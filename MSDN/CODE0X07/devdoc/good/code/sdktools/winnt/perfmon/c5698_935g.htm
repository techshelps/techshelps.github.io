<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SYSTEM.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5704"></a>SYSTEM.C</h2>
<pre><code>// <br>//  Foreign computer support needs more work (a-robw) <br>// <br>#ifdef FOREIGN_COMPUTER_SUPPORT <br>#undef FOREIGN_COMPUTER_SUPPORT <br>#endif <br> <br>#include "perfmon.h" <br>#include "system.h"     // external declarations for this file <br> <br>#include "perfdata.h" <br>#include "perfmops.h" <br>#include "playback.h"   // for PlayingBackLog <br>#include "pmemory.h" <br>#include "utils.h"      // for strsame, et al <br>#include "sizes.h" <br> <br> <br>DWORD <br>SystemCount( <br>    PPERFSYSTEM pSystemFirst <br>) <br>{ <br>    PPERFSYSTEM       pSystem ; <br>    DWORD           iNumSystems ; <br> <br>    iNumSystems = 0 ; <br> <br>    for (pSystem = pSystemFirst ; <br>         pSystem ; <br>         pSystem = pSystem-&gt;pSystemNext) { <br>        iNumSystems++ ; <br>    } <br> <br>    return iNumSystems ; <br>} <br> <br>  <br>BOOL <br>SystemSetupThread (PPERFSYSTEM pSystem) <br>{ <br>    DWORD           dwThreadID ; <br>    HANDLE          hThread ; <br>    HANDLE          hStateDataMutex ; <br>    HANDLE          hPerfDataEvent ; <br>    SECURITY_ATTRIBUTES  SecAttr ; <br>    PPERFDATA       pSystemPerfData ; <br> <br> <br>    SecAttr.nLength = sizeof (SecAttr) ; <br>    SecAttr.bInheritHandle = TRUE ; <br>    SecAttr.lpSecurityDescriptor = NULL ; <br> <br>    hThread = CreateThread (&amp;SecAttr, 1024L,  <br>        (LPTHREAD_START_ROUTINE)PerfDataThread, (LPVOID)(pSystem), 0L, &amp;dwThreadID); <br> <br>    if (!hThread) { <br>        SystemFree (pSystem, TRUE); <br>        return (FALSE) ; <br>    } <br> <br>    // create a State Data Lock mutex <br>    hStateDataMutex = CreateMutex (&amp;SecAttr, FALSE, NULL); <br>    if (!hStateDataMutex) { <br>        CloseHandle (hThread) ; <br>        SystemFree (pSystem, TRUE); <br>        return (FALSE); <br>    } <br>    hPerfDataEvent = CreateEvent (&amp;SecAttr, TRUE, 0L, NULL) ; <br>    if (!hPerfDataEvent) { <br>        CloseHandle (hStateDataMutex) ; <br>        CloseHandle (hThread) ; <br>        SystemFree (pSystem, TRUE); <br>        return (FALSE); <br>    } <br>     <br>    // allocate Perfdata <br>    pSystemPerfData = (PPERFDATA) MemoryAllocate (4096L) ; <br>    if (!pSystemPerfData) { <br>        CloseHandle (hPerfDataEvent) ; <br>        CloseHandle (hStateDataMutex) ; <br>        CloseHandle (hThread) ; <br>        SystemFree (pSystem, TRUE); <br>        return (FALSE); <br>    } <br>    // now setup the pSystem.. <br>    pSystem-&gt;dwThreadID = dwThreadID ; <br>    pSystem-&gt;hThread = hThread ; <br>    pSystem-&gt;hPerfDataEvent = hPerfDataEvent ; <br>    pSystem-&gt;pSystemPerfData = pSystemPerfData ; <br>    pSystem-&gt;hStateDataMutex = hStateDataMutex ; <br> <br>    return (TRUE) ; <br>} <br>  <br>PPERFSYSTEM <br>SystemCreate ( <br>    LPCTSTR lpszSystemName <br>) <br>{ <br>    PPERFSYSTEM     pSystem ; <br>    PPERFDATA       pLocalPerfData; <br>    DWORD           Status ; <br>    DWORD           dwMemSize; <br>    TCHAR           GlobalValueBuffer[] = L"Global" ; <br>    TCHAR           ForeignValueBuffer[8+MAX_SYSTEM_NAME_LENGTH+1] = <br>                    L"Foreign " ; <br> <br>    // attempt to allocate system data structure <br> <br>    pSystem = MemoryAllocate (sizeof (PERFSYSTEM)) ; <br>    if (!pSystem) { <br>        SetLastError (ERROR_OUTOFMEMORY) ; <br>        return (NULL) ; <br>    } <br> <br>    // initialize name and help table pointers <br> <br>    pSystem-&gt;CounterInfo.pNextTable = NULL; <br>    pSystem-&gt;CounterInfo.dwLangId = 0; <br>    pSystem-&gt;CounterInfo.dwLastId = 0; <br>    pSystem-&gt;CounterInfo.TextString = NULL; <br> <br>    lstrcpy (pSystem-&gt;sysName, lpszSystemName) ; <br>    <br>    // try to open key to registry, error code is in GetLastError() <br> <br>    pSystem-&gt;sysDataKey = OpenSystemPerfData(lpszSystemName); <br> <br>    // if a Null Key was returned then: <br>    //  a) there's no such computer <br>    //  b) the system is a foreign computer <br>    // <br>    //  before giving up, then see if it's a foreign computer <br> <br>    if (!pSystem-&gt;sysDataKey) { <br>         <br>        // build foreign computer string <br> <br>        lstrcat(ForeignValueBuffer, lpszSystemName) ; <br>         <br>        // assign System value name pointer to the local variable for trial <br> <br>        pSystem-&gt;lpszValue = ForeignValueBuffer; <br> <br>        // try to get data from the computer to see if it's for real <br>        // otherwise, give up and return NULL <br> <br>        pLocalPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE); <br>        if (pLocalPerfData == NULL) { // no mem so give up <br>            SetLastError (ERROR_OUTOFMEMORY); <br>            pSystem-&gt;lpszValue = NULL; <br>            SystemFree (pSystem, TRUE); <br>            return (NULL); <br>        } else { <br>            pSystem-&gt;sysDataKey = HKEY_PERFORMANCE_DATA; // local machine <br>            bCloseLocalMachine = TRUE ; <br> <br>            dwMemSize = STARTING_SYSINFO_SIZE; <br>            Status = GetSystemPerfData ( <br>                    pSystem-&gt;sysDataKey, <br>                    pSystem-&gt;lpszValue, <br>                    pLocalPerfData, <br>                    &amp;dwMemSize); <br> <br>            // success means a valid buffer came back <br>            // more data means someone tried (so it's probably good (?) <br> <br>            if (!((Status == ERROR_MORE_DATA) || (Status == ERROR_SUCCESS)) || <br>                !((pLocalPerfData-&gt;Signature[0] == (WCHAR)'P') &amp;&amp; <br>                  (pLocalPerfData-&gt;Signature[1] == (WCHAR)'E') &amp;&amp; <br>                  (pLocalPerfData-&gt;Signature[2] == (WCHAR)'R') &amp;&amp; <br>                  (pLocalPerfData-&gt;Signature[3] == (WCHAR)'F'))) { <br>                MemoryFree (pLocalPerfData) ; <br> <br>                // if we are reading from a setting file, let this pass thru' <br>                if (bDelayAddAction == TRUE) { <br>                   pSystem-&gt;sysDataKey = NULL ; <br>                   pSystem-&gt;FailureTime = GetTickCount(); <br>                   pSystem-&gt;dwSystemState = SYSTEM_DOWN; <br> <br>                   // Free any memory that may have created <br>                   SystemFree (pSystem, FALSE) ; <br> <br>                   pSystem-&gt;lpszValue = MemoryAllocate (TEMP_BUF_LEN*sizeof(WCHAR)); <br>   <br>                   if (!pSystem-&gt;lpszValue) { <br>                      // unable to allocate memory <br>                      SetLastError (ERROR_OUTOFMEMORY); <br>                      SystemFree (pSystem, TRUE); <br>                      return (NULL) ; <br>                   } else { <br>                      lstrcpy (pSystem-&gt;lpszValue, GlobalValueBuffer); <br>                   } <br> <br>                   // Setup the thread's stuff <br>                   if (SystemSetupThread (pSystem)) <br>                      return (pSystem) ; <br>                   else  <br>                      return NULL; <br>                } <br>                SetLastError (ERROR_BAD_NET_NAME); // unable to find name <br>                SystemFree (pSystem, TRUE); <br>                return NULL; <br>            } <br> <br>            MemoryFree (pLocalPerfData);    // don't really need anything from it <br>     <br>            // ok, so we've established that a foreign data provider <br>            // exists, now to finish the initialization. <br> <br>            // change system name in structure to get counter names <br> <br>            lstrcpy (pSystem-&gt;sysName, LocalComputerName); <br> <br>            Status = GetSystemNames(pSystem);   // get counter names &amp; explain text <br>            if (Status != ERROR_SUCCESS) { <br>                // unable to get names so bail out <br>                SetLastError (Status); <br>                SystemFree (pSystem, TRUE); <br>                return (NULL) ; <br>            } <br> <br>            // restore computer name for displays, etc. <br> <br>            lstrcpy (pSystem-&gt;sysName, lpszSystemName); <br>     <br>            // allocate value string buffer <br>            pSystem-&gt;lpszValue = MemoryAllocate (TEMP_BUF_LEN*sizeof(WCHAR)); <br>            if (!pSystem-&gt;lpszValue) { <br>                // unable to allocate memory <br>                SetLastError (ERROR_OUTOFMEMORY); <br>                SystemFree (pSystem, TRUE); <br>                return (NULL) ; <br>            } else { <br>                lstrcpy (pSystem-&gt;lpszValue, ForeignValueBuffer); <br>            } <br>        } <br>    } else { <br>        // if here, then a connection to the system's registry was established <br>        // so continue with the system data structure initialization <br> <br>        // get counter names &amp; explain text from local computer <br> <br>        Status = GetSystemNames(pSystem);    <br>        if (Status != ERROR_SUCCESS) { <br>            // unable to get names so bail out <br>            SetLastError (Status); <br>            SystemFree (pSystem, TRUE); <br>            return (NULL) ; <br>        } <br> <br>        // allocate value string buffer <br>        pSystem-&gt;lpszValue = MemoryAllocate(TEMP_BUF_LEN*sizeof(WCHAR)); <br> <br>        if (!pSystem-&gt;lpszValue) { <br>            // unable to allocate memory <br>            SetLastError (ERROR_OUTOFMEMORY); <br>            SystemFree (pSystem, TRUE); <br>            return (NULL) ; <br>        } else { <br>            SetSystemValueNameToGlobal (pSystem); <br>        } <br>    } <br> <br>    // initialize remaining system pointers <br> <br>    pSystem-&gt;pSystemNext = NULL ; <br>    pSystem-&gt;FailureTime = 0; <br> <br>    // setup data for thread data collection <br>    if (!PlayingBackLog()) { <br>        // create a thread for data collection <br>        if (!SystemSetupThread (pSystem)) <br>           return (NULL) ; <br>    }  <br> <br>    SetLastError (ERROR_SUCCESS); <br> <br>    return (pSystem) ; <br>}  // SystemCreate <br>  <br>PPERFSYSTEM <br>SystemGet ( <br>    PPERFSYSTEM pSystemFirst, <br>    LPCTSTR lpszSystemName <br>) <br>{ <br>    PPERFSYSTEM       pSystem ; <br> <br>    if (!pSystemFirst) { <br>        return (NULL) ; <br>    } <br>     <br>    for (pSystem = pSystemFirst ; <br>         pSystem ; <br>         pSystem = pSystem-&gt;pSystemNext) { <br>        if (strsamei (pSystem-&gt;sysName, lpszSystemName)) { <br>            return (pSystem) ; <br>        } <br>    }  // for <br> <br>    return (NULL) ; <br>} <br>  <br>PPERFSYSTEM <br>SystemAdd ( <br>    PPPERFSYSTEM ppSystemFirst, <br>    LPCTSTR lpszSystemName <br>) <br>{ <br>    PPERFSYSTEM       pSystem ; <br>    PPERFSYSTEM       pSystemPrev ; <br> <br> <br>    if (!*ppSystemFirst) { <br>        *ppSystemFirst = SystemCreate (lpszSystemName) ; <br>        return (*ppSystemFirst) ; <br>    } <br> <br>    for (pSystem = *ppSystemFirst ; <br>         pSystem ; <br>         pSystem = pSystem-&gt;pSystemNext) { <br>        pSystemPrev = pSystem ; <br>        if (strsamei (pSystem-&gt;sysName, lpszSystemName)) { <br>            return (pSystem) ; <br>        } <br>    }  // for <br> <br>    pSystemPrev-&gt;pSystemNext = SystemCreate (lpszSystemName) ; <br>    return (pSystemPrev-&gt;pSystemNext) ; <br>} <br>  <br>void <br>SystemFree ( <br>    PPERFSYSTEM pSystem, <br>    BOOL        bDeleteTheSystem <br>) <br>{  // SystemFree <br> <br>    PCOUNTERTEXT pCounter, pNextCounter; <br> <br>    if (!pSystem) { <br>        // can't proceed <br>        return ; <br>    } <br> <br>    if (pSystem-&gt;sysDataKey &amp;&amp; pSystem-&gt;sysDataKey != HKEY_PERFORMANCE_DATA) { <br>        // close the remote computer key <br>        RegCloseKey (pSystem-&gt;sysDataKey); <br>        pSystem-&gt;sysDataKey = 0 ; <br>    } <br> <br>    for (pCounter = pSystem-&gt;CounterInfo.pNextTable, pNextCounter = NULL; <br>         pCounter; <br>         pCounter = pNextCounter) { <br>        pNextCounter = pCounter-&gt;pNextTable; <br>        MemoryFree (pCounter); <br>    } <br>    pSystem-&gt;CounterInfo.pNextTable = NULL ; <br> <br>    if (pSystem-&gt;CounterInfo.TextString) { <br>        MemoryFree (pSystem-&gt;CounterInfo.TextString); <br>        pSystem-&gt;CounterInfo.TextString = NULL ; <br>    } <br> <br>    if (pSystem-&gt;CounterInfo.HelpTextString) { <br>        MemoryFree (pSystem-&gt;CounterInfo.HelpTextString); <br>        pSystem-&gt;CounterInfo.HelpTextString = NULL ; <br>    } <br>    pSystem-&gt;CounterInfo.dwLastId = 0 ; <br>    pSystem-&gt;CounterInfo.dwHelpSize = 0 ; <br>    pSystem-&gt;CounterInfo.dwCounterSize = 0 ; <br> <br>    if (bDeleteTheSystem) { <br>#if 0 <br>        // cleanup all the data collection variables <br>        if (pSystem-&gt;hPerfDataEvent) <br>            CloseHandle (pSystem-&gt;hPerfDataEvent) ; <br> <br>        if (pSystem-&gt;hStateDataMutex) <br>            CloseHandle (pSystem-&gt;hStateDataMutex) ; <br> <br>        if (pSystem-&gt;hThread) <br>            CloseHandle (pSystem-&gt;hThread) ; <br> <br>        if (pSystem-&gt;pSystemPerfData) <br>            MemoryFree (pSystem-&gt;pSystemPerfData); <br> <br>        if (pSystem-&gt;lpszValue) { <br>            MemoryFree (pSystem-&gt;lpszValue); <br>            pSystem-&gt;lpszValue = NULL ; <br>        } <br>        MemoryFree (pSystem) ; <br>#endif <br>        if (pSystem-&gt;hThread) { <br>            // let the thread clean up memory <br>            PostThreadMessage ( <br>               pSystem-&gt;dwThreadID, <br>               WM_FREE_SYSTEM, <br>               (WPARAM)0, <br>               (LPARAM)0) ; <br>        } else { <br>            // if no thread, clean up memory here. <br>            // Should not happen. <br>            if (pSystem-&gt;pSystemPerfData) <br>                MemoryFree (pSystem-&gt;pSystemPerfData); <br> <br>            if (pSystem-&gt;lpszValue) { <br>                MemoryFree (pSystem-&gt;lpszValue); <br>                pSystem-&gt;lpszValue = NULL ; <br>            } <br>            MemoryFree (pSystem) ; <br>        } <br>    } <br>} <br>  <br>void <br>DeleteUnusedSystems ( <br>    PPPERFSYSTEM  ppSystemFirst , <br>    int           iNoUseSystems <br>) <br>{ <br>    PPERFSYSTEM   pPrevSys, pCurrentSys, pNextSys ; <br> <br>    // delete all the marked system from the list header until <br>    // we hit one that is not marked <br>    while ((*ppSystemFirst)-&gt;bSystemNoLongerNeeded) { <br>       // delect from the list header <br>       pCurrentSys = *ppSystemFirst ; <br>       *ppSystemFirst = pCurrentSys-&gt;pSystemNext ; <br>       SystemFree (pCurrentSys, TRUE) ; <br>       iNoUseSystems-- ; <br>       if (iNoUseSystems &lt;= 0 || !(*ppSystemFirst)) { <br>          // done <br>          break ; <br>       } <br>    } <br> <br>    if (iNoUseSystems &lt;= 0 || !(*ppSystemFirst)) { <br>       return ; <br>    } <br> <br>    // now walk the list and delete each marked system <br>    for (pPrevSys = *ppSystemFirst, pCurrentSys = pPrevSys-&gt;pSystemNext ; <br>         pCurrentSys &amp;&amp; iNoUseSystems &gt; 0 ; <br>         pCurrentSys = pNextSys) { <br> <br>       if (pCurrentSys-&gt;bSystemNoLongerNeeded) { <br>          // the current system is marked, updated the list and free <br>          // this system.  No need to change pPrevSys here <br>          pNextSys = pPrevSys-&gt;pSystemNext = pCurrentSys-&gt;pSystemNext ; <br>          SystemFree (pCurrentSys, TRUE) ; <br>          iNoUseSystems-- ; <br>       } else { <br>          // pCurrentSys is OK, update the 2 list pointers and  <br>          // carry on looping <br>          pPrevSys = pCurrentSys ; <br>          pNextSys = pCurrentSys-&gt;pSystemNext ; <br>       } <br>    } <br>} <br>  <br>void <br>FreeSystems ( <br>    PPERFSYSTEM pSystemFirst <br>) <br>{ <br>    PPERFSYSTEM    pSystem, pSystemNext ; <br> <br> <br>    for (pSystem = pSystemFirst;  <br>         pSystem;  <br>         pSystem = pSystemNext) { <br>        pSystemNext = pSystem-&gt;pSystemNext ; <br>        SystemFree (pSystem, TRUE) ; <br>    } <br>}  // FreeSystems <br>  <br>PPERFSYSTEM <br>GetComputer ( <br>    HDLG hDlg, <br>    WORD wControlID, <br>    BOOL bWarn, <br>    PPERFDATA *ppPerfData, <br>    PPERFSYSTEM *ppSystemFirst <br>) <br>/* <br>   Effect:        Attempt to set the current computer to the one in the <br>                  hWndComputers dialog edit box. If this computer system <br>                  can be found, load the objects, etc. for the computer <br>                  and set pSystem and ppPerfdata to the values for this <br>                  system. <br>*/ <br>{  // GetComputer <br>    TCHAR          szComputer [MAX_SYSTEM_NAME_LENGTH + 1] ; <br>    PPERFSYSTEM    pSystem; <br>    TCHAR          tempBuffer [LongTextLen] ; <br>    DWORD          dwBufferSize ; <br>    LPTSTR         pBuffer = NULL ; <br> <br>    DialogText (hDlg, wControlID, szComputer) ; <br> <br>    // If necessary, add the system to the lists for this view. <br>    pSystem = SystemGet (*ppSystemFirst, szComputer) ; <br>    if (!pSystem) { <br>        pSystem = SystemAdd (ppSystemFirst, szComputer) ; <br>    } <br> <br>    if (!pSystem &amp;&amp; bWarn) { <br>        DialogSetString (hDlg, wControlID, LocalComputerName) ; <br> <br>        // Note: this will succeed since the local computer is always <br>        // available <br>        EditSetModified (GetDlgItem(hDlg, wControlID), FALSE) ; <br>     <br>        pSystem = SystemGet (*ppSystemFirst, LocalComputerName) ; <br>        if (!pSystem) { <br>            pSystem = SystemAdd (ppSystemFirst, LocalComputerName) ; <br>        } <br> <br>//        MessageBoxResource (hDlg, IDS_COMPUTERNOTFOUND, IDS_APPNAME, MB_OK) ; <br>        DlgErrorBox (hDlg, ERR_COMPUTERNOTFOUND) ; <br> <br>        SetFocus (DialogControl(hDlg, wControlID)) ; <br>    } <br> <br>    if (pSystem) { <br>        if (PlayingBackLog ()) { <br>            *ppPerfData = <br>            LogDataFromPosition (pSystem, &amp;(PlaybackLog.StartIndexPos)) ; <br>        } else { <br> <br>            if (pSystem-&gt;lpszValue) { <br>               // save the previous lpszValue string before  <br>               // SetSystemValueNameToGlobal screw it up <br>               dwBufferSize = MemorySize (pSystem-&gt;lpszValue) ; <br>               if (dwBufferSize &lt;= sizeof(tempBuffer)) { <br>                  pBuffer = tempBuffer ; <br>               } else { <br>                  pBuffer = MemoryAllocate (dwBufferSize) ; <br>               } <br>               memcpy (pBuffer, pSystem-&gt;lpszValue, dwBufferSize) ; <br>            } <br> <br>            SetSystemValueNameToGlobal (pSystem); <br>            UpdateSystemData (pSystem, ppPerfData) ; <br> <br>            if (pSystem-&gt;lpszValue) { <br>               // retore the previous lpszValue string <br>               memcpy (pSystem-&gt;lpszValue, pBuffer, dwBufferSize) ; <br>               if (pBuffer != tempBuffer) { <br>                  MemoryFree (pBuffer) ; <br>               } <br>            } <br>        } <br>    } <br>    return (pSystem) ; <br> <br>}  // GetComputer </code></pre>
<p>&nbsp;</p></body>
</HTML>
