<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5671"></a>LINE.C</h2>
<pre><code><br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include "perfmon.h"    // included by all source files <br>#include "line.h"       // external declarations for this file <br>//#include &lt;tchar.h&gt;      // for _tcsncpy <br> <br>#include "fileutil.h"   // for FileRead, FileWrite <br>#include "pmemory.h"     // for MemoryXXX (mallloc-type) routines <br>#include "perfdata.h"   // for UpdateSystemData, et al <br>#include "perfmops.h"   // for InsertLine <br>#include "system.h"     // for SystemAdd <br>#include "utils.h" <br>#include "playback.h"   // for PlayingBackLog <br>#include "counters.h"   // CounterEntry <br> <br>#include &lt;string.h&gt;     // for strncpy <br>#ifdef UNICODE <br>#define _tcsncpywcsncpy <br>#else <br>#define _tcsncpystrncpy <br>#endif <br> <br>TCHAR LOCAL_SYS_CODE_NAME[] = TEXT("....") ; <br>#define  sizeofCodeName sizeof(LOCAL_SYS_CODE_NAME) / sizeof(TCHAR) - 1 <br> <br>// Local Function prototype <br>PLINE ReadLine (PPERFSYSTEM *ppSystem, <br>                PPPERFSYSTEM ppSystemFirst, <br>                PPERFDATA *ppPerfData,  <br>                HANDLE hFile, <br>                int LineType, <br>                PDISKLINE  *ppDiskLine, <br>                DWORD *pSizeofDiskLine) ; <br> <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>PLINE LineAllocate (void) <br>/* <br>   Effect:        Allocate and initialize a Line data structure. Lines <br>                  are used as the primary elements of both charts and <br>                  alerts. <br> <br>                  Establish any representation invariants for the Line <br>                  type. <br> <br>                  Also alllocate another structure, an array of data <br>                  elements, iNumDataValues long. <br>*/ <br>   {  // LineAllocate <br>   PLINE          pLine ; <br> <br>   pLine = MemoryAllocate (sizeof (LINESTRUCT)) ; <br> <br>   if (pLine) <br>      { <br>//  don't need to zero these again since MemoryAllocate is using <br>//  GMEM_ZEROPOINT <br>//      pLine-&gt;pLineNext = NULL ; <br>//      pLine-&gt;pLineCounterNext = NULL ; <br> <br>      // do want to do this since (FLOAT)0.0 is not 0 <br>      pLine-&gt;lnMinValue = <br>      pLine-&gt;lnMaxValue = <br>      pLine-&gt;lnAveValue = (FLOAT) 0.0 ; <br> <br>      if (PlayingBackLog()) <br>         { <br>         pLine-&gt;bFirstTime = FALSE ; <br>         } <br>      else <br>         { <br>//         pLine-&gt;bFirstTime = TRUE ; <br>         // we want to take 2 samples before plotting the first data <br>         pLine-&gt;bFirstTime = 2 ; <br>         } <br>      }  // if <br> <br>   return (pLine) ; <br>   }  // LineAllocate <br> <br> <br>void LineFree (PLINE pLine) <br>   {  // LineFree <br>   // free any memory allocated by this line <br>   if (pLine-&gt;lnSystemName) <br>      MemoryFree (pLine-&gt;lnSystemName) ; <br> <br>   if (pLine-&gt;lnObjectName) <br>      MemoryFree (pLine-&gt;lnObjectName) ; <br> <br>   if (pLine-&gt;lnCounterName) <br>      MemoryFree (pLine-&gt;lnCounterName) ; <br> <br>   if (pLine-&gt;lnInstanceName) <br>      MemoryFree (pLine-&gt;lnInstanceName) ; <br> <br>   if (pLine-&gt;lnParentObjName) <br>      MemoryFree (pLine-&gt;lnParentObjName) ; <br> <br>   if (pLine-&gt;lnPINName) <br>      MemoryFree (pLine-&gt;lnPINName) ; <br> <br>   if (pLine-&gt;lpszAlertProgram) <br>      MemoryFree (pLine-&gt;lpszAlertProgram) ; <br> <br>   if (pLine-&gt;hPen) <br>      DeletePen(pLine-&gt;hPen); <br> <br>   if (pLine-&gt;hBrush) <br>      DeletePen(pLine-&gt;hBrush); <br> <br>   if (pLine-&gt;lnValues) <br>      MemoryFree (pLine-&gt;lnValues) ; <br> <br>   if (pLine-&gt;aiLogIndexes) <br>      MemoryFree (pLine-&gt;aiLogIndexes) ; <br> <br>   MemoryFree (pLine) ; <br>   }  // LineFree <br> <br> <br> <br>void LineAppend (PPLINE ppLineFirst,  <br>                 PLINE pLineNew) <br>   { <br>   PLINE          pLine ; <br> <br>   if (!*ppLineFirst) <br>      *ppLineFirst = pLineNew ; <br>   else   <br>      {  // else <br>      for (pLine = *ppLineFirst ; <br>           pLine-&gt;pLineNext ; <br>           pLine = pLine-&gt;pLineNext) <br>         /* nothing */ ; <br>      pLine-&gt;pLineNext = pLineNew ; <br>      }  // else <br>   } <br> <br> <br> <br>BOOL LineRemove (PPLINE ppLineFirst, <br>                 PLINE pLineRemove) <br>   { <br>   PLINE          pLine ; <br> <br>   if (*ppLineFirst == pLineRemove) <br>      { <br>      *ppLineFirst = (*ppLineFirst)-&gt;pLineNext ; <br>      return (TRUE) ; <br>      } <br> <br>   for (pLine = *ppLineFirst ; <br>        pLine-&gt;pLineNext ; <br>        pLine = pLine-&gt;pLineNext) <br>      {   // for <br>      if (pLine-&gt;pLineNext == pLineRemove) <br>         { <br>         pLine-&gt;pLineNext = pLineRemove-&gt;pLineNext ; <br>         return (TRUE) ; <br>         }  // if <br>      }  // for <br> <br>   return (FALSE) ; <br>   }  // LineRemove <br> <br> <br> <br>int NumLines (PLINE pLineFirst) <br>   {  // NumLines <br>   PLINE          pLine ; <br>   int            iNumLines ; <br> <br>   if (!pLineFirst) <br>      return (0) ; <br> <br>   <br>   iNumLines = 0 ; <br>   for (pLine = pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      iNumLines++ ; <br>      }  // for <br> <br> <br>   return (iNumLines) ; <br>   }  // NumLines <br> <br> <br> <br>LPTSTR LineInstanceName (PLINE pLine) <br>   { <br>   if (pLine-&gt;lnObject.NumInstances &lt;= 0) <br>      return (NULL) ; <br>   else <br>      return (pLine-&gt;lnInstanceName) ; <br>   } <br> <br> <br>LPTSTR LineParentName (PLINE pLine) <br>   { <br>   if (pLine-&gt;lnObject.NumInstances &lt;= 0) <br>      return (NULL) ; <br>   else if (pLine-&gt;lnInstanceDef.ParentObjectTitleIndex) <br>      return (pLine-&gt;lnPINName) ; <br>   else <br>      return (NULL) ; <br>   } <br> <br> <br> <br>void LineCounterAppend (PPLINE ppLineFirst,  <br>                        PLINE pLineNew) <br>   { <br>   PLINE          pLine ; <br> <br>   if (!*ppLineFirst) <br>      *ppLineFirst = pLineNew ; <br>   else   <br>      {  // else <br>      for (pLine = *ppLineFirst ; <br>           pLine-&gt;pLineCounterNext ; <br>           pLine = pLine-&gt;pLineCounterNext) <br>         /* nothing */ ; <br>      pLine-&gt;pLineCounterNext = pLineNew ; <br>      }  // else <br>   } <br> <br> <br> <br>BOOL EquivalentLine (PLINE pLine1, <br>                     PLINE pLine2) <br>   {  // LineEquivalent <br>   return (pstrsame (pLine1-&gt;lnCounterName, pLine2-&gt;lnCounterName) &amp;&amp; <br>           pstrsame (pLine1-&gt;lnInstanceName, pLine2-&gt;lnInstanceName) &amp;&amp; <br>           pstrsame (pLine1-&gt;lnPINName, pLine2-&gt;lnPINName) &amp;&amp; <br>           pstrsame (pLine1-&gt;lnObjectName, pLine2-&gt;lnObjectName) &amp;&amp; <br>           pstrsamei (pLine1-&gt;lnSystemName, pLine2-&gt;lnSystemName)) ; <br>   }  // LineEquivalent <br> <br> <br>PLINE FindEquivalentLine (PLINE pLineToFind, <br>                          PLINE pLineFirst) <br>   { <br>   PLINE          pLine ; <br> <br>   for (pLine = pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      if (EquivalentLine (pLine, pLineToFind)) <br>         return (pLine) ; <br>      }  // for <br> <br>   return (NULL) ; <br>   }  // FindEquivalentLine <br> <br>// This routine is used only to read the system name from a disk string <br>// It is mainly for performance improvement. <br>LPTSTR DiskStringReadSys (PDISKSTRING pDS) <br>   {  // DiskStringReadSys <br>   LPTSTR         lpszText ; <br>   LPTSTR         pDiskSysName ; <br>   int            iIndex ; <br>   BOOL           bLocalSysName = FALSE ; <br> <br>   if (pDS-&gt;dwLength == 0) <br>      { <br>      return (NULL) ; <br>      } <br> <br>   if (pDS-&gt;dwLength == sizeofCodeName) <br>      { <br>      // check for LOCAL_SYS_CODE_NAME <br>      bLocalSysName = TRUE ; <br>      pDiskSysName = (LPTSTR)((PBYTE) pDS + pDS-&gt;dwOffset) ; <br>      for (iIndex = 0 ; iIndex &lt; sizeofCodeName; iIndex++, pDiskSysName++) <br>         { <br>         if (*pDiskSysName != LOCAL_SYS_CODE_NAME[iIndex]) <br>            { <br>            bLocalSysName = FALSE ; <br>            break ; <br>            } <br>         } <br>      } <br> <br>   if (bLocalSysName) <br>      { <br>      lpszText = <br>         MemoryAllocate ((lstrlen(LocalComputerName)+1) * sizeof(TCHAR)) ; <br>      if (lpszText) <br>         { <br>         lstrcpy (lpszText, LocalComputerName) ; <br>         } <br>      } <br>   else <br>      { <br>      lpszText = MemoryAllocate (sizeof (TCHAR) * (pDS-&gt;dwLength + 1)) ; <br>      if (lpszText) <br>         { <br>         _tcsncpy ((WCHAR *)lpszText, (WCHAR *)((PBYTE) pDS + pDS-&gt;dwOffset), <br>                  pDS-&gt;dwLength) ; <br>         } <br>      } <br> <br>   return (lpszText) ; <br>   }  // DiskStringReadSys <br> <br> <br> <br>LPTSTR DiskStringRead (PDISKSTRING pDS) <br>   {  // DiskStringRead <br>   LPTSTR         lpszText ; <br> <br>   if (pDS-&gt;dwLength == 0) <br>      { <br>      return (NULL) ; <br>      } <br> <br>   lpszText = MemoryAllocate (sizeof (TCHAR) * (pDS-&gt;dwLength + 1)) ; <br>   if (!lpszText) <br>      { <br>      return (NULL) ; <br>      } <br> <br>   _tcsncpy ((WCHAR *)lpszText, (WCHAR *)((PBYTE) pDS + pDS-&gt;dwOffset), <br>            pDS-&gt;dwLength) ; <br> <br>   return (lpszText) ; <br>   }  // DiskStringRead <br> <br> <br>int DiskStringLength (LPTSTR lpszText) <br>   { <br>   if (!lpszText) <br>      return (0) ; <br>   else <br>      return (lstrlen (lpszText)) ; <br>   } <br> <br>PBYTE DiskStringCopy (PDISKSTRING pDS, LPTSTR lpszText, PBYTE pNextFree) <br>   { <br>   if (!lpszText) <br>      { <br>      pDS-&gt;dwOffset = 0 ; <br>      pDS-&gt;dwLength = 0 ; <br>      return (pNextFree) ; <br>      } <br>   else <br>      { <br>      pDS-&gt;dwOffset = pNextFree - (PBYTE) pDS ; <br>      pDS-&gt;dwLength = DiskStringLength (lpszText) ; <br>      _tcsncpy ((WCHAR *)pNextFree, (WCHAR *)lpszText, pDS-&gt;dwLength) ; <br>      return (pNextFree + pDS-&gt;dwLength * sizeof(TCHAR)) ; <br>      } <br>   }  // DiskStringCopy <br>    <br> <br>void CounterName (PPERFSYSTEM pSystem,  <br>                  PPERFCOUNTERDEF pCounter,  <br>                  LPTSTR lpszCounter) <br>   {  // CounterName <br>//!!   strclr (lpszCounter) ; <br>   lpszCounter [0] = TEXT('\0') ; <br>   QueryPerformanceName (pSystem,  <br>                         pCounter-&gt;CounterNameTitleIndex,  <br>                         0, 256, <br>                         lpszCounter, <br>                         FALSE) ; <br>   }  // CounterName <br> <br> <br> <br>PPERFOBJECT LineFindObject (PPERFSYSTEM pSystem, <br>                            PPERFDATA pPerfData, <br>                            PLINE pLine) <br>/* <br>   Effect:        Set the lnObject field of pLine to the object with the <br>                  name of lnObjectName, and return TRUE. Return FALSE if <br>                  there is no such object. <br>*/ <br>   {  // LineFindObject <br>   PPERFOBJECT    pObject ; <br> <br>   pObject = GetObjectDefByName (pSystem, pPerfData, pLine-&gt;lnObjectName) ; <br>    <br>   if (pObject) <br>      { <br>      pLine-&gt;lnObject = *pObject ; <br>      return (pObject) ; <br>      } <br>   else <br>      return (NULL) ; <br>   }  // LineFindObject <br>    <br> <br> <br>PPERFCOUNTERDEF LineFindCounter (PPERFSYSTEM pSystem, <br>                                 PPERFOBJECT pObject, <br>                                 PPERFDATA pPerfData, <br>                                 PLINE pLine) <br>   {  // LineFindCounter <br>   UINT               i ; <br>   PPERFCOUNTERDEF   pCounter ; <br>   TCHAR             szCounter [256] ; <br> <br>   for (i = 0, pCounter = FirstCounter (pObject) ; <br>        i &lt; pObject-&gt;NumCounters ; <br>        i++, pCounter = NextCounter (pCounter)) <br>      {  // for <br>      CounterName (pSystem, pCounter, szCounter) ; <br>      if (strsame (szCounter, pLine-&gt;lnCounterName)) <br>         { <br>         pLine-&gt;lnCounterDef = *pCounter ; <br>         return (pCounter) ; <br>         }  // if <br>      }  // for <br> <br>   return (NULL) ; <br>   }  // LineFindCounter <br> <br>                       <br>PPERFINSTANCEDEF LineFindInstance (PPERFDATA pPerfData, <br>                                   PPERFOBJECT pObject, <br>                                   PLINE pLine) <br>   {  // LineFindInstance <br>   <br>                                    <br>   PPERFINSTANCEDEF  pInstance = NULL ; <br> <br>   if ((pObject-&gt;NumInstances &gt; 0) &amp;&amp; pLine-&gt;lnInstanceName) <br>      { <br>      // instances exist, find the right one <br>       <br>      if (pLine-&gt;lnUniqueID != PERF_NO_UNIQUE_ID) <br>         { <br>         pInstance = GetInstanceByUniqueID(pObject, pLine-&gt;lnUniqueID) ; <br>         } <br>      else <br>         { <br>         pInstance = GetInstanceByName(pPerfData, pObject, <br>                        pLine-&gt;lnInstanceName, pLine-&gt;lnPINName) ; <br>         } <br>      } <br> <br>   if (pInstance) <br>      { <br>      pLine-&gt;lnInstanceDef = *pInstance ; <br>      } <br> <br>   return (pInstance) ; <br>   }  // LineFindInstance <br> <br> <br> <br> <br>void ReadLines (HANDLE hFile, <br>                DWORD dwNumLines, <br>                PPPERFSYSTEM ppSystemFirst, <br>                PPLINE ppLineFirst, <br>                int LineType) <br>   { <br>   DWORD          i ; <br>   PPERFDATA      pPerfData ; <br>   PLINE          pLine ; <br>   PPERFSYSTEM    pSystem ; <br>   PDISKLINE      pDiskLine = NULL ; <br>   DWORD          SizeofDiskLine = 0 ;  // bytes in pDiskLine <br> <br> <br>   pPerfData = AllocatePerfData () ; <br>   pSystem = *ppSystemFirst ; <br> <br>#if 0 <br>   if (!pSystem) <br>      { <br>      pSystem = SystemAdd (ppSystemFirst, LocalComputerName) ; <br>      pSystem = *ppSystemFirst ; //!! <br>      } <br> <br>   UpdateSystemData (pSystem, &amp;pPerfData) ; <br>#endif <br>   pDiskLine = MemoryAllocate (FilePathLen) ; <br>   if (!pDiskLine) <br>      { <br>      // no memory to begin with, forget it <br>      DlgErrorBox (hWndMain, ERR_NO_MEMORY) ; <br>      return ; <br>      } <br>   SizeofDiskLine = FilePathLen ; <br> <br>   for (i = 0 ; <br>        i &lt; dwNumLines ; <br>        i++) <br>      { <br>      pLine = ReadLine (&amp;pSystem, ppSystemFirst, &amp;pPerfData, hFile, <br>            LineType, &amp;pDiskLine, &amp;SizeofDiskLine) ; <br>      if (pLine) <br>         { <br>         if (InsertLine (pLine) == FALSE) <br>            { <br>            // no inert occurred due to either line already existed <br>            // or error detected. <br>            LineFree (pLine) ; <br>            } <br>         } <br>      } <br>    <br>   if (pDiskLine) <br>      { <br>      MemoryFree (pDiskLine); <br>      } <br> <br>   BuildValueListForSystems (*ppSystemFirst, *ppLineFirst) ; <br> <br>   MemoryFree (pPerfData) ; <br>   }  // ReadLines <br> <br> <br> <br>PLINE ReadLine (PPERFSYSTEM *ppSystem, <br>                PPPERFSYSTEM ppSystemFirst, <br>                PPERFDATA *ppPerfData, <br>                HANDLE hFile, <br>                int LineType, <br>                PDISKLINE  *ppDiskLine, <br>                DWORD *pSizeofDiskLine) <br> <br> <br>/* <br>   Effect:        Read in a line from the file hFile, at the current file <br>                  position. <br> <br>   Internals:     The very first characters are a line signature, then a  <br>                  length integer. If the signature is correct, then allocate <br>                  the length amount, and work with that. <br>*/ <br>   {  // ReadLine <br>   PLINE             pLine ; <br> <br>   struct <br>      { <br>      DWORD             dwSignature ; <br>      DWORD             dwLength ; <br>      } LineHeader ; <br> <br>   PPERFOBJECT       pObject ; <br>   PPERFCOUNTERDEF   pCounter ; <br>   PDISKLINE         pDiskLine ;    // Local copy of the pointer <br>   PPERFINSTANCEDEF  pInstance ; <br> <br>   pLine = NULL ; <br> <br>   //=============================// <br>   // read and compare signature  // <br>   //=============================// <br> <br>   if (!FileRead (hFile, &amp;LineHeader, sizeof (LineHeader))) <br>      return (NULL) ; <br> <br> <br>   if (LineHeader.dwSignature != dwLineSignature || <br>       LineHeader.dwLength == 0) <br>      { <br>      SetLastError (ERROR_BAD_FORMAT) ; <br>      return (NULL) ; <br>      } <br> <br> <br>   //=============================// <br>   // read and allocate length    // <br>   //=============================// <br> <br> <br>//   if (!FileRead (hFile, &amp;dwLength, sizeof (dwLength)) || dwLength == 0) <br>//      return (NULL) ; <br> <br> <br>   // check if we need a bigger buffer,  <br>   // normally, it should be the same except the first time... <br>   if (LineHeader.dwLength &gt; *pSizeofDiskLine) <br>      { <br>      if (*ppDiskLine) <br>         { <br>         // free the previous buffer <br>         MemoryFree (*ppDiskLine); <br>         *pSizeofDiskLine = 0 ; <br>         } <br> <br>      // re-allocate a new buffer <br>      *ppDiskLine = (PDISKLINE) MemoryAllocate (LineHeader.dwLength) ; <br>      if (!(*ppDiskLine)) <br>         { <br>         // no memory, should flag an error... <br>         return (NULL) ; <br>         } <br>      *pSizeofDiskLine = LineHeader.dwLength ; <br>      } <br>       <br>   pDiskLine = *ppDiskLine ; <br> <br> <br>   //=============================// <br>   // copy diskline, alloc line   // <br>   //=============================// <br> <br>   if (!FileRead (hFile, pDiskLine, LineHeader.dwLength)) <br>      return (NULL) ; <br> <br> <br>   pLine = LineAllocate () ; <br>   if (!pLine) <br>      { <br>      return (NULL) ; <br>      } <br> <br>   pLine-&gt;iLineType = pDiskLine-&gt;iLineType ; <br> <br> <br>   //=============================// <br>   // convert system information  // <br>   //=============================// <br> <br>   pLine-&gt;lnSystemName = DiskStringReadSys (&amp;(pDiskLine-&gt;dsSystemName)) ; <br>   if (!pLine-&gt;lnSystemName) <br>      goto ErrorBadLine ; <br> <br>   if (!*ppSystem || !strsamei (pLine-&gt;lnSystemName, (*ppSystem)-&gt;sysName)) <br>      { <br>      *ppSystem = SystemAdd (ppSystemFirst, pLine-&gt;lnSystemName) ; <br>      if (!*ppSystem) <br>         { <br>         SetLastError (ERROR_BAD_FORMAT) ; <br>         goto ErrorBadLine ; <br>         } <br>      UpdateSystemData (*ppSystem, ppPerfData) ; <br>      }  // if <br> <br>   //=============================// <br>   // convert object information  // <br>   //=============================// <br> <br>   pLine-&gt;lnObjectName = DiskStringRead (&amp;(pDiskLine-&gt;dsObjectName)) ; <br>   if (!pLine-&gt;lnObjectName) <br>      goto ErrorBadLine ; <br> <br>   pObject = LineFindObject (*ppSystem, *ppPerfData, pLine) ; <br> <br>   //=============================// <br>   // convert counter information // <br>   //=============================// <br> <br>   pLine-&gt;lnCounterName = DiskStringRead (&amp;(pDiskLine-&gt;dsCounterName)) ; <br>   if (!pLine-&gt;lnCounterName) <br>      goto ErrorBadLine ; <br> <br>   if (pObject) <br>      { <br>      pCounter = LineFindCounter (*ppSystem, pObject, *ppPerfData, pLine) ; <br>      if (!pCounter) <br>         { <br>         SetLastError (ERROR_BAD_FORMAT) ; <br>         goto ErrorBadLine ; <br>         } <br>      } <br> <br>   //=============================// <br>   // convert instance info       // <br>   //=============================// <br> <br>   pLine-&gt;lnUniqueID = pDiskLine-&gt;dwUniqueID ; <br>   pLine-&gt;lnInstanceName = DiskStringRead (&amp;(pDiskLine-&gt;dsInstanceName)) ; <br>   pLine-&gt;lnPINName = DiskStringRead (&amp;(pDiskLine-&gt;dsPINName)) ; <br> <br>   if (pObject &amp;&amp; <br>       pLine-&gt;lnObject.NumInstances &gt; 0 &amp;&amp; <br>       pLine-&gt;lnInstanceName == NULL) <br>      { <br>      goto ErrorBadLine ; <br>      } <br> <br>   if (pObject) { <br>      pInstance = LineFindInstance (*ppPerfData, pObject, pLine) ; <br> <br>      if (pInstance) <br>         { <br>         pLine-&gt;lnParentObjName = DiskStringRead (&amp;(pDiskLine-&gt;dsParentObjName)) ; <br>         } <br>      } <br>   else { <br>      pLine-&gt;lnParentObjName = DiskStringRead (&amp;(pDiskLine-&gt;dsParentObjName)) ; <br>   } <br> <br> <br>   //=============================// <br>   // convert chart information   // <br>   //=============================// <br> <br>   if (LineType == IDM_VIEWCHART) <br>      { <br>      pLine-&gt;Visual = pDiskLine-&gt;Visual ; <br>      pLine-&gt;hPen = CreatePen (pLine-&gt;Visual.iStyle, <br>                               pLine-&gt;Visual.iWidth,  <br>                               pLine-&gt;Visual.crColor) ; <br>      pLine-&gt;iScaleIndex = pDiskLine-&gt;iScaleIndex ; <br>      pLine-&gt;eScale = pDiskLine-&gt;eScale ; <br>      } <br> <br> <br>   //=============================// <br>   // convert alert information   // <br>   //=============================// <br> <br>   if (LineType == IDM_VIEWALERT) <br>      { <br>      pLine-&gt;Visual = pDiskLine-&gt;Visual ; <br>      pLine-&gt;hBrush = CreateSolidBrush (pLine-&gt;Visual.crColor) ; <br>      pLine-&gt;bAlertOver = pDiskLine-&gt;bAlertOver ; <br>      pLine-&gt;eAlertValue = pDiskLine-&gt;eAlertValue ; <br>      pLine-&gt;lpszAlertProgram = DiskStringRead (&amp;(pDiskLine-&gt;dsAlertProgram)) ; <br>      pLine-&gt;bEveryTime = pDiskLine-&gt;bEveryTime ; <br>      pLine-&gt;bAlerted = FALSE ; <br>      } <br> <br> <br>   //=============================// <br>   // Convert the nasty stuff     // <br>   //=============================// <br> <br> <br>   if (pObject) { <br>      pLine-&gt;lnCounterType = pCounter-&gt;CounterType; <br>      pLine-&gt;lnCounterLength = pCounter-&gt;CounterSize; <br>      } <br> <br>   return (pLine) ; <br> <br> <br>ErrorBadLine: <br>   if (!pLine) <br>      { <br>      LineFree (pLine) ; <br>      } <br>   return (NULL) ; <br>   }  // ReadLine <br> <br> <br> <br> <br>BOOL WriteLine (PLINE pLine, <br>                HANDLE hFile) <br>   {  // WriteLine <br>   PDISKLINE      pDiskLine ; <br>   DWORD          dwSignature ; <br>   DWORD          dwLength ; <br>   PBYTE          pNextFree ; <br>   BOOL           bConvertName ; <br> <br>   //=============================// <br>   // write signature             // <br>   //=============================// <br> <br>   dwSignature = dwLineSignature ; <br>   if (!FileWrite (hFile, &amp;dwSignature, sizeof (dwSignature))) <br>      return (FALSE) ; <br> <br>   if (IsLocalComputer(pLine-&gt;lnSystemName)) <br>      { <br>      bConvertName = TRUE ; <br>      } <br>   else <br>      { <br>      bConvertName = FALSE ; <br>      } <br> <br>   //=============================// <br>   // compute and allocate length // <br>   //=============================// <br> <br> <br>   dwLength = sizeof (DISKLINE) ; <br>   if (bConvertName) <br>      { <br>      dwLength += DiskStringLength (LOCAL_SYS_CODE_NAME) * sizeof (TCHAR) ; <br>      } <br>   else <br>      { <br>      dwLength += DiskStringLength (pLine-&gt;lnSystemName) * sizeof (TCHAR) ; <br>      } <br>   dwLength += DiskStringLength (pLine-&gt;lnObjectName) * sizeof (TCHAR) ; <br>   dwLength += DiskStringLength (pLine-&gt;lnCounterName) * sizeof (TCHAR) ; <br>   dwLength += DiskStringLength (pLine-&gt;lnInstanceName) * sizeof (TCHAR) ; <br>   dwLength += DiskStringLength (pLine-&gt;lnPINName) * sizeof (TCHAR) ; <br>   dwLength += DiskStringLength (pLine-&gt;lnParentObjName) * sizeof (TCHAR) ; <br>   dwLength += DiskStringLength (pLine-&gt;lpszAlertProgram) * sizeof (TCHAR) ; <br> <br> <br>   if (!FileWrite (hFile, &amp;dwLength, sizeof (dwLength))) <br>      return (FALSE) ; <br> <br>   pDiskLine = (PDISKLINE) MemoryAllocate (dwLength) ; <br>   if (!pDiskLine) <br>      return (FALSE) ; <br> <br>   pNextFree = (PBYTE) pDiskLine + sizeof (DISKLINE) ; <br> <br> <br>   //=============================// <br>   // convert fixed size fields   // <br>   //=============================// <br> <br>   pDiskLine-&gt;iLineType = pLine-&gt;iLineType ; <br>   pDiskLine-&gt;dwUniqueID = pLine-&gt;lnUniqueID ; <br>   pDiskLine-&gt;Visual = pLine-&gt;Visual ; <br>   pDiskLine-&gt;iScaleIndex = pLine-&gt;iScaleIndex ; <br>   pDiskLine-&gt;eScale = pLine-&gt;eScale ; <br>   pDiskLine-&gt;bAlertOver = pLine-&gt;bAlertOver ; <br>   pDiskLine-&gt;eAlertValue = pLine-&gt;eAlertValue ; <br>   pDiskLine-&gt;bEveryTime = pLine-&gt;bEveryTime ; <br> <br> <br>   //=============================// <br>   // copy disk string fields     // <br>   //=============================// <br> <br>   if (bConvertName) <br>      { <br>      pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsSystemName,  <br>                                  LOCAL_SYS_CODE_NAME, <br>                                  pNextFree) ; <br>      } <br>   else <br>      { <br>      pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsSystemName,  <br>                                  pLine-&gt;lnSystemName, <br>                                  pNextFree) ; <br>      } <br> <br>   pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsObjectName,  <br>                               pLine-&gt;lnObjectName, <br>                               pNextFree) ; <br> <br>   pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsCounterName,  <br>                               pLine-&gt;lnCounterName, <br>                               pNextFree) ; <br> <br>   pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsParentObjName,  <br>                               pLine-&gt;lnParentObjName, <br>                               pNextFree) ; <br> <br>   pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsInstanceName,  <br>                               pLine-&gt;lnInstanceName, <br>                               pNextFree) ; <br> <br>   pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsPINName,  <br>                               pLine-&gt;lnPINName, <br>                               pNextFree) ; <br> <br>   pNextFree = DiskStringCopy (&amp;pDiskLine-&gt;dsAlertProgram,  <br>                               pLine-&gt;lpszAlertProgram, <br>                               pNextFree) ; <br> <br> <br> <br>   FileWrite (hFile, pDiskLine, dwLength) ; <br>   MemoryFree (pDiskLine) ; <br>   return (TRUE) ; <br> <br>//ErrorBadLine: <br>   MemoryFree (pDiskLine) ; <br>   return (FALSE) ; <br>   }  // WriteLine <br> <br> <br>// we are not doing printing.  In case we need this <br>// later, then define DO_PRINTING <br>#ifdef DO_PRINTING <br>int aiPrinterLineStyles [] =  <br>   { <br>   PS_SOLID, <br>   PS_DASH, <br>   PS_DOT, <br>   PS_DASHDOT, <br>   PS_DASHDOTDOT <br>   } ; <br>#define NumPrinterLineStyles()   \ <br>   (sizeof (aiPrinterLineStyles) / sizeof (aiPrinterLineStyles [0])) <br> <br> <br>COLORREF acrPrinterLineColors [] = <br>   { <br>   RGB (192, 192, 192), <br>   RGB (128, 128, 128),  <br>   RGB (64, 64, 64), <br>   RGB (0, 0, 0) <br>   }  ; <br> <br> <br>#define NumPrinterLineColors()   \ <br>   (sizeof (acrPrinterLineColors) / sizeof (acrPrinterLineColors [0])) <br>#endif      // DO_PRINTING <br> <br> <br>HPEN LineCreatePen (HDC hDC, <br>                    PLINEVISUAL pVisual, <br>                    BOOL bForPrint) <br>   {  // LineCreatePen <br>   HPEN        hPen ; <br>#ifdef DO_PRINTING <br>   LOGBRUSH    logBrush ; <br> <br>   if (bForPrint) <br>      { <br>      logBrush.lbStyle = PS_SOLID ; <br>//!!         aiPrinterLineStyles [pVisual-&gt;iColorIndex % NumPrinterLineStyles ()] ; <br>      logBrush.lbColor =  <br>         acrPrinterLineColors [pVisual-&gt;iColorIndex % NumPrinterLineColors ()] ; <br>      logBrush.lbHatch = 0 ; <br> <br>      hPen = ExtCreatePen (logBrush.lbStyle |  <br>                           PS_GEOMETRIC |  <br>                           PS_ENDCAP_SQUARE |  <br>                           PS_JOIN_BEVEL, <br>                           VertInchPixels (hDC, pVisual-&gt;iWidth, 20), <br>                           &amp;logBrush, <br>                           0, NULL) ; <br>      } <br>   else <br>#endif <br>      hPen = CreatePen (pVisual-&gt;iStyle, <br>                        pVisual-&gt;iWidth,  <br>                        pVisual-&gt;crColor) ; <br> <br>   return (hPen) ; <br>   }  // LineCreatePen <br> <br> <br> <br>VOID FreeLines (PLINESTRUCT pLineFirst) <br>   {  // FreeLines <br>   PLINESTRUCT    pLine,next_line; <br> <br> <br>   for (pLine = pLineFirst; pLine; pLine = next_line) <br>      { <br>      next_line = pLine-&gt;pLineNext; <br>      LineFree (pLine) ; <br>      } <br>   }  // FreeLines <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
