<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFMOPS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5685"></a>PERFMOPS.C</h2>
<pre><code><br>#include "perfmon.h" <br>#include &lt;lmcons.h&gt; <br>#include &lt;lmerr.h&gt; <br>#include &lt;lmapibuf.h&gt; <br>#include &lt;lmwksta.h&gt; <br>#include "uiexprt.h" <br>#include &lt;stdio.h&gt;         // for sprintf <br>#include &lt;locale.h&gt;        // for setlocale <br>#include "utils.h" <br> <br>#include "perfdata.h"      // for OpenSystemPerfData <br>#include "alert.h"         // for AlertInsertLine <br>#include "report.h"        // for ReportInsertLine <br>#include "grafdata.h"      // for GraphInsertLine <br>#include "log.h"           // for OpenLog <br>#include "fileopen.h"      // for FileGetName <br>#include "fileutil.h"      // for FileRead etc <br>#include "command.h"       // for PrepareMenu <br>#include "playback.h"      // for PlayingBackLog &amp; LogPositionSystemTime <br>#include "system.h" <br>#include "globals.h" <br>#include "pmemory.h"       // for MemoryFree <br>#include "status.h"        // for StatusLineReady <br>#include "pmhelpid.h" <br> <br>// test for delimiter, end of line and non-digit characters <br>// used by IsNumberInUnicodeList routine <br>// <br>#define DIGIT       1 <br>#define DELIMITER   2 <br>#define INVALID     3 <br> <br>// globals used for International Date and Time formats <br>enum DATE_STYLE <br>   { <br>   YEAR_FIRST,       // YYMMDD <br>   DAY_FIRST,        // DDMMYY <br>   MONTH_FIRST       // MMDDYY <br>   } DateStyle ; <br> <br>TCHAR szInternational[] = TEXT("Intl") ; <br>TCHAR sz1159[6] ;       // AM String <br>TCHAR sz2359[6] ;       // PM String <br>int   iTime ;           // = 0 for 12-hour format,  &lt;&gt; 0 for 24-hour format <br>int   YearCharCount ;   // = 4 for 1990, = 2 for 90 <br> <br>TCHAR szDateFormat[ResourceStringLen] ; <br>TCHAR szTimeFormat[ResourceStringLen] ;   // time format including msec <br>TCHAR szTimeFormat1[ResourceStringLen] ;  // time format without msec <br> <br>TCHAR LeadingZeroStr [] = TEXT("%02d") ; <br>TCHAR NoLeadingZeroStr [] = TEXT("%d") ; <br> <br>TCHAR szDecimal [2] ; <br>TCHAR szCurrentDecimal [2] ; <br> <br>#define EvalThisChar(c,d) ( \ <br>     (c == d) ? DELIMITER : \ <br>     (c == 0) ? DELIMITER : \ <br>     (c &lt; (WCHAR)'0') ? INVALID : \ <br>     (c &gt; (WCHAR)'9') ? INVALID : \ <br>     DIGIT) <br> <br>#define SIZE_OF_BIGGEST_INTEGER  16  <br>// #define SIZE_OF_BIGGEST_INTEGER (16*sizeof(WCHAR))  <br> <br> <br>//==========================================================================// <br>//                                  Typedefs                                // <br>//==========================================================================// <br> <br>BOOL AddObjectToSystem ( PLINE , PPERFSYSTEM ); <br>BOOL GetLogFileComputer (HWND hWndParent, LPTSTR lpComputerName, DWORD BufferSize) ; <br> <br> <br>HWND PerfmonViewWindow (void) <br>/* <br>   Effect:        Return the current data window, i.e. the window currently <br>                  visible as the client area of Perfmon.  This is either a <br>                  chart, log, alert, or report window. <br>*/ <br>   {  // PerfmonDataWindow <br>   switch (iPerfmonView) <br>      {  // switch <br>      case IDM_VIEWLOG: <br>         return (hWndLog) ; <br> <br>      case IDM_VIEWALERT: <br>         return (hWndAlert) ; <br> <br>      case IDM_VIEWREPORT: <br>         return (hWndReport) ; <br> <br>//      case IDM_VIEWCHART: <br>      default: <br>         return (hWndGraph) ; <br>      }  // switch <br>   }  // PerfmonViewWindow <br> <br> <br> <br> <br>#define szChooseComputerLibrary     TEXT("ntlanman.dll") <br>#define szChooseComputerFunction    "I_SystemFocusDialog" <br> <br> <br>BOOL ChooseComputer (HWND hWndParent, LPTSTR lpszComputer) <br>/* <br>   Effect:        Display the choose Domain/Computer dialog provided by <br>                  network services.  If the user selects a computer,  <br>                  copy the computer name to lpszComputer and return <br>                  nonnull. If the user cancels, return FALSE. <br> <br>   Internals:     This dialog and code is currently not an exported  <br>                  routine regularly found on any user's system. Right  <br>                  now, we dynamically load and call the routine. <br> <br>                  This is definitely temporary code that will be  <br>                  rewritten when NT stabilizes. The callers of this <br>                  routine, however, will not need to be modified. <br> <br>                  Also, the Domain/Computer dialog currently allows <br>                  a domain to be selected, which we cannot use. We <br>                  therefore loop until the user cancels or selects <br>                  a computer, putting up a message if the user selects <br>                  a domain. <br> <br>   Assert:        lpszComputer is at least MAX_SYSTEM_NAME_LENGTH + 1 <br>                  characters. <br>*/ <br>   {  // ChooseComputer <br>   BOOL                     bSuccess ; <br>   WCHAR                    wszWideComputer[MAX_COMPUTERNAME_LENGTH + 3] ; <br>   HLIBRARY                 hLibrary ; <br>   LPFNI_SYSTEMFOCUSDIALOG  lpfnChooseComputer ; <br>   LONG                     lError ; <br> <br>   if (!PlayingBackLog()) <br>      { <br> <br>      // bring up the select network computer dialog <br>      hLibrary = LoadLibrary (szChooseComputerLibrary) ; <br>      if (!hLibrary || hLibrary == INVALID_HANDLE_VALUE) <br>         { <br>         return (FALSE) ; <br>         } <br>    <br>      lpfnChooseComputer = (LPFNI_SYSTEMFOCUSDIALOG) <br>         GetProcAddress (hLibrary, szChooseComputerFunction) ; <br> <br>      if (!lpfnChooseComputer) <br>         { <br>         FreeLibrary (hLibrary) ; <br>         return (FALSE) ; <br>         } <br> <br>      lError = (*lpfnChooseComputer) (hWndParent, <br>         FOCUSDLG_SERVERS_ONLY | FOCUSDLG_BROWSE_ALL_DOMAINS, <br>         wszWideComputer, <br>         sizeof(wszWideComputer) / sizeof(WCHAR), <br>         &amp;bSuccess, <br>         pszHelpFile, <br>         HC_PM_idDlgSelectNetworkComputer) ; <br> <br>      FreeLibrary (hLibrary) ; <br>      } <br>   else <br>      { <br>      // bring up the select Log Computer dialog <br>      bSuccess = GetLogFileComputer (hWndParent, <br>         wszWideComputer, <br>         sizeof(wszWideComputer) / sizeof(WCHAR)) ; <br>      } <br> <br>   if (bSuccess) <br>      { <br>      lstrcpy (lpszComputer, wszWideComputer) ; <br>//      wcstombs(lpszComputer, wszWideComputer, MAX_COMPUTERNAME_LENGTH + 3) ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // ChooseComputer <br>    <br> <br>void SystemTimeDateString (SYSTEMTIME *pSystemTime, <br>                           LPTSTR lpszDate) <br>   { <br>   int      wYear ; <br>    <br>   wYear = pSystemTime-&gt;wYear ; <br>   if (YearCharCount == 2) <br>      { <br>      wYear %= 100 ; <br>      } <br> <br>   switch (DateStyle) <br>      { <br>      case YEAR_FIRST: <br>         TSPRINTF (lpszDate, szDateFormat, <br>             wYear, pSystemTime-&gt;wMonth, pSystemTime-&gt;wDay) ; <br>         break ; <br> <br>      case DAY_FIRST: <br>         TSPRINTF (lpszDate, szDateFormat, <br>             pSystemTime-&gt;wDay, pSystemTime-&gt;wMonth, wYear) ; <br>         break ; <br> <br>      case MONTH_FIRST: <br>      default: <br>         TSPRINTF (lpszDate, szDateFormat, <br>             pSystemTime-&gt;wMonth, pSystemTime-&gt;wDay, wYear) ; <br>         break ; <br>      } <br>   } <br> <br> <br>void SystemTimeTimeString (SYSTEMTIME *pSystemTime, <br>                           LPTSTR lpszTime, <br>                           BOOL   bOutputMsec) <br>   { <br>   int            iHour ; <br>   BOOL           bPM ; <br> <br>   if (iTime) <br>      { <br>      // 24 hor format <br>      if (bOutputMsec) <br>         { <br>         TSPRINTF (lpszTime, szTimeFormat, <br>                pSystemTime-&gt;wHour, <br>                pSystemTime-&gt;wMinute, <br>                (FLOAT)pSystemTime-&gt;wSecond + <br>                (FLOAT)pSystemTime-&gt;wMilliseconds / (FLOAT) 1000.0) ; <br>         } <br>      else <br>         { <br>         TSPRINTF (lpszTime, szTimeFormat1, <br>                pSystemTime-&gt;wHour, <br>                pSystemTime-&gt;wMinute, <br>                pSystemTime-&gt;wSecond) ; <br> <br>         } <br>      } <br>   else <br>      { <br>      // 12 hour format <br>      iHour = pSystemTime-&gt;wHour ; <br>      bPM = (iHour &gt;= 12) ; <br> <br>      if (iHour &gt; 12) <br>         iHour -= 12 ; <br>      else if (!iHour) <br>         iHour = 12 ; <br> <br>      if (bOutputMsec) <br>         { <br>         TSPRINTF (lpszTime, szTimeFormat, <br>                iHour, pSystemTime-&gt;wMinute, <br>                (FLOAT)pSystemTime-&gt;wSecond +  <br>                (FLOAT)pSystemTime-&gt;wMilliseconds / (FLOAT) 1000.0 , <br>                bPM ? sz2359 : sz1159) ; <br>         } <br>      else <br>         { <br>         TSPRINTF (lpszTime, szTimeFormat1, <br>                iHour, pSystemTime-&gt;wMinute, <br>                pSystemTime-&gt;wSecond, <br>                bPM ? sz2359 : sz1159) ; <br>         } <br>      } <br>   } <br>             <br>void ShowPerfmonWindowText () <br>   { <br>   LPTSTR   *ppFileName ; <br>   TCHAR    szApplication [MessageLen] ; <br> <br>   switch (iPerfmonView) <br>      { <br>      case IDM_VIEWCHART: <br>         ppFileName = &amp;pChartFileName ; <br>         break ; <br> <br>      case IDM_VIEWALERT: <br>         ppFileName = &amp;pAlertFileName ; <br>         break ; <br> <br>      case IDM_VIEWREPORT: <br>         ppFileName = &amp;pReportFileName ; <br>         break ; <br> <br>      case IDM_VIEWLOG: <br>         ppFileName = &amp;pLogFileName ; <br>         break ; <br> <br>      default: <br>         ppFileName = NULL ; <br>         break ; <br>      } <br> <br>   if (ppFileName == NULL || *ppFileName == NULL) <br>      { <br>      ppFileName = &amp;pWorkSpaceFileName ; <br>      } <br> <br>   // display the name file name on the Title bar. <br>   StringLoad (IDS_APPNAME, szApplication) ; <br> <br>   if (*ppFileName) <br>      { <br>      lstrcat (szApplication, TEXT(" - ")) ; <br>      lstrcat (szApplication, *ppFileName) ; <br>      } <br>   SetWindowText (hWndMain, szApplication) ; <br>   } <br> <br>void ShowPerfmonMenu (BOOL bMenu) <br>   {  // ShowPerfmonMenu <br>   if (!bMenu) <br>      { <br>      WindowEnableTitle (hWndMain, FALSE) ; <br>//      SetMenu(hWndMain, NULL) ; <br>      } <br>   else <br>      { <br>      WindowEnableTitle (hWndMain, TRUE) ; <br>      switch (iPerfmonView) <br>         {  // switch <br>         case IDM_VIEWCHART: <br>            SetMenu (hWndMain, hMenuChart) ; <br>            break ; <br> <br>         case IDM_VIEWALERT: <br>            SetMenu (hWndMain, hMenuAlert) ; <br>            break ; <br> <br>         case IDM_VIEWLOG: <br>            SetMenu (hWndMain, hMenuLog) ; <br>            break ; <br> <br>         case IDM_VIEWREPORT: <br>            SetMenu (hWndMain, hMenuReport) ; <br>            break ; <br>         }  // switch <br>      }  // else <br> <br>   if (bMenu != Options.bMenubar) <br>      { <br>      PrepareMenu (GetMenu (hWndMain)) ; <br>      } <br> <br>   Options.bMenubar = bMenu ; <br> <br>   // Show Window Text <br>   if (bMenu) <br>      { <br>      ShowPerfmonWindowText () ; <br>      } <br>   }  // ShowPerfmonMenu <br> <br> <br> <br>void SmallFileSizeString (int iFileSize, <br>                          LPTSTR lpszFileText) <br>   {  // SmallFileSizeString <br>   if (iFileSize &lt; 1000000) <br>      TSPRINTF (lpszFileText, TEXT(" %1.1fK "), ((FLOAT) iFileSize) / 1000.0f) ; <br>   else <br>      TSPRINTF (lpszFileText, TEXT(" %1.1fM "), ((FLOAT) iFileSize) / 1000000.0f) ; <br>   }  // SmallFileSizeString    <br> <br> <br> <br>BOOL DoWindowDrag (HWND hWnd, LPARAM lParam) <br>   { <br>   POINT    lPoint ; <br> <br>   if (!Options.bMenubar &amp;&amp; !IsZoomed (hWndMain)) <br>      { <br>      // convert lParam from client to screen <br>      lPoint.x = LOWORD (lParam) ; <br>      lPoint.y = HIWORD (lParam) ; <br>      ClientToScreen (hWnd, &amp;lPoint) ; <br>      lParam = MAKELONG (lPoint.x, lPoint.y) ; <br>      SendMessage (hWndMain, WM_NCLBUTTONDOWN, HTCAPTION, lParam) ; <br>      return (TRUE) ; <br>      } <br>   else <br>      return (FALSE) ; <br>   } <br> <br> <br> <br>// Filetimes are in 100NS units <br>#define FILETIMES_PER_SECOND     10000000 <br> <br> <br>int SystemTimeDifference (SYSTEMTIME *pst1, SYSTEMTIME *pst2) <br>   { <br>   LONGLONG       li1, li2 ; <br>   LONGLONG       liDifference, liDifferenceSeconds ; <br>   int            RetInteger; <br>   BOOL           bNegative; <br> <br>   li1 = (LONGLONG) 0 ; <br>   li2 = (LONGLONG) 0 ; <br> <br>   SystemTimeToFileTime (pst1, (FILETIME *) &amp;li1) ; <br>   SystemTimeToFileTime (pst2, (FILETIME *) &amp;li2) ; <br> <br>   // check for special cases when the time can be 0 <br>   if (li2 == (LONGLONG)0) <br>      { <br>      if (li1 == (LONGLONG)0) <br>         { <br>         return 0 ; <br>         } <br>      else <br>         { <br>         return -INT_MAX ; <br>         } <br>      } <br>   else if (li1 == (LONGLONG)0) <br>      { <br>      return INT_MAX ; <br>      } <br> <br>   liDifference = li2 - li1 ; <br>   bNegative = liDifference &lt;= (LONGLONG) 0 ; <br> <br>   // add the round-off factor before doing the division <br>   if (bNegative) <br>      { <br>      liDifferenceSeconds = (LONGLONG) (- FILETIMES_PER_SECOND / 2) ; <br>      } <br>   else <br>      { <br>      liDifferenceSeconds = (LONGLONG) (FILETIMES_PER_SECOND / 2) ; <br>      } <br> <br> <br>   liDifferenceSeconds = liDifferenceSeconds + liDifference ; <br> <br>   liDifferenceSeconds = <br>         liDifferenceSeconds / (LONGLONG) (FILETIMES_PER_SECOND) ;  <br> <br>   RetInteger = (int) (liDifferenceSeconds &amp; ((LONGLONG) 0x0ffffffff)); <br> <br>   if (bNegative) <br>      { <br>      return (-RetInteger) ; <br>      } <br>   else <br>      { <br>      return (RetInteger) ; <br>      } <br>   } <br>  <br> <br>BOOL InsertLine (PLINE pLine) <br>{  // InsertLine <br> <br>    BOOL bReturn; <br>    <br>    switch (pLine-&gt;iLineType) {  // switch <br>        case LineTypeChart: <br>            bReturn = ChartInsertLine (pGraphs, pLine) ; <br>            break ; <br> <br>        case LineTypeAlert: <br>            bReturn = AlertInsertLine (hWndAlert, pLine) ; <br>            break ; <br> <br>        case LineTypeReport: <br>            bReturn = ReportInsertLine (hWndReport, pLine) ; <br>            break ; <br> <br>    }  // switch <br> <br>    return bReturn; <br> <br>}  // InsertLine <br>    <br> <br>BOOL OpenWorkspace (HANDLE hFile, DWORD dwMajorVersion, DWORD dwMinorVersion) <br>   { <br>   DISKWORKSPACE  DiskWorkspace ; <br>    <br>   if (!FileRead (hFile, &amp;DiskWorkspace, sizeof(DiskWorkspace))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   if (DiskWorkspace.ChartOffset == 0 &amp;&amp; <br>       DiskWorkspace.AlertOffset == 0 &amp;&amp; <br>       DiskWorkspace.LogOffset == 0 &amp;&amp; <br>       DiskWorkspace.ReportOffset == 0) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   switch (dwMajorVersion) <br>      {  // switch <br>      case (1): <br> <br>         if (dwMinorVersion &gt;= 1) <br>            { <br>            // setup the window position and size <br>            DiskWorkspace.WindowPlacement.length = sizeof(WINDOWPLACEMENT); <br>            DiskWorkspace.WindowPlacement.flags = WPF_SETMINPOSITION; <br>            if (!SetWindowPlacement (hWndMain, &amp;(DiskWorkspace.WindowPlacement))) <br>                { <br>                goto Exit0 ; <br>                } <br>            } <br> <br>         // change to the view as stored in the workspace file <br>         SendMessage (hWndMain, WM_COMMAND, <br>            (LONG)DiskWorkspace.iPerfmonView, 0L) ; <br>         iPerfmonView = DiskWorkspace.iPerfmonView ; <br> <br>         if (DiskWorkspace.ChartOffset) <br>            { <br>            if (FileSeekBegin(hFile, DiskWorkspace.ChartOffset) == 0xFFFFFFFF) <br>               { <br>               goto Exit0 ; <br>               } <br> <br>            if (!OpenChart (hWndGraph, <br>                           hFile, <br>                           dwMajorVersion, <br>                           dwMinorVersion, <br>                           FALSE)) <br>               { <br>               goto Exit0 ; <br>               } <br>            } <br>         if (DiskWorkspace.AlertOffset) <br>            { <br>            if (FileSeekBegin(hFile, DiskWorkspace.AlertOffset) == 0xffffffff) <br>               { <br>               goto Exit0 ; <br>               } <br>            if (!OpenAlert (hWndAlert, <br>                       hFile, <br>                       dwMajorVersion, <br>                       dwMinorVersion, <br>                       FALSE)) <br>               { <br>               goto Exit0 ; <br>               } <br>            } <br>         if (DiskWorkspace.LogOffset) <br>            { <br>            if (FileSeekBegin(hFile, DiskWorkspace.LogOffset) == 0xffffffff) <br>               { <br>               goto Exit0 ; <br>               } <br>            if (!OpenLog (hWndLog, <br>                          hFile, <br>                          dwMajorVersion, <br>                          dwMinorVersion, <br>                          FALSE)) <br>               { <br>               goto Exit0 ; <br>               } <br>            } <br>         if (DiskWorkspace.ReportOffset) <br>            { <br>            if (FileSeekBegin(hFile, DiskWorkspace.ReportOffset) == 0xffffffff) <br>               { <br>               goto Exit0 ; <br>               } <br>            if (!OpenReport (hWndReport, <br>                        hFile, <br>                        dwMajorVersion, <br>                        dwMinorVersion, <br>                        FALSE)) <br>               { <br>               goto Exit0 ; <br>               } <br>            } <br>         break ; <br> <br>      default: <br>         goto Exit0 ; <br>         break ; <br>      } <br> <br>   CloseHandle (hFile) ; <br>   return (TRUE) ; <br> <br> <br>Exit0: <br>   CloseHandle (hFile) ; <br>   return (FALSE) ; <br> <br>   }  // OpenWorkspace <br> <br> <br>BOOL SaveWorkspace (void) <br>   { <br>   DISKWORKSPACE  DiskWorkspace ; <br>   PERFFILEHEADER FileHeader ; <br>   HANDLE         hFile ; <br>   long           DiskWorkspacePosition ; <br>   TCHAR          szFileName[FilePathLen] ; <br>   BOOL           bWriteErr = TRUE ; <br> <br>   if (!FileGetName (PerfmonViewWindow(), IDS_WORKSPACEFILE, szFileName)) <br>      { <br>      return (FALSE) ; <br>      } <br> <br>   hFile = FileHandleCreate (szFileName) ; <br>   if (!hFile) <br>      { <br>      DlgErrorBox (PerfmonViewWindow (), ERR_CANT_OPEN, szFileName) ; <br>      return (FALSE) ; <br>      } <br> <br>   memset (&amp;FileHeader, 0, sizeof (FileHeader)) ; <br>   lstrcpy (FileHeader.szSignature, szPerfWorkspaceSignature) ; <br>   FileHeader.dwMajorVersion = WorkspaceMajorVersion ; <br>   FileHeader.dwMinorVersion = WorkspaceMinorVersion ; <br> <br>   if (!FileWrite (hFile, &amp;FileHeader, sizeof (PERFFILEHEADER))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // reserve space in the file.  We will fill up info <br>   // and write into this guy later. <br>   memset (&amp;DiskWorkspace, 0, sizeof(DiskWorkspace)) ; <br>   DiskWorkspacePosition = FileTell (hFile) ; <br>   DiskWorkspace.WindowPlacement.length = sizeof(WINDOWPLACEMENT); <br>   if (!GetWindowPlacement (hWndMain, &amp;(DiskWorkspace.WindowPlacement))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   if (!FileWrite (hFile, &amp;DiskWorkspace, sizeof (DISKWORKSPACE))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // put in chart data <br>   DiskWorkspace.ChartOffset = FileTell (hFile) ; <br>   if (!SaveChart (hWndGraph, hFile, 0)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // put in alert data <br>   DiskWorkspace.AlertOffset = FileTell (hFile) ; <br>   if (!SaveAlert (hWndAlert, hFile, 0)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // put in log data <br>   DiskWorkspace.LogOffset = FileTell (hFile) ; <br>   if (!SaveLog (hWndLog, hFile, 0)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // put in report data <br>   DiskWorkspace.ReportOffset = FileTell (hFile) ; <br>   if (!SaveReport (hWndReport, hFile, 0)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // put in the disk header info <br>   DiskWorkspace.iPerfmonView = iPerfmonView ; <br>   FileSeekBegin (hFile, DiskWorkspacePosition) ; <br>   if (!FileWrite (hFile, &amp;DiskWorkspace, sizeof (DISKWORKSPACE))) <br>      { <br>      goto Exit0 ; <br>      } <br>   bWriteErr = FALSE ; <br> <br>Exit0: <br>   if (bWriteErr) <br>      { <br>      DlgErrorBox (PerfmonViewWindow (), ERR_SETTING_FILE, szFileName) ; <br>      } <br> <br>   CloseHandle (hFile) ; <br> <br>   }  // SaveWorkspace <br> <br>void SetPerfmonOptions (OPTIONS *pOptions) <br>   { <br>   Options = *pOptions ; <br>   ShowPerfmonMenu (Options.bMenubar) ; <br>   SizePerfmonComponents () ; <br>   WindowSetTopmost (hWndMain, Options.bAlwaysOnTop) ; <br>   }  // SetPerfmonOptions <br> <br>void ChangeSaveFileName (LPTSTR szFileName, int iPMView) <br>   { <br>   LPTSTR   *ppFullName ; <br>   LPTSTR   *ppFileName ; <br>   BOOL     errorInput = FALSE ; <br>   TCHAR    szApplication [MessageLen] ; <br> <br> <br>   switch (iPMView) <br>      { <br>      case IDM_VIEWCHART: <br>         ppFileName = &amp;pChartFileName ; <br>         ppFullName = &amp;pChartFullFileName ; <br>         break ; <br> <br>      case IDM_VIEWALERT: <br>         ppFileName = &amp;pAlertFileName ; <br>         ppFullName = &amp;pAlertFullFileName ; <br>         break ; <br> <br>      case IDM_VIEWREPORT: <br>         ppFileName = &amp;pReportFileName ; <br>         ppFullName = &amp;pReportFullFileName ; <br>         break ; <br> <br>      case IDM_VIEWLOG: <br>         ppFileName = &amp;pLogFileName ; <br>         ppFullName = &amp;pLogFullFileName ; <br>         break ; <br> <br>      case IDM_WORKSPACE: <br>         // not a view but a define <br>         ppFileName = &amp;pWorkSpaceFileName ; <br>         ppFullName = &amp;pWorkSpaceFullFileName ; <br>         break ; <br> <br>      default: <br>         errorInput = TRUE ; <br>         break ; <br>      } <br> <br>   if (errorInput) <br>      { <br>      return ; <br>      } <br> <br>   // release last filename <br>   if (*ppFullName) <br>      { <br>      MemoryFree (*ppFullName) ; <br>      *ppFileName = NULL ; <br>      *ppFullName = NULL ; <br>      } <br> <br>   // allocate new file name and display it <br>   if (szFileName &amp;&amp; (*ppFullName = StringAllocate (szFileName))) <br>      { <br>      *ppFileName = ExtractFileName (*ppFullName) ; <br>      } <br> <br>   if (iPerfmonView == iPMView || iPMView == IDM_WORKSPACE) <br>      { <br>      StatusLineReady (hWndStatus) ; <br> <br>      if (Options.bMenubar) <br>         { <br>         // display the name file name on the Title bar. <br>         StringLoad (IDS_APPNAME, szApplication) ; <br> <br>         if (*ppFileName == NULL) <br>            { <br>            ppFileName = &amp;pWorkSpaceFileName ; <br>            } <br> <br>         if (*ppFileName) <br>            { <br>            lstrcat (szApplication, TEXT(" - ")) ; <br>            lstrcat (szApplication, *ppFileName) ; <br>            } <br>         SetWindowText (hWndMain, szApplication) ; <br>         } <br>      } <br>   }     // ChangeSaveFileName <br>  <br>BOOL <br>IsNumberInUnicodeList ( <br>    IN DWORD   dwNumber, <br>    IN LPTSTR  lpwszUnicodeList <br>) <br>/*++ <br> <br>IsNumberInUnicodeList <br> <br>Arguments: <br>         <br>    IN dwNumber <br>        DWORD number to find in list <br> <br>    IN lpwszUnicodeList <br>        Null terminated, Space delimited list of decimal numbers <br> <br>Return Value: <br> <br>    TRUE: <br>            dwNumber was found in the list of unicode number strings <br> <br>    FALSE: <br>            dwNumber was not found in the list. <br> <br>--*/ <br>{ <br>    DWORD   dwThisNumber; <br>    WCHAR   *pwcThisChar; <br>    BOOL    bValidNumber; <br>    BOOL    bNewItem; <br>    WCHAR   wcDelimiter;    // could be an argument to be more flexible <br> <br>    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde <br> <br>    pwcThisChar = lpwszUnicodeList; <br>    dwThisNumber = 0; <br>    wcDelimiter = (WCHAR)' '; <br>    bValidNumber = FALSE; <br>    bNewItem = TRUE; <br>     <br>    while (TRUE) { <br>        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) { <br>            case DIGIT: <br>                // if this is the first digit after a delimiter, then  <br>                // set flags to start computing the new number <br>                if (bNewItem) { <br>                    bNewItem = FALSE; <br>                    bValidNumber = TRUE; <br>                } <br>                if (bValidNumber) { <br>                    dwThisNumber *= 10; <br>                    dwThisNumber += (*pwcThisChar - (WCHAR)'0'); <br>                } <br>                break; <br>             <br>            case DELIMITER: <br>                // a delimter is either the delimiter character or the  <br>                // end of the string ('\0') if when the delimiter has been <br>                // reached a valid number was found, then compare it to the <br>                // number from the argument list. if this is the end of the <br>                // string and no match was found, then return. <br>                // <br>                if (bValidNumber) { <br>                    if (dwThisNumber == dwNumber) return TRUE; <br>                    bValidNumber = FALSE; <br>                } <br>                if (*pwcThisChar == 0) { <br>                    return FALSE; <br>                } else { <br>                    bNewItem = TRUE; <br>                    dwThisNumber = 0; <br>                } <br>                break; <br> <br>            case INVALID: <br>                // if an invalid character was encountered, ignore all <br>                // characters up to the next delimiter and then start fresh. <br>                // the invalid number is not compared. <br>                bValidNumber = FALSE; <br>                break; <br> <br>            default: <br>                break; <br> <br>        } <br>        pwcThisChar++; <br>    } <br> <br>}   // IsNumberInUnicodeList <br>  <br>BOOL <br>AppendObjectToValueList ( <br>    DWORD   dwObjectId, <br>    PWSTR   pwszValueList <br>) <br>/*++ <br> <br>AppendObjectToValueList <br> <br>Arguments: <br>         <br>    IN dwNumber <br>        DWORD number to insert in list <br> <br>    IN PUNICODE_STRING <br>        pointer to unicode string structure that contains buffer that is <br>        Null terminated, Space delimited list of decimal numbers that <br>        may have this number appended to.  <br> <br>Return Value: <br> <br>    TRUE: <br>            dwNumber was added to list <br> <br>    FALSE: <br>            dwNumber was not added. (because it's already there or <br>                an error occured) <br> <br>--*/ <br>{ <br>    WCHAR           tempString [SIZE_OF_BIGGEST_INTEGER] ; <br>    DWORD           dwStrLen, dwNewStrLen; <br> <br>    if (!pwszValueList) { <br>        return FALSE; <br>    } <br> <br>    if (IsNumberInUnicodeList(dwObjectId, pwszValueList)) { <br>        return FALSE;   // object already in list <br>    } else { <br>        // append the new object id the  value list <br>        TSPRINTF (tempString, TEXT("%d "), dwObjectId) ; <br> <br>        // see if string will fit (compare in bytes) <br> <br>        dwStrLen = MemorySize (pwszValueList) - sizeof (UNICODE_NULL); <br> <br>        dwNewStrLen = (lstrlen (pwszValueList) + lstrlen (tempString)) * <br>            sizeof (WCHAR); <br> <br>        if (dwNewStrLen &lt;= dwStrLen) { <br>            lstrcat (pwszValueList, tempString); <br>            return TRUE; <br>        } else { <br>            SetLastError (ERROR_OUTOFMEMORY);  <br>            return FALSE; <br>        } <br>    } <br>} <br>  <br>BOOL <br>AddObjectToSystem ( <br>    PLINE pLine, <br>    PPERFSYSTEM pFirstSystem <br>) <br>{ <br>    PPERFSYSTEM     pSystem; <br>     <br>    if ((ARGUMENT_PRESENT (pLine)) &amp;&amp; (ARGUMENT_PRESENT(pFirstSystem))) { <br>        pSystem = SystemGet (pFirstSystem, pLine-&gt;lnSystemName); <br> <br>        if (pSystem) { <br>            return AppendObjectToValueList ( <br>                pLine-&gt;lnObject.ObjectNameTitleIndex, <br>                pSystem-&gt;lpszValue); <br>        } else { <br>            return FALSE; <br>        } <br>    } else { <br>        return FALSE; <br>    } <br>} <br>  <br>BOOL <br>RemoveObjectsFromSystem ( <br>    PPERFSYSTEM pSystem <br>) <br>{ <br>    DWORD   dwBufferSize = 0; <br> <br>    if (ARGUMENT_PRESENT (pSystem)) { <br>        // don't do foreign computers <br>        if (pSystem-&gt;lpszValue &amp;&amp; !strsame (pSystem-&gt;lpszValue, L"Foreign")){ <br>            dwBufferSize = MemorySize (pSystem-&gt;lpszValue); <br> <br>            memset (pSystem-&gt;lpszValue, 0, dwBufferSize); <br>            return TRUE; <br>        } else { <br>            return FALSE; <br>        } <br>    } else { <br>        return FALSE; <br>    } <br> <br> <br>}     <br>  <br>BOOL <br>BuildValueListForSystems ( <br>    PPERFSYSTEM pSystemListHead, <br>    PLINE       pLineListHead <br>) <br>/*++ <br> <br>BuildValueListForSystem <br> <br>Abstract: <br> <br>    Walks down line list and builds the list of objects to query from <br>    that system containing that line. <br> <br>Arguments: <br> <br>    pSystemListHead <br> <br>        head of system linked list <br>        each system will have it's "Value Name" list appended <br> <br>    pLineListHead <br> <br>        head of line list that will be searched for creating the new <br>        valuelist. <br> <br> <br>Return Value: <br> <br> <br>--*/ <br>{ <br> <br>    PPERFSYSTEM     pSystem;    // system that contains current line <br>    PLINE           pThisLine;  // current line <br> <br>    if ((ARGUMENT_PRESENT (pLineListHead)) &amp;&amp; (ARGUMENT_PRESENT(pSystemListHead))) { <br>        // clear system entries: <br>        for (pSystem = pSystemListHead; pSystem; pSystem = pSystem-&gt;pSystemNext) { <br>            if (pSystem &amp;&amp; pSystem-&gt;FailureTime == 0) { <br>                RemoveObjectsFromSystem (pSystem); <br>            } <br>        } <br> <br>        // add new enties <br> <br>        for (pThisLine = pLineListHead; pThisLine; pThisLine = pThisLine-&gt;pLineNext) { <br> <br>            pSystem = SystemGet (pSystemListHead, pThisLine-&gt;lnSystemName); <br>            if (pSystem &amp;&amp; pSystem-&gt;FailureTime == 0) { <br>                AppendObjectToValueList ( <br>                    pThisLine-&gt;lnObject.ObjectNameTitleIndex, <br>                    pSystem-&gt;lpszValue); <br> <br>            } <br>        } <br>        return TRUE; <br>    } else {    // argument(s) missing <br>        return FALSE; <br>    } <br>} <br>  <br>// define in Addline.c <br>extern   PLINESTRUCT       pLineEdit ; <br>#define  bEditLine (pLineEdit != NULL) <br> <br>BOOL <br>SetSystemValueNameToGlobal ( <br>    PPERFSYSTEM pSystem <br>) <br>{ <br> <br>    if (!bEditLine &amp;&amp; ARGUMENT_PRESENT(pSystem)) { <br>        if (pSystem-&gt;lpszValue &amp;&amp; RemoveObjectsFromSystem(pSystem)) { <br>            lstrcpy ( <br>                pSystem-&gt;lpszValue, <br>                TEXT("Global")) ; <br>            return TRUE; <br>        } else { <br>            return FALSE; <br>        } <br>    } else { <br>        return FALSE; <br>    } <br>} <br>  <br>BOOL <br>RemoveUnusedSystems ( <br>    PPERFSYSTEM pSystemHead, <br>    PLINE       pLineHead <br>) <br>/*++ <br> <br>    walks system list and removes systems with no lines from list <br> <br>--*/ <br>{ <br>    PPERFSYSTEM pSystem; <br>    PPERFSYSTEM pLastSystem; <br>    PLINE       pLine; <br>    BOOL        bSystemFound; </code></pre>
<p>
</p>
<pre><code><br>    pLastSystem = NULL; <br> <br>    if ((ARGUMENT_PRESENT (pLineHead)) &amp;&amp; (ARGUMENT_PRESENT(pSystemHead))) { <br>        for (pSystem = pSystemHead; <br>             pSystem; <br>             pLastSystem = pSystem, pSystem = pSystem-&gt;pSystemNext) { <br>             <br>            if (pSystem) { <br>                bSystemFound = FALSE; <br>                // walk lines to see if this system has a line <br>                for (pLine = pLineHead; pLine; pLine = pLine-&gt;pLineNext) { <br>                    // if system in line is this system, then bailout <br>                    if (strsame (pLine-&gt;lnSystemName, pSystem-&gt;sysName)) { <br>                        bSystemFound = TRUE; <br>                        break; <br>                    } <br>                } <br>                 <br>                if (!bSystemFound) {    // delete this unused system <br> <br>                    // fix pointers <br>                    pLastSystem-&gt;pSystemNext = pSystem-&gt;pSystemNext; <br> <br>                    SystemFree (pSystem, TRUE); <br> <br>                    // set pointer back to a valid structure <br>                    pSystem = pLastSystem;  <br>                } <br>            } <br>        } <br>    } <br>    return TRUE; <br>} <br> <br>void CreatePerfmonSystemObjects () <br>{ <br>   ColorBtnFace = GetSysColor (COLOR_BTNFACE) ; <br>   hBrushFace = CreateSolidBrush (ColorBtnFace) ; <br>   hPenHighlight = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_BTNHIGHLIGHT)) ; <br>   hPenShadow = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_BTNSHADOW)) ; <br>} <br> <br>void DeletePerfmonSystemObjects () <br>{ <br>   if (hBrushFace) <br>      { <br>      DeleteBrush (hBrushFace) ; <br>      hBrushFace = 0 ; <br>      } <br>   if (hPenHighlight) <br>      { <br>      DeletePen (hPenHighlight) ; <br>      hPenHighlight = 0 ; <br>      } <br>   if (hPenShadow) <br>      { <br>      DeletePen (hPenShadow) ; <br>      hPenShadow = 0 ; <br>      } <br>} <br> <br>// This routine count the number of the same charatcer in the input string <br>int  SameCharCount (LPTSTR pInputString) <br>{ <br>   int      Count = 0 ; <br>   TCHAR    InputChar = *pInputString ; <br> <br>   if (InputChar) <br>      { <br>      while (InputChar == *pInputString) <br>         { <br>         Count ++ ; <br>         pInputString ++ ; <br>         } <br>      } <br>   return (Count) ; <br>} <br> <br>// create the format to be used in SystemTimeDateString() <br>BOOL CreateDateFormat (LPTSTR pShortDate) <br>{ <br>   int   iIndex ; <br>   int   iDayCount ; <br>   int   iMonthCount ; <br>   int   DateSeparatorCount ; <br>   TCHAR szDateSeparator [10] ; <br>   BOOL  bFirstLeading, bSecondLeading, bThirdLeading ; <br> <br>   // get the date format based on the first char <br>   if (*pShortDate == TEXT('M') || *pShortDate == TEXT('m')) <br>      { <br>      DateStyle = MONTH_FIRST ; <br>      } <br>   else if (*pShortDate == TEXT('D') || *pShortDate == TEXT('d')) <br>      { <br>      DateStyle = DAY_FIRST ; <br>      } <br>   else if (*pShortDate == TEXT('Y') || *pShortDate == TEXT('y')) <br>      { <br>      DateStyle = YEAR_FIRST ; <br>      } <br>   else <br>      { <br>      // bad format  <br>      return FALSE ; <br>      } <br> <br>   bFirstLeading = bSecondLeading = bThirdLeading = FALSE ; <br> <br>   switch (DateStyle) <br>      { <br>      case YEAR_FIRST: <br>         // YYYY-MM-DD <br>         YearCharCount = SameCharCount (pShortDate) ; <br>         pShortDate += YearCharCount ; <br>         DateSeparatorCount = SameCharCount (pShortDate) ; <br> <br>         // get the separator string <br>         for (iIndex = 0; iIndex &lt; DateSeparatorCount; iIndex ++) <br>            { <br>            szDateSeparator [iIndex] = *pShortDate++ ; <br>            } <br>         szDateSeparator [iIndex] = TEXT('\0') ; <br> <br>         iMonthCount = SameCharCount (pShortDate) ; <br>         pShortDate += iMonthCount + DateSeparatorCount ; <br>         iDayCount = SameCharCount (pShortDate) ; <br> <br>         if (YearCharCount == 2) <br>            { <br>            bFirstLeading = TRUE ; <br>            } <br> <br>         if (iMonthCount == 2) <br>            { <br>            bSecondLeading = TRUE ; <br>            } <br> <br>         if (iDayCount == 2) <br>            { <br>            bThirdLeading = TRUE ; <br>            } <br> <br>         break ; <br> <br>      case MONTH_FIRST: <br>         // MM-DD-YYYY <br>         iMonthCount = SameCharCount (pShortDate) ; <br>         pShortDate += iMonthCount ; <br>         DateSeparatorCount = SameCharCount (pShortDate) ; <br> <br>         // get the separator string <br>         for (iIndex = 0; iIndex &lt; DateSeparatorCount; iIndex ++) <br>            { <br>            szDateSeparator [iIndex] = *pShortDate++ ; <br>            } <br>         szDateSeparator [iIndex] = TEXT('\0') ; <br>          <br>         iDayCount = SameCharCount (pShortDate) ; <br>         pShortDate += iMonthCount + DateSeparatorCount ; <br>         YearCharCount = SameCharCount (pShortDate) ; <br> <br> <br>         if (iMonthCount == 2) <br>            { <br>            bFirstLeading = TRUE ; <br>            } <br> <br>         if (iDayCount == 2) <br>            { <br>            bSecondLeading = TRUE ; <br>            } <br> <br>         if (YearCharCount == 2) <br>            { <br>            bThirdLeading = TRUE ; <br>            } <br> <br>         break ; <br> <br>      case DAY_FIRST: <br>         // DD-MM-YYYY <br>         iDayCount = SameCharCount (pShortDate) ; <br>         pShortDate += iDayCount ; <br>         DateSeparatorCount = SameCharCount (pShortDate) ; <br> <br>         // get the separator string <br>         for (iIndex = 0; iIndex &lt; DateSeparatorCount; iIndex ++) <br>            { <br>            szDateSeparator [iIndex] = *pShortDate++ ; <br>            } <br>         szDateSeparator [iIndex] = TEXT('\0') ; <br>          <br>         iMonthCount = SameCharCount (pShortDate) ; <br>         pShortDate += iMonthCount + DateSeparatorCount ; <br>         YearCharCount = SameCharCount (pShortDate) ; <br> <br>         if (iDayCount == 2) <br>            { <br>            bFirstLeading = TRUE ; <br>            } <br> <br>         if (iMonthCount == 2) <br>            { <br>            bSecondLeading = TRUE ; <br>            } <br> <br>         if (YearCharCount == 2) <br>            { <br>            bThirdLeading = TRUE ; <br>            } <br> <br>         break ; <br>      } <br> <br>   // now generate the date format <br>   lstrcpy (szDateFormat, bFirstLeading ? LeadingZeroStr : NoLeadingZeroStr) ; <br>   lstrcat (szDateFormat, szDateSeparator) ; <br>   lstrcat (szDateFormat, bSecondLeading ? LeadingZeroStr : NoLeadingZeroStr) ; <br>   lstrcat (szDateFormat, szDateSeparator) ; <br>   lstrcat (szDateFormat, bThirdLeading ? LeadingZeroStr : NoLeadingZeroStr) ; <br> <br>   return TRUE ; <br>} <br> <br>BOOL CreateTimeFormat (LPTSTR pTimeSeparator, int iLeadingZero) <br>{ <br>   // create the format to be used in SystemTimeTimeString  <br>   if (iLeadingZero) <br>      { <br>      lstrcpy (szTimeFormat, LeadingZeroStr) ; <br>      } <br>   else <br>      { <br>      lstrcpy (szTimeFormat, NoLeadingZeroStr) ; <br>      } <br> <br>   lstrcat (szTimeFormat, pTimeSeparator) ; <br>   lstrcat (szTimeFormat, LeadingZeroStr) ; <br>   lstrcat (szTimeFormat, pTimeSeparator) ; <br>//   lstrcat (szTimeFormat, LeadingZeroStr) ; <br> <br>   // Duplicate the format without the msec field (for export use) <br>   lstrcpy (szTimeFormat1, szTimeFormat) ; <br> <br>   // for the msec <br>   lstrcat (szTimeFormat, TEXT("%02.1f")) ; <br> <br>   // for sec without msec <br>   lstrcat (szTimeFormat1, TEXT("%02d")) ; <br> <br>   if (iTime == 0) <br>      { <br>      lstrcat (szTimeFormat, TEXT(" %s ")) ; <br>      lstrcat (szTimeFormat1, TEXT(" %s ")) ; <br>      } <br> <br>   return TRUE ; <br>}  // CreateTimeFormats <br> <br>BOOL GetInternational() <br>{ <br>   TCHAR szShortDate[40] ; <br>   TCHAR szTime[40] ;   // time separator <br>   DWORD RetCode ; <br>   int   iTLZero = 0 ;      // = 0 for no leading zero, &lt;&gt; 0 for leading zero <br>   CHAR  aLanguageStr [2] ; <br>   LPSTR pRetStr ; <br>   LPTSTR lpStr ; <br> <br>   // read the data from the win.ini (which i smapped to registry) <br>   RetCode = GetProfileString(szInternational, <br>      TEXT("sShortDate"), szShortDate, szShortDate, sizeof(szShortDate)/sizeof(TCHAR)); <br>    <br>   if (RetCode) <br>      { <br>      RetCode = GetProfileString(szInternational, <br>         TEXT("sTime"), szTime, szTime, sizeof(szTime)/sizeof(TCHAR)); <br>      } <br> <br> <br>   if (RetCode) <br>      { <br>      iTime   = GetProfileInt(szInternational, TEXT("iTime"), iTime); <br>      iTLZero = GetProfileInt(szInternational, TEXT("iTLZero"), iTLZero); <br> <br>      GetProfileString(szInternational, TEXT("sDecimal"), szDecimal, szDecimal, sizeof(szDecimal)/sizeof(TCHAR)); <br> <br>      if (iTime == 0) <br>         { <br>         // get the AM PM strings for 12-hour format. <br>         // These two strings could be NULL. <br>         sz1159[0] = sz2359[0] = TEXT('\0') ; <br>         GetProfileString(szInternational, <br>            TEXT("s1159"), sz1159, sz1159, sizeof(sz1159)/sizeof(TCHAR)); <br> <br>         GetProfileString(szInternational, <br>            TEXT("s2359"), sz2359, sz2359, sizeof(sz2359)/sizeof(TCHAR)); <br>         } <br>      } <br> <br>   // create the two formats <br>   if (RetCode) <br>      { <br>      RetCode = (DWORD) CreateDateFormat (szShortDate) ; <br>      } <br> <br>   if (RetCode) <br>      { <br>      RetCode = (DWORD) CreateTimeFormat (szTime, iTLZero) ; <br>      } <br> <br>   // use the system default language numeric <br>   aLanguageStr[0] = '\0' ; <br>   pRetStr = setlocale(LC_NUMERIC, aLanguageStr); <br> <br>   // get current decimal point used by C-runtime <br>   TSPRINTF (szShortDate, TEXT("%f"), (FLOAT)1.0) ; <br>   lpStr = szShortDate ; <br> <br>   szCurrentDecimal [0] = TEXT('\0') ; <br> <br>   while (*lpStr != TEXT('\0')) <br>      { <br>      if (*lpStr == TEXT('1')) <br>         { <br>         lpStr++ ; <br>         szCurrentDecimal [0] = *lpStr ; <br>         break ; <br>         } <br>      lpStr++ ; <br>      } <br>    <br>   if (szCurrentDecimal[0] == TEXT('\0')) <br>      { <br>      szCurrentDecimal [0] = TEXT('.') ; <br>      } <br> <br>   return (RetCode != 0) ; <br>}  // GetInternational <br> <br> <br>// this routine is called to get the date/time formats either <br>// for the resource or from the registry. <br>void GetDateTimeFormats () <br>{ <br>   PALERT        pAlert ; <br>   PLOG          pLog ; <br>   if (!GetInternational()) <br>      { <br>      // GetInternational failed, then get default formats from resource <br>      iTime = 0 ; <br>      DateStyle = MONTH_FIRST ; <br>      YearCharCount = 4 ; <br>      StringLoad (IDS_S1159, sz1159) ; <br>      StringLoad (IDS_S2359, sz2359) ; <br>      StringLoad (IDS_TIME_FORMAT, szTimeFormat) ; <br>      StringLoad (IDS_SHORT_DATE_FORMAT, szDateFormat) ; <br>      } <br>   WindowInvalidate (PerfmonViewWindow()) ; <br> <br>   // reset all the field taht may be affected by the <br>   // language numberic changes <br> <br>   pAlert = AlertData (hWndMain) ; <br>   pLog = LogData (hWndMain) ; <br> <br>   if (pAlert) <br>      { <br>      DialogSetInterval (hWndAlert, IDD_ALERTINTERVAL, pAlert-&gt;iIntervalMSecs) ; <br>      } <br> <br>   if (pLog) <br>      { <br>      DialogSetInterval (hWndLog, IDD_LOGINTERVAL, pLog-&gt;iIntervalMSecs) ; <br>      } <br>}  // GetDateTimeFormats <br> <br>void ConvertDecimalPoint (LPTSTR lpFloatPointStr) <br>{ <br>   if (szCurrentDecimal[0] == szDecimal[0]) <br>      { <br>      // no need to convert anything <br>      return ; <br>      } <br> <br>   while (*lpFloatPointStr) <br>      { <br>      if (*lpFloatPointStr == szCurrentDecimal[0]) <br>         { <br>         *lpFloatPointStr = szDecimal[0] ; <br>         break ; <br>         } <br>      ++lpFloatPointStr ; <br>      } <br>}  // ConvertDecimalPoint <br> <br>void ReconvertDecimalPoint (LPTSTR lpFloatPointStr) <br>{ <br>   if (szCurrentDecimal[0] == szDecimal[0]) <br>      { <br>      // no need to convert anything <br>      return ; <br>      } <br> <br>   while (*lpFloatPointStr) <br>      { <br>      if (*lpFloatPointStr == szDecimal[0]) <br>         { <br>         *lpFloatPointStr = szCurrentDecimal[0] ; <br>         break ; <br>         } <br>      ++lpFloatPointStr ; <br>      } <br>}  // ReconvertDecimalPoint <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
