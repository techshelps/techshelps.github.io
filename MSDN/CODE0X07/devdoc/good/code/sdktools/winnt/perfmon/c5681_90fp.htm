<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5695"></a>REPORT.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  Report.c - This file contains the report window handler.  Some of the <br> *       support routines are in RptFct.c <br> * <br> *  Microsoft Confidential <br> *  Copyright 1992 - 1998 Microsoft Corporation <br> * <br> *  Author - <br> * <br> *       Hon-Wah Chan <br> * <br> ****************************************************************************/ <br> <br>#include "perfmon.h" <br>#include &lt;stdio.h&gt;      // for sprintf <br>#include &lt;string.h&gt;     // for strncpy <br>#include "report.h"     // Exported declarations for this file <br> <br>#include "addline.h"    // for AddLine, EditLine <br>#include "perferr.h"    // for PostError <br>#include "fileutil.h"   // for FileHandleCreate <br>#include "line.h"       // for LineAppend <br>#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines <br>#include "perfdata.h"   // for UpdateLines <br>#include "perfmops.h"   // for DoWindowDrag <br>#include "playback.h"   // for PlaybackLines, PlayingBackLog <br>#include "system.h"     // for SystemGet <br>#include "utils.h" <br>#include "menuids.h"    // for IDM_VIEWREPORT <br>#include "fileopen.h"   // for FileGetName <br>#include "counters.h"   // for CounterEntry <br> <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br>TCHAR          szSystemFormat [ResourceStringLen] ; <br>TCHAR          szObjectFormat [ResourceStringLen] ; <br> <br> <br>//=============================// <br>// Report Class                // <br>//=============================// <br> <br> <br>TCHAR   szReportWindowClass[] = TEXT("PerfRpt") ; <br>#define dwReportClassStyle           (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS) <br>#define iReportClassExtra            (0) <br>#define iReportWindowExtra           (0) <br>#define dwReportWindowStyle          (WS_CHILD | WS_VSCROLL | WS_HSCROLL) <br> <br> <br>#define szValuePlaceholder          TEXT("-999999999.999") <br>#define szValueLargeHexPlaceholder  TEXT(" xBBBBBBBBDDDDDDDD") <br> <br>#define szHexFormat                 TEXT("x%08lX") <br>#define szLargeHexFormat            TEXT("x%08lX%08lX") <br>#define szLargeValueFormat          TEXT("%12.0f") <br>#define eStatusLargeValueMax        ((FLOAT) 999999999.0) <br>#define szValueFormat               TEXT("%12.3f") <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>PREPORT AllocateReportData (HWND hWndReport) <br>   { <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWndReport) ; <br> <br>   pReport-&gt;hWnd = hWndReport ; <br>   pReport-&gt;iStatus = iPMStatusClosed ; <br>   pReport-&gt;bManualRefresh = FALSE ; <br>   pReport-&gt;bModified = FALSE ; <br> <br>   pReport-&gt;Visual.iColorIndex = 0 ; <br>   pReport-&gt;Visual.iWidthIndex = -1 ; <br>   pReport-&gt;Visual.iStyleIndex = -1 ; <br> <br>   pReport-&gt;iIntervalMSecs = iDefaultReportIntervalSecs * 1000 ; <br>   pReport-&gt;pSystemFirst = NULL ; <br>   pReport-&gt;pLineFirst = NULL ; <br> <br>   pReport-&gt;CurrentItemType = REPORT_TYPE_NOTHING ; <br>   pReport-&gt;CurrentItem.pLine = NULL ; <br> <br>   return (pReport) ; <br>   }  // AllocateReportData <br> <br> <br>void FreeReportData (PREPORT pReport) <br>   {  // FreeReportData <br>   }  // FreeReportData <br> <br> <br> <br>BOOL LineCounterRemove (PPLINE ppLineFirst, <br>                        PLINE pLineRemove) <br>   { <br>   PLINE          pLine ; <br> <br>   if (*ppLineFirst == pLineRemove) <br>      { <br>      *ppLineFirst = (*ppLineFirst)-&gt;pLineCounterNext ; <br>      return (TRUE) ; <br>      } <br> <br>   for (pLine = *ppLineFirst ; <br>        pLine-&gt;pLineCounterNext ; <br>        pLine = pLine-&gt;pLineCounterNext) <br>      {   // for <br>      if (pLine-&gt;pLineCounterNext == pLineRemove) <br>         { <br>         pLine-&gt;pLineCounterNext = pLineRemove-&gt;pLineCounterNext ; <br>         return (TRUE) ; <br>         }  // if <br>      }  // for <br> <br>   return (FALSE) ; <br>   }  // LineCounterRemove <br> <br> <br> <br>void DrawCounter (HDC hDC, PREPORT pReport, <br>                  PCOUNTERGROUP pCounterGroup) <br>   {  // DrawCounter <br>      <br>   RECT  Rect ; <br> <br> <br>   if (!pCounterGroup-&gt;pLineFirst) <br>      return ; <br> <br>   SelectFont (hDC, pReport-&gt;hFont) ; <br>   TextOut (hDC, xCounterMargin, pCounterGroup-&gt;yLine, <br>            pCounterGroup-&gt;pLineFirst-&gt;lnCounterName, <br>            lstrlen (pCounterGroup-&gt;pLineFirst-&gt;lnCounterName)) ; <br> <br>   if (pCounterGroup == pReport-&gt;CurrentItem.pCounter) <br>      { <br>      ReportCounterRect (pReport, pCounterGroup, &amp;Rect) ; <br>      DrawFocusRect (hDC, &amp;Rect) ; <br>      } <br> <br>   }  // DrawCounter <br> <br> <br>void DrawObject (HDC hDC, PREPORT pReport, <br>                 POBJECTGROUP pObjectGroup) <br>   {  // DrawObject <br>   TCHAR          szLine [LongTextLen] ; <br>   PCOUNTERGROUP  pCounterGroup ; <br>   PCOLUMNGROUP   pColumnGroup ; <br> <br>   if (!pObjectGroup-&gt;pCounterGroupFirst) <br>      { <br>      return ; <br>      } <br> <br>   SelectFont (hDC, pReport-&gt;hFontHeaders) ; <br> <br>   SetTextAlign (hDC, TA_RIGHT) ; <br> <br>   for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>        pColumnGroup ; <br>        pColumnGroup = pColumnGroup-&gt;pColumnGroupNext) <br>      {  // for <br>      // Draw Parent <br>      if (pColumnGroup-&gt;lpszParentName) <br>         TextOut (hDC,  <br>                  ValueMargin (pReport) +  <br>                  pColumnGroup-&gt;xPos + pColumnGroup-&gt;xWidth, <br>                  pObjectGroup-&gt;yFirstLine - pReport-&gt;yLineHeight, <br>                  pColumnGroup-&gt;lpszParentName, <br>                  lstrlen (pColumnGroup-&gt;lpszParentName)) ; <br> <br>      // Draw Instance <br>      if (pColumnGroup-&gt;lpszInstanceName) <br>         { <br>         TextOut (hDC,  <br>                  ValueMargin (pReport) +  <br>                  pColumnGroup-&gt;xPos + pColumnGroup-&gt;xWidth, <br>                  pObjectGroup-&gt;yFirstLine, <br>                  pColumnGroup-&gt;lpszInstanceName, <br>                  lstrlen (pColumnGroup-&gt;lpszInstanceName)) ; <br>         } <br> <br>      if (pColumnGroup == pReport-&gt;CurrentItem.pColumn) <br>         { <br>         RECT  Rect ; <br> <br>         ReportColumnRect (pReport, pColumnGroup, &amp;Rect) ; <br>         DrawFocusRect (hDC, &amp;Rect) ; <br>         } <br> <br>      }  // for <br>   SetTextAlign (hDC, TA_LEFT) ; <br> <br>   TSPRINTF (szLine, szObjectFormat, pObjectGroup-&gt;lpszObjectName) ; <br>   TextOut (hDC,  <br>            xObjectMargin, pObjectGroup-&gt;yFirstLine, <br>            szLine, lstrlen (szLine)) ; <br> <br>   if (pObjectGroup == pReport-&gt;CurrentItem.pObject) <br>      { <br>      RECT  Rect ; <br> <br>      ReportObjectRect (pReport, pObjectGroup, &amp;Rect) ; <br>      DrawFocusRect (hDC, &amp;Rect) ; <br>      } <br> <br>   SelectFont (hDC, pReport-&gt;hFont) ; <br> <br>   for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>        pCounterGroup ; <br>        pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>      {  // for <br>      DrawCounter (hDC, pReport, pCounterGroup) ; <br>      }  // for <br> <br>   }  // DrawObject <br> <br> <br>void DrawSystem (HDC hDC, PREPORT pReport, PSYSTEMGROUP pSystemGroup) <br>   {  // DrawSystem <br>   TCHAR          szLine [LongTextLen] ; <br>   POBJECTGROUP   pObjectGroup ; <br> <br>   SelectFont (hDC, pReport-&gt;hFontHeaders) ; <br> <br>   if (!pSystemGroup-&gt;pObjectGroupFirst) <br>      return ; <br> <br>   SetTextAlign (hDC, TA_LEFT) ; <br>   TSPRINTF (szLine, szSystemFormat, pSystemGroup-&gt;lpszSystemName) ; <br>   TextOut (hDC,  <br>            xSystemMargin, pSystemGroup-&gt;yFirstLine, <br>            szLine, lstrlen (szLine)) ; <br> <br>   if (pSystemGroup == pReport-&gt;CurrentItem.pSystem) <br>      { <br>      RECT  Rect ; <br> <br>      ReportSystemRect (pReport, pSystemGroup, &amp;Rect) ; <br>      DrawFocusRect (hDC, &amp;Rect) ; <br>      } <br> <br>   for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>        pObjectGroup ; <br>        pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>      {  // for <br>      DrawObject (hDC, pReport, pObjectGroup) ; <br>      }  // for <br>   }  // DrawSystem <br> <br>void DrawReportValue (HDC hDC, PREPORT pReport, PLINE pLine) <br>   {  // DrawReportValue <br>   TCHAR          szValue [20] ; <br>   FLOAT          eValue ; <br>   RECT           rectValue ; <br> <br>   // skip until we have collect enough samples for the first data <br>   if (pLine-&gt;bFirstTime == 0) <br>      { <br>      eValue = CounterEntry (pLine) ; <br>      if (pLine-&gt;lnCounterType == PERF_COUNTER_RAWCOUNT_HEX || <br>          pLine-&gt;lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) <br>         { <br>         DWORD LowValue  ; <br>         DWORD HighValue ; <br> <br>         LowValue  = (DWORD) (pLine-&gt;lnaCounterValue[0]) ; <br>         HighValue = (DWORD) (pLine-&gt;lnaCounterValue[0] &gt;&gt; 32); <br> <br>         if (pLine-&gt;lnCounterType == PERF_COUNTER_RAWCOUNT_HEX || <br>             HighValue == 0) <br>            { <br>            TSPRINTF (szValue, <br>                      szHexFormat, <br>                      LowValue) ; <br>            } <br>         else <br>            { <br> <br>            TSPRINTF (szValue, <br>                      szLargeHexFormat, <br>                      HighValue, <br>                      LowValue) ; <br>            } <br>         } <br>      else <br>         { <br>         TSPRINTF (szValue, <br>                   (eValue &gt; eStatusLargeValueMax) ? <br>                       szLargeValueFormat : szValueFormat, <br>                   eValue) ; <br>         ConvertDecimalPoint (szValue) ; <br>         } <br>      } <br>   else <br>      { <br>      // draw "- - - -" <br>      lstrcpy(szValue, DashLine); <br>      } <br> <br>   ReportLineValueRect (pReport, pLine, &amp;rectValue) ; <br>    <br>   ExtTextOut (hDC,  <br>               rectValue.right - 2, rectValue.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectValue, <br>               szValue, lstrlen (szValue), NULL) ; <br> <br>   if (pReport-&gt;CurrentItemType == REPORT_TYPE_LINE &amp;&amp; <br>       pLine == pReport-&gt;CurrentItem.pLine) <br>      { <br>      DrawFocusRect (hDC, &amp;rectValue) ; <br>      } <br>   }  // DrawReportValue <br> <br> <br>void DrawReportValues (HDC hDC, PREPORT pReport) <br>   { <br>   PSYSTEMGROUP   pSystemGroup ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PCOUNTERGROUP  pCounterGroup ; <br>   PLINE          pLine ; <br> <br>   SelectFont (hDC, pReport-&gt;hFont) ; <br>   SetTextAlign (hDC, TA_RIGHT) ; <br> <br>   for (pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>        pSystemGroup ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {  // for System... <br>      for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>           pObjectGroup ; <br>           pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>         {  // for Object... <br>         for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>              pCounterGroup ; <br>              pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>            {  // for Counter... <br>            for (pLine = pCounterGroup-&gt;pLineFirst ; <br>                 pLine ; <br>                 pLine = pLine-&gt;pLineCounterNext) <br>               {  // for Line... <br>               DrawReportValue (hDC, pReport, pLine) ; <br>               }  // for Line... <br>            }  // for Counter... <br>         }  // for Object       <br>      }  // for System... <br> <br>   } <br> <br> <br>void DrawReportHeaders (HDC hDC, PREPORT pReport) <br>   {  // DrawReportHeaders <br>   PSYSTEMGROUP   pSystemGroup ; <br> <br>   for (pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>        pSystemGroup ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {  // for <br>      DrawSystem (hDC, pReport, pSystemGroup) ; <br>      }  // for          <br>   }  // DrawReportHeaders <br> <br> <br>void DrawReport (HDC hDC, PREPORT pReport) <br>   { <br>   SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ; <br>   DrawReportHeaders (hDC, pReport) ; <br>   //UpdateLines (&amp;(pReport-&gt;pSystemFirst), pReport-&gt;pLineFirst) ; <br>   DrawReportValues (hDC, pReport) ; <br>   } <br> <br> <br> <br>void SetLinePosition (HDC hDC, <br>                      PREPORT pReport,  <br>                      POBJECTGROUP pObjectGroup, <br>                      PLINE pLine) <br>   {  // SetLinePositions <br>   PCOLUMNGROUP   pColumnGroup ; <br> <br>   pColumnGroup = GetColumnGroup (pReport, pObjectGroup, pLine) ; <br>   if (!pColumnGroup) <br>      { <br>      pLine-&gt;xReportPos = 0 ; <br>      pLine-&gt;iReportColumn = -1 ; <br>      } <br>   else <br>      { <br>      pLine-&gt;xReportPos = pColumnGroup-&gt;xPos ; <br>      pLine-&gt;iReportColumn = pColumnGroup-&gt;ColumnNumber ; <br>      } <br>   }  // SetLinePosition <br> <br> <br>void SetCounterPositions (HDC hDC, <br>                          PREPORT pReport, <br>                          POBJECTGROUP pObjectGroup, <br>                          PCOUNTERGROUP pCounterGroup, <br>                          int yLine) <br>   {  // SetCounterPositions <br>   PLINE          pLine ; <br>   int            yPos ; <br> <br> <br>   if (!pCounterGroup-&gt;pLineFirst) <br>      return ; <br> <br>   yPos = pCounterGroup-&gt;yLine ; <br> <br>   SelectFont (hDC, pReport-&gt;hFontHeaders) ; <br> <br>   for (pLine = pCounterGroup-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineCounterNext) <br>      {  // for <br>      SetLinePosition (hDC, pReport, pObjectGroup, pLine) ; <br>      pLine-&gt;yReportPos = yPos ; <br>      }  // for <br>   }  // SetCounterPositions <br> <br> <br>void SetColumnPositions (HDC hDC, <br>                         PREPORT pReport, <br>                         POBJECTGROUP pObjectGroup) <br>   {  // SetColumnPositions <br>   int            xPos ; <br>   PCOLUMNGROUP   pColumnGroup ; <br> <br>   xPos = 0 ; <br>   for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>        pColumnGroup ; <br>        pColumnGroup = pColumnGroup-&gt;pColumnGroupNext) <br>      {  // for <br>      pColumnGroup-&gt;xWidth = max (max (pColumnGroup-&gt;ParentNameTextWidth, <br>                                       pColumnGroup-&gt;InstanceNameTextWidth), <br>                                  pReport-&gt;xValueWidth) ; <br>      pColumnGroup-&gt;xPos = xPos ; <br>      pColumnGroup-&gt;yFirstLine = pObjectGroup-&gt;yFirstLine ; <br>      xPos += (pColumnGroup-&gt;xWidth + xColumnMargin) ; <br>      }  // for <br>   }  // SetColumnPositions <br> <br> <br>void SetObjectPositions (HDC hDC, <br>                         PREPORT pReport, <br>                         POBJECTGROUP pObjectGroup, <br>                         int yLine) <br>/* <br>   Effect:        Determine and set the logical coordinates for the <br>                  object pObject within the report pReport. <br> <br>                  For each instance x counter, determine the appropriate <br>                  column, adding a column description to the object if <br>                  needed. <br> <br>   Called By:     SetSystemPositions only. <br> <br>   See Also:      SetSystemPositions, SetCounterPositions, ColumnGroup. <br>*/ <br>   {  // SetObjectPositions <br>   PCOUNTERGROUP  pCounterGroup ; <br>   int            yPos ; <br>   PLINE          pLine ; <br> <br>   // check if there is parnet name for this object type <br>   // if so, need to add extra space for the parent name <br>   if (pObjectGroup-&gt;pCounterGroupFirst) <br>      { <br>      pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>      pLine = pCounterGroup-&gt;pLineFirst ; <br>      if (pLine &amp;&amp; LineParentName(pLine)) <br>         { <br>         pObjectGroup-&gt;yFirstLine += yLine ; <br>         } <br>      } <br> <br>   SetColumnPositions (hDC, pReport, pObjectGroup) ; <br> <br>   yPos = pObjectGroup-&gt;yFirstLine + yLine ; <br> <br>   for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>        pCounterGroup ; <br>        pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>      {  // for <br>      pCounterGroup-&gt;yLine = yPos + yLine ; <br>    <br>      SetCounterPositions (hDC, pReport, pObjectGroup, pCounterGroup, yLine) ; <br> <br>      yPos = pCounterGroup-&gt;yLine ; <br>      }  // for <br> <br>   pObjectGroup-&gt;yLastLine = yPos + yLine ; <br>   }  // SetObjectPositions <br> <br> <br>void SetSystemPositions (HDC hDC, <br>                         PREPORT pReport,  <br>                         PSYSTEMGROUP pSystemGroup, <br>                         int yLine) <br>   {  // SetSystemPositions <br>   POBJECTGROUP   pObjectGroup ; <br>   int            yPos ; <br> <br>   yPos = pSystemGroup-&gt;yFirstLine ; <br> <br>   for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>        pObjectGroup ; <br>        pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>      {  // for <br>      pObjectGroup-&gt;yFirstLine = yPos + yLine ; <br>    <br>      SetObjectPositions (hDC, pReport, pObjectGroup, yLine) ; <br> <br>      yPos = pObjectGroup-&gt;yLastLine ; <br>      }  // for <br> <br>   pSystemGroup-&gt;yLastLine = yPos + yLine ; <br>   }  // SetSystemPositions <br> <br> <br>void static SetScrollRanges (HWND hWnd) <br>   {  // SetScrollRanges <br>   PREPORT        pReport ; <br>   RECT           rectClient ; <br>   int            xWidth, yHeight ; <br> <br>   GetClientRect (hWnd, &amp;rectClient) ; <br>   xWidth = rectClient.right - rectClient.left ; <br>   yHeight = rectClient.bottom - rectClient.top ; <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   SetScrollRange (hWnd, SB_VERT,  <br>                   0, max (0, pReport-&gt;yHeight - yHeight),  <br>                   TRUE) ; <br>   SetScrollRange (hWnd, SB_HORZ, <br>                   0, max (0, pReport-&gt;xWidth - xWidth), <br>                   TRUE) ; <br>   }  // SetScrollRanges <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void static OnCreate (HWND hWnd) <br>   {  // OnCreate <br>   HDC            hDC ; <br>   PREPORT        pReport ; <br> <br>   pReport = AllocateReportData (hWnd) ; <br>   if (!pReport) <br>      return ; <br> <br>   pReport-&gt;hFont = hFontScales ; <br>   pReport-&gt;hFontHeaders = hFontScalesBold ; <br> <br>   pReport-&gt;pLineFirst = NULL ; <br>   pReport-&gt;pSystemFirst = NULL ; <br> <br>   pReport-&gt;pSystemGroupFirst = NULL ; <br> <br>   hDC = GetDC (hWnd) ; <br> <br>   SelectFont (hDC, pReport-&gt;hFont) ; <br> <br> <br>   pReport-&gt;yLineHeight = FontHeight (hDC, TRUE) ; <br>   pReport-&gt;xValueWidth = TextWidth (hDC, szValuePlaceholder) ; <br>   ReleaseDC (hWnd, hDC) ; <br> <br>   pReport-&gt;xWidth = 0 ; <br>   pReport-&gt;yHeight = 0 ; <br> <br>   StringLoad (IDS_SYSTEMFORMAT, szSystemFormat) ; <br>   StringLoad (IDS_OBJECTFORMAT, szObjectFormat) ; <br>   }  // OnCreate <br> <br> <br>void static OnPaint (HWND hWnd) <br>   { <br>   HDC            hDC ; <br>   PAINTSTRUCT    ps ; <br>   PREPORT        pReport ; <br> <br> <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   hDC = BeginPaint (hWnd, &amp;ps) ; <br>   //hDC = hReportDC ; <br>   SetWindowOrgEx (hDC,  <br>                   GetScrollPos (hWnd, SB_HORZ),  <br>                   GetScrollPos (hWnd, SB_VERT), <br>                   NULL) ; <br> <br>   DrawReport (hDC, pReport) ; <br> <br>   EndPaint (hWnd, &amp;ps) ; <br>   } <br> <br> <br>void static UpdateReportValues (PREPORT pReport) <br>/* <br>   Effect:        Redraw all the visible report values of pReport. <br>                  Since drawing the values completely covers any  <br>                  previous values, there is no need to erase (or flicker) <br>                  between updating values. <br> <br>   Called By:     ReportTimer, OnVScroll, OnHScroll. <br>*/ <br>   {  // UpdateReportValues <br>   HDC            hDC ; <br> <br>   hDC = GetDC (pReport-&gt;hWnd) ; <br> <br>   SetBkColor (hDC, GetSysColor(COLOR_WINDOW)) ; <br>   SetWindowOrgEx (hDC,  <br>                   GetScrollPos (pReport-&gt;hWnd, SB_HORZ),  <br>                   GetScrollPos (pReport-&gt;hWnd, SB_VERT), <br>                   NULL) ; <br> <br>   DrawReportValues (hDC, pReport) ; <br>   ReleaseDC (pReport-&gt;hWnd, hDC) ; <br> <br>   }  // UpdateReportValues <br> <br> <br> <br>void static OnHScroll (HWND hWnd, <br>                       int iScrollCode, <br>                       int iScrollNewPos) <br>   {  // OnHScroll <br>   PREPORT        pReport ; <br>   int            iScrollAmt, iScrollPos, iScrollRange ; <br>   int            iScrollLo ; <br>   RECT           rectClient ; <br>   int            xWidth ; <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   GetClientRect (hWnd, &amp;rectClient) ; <br>   xWidth = rectClient.right - rectClient.left ; <br> <br>   if (pReport-&gt;xWidth &lt;= xWidth) <br>      { <br>      // no horz scroll bar, forget it <br>      return ; <br>      } <br> <br>   iScrollPos = GetScrollPos (hWnd, SB_HORZ) ; <br> <br>   GetScrollRange (hWnd, SB_HORZ, &amp;iScrollLo, &amp;iScrollRange) ; <br> <br> <br>   switch (iScrollCode) <br>      { <br>      case SB_LINEUP: <br>           iScrollAmt = - Report.yLineHeight ; <br>           break ; <br> <br>      case SB_LINEDOWN: <br>           iScrollAmt = Report.yLineHeight ; <br>           break ; <br> <br>      case SB_PAGEUP: <br>           iScrollAmt = - (rectClient.right - rectClient.left) / 2 ; <br>           break ; <br> <br>      case SB_PAGEDOWN: <br>           iScrollAmt = (rectClient.right - rectClient.left) / 2 ; <br>           break ; <br> <br>      case SB_THUMBPOSITION: <br>           iScrollAmt = iScrollNewPos - iScrollPos ; <br>           break ; <br> <br>      default: <br>           iScrollAmt = 0 ; <br>      }  // switch <br> <br>     iScrollAmt = PinInclusive (iScrollAmt, <br>                                -iScrollPos, <br>                                iScrollRange - iScrollPos) ; <br>     if (iScrollAmt) <br>        { <br>        iScrollPos += iScrollAmt ; <br>        ScrollWindow (hWnd, -iScrollAmt, 0, NULL, NULL) ; <br>        SetScrollPos (hWnd, SB_HORZ, iScrollPos, TRUE) ; <br>        UpdateWindow (hWnd) ; <br>#if 0 <br>        UpdateReportValues (pReport) ; <br>#endif <br>        } <br>   }  // OnHScroll <br> <br> <br> <br>void static OnVScroll (HWND hWnd, <br>                       int iScrollCode, <br>                       int iScrollNewPos) <br>   {  // OnVScroll <br>   PREPORT        pReport ; <br>   int            iScrollAmt, iScrollPos, iScrollRange ; <br>   int            iScrollLo ; <br>   RECT           rectClient ; <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   iScrollPos = GetScrollPos (hWnd, SB_VERT) ; <br>   GetScrollRange (hWnd, SB_VERT, &amp;iScrollLo, &amp;iScrollRange) ; <br> <br>   GetClientRect (hWnd, &amp;rectClient) ; <br> <br>   switch (iScrollCode) <br>      { <br>      case SB_LINEUP: <br>           iScrollAmt = - Report.yLineHeight ; <br>           break ; <br> <br>      case SB_LINEDOWN: <br>           iScrollAmt = Report.yLineHeight ; <br>           break ; <br> <br>      case SB_PAGEUP: <br>           iScrollAmt = - (rectClient.bottom - rectClient.top) / 2 ; <br>           break ; <br> <br>      case SB_PAGEDOWN: <br>           iScrollAmt = (rectClient.bottom - rectClient.top) / 2 ; <br>           break ; <br> <br>      case SB_THUMBPOSITION: <br>           iScrollAmt = iScrollNewPos - iScrollPos ; <br>           break ; <br> <br>      default: <br>           iScrollAmt = 0 ; <br>      }  // switch <br> <br>     iScrollAmt = PinInclusive (iScrollAmt, <br>                                -iScrollPos, <br>                                iScrollRange - iScrollPos) ; <br>     if (iScrollAmt) <br>        { <br>        iScrollPos += iScrollAmt ; <br>        ScrollWindow (hWnd, 0, -iScrollAmt, NULL, NULL) ; <br>        SetScrollPos (hWnd, SB_VERT, iScrollPos, TRUE) ; <br> <br>//        WindowInvalidate (hWnd) ; <br>        UpdateWindow (hWnd) ; <br>#if 0 <br>        UpdateReportValues (pReport) ;         <br>#endif <br>        } <br>   }  // OnVScroll <br> <br>void static OnKeyDown (HWND hWnd, DWORD wParam) <br>   { <br>   switch (wParam) <br>      { <br>      case VK_UP: <br>         OnVScroll (hWnd, SB_LINEUP, 0) ; <br>         break ; <br> <br>      case VK_DOWN: <br>         OnVScroll (hWnd, SB_LINEDOWN, 0) ; <br>         break ; <br> <br>      case VK_LEFT: <br>         OnHScroll (hWnd, SB_LINEUP, 0) ; <br>         break ; <br> <br>      case VK_RIGHT: <br>         OnHScroll (hWnd, SB_LINEDOWN, 0) ; <br>         break ; <br> <br>      case VK_PRIOR: <br>         OnVScroll (hWnd, SB_PAGEUP, 0) ; <br>         break ; <br> <br>      case VK_NEXT: <br>         OnVScroll (hWnd, SB_PAGEDOWN, 0) ; <br>         break ; <br>      } <br>   }  // OnKeyDown <br>        <br>          <br>LRESULT APIENTRY ReportWndProc (HWND hWnd, <br>                               WORD wMsg, <br>                               DWORD wParam, <br>                               LONG lParam) <br>   {  // ReportWndProc <br>   BOOL           bCallDefProc ; <br>   LRESULT        lReturnValue ; <br> <br>   bCallDefProc = FALSE ; <br>   lReturnValue = 0L ; <br> <br>   switch (wMsg) <br>      {  // switch <br>      case WM_CREATE: <br>         OnCreate (hWnd) ; <br>         break ; <br> <br>      case WM_LBUTTONDOWN: <br> <br>         if (!OnReportLButtonDown (hWnd, LOWORD (lParam), HIWORD (lParam))) <br>            { <br>            // mouse click do not hit on any entries, see if we  <br>            // need to drag Perfmon <br>            if (!(Options.bMenubar)) <br>               { <br>               DoWindowDrag (hWnd, lParam) ; <br>               } <br>            } <br>         break ; <br> <br>      case WM_LBUTTONDBLCLK: <br>         SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ; <br>         break ; <br> <br>      case WM_PAINT: <br>         OnPaint (hWnd) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         SetScrollRanges (hWnd) ; <br>         break ; <br> <br>      case WM_HSCROLL: <br>         OnHScroll (hWnd, LOWORD (wParam), HIWORD (wParam)) ; <br>         break ; <br> <br>      case WM_VSCROLL: <br>         OnVScroll (hWnd, LOWORD (wParam), HIWORD (wParam)) ; <br>         break ; <br> <br>      case WM_TIMER: <br>         ReportTimer (hWnd, FALSE) ; <br>         break ; <br> <br>      case WM_KEYDOWN: <br>         OnKeyDown (hWnd, wParam) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         KillTimer (hWnd, ReportTimerID) ; <br>         break ; <br> <br>      default: <br>         bCallDefProc = TRUE ; <br>      }  // switch <br> <br> <br>   if (bCallDefProc) <br>      lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ; <br> <br>   return (lReturnValue); <br>   }  // ReportWndProc <br> <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br>#if 0 <br>PREPORT ReportData (HWND hWndReport) <br>   { <br>   return (&amp;Report) ; <br>   } <br>#endif <br> <br>void SetReportTimer (PREPORT pReport) <br>   {   <br>   if (pReport-&gt;iStatus == iPMStatusCollecting) <br>      KillTimer (pReport-&gt;hWnd, ReportTimerID) ; <br> <br>   SetTimer (pReport-&gt;hWnd, ReportTimerID,  <br>             pReport-&gt;iIntervalMSecs , NULL) ; <br>   pReport-&gt;iStatus = iPMStatusCollecting ; <br>   } <br> <br> <br>void ClearReportTimer (PREPORT pReport) <br>   { <br>   pReport-&gt;iStatus = iPMStatusClosed ; <br>   KillTimer (pReport-&gt;hWnd, ReportTimerID) ; <br>   } <br> <br> <br>BOOL ReportInitializeApplication (void) <br>   {  // ReportInitializeApplication <br>   BOOL           bSuccess ; <br>   WNDCLASS       wc ; <br> <br>   //=============================// <br>   // Register ReportWindow class  // <br>   //=============================// <br> <br> <br>   wc.style         = dwReportClassStyle ; <br>   wc.lpfnWndProc   = (WNDPROC) ReportWndProc ; <br>   wc.hInstance     = hInstance ; <br>   wc.cbClsExtra    = iReportWindowExtra ; <br>   wc.cbWndExtra    = iReportClassExtra ; <br>   wc.hIcon         = NULL ; <br>   wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ; <br>//   wc.hbrBackground = GetStockObject (WHITE_BRUSH) ; <br>   wc.hbrBackground =   (HBRUSH) (COLOR_WINDOW + 1) ; <br>   wc.lpszMenuName  = NULL ; <br>   wc.lpszClassName = szReportWindowClass ; <br> <br>   bSuccess = RegisterClass (&amp;wc) ; <br> <br> <br>   //=============================// <br>   // Register Child classes      // <br>   //=============================// <br> <br>   return (bSuccess) ; <br>   }  // ReportInitializeApplication <br> <br> <br> <br> <br> <br>HWND CreateReportWindow (HWND hWndParent) <br>/* <br>   Effect:        Create the graph window. This window is a child of  <br>                  hWndMain and is a container for the graph data, <br>                  graph label, graph legend, and graph status windows. <br> <br>   Note:          We dont worry about the size here, as this window <br>                  will be resized whenever the main window is resized. <br> <br>*/ <br>   { <br>   return (CreateWindow (szReportWindowClass,       // window class <br>                         NULL,                     // caption <br>                         dwReportWindowStyle,       // style for window <br>                         0, 0,                     // initial position <br>                         0, 0,                     // initial size <br>                         hWndParent,               // parent <br>                         NULL,                     // menu <br>                         hInstance,               // program instance <br>                         NULL)) ;                  // user-supplied data                                               <br>   }  // CreateReportWindow <br> <br> <br> <br>void SetReportPositions (HDC hDC, <br>                         PREPORT pReport) <br>   { <br>   PSYSTEMGROUP   pSystemGroup ; <br>   int            yLine ; <br>   int            yPos ; <br> <br>   <br>//   pReport-&gt;xMaxCounterWidth = 0 ; <br> <br>   yLine = pReport-&gt;yLineHeight ; <br>   yPos = 2 * yLine ; <br> <br>   for (pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>        pSystemGroup ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {  // for <br>      pSystemGroup-&gt;yFirstLine = yPos + yLine ; <br> <br>      SetSystemPositions (hDC, pReport, pSystemGroup, yLine) ; <br> <br>      yPos = pSystemGroup-&gt;yLastLine ; <br>      }  // for  <br> <br>   pReport-&gt;yHeight = yPos ; <br> <br>   SetScrollRanges (pReport-&gt;hWnd) ; <br>   }  // SetReportPositions <br> <br> <br> <br>void PlaybackReport (HWND hWndReport) <br>   {  // PlaybackReport <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWndReport) ; <br> <br>   PlaybackLines (pReport-&gt;pSystemFirst,  <br>                  pReport-&gt;pLineFirst,  <br>                  PlaybackLog.StartIndexPos.iPosition) ; <br>   PlaybackLines (pReport-&gt;pSystemFirst,  <br>                  pReport-&gt;pLineFirst,  <br>                  PlaybackLog.StopIndexPos.iPosition) ; <br>   }  // PlaybackReport <br> <br> <br>BOOL CurrentReportItem (HWND hWndReport) <br>   {  // CurrentReportItem <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWndReport) ; <br>   if (!pReport) <br>      return (FALSE) ; <br> <br>   return (pReport-&gt;CurrentItemType != REPORT_TYPE_NOTHING) ; <br>   }  // CurrentReportItem </code></pre>
<p>
</p>
<pre><code><br> <br> <br>BOOL AddReport (HWND hWndParent) <br>   { <br>   PREPORT        pReport ; <br>   LPTSTR         pCurrentSystem ; <br>   POBJECTGROUP  pParentObject ; <br> <br>   pReport = ReportData (hWndReport) ; <br> <br>   if (pReport-&gt;CurrentItemType == REPORT_TYPE_LINE) <br>      { <br>      pCurrentSystem = pReport-&gt;CurrentItem.pLine-&gt;lnSystemName ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_SYSTEM) <br>      { <br>      pCurrentSystem = pReport-&gt;CurrentItem.pSystem-&gt;lpszSystemName ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_OBJECT) <br>      { <br>      pCurrentSystem = pReport-&gt;CurrentItem.pObject-&gt;pParentSystem-&gt;lpszSystemName ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_COLUMN) <br>      { <br>      pParentObject =  pReport-&gt;CurrentItem.pColumn-&gt;pParentObject ; <br>      pCurrentSystem =  pParentObject-&gt;pParentSystem-&gt;lpszSystemName ; <br>      } <br>   else if (pReport-&gt;CurrentItemType == REPORT_TYPE_COUNTER) <br>      { <br>      pParentObject =  pReport-&gt;CurrentItem.pCounter-&gt;pParentObject ; <br>      pCurrentSystem =  pParentObject-&gt;pParentSystem-&gt;lpszSystemName ; <br>      } <br>   else <br>      { <br>      pCurrentSystem = NULL ; <br>      } <br> <br> <br>   return (AddLine (hWndParent,  <br>                    &amp;(pReport-&gt;pSystemFirst),  <br>                    &amp;(pReport-&gt;Visual), <br>                    pCurrentSystem, <br>                    LineTypeReport)) ; <br>   } <br> <br> <br>BOOL ToggleReportRefresh (HWND hWnd) <br>   {  // ToggleReportRefresh <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   if (pReport-&gt;bManualRefresh) <br>      SetReportTimer (pReport) ; <br>   else <br>      ClearReportTimer (pReport) ; <br> <br>   pReport-&gt;bManualRefresh = !pReport-&gt;bManualRefresh ; <br>   return (pReport-&gt;bManualRefresh) ; <br>   }  // ToggleReportRefresh <br> <br>BOOL ReportRefresh (HWND hWnd) <br>   {  // ReportRefresh <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   return (pReport-&gt;bManualRefresh) ; <br>   }  // ReportRefresh <br> <br> <br> <br>void ReportTimer (HWND hWnd, BOOL bForce) <br>   { <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWnd) ; <br> <br>   if (PlayingBackLog () || !pReport) <br>      { <br>      return; <br>      } <br> <br>   if (bForce || !pReport-&gt;bManualRefresh) <br>      {  // if <br>      UpdateLines (&amp;(pReport-&gt;pSystemFirst), pReport-&gt;pLineFirst) ; <br>      if (iPerfmonView == IDM_VIEWREPORT &amp;&amp; !bPerfmonIconic) <br>         { <br>         // only need to draw the data when we are viewing it... <br>         UpdateReportValues (pReport) ; <br>         } <br>      }  // if <br>   }  // ReportTimer <br> <br>BOOL SaveReport (HWND hWndReport, HANDLE hInputFile, BOOL bGetFileName) <br>   { <br>   PREPORT        pReport ; <br>   PLINE          pLine ; <br>   HANDLE         hFile ; <br>   DISKREPORT     DiskReport ; <br>   PERFFILEHEADER FileHeader ; <br>   TCHAR          szFileName [256] ; <br>   BOOL           newFileName = FALSE ; <br> <br>   pReport = ReportData (hWndReport) ; <br>   if (!pReport) <br>      { <br>      return (FALSE) ; <br>      } <br> <br>   if (hInputFile) <br>      { <br>      // use the input file handle if it is available <br>      // this is the case for saving workspace data <br>      hFile = hInputFile ; <br>      } <br>   else <br>      { <br>      if (pReportFullFileName) <br>         { <br>         lstrcpy (szFileName, pReportFullFileName) ; <br>         } <br>      if (bGetFileName || pReportFullFileName == NULL) <br>         { <br>         if (!FileGetName (hWndReport, IDS_REPORTFILE, szFileName)) <br>            { <br>            return (FALSE) ; <br>            } <br>         newFileName = TRUE ; <br>         } <br> <br>      hFile = FileHandleCreate (szFileName) ; <br> <br>      if (hFile &amp;&amp; newFileName) <br>         { <br>         ChangeSaveFileName (szFileName, IDM_VIEWREPORT) ; <br>         } <br>      else if (!hFile) <br>         { <br>         DlgErrorBox (hWndReport, ERR_CANT_OPEN, szFileName) ; <br>         } <br>      } <br> <br> <br>   if (!hFile) <br>      return (FALSE) ; <br> <br> <br>   if (!hInputFile) <br>      { <br>      memset (&amp;FileHeader, 0, sizeof (FileHeader)) ; <br>      lstrcpy (FileHeader.szSignature, szPerfReportSignature) ; <br>      FileHeader.dwMajorVersion = ReportMajorVersion ; <br>      FileHeader.dwMinorVersion = ReportMinorVersion ; <br>    <br>      if (!FileWrite (hFile, &amp;FileHeader, sizeof (PERFFILEHEADER))) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   DiskReport.Visual = pReport-&gt;Visual ; <br>   DiskReport.bManualRefresh = pReport-&gt;bManualRefresh ; <br>   DiskReport.dwIntervalSecs = pReport-&gt;iIntervalMSecs ; <br>   DiskReport.dwNumLines = NumLines (pReport-&gt;pLineFirst) ; <br>   DiskReport.perfmonOptions = Options ; <br> <br>   if (!FileWrite (hFile, &amp;DiskReport, sizeof (DISKREPORT))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   for (pLine = pReport-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      if (!WriteLine (pLine, hFile)) <br>         { <br>         goto Exit0 ; <br>         } <br>      }  // for <br> <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br> <br>      // only need to report error if not workspace  <br>      DlgErrorBox (hWndReport, ERR_SETTING_FILE, szFileName) ; <br>      } <br>   return (FALSE) ; <br>   }  // SaveReport   <br> <br> <br>void ReportAddAction (PREPORT pReport) <br>   { <br>   HDC      hDC ; <br> <br>   //=============================// <br>   // Calculate report positions  // <br>   //=============================// <br> <br>   hDC = GetDC (hWndReport) ; <br>   SetReportPositions (hDC, pReport) ; <br>   ReleaseDC (hWndReport, hDC) ; <br>    <br>   if (PlayingBackLog ()) <br>      { <br>      PlaybackReport (hWndReport) ; <br>      } <br>   else if (pReport-&gt;iStatus == iPMStatusClosed) <br>      { <br>      SetReportTimer (pReport) ; <br>      } <br> <br>   WindowInvalidate (hWndReport) ; <br>   } <br> <br> <br>BOOL OpenReportVer1 (HANDLE hFile, <br>                     DISKREPORT *pDiskReport, <br>                     PREPORT pReport, <br>                     DWORD dwMinorVersion) <br>   { <br>   HDC   hDC ; <br> <br>   pReport-&gt;Visual = pDiskReport-&gt;Visual ; <br>   pReport-&gt;iIntervalMSecs = pDiskReport-&gt;dwIntervalSecs ; <br>   if (dwMinorVersion &lt; 3) <br>      { <br>      // convert this to msec <br>      pReport-&gt;iIntervalMSecs *= 1000 ; <br>      } <br>   pReport-&gt;bManualRefresh = pDiskReport-&gt;bManualRefresh ; <br> <br>   bDelayAddAction = TRUE ; <br>   ReadLines (hFile, pDiskReport-&gt;dwNumLines, <br>             &amp;(pReport-&gt;pSystemFirst), &amp;(pReport-&gt;pLineFirst), IDM_VIEWREPORT) ; <br> <br>   if (pReport-&gt;pLineFirst) <br>      { <br>      // set focus on the first line <br>      pReport-&gt;CurrentItem.pLine = pReport-&gt;pLineFirst ; <br>      pReport-&gt;CurrentItemType = REPORT_TYPE_LINE ; <br>      } <br>   bDelayAddAction = FALSE ; <br> <br>   //=============================// <br>   // Calculate report positions  // <br>   //=============================// <br> <br>   hDC = GetDC (hWndReport) ; <br>   SetReportPositions (hDC, pReport) ; <br>   ReleaseDC (hWndReport, hDC) ; <br> <br>   if (PlayingBackLog ()) <br> <br>      { <br>      PlaybackReport (hWndReport) ; <br>      } <br>   else if (pReport-&gt;iStatus == iPMStatusClosed) <br>      { <br>      SetReportTimer (pReport) ; <br>      } <br> <br>   WindowInvalidate (hWndReport) ; <br> <br>   return (TRUE) ; <br>   }  // OpenReportVer1 <br> <br> <br> <br>BOOL OpenReport (HWND hWndReport,  <br>                 HANDLE hFile,  <br>                 DWORD dwMajorVersion, <br>                 DWORD dwMinorVersion, <br>                 BOOL bReportFile) <br>   { <br>   PREPORT        pReport ; <br>   DISKREPORT     DiskReport ; <br>   BOOL           bSuccess = TRUE ; <br> <br>   pReport = ReportData (hWndReport) ; <br>   if (!pReport) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br>   if (!FileRead (hFile, &amp;DiskReport, sizeof (DISKREPORT))) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br> <br>   switch (dwMajorVersion) <br>      { <br>      case (1): <br>          <br>         SetHourglassCursor() ; <br>      <br>         ResetReportView (hWndReport) ; <br> <br>         OpenReportVer1 (hFile, &amp;DiskReport, pReport, dwMinorVersion) ; <br> <br>         // change to report view if we are opening a  <br>         // report file <br>         if (bReportFile &amp;&amp; iPerfmonView != IDM_VIEWREPORT) <br>            { <br>            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWREPORT, 0L) ; <br>            } <br> <br>         if (iPerfmonView == IDM_VIEWREPORT) <br>            { <br>            SetPerfmonOptions (&amp;DiskReport.perfmonOptions) ; <br>            } <br> <br>         SetArrowCursor() ; <br> <br>         break ; <br>      }  // switch <br> <br>Exit0: <br>       <br>   if (bReportFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // OpenReport <br> <br>void ResetReportView (HWND hWndReport) <br>   {  // ResetReportView <br>   PREPORT        pReport ; <br> <br>   pReport = ReportData (hWndReport) ; <br>    <br>   if (!pReport) <br>      { <br>      return ; <br>      } <br>    <br>   ChangeSaveFileName (NULL, IDM_VIEWREPORT) ; <br> <br>   if (pReport-&gt;pSystemGroupFirst) <br>      { <br>      ResetReport (hWndReport) ; <br>      } <br>   }  // ResetReportView <br> <br> <br>void ResetReport (HWND hWndReport) <br>   {  // ResetReport <br>   PREPORT        pReport ; <br>   PSYSTEMGROUP   pSystemGroup, pSystemGroupDelete ; <br>   POBJECTGROUP   pObjectGroup, pObjectGroupDelete ; <br>   PCOUNTERGROUP  pCounterGroup, pCounterGroupDelete ; <br>   HDC            hDC ; <br> <br>   pReport = ReportData (hWndReport) ; <br>   if (!pReport) <br>      return ; <br> <br>   ClearReportTimer (pReport) ; <br> <br>   pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>   while (pSystemGroup) <br>      {  <br>      pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; <br>      while (pObjectGroup) <br>         { <br>         pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>         while (pCounterGroup) <br>            { <br>            pCounterGroupDelete = pCounterGroup ; <br>            pCounterGroup = pCounterGroup-&gt;pCounterGroupNext ; <br>            MemoryFree (pCounterGroupDelete) ; <br>            }  // while pCounter... <br>          <br>         pObjectGroupDelete = pObjectGroup ; <br>         pObjectGroup = pObjectGroup-&gt;pObjectGroupNext ; <br>         ColumnGroupRemove (pObjectGroupDelete-&gt;pColumnGroupFirst) ; <br>         MemoryFree (pObjectGroupDelete-&gt;lpszObjectName) ; <br>         MemoryFree (pObjectGroupDelete) ; <br>         }  // while pObject <br> <br>      pSystemGroupDelete = pSystemGroup ; <br>      pSystemGroup = pSystemGroup-&gt;pSystemGroupNext ; <br>      MemoryFree (pSystemGroupDelete-&gt;lpszSystemName) ; <br>      MemoryFree (pSystemGroupDelete) ; <br>      }  // while pSystem... <br> <br>   FreeLines (pReport-&gt;pLineFirst) ; <br>   pReport-&gt;pLineFirst = NULL ; <br> <br>   FreeSystems (pReport-&gt;pSystemFirst) ; <br>   pReport-&gt;pSystemFirst = NULL ; <br> <br>   pReport-&gt;pSystemGroupFirst = NULL ; <br>   pReport-&gt;CurrentItemType   = REPORT_TYPE_NOTHING ; <br>   pReport-&gt;CurrentItem.pLine = NULL ; <br> <br>   // reset scrolling ranges <br>   pReport-&gt;xWidth = 0 ; <br>   pReport-&gt;yHeight = 0 ; <br>   pReport-&gt;xMaxCounterWidth = 0 ; <br>   hDC = GetDC (hWndReport) ; <br>   SetReportPositions (hDC, pReport) ; <br> <br>   SelectFont (hDC, pReport-&gt;hFont) ; <br>   pReport-&gt;xValueWidth = TextWidth (hDC, szValuePlaceholder) ; <br> <br>   ReleaseDC (hWndReport, hDC) ; <br> <br>   WindowInvalidate (hWndReport) ; <br>   }  // ResetReport <br>    <br>void ClearReportDisplay (HWND hWndReport) <br>   {  // ResetReport <br>   PREPORT        pReport ; <br>   PLINE          pLine; <br> <br>   if (PlayingBackLog()) <br>      { <br>      return ; <br>      } <br> <br>   pReport = ReportData (hWndReport) ; <br>   if (!pReport || !pReport-&gt;pLineFirst) <br>      return ; <br> <br>   for (pLine = pReport-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      { <br>      // reset the new data counts <br>      pLine-&gt;bFirstTime = 2 ; <br>      } <br> <br>   // re-draw the values <br>   UpdateReportValues (pReport) ; <br> <br>   }  // ClearReportDisplay <br>  <br>//========================================= <br>// we don't print. we just export <br>// <br>// if need printing, define KEEP_PRINT <br>//========================================= <br>#ifdef KEEP_PRINT <br>BOOL PrintReportDisplay (HDC hDC, <br>                         PREPORT pReport) <br>   { <br>   SetReportPositions (hDC, pReport) ; <br>   DrawReport (hDC, pReport) ; <br>   return TRUE ; <br>   }  // PrintReportDisplay <br> <br> <br> <br>BOOL PrintReport (HWND hWndParent, <br>                  HWND hWndReport) <br>   { <br>   PREPORT        pReport ; <br>   HDC            hDC ; <br>   int            xPageWidth ; <br>   int            yPageHeight ; <br>   int            xValueWidth ; <br> <br>   HFONT          hFont, hFontHeaders ; <br>   int            yLineHeight ; <br> <br>   pReport = ReportData (hWndReport) ; <br>   if (!pReport) <br>      return (FALSE) ; <br> <br>   hDC = PrintDC () ; <br>   if (!hDC) <br>      { <br>      PostError () ; <br>      return (FALSE) ; <br>      } <br>       <br>   xPageWidth = GetDeviceCaps (hDC, HORZRES) ; <br>   yPageHeight = GetDeviceCaps (hDC, VERTRES) ; <br> <br>    <br>   StartJob (hDC, TEXT("Performance Monitor Report")) ; <br>   StartPage (hDC) ;    <br> <br> <br>   hFont = pReport-&gt;hFont ; <br>   hFontHeaders = pReport-&gt;hFontHeaders ; <br>   yLineHeight = pReport-&gt;yLineHeight ; <br>   xValueWidth = pReport-&gt;xValueWidth ; <br> <br>   pReport-&gt;hFont = hFontPrinterScales ; <br>   pReport-&gt;hFontHeaders = hFontPrinterScalesBold ; <br> <br>   SelectFont (hDC, pReport-&gt;hFont) ; <br>   pReport-&gt;yLineHeight = FontHeight (hDC, TRUE) ; <br> <br>   pReport-&gt;xValueWidth = TextWidth (hDC, szValuePlaceholder) ; <br> <br>   PrintReportDisplay (hDC, pReport) ; <br> <br>   EndPage (hDC) ; <br>   EndJob (hDC) ; <br>    <br>   DeleteDC (hDC) ; <br> <br> <br>   pReport-&gt;hFont = hFont ; <br>   pReport-&gt;hFontHeaders = hFontHeaders ; <br>   pReport-&gt;yLineHeight = yLineHeight ; <br> <br>   pReport-&gt;xValueWidth = xValueWidth ; <br> <br>   hDC = GetDC (hWndReport) ; <br>   SetReportPositions (hDC, pReport) ; <br>   ReleaseDC (hWndReport, hDC) ; <br> <br>   return (FALSE) ; <br>   }  // PrintReport <br> <br>// we don't print. we just export <br>#endif <br> <br> <br> <br>BOOL ReportInsertLine (HWND hWnd, PLINE pLine) <br>/* <br>   Effect:        Insert the line pLine into the data structures for the <br>                  Report of window hWnd. The line is added to the list of <br>                  lines, and also added to the report structure in the  <br>                  appropriate System, Object, and Counter. <br> <br>   Returns:       Whether the function was successful. If this function  <br>                  returns FALSE, the line was not added. <br>*/ <br>   {  // ReportInsertLine <br>   HDC            hDC ; <br>   PREPORT        pReport ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PCOUNTERGROUP  pCounterGroup ; <br>   PLINE          pLineEquivalent ; <br>   int            OldCounterWidth ; <br>   BOOL           bNewCounterGroup ; <br> <br>   pReport = ReportData (hWnd) ; <br>   pReport-&gt;bModified = TRUE ; <br> <br>   pLineEquivalent = FindEquivalentLine (pLine, pReport-&gt;pLineFirst) ; <br>   if (pLineEquivalent)  <br>      { <br>      return (FALSE) ;  <br>      } <br>   else <br>      { <br>      //=============================// <br>      // Add line, line's system     // <br>      //=============================// <br> <br>      LineAppend (&amp;pReport-&gt;pLineFirst, pLine) ; <br>      SystemAdd (&amp;pReport-&gt;pSystemFirst, pLine-&gt;lnSystemName) ; <br> <br> <br>      //=============================// <br>      // Find correct spot; add line // <br>      //=============================// <br> <br>      pSystemGroup = GetSystemGroup (pReport, pLine-&gt;lnSystemName) ; <br>      pObjectGroup = GetObjectGroup (pSystemGroup, pLine-&gt;lnObjectName) ; <br>      pCounterGroup = GetCounterGroup (pObjectGroup,  <br>                                 pLine-&gt;lnCounterDef.CounterNameTitleIndex, <br>                                 &amp;bNewCounterGroup, <br>                                 pLine-&gt;lnCounterName) ; <br> <br>      if (!pCounterGroup) <br>         return (FALSE) ; <br> <br>      LineCounterAppend (&amp;pCounterGroup-&gt;pLineFirst, pLine) ; <br>    <br>      //=============================// <br>      // Calculate report positions  // <br>      //=============================// <br>      hDC = GetDC (hWnd) ; <br>      SelectFont (hDC, pReport-&gt;hFontHeaders) ; <br> <br>      if (bNewCounterGroup) <br>         { <br>         // re-calc. the max. counter group width  <br>         OldCounterWidth = pReport-&gt;xMaxCounterWidth ; <br>         pReport-&gt;xMaxCounterWidth =  <br>            max (pReport-&gt;xMaxCounterWidth, <br>                 TextWidth (hDC, pLine-&gt;lnCounterName)) ; <br>         if (OldCounterWidth &lt; pReport-&gt;xMaxCounterWidth) <br>            { <br>            // adjust the report width with the new counter width <br>            pReport-&gt;xWidth += <br>               (pReport-&gt;xMaxCounterWidth - OldCounterWidth); <br>            } <br>         } <br> <br>      if (pLine-&gt;lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) <br>         { <br>         SelectFont (hDC, pReport-&gt;hFont) ; <br>         pReport-&gt;xValueWidth = TextWidth (hDC, szValueLargeHexPlaceholder) ; <br>         } <br> <br>      if (!bDelayAddAction) <br>         { <br>         SetReportPositions (hDC, pReport) ; <br>         } <br>      ReleaseDC (hWnd, hDC) ; <br> <br>      pReport-&gt;CurrentItem.pLine = pLine ; <br>      pReport-&gt;CurrentItemType = REPORT_TYPE_LINE ; <br>       <br>      if (!bDelayAddAction) <br>         { <br>         if (PlayingBackLog ()) <br>            { <br>            PlaybackReport (hWndReport) ; <br>            } <br>         else if (pReport-&gt;iStatus == iPMStatusClosed) <br>            { <br>            SetReportTimer (pReport) ; <br>            } <br>          <br>         WindowInvalidate (hWnd) ; <br>         } <br>      }  // else <br> <br>      return (TRUE) ; <br>   }  // ReportInsertLine <br> <br> <br>BOOL ExportComputerName (HANDLE hFile, PSYSTEMGROUP pSystemGroup) <br>{ <br>   int            StringLen ; <br>   BOOL           bWriteSuccess = TRUE ; <br> <br>   CHAR           TempBuff [LongTextLen * 2] ; <br> <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br> <br>   // export computer name <br>   strcpy (TempBuff, LineEndStr) ; <br>   strcat (TempBuff, LineEndStr) ; <br>   StringLen = strlen (TempBuff) ; <br>   TSPRINTF (UnicodeBuff, szSystemFormat, pSystemGroup-&gt;lpszSystemName) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, LineEndStr) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      bWriteSuccess = FALSE ;  <br>      } <br> <br>   return (bWriteSuccess) ; <br>}  // ExportComputerName <br> <br>#define WRITE_FILE_TIME 2 <br>BOOL ExportObjectName (HANDLE hFile, POBJECTGROUP pObjectGroup, int *pColNum) <br>{ <br>   int            StringLen ; <br>   BOOL           bNeedToExport ; <br>   BOOL           bWriteSuccess = TRUE ; <br>   PCOLUMNGROUP   pColumnGroup ; <br>   int            ParentNum, InstanceNum ; <br>   int            TimeToWrite ; <br> <br>   CHAR           TempBuff [512 * 2] ; <br> <br>   TCHAR          UnicodeBuff [512] ; <br> <br>   ParentNum = InstanceNum = 0 ; <br> <br>   if (pColNum) <br>      { <br>      *pColNum = 0 ; <br>      } <br> <br>   // export object name <br>   strcpy (TempBuff, LineEndStr) ; <br>   StringLen = strlen (TempBuff) ; <br>   TSPRINTF (UnicodeBuff, szObjectFormat, pObjectGroup-&gt;lpszObjectName) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, LineEndStr) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br>    <br> <br>   TimeToWrite = 0 ; <br> <br>   // export column group <br>   if (pObjectGroup-&gt;pColumnGroupFirst) <br>      { <br>      strcpy (TempBuff, pDelimiter) ; <br>      strcat (TempBuff, pDelimiter) ; <br>      StringLen = strlen (TempBuff) ; <br> <br>      bNeedToExport = FALSE ; <br> <br>      // export Parent Names <br>      for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>           pColumnGroup ; <br>           pColumnGroup = pColumnGroup-&gt;pColumnGroupNext) <br>         {  // for <br> <br>         if (pColumnGroup-&gt;lpszParentName) <br>            { <br>            ParentNum++ ; <br>            bNeedToExport = TRUE ; <br>            ConvertUnicodeStr (&amp;TempBuff[StringLen], <br>                               pColumnGroup-&gt;lpszParentName) ; <br>            StringLen = strlen (TempBuff) ; <br>            } <br>                         <br>         strcat (&amp;TempBuff[StringLen], pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br> <br>         // check if we need to export this line before it is filled up <br>         TimeToWrite++ ; <br>         if (TimeToWrite &gt; WRITE_FILE_TIME) <br>            { <br>            if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>               { <br>               goto Exit0 ; <br>               } <br>            TimeToWrite = 0 ; <br>            StringLen = 0 ; <br>            TempBuff[0] = TEXT('\0') ; <br>            } <br>         } <br> <br>      // write the line delimiter <br>      strcpy (&amp;TempBuff[StringLen], LineEndStr) ; <br>      if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>         { <br>         goto Exit0 ; <br>         } <br>           <br>      if (!bNeedToExport) <br>         { <br>         ParentNum = 0 ; <br>         } <br> <br> <br>      // setup to export Instances <br>      strcpy (TempBuff, pDelimiter) ; <br>      strcat (TempBuff, pDelimiter) ; <br>      StringLen = strlen (TempBuff) ; <br>      bNeedToExport = FALSE ; <br>      TimeToWrite = 0 ; <br> <br>      // export Instance Names <br>      for (pColumnGroup = pObjectGroup-&gt;pColumnGroupFirst ; <br>           pColumnGroup ; <br>           pColumnGroup = pColumnGroup-&gt;pColumnGroupNext) <br>         {  // for <br> <br>         if (pColumnGroup-&gt;lpszInstanceName) <br>            { <br>            InstanceNum++ ; <br>            bNeedToExport = TRUE ; <br>            ConvertUnicodeStr (&amp;TempBuff[StringLen], <br>                               pColumnGroup-&gt;lpszInstanceName) ; <br>            StringLen = strlen (TempBuff) ; <br>            } <br>                <br>         strcat (&amp;TempBuff[StringLen], pDelimiter) ; <br>         StringLen = strlen (TempBuff) ; <br> <br>         // check if we need to export this line before it is filled up <br>         TimeToWrite++ ; <br>         if (TimeToWrite &gt; WRITE_FILE_TIME) <br>            { <br>            if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>               { <br>               goto Exit0 ; <br>               } <br>            TimeToWrite = 0 ; <br>            StringLen = 0 ; <br>            TempBuff[0] = TEXT('\0') ; <br>            } <br>         } <br> <br>      // write the line delimiter <br>      strcpy (&amp;TempBuff[StringLen], LineEndStr) ; <br>      if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>         { <br>         goto Exit0 ; <br>         } <br> <br>      if (!bNeedToExport) <br>         { <br>         InstanceNum = 0 ; <br>         } <br>      } <br> <br>   if (pColNum) <br>      { <br>      *pColNum = max (ParentNum, InstanceNum) ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportObjectName <br> <br>BOOL ExportLineName (HANDLE hFile, PLINE pLine, int *pExportCounterName) <br>{ <br>   FLOAT          eValue ; <br>   int            StringLen ; <br>   BOOL           bWriteSuccess = TRUE ; <br> <br>   CHAR           TempBuff [LongTextLen * 2] ; <br> <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br> <br> <br>   strcpy (TempBuff, pDelimiter) ; <br>    <br>   if (*pExportCounterName) <br>      { <br>      StringLen = strlen (TempBuff) ; <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], pLine-&gt;lnCounterName) ; <br>      strcat (TempBuff, pDelimiter) ; <br>      *pExportCounterName = FALSE ; <br>      } <br>   StringLen = strlen (TempBuff) ; <br> <br>   if (pLine-&gt;bFirstTime == 0) <br>      { <br>      eValue = CounterEntry (pLine) ; <br> <br>      if (pLine-&gt;lnCounterType == PERF_COUNTER_RAWCOUNT_HEX || <br>          pLine-&gt;lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) <br>         { <br>         DWORD LowValue  ; <br>         DWORD HighValue ; <br> <br>         LowValue  = (DWORD) (pLine-&gt;lnaCounterValue[0]) ; <br>         HighValue = (DWORD) (pLine-&gt;lnaCounterValue[0] &gt;&gt; 32); <br> <br>         if (pLine-&gt;lnCounterType == PERF_COUNTER_RAWCOUNT_HEX || <br>             HighValue == 0) <br>            { <br>            TSPRINTF (UnicodeBuff, <br>                      szHexFormat, <br>                      LowValue) ; <br>            } <br>         else <br>            { <br>            TSPRINTF (UnicodeBuff, <br>                      szLargeHexFormat, <br>                      HighValue, <br>                      LowValue) ; <br>            } <br>         } <br>      else <br>         { <br>         TSPRINTF (UnicodeBuff, <br>                   (eValue &gt; eStatusLargeValueMax) ? <br>                       szLargeValueFormat : szValueFormat, <br>                   eValue) ; <br>         ConvertDecimalPoint (UnicodeBuff) ; <br>         } <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>      } <br>   else <br>      { <br>      // export "----" for unstable values <br>      strcat (&amp;TempBuff[StringLen], "----"); <br>      } <br> <br>   // write the line value <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   return (TRUE) ; <br> <br> <br>Exit0: <br>   return (FALSE) ; <br>}  // ExportLineName <br> <br> <br>// This routine is need to insert the line values into its <br>// column location.  It is needed because not all the instances (columns) <br>// are available for the same line. <br>void SaveColumnLineData (PLINE pLine, LPSTR pColumnLineData) <br>{ <br>   FLOAT          eValue ; <br>   LPSTR          pColumnLine ; <br> <br>   CHAR           TempBuff [LongTextLen * 2] ; <br> <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br> <br>   if (!pColumnLineData || pLine-&gt;iReportColumn &lt; 0) <br>      { <br>      return ; <br>      } <br> <br>   // find the offset into the pColumnLineData buffer for current line <br>   pColumnLine = pColumnLineData + pLine-&gt;iReportColumn * ShortTextLen ; <br> <br>   if (pLine-&gt;bFirstTime == 0) <br>      { <br> <br>      eValue = CounterEntry (pLine) ; <br> <br> <br>      if (pLine-&gt;lnCounterType == PERF_COUNTER_RAWCOUNT_HEX || <br>          pLine-&gt;lnCounterType == PERF_COUNTER_LARGE_RAWCOUNT_HEX) <br>         { <br>         DWORD LowValue  ; <br>         DWORD HighValue ; <br> <br>         LowValue  = (DWORD) (pLine-&gt;lnaCounterValue[0]) ; <br>         HighValue = (DWORD) (pLine-&gt;lnaCounterValue[0] &gt;&gt; 32); <br> <br>         if (pLine-&gt;lnCounterType == PERF_COUNTER_RAWCOUNT_HEX || <br>             HighValue == 0) <br>            { <br>            TSPRINTF (UnicodeBuff, <br>                      szHexFormat, <br>                      LowValue) ; <br>            } <br>         else <br>            { <br>            TSPRINTF (UnicodeBuff, <br>                      szLargeHexFormat, <br>                      HighValue, <br>                      LowValue) ; <br>            } <br>         } <br>      else <br>         { <br>         TSPRINTF (UnicodeBuff, <br>                   (eValue &gt; eStatusLargeValueMax) ? <br>                       szLargeValueFormat : szValueFormat, <br>                   eValue) ; <br>         ConvertDecimalPoint (UnicodeBuff) ; <br>         } <br>      ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>      strncpy (pColumnLine, TempBuff, ShortTextLen) ; <br>      *(pColumnLine + ShortTextLen - 1) = '\0' ; <br>      } <br>   else <br>      { <br>      // export "----" for unstable values <br>      strcpy (pColumnLine, "----"); <br>      } <br>}  // SaveColumnLineData <br> <br>BOOL ExportColumnLineData (HANDLE hFile, <br>                           int ColumnTotal, <br>                           PCOUNTERGROUP pCounterGroup, <br>                           LPSTR pColumnLineData) <br>{ <br>   int            iIndex ; <br>   int            StringLen ; <br>   CHAR           TempBuff [LongTextLen] ; <br>   LPSTR          pCurrentLineData ; <br> <br>   // export the counter name <br>   strcpy (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], pCounterGroup-&gt;pLineFirst-&gt;lnCounterName) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // go thru each column and export the line value if it has been stored    <br>   for (iIndex = 0, pCurrentLineData = pColumnLineData ; <br>      iIndex &lt; ColumnTotal ; <br>      iIndex++, pCurrentLineData += ShortTextLen ) <br>      { <br>      if (*pCurrentLineData != 0) <br>         { <br>         // data available for this column <br>         if (!FileWrite (hFile, pCurrentLineData, strlen(pCurrentLineData))) <br>            { <br>            goto Exit0 ; <br>            } <br>         } <br> <br>      if (!FileWrite (hFile, pDelimiter, strlen(pDelimiter))) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   if (!FileWrite (hFile, LineEndStr, strlen(LineEndStr))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   return (TRUE) ; <br> <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportColumnLineData <br> <br>void ExportReport (void) <br>{ <br>   HANDLE         hFile = 0 ; <br>   PREPORT        pReport ; <br>   PSYSTEMGROUP   pSystemGroup ; <br>   POBJECTGROUP   pObjectGroup ; <br>   PCOUNTERGROUP  pCounterGroup ; <br>   PLINE          pLine ; <br>   BOOL           bExportComputer ; <br>   BOOL           bExportObject ; <br>   BOOL           bExportCounterName ; <br>   int            ColumnTotal = 0 ; <br>   LPSTR          pColumnLineData = NULL ; <br>   LPTSTR         pFileName = NULL ; <br>   INT            ErrCode = 0 ; <br> <br>   if (!(pReport = ReportData (hWndReport))) <br>      { <br>      return ; <br>      } <br> <br>   // see if there is anything to export.. <br>   if (!(pReport-&gt;pSystemGroupFirst)) <br>      { <br>      return ; <br>      } <br> <br>   SetHourglassCursor() ; <br>    <br>   if (ErrCode = ExportFileOpen (hWndReport, &amp;hFile, <br>       pReport-&gt;iIntervalMSecs, &amp;pFileName)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   if (!pFileName) <br>      { <br>      // the case when user cancel <br>      goto Exit0 ; <br>      } <br> <br>   // export each system group <br> <br>   for (pSystemGroup = pReport-&gt;pSystemGroupFirst ; <br>        pSystemGroup ; <br>        pSystemGroup = pSystemGroup-&gt;pSystemGroupNext) <br>      {  // for System... <br> <br>      bExportComputer = TRUE ; <br> <br>      for (pObjectGroup = pSystemGroup-&gt;pObjectGroupFirst ; </code></pre>
<p>
</p>
<pre><code>pObjectGroup ; <br>           pObjectGroup = pObjectGroup-&gt;pObjectGroupNext) <br>         {  // for Object... <br> <br>         bExportObject = TRUE ; <br> <br>         for (pCounterGroup = pObjectGroup-&gt;pCounterGroupFirst ; <br>              pCounterGroup ; <br>              pCounterGroup = pCounterGroup-&gt;pCounterGroupNext) <br>            {  // for Counter... <br> <br>            bExportCounterName = TRUE ; <br> <br>            // Column data buffer has been allocated for this object type,  <br>            // zero out the buffer and prepare for next round. <br>          <br>            if (pColumnLineData) <br>               { <br>               memset (pColumnLineData, 0, ColumnTotal * ShortTextLen) ; <br>               } <br> <br>            for (pLine = pCounterGroup-&gt;pLineFirst ; <br>                 pLine ; <br>                 pLine = pLine-&gt;pLineCounterNext) <br>               {  // for Line... <br> <br>               if (bExportComputer) <br>                  { <br>                  // only need to do this for the first object <br>                  bExportComputer = FALSE ; <br>                  if (!ExportComputerName (hFile, pSystemGroup)) <br>                     { <br>                     ErrCode = ERR_EXPORT_FILE ; <br>                     goto Exit0 ; <br>                     } <br>                  } <br> <br>               if (bExportObject) <br>                  { <br>                  // only need to do this for the first counter group <br>                  bExportObject = FALSE ; <br>                  if (!ExportObjectName (hFile, pObjectGroup, &amp;ColumnTotal)) <br>                     { <br>                     ErrCode = ERR_EXPORT_FILE ; <br>                     goto Exit0 ; <br>                     } <br> <br>                  if (ColumnTotal &gt; 1) <br>                     { <br>                     // special case to setup a column array and export <br>                     // the line values later <br>                     pColumnLineData = MemoryAllocate (ColumnTotal * ShortTextLen) ; <br>                     if (!pColumnLineData) <br>                        { <br>                        ErrCode = ERR_EXPORT_FILE ; <br>                        goto Exit0 ; <br>                        } <br>                     } <br>                  } <br> <br>               if (ColumnTotal &gt; 1) <br>                  { <br>                  // save the line value into its column &amp; export later <br>                  SaveColumnLineData (pLine, pColumnLineData) ; <br>                  } <br>               else <br>                  { <br>                  // simple case, export the line now <br>                  if (!ExportLineName (hFile, pLine, &amp;bExportCounterName)) <br>                     { <br>                     ErrCode = ERR_EXPORT_FILE ; <br>                     goto Exit0 ; <br>                     } <br>                  } <br>               }  // for Line... <br> <br>            if (!bExportCounterName) <br>               { <br>               // export the line end <br>               if (!FileWrite (hFile, LineEndStr, strlen(LineEndStr))) <br>                  { <br>                  ErrCode = ERR_EXPORT_FILE ; <br>                  goto Exit0 ; <br>                  } <br>               } <br> <br>            if (pColumnLineData) <br>               { <br>               // now, do the actual export <br>               if (!ExportColumnLineData (hFile, <br>                  ColumnTotal, <br>                  pCounterGroup, <br>                  pColumnLineData)) <br>                  { <br>                  ErrCode = ERR_EXPORT_FILE ; <br>                  goto Exit0 ; <br>                  } <br>               } <br>            }  // for Counter... <br> <br>         // done with the object, done with the buffer <br>         if (pColumnLineData) <br>            { <br>            MemoryFree (pColumnLineData) ; <br>            ColumnTotal = 0 ; <br>            pColumnLineData = NULL ; <br>            } <br>         }  // for Object <br> <br> <br>      }  // for System... <br> <br>Exit0: <br> <br>   SetArrowCursor() ; <br> <br>   if (pColumnLineData) <br>      { <br>      MemoryFree (pColumnLineData) ; <br>      } <br> <br>   if (hFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   if (pFileName) <br>      { <br>      if (ErrCode) <br>         { <br>         DlgErrorBox (hWndGraph, ErrCode, pFileName) ; <br>         } <br> <br>      MemoryFree (pFileName) ; <br>      } <br> <br>}  // ExportReport <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
