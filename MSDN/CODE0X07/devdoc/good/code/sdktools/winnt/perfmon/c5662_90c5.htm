<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOGOPTNS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5675"></a>LOGOPTNS.C</h2>
<pre><code><br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include "perfmon.h"       // basic defns, windows.h <br>#include "logoptns.h"      // external declarations for this file <br> <br>#include "dlgs.h"          // common dialog control IDs <br>#include "log.h"           // for StartLog, SetLogTimer, CloseLog <br>#include "fileutil.h"      // file utilities <br>#include "utils.h"         // various utilities <br>#include "playback.h"      // for PlayingBackLog <br>#include "pmhelpid.h"      // Help IDs <br> <br> <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br>DWORD          iIntervalMSecs ; <br>BOOL           bNeedToRelogData ; <br>BOOL           bNeedToStartLog ; <br>BOOL           bNeedToSetTimer ; <br> <br>extern BOOL    LocalManualRefresh ; <br>static BOOL    bStopButtonClicked ; <br>extern HWND    hWndLogEntries ; <br> <br>// This is a counter that is init. to 0.  It is incremened by 1 <br>// when the user click the cancel button. <br>// It is set to -1 when we sent the cancell msg internally. <br>int            bCancelled ; <br>TCHAR          szmsgFILEOK[] = FILEOKSTRING ; <br>DWORD          msgFILEOK ; <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define LogOptionsOFNStyle                      \ <br>   (OFN_ENABLETEMPLATE | OFN_HIDEREADONLY |     \ <br>    OFN_SHOWHELP | OFN_ENABLEHOOK) <br> <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br>void EnableFileControls (HDLG hDlg, BOOL bEnable) <br>   { <br>   DialogEnable (hDlg, stc3, bEnable) ; <br>   DialogEnable (hDlg, lst1, bEnable) ; <br>   DialogEnable (hDlg, stc1, bEnable) ; <br>   DialogEnable (hDlg, lst2, bEnable) ; <br>   DialogEnable (hDlg, stc2, bEnable) ; <br>   DialogEnable (hDlg, cmb1, bEnable) ; <br>   DialogEnable (hDlg, stc4, bEnable) ; <br>   DialogEnable (hDlg, cmb2, bEnable) ; <br>   DialogEnable (hDlg, edt1, bEnable) ; <br>   } <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void static OnInitDialog (HDLG hDlg) <br>   { <br>   PLOG           pLog ; <br>   int            i ; <br>   BOOL           DisplayManualRefresh ; <br>   pLog = LogData (hWndLog) ; <br> <br>   if (msgFILEOK == 0) <br>      { <br>      msgFILEOK = RegisterWindowMessage(szmsgFILEOK); <br>      } <br> <br>   bCancelled = 0 ; <br> <br>   switch (pLog-&gt;iStatus) <br>      {  // switch <br>      case iPMStatusClosed: <br>//         DialogEnable (hDlg, IDD_LOGOPTPAUSE, FALSE) ; <br>         break ; <br> <br>      case iPMStatusPaused: <br>         EnableFileControls (hDlg, FALSE) ; <br>         DialogSetText (hDlg, IDD_LOGOPTSTART, IDS_STOP) ; <br>//         DialogSetText (hDlg, IDD_LOGOPTPAUSE, IDS_RESUME) ; <br>         break ; <br> <br>      case iPMStatusCollecting: <br>         EnableFileControls (hDlg, FALSE) ; <br>         DialogSetText (hDlg, IDD_LOGOPTSTART, IDS_STOP) ; <br>         break ; <br>      }  // switch <br> <br>   for (i = 0 ; <br>        i &lt; NumIntervals ; <br>        i++) <br>      CBAddInt (DialogControl (hDlg, IDD_LOGOPTINTERVAL), aiIntervals [i]) ; <br>   DialogSetInterval (hDlg, IDD_LOGOPTINTERVAL, pLog-&gt;iIntervalMSecs) ; <br>   iIntervalMSecs = pLog-&gt;iIntervalMSecs ; <br> <br>   LocalManualRefresh = pLog-&gt;bManualRefresh ; <br>   DisplayManualRefresh = TRUE ; <br> <br>   if (PlayingBackLog ()) <br>      { <br>      DialogSetText (hDlg, IDD_LOGOPTSTART, IDS_CREATELOGFILE) ; <br>      DisplayManualRefresh = FALSE ; <br>      } <br>    <br>   if (LBNumItems (hWndLogEntries) == 0) <br>      { <br>      DialogEnable (hDlg, IDD_LOGOPTSTART, FALSE) ; <br>//      DialogEnable (hDlg, IDD_LOGOPTPAUSE, FALSE) ; <br>      } <br> <br>   if (DisplayManualRefresh) <br>      { <br>      if (LocalManualRefresh) <br>         { <br>         DialogEnable (hDlg, IDD_LOGOPTINTERVAL, FALSE) ; <br>         DialogEnable (hDlg, IDD_LOGOPTINTERVALTEXT, FALSE) ; <br>         } <br> <br>      CheckRadioButton (hDlg, <br>         IDD_LOGOPTIONSMANUALREFRESH, <br>         IDD_LOGOPTIONSPERIODIC, <br>         LocalManualRefresh ? IDD_LOGOPTIONSMANUALREFRESH :  <br>         IDD_LOGOPTIONSPERIODIC) ; <br>      } <br>   else <br>      { <br>      DialogEnable (hDlg, IDD_LOGOPTIONSMANUALREFRESH, FALSE) ; <br>      CheckRadioButton (hDlg, <br>         IDD_LOGOPTIONSMANUALREFRESH, <br>         IDD_LOGOPTIONSPERIODIC, <br>         IDD_LOGOPTIONSPERIODIC) ; <br>      } <br>    <br> <br>   dwCurrentDlgID = HC_PM_idDlgOptionLog ; <br>    <br>   WindowCenter (hDlg) ; <br>   }  // OnInitDialog <br> <br> <br>void OnStart (HDLG hDlg) <br>/* <br>   Effect:        Handle any actions necessary when the user clicks on <br>                  the "Start/Stop" button. <br> <br>   Note:          This button could be displaying start or stop, depending <br>                  on the situation. <br>*/      <br>   { <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hDlg) ; <br>   <br>   bStopButtonClicked = FALSE ; <br>   switch (pLog-&gt;iStatus) <br>      {  // switch <br>      case iPMStatusClosed: <br>         if (PlayingBackLog ()) <br>            { <br>            bNeedToRelogData = TRUE ; <br>            } <br>         else <br>            { <br>            FLOAT eTimeInterval ; <br> <br>            eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ; <br>            if (eTimeInterval &gt; MAX_INTERVALSEC || <br>                eTimeInterval &lt; MIN_INTERVALSEC) <br>               { <br>               DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ; <br>               SetFocus (DialogControl (hDlg, IDD_LOGOPTINTERVAL)) ; <br>               EditSetTextEndPos (hDlg, IDD_LOGOPTINTERVAL) ; <br>               return ; <br>               break ; <br>               } <br> <br>            eTimeInterval = eTimeInterval * (FLOAT) 1000.0 + (FLOAT) 0.5 ; <br>            pLog-&gt;iIntervalMSecs = (DWORD) eTimeInterval ; <br> <br>            iIntervalMSecs = pLog-&gt;iIntervalMSecs ; <br>            bNeedToStartLog = TRUE ; <br>            } <br>         break ; <br> <br>      case iPMStatusCollecting: <br>      case iPMStatusPaused: <br>         CloseLog (hWndLog, pLog) ; <br>         bStopButtonClicked = TRUE ; <br>         break ; <br>      }  // switch <br> <br> <br>   SimulateButtonPush (hDlg, IDD_OK) ; <br>   } <br> <br> <br>BOOL static OnOK (HDLG hDlg) <br>/* <br>   Effect:        Perform any hooked actions needed when the user selects <br>                  OK in the log options dialog. In particular, if we are <br>                  currently logging, record the need to relog and CANCEL  <br>                  the dialog, never letting the real dialog proc get the <br>                  OK. Remember, this is actually a file open dialog that <br>                  we have perverted. If we let the OK through, the common <br>                  dialog manager will try to open it and it will inform <br>                  the user that the file is locked. This way, we let the <br>                  user click OK, but the dialog thinks we cancelled. <br> <br>   Called By:     LogOptionsHookProc only. <br> <br>   Returns:       Whether the message was handled by this function or not. <br>*/ <br>   {  // OnOK <br>   PLOG           pLog ; <br> <br> <br>   pLog = LogData (hWndLog) ; <br>   if (pLog-&gt;iStatus == iPMStatusCollecting ||   <br>       pLog-&gt;iStatus == iPMStatusPaused) <br>      { <br>      if (LocalManualRefresh != pLog-&gt;bManualRefresh) <br>         { <br>         if (!LocalManualRefresh) <br>            { <br>            FLOAT eTimeInterval ; <br> <br>            eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ; <br> <br>            if (eTimeInterval &gt; MAX_INTERVALSEC || <br>                eTimeInterval &lt; MIN_INTERVALSEC) <br>               { <br>               DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ; <br>               SetFocus (DialogControl (hDlg, IDD_LOGOPTINTERVAL)) ; <br>               EditSetTextEndPos (hDlg, IDD_LOGOPTINTERVAL) ; <br>               return (FALSE) ; <br>               } <br> <br>            eTimeInterval = eTimeInterval * (FLOAT) 1000.0 + (FLOAT) 0.5 ; <br>            pLog-&gt;iIntervalMSecs = (DWORD) eTimeInterval ; <br>            iIntervalMSecs = pLog-&gt;iIntervalMSecs ; <br>            UpdateLogDisplay (hWndLog) ; <br>            } <br>         ToggleLogRefresh (hWndLog) ; <br>         } <br>      else <br>         { <br>         bNeedToSetTimer = TRUE ; <br>         bCancelled = -1 ; <br>         } <br>      SimulateButtonPush (hDlg, IDD_CANCEL) ; <br>      return TRUE ; <br>      } <br>   else <br>      { <br>      if (!LocalManualRefresh) <br>         { <br>         FLOAT eTimeInterval ; <br> <br>         eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ; <br> <br>         if (eTimeInterval &gt; MAX_INTERVALSEC || <br>             eTimeInterval &lt; MIN_INTERVALSEC) <br>            { <br>            DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ; <br>            SetFocus (DialogControl (hDlg, IDD_LOGOPTINTERVAL)) ; <br>            EditSetTextEndPos (hDlg, IDD_LOGOPTINTERVAL) ; <br>            return (TRUE) ; <br>            } <br>         } <br>      } <br>      return FALSE ; <br>   }  // OnOK <br> <br> <br>          <br>void OnPause (HDLG hDlg) <br>   { <br>   } <br> <br> <br> <br>BOOL APIENTRY LogOptionsHookProc (HWND hDlg,  <br>                                  UINT iMessage,  <br>                                  WPARAM wParam,  <br>                                  LPARAM lParam) <br>   { <br>   BOOL           bHandled ; <br> <br>   bHandled = TRUE ; <br> <br>   if (iMessage == msgFILEOK) <br>      { <br>      bHandled = OnOK (hDlg) ; <br>      return (bHandled) ; <br>      } <br> <br>   switch (iMessage) <br>      { <br>      case WM_INITDIALOG: <br>         OnInitDialog (hDlg) ; <br>         break ; <br> <br>      case WM_DESTROY: <br> <br>         { <br>         FLOAT eTimeInterval ; <br> <br>         if (!bCancelled) <br>            { <br>            eTimeInterval = DialogFloat (hDlg, IDD_LOGOPTINTERVAL, NULL) ; <br>            if (eTimeInterval &gt; MAX_INTERVALSEC || <br>                eTimeInterval &lt; MIN_INTERVALSEC) <br>               { <br>               DlgErrorBox (hDlg, ERR_BADTIMEINTERVAL) ; <br>               } <br>            else <br>               { <br>               eTimeInterval = eTimeInterval * (FLOAT) 1000.0 + (FLOAT) 0.5 ; <br>               iIntervalMSecs = (DWORD) eTimeInterval ; <br>               } <br>            } <br> <br>         dwCurrentDlgID = 0 ; <br>         bHandled = FALSE ; <br>         } <br>         break ; <br> <br>      case WM_COMMAND: <br>         switch (wParam) <br>            {  // switch <br>            case IDD_LOGOPTSTART: <br>               OnStart (hDlg) ; <br>               break ; <br> <br>            case IDD_LOGOPTPAUSE: <br>               OnPause (hDlg) ; <br>               break ; <br> <br>            case IDD_OK: <br>               bHandled = OnOK (hDlg) ; <br>               break ; <br> <br>            case IDD_CANCEL: <br>               bCancelled += 1 ; <br>               bHandled = FALSE ; <br>               break ; <br> <br>            case IDD_LOGOPTIONSPERIODIC: <br>               if (PlayingBackLog()) <br>                  { <br>                  break ; <br>                  } <br>               // else fall thru to the following case... <br>            case IDD_LOGOPTIONSMANUALREFRESH: <br>               // check if the Manual refresh is currently checked. <br>               // Then toggle the ManualRefresh button <br>               LocalManualRefresh = <br>                  (wParam == IDD_LOGOPTIONSMANUALREFRESH) ; <br> <br>               CheckRadioButton (hDlg, <br>                  IDD_LOGOPTIONSMANUALREFRESH, <br>                  IDD_LOGOPTIONSPERIODIC, <br>                  LocalManualRefresh ? IDD_LOGOPTIONSMANUALREFRESH : <br>                  IDD_LOGOPTIONSPERIODIC) ; <br> <br>               DialogEnable (hDlg, IDD_LOGOPTINTERVAL, !LocalManualRefresh) ; <br>               DialogEnable (hDlg, IDD_LOGOPTINTERVALTEXT, !LocalManualRefresh) ; <br>               break ; <br> <br>            case ID_HELP: <br>               CallWinHelp (dwCurrentDlgID) ; <br>               break ; <br> <br>            default: <br>               bHandled = FALSE ; <br>               break ; <br>            }  // switch <br>         break; <br> <br>      default: <br>         bHandled = FALSE ; <br>         break;             <br>      }  // switch <br> <br>   return (bHandled) ; <br>   }  // LogOptionsHookProc <br> <br> <br>BOOL DisplayLogOptions (HWND hWndParent, <br>                        HWND hWndLog) <br> <br>   {  // DisplayLogOptions <br>   TCHAR          szFilePath [FilePathLen + 1] ; <br>   TCHAR          szFileTitle [FilePathLen + 1] ; <br>   TCHAR          szFileDirectory [FilePathLen + 1] ; <br>   TCHAR          szCaption [WindowCaptionLen + 1] ; <br>   OPENFILENAME   ofn ; <br>   PLOG           pLog ; <br>   int            RetCode ; <br>   int            PrevLogSize ; <br>   BOOL           bSameFile ; <br> <br>   TCHAR szFilter[LongTextLen] ; <br>   int   StringLength ; <br> <br>   StringLoad (IDS_SAVELOGFILE, szFilter) ; <br>   StringLength = lstrlen (szFilter) + 1 ; <br>   LoadString (hInstance, IDS_SAVELOGFILEEXT, <br>      &amp;szFilter[StringLength], sizeof(szFilter)-StringLength) ; <br>   StringLength += lstrlen (&amp;szFilter[StringLength]) ; <br>   szFilter[StringLength+1] = szFilter[StringLength+2] = TEXT('\0') ; <br> <br>   // This dialog is used to change attributes for an existing log file, <br>   // and to select the name of a log file to open. Therefore we have  <br>   // different options in these cases. <br> <br>   pLog = LogData (hWndLog) ; <br>   if (!strempty (pLog-&gt;szFilePath)) <br>      { <br>      FileNameExtension (pLog-&gt;szFilePath, szFileTitle) ; <br>      FileDriveDirectory (pLog-&gt;szFilePath, szFileDirectory) ; <br>      lstrcpy (szFilePath, szFileTitle) ; <br>      } <br>   else <br>      { <br>      szFileTitle[0] = szFileDirectory[0] = TEXT('\0') ; <br>      StringLoad (IDS_SAVELOGFILEEXT, szFilePath) ; <br>      } <br> <br>   StringLoad (IDS_LOGOPTIONS, szCaption) ; <br> <br>   ofn.lStructSize = sizeof(OPENFILENAME) ;  <br>   ofn.hwndOwner = hWndParent ; <br>   ofn.hInstance = hInstance ; <br>   ofn.lpstrFilter = szFilter; <br>   ofn.lpstrCustomFilter = (LPTSTR) NULL; <br>   ofn.nMaxCustFilter = 0L; <br>   ofn.nFilterIndex = 1L; <br>   ofn.lpstrFile = szFilePath ; <br>   ofn.nMaxFile = FilePathLen ; <br>   ofn.lpstrFileTitle = szFileTitle ; <br>   ofn.nMaxFileTitle = FilePathLen ; <br>   ofn.lpstrInitialDir = szFileDirectory ; <br>   ofn.lpstrTitle = (LPTSTR) szCaption ; <br>   ofn.Flags = LogOptionsOFNStyle  ; <br>   ofn.nFileOffset = 0; <br>   ofn.nFileExtension = 0; <br>   ofn.lpstrDefExt = (LPTSTR) NULL; <br>   ofn.lpfnHook = (LPOFNHOOKPROC) LogOptionsHookProc ; <br>   ofn.lpTemplateName = idDlgLogOptions ; <br> <br>   bNeedToRelogData = FALSE; <br>   bNeedToStartLog = FALSE ; <br>   bNeedToSetTimer = FALSE ; <br>   bStopButtonClicked = FALSE ; <br> <br>   if (GetSaveFileName(&amp;ofn) &amp;&amp; !bStopButtonClicked) <br>      { <br>      pLog = LogData (hWndLog) ; <br> <br>      // save previous log file name &amp; size <br>      // so we can reset if error  <br>      PrevLogSize = pLog-&gt;lFileSize ; <br>       <br>      lstrcpy (szFileTitle, pLog-&gt;szFilePath) ; <br> <br>      bSameFile = pstrsamei (pLog-&gt;szFilePath, ofn.lpstrFile) ; <br> <br>      if (!bSameFile) <br>         { <br>         lstrcpy (pLog-&gt;szFilePath, ofn.lpstrFile) ; <br>         } <br> <br>      pLog-&gt;iIntervalMSecs = iIntervalMSecs ; <br>       <br>      if (bNeedToStartLog) <br>         { <br>         pLog-&gt;bManualRefresh = LocalManualRefresh ; <br>         StartLog (hWndLog, pLog, bSameFile) ; <br>         } <br>      else if (bNeedToRelogData) <br>         { <br>         bNeedToRelogData = FALSE ; <br>         SetHourglassCursor() ; <br>         ReLog (hWndLog, bSameFile) ; <br>         SetArrowCursor() ; <br>         } <br>      else if (LocalManualRefresh != pLog-&gt;bManualRefresh) <br>         { <br>         ToggleLogRefresh (hWndLog) ; <br>         } <br> <br>      if (!pLog-&gt;hFile) <br>         { <br>         if (bNeedToStartLog) <br>            { <br>            // if we get here, that means StartLog has detected <br>            // problem, just restore the old stuff.. <br>            pLog-&gt;lFileSize = PrevLogSize ; <br>            lstrcpy (pLog-&gt;szFilePath, szFileTitle) ; <br>            } <br>         // verify if this is a good log file and setup the file size <br>         else if ((RetCode = CreateLogFile (pLog, FALSE, bSameFile)) != 0) <br>            { <br>            DlgErrorBox (hWndLog, RetCode, pLog-&gt;szFilePath); <br>            pLog-&gt;lFileSize = PrevLogSize ; <br>            lstrcpy (pLog-&gt;szFilePath, szFileTitle) ; <br>            } <br>         else <br>            { <br>            // unfortunately, we have to close this file. <br>            // Otherwise, when we do StartLog, the common dialog <br>            // will complain that this file is already in-used. <br>            CloseHandle (pLog-&gt;hFile) ; <br>            } <br>         pLog-&gt;hFile = 0 ; <br>         } <br> <br>//      UpdateLogDisplay (hWndLog) ; <br>      } <br> <br> <br>   // Remember, we faked out GetSaveFileName to return FALSE. See OnOK doc. <br>   if (bNeedToSetTimer) <br>      { <br>      SetLogTimer (hWndLog, iIntervalMSecs) ; <br>//      UpdateLogDisplay (hWndLog) ; <br>      } <br> <br>   UpdateLogDisplay (hWndLog) ; <br> <br>   return (TRUE) ; <br>   }  // DisplayLogOptions <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
