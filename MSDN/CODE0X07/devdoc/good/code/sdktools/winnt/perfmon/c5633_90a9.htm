<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GRAFDISP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5661"></a>GRAFDISP.C</h2>
<pre><code>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include &lt;stdio.h&gt; <br>#include "perfmon.h" <br>#include "grafdisp.h"      // external declarations for this file <br> <br>#include "grafdata.h"      // for InsertGraph, et al. <br>#include "graph.h" <br>#include "legend.h" <br>#include "line.h"          // for LineCreatePen <br>#include "perfmops.h"      // for DoWindowDrag <br>#include "playback.h"      // for PlayingBackLog <br>#include "valuebar.h" <br>#include "utils.h" <br>#include "timeline.h"      // for IsTLineWindowUp &amp; TLineRedraw  <br>#include "counters.h"      // for CounterEntry <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br>// this macro is used in doing a simple DDA (Digital Differential Analyzer) <br>// * 10 + 5 is to make the result round up with .5 <br>#define DDA_DISTRIBUTE(TotalTics, numOfData) \ <br>   ((TotalTics * 10 / numOfData) + 5) / 10 <br> <br>HDC   hGraphDisplayDC ; <br>//=============================// <br>// GraphDisplay Class          // <br>//=============================// <br> <br> <br>TCHAR   szGraphDisplayWindowClass[] = TEXT("PerfChart") ; <br>#define dwGraphDisplayClassStyle    (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS | CS_OWNDC) <br>#define iGraphDisplayClassExtra     (0) <br>#define iGraphDisplayWindowExtra    (0) <br>#define dwGraphDisplayWindowStyle   (WS_CHILD | WS_VISIBLE) <br> <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br>BOOL UpdateTimeLine (HDC hDC, PGRAPHSTRUCT pGraph, BOOL getLastTimeLocation) ; <br> <br>#if 0 <br>PGRAPHSTRUCT GraphData (HWND hWndGraphDisplay) <br>/* <br>   Effect:        Return the graph associated with graph display window <br>                  hWndGraphData. At the present time, we only have one <br>                  graph data window and one graph structure. In the <br>                  future, we may have several of each. The graph structure <br>                  is conceptually instance data of the graph display <br>                  window. Use of this function allows for easier additions <br>                  to the code. <br>*/ <br>   { <br>   return (pGraphs) ; <br>   } <br>#endif <br> <br>INT ScaleAndInvertY (FLOAT ey,  <br>                     PLINESTRUCT pLineStruct, <br>                     PGRAPHSTRUCT pGraph) <br>/* <br>   Effect:        Given data value ey, scale and fit the value to fit <br>                  within the graph data area of the window, considering <br>                  the scale set for the line and the current size of the <br>                  data rectangle. <br>*/    <br>   {  // ScaleAndInvertY <br>   INT     yGraphDataHeight,               // Height of graph area <br>           yInverted ;                     // Scaled &amp; Inverted Y. <br>   FLOAT   eppd, <br>           eyScaled ; <br> <br> <br>   // Take care of any scaling now, at output time. <br>   ey *= pLineStruct-&gt;eScale ; <br> <br>   // Calculate the Cy of the graph area. <br>   yGraphDataHeight = pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top ; <br> <br>   // Calculate the pixels per data point. <br>   eppd = (FLOAT) ((FLOAT) yGraphDataHeight / (FLOAT) pGraph-&gt;gOptions.iVertMax) ; <br>   eyScaled = eppd * ey ; <br>   yInverted = (INT) (((FLOAT) yGraphDataHeight) - eyScaled) ; <br> <br>   yInverted += pGraph-&gt;rectData.top ; <br>    <br>   // Clamp the range to fit with in the graph portion of the windows <br>   yInverted = PinInclusive (yInverted,  <br>                             pGraph-&gt;rectData.top, pGraph-&gt;rectData.bottom) ; <br>   return (yInverted) ; <br>   }  // ScaleAndInvertY <br> <br> <br> <br>BOOL DrawGrid (HDC hDC,  <br>               PGRAPHSTRUCT pGraph, <br>               LPRECT lpRect, <br>               BOOL bForPaint) <br>/* <br>   Effect:        Draw the grid lines in the graph display window. <br>                  These grid lines are in the graph data area only, <br>                  which is indicated by pGraph-&gt;rectData. <br> <br>   Called By:     OnPaint only. <br>*/ <br>   {  // DrawGrid <br>   int            iGrid, iLines ; <br>   int            xGrid, yGrid ; <br>   POINT          aPoints [4 * iGraphMaxTics] ; <br>   DWORD          aCounts [2 * iGraphMaxTics] ; <br>   HPEN           hPenPrevious ; <br>   int            bottomAdjust ; <br> <br>   if (!pGraph-&gt;gOptions.bHorzGridChecked &amp;&amp;  <br>       !pGraph-&gt;gOptions.bVertGridChecked)    <br>      return (FALSE) ; <br> <br> <br>   hPenPrevious = SelectPen (hDC, IsPrinterDC (hDC) ? <br>      GetStockObject (BLACK_PEN) : pGraph-&gt;hGridPen) ; <br> <br>   iLines = 0 ; <br> <br>   if (pGraph-&gt;gOptions.bHorzGridChecked) <br>      { <br>      for (iGrid = 1 ; <br>           iGrid &lt; pGraph-&gt;yNumTics ; <br>           iGrid++) <br>         {  // for <br>         yGrid = pGraph-&gt;ayTics[iGrid] + pGraph-&gt;rectData.top ; <br>         if (yGrid &gt;= lpRect-&gt;top &amp;&amp; <br>             yGrid &lt;= lpRect-&gt;bottom) <br>            {  // if <br>            aPoints[2 * iLines].x = lpRect-&gt;left ; <br>            aPoints[2 * iLines].y = yGrid ; <br>            aPoints[2 * iLines + 1].x = lpRect-&gt;right ; <br>            aPoints[2 * iLines + 1].y = yGrid ; <br> <br>            aCounts[iLines] = 2 ; <br>            iLines++ ; <br>            }  // if <br>         }  // for <br>      }  // if <br> <br>   if (pGraph-&gt;gOptions.bVertGridChecked) <br>      { <br>      bottomAdjust = lpRect-&gt;bottom + (bForPaint ? 1 : 0) ; <br>      for (iGrid = 1 ; <br>           iGrid &lt; pGraph-&gt;xNumTics ; <br>           iGrid++) <br>         {  // for <br>         xGrid = pGraph-&gt;axTics[iGrid] + pGraph-&gt;rectData.left ; <br>         if (xGrid &gt;= lpRect-&gt;left &amp;&amp; <br>             xGrid &lt;= lpRect-&gt;right) <br>            {  // if <br>            aPoints[2 * iLines].x = xGrid ; <br>            aPoints[2 * iLines].y = lpRect-&gt;top ; <br>            aPoints[2 * iLines + 1].x = xGrid ; <br>            aPoints[2 * iLines + 1].y = bottomAdjust ; <br> <br>            aCounts[iLines] = 2 ; <br>            iLines++ ; <br>            }  // if <br>         }  // for <br>      }  // if <br> <br>   if (iLines) <br>      PolyPolyline (hDC, aPoints, aCounts, iLines) ; <br> <br>   SelectPen (hDC, hPenPrevious) ; <br> <br>   return (TRUE) ; <br>   }  // DrawGrid <br> <br> <br> <br>BOOL DrawBarChartData (HDC hDC,  <br>                       PGRAPHSTRUCT pGraph) <br>   {  // DrawBarChartData <br>   PLINESTRUCT pLineStruct ; <br>   PFLOAT      pDataPoints ; <br>   INT         nLegendItems, <br>               cx, <br>               cxBar, <br>               xDataPoint, <br>               y ; <br>   RECT        rectBar ; <br>   RECT        rectBkgrnd ; <br>   HBRUSH      hOldBrush ; <br>   FLOAT       eValue ; <br>   PLINESTRUCT pCurrentLine ; <br> <br>   // Determine how many items are in the legend. <br> <br>   nLegendItems = 0 ; <br> <br>   for (pLineStruct = pGraph-&gt;pLineFirst ; <br>        pLineStruct ; <br>        pLineStruct = pLineStruct-&gt;pLineNext) <br>      {  // for <br>      nLegendItems++ ; <br>      }  // for <br> <br>   if (nLegendItems == 0) <br>      return(FALSE) ; <br> <br>   // get current select line for highlighting <br>   if (pGraph-&gt;HighLightOnOff) <br>      { <br>      pCurrentLine = CurrentGraphLine (hWndGraph) ; <br>      } <br>   else <br>      { <br>      pCurrentLine = NULL ; <br>      } <br> <br>   // Determine the width of each bar. <br>   cx = pGraph-&gt;rectData.right - pGraph-&gt;rectData.left ; <br> <br> <br>   if (PlayingBackLog()) <br>      { <br>      // get the average using the start and stop data point  <br>      // from the log file <br>      PlaybackLines (pGraph-&gt;pSystemFirst,  <br>                     pGraph-&gt;pLineFirst,  <br>                     PlaybackLog.StartIndexPos.iPosition) ; <br>      PlaybackLines (pGraph-&gt;pSystemFirst,  <br>                     pGraph-&gt;pLineFirst,  <br>                     PlaybackLog.StopIndexPos.iPosition) ; <br>      } <br>   else <br>      { <br>      // Loop through all the DataLines and draw a bar for <br>      // it's last value. <br>      xDataPoint = pGraph-&gt;gKnownValue % pGraph-&gt;gMaxValues ; <br>      } <br> <br>   rectBar.bottom = pGraph-&gt;rectData.bottom + 1 ; <br> <br>   rectBkgrnd = pGraph-&gt;rectData ; <br> <br>   hOldBrush = SelectBrush (hDC, hBrushFace) ; <br> <br>   PatBlt (hDC,  <br>           rectBkgrnd.left, rectBkgrnd.top, <br>           rectBkgrnd.right - rectBkgrnd.left, <br>           rectBkgrnd.bottom - rectBkgrnd.top + 1, <br>           PATCOPY) ; <br>   DrawGrid(hDC, pGraph, &amp;(rectBkgrnd), FALSE) ; <br> <br>   rectBar.right = pGraph-&gt;rectData.left ; <br>   for (pLineStruct = pGraph-&gt;pLineFirst ; <br>        pLineStruct ; <br>        pLineStruct = pLineStruct-&gt;pLineNext) <br>      {  // for <br>      pDataPoints = pLineStruct-&gt;lnValues ; <br> <br>      if (PlayingBackLog()) <br>         { <br>         eValue = CounterEntry (pLineStruct) ; <br>         } <br>      else <br>         { <br>         eValue = pDataPoints[xDataPoint] ; <br>         } <br> <br> <br>      y = ScaleAndInvertY (eValue, <br>                           pLineStruct, <br>                           pGraph) ; <br> <br>      rectBar.left   = rectBar.right ; <br>      rectBar.top    = y ; <br> <br>      // nomore line to draw <br>      if (nLegendItems == 0 ) <br>         { <br>         break ; <br>         } <br> <br>      cxBar = DDA_DISTRIBUTE (cx, nLegendItems) ; <br>      rectBar.right  = rectBar.left + cxBar ; <br> <br>      // setup for next DDA <br>      nLegendItems-- ; <br>      cx -= cxBar ; <br> <br>      // NOTE: this handle creation should be moved to line <br>      //       create time. <br> <br>      if (pCurrentLine == pLineStruct) <br>         { <br>         SetBkColor (hDC, crWhite) ; <br>         } <br>      else <br>         { <br>         SetBkColor (hDC, pLineStruct-&gt;Visual.crColor) ; <br>         } <br>       ExtTextOut (hDC, rectBar.right, rectBar.top, ETO_OPAQUE, <br>         &amp;rectBar, NULL, 0, NULL) ; <br>      }  // for <br> <br>   return (TRUE) ; <br>   } <br> <br> <br>/*************************************************************************** <br> * DrawTLGraphData - Draw Time Line Graph Data. <br> * <br> *  Some notes about drawing the DataPoint graphs. <br> * <br> *      1]  It's real expensive to make a GDI call. So, we do not <br> *          make a MoveToEx and LineTo call for each point.  Instead <br> *          we create a polyline and send it down to GDI. <br> * <br> *      2]  The X coordinates for each point in the polyline is generated <br> *          from our favorite xDataPoint to xWindows DDA. <br> * <br> *      3]  The Y coordinate is generated from the pLineStruct-&gt;lnValues[x] <br> *          data associated with each line. <br> ***************************************************************************/ <br>BOOL DrawTLGraphData (HDC hDC,  <br>                      BOOL bForPaint, <br>                      PRECT prctPaint,  <br>                      PGRAPHSTRUCT pGraph) <br>/* <br>   Called By:     UpdateGraphDisplay only.  <br>*/ <br>   { <br>   PLINESTRUCT pLineStruct ; <br>   HPEN        hPen = 0 ; <br>   HPEN        hOldPen ; <br>   PFLOAT      pDataPoints ; <br>   INT         i, j, <br>               iValidValues, <br>               xDispDataPoint, <br>               xLeftLimit, <br>               xRightLimit ; <br>   PPOINT      pptDataPoints ; <br>   INT         numOfData, rectWidth, xPos ; <br>   PLINESTRUCT pCurrentLine ; <br>   INT         DrawZeroPoint = 0 ; <br> <br>//   SetBkColor (hDC, crLightGray) ; <br> <br>   if (!IsPrinterDC (hDC)) <br>      { <br>      if (bForPaint) <br>         { <br>         IntersectClipRect (hDC,  <br>                            pGraph-&gt;rectData.left, <br>                            pGraph-&gt;rectData.top, <br>                            pGraph-&gt;rectData.right, <br>                            pGraph-&gt;rectData.bottom + 1) ; <br>         } <br>      else <br>         { <br>         IntersectClipRect (hDC,  <br>                            pGraph-&gt;rectData.left, <br>                            pGraph-&gt;rectData.top, <br>                            PlayingBackLog () ?  <br>                              pGraph-&gt;rectData.right : <br>                              min (pGraph-&gt;rectData.right, <br>                                   pGraph-&gt;gTimeLine.xLastTime + 2), <br>                            pGraph-&gt;rectData.bottom + 1) ; <br>         } <br>      } <br> <br>   xLeftLimit  = prctPaint-&gt;left  - pGraph-&gt;gTimeLine.ppd - 1 ; <br>    <br>   if (bForPaint) <br>      xRightLimit = prctPaint-&gt;right + pGraph-&gt;gTimeLine.ppd ; <br>   else <br>      xRightLimit = prctPaint-&gt;right ; <br>    <br>   pptDataPoints  = pGraph-&gt;pptDataPoints ; <br> <br>   iValidValues   = pGraph-&gt;gTimeLine.iValidValues ; <br> <br>   if (!PlayingBackLog() &amp;&amp; <br>      pGraph-&gt;gOptions.iGraphOrHistogram == LINE_GRAPH) <br>      { <br>      // drawing the 0th at the end of the chart. <br>      DrawZeroPoint = 1 ; <br>      if (iValidValues == pGraph-&gt;gMaxValues) <br>         { <br>         iValidValues++ ; <br>         } <br>      } <br> <br>   // get current select line for highlighting <br>   if (pGraph-&gt;HighLightOnOff) <br>      { <br>      pCurrentLine = CurrentGraphLine (hWndGraph) ; <br>      } <br>   else <br>      { <br>      pCurrentLine = NULL ; <br>      } <br> <br>   // loop through lines to plot <br>   for (pLineStruct = pGraph-&gt;pLineFirst ; <br>        pLineStruct || pCurrentLine; <br>        pLineStruct = pLineStruct-&gt;pLineNext) <br>      {  // for <br> <br>      if (pLineStruct == NULL) <br>         { <br>         // now draw the current line <br>         pLineStruct = pCurrentLine ; <br>         } <br>      else if (pLineStruct == pCurrentLine) <br>         { <br>         // skip this line and draw it later <br>         continue ; <br>         } <br> <br>      // "Localize" some variables from the line data structure. <br>      pDataPoints    = pLineStruct-&gt;lnValues ; <br> <br> <br>      rectWidth      = pGraph-&gt;rectData.right - pGraph-&gt;rectData.left ; <br>      numOfData      = pGraph-&gt;gMaxValues - 1 + DrawZeroPoint ; <br> <br>      // Generate the polyline data. <br>      xDispDataPoint = pGraph-&gt;rectData.left ; <br> <br>      // Only process points that lie within the update region. <br>      // Also only process points that have valid data. <br>      j = 0 ; <br> <br>      for (i = 0 ; i &lt; iValidValues ; i++) <br>         {  // for <br>         if (xDispDataPoint &gt; xRightLimit) <br>            { <br>            // we are done! <br>            break ; <br>            } <br>         if (xDispDataPoint &gt;= xLeftLimit) <br>            { <br>            // It is within the limits, plot the point <br>            pptDataPoints[j].x = xDispDataPoint ; <br>            pptDataPoints[j].y = ScaleAndInvertY ( <br>               (i == pGraph-&gt;gMaxValues) ? pDataPoints[0] : pDataPoints[i], <br>               pLineStruct, <br>               pGraph) ; <br>            j++ ; <br>            }  // if <br> <br>         // setup for the next point <br>         if (!numOfData) <br>            { <br>            // no more points to go <br>            break ; <br>            } <br> <br>         xPos = DDA_DISTRIBUTE (rectWidth, numOfData) ; <br>         xDispDataPoint += xPos ; <br>         numOfData-- ; <br>         rectWidth -= xPos ; <br>         }  // for i <br> <br>      // only need to draw the line if there is point to draw. <br>      if (j &gt; 0) <br>         { <br>         // Set the pen color and draw the polyline. <br>         if (IsPrinterDC (hDC)) <br>            { <br>            hPen = LineCreatePen (hDC, &amp;(pLineStruct-&gt;Visual), TRUE) ; <br>            hOldPen = SelectObject (hDC, hPen) ; <br>            } <br>         else <br>            { <br>            if (pCurrentLine == pLineStruct) <br>               { <br>               // highlight this line by turning it into White color <br>               hOldPen = SelectObject (hDC, hWhitePen) ; <br>               } <br>            else <br>               { <br>               SelectObject (hDC, pLineStruct-&gt;hPen) ; <br>               } <br>            } <br> <br>         Polyline(hDC, pptDataPoints, j) ; <br> <br>         if (hPen) <br>            { <br>            SelectObject (hDC, hOldPen) ; <br> <br>            if (hPen != hWhitePen) <br>               { <br>               DeletePen (hPen) ; <br>               } <br>            hPen = 0 ; <br>            } <br>         } <br> <br>      if (pCurrentLine == pLineStruct) <br>         { <br>         // We are done... <br>         break ; <br>         } <br>      }  // for pLine <br> <br>   if (IsTLineWindowUp()) <br>      { <br>      // re-draw the timelines if need <br>      TLineRedraw (hDC, pGraph) ; <br>      } <br> <br>   // reset the clipping region <br>   SelectClipRgn (hDC, pGraph-&gt;hGraphRgn) ; <br> <br>   return (TRUE) ; <br>   }  // DrawTLGraphData <br> <br> <br> <br>/*************************************************************************** <br> * bInitTimeLine - Initialize the fields of the time line structure. <br> ***************************************************************************/ <br>BOOL bInitTimeLine(PGRAPHSTRUCT pGraph) <br>{ <br> <br>        pGraph-&gt;gTimeLine.xLastTime      = 0 ; <br>        pGraph-&gt;gTimeLine.ppd            = 0 ; <br>        pGraph-&gt;gTimeLine.rppd           = 0 ; <br>        pGraph-&gt;gTimeLine.iValidValues   = 1 ; <br> <br>        return (TRUE) ; <br> <br>} <br> <br> <br>/*************************************************************************** <br> * Scale Time Line <br> * <br> *  This routine should be called from the WM_SIZE message. <br> *  It does the scaling from the number of data points to the <br> *  size of the window. <br> ***************************************************************************/ <br>void ScaleTimeLine (PGRAPHSTRUCT pGraph) <br>   { <br>   INT     nDataPoints, <br>           cxClient ; <br> <br>   // Calculate the pels per data point. <br>   nDataPoints = pGraph-&gt;gMaxValues - 1 ; <br>   cxClient    = pGraph-&gt;rectData.right - pGraph-&gt;rectData.left ; <br> <br>   // ppd  = Pixels per DataPoint. <br>   // rppd = Remaining Pixels per DataPoint. <br>   pGraph-&gt;gTimeLine.ppd  = cxClient / nDataPoints ; <br>   pGraph-&gt;gTimeLine.rppd = cxClient % nDataPoints ; <br>   } <br> <br> <br>void DisplayTimeLine(HDC hDC, PGRAPHSTRUCT pGraph) <br>/* <br>   Called By:     OnPaint only. <br> <br>   Assert:        xDisplayPoint has been set by UpdateTimeLine on this <br>                  same timer tick. <br>*/ <br>   {  // DisplayTimeLine <br>   INT     xDisplayPoint ; <br>   RECT    rect ; <br> <br>   if (pGraph-&gt;gTimeLine.xLastTime == -1) <br>      { <br>      UpdateTimeLine (hGraphDisplayDC, pGraph, TRUE) ; <br>      } <br> <br>   // xDisplayPoint is X coordinate to display the time line at. <br>   if ((xDisplayPoint = pGraph-&gt;gTimeLine.xLastTime) == 0) <br>      return ; <br> <br>   SelectBrush (hDC, pGraph-&gt;hbRed) ; <br> <br>   if (xDisplayPoint &gt;= pGraph-&gt;rectData.right) <br>      { <br>      rect.left   = pGraph-&gt;rectData.left ; <br>      } <br>   else <br>      { <br>//      rect.left   = xDisplayPoint++ ; <br>      rect.left   = xDisplayPoint ; <br>      } <br>   rect.top    = pGraph-&gt;rectData.top ; <br>   rect.right  = rect.left + 2 ; <br>   rect.bottom = pGraph-&gt;rectData.bottom ; <br> <br>//   IntersectRect (&amp;rect, &amp;rect, &amp;pGraph-&gt;rectData) ; <br>   if (rect.right &gt; pGraph-&gt;rectData.right) <br>      { <br>      rect.right = pGraph-&gt;rectData.right ; <br>      } <br>   PatBlt (hDC,  <br>           rect.left, rect.top, <br>           rect.right - rect.left, <br>           rect.bottom - rect.top + 1 , <br>           PATCOPY) ; <br>          <br>   }  // DisplayTimeLine <br> <br> <br> <br>int SuggestedNumTics (int iRange) <br>/* <br>   Effect:        Return an appropriate number of tic marks to display <br>                  within iRange pixels. <br> <br>                  These numbers are empirically chosen for pleasing  <br>                  results. <br>*/ <br>   {  // SuggestedNumTics <br>   if (iRange &lt; 20) <br>      return (0) ; <br> <br>   if (iRange &lt; 50) <br>      return (2) ; <br> <br>   if (iRange &lt; 100) <br>      return (4) ; <br> <br>   if (iRange &lt; 150) <br>      return (5) ; <br> <br>   if (iRange &lt; 300) <br>      return (10) ; <br> <br>   if (iRange &lt; 500) <br>      return (20) ; <br> <br>   return (25) ; <br>   }  // SuggestedNumTics <br> <br> <br> <br>void SetGridPositions (PGRAPHSTRUCT pGraph) <br>   {  // SetGridPositions <br>   int            xDataWidth ; <br>   int            yDataHeight ; <br> <br>   int            iCurrentTicPixels ; <br>   int            iNumTics ; <br> <br>   int            i ; <br> <br> <br>   //=============================// <br>   // Set number of Tics          // <br>   //=============================// <br> <br>   xDataWidth = pGraph-&gt;rectData.right - pGraph-&gt;rectData.left ; <br>   yDataHeight = pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top ; <br> <br>   pGraph-&gt;xNumTics = PinInclusive (SuggestedNumTics (xDataWidth), <br>                                    0, iGraphMaxTics) ; <br>   pGraph-&gt;yNumTics = PinInclusive (SuggestedNumTics (yDataHeight), <br>                                    0, iGraphMaxTics) ; <br> <br>   // if we have more tics than possible integral values, reduce the number <br>   // of tics. <br>   if (pGraph-&gt;gOptions.iVertMax &lt; pGraph-&gt;yNumTics) <br>      pGraph-&gt;yNumTics = pGraph-&gt;gOptions.iVertMax ; <br> <br> <br>   //=============================// <br>   // Set X Tic Positions         // <br>   //=============================// <br> <br>   if (pGraph-&gt;xNumTics) <br>      { <br>      iNumTics = pGraph-&gt;xNumTics ; <br> <br>      pGraph-&gt;axTics[0] = 0 ; <br>      for (i = 1 ; <br>           i &lt; pGraph-&gt;xNumTics ; <br>           i++) <br>         {  // for <br>         if (iNumTics == 0) <br>            { <br>            break ; <br>            } <br>         iCurrentTicPixels = DDA_DISTRIBUTE (xDataWidth, iNumTics) ; <br>         pGraph-&gt;axTics [i] = pGraph-&gt;axTics [i - 1] + iCurrentTicPixels ; <br> <br>         xDataWidth -= iCurrentTicPixels ; <br>         iNumTics-- ; <br>         }  // for <br>      }  // if <br> <br> <br>   //=============================// <br>   // Set Y Tic Positions         // <br>   //=============================// <br> <br>   if (pGraph-&gt;yNumTics) <br>      { <br>      iNumTics = pGraph-&gt;yNumTics ; <br> <br>      pGraph-&gt;ayTics[0] = 0 ; <br>      for (i = 1 ; <br>           i &lt; pGraph-&gt;yNumTics ; <br>           i++) <br>         {  // for <br>         if (iNumTics == 0) <br>            { <br>            break ; <br>            } <br>         iCurrentTicPixels = DDA_DISTRIBUTE (yDataHeight, iNumTics) ; <br>         pGraph-&gt;ayTics [i] = pGraph-&gt;ayTics [i- 1] + iCurrentTicPixels ; <br> <br>         yDataHeight -= iCurrentTicPixels ; <br>         iNumTics-- ; <br>         }  // for <br>      }  // if <br>   }  // SetGridPositions <br> <br> <br> <br>int GraphVerticalScaleWidth (HDC hDC, <br>                             PGRAPHSTRUCT pGraph) <br>   { <br>   TCHAR          szMaxValue [20] ; <br>   int            xWidth ; <br> <br>   if (!pGraph-&gt;gOptions.bLabelsChecked) <br>      return (0) ; <br> <br> <br>//   SelectFont (hDC, IsPrinterDC (hDC) ? hFontPrinterScales : hFontScales) ; <br> <br> <br>   TSPRINTF (szMaxValue, TEXT(" %1d "), <br>            pGraph-&gt;gOptions.iVertMax * 10 ) ; <br> <br>   xWidth = TextWidth (hDC, szMaxValue) ; <br> <br>   return (xWidth) ; <br>   } <br> <br> <br> <br>void DrawGraphScale (HDC hDC,  <br>                     PGRAPHSTRUCT pGraph) <br>   { <br>   TCHAR   szScale [20] ; <br> <br>   INT     len, <br>           i, <br>           nLines, <br>           iUnitsPerLine ; <br>   FLOAT   ePercentOfTotal  ; <br>   FLOAT   eDiff ; <br>   BOOL    bUseFloatingPt = FALSE ; <br> <br>   //=============================// <br>   // Draw Vertical Scale?        // <br>   //=============================// <br> <br>   if (!pGraph-&gt;gOptions.bLabelsChecked) <br>       return ; <br> <br>   // Get the number of lines. <br>   nLines = pGraph-&gt;yNumTics ; <br> <br>   // nLines may be zero if the screen size if getting too small <br>   if (nLines &gt; 0) <br>      { <br>      // Calculate what percentage of the total each line represents. <br>      ePercentOfTotal = ((FLOAT) 1.0) / ((FLOAT) nLines)  ; <br> <br>      // Calculate the amount (number of units) of the Vertical max each <br>      // each line in the graph represents. <br>      iUnitsPerLine = (INT) ((FLOAT) pGraph-&gt;gOptions.iVertMax * ePercentOfTotal) ; <br>      ePercentOfTotal *= (FLOAT) pGraph-&gt;gOptions.iVertMax ; <br>      eDiff = (FLOAT)iUnitsPerLine - ePercentOfTotal ; <br>      if (eDiff &lt; (FLOAT) 0.0) <br>         eDiff = -eDiff ; <br> <br>      if (eDiff &gt; (FLOAT) 0.1) <br>         bUseFloatingPt = TRUE ; <br>      } <br> <br>   //=============================// <br>   // Set Drawing Attributes      // <br>   //=============================// <br> <br>//   SelectFont (hDC, IsPrinterDC (hDC) ? hFontPrinterScales : hFontScales) ; <br>   SetBkMode(hDC, TRANSPARENT) ; <br>   SetTextAlign (hDC, TA_TOP | TA_RIGHT) ; <br>   SelectObject(hDC, GetStockObject (BLACK_PEN)) ; <br> <br>   // Set the background color to gray <br>   if (!IsPrinterDC (hDC)) <br>      FillRect (hDC, &amp;(pGraph-&gt;rectVertScale), hbLightGray) ; <br> <br>// TESTING TESTING <br>#ifdef   PERFMON_DEBUG <br>GdiSetBatchLimit(1) ;   // disable Batching <br>#endif <br> <br>   // Now Output each string. <br>   for (i = 0 ;  <br>        i &lt; nLines ;  <br>        i++) <br>      {  // for <br>      if (bUseFloatingPt) <br>         { <br>         len = TSPRINTF (szScale, TEXT("%1.1f"), <br>            (FLOAT)pGraph-&gt;gOptions.iVertMax - ((FLOAT)i * <br>             ePercentOfTotal)) ; <br>         ConvertDecimalPoint (szScale) ; <br>         } <br>      else <br>         { <br>         len = TSPRINTF (szScale, TEXT("%d"), <br>                         pGraph-&gt;gOptions.iVertMax - (i * iUnitsPerLine)) ; <br>         } <br>      TextOut (hDC, <br>               pGraph-&gt;rectVertScale.right, <br>               pGraph-&gt;ayTics[i] + <br>               pGraph-&gt;rectData.top - HalfTextHeight, <br>               szScale, <br>               len) ; <br>      }  // for <br> <br>   // Output the "min value" separately. <br>   TextOut (hDC,  <br>            pGraph-&gt;rectVertScale.right, <br>            pGraph-&gt;rectData.bottom - HalfTextHeight, <br>            TEXT("0"), <br>            1) ; <br> <br>#ifdef   PERFMON_DEBUG <br>// TESTING TESTING <br>GdiSetBatchLimit(0) ;   // enable default Batching <br>#endif <br> <br> <br>   }  // DrawGraphScale <br> <br> <br> <br>void SizeGraphDisplayComponentsRect (HDC hDC, <br>                                     PGRAPHSTRUCT pGraph, <br>                                     RECT rectDisplay) <br>   {  // SizeGraphDisplayComponentsRect <br>   int            xScaleWidth ; <br> <br>   if (!rectDisplay.right || !rectDisplay.bottom) <br>      return ; <br> <br>   //=============================// <br>   // Size the Vertical Scale     // <br>   //=============================// <br> <br>   xScaleWidth = GraphVerticalScaleWidth (hDC, pGraph) ; <br>   pGraph-&gt;rectVertScale.left = rectDisplay.left ; <br>   pGraph-&gt;rectVertScale.top = rectDisplay.top ; <br>   pGraph-&gt;rectVertScale.right = rectDisplay.left + xScaleWidth ; <br>   pGraph-&gt;rectVertScale.bottom = rectDisplay.bottom ; <br> <br>   //=============================// <br>   // Size the Horizontal Scale   // <br>   //=============================// <br> <br>   pGraph-&gt;rectHorzScale.left = 0 ; <br>   pGraph-&gt;rectHorzScale.top = 0 ; <br>   pGraph-&gt;rectHorzScale.right = 0 ; <br>   pGraph-&gt;rectHorzScale.bottom = 0 ; <br> <br>   //=============================// <br>   // Size the Data Area          // <br>   //=============================// <br> <br>   pGraph-&gt;rectData.left = pGraph-&gt;rectVertScale.right + 3 + ThreeDPad ; <br>   pGraph-&gt;rectData.right = rectDisplay.right - 5 - ThreeDPad ; <br>   pGraph-&gt;rectData.top = rectDisplay.top + 5 + ThreeDPad ; <br>   pGraph-&gt;rectData.bottom = rectDisplay.bottom - 5 - ThreeDPad ; <br> <br>   SetGridPositions (pGraph) ; <br>   ScaleTimeLine (pGraph) ; <br> <br>   //==========================================// <br>   // Invalidate the last time line poisition  // <br>   //==========================================// <br>   pGraph-&gt;gTimeLine.xLastTime = -1 ; <br> <br>   if (pGraph-&gt;hGraphRgn) <br>      { <br>      DeleteObject (pGraph-&gt;hGraphRgn) ; <br>      } <br> <br>   pGraph-&gt;hGraphRgn = CreateRectRgn (rectDisplay.left, <br>      rectDisplay.top, <br>      rectDisplay.right, <br>      rectDisplay.bottom) ; <br> <br>   SelectClipRgn (hDC, pGraph-&gt;hGraphRgn) ; <br> <br>   }  // SizeGraphDisplayComponentsRect <br> <br> <br>void SizeGraphDisplayComponents (HWND hWnd) <br>/* <br>   Effect:        Given the graph display window hWnd, of size  <br>                  (xWidth x yHeight), determine the size and position <br>                  of the various graph display components: the vertical <br>                  scale, the horizontal scale, and the data area. <br> <br>   Called By:     OnSize, any other routine that changes the visibility <br>                  of a vertical or horizontal scale. <br> <br>   Note:          This function has multiple return points. <br>*/ <br>   {  // SizeGraphDisplayComponents <br>   PGRAPHSTRUCT   pGraph ; <br>   RECT           rectClient ; <br> <br>   pGraph = GraphData (hWnd) ; <br>   GetClientRect (hWnd, &amp;rectClient) ; <br> <br>   SizeGraphDisplayComponentsRect (hGraphDisplayDC, pGraph, rectClient) ; <br>   } <br> <br> <br>void UpdateGraphDisplay (HDC hDC, <br>                         BOOL bForPaint, <br>                         LPRECT lpRect, <br>                         PGRAPHSTRUCT pGraph) <br>/* <br>   Effect:        Draw the portions of the graph that change as the <br>                  graph's values change. This includes the background, <br>                  the grid, the lines, and the timeline. <br>*/ <br>   {  // UpdateGraphDisplay <br>   RECT           rectUpdate ; <br> <br>   if (!bForPaint &amp;&amp; !IsPrinterDC (hDC) &amp;&amp;  <br>       pGraph-&gt;gOptions.iGraphOrHistogram == LINE_GRAPH) <br>      { <br>      HBRUSH         hOldBrush ; <br> <br>      rectUpdate = pGraph-&gt;rectData ; <br>      rectUpdate.bottom += 1 ; <br> <br>      IntersectRect (&amp;rectUpdate, lpRect, &amp;rectUpdate) ; <br>      hOldBrush = SelectBrush (hDC, hBrushFace) ; <br> <br>      PatBlt (hDC,  <br>              rectUpdate.left, rectUpdate.top, <br>              rectUpdate.right - rectUpdate.left, <br>              rectUpdate.bottom - rectUpdate.top, <br>              PATCOPY) ; <br>      } <br>   else <br>      { <br>      IntersectRect (&amp;rectUpdate, lpRect, &amp;pGraph-&gt;rectData) ; <br>      } <br>    <br>   if (pGraph-&gt;gOptions.iGraphOrHistogram == LINE_GRAPH) <br>      { <br>      DrawGrid(hDC, pGraph, &amp;rectUpdate, bForPaint) ; <br>      if (pGraph-&gt;pLineFirst != NULL) <br>          { <br>          DrawTLGraphData(hDC, bForPaint, &amp;rectUpdate, pGraph) ; <br>          if (!PlayingBackLog ()) <br>             DisplayTimeLine(hDC, pGraph) ; <br>          } <br>      } <br>   else <br>      { <br>      DrawBarChartData (hDC, pGraph) ; <br>      } <br>   }  // UpdateGraphDisplay <br> <br>                     <br>BOOL UpdateTimeLine (HDC hDC,  <br>                     PGRAPHSTRUCT pGraph, </code></pre>
<p>
</p>
<pre><code>BOOL getLastTimeLocation) <br>/* <br>   Called By:     GraphTimer only. <br> <br>   See Also:      UpdateGraphDisplay. <br>*/ <br>   { <br>   INT     i, <br>           xDisplayPoint, <br>           xDataPoint ; <br>   RECT    rctUpdate ; <br>   INT     xLastTime ; <br>   INT     rectWidth, <br>           xPos, <br>           numOfPoints ; <br> <br> <br>   if ((xLastTime = pGraph-&gt;gTimeLine.xLastTime) != 0) <br>      { <br>      if ((pGraph-&gt;gKnownValue % pGraph-&gt;gMaxValues) == 1) <br>         { <br>         // Data wrap around case <br>         rctUpdate.left   = pGraph-&gt;rectData.left ; <br>         rctUpdate.right  = pGraph-&gt;rectData.left + <br>             pGraph-&gt;gTimeLine.ppd + 1 ; <br>         } <br>      else <br>         { <br>         rctUpdate.left   = xLastTime - pGraph-&gt;gTimeLine.ppd ; <br>         rctUpdate.right  = xLastTime + <br>             pGraph-&gt;gTimeLine.ppd + 1 ; <br>         } <br>      rctUpdate.top    = pGraph-&gt;rectData.top ; <br>      rctUpdate.bottom = pGraph-&gt;rectData.bottom + 1 ; <br>      } <br> <br>   // Calculate where to draw the time line. <br>   // This is done by running a simple DDA (Digital Differential Analyzer) <br>   // We have to position the time depending upon the size of the <br>   // graph window.  In essence we need to calculate the x display <br>   // coordinate. <br> <br>   // Note we should wrap Known Value in UpdateGLData. <br>   // We should also use a data buffer of 256 bytes so we can <br>   // wrap with and AND. <br> <br>   // xDataPoint =  pGraph-&gt;gKnownValue ; <br>   xDataPoint =  pGraph-&gt;gKnownValue % pGraph-&gt;gMaxValues ; <br> <br>   xDisplayPoint = pGraph-&gt;rectData.left ; <br> <br>   numOfPoints = pGraph-&gt;gMaxValues - 1 ; <br> <br>   if (!PlayingBackLog() &amp;&amp; <br>      pGraph-&gt;gOptions.iGraphOrHistogram == LINE_GRAPH) <br>      { <br>      // drawing the 0th at the end of the chart. <br>      // So, we do have gMaxValues points <br>      numOfPoints++ ; <br>      if ((pGraph-&gt;gKnownValue % pGraph-&gt;gMaxValues) == 0) <br>         { <br>         xDataPoint = pGraph-&gt;gMaxValues ; <br>         } <br>      } <br> <br>   rectWidth = pGraph-&gt;rectData.right - pGraph-&gt;rectData.left ; <br> <br>   for (i = 0 ; i &lt; xDataPoint ; i++) <br>      { <br>      if (numOfPoints == 0) <br>         { <br>         break ; <br>         } <br>      xPos = DDA_DISTRIBUTE (rectWidth, numOfPoints) ; <br>      xDisplayPoint += xPos ; <br>      rectWidth -= xPos ; <br>      numOfPoints-- ; <br>      }  // for <br> <br>   pGraph-&gt;gTimeLine.xLastTime = xDisplayPoint ; <br> <br>   if (!getLastTimeLocation &amp;&amp; iPerfmonView == IDM_VIEWCHART &amp;&amp; !bPerfmonIconic) <br>      { <br>      UpdateGraphDisplay (hDC, FALSE, &amp;rctUpdate, pGraph) ; <br>      } <br> <br>   return(TRUE) ; <br>   } <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void /*static*/ OnCreate (HWND hWnd) <br>/* <br>   Effect:        Perform all actions needed when a GraphDisplay window is  <br>                  created. <br>                  In particular, initialize the graph instance data and <br>                  create the child windows. <br> <br>   Called By:     GraphDisplayWndProc, in response to a WM_CREATE message. <br>*/ <br>   {  // OnCreate <br>   LOGBRUSH       LogBrush ; <br>   TEXTMETRIC     tmScales ; <br> <br>   hGraphDisplayDC = GetDC(hWnd) ; <br> <br>   SelectFont(hGraphDisplayDC, hFontScales) ; <br>   GetTextMetrics(hGraphDisplayDC, &amp;tmScales) ; <br>   HalfTextHeight = tmScales.tmHeight / 2 ; <br> <br>   SetBkColor (hGraphDisplayDC, crLightGray) ; <br> <br> <br>   InsertGraph(hWnd) ; <br>   bInitTimeLine(pGraphs) ; <br> <br>   pGraphs-&gt;hWnd = hWnd ; <br> <br>   // Create the brush and pen used by the time line. <br>   // We don't want to create these on every timer tick. <br> <br>   LogBrush.lbStyle = BS_SOLID ; <br>   LogBrush.lbColor = RGB(0xff, 0, 0) ; <br>   LogBrush.lbHatch = 0 ; <br> <br>   // Now get the system resources we use "all the time" <br>   pGraphs-&gt;hbRed = CreateBrushIndirect(&amp;LogBrush) ; <br>   pGraphs-&gt;hGridPen = CreatePen (PS_SOLID, 1, crGray) ; <br> <br>   pGraphs-&gt;xNumTics = 0 ; <br>   pGraphs-&gt;yNumTics = 0 ; <br>   }  // OnCreate <br> <br> <br>void /*static*/ OnSize (HWND hWnd, <br>                    WORD xWidth, <br>                    WORD yHeight) <br>   {  // OnSize <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWnd) ; <br> <br>   SizeGraphDisplayComponents (hWnd) ; <br>   }  // OnSize <br> <br> <br>void /*static*/ OnPaint (HWND hWnd) <br>   { <br>   HDC            hDC ; <br>   PAINTSTRUCT    ps ; <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWnd) ; <br>   hDC = BeginPaint(hWnd, &amp;ps) ; <br> <br>   DrawGraphDisplay (hDC, ps.rcPaint, pGraph) ; <br> <br>   EndPaint(hWnd, &amp;ps) ; <br>   }  // OnPaint <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br>#ifdef KEEP_PRINT <br>void PrintGraphDisplay (HDC hDC, <br>                        PGRAPHSTRUCT pGraph) <br>   { <br>   DrawGraphScale (hDC, pGraph) ; <br> <br> <br>//!!   UpdateGraphDisplay (hDC, TRUE, &amp;(pGraph-&gt;rectData), pGraph) ; <br> <br>   IntersectClipRect (hDC, 0, 0, 10000, 10000) ; <br>   SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ; <br>   SelectPen (hDC, GetStockObject (BLACK_PEN)) ; <br>   Rectangle (hDC,  <br>              pGraph-&gt;rectData.left, <br>              pGraph-&gt;rectData.top, <br>              pGraph-&gt;rectData.right, <br>              pGraph-&gt;rectData.bottom) ; <br>   }  // PrintGraphDisplay <br>#endif <br> <br> <br> <br>void DrawGraphDisplay (HDC hDC, <br>                       RECT rectDraw, <br>                       PGRAPHSTRUCT pGraph) <br>   { <br>   BOOL        bPaintScale ; <br>   INT         LocalThreeDPad = ThreeDPad - 1 ; <br> <br>   // Only draw the vertical labels if the paint rectangle <br>   // any portion of the window to the left of the graph area. <br> <br>   bPaintScale = (rectDraw.left &lt;= pGraph-&gt;rectVertScale.right) ; <br>   if (bPaintScale) <br>      DrawGraphScale (hDC, pGraph) ; <br>   if (IsPrinterDC (hDC)) <br>      Rectangle (hDC,  <br>                 pGraph-&gt;rectData.left, <br>                 pGraph-&gt;rectData.top, <br>                 pGraph-&gt;rectData.right, <br>                 pGraph-&gt;rectData.bottom) ; <br>   else <br>      ThreeDConcave1 (hDC,  <br>                     pGraph-&gt;rectData.left - LocalThreeDPad, <br>                     pGraph-&gt;rectData.top - LocalThreeDPad, <br>                     pGraph-&gt;rectData.right + LocalThreeDPad, <br>                     pGraph-&gt;rectData.bottom + LocalThreeDPad + 1) ; <br> <br>   UpdateGraphDisplay (hDC, TRUE, &amp;(rectDraw), pGraph) ; <br>   }  // DrawGraphDisplay <br> <br> <br>LRESULT APIENTRY GraphDisplayWndProc (HWND hWnd,  <br>                                      UINT uMsg,  <br>                                      WPARAM wParam, <br>                                      LPARAM lParam) <br>   {  // GraphDisplayWndProc <br>   LONG        lret = 0L ; <br>   BOOL        bCallDefProc = FALSE ; <br> <br>   switch (LOWORD (uMsg)) <br>      { <br>      case WM_LBUTTONDOWN: <br>         DoWindowDrag (hWnd, lParam) ; <br>         break ; <br> <br>      case WM_LBUTTONDBLCLK: <br>         SendMessage (hWndMain, uMsg, wParam, lParam) ; <br>         break ; <br> <br>      case WM_CREATE: <br>         OnCreate (hWnd) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         KillTimer(hWndMain, GRAPH_TIMER_ID) ; <br>         break ; <br> <br>      case WM_PAINT: <br>         OnPaint (hWnd) ; <br>         break ; <br> <br>      case WM_TIMER: <br>         GraphTimer (hWnd, FALSE) ; <br>         break ; <br> <br>      default: <br>         bCallDefProc = TRUE ; <br>         break ; <br>      }  // switch <br> <br> <br>   if (bCallDefProc) <br>      { <br>      lret = DefWindowProc(hWnd, uMsg, wParam, lParam) ; <br>      } <br>   return (lret) ; <br>   } <br> <br> <br>BOOL GraphDisplayInitializeApplication (void) <br>   {  // GraphDisplayInitializeApplication <br>   WNDCLASS       wc ; <br> <br>   wc.style         = dwGraphDisplayClassStyle ; <br>   wc.lpfnWndProc   = (WNDPROC) GraphDisplayWndProc ; <br>   wc.hInstance     = hInstance ; <br>   wc.cbClsExtra    = iGraphDisplayWindowExtra ; <br>   wc.cbWndExtra    = iGraphDisplayClassExtra ; <br>   wc.hIcon         = NULL ; <br>   wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ; <br>   wc.hbrBackground = hbLightGray ; <br>   wc.lpszMenuName  = NULL ; <br>   wc.lpszClassName = (LPTSTR) szGraphDisplayWindowClass ; <br> <br>   return (RegisterClass (&amp;wc)) ; <br>   }  // GraphDisplayInitializeApplication <br> <br> <br> <br>HWND CreateGraphDisplayWindow (HWND hWndGraph) <br>   { <br>   return (CreateWindow (szGraphDisplayWindowClass,   // class <br>                         NULL,                        // caption <br>                         dwGraphDisplayWindowStyle,   // window style <br>                         0, 0,                        // position <br>                         0, 0,                        // size <br>                         hWndGraph,                   // parent window <br>                         NULL,                        // menu <br>                         hInstance,                  // program instance <br>                         NULL)) ;                     // user-supplied data <br>   } <br> <br> <br> <br>BOOL ToggleGraphRefresh (HWND hWnd) <br>   {  // ToggleGraphRefresh <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWnd) ; <br> <br>   if (pGraph-&gt;bManualRefresh) <br>      SetGraphTimer (pGraph) ; <br>   else <br>      ClearGraphTimer (pGraph) ; <br> <br>   pGraph-&gt;bManualRefresh = !pGraph-&gt;bManualRefresh ; <br>   return (pGraph-&gt;bManualRefresh) ; <br>   }  // ToggleGraphRefresh <br> <br>BOOL GraphRefresh (HWND hWnd) <br>   {  // GraphRefresh <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWnd) ; <br> <br>   return (pGraph-&gt;bManualRefresh) ; <br>   }  // GraphRefresh <br> <br> <br>void GraphTimer (HWND hWnd,  <br>                 BOOL bForce) <br>/* <br>   Effect:        Handle any actions necessary when the graph display <br>                  window hWnd receives a timer tick. In particular, <br>                  update the graph display and update the status bar <br>                  if it is showing. <br> <br>   Called By:     GraphDisplayWndProc, in response to a WM_TIMER message. <br>*/ <br>   {  // GraphTimer <br>   PGRAPHSTRUCT         pGraph ; <br> <br>   pGraph = GraphData (hWnd) ; <br> <br>   if (!pGraph-&gt;pLineFirst) <br>      return ; <br> <br> <br>   if (bForce || !pGraph-&gt;bManualRefresh) <br>      { <br> <br>    <br>      HandleGraphTimer () ; <br> <br>      // If we are displaying a time-line graph then do the <br>      // calculations for the minimal update region. <br>      // If were doing a bar graph, then draw the <br>      // whole graph area. <br> <br>      if (pGraph-&gt;gOptions.iGraphOrHistogram == LINE_GRAPH) <br>         UpdateTimeLine (hGraphDisplayDC, pGraph, FALSE) ; <br>      else <br>         DrawBarChartData (hGraphDisplayDC, pGraph) ; <br> <br>      // Take care of the status bar window <br>      StatusTimer (hWndGraphStatus, FALSE) ; <br> <br>      }  // if <br>   }  // GraphTimer <br> <br>// this routine set/reset the line highlight mode <br>void ChartHighlight (void) <br>   { <br>   PGRAPHSTRUCT         pGraph ; <br> <br> <br>   if (pGraph = GraphData (hWndGraph)) <br>      { <br>      if (pGraph-&gt;pLineFirst) <br>         { <br>         // toggle the HightlightOnOff mode <br>         pGraph-&gt;HighLightOnOff = !pGraph-&gt;HighLightOnOff ; <br>         WindowInvalidate (hWndGraphDisplay) ; <br>         } <br>      else <br>         { <br>         // no line availble, just turn it off <br>         pGraph-&gt;HighLightOnOff = FALSE ; <br>         } <br>      } <br>   }  // ChartHighlight <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
