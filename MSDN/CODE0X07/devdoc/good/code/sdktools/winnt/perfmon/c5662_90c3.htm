<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5673"></a>LOG.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  Log.c - This module handles the Logging. <br> * <br> *  Microsoft Confidential <br> *  Copyright 1992 - 1998 Microsoft Corporation <br> * <br> * <br> ****************************************************************************/ <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br>#include &lt;stdio.h&gt; <br> <br>#include "perfmon.h" <br>#include "log.h" <br> <br>#include "fileutil.h" <br>#include "owndraw.h" <br>#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines <br>#include "perfmops.h"      // for SystemAdd <br>#include "perfdata.h" <br>#include "playback.h"      // for PlayingBackLog <br>#include "status.h"        // for StatusUpdateIcons <br>#include "system.h"        // for SystemAdd <br>#include "utils.h" <br>#include "fileopen.h"      // for FileGetName <br>#include "command.h" <br> <br>extern TCHAR LOCAL_SYS_CODE_NAME[] ; <br> <br>//==========================================================================// <br>//                              Funtion Prototypes                          // <br>//==========================================================================// <br> <br> <br>BOOL LogWriteStartBookmark (HWND hWnd, SYSTEMTIME *pSystemTime) ; <br>BOOL LogWriteBookmarkData (HWND hWnd, PBOOKMARK pBookMark) ; <br>BOOL LogWriteSystemBookmark (HWND hWnd, LPTSTR SysName, BOOL DisConnect, SYSTEMTIME *pSystemTime) ; <br> <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br> <br>#define LogNameMinLen             15 <br>#define LogObjectMinLen           20 <br> <br>// This is set to 1 min <br>#define LARGE_INTERVAL            60 <br> <br>//=============================// <br>// Log Class                   // <br>//=============================// <br> <br> <br>#define dwLogClassStyle           (CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS) <br>#define iLogClassExtra            (0) <br>#define iLogWindowExtra           (0) <br>#define dwLogWindowStyle          (WS_CHILD) <br> <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br> <br>int            xStatusWidth ; <br>int            xNameMinWidth ; <br> <br>TCHAR          szClosed [ShortTextLen] ; <br>TCHAR          szCollecting [ShortTextLen] ; <br>// TCHAR          szPaused [ControlStringLen + 1] ; <br> <br> <br> <br>LOGINDEXBLOCK  *pLogIndexBlock ; <br> <br>#define WM_START_LOGGING  WM_USER+2 <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define LogEntryN(hWndLogEntries, iIndex)        \ <br>   ((PLOGENTRY) LBData (hWndLogEntries, iIndex)) <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br>void LogAddEntryToList (PLOGENTRY *ppLogEntryFirst, PLOGENTRY pLogNewEntry) <br>{ <br>   // insert the new entry at the beginning <br>   pLogNewEntry-&gt;pNextLogEntry = *ppLogEntryFirst ; <br>   *ppLogEntryFirst = pLogNewEntry ; <br>} <br> <br>void LogDeleteEntryFromList (PLOGENTRY *ppLogEntryFirst, PLOGENTRY pLogEntryDel) <br>{ <br>   PLOGENTRY   pLogEntry ; <br> <br>   if (*ppLogEntryFirst == pLogEntryDel) <br>      { <br>      *ppLogEntryFirst = pLogEntryDel-&gt;pNextLogEntry ; <br>      } <br>   else <br>      { <br>      for (pLogEntry = *ppLogEntryFirst ; <br>         pLogEntry ; <br>         pLogEntry = pLogEntry-&gt;pNextLogEntry) <br>         { <br>         if (pLogEntry-&gt;pNextLogEntry == pLogEntryDel) <br>            { <br>            // found, remove this entry from the list <br>            pLogEntry-&gt;pNextLogEntry = <br>               pLogEntryDel-&gt;pNextLogEntry ; <br>            break ; <br>            } <br>         } <br>      } <br>} <br> <br> <br>// LogDeleteIndex - delete the log entry specified by iIndex <br>// and do memory clean-up <br>void static LogDeleteIndex (HWND hWndLogEntries, int iIndex) <br>{ <br>   PLOGENTRY   pLogEntry ; <br>   PLOG        pLog ; <br> <br>   pLogEntry = (PLOGENTRY) LBData(hWndLogEntries, iIndex) ; <br> <br>    <br>   if (pLogEntry &amp;&amp; pLogEntry != (PLOGENTRY)LB_ERR) <br>      { <br>      pLog = LogData (hWndLog) ; <br> <br>      if (pLog-&gt;pLogEntryFirst) <br>         { <br>         LogDeleteEntryFromList (&amp;(pLog-&gt;pLogEntryFirst), pLogEntry) ; <br>         } <br> <br>      MemoryFree (pLogEntry) ; <br>      } <br>       <br>   LBDelete (hWndLogEntries, iIndex) ; <br>} <br> <br> <br>void LogEntriesChanged (HWND hWndLogEntries) <br>/* <br>   Effect:        Perform any actions needed when an entry has been added or <br>                  removed from the log. In particular, determine if a new <br>                  "Object" column width is appropriate. If it is, then <br>                  change the width and redraw the log entries list. <br>*/ <br>   {  // LogEntriesChanged <br>   int         iIndex ; <br>   int         iIndexNum ; <br>   int         xCol1Width ; <br>   HDC         hDC ; <br>   PLOG        pLog ; <br>   PLOGENTRY   pLogEntry ; <br>   PPERFSYSTEM pSystem; <br> <br>   pLog = LogData (hWndLog) ; <br>   xCol1Width = 0 ; <br> <br>   hDC = GetDC (hWndLog) ; <br>   iIndexNum = LBNumItems (hWndLogEntries) ; <br>     <br>    // clear value Strings for all systems <br> <br>    for (pSystem = pLog-&gt;pSystemFirst; <br>         pSystem; <br>         pSystem = pSystem-&gt;pSystemNext) { <br>        if (pSystem &amp;&amp; pSystem-&gt;FailureTime == 0) { <br>            RemoveObjectsFromSystem (pSystem); <br>        } <br>    } <br> <br>   for (iIndex = 0 ; <br>        iIndex &lt; iIndexNum ; <br>        iIndex++) <br>      {  // for all items in the list <br>      pLogEntry = LogEntryN (hWndLogEntries, iIndex) ; <br>      xCol1Width = max (TextWidth (hDC, pLogEntry-&gt;szObject),  <br>                        xCol1Width) ; <br> <br>      pSystem = SystemGet (pLog-&gt;pSystemFirst, pLogEntry-&gt;szComputer); <br>      if (pSystem &amp;&amp; pSystem-&gt;FailureTime == 0) { <br>         AppendObjectToValueList ( <br>                pLogEntry-&gt;ObjectTitleIndex, <br>                pSystem-&gt;lpszValue); <br>         }  <br>      }  // for <br> <br>   xCol1Width += 2 * xScrollWidth ; <br>   xCol1Width = max (xCol1Width,  <br>                     TextAvgWidth (hDC, LogObjectMinLen)) ; <br>   if (xCol1Width != pLog-&gt;xCol1Width) <br>      { <br>      pLog-&gt;xCol1Width = xCol1Width ; <br>      WindowInvalidate (hWndLogEntries) ; <br>      } <br>   ReleaseDC (hWndLog, hDC) ; <br>   }  // LogEntriesChanged <br> <br> <br>LPTSTR StatusText (int iPMStatus) <br>/* <br>   Effect:        Return a string representation of the log status <br>                  iPMStatus. <br> <br>   Note:          Since these are globals, we can just return a pointer <br>                  to them. The user of this routine should not free <br>                  these pointers or modify the string. <br>*/ <br>   { <br>   switch (iPMStatus) <br>      {  // switch <br>      case iPMStatusClosed: <br>         return (szClosed) ; <br> <br>      case iPMStatusCollecting: <br>         return (szCollecting) ; <br> <br>//      case iPMStatusPaused: <br>//         return (szPaused) ; <br> <br>      default: <br>         return (szClosed) ; <br>      }  // switch <br>   }  // StatusText <br> <br> <br>PLOG AllocateLogData (HWND hWndLog) <br>   { <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   pLog-&gt;iStatus = iPMStatusClosed ; <br>   pLog-&gt;bManualRefresh = FALSE ; <br> <br>   // let's not give it a filename <br> <br>/*!! <br>   FileCombine (pLog-&gt;szFilePath,  <br>                szDefaultLogDirectory, szDefaultLogFileName) ; <br>!!*/ <br>   strclr (pLog-&gt;szFilePath) ; <br> <br>   pLog-&gt;pSystemFirst = NULL; <br>   pLog-&gt;lFileSize = 0L ; <br>   pLog-&gt;iIntervalMSecs = iDefaultLogIntervalSecs * 1000 ; <br> <br>   pLog-&gt;pLogData = (PPERFDATA) MemoryAllocate (STARTING_SYSINFO_SIZE) ; <br>   pLog-&gt;dwDetailLevel = PERF_DETAIL_WIZARD ; <br>   LogEntriesChanged (hWndLogEntries) ; <br> <br>   return (pLog) ; <br>   }  // AllocateLogData <br> <br> <br>void FreeLogData (PLOG pLog) <br>   {  // FreeLogData <br>   MemoryFree (pLog-&gt;pLogData) ; <br>   }  // FreeLogData <br> <br> <br>void UpdateLogSize (HWND hWnd) <br>/* <br>   Effect:        Set the size value to the current size.  Also change the <br>                  size entry in the status line. <br>*/ <br>   {  // UpdateLogSize <br>   PLOG           pLog ; <br>   TCHAR          szSize [ShortTextLen + 1] ; <br> <br>   pLog = LogData (hWnd) ; <br>    <br>   LongToCommaString (pLog-&gt;lFileSize, szSize) ; <br>   SetDlgItemText (hWnd, IDD_LOGSIZE, szSize) ; <br> <br>   if (!PlayingBackLog()) <br>      { <br>      StatusUpdateIcons (hWndStatus) ; <br>      } <br>   }  // UpdateLogSize <br> <br> <br>HANDLE LogAppendSetup(PLOG pLog, PLOGHEADER pLogFileHeader) <br>   {  // LogAppendSetup <br>   PLOGHEADER     pHeader ; <br>   LOGPOSITION    LP ; <br>   DWORD          lPreviousIndexBlock ; <br>   DWORD          lNextIndexBlock ; <br>   PLOGHEADER     pPlaybackLogHeader ; <br>   HANDLE         hMapHandle ; <br> <br>   pHeader = (PLOGHEADER) FileMap(pLog-&gt;hFile, &amp;hMapHandle) ; <br>   if (!pHeader || <br>       !strsame(pHeader-&gt;szSignature, LogFileSignature) || <br>       pHeader-&gt;wVersion != LogFileVersion || <br>       pHeader-&gt;wRevision != LogFileRevision) <br>      { <br>      if (pHeader) <br>         { <br>         FileUnMap((LPVOID)pHeader, hMapHandle) ; <br>         } <br>      return 0 ; <br>      } <br> <br>   *pLogFileHeader = *pHeader ; <br> <br> <br>   LP.pIndexBlock = FirstIndexBlock(pHeader) ; <br>   LP.iIndex = 0 ; <br>   LP.iPosition = 0 ; <br>   lPreviousIndexBlock = pHeader-&gt;iLength ; <br>   lNextIndexBlock = LP.pIndexBlock-&gt;lNextBlockOffset ; <br> <br>   // since inside NextReLogIndexPosition would eventually call <br>   // PlaybackSeek for large log file, we have to temporarily <br>   // setup PlaybackLog.pHeader.   Not a good fix but it works... <br>   pPlaybackLogHeader = PlaybackLog.pHeader ; <br>   PlaybackLog.pHeader = pHeader ; <br>   while (NextReLogIndexPosition(&amp;LP)) <br>      { <br>      if (LP.pIndexBlock-&gt;lNextBlockOffset != lNextIndexBlock) <br>         { <br>         lPreviousIndexBlock = lNextIndexBlock ; <br>         lNextIndexBlock = LP.pIndexBlock-&gt;lNextBlockOffset ; <br>         } <br>      } <br> <br>   // get the last system time from this log file <br>   if (LP.iIndex &gt; 0) <br>      { <br>      SYSTEMTIME localSystemTime ; <br> <br>      if (LogPositionSystemTime (&amp;LP, &amp;localSystemTime)) <br>         { <br>         pLog-&gt;LastLogTime = localSystemTime ; <br>         } <br>      } <br> <br>   PlaybackLog.pHeader = pPlaybackLogHeader ; <br>   if (!pLogIndexBlock) <br>      { <br>      pLogIndexBlock = (LOGINDEXBLOCK *) MemoryAllocate (sizeof(LOGINDEXBLOCK)) ; <br>      } <br>   *pLogIndexBlock = *LP.pIndexBlock ; <br>   pLog-&gt;lIndexBlockOffset = lPreviousIndexBlock ; <br>   pLog-&gt;iIndex = ++LP.iIndex ; <br>   pLog-&gt;lFileSize = FileSeekEnd(pLog-&gt;hFile, 0) ; <br> <br>   FileUnMap((LPVOID)pHeader, hMapHandle) ; <br>   return pLog-&gt;hFile ; <br>   }  // LogAppendSetup <br> <br>void LogRemoveCounterName (PLOG pLog) <br>   { <br>   PPERFSYSTEM    pSystem ; <br> <br>   if (pLog-&gt;pBaseCounterName) <br>      { <br>      MemoryFree (pLog-&gt;pBaseCounterName) ; <br>      } <br>   pLog-&gt;pBaseCounterName = 0 ; <br>   pLog-&gt;lBaseCounterNameSize = 0 ; <br>   pLog-&gt;lBaseCounterNameOffset = 0 ; <br> <br>   // clear all the system marker to indicate they have not been  <br>   // saved <br>   for (pSystem = pLog-&gt;pSystemFirst ; <br>      pSystem ; <br>      pSystem = pSystem-&gt;pSystemNext) <br>      { <br>      pSystem-&gt;bSystemCounterNameSaved = FALSE ; <br>      } <br>   } <br> <br>int CreateLogFile (PLOG pLog, BOOL bCreateFile, BOOL bSameFile) <br>   {  // CreateLogFile <br>   HANDLE               returnHandle ; <br>   LOGHEADER            LogFileHeader ; <br>   long                 lCurPosition ; <br>   LOGFILECOUNTERNAME   CounterNameRecord ; <br> <br>   pLog-&gt;lFileSize = 0 ; <br>   memset (&amp;(pLog-&gt;LastLogTime), 0, sizeof(SYSTEMTIME)) ; <br> <br>   if (!pLogIndexBlock) <br>      { <br>      pLogIndexBlock = (LOGINDEXBLOCK *) MemoryAllocate (sizeof(LOGINDEXBLOCK)) ; <br>      } <br> <br>   lstrcpy (pLogIndexBlock-&gt;szSignature, LogIndexSignature) ; <br>   pLog-&gt;hFile = FileHandleOpen (pLog-&gt;szFilePath) ; <br>   if (pLog-&gt;hFile != INVALID_HANDLE_VALUE) <br>      { <br>      // if this is a pre-existing log file, set up to append to it <br>      returnHandle = LogAppendSetup(pLog, &amp;LogFileHeader) ; <br>      if (!returnHandle) <br>         { <br>         // this is not a log file... <br>         CloseHandle (pLog-&gt;hFile) ; <br>         return (ERR_BAD_LOG_FILE) ; <br>         } <br>       <br>      pLog-&gt;hFile = returnHandle ; <br>      } <br> <br>   if (bCreateFile &amp;&amp; (!pLog-&gt;hFile || pLog-&gt;hFile == INVALID_HANDLE_VALUE)) <br>      { <br>      // Create a new log file if needed. <br>      pLog-&gt;hFile = FileHandleCreate (pLog-&gt;szFilePath) ; <br>      if (!pLog-&gt;hFile || pLog-&gt;hFile == INVALID_HANDLE_VALUE) <br>         return (ERR_LOG_FILE) ; <br>      lstrcpy (LogFileHeader.szSignature, LogFileSignature) ; <br>      LogFileHeader.wVersion = LogFileVersion ; <br>      LogFileHeader.wRevision = LogFileRevision ; <br>      LogFileHeader.iLength = sizeof (LOGHEADER) ; <br>      LogFileHeader.lBaseCounterNameOffset = 0 ; <br>      if (!FileWrite (pLog-&gt;hFile, &amp;LogFileHeader, sizeof (LogFileHeader))) <br>         { <br>         CloseHandle (pLog-&gt;hFile) ; <br>         return (ERR_LOG_FILE) ; <br>         } <br> <br>      pLog-&gt;iIndex = 0 ; <br>      pLog-&gt;lIndexBlockOffset = FileTell (pLog-&gt;hFile) ; <br>      FileSeekCurrent (pLog-&gt;hFile, sizeof (LOGINDEXBLOCK)) ; <br>      pLog-&gt;lFileSize = sizeof(LOGHEADER) + sizeof (LOGINDEXBLOCK) ; <br>      pLogIndexBlock-&gt;iNumIndexes = 0 ; <br>      pLogIndexBlock-&gt;lNextBlockOffset = 0 ; <br> <br>      // get rid of any previous counter names and get ready for start <br>//      if (!bSameFile) <br>//         { <br>//         LogRemoveCounterName (pLog) ; <br>//         } <br>      LogRemoveCounterName (pLog) ; <br>      } <br>   else if (bCreateFile) <br>      { <br>      // this is an existing log file, setup the counter names <br>      // LogFileHeader already has the header info filled in <br>      // by LogAppendSetup <br>      if (!bSameFile || !pLog-&gt;pBaseCounterName) <br>         { <br>         // get rid of any previous counter names <br>         LogRemoveCounterName (pLog) ; <br> <br>         // read the new names and get ready for start <br>         lCurPosition = FileTell (pLog-&gt;hFile) ; <br> <br>         FileSeekBegin (pLog-&gt;hFile, <br>            LogFileHeader.lBaseCounterNameOffset) ; <br> <br>         if (!(FileRead (pLog-&gt;hFile, <br>            &amp;CounterNameRecord, <br>            sizeof (CounterNameRecord)))) <br>            { <br>            FileSeekBegin (pLog-&gt;hFile, <br>               lCurPosition) ; <br>            goto EXIT ; <br>            } <br> <br>         FileSeekBegin (pLog-&gt;hFile, <br>            CounterNameRecord.lCurrentCounterNameOffset) ; <br> <br>         if (!(pLog-&gt;pBaseCounterName = MemoryAllocate ( <br>            CounterNameRecord.lUnmatchCounterNames))) <br>            { <br>            FileSeekBegin (pLog-&gt;hFile, <br>               lCurPosition) ; <br>            goto EXIT ; <br>            } <br>         if (!(FileRead (pLog-&gt;hFile, <br>            pLog-&gt;pBaseCounterName, <br>            CounterNameRecord.lUnmatchCounterNames))) <br>            { <br>            MemoryFree (pLog-&gt;pBaseCounterName) ; <br>            pLog-&gt;pBaseCounterName = NULL ; <br>            FileSeekBegin (pLog-&gt;hFile, <br>               lCurPosition) ; <br>            goto EXIT ; <br>            } <br>         // we got the data, fill in other info <br>         pLog-&gt;lBaseCounterNameSize = <br>            CounterNameRecord.lUnmatchCounterNames ; <br>         pLog-&gt;lBaseCounterNameOffset = <br>            LogFileHeader.lBaseCounterNameOffset ; <br>                <br>         FileSeekBegin (pLog-&gt;hFile, <br>            lCurPosition) ; <br>         } <br>      } <br> <br>EXIT: <br> <br>   return (0) ; <br> <br>   }  // CreateLogFile <br> <br>void LogWriteIndexBlock (PLOG pLog) <br>   { <br>   FileSeekBegin (pLog-&gt;hFile,  <br>                  pLog-&gt;lIndexBlockOffset) ; <br>   pLogIndexBlock-&gt;lNextBlockOffset = 0 ; <br>   FileWrite (pLog-&gt;hFile, <br>              (LPSTR) pLogIndexBlock, <br>              sizeof (LOGINDEXBLOCK)) ; <br>   }  // LogWriteIndexBlock <br> <br> <br>BOOL LogWriteIndex (PLOG pLog, <br>                    UINT uFlags, <br>                    SYSTEMTIME *pSystemTime, <br>                    LONG lDataOffset, <br>                    int iSystemsLogged)  <br>   {  // LogWriteIndex <br>   LOGINDEX       Index ; <br>   long           lNextBlockOffset ; <br>   BOOL           WriteOK ; <br>   //=============================// <br>   // Add Index Block Entry       // <br>   //=============================// <br>   //=============================// <br>   // Index Block Full?           // <br>   //=============================// <br> <br>   WriteOK = TRUE ; <br> <br>   if (pLog-&gt;iIndex == LogFileBlockMaxIndexes - 1) <br>      { <br>      lNextBlockOffset = FileTell (pLog-&gt;hFile) ; <br>      pLogIndexBlock-&gt;lNextBlockOffset = lNextBlockOffset ; <br>      FileSeekBegin (pLog-&gt;hFile,  <br>                     pLog-&gt;lIndexBlockOffset) ; <br>      WriteOK = FileWrite (pLog-&gt;hFile, <br>                           (LPSTR) pLogIndexBlock, <br>                           sizeof (LOGINDEXBLOCK)) ; <br>      if (WriteOK) <br>         { <br>         FileSeekBegin (pLog-&gt;hFile, <br>                        lNextBlockOffset) ; <br>         // Fake file end until we really write the block <br>         pLogIndexBlock-&gt;iNumIndexes = 0 ; <br>         pLogIndexBlock-&gt;lNextBlockOffset = 0 ; <br>         WriteOK = FileWrite (pLog-&gt;hFile, <br>                              (LPSTR) pLogIndexBlock, <br>                              sizeof (LOGINDEXBLOCK)) ; <br>         if (WriteOK) <br>            { <br>            pLog-&gt;lIndexBlockOffset = lNextBlockOffset ; <br>            pLog-&gt;iIndex = 0 ; <br>            pLog-&gt;lFileSize += sizeof (LOGINDEXBLOCK) ; <br>            } <br>         } <br>      }  // if <br> <br>   //=============================// <br>   // Add Index Block Entry       // <br>   //=============================// <br> <br>   Index.uFlags = uFlags ; <br>   Index.SystemTime = *pSystemTime ; <br>   Index.lDataOffset = lDataOffset ; <br>   Index.iSystemsLogged = iSystemsLogged ; <br>     <br>   pLogIndexBlock-&gt;aIndexes [pLog-&gt;iIndex] = Index ; <br>   pLog-&gt;iIndex++ ; <br>   pLogIndexBlock-&gt;iNumIndexes++ ; <br> <br>   // write out the index block if the log interval if too large <br>   if (pLog-&gt;iIntervalMSecs &gt;= LARGE_INTERVAL * 1000 ) <br>      { <br>      LONG           lCurPosition ; <br>    <br>      // save the current file position <br>      lCurPosition = FileTell (pLog-&gt;hFile) ; <br> <br>      // flush the index block to the file <br>      LogWriteIndexBlock (pLog) ; <br> <br>      // restore previous file position since <br>      // LogWriteIndexBlock has messed it up <br>      FileSeekBegin (pLog-&gt;hFile, lCurPosition) ; <br>      } <br>   return (WriteOK) ; <br>   }  // LogWriteIndex <br> <br> <br> <br>BOOL LogWritePerfData (HWND hWnd, <br>                       PLOG pLog, <br>                       PPERFDATA pPerfData, <br>                       SYSTEMTIME *pSystemTime, <br>                       DWORD iNumSystems, <br>                       BOOL bWriteIndex) <br>   {  // LogWritePerfData <br>   LONG           lSize ; <br>   BOOL           WriteOK ; <br>   LONG           lCurPosition ; <br>    <br>   lSize = pPerfData-&gt;TotalByteLength ; <br> <br>   lCurPosition = FileTell (pLog-&gt;hFile) ; <br> <br>   //=============================// <br>   // Write Perf Data             // <br>   //=============================// <br> <br>   WriteOK = FileWrite (pLog-&gt;hFile, (LPSTR) pPerfData, lSize) ; <br>   if (WriteOK) <br>      { <br>      pLog-&gt;lFileSize += lSize ; <br> <br>      if (bWriteIndex) <br>         { <br>         WriteOK = LogWriteIndex (pLog, <br>                                  LogFileIndexData, <br>                                  pSystemTime, <br>                                  lCurPosition, <br>                                  iNumSystems) ; <br>         } <br>      } <br>   if ( !WriteOK ) <br>      { <br>      CloseLog (hWnd, pLog) ; <br>      PrepareMenu (GetMenu (hWndMain)) ; <br>      UpdateLogDisplay (hWnd) ;    <br>      DlgErrorBox (hWnd, ERR_LOG_FILE, pLog-&gt;szFilePath) ; <br>      } <br>   return (WriteOK) ; <br>   }  // LogWritePerfData <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void static OnSize (HWND hDlg, <br>                    int xWidth, <br>                    int yHeight) <br>/* <br>   Effect:        Perform any actions necessary when the log window (dialog) <br>                  is resized. In particular, move and resize some of the <br>                  dialogs controls. <br> <br>   Internals:     The rightmost control, the log status, contains one of <br>                  only several values. These values are all within  <br>                  xStatusWidth, computed at init time. Put this control <br>                  one scroll width away from the right edge at fixed <br>                  width. Move its associated text prompt with it. Then <br>                  use the remaining space for the filename control, which <br>                  can probably use it. <br> <br>   To Do:         Need to consider minimum first. <br>*/ <br>   {  // OnSize <br>   int            xStatusPos ; <br>   int            xStatusTextPos ; <br>   int            xNameWidth ; <br>   int            xMinWidth ; <br> <br>   //=============================// <br>   // Enough space for minimums?  // <br>   //=============================// <br> <br>   xMinWidth =  <br>      xScrollWidth +                         // margin before prompt <br>      DialogWidth (hDlg, IDD_LOGFILETEXT) +  // width of prompt <br>      xNameMinWidth +                        // width of name <br>      xScrollWidth + <br>      DialogWidth (hDlg, IDD_LOGSTATUSTEXT) + <br>      DialogWidth (hDlg, IDD_LOGSTATUS) +  <br>      xScrollWidth ; <br> <br> <br>   xStatusPos = xWidth - xStatusWidth - xScrollWidth ;    <br>   DialogMove (hDlg, IDD_LOGSTATUS, <br>               xStatusPos, NOCHANGE, <br>               xStatusWidth, NOCHANGE) ; <br> <br>   xStatusTextPos = xStatusPos -  <br>                    DialogWidth (hDlg, IDD_LOGSTATUSTEXT) -  <br>                    xScrollWidth ; <br>   DialogMove (hDlg, IDD_LOGSTATUSTEXT,  <br>               xStatusTextPos, NOCHANGE, <br>               NOCHANGE, NOCHANGE) ; <br> <br>   xNameWidth = xStatusTextPos -  <br>                DialogWidth (hDlg, IDD_LOGFILETEXT) - <br>                2 * xScrollWidth ; <br>   DialogMove (hDlg, IDD_LOGFILE, <br>               NOCHANGE, NOCHANGE, <br>               xNameWidth, NOCHANGE) ; <br> <br>   DialogMove (hDlg, IDD_LOGSIZE, <br>               DialogXPos (hDlg, IDD_LOGFILE), NOCHANGE, <br>               DialogWidth (hDlg, IDD_LOGFILE), NOCHANGE) ; <br> <br>   DialogMove (hDlg, IDD_LOGINTERVALTEXT, <br>               DialogXPos (hDlg, IDD_LOGSTATUSTEXT), NOCHANGE, <br>               DialogWidth (hDlg, IDD_LOGSTATUSTEXT), NOCHANGE) ; <br> <br>   DialogMove (hDlg, IDD_LOGINTERVAL, <br>               DialogXPos (hDlg, IDD_LOGSTATUS), NOCHANGE, <br>               DialogWidth (hDlg, IDD_LOGSTATUS), NOCHANGE) ; <br> <br>   DialogMove (hDlg, IDD_LOGENTRIESTEXT, <br>               xScrollWidth, NOCHANGE, NOCHANGE, NOCHANGE) ; <br> <br>   DialogMove (hDlg, IDD_LOGENTRIES,  <br>               xScrollWidth, NOCHANGE, <br>               xWidth - 2 * xScrollWidth, <br>               yHeight - DialogYPos (hDlg, IDD_LOGENTRIES) - yScrollHeight) ; <br>   WindowInvalidate (hDlg) ; <br>   }  // OnSize <br> <br> <br>int OnCtlColor (HWND hDlg, <br>                       HDC hDC) <br>   { <br>   SetTextColor (hDC, crBlack) ; <br>   SetBkColor (hDC, crLightGray) ; <br>   return ((int) hbLightGray) ; <br>   } <br> <br> <br>void static OnInitDialog (HWND hDlg) <br>   { <br>   HDC            hDC ; <br>   PLOG           pLog ; <br> <br>   hWndLogEntries = DialogControl (hDlg, IDD_LOGENTRIES) ; <br> <br>   pLog = AllocateLogData (hDlg) ; <br>   if (!pLog) <br>      return ; <br> <br>   StringLoad (IDS_CLOSED, szClosed) ; <br>//   StringLoad (IDS_PAUSED, szPaused) ; <br>   StringLoad (IDS_COLLECTING, szCollecting) ; <br>   UpdateLogDisplay (hDlg) ; <br> <br>   hDC = GetDC (hDlg) ; <br>   xStatusWidth = max (TextWidth (hDC, szClosed),  <br>                       TextWidth (hDC, szCollecting)) ; <br>//                       max (TextWidth (hDC, szPaused), <br>//                            TextWidth (hDC, szCollecting))) ; <br>   xStatusWidth += xScrollWidth ; <br> <br>   xNameMinWidth = TextAvgWidth (hDC, LogNameMinLen) ; <br>   ReleaseDC (hDlg, hDC) ; <br>   } <br> <br> <br> <br>void static OnDestroy (HWND hWnd) <br>/* <br>   Effect:        Perform any actions necessary when a LogDisplay window <br>                  is being destroyed. In particular, free the instance <br>                  data for the log.   <br> <br>                  Since we really only have one log window and one global <br>                  log data structure, we don't free the structure. We do, <br>                  however, delete the objects allocated within the structure. <br>*/ <br>   {  // OnDestroy <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hWnd) ; <br>   FreeLogData (pLog) ; <br>   }  // OnDestroy <br> <br> <br>void static OnDrawItem (HWND hWnd, LPDRAWITEMSTRUCT lpDI) <br>   {  // OnDrawItem <br>   HDC            hDC ; <br>   RECT           rectComputer, rectObject ; <br>   PLOGENTRY      pLogEntry ; <br>   PLOG           pLog ; <br>   COLORREF       preBkColor ; <br>   COLORREF       preTextColor ; <br> <br>   pLog = LogData (hWnd) ; <br> <br>   pLogEntry = LogEntryN (hWndLogEntries, DIIndex (lpDI)) ; <br> <br>   // LogEntryN (SendMessage) will return LB_ERR for error, have to <br>   // check for that case <br>   if (!pLogEntry || pLogEntry == (PLOGENTRY)LB_ERR) <br>      { <br>      return ; <br>      } <br> <br>   hDC = lpDI-&gt;hDC ; <br> <br>   SelectFont (hDC, hFontScales) ; <br> <br>   if (DISelected (lpDI))  <br>      {  // if <br>      preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ; <br>      preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ; <br>      }  // if <br> <br>   rectObject.left = lpDI-&gt;rcItem.left ; <br>   rectObject.top = lpDI-&gt;rcItem.top ; <br>   rectObject.right = rectObject.left + pLog-&gt;xCol1Width ; <br>   rectObject.bottom = lpDI-&gt;rcItem.bottom ; <br> <br>   ExtTextOut (hDC,   <br>               rectObject.left + xScrollWidth, rectObject.top,    <br>               ETO_OPAQUE, <br>               &amp;rectObject, <br>               pLogEntry-&gt;szObject, <br>               lstrlen (pLogEntry-&gt;szObject), <br>               NULL) ; <br> <br> <br>   rectComputer.left = rectObject.right ; <br>   rectComputer.top = lpDI-&gt;rcItem.top ; <br>   rectComputer.right = lpDI-&gt;rcItem.right ; <br>   rectComputer.bottom = lpDI-&gt;rcItem.bottom ; <br> <br>   ExtTextOut (hDC,   <br>               rectComputer.left, rectComputer.top, <br>               ETO_OPAQUE, <br>               &amp;rectComputer, <br>               pLogEntry-&gt;szComputer, <br>               lstrlen (pLogEntry-&gt;szComputer), <br>               NULL) ; <br> <br>   if (DIFocus (lpDI)) <br>      DrawFocusRect (hDC, &amp;(lpDI-&gt;rcItem)) ; <br> <br>   if (DISelected (lpDI)) <br>      {  // if <br>      preTextColor = SetTextColor (hDC, preTextColor) ; <br>      preBkColor = SetBkColor (hDC, preBkColor) ; <br>      }  // if <br>//   RestoreDC (hDC, -1) ; <br>   }  // OnDrawItem <br> <br> <br>    <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>int APIENTRY LogDisplayDlgProc (HWND hDlg, <br>                                unsigned iMessage, <br>                                WPARAM wParam, <br>                                LONG lParam) <br>/* <br>   Note:          This function must be exported in the application's <br>                  linker-definition file, perfmon.def. <br>*/ <br>   {  // LogDisplayDlgProc <br>//   HDC            hDC ; <br> <br>   switch (iMessage) <br>      { <br>      case WM_INITDIALOG: <br>         OnInitDialog (hDlg) ; <br>         break ; <br> <br>      case WM_CTLCOLORDLG: <br>      case WM_CTLCOLOREDIT: <br>      case WM_CTLCOLORBTN: <br>      case WM_CTLCOLORSTATIC: <br>         return (OnCtlColor (hDlg, (HDC) wParam)) ; <br>         break ; <br> <br>      case WM_DRAWITEM: <br>         OnDrawItem (hDlg, (LPDRAWITEMSTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_LBUTTONDBLCLK: <br>         SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ; <br>         break ; <br> <br>      case WM_LBUTTONDOWN: <br>         DoWindowDrag (hDlg, lParam) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hDlg, LOWORD (lParam), HIWORD (lParam)) ; <br>         break ; <br> <br>      case WM_TIMER: <br>         LogTimer (hDlg, FALSE) ; <br>         break ; <br> <br>      case WM_SETFOCUS: <br>         SetFocus (hWndLogEntries) ; <br>         break ; <br> <br>      case WM_START_LOGGING: <br>         { <br>         PLOG        pLog ; <br> <br>         pLog = LogData (hDlg) ; <br>         if (StartLog (hDlg, pLog, FALSE)) <br>            { <br>            UpdateLogDisplay (hDlg) ; <br>            PrepareMenu (GetMenu (hWndMain)) ; <br>            } <br>         } <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hDlg) ; <br>         return (FALSE) ; <br>         break ; <br> <br>      default: <br>         return (FALSE) ; <br>      } // switch <br> <br>   return (TRUE) ; <br>   }  // LogDisplayDlgProc <br> <br> <br>#if 0 <br>PLOG LogData (HWND hWndLog) <br>   { <br>   return (&amp;Log) ; <br>   } <br>#endif <br> <br>HWND CreateLogWindow (HWND hWndParent) <br>/* <br>   Effect:        Create the Log window. This window is a child of  <br>                  hWndMain. <br> <br>   Note:          We dont worry about the size here, as this window <br>                  will be resized whenever the main window is resized. <br> <br>*/ <br>   {  // CreateLogWindow <br>   HWND           hWnd ; <br>   hWnd = CreateDialog (hInstance, <br>                        MAKEINTRESOURCE (idDlgLogDisplay), <br>                        hWndParent, <br>                        (DLGPROC) LogDisplayDlgProc) ; </code></pre>
<p>
</p>
<pre><code><br>   return (hWnd) ; <br>   }  // CreateLogWindow <br> <br> <br> <br>void UpdateLogDisplay (HWND hWnd) <br>/* <br>   Effect:        Set the values for the various controls in the log <br>                  display. <br> <br>   Called By:     OnInitDialog, any other routines that change these <br>                  values. <br>*/ <br>   {  // UpdateLogDisplay <br>   PLOG           pLog ; <br>   WCHAR          szSize [MiscTextLen + 1] ; <br> <br>   pLog = LogData (hWnd) ; <br> <br>   DialogSetString (hWnd, IDD_LOGFILE, pLog-&gt;szFilePath) ; <br> <br>   // position the cursor at the end of the text <br>   EditSetTextEndPos (hWnd, IDD_LOGFILE) ; <br> <br> <br>   DialogSetString (hWnd, IDD_LOGSTATUS, StatusText (pLog-&gt;iStatus)) ; <br> <br>   LongToCommaString (pLog-&gt;lFileSize, szSize) ; <br>   DialogSetString (hWnd, IDD_LOGSIZE, szSize) ; <br> <br>   DialogSetInterval (hWnd, IDD_LOGINTERVAL, pLog-&gt;iIntervalMSecs) ; <br>   }  // UpdateLogDisplay <br> <br> <br>BOOL LogInitializeApplication (void) <br>   { <br>   return (TRUE) ; <br>   }  // LogInitializeApplication <br> <br> <br>void SetLogTimer (HWND hWnd, <br>                  int iIntervalMSecs) <br>   { <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hWnd) ; <br>   pLog-&gt;iIntervalMSecs = iIntervalMSecs ; <br> <br>   KillTimer (hWnd, LogTimerID) ; <br>   SetTimer (hWnd, LogTimerID, pLog-&gt;iIntervalMSecs, NULL) ; <br>   } <br> <br> <br>void ClearLogTimer (HWND hWnd) <br>   { <br>   KillTimer (hWnd, LogTimerID) ; <br>   } <br> <br> <br> <br>BOOL CloseLogStopTimer (HWND hWnd, PLOG pLog) <br>   { <br>   CloseHandle (pLog-&gt;hFile) ; <br> <br>   pLog-&gt;hFile = 0 ; <br>   pLog-&gt;iStatus = iPMStatusClosed ; <br> <br>   ClearLogTimer (hWnd) ; <br> <br>   return (TRUE) ; <br>   } <br> <br> <br>BOOL CloseLog (HWND hWnd, PLOG pLog) <br>   {  // CloseLog <br>   LogWriteIndexBlock (pLog) ; <br>   CloseLogStopTimer (hWnd, pLog) ; <br>   WindowInvalidate (hWndStatus) ; <br>   return (TRUE) ; <br>   } // CloseLog <br> <br>BOOL StartLog (HWND hWnd, PLOG pLog, BOOL bSameFile) <br>   { <br>   int            RetCode ; <br>   SYSTEMTIME     SystemTime ;  <br> <br>   if ((RetCode = CreateLogFile (pLog, TRUE, bSameFile)) == 0) <br>      { <br>      pLog-&gt;iStatus = iPMStatusCollecting ; <br> <br>      GetLocalTime (&amp;SystemTime) ; <br> <br>      // write a dummy record. <br>      // this is needed because when playingback log <br>      // it will skip the first index from the first <br>      // index block. <br>      LogWriteIndex (pLog, 0, &amp;SystemTime, 0, 0) ; <br> <br>      if (!PlayingBackLog()) <br>         { <br>         // write out a bookmark to indicate start of new data <br>         if (!LogWriteStartBookmark (hWnd, &amp;SystemTime)) <br>            { <br>            RetCode = 0 ; <br>            goto ErrorExit ; <br>            } <br>          <br>         if (!(pLog-&gt;bManualRefresh)) <br>            { <br>            SetLogTimer (hWnd, pLog-&gt;iIntervalMSecs) ; <br>            WindowInvalidate (hWndStatus) ; <br>            } <br>         } <br>      else <br>         { <br>         // check if time if OK <br>         LOGPOSITION    LP ; <br>         SYSTEMTIME     FirstSystemTime ; <br>         int            TimeDiff ; <br> <br>         LP = PlaybackLog.StartIndexPos ; <br> <br>         if (LogPositionSystemTime (&amp;LP, &amp;FirstSystemTime)) <br>            { <br>            // we don't want to append data to the log file if <br>            // the time is not in order.  So, forget it if the <br>            // last log time in the Log file is greater than the First <br>            // log time of the playback log file. <br>            TimeDiff = SystemTimeDifference (&amp;(FirstSystemTime), <br>                                             &amp;(pLog-&gt;LastLogTime)) ; <br>            if (TimeDiff &gt; 0) <br>               { <br>               // error , time not in order <br>               CloseHandle (pLog-&gt;hFile) ; <br>               RetCode = ERR_CANT_RELOG_DATA ; <br>               } <br>            } <br>         } <br>       <br>      if (RetCode == 0) <br>         { <br>         // write counter names if needed <br>         LogWriteSystemCounterNames (hWnd, pLog) ; <br>         return (TRUE) ; <br>         } <br>      } <br> <br>ErrorExit: <br>   pLog-&gt;hFile = 0 ; <br>   CloseLogStopTimer(hWnd, pLog); <br>   PrepareMenu (GetMenu (hWndMain)) ; <br>   UpdateLogDisplay (hWnd) ; <br>   if (RetCode) <br>      { <br>      DlgErrorBox (hWnd, RetCode, pLog-&gt;szFilePath); <br>      } <br>   return (FALSE) ; <br>   } <br> <br> <br> <br>DWORD LogFindEntry(LPTSTR lpszComputer, DWORD ObjectTitleIndex) <br>/* <br>   Effect:         Returns the index of the specified Computer/Object <br>                   if it already exists in the Entries List Box, <br>                   otherwise returns LOG_ENTRY_NOT_FOUND <br>*/ <br>   { <br>   DWORD          iLogEntry ; <br>   DWORD          iLogNum ; <br>   PLOGENTRY      pLogEntry ; <br> <br>   iLogNum = (DWORD) LBNumItems(hWndLogEntries) ; <br>   for (iLogEntry = 0; <br>        iLogEntry &lt; iLogNum ; <br>        iLogEntry++) <br>      { <br>      pLogEntry = (PLOGENTRY) LBData(hWndLogEntries, iLogEntry) ; <br>      if (pLogEntry-&gt;ObjectTitleIndex == ObjectTitleIndex &amp;&amp; <br>          strsamei(pLogEntry-&gt;szComputer, lpszComputer)) <br>         { <br>         return iLogEntry ; <br>         } <br>      } <br>   return (DWORD) LOG_ENTRY_NOT_FOUND; <br>   } <br> <br> <br> <br>BOOL LogAddEntry (HWND hWndLog, <br>                  LPTSTR lpszComputer, <br>                  LPTSTR lpszObject, <br>                  DWORD ObjectTitleIndex, <br>                  BOOL  bGetObjectTitleIndex) <br>/* <br>   Effect:        Add an entry in the log structure for the computer and <br>                  object to be logged. <br> <br>   Returns:       Whether the operation could be performed. <br>*/ <br>   {  // LogAddEntry <br>   PLOG           pLog ; <br>   PLOGENTRY      pLogEntry ; <br>   UINT           iIndex ; <br>   PPERFSYSTEM    pCurrentSystem = NULL ; <br>   DWORD          CurrentObjectTitleIndex ; <br> <br> <br>   pLog = LogData (hWndLog) ; <br>    <br>   pCurrentSystem = SystemAdd (&amp;(pLog-&gt;pSystemFirst), lpszComputer) ; <br> <br>   pLogEntry = MemoryAllocate (sizeof (LOGENTRY)) ; <br>   if (!pLogEntry) <br>      return (FALSE) ; <br> <br>   lstrcpy (pLogEntry-&gt;szComputer, lpszComputer) ; <br>   lstrcpy (pLogEntry-&gt;szObject, lpszObject) ; <br> <br>   pLogEntry-&gt;ObjectTitleIndex = ObjectTitleIndex ; <br> <br>   // if reading from a log setting file, get the  <br>   // latest Object index by the perfdata itself. <br>   // There may be case that the id has been changed <br>   if (bGetObjectTitleIndex &amp;&amp; <br>      pCurrentSystem &amp;&amp; <br>      pCurrentSystem-&gt;pSystemPerfData) <br>      { <br>      if (pCurrentSystem-&gt;pSystemPerfData-&gt;Signature[0] == TEXT('\0')) <br>         { <br>         UpdateSystemData ( <br>            pCurrentSystem, <br>            &amp;(pCurrentSystem-&gt;pSystemPerfData)) ; <br>         } <br> <br>      if (CurrentObjectTitleIndex = GetObjectIdByName( <br>         pCurrentSystem, <br>         pCurrentSystem-&gt;pSystemPerfData, <br>         lpszObject)) <br>         { <br>         pLogEntry-&gt;ObjectTitleIndex = CurrentObjectTitleIndex ; <br>         } <br>      } <br> <br>   iIndex = LBAdd (hWndLogEntries, pLogEntry) ; <br> <br>   if (!bDelayAddAction) <br>      { <br>      if (iIndex == LB_ERR) <br>         { <br>         iIndex = 0 ; <br>         } <br> <br>      LBSetSelection (hWndLogEntries, iIndex) ; <br>      LBSetVisible (hWndLogEntries, iIndex) ; <br> <br>      LogEntriesChanged (hWndLogEntries) ; <br>      } <br> <br>   LogAddEntryToList (&amp;(pLog-&gt;pLogEntryFirst), pLogEntry) ; <br> <br> <br>   }  // LogAddEntry <br> <br> <br> <br> <br>BOOL ToggleLogRefresh (HWND hWnd) <br>   {  // ToggleLogRefresh <br>   PLOG        pLog ; <br> <br>   pLog = LogData (hWnd) ; <br> <br>   if (pLog-&gt;bManualRefresh) <br>      SetLogTimer (hWnd, pLog-&gt;iIntervalMSecs) ; <br>   else <br>      ClearLogTimer (hWnd) ; <br> <br>   pLog-&gt;bManualRefresh = !pLog-&gt;bManualRefresh ; <br>   return (pLog-&gt;bManualRefresh) ; <br>   }  // ToggleLogRefresh <br> <br>BOOL LogRefresh (HWND hWnd) <br>   {  // LogRefresh <br>   PLOG        pLog ; <br> <br>   pLog = LogData (hWnd) ; <br> <br>   return (pLog-&gt;bManualRefresh) ; <br>   }  // LogRefresh <br> <br>BOOL  CheckUnusedSystem (LPTSTR      lpszComputer) <br>{ <br>   BOOL  bStillUse = FALSE ; <br>   PLOGENTRY      pLogEntry ; <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   for (pLogEntry = pLog-&gt;pLogEntryFirst ; <br>        pLogEntry ; <br>        pLogEntry = pLogEntry-&gt;pNextLogEntry) <br>      { // for <br>      if (strsamei(pLogEntry-&gt;szComputer, lpszComputer)) <br>         { <br>         bStillUse = TRUE ; <br>         break ; <br>         } <br>      } <br>   return (bStillUse) ; <br>} <br> <br>int SelectLogObjects(LPTSTR      lpszComputer, <br>                     PPERFDATA   pPerfData, <br>                     PPERFDATA   *ppLogData) <br>/* <br>   Effect:        This routine copies the header from pPerfData <br>                  to pLogData and initializes the byte length and the <br>                  number of objects.  It then copies the previously <br>                  selected objects from pPerfData to pLogData.  If <br>                  pLogData must be enlarged to accomodate the new data, <br>                  this routine will enlarge it. <br> <br>   Returns:       An updated pLogData, and TRUE if at least one object <br>                  was copied. <br> <br>*/ <br> <br>   { <br>   PLOGENTRY      pLogEntry ; <br>   PPERF_OBJECT_TYPE <br>                  pObject ; <br>   DWORD          TotalBytes ; <br>   DWORD          NumObjects ; <br>   PBYTE          pNextObject ; <br>   DWORD          MaxLogDataSize ; <br>   PLOG           pLog ; <br> <br>   if (!*ppLogData || !pPerfData) <br>      return -1 ; <br> <br>   memcpy (*ppLogData, pPerfData, pPerfData-&gt;HeaderLength) ; <br>   TotalBytes = pPerfData-&gt;HeaderLength ; <br>   MaxLogDataSize = MemorySize(*ppLogData) ; <br>   NumObjects = 0; <br> <br>    <br>   pLog = LogData (hWndLog) ; <br> <br>   for (pLogEntry = pLog-&gt;pLogEntryFirst ; <br>        pLogEntry ; <br>        pLogEntry = pLogEntry-&gt;pNextLogEntry) <br>      { // for <br>      if (strsamei(pLogEntry-&gt;szComputer, lpszComputer)) <br>         { <br>         pObject = GetObjectDefByTitleIndex(pPerfData, <br>            pLogEntry-&gt;ObjectTitleIndex) ; <br> <br>         if (pObject) <br>            { <br>            if (MaxLogDataSize &lt; TotalBytes + pObject-&gt;TotalByteLength) <br>               { <br>               *ppLogData = MemoryResize(*ppLogData, <br>                                         TotalBytes + pObject-&gt;TotalByteLength) ; <br>               if (!*ppLogData) <br>                  return -1 ; <br> <br>               } <br> <br>            pNextObject = (PBYTE) *ppLogData + TotalBytes ; <br>            memcpy (pNextObject, pObject, pObject-&gt;TotalByteLength); <br>            TotalBytes += pObject-&gt;TotalByteLength ; <br>            NumObjects++; <br>            } <br>         else <br>            { <br>            } <br>         } <br>      } // for <br> <br>   if (!NumObjects) <br>      return 1 ; <br> <br>   (*ppLogData)-&gt;TotalByteLength = TotalBytes ; <br>   (*ppLogData)-&gt;NumObjectTypes = NumObjects ; <br> <br>   return 0 ; <br>   } <br> <br> <br>void LogTimer (HWND hWnd, BOOL bForce) <br>/* <br>   Effect:        Perform all actions necessary when the log window  <br>                  receives a timer tic. In particular, if we are <br>                  collecting data, get a new perf_data_block and add a  <br>                  header entry. If the header block is full, write the <br>                  data to disk. <br> <br>   Called By:     LogDisplayDlgProc, in response to a WM_TIMER message. <br>*/ <br>   {  // OnTimer <br>   PLOG           pLog ; <br>   PPERFSYSTEM       pSystem ; <br>   BOOL           bWriteIndex ; <br>   DWORD          iNumSystems ; <br>   SYSTEMTIME     SystemTime ; <br>   int            iNoUseSystemDetected = 0 ; <br> <br>   int               NumberOfSystems = 0 ; <br>   DWORD             WaitStatus ; <br>   BOOL              bNeedToStoreName = FALSE ; <br>   HANDLE            *lpPacketHandles ; <br> <br> <br>   pLog = LogData (hWnd) ; <br> <br>   if (pLog-&gt;iStatus != iPMStatusCollecting) <br>      return ; <br> <br>   if (bForce || !pLog-&gt;bManualRefresh)  <br>      { <br>      if (pLog-&gt;NumberOfHandles == 0) <br>         { <br>         pLog-&gt;NumberOfHandles = MAXIMUM_WAIT_OBJECTS ; <br>         pLog-&gt;lpHandles = (HANDLE *) MemoryAllocate (pLog-&gt;NumberOfHandles * sizeof (HANDLE)) ; <br>         if (!pLog-&gt;lpHandles) <br>            { <br>            // out of memory, can't go on <br>            pLog-&gt;NumberOfHandles = 0 ; <br>            return ; <br>            } <br>         } <br> <br>      iNumSystems = SystemCount(pLog-&gt;pSystemFirst) ; <br>      bWriteIndex = TRUE ; <br> <br>      for (pSystem = pLog-&gt;pSystemFirst ; <br>           pSystem ; <br>           pSystem = pSystem-&gt;pSystemNext) <br>         {  // for <br>       <br>         if (pSystem-&gt;hStateDataMutex == 0) <br>            continue ; <br> <br>         // lock the state data mutex <br>         WaitStatus = WaitForSingleObject(pSystem-&gt;hStateDataMutex, 100L); <br>         if (WaitStatus == WAIT_OBJECT_0) <br>            { <br>            ResetEvent (pSystem-&gt;hPerfDataEvent) ; <br>            pSystem-&gt;StateData = WAIT_FOR_PERF_DATA ; <br> <br>            if (NumberOfSystems &gt;= pLog-&gt;NumberOfHandles) <br>               { <br>               pLog-&gt;NumberOfHandles += MAXIMUM_WAIT_OBJECTS ; <br>               pLog-&gt;lpHandles = (HANDLE *) MemoryResize ( <br>                  pLog-&gt;lpHandles, <br>                  pLog-&gt;NumberOfHandles * sizeof (HANDLE)) ; <br>               if (!pLog-&gt;lpHandles) <br>                  { <br>                  // out of memory, can't go on <br>                  pLog-&gt;NumberOfHandles = 0 ; <br>                  return ; <br>                  } <br>               } <br> <br>            // add this to the wait <br>            pLog-&gt;lpHandles [NumberOfSystems] = pSystem-&gt;hPerfDataEvent ; <br>            NumberOfSystems++ ; <br>            } <br> <br>         // Send Message to thread to take a data sample <br>         PostThreadMessage ( <br>            pSystem-&gt;dwThreadID, <br>            WM_GET_PERF_DATA, <br>            (WPARAM)0, <br>            (LPARAM)0) ; <br> <br>         ReleaseMutex(pSystem-&gt;hStateDataMutex); <br>         }  // for each system <br> <br>      // wait for all the data  <br>      if (NumberOfSystems) <br>         { <br>         // increase timeout if we are monitoring lots of systems <br>         // For every additional 5 systems, add five more seconds <br>         lpPacketHandles = pLog-&gt;lpHandles ; <br>         do <br>            { <br>            WaitStatus = WaitForMultipleObjects ( <br>               min (NumberOfSystems, MAXIMUM_WAIT_OBJECTS), <br>               lpPacketHandles, <br>               TRUE,       // wait for all objects <br>               DataTimeOut + (NumberOfSystems / 5) * DEFAULT_DATA_TIMEOUT); <br>          <br>            if (WaitStatus == WAIT_TIMEOUT || <br>               NumberOfSystems &lt;= MAXIMUM_WAIT_OBJECTS) <br>               { <br>//if (WaitStatus == WAIT_TIMEOUT) <br>//mike2(TEXT("WaitTimeOut for %ld systems\n"), NumberOfSystems) ; <br>               break ; <br>               } <br> <br>            // more systems --&gt; more to wait <br>            NumberOfSystems -= MAXIMUM_WAIT_OBJECTS ; <br>            lpPacketHandles += MAXIMUM_WAIT_OBJECTS ; <br>            } while (TRUE) ; <br> <br> <br>         for (pSystem = pLog-&gt;pSystemFirst ; <br>              pSystem ; <br>              pSystem = pSystem-&gt;pSystemNext) <br>            {  // for <br>       <br>            if (pSystem-&gt;hStateDataMutex == 0) <br>               continue ; <br> <br>            // lock the state data mutex <br>            WaitStatus = WaitForSingleObject(pSystem-&gt;hStateDataMutex, 100L); <br>            if (WaitStatus == WAIT_OBJECT_0) <br>               { <br>               // check for system disconnect/reconnect <br>               if (pSystem-&gt;dwSystemState == SYSTEM_DOWN || <br>                   pSystem-&gt;dwSystemState == SYSTEM_RECONNECT) <br>                  { <br>                  BOOL  bDisconnected ; <br> <br>                  GetLocalTime (&amp;SystemTime) ; <br>                  if (bDisconnected = (pSystem-&gt;dwSystemState == SYSTEM_DOWN)) <br>                     { <br>                     pSystem-&gt;dwSystemState = SYSTEM_DOWN_RPT ; <br>                     } <br>                  else <br>                     { <br>                     pSystem-&gt;dwSystemState = SYSTEM_RECONNECT_RPT ; <br>                     } <br>                  if (!LogWriteSystemBookmark ( <br>                     hWnd, <br>                     pSystem-&gt;sysName, <br>                     bDisconnected, <br>                     &amp;SystemTime)) <br>                     { <br>                     pSystem-&gt;StateData = IDLE_STATE ; <br>                     ReleaseMutex(pSystem-&gt;hStateDataMutex); <br>                     return ; <br>                     } <br>                  } <br> <br>               if (pSystem-&gt;StateData == PERF_DATA_READY) <br>                  { <br>                  if (pSystem-&gt;bSystemCounterNameSaved == FALSE) <br>                     { <br>                     // we have not written the system name to log file.  This <br>                     // is the case when this system is down when we first <br>                     // start logging data... <br>                     bNeedToStoreName = TRUE ; <br>                     } <br> <br>                  if (bWriteIndex) <br>                     { <br>                     GetLocalTime (&amp;SystemTime) ; <br>                     } <br> <br>                  if (SelectLogObjects(pSystem-&gt;sysName, <br>                     pSystem-&gt;pSystemPerfData, <br>                     &amp;pLog-&gt;pLogData) == 0) <br>                     { <br>                     if ( !LogWritePerfData (hWnd, pLog, pLog-&gt;pLogData, &amp;SystemTime, <br>                        iNumSystems, bWriteIndex) ) <br>                        { <br>                        CloseLogStopTimer(hWnd, pLog) ; <br> <br>                        pSystem-&gt;StateData = IDLE_STATE ; <br>                        ReleaseMutex(pSystem-&gt;hStateDataMutex); <br> <br>                        return ; <br>                        } <br>                     // write an index for only the first system <br>                     bWriteIndex = FALSE ; <br>                     } <br>                  else <br>                     { <br>                     if (!bAddLineInProgress) <br>                        { <br>                        pSystem-&gt;bSystemNoLongerNeeded = TRUE ; <br>                        iNoUseSystemDetected ++ ; <br>                        } <br>                     } <br>                  }  // if PERF_DATA_READY <br>               else if (!bAddLineInProgress &amp;&amp; <br>                  CheckUnusedSystem (pSystem-&gt;sysName) == FALSE) <br>                  { <br>                  // we don't need this system any more <br>                  pSystem-&gt;bSystemNoLongerNeeded = TRUE ; <br>                  iNoUseSystemDetected ++ ; <br>                  } <br> <br>               pSystem-&gt;StateData = IDLE_STATE ; <br>               ReleaseMutex(pSystem-&gt;hStateDataMutex); <br>               }  // wait for StateDataMutex <br>            }  // For each system <br>         }  // if NumberOfSystems <br> <br>      if (!bWriteIndex) <br>         { <br>         UpdateLogSize (hWnd) ; <br>         } <br>      }  // if <br> <br>   if (iNoUseSystemDetected) <br>      { <br>      DeleteUnusedSystems (&amp;(pLog-&gt;pSystemFirst), iNoUseSystemDetected) ; <br>      } <br> <br>   if (bNeedToStoreName == TRUE) <br>      { <br>      LogWriteSystemCounterNames (hWnd, pLog) ; <br>      } <br>   }  // LogTimer <br> <br> <br> <br>BOOL NextIntervalIndexPosition (PLOG pLog, PLOGPOSITION pLP, int *pNumTics) <br>   {  <br>   SYSTEMTIME     SystemTime1 ; <br>   SYSTEMTIME     SystemTime2 ; <br>   LOGPOSITION    LP ; <br>   PLOGINDEX      pIndex ; <br>   DWORD          TimeDiff ; <br> <br>   LogPositionSystemTime (pLP, &amp;SystemTime1) ; <br> <br>   LP = *pLP ; <br> <br>   while (NextReLogIndexPosition (&amp;LP)) <br>      {  // while <br> <br>      *pNumTics = *pNumTics - 1 ; <br> <br>      pIndex = IndexFromPosition (&amp;LP) ; <br>      if (pIndex &amp;&amp; IsBookmarkIndex (pIndex)) <br>         { <br>         *pLP = LP ; <br>         return TRUE ; <br>         } <br>      LogPositionSystemTime (&amp;LP, &amp;SystemTime2) ; <br>      TimeDiff = (DWORD) SystemTimeDifference (&amp;SystemTime1, &amp;SystemTime2) ; <br>      if (TimeDiff * 1000 &gt;= pLog-&gt;iIntervalMSecs) <br>         {  // if <br>         *pLP = LP ; <br>         return (TRUE) ; <br>         }  // if <br>      }  // while <br> <br>   return (FALSE) ; <br>   }  // NextIntervalIndexPosition <br> <br> <br> <br>BOOL ReLogTimer (HWND hWnd, <br>                 PLOG pLog, <br>                 LOGPOSITION lp, <br>                 BOOL *pWriteBookmark) <br>   {  // ReLogTimer <br>   PPERFSYSTEM    pSystem ; <br>   BOOL           bWriteIndex ; <br>   DWORD          iNumSystems ; <br>   SYSTEMTIME     SystemTime ; <br>   PPERFDATA      pPerfData ; <br> <br>   bWriteIndex = TRUE ; <br> <br>   // First count number of systems to be logged <br> <br>   iNumSystems = 0; <br> <br>   for (pSystem = pLog-&gt;pSystemFirst ; <br>        pSystem ; <br>        pSystem = pSystem-&gt;pSystemNext) <br>      {  // for <br>      pPerfData = LogDataFromPosition (pSystem, &amp;lp) ; <br>      if (pPerfData) <br>         { <br>         if (SelectLogObjects(pSystem-&gt;sysName, <br>                              pPerfData, <br>                              &amp;pLog-&gt;pLogData) == 0) <br>            { <br>            iNumSystems++; <br>            } <br>         } <br>      }  // for <br> <br>   // Now we can log the data <br> <br>   for (pSystem = pLog-&gt;pSystemFirst ; <br>        pSystem ; <br>        pSystem = pSystem-&gt;pSystemNext) <br>      {  // for <br>      pPerfData = LogDataFromPosition (pSystem, &amp;lp) ; <br>      if (pPerfData) <br>         { <br>         // write an index for only the first system <br>         LogPositionSystemTime (&amp;lp, &amp;SystemTime) ; <br>         if (SelectLogObjects(pSystem-&gt;sysName, <br>                              pPerfData, <br>                              &amp;pLog-&gt;pLogData) == 0) <br>            { <br>            if (*pWriteBookmark) <br>               { <br>               // only need to write the start bookmark once. <br>               *pWriteBookmark = FALSE ; <br>               LogWriteStartBookmark (hWnd, &amp;SystemTime) ; <br>               } <br>            if ( !LogWritePerfData (hWnd, pLog, pLog-&gt;pLogData, &amp;SystemTime, <br>                                    iNumSystems, bWriteIndex) ) <br>               { <br>               CloseLogStopTimer(hWnd, pLog) ; <br>               return FALSE ; <br>               } <br>            else <br>               { <br>               // write the index for only the first system logged <br>               bWriteIndex = FALSE ; <br>               } <br>            } <br>         } <br>      }  // for <br> <br>   return TRUE ; <br>   }  // ReLogTimer <br> <br> <br>void ReLog (HWND hWndLog, BOOL bSameFile) <br>   {  // PlaybackLog <br>   PLOG           pLog ; <br>   LOGPOSITION    lp ; <br>//   SYSTEMTIME     SystemTime ; <br>   PLOGINDEX      pIndex ; <br>   PBOOKMARK      pBookmark; <br>   int            iDisplayTics ; <br> <br>   // bWriteBookmark tell relogtimer to write start bookmark <br>   BOOL           bWriteBookmark = TRUE ;     <br> <br>   pLog = LogData (hWndLog) ; <br>   if (StartLog (hWndLog, pLog, bSameFile) == FALSE) <br>      { <br>      return ; <br>      } <br> <br>   lp = PlaybackLog.StartIndexPos ; <br>   iDisplayTics = PlaybackLog.iSelectedTics; <br> <br>   while (iDisplayTics &gt; 0) <br>      { <br>      pIndex = IndexFromPosition (&amp;lp) ; <br>      if (pIndex) <br>         { <br>         if (IsBookmarkIndex (pIndex)) <br>            { <br>            pBookmark = (PBOOKMARK) PlaybackSeek (pIndex-&gt;lDataOffset) ; <br>            if (!LogWriteBookmarkData (hWndLog, pBookmark)) <br>               break; <br>            } <br>         else if (!ReLogTimer (hWndLog, pLog, lp, &amp;bWriteBookmark)) <br>            break ; <br>         } <br>       <br>      if (!NextIntervalIndexPosition (pLog, &amp;lp, &amp;iDisplayTics)) <br>         break ; <br>       <br>      }  // while <br>   UpdateLogSize (hWndLog) ; <br>   CloseLog (hWndLog, pLog) ; <br>   }  // ReLog <br> <br>// SaveLog is diff than other because we are not saving a "Line" <br>// We are actually saving an entry in the hWndLogEntries listbox. <br>// It only contains the system &amp; object name. <br>BOOL SaveLog (HWND hWndLog, HANDLE hInputFile, BOOL bGetFileName) <br>   { <br>   int         iIndex, iIndexNum ; <br>   PLOG        pLog ; <br>   PLOGENTRY   pLogEntry ; <br>   LOGENTRY       tempLogEntry ; <br>   HANDLE         hFile ; <br>   DISKLOG        DiskLog ; <br>   PERFFILEHEADER FileHeader ; <br>   TCHAR          szFileName [256] ; <br>   BOOL           newFileName = FALSE ; <br> <br>   pLog = LogData (hWndLog) ; <br>   if (!pLog) <br>      { <br>      return (FALSE) ; <br>      } <br> <br>   if (hInputFile) <br>      { <br>      // use the input file handle if it is available <br>      // this is the case for saving workspace data <br>      hFile = hInputFile ; <br>      } <br>   else <br>      { <br>      if (pLogFullFileName) <br>         { <br>         lstrcpy (szFileName, pLogFullFileName) ; <br>         } <br>      if (bGetFileName || pLogFullFileName == NULL) <br>         { <br>//         if (pLogFullFileName == NULL) <br>//            { <br>//            StringLoad (IDS_LOG_FNAME, szFileName) ; <br>//            } <br> <br>         if (!FileGetName (hWndLog, IDS_LOGFILE, szFileName)) <br>            { <br>            return (FALSE) ; <br>            } <br>         newFileName = TRUE ; <br>         } <br> <br>      hFile = FileHandleCreate (szFileName) ; <br> <br>      if (hFile &amp;&amp; newFileName) <br>         { <br>         ChangeSaveFileName (szFileName, IDM_VIEWLOG) ; <br>         } <br>      else if (!hFile) <br>         { <br>         DlgErrorBox (hWndLog, ERR_CANT_OPEN, szFileName) ; <br>         } <br>      } <br> <br>   if (!hFile) <br>      return (FALSE) ; <br> <br>   iIndexNum = LBNumItems (hWndLogEntries) ; <br> <br>   if (!hInputFile) <br>      { <br>      memset (&amp;FileHeader, 0, sizeof (FileHeader)) ; <br>      lstrcpy (FileHeader.szSignature, szPerfLogSignature) ; <br>      FileHeader.dwMajorVersion = LogMajorVersion ; <br>      FileHeader.dwMinorVersion = LogMinorVersion ; <br>    <br>      if (!FileWrite (hFile, &amp;FileHeader, sizeof (PERFFILEHEADER))) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   DiskLog.dwIntervalSecs = pLog-&gt;iIntervalMSecs ; <br>   DiskLog.dwNumLines = iIndexNum ; <br>   DiskLog.bManualRefresh = pLog-&gt;bManualRefresh ; <br>   DiskLog.perfmonOptions = Options ; <br>   lstrcpy(DiskLog.LogFileName, pLog-&gt;szFilePath) ; <br> <br>   if (!FileWrite (hFile, &amp;DiskLog, sizeof (DISKLOG))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   for (iIndex = 0 ; <br>        iIndex &lt; iIndexNum ; <br>        iIndex++) <br>      {  // for <br>      pLogEntry = LogEntryN (hWndLogEntries, iIndex) ; <br>      if (pstrsamei (pLogEntry-&gt;szComputer, LocalComputerName)) <br>         { <br>         tempLogEntry = *pLogEntry ; <br>         lstrcpy (tempLogEntry.szComputer, LOCAL_SYS_CODE_NAME) ; <br>         if (!FileWrite (hFile, <br>               &amp;tempLogEntry, <br>               sizeof(LOGENTRY)-sizeof(pLogEntry-&gt;pNextLogEntry))) <br>            { <br>            goto Exit0 ; <br>            } <br>         } <br>      else <br>         { <br>         if (!FileWrite (hFile, <br>               pLogEntry, <br>               sizeof(LOGENTRY)-sizeof(pLogEntry-&gt;pNextLogEntry))) <br>            { <br>            goto Exit0 ; <br>            } <br>         } <br>      }  // for <br> <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br> <br>      // only need to report error if not workspace  <br>      DlgErrorBox (hWndLog, ERR_SETTING_FILE, szFileName) ; <br>      } <br>   return (FALSE) ; <br>   } <br> <br>BOOL OpenLogVer1 (HWND hWndLog, HANDLE hFile, DISKLOG *pDiskLog, PLOG <br>   pLog, DWORD dwMinorVersion) <br>   { <br>   int            iIndex, iIndexNum ; <br>   PLOGENTRY      pLogEntry ; <br>   LOGENTRY       LogEntry ; <br>   PPERFSYSTEM    pSystem; <br> <br>   pLog-&gt;iIntervalMSecs = pDiskLog-&gt;dwIntervalSecs ; <br>   if (dwMinorVersion &lt; 3) <br>      { <br>      pLog-&gt;iIntervalMSecs *= 1000 ; <br>      } <br> <br>   pLog-&gt;lFileSize = 0L ; <br>   if (dwMinorVersion &gt;= 5) <br>      { <br>      lstrcpy (pLog-&gt;szFilePath, pDiskLog-&gt;LogFileName) ; <br>      } <br>   else <br>      { <br>      strclr (pLog-&gt;szFilePath) ; <br> <br>      // fixed the file pointer for backward compatible with older version. <br>//      FileSeekCurrent (hFile, -((int) (sizeof (pDiskLog-&gt;LogFileName)))) ; <br>      } <br> <br>   pLog-&gt;bManualRefresh = pDiskLog-&gt;bManualRefresh ; <br>   iIndexNum = pDiskLog-&gt;dwNumLines ; <br> <br>   LBSetRedraw (hWndLogEntries, FALSE) ; <br> <br>   bDelayAddAction = TRUE ; <br> <br>   for (iIndex = 0 ; iIndex &lt; iIndexNum ; iIndex++) <br>      { <br>      if (!FileRead (hFile, <br>            &amp;LogEntry, <br>            sizeof(LOGENTRY)-sizeof(LogEntry.pNextLogEntry))) <br>         { <br>         break ; <br>         } <br> <br>      if (pstrsame (LogEntry.szComputer, LOCAL_SYS_CODE_NAME)) <br>         { <br>         // convert it back to the local name <br>         lstrcpy (LogEntry.szComputer, LocalComputerName) ; <br>         } <br> <br>      LogAddEntry (hWndLog, <br>                  LogEntry.szComputer, <br>                  LogEntry.szObject, <br>                  LogEntry.ObjectTitleIndex, <br>                  TRUE) ; <br>      } <br>    <br>   bDelayAddAction = FALSE ; <br> <br>   LBSetSelection (hWndLogEntries, 0) ; <br>   LBSetVisible (hWndLogEntries, 0) ; <br> <br>   LogEntriesChanged (hWndLogEntries) ; <br> <br>   LBSetRedraw (hWndLogEntries, TRUE) ; <br> <br>   for (pSystem = pLog-&gt;pSystemFirst ; <br>      pSystem ; <br>      pSystem = pSystem-&gt;pSystemNext) <br>      { <br>      if (pSystem) <br>         { <br>         RemoveObjectsFromSystem (pSystem); <br>         } <br>      } <br> <br> <br>   for (iIndex = 0 ; <br>        iIndex &lt; iIndexNum ; <br>        iIndex++) <br>      {  // for all items in the list <br>      pLogEntry = LogEntryN (hWndLogEntries, iIndex) ; <br> <br>      pSystem = SystemGet (pLog-&gt;pSystemFirst, pLogEntry-&gt;szComputer); <br>      if (pSystem) <br>         { <br>         AppendObjectToValueList ( <br>                pLogEntry-&gt;ObjectTitleIndex, <br>                pSystem-&gt;lpszValue); <br>         }  <br>      }  // for <br> <br>   if (!strempty(pLog-&gt;szFilePath)) <br>      { <br>      if (pLog-&gt;pLogEntryFirst &amp;&amp; <br>          pLog-&gt;pSystemFirst) <br>         { <br>         // PostMessage so it will start logging <br>         PostMessage ( <br>            hWndLog, <br>            WM_START_LOGGING, <br>            0, <br>            0) ; <br>         } <br>      else <br>         { <br>         HANDLE   hLogFile ; <br> <br>         // get the file size. <br>         hLogFile = FileHandleOpen (pLog-&gt;szFilePath) ; <br> <br>         if (hLogFile &amp;&amp; hLogFile != INVALID_HANDLE_VALUE) <br>            { <br>            pLog-&gt;lFileSize = GetFileSize (hLogFile, NULL); </code></pre>
<p>
</p>
<pre><code>CloseHandle (hLogFile) ; <br>            } <br>         } <br>      } <br> <br>   return (TRUE) ; <br>   } <br> <br>BOOL OpenLog (HWND hWndLog, <br>              HANDLE hFile, <br>              DWORD dwMajorVersion, <br>              DWORD dwMinorVersion, <br>              BOOL bLogFile) <br>   { <br>   PLOG        pLog ; <br>   DISKLOG     DiskLog ; <br>   BOOL        bSuccess = TRUE ; <br> <br>   pLog = LogData (hWndLog) ; <br>   if (!pLog) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br>   if (!FileRead (hFile, &amp;DiskLog, sizeof (DISKLOG) - sizeof(DiskLog.LogFileName))) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br>   if (dwMajorVersion == 1 &amp;&amp; dwMinorVersion &gt;= 5 || <br>      dwMajorVersion &gt; 1) <br>      { <br>      // read LogFileName <br>      if (!FileRead (hFile, DiskLog.LogFileName, sizeof (DiskLog.LogFileName))) <br>         { <br>         bSuccess = FALSE ; <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   switch (dwMajorVersion) <br>      {   <br>      case (1): <br> <br>         SetHourglassCursor() ; <br>          <br>         ResetLogView (hWndLog) ; <br> <br>         OpenLogVer1 (hWndLog, hFile, &amp;DiskLog, pLog, dwMinorVersion) ; <br> <br>         // change to log view if we are opening a  <br>         // log file <br>         if (bLogFile &amp;&amp; iPerfmonView != IDM_VIEWLOG) <br>            { <br>            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWLOG, 0L) ; <br>            } <br>  <br>         if (iPerfmonView == IDM_VIEWLOG) <br>            { <br>            SetPerfmonOptions (&amp;DiskLog.perfmonOptions) ; <br>            } <br>          <br>         UpdateLogDisplay (hWndLog) ;    <br>          <br>         SetArrowCursor() ; <br>          <br>         break ; <br>      } <br> <br>Exit0: <br> <br>   if (bLogFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // OpenLog <br> <br> <br>BOOL LogCollecting (HWND hWndLog) <br>/* <br>   Effect:        Return whether the log associated with hWndLog is currently <br>                  collecting data (writing performance values to disk). <br>*/ <br>   {  // LogCollecting <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   return (pLog-&gt;iStatus == iPMStatusCollecting) ; <br>   }  // LogCollecting <br> <br> <br>int LogFileSize (HWND hWndLog) <br>   { <br>   PLOG           pLog ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   return (pLog-&gt;lFileSize) ; <br>   } <br> <br>BOOL LogWriteSystemBookmark ( <br>   HWND     hWnd, <br>   LPTSTR   lpSystemName, <br>   BOOL     bDisconnected, <br>   SYSTEMTIME *pSystemTime) <br>   { <br>   BOOKMARK       Bookmark ; <br>   TCHAR    NewSystemBookmark [MiscTextLen * 2] ; <br> <br>   memset (&amp;Bookmark, 0, sizeof (BOOKMARK)) ; <br> <br>   NewSystemBookmark [0] = TEXT('\0') ; <br>   StringLoad ( <br>      bDisconnected ? <br>         IDS_SYSTEM_DOWN : <br>         IDS_SYSTEM_UP, <br>      NewSystemBookmark) ; <br> <br>   lstrcat (NewSystemBookmark, TEXT(" - ")) ; <br>   lstrcat (NewSystemBookmark, lpSystemName) ; <br>   Bookmark.SystemTime = *pSystemTime ; <br>   lstrcpy (Bookmark.szComment, NewSystemBookmark) ; <br> <br>   return (LogWriteBookmarkData (hWndLog, &amp;Bookmark)) ; <br>   } <br> <br>BOOL LogWriteStartBookmark (HWND hWnd, SYSTEMTIME *pSystemTime) <br>   { <br>   BOOKMARK       Bookmark ; <br>   TCHAR    NewDataBookmark [MiscTextLen] ; <br> <br>   memset (&amp;Bookmark, 0, sizeof (BOOKMARK)) ; <br> <br>   NewDataBookmark [0] = TEXT('\0') ; <br>   StringLoad (IDS_NEWDATA_BOOKMARK, NewDataBookmark) ; <br>   Bookmark.SystemTime = *pSystemTime ; <br>   lstrcpy (Bookmark.szComment, NewDataBookmark) ; <br> <br>   return (LogWriteBookmarkData (hWndLog, &amp;Bookmark)) ; <br>   } <br> <br>BOOL LogWriteBookmarkData (HWND hWnd, PBOOKMARK pBookmark) <br>   { <br>   PLOG           pLog ; <br>   LONG           lDataOffset ; <br>   BOOL           WriteOK ; <br> <br>   pLog = LogData (hWndLog) ; <br>   if (!pLog) <br>      return (FALSE) ; <br> <br>   lDataOffset = FileTell (pLog-&gt;hFile) ; <br>   WriteOK = FileWrite (pLog-&gt;hFile, pBookmark, sizeof (BOOKMARK)) ; <br>   if ( WriteOK ) <br>      { <br>      pLog-&gt;lFileSize += sizeof (BOOKMARK) ; <br>      UpdateLogSize (hWndLog) ; <br> <br>      WriteOK = LogWriteIndex (pLog, LogFileIndexBookmark, <br>                               &amp;(pBookmark-&gt;SystemTime), <br>                               lDataOffset, <br>                               0) ; <br>      } <br>   if ( !WriteOK ) <br>      { <br>      CloseLog (hWndLog, pLog) ; <br>      PrepareMenu (GetMenu (hWndMain)) ; <br>      UpdateLogDisplay (hWndLog) ;    <br>      DlgErrorBox (hWndLog, ERR_LOG_FILE, pLog-&gt;szFilePath); <br>      } <br>   return WriteOK ; <br>   } <br> <br> <br> <br>BOOL LogWriteBookmark (HWND hWndLog, <br>                       LPCTSTR lpszComment) <br>   {  // LogWriteBookmark <br>   BOOKMARK       Bookmark ; <br> <br>   memset (&amp;Bookmark, 0, sizeof (BOOKMARK)) ; <br> <br>   GetLocalTime (&amp;Bookmark.SystemTime) ; <br>   lstrcpy (Bookmark.szComment, lpszComment) ; <br> <br>   return (LogWriteBookmarkData (hWndLog, &amp;Bookmark)) ; <br>   }  // LogWriteBookmark <br>    <br> <br>BOOL AnyLogLine (void) <br>{  // CurrentLogLine <br>   int iIndex ; <br> <br>   iIndex = LBSelection (hWndLogEntries) ; <br>   if (iIndex == LB_ERR) <br>      { <br>      return (FALSE) ; <br>      } <br>   else <br>      { <br>      return (TRUE) ; <br>      } <br>} <br> <br>void ResetLogView (HWND hWndLog) <br>{ <br>   PLOG        pLog ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   ChangeSaveFileName (NULL, IDM_VIEWLOG) ; <br> <br>   if (pLog &amp;&amp; pLog-&gt;pSystemFirst) <br>      { <br>      ResetLog (hWndLog) ; <br>      } <br>}  // ResetLogView <br> <br>BOOL ResetLog (HWND hWndLog) <br>{ <br>   int         iIndex ; <br>   PLOG        pLog ; <br>   int         iEntriesNum ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   if (LogCollecting (hWndLog)) <br>      { <br>      CloseLog (hWndLog, pLog) ; <br>      } <br>  <br>   LBSetRedraw (hWndLogEntries, FALSE) ; <br>   iEntriesNum = LBNumItems (hWndLogEntries) ; <br> <br>   // only need to zero out the list head <br>   // each item will be deleted by LogDeleteIndex via the listbox <br>   pLog-&gt;pLogEntryFirst = NULL ; <br> <br>   // delete each line <br>   for (iIndex = iEntriesNum - 1 ; <br>        iIndex &gt;= 0 ; <br>        iIndex-- ) <br>      { <br>      LogDeleteIndex (hWndLogEntries, iIndex) ; <br>      } <br> <br>   LBSetRedraw (hWndLogEntries, TRUE) ; <br> <br>   if (pLog-&gt;pSystemFirst) <br>      { <br>      FreeSystems (pLog-&gt;pSystemFirst) ; <br>      pLog-&gt;pSystemFirst = NULL ; <br>      } <br> <br>   MemoryFree (pLog-&gt;pLogData) ; <br> <br>   pLog-&gt;pLogData = (PPERFDATA) MemoryAllocate (STARTING_SYSINFO_SIZE) ; <br> <br>   LogEntriesChanged (hWndLogEntries) ; <br> <br>   pLog-&gt;iStatus = iPMStatusClosed ; <br>   UpdateLogDisplay (hWndLog) ; <br> <br>   return (TRUE) ; <br>} <br> <br>BOOL LogDeleteEntry (HWND hWndLog) <br>{ <br>   int         iIndex ; <br>   PLOG        pLog ; <br>   BOOL        retCode ; <br>   int         iEntriesNum ; <br> <br>   pLog = LogData (hWndLog) ; <br> <br>   iIndex = LBSelection (hWndLogEntries) ; <br> <br>   if (iIndex == LB_ERR) <br>      { <br>      retCode = FALSE ; <br>      } <br>   else <br>      { <br>      // remove the current selection <br>      LogDeleteIndex (hWndLogEntries, iIndex) ; <br> <br>      iEntriesNum = LBNumItems (hWndLogEntries) ; <br> <br>      if (iEntriesNum == 0 || iEntriesNum == LB_ERR) <br>         { <br>         // delete the last line or something bad happened,  <br>         // then reset the window. <br>         ResetLog (hWndLog) ; <br>         } <br>      else <br>         { <br>         // set selection on the item above the deleted item. <br>         iIndex-- ; <br>         if (iIndex &lt; 0) <br>            { <br>            iIndex = 0 ; <br>            } <br>         LBSetSelection (hWndLogEntries, iIndex) ; <br>         LBSetVisible (hWndLogEntries, iIndex) ; <br>         } <br> <br>      LogEntriesChanged (hWndLogEntries) ; <br>      retCode = TRUE ; <br>      } <br>   return (retCode) ; <br>} <br> <br> <br>void ExportLog (void) <br>{ <br>   HANDLE      hFile ; <br>   PLOG        pLog ; <br>   PLOGENTRY   pLogEntry ; <br>   int         iIndex ; <br>   int         iIndexNum ; <br>   CHAR        TempBuff [LongTextLen * 2] ; <br>   TCHAR       UnicodeBuff [LongTextLen] ; <br>   TCHAR       UnicodeBuff1 [MiscTextLen] ; <br>   int         StringLen ; <br>   LPTSTR      pFileName = NULL ; <br>   INT         ErrCode = 0 ; <br> <br>   if (!(pLog = LogData (hWndLog))) <br>      { <br>      return ; <br>      } <br> <br>   // see if there is anything to export.. <br>   iIndexNum = LBNumItems (hWndLogEntries) ; <br>   if (iIndexNum == 0 || iIndexNum == LB_ERR) <br>      { <br>      return ; <br>      } <br> <br>   if (!FileGetName (hWndLog, IDS_EXPORTFILE, UnicodeBuff)) <br>      { <br>      // user cancel  <br>      return ; <br>      } <br> <br>   pFileName = StringAllocate (UnicodeBuff) ; <br> <br>   // open the file.. <br>   if (!(hFile = FileHandleCreate (UnicodeBuff))) <br>      { <br>      // can't open the file <br>      ErrCode = ERR_CANT_OPEN ; <br>      return ; <br>      } <br> <br> <br>   SetHourglassCursor() ; <br> <br>   // get header <br>   StringLoad (IDS_REPORT_HEADER, UnicodeBuff) ; <br>   ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>   StringLen = strlen (TempBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], LocalComputerName) ; <br>   strcat (TempBuff, LineEndStr) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      ErrCode = ERR_EXPORT_FILE ; <br>      goto Exit0 ; <br>      } <br> <br>   if (!(strempty(pLog-&gt;szFilePath))) <br>      { <br>      // export filename is there is one <br>      StringLoad (IDS_REPORT_LOGFILE, UnicodeBuff) ; <br>      ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>      StringLen = strlen (TempBuff) ; <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], pLog-&gt;szFilePath) ; <br>      strcat (TempBuff, LineEndStr) ; <br> <br>      if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>         { <br>         ErrCode = ERR_EXPORT_FILE ; <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   // export interval  <br>   StringLoad (IDS_CHARTINT_FORMAT, UnicodeBuff1) ; <br>   TSPRINTF (UnicodeBuff, UnicodeBuff1, <br>       (FLOAT) pLog-&gt;iIntervalMSecs / (FLOAT) 1000.0) ; <br>   ConvertDecimalPoint (UnicodeBuff) ; <br>   ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>   strcat (TempBuff, LineEndStr) ; <br>   strcat (TempBuff, LineEndStr) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      ErrCode = ERR_EXPORT_FILE ; <br>      goto Exit0 ; <br>      } <br> <br>   // export Labels <br>   StringLoad (IDS_LABELOBJECT, UnicodeBuff) ; <br>   ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      ErrCode = ERR_EXPORT_FILE ; <br>      goto Exit0 ; <br>      } <br> <br>   StringLoad (IDS_LABELSYSTEM, UnicodeBuff) ; <br>   ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>   strcat (TempBuff, LineEndStr) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      ErrCode = ERR_EXPORT_FILE ; <br>      goto Exit0 ; <br>      } <br> <br> <br>   // export each counter <br>   for (iIndex = 0 ; iIndex &lt; iIndexNum ; iIndex++) <br>      {  // for <br>       <br>      pLogEntry = LogEntryN (hWndLogEntries, iIndex) ; <br>       <br>      if (!pLogEntry || pLogEntry == (PLOGENTRY)LB_ERR) <br>         { <br>         continue ; <br>         } <br> <br>      ConvertUnicodeStr (TempBuff, pLogEntry-&gt;szObject) ; <br>      strcat (TempBuff, pDelimiter) ; <br> <br>      if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>         { <br>         ErrCode = ERR_EXPORT_FILE ; <br>         break ; <br>         } <br> <br>      ConvertUnicodeStr (TempBuff, pLogEntry-&gt;szComputer) ; <br>      strcat (TempBuff, LineEndStr) ; <br> <br>      if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>         { <br>         ErrCode = ERR_EXPORT_FILE ; <br>         break ; <br>         } <br>      } <br> <br>Exit0: <br> <br>   SetArrowCursor() ; <br>   CloseHandle (hFile) ; <br> <br>   if (pFileName) <br>      { <br>      if (ErrCode) <br>         { <br>         DlgErrorBox (hWndGraph, ErrCode, pFileName) ; <br>         } <br>      MemoryFree (pFileName) ; <br>      } <br> <br>}  // ExportLog <br> <br> <br>LPTSTR   MatchSystemCounters (LPTSTR pBaseSysCounter, <br>   long   lBaseSysSize, <br>   LPTSTR pSysCounter, <br>   long   lSysSize, <br>   long   *pMatchPortion) <br>{ <br>   LPTSTR   pNotMatch = NULL ; <br>   long     i, lSizeToCompare ; <br> <br>   *pMatchPortion = 0 ; <br>   lSizeToCompare = min (lBaseSysSize, lSysSize) / sizeof (TCHAR) ; <br> <br>   for (i = 0 ; i &lt; lSizeToCompare ; i++, pBaseSysCounter++, pSysCounter++) <br>      { <br>      if (*pBaseSysCounter != *pSysCounter) <br>         { <br>         pNotMatch = pSysCounter ; <br>         break ; <br>         } <br>      } <br> <br>   if (pNotMatch == NULL) <br>      { <br>      if (lBaseSysSize &lt; lSysSize) <br>         { <br>         // the new system has longer counter names than base system <br>         // setup the extra portion. <br>         pNotMatch = pSysCounter ; <br>         } <br>      else <br>         { <br>         // new system counter name is shorter than or equal to <br>         // the base system counter names <br>         *pMatchPortion = lSysSize ; <br>         } <br>      } <br> <br>   return (pNotMatch) ; <br> <br>} <br>  <br>void LogWriteSystemCounterNames (HWND hWnd, PLOG pLog) <br>   { <br>   long           dwArraySize ; <br>   PPERFSYSTEM    pSystem = pLog-&gt;pSystemFirst ; <br>   LPTSTR         pMatchLen ; <br>   LPTSTR         pCounterName ; <br>   long           lMatchLen, lMatchPortion ; <br> <br>   for (pSystem = pLog-&gt;pSystemFirst ; <br>        pSystem ; <br>        pSystem = pSystem-&gt;pSystemNext) <br>      { <br>      if (pSystem-&gt;bSystemCounterNameSaved == TRUE || <br>          pSystem-&gt;CounterInfo.dwLastId == 0) <br>         { <br>         // we have either wrote out the counter name for  <br>         // this system, or this system is not connect when <br>         // reading in the setting file,  skip it then. <br>         continue ; <br>         } <br> <br>      dwArraySize = (pSystem-&gt;CounterInfo.dwLastId + 1 ) ; <br> <br>      if (!pLog-&gt;lBaseCounterNameOffset) <br>         { <br>         LogWriteCounterName (hWnd, pSystem, pLog, <br>            (LPTSTR)(pSystem-&gt;CounterInfo.TextString + dwArraySize), <br>            0, <br>            pSystem-&gt;CounterInfo.dwCounterSize, <br>            0 ) ; <br>         } <br>      else <br>         { <br>         // check for matched characters between this system and the  <br>         // base system <br>         pCounterName = (LPTSTR)(pSystem-&gt;CounterInfo.TextString + dwArraySize) ; <br>         pMatchLen = MatchSystemCounters (pLog-&gt;pBaseCounterName, <br>                        pLog-&gt;lBaseCounterNameSize, <br>                        pCounterName, <br>                        pSystem-&gt;CounterInfo.dwCounterSize, <br>                        &amp;lMatchPortion) ; <br> <br>         if (pMatchLen) <br>            { <br>            // This system matches part of the base system <br>            // (all if it has more names) <br>            lMatchLen = (long) (pMatchLen - pCounterName) * sizeof (TCHAR) ; <br>            LogWriteCounterName (hWnd, pSystem, pLog, <br>               pMatchLen, <br>               lMatchLen, <br>               pSystem-&gt;CounterInfo.dwCounterSize - lMatchLen, <br>               0 ) ; <br>            } <br>         else <br>            { <br>            // This system matches the based system <br>            LogWriteCounterName (hWnd, pSystem, pLog, <br>               NULL, <br>               lMatchPortion, <br>               0, <br>               0 ) ; <br>            } <br>         } <br>      } <br>   } // LogWriteSystemCounterNames <br> <br> <br>BOOL LogWriteCounterName (HWND hWnd, <br>                          PPERFSYSTEM pSystem, <br>                          PLOG   pLog, <br>                          LPTSTR pCounterName, <br>                          long sizeMatched, <br>                          long sizeOfData, <br>                          BOOL bBaseCounterName) <br>   { <br>   BOOL                 ReadOK ; <br>   BOOL                 WriteOK ; <br>   SYSTEMTIME           SystemTime ; <br>   LOGFILECOUNTERNAME   CounterNameRecord ; <br>   LOGHEADER            LogFileHeader ; <br>   long                 lDataOffset, lCurPosition ; <br>   TCHAR                Dummy [sizeof(DWORD)] ; <br>   int                  PatchBytes ; <br> <br>   if (pSystem-&gt;bSystemCounterNameSaved == TRUE) <br>      return FALSE ; <br> <br>   GetLocalTime (&amp;SystemTime) ; <br> <br>   lCurPosition = FileTell (pLog-&gt;hFile) ; <br>    <br>   lstrcpy (CounterNameRecord.szComputer, pSystem-&gt;sysName) ; <br>   CounterNameRecord.lBaseCounterNameOffset = pLog-&gt;lBaseCounterNameOffset ; <br>   CounterNameRecord.lCurrentCounterNameOffset = <br>      lCurPosition + sizeof (LOGFILECOUNTERNAME) ; <br>   CounterNameRecord.lMatchLength = sizeMatched ; <br>   CounterNameRecord.lUnmatchCounterNames = sizeOfData ; <br>   CounterNameRecord.dwLastCounterId = pSystem-&gt;CounterInfo.dwLastId ; <br>   CounterNameRecord.dwLangId = pSystem-&gt;CounterInfo.dwLangId ; <br>   WriteOK = FileWrite (pLog-&gt;hFile, &amp;CounterNameRecord, <br>      sizeof (CounterNameRecord)) ; <br> <br>   if (WriteOK) <br>      { <br>      pLog-&gt;lFileSize += sizeof (LOGFILECOUNTERNAME) ; <br> <br>      if (sizeOfData) <br>         { <br>       <br>         WriteOK = FileWrite (pLog-&gt;hFile, pCounterName, sizeOfData) ; <br>          <br>         if (WriteOK &amp;&amp; (PatchBytes = sizeOfData % sizeof(DWORD)) &gt; 0) <br>            { <br>            // ensure the file is in DWORD boundary. <br>            WriteOK = FileWrite (pLog-&gt;hFile, Dummy, PatchBytes) ; <br>            } <br> <br>         if (WriteOK) <br>            { <br>            pLog-&gt;lFileSize += sizeOfData + PatchBytes ; <br> <br>            if (!pLog-&gt;lBaseCounterNameOffset) <br>               { <br>               // this is the first counter name data block <br>               // then update the log file header <br>               lDataOffset = FileTell (pLog-&gt;hFile) ; <br> <br>               FileSeekBegin (pLog-&gt;hFile, 0L) ; <br> <br>               ReadOK = FileRead (pLog-&gt;hFile, <br>                  &amp;LogFileHeader, <br>                  sizeof (LogFileHeader)) ; <br> <br>               if (ReadOK) <br>                  { <br>                  LogFileHeader.lBaseCounterNameOffset = lCurPosition ; <br>                  FileSeekBegin (pLog-&gt;hFile, 0L) ; <br>                  WriteOK = FileWrite (pLog-&gt;hFile, <br>                     &amp;LogFileHeader, <br>                     sizeof (LogFileHeader)) ; <br>                  } <br>               else <br>                  { <br>                  // flag an error <br>                  WriteOK = FALSE ;  <br>                  } <br> <br>               // retore back to current file position <br>               FileSeekBegin (pLog-&gt;hFile, lDataOffset) ; <br> <br>               if (ReadOK &amp;&amp; WriteOK) <br>                  { <br>                  // allocate memory to save the base system counter names <br>                  if (pLog-&gt;pBaseCounterName) <br>                     { <br>                     MemoryFree (pLog-&gt;pBaseCounterName) ; <br>                     } <br>                  if (pLog-&gt;pBaseCounterName = MemoryAllocate (sizeOfData)) <br>                     { <br>                     memcpy (pLog-&gt;pBaseCounterName, <br>                        pCounterName, <br>                        sizeOfData) ; <br>                     pLog-&gt;lBaseCounterNameOffset = lCurPosition ; <br>                     pLog-&gt;lBaseCounterNameSize = sizeOfData ; <br>                     } <br>                  } <br>               }  // if (!pLog-&gt;lBaseCounterNameOffset) <br>            } <br>         }  // if (sizeOfData) <br>      } <br> <br>   if ( WriteOK ) <br>      { <br>      WriteOK = LogWriteIndex (pLog, LogFileIndexCounterName, <br>                               &amp;SystemTime, <br>                               lCurPosition, <br>                               0) ; <br>      } <br> <br>   if ( !WriteOK ) <br>      { <br>      CloseLog (hWndLog, pLog) ; <br>      PrepareMenu (GetMenu (hWndMain)) ; <br>      UpdateLogDisplay (hWndLog) ;    <br>      DlgErrorBox (hWndLog, ERR_LOG_FILE, pLog-&gt;szFilePath); <br>      } <br>   else <br>      { <br>      UpdateLogSize (hWnd) ; <br>      pSystem-&gt;bSystemCounterNameSaved = TRUE ; <br>      } <br> <br>   return (TRUE) ; <br>   } <br> <br>      </code></pre>
<p>&nbsp;</p></body>
</HTML>
