<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VALUEBAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5716"></a>VALUEBAR.C</h2>
<pre><code>/* <br>============================================================================== <br> <br>  Application: <br> <br>            Microsoft Windows NT (TM) Performance Monitor <br> <br>  File: <br>            status.c - Status window procedure and supporting routines. <br> <br>            This file contains code creating the status window, which is <br>            a child of the legend window. The status window shows the <br>            time duration of the chart, and the last, avg, min and max <br>            of the currently-selected chart line. <br> <br> <br>  Copyright 1992 - 1998 Microsoft Corporation. All Rights Reserved. <br>============================================================================== <br>*/ <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt;   // for mbstowcs <br> <br> <br>#include "perfmon.h" <br>#include "perfmops.h"      // for ConvertDecimalPoint <br>#include "valuebar.h" <br> <br>#include "grafdata.h"      // for CurrentGraphLine <br>#include "graph.h" <br>#include "playback.h"      // for PlayingBackLog <br>#include "legend.h" <br>#include "utils.h" <br> <br> <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br>HDC   hVBarDC ; <br> <br>#define szGraphStatusClass          TEXT("PerfmonGraphStatusClass") <br>#define dwGraphStatusClassStyle     (CS_HREDRAW | CS_VREDRAW | CS_OWNDC) <br>#define iGraphStatusClassExtra      (0) <br>#define iGraphStatusWindowExtra     (0) <br>#define dwGraphStatusWindowStyle    (WS_CHILD | WS_VISIBLE) <br> <br> <br>#define szStatusValueFormat         TEXT("%10.3f") <br>#define szStatusMediumnValueFormat  TEXT("%10.0f") <br>#define szStatusLargeValueFormat    TEXT("%10.4e") <br>#define eStatusValueTooLarge        ((FLOAT) 1.0E+20) <br>#define eStatusValueMax             ((FLOAT) 999999.999) <br>#define eStatusLargeValueMax        ((FLOAT) 9999999999.0) <br> <br> <br>#define szValueTooHigh              TEXT("+ + + +") <br>#define szValueTooLow               TEXT("- - - -") <br> <br>#define StatusLastElt               0 <br>#define StatusAvgElt                1 <br>#define StatusMinElt                2 <br>#define StatusMaxElt                3 <br>#define StatusTimeElt               4 <br> <br>#define StatusNumElts               5 <br> <br>#define StatusDrawAvg(hDC, eValue, bForceRedraw)   \ <br>   DrawStatusValue (hDC, StatusAvgElt, eValue, bForceRedraw) <br> <br>#define StatusDrawMax(hDC, eValue, bForceRedraw)   \ <br>   DrawStatusValue (hDC, StatusMaxElt, eValue, bForceRedraw) <br> <br>#define StatusDrawMin(hDC, eValue, bForceRedraw)   \ <br>   DrawStatusValue (hDC, StatusMinElt, eValue, bForceRedraw) <br> <br>//==========================================================================// <br>//                                  Typedefs                                // <br>//==========================================================================// <br> <br> <br>typedef struct StatusEltStruct <br>   { <br>   TCHAR          szText [20] ; <br>   int            xTextPos ; <br>   int            xValuePos ; <br>   FLOAT          eValue ; <br>   } StatusEltType ; <br> <br> <br>// This structure represents the "instance data" for a StatusWindow. The <br>// information is collected in a structure to ease the conversion of this <br>// code when later adding multiple graph windows. For now, one copy of this <br>// struct is defined as local data to this file. <br>typedef struct StatusDataStruct <br>   { <br>   StatusEltType  aElts [StatusNumElts] ; <br>   SIZE           sizeValue ; <br>   int            yHeight ; <br>   } StatusDataType ; <br> <br> <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br>StatusDataType    StatusData ; <br> <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define StatusTopMargin()     (2) <br>#define StatusBottomMargin()  (4) <br> <br>#define StatusLeftMargin()    (3) <br>#define StatusTextMargin()    (5 + ThreeDPad) <br>#define StatusValueMargin()   (3 + ThreeDPad) <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>void DrawStatusValue (HDC hDC, <br>                      int iEltOffset, <br>                      FLOAT eValue, <br>                      BOOL bForceRedraw) <br>/* <br>   Called By:     StatusDrawTime, StatusDrawLast, StatusDrawAvg, <br>                  StatusDrawMin, StatusDrawMax. <br>*/ <br>   {  // DrawStatusValue <br>   RECT           rectValue ; <br>   TCHAR          szValue [20] ; <br> <br>   if (!bForceRedraw &amp;&amp; eValue == StatusData.aElts[iEltOffset].eValue) <br>      return ; <br>   StatusData.aElts[iEltOffset].eValue = eValue ; <br> <br>   rectValue.left = StatusData.aElts[iEltOffset].xValuePos ; <br>   rectValue.top = StatusTopMargin () + ThreeDPad + 1; <br>   rectValue.right = rectValue.left + StatusData.sizeValue.cx ; <br>   rectValue.bottom = rectValue.top + StatusData.sizeValue.cy ; <br> <br> <br>   if (eValue &gt; eStatusValueMax) <br>      { <br>      if (eValue &gt; eStatusValueTooLarge) <br>         { <br>         lstrcpy (szValue, szValueTooHigh) ; <br>         } <br>      else <br>         { <br>         TSPRINTF (szValue, <br>            (eValue &gt; eStatusLargeValueMax) ? szStatusLargeValueFormat : <br>            szStatusMediumnValueFormat, <br>            eValue) ; <br>         ConvertDecimalPoint (szValue) ; <br>         } <br>      } <br>   else if (eValue &lt; -eStatusValueMax) <br>      lstrcpy (szValue, szValueTooLow) ; <br>   else <br>      { <br>      TSPRINTF (szValue, szStatusValueFormat, eValue) ; <br>      ConvertDecimalPoint (szValue) ; <br>      } <br> <br>   ExtTextOut (hDC, rectValue.right, rectValue.top, ETO_OPAQUE, &amp;rectValue, <br>               szValue, lstrlen (szValue), NULL) ; <br>   }  // DrawStatusValue <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>//void static OnCreate (HWND hWnd) <br>void OnVBarCreate (HWND hWnd) <br>/* <br>   Effect:        Perform any actions needed when a status window is created. <br>                  In particular, set the instance data to initial values, <br>                  determine the size and placement of the various elements <br>                  of the status display. <br> <br>   Called By:     GraphStatusWndProc only, in response to a WM_CREATE message. <br>*/ <br>   {  // OnCreate <br>   TCHAR          szValue [20] ; <br>   HDC            hDC ; <br>   int            iLen ; <br>   int            i ; <br> <br> <br>   hDC = hVBarDC = GetDC (hWnd) ; <br>   SelectFont (hDC, hFontScales) ; <br>   SetBkColor (hDC, ColorBtnFace) ; <br>   SetTextAlign (hDC, TA_RIGHT | TA_TOP) ; <br> <br>   //=============================// <br>   // Load Text Labels            // <br>   //=============================// <br> <br>   StringLoad (IDS_STATUSLAST, StatusData.aElts[StatusLastElt].szText) ; <br>   StringLoad (IDS_STATUSAVG, StatusData.aElts[StatusAvgElt].szText) ; <br>   StringLoad (IDS_STATUSMIN, StatusData.aElts[StatusMinElt].szText) ; <br>   StringLoad (IDS_STATUSMAX, StatusData.aElts[StatusMaxElt].szText) ; <br>   StringLoad (IDS_STATUSTIME, StatusData.aElts[StatusTimeElt].szText) ; <br> <br>   //=============================// <br>   // Determine Status Height     // <br>   //=============================// <br> <br>   StatusData.yHeight = StatusTopMargin () + <br>                        StatusBottomMargin () + <br>                        FontHeight (hDC, TRUE) + <br>                        2 * ThreeDPad ; <br> <br>   //=============================// <br>   // Set position/size of elts   // <br>   //=============================// <br> <br>   // Determine the bounding box for each status value by using a max value. <br>#ifdef JAPAN <br>   iLen = TSPRINTF (szValue, szStatusMediumnValueFormat, -((FLOAT) 9999.999)) ; <br>#else <br>   iLen = TSPRINTF (szValue, szStatusLargeValueFormat, -eStatusValueMax) ; <br>#endif <br> <br>   GetTextExtentPoint (hDC, szValue, lstrlen(szValue), &amp;StatusData.sizeValue) ; <br>   for (i = 0 ; <br>        i &lt; StatusNumElts ; <br>        i++) <br>      {  // for <br>      StatusData.aElts[i].eValue = (FLOAT) 0.0 ; <br> <br>      if (i) <br>         StatusData.aElts[i].xTextPos = <br>            StatusTextMargin () + <br>            StatusData.aElts[i - 1].xValuePos + <br>            StatusData.sizeValue.cx ; <br>      else <br>         StatusData.aElts[i].xTextPos = StatusLeftMargin () ; <br>      StatusData.aElts[i].xValuePos = StatusData.aElts[i].xTextPos + <br>                                     StatusValueMargin () + <br>                                     TextWidth (hDC, StatusData.aElts[i].szText) ; <br>      }  // for <br>   }  // OnCreate <br> <br> <br> <br>void static OnPaint (HWND hWnd) <br>/* <br>   Effect:        Paint the invalid surface of hWnd. Draw each label, each <br>                  recessed value box, and each value. <br> <br>   Called By:     GraphStatusWndProc only, in response to a WM_PAINT message. <br>*/ <br>   { <br>   HDC            hDC ; <br>   PAINTSTRUCT    ps ; <br>   RECT           rectClient ; <br>   int            i ; <br>   PLINESTRUCT    pLine; <br> <br>   hDC = BeginPaint (hWnd, &amp;ps) ; <br>   SetBkMode (hDC, TRANSPARENT) ; <br> <br>   GetClientRect (hWnd, &amp;rectClient) ; <br>   HLine (hDC, GetStockObject (BLACK_PEN), <br>          rectClient.left, rectClient.right, <br>          rectClient.bottom - 1) ; <br> <br>   if ((pGraphs-&gt;gOptions.bStatusBarChecked) &amp;&amp; <br>       (pGraphs-&gt;gOptions.bLegendChecked)) <br>      {  // if <br>      UINT  hPrevTextAlign = SetTextAlign (hDC, TA_LEFT | TA_TOP) ; <br> <br>      for (i = 0 ; <br>           i &lt; StatusNumElts ; <br>           i++) <br>         {  // for <br>         // Draw the label <br>         TextOut (hDC, StatusData.aElts[i].xTextPos, StatusTopMargin () + ThreeDPad, <br>                  StatusData.aElts[i].szText, <br>                  lstrlen (StatusData.aElts[i].szText)) ; <br> <br>         // Draw the recesed value box <br>         ThreeDConcave1 (hDC, <br>                        StatusData.aElts[i].xValuePos - ThreeDPad, <br>                        StatusTopMargin (), <br>                        StatusData.aElts[i].xValuePos + StatusData.sizeValue.cx + ThreeDPad, <br>                        StatusTopMargin () + StatusData.sizeValue.cy + 2 * ThreeDPad ) ; <br>         }  // for <br> <br>      // restore TextAlign for drawing values <br>      SetTextAlign (hDC, hPrevTextAlign) ; <br> <br>      // Draw the values themselves <br> <br>      pLine = CurrentGraphLine (hWndGraph) ; <br>      StatusDrawTime (hDC, TRUE) ; <br> <br>      StatusDrawLast (hDC, pLine, TRUE) ; <br> <br>      if (pLine) <br>         { <br>         StatusDrawAvg (hDC, pLine-&gt;lnAveValue, TRUE) ; <br>         StatusDrawMin (hDC, pLine-&gt;lnMinValue, TRUE) ; <br>         StatusDrawMax (hDC, pLine-&gt;lnMaxValue, TRUE) ; <br>         } <br>      else <br>         { <br>         StatusDrawAvg (hVBarDC,  (FLOAT)0.0, TRUE) ; <br>         StatusDrawMax (hVBarDC,  (FLOAT)0.0, TRUE) ; <br>         StatusDrawMin (hVBarDC,  (FLOAT)0.0, TRUE) ; <br>         } <br>      }  // if <br> <br>   EndPaint (hWnd, &amp;ps) ; <br>   }  // StatusPaint <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br> <br>void StatusDrawTime (HDC hDC, BOOL bForceRedraw) <br>/* <br>   Called By:     StatusTimer, StatusPaint. <br>*/ <br>   {  // StatusDrawTime <br>   FLOAT          eTimeSeconds ; <br> <br>   if (PlayingBackLog ()) <br>      eTimeSeconds = (FLOAT) PlaybackSelectedSeconds () ; <br>   else <br>      eTimeSeconds = pGraphs-&gt;gOptions.eTimeInterval * <br>                     (FLOAT) pGraphs-&gt;gMaxValues; <br> <br>   DrawStatusValue (hDC, StatusTimeElt, eTimeSeconds, bForceRedraw) ; <br>   }  // StatusDrawTime <br> <br> <br>void StatusDrawLast (HDC hDC, PLINESTRUCT pLine, BOOL bForceRedraw) <br>/* <br>   Called By:     StatusTimer, StatusPaint. <br>*/ <br>   { <br>   INT            iKnownValue ; <br>   int            iMaxValues ; <br>   FLOAT          eValue ; <br> <br>   if (!pLine || pGraphs-&gt;gKnownValue == -1) <br>      eValue = (FLOAT) 0.0 ; <br>   else <br>      { <br>      iKnownValue = pGraphs-&gt;gKnownValue ; <br>      iMaxValues  = pGraphs-&gt;gMaxValues ; <br>      eValue = pLine-&gt;lnValues [iKnownValue % iMaxValues] ; <br>      } <br> <br>   DrawStatusValue (hDC, StatusLastElt, eValue, bForceRedraw) ; <br>   } <br> <br>#if 0 <br>void StatusDrawAvg (HDC hDC, PLINESTRUCT pLine, BOOL bForceRedraw) <br>/* <br>   Called By:     StatusTimer, StatusPaint. <br>*/ <br>   { <br>   FLOAT          eValue ; <br> <br>   if (!pLine) <br>      eValue = (FLOAT) 0.0 ; <br>   else <br>      eValue = pLine-&gt;lnAveValue ; <br> <br>   DrawStatusValue (hDC, StatusAvgElt, eValue, bForceRedraw) ; <br>   } <br> <br> <br>void StatusDrawMax (HDC hDC, PLINESTRUCT pLine, BOOL bForceRedraw) <br>/* <br>   Called By:     StatusTimer, StatusPaint. <br>*/ <br>   { <br>   FLOAT          eValue ; <br> <br>   if (!pLine) <br>      eValue = (FLOAT) 0.0 ; <br>   else <br>      eValue = pLine-&gt;lnMaxValue ; <br> <br>   DrawStatusValue (hDC, StatusMaxElt, eValue, bForceRedraw) ; <br>   } <br> <br> <br>void StatusDrawMin (HDC hDC, PLINESTRUCT pLine, BOOL bForceRedraw) <br>/* <br>   Called By:     StatusTimer, StatusPaint. <br>*/ <br>   { <br>   FLOAT          eValue ; <br> <br>   if (!pLine) <br>      eValue = (FLOAT) 0.0 ; <br>   else <br>      eValue = pLine-&gt;lnMinValue ; <br> <br>   DrawStatusValue (hDC, StatusMinElt, eValue, bForceRedraw) ; <br>   } <br>#endif <br> <br> <br>LRESULT APIENTRY GraphStatusWndProc (HWND hWnd, <br>                                     WORD wMsg, <br>                                     WPARAM wParam, <br>                                     LPARAM lParam) <br>   {  // GraphStatusWndProc <br>   BOOL           bCallDefProc ; <br>   LRESULT        lReturnValue ; <br> <br> <br>   bCallDefProc = FALSE ; <br>   lReturnValue = 0L ; <br> <br>   switch (wMsg) <br>      {  // switch <br>      case WM_CREATE: <br>         //OnCreate (hWnd) ; <br>         OnVBarCreate (hWnd) ; <br>         break ; <br> <br> <br>      case WM_PAINT: <br>         OnPaint (hWnd) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         ReleaseDC (hWnd, hVBarDC) ; <br>         break ; <br> <br>      default: <br>         bCallDefProc = TRUE ; <br>      }  // switch <br> <br> <br>   if (bCallDefProc) <br>      lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ; <br> <br>   return (lReturnValue); <br>   }  // GraphStatusWndProc <br> <br> <br>int ValuebarHeight (HWND hWnd) <br>/* <br>   Effect:        A status window has a preferred height, based on the font <br>                  used in its display. Return the preferred height, determined <br>                  when the window was created. <br> <br>   Assert:        OnCreate has already been called, and it set <br>                  StatusData.yHeight. <br>*/ <br>   { <br>   return (StatusData.yHeight) ; <br>   } <br> <br> <br>void StatusTimer (HWND hWnd, BOOL bForceRedraw) <br>/* <br>   Effect:        Perform any status-window actions necessary when a timer <br>                  tick has been received. In particular, update (redraw) <br>                  any of the changed values in the status bar. <br> <br>   Internals:     Each of these called functions compares the value to be <br>                  displayed with the previous value and doesn't draw if the <br>                  values are equal. <br>*/ <br>   {  // StatusTimer <br>   PLINESTRUCT pLine; <br> <br> <br> <br>   pLine = CurrentGraphLine (hWndGraph) ; <br> <br>   StatusDrawLast (hVBarDC, pLine, bForceRedraw) ; <br> <br>   if (pLine) <br>      { <br>      StatusDrawAvg (hVBarDC, pLine-&gt;lnAveValue, bForceRedraw) ; <br>      StatusDrawMin (hVBarDC, pLine-&gt;lnMinValue, bForceRedraw) ; <br>      StatusDrawMax (hVBarDC, pLine-&gt;lnMaxValue, bForceRedraw) ; <br>      } <br>   else <br>      { <br>      StatusDrawAvg (hVBarDC,  (FLOAT)0.0, bForceRedraw) ; <br>      StatusDrawMax (hVBarDC,  (FLOAT)0.0, bForceRedraw) ; <br>      StatusDrawMin (hVBarDC,  (FLOAT)0.0, bForceRedraw) ; <br>      } <br>   }  // StatusTimer <br> <br> <br> <br>HWND CreateGraphStatusWindow (HWND hWndGraph) <br>   { <br>   return (CreateWindow (szGraphStatusClass,       // class <br>                         NULL,                     // caption <br>                         dwGraphStatusWindowStyle, // window style <br>                         0, 0,                     // position <br>                         0, 0,                     // size <br>                         hWndGraph,                // parent window <br>                         NULL,                     // menu <br>                         hInstance,               // program instance <br>                         NULL)) ;                  // user-supplied data <br>   } <br> <br> <br> <br> <br>BOOL GraphStatusInitializeApplication (void) <br>/* <br>   Called By:     GraphInitializeApplication only <br>*/ <br>   { <br>   WNDCLASS       wc ; <br> <br>   wc.style          = dwGraphStatusClassStyle ; <br>   wc.lpfnWndProc    = (WNDPROC) GraphStatusWndProc ; <br>   wc.hInstance      = hInstance ; <br>   wc.cbClsExtra     = iGraphStatusClassExtra ; <br>   wc.cbWndExtra     = iGraphStatusWindowExtra ; <br>   wc.hIcon          = NULL ; <br>   wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ; <br>   wc.hbrBackground  = hbLightGray ; <br>   wc.lpszMenuName   = NULL ; <br>   wc.lpszClassName  = szGraphStatusClass ; <br> <br>   return (RegisterClass (&amp;wc)) ; <br>   } <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
