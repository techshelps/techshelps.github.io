<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TIMELINE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5708"></a>TIMELINE.C</h2>
<pre><code><br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include "perfmon.h" <br>#include "intrline.h" <br>#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines <br>#include "timeline.h" <br>#include "perfmops.h"       // for SystemTimeDateString, et al. <br>#include "utils.h" <br>#include "grafdata.h"       // for GraphData <br> <br>//==========================================================================// <br>//                                  Typedefs                                // <br>//==========================================================================// <br> <br>typedef struct CHARTDATAPOINTSTRUCT <br>   { <br>   int         iLogIndex ; <br>   int         xDispDataPoint ; <br>   } CHARTDATAPOINT, *PCHARTDATAPOINT ; <br> <br>typedef struct TLINESTRUCT <br>   {  // TLINE <br>   HWND              hWndILine ; <br>   HFONT             hFont ; <br> <br>   SYSTEMTIME        SystemTimeBegin ; <br>   SYSTEMTIME        SystemTimeEnd ; <br> <br>   int               yFontHeight ; <br>   int               xMaxTimeWidth ; <br>   int               xBegin ; <br>   int               xEnd ; <br>    <br>   RECT              rectStartDate ; <br>   RECT              rectStartTime ; <br>   RECT              rectStopDate ; <br>   RECT              rectStopTime ; <br> <br>   PCHARTDATAPOINT   pChartDataPoint ; <br>   int               iCurrentStartPos ; <br>   int               iCurrentStopPos ; <br>   } TLINE ; <br> <br>typedef TLINE *PTLINE ; <br> <br>void PlaybackChartDataPoint (PCHARTDATAPOINT pChartDataPoint) ; <br> <br>// IntrLineFocus is defined and set/clear in Intrline.c <br>extern BOOL  IntrLineFocus ; <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define dwTLineClassStyle     (CS_HREDRAW | CS_VREDRAW) <br>#define iTLineClassExtra      (0) <br>#define iTLineWindowExtra     (sizeof (PTLINE)) <br>#define dwTLineWindowStyle    (WS_CHILD | WS_VISIBLE)  <br> <br>HWND  hTLineWnd ; <br>BOOL  TLineWindowUp ; <br> <br> <br> <br>PTLINE TLData (HWND hWndTL) <br>   { <br>   return ((PTLINE) GetWindowLong (hWndTL, 0)) ; <br>   } <br> <br> <br>PTLINE AllocateTLData (HWND hWndTL) <br>   { <br>   PTLINE         pTLine ; <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWndGraph) ; <br> <br>   pTLine = MemoryAllocate (sizeof (TLINE)) ; <br> <br>    <br>   // see if we have to draw the timeline <br>   if (pGraph &amp;&amp; <br>      iPerfmonView == IDM_VIEWCHART &amp;&amp; <br>      pGraph-&gt;pLineFirst &amp;&amp; <br>      pGraph-&gt;gOptions.iGraphOrHistogram == LINE_GRAPH) <br>      { <br>      pTLine-&gt;pChartDataPoint = <br>         MemoryAllocate (sizeof(CHARTDATAPOINT) * <br>         (pGraph-&gt;gTimeLine.iValidValues+1)) ; <br> <br> <br>      if (pTLine-&gt;pChartDataPoint != NULL) <br>         { <br>         PlaybackChartDataPoint (pTLine-&gt;pChartDataPoint) ; <br>         } <br>      } <br> <br>   SetWindowLong (hWndTL, 0, (LONG) pTLine) ; <br> <br>   return (pTLine) ; <br>   } <br> <br> <br>int MaxTimeWidth (HDC hDC,  <br>                  PTLINE pTLine) <br>/* <br>   Effect:        Return a reasonable maximum number of pixels to hold <br>                  expected time and date strings.   <br> <br>   To Do:         When we use the alleged local-date and local-time display <br>                  functions, we will modify this routine to use them. <br>*/ <br>   {  // MaxTimeWidth <br>   return (max (TextWidth (hDC, TEXT(" 99 XXX 99 ")), <br>                TextWidth (hDC, TEXT(" 99:99:99.9 PM ")))) ; <br>   }  // MaxTimeWidth <br> <br> <br>void TLGetSystemTimeN (HWND hWnd,    <br>                       int iInterval, <br>                       SYSTEMTIME *pSystemTime) <br>   {  // TLGetSystemTimeN <br>   SendMessage (WindowParent (hWnd),  <br>                TL_INTERVAL,  <br>                iInterval, (LPARAM) pSystemTime) ; <br>   }  // TLGetSystemTimeN <br> <br> <br> <br>void static TLDrawBeginEnd (HDC hDC, <br>                            PTLINE pTLine) <br>   { <br>   TCHAR         szDate [20] ; <br>   TCHAR         szTime [20] ; <br> <br>   SetTextAlign (hDC, TA_TOP) ; <br>   SelectFont (hDC, pTLine-&gt;hFont) ; <br> <br>   // Draw the begin time <br> <br>   SystemTimeDateString (&amp;(pTLine-&gt;SystemTimeBegin), szDate) ; <br>   SystemTimeTimeString (&amp;(pTLine-&gt;SystemTimeBegin), szTime, TRUE) ; <br> <br>   SetTextAlign (hDC, TA_RIGHT) ; <br>   TextOut (hDC, pTLine-&gt;xBegin, 0,  <br>            szDate, lstrlen (szDate)) ; <br>   TextOut (hDC, pTLine-&gt;xBegin, pTLine-&gt;yFontHeight, <br>            szTime, lstrlen (szTime)) ; <br> <br>   // Draw The end time <br> <br>   SystemTimeDateString (&amp;(pTLine-&gt;SystemTimeEnd), szDate) ; <br>   SystemTimeTimeString (&amp;(pTLine-&gt;SystemTimeEnd), szTime, TRUE) ; <br> <br>   SetTextAlign (hDC, TA_LEFT) ; <br>   TextOut (hDC, pTLine-&gt;xEnd, 0, <br>            szDate, lstrlen (szDate)) ; <br>   TextOut (hDC,  <br>            pTLine-&gt;xEnd,  <br>            pTLine-&gt;yFontHeight, <br>            szTime, lstrlen (szTime)) ; <br>   } <br> <br>void TLineRedraw (HDC hGraphDC, PGRAPHSTRUCT pGraph) <br>   { <br>   PTLINE         pTLine ; <br> <br>   if (!hTLineWnd) <br>      { <br>      return ; <br>      } <br> <br>   pTLine = TLData (hTLineWnd) ; <br>   if (pTLine == NULL) <br>      { <br>      return ; <br>      } <br> <br>   if (pTLine-&gt;iCurrentStartPos) <br>      { <br>      // redraw start line <br>      PatBlt (hGraphDC, pTLine-&gt;iCurrentStartPos, pGraph-&gt;rectData.top, <br>         1, pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top + 1, <br>         DSTINVERT) ; <br>      } <br> <br>   if (pTLine-&gt;iCurrentStopPos) <br>      { <br>      // redraw stop line <br>      PatBlt (hGraphDC, pTLine-&gt;iCurrentStopPos, pGraph-&gt;rectData.top, <br>         1, pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top+ 1, <br>         DSTINVERT) ; <br>      } <br>   }  // TLineRedraw <br> <br>void DrawOneTimeIndicator (PTLINE pTLine, <br>                           PGRAPHSTRUCT pGraph, <br>                           HDC hGraphDC, <br>                           int iPos, <br>                           int *pCurrentPos) <br>   { <br>   int               xPos ; <br>   PCHARTDATAPOINT   pDataPoint ; <br> <br>   // check if it is within current selected range <br>   if (iPos &gt;= PlaybackLog.StartIndexPos.iPosition &amp;&amp; <br>      iPos &lt;= PlaybackLog.StopIndexPos.iPosition) <br>      { <br> <br>      xPos = 0 ; <br>      pDataPoint = pTLine-&gt;pChartDataPoint ; <br> <br>      // check for the x position of this Log Index <br>      while (pDataPoint-&gt;iLogIndex != 0) <br>         { <br>         if (iPos &gt;= pDataPoint-&gt;iLogIndex) <br>            { <br>            if ((pDataPoint+1)-&gt;iLogIndex == 0) <br>               { <br>               // we have reached the end <br>               xPos = pDataPoint-&gt;xDispDataPoint ; <br>               break ; <br>               } <br>            else if (iPos &lt;= (pDataPoint+1)-&gt;iLogIndex) <br>               { <br>               // we have found the Log index <br>               xPos = (pDataPoint+1)-&gt;xDispDataPoint ; <br>               break ; <br>               } <br>            } <br>         else <br>            { <br>            // no need to continue if iPos is smaller than the  <br>            // first Log index on the chart <br>            break ; <br>            } <br> <br>         pDataPoint++ ; <br>         } <br> <br>      if (xPos != *pCurrentPos) <br>         { <br>         if (*pCurrentPos) <br>            { <br>            // erase the old line <br>            PatBlt (hGraphDC, *pCurrentPos, pGraph-&gt;rectData.top, <br>               1, pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top + 1, <br>               DSTINVERT) ; <br>            } <br> <br>         // draw the new line <br>         *pCurrentPos = xPos ; <br> <br>         if (xPos &gt; 0) <br>            { <br>            PatBlt (hGraphDC, xPos, pGraph-&gt;rectData.top, <br>               1, pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top + 1, <br>               DSTINVERT) ; <br>            } <br>         } <br>      } <br>   else <br>      { <br>      if (*pCurrentPos) <br>         { <br>         // erase the old line <br>         PatBlt (hGraphDC, *pCurrentPos, pGraph-&gt;rectData.top, <br>            1, pGraph-&gt;rectData.bottom - pGraph-&gt;rectData.top + 1, <br>            DSTINVERT) ; <br>         } <br> <br>      *pCurrentPos = 0 ; <br>      } <br>   }  // DrawOneTimeIndicator <br> <br>void DrawTimeIndicators (PTLINE pTLine, int iStart, int iStop) <br>   { <br> <br>   HDC            hGraphDC ; <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pGraph = GraphData (hWndGraph) ; <br>   hGraphDC = GetDC (hWndGraph) ; <br>   if (!hGraphDC || !pGraph) <br>      { <br>      return ; <br>      } <br> <br>   DrawOneTimeIndicator (pTLine, pGraph, hGraphDC, iStart, &amp;pTLine-&gt;iCurrentStartPos) ; <br>   DrawOneTimeIndicator (pTLine, pGraph, hGraphDC, iStop, &amp;pTLine-&gt;iCurrentStopPos) ; <br> <br>   ReleaseDC (hWndGraph, hGraphDC) ; <br>   } <br> <br>void static TLDrawStartStop (HWND hWnd, <br>                             HDC hDC, <br>                             PTLINE pTLine) <br>/* <br>   Effect:        Draw the start and stop date/times on the bottom of the <br>                  timeline. Draw the start date/time right justified at the <br>                  outer edge of the start point and the stop date/time left <br>                  justified with the outer edge of the stop point. <br> <br>                  Erase previous start and stop date/times in the process. <br>*/ <br>   {  // TLDrawStartStop <br>   RECT           rectDate ; <br>   RECT           rectTime ; <br>   RECT           rectOpaque ; <br> <br>   TCHAR          szDate [30] ; <br>   TCHAR          szTime [30] ; <br> <br>   int            xStart ; <br>   int            xStop ; <br> <br>   int            iStart ; <br>   int            iStop ; <br> <br>   SYSTEMTIME     SystemTimeStart ; <br>   SYSTEMTIME     SystemTimeStop ; <br> <br>   int            xDateTimeWidth ; <br> <br> <br>   SelectFont (hDC, pTLine-&gt;hFont) ; <br>   SetTextAlign (hDC, TA_TOP) ; <br> <br>   //=============================// <br>   // Get Start Information       // <br>   //=============================// <br> <br>   xStart = pTLine-&gt;xBegin + ILineXStart (pTLine-&gt;hWndILine) ; <br> <br>   iStart = ILineStart (pTLine-&gt;hWndILine) ; <br>   TLGetSystemTimeN (hWnd, iStart, &amp;SystemTimeStart) ; <br>   SystemTimeDateString (&amp;SystemTimeStart, szDate) ; <br>   SystemTimeTimeString (&amp;SystemTimeStart, szTime, TRUE) ; <br> <br>   xDateTimeWidth = max (TextWidth (hDC, szDate), <br>                         TextWidth (hDC, szTime)) ; <br> <br>   //=============================// <br>   // Write Start Date            // <br>   //=============================// <br> <br>   rectDate.left = xStart - xDateTimeWidth ; <br>   rectDate.top = pTLine-&gt;rectStartDate.top ; <br>   rectDate.right = xStart ; <br>   rectDate.bottom = pTLine-&gt;rectStartDate.bottom ; <br>  <br>   SetTextAlign (hDC, TA_RIGHT) ; <br>   UnionRect (&amp;rectOpaque, &amp;pTLine-&gt;rectStartDate, &amp;rectDate) ; <br> <br>   ExtTextOut (hDC,  <br>               rectDate.right, rectDate.top, <br>               ETO_OPAQUE, <br>               &amp;rectOpaque, <br>               szDate, lstrlen (szDate), <br>               NULL) ; <br>   pTLine-&gt;rectStartDate = rectDate ; <br> <br>   //=============================// <br>   // Write Start Time            // <br>   //=============================// <br>    <br>   rectTime.left = rectDate.left ; <br>   rectTime.top = pTLine-&gt;rectStartTime.top ; <br>   rectTime.right = rectDate.right ; <br>   rectTime.bottom = pTLine-&gt;rectStartTime.bottom ; <br> <br>   UnionRect (&amp;rectOpaque, &amp;pTLine-&gt;rectStartTime, &amp;rectTime) ; <br> <br>   ExtTextOut (hDC,  <br>               rectTime.right, rectTime.top, <br>               ETO_OPAQUE, <br>               &amp;rectOpaque, <br>               szTime, lstrlen (szTime), <br>               NULL) ; <br>   pTLine-&gt;rectStartTime = rectTime ; <br> <br>   if (IntrLineFocus) <br>      { <br>      UnionRect (&amp;rectOpaque, &amp;rectDate, &amp;rectTime) ; <br>      DrawFocusRect (hDC, &amp;rectOpaque) ; <br>      } <br> <br>   //=============================// <br>   // Get Stop Information        // <br>   //=============================// <br> <br>   xStop = pTLine-&gt;xBegin + ILineXStop (pTLine-&gt;hWndILine) ; <br> <br>   iStop = ILineStop (pTLine-&gt;hWndILine) ; <br>   TLGetSystemTimeN (hWnd, iStop, &amp;SystemTimeStop) ; <br>   SystemTimeDateString (&amp;SystemTimeStop, szDate) ; <br>   SystemTimeTimeString (&amp;SystemTimeStop, szTime, TRUE) ; <br> <br>   xDateTimeWidth = max (TextWidth (hDC, szDate), <br>                         TextWidth (hDC, szTime)) ; <br> <br>   //=============================// <br>   // Write Stop Date             // <br>   //=============================// <br> <br>   rectDate.left = xStop ; <br>   rectDate.top = pTLine-&gt;rectStopDate.top ; <br>   rectDate.right = xStop + xDateTimeWidth ; <br>   rectDate.bottom = pTLine-&gt;rectStopDate.bottom ; <br>  <br>   SetTextAlign (hDC, TA_LEFT) ; <br>   UnionRect (&amp;rectOpaque, &amp;pTLine-&gt;rectStopDate, &amp;rectDate) ; <br> <br>   ExtTextOut (hDC,  <br>               rectDate.left, rectDate.top, <br>               ETO_OPAQUE, <br>               &amp;rectOpaque, <br>               szDate, lstrlen (szDate), <br>               NULL) ; <br>   pTLine-&gt;rectStopDate = rectDate ; <br> <br>   //=============================// <br>   // Write Stop Time             // <br>   //=============================// <br>    <br>   rectTime.left = rectDate.left ; <br>   rectTime.top = pTLine-&gt;rectStopTime.top ; <br>   rectTime.right = rectDate.right ; <br>   rectTime.bottom = pTLine-&gt;rectStopTime.bottom ; <br> <br>   UnionRect (&amp;rectOpaque, &amp;pTLine-&gt;rectStopTime, &amp;rectTime) ; <br> <br>   ExtTextOut (hDC,  <br>               rectTime.left, rectTime.top, <br>               ETO_OPAQUE, <br>               &amp;rectOpaque, <br>               szTime, lstrlen (szTime), <br>               NULL) ; <br>   pTLine-&gt;rectStopTime = rectTime ; <br> <br>   if (IntrLineFocus) <br>      { <br>      UnionRect (&amp;rectOpaque, &amp;rectDate, &amp;rectTime) ; <br>      DrawFocusRect (hDC, &amp;rectOpaque) ; <br>      } <br> <br>   if (pTLine-&gt;pChartDataPoint) <br>      { <br>      DrawTimeIndicators (pTLine, iStart, iStop) ; <br>      } <br>   }  // TLDrawStartStop <br> <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br> <br>void static OnCreate (HWND hWnd) <br>   {  // OnCreate <br>   PTLINE         pTLine ; <br>   HDC            hDC ; <br> <br>   pTLine = AllocateTLData (hWnd) ; <br>    <br>   pTLine-&gt;hFont = hFontScales ; <br> <br>   hDC = GetDC (hWnd) ; <br>   SelectFont (hDC, hFontScales) ; <br> <br>   pTLine-&gt;yFontHeight = FontHeight (hDC, TRUE) ; <br>   pTLine-&gt;xMaxTimeWidth = MaxTimeWidth (hDC, pTLine) ; <br> <br>   ReleaseDC (hWnd, hDC) ; <br> <br>   hTLineWnd = hWnd ; <br>   TLineWindowUp = TRUE ; <br> <br>   pTLine-&gt;hWndILine =  <br>      CreateWindow (szILineClass,                  // class <br>                    NULL,                          // caption <br>                    (WS_VISIBLE | WS_CHILD | WS_TABSTOP ),       // window style <br>                    0, 0,                          // position <br>                    0, 0,                          // size <br>                    hWnd,                          // parent window <br>                    NULL,                          // menu           <br>                    hInstance,                     // program instance <br>                    NULL) ;                        // user-supplied data <br>   }  // OnCreate <br> <br> <br>void static OnDestroy (HWND hWnd) <br>   { <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br> <br>   if (pTLine-&gt;pChartDataPoint) <br>      { <br>      MemoryFree (pTLine-&gt;pChartDataPoint) ; <br>      } <br> <br>   MemoryFree (pTLine) ; <br> <br>   hTLineWnd = 0 ; <br>   TLineWindowUp = FALSE ; <br> <br>   } <br> <br> <br>void static OnSize (HWND hWnd, <br>                    int xWidth, <br>                    int yHeight) <br>/* <br>   Effect:        Perform all actions needed when the size of the timeline <br>                  hWnd has changed. In particular, determine the appropriate <br>                  size for the ILine window and set the rectangles for the <br>                  top and bottom displays. <br>*/ <br>   {  // OnSize <br>   PTLINE         pTLine ; <br>   int            yLine ; <br>   int            yDate, yTime ; <br>   int            xEnd ; <br> <br>   pTLine = TLData (hWnd) ; <br> <br>   xEnd = xWidth - pTLine-&gt;xMaxTimeWidth ; <br>   yLine = pTLine-&gt;yFontHeight ; <br>   yDate = yHeight - 2 * yLine ; <br>   yTime = yHeight - yLine ; <br> <br> <br>   SetRect (&amp;pTLine-&gt;rectStartDate, <br>            0, yDate, 0, yDate + yLine) ; <br> <br>   SetRect (&amp;pTLine-&gt;rectStartTime, <br>            0, yTime, 0, yTime + yLine) ; <br> <br>   SetRect (&amp;pTLine-&gt;rectStopDate, <br>            xEnd, yDate, xEnd, yDate + yLine) ; <br> <br>   SetRect (&amp;pTLine-&gt;rectStopTime, <br>            xEnd, yTime, xEnd, yTime + yLine) ; <br> <br>   MoveWindow (pTLine-&gt;hWndILine, <br>               pTLine-&gt;xMaxTimeWidth, 2 * pTLine-&gt;yFontHeight, <br>               xWidth - 2 * pTLine-&gt;xMaxTimeWidth, <br>               yHeight - 4 * pTLine-&gt;yFontHeight, <br>               FALSE) ; <br> <br>   pTLine-&gt;xBegin = pTLine-&gt;xMaxTimeWidth ; <br>   pTLine-&gt;xEnd = xWidth - pTLine-&gt;xMaxTimeWidth ; <br>   }  // OnSize <br> <br> <br>void static OnPaint (HWND hWnd) <br>   { <br>   HDC            hDC ; <br>   PAINTSTRUCT    ps ; <br>   PTLINE         pTLine ; <br> <br>   hDC = BeginPaint (hWnd, &amp;ps) ; <br> <br>   pTLine = TLData (hWnd) ; <br>   TLDrawBeginEnd (hDC, pTLine) ; <br>   TLDrawStartStop (hWnd, hDC, pTLine) ; <br> <br>   EndPaint (hWnd, &amp;ps) ; <br>   } <br> <br> <br>void static OnILineChanged (HWND hWnd) <br>   { <br>   HDC            hDC ; <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br> <br>   hDC = GetDC (hWnd) ; <br>   TLDrawStartStop (hWnd, hDC, pTLine) ; <br>   ReleaseDC (hWnd, hDC) ; <br>   } <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>LONG FAR PASCAL TLineWndProc (HWND hWnd, <br>                              unsigned msg, <br>                              WPARAM wParam, <br>                              LONG lParam) <br>/* <br>   Note:          This function must be declared in the application's <br>                  linker-definition file, perfmon.def file. <br>*/ <br>   {  // TLineWndProc <br>   BOOL           bCallDefWindowProc ; <br>   LONG           lReturnValue ; <br> <br>   bCallDefWindowProc = FALSE ; <br>   lReturnValue = 0L ; <br> <br>   switch (msg) <br>      {  // switch <br>      case WM_SETFOCUS: <br>         { <br>         PTLINE         pTLine ; <br> <br>         pTLine = TLData (hWnd) ; <br>         SetFocus (pTLine-&gt;hWndILine) ; <br>         } <br>         return 0 ; <br> <br>      case WM_KILLFOCUS: <br>         return 0 ; <br> <br>      case WM_COMMAND: <br>         OnILineChanged (hWnd) ; <br>         break ; <br> <br>      case WM_CREATE: <br>         OnCreate (hWnd) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hWnd) ; <br>         break ; <br> <br>      case WM_PAINT: <br>         OnPaint (hWnd) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ; <br>         break ; <br> <br>      default: <br>         bCallDefWindowProc = TRUE ; <br>      }  // switch <br> <br>   if (bCallDefWindowProc) <br>      lReturnValue = DefWindowProc (hWnd, msg, wParam, lParam) ; <br> <br>   return (lReturnValue) ; <br>   }  // TLineWndProc <br> <br> <br> <br>BOOL TLineInitializeApplication (void) <br>/* <br>   Effect:        Perform all initializations required before an application <br>                  can create an IntervalLine. In particular, register the  <br>                  IntervalLine window class. <br> <br>   Called By:     The application, in its InitializeApplication routine. <br> <br>   Returns:       Whether the class could be registered. <br>*/ <br>   {  // TLineInitializeApplication <br>   WNDCLASS       wc ; <br> <br>   wc.style =           dwTLineClassStyle ; <br>   wc.lpfnWndProc =     TLineWndProc ; <br>   wc.cbClsExtra =      iTLineClassExtra ; <br>   wc.cbWndExtra =      iTLineWindowExtra ; <br>   wc.hInstance =       hInstance ; <br>   wc.hIcon =           NULL ; <br>   wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ; <br>   wc.hbrBackground =   (HBRUSH) (COLOR_WINDOW + 1) ; <br>   wc.lpszMenuName =    NULL ; <br>   wc.lpszClassName =   szTLineClass ; <br> <br>   return (RegisterClass (&amp;wc)) ; <br>   }  // TLineInitializeApplication <br> <br> <br>void TLineSetRange (HWND hWnd,  <br>                    int iBegin,  <br>                    int iEnd) <br>   { <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br> <br>   ILineSetRange (pTLine-&gt;hWndILine, iBegin, iEnd) ; <br>   TLGetSystemTimeN (hWnd, iBegin, &amp;pTLine-&gt;SystemTimeBegin) ; <br>   TLGetSystemTimeN (hWnd, iEnd, &amp;pTLine-&gt;SystemTimeEnd) ; <br>   } <br> <br> <br>void TLineSetStart (HWND hWnd, <br>                    int iStart) <br>   { <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br>   ILineSetStart (pTLine-&gt;hWndILine, iStart) ; <br>   } <br> <br> <br>void TLineSetStop (HWND hWnd, <br>                   int iStop) <br>   { <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br>   ILineSetStop (pTLine-&gt;hWndILine, iStop) ; <br>   } <br> <br> <br>int TLineStart (HWND hWnd) <br>   { <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br> <br>   return (ILineStart (pTLine-&gt;hWndILine)) ; <br>   } <br> <br> <br>int TLineStop (HWND hWnd) <br>   { <br>   PTLINE         pTLine ; <br> <br>   pTLine = TLData (hWnd) ; <br> <br>   return (ILineStop (pTLine-&gt;hWndILine)) ; <br>   } <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
