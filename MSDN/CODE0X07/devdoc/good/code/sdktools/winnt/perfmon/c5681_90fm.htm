<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADDLINE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5692"></a>ADDLINE.C</h2>
<pre><code>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include "perfmon.h" <br>#include "addline.h" <br> <br>#include "alert.h"      // for AlertInsertLine, AlertDeleteLine <br>#include "grafdata.h"   // for ChartInsertLine, ChartDeleteLine <br>#include "graph.h"      // for SizeGraphComponents <br>#include "legend.h"     // for LegendAddItem <br>#include "line.h"       // for LineAllocate, LineFree. <br>#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines <br>#include "perfdata.h"   // for QueryPerformanceData <br>#include "perfmops.h"   // for dlg_error_box <br>#include "playback.h"   // for PlaybackLines <br>#include "report.h"     // for ReportInsertLine, ReportDeleteLine <br>#include "system.h"     // for SystemGet <br>#include "utils.h" <br>#include "playback.h"   // for PlayingBackLog <br>#include "counters.h" <br>#include "pmhelpid.h"   // Help IDs <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#ifdef ADVANCED_PERFMON <br>#define ADDLINEDETAILLEVEL    PERF_DETAIL_WIZARD <br>#else <br>#define ADDLINEDETAILLEVEL    PERF_DETAIL_NOVICE <br>#endif <br> <br>#define iInitialExplainLen    256 <br> <br>// defines used in owner-drawn items <br>#define OWNER_DRAWN_ITEM      2 <br>#define OWNER_DRAW_FOCUS      1 <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br>// defined in PerfData.c <br>extern WCHAR   NULL_NAME[] ; <br> <br> <br>COLORREF argbColors[] =  <br>   { <br>   RGB (0xff, 0x00, 0x00),  <br>   RGB (0x00, 0x80, 0x00),  <br>   RGB (0x00, 0x00, 0xff),  <br>   RGB (0xff, 0xff, 0x00),  <br>   RGB (0xff, 0x00, 0xff),  <br>   RGB (0x00, 0xff, 0xff),  <br>   RGB (0x80, 0x00, 0x00),  <br>   RGB (0x40, 0x40, 0x40),  <br>   RGB (0x00, 0x00, 0x80),  <br>   RGB (0x80, 0x80, 0x00),  <br>   RGB (0x80, 0x00, 0x80),  <br>   RGB (0x00, 0x80, 0x80),  <br>   RGB (0x40, 0x00, 0x00),  <br>   RGB (0x00, 0x40, 0x00),  <br>   RGB (0x00, 0x00, 0x40),  <br>   RGB (0x00, 0x00, 0x00) <br>   } ; <br> <br> <br>TCHAR *apszScaleFmt[] = <br>   { <br>   TEXT("%6.6f"), <br>   TEXT("%5.5f"), <br>   TEXT("%4.4f"), <br>   TEXT("%3.3f"), <br>   TEXT("%2.2f"), <br>   TEXT("%1.1f"), <br>   TEXT("%2.1f"), <br>   TEXT("%3.1f"), <br>   TEXT("%4.1f"), <br>   TEXT("%5.1f"), <br>   TEXT("%6.1f"), <br>   TEXT("%7.1f") <br>   } ; <br>#define DEFAULT_SCALE 0 <br>#define NUMBER_OF_SCALE sizeof(apszScaleFmt)/sizeof(apszScaleFmt[0]) <br> <br>int               iLineType ; <br>static PPERFDATA  pPerfData ; <br>PPERFSYSTEM       pSystem ; <br>PLINESTRUCT       pLineEdit ; <br>PPERFSYSTEM       *ppSystemFirst ; <br>PLINEVISUAL       pVisual ; <br> <br>#define bEditLine (pLineEdit != NULL) <br> <br> <br>BOOL              ComputerChange ; <br>LPTSTR            pCurrentSystem ; <br> <br>//=============================// <br>// Alert-related locals        // <br>//=============================// <br> <br> <br>BOOL           bAlertOver ;         // over or under? <br>FLOAT          eAlertValue ;        // value to compare <br>BOOL           bEveryTime ;         // run every time or once? <br> <br>// program to run;  <br>LPTSTR          pszAlertProgram ;   <br> <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define InChartAdd()             \ <br>   (iLineType == LineTypeChart) <br> <br> <br>#define InAlertAdd()             \ <br>   (iLineType == LineTypeAlert) <br> <br>#define InReportAdd()            \ <br>   (iLineType == LineTypeReport) <br> <br> <br> <br> <br>#define NumColorIndexes()     \ <br>   (sizeof (argbColors) / sizeof (argbColors[0])) <br> <br>#define NumWidthIndexes()  5 <br> <br>#define NumStyleIndexes()  4 <br> <br> <br>//==========================================================================// <br>//                              Forward Declarations                        // <br>//==========================================================================// <br> <br>BOOL /*static*/ OnObjectChanged (HDLG hDlg) ; <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>PPERFINSTANCEDEF ParentInstance (PPERFINSTANCEDEF pInstance) <br>   {  // ParentInstance <br>   PPERFOBJECT          parent_obj ; <br>   PPERFINSTANCEDEF     parent_instance ; <br>   PERF_COUNTER_BLOCK   *counter_blk; <br>   LONG                 i ; <br> <br>   parent_obj =  <br>      GetObjectDefByTitleIndex (pPerfData,  <br>                                pInstance-&gt;ParentObjectTitleIndex) ; <br>   if (!parent_obj) <br>      return (NULL) ; <br> <br> <br>   // Then get the parent instance. <br>   // NOTE: can use unique ID field to match here instead <br>   // of name compare. <br>   for (i = 0,  <br>        parent_instance = (PERF_INSTANCE_DEFINITION *) ( (PBYTE)parent_obj <br>        + parent_obj-&gt;DefinitionLength); <br>        i &lt; parent_obj-&gt;NumInstances; <br>        i++, parent_instance = (PERF_INSTANCE_DEFINITION *) ( (PBYTE)counter_blk <br>        + counter_blk-&gt;ByteLength)) <br>      {  // for <br>      counter_blk = (PERF_COUNTER_BLOCK *) ( (PBYTE)parent_instance <br>                   + parent_instance-&gt;ByteLength); <br>     if ((DWORD)i == pInstance-&gt;ParentObjectInstance) <br>        return (parent_instance) ; <br>     } <br> <br>   return (NULL) ; <br>   }  // ParentInstance <br> <br> <br>PPERFOBJECT SelectedObject (HWND hWndObjects,  <br>                            LPTSTR lpszObjectName) <br>/* <br>   Effect:        Return the pObject associated with the currently selected <br>                  combo-box item of hWndObjects. Set lpszObjectName to  <br>                  the object's name. <br> <br>                  If no item is selected in the combobox, return NULL. <br> <br>   Assert:        The pObject for each CB item was added when the string <br>                  was added to the CB, by CBLoadObjects. <br> <br>   See Also:      LoadObjects. <br>*/ <br>   {  // SelectedObject <br>   int            iIndex ; <br> <br>   iIndex = CBSelection (hWndObjects) ; <br>   if (iIndex == CB_ERR) <br>      return (NULL) ; <br> <br>   if (lpszObjectName) <br>      CBString (hWndObjects, iIndex, lpszObjectName) ; <br> <br>   return ((PPERFOBJECT) CBData (hWndObjects, iIndex)) ; <br>   }  // SelectedObject <br> <br> <br> <br>PPERFCOUNTERDEF SelectedCounter (HWND hWndCounters,  <br>                                 LPTSTR lpszCounterName) <br>/* <br>   Effect:        Return the pCounter associated with the currently selected <br>                  LB item of hWndCounters. Set lpszCounterName to  <br>                  the Counter's name. <br> <br>                  If no item is selected in the listbox, return NULL. <br> <br>   Assert:        The pCounter for each LB item was added when the string <br>                  was added to the LB, by LoadCounters. <br> <br>   See Also:      LoadCounters. <br>*/ <br>   {  // SelectedCounter <br>   int            iIndex ; <br> <br>   iIndex = LBSelection (hWndCounters) ; <br>   if (iIndex == LB_ERR) <br>      return (NULL) ; <br> <br>   if (lpszCounterName) <br>      LBString (hWndCounters, iIndex, lpszCounterName) ; <br>   return ((PPERFCOUNTERDEF) LBData (hWndCounters, iIndex)) ; <br>   }  // SelectedCounter <br> <br> <br> <br>void VisualIncrement (PLINEVISUAL pVisual) <br>/* <br>   Effect:        Cycle through the combinations of color, width, and <br>                  style to distinguish between lines.  The color attributes <br>                  are like a number: <br>                        &lt;style&gt; &lt;width&gt; &lt;color&gt; <br> <br>                  Since color is the LSB, it is always incremented. The <br>                  others are incremented whenever the color rolls over. <br> <br>                  If a current index is -1, that means don't increment <br>                  that visual attribute. <br>*/ <br>   {  // VisualIncrement <br>   pVisual-&gt;iColorIndex =  <br>      (pVisual-&gt;iColorIndex + 1) % NumColorIndexes () ; <br> <br>   if (pVisual-&gt;iColorIndex) <br>      return ; <br> <br> <br>   if (pVisual-&gt;iWidthIndex == -1) <br>      return ; <br> <br> <br>   pVisual-&gt;iWidthIndex = <br>      (pVisual-&gt;iWidthIndex + 1) % NumWidthIndexes () ; <br> <br>   if (pVisual-&gt;iWidthIndex) <br>       return ; <br> <br> <br>   if (pVisual-&gt;iStyleIndex == -1) <br>      return ; <br> <br> <br>   pVisual-&gt;iStyleIndex =  <br>      (pVisual-&gt;iStyleIndex + 1) % NumStyleIndexes () ; <br>   }  // VisualIncrement <br> <br> <br>COLORREF LineColor (int iColorIndex) <br>   { <br>   return (argbColors [iColorIndex]) ; <br>   } <br> <br> <br>int LineWidth (int iWidthIndex) <br>   { <br>   switch (iWidthIndex) <br>      {  // switch <br>      case 0: <br>          return (1) ; <br>          break ; <br> <br>      case 1: <br>          return (3) ; <br>          break ; <br> <br>      case 2: <br>          return (5) ; <br>          break ; <br> <br>      case 3: <br>          return (7) ; <br>          break ; <br> <br>      case 4: <br>          return (9) ; <br>          break ; <br>      }  // switch <br>   }  // LineWidth <br> <br> <br> <br>int LineStyle (int iStyleIndex) <br>   { <br>   return (iStyleIndex) ; <br>   } <br> <br> <br>BOOL /*static*/ LoadInstances (HDLG hDlg) <br>   { <br>   PPERFOBJECT       pObject ; <br>   PPERFINSTANCEDEF  pInstance, pInstanceParent ; <br>   TCHAR             szInstance [256], szInstanceParent [256] ; <br>   TCHAR             szCompositeName [256 * 2] ; <br>   TCHAR             szInstCompositeName [256 * 2] ; <br>                            <br>   LONG              iInstance ; <br>   UINT              iIndex ; <br> <br>   int               xTextExtent = 0 ; <br>   int               currentTextExtent ; <br>   HFONT             hFont ; <br>   HDC               hDC = 0 ; <br>   HWND              hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT); <br>   HWND              hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE); <br> <br>   // turn off horiz. scrollbar <br>   LBSetHorzExtent (hWndInstances, 0) ; <br>   LBReset (hWndInstances) ; <br> <br>   pObject = SelectedObject (hWndObjects, NULL) ; <br>   if (!pObject) <br>      return (FALSE) ; <br> <br>   if (pObject-&gt;NumInstances &lt;= 0) <br>      { <br>      MLBSetSelection (hWndInstances, 0, TRUE) ; <br>      return (FALSE) ; <br>      } <br> <br>   // turn off Listbox redraw <br>   LBSetRedraw (hWndInstances, FALSE) ; <br> <br>   if (bEditLine) <br>      { <br>      if (pLineEdit-&gt;lnObject.NumInstances &gt; 0) <br>         { <br>         if (pLineEdit-&gt;lnInstanceDef.ParentObjectTitleIndex) <br>            { <br>            // Get the Parent Object Instance Name. <br>            // and prefix it to the Instance Name, to make <br>            // the string we want to display. <br>            TSPRINTF (szInstCompositeName, <br>                     TEXT("%s ==&gt; %s"), <br>                     pLineEdit-&gt;lnPINName, <br>                     pLineEdit-&gt;lnInstanceName) ; <br>            } <br>         else <br>            { <br>            lstrcpy (szInstCompositeName, pLineEdit-&gt;lnInstanceName) ; <br>            } <br>         } <br>      else <br>         { <br>         szInstCompositeName[0] = TEXT('\0'); <br>         } <br>      } <br> <br>   if (!bEditLine &amp;&amp; (hDC = GetDC (hWndInstances))) <br>      { <br>      hFont = (HFONT)SendMessage(hWndInstances, WM_GETFONT, 0, 0L); <br>      if (hFont) <br>         SelectObject(hDC, hFont); <br>      } <br> <br> <br>   for (iInstance = 0, pInstance = FirstInstance (pObject) ; <br>        iInstance &lt; pObject-&gt;NumInstances;  <br>        iInstance++, pInstance = NextInstance (pInstance)) <br>      {  // for <br>      GetInstanceNameStr (pInstance, szInstance) ; <br>      pInstanceParent = ParentInstance (pInstance) ; <br>     <br>      if (pInstanceParent) <br>         { <br>         GetInstanceNameStr (pInstanceParent, szInstanceParent) ; <br>         TSPRINTF (szCompositeName, TEXT("%s ==&gt; %s"),  <br>                   szInstanceParent, szInstance) ; <br>         } <br>     else <br>        lstrcpy (szCompositeName, szInstance) ; <br> <br>  iIndex = LBAdd (hWndInstances, szCompositeName) ; <br>   if (iIndex != LB_ERR) <br>      { <br>      LBSetData (hWndInstances, iIndex, (LPARAM) pInstance) ; <br>      } <br>  <br>   // get the biggest text width <br>   if (hDC) <br>      { <br>      currentTextExtent = TextWidth (hDC, szCompositeName) + xScrollWidth / 2  ; <br>      if (currentTextExtent &gt; xTextExtent) <br>         { <br>         xTextExtent = currentTextExtent ; <br>         } <br>      } <br>   }  // for <br> <br>   if (hDC) <br>      { <br>      // turn on horiz. scrollbar if necessary... <br>      LBSetHorzExtent (hWndInstances, xTextExtent) ; <br>      ReleaseDC (hWndInstances, hDC) ; <br>      } <br> <br> <br>   if (!bEditLine || szInstCompositeName[0] == TEXT('\0')) <br>      { <br>      MLBSetSelection (hWndInstances, 0, TRUE) ; <br>      } <br>   else <br>      { <br>      BOOL bSetSelection = TRUE ; <br> <br>      iIndex = LBFind (hWndInstances, szInstCompositeName) ; <br>      if (iIndex == LB_ERR) <br>         { <br>         if (bEditLine) <br>            { <br>            bSetSelection = FALSE ; <br>            } <br>         iIndex = 0 ; <br>         } <br> <br>      if (bSetSelection) <br>         { <br>         MLBSetSelection (hWndInstances, iIndex, TRUE) ; <br>         } <br> <br>      LBSetVisible (hWndInstances, iIndex) ; <br>      } <br> <br>   // turn on Listbox redraw <br>   LBSetRedraw (hWndInstances, TRUE) ;   <br> <br>   }  // LoadInstances <br> <br> <br>BOOL OnCounterChanged (HDLG hDlg) <br>/* <br>   Effect:        Perform any actions necessary when the counter has changed. <br>                  In particular, display the explanation for the counter <br>                  that has the focus rectangle. <br>*/ <br>   { <br>   LPTSTR         lpszText ; <br>   PPERFCOUNTERDEF pCounter ; <br>   int            iStatus ; <br>   int            iFocusIndex ; <br>   HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER); <br>   HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ; <br> <br>   iFocusIndex = LBFocus (hWndCounters) ; <br>   if  (iFocusIndex == LB_ERR) <br>      return (FALSE) ; <br> <br>   if (PlayingBackLog()) <br>      { <br>      DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ;    <br>      return (TRUE) ; <br>      } <br> <br>   pCounter = (PPERFCOUNTERDEF) LBData (hWndCounters, iFocusIndex) ; <br>   if ((!pCounter) || (pCounter == (PPERFCOUNTERDEF)LB_ERR)) <br>      return (FALSE) ; <br>    <br>   // no need to get help text before the button is clicked <br>   if (!bExplainTextButtonHit) <br>      return (FALSE) ; <br> <br>   // Create initial string <br>   lpszText = MemoryAllocate (iInitialExplainLen * sizeof (TCHAR)) ; <br> <br>   if (!lpszText) <br>      return (FALSE) ; <br> <br>   while (TRUE) <br>      { <br>      lpszText[0] = TEXT('\0') ; <br> <br>      #ifdef UNICODE <br>      iStatus = QueryPerformanceName  (pSystem, <br>                                       pCounter-&gt;CounterHelpTitleIndex, <br>                                       iLanguage, <br>                                       MemorySize (lpszText) / sizeof(TCHAR), <br>                                       lpszText, <br>                                       TRUE) ; <br>      #else <br>      iStatus = QueryPerformanceNameW (pSystem, <br>                                       pCounter-&gt;CounterHelpTitleIndex, <br>                                       iLanguage, <br>                                       MemorySize (lpszText), <br>                                       lpszText, <br>                                       TRUE) ; <br>      #endif <br> <br>      if (iStatus == ERROR_SUCCESS) <br>         break ; <br> <br>      if (iStatus == ERROR_MORE_DATA) <br>         lpszText =  <br>            MemoryResize (lpszText,  <br>                          MemorySize (lpszText) + iInitialExplainLen) ; <br>      else <br>         break ; <br>      }  // while <br> <br>   // Don't use my DialogSetString, it won't handle such large strings. <br>   SetDlgItemText (hDlg, IDD_ADDLINEEXPLAIN, lpszText) ; <br>   MemoryFree (lpszText) ; <br> <br>   return (TRUE) ; <br>   }  // OnCounterChanged <br> <br> <br> <br>BOOL LoadCounters (HDLG hDlg,  <br>                   UINT iSelectCounterDefn) <br>   {  // LoadCounters <br>   PPERFOBJECT       pObject ; <br> <br>   TCHAR             szCounterName [256] ; <br>   TCHAR             szDefaultCounterName [256] ; <br>   PPERFCOUNTERDEF   pCounter ; <br>   UINT              i ; <br>   int               iIndex ; <br>   int               xTextExtent = 0 ; <br>   int               currentTextExtent ; <br>   HFONT             hFont ; <br>   HDC               hDC = 0 ; <br>   BOOL              bSetSelection = TRUE ; <br>   HWND              hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT); <br>   HWND              hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER); <br> <br> <br>   strclr (szDefaultCounterName) ; <br> <br>   // turn off horiz. scrollbar <br>   LBSetHorzExtent (hWndCounters, 0) ; <br>   LBReset (hWndCounters) ; <br> <br>   pObject = SelectedObject (hWndObjects, NULL) ; <br>   if (!pObject) <br>      return (FALSE) ; <br> <br>   if (!bEditLine &amp;&amp; (hDC = GetDC (hWndCounters))) <br>      { <br>      hFont = (HFONT)SendMessage(hWndCounters, WM_GETFONT, 0, 0L); <br>      if (hFont) <br>         SelectObject(hDC, hFont); <br>      } <br> <br>   // turn off Listbox redraw <br>   LBSetRedraw (hWndCounters, FALSE) ;   <br> <br>   for (i = 0, pCounter = FirstCounter (pObject) ; <br>        i &lt; pObject-&gt;NumCounters ; <br>        i++, pCounter = NextCounter (pCounter)) <br>      {  // for <br>      if (pCounter-&gt;CounterType != PERF_SAMPLE_BASE &amp;&amp; <br>          pCounter-&gt;CounterType != PERF_COUNTER_NODATA &amp;&amp; <br>          pCounter-&gt;CounterType != PERF_AVERAGE_BASE &amp;&amp; <br>          pCounter-&gt;CounterType != PERF_COUNTER_QUEUELEN_TYPE &amp;&amp; <br>          pCounter-&gt;CounterType != PERF_COUNTER_MULTI_BASE &amp;&amp; <br>          pCounter-&gt;CounterType != PERF_RAW_BASE &amp;&amp; <br>          pCounter-&gt;DetailLevel &lt;= ADDLINEDETAILLEVEL) <br>         {   // if <br>         szCounterName[0] = TEXT('\0') ; <br>         QueryPerformanceName (pSystem,  <br>                                 pCounter-&gt;CounterNameTitleIndex,  <br>                                 0, sizeof (szCounterName) / sizeof(TCHAR), <br>                                 szCounterName, <br>                                 FALSE) ; <br>          <br>         // if szCounterName is not empty, add it to the listbox <br>         if (!strsame(szCounterName, NULL_NAME)) <br>            { <br>            iIndex = LBAdd (hWndCounters, szCounterName) ; <br>            LBSetData (hWndCounters, iIndex, (DWORD) pCounter) ; <br> <br>            // get the biggest text width <br>            if (hDC) <br>               { <br>               currentTextExtent = TextWidth (hDC, szCounterName) + xScrollWidth / 2 ; <br>               if (currentTextExtent &gt; xTextExtent) <br>                  { <br>                  xTextExtent = currentTextExtent ; <br>                  } <br>               } <br>        <br>            if (iSelectCounterDefn == i) <br>               lstrcpy (szDefaultCounterName, szCounterName) ; <br>            } // if szCounterName is not empty <br>         }   // if <br>      }  // for <br> <br>   if (bEditLine) <br>      lstrcpy (szDefaultCounterName, pLineEdit-&gt;lnCounterName) ; <br> <br>   iIndex = LBFind (hWndCounters, szDefaultCounterName) ; <br>   if (iIndex == LB_ERR) <br>      { <br>      if (bEditLine) <br>         { <br>         bSetSelection = FALSE ; <br>         } <br>      iIndex = 0 ; <br>      } <br> <br>   if (bSetSelection) <br>      { <br>      MLBSetSelection (hWndCounters, iIndex, TRUE) ; <br>      } <br>   LBSetVisible (hWndCounters, iIndex) ; <br>    <br>   if (hDC) <br>      { <br>      // turn on horiz. scrollbar if necessary... <br>      LBSetHorzExtent (hWndCounters, xTextExtent) ; <br>      ReleaseDC (hWndCounters, hDC) ; <br>      } <br> <br>   // turn on Listbox redraw <br>   LBSetRedraw (hWndCounters, TRUE) ;   <br> <br>   OnCounterChanged (hDlg) ; <br>   }  // LoadCounters <br> <br> <br> <br> <br>void LoadObjects (HDLG hDlg, <br>                  PPERFDATA pPerfData) <br>/* <br>   Effect:        Load into the object CB the objects for the current <br>                  pPerfData. <br>*/ <br>   { <br>   LPTSTR         lpszObject ; <br>   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT); <br> <br> <br>   lpszObject = bEditLine ? pLineEdit-&gt;lnObjectName : NULL ; <br> <br>   CBLoadObjects (hWndObjects,  <br>                  pPerfData, <br>                  pSystem, <br>                  ADDLINEDETAILLEVEL, <br>                  lpszObject, <br>                  FALSE) ; <br>   OnObjectChanged (hDlg) ; <br>//   UpdateWindow (hDlg) ; <br>   }  // LoadObjects <br> <br> <br> <br>void OnComputerChanged (HDLG hDlg) <br>   { <br> <br>   PPERFSYSTEM pLocalSystem; <br>   PPERFDATA   pLocalPerfData; <br> <br>   pLocalPerfData = pPerfData; <br>   pLocalSystem = GetComputer (hDlg, <br>                          IDD_ADDLINECOMPUTER, <br>                          TRUE, <br>                          &amp;pLocalPerfData, <br>                          ppSystemFirst) ; <br>   if (pLocalSystem &amp;&amp; pLocalPerfData) <br>      { <br>      pSystem = pLocalSystem; <br>      pPerfData = pLocalPerfData; <br>      LoadObjects (hDlg, pPerfData) ; <br>      ComputerChange = FALSE ; <br>      } <br> <br>   }  // OnComputerChanged <br> <br> <br>    <br> <br>BOOL AddOneChartLine (HWND hDlg, <br>                      PPERFCOUNTERDEF pCounter, <br>                      LPTSTR lpszCounter, <br>                      PPERFINSTANCEDEF pInstance)                      <br>   { <br>   TCHAR             szComputer [MAX_SYSTEM_NAME_LENGTH] ; <br> <br>//   PPERFOBJECT       pObject ; <br>   PERF_OBJECT_TYPE       UNALIGNED *pObject ; <br>   TCHAR             szObject [PerfObjectLen] ; <br> <br>   TCHAR             szInstance [256] ; <br> <br>   PLINE             pLine ; <br>//   int               i ; <br>   int               iCounterIndex ; <br>   int               j ; <br> <br>   PPERFINSTANCEDEF  pInstanceParent ; <br>   PERF_COUNTER_BLOCK *pCounterBlock ; <br>   TCHAR          szInstanceParent [256] ; <br>   TCHAR          szObjectParent [256] ; <br>   HWND           hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ; <br>   HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ; <br>   HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ; <br>   HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ; <br>   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT); <br> <br> <br>   //=============================// <br>   // Get selected data values    // <br>   //=============================// <br> <br> <br> <br>   DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ; <br> <br>   pObject = (PERF_OBJECT_TYPE UNALIGNED *)SelectedObject (hWndObjects, szObject) ; <br>   if (!pObject) <br>      return (FALSE) ; <br> <br>   if (pInstance) <br>      GetInstanceNameStr (pInstance, szInstance) ; <br> <br>   //=============================// <br>   // Allocate the line           // <br>   //=============================// <br> <br>   pLine = LineAllocate () ; <br>   if (!pLine) <br>      { <br>      DlgErrorBox (hDlg, ERR_NO_MEMORY); <br>      return (FALSE) ; <br>      } <br> <br> <br>   //=============================// <br>   // Set line's data values      // <br>   //=============================// <br> <br>   pLine-&gt;iLineType = iLineType ; <br>   pLine-&gt;lnSystemName = StringAllocate (szComputer) ; <br> <br>   pLine-&gt;lnObject = *pObject ; <br>   pLine-&gt;lnObjectName = StringAllocate (szObject) ; <br> <br>   pLine-&gt;lnCounterDef = *pCounter ; <br>   pLine-&gt;lnCounterName = StringAllocate (lpszCounter) ; <br> <br> <br>   if (pObject-&gt;NumInstances &gt; 0 &amp;&amp; pInstance) <br>      { <br>      pLine-&gt;lnInstanceDef = *pInstance ;           <br>      pLine-&gt;lnInstanceName = StringAllocate (szInstance) ; <br> <br>      pLine-&gt;lnUniqueID = pInstance-&gt;UniqueID ; <br> <br>      if (pInstance-&gt;ParentObjectTitleIndex) <br>         { <br>         szObjectParent[0] = (TCHAR)'\0'; <br>         QueryPerformanceName (pSystem, <br>                               pInstance-&gt;ParentObjectTitleIndex, <br>                               0,  PerfObjectLen, szObjectParent, FALSE) ; <br>         pLine-&gt;lnParentObjName = StringAllocate (szObjectParent) ; <br>         } <br> <br>      pInstanceParent = ParentInstance (pInstance) ; <br>      if (pInstanceParent) <br>         { <br>         GetInstanceNameStr (pInstanceParent, szInstanceParent) ; <br>         if (pInstance-&gt;ParentObjectTitleIndex) <br>            { <br>            pLine-&gt;lnPINName = StringAllocate (szInstanceParent) ; <br>            } <br>         } <br>      }  // if <br> <br>   pLine-&gt;lnCounterType = pCounter-&gt;CounterType; <br>   pLine-&gt;lnCounterLength = pCounter-&gt;CounterSize; <br> <br>   pLine-&gt;lnOldTime = pPerfData-&gt;PerfTime.HighPart &lt;&lt; 32 + <br>      pPerfData-&gt;PerfTime.LowPart ; <br>   pLine-&gt;lnNewTime = pLine-&gt;lnOldTime ; <br> <br>   for (j = 0 ; j &lt; 2 ; j++) <br>      { <br>      pLine-&gt;lnaCounterValue[j] = (LONGLONG) 0 ; <br>      } <br> <br> <br>   //=============================// <br>   // Chart-related Values        // <br>   //=============================// <br> <br>   pLine-&gt;iScaleIndex = CBSelection (hWndScales) ; <br>   if (pLine-&gt;iScaleIndex == 0) <br>      { <br>      // use the default scale <br>      pLine-&gt;eScale = (FLOAT) pow ((double)10.0, <br>          (double)pCounter-&gt;DefaultScale) ; <br>      } <br>   else <br>      { <br>      pLine-&gt;eScale = DialogFloat (hDlg, IDD_ADDLINESCALE, NULL) ; <br>      } <br> <br>   if (pObject-&gt;NumInstances &gt; 0 &amp;&amp; pInstance) <br>      { <br>      pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pInstance + <br>                       pInstance-&gt;ByteLength); <br>      } <br>   else <br>      { <br>      pCounterBlock = (PERF_COUNTER_BLOCK *) ( (PBYTE) pObject + <br>                       pObject-&gt;DefinitionLength); <br>      } <br> <br>   if (pLine-&gt;lnCounterLength &lt;= 4) <br>      { <br>      pLine-&gt;lnaOldCounterValue[0] = <br>               * ( (DWORD FAR *) ( (PBYTE)pCounterBlock + <br>               pCounter[0].CounterOffset)); <br>      pLine-&gt;lnaOldCounterValue[0] &amp;= (LONGLONG) (0x0ffffffff); <br>      } <br>   else <br>      { <br>      pLine-&gt;lnaOldCounterValue[0] = <br>              * ( (LONGLONG UNALIGNED *) ( (PBYTE)pCounterBlock + <br>              pCounter[0].CounterOffset)); <br>      } <br> <br>   // Get second counter, only if we are not at <br>   // the end of the counters; some computations <br>   // require a second counter <br> <br>   iCounterIndex = CounterIndex (pCounter, (PPERFOBJECT) pObject) ; <br>   if ((UINT) iCounterIndex &lt; pObject-&gt;NumCounters - 1 &amp;&amp; <br>       iCounterIndex != -1) <br>      { <br>      if (pLine-&gt;lnCounterLength &lt;= 4) <br>         { <br>         pLine-&gt;lnaOldCounterValue[1] = <br>                  * ( (DWORD FAR *) ( (PBYTE)pCounterBlock + <br>                  pCounter[1].CounterOffset)); <br>         pLine-&gt;lnaOldCounterValue[1] &amp;= (LONGLONG) (0x0ffffffff); <br>         } <br>      else <br>         pLine-&gt;lnaOldCounterValue[1] = <br>                 * ( (LONGLONG UNALIGNED *) ( (PBYTE)pCounterBlock + <br>                 pCounter[1].CounterOffset)); <br>      } <br> <br> <br>   pLine-&gt;lnaOldCounterValue[0] = pLine-&gt;lnaCounterValue[0]; <br>   pLine-&gt;lnaOldCounterValue[1] = pLine-&gt;lnaCounterValue[1]; <br> <br>   //=============================// <br>   // Visual Values               // <br>   //=============================// <br> <br>   pLine-&gt;Visual.iColorIndex = CBSelection (hWndColors) ; <br>   pLine-&gt;Visual.crColor = LineColor (pLine-&gt;Visual.iColorIndex) ; <br> <br>   pLine-&gt;Visual.iWidthIndex = CBSelection (hWndWidths) ; <br>   pLine-&gt;Visual.iWidth = LineWidth (pLine-&gt;Visual.iWidthIndex) ; <br> <br>   pLine-&gt;Visual.iStyleIndex = CBSelection (hWndStyles) ; <br>   pLine-&gt;Visual.iStyle = LineStyle (pLine-&gt;Visual.iStyleIndex) ; <br> <br>   *pVisual = pLine-&gt;Visual ; <br>   if (!bEditLine) <br>      VisualIncrement (pVisual) ; <br> <br>   CBSetSelection (hWndColors, pVisual-&gt;iColorIndex) ; <br>   CBSetSelection (hWndWidths, pVisual-&gt;iWidthIndex) ; <br>   CBSetSelection (hWndStyles, pVisual-&gt;iStyleIndex) ; <br> <br>   if (iLineType == LineTypeChart) <br>      { <br>      pLine-&gt;hPen = LineCreatePen (NULL, &amp;(pLine-&gt;Visual), FALSE) ; <br>      } <br> <br>   //=============================// <br>   // Alert Related Values        // <br>   //=============================// <br> <br>   if (iLineType == LineTypeAlert) <br>      { <br>      pLine-&gt;bAlertOver = bAlertOver ; <br>      pLine-&gt;eAlertValue = eAlertValue ; <br>      pLine-&gt;bEveryTime =  <br>         IsDlgButtonChecked (hDlg, IDD_ADDLINEPROGRAMEVERYTIME) ; <br>      pLine-&gt;bAlerted = FALSE ; <br>      pLine-&gt;hBrush = CreateSolidBrush (pLine-&gt;Visual.crColor) ; <br>      if (!PlayingBackLog ()) <br>         { <br>         pLine-&gt;lpszAlertProgram = StringAllocate (pszAlertProgram) ; <br>         } <br>      else <br>         { <br>         pLine-&gt;lpszAlertProgram = NULL ; <br>         } <br>      } <br>   //=============================// <br>   // Insert the line!            // <br>   //=============================// <br> <br>   if (InsertLine (pLine) == FALSE) <br>      { <br>      // no inert occurred due to either line already existed <br>      // or error detected. <br>      LineFree (pLine) ; <br>      } <br>   else <br>      { <br>      if (pSystem-&gt;lpszValue &amp;&amp; pSystem-&gt;FailureTime == 0) <br>         { <br>         if (strsame(pSystem-&gt;lpszValue, TEXT("Global"))) <br>            { <br>            // take out the "Global" string <br>            *(pSystem-&gt;lpszValue) = 0 ; <br>            } <br>         AppendObjectToValueList ( <br>            pLine-&gt;lnObject.ObjectNameTitleIndex, <br>            pSystem-&gt;lpszValue) ; <br>         } <br>      } <br>   }  // AddOneChartLine <br> <br> <br>BOOL AddCounter (HWND hDlg, <br>                      PPERFCOUNTERDEF pCounter, <br>                      LPTSTR lpszCounter) <br>   {  // AddCounter <br>   int               iInstanceIndex ; <br>   int               iInstanceNum ; <br>   PPERFINSTANCEDEF  pInstance ; <br>   HWND              hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE); <br> <br>   // NOTE: for now, we don't check for duplicate lines <br>   if (!IsCounterSupported (pCounter-&gt;CounterType)) <br>      { <br>      DlgErrorBox (hDlg, ERR_COUNTER_NOT_IMP); <br>      return (FALSE) ; <br>      } <br> <br> <br>   if ((iInstanceNum = LBNumItems (hWndInstances)) &amp;&amp; iInstanceNum != LB_ERR) <br>      { <br> <br>      if (iInstanceNum &gt; 1) <br>         { <br>         // delay some of the insert actions for performacne improvement <br>         bDelayAddAction = TRUE ; </code></pre>
<p>
</p>
<pre><code><br>         if (InChartAdd()) <br>            { <br>            LegendSetRedraw (hWndGraphLegend, FALSE) ; <br>            } <br>         else if (InAlertAdd()) <br>            { <br>            LegendSetRedraw (hWndAlertLegend, FALSE) ; <br>            } <br>         } <br> <br>      for (iInstanceIndex = 0 ; <br>           iInstanceIndex &lt; iInstanceNum ; <br>           iInstanceIndex++) <br>         {  // for <br>         if (LBSelected (hWndInstances, iInstanceIndex)) <br>            {  // if <br>            pInstance = (PPERFINSTANCEDEF) LBData (hWndInstances, iInstanceIndex) ; <br>            if (pInstance == (PPERFINSTANCEDEF) LB_ERR) <br>               { <br>               pInstance = NULL; <br>               } <br>            AddOneChartLine (hDlg, pCounter, lpszCounter, pInstance) ; <br>            }  // if <br>         }  // for <br>       <br>      if (bDelayAddAction) <br>         { <br>         // now do the post add-line actions <br>         bDelayAddAction = FALSE ; <br>         if (InReportAdd()) <br>            { <br>            PREPORT pReport ; <br>       <br>            pReport = ReportData (hWndReport) ; <br>            ReportAddAction (pReport) ; <br>            } <br>         else if (InChartAdd()) <br>            { <br>            GraphAddAction () ; <br>            LegendSetRedraw (hWndGraphLegend, TRUE) ; <br>            } <br>         else if (InAlertAdd()) <br>            { <br>            AlertAddAction () ; <br>            LegendSetRedraw (hWndAlertLegend, TRUE) ; <br>            } <br>         } <br>      } <br>   else <br>      { <br>      pInstance = NULL; <br>      AddOneChartLine (hDlg, pCounter, lpszCounter, pInstance) ; <br>      } <br> <br>   return (TRUE) ; <br>   }  // AddCounter <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>BOOL /*static*/ OnInitDialog (HWND hDlg) <br>   { <br>   int            i ; <br>   FLOAT          ScaleFactor ; <br>   TCHAR          tempBuff[ShortTextLen] ; <br>   TCHAR          szCaption [WindowCaptionLen] ; <br>   TCHAR          szRemoteComputerName[MAX_COMPUTERNAME_LENGTH + 3] ; <br>   HWND           hWndComputer = DialogControl (hDlg, IDD_ADDLINECOMPUTER); <br>   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT); <br>   HWND           hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE); <br>   HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER); <br>   HWND           hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ; <br>   HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ; <br>   HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ; <br>   HWND           hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ; <br> <br>   // this is used to tell UPdateLines not to mark any <br>   // system as not used <br>   bAddLineInProgress = TRUE ; <br>    <br>   // turn this off until the Explain text button is clicked <br>   bExplainTextButtonHit = FALSE ; <br> <br>   if (InAlertAdd()) <br>      { <br>      pszAlertProgram = (LPTSTR) MemoryAllocate (FilePathLen * sizeof (TCHAR)) ; <br>      } <br> <br>   if (!PlayingBackLog ()) <br>      pPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ; <br> <br>   pSystem = NULL ; <br> <br>   if (!bEditLine &amp;&amp; PlayingBackLog()) <br>      { <br>      pPerfData = DataFromIndexPosition (&amp;(PlaybackLog.StartIndexPos), NULL) ; <br>      GetPerfComputerName(pPerfData, szRemoteComputerName); <br>      DialogSetString (hDlg, IDD_ADDLINECOMPUTER, szRemoteComputerName); <br>      } <br>   else <br>      { <br>      if (bEditLine) <br>         { <br>         DialogSetString (hDlg, IDD_ADDLINECOMPUTER, <br>            pLineEdit-&gt;lnSystemName) ; <br>         } <br>      else <br>         { <br>//Try to use current system (if any), otherwise computer specified on commandline (if any), <br>//otherwise local computer <br>         DialogSetString (hDlg, IDD_ADDLINECOMPUTER, <br>            pCurrentSystem ? <br>                pCurrentSystem : <br>                (( CmdLineComputerName[0] ) ? <br>                   CmdLineComputerName : <br>                   LocalComputerName )) ; <br>         } <br>      } <br> <br>   OnComputerChanged (hDlg) ; <br> <br>   //=============================// <br>   // Set default line values     // <br>   //=============================// <br> <br>   bAlertOver = bEditLine ? pLineEdit-&gt;bAlertOver : TRUE ; <br>   bEveryTime = bEditLine ? pLineEdit-&gt;bEveryTime : TRUE ; <br> <br>   //=============================// <br>   // Fill line attribute CBs     // <br>   //=============================// <br> <br>   // Load the colors combobox, select the default color. <br>   for (i = 0 ; i &lt; NumColorIndexes () ; i++) <br>       CBAdd (hWndColors, i) ; <br>   CBSetSelection (hWndColors, pVisual-&gt;iColorIndex) ; <br> <br>   // Load the widths combobox, select the default width. <br>   for (i = 0 ; i &lt; NumWidthIndexes () ; i++) <br>      CBAdd (hWndWidths, i) ; <br>   CBSetSelection (hWndWidths, pVisual-&gt;iWidthIndex) ; <br> <br>   // Load the styles combobox, select the default style. <br>   for (i = 0 ; i &lt; NumStyleIndexes () ; i++) <br>      CBAdd (hWndStyles, i) ; <br>   CBSetSelection (hWndStyles, pVisual-&gt;iStyleIndex) ; <br> <br>#if (!WIDESTYLES) <br>   DialogEnable (hDlg, IDD_ADDLINESTYLE, pVisual-&gt;iWidthIndex == 0) ; <br>   DialogEnable (hDlg, IDD_ADDLINESTYLETEXT, pVisual-&gt;iWidthIndex == 0) ; <br> <br>   if (pVisual-&gt;iWidthIndex == 0 &amp;&amp; pVisual-&gt;iStyleIndex &gt; 0) <br>      { <br>      DialogEnable (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ; <br>      DialogEnable (hDlg, IDD_ADDLINEWIDTH, FALSE) ; <br>      } <br>#endif <br> <br>   // Init the scale combo box. <br> <br>   StringLoad (IDS_DEFAULT, tempBuff) ; <br>   CBAdd (hWndScales, tempBuff) ; <br> <br>   // we are formatting the scale factors during run-time so <br>   // the c-runtime library will pick up the default locale <br>   // decimal "charatcer". <br>   ScaleFactor = (FLOAT)0.000001 ; <br>   for (i = 0 ; i &lt; NUMBER_OF_SCALE ; i++) <br>      { <br>      TSPRINTF(tempBuff, apszScaleFmt[i], ScaleFactor) ; <br>      ConvertDecimalPoint (tempBuff) ; <br>      ScaleFactor *= (FLOAT) 10.0 ; <br>      CBAdd (hWndScales, tempBuff) ; <br>      } <br> <br>   CBSetSelection (hWndScales, bEditLine ? pLineEdit-&gt;iScaleIndex : DEFAULT_SCALE) ; <br> <br>    <br>   CheckRadioButton (hDlg, IDD_ADDLINEIFOVER, IDD_ADDLINEIFUNDER,  <br>                     bAlertOver ? IDD_ADDLINEIFOVER: IDD_ADDLINEIFUNDER) ; <br>   CheckRadioButton (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, IDD_ADDLINEPROGRAMEVERYTIME,  <br>                     bEveryTime ? IDD_ADDLINEPROGRAMEVERYTIME: IDD_ADDLINEPROGRAMFIRSTTIME) ; <br> <br>   if (bEditLine) <br>      { <br>      DialogSetText (hDlg, IDD_ADDLINEADD, IDS_OK) ; <br>      DialogSetFloat (hDlg, IDD_ADDLINEIFVALUE, pLineEdit-&gt;eAlertValue) ; <br>      if (pLineEdit-&gt;lpszAlertProgram) <br>         DialogSetString (hDlg, IDD_ADDLINEPROGRAM,  <br>                          pLineEdit-&gt;lpszAlertProgram) ; <br> <br>      DialogEnable (hDlg, IDD_ADDLINECOMPUTERTEXT, FALSE) ; <br>      DialogEnable (hDlg, IDD_ADDLINECOMPUTER, FALSE) ; <br>      DialogEnable (hDlg, IDD_ADDLINEELLIPSES, FALSE) ;    <br>      DialogEnable (hDlg, IDD_ADDLINEOBJECTTEXT, FALSE) ;    <br>      DialogEnable (hDlg, IDD_ADDLINEOBJECT, FALSE) ;    <br>      DialogEnable (hDlg, IDD_ADDLINECOUNTERTEXT, FALSE) ;    <br>      DialogEnable (hDlg, IDD_ADDLINECOUNTER, FALSE) ;    <br>      DialogEnable (hDlg, IDD_ADDLINEINSTANCE, FALSE) ;    <br>      DialogEnable (hDlg, IDD_ADDLINEINSTANCETEXT, FALSE) ;    <br>      } <br>   else <br>      { <br>      // set the scroll limit on the edit box <br>      EditSetLimit (GetDlgItem(hDlg, IDD_CHOOSECOMPUTERNAME), <br>         MAX_SYSTEM_NAME_LENGTH-1) ; <br> <br>      } <br> <br>   if (PlayingBackLog()) <br>      { <br>      DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ;    <br>      } <br> <br>   //=============================// <br>   // LineType specific init      // <br>   //=============================// <br> <br>   switch (iLineType) <br>      { <br>      case LineTypeChart: <br>         dwCurrentDlgID = bEditLine ? <br>                  HC_PM_idDlgEditChartLine : HC_PM_idDlgEditAddToChart ; <br> <br>         StringLoad (bEditLine ?  <br>                     IDS_EDITCHART : IDS_ADDTOCHART, szCaption) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINEIFGROUP, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEIFVALUE, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEIFUNDER, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEIFOVER, FALSE) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAMGROUP, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAM, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAMEVERYTIME, FALSE) ; <br>         break ; <br> <br>      case LineTypeAlert: <br>         dwCurrentDlgID = bEditLine ? <br>                  HC_PM_idDlgEditAlertEntry : HC_PM_idDlgEditAddToAlert ; <br> <br>         StringLoad (bEditLine ?  <br>                     IDS_EDITALERT : IDS_ADDTOALERT, szCaption) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINESCALE, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINESCALETEXT, FALSE) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINEWIDTH, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINESTYLE, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINESTYLETEXT, FALSE) ; <br> <br>         if (PlayingBackLog ()) <br>            { <br>            DialogEnable (hDlg, IDD_ADDLINEPROGRAM, FALSE) ; <br>            DialogEnable (hDlg, IDD_ADDLINEPROGRAMGROUP, FALSE) ; <br>            DialogEnable (hDlg, IDD_ADDLINEPROGRAMEVERYTIME, FALSE) ; <br>            DialogEnable (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, FALSE) ; <br>            } <br> <br>         // set the scroll limit on the edit boxes <br> <br>         EditSetLimit (GetDlgItem(hDlg, IDD_ADDLINEIFVALUE), ShortTextLen) ; <br>         EditSetLimit (GetDlgItem(hDlg, IDD_ADDLINEPROGRAM), FilePathLen-1) ; <br> <br>         break ; <br> <br>      case LineTypeReport: <br> <br>         dwCurrentDlgID = HC_PM_idDlgEditAddToReport ; <br> <br>         StringLoad (bEditLine ?  <br>                     IDS_EDITREPORT : IDS_ADDTOREPORT, szCaption) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINEIFGROUP, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEIFVALUE, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEIFUNDER, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEIFOVER, FALSE) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAMGROUP, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAM, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEPROGRAMEVERYTIME, FALSE) ; <br> <br>         DialogShow (hDlg, IDD_ADDLINECOLOR, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINECOLORTEXT, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINESCALE, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINESCALETEXT, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEWIDTH, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINEWIDTHTEXT, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINESTYLE, FALSE) ; <br>         DialogShow (hDlg, IDD_ADDLINESTYLETEXT, FALSE) ; <br>         break ; <br>      }  // switch <br> <br>   SetWindowText (hDlg, szCaption) ; <br>   SendDlgItemMessage (hDlg,  <br>                       IDD_ADDLINEEXPLAIN, WM_SETFONT,  <br>                       (WPARAM) hFontScales, (LPARAM) FALSE) ; <br>   WindowCenter (hDlg) ; <br>   return (TRUE) ; <br>   }  // OnInitDialog <br> <br> <br>BOOL /*static*/ OnObjectChanged (HDLG hDlg) <br>/* <br>   Effect:        Perform any actions necessary when the user has selected <br>                  a new object category from the object CB, or when a default <br>                  object is first selected into the dialog. In particular, <br>                  find and load the counters, instances, etc., for this <br>                  object. <br> <br>   Called by:     OnInitDialog, AddLineDlgProc (in response to an  <br>                  IDM_ADDLINEOBJECT notification). <br>*/ <br>   {  // OnObjectChanged <br>   PPERFOBJECT    pObject ; <br>   HWND           hWndInstances = DialogControl (hDlg, IDD_ADDLINEINSTANCE); <br>   HWND           hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER); <br>   HWND           hWndObjects = DialogControl (hDlg, IDD_ADDLINEOBJECT); <br> <br>   LBReset (hWndInstances) ; <br>   LBReset (hWndCounters) ; <br> <br>   pObject = SelectedObject (hWndObjects, NULL) ; <br>   if (!pObject) <br>      return (FALSE) ; <br> <br>   LoadCounters (hDlg, (UINT)pObject-&gt;DefaultCounter) ; <br>   LoadInstances (hDlg) ;   <br> <br>   }  // OnObjectChanged <br> <br> <br> <br>void /*static*/ OnEllipses (HWND hDlg) <br>   { <br>   TCHAR          szComputer [256] ; <br> <br>   DialogText (hDlg, IDD_ADDLINECOMPUTER, szComputer) ; <br>   if (ChooseComputer (hDlg, szComputer))  <br>      {  // if <br>      SetHourglassCursor() ; <br>      DialogSetString (hDlg, IDD_ADDLINECOMPUTER, szComputer) ; <br>      OnComputerChanged (hDlg) ; <br>      }  // if <br>   } <br> <br>BOOL LineModifyAttributes (HWND hDlg, PLINE pLineToModify) <br>{ <br>   LINEVISUAL  LineVisual ; <br>   HPEN        hLinePen ; <br>   int         iScaleIndex ;        // chart attribute <br>   FLOAT      eScale ;             // chart attribute <br> <br>   BOOL        bLocalAlertOver ;         // alert attribute - over or under? <br>   FLOAT       eLocalAlertValue ;        // alert attribute - value to compare <br>   LPTSTR      lpLocalszAlertProgram ;   // alert attribute - program to run <br>   BOOL        bLocalEveryTime ;         // alert attribute - run every time or once? <br>   BOOL        bLocalAlerted ;           // alert attribute - alert happened on line? <br> <br>   HPEN        hTempPen ; <br>   LPTSTR      lpTempAlertProgram ; <br>   HWND        hWndColors = DialogControl (hDlg, IDD_ADDLINECOLOR) ; <br>   HWND        hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ; <br>   HWND        hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ; <br>   HWND        hWndScales = DialogControl (hDlg, IDD_ADDLINESCALE) ; <br>    <br>   //=============================// <br>   // Visual Values               // <br>   //=============================// <br> <br>   LineVisual.iColorIndex = CBSelection (hWndColors) ; <br>   LineVisual.crColor = LineColor (LineVisual.iColorIndex) ; <br> <br>   LineVisual.iWidthIndex = CBSelection (hWndWidths) ; <br>   LineVisual.iWidth = LineWidth (LineVisual.iWidthIndex) ; <br> <br>   LineVisual.iStyleIndex = CBSelection (hWndStyles) ; <br>   LineVisual.iStyle = LineStyle (LineVisual.iStyleIndex) ; <br> <br>   hLinePen = LineCreatePen (NULL, &amp;(LineVisual), FALSE) ; <br> <br>   //=============================// <br>   // Chart-related Values        // <br>   //=============================// <br>    <br>   if (InChartAdd()) <br>      { <br>      iScaleIndex = CBSelection (hWndScales) ; <br>      if (iScaleIndex == 0) <br>          { <br>          // use the default scale <br>          eScale = (FLOAT) pow ((double)10.0, <br>              (double)pLineToModify-&gt;lnCounterDef.DefaultScale) ; <br>          } <br>      else <br>          { <br>          eScale = DialogFloat (hDlg, IDD_ADDLINESCALE, NULL) ; <br>          } <br>      } <br> <br>   //=============================// <br>   // Alert Related Values        // <br>   //=============================// <br>    <br>   if (InAlertAdd()) <br>      { <br>      bLocalAlertOver = bAlertOver ; <br>      eLocalAlertValue = eAlertValue ; <br>      bLocalEveryTime = <br>         IsDlgButtonChecked (hDlg, IDD_ADDLINEPROGRAMEVERYTIME) ; <br>      bLocalAlerted = FALSE ; <br>      lpLocalszAlertProgram = StringAllocate (pszAlertProgram) ; <br>      } <br> <br>   // Just do it.. <br>   pLineToModify-&gt;Visual = LineVisual ; <br>   if (pLineToModify-&gt;hPen) <br>      { <br>      hTempPen = pLineToModify-&gt;hPen ; <br>      pLineToModify-&gt;hPen = hLinePen ; <br>      DeletePen (hTempPen) ; <br>      } <br> <br>   if (InChartAdd()) <br>      { <br>      pLineToModify-&gt;iScaleIndex = iScaleIndex ; <br>      pLineToModify-&gt;eScale = eScale ; <br> <br>      } <br> <br>   if (InAlertAdd()) <br>      { <br>      HBRUSH   hOldBrush; <br>      pLineToModify-&gt;bAlertOver = bLocalAlertOver ; <br>      pLineToModify-&gt;eAlertValue = eLocalAlertValue ; <br>      pLineToModify-&gt;bEveryTime = bLocalEveryTime ; <br>      pLineToModify-&gt;bAlerted = FALSE ; <br> <br>      hOldBrush = pLineToModify-&gt;hBrush ; <br>      pLineToModify-&gt;hBrush = CreateSolidBrush (pLineToModify-&gt;Visual.crColor) ; <br>      DeleteBrush (hOldBrush); <br> <br>      lpTempAlertProgram = pLineToModify-&gt;lpszAlertProgram ; <br>      pLineToModify-&gt;lpszAlertProgram = lpLocalszAlertProgram ; <br> <br>      if (lpTempAlertProgram) <br>         { <br>         MemoryFree (lpTempAlertProgram) ; <br>         } <br>      } <br> <br>   return (TRUE) ; <br> <br>} // LineModifyAttributes <br> <br>BOOL OnAddLines (HWND hDlg) <br>   {   <br>   PPERFCOUNTERDEF   pCounter ; <br>   TCHAR             szCounter [256] ; <br>   BOOL              bOK ; <br>   int               iCounter ; <br>   int               iCounterNum ; <br>   HWND              hWndCounters = DialogControl (hDlg, IDD_ADDLINECOUNTER); <br> <br>   if (ComputerChange) <br>      { <br>      // if computer has changed, don't want to continue <br>      // because the perfdata may have changed <br>      OnComputerChanged (hDlg) ; <br>      return (TRUE) ; <br>      } <br> <br>   //=============================// <br>   // Dialog Values Acceptable?   // <br>   //=============================// <br> <br>   if (InAlertAdd ()) <br>      { <br>      eAlertValue = DialogFloat (hDlg, IDD_ADDLINEIFVALUE, &amp;bOK) ; <br>      if (!bOK) <br>         { <br>         DlgErrorBox (hDlg, ERR_NEEDALERTVALUE); <br>         SetFocus (DialogControl (hDlg, IDD_ADDLINEIFVALUE)) ; <br>         return (FALSE) ; <br>         }  // if <br>      }  // if <br> <br>   if (bEditLine) <br>      { <br>      LineModifyAttributes (hDlg, pLineEdit) ; <br>      EndDialog (hDlg, TRUE) ; <br>      } <br> <br>      // If the user changed the textbox for computer name and pressed enter, <br>      // the OnAddLines function would be called without a check of the  <br>      // computer name. This solves that problem. <br>   else <br>      { <br> <br>      iCounterNum = LBNumItems (hWndCounters) ; <br>      for (iCounter = 0 ; <br>           iCounter &lt; iCounterNum ; <br>           iCounter++) <br>         {  // for <br>         // NOTE: for now, we don't check for duplicate lines <br>         if (LBSelected (hWndCounters, iCounter)) <br>            {  // if <br>            pCounter = (PPERFCOUNTERDEF) LBData (hWndCounters, iCounter) ; <br>            LBString (hWndCounters, iCounter, szCounter) ; <br> <br>            if (!IsCounterSupported (pCounter-&gt;CounterType)) <br>               { <br>               DlgErrorBox (hDlg, ERR_COUNTER_NOT_IMP); <br>               } <br>            else <br>               { <br>               AddCounter (hDlg, pCounter, szCounter) ; <br>               } <br>            }  // if <br>         }  // for <br>      DialogSetText (hDlg, IDCANCEL, IDS_DONE) ; <br>      } // else (not bEditLine) <br> <br>   if (InChartAdd ()) <br>      SizeGraphComponents (hWndGraph) ; <br>   if (InAlertAdd ()) <br>      SizeAlertComponents (hWndAlert) ; <br> <br>   WindowInvalidate (PerfmonViewWindow ()) ; <br> <br>   }  // OnAddLines <br> <br> <br>void OnExpandExplain (HWND hDlg) <br>/* <br>   Effect:        Perform actions needed when user clicks on the Explain... <br>                  button. In particular, expand the dialog size to  <br>                  uncover the explain edit box, and gray out the button. <br>*/ <br>   {  // OnExpandExplain <br>   RECT           rectWindow ; <br> <br>   // Disable button first <br>   DialogEnable (hDlg, IDD_ADDLINEEXPANDEXPLAIN, FALSE) ; <br> <br>   // go get the help text <br>   bExplainTextButtonHit = TRUE ; <br>   OnCounterChanged (hDlg) ; <br> <br>   GetWindowRect (hDlg, &amp;rectWindow) ; <br>   MoveWindow (hDlg, <br>               rectWindow.left, <br>               rectWindow.top, <br>               rectWindow.right - rectWindow.left, <br>               rectWindow.bottom - rectWindow.top +  <br>               DialogHeight (hDlg, IDD_ADDLINEEXPLAINGROUP) +  <br>               yScrollHeight, <br>               TRUE) ; <br> <br>   WindowCenter (hDlg) ; <br> <br>   }  // OnExpandExplain <br> <br> <br> <br>BOOL /*static*/ OnCommand (HWND hDlg,  <br>                       WPARAM wParam,  <br>                       LPARAM lParam) <br>   { <br>   int            iWidthIndex ; <br>   int            iStyleIndex ; <br>   HWND           hWndWidths = DialogControl (hDlg, IDD_ADDLINEWIDTH) ; <br>   HWND           hWndStyles = DialogControl (hDlg, IDD_ADDLINESTYLE) ; <br> <br>   switch (LOWORD (wParam)) <br>      { <br>      case IDD_ADDLINEIFVALUE: <br>         // We don't get the value when the user types it. We get it when <br>         // the user attempts to add the line. <br>         break ; <br> <br>      case IDD_ADDLINEPROGRAM: <br>         GetDlgItemText (hDlg, <br>            IDD_ADDLINEPROGRAM, <br>            pszAlertProgram, <br>            FilePathLen - 1) ; <br>         break ; <br> <br>      case IDD_ADDLINEIFOVER: <br>      case IDD_ADDLINEIFUNDER: <br>         bAlertOver = (LOWORD (wParam) == IDD_ADDLINEIFOVER) ; <br>         CheckRadioButton (hDlg, IDD_ADDLINEIFOVER, IDD_ADDLINEIFUNDER,  <br>                           bAlertOver ? IDD_ADDLINEIFOVER: IDD_ADDLINEIFUNDER) ; <br>         break ; <br> <br>      case IDD_ADDLINEPROGRAMFIRSTTIME: <br>      case IDD_ADDLINEPROGRAMEVERYTIME: <br>         bEveryTime = (LOWORD (wParam) == IDD_ADDLINEPROGRAMEVERYTIME) ; <br>         CheckRadioButton (hDlg, IDD_ADDLINEPROGRAMFIRSTTIME, IDD_ADDLINEPROGRAMEVERYTIME,  <br>                           bEveryTime ? IDD_ADDLINEPROGRAMEVERYTIME: IDD_ADDLINEPROGRAMFIRSTTIME) ; <br>         break ; <br> <br>      case IDD_ADDLINEWIDTH: <br>         iWidthIndex = CBSelection (hWndWidths) ; <br>#if (!WIDESTYLES) <br>         DialogEnable (hDlg, IDD_ADDLINESTYLETEXT,  <br>                       iWidthIndex == 0  || iWidthIndex == CB_ERR) ; <br>         DialogEnable (hDlg, IDD_ADDLINESTYLE,  <br>                       iWidthIndex == 0  || iWidthIndex == CB_ERR) ; <br>#endif <br>         break ; <br> <br>      case IDD_ADDLINESTYLE: <br>         iStyleIndex = CBSelection (hWndStyles) ; <br>#if (!WIDESTYLES) <br>         DialogEnable (hDlg, IDD_ADDLINEWIDTHTEXT,  <br>                       iStyleIndex == 0  || iStyleIndex == CB_ERR) ; <br>         DialogEnable (hDlg, IDD_ADDLINEWIDTH,  <br>                       iStyleIndex == 0  || iStyleIndex == CB_ERR) ; <br>#endif <br>         break ; <br> <br>      case IDCANCEL: <br>         EndDialog (hDlg, 0); <br>         return (TRUE); <br>         break ; <br> <br>      case IDD_ADDLINEADD : <br> <br>         if (ComputerChange) <br>            { <br>            SetHourglassCursor() ; <br>            OnComputerChanged (hDlg) ; <br>            } <br>         else <br>            { <br>            SetHourglassCursor() ; <br>            OnAddLines (hDlg) ; <br>            SetArrowCursor() ; <br>            } <br>         break; <br> <br>      case IDD_ADDLINEEXPANDEXPLAIN : <br>         if (ComputerChange) <br>            { <br>            SetHourglassCursor() ; <br>            OnComputerChanged (hDlg) ; <br>            } <br>         else <br>            { <br>            OnExpandExplain (hDlg) ; <br>            } <br>         break; <br> <br>      case IDD_ADDLINEELLIPSES: <br>         SetHourglassCursor() ; <br>         OnEllipses (hDlg) ; <br>         SetArrowCursor() ; <br>         break ; <br> <br> <br>      case IDD_ADDLINECOUNTER: <br>         if (ComputerChange) <br>            { <br>            SetHourglassCursor() ; <br>            OnComputerChanged (hDlg) ; <br>            } <br>         else if (HIWORD (wParam) == LBN_SELCHANGE) <br>            OnCounterChanged (hDlg) ; <br>         break ; <br>            <br>       <br>      case IDD_ADDLINEOBJECT: <br>         if (ComputerChange) <br>            { <br>            SetHourglassCursor() ; <br>            OnComputerChanged (hDlg) ; <br>            } <br>         else if (HIWORD (wParam) == CBN_SELCHANGE) <br>            OnObjectChanged (hDlg) ; <br>         break ; <br> <br>      case IDD_ADDLINEINSTANCE: <br>         if (ComputerChange) <br>            { <br>            SetHourglassCursor() ; <br>            OnComputerChanged (hDlg) ; <br>            } <br>         break ; <br> <br>      case IDD_ADDLINECOMPUTER: <br>         if (HIWORD (wParam) == EN_UPDATE) <br>            { <br>            ComputerChange = TRUE ; <br>            } <br>         break ; <br> <br>      case IDD_ADDLINEHELP: <br>         CallWinHelp (dwCurrentDlgID) ; <br>         break ; <br> <br>default: <br>    break; <br>    } // switch <br> <br>   return (FALSE) ; <br>   } // OnCommand <br> <br> <br>void /*static*/ OnMeasureItem (HWND hDlg,  <br>                           PMEASUREITEMSTRUCT pMI) <br>   { <br>   pMI-&gt;CtlType    = ODT_COMBOBOX ; <br>   pMI-&gt;CtlID      = IDD_ADDLINECOLOR ; <br>   pMI-&gt;itemData   = 0 ; <br>   pMI-&gt;itemWidth  = 0 ; <br> <br>   // need 14 in order to draw the thickest line width <br>   pMI-&gt;itemHeight = 14 ; <br>//   pMI-&gt;itemHeight = 12 ; <br>   } <br> <br>//*************************************************************************** <br>//                                                                          * <br>//  FUNCTION   : HandleSelectionState(LPDRAWITEMSTRUCT)                     * <br>//                                                                          * <br>//  PURPOSE    : Handles a change in an item selection state. If an item is * <br>//               selected, a black rectangular frame is drawn around that   * <br>//               item; if an item is de-selected, the frame is removed.     * <br>//                                                                          * <br>//  COMMENT    : The black selection frame is slightly larger than the gray * <br>//               focus frame so they won't paint over each other.           * <br>//                                                                          * <br>//*************************************************************************** <br>void static HandleSelectionState (LPDRAWITEMSTRUCTlpdis) <br>{ <br>HBRUSHhbr ; <br> <br>if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>{ <br>// selecting item -- paint a black frame <br>hbr = GetStockObject(BLACK_BRUSH) ; <br>} <br>else <br>{ <br>// de-selecting item -- remove frame  <br>hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ; <br>} <br>FrameRect(lpdis-&gt;hDC, (LPRECT)&amp;lpdis-&gt;rcItem, hbr) ; <br>DeleteObject (hbr) ; <br>   }  // HandleSelectionState <br> <br>//*************************************************************************** <br>//                                                                          * <br>//  FUNCTION   : HandleFocusState(LPDRAWITEMSTRUCT)                         * <br>//                                                                          * <br>//  PURPOSE    : Handle a change in item focus state. If an item gains the  * <br>//               input focus, a gray rectangular frame is drawn around that * <br>//               item; if an item loses the input focus, the gray frame is  * <br>//               removed.                                                   * <br>//                                                                          * <br>//  COMMENT    : The gray focus frame is slightly smaller than the black    * <br>//               selection frame so they won't paint over each other.       * <br>//                                                                          * <br>//*************************************************************************** <br>void static HandleFocusState (LPDRAWITEMSTRUCTlpdis) <br>   { <br>RECT   rc ; <br>HBRUSHhbr ; <br> <br>// Resize rectangle to place focus frame between the selection <br>// frame and the item. <br>CopyRect ((LPRECT)&amp;rc, (LPRECT)&amp;lpdis-&gt;rcItem) ; <br>InflateRect ((LPRECT)&amp;rc, -OWNER_DRAW_FOCUS, -OWNER_DRAW_FOCUS) ; <br> <br>if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>{ <br>// gaining input focus -- paint a gray frame <br>hbr = GetStockObject(GRAY_BRUSH) ; <br>} <br>else <br>{ <br>// losing input focus -- remove (paint over) frame <br>hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)) ; <br>} <br>FrameRect(lpdis-&gt;hDC, (LPRECT)&amp;rc, hbr) ; <br>DeleteObject (hbr) ; <br>   }  // HandleFocusState <br> <br>void /*static*/ OnDrawItem (HWND hDlg, PDRAWITEMSTRUCT pDI) <br>   {  // OnDrawItem <br>   HDC            hDC ; <br>   PRECT          prect ; <br>   INT            itemData,  <br>                  itemID,  <br>                  CtlID,  <br>                  itemAction ; <br>   LOGBRUSH       logBrush ; <br>   HANDLE         hBrush,  <br>                  hOldBrush,  <br>                  hPen,  <br>                  hOldPen ; <br>   INT            x1, y1, x2, y2, cy ; <br>   POINT          point ; <br>   INT            iPenWidth ; <br>   COLORREF       BackgroundColor ; <br> <br>   hDC        = pDI-&gt; hDC ; <br>   CtlID      = pDI-&gt;CtlID ; <br>   prect      = &amp;pDI-&gt;rcItem ; <br>   itemData   = pDI-&gt;itemData ; <br>   itemID     = pDI-&gt;itemID ; <br>   itemAction = pDI-&gt;itemAction ; <br> <br> <br>   if (itemID == -1) <br>      { <br>      // invalid ID, can't go on <br>      HandleFocusState (pDI) ; <br>      } <br>   else if (itemAction == ODA_SELECT) <br>      { <br>      HandleSelectionState(pDI); <br>      } <br>   else if (itemAction == ODA_FOCUS) <br>      { <br>      HandleFocusState (pDI) ; <br>      } <br>   else <br>      { <br>       <br>      // draw the entire item <br>       <br>      InflateRect (prect, -OWNER_DRAWN_ITEM, -OWNER_DRAWN_ITEM) ; <br> <br>      switch (CtlID) <br>         {  // switch <br>         case IDD_ADDLINECOLOR: <br> <br>            // Draw a color rectangle into the control area <br> <br>            logBrush.lbStyle = BS_SOLID ; <br>            logBrush.lbColor = (COLORREF) argbColors[itemID] ; <br>            logBrush.lbHatch = 0 ; <br> <br>            hBrush = CreateBrushIndirect (&amp;logBrush) ; <br>            hOldBrush = SelectObject (hDC, hBrush) ; <br> <br>            hPen = GetStockObject (NULL_PEN) ; <br>            hOldPen = SelectObject (hDC, hPen) ; <br> <br>            x1 = prect-&gt;left ; <br>            y1 = prect-&gt;top ; <br>            x2 = prect-&gt;right ; <br>            y2 = prect-&gt;bottom ; <br> <br>            Rectangle (hDC, x1, y1, x2, y2) ; <br> <br>            SelectObject (hDC, hOldBrush) ; <br>            DeleteObject (hBrush) ; <br> <br>            InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ; <br> <br>            HandleSelectionState (pDI) ; <br>            HandleFocusState (pDI) ; <br> <br>            break ; <br> <br>         case IDD_ADDLINEWIDTH: <br>         case IDD_ADDLINESTYLE: <br> <br>            // First draw a rectangle, white interior, null border <br>            hBrush = GetStockObject (WHITE_BRUSH) ; <br>            hOldBrush = SelectObject (hDC, hBrush) ; <br> <br>            // we need to set the bk color in order to draw <br>            // the dash lines coorectly during focus.  Otherwise, <br>            // the COLOR_WINDOW background will make all dash lines <br>            // look like solid line... </code></pre>
<p>
</p>
<pre><code>BackgroundColor = SetBkColor (hDC, crWhite) ; <br> <br>            hPen = GetStockObject (NULL_PEN) ; <br>            hOldPen = SelectObject (hDC, hPen) ; <br> <br>            x1 = prect-&gt;left ; <br>            y1 = prect-&gt;top ; <br>            x2 = prect-&gt;right ; <br>            y2 = prect-&gt;bottom ; <br> <br>            Rectangle (hDC, x1, y1, x2, y2) ; <br> <br>            SelectObject (hDC, hOldPen) ; <br> <br>            // Draw a line of the itemID width in the middle <br>            // of the control area. <br> <br>            if (CtlID == IDD_ADDLINEWIDTH) <br>               { <br>               iPenWidth = LineWidth (itemID) ; <br>               hPen = CreatePen (PS_SOLID, iPenWidth, RGB (0, 0, 0)) ; <br>               } <br>            else <br>               { <br>               hPen = CreatePen (itemID, 1, RGB (0, 0, 0)) ; <br>               } <br> <br>            hOldPen = SelectObject (hDC, hPen) ; <br> <br>            x1 = prect-&gt;left + 8 ; <br>            cy = prect-&gt;bottom - prect-&gt;top ; <br>            y1 = prect-&gt;top + (cy / 2) - 1 ; <br>            x2 = prect-&gt;right - 8 ; <br>            MoveToEx (hDC, x1, y1, &amp;point) ; <br>            LineTo (hDC, x2, y1) ; <br> <br>            SelectObject (hDC, hOldPen) ; <br>            DeleteObject (hPen) ; <br>            SelectObject (hDC, hOldBrush) ; <br>            BackgroundColor = SetBkColor (hDC, BackgroundColor) ; <br> <br>            InflateRect (prect, OWNER_DRAWN_ITEM, OWNER_DRAWN_ITEM) ; <br> <br>            HandleSelectionState (pDI) ; <br>            HandleFocusState (pDI) ; <br> <br>            break ; <br>         }   // switch <br>      }  // draw entire item    <br>   }  // OnDrawItem <br>                         <br> <br>void /*static*/ OnDestroy (HDLG hDlg) <br>   {  // OnDestroy <br>   if (!PlayingBackLog ()) <br>      MemoryFree (pPerfData) ; <br> <br>   if (pszAlertProgram) <br>      { <br>      MemoryFree (pszAlertProgram) ; <br>      pszAlertProgram = NULL ; <br>      } <br> <br>   pLineEdit = NULL ; <br>   bAddLineInProgress = FALSE ; <br>   dwCurrentDlgID = 0 ; <br>   bExplainTextButtonHit = FALSE ; <br>   }  // OnDestroy <br>    <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br> <br>BOOL FAR PASCAL AddLineDlgProc (HWND hDlg,  <br>                                WORD msg,  <br>                                DWORD wParam,  <br>                                LONG lParam) <br>   {  // AddLineDlgProc <br> <br>   BOOL Status; <br> <br>   switch (msg) <br>      {  // switch <br>      case WM_COMMAND: <br>         OnCommand (hDlg, wParam, lParam) ; <br>         return (FALSE) ; <br>         break ; <br> <br>   case WM_INITDIALOG: <br>         SetHourglassCursor() ; <br>         Status = OnInitDialog (hDlg) ; <br>         SetArrowCursor() ; <br> <br>         // set focus on the "Add" button instead of the "Computer" <br>         SetFocus (DialogControl (hDlg, IDD_ADDLINEADD)) ; <br>         return FALSE ; <br>         break ; <br> <br>      case WM_MEASUREITEM: <br>         OnMeasureItem (hDlg, (PMEASUREITEMSTRUCT) lParam) ; <br>         return (TRUE) ; <br>         break ; <br> <br>      case WM_DRAWITEM: <br>         OnDrawItem (hDlg, (PDRAWITEMSTRUCT) lParam) ; <br>         return (TRUE) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hDlg) ; <br>         break ; <br>            <br>   default: <br>      break; <br>      }  // switch <br> <br>   return (FALSE) ; <br>   }  // AddLineDlgProc <br> <br> <br> <br> <br>BOOL AddLine (HWND hWndParent,  <br>              PPERFSYSTEM *ppSystemFirstView, <br>              PLINEVISUAL pLineVisual, <br>              LPTSTR pInCurrentSystem, <br>              int iLineTypeToAdd) <br>/* <br>   Effect:        Display the add line dialog box, allowing the user <br>                  to specify the computer, object, counter, instance, <br>                  and scale for a line.  The user can also select the <br>                  visual aspects of color, width and line style. <br> <br>*/                   <br>   {  // AddLine <br>   pLineEdit = NULL ; <br> <br>   ppSystemFirst = ppSystemFirstView ;    <br>   iLineType = iLineTypeToAdd ; <br>   pVisual = pLineVisual ; <br>   pCurrentSystem = pInCurrentSystem ; <br>    <br>   return (DialogBox (hInstance, idDlgAddLine,  <br>                      hWndParent, (DLGPROC) AddLineDlgProc)) ; <br>   }  // AddLine <br> <br> <br> <br>BOOL EditLine (HWND hWndParent, <br>               PPERFSYSTEM *ppSystemFirstView, <br>               PLINE pLineToEdit, <br>               int iLineTypeToEdit) <br>   {  // EditLine <br>   if (!pLineToEdit) <br>      { <br>      return (FALSE) ; <br>      } <br> <br>   pLineEdit = pLineToEdit ; <br> <br>   ppSystemFirst = ppSystemFirstView ;    <br>   iLineType = iLineTypeToEdit ; <br>   pVisual = &amp;(pLineToEdit-&gt;Visual) ; <br>    <br>   return (DialogBox (hInstance, idDlgAddLine,  <br>                      hWndParent, (DLGPROC) AddLineDlgProc)) ; <br>   }  // EditLine </code></pre>
<p>&nbsp;</p></body>
</HTML>
