<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LEGEND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5669"></a>LEGEND.C</h2>
<pre><code>/* <br>============================================================================== <br> <br>  Application: <br> <br>            Microsoft Windows NT (TM) Performance Monitor <br> <br>  File: <br>            legend.c - legend window routines.                           <br> <br>            This file contains code creating the legend window, which is <br>            a child of the graph windows. The legend window displays a <br>            legend line for each line in the associated graph. It also  <br>            includes an area called the label, which are headers for those <br>            lines. <br> <br> <br>  Copyright 1992 - 1998 Microsoft Corporation. All Rights Reserved. <br>============================================================================== <br>*/ <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include &lt;stdio.h&gt;      // for sprintf <br>#include "perfmon.h" <br>#include "legend.h"     // external declarations for this file <br> <br>#include "owndraw.h" <br> <br>#include "alert.h"      // for EditAlert <br>#include "grafdata.h"   // for EditChart <br>#include "pmemory.h"    // for MemoryXXX (mallloc-type) routines <br>#include "utils.h" <br>#include "valuebar.h"   // for StatusTimer <br>#include "playback.h"   // for PlayingBackLog() <br>#include "perfmops.h"   // for COnvertDecimalPoint <br> <br>#define eScaleValueSpace       TEXT("&gt;9999999999.0") <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define dwGraphLegendClassStyle     (CS_HREDRAW | CS_VREDRAW) <br>#define iGraphLegendClassExtra      (0) <br>#define iGraphLegendWindowExtra     (sizeof (PLEGEND)) <br>#define dwGraphLegendWindowStyle    (WS_CHILD | WS_VISIBLE)  <br> <br>#define xLegendBorderWidth          (xDlgBorderWidth) <br>#define yLegendBorderHeight         (yDlgBorderHeight) <br> <br>#define iLabelLen                   30 <br>#define iLegendColMax               1000 <br> <br>#define LEFTORIENTATION             1 <br>#define CENTERORIENTATION           2 <br>#define RIGHTORIENTATION            3 <br> <br>#define LegendColorCol              0 <br>#define LegendScaleCol              1 <br>#define LegendCounterCol            2 <br>#define LegendInstanceCol           3 <br>#define LegendParentCol             4 <br>#define LegendObjectCol             5 <br>#define LegendSystemCol             6   <br> <br>#define iLegendNumCols              7 <br> <br>#define iLegendMaxVisibleItems      8 <br> <br>#define dwGraphLegendItemsWindowClass  TEXT("ListBox") <br>#define dwGraphLegendItemsWindowStyle           \ <br>   (LBS_NOTIFY | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED | \ <br>    WS_VISIBLE | WS_CHILD | WS_VSCROLL) <br> <br> <br>//==========================================================================// <br>//                                  Typedefs                                // <br>//==========================================================================// <br> <br> <br>typedef struct LEGENDCOLSTRUCT <br>   { <br>   TCHAR          szLabel [iLabelLen] ; <br>   int            xMinWidth ; <br>   int            xMaxWidth ; <br>   int            xWidth ; <br>   int            xPos ; <br>   int            iOrientation ; <br>   } LEGENDCOL ; <br> <br>typedef LEGENDCOL *PLEGENDCOL ; <br> <br> <br>typedef struct LEGENDTRUCT <br>   { <br>   HWND           hWndItems ; <br>   HFONT          hFontItems ; <br>   HFONT          hFontLabels ; <br>   int            xMinWidth ; <br>   int            yLabelHeight ; <br>   int            yItemHeight ; <br>   int            iNumItemsVisible ; <br>   LEGENDCOL      aCols [iLegendNumCols] ; <br>   int            iLineType ; <br>   PLINE          pCurrentLine ;    // current selected line <br>   }  LEGEND ; <br> <br>typedef LEGEND *PLEGEND ; <br> <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define LabelTopMargin()      (2) <br>#define LegendLeftMargin()    (3 + ThreeDPad) <br> <br>#define LegendItemTopMargin() (yBorderHeight) <br> <br> <br>#define IsLegendLabelVisible()  (TRUE) <br> <br>#define ColCanGrow(pCol)                     \ <br>   (pCol-&gt;xMaxWidth &gt; pCol-&gt;xWidth) <br> <br> <br>#define LegendHorzMargin()    (3) <br> <br> <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br>// LEGEND            Legend ; <br>PLEGEND     pGraphLegendData ; <br>PLEGEND     pAlertLegendData ; <br> <br>#define  LegendData(hWnd)     \ <br>   ((hWnd == hWndGraphLegend) ? pGraphLegendData : pAlertLegendData ) <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br>void LegendSetCurrentLine (PLEGEND pLegend, int iIndex) <br>   { <br>   pLegend-&gt;pCurrentLine = <br>      (PLINESTRUCT) LBData (pLegend-&gt;hWndItems, iIndex) ; <br> <br>   if (pLegend-&gt;pCurrentLine == (PLINESTRUCT) LB_ERR) <br>      { <br>      pLegend-&gt;pCurrentLine = NULL ; <br>      } <br>   }  // LegendSetCurrentLine <br> <br>#if 0 <br>PLEGEND LegendData (HWND hWnd) <br>   { <br>   return ((PLEGEND) GetWindowLong (hWnd, 0)) ; <br>   } <br>#endif <br> <br> <br>PLEGEND AllocateLegendData (HWND hWnd, BOOL bChartLegend) <br>   { <br>   PLEGEND        pLegend ; <br> <br>   pLegend = MemoryAllocate (sizeof (LEGEND)) ; <br>//   SetWindowLong (hWnd, 0, (LONG) pLegend) ; <br> <br>   if (bChartLegend) <br>      { <br>      hWndGraphLegend = hWnd ; <br>      pGraphLegendData = pLegend ; <br>      } <br>   else <br>      { <br>      hWndAlertLegend = hWnd ; <br>      pAlertLegendData = pLegend ; <br>      } <br> <br>   return (pLegend) ; <br>   } <br> <br> <br> <br>void DrawLegendLabel (PLEGEND pLegend, <br>                      HDC hDC, <br>                      HWND hWnd) <br>   {  // DrawLegendLabel <br>   int            i ; <br>   int            xPos ; <br>   RECT           rect ; <br>   RECT           rectLB ; <br>   INT            LocalThreeDPad = ThreeDPad - 1 ; <br> <br>   SetBkColor (hDC, crLightGray) ; <br> <br>   SelectFont (hDC, pLegend-&gt;hFontLabels) ; <br> <br>   GetClientRect (hWnd, &amp;rect) ; <br>//   Fill (hDC, crLightGray, &amp;rect) ; <br>   ExtTextOut (hDC, rect.left, rect.top, <br>      ETO_OPAQUE, &amp;(rect), NULL, 0, NULL ) ; <br> <br>   GetWindowRect (pLegend-&gt;hWndItems, &amp;rectLB) ; <br>   ScreenRectToClient (hWnd, &amp;rectLB) ; <br>   ThreeDConcave1 (hDC,  <br>                  rectLB.left - LocalThreeDPad, <br>                  rectLB.top - LocalThreeDPad, <br>                  rectLB.right + LocalThreeDPad, <br>                  rectLB.bottom + LocalThreeDPad) ; <br> <br>   for (i = 0 ; <br>        i &lt; iLegendNumCols ; <br>        i++) <br>      {  // for <br>      rect.left = pLegend-&gt;aCols[i].xPos ; <br>      rect.top = yBorderHeight ; <br>      rect.right = rect.left + pLegend-&gt;aCols[i].xWidth - LegendHorzMargin () ; <br>      rect.bottom = pLegend-&gt;yLabelHeight ; <br> <br>      switch (pLegend-&gt;aCols[i].iOrientation) <br>         {  // switch <br>         case LEFTORIENTATION: <br>            SetTextAlign (hDC, TA_LEFT) ; <br>            xPos = rect.left ; <br>            break ; <br> <br>         case CENTERORIENTATION: <br>            SetTextAlign (hDC, TA_CENTER) ; <br>            xPos = (rect.left + rect.right) / 2 ; <br>            break ; <br> <br>         case RIGHTORIENTATION: <br>            SetTextAlign (hDC, TA_RIGHT) ; <br>            xPos = rect.right ; <br>            break ; <br> <br>         default: <br>            xPos = rect.left ; <br>            break ; <br>         }  // switch <br> <br>      ExtTextOut (hDC,  <br>                  xPos, rect.top,  <br>                  ETO_OPAQUE, <br>                  &amp;rect, <br>                  pLegend-&gt;aCols[i].szLabel, <br>                  lstrlen (pLegend-&gt;aCols[i].szLabel), <br>                  NULL) ; <br>      }  // for <br>   }  // DrawLegendLabel <br> <br> <br> <br>void DrawColorCol (PLEGEND pLegend, <br>                   PLINE pLine, <br>                   int iCol, <br>                   HDC hDC, <br>                   int yPos) <br>/* <br>   Effect:        Draw the "color" column of a legend entry. The color  <br>                  column displays a small sample of the line drawing. <br> <br>                  For charts, the sample is a line of the correct style, <br>                  color, and width.  Since we are using wide lines,  <br>                  the round endcaps of the lines will breach the column. <br>                  Therefore we need to set the clip region. We could <br>                  remove this clipping if we find a way to change the <br>                  end cap design.   <br> <br>                  For alerts, the sample is a small circle which echos <br>                  the design in the alert log itself. <br>*/       <br>   {  // DrawColorCol <br>   HBRUSH         hBrush, hBrushPrevious ; <br>   RECT           rect ; <br>   int            yMiddle ; <br>   int            iCircle ; <br> <br> <br> <br>   rect.left = pLegend-&gt;aCols[iCol].xPos - LegendLeftMargin () + 2 ; <br>   rect.top = yPos + 1 ; <br>   rect.right = rect.left + pLegend-&gt;aCols[iCol].xWidth - LegendHorzMargin () ; <br>   rect.bottom = yPos + pLegend-&gt;yItemHeight - 1 ; <br> <br>   yMiddle = rect.top + (rect.bottom - rect.top) / 2 ; <br>   iCircle = rect.bottom - rect.top - 2 ; <br>  <br>  switch (pLegend-&gt;iLineType) <br>      {  // switch <br>      case LineTypeChart: <br>    <br>         if (pLine-&gt;Visual.iWidth == 1) <br>            { <br>            // simple case with thin pen <br>            hBrush = SelectBrush (hDC, hbLightGray) ; <br>            Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom) ; <br>    <br>            HLine (hDC, pLine-&gt;hPen,  <br>                   rect.left + 1, rect.right - 1, yMiddle) ; <br>            SelectBrush (hDC, hBrush) ; <br>            } <br>         else <br>            { <br>            // thicker pen width, have to set ClipRect so <br>            // it will not draw otherside the rect. <br>            SaveDC (hDC) ; <br>            hBrush = SelectBrush (hDC, hbLightGray) ; <br>            Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom) ; <br>    <br>            IntersectClipRect (hDC,  <br>                               rect.left + 1, <br>                               rect.top + 1, <br>                               rect.right - 1, <br>                               rect.bottom - 1) ; <br>            HLine (hDC, pLine-&gt;hPen,  <br>                   rect.left + 1, rect.right - 1, yMiddle) ; <br>            SelectBrush (hDC, hBrush) ; <br>            RestoreDC (hDC, -1) ; <br>            } <br>         break ; <br> <br> <br>      case LineTypeAlert: <br>         hBrushPrevious = SelectBrush (hDC, pLine-&gt;hBrush) ; <br> <br>         Ellipse (hDC, <br>                  rect.left + 2, <br>                  rect.top + 2, <br>                  rect.left + 2 + iCircle, <br>                  rect.top + 2 + iCircle) ; <br> <br>         SelectBrush (hDC, hBrushPrevious) ; <br>         break ; <br>      }  // switch <br> <br>   }  // DrawColorCol <br> <br> <br>void DrawLegendCol (PLEGEND pLegend, <br>                    int iCol, <br>                    HDC hDC, <br>                    int yPos, <br>                    LPTSTR lpszValue) <br>/* <br>   Effect:        Draw the value lpszValue for the column iCol on hDC. <br> <br>   Assert:        The foreground and background text colors of hDC are <br>                  properly set. <br>*/ <br>   {  // DrawLegendCol <br>   RECT           rect ; <br>   int            xPos ; <br> <br>   rect.left = pLegend-&gt;aCols[iCol].xPos - LegendLeftMargin () ; <br>   rect.top = yPos ; <br>   rect.right = rect.left + pLegend-&gt;aCols[iCol].xWidth - LegendHorzMargin () ; <br>   rect.bottom = yPos + pLegend-&gt;yItemHeight ; <br> <br>//   SetTextAlign (hDC, TA_TOP) ;    <br>   switch (pLegend-&gt;aCols[iCol].iOrientation) <br>      {  // switch <br>      case LEFTORIENTATION: <br>         SetTextAlign (hDC, TA_LEFT) ; <br>         xPos = rect.left ; <br>         break ; <br> <br>      case CENTERORIENTATION: <br>         SetTextAlign (hDC, TA_CENTER) ; <br>         xPos = (rect.left + rect.right) / 2 ; <br>         break ; <br> <br>      case RIGHTORIENTATION: <br>         SetTextAlign (hDC, TA_RIGHT) ; <br>         xPos = rect.right ; <br>         break ; <br> <br>      default: <br>         xPos = rect.left ; <br>         break ; <br>      }  // switch <br> <br>   ExtTextOut (hDC,  <br>               xPos, rect.top + LegendItemTopMargin (),  <br>               ETO_OPAQUE | ETO_CLIPPED, <br>               &amp;rect, <br>               lpszValue, <br>               lstrlen (lpszValue), <br>               NULL) ; <br>   }  // DrawLegendCol <br> <br> <br>void DrawLegendItem (PLEGEND pLegend, <br>                     PLINESTRUCT pLine, <br>                     int yPos, <br>                     HDC hDC) <br>   { <br>   TCHAR          szValue [256] ; <br>   TCHAR          szInstance [256] ; <br>   TCHAR          szParent [256] ; <br>   TCHAR          szNoName[4] ; <br> <br>   szNoName[0] = szNoName[1] = szNoName[2] = TEXT('-') ; <br>   szNoName[3] = TEXT('\0') ; <br> <br>   //=============================// <br>   // Determine Instance, Parent  // <br>   //=============================// <br> <br>   // It's possible that there will be no instance, therefore <br>   // the lnInstanceName would be NULL. <br> <br>   if (pLine-&gt;lnObject.NumInstances &gt; 0) <br>      { <br>      // Test for the parent object instance name title index. <br>      // If there is one, it implies that there will be a valid <br>      // Parent Object Name and a valid Parent Object Instance Name. <br> <br>      // If the Parent Object title index is 0 then <br>      // just display the instance name. <br> <br>      lstrcpy (szInstance, pLine-&gt;lnInstanceName) ; <br>      if (pLine-&gt;lnInstanceDef.ParentObjectTitleIndex &amp;&amp; <br>          pLine-&gt;lnPINName) <br>         { <br>         // Get the Parent Object Name. <br>         lstrcpy (szParent, pLine-&gt;lnPINName) ; <br>         } <br>      else <br>         { <br>         lstrcpy (szParent, szNoName) ; <br>         } <br>      } <br>   else <br>      { <br>      lstrcpy (szInstance, szNoName) ; <br>      lstrcpy (szParent, szNoName) ; <br>      } <br> <br>   //=============================// <br>   // Draw Color                  // <br>   //=============================// <br> <br>   DrawColorCol (pLegend, pLine, LegendColorCol, hDC, yPos) ; <br> <br>   //=============================// <br>   // Draw Scale/Value            // <br>   //=============================// <br> <br>   if (pLegend-&gt;iLineType == LineTypeChart) <br>      { <br>      if (pLine-&gt;eScale &lt; (FLOAT) 1.0) <br>         { <br>         TSPRINTF (szValue, TEXT("%6.6f"), pLine-&gt;eScale) ; <br>         } <br>      else <br>         { <br>         TSPRINTF (szValue, TEXT("%10.3f"), pLine-&gt;eScale) ; <br>         } <br>      ConvertDecimalPoint (szValue) ; <br>      } <br>   else <br>      { <br>      FLOAT tempAlertValue ; <br> <br>      tempAlertValue = pLine-&gt;eAlertValue ; <br>      if (tempAlertValue &lt; (FLOAT) 0.0) <br>         { <br>         tempAlertValue = -tempAlertValue ; <br>         } <br> <br>      if (tempAlertValue &gt;= (FLOAT) 10000.0) <br>         { <br>         if (tempAlertValue &lt; (FLOAT) 1.0E+8) <br>            { <br>            TSPRINTF (szValue, TEXT("%c%10.0f"), <br>               pLine-&gt;bAlertOver ? TEXT('&gt;') : TEXT('&lt;'), <br>               pLine-&gt;eAlertValue) ; <br>            } <br>         else <br>            { <br>            TSPRINTF (szValue, TEXT("%c%10.3e"), <br>               pLine-&gt;bAlertOver ? TEXT('&gt;') : TEXT('&lt;'), <br>               pLine-&gt;eAlertValue) ; <br>            } <br>         ConvertDecimalPoint (szValue) ; <br>         } <br>      else <br>         { <br>         TSPRINTF (szValue, TEXT("%c%10.4f"), <br>            pLine-&gt;bAlertOver ? TEXT('&gt;') : TEXT('&lt;'), <br>            pLine-&gt;eAlertValue) ; <br>         ConvertDecimalPoint (szValue) ; <br>         } <br>      } <br> <br>   SetTextAlign (hDC, TA_TOP) ;    <br> <br>   DrawLegendCol (pLegend, LegendScaleCol, <br>                  hDC, yPos, szValue) ; <br> <br> <br>   //=============================// <br>   // Draw Counter                // <br>   //=============================// <br> <br>   DrawLegendCol (pLegend, LegendCounterCol, <br>                  hDC, yPos, pLine-&gt;lnCounterName) ; <br> <br>    <br>   //=============================// <br>   // Draw Instance               // <br>   //=============================// <br> <br>   DrawLegendCol (pLegend, LegendInstanceCol, <br>                  hDC, yPos, szInstance) ; <br> <br>   //=============================// <br>   // Draw Parent                 // <br>   //=============================// <br> <br>   DrawLegendCol (pLegend, LegendParentCol,   <br>                  hDC, yPos, szParent) ; <br> <br>   //=============================// <br>   // Draw Object                 // <br>   //=============================// <br> <br>   DrawLegendCol (pLegend, LegendObjectCol, <br>                  hDC, yPos, pLine-&gt;lnObjectName) ; <br> <br>   //=============================// <br>   // Draw System                 // <br>   //=============================// <br> <br>   DrawLegendCol (pLegend, LegendSystemCol, <br>                  hDC, yPos, pLine-&gt;lnSystemName) ; <br> <br>   } <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>BOOL OnLegendCreate (HWND hWnd, LPCREATESTRUCT lpCS) <br>   { <br>   PLEGEND        pLegend ; <br>   HDC            hDC ; <br>   int            iCol ; <br>   BOOL           bChartLegend ; <br> <br>   bChartLegend = (lpCS-&gt;lpCreateParams) == (LPVOID) TRUE ; <br> <br>   pLegend = AllocateLegendData (hWnd, bChartLegend) ; <br> <br>   if (!pLegend) <br>      return (FALSE) ; <br> <br>   if (bChartLegend) <br>      { <br>      pLegend-&gt;iLineType = LineTypeChart ; <br>      } <br>   else <br>      { <br>      pLegend-&gt;iLineType = LineTypeAlert ; <br>      } <br> <br>   pLegend-&gt;hFontItems = hFontScales ; <br>   pLegend-&gt;hFontLabels = hFontScalesBold ; <br>   hDC = GetDC (hWnd) ; <br> <br>   //=============================// <br>   // Load Labels                 // <br>   //=============================// <br> <br>   StringLoad (IDS_LABELCOLOR, pLegend-&gt;aCols[LegendColorCol].szLabel) ; <br>   if (pLegend-&gt;iLineType == LineTypeChart) <br>      StringLoad (IDS_LABELSCALE,  <br>                  pLegend-&gt;aCols[LegendScaleCol].szLabel) ; <br>   else <br>      StringLoad (IDS_LABELVALUE, <br>                  pLegend-&gt;aCols[LegendScaleCol].szLabel) ; <br>   StringLoad (IDS_LABELCOUNTER, pLegend-&gt;aCols[LegendCounterCol].szLabel) ; <br>   StringLoad (IDS_LABELINSTANCE, pLegend-&gt;aCols[LegendInstanceCol].szLabel) ; <br>   StringLoad (IDS_LABELPARENT, pLegend-&gt;aCols[LegendParentCol].szLabel) ; <br>   StringLoad (IDS_LABELOBJECT, pLegend-&gt;aCols[LegendObjectCol].szLabel) ; <br>   StringLoad (IDS_LABELSYSTEM, pLegend-&gt;aCols[LegendSystemCol].szLabel) ; <br> <br> <br>   //=============================// <br>   // Label dimensions            // <br>   //=============================// <br> <br>   SelectFont (hDC, pLegend-&gt;hFontLabels) ; <br>   pLegend-&gt;yLabelHeight = FontHeight (hDC, TRUE) + 2 * LabelTopMargin () ; <br> <br>   //=============================// <br>   // Column dimensions           // <br>   //=============================// <br> <br>   for (iCol = 0 ; <br>        iCol &lt; iLegendNumCols ; <br>        iCol++) <br>      {  // for <br>      pLegend-&gt;aCols[iCol].iOrientation = LEFTORIENTATION ; <br>      pLegend-&gt;aCols[iCol].xMinWidth =  <br>         TextWidth (hDC, pLegend-&gt;aCols[iCol].szLabel) + LegendHorzMargin () ; <br>      }  // for <br> <br>   SelectFont (hDC, pLegend-&gt;hFontItems) ; <br>   pLegend-&gt;yItemHeight = FontHeight (hDC, TRUE) + 2 * LegendItemTopMargin () ; <br> <br>   pLegend-&gt;aCols[LegendColorCol].xMaxWidth = max (3 * xScrollWidth, <br>      pLegend-&gt;aCols[LegendColorCol].xMinWidth) ; <br> <br>   pLegend-&gt;aCols[LegendScaleCol].xMaxWidth = TextWidth (hDC, eScaleValueSpace) ; <br>   pLegend-&gt;aCols[LegendCounterCol].xMaxWidth = iLegendColMax ; <br>   pLegend-&gt;aCols[LegendInstanceCol].xMaxWidth = iLegendColMax ; <br>   pLegend-&gt;aCols[LegendParentCol].xMaxWidth = iLegendColMax ; <br>   pLegend-&gt;aCols[LegendObjectCol].xMaxWidth = iLegendColMax ; <br>   pLegend-&gt;aCols[LegendSystemCol].xMaxWidth = iLegendColMax ; <br>    <br>   pLegend-&gt;aCols[LegendColorCol].iOrientation = LEFTORIENTATION ; <br>   pLegend-&gt;aCols[LegendScaleCol].iOrientation = RIGHTORIENTATION ; <br> <br>   ReleaseDC (hWnd, hDC) ;    <br> <br>   //=============================// <br>   // Create Legend Items Listbox // <br>   //=============================// <br> <br>   pLegend-&gt;hWndItems = <br>      CreateWindow (TEXT("ListBox"),               // window class <br>                    NULL,                          // window caption <br>                    dwGraphLegendItemsWindowStyle, // window style <br>                    0, 0, 0, 0,                    // window size and pos <br>                    hWnd,                          // parent window <br>                    NULL,                          // menu <br>                    hInstance,                     // program instance <br>                    (LPVOID) TRUE) ;               // user-supplied data <br>   }  // OnLegendCreate <br>    <br> <br>void static OnSize (HWND hWnd, int xWidth, int yHeight) <br>/* <br>   Effect:        Perform all actions necessary when the legend window is <br>                  being resized. In particular, set the width and starting <br>                  position for each column of the legend list and labels. <br> <br>   Internals:     What we do is determine the amount of space in the <br>                  width that is greater than the minimum, and allocate <br>                  that space among each of the columns that is willing to <br>                  be larger than minimum. If there is not enough room for <br>                  the minimum, don't bother with calculations. <br>*/ <br> <br>   {  // OnSize <br>   PLEGEND        pLegend ; <br>   PLEGENDCOL     pCol ; <br>   int            xMin ; <br>   int            xSlack ; <br>   int            iColsToGrow ; <br>   int            iCol ; <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   //=============================// <br>   // Resize Legend Items         // <br>   //=============================// <br> <br>   if (IsLegendLabelVisible ()) <br>      MoveWindow (pLegend-&gt;hWndItems,  <br>                  LegendLeftMargin (), pLegend-&gt;yLabelHeight + ThreeDPad, <br>                  xWidth - 2 * LegendLeftMargin (), <br>                  yHeight - pLegend-&gt;yLabelHeight - yLegendBorderHeight, <br>                  TRUE) ; <br>   else <br>      MoveWindow (pLegend-&gt;hWndItems, <br>                  0, 0,  <br>                  xWidth, yHeight, <br>                  TRUE) ; <br>                   <br>       <br>   //=============================// <br>   // Allocate width to Columns   // <br>   //=============================// <br> <br>   xMin = LegendMinWidth (hWnd) ; <br>   xSlack = max (xWidth - xMin, 0) ; <br>   iColsToGrow = 0 ; <br> <br>   for (iCol = 0 ; <br>        iCol &lt; iLegendNumCols ; <br>        iCol++) <br>      {  // for <br>      pCol = &amp;(pLegend-&gt;aCols[iCol]) ; <br> <br>      pCol-&gt;xWidth = pCol-&gt;xMinWidth ; <br>      if (ColCanGrow (pCol)) <br>         iColsToGrow++ ; <br>      }  // for <br> <br>   for (iCol = 0 ; <br>        iCol &lt; iLegendNumCols ; <br>        iCol++) <br>      {  // for <br>      pCol = &amp;(pLegend-&gt;aCols[iCol]) ; <br> <br>      if (ColCanGrow (pCol)) <br>         { <br>         if ((pCol-&gt;xWidth + xSlack / iColsToGrow) &gt; <br>             pCol-&gt;xMaxWidth) <br>            {  // if <br>            pCol-&gt;xWidth = pCol-&gt;xMaxWidth ; <br>            xSlack -= (pCol-&gt;xMaxWidth - pCol-&gt;xMinWidth) ; <br>            iColsToGrow-- ; <br>            }  // if <br>         }  // if <br>      }  // for <br> <br>   for (iCol = 0 ; <br>        iCol &lt; iLegendNumCols ; <br>        iCol++) <br>      {  // for <br>      pCol = &amp;(pLegend-&gt;aCols[iCol]) ; <br> <br>      if (ColCanGrow (pCol)) <br>        pCol-&gt;xWidth += xSlack / iColsToGrow ; <br>      }  // for <br> <br>   if (pLegend-&gt;aCols[LegendCounterCol].xWidth &lt; <br>      pLegend-&gt;aCols[LegendCounterCol].xMaxWidth) <br>      { <br>      // cut some from the other columns and give them to CounterCol <br>      if (pLegend-&gt;aCols[LegendColorCol].xWidth - xScrollWidth &gt;= <br>          pLegend-&gt;aCols[LegendColorCol].xMinWidth) <br>         { <br>         pLegend-&gt;aCols[LegendColorCol].xWidth -= xScrollWidth ;       <br>         pLegend-&gt;aCols[LegendCounterCol].xWidth += xScrollWidth ; <br>         } <br>      if (pLegend-&gt;aCols[LegendInstanceCol].xWidth - xScrollWidth &gt;= <br>          pLegend-&gt;aCols[LegendInstanceCol].xMinWidth) <br>         { <br>         pLegend-&gt;aCols[LegendInstanceCol].xWidth -= xScrollWidth ;       <br>         pLegend-&gt;aCols[LegendCounterCol].xWidth += xScrollWidth ; <br>         } <br>      if (pLegend-&gt;aCols[LegendParentCol].xWidth - xScrollWidth &gt;= <br>          pLegend-&gt;aCols[LegendParentCol].xMinWidth) <br>         { <br>         pLegend-&gt;aCols[LegendParentCol].xWidth -= xScrollWidth ;       <br>         pLegend-&gt;aCols[LegendCounterCol].xWidth += xScrollWidth ; <br>         } <br>      } <br> <br>    <br>   //=============================// <br>   // Set Column positions        // <br>   //=============================// <br> <br>   pLegend-&gt;aCols[0].xPos = LegendLeftMargin () ; <br>   for (iCol = 1 ; <br>        iCol &lt; iLegendNumCols ; <br>        iCol++) <br>      {  // for <br>      pLegend-&gt;aCols[iCol].xPos =  <br>         pLegend-&gt;aCols[iCol - 1].xPos + pLegend-&gt;aCols[iCol - 1].xWidth ; <br> <br>      if (iCol == LegendCounterCol) <br>         { <br>         // add some space between Scale/Value col &amp; Counter col <br>         pLegend-&gt;aCols[LegendCounterCol].xPos += LegendLeftMargin () ; <br>         } <br>      }  // for <br> <br>   }  // OnSize <br> <br> <br>void static OnPaint (HWND hWnd) <br>   {  // OnPaint <br>   PLEGEND        pLegend ; <br>   HDC            hDC ; <br>   PAINTSTRUCT    ps ; <br> <br>   hDC = BeginPaint (hWnd, &amp;ps) ; <br> <br>   if (IsLegendLabelVisible ()) <br>      { <br>      pLegend = LegendData (hWnd) ; <br>      DrawLegendLabel (pLegend, hDC, hWnd) ; <br>      } <br> <br>   if (LBNumItems (pLegend-&gt;hWndItems) == 0) <br>      { <br>      WindowInvalidate(pLegend-&gt;hWndItems) ; <br>      } <br> <br>   EndPaint (hWnd, &amp;ps) ; <br>   }  // OnPaint <br> <br> <br>void OnDrawLegendItem (HWND hWnd, <br>                        LPDRAWITEMSTRUCT lpDI) <br>   {  // OnDrawItem <br>   HFONT          hFontPrevious ; <br>   HDC            hDC ; <br>   PLEGEND        pLegend ; <br>   PLINESTRUCT    pLine ; <br>   int            iLBIndex ; <br>   COLORREF       preBkColor ; <br>   COLORREF       preTextColor ; <br>   BOOL           ResetColor = FALSE ; <br> <br>    <br>   hDC = lpDI-&gt;hDC ; <br>   iLBIndex = DIIndex (lpDI) ; <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   if (iLBIndex == -1) <br>      pLine = NULL ; <br>   else <br>      pLine = (PLINESTRUCT) LBData (pLegend-&gt;hWndItems, iLBIndex) ; <br> <br>   //=============================// <br>   // Set DC attributes           // <br>   //=============================// <br> <br> <br>   if (DISelected (lpDI) || pLine == NULL) <br>      {  // if <br>      preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ; <br>      preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ; <br>      ResetColor = TRUE ; <br>      }  // if <br>   ExtTextOut (hDC, lpDI-&gt;rcItem.left, lpDI-&gt;rcItem.top, <br>      ETO_OPAQUE, &amp;(lpDI-&gt;rcItem), NULL, 0, NULL ) ; <br>    <br> <br>   //=============================// <br>   // Draw Legend Item            // <br>   //=============================// <br> <br>   hFontPrevious = SelectFont (hDC, pLegend-&gt;hFontItems) ; <br>   if (pLine) <br>      DrawLegendItem (pLegend, pLine, lpDI-&gt;rcItem.top, hDC) ; <br>   SelectFont (hDC, hFontPrevious) ; <br> <br>   //=============================// <br>   // Draw Focus                  // <br>   //=============================// <br> <br>   if (DIFocus (lpDI)) <br>      DrawFocusRect (hDC, &amp;(lpDI-&gt;rcItem)) ; <br> <br> <br>   if (ResetColor == TRUE) <br>      {  // if <br>      preTextColor = SetTextColor (hDC, preTextColor) ; <br>      preBkColor = SetBkColor (hDC, preBkColor) ; <br>      }  // if <br>   }  // OnDrawItem <br> <br> <br>void static OnMeasureItem (HWND hWnd, <br>                           LPMEASUREITEMSTRUCT lpMI) <br>   {  // OnMeasureItem <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWnd) ; <br>   lpMI-&gt;itemHeight = pLegend-&gt;yItemHeight ; <br>   }  // OnMeasureItem <br> <br> <br>void static OnDestroy (HWND hWnd) <br>   { <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWnd) ; <br>   MemoryFree (pLegend) ; <br>   }  // OnDestroy <br> <br> <br> <br>void static OnDoubleClick (HWND hWnd) <br>   { <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWnd) ; <br>   if (!pLegend) <br>      return ; <br> <br>   switch (pLegend-&gt;iLineType) <br>      {  // switch <br>      case LineTypeChart: <br>         EditChart (hWndMain) ; <br>         break ; <br> <br>      case LineTypeAlert: <br>         EditAlert (hWndAlert) ; <br>         break ; <br>      }  // switch <br>   }  // OnDoubleClick <br> <br> <br>void static OnSetFocus (HWND hWnd) <br>   {  // OnSetFocus <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   SetFocus (pLegend-&gt;hWndItems) ; <br>   } <br> <br>void static OnSelectionChanged (HWND hWnd) <br>   {  // OnSelectionChanged <br>   PLEGEND        pLegend ; <br>   PGRAPHSTRUCT         pGraph ; <br>   int            iIndex ; <br> <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   // set the new selected line <br>   iIndex = LBSelection (pLegend-&gt;hWndItems) ; <br> <br>   if (iIndex == LB_ERR) <br>      return ; <br> <br>   LegendSetCurrentLine (pLegend, iIndex) ; <br> <br>   if (pLegend-&gt;iLineType == LineTypeChart) <br>      { <br>      pGraph = GraphData (hWndGraph) ; <br>       <br>      if (!PlayingBackLog()) <br>         { <br>         // update the min, max, &amp; avg of the current line <br>         UpdateValueBarData (pGraph) ; <br>         } <br> <br>      // update the valuebar display <br>      StatusTimer (hWndGraphStatus, TRUE) ; <br> <br>      // change the Current highlighted line if necessary <br>      if (pGraph &amp;&amp; pGraph-&gt;HighLightOnOff) <br>         { <br>         WindowInvalidate (hWndGraphDisplay) ; <br>         } <br>      } <br>   }  // OnSelectionChanged <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // </code></pre>
<p>
</p>
<pre><code>//==========================================================================// <br> <br> <br>LRESULT APIENTRY GraphLegendWndProc (HWND hWnd, <br>                                     WORD wMsg, <br>                                     WPARAM wParam, <br>                                     LONG lParam) <br>   {  // GraphLegendWndProc <br>   BOOL           bCallDefProc ; <br>   LRESULT        lReturnValue ; <br> <br> <br>   bCallDefProc = FALSE ; <br>   lReturnValue = 0L ; <br> <br>   switch (wMsg) <br>      {  // switch <br>      case WM_DELETEITEM: <br>         break ; <br> <br>      case WM_COMMAND: <br>         switch (HIWORD (wParam)) <br>            {  // switch <br>            case LBN_DBLCLK: <br>               OnDoubleClick (hWnd) ; <br>               break ; <br> <br>            case LBN_SELCHANGE: <br>               OnSelectionChanged (hWnd) ; <br>               break ; <br> <br>            default: <br>               break ; <br>            }  // switch <br>         break ; <br> <br>      case WM_CREATE: <br>         OnLegendCreate (hWnd, (LPCREATESTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hWnd) ; <br>         break ; <br> <br>      case WM_DRAWITEM: <br>         OnDrawLegendItem (hWnd, (LPDRAWITEMSTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_MEASUREITEM: <br>         OnMeasureItem (hWnd, (LPMEASUREITEMSTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_PAINT: <br>         OnPaint (hWnd) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ; <br>         break ; <br> <br>      case WM_SETFOCUS: <br>         OnSetFocus (hWnd) ; <br>         break ; <br> <br>      default: <br>         bCallDefProc = TRUE ; <br>      }  // switch <br> <br> <br>   if (bCallDefProc) <br>      lReturnValue = DefWindowProc (hWnd, wMsg, wParam, lParam) ; <br> <br>   return (lReturnValue); <br>   }  // GraphLegendWndProc <br> <br> <br>int LegendMinWidth (HWND hWnd) <br>   { <br>   PLEGEND        pLegend ; <br>   int            iCol ; <br>   int            xMinWidth ; <br> <br>   pLegend = LegendData (hWnd) ; <br>   xMinWidth = 0 ; <br> <br>   for (iCol = 0 ; <br>        iCol &lt; iLegendNumCols ; <br>        iCol++) <br>      {  // for <br>      xMinWidth += pLegend-&gt;aCols[iCol].xMinWidth ; <br>      }  // for <br> <br>   return (xMinWidth) ; <br>   } <br> <br> <br>int LegendMinHeight (HWND hWnd) <br>   { <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   if (IsLegendLabelVisible ()) <br>      return (pLegend-&gt;yLabelHeight + pLegend-&gt;yItemHeight) ; <br>   else <br>      return (pLegend-&gt;yItemHeight) ; <br>   } <br> <br> <br>int LegendHeight (HWND hWnd, int yGraphHeight) <br>/* <br>   Effect:        Return the best height for the Legend window given the  <br>                  number of items and label visibility of the legend, as <br>                  well as the overall height of the graph. <br>*/ <br>   {  // LegendHeight <br>   PLEGEND        pLegend ; <br>   int            yPreferredHeight ; <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   yPreferredHeight = yLegendBorderHeight + <br>                      pLegend-&gt;yItemHeight *  <br>                      PinInclusive (LBNumItems (pLegend-&gt;hWndItems), <br>                                    1, iLegendMaxVisibleItems) ; <br>   if (IsLegendLabelVisible ()) <br>      yPreferredHeight += pLegend-&gt;yLabelHeight ; <br> <br>   return (min (yPreferredHeight, yGraphHeight / 2)) ; <br>   }  // LegendHeight <br> <br> <br> <br>int LegendFullHeight (HWND hWnd, HDC hDC) <br>/* <br>   Effect:        Return the best height for the Legend window given the  <br>                  number of items and label visibility of the legend, as <br>                  well as the overall height of the graph. <br>*/ <br>   {  // LegendHeight <br>   PLEGEND        pLegend ; <br>   int            yPreferredHeight ; <br> <br>   pLegend = LegendData (hWnd) ; <br> <br>   yPreferredHeight = yLegendBorderHeight + <br>                      pLegend-&gt;yItemHeight *  <br>                      LBNumItems (pLegend-&gt;hWndItems) ; <br>   if (IsLegendLabelVisible ()) <br>      yPreferredHeight += pLegend-&gt;yLabelHeight ; <br> <br>   return (yPreferredHeight) ; <br>   }  // LegendFullHeight <br> <br> <br> <br> <br>HWND CreateGraphLegendWindow (HWND hWndGraph) <br>   { <br>   return (CreateWindow (szGraphLegendClass,       // class <br>                         NULL,                     // caption <br>                         dwGraphLegendWindowStyle, // window style <br>                         0, 0,                     // position <br>                         0, 0,                     // size <br>                         hWndGraph,                // parent window <br>                         NULL,                     // menu <br>                         hInstance,                // program instance <br>                         (LPVOID) TRUE)) ;         // user-supplied data <br>   } <br> <br> <br>BOOL GraphLegendInitializeApplication (void) <br>/* <br>   Called By:     GraphInitializeApplication only <br>*/ <br>   { <br>   WNDCLASS       wc ; <br> <br>   wc.style          = dwGraphLegendClassStyle ; <br>   wc.lpfnWndProc    = (WNDPROC) GraphLegendWndProc ; <br>   wc.hInstance      = hInstance ; <br>   wc.cbClsExtra     = iGraphLegendClassExtra ; <br>   wc.cbWndExtra     = iGraphLegendWindowExtra ; <br>   wc.hIcon          = NULL ; <br>   wc.hCursor        = LoadCursor (NULL, IDC_ARROW) ; <br>   wc.hbrBackground  = hbLightGray ; <br>   wc.lpszMenuName   = NULL ; <br>   wc.lpszClassName  = szGraphLegendClass ; <br> <br>   return (RegisterClass (&amp;wc)) ; <br>   } <br> <br> <br>BOOL LegendAddItem (HWND hWnd, PLINESTRUCT pLine) <br>/* <br>   Effect:        Add a legend entry for the line pLine. Don't select <br>                  the line as current entry here, because this will cause <br>                  the scroll bar to unneccesarily appear for a moment. <br>                  If you want this line to be the current line, resize  <br>                  the legend first, then set as current line. <br> <br>   See Also:      ChartInsertLine, AlertInsertLine.                   <br>*/ <br>   {  // LegendAddItem <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWnd) ; <br>   LBAdd (pLegend-&gt;hWndItems, pLine) ; <br> <br>   return (TRUE) ; <br>   }  // LegendAddItem <br> <br> <br>void LegendDeleteItem (HWND hWndLegend,  <br>                       PLINE pLine) <br>   {  // LegendDeleteItem <br>   PLEGEND        pLegend ; <br>   int            iIndex ; <br>   int            iNextIndex ; <br>   int            iNumItems ; <br>   PGRAPHSTRUCT   pGraph ; <br> <br>   pLegend = LegendData (hWndLegend) ; <br>   if (!pLegend) <br>      return ; <br> <br>   iNumItems = LBNumItems (pLegend-&gt;hWndItems) ; <br> <br>   iIndex = LBFind (pLegend-&gt;hWndItems, pLine) ; <br> <br>   if (iIndex != LB_ERR) <br>      { <br>      LBDelete (pLegend-&gt;hWndItems, iIndex) ; <br>      } <br> <br>   // no need to do anything if iNumItems is 1 to begin with <br>   if (iNumItems != LB_ERR &amp;&amp; iNumItems &gt; 1) <br>      { <br>      if (iIndex == iNumItems - 1) <br>         { <br>         // deleting the last line, then set selection <br>         // to the previous legend line <br>         iNextIndex = iIndex - 1 ; <br>         } <br>      else <br>         { <br>         // set the selection to the next legend line <br>         iNextIndex = iIndex ; <br>         } <br> <br>      LBSetSelection (pLegend-&gt;hWndItems, iNextIndex) ; <br>      LegendSetCurrentLine (pLegend, iNextIndex) ; <br> <br>      if (pLegend-&gt;iLineType == LineTypeChart) <br>         { <br>         // update the min, max, &amp; avg of the current line <br>         pGraph = GraphData (hWndGraph) ; <br> <br>         if (!PlayingBackLog()) <br>            { <br>            // update the min, max, &amp; avg of the current line <br>            UpdateValueBarData (pGraph) ; <br>            } <br>    <br>         // update the valuebar display <br>         StatusTimer (hWndGraphStatus, TRUE) ; <br>         } <br>      } <br> <br>   }  // LegendDeleteItem <br> <br> <br>PLINE LegendCurrentLine (HWND hWndLegend) <br>   {  // LegendCurrentLine <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWndLegend) ; <br> <br>   if (!pLegend) <br>      return (NULL) ; <br> <br>   return (pLegend-&gt;pCurrentLine) ; <br> <br>   }  // LegendCurrentLine <br> <br> <br> <br>int LegendNumItems (HWND hWndLegend) <br>   {  // LegendNumItems <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWndLegend) ; <br> <br>   return (LBNumItems (pLegend-&gt;hWndItems)) ; <br>   }  // LegendNumItems <br> <br> <br> <br>void LegendSetSelection (HWND hWndLegend, int iIndex) <br>   {  // LegendSetSelection <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWndLegend) ; <br>   LBSetSelection (pLegend-&gt;hWndItems, iIndex) ; <br>   LegendSetCurrentLine (pLegend, iIndex) ; <br>   }  // LegendSetSelection    <br> <br> <br> <br>#ifdef KEEP_PRINT <br> <br>void PrintLegend (HDC hDC, PGRAPHSTRUCT pGraph, HWND hWndLegend, <br>                  RECT rectLegend) <br>   { <br>   PLEGEND        pLegend ; <br>   int            yItemHeight ; <br>   HFONT          hFontItems ; <br>   PLINE          pLine ; <br>   int            iIndex ; <br>   int            iIndexNum ; <br> <br> <br>   pLegend = LegendData (hWndLegend) ; <br> <br>   yItemHeight = pLegend-&gt;yItemHeight ; <br>   hFontItems = pLegend-&gt;hFontItems ; <br> <br>   pLegend-&gt;hFontItems = hFontPrinterScales ; <br>   SelectFont (hDC, pLegend-&gt;hFontItems) ; <br> <br>   pLegend-&gt;yItemHeight = FontHeight (hDC, TRUE) ; <br> <br>   iIndexNum = LBNumItems (pLegend-&gt;hWndItems) ; <br>   for (iIndex = 0 ; <br>        iIndex &lt; iIndexNum ; <br>        iIndex++) <br>      {  // for <br>      pLine = (PLINE) LBData (pLegend-&gt;hWndItems, iIndex) ; <br>      DrawLegendItem (pLegend, pLine, iIndex * pLegend-&gt;yItemHeight, hDC) ; <br>      }  // for <br> <br>   pLegend-&gt;hFontItems = hFontItems ; <br>   pLegend-&gt;yItemHeight = yItemHeight ; <br> <br> <br>   SelectBrush (hDC, GetStockObject (HOLLOW_BRUSH)) ; <br>   SelectPen (hDC, GetStockObject (BLACK_PEN)) ; <br>   Rectangle (hDC, 0, 0,  <br>              rectLegend.right - rectLegend.left, <br>              rectLegend.bottom - rectLegend.top) ; <br>   } <br>#endif <br> <br> <br>void ClearLegend (HWND hWndLegend) <br>   { <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWndLegend) ; <br>   if (!pLegend) <br>      return ; <br> <br>   LBReset (pLegend-&gt;hWndItems) ; <br>   pLegend-&gt;pCurrentLine = NULL ; <br>   } <br> <br>void LegendSetRedraw (HWND hWndLegend, BOOL bRedraw) <br>   { <br>   PLEGEND        pLegend ; <br> <br>   pLegend = LegendData (hWndLegend) ; <br>   if (!pLegend) <br>      return ; <br> <br>   LBSetRedraw (pLegend-&gt;hWndItems, bRedraw) ; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
