<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5714"></a>UTILS.C</h2>
<pre><code>/* <br>============================================================================== <br> <br>  Application: <br> <br>            Microsoft Windows NT (TM) Performance Monitor <br> <br>  File: <br>            utils.c -- miscellaneous utility routines.   <br> <br>            This file contains miscellaneous utiltity routines, mostly  <br>            low-level windows helpers. These routines are not specific <br>            to the perfmon utillity. <br> <br>  Copyright 1992 - 1998 Microsoft Corporation. All Rights Reserved. <br>  Microsoft Confidential. <br>============================================================================== <br>*/ <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br> <br>#include &lt;stdarg.h&gt;  // For ANSI variable args. Dont use UNIX &lt;varargs.h&gt; <br>#include &lt;stdlib.h&gt;  // For itoa <br>#include &lt;stdio.h&gt;   // for vsprintf. <br>#include &lt;string.h&gt;  // for strtok <br>#include &lt;wchar.h&gt;   // for swscanf <br> <br>#include "perfmon.h" <br>#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines <br>#include "utils.h" <br>#include "pmhelpid.h"       // IDs for WinHelp <br>#include "perfmops.h"       // for ConvertDecimalPoint() &amp; ReconvertDecimalPoint() <br>#include "sizes.h" <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define DOS_FILES                0x0000   // Ordinary files <br>#define DOS_READONLY             0x0001   // Read-only files <br>#define DOS_HIDDEN               0x0002   // Hidden files <br>#define DOS_SYSTEM               0x0004   // System files <br>#define DOS_SUBDIRECTORIES       0x0010   // Subdirectories <br>#define DOS_ARCHIVES             0x0020   // Archives <br>#define DOS_LIB_DIR              0x2000   // LB_DIR flag <br>#define DOS_DRIVES               0x4000   // Drives <br>#define DOS_EXCLUSIVE            0x8000   // Exclusive bit <br>#define DOS_DRIVES_DIRECTORIES   0xC010   // Find drives and directories only <br> <br> <br>#define WILD_ONE                 '?' <br>#define WILD_ANY                 '*' <br> <br> <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br> <br>void ClientRectToScreen (HWND hWnd, <br>                         LPRECT lpRect) <br>/* <br>   Effect:        Remaps lpRect from client coordinates to screen <br>                  coordinates. Analogous to ClientToScreen for rectangles. <br> <br>   Note:          To convert a rectangle from the client coordinates of <br>                  Wnd1 to the client coordinates of Wnd2, call: <br> <br>                        ClientRectToScreen (hWnd1, &amp;rect) ; <br>                        ScreenRectToClient (hWnd2, &amp;rect) ; <br> <br>   See Also:      ClientToScreen (windows), ScreenRectToClient. <br> <br>   Internals:     Since a rectangle is really only two points, let <br>                  windows do the work with ClientToScreen. <br>*/ <br>   {  /* ClientRectToScreen */ <br>   POINT    pt1, pt2 ; <br> <br>   pt1.x = lpRect-&gt;left ; <br>   pt1.y = lpRect-&gt;top ; <br> <br>   pt2.x = lpRect-&gt;right ; <br>   pt2.y = lpRect-&gt;bottom ; <br> <br>   ClientToScreen (hWnd, &amp;pt1) ; <br>   ClientToScreen (hWnd, &amp;pt2) ; <br> <br>   lpRect-&gt;left = pt1.x ; <br>   lpRect-&gt;top = pt1.y ; <br> <br>   lpRect-&gt;right = pt2.x ; <br>   lpRect-&gt;bottom = pt2.y ; <br>   }  // ClientRectToScreen <br> <br> <br>void ScreenRectToClient (HWND hWnd, LPRECT lpRect) <br>/* <br>   Effect:        Remaps lpRect from screen coordinates to client <br>                  coordinates. Analogous to ScreenToClient for rectangles. <br> <br>   Note:          To convert a rectangle from the client coordinates of <br>                  Wnd1 to the client coordinates of Wnd2, call: <br> <br>                        ClientRectToScreen (hWnd1, &amp;rect) ; <br>                        ScreenRectToClient (hWnd2, &amp;rect) ; <br> <br>   See Also:      ScreenToClient (windows), ClientRectToScreen. <br> <br>   Internals:     Since a rectangle is really only two points, let <br>                  windows do the work with ScreenToClient. <br>*/ <br>   {  // ScreenRectToClient <br>   POINT    pt1, pt2 ; <br> <br>   pt1.x = lpRect-&gt;left ; <br>   pt1.y = lpRect-&gt;top ; <br> <br>   pt2.x = lpRect-&gt;right ; <br>   pt2.y = lpRect-&gt;bottom ; <br> <br>   ScreenToClient (hWnd, &amp;pt1) ; <br>   ScreenToClient (hWnd, &amp;pt2) ; <br> <br>   lpRect-&gt;left = pt1.x ; <br>   lpRect-&gt;top = pt1.y ; <br> <br>   lpRect-&gt;right = pt2.x ; <br>   lpRect-&gt;bottom = pt2.y ; <br>   }  // ScreenRectToClient <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>void Line (HDC hDC, <br>           HPEN hPen, <br>           int x1, int y1, <br>           int x2, int y2) <br>   {  // Line <br>   HPEN           hPenPrevious ; <br> <br>   if (hPen) <br>      hPenPrevious = SelectPen (hDC, hPen) ; <br>   MoveToEx (hDC, x1, y1, NULL) ; <br>   LineTo (hDC, x2, y2) ; <br>   if (hPen) <br>      SelectObject (hDC, hPenPrevious) ; <br>   }  // Line <br> <br>#if 0 <br>void HLine (HDC hDC, <br>            HPEN hPen, <br>            int x1,  <br>            int x2,  <br>            int y) <br>   {  // HLine <br>   Line (hDC, hPen, x1, y, x2, y) ; <br>   } <br> <br> <br>void VLine (HDC hDC, <br>            HPEN hPen, <br>            int x, <br>            int y1, <br>            int y2) <br>   {  // VLine <br>   Line (hDC, hPen, x, y1, x, y2) ; <br>   }  // VLine <br>#endif <br> <br>#ifdef  KEEP_UTIL <br>void Fill (HDC hDC, <br>           DWORD rgbColor, <br>           LPRECT lpRect) <br>   {  // Fill <br>   HBRUSH         hBrush ; <br> <br>   hBrush = CreateSolidBrush (rgbColor) ; <br> <br>   FillRect (hDC, lpRect, hBrush) ; <br> <br>   DeleteBrush (hBrush) ; <br>   }  // Fill <br> <br>void ThreeDConvex (HDC hDC, <br>               int x1, int y1,  <br>               int x2, int y2) <br>   {  // ThreeDConvex <br>   HBRUSH         hBrushPrevious ; <br>   POINT          aPoints [8] ; <br>   DWORD          aCounts [2] ; <br>   HPEN           hPenPrevious ; <br> <br> <br>   //                               <br>   //  Draw Face                    <br>   //                               <br> <br>   hBrushPrevious = SelectBrush (hDC, hBrushFace) ; <br>   PatBlt (hDC,  <br>           x1 + ThreeDPad, y1 + ThreeDPad,  <br>           x2 - x1 - ThreeDPad, y2 - y1 - ThreeDPad,  <br>           PATCOPY) ; <br>   SelectBrush (hDC, hBrushPrevious) ; <br> <br>   //                               <br>   //  Draw Highlight               <br>   //                               <br> <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenHighlight) ; <br> <br>   aPoints [0].x = x1 ; <br>   aPoints [0].y = y2 - 1 ;   // this works slightly diff. than Line ?? <br>   aPoints [1].x = x1 ; <br>   aPoints [1].y = y1 ; <br>   aPoints [2].x = x2 ; <br>   aPoints [2].y = y1 ; <br> <br>   aPoints [3].x = x1 + 1 ; <br>   aPoints [3].y = y2 - 1 ; <br>   aPoints [4].x = x1 + 1 ; <br>   aPoints [4].y = y1 + 1 ; <br>   aPoints [5].x = x2 - 1 ; <br>   aPoints [5].y = y1 + 1 ; <br> <br>   aCounts [0] = 3 ; <br>   aCounts [1] = 3 ; <br> <br>   PolyPolyline (hDC, aPoints, aCounts, 2) ; <br>    <br>    <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br> <br>//   HLine (hDC, hPenHighlight, x1, x2, y1) ;              // outside top line <br>//   HLine (hDC, hPenHighlight, x1 + 1, x2 - 1, y1 + 1) ;  // inside top line <br>//   VLine (hDC, hPenHighlight, x1, y1, y2) ;              // outside left line <br>//   VLine (hDC, hPenHighlight, x1 + 1, y1 + 1, y2 - 1) ;  // inside left line <br> <br>   //                               <br>   //  Draw Shadow                  <br>   //                               <br> <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenShadow) ; <br> <br>   aPoints [0].x = x1 + 1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x2 ; <br>   aPoints [1].y = y2 - 1 ; <br>   aPoints [2].x = x2 ; <br>   aPoints [2].y = y2 - 2 ; <br>   aPoints [3].x = x1 + 2 ; <br>   aPoints [3].y = y2 - 2 ; <br> <br>   aPoints [4].x = x2 - 1 ; <br>   aPoints [4].y = y1 ; <br>   aPoints [5].x = x2 - 1 ; <br>   aPoints [5].y = y2 - 1; <br>   aPoints [6].x = x2 - 2 ; <br>   aPoints [6].y = y2 - 1 ; <br>   aPoints [7].x = x2 - 2 ; <br>   aPoints [7].y = y1 ; <br> <br>   aCounts [0] = 4 ; <br>   aCounts [1] = 4 ; <br> <br>   PolyPolyline (hDC, aPoints, aCounts, 2) ; <br>    <br>    <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br> <br>//   HLine (hDC, hPenShadow, x1 + 1, x2, y2 - 1) ;   // outside bottom line <br>//   HLine (hDC, hPenShadow, x1 + 2, x2, y2 - 2) ;   // inside bottom line <br>//   VLine (hDC, hPenShadow, x2 - 1, y1 + 1, y2) ;   // outside right line <br>//   VLine (hDC, hPenShadow, x2 - 2, y1 + 2, y2) ;   // inside right line <br> <br>   }  // ThreeDConvex <br> <br> <br> <br>void ThreeDConcave (HDC hDC, <br>                    int x1, int y1,  <br>                    int x2, int y2, <br>                    BOOL bFace) <br>   {  // ThreeDConcave <br>   HBRUSH         hBrushPrevious ; <br>   POINT          aPoints [6] ; <br>   DWORD          aCounts [2] ; <br>   HPEN           hPenPrevious ; <br> <br> <br>   //                               <br>   //  Draw Face                    <br>   //                               <br> <br>   if (bFace) <br>      { <br>      hBrushPrevious = SelectBrush (hDC, hBrushFace) ; <br>      PatBlt (hDC,  <br>              x1 + ThreeDPad, y1 + ThreeDPad,  <br>              x2 - x1 - ThreeDPad, y2 - y1 - ThreeDPad,  <br>              PATCOPY) ; <br>      SelectBrush (hDC, hBrushPrevious) ; <br>      } <br> <br>   //                               <br>   //  Draw Shadow                  <br>   //                               <br> <br>#if 1 <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenShadow) ; <br> <br>   aPoints [0].x = x1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x1 ; <br>   aPoints [1].y = y1 ; <br>   aPoints [2].x = x2 ; <br>   aPoints [2].y = y1 ; <br> <br>   aPoints [3].x = x1 + 1 ; <br>   aPoints [3].y = y2 - 1 ; <br>   aPoints [4].x = x1 + 1 ; <br>   aPoints [4].y = y1 + 1 ; <br>   aPoints [5].x = x2 - 1 ; <br>   aPoints [5].y = y1 + 1 ; <br> <br>   aCounts [0] = 3 ; <br>   aCounts [1] = 3 ; <br> <br>   PolyPolyline (hDC, aPoints, aCounts, 2) ; <br>    <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br> <br>#else <br>   HLine (hDC, hPenShadow, x1, x2, y1) ;              // outside top line <br>   HLine (hDC, hPenShadow, x1 + 1, x2 - 1, y1 + 1) ;  // inside top line <br>   VLine (hDC, hPenShadow, x1, y1, y2) ;              // outside left line <br>   VLine (hDC, hPenShadow, x1 + 1, y1 + 1, y2 - 1) ;  // inside left line <br>#endif <br> <br>   //                               <br>   //  Draw Highlight               <br>   //                               <br> <br>#if 1 <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenHighlight) ; <br> <br>   aPoints [0].x = x1 + 1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x2 ; <br>   aPoints [1].y = y2 - 1 ; <br> <br>   aPoints [2].x = x2 - 1 ; <br>   aPoints [2].y = y2 - 1 ; <br>   aPoints [3].x = x2 - 1 ; <br>   aPoints [3].y = y1 ; <br> <br>   aCounts [0] = 2 ; <br>   aCounts [1] = 2 ; <br> <br>   PolyPolyline (hDC, aPoints, aCounts, 2) ; <br>    <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br> <br>#else <br>   HLine (hDC, hPenHighlight, x1 + 1, x2, y2 - 1) ;   // outside bottom line <br>   VLine (hDC, hPenHighlight, x2 - 1, y1 + 1, y2) ;   // outside right line <br>#endif    <br>   }  // ThreeDConcave <br>#endif // KEEP_UTIL <br> <br>      <br>void ThreeDConvex1 (HDC hDC, <br>                    int x1, int y1,  <br>                    int x2, int y2) <br>   {  // ThreeDConvex1 <br>   HBRUSH         hBrushPrevious ; <br>   POINT          aPoints [6] ; <br>   DWORD          aCounts [2] ; <br>   HPEN           hPenPrevious ; <br> <br> <br>   //                               <br>   //  Draw Face                    <br>   //                               <br>#if 1 <br>   hBrushPrevious = SelectBrush (hDC, hBrushFace) ; <br>   PatBlt (hDC,  <br>           x1 + 1, y1 + 1,  <br>           x2 - x1 - 1, y2 - y1 - 1,  <br>           PATCOPY) ; <br>   SelectBrush (hDC, hBrushPrevious) ; <br> <br>   //                               <br>   //  Draw Highlight               <br>   //                               <br> <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenHighlight) ; <br> <br>   aPoints [0].x = x1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x1 ; <br>   aPoints [1].y = y1 ; <br>   aPoints [2].x = x2 ; <br>   aPoints [2].y = y1 ; <br> <br>   Polyline (hDC, aPoints, 3) ; <br>    <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br> <br>#else <br>   HLine (hDC, hPenHighlight, x1, x2, y1) ;              // outside top line <br>   VLine (hDC, hPenHighlight, x1, y1, y2) ;              // outside left line <br>#endif <br> <br>   //                               <br>   //  Draw Shadow                  <br>   //                               <br> <br>#if 1 <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenShadow) ; <br> <br>   aPoints [0].x = x1 + 1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x2 ; <br>   aPoints [1].y = y2 - 1 ; <br> <br>   aPoints [2].x = x2 - 1 ; <br>   aPoints [2].y = y2 - 1 ; <br>   aPoints [3].x = x2 - 1 ; <br>   aPoints [3].y = y1 ; <br> <br>   aCounts [0] = 2 ; <br>   aCounts [1] = 2 ; <br> <br>   PolyPolyline (hDC, aPoints, aCounts, 2) ; <br>    <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br>#else <br>   HLine (hDC, hPenShadow, x1 + 1, x2, y2 - 1) ;   // outside bottom line <br>   VLine (hDC, hPenShadow, x2 - 1, y1 + 1, y2) ;   // outside right line <br>#endif <br> <br>   }  // ThreeDConvex1 <br> <br> <br> <br>void ThreeDConcave1 (HDC hDC, <br>                     int x1, int y1,  <br>                     int x2, int y2) <br>   {  // ThreeDConcave1 <br>   HBRUSH         hBrushPrevious ; <br>   POINT          aPoints [6] ; <br>   DWORD          aCounts [2] ; <br>   HPEN           hPenPrevious ; <br> <br> <br>   //                               <br>   //  Draw Face                    <br>   //                               <br> <br>   hBrushPrevious = SelectBrush (hDC, hBrushFace) ; <br>   PatBlt (hDC,  <br>           x1 + 1, y1 + 1,  <br>           x2 - x1 - 1, y2 - y1 - 1,  <br>           PATCOPY) ; <br>   SelectBrush (hDC, hBrushPrevious) ; <br> <br>   //                               <br>   //  Draw Shadow                  <br>   //                               <br> <br>#if 1 <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenShadow) ; <br> <br>   aPoints [0].x = x1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x1 ; <br>   aPoints [1].y = y1 ; <br>   aPoints [2].x = x2 ; <br>   aPoints [2].y = y1 ; <br> <br>   Polyline (hDC, aPoints, 3) ; <br>    <br>   if (hPenShadow) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br>#else <br>   HLine (hDC, hPenShadow, x1, x2, y1) ;              // outside top line <br>   VLine (hDC, hPenShadow, x1, y1, y2) ;              // outside left line <br>#endif <br> <br>   //                               <br>   //  Draw Highlight               <br>   //                               <br>#if 1 <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenHighlight) ; <br> <br>   aPoints [0].x = x1 + 1 ; <br>   aPoints [0].y = y2 - 1 ; <br>   aPoints [1].x = x2 ; <br>   aPoints [1].y = y2 - 1 ; <br> <br>   aPoints [2].x = x2 - 1 ; <br>   aPoints [2].y = y2 - 2 ; <br>   aPoints [3].x = x2 - 1 ; <br>   aPoints [3].y = y1 ; <br> <br>   aCounts [0] = 2 ; <br>   aCounts [1] = 2 ; <br> <br>   PolyPolyline (hDC, aPoints, aCounts, 2) ; <br>    <br>   if (hPenHighlight) <br>      hPenPrevious = SelectPen (hDC, hPenPrevious) ; <br>#else <br>   HLine (hDC, hPenHighlight, x1 + 1, x2, y2 - 1) ;   // outside bottom line <br>   VLine (hDC, hPenHighlight, x2 - 1, y1 + 1, y2) ;   // outside right line <br>#endif <br>    <br>   }  // ThreeDConcave1 <br> <br> <br>int TextWidth (HDC hDC, LPTSTR lpszText) <br>   { <br>   SIZE           size ; <br> <br>   if (!lpszText) <br>      return (0) ; <br> <br>   GetTextExtentPoint (hDC, lpszText, lstrlen (lpszText), &amp;size) ; <br>   return  (size.cx) ; <br>   } <br> <br> <br>int _cdecl DlgErrorBox (HWND hDlg, UINT id, ...) <br>   { <br>   TCHAR          szMessageFmt [FilePathLen + 1] ; <br>   TCHAR          szBuffer [FilePathLen * 2] ; <br>   va_list        vaList ; <br>   int            NumOfChar ; <br>   TCHAR          szApplication [WindowCaptionLen] ; <br> <br>   NumOfChar = StringLoad (id, szMessageFmt) ; <br> <br>   if (NumOfChar) <br>      { <br>      va_start (vaList, id) ; <br>      TSPRINTF (szBuffer, szMessageFmt, va_arg(vaList, LPTSTR)) ; <br>      va_end (vaList) ; <br> <br>      StringLoad (IDS_APPNAME, szApplication) ; <br> <br>      MessageBox (hDlg, szBuffer, szApplication, <br>         MB_OK | MB_ICONSTOP | MB_TASKMODAL) ; <br>      } <br> <br>   return (0) ; <br>   } <br> <br> <br> <br> <br> <br> <br>int FontHeight (HDC hDC,  <br>                 BOOL bIncludeLeading) <br>   {  // FontHeight <br>   TEXTMETRIC     tm ; <br> <br>   GetTextMetrics (hDC, &amp;tm) ; <br>   if (bIncludeLeading) <br>      return (tm.tmHeight + tm.tmExternalLeading) ; <br>   else <br>      return (tm.tmHeight) ; <br>   }  // FontHeight <br> <br> <br> <br>int TextAvgWidth (HDC hDC, <br>                  int iNumChars) <br>   { <br>   TEXTMETRIC     tm ; <br>   int            xAvgWidth ; <br> <br>   GetTextMetrics (hDC, &amp;tm) ; <br> <br>   xAvgWidth = iNumChars * tm.tmAveCharWidth ; <br> <br>   // add 10% slop <br>   return (MulDiv (xAvgWidth, 11, 10)) ;    <br>   } <br> <br> <br>void WindowCenter (HWND hWnd) <br>/* <br>   Effect:        Center the window hWnd in the center of the screen. <br>                  Physically update the windows appearance as well. <br> <br>   Globals:       xScreenWidth, yScreenHeight. <br>*/ <br>   {  // WindowCenter <br>   RECT           rectWindow ; <br>   int            xWindowWidth, yWindowHeight ; <br> <br>   GetWindowRect (hWnd, &amp;rectWindow) ; <br>   xWindowWidth = rectWindow.right - rectWindow.left ; <br>   yWindowHeight = rectWindow.bottom - rectWindow.top ; <br> <br>   MoveWindow (hWnd, <br>               (xScreenWidth - xWindowWidth) / 2, <br>               (yScreenHeight - yWindowHeight) / 2, <br>               xWindowWidth, <br>               yWindowHeight, <br>               TRUE) ; <br>   }  // WindowCenter <br> <br> <br> <br>BOOL DialogMove (HDLG hDlg, <br>                 WORD wControlID, <br>                 int xPos,  <br>                 int yPos, <br>                 int xWidth, <br>                 int yHeight) <br>/* <br>   Effect:        Move the control identified by wControlID in the dialog   <br>                  hDlg to the new position (xPos, yPos), and resize to <br>                  (xWidth, yHeight). If any of these values are NOCHANGE, retain <br>                  the current value. <br> <br>   Examples:      DialogMove (hDlg, IDD_FOO, 10, 20, NOCHANGE, NOCHANGE) <br>                     moves control but does not resize it <br> <br>                  DialogMove (hDlg, IDD_FOO, NOCHANGE, NOCHANGE, 100, NOCHANGE) <br>                     sets width of control to 100 <br>*/                      <br>   {  // DialogMove <br>   HWND        hWndControl ; <br>   RECT        rectControl ; <br> <br>   hWndControl = DialogControl (hDlg, wControlID) ; <br>   if (!hWndControl) <br>      return (FALSE) ; <br>   GetWindowRect (hWndControl, &amp;rectControl) ; <br>   ScreenRectToClient (hDlg, &amp;rectControl) ; <br> <br>   MoveWindow (hWndControl, <br>               (xPos == NOCHANGE) ? rectControl.left : xPos, <br>               (yPos == NOCHANGE) ? rectControl.top : yPos, <br>               (xWidth == NOCHANGE) ? rectControl.right - rectControl.left : xWidth, <br>               (yHeight == NOCHANGE) ? rectControl.bottom - rectControl.top : yHeight, <br>               TRUE) ; <br> <br>   return (TRUE) ; <br>   }  // DialogMove <br> <br> <br>int DialogWidth (HDLG hDlg,  <br>                 WORD wControlID) <br>   { <br>   HWND           hWndControl ; <br>   RECT           rectControl ; <br> <br>   hWndControl = DialogControl (hDlg, wControlID) ; <br>   if (!hWndControl) <br>      return (0) ; <br> <br>   GetWindowRect (hWndControl, &amp;rectControl) ; <br>   return (rectControl.right - rectControl.left) ; <br>   } <br>    <br> <br>int DialogHeight (HDLG hDlg,  <br>                  WORD wControlID) <br>   { <br>   HWND           hWndControl ; <br>   RECT           rectControl ; <br> <br>   hWndControl = DialogControl (hDlg, wControlID) ; <br>   if (!hWndControl) <br>      return (0) ; <br> <br>   GetWindowRect (hWndControl, &amp;rectControl) ; <br>   return (rectControl.bottom - rectControl.top) ; <br>   } <br>    <br> <br>int DialogXPos (HDLG hDlg, <br>                WORD wControlID) <br>   {  // DialogXPos <br>   HWND           hWndControl ; <br>   RECT           rectControl ; <br> <br>   hWndControl = DialogControl (hDlg, wControlID) ; <br>   if (!hWndControl) <br>      return (0) ; <br> <br>   GetWindowRect (hWndControl, &amp;rectControl) ; <br>   ScreenRectToClient (hDlg, &amp;rectControl) ; <br> <br>   return  (rectControl.left) ; <br>   }  // DialogXPos <br> <br> <br>int DialogYPos (HDLG hDlg, <br>                WORD wControlID) <br>   {  // DialogYPos <br>   HWND           hWndControl ; <br>   RECT           rectControl ; <br> <br>   hWndControl = DialogControl (hDlg, wControlID) ; <br>   if (!hWndControl) <br>      return (0) ; <br> <br>   GetWindowRect (hWndControl, &amp;rectControl) ; <br>   ScreenRectToClient (hDlg, &amp;rectControl) ; <br> <br>   return  (rectControl.top) ; <br>   }  // DialogYPos <br> <br> <br>void DialogEnable (HDLG hDlg, <br>                   WORD wID, <br>                   BOOL bEnable) <br>/* <br>   Effect:        Enable or disable (based on bEnable) the control  <br>                  identified by wID in dialog hDlg. <br> <br>   See Also:      DialogShow. <br>*/ <br>   {  // DialogEnable <br>   HCONTROL       hControl ; <br> <br>   hControl = GetDlgItem (hDlg, wID) ; <br>   if (hControl) <br>      EnableWindow (hControl, bEnable) ; <br>   }  // DialogEnable <br> <br> <br>void DialogShow (HDLG hDlg, <br>                 WORD wID, <br>                 BOOL bShow) <br>   {  // DialogShow <br>   HCONTROL       hControl ; <br> <br>   hControl = GetDlgItem (hDlg, wID) ; <br>   if (hControl) <br>      ShowWindow (hControl, bShow ? SW_SHOW : SW_HIDE) ; <br>   }  // DialogShow <br> <br> <br> <br> <br> <br> <br>BOOL _cdecl DialogSetText (HDLG hDlg, <br>                           WORD wControlID, <br>                           WORD wStringID, <br>                           ...) <br>   {  // DialogSetText <br>   TCHAR           szFormat [ControlStringLen] ; <br>   TCHAR           szText [ControlStringLen] ; <br>   va_list         vaList ; <br> <br>   if (LoadString (hInstance, wStringID, <br>                   szFormat, ControlStringLen - 1)) <br>      { <br>      va_start (vaList, wStringID) ; <br>      TSPRINTF (szText, szFormat, va_arg(vaList, LPTSTR)) ; <br>      va_end (vaList) ; <br> <br>      SetDlgItemText (hDlg, wControlID, szText) ; <br>      return (TRUE) ; <br>      }  // if <br>   else <br>      return (FALSE) ; <br>   }  // DialogSetText <br> <br> <br>// Bug - lpszFormat could contain % in it <br>#if 0 <br>BOOL _cdecl DialogSetString (HDLG hDlg, <br>                             WORD wControlID, <br>                             LPTSTR lpszFormat, <br>                             ...) <br>   {  // DialogSetString <br>   TCHAR          szText [ControlStringLen] ; <br>   va_list        vaList ; <br> <br>   va_start (vaList, lpszFormat) ; <br>   TSPRINTF (szText, lpszFormat, va_arg(vaList, LPTSTR)) ; <br>   va_end (vaList) ; <br> <br>   SetDlgItemText (hDlg, wControlID, szText) ; <br>   return (TRUE) ; <br>   }  // DialogSetString <br>#endif <br> <br> <br>LPTSTR LongToCommaString (LONG lNumber, <br>                          LPTSTR lpszText) <br>   {  // LongToCommaString <br>   BOOL           bNegative ; <br>   TCHAR          szTemp1 [40] ; <br>   TCHAR          szTemp2 [40] ; <br>   LPTSTR         lpsz1 ; <br>   LPTSTR         lpsz2 ; <br>   int            i ; <br>   int            iDigit ; <br> <br>   // 1. Convert the number to a reversed string. <br>   lpsz1 = szTemp1 ; <br>   bNegative = (lNumber &lt; 0) ; <br>   lNumber = labs (lNumber) ; <br> <br>   if (lNumber) <br>      while (lNumber) <br>         { <br>         iDigit = (int) (lNumber % 10L) ; <br>         lNumber /= 10L ; <br>         *lpsz1++ = (TCHAR) (TEXT('0') + iDigit) ; <br>         } <br>   else <br>      *lpsz1++ = TEXT('0') ; <br>   *lpsz1++ = TEXT('\0') ; <br> <br> <br>   // 2. reverse the string and add commas <br>   lpsz1 = szTemp1 + lstrlen (szTemp1) - 1 ; <br>   lpsz2 = szTemp2 ; <br> <br>   if (bNegative) <br>      *lpsz2++ = TEXT('-') ; <br> <br>   for (i = lstrlen (szTemp1) - 1; <br>        i &gt;= 0 ; <br>        i--) <br>      {  // for <br>      *lpsz2++ = *lpsz1-- ; <br>      if (i &amp;&amp; !(i % 3)) <br>         *lpsz2++ = TEXT(',') ; <br>      }  // for <br>   *lpsz2++ = TEXT('\0') ; <br> <br>   return (lstrcpy (lpszText, szTemp2)) ; <br>   }  // LongToCommaString <br> <br> <br> <br>BOOL MenuSetPopup (HWND hWnd, <br>                   int iPosition, <br>                   WORD  wControlID, <br>                   LPTSTR lpszResourceID) <br>   { <br>   HMENU          hMenuMain ; <br>   HMENU          hMenuPopup ; <br>   TCHAR          szTopChoice [MenuStringLen + 1] ; <br> <br>   hMenuMain = GetMenu (hWnd) ; <br>   hMenuPopup = LoadMenu (hInstance, lpszResourceID) ; <br> <br>   if (!hMenuMain || !hMenuPopup) <br>      return (FALSE) ; <br> <br>   StringLoad (wControlID, szTopChoice) ; <br>   return (ModifyMenu (hMenuMain, iPosition, MF_BYPOSITION | MF_POPUP, <br>                       (UINT) hMenuPopup, szTopChoice)) ; <br>   }                <br>          <br> <br>    <br>LPTSTR FileCombine (LPTSTR lpszFileSpec, <br>                    LPTSTR lpszFileDirectory, <br>                    LPTSTR lpszFileName) <br>   {  // FileCombine <br> <br>   int      stringLen ; <br>   TCHAR    DIRECTORY_DELIMITER[2] ; <br> <br>   DIRECTORY_DELIMITER[0] = TEXT('\\') ; <br>   DIRECTORY_DELIMITER[1] = TEXT('\0') ; <br> <br>   lstrcpy (lpszFileSpec, lpszFileDirectory) ; <br> <br>   stringLen = lstrlen (lpszFileSpec) ; <br>   if (stringLen &gt; 0 &amp;&amp; <br>       lpszFileSpec [stringLen - 1] != DIRECTORY_DELIMITER [0]) <br>      lstrcat (lpszFileSpec, DIRECTORY_DELIMITER) ; <br> <br>   lstrcat (lpszFileSpec, lpszFileName) ; <br> <br>   return (lpszFileSpec) ; <br>   }  // FileCombine <br> <br>// This routine extract the filename portion from a given full-path filename <br>LPTSTR ExtractFileName (LPTSTR pFileSpec) <br>   { <br>   LPTSTR   pFileName = NULL ; <br>   TCHAR    DIRECTORY_DELIMITER1 = TEXT('\\') ; <br>   TCHAR    DIRECTORY_DELIMITER2 = TEXT(':') ; <br> <br>   if (pFileSpec) <br>      { <br>      pFileName = pFileSpec + lstrlen (pFileSpec) ; <br> <br>      while (*pFileName != DIRECTORY_DELIMITER1 &amp;&amp; <br>         *pFileName != DIRECTORY_DELIMITER2) <br>         { <br>         if (pFileName == pFileSpec) <br>            { <br>            // done when no directory delimiter is found <br>            break ; <br>            } <br>         pFileName-- ; <br>         } <br>       <br>      if (*pFileName == DIRECTORY_DELIMITER1 || <br>         *pFileName == DIRECTORY_DELIMITER2) <br>         { <br>         // directory delimiter found, point the  <br>         // filename right after it <br>         pFileName++ ; <br>         } <br>      } <br>   return pFileName ; <br>   }  // ExtractFileName <br> <br>int CBAddInt (HWND hWndCB, <br>              int iValue) <br>   {  // CBAddInt <br>   TCHAR       szValue [ShortTextLen + 1] ; <br>   CHAR        szCharValue [ShortTextLen + 1] ; <br> <br>   itoa (iValue, (LPSTR)szCharValue, 10) ; <br>#ifdef UNICODE <br>   mbstowcs (szValue, (LPSTR)szCharValue, strlen((LPSTR)szCharValue)+1) ; <br>   return (CBAdd (hWndCB, szValue)) ; <br>#else <br>   return (CBAdd (hWndCB, szCharValue)) ; <br>#endif <br> <br>   }  // CBAddInt <br> <br>void DialogSetInterval (HDLG hDlg, <br>                        WORD wControlID, <br>                        int  IntervalMSec) <br>   { <br>   TCHAR          szValue [MiscTextLen] ; <br> <br>   TSPRINTF (szValue, TEXT("%3.3f"), <br>            (FLOAT)(IntervalMSec) / (FLOAT)1000.0) ; <br>   ConvertDecimalPoint (szValue) ; <br>   SetDlgItemText (hDlg, wControlID, szValue) ; <br>   } <br> <br>void DialogSetFloat (HDLG hDlg, <br>                     WORD wControlID, <br>                     FLOAT eValue) <br>   { <br>   TCHAR          szValue [40] ; <br>   FLOAT          tempValue = eValue ; <br> <br>   if (tempValue &lt; (FLOAT) 0.0) <br>      { <br>      tempValue = - tempValue ; <br>      } <br> <br>   if (tempValue &lt; (FLOAT) 1.0E+8) <br>      { <br>      TSPRINTF (szValue, TEXT("%1.4f"), eValue) ; <br>      } <br>   else <br>      { <br>      TSPRINTF (szValue, TEXT("%14.6e"), eValue) ; <br>      } <br>   ConvertDecimalPoint (szValue) ; <br> <br>   SetDlgItemText (hDlg, wControlID, szValue) ; <br>   } <br> <br> <br>FLOAT DialogFloat (HDLG hDlg,  <br>                   WORD wControlID, <br>                   BOOL *pbOK) <br>/* <br>   Effect:        Return a floating point representation of the string <br>                  value found in the control wControlID of hDlg. <br> <br>   Internals:     We use sscanf instead of atof becuase atof returns a  <br>                  double. This may or may not be the right thing to do. <br>*/ <br>   {  // DialogFloat <br>   TCHAR          szValue [ShortTextLen+1] ; <br>   FLOAT          eValue ; <br>   int            iNumScanned ; <br> <br>   DialogText (hDlg, wControlID, szValue) ; <br>   ReconvertDecimalPoint (szValue) ; <br>   iNumScanned = swscanf (szValue, TEXT("%e"), &amp;eValue) ; <br> <br>   if (pbOK) <br>      *pbOK = (iNumScanned == 1) ; <br> <br>   return (eValue) ; <br>   }  // DialogFloat <br> <br> <br> <br>LPTSTR StringAllocate (LPTSTR lpszText1) <br>   {  // StringAllocate <br>   LPTSTR         lpszText2 ; <br> <br>   if (!lpszText1) <br>      return (NULL) ; <br> <br>   if (lstrlen (lpszText1) == 0) <br>      return (NULL) ; <br> <br>   lpszText2 = MemoryAllocate ((lstrlen (lpszText1)+1) * sizeof (TCHAR)) ; <br>   if (lpszText2) <br>      lstrcpy (lpszText2, lpszText1) ; <br> <br>   return  (lpszText2) ; <br>   }  // StringAllocate <br> <br> <br> <br>int DivRound (int iNumerator, int iDenominator) <br>/* <br>   Effect:        Return the quotient (iNumerator / iDenominator). <br>                  Round the quotient to the nearest integer. <br>                  This function is similar to normal integer division (/), <br>                  but normal division always rounds down. <br> <br>   Note:          Surely there must already be a runtime version of this, <br>                  but I couldn't find it.  </code></pre>
<p>
</p>
<pre><code><br>   Note:          This function originally used the runtime div function <br>                  instead of (/ and %), but the div runtime function is <br>                  now broken (build 265).    <br>*/ <br>   {  // DivRound <br>   int            iQuotient ; <br>   int            iRemainder ; <br> <br> <br>   iQuotient = iNumerator / iDenominator ; <br>   iRemainder = iNumerator % iDenominator ; <br> <br>   if (iRemainder &gt;= (iDenominator / 2)) <br>      iQuotient++ ; <br> <br>   return (iQuotient) ; <br>   } <br> <br> <br>BOOL MenuEnableItem (HMENU hMenu, <br>                     WORD wID, <br>                     BOOL bEnable) <br>/* <br>   Effect:        Enable or disable, depending on bEnable, the menu item <br>                  associated with id wID in the menu hMenu. <br> <br>                  Any disabled menu items are displayed grayed out. <br> <br>   See Also:      EnableMenuItem (windows). <br>*/ <br>   {  // MenuEnableItem <br>   return (EnableMenuItem (hMenu, wID, <br>                           bEnable ? <br>                              (MF_ENABLED | MF_BYCOMMAND) : <br>                              (MF_GRAYED | MF_BYCOMMAND))) ; <br>   }  // MenuEnableItem <br> <br>void BitmapDimemsion (HBITMAP hBitmap, int *pHeight, int *pWidth) <br>   {  // BitmapDimemsion <br>   BITMAP  bm ; <br> <br>   GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &amp;bm) ; <br>   if (pHeight) <br>      *pHeight = bm.bmHeight ; <br>   if (pWidth) <br>      *pWidth = bm.bmWidth ; <br>   }  // BitmapDimemsion <br> <br> <br>int WindowHeight (HWND hWnd) <br>   {  // WindowHeight <br>   RECT           rectWindow ; <br> <br>   GetWindowRect (hWnd, &amp;rectWindow) ; <br>   return (rectWindow.bottom - rectWindow.top) ; <br>   }  // WindowHeight <br> <br> <br>#ifdef KEEP_UTIL <br>int WindowWidth (HWND hWnd) <br>   {  // WindowWidth <br>   RECT           rectWindow ; <br> <br>   GetWindowRect (hWnd, &amp;rectWindow) ; <br>   return (rectWindow.right - rectWindow.left) ; <br>   }  // WindowWidth <br> <br> <br>void WindowResize (HWND hWnd, <br>                   int xWidth, <br>                   int yHeight) <br>/* <br>   Effect:        Change the size of the window hWnd, leaving the <br>                  starting position intact.  Redraw the window. <br> <br>                  If either xWidth or yHeight is NULL, keep the <br>                  corresponding dimension unchanged. <br> <br>   Internals:     Since hWnd may be a child of another parent, we need <br>                  to scale the MoveWindow arguments to be in the client <br>                  coordinates of the parent. <br>             <br>*/ <br>   {  // WindowResize <br>   RECT           rectWindow ; <br>   HWND           hWndParent ; <br> <br>   GetWindowRect (hWnd, &amp;rectWindow) ; <br>   hWndParent = WindowParent (hWnd) ; <br> <br>   if (hWndParent) <br>      ScreenRectToClient (hWndParent, &amp;rectWindow) ; <br>    <br>   MoveWindow (hWnd, <br>               rectWindow.left, <br>               rectWindow.top, <br>               xWidth ? xWidth : rectWindow.right - rectWindow.left, <br>               yHeight ? yHeight : rectWindow.bottom - rectWindow.top, <br>               TRUE) ; <br>   }  // WindowResize <br>#endif <br> <br> <br> <br> <br>void WindowSetTopmost (HWND hWnd, BOOL bTopmost) <br>/* <br>   Effect:        Set or clear the "topmost" attribute of hWnd. If a window <br>                  is "topmost", it remains ontop of other windows, even ones <br>                  that have the focus. <br>*/ <br>   { <br>   SetWindowPos (hWnd, bTopmost ? HWND_TOPMOST : HWND_NOTOPMOST, <br>                 0, 0, 0, 0, <br>                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE) ; <br>   } <br> <br> <br>void WindowEnableTitle (HWND hWnd, BOOL bTitle) <br>   { <br>   DWORD          dwStyle ; <br> <br> <br>   dwStyle = WindowStyle (hWnd) ; <br>    <br>   if (bTitle) <br>      dwStyle = WS_TILEDWINDOW | dwStyle ; <br>   else <br>      dwStyle =  <br>         dwStyle &amp;  <br>         ~ (WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX) ; <br> <br>   if (!bTitle) <br>      SetMenu (hWnd, NULL) ; <br> <br>   WindowSetStyle (hWnd, dwStyle) ; <br>   SetWindowPos (hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | <br>                 SWP_NOZORDER | SWP_FRAMECHANGED ); <br>   } <br> <br>// removing the following routines since LINK32 is not doing that for us <br>#ifdef  KEEP_UTIL <br>int MessageBoxResource (HWND hWndParent, <br>                        WORD wTextID, <br>                        WORD wTitleID, <br>                        UINT uiStyle) <br>/* <br>   Effect:        Just like MessageBox, but takes the title and format <br>                  strings from the resoure. In addition, the format string <br>                  is used as a printf style format, combined with the  <br>                  additional arguments. <br>*/ <br>   {  // MessageBoxResource <br>   TCHAR          szText [MessageLen + 1] ; <br>   TCHAR          szCaption [WindowCaptionLen + 1] ; <br> <br>   StringLoad (wTextID, szText) ; <br>   StringLoad (wTitleID, szCaption) ; <br> <br>   return (MessageBox (hWndParent, szText, szCaption, uiStyle)) ; <br>   }  // MessageBoxResource <br> <br> <br>#define WndProcKey   TEXT("OLDWNDPROC") <br> <br>FARPROC WindowSetWndProc (HWND hWnd, <br>                          HANDLE hInstance, <br>                          FARPROC lpfnNewWndProc) <br>/* <br>   Effect:     Replace the window procedure of hWnd with lpfnNewWndProc. <br>               Return the existing window procedure. <br> <br>   Note:       For proper subclassing, NewWndProc should pass all <br>               unhandled messages to the original wndproc. <br> <br>   Called By:  WindowSubclass, WindowUnsubclass. <br>*/ <br>   {  // WindowSetWndProc <br>   FARPROC     lpfnNewProcInstance ; <br>   FARPROC     lpfnOldProc ; <br> <br>   lpfnOldProc = (FARPROC) GetWindowLong (hWnd, GWL_WNDPROC) ; <br>   lpfnNewProcInstance = MakeProcInstance (lpfnNewWndProc, hInstance) ; <br>   SetWindowLong (hWnd, GWL_WNDPROC, (long) lpfnNewProcInstance) ; <br> <br>   return (lpfnOldProc) ; <br>   }  // WindowSetWndProc <br> <br>WNDPROC WindowGetOriginalWndProc (HWND hWnd) <br>/* <br>   Effect:        Return a far pointer to the "original" wndproc for <br>                  hWnd. <br> <br>   Assert:        WindowSetOriginalProc was already called on this hWnd. <br> <br>   See Also:      WindowSetOriginalWndProc. <br>*/ <br>   {  // WindowGetOriginalWndProc <br>   return (WNDPROC) GetProp (hWnd, WndProcKey) ; <br>   }  // WindowGetOriginalWndProc <br> <br> <br>void WindowSetOriginalWndProc (HWND hWnd, <br>                               FARPROC lpfnWndProc) <br>/* <br>   Effect:        Save away a far pointer to the "original" wndproc for <br>                  hWnd. <br> <br>   See Also:      WindowGetOriginalProc. <br>*/ <br>   {  // WindowSetOriginalProc <br>   SetProp (hWnd, WndProcKey, (LPSTR) lpfnWndProc) ; <br>   }  // WindowSetOriginalProc <br> <br> <br>void WindowSubclass (HWND hWnd, <br>                     HANDLE hInstance, <br>                     FARPROC lpfnNewWndProc) <br>/* <br>   Effect:        Replace the wndproc for hWnd with lpfnNewWndProc. <br>                  Save away a pointer to the original procedure. <br> <br>   See Also:      WindowUnsubclass. <br>*/ <br>   {  // WindowSubclass <br>   FARPROC     lpfnOldWndProc ; <br> <br>   lpfnOldWndProc = WindowSetWndProc (hWnd, hInstance, lpfnNewWndProc) ; <br>   WindowSetOriginalWndProc (hWnd, lpfnOldWndProc) ; <br>   }  // WindowSubclass <br> <br> <br>LONG WindowCallOriginalWndProc (HWND hWnd, <br>                                UINT msg, <br>                                WPARAM wParam, <br>                                LPARAM lParam) <br>   { <br>   WNDPROC        lpfnOriginalWndProc ; <br> <br>   lpfnOriginalWndProc = WindowGetOriginalWndProc (hWnd) ; <br>   if (lpfnOriginalWndProc) <br>      return ((LONG) CallWindowProc (lpfnOriginalWndProc, <br>                                     hWnd, msg, wParam, lParam)) ; <br>   else return (FALSE) ; <br>   } <br> <br> <br> <br>LRESULT APIENTRY FocusCtlWndProc (HWND hWnd, <br>                                  UINT wMsg, <br>                                  WPARAM wParam, <br>                                  LPARAM lParam) <br>   {  // FocusCtlWndProc <br>   BOOL           bCallDefProc ; <br>   LRESULT        lReturnValue ; <br> <br> <br>   bCallDefProc = TRUE ; <br>   lReturnValue = 0L ; <br> <br>   switch (wMsg) <br>      {  // switch <br>      case WM_SETFOCUS: <br>         SendMessage (WindowParent (hWnd),  <br>                      WM_DLGSETFOCUS, WindowID (hWnd), 0) ; <br>         break ; <br> <br> <br>      case WM_KILLFOCUS: <br>         SendMessage (WindowParent (hWnd),  <br>                      WM_DLGKILLFOCUS, WindowID (hWnd), 0) ; <br>         break ; <br> <br>      default: <br>         bCallDefProc = TRUE ; <br>      }  // switch <br> <br> <br>   if (bCallDefProc) <br>      lReturnValue = WindowCallOriginalWndProc (hWnd, wMsg, wParam, lParam) ; <br> <br>   return (lReturnValue); <br>   }  // FocusWndProc <br> <br> <br> <br>BOOL DlgFocus (HDLG hDlg, WORD wControlID) <br>   {  // DlgFocus <br>   HWND           hWndControl ; <br> <br>   hWndControl = DialogControl (hDlg, wControlID) ; <br>   if (!hWndControl) <br>      return (FALSE) ; <br> <br>   WindowSubclass (hWndControl, hInstance, (FARPROC) FocusCtlWndProc) ; <br>   return (TRUE) ; <br>   }  // DlgFocus <br> <br> <br>BOOL DeviceNumColors (HDC hDC) <br>   {  // DeviceNumColors <br>   int            nPlanes ; <br>   int            nBitsPixel ; <br> <br>   nPlanes = GetDeviceCaps (hDC, PLANES) ; <br>   nBitsPixel = GetDeviceCaps (hDC, BITSPIXEL) ; <br> <br>   return (1 &lt;&lt; (nPlanes * nBitsPixel)) ; <br>   }  // DeviceNumColors <br> <br> <br>void DrawBitmap (HDC hDC, <br>                 HBITMAP hBitmap, <br>                 int xPos, <br>                 int yPos, <br>                 LONG  lROPCode) <br>   {  // DrawBitmap <br>   BITMAP  bm ; <br>   HDC     hDCMemory ; <br> <br>   hDCMemory = CreateCompatibleDC (hDC) ; <br>   SelectObject (hDCMemory, hBitmap) ; <br> <br>   GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &amp;bm) ; <br> <br>   BitBlt (hDC,                     // DC for Destination surface <br>           xPos, yPos,              // location in destination surface <br>           bm.bmWidth, bm.bmHeight, // dimension of bitmap <br>           hDCMemory,               // DC for Source surface <br>           0, 0,                    // location in source surface <br>           lROPCode) ;              // ROP code <br> <br>   DeleteDC (hDCMemory) ; <br>   }  // DrawBitmap <br> <br> <br>#endif  // KEEP_UTIL <br> <br>#ifdef PERFMON_DEBUG <br> <br>#define MikeBufferSize         256 <br> <br> <br>int _cdecl mike (TCHAR *szFormat, ...) <br>/* <br>   Note:          This function returns a value so that it can more easily <br>                  be used in conditional expressions. <br>*/ <br>   {  // mike <br>   TCHAR          szBuffer [MikeBufferSize] ; <br>   va_list        vaList ; <br> <br>   va_start (vaList, szFormat) ; <br>   TSPRINTF (szBuffer, szFormat, va_arg(vaList, LPTSTR)) ; <br>   va_end (vaList) ; <br> <br>   MessageBox (NULL, szBuffer, TEXT("Debug"), MB_OK | MB_TASKMODAL) ; <br>   return (0) ; <br>   }  // mike <br> <br> <br> <br>int _cdecl mike1 (TCHAR *szFormat, ...) <br>/* <br>   Note:          This function returns a value so that it can more easily <br>                  be used in conditional expressions. <br>*/ <br>   {  //  mike1 <br>   TCHAR           szBuffer [MikeBufferSize] ; <br>   va_list        vaList ; <br>   HDC            hDC ; <br>   RECT           rect ; <br>   <br>   va_start (vaList, szFormat) ; <br>   TSPRINTF (szBuffer, szFormat, va_arg(vaList, LPTSTR)) ; <br>   va_end (vaList) ; <br> <br>   rect.left = 0 ; <br>   rect.right = xScreenWidth ; <br>   rect.top = 0 ; <br>   rect.bottom = 20 ; <br> <br>   hDC = CreateScreenDC () ; <br>   ExtTextOut (hDC, 0, 0, ETO_OPAQUE, &amp;rect,  <br>               szBuffer, lstrlen (szBuffer), NULL) ; <br>   DeleteDC (hDC) ; <br> <br>   return (0) ; <br>   }  // mike1 <br> <br>int _cdecl mike2 (TCHAR *szFormat, ...) <br>/* <br>   Note:          This function returns a value so that it can more easily <br>                  be used in conditional expressions. <br>*/ <br>   {  //  mike2 <br>   TCHAR           szBuffer [MikeBufferSize] ; <br>   va_list        vaList ; <br>   <br>   va_start (vaList, szFormat) ; <br>   TSPRINTF (szBuffer, szFormat, va_arg(vaList, LPTSTR)) ; <br>   va_end (vaList) ; <br> <br>   OutputDebugString (szBuffer) ; <br> <br>   return (0) ; <br>   }  // mike2 <br>#endif      // PERFMON_DEBUG <br> <br> <br>#ifdef KEEP_UTIL <br>int inttok (LPSTR lpszText, LPSTR lpszDelimiters) <br>   {  // inttok <br> <br>   // Inttok only works with LPSTRs because of the atoi &amp; strtok <br>    <br>   LPSTR   lpszToken ; <br> <br>   lpszToken = strtok (lpszText, lpszDelimiters) ; <br> <br>   if (lpszToken) <br>      return (atoi (lpszToken)) ; <br>   else <br>      return (0) ; <br>   }  // inttok <br> <br> <br>void WindowPlacementToString (PWINDOWPLACEMENT pWP,  <br>                              LPTSTR lpszText) <br>   { <br>   TSPRINTF (lpszText, TEXT("%d %d %d %d %d %d %d %d %d"), <br>            pWP-&gt;showCmd,  <br>            pWP-&gt;ptMinPosition.x, <br>            pWP-&gt;ptMinPosition.y, <br>            pWP-&gt;ptMaxPosition.x, <br>            pWP-&gt;ptMaxPosition.y, <br>            pWP-&gt;rcNormalPosition.left, <br>            pWP-&gt;rcNormalPosition.top, <br>            pWP-&gt;rcNormalPosition.right, <br>            pWP-&gt;rcNormalPosition.bottom) ; <br>   } <br> <br> <br>void StringToWindowPlacement (LPTSTR lpszText, <br>                              PWINDOWPLACEMENT pWP) <br>   {  // StringToWindowPlacement <br>   int            iNumScanned ; <br>    <br>   iNumScanned = swscanf (lpszText, TEXT("%d %d %d %d %d %d %d %d %d"), <br>            &amp;pWP-&gt;showCmd,  <br>            &amp;pWP-&gt;ptMinPosition.x, <br>            &amp;pWP-&gt;ptMinPosition.y, <br>            &amp;pWP-&gt;ptMaxPosition.x, <br>            &amp;pWP-&gt;ptMaxPosition.y, <br>            &amp;pWP-&gt;rcNormalPosition.left, <br>            &amp;pWP-&gt;rcNormalPosition.top, <br>            &amp;pWP-&gt;rcNormalPosition.right, <br>            &amp;pWP-&gt;rcNormalPosition.bottom) ; <br>   }  // StringToWindowPlacement <br>#endif  // KEEP_UTIL <br> <br> <br> <br>int LogFontHeight (HDC hDC, <br>                   int iPointSize) <br>/* <br>   Effect:        Return the appropriate pixel height for the lfHeight <br>                  field of the LOGFONT structure for the requested point <br>                  size. This size depends on the number of pixels per <br>                  logical inch of the current display context, hDC. <br> <br>   Called By:     Any function which wants to create a particular <br>                  point-height font. <br>*/ <br>   {  // LogFontHeight <br>   return (-MulDiv (iPointSize, GetDeviceCaps (hDC, LOGPIXELSY), 72)) ; <br>   }  // LogFontHeight <br> <br> <br>// this routine converts the input menu id into help id. <br>DWORD MenuIDToHelpID (DWORD MenuID) <br>   { <br>   DWORD HelpID = 0 ; <br> <br>   if (MenuID &gt;= IDM_FIRSTMENUID &amp;&amp; MenuID &lt;= IDM_LASTMENUID) <br>      { <br>      // only special cases... <br>      if (MenuID &gt;= IDM_OPTIONSREFRESHNOWCHART &amp;&amp; <br>          MenuID &lt;= IDM_OPTIONSREFRESHNOWREPORT) <br>         { <br>         HelpID = HC_PM_MENU_OPTIONSREFRESHNOW ; <br>         } <br>      else <br>         { <br>         HelpID = MenuID - MENUIDTOHELPID ; <br>         } <br>#ifndef ADVANCED_PERFMON <br>      // need to convert these 2 IDs for Perf. Meter <br>      if (HelpID == HC_PM_MENU_HELPABOUT) <br>         { <br>         HelpID = HC_NTPM_MENU_HELPABOUT ; <br>         } <br>      else if (HelpID == HC_PM_MENU_FILEEXIT) <br>         { <br>         HelpID = HC_NTPM_MENU_FILEEXIT ; <br>         } <br>#endif <br>      } <br> <br>   return (HelpID) ; <br>   } <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
