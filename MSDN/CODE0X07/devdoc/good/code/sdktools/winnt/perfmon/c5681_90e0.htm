<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PLAYBACK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5688"></a>PLAYBACK.C</h2>
<pre><code>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include "perfmon.h" <br>#include "playback.h"   // external declarations for this module <br> <br>#include "bookmark.h"   // for BookmarkAppend <br>#include "grafdata.h"   // for ResetGraph <br>#include "perfdata.h"   // for UpdateLinesForSystem <br>#include "perfmops.h"   // for SystemTimeDateString <br>#include "log.h" <br>#include "pmemory.h"    // for MemoryAllocate <br>#include "fileutil.h" <br>#include "utils.h" <br>#include "alert.h"      // for ResetAlert <br>#include "report.h"     // for ResetReport <br> <br>NTSTATUS  AddNamesToArray (LPTSTR pNames, <br>   DWORD    dwLastID, <br>   LPWSTR   *lpCounterId) ; <br> <br> <br>void  PlaybackAddCounterName (PLOGINDEX pIndex) ; <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br> <br>#define PointerSeek(pBase, lFileOffset)         \ <br>   ((PVOID) ((PBYTE) pBase + lFileOffset)) <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>PVOID PlaybackSeek (long lFileOffset) <br>   {  // PlaybackSeek <br>   return (PointerSeek (PlaybackLog.pHeader, lFileOffset)) ; <br>   }  // PlaybackSeek <br> <br> <br>PLOGINDEXBLOCK FirstIndexBlock (PLOGHEADER pLogHeader) <br>   { <br>   return ((PLOGINDEXBLOCK) PointerSeek (pLogHeader, pLogHeader-&gt;iLength)) ; <br>   } <br> <br> <br>PLOGINDEX IndexFromPosition (PLOGPOSITION pLogPosition) <br>   { <br>   return (&amp;pLogPosition-&gt;pIndexBlock-&gt;aIndexes [pLogPosition-&gt;iIndex]) ; <br>   } <br> <br> <br>PPERFDATA DataFromIndex (PLOGINDEX pLogIndex, <br>                         LPTSTR lpszSystemName) <br>   { <br>   PPERFDATA pPerfData; <br>   TCHAR     szLoggedComputerName[MAX_COMPUTERNAME_LENGTH + 3] ; <br>   int       iNumSystem ; <br> <br>   // Note: NULL lpszSystemName means return first logged system name <br>   //       at the specified index. <br> <br>   pPerfData = PlaybackSeek (pLogIndex-&gt;lDataOffset) ; <br> <br>   for (iNumSystem = 0; <br>        iNumSystem &lt; pLogIndex-&gt;iSystemsLogged; <br>        iNumSystem++) <br>      { <br>      if ( pPerfData &amp;&amp; <br>           pPerfData-&gt;Signature[0] == (WCHAR)'P' &amp;&amp; <br>           pPerfData-&gt;Signature[1] == (WCHAR)'E' &amp;&amp; <br>           pPerfData-&gt;Signature[2] == (WCHAR)'R' &amp;&amp; <br>           pPerfData-&gt;Signature[3] == (WCHAR)'F' ) <br>          { <br>          GetPerfComputerName(pPerfData, szLoggedComputerName) ; <br>          if (!lpszSystemName || strsamei(lpszSystemName, szLoggedComputerName)) <br>              { <br>              return pPerfData ; <br>              } <br>          pPerfData = (PPERFDATA)((PBYTE) pPerfData + <br>                                  pPerfData-&gt;TotalByteLength) ; <br>          } <br>      else <br>          {  <br>          break ; <br>          } <br>       } <br>   return NULL ; <br>   } <br> <br> <br>PPERFDATA DataFromIndexPosition (PLOGPOSITION pLogPosition, <br>                                 LPTSTR lpszSystemName) <br>   { <br>   PLOGINDEX      pLogIndex ; <br>//   long           lDataFileOffset ; <br> <br>   pLogIndex = IndexFromPosition (pLogPosition) ; <br>   return (DataFromIndex (pLogIndex, lpszSystemName)) ; <br>   } <br> <br> <br>BOOL NextLogPosition (IN OUT PLOGPOSITION pLogPosition) <br>   { <br>   PLOGINDEXBLOCK pIndexBlock ; <br> <br>   if (pLogPosition-&gt;pIndexBlock-&gt;iNumIndexes == 0) <br>      { <br>      // no data in this index block.  This is most likely <br>      // a corrupted log file caused by system failure... <br>      return (FALSE) ; <br>      } <br> <br>   if (pLogPosition-&gt;iIndex == pLogPosition-&gt;pIndexBlock-&gt;iNumIndexes - 1) <br>      { <br>      if (pLogPosition-&gt;pIndexBlock-&gt;lNextBlockOffset) <br>         { <br>         pIndexBlock =  <br>            PlaybackSeek (pLogPosition-&gt;pIndexBlock-&gt;lNextBlockOffset) ; <br> <br>         if (pIndexBlock-&gt;iNumIndexes == 0) <br>            { <br>            // no data in the next index block.  This is most likely <br>            // a corrupted log file caused by system failure... <br>            return (FALSE) ; <br>            } <br>         else <br>            { <br>            pLogPosition-&gt;pIndexBlock = pIndexBlock ; <br>            pLogPosition-&gt;iIndex = 0 ; <br>            return (TRUE) ; <br>            } <br>         } <br>      else <br>         return (FALSE) ;    <br>      } <br>   else <br>      { <br>      pLogPosition-&gt;iIndex++ ; <br>      return (TRUE) ; <br>      }  <br>   } <br> <br> <br>BOOL NextIndexPosition (IN OUT PLOGPOSITION pLogPosition, <br>                        BOOL bCheckForNonDataIndexes) <br>/* <br>   Effect:        Set pLogPosition to the next log position from  <br>                  the current position of pLogPosition if there is one. <br> <br>   Returns:       Whether there was a next log position. <br>*/ <br>   {  // NextIndexPosition <br>   LOGPOSITION    LP ; <br>   PLOGINDEX      pIndex ; <br>   PBOOKMARK      pBookmarkDisk, pBookmark ; <br>//   LONG           lFilePosition ; <br> <br>   pIndex = IndexFromPosition (pLogPosition) ; <br>    <br>   LP = *pLogPosition ; <br>   pBookmark = NULL ; <br> <br>   while (TRUE) <br>      {  // while <br>      if (!NextLogPosition (&amp;LP)) <br>         return (FALSE) ; <br>      pIndex = IndexFromPosition (&amp;LP) ; <br> <br>      if (pIndex &amp;&amp; bCheckForNonDataIndexes &amp;&amp; IsCounterNameIndex (pIndex)) <br>         { <br>         PlaybackAddCounterName (pIndex) ; <br>         } <br> <br>      if (pIndex &amp;&amp; bCheckForNonDataIndexes &amp;&amp; IsBookmarkIndex (pIndex)) <br>         { <br>         if (pBookmark) <br>            { <br>            // this is the case when several bookmarks are <br>            // found before any data index... <br>            pBookmark-&gt;iTic = PlaybackLog.iTotalTics ; <br>            BookmarkAppend (&amp;PlaybackLog.pBookmarkFirst, pBookmark) ; <br>            } <br> <br>         pBookmarkDisk = PlaybackSeek (pIndex-&gt;lDataOffset) ; <br>         pBookmark = MemoryAllocate (sizeof (BOOKMARK)) ; <br>         *pBookmark = *pBookmarkDisk; <br>         pBookmark-&gt;pBookmarkNext = NULL ; <br>         } <br> <br>      if (pIndex &amp;&amp; IsDataIndex (pIndex)) <br>         { <br>         LP.iPosition++ ; <br>         *pLogPosition = LP ; <br>         if (pBookmark) <br>            { <br>            pBookmark-&gt;iTic = PlaybackLog.iTotalTics ; <br>            BookmarkAppend (&amp;PlaybackLog.pBookmarkFirst, pBookmark) ; <br>            } <br>         return (TRUE) ; <br>         } <br>      }  // while <br>   }  // NextIndexPosition <br> <br> <br>BOOL NextReLogIndexPosition (IN OUT PLOGPOSITION pLogPosition) <br>/* <br>   Effect:        Set pLogPosition to the next log position from  <br>                  the current position of pLogPosition if there is one. <br>                  Will return bookmarks, counternames, or data. <br> <br>   Returns:       Whether there was a next relog position. <br>*/ <br>   {  // NextReLogIndexPosition <br>   LOGPOSITION    LP ; <br>   PLOGINDEX      pIndex ; <br>//   LONG           lFilePosition ; <br> <br>   pIndex = IndexFromPosition (pLogPosition) ; <br>    <br>   LP = *pLogPosition ; <br> <br>   if (!NextLogPosition (&amp;LP)) <br>      return (FALSE) ; <br>   pIndex = IndexFromPosition (&amp;LP) ; <br> <br>   if (pIndex &amp;&amp; IsDataIndex (pIndex)) <br>      { <br>      LP.iPosition++ ; <br>      } <br>   *pLogPosition = LP ; <br>   return (TRUE) ; <br>   }  // NextReLogIndexPosition <br> <br> <br> <br> <br>    <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>void PlaybackInitializeInstance (void) <br>   {  // PlaybackInitializeInstance <br>   PlaybackLog.iStatus = iPMStatusClosed ; <br>   PlaybackLog.hFile = NULL ; <br> <br>   PlaybackLog.szFilePath  = MemoryAllocate (FilePathLen * sizeof (TCHAR)) ; <br>   PlaybackLog.szFileTitle = MemoryAllocate (FilePathLen * sizeof (TCHAR)) ; <br>   lstrcpy (PlaybackLog.szFilePath,  szDefaultLogFileName) ; <br>   lstrcpy (PlaybackLog.szFileTitle, szDefaultLogFileName) ; <br>   }  // PlaybackInitializeInstance <br> <br> <br>INT OpenPlayback (LPTSTR lpszFilePath, LPTSTR lpszFileTitle) <br>   {  // OpenPlayback <br>   BOOL     bFirstTime = TRUE ; <br> <br>   lstrcpy  (PlaybackLog.szFilePath, lpszFilePath) ; <br>   lstrcpy  (PlaybackLog.szFileTitle, lpszFileTitle) ; <br>   PlaybackLog.hFile = FileHandleReadOnly (lpszFilePath) ; <br>   if (!PlaybackLog.hFile || PlaybackLog.hFile == INVALID_HANDLE_VALUE) <br>      { <br>      return (ERR_CANT_OPEN) ; <br>      } <br> <br>   PlaybackLog.pHeader = (PLOGHEADER) FileMap (PlaybackLog.hFile, <br>      &amp;PlaybackLog.hMapHandle) ; <br>    <br>   if (!PlaybackLog.pHeader) <br>      { <br>      if (PlaybackLog.hMapHandle) <br>         { <br>         CloseHandle (PlaybackLog.hMapHandle) ; <br>         } <br> <br>      CloseHandle (PlaybackLog.hFile) ; <br>      return (ERR_CANT_OPEN) ; <br>      } <br> <br>   if (!strsame (PlaybackLog.pHeader-&gt;szSignature, LogFileSignature)) <br>      { <br>      FileUnMap((LPVOID)PlaybackLog.pHeader, PlaybackLog.hMapHandle) ; <br>      CloseHandle (PlaybackLog.hFile) ; <br>      return (ERR_BAD_LOG_FILE) ; <br>      } <br> <br>   PlaybackLog.BeginIndexPos.pIndexBlock = FirstIndexBlock (PlaybackLog.pHeader) ; <br>   PlaybackLog.BeginIndexPos.iIndex = 0 ; <br>   PlaybackLog.BeginIndexPos.iPosition = 0 ; <br>   PlaybackLog.pBookmarkFirst = NULL ; <br> <br>   PlaybackLog.iTotalTics = 1 ; <br>   PlaybackLog.EndIndexPos = PlaybackLog.BeginIndexPos ; <br>   while (NextIndexPosition (&amp;PlaybackLog.EndIndexPos, TRUE)) <br>      { <br>      if (bFirstTime) <br>         { <br>         // set the begin index to the first data index <br>         bFirstTime = FALSE ; <br>         PlaybackLog.BeginIndexPos.iIndex = <br>            PlaybackLog.EndIndexPos.iIndex ; <br>         } <br>      else <br>         { <br>         PlaybackLog.iTotalTics++ ; <br>         } <br>      } <br> <br>   if (PlaybackLog.iTotalTics == 1 ) <br>      { <br>      // no data inside the log file.  It must be a corrupted <br>      // log file <br>      FileUnMap((LPVOID)PlaybackLog.pHeader, PlaybackLog.hMapHandle) ; <br>      CloseHandle (PlaybackLog.hFile) ; <br>      return (ERR_CORRUPT_LOG) ; <br>      } <br> <br>//   PlaybackLog.StartIndexPos = PlaybackLog.BeginIndexPos ; <br> <br>   // getthe first data index <br>   if (!LogPositionN (1, &amp;(PlaybackLog.StartIndexPos))) <br>      { <br>      PlaybackLog.StartIndexPos = PlaybackLog.BeginIndexPos ; <br>      } <br> <br>   PlaybackLog.StopIndexPos = PlaybackLog.EndIndexPos ; <br>   PlaybackLog.StopIndexPos.iPosition = <br>      min (PlaybackLog.StopIndexPos.iPosition, <br>           PlaybackLog.iTotalTics - 1 ) ; <br> <br> <br>   PlaybackLog.iSelectedTics = PlaybackLog.iTotalTics ; <br> <br>   PlaybackLog.iStatus = iPMStatusPlaying ; <br>   return (0) ;    <br>   }  // OpenPlayback <br> <br> <br>void CloseInputLog (HWND hWndParent) <br>   {  // CloseInputLog <br>   PBOOKMARK      pBookmark, pNextBookmark ; <br>   BOOL           retCode, retCode1 ; <br>   PLOGCOUNTERNAME pLogCounterName, pNextCounterName ; <br> <br>   UNREFERENCED_PARAMETER (hWndParent) ; <br> <br>   // free the bookmark list <br>   for (pBookmark = PlaybackLog.pBookmarkFirst ; <br>      pBookmark ; <br>      pBookmark = pNextBookmark ) <br>      { <br>      // save next bookmark and free current bookmark <br>      pNextBookmark = pBookmark-&gt;pBookmarkNext ; <br>      MemoryFree (pBookmark) ; <br>      } <br>   PlaybackLog.pBookmarkFirst = NULL ; <br> <br>   // free all counter names stuff <br>   if (PlaybackLog.pBaseCounterNames) <br>      { <br>      MemoryFree (PlaybackLog.pBaseCounterNames) ; <br>      } <br>   PlaybackLog.pBaseCounterNames = NULL ; <br>   PlaybackLog.lBaseCounterNameSize = 0 ; <br>   PlaybackLog.lBaseCounterNameOffset = 0 ; <br> <br>   for (pLogCounterName = PlaybackLog.pLogCounterNameFirst ; <br>      pLogCounterName ; <br>      pLogCounterName = pNextCounterName) <br>      { <br>      pNextCounterName = pLogCounterName-&gt;pCounterNameNext ; <br>      MemoryFree (pLogCounterName-&gt;pRemainNames) ; <br>      MemoryFree (pLogCounterName) ; <br>      } <br> <br>   PlaybackLog.pLogCounterNameFirst = NULL ; <br> <br>   retCode1 = FileUnMap((LPVOID)PlaybackLog.pHeader, PlaybackLog.hMapHandle) ; <br>   retCode = CloseHandle (PlaybackLog.hFile) ; <br>   PlaybackLog.iStatus = iPMStatusClosed ; <br> <br>   ResetGraphView (hWndGraph) ; <br>   ResetAlertView (hWndAlert) ; <br>   ResetLogView (hWndLog) ; <br>   ResetReportView (hWndReport) ; <br>   } <br> <br> <br> <br>BOOL LogPositionN (int iIndex, PLOGPOSITION pLP) <br>   {  // LogPositionN <br>   LOGPOSITION    LP ; <br>   int            i ; <br> <br>   LP = PlaybackLog.BeginIndexPos ; <br>   for (i = 0 ; <br>        i &lt; iIndex ; <br>        i++) <br>      { <br>      if (!NextIndexPosition (&amp;LP, FALSE)) <br>         return (FALSE) ; <br>      } <br> <br>   *pLP = LP ; <br>   return (TRUE) ; <br>   }  // LogPositionN <br> <br> <br>PLOGINDEX PlaybackIndexN (int iIndex) <br>   { <br>   LOGPOSITION    LP ; <br>   int            i ; <br> <br>   LP = PlaybackLog.BeginIndexPos ; <br>   for (i = 0 ; <br>        i &lt; iIndex ; <br>        i++) <br>      { <br>      if (!NextIndexPosition (&amp;LP, FALSE)) <br>         return (NULL) ; <br>      } <br> <br>   return (IndexFromPosition (&amp;LP)) ; <br>   } <br> <br> <br>BOOL PlaybackLines (PPERFSYSTEM pSystemFirst, <br>                    PLINE pLineFirst, <br>                    int iLogTic) <br>   {  // PlaybackLines <br> <br>   PLOGINDEX      pLogIndex ; <br>   PPERFDATA      pPerfData ; <br>   PPERFSYSTEM       pSystem ; <br>   BOOL           bAnyFound ; <br> <br>   pLogIndex = PlaybackIndexN (iLogTic) ; <br>   if (!pLogIndex) <br>      return (FALSE) ; <br> <br>   bAnyFound = FALSE ; <br>   for (pSystem = pSystemFirst ; <br>        pSystem ; <br>        pSystem = pSystem-&gt;pSystemNext) <br>      {  // for <br>      pPerfData = DataFromIndex (pLogIndex, pSystem-&gt;sysName) ; <br>      if (pPerfData) <br>         { <br>         UpdateLinesForSystem (pSystem-&gt;sysName, <br>                               pPerfData, <br>                               pLineFirst, <br>                               NULL) ; <br>         bAnyFound = TRUE ; <br>         } <br>      else <br>         { <br>         FailedLinesForSystem (pSystem-&gt;sysName, <br>                               pPerfData, <br>                               pLineFirst) ; <br>         } <br>      } <br>   return (bAnyFound) ; <br>   }  // PlaybackLines <br> <br> <br> <br> <br>PPERFDATA LogDataFromPosition (PPERFSYSTEM pSystem,  <br>                               PLOGPOSITION pLogPosition) <br>   {  // LogDataFromPosition <br>   PLOGINDEX      pLogIndex ; <br>    <br> <br>   if (!pLogPosition) <br>      return (NULL) ; <br> <br>   pLogIndex = IndexFromPosition (pLogPosition) ; <br>   if (!pLogIndex) <br>      return (NULL) ; <br>    <br>   return (DataFromIndex (pLogIndex, pSystem-&gt;sysName)) ; <br>   }  // LogDataFromPosition <br> <br> <br> <br>BOOL LogPositionSystemTime (PLOGPOSITION pLP, SYSTEMTIME *pSystemTime) <br>/* <br>   Effect:        Given a logposition, get the index entry for that position <br>                  and return the system time stored therein. <br>*/ <br>   {  // LogPositionSystemTime <br>   PLOGINDEX      pLogIndex ; <br> <br>   pLogIndex = IndexFromPosition (pLP) ; <br>   if (!pLogIndex) <br>      return (FALSE) ; <br> <br>   *pSystemTime = pLogIndex-&gt;SystemTime ; <br>   }  // LogPositionSystemTime <br> <br> <br>int LogPositionIntervalSeconds (PLOGPOSITION pLPStart,  <br>                                PLOGPOSITION pLPStop) <br>/* <br>   Effect:        Return the time difference (in seconds) between the <br>                  system times of the two specified log positions. <br>*/ <br>   {  // LogPositionIntervalSeconds <br>   SYSTEMTIME     SystemTimeStart ; <br>   SYSTEMTIME     SystemTimeStop ; <br> <br> <br>   if (LogPositionSystemTime (pLPStart, &amp;SystemTimeStart) &amp;&amp; <br>       LogPositionSystemTime (pLPStop, &amp;SystemTimeStop)) <br>      return (SystemTimeDifference (&amp;SystemTimeStart, &amp;SystemTimeStop)) ; <br>   else <br>      return (0) ; <br>   }  // LogPositionIntervalSeconds <br> <br> <br> <br>int PlaybackSelectedSeconds (void) <br>   {  // PlaybackSelectedSeconds <br>   return (LogPositionIntervalSeconds (&amp;PlaybackLog.StartIndexPos,  <br>                                       &amp;PlaybackLog.StopIndexPos)) ; <br>   }  // PlaybackSelectedSeconds <br> <br>void BuildLogComputerList (HWND hDlg, int DlgID) <br>   { <br>   PPERFDATA pPerfData; <br>   int       iNumSystem ; <br>   HWND      hListBox = GetDlgItem (hDlg, DlgID) ; <br>   PLOGINDEX pLogIndex ; <br>   TCHAR     szLoggedComputerName[MAX_COMPUTERNAME_LENGTH + 3] ; <br>   int       Index ; <br> <br>   pLogIndex = IndexFromPosition (&amp;(PlaybackLog.StartIndexPos)) ; <br>   pPerfData = PlaybackSeek (pLogIndex-&gt;lDataOffset) ; <br> <br>   for (iNumSystem = 0; <br>        iNumSystem &lt; pLogIndex-&gt;iSystemsLogged; <br>        iNumSystem++) <br>      { <br>      if ( pPerfData &amp;&amp; <br>           pPerfData-&gt;Signature[0] == (WCHAR)'P' &amp;&amp; <br>           pPerfData-&gt;Signature[1] == (WCHAR)'E' &amp;&amp; <br>           pPerfData-&gt;Signature[2] == (WCHAR)'R' &amp;&amp; <br>           pPerfData-&gt;Signature[3] == (WCHAR)'F' ) <br>          { <br>          GetPerfComputerName(pPerfData, szLoggedComputerName) ; <br>          Index = LBFind (hListBox, szLoggedComputerName) ; <br>          if (Index != LB_ERR)  <br>             { <br>             // computer name already exist, we must have reach the next <br>             // block of perfdata <br>             break ; <br>             } <br>          LBAdd (hListBox, szLoggedComputerName) ; <br>          pPerfData = (PPERFDATA)((PBYTE) pPerfData + <br>                                  pPerfData-&gt;TotalByteLength) ; <br>          } <br>       else  <br>          { <br>          break; <br>          } <br>       } <br>   }  // BuildLogComputerList <br> <br>void  PlaybackAddCounterName (PLOGINDEX pIndex) <br>{ <br>   PLOGCOUNTERNAME      pLogCounterName, pListCounterName ; <br>   PLOGFILECOUNTERNAME  pDiskCounterName ; <br>   PVOID                pCounterData ; <br>   BOOL                 bExist = FALSE ; <br> <br>   pDiskCounterName = PlaybackSeek (pIndex-&gt;lDataOffset) ; <br> <br>   // check we have a record for this system <br>   for (pListCounterName = PlaybackLog.pLogCounterNameFirst ; <br>        pListCounterName ; <br>        pListCounterName = pListCounterName-&gt;pCounterNameNext) <br>      { <br>      if (strsamei(pDiskCounterName-&gt;szComputer, <br>         pListCounterName-&gt;CounterName.szComputer)) <br>         { <br>         // found! <br>         pLogCounterName = pListCounterName ; <br>         bExist = TRUE ; <br>         break ; <br>         } <br>      } <br> <br>   if (!bExist) <br>      { <br>      // new counter name record <br>      if (!(pLogCounterName = MemoryAllocate (sizeof(LOGCOUNTERNAME)))) <br>         { <br>         return ; <br>         } <br>      } <br>   else <br>      { <br>      // free old memory in previous counter name record. <br>      if (pLogCounterName-&gt;pRemainNames) <br>         { <br>         MemoryFree (pLogCounterName-&gt;pRemainNames) ; <br>         } <br>      pLogCounterName-&gt;pRemainNames = NULL ; <br>      } <br> <br>   pLogCounterName-&gt;CounterName = *pDiskCounterName ; <br> <br>   if (pDiskCounterName-&gt;lBaseCounterNameOffset == 0) <br>      { <br>      // this is the base counter names,  <br>      // get the master copy of the counter names <br> <br>      if (!(pCounterData = <br>            MemoryAllocate (pDiskCounterName-&gt;lUnmatchCounterNames))) <br>         { <br>         MemoryFree (pLogCounterName) ; <br>         return ; <br>         } <br> <br>      // free the old one if it exists. <br>      if (PlaybackLog.pBaseCounterNames) <br>         { <br>         MemoryFree (PlaybackLog.pBaseCounterNames) ; <br>         } <br>    <br>      PlaybackLog.pBaseCounterNames = pCounterData ; <br> <br>      pCounterData = <br>         PlaybackSeek (pDiskCounterName-&gt;lCurrentCounterNameOffset) ; <br> <br>      memcpy (PlaybackLog.pBaseCounterNames, <br>         pCounterData, <br>         pDiskCounterName-&gt;lUnmatchCounterNames) ; <br> <br>      PlaybackLog.lBaseCounterNameSize = <br>         pDiskCounterName-&gt;lUnmatchCounterNames ; <br> <br>      PlaybackLog.lBaseCounterNameOffset = <br>         pDiskCounterName-&gt;lBaseCounterNameOffset ; <br>      } <br>   else if (pDiskCounterName-&gt;lUnmatchCounterNames) <br>      { <br>      // this is not a based system and it has extra counter names <br>      // allocate a buffer to hold them <br>      pLogCounterName-&gt;pRemainNames = <br>         MemoryAllocate (pDiskCounterName-&gt;lUnmatchCounterNames) ; <br> <br>      if (pLogCounterName-&gt;pRemainNames) <br>         { <br>         pCounterData = <br>            PlaybackSeek (pDiskCounterName-&gt;lCurrentCounterNameOffset) ; <br> <br>         memcpy(pLogCounterName-&gt;pRemainNames, <br>            pCounterData, <br>            pDiskCounterName-&gt;lUnmatchCounterNames) ; <br>         } <br>      } <br> <br>   if (!bExist) <br>      { <br>      // now add the new counter name record to the linked list <br>      if (!PlaybackLog.pLogCounterNameFirst) <br>         { <br>         PlaybackLog.pLogCounterNameFirst = pLogCounterName ; <br>         } <br>      else <br>         { <br>         for (pListCounterName = PlaybackLog.pLogCounterNameFirst ; <br>            pListCounterName-&gt;pCounterNameNext ; <br>            pListCounterName = pListCounterName-&gt;pCounterNameNext) <br>            { <br>            // do nothing until we get to the end of the list <br>            ; <br>            } <br>         pListCounterName-&gt;pCounterNameNext = pLogCounterName ; <br>         } <br>      } <br> <br>}  // PlaybackAddCounterName <br> <br> <br>LPWSTR *LogBuildNameTable (PPERFSYSTEM pSysInfo) <br>{ <br> <br>   DWORD             dwArraySize ; <br>   PLOGCOUNTERNAME   pCounterName ; <br>   LPWSTR            *lpCounterId = NULL ; <br>   LPWSTR            lpCounterNames ; <br>   NTSTATUS          Status ; <br> <br>   for (pCounterName = PlaybackLog.pLogCounterNameFirst ; <br>        pCounterName ; <br>        pCounterName = pCounterName-&gt;pCounterNameNext) <br>      { <br>      if (strsamei (pSysInfo-&gt;sysName, pCounterName-&gt;CounterName.szComputer)) <br>         { <br>         // found the right system <br>         break ; <br>         } <br>      } <br>   if (!pCounterName) <br>      { <br>      goto ERROR_EXIT ; <br>      } <br> <br>   dwArraySize = (pCounterName-&gt;CounterName.dwLastCounterId + 1) <br>      * sizeof (LPWSTR) ; <br> <br>   lpCounterId = MemoryAllocate (dwArraySize + <br>      pCounterName-&gt;CounterName.lMatchLength + <br>      pCounterName-&gt;CounterName.lUnmatchCounterNames ) ; <br> <br>   if (!lpCounterId) <br>      { <br>      goto ERROR_EXIT ; <br>      } <br> <br>   // initialize pointers into buffer <br> <br>   lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize); <br>   if (pCounterName-&gt;CounterName.lBaseCounterNameOffset == 0) <br>      { <br>      // this is the base system <br>      memcpy(lpCounterNames, <br>         PlaybackLog.pBaseCounterNames, <br>         PlaybackLog.lBaseCounterNameSize) ; <br>      } <br>   else <br>      { <br>      // copy the matched portion from the base system <br>      memcpy(lpCounterNames, <br>         PlaybackLog.pBaseCounterNames, <br>         pCounterName-&gt;CounterName.lMatchLength) ; <br> <br>      // copy the unmatched portion <br>      if (pCounterName-&gt;CounterName.lUnmatchCounterNames) <br>         { <br>         memcpy(((PBYTE)lpCounterNames + <br>            pCounterName-&gt;CounterName.lMatchLength), <br>            pCounterName-&gt;pRemainNames, <br>            pCounterName-&gt;CounterName.lUnmatchCounterNames) ; <br>         } <br>      } <br> <br>   Status = AddNamesToArray (lpCounterNames, <br>      pCounterName-&gt;CounterName.dwLastCounterId, <br>      lpCounterId) ; <br> <br>   if (Status != ERROR_SUCCESS) <br>      { <br>      goto ERROR_EXIT ; <br>      } <br> <br>   pSysInfo-&gt;CounterInfo.dwLastId = <br>      pCounterName-&gt;CounterName.dwLastCounterId ; <br>   pSysInfo-&gt;CounterInfo.dwLangId = <br>      pCounterName-&gt;CounterName.dwLangId ; <br>   pSysInfo-&gt;CounterInfo.dwHelpSize = 0 ; <br>   pSysInfo-&gt;CounterInfo.dwCounterSize = <br>      pCounterName-&gt;CounterName.lMatchLength + <br>      pCounterName-&gt;CounterName.lUnmatchCounterNames ; <br>    <br>   return (lpCounterId) ; <br> <br>ERROR_EXIT: <br>   if (lpCounterId) <br>      { <br>      MemoryFree (lpCounterId) ; <br>      } <br>   return (NULL) ; <br>} // LogBuildNameTable <br> <br>     </code></pre>
<p>&nbsp;</p></body>
</HTML>
