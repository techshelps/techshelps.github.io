<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INTRLINE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5667"></a>INTRLINE.C</h2>
<pre><code>/* <br>============================================================================== <br> <br>  Application: <br> <br>            Microsoft Windows NT (TM) Performance Monitor <br> <br>  File: <br>            intrline.c -- IntervalLine custom control. <br> <br>  Copyright 1992 - 1998 Microsoft Corporation. All Rights Reserved. <br>============================================================================== <br>*/ <br> <br> <br>/* <br> <br> <br>Basic Information <br>----------------- <br>    <br>An ILine (Interval Line) control is a horizontally-sliding device; the user  <br>can slide the start position and end position independently by dragging  <br>either "grab" bar, or move them simultaneously by dragging the center grab <br>bar. An ILine control is used in the Input Log dialog of Perfmon, but could <br>be used anywhere. The control allows the user to specify the start, end and  <br>duration of playback within the range of previously-logged data. <br> <br> <br>ILine Parts <br>----------- <br> <br>     iBeginValue                                            iEndValue <br>     |      iStartValue                        iStopValue           | <br>     |      |                                           |           | <br>     v      v                                           v           v <br>     +------+-+---------------------------------------+-+-----------+ <br>     |      |X|                                       |X|           | <br>     |      |X|                                       |X|           | <br>     +------+-+---------------------------------------+-+-----------+ <br>             ^                    ^                    ^ <br>             Start grab bar       Center grab bar      Stop grab bar <br> <br> <br>ILine Terminology <br>----------------- <br> <br>All external routines are designated by the prefix ILine-. <br>Internal routines are designated by the prefix IL-. <br> <br>The suffix -Value represents an integer in the user-supplied domain. <br>The suffix -Pixel represents an integer location on the screen. <br> <br>Note that the range of the IntervalLine is represented by "Begin" and  <br>"End", while the the currently selected interval is represented by <br>"Start" and "Stop". <br> <br> <br>Implementation Notes <br>-------------------- <br> <br>ILine is a custom control, but does not have all the messages  <br>normally associated with a full-fledged control type like "button".  <br>In particular, it doesn't have a keyboard interface or ask it's parent <br>for color choices. It also doesn't have the functions needed for interfacing <br>with the dialog editor custom control menu. <br> <br>An ILine control is designed to work with an integer range of values <br>specified by the user of the control. These values should have meaning to <br>the caller. The caller can specify the minimum value of the range  <br>(iBeginValue), the maximum value of the range (iEndValue), and the current <br>starting and stopping values (iStartValue and iStopValue).  <br> <br>These values are set with a function-based interface. (ILSetXXX). <br> <br>The code distinguishes between the *values* for the begin, end, start, and <br>stop, and the *pixels* which represent locations on the control for these <br>values. <br> <br>Various bits of the control style allow for changing the control's  <br>behavior. <br> <br>To allow for multiple ILine controls, all data used by each ILine <br>instance is allocated from the heap and associated with the control. <br>The allocation is done in OnCreate and the freeing in OnDestroy. The <br>instance data is contained in the ILINE structure. Each message handler <br>retrieves this instance data with the ILData function. <br> <br>*/       <br> <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include "perfmon.h" <br>#include "utils.h" <br>#include "intrline.h" <br>#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines <br> <br>BOOL  IntrLineFocus ; <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define dwILineClassStyle     (CS_HREDRAW | CS_VREDRAW) <br>#define iILineClassExtra      (0) <br>#define iILineWindowExtra     (sizeof (PILINE)) <br>#define dwILineWindowStyle    (WS_CHILD | WS_VISIBLE)  <br> <br> <br>#define ILModeNone            0 <br>#define ILModeLeft            1 <br>#define ILModeCenter          2 <br>#define ILModeRight           3 <br> <br>#define TO_THE_END            0x7FFFFFFFL <br> <br>//==========================================================================// <br>//                                  Typedefs                                // <br>//==========================================================================// <br> <br> <br>// The instance data for each IL window.  One of these is allocated for each <br>// window in the window's OnCreate processing and free'd in OnDestroy. <br>typedef struct ILINESTRUCT <br>   {  // ILINE <br>   int            iBeginValue ;        // user-supplied lowest range <br>   int            iEndValue ;          // user-supplied highest range <br>   int            iStartValue ;        // current start of selected interval <br>   int            iStopValue ;         // current end of selected interval <br>   int            iGranularityValue ; <br>   int            iMinimumRangeValue ; <br> <br>   RECT           rectBorder ; <br>   RECT           rectLeftBk ; <br>   RECT           rectLeftGrab ; <br>   RECT           rectCenterGrab ; <br>   RECT           rectRightGrab ; <br>   RECT           rectRightBk ; <br> <br>   HBRUSH         hBrushBk ; <br> <br>   POINTS         ptsMouse ; <br>   int            iMode ;              // who is being tracked? <br>   } ILINE ; <br> <br>typedef ILINE *PILINE ; <br> <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>// Width of the start and stob grab bars <br>#define ILGrabWidth()      \ <br>   (xScrollThumbWidth) <br> <br> <br>// A rectangle is "drawable" if it has both nonzero width and height <br>#define RectDrawable(lpRect)           \ <br>   ((lpRect-&gt;right - lpRect-&gt;left) &amp;&amp;  \ <br>    (lpRect-&gt;bottom - lpRect-&gt;top)) <br> <br> <br>//======================================// <br>// ILine Accessor Macros                // <br>//======================================// <br> <br>// These macros reference fields in the ILine structure and should be <br>// used in place of direct reference to the fields. This makes the code <br>// easier to read and allows modification of the underlying structure. <br> <br>// You can use these macros to both get and set the fields. <br> <br>#define ILBegin(pILine)    \ <br>   (pILine-&gt;iBeginValue) <br> <br>#define ILEnd(pILine)      \ <br>   (pILine-&gt;iEndValue) <br> <br>#define ILStart(pILine)    \ <br>   (pILine-&gt;iStartValue) <br> <br>#define ILStop(pILine)     \ <br>   (pILine-&gt;iStopValue) <br> <br>#define ILMode(pILine)     \ <br>   (pILine-&gt;iMode) <br> <br> <br>//======================================// <br>// ILine Pseudo-Accessor Macros         // <br>//======================================// <br> <br>// These macros are used to get values which don't correspond to a single <br>// field. You can get the value with these macros but can't set it. <br> <br>#define ILWidth(pILine)    \ <br>   (pILine-&gt;rectBorder.right) <br> <br>#define ILRange(pILine)    \ <br>   (ILEnd (pILine) - ILBegin (pILine)) <br> <br>#define ILStartPixel(pILine) \ <br>   (pILine-&gt;rectLeftGrab.left) <br> <br>#define ILStopPixel(pILine)   \ <br>   (pILine-&gt;rectRightGrab.right) <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>void static ILNotifyChange (HWND hWnd, <br>                            PILINE pILine) <br>   {  // ILNotifyChange <br>   HWND           hWndParent ; <br> <br>   hWndParent = WindowParent (hWnd) ; <br> <br>   if (hWndParent) <br>      SendMessage (hWndParent, WM_COMMAND,  <br>                   (WPARAM) WindowID (hWnd), <br>                   (LPARAM) hWnd) ; <br>   }  // ILNotifyChange <br> <br> <br>BOOL ILGrabRect (IN PILINE pILine,  <br>                 OUT LPRECT lpRect) <br>/* <br>   Effect:        Return in lpRect the rectangle representing the position <br>                  of the grab bar currently being tracked. <br>*/ <br>   {  // ILGrabRect <br>   switch (ILMode (pILine)) <br>      {  // switch <br>      case ILModeLeft: <br>         *lpRect = pILine-&gt;rectLeftGrab ; <br>         return (TRUE) ; <br>         break ; <br> <br>      case ILModeRight: <br>         *lpRect = pILine-&gt;rectRightGrab ; <br>         return (TRUE) ; <br>         break ; <br> <br>      case ILModeCenter: <br>         *lpRect = pILine-&gt;rectCenterGrab ; <br>         return (TRUE) ; <br>         break ; <br> <br>      case ILModeNone: <br>         lpRect-&gt;left = 0 ; <br>         lpRect-&gt;top = 0 ; <br>         lpRect-&gt;right = 0 ; <br>         lpRect-&gt;bottom = 0 ; <br>         return (FALSE) ; <br>         break ; <br>      }  // switch <br>   }  // ILGrabRect <br> <br> <br>PILINE ILData (HWND hWndIL) <br>   { <br>   return ((PILINE) GetWindowLong (hWndIL, 0)) ; <br>   } <br> <br> <br>PILINE AllocateILData (HWND hWndIL) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = MemoryAllocate (sizeof (ILINE)) ; <br>   SetWindowLong (hWndIL, 0, (LONG) pILine) ; <br> <br>   return (pILine) ; <br>   } <br> <br> <br>void static DrawGrab (HDC hDC, <br>                      LPRECT lpRectGrab, <br>                      BOOL bDown) <br>   {  // DrawGrab <br>   if (!RectDrawable (lpRectGrab)) <br>      return ; <br> <br>   if (bDown) <br>      ThreeDConcave1 (hDC,  <br>                     lpRectGrab-&gt;left, <br>                     lpRectGrab-&gt;top, <br>                     lpRectGrab-&gt;right, <br>                     lpRectGrab-&gt;bottom) ; <br>   else <br>      ThreeDConvex1 (hDC,  <br>                    lpRectGrab-&gt;left, <br>                    lpRectGrab-&gt;top, <br>                    lpRectGrab-&gt;right, <br>                    lpRectGrab-&gt;bottom) ; <br>   }  // DrawGrab <br> <br> <br>int ILValueToPixel (PILINE pILine, <br>                    int iValue) <br>   { <br>   int            xPixel ; <br> <br>   if (ILRange (pILine)) <br>      xPixel = MulDiv (iValue, ILWidth (pILine), ILRange (pILine)) ; <br>   else <br>      xPixel = 0 ; <br> <br>   return (PinExclusive (xPixel, 0, pILine-&gt;rectBorder.right)) ; <br>   } <br> <br> <br>int ILPixelToValue (PILINE pILine, <br>                    int xPixel) <br>   { <br>   int            iValue ; <br> <br>   if (ILWidth (pILine)) <br>      iValue = MulDiv (xPixel, ILRange (pILine), ILWidth (pILine)) ; <br>   else <br>      iValue = 0 ; <br> <br>   return (PinInclusive (iValue, ILBegin (pILine), ILEnd (pILine))) ; <br>   } <br> <br> <br>void static ILCalcPositions (HWND hWnd, <br>                             PILINE pILine) <br>/* <br>   Effect:        Determine and set all of the physical rectangles of ILine, <br>                  based on the current size of the ILine window and the  <br>                  current logical Start, Stop, Begin, and End values. <br>*/ <br>   {  // ILCalcPositions <br>   int            xStart, xStop ; <br>   int            yHeight ; <br> <br>   GetClientRect (hWnd, &amp;pILine-&gt;rectBorder) ; <br>   yHeight = pILine-&gt;rectBorder.bottom ; <br> <br>   xStart = ILValueToPixel (pILine, ILStart (pILine)) ; <br>   xStop = ILValueToPixel (pILine, ILStop (pILine)) ; <br> <br>   pILine-&gt;rectLeftBk.left = 1 ; <br>   pILine-&gt;rectLeftBk.top = 1 ; <br>   pILine-&gt;rectLeftBk.right = xStart ; <br>   pILine-&gt;rectLeftBk.bottom = yHeight - 1 ; <br> <br>   pILine-&gt;rectLeftGrab.left = xStart ; <br>   pILine-&gt;rectLeftGrab.top = 1 ; <br>   pILine-&gt;rectLeftGrab.right = xStart + ILGrabWidth () ; <br>   pILine-&gt;rectLeftGrab.bottom = yHeight - 1 ; <br> <br>   pILine-&gt;rectRightBk.left = xStop ; <br>   pILine-&gt;rectRightBk.top = 1 ; <br>   pILine-&gt;rectRightBk.right = pILine-&gt;rectBorder.right - 1 ; <br>   pILine-&gt;rectRightBk.bottom = yHeight - 1 ; <br> <br>   pILine-&gt;rectRightGrab.left = xStop - ILGrabWidth () ; <br>   pILine-&gt;rectRightGrab.top = 1 ; <br>   pILine-&gt;rectRightGrab.right = xStop ; <br>   pILine-&gt;rectRightGrab.bottom = yHeight - 1 ; <br> <br>   pILine-&gt;rectCenterGrab.left = pILine-&gt;rectLeftGrab.right ; <br>   pILine-&gt;rectCenterGrab.top = 1 ; <br>   pILine-&gt;rectCenterGrab.right = pILine-&gt;rectRightGrab.left ; <br>   pILine-&gt;rectCenterGrab.bottom = yHeight - 1 ; <br> <br>   if (pILine-&gt;rectLeftGrab.right &gt; pILine-&gt;rectRightGrab.left) <br>      { <br>      pILine-&gt;rectLeftGrab.right = pILine-&gt;rectLeftGrab.left +  <br>                                   (xStop - xStart) / 2 ; <br>      pILine-&gt;rectRightGrab.left = pILine-&gt;rectLeftGrab.right ; <br>      pILine-&gt;rectCenterGrab.left = 0 ; <br>      pILine-&gt;rectCenterGrab.right = 0 ; <br>      } <br>   }  // ILCalcPositions <br> <br> <br>void static ILDraw (HDC hDC,  <br>                    PILINE pILine,      <br>                    LPRECT lpRectUpdate) <br>/* <br>   Effect:        Draw the image of pILine on hDC.  Draw at least the  <br>                  portions within rectUpdate. <br> <br>   Called By:     OnPaint, OnMouseMove. <br>*/ <br>   {  // ILDraw <br> <br>   //=============================// <br>   // Draw Border                 // <br>   //=============================// <br>    <br>   FrameRect (hDC, &amp;pILine-&gt;rectBorder, GetStockObject (BLACK_BRUSH)) ; <br> <br>   //=============================// <br>   // Draw Background             // <br>   //=============================// <br> <br>   FillRect (hDC, &amp;pILine-&gt;rectLeftBk, pILine-&gt;hBrushBk) ; <br>   FillRect (hDC, &amp;pILine-&gt;rectRightBk, pILine-&gt;hBrushBk) ; <br> <br>   //=============================// <br>   // Draw Range Grabs            // <br>   //=============================// <br> <br>   DrawGrab (hDC, &amp;pILine-&gt;rectLeftGrab,  <br>             ILMode (pILine) == ILModeLeft) ; <br>   DrawGrab (hDC, &amp;pILine-&gt;rectRightGrab, <br>             ILMode (pILine) == ILModeRight) ; <br> <br>   //=============================// <br>   // Draw Center Grab            // <br>   //=============================// <br> <br>   DrawGrab (hDC, &amp;pILine-&gt;rectCenterGrab, <br>             ILMode (pILine) == ILModeCenter) ; <br>   }  // ILDraw <br> <br>#if 0 <br>void ILPageLeftRight (HWND hWnd, <br>                      PILINE pILine, <br>                      BOOL bLeft) <br>   {  // ILPageLeftRight <br>   int            iStart, iStop, iMove ; <br>   HDC            hDC ; <br> <br>   iStart = ILStart (pILine) ; <br>   iStop = ILStop (pILine) ; <br> <br>   if (ILRange (pILine) &gt;= 10)    <br>      iMove = ILRange (pILine) / 10 ; <br>   else <br>      iMove = 1 ; <br> <br>   if (bLeft) <br>      iMove = -iMove ; <br> <br>   iStart += iMove ; <br>   iStop += iMove ; <br> <br>   ILineSetStart (hWnd, iStart) ; <br>   ILineSetStop (hWnd, iStop) ; <br> <br>   hDC = GetDC (hWnd) ; <br>   ILDraw (hDC, pILine, &amp;pILine-&gt;rectBorder) ; <br>   ReleaseDC (hWnd, hDC) ; <br> <br>   ILNotifyChange (hWnd, pILine) ; <br>   }  // ILPageLeftRight <br>#endif <br> <br>void ILMoveLeftRight (HWND hWnd, <br>                      BOOL bStart, <br>                      BOOL bLeft, <br>                      int  MoveAmt) <br>   {  // ILPageLeftRight <br>   int            iStart, iStop, iMove ; <br>   int            iBegin, iEnd ; <br>   HDC            hDC ; <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br>   iStart = ILStart (pILine) ; <br>   iStop = ILStop (pILine) ; <br>   iBegin = ILBegin (pILine) ; <br>   iEnd = ILEnd (pILine) ; <br> <br>   iMove = MoveAmt ; <br>   if (bLeft) <br>      iMove = -iMove ; <br> <br>   if (bStart) <br>      { <br>      if (MoveAmt == TO_THE_END) <br>         { <br>         iStart = iBegin ; <br>         } <br>      else <br>         { <br>         iStart += iMove ; <br>         if (iStart &gt;= iStop) <br>            { <br>            return; <br>            } <br>         } <br> <br>      ILineSetStart (hWnd, iStart) ; <br>      } <br>   else <br>      { <br>      if (MoveAmt == TO_THE_END) <br>         { <br>         iStop = iEnd ; <br>         } <br>      else <br>         { <br>         iStop += iMove ; <br>         if (iStart &gt;= iStop) <br>            { <br>            return; <br>            } <br>         } <br> <br>      ILineSetStop (hWnd, iStop) ; <br>      } <br> <br>   hDC = GetDC (hWnd) ; <br>   ILDraw (hDC, pILine, &amp;pILine-&gt;rectBorder) ; <br>   ReleaseDC (hWnd, hDC) ; <br> <br>   ILNotifyChange (hWnd, pILine) ; <br>   }  // ILMoveLeftRight <br> <br>static BOOL OnKeyDown (HWND hWnd, <br>                       WPARAM wParam) <br>   { <br>   BOOL bHandle = TRUE ; <br>   BOOL bStart ; <br>   BOOL bLeftDirection ; <br>   BOOL bShiftKeyDown ; <br> <br>   if (wParam == VK_LEFT || wParam == VK_RIGHT) <br>      { <br>      bShiftKeyDown = (GetKeyState (VK_SHIFT) &lt; 0) ; <br> <br>      if (!bShiftKeyDown) <br>         { <br>         if (wParam == VK_LEFT) <br>            { <br>            // Left Arrow --&gt; move Start Edge Left <br>            bStart = TRUE ; <br>            bLeftDirection = TRUE ; <br>            } <br>         else <br>            { <br>            // Right Arrow --&gt; move Stop Edge Right <br>            bStart = FALSE ; <br>            bLeftDirection = FALSE ; <br>            } <br>         } <br>      else <br>         { <br>         if (wParam == VK_LEFT) <br>            { <br>            // Shift Left Arrow --&gt; move Stop Edge Left <br>            bStart = FALSE ; <br>            bLeftDirection = TRUE ; <br>            } <br>         else <br>            { <br>            // Shift Right Arrow --&gt; move Start Edge Right <br>            bStart = TRUE ; <br>            bLeftDirection = FALSE ; <br>            } <br>         } <br>      ILMoveLeftRight (hWnd, bStart, bLeftDirection, 1) ; <br>      } <br>   else if (wParam == VK_HOME) <br>      { <br>      // move iStart all the way the Left <br>      ILMoveLeftRight (hWnd, TRUE, TRUE, TO_THE_END) ; <br>      } <br>   else if (wParam == VK_END) <br>      { <br>      // move iStop all the way the right <br>      ILMoveLeftRight (hWnd, FALSE, FALSE, TO_THE_END) ; <br>      } <br>   else <br>      { <br>      bHandle = FALSE ; <br>      } <br>   return (bHandle) ; <br> <br>   }  // OnKeyDown <br> <br>void StartGrab (HWND hWnd, <br>                PILINE pILine) <br>   {  // StartGrab <br>   RECT           rectUpdate ; <br>   HDC            hDC ; <br> <br>   SetCapture (hWnd) ; <br>   ILGrabRect (pILine, &amp;rectUpdate) ; <br> <br>   hDC = GetDC (hWnd) ; <br>   ILDraw (hDC, pILine, &amp;rectUpdate) ; <br>   ReleaseDC (hWnd, hDC) ; <br>   }  // StartGrab <br> <br> <br>void EndGrab (HWND hWnd, <br>              PILINE pILine) <br>/* <br>   Internals:     Set the mode to null after getting the grab rectangle <br>                  so ILGrabRect knows which grab bar to get. <br>*/ <br>   { <br>   RECT           rectUpdate ; <br>   HDC            hDC ; <br> <br>   ReleaseCapture () ; <br> <br>   ILGrabRect (pILine, &amp;rectUpdate) ; <br>   ILMode (pILine) = ILModeNone ; <br> <br>   hDC = GetDC (hWnd) ; <br>   ILDraw (hDC, pILine, &amp;rectUpdate) ; <br>   ReleaseDC  (hWnd, hDC) ; <br>   } <br> <br>    <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void static OnPaint (HWND hWnd) <br>   { <br>   PAINTSTRUCT    ps ; <br>   HDC            hDC ; <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br>   hDC = BeginPaint (hWnd, &amp;ps) ; <br> <br>   ILDraw (hDC, pILine, &amp;ps.rcPaint) ; <br> <br>   EndPaint (hWnd, &amp;ps) ; <br>   } <br> <br> <br>void static OnCreate (HWND hWnd) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = AllocateILData (hWnd) ; <br>   ILBegin (pILine) =  0 ; <br>   ILEnd (pILine) =  100 ; <br>   ILStart (pILine) =  0 ; <br>   ILStop (pILine) = 100 ; <br>   ILMode (pILine) = ILModeNone ; <br> <br>   pILine-&gt;hBrushBk = CreateSolidBrush (crBlue) ; <br>   ILCalcPositions (hWnd, pILine) ; <br>   } <br> <br> <br>void static OnDestroy (HWND hWnd) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   IntrLineFocus = FALSE ; <br>   DeleteBrush (pILine-&gt;hBrushBk) ; <br>   MemoryFree (pILine) ; <br>   } <br> <br> <br>void static OnLButtonUp (HWND hWnd) <br>   {  // OnLButtonUp <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   if (ILMode (pILine) == ILModeNone) <br>      return ; <br> <br>   EndGrab (hWnd, pILine) ; <br>   }  // OnLButtonUp <br> <br> <br>void static OnMouseMove (HWND hWnd, <br>                         POINTS ptsMouse) <br>/* <br>   Effect:        Handle any actions needed when the mouse moves in the <br>                  ILine hWnd's client area or while the mouse is captured. <br>                  In particular, if we are tracking one of the grab bars,  <br>                  determine if the mouse movement represents a logical value  <br>                  change and move the grab bar accordingly. <br> <br>   Called By:     ILineWndProc, in response to a WM_MOUSEMOVE message. <br> <br>   See Also:      OnLButtonDown, OnLButtonUp. <br> <br>   Note:          This function has multiple return points. <br> <br>   Note:          Since we have captured the mouse, we receive mouse msgs <br>                  even when the mouse is outside our client area, but still <br>                  in client coordinates. Thus we can have negative mouse <br>                  coordinates. That is why we convert the lParam of the <br>                  mouse msg into a POINTS structure rather than 2 WORDS. <br>                   <br>                    <br>   Internals:     Remember that an IntervalLine can only take on integral <br>                  values in the user-supplied range. Therefore we do our <br>                  movement calculation in user values, not pixels. We <br>                  determine what the logical value would be for the previous <br>                  (last mouse move) and current mouse position. If these <br>                  LOGICAL values differ, we attempt an adjustment of the <br>                  grab bar by that logical amount.  This way the grab  <br>                  values assume on integral positions and the calculations <br>                  are simplified.  <br> <br>                  If we calculated by pixel movement, and then shifted the  <br>                  bar into the nearest integal position, we would encounter  <br>                  rounding problems. In particular, when tracking the center  <br>                  grab bar, if we moved both start and stop by the same  <br>                  amount of PIXELS, then converted to LOGICAL values, we  <br>                  might find our center bar shrinking and growing while <br>                  the bar moves. <br>*/ <br>   { <br>   int            iMousePrevious, iMouseCurrent ; <br>   int            iMouseMove ; <br>   PILINE         pILine ; <br>   HDC            hDC ; <br> <br>   //=============================// <br>   // Are we tracking?            // <br>   //=============================// <br> <br>   pILine = ILData (hWnd) ; <br>   if (ILMode (pILine) == ILModeNone) <br>      return ; <br> <br>   //=============================// <br>   // Calc LOGICAL mouse movement // <br>   //=============================// <br> <br>   ptsMouse.x = PinInclusive ((INT)ptsMouse.x,  <br>                              (INT)pILine-&gt;rectBorder.left,  <br>                              (INT)pILine-&gt;rectBorder.right) ; <br> <br>   iMousePrevious = ILPixelToValue (pILine, pILine-&gt;ptsMouse.x) ; <br>   iMouseCurrent = ILPixelToValue (pILine, ptsMouse.x) ; <br> <br>   iMouseMove = iMouseCurrent - iMousePrevious ; <br>   if (!iMouseMove)    <br>      return ; <br> <br>   //=============================// <br>   // Move grab bar positions     // <br>   //=============================// <br> <br>   switch (ILMode (pILine)) <br>      {  // switch    <br>      case ILModeLeft: <br>         ILStart (pILine) += iMouseMove ; <br>         ILStart (pILine) = min (ILStart (pILine), ILStop (pILine) - 1) ; <br>         break ; <br> <br>      case ILModeCenter: <br>         // Before we slide the center grab bar we need to see if the  <br>         // desired movement amount would send either end out of bounds, <br>         // and reduce the movement accordingly. <br> <br>         if (ILStart (pILine) + iMouseMove &lt; ILBegin (pILine)) <br>            iMouseMove = ILBegin (pILine) - ILStart (pILine) ; <br>         if (ILStop (pILine) + iMouseMove &gt; ILEnd (pILine)) <br>            iMouseMove = ILEnd (pILine) - ILStop (pILine) ; <br> <br>         ILStart (pILine) += iMouseMove ; <br>         ILStop (pILine) += iMouseMove ; <br>         break ; <br> <br>      case ILModeRight: <br>         ILStop (pILine) += iMouseMove ; <br>         ILStop (pILine) = max (ILStart (pILine) + 1, ILStop (pILine)) ; <br>         break ; <br>      }  // switch <br> <br> <br>   //=============================// <br>   // Keep grab bars in range     // <br>   //=============================// <br> <br> <br>   ILStart (pILine) = PinInclusive (ILStart (pILine), <br>                                    ILBegin (pILine), ILEnd (pILine)) ; <br>   ILStop (pILine) = PinInclusive (ILStop (pILine), <br>                                   ILBegin (pILine), ILEnd (pILine)) ; <br> <br>   //=============================// <br>   // Determine pixel pos, draw   // <br>   //=============================// <br> <br>   ILCalcPositions (hWnd, pILine) ; <br> <br>   hDC = GetDC (hWnd) ; <br>   ILDraw (hDC, pILine, &amp;pILine-&gt;rectBorder) ; <br>   ReleaseDC (hWnd, hDC) ; <br> <br>   pILine-&gt;ptsMouse = ptsMouse ; <br>   ILNotifyChange (hWnd, pILine) ; <br>   }  // OnMouseMove <br> <br> <br>void static OnLButtonDown (HWND hWnd,  <br>                           POINTS ptsMouse) <br>   { <br>   PILINE         pILine ; <br>   POINT          ptMouse ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   pILine-&gt;ptsMouse = ptsMouse ; <br>   ptMouse.x = ptsMouse.x ; <br>   ptMouse.y = ptsMouse.y ; <br> <br>#if 0 <br>   // Russ said this is bad, so don't do it <br>   if (PtInRect (&amp;pILine-&gt;rectLeftBk, ptMouse)) <br>      ILPageLeftRight (hWnd, pILine, TRUE) ; <br> <br>   else if (PtInRect (&amp;pILine-&gt;rectRightBk, ptMouse)) <br>      ILPageLeftRight (hWnd, pILine, FALSE) ; <br> <br>   else if (PtInRect (&amp;pILine-&gt;rectLeftGrab, ptMouse)) <br>#endif <br>   if (PtInRect (&amp;pILine-&gt;rectLeftGrab, ptMouse) || <br>       PtInRect (&amp;pILine-&gt;rectLeftBk, ptMouse)) <br>      { <br>      ILMode (pILine) = ILModeLeft ; <br>      StartGrab (hWnd, pILine) ; <br>      } <br> <br>   else if (PtInRect (&amp;pILine-&gt;rectRightGrab, ptMouse) || <br>            PtInRect (&amp;pILine-&gt;rectRightBk, ptMouse)) <br>      { <br>      ILMode (pILine) = ILModeRight ; <br>      StartGrab (hWnd, pILine) ; <br>      } <br> <br>   else if (PtInRect (&amp;pILine-&gt;rectCenterGrab, ptMouse)) <br>      { <br>      ILMode (pILine) = ILModeCenter ; <br>      StartGrab (hWnd, pILine) ; <br>      } <br>   } <br> <br> <br>void static OnSize (HWND hWnd, WORD xWidth, WORD yHeight) <br>   {  // OnSize <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   ILCalcPositions (hWnd, pILine) ; <br>   }  // OnSize <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>LONG FAR PASCAL ILineWndProc (HWND hWnd, <br>                              unsigned msg, <br>                              WPARAM wParam, <br>                              LONG lParam) <br>/* <br>   Note:          This function must be declared in the application's <br>                  linker-definition file, perfmon.def file. <br>*/ <br>   {  // ILineWndProc <br>   BOOL           bCallDefWindowProc ; <br>   POINTS         ptsMouse ; <br>   LONG           lReturnValue ; <br> <br>   bCallDefWindowProc = FALSE ; <br>   lReturnValue = 0L ; <br> <br>   switch (msg) <br>      {  // switch <br>      case WM_CREATE: <br>         OnCreate (hWnd) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hWnd) ; <br>         break ; <br> <br>      case WM_LBUTTONDOWN: <br>         // See the note in OnMouseMove for why we are using POINTS <br>         SetFocus (hWnd) ; <br>         ptsMouse = MAKEPOINTS (lParam) ; <br>         OnLButtonDown (hWnd, ptsMouse) ; <br>         break ; <br> <br>      case WM_LBUTTONUP: <br>         OnLButtonUp (hWnd) ; <br>         break ; <br> <br>      case WM_SETFOCUS: <br>      case WM_KILLFOCUS: <br>         { <br>         PILINE         pILine ; <br> <br>         IntrLineFocus = (msg == WM_SETFOCUS) ; <br> <br>         pILine = ILData (hWnd) ; <br>         ILNotifyChange (hWnd, pILine) ; <br>         } <br>         return 0 ; <br> <br> <br>      case WM_MOUSEMOVE: <br>         // See the note in OnMouseMove for why we are using POINTS <br>         ptsMouse = MAKEPOINTS (lParam) ; <br>         OnMouseMove (hWnd, ptsMouse) ; <br>         break ; <br> <br>      case WM_KEYDOWN: <br>         if (!OnKeyDown (hWnd, wParam)) <br>            { <br>            bCallDefWindowProc = TRUE ; <br>            } <br>         break ; <br>   <br>      case WM_GETDLGCODE: <br>         // We want to handle Arrow keys input.  If we don't specify this <br>         // the dialog will not pass arrow keys to us. <br>         return (DLGC_WANTARROWS) ; <br>         break ; <br> <br>      case WM_PAINT: <br>         OnPaint (hWnd) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hWnd, LOWORD (lParam), HIWORD (lParam)) ; <br> <br>      default: <br>         bCallDefWindowProc = TRUE ; <br>      }  // switch <br> <br>   if (bCallDefWindowProc) <br>      lReturnValue = DefWindowProc (hWnd, msg, wParam, lParam) ; <br> <br>   return (lReturnValue) ; <br>   }  // ILineWndProc <br> <br> <br> <br>BOOL ILineInitializeApplication (void) <br>/* <br>   Effect:        Perform all initializations required before an application <br>                  can create an IntervalLine. In particular, register the  <br>                  IntervalLine window class. <br> <br>   Called By:     The application, in its InitializeApplication routine. <br> <br>   Returns:       Whether the class could be registered. <br>*/ <br>   {  // ILineInitializeApplication <br>   WNDCLASS       wc ; <br> <br>   wc.style =           dwILineClassStyle ; <br>   wc.lpfnWndProc =     ILineWndProc ; <br>   wc.cbClsExtra =      iILineClassExtra ; <br>   wc.cbWndExtra =      iILineWindowExtra ; <br>   wc.hInstance =       hInstance ; <br>   wc.hIcon =           NULL ; <br>   wc.hCursor =         LoadCursor (NULL, IDC_ARROW) ; <br>   wc.hbrBackground =   NULL ; <br>   wc.lpszMenuName =    NULL ; <br>   wc.lpszClassName =   szILineClass ; <br> <br>   return (RegisterClass (&amp;wc)) ; <br>   }  // ILineInitializeApplication <br> <br> <br>void ILineSetRange (HWND hWnd, int iBegin, int iEnd) </code></pre>
<p>
</p>
<pre><code>{  // ILineSetRange <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   ILBegin (pILine) = iBegin ; <br>   ILEnd (pILine) = iEnd ; <br> <br>   ILCalcPositions (hWnd, pILine) ; <br>   }  // ILineSetRange <br> <br> <br>void ILineSetStart (HWND hWnd, int iStart) <br>   {  // ILineSetStart <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   iStart = PinInclusive (iStart, ILBegin (pILine), ILEnd (pILine)) ; <br>   ILStart (pILine) = iStart ; <br> <br>   ILCalcPositions (hWnd, pILine) ; <br>   }  // ILineSetStart <br> <br> <br> <br>void ILineSetStop (HWND hWnd, int iStop) <br>   {  // ILineSetStop <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   iStop = PinInclusive (iStop, ILBegin (pILine), ILEnd (pILine)) ; <br>   ILStop (pILine) = iStop ; <br> <br>   ILCalcPositions (hWnd, pILine) ; <br>   }  // ILineSetStop <br> <br> <br>int ILineXStart (HWND hWnd) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   return (pILine-&gt;rectLeftGrab.left) ; <br>   } <br> <br> <br>int ILineXStop (HWND hWnd) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   return (pILine-&gt;rectRightGrab.right) ; <br>   } <br> <br> <br>int ILineStart (HWND hWnd) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   return  (ILStart (pILine)) ; <br>   } <br> <br> <br>int ILineStop (HWND hWnd) <br>   { <br>   PILINE         pILine ; <br> <br>   pILine = ILData (hWnd) ; <br> <br>   return  (ILStop (pILine)) ; <br>   } <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
