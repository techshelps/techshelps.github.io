<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COUNTERS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5644"></a>COUNTERS.C</h2>
<pre><code>/*++ BUILD Version: 0001    // Increment this if a change has global effects <br> <br>Copyright (c) 1992-1996   Microsoft Corporation <br> <br>Module Name: <br> <br>    counters.c   <br> <br>Abstract: <br> <br>    This module contains the routines to calculate "DataPoint" values from <br>    the registry data. <br> <br>    The algoritms were lifted from RussBls's "Data.C" in winmeter. <br> <br>    All the math is done in floating point to get the correct results, at <br>    the sacrifice of efficiency on a 386 with not 387. We can always <br>    revisit these routines later. <br> <br>Revision History: <br> <br>    Bob Watson  11/04/92 <br>        -- modified calculations to use more integer math and "early <br>            exits" to improve efficiency on slower &amp; non-coprocessor <br>            machines <br>--*/ <br> <br>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include "perfmon.h"       // perfmon include files <br>#include "counters.h"      // Exported declarations for this file <br> <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define INVERT             PERF_COUNTER_TIMER_INV <br>#define NS100_INVERT       PERF_100NSEC_TIMER_INV <br>#define NS100              PERF_100NSEC_TIMER <br>#define TIMER_MULTI        PERF_COUNTER_MULTI_TIMER <br>#define TIMER_MULTI_INVERT PERF_COUNTER_MULTI_TIMER_INV <br>#define NS100_MULTI        PERF_100NSEC_MULTI_TIMER <br>#define NS100_MULTI_INVERT PERF_100NSEC_MULTI_TIMER_INV <br> <br> <br>#define FRACTION 1 <br>#define BULK     1 <br> <br>#define TOO_BIG   (FLOAT)1500000000 <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br> <br>  <br>FLOAT <br>eGetTimeInterval( <br>    IN LONGLONG *pliCurrentTime, <br>    IN LONGLONG *pliPreviousTime, <br>    IN LONGLONG *pliFreq <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Get the difference between the current and previous time counts, <br>        then divide by the frequency. <br>     <br>Arguments: <br> <br>    IN pCurrentTime <br>    IN pPreviousTime <br>        used to compute the duration of this sample (the time between <br>        samples <br> <br>    IN pliFreq <br>        # of  counts (clock ticks) per second <br> <br>Return Value: <br> <br>    Floating point representation of Time Interval (seconds) <br>--*/ <br>{ <br>    FLOAT   eTimeDifference; <br>    FLOAT   eFreq; <br>    FLOAT   eTimeInterval ; <br> <br>    LONGLONG liDifference; <br> <br>    // Get the number of counts that have occured since the last sample <br> <br>    liDifference = *pliCurrentTime - *pliPreviousTime; <br> <br>    if (liDifference &lt;= (LONGLONG)0) { <br>        return (FLOAT) 0.0f; <br>    } else { <br>        eTimeDifference = (FLOAT)liDifference; <br> <br>        // Get the counts per second <br> <br>        eFreq = (FLOAT)(*pliFreq) ; <br>        if (eFreq &lt;= 0.0f) <br>           return (FLOAT) 0.0f; <br> <br>        // Get the time since the last sample. <br> <br>        eTimeInterval = eTimeDifference / eFreq ; <br> <br>        return (eTimeInterval) ; <br>    } <br>} // eGetTimeInterval <br>  <br>FLOAT <br>Counter_Counter_Common( <br>    IN PLINESTRUCT pLineStruct, <br>    IN INT iType <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Take the difference between the current and previous counts <br>        then divide by the time interval <br>     <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>    IN iType <br>        Counter Type <br>         <br> <br>Return Value: <br> <br>    Floating point representation of outcome <br>--*/ <br>{ <br>    FLOAT   eTimeInterval; <br>    FLOAT   eDifference; <br>    FLOAT   eCount ; <br>    BOOL    bValueDrop = FALSE ; <br> <br>    LONGLONG   liDifference; <br> <br>    if (iType != BULK) { <br> <br>        // check if it is too big to be a wrap-around case <br>        if (pLineStruct-&gt;lnaCounterValue[0] &lt; <br>            pLineStruct-&gt;lnaOldCounterValue[0]) <br>           { <br>           if (pLineStruct-&gt;lnaCounterValue[0] - <br>               pLineStruct-&gt;lnaOldCounterValue[0] &gt; (DWORD)0x00ffff0000) <br>              { <br>              return (FLOAT) 0.0f; <br>              } <br>           bValueDrop = TRUE ; <br>           } <br> <br>        liDifference = pLineStruct-&gt;lnaCounterValue[0] - <br>                       pLineStruct-&gt;lnaOldCounterValue[0]; <br> <br>        liDifference &amp;= (DWORD)(0x0ffffffff); <br> <br>    } else { <br>        liDifference = pLineStruct-&gt;lnaCounterValue[0] - <br>                       pLineStruct-&gt;lnaOldCounterValue[0]; <br>    } <br>     <br>    if (liDifference &lt;= (LONGLONG) 0) { <br>        return (FLOAT) 0.0f; <br>    } else { <br>        eTimeInterval = eGetTimeInterval(&amp;pLineStruct-&gt;lnNewTime, <br>                                        &amp;pLineStruct-&gt;lnOldTime, <br>                                        &amp;pLineStruct-&gt;lnPerfFreq) ; <br>        if (eTimeInterval &lt;= 0.0f) { <br>            return (FLOAT) 0.0f; <br>        } else { <br>            eDifference = (FLOAT)(liDifference); <br> <br>            eCount         = eDifference / eTimeInterval ; <br>             <br>            if (bValueDrop &amp;&amp; eCount &gt; (FLOAT) TOO_BIG) { <br>                // ignore this bogus data since it is too big for  <br>                // the wrap-around case <br>                eCount = (FLOAT) 0.0f ; <br>            } <br>            return(eCount) ; <br>        } <br>    } <br>} // Counter_Counter_Common <br> <br>  <br>FLOAT <br>Counter_Average_Timer( <br>    IN PLINESTRUCT pLineStruct <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Take the differences between the current and previous times and counts <br>    divide the time interval by the counts multiply by 10,000,000 (convert <br>    from 100 nsec to sec) <br>     <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>Return Value: <br> <br>    Floating point representation of outcome <br>--*/ <br>{ <br>    FLOAT   eTimeInterval; <br>    FLOAT   eCount; <br> <br>    LONGLONG    liDifference; <br> <br>    // Get the current and previous counts. <br> <br>    liDifference = (DWORD)pLineStruct-&gt;lnaCounterValue[1] -  <br>            (DWORD)pLineStruct-&gt;lnaOldCounterValue[1]; <br> <br>    if ( liDifference &lt;= 0) { <br>        return (FLOAT) 0.0f; <br>    } else { <br>        // Get the amount of time that has passed since the last sample <br>        eTimeInterval = eGetTimeInterval(&amp;pLineStruct-&gt;lnaCounterValue[0], <br>                                            &amp;pLineStruct-&gt;lnaOldCounterValue[0], <br>                                            &amp;pLineStruct-&gt;lnPerfFreq) ; <br> <br>        if (eTimeInterval &lt; 0.0f) { // return 0 if negative time has passed <br>            return (0.0f); <br>        } else { <br>            // Get the number of counts in this time interval. <br>            eCount = eTimeInterval / (FLOAT)(liDifference); <br>            return(eCount) ; <br>        } <br>    } <br>} //Counter_Average_Timer <br> <br> <br>  <br>FLOAT <br>Counter_Average_Bulk( <br>    IN PLINESTRUCT pLineStruct <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Take the differences between the current and previous byte counts and <br>    operation counts divide the bulk count by the operation counts <br>     <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>Return Value: <br> <br>    Floating point representation of outcome <br>--*/ <br>{ <br>    FLOAT   eBulkDelta; <br>    FLOAT   eDifference; <br>    FLOAT   eCount; <br> <br>    LONGLONG liDifference; <br>    LONGLONG liBulkDelta; <br> <br>    // Get the bulk count increment since the last sample <br> <br>    liBulkDelta = pLineStruct-&gt;lnaCounterValue[0] - <br>            pLineStruct-&gt;lnaOldCounterValue[0]; <br> <br>    if (liBulkDelta &lt;= (LONGLONG) 0) { <br>        return (FLOAT) 0.0f; <br>    } else { <br>        // Get the current and previous counts. <br>        liDifference = (DWORD)pLineStruct-&gt;lnaCounterValue[1] - <br>                (DWORD) pLineStruct-&gt;lnaOldCounterValue[1]; <br>        liDifference &amp;= (DWORD) (0x0ffffffff); <br> <br>        // Get the number of counts in this time interval. <br> <br>        if ( liDifference &lt;= (LONGLONG) 0) { <br>            // Counter value invalid <br>            return (FLOAT) 0.0f; <br>        } else { <br>            eBulkDelta = (FLOAT) (liBulkDelta); <br>            eDifference = (FLOAT) (liDifference); <br>            eCount = eBulkDelta / eDifference ; <br> <br>            // Scale the value to up to 1 second <br> <br>            return(eCount) ; <br>        } <br>    } <br>} // Counter_Average_Bulk <br> <br> <br>  <br>FLOAT <br>Counter_Timer_Common( <br>    IN  PLINESTRUCT pLineStruct, <br>    IN  INT iType <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Take the difference between the current and previous counts, <br>        Normalize the count (counts per interval) <br>        divide by the time interval (count = % of interval) <br>        if (invert) <br>            subtract from 1 (the normalized size of an interval) <br>        multiply by 100 (convert to a percentage) <br>        this value from 100. <br>     <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>    IN iType <br>        Counter Type <br> <br>Return Value: <br> <br>    Floating point representation of outcome <br>--*/ <br>{ <br>    FLOAT   eTimeInterval; <br>    FLOAT   eDifference; <br>    FLOAT   eFreq; <br>    FLOAT   eFraction; <br>    FLOAT   eMultiBase; <br>    FLOAT   eCount ; <br> <br>    LONGLONG   liTimeInterval; <br>    LONGLONG   liDifference; <br> <br>    // Get the amount of time that has passed since the last sample <br> <br>    if (iType == NS100 || <br>        iType == NS100_INVERT || <br>        iType == NS100_MULTI || <br>        iType == NS100_MULTI_INVERT) { <br>            liTimeInterval = pLineStruct-&gt;lnNewTime100Ns - <br>                pLineStruct-&gt;lnOldTime100Ns ; <br>            eTimeInterval = (FLOAT) (liTimeInterval); <br>    } else { <br>            eTimeInterval = eGetTimeInterval(&amp;pLineStruct-&gt;lnNewTime, <br>                                            &amp;pLineStruct-&gt;lnOldTime, <br>                                            &amp;pLineStruct-&gt;lnPerfFreq) ; <br>    } <br> <br>    if (eTimeInterval &lt;= 0.0f) <br>       return (FLOAT) 0.0f; <br> <br>    // Get the current and previous counts. <br> <br>    liDifference = pLineStruct-&gt;lnaCounterValue[0] - <br>            pLineStruct-&gt;lnaOldCounterValue[0] ; <br> <br>    // Get the number of counts in this time interval. <br>    // (1, 2, 3 or any number of seconds could have gone by since <br>    // the last sample) <br> <br>    eDifference = (FLOAT) (liDifference) ; <br> <br>    if (iType == 0 || iType == INVERT) <br>    { <br>        // Get the counts per interval (second) <br> <br>        eFreq = (FLOAT) (pLineStruct-&gt;lnPerfFreq) ; <br>        if (eFreq &lt;= 0.0f) <br>           return (FLOAT) 0.0f; <br> <br>        // Calculate the fraction of the counts that are used by whatever <br>        // we are measuring <br> <br>        eFraction = eDifference / eFreq ; <br>    } <br>    else <br>    { <br>        eFraction = eDifference ; <br>    } <br> <br>    // Calculate the fraction of time used by what were measuring. <br> <br>    eCount = eFraction / eTimeInterval ; <br> <br>    // If this is  an inverted count take care of the inversion. <br> <br>    if (iType == INVERT || iType == NS100_INVERT) <br>        eCount = (FLOAT) 1.0 - eCount ; <br> <br>    // If this is  an inverted multi count take care of the inversion. <br> <br>    if (iType == TIMER_MULTI_INVERT || iType == NS100_MULTI_INVERT) { <br>        eMultiBase  = (FLOAT)pLineStruct-&gt;lnaCounterValue[1] ; <br>        eCount = (FLOAT) eMultiBase - eCount ; <br>    } <br> <br>    // Scale the value to up to 100. <br> <br>    eCount *= 100.0f ; <br> <br>    if (eCount &lt; 0.0f) eCount = 0.0f ; <br> <br>    if (eCount &gt; 100.0f &amp;&amp; <br>        iType != NS100_MULTI &amp;&amp; <br>        iType != NS100_MULTI_INVERT &amp;&amp; <br>        iType != TIMER_MULTI &amp;&amp; <br>        iType != TIMER_MULTI_INVERT) { <br> <br>        eCount = 100.0f; <br>    } <br> <br>    return(eCount) ; <br>} // Counter_Timer_Common <br> <br>  <br>FLOAT <br>Counter_Raw_Fraction( <br>    IN PLINESTRUCT pLineStruct <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Evaluate a raw fraction (no time, just two values: Numerator and <br>        Denominator) and multiply by 100 (to make a percentage; <br> <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>Return Value: <br> <br>    Floating point representation of outcome <br>--*/ <br>{ <br>    FLOAT   eCount ; <br> <br>    LONGLONG   liNumerator; <br> <br>    if ( pLineStruct-&gt;lnaCounterValue[0] == 0 || <br>            pLineStruct-&gt;lnaCounterValue[1] == 0 ) { <br>        // invalid value <br>        return (0.0f); <br>    } else { <br>        liNumerator = pLineStruct-&gt;lnaCounterValue[0] * 100; <br>        eCount = (FLOAT) (liNumerator)  / <br>                 (FLOAT) pLineStruct-&gt;lnaCounterValue[1]; <br>        return(eCount) ; <br>    } <br>} // Counter_Raw_Fraction <br> <br>  <br>FLOAT <br>eElapsedTime( <br>    PLINESTRUCT pLineStruct, <br>    INT iType <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Converts 100NS elapsed time to fractional seconds <br> <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>    IN iType <br>        Unused. <br> <br>Return Value: <br> <br>    Floating point representation of elapsed time in seconds <br>--*/ <br>{ <br>    FLOAT   eSeconds ; <br> <br>    LONGLONG   liDifference; <br> <br>    if (pLineStruct-&gt;lnaCounterValue[0] &lt;= (LONGLONG) 0) { <br>        // no data [start time = 0] so return 0 <br>        return (FLOAT) 0.0f; <br>    } else { <br>        LONGLONG PerfFreq; <br>        <br>        PerfFreq = *(LONGLONG UNALIGNED *)(&amp;pLineStruct-&gt;lnObject.PerfFreq) ; <br> <br>        // otherwise compute difference between current time and start time <br>        liDifference =  <br>            pLineStruct-&gt;lnNewTime - pLineStruct-&gt;lnaCounterValue[0]; <br> <br>        if (liDifference &lt;= (LONGLONG) 0 || <br>            PerfFreq &lt;= 0) { <br>            return (FLOAT) 0.0f; <br>        } else { <br>            // convert to fractional seconds using object counter <br>            eSeconds = (FLOAT) (liDifference) / <br>                (FLOAT) (PerfFreq); <br> <br>            return (eSeconds); <br>        } <br>    } <br>     <br>} // eElapsedTime <br> <br>  <br>FLOAT <br>Sample_Common( <br>    PLINESTRUCT pLineStruct, <br>    INT iType <br>) <br>/*++ <br> <br>Routine Description: <br> <br>    Divites "Top" differenced by Base Difference <br> <br>Arguments: <br> <br>    IN pLineStruct <br>        Line structure containing data to perform computations on <br> <br>    IN iType <br>        Counter Type <br> <br>Return Value: <br> <br>    Floating point representation of outcome <br>--*/ <br>{ <br>    FLOAT   eCount ; <br> <br>    LONG    lDifference; <br>    LONG    lBaseDifference; <br> <br>    lDifference = (DWORD)pLineStruct-&gt;lnaCounterValue[0] - <br>        (DWORD)pLineStruct-&gt;lnaOldCounterValue[0] ; <br>    lDifference &amp;= (DWORD) (0x0ffffffff); <br> <br>    if (lDifference &lt;= 0) { <br>        return (FLOAT) 0.0f; <br>    } else { <br>        lBaseDifference = (DWORD)pLineStruct-&gt;lnaCounterValue[1] - <br>            (DWORD)pLineStruct-&gt;lnaOldCounterValue[1] ; <br> <br>        if ( lBaseDifference &lt;= 0 ) { <br>            // invalid value <br>            return (0.0f); <br>        } else { <br>            eCount = (FLOAT)lDifference / (FLOAT)lBaseDifference ; <br> <br>            if (iType == FRACTION) { <br>                eCount *= (FLOAT) 100.0f ; <br>            } <br>            return(eCount) ; <br>        } <br>    } <br>} // Sample_Common <br> <br>  <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>/***************************************************************************** <br> * Counter_Counter - Take the difference between the current and previous <br> *                   counts then divide by the time interval <br> ****************************************************************************/ <br>#define Counter_Counter(pLineStruct)      \ <br>        Counter_Counter_Common(pLineStruct, 0) <br>#if 0 <br>FLOAT Counter_Counter(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Counter_Common(pLineStruct, 0) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Bulk    - Take the difference between the current and previous <br> *                   counts then divide by the time interval <br> *                   Same as a Counter_counter except it uses lognlong <br> ****************************************************************************/ <br>#define Counter_Bulk(pLineStruct)         \ <br>        Counter_Counter_Common(pLineStruct, BULK) <br>#if 0 <br>FLOAT Counter_Bulk(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Counter_Common(pLineStruct, BULK) ; <br>} <br>#endif <br> <br> <br>/***************************************************************************** <br> * Counter_Timer100Ns - <br> * <br> *      Need to review with RussBl exactly what he is doing here. <br> ****************************************************************************/ <br>#define Counter_Timer100Ns(pLineStruct)     \ <br>        Counter_Timer_Common(pLineStruct, NS100) <br>#if 0 <br>FLOAT Counter_Timer100Ns(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, NS100) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Timer100Ns_Inv - <br> * <br> *      Need to review with RussBl exactly what he is doing here. <br> ****************************************************************************/ <br>#define Counter_Timer100Ns_Inv(pLineStruct)     \ <br>        Counter_Timer_Common(pLineStruct, NS100_INVERT) <br>#if 0 <br>FLOAT Counter_Timer100Ns_Inv(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, NS100_INVERT) ; <br> <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Timer_Multi - <br> * <br> *      Need to review with RussBl exactly what he is doing here. <br> ****************************************************************************/ <br>#define Counter_Timer_Multi(pLineStruct)     \ <br>        Counter_Timer_Common(pLineStruct, TIMER_MULTI) <br>#if 0 <br>FLOAT Counter_Timer_Multi(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, TIMER_MULTI) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Timer_Multi_Inv - <br> * <br> *      Need to review with RussBl exactly what he is doing here. <br> ****************************************************************************/ <br>#define Counter_Timer_Multi_Inv(pLineStruct)       \ <br>        Counter_Timer_Common(pLineStruct, TIMER_MULTI_INVERT) <br>#if 0 <br>FLOAT Counter_Timer_Multi_Inv(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, TIMER_MULTI_INVERT) ; <br>} <br>#endif <br> <br> <br>/***************************************************************************** <br> * Counter_Timer100Ns_Multi - <br> * <br> *      Need to review with RussBl exactly what he is doing here. <br> ****************************************************************************/ <br>#define Counter_Timer100Ns_Multi(pLineStruct)     \ <br>        Counter_Timer_Common(pLineStruct, NS100_MULTI) <br>#if 0 <br>FLOAT Counter_Timer100Ns_Multi(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, NS100_MULTI) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Timer100Ns_Multi_Inv - <br> * <br> *      Need to review with RussBl exactly what he is doing here. <br> ****************************************************************************/ <br>#define Counter_Timer100Ns_Multi_Inv(pLineStruct)    \ <br>        Counter_Timer_Common(pLineStruct, NS100_MULTI_INVERT) <br>#if 0 <br>FLOAT Counter_Timer100Ns_Multi_Inv(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, NS100_MULTI_INVERT) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Timer - Take the difference between the current and previous <br> *                 counts, <br> *                 Normalize the count (counts per interval) <br> *                 divide by the time interval (count = % of interval) <br> *                 multiply by 100 (convert to a percentage) <br> *                 this value from 100. <br> ****************************************************************************/ <br>#define Counter_Timer(pLineStruct)       \ <br>        Counter_Timer_Common(pLineStruct, 0) <br>#if 0 <br>FLOAT Counter_Timer(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, 0) ; <br>} <br>#endif <br> <br> <br>/***************************************************************************** <br> * Counter_Timer_Inv - Take the difference between the current and previous <br> *                     counts, <br> *                     Normalize the count (counts per interval) <br> *                     divide by the time interval (count = % of interval) <br> *                     subtract from 1 (the normalized size of an interval) <br> *                     multiply by 100 (convert to a percentage) <br> *                     this value from 100. <br> ****************************************************************************/ <br>#define Counter_Timer_Inv(pLineStruct)         \ <br>      Counter_Timer_Common(pLineStruct, INVERT) <br>#if 0 <br>FLOAT Counter_Timer_Inv(PLINESTRUCT pLineStruct) <br>{ <br>        return Counter_Timer_Common(pLineStruct, INVERT) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Sample_Counter - <br> ****************************************************************************/ <br>#define Sample_Counter(pLineStruct)      \ <br>      Sample_Common(pLineStruct, 0) <br>#if 0 <br>FLOAT Sample_Counter(PLINESTRUCT pLineStruct) <br>{ <br>        return Sample_Common(pLineStruct, 0) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Sample_Fraction - <br> ****************************************************************************/ <br>#define Sample_Fraction(pLineStruct)     \ <br>     Sample_Common(pLineStruct, FRACTION) <br>#if 0 <br>FLOAT Sample_Fraction(PLINESTRUCT pLineStruct) <br>{ <br>        return Sample_Common(pLineStruct, FRACTION) ; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Rawcount - This is just a raw count. <br> ****************************************************************************/ <br>#define Counter_Rawcount(pLineStruct)     \ <br>   ((FLOAT) ((DWORD) (pLineStruct-&gt;lnaCounterValue[0]))) <br>#if 0 <br>FLOAT Counter_Rawcount(PLINESTRUCT pLineStruct) <br>   { <br>   return((FLOAT) (pLineStruct-&gt;lnaCounterValue[0])) ; <br>   } <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Large_Rawcount - This is just a raw count. <br> ****************************************************************************/ <br>#define Counter_Large_Rawcount(pLineStruct)     \ <br>   ((FLOAT) (pLineStruct-&gt;lnaCounterValue[0])) <br> <br>/***************************************************************************** <br> * Counter_Elapsed_Time - <br> ****************************************************************************/ <br>#define Counter_Elapsed_Time(pLineStruct)         \ <br>    eElapsedTime (pLineStruct, 0) <br>#if 0 <br>FLOAT Counter_Elapsed_Time (PLINESTRUCT pLineStruct) <br>{ <br>    return eElapsedTime (pLineStruct, 0); <br>} <br>#endif <br> <br>/***************************************************************************** <br> * Counter_Null - The counters that return nothing go here. <br> ****************************************************************************/ <br>#define Counter_Null(pline)        \ <br>        ((FLOAT) 0.0) <br>#if 0 <br>FLOAT Counter_Null(PLINESTRUCT pline) <br>{ <br>        return((FLOAT) 0.0); <br>        pline; <br>} <br>#endif <br> <br>  <br>FLOAT <br>CounterEntry ( <br>    PLINESTRUCT pLine <br>) <br>{ <br>    switch (pLine-&gt;lnCounterType) { <br>        case  PERF_COUNTER_COUNTER: <br>            return Counter_Counter (pLine); <br> <br>        case  PERF_COUNTER_TIMER: <br>            return Counter_Timer (pLine); <br> <br>        case  PERF_COUNTER_QUEUELEN_TYPE: <br>            return Counter_Queuelen(pLine); <br> <br>        case  PERF_COUNTER_BULK_COUNT: <br>            return Counter_Bulk (pLine); <br> <br>        case  PERF_COUNTER_TEXT: <br>            return Counter_Null (pLine); <br> <br>        case  PERF_COUNTER_RAWCOUNT: <br>        case  PERF_COUNTER_RAWCOUNT_HEX: <br>            return Counter_Rawcount(pLine); <br> <br>        case  PERF_COUNTER_LARGE_RAWCOUNT: <br>        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX: <br>            return Counter_Large_Rawcount(pLine); <br> <br>        case  PERF_SAMPLE_FRACTION: <br>            return Sample_Fraction(pLine); <br> <br>        case  PERF_SAMPLE_COUNTER: <br>            return Sample_Counter (pLine); <br> <br>        case  PERF_COUNTER_NODATA: <br>            return Counter_Null (pLine); <br> <br>        case  PERF_COUNTER_TIMER_INV: <br>            return Counter_Timer_Inv (pLine); <br> <br>        case  PERF_RAW_BASE: <br>//      case  PERF_SAMPLE_BASE: <br>//      case  PERF_AVERAGE_BASE: <br>            return Counter_Null (pLine); <br> <br>        case  PERF_AVERAGE_TIMER: <br>            return Counter_Average_Timer (pLine); <br> <br>        case  PERF_AVERAGE_BULK: <br>            return Counter_Average_Bulk (pLine); <br> <br>        case  PERF_100NSEC_TIMER: <br>            return Counter_Timer100Ns (pLine); <br> <br>        case  PERF_100NSEC_TIMER_INV: <br>            return Counter_Timer100Ns_Inv (pLine); <br> <br>        case  PERF_COUNTER_MULTI_TIMER: <br>            return Counter_Timer_Multi (pLine); <br> <br>        case  PERF_COUNTER_MULTI_TIMER_INV: <br>            return Counter_Timer_Multi_Inv (pLine); <br> <br>        case  PERF_COUNTER_MULTI_BASE: <br>            return Counter_Null (pLine); <br> <br>        case  PERF_100NSEC_MULTI_TIMER: <br>            return Counter_Timer100Ns_Multi (pLine); <br>                  <br>        case  PERF_100NSEC_MULTI_TIMER_INV: <br>            return Counter_Timer100Ns_Multi_Inv (pLine); <br> <br>        case  PERF_RAW_FRACTION: <br>            return Counter_Raw_Fraction (pLine); <br> <br>        case  PERF_ELAPSED_TIME: <br>            return Counter_Elapsed_Time (pLine); <br>            <br>        default: <br>            return Counter_Null (pLine); <br> <br>    } <br>} <br> <br>  <br>BOOL <br>IsCounterSupported ( <br>    DWORD dwCounterType <br>) <br>{ <br>    switch (dwCounterType) { <br>// supported counters <br>        case  PERF_COUNTER_COUNTER: <br>        case  PERF_COUNTER_TIMER: <br>        case  PERF_COUNTER_QUEUELEN_TYPE: <br>        case  PERF_COUNTER_BULK_COUNT: <br>        case  PERF_COUNTER_RAWCOUNT: <br>        case  PERF_COUNTER_RAWCOUNT_HEX: <br>        case  PERF_COUNTER_LARGE_RAWCOUNT: <br>        case  PERF_COUNTER_LARGE_RAWCOUNT_HEX: <br>        case  PERF_SAMPLE_FRACTION: <br>        case  PERF_SAMPLE_COUNTER: <br>        case  PERF_COUNTER_TIMER_INV: <br>        case  PERF_AVERAGE_TIMER: <br>        case  PERF_AVERAGE_BULK: <br>        case  PERF_100NSEC_TIMER: <br>        case  PERF_100NSEC_TIMER_INV: <br>        case  PERF_COUNTER_MULTI_TIMER: <br>        case  PERF_COUNTER_MULTI_TIMER_INV: <br>        case  PERF_100NSEC_MULTI_TIMER: <br>        case  PERF_100NSEC_MULTI_TIMER_INV: <br>        case  PERF_RAW_FRACTION: <br>        case  PERF_ELAPSED_TIME: <br>            return TRUE; <br> <br>// unsupported counters <br>        case  PERF_COUNTER_TEXT: <br>        case  PERF_COUNTER_NODATA: <br>        case  PERF_RAW_BASE: <br>//      case  PERF_SAMPLE_BASE: <br>//      case  PERF_AVERAGE_BASE: <br>        case  PERF_COUNTER_MULTI_BASE: <br>        default: <br>            return FALSE; <br> <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
