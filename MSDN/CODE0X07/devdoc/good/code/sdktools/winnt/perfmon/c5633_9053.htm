<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ALERT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5637"></a>ALERT.C</h2>
<pre><code>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br>#include &lt;stdio.h&gt; <br>#include "perfmon.h" <br>#include "alert.h"         // External declarations for this file <br> <br>#include "addline.h"       // for AddLine <br>#include "fileutil.h"      // for FileRead <br>#include "legend.h" <br>#include "line.h" <br>#include "pmemory.h"       // for MemoryXXX (mallloc-type) routines <br>#include "owndraw.h"       // for OwnerDraw macros <br>#include "perfdata.h"      // for UpdateLines <br>#include "perfmops.h"      // for SystemAdd <br>#include "playback.h"      // for PlaybackLines <br>#include "status.h"        // for StatusUpdateAlerts    <br>#include "system.h"        // for SystemGet <br>#include "utils.h" <br>#include "menuids.h"       // for IDM_VIEWALERT <br>#include "fileopen.h"      // for FileGetName <br>#include "counters.h"      // for CounterEntry <br> <br>#include &lt;lmcons.h&gt; <br>#include &lt;lmmsg.h&gt; <br>#include &lt;lmerr.h&gt; <br> <br> <br>#define MSG_ALERT_OCCURRED               ((DWORD)0x400007D0L) <br>#define MSG_ALERT_SYSTEM                 ((DWORD)0x400007D1L) <br> <br> <br>#define WM_SEND_NETWORK_ALERT (WM_USER + 101) <br> <br>//==========================================================================// <br>//                                  Typedefs                                // <br>//==========================================================================// <br> <br>typedef NET_API_STATUS <br>(*pNetMessageBufferSend) ( <br>    IN  LPTSTR  servername, <br>    IN  LPTSTR  msgname, <br>    IN  LPTSTR  fromname, <br>    IN  LPBYTE  buf, <br>    IN  DWORD   buflen <br>    ); <br> <br>typedef struct ALERTENTRYSTRUCT <br>   { <br>   SYSTEMTIME     SystemTime ; <br>   PLINE          pLine ; <br>   FLOAT          eValue ; <br>   BOOL           bOver ; <br>   FLOAT          eAlertValue ; <br>   LPTSTR         lpszInstance ; <br>   LPTSTR         lpszParent ; <br>   INT            StringWidth ; <br>   } ALERTENTRY ; <br> <br>typedef ALERTENTRY *PALERTENTRY ; <br> <br>static HBRUSH  hRedBrush ; <br> <br>//==== <br>//==== <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br> <br>#define szNumberFormat         TEXT("%12.3f") <br>#define szMediumnNumberFormat  TEXT("%12.0f") <br>#define szLargeNumberFormat    TEXT("%12.4e") <br>#define eNumber                ((FLOAT) 99999999.999) <br>#define eLargeNumber           ((FLOAT) 999999999999.0) <br> <br>#define szNumberPrototype        TEXT("99999999.999") <br> <br> <br>#define szConditionFormat        TEXT("  %c  ") <br>#define szConditionPrototype     TEXT("  &gt;  ") <br> <br>#define szDatePrototype          TEXT("12/31/1999   ") <br>#define szTimePrototype          TEXT("12:34:56.9 pm  ") <br> <br>#define ALERTLOGMAXITEMS         1000 <br> <br>#define szAlertFormat TEXT("%s %s %s %c %s %s,  %s,  %s,  %s,  %s") <br> <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br>#define AlertItemTopMargin()     (yBorderHeight) <br> <br> <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br>INT ExportAlertLine (PLINE pLine, FLOAT eValue, SYSTEMTIME *pSystemTime, HANDLE hExportFile) ; <br> <br>#if 0 <br>PALERT AlertData (HWND hWndAlert) <br>   { <br>   return (&amp;Alert) ; <br>   } <br>#endif <br> <br>void AlertFormatFloat (LPTSTR lpValueBuf, FLOAT eValue) <br>   { <br>   if (eValue &lt;= eNumber) <br>      { <br>      TSPRINTF (lpValueBuf, szNumberFormat, eValue) ; <br>      } <br>   else if (eValue &lt;= eLargeNumber) <br>      { <br>      TSPRINTF (lpValueBuf, szMediumnNumberFormat, eValue) ; <br>      } <br>   else <br>      { <br>      TSPRINTF (lpValueBuf, szLargeNumberFormat, eValue) ; <br>      } <br>   ConvertDecimalPoint (lpValueBuf) ; <br> <br>   }  // AlertFormatFloat <br> <br> <br>PALERT AllocateAlertData (HWND hWndAlert) <br>   { <br>   PALERT           pAlert ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br> <br>   pAlert-&gt;hWnd = hWndAlert ; <br>   pAlert-&gt;hAlertListBox = DialogControl (hWndAlert, IDD_ALERTLOG) ; <br>   pAlert-&gt;iStatus = iPMStatusClosed ; <br>   pAlert-&gt;bManualRefresh = FALSE ; <br>   pAlert-&gt;bModified = FALSE ; <br> <br>   pAlert-&gt;Visual.iColorIndex = 0 ; <br>   pAlert-&gt;Visual.iWidthIndex = -1 ; <br>   pAlert-&gt;Visual.iStyleIndex = -1 ; <br> <br>   pAlert-&gt;iIntervalMSecs = iDefaultAlertIntervalSecs * 1000 ; <br>   pAlert-&gt;pSystemFirst = NULL ; <br>   pAlert-&gt;pLineFirst = NULL ; <br> <br>   pAlert-&gt;MessageName[0] = TEXT('\0') ; <br> <br>   pAlert-&gt;bLegendOn = TRUE ; <br> <br>   return (pAlert) ; <br>   }  // AllocateAlertData <br> <br> <br>void FreeAlertData (PALERT pAlert) <br>   {  // FreeAlertData <br>   }  // FreeAlertData <br> <br> <br>BOOL SetAlertTimer (PALERT pAlert) <br>   { <br>   if (pAlert-&gt;iStatus == iPMStatusCollecting) <br>      KillTimer (pAlert-&gt;hWnd, AlertTimerID) ; <br> <br>   pAlert-&gt;iStatus = iPMStatusCollecting ; <br>   SetTimer (pAlert-&gt;hWnd, AlertTimerID, pAlert-&gt;iIntervalMSecs, NULL) ; <br>   return (TRUE) ; <br>   } <br> <br> <br>BOOL ClearAlertTimer (PALERT pAlert) <br>   {  // ClearAlertTimer <br>   if (!PlayingBackLog()) <br>      { <br>      KillTimer (pAlert-&gt;hWnd, AlertTimerID) ; <br>      } <br>   pAlert-&gt;iStatus = iPMStatusClosed ; <br> <br>   return (TRUE) ; <br>   }  // ClearAlertTimer <br> <br> <br>BOOL AlertExec (LPTSTR lpszImageName, LPTSTR lpszCommandLine) <br>/* <br>   Effect:        WinExec is considered obsolete. We're supposed to use <br>                  CreateProcess, which allows considerably more control. <br>                  For perfmon, we only execute a program when an alert <br>                  occurs, and we really don't know anything about the <br>                  program, so can't really do much.  We just set some <br>                  defaults and go. <br> <br>   Called By:     SignalAlert only. <br>*/ <br>   {  // ExecProcess <br>   STARTUPINFO    si ; <br>   PROCESS_INFORMATION  pi ; <br>   int            StringLen ; <br>   TCHAR          TempBuffer [ 5 * FilePathLen ] ; <br>   BOOL           RetCode; <br> <br>   memset (&amp;si, 0, sizeof (STARTUPINFO)) ; <br>   si.cb = sizeof (STARTUPINFO) ; <br>   si.dwFlags = STARTF_USESHOWWINDOW ; <br>   si.wShowWindow = SW_SHOWNOACTIVATE ; <br>   memset (&amp;pi, 0, sizeof (PROCESS_INFORMATION)) ; <br> <br>   lstrcpy (TempBuffer, lpszImageName) ; <br>   StringLen = lstrlen (TempBuffer) ; <br>   TempBuffer [StringLen] = TEXT(' ') ; <br>   StringLen++ ; <br>   lstrcpy (&amp;TempBuffer[StringLen], lpszCommandLine) ; <br> <br>   // DETACHED_PROCESS is needed to get rid of the ugly console window <br>   // that SQL guys have been bitching.. <br>   RetCode = CreateProcess (NULL, TempBuffer, <br>                          NULL, NULL, FALSE, <br>                          (DWORD) NORMAL_PRIORITY_CLASS, <br>                          NULL, NULL, <br>                          &amp;si, &amp;pi) ; <br>   if (RetCode) <br>      { <br>      if (pi.hProcess &amp;&amp; pi.hProcess != INVALID_HANDLE_VALUE) <br>         { <br>         CloseHandle (pi.hProcess) ; <br>         } <br>      if (pi.hThread &amp;&amp; pi.hThread != INVALID_HANDLE_VALUE) <br>         { <br>         CloseHandle (pi.hThread) ; <br>         } <br>      } <br> <br>   return RetCode ; <br> <br>   }  // ExecProcess <br> <br> <br>BOOL SendNetworkMessage (LPTSTR pText, DWORD TextLen, LPTSTR pMessageName) <br>{ <br>   NET_API_STATUS NetStatus; <br>   HANDLE dllHandle ; <br>   pNetMessageBufferSend SendFunction ; <br> <br>   // <br>   // Dynamically link to netapi32.dll.  If it's not there just return.  Return <br>   // TRUE so we won't try to send this alert again. <br>   // <br> <br>   dllHandle = LoadLibrary(TEXT("NetApi32.Dll")) ; <br>   if ( !dllHandle || dllHandle == INVALID_HANDLE_VALUE ) <br>      { <br>      return(TRUE) ; <br>      } <br> <br>   // <br>   // Get the address of the service's main entry point.  This <br>   // entry point has a well-known name. <br>   // <br> <br>   SendFunction = (pNetMessageBufferSend)GetProcAddress( <br>      dllHandle, "NetMessageBufferSend") ; <br> <br>   if (SendFunction == NULL) <br>      { <br>      FreeLibrary (dllHandle) ; <br>      return(TRUE) ; <br>      } <br> <br>   NetStatus = (*SendFunction) (NULL, pMessageName, <br>      NULL, (LPBYTE)pText, TextLen * sizeof(TCHAR)) ; <br>   if (NetStatus != NERR_Success) <br>      { <br>      FreeLibrary (dllHandle) ; <br>      return (FALSE) ; <br>      } <br> <br>   FreeLibrary (dllHandle) ; <br> <br>   return (TRUE) ;    <br>} <br> <br> <br>// this is the child thread used to send out network alert message. <br>// This thread is created at init time and is destroyed at close time <br>void NetAlertHandler (LPVOID *pDummy) <br>   { <br>   MSG      msg; <br> <br>   while (GetMessage (&amp;msg, NULL, 0, 0)) <br>      { <br>      // we are only interested in this message <br>      if (LOWORD(msg.message) == WM_SEND_NETWORK_ALERT) <br>         { <br>         SendNetworkMessage ((LPTSTR)(msg.wParam), <br>            lstrlen ((LPTSTR)(msg.wParam)), <br>            (LPTSTR)(msg.lParam)) ; <br>         MemoryFree ((LPTSTR)(msg.wParam)) ; <br>         } <br>      } <br>   }  // NetAlertHandler <br> <br> <br>void SignalAlert (HWND hWnd, <br>                  HWND hWndAlerts, <br>                  PLINE pLine, <br>                  FLOAT eValue, <br>                  SYSTEMTIME *pSystemTime, <br>                  LPTSTR pSystemName, <br>                  DWORD dwSystemState) <br>/* <br>   Effect:        Perform any actions necessary when a given alert line's <br>                  condition is true. In particular, add the alert to the <br>                  alert log. Also, depending on the user's wishes, signal <br>                  a network alert or beep or run a program. <br> <br>                  If we are not viewing the alert screen, add one alert to  <br>                  the unviewed list. <br>*/ <br>   { <br>   int            iIndex ; <br>   PALERT         pAlert ; <br>   PALERTENTRY    pAlertEntry ; <br>   TCHAR          szTime [20] ; <br>   TCHAR          szDate [20] ; <br>   TCHAR          szInstance [256] ; <br>   TCHAR          szParent [256] ; <br>   TCHAR          szText [256 * 4] ; <br>   TCHAR          eValueBuf [40] ; <br>   TCHAR          eAlertValueBuf [40] ; <br>   TCHAR          eAlertValueBuf1 [42] ; <br>   FLOAT          eLocalValue ; <br>   DWORD          TextSize ; <br>   LPTSTR         lpAlertMsg ; <br>   LPTSTR         lpEventLog[7] ; <br>   TCHAR          NullBuff [2] ; <br> <br>   NullBuff [0] = NullBuff [1] = TEXT('\0') ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   pAlertEntry = MemoryAllocate (sizeof (ALERTENTRY)) ; <br>   if (!pAlertEntry) <br>      { <br>      return ; <br>      } <br>   pAlertEntry-&gt;SystemTime = *pSystemTime ; <br>   pAlertEntry-&gt;pLine= pLine ; <br>   pAlertEntry-&gt;eValue = eValue ; <br>   if (pLine) <br>      { <br>      pAlertEntry-&gt;bOver = pLine-&gt;bAlertOver ; <br>      pAlertEntry-&gt;eAlertValue = pLine-&gt;eAlertValue ; <br>      } <br> <br> <br>   //=============================// <br>   // Determine Instance, Parent  // <br>   //=============================// <br> <br>   // It's possible that there will be no instance, therefore <br>   // the lnInstanceName would be NULL. <br> <br>   if (pLine &amp;&amp; pLine-&gt;lnObject.NumInstances &gt; 0) <br>      { <br>      // Test for the parent object instance name title index. <br>      // If there is one, it implies that there will be a valid <br>      // Parent Object Name and a valid Parent Object Instance Name. <br> <br>      // If the Parent Object title index is 0 then <br>      // just display the instance name. <br> <br>      lstrcpy (szInstance, pLine-&gt;lnInstanceName) ; <br>      if (pLine-&gt;lnInstanceDef.ParentObjectTitleIndex &amp;&amp; pLine-&gt;lnPINName) <br>         { <br>         // Get the Parent Object Name. <br>         lstrcpy (szParent, pLine-&gt;lnPINName) ; <br>         } <br>      else <br>         { <br>         szParent[0] = TEXT(' ') ; <br>         szParent[1] = TEXT('\0') ; <br>         } <br>      } <br>   else <br>      { <br>      if (pLine) <br>         { <br>         szInstance[0] = TEXT(' ') ; <br>         szInstance[1] = TEXT('\0') ; <br>         szParent[0] = TEXT(' ') ; <br>         szParent[1] = TEXT('\0') ; <br>         } <br>      else <br>         { <br>         // this is a system down/reconnect alert <br>         StringLoad ( <br>            dwSystemState == SYSTEM_DOWN ? <br>               IDS_SYSTEM_DOWN : IDS_SYSTEM_UP, <br>            szInstance) ; <br>         lstrcpy (szParent, pSystemName) ; <br>         } <br>      } <br> <br> <br>   pAlertEntry-&gt;lpszInstance = StringAllocate (szInstance) ; <br>   pAlertEntry-&gt;lpszParent = StringAllocate (szParent) ; <br>    <br>   //=============================// <br>   // Add alert to Alert Log      // <br>   //=============================// <br> <br>   if (LBNumItems (hWndAlerts) &gt;= ALERTLOGMAXITEMS) <br>      LBDelete (hWndAlerts, 0) ; <br> <br>   iIndex = LBAdd (hWndAlerts, (LPARAM) pAlertEntry) ; <br>   LBSetSelection (hWndAlerts, iIndex) ; <br> <br>   // no need to check other things if we <br>   // are playing back log <br>   if (PlayingBackLog()) <br>      { <br>      return ; <br>      } <br> <br>   //=============================// <br>   // Update Status Line          // <br>   //=============================// <br> <br>   if (iPerfmonView != IDM_VIEWALERT) <br>      { <br>      if (pAlert-&gt;bSwitchToAlert) <br>         { <br>         SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWALERT, 0L) ; <br>         } <br>      else <br>         { <br>         // if iUnviewedAlerts is over 100, we will display "++" <br>         // so, no need to keep updating the icon... <br>         if (iUnviewedAlerts &lt; 100) <br>            { <br>            iUnviewedAlerts ++ ; <br>            if (pLine) <br>               { <br>               crLastUnviewedAlert = pLine-&gt;Visual.crColor ; <br>               } <br>            StatusUpdateIcons (hWndStatus) ; <br>            } <br>         } <br>      } <br> <br>   //===================================// <br>   //  Check if we need to do anything  // <br>   //===================================// <br>   szText[0] = TEXT('\0') ; <br>   if ((pAlert-&gt;bNetworkAlert &amp;&amp; pAlert-&gt;MessageName[0]) <br>               || <br>       (pLine) &amp;&amp; <br>       (pLine-&gt;lpszAlertProgram &amp;&amp; <br>       (pLine-&gt;bEveryTime || !pLine-&gt;bAlerted)) <br>               || <br>       (pAlert-&gt;bEventLog)) <br>      { <br>      // format the alert line to be exported <br>      SystemTimeDateString (pSystemTime, szDate) ; <br>      SystemTimeTimeString (pSystemTime, szTime, TRUE) ; <br> <br>      if (pLine) <br>         { <br>         AlertFormatFloat (eValueBuf, pAlertEntry-&gt;eValue) ; <br> <br>         eLocalValue = pAlertEntry-&gt;eAlertValue ; <br>         if (eLocalValue &lt; (FLOAT) 0.0) <br>            { <br>            eLocalValue = -eLocalValue ; <br>            } <br>         AlertFormatFloat (eAlertValueBuf, pAlertEntry-&gt;eAlertValue) ; <br> <br>         TSPRINTF (szText, <br>            szAlertFormat, <br>            szDate, <br>            szTime, <br>            eValueBuf, <br>            (pLine-&gt;bAlertOver ? TEXT('&gt;') : TEXT('&lt;')), <br>            eAlertValueBuf, <br>            pLine-&gt;lnCounterName, <br>            szInstance, <br>            szParent, <br>            pLine-&gt;lnObjectName, <br>            pLine-&gt;lnSystemName) ; <br>         } <br>      else <br>         { <br>         lstrcpy (eValueBuf, DashLine) ; <br>         lstrcpy (eAlertValueBuf, eValueBuf) ; <br>         TSPRINTF (szText, <br>            szAlertFormat, <br>            szDate, <br>            szTime, <br>            eValueBuf, <br>            TEXT(' '), <br>            eAlertValueBuf, <br>            szInstance,             // system up/down message <br>            NullBuff, <br>            NullBuff, <br>            NullBuff, <br>            szParent) ; <br>         } <br> <br>      TextSize = sizeof(TCHAR) * (lstrlen(szText)+1) ; <br>      } <br> <br>   if (szText[0] == TEXT('\0')) <br>      { <br>      // nothing to do <br>      return ; <br>      } <br> <br>   //=============================// <br>   // Network Alert?              // <br>   //=============================// <br> <br>   SetHourglassCursor() ; <br> <br>   if (pAlert-&gt;bNetworkAlert &amp;&amp; pAlert-&gt;MessageName[0]) <br>      {  // if <br> <br>      if (pAlert-&gt;dwNetAlertThreadID) <br>         { <br>         // use thread to send the network alert. <br>         // the memory will be released by the child thread when done <br>         lpAlertMsg = <br>            (LPTSTR) MemoryAllocate (TextSize) ; <br>         if (lpAlertMsg) <br>            { <br>            lstrcpy (lpAlertMsg, szText) ; <br>            PostThreadMessage (pAlert-&gt;dwNetAlertThreadID, <br>               WM_SEND_NETWORK_ALERT, <br>               (WPARAM)lpAlertMsg, <br>               (LPARAM)pAlert-&gt;MessageName) ; <br>            } <br>         } <br>      else <br>         { <br>         // no thread available, use the slow way to send the network alert <br>         SendNetworkMessage (szText, <br>            (DWORD) lstrlen(szText), <br>            pAlert-&gt;MessageName) ; <br>         } <br>      } <br> <br> <br>   //=============================// <br>   // Run Program?                // <br>   //=============================// <br> <br>   if (pLine &amp;&amp; <br>       pLine-&gt;lpszAlertProgram &amp;&amp; <br>       (pLine-&gt;bEveryTime || !pLine-&gt;bAlerted)) <br>      { <br>      AlertExec (pLine-&gt;lpszAlertProgram, szText) ; <br>      pLine-&gt;bAlerted = TRUE ; <br>      } <br> <br>   //===================================// <br>   // Log event to Application Log?     // <br>   //===================================// <br>   if (pAlert-&gt;bEventLog) <br>      { <br>      if (hEventLog) <br>         { <br>         if (pLine) <br>            { <br>            lpEventLog[0] = pLine-&gt;lnSystemName ; <br>            lpEventLog[1] = pLine-&gt;lnObjectName ; <br>            lpEventLog[2] = pLine-&gt;lnCounterName ; <br>            lpEventLog[3] = szInstance ; <br>            lpEventLog[4] = szParent ; <br>            lpEventLog[5] = eValueBuf ; <br>            eAlertValueBuf1[0] = pLine-&gt;bAlertOver ? TEXT('&gt;') : TEXT('&lt;') ; <br>            eAlertValueBuf1[1] = TEXT(' ') ; <br>            lstrcpy (&amp;eAlertValueBuf1[2], eAlertValueBuf) ; <br>            lpEventLog[6] = eAlertValueBuf1 ; <br>            } <br>         else <br>            { <br>            lpEventLog[0] = szParent ; <br>            lpEventLog[1] = szInstance ; <br>            } <br> <br>         ReportEvent (hEventLog, <br>            (WORD)EVENTLOG_INFORMATION_TYPE, <br>            (WORD)0, <br>            (DWORD) (pLine ? MSG_ALERT_OCCURRED : MSG_ALERT_SYSTEM), <br>            (PSID)NULL, <br>            (WORD) (pLine ? 7 : 2), <br>            (DWORD)TextSize, <br>            (LPCTSTR *)lpEventLog, <br>            (LPVOID)(szText)) ; <br>         } <br>      } <br>     <br>   SetArrowCursor() ; <br> <br>   }  // SignalAlert <br> <br> <br> <br>BOOL AlertCondition (PLINE pLine, FLOAT eValue) <br>/* <br>   Effect:        Return whether the alert test passed for line pLine, <br>                  with current data value eValue. <br> <br>   Internals:     Don't *ever* say (bFoo == bBar), as non-FALSE values <br>                  could be represented by any nonzero number.  Use <br>                  BoolEqual or equivalent. <br>*/ <br>   {  // AlertCondition <br>   BOOL           bOver ; <br> <br>   bOver = eValue &gt; pLine-&gt;eAlertValue ; <br> <br>   return (BoolEqual (bOver, pLine-&gt;bAlertOver)) ; <br>   }  // AlertCondition <br> <br> <br>INT static CheckAlerts (HWND hWnd, <br>                        HWND hWndAlerts, <br>                        SYSTEMTIME *pSystemTime, <br>                        PLINE pLineFirst, <br>                        HANDLE hExportFile, <br>                        PPERFSYSTEM pSystemFirst) <br>   {  // CheckAlerts <br>   FLOAT          eValue ; <br>   PLINE          pLine ; <br>   BOOL           bAnyAlerts ; <br>   INT            ErrCode = 0 ; <br>   PPERFSYSTEM    pSystem ; <br> <br>   bAnyAlerts = FALSE ; <br>   if (!PlayingBackLog()) <br>      { <br>      LBSetRedraw (hWndAlerts, FALSE) ; <br> <br>      // check for system up/down <br>      for (pSystem = pSystemFirst ; <br>         pSystem ; <br>         pSystem = pSystem-&gt;pSystemNext) <br>         { <br>         if (pSystem-&gt;dwSystemState == SYSTEM_DOWN) <br>            { <br>            pSystem-&gt;dwSystemState = SYSTEM_DOWN_RPT ; <br>            SignalAlert (hWnd, <br>               hWndAlerts, <br>               NULL, <br>               (FLOAT) 0.0, <br>               pSystemTime, <br>               pSystem-&gt;sysName, <br>               SYSTEM_DOWN) ; <br>            } <br>         else if (pSystem-&gt;dwSystemState == SYSTEM_RECONNECT) <br>            { <br>            pSystem-&gt;dwSystemState = SYSTEM_RECONNECT_RPT ; <br>            SignalAlert (hWnd, <br>               hWndAlerts, <br>               NULL, <br>               (FLOAT) 0.0, <br>               pSystemTime, <br>               pSystem-&gt;sysName, <br>               SYSTEM_RECONNECT) ; <br>            } <br>         } <br>      }  // !PlayingBackLog() <br> <br> <br>   for (pLine = pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      { <br>      if (pLine-&gt;bFirstTime) <br>         { <br>         // skip until we have collect enough samples for the first data <br>         continue ; <br>         } <br> <br>      // Get the new value for this line. <br>      eValue = CounterEntry (pLine) ; <br>      if (AlertCondition (pLine, eValue)) <br>         { <br>         bAnyAlerts = TRUE ; <br> <br>         // the case that hExportFile is !NULL is when playingback log and that the <br>         // listbox is overflowed with alert.  In this case, we have to <br>         // walk the log file again to re-generate all the alerts. <br>         if (hExportFile) <br>            { <br>            ErrCode = ExportAlertLine (pLine, eValue, pSystemTime, hExportFile) ; <br>            if (ErrCode) <br>               { <br>               break ; <br>               } <br>            } <br>         else <br>            { <br>            SignalAlert (hWnd, <br>               hWndAlerts, <br>               pLine, <br>               eValue, <br>               pSystemTime, <br>               NULL, <br>               0) ; <br>            } <br>         } <br>      }  // for <br> <br>   if (!PlayingBackLog()) <br>      { <br>      LBSetRedraw (hWndAlerts, TRUE) ; <br>      } <br> <br>   return (ErrCode) ; <br>   }  // CheckAlerts <br> <br> <br> <br> <br>void DrawAlertEntry (HWND hWnd, <br>                     PALERT pAlert, <br>                     PALERTENTRY pAlertEntry, <br>                     LPDRAWITEMSTRUCT lpDI, <br>                     HDC hDC) <br>   {  // DrawAlertEntry <br>   PLINE          pLine ; <br>   RECT           rectUpdate ; <br> <br>   TCHAR          szTime [20] ; <br>   TCHAR          szDate [20] ; <br>   TCHAR          szText [256] ; <br> <br>   HBRUSH         hBrushPrevious ; <br>   FLOAT          eLocalValue ; <br>   COLORREF       preBkColor ; <br>   COLORREF       preTextColor ; <br> <br>   pLine = pAlertEntry-&gt;pLine ; <br> <br>   SystemTimeDateString (&amp;(pAlertEntry-&gt;SystemTime), szDate) ; <br>   SystemTimeTimeString (&amp;(pAlertEntry-&gt;SystemTime), szTime, TRUE) ; <br> <br>   if (DISelected (lpDI))  <br>      {  // if <br>      preTextColor = SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)) ; <br>      preBkColor = SetBkColor (hDC, GetSysColor (COLOR_HIGHLIGHT)) ; <br>      }  // if <br> <br>   //=============================// <br>   // Draw Color Dot              // <br>   //=============================// <br> <br>   rectUpdate.left = 0 ; <br>   rectUpdate.top = lpDI-&gt;rcItem.top ; <br>   rectUpdate.right = pAlert-&gt;xColorWidth ; <br>   rectUpdate.bottom = lpDI-&gt;rcItem.bottom ; <br> <br>   ExtTextOut (hDC, rectUpdate.left, rectUpdate.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               NULL, 0, <br>               NULL) ; <br> <br>   if (pLine) <br>      { <br>      hBrushPrevious = SelectBrush (hDC, pLine-&gt;hBrush) ; <br>      } <br>   else <br>      { <br>      if (hRedBrush == NULL) <br>         { <br>         hRedBrush = CreateSolidBrush (RGB (0xff, 0x00, 0x00)) ; <br>         } <br>      hBrushPrevious = SelectBrush (hDC, hRedBrush) ; <br>      } <br> <br>   Ellipse (hDC, <br>            rectUpdate.left + 2, <br>            rectUpdate.top + 2, <br>            rectUpdate.right - 2, <br>            rectUpdate.bottom - 2) ; <br> <br>   SelectBrush (hDC, hBrushPrevious) ; <br> <br>   //=============================// <br>   // Draw Date                   // <br>   //=============================// <br> <br>   rectUpdate.left = rectUpdate.right ; <br>   rectUpdate.right = rectUpdate.left + pAlert-&gt;xDateWidth ; <br> <br>   ExtTextOut (hDC, rectUpdate.left, rectUpdate.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               szDate, lstrlen (szDate), <br>               NULL) ; <br> <br>   //=============================// <br>   // Draw Time                   // <br>   //=============================// <br> <br>   rectUpdate.left = rectUpdate.right ; <br>   rectUpdate.right = rectUpdate.left + pAlert-&gt;xTimeWidth ; <br> <br>   ExtTextOut (hDC, rectUpdate.left, rectUpdate.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               szTime, lstrlen (szTime), <br>               NULL) ; <br> <br>   //=============================// <br>   // Draw Alert Value            // <br>   //=============================// <br> <br>   SetTextAlign (hDC, TA_RIGHT) ; <br> <br>   rectUpdate.left = rectUpdate.right ; <br>   rectUpdate.right = rectUpdate.left + pAlert-&gt;xNumberWidth ; <br> <br>   if (pLine) <br>      { <br>      AlertFormatFloat (szText, pAlertEntry-&gt;eValue) ; <br>      } <br>   else <br>      { <br>      lstrcpy (szText, DashLine) ; <br>      } <br> <br>   ExtTextOut (hDC, rectUpdate.right, rectUpdate.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               szText, lstrlen (szText), <br>               NULL) ; <br> <br>   //=============================// <br>   // Draw Alert Condition        // <br>   //=============================// <br> <br>   rectUpdate.left = rectUpdate.right ; <br>   rectUpdate.right = rectUpdate.left + pAlert-&gt;xConditionWidth ; <br> <br>   TSPRINTF (szText, szConditionFormat, <br>      pLine ? <br>         (pAlertEntry-&gt;bOver ? TEXT('&gt;') : TEXT('&lt;')) : <br>         TEXT(' ') <br>      ) ; <br> <br>   ExtTextOut (hDC, rectUpdate.right, rectUpdate.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               szText, lstrlen (szText), <br>               NULL) ; <br> <br>   //=============================// <br>   // Draw Trigger Value          // <br>   //=============================// <br> <br>   rectUpdate.left = rectUpdate.right ; <br>   rectUpdate.right = rectUpdate.left + pAlert-&gt;xNumberWidth ; <br> <br>   if (pLine) <br>      { <br>      eLocalValue = pAlertEntry-&gt;eAlertValue ; <br>      if (eLocalValue &lt; (FLOAT) 0.0) <br>         { <br>         eLocalValue = -eLocalValue ; <br>         } <br>      AlertFormatFloat (szText, pAlertEntry-&gt;eAlertValue) ; <br>      } <br>   else <br>      { <br>      lstrcpy (szText, DashLine) ; <br>      } <br> <br>   ExtTextOut (hDC, rectUpdate.right, rectUpdate.top, <br>               ETO_CLIPPED | ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               szText, lstrlen (szText), <br>               NULL) ; <br> <br>   //=============================// <br>   // Draw Rest                   // <br>   //=============================// <br> <br>   SetTextAlign (hDC, TA_LEFT) ; <br> <br>   rectUpdate.left = rectUpdate.right ; <br>   rectUpdate.right = 10000 ; <br> <br>   if (pLine) <br>      { <br>      TSPRINTF (szText, <br>         TEXT("    %s,  %s,  %s,  %s,  %s"), <br>         pLine-&gt;lnCounterName, <br>         pAlertEntry-&gt;lpszInstance, <br>         pAlertEntry-&gt;lpszParent, <br>         pLine-&gt;lnObjectName, <br>         pLine-&gt;lnSystemName) ; <br>      } <br>   else <br>      { <br>      TSPRINTF (szText, <br>         TEXT("    %s, , , ,  %s"), <br>         pAlertEntry-&gt;lpszInstance, <br>         pAlertEntry-&gt;lpszParent) ; <br>      } <br> <br>   ExtTextOut (hDC, rectUpdate.left, rectUpdate.top, <br>               ETO_OPAQUE, <br>               &amp;rectUpdate, <br>               szText, lstrlen (szText), <br>               NULL) ; <br> <br>   // check if we need to bring-up or resize the horiz scrollbar <br>   if (pAlertEntry-&gt;StringWidth == 0) <br>      { <br>      pAlertEntry-&gt;StringWidth = TextWidth (hDC, szText) + xScrollWidth + <br>                  rectUpdate.left ; <br>      } <br> <br>   if (pAlertEntry-&gt;StringWidth &gt; pAlert-&gt;xTextExtent) <br>      { <br>      pAlert-&gt;xTextExtent = pAlertEntry-&gt;StringWidth ; <br>      LBSetHorzExtent (pAlert-&gt;hAlertListBox, pAlertEntry-&gt;StringWidth) ; <br>      } <br> <br>   if (DISelected (lpDI)) <br>      {  // if <br>      preTextColor = SetTextColor (hDC, preTextColor) ; <br>      preBkColor = SetBkColor (hDC, preBkColor) ; <br>      }  // if <br>   }  // DrawAlertEntry <br> <br> <br> <br>//==========================================================================// <br>//                              Message Handlers                            // <br>//==========================================================================// <br> <br> <br>void static OnDrawItem (HWND hWnd, <br>                        LPDRAWITEMSTRUCT lpDI) <br>   {  // OnDrawItem <br>   HFONT          hFontPrevious ; <br>   HDC            hDC ; <br>   PALERT         pAlert ; <br>   PALERTENTRY    pAlertEntry ; <br>//   PLINESTRUCT    pLine ; <br>   int            iLBIndex ; <br> <br>   hDC = lpDI-&gt;hDC ; <br>   iLBIndex = DIIndex (lpDI) ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   if (iLBIndex == -1) <br>      { <br>      pAlertEntry = NULL ; <br>      } <br>   else <br>      { <br>      pAlertEntry = (PALERTENTRY) LBData (pAlert-&gt;hAlertListBox, iLBIndex) ; <br>      if (pAlertEntry == (PALERTENTRY) LB_ERR) <br>         { <br>         pAlertEntry = NULL ; <br>         } <br>      } <br> <br>   //=============================// <br>   // Draw Legend Item            // <br>   //=============================// <br> <br>   if (pAlertEntry) <br>      { <br>      hFontPrevious = SelectFont (hDC, pAlert-&gt;hFontItems) ; <br>      DrawAlertEntry (hWnd, pAlert, pAlertEntry, lpDI, hDC) ; <br>      SelectFont (hDC, hFontPrevious) ; <br>      } <br> <br>   //=============================// <br>   // Draw Focus                  // <br>   //=============================// <br> <br>   if (DIFocus (lpDI)) <br>      DrawFocusRect (hDC, &amp;(lpDI-&gt;rcItem)) ; <br> <br>   }  // OnDrawItem <br> <br> <br> <br>int static OnCtlColor (HWND hDlg, <br>                       HDC hDC) <br>   { <br>   SetTextColor (hDC, crBlack) ; <br>   SetBkColor (hDC, crLightGray) ; <br>   return ((int) hbLightGray) ; <br>   } <br> <br>void AlertCreateThread (PALERT pAlert) </code></pre>
<p>
</p>
<pre><code>{ <br>   pAlert-&gt;hNetAlertThread = CreateThread(NULL, (DWORD)1024L, <br>      (LPTHREAD_START_ROUTINE)NetAlertHandler, <br>      NULL, (DWORD)0, &amp;(pAlert-&gt;dwNetAlertThreadID)) ; <br> <br>   if (!(pAlert-&gt;hNetAlertThread)) <br>      { <br>      // CreateThread failure, set its ID to zero <br>      // so we will not use the thread <br>      pAlert-&gt;dwNetAlertThreadID = 0 ; <br>      } <br>   else <br>      { <br>      SetThreadPriority (pAlert-&gt;hNetAlertThread, THREAD_PRIORITY_HIGHEST) ; <br>      } <br>   } <br> <br>void static OnInitDialog (HWND hDlg) <br>   { <br>   HDC            hDC ; <br>   PALERT         pAlert ; <br> <br>   iUnviewedAlerts = 0 ; <br> <br>   pAlert = AllocateAlertData (hDlg) ; <br>   if (!pAlert) <br>      return ; <br> <br>   pAlert-&gt;iStatus = iPMStatusClosed ; <br>   pAlert-&gt;hFontItems = hFontScales ; <br> <br>   hDC = GetDC (hDlg) ; <br>   SelectFont (hDC, pAlert-&gt;hFontItems) ; <br> <br>   pAlert-&gt;yItemHeight = FontHeight (hDC, TRUE) + 2 * AlertItemTopMargin () ; <br> <br>   pAlert-&gt;xColorWidth = pAlert-&gt;yItemHeight ; <br>   pAlert-&gt;xDateWidth = TextWidth (hDC, szDatePrototype) ; <br>   pAlert-&gt;xTimeWidth = TextWidth (hDC, szTimePrototype) ; <br>   pAlert-&gt;xNumberWidth = TextWidth (hDC, szNumberPrototype) ; <br>   pAlert-&gt;xConditionWidth = TextWidth (hDC, szConditionPrototype) ; <br> <br>   // no Horz. scroll bar to begin with <br>   pAlert-&gt;xTextExtent = 0 ; <br>   pAlert-&gt;hNetAlertThread = 0; <br>#if 0 <br>   pAlert-&gt;hNetAlertThread = CreateThread(NULL, (DWORD)1024L, <br>      (LPTHREAD_START_ROUTINE)NetAlertHandler, <br>      NULL, (DWORD)0, &amp;(pAlert-&gt;dwNetAlertThreadID)) ; <br> <br>   if (!(pAlert-&gt;hNetAlertThread)) <br>      { <br>      // CreateThread failure, set its ID to zero <br>      // so we will not use the thread <br>      pAlert-&gt;dwNetAlertThreadID = 0 ; <br>      } <br>   else <br>      { <br>      SetThreadPriority (pAlert-&gt;hNetAlertThread, THREAD_PRIORITY_HIGHEST) ; <br>      } <br>#endif <br>   ReleaseDC (hDlg, hDC) ; <br> <br>   hWndAlertLegend = DialogControl (hDlg, IDD_ALERTLEGEND) ; <br>   UpdateAlertDisplay (hDlg) ; <br>   } <br> <br> <br> <br>void static OnMeasureItem (HWND hWnd, <br>                           LPMEASUREITEMSTRUCT lpMI) <br>/* <br>   Note:          Since we have an LB_OWNERDRAWFIXED item in the alert <br>                  dialog, we get this message *before* the WM_INITDIALOG <br>                  message.  Therefore we can't rely on any of the values <br>                  set in that message handler. <br>*/ <br>   {  // OnMeasureItem <br>   HDC            hDC ; <br> <br>   hDC = GetDC (hWnd) ; <br>   SelectFont (hDC, hFontScales) ; <br> <br>   lpMI-&gt;itemHeight = FontHeight (hDC, TRUE) + 2 * AlertItemTopMargin () ; <br> <br>   ReleaseDC (hWnd, hDC) ; <br>   }  // OnMeasureItem <br> <br> <br>void static OnDeleteItem (HDLG hDlg, <br>                          WPARAM wControlID, <br>                          LPDELETEITEMSTRUCT lpDI) <br>   {  // OnDeleteItem <br>   PALERTENTRY    pAlertEntry ; <br> <br>   pAlertEntry = (PALERTENTRY) lpDI-&gt;itemData ; <br> <br>   MemoryFree (pAlertEntry-&gt;lpszParent) ; <br>   MemoryFree (pAlertEntry-&gt;lpszInstance) ; <br> <br>   MemoryFree (pAlertEntry) ; <br>   }  // OnDeleteItem <br> <br> <br> <br>void static OnSize (HWND hDlg, <br>                    int xWidth, <br>                    int yHeight) <br>   {  // OnSize <br>   SizeAlertComponents (hDlg) ; <br>   } <br> <br> <br>void static OnDestroy (HWND hWnd) <br>/* <br>   Effect:        Perform any actions necessary when an AlertDisplay window <br>                  is being destroyed. In particular, free the instance <br>                  data for the log. <br> <br>                  Since we really only have one log window and one global <br>                  log data structure, we don't free the structure. We do, <br>                  however, delete the objects allocated within the structure. <br>*/ <br>   {  // OnDestroy <br>   PALERT           pAlert ; <br> <br>   pAlert = AlertData (hWnd) ; <br>   FreeAlertData (pAlert) ; <br> <br>   if (pAlert-&gt;dwNetAlertThreadID) <br>      { <br>      CloseHandle (pAlert-&gt;hNetAlertThread) ; <br>      } <br>   }  // OnDestroy <br> <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>BOOL AlertInitializeApplication (void) <br>   {  // AlertInitializeApplication <br>   return (TRUE) ; <br>   }  // AlertInitializeApplication <br> <br> <br>int APIENTRY AlertDisplayDlgProc (HWND hDlg, <br>                                  unsigned iMessage, <br>                                  WPARAM wParam, <br>                                  LONG lParam) <br>/* <br>   Note:          This function must be exported in the application's <br>                  linker-definition file, perfmon.def. <br>*/ <br>   {  // AlertDisplayDlgProc <br>//   HDC            hDC ; <br> <br>   switch (iMessage) <br>      { <br>      case WM_CTLCOLORDLG: <br>      case WM_CTLCOLOREDIT: <br>      case WM_CTLCOLORBTN: <br>      case WM_CTLCOLORSTATIC: <br>         return (OnCtlColor (hDlg, (HDC) wParam)) ; <br>         break ; <br> <br>      case WM_DELETEITEM: <br>         OnDeleteItem (hDlg, wParam, (LPDELETEITEMSTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_DRAWITEM: <br>         OnDrawItem (hDlg, (LPDRAWITEMSTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_INITDIALOG: <br>         OnInitDialog (hDlg) ; <br>         break ; <br> <br>      case WM_LBUTTONDOWN: <br>         DoWindowDrag (hDlg, lParam) ; <br>         break ; <br> <br>      case WM_LBUTTONDBLCLK: <br>         SendMessage (hWndMain, WM_LBUTTONDBLCLK, wParam, lParam) ; <br>         break ; <br> <br>      case WM_MEASUREITEM: <br>         OnMeasureItem (hDlg, (LPMEASUREITEMSTRUCT) lParam) ; <br>         break ; <br> <br>      case WM_SIZE: <br>         OnSize (hDlg, LOWORD (lParam), HIWORD (lParam)) ; <br>         break ; <br> <br>      case WM_TIMER: <br>         AlertTimer (hDlg, FALSE) ; <br>         break ; <br> <br>      case WM_DESTROY: <br>         OnDestroy (hDlg) ; <br>         return (FALSE) ; <br>         break ; <br> <br>      default: <br>         return (FALSE) ; <br>      } // switch <br> <br>   return (TRUE) ; <br>   }  // AlertDisplayDlgProc <br> <br> <br>HWND CreateAlertWindow (HWND hWndParent) <br>/* <br>   Effect:        Create the Alert window. This window is a child of <br>                  hWndMain. <br> <br>   Note:          We dont worry about the size here, as this window <br>                  will be resized whenever the main window is resized. <br> <br>*/ <br>   {  // CreateAlertWindow <br>   HWND           hWnd ; <br>   hWnd = CreateDialog (hInstance, <br>                        MAKEINTRESOURCE (idDlgAlertDisplay), <br>                        hWndParent, <br>                        (DLGPROC) AlertDisplayDlgProc) ; <br> <br>   return (hWnd) ; <br>   }  // CreateAlertWindow <br> <br> <br> <br>void UpdateAlertDisplay (HWND hWnd) <br>/* <br>   Effect:        Set the values for the various controls in the Alert <br>                  display. <br> <br>   Called By:     OnInitDialog, any other routines that change these <br>                  values. <br>*/ <br>   {  // UpdateAlertDisplay <br>   PALERT         pAlert ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   DialogSetInterval (hWnd, IDD_ALERTINTERVAL, pAlert-&gt;iIntervalMSecs) ; <br>   }  // UpdateAlertDisplay <br> <br> <br>BOOL AlertInsertLine (HWND hWnd, PLINE pLine) <br>   { <br>   PALERT         pAlert ; <br>   PLINE          pLineEquivalent ; <br> <br>   pAlert = AlertData (hWnd) ; <br>   pAlert-&gt;bModified = TRUE ; <br> <br>   pLineEquivalent = FindEquivalentLine (pLine, pAlert-&gt;pLineFirst) ; <br>   if (pLineEquivalent) <br>      { <br>      LINESTRUCT  tempLine ; <br> <br>      tempLine = *pLineEquivalent ; <br> <br>      // copy the new alert line attributes <br>      pLineEquivalent-&gt;Visual = pLine-&gt;Visual ; <br>      pLineEquivalent-&gt;bAlertOver = pLine-&gt;bAlertOver ; <br>      pLineEquivalent-&gt;eAlertValue = pLine-&gt;eAlertValue ; <br>      pLineEquivalent-&gt;bEveryTime = pLine-&gt;bEveryTime ; <br> <br>      pLineEquivalent-&gt;lpszAlertProgram = pLine-&gt;lpszAlertProgram ; <br>      pLine-&gt;lpszAlertProgram = tempLine.lpszAlertProgram ; <br> <br>      pLineEquivalent-&gt;hBrush = pLine-&gt;hBrush ; <br>      pLine-&gt;hBrush = tempLine.hBrush ; <br> <br>      if (PlayingBackLog ()) <br>         { <br>         PlaybackAlert (hWnd, 0) ; <br>         WindowInvalidate (hWnd) ; <br>         } <br> <br>      return (FALSE) ; <br>      } <br>   else <br>      { <br>      SystemAdd (&amp;pAlert-&gt;pSystemFirst, pLine-&gt;lnSystemName) ; <br> <br>      LineAppend (&amp;pAlert-&gt;pLineFirst, pLine) ; <br> <br>      LegendAddItem (hWndAlertLegend, pLine) ; <br> <br>      if (!bDelayAddAction) <br>         { <br>         SizeAlertComponents (hWndAlert) ; <br>         LegendSetSelection (hWndAlertLegend,  <br>                             LegendNumItems (hWndAlertLegend) - 1) ; <br>         } <br>      } <br> <br>   if (!bDelayAddAction) <br>      { <br>      if (PlayingBackLog ()) <br>         { <br>         PlaybackAlert (hWnd, 0) ; <br>         WindowInvalidate (hWnd) ; <br>         } <br> <br>      else if (pAlert-&gt;iStatus == iPMStatusClosed) <br>         SetAlertTimer (pAlert) ; <br>      } <br> <br>   return (TRUE) ; <br>   }  // AlertInsertLine <br> <br> <br>void AlertAddAction () <br>   { <br>   PALERT           pAlert ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br> <br>   SizeAlertComponents (hWndAlert) ; <br>   LegendSetSelection (hWndAlertLegend, <br>      LegendNumItems (hWndAlertLegend) - 1) ; <br> <br>   if (PlayingBackLog ()) <br>      { <br>      PlaybackAlert (hWndAlert, 0) ; <br>      WindowInvalidate (hWndAlert) ; <br>      } <br>   else if (pAlert-&gt;iStatus == iPMStatusClosed) <br>      SetAlertTimer (pAlert) ; <br>   } <br>    <br>void SizeAlertComponents (HWND hDlg) <br>   {  // SizeAlertComponents <br>   RECT           rectClient ; <br>   int            xWidth, yHeight ; <br>   int            yLegendHeight ; <br>   int            yLegendTextHeight ; <br>   int            yLogHeight ; <br>   int            yLogTextHeight ; <br>   int            yIntervalHeight ; <br>   int            xIntervalTextWidth ; <br>   int            StartYPos ; <br>   PALERT         pAlert = AlertData(hDlg) ; <br> <br>   GetClientRect (hDlg, &amp;rectClient) ; <br>   xWidth = rectClient.right ; <br>   yHeight = rectClient.bottom ; <br> <br>   if (pAlert-&gt;bLegendOn) <br>      { <br>      yLegendHeight = LegendHeight (hWndAlertLegend, yHeight) ; <br>      } <br>   else <br>      { <br>      yLegendHeight = 0 ; <br>      } <br> <br>   if (yHeight &lt; 7 * xScrollWidth) <br>      { <br>      // too small, just display the alert logs and hide all other <br>      // items <br>      DialogShow (hDlg, IDD_ALERTLEGEND, FALSE) ; <br>      DialogShow (hDlg, IDD_ALERTLEGENDTEXT, FALSE) ; <br> <br>      DialogShow (hDlg, IDD_ALERTINTERVAL, FALSE) ; <br>      DialogShow (hDlg, IDD_ALERTINTERVALTEXT, FALSE) ; <br> <br>      yLogTextHeight = DialogHeight (hDlg, IDD_ALERTLOGTEXT) ; <br> <br>      if (yHeight - yLogTextHeight &gt; 3 * xScrollWidth) <br>         { <br>         DialogMove (hDlg, IDD_ALERTLOGTEXT, <br>                     xScrollWidth, <br>                     xScrollWidth / 2, <br>                     NOCHANGE, NOCHANGE) ; <br>         yLogTextHeight += xScrollWidth / 2 ; <br>         DialogShow (hDlg, IDD_ALERTLOGTEXT, TRUE) ; <br>         } <br>      else <br>         { <br>         yLogTextHeight = 0 ; <br>         DialogShow (hDlg, IDD_ALERTLOGTEXT, FALSE) ; <br>         } <br>      DialogMove (hDlg, IDD_ALERTLOG, <br>                  xScrollWidth, <br>                  xScrollWidth / 2 + yLogTextHeight, <br>                  xWidth - 2 * xScrollWidth, <br>                  yHeight - xScrollWidth) ; <br>      } <br>   else if (yHeight &lt;= 2 * yLegendHeight + 5 * xScrollWidth) <br>      { <br>      if (pAlert-&gt;bLegendOn) <br>         { <br>         yLegendHeight = min (yLegendHeight, <br>            (yHeight - xScrollWidth) / 2) ; <br>         } <br>      else <br>         { <br>         yLegendHeight = 0 ; <br>         } <br> <br> <br>      yLogHeight = yHeight - yLegendHeight - xScrollWidth - 2 ; <br> <br>      DialogShow (hDlg, IDD_ALERTLEGENDTEXT, FALSE) ; <br>      DialogShow (hDlg, IDD_ALERTINTERVAL, FALSE) ; <br>      DialogShow (hDlg, IDD_ALERTINTERVALTEXT, FALSE) ; <br> <br>      yLogTextHeight = DialogHeight (hDlg, IDD_ALERTLOGTEXT) ; <br>      if (yLogHeight - yLogTextHeight &gt; 3 * xScrollWidth) <br>         { <br>         DialogMove (hDlg, IDD_ALERTLOGTEXT, <br>                     xScrollWidth, <br>                     xScrollWidth / 2, <br>                     NOCHANGE, NOCHANGE) ; <br>         yLogTextHeight += xScrollWidth / 2 ; <br>         DialogShow (hDlg, IDD_ALERTLOGTEXT, TRUE) ; <br>         } <br>      else <br>         { <br>         yLogTextHeight = 0 ; <br>         DialogShow (hDlg, IDD_ALERTLOGTEXT, FALSE) ; <br>         } <br> <br>      DialogMove (hDlg, IDD_ALERTLOG, <br>                  xScrollWidth, <br>                  xScrollWidth / 2 + yLogTextHeight, <br>                  xWidth - 2 * xScrollWidth, <br>                  yLogHeight - yLogTextHeight) ; <br> <br>      DialogMove (hDlg, IDD_ALERTLEGEND, <br>                  xScrollWidth, <br>                  yLogHeight + xScrollWidth - 2, <br>                  xWidth - 2 * xScrollWidth, <br>                  yLegendHeight) ; <br> <br>      DialogShow (hDlg, IDD_ALERTLEGEND, pAlert-&gt;bLegendOn ? TRUE : FALSE) ; <br>      } <br>   else <br>      { <br>      if (pAlert-&gt;bLegendOn) <br>         { <br>         DialogMove (hDlg, IDD_ALERTLEGEND, <br>            xScrollWidth, yHeight - xScrollWidth / 2 - yLegendHeight, <br>            xWidth - 2  * xScrollWidth, <br>            yLegendHeight) ; <br>         DialogMove (hDlg, IDD_ALERTLEGENDTEXT, <br>            xScrollWidth, <br>            DialogYPos (hDlg, IDD_ALERTLEGEND) - xScrollWidth, <br>            NOCHANGE, NOCHANGE) ; <br> <br>         yLegendTextHeight = DialogYPos (hDlg, IDD_ALERTLEGENDTEXT) ; <br>         } <br>      else <br>         { <br>         yLegendTextHeight = yHeight - xScrollWidth / 2 - yLegendHeight ; <br>         } <br> <br>      yLogTextHeight = DialogHeight (hDlg, IDD_ALERTLOGTEXT) ; <br>      yIntervalHeight = DialogHeight (hDlg, IDD_ALERTINTERVAL) ; <br>      yLogHeight = yLegendTextHeight - 4 * xScrollWidth ; <br> <br>      if (yLogHeight &lt; 2 * xScrollWidth) <br>         { <br>         yLogHeight = yLegendTextHeight - yLogTextHeight - xScrollWidth ; <br>         } <br>      DialogMove (hDlg, IDD_ALERTLOG, <br>                  xScrollWidth, <br>                  yLegendTextHeight - yLogHeight - xScrollWidth / 2, <br>                  xWidth - 2 * xScrollWidth, <br>                  yLogHeight) ; <br>      DialogMove (hDlg, IDD_ALERTLOGTEXT, <br>                  xScrollWidth, <br>                  yLogTextHeight = DialogYPos (hDlg, IDD_ALERTLOG) - xScrollWidth, <br>                  xWidth - 2 * xScrollWidth, NOCHANGE) ; <br> <br>      DialogShow (hDlg, IDD_ALERTLEGEND, pAlert-&gt;bLegendOn ? TRUE : FALSE) ; <br>      DialogShow (hDlg, IDD_ALERTLEGENDTEXT, pAlert-&gt;bLegendOn ? TRUE : FALSE) ; <br>      DialogShow (hDlg, IDD_ALERTLOGTEXT, TRUE) ; <br> <br> <br>      if (yLogTextHeight &gt;= yIntervalHeight + xScrollWidth) <br>         { <br>         StartYPos = (yLogTextHeight - yIntervalHeight) / 2 ; <br>         xIntervalTextWidth = DialogWidth (hDlg, IDD_ALERTINTERVALTEXT) ; <br>         DialogMove (hDlg, IDD_ALERTINTERVALTEXT, <br>                     xScrollWidth, <br>                     StartYPos + 1, <br>                     NOCHANGE, NOCHANGE) ; <br>         DialogMove (hDlg, IDD_ALERTINTERVAL, <br>                     xScrollWidth + xIntervalTextWidth + 4, <br>                     StartYPos, <br>                     NOCHANGE, NOCHANGE) ; <br> <br>         DialogShow (hDlg, IDD_ALERTINTERVAL, TRUE) ; <br>         DialogShow (hDlg, IDD_ALERTINTERVALTEXT, TRUE) ; <br>         } <br>      else <br>         { <br>         DialogShow (hDlg, IDD_ALERTINTERVAL, FALSE) ; <br>         DialogShow (hDlg, IDD_ALERTINTERVALTEXT, FALSE) ; <br>         } <br>      } <br> <br>   WindowInvalidate (hDlg) ; <br>   }  // SizeAlertComponents <br> <br> <br>INT PlaybackAlert (HWND hWndAlert, HANDLE hExportFile) <br>   {  // PlaybackAlert <br>   PALERT         pAlert ; <br>   LOGPOSITION    lp ; <br>   PLOGINDEX      pLogIndex ; <br>   SYSTEMTIME     SystemTime ; <br>   SYSTEMTIME     PreviousSystemTime ; <br>   BOOL           bFirstTime = TRUE ; <br>   INT            ErrCode = 0 ; <br>   int            iDisplayTics ; <br>   DWORD          TimeDiff ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br> <br>   if (!pAlert-&gt;pLineFirst) <br>      { <br>      // nothing to check <br>      return ErrCode; <br>      } <br> <br>   lp = PlaybackLog.StartIndexPos ; <br>   iDisplayTics = PlaybackLog.iSelectedTics; <br> <br>   if (!hExportFile) <br>      { <br>      LBReset (pAlert-&gt;hAlertListBox) ; <br>      LBSetRedraw (pAlert-&gt;hAlertListBox, FALSE) ; <br>      } <br> <br>   while (iDisplayTics) { <br> <br>      pLogIndex = IndexFromPosition (&amp;lp) ; <br>      if (pLogIndex) <br>         SystemTime = pLogIndex-&gt;SystemTime ; <br>      else <br>         GetLocalTime (&amp;SystemTime) ; <br>       <br>      if (!bFirstTime) <br>         { <br>         // check if it is time to do the alert checking <br>         TimeDiff = (DWORD) SystemTimeDifference (&amp;PreviousSystemTime, &amp;SystemTime) ; <br>         if (TimeDiff * 1000 &gt;= pAlert-&gt;iIntervalMSecs) <br>            { <br>            PlaybackLines (pAlert-&gt;pSystemFirst, <br>                           pAlert-&gt;pLineFirst, <br>                           lp.iPosition) ; <br>            ErrCode = CheckAlerts (hWndAlert, <br>                            pAlert-&gt;hAlertListBox, <br>                            &amp;SystemTime, <br>                            pAlert-&gt;pLineFirst, <br>                            hExportFile, <br>                            NULL) ; <br>            if (ErrCode) <br>               { <br>               break ; <br>               } <br> <br>            PreviousSystemTime = SystemTime ; <br>            } <br>         } <br>      else <br>         { <br>         // setup the data for the first time <br>         bFirstTime = FALSE ; <br>         PreviousSystemTime = SystemTime ; <br>         PlaybackLines (pAlert-&gt;pSystemFirst, <br>                        pAlert-&gt;pLineFirst, <br>                        lp.iPosition) ; <br>         } <br> <br>      if (!NextIndexPosition (&amp;lp, FALSE))   <br>         break; <br> <br>      iDisplayTics-- ; <br>      } <br> <br>   if (!hExportFile) <br>      { <br>      LBSetRedraw (pAlert-&gt;hAlertListBox, TRUE) ; <br>      } <br> <br>   return (ErrCode) ; <br>   }  // PlaybackAlert <br> <br> <br>#if 0 <br>PLINESTRUCT CurrentAlertLine (HWND hWndAlert) <br>   {  // CurrentAlertLine <br>   UNREFERENCED_PARAMETER (hWndAlert) ; <br> <br>   return (LegendCurrentLine (hWndAlertLegend)) ; <br>   }  // CurrentAlertLine <br>#endif <br> <br>BOOL AddAlert (HWND hWndParent) <br>   { <br>   PALERT         pAlert ; <br>   PLINE          pCurrentLine ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br>   pCurrentLine = CurrentAlertLine (hWndAlert) ; <br> <br>   return (AddLine (hWndParent, <br>                    &amp;(pAlert-&gt;pSystemFirst), <br>                    &amp;(pAlert-&gt;Visual), <br>                    pCurrentLine ? pCurrentLine-&gt;lnSystemName : NULL, <br>                    LineTypeAlert)) ; <br>   } <br> <br> <br> <br>BOOL EditAlert (HWND hWndParent) <br>   {  // EditAlert <br>   PALERT        pAlert ; <br>   BOOL          bOK ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br> <br>   bOK = EditLine (hWndParent, <br>                   &amp;(pAlert-&gt;pSystemFirst), <br>                   CurrentAlertLine (hWndAlert), <br>                   LineTypeAlert) ; <br> <br>   if (bOK &amp;&amp; PlayingBackLog()) <br>      { <br>      //re-do the alert using the new condition <br>      PlaybackAlert (hWndAlert, 0) ; <br>      WindowInvalidate (hWndAlert) ; <br>      } <br> <br>   return (bOK) ; <br>   }  // EditAlert <br> <br>// RemoveLineFromAlertListBox is called when we are deleting a line  <br>// while monitoring current activity.  We have to clear all the alert <br>// entries of this line because we are already doing this when  <br>// playing back from log.  Moreover, we are using the line structure <br>// while drawing the item. <br>// <br>void RemoveLineFromAlertListBox (PALERT pAlert, PLINE pLine) <br>   { <br>   int            iIndex ; <br>   int            iNumOfAlerts ; <br>   PALERTENTRY    pAlertEntry ; <br> <br>   iNumOfAlerts = LBNumItems (pAlert-&gt;hAlertListBox) ; <br> <br>   if (iNumOfAlerts == 0 || iNumOfAlerts == (int) LB_ERR) <br>      { <br>      return ; <br>      } <br> <br>   LBSetRedraw (pAlert-&gt;hAlertListBox, FALSE) ; <br> <br>   // go thru the listbox from bottom to top <br>   for (iIndex = iNumOfAlerts - 1; iIndex &gt;= 0; iIndex-- ) <br>      { <br>      pAlertEntry = (PALERTENTRY) LBData (pAlert-&gt;hAlertListBox, iIndex) ; <br>      if (pAlertEntry != (PALERTENTRY) NULL &amp;&amp; pAlertEntry) <br>         { <br>         if (pAlertEntry-&gt;pLine == pLine) <br>            { <br>            // remove it from the alert listbox. <br>            LBDelete (pAlert-&gt;hAlertListBox, iIndex) ; <br>            } <br>         } <br>      } <br>   LBSetRedraw (pAlert-&gt;hAlertListBox, TRUE) ; <br>   } <br> <br>BOOL AlertDeleteLine (HWND hWndAlert, <br>                      PLINE pLine) <br>/* <br>   Effect:        Delete the line pLine from the alerts associated with <br>                  window hWnd.  Return whether the line could be deleted. <br>*/ <br>   {  // DeleteAlert <br>   PALERT         pAlert ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br>   pAlert-&gt;bModified = TRUE ; <br> <br>   LineRemove (&amp;pAlert-&gt;pLineFirst, pLine) ; <br>   LegendDeleteItem (hWndAlertLegend, pLine) ; <br> <br>   if (!pAlert-&gt;pLineFirst) <br>      { <br>      // no need to collect data <br>      ClearAlertTimer (pAlert) ; <br> <br>      // clear legend <br>      ClearLegend (hWndAlertLegend) ; <br> <br>      // reset visual data <br>      pAlert-&gt;Visual.iColorIndex = 0 ; <br>      pAlert-&gt;Visual.iWidthIndex = 0 ; <br>      pAlert-&gt;Visual.iStyleIndex = 0 ; <br>      } <br>   else <br>      { <br>      BuildValueListForSystems ( <br>         pAlert-&gt;pSystemFirst, <br>         pAlert-&gt;pLineFirst) ; <br>      } <br> <br>   if (!PlayingBackLog()) <br>      { <br>      // delete any alert entry for this line <br>      RemoveLineFromAlertListBox (pAlert, pLine) ; <br>      } <br> <br>   SizeAlertComponents (hWndAlert) ; <br> <br>   if (PlayingBackLog ()) <br>      { <br>      if (pAlert-&gt;pLineFirst) <br>         PlaybackAlert (hWndAlert, 0) ; <br>      else <br>         { <br>         LBReset (pAlert-&gt;hAlertListBox) ; <br>         } <br> <br>      WindowInvalidate (hWndAlert) ; <br>      } <br> <br>   return (TRUE) ; <br>   }  // DeleteAlert <br> <br> <br> <br>BOOL ToggleAlertRefresh (HWND hWnd) <br>   {  // ToggleAlertRefresh <br>   PALERT        pAlert ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   if (pAlert-&gt;bManualRefresh) <br>      SetAlertTimer (pAlert) ; <br>   else <br>      ClearAlertTimer (pAlert) ; <br> <br>   pAlert-&gt;bManualRefresh = !pAlert-&gt;bManualRefresh ; <br>   return (pAlert-&gt;bManualRefresh) ; <br>   }  // ToggleAlertRefresh <br> <br>BOOL AlertRefresh (HWND hWnd) <br>   {  // ToggleAlertRefresh <br>   PALERT        pAlert ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   return (pAlert-&gt;bManualRefresh) ; <br>   }  // AlertRefresh <br> <br> <br>void AlertTimer (HWND hWnd, BOOL bForce) <br>/* <br>   Effect:        Perform all actions neccesary when an alert timer tick <br>                  or manual refresh occurs. In particular, get the current <br>                  values for each line in the alert window, and compare <br>                  the value against the alert conditions. For each alert <br>                  that may have occured, call SignalAlert. <br> <br>   Called By:     AlertWndProc, in response to a WM_TIMER message. <br>                  OnCommand, in response to a IDM_REFRESHALERT notification. <br>*/ <br>   {  // AlertTimer <br>   PALERT         pAlert ; <br>   SYSTEMTIME     SystemTime ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   if (PlayingBackLog ()) <br>      return ; <br> <br>   if (bForce || !pAlert-&gt;bManualRefresh) <br>      {  // if <br>      UpdateLines (&amp;(pAlert-&gt;pSystemFirst), pAlert-&gt;pLineFirst) ; <br>      GetLocalTime (&amp;SystemTime) ; <br>      CheckAlerts (hWnd, <br>                   pAlert-&gt;hAlertListBox, <br>                   &amp;SystemTime, <br>                   pAlert-&gt;pLineFirst, <br>                   FALSE, <br>                   pAlert-&gt;pSystemFirst) ; <br>      }  // if <br>   }  // AlertTimer <br> <br> <br> <br>BOOL OpenAlertVer1 (HANDLE hFile, <br>                    DISKALERT *pDiskAlert, <br>                    PALERT pAlert, <br>                    DWORD dwMinorVersion) <br>                   <br>   {  // OpenAlertVer1 <br>   bDelayAddAction = TRUE ; <br>   pAlert-&gt;Visual = pDiskAlert-&gt;Visual ; <br>   pAlert-&gt;iIntervalMSecs = pDiskAlert-&gt;dwIntervalSecs ; <br>   if (dwMinorVersion &lt; 3) <br>      { <br>      pAlert-&gt;iIntervalMSecs *= 1000 ; <br>      } <br> <br>   pAlert-&gt;bNetworkAlert = pDiskAlert-&gt;bNetworkAlert ; <br>   pAlert-&gt;bManualRefresh = pDiskAlert-&gt;bManualRefresh ; <br>   pAlert-&gt;bSwitchToAlert = pDiskAlert-&gt;bSwitchToAlert ; <br> <br>   if (dwMinorVersion &gt;= 2) <br>      { <br>      lstrcpy (pAlert-&gt;MessageName, pDiskAlert-&gt;MessageName) ; <br>      } <br> <br>   pAlert-&gt;bLegendOn = TRUE ; <br> <br>   if (dwMinorVersion &gt;= 4) <br>      { <br>      if (dwMinorVersion == 4) <br>         pAlert-&gt;bEventLog = pDiskAlert-&gt;MiscOptions ; <br>      else <br>         { <br>         pAlert-&gt;bEventLog = pDiskAlert-&gt;MiscOptions &amp; 0x01 ; <br>         pAlert-&gt;bLegendOn = pDiskAlert-&gt;MiscOptions &amp; 0x02 ; <br>         } <br>      } <br>   else <br>      { <br>      pAlert-&gt;bEventLog = FALSE ; <br> <br>      // have to move the file pointer back for old pma file <br>      FileSeekCurrent (hFile, -((int) (sizeof (pDiskAlert-&gt;MiscOptions)))) ; <br>      } <br> <br>   if (pAlert-&gt;bNetworkAlert &amp;&amp; pAlert-&gt;hNetAlertThread == 0) <br>      { <br>      AlertCreateThread (pAlert) ; <br>      } <br> <br>   ReadLines (hFile, pDiskAlert-&gt;dwNumLines, <br>               &amp;(pAlert-&gt;pSystemFirst), &amp;(pAlert-&gt;pLineFirst), IDM_VIEWALERT) ; <br> <br>   bDelayAddAction = FALSE ; <br> <br>   AlertAddAction () ; <br> <br>   return (TRUE) ; <br>   }  // OpenAlertVer1 <br> <br> <br> <br>BOOL OpenAlert (HWND hWndAlert, <br>                HANDLE hFile, <br>                DWORD dwMajorVersion, <br>                DWORD dwMinorVersion, <br>                BOOL bAlertFile) <br>   {  // OpenAlert <br>   PALERT         pAlert ; <br>   DISKALERT      DiskAlert ; <br>   BOOL           bSuccess = TRUE ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br>   if (!pAlert) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br>   if (!FileRead (hFile, &amp;DiskAlert, sizeof (DISKALERT))) <br>      { <br>      bSuccess = FALSE ; <br>      goto Exit0 ; <br>      } <br> <br> <br>   switch (dwMajorVersion) <br>      { <br>      case (1): <br> <br>         SetHourglassCursor() ; <br> <br>         ResetAlertView (hWndAlert) ; <br> <br>         OpenAlertVer1 (hFile, &amp;DiskAlert, pAlert, dwMinorVersion) ; <br> <br>         // change to alert view if we are opening a  <br>         // alert file <br>         if (bAlertFile &amp;&amp; iPerfmonView != IDM_VIEWALERT) <br>            { <br>            SendMessage (hWndMain, WM_COMMAND, (LONG)IDM_VIEWALERT, 0L) ; <br>            } <br> <br>         if (iPerfmonView == IDM_VIEWALERT) <br>            { <br>            SetPerfmonOptions (&amp;DiskAlert.perfmonOptions) ; <br>            } <br>         UpdateAlertDisplay (hWndAlert) ; <br> <br>         SetArrowCursor() ; <br> <br>         break ; <br>      }  // switch <br> <br>Exit0: <br> <br>   if (bAlertFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (bSuccess) ; <br>   }  // OpenAlert <br> <br> <br>void ResetAlertView (HWND hWndAlert) <br>   {   <br>   PALERT         pAlert ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br>   if (!pAlert) <br>      return ; <br> <br>   ChangeSaveFileName (NULL, IDM_VIEWALERT) ; <br> <br>   if (pAlert-&gt;pSystemFirst) <br>      { <br>      ResetAlert (hWndAlert) ; <br>      } <br>   }  // ResetAlertView <br> <br>void ResetAlert (HWND hWndAlert) <br>   {  // ResetAlert <br>   PALERT         pAlert ; <br> <br> <br>   pAlert = AlertData (hWndAlert) ; <br>   if (!pAlert) <br>      return ; <br> <br>   ClearAlertTimer (pAlert) ; <br> <br>   ClearLegend (hWndAlertLegend) ; <br>   if (pAlert-&gt;pLineFirst) <br>      { <br>      FreeLines (pAlert-&gt;pLineFirst) ; <br>      pAlert-&gt;pLineFirst = NULL ; <br>      } <br> <br>   if (pAlert-&gt;pSystemFirst) <br>      { <br>      FreeSystems (pAlert-&gt;pSystemFirst) ; <br>      pAlert-&gt;pSystemFirst = NULL ; <br>      } <br> <br>   pAlert-&gt;bModified = FALSE ; <br> <br>   // reset visual data <br>   pAlert-&gt;Visual.iColorIndex = 0 ; <br>   pAlert-&gt;Visual.iWidthIndex = 0 ; <br>   pAlert-&gt;Visual.iStyleIndex = 0 ; <br> <br>   iUnviewedAlerts = 0 ; <br>   if (iPerfmonView != IDM_VIEWALERT) <br>      { <br>      StatusUpdateIcons (hWndStatus) ; <br>      } <br> <br>   // remove the horiz. scrollbar <br>   pAlert-&gt;xTextExtent = 0 ; <br>   LBSetHorzExtent (pAlert-&gt;hAlertListBox, pAlert-&gt;xTextExtent) ; <br> <br>   LBReset (pAlert-&gt;hAlertListBox) ; <br>   SizeAlertComponents (hWndAlert) ; <br> <br>//   WindowInvalidate (hWndAlert) ; <br>   }  // ResetAlert <br>    <br> <br>void ClearAlertDisplay (HWND hWnd) <br>   { <br>   PALERT         pAlert ; <br> <br>   pAlert = AlertData (hWnd) ; <br> <br>   // remove the horiz. scrollbar <br>   pAlert-&gt;xTextExtent = 0 ; <br>   LBSetHorzExtent (pAlert-&gt;hAlertListBox, pAlert-&gt;xTextExtent) ; <br> <br>   LBReset (pAlert-&gt;hAlertListBox) ; <br>   } <br> <br>BOOL SaveAlert (HWND hWndAlert, HANDLE hInputFile, BOOL bGetFileName) <br>   { <br>   PALERT         pAlert ; <br>   PLINE          pLine ; <br>   HANDLE         hFile ; <br>   DISKALERT      DiskAlert ; <br>   PERFFILEHEADER FileHeader ; <br>   TCHAR          szFileName [256] ; <br>   BOOL           newFileName = FALSE ; <br> <br>   if (hInputFile) <br>      { <br>      // use the input file handle if it is available <br>      // this is the case for saving workspace data <br>      hFile = hInputFile ; <br>      } <br>   else <br>      { <br>      if (pAlertFullFileName) <br>         { <br>         lstrcpy (szFileName, pAlertFullFileName) ; <br>         } <br>      if (bGetFileName || pAlertFullFileName == NULL) <br>         { <br>         if (!FileGetName (hWndAlert, IDS_ALERTFILE, szFileName)) <br>            { <br>            return (FALSE) ; <br>            } <br>         newFileName = TRUE ; <br>         } <br> <br>      hFile = FileHandleCreate (szFileName) ; <br> <br>      if (hFile &amp;&amp; newFileName) <br>         { <br>         ChangeSaveFileName (szFileName, IDM_VIEWALERT) ; <br>         } <br>      else if (!hFile) <br>         { <br>         DlgErrorBox (hWndAlert, ERR_CANT_OPEN, szFileName) ; <br>         } <br>      } <br> <br>   if (!hFile) <br>      return (FALSE) ; <br> <br>   pAlert = AlertData (hWndAlert) ; <br>   if (!pAlert) <br>      { <br>      if (!hInputFile) <br>         { <br>         CloseHandle (hFile) ; <br>         } <br>      return (FALSE) ; </code></pre>
<p>
</p>
<pre><code>} <br> <br>   if (!hInputFile) <br>      { <br>      memset (&amp;FileHeader, 0, sizeof (FileHeader)) ; <br>      lstrcpy (FileHeader.szSignature, szPerfAlertSignature) ; <br>      FileHeader.dwMajorVersion = AlertMajorVersion ; <br>      FileHeader.dwMinorVersion = AlertMinorVersion ; <br>    <br>      if (!FileWrite (hFile, &amp;FileHeader, sizeof (PERFFILEHEADER))) <br>         { <br>         goto Exit0 ; <br>         } <br>      } <br> <br>   DiskAlert.Visual = pAlert-&gt;Visual ; <br>   DiskAlert.dwIntervalSecs = pAlert-&gt;iIntervalMSecs ; <br>   DiskAlert.dwNumLines = NumLines (pAlert-&gt;pLineFirst) ; <br> <br>   // fill in misc alert options <br>   DiskAlert.MiscOptions = 0 ; <br>   if (pAlert-&gt;bEventLog) <br>      DiskAlert.MiscOptions = 0x01 ; <br>   if (pAlert-&gt;bLegendOn) <br>      DiskAlert.MiscOptions += 0x02 ; <br> <br>//   DiskAlert.bEventLog = pAlert-&gt;bEventLog ; <br>   DiskAlert.bNetworkAlert = pAlert-&gt;bNetworkAlert ; <br>   DiskAlert.bSwitchToAlert = pAlert-&gt;bSwitchToAlert ; <br>   DiskAlert.bManualRefresh = pAlert-&gt;bManualRefresh ; <br>   DiskAlert.perfmonOptions = Options ; <br>   lstrcpy (DiskAlert.MessageName, pAlert-&gt;MessageName) ; <br>   if (!FileWrite (hFile, &amp;DiskAlert, sizeof (DISKALERT))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   for (pLine = pAlert-&gt;pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for <br>      if (!WriteLine (pLine, hFile)) <br>         { <br>         goto Exit0 ; <br>         } <br>      }  // for <br> <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   if (!hInputFile) <br>      { <br>      CloseHandle (hFile) ; <br> <br>      // only need to report error if not workspace  <br>      DlgErrorBox (hWndAlert, ERR_SETTING_FILE, szFileName) ; <br>      } <br>   return (FALSE) ; <br>   } <br> <br> <br>BOOL ExportAlertEntry (HANDLE hFile, PALERTENTRY pAlertEntry) <br>{ <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br>   CHAR           TempBuff [LongTextLen * 2] ; <br>   int            StringLen ; <br>   PLINE          pLine ; <br> <br>   pLine = pAlertEntry-&gt;pLine ; <br> <br>   // export the alert date-time <br>    <br>   strcpy (TempBuff, LineEndStr) ; <br>   StringLen = strlen (TempBuff) ; <br>   SystemTimeDateString (&amp;(pAlertEntry-&gt;SystemTime), UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br> <br>   strcat (TempBuff, pDelimiter) ; <br>   SystemTimeTimeString (&amp;(pAlertEntry-&gt;SystemTime), UnicodeBuff, FALSE) ; <br>   StringLen = strlen (TempBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // export alert value and trigger condition <br> <br>   if (pLine) <br>      { <br>      TSPRINTF (UnicodeBuff, szNumberFormat, pAlertEntry-&gt;eValue) ; <br>      ConvertDecimalPoint (UnicodeBuff) ; <br>      ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>      strcat (TempBuff, pDelimiter) ; <br>      StringLen = strlen (TempBuff) ; <br>      TempBuff[StringLen] = pAlertEntry-&gt;bOver ? '&gt;' : '&lt;' ; <br>      StringLen++ ; <br>      TSPRINTF (UnicodeBuff, szNumberFormat, pAlertEntry-&gt;eAlertValue) ; <br>      ConvertDecimalPoint (UnicodeBuff) ; <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>      strcat (TempBuff, pDelimiter) ; <br>      } <br>   else <br>      { <br>      strcpy (TempBuff, pDelimiter) ; <br>      strcat (TempBuff, pDelimiter) ; <br>      } <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // export Counter, Instance, &amp; Parent names <br>    <br>   if (pLine) <br>      { <br>      ConvertUnicodeStr (TempBuff, pLine-&gt;lnCounterName) ; <br>      } <br>   else <br>      { <br>      // system up/down message is stored in lpszInstance. <br>      ConvertUnicodeStr (TempBuff, pAlertEntry-&gt;lpszInstance) ; <br>      } <br> <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   if (pLine &amp;&amp; !(strempty(pAlertEntry-&gt;lpszInstance))) <br>      { <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], pAlertEntry-&gt;lpszInstance) ; <br>      } <br> <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br>    <br>   if (pLine &amp;&amp; !(strempty(pAlertEntry-&gt;lpszParent))) <br>      { <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], pAlertEntry-&gt;lpszParent) ; <br>      } <br>   strcat (TempBuff, pDelimiter) ; <br>    <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   // export object, &amp; computer names <br>   TempBuff[0] = '\0' ;    <br>   if (pLine) <br>      { <br>      ConvertUnicodeStr (TempBuff, pLine-&gt;lnObjectName) ; <br>      } <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   if (pLine) <br>      { <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], pLine-&gt;lnSystemName) ; <br>      } <br>   else <br>      { <br>      // system name for the system that is up or down is in <br>      // lpszParent. <br>      ConvertUnicodeStr (&amp;TempBuff[StringLen], pAlertEntry-&gt;lpszParent) ; <br>      } <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportAlertEntry <br> <br>INT ExportAlertLine (PLINE pLine, FLOAT eValue, SYSTEMTIME *pSystemTime, HANDLE hExportFile) <br>{ <br>   ALERTENTRY     AlertEntry ; <br>   TCHAR          szInstance [256] ; <br>   TCHAR          szParent [256] ; <br>   INT            ErrCode = 0 ; <br> <br>   AlertEntry.SystemTime = *pSystemTime ; <br>   AlertEntry.pLine= pLine ; <br>   AlertEntry.eValue = eValue ; <br>   AlertEntry.bOver = pLine-&gt;bAlertOver ; <br>   AlertEntry.eAlertValue = pLine-&gt;eAlertValue ; <br> <br> <br>   //=============================// <br>   // Determine Instance, Parent  // <br>   //=============================// <br> <br>   // It's possible that there will be no instance, therefore <br>   // the lnInstanceName would be NULL. <br> <br>   if (pLine-&gt;lnObject.NumInstances &gt; 0) <br>      { <br>      // Test for the parent object instance name title index. <br>      // If there is one, it implies that there will be a valid <br>      // Parent Object Name and a valid Parent Object Instance Name. <br> <br>      // If the Parent Object title index is 0 then <br>      // just display the instance name. <br> <br>      lstrcpy (szInstance, pLine-&gt;lnInstanceName) ; <br>      if (pLine-&gt;lnInstanceDef.ParentObjectTitleIndex &amp;&amp; pLine-&gt;lnPINName) <br>         { <br>         // Get the Parent Object Name. <br>         lstrcpy (szParent, pLine-&gt;lnPINName) ; <br>         } <br>      else <br>         { <br>         szParent[0] = TEXT(' ') ; <br>         szParent[1] = TEXT('\0') ; <br>         } <br>      } <br>   else <br>      { <br>      szInstance[0] = TEXT(' ') ; <br>      szInstance[1] = TEXT('\0') ; <br>      szParent[0] = TEXT(' ') ; <br>      szParent[1] = TEXT('\0') ; <br>      } <br> <br>   AlertEntry.lpszInstance = szInstance ; <br>   AlertEntry.lpszParent = szParent ; <br> <br>   if (!ExportAlertEntry (hExportFile, &amp;AlertEntry)) <br>      { <br>      ErrCode = ERR_EXPORT_FILE ; <br>      } <br> <br>   return ErrCode ; <br> } <br> <br> <br>BOOL ExportAlertLabels (HANDLE hFile) <br>{ <br>   TCHAR          UnicodeBuff [LongTextLen] ; <br>   CHAR           TempBuff [LongTextLen * 2] ; <br>   int            StringLen ; <br> <br>   strcpy (TempBuff, LineEndStr) ; <br>   StringLen = strlen (TempBuff) ; <br>   StringLoad (IDS_EXPORT_DATE, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_EXPORT_TIME, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_LABELVALUE, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_ALERT_TRIGGER, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   StringLoad (IDS_COUNTERNAME, UnicodeBuff) ; <br>   ConvertUnicodeStr (TempBuff, UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_INSTNAME, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_PARENT, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_OBJNAME, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br>   strcat (TempBuff, pDelimiter) ; <br>   StringLen = strlen (TempBuff) ; <br> <br>   StringLoad (IDS_LABELSYSTEM, UnicodeBuff) ; <br>   ConvertUnicodeStr (&amp;TempBuff[StringLen], UnicodeBuff) ; <br> <br>   if (!FileWrite (hFile, TempBuff, strlen(TempBuff))) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   return (TRUE) ; <br> <br>Exit0: <br>   return (FALSE) ; <br> <br>}  // ExportAlertLabels <br> <br> <br>void ExportAlert (void) <br>{ <br>   PALERT         pAlert ; <br>   HANDLE         hFile = 0 ; <br>   HWND           hWndAlerts ; <br>   PALERTENTRY    pAlertEntry ; <br>   int            AlertTotal ; <br>   int            iIndex ; <br>   LPTSTR         pFileName = NULL ; <br>   INT            ErrCode = 0 ; <br> <br>   if (!(pAlert = AlertData (hWndAlert))) <br>      { <br>      return ; <br>      } <br> <br>   // see if there is anything to export.. <br>   if (!(pAlert-&gt;pLineFirst)) <br>      { <br>      return ; <br>      } <br> <br>   if (!(hWndAlerts = pAlert-&gt;hAlertListBox)) <br>      { <br>      return ; <br>      } <br> <br>   AlertTotal = LBNumItems (hWndAlerts) ; <br>   if (AlertTotal == LB_ERR || AlertTotal == 0) <br>      { <br>      return ; <br>      } <br> <br>   SetHourglassCursor() ; <br>    <br>   if (ErrCode = ExportFileOpen (hWndAlert, &amp;hFile, pAlert-&gt;iIntervalMSecs, &amp;pFileName)) <br>      { <br>      goto Exit0 ; <br>      } <br> <br>   if (!pFileName) <br>      { <br>      // the case when user cancel. <br>      goto Exit0 ; <br>      } <br> <br>   // export the column labels <br>   if (!ExportAlertLabels (hFile)) <br>      { <br>      ErrCode = ERR_EXPORT_FILE ; <br>      goto Exit0 ; <br>      } <br>   if (AlertTotal &lt; ALERTLOGMAXITEMS || !PlayingBackLog()) <br>      { <br>      for (iIndex = 0 ; iIndex &lt; AlertTotal ; iIndex++) <br>         { <br>         // get the alert data <br>         pAlertEntry = (PALERTENTRY) LBData (hWndAlerts, iIndex) ; <br> <br>         if (!pAlertEntry || pAlertEntry == (PALERTENTRY)LB_ERR) <br>            { <br>            // skip this entry if we hit an error <br>            continue ; <br>            } <br>          <br>         // export the alert line <br>         if (!ExportAlertEntry (hFile, pAlertEntry)) <br>            { <br>            ErrCode = ERR_EXPORT_FILE ; <br>            break ; <br>            } <br>         } <br>      } <br>   else <br>      { <br>      // we are playingback log and that the listbox does not <br>      // contain all the alerts.  In this case, have to walk the <br>      // log file to re-generate all the alerts. <br>      ErrCode = PlaybackAlert (hWndAlert, hFile) ; <br>      } <br> <br>Exit0: <br> <br>   SetArrowCursor() ; <br> <br>   if (hFile) <br>      { <br>      CloseHandle (hFile) ; <br>      } <br> <br>   if (pFileName) <br>      { <br>      if (ErrCode) <br>         { <br>         DlgErrorBox (hWndAlert, ErrCode, pFileName) ; <br>         } <br> <br>      MemoryFree (pFileName) ; <br>      } <br> <br>}  // ExportAlert <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
