<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFDATA.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5680"></a>PERFDATA.C</h2>
<pre><code>//==========================================================================// <br>//                                  Includes                                // <br>//==========================================================================// <br> <br> <br>#include &lt;string.h&gt;     // strupr <br>#include &lt;stdio.h&gt;   // for sprintf. <br>#include "perfmon.h" <br>#include "utils.h" <br> <br>#include "pmemory.h"        // for MemoryXXX (mallloc-type) routines <br>#include "playback.h"   // for PlayingBackLog <br>#include "perfdata.h"   // external declarations for this file <br>#include "system.h"     // for DeleteUnusedSystems <br>#include "line.h"       // for LineFind???() <br>#include "perfmops.h"   // for AppendObjectToValueList() <br> <br>//==========================================================================// <br>//                                  Constants                               // <br>//==========================================================================// <br> <br>TCHAR NamesKey[] = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"; <br>TCHAR Counters[] = L"Counters"; <br>TCHAR Help[] = L"Help"; <br>TCHAR LastHelp[] = L"Last Help"; <br>TCHAR LastCounter[] = L"Last Counter"; <br>TCHAR SysVersion[] = L"Version"; <br>TCHAR CounterNameStr[] = L"Counter "; <br>TCHAR ExplainNameStr[] = L"Explain "; <br> <br>#define szPerfSubkey      (NULL) <br>TCHAR   NULL_NAME[] = L" "; <br>#define RESERVED    0L <br> <br>TCHAR          DefaultLangId[4] ; <br>TCHAR          EnglishLangId[4] ; <br> <br>static   HANDLE            *lpHandles ; <br>static   int               NumberOfHandles = 0 ; <br> <br>//==========================================================================// <br>//                                   Macros                                 // <br>//==========================================================================// <br> <br> <br> <br>//==========================================================================// <br>//                                Local Data                                // <br>//==========================================================================// <br> <br> <br>// When the conversion of this code is complete, this will be the *only* <br>// allocated copy of the performance data.  It will monotonically grow <br>// to hold the largest of the system's performance data. <br> <br>// PPERFDATA      pGlobalPerfData ; <br> <br>//==========================================================================// <br>//                              Local Functions                             // <br>//==========================================================================// <br> <br>NTSTATUS  AddNamesToArray (LPTSTR pNames, <br>   DWORD    dwLastID, <br>   LPWSTR   *lpCounterId) ; <br> <br>//======================================// <br>// Object Accessors                     // <br>//======================================// <br> <br> <br>void ObjectName (PPERFSYSTEM pSystem, <br>                 PPERFOBJECT pObject,  <br>                 LPTSTR lpszName,  <br>                 int iLen) <br>   {  // ObjectName <br>   strclr (lpszName) ; <br>   QueryPerformanceName (pSystem,  <br>                         pObject-&gt;ObjectNameTitleIndex,  <br>                         0, iLen, lpszName, FALSE) ; <br>   }  // ObjectName <br> <br> <br> <br>//======================================// <br>// Counter Accessors                    // <br>//======================================// <br> <br> <br>PERF_INSTANCE_DEFINITION * <br>FirstInstance( <br>    PERF_OBJECT_TYPE *pObjectDef) <br>{ <br>    return (PERF_INSTANCE_DEFINITION *) <br>               ((PCHAR) pObjectDef + pObjectDef-&gt;DefinitionLength); <br>} <br> <br> <br>PERF_INSTANCE_DEFINITION * <br>NextInstance( <br>    PERF_INSTANCE_DEFINITION *pInstDef) <br>{ <br>    PERF_COUNTER_BLOCK *pCounterBlock; <br> <br>    pCounterBlock = (PERF_COUNTER_BLOCK *) <br>                        ((PCHAR) pInstDef + pInstDef-&gt;ByteLength); <br> <br>    return (PERF_INSTANCE_DEFINITION *) <br>               ((PCHAR) pCounterBlock + pCounterBlock-&gt;ByteLength); <br>} <br> <br> <br> <br> <br>LPTSTR <br>GetInstanceName( <br>PPERFINSTANCEDEF  pInstDef) <br>{ <br>    return (LPTSTR) ((PCHAR) pInstDef + pInstDef-&gt;NameOffset); <br>} <br> <br> <br>void <br>GetInstanceNameStr (PPERFINSTANCEDEF pInstance, <br>                    LPTSTR lpszInstance) <br>   { <br>   LPSTR pSource; <br> <br>   pSource = (LPSTR) GetInstanceName(pInstance) ; <br> <br>   if (pSource[1] == '\0' &amp;&amp; pSource[2] != '\0') <br>      { <br>      // Must be Unicode <br>      wcsncpy (lpszInstance, <br>               (LPTSTR)pSource, <br>               pInstance-&gt;NameLength); <br>      } <br>   else <br>      { <br>      // Must be ANSI (or a single Unicode character) <br>      mbstowcs (lpszInstance, <br>                pSource, <br>                pInstance-&gt;NameLength); <br>      } <br> <br>   } <br> <br>void <br>GetPerfComputerName(PPERFDATA pPerfData, <br>                    LPTSTR lpszComputerName) <br>   { <br>   lstrcpy(lpszComputerName, szComputerPrefix) ; <br>   if (pPerfData) <br>      { <br>      wcsncpy (&amp;lpszComputerName[2], <br>               (LPWSTR)((PBYTE) pPerfData + pPerfData-&gt;SystemNameOffset), <br>               pPerfData-&gt;SystemNameLength/sizeof(WCHAR)) ; <br>      } <br>   else <br>      { <br>      lpszComputerName[0] = TEXT('\0') ; <br>      } <br>   } <br> <br> <br>//==========================================================================// <br>//                             Exported Functions                           // <br>//==========================================================================// <br> <br> <br>int CounterIndex (PPERFCOUNTERDEF pCounterToFind, <br>                  PPERFOBJECT pObject) <br>/* <br>   Effect:        Return the index ("counter number") of pCounterToFind <br>                  within pObject. If the counter doesnt belong to pObject, <br>                  return -1. <br>*/ <br>   {  // CounterIndex <br>   PPERFCOUNTERDEF   pCounter ; <br>   UINT              iCounter ; <br> <br>   for (iCounter = 0, pCounter = FirstCounter (pObject) ; <br>        iCounter &lt; pObject-&gt;NumCounters ; <br>        iCounter++, pCounter = NextCounter (pCounter)) <br>      {  // for <br>      if (pCounter-&gt;CounterNameTitleIndex ==  <br>          pCounterToFind-&gt;CounterNameTitleIndex) <br>         return (iCounter) ; <br>      }  // for <br> <br>   return (-1) ; <br>   }  // CounterIndex <br> <br> <br>HKEY <br>OpenSystemPerfData ( <br>    IN LPCTSTR lpszSystem <br>) <br>{  // OpenSystemPerfData <br> <br>    HKEY    hKey = NULL; <br>    LONG    lStatus; <br> <br> <br>    lStatus = ERROR_CANTOPEN;   // default error if none is returned <br> <br>    if (IsLocalComputer(lpszSystem) || PlayingBackLog()) { <br>        bCloseLocalMachine = TRUE ; <br>        SetLastError (ERROR_SUCCESS); <br>        return HKEY_PERFORMANCE_DATA; <br>    } else if (lstrlen (lpszSystem) &lt; MAX_COMPUTERNAME_LENGTH+3) { <br>        // Must be a remote system <br>        try { <br>            lStatus = RegConnectRegistry ( <br>                (LPTSTR)lpszSystem, <br>                HKEY_PERFORMANCE_DATA, <br>                &amp;hKey); <br>        } finally { <br>            if (lStatus != ERROR_SUCCESS) { <br>                SetLastError (lStatus); <br>                hKey = NULL; <br>            } <br>        } <br>    } <br>    return (hKey); <br> <br>}  // OpenSystemPerfData <br>  <br>LPWSTR <br>*AddNewName( <br>    HKEY    hKeyNames, <br>    PCOUNTERTEXT  pCounterInfo, <br>    LPWSTR  CounterBuffer, <br>    LPWSTR  HelpBuffer, <br>    DWORD   dwLastId, <br>    DWORD   dwCounterSize, <br>    DWORD   dwHelpSize, <br>    LANGID  LangIdUsed <br>   ) <br>{ <br>    LPWSTR  *lpReturnValue; <br>    LPWSTR  *lpCounterId; <br>    LPWSTR  lpCounterNames; <br>    LPWSTR  lpHelpText; <br>    DWORD   dwArraySize; <br>    DWORD   dwBufferSize; <br>    DWORD   dwValueType; <br>    LONG    lWin32Status; <br>    NTSTATUS    Status; <br>    DWORD   dwLastError; <br> <br>    dwArraySize = (dwLastId + 1 ) * sizeof(LPWSTR); <br>    lpReturnValue = MemoryAllocate (dwArraySize + dwCounterSize + dwHelpSize); <br> <br>    if (!lpReturnValue) goto ERROR_EXIT; <br> <br>    // initialize pointers into buffer <br> <br>    lpCounterId = lpReturnValue; <br>    lpCounterNames = (LPWSTR)((LPBYTE)lpCounterId + dwArraySize); <br>    lpHelpText = (LPWSTR)((LPBYTE)lpCounterNames + dwCounterSize); <br> <br>    // read counters into memory <br> <br>    dwBufferSize = dwCounterSize; <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyNames, <br>        CounterBuffer, <br>        RESERVED, <br>        &amp;dwValueType, <br>        (LPVOID)lpCounterNames, <br>        &amp;dwBufferSize); <br> <br>    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT; <br>  <br>    if (bExplainTextButtonHit) { <br>        dwBufferSize = dwHelpSize; <br>        lWin32Status = RegQueryValueEx ( <br>            hKeyNames, <br>            HelpBuffer, <br>            RESERVED, <br>            &amp;dwValueType, <br>            (LPVOID)lpHelpText, <br>            &amp;dwBufferSize); <br>                             <br>    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT; <br>    } <br> <br>    // load counter array items <br>    Status = AddNamesToArray (lpCounterNames, dwLastId, lpCounterId); <br>    if (Status != ERROR_SUCCESS) goto ERROR_EXIT; <br> <br>    if (bExplainTextButtonHit) { <br>        Status = AddNamesToArray (lpHelpText, dwLastId, lpCounterId); <br>    } <br> <br>    if (Status != ERROR_SUCCESS) goto ERROR_EXIT; <br> <br>    if (pCounterInfo) { <br>        pCounterInfo-&gt;dwLastId = dwLastId; <br>        pCounterInfo-&gt;dwLangId = LangIdUsed; <br>        pCounterInfo-&gt;dwHelpSize = dwHelpSize; <br>        pCounterInfo-&gt;dwCounterSize = dwCounterSize; <br>    } <br> <br>    return lpReturnValue; <br> <br>ERROR_EXIT: <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        dwLastError = GetLastError(); <br>    } <br> <br>    if (lpReturnValue) { <br>        MemoryFree ((LPVOID)lpReturnValue); <br>    } <br>     <br>    return NULL; <br>} <br> <br>  <br>LPWSTR <br>*BuildNewNameTable( <br>    PPERFSYSTEM   pSystem, <br>    LPWSTR        lpszLangId,     // unicode value of Language subkey <br>    PCOUNTERTEXT  pCounterInfo, <br>    LANGID        iLangId,         // lang ID of the lpszLangId <br>    DWORD         dwLastId <br>) <br>/*++ <br>    <br>BuildNewNameTable <br> <br>Arguments: <br> <br>    lpszLangId <br>            The unicode id of the language to look up. (English is 0x409) <br> <br>Return Value: <br>      <br>    pointer to an allocated table. (the caller must free it when finished!) <br>    the table is an array of pointers to zero terminated strings. NULL is <br>    returned if an error occured. <br> <br>--*/ <br>{ <br>    LONG    lWin32Status; <br>    DWORD   dwValueType; <br>    DWORD   dwLastError; <br>    DWORD   dwBufferSize; <br>    DWORD   dwCounterSize; <br>    DWORD   dwHelpSize; <br>    HKEY    hKeyNames; <br>    TCHAR   CounterBuffer [MiscTextLen] ; <br>    TCHAR   ExplainBuffer [MiscTextLen] ; <br>    TCHAR   subLangId [ShortTextLen] ; <br>    LANGID  LangIdUsed = iLangId; <br> <br> <br>    //initialize local variables <br>    hKeyNames = pSystem-&gt;sysDataKey; <br> <br> <br>    // check for null arguments and insert defaults if necessary <br>    if (!lpszLangId) { <br>        lpszLangId = DefaultLangId; <br>        LangIdUsed = iLanguage ; <br>    } <br> <br>    // get size of counter names and add that to the arrays <br>    lstrcpy (CounterBuffer, CounterNameStr); <br>    lstrcat (CounterBuffer, lpszLangId); <br> <br>    lstrcpy (ExplainBuffer, ExplainNameStr); <br>    lstrcat (ExplainBuffer, lpszLangId); <br> <br>    dwBufferSize = 0; <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyNames, <br>        CounterBuffer, <br>        RESERVED, <br>        &amp;dwValueType, <br>        NULL, <br>        &amp;dwBufferSize); <br> <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        // try take out the country ID <br>        LangIdUsed = MAKELANGID (LangIdUsed &amp; 0x0ff, LANG_NEUTRAL); <br>        TSPRINTF (subLangId, TEXT("%03x"), LangIdUsed); <br>        lstrcpy (CounterBuffer, CounterNameStr); <br>        lstrcat (CounterBuffer, subLangId); <br> <br>        lstrcpy (ExplainBuffer, ExplainNameStr); <br>        lstrcpy (ExplainBuffer, subLangId); <br> <br>        dwBufferSize = 0; <br>        lWin32Status = RegQueryValueEx ( <br>            hKeyNames, <br>            CounterBuffer, <br>            RESERVED, <br>            &amp;dwValueType, <br>            NULL, <br>            &amp;dwBufferSize); <br>    } <br> <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        // try the EnglishLangId  <br>        if (!strsame(EnglishLangId, subLangId)) { <br> <br>            lstrcpy (CounterBuffer, CounterNameStr); <br>            lstrcat (CounterBuffer, EnglishLangId); <br> <br>            lstrcpy (ExplainBuffer, ExplainNameStr); <br>            lstrcpy (ExplainBuffer, EnglishLangId); <br> <br>            LangIdUsed = iEnglishLanguage ; <br> <br>            dwBufferSize = 0; <br>            lWin32Status = RegQueryValueEx ( <br>                hKeyNames, <br>                CounterBuffer, <br>                RESERVED, <br>                &amp;dwValueType, <br>                NULL, <br>                &amp;dwBufferSize); <br>        } <br>    } <br> <br>    // Fail, too bad... <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        goto BNT_BAILOUT; <br>    } <br> <br>    dwCounterSize = dwBufferSize; <br> <br>    // If ExplainText is needed, then <br>    // get size of help text and add that to the arrays <br>     <br>    if (bExplainTextButtonHit) { <br>        dwBufferSize = 0; <br>        lWin32Status = RegQueryValueEx ( <br>              hKeyNames, <br>              ExplainBuffer, <br>              RESERVED, <br>              &amp;dwValueType, <br>              NULL, <br>              &amp;dwBufferSize); <br> <br>        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT; <br>    <br>        dwHelpSize = dwBufferSize; <br>     } else { <br>        dwHelpSize = 0; <br>     } <br> <br>    return (AddNewName( <br>        hKeyNames, <br>        pCounterInfo, <br>        CounterBuffer, <br>        ExplainBuffer, <br>        dwLastId, <br>        dwCounterSize, <br>        dwHelpSize, <br>        LangIdUsed)); <br> <br> <br>BNT_BAILOUT: <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        dwLastError = GetLastError(); <br>    } <br> <br>    return NULL; <br>} <br> <br>  <br>LPWSTR <br>*BuildOldNameTable( <br>    HKEY          hKeyRegistry,   // handle to registry db with counter names <br>    LPWSTR        lpszLangId,     // unicode value of Language subkey <br>    PCOUNTERTEXT  pCounterInfo, <br>    LANGID        iLangId,         // lang ID of the lpszLangId <br>    DWORD         dwLastId <br>) <br>/*++ <br>    <br>BuildOldNameTable <br> <br>Arguments: <br> <br>    hKeyRegistry <br>            Handle to an open registry (this can be local or remote.) and <br>            is the value returned by RegConnectRegistry or a default key. <br> <br>    lpszLangId <br>            The unicode id of the language to look up. (English is 0x409) <br> <br>Return Value: <br>      <br>    pointer to an allocated table. (the caller must free it when finished!) <br>    the table is an array of pointers to zero terminated strings. NULL is <br>    returned if an error occured. <br> <br>--*/ <br>{ <br>    LPWSTR  *lpReturnValue = NULL; <br> <br>    LONG    lWin32Status; <br>    DWORD   dwValueType; <br>    DWORD   dwLastError; <br>    DWORD   dwBufferSize; <br>    DWORD   dwCounterSize; <br>    DWORD   dwHelpSize; <br>    HKEY    hKeyNames; <br>    TCHAR   tempBuffer [MiscTextLen] ; <br>    TCHAR   subLangId [ShortTextLen] ; <br>    LPWSTR  lpValueNameString; <br>    LANGID  LangIdUsed = iLangId; <br>    TCHAR   Slash[2]; <br> <br>    //initialize local variables <br>    hKeyNames = NULL; <br>    Slash[0] = L'\\'; <br>    Slash[1] = L'\0'; <br> <br>    // check for null arguments and insert defaults if necessary <br>    if (!lpszLangId) { <br>        lpszLangId = DefaultLangId; <br>        LangIdUsed = iLanguage ; <br>    } <br> <br>    // get size of string buffer <br>    lpValueNameString = tempBuffer ; <br> <br>    lstrcpy (lpValueNameString, NamesKey); <br>    lstrcat (lpValueNameString, Slash); <br>    lstrcat (lpValueNameString, lpszLangId); <br> <br>    lWin32Status = RegOpenKeyEx ( <br>        hKeyRegistry, <br>        lpValueNameString, <br>        RESERVED, <br>        KEY_READ, <br>        &amp;hKeyNames); <br> <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        // try take out the country ID <br>        LangIdUsed = MAKELANGID (LangIdUsed &amp; 0x0ff, LANG_NEUTRAL); <br>        TSPRINTF (subLangId, TEXT("%03x"), LangIdUsed); <br>        lstrcpy (lpValueNameString, NamesKey); <br>        lstrcat (lpValueNameString, Slash); <br>        lstrcat (lpValueNameString, subLangId); <br> <br>        lWin32Status = RegOpenKeyEx ( <br>                hKeyRegistry, <br>                lpValueNameString, <br>                RESERVED, <br>                KEY_READ, <br>                &amp;hKeyNames); <br>    } <br> <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        // try the EnglishLangId  <br>        if (!strsame(EnglishLangId, subLangId)) { <br> <br>            lstrcpy (lpValueNameString, NamesKey); <br>            lstrcat (lpValueNameString, Slash); <br>            lstrcat (lpValueNameString, EnglishLangId); <br> <br>            LangIdUsed = iEnglishLanguage ; <br> <br>            lWin32Status = RegOpenKeyEx ( <br>                hKeyRegistry, <br>                lpValueNameString, <br>                RESERVED, <br>                KEY_READ, <br>                &amp;hKeyNames); <br>        } <br>    } <br> <br>    // Fail, too bad... <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        goto BNT_BAILOUT; <br>    } <br> <br>    // get size of counter names and add that to the arrays <br>     <br> <br>    dwBufferSize = 0; <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyNames, <br>        Counters, <br>        RESERVED, <br>        &amp;dwValueType, <br>        NULL, <br>        &amp;dwBufferSize); <br> <br>    if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT; <br> <br>    dwCounterSize = dwBufferSize; <br> <br>    // If ExplainText is needed, then <br>    // get size of help text and add that to the arrays <br>     <br>    if (bExplainTextButtonHit) { <br>        dwBufferSize = 0; <br>        lWin32Status = RegQueryValueEx ( <br>              hKeyNames, <br>              Help, <br>              RESERVED, <br>              &amp;dwValueType, <br>              NULL, <br>              &amp;dwBufferSize); <br> <br>        if (lWin32Status != ERROR_SUCCESS) goto BNT_BAILOUT; <br>    <br>        dwHelpSize = dwBufferSize; <br>     } else { <br>        dwHelpSize = 0; <br>     } <br> <br>    lpReturnValue = AddNewName( <br>        hKeyNames, <br>        pCounterInfo, <br>        Counters, <br>        Help, <br>        dwLastId, <br>        dwCounterSize, <br>        dwHelpSize, <br>        LangIdUsed); <br> <br>    RegCloseKey (hKeyNames); <br> <br>    return lpReturnValue; <br> <br>BNT_BAILOUT: <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        dwLastError = GetLastError(); <br>    } <br> <br>    if (lpReturnValue) { <br>        MemoryFree ((LPVOID)lpReturnValue); <br>    } <br>     <br>    if (hKeyNames) RegCloseKey (hKeyNames); <br> <br>    return NULL; <br>} <br> <br>  <br>LPWSTR <br>*BuildNameTable( <br>    PPERFSYSTEM   pSysInfo, <br>    HKEY          hKeyRegistry,   // handle to registry db with counter names <br>    LPWSTR        lpszLangId,     // unicode value of Language subkey <br>    PCOUNTERTEXT  pCounterInfo, <br>    LANGID        iLangId         // lang ID of the lpszLangId <br>) <br>/*++ <br>    <br>BuildNameTable <br> <br>Arguments: <br> <br>    hKeyRegistry <br>            Handle to an open registry (this can be local or remote.) and <br>            is the value returned by RegConnectRegistry or a default key. <br> <br>    lpszLangId <br>            The unicode id of the language to look up. (English is 0x409) <br> <br>Return Value: <br>      <br>    pointer to an allocated table. (the caller must free it when finished!) <br>    the table is an array of pointers to zero terminated strings. NULL is <br>    returned if an error occured. <br> <br>--*/ <br>{ <br> <br>    LPWSTR  *lpReturnValue; <br>    LONG    lWin32Status; <br>    DWORD   dwLastError; <br>    DWORD   dwValueType; <br>    DWORD   dwLastHelp; <br>    DWORD   dwLastCounter; <br>    DWORD   dwLastId; <br>    DWORD   dwBufferSize; <br>    HKEY    hKeyValue; <br>    DWORD   dwSystemVersion; <br> <br> <br>    //initialize local variables <br>    lpReturnValue = NULL; <br>    hKeyValue = NULL; <br> <br> <br>    // open registry to get number of items for computing array size <br> <br>    lWin32Status = RegOpenKeyEx ( <br>        hKeyRegistry, <br>        NamesKey, <br>        RESERVED, <br>        KEY_READ, <br>        &amp;hKeyValue); <br>     <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        goto BNT_BAILOUT; <br>    } <br> <br>    // get number of items <br>     <br>    dwBufferSize = sizeof (dwLastHelp); <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyValue, <br>        LastHelp, <br>        RESERVED, <br>        &amp;dwValueType, <br>        (LPBYTE)&amp;dwLastHelp, <br>        &amp;dwBufferSize); <br> <br>    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) { <br>        goto BNT_BAILOUT; <br>    } <br> <br>    dwBufferSize = sizeof (dwLastCounter); <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyValue, <br>        LastCounter, <br>        RESERVED, <br>        &amp;dwValueType, <br>        (LPBYTE)&amp;dwLastCounter, <br>        &amp;dwBufferSize); <br> <br>    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) { <br>        goto BNT_BAILOUT; <br>    } <br> <br>    if (dwLastCounter &gt;= dwLastHelp) { <br>        dwLastId = dwLastCounter; <br>    } else { <br>        dwLastId = dwLastHelp; <br>    } <br>    <br>    // get system version <br>    dwBufferSize = sizeof (dwSystemVersion); <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyValue, <br>        SysVersion, <br>        RESERVED, <br>        &amp;dwValueType, <br>        (LPBYTE)&amp;dwSystemVersion, <br>        &amp;dwBufferSize); <br> <br>    if ((lWin32Status != ERROR_SUCCESS) || (dwValueType != REG_DWORD)) { <br>        pSysInfo-&gt;SysVersion = 0x10000;  <br>    } else { <br>        pSysInfo-&gt;SysVersion = dwSystemVersion; <br>    } <br> <br>    if (pSysInfo-&gt;SysVersion &lt;= 0x10000) { <br>        lpReturnValue = BuildOldNameTable ( <br>            hKeyRegistry, <br>            lpszLangId, <br>            pCounterInfo, <br>            iLangId, <br>            dwLastId) ; <br>    } else { <br>        lpReturnValue = BuildNewNameTable ( <br>            pSysInfo, <br>            lpszLangId, <br>            pCounterInfo, <br>            iLangId, <br>            dwLastId) ; <br>    } <br> <br>    RegCloseKey (hKeyValue); <br>    return lpReturnValue; <br> <br>BNT_BAILOUT: <br>    if (lWin32Status != ERROR_SUCCESS) { <br>        dwLastError = GetLastError(); <br>    } <br>    if (hKeyValue) RegCloseKey (hKeyValue); <br>    return NULL; <br>} <br> <br>DWORD GetSystemKey (PPERFSYSTEM pSysInfo, HKEY *phKeyMachine) <br>{ <br>    DWORD   dwStatus; <br> <br>   // connect to system registry <br> <br>    if (IsLocalComputer(pSysInfo-&gt;sysName) || <br>       (PlayingBackLog() &amp;&amp; PlaybackLog.pBaseCounterNames)) { <br>        *phKeyMachine = HKEY_LOCAL_MACHINE; <br>    } else if (lstrlen(pSysInfo-&gt;sysName) &lt; MAX_COMPUTERNAME_LENGTH+3) { <br>        try { <br>            dwStatus = RegConnectRegistry ( <br>                pSysInfo-&gt;sysName, <br>                HKEY_LOCAL_MACHINE, <br>                phKeyMachine); <br> <br>            if (dwStatus != ERROR_SUCCESS) { <br>                if (PlayingBackLog()) { <br>                    // If remote machine is not on and we are <br>                    // playing back log, then, use the counters from <br>                    // local machine. <br>                    *phKeyMachine = HKEY_LOCAL_MACHINE; <br>                } else { <br>                    return dwStatus; <br>                } <br>            } <br>        } finally { <br>            ; // nothing <br>        } <br>    } <br>    return 0; <br>} <br> <br> <br>DWORD GetSystemNames(PPERFSYSTEM pSysInfo) <br>{ <br>    HKEY    hKeyMachine = 0; <br>    DWORD   dwStatus; <br> <br>    if (dwStatus = GetSystemKey (pSysInfo, &amp;hKeyMachine)) { <br>         return dwStatus; <br>    } <br> <br>    // if here, then hKeyMachine is an open key to the system's  <br>    //  HKEY_LOCAL_MACHINE registry database <br> <br>    // only one language is supported by this approach. <br>    // multiple language support would: <br>    //  1.  enumerate language keys  <br>    //       and for each key: <br>    //  2.  allocate memory for structures <br>    //  3.  call BuildNameTable for each lang key. <br> <br>    pSysInfo-&gt;CounterInfo.pNextTable = NULL; <br>    pSysInfo-&gt;CounterInfo.dwLangId = iLanguage ;   // default Lang ID <br> <br>    if (PlayingBackLog() &amp;&amp; PlaybackLog.pBaseCounterNames) { <br>        pSysInfo-&gt;CounterInfo.TextString = LogBuildNameTable (pSysInfo) ;  <br>    } else { <br>        pSysInfo-&gt;CounterInfo.TextString = BuildNameTable ( <br>              pSysInfo, <br>              hKeyMachine, <br>              NULL,                               // use default <br>              &amp;pSysInfo-&gt;CounterInfo, <br>              0); <br>    } <br> <br>    if (hKeyMachine &amp;&amp; hKeyMachine != HKEY_LOCAL_MACHINE) { <br>        RegCloseKey (hKeyMachine) ; <br>    } <br> <br>    if (pSysInfo-&gt;CounterInfo.TextString == NULL) { <br>        return GetLastError(); <br>    } else { <br>        return ERROR_SUCCESS; <br>    } <br>} <br> <br>BOOL  GetHelpText( <br>    PPERFSYSTEM pSysInfo <br>    ) <br>{ <br>    LPWSTR  *lpCounterId; <br>    LPWSTR  lpHelpText; <br>    LONG    lWin32Status; <br>    DWORD   dwValueType; <br>    DWORD   dwArraySize; <br>    DWORD   dwBufferSize; <br>    DWORD   dwCounterSize; <br>    DWORD   dwHelpSize; <br>    NTSTATUS    Status; <br>    DWORD   dwLastId; <br>    TCHAR   Slash[2]; <br>      <br>    HKEY    hKeyNames; <br>     <br>    TCHAR   SysLangId [ShortTextLen] ; <br>    TCHAR   ValueNameString [MiscTextLen] ; <br>    HKEY    hKeyMachine = 0; <br>    DWORD   dwStatus; <br> <br>    SetHourglassCursor() ; <br> <br>    //initialize local variables <br>    lpHelpText = NULL; <br>    hKeyNames = hKeyMachine = NULL; <br>    Slash[0] = L'\\'; <br>    Slash[1] = L'\0'; <br> <br>    dwBufferSize = 0; <br> <br>    TSPRINTF (SysLangId, TEXT("%03x"), pSysInfo-&gt;CounterInfo.dwLangId) ; <br> <br>    if (pSysInfo-&gt;SysVersion &lt;= 0x10000) { <br>        // old version, get help from registry <br>        if (dwStatus = GetSystemKey (pSysInfo, &amp;hKeyMachine)) { <br>            goto ERROR_EXIT; <br>        } <br>     <br>        lstrcpy (ValueNameString, NamesKey); <br>        lstrcat (ValueNameString, Slash); <br>        lstrcat (ValueNameString, SysLangId); <br> <br>        lWin32Status = RegOpenKeyEx ( <br>                  hKeyMachine, <br>                  ValueNameString, <br>                  RESERVED, <br>                  KEY_READ, <br>                  &amp;hKeyNames); <br> <br>       if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT; <br>    } else { <br>        // new system version, get it from the HKEY_PERFORMANCE <br>        hKeyNames = pSysInfo-&gt;sysDataKey; <br>        lstrcpy (ValueNameString, ExplainNameStr); <br>        lstrcat (ValueNameString, SysLangId); <br>    } <br> <br>    dwHelpSize = 0; <br>    lWin32Status = RegQueryValueEx ( <br>              hKeyNames, <br>              pSysInfo-&gt;SysVersion &lt;= 0x010000 ? Help : ValueNameString, <br>              RESERVED, <br>              &amp;dwValueType, <br>              NULL, <br>              &amp;dwHelpSize); <br> <br>    if (lWin32Status != ERROR_SUCCESS || dwHelpSize == 0) goto ERROR_EXIT; <br> <br>    dwLastId = pSysInfo-&gt;CounterInfo.dwLastId; <br>    dwArraySize = (dwLastId + 1) * sizeof (LPWSTR); <br>    dwCounterSize = pSysInfo-&gt;CounterInfo.dwCounterSize; <br> <br>    // allocate another memory to get the help text <br>    lpHelpText = MemoryAllocate (dwHelpSize); <br>    if (!lpHelpText) goto ERROR_EXIT; <br> <br>    dwBufferSize = dwHelpSize; <br>    lWin32Status = RegQueryValueEx ( <br>        hKeyNames, <br>        pSysInfo-&gt;SysVersion &lt;= 0x010000 ? Help : ValueNameString, <br>        RESERVED, <br>        &amp;dwValueType, <br>        (LPVOID)lpHelpText, <br>        &amp;dwBufferSize); <br>                             <br>    if (lWin32Status != ERROR_SUCCESS) goto ERROR_EXIT; <br> <br>    // setup the help text pointers <br>    lpCounterId = pSysInfo-&gt;CounterInfo.TextString; <br>    Status = AddNamesToArray (lpHelpText, dwLastId, lpCounterId) ; <br>    if (Status != ERROR_SUCCESS) goto ERROR_EXIT; <br> <br>    pSysInfo-&gt;CounterInfo.dwHelpSize = dwHelpSize; <br> <br>    if (pSysInfo-&gt;SysVersion &lt;= 0x010000) <br>        RegCloseKey (hKeyNames); <br> <br>    if (hKeyMachine &amp;&amp; hKeyMachine != HKEY_LOCAL_MACHINE) { <br>        RegCloseKey (hKeyMachine) ; <br>    } <br> <br>    pSysInfo-&gt;CounterInfo.HelpTextString = lpHelpText; <br> <br>    SetArrowCursor() ; <br> <br>    return TRUE; <br> <br>ERROR_EXIT: <br> <br>    SetArrowCursor() ; <br> <br>    if (lpHelpText) { <br>        MemoryFree ((LPVOID)lpHelpText); <br>    } <br>     <br>    if (hKeyNames) { <br>        RegCloseKey (hKeyNames); <br>    } <br>    if (hKeyMachine &amp;&amp; hKeyMachine != HKEY_LOCAL_MACHINE) { <br>        RegCloseKey (hKeyMachine) ; <br>    } <br> <br>    return FALSE; <br>} <br> <br>// <br>//  QueryPerformanceName -Get a title, given an index <br>// <br>//Inputs: <br>// <br>//          pSysInfo        -   Pointer to sysinfo struct for the <br>//                              system in question <br>// <br>//    dwTitleIndex    -Index of Title entry <br>// <br>//          LangID          -   language in which title should be displayed <br>// <br>//    cbTitle    -# of char in the lpTitle buffer <br>// <br>//    lpTitle    -pointer to a buffer to receive the <br>//                              Title <br>// <br>//          Help            -   TRUE is help is desired, else counter or <br>//                              object is assumed <br>DWORD <br>QueryPerformanceName( <br>    PPERFSYSTEM pSysInfo, <br>    DWORD dwTitleIndex, <br>    LANGID LangID, <br>    DWORD cbTitle, <br>    LPTSTR lpTitle, <br>    BOOL Help <br>    ) <br>{ <br>    LPWSTR  lpTitleFound; <br>    NTSTATUS    Status; <br>    BOOL    bGetTextSuccess = TRUE ; <br> <br>    DBG_UNREFERENCED_PARAMETER(LangID); <br> <br>    if (Help &amp;&amp; pSysInfo-&gt;CounterInfo.dwHelpSize == 0) { <br>        // we have not get the help text yet, go get it <br>        bGetTextSuccess = GetHelpText (pSysInfo); <br>    } <br> <br>    if (!bGetTextSuccess) { <br>        Status = ERROR_INVALID_NAME; <br>        goto ErrorExit; <br>    } <br> <br>    if ((dwTitleIndex &gt; 0) &amp;&amp; (dwTitleIndex &lt;= pSysInfo-&gt;CounterInfo.dwLastId)) { <br>        // then title should be found in the array <br>        lpTitleFound = pSysInfo-&gt;CounterInfo.TextString[dwTitleIndex]; <br>        if (!lpTitleFound) { <br>            // no entry for this index <br>            Status = ERROR_INVALID_NAME; <br>        } <br>        else if ((DWORD)lstrlen(lpTitleFound) &lt; cbTitle) { <br>            lstrcpy (lpTitle, lpTitleFound); <br>            return (ERROR_SUCCESS); <br>        } else { <br>            Status = ERROR_MORE_DATA; <br>        } <br>    } else { <br> <br>        Status = ERROR_INVALID_NAME; <br>    } <br> <br>ErrorExit: <br>    // if here, then an error occured, so return a blank <br> </code></pre>
<p>
</p>
<pre><code>if ((DWORD)lstrlen (NULL_NAME) &lt; cbTitle) { <br>        lstrcpy (lpTitle, NULL_NAME); <br>    } <br> <br>    return Status;   // title not returned <br> <br>} <br> <br> <br>LONG <br>GetSystemPerfData ( <br>    IN HKEY hKeySystem, <br>    IN LPTSTR lpszValue, <br>    OUT PPERFDATA pPerfData,  <br>    OUT PDWORD pdwPerfDataLen <br>) <br>   {  // GetSystemPerfData <br>   LONG     lError ; <br>   DWORD    Type ; <br> <br>   // have to pass in a Type to RegQueryValueEx(W) or else it <br>   // will crash <br>   lError = RegQueryValueEx (hKeySystem, lpszValue, NULL, &amp;Type, <br>                            (LPSTR) pPerfData, pdwPerfDataLen) ; <br>   return (lError) ; <br>   }  // GetSystemPerfData <br> <br>             <br>BOOL CloseSystemPerfData (HKEY hKeySystem) <br>   {  // CloseSystemPerfData <br>   return (TRUE) ; <br>   }  // CloseSystemPerfData <br> <br> <br> <br>int CBLoadObjects (HWND hWndCB, <br>                   PPERFDATA pPerfData, <br>                   PPERFSYSTEM pSysInfo, <br>                   DWORD dwDetailLevel, <br>                   LPTSTR lpszDefaultObject, <br>                   BOOL bIncludeAll) <br>/* <br>   Effect:        Load into the combo box CB one item for each Object in <br>                  pPerfData. For each item, look up the object's name in <br>                  the registry strings associated with pSysInfo, and  <br>                  attach the object to the data field of the CB item. <br> <br>                  Dont add those objects that are more detailed than <br>                  dwDetailLevel.       <br> <br>                  Set the current selected CB item to the object named <br>                  lpszDefaultObject, or to the default object specified in  <br>                  pPerfData if lpszDefaultObject is NULL. <br>*/ <br>   {  // CBLoadObjects <br>   UINT           i ; <br>   int            iIndex ; <br>   PPERFOBJECT    pObject ; <br>   TCHAR          szObject [PerfObjectLen + 1] ; <br>   TCHAR          szDefaultObject [PerfObjectLen + 1] ; <br> <br>   CBReset (hWndCB) ; <br>   strclr (szDefaultObject) ; <br> <br>   pObject = FirstObject (pPerfData) ; <br> <br>   for (i = 0, pObject = FirstObject (pPerfData) ; <br>        i &lt; pPerfData-&gt;NumObjectTypes ; <br>        i++, pObject = NextObject (pObject)) <br>      {  // for <br>      if (pObject-&gt;DetailLevel &lt;= dwDetailLevel) <br>         {  // if <br>         strclr (szObject) ; <br>         QueryPerformanceName (pSysInfo, pObject-&gt;ObjectNameTitleIndex,  <br>                               0, PerfObjectLen, szObject, FALSE) ; <br> <br>         // if szObject not empty, add it to the Combo-box <br>         if (!strsame(szObject, NULL_NAME)) <br>            { <br>            iIndex = CBAdd (hWndCB, szObject) ; <br>            CBSetData (hWndCB, iIndex, (DWORD) pObject) ; <br> <br>            if ((LONG)pObject-&gt;ObjectNameTitleIndex == pPerfData-&gt;DefaultObject) <br>               lstrcpy (szDefaultObject, szObject) ; <br>            } // if szObject not empty <br>         }  // if <br>      }  // for <br> <br> <br>   if (bIncludeAll) <br>      { <br>      StringLoad (IDS_ALLOBJECTS, szObject) ; <br>      CBInsert (hWndCB, 0, szObject) ; <br>      // assume "ALL" is default unless overridden <br>      lstrcpy (szDefaultObject, szObject) ; <br>      } <br>       <br>   if (lpszDefaultObject) <br>      lstrcpy (szDefaultObject, lpszDefaultObject) ; <br> <br>   iIndex = CBFind (hWndCB, szDefaultObject) ; <br>   CBSetSelection (hWndCB, (iIndex != CB_ERR) ? iIndex : 0) ; <br> <br>   return (i) ; <br>   }  // CBLoadObjects <br>          <br> <br>int LBLoadObjects (HWND hWndLB, <br>                   PPERFDATA pPerfData, <br>                   PPERFSYSTEM pSysInfo, <br>                   DWORD dwDetailLevel, <br>                   LPTSTR lpszDefaultObject, <br>                   BOOL bIncludeAll) <br>/* <br>   Effect:        Load into the list box LB one item for each Object in <br>                  pPerfData. For each item, look up the object's name in <br>                  the registry strings associated with pSysInfo, and  <br>                  attach the object to the data field of the LB item. <br> <br>                  Dont add those objects that are more detailed than <br>                  dwDetailLevel.       <br> <br>                  Set the current selected LB item to the object named <br>                  lpszDefaultObject, or to the default object specified in  <br>                  pPerfData if lpszDefaultObject is NULL. <br>*/ <br>   {  // LBLoadObjects <br>   UINT           i ; <br>   int            iIndex ; <br>   PPERFOBJECT    pObject ; <br>   TCHAR          szObject [PerfObjectLen + 1] ; <br>   TCHAR          szDefaultObject [PerfObjectLen + 1] ; <br> <br>   LBReset (hWndLB) ; <br>   strclr (szDefaultObject) ; <br> <br>   pObject = FirstObject (pPerfData) ; <br> <br>   for (i = 0, pObject = FirstObject (pPerfData) ; <br>        i &lt; pPerfData-&gt;NumObjectTypes ; <br>        i++, pObject = NextObject (pObject)) <br>      {  // for <br>      if (pObject-&gt;DetailLevel &lt;= dwDetailLevel) <br>         {  // if <br>         strclr (szObject) ; <br>         QueryPerformanceName (pSysInfo, pObject-&gt;ObjectNameTitleIndex,  <br>                               0, PerfObjectLen, szObject, FALSE) ; <br> <br>         // if szObject is not empty, add it to the listbox <br>         if (!strsame(szObject, NULL_NAME)) <br>            { <br>            iIndex = LBAdd (hWndLB, szObject) ; <br>            LBSetData (hWndLB, iIndex, (DWORD) pObject) ; <br> <br>            if ((LONG)pObject-&gt;ObjectNameTitleIndex == pPerfData-&gt;DefaultObject) <br>               lstrcpy (szDefaultObject, szObject) ; <br>            } // if szObject is not empty <br>         } <br>      }  // for <br> <br> <br>   if (bIncludeAll) <br>      { <br>      StringLoad (IDS_ALLOBJECTS, szObject) ; <br>      LBInsert (hWndLB, 0, szObject) ; <br>         LBSetData (hWndLB, iIndex, (DWORD) NULL) ; <br>      // assume "ALL" is default unless overridden <br>      lstrcpy (szDefaultObject, szObject) ; <br>      } <br> <br>   if (lpszDefaultObject) <br>      lstrcpy (szDefaultObject, lpszDefaultObject) ; <br>       <br>   iIndex = LBFind (hWndLB, szDefaultObject) ; <br>   LBSetSelection (hWndLB, (iIndex != LB_ERR) ? iIndex : 0) ; <br> <br>   return (i) ; <br>   }  // LBLoadObjects <br>          <br> <br>/***************************************************************************\ <br>* GetObjectDef() <br>* <br>* Entry: pointer to data block and the number of the object type <br>* Exit:  returns a pointer to the specified object type definition <br>* <br>\***************************************************************************/ <br> <br>PERF_OBJECT_TYPE *GetObjectDef( <br>    PERF_DATA_BLOCK *pDataBlock, <br>    DWORD NumObjectType) <br>{ <br>    DWORD NumTypeDef; <br> <br>    PERF_OBJECT_TYPE *pObjectDef; <br> <br>    pObjectDef = FirstObject(pDataBlock); <br> <br>    for ( NumTypeDef = 0; <br>  NumTypeDef &lt; pDataBlock-&gt;NumObjectTypes; <br>  NumTypeDef++ ) { <br> <br>if ( NumTypeDef == NumObjectType ) { <br> <br>    return pObjectDef; <br>} <br>        pObjectDef = NextObject(pObjectDef); <br>    } <br>    return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetObjectDefByTitleIndex() <br>* <br>* Entry: pointer to data block and the title index of the object type <br>* Exit:  returns a pointer to the specified object type definition <br>* <br>\***************************************************************************/ <br> <br>PERF_OBJECT_TYPE *GetObjectDefByTitleIndex( <br>    PERF_DATA_BLOCK *pDataBlock, <br>    DWORD ObjectTypeTitleIndex) <br>{ <br>    DWORD NumTypeDef; <br> <br>    PERF_OBJECT_TYPE *pObjectDef; <br> <br>    pObjectDef = FirstObject(pDataBlock); <br> <br>    for ( NumTypeDef = 0; <br>  NumTypeDef &lt; pDataBlock-&gt;NumObjectTypes; <br>  NumTypeDef++ ) { <br> <br>        if ( pObjectDef-&gt;ObjectNameTitleIndex == ObjectTypeTitleIndex ) { <br> <br>    return pObjectDef; <br>} <br>        pObjectDef = NextObject(pObjectDef); <br>    } <br>    return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetObjectDefByName() <br>* <br>* Entry: pointer to data block and the name of the object type <br>* Exit:  returns a pointer to the specified object type definition <br>* <br>\***************************************************************************/ <br> <br>PERF_OBJECT_TYPE *GetObjectDefByName( <br>    PPERFSYSTEM pSystem, <br>    PERF_DATA_BLOCK *pDataBlock, <br>    LPTSTR pObjectName) <br>{ <br>    DWORD NumTypeDef; <br>    TCHAR szObjectName [PerfObjectLen + 1] ; <br> <br>    PERF_OBJECT_TYPE *pObjectDef; <br> <br>    pObjectDef = FirstObject(pDataBlock); <br>    for ( NumTypeDef = 0; <br>  NumTypeDef &lt; pDataBlock-&gt;NumObjectTypes; <br>  NumTypeDef++ ) { <br> <br>        ObjectName (pSystem, pObjectDef, szObjectName, PerfObjectLen) ; <br>        if (strsame (szObjectName, pObjectName) ) { <br> <br>    return pObjectDef; <br>} <br>        pObjectDef = NextObject(pObjectDef); <br>    } <br>    return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetObjectIdByName() <br>* <br>* Entry: pointer to data block and the name of the object type <br>* Exit:  returns the Object title index for the specified Object Name <br>* <br>\***************************************************************************/ <br> <br>DWORD GetObjectIdByName( <br>    PPERFSYSTEM pSystem, <br>    PERF_DATA_BLOCK *pDataBlock, <br>    LPTSTR pObjectName) <br>{ <br>    DWORD NumTypeDef; <br>    TCHAR szObjectName [PerfObjectLen + 1] ; <br> <br>    PERF_OBJECT_TYPE *pObjectDef; <br> <br>    pObjectDef = FirstObject(pDataBlock); <br>    for ( NumTypeDef = 0; <br>  NumTypeDef &lt; pDataBlock-&gt;NumObjectTypes; <br>  NumTypeDef++ ) { <br> <br>        ObjectName (pSystem, pObjectDef, szObjectName, PerfObjectLen) ; <br>        if (strsame (szObjectName, pObjectName) ) { <br> <br>    return pObjectDef-&gt;ObjectNameTitleIndex; <br>} <br>        pObjectDef = NextObject(pObjectDef); <br>    } <br>    return 0; <br>} <br> <br> <br>/***************************************************************************\ <br>* GetCounterDef() <br>* <br>* Entry: pointer to object type definition the number of the Counter <br>* definition <br>* Exit:  returns a pointer to the specified Counter definition <br>* <br>\***************************************************************************/ <br> <br>PERF_COUNTER_DEFINITION *GetCounterDef( <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    DWORD NumCounter) <br>{ <br>    DWORD NumCtrDef; <br> <br>    PERF_COUNTER_DEFINITION *pCounterDef; <br> <br>    pCounterDef = FirstCounter(pObjectDef); <br> <br>    for ( NumCtrDef = 0; <br>  NumCtrDef &lt; pObjectDef-&gt;NumCounters; <br>  NumCtrDef++ ) { <br> <br>if ( NumCtrDef == NumCounter ) { <br> <br>    return pCounterDef; <br>} <br>        pCounterDef = NextCounter(pCounterDef); <br>    } <br>    return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetCounterNumByTitleIndex() <br>* <br>* Entry: pointer to object type definition and the title index of <br>*        the name of the Counter definition <br>* Exit:  returns the number of the specified Counter definition <br>* <br>\***************************************************************************/ <br> <br>LONG GetCounterNumByTitleIndex( <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    DWORD CounterTitleIndex) <br>{ <br>    DWORD NumCtrDef; <br> <br>    PERF_COUNTER_DEFINITION *pCounterDef; <br> <br>    pCounterDef = FirstCounter(pObjectDef); <br> <br>    for ( NumCtrDef = 0; <br>  NumCtrDef &lt; pObjectDef-&gt;NumCounters; <br>  NumCtrDef++ ) { <br> <br>        if ( pCounterDef-&gt;CounterNameTitleIndex == CounterTitleIndex ) { <br> <br>    return NumCtrDef; <br>} <br>        pCounterDef = NextCounter(pCounterDef); <br>    } <br>    return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetCounterData() <br>* <br>* Entry: pointer to object definition and number of counter, must be <br>* an object with no instances <br>* Exit:  returns a pointer to the data <br>* <br>\***************************************************************************/ <br> <br>PVOID GetCounterData( <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    PERF_COUNTER_DEFINITION *pCounterDef) <br>{ <br> <br>    PERF_COUNTER_BLOCK *pCtrBlock; <br> <br>    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pObjectDef + <br>      pObjectDef-&gt;DefinitionLength); <br> <br>    return (PVOID)((PCHAR)pCtrBlock + pCounterDef-&gt;CounterOffset); <br>} <br> <br>/***************************************************************************\ <br>* GetInstanceCounterData() <br>* <br>* Entry: pointer to object definition and number of counter, and a pointer <br>*        to the instance for which the data is to be retrieved <br>* Exit:  returns a pointer to the data <br>* <br>\***************************************************************************/ <br> <br>PVOID GetInstanceCounterData( <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    PERF_INSTANCE_DEFINITION *pInstanceDef, <br>    PERF_COUNTER_DEFINITION *pCounterDef) <br>{ <br> <br>    PERF_COUNTER_BLOCK *pCtrBlock; <br> <br>    pCtrBlock = (PERF_COUNTER_BLOCK *)((PCHAR)pInstanceDef + <br>      pInstanceDef-&gt;ByteLength); <br> <br>    return (PVOID)((PCHAR)pCtrBlock + pCounterDef-&gt;CounterOffset); <br>} <br> <br>/***************************************************************************\ <br>* GetNextInstance() <br>* <br>* Entry: pointer to instance definition <br>* Exit:  returns a pointer to the next instance definition.  If none, <br>*        points to byte past this instance <br>* <br>\***************************************************************************/ <br> <br>PERF_INSTANCE_DEFINITION *GetNextInstance( <br>    PERF_INSTANCE_DEFINITION *pInstDef) <br>{ <br>    PERF_COUNTER_BLOCK *pCtrBlock; <br> <br>    pCtrBlock = (PERF_COUNTER_BLOCK *) <br>                ((PCHAR) pInstDef + pInstDef-&gt;ByteLength); <br> <br>    return (PERF_INSTANCE_DEFINITION *) <br>           ((PCHAR) pCtrBlock + pCtrBlock-&gt;ByteLength); <br>} <br> <br>/***************************************************************************\ <br>* GetInstance() <br>* <br>* Entry: pointer to object type definition, the name of the instance, <br>* the name of the parent object type, and the parent instance index. <br>* The name of the parent object type is NULL if no parent. <br>* Exit:  returns a pointer to the specified instance definition <br>* <br>\***************************************************************************/ <br> <br>PERF_INSTANCE_DEFINITION *GetInstance( <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    LONG InstanceNumber) <br>{ <br> <br>   PERF_INSTANCE_DEFINITION *pInstanceDef; <br>   LONG NumInstance; <br> <br>   if (!pObjectDef) <br>      { <br>      return 0; <br>      } <br> <br>   pInstanceDef = FirstInstance(pObjectDef); <br>    <br>   for ( NumInstance = 0; <br>      NumInstance &lt; pObjectDef-&gt;NumInstances; <br>      NumInstance++ ) <br>      { <br>   if ( InstanceNumber == NumInstance ) <br>         { <br>         return pInstanceDef; <br>         } <br>      pInstanceDef = GetNextInstance(pInstanceDef); <br>      } <br> <br>   return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetInstanceByUniqueID() <br>* <br>* Entry: pointer to object type definition, and <br>*        the unique ID of the instance. <br>* Exit:  returns a pointer to the specified instance definition <br>* <br>\***************************************************************************/ <br> <br>PERF_INSTANCE_DEFINITION *GetInstanceByUniqueID( <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    LONG UniqueID) <br>{ <br> <br>    PERF_INSTANCE_DEFINITION *pInstanceDef; <br> <br>    LONG NumInstance; <br> <br>    pInstanceDef = FirstInstance(pObjectDef); <br> <br>    for ( NumInstance = 0; <br>  NumInstance &lt; pObjectDef-&gt;NumInstances; <br>  NumInstance++ ) { <br> <br>        if ( pInstanceDef-&gt;UniqueID == UniqueID ) { <br> <br>    return pInstanceDef; <br>} <br>        pInstanceDef = GetNextInstance(pInstanceDef); <br>    } <br>    return 0; <br>} <br> <br> <br>/***************************************************************************\ <br>* GetInstanceByNameUsingParentTitleIndex() <br>* <br>* Entry: pointer to object type definition, the name of the instance, <br>* and the name of the parent instance. <br>* The name of the parent instance is NULL if no parent. <br>* Exit:  returns a pointer to the specified instance definition <br>* <br>\***************************************************************************/ <br> <br>PERF_INSTANCE_DEFINITION *GetInstanceByNameUsingParentTitleIndex( <br>    PERF_DATA_BLOCK *pDataBlock, <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    LPTSTR pInstanceName, <br>    LPTSTR pParentName) <br>{ <br>   BOOL fHaveParent; <br>   PERF_OBJECT_TYPE *pParentObj; <br> <br>    PERF_INSTANCE_DEFINITION  *pParentInst, <br>     *pInstanceDef; <br> <br>   LONG   NumInstance; <br>   TCHAR  InstanceName[256]; <br>    <br> <br>   fHaveParent = FALSE; <br>   pInstanceDef = FirstInstance(pObjectDef); <br> <br>   for ( NumInstance = 0; <br>      NumInstance &lt; pObjectDef-&gt;NumInstances; <br>      NumInstance++ ) <br>      { <br> <br>      GetInstanceNameStr(pInstanceDef,InstanceName); <br>      if ( lstrcmp(InstanceName, pInstanceName) == 0 ) <br>         { <br> <br>         // Instance name matches <br> <br>         if ( pParentName == NULL ) <br>            { <br> <br>            // No parent, we're done <br> <br>            return pInstanceDef; <br> <br>            } <br>         else <br>            { <br> <br>            // Must match parent as well <br> <br>            pParentObj = GetObjectDefByTitleIndex( <br>               pDataBlock, <br>               pInstanceDef-&gt;ParentObjectTitleIndex); <br> <br>            if (!pParentObj) <br>               { <br>               // can't locate the parent, forget it <br>               break ; <br>               } <br> <br>            // Object type of parent found; now find parent <br>            // instance <br> <br>            pParentInst = GetInstance(pParentObj, <br>               pInstanceDef-&gt;ParentObjectInstance); <br> <br>            if (!pParentInst) <br>               { <br>               // can't locate the parent instance, forget it <br>               break ; <br>               } <br> <br>            GetInstanceNameStr(pParentInst,InstanceName); <br>            if ( lstrcmp(InstanceName, pParentName) == 0 ) <br>               { <br> <br>               // Parent Instance Name matches that passed in <br> <br>               return pInstanceDef; <br>               } <br>            } <br>         } <br>      pInstanceDef = GetNextInstance(pInstanceDef); <br>      } <br>   return 0; <br>} <br> <br>/***************************************************************************\ <br>* GetInstanceByName() <br>* <br>* Entry: pointer to object type definition, the name of the instance, <br>* and the name of the parent instance. <br>* The name of the parent instance is NULL if no parent. <br>* Exit:  returns a pointer to the specified instance definition <br>* <br>\***************************************************************************/ <br> <br>PERF_INSTANCE_DEFINITION *GetInstanceByName( <br>    PERF_DATA_BLOCK *pDataBlock, <br>    PERF_OBJECT_TYPE *pObjectDef, <br>    LPTSTR pInstanceName, <br>    LPTSTR pParentName) <br>{ <br>    BOOL fHaveParent; <br> <br>    PERF_OBJECT_TYPE *pParentObj; <br> <br>    PERF_INSTANCE_DEFINITION *pParentInst, <br>     *pInstanceDef; <br> <br>    LONG  NumInstance; <br>    TCHAR  InstanceName[256]; <br> <br> <br>    fHaveParent = FALSE; <br>    pInstanceDef = FirstInstance(pObjectDef); <br> <br>    for ( NumInstance = 0; <br>  NumInstance &lt; pObjectDef-&gt;NumInstances; <br>  NumInstance++ ) { <br> <br>        GetInstanceNameStr(pInstanceDef,InstanceName); <br>        if ( lstrcmp(InstanceName, pInstanceName) == 0 ) { <br> <br>    // Instance name matches <br> <br>    if ( !pInstanceDef-&gt;ParentObjectTitleIndex ) { <br> <br>// No parent, we're done <br> <br>return pInstanceDef; <br> <br>    } else { <br> <br>// Must match parent as well <br> <br>                pParentObj = GetObjectDefByTitleIndex( <br> pDataBlock, <br>                                 pInstanceDef-&gt;ParentObjectTitleIndex); <br> <br>// Object type of parent found; now find parent <br>// instance <br> <br>pParentInst = GetInstance(pParentObj, <br>  pInstanceDef-&gt;ParentObjectInstance); <br> <br>            GetInstanceNameStr(pParentInst,InstanceName); <br>                if ( lstrcmp(InstanceName, pParentName) == 0 ) { <br> <br>    // Parent Instance Name matches that passed in <br> <br>    return pInstanceDef; <br>} <br>    } <br>} <br>        pInstanceDef = GetNextInstance(pInstanceDef); <br>    } <br>    return 0; <br>}  // GetInstanceByName <br> <br> <br>BOOL FailedLineData (PPERFDATA pPerfData, <br>                     PLINE pLine) <br>/* <br>        This routine handles the case where there is no data for a <br>        system. <br>*/ <br> <br>{  // FailedLineData <br>   LONGLONG     liDummy ; <br> <br>   // System no longer exists. <br>   liDummy = (LONGLONG) 0; <br>   if (pLine-&gt;lnCounterType == PERF_COUNTER_TIMER_INV) <br>   { <br>      // Timer inverse with Performance Counter as timer <br>      pLine-&gt;lnaOldCounterValue[0] = pLine-&gt;lnOldTime ; <br>      pLine-&gt;lnaCounterValue[0] = pLine-&gt;lnNewTime ; <br>   } else if (pLine-&gt;lnCounterType == PERF_100NSEC_TIMER_INV || <br>              pLine-&gt;lnCounterType == PERF_100NSEC_MULTI_TIMER_INV) <br>   { <br>      // Timer inverse with System Time as timer <br>      pLine-&gt;lnaOldCounterValue[0] = pLine-&gt;lnOldTime100Ns ; <br>      pLine-&gt;lnaCounterValue[0] = pLine-&gt;lnNewTime100Ns ; <br>   } else <br>   { <br>      // Normal timer <br>      pLine-&gt;lnaOldCounterValue[0] = <br>      pLine-&gt;lnaCounterValue[0] = <br>      pLine-&gt;lnaOldCounterValue[1] = <br>      pLine-&gt;lnaCounterValue[1] = liDummy ; <br>   } <br>   return TRUE ; <br> <br>}  // FailedLineData <br> <br> <br>BOOL UpdateLineData (PPERFDATA pPerfData,  <br>                     PLINE pLine, <br>                     PPERFSYSTEM pSystem) <br>/* <br>   Assert:        pPerfData holds the performance data for the same <br>                  system as pLine. <br>*/ <br>{  // UpdateLineData <br>   PPERFOBJECT       pObject ; <br>   PPERFINSTANCEDEF  pInstanceDef ; <br>   PPERFCOUNTERDEF   pCounterDef ; <br>   PPERFCOUNTERDEF   pCounterDef2 ; <br>   PDWORD            pCounterValue ; <br>   PDWORD            pCounterValue2 ; <br>   UINT              iCounterIndex ; <br>   LONGLONG          liDummy[2] ; <br> <br>   // Use Object time units if available, otherwise use system <br>   // performance timer <br> <br>   pLine-&gt;lnOldTime = pLine-&gt;lnNewTime; <br> <br>   pLine-&gt;lnOldTime100Ns = pLine-&gt;lnNewTime100Ns; <br>   pLine-&gt;lnNewTime100Ns = *(LONGLONG UNALIGNED *)(&amp;pPerfData-&gt;PerfTime100nSec); <br> <br>   pLine-&gt;lnPerfFreq = *(LONGLONG UNALIGNED *)(&amp;pPerfData-&gt;PerfFreq) ; <br> <br>   if ((pLine-&gt;lnObject.TotalByteLength == 0) &amp;&amp; !(PlayingBackLog())) <br>   { <br>      // this is the case when openning a setting file and the remote <br>      // system is not up at that time.  We have all the names but no <br>      // pObject, pCounter, etc.  So, we have to re-built the linedata. <br>      PPERFOBJECT       pObject ; <br>      PPERFCOUNTERDEF   pCounter ; <br>      PPERFINSTANCEDEF  pInstance ; <br> <br>      pObject = LineFindObject (pSystem, pPerfData, pLine) ; <br>      if (!pObject) <br>      { <br>         //Something wrong, this object is still not there... <br>         return FALSE ; <br>      } <br>      pCounter = LineFindCounter (pSystem, pObject, pPerfData, pLine) ; <br>      if (!pCounter) <br>      { <br>         return FALSE ; <br>      } <br>      if (pObject &amp;&amp; <br>          pLine-&gt;lnObject.NumInstances &gt; 0 &amp;&amp; <br>          pLine-&gt;lnInstanceName == NULL) <br>      { <br>         return FALSE ; <br>      } <br>      pInstance = LineFindInstance (pPerfData, pObject, pLine) ; <br>      if (!pInstance) <br>      { <br>         if (pLine-&gt;lnParentObjName) <br>         { <br>            MemoryFree (pLine-&gt;lnParentObjName) ; <br>            pLine-&gt;lnParentObjName = NULL ; <br>         } <br>      } <br> <br>      pLine-&gt;lnCounterType = pCounter-&gt;CounterType; <br>      pLine-&gt;lnCounterLength = pCounter-&gt;CounterSize; <br> <br>      if (pSystem-&gt;lpszValue &amp;&amp; strsame (pSystem-&gt;lpszValue, L"Global")) <br>      { <br>         DWORD dwBufferSize = MemorySize (pSystem-&gt;lpszValue) ; <br>         memset (pSystem-&gt;lpszValue, 0, dwBufferSize) ; <br>      } <br> <br>      AppendObjectToValueList ( <br>                    pLine-&gt;lnObject.ObjectNameTitleIndex, <br>                    pSystem-&gt;lpszValue); <br> <br>       <br>   } <br> <br>   pObject = GetObjectDefByTitleIndex( <br>                pPerfData, <br>                pLine-&gt;lnObject.ObjectNameTitleIndex); <br> <br>   if (!pObject) <br>   { <br>      // Object Type no longer exists.  This is possible if we are <br>      // looking at a log file which has not always collected all <br>      // the same data, such as appending measurements of different <br>      // object types. <br> <br>      pCounterValue = <br>      pCounterValue2 = (PDWORD) liDummy; <br>      liDummy[0] = (LONGLONG)0; <br> <br> <br>      pLine-&gt;lnNewTime = *(LONGLONG UNALIGNED *)(&amp;pPerfData-&gt;PerfTime); <br> <br>      if (pLine-&gt;lnCounterType == PERF_COUNTER_TIMER_INV) <br>      { <br>         // Timer inverse with Performance Counter as timer <br>         pLine-&gt;lnaOldCounterValue[0] = pLine-&gt;lnOldTime ; <br>         pLine-&gt;lnaCounterValue[0] = pLine-&gt;lnNewTime ; <br>      } else if (pLine-&gt;lnCounterType == PERF_100NSEC_TIMER_INV || <br>                 pLine-&gt;lnCounterType == PERF_100NSEC_MULTI_TIMER_INV) <br>      { <br>         // Timer inverse with System Time as timer <br>         pLine-&gt;lnaOldCounterValue[0] = pLine-&gt;lnOldTime100Ns ; <br>         pLine-&gt;lnaCounterValue[0] = pLine-&gt;lnNewTime100Ns ; <br>      } else <br>      { <br>         // Normal timer or counter <br>         pLine-&gt;lnaOldCounterValue[0] = <br>         pLine-&gt;lnaCounterValue[0] = <br>         pLine-&gt;lnaOldCounterValue[1] = <br>         pLine-&gt;lnaCounterValue[1] = liDummy[0] ; <br>      } <br>      return TRUE ; <br>   } <br>   else <br>   { <br>      pCounterDef = &amp;pLine-&gt;lnCounterDef ; <br> <br>      if (pCounterDef-&gt;CounterType &amp; PERF_OBJECT_TIMER) { <br>         pLine-&gt;lnNewTime = *(LONGLONG UNALIGNED *)(&amp;pObject-&gt;PerfTime); <br>      } else { <br>         pLine-&gt;lnNewTime = *(LONGLONG UNALIGNED *)(&amp;pPerfData-&gt;PerfTime); <br>      } <br>     <br>      iCounterIndex = CounterIndex (pCounterDef, pObject) ; <br> <br>      // Get second counter, only if we are not at <br>      // the end of the counters; some computations <br>      // require a second counter <br> <br>      if (iCounterIndex &lt; pObject-&gt;NumCounters-1 &amp;&amp; iCounterIndex != -1) { <br>          pCounterDef2 = GetCounterDef(pObject, iCounterIndex+1); <br>      } else { <br>          pCounterDef2 = NULL; <br>      } <br> <br>      if (pObject-&gt;NumInstances &gt; 0) <br>      { <br> <br>          if ( pLine-&gt;lnUniqueID != PERF_NO_UNIQUE_ID ) { <br>              pInstanceDef = GetInstanceByUniqueID(pObject, <br>                                               pLine-&gt;lnUniqueID); <br>          } else { <br> <br>              pInstanceDef = <br>                  GetInstanceByNameUsingParentTitleIndex( <br>                      pPerfData, <br>                      pObject, <br>                      pLine-&gt;lnInstanceName, <br>                      pLine-&gt;lnPINName); <br>          } <br> <br>          if (pInstanceDef) { <br>              pLine-&gt;lnInstanceDef = *pInstanceDef; <br>              pCounterValue = GetInstanceCounterData(pObject, <br>                                               pInstanceDef, <br>                                               pCounterDef); <br>              if ( pCounterDef2 ) { <br>                  pCounterValue2 = GetInstanceCounterData(pObject, <br>                                                    pInstanceDef, <br>                                                    pCounterDef2); <br>              } <br>          } else { <br>              pCounterValue = <br>              pCounterValue2 = (PDWORD) liDummy; <br>              liDummy[0] = (LONGLONG) 0; <br>              liDummy[1] = (LONGLONG) 0; <br>          } <br> <br>          // Got everything... <br> <br>      } // instances exist, look at them for counter blocks <br> <br>      else <br>      { <br>          pCounterValue = GetCounterData(pObject, pCounterDef); <br>          if (pCounterDef2) <br>          { <br>              pCounterValue2 = GetCounterData(pObject, pCounterDef2); <br>          } <br> <br>      } // counter def search when no instances <br>   } <br> <br>   pLine-&gt;lnaOldCounterValue[0] = pLine-&gt;lnaCounterValue[0] ; <br> <br>   if (pLine-&gt;lnCounterLength &lt;= 4) <br>   { <br>       pLine-&gt;lnaCounterValue[0] = *pCounterValue; <br>       pLine-&gt;lnaCounterValue[0] &amp;= (LONGLONG) (0x0ffffffff) ; <br>   } <br>   else <br>   { <br>       pLine-&gt;lnaCounterValue[0] = *(LONGLONG UNALIGNED *) pCounterValue; <br>   } <br> <br>   // Get second counter, only if we are not at <br>   // the end of the counters; some computations <br>   // require a second counter <br> <br>   if ( pCounterDef2 ) { <br>       pLine-&gt;lnaOldCounterValue[1] = <br>           pLine-&gt;lnaCounterValue[1] ; <br>       if (pCounterDef2-&gt;CounterSize &lt;= 4) <br>       { <br>           pLine-&gt;lnaCounterValue[1] = *pCounterValue2; <br>           pLine-&gt;lnaCounterValue[1] &amp;= (LONGLONG) (0x0ffffffff) ; <br>       } <br>       else <br>           pLine-&gt;lnaCounterValue[1] = <br>               *((LONGLONG UNALIGNED *) pCounterValue2); <br>      } <br>   return (TRUE) ; <br>}  // UpdateLineData <br> <br> <br> <br>BOOL UpdateSystemData (PPERFSYSTEM pSystem,  <br>                       PPERFDATA *ppPerfData) <br>   {  // UpdateSystemData <br>   #define        PERF_SYSTEM_TIMEOUT (60L * 1000L) <br>   long           lError ; <br>   DWORD          Status ; <br>   DWORD          Size; <br> <br>   if (!ppPerfData) <br>      return (FALSE) ; <br> <br>   while (TRUE) <br>      { <br>      if (pSystem-&gt;FailureTime) <br>         { <br>         BOOL     TimeToCheck = FALSE ; <br>         DWORD    CurrentTickCount = GetTickCount() ; <br> <br>         if (CurrentTickCount &lt; pSystem-&gt;FailureTime) { <br>            // wrap-around case <br>            if (CurrentTickCount &gt;= PERF_SYSTEM_TIMEOUT) <br>               TimeToCheck = TRUE ; <br>            else if ( ~pSystem-&gt;FailureTime &gt;= PERF_SYSTEM_TIMEOUT) <br>               TimeToCheck = TRUE ; <br>            else if (CurrentTickCount + (~pSystem-&gt;FailureTime) &gt;= PERF_SYSTEM_TIMEOUT) <br>               TimeToCheck = TRUE ; <br>            } <br>         else { <br>            if (CurrentTickCount - pSystem-&gt;FailureTime &gt;= PERF_SYSTEM_TIMEOUT) <br>               TimeToCheck = TRUE ; <br>            } <br> <br>         if (TimeToCheck) <br>            { <br>            // free any memory hanging off this system <br>            SystemFree (pSystem, FALSE) ; <br> <br>            // get the registry info <br>            pSystem-&gt;sysDataKey = OpenSystemPerfData(pSystem-&gt;sysName) ; <br> <br>            Status = !ERROR_SUCCESS ; <br>            if (pSystem-&gt;sysDataKey)  <br>               { <br>               Status = GetSystemNames(pSystem); <br>               } </code></pre>
<p>
</p>
<pre><code><br>            if (Status != ERROR_SUCCESS) <br>               { <br>               // something wrong in getting the registry info, <br>               // remote system must be still down (??) <br>               pSystem-&gt;FailureTime = GetTickCount(); <br> <br>               // Free any memory that may have created <br>               SystemFree (pSystem, FALSE) ; <br> <br>               return (FALSE) ; <br>               } <br> <br>            // time to check again <br>            pSystem-&gt;FailureTime = 0 ; <br>            } <br>         else <br>            { <br>            // not time to check again <br>            return (FALSE) ; <br>            } <br>         } <br> <br>      if (pSystem-&gt;FailureTime == 0 ) <br>         { <br>         Size = MemorySize (*ppPerfData); <br> <br>         lError = GetSystemPerfData (pSystem-&gt;sysDataKey, <br>                                     pSystem-&gt;lpszValue, <br>                                     *ppPerfData, <br>                                     &amp;Size) ; <br>         if ((!lError) &amp;&amp; <br>            (Size &gt; 0) &amp;&amp; <br>            (*ppPerfData)-&gt;Signature[0] == (WCHAR)'P' &amp;&amp; <br>            (*ppPerfData)-&gt;Signature[1] == (WCHAR)'E' &amp;&amp; <br>            (*ppPerfData)-&gt;Signature[2] == (WCHAR)'R' &amp;&amp; <br>            (*ppPerfData)-&gt;Signature[3] == (WCHAR)'F' ) <br>            { <br>            if (pSystem-&gt;dwSystemState == SYSTEM_OK) <br>               { <br>               return (TRUE) ; <br>               } <br>            else if (pSystem-&gt;dwSystemState == SYSTEM_DOWN || <br>               pSystem-&gt;dwSystemState == SYSTEM_DOWN_RPT ) <br>               { <br>               pSystem-&gt;dwSystemState = SYSTEM_RECONNECT ; <br>               } <br>            else if (pSystem-&gt;dwSystemState == SYSTEM_RECONNECT_RPT) <br>               { <br>               pSystem-&gt;dwSystemState = SYSTEM_OK ; <br>               } <br>            // for SYSTEM_RECONNECT case, we want to wait for Alert <br>            // view to report the re-connection first <br>            return (TRUE) ; <br>            } <br> <br>         if (lError == ERROR_MORE_DATA) <br>            { <br>            *ppPerfData = MemoryResize (*ppPerfData,  <br>                                        MemorySize (*ppPerfData) + <br>                                        dwPerfDataIncrease) ; <br>            if (!*ppPerfData) <br>               { <br>               if (pSystem-&gt;dwSystemState != SYSTEM_DOWN_RPT) <br>                  { <br>                  pSystem-&gt;dwSystemState = SYSTEM_DOWN ; <br>                  } <br>               pSystem-&gt;FailureTime = GetTickCount(); <br>               return (FALSE) ; <br>               } <br>            } <br>         else <br>            { <br>            if (pSystem-&gt;dwSystemState != SYSTEM_DOWN_RPT) <br>               { <br>               pSystem-&gt;dwSystemState = SYSTEM_DOWN ; <br>               } <br>            pSystem-&gt;FailureTime = GetTickCount(); <br>            return (FALSE) ; <br>            }  // else <br>         } // if <br>      }  // while <br>   }  // UpdateSystemData <br> <br> <br> <br>BOOL FailedLinesForSystem (LPTSTR lpszSystem, <br>                           PPERFDATA pPerfData,  <br>                           PLINE pLineFirst) <br>   {  // FailedLinesForSystem <br>   PLINE          pLine ; <br>   BOOL           bMatchFound = FALSE ;   // no line from this system <br> <br>   for (pLine = pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for pLine <br>      if (strsamei (lpszSystem, pLine-&gt;lnSystemName)) <br>         { <br>         FailedLineData (pPerfData, pLine) ; <br>         if (pLine-&gt;bFirstTime) <br>            { <br>            pLine-&gt;bFirstTime-- ; <br>            } <br>         bMatchFound = TRUE ; // one or more lines from this system <br>         } <br>      }  // for pLine <br> <br>   return (bMatchFound) ; <br>   } <br> <br> <br>BOOL UpdateLinesForSystem (LPTSTR lpszSystem,  <br>                           PPERFDATA pPerfData,  <br>                           PLINE pLineFirst, <br>                           PPERFSYSTEM pSystem) <br>   {  // UpdateLinesForSystem <br>   PLINE          pLine ; <br>   BOOL           bMatchFound = FALSE ;   // no line from this system <br> <br>   for (pLine = pLineFirst ; <br>        pLine ; <br>        pLine = pLine-&gt;pLineNext) <br>      {  // for pLine <br>      if (strsamei (lpszSystem, pLine-&gt;lnSystemName)) <br>         { <br>         UpdateLineData (pPerfData, pLine, pSystem) ; <br>         if (pLine-&gt;bFirstTime) <br>            { <br>            pLine-&gt;bFirstTime-- ; <br>            } <br>         bMatchFound = TRUE ; // one or more lines from this system <br>         } <br>      }  // for pLine <br> <br>   return (bMatchFound) ; <br>   } <br> <br> <br>BOOL PerfDataInitializeInstance (void) <br>   { <br>//   pGlobalPerfData = MemoryAllocate (STARTING_SYSINFO_SIZE) ; <br>//   return (pGlobalPerfData != NULL) ; <br>   return (TRUE) ; <br>   } <br> <br>NTSTATUS  AddNamesToArray (LPTSTR lpNames, <br>   DWORD    dwLastId, <br>   LPWSTR   *lpCounterId) <br>   { <br>   LPWSTR      lpThisName; <br>   LPWSTR      lpStopString; <br>   DWORD       dwThisCounter; <br>   NTSTATUS    Status = ERROR_SUCCESS; <br>    <br>   for (lpThisName = lpNames; <br>        *lpThisName; <br>       ) <br>      { <br> <br>      // first string should be an integer (in decimal unicode digits) <br>      dwThisCounter = wcstoul(lpThisName, &amp;lpStopString, 10); <br> <br>      if ((dwThisCounter == 0) || (dwThisCounter == ULONG_MAX)) <br>      { <br>         Status += 1; <br>         goto ADD_BAILOUT;  // bad entry <br>      } <br> <br>      // point to corresponding counter name <br> <br>      while (*lpThisName++); <br> <br>      if (dwThisCounter &lt;= dwLastId) <br>         { <br> <br>         // and load array element; <br> <br>         lpCounterId[dwThisCounter] = lpThisName; <br> <br>         } <br> <br>      while (*lpThisName++); <br> <br>      } <br> <br>ADD_BAILOUT: <br>   return (Status) ; <br>   } <br> <br>// try the new way of getting data... <br> <br>BOOL UpdateLines (PPPERFSYSTEM ppSystemFirst, <br>                  PLINE pLineFirst) <br>   { <br>   PPERFSYSTEM       pSystem ; <br>   int               iNoUseSystemDetected = 0 ; <br>   int               NumberOfSystems = 0 ; <br>   DWORD             WaitStatus ; <br>   HANDLE            *lpPacketHandles ; <br>    <br>   // allocate the handle array for multiple wait <br>   if (NumberOfHandles == 0) <br>      { <br>      NumberOfHandles = MAXIMUM_WAIT_OBJECTS ; <br>      lpHandles = (HANDLE *) MemoryAllocate (NumberOfHandles * sizeof (HANDLE)) ; <br>      if (!lpHandles) <br>         { <br>         // out of memory, can't go on <br>         NumberOfHandles = 0 ; <br>         return FALSE ; <br>         } <br>      } <br> <br> <br>   for (pSystem = *ppSystemFirst ; <br>        pSystem ; <br>        pSystem = pSystem-&gt;pSystemNext) <br>      {  // for <br>       <br>      // lock the state data mutex, should be quick unless this thread  <br>      // is still getting data from last time <br>      if (pSystem-&gt;hStateDataMutex == 0) <br>         continue ; <br> <br>      WaitStatus = WaitForSingleObject(pSystem-&gt;hStateDataMutex, 100L); <br>      if (WaitStatus == WAIT_OBJECT_0) <br>         { <br>         ResetEvent (pSystem-&gt;hPerfDataEvent) ; <br>         pSystem-&gt;StateData = WAIT_FOR_PERF_DATA ; <br> <br>         // add this to the wait <br>         if (NumberOfSystems &gt;= NumberOfHandles) <br>            { <br>            NumberOfHandles += MAXIMUM_WAIT_OBJECTS ; <br>            lpHandles = (HANDLE *) MemoryResize ( <br>               lpHandles, <br>               NumberOfHandles * sizeof (HANDLE)) ; <br>            if (!lpHandles) <br>               { <br>               // out of memory, can't go on <br>               NumberOfHandles = 0 ; <br>               return FALSE ; <br>               } <br>            } <br> <br>         lpHandles [NumberOfSystems] = pSystem-&gt;hPerfDataEvent ; <br>         NumberOfSystems++ ; <br> <br>         // Send Message to thread to take a data sample <br>         PostThreadMessage ( <br>            pSystem-&gt;dwThreadID, <br>            WM_GET_PERF_DATA, <br>            (WPARAM)0, <br>            (LPARAM)0) ; <br> <br>         ReleaseMutex(pSystem-&gt;hStateDataMutex); <br>         } <br>      } <br> <br>   // wait for all the data  <br>   if (NumberOfSystems) <br>      { <br>      // increase timeout if we are monitoring lots of systems <br>      // For every additional 5 systems, add 5 more seconds <br>      lpPacketHandles = lpHandles ; <br>      do <br>         { <br>         WaitStatus = WaitForMultipleObjects ( <br>            min (NumberOfSystems, MAXIMUM_WAIT_OBJECTS), <br>            lpPacketHandles, <br>            TRUE,       // wait for all objects <br>            DataTimeOut + (NumberOfSystems / 5) * DEFAULT_DATA_TIMEOUT); <br> <br>         if (WaitStatus == WAIT_TIMEOUT || <br>            NumberOfSystems &lt;= MAXIMUM_WAIT_OBJECTS) <br>            { <br>//if (WaitStatus == WAIT_TIMEOUT) <br>//   mike2(TEXT("WaitTimeOut for %ld systems\n"), NumberOfSystems) ; <br> <br>            break ; <br>            } <br> <br>         // more systems --&gt; more to wait <br>         NumberOfSystems -= MAXIMUM_WAIT_OBJECTS ; <br>         lpPacketHandles += MAXIMUM_WAIT_OBJECTS ; <br>         } while (TRUE) ; <br> <br>      for (pSystem = *ppSystemFirst ; <br>           pSystem ; <br>           pSystem = pSystem-&gt;pSystemNext) <br>         {  // for <br> <br>         if (pSystem-&gt;hStateDataMutex == 0) <br>            continue ; <br>       <br>         // lock the state data mutex <br>         WaitStatus = WaitForSingleObject(pSystem-&gt;hStateDataMutex, 100L); <br>         if (WaitStatus == WAIT_OBJECT_0) <br>            { <br>            if (pSystem-&gt;StateData != PERF_DATA_READY) <br>               { <br>               if (!FailedLinesForSystem (pSystem-&gt;sysName, <br>                  pSystem-&gt;pSystemPerfData, <br>                  pLineFirst)) <br>                  { <br>                  if (!bAddLineInProgress) <br>                     { <br>                     // mark this system as no-longer-needed <br>                     iNoUseSystemDetected++ ; <br>                     pSystem-&gt;bSystemNoLongerNeeded = TRUE ; <br>                     } <br>                  } <br>               } <br>            else <br>               { <br>               if (!UpdateLinesForSystem (pSystem-&gt;sysName, <br>                    pSystem-&gt;pSystemPerfData, <br>                    pLineFirst, <br>                    pSystem)) <br>                  { <br>                  if (!bAddLineInProgress) <br>                     { <br>                     // mark this system as no-longer-needed <br>                     iNoUseSystemDetected++ ; <br>                     pSystem-&gt;bSystemNoLongerNeeded = TRUE ; <br>                     } <br>                  } <br>               } <br>            pSystem-&gt;StateData = IDLE_STATE ; <br>            ReleaseMutex(pSystem-&gt;hStateDataMutex); <br>            } <br>         else <br>            { <br>            if (!FailedLinesForSystem (pSystem-&gt;sysName, <br>               pSystem-&gt;pSystemPerfData, <br>               pLineFirst)) <br>               { <br>               if (!bAddLineInProgress) <br>                  { <br>                  // mark this system as no-longer-needed <br>                  iNoUseSystemDetected++ ; <br>                  pSystem-&gt;bSystemNoLongerNeeded = TRUE ; <br>                  } <br>               } <br>            } <br>         } <br> <br>      // check for un-used systems <br>      if (iNoUseSystemDetected) <br>          { <br>          // some unused system(s) detected. <br>          DeleteUnusedSystems (ppSystemFirst, iNoUseSystemDetected) ; <br>          } <br>      } <br> <br>   return (TRUE) ; <br>   }  // UpdateLines <br> <br>void PerfDataThread (PPERFSYSTEM pSystem) <br>   { <br>   MSG      msg ; <br>   BOOL     bGetPerfData ; <br>   DWORD    WaitStatus ; <br> <br>   while (GetMessage (&amp;msg, NULL, 0, 0)) <br>      { <br>      if (LOWORD(msg.message) == WM_GET_PERF_DATA) <br>         { <br> <br>         // this system has been marked as no long used, <br>         // forget about getting data and continue until  <br>         // we get to the WM_FREE_SYSTEM msg <br>         if (pSystem-&gt;bSystemNoLongerNeeded) <br>            continue ; <br> <br>         bGetPerfData = FALSE ; <br> <br>         if (!bAddLineInProgress || <br>            (pSystem-&gt;lpszValue &amp;&amp; <br>            !strsame (pSystem-&gt;lpszValue, L"Global"))) <br>            { <br>            bGetPerfData = UpdateSystemData (pSystem, &amp;(pSystem-&gt;pSystemPerfData)) ; <br>            } <br> <br>         WaitStatus = WaitForSingleObject(pSystem-&gt;hStateDataMutex, 1000L); <br>         if (WaitStatus == WAIT_OBJECT_0) <br>            { <br>            if (pSystem-&gt;StateData == WAIT_FOR_PERF_DATA) <br>               { <br>               pSystem-&gt;StateData = bGetPerfData ? <br>                  PERF_DATA_READY : PERF_DATA_FAIL ; <br>               } <br>            else <br>               { <br>//mike2(TEXT("Thread - System = %s, WaitStatus = %d\n"), <br>//pSystem-&gt;sysName, WaitStatus) ; <br>               } <br>            ReleaseMutex(pSystem-&gt;hStateDataMutex); <br>            SetEvent (pSystem-&gt;hPerfDataEvent) ; <br>            } <br>         }  // WM_GET_PERF_DATA MSG <br> <br>      else if (LOWORD(msg.message) == WM_FREE_SYSTEM) <br>         { <br>//mike2(TEXT("Thread - System = %s closing\n"), <br>//pSystem-&gt;sysName) ; <br>         // do the memory cleanup during SystemFree stage <br>         // cleanup all the data collection variables <br>         if (pSystem-&gt;hPerfDataEvent) <br>             CloseHandle (pSystem-&gt;hPerfDataEvent) ; <br> <br>         if (pSystem-&gt;hStateDataMutex) <br>             CloseHandle (pSystem-&gt;hStateDataMutex) ; <br> <br>         if (pSystem-&gt;pSystemPerfData) <br>             MemoryFree (pSystem-&gt;pSystemPerfData); <br> <br>         if (pSystem-&gt;lpszValue) { <br>             MemoryFree (pSystem-&gt;lpszValue); <br>             pSystem-&gt;lpszValue = NULL ; <br>         } <br> <br>         CloseHandle (pSystem-&gt;hThread); <br> <br>         MemoryFree (pSystem) ; <br>         break ;  // get out of message loop <br>         }  // WM_FREE_SYSTEM MSG <br>      }  // GetMessage Loop <br> <br>   ExitThread (TRUE) ; <br>   }  // PerfDataThread <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
