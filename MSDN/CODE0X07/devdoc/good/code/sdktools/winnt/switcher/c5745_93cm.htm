<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SWITCHER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5746"></a>SWITCHER.C</h2>
<pre><code>/**************************************************************************** <br>*  This is a part of the Microsoft Source Code Samples. <br>*  Copyright (C) 1995 Microsoft Corporation. <br>*  All rights reserved. <br>*  This source code is only intended as a supplement to <br>*  Microsoft Development Tools and/or WinHelp documentation. <br>*  See these sources for detailed information regarding the <br>*  Microsoft samples programs. <br>* <br>*****************************************************************************/ <br> <br>/**************************************************************************** <br> <br>        PROGRAM: desktop.c <br> <br>        PURPOSE: Allow user to switch between active desktops on the User's <br>        WindowStation <br> <br>        USAGE: desktop [-t #threads] <br>        #threads is the number of desktops and corresponding threads to create <br> <br>        APIS of Importance: <br>         CreateDesktop() <br>         SwitchDesktop() <br>         GetUserObjectInformation() <br>         GetThreadDesktop() <br>         SetThreadDesktop() <br>         CloseDesktop() <br>         OpenDesktop() <br> <br>        FUNCTIONS: <br>        WinMain <br>        StartNewDesktop <br>        CreateAllDesktops <br>        LoadResources <br>        InitApplication <br>        ThreadInit <br>        SaveScreen <br>        PaintMainWnd <br>        RunApp <br>        GetFontHeight <br>        TitleWindow <br>        CreateControls <br>        WndProc <br>        PreviewWndProc <br>        EditProc <br> <br> <br>        COMMENTS: This application demonstrates the multiple desktop <br>        capabilities of Windows NT 3.51, PPC release. <br> <br> <br> <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt;   // required for all Windows applications <br> <br>#include "switcher.h"   // specific to this program <br> <br>// <br>// Array of string resources <br>// <br>TCHAR SwitchStrings[LAST_STRING-FIRST_STRING + 1][MAXSTRLEN]; <br>#define PSZ(x) SwitchStrings[x-FIRST_STRING] <br> <br>// <br>// Structure used for thread-specific data <br>// <br>typedef struct _tdata <br>{ <br>   HDESK hDesk;     // desktop assigned to new thread <br>   int index;       // index into deskArray <br>   HWND hWndStatic; // "Run:" static control <br>   HWND hWndEdit;   // edit control for user input <br>   HWND hWndBtn;    // button for user input <br>   HWND hWndNew;    // button for new desktop <br>} ThreadData; <br> <br>int     gMaxIndex;                  // Highest index for array of desk handles <br>HWND    gBaseWindow;                // Window handle of default desktop window <br>HDESK   gDeskArray[MAX_THREADS];    // Global array of desktop handles <br>HWND    hWndArray[MAX_THREADS];     // Global array of window handles <br>HDC     gHDCArray[MAX_THREADS];     // global array of memory device contexts <br>                                    // these DCs store snapshots of the desktops <br>int gWidth, gHeight;                // dimensions of desktop rectangles <br> <br>// <br>// Keep track of how big the controls need to be to match the <br>// active system fixed font. These will help determine the <br>// minimum size of the switcher window. <br>// <br>int gStaticWidth;    //  Edit control label <br>int gEditWidth;      //  Edit control <br>int gBtnWidth;       //  Button to run app in edit control <br>int gNewWidth;       //  Button to create new desktop <br> <br>HINSTANCE ghInst = NULL;               // Global hInstance <br>#define DEFAULT_DESKTOP  gDeskArray[0] // For easy reading <br>LONG APIENTRY EditProc (HWND, UINT, WPARAM, LPARAM); <br>TCHAR szAppName[]     = TEXT("Desktop Switcher!"); <br>TCHAR szClassName[]   = TEXT("SwitcherWindow"); <br>TCHAR szPreviewClass[]= TEXT("PreviewWindow"); <br> <br>/**************************************************************************** <br>        FUNCTION: StartNewDesktop <br> <br>        PURPOSE: Create or open a handle to a desktop and put a switcher thread <br>        on it. <br> <br>        ARGUMENTS: <br>           int nCount - Which desktop number this is <br> <br>        Assumes gDeskArray[nCount] == NULL <br> <br>****************************************************************************/ <br> <br>void StartNewDesktop (int nCount) <br>{ <br>   ThreadData *ptd; <br>   TCHAR szDesk[50]; <br>   DWORD tID; <br>   ptd = (ThreadData*)GlobalAlloc(GMEM_FIXED,sizeof(ThreadData)); <br>   if (ptd) <br>   { <br>       ptd-&gt;index = nCount; <br>       // <br>       // Give the desktop a name. <br>       // <br>       wsprintf (szDesk, PSZ(IDS_DESKTOPNAME), nCount+1); <br>       // <br>       // First, try to open an existing desktop <br>       // <br>       if ( !(ptd-&gt;hDesk = OpenDesktop (szDesk, 0, FALSE, GENERIC_ALL))) <br>       { <br>       // <br>       // Failing an open, Create it <br>       // <br>          if (!(ptd-&gt;hDesk= CreateDesktop (szDesk, NULL, <br>                                        NULL,0,MAXIMUM_ALLOWED, <br>                                        NULL))) <br>          { <br> <br>                 MessageBox (NULL, PSZ(IDS_CREATEERROR), <br>                          PSZ(IDS_ERRCAPTION), MB_OK); <br>                 // <br>                 //Mark this array slot as invalid <br>                 // <br>                 gDeskArray[nCount] = NULL; <br> <br>          } <br> <br>       } <br>       if (ptd-&gt;hDesk) <br>       { <br>       // <br>       // Save the handle to the global array. Start the new thread <br>       // <br>           gDeskArray[ptd-&gt;index] = ptd-&gt;hDesk; <br>           CloseHandle(CreateThread(NULL, 0, <br>                        (LPTHREAD_START_ROUTINE)ThreadInit, <br>                        (LPVOID)ptd, 0, &amp;tID)); <br>       } <br>   } <br>    else <br>   { <br>       // <br>       // Out of memory <br>       // <br>       MessageBox (NULL, PSZ(IDS_CREATEERROR), <br>                      PSZ(IDS_MEMERRCAPTION), MB_OK); <br>       // <br>       //Mark this array slot as invalid <br>       // <br>       gDeskArray[nCount] = NULL; <br>   } <br> <br>} <br>/**************************************************************************** <br> <br>        FUNCTION: CreateAllDesktops (cThreads) <br> <br>        PURPOSE: Creates desktops and assigns a switcher thread to each. <br>        Updates the global desktop array. <br> <br>        ARGUMENTS: <br>          int cThreads - Number of threads/desktops to open or create <br> <br>****************************************************************************/ <br> <br>void CreateAllDesktops (int cThreads) <br>{ <br>   ThreadData *ptdDefault; <br> <br> <br>   // <br>   // Make sure we allocate for the default desktop first <br>   // <br>   ptdDefault = (ThreadData *)GlobalAlloc (GMEM_FIXED, sizeof(ThreadData)); <br>   if (!ptdDefault) { <br>      return; <br>   } <br>   while (cThreads) <br>   { <br>      StartNewDesktop (cThreads); <br>      cThreads--; <br>   } <br>   // <br>   // Main thread is one of the running threads too <br>   // <br>   ptdDefault-&gt;index = 0; <br>   ptdDefault-&gt;hDesk = DEFAULT_DESKTOP; <br>   ThreadInit((LPVOID)ptdDefault); <br> <br>} <br> <br>/**************************************************************************** <br> <br>        FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int) <br> <br>        PURPOSE: Creates the threads and desktops <br>        COMMENTS: Each thread has a separate desktop assigned to it. <br> <br> <br>****************************************************************************/ <br>int CALLBACK WinMain( <br>        HINSTANCE hInstance, <br>        HINSTANCE hPrevInstance, <br>        LPSTR lpCmdLine, <br>        int nCmdShow) <br>{ <br> <br>    int cThreads;                // number of desktops <br> <br>    ghInst = hInstance; <br> <br>    if (hPrevInstance) <br>    {       // Other instances of app running? <br>            return (FALSE);     // Exit <br>    } else { <br>       if (!InitApplication ()) { <br>          return FALSE; <br>       } <br>    } <br> <br>    // parse command line to determine number of desktops <br>    // Assume 9 threads <br> <br>    cThreads = 9; <br>    lpCmdLine = GetCommandLineA(); <br> <br>    // <br>    // Get past .exe name <br>    // <br>    while (*lpCmdLine != ' ' &amp;&amp; *lpCmdLine != 0) <br>        lpCmdLine++; <br> <br>    // <br>    // Find the parameters <br>    // <br>    while (*lpCmdLine != 0) <br>    { <br> <br>        // Eat white space <br> <br>        if (*lpCmdLine == ' ') <br>        { <br>            lpCmdLine++; <br>            continue; <br>        } <br> <br>        // <br>        // Do we have a dash? If not, just exit the loop <br>        // <br>        if (*lpCmdLine++ != '-') <br>            break; <br> <br>        switch (*lpCmdLine++) <br>        { <br>           case 't': <br>           case 'T': <br>            // <br>            // How many threads? <br>            // <br> <br>              while (*lpCmdLine == ' ') <br>                lpCmdLine++; <br> <br>              if (*lpCmdLine == 0 || *lpCmdLine == '-') <br>                continue; <br> <br>              cThreads = 0; <br>              while (*lpCmdLine &gt;= '0' &amp;&amp; *lpCmdLine &lt;= '9') <br>                 cThreads = cThreads * 10 + (*lpCmdLine++ - 0x30); <br>              break; <br> <br>        } <br>    } <br> <br>    // Create the threads - if zero was specified, default to 1. <br>    // What does 0 threads mean? <br>    if (cThreads == 0) <br>       cThreads = 1; <br>    else if (cThreads &gt; MAX_THREADS) <br>       cThreads = MAX_THREADS; <br>    // <br>    // Account for the main thread - only create extras <br>    // <br>    cThreads--; <br>    gMaxIndex = cThreads;          // Keep track of the highest array index <br> <br>    // <br>    // Assign this here, since threads reference it <br>    // <br>    DEFAULT_DESKTOP = GetThreadDesktop(GetCurrentThreadId()); <br>    CreateAllDesktops (cThreads); <br>    return 0; <br>} <br> <br>/************************************************************* <br>   FUNCTION: LoadResources <br> <br>   PURPOSE: Load string table entries <br> <br>   ARGUMENTS: None <br> <br>   RETURNS: True if all strings are loaded, False otherwise <br> <br>*************************************************************/ <br> <br>BOOL LoadResources (void) <br>{ <br>   int i; <br>   for (i=0;i&lt;(LAST_STRING-FIRST_STRING+1);i++) <br>   { <br>      if (!LoadString (ghInst, FIRST_STRING + i, SwitchStrings[i], MAXSTRLEN)) <br>          return FALSE; <br>   } <br>   return TRUE; <br>} <br>/************************************************************* <br> <br>   FUNCTION: InitApplication <br> <br>   PURPOSE: Register the window class and init global variables <br> <br>   ARGUMENTS: <br> <br>   RETURNS: <br>     TRUE if window class registration and other initialization succeeds <br> <br>**************************************************************/ <br> <br>BOOL InitApplication (void) { <br> <br>   WNDCLASS wc; <br>   HWND hTemp; <br>   HWINSTA hWndSta; <br>   RECT rect; <br> <br>   if (!LoadResources ()) <br>       return FALSE; <br>   // <br>   // Initialize the gHDCArray to all NULLS <br>   // <br>   ZeroMemory (gHDCArray, sizeof (gHDCArray)); <br>   hTemp = GetDesktopWindow(); // Call this so User will assign us a WindowStation. <br>   // <br>   // Initialize gWidth and gHeight <br>   // Get the size of the screen, make gWidth/gHeight == scrnW/scrnH <br>   // <br>   GetClientRect (hTemp, &amp;rect); <br>   gWidth = rect.right/DIVISOR; <br>   gHeight = rect.bottom/DIVISOR; <br> <br>   // <br>   // Make sure this app has a windowstation <br>   // <br>   hWndSta = GetProcessWindowStation(); <br>   if (!hWndSta) <br>   { <br>      MessageBox (NULL, PSZ(IDS_WNDSTAERROR), PSZ(IDS_ERRCAPTION), MB_OK); <br>      return FALSE; <br>   } <br>   // <br>   // Register the main window class <br>   // <br>   wc.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW; <br>   wc.lpfnWndProc = WndProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = 0; <br>   wc.hInstance = ghInst; <br>   wc.hIcon = LoadIcon (NULL, IDI_APPLICATION); <br>   wc.hCursor = LoadCursor (NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)GetStockObject (WHITE_BRUSH); <br>   wc.lpszMenuName = NULL; <br>   wc.lpszClassName = szClassName; <br> <br>   if (!RegisterClass (&amp;wc)) <br>   { <br>      return FALSE; <br>   } <br> <br>   // <br>   // Register the preview window class <br>   // <br>   wc.style = 0; <br>   wc.lpfnWndProc = PreviewWndProc; <br>   wc.lpszClassName = szPreviewClass; <br> <br>   if (!RegisterClass (&amp;wc)) { <br>      return FALSE; <br>   } <br> <br> <br>   return TRUE; <br>} <br> <br>/******************************************************************* <br> <br>   FUNCTION: ThreadInit <br> <br>   PURPOSE: Given a desktop handle, create a window on it to allow switching <br>   among desktops. <br> <br>   ARGUMENTS: <br>     LPVOID tData - Thread-specific data <br> <br>   RETURNS: <br>     nothing <br>********************************************************************/ <br> <br>void ThreadInit(LPVOID tData) <br>{ <br>    MSG msg; <br>    HWND hWnd; <br>    HDC hTemp; <br>    int width;           // window width <br>    USEROBJECTFLAGS uof; // To set Desktop attributes <br> <br>    uof.fInherit = FALSE;        // If an app inherits multiple desktop handles, <br>                                 // it could run on any one of those desktops <br>    uof.fReserved = FALSE; <br>    // <br>    // Let other account processes hook this desktop <br>    // <br>    uof.dwFlags = DF_ALLOWOTHERACCOUNTHOOK; <br>    SetUserObjectInformation (((ThreadData*)tData)-&gt;hDesk, <br>                              UOI_FLAGS, <br>                              (LPVOID)&amp;uof, <br>                              sizeof(uof)); <br>    // <br>    // Make sure the handle is valid <br>    // <br>    if (gDeskArray[((ThreadData*)tData)-&gt;index]) <br>    { <br>      // <br>      // Assign new desktop to this thread <br>      // <br>      SetThreadDesktop (((ThreadData*)tData)-&gt;hDesk); <br>      //  create the cool switcher window <br>      if ((gMaxIndex+1) * gWidth &gt; MINWINDOWWIDTH) <br>      { <br>         width = (gMaxIndex+1) * gWidth; <br>      } <br>      else <br>      { <br>         width = MINWINDOWWIDTH; <br>      } <br>      hWnd = CreateWindow (szClassName, <br>                     szAppName, <br>                     WS_MINIMIZEBOX|WS_OVERLAPPED|WS_VISIBLE|WS_BORDER|WS_CAPTION|WS_SYSMENU, <br>                     0, 0, width, 30+gHeight + CONTROLHEIGHT, <br>                     NULL, NULL, ghInst, tData); <br>      if (!hWnd) // bag it <br>      { <br>         gDeskArray[((ThreadData*)tData)-&gt;index] = NULL; <br>         GlobalFree (tData); <br>         return; <br>      } <br> <br>      // <br>      //update the global window array <br>      // <br>      hWndArray[((ThreadData*)tData)-&gt;index] = hWnd; <br> <br>    } <br>    else <br>    { <br> <br>       GlobalFree (tData); <br>       return; <br>    } <br> <br>    // <br>    // Acquire and dispatch messages until a WM_QUIT message is received. <br>    // <br>    while (GetMessage(&amp;msg, NULL,  0, 0)) <br>    { <br>                 TranslateMessage(&amp;msg);// Translates virtual key codes <br>                 DispatchMessage(&amp;msg); // Dispatches message to window <br>    } <br>    // <br>    // Switch back to the default desktop and close the user-created one <br>    // <br>    SetThreadDesktop (DEFAULT_DESKTOP); <br>    SwitchDesktop (DEFAULT_DESKTOP); <br>    CloseDesktop (((ThreadData*)tData)-&gt;hDesk); <br>    // <br>    // NULL out the global array entry so other threads won't try to switch to <br>    // this desktop <br>    // <br>    gDeskArray[((ThreadData*)tData)-&gt;index] = NULL; <br>    // <br>    // cleanup <br>    // <br>    hTemp = gHDCArray[((ThreadData*)tData)-&gt;index]; <br>    gHDCArray[((ThreadData*)tData)-&gt;index] = NULL; <br>    DeleteObject (hTemp); <br>    GlobalFree (tData); <br> <br>} <br> <br> <br>/*********************************************************************** <br> <br>   FUNCTION: SaveScreen <br> <br>   PURPOSE: Save a snapshot of the desktop to its corresponding <br>   memory DC. StretchBlt! <br> <br>   ARGUMENTS: <br>     int index - Index of memory DC to save bits to <br> <br>   RETURNS: nothing <br>************************************************************************/ <br> <br>void SaveScreen (int index) { <br>   HDC hdc; <br>   int xSize, ySize; <br> <br>   xSize = GetSystemMetrics (SM_CXSCREEN); <br>   ySize = GetSystemMetrics (SM_CYSCREEN); <br> <br>   if (hdc = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL)) <br>   { <br>      // <br>      // Copy the desktop to a memory DC <br>      // <br>      StretchBlt (gHDCArray[index], 0, 0, gWidth*2, gHeight*2, <br>               hdc, 0, 0, xSize, ySize, SRCCOPY); <br>      DeleteDC (hdc); <br>   } <br>} <br> <br>/******************************************************************************* <br> <br>     FUNCTION: PaintMainWnd <br> <br>     PURPOSE: Draw the main window. This window has rectangles with miniature snapshots <br>     of each desktop. The snapshots are retrieved from the gHDCArray and StretchBlt'd to <br>     the right size. <br> <br>     ARGUMENTS: <br>       HWND hWnd - Window to draw <br> <br>    RETURNS: nothing <br> <br>*******************************************************************************/ <br> <br>void PaintMainWnd (HWND hWnd) <br>{ <br>   PAINTSTRUCT ps; <br>   RECT rect; <br>   HPEN hPen, hOld; <br>   ThreadData *ptd; <br>   TCHAR szName[4];  // short name! <br>   int myThread; <br>   HDC hDC;          // always need a dc for drawing <br>   int i;            // my favorite loop counter <br> <br>   // <br>   // get the array index of this window <br>   // <br>   ptd = (ThreadData *)GetWindowLong (hWnd, GWL_USERDATA); <br>   myThread = ptd-&gt;index; <br> <br>   // <br>   //Draw a rectangle for each desktop <br>   // <br>   hDC = BeginPaint (hWnd, &amp;ps); <br>   if (GetClientRect (hWnd, &amp;rect)) <br>   { <br>      int right, left; <br>      // <br>      // leave space for edit control and button <br>      // <br>      rect.bottom -= CONTROLHEIGHT; <br>      hPen = CreatePen (PS_SOLID | PS_INSIDEFRAME, 2, RGB(255,16,16)); <br>      hOld = SelectObject (hDC, hPen); <br> <br>      // <br>      // draw each desktop rectangle <br>      // <br>      for (i=0;i&lt;=gMaxIndex;i++) <br>      { <br>         right = gWidth * i + gWidth; <br>         left = right - gWidth; <br>         // <br>         // If no snapshot is available, be boring <br>         // <br>         if (!gHDCArray[i]) <br>         { <br>            Rectangle (hDC, left, rect.top, right, gHeight); <br>            wsprintf (szName, TEXT("%d"), i+1); <br>            TextOut (hDC, left+(gWidth/2), <br>                     gHeight/2, szName, <br>                     lstrlen (szName)); <br>         } <br>         else <br>         { <br>            // <br>            // BitBlt the snapshot into the rectangle <br>            // <br>            StretchBlt (hDC, left, rect.top, gWidth, gHeight, <br>                    gHDCArray[i], 0, 0, gWidth*2, gHeight*2, SRCCOPY); <br>            // <br>            // draw lines around the rectangle <br>            // <br>            MoveToEx (hDC, left, rect.top, NULL); <br>            LineTo (hDC, left, gHeight); <br>            MoveToEx (hDC, right, rect.top, NULL); <br>            LineTo (hDC, right, gHeight); <br>            // <br>            // underline the active one <br>            // <br>            if (myThread == i) <br>            { <br>               MoveToEx (hDC, left, gHeight, NULL); <br>               LineTo (hDC, right, gHeight); <br>            } <br>         } <br>      } <br>      // <br>      // cleanup <br>      // <br>      SelectObject (hDC, hOld); <br>      DeleteObject (hPen); <br>   } <br> <br>   EndPaint (hWnd, &amp;ps); <br> <br>} <br> <br>/**************************************************************************** <br> <br>      FUNCTION: RunApp (HWND) <br> <br>      PURPOSE: Create a process, using contents of HWND's edit control <br>      as the command line. <br> <br>      ARGUMENTS: <br>        HWND hWnd - Handle of active switcher window <br> <br>      RETURNS: nothing <br> <br>      COMMENTS: Make sure proper desktop is passed in STARTUPINFO <br> <br> ****************************************************************************/ <br> <br>void RunApp (HWND hWnd) <br>{ <br>   TCHAR szDesk[100];          // data holder <br>   TCHAR szExec[100];       // Command line <br>   STARTUPINFO sui;         // Process startup info <br>   PROCESS_INFORMATION pi;  // info returned from CreateProcess <br>   ThreadData *ptd; <br> <br>   ptd = (ThreadData*)GetWindowLong (hWnd, GWL_USERDATA); <br>   // <br>   // Most sui members will be 0 <br>   // <br>   ZeroMemory ((PVOID)&amp;sui, sizeof(sui)); <br>   // <br>   //Get the command line to execute <br>   // <br>   GetDlgItemText (hWnd, IDC_RUNME, szExec, 100*sizeof(TCHAR)); <br>   // <br>   //Get the current desktop name <br>   // <br>   GetUserObjectInformation (GetThreadDesktop (GetCurrentThreadId()), <br>                             UOI_NAME, <br>                             szDesk, <br>                             100*sizeof(TCHAR), <br>                             NULL); <br>   sui.cb = sizeof (sui); <br>   // <br>   // Need the lpDesktop member so the new process runs on this desktop <br>   // The lpDesktop member was reserved in previous versions of NT <br>   // <br>   sui.lpDesktop = szDesk; <br>   CreateProcess (NULL,   // image name <br>                  szExec, // command line <br>                  NULL,   // process security attributes <br>                  NULL,   // thread security attributes <br>                  TRUE,   // inherit handles <br>                  CREATE_DEFAULT_ERROR_MODE|CREATE_SEPARATE_WOW_VDM, <br>                  NULL,   // environment block <br>                  NULL,   // current directory <br>                  &amp;sui,   // STARTUPINFO <br>                  &amp;pi);   // PROCESS_INFORMATION <br> <br>} <br>/**************************************************************************** <br>   FUNCTION: GetFontHeight <br> <br>   PURPOSE: Set up widths for controls based on size of the system <br>   font. <br> <br>   ARGUMENTS: <br>     HWND hWnd - Window whose DC to use. <br> <br>   RETURNS: <br>      Return the height of the system fixed font to use for <br>   the controls. <br> <br>****************************************************************************/ <br> <br>LONG GetFontHeight (HWND hWnd) <br>{ <br>   HDC hdc; <br>   TEXTMETRIC tm; <br>   SIZE size; <br>   #define MARGIN 7  // extra space on the button around the text <br> <br>   hdc = GetDC (hWnd); <br>   if (!GetTextMetrics (hdc, &amp;tm)) <br>   { <br>      // <br>      // Use defaults <br>      // <br>      gStaticWidth = STATICWIDTH; <br>      gBtnWidth    = BTNWIDTH; <br>      gEditWidth   = EDITWIDTH; <br>      gNewWidth    = BTNWIDTH + 25; <br>      return CONTROLHEIGHT; <br>   } <br> <br>   // <br>   // GetTextExtentPoint32 fills in size with the width and height of <br>   // a string. <br>   // <br>   GetTextExtentPoint32 (hdc, PSZ(IDS_RUNLABEL), lstrlen(PSZ(IDS_RUNLABEL)), &amp;size); <br>   gStaticWidth = size.cx + MARGIN; <br>   gEditWidth   = EDITWIDTH; <br>   GetTextExtentPoint32 (hdc, PSZ(IDS_BTNLABEL), lstrlen(PSZ(IDS_BTNLABEL)), &amp;size); <br>   gBtnWidth = size.cx + MARGIN; <br>   GetTextExtentPoint32 (hdc, PSZ(IDS_NEWLABEL), lstrlen(PSZ(IDS_NEWLABEL)), &amp;size); <br>   gNewWidth = size.cx + MARGIN; <br>   ReleaseDC (hWnd, hdc); <br>   return tm.tmHeight + 2; <br> <br>} <br> <br>/**************************************************************************** <br>        FUNCTION: TitleWindow <br> <br>        PURPOSE: Give a switcher window an appropriate title, using its <br>        desktop name. <br> <br>        ARGUMENTS: <br>          HWND hWnd - Window to title <br> <br>        RETURNS: nothing <br> <br>****************************************************************************/ <br> <br>void TitleWindow (HWND hWnd) <br>{ <br>   TCHAR *szTitle, *szName; <br>   UINT nBytes = 0; <br> <br>   // <br>   // How long is the desktop name? <br>   // <br>   GetUserObjectInformation (GetThreadDesktop(GetCurrentThreadId()), <br>                             UOI_NAME, <br>                             (LPVOID)&amp;nBytes, // not used since cbInfo is 0 <br>                             0, <br>                             &amp;nBytes); <br>   szName = (LPTSTR)GlobalAlloc (GPTR, nBytes); <br>   if (!szName) <br>   { <br>      return; <br>   } <br>   // <br>   // Now get the desktop name <br>   // <br>   GetUserObjectInformation (GetThreadDesktop(GetCurrentThreadId()), <br>                             UOI_NAME, <br>                             (LPVOID)szName, <br>                             nBytes, <br>                             &amp;nBytes); <br>   // <br>   // Now make the window title <br>   // <br>   szTitle = (LPTSTR)GlobalAlloc ( <br>           GPTR, <br>           (lstrlen(szAppName)+lstrlen(TEXT(" - "))) * sizeof(TCHAR) + nBytes); <br> <br>   if (!szTitle) <br>   { <br>      GlobalFree (szName); <br>      return; <br>   } <br>   wsprintf (szTitle, TEXT("%s - %s"), szAppName, szName); <br>   SetWindowText (hWnd, szTitle); <br>   // <br>   // Cleanup <br>   // <br>   GlobalFree (szName); <br>   GlobalFree (szTitle); <br>} <br> <br>/**************************************************************************** <br> <br>        FUNCTION: CreateControls (ThreadData *, HWND) <br> <br>        PURPOSE: Creates UI controls on a switcher window <br> <br>        ARGUMENTS: <br>          ThreadData *ptd  - Thread specific data to use/init <br>          HWND hWnd        - Parent window <br> <br>        RETURNS: <br>           nothing <br> <br> <br>****************************************************************************/ <br> <br>void CreateControls (ThreadData *ptd, HWND hWnd) <br>{ <br>   LONG oldproc; <br> <br>   // <br>   // Create the edit control label <br>   // <br>   ptd-&gt;hWndStatic = CreateWindow (TEXT("static"), PSZ(IDS_RUNLABELHOT), <br>                                   WS_CHILD | WS_VISIBLE, <br>                                   0,0,0,0, hWnd, (HMENU)IDC_STATIC, <br>                                   ghInst, NULL); <br>   // <br>   // Create the edit control <br>   // <br>   ptd-&gt;hWndEdit = CreateWindow (TEXT("Edit"), TEXT(""), <br>                         WS_BORDER | WS_CHILD | WS_VISIBLE | ES_AUTOHSCROLL, <br>                         0,0,0,0, hWnd, (HMENU)IDC_RUNME, <br>                         ghInst, NULL); <br> <br>   // <br>   // set the edit control proc and save the default one <br>   // <br>   oldproc = GetWindowLong (ptd-&gt;hWndEdit, GWL_WNDPROC); <br>   SetWindowLong (ptd-&gt;hWndEdit, GWL_WNDPROC, (LONG)EditProc); <br>   SetWindowLong (ptd-&gt;hWndEdit, GWL_USERDATA, oldproc); <br> <br>   // <br>   // Create the execution button <br>   // <br>   ptd-&gt;hWndBtn = CreateWindow (TEXT("Button"), PSZ(IDS_BTNLABEL), <br>                                WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, <br>                                0,0,0,0, hWnd, (HMENU)IDC_RUNMEBTN, <br>                                ghInst, NULL); <br>   // <br>   // Create a button for creating new desktops <br>   // <br>   ptd-&gt;hWndNew = CreateWindow (TEXT("button"), PSZ(IDS_NEWLABELHOT), <br>                                WS_CHILD | WS_VISIBLE, <br>                                0,0,0,0, hWnd, (HMENU)IDC_NEWDSKBTN, <br>                                ghInst, NULL); <br> <br>} <br>/**************************************************************************** <br> <br>        FUNCTION: WndProc(UINT, WPARAM, LPARAM) <br> <br>        PURPOSE:  Processes messages to the Switcher window <br> <br>        MESSAGES: <br>          WM_RBUTTONDOWN - Switch to desktop whose rectangle is under the mouse <br>          WM_CLOSE       - Send WM_CLOSE to all windows in hWndArray <br>          WM_LBUTTONDOWN - Create a preview window to display a larger view of <br>                           a desktop until WM_LBUTTONUP <br>          WM_COMMAND     - Respond to button pushes or edit control entry <br>          WM_SYSCHAR     - ALT+R sets focus to the edit control <br>                           ALT+N creates a new desktop <br>          WM_CHAR        - Carriage return executes command line from <br>                           the edit control <br>          WM_HOTKEY <br>          WM_KEYDOWN     - Respond to function keys by switching to <br>                           the appropriate desktop. Example, F2 means switch <br>                           to Desktop2. Ctrl-F# allows switching without <br>                           giving focus to the switcher window <br>          WM_LBUTTONUP   - Close the active preview window <br>          WM_CREATE      - Initialize controls and global array entries <br>          WM_SIZE        - Size the child controls correctly <br> <br> <br>        COMMENTS: <br> <br>****************************************************************************/ <br> <br>LONG APIENTRY WndProc( <br>    HWND hWnd, <br>    UINT message,      // type of message <br>    WPARAM wParam,     // additional information <br>    LPARAM lParam)     // additional information <br>{ <br> <br>    int newThread;      // Thread index to switch to <br>    int i; <br>    ThreadData *ptd; <br>    static HWND hShowing = NULL;           // which preview window is being shown <br>    static LONG fntHeight = CONTROLHEIGHT; // height for the edit control <br>    switch (message) <br>    { <br>       case WM_CREATE: <br>       { <br>          HDC hDC; <br>          HBITMAP hBmp; <br> <br>         // Create edit control, button, and label at the bottom of the window <br>         // This will allow the user to input a program to run <br> <br>         SetWindowLong (hWnd, GWL_USERDATA, <br>                        (LONG)((CREATESTRUCT *)lParam)-&gt;lpCreateParams); <br>         ptd = (ThreadData *)GetWindowLong (hWnd, GWL_USERDATA); <br>         CreateControls (ptd, hWnd); <br>         fntHeight = GetFontHeight (hWnd); <br>         // <br>         // initialize the DC array entry <br>         // <br>         hDC = CreateDC (TEXT("DISPLAY"), NULL, NULL, NULL); <br>         gHDCArray[ptd-&gt;index] = CreateCompatibleDC (hDC); <br>         // <br>         // Halftone is the best stretching algorithm <br>         // <br>         SetStretchBltMode (gHDCArray[ptd-&gt;index], HALFTONE); <br>         SetBrushOrgEx (gHDCArray[ptd-&gt;index], 0, 0, NULL); <br>         // <br>         // Use a bitmap the same size as the desktop preview rectangles <br>         // <br>         hBmp = CreateCompatibleBitmap (hDC, gWidth*2, gHeight*2); <br>         SelectObject (gHDCArray[ptd-&gt;index], hBmp); <br>         DeleteDC (hDC); <br>         SaveScreen (ptd-&gt;index); <br>         TitleWindow (hWnd); <br>         // <br>         // Register hot keys <br>         // <br>         for (i=0;i&lt;10;i++) <br>         { <br>            RegisterHotKey (hWnd, VK_F1+i, MOD_CONTROL, VK_F1+i); <br>         } <br>         return 0; <br>       } <br> <br>       case WM_SIZE: <br>       { <br>         // <br>         // Put the child controls at the right places <br>         // <br>          #define PADDING 5 <br> <br>          RECT rect; <br>          ThreadData *ptd; <br>          if (GetClientRect (hWnd, &amp;rect)) <br>          { <br>            ptd = (ThreadData *)GetWindowLong (hWnd, GWL_USERDATA); <br>            MoveWindow (ptd-&gt;hWndStatic, 0, rect.bottom - CONTROLHEIGHT, <br>                        gStaticWidth, fntHeight + PADDING, TRUE); <br> <br>            MoveWindow (ptd-&gt;hWndEdit, gStaticWidth + 5, <br>                        rect.bottom - fntHeight - PADDING, <br>                        gEditWidth, fntHeight+PADDING, TRUE); <br> <br>            MoveWindow (ptd-&gt;hWndBtn, gStaticWidth + gEditWidth + 10, <br>                        rect.bottom - fntHeight - PADDING, </code></pre>
<p>
</p>
<pre><code>gBtnWidth, fntHeight+PADDING, TRUE); <br> <br>            MoveWindow (ptd-&gt;hWndNew, gStaticWidth+gEditWidth+gBtnWidth+15, <br>                        rect.bottom - fntHeight- PADDING, <br>                        gNewWidth, fntHeight+PADDING, TRUE); <br> <br> <br>          } <br>          return 0; <br>       } <br>       case WM_PAINT: <br>          PaintMainWnd (hWnd); <br>          return 0; <br> <br>       case WM_RBUTTONDOWN: <br>       { <br>          // <br>          // Find the rectangle in which the button was pressed <br>          // <br>          POINTS pts; <br>          ThreadData *ptd; <br>          ptd = (ThreadData *)GetWindowLong(hWnd, GWL_USERDATA); <br>          pts = MAKEPOINTS (lParam); <br>          if (pts.y &gt; gHeight) <br>          { <br>             return 1; <br>          } <br>          newThread = pts.x/gWidth; <br> <br>          // <br>          // Get a snapshot of the current desktop <br>          // <br>          SaveScreen (ptd-&gt;index); <br> <br>          // <br>          // Switch to the selected desktop <br>          // <br>          if (!gDeskArray[newThread]) <br>          { <br>             StartNewDesktop (newThread); <br>          } <br>          if (!SwitchDesktop (gDeskArray[newThread])) <br>             MessageBox (hWnd, <br>                         PSZ(IDS_BADDESKTOP), <br>                         PSZ(IDS_ERRCAPTION), MB_OK); <br> <br>          return 0; <br>       } <br> <br>       case WM_LBUTTONDOWN: <br>       // <br>       // show the preview window <br>       // <br>       { <br>          POINTS pts; <br>          POINT ptl; <br>          int *index; <br> <br>          pts = MAKEPOINTS (lParam); <br>          if (pts.y &gt; gHeight) <br>          { <br>             return 1; <br>          } <br>          newThread = pts.x/gWidth; <br>          index = GlobalAlloc (GMEM_FIXED, sizeof(int)); <br>          if (!index) <br>          { <br>             return 1; <br>          } <br>          *index = newThread; <br>          // <br>          // Want to show the preview window where the button was clicked. <br>          // Map the given points to screen coords. <br>          // ClientToScreen is expecting a POINT structure, not a POINTS <br>          // <br>          ptl.x = (LONG)pts.x; <br>          ptl.y = (LONG)pts.y; <br>          ClientToScreen (hWnd, &amp;ptl); <br>          hShowing = CreateWindow (szPreviewClass, TEXT(""), <br>                                  WS_POPUP | WS_VISIBLE | WS_BORDER, <br>                                  ptl.x+3, <br>                                  ptl.y+3, <br>                                  gWidth*2, <br>                                  gHeight*2, <br>                                  hWnd, <br>                                  (HMENU)0, ghInst, (LPVOID)index); <br>          return 0; <br>       } <br> <br>       case WM_CHAR: <br>          if (wParam == VK_RETURN) <br>          { <br>              PostMessage (hWnd, WM_COMMAND, (WPARAM)IDC_RUNMEBTN, 0); <br>          } <br>          return 0; <br> <br>       case WM_SYSCHAR: <br>       { <br>          ThreadData *ptd; <br>          ptd = (ThreadData *)GetWindowLong(hWnd, GWL_USERDATA); <br>          switch (wParam) <br>          { <br>             // alt+r == focus on the edit control <br>             case TEXT('r'): <br>             case TEXT('R'): <br>                if (GetKeyState (VK_MENU)) <br>                { <br>                   SetFocus (ptd-&gt;hWndEdit); <br>                } <br>                return 0; <br>             // alt+n = create a new desktop <br>             case TEXT('n'): <br>             case TEXT('N'): <br>                if (GetKeyState (VK_MENU)) <br>                { <br>                   PostMessage (hWnd, WM_COMMAND, (WPARAM)IDC_NEWDSKBTN, 0); <br>                } <br>          } <br>          return 0; <br>       } <br>       case WM_HOTKEY: <br>       case WM_KEYDOWN: <br>          // <br>          // F1-F9 switches to corresponding desktop <br>          // <br> <br>          if ((wParam &gt;= VK_F1 &amp;&amp; wParam &lt;= VK_F10) <br>              &amp;&amp; (wParam - VK_F1 &lt;= (UINT)gMaxIndex)) <br>          { <br>             LONG x, y; <br>             x = (wParam - VK_F1) * gWidth + 2; <br>             y = gHeight - 4; <br>             PostMessage (hWnd, WM_RBUTTONDOWN, 0, MAKELPARAM (x, y)); <br>          } <br>          return 0; <br> <br>       case WM_SETFOCUS: <br>       case WM_NCLBUTTONUP: <br>       case WM_LBUTTONUP: <br> <br>         // <br>         // destroy the preview window <br>         // <br>         if (hShowing) <br>         { <br>            DestroyWindow (hShowing); <br>            hShowing = NULL; <br>         } <br>         return 0; <br> <br> <br> <br>       case WM_CLOSE: <br>         // <br>         // to be safe, check for a preview window <br>         // <br>         if (hShowing) <br>         { <br>            DestroyWindow (hShowing); <br>            hShowing = NULL; <br>         } <br>         // <br>         // go to the default desktop so the DestroyWindow calls all succeed <br>         // <br>         SwitchDesktop (DEFAULT_DESKTOP); <br>         // <br>         // kill the window on this desktop <br>         // all the windows will be destroyed if this is the default desktop <br>         // <br>         for (i=gMaxIndex;i&gt;=0;i--) <br>         { <br>            DestroyWindow (hWndArray[i]); <br>         } <br>         // <br>         // Unregister the hot keys <br>         // <br>         for (i=0;i&lt;10;i++) <br>         { <br>            UnregisterHotKey (hWnd,VK_F1+i); <br>         } <br>         return 0; <br> <br>       case WM_DESTROY:  // message: window being destroyed <br> <br>         PostQuitMessage(0); <br>         return 0; <br> <br> <br>       case WM_COMMAND: <br>       { <br> <br>          switch (LOWORD(wParam)) <br>          { <br>             case IDC_RUNMEBTN: <br>             { <br>                RunApp (hWnd); <br>                return 0; <br>             } <br> <br>             case IDC_NEWDSKBTN: <br>             // <br>             // Create a new desktop and resize the windows to show it. <br>             // <br>             { <br>                RECT rect; <br>                int i; <br>                if (gMaxIndex + 1 &lt; MAX_THREADS) <br>                { <br>                   gMaxIndex++; <br>                   StartNewDesktop (gMaxIndex); <br>                   GetWindowRect (hWnd,&amp;rect); <br>                   for (i=0;i&lt;gMaxIndex;i++) <br>                   { <br>                      MoveWindow (hWndArray[i], <br>                               rect.left, rect.top, <br>                               rect.right + gWidth, rect.bottom-rect.top, <br>                               TRUE); <br> <br>                   } <br>                } <br>               return 0; <br> <br>             } <br> <br>             default: <br>                return DefWindowProc (hWnd, message, wParam, lParam); <br>          } <br>       } <br> <br>    default:          // Passes it on if unprocessed <br>        return (DefWindowProc (hWnd, message, wParam, lParam)); <br>    } <br> <br>} <br> <br>/*********************************************************** <br> <br>     FUNCTION: PreviewWndProc <br> <br>     PURPOSE: Displays an enlarged view of the last snapshot of a desktop <br> <br>************************************************************/ <br> <br>LONG APIENTRY PreviewWndProc (HWND hWnd, <br>                              UINT msg, <br>                              WPARAM wParam, <br>                              LPARAM lParam) <br>{ <br> <br>   int *index; <br>   switch (msg) <br>   { <br>      case WM_CREATE: <br>         // <br>         // save the index <br>         // <br>         SetWindowLong (hWnd, GWL_USERDATA, <br>                       (LONG)((CREATESTRUCT *)lParam)-&gt;lpCreateParams); <br> <br>         return 0; <br> <br>      case WM_PAINT: <br>      { <br>         HDC hdc; <br>         PAINTSTRUCT ps; <br>         index = (int *)GetWindowLong (hWnd, GWL_USERDATA); <br>         hdc = BeginPaint (hWnd, &amp;ps); <br>         // <br>         // slap in the desktop picture <br>         // <br>         BitBlt (hdc, 0, 0, gWidth*2, gHeight*2, <br>                     gHDCArray[*index], 0, 0, SRCCOPY); <br>         EndPaint (hWnd, &amp;ps); <br>         return 0; <br>      } <br>      case WM_LBUTTONUP: <br>      { <br>         // <br>         // In case the button is released in my client area <br>         // <br>         HWND hp; <br>         hp = GetWindow (hWnd, GW_OWNER); <br>         PostMessage (hp, msg, wParam, lParam); <br>         return 0; <br>      } <br>      case WM_CLOSE: <br>      { <br>         // <br>         // cleanup the index pointer <br>         // <br>         index = (int *)GetWindowLong (hWnd, GWL_USERDATA); <br>         GlobalFree (index); <br> <br>         return DefWindowProc (hWnd, msg, wParam, lParam); <br>      } <br>      default: <br>          return DefWindowProc (hWnd, msg, wParam, lParam); <br> <br>   } <br>} <br> <br>/******************************************** <br> <br>     FUNCTION: EditProc <br> <br>     PURPOSE: subclass the edit control to handle carriage returns <br> <br> ********************************************/ <br> <br> LONG APIENTRY EditProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br> { <br>    if (WM_CHAR == msg &amp;&amp; (TCHAR)wParam == 0xD) <br>    { <br>       PostMessage (GetParent (hWnd), WM_COMMAND, (WPARAM)IDC_RUNMEBTN, 0); <br>       return 0; <br>    } <br>    // <br>    // call the default edit control procedure <br>    // <br>    return CallWindowProc ( (WNDPROC)GetWindowLong (hWnd, GWL_USERDATA), <br>                            hWnd,  msg, wParam, lParam); <br> } </code></pre>
<p>&nbsp;</p></body>
</HTML>
