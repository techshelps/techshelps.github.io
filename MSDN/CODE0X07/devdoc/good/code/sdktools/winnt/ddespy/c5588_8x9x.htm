<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TESTSUBS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5595"></a>TESTSUBS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> * TESTSUBS.C <br> * <br> *   String formatting class, window procedure and helper functions <br> */ <br> <br>#define UNICODE <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include "ddespy.h" <br>#include "globals.h" <br> <br>#define OFF2P(psw, off)  ((TCHAR *)psw + off) <br>#define BOUND(n, min, max) ((n) &lt; (min) ? (min) : ((n) &gt; (max) ? (max) : n)) <br> <br>INT cyChar;                     /* Height of a line */ <br>INT cxChar; <br>INT cyDescent; <br> <br> <br>/***************************** Public  Function ****************************\ <br>* BOOL InitTestSubs( ) <br>* <br>* This routine MUST be called before using anything in this file.  Registers <br>* window classes, loads brushes, etc.  Returns TRUE if successful, FALSE <br>* otherwise. <br>* <br>\***************************************************************************/ <br> <br>BOOL InitTestSubs() <br>{ <br>    WNDCLASS cls; <br> <br>    cls.style =         0; <br>    cls.lpfnWndProc =   (WNDPROC)StrWndProc; <br>    cls.cbClsExtra =    0; <br>    cls.cbWndExtra =    sizeof(HANDLE); <br>    cls.hInstance =     hInst; <br>    cls.hIcon =         NULL; <br>    cls.hCursor =       LoadCursor(NULL, IDC_ARROW); <br>    cls.hbrBackground = (HBRUSH)COLOR_WINDOW; <br>    cls.lpszMenuName =  NULL; <br>    cls.lpszClassName = (LPCTSTR) RefString(IDS_STRINGCLASS); <br> <br>    if (!RegisterClass((WNDCLASS FAR * ) &amp; cls)) <br>        return(FALSE); <br> <br>    return(TRUE); <br>} <br> <br> <br>VOID CloseTestSubs( <br>HANDLE hInst) <br>{ <br>    UnregisterClass((LPCTSTR) RefString(IDS_STRINGCLASS), hInst); <br>} <br> <br> <br> <br>VOID NextLine( STRWND *psw) <br>{ <br>    psw-&gt;offBottomLine += psw-&gt;cchLine; <br>    if (psw-&gt;offBottomLine == psw-&gt;offBufferMax) <br>        psw-&gt;offBottomLine = psw-&gt;offBuffer; <br>    psw-&gt;offOutput = psw-&gt;offBottomLine; <br>    *OFF2P(psw, psw-&gt;offOutput) = TEXT('\0'); <br>} <br> <br> <br>/***************************** Public  Function ****************************\ <br>* VOID DrawString(hwnd, sz) <br>* <br>* This routine prints a string in the specified StringWindow class window. <br>* sz is a NEAR pointer to a zero-terminated string, which can be produced <br>* with wsprintf(). <br>\***************************************************************************/ <br> <br>VOID DrawString( HWND hwnd, TCHAR *sz) <br>{ <br>    register STRWND *psw; <br>    INT cLines = 1; <br>    HANDLE hpsw; <br> <br>    hpsw = (HANDLE)GetWindowLong(hwnd, 0); <br>    psw = (STRWND *)LocalLock(hpsw); <br> <br>    NextLine(psw); <br>    while (*sz) { <br>        switch (*sz) { <br>        case TEXT('\r'): <br>            break; <br> <br>        case TEXT('\n'): <br>            *OFF2P(psw, psw-&gt;offOutput++) = TEXT('\0'); <br>            NextLine(psw); <br>            cLines++; <br>            break; <br> <br>        default: <br>            *OFF2P(psw, psw-&gt;offOutput++) = *sz; <br>        } <br>        sz++; <br>    } <br>    *OFF2P(psw, psw-&gt;offOutput++) = TEXT('\0'); <br>    LocalUnlock(hpsw); <br> <br>    ScrollWindow(hwnd, 0, -((cyChar + cyDescent) * cLines), (LPRECT)NULL, <br>            (LPRECT)NULL); <br>    UpdateWindow(hwnd); <br>} <br> <br>/***************************** Public  Function ****************************\ <br>* "StringWindow" window class <br>* <br>* Windows of the "StringWindow" window class are simple scrolling text output <br>* windows that are refreshed properly as windows are rearranged.  A text buffer <br>* is maintained to store the characters as they are drawn. <br>* <br>* When creating a StringWindow window, lpCreateParams is actually a UINT <br>* containing the dimensions of the text buffer to be created, if 0L, then <br>* a 80 by 25 buffer is created. <br>* <br>\***************************************************************************/ <br> <br>LONG  CALLBACK StrWndProc(HWND hwnd, UINT msg, WPARAM wParam, UINT lParam) <br>{ <br>    HANDLE hpsw; <br>    PAINTSTRUCT ps; <br>    RECT rc; <br> <br>    switch (msg) { <br>    case WM_CREATE: <br>        cyChar = 14; <br>        cxChar = 8; <br>        cyDescent = 2; <br>        if (*(PUINT)lParam     == 0L) { <br>            *(PUINT)lParam     = MAKELONG(80, 50); <br>        } <br>        if (!StrWndCreate(hwnd, LOWORD(*(PUINT)lParam), HIWORD(*(PUINT)lParam))) <br>            return(TRUE); <br>        break; <br> <br>    case WM_SIZE: <br>        InvalidateRect(hwnd, NULL, TRUE); <br>        break; <br> <br>    case WM_DESTROY: <br>        if ((hpsw = (HANDLE)GetWindowLong(hwnd, 0)) != NULL) <br>            LocalFree(hpsw); <br>        break; <br> <br>    case WM_ERASEBKGND: <br>        GetClientRect(hwnd, (LPRECT) &amp;rc); <br>        FillRect((HDC) wParam, (LPRECT) &amp;rc, GetStockObject(WHITE_BRUSH)); <br>        break; <br> <br>    case WM_VSCROLL: <br>        scroll(hwnd, GET_WM_VSCROLL_CODE(wParam, lParam), <br>                GET_WM_VSCROLL_POS(wParam, lParam), SB_VERT); <br>        break; <br> <br>    case WM_HSCROLL: <br>        scroll(hwnd, GET_WM_HSCROLL_CODE(wParam, lParam), <br>                GET_WM_HSCROLL_POS(wParam, lParam), SB_HORZ); <br>        break; <br> <br>    case WM_PAINT: <br>        BeginPaint(hwnd, &amp;ps); <br>        PaintStrWnd(hwnd, &amp;ps); <br>        EndPaint(hwnd, &amp;ps); <br>        break; <br> <br>    default: <br>        return(DefWindowProc(hwnd, msg, wParam, lParam)); <br>        break; <br>    } <br>    return(0L); <br>} <br> <br> <br> <br>VOID scroll(HWND hwnd, UINT msg, UINT sliderpos, UINT style) <br>{ <br>    RECT rc; <br>    INT iPos; <br>    INT dn; <br>    HANDLE hpsw; <br>    register STRWND *psw; <br> <br>    GetClientRect(hwnd, (LPRECT) &amp;rc); <br>    iPos = GetScrollPos(hwnd, style); <br>    hpsw = (HANDLE)GetWindowLong(hwnd, 0); <br>    psw = (STRWND *)LocalLock(hpsw); <br> <br>    switch (msg) { <br>    case SB_LINEDOWN: <br>        dn =  1; <br>        break; <br> <br>    case SB_LINEUP: <br>        dn = -1; <br>        break; <br> <br>    case SB_PAGEDOWN: <br>        if (style == SB_VERT) { <br>            dn = rc.bottom / (cyChar + cyDescent); <br>        } else { <br>            dn = rc.right / cxChar; <br>        } <br>        break; <br> <br>    case SB_PAGEUP: <br>        if (style == SB_VERT) { <br>            dn = -rc.bottom / (cyChar + cyDescent); <br>        } else { <br>            dn = -rc.right / cxChar; <br>        } <br>        break; <br> <br>    case SB_THUMBTRACK: <br>    case SB_THUMBPOSITION: <br>        dn = sliderpos-iPos; <br>        break; <br> <br>    default: <br>        dn = 0; <br>    } <br>    if (style == SB_VERT) { <br>        if (dn = BOUND (iPos + dn, 0, psw-&gt;cLine) - iPos) { <br>            psw-&gt;cBottomLine -= dn; <br>            ScrollWindow (hwnd, 0, -dn * (cyChar + cyDescent), NULL, NULL); <br>            SetScrollPos (hwnd, SB_VERT, iPos + dn, TRUE); <br>        } <br>    } else /* style == SB_HORZ */ { <br>        if (dn = BOUND (iPos + dn, 0, psw-&gt;cchLine) - iPos) { <br>            psw-&gt;cLeftChar += dn; <br>            ScrollWindow (hwnd, -dn * cxChar, 0, NULL, NULL); <br>            SetScrollPos (hwnd, SB_HORZ, iPos + dn, TRUE); <br>        } <br>    } <br>    LocalUnlock(hpsw); <br>} <br> <br> <br> <br>BOOL StrWndCreate(HWND hwnd, INT cchLine, INT cLine) <br>{ <br>    register INT off; <br>    STRWND *psw; <br>    HANDLE hpsw; <br> <br>    if ((hpsw = LocalAlloc(LMEM_MOVEABLE, sizeof(STRWND) <br>   + (sizeof (TCHAR) * cchLine * cLine))) == NULL) <br>        return(FALSE); <br>    SetWindowLong(hwnd, 0, (UINT)hpsw); <br> <br> <br>    psw = (STRWND *)LocalLock(hpsw); <br>    psw-&gt;cchLine       = cchLine; <br>    psw-&gt;cLine         = cLine; <br>    off                = sizeof(STRWND); <br>    psw-&gt;offBuffer     = off; <br>    psw-&gt;offBufferMax  = off + cchLine * cLine; <br>    psw-&gt;offBottomLine = off; <br>    psw-&gt;offOutput     = off; <br>    psw-&gt;cBottomLine   = 0; <br>    psw-&gt;cLeftChar     = 0; <br> <br>    ClearScreen(psw); <br> <br>    SetScrollRange(hwnd, SB_VERT, 0, cLine, FALSE); <br>    SetScrollPos(hwnd, SB_VERT, cLine, TRUE); <br>    SetScrollRange(hwnd, SB_HORZ, 0, cchLine, TRUE); <br>    LocalUnlock(hpsw); <br>    return(TRUE); <br>} <br> <br> <br>VOID ClearScreen(register STRWND *psw) <br>{ <br>    register INT off; <br>    /* <br>     * Make all the lines empty <br>     */ <br>    off = psw-&gt;offBuffer; <br>    while (off &lt; psw-&gt;offBufferMax) { <br>        *OFF2P(psw, off) = TEXT('\0'); <br>        off += psw-&gt;cchLine; <br>    } <br>} <br> <br> <br> <br> <br>VOID PaintStrWnd( HWND hwnd, LPPAINTSTRUCT pps) <br>{ <br>    register STRWND *psw; <br>    register INT off; <br>    INT x; <br>    INT y; <br>    RECT rc, rcOut; <br>    HANDLE hpsw; <br> <br> <br>    SelectObject(pps-&gt;hdc, GetStockObject(SYSTEM_FIXED_FONT)); <br>    hpsw = (HANDLE)GetWindowLong(hwnd, 0); <br>    psw = (STRWND *)LocalLock(hpsw); <br> <br>    GetClientRect(hwnd, (LPRECT)&amp;rc); <br>    if (!pps-&gt;fErase) <br>        FillRect(pps-&gt;hdc, (LPRECT)&amp;rc, GetStockObject(WHITE_BRUSH)); <br> <br>    x = rc.left - cxChar * psw-&gt;cLeftChar; <br>    y = rc.bottom - cyDescent + (cyChar + cyDescent) * psw-&gt;cBottomLine; <br>    off = psw-&gt;offBottomLine; <br> <br>    if (&amp;pps-&gt;rcPaint != NULL) <br>        IntersectRect((LPRECT)&amp;rc, (LPRECT)&amp;rc, &amp;pps-&gt;rcPaint); <br> <br>    do { <br>        if (y &lt;= rc.top - cyDescent) <br>            break; <br>        if (y - cyChar &lt;= rc.bottom) { <br>            rcOut.left = x; <br>            rcOut.bottom = y + cyDescent; <br>            rcOut.right = 1000; <br>            rcOut.top = y - cyChar; <br>            DrawText(pps-&gt;hdc, (LPTSTR)OFF2P(psw, off), -1, (LPRECT)&amp;rcOut, <br>                    DT_LEFT | DT_VCENTER | DT_NOCLIP | DT_EXPANDTABS | <br>                    DT_EXTERNALLEADING | DT_NOPREFIX | DT_TABSTOP | 0x0400); <br>        } <br>        y -= cyChar + cyDescent; <br>        /* <br>         * Back up to previous line <br>         */ <br>        if (off == psw-&gt;offBuffer) <br>            off = psw-&gt;offBufferMax; <br>        off -= psw-&gt;cchLine; <br>    } while (off != psw-&gt;offBottomLine); <br>    LocalUnlock(hpsw); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
