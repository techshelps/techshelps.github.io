<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LISTS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5592"></a>LISTS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> * LISTS.C <br> * <br> * This file implements a generalized multi-collumn listbox with a standard <br> * frame window. <br> */ <br>#define UNICODE <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "ddespy.h" <br>#include "globals.h" <br>#include "lists.h" <br> <br>int  CompareItems(LPTSTR psz1, LPTSTR psz2, INT SortCol, INT cCols); <br>int  CmpCols(LPTSTR psz1, LPTSTR psz2, INT SortCol); <br>void DrawLBItem(LPDRAWITEMSTRUCT lpdis); <br>long CALLBACK MCLBClientWndProc(HWND hwnd, UINT msg, WPARAM wParam, LONG lPAram); <br> <br>UINT cyHeading; <br> <br> <br>#ifdef UNICODE <br> <br>#define atoi    atoiW <br> <br> <br>//********************************************************************* <br>// <br>//  atoiW <br>// <br>//      Unicode version of atoi. <br>// <br> <br>INT atoiW (LPTSTR s) { <br>   INT i = 0; <br> <br>   while (isdigit (*s)) { <br>      i = i*10 + (BYTE)*s - TEXT('0'); <br>      s++; <br>   } <br>   return i; <br>} <br> <br>#endif <br> <br>HWND CreateMCLBFrame( <br>                    HWND hwndParent, <br>                    LPTSTR lpszTitle,        // frame title string <br>                    UINT dwStyle,          // frame styles <br>                    HICON hIcon, <br>                    HBRUSH hbrBkgnd,        // background for heading. <br>                    LPTSTR lpszHeadings)     // tab delimited list of headings.  The number of <br>                        // headings indicate the number of collumns. <br>{ <br>    static BOOL fRegistered = FALSE; <br>    MCLBCREATESTRUCT mclbcs; <br> <br>    if (!fRegistered) { <br>        WNDCLASS wc; <br>        HDC hdc; <br>        TEXTMETRIC tm; <br> <br>        wc.style = WS_OVERLAPPED | CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc = MCLBClientWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 4; <br>        wc.hInstance = hInst; <br>        wc.hIcon = hIcon; <br>        wc.hCursor = NULL; <br>        wc.hbrBackground = hbrBkgnd; <br>        wc.lpszMenuName = NULL; <br>        wc.lpszClassName = (LPCTSTR) RefString(IDS_LISTCLASS); <br>        RegisterClass(&amp;wc); <br> <br>        hdc = GetDC(GetDesktopWindow()); <br>        GetTextMetrics(hdc, &amp;tm); <br>        cyHeading = tm.tmHeight; <br>        ReleaseDC(GetDesktopWindow(), hdc); <br> <br>        fRegistered = TRUE; <br>    } <br>    mclbcs.lpszHeadings = lpszHeadings; <br> <br>    return(CreateWindow((LPCTSTR) RefString(IDS_LISTCLASS), <br>    (LPCTSTR) lpszTitle, dwStyle, <br>            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <br>            hwndParent, NULL, hInst, (LPVOID)&amp;mclbcs)); <br>} <br> <br> <br>LONG  CALLBACK MCLBClientWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    MCLBSTRUCT *pmclb; <br>    RECT rc; <br>    INT  i; <br> <br>    if (msg == WM_CREATE) { <br>        LPTSTR psz; <br>        MCLBCREATESTRUCT FAR *pcs; <br> <br>        pcs = (MCLBCREATESTRUCT FAR *)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>        pmclb = (MCLBSTRUCT *)LocalAlloc(LPTR, sizeof(MCLBSTRUCT)); <br>        psz = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) <br>      * (lstrlen(pcs-&gt;lpszHeadings) + 1)); <br>        lstrcpy((LPTSTR)psz, pcs-&gt;lpszHeadings); <br>        pmclb-&gt;pszHeadings = psz; <br>        pmclb-&gt;cCols = 1; <br>while (*psz) { <br>   if (*psz == '\t') { <br>      pmclb-&gt;cCols++; <br>   } <br>   psz++; <br>} <br>        pmclb-&gt;SortCol = 0; <br>        SetWindowLong(hwnd, 0, (UINT)pmclb); <br>        GetClientRect(hwnd, &amp;rc); <br>        pmclb-&gt;hwndLB = CreateWindow((LPCTSTR) RefString(IDS_LBOX), <br>      (LPCTSTR) szNULL, <br>       MYLBSTYLE | WS_VISIBLE, <br>               0, 0, 0, 0, hwnd, (HMENU)pmclb-&gt;cCols, hInst, NULL); <br>        return(pmclb-&gt;hwndLB ? 0 : -1); <br>    } <br> <br>    pmclb = (MCLBSTRUCT *)GetWindowLong(hwnd, 0); <br> <br>    switch (msg) { <br>    case WM_PAINT: <br>        { <br>            PAINTSTRUCT ps; <br>            DRAWITEMSTRUCT dis; <br> <br>            BeginPaint(hwnd, &amp;ps); <br>            SetBkMode(ps.hdc, TRANSPARENT); <br>            dis.hwndItem = hwnd; <br>            dis.hDC = ps.hdc; <br>            GetClientRect(hwnd, &amp;dis.rcItem); <br>            dis.rcItem.bottom = dis.rcItem.top + cyHeading; <br>            dis.CtlType = ODT_BUTTON;   // hack to avoid erasure <br>            dis.CtlID = pmclb-&gt;cCols; <br>            dis.itemID = 0; <br>            dis.itemAction = ODA_DRAWENTIRE; <br>            dis.itemData = (UINT)(LPTSTR)pmclb-&gt;pszHeadings; <br>            dis.itemState = 0; <br>            DrawLBItem(&amp;dis); <br>            EndPaint(hwnd, &amp;ps); <br>        } <br>        break; <br> <br>    case WM_SIZE: <br>        MoveWindow(pmclb-&gt;hwndLB, 0, cyHeading, LOWORD(lParam), <br>                HIWORD(lParam) - cyHeading, TRUE); <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>        { <br>            HWND hwndLB; <br>            INT i; <br> <br>            // determine which collumn the mouse landed and sort on that collumn. <br> <br>            SendMessage(hwnd, WM_SETREDRAW, 0, 0); <br>            GetClientRect(hwnd, &amp;rc); <br>            InflateRect(&amp;rc, -1, -1); <br>            pmclb-&gt;SortCol = LOWORD(lParam) * pmclb-&gt;cCols / (rc.right - rc.left); <br>            hwndLB = CreateWindow((LPCTSTR) RefString(IDS_LBOX), <br>    (LPCTSTR) szNULL, MYLBSTYLE, 1, cyHeading + 1, <br>                    rc.right - rc.left, rc.bottom - rc.top - cyHeading, <br>                    hwnd, (HMENU)pmclb-&gt;cCols, hInst, NULL); <br>            for (i = (INT)SendMessage(pmclb-&gt;hwndLB, LB_GETCOUNT, 0, 0); i; <br>   i--) { <br>                SendMessage(hwndLB, LB_ADDSTRING, 0, <br>                    SendMessage(pmclb-&gt;hwndLB, LB_GETITEMDATA, i - 1, 0)); <br>                SendMessage(pmclb-&gt;hwndLB, LB_SETITEMDATA, i - 1, 0); <br>            } <br>            ShowWindow(hwndLB, SW_SHOW); <br>            ShowWindow(pmclb-&gt;hwndLB, SW_HIDE); <br>            DestroyWindow(pmclb-&gt;hwndLB); <br>            pmclb-&gt;hwndLB = hwndLB; <br>            SendMessage(hwnd, WM_SETREDRAW, 1, 0); <br>            InvalidateRect(hwnd, NULL, FALSE); <br>        } <br>        break; <br> <br>    case WM_DELETEITEM: <br> <br>        if ((UINT)((LPDELETEITEMSTRUCT)lParam)-&gt;itemData) <br>            LocalFree(LocalHandle((PVOID)((LPDELETEITEMSTRUCT)lParam)-&gt;itemData)); <br>        break; <br> <br>    case WM_MEASUREITEM: <br>        ((LPMEASUREITEMSTRUCT)lParam)-&gt;itemHeight = cyHeading; <br>        break; <br> <br>    case WM_DRAWITEM: <br>        GetClientRect(hwnd, &amp;rc); <br>        // This fudge makes the collumns line up with the heading. <br>        ((LPDRAWITEMSTRUCT)lParam)-&gt;rcItem.right = rc.right; <br>        DrawLBItem((LPDRAWITEMSTRUCT)lParam); <br>        return(DefWindowProc(hwnd, msg, wParam, lParam)); <br>        break; <br> <br>    case WM_COMPAREITEM: <br>        return(CompareItems((LPTSTR)((LPCOMPAREITEMSTRUCT)lParam)-&gt;itemData1, <br>                (LPTSTR)((LPCOMPAREITEMSTRUCT)lParam)-&gt;itemData2, <br>                pmclb-&gt;SortCol, <br>                pmclb-&gt;cCols)); <br>        break; <br> <br>    case WM_DESTROY: <br>        LocalFree(LocalHandle((PVOID)pmclb-&gt;pszHeadings)); <br>        LocalFree(LocalHandle((PVOID)pmclb)); <br>        break; <br> <br>    case WM_CLOSE: <br>        for (i = 0; i &lt; IT_COUNT &amp;&amp; (hwndTrack[i] != hwnd); i++) { <br>            ; <br>        } <br>        pro.fTrack[i] = FALSE; <br>        hwndTrack[i] = NULL; <br>        SetFilters(); <br>        DestroyWindow(hwnd); <br>        break; <br> <br>    default: <br>        return(DefWindowProc(hwnd, msg, wParam, lParam)); <br>    } <br>} <br> <br> <br> <br> <br>/* <br> * Make this return FALSE if addition not needed. <br> * <br> * if pszSearch != NULL, searches for pszSearch - collumns may contain <br> * wild strings - TEXT("*") <br> * If found, the string is removed from the LB. <br> * Adds pszReplace to LB. <br> */ <br>VOID AddMCLBText(LPTSTR pszSearch, LPTSTR pszReplace, HWND hwndLBFrame) <br>{ <br>    MCLBSTRUCT *pmclb; <br>    INT lit; <br>    LPTSTR psz; <br> <br>    pmclb = (MCLBSTRUCT *)GetWindowLong(hwndLBFrame, 0); <br> <br>    SendMessage(pmclb-&gt;hwndLB, WM_SETREDRAW, 0, 0); <br>    if (pszSearch != NULL) { <br>        lit = (INT)SendMessage(pmclb-&gt;hwndLB, LB_FINDSTRING, (WPARAM)-1, (LONG)(LPTSTR)pszSearch); <br>        if (lit &gt;= 0) { <br>            SendMessage(pmclb-&gt;hwndLB, LB_DELETESTRING, lit, 0); <br>        } <br>    } <br>    psz = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * (lstrlen(pszReplace) + 1)); <br>    lstrcpy(psz, pszReplace); <br>    SendMessage(pmclb-&gt;hwndLB, WM_SETREDRAW, 1, 0); <br>    SendMessage(pmclb-&gt;hwndLB, LB_ADDSTRING, 0, (LONG)(LPTSTR)psz); <br>} <br> <br> <br>/* <br> * This function assumes that the text in cCol is an ASCII number.  0 is <br> * returned if it is not found. <br> */ <br>INT GetMCLBColValue(LPTSTR pszSearch, HWND hwndLBFrame, INT  cCol) <br>{ <br>    MCLBSTRUCT *pmclb; <br>    LPTSTR psz; <br>    INT lit; <br> <br>    pmclb = (MCLBSTRUCT *)GetWindowLong(hwndLBFrame, 0); <br> <br>    lit = (INT)SendMessage(pmclb-&gt;hwndLB, LB_FINDSTRING, (WPARAM)-1, <br>  (LPARAM)(LPTSTR)pszSearch); <br>    if (lit &lt; 0) { <br>        return(0); <br>    } <br>    psz = (LPTSTR)SendMessage(pmclb-&gt;hwndLB, LB_GETITEMDATA, lit, 0); <br>    while (--cCol &amp;&amp; (psz = wcschr(psz, '\t') + 1)) { <br>        ; <br>    } <br>    if (psz) { <br>        return(atoi(psz)); <br>    } else { <br>        return(0); <br>    } <br>} <br> <br> <br> <br>/* <br> * Returns fFoundAndRemoved <br> */ <br>BOOL DeleteMCLBText(LPTSTR pszSearch, HWND hwndLBFrame) <br>{ <br>    MCLBSTRUCT *pmclb; <br>    INT lit; <br> <br>    pmclb = (MCLBSTRUCT *)GetWindowLong(hwndLBFrame, 0); <br>    lit = (INT)SendMessage(pmclb-&gt;hwndLB, LB_FINDSTRING, (WPARAM)-1, <br>            (LONG)(LPTSTR)pszSearch); <br>    if (lit &gt;= 0) { <br>        SendMessage(pmclb-&gt;hwndLB, LB_DELETESTRING, lit, 0); <br>        return(TRUE); <br>    } <br>    return(FALSE); <br>} <br> <br> <br>/* <br> * Returns &gt;0 if item1 comes first, &lt;0 if item2 comes first, 0 if ==. <br> */ <br>INT CompareItems(LPTSTR psz1, LPTSTR psz2, INT SortCol, INT cCols) <br>{ <br>    INT i, Col; <br> <br>    i = CmpCols(psz1, psz2, SortCol); <br>    if (i != 0) { <br>        return(i); <br>    } <br>    for (Col = 0; Col &lt; cCols; Col++) { <br>        if (Col == SortCol) { <br>            continue; <br>        } <br>        i = CmpCols(psz1, psz2, Col); <br>        if (i != 0) { <br>            return(i); <br>        } <br>    } <br>    return(0); <br>} <br> <br> <br>INT CmpCols(LPTSTR psz1, LPTSTR psz2, INT SortCol) <br>{ <br>    LPTSTR psz, pszT1, pszT2; <br>    INT iRet; <br> <br>    while (SortCol--) { <br>        psz = wcschr(psz1, '\t'); <br>        if (psz != NULL) { <br>            psz1 = psz + 1; <br>        } else { <br>            psz1 = psz1 + lstrlen(psz1); <br>        } <br>        psz = wcschr(psz2, '\t'); <br>        if (psz != NULL) { <br>            psz2 = psz + 1; <br>        } else { <br>            psz2 = psz2 + lstrlen(psz2); <br>        } <br>    } <br>    pszT1 = wcschr(psz1, '\t'); <br>    pszT2 = wcschr(psz2, '\t'); <br> <br>    if (pszT1) { <br>        *pszT1 = '\0'; <br>    } <br>    if (pszT2) { <br>        *pszT2 = '\0'; <br>    } <br> <br>    if (!lstrcmp((LPCTSTR)RefString(IDS_WILD), psz1) <br>     || !lstrcmp((LPCTSTR) RefString(IDS_WILD), psz2)) { <br>        iRet = 0; <br>    } else { <br>        iRet = lstrcmp(psz1, psz2); <br>    } <br> <br>    if (pszT1) { <br>        *pszT1 = '\t'; <br>    } <br>    if (pszT2) { <br>        *pszT2 = '\t'; <br>    } <br> <br>    return(iRet); <br>} <br> <br> <br> <br>VOID DrawLBItem(LPDRAWITEMSTRUCT lpdis) <br>{ <br>    RECT rcDraw; <br>    INT cxSection; <br>    LPTSTR psz, pszEnd; <br> <br>    if (!lpdis-&gt;itemData) <br>        return; <br>    if ((lpdis-&gt;itemAction &amp; ODA_DRAWENTIRE) || <br>            ((lpdis-&gt;itemAction &amp; ODA_SELECT) &amp;&amp; <br>            (lpdis-&gt;itemState &amp; ODS_SELECTED))) { <br>        rcDraw = lpdis-&gt;rcItem; <br>        if (lpdis-&gt;CtlType != ODT_BUTTON) { // hack to avoid erasure <br>            HBRUSH hbr; <br> <br>            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>            FillRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem, hbr); <br>            DeleteObject(hbr); <br>        } <br>        cxSection = (rcDraw.right - rcDraw.left) / lpdis-&gt;CtlID; <br>        psz = (LPTSTR)(UINT)lpdis-&gt;itemData; <br>        rcDraw.right = rcDraw.left + cxSection; <br>        while (pszEnd = wcschr(psz, '\t')) { <br>            *pszEnd = '\0'; <br>            DrawText(lpdis-&gt;hDC, psz, -1, &amp;rcDraw, DT_LEFT); <br>            OffsetRect(&amp;rcDraw, cxSection, 0); <br>            *pszEnd = '\t'; <br>            psz = pszEnd + 1; <br>        } <br>        DrawText(lpdis-&gt;hDC, psz, -1, &amp;rcDraw, DT_LEFT); <br> <br>        if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>            InvertRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem); <br> <br>        if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>            DrawFocusRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem); <br> <br>    } else if (lpdis-&gt;itemAction &amp; ODA_SELECT) { <br> <br>        InvertRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem); <br> <br>    } else if (lpdis-&gt;itemAction &amp; ODA_FOCUS) { <br> <br>        DrawFocusRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem); <br> <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
