<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DDESPY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5594"></a>DDESPY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************** <br> <br>    PROGRAM: DdeSpy.c <br> <br>****************************************************************************/ <br> <br>#define UNICODE <br>#include &lt;windows.h&gt;                /* required for all Windows applications */ <br>#include &lt;windowsx.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include &lt;dde.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;errno.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br>#include "ddespy.h" <br>#include "lists.h" <br> <br>/* GLOBAL Variables used for DDESPY */ <br> <br>UINT        idInst = 0; <br>HINSTANCE   hInst; <br>HICON       hIcon; <br>HWND        hWndString = NULL; <br>HWND        hwndSpy = NULL; <br>HANDLE      fhOutput = NULL; <br>OFSTRUCT    ofsOpen; <br>TCHAR        OpenName[MAX_FNAME + 1]; <br>TCHAR        TBuf[BUFFER_SIZE]; <br>TCHAR        TBuf2[BUFFER_SIZE]; <br>TCHAR        szNULL[] = TEXT(""); <br>LPTSTR        apszResources[IDS_LAST + 1]; <br>PFNCALLBACK pfnDdeCallback = NULL; <br>HWND        hwndTrack[IT_COUNT] = { 0 }; <br>LPTSTR        TrackTitle[IT_COUNT]; <br>BOOL        fBlockMsg[WM_DDE_LAST - WM_DDE_FIRST + 1] = { 0 }; <br>BOOL        fBlockCb[15] = { 0 }; <br>LPTSTR        TrackHeading[IT_COUNT]; <br>struct {                           /* profile data */ <br>    BOOL fOutput[IO_COUNT]; <br>    BOOL fFilter[IF_COUNT]; <br>    BOOL fTrack[IT_COUNT]; <br>    BOOL fTerse; <br>} pro; <br> <br> <br> <br>BOOL LoadResourceStrings() <br>{ <br>    int i, cbLeft, cbRes; <br>    LPTSTR psz; <br> <br>    cbLeft = 0x1000; <br>    psz = LocalAlloc(LPTR, sizeof(TCHAR) * cbLeft); <br>    for (i = 0; i &lt;= IDS_LAST; i++) { <br>        apszResources[i] = psz; <br>        cbRes = LoadString(hInst, i, psz, cbLeft) + 1; <br>        cbLeft -= cbRes; <br>        psz += cbRes; <br>    } <br>    for (i = 0; i &lt; IT_COUNT; i++) { <br>        TrackTitle[i] = RefString(IDS_TRACKTITLE_1 + i); <br>        TrackHeading[i] = RefString(IDS_TRACKHEADING_1 + i); <br>    } <br>    lstrcpy(TBuf, RefString(IDS_DEFAULT_OUTPUT_FNAME)); <br>    GetFullPathName(TBuf, sizeof(OpenName) / sizeof(TCHAR), <br>    OpenName, (LPTSTR *)TBuf2); <br>    return(TRUE); <br>} <br> <br> <br> <br>int WINAPI WinMain( <br>        HINSTANCE hInstance, <br>        HINSTANCE hPrevInstance, <br>        LPSTR lpCmdLine, <br>        int nCmdShow) <br>{ <br>    MSG msg; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br> <br>    hInst = hInstance; <br> <br>    if (!LoadResourceStrings()) { <br>        return (FALSE); <br>    } <br> <br>    if (!hPrevInstance) <br>        if (!InitApplication(hInstance)) /* Initialize shared things */ <br>            return (FALSE);              /* Exits if unable to initialize    */ <br> <br>    /* Perform initializations that apply to a specific instance */ <br> <br>    if (!InitInstance(hInstance, nCmdShow)) { <br>        CloseApp(); <br>        return (FALSE); <br>    } <br> <br>    /* Acquire and dispatch messages until a WM_QUIT message is received. */ <br> <br>    while (GetMessage(&amp;msg,        /* message structure                      */ <br>            NULL,                  /* handle of window receiving the message */ <br>            0,                     /* lowest message to examine              */ <br>            0))                    /* highest message to examine             */ <br>        { <br>        TranslateMessage(&amp;msg);    /* Translates virtual key codes           */ <br>        DispatchMessage(&amp;msg);     /* Dispatches message to window           */ <br>    } <br>    CloseApp(); <br>    return (msg.wParam);           /* Returns the value from PostQuitMessage */ <br>} <br> <br> <br> <br>BOOL InitApplication(HINSTANCE hInstance) <br>{ <br>    WNDCLASS  wc; <br> <br>    if (!InitTestSubs()) <br>        return(FALSE); <br> <br>    /* Fill in window class structure with parameters that describe the       */ <br>    /* main window.                                                           */ <br> <br>    wc.style = 0;                    /* Class style(s).                    */ <br>    wc.lpfnWndProc = (WNDPROC)MainWndProc;       /* Function to retrieve messages for  */ <br>                                        /* windows of this class.             */ <br>    wc.cbClsExtra = 0;                  /* No per-class extra data.           */ <br>    wc.cbWndExtra = 0;                  /* No per-window extra data.          */ <br>    wc.hInstance = hInstance;           /* Application that owns the class.   */ <br>    hIcon = wc.hIcon = LoadIcon(hInstance, TEXT("DDESpy")); <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>    wc.lpszMenuName =  MAKEINTRESOURCE(IDR_MENU);   /* Name of menu resource in .RC file. */ <br>    wc.lpszClassName = RefString(IDS_CLASS); <br> <br>    /* Register the window class and return success/failure code. */ <br> <br>    return (RegisterClass(&amp;wc)); <br>} <br> <br> <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    RECT            Rect; <br>    INT             i; <br> <br>    /* Save the instance handle in static variable, which will be used in  */ <br>    /* many subsequence calls from this application to Windows.            */ <br> <br>    pfnDdeCallback = (PFNCALLBACK)MakeProcInstance((FARPROC)DdeCallback, <br>            hInstance); <br> <br>    GetProfile(); <br> <br>    /* Create a main window for this application instance.  */ <br> <br>    hwndSpy = CreateWindow( <br>        RefString(IDS_CLASS), <br>        RefString(IDS_TITLE), <br>        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>        CW_USEDEFAULT,                  /* Default horizontal position.       */ <br>        CW_USEDEFAULT,                  /* Default vertical position.         */ <br>        CW_USEDEFAULT,                  /* Default width.                     */ <br>        CW_USEDEFAULT,                  /* Default height.                    */ <br>        NULL,                           /* Overlapped windows have no parent. */ <br>        NULL,                           /* Use the window class menu.         */ <br>        hInstance,                      /* This instance owns this window.    */ <br>        NULL                            /* Pointer not needed.                */ <br>    ); <br> <br> <br>    GetClientRect(hwndSpy, (LPRECT) &amp;Rect); <br> <br>    hWndString = CreateWindow(          /* String Window (class Registered in Teststubs)*/ <br>        RefString(IDS_STRINGCLASS), <br>        szNULL, <br>        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL, <br>        0, <br>        0, <br>        Rect.right - Rect.left, <br>        Rect.bottom - Rect.top, <br>        hwndSpy, <br>        NULL, <br>        hInst, <br>        (LPTSTR)MAKELONG(CCHARS, CLINES)); <br> <br>    for (i = 0; i &lt; IT_COUNT; i++) { <br>        if (pro.fTrack[i]) { <br>            pro.fTrack[i] = FALSE; <br>            SendMessage(hwndSpy, WM_COMMAND, <br>                    GET_WM_COMMAND_MPS(IDM_TRACK_FIRST + i, 0, 0)); <br>        } <br>    } <br> <br>    if (!hwndSpy || !hWndString) { <br>        CloseApp(); <br>        return (FALSE); <br>    } <br> <br>    /* Make the window visible; update its client area; and return "success" */ <br> <br>    ShowWindow(hwndSpy, nCmdShow);  /* Show the window                        */ <br>    UpdateWindow(hwndSpy);          /* Sends WM_PAINT message                 */ <br> <br>    if (SetFilters()) { <br>        return(FALSE); <br>    } <br> <br>    return(TRUE); <br>} <br> <br> <br>VOID CloseApp() <br>{ <br>    DdeUninitialize(idInst);        /* perform cleanup and store profile */ <br>    SaveProfile(); <br>    if (fhOutput != NULL) <br>        CloseHandle(fhOutput); <br>    UnregisterClass(RefString(IDS_CLASS), hInst); <br>    CloseTestSubs(hInst); <br>} <br> <br> <br> <br>LONG  CALLBACK MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    int i; <br> <br>    switch (message) { <br>    case WM_CREATE: <br>        LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCEL)); <br>        if (pro.fOutput[IO_FILE]) <br>            fhOutput = (HANDLE)DoDialog( <br>                    MAKEINTRESOURCE(IDD_OPEN), <br>                    (DLGPROC)OpenDlg, <br>                    0, <br>                    TRUE, <br>                    hWnd, <br>                    hInst); <br>            pro.fOutput[IO_FILE] = (fhOutput != NULL); <br>        break; <br> <br>    case WM_INITMENU: <br>        if (GetMenu(hWnd) != (HMENU)wParam) <br>            break; <br> <br>        for (i = 0; i &lt; IO_COUNT; i++) { <br>        CheckMenuItem((HMENU)wParam, IDM_OUTPUT_FIRST + i, <br>                pro.fOutput[i] ? MF_CHECKED : MF_UNCHECKED); <br>        } <br> <br>        for (i = 0; i &lt; IF_COUNT; i++) { <br>            CheckMenuItem((HMENU)wParam, IDM_FILTER_FIRST + i, <br>                pro.fFilter[i] ? MF_CHECKED : MF_UNCHECKED); <br>        } <br> <br>        for (i = 0; i &lt; IT_COUNT; i++) { <br>            CheckMenuItem((HMENU)wParam, IDM_TRACK_FIRST + i, <br>                pro.fTrack[i] ? MF_CHECKED : MF_UNCHECKED); <br>        } <br>        break; <br> <br>    case WM_COMMAND:           /* message: command from application menu */ <br>        switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDM_OUTPUT_FILE: <br>        case IDM_OUTPUT_DEBUG: <br>        case IDM_OUTPUT_SCREEN: <br>            switch (wParam) { <br>            case IDM_OUTPUT_FILE: <br>                if (fhOutput != NULL) { <br>                    wsprintf(TBuf, RefString(IDS_QCLOSEFILE_TEXT), OpenName); <br>                    if (IDYES != MessageBox(hWnd, <br>                            TBuf, RefString(IDS_QCLOSEFILE_CAPTION), <br>                            MB_YESNO | MB_ICONQUESTION)) { <br>                        break; <br>                    } <br>                    CloseHandle(fhOutput); <br>                } <br>                fhOutput = (HANDLE)DoDialog( <br>                        MAKEINTRESOURCE(IDD_OPEN), <br>                        (DLGPROC)OpenDlg, <br>                        0, <br>                        TRUE, <br>                        hWnd, <br>                        hInst); <br>                pro.fOutput[IO_FILE] = (fhOutput != NULL); <br>                break; <br> <br>            case IDM_OUTPUT_DEBUG: <br>                pro.fOutput[IO_DEBUG] = !pro.fOutput[IO_DEBUG]; <br>                break; <br> <br>            case IDM_OUTPUT_SCREEN: <br>                pro.fOutput[IO_SCREEN] = !pro.fOutput[IO_SCREEN]; <br>                break; <br> <br>            } <br>            break; <br> <br>        case IDM_CLEARSCREEN: <br>            if (hWndString) { <br>                HANDLE hpsw; <br>                STRWND *psw; <br> <br>                hpsw = (HANDLE)GetWindowLong(hWndString, 0); <br>                psw = (STRWND *)LocalLock(hpsw); <br>                ClearScreen(psw); <br>                LocalUnlock(hpsw); <br>                InvalidateRect(hWndString, NULL, TRUE); <br>            } <br>            break; <br> <br>        case IDM_MARK: <br>            DoDialog(MAKEINTRESOURCE(IDD_VALUEENTRY), (DLGPROC)MarkDlgProc, 0, TRUE, hWnd, hInst); <br>            break; <br> <br>        case IDM_FILTER_HSZINFO: <br>        case IDM_FILTER_INIT_TERM: <br>        case IDM_FILTER_DDEMSGS: <br>        case IDM_FILTER_CALLBACKS: <br>        case IDM_FILTER_ERRORS: <br>            pro.fFilter[wParam - IDM_FILTER_FIRST] = <br>                    !pro.fFilter[wParam - IDM_FILTER_FIRST]; <br>            SetFilters(); <br>            break; <br> <br>        case IDM_FILTER_DIALOG: <br>            DoDialog(MAKEINTRESOURCE(IDD_MSGFILTERS), (DLGPROC)FilterDlgProc, 0, TRUE, hWnd, hInst); <br>            break; <br> <br>        case IDM_TRACK_HSZS: <br>        case IDM_TRACK_CONVS: <br>        case IDM_TRACK_LINKS: <br>        case IDM_TRACK_SVRS: <br>            pro.fTrack[wParam - IDM_TRACK_FIRST] = <br>                    !pro.fTrack[wParam - IDM_TRACK_FIRST]; <br>            if (pro.fTrack[wParam - IDM_TRACK_FIRST]) { <br>                hwndTrack[wParam - IDM_TRACK_FIRST] = CreateMCLBFrame( <br>                        NULL, <br>                        TrackTitle[wParam - IDM_TRACK_FIRST], <br>                        WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_MINIMIZE, <br>                        hIcon, (HBRUSH)(COLOR_APPWORKSPACE + 1), <br>                        TrackHeading[wParam - IDM_TRACK_FIRST]); <br>            } else { <br>                DestroyWindow(hwndTrack[wParam - IDM_TRACK_FIRST]); <br>                hwndTrack[wParam - IDM_TRACK_FIRST] = 0; <br>            } <br>            SetFilters(); <br>            break; <br> <br>        case IDM_ABOUT: <br>            DoDialog(MAKEINTRESOURCE(IDD_ABOUTBOX), (DLGPROC)About, 0, TRUE, hWnd, hInst); <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, message, wParam, lParam)); <br>        } <br>        break; <br> <br>    case WM_DESTROY:                  /* message: window being destroyed */ <br>        for (i = IDM_TRACK_FIRST; i &lt;= IDM_TRACK_LAST; i++) { <br>            if (pro.fTrack[i - IDM_TRACK_FIRST]) { <br>                DestroyWindow(hwndTrack[i - IDM_TRACK_FIRST]); <br>                hwndTrack[i - IDM_TRACK_FIRST] = 0; <br>            } <br>        } <br>        PostQuitMessage(0); <br>        break; <br> <br>    case WM_SIZE: <br>        if (hWndString) { <br>            RECT rc; <br> <br>            GetClientRect(hWnd, &amp;rc); <br>            MoveWindow(hWndString, 0, 0, rc.right, rc.bottom, TRUE); <br>        } <br>        // fall through <br>    default: <br>        return (DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return (0); <br>} <br> <br> <br> <br> <br> <br>BOOL  CALLBACK About( <br>                    HWND hDlg, <br>                    UINT message, <br>                    WPARAM wParam, <br>                    LPARAM lParam) <br>{ <br>    switch (message) { <br>        case WM_INITDIALOG:                /* message: initialize dialog box */ <br>            return (TRUE); <br> <br>        case WM_COMMAND:                      /* message: received a command */ <br>            if (GET_WM_COMMAND_ID(wParam, lParam) == IDOK <br>                || GET_WM_COMMAND_ID(wParam, lParam) == IDCANCEL) { <br>                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */ <br>                return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE);                           /* Didn't process a message    */ <br>} <br> <br> <br>HDDEDATA CALLBACK DdeCallback( <br>                            UINT wType, <br>                            UINT wFmt, <br>                            HCONV hConv, <br>                            HSZ hsz1, <br>                            HSZ hsz2, <br>                            HDDEDATA hData, <br>                            UINT dwData1, <br>                            UINT dwData2) <br>{ <br>    LPVOID pData; <br>    UINT cb; <br>    TCHAR *psz1, *psz2, *psz3; <br>    TCHAR *szAction; <br>    INT i; <br>    BOOL fInt = FALSE; <br>    wFmt; <br>    hConv; <br>    dwData1; <br> <br>    switch (wType) { <br>    case XTYP_MONITOR: <br>    if (pData = DdeAccessData(hData, (LPDWORD)&amp;cb)) { <br>        switch (dwData2) { <br>        case MF_HSZ_INFO: <br>            if (pro.fTrack[IT_HSZS]) { <br>                switch (((MONHSZSTRUCT FAR *)pData)-&gt;fsAction) { <br>                case MH_DELETE: <br>                    wsprintf(TBuf, fInt ? TEXT("0x%lx\t*\t%s(int)") <br>    : TEXT("0x%lx\t*\t%s"), <br>                            ((MONHSZSTRUCT FAR *)pData)-&gt;hsz, <br>                            (LPTSTR)((MONHSZSTRUCT FAR *)pData)-&gt;str); <br>                    i = GetMCLBColValue(TBuf, hwndTrack[IT_HSZS], 2); <br>                    if (i &gt; 1) { <br>                        wsprintf(TBuf2, fInt ? TEXT("0x%lx\t%d\t%s(int)") <br>: TEXT("0x%lx\t%d\t%s"), <br>                                ((MONHSZSTRUCT FAR *)pData)-&gt;hsz, <br>                                 i - 1, <br>                                 (LPTSTR)((MONHSZSTRUCT FAR *)pData)-&gt;str); <br>                        AddMCLBText(TBuf, TBuf2, hwndTrack[IT_HSZS]); <br>                    } else if (i == 1) { <br>                        DeleteMCLBText(TBuf, hwndTrack[IT_HSZS]); <br>                    } <br>                    break; <br> <br>                case MH_KEEP: <br>                case MH_CREATE: <br>                    wsprintf(TBuf, fInt ? TEXT("0x%lx\t*\t%s(int)") <br>    : TEXT("0x%lx\t*\t%s"), <br>                            ((MONHSZSTRUCT FAR *)pData)-&gt;hsz, <br>                            (LPTSTR)((MONHSZSTRUCT FAR *)pData)-&gt;str); <br>                    i = GetMCLBColValue(TBuf, hwndTrack[IT_HSZS], 2) + 1; <br>                    wsprintf(TBuf2, fInt ? TEXT("0x%lx\t%d\t%s(int)") <br>    : TEXT("0x%lx\t%d\t%s"), <br>                            ((MONHSZSTRUCT FAR *)pData)-&gt;hsz, <br>                             i, <br>                             (LPTSTR)((MONHSZSTRUCT FAR *)pData)-&gt;str); <br>                    AddMCLBText(TBuf, TBuf2, hwndTrack[IT_HSZS]); <br>                } <br>            } <br> <br>            if (!pro.fFilter[IF_HSZ]) { <br>                return(0); <br>            } <br> <br>            switch (((MONHSZSTRUCT FAR *)pData)-&gt;fsAction) { <br>            case MH_CLEANUP: <br>                szAction = RefString(IDS_ACTION_CLEANEDUP); <br>                break; <br> <br>            case MH_DELETE: <br>                szAction = RefString(IDS_ACTION_DESTROYED); <br>                break; <br> <br>            case MH_KEEP: <br>                szAction = RefString(IDS_ACTION_INCREMENTED); <br>                break; <br> <br>            case MH_CREATE: <br>                szAction = RefString(IDS_ACTION_CREATED); <br>                break; <br> <br>            default: <br>                DdeUnaccessData(hData); <br>                return(0); <br>            } <br>            if (pro.fTerse) { <br>                wsprintf(TBuf, TEXT("[%x:%ld] HSZ %s: %lx(%s)"), <br>                        ((MONHSZSTRUCT FAR *)pData)-&gt;hTask, <br>                        ((MONHSZSTRUCT FAR *)pData)-&gt;dwTime, <br>                        (LPTSTR)szAction, <br>                        ((MONHSZSTRUCT FAR *)pData)-&gt;hsz, <br>                        (LPTSTR)((MONHSZSTRUCT FAR *)pData)-&gt;str); <br>            } else { <br>                wsprintf(TBuf, <br>                        RefString(IDS_FMT_SH_MSG1), <br>                        ((MONHSZSTRUCT FAR *)pData)-&gt;hTask, <br>                        ((MONHSZSTRUCT FAR *)pData)-&gt;dwTime, <br>                        (LPTSTR)szAction, <br>                        ((MONHSZSTRUCT FAR *)pData)-&gt;hsz, <br>                        (LPTSTR)((MONHSZSTRUCT FAR *)pData)-&gt;str); <br>            } <br>            break; <br> <br> <br>        case MF_SENDMSGS: <br>        case MF_POSTMSGS: <br>            if (fBlockMsg[((MONMSGSTRUCT FAR *)pData)-&gt;wMsg - WM_DDE_FIRST]) { <br>                return(0); <br>            } <br>            if (pro.fTerse) { <br>                wsprintf(TBuf, RefString(IDS_FMT_TRS_MSG1), <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;hTask, <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;dwTime, <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;wParam, <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;hwndTo, <br>                        (dwData2 == MF_SENDMSGS) ? RefString(IDS_SENT) : RefString(IDS_POSTED), <br>                        (LPTSTR)DdeMsg2String(((MONMSGSTRUCT FAR *)pData)-&gt;wMsg)); <br>            } else { <br>                wsprintf(TBuf, RefString(IDS_FMT_MSG1), <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;hTask, <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;dwTime, <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;hwndTo, <br>                        (dwData2 == MF_SENDMSGS) ? RefString(IDS_SENT) : RefString(IDS_POSTED), <br>                        (LPTSTR)DdeMsg2String(((MONMSGSTRUCT FAR *)pData)-&gt;wMsg)); <br>            } <br>            OutputString(TBuf); <br>            wsprintf(TBuf, pro.fTerse ? RefString(IDS_FMT_TRS_MSG2) : RefString(IDS_FMT_MSG2), <br>                        ((MONMSGSTRUCT FAR *)pData)-&gt;wParam); <br>            DisectMsgLP(((MONMSGSTRUCT FAR *)pData)-&gt;wMsg, <br>                        ((MONMSGSTRUCT FAR *)pData), <br>                        &amp;TBuf[lstrlen(TBuf)]); <br>            break; <br> <br> <br>        case MF_CALLBACKS: <br>            if (fBlockCb[(((MONCBSTRUCT FAR *)pData)-&gt;wType &amp; XTYP_MASK) &gt;&gt; XTYP_SHIFT]) { <br>                return(0); <br>            } <br>            wsprintf(TBuf, <br>                    pro.fTerse ? RefString(IDS_FMT_TRS_CB1) : RefString(IDS_FMT_CB1), <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;hTask, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;dwTime, <br>                    (LPTSTR)Type2String(((MONCBSTRUCT FAR *)pData)-&gt;wType)); <br>            wsprintf(DumpFormat(((MONCBSTRUCT FAR *)pData)-&gt;wFmt, &amp;TBuf[lstrlen(TBuf)]), <br>                    pro.fTerse ? RefString(IDS_FMT_TRS_CB2) : RefString(IDS_FMT_CB2), <br>                    (UINT)((MONCBSTRUCT FAR *)pData)-&gt;hConv, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;hsz1, <br>                    (LPTSTR)(psz1 = GetHszName(((MONCBSTRUCT FAR *)pData)-&gt;hsz1)), <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;hsz2, <br>                    (LPTSTR)(psz2 = GetHszName(((MONCBSTRUCT FAR *)pData)-&gt;hsz2)), <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;hData, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;dwData1, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;dwData2, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;dwRet); <br>            MyFree(psz1); <br>            MyFree(psz2); <br>            OutputString(TBuf); <br>            if (((MONCBSTRUCT FAR *)pData)-&gt;dwData1 &amp;&amp; <br>               (((MONCBSTRUCT FAR *)pData)-&gt;wType == XTYP_CONNECT || <br>               ((MONCBSTRUCT FAR *)pData)-&gt;wType == XTYP_WILDCONNECT)) { <br>                // display proposed context <br>                wsprintf(TBuf, <br>                    pro.fTerse ? RefString(IDS_FMT_TRS_CTXT1) : RefString(IDS_FMT_CTXT1), <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.wFlags, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.wCountryID, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.iCodePage, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.dwLangID, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.dwSecurity, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.qos.ImpersonationLevel, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.qos.ContextTrackingMode, <br>                    ((MONCBSTRUCT FAR *)pData)-&gt;cc.qos.EffectiveOnly); <br>                OutputString(TBuf); <br>            } <br>            if (((MONCBSTRUCT FAR *)pData)-&gt;hData &amp;&amp; ((MONCBSTRUCT FAR *)pData)-&gt;cbData) { <br>                wsprintf(TBuf, RefString(IDS_INPUT_DATA)); <br>                OutputString(TBuf); <br>                DumpData((LPBYTE)((MONCBSTRUCT FAR *)pData)-&gt;Data, <br>                                 ((MONCBSTRUCT FAR *)pData)-&gt;cbData, <br>                                 TBuf, <br>                                 ((MONCBSTRUCT FAR *)pData)-&gt;wFmt); <br>                OutputString(TBuf); <br>                if (cb &gt; MAX_DISPDATA) <br>                    OutputString(RefString(IDS_TABDDD)); <br>                DdeUnaccessData(((MONCBSTRUCT FAR *)pData)-&gt;hData); <br>            } <br>            if ((((MONCBSTRUCT FAR *)pData)-&gt;wType &amp; XCLASS_DATA) &amp;&amp; <br>                 ((MONCBSTRUCT FAR *)pData)-&gt;dwRet &amp;&amp; <br>                 ((MONCBSTRUCT FAR *)pData)-&gt;cbData) { <br>                wsprintf(TBuf, RefString(IDS_OUTPUT_DATA)); <br>                OutputString(TBuf); <br>                DumpData((LPBYTE)((MONCBSTRUCT FAR *)pData)-&gt;Data, <br>                                 ((MONCBSTRUCT FAR *)pData)-&gt;cbData, <br>                                 TBuf, <br>                                 ((MONCBSTRUCT FAR *)pData)-&gt;wFmt); <br>                OutputString(TBuf); <br>                if (cb &gt; MAX_DISPDATA) <br>                    OutputString(RefString(IDS_TABDDD)); <br>                DdeUnaccessData((HDDEDATA)((MONCBSTRUCT FAR *)pData)-&gt;dwRet); <br>            } <br>            DdeUnaccessData(hData); <br>            return(0); <br>            break; <br> <br>        case MF_ERRORS: <br>            wsprintf(TBuf, pro.fTerse ? RefString(IDS_FMT_TRS_ER1) : RefString(IDS_FMT_ER1), <br>                    ((MONERRSTRUCT FAR *)pData)-&gt;hTask, <br>                    ((MONERRSTRUCT FAR *)pData)-&gt;dwTime, <br>                    ((MONERRSTRUCT FAR *)pData)-&gt;wLastError, <br>                    (LPTSTR)Error2String(((MONERRSTRUCT FAR *)pData)-&gt;wLastError)); <br>            break; <br> <br> <br>        case MF_LINKS: <br>            psz1 = GetHszName(((MONLINKSTRUCT FAR *)pData)-&gt;hszSvc); <br>            psz2 = GetHszName(((MONLINKSTRUCT FAR *)pData)-&gt;hszTopic); <br>            psz3 = GetHszName(((MONLINKSTRUCT FAR *)pData)-&gt;hszItem); <br>            if (!GetClipboardFormatName(((MONLINKSTRUCT FAR *)pData)-&gt;wFmt, TBuf2, BUFFER_SIZE)) <br>                lstrcpy(TBuf2, pdf(((MONLINKSTRUCT FAR *)pData)-&gt;wFmt)); <br>            if (!lstrcmp(RefString(IDS_HUH), TBuf2)) { <br>                wsprintf(TBuf2, TEXT("%d"), ((MONLINKSTRUCT FAR *)pData)-&gt;wFmt); <br>            } <br> <br>            wsprintf(TBuf, TEXT("%s\t%s\t%s\t%s\t%s\t%lx\t%lx"), <br>                    (LPTSTR)psz1, (LPTSTR)psz2, (LPTSTR)psz3, <br>                    (LPTSTR)TBuf2, <br>                    ((MONLINKSTRUCT FAR *)pData)-&gt;fNoData ? <br>                     RefString(IDS_WARM) : RefString(IDS_HOT), <br>                    ((MONLINKSTRUCT FAR *)pData)-&gt;hConvClient, <br>                    ((MONLINKSTRUCT FAR *)pData)-&gt;hConvServer); <br> <br>            if (((MONLINKSTRUCT FAR *)pData)-&gt;fEstablished) { <br>                AddMCLBText(TBuf, TBuf, hwndTrack[IT_LINKS]); <br>            } else { <br>                DeleteMCLBText(TBuf, hwndTrack[IT_LINKS]); <br>            } <br> <br>            MyFree(psz1); <br>            MyFree(psz2); <br>            MyFree(psz3); <br>            DdeUnaccessData(hData); <br>            return(0); <br> <br> <br>        case MF_CONV: <br>            psz1 = GetHszName(((MONCONVSTRUCT FAR *)pData)-&gt;hszSvc); <br>            psz2 = GetHszName(((MONCONVSTRUCT FAR *)pData)-&gt;hszTopic); <br> <br>            wsprintf(TBuf, TEXT("%s\t%s\t%lx\t%lx"), <br>                    (LPTSTR)psz1, (LPTSTR)psz2, <br>                    ((MONCONVSTRUCT FAR *)pData)-&gt;hConvClient, <br>                    ((MONCONVSTRUCT FAR *)pData)-&gt;hConvServer); <br> <br>            if (((MONCONVSTRUCT FAR *)pData)-&gt;fConnect) { <br>                AddMCLBText(TBuf, TBuf, hwndTrack[IT_CONVS]); <br>            } else { <br>                DeleteMCLBText(TBuf, hwndTrack[IT_CONVS]); <br>            } <br> <br>            MyFree(psz1); <br>            MyFree(psz2); <br>            DdeUnaccessData(hData); <br>            return(0); <br> <br> <br>        default: <br>            lstrcpy(TBuf, RefString(IDS_UNKNOWN_CALLBACK)); <br>        } <br>        DdeUnaccessData(hData); <br>        OutputString(TBuf); <br>    } <br>    break; <br> <br>    case XTYP_REGISTER: <br>    case XTYP_UNREGISTER: <br>        if (!pro.fTrack[IT_SVRS]) { <br>            return(0); <br>        } <br>        psz1 = GetHszName(hsz1); <br>        psz2 = GetHszName(hsz2); <br>        wsprintf(TBuf, TEXT("%s\t%s"), (LPTSTR)psz1, (LPTSTR)psz2); <br>        if (wType == XTYP_REGISTER) { <br>            AddMCLBText(NULL, TBuf, hwndTrack[IT_SVRS]); <br>        } else { <br>            DeleteMCLBText(TBuf, hwndTrack[IT_SVRS]); <br>        } <br>        MyFree(psz1); <br>        MyFree(psz2); <br>        break; <br>    } <br>    return(0); <br>} <br> <br> <br>LPTSTR DisectMsgLP(UINT msg, MONMSGSTRUCT *pmms,  LPTSTR pszBuf) <br>{ <br>    static LONG m2t[] = { <br> <br>    /*              LOW                       HIGH */ <br> <br>        MAKELONG(T_APP | T_ATOM,        T_TOPIC | T_ATOM),  // WM_DDE_INITIATE <br>        0,                                                  // WM_DDE_TERMINATE <br>        MAKELONG(T_OPTIONHANDLE,        T_ITEM | T_ATOM),   // WM_DDE_ADVISE <br>        MAKELONG(T_FORMAT,              T_ITEM | T_ATOM),   // WM_DDE_UNADVISE <br>        MAKELONG(T_APP | T_ATOM | T_OR | T_STATUS, <br>                                        T_TOPIC | T_ITEM | T_ATOM | T_OR | T_STRINGHANDLE), <br>                                                            // WM_DDE_ACK <br>        MAKELONG(T_DATAHANDLE,          T_ITEM | T_ATOM),   // WM_DDE_DATA <br>        MAKELONG(T_FORMAT,              T_ITEM | T_ATOM),   // WM_DDE_REQUEST <br>        MAKELONG(T_DATAHANDLE,          T_ITEM | T_ATOM),   // WM_DDE_POKE <br>        MAKELONG(0,                     T_STRINGHANDLE),    // WM_DDE_EXECUTE <br>    }; <br> <br>    // ASSUMED: msg is a valid DDE message!!! <br> <br>    pszBuf = DisectWord(LOWORD(m2t[msg - WM_DDE_FIRST]), <br>                        pmms-&gt;dmhd.uiLo, &amp;pmms-&gt;dmhd, pszBuf); <br>    *pszBuf++ = TEXT('\r'); <br>    *pszBuf++ = TEXT('\n'); <br>    *pszBuf++ = TEXT('\t'); <br>    return(DisectWord(HIWORD(m2t[msg - WM_DDE_FIRST]), <br>                        pmms-&gt;dmhd.uiHi, &amp;pmms-&gt;dmhd, pszBuf)); <br>} <br> <br> <br> <br> <br>/* <br> * Allocates local memory for and retrieves the string form of an HSZ. <br> * Returns a pointer to the local memory or NULL if failure. <br> * The string must be freed via MyFree(). <br> */ <br>LPTSTR GetHszName(HSZ hsz) <br>{ <br>    LPTSTR psz; <br>    UINT cb; <br> <br>    cb = (UINT)DdeQueryString(idInst, hsz, NULL, 0, 0) + 1; <br>    psz = LocalAlloc (LPTR, sizeof(TCHAR) * cb); <br>    DdeQueryString(idInst, hsz, psz, cb, 0); <br>    return(psz); <br>} <br> <br> <br> <br> <br>LPTSTR DisectWord( UINT type, <br>UINT data, <br>DDEML_MSG_HOOK_DATA *pdmhd, <br>LPTSTR pstr) <br>{ <br>    UINT wT; <br> <br>    *pstr = TEXT('\0');   // in case we do nothing. <br> <br>    if (type &amp; T_ATOM) { <br>        wT = GlobalGetAtomName((ATOM)data, (LPTSTR)pstr, 25); <br>        if (wT || data == 0) { <br>            if (type &amp; T_APP) { <br>                lstrcpy(pstr, RefString(IDS_APPIS)); <br>                pstr += lstrlen(pstr); <br>            } <br> <br>            if (type &amp; T_TOPIC) { <br>                lstrcpy(pstr, RefString(IDS_TOPICIS)); <br>                pstr += lstrlen(pstr); <br>            } <br> <br>            if (type &amp; T_ITEM) { <br>                lstrcpy(pstr, RefString(IDS_ITEMIS)); <br>                pstr += lstrlen(pstr); <br>            } <br>        } <br>        if (wT) { <br>            wsprintf(pstr, TEXT("0x%x(\""), data); <br>            pstr += lstrlen(pstr); <br>            GlobalGetAtomName((ATOM)data, (LPTSTR)pstr, 25); <br>            pstr += wT; <br>            if (wT == 25) { <br>                *pstr++ = TEXT('.'); <br>                *pstr++ = TEXT('.'); <br>                *pstr++ = TEXT('.'); <br>            } <br>            *pstr++ = TEXT('\"'); <br>            *pstr++ = TEXT(')'); <br>            *pstr = TEXT('\0'); </code></pre>
<p>
</p>
<pre><code>type &amp;= ~(T_OR | T_STRINGHANDLE);  // its an atom, so its not an object! <br>        } else if (data == 0) {     // could be a wild atom <br>            *pstr++ = TEXT('*'); <br>            *pstr = TEXT('\0'); <br>        } else if (type &amp; T_OR) { <br>            type &amp;= ~T_OR;   // not an atom, must be somthin else. <br>        } else { <br>            wsprintf(pstr, RefString(IDS_FMT_BADATOM), data); <br>            pstr += lstrlen(pstr); <br>        } <br>    } <br> <br>    if (type &amp; T_OR) { <br>        lstrcpy(pstr, RefString(IDS_OR)); <br>        pstr += lstrlen(pstr); <br>    } <br> <br> <br>    if (type &amp; T_OPTIONHANDLE) { <br>        if (pdmhd-&gt;cbData &gt;= 4) { <br>            wsprintf(pstr, pro.fTerse ? RefString(IDS_FMT_TRS_STATUSIS) : RefString(IDS_FMT_STATUSIS), LOWORD(pdmhd-&gt;Data[0])); <br>            pstr += lstrlen(pstr); <br>            if (LOWORD(pdmhd-&gt;Data[0]) &amp; DDE_FACKREQ) { <br>                lstrcpy(pstr, RefString(IDS_FACKREQ)); <br>                pstr += lstrlen(pstr); <br>            } <br>            if (LOWORD(pdmhd-&gt;Data[0]) &amp; DDE_FDEFERUPD) { <br>                lstrcpy(pstr, RefString(IDS_DEFERUPD)); <br>                pstr += lstrlen(pstr); <br>            } <br>            *pstr++ = TEXT(')'); <br>            *pstr++ = TEXT(' '); <br>            pstr = DumpFormat((UINT)HIWORD(pdmhd-&gt;Data[0]), pstr); <br>        } <br>    } <br> <br>    if (type &amp; T_FORMAT) { <br>        pstr = DumpFormat(data, pstr); <br>    } <br> <br>    if (type &amp; T_STATUS) { <br>        wsprintf(pstr, pro.fTerse ? RefString(IDS_FMT_TRS_STATUSIS) : RefString(IDS_FMT_STATUSIS), LOWORD(data)); <br>        pstr += lstrlen(pstr); <br>        if (data &amp; DDE_FACK) { <br>            lstrcpy(pstr, RefString(IDS_FACK)); <br>            pstr += lstrlen(pstr); <br>        } <br>        if (data &amp; DDE_FBUSY) { <br>            lstrcpy(pstr, RefString(IDS_FBUSY)); <br>            pstr += lstrlen(pstr); <br>        } <br>        *pstr++ = TEXT(')'); <br>        *pstr = TEXT('\0'); <br>    } <br> <br>    if (type &amp; T_STRINGHANDLE &amp;&amp; pdmhd-&gt;cbData) { <br>        WCHAR szData[16]; <br> <br>        memset(szData, '\0', 16 * sizeof(WCHAR)); <br>        memcpy(szData, pdmhd-&gt;Data, min(16 * sizeof(WCHAR), pdmhd-&gt;cbData)); <br>        szData[15] = L'\0'; <br>        wsprintf(pstr, pro.fTerse ? <br>                    RefString(IDS_FMT_TRS_EXEC1) : RefString(IDS_FMT_EXEC1), (LPWSTR)szData); <br>        pstr += lstrlen(pstr); <br>        *pstr = TEXT('\0'); <br>    } <br> <br>    if (type &amp; T_DATAHANDLE &amp;&amp; pdmhd-&gt;cbData) { <br>        wsprintf(pstr, pro.fTerse ? <br>                    RefString(IDS_FMT_TRS_STATUSIS) : RefString(IDS_FMT_STATUSIS), <br>                    LOWORD(pdmhd-&gt;Data[0])); <br>        pstr += lstrlen(pstr); <br>        if (LOWORD(pdmhd-&gt;Data[0]) &amp; DDE_FRELEASE) { <br>            lstrcpy(pstr, RefString(IDS_FRELEASE)); <br>            pstr += lstrlen(pstr); <br>        } <br>        if (LOWORD(pdmhd-&gt;Data[0]) &amp; DDE_FREQUESTED) { <br>            lstrcpy(pstr, RefString(IDS_FREQUESTED)); <br>            pstr += lstrlen(pstr); <br>        } <br>        *pstr++ = TEXT(')'); <br>        *pstr++ = TEXT(' '); <br>        pstr = DumpFormat(HIWORD(pdmhd-&gt;Data[0]), pstr); <br>        lstrcpy(pstr, pro.fTerse ? RefString(IDS_FMT_TRS_DATAIS1) : RefString(IDS_FMT_DATAIS1)); <br>        pstr += lstrlen(pstr); <br>        pstr = DumpData((LPBYTE)&amp;pdmhd-&gt;Data[1], min(28, pdmhd-&gt;cbData - 4), <br>                pstr, HIWORD(pdmhd-&gt;Data[0])); <br>    } <br>    return(pstr); <br>} <br> <br> <br>LPTSTR pdf(UINT fmt) <br>{ <br>    INT i; <br>    static struct { <br>        UINT fmt; <br>        LPTSTR psz; <br>    } fmts[] = { <br>        { CF_TEXT             ,     TEXT("CF_TEXT")           }   , <br>        { CF_UNICODETEXT      ,     TEXT("CF_UNICODETEXT")    }   , <br>        { CF_BITMAP           ,     TEXT("CF_BITMAP")         }   , <br>        { CF_METAFILEPICT     ,     TEXT("CF_METAFILEPICT")   }   , <br>        { CF_ENHMETAFILE      ,     TEXT("CF_ENHMETAFILE")    }   , <br>        { CF_SYLK             ,     TEXT("CF_SYLK")           }   , <br>        { CF_DIF              ,     TEXT("CF_DIF")            }   , <br>        { CF_TIFF             ,     TEXT("CF_TIFF")           }   , <br>        { CF_OEMTEXT          ,     TEXT("CF_OEMTEXT")        }   , <br>        { CF_DIB              ,     TEXT("CF_DIB")            }   , <br>        { CF_PALETTE          ,     TEXT("CF_PALETTE")        }   , <br>    }; <br>    for (i = 0; i &lt; 10; i++) <br>        if (fmts[i].fmt == fmt) <br>            return(fmts[i].psz); <br>    return(RefString(IDS_HUH)); <br>} <br> <br> <br> <br>LPTSTR DumpFormat(UINT fmt, LPTSTR pstr) <br>{ <br>    UINT cb; <br> <br>    wsprintf(pstr, TEXT("fmt=0x%x(\""), (WORD)fmt); <br>    pstr += lstrlen(pstr); <br>    if (cb = GetClipboardFormatName(fmt, pstr, 25)) { <br>        pstr += cb; <br>        *pstr++ = TEXT('\"'); <br>        *pstr++ = TEXT(')'); <br>    } else { <br>        wsprintf(pstr, TEXT("%s\")"), (LPTSTR)pdf(fmt)); <br>        pstr += lstrlen(pstr); <br>    } <br>    return(pstr); <br>} <br> <br> <br> <br>LPTSTR DumpData(LPBYTE pData, UINT cb, TCHAR *szBuf, UINT fmt) <br>{ <br>    register INT i; <br>    LPTSTR psz = szBuf; <br> <br> <br>    while (cb) { <br>        if (fmt == CF_TEXT || fmt == CF_UNICODETEXT) { <br>            *szBuf++ = TEXT('\t'); <br>            if (fmt == CF_UNICODETEXT) { <br>                *szBuf++ = TEXT('U'); <br>            } <br>            *szBuf++ = TEXT('\"'); <br>            if (fmt == CF_UNICODETEXT) { <br>                memcpy(szBuf, pData, cb); <br>            } else { <br>                MultiByteToWideChar(CP_ACP, 0, pData, cb, szBuf, cb / sizeof(TCHAR)); <br>            } <br>            szBuf[cb - 2] = TEXT('\0'); <br>            lstrcat(szBuf, TEXT("\"")); <br>            cb = 0; <br>        } else { <br>            for (i = 0; i &lt; 80 ; i++) { <br>                szBuf[i] = TEXT(' '); <br>            } <br>            szBuf[0] = TEXT('\t'); <br>            i = 0; <br>            while (cb &amp;&amp; (i &lt; 16)) { <br>                wsprintf(&amp;szBuf[i * 3 + 1], TEXT("%02x "), pData[0]); <br>                wsprintf(&amp;szBuf[17 * 3 + i + 1], TEXT("%c"), MPRT(pData[0])); <br>                pData++; <br>                cb--; <br>                i++; <br>            } <br>            szBuf[i * 3 + 1] = TEXT(' '); <br>            szBuf[17 * 3 + i + 1] = TEXT(' '); <br>            szBuf[68] = TEXT('\0'); <br>        } <br>        szBuf += lstrlen(szBuf); <br>    } <br>    return(szBuf); <br>} <br> <br> <br> <br>LPTSTR Error2String(UINT error) <br>{ <br>    static TCHAR szErr[23]; <br> <br>    if (error == 0) { <br>        lstrcpy(szErr, RefString(IDS_ZERO)); <br>    } else if (error &gt; DMLERR_LAST || error &lt; DMLERR_FIRST) { <br>        lstrcpy(szErr, RefString(IDS_HUH)); <br>    } else { <br>        lstrcpy(szErr, apszResources[IDS_ERRST0 + error - DMLERR_FIRST]); <br>    } <br>    return(szErr); <br>} <br> <br> <br> <br>LPTSTR DdeMsg2String(UINT msg) <br>{ <br>    static TCHAR szBadMsg[10]; <br> <br>    if (msg &lt; WM_DDE_FIRST || msg &gt; WM_DDE_LAST) { <br>       wsprintf (szBadMsg, TEXT("%ld"), szBadMsg); <br>       return (szBadMsg); <br>//        return((LPTSTR)itoa(msg, szBadMsg, 10)); <br>    } else { <br>        return(apszResources[IDS_MSG0 + msg - WM_DDE_FIRST]); <br>    } <br>} <br> <br> <br> <br>VOID OutputString(LPTSTR pstr) <br>{ <br>    DWORD cbWritten; <br> <br>    if (pro.fOutput[IO_FILE] &amp;&amp; fhOutput != NULL) { <br>        static CHAR szT[200]; <br> <br>        WideCharToMultiByte( <br>                CP_ACP, <br>                0, <br>                pstr, <br>                -1, <br>                szT, <br>                200, <br>                NULL, <br>                NULL); <br>        WriteFile(fhOutput, (LPCSTR) szT, lstrlenA(szT), &amp;cbWritten, NULL); <br>        WriteFile(fhOutput, (LPCSTR) "\r\n", 2, &amp;cbWritten, NULL); <br>        FlushFileBuffers(fhOutput); <br>    } <br>    if (pro.fOutput[IO_DEBUG]) { <br>        OutputDebugString((LPTSTR)pstr); <br>        OutputDebugString(RefString(IDS_CRLF)); <br>    } <br>    if (pro.fOutput[IO_SCREEN]) { <br>        if (IsWindow(hWndString)) <br>            DrawString(hWndString, pstr); <br>    } <br>} <br> <br> <br> <br>BOOL SetFilters() <br>{ <br>    UINT cbf; <br> <br>    cbf = 0; <br>    if (pro.fTrack[IT_HSZS] || pro.fFilter[IF_HSZ]) <br>        cbf |= MF_HSZ_INFO; <br>    if (pro.fTrack[IT_LINKS]) <br>        cbf |= MF_LINKS; <br>    if (pro.fTrack[IT_CONVS]) <br>        cbf |= MF_CONV; <br>    if (pro.fFilter[IF_SEND]) <br>        cbf |= MF_SENDMSGS; <br>    if (pro.fFilter[IF_POST]) <br>        cbf |= MF_POSTMSGS; <br>    if (pro.fFilter[IF_CB]) <br>        cbf |= MF_CALLBACKS; <br>    if (pro.fFilter[IF_ERR]) <br>        cbf |= MF_ERRORS; <br>    return((BOOL)DdeInitialize(&amp;idInst, pfnDdeCallback, APPCLASS_MONITOR | cbf, 0)); <br>} <br> <br> <br> <br> <br> <br>/* <br> * This dialog returns a file handle to the opened file name given or NULL <br> * if cancel. <br> */ <br> <br>BOOL CALLBACK OpenDlg(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    HANDLE fh; <br>    lParam; <br> <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            SetDlgItemText(hDlg, IDC_EDIT, (LPTSTR)OpenName); <br>            SendDlgItemMessage(hDlg, IDC_EDIT, EM_SETSEL, <br>                    GET_EM_SETSEL_MPS(0, 0x7fff)); <br>            SetFocus(GetDlgItem(hDlg, IDC_EDIT)); <br>            return (FALSE); /* Indicates the focus is set to a control */ <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK: <br>                    GetDlgItemText(hDlg, IDC_EDIT, TBuf, MAX_FNAME); <br>                    GetFullPathName(TBuf, sizeof(OpenName), OpenName, (LPTSTR *)TBuf2); <br>                    fh = CreateFile( <br>                            OpenName, <br>                            GENERIC_WRITE, <br>                            FILE_SHARE_READ, <br>                            (PSECURITY_ATTRIBUTES)NULL, <br>                            CREATE_ALWAYS, <br>                            FILE_ATTRIBUTE_NORMAL, <br>                            NULL); <br>                    if (fh == INVALID_HANDLE_VALUE) { <br>                        MessageBox(hDlg, RefString(IDS_INVALID_FNAME), <br>                            NULL, MB_OK | MB_ICONHAND); <br>                        return (TRUE); <br>                    } <br> <br>                    EndDialog(hDlg, (INT)fh); <br>                    return (TRUE); <br> <br>                case IDCANCEL: <br>                    EndDialog(hDlg, 0); <br>                    return (FALSE); <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br>BOOL CALLBACK FilterDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    int i; <br>    lParam; <br> <br>    switch (message) { <br>    case WM_INITDIALOG: <br>            for (i = IDRB_WM_DDE_INITIATE; i &lt;= IDRB_WM_DDE_EXECUTE; i++) { <br>                CheckDlgButton(hDlg, i, !fBlockMsg[i - IDRB_WM_DDE_INITIATE]); <br>            } <br>            for (i = IDRB_XTYP_ERROR; i &lt;= IDRB_XTYP_WILDCONNECT; i++) { <br>                CheckDlgButton(hDlg, i, !fBlockCb[i - IDRB_XTYP_ERROR]); <br>            } <br>            CheckDlgButton(hDlg, IDRB_TERSE, pro.fTerse); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK: <br>                    for (i = IDRB_WM_DDE_INITIATE; i &lt;= IDRB_WM_DDE_EXECUTE; i++) { <br>                        fBlockMsg[i - IDRB_WM_DDE_INITIATE] = !IsDlgButtonChecked(hDlg, i); <br>                    } <br>                    for (i = IDRB_XTYP_ERROR; i &lt;= IDRB_XTYP_WILDCONNECT; i++) { <br>                        fBlockCb[i - IDRB_XTYP_ERROR] = !IsDlgButtonChecked(hDlg, i); <br>                    } <br>                    pro.fTerse = IsDlgButtonChecked(hDlg, IDRB_TERSE); <br>                    EndDialog(hDlg, TRUE); <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hDlg, 0); <br>                    break; <br>            } <br>            break; <br>    } <br>    return FALSE; <br>} <br> <br> <br> <br> <br>VOID GetProfile() <br>{ <br>    pro.fOutput[IO_FILE]    = GetProfileBoolean(RefString(IDS_PROF_OUT_FILE),FALSE); <br>    pro.fOutput[IO_DEBUG]   = GetProfileBoolean(RefString(IDS_PROF_OUT_DEBUG),FALSE); <br>    pro.fOutput[IO_SCREEN]  = GetProfileBoolean(RefString(IDS_PROF_OUT_SCREEN),FALSE); <br> <br>    pro.fFilter[IF_HSZ]     = GetProfileBoolean(RefString(IDS_PROF_MONITOR_STRINGHANDLES),FALSE); <br>    pro.fFilter[IF_SEND]    = GetProfileBoolean(RefString(IDS_PROF_MONITOR_INITIATES), FALSE); <br>    pro.fFilter[IF_POST]    = GetProfileBoolean(RefString(IDS_PROF_MONITOR_DDE_MESSAGES), FALSE); <br>    pro.fFilter[IF_CB]      = GetProfileBoolean(RefString(IDS_PROF_MONITOR_CALLBACKS), FALSE); <br>    pro.fFilter[IF_ERR]     = GetProfileBoolean(RefString(IDS_PROF_MONITOR_ERRORS),FALSE); <br> <br>    pro.fTrack[IT_HSZS]     = GetProfileBoolean(RefString(IDS_PROF_TRACK_STRINGHANDLES), FALSE); <br>    pro.fTrack[IT_LINKS]    = GetProfileBoolean(RefString(IDS_PROF_TRACK_LINKS), FALSE); <br>    pro.fTrack[IT_CONVS]    = GetProfileBoolean(RefString(IDS_PROF_TRACK_CONVERSATIONS), FALSE); <br>    pro.fTrack[IT_SVRS]     = GetProfileBoolean(RefString(IDS_PROF_TRACK_SERVICES), FALSE); <br> <br>    pro.fTerse              = GetProfileBoolean(RefString(IDS_PROF_TERSE), FALSE); <br>} <br> <br> <br> <br>VOID SaveProfile() <br>{ <br>    SetProfileBoolean(RefString(IDS_PROF_OUT_FILE), pro.fOutput[IO_FILE]  ); <br>    SetProfileBoolean(RefString(IDS_PROF_OUT_DEBUG), pro.fOutput[IO_DEBUG] ); <br>    SetProfileBoolean(RefString(IDS_PROF_OUT_SCREEN), pro.fOutput[IO_SCREEN]); <br> <br>    SetProfileBoolean(RefString(IDS_PROF_MONITOR_STRINGHANDLES), pro.fFilter[IF_HSZ]   ); <br>    SetProfileBoolean(RefString(IDS_PROF_MONITOR_INITIATES), pro.fFilter[IF_SEND]  ); <br>    SetProfileBoolean(RefString(IDS_PROF_MONITOR_DDE_MESSAGES), pro.fFilter[IF_POST]  ); <br>    SetProfileBoolean(RefString(IDS_PROF_MONITOR_CALLBACKS), pro.fFilter[IF_CB]    ); <br>    SetProfileBoolean(RefString(IDS_PROF_MONITOR_ERRORS), pro.fFilter[IF_ERR]   ); <br> <br>    SetProfileBoolean(RefString(IDS_PROF_TRACK_STRINGHANDLES), pro.fTrack[IT_HSZS]   ); <br>    SetProfileBoolean(RefString(IDS_PROF_TRACK_LINKS), pro.fTrack[IT_LINKS]  ); <br>    SetProfileBoolean(RefString(IDS_PROF_TRACK_CONVERSATIONS), pro.fTrack[IT_CONVS]  ); <br>    SetProfileBoolean(RefString(IDS_PROF_TRACK_SERVICES), pro.fTrack[IT_SVRS]   ); <br> <br>    SetProfileBoolean(RefString(IDS_PROF_TERSE), pro.fTerse   ); <br>} <br> <br> <br> <br> <br>BOOL GetProfileBoolean(LPTSTR pszKey, BOOL fDefault) <br>{ <br>    GetPrivateProfileString(RefString(IDS_TITLE), pszKey, <br>                    fDefault ? RefString(IDS_YES) : RefString(IDS_NO), TBuf, <br>                    sizeof(TBuf), RefString(IDS_INIFNAME)); <br>    return(lstrcmpi(RefString(IDS_NO), TBuf)); <br>} <br> <br> <br> <br>VOID SetProfileBoolean(LPTSTR pszKey, BOOL fSet) <br>{ <br>    WritePrivateProfileString(RefString(IDS_TITLE), pszKey, <br>                    fSet ? RefString(IDS_YES) : RefString(IDS_NO), <br>                    RefString(IDS_INIFNAME)); <br>} <br> <br>/* <br> * Generic dialog invocation routine.  Handles procInstance stuff and param <br> * passing. <br> */ <br>INT FAR DoDialog( <br>                LPTSTR lpTemplateName, <br>                DLGPROC lpDlgProc, <br>                UINT param, <br>                BOOL fRememberFocus, <br>                HWND hwndParent, <br>                HANDLE hInst) <br>{ <br>    UINT wRet; <br>    HWND hwndFocus; <br> <br>    if (fRememberFocus) <br>        hwndFocus = GetFocus(); <br>    lpDlgProc = (DLGPROC)MakeProcInstance(lpDlgProc, hInst); <br>    wRet = DialogBoxParam(hInst, (LPCTSTR)lpTemplateName, hwndParent, <br>            lpDlgProc, param); <br>    FreeProcInstance((FARPROC)lpDlgProc); <br>    if (fRememberFocus) <br>        SetFocus(hwndFocus); <br>    return wRet; <br>} <br> <br> <br>BOOL CALLBACK MarkDlgProc( <br>                        HWND hwnd, <br>                        UINT msg, <br>                        WPARAM wParam, <br>                        LPARAM lParam) <br>{ <br>    TCHAR szT[MAX_MARK + 1]; <br>    lParam; <br> <br>    switch (msg){ <br>    case WM_INITDIALOG: <br>        SetWindowText(hwnd, RefString(IDS_MARKDLGTITLE)); <br>        SendDlgItemMessage(hwnd, IDEF_VALUE, EM_LIMITTEXT, MAX_MARK, 0); <br>        SetDlgItemText(hwnd, IDEF_VALUE, RefString(IDS_SEPERATOR)); <br>        SetDlgItemText(hwnd, IDTX_VALUE, RefString(IDS_MARKTEXT)); <br>        return(1); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>            GetDlgItemText(hwnd, IDEF_VALUE, szT, MAX_MARK); <br>            OutputString(szT); <br>            // fall through <br>        case IDCANCEL: <br>            EndDialog(hwnd, 0); <br>            break; <br> <br>        default: <br>            return(FALSE); <br>        } <br>        break; <br>    } <br>    return(FALSE); <br>} <br> <br>/**************************************************************************** <br>    My_mbschr:  strchr() DBCS version <br>****************************************************************************/ <br>LPTSTR _CRTAPI1 My_mbschr( <br>    LPTSTR psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    if (*psz == '\0' &amp;&amp; uiSep != '\0') { <br>        return NULL; <br>    } else { <br>        return psz; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
