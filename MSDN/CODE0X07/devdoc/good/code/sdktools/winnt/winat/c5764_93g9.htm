<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINAT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5769"></a>WINAT.C</h2>
<pre><code>//=========================================================================== <br>// <br>// Module: WINAT.C <br>// <br>// Purpose: Main program for WINAT.exe.  This program is a GUI Windows <br>//          NT AT Command Scheduler.  The base code was taken from the <br>//          Windows NT AT command files.  I have preserved (mostly) the <br>//          same algorithms and data structures. <br>// <br>// Author: Kory Gill <br>// <br>// Date  : March 1993 <br>// <br>// Copyright: Copyright 1993 - 1998 Microsoft Corporation <br>// <br>// Original banner from Windows NT at.c <br>// <br>//      /*++ <br>// <br>//      Copyright 1987 - 1998  Microsoft Corporation <br>// <br>//      Module Name: <br>// <br>//          atcmd.c <br>// <br>//      Abstract: <br>// <br>//          Code for AT command, to be used with SCHEDULE service on <br>//          Windows NT. <br>// <br>//          The module was taken from LanManager\at.c and then modified <br>//          considerably to work with NT Schedule service. <br>// <br>//      Author: <br>// <br>//          Vladimir Z. Vulovic                     06 - November - 1992 <br>// <br>//      Environment: <br>// <br>//          User Mode - Win32 <br>// <br>//      Revision History: <br>// <br>//          06-Nov-1992 <br>//              Created <br>// <br>//          20-Feb-1993 <br>//              Get rid of hard coded strings and parse/print time according <br>//              to user profile <br>// <br>//      --*/ <br>// <br>//=========================================================================== <br> <br> <br>//=========================================================================== <br>// includes <br>//=========================================================================== <br> <br>#include &lt;windows.h&gt;    // required for all Windows applications <br>#include "lmcons.h"     // LAN Manager defines <br>#include "MYnetmsg.h"   // APE2 defines <br>#include "lmerr.h"      // LAN Manager error messages <br>#include "lmat.h"       // AT Command prototypes <br>#include "lmapibuf.h"   // NetApiBufferFree <br>#include "WINAT.h"      // specific to this program <br>#include "listhapi.h"   // hotizontal listbox routines <br>#include &lt;assert.h&gt;     // assert <br>#include &lt;stdio.h&gt;      // assert <br> <br> <br>//=========================================================================== <br>// global variables <br>//=========================================================================== <br> <br>ATTIME  AtTime[NUM_TIMES] =                 // time strings and ms since 12am <br>    { <br>"00:00",  0, "00:30",  0, "01:00",  0, "01:30",  0, <br>"02:00",  0, "02:30",  0, "03:00",  0, "03:30",  0, <br>"04:00",  0, "04:30",  0, "05:00",  0, "05:30",  0, <br>"06:00",  0, "06:30",  0, "07:00",  0, "07:30",  0, <br>"08:00",  0, "08:30",  0, "09:00",  0, "09:30",  0, <br>"10:00",  0, "10:30",  0, "11:00",  0, "11:30",  0, <br>"12:00",  0, "12:30",  0, "13:00",  0, "13:30",  0, <br>"14:00",  0, "14:30",  0, "15:00",  0, "15:30",  0, <br>"16:00",  0, "16:30",  0, "17:00",  0, "17:30",  0, <br>"18:00",  0, "18:30",  0, "19:00",  0, "19:30",  0, <br>"20:00",  0, "20:30",  0, "21:00",  0, "21:30",  0, <br>"22:00",  0, "22:30",  0, "23:00",  0, "23:30",  0 <br>    }; <br>AT_INFO GlobalAtInfo;                       // at information structure <br>BOOL    fTimer;                             // flag for timer events <br>DWORD   GlobalJobId;                        // job id as dword <br>DWORD   dwDisposition;                      // used for registry calls <br>DWORD   dwH = DWH;                          // height of main window <br>DWORD   dwTime;                             // time in milliseconds <br>DWORD   dwW = DWW;                          // width of main window <br>DWORD   dwX = DWX;                          // x location of main window <br>DWORD   dwY = DWY;                          // y location of main window <br>FARPROC lpAmPmProc;                                                     // subclass for add/change AmPm edit control <br>FARPROC lpAmPmDefProc;                                          // default handler for add/change AmPm edit control <br>FARPROC lpDownButtonProc;                                       // subclass for spin button <br>FARPROC lpDownButtonDefProc;                            // default handler for spin buttons <br>FARPROC lpHourProc;                                                     // subclass for add/change hour edit control <br>FARPROC lpHourDefProc;                                          // default handler for add/change hour edit control <br>FARPROC lpMinProc;                                                      // subclass for add/change min edit control <br>FARPROC lpMinDefProc;                                           // default handler for add/change min edit control <br>FARPROC lpUpButtonProc;                                         // subclass for spin button <br>FARPROC lpUpButtonDefProc;                                      // default handler for spin buttons <br>HANDLE  hInst;                              // instance <br>HCURSOR hCursorOld;                         // old cursor <br>HCURSOR hCursorWait;                        // hourglass cursor <br>#ifdef JAPAN <br>#else <br>HFONT   hFont;                              // handle to font <br>#endif <br>HANDLE  GlobalMessageHandle;                // handle to netmsg.dll <br>HKEY    hkHandle;                           // hangle to registry <br>HWND    hCurrentFocus = NULL;                           // handle to window with focus (used for hour/min/ampm spin buttons) <br>HWND    hGlobalhWnd;                        // handle to main window <br>HWND    hGlobalAddChg = NULL;               // handle to Add/Change dialog when active <br>HWND    hHour = NULL;                       // handle to hour <br>HWND    hMin = NULL;                        // handle to minutes <br>HWND    hAmPm = NULL;                       // handle to ampm <br>LOGFONT lf;                                 // font <br>PWSTR   GlobalComputerName;                 // currently selected comp. name <br>UCHAR   szRegistryPath[] = SZREGPATH;       // path to registry for stored info <br>UCHAR   szAppName[] = SZAPPTITLE;           // name of this application <br>UCHAR   szAtCommand[MAX_ATCMD_LEN+1];       // entire line in atcommand listbox <br>UCHAR   szCommandM[MAXCOMMANDLEN+1];        // multibyte command <br>UCHAR   szComputerM[MAXCOMPUTERNAMELEN+1];  // multibyte comp. name <br>UCHAR   szDateAbbr[4];                      // store day of month as string <br>#ifdef JAPAN <br>UCHAR   szDayAbbr[7][8]   =                 // abbreviations <br>    { <br>        "   j   ", "   j   ", "   j   ", "   j   ", "   j   ", " y j   ", "   j   " <br>    }; <br>#else <br>UCHAR   szDayAbbr[7][4]   =                 // abbreviations <br>    { <br>"M ", "T ", "W ", "Th ", "F ", "Sa ", "Su " <br>    }; <br>#endif <br>UCHAR   szDefault[] = " ";                  // default char for wide conversion <br>UCHAR   szError[] = SZGENERROR;             // error message <br>UCHAR   szNoEntries[] = SZNOENTRIES;        // error message <br>#ifdef JAPAN <br>UCHAR   szTime[32];                         // store time as string <br>#else <br>UCHAR   szTime[8];                          // store time as string <br>#endif <br>UCHAR   szTitle[]   = SZAPPTITLE;           // title bar text <br>UCHAR   szWhenDay[MAXWHENDAYLEN + 1];       // used to build when/day string <br>#ifdef JAPAN <br>#else <br>UINT    uAmPmChars;                                                     // count of characters in add/change AmPm edit control <br>#endif <br>UINT    uHourChars;                                                     // count of characters in add/change hour edit control <br>UINT    uMinChars;                                                      // count of characters in add/change min edit control <br>UINT    uTimer;                             // handle of timer <br>WCHAR   szCommandW[MAXCOMMANDLEN+1];        // widechar command <br>WCHAR   szComputerW[MAXCOMPUTERNAMELEN+1];  // widechar comp. name <br> <br>// jean-marc - start <br>UCHAR   gszCommandLine[MAXCOMPUTERNAMELEN+1]; // stores the passed in commandline <br>// jean-marc - end <br> <br>  <br>//=========================================================================== <br>// FUNCTION: AddChangeDlgProc() <br>//=========================================================================== <br> <br>BOOL APIENTRY <br>AddChangeDlgProc( <br>    HWND hWnd,         // window handle <br>    UINT message,      // type of message <br>    UINT uParam,       // additional information <br>    LONG lParam        // additional information <br>    ) <br>{ <br> <br>    NET_API_STATUS  status; <br>    PAT_INFO        pAtInfo = NULL; <br>    SYSTEMTIME      SystemTime; <br>    UCHAR           szAtCommand[MAX_ATCMD_LEN]; <br>    UCHAR           szTemp[30]; <br>    char *          ptr; <br>    int             JobId; <br>    int             i; <br>    int             wmEvent; <br>    int             wmId; <br>    static BOOL     fChange; <br>    BOOL                        Translated; <br>    UINT                        Value; <br>    int                         Delta; <br> <br>    // owner draw stuff <br>    static LPDRAWITEMSTRUCT  lpdis;          // Long Pointer to owner-draw struct <br>    LPMEASUREITEMSTRUCT      lpmis;          // Long Pointer to o-d measure struct <br>    static HBITMAP           hButtonUpDef,   // for button's regular state bm <br>     hButtonUpDep,   // for button's pushed  state bm <br>     hButtonDownDef, // for button's regular state bm <br>     hButtonDownDep; // for button's pushed  state bm <br> <br>    switch (message) { <br> <br>case WM_SPINBUTTON: <br> <br>    if ( (hCurrentFocus != hHour) &amp;&amp; (hCurrentFocus != hMin) &amp;&amp; (hCurrentFocus != hAmPm) ) { <br> <br>break; <br> <br>    } <br> <br>if ( lParam == UP ) { <br> <br>Delta = UP; <br> <br>} else { <br> <br>Delta = DOWN; <br> <br>} <br> <br>if ( uParam == (UINT)GetDlgItem( hWnd, IDC_HOUR ) ) { <br> <br>Value = GetDlgItemInt( hWnd, IDC_HOUR, &amp;Translated, FALSE ); <br> <br>if ( Translated == 0 ) { <br> <br>SetDlgItemInt( hWnd, IDC_HOUR, DEFAULT_HOUR, FALSE ); <br> <br>} else { <br> <br>if ( ( Value &gt;= 12 || Value &lt; 1 ) &amp;&amp; Delta == UP ) { <br> <br>Value = 1; <br> <br>} else if ( ( Value &gt; 12 || Value &lt;= 1 ) &amp;&amp; Delta == DOWN ) { <br> <br>Value = 12; <br> <br>} else { <br> <br>if ( (Value == 11 &amp;&amp; Delta == UP) || (Value == 12 &amp;&amp; Delta == DOWN) ) { <br> <br>GetDlgItemText( hWnd, IDC_AMPM, (LPTSTR)&amp;szTemp, sizeof(szTemp) ); <br> <br>#ifdef JAPAN <br>        if ( !strcmp(szTemp, "   O" ) ) { <br>        SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"    " ); <br>        } else { <br>SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"   O" ); <br>} <br>#else <br>if ( szTemp[0] == 'A' || szTemp[0] == 'a' ) { <br> <br>SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"PM" ); <br> <br>} else { <br> <br>SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"AM" ); <br> <br>} <br>#endif <br>} <br> <br>Value += Delta; <br> <br>} <br> <br>SetDlgItemInt( hWnd, IDC_HOUR, Value, FALSE ); <br> <br>} <br> <br>SendDlgItemMessage( hWnd, IDC_HOUR, EM_SETSEL, 0, -1 ); <br>//SetFocus( (HWND)uParam ); <br> <br>} else if ( uParam == (UINT)GetDlgItem( hWnd, IDC_MIN ) ) { <br> <br>Value = GetDlgItemInt( hWnd, IDC_MIN, &amp;Translated, FALSE ); <br> <br>if ( Translated == 0 ) { <br> <br>SetDlgItemInt( hWnd, IDC_MIN, DEFAULT_MIN, FALSE ); <br> <br>} else { <br> <br>if ( ( Value &gt;= 59 || Value &lt; 0 ) &amp;&amp; Delta == UP ) { <br> <br>Value = 0; <br> <br>} else if ( ( Value &gt; 59 || Value &lt;= 0 ) &amp;&amp; Delta == DOWN ) { <br> <br>Value = 59; <br> <br>} else { <br> <br>Value += Delta; <br> <br>} <br> <br>} <br> <br>if ( Value &gt; 9 ) { <br> <br>SetDlgItemInt( hWnd, IDC_MIN, Value, FALSE ); <br> <br>} else { <br> <br>szTemp[0] = '0'; <br>szTemp[1] = '0' + Value; <br>szTemp[2] = '\0'; <br> <br>SetDlgItemText( hWnd, IDC_MIN, szTemp ); <br>    } <br> <br>SendDlgItemMessage( hWnd, IDC_MIN, EM_SETSEL, 0, -1 ); <br>//SetFocus( (HWND)uParam ); <br> <br>} else if ( uParam == (UINT)GetDlgItem( hWnd, IDC_AMPM ) ) { <br> <br>GetDlgItemText( hWnd, IDC_AMPM, (LPTSTR)&amp;szTemp, sizeof(szTemp) ); <br> <br>#ifdef JAPAN <br>    if ( !strcmp(szTemp, "   O") ) { <br>    SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"    " ); <br>    } else { <br>SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"   O" ); <br>} <br>#else <br>if ( szTemp[0] == 'A' || szTemp[0] == 'a' ) { <br> <br>SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"PM" ); <br> <br>} else { <br> <br>SetDlgItemText( hWnd, IDC_AMPM,  (LPCTSTR)"AM" ); <br> <br>} <br>#endif <br> <br>SendDlgItemMessage( hWnd, IDC_AMPM, EM_SETSEL, 0, -1 ); <br>//SetFocus( (HWND)uParam ); <br> <br>} <br> <br>break; <br> <br>case WM_MEASUREITEM: <br> <br>    lpmis = (LPMEASUREITEMSTRUCT)lParam; // for convenience <br>    lpmis-&gt;itemWidth  = 7; <br>    lpmis-&gt;itemHeight = 7; <br> <br>    break; <br> <br>case WM_DRAWITEM: <br> <br>    lpdis = (LPDRAWITEMSTRUCT)lParam;    // for convenience <br> <br>    switch (lpdis-&gt;itemAction) { <br> <br>case ODA_DRAWENTIRE: <br>    if ( lpdis-&gt;CtlID == IDD_DOWNBUT ) { <br>DrawBitmap(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, hButtonDownDef, SRCCOPY); <br>    } else { <br>DrawBitmap(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, hButtonUpDef, SRCCOPY); <br>    } <br> <br>    break; <br> <br>case ODA_SELECT: <br>    // handle select state -- text is right &amp; down 2 pixels <br>    // also handle focus state since it's associated <br>    if (lpdis-&gt;itemState &amp; ODS_SELECTED) { <br>if ( lpdis-&gt;CtlID == IDD_DOWNBUT ) { <br>DrawBitmap(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, hButtonDownDep, SRCCOPY); <br>    } else { <br>DrawBitmap(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, hButtonUpDep, SRCCOPY); <br>    } <br>    } <br>    else { <br>if ( lpdis-&gt;CtlID == IDD_DOWNBUT ) { <br>DrawBitmap(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, hButtonDownDef, SRCCOPY); <br>    } else { <br>DrawBitmap(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, hButtonUpDef, SRCCOPY); <br>    } <br> <br>if ( hCurrentFocus != NULL ) { <br> <br>SetFocus( hCurrentFocus ); <br> <br>} <br> <br>    } <br>    break; <br> <br>case ODA_FOCUS: <br>    if (lpdis-&gt;itemState &amp; ODS_FOCUS) { <br> <br>    break; <br>} <br> <br>break; <br> <br>default: <br> <br>    break; <br> <br>    }  //itemAction <br> <br>    break; <br> <br>case WM_INITDIALOG: <br> <br>/* load bitmaps and get area of text rectangle for owner-draw button */ <br> <br>    hButtonUpDef = LoadBitmap(hInst,"BUTTONUPDEF"); // regular state <br>    hButtonUpDep   = LoadBitmap(hInst,"BUTTONUPDEP");   // pushed  state <br> <br> <br>    hButtonDownDef = LoadBitmap(hInst,"BUTTONDOWNDEF"); // regular state <br>    hButtonDownDep = LoadBitmap(hInst,"BUTTONDOWNDEP");   // pushed  state <br> <br>    hCurrentFocus = NULL; <br>    hHour = GetDlgItem( hWnd, IDC_HOUR ); <br>    hMin  = GetDlgItem( hWnd, IDC_MIN ); <br>    hAmPm = GetDlgItem( hWnd, IDC_AMPM ); <br> <br>#ifdef JAPAN <br>#else <br>SendDlgItemMessage( hWnd, IDC_NEWCOMMAND, WM_SETFONT, (WPARAM)hFont, 1L ); <br>SendDlgItemMessage( hWnd, IDC_DAYS, WM_SETFONT, (WPARAM)hFont, 1L ); <br>SendDlgItemMessage( hWnd, IDC_HOUR, WM_SETFONT, (WPARAM)hFont, 1L ); <br>SendDlgItemMessage( hWnd, IDC_MIN, WM_SETFONT,  (WPARAM)hFont, 1L ); <br>SendDlgItemMessage( hWnd, IDC_AMPM, WM_SETFONT, (WPARAM)hFont, 1L ); <br>#endif <br> <br>    // fill in Days <br>#ifdef JAPAN <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"   j  "); <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"   j  "); <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"   j  "); <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"   j  "); <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"   j  "); <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)" y j  "); <br>            SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"   j  "); <br>#else <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Monday"); <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Tuesday"); <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Wednesday"); <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Thursday"); <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Friday"); <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Saturday"); <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)"Sunday"); <br>#endif <br> <br>    for ( i=1; i&lt;=9; ++i ) { <br> <br>UCHAR szDateAbbr[2]; <br> <br>szDateAbbr[0] = i + '0'; <br>szDateAbbr[1] = '\0'; <br> <br>SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)szDateAbbr ); <br> <br>    } <br> <br>for ( i=10; i&lt;=31; ++i ) { <br> <br>UCHAR szDateAbbr[3]; <br> <br>szDateAbbr[0] = i/10 + '0'; <br>szDateAbbr[1] = i%10 + '0'; <br>szDateAbbr[2] = '\0'; <br> <br>SendDlgItemMessage(hWnd, IDC_DAYS, LB_ADDSTRING, 0, (LPARAM)szDateAbbr ); <br> <br>    } <br> <br>if ( lParam == IDC_ADD ) { <br> <br>    SendDlgItemMessage(hWnd, IDC_DAYS, LB_SETCURSEL, 0, 0); <br> <br>    // fill in Time <br> <br>SetDlgItemInt( hWnd, IDC_HOUR, DEFAULT_HOUR, FALSE ); <br> <br>if ( DEFAULT_MIN &gt; 9 ) { <br> <br>SetDlgItemInt( hWnd, IDC_MIN, DEFAULT_MIN, FALSE ); <br> <br>} else { <br> <br>szTemp[0] = '0'; <br>szTemp[1] = '0' + DEFAULT_MIN; <br>szTemp[2] = '\0'; <br> <br>SetDlgItemText( hWnd, IDC_MIN, szTemp ); <br>    } <br> <br>SetDlgItemText( hWnd, IDC_AMPM, (LPCTSTR)DEFAULT_AMPM ); <br> <br>    // set the Every radio button <br> <br>    SendDlgItemMessage(hWnd, IDC_EVERY, BM_SETCHECK, TRUE, 0); <br> <br>    fChange = FALSE; <br> <br>#ifdef JAPAN <br>        lstrcpy( szTemp, "         " ); <br>#else <br>lstrcpy( szTemp, "Add Command" ); <br>#endif <br> <br>SetWindowText( hWnd, szTemp ); <br> <br>} else { <br> <br>    fChange = TRUE; <br> <br>#ifdef JAPAN <br>lstrcpy( szTemp, "        X" ); <br>#else <br>lstrcpy( szTemp, "Change Command" ); <br>#endif <br> <br>SetWindowText( hWnd, szTemp ); <br> <br>// fill in current command info <br> <br>SendDlgItemMessage( <br>hGlobalhWnd, <br>IDC_ATCOMMANDS, <br>LB_GETTEXT, <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_GETCURSEL, 0, 0 ), <br>(LPARAM)szAtCommand <br>); <br> <br>// get job id <br> <br>    JobId = 0; <br> <br>    ptr   = szAtCommand; <br> <br>    while( *ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9' ) { <br> <br>JobId *= 10; <br>JobId += (UINT)*ptr - '0'; <br> <br>ptr++; <br> <br>    } <br> <br>    // get info on this job <br> <br>    status = NetScheduleJobGetInfo( <br>    GlobalComputerName, <br>JobId, <br>(LPBYTE *)&amp;pAtInfo <br>); <br> <br>    if ( status != NERR_Success ) { <br> <br>//MessageBox( hWnd, "Problem getting Job Info.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>MessagePrint( status ); <br> <br>EndDialog( hWnd, 0 ); <br> <br>    } <br> <br>    // fill in command <br> <br>    WideCharToMultiByte( <br>(UINT)CP_ACP, <br>(DWORD)0, <br>(LPWSTR)pAtInfo-&gt;Command, <br>MAX_ATCMD_LEN, <br>    (LPSTR)szCommandM, <br>    MAX_ATCMD_LEN, <br>    (LPSTR)NULL, (LPBOOL)NULL <br>    ); <br> <br>SetDlgItemText( hWnd, IDC_NEWCOMMAND, szCommandM ); <br> <br>// set days this command runs <br> <br>if ( pAtInfo-&gt;DaysOfWeek != 0) { <br> <br>for ( i=0; i&lt;7; ++i ) { <br> <br>if ( ( pAtInfo-&gt;DaysOfWeek &amp; (1 &lt;&lt; i) ) != 0 ) { <br> <br>SendDlgItemMessage( hWnd, IDC_DAYS, LB_SETSEL, TRUE, i ); <br> <br>} <br> <br>} <br> <br>} <br> <br>if ( pAtInfo-&gt;DaysOfMonth != 0) { <br> <br>for ( i=0; i&lt;31; ++i ) { <br> <br>if ( ( pAtInfo-&gt;DaysOfMonth &amp; (1L &lt;&lt; i) ) != 0 ) { <br> <br>SendDlgItemMessage( hWnd, IDC_DAYS, LB_SETSEL, TRUE, i+7 ); <br> <br>} <br> <br>} <br> <br>} <br> <br>// fill in every/today/tomorrow/next flag <br> <br>if ( pAtInfo-&gt;Flags &amp; JOB_RUN_PERIODICALLY ) { <br> <br>SendDlgItemMessage( hWnd, IDC_EVERY, BM_SETCHECK, TRUE, 0 ); <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_EVERY, 0 ); <br> <br>} else if ( (pAtInfo-&gt;DaysOfWeek != 0) || (pAtInfo-&gt;DaysOfMonth != 0) ) { <br> <br>SendDlgItemMessage( hWnd, IDC_NEXT, BM_SETCHECK, TRUE, 0 ); <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_NEXT, 0 ); <br> <br>} else if ( pAtInfo-&gt;Flags &amp; JOB_RUNS_TODAY ) { <br> <br>SendDlgItemMessage( hWnd, IDC_TODAY, BM_SETCHECK, TRUE, 0 ); <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_TODAY, 0 ); <br> <br>} else { <br> <br>SendDlgItemMessage( hWnd, IDC_TOMORROW, BM_SETCHECK, TRUE, 0 ); <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_TOMORROW, 0 ); <br> <br>} <br> <br>    // set time for this command <br> <br>{ <br> <br>    UINT  uJobTime = (UINT)(pAtInfo-&gt;JobTime / 1000 / 60 / 60); <br>UINT  uAM = TRUE; <br> <br>if ( uJobTime == 0 ) { <br> <br>uJobTime = 12; <br> <br>} else if ( uJobTime == 12 ) { <br> <br>    uAM = FALSE; <br> <br>} else if ( uJobTime &gt; 12 ) { <br> <br>    uJobTime -= 12; <br> <br>    uAM = FALSE; <br> <br>} <br> <br>SetDlgItemInt( hWnd, IDC_HOUR, uJobTime, FALSE ); <br> <br>#ifdef JAPAN <br>               uAM ? SetDlgItemText( hWnd, IDC_AMPM, "   O" ) : SetDlgItemText( hWnd, IDC_AMPM, "    " ); <br>#else <br>uAM ? SetDlgItemText( hWnd, IDC_AMPM, "AM" ) : SetDlgItemText( hWnd, IDC_AMPM, "PM" ); <br>#endif <br> <br>if ( (UINT)(pAtInfo-&gt;JobTime / 1000 / 60 % 60) &gt; 9 ) { <br> <br>SetDlgItemInt( hWnd, IDC_MIN, (UINT)(pAtInfo-&gt;JobTime / 1000 / 60 % 60), FALSE ); <br> <br>} else { <br> <br>szTemp[0] = '0'; <br>szTemp[1] = '0' + (UINT)(pAtInfo-&gt;JobTime / 1000 / 60 % 60); <br>szTemp[2] = '\0'; <br> <br>SetDlgItemText( hWnd, IDC_MIN, szTemp ); <br>    } <br> <br>    } <br> <br>// free buffer <br> <br>NetApiBufferFree( (LPVOID)pAtInfo ); <br> <br>} <br> <br>    // set up subclass functions <br> <br>lpAmPmProc = MakeProcInstance( (FARPROC)AmPmProc, hInst ); <br>lpAmPmDefProc = (FARPROC) SetWindowLong( GetDlgItem( hWnd, IDC_AMPM ), GWL_WNDPROC, (LONG)lpAmPmProc ); <br>lpDownButtonProc = MakeProcInstance( (FARPROC)DownButtonProc, hInst ); <br>lpDownButtonDefProc = (FARPROC) SetWindowLong( GetDlgItem( hWnd, IDD_DOWNBUT ), GWL_WNDPROC, (LONG)lpDownButtonProc ); <br>lpUpButtonProc = MakeProcInstance( (FARPROC)UpButtonProc, hInst ); <br>lpUpButtonDefProc = (FARPROC) SetWindowLong( GetDlgItem( hWnd, IDD_UPBUT ), GWL_WNDPROC, (LONG)lpUpButtonProc ); <br>lpHourProc = MakeProcInstance( (FARPROC)HourProc, hInst ); <br>lpHourDefProc = (FARPROC) SetWindowLong( GetDlgItem( hWnd, IDC_HOUR ), GWL_WNDPROC, (LONG)lpHourProc ); <br>lpMinProc = MakeProcInstance( (FARPROC)MinProc, hInst ); <br>lpMinDefProc = (FARPROC) SetWindowLong( GetDlgItem( hWnd, IDC_MIN ), GWL_WNDPROC, (LONG)lpMinProc ); <br> <br>// will default to two chars <br> <br>uHourChars = 2; <br>uMinChars = 2; <br> <br> <br>hGlobalAddChg = hWnd; <br> <br>break; <br> <br>case WM_COMMAND:    // message: command from application menu <br> <br>wmId    = LOWORD(uParam); <br>wmEvent = HIWORD(uParam); <br> <br>switch (wmId) { <br> <br>case IDC_TODAY: <br>case IDC_TOMORROW: <br> <br>    GetLocalTime( &amp;SystemTime ); <br> <br>    if ( SystemTime.wDayOfWeek == 0 ) { <br> <br>SystemTime.wDayOfWeek = 7; <br> <br>    } <br> <br>for( i=0; i&lt;NUMDAYITEMS; ++i ) { <br> <br>SendDlgItemMessage( hWnd, IDC_DAYS, LB_SETSEL, FALSE, i ); <br> <br>} <br> <br>SendDlgItemMessage( <br>hWnd, <br>IDC_DAYS, <br>LB_SETSEL, <br>TRUE, <br>wmId == IDC_TOMORROW ? SystemTime.wDayOfWeek : SystemTime.wDayOfWeek - 1 ); <br> <br>    EnableWindow(GetDlgItem(hWnd, IDC_DAYS), FALSE); <br> <br>    break; <br> <br>case IDC_EVERY: <br> <br>    EnableWindow(GetDlgItem(hWnd, IDC_DAYS), TRUE); <br> <br>    break; <br> <br>case IDC_NEXT: <br> <br>    EnableWindow(GetDlgItem(hWnd, IDC_DAYS), TRUE); <br> <br>    break; <br> <br>case IDCANCEL: <br> <br>    hCurrentFocus = NULL; <br>    DeleteObject( hButtonUpDef ); <br>    DeleteObject( hButtonUpDep ); <br>    DeleteObject( hButtonDownDep ); <br>    DeleteObject( hButtonDownDef ); <br> <br>EndDialog( hWnd, IDCANCEL ); <br> <br>break; <br> <br>case IDOK: <br> <br>    if ( ValidateAddChangeArguments( hWnd ) == TRUE ) { <br> <br>if( fChange == TRUE) { <br> <br>status = JobDel( DEL_ID_CHANGE, hGlobalhWnd); <br> <br>} <br> <br>status = JobAdd(); <br> <br>    if ( status == NERR_Success ) { <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_BOTTOM ); <br> <br>hCurrentFocus = NULL; <br>DeleteObject( hButtonUpDef ); <br>    DeleteObject( hButtonUpDep ); <br>    DeleteObject( hButtonDownDep ); <br>    DeleteObject( hButtonDownDef ); <br> <br>    EndDialog( hWnd, IDOK ); <br> <br>    } else { <br> <br>//MessageBox( hWnd, "Problem adding command.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>MessagePrint( status ); <br> <br>    } <br> <br>    } <br> <br>    break; <br> <br>case IDC_ADDCHANGEHELP: <br> <br>#ifdef KKBUGFIX <br>    if (!WinHelp (hWnd, "WINAT.HLP", HELP_CONTENTS,0L)) { <br>#else <br>    if (!WinHelp (hWnd, "WINAT.HLP", HELP_KEY,(DWORD)(LPSTR)"CONTENTS")) { <br>#endif <br>MessageBox (GetFocus(), <br>#ifdef JAPAN <br>" w   v   N            ", <br>#else <br>"Unable to activate help", <br>#endif <br>SZWINDOWTITLE, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND); <br>    } <br> <br>    break; <br> <br>    } <br> <br>    break; <br> <br>    } <br> <br>    return (0); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: AmPmProc() <br>//=========================================================================== <br>LRESULT APIENTRY AmPmProc( HWND hWnd, UINT message, UINT uParam, LONG lParam ) <br>{ <br>// jean-marc - start <br>    // NOTE: the dialog resource for this field includes the ES_READONLY flag <br>    // to prevent the delete key from working, otherwise the delete key was <br>    // going through by somehow by-passing the WM_CHAR case. <br> <br>    switch (message) <br>    { <br>      case WM_SETFOCUS: <br>hCurrentFocus = hWnd; <br>break; <br> <br>      case WM_CHAR: <br>      { <br>switch(uParam) <br>{ <br>  case 'A': <br>  case 'a': <br>#ifdef JAPAN <br>    SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)"   O" ); <br>#else <br>    SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)"AM"); <br>#endif <br>    return 0; <br> <br>  case 'P': <br>  case 'p': <br>#ifdef JAPAN <br>    SendMessage( hWnd, WM_SETTEXT, 0, (LPARAM)"    " ); <br>#else <br>    SendMessage(hWnd, WM_SETTEXT, 0, (LPARAM)(LPCTSTR)"PM"); <br>#endif <br>    return 0; <br> <br>  default: <br>    MessageBeep(MB_OK); <br>    return 0; <br>} <br>      } <br>      return 0; <br>    } <br> <br>    return CallWindowProc( (WNDPROC)lpAmPmDefProc, hWnd, message, uParam, lParam ) ; <br>// jean-marc - end <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: AreYouSure() <br>// <br>// Arguments: <br>// <br>//   Uses globals. <br>// <br>// Return Value: <br>// <br>//   ID_YES if the yes button pressed <br>//   ID_NO  if the  no button pressed <br>// <br>//=========================================================================== <br>UINT <br>AreYouSure( <br>    HWND hWnd <br>    ) <br>{ <br> <br>    return ( MessageBox( <br> hWnd, <br>#ifdef JAPAN <br>                 " I         R }   h               H", <br>                 "     m F", <br>#else <br> "Remove the selected command?", <br> "Confirm Remove", <br>#endif <br> MB_YESNO | MB_ICONEXCLAMATION <br> ) <br>   ); <br> <br>} <br> <br>  <br>//=========================================================================== <br>// FUNCTION: UpButtonProc() <br>//=========================================================================== <br>LRESULT APIENTRY UpButtonProc( HWND hWnd, UINT message, UINT uParam, LONG lParam ) <br>{ <br>// jean-marc - start <br>#define TIME_DELAY 150 <br>#define TIME_DELAY 150 <br> <br>  DWORD dwEventTime; <br> <br>  switch (message) <br>  { <br>    case WM_LBUTTONDOWN: <br>      if (hCurrentFocus == hHour || hCurrentFocus == hMin || hCurrentFocus == hAmPm) <br>      { <br>dwEventTime = GetTickCount() - TIME_DELAY; <br>do <br>{ <br>  if (dwEventTime + TIME_DELAY &gt; GetTickCount()) <br>    continue; <br>  SendMessage(hGlobalAddChg, WM_SPINBUTTON, (UINT)hCurrentFocus, (LONG)UP); <br>  InvalidateRect(hCurrentFocus, NULL, TRUE); <br>  UpdateWindow(hCurrentFocus); <br>  dwEventTime = GetTickCount(); <br>} <br>while (GetAsyncKeyState(VK_LBUTTON) &amp; 0x8000); <br>      } <br>      break; <br>  } <br> <br>  return CallWindowProc((WNDPROC)lpUpButtonDefProc, hWnd, message, uParam, lParam); <br>// jean-marc - end <br>} <br> <br>  <br>//=========================================================================== <br>// FUNCTION: DownButtonProc() <br>//=========================================================================== <br>LRESULT APIENTRY DownButtonProc( HWND hWnd, UINT message, UINT uParam, LONG lParam ) <br>{ <br>// jean-marc - start <br>#define TIME_DELAY 150 <br> <br>  DWORD dwEventTime; <br> <br>  switch (message) <br>  { <br>    case WM_LBUTTONDOWN: <br>      if (hCurrentFocus == hHour || hCurrentFocus == hMin || hCurrentFocus == hAmPm) <br>      { <br>dwEventTime = GetTickCount() - TIME_DELAY; <br>do <br>{ <br>  if (dwEventTime + TIME_DELAY &gt; GetTickCount()) <br>    continue; <br>  SendMessage(hGlobalAddChg, WM_SPINBUTTON, (UINT)hCurrentFocus, (LONG)DOWN); <br>  InvalidateRect(hCurrentFocus, NULL, TRUE); <br>  UpdateWindow(hCurrentFocus); <br>  dwEventTime = GetTickCount(); <br>} <br>while (GetAsyncKeyState(VK_LBUTTON) &amp; 0x8000); <br>      } <br>      break; <br>  } <br> <br>  return CallWindowProc((WNDPROC)lpDownButtonDefProc, hWnd, message, uParam, lParam); <br>// jean-marc - end <br>} <br> <br> <br>  <br>/**************************************************************************** <br> <br>    FUNCTION: DrawBitmap <br> <br>    PURPOSE:  Draw default or pushed button bitmap <br> <br>****************************************************************************/ <br> <br>void DrawBitmap( <br>HDC     hDC, <br>LONG    xStart, <br>LONG    yStart, <br>HBITMAP hBitmap, <br>DWORD   rop) <br>{ <br>  BITMAP        bm; <br>  HDC           hMemDC; <br>  POINT                 pt; <br> <br>  hMemDC = CreateCompatibleDC (hDC); <br>  SelectObject (hMemDC, hBitmap); <br>  GetObject (hBitmap, sizeof (BITMAP), (LPSTR) &amp;bm); <br>  pt.x = bm.bmWidth; <br>  pt.y = bm.bmHeight; <br>  BitBlt (hDC, xStart, yStart, pt.x, pt.y, hMemDC, 0, 0, rop); <br>  DeleteDC (hMemDC); <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: HourProc() <br>//=========================================================================== <br>LRESULT APIENTRY HourProc( HWND hWnd, UINT message, UINT uParam, LONG lParam ) </code></pre>
<p>
</p>
<pre><code>{ <br>    UINT  uCurVal; <br>    UCHAR szCurVal[3]; <br> <br>    switch ( message ) { <br> <br>    case WM_COPY: <br>    case WM_PASTE: <br>    case WM_CUT: <br> <br>// cut and paste dont seem to work... <br> <br>break; <br> <br>// jean-marc - start <br>      case WM_SETFOCUS: <br>hCurrentFocus = hWnd; <br>break; <br>// jean-marc - end <br> <br>case WM_CHAR: <br> <br>if ( uParam == VK_BACK ) { <br> <br>if ( uHourChars &gt; 0 ) { <br> <br>--uHourChars; <br> <br>} <br> <br>return CallWindowProc( (WNDPROC)lpHourDefProc, hWnd, message, uParam, lParam ) ; <br> <br>} else { <br> <br>uHourChars = (UINT) SendMessage( hWnd, WM_GETTEXT, 2, (LPARAM)szCurVal ); <br> <br>if ( uHourChars == 0 ) { <br> <br>uCurVal = 0; <br> <br>    } else if ( uHourChars == 1 ) { <br> <br>uCurVal = szCurVal[0] - '0'; <br> <br>    } else if ( uHourChars == 2 ) { <br> <br>uCurVal  = szCurVal[0] - '0'; <br>uCurVal *= 10; <br>uCurVal  = szCurVal[1] - '0'; <br> <br>    } else if ( uHourChars &gt; 2 ) { <br> <br>uHourChars = 0; <br> <br>SendMessage( hWnd, WM_SETTEXT, 0, (LPARAM)"" ); <br> <br>return( 0 ); <br> <br>    } <br> <br>} <br> <br>if ( ( uParam == ' ' )                                     ||  // space <br>     ( uParam &lt; '0' || uParam &gt; '9')                       ||  // not a number <br>     ( uParam == '0' &amp;&amp; uCurVal == 0 )                     ||  // trying to enter 0 as first char <br>     ( (uParam &gt; '2' &amp;&amp; uCurVal &gt;= 1) &amp;&amp; uHourChars &gt;= 1)  ||  // greater than 12 <br>     ( uParam &lt;= '2' &amp;&amp; uCurVal &gt; 1)                           // greater than 12 <br>   ) { <br> <br> MessageBeep( MB_OK ); <br> <br> return( 0 ); <br> <br>} else if ( uHourChars &lt; 2 ) { <br> <br>++uHourChars; <br> <br>} else { <br> <br>    MessageBeep( MB_OK ); <br> <br>    return( 0 ); <br> <br>} <br> <br>break; <br> <br>} // switch <br> <br>return CallWindowProc( (WNDPROC)lpHourDefProc, hWnd, message, uParam, lParam ) ; <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: JobAdd() <br>// <br>// Routine Description: <br>// <br>//     Adds a new item to schedule. <br>// <br>// Arguments: <br>// <br>//     None.  Uses globals. <br>// <br>// Return Value: <br>// <br>//     NET_API_STATUS return value of remote api call <br>// <br>//=========================================================================== <br>NET_API_STATUS <br>JobAdd( <br>    VOID <br>    ) <br>{ <br> <br>    NET_API_STATUS          status; <br> <br>    status = NetScheduleJobAdd( <br>GlobalComputerName, <br>(LPBYTE)&amp;GlobalAtInfo, <br>&amp;GlobalJobId <br>); <br> <br>    if ( status != NERR_Success ) { <br> <br>/*MessageBox( <br>    hGlobalhWnd, <br>    ( status == NERR_ServiceNotInstalled ? "The service has not been started" : "Message could not be added." ), <br>    SZWINDOWTITLE, <br>    MB_OK | MB_ICONEXCLAMATION <br>    ); <br>*/ <br> <br>MessagePrint( status ); <br>    } <br> <br>    return ( status ); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// <br>// FUNCTION: JobDel() <br>// <br>// <br>// Routine Description: <br>// <br>//     This does all of the processing necessary to dump out the entire <br>//     schedule file.  It loops through on each record and formats its <br>//     information for printing and then goes to the next. <br>// <br>// Arguments: <br>// <br>//     DEL_ALL if to delete all jobs, DEL_ID otherwise. <br>//     Uses globals. <br>// <br>// Return Value: <br>// <br>//     ERROR_SUCCESS                       if everything enumerated OK <br>//     error returned by remote api        otherwise <br>// <br>//=========================================================================== <br>NET_API_STATUS <br>JobDel( <br>    UINT Method, <br>    HWND hWnd <br>    ) <br>{ <br> <br>    DWORD                       dwSelection; <br>    NET_API_STATUS  status; <br>    UCHAR           szAtCommand[MAX_ATCMD_LEN]; <br>    UINT            JobId; <br>    UINT                        uSelection; <br>    UINT                        uCount; <br>    char *          ptr; <br> <br> <br>    if ( Method != DEL_ID_CHANGE ) { <br> <br>if ( AreYouSure(hWnd) == IDNO ) { <br> <br>return( ERROR_SUCCESS ); <br> <br>} <br> <br>    } <br> <br>    switch( Method ) { <br> <br>case DEL_ALL: <br> <br>    status = NetScheduleJobDel( <br>    GlobalComputerName, <br>    0, <br>    (DWORD)-1 <br>    ); <br> <br>    if ( status == NERR_Success ) { <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_NONE ); <br>break; <br> <br>    } <br> <br>    break; <br> <br>case DEL_ID: <br>case DEL_ID_CHANGE: <br> <br>    // compute id <br> <br>    uSelection = SendDlgItemMessage( hWnd, IDC_ATCOMMANDS, LB_GETCURSEL, 0, 0 ); <br>    uCount     = SendDlgItemMessage( hWnd, IDC_ATCOMMANDS, LB_GETCOUNT,  0, 0 ); <br> <br>    SendDlgItemMessage( <br>hWnd, <br>IDC_ATCOMMANDS, <br>LB_GETTEXT, <br>uSelection, <br>(LPARAM)szAtCommand <br>); <br> <br>    JobId = 0; <br>    ptr   = szAtCommand; <br> <br>    while( *ptr &gt;= '0' &amp;&amp; *ptr &lt;= '9' ) { <br> <br>JobId *= 10; <br>JobId += (UINT)*ptr - '0'; <br> <br>ptr++; <br> <br>    } <br> <br>    status = NetScheduleJobDel( <br>    GlobalComputerName, <br>    JobId, <br>    JobId <br>    ); <br> <br>    if ( status != NERR_Success) { <br> <br>//MessageBox( hWnd, "Problem deleteing a job.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>MessagePrint( status ); <br> <br>break; <br> <br>    } <br> <br>    if ( uCount == 1 ) { <br> <br>// this was the only job <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_NONE ); <br> <br>    } else if ( uSelection == 0 ) { <br> <br>// the first/top job was selected and there is more than 1 job <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_TOP ); <br> <br>    } else if ( ( uCount - 1 ) == uSelection ) { <br> <br>// the last/bottom job was selected <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_BOTTOM ); <br> <br>    } else { <br> <br>// the 2nd thru last-1 job was selected <br> <br>dwSelection  = 0; <br>dwSelection |= uSelection &lt;&lt; 16; <br>dwSelection |= SCS_SELINHIGHWORD; <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)dwSelection ); <br> <br>    } <br> <br>    break; <br> <br>    } <br> <br>    return( status ); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// <br>// FUNCTION: JobEnum() <br>// <br>// <br>// Routine Description: <br>// <br>//     This does all of the processing necessary to dump out the entire <br>//     schedule file.  It loops through on each record and formats its <br>//     information for printing and then goes to the next. <br>// <br>// Arguments: <br>// <br>//     None.  Uses globals. <br>// <br>// Return Value: <br>// <br>//     ERROR_SUCCESS                       if everything enumerated OK <br>//     error returned by remote api        otherwise <br>// <br>//=========================================================================== <br>NET_API_STATUS <br>JobEnum( <br>    DWORD SetCurrentSelection <br>    ) <br>{ <br> <br>    BOOL            fFlag; <br>    BOOL            first = TRUE; <br>    DWORD           EntriesRead; <br>    DWORD           ResumeJobId = 0; <br>    DWORD           TotalEntries; <br>    LPVOID          EnumBuffer = NULL; <br>    NET_API_STATUS  status = NERR_Success; <br>    PAT_ENUM        pAtEnum; <br>    //UCHAR           szTemp[80]; <br>    static UINT         uSelection; <br>    static UINT         uTopIndex; <br>    int             i; <br> <br>    // initialize to current selection <br> <br>uSelection = SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_GETCURSEL,   0, 0 ); <br>uTopIndex  = SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_GETTOPINDEX, 0, 0 ); <br> <br>if ( uSelection == LB_ERR ) { <br> <br>uSelection = 0; <br> <br>} <br> <br>    for ( ; ;) { <br> <br>status = NetScheduleJobEnum( <br>GlobalComputerName, <br>(LPBYTE *)&amp;EnumBuffer, <br>(DWORD)-1, <br>&amp;EntriesRead, <br>&amp;TotalEntries, <br>&amp;ResumeJobId <br>); <br> <br>if ( status != ERROR_SUCCESS  &amp;&amp;  status != ERROR_MORE_DATA) { <br> <br>    // <br>    // not needded since both the if/else(MessagePrint) will set this text now <br>    // <br>    //SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_RESETCONTENT, 0, 0 ); <br>    // <br>    //SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)szError ); <br> <br>    EnableWindow( GetDlgItem( hGlobalhWnd, IDC_ADD    ), FALSE ); <br>    EnableWindow( GetDlgItem( hGlobalhWnd, IDC_CHANGE ), FALSE ); <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_REMOVE ), FALSE ); <br> <br>if ( status == NERR_ServiceNotInstalled ) { <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_RESETCONTENT, 0, 0 ); <br> <br>#ifdef JAPAN <br>                SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)"                 N  " ); <br> <br>#else <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)"Schedule service not started." ); <br>#endif <br> <br>if ( ServiceNotStartedHandler() == FALSE ) { <br> <br>return( status ); <br> <br>} else { <br> <br>    continue; <br> <br>} <br> <br>} else  { <br> <br>/*wsprintf( szTemp, "The computer %s cannot be found.\nError %u.", &amp;szComputerM[2], status ); <br> <br>    MessageBox( <br> hGlobalhWnd, <br>szTemp, <br>SZWINDOWTITLE, <br>MB_OK | MB_ICONEXCLAMATION <br>); <br>    */ <br> <br>MessagePrint( status ); <br> <br>    return( status ); <br> <br>} <br> <br>} <br> <br>assert( status == ERROR_SUCCESS ? TotalEntries == EntriesRead : TotalEntries &gt; EntriesRead ); <br> <br>if ( TotalEntries == 0) { <br> <br>    break;  //  no items found <br> <br>} <br> <br>if ( first == TRUE) { <br> <br>    ResetListboxExtents( GetDlgItem( hGlobalhWnd, IDC_ATCOMMANDS ) ); <br>    SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_RESETCONTENT, 0, 0 ); <br> <br>    first = FALSE; <br> <br>} <br> <br>for ( pAtEnum = EnumBuffer;  EntriesRead-- &gt; 0;  pAtEnum++) { <br> <br>    // not sure what this is doing... <br> <br>    /* <br>    if ( pAtEnum-&gt;Flags &amp; JOB_EXEC_ERROR) { <br> <br>if ( MessageGet( APE2_GEN_ERROR, &amp;smallBuffer, 0 ) == 0) { <br> <br>    // error reported already <br>    exit( -1); <br> <br>} <br> <br>printf( DUMP_FMT1, smallBuffer ); <br>LocalFree( smallBuffer ); <br> <br>    } else { <br> <br>printf( DUMP_FMT1, L""); <br> <br>    } <br>    */ <br> <br>    // replate with... <br> <br>    if ( pAtEnum-&gt;Flags &amp; JOB_EXEC_ERROR) { <br> <br>MessagePrint( APE2_GEN_ERROR ); <br> <br>    } <br> <br>    szWhenDay[0] = '\0'; <br> <br>    if ( pAtEnum-&gt;Flags &amp; JOB_RUN_PERIODICALLY ) { <br> <br>#ifdef JAPAN <br>                lstrcat( szWhenDay, "   " ); <br>#else <br>lstrcat( szWhenDay, "Each " ); <br>#endif <br> <br>    } else if ( pAtEnum-&gt;DaysOfWeek != 0 || pAtEnum-&gt;DaysOfMonth != 0 ) { <br> <br>#ifdef JAPAN <br>                lstrcat( szWhenDay, "     " ); <br>#else <br>lstrcat( szWhenDay, "Next " ); <br>#endif <br> <br>    } else if ( pAtEnum-&gt;Flags &amp; JOB_RUNS_TODAY ) { <br> <br>#ifdef JAPAN <br>                lstrcat( szWhenDay, "     " ); <br>#else <br>lstrcat( szWhenDay, "Today " ); <br>#endif <br> <br>    } else { <br> <br>#ifdef JAPAN <br>                lstrcat( szWhenDay, "     " ); <br>#else <br>lstrcat( szWhenDay, "Tomorrow " ); <br>#endif <br> <br>    } <br> <br>    if ( pAtEnum-&gt;DaysOfWeek != 0 ) { <br> <br>for ( i=0; i&lt;7; ++i ) { <br> <br>    if ( ( pAtEnum-&gt;DaysOfWeek &amp; ( 1 &lt;&lt; i ) ) != 0 ) { <br> <br>lstrcat( szWhenDay, szDayAbbr[i] ); <br> <br>    } <br> <br>} <br> <br>    } <br> <br>    if ( pAtEnum-&gt;DaysOfMonth != 0 ) { <br> <br>for ( i=0; i&lt;31; ++i ) { <br> <br>    if ( ( pAtEnum-&gt;DaysOfMonth &amp; ( 1L &lt;&lt; i ) ) != 0 ) { <br> <br>wsprintf( szDateAbbr, "%d ", i+1 ); <br> <br>lstrcat( szWhenDay, szDateAbbr ); <br>#ifdef JAPAN <br>                        lstrcat( szWhenDay, "  " ); <br>#endif <br>    } <br> <br>} <br> <br>    } <br> <br> <br>    dwTime     = pAtEnum-&gt;JobTime / 1000 / 60;       // total minutes <br> <br>    szTime[0]  = (UCHAR)( dwTime / 600 ) + '0';      // 10s of hours <br>    dwTime    %= 600; <br> <br>    szTime[1]  = (UCHAR)( dwTime / 60 )  + '0';      // 1s of hours <br>    dwTime    %= 60; <br> <br>    szTime[2]  = ':'; <br> <br>    szTime[3]  = (UCHAR)( dwTime / 10 )  + '0';      // 10s of minutes <br>    dwTime    %= 10; <br> <br>    szTime[4]  = (UCHAR)( dwTime )       + '0';      // 1s of minutes <br> <br>    szTime[5]  = '\0'; <br> <br>    // convert this 24-hour time to AM/PM form <br> <br>    szTime[5] = 'A'; <br>    szTime[6] = 'M'; <br>    szTime[7] = '\0'; <br> <br>// if it is past 1000 but before 2000 (24-hour time) <br> <br>    if ( szTime[0] == '1' ) { <br> <br>// if it is past 1100 <br> <br>if ( szTime[1] &gt;= '2' ) { <br> <br>szTime[5] = 'P'; <br> <br>} <br> <br>    if( szTime [1] &gt; '2' ) { <br> <br>szTime[0] -= 1; <br>szTime[1] -= 2; <br> <br>    } <br> <br>    } else if ( szTime[0] == '2' ) { <br> <br>// it is 2000 or later <br> <br>szTime[5] = 'P'; <br> <br>    // if it is 2200 or later <br> <br>    if( szTime [1] &gt;= '2' ) { <br> <br>szTime[0] -= 1; <br>szTime[1] -= 2; <br> <br>    } else { <br> <br>szTime[0] -= 2; <br>szTime[1] += 8; <br> <br>    } <br> <br>} <br> <br>if ( szTime[0] == '0' ) { <br> <br>if ( szTime[1] == '0' ) { <br> <br>// 12 am or pm <br> <br>szTime[0] = '1'; <br>szTime[1] = '2'; <br> <br>} else { <br> <br>szTime[0] = ' '; <br> <br>} <br> <br>} <br> <br>#ifdef JAPAN <br>            { <br>                char szBuf[sizeof(szTime)]; <br> <br>                strcpy(szBuf, szTime); <br>                strcpy(szTime, szBuf[5] == 'A' ? "   O " : "     "); <br>                szBuf[5] = '\0'; <br>                strcat(szTime, szBuf); <br>            } <br>#endif <br> <br>    WideCharToMultiByte( <br>CP_ACP, <br>0, <br>pAtEnum-&gt;Command, <br>-1, <br>szCommandM, <br>MAXCOMMANDLEN, <br>szDefault, <br>&amp;fFlag <br>); <br> <br>    wsprintf( szAtCommand, "%d\t", pAtEnum-&gt;JobId ); <br>    lstrcat( szAtCommand, szWhenDay  ); <br>    lstrcat( szAtCommand, "\t"       ); <br>    lstrcat( szAtCommand, szTime     ); <br>    lstrcat( szAtCommand, "\t"       ); <br>    lstrcat( szAtCommand, szCommandM ); <br> <br>    WAddExtentEntry( GetDlgItem( hGlobalhWnd, IDC_ATCOMMANDS ), szAtCommand ); <br>    SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)szAtCommand ); <br> <br>} <br> <br>if ( EnumBuffer != NULL ) { <br> <br>    (VOID)NetApiBufferFree( (LPVOID)EnumBuffer ); <br>    EnumBuffer = NULL; <br> <br>} <br> <br>if ( status == ERROR_SUCCESS ) { <br> <br>    break;  //  we have read &amp; displayed all the items <br> <br>} <br> <br>    } // for <br> <br>    if ( first == TRUE) { <br> <br>ResetListboxExtents( GetDlgItem( hGlobalhWnd, IDC_ATCOMMANDS ) ); <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_RESETCONTENT, 0, 0 ); <br>WAddExtentEntry( GetDlgItem( hGlobalhWnd, IDC_ATCOMMANDS ), szNoEntries ); <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)szNoEntries ); <br> <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_ADD ), TRUE ); <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_CHANGE ), FALSE ); <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_REMOVE ), FALSE ); <br> <br>    } else { <br> <br>switch ( LOWORD( SetCurrentSelection ) ) { <br> <br>case SCS_BOTTOM: <br> <br>uSelection = SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_GETCOUNT, 0, 0 ) - 1; <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_SETCURSEL,  uSelection,     0 ); <br> <br>break; <br> <br>    case SCS_NOCHANGE: <br> <br>// uSelection has already been set <br> <br>    SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_SETCURSEL,  uSelection, 0 ); <br> <br>    break; <br> <br>case SCS_TOP: <br> <br>uSelection = 0; <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_SETCURSEL,  uSelection,     0 ); <br> <br>break; <br> <br>case SCS_SELINHIGHWORD: <br> <br>    uSelection = HIWORD( SetCurrentSelection ); <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_SETCURSEL,  uSelection,     0 ); <br> <br>break; <br> <br>case SCS_NONE: <br>default: <br> <br>break; <br> <br>} <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_SETTOPINDEX,  uTopIndex,    0 ); <br> <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_ADD ), TRUE ); <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_CHANGE ), TRUE ); <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_REMOVE ), TRUE ); <br> <br>    } <br> <br>    return( ERROR_SUCCESS ); <br> <br>} <br> <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: MessagePrint() <br>//=========================================================================== <br>DWORD <br>MessagePrint( <br>    IN      DWORD       MessageId, <br>    ... <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Finds the unicode message corresponding to the supplied message id, <br>    merges it with caller supplied string(s), and prints the resulting <br>    string. <br> <br>Arguments: <br> <br>    MessageId       -   message id <br> <br>Return Value: <br> <br>    Count of characters, not counting the terminating null character, <br>    printed by this routine.  Zero return value indicates failure. <br> <br>--*/ <br>{ <br>    va_list             arglist; <br>    UCHAR *             buffer = NULL; <br>    UCHAR *                     ptr; <br>    DWORD               length; <br>    LPVOID              lpSource; <br>    DWORD               dwFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY | <br>  FORMAT_MESSAGE_ALLOCATE_BUFFER; <br> <br> <br>    va_start( arglist, MessageId ); <br> <br>    if ( MessageId &lt; NERR_BASE) { <br>// <br>//  Get message from system. <br>// <br>lpSource = NULL; // redundant step according to FormatMessage() spec <br>dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM; <br> <br>    } else if (  ( MessageId &gt;= APE2_AT_DEL_WARNING <br>    &amp;&amp;  MessageId &lt;= APE2_AT_DI_COMMAND) <br>      // <br>      // I cannot find these definitions!!!! <br>      // <br>      //|| ( MessageId &gt;= IDS_LOAD_LIBRARY_FAILURE <br>      //      &amp;&amp;  MessageId &lt;= IDS_USAGE ) <br>      ) { <br>// <br>//  Get message from this module. <br>// <br>lpSource = NULL; <br>dwFlags |= FORMAT_MESSAGE_FROM_HMODULE; <br> <br>    } else { <br>// <br>//  Get message from netmsg.dll. <br>// <br>lpSource = GlobalMessageHandle; <br>dwFlags |= FORMAT_MESSAGE_FROM_HMODULE; <br>    } <br> <br>    length = FormatMessage( <br>    dwFlags,                                          //  dwFlags <br>    lpSource,                                         //  lpSource <br>    MessageId,                                        //  MessageId <br>    0L,                                               //  dwLanguageId <br>    (LPTSTR)&amp;buffer,                                 //  lpBuffer <br>    0,                                                //  size <br>    (va_list *) &amp;arglist                              //  lpArguments <br>    ); <br> <br>    if ( length != 0) { <br> <br>//change to MessageBox <br>//printf( "%ws", buffer ); <br> <br>ptr = buffer; <br> <br>while ( *ptr ) { <br>#ifdef DBCS <br>            if (IsDBCSLeadByte(*ptr)) { <br>                ptr++; <br>            } else <br>#endif <br>    if ( ( *ptr &lt; ' ' ) || ( *ptr &gt; '~' ) ) { <br> <br>*ptr = ' '; <br> <br>    } <br> <br>ptr++; <br> <br>} <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_RESETCONTENT, 0, 0 ); <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)(LPTSTR)buffer ); <br> <br>MessageBox( hGlobalhWnd, (LPCTSTR)buffer, SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>LocalFree( buffer ); <br> <br>    } <br> <br>    return( length); <br> <br>} // MessagePrint() <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: MinProc() <br>//=========================================================================== <br>LRESULT APIENTRY MinProc( HWND hWnd, UINT message, UINT uParam, LONG lParam ) <br>{ <br>    UINT  uCurVal; <br>    UCHAR szCurVal[3]; <br> <br>    switch ( message ) { <br> <br>    case WM_COPY: <br>    case WM_PASTE: <br>    case WM_CUT: <br> <br>// cut and paste dont seem to work... <br> <br>break; <br> <br>// jean-marc - start <br>      case WM_SETFOCUS: <br>hCurrentFocus = hWnd; <br>break; <br>// jean-marc - end <br> <br>case WM_CHAR: <br> <br>if ( uParam == VK_BACK ) { <br> <br>if ( uMinChars &gt; 0 ) { <br> <br>--uMinChars; <br> <br>} <br> <br>return CallWindowProc( (WNDPROC)lpMinDefProc, hWnd, message, uParam, lParam ) ; <br> <br>} else { <br> <br>uMinChars = (UINT) SendMessage( hWnd, WM_GETTEXT, 2, (LPARAM)szCurVal ); <br> <br>if ( uMinChars == 0 ) { <br> <br>uCurVal = 0; <br> <br>    } else if ( uMinChars == 1 ) { <br> <br>uCurVal = szCurVal[0] - '0'; <br> <br>    } else if ( uMinChars == 2 ) { <br> <br>uCurVal  = szCurVal[0] - '0'; <br>uCurVal *= 10; <br>uCurVal  = szCurVal[1] - '0'; <br> <br>    } else if ( uMinChars &gt; 2 ) { <br> <br>uMinChars = 0; <br> <br>SendMessage( hWnd, WM_SETTEXT, 0, (LPARAM)"" ); <br> <br>return( 0 ); <br> <br>    } <br> <br>} <br> <br>if ( ( uParam == ' ' )                  ||  // space <br>     ( uParam &lt; '0' || uParam &gt; '9' )   ||  // not a number <br>     ( uCurVal &gt;= 6  )                      // greater than 59 <br>   ) { <br> <br> MessageBeep( MB_OK ); <br> <br> return( 0 ); <br> <br>} else if ( uMinChars &lt; 2 ) { <br> <br>++uMinChars; <br> <br>} else { <br> <br>    MessageBeep( MB_OK ); <br> <br>    return( 0 ); <br> <br>} <br> <br>break; <br> <br>} // switch <br> <br>return CallWindowProc( (WNDPROC)lpMinDefProc, hWnd, message, uParam, lParam ) ; <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: Refresh() <br>//=========================================================================== <br>UINT <br>Refresh(UINT Command) <br>{ <br> <br>    static BOOL fOkayToRefresh; <br>static BOOL     fOkayToRefreshSave; <br> <br>switch( Command ) { <br> <br>case REFRESH_FALSE: <br> <br>    fOkayToRefresh = FALSE; <br> <br>break; <br> <br>case REFRESH_TRUE: <br> <br>    fOkayToRefresh = TRUE; <br> <br>break; <br> <br>case REFRESH_QUERY: <br> <br>return( fOkayToRefresh ); <br> <br>break; <br> <br>case REFRESH_SAVE: <br> <br>    fOkayToRefreshSave = fOkayToRefresh; <br> <br>break; <br> <br>case REFRESH_RESTORE: <br> <br>    fOkayToRefresh = fOkayToRefreshSave; <br> <br>break; <br>} <br> <br>return( REFRESH_ERROR ); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: SelectComputerProc() <br>//=========================================================================== <br>BOOL APIENTRY SelectComputerProc( <br>HWND hWnd,         // window handle <br>UINT message,      // type of message <br>UINT uParam,       // additional information <br>LONG lParam)       // additional information <br>{ <br> <br>    DWORD           dwLen = MAXCOMPUTERNAMELEN + 1; <br>    UCHAR           szSelectComputer[MAXCOMPUTERNAMELEN+1]; <br>    int             wmEvent; <br>    int             wmId; <br>// jean-marc - start <br>    UCHAR           szComputerMTemp[MAXCOMPUTERNAMELEN+1];  // multibyte comp. name <br>// jean-marc - end <br> <br>    switch (message) { <br> <br>case WM_INITDIALOG: <br>// jean-marc - start <br>    // set the text limit for the IDC_SELECTCOMPUTER edit field to be <br>    // MAXCOMPUTERNAMELEN <br>    SendDlgItemMessage(hWnd, <br>       IDC_SELECTCOMPUTER, <br>       EM_LIMITTEXT, <br>       MAXCOMPUTERNAMELEN, <br>       0); <br>// jean-marc - end <br> <br>    if ( !GetComputerName( szSelectComputer, &amp;dwLen ) ) { <br> <br>#ifdef JAPAN <br>MessageBox( hWnd, " R   s   [ ^       G   [.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>MessageBox( hWnd, "Problem getting computer name.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br>} else { <br> <br>SetDlgItemText( hWnd, IDC_SELECTCOMPUTER, szSelectComputer ); <br> <br>} <br> <br>break; <br> <br>case WM_COMMAND:    // message: command from application menu <br> <br>    // Message packing of uParam and lParam have changed for Win32, let us <br>    // handle the differences in a conditional compilation: <br> <br>wmId    = LOWORD(uParam); <br>wmEvent = HIWORD(uParam); <br> <br>switch (wmId) { <br> <br>case IDCANCEL: <br> <br>EndDialog( hWnd, IDCANCEL ); <br> <br>break; <br> <br>case IDOK: <br> <br>    GetDlgItemText( hWnd, IDC_SELECTCOMPUTER, &amp;szComputerMTemp[0], MAXCOMPUTERNAMELEN ); <br> <br>// jean-marc - start <br>    // make sure backslashes are there, if not then add them <br>    if (szComputerMTemp[0] == '\\' &amp;&amp; szComputerMTemp[1] == '\\') <br>      lstrcpy(szComputerM, szComputerMTemp); <br>    else if (szComputerMTemp[0] != '\\' &amp;&amp; szComputerMTemp[1] != '\\') <br>      wsprintf(szComputerM, "\\\\%s", szComputerMTemp); <br>    else if (szComputerMTemp[0] == '\\' || szComputerMTemp[1] == '\\') <br>      wsprintf(szComputerM, "\\%s", szComputerMTemp); <br>    if (lstrlen(szComputerM) &gt; MAXCOMPUTERNAMELEN || lstrlen(szComputerM) == 2) <br>#ifdef JAPAN <br>                    MessageBox( hWnd, " R   s   [ ^     P     P T    (   p)                           B", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>      MessageBox( hWnd, "Computer names are 1 to 15 characters long.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br>// jean-marc - end <br> <br>    else { <br> <br>    SetDlgItemText( hGlobalhWnd, IDC_COMPUTER, &amp;szComputerM[2] ); <br> <br>MultiByteToWideChar( <br>CP_ACP, <br>MB_PRECOMPOSED, <br>szComputerM, <br>-1, <br>szComputerW, <br>MAXCOMPUTERNAMELEN <br>); <br> <br>GlobalComputerName = szComputerW; <br> <br>Refresh( REFRESH_TRUE ); <br> <br>    EndDialog( hWnd, IDOK ); <br> <br>} <br> <br>    break; <br> <br>    } <br> <br>break; <br> <br>    } <br> <br>    return (0); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: ServiceNotStartedHandler() <br>//=========================================================================== <br>BOOL <br>ServiceNotStartedHandler(VOID) <br>{ <br> <br>    BOOL            Done; <br>    SC_HANDLE       schSCManager; <br>    SC_HANDLE       schService; <br>    SERVICE_STATUS  ssServiceStatus; <br>    UCHAR           szService[] = "Schedule"; <br>    UCHAR           szTemp[80]; <br> <br>#ifdef JAPAN <br>    wsprintf( szTemp, "%s    X P W   [   T [ r X   J n               B\n J n         H", &amp;szComputerM[2] ); <br>#else <br>    wsprintf( szTemp, "Schedule service on %s not started.\nWould you like to start it?", &amp;szComputerM[2] ); <br>#endif <br> <br>if ( MessageBox( hGlobalhWnd, szTemp, SZWINDOWTITLE, MB_YESNO ) == IDYES ) { <br> <br>    schSCManager = OpenSCManager( szComputerM, NULL, SC_MANAGER_ALL_ACCESS ); <br> <br>    if ( schSCManager == NULL ) { <br> <br>#ifdef JAPAN <br>    wsprintf( szTemp, " T [ r X R   g   [    } l [ W    A N Z X G   [\n\nError %d.", GetLastError() ); <br>#else <br>wsprintf( szTemp, "Problem accessing Service Control Manager.\n\nError %d.", GetLastError() ); <br>#endif <br> <br>MessageBox( hGlobalhWnd, szTemp, SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>    return( FALSE ); <br> <br>    } else { <br> <br>schService = OpenService( schSCManager, szService, SERVICE_ALL_ACCESS ); <br> <br>if ( schService == NULL ) { <br> <br>#ifdef JAPAN <br>    wsprintf( szTemp, " X P [ W   [    T [ r X  I [ v    G   [\n\nError %d.", GetLastError() ); <br>#else <br>wsprintf( szTemp, "Problem opening Schedule service.\n\nError %d.", GetLastError() ); <br>#endif <br> <br>MessageBox( hGlobalhWnd, szTemp, SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>return( FALSE ); <br> <br>    } else { <br> <br>if ( StartService( schService, 0, NULL ) == FALSE ) { <br> <br>#ifdef JAPAN <br>    wsprintf( szTemp, " X P W   [    T [ r X  J n  G   [\n\nError %d.", GetLastError() ); <br>#else <br>wsprintf( szTemp, "Problem starting Schedule service.\n\nError %d.", GetLastError() ); <br>#endif <br> <br>MessageBox( hGlobalhWnd, szTemp, SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>return( FALSE ); <br> <br>    } else { <br> <br>// wait for service to start <br> <br>Done = FALSE; <br> <br>while( !Done ) { <br> <br>if ( QueryServiceStatus( schService, &amp;ssServiceStatus ) == FALSE ) { <br> <br>#ifdef JAPAN <br>    wsprintf( szTemp, " T [ r X  X e C ^ X     G   [\n\nError %d.", GetLastError() ); <br>#else <br>wsprintf( szTemp, "Problem getting service status.\n\nError %d.", GetLastError() ); <br>#endif <br> <br>MessageBox( hGlobalhWnd, szTemp, SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>return( FALSE ); <br> <br>} else { <br> <br>switch ( ssServiceStatus.dwCurrentState ) { <br> <br>case SERVICE_START_PENDING: <br> <br>Sleep( ssServiceStatus.dwWaitHint ); <br> <br>break; <br> <br>case SERVICE_RUNNING: <br> <br>    Done = TRUE; <br> <br>break; <br> <br>default: <br> <br>#ifdef JAPAN <br>wsprintf( szTemp, " \           T [ r X  X e C ^ X\n\nState %d.", ssServiceStatus.dwCurrentState ); <br>#else <br>wsprintf( szTemp, "Unexpected service state.\n\nState %d.", ssServiceStatus.dwCurrentState ); <br>#endif <br> <br>MessageBox( hGlobalhWnd, szTemp, SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>Done = TRUE; <br> <br>break; <br> <br>} <br> <br>} <br> <br>} <br> <br>    } <br> <br>CloseServiceHandle(schService); <br> <br>} <br> <br>CloseServiceHandle(schSCManager); <br> <br>    } <br> <br>SendDlgItemMessage( hGlobalhWnd, IDC_ATCOMMANDS, LB_RESETCONTENT, 0, 0 ); <br> <br>SendDlgItemMessage( <br>hGlobalhWnd, <br>IDC_ATCOMMANDS, <br>LB_ADDSTRING, <br>0, <br>#ifdef JAPAN <br>        (LPARAM)" X P W   [    T [ r X         J n           B" ); <br>#else <br>(LPARAM)"The Schedule service was started successfully." ); <br>#endif <br> <br>MessageBox( <br>hGlobalhWnd, <br>#ifdef JAPAN <br>" X P W   [    T [ r X         J n           B",  <br>#else <br>"The Schedule service was started successfully.", <br>#endif <br>SZWINDOWTITLE, <br>MB_OK ); <br> <br>return( TRUE ); <br> <br>} else { <br> <br>    Refresh( REFRESH_FALSE ); <br> <br>MessageBox( <br>hGlobalhWnd, <br>#ifdef JAPAN <br>" \         I     X V           B \     X V             A[ t @ C  ]   j   [  [ R   s   [ ^   I  ]   I             B",  <br>#else <br>"The display will not be refreshed automatically.  Chose File, Select Computer to refresh the display.", <br>#endif <br>SZWINDOWTITLE, <br>MB_OK | MB_ICONEXCLAMATION ); </code></pre>
<p>
</p>
<pre><code><br>} <br> <br>return( FALSE ); <br> <br>} <br> <br>  <br>//=========================================================================== <br>// FUNCTION: ValidateAddChangeArguments() <br>//=========================================================================== <br>BOOL <br>ValidateAddChangeArguments( <br>HWND hWnd <br>) <br>{ <br> <br>    SYSTEMTIME              SysTime; <br>#ifdef JAPAN <br>    UCHAR                   szAmPm[5]; <br>#else <br>    UCHAR                   szAmPm[3]; <br>#endif <br>    UINT                    Items[NUMDAYITEMS]; <br>    UINT                    NumSelected; <br>    UINT                    i; <br> <br>// initialize <br> <br>    memset( (PBYTE)&amp;GlobalAtInfo, '\0', sizeof(GlobalAtInfo) ); <br> <br>// command <br> <br>    SendDlgItemMessage( hWnd, IDC_NEWCOMMAND, WM_GETTEXT, MAXCOMMANDLEN, (LPARAM)szCommandM ); <br> <br>    if ( szCommandM[0] == 0 ) { <br> <br>MessageBox( <br>    hWnd, <br>#ifdef JAPAN <br>            " R }   h                   B", <br>#else <br>    "Enter a command.", <br>#endif <br>    SZWINDOWTITLE, <br>    MB_OK | MB_ICONEXCLAMATION <br>    ); <br> <br>SetFocus( GetDlgItem( hWnd, IDC_NEWCOMMAND ) ); <br> <br>return ( FALSE ); <br> <br>    } <br> <br>MultiByteToWideChar( <br>CP_ACP, <br>MB_PRECOMPOSED, <br>szCommandM, <br>-1, <br>szCommandW, <br>MAXCOMMANDLEN <br>); <br> <br>    GlobalAtInfo.Command = szCommandW; <br> <br>// hours <br> <br>    GlobalAtInfo.JobTime = GetDlgItemInt( hWnd, IDC_HOUR, NULL, FALSE ); <br> <br>    GetDlgItemText( hWnd, IDC_AMPM, (LPTSTR)&amp;szAmPm, sizeof(szAmPm) ); <br> <br>#ifdef JAPAN <br>    if (strcmp(szAmPm, "   O")) { <br>#else <br>    if ( szAmPm[0] == 'P' || szAmPm[0] == 'p' ) { <br>#endif <br>if( GlobalAtInfo.JobTime != 12 ) { <br> <br>GlobalAtInfo.JobTime += 12; <br> <br>} <br> <br>    } else if( GlobalAtInfo.JobTime == 12 ) { <br> <br>GlobalAtInfo.JobTime = 0; <br> <br>    } <br> <br> <br>    // convert to minutes <br> <br>GlobalAtInfo.JobTime *= 60; <br> <br>// add minutes <br> <br>GlobalAtInfo.JobTime += GetDlgItemInt( hWnd, IDC_MIN, NULL, FALSE ); <br> <br>// convert to milliseconds <br> <br>GlobalAtInfo.JobTime *= 60 * 1000; <br> <br>GetLocalTime( &amp;SysTime ); <br> <br>    if ( SendDlgItemMessage( hWnd, IDC_TODAY, BM_GETCHECK, 0, 0 ) ) { <br> <br>if ( (DWORD)( (SysTime.wHour * 60 + SysTime.wMinute) * 60 * 1000) &gt;= GlobalAtInfo.JobTime ) { <br> <br>MessageBox( <br>hWnd, <br>#ifdef JAPAN <br>" w                               B     R }   h         s         B",  <br>#else <br>"The time you have selected has already passed.  The command will run tomorrow.", <br>#endif <br>SZWINDOWTITLE, <br>MB_OK | MB_ICONEXCLAMATION <br>); <br> <br>} <br> <br>} <br> <br>if ( SendDlgItemMessage( hWnd, IDC_EVERY, BM_GETCHECK, 0, 0 ) || <br>     SendDlgItemMessage( hWnd, IDC_NEXT, BM_GETCHECK, 0, 0 )    ) { <br> <br>// day <br>// NOTE: I am assuming that this lisbox will always be correct <br>//       and if you select Today/Tomorrow the proper day is selected. <br> <br>NumSelected = SendDlgItemMessage( hWnd, IDC_DAYS, LB_GETSELCOUNT, 0, 0 ); <br> <br>if ( NumSelected == 0 ) { <br> <br>MessageBox( <br>    hWnd, <br>#ifdef JAPAN <br>            " R }   h     s         I             B", <br>#else <br>    "Select the day(s) this command will run.", <br>#endif <br>    SZWINDOWTITLE, <br>    MB_OK | MB_ICONEXCLAMATION <br>    ); <br> <br>SetFocus( GetDlgItem( hWnd, IDC_DAYS ) ); <br> <br>return ( FALSE ); <br> <br>} <br> <br>SendDlgItemMessage( hWnd, IDC_DAYS, LB_GETSELITEMS, NUMDAYITEMS, (LPARAM)Items ); <br> <br>for( i=0; i&lt;NumSelected; ++i ) { <br> <br>if ( Items[i] &gt; 6 ) { <br> <br>// days of month <br>//0-based, 7 and up are dates (1-31) <br> <br>    GlobalAtInfo.DaysOfMonth |= ( 1 &lt;&lt; ( Items[i]-7 ) ); <br> <br>} else { <br> <br>    // days of week <br>    // 0-based, first 7 are days (M-Su) <br> <br>GlobalAtInfo.DaysOfWeek |= ( 1 &lt;&lt; Items[i] ); <br> <br>} <br> <br>} <br> <br>// flags <br> <br>if ( SendDlgItemMessage( hWnd, IDC_EVERY, BM_GETCHECK, 0, 0 ) ) { <br> <br>    GlobalAtInfo.Flags |= JOB_RUN_PERIODICALLY; <br> <br>} <br> <br>} else if ( SendDlgItemMessage( hWnd, IDC_TOMORROW, BM_GETCHECK, 0, 0 ) ) { <br> <br>i = SendDlgItemMessage( hWnd, IDC_DAYS, LB_GETCURSEL, 0, 0 ); <br> <br>if ( i == 0 ) { <br> <br>    // set to Sunday <br> <br>GlobalAtInfo.DaysOfWeek = ( 1 &lt;&lt; 6 ); <br> <br>} else { <br> <br>    // increment to tomorrow <br> <br>GlobalAtInfo.DaysOfWeek |= ( 1 &lt;&lt; i ); <br> <br>} <br> <br>} <br> <br>return( TRUE ); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: WINATDlgProc() <br>//=========================================================================== <br>BOOL APIENTRY WINATDlgProc( <br>HWND hWnd,         // window handle <br>UINT message,      // type of message <br>UINT uParam,       // additional information <br>LONG lParam)       // additional information <br>{ <br> <br>    FARPROC         lpAddChangeDlgProc;  // pointer to the "AddChange" function <br>    FARPROC         lpProcSelect; <br>    NET_API_STATUS  status; <br>    int             wmEvent; <br>    int             wmId; <br>    int                         iDlgRetCode; <br>// jean-marc - start <br>    LOGFONT         lfComputerName; <br>    static HFONT    hFontComputerName = NULL; <br>    BOOL            bGetComputerName = FALSE; <br>// jean-marc - end <br> <br>    switch (message) { <br> <br>case WM_INITDIALOG: <br>// jean-marc - start <br>    // retrieve the font of the field IDC_COMPUTER <br>    hFontComputerName = (HFONT)SendDlgItemMessage(hWnd, <br>  IDC_COMPUTER, <br>  WM_GETFONT, <br>  0, <br>  0L); <br> <br>    // now get the logfont description of the font handle <br>    if (GetObject(hFontComputerName, sizeof(LOGFONT), &amp;lfComputerName)) <br>    { <br>// now make the font underlined <br>lfComputerName.lfUnderline = 1; <br> <br>// next recreate a font handle from this logfont <br>hFontComputerName = CreateFontIndirect(&amp;lfComputerName); <br> <br>// finally set the font handle for the edit field <br>if (hFontComputerName) <br>  SendDlgItemMessage(hWnd, <br>     IDC_COMPUTER, <br>     WM_SETFONT, <br>     (WPARAM)hFontComputerName, <br>     1L); <br>    } <br>// jean-marc - end <br>#ifdef JAPAN <br>#else <br>    lf.lfEscapement    = 0; <br>    lf.lfOrientation   = 0; <br>    lf.lfOutPrecision  = OUT_DEFAULT_PRECIS; <br>    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br>    lf.lfHeight        = 14; <br>    lf.lfWidth         = 0; //6; //5 <br>    lf.lfWeight        = 0; <br> <br>    lf.lfItalic        = 0; <br>    lf.lfUnderline     = 0; <br>    lf.lfStrikeOut     = 0; <br> <br>    lf.lfPitchAndFamily=VARIABLE_PITCH | FF_SWISS; <br> <br>    hFont = CreateFontIndirect( &amp;lf ); <br> <br>    if ( hFont != NULL ) { <br> <br>SendDlgItemMessage( hWnd, IDC_ATCOMMANDS, WM_SETFONT, (WPARAM)hFont, 1L ); <br> <br>    } else { <br> <br>MessageBox( hWnd, "Problem creating font.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br> <br>    } <br>#endif // !JAPAN <br> <br>    hCursorWait = LoadCursor( NULL, IDC_WAIT ); <br> <br>    if ( !FInitListboxExtents( GetDlgItem( hWnd, IDC_ATCOMMANDS ) ) ) { <br> <br>#ifdef JAPAN <br>                MessageBox( hWnd, "       l     s", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>MessageBox( hWnd, "Scrolling broken", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br> <br>    } <br> <br>    hGlobalhWnd = hWnd; <br> <br>    // get values from registry <br> <br>    SendMessage(hWnd, WM_COMMAND, IDM_GET_FROM_REGISTRY, 0); <br> <br>    // set tabstops for commands <br> <br>    { <br> <br>#ifdef JAPAN <br>                UINT Tabs[3] = { 22, 72, 124 }; <br>#else <br>UINT Tabs[3] = { 25, 110, 145 }; <br>#endif <br> <br>SendDlgItemMessage( hWnd, IDC_ATCOMMANDS, LB_SETTABSTOPS, 3, (LPARAM)Tabs ); <br> <br>    } <br> <br>// get local computer name <br> <br>{ <br> <br>DWORD dwLen = MAXCOMPUTERNAMELEN; <br> <br>// jean-marc - start <br>// process the commandline <br>if (gszCommandLine[0]) <br>{ <br>  // make sure backslashes are there, if not then add them <br>  if (gszCommandLine[0] == '\\' &amp;&amp; gszCommandLine[1] == '\\') <br>    lstrcpy(szComputerM, gszCommandLine); <br>  else if (gszCommandLine[0] != '\\' &amp;&amp; gszCommandLine[1] != '\\') <br>    wsprintf(szComputerM, "\\\\%s", gszCommandLine); <br>  else if (gszCommandLine[0] == '\\' || gszCommandLine[1] == '\\') <br>    wsprintf(szComputerM, "\\%s", gszCommandLine); <br>  if (lstrlen(szComputerM) &gt; MAXCOMPUTERNAMELEN || lstrlen(szComputerM) == 2) <br>  { <br>#ifdef JAPAN <br>                        MessageBox( hWnd, " R   s   [ ^     P     P T    (   p)                           B", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>    MessageBox( hWnd, "Computer names are 1 to 15 characters long.\nUsing local computer name.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br>    bGetComputerName = GetComputerName( &amp;szComputerM[2], &amp;dwLen ); <br>    if (!bGetComputerName) <br>#ifdef JAPAN <br>MessageBox( hWnd, " R   s   [ ^       G   [", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>      MessageBox( hWnd, "Problem getting computer name", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br>  } <br>  else <br>    bGetComputerName = TRUE; <br>} <br>else <br>{ <br>  bGetComputerName = GetComputerName( &amp;szComputerM[2], &amp;dwLen ); <br>  if (!bGetComputerName) <br>#ifdef JAPAN <br>    MessageBox( hWnd, " R   s   [ ^       G   [", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>    MessageBox( hWnd, "Problem getting computer name", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br>} <br>// jean-marc - end <br> <br>    if (bGetComputerName) { <br> <br>    szComputerM[0] = '\\'; <br>szComputerM[1] = '\\'; <br> <br>    MultiByteToWideChar( <br>CP_ACP, <br>MB_PRECOMPOSED, <br>szComputerM, <br>-1, <br>szComputerW, <br>MAXCOMMANDLEN <br>); <br> <br>    // set GlobalComputerName for all functions to use <br>// only Select Computer will ever change this value <br> <br>    GlobalComputerName = szComputerW; <br> <br>SendDlgItemMessage( hWnd, IDC_COMPUTER, WM_SETTEXT, 0, (LPARAM)&amp;szComputerM[2]  ); <br> <br>} <br> <br>} <br> <br>    // set initial states of buttons to disabled <br> <br>    EnableWindow( GetDlgItem( hGlobalhWnd, IDC_ADD    ), FALSE ); <br>    EnableWindow( GetDlgItem( hGlobalhWnd, IDC_CHANGE ), FALSE ); <br>EnableWindow( GetDlgItem( hGlobalhWnd, IDC_REMOVE ), FALSE ); <br> <br>// initialize the commands window <br> <br>#ifdef JAPAN <br>        SendDlgItemMessage( hWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)"        " ); <br>#else <br>SendDlgItemMessage( hWnd, IDC_ATCOMMANDS, LB_ADDSTRING, 0, (LPARAM)"Initializing" ); <br>#endif <br> <br>// set up timer to go off very soon after the dlgbox is created <br> <br>    uTimer = SetTimer( hWnd, 1, 1000, NULL ); <br>    fTimer = FIRST_TIME; <br>    Refresh( REFRESH_TRUE ); <br> <br> <br>    GlobalMessageHandle = LoadLibrary( "netmsg.dll" ); <br> <br>    if ( GlobalMessageHandle == NULL ) { <br> <br>;//                MessagePrint( IDS_LOAD_LIBRARY_FAILURE, GetLastError() ); <br> <br>    } <br> <br>    break; <br> <br>case WM_TIMER: <br> <br>if ( fTimer == FIRST_TIME ) { <br> <br>uTimer = SetTimer( hWnd, 1, REFRESH_RATE, NULL ); <br> <br>fTimer = !FIRST_TIME; <br> <br>} <br> <br>    if ( Refresh( REFRESH_QUERY ) == TRUE ) { <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_NOCHANGE ); <br> <br>    } <br> <br>    break; <br> <br>case WM_COMMAND:    // message: command from application menu <br> <br>    // Message packing of uParam and lParam have changed for Win32, let us <br>    // handle the differences in a conditional compilation: <br> <br>wmId    = LOWORD(uParam); <br>wmEvent = HIWORD(uParam); <br> <br>switch (wmId) { <br> <br>case IDC_ATCOMMANDS: <br> <br>    if ( LBN_DBLCLK == wmEvent ) { <br> <br>if ( IsWindowEnabled( GetDlgItem( hWnd, IDC_CHANGE ) ) ) { <br> <br>PostMessage( hWnd, WM_COMMAND, IDC_CHANGE, 0 ); <br> <br>} <br> <br>    } <br> <br>break; <br> <br>case IDC_REFRESH: <br> <br>    if ( Refresh( REFRESH_QUERY ) == TRUE ) { <br> <br>    Refresh( REFRESH_FALSE ); <br> <br>    hCursorOld = SetCursor( hCursorWait ); <br> <br>    status = JobEnum( lParam ); <br> <br>    SetCursor( hCursorOld ); <br> <br>    if ( status == NERR_Success || status == ERROR_SUCCESS ) { <br> <br>Refresh( REFRESH_TRUE ); <br> <br>    } <br> <br>} <br> <br>    break; <br> <br>case IDC_ADD: <br> <br>    Refresh( REFRESH_FALSE ); <br> <br>    lpAddChangeDlgProc = MakeProcInstance((FARPROC)AddChangeDlgProc, hInstance); <br> <br>    iDlgRetCode = DialogBoxParam( <br>hInst, <br>"ADDCHANGEDLG", <br>hWnd, <br>(DLGPROC)lpAddChangeDlgProc, <br>IDC_ADD); <br> <br>    hGlobalAddChg = NULL; <br> <br>    FreeProcInstance(lpAddChangeDlgProc); <br>    FreeProcInstance(lpAmPmProc); <br>    FreeProcInstance(lpAmPmDefProc); <br>    FreeProcInstance(lpHourProc); <br>    FreeProcInstance(lpHourDefProc); <br>    FreeProcInstance(lpMinProc); <br>    FreeProcInstance(lpMinDefProc); <br>    FreeProcInstance(lpDownButtonProc); <br>    FreeProcInstance(lpDownButtonDefProc); <br>    FreeProcInstance(lpUpButtonProc); <br>    FreeProcInstance(lpUpButtonDefProc); <br> <br>    Refresh( REFRESH_TRUE ); <br> <br>    if ( iDlgRetCode == IDOK ) { <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_BOTTOM ); <br> <br>    } <br> <br>    break; <br> <br>case IDC_CHANGE: <br> <br>Refresh( REFRESH_FALSE ); <br> <br>    lpAddChangeDlgProc = MakeProcInstance((FARPROC)AddChangeDlgProc, hInstance); <br> <br>    iDlgRetCode = DialogBoxParam( <br>hInst, <br>"ADDCHANGEDLG", <br>hWnd, <br>(DLGPROC)lpAddChangeDlgProc, <br>IDC_CHANGE); <br> <br>    hGlobalAddChg = NULL; <br> <br>    FreeProcInstance(lpAddChangeDlgProc); <br>    FreeProcInstance(lpAmPmProc); <br>    FreeProcInstance(lpAmPmDefProc); <br>    FreeProcInstance(lpHourProc); <br>    FreeProcInstance(lpHourDefProc); <br>    FreeProcInstance(lpMinProc); <br>    FreeProcInstance(lpMinDefProc); <br>    FreeProcInstance(lpDownButtonProc); <br>    FreeProcInstance(lpDownButtonDefProc); <br>    FreeProcInstance(lpUpButtonProc); <br>    FreeProcInstance(lpUpButtonDefProc); <br> <br>Refresh( REFRESH_TRUE ); <br> <br>    if ( iDlgRetCode == IDOK ) { <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_BOTTOM ); <br> <br>    } <br> <br>    break; <br> <br>case IDC_REMOVE: <br> <br>    status = JobDel( DEL_ID, hWnd ); <br> <br>break; <br> <br>case IDM_GET_FROM_REGISTRY: <br> <br>    RegCreateKeyEx(REG_HKEY, <br>   szRegistryPath, <br>   0, <br>   "", <br>   REG_OPTION_NON_VOLATILE, <br>   KEY_ALL_ACCESS, <br>   NULL, <br>   &amp;hkHandle, <br>   &amp;dwDisposition); <br> <br>    if ( dwDisposition == REG_CREATED_NEW_KEY ) { <br> <br>RegSetValueEx(hkHandle, "dwX", 0, REG_DWORD, (LPBYTE)DWX, sizeof(DWORD)); <br>RegSetValueEx(hkHandle, "dwY", 0, REG_DWORD, (LPBYTE)DWY, sizeof(DWORD)); <br> <br>    } <br> <br>    { <br>DWORD dwType = REG_DWORD; <br>DWORD dwSize = sizeof(DWORD); <br> <br>RegQueryValueEx(hkHandle, "dwX", 0, &amp;dwType, (LPBYTE)&amp;dwX, &amp;dwSize); <br>RegQueryValueEx(hkHandle, "dwY", 0, &amp;dwType, (LPBYTE)&amp;dwY, &amp;dwSize); <br> <br>    } <br> <br>    RegCloseKey(hkHandle); <br> <br>    { <br>RECT Rect; <br> <br>if(!GetWindowRect(hWnd, &amp;Rect)) { <br> <br>    MessageBox( <br>hWnd, <br>#ifdef JAPAN <br>                                " E B   h E   u     G   [", <br>#else <br>"Problem getting window coordinates.", <br>#endif <br>SZWINDOWTITLE, <br>MB_OK | MB_ICONEXCLAMATION <br>); <br> <br>} else { <br> <br>    dwW = Rect.right  - Rect.left; <br>    dwH = Rect.bottom - Rect.top; <br> <br>} <br> <br>    } <br> <br>    MoveWindow(hWnd, (INT)dwX, (INT)dwY, (INT)dwW, (INT)dwH, TRUE); <br> <br>    break; <br> <br> case IDM_SAVE_TO_REGISTRY: <br> <br>    RegCreateKeyEx(REG_HKEY, <br>   szRegistryPath, <br>   0, <br>   "", <br>   REG_OPTION_NON_VOLATILE, <br>   KEY_ALL_ACCESS, <br>   NULL, <br>   &amp;hkHandle, <br>   &amp;dwDisposition <br>   ); <br> <br>    { <br>RECT Rect; <br> <br>if(!GetWindowRect(hWnd, &amp;Rect)) { <br> <br>    dwX = DWX; <br>    dwY = DWY; <br> <br>    MessageBox( <br>hWnd, <br>#ifdef JAPAN <br>                                " E B   h E   u     G   [", <br>#else <br>"Problem getting coordinates.", <br>#endif <br>SZWINDOWTITLE, <br>MB_OK | MB_ICONEXCLAMATION <br>); <br> <br>} else { <br> <br>    dwX = Rect.left; <br>    dwY = Rect.top; <br> <br>} <br> <br>    } <br> <br>    RegSetValueEx(hkHandle, "dwX", 0, REG_DWORD, (LPBYTE)&amp;dwX, sizeof(DWORD)); <br>    RegSetValueEx(hkHandle, "dwY", 0, REG_DWORD, (LPBYTE)&amp;dwY, sizeof(DWORD)); <br> <br>    RegCloseKey(hkHandle); <br> <br>    break; <br> <br>case IDM_ABOUT: <br> <br>Refresh( REFRESH_SAVE ); <br>    Refresh( REFRESH_FALSE ); <br> <br>// jean-marc - start <br>    if ( ShellAbout( hGlobalhWnd, SZWINDOWTITLE, NULL, LoadIcon( hInst, (LPSTR)SZAPPTITLE ) ) == -1 ) { <br>//old line    if ( ShellAbout( hGlobalhWnd, SZWINDOWTITLE, SZCREDITS, LoadIcon( hInst, (LPSTR)SZAPPTITLE ) ) == -1 ) { <br>// jean-marc - end <br> <br>#ifdef JAPAN <br>                    MessageBox( hGlobalhWnd, "       s  ", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#else <br>MessageBox( hGlobalhWnd, "Out of memory error.", SZWINDOWTITLE, MB_OK | MB_ICONEXCLAMATION ); <br>#endif <br> <br>    } <br> <br>Refresh( REFRESH_RESTORE ); <br> <br>break; <br> <br>case IDM_SELECTCOMPUTER: <br> <br>    Refresh( REFRESH_SAVE ); <br>    Refresh( REFRESH_FALSE ); <br> <br>    lpProcSelect = MakeProcInstance((FARPROC)SelectComputerProc, hInst); <br> <br>iDlgRetCode = DialogBox(hInst, <br>"SelectComputer", <br>hWnd, <br>(DLGPROC)lpProcSelect); <br> <br>FreeProcInstance(lpProcSelect); <br> <br>    Refresh( REFRESH_TRUE ); <br> <br>if ( iDlgRetCode == IDOK ) { <br> <br>SendMessage( hWnd, WM_COMMAND, IDC_REFRESH, (LPARAM)SCS_TOP ); <br> <br>} <br> <br>break; <br> <br>case IDM_EXIT: <br> <br>    Refresh( REFRESH_FALSE ); <br>    FFreeListboxExtents( GetDlgItem( hWnd, IDC_ATCOMMANDS ) ); <br>    ShowWindow( hWnd, SW_RESTORE ); <br>    SendMessage( hWnd, WM_COMMAND, IDM_SAVE_TO_REGISTRY, 0 ); <br>#ifdef JAPAN <br>#else <br>    DeleteObject( hFont ); <br>// jean-marc - start <br>    if (hFontComputerName) <br>      DeleteObject(hFontComputerName); <br>// jean-marc - end <br>#endif <br>    KillTimer( hWnd, 1 ); <br>    EndDialog( hWnd, 0 ); <br> <br>break; <br> <br>case IDC_HELP: <br> <br>#ifdef KKBUGFIX <br>    if (!WinHelp (hWnd, "WINAT.HLP", HELP_CONTENTS,0L)) { <br>#else <br>    if (!WinHelp (hWnd, "WINAT.HLP", HELP_KEY,(DWORD)(LPSTR)"CONTENTS")) { <br>#endif <br>MessageBox (GetFocus(), <br>#ifdef JAPAN <br>" w   v   N            ", <br>#else <br>"Unable to activate help", <br>#endif <br>SZWINDOWTITLE, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND); <br>    } <br>break; <br> <br>case IDM_HELPCONTENTS: <br> <br>#ifdef KKBUGFIX <br>    if (!WinHelp (hWnd, "WINAT.HLP", HELP_CONTENTS,0L)) { <br>#else <br>    if (!WinHelp (hWnd, "WINAT.HLP", HELP_KEY,(DWORD)(LPSTR)"CONTENTS")) { <br>#endif <br>MessageBox (GetFocus(), <br>#ifdef JAPAN <br>" w   v   N            ", <br>#else <br>"Unable to activate help", <br>#endif <br>SZWINDOWTITLE, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND); <br>    } <br> <br>    break; <br> <br>case IDM_HELPSEARCH: <br> <br>    if (!WinHelp(hWnd, "WINAT.HLP", HELP_PARTIALKEY, (DWORD)(LPSTR)"")) { <br>MessageBox (GetFocus(), <br>#ifdef JAPAN <br>" w   v   N            ", <br>#else <br>"Unable to activate help", <br>#endif <br>SZWINDOWTITLE, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND); <br>    } <br> <br>    break; <br> <br>case IDM_HELPHELP: <br> <br>    if(!WinHelp(hWnd, (LPSTR)NULL, HELP_HELPONHELP, 0)) { <br>MessageBox (GetFocus(), <br>#ifdef JAPAN <br>" w   v   N            ", <br>#else <br>"Unable to activate help", <br>#endif <br>SZWINDOWTITLE, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND); <br>    } <br> <br>    break; <br> <br>    } <br> <br>    break; <br> <br>case WM_CLOSE: <br>case WM_ENDSESSION: <br> <br>    SendMessage(hWnd, WM_COMMAND, IDM_EXIT, 0); <br> <br>    break; <br> <br>    } <br> <br>    return (0); <br> <br>} <br> <br> <br>  <br>//=========================================================================== <br>// FUNCTION: WinMain() <br>//=========================================================================== <br>int APIENTRY WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR lpCmdLine, <br>int nCmdShow) <br>{ <br> <br>    FARPROC   lpWINATDlgProc; <br>    WNDCLASS  wc; <br> <br>    hInst       = hInstance; <br> <br>// Fill in window class structure with parameters that describe the <br>// main window. <br> <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc   = (WNDPROC)DefDlgProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = DLGWINDOWEXTRA; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon         = LoadIcon (hInstance, szAppName); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = szAppName; <br>    wc.lpszClassName = szAppName; <br> <br>    // Register the window class <br> <br>    RegisterClass(&amp;wc); <br> <br>// jean-marc - start <br>    // store the commandline (only copy over MAXCOMPUTERNAMELEN characters) <br>    memset(&amp;gszCommandLine, 0, sizeof(gszCommandLine)); <br>    strncpy(gszCommandLine, lpCmdLine, MAXCOMPUTERNAMELEN); <br>    // the commandline will actually be processed from within the WINATDlgProc <br>// jean-marc - end <br> <br>    // <br>    // this program is only a single dialog box <br>    // <br> <br>    lpWINATDlgProc = MakeProcInstance((FARPROC)WINATDlgProc, hInstance); <br> <br>    DialogBox(hInstance, <br>"WINATDLG", <br>0, <br>(DLGPROC)lpWINATDlgProc <br>); <br> <br>    FreeProcInstance(lpWINATDlgProc); <br> <br>    return 0; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
