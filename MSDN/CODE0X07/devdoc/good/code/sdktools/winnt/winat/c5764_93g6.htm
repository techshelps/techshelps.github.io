<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LISTHSCR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5766"></a>LISTHSCR.C</h2>
<pre><code>/* <br> * LISTHSCR.C <br> * <br> * Added functions to support horizontal listbox scrolling.  This <br> * DLL is generalized to support any listbox.  The FInitListboxExtents <br> * function allocates local memory (from the DLLs DATA segment) for <br> * the list of string extents to go in the listbox.  The local handle <br> * is then assigned as a property of the window, so every other <br> * function first looks at this property. <br> * <br> * This means that any number of horizontal scrolling listboxes can <br> * be used in the system and make use of these functions, as long <br> * as the DLLs memory is not full. <br> * <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include "listhscr.h" <br> <br> <br>/* <br> * This is just the label of the property given to each listbox <br> * that asks for an extent list. <br> */ <br> <br>char szXTList[]="XTList"; <br> <br> <br> <br> <br> <br>/* <br> * FInitListboxExtents <br> * <br> * Purpose: <br> *  Simple helper function to initialize everything for maintaining <br> *  horizontal extents in a listbox.  This function allocates memory <br> *  to hold the list of extents and assigns it to the window as a property. <br> * <br> * Parameters: <br> *  hList       HWND of the listbox concerned. <br> * <br> * Return Value: <br> *  BOOL        TRUE if the function was successful. <br> *              FALSE if memory could not be allocated. <br> */ <br> <br>BOOL FAR PASCAL FInitListboxExtents(HWND hList) <br>    { <br>    HANDLE      hMem; <br>    WORD        *pw; <br> <br>    /* <br>     * Initially allocate 260 bytes, or 130 WORDs since the majority <br>     * of listbox usage will not require a reallocation, and <br>     * allocating 256 bytes is just as efficient as allocating 2 <br>     * bytes, if not more so because of reduces overhead. <br>     * <br>     * The extra two words store the current number of extent entries <br>     * and the maximum number possible in this memory block. <br>     * <br>     */ <br> <br>    hMem=LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, CBALLOCUNIT + sizeof(WORD)&lt;&lt;1); <br> <br>    if (hMem==NULL) <br>        return FALSE; <br> <br>    /* <br>     * Set the first two words in the memory to the appropriate values. <br>     * If we can't lock it we can;'t use it! <br>     */ <br>    pw=(WORD *)LocalLock(hMem); <br> <br>    if (pw==NULL) <br>        { <br>        LocalFree(hMem); <br>        return FALSE; <br>        } <br> <br>    *pw=0;                  //cExtentEntries <br>    *(pw+1)=CALLOCUNITS;    //cExtentEntriesMax <br> <br>    LocalUnlock(hMem); <br> <br>    /* <br>     * Assign the memory handle as a property of the listbox.  This allows <br>     * this code to take any hList and get it's extent entry list, <br>     * therefore having full support for multiple listboxes. <br>     */ <br>    SetProp(hList, (LPSTR)szXTList, hMem); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * FFreeListboxExtents <br> * <br> * Purpose: <br> *  Release any memory used for storing the extents of the <br> *  horizontal listbox.  This MUST be called when the listbox <br> *  is destroyed, like in the WM_DESTROY case of the parent window. <br> * <br> * Parameters: <br> *  hList       HWND of the listbox concerned. <br> * <br> * Return Value: <br> *  BOOL        TRUE if the function was successful. <br> *              FALSE if there is an error. <br> */ <br> <br>BOOL FAR PASCAL FFreeListboxExtents(HWND hList) <br>    { <br>    HANDLE      hMem; <br>    BOOL        fSuccess; <br> <br>    //Load the handle to free. <br>    hMem=GetProp(hList, (LPSTR)szXTList); <br> <br>    /* <br>     * Return a BOOL on the result.  An app could keep calling this <br>     * function until it worked since hMem is still around. <br>     */ <br>    fSuccess=(BOOL)LocalFree(hMem); <br> <br>    if (fSuccess) <br>        RemoveProp(hList, (LPSTR)szXTList); //Only if handle was freed! <br> <br>    return fSuccess; <br>    } <br> <br> <br> <br> <br>/* <br> * ResetListboxExtents <br> * <br> * Purpose: <br> *  Deletes all extents in the extent list to be used AFTER an <br> *  LB_RESETCONTENT is sent to the listbox. <br> * <br> * Parameters: <br> *  hList       HWND of the listbox. <br> * <br> * Return Value: <br> *  none <br> * <br> */ <br> <br>void FAR PASCAL ResetListboxExtents(HWND hList) <br>    { <br>    FFreeListboxExtents(hList); <br>    FInitListboxExtents(hList); <br> <br>    SendMessage(hList, LB_SETHORIZONTALEXTENT, 0, 0L); <br> <br>    //This is required to remove the scrollbar. <br>    SendMessage(hList, LB_DELETESTRING, 0, 0L); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * WAddExtentEntry <br> * <br> * Purpose: <br> *  Facilitates handling of the horizontal listbox by keeping <br> *  track of the pixel width of the longest string in the listbox. <br> *  The number of pixels that the listbox scrolls is the width <br> *  of the longest string. <br> * <br> * Parameters: <br> *  hList       HWND of the listbox. <br> *  psz         Pointer to string that is added.  This must be passed <br> *              instead of an index into the listbox since this must <br> *              be called before the string is added if the scrollbar <br> *              is to be maintained properly. <br> * <br> * Return Value: <br> *  WORD        0 if the string added was not the longest string in <br> *              the listbox and therefore did not change the visibility <br> *              of the horizontal scrollbar. <br> * <br> *              wExtent if the added string was the longest, thus either <br> *              making the scrollbar visible or changing the extent. <br> * <br> *              -1 on an error. <br> * <br> */ <br> <br>WORD FAR PASCAL WAddExtentEntry(HWND hList, LPSTR psz) <br>    { <br>    HANDLE      hMem; <br>    WORD        cExtentEntries; <br>    WORD        cExtentEntriesMax; <br>    WORD        *pw;       //Pointer to extent memory. <br>    WORD        wExtent; <br>    WORD        i=0; <br>    WORD        iRev; <br> <br> <br>    hMem=GetProp(hList, (LPSTR)szXTList); <br> <br>    if (hMem==NULL) <br>return ((WORD)-1); <br> <br> <br>    pw=(WORD *)LocalLock(hMem); <br> <br>    if (pw==NULL) <br>return ((WORD)-1); <br> <br>    //Load the values and set pointer to start of list. <br>    cExtentEntries=*pw++; <br>    cExtentEntriesMax=*pw++; <br> <br>    //Reallocate if necessary. <br>    if (cExtentEntries==cExtentEntriesMax) <br>        { <br>        LocalUnlock(hMem); <br> <br>        //This call takes care of cExtentEntriesMax <br>        if (!FReAllocExtentList(hMem, TRUE)) <br>    return ((WORD)-1); <br> <br>        cExtentEntriesMax += CALLOCUNITS; <br>        pw=(WORD *)LocalLock(hMem); <br> <br>        if (pw==NULL) <br>    return ((WORD)-1); <br> <br>        pw+=2;  //Skip the two counters. <br>        } <br> <br>    wExtent=WGetListboxStringExtent(hList, psz); <br> <br> <br>    /* <br>     * Insert the new extent into the list.  This list is just a sorted <br>     * list (descending) of the largest to smallest extents in the <br>     * listbox.  When deleting a string, we just need to look in this <br>     * list for it's extent and remove that entry. <br>     * <br>     * Yeah, this can be inefficient, but this is not a real case for <br>     * optimization. <br>     * <br>     */ <br> <br>    if (cExtentEntries==0) <br>        pw[0]=wExtent; <br>    else <br>        { <br>        i=IFindExtentInList(pw, wExtent, cExtentEntries); <br> <br>        for (iRev=cExtentEntries+1; iRev &gt; i; iRev--) <br>            pw[iRev]=pw[iRev-1]; <br> <br>        pw[i]=wExtent; <br>        } <br> <br>    cExtentEntries++; <br> <br>    //Save these values back.  pw must be decremented first. <br>    *(--pw)=cExtentEntriesMax; <br>    *(--pw)=cExtentEntries; <br> <br>    LocalUnlock(hMem); <br> <br> <br>    /* <br>     * Check if the one we added is now the first.  If so, then <br>     * we need to reset the horizontal extent. <br>     */ <br> <br>    if (i==0) <br>       { <br>        SendMessage(hList, LB_SETHORIZONTALEXTENT, wExtent, 0L); <br>        return wExtent; <br>       } <br> <br>    return ((WORD)0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * WRemoveExtentEntry <br> * <br> * Purpose: <br> *  Facilitates handling of the horizontal listbox by keeping <br> *  track of the pixel width of the longest string in the listbox. <br> *  The number of pixels that the listbox scrolls is the width <br> *  of the longest string. <br> * <br> * Parameters: <br> *  hList       HWND of the listbox. <br> *  iSel        WORD index of the string to be removed. <br> * <br> * Return Value: <br> *  WORD        0 if the string removed did not affect the visibilty <br> *              of the horizontal scrollbar, i.e. if there still is <br> *              a longer string or there is no scrollbar in the first <br> *              place. <br> * <br> *              wExtent of the new longest string if the one removed <br> *              was the longest. <br> * <br> *              -1 on an error. <br> */ <br> <br>WORD FAR PASCAL WRemoveExtentEntry(HWND hList, WORD iSel) <br>    { <br>    WORD        *pw;       //Pointer to extent memory. <br>    WORD        cExtentEntries; <br>    WORD        cExtentEntriesMax; <br>    WORD        wExtent; <br>    WORD        i; <br>    WORD        iSave; <br>    HANDLE      hMem; <br>    HANDLE      hMemT; <br>    char        *pch; <br>    WORD        cb; <br> <br> <br>    hMem=GetProp(hList, (LPSTR)szXTList); <br> <br>    if (hMem==NULL) <br>return ((WORD)-1); <br> <br> <br>    pw=(WORD *)LocalLock(hMem); <br> <br>    if (pw==NULL) <br>return ((WORD)-1); <br> <br>    //Load the values and set pointer to start of list. <br>    cExtentEntries=*pw++; <br>    cExtentEntriesMax=*pw++; <br> <br>    if (cExtentEntries==0) <br>        { <br>        LocalUnlock(hMem); <br>return ((WORD)-1); <br>        } <br> <br> <br>    //Free up memory if necessary.  No reallocating smaller is not fatal. <br>    if ((cExtentEntriesMax-cExtentEntries)==CALLOCUNITS) <br>        { <br>        LocalUnlock(hMem); <br> <br>        if (!FReAllocExtentList(hMem, FALSE)) <br>    return ((WORD)-1); <br> <br>        cExtentEntriesMax += CALLOCUNITS; <br>        pw=(WORD *)LocalLock(hMem); <br> <br>        if (pw==NULL) <br>    return ((WORD)-1); <br> <br>        pw+=2;  //Skip the two counters. <br>        } <br> <br>    cb=(WORD)SendMessage(hList, LB_GETTEXTLEN, iSel, 0L); <br> <br>    //Temporary memory to copy the listbox string so we can get the extent. <br>    hMemT=LocalAlloc(LMEM_MOVEABLE, cb+2);  //One extra to be safe. <br>    pch=LocalLock(hMemT); <br> <br>    if (pch==NULL) <br>        { <br>        LocalUnlock(hMem); <br>        LocalFree(hMemT); <br>return ((WORD)-1); <br>        } <br> <br>    cb=(WORD)SendMessage(hList, LB_GETTEXT, iSel, (LONG)(LPSTR)pch); <br> <br>    wExtent=WGetListboxStringExtent(hList, (LPSTR)pch); <br> <br>    LocalUnlock(hMemT); <br>    LocalFree(hMemT); <br> <br> <br>    /* <br>     * Find the extent in the list and remove it.  If it's the first, <br>     * then reset the horizontal extent to the second. <br>     */ <br> <br>    i=IFindExtentInList(pw, wExtent, cExtentEntries); <br>    iSave=i; <br> <br>    while (i &lt; cExtentEntries) <br>        pw[i++]=pw[i+1]; <br> <br>    cExtentEntries--; <br> <br>    //Save these values back.  pw must be decremented first. <br>    *(--pw)=cExtentEntriesMax; <br>    *(--pw)=cExtentEntries; <br> <br>    LocalUnlock(hMem); <br> <br>    if (iSave==0) <br>        { <br>        /* <br>         * Before we change the horizontal extent, we must make sure that <br>         * the origin of the listbox is visible through forcing a scroll. <br>         * If this is not done, and the listbox is scrolled one or <br>         * more pixels to the right, the scrollbar WILL NOT disappear <br>         * even if all remaining strings fit inside the client area <br>         * of the listbox. <br>         * <br>         * This is only done here since this the only case where this <br>         * might happen is when we change the extent. <br>         */ <br>        SendMessage(hList, WM_HSCROLL, SB_TOP, MAKELONG(0, hList)); <br>        SendMessage(hList, LB_SETHORIZONTALEXTENT, pw[2], 0L); <br> <br>        return pw[2]; <br>        } <br> <br> <br>    return ((WORD)0); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FReAllocExtentList <br> * <br> * Purpose: <br> *  Handles reallocation of the list in blocks of +/- CBALLOCUNIT <br> * <br> * Parameters: <br> *  fGrow       BOOL if TRUE, instructs this function to allocate <br> *              an additional ALLOCUNIT. <br> *              If FALSE, shrinks the memory block by an ALLOCUNIT. <br> * <br> * Return Value: <br> *  BOOL        TRUE if successfully reallocated.  FALSE otherwise. <br> * <br> */ <br> <br>BOOL FReAllocExtentList(HANDLE hMem, BOOL fGrow) <br>    { <br>    WORDwSize; <br> <br>    /* <br>     * Allocate an additional 128 entries.  A 256 byte block is a <br>     * decent reallocation size. <br>     */ <br>    wSize=LocalSize((HLOCAL)hMem); <br>    wSize+=(fGrow) ?  ((int)CBALLOCUNIT) : (-(int)CBALLOCUNIT); <br> <br>    /* <br>     * This returns FALSE if the realloc was unsuccessful.  TRUE <br>     * otherwise because the return handle is  !=0 <br>     * <br>     */ <br>    return (BOOL)LocalReAlloc(hMem, wSize, LMEM_MOVEABLE | LMEM_ZEROINIT); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * WGetListboxStringExtent <br> * <br> * Purpose: <br> *  Returns the extent, in pixels, of a string that will be or is <br> *  in a listbox.  The hDC of the listbox is used and an extra <br> *  average character width is added to the extent to insure that <br> *  a horizontal scrolling listbox that is based on this extent <br> *  will scroll such that the end of the string is visible. <br> * <br> * Parameters: <br> *  hList       HWND handle to the listbox. <br> *  psz         LPSTR pointer to string in question. <br> * <br> * Return Value: <br> *  WORD        Extent of the string relative to listbox. <br> * <br> */ <br> <br>WORD WGetListboxStringExtent(HWND hList, LPSTR psz) <br>    { <br>    TEXTMETRIC  tm; <br>    HDC         hDC; <br>    HFONT       hFont; <br>    WORD        wExtent; <br> <br> <br>    /* <br>     * Make sure we are using the correct font. <br>     */ <br>    hDC=GetDC(hList); <br>    hFont=(HFONT)SendMessage(hList, WM_GETFONT, 0, 0L); <br> <br>    if (hFont!=NULL) <br>        SelectObject(hDC, hFont); <br> <br>    GetTextMetrics(hDC, &amp;tm); <br> <br>    /* <br>     * Add one average text width to insure that we see the end of the <br>     * string when scrolled horizontally. <br>     */ <br> <br>    // <br>    // changed to GetTextExtentPoint - KoryG - 3/24/92 <br>    // <br>    { <br>        SIZE Size; <br> <br>        GetTextExtentPoint(hDC, psz, lstrlen(psz), &amp;Size); <br>        // fudge for tabs! <br>        wExtent=(WORD)Size.cx + (WORD)tm.tmAveCharWidth + 180; <br>    } <br> <br>    ReleaseDC(hList, hDC); <br> <br>    return wExtent; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * IFindExtentInList <br> * <br> * Purpose: <br> *  Does an binary search on the sorted extent list and returns <br> *  an index to the one that matches.  If there is no match, <br> *  the index gives the point where the extent entry should go. <br> * <br> *  Note that an altered search algorithm is used since the list <br> *  is descending instead of ascending. <br> * <br> * Parameters: <br> *  pw             WORD * pointer to extent list. <br> *  wExtent        WORD extent to find or find an index for. <br> *  cExtentEntries WORD count of entries in list. <br> * <br> * Return Value: <br> *  iExtent    WORD index into lpw where wExtent exists or where <br> *             it should be inserted. <br> * <br> */ <br> <br>WORD IFindExtentInList(WORD *pw, WORD wExtent, WORD cExtentEntries) <br>    { <br>    int     i = 0;      //These MUST be signed! <br>    int     iPrev; <br>    int     iMin; <br>    int     iMax; <br> <br>    //Set upper limits on search. <br>    iMin=0; <br>    iMax=cExtentEntries+1; <br> <br> <br>    do <br>        { <br>        iPrev=i; <br>        i=(iMin + iMax) &gt;&gt; 1; <br> <br>        if (i==iPrev) <br>            { <br>            i++; <br>            break; <br>            } <br> <br>        //Change the min and max depending on which way we need to look. <br>        if (wExtent &lt; pw[i])   // &lt; since list is descending. &gt; otherwise <br>            iMin=i; <br>        else <br>            iMax=i; <br> <br>        if (iMax==iMin) <br>            break; <br>        } <br>    while (wExtent != pw[i]); <br> <br> <br>    /* <br>     * When we get here, i is either where wExtent is or where it should <br>     * go--so return it. <br>     */ <br>    return i; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
