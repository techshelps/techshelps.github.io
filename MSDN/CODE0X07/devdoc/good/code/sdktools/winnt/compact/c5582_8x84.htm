<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SUPPORT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5584"></a>SUPPORT.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1994-1995  Microsoft Corporation <br> <br>Module Name: <br> <br>    Support.c <br> <br>Abstract: <br> <br>    Support routines for compact utility <br> <br>Author: <br> <br>    Matthew Bradburn    [mattbr]        05-Oct-1994 <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>#define UNICODE <br>#define _UNICODE <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;windows.h&gt; <br>#include "support.h" <br>#include "msg.h" <br> <br> <br>  <br>// <br>//  Declare routines to put out internationalized messages <br>// <br> <br>typedef enum { <br>    READ_ACCESS, <br>    WRITE_ACCESS <br>} STREAMACCESS; <br> <br>HANDLE <br>GetStandardStream( <br>    IN HANDLE   Handle, <br>    IN STREAMACCESS Access <br>    ); <br> <br>HANDLE hInput; <br>HANDLE hOutput; <br>HANDLE hError; <br> <br>#define STDIN   0 <br>#define STDOUT  1 <br>#define STDERR  2 <br> <br>BOOL ConsoleInput; <br>BOOL ConsoleOutput; <br>BOOL ConsoleError; <br> <br>int <br>FileIsConsole(int fh) <br>{ <br>    unsigned htype; <br>    DWORD dwMode; <br>    HANDLE hFile; <br> <br>    hFile = (HANDLE)_get_osfhandle(fh); <br>    htype = GetFileType(hFile); <br>    htype &amp;= ~FILE_TYPE_REMOTE; <br> <br>    if (FILE_TYPE_CHAR == htype) { <br> <br>        switch (fh) { <br>        case STDIN: <br>            hFile = GetStdHandle(STD_INPUT_HANDLE); <br>            break; <br>        case STDOUT: <br>            hFile = GetStdHandle(STD_OUTPUT_HANDLE); <br>            break; <br>        case STDERR: <br>            hFile = GetStdHandle(STD_ERROR_HANDLE); <br>            break; <br>        } <br> <br>        if (GetConsoleMode(hFile, &amp;dwMode)) { <br>            return TRUE; <br>        } <br>    } <br> <br>    return FALSE; <br> <br>} <br> <br> <br>VOID <br>InitializeIoStreams() <br>{ <br>#ifdef FE_SB <br>    LANGID LangId; <br> <br>    switch (GetConsoleOutputCP()) { <br>        case 932: <br>            LangId = MAKELANGID( LANG_JAPANESE, SUBLANG_DEFAULT ); <br>            break; <br>        case 949: <br>            LangId = MAKELANGID( LANG_KOREAN, SUBLANG_KOREAN ); <br>            break; <br>        case 936: <br>            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED ); <br>            break; <br>        case 950: <br>            LangId = MAKELANGID( LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL ); <br>            break; <br>        default: <br>            LangId = MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ); <br>            break; <br>    } <br> <br>    SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) ); <br>#endif <br> <br>    hInput = GetStdHandle(STD_INPUT_HANDLE); <br>    ConsoleInput = FileIsConsole(STDIN); <br> <br>    hOutput = GetStdHandle(STD_OUTPUT_HANDLE); <br>    ConsoleOutput = FileIsConsole(STDOUT); <br> <br>    hError = GetStdHandle(STD_ERROR_HANDLE); <br>    ConsoleError = FileIsConsole(STDERR); <br>} <br> <br>TCHAR DisplayBuffer[4096]; <br>CHAR DisplayBuffer2[4096]; <br> <br>VOID <br>DisplayMsg(DWORD MsgNum, ... ) <br>{ <br>    DWORD len, bytes_written; <br>    BOOL success; <br>    DWORD status; <br>    va_list ap; <br> <br>    va_start(ap, MsgNum); <br> <br>    len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, MsgNum, 0, <br>        DisplayBuffer, 4096, &amp;ap); <br>        <br>    if (ConsoleOutput) { <br>        success = WriteConsole(hOutput, (LPVOID)DisplayBuffer, len, <br>                 &amp;bytes_written, NULL); <br> <br>    } else { <br>        CharToOem(DisplayBuffer, DisplayBuffer2); <br>        success = WriteFile(hOutput, (LPVOID)DisplayBuffer2, len, <br>                 &amp;bytes_written, NULL); <br>    } <br> <br>    if (!success || bytes_written != len) { <br>        status = GetLastError(); <br>    } <br> <br>    va_end(ap); <br>} <br> <br>VOID <br>DisplayErr( <br>    PTCHAR Prefix, <br>    DWORD MsgNum, <br>    ... <br>    ) <br>{ <br>    DWORD len, bytes_written; <br>    BOOL success; <br>    DWORD status; <br>    va_list ap; <br>    ULONG i; <br> <br>    va_start(ap, MsgNum); <br> <br>    if (NULL != Prefix) { <br>        lstrcpy(DisplayBuffer, Prefix); <br>        lstrcat(DisplayBuffer, TEXT(": ")); <br>    } else { <br>        DisplayBuffer[0] = UNICODE_NULL; <br>    } <br> <br>    i = lstrlen(DisplayBuffer); <br> <br>    len = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, MsgNum, 0, <br>        DisplayBuffer + i, 4096 - i, &amp;ap); <br> <br>    if (ConsoleError) { <br>        success = WriteConsole(hError, (LPVOID)DisplayBuffer, len + i, <br>                 &amp;bytes_written, NULL); <br> <br>    } else { <br>        CharToOem(DisplayBuffer, DisplayBuffer2); <br>        success = WriteFile(hError, (LPVOID)DisplayBuffer2, len + i, <br>                 &amp;bytes_written, NULL); <br>    } <br> <br>    if (!success) { <br>        status = GetLastError(); <br>    }     <br>    va_end(ap); <br>} <br> <br>BOOLEAN <br>IsNtldr( <br>    PTCHAR Path <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Used to keep the user from compressing \NTLDR (which would prevent <br>    the machine from booting). <br>     <br>Arguments: <br> <br>    Path - the path to examine. <br> <br>Return Value: <br> <br>    TRUE - the path looks like \ntldr. <br>    FALSE - the path does not look like \ntldr. <br>     <br>--*/ <br>{ <br>    PTCHAR pch; <br> <br>    // try "X:\ntldr" <br> <br>    if (0 == lstricmp(Path + 2, TEXT("\\ntldr"))) { <br>        return TRUE; <br>    } <br> <br>    // try "\\machine\share\ntldr" <br> <br>    if ('\\' == Path[0] &amp;&amp; '\\' != Path[1]) { <br>        pch = lstrchr(Path + 2, '\\'); <br>        if (NULL == pch) { <br>            return FALSE; <br>        } <br>        pch = lstrchr(pch + 1, '\\'); <br>        if (NULL == pch) { <br>            return FALSE; <br>        } <br>        if (0 == lstricmp(pch, TEXT("\\ntldr"))) { <br>            return TRUE; <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br>BOOLEAN <br>IsUncRoot( <br>    PTCHAR Path <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Determine whether the given path is of the form \\server\share. <br>     <br>Arguments: <br> <br>    Path - the path to examine. <br> <br>Return Value: <br> <br>    TRUE - the path looks like a unc share name. <br>    FALSE - the path does not look like that. <br>     <br>--*/ <br>{ <br>    PTCHAR pch; <br> <br>    if ('\\' != *Path || '\\' != *(Path + 1)) { <br>        return FALSE; <br>    } <br> <br>    pch = lstrchr(Path + 2, '\\'); <br>    if (NULL == pch) { <br>        // <br>        // There is no slash to seperate server and share. <br>        // <br> <br>        return FALSE; <br>    } <br> <br>    pch = lstrchr(pch + 1, '\\'); <br>    if (NULL != pch) { <br>        // <br>        // There are additional component -- no match. <br>        // <br> <br>        return FALSE; <br>    } <br> <br>    if ('\\' == *(Path + lstrlen(Path))) { <br>     <br>        // <br>        // The string ends in slash -- it doesn't match. <br>        // <br> <br>        return FALSE; <br>    } <br>     <br>    return TRUE; <br>} <br> <br>ULONG <br>FormatFileSize( <br>    IN PLARGE_INTEGER FileSize, <br>    IN DWORD Width, <br>    OUT PTCHAR FormattedSize, <br>    IN BOOLEAN Commas <br>    ) <br>{ <br>    TCHAR Buffer[100]; <br>    PTCHAR s, s1; <br>    ULONG DigitIndex, Digit; <br>    ULONG Size; <br>    LARGE_INTEGER TempSize; <br> <br>    s = &amp;Buffer[ 99 ]; <br>    *s = TEXT('\0'); <br>    DigitIndex = 0; <br>    TempSize = *FileSize; <br>    while (TempSize.HighPart != 0) { <br>        if (TempSize.HighPart != 0) { <br>            Digit = (ULONG)(TempSize.QuadPart % 10); <br>            TempSize.QuadPart = TempSize.QuadPart / 10; <br>        } else { <br>            Digit = TempSize.LowPart % 10; <br>            TempSize.LowPart = TempSize.LowPart / 10; <br>        } <br>        *--s = (TCHAR)(TEXT('0') + Digit); <br> <br>        if ((++DigitIndex % 3) == 0 &amp;&amp; Commas) { <br>            *--s = TEXT(','); <br>        } <br>    } <br>    Size = TempSize.LowPart; <br>    while (Size != 0) { <br>        *--s = (TCHAR)(TEXT('0') + (Size % 10)); <br>        Size = Size / 10; <br> <br>        if ((++DigitIndex % 3) == 0 &amp;&amp; Commas) { <br>            *--s = TEXT(','); <br>        } <br>    } <br> <br>    if (DigitIndex == 0) { <br>        *--s = TEXT('0'); <br>    } else if (Commas &amp;&amp; *s == TEXT(',')) { <br>        s += 1; <br>    } <br> <br>    Size = lstrlen( s ); <br>    if (Width != 0 &amp;&amp; Size &lt; Width) { <br>        s1 = FormattedSize; <br>        while (Width &gt; Size) { <br>            Width -= 1; <br>            *s1++ = TEXT(' '); <br>        } <br>        lstrcpy( s1, s ); <br>    } else { <br>        lstrcpy( FormattedSize, s ); <br>    } <br> <br>    return lstrlen( FormattedSize ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
