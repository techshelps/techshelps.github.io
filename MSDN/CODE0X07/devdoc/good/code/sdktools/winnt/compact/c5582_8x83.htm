<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPACT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5583"></a>COMPACT.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1994-1995  Microsoft Corporation <br> <br>Module Name: <br> <br>    Compact.c <br> <br>Abstract: <br> <br>    This module implements the double stuff utility for compressed NTFS <br>    volumes. <br> <br>Author: <br> <br>    Gary Kimura     [garyki]        10-Jan-1994 <br> <br>Revision History: <br> <br> <br>--*/ <br> <br>// <br>// Include the standard header files. <br>// <br> <br>#define UNICODE <br>#define _UNICODE <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;winioctl.h&gt; <br>#include &lt;shellapi.h&gt; <br> <br>#include "support.h" <br>#include "msg.h" <br> <br>#define lstrchr wcschr <br>#define lstricmp _wcsicmp <br>#define lstrnicmp _wcsnicmp <br> <br>// <br>//  FIRST_COLUMN_WIDTH - When compressing files, the width of the output <br>//  column which displays the file name <br>// <br> <br>#define FIRST_COLUMN_WIDTH  (20) <br> <br>// <br>//  Local procedure types <br>// <br> <br>typedef BOOLEAN (*PACTION_ROUTINE) ( <br>    IN PTCHAR DirectorySpec, <br>    IN PTCHAR FileSpec <br>    ); <br> <br>typedef VOID (*PFINAL_ACTION_ROUTINE) ( <br>    ); <br> <br>// <br>//  Declare global variables to hold the command line information <br>// <br> <br>BOOLEAN DoSubdirectories      = FALSE;      // recurse <br>BOOLEAN IgnoreErrors          = FALSE;      // keep going despite errs <br>BOOLEAN UserSpecifiedFileSpec = FALSE; <br>BOOLEAN ForceOperation        = FALSE;      // compress even if already so <br>BOOLEAN Quiet                 = FALSE;      // be less verbose <br>BOOLEAN DisplayAllFiles       = FALSE;      // dsply hidden, system? <br>TCHAR   StartingDirectory[MAX_PATH];        // parameter to "/s" <br>ULONG   AttributesNoDisplay = FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN; <br> <br>// <br>//  Declere global variables to hold compression statistics <br>// <br> <br>LARGE_INTEGER TotalDirectoryCount; <br>LARGE_INTEGER TotalFileCount; <br>LARGE_INTEGER TotalCompressedFileCount; <br>LARGE_INTEGER TotalUncompressedFileCount; <br> <br>LARGE_INTEGER TotalFileSize; <br>LARGE_INTEGER TotalCompressedSize; <br> <br>TCHAR Buf[1024];                            // for displaying stuff <br> <br>  <br>HANDLE <br>OpenFileForCompress( <br>    IN      PTCHAR      ptcFile <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This routine jumps through the hoops necessary to open the file <br>    for READ_DATA|WRITE_DATA even if the file has the READONLY <br>    attribute set. <br> <br>Arguments: <br> <br>    ptcFile     - Specifies the file that should be opened. <br> <br>Return Value: <br> <br>    A handle open on the file if successfull, INVALID_HANDLE_VALUE <br>    otherwise, in which case the caller may use GetLastError() for more <br>    info. <br> <br>--*/ <br>{ <br>    BY_HANDLE_FILE_INFORMATION fi; <br>    HANDLE hRet; <br>    HANDLE h; <br>    INT err; <br> <br>    hRet = CreateFile( <br>                ptcFile, <br>                FILE_READ_DATA | FILE_WRITE_DATA, <br>                FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                NULL, <br>                OPEN_EXISTING, <br>                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN, <br>                NULL <br>                ); <br> <br>    if (INVALID_HANDLE_VALUE != hRet) { <br>        return hRet; <br>    } <br> <br>    if (ERROR_ACCESS_DENIED != GetLastError()) { <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    err = GetLastError(); <br> <br>    h = CreateFile( <br>            ptcFile, <br>            FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, <br>            FILE_SHARE_READ | FILE_SHARE_WRITE, <br>            NULL, <br>            OPEN_EXISTING, <br>            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN, <br>            NULL <br>            ); <br> <br>    if (INVALID_HANDLE_VALUE == h) { <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    if (!GetFileInformationByHandle(h, &amp;fi)) { <br>        CloseHandle(h); <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    if ((fi.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) == 0) { <br> <br>        // If we couldn't open the file for some reason other than that <br>        // the readonly attribute was set, fail. <br> <br>        SetLastError(err); <br>        CloseHandle(h); <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    fi.dwFileAttributes &amp;= ~FILE_ATTRIBUTE_READONLY; <br> <br>    if (!SetFileAttributes(ptcFile, fi.dwFileAttributes)) { <br>        CloseHandle(h); <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    hRet = CreateFile( <br>            ptcFile, <br>            FILE_READ_DATA | FILE_WRITE_DATA, <br>            FILE_SHARE_READ | FILE_SHARE_WRITE, <br>            NULL, <br>            OPEN_EXISTING, <br>            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN, <br>            NULL <br>            ); <br> <br>    CloseHandle(h); <br> <br>    if (INVALID_HANDLE_VALUE == hRet) { <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    fi.dwFileAttributes |= FILE_ATTRIBUTE_READONLY; <br> <br>    if (!SetFileAttributes(ptcFile, fi.dwFileAttributes)) { <br>        CloseHandle(hRet); <br>        return INVALID_HANDLE_VALUE; <br>    } <br> <br>    return hRet; <br>} <br>  <br>// <br>//  Now do the routines to list the compression state and size of <br>//  a file and/or directory <br>// <br> <br>BOOLEAN <br>DisplayFile ( <br>    IN PTCHAR FileSpec, <br>    IN PWIN32_FIND_DATA FindData <br>    ) <br>{ <br>    LARGE_INTEGER FileSize; <br>    LARGE_INTEGER CompressedSize; <br>    TCHAR PrintState; <br> <br>    ULONG Percentage = 100; <br>    double Ratio = 1.0; <br> <br>    FileSize.LowPart = FindData-&gt;nFileSizeLow; <br>    FileSize.HighPart = FindData-&gt;nFileSizeHigh; <br>    PrintState = ' '; <br> <br>    // <br>    //  Decide if the file is compressed and if so then <br>    //  get the compressed file size. <br>    // <br> <br>    if (FindData-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_COMPRESSED) { <br> <br>        CompressedSize.LowPart = GetCompressedFileSize( FileSpec, <br>            &amp;CompressedSize.HighPart ); <br>        PrintState = 'C'; <br>        TotalCompressedFileCount.QuadPart += 1; <br> <br>    } else { <br> <br>        CompressedSize.LowPart = GetCompressedFileSize( FileSpec, <br>            &amp;CompressedSize.HighPart ); <br> <br>        if (GetLastError() == 0 &amp;&amp; <br>            CompressedSize.QuadPart != 0 &amp;&amp; <br>            CompressedSize.QuadPart &lt; FileSize.QuadPart) { <br> <br>            // File on DblSpace partition. <br> <br>            PrintState = 'd'; <br>            TotalCompressedFileCount.QuadPart += 1; <br> <br>        } else { <br> <br>            CompressedSize = FileSize; <br>            TotalUncompressedFileCount.QuadPart += 1; <br>        } <br>    } <br> <br> <br>    // <br>    //  Calculate the compression ratio for this file <br>    // <br> <br>    if (CompressedSize.QuadPart != 0) { <br> <br>        if (CompressedSize.QuadPart &gt; FileSize.QuadPart) { <br> <br>            // <br>            // The file probably grew between the time we got its size <br>            // and the time we got its compressed size.  Kludge. <br>            // <br> <br>            FileSize.QuadPart = CompressedSize.QuadPart; <br>        } <br> <br>        Ratio = (double)FileSize.QuadPart / (double)CompressedSize.QuadPart; <br>    } <br> <br>    // <br>    //  Print out the sizes compression state and file name <br>    // <br> <br>    if (!Quiet &amp;&amp; <br>        (DisplayAllFiles || <br>            (0 == (FindData-&gt;dwFileAttributes &amp; AttributesNoDisplay)))) { <br> <br>        FormatFileSize(&amp;FileSize, 9, Buf, FALSE); <br>        lstrcat(Buf, TEXT(" : ")); <br>        FormatFileSize(&amp;CompressedSize, 9, &amp;Buf[lstrlen(Buf)], FALSE); <br> <br>        swprintf(&amp;Buf[lstrlen(Buf)], TEXT(" = %2.1lf "), Ratio); <br>        DisplayMsg(COMPACT_THROW, Buf); <br> <br>        DisplayMsg(COMPACT_TO_ONE); <br> <br>        swprintf(Buf, TEXT("%c %s",), PrintState, FindData-&gt;cFileName); <br>        DisplayMsg(COMPACT_THROW_NL, Buf); <br>    } <br> <br>    // <br>    //  Increment our running total <br>    // <br> <br>    TotalFileSize.QuadPart += FileSize.QuadPart; <br>    TotalCompressedSize.QuadPart += CompressedSize.QuadPart; <br>    TotalFileCount.QuadPart += 1; <br> <br>    return TRUE; <br>} <br> <br>  <br>BOOLEAN <br>DoListAction ( <br>    IN PTCHAR DirectorySpec, <br>    IN PTCHAR FileSpec <br>    ) <br> <br>{ <br>    PTCHAR DirectorySpecEnd; <br> <br>    // <br>    //  So that we can keep on appending names to the directory spec <br>    //  get a pointer to the end of its string <br>    // <br> <br>    DirectorySpecEnd = DirectorySpec + lstrlen(DirectorySpec); <br> <br>    // <br>    //  List the compression attribute for the directory <br>    // <br> <br>    { <br>        ULONG Attributes; <br> <br>        if (!Quiet || Quiet) { <br> <br>            Attributes = GetFileAttributes( DirectorySpec ); <br> <br>            if (0xFFFFFFFF == Attributes) { <br> <br>                if (!Quiet || !IgnoreErrors) { <br> <br>                    // <br>                    // Refrain from displaying error only when in quiet <br>                    // mode *and* we're ignoring errors. <br>                    // <br> <br>                    DisplayErr(DirectorySpec, GetLastError()); <br>                } <br> <br>                if (!IgnoreErrors) { <br>                    return FALSE; <br>                } <br>            } else { <br> <br>                if (Attributes &amp; FILE_ATTRIBUTE_COMPRESSED) { <br>                    DisplayMsg(COMPACT_LIST_CDIR, DirectorySpec); <br>                } else { <br>                    DisplayMsg(COMPACT_LIST_UDIR, DirectorySpec); <br>                } <br>            } <br>        } <br> <br>        TotalDirectoryCount.QuadPart += 1; <br>    } <br> <br>    // <br>    //  Now for every file in the directory that matches the file spec we will <br>    //  will open the file and list its compression state <br>    // <br> <br>    { <br>        HANDLE FindHandle; <br>        WIN32_FIND_DATA FindData; <br> <br>        // <br>        //  setup the template for findfirst/findnext <br>        // <br> <br>        // <br>        //  Make sure we don't try any paths that are too long for us <br>        //  to deal with. <br>        // <br> <br>        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) &lt; <br>            MAX_PATH) { <br> <br>            lstrcpy( DirectorySpecEnd, FileSpec ); <br> <br>            FindHandle = FindFirstFile( DirectorySpec, &amp;FindData ); <br> <br>            if (INVALID_HANDLE_VALUE != FindHandle) { <br> <br>               do { <br> <br>                   // <br>                   //  append the found file to the directory spec and open the <br>                   //  file <br>                   // <br> <br>                   if (0 == lstrcmp(FindData.cFileName, TEXT("..")) || <br>                       0 == lstrcmp(FindData.cFileName, TEXT("."))) { <br>                       continue; <br>                   } <br> <br>                   // <br>                   //  Make sure we don't try any paths that are too long for us <br>                   //  to deal with. <br>                   // <br> <br>                   if ((DirectorySpecEnd - DirectorySpec) + <br>                       lstrlen( FindData.cFileName ) &gt;= MAX_PATH ) { <br> <br>                       continue; <br>                   } <br> <br>                   lstrcpy( DirectorySpecEnd, FindData.cFileName ); <br> <br>                   // <br>                   //  Now print out the state of the file <br>                   // <br> <br>                   DisplayFile( DirectorySpec, &amp;FindData ); <br> <br>               } while ( FindNextFile( FindHandle, &amp;FindData )); <br> <br>               FindClose( FindHandle ); <br>           } <br>        } <br>    } <br> <br>    // <br>    //  For if we are to do subdirectores then we will look for every <br>    //  subdirectory and recursively call ourselves to list the subdirectory <br>    // <br> <br>    if (DoSubdirectories) { <br> <br>        HANDLE FindHandle; <br> <br>        WIN32_FIND_DATA FindData; <br> <br>        // <br>        //  Setup findfirst/findnext to search the entire directory <br>        // <br> <br>        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) &lt; <br>            MAX_PATH) { <br> <br>           lstrcpy( DirectorySpecEnd, TEXT("*") ); <br> <br>           FindHandle = FindFirstFile( DirectorySpec, &amp;FindData ); <br> <br>           if (INVALID_HANDLE_VALUE != FindHandle) { <br> <br>               do { <br> <br>                   // <br>                   //  Now skip over the . and .. entries otherwise we'll recurse <br>                   //  like mad <br>                   // <br> <br>                   if (0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".")) || <br>                       0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".."))) { <br> <br>                       continue; <br> <br>                   } else { <br> <br>                       // <br>                       //  If the entry is for a directory then we'll tack on the <br>                       //  subdirectory name to the directory spec and recursively <br>                       //  call otherselves <br>                       // <br> <br>                       if (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br> <br>                           // <br>                           //  Make sure we don't try any paths that are too long for us <br>                           //  to deal with. <br>                           // <br> <br>                           if ((DirectorySpecEnd - DirectorySpec) + <br>                               lstrlen( TEXT("\\") ) + <br>                               lstrlen( FindData.cFileName ) &gt;= MAX_PATH ) { <br> <br>                               continue; <br>                           } <br> <br>                           lstrcpy( DirectorySpecEnd, FindData.cFileName ); <br>                           lstrcat( DirectorySpecEnd, TEXT("\\") ); <br> <br>                           if (!DoListAction( DirectorySpec, FileSpec )) { <br> <br>                               FindClose( FindHandle ); <br>                               return FALSE || IgnoreErrors; <br>                           } <br>                       } <br>                   } <br> <br>               } while ( FindNextFile( FindHandle, &amp;FindData )); <br> <br>               FindClose( FindHandle ); <br>           } <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br>VOID <br>DoFinalListAction ( <br>    ) <br>{ <br>    ULONG TotalPercentage = 100; <br>    double f = 1.0; <br> <br>    TCHAR FileCount[32]; <br>    TCHAR DirectoryCount[32]; <br>    TCHAR CompressedFileCount[32]; <br>    TCHAR UncompressedFileCount[32]; <br>    TCHAR CompressedSize[32]; <br>    TCHAR FileSize[32]; <br>    TCHAR Percentage[10]; <br>    TCHAR Ratio[8]; <br> <br>    if (TotalCompressedSize.QuadPart != 0) { <br>        f = (double)TotalFileSize.QuadPart / <br>            (double)TotalCompressedSize.QuadPart; <br>    } <br> <br>    FormatFileSize(&amp;TotalFileCount, 0, FileCount, FALSE); <br>    FormatFileSize(&amp;TotalDirectoryCount, 0, DirectoryCount, FALSE); <br>    FormatFileSize(&amp;TotalCompressedFileCount, 0, CompressedFileCount, FALSE); <br>    FormatFileSize(&amp;TotalUncompressedFileCount, 0, UncompressedFileCount, FALSE); <br>    FormatFileSize(&amp;TotalCompressedSize, 0, CompressedSize, TRUE); <br>    FormatFileSize(&amp;TotalFileSize, 0, FileSize, TRUE); <br> <br>    swprintf(Percentage, TEXT("%d"), TotalPercentage); <br>    swprintf(Ratio, TEXT("%2.1lf"), f); <br> <br>    DisplayMsg(COMPACT_LIST_SUMMARY, FileCount, DirectoryCount, <br>               CompressedFileCount, UncompressedFileCount, <br>               FileSize, CompressedSize, <br>               Ratio ); <br> <br>    return; <br>} <br> <br>  <br>BOOLEAN <br>CompressFile ( <br>    IN HANDLE Handle, <br>    IN PTCHAR FileSpec, <br>    IN PWIN32_FIND_DATA FindData <br>    ) <br> <br>{ <br>    USHORT State = 1; <br>    ULONG Length; <br>    ULONG i; <br>    BOOLEAN Success; <br>    double f = 1.0; <br> <br>    if ((FindData-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_COMPRESSED) &amp;&amp; <br>        !ForceOperation) { <br> <br>        return TRUE; <br>    } <br> <br>    Success = DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &amp;State, <br>        sizeof(USHORT), NULL, 0, &amp;Length, FALSE ); <br> <br>    if (!Success) { <br> <br>        if (Quiet &amp;&amp; IgnoreErrors) { <br>            return FALSE || IgnoreErrors; <br>        } <br> <br>        swprintf(Buf, TEXT("%s "), FindData-&gt;cFileName); <br>        DisplayMsg(COMPACT_THROW, Buf); <br> <br>        for (i = lstrlen(FindData-&gt;cFileName) + 1; i &lt; FIRST_COLUMN_WIDTH; ++i) { <br>            swprintf(Buf, TEXT("%c"), ' '); <br>            DisplayMsg(COMPACT_THROW, Buf); <br>        } <br> <br>        DisplayMsg(COMPACT_ERR); <br> <br>        if (!Quiet &amp;&amp; !IgnoreErrors) { <br>            if (ERROR_INVALID_FUNCTION == GetLastError()) { <br> <br>                // This error is caused by doing the fsctl on a <br>                // non-compressing volume. <br> <br>                DisplayMsg(COMPACT_WRONG_FILE_SYSTEM_OR_CLUSTER_SIZE, FindData-&gt;cFileName); <br> <br>            } else { <br>                DisplayErr(FindData-&gt;cFileName, GetLastError()); <br>            } <br>        } <br> <br>        return FALSE || IgnoreErrors; <br>    } <br> <br>    if (!Quiet &amp;&amp; <br>        (DisplayAllFiles || <br>            (0 == (FindData-&gt;dwFileAttributes &amp; AttributesNoDisplay)))) { <br>        swprintf(Buf, TEXT("%s "), FindData-&gt;cFileName); <br>        DisplayMsg(COMPACT_THROW, Buf); <br> <br>        for (i = lstrlen(FindData-&gt;cFileName) + 1; i &lt; FIRST_COLUMN_WIDTH; ++i) { <br>            swprintf(Buf, TEXT("%c"), ' '); <br>            DisplayMsg(COMPACT_THROW, Buf); <br>        } <br>    } <br> <br> <br>    // <br>    //  Gather statistics and increment our running total <br>    // <br> <br>    { <br>        LARGE_INTEGER FileSize; <br>        LARGE_INTEGER CompressedSize; <br>        ULONG Percentage = 100; <br> <br>        FileSize.LowPart = FindData-&gt;nFileSizeLow; <br>        FileSize.HighPart = FindData-&gt;nFileSizeHigh; <br> <br>        CompressedSize.LowPart = GetCompressedFileSize( FileSpec, <br>            &amp;CompressedSize.HighPart ); <br> <br>        // <br>        // This statement to prevent confusion from the case where the <br>        // compressed file had been 0 size, but has grown since the filesize <br>        // was examined. <br>        // <br> <br>        if (0 == FileSize.QuadPart) { <br>            CompressedSize.QuadPart = 0; <br>        } <br> <br>        if (CompressedSize.QuadPart != 0) { <br> <br>            f = (double)FileSize.QuadPart / (double)CompressedSize.QuadPart; <br>        } <br> <br>        // <br>        //  Print out the sizes compression state and file name <br>        // <br> <br>        if (!Quiet &amp;&amp; <br>            (DisplayAllFiles || <br>                (0 == (FindData-&gt;dwFileAttributes &amp; AttributesNoDisplay)))) { <br> <br>            FormatFileSize(&amp;FileSize, 9, Buf, FALSE); <br>            lstrcat(Buf, TEXT(" : ")); <br>            FormatFileSize(&amp;CompressedSize, 9, &amp;Buf[lstrlen(Buf)], FALSE); <br> <br>            swprintf(&amp;Buf[lstrlen(Buf)], TEXT(" = %2.1lf "), f); <br> <br>            DisplayMsg(COMPACT_THROW, Buf); <br> <br>            DisplayMsg(COMPACT_TO_ONE); <br>            DisplayMsg(COMPACT_OK); <br>        } <br> <br>        // <br>        //  Increment our running total <br>        // <br> <br>        TotalFileSize.QuadPart += FileSize.QuadPart; <br>        TotalCompressedSize.QuadPart += CompressedSize.QuadPart; <br>        TotalFileCount.QuadPart += 1; <br>    } <br> <br>    return TRUE; <br>} <br> <br>BOOLEAN <br>DoCompressAction ( <br>    IN PTCHAR DirectorySpec, <br>    IN PTCHAR FileSpec <br>    ) <br> <br>{ <br>    PTCHAR DirectorySpecEnd; <br> <br>    // <br>    //  If the file spec is null then we'll set the compression bit for the <br>    //  the directory spec and get out. <br>    // <br> <br>    if (lstrlen(FileSpec) == 0) { <br> <br>        HANDLE FileHandle; <br>        USHORT State = 1; <br>        ULONG Length; <br> <br>        FileHandle = OpenFileForCompress(DirectorySpec); <br> <br>        if (INVALID_HANDLE_VALUE == FileHandle) { <br> <br>            DisplayErr(DirectorySpec, GetLastError()); <br>            return FALSE || IgnoreErrors; <br>        } <br> <br>        DisplayMsg(COMPACT_COMPRESS_DIR, DirectorySpec); <br> <br>        if (!DeviceIoControl(FileHandle, FSCTL_SET_COMPRESSION, &amp;State, <br>            sizeof(USHORT), NULL, 0, &amp;Length, FALSE )) { <br> <br>            if (!Quiet || !IgnoreErrors) { <br>                DisplayMsg(COMPACT_ERR); <br>            } <br>            if (!Quiet &amp;&amp; !IgnoreErrors) { <br>                DisplayErr(DirectorySpec, GetLastError()); <br>            } <br>            CloseHandle( FileHandle ); <br>            return FALSE || IgnoreErrors; <br>        } <br> <br>        if (!Quiet) { <br>            DisplayMsg(COMPACT_OK); <br>        } <br> <br>        CloseHandle( FileHandle ); <br> <br>        TotalDirectoryCount.QuadPart += 1; <br>        TotalFileCount.QuadPart += 1; <br> <br>        return TRUE; <br>    } <br> <br>    // <br>    //  So that we can keep on appending names to the directory spec <br>    //  get a pointer to the end of its string <br>    // <br> <br>    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec ); <br> <br>    // <br>    //  List the directory that we will be compressing within and say what its <br>    //  current compress attribute is <br>    // <br> <br>    { <br>        ULONG Attributes; <br> <br>        if (!Quiet || Quiet) { <br> <br>            Attributes = GetFileAttributes( DirectorySpec ); <br> <br>            if (Attributes &amp; FILE_ATTRIBUTE_COMPRESSED) { <br> <br>                DisplayMsg(COMPACT_COMPRESS_CDIR, DirectorySpec); <br> <br>            } else { <br> <br>                DisplayMsg(COMPACT_COMPRESS_UDIR, DirectorySpec); <br> <br>            } <br>        } <br> <br>        TotalDirectoryCount.QuadPart += 1; <br>    } <br> <br>    // <br>    //  Now for every file in the directory that matches the file spec we will <br>    //  will open the file and compress it <br>    // <br> <br>    { <br>        HANDLE FindHandle; <br>        HANDLE FileHandle; <br> <br>        WIN32_FIND_DATA FindData; <br> <br>        // <br>        //  setup the template for findfirst/findnext <br>        // <br> <br>        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) &lt; <br>            MAX_PATH) { <br> <br>           lstrcpy( DirectorySpecEnd, FileSpec ); <br> <br>           FindHandle = FindFirstFile( DirectorySpec, &amp;FindData ); <br> <br>           if (INVALID_HANDLE_VALUE != FindHandle) { <br> <br>               do { <br> <br>                   // <br>                   //  Now skip over the . and .. entries <br>                   // <br> <br>                   if (0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".")) || <br>                       0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".."))) { <br> <br>                       continue; <br> <br>                   } else { <br> <br>                       // <br>                       //  Make sure we don't try any paths that are too long for us <br>                       //  to deal with. <br>                       // <br> <br>                       if ( (DirectorySpecEnd - DirectorySpec) + <br>                           lstrlen( FindData.cFileName ) &gt;= MAX_PATH ) { <br> <br>                           continue; <br>                       } <br> <br>                       // <br>                       //  append the found file to the directory spec and open <br>                       //  the file <br>                       // <br> <br> <br>                       lstrcpy( DirectorySpecEnd, FindData.cFileName ); <br> <br>                       // <br>                       //  Hack hack, kludge kludge.  Refrain from compressing <br>                       //  files named "\NTDLR" to help users avoid hosing <br>                       //  themselves. <br>                       // <br> <br>                       if (IsNtldr(DirectorySpec)) { <br> <br>                           if (!Quiet) { <br>                               DisplayMsg(COMPACT_SKIPPING, DirectorySpecEnd); <br>                           } <br> <br>                           continue; <br>                       } <br> <br>                       FileHandle = OpenFileForCompress(DirectorySpec); <br> <br>                       if (INVALID_HANDLE_VALUE == FileHandle) { <br> <br>                           if (!Quiet || !IgnoreErrors) { <br>                               DisplayErr(FindData.cFileName, GetLastError()); <br>                           } <br> <br>                           if (!IgnoreErrors) { <br>                               FindClose(FindHandle); <br>                               return FALSE; <br>                           } <br>                           continue; <br>                       } <br> <br>                       // <br>                       //  Now compress the file <br>                       // <br> <br>                       if (!CompressFile( FileHandle, DirectorySpec, &amp;FindData )) { <br>                           CloseHandle( FileHandle ); <br>                           FindClose( FindHandle ); <br>                           return FALSE || IgnoreErrors; <br>                       } <br> <br>                       // <br>                       //  Close the file and go get the next file <br>                       // <br> <br>                       CloseHandle( FileHandle ); <br>                   } <br> <br>               } while ( FindNextFile( FindHandle, &amp;FindData )); <br> <br>               FindClose( FindHandle ); <br>           } <br>        } <br>    } <br> <br>    // <br>    //  If we are to do subdirectores then we will look for every subdirectory <br>    //  and recursively call ourselves to list the subdirectory <br>    // <br> <br>    if (DoSubdirectories) { <br> <br>        HANDLE FindHandle; <br> <br>        WIN32_FIND_DATA FindData; <br> <br>        // <br>        //  Setup findfirst/findnext to search the entire directory <br>        // <br> <br>        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) &lt; <br>            MAX_PATH) { <br> <br>           lstrcpy( DirectorySpecEnd, TEXT("*") ); <br> <br>           FindHandle = FindFirstFile( DirectorySpec, &amp;FindData ); <br> <br>           if (INVALID_HANDLE_VALUE != FindHandle) { <br> <br>               do { <br> <br>                   // <br>                   //  Now skip over the . and .. entries otherwise we'll recurse <br>                   //  like mad <br>                   // <br> <br>                   if (0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".")) || <br>                       0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".."))) { <br> <br>                       continue; <br> <br>                   } else { <br> <br>                       // <br>                       //  If the entry is for a directory then we'll tack on the <br>                       //  subdirectory name to the directory spec and recursively <br>                       //  call otherselves <br>                       // <br> <br>                       if (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br> <br>                           // <br>                           //  Make sure we don't try any paths that are too long for us <br>                           //  to deal with. <br>                           // <br> <br>                           if ((DirectorySpecEnd - DirectorySpec) + <br>                               lstrlen( TEXT("\\") ) + <br>                               lstrlen( FindData.cFileName ) &gt;= MAX_PATH ) { <br> <br>                               continue; <br>                           } <br> <br>                           lstrcpy( DirectorySpecEnd, FindData.cFileName ); <br>                           lstrcat( DirectorySpecEnd, TEXT("\\") ); <br> <br>                           if (!DoCompressAction( DirectorySpec, FileSpec )) { <br>                               FindClose( FindHandle ); <br>                               return FALSE || IgnoreErrors; <br>                           } <br>                       } <br>                   } <br> <br>               } while ( FindNextFile( FindHandle, &amp;FindData )); <br> <br>               FindClose( FindHandle ); <br>           } <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br>VOID <br>DoFinalCompressAction ( <br>    ) <br>{ <br>    ULONG TotalPercentage = 100; <br>    double f = 1.0; <br> <br>    TCHAR FileCount[32]; <br>    TCHAR DirectoryCount[32]; <br>    TCHAR CompressedSize[32]; <br>    TCHAR FileSize[32]; <br>    TCHAR Percentage[32]; <br>    TCHAR Ratio[8]; <br> <br>    if (TotalCompressedSize.QuadPart != 0) { <br>        f = (double)TotalFileSize.QuadPart / <br>            (double)TotalCompressedSize.QuadPart; <br>    } <br> <br>    FormatFileSize(&amp;TotalFileCount, 0, FileCount, FALSE); <br>    FormatFileSize(&amp;TotalDirectoryCount, 0, DirectoryCount, FALSE); <br>    FormatFileSize(&amp;TotalCompressedSize, 0, CompressedSize, TRUE); <br>    FormatFileSize(&amp;TotalFileSize, 0, FileSize, TRUE); <br> <br>    swprintf(Percentage, TEXT("%d"), TotalPercentage); <br>    swprintf(Ratio, TEXT("%2.1f"), f); <br> <br>    DisplayMsg(COMPACT_COMPRESS_SUMMARY, FileCount, DirectoryCount, <br>                FileSize, CompressedSize, Ratio ); <br> <br>} <br> <br>  <br>BOOLEAN <br>UncompressFile ( <br>    IN HANDLE Handle, <br>    IN PWIN32_FIND_DATA FindData <br>    ) <br>{ <br>    USHORT State = 0; <br>    ULONG Length; <br> <br>    if (!(FindData-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_COMPRESSED) &amp;&amp; <br>        !ForceOperation) { <br> <br>        return TRUE; <br>    } <br> <br>    if (!DeviceIoControl(Handle, FSCTL_SET_COMPRESSION, &amp;State, <br>        sizeof(USHORT), NULL, 0, &amp;Length, FALSE )) { <br> <br>        if (!Quiet || !IgnoreErrors) { <br> <br>            swprintf(Buf, TEXT("%s "), FindData-&gt;cFileName); <br>            DisplayMsg(COMPACT_THROW, Buf); <br> <br>            DisplayMsg(COMPACT_ERR); <br> <br>            if (!Quiet &amp;&amp; !IgnoreErrors) { <br> <br>                if (ERROR_INVALID_FUNCTION == GetLastError()) { <br> <br>                    // This error is caused by doing the fsctl on a <br>                    // non-compressing volume. <br> <br>                    DisplayMsg(COMPACT_WRONG_FILE_SYSTEM, FindData-&gt;cFileName); <br> <br>                } else { <br>                    DisplayErr(FindData-&gt;cFileName, GetLastError()); <br>                } <br>            } <br>        } <br>        return FALSE || IgnoreErrors; <br>    } <br> <br>    if (!Quiet &amp;&amp; <br>        (DisplayAllFiles || <br>            (0 == (FindData-&gt;dwFileAttributes &amp; AttributesNoDisplay)))) { <br>        swprintf(Buf, TEXT("%s "), FindData-&gt;cFileName); <br>        DisplayMsg(COMPACT_THROW, Buf); <br> <br>        DisplayMsg(COMPACT_OK); <br>    } <br> <br>    // <br>    //  Increment our running total <br>    // <br> <br>    TotalFileCount.QuadPart += 1; <br> <br>    return TRUE; <br>} <br> <br>BOOLEAN <br>DoUncompressAction ( <br>    IN PTCHAR DirectorySpec, <br>    IN PTCHAR FileSpec <br>    ) <br> <br>{ <br>    PTCHAR DirectorySpecEnd; <br> <br>    // <br>    //  If the file spec is null then we'll clear the compression bit for the <br>    //  the directory spec and get out. <br>    // <br> <br>    if (lstrlen(FileSpec) == 0) { <br> <br>        HANDLE FileHandle; <br>        USHORT State = 0; <br>        ULONG Length; <br> <br>        FileHandle = OpenFileForCompress(DirectorySpec); <br> <br>        if (INVALID_HANDLE_VALUE == FileHandle) { </code></pre>
<p>
</p>
<pre><code><br>            if (!Quiet || !IgnoreErrors) { <br>                DisplayErr(DirectorySpec, GetLastError()); <br>            } <br>            return FALSE || IgnoreErrors; <br>        } <br> <br>        DisplayMsg(COMPACT_UNCOMPRESS_DIR, DirectorySpec); <br> <br>        if (!DeviceIoControl(FileHandle, FSCTL_SET_COMPRESSION, &amp;State, <br>            sizeof(USHORT), NULL, 0, &amp;Length, FALSE )) { <br> <br>            if (!Quiet || !IgnoreErrors) { <br>                DisplayMsg(COMPACT_ERR); <br> <br>            } <br>            if (!Quiet &amp;&amp; !IgnoreErrors) { <br>                DisplayErr(DirectorySpec, GetLastError()); <br>            } <br> <br>            return FALSE || IgnoreErrors; <br>        } <br> <br>        if (!Quiet) { <br>            DisplayMsg(COMPACT_OK); <br>        } <br> <br>        CloseHandle( FileHandle ); <br> <br>        TotalDirectoryCount.QuadPart += 1; <br>        TotalFileCount.QuadPart += 1; <br> <br>        return TRUE; <br>    } <br> <br>    // <br>    //  So that we can keep on appending names to the directory spec <br>    //  get a pointer to the end of its string <br>    // <br> <br>    DirectorySpecEnd = DirectorySpec + lstrlen( DirectorySpec ); <br> <br>    // <br>    //  List the directory that we will be uncompressing within and say what its <br>    //  current compress attribute is <br>    // <br> <br>    { <br>        ULONG Attributes; <br> <br>        if (!Quiet || Quiet) { <br> <br>            Attributes = GetFileAttributes( DirectorySpec ); <br> <br>            if (Attributes &amp; FILE_ATTRIBUTE_COMPRESSED) { <br> <br>                DisplayMsg(COMPACT_UNCOMPRESS_CDIR, DirectorySpec); <br> <br>            } else { <br> <br>                DisplayMsg(COMPACT_UNCOMPRESS_UDIR, DirectorySpec); <br>            } <br>        } <br> <br>        TotalDirectoryCount.QuadPart += 1; <br>    } <br> <br>    // <br>    //  Now for every file in the directory that matches the file spec we will <br>    //  will open the file and uncompress it <br>    // <br> <br>    { <br>        HANDLE FindHandle; <br>        HANDLE FileHandle; <br> <br>        WIN32_FIND_DATA FindData; <br> <br>        // <br>        //  setup the template for findfirst/findnext <br>        // <br> <br>        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( FileSpec )) &lt; <br>            MAX_PATH) { <br> <br>           lstrcpy( DirectorySpecEnd, FileSpec ); <br> <br>           FindHandle = FindFirstFile( DirectorySpec, &amp;FindData ); <br> <br>           if (INVALID_HANDLE_VALUE != FindHandle) { <br> <br>               do { <br> <br>                   // <br>                   //  Now skip over the . and .. entries <br>                   // <br> <br>                   if (0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".")) || <br>                       0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".."))) { <br> <br>                       continue; <br> <br>                   } else { <br> <br>                       // <br>                       //  Make sure we don't try any paths that are too long for us <br>                       //  to deal with. <br>                       // <br> <br>                       if ((DirectorySpecEnd - DirectorySpec) + <br>                           lstrlen( FindData.cFileName ) &gt;= MAX_PATH ) { <br> <br>                           continue; <br>                       } <br> <br>                       // <br>                       //  append the found file to the directory spec and open <br>                       //  the file <br>                       // <br> <br>                       lstrcpy( DirectorySpecEnd, FindData.cFileName ); <br> <br>                       FileHandle = OpenFileForCompress(DirectorySpec); <br> <br>                       if (INVALID_HANDLE_VALUE == FileHandle) { <br> <br>                           if (!Quiet || !IgnoreErrors) { <br>                               DisplayErr(DirectorySpec, GetLastError()); <br>                           } <br> <br>                           if (!IgnoreErrors) { <br>                               FindClose( FindHandle ); <br>                               return FALSE; <br>                           } <br>                           continue; <br>                       } <br> <br>                       // <br>                       //  Now compress the file <br>                       // <br> <br>                       if (!UncompressFile( FileHandle, &amp;FindData )) { <br>                           CloseHandle( FileHandle ); <br>                           FindClose( FindHandle ); <br>                           return FALSE || IgnoreErrors; <br>                       } <br> <br>                       // <br>                       //  Close the file and go get the next file <br>                       // <br> <br>                       CloseHandle( FileHandle ); <br>                   } <br> <br>               } while ( FindNextFile( FindHandle, &amp;FindData )); <br> <br>               FindClose( FindHandle ); <br>           } <br>        } <br>    } <br> <br>    // <br>    //  If we are to do subdirectores then we will look for every subdirectory <br>    //  and recursively call ourselves to list the subdirectory <br>    // <br> <br>    if (DoSubdirectories) { <br> <br>        HANDLE FindHandle; <br> <br>        WIN32_FIND_DATA FindData; <br> <br>        // <br>        //  Setup findfirst/findnext to search the entire directory <br>        // <br> <br>        if (((DirectorySpecEnd - DirectorySpec) + lstrlen( TEXT("*") )) &lt; <br>            MAX_PATH) { <br> <br>           lstrcpy( DirectorySpecEnd, TEXT("*") ); <br> <br>           FindHandle = FindFirstFile( DirectorySpec, &amp;FindData ); <br>           if (INVALID_HANDLE_VALUE != FindHandle) { <br> <br>               do { <br> <br>                   // <br>                   //  Now skip over the . and .. entries otherwise we'll recurse <br>                   //  like mad <br>                   // <br> <br>                   if (0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".")) || <br>                       0 == lstrcmp(&amp;FindData.cFileName[0], TEXT(".."))) { <br> <br>                       continue; <br> <br>                   } else { <br> <br>                       // <br>                       //  If the entry is for a directory then we'll tack on the <br>                       //  subdirectory name to the directory spec and recursively <br>                       //  call otherselves <br>                       // <br> <br>                       if (FindData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) { <br> <br>                           // <br>                           //  Make sure we don't try any paths that are too long for us <br>                           //  to deal with. <br>                           // <br> <br>                           if ((DirectorySpecEnd - DirectorySpec) + <br>                               lstrlen( TEXT("\\") ) + <br>                               lstrlen( FindData.cFileName ) &gt;= MAX_PATH ) { <br> <br>                               continue; <br>                           } <br> <br>                           lstrcpy( DirectorySpecEnd, FindData.cFileName ); <br>                           lstrcat( DirectorySpecEnd, TEXT("\\") ); <br> <br>                           if (!DoUncompressAction( DirectorySpec, FileSpec )) { <br>                               FindClose( FindHandle ); <br>                               return FALSE || IgnoreErrors; <br>                           } <br>                       } <br>                   } <br> <br>               } while ( FindNextFile( FindHandle, &amp;FindData )); <br> <br>               FindClose( FindHandle ); <br>           } <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br>VOID <br>DoFinalUncompressAction ( <br>    ) <br> <br>{ <br>    TCHAR FileCount[32]; <br>    TCHAR DirectoryCount[32]; <br> <br>    FormatFileSize(&amp;TotalFileCount, 0, FileCount, FALSE); <br>    FormatFileSize(&amp;TotalDirectoryCount, 0, DirectoryCount, FALSE); <br> <br>    DisplayMsg(COMPACT_UNCOMPRESS_SUMMARY, FileCount, DirectoryCount); <br> <br>    return; <br>} <br> <br>  <br>VOID <br>__cdecl <br>main() <br>{ <br>    PTCHAR *argv; <br>    ULONG argc; <br> <br>    ULONG i; <br> <br>    PACTION_ROUTINE ActionRoutine = NULL; <br>    PFINAL_ACTION_ROUTINE FinalActionRoutine = NULL; <br> <br>    BOOLEAN UserSpecifiedFileSpec = FALSE; <br> <br>    TCHAR DirectorySpec[MAX_PATH]; <br>    TCHAR FileSpec[MAX_PATH]; <br>    PTCHAR p; <br> <br>    InitializeIoStreams(); <br> <br>    argv = CommandLineToArgvW(GetCommandLine(), &amp;argc); <br>    if (NULL == argv) { <br>        DisplayErr(NULL, GetLastError()); <br>        return; <br>    } <br> <br>    // <br>    //  Scan through the arguments looking for switches <br>    // <br> <br>    for (i = 1; i &lt; argc; i += 1) { <br> <br>        if (argv[i][0] == '/') { <br> <br>            if (0 == lstricmp(argv[i], TEXT("/c"))) { <br> <br>                if (ActionRoutine != NULL &amp;&amp; <br>                    ActionRoutine != DoCompressAction) { <br> <br>                    DisplayMsg(COMPACT_USAGE, NULL); <br>                    return; <br>                } <br> <br>                ActionRoutine = DoCompressAction; <br>                FinalActionRoutine = DoFinalCompressAction; <br> <br>            } else if (0 == lstricmp(argv[i], TEXT("/u"))) { <br> <br>                if (ActionRoutine != NULL &amp;&amp; ActionRoutine != DoListAction) { <br> <br>                    DisplayMsg(COMPACT_USAGE, NULL); <br>                    return; <br>                } <br> <br>                ActionRoutine = DoUncompressAction; <br>                FinalActionRoutine = DoFinalUncompressAction; <br> <br>            } else if (0 == lstricmp(argv[i], TEXT("/q"))) { <br> <br>                Quiet = TRUE; <br> <br>            } else if (0 == lstrnicmp(argv[i], TEXT("/s"), 2)) { <br> <br>                PTCHAR pch; <br> <br>                DoSubdirectories = TRUE; <br> <br>                pch = lstrchr(argv[i], ':'); <br>                if (NULL != pch) { <br>                    lstrcpy(StartingDirectory, pch + 1); <br>                } else if (2 == lstrlen(argv[i])) { <br> <br>                    // Starting dir is CWD <br> <br>                    GetCurrentDirectory( MAX_PATH, StartingDirectory ); <br> <br>                } else { <br>                    DisplayMsg(COMPACT_USAGE, NULL); <br>                    return; <br>                } <br> <br>            } else if (0 == lstricmp(argv[i], TEXT("/i"))) { <br> <br>                IgnoreErrors = TRUE; <br> <br>            } else if (0 == lstricmp(argv[i], TEXT("/f"))) { <br> <br>                ForceOperation = TRUE; <br> <br>            } else if (0 == lstricmp(argv[i], TEXT("/a"))) { <br> <br>                DisplayAllFiles = TRUE; <br> <br>            } else { <br> <br>                DisplayMsg(COMPACT_USAGE, NULL); <br>                return; <br>            } <br> <br>        } else { <br> <br>            UserSpecifiedFileSpec = TRUE; <br>        } <br>    } <br> <br>    // <br>    //  If the use didn't specify an action then set the default to do a listing <br>    // <br> <br>    if (ActionRoutine == NULL) { <br> <br>        ActionRoutine = DoListAction; <br>        FinalActionRoutine = DoFinalListAction; <br>    } <br> <br>    // <br>    //  Get our current directoy because the action routines might move us <br>    //  around <br>    // <br> <br>    if (!DoSubdirectories) { <br>        GetCurrentDirectory( MAX_PATH, StartingDirectory ); <br>    } else if (!SetCurrentDirectory( StartingDirectory )) { <br>        DisplayErr(StartingDirectory, GetLastError()); <br>        return; <br>    } <br> <br>    // <br>    //  If the user didn't specify a file spec then we'll do just "*" <br>    // <br> <br>    if (!UserSpecifiedFileSpec) { <br> <br>        (VOID)GetFullPathName( TEXT("*"), MAX_PATH, DirectorySpec, &amp;p ); <br> <br>        lstrcpy( FileSpec, p ); *p = '\0'; <br> <br>        // <br>        // Also want to make "compact /c" set the bit for the current <br>        // directory. <br>        // <br> <br>        if (ActionRoutine != DoListAction) { <br> <br>            (VOID)(ActionRoutine)( DirectorySpec, TEXT("") ); <br>        } <br> <br>        (VOID)(ActionRoutine)( DirectorySpec, FileSpec ); <br> <br>    } else { <br> <br>        // <br>        //  Now scan the arguments again looking for non-switches <br>        //  and this time do the action, but before calling reset <br>        //  the current directory so that things work again <br>        // <br> <br>        for (i = 1; i &lt; argc; i += 1) { <br> <br>            if (argv[i][0] != '/') { <br> <br>                SetCurrentDirectory( StartingDirectory ); <br> <br>                // <br>                // Handle a command with "." as the file argument specially, <br>                // since it doesn't make good sense and the results without <br>                // this code are surprising. <br>                // <br> <br>                if ('.' == argv[i][0] &amp;&amp; '\0' == argv[i][1]) { <br>                    argv[i] = TEXT("*"); <br>                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &amp;p); <br>                    *p = '\0'; <br>                    p = NULL; <br>                } else { <br> <br>                    PWCHAR pwch; <br> <br>                    GetFullPathName(argv[i], MAX_PATH, DirectorySpec, &amp;p); <br> <br>                    // <br>                    // We want to treat "foobie:xxx" as an invalid drive name, <br>                    // rather than as a name identifying a stream.  If there's <br>                    // a colon, there should be only a single character before <br>                    // it. <br>                    // <br> <br>                    pwch = wcschr(argv[i], ':'); <br>                    if (NULL != pwch &amp;&amp; pwch - argv[i] != 1) { <br>                        DisplayMsg(COMPACT_INVALID_PATH, argv[i]); <br>                        break; <br>                    } <br> <br>                    // <br>                    // GetFullPathName strips trailing dots, but we want <br>                    // to save them so that "*." will work correctly. <br>                    // <br> <br>                    if ('.' == argv[i][lstrlen(argv[i]) - 1]) { <br>                        lstrcat(DirectorySpec, TEXT(".")); <br>                    } <br>                } <br> <br>                if (IsUncRoot(DirectorySpec)) { <br> <br>                    // <br>                    // If the path is like \\server\share, we append an <br>                    // additional slash to make things come out right. <br>                    // <br> <br>                    lstrcat(DirectorySpec, TEXT("\\")); <br>                    p = NULL; <br>                } <br> <br> <br>                if (p != NULL) { <br>                    lstrcpy( FileSpec, p ); *p = '\0'; <br>                } else { <br>                    FileSpec[0] = '\0'; <br>                } <br> <br>                if (!(ActionRoutine)( DirectorySpec, FileSpec ) &amp;&amp; <br>                    !IgnoreErrors) { <br>                    break; <br>                } <br>            } <br>        } <br>    } <br> <br>    // <br>    //  Reset our current directory back <br>    // <br> <br>    SetCurrentDirectory( StartingDirectory ); <br> <br>    // <br>    //  And do the final action routine that will print out the final <br>    //  statistics of what we've done <br>    // <br> <br>    (FinalActionRoutine)(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
