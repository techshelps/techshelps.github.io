<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5631"></a>UTILS.C</h2>
<pre><code>/* <br> *  utils.c <br> *   <br> *  Purpose: <br> *      generic utils <br> *   <br> *  Owner: <br> *      MikeSart <br> */ <br>#define UNICODE 1 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;lm.h&gt; <br>#include "netwatch.h" <br>#include "rcids.h" <br> <br>ASSERTDATA <br> <br>/* <br> *General treeview routines <br> */ <br> <br>/* <br> *FTreeView_GetString <br> * <br> *Purpose: <br> *Get the text from a treeview <br> * <br> *Arguments: <br> *hItem, szText, and cchText <br> * <br> *Returns: <br> *TRUE - success, FALSE - failure <br> */ <br>BOOL <br>FTreeView_GetString(HWND hwndTV, HTREEITEM hItem, TCHAR *szText, UINT cchTextMax) <br>{ <br>TV_ITEMtvItem; <br> <br>Assert(IsWindow(hwndTV) &amp;&amp; hItem); <br>tvItem.mask = TVIF_TEXT; <br>tvItem.hItem = hItem; <br>tvItem.pszText = szText; <br>tvItem.cchTextMax = cchTextMax; <br>return TreeView_GetItem(hwndTV, &amp;tvItem); <br>} <br> <br>/* <br> *TreeView_GetRootCount <br> * <br> *Purpose: <br> *Count the number of roots (computers) <br> * <br> *Arguments: <br> *hwndTV <br> * <br> *Returns: <br> *a number <br> */ <br>UINT <br>TreeView_GetRootCount(HWND hwndTV) <br>{ <br>HTREEITEMhItem; <br>UINTcRoots = 0; <br> <br>Assert(IsWindow(hwndTV)); <br>hItem = TreeView_GetRoot(hwndTV); <br>while(hItem) <br>{ <br>cRoots++; <br>hItem = TreeView_GetNextSibling(hwndTV, hItem); <br>} <br> <br>OutputDbgStr("TreeView_GetRootCount: %ld", cRoots); <br>return cRoots; <br>} <br> <br>/* <br> *TreeView_GetRootList <br> * <br> *Purpose: <br> *Construct a REG_MULTI_SZ of roots <br> * <br> *Arguments: <br> *hwndTV, pcb <br> * <br> *Returns: <br> *TCHAR * to your new MULTI_SZ - be sure to free it <br> */ <br>LPTSTR <br>TreeView_GetRootList(HWND hwndTV, DWORD *pcb) <br>{ <br>LPTSTRpszT; <br>HTREEITEMhItem; <br>LPTSTRpszRootList; <br> <br>// Alloc enough for all the servers <br>Assert(IsWindow(hwndTV)); <br>*pcb = (TreeView_GetRootCount(hwndTV) * (UNCLEN + 1) + 1) * sizeof(TCHAR); <br>pszRootList = GlobalAllocPtr(GHND, *pcb); <br>if(pszT = pszRootList) <br>{ <br>hItem = TreeView_GetRoot(hwndTV); <br>while(hItem) <br>{ <br>TV_ITEMtvItem; <br>TCHARszT[UNCLEN + 1]; <br> <br>// If we retrieved the text, save it <br>tvItem.mask = TVIF_TEXT | TVIF_IMAGE; <br>tvItem.hItem = hItem; <br>tvItem.pszText = szT; <br>tvItem.cchTextMax = UNCLEN + 1; <br>if(TreeView_GetItem(hwndTV, &amp;tvItem) &amp;&amp; (szT[0] == '\\')) <br>{ <br>// mark the first char as the image type <br>szT[0] = tvItem.iImage + '0'; <br>// Make a REG_MULTI_SZ out of this stuff <br>OutputDbgStr("Roots: '%ls'", szT); <br>lstrcat(pszT, szT); <br>pszT += lstrlen(szT) + 1; <br>} <br> <br>hItem = TreeView_GetNextSibling(hwndTV, hItem); <br>} <br>} <br> <br>return pszRootList; <br>} <br> <br>/* <br> *GetComputerImage <br> * <br> *Purpose: <br> *Check the validity of a server the user is trying to add. <br> * <br> *Arguments: <br> *hwnd, szServerName <br> * <br> *Returns: <br> *-1 err, BMP_COMPUTER cool, BMP_COMPUTERLIMITED limited access <br> */ <br>int <br>GetComputerImage(HWND hwnd, TCHAR *szServerName) <br>{ <br>NET_API_STATUSnas; <br>TCHARchT; <br>HCURSORhCursor; <br>INTiImage = -1; <br>SHARE_INFO_2*shi2 = NULL; <br>DWORDdwentriesread; <br>DWORDdwtotalentries; <br>TCHARszMsg[cchErrMax]; <br>TCHAR*szErrMessage = NULL; <br> <br>Assert(hwnd); <br> <br>// When we write stuff to the registry, we set the first char to be the <br>// image type. <br>if((chT = szServerName[0]) != '\\') <br>szServerName[0] = '\\'; <br> <br>// This may take a while <br>hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>CharUpper(szServerName); <br>nas = NetShareEnum(szServerName, 2, (LPBYTE *)&amp;shi2, <br>MAX_PREFERRED_LENGTH, &amp;dwentriesread, &amp;dwtotalentries, NULL); <br>OutputDbgStr("GetComputerImage: nas = 0x%08lx", nas); <br> <br>SetCursor(hCursor); <br>switch(nas) <br>{ <br>case ERROR_SUCCESS: <br>iImage = BMP_COMPUTER; <br>break; <br>case ERROR_ACCESS_DENIED: <br>wsprintf(szMsg, szFromIDS1(IDS_ERRACCESS), szServerName); <br>// If iImage is already BMP_COMPUTERLIMITED, then we must have <br>// restored this from the registry so don't ask the user again. <br>if((chT == ('0' + BMP_COMPUTERLIMITED)) || <br>MessageBox(hwnd, szMsg, szAppName, <br>MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2) == IDYES) <br>iImage = BMP_COMPUTERLIMITED; <br>break; <br>default: <br>Assert(iImage == -1); <br>wsprintf(szMsg, szFromIDS1(IDS_ERRADDCOMPUTER), szServerName); <br>if(szErrMessage = GetSystemErrMessage(nas)) <br>lstrcat(szMsg, szErrMessage); <br>MessageBox(hwnd, szMsg, szAppName, MB_ICONEXCLAMATION | MB_OK); <br>break; <br>} <br> <br>GlobalFreeNullPtr(szErrMessage); <br>NetApiBufferFree(shi2); <br>return iImage; <br>} <br> <br>/* <br> *hAddComputer <br> * <br> *Purpose: <br> *Add a new computer to the hwndTV <br> * <br> *Arguments: <br> *computername to add <br> * <br> *Returns: <br> *hItem of existing or new rooted computername <br> */ <br>HTREEITEM <br>hAddComputer(HWND hwnd, HWND hwndTV, LPTSTR szComputerName, <br>HTREEITEM hItemLocation) <br>{ <br>TV_INSERTSTRUCTtvis; <br>HTREEITEMhItem; <br> <br>OutputDbgStr("hAddComputer: '%ls'", szComputerName); <br> <br>Assert(IsWindow(hwndTV)); <br>// Check to see if the name already exists <br>hItem = TreeView_GetRoot(hwndTV); <br>while(hItem) <br>{ <br>TCHARszT[UNCLEN + 1]; <br> <br>if(FTreeView_GetString(hwndTV, hItem, szT, UNCLEN + 1) &amp;&amp; <br>!lstrcmpi(szComputerName, szT)) <br>{ <br>// Oooh - found one <br>OutputDbgStr("'%ls' already there", szComputerName); <br>TreeView_SelectItem(hwndTV, hItem); <br>return hItem; <br>} <br> <br>hItem = TreeView_GetNextSibling(hwndTV, hItem); <br>} <br> <br>// Not found - add it <br>// Check for access, computer existance, etc. here. <br>tvis.item.iImage = tvis.item.iSelectedImage = <br>GetComputerImage(hwnd, szComputerName); <br>if(tvis.item.iImage == -1) <br>return NULL; <br> <br>tvis.hParent = NULL; <br>tvis.hInsertAfter = hItemLocation; <br>tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; <br>tvis.item.pszText = szComputerName; <br> <br>if(hItem = TreeView_InsertItem(hwndTV, &amp;tvis)) <br>TreeView_SelectItem(hwndTV, hItem); <br>return hItem; <br>} <br> <br>/* <br> *RestoreServerList <br> * <br> *Purpose: <br> *add initial servers to tv via command line, registry, local computer <br> * <br> *Arguments: <br> *hwnd, hwndTV, REG_MULTI_SZ pszServers <br> * <br> *Returns: <br> *nada <br> */ <br>VOID <br>RestoreServerList(HWND hwnd, HWND hwndTV, TCHAR *pszServers) <br>{ <br>DWORDnT; <br>INTargc; <br>LPTSTRpszT; <br>HTREEITEMhItem; <br>TCHAR**argv; <br>BOOLfSuccess = FALSE; <br>TCHARszComputerName[UNCLEN + 1]; <br> <br>szComputerName[0] = szComputerName[1] = '\\'; <br> <br>// Handle command line <br>argv = CommandLineToArgvW(GetCommandLine(), &amp;argc); <br>while(argc-- &gt; 1) <br>{ <br>if(lstrlen(argv[argc]) &gt; UNCLEN) <br>argv[argc][UNCLEN] = 0; <br> <br>nT = ((argv[argc][0] == '\\') &amp;&amp; (argv[argc][1] == '\\')) ? 0 : 2; <br>lstrcpy(&amp;szComputerName[nT], argv[argc]); <br>CharUpper(szComputerName); <br>if(hAddComputer(hwnd, hwndTV, szComputerName, TVI_FIRST)) <br>fSuccess = TRUE; <br>} <br> <br>if(!fSuccess &amp;&amp; pszServers) <br>{ <br>// Loop through all these SZs adding em <br>for(pszT = pszServers; *pszT; pszT += lstrlen(pszT) + 1) <br>{ <br>if(hAddComputer(hwnd, hwndTV, pszT, TVI_LAST)) <br>fSuccess = TRUE; <br>OutputDbgStr("Restoring '%ls'", pszT); <br>} <br>} <br> <br>// If we didn't get any servers yet, just default to this computer <br>if(!fSuccess) <br>{ <br>nT = UNCLEN - 1; <br>Assert((szComputerName[0] == '\\') &amp;&amp; (szComputerName[1] == '\\')); <br>if(GetComputerName(&amp;szComputerName[2], &amp;nT)) <br>hAddComputer(hwnd, hwndTV, szComputerName, TVI_FIRST); <br>} <br> <br>// Select the first item <br>if(hItem = TreeView_GetRoot(hwndTV)) <br>TreeView_SelectItem(hwndTV, hItem); <br>} <br> <br>/* <br> *RestoreWindowPosition <br> * <br> *Purpose: <br> *Nostalgia <br> * <br> *Arguments: <br> *hwnd to nostalge <br> * <br> *Returns: <br> *zipola <br> */ <br>VOID <br>RestoreWindowPosition(HWND hwnd, HWND hwndTV) <br>{ <br>DWORDcb; <br>WINDOWPLACEMENTwndpl; <br>DWORDfHideTitle; <br>HKEYhkey = NULL; <br>DWORDdwTopMost = 0; <br>TCHAR*pszServers = NULL; <br> <br>wndpl.showCmd = SW_SHOWNORMAL; <br>if(RegOpenKeyEx(HKEY_CURRENT_USER, szFromIDS1(IDS_KEY), 0, KEY_READ, &amp;hkey)) <br>goto err; <br> <br>cb = sizeof(fHideTitle); <br>if(!RegQueryValueEx(hkey, szFromIDS1(IDS_HIDETITLE), 0, 0, <br>(LPBYTE)&amp;fHideTitle, &amp;cb) &amp;&amp; fHideTitle) <br>ShowTitle(hwnd, SW_HIDE); <br> <br>cb = COUNT_CHECKMENUS * sizeof(unMenuFlags[0]); <br>if(!RegQueryValueEx(hkey, szFromIDS1(IDS_MENUFLAGS), 0, 0, <br>(LPBYTE)unMenuFlags, &amp;cb)) <br>{ <br>for(cb = 0; cb &lt; COUNT_CHECKMENUS; cb++) <br>{ <br>CheckMenuItem(ghMenu, CHECKMENUSTART + cb, <br>MF_BYCOMMAND | unMenuFlags[cb]); <br>} <br>} <br> <br>cb = sizeof(wndpl); <br>if(!RegQueryValueEx(hkey, szFromIDS1(IDS_PLACEMENT), 0, 0, <br>(LPBYTE)&amp;wndpl, &amp;cb)) <br>{ <br>if(wndpl.length == sizeof(wndpl)) <br>SetWindowPlacement(hwnd, &amp;wndpl); <br>} <br> <br>cb = sizeof(dwTimerInterval); <br>RegQueryValueEx(hkey, szFromIDS1(IDS_TIMERINTERVAL), 0, 0, <br>(LPBYTE)&amp;dwTimerInterval, &amp;cb); <br> <br>if(!RegQueryValueEx(hkey, szFromIDS1(IDS_TOPMOST), 0, 0, <br>(LPBYTE)&amp;dwTopMost, &amp;cb) &amp;&amp; cb &amp;&amp; dwTopMost) <br>{ <br>SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, <br>SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE); <br>CheckMenuItem(ghMenu, IDM_TOPMOST, MF_BYCOMMAND | MF_CHECKED); <br>} <br> <br>// Get the size of the servers and any we had store away. <br>cb = TreeView_GetCount(hwndTV); <br>if(!cb &amp;&amp; !RegQueryValueEx(hkey, szFromIDS1(IDS_SERVERS), 0, 0, NULL, &amp;cb)) <br>{ <br>if(cb &amp;&amp; (pszServers = GlobalAllocPtr(GHND, cb))) <br>RegQueryValueEx(hkey, szFromIDS1(IDS_SERVERS), 0, 0, <br>(LPBYTE)pszServers, &amp;cb); <br>} <br> <br>CloseHandle(hkey); <br> <br>err: <br>ShowWindow(hwnd, wndpl.showCmd); <br> <br>if(dwTimerInterval &lt; 1000) <br>dwTimerInterval = 1000; <br> <br>RestoreServerList(hwnd, hwndTV, pszServers); <br>GlobalFreeNullPtr(pszServers); <br>} <br> <br>/* <br> *SaveWindowPosition <br> * <br> *Purpose: <br> *Put all our eggs in one basket <br> * <br> *Arguments: <br> *hwnd of basket <br> * <br> *Returns: <br> *zipster <br> */ <br>VOID <br>SaveWindowPosition(HWND hwnd, HWND hwndTV) <br>{ <br>DWORDcb; <br>WINDOWPLACEMENTwndpl; <br>HKEYhkey; <br>DWORDdwTopMost; <br>DWORDfHideTitle; <br>LPTSTRpszRootList; <br> <br>Assert(IsWindow(hwndTV)); <br>wndpl.length = sizeof(wndpl); <br>GetWindowPlacement(hwnd, &amp;wndpl); <br>// for some reason, GetWindowPlacement resets the length part?? <br>wndpl.length = sizeof(wndpl); <br> <br>if(!RegCreateKeyEx(HKEY_CURRENT_USER, szFromIDS1(IDS_KEY), 0, szFromIDS1(IDS_KEY), 0, <br>KEY_READ | KEY_WRITE, 0, &amp;hkey, NULL)) <br>{ <br>// Save away the list of computer names <br>if(pszRootList = TreeView_GetRootList(hwndTV, &amp;cb)) <br>{ <br>RegSetValueEx(hkey, szFromIDS1(IDS_SERVERS), 0, REG_MULTI_SZ, <br>(LPBYTE)pszRootList, cb); <br>GlobalFreePtr(pszRootList); <br>} <br> <br>RegSetValueEx(hkey, szFromIDS1(IDS_PLACEMENT), 0, REG_BINARY, <br>(LPBYTE)&amp;wndpl, sizeof(wndpl)); <br> <br>RegSetValueEx(hkey, szFromIDS1(IDS_MENUFLAGS), 0, REG_BINARY, <br>(LPBYTE)unMenuFlags, COUNT_CHECKMENUS * sizeof(unMenuFlags[0])); <br> <br>RegSetValueEx(hkey, szFromIDS1(IDS_TIMERINTERVAL), 0, REG_DWORD, <br>(LPBYTE)&amp;dwTimerInterval, sizeof(dwTimerInterval)); <br> <br>fHideTitle = GetMenu(hwnd) ? 0 : 1; <br>RegSetValueEx(hkey, szFromIDS1(IDS_HIDETITLE), 0, REG_DWORD, <br>(LPBYTE)&amp;fHideTitle, sizeof(fHideTitle)); <br> <br>dwTopMost = GetMenuState(ghMenu, IDM_TOPMOST, MF_BYCOMMAND) &amp; MF_CHECKED; <br>RegSetValueEx(hkey, szFromIDS1(IDS_TOPMOST), 0, REG_DWORD, <br>(LPBYTE)&amp;dwTopMost, sizeof(dwTopMost)); <br> <br>CloseHandle(hkey); <br>} <br>} <br> <br>/* <br> *szFromIDS1 <br> * <br> *Purpose: <br> *LoadString and ids and keep it in a static buffer <br> * <br> *Arguments: <br> *ids to load <br> * <br> *Returns: <br> *TCHAR * to the static buffer <br> */ <br>TCHAR * <br>szFromIDS1(UINT unID) <br>{ <br>#define cchMaxIDS200 <br>static TCHAR szBuf1[cchMaxIDS]; <br> <br>szBuf1[0] = '\0'; <br>SideAssert(LoadString(ghInst, unID, szBuf1, cchMaxIDS)); <br>return szBuf1; <br>} <br> <br>/* <br> *AllocAndLoadString <br> * <br> *Purpose: <br> *Alloc enough room to load an IDS <br> * <br> *Arguments: <br> *ids to return <br> * <br> *Returns: <br> *TCHAR * <br> */ <br>TCHAR * <br>AllocAndLoadString(UINT unID) <br>{ <br>TCHAR*sz; <br>TCHAR*szT = szFromIDS1(unID); <br> <br>sz = GlobalAllocPtr(GHND, (lstrlen(szT) + 1) * sizeof(TCHAR)); <br>if(sz) <br>lstrcpy(sz, szT); <br> <br>return sz; <br>}     <br> <br>/* <br> *GetSystemErrMessage <br> * <br> *Purpose: <br> *Format an error message string <br> * <br> *Arguments: <br> *dwError <br> * <br> *Returns: <br> *a TCHAR * that you must free <br> */ <br>TCHAR * <br>GetSystemErrMessage(DWORD dwError) <br>{ <br>LPTSTR  szErrMessage = NULL; <br>HMODULE hLibrary; <br> <br>if(dwError == ERROR_INVALID_LEVEL) <br>{ <br>// This err usually occurs when we try to view a WFW machine. <br>// So, the PM decided to use our own version of the err msg. <br>szErrMessage = AllocAndLoadString(IDS_ERRWFW); <br>}  <br>else if(FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, dwError, 0, (LPTSTR)&amp;szErrMessage, 0, NULL)) <br>{ <br>szErrMessage[lstrlen(szErrMessage) - 2] = '\0'; // remove /r/n <br>} <br>else if(hLibrary = LoadLibrary(MESSAGE_FILENAME)) <br>{ <br>if(FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE, <br>(LPVOID)hLibrary, dwError, 0, (LPTSTR)&amp;szErrMessage, 0, NULL)) <br>{ <br>szErrMessage[lstrlen(szErrMessage) - 2] = '\0'; // remove /r/n <br>} <br>FreeLibrary(hLibrary); <br>} <br> <br>return szErrMessage; <br>} <br> <br>/* <br> *PunchTimer <br> * <br> *Purpose: <br> *turn on\off timer <br> * <br> *Arguments: <br> *TRUE: turn on timer <br> *FALSE: turn it off <br> * <br> *Returns: <br> *nada <br> */ <br>VOID <br>PunchTimer(HWND hwndMain, BOOL fNewState) <br>{ <br>static BOOL fCurrentState = FALSE; <br> <br>if(fCurrentState == fNewState) <br>return; <br> <br>if(fNewState) <br>SetTimer(hwndMain, TIMERID, dwTimerInterval, NULL); <br>else <br>KillTimer(hwndMain, TIMERID); <br> <br>fCurrentState = fNewState; <br>} <br> <br>/* <br> *ShowTitle <br> * <br> *Purpose: <br> *Show\Hidle title bar <br> * <br> *Arguments: <br> *hwnd, nCmdShow (SW_HIDE, SW_SHOW) <br> * <br> *Returns: <br> *zip <br> */ <br>VOID <br>ShowTitle(HWND hwnd, int nCmdShow) <br>{ <br>DWORDdwStyle; <br>static HMENUhMenu = NULL; <br> <br>dwStyle = GetWindowLong(hwnd, GWL_STYLE); <br>if(hMenu) <br>{ <br>dwStyle = WS_TILEDWINDOW | dwStyle; <br>SetMenu(hwnd, hMenu); <br>hMenu = NULL; <br>} <br>else <br>{ <br>dwStyle &amp;= ~(WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX); <br>hMenu = GetMenu(hwnd); <br>SetMenu(hwnd, NULL); <br>} <br> <br>SetWindowLong(hwnd, GWL_STYLE, dwStyle); <br>SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | <br>SWP_NOZORDER | SWP_FRAMECHANGED); <br> <br>ShowWindow(hwnd, nCmdShow); <br>} <br> <br>/* <br> *Date\Time routines <br> */ <br> <br>/* <br> *PutDate <br> * <br> *Purpose: <br> *Convert a tm_t to '6/8/95' <br> * <br> *Arguments: <br> *tm_t, str, and cchstr <br> * <br> *Returns: <br> *str <br> */ <br>TCHAR * <br>PutDate(time_t tm_t, TCHAR *szStr, UINT cch) <br>{ <br>SYSTEMTIME  st; <br>struct tm   *ptm; <br> <br>ptm = localtime(&amp;tm_t); <br> <br>st.wYear= ptm-&gt;tm_year + 1900; <br>st.wMonth= ptm-&gt;tm_mon + 1; <br>st.wDay= ptm-&gt;tm_mday; <br> <br>GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &amp;st, NULL, szStr, cch); <br>return szStr; <br>} <br> <br>/* <br> *PutTime <br> * <br> *Purpose: <br> *Convert a tm_t to '6:31 am' <br> * <br> *Arguments: <br> *tm_t, str, and cchstr <br> * <br> *Returns: <br> *str <br> */ <br>TCHAR * <br>PutTime(time_t tm_t, TCHAR *szStr, UINT cch) <br>{ <br>SYSTEMTIME  st; <br>struct tm   *ptm; <br> <br>ptm = localtime(&amp;tm_t); <br> <br>st.wHour= ptm-&gt;tm_hour; <br>st.wMinute= ptm-&gt;tm_min; <br>st.wSecond= ptm-&gt;tm_sec; <br>st.wMilliseconds= 0; <br> <br>GetTimeFormat(LOCALE_USER_DEFAULT, 0, &amp;st, NULL, szStr, cch); <br>return szStr; <br>} <br> <br>/* <br> *PutCounterTime <br> * <br> *Purpose: <br> *Convert a tm_t to '6:31:00' <br> * <br> *Arguments: <br> *tm_t, str, and cchstr <br> * <br> *Returns: <br> *str <br> */ <br>TCHAR * <br>PutCounterTime(DWORD dwTime, TCHAR *szStr, UINT cch) <br>{ <br>SYSTEMTIME  st; <br>TCHARszTimeSep[cchSzMax]; <br>SCONST TCHARszFmtCounter[] = TEXT("%02d%s%d"); <br> <br>st.wHour= (WORD)(dwTime / 3600); <br>dwTime-= (st.wHour * 3600); <br>st.wMinute= (WORD)(dwTime / 60); <br>dwTime-= (st.wMinute * 60); <br>st.wSecond= (WORD)dwTime; <br>st.wMilliseconds= 0; <br> <br>GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STIME, szTimeSep, cchSzMax); <br>wsprintf(szStr, szFmtCounter, st.wHour, szTimeSep, st.wMinute); <br>Assert((UINT)lstrlen(szStr) &lt; cch); <br>return szStr; <br>} <br> <br>/* <br> *  TreeView and Imagelist routines <br> */ <br> <br>// handle to our imagelist <br>HIMAGELISThImal = NULL; <br> <br>/* <br> *  InitNetWatchWnd <br> *   <br> *  Purpose: <br> *      inits listbox globals, creates listbox <br> *   <br> *  Arguments: <br> *      HWND    main hwnd of app (parent of LB) <br> *   <br> *  Returns: <br> *      hwnd of treeview <br> */ <br>HWND <br>InitNetWatchWnd(HWND hwnd) <br>{ <br>HWNDhwndTV; <br>SCONST TCHARszWCTreeView[] = WC_TREEVIEW; <br> <br>OutputDbgStr("InitNetWatchWnd"); <br> <br>// Init common controls <br>InitCommonControls(); <br> <br>// Create our imagelist <br>hImal = ImageList_LoadBitmap(ghInst, MAKEINTRESOURCE(IDB_LB), <br>BMWIDTH, 0, RGBREPLACE); <br>if(!hImal) <br>return NULL; <br> <br>// Create our treeview <br>hwndTV = CreateWindow(szWCTreeView, NULL, <br>WS_VISIBLE | WS_CHILD | TVS_HASLINES | TVS_DISABLEDRAGDROP, <br>0, 0, 0, 0, hwnd, (HMENU)IDD_tvwSHARES, ghInst, NULL); <br>if(!hwndTV) <br>return NULL; <br>TreeView_SetImageList(hwndTV, hImal, 0); <br> <br>// Make sure our new tv has the focus <br>SetFocus(hwndTV); <br>return hwndTV; <br>} <br> <br>/* <br> *  DeInitNetWatchWnd <br> *   <br> *  Purpose: <br> *      cleans up LB hfonts, hdc, and hbmps <br> *   <br> *  Arguments: <br> *   <br> *  Returns: <br> *      hopefully <br> */ <br>VOID <br>DeInitNetWatchWnd(VOID) <br>{ <br>if(hImal) <br>{ <br>ImageList_Destroy(hImal); <br>hImal = NULL; <br>} <br>} <br> <br>/* <br> *BlitIcon <br> * <br> *Purpose: <br> *Smack an icon onto an hdc <br> * <br> *Arguments: <br> *hdc, x, y, bitmap index <br> * <br> *Returns: <br> *nope <br> */ <br>VOID <br>BlitIcon(HDC hdc, LONG x, LONG y, int nBitmap) <br>{ <br>ImageList_Draw(hImal, nBitmap, hdc, x, y, ILD_TRANSPARENT); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
