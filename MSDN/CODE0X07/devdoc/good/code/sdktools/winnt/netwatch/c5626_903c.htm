<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NETWATCH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5628"></a>NETWATCH.C</h2>
<pre><code>/* <br> *  netwatch.c <br> *   <br> *  Purpose: <br> *      WinMain and Wndprocs <br> *   <br> *  Owner: <br> *      MikeSart <br> */ <br>#define UNICODE 1 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;lm.h&gt; <br>#include "netwatch.h" <br>#include "rcids.h" <br> <br>ASSERTDATA <br> <br>/* <br> *Globules <br> */ <br>HINSTANCEghInst;// hInstance <br>HMENUghMenu;// Main menu handle <br>HWNDhwndTV;// hwnd of TreeView control <br>UINTcUsers = 0;// # of users currently connected <br>TCHARszAppName[cchSzMax];// Localized "NetWatch" <br>DWORDdwTimerInterval= 30000;// Check for new server every 30 secs <br>TCHARszNil[]= TEXT("");// Save a byte <br>WNDPROClpfnOldTVProc;// subclassed Treeview wndproc <br>// showhidden, showinuse, showfiles <br>UINTunMenuFlags[3]  = { MF_UNCHECKED, MF_UNCHECKED, MF_UNCHECKED }; <br> <br>/* <br> *WinMain <br> * <br> *Purpose: <br> *Main entry point <br> * <br> *Arguments: <br> *read the SDK <br> * <br> *Returns: <br> *an int <br> */ <br>int CALLBACK <br>WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>MSGmsg; <br>HANDLEhAccel; <br>WNDCLASSwndclass; <br>HWNDhwndMain; <br>SCONST TCHARszClassName[] = TEXT("NetWatchClass"); <br> <br>ghInst = hInst; <br> <br>// Get our app name <br>lstrcpyn(szAppName, szFromIDS1(IDS_APPNAME), cchSzMax); <br> <br>// Register our class <br>wndclass.style= CS_HREDRAW | CS_VREDRAW; <br>wndclass.lpfnWndProc= WndProc; <br>wndclass.cbClsExtra= 0; <br>wndclass.cbWndExtra= 0; <br>wndclass.hInstance= hInst; <br>wndclass.hIcon= NULL; <br>wndclass.hCursor= LoadCursor(NULL, IDC_ARROW); <br>wndclass.hbrBackground= (HBRUSH)(COLOR_WINDOW + 1); <br>wndclass.lpszMenuName= MAKEINTRESOURCE(IDD_MENU); <br>wndclass.lpszClassName= szClassName; <br>if(!RegisterClass(&amp;wndclass)) <br>goto err; <br> <br>// Create the main window <br>if(!(hwndMain = CreateWindow(szClassName, szAppName, <br>WS_OVERLAPPEDWINDOW, 100, 100, 200, 200, <br>NULL, NULL, hInst, NULL))) <br>goto err; <br>RestoreWindowPosition(hwndMain, hwndTV); <br> <br>// Refresh the display <br>PostMessage(hwndMain, WM_TIMER, 0, 0L); <br> <br>hAccel = LoadAccelerators(ghInst, MAKEINTRESOURCE(IDD_ACCL)); <br>while(GetMessage(&amp;msg, NULL, 0, 0)) <br>{ <br>if(!TranslateAccelerator(hwndMain, hAccel, &amp;msg)) <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>} <br>} <br> <br>return msg.wParam; <br> <br>err: <br>MessageBox(NULL, szFromIDS1(IDS_ERRMEMORY), szAppName, MB_OK); <br>return -1; <br>} <br> <br>/* <br> *Cooler routines <br> */ <br>#ifdef DOSHAREMANAGE <br>SCONST TCHARszLMDll[] = TEXT("ntlanman.dll"); <br>SCONST CHARszShareManageEntry[] = "ShareManage"; <br>SCONST CHARszServerBrowseEntry[] = "ServerBrowseDialogA0"; <br> <br>typedef DWORD (WINAPI *LPFNServerBrowseDialogA0)(HWND hwnd, CHAR *pchBuffer, <br>DWORD cchBufSize); <br>typedef VOID (WINAPI *LPFNSHAREMANAGE)(HWND, TCHAR *); <br> <br>BOOL <br>ShareManage(HWND hwnd) <br>{ <br>LPFNSHAREMANAGElpfn; <br>HTREEITEMhItem; <br>HTREEITEMhItemT; <br>HMODULEhMod = NULL; <br>TCHARszServerName[UNCLEN + 1]; <br> <br>// Get the root (server name) of whatever is selected <br>if(!(hItem = TreeView_GetSelection(hwndTV))) <br>return FALSE; <br>while(hItemT = TreeView_GetParent(hwndTV, hItem)) <br>hItem = hItemT; <br>// Get the server name <br>if(!FTreeView_GetString(hwndTV, hItem, szServerName, cchTVSzMax)) <br>goto err; <br> <br>// Bring up the share manage dialog <br>if((hMod = LoadLibrary(szLMDll)) &amp;&amp; <br>(lpfn = (LPFNSHAREMANAGE)GetProcAddress(hMod, szShareManageEntry))) <br>{ <br>(*lpfn)(hwnd, szServerName); <br>} <br> <br>err: <br>if(hMod) <br>FreeLibrary(hMod); <br>if(!lpfn) <br>MessageBeep(MB_ICONEXCLAMATION); <br>return (BOOL)lpfn; <br>} <br> <br>VOID <br>SelectComputer(HWND hwnd) <br>{ <br>LPFNServerBrowseDialogA0lpfn; <br>HMODULEhMod = NULL; <br>CHARszT[UNCLEN + 1]; <br> <br>if((hMod = LoadLibrary(szLMDll)) &amp;&amp; <br>(lpfn = (LPFNServerBrowseDialogA0)GetProcAddress(hMod, <br>szServerBrowseEntry))) <br>{ <br>retry: <br>(*lpfn)(hwnd, szT, UNCLEN); <br>if(szT[0] == '\\' &amp;&amp; szT[1] == '\\') <br>{ <br>TCHARszNewServerName[UNCLEN + 1]; <br> <br>OutputDbgStr("ServerBrowseDialogA0 returns '%s'", szT); <br>MultiByteToWideChar(CP_ACP, 0, szT, -1, szNewServerName, <br>UNCLEN + 1); <br>if(!hAddComputer(hwnd, hwndTV, szNewServerName, TVI_FIRST)) <br>goto retry; <br>PostMessage(hwnd, WM_TIMER, 0, 0L); <br>} <br>} <br>else <br>{ <br>MessageBeep(MB_ICONEXCLAMATION); <br>} <br> <br>if(hMod) <br>FreeLibrary(hMod); <br>} <br>#endif// DOSHAREMANAGE <br> <br>/* <br> *HandleWMCommand <br> * <br> *Purpose: <br> *Message Cracker to handle WM_COMMAND from WndProc <br> * <br> *Arguments: <br> *hwnd, id, hwndCtl, and notify code <br> * <br> *Returns: <br> *nada <br> */ <br>VOID <br>HandleWMCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>switch(id) <br>{ <br>case IDM_DISCONNECTDRIVE: <br>WNetDisconnectDialog(hwnd, RESOURCETYPE_DISK); <br>break; <br> <br>case IDM_CONNECTDRIVE: <br>WNetConnectionDialog(hwnd, RESOURCETYPE_DISK); <br>break; <br> <br>#ifdef DOSHAREMANAGE <br>case IDM_SHAREMANAGE: <br>ShareManage(hwnd); <br>break; <br>#endif <br> <br>case IDM_SELECTCOMPUTER: <br>// Add another computer <br>PunchTimer(hwnd, FALSE); <br>#ifdef DOSHAREMANAGE <br>SelectComputer(hwnd); <br>#else <br>DialogBox(ghInst, MAKEINTRESOURCE(DLG_SELECT), hwnd, SelectDlgProc); <br>#endif <br>PunchTimer(hwnd, TRUE); <br>break; <br> <br>case IDM_DELETERESOURCE: <br>// Delete menu item <br>HandleWM_VKEY(hwnd, hwndTV, VK_DELETE); <br>break; <br> <br>case IDM_PROPERTIES: <br>// Properties menu item <br>HandleWM_VKEY(hwnd, hwndTV, VK_RETURN); <br>break; <br> <br>case IDM_NOMENUBAR: <br>// Show that menu bar <br>ShowTitle(hwnd, SW_SHOW); <br>break; <br> <br>case IDM_TOPMOST: <br>{ <br>HWNDhwndT= HWND_TOPMOST; <br>UINTunFlags= MF_CHECKED; <br> <br>if(GetMenuState(ghMenu, IDM_TOPMOST, MF_BYCOMMAND) &amp; MF_CHECKED) <br>{ <br>hwndT = HWND_NOTOPMOST; <br>unFlags = MF_UNCHECKED; <br>} <br> <br>SetWindowPos(hwnd, hwndT, 0, 0, 0, 0, <br>SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE); <br>CheckMenuItem(ghMenu, IDM_TOPMOST, MF_BYCOMMAND | unFlags); <br>break; <br>} <br> <br>case IDM_SHOWHIDDEN: <br>case IDM_SHOWINUSE: <br>case IDM_SHOWFILES: <br>Assert((id &amp; 0xff) &lt; COUNT_CHECKMENUS); <br> <br>// Toggle the checked bit and set it  <br>unMenuFlags[id &amp; 0xff] ^= MF_CHECKED; <br>CheckMenuItem(ghMenu, id, MF_BYCOMMAND | unMenuFlags[id &amp; 0xff]); <br>// Fall through and refresh <br> <br>case IDM_REFRESH: <br>// Refresh the TV <br>PostMessage(hwnd, WM_TIMER, 0, 0L); <br>break; <br> <br>case WM_CONTEXTMENU: <br>OutputDbgStr("WM_CONTEXTMENU"); <br>break; <br> <br>case IDM_ABOUT: <br>ShellAbout(hwnd, szAppName, NULL, <br>LoadIcon(ghInst, MAKEINTRESOURCE(IDD_ICONON))); <br>break; <br> <br>case IDM_EXIT: <br>PostMessage(hwnd, WM_CLOSE, 0, 0L); <br>break; <br>} <br>} <br> <br>/* <br> *HandleWMNotify <br> * <br> *Purpose: <br> *Message cracker for WM_NOTIFYs from WndProc <br> * <br> *Arguments: <br> *hwnd, idFrom, pnmhdr <br> * <br> *Returns: <br> *BOOL <br> */ <br>BOOL <br>HandleWMNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr) <br>{ <br>//OutputDbgStr("HandleWMNotify: 0x%08lx", pnmhdr-&gt;code); <br>switch(pnmhdr-&gt;code) <br>{ <br>case NM_RCLICK: <br>{ <br>TV_HITTESTINFOhtti; <br>DWORDdwPos; <br>HTREEITEMhItem; <br>POINTptScreen; <br> <br>// Try to get the item that was clicked and bring up a context menu <br>dwPos = GetMessagePos(); <br>htti.pt.x = ptScreen.x = LOWORD(dwPos); <br>htti.pt.y = ptScreen.y = HIWORD(dwPos); <br>ScreenToClient(hwndTV, &amp;htti.pt); <br>if(hItem = TreeView_HitTest(hwndTV, &amp;htti)) <br>{ <br>HMENUhMenu; <br> <br>if(hMenu = LoadMenu(ghInst, MAKEINTRESOURCE(IDD_MENUPROPS))) <br>{ <br>// Select the click item <br>TreeView_SelectItem(hwndTV, hItem); <br>// Setup up the appropriate menu strings <br>HandleMenu(hwnd, hwndTV, hMenu); <br>// Pop up a menu <br>TrackPopupMenu(GetSubMenu(hMenu, 0), <br>TPM_LEFTALIGN | TPM_RIGHTBUTTON, <br>ptScreen.x, ptScreen.y, 0, hwnd, NULL); <br>DestroyMenu(hMenu); <br>} <br>else <br>{ <br>MessageBeep(0); <br>} <br>} <br>break; <br>} <br> <br>case NM_DBLCLK: <br>// Bring up properites <br>HandleWM_VKEY(hwnd, hwndTV, VK_RETURN); <br>break; <br> <br>case TVN_KEYDOWN: <br>// Handle delete key <br>if(((TV_KEYDOWN *)pnmhdr)-&gt;wVKey == VK_DELETE) <br>return HandleWM_VKEY(hwnd, hwndTV, VK_DELETE); <br>else if(((TV_KEYDOWN *)pnmhdr)-&gt;wVKey == VK_INSERT) <br>PostMessage(hwnd, WM_COMMAND, IDM_SELECTCOMPUTER, 0); <br>break; <br> <br>case TVN_DELETEITEM: <br>// Free any memory this item may be holding onto <br>TreeView_FreeItemData(&amp;((NM_TREEVIEW *)pnmhdr)-&gt;itemOld); <br>break; <br> <br>case TVN_ITEMEXPANDING: <br>// Only allow expands to pass through <br>if(((NM_TREEVIEW *)pnmhdr)-&gt;action != TVE_EXPAND) <br>{ <br>OutputDbgStr("denying TVN_ITEMEXPANDING"); <br>return TRUE; <br>} <br>break; <br>} <br> <br>return FALSE; <br>} <br> <br>/* <br> *WndProc <br> * <br> *Purpose: <br> *Main wndproc for netwatch <br> * <br> *Arguments: <br> *hwnd, etc. <br> * <br> *Returns: <br> *an LRESULT <br> */ <br>LRESULT CALLBACK <br>WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>switch (message) <br>{ <br>case WM_CREATE: <br>// Get our menu <br>ghMenu = GetMenu(hwnd); <br> <br>// Create our treeview, imagelist, etc. <br>if(!(hwndTV = InitNetWatchWnd(hwnd))) <br>return -1L; <br> <br>// subclass treeview control <br>lpfnOldTVProc = SubclassWindow(hwndTV, NewTVProc); <br>return 0; <br> <br>case WM_TIMER: <br>cUsers = RefreshDisplay(hwnd, hwndTV); <br>return 0; <br> <br>case WM_QUERYDRAGICON: <br>return (LRESULT)LoadIcon(ghInst, cUsers ? MAKEINTRESOURCE(IDD_ICONON) : <br>MAKEINTRESOURCE(IDD_ICONOFF)); <br> <br>case WM_PAINT: <br>if(IsIconic(hwnd)) <br>{ <br>PAINTSTRUCT ps; <br>HDC         hdc; <br>HICON       hIcon; <br> <br>hdc = BeginPaint(hwnd, &amp;ps); <br>DefWindowProc(hwnd, WM_ICONERASEBKGND, (WPARAM)hdc, 0L); <br>hIcon = LoadIcon(ghInst, cUsers ? MAKEINTRESOURCE(IDD_ICONON) : <br>MAKEINTRESOURCE(IDD_ICONOFF)); <br>DrawIcon(hdc, 0, 0, hIcon); <br>EndPaint(hwnd, &amp;ps); <br>} <br>break; <br> <br>case WM_SETFOCUS: <br>SetFocus(hwndTV); <br>return 0; <br> <br>case WM_SYSCOLORCHANGE: <br>OutputDbgStr("WM_SYSCOLORCHANGE"); <br>break; <br> <br>case WM_SIZE: <br>if(hwndTV) <br>{ <br>RECT rc; <br> <br>// Figure the new client area <br>GetClientRect(hwnd, &amp;rc); <br>// Resize the TreeView control <br>SetWindowPos(hwndTV, NULL, 0, 0, rc.right, rc.bottom, SWP_NOZORDER); <br>return 0; <br>} <br>break; <br> <br>case WM_INITMENU: <br>HandleMenu(hwnd, hwndTV, ghMenu); <br>break; <br> <br>case WM_NOTIFY: <br>return HANDLE_WM_NOTIFY(hwnd, wParam, lParam, HandleWMNotify); <br> <br>case WM_COMMAND: <br>HANDLE_WM_COMMAND(hwnd, wParam, lParam, HandleWMCommand); <br>break; <br> <br>case WM_QUERYENDSESSION: <br>PostMessage(hwnd, WM_CLOSE, 0, 0L); <br>break; <br> <br>case WM_DESTROY: <br>PunchTimer(hwnd, FALSE); <br>if(hwndTV) <br>{ <br>SaveWindowPosition(hwnd, hwndTV); <br>SubclassWindow(hwndTV, lpfnOldTVProc); <br>PostQuitMessage(0); <br>} <br>DeInitNetWatchWnd(); <br>return 0; <br>} <br> <br>return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br>/* <br> *NewTVProc <br> * <br> *Purpose: <br> *Subclassed TV proc <br> * <br> *Arguments: <br> *ok <br> * <br> *Returns: <br> *we hope <br> */ <br>LRESULT CALLBACK <br>NewTVProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>switch(msg) <br>{ <br>case WM_LBUTTONDBLCLK: <br>// If they double click and the menu is hidden, show it <br>if(!GetMenu(GetParent(hwnd))) <br>{ <br>ShowTitle(GetParent(hwnd), SW_SHOW); <br>return 0; <br>} <br>break; <br> <br>case WM_RBUTTONDBLCLK: <br>if(GetKeyState(16) &amp; 32768) <br>{ <br>TV_INSERTSTRUCTtvis; <br>HTREEITEMhItem; <br>intnch = 0; <br>TCHARszBuf[cchSzMax]; <br>static const CHAR szVer[] = VER_PRODUCTVERSIONSTR; <br> <br>while(szVer[nch])  <br>szBuf[nch++] = szVer[nch] ^ 65535; <br>szBuf[nch] = 0; <br>tvis.hParent = tvis.hInsertAfter = NULL; <br>tvis.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; <br>tvis.item.pszText = szBuf; <br>tvis.item.iImage = tvis.item.iSelectedImage = BMP_BOB; <br>tvis.item.lParam = (LPARAM)TYPE_ERROR; <br>if(hItem = TreeView_InsertItem(hwndTV, &amp;tvis)) <br>TreeView_SelectItem(hwndTV, hItem); <br>} <br>break; <br> <br>case WM_MOUSEMOVE: <br>// Do that move entire window via client area thing <br>if(wParam &amp; MK_LBUTTON) <br>SendMessage(GetParent(hwnd), WM_SYSCOMMAND, <br>SC_MOVE | HTCLIENT, 0L); <br>break; <br>} <br> <br>// Let the treeview play now <br>return CallWindowProc(lpfnOldTVProc, hwnd, msg, wParam, lParam); <br>} <br> <br>/* <br> *SelectDlgProc <br> * <br> *Purpose: <br> *Add a new computer name to the TV <br> * <br> *Arguments: <br> *standard Dlg stuff <br> * <br> *Returns: <br> *more standard Dlg stuff <br> */ <br>#ifndef DOSHAREMANAGE <br>BOOL CALLBACK <br>SelectDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>UINTnT; <br>TCHARszNewServerName[UNCLEN + 1]; <br> <br>switch(message) <br>{ <br>case WM_INITDIALOG: <br>// limit any possible damage <br>Edit_LimitText(GetDlgItem(hDlg, IDD_edtCOMPNAME), CNLEN); <br> <br>// Fill the edit control with something <br>nT = UNCLEN - 1; <br>if(GetComputerName(&amp;szNewServerName[2], &amp;nT)) <br>{ <br>szNewServerName[0] = szNewServerName[1] = '\\'; <br>Edit_SetText(GetDlgItem(hDlg, IDD_edtCOMPNAME), szNewServerName); <br>} <br>return TRUE; <br> <br>case WM_COMMAND: <br>switch(LOWORD(wParam)) <br>{ <br>case IDD_edtCOMPNAME: <br>// Only enable the &lt;ok&gt; button if they've typed something <br>Button_Enable(GetDlgItem(hDlg, IDOK), <br>Edit_GetTextLength(GetDlgItem(hDlg, IDD_edtCOMPNAME))); <br>break; <br> <br>case IDOK: <br>if(!IsWindowEnabled(GetDlgItem(hDlg, IDOK))) <br>break; <br> <br>// Get whatever they typed in <br>nT = 2; <br>Edit_GetText(GetDlgItem(hDlg, IDD_edtCOMPNAME), <br>&amp;szNewServerName[nT], UNCLEN + 1); <br> <br>// add two '\\'s if not there <br>if(szNewServerName[nT] != TEXT('\\') || <br>szNewServerName[nT + 1] != TEXT('\\')) <br>{ <br>nT = 0; <br>szNewServerName[0] = szNewServerName[1] = TEXT('\\'); <br>} <br> <br>// Ok, add the computer and refresh <br>if(!hAddComputer(hDlg, hwndTV, &amp;szNewServerName[nT], TVI_FIRST)) <br>break; <br>PostMessage(GetParent(hDlg), WM_TIMER, 0, 0L); <br> <br>case IDCANCEL: <br>EndDialog(hDlg, LOWORD(wParam)); <br>return TRUE; <br>} <br>} <br> <br>return FALSE; <br>} <br>#endif <br> <br>/* <br> *Property Dialog stuff <br> */ <br>#define NUMPROPFIELDS6 <br>typedef struct <br>{ <br>WORDrgIDSStart; <br>DWORDdwrgBmp; <br>TCHAR*rgsz[NUMPROPFIELDS]; <br>} DLGPROPS; <br> <br>#define CAPTION_ITEM(_dw)(((_dw) &lt;&lt; 1) + 2) <br>#define TEXT_ITEM(_dw)(((_dw) &lt;&lt; 1) + 3) <br> <br>/* <br> *PropDlgProc <br> * <br> *Purpose: <br> *Property Sheet dlg proc <br> * <br> *Arguments: <br> *DLGPROC * on WM_INITDIALOG <br> * <br> *Returns: <br> *yep <br> */ <br>BOOL CALLBACK <br>PropDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>RECTrc; <br>DWORDdwT; <br>static DWORDdwrgBmp; <br>TCHARszBuf[cchSzMax]; <br>staticHBRUSHhbrBtnFace = NULL; <br> <br>switch(message) <br>{ <br>case WM_INITDIALOG: <br>{ <br>DLGPROPS  *pprops = (DLGPROPS *)((PROPSHEETPAGE *)lParam)-&gt;lParam; <br> <br>// Loop through and set the edit control fields <br>dwrgBmp = pprops-&gt;dwrgBmp; <br>for(dwT = 0; (dwT &lt; NUMPROPFIELDS) &amp;&amp;  <br>LoadString(ghInst, pprops-&gt;rgIDSStart + dwT, szBuf, cchSzMax); dwT++) <br>{ <br>// Set the left static control <br>SetDlgItemText(hDlg, CAPTION_ITEM(dwT), szBuf); <br> <br>// If we were passed a string, set it <br>if(pprops-&gt;rgsz[dwT]) <br>{ <br>SetDlgItemText(hDlg, TEXT_ITEM(dwT), pprops-&gt;rgsz[dwT]); <br>Edit_Enable(GetDlgItem(hDlg, TEXT_ITEM(dwT)), TRUE); <br>} <br>} <br> <br>// move the window over (BMWIDTH+2) pixels if an icon is there <br>for(dwT = 0; dwT &lt; (sizeof(DWORD) &lt;&lt; 1); dwT++) <br>{ <br>if(((dwrgBmp &gt;&gt; (dwT &lt;&lt; 2)) &amp; 0xf) != 0xf) <br>{ <br>GetWindowRect(GetDlgItem(hDlg, TEXT_ITEM(dwT)), &amp;rc); <br>ScreenToClient(hDlg, (LPPOINT)&amp;rc); <br>ScreenToClient(hDlg, ((LPPOINT)&amp;rc) + 1); <br>rc.left += (BMWIDTH + 2); <br>SetWindowPos(GetDlgItem(hDlg, TEXT_ITEM(dwT)),  <br>NULL, rc.left, rc.top, rc.right - rc.left,  <br>rc.bottom - rc.top, SWP_NOZORDER); <br>} <br>} <br>return TRUE; <br>} <br> <br>case WM_PAINT: <br>{ <br>PAINTSTRUCTps; <br>HDChdc; <br> <br>hdc = BeginPaint(hDlg, &amp;ps); <br> <br>GetWindowRect(GetDlgItem(hDlg, 3), &amp;rc); <br>ScreenToClient(hDlg, (LPPOINT)&amp;rc); <br> <br>// Draw the cute little bitmaps <br>for(dwT = 0; dwT &lt; (sizeof(DWORD) &lt;&lt; 1); dwT++) <br>{ <br>if(((dwrgBmp &gt;&gt; (dwT &lt;&lt; 2)) &amp; 0xf) != 0xf) <br>{ <br>GetWindowRect(GetDlgItem(hDlg, (dwT &lt;&lt; 1) + 3), &amp;rc); <br>ScreenToClient(hDlg, (LPPOINT)&amp;rc); <br>BlitIcon(hdc, rc.left - BMWIDTH - 2, rc.top, <br>(dwrgBmp &gt;&gt; (dwT &lt;&lt; 2)) &amp; 0xf); <br>} <br>} <br> <br>EndPaint(hDlg, &amp;ps); <br>break; <br>} <br> <br>case WM_CTLCOLOREDIT: <br>SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, message), <br>GetSysColor(COLOR_BTNFACE)); <br>if(!hbrBtnFace) <br>hbrBtnFace = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>return (BOOL)hbrBtnFace; <br> <br>case WM_SYSCOLORCHANGE: <br>// Fall through and delete the brush <br>case WM_DESTROY: <br>if(hbrBtnFace) <br>{ <br>DeleteBrush(hbrBtnFace); <br>hbrBtnFace = NULL; <br>} <br>break; <br>} <br> <br>return FALSE; <br>} <br> <br>/* <br> *PropertyDlg <br> * <br> *Purpose: <br> *Bring up the properties dialog <br> * <br> *Arguments: <br> *IDS, bmp array, and 6 strings <br> * <br> *Returns: <br> * <br> */ <br>VOID _cdecl <br>PropertyDlg(HWND hwnd, UINT rgIDSStart, DWORD dwrgBmp, ...) <br>{ <br>UINTnT; <br>DLGPROPSprops; <br>va_listarglist; <br>PROPSHEETPAGEpsp[] = <br>{ <br>{ <br>sizeof(PROPSHEETPAGE), PSP_DEFAULT, ghInst, <br>MAKEINTRESOURCE(DLG_PROPERTIES), NULL, NULL, PropDlgProc, 0, NULL, <br>NULL <br>} <br>}; <br>PROPSHEETHEADERpsh = <br>{  <br>sizeof(PROPSHEETHEADER), PSH_PROPTITLE | PSH_PROPSHEETPAGE, <br>hwndTV, ghInst, NULL, MAKEINTRESOURCE(rgIDSStart + 15), <br>sizeof(psp) / sizeof(PROPSHEETPAGE), 0, (LPCPROPSHEETPAGE)&amp;psp, NULL <br>}; <br> <br>// Save the IDS and bmp array <br>props.rgIDSStart = rgIDSStart; <br>props.dwrgBmp = dwrgBmp; <br> <br>// Loop through and get all static field text <br>va_start(arglist, dwrgBmp); <br>for(nT = 0; nT &lt; NUMPROPFIELDS; nT++) <br>{ <br>props.rgsz[nT] = va_arg(arglist, TCHAR *); <br>Assert(!props.rgsz[nT] || !IsBadStringPtr(props.rgsz[nT], (UINT)-1)); <br>} <br>va_end(arglist); <br> <br>// Display the puppy <br>psp[0].lParam = (LPARAM)&amp;props; <br>PropertySheet(&amp;psh); <br>} <br> <br>/* <br> *Debug only routines <br> */ <br> <br>/* <br> *DbgPrint <br> * <br> *Purpose: <br> *Debug only variable outputdebugstring <br> * <br> *Parameters: <br> *Standard wsprintf type stuff <br> * <br> *Returns: <br> *nada <br> */ <br>#ifdef DEBUG <br>VOID _cdecl <br>DbgPrint(const CHAR *lpFmt, ...) <br>{ <br>va_listarglist; <br>CHARlpOutput[400] = "NW: "; <br> <br>va_start(arglist, lpFmt); <br>wvsprintfA(&amp;lpOutput[4], lpFmt, arglist); <br>va_end(arglist); <br> <br>lstrcatA(lpOutput, "\r\n"); <br>OutputDebugStringA(lpOutput); <br>} <br> <br>UINT <br>AssertSzFn(LPSTR szMsg, LPSTR szFile, INT nLine) <br>{ <br>CHARrgch[1024]; <br>CHARrgchUnk[] = "Unknown file\n"; <br>INTnID; <br> <br>if(szFile) <br>wsprintfA(rgch, "File %s, line %d\n", szFile, nLine); <br>else <br>lstrcpyA(rgch, rgchUnk); <br> <br>if(szMsg) <br>lstrcatA(rgch, szMsg); <br> <br>MessageBeep(MB_ICONHAND); <br>nID = MessageBoxA(NULL, rgch, "Assert Failure", <br>MB_ABORTRETRYIGNORE | MB_DEFBUTTON3 | MB_ICONHAND |  <br>MB_SETFOREGROUND | MB_TASKMODAL); <br> <br>if(nID == IDRETRY) <br>DebugBreak(); <br> <br>// if cancelling, force a hard exit w/ a GP-fault so that Dr. Watson <br>// generates a nice stack trace log. <br>if(nID == IDABORT) <br>*(BYTE *)0 = 1;// write to address 0 causes GP-fault <br> <br>return nID; <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
