<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NET.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5627"></a>NET.C</h2>
<pre><code>/* <br> *  net.c <br> *   <br> *  Purpose: <br> *      net functions <br> *   <br> *  Owner: <br> *      MikeSart <br> */ <br>#define UNICODE 1 <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;lm.h&gt; <br>#include "netwatch.h" <br>#include "rcids.h" <br> <br>ASSERTDATA <br> <br>// From lmcons.h: <br>//  NNLEN: max share name <br>//  UNLEN: max user name <br>//  MAXCOMMENTSZ: max comment length <br>//  PATHLEN: max path <br> <br>// From datetime.c <br>TCHAR*PutTime(time_t tm_t, TCHAR *szStr, UINT cch); <br>TCHAR*PutDate(time_t tm_t, TCHAR *szStr, UINT cch); <br>TCHAR*PutCounterTime(DWORD dw, TCHAR *szStr, UINT cch); <br> <br>/* <br> *Useful macros <br> */ <br>// Should we consider szShare hidden? <br>#define FIsShareHidden(_szShare) \ <br>((_szShare)[lstrlen(_szShare) - 1] == TEXT('$')) <br>// Is the lParam in the TV_ITEM a pointer to TVDATA or just a type? <br>#define FIsLParamTVData(_lp) \ <br>(((_lp) + 1) &gt; 1) <br> <br>/* <br> *Globules <br> */ <br>SCONST TCHARszFmtNum[]      = TEXT("%lu"); <br> <br>/* <br> *Typedefs <br> */ <br>typedef struct tagTVDATA <br>{ <br>DWORDdwType; <br>} TVDATA; <br> <br>typedef struct tagTVDATASHARE <br>{ <br>DWORDdwType;// TYPE_SHARE, TYPE_USER, or TYPE_FILE <br>DWORDdwShareType;// STYPE_IPC, etc. <br>TCHARszShareName[NNLEN + 1];// e$, etc. <br> <br>TCHARszServerName[UNCLEN + 1]; <br>} TVDATASHARE; <br> <br>typedef struct tagTVDATAUSER <br>{ <br>DWORDdwType;// TYPE_SHARE, TYPE_USER, or TYPE_FILE <br>TCHARszUserName[UNLEN + 1];// BillG, etc. <br>TCHARszNetName[UNCLEN + 1];// \\BILLG1, etc. <br> <br>TVDATASHARE*pTVDataShare;// Parent data <br>} TVDATAUSER; <br> <br>typedef struct tagTVDATAFILE <br>{ <br>DWORDdwType;// TYPE_SHARE, TYPE_USER, or TYPE_FILE <br>DWORDdwFileId;// fi3_id <br> <br>TVDATAUSER*pTVDataUser;// Parent data <br>} TVDATAFILE; <br> <br>/* <br> *Treeview nonsense <br> */ <br> <br>/* <br> *TreeView_FindExactString <br> * <br> *Purpose: <br> *Find a szText starting from hItemStart <br> * <br> *Arguments: <br> *hParent, hItemStart, szText <br> * <br> *Returns: <br> *hItem or NULL <br> */ <br>HTREEITEM <br>TreeView_FindExactString(HWND hwndTV, HTREEITEM hParent, HTREEITEM hItemStart, <br>TCHAR *szText) <br>{ <br>TCHARszT[cchTVSzMax]; <br> <br>// Start looking one node after us <br>hItemStart = hItemStart ? TreeView_GetNextSibling(hwndTV, hItemStart) : <br>TreeView_GetChild(hwndTV, hParent); <br> <br>// Loop through looking for that baby <br>while(hItemStart) <br>{ <br>// Get the text <br>if(FTreeView_GetString(hwndTV, hItemStart, szT, cchTVSzMax)) <br>{ <br>UINT nRet = lstrcmp(szText, szT); <br> <br>// Strings should be in the treeview control like: <br>//   aaaa$ <br>//   bbbb$ <br>//   zzzz$ <br>//   bbbb <br>//   ffff <br> <br>// So, if the strings match, return em <br>// Else szText is larger than szT and we're past the hidden shares <br>// so the item shouldn't be here <br>if(!nRet) <br>return hItemStart; <br>else if((nRet &lt; 0) &amp;&amp; !FIsShareHidden(szT)) <br>return NULL; <br>} <br> <br>hItemStart = TreeView_GetNextSibling(hwndTV, hItemStart); <br>} <br> <br>return hItemStart; <br>} <br> <br>/* <br> *FTreeView_DeleteRange <br> * <br> *Purpose: Delete hItemStart+1 to hItemEnd-1 <br> *hItemStart <br> *hItemStart+1 <br> *... <br> *HItemEnd-1 <br> *HItemEnd <br> * <br> *Arguments: <br> *hwndTV, hItemStart, hItemEnd <br> * <br> *Returns: <br> *TRUE - success, FALSE - failure <br> */ <br>BOOL <br>FTreeView_DeleteRange(HWND hwndTV, HTREEITEM hParent, HTREEITEM hItemStart, <br>HTREEITEM hItemEnd) <br>{ <br>// If NULL, we want the first item, else we want hItemStart + 1 <br>hItemStart = hItemStart ? TreeView_GetNextSibling(hwndTV, hItemStart) : <br>TreeView_GetChild(hwndTV, hParent); <br> <br>while(hItemStart &amp;&amp; (hItemStart != hItemEnd)) <br>{ <br>HTREEITEMhItemT; <br> <br>hItemT = TreeView_GetNextSibling(hwndTV, hItemStart); <br>TreeView_DeleteItem(hwndTV, hItemStart); <br>hItemStart = hItemT; <br>} <br> <br>return TRUE; <br>} <br> <br>/* <br> *TreeView_TVReplacelParam <br> * <br> *Purpose: <br> *Replace an lparam and free any associated memory <br> * <br> *Arguments: <br> *hItem to replace and lParamNew <br> * <br> *Returns: <br> *TRUE - success, FALSE - failed <br> */ <br>BOOL <br>TreeView_TVReplacelParam(HWND hwndTV, HTREEITEM hItem, LPARAM lParamNew) <br>{ <br>TV_ITEMtvItem; <br>LPARAMlParamOld; <br> <br>tvItem.mask = TVIF_PARAM; <br>tvItem.hItem = hItem; <br>TreeView_GetItem(hwndTV, &amp;tvItem); <br>lParamOld = tvItem.lParam; <br> <br>tvItem.lParam = lParamNew; <br>TreeView_SetItem(hwndTV, &amp;tvItem); <br> <br>if(FIsLParamTVData(lParamOld)) <br>GlobalFreePtr((TVDATA *)lParamOld); <br>return TRUE; <br>} <br> <br>/* <br> *TreeView_TVDataInsert <br> * <br> *Purpose: <br> *Try to be smart when inserting TV items <br> * <br> *Arguments: <br> *ptvis to insert <br> * <br> *Returns: <br> *hItem of newly inserted item <br> */ <br>HTREEITEM <br>TreeView_TVDataInsert(HWND hwndTV, TV_INSERTSTRUCT *ptvis) <br>{ <br>HTREEITEMhItem; <br> <br>// See if this item exists anywhere already <br>hItem = TreeView_FindExactString(hwndTV, ptvis-&gt;hParent, <br>ptvis-&gt;hInsertAfter, ptvis-&gt;item.pszText); <br> <br>// It does: del everything from the last inserted node to right before us <br>if(hItem) <br>{ <br>OutputDbgStr("TreeView_TVDataInsert found '%ls'", ptvis-&gt;item.pszText); <br>FTreeView_DeleteRange(hwndTV, ptvis-&gt;hParent, ptvis-&gt;hInsertAfter, <br>hItem); <br>TreeView_TVReplacelParam(hwndTV, hItem, ptvis-&gt;item.lParam); <br>ptvis-&gt;hInsertAfter = hItem; <br>return hItem; <br>} <br> <br>// ok, it's a new string, insert it <br>// If this is the first one, make sure it's the first one <br>OutputDbgStr("TreeView_TVDataInsert inserting '%ls'", ptvis-&gt;item.pszText); <br>if(!ptvis-&gt;hInsertAfter) <br>ptvis-&gt;hInsertAfter = TVI_FIRST; <br>hItem = TreeView_InsertItem(hwndTV, ptvis); <br>// Store away the last item we've inserted <br>ptvis-&gt;hInsertAfter = hItem; <br> <br>return hItem; <br>} <br> <br>/* <br> *TreeView_FreeItemData <br> * <br> *Purpose: <br> *Free our alloc'd lParam (called via DELETEITEM) <br> * <br> *Arguments: <br> *ptvItem of item being deleted <br> * <br> *Returns: <br> *nada <br> */ <br>VOID <br>TreeView_FreeItemData(TV_ITEM *ptvItem) <br>{ <br>if(FIsLParamTVData(ptvItem-&gt;lParam)) <br>{ <br>OutputDbgStr("TreeView_FreeItemData '%d'", <br>((TVDATA *)ptvItem-&gt;lParam)-&gt;dwType); <br>GlobalFreePtr((TVDATA *)ptvItem-&gt;lParam); <br>ptvItem-&gt;lParam = 0; <br>} <br>} <br> <br>/* <br> *TreeView_GetSelectedItemData <br> * <br> *Purpose: <br> *Get type and lParam of selected item <br> * <br> *Arguments: <br> *pdwType <br> * <br> *Returns: <br> *lParam of selected item <br> */ <br>LPARAM <br>TreeView_GetSelectedItemData(HWND hwndTV, DWORD *pdwType) <br>{ <br>HTREEITEMhItem; <br>TV_ITEMtvItem; <br> <br>*pdwType = TYPE_ERROR; <br>if(!(hItem = TreeView_GetSelection(hwndTV))) <br>return 0; <br> <br>tvItem.mask = TVIF_PARAM; <br>tvItem.hItem = hItem; <br>tvItem.lParam = TYPE_ERROR; <br>TreeView_GetItem(hwndTV, &amp;tvItem); <br> <br>*pdwType = FIsLParamTVData(tvItem.lParam) ? <br>((TVDATA *)tvItem.lParam)-&gt;dwType : tvItem.lParam; <br>return tvItem.lParam; <br>} <br> <br>/* <br> *Sorting routines <br> */ <br> <br>/* <br> *CompareShareNames <br> * <br> *Purpose: <br> *compare two share names being 'smart' about hidden shares <br> * <br> *Arguments: <br> *share1, share2 <br> * <br> *Returns: <br> *-1, 0, 1 <br> */ <br>int <br>CompareShareNames(TCHAR *szShareName1, TCHAR *szShareName2) <br>{ <br>BOOLfShare1Hidden; <br>BOOLfShare2Hidden; <br> <br>fShare1Hidden = FIsShareHidden(szShareName1); <br>fShare2Hidden = FIsShareHidden(szShareName2); <br> <br>// If they're the same type, just string compare them <br>if(fShare1Hidden == fShare2Hidden) <br>return lstrcmpi(szShareName1, szShareName2); <br> <br>// Otherwise we want hidden shares to go first <br>return fShare1Hidden ? -1 : 1; <br>} <br> <br>/* <br> *QSortCallbacks <br> * <br> *Purpose: <br> *called from qsort to figure what goes where <br> * <br> *Arguments: <br> *elements to compare <br> * <br> *Returns: <br> *&lt; 0: elem1 less than elem2 <br> *= 0: elem1 equivalent to elem2 <br> *&gt; 0: elem1 greater than elem2 <br> */ <br>int __cdecl <br>CompareShareNamesQSortCallback(const void *elem1, const void *elem2) <br>{ <br>return CompareShareNames(((SHARE_INFO_2 *)elem1)-&gt;shi2_netname, <br>((SHARE_INFO_2 *)elem2)-&gt;shi2_netname); <br>} <br> <br>int __cdecl <br>CompareUserNamesQSortCallback(const void *elem1, const void *elem2) <br>{ <br>return lstrcmp(((CONNECTION_INFO_1 *)elem1)-&gt;coni1_username, <br>((CONNECTION_INFO_1 *)elem2)-&gt;coni1_username); <br>} <br> <br>int __cdecl <br>CompareFileNamesQSortCallback(const void *elem1, const void *elem2) <br>{ <br>return lstrcmp(((FILE_INFO_3 *)elem1)-&gt;fi3_pathname, <br>((FILE_INFO_3 *)elem2)-&gt;fi3_pathname); <br>} <br> <br>/* <br> *Enumeration routines <br> */ <br> <br>/* <br> *FilesEnum <br> * <br> *Purpose: <br> *Enumerate the open files on a sharepath, username, and server <br> * <br> *Arguments: <br> *all kinds of stuff <br> * <br> *Returns: <br> *nas <br> */ <br>NET_API_STATUS <br>FilesEnum(HWND hwndTV, HTREEITEM hParent, LPTSTR szServerName, TCHAR *username, <br>TCHAR *sharepath, TVDATAUSER *pTVDataUser) <br>{ <br>NET_API_STATUSnas; <br>TV_INSERTSTRUCTtvis; <br>FILE_INFO_3*pfi3; <br>FILE_INFO_3*fi3 = NULL; <br>DWORDdwentriesread; <br>DWORDdwtotalentries; <br>TCHAR*psharepathend; <br> <br>// Some stuff doesn't change <br>tvis.hInsertAfter = NULL; <br>tvis.hParent = hParent; <br>tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM; <br> <br>// Reasoning: if you are passed c:\ as a sharepath, sometimes c: is opened <br>// as execute. But since we would be qualifying paths on c:\, it won't show <br>// c: as being open.  So - remove the last \ if it's there. <br>if(sharepath &amp;&amp; sharepath[0]) <br>{ <br>psharepathend = sharepath + lstrlen(sharepath) - 1; <br>if(*psharepathend == TEXT('\\')) <br>*psharepathend = '\0'; <br>} <br> <br>nas = NetFileEnum(szServerName, sharepath, username, 3, <br>(LPBYTE *)&amp;fi3, MAX_PREFERRED_LENGTH,  <br>&amp;dwentriesread, &amp;dwtotalentries, NULL); <br>if(nas || !dwentriesread) <br>goto err; <br> <br>qsort(fi3, dwentriesread, sizeof(fi3[0]), CompareFileNamesQSortCallback); <br>for(pfi3 = fi3; dwentriesread; pfi3++, dwentriesread--) <br>{ <br>TVDATAFILE*pTVDataFile; <br>UINTnBitmap = BMP_READ; <br> <br>// And our bmp is... <br>if((pfi3-&gt;fi3_permissions &amp; PERM_FILE_WRITE) || <br>(pfi3-&gt;fi3_permissions &amp; PERM_FILE_CREATE)) <br>nBitmap = BMP_WRITE; <br> <br>// Things to remember for properties, delete, etc. <br>if(pTVDataFile = (TVDATAFILE *)GlobalAllocPtr(GHND, sizeof(TVDATAFILE))) <br>{ <br>pTVDataFile-&gt;dwType = TYPE_FILE; <br>pTVDataFile-&gt;dwFileId = pfi3-&gt;fi3_id; <br>pTVDataFile-&gt;pTVDataUser = pTVDataUser; <br>} <br> <br>// Insert that baby <br>tvis.item.lParam = (LPARAM)pTVDataFile; <br>tvis.item.pszText = pfi3-&gt;fi3_pathname; <br>tvis.item.iImage = tvis.item.iSelectedImage = nBitmap; <br>TreeView_TVDataInsert(hwndTV, &amp;tvis); <br>} <br> <br>err: <br>// Whack any stragglers hanging at the end <br>FTreeView_DeleteRange(hwndTV, hParent, tvis.hInsertAfter, NULL); <br> <br>NetApiBufferFree(fi3); <br>if(nas) <br>AddErrorStringToTV(hwndTV, hParent, IDS_ERRENUMFILES, nas); <br>return nas; <br>} <br> <br>/* <br> *UsersEnum <br> * <br> *Purpose: <br> *Enumerate the users on a sharepath and server <br> * <br> *Arguments: <br> *lots o garbage <br> * <br> *Returns: <br> *nas <br> */ <br>NET_API_STATUS <br>UsersEnum(HWND hwndTV, HTREEITEM hParent, LPTSTR szServerName, TCHAR *sharename, <br>TCHAR *sharepath, TVDATASHARE *pTVDataShare) <br>{ <br>NET_API_STATUSnas; <br>TV_INSERTSTRUCTtvis; <br>HTREEITEMhItem; <br>CONNECTION_INFO_1*pci1; <br>CONNECTION_INFO_1*ci1 = NULL; <br>DWORDdwentriesread; <br>DWORDdwtotalentries; <br>static TCHARszFmtUser[cchSzMax + 1]; <br>TCHARszUserT[NNLEN + UNLEN + cchSzMax + 1]; <br> <br>// Some stuff doesn't change <br>tvis.hInsertAfter = NULL; <br>tvis.hParent = hParent; <br>tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM; <br> <br>if(!szFmtUser[0]) <br>lstrcpy(szFmtUser, szFromIDS1(IDS_FMTUSER)); <br> <br>nas = NetConnectionEnum(szServerName, sharename, 1, (LPBYTE *)&amp;ci1, <br>MAX_PREFERRED_LENGTH, &amp;dwentriesread, &amp;dwtotalentries, NULL); <br>if(nas || !dwentriesread) <br>goto err; <br> <br>qsort(ci1, dwentriesread, sizeof(ci1[0]), CompareUserNamesQSortCallback); <br>for(pci1 = ci1; dwentriesread; pci1++, dwentriesread--) <br>{ <br>TCHAR*netname; <br>TCHAR*username; <br>TVDATAUSER*pTVDataUser; <br> <br>username = pci1-&gt;coni1_username; <br>netname = pci1-&gt;coni1_netname; <br>if(!username || !username[0]) <br>username = szNil; <br>else <br>CharLower(username); <br>if(!netname || !netname[0]) <br>netname = szNil; <br>else <br>CharUpper(netname); <br> <br>if(lstrlen(netname) &gt; CNLEN) <br>netname[CNLEN] = 0; <br>if(lstrlen(username) &gt; UNLEN) <br>username[UNLEN] = 0; <br> <br>wsprintf(szUserT, szFmtUser, username, netname); <br> <br>// Things to remember for properties, delete, etc. <br>if(pTVDataUser = (TVDATAUSER *)GlobalAllocPtr(GHND, sizeof(TVDATAUSER))) <br>{ <br>pTVDataUser-&gt;dwType = TYPE_USER; <br>lstrcpy(pTVDataUser-&gt;szUserName, username); <br>pTVDataUser-&gt;szNetName[0] = pTVDataUser-&gt;szNetName[1] = '\\'; <br>lstrcpy(&amp;pTVDataUser-&gt;szNetName[2], netname); <br>pTVDataUser-&gt;pTVDataShare = pTVDataShare; <br>} <br> <br>tvis.item.lParam = (LPARAM)pTVDataUser; <br>tvis.item.pszText = szUserT; <br>tvis.item.iImage = tvis.item.iSelectedImage = BMP_USER; <br>hItem = TreeView_TVDataInsert(hwndTV, &amp;tvis); <br> <br>// If we haven't run into any errors and the user wants to see files <br>if(pci1-&gt;coni1_num_opens &amp;&amp; <br>unMenuFlags[IDM_SHOWFILES &amp; 0xff] == MF_CHECKED &amp;&amp; !nas) <br>{ <br>// Enum the files <br>nas = FilesEnum(hwndTV, hItem, szServerName, username, <br>sharepath, pTVDataUser); <br>// make sure we're expanded <br>TreeView_Expand(hwndTV, hItem, TVE_EXPAND); <br>} <br>else <br>{ <br>// Delete all our children <br>FTreeView_DeleteRange(hwndTV, hItem, NULL, NULL); <br>} <br>} <br> <br>// reset any filesenum errors we may have encountered <br>nas = 0; <br> <br>err: <br>// Whack any stragglers hanging at the end <br>FTreeView_DeleteRange(hwndTV, hParent, tvis.hInsertAfter, NULL); <br> <br>NetApiBufferFree(ci1); <br>if(nas) <br>AddErrorStringToTV(hwndTV, hParent, IDS_ERRENUMUSERS, nas); <br>return nas; <br>} <br> <br>/* <br> *SharesEnum <br> * <br> *Purpose: <br> *Enumerate the shares on a server <br> * <br> *Arguments: <br> *server to enum <br> * <br> *Returns: <br> *nas <br> */ <br>#define offsetof(s, m)  (size_t)&amp;(((s *)0)-&gt;m) <br>#define shoffset(l, m)  (offsetof(SHARE_INFO_##l, m)) <br>NET_API_STATUS <br>SharesEnum(HWND hwndTV, HTREEITEM hParent, LPTSTR szServerName, UINT *pcUsers, <br>INT nLevel) <br>{ <br>NET_API_STATUSnas; <br>TV_INSERTSTRUCTtvis; <br>HTREEITEMhItem; <br>SHARE_INFO_2*pshi2; <br>UINTcbStruct; <br>SHARE_INFO_2*shi2 = NULL; <br>DWORDdwentriesread; <br>DWORDdwtotalentries; <br>SCONST TCHARszEndSep[] = TEXT(")"); <br>SCONST TCHARszBegSep[] = TEXT(" ("); <br>// +3 for the begsep and endsep <br>TCHARszShareT[NNLEN + MAXCOMMENTSZ + 3 + 1]; <br> <br>Assert(nLevel == 1 || nLevel == 2); <br>// We assume the first three parts of these structs are the same. Make sure. <br>// Using cbStruct here cause the compiler loses the entire line if I don't? <br>Assert((cbStruct = shoffset(1, shi1_netname)) == shoffset(2, shi2_netname)); <br>Assert((cbStruct = shoffset(1, shi1_type)) == shoffset(2, shi2_type)); <br>Assert((cbStruct = shoffset(1, shi1_remark)) == shoffset(2, shi2_remark)); <br> <br>cbStruct = nLevel == 2 ? sizeof(SHARE_INFO_2) : sizeof(SHARE_INFO_1); <br>// WARNING: don't use the following members of shi2 without checking nLevel! <br>//shi2_permissions; <br>//shi2_max_uses; <br>//shi2_current_uses <br>//shi2_path; <br>//shi2_passwd; <br> <br>// Some stuff doesn't change <br>tvis.hInsertAfter = NULL; <br>tvis.hParent = hParent; <br>tvis.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM; <br> <br>nas = NetShareEnum(szServerName, nLevel, (LPBYTE *)&amp;shi2, <br>MAX_PREFERRED_LENGTH, &amp;dwentriesread, &amp;dwtotalentries, NULL); <br>if(nas || !dwentriesread) <br>goto err; <br> <br>// Sort the shares and then cruise through adding em all to the TV <br>qsort(shi2, dwentriesread, cbStruct, CompareShareNamesQSortCallback); <br>for(pshi2 = shi2; dwentriesread; ((LPBYTE)pshi2) += cbStruct, dwentriesread--) <br>{ <br>TCHAR*sharename; <br>TCHAR*shareremark; <br>UINTnCurrentUses; <br>TVDATASHARE*pTVDataShare; <br> <br>sharename = pshi2-&gt;shi2_netname; <br>shareremark = pshi2-&gt;shi2_remark; <br>nCurrentUses = (nLevel == 2) ? pshi2-&gt;shi2_current_uses : 0; <br> <br>if(!sharename) <br>continue; <br>if(!shareremark) <br>shareremark = szNil; <br> <br>if(lstrlen(sharename) &gt; NNLEN) <br>sharename[NNLEN] = 0; <br>if(lstrlen(shareremark) &gt; MAXCOMMENTSZ) <br>shareremark[MAXCOMMENTSZ] = 0; <br> <br>// skip hidden shares <br>if((unMenuFlags[IDM_SHOWHIDDEN &amp; 0xff] == MF_UNCHECKED) &amp;&amp; <br>FIsShareHidden(sharename)) <br>continue; <br> <br>// Keep a running total <br>*pcUsers += nCurrentUses; <br> <br>// If we have any users connected or the onlyshowinuse isn't checked <br>if(nCurrentUses || (unMenuFlags[IDM_SHOWINUSE &amp; 0xff] != MF_CHECKED)) <br>{ <br>int nBitmap = ((pshi2-&gt;shi2_type &amp; 0xf) == STYPE_IPC) ? <br>BMP_IPC : BMP_SHARE; <br> <br>// Copy over the share name and comment <br>lstrcpy(szShareT, sharename); <br>if(shareremark[0]) <br>{ <br>lstrcat(szShareT, szBegSep); <br>lstrcat(szShareT, shareremark); <br>lstrcat(szShareT, szEndSep); <br>} <br> <br>// Things to remember for properties, delete, etc. <br>if(pTVDataShare = (TVDATASHARE *)GlobalAllocPtr(GHND, <br>sizeof(TVDATASHARE))) <br>{ <br>pTVDataShare-&gt;dwType = TYPE_SHARE; <br>pTVDataShare-&gt;dwShareType = pshi2-&gt;shi2_type; <br>lstrcpy(pTVDataShare-&gt;szShareName, sharename); <br>lstrcpy(pTVDataShare-&gt;szServerName, szServerName); <br>} <br> <br>tvis.item.lParam = (LPARAM)pTVDataShare; <br>tvis.item.pszText = szShareT; <br>tvis.item.iImage = tvis.item.iSelectedImage = nBitmap; <br>hItem = TreeView_TVDataInsert(hwndTV, &amp;tvis); <br> <br>// If we previously got an error enuming users, don't waste our time <br>// trying again. <br>if(!nas &amp;&amp; nCurrentUses) <br>{ <br>Assert(nLevel == 2); <br>nas = UsersEnum(hwndTV, hItem, szServerName, <br>sharename, pshi2-&gt;shi2_path, pTVDataShare); <br>// Make sure we're showing it all <br>TreeView_Expand(hwndTV, hItem, TVE_EXPAND); <br>} <br>else <br>{ <br>// Delete all our children <br>FTreeView_DeleteRange(hwndTV, hItem, NULL, NULL); <br>} <br>} <br>} <br> <br>// reset any errors UsersEnum may have trickled up <br>nas = 0; <br> <br>err: <br>// Whack any stragglers hanging at the end <br>FTreeView_DeleteRange(hwndTV, hParent, tvis.hInsertAfter, NULL); <br> <br>if(nas) <br>AddErrorStringToTV(hwndTV, hParent, IDS_ERRENUMSHARES, nas); <br>NetApiBufferFree(shi2); <br>return nas; <br>} <br> <br>/* <br> *RefreshDisplay <br> * <br> *Purpose: <br> *Update the treeview with piping hot info <br> * <br> *Arguments: <br> *main hwnd <br> * <br> *Returns: <br> *Count of uses connected to shares <br> */ <br>UINT <br>RefreshDisplay(HWND hwnd, HWND hwndTV) <br>{ <br>HTREEITEMhItem; <br>HCURSORhCursor; <br>UINTcUsers = 0; <br>static UINTcRefreshes = 0; <br> <br>// Turn off the timer <br>PunchTimer(hwnd, FALSE); <br>OutputDbgStr("RefreshDisplay (%d): 0x%08lx", cRefreshes, GetTickCount()); <br> <br>// This may take a while <br>hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>// Enumerate all the shares <br>hItem = TreeView_GetRoot(hwndTV); <br>while(hItem) <br>{ <br>TV_ITEMtvItem; <br>HTREEITEMhItemChild; <br>TCHARszT[UNCLEN + 1]; <br> <br>// Check to see if the first child is an error <br>if((cRefreshes % 4) &amp;&amp; (hItemChild = TreeView_GetChild(hwndTV, hItem))) <br>{ <br>// If it is, only update it 1 out of 4 times <br>tvItem.mask = TVIF_PARAM; <br>tvItem.hItem = hItemChild; <br>if(TreeView_GetItem(hwndTV, &amp;tvItem) &amp;&amp; tvItem.lParam == TYPE_ERROR) <br>{ <br>OutputDbgStr("Skipping errored out server"); <br>goto nextserver; <br>} <br>} <br> <br>// Get the server name and server image <br>tvItem.mask = TVIF_TEXT | TVIF_IMAGE; <br>tvItem.hItem = hItem; <br>tvItem.pszText = szT; <br>tvItem.cchTextMax = UNCLEN + 1; <br>if(TreeView_GetItem(hwndTV, &amp;tvItem) &amp;&amp; (szT[0] == '\\')) <br>{ <br>// Enumerate all the shares under here <br>SharesEnum(hwndTV, hItem, szT, &amp;cUsers, <br>tvItem.iImage == BMP_COMPUTER ? 2 : 1); <br>// Make sure we're showing it all <br>TreeView_Expand(hwndTV, hItem, TVE_EXPAND); <br>} <br> <br>// Next server <br>nextserver: <br>hItem = TreeView_GetNextSibling(hwndTV, hItem); <br>} <br> <br>// Bring back our arrow <br>SetCursor(hCursor); <br> <br>// Swing the selection back into view <br>if(hItem = TreeView_GetSelection(hwndTV)) <br>TreeView_EnsureVisible(hwndTV, hItem); <br> <br>// Resume the timer again <br>PunchTimer(hwnd, TRUE); <br> <br>// Update our number of refreshes and return the count of users <br>cRefreshes++; <br>return cUsers; <br>} <br> <br>/* <br> *Properties <br> */ <br> <br>/* <br> *DisplayComputerDetails <br> * <br> *Purpose: <br> *Delete/Show property page for computer <br> * <br> *Arguments: <br> *hwnd, wAction <br> * <br> *Returns: <br> *nas <br> */ <br>NET_API_STATUS <br>DisplayComputerDetails(HWND hwnd, TVDATA *pTVData, WORD wAction) <br>{ <br>HTREEITEMhItem; <br>HWNDhwndTV; <br>NET_API_STATUSnas = 0; <br>SERVER_INFO_102*si102 = NULL; <br> <br>if(!(hwndTV = GetDlgItem(hwnd, IDD_tvwSHARES))) <br>return 0; <br> <br>if(!(hItem = TreeView_GetSelection(hwndTV))) <br>return 0; <br> <br>if(wAction == VK_DELETE) <br>{ <br>TreeView_DeleteItem(hwndTV, hItem); <br>} <br>else <br>{ <br>TV_ITEMtvItem; <br>HCURSORhCursor; <br>TCHARszT[UNCLEN + 1]; <br>TCHARszVer[cchSzMax + 1]; <br> <br>szT[0] = 0; <br>tvItem.mask = TVIF_TEXT; <br>tvItem.hItem = hItem; <br>tvItem.pszText = szT; <br>tvItem.cchTextMax = UNCLEN + 1; <br>TreeView_GetItem(hwndTV, &amp;tvItem); <br> <br>hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>nas = NetServerGetInfo(szT, 102, (LPBYTE *)&amp;si102); <br>SetCursor(hCursor); <br>if(nas || !si102) <br>goto err; <br> <br>wsprintf(szVer, TEXT("%d.%d"), <br>si102-&gt;sv102_version_major &amp; MAJOR_VERSION_MASK, <br>si102-&gt;sv102_version_minor); <br> <br>PropertyDlg(hwnd, <br>IDS_SERVERPROPS, <br>0xfffffff1, <br>si102-&gt;sv102_name, <br>si102-&gt;sv102_comment, <br>si102-&gt;sv102_userpath, <br>szVer, <br>szFromIDS1(IDS_HIDDEN + !!si102-&gt;sv102_hidden), <br>NULL); <br>} <br> <br>err: <br>NetApiBufferFree(si102); <br>return nas; <br>} <br> <br>/* <br> *DisplayShareDetails <br> * <br> *Purpose: <br> *Delete/Show property page for shares <br> * <br> *Arguments: <br> *hwnd, pTVDataShare, wAction <br> * <br> *Returns: <br> *nas <br> */ <br>NET_API_STATUS <br>DisplayShareDetails(HWND hwnd, TVDATA *pTVData, WORD wAction) <br>{ <br>NET_API_STATUSnas; <br>HCURSORhCursor; <br>SHARE_INFO_2*shi2 = NULL; <br>TVDATASHARE*pTVDataShare = (TVDATASHARE *)pTVData; <br> <br>hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>nas = NetShareGetInfo(pTVDataShare-&gt;szServerName, pTVDataShare-&gt;szShareName, <br>2, (LPBYTE *)&amp;shi2); <br>SetCursor(hCursor); <br>if(!nas &amp;&amp; shi2) <br>{ <br>if(wAction == VK_DELETE) <br>{ <br>// if no one is connected, nuke it, else confirm with user <br>if(!(shi2-&gt;shi2_current_uses) || <br>(MessageBox(hwnd, szFromIDS1(IDS_AREYOUSURE + TYPE_SHARE),  <br>szAppName, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) ==  <br>IDYES)) <br>{ <br>nas = NetShareDel(pTVDataShare-&gt;szServerName, <br>pTVDataShare-&gt;szShareName, 0); <br>} <br>} <br>else <br>{ <br>TCHARszMaxUses[11]; <br>TCHARszMaxCurrent[11]; <br> <br>wsprintf(szMaxUses, szFmtNum, shi2-&gt;shi2_max_uses); <br>wsprintf(szMaxCurrent, szFmtNum, shi2-&gt;shi2_current_uses); <br> <br>PropertyDlg(hwnd, <br>IDS_SHAREPROPS, <br>((shi2-&gt;shi2_type &amp; 0xf) == STYPE_IPC) ? 0xfffffff8 : 0xfffffff0, <br>shi2-&gt;shi2_netname, <br>shi2-&gt;shi2_path, <br>shi2-&gt;shi2_remark, <br>(shi2-&gt;shi2_max_uses == SHI_USES_UNLIMITED) ?  <br>szFromIDS1(IDS_NOLIMIT) : szMaxUses, <br>szMaxCurrent, <br>NULL); <br>} <br>} <br> <br>NetApiBufferFree(shi2); <br>return nas; <br>} <br> <br>/* <br> *DisplayFileDetails <br> * <br> *Purpose: <br> *Delete/Show property page for files <br> * <br> *Arguments: <br> *hwnd, pTVDataFile, wAction <br> * <br> *Returns: <br> *nas <br> */ <br>NET_API_STATUS <br>DisplayFileDetails(HWND hwnd, TVDATA *pTVData, WORD wAction) <br>{ <br>NET_API_STATUSnas; <br>HCURSORhCursor; <br>FILE_INFO_3*fi3 = NULL; <br>TCHAR*szServerName;   <br>TVDATAFILE*pTVDataFile = (TVDATAFILE *)pTVData; <br> <br>hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>szServerName = pTVDataFile-&gt;pTVDataUser-&gt;pTVDataShare-&gt;szServerName; <br>nas = NetFileGetInfo(szServerName, pTVDataFile-&gt;dwFileId, 3, (LPBYTE *)&amp;fi3); <br>SetCursor(hCursor); <br>if(!nas &amp;&amp; fi3) <br>{ <br>if(wAction == VK_DELETE) <br>{ <br>TCHARszMsg[cchMsgMax]; <br> <br>wsprintf(szMsg, szFromIDS1(IDS_AREYOUSURE + TYPE_FILE), <br>pTVDataFile-&gt;pTVDataUser-&gt;szUserName, fi3-&gt;fi3_pathname); <br>if(MessageBox(hwnd, szMsg, szAppName, <br>MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) == IDYES) <br>{ <br>nas = NetFileClose(szServerName, pTVDataFile-&gt;dwFileId); <br>} <br>} <br>else <br>{ <br>TCHARszNumLocks[11]; <br>UINTnBitmap = BMP_READ; <br> <br>if((fi3-&gt;fi3_permissions &amp; PERM_FILE_WRITE) || <br>(fi3-&gt;fi3_permissions &amp; PERM_FILE_CREATE)) <br>nBitmap = BMP_WRITE; <br> <br>wsprintf(szNumLocks, szFmtNum, fi3-&gt;fi3_num_locks); <br> <br>PropertyDlg(hwnd, <br>IDS_FILEPROPS, <br>0xfffff072 | (nBitmap &lt;&lt; 8), <br>fi3-&gt;fi3_pathname, <br>fi3-&gt;fi3_username, <br>szFromIDS1(IDS_FILEPROPS + 10 + nBitmap), <br>szNumLocks, <br>NULL, <br>NULL); <br>} <br>} <br> <br>NetApiBufferFree(fi3); <br>return nas; <br>} <br> <br>/* <br> *DisplayUserDetails <br> * <br> *Purpose: <br> *Delete/Show property page for users <br> * <br> *Arguments: <br> *hwnd, pTVDataUser, wAction <br> * <br> *Returns: <br> *nas <br> */ <br>NET_API_STATUS <br>DisplayUserDetails(HWND hwnd, TVDATA *pTVData, WORD wAction) <br>{ <br>NET_API_STATUSnas; <br>time_ttm_t; <br>TCHAR*szServerName; <br>SESSION_INFO_2*sesi2 = NULL; <br>TCHARszUserName[UNLEN + cchSzMax + 1]; <br>TVDATAUSER*pTVDataUser = (TVDATAUSER *)pTVData; <br> <br>szServerName = pTVDataUser-&gt;pTVDataShare-&gt;szServerName; <br>nas = NetSessionGetInfo(szServerName, pTVDataUser-&gt;szNetName, <br>pTVDataUser-&gt;szUserName, 2, (LPBYTE *)&amp;sesi2); <br>if(!nas &amp;&amp; sesi2) <br>{ <br>if(wAction == VK_DELETE) <br>{ <br>UINTids; <br>TCHARszMsg[cchMsgMax]; <br> <br>// if user has open files, tell the del happy person this <br>// otherwise just reaffirm that they wanna hack em. <br>ids = sesi2-&gt;sesi2_num_opens ? <br>IDS_AREYOUSURE + TYPE_USER : IDS_AREYOUSUREDISUSER; <br>wsprintf(szMsg, szFromIDS1(ids), pTVDataUser-&gt;szUserName); <br>if(MessageBox(hwnd, szMsg, szAppName, <br>MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) == IDYES) <br>{ <br>nas = NetSessionDel(szServerName, pTVDataUser-&gt;szNetName, <br>pTVDataUser-&gt;szUserName); <br>} <br>} <br>else <br>{ <br>TCHARszNumOpens[11]; <br>TCHARszIdleTime[cchSzMax]; <br>TCHARszConnectTime[cchSzMax]; <br>SCONST TCHAR szSpace[] = TEXT(" "); <br> <br>lstrcpy(szUserName, pTVDataUser-&gt;szUserName); <br>if(sesi2-&gt;sesi2_user_flags &amp; SESS_GUEST) <br>lstrcat(szUserName, szFromIDS1(IDS_GUEST)); <br> <br>time(&amp;tm_t); <br>PutTime(tm_t - sesi2-&gt;sesi2_time, szIdleTime, cchSzMax); <br>PutDate(tm_t - sesi2-&gt;sesi2_time, szConnectTime, cchSzMax); <br>lstrcat(szConnectTime, szSpace); <br>lstrcat(szConnectTime, szIdleTime); <br> <br>wsprintf(szNumOpens, szFmtNum, sesi2-&gt;sesi2_num_opens); <br> <br>PropertyDlg(hwnd, <br>IDS_USERPROPS, <br>pTVDataUser-&gt;pTVDataShare-&gt;dwShareType == STYPE_IPC ? <br>0xfffff817 : 0xfffff017, <br>szUserName, <br>pTVDataUser-&gt;szNetName,  <br>pTVDataUser-&gt;pTVDataShare-&gt;szShareName, <br>szConnectTime, <br>PutCounterTime(sesi2-&gt;sesi2_idle_time, szIdleTime, cchSzMax), <br>szNumOpens); <br>} <br>} <br> <br>if(!nas &amp;&amp; !sesi2) <br>nas = ERROR_NOT_CONNECTED; <br>NetApiBufferFree(sesi2); <br>return nas; <br>} <br> <br>/* <br> *Nifty little array of property functions <br> */ <br>typedef NET_API_STATUS (*PFNDISPLAYDETAILS)(HWND hwnd, TVDATA *pTVData, WORD wAction); <br>SCONST PFNDISPLAYDETAILS pfnDisplayDetails[TYPE_MAX] = <br>{ <br>DisplayComputerDetails, <br>DisplayShareDetails, <br>DisplayUserDetails, <br>DisplayFileDetails <br>}; <br> <br>/* <br> *HandleWM_VKEY <br> * <br> *Purpose: <br> *handle WM_VKEYS: VK_DELETE and VK_RETURN <br> * <br> *Arguments: <br> *main hwnd and wAction <br> * <br> *Returns: <br> *TRUE - success, FALSE - error <br> */ <br>BOOL <br>HandleWM_VKEY(HWND hwnd, HWND hwndTV, WORD wAction) <br>{ <br>NET_API_STATUSnas = 0; <br>TVDATA*pTVData; <br>DWORDdwType = TYPE_COMPUTER; <br> <br>OutputDbgStr("HandleWM_VKEY"); <br>// Only handle return and delete keys <br>if((wAction != VK_RETURN) &amp;&amp; (wAction != VK_DELETE)) <br>return FALSE; <br> <br>// Get the Selected item data <br>pTVData = (TVDATA *)TreeView_GetSelectedItemData(hwndTV, &amp;dwType); <br> <br>// Ok, do the order <br>PunchTimer(hwnd, FALSE); <br> <br>// jump to the display page <br>if(dwType &lt; TYPE_MAX) <br>nas = (pfnDisplayDetails[dwType])(hwnd, pTVData, wAction); <br> <br>// Report any errors <br>if(nas) <br>{ <br>TCHARszMsg[cchErrMax]; <br>TCHAR*szErrMessage = NULL; <br> <br>lstrcpy(szMsg, szFromIDS1(IDS_ERRACTION)); <br>if(szErrMessage = GetSystemErrMessage(nas)) <br>lstrcat(szMsg, szErrMessage); <br> <br>MessageBox(hwnd, szMsg, szAppName, MB_ICONEXCLAMATION); <br>GlobalFreeNullPtr(szErrMessage); <br>} <br> <br>// If we hit an error or they whacked something, update now <br>if(nas || (wAction == VK_DELETE)) <br>PostMessage(hwnd, WM_TIMER, 0, 0L); <br>else <br>PunchTimer(hwnd, TRUE); <br> <br>return TRUE; <br>} <br> <br>/* <br> *AddErrorStringToTV <br> * <br> *Purpose: <br> *Slap an error string in the TV <br> * <br> *Arguments: <br> *hParent, ids of error, nas of error <br> * <br> *Returns: <br> *nada <br> */ <br>VOID <br>AddErrorStringToTV(HWND hwndTV, HTREEITEM hParent, UINT ids, NET_API_STATUS nas) <br>{ <br>TV_INSERTSTRUCTtvis; <br>TCHAR*szErrMessage; <br>SCONST TCHARszSep[] = TEXT(": "); <br>TCHARszErrBuf[cchErrMax]; </code></pre>
<p>
</p>
<pre><code><br>// Get the text <br>lstrcpy(szErrBuf, szFromIDS1(ids)); <br>if(szErrMessage = GetSystemErrMessage(nas)) <br>{ <br>lstrcat(szErrBuf, szSep); <br>lstrcat(szErrBuf, szErrMessage); <br>LocalFree((HLOCAL)szErrMessage); <br>} <br> <br>// Add the error string <br>tvis.hParent = hParent; <br>tvis.item.mask = TVIF_PARAM | TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE; <br>tvis.hInsertAfter = NULL; <br>tvis.item.pszText = szErrBuf; <br>tvis.item.iImage = tvis.item.iSelectedImage = BMP_DENIED; <br>tvis.item.lParam = (LPARAM)TYPE_ERROR; <br>TreeView_TVDataInsert(hwndTV, &amp;tvis); <br> <br>// Delete all other children <br>FTreeView_DeleteRange(hwndTV, hParent, tvis.hInsertAfter, NULL); <br>} <br> <br>/* <br> *FAnyRemoteDrives <br> * <br> *Purpose: <br> *Checks if there are any remote drives connected <br> * <br> *Arguments: <br> *zip <br> * <br> *Returns: <br> *Returns TRUE if there are <br> */ <br>BOOL <br>FAnyRemoteDrives() <br>{ <br>INTch; <br>UINTerrmode; <br>TCHARszRoot[4]; <br>BOOLfRet = FALSE; <br> <br>errmode = SetErrorMode(SEM_FAILCRITICALERRORS); <br> <br>szRoot[1] = ':'; <br>szRoot[2] = '\\'; <br>szRoot[3] = 0; <br>for (ch = 'C'; ch &lt;= 'Z'; ch++) <br>{ <br>szRoot[0] = ch; <br>if(GetDriveType(szRoot) == DRIVE_REMOTE) <br>{ <br>fRet = TRUE; <br>break; <br>} <br>} <br> <br>SetErrorMode(errmode); <br>return fRet; <br>} <br> <br>/* <br> *HandleMenu <br> * <br> *Purpose: <br> *Disable\Enable\Change menu according to what is selected <br> * <br> *Arguments: <br> *hwnd <br> * <br> *Returns: <br> *zip <br> */ <br>VOID <br>HandleMenu(HWND hwnd, HWND hwndTV, HMENU hMenu) <br>{ <br>DWORDdwType = TYPE_COMPUTER; <br> <br>TreeView_GetSelectedItemData(hwndTV, &amp;dwType); <br>OutputDbgStr("Item type %d selected", dwType); <br> <br>// Enable/disable the disconnect network drive menu item <br>if(hMenu == ghMenu) <br>{ <br>EnableMenuItem(hMenu, IDM_DISCONNECTDRIVE, FAnyRemoteDrives() ? <br>MF_BYCOMMAND | MF_ENABLED : MF_BYCOMMAND | MF_GRAYED); <br>} <br> <br>if(dwType == TYPE_ERROR) <br>{ <br>EnableMenuItem(hMenu, IDM_DELETERESOURCE, MF_BYCOMMAND | MF_GRAYED); <br>EnableMenuItem(hMenu, IDM_PROPERTIES, MF_BYCOMMAND | MF_GRAYED); <br>} <br>else <br>{ <br>EnableMenuItem(hMenu, IDM_PROPERTIES, MF_BYCOMMAND | MF_ENABLED); <br>ModifyMenu(hMenu, IDM_DELETERESOURCE, MF_BYCOMMAND | MF_STRING, <br>IDM_DELETERESOURCE, szFromIDS1(IDS_DELETERESOURCE + dwType)); <br>} <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
