<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFDATA.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5722"></a>PERFDATA.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>/****************************************************************************** <br> <br>                        P E R F O R M A N C E   D A T A <br> <br>    Name:       perfdata.c <br> <br>    Description: <br>        This module together with objdata.c, instdata.c, and cntrdata.c <br>        access the performance data. <br> <br>******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winperf.h&gt; <br>#include "perfdata.h" <br>#include &lt;stdlib.h&gt; <br> <br> <br> <br> <br>LPTSTR      *gPerfTitleSz; <br>LPTSTR      TitleData; <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//  GetPerfData <br>// <br>//      Get a new set of performance data. <br>// <br>//      *ppData should be NULL initially. <br>//      This function will allocate a buffer big enough to hold the <br>//      data requested by szObjectIndex. <br>// <br>//      *pDataSize specifies the initial buffer size.  If the size is <br>//      too small, the function will increase it until it is big enough <br>//      then return the size through *pDataSize.  Caller should <br>//      deallocate *ppData if it is no longer being used. <br>// <br>//      Returns ERROR_SUCCESS if no error occurs. <br>// <br>//      Note: the trial and error loop is quite different from the normal <br>//            registry operation.  Normally if the buffer is too small, <br>//            RegQueryValueEx returns the required size.  In this case, <br>//            the perflib, since the data is dynamic, a buffer big enough <br>//            for the moment may not be enough for the next. Therefor, <br>//            the required size is not returned. <br>// <br>//            One should start with a resonable size to avoid the overhead <br>//            of reallocation of memory. <br>// <br>DWORD   GetPerfData    (HKEY        hPerfKey, <br>                        LPTSTR      szObjectIndex, <br>                        PPERF_DATA  *ppData, <br>                        DWORD       *pDataSize) <br>{ <br>DWORD   DataSize; <br>DWORD   dwR; <br>DWORD   Type; <br> <br> <br>    if (!*ppData) <br>        *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize); <br> <br> <br>    do  { <br>        DataSize = *pDataSize; <br>        dwR = RegQueryValueEx (hPerfKey, <br>                               szObjectIndex, <br>                               NULL, <br>                               &amp;Type, <br>                               (BYTE *)*ppData, <br>                               &amp;DataSize); <br> <br>        if (dwR == ERROR_MORE_DATA) <br>            { <br>            LocalFree (*ppData); <br>            *pDataSize += 1024; <br>            *ppData = (PPERF_DATA) LocalAlloc (LMEM_FIXED, *pDataSize); <br>            } <br> <br>        if (!*ppData) <br>            { <br>            LocalFree (*ppData); <br>            return ERROR_NOT_ENOUGH_MEMORY; <br>            } <br> <br>        } while (dwR == ERROR_MORE_DATA); <br> <br>    return dwR; <br>} <br> <br> <br> <br> <br>#ifdef UNICODE <br> <br>#define atoi    atoiW <br> <br> <br>//********************************************************************* <br>// <br>//  atoiW <br>// <br>//      Unicode version of atoi. <br>// <br>INT atoiW (LPTSTR s) <br>{ <br>INT i = 0; <br> <br> while (iswdigit (*s)) <br>        { <br>  i = i*10 + (BYTE)*s - L'0'; <br>        s++; <br>        } <br> <br>    return i; <br>} <br> <br>#endif <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//  GetPerfTitleSz <br>// <br>//      Retrieves the performance data title strings. <br>// <br>//   This call retrieves english version of the title strings. <br>// <br>//   For NT 3.1, the counter names are stored in the "Counters" value <br>//   in the ...\perflib\009 key.  For 3.5 and later, the 009 key is no <br>//      longer used.  The counter names should be retrieved from "Counter 009" <br>//      value of HKEY_PERFORMANCE_KEY. <br>// <br>//      Caller should provide two pointers, one for buffering the title <br>//      strings the other for indexing the title strings.  This function will <br>//      allocate memory for the TitleBuffer and TitleSz.  To get the title <br>//      string for a particular title index one would just index the TitleSz. <br>//      *TitleLastIdx returns the highest index can be used.  If TitleSz[N] is <br>//      NULL then there is no Title for index N. <br>// <br>//      Example:  TitleSz[20] points to titile string for title index 20. <br>// <br>//      When done with the TitleSz, caller should LocalFree(*TitleBuffer). <br>// <br>//      This function returns ERROR_SUCCESS if no error. <br>// <br>DWORD   GetPerfTitleSz (HKEY    hKeyMachine, <br>                        HKEY    hKeyPerf, <br>                        LPTSTR  *TitleBuffer, <br>                        LPTSTR  *TitleSz[], <br>                        DWORD   *TitleLastIdx) <br>{ <br>HKEY  hKey1; <br>HKEY    hKey2; <br>DWORD   Type; <br>DWORD   DataSize; <br>DWORD   dwR; <br>DWORD   Len; <br>DWORD   Index; <br>DWORD   dwTemp; <br>BOOL    bNT10; <br>LPTSTR  szCounterValueName; <br>LPTSTR  szTitle; <br> <br> <br> <br> <br>    // Initialize <br>    // <br>    hKey1        = NULL; <br>    hKey2        = NULL; <br>    *TitleBuffer = NULL; <br>    *TitleSz     = NULL; <br> <br> <br> <br> <br>    // Open the perflib key to find out the last counter's index and system version. <br>    // <br>    dwR = RegOpenKeyEx (hKeyMachine, <br>                        TEXT("software\\microsoft\\windows nt\\currentversion\\perflib"), <br>                        0, <br>                        KEY_READ, <br>                        &amp;hKey1); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br>    // Get the last counter's index so we know how much memory to allocate for TitleSz <br>    // <br>    DataSize = sizeof (DWORD); <br>    dwR = RegQueryValueEx (hKey1, TEXT("Last Counter"), 0, &amp;Type, (LPBYTE)TitleLastIdx, &amp;DataSize); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br>    // Find system version, for system earlier than 1.0a, there's no version value. <br>    // <br>    dwR = RegQueryValueEx (hKey1, TEXT("Version"), 0, &amp;Type, (LPBYTE)&amp;dwTemp, &amp;DataSize); <br> <br>    if (dwR != ERROR_SUCCESS) <br>        // unable to read the value, assume NT 1.0 <br>        bNT10 = TRUE; <br>    else <br>        // found the value, so, NT 1.0a or later <br>        bNT10 = FALSE; <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>    // Now, get ready for the counter names and indexes. <br>    // <br>    if (bNT10) <br>        { <br>        // NT 1.0, so make hKey2 point to ...\perflib\009 and get <br>        //  the counters from value "Counters" <br>        // <br>        szCounterValueName = TEXT("Counters"); <br>        dwR = RegOpenKeyEx (hKeyMachine, <br>                            TEXT("software\\microsoft\\windows nt\\currentversion\\perflib\\009"), <br>                            0, <br>                            KEY_READ, <br>                            &amp;hKey2); <br>        if (dwR != ERROR_SUCCESS) <br>            goto done; <br>        } <br>    else <br>        { <br>        // NT 1.0a or later.  Get the counters in key HKEY_PERFORMANCE_KEY <br>        //  and from value "Counter 009" <br>        // <br>        szCounterValueName = TEXT("Counter 009"); <br>        hKey2 = hKeyPerf; <br>        } <br> <br> <br> <br> <br> <br>    // Find out the size of the data. <br>    // <br>    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &amp;Type, 0, &amp;DataSize); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br>    // Allocate memory <br>    // <br>    *TitleBuffer = (LPTSTR)LocalAlloc (LMEM_FIXED, DataSize); <br>    if (!*TitleBuffer) <br>        { <br>        dwR = ERROR_NOT_ENOUGH_MEMORY; <br>        goto done; <br>        } <br> <br>    *TitleSz = (LPTSTR *)LocalAlloc (LPTR, (*TitleLastIdx+1) * sizeof (LPTSTR)); <br>    if (!*TitleSz) <br>        { <br>        dwR = ERROR_NOT_ENOUGH_MEMORY; <br>        goto done; <br>        } <br> <br> <br> <br> <br> <br>    // Query the data <br>    // <br>    dwR = RegQueryValueEx (hKey2, szCounterValueName, 0, &amp;Type, (BYTE *)*TitleBuffer, &amp;DataSize); <br>    if (dwR != ERROR_SUCCESS) <br>        goto done; <br> <br> <br> <br> <br>    // Setup the TitleSz array of pointers to point to beginning of each title string. <br>    // TitleBuffer is type REG_MULTI_SZ. <br>    // <br>    szTitle = *TitleBuffer; <br> <br>    while (Len = lstrlen (szTitle)) <br>        { <br>        Index = atoi (szTitle); <br> <br>        szTitle = szTitle + Len +1; <br> <br>        if (Index &lt;= *TitleLastIdx) <br>            (*TitleSz)[Index] = szTitle; <br> <br>        szTitle = szTitle + lstrlen (szTitle) +1; <br>        } <br> <br> <br> <br>done: <br> <br>    // Done. Now cleanup! <br>    // <br>    if (dwR != ERROR_SUCCESS) <br>        { <br>        // There was an error, free the allocated memory <br>        // <br>        if (*TitleBuffer) LocalFree (*TitleBuffer); <br>        if (*TitleSz)     LocalFree (*TitleSz); <br>        } <br> <br>    // Close the hKeys. <br>    // <br>    if (hKey1) RegCloseKey (hKey1); <br>    if (hKey2 &amp;&amp; hKey2 != hKeyPerf) RegCloseKey (hKey2); <br> <br> <br> <br>    return dwR; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
