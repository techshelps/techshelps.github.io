<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PVIEWDAT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5724"></a>PVIEWDAT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>/****************************************************************************** <br> <br>                            P V I E W   D A T A <br> <br>    Name:       pviewdat.c <br> <br>    Description: <br>        This module collects the data to be displayed in pview. <br> <br>******************************************************************************/ <br> <br>#include    &lt;windows.h&gt; <br>#include    &lt;winperf.h&gt; <br>#include    "perfdata.h" <br>#include    "pviewdat.h" <br>#include    "pviewdlg.h" <br>#include    &lt;stdio.h&gt; <br>#include    &lt;stdlib.h&gt; <br>#include    &lt;string.h&gt; <br>#include    &lt;tchar.h&gt; <br> <br> <br>#define NODATA  TEXT("--------") <br> <br> <br> <br> <br> <br>void    FormatTimeFields <br>               (double      fTime, <br>                PTIME_FIELD pTimeFld); <br> <br>DWORD   PutCounterDWKB <br>               (HWND            hWnd, <br>                DWORD           dwItemID, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj, <br>                DWORD           dwCounterIdx); <br> <br>DWORD   PutCounterHEX <br>               (HWND            hWnd, <br>                DWORD           dwItemID, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj, <br>                DWORD           dwCounterIdx); <br> <br>DWORD   PutCounterDW <br>               (HWND            hWnd, <br>                DWORD           dwItemID, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj, <br>                DWORD           dwCounterIdx); <br> <br>void    PaintAddressSpace <br>               (HWND            hMemDlg, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj, <br>                DWORD           TotalID, <br>                DWORD           NoAccessID, <br>                DWORD           NoAccessIndex, <br>                DWORD           ReadOnlyID, <br>                DWORD           ReadOnlyIndex, <br>                DWORD           ReadWriteID, <br>                DWORD           ReadWriteIndex, <br>                DWORD           WriteCopyID, <br>                DWORD           WriteCopyIndex, <br>                DWORD           ExecuteID, <br>                DWORD           ExecuteIndex1, <br>                DWORD           ExecuteIndex2, <br>                DWORD           ExecuteIndex3, <br>                DWORD           ExecuteIndex4); <br> <br>void    PaintMemDlgAddrData <br>               (HWND            hMemDlg, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj); <br> <br>void    PaintMemDlgVMData <br>               (HWND            hMemDlg, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj); <br> <br>void    PaintPviewDlgMemoryData <br>               (HWND            hPviewDlg, <br>                PPERF_INSTANCE  pInst, <br>                PPERF_OBJECT    pObj); <br> <br>void    RefreshMemoryDlgImageList <br>               (HWND            hImageList, <br>                DWORD           ParentIndex, <br>                PPERF_OBJECT    pImageObj); <br> <br>WORD    ProcessPriority <br>               (PPERF_OBJECT    pObject, <br>                PPERF_INSTANCE  pInstance); <br> <br>void    SetProcessListText <br>               (PPERF_INSTANCE pInst, <br>                PPERF_COUNTER  pCPU, <br>                PPERF_COUNTER  pPRIV, <br>                PPERF_COUNTER  pProcID, <br>                double         fTime, <br>                LPTSTR         str); <br> <br>void    SetThreadListText <br>               (PPERF_INSTANCE  pInst, <br>                PPERF_COUNTER   pCPU, <br>                PPERF_COUNTER   pPRIV, <br>                double          fTime, <br>                LPTSTR          str); <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      FormatTimeFields <br>// <br>//  Formats a double value to time fields. <br>// <br>void FormatTimeFields   (double      fTime, <br>                         PTIME_FIELD pTimeFld) <br>{ <br>INT     i; <br>double   f; <br> <br>    f = fTime/3600; <br> <br>    pTimeFld-&gt;Hours = i = (int)f; <br> <br>    f = f - i; <br>    pTimeFld-&gt;Mins = i = (int)(f = f * 60); <br> <br>    f = f - i; <br>    pTimeFld-&gt;Secs = i = (int)(f = f * 60); <br> <br>    f = f - i; <br>    pTimeFld-&gt;mSecs = (int)(f * 1000); <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PutCounterDWKB <br>// <br>//  Display a DWORD counter's data in KB units. <br>// <br>DWORD   PutCounterDWKB (HWND            hWnd, <br>                        DWORD           dwItemID, <br>                        PPERF_INSTANCE  pInst, <br>                        PPERF_OBJECT    pObj, <br>                        DWORD           dwCounterIdx) <br>{ <br>PPERF_COUNTER   pCounter; <br>DWORD           *pdwData; <br>TCHAR           szTemp[20]; <br> <br>    if (pCounter = FindCounter (pObj, dwCounterIdx)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        wsprintf (szTemp, TEXT("%ld KB"), *pdwData/1024); <br>        SetDlgItemText (hWnd, dwItemID, szTemp); <br> <br>        return *pdwData; <br>        } <br>    else <br>        { <br>        SetDlgItemText (hWnd, dwItemID, NODATA); <br>        return 0; <br>        } <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PutCounterHEX <br>// <br>//  Display a DWORD counter's data in hex. <br>// <br>DWORD   PutCounterHEX  (HWND            hWnd, <br>                        DWORD           dwItemID, <br>                        PPERF_INSTANCE  pInst, <br>                        PPERF_OBJECT    pObj, <br>                        DWORD           dwCounterIdx) <br>{ <br>PPERF_COUNTER   pCounter; <br>DWORD           *pdwData; <br>TCHAR           szTemp[20]; <br> <br>    if (pCounter = FindCounter (pObj, dwCounterIdx)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        wsprintf (szTemp, TEXT("0x%08x"), *pdwData); <br>        SetDlgItemText (hWnd, dwItemID, szTemp); <br> <br>        return *pdwData; <br>        } <br>    else <br>        { <br>        SetDlgItemText (hWnd, dwItemID, NODATA); <br>        return 0; <br>        } <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PutCounterDWKB <br>// <br>//  Display a DWORD counter's data. <br>// <br>DWORD   PutCounterDW   (HWND            hWnd, <br>                        DWORD           dwItemID, <br>                        PPERF_INSTANCE  pInst, <br>                        PPERF_OBJECT    pObj, <br>                        DWORD           dwCounterIdx) <br>{ <br>PPERF_COUNTER   pCounter; <br>DWORD           *pdwData; <br> <br>    if (pCounter = FindCounter (pObj, dwCounterIdx)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        SetDlgItemInt (hWnd, dwItemID, *pdwData, FALSE); <br> <br>        return *pdwData; <br>        } <br>    else <br>        { <br>        SetDlgItemText (hWnd, dwItemID, NODATA); <br>        return 0; <br>        } <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PaintAddressSpace <br>// <br>// <br>void    PaintAddressSpace  (HWND            hMemDlg, <br>                            PPERF_INSTANCE  pInst, <br>                            PPERF_OBJECT    pObj, <br>                            DWORD           TotalID, <br>                            DWORD           NoAccessID, <br>                            DWORD           NoAccessIndex, <br>                            DWORD           ReadOnlyID, <br>                            DWORD           ReadOnlyIndex, <br>                            DWORD           ReadWriteID, <br>                            DWORD           ReadWriteIndex, <br>                            DWORD           WriteCopyID, <br>                            DWORD           WriteCopyIndex, <br>                            DWORD           ExecuteID, <br>                            DWORD           ExecuteIndex1, <br>                            DWORD           ExecuteIndex2, <br>                            DWORD           ExecuteIndex3, <br>                            DWORD           ExecuteIndex4) <br>{ <br>PPERF_COUNTER   pCounter; <br>DWORD           *pdwData; <br>TCHAR           szTemp[20]; <br> <br>DWORD           dwTotal = 0; <br>DWORD           dwExecute = 0; <br>BOOL            bCounter = FALSE; <br> <br> <br>    dwTotal += PutCounterDWKB (hMemDlg, NoAccessID,  pInst, pObj, NoAccessIndex); <br>    dwTotal += PutCounterDWKB (hMemDlg, ReadOnlyID,  pInst, pObj, ReadOnlyIndex); <br>    dwTotal += PutCounterDWKB (hMemDlg, ReadWriteID, pInst, pObj, ReadWriteIndex); <br>    dwTotal += PutCounterDWKB (hMemDlg, WriteCopyID, pInst, pObj, WriteCopyIndex); <br> <br> <br>    // execute is the sum of the following <br>    // <br>    if (pCounter = FindCounter (pObj, ExecuteIndex1)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwTotal += *pdwData; <br>        dwExecute += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, ExecuteIndex2)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwTotal += *pdwData; <br>        dwExecute += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, ExecuteIndex3)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwTotal += *pdwData; <br>        dwExecute += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, ExecuteIndex4)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwTotal += *pdwData; <br>        dwExecute += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (bCounter) <br>        { <br>        wsprintf (szTemp, TEXT("%ld KB"), dwExecute/1024); <br>        SetDlgItemText (hMemDlg, ExecuteID, szTemp); <br>        } <br>    else <br>        SetDlgItemText (hMemDlg, ExecuteID, NODATA); <br> <br>    wsprintf (szTemp, TEXT("%ld KB"), dwTotal/1024); <br>    SetDlgItemText (hMemDlg, TotalID, szTemp); <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PaintMemDlgAddrData <br>// <br>//  Paint the memory dialog address space data. <br>// <br>void    PaintMemDlgAddrData(HWND            hMemDlg, <br>                            PPERF_INSTANCE  pInst, <br>                            PPERF_OBJECT    pObj) <br>{ <br>    PaintAddressSpace (hMemDlg, pInst, pObj, <br>                       MEMORY_TOTALPRIVATE_COMMIT, <br>                       MEMORY_PRIVATE_NOACCESS,  PX_PROCESS_PRIVATE_NOACCESS, <br>                       MEMORY_PRIVATE_READONLY,  PX_PROCESS_PRIVATE_READONLY, <br>                       MEMORY_PRIVATE_READWRITE, PX_PROCESS_PRIVATE_READWRITE, <br>                       MEMORY_PRIVATE_WRITECOPY, PX_PROCESS_PRIVATE_WRITECOPY, <br>                       MEMORY_PRIVATE_EXECUTE,   PX_PROCESS_PRIVATE_EXECUTABLE, <br>                                                 PX_PROCESS_PRIVATE_EXE_READONLY, <br>                                                 PX_PROCESS_PRIVATE_EXE_READWRITE, <br>                                                 PX_PROCESS_PRIVATE_EXE_WRITECOPY); <br> <br>    PaintAddressSpace (hMemDlg, pInst, pObj, <br>                       MEMORY_TOTALMAPPED_COMMIT, <br>                       MEMORY_MAPPED_NOACCESS,  PX_PROCESS_MAPPED_NOACCESS, <br>                       MEMORY_MAPPED_READONLY,  PX_PROCESS_MAPPED_READONLY, <br>                       MEMORY_MAPPED_READWRITE, PX_PROCESS_MAPPED_READWRITE, <br>                       MEMORY_MAPPED_WRITECOPY, PX_PROCESS_MAPPED_WRITECOPY, <br>                       MEMORY_MAPPED_EXECUTE,   PX_PROCESS_MAPPED_EXECUTABLE, <br>                                                PX_PROCESS_MAPPED_EXE_READONLY, <br>                                                PX_PROCESS_MAPPED_EXE_READWRITE, <br>                                                PX_PROCESS_MAPPED_EXE_WRITECOPY); <br> <br>    PaintAddressSpace (hMemDlg, pInst, pObj, <br>                       MEMORY_TOTALIMAGE_COMMIT, <br>                       MEMORY_IMAGE_NOACCESS,   PX_PROCESS_IMAGE_NOACCESS, <br>                       MEMORY_IMAGE_READONLY,   PX_PROCESS_IMAGE_READONLY, <br>                       MEMORY_IMAGE_READWRITE,  PX_PROCESS_IMAGE_READWRITE, <br>                       MEMORY_IMAGE_WRITECOPY,  PX_PROCESS_IMAGE_WRITECOPY, <br>                       MEMORY_IMAGE_EXECUTE,    PX_PROCESS_IMAGE_EXECUTABLE, <br>                                                PX_PROCESS_IMAGE_EXE_READONLY, <br>                                                PX_PROCESS_IMAGE_EXE_READWRITE, <br>                                                PX_PROCESS_IMAGE_EXE_WRITECOPY); <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PaintMemDlgVMData <br>// <br>//  Paint the memory dialog Virtual Memory data. <br>// <br>void    PaintMemDlgVMData  (HWND            hMemDlg, <br>                            PPERF_INSTANCE  pInst, <br>                            PPERF_OBJECT    pObj) <br>{ <br> <br>    PutCounterDWKB (hMemDlg, MEMORY_WS,           pInst, pObj, PX_PROCESS_WORKING_SET); <br>    PutCounterDWKB (hMemDlg, MEMORY_PEAK_WS,      pInst, pObj, PX_PROCESS_PEAK_WS); <br>    PutCounterDWKB (hMemDlg, MEMORY_PRIVATE_PAGE, pInst, pObj, PX_PROCESS_PRIVATE_PAGE); <br>    PutCounterDWKB (hMemDlg, MEMORY_VSIZE,        pInst, pObj, PX_PROCESS_VIRTUAL_SIZE); <br>    PutCounterDWKB (hMemDlg, MEMORY_PEAK_VSIZE,   pInst, pObj, PX_PROCESS_PEAK_VS); <br>    PutCounterDWKB (hMemDlg, MEMORY_PFCOUNT,      pInst, pObj, PX_PROCESS_FAULT_COUNT); <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      PaintPviewDlgMemoryData <br>// <br>//  Paint the memory data for pview dialog. <br>// <br>void    PaintPviewDlgMemoryData    (HWND            hPviewDlg, <br>                                    PPERF_INSTANCE  pInst, <br>                                    PPERF_OBJECT    pObj) <br>{ <br>PPERF_COUNTER   pCounter; <br>TCHAR           str[20]; <br>DWORD           *pdwData; <br>DWORD           dwData = 0; <br>BOOL            bCounter = FALSE; <br> <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_NOACCESS)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_READONLY)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_READWRITE)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_WRITECOPY)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXECUTABLE)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_READONLY)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_READWRITE)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (pCounter = FindCounter (pObj, PX_PROCESS_PRIVATE_EXE_WRITECOPY)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInst, pCounter); <br>        dwData += *pdwData; <br>        bCounter = TRUE; <br>        } <br> <br>    if (bCounter) <br>        { <br>        wsprintf (str, TEXT("%ld KB"), dwData/1024); <br>        SetDlgItemText (hPviewDlg, PVIEW_TOTALPRIVATE_COMMIT, str); <br>        } <br>    else <br>        SetDlgItemText (hPviewDlg, PVIEW_TOTALPRIVATE_COMMIT, NODATA); <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshMemoryDlg <br>// <br>//  Refresh the memory detail dialog. <br>// <br>BOOL    RefreshMemoryDlg   (HWND            hMemDlg, <br>                            PPERF_INSTANCE  pProcessInstance, <br>                            PPERF_OBJECT    pProcessObject, <br>                            PPERF_OBJECT    pAddressObject, <br>                            PPERF_OBJECT    pImageObject) <br>{ <br>DWORD           *pProcessID1; <br>DWORD           *pProcessID2; <br>PPERF_COUNTER   pCounter1; <br>PPERF_COUNTER   pCounter2; <br>PPERF_INSTANCE  pAddressInstance; <br>HWND            hImageList; <br>TCHAR           szTemp[40]; <br>BOOL            bStat = FALSE; <br>INT             InstIndex = 0; <br> <br> <br>    if ((pCounter1 = FindCounter (pProcessObject, PX_PROCESS_ID)) &amp;&amp; <br>        (pCounter2 = FindCounter (pAddressObject, PX_PROCESS_ID))) <br>        { <br>        pProcessID1 = (DWORD *) CounterData (pProcessInstance, pCounter1); <br> <br>        wsprintf (szTemp, TEXT("%s (%#x)"), InstanceName (pProcessInstance), *pProcessID1); <br>        SetDlgItemText (hMemDlg, MEMORY_PROCESS_ID, szTemp); <br> <br>        pAddressInstance = FirstInstance (pAddressObject); <br> <br>        while (pAddressInstance &amp;&amp; InstIndex &lt; pAddressObject-&gt;NumInstances) <br>            { <br>            pProcessID2 = (DWORD *) CounterData (pAddressInstance, pCounter2); <br> <br>            if (*pProcessID1 == *pProcessID2) <br>                { <br>                PaintMemDlgAddrData (hMemDlg, pAddressInstance, pAddressObject); <br>                PaintMemDlgVMData (hMemDlg, pProcessInstance, pProcessObject); <br> <br>                hImageList = GetDlgItem (hMemDlg, MEMORY_IMAGE); <br>                RefreshMemoryDlgImageList (hImageList, InstIndex, pImageObject); <br> <br>                bStat = TRUE; <br>                break; <br>                } <br> <br>            pAddressInstance = NextInstance (pAddressInstance); <br>            InstIndex++; <br>            } <br>        } <br> <br>    return bStat; <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshMemoryDlgImageList <br>// <br>//  Refresh the image list for memory dialog. <br>// <br>void    RefreshMemoryDlgImageList  (HWND            hImageList, <br>                                    DWORD           ParentIndex, <br>                                    PPERF_OBJECT    pImageObj) <br>{ <br>PPERF_INSTANCE  pImageInst; <br>INT             ListIndex; <br>INT             InstIndex = 0; <br> <br> <br>    ListIndex = SendMessage (hImageList, CB_ADDSTRING, 0, (DWORD)TEXT(" Total Commit")); <br>    SendMessage (hImageList, CB_SETITEMDATA, ListIndex, 0xFFFFFFFF); <br> <br>    if (pImageObj) <br>        { <br>        pImageInst = FirstInstance (pImageObj); <br> <br>        while (pImageInst &amp;&amp; InstIndex &lt; pImageObj-&gt;NumInstances) <br>            { <br>            if (ParentIndex == pImageInst-&gt;ParentObjectInstance) <br>                { <br>                ListIndex = SendMessage (hImageList, <br>                                         CB_ADDSTRING, <br>                                         0, <br>                                         (DWORD)InstanceName(pImageInst)); <br>                SendMessage (hImageList, CB_SETITEMDATA, ListIndex, InstIndex); <br>                } <br> <br>            pImageInst = NextInstance (pImageInst); <br>            InstIndex++; <br>            } <br>        } <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshMemoryDlgImage <br>// <br>// <br>void RefreshMemoryDlgImage (HWND            hMemDlg, <br>                            DWORD           dwIndex, <br>                            PPERF_OBJECT    pImageObject) <br>{ <br>PPERF_INSTANCE  pInst; <br> <br>    if (pInst = FindInstanceN (pImageObject, dwIndex)) <br>        PaintAddressSpace (hMemDlg, pInst, pImageObject, <br>                           MEMORY_TOTALIMAGE_COMMIT, <br>                           MEMORY_IMAGE_NOACCESS,   PX_IMAGE_NOACCESS, <br>                           MEMORY_IMAGE_READONLY,   PX_IMAGE_READONLY, <br>                           MEMORY_IMAGE_READWRITE,  PX_IMAGE_READWRITE, <br>                           MEMORY_IMAGE_WRITECOPY,  PX_IMAGE_WRITECOPY, <br>                           MEMORY_IMAGE_EXECUTE,    PX_IMAGE_EXECUTABLE, <br>                                                    PX_IMAGE_EXE_READONLY, <br>                                                    PX_IMAGE_EXE_READWRITE, <br>                                                    PX_IMAGE_EXE_WRITECOPY); <br>} <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshPviewDlgMemoryData <br>// <br>//  Update the memory data for pview dialog.  This should be done <br>//  after the ghCostlyData is collected and is not refreshing. <br>// <br>void RefreshPviewDlgMemoryData (HWND            hPviewDlg, <br>                                PPERF_INSTANCE  pProcessInstance, <br>                                PPERF_OBJECT    pProcessObject, <br>                                PPERF_OBJECT    pAddressObject) <br>{ <br>DWORD           *pProcessID1; <br>DWORD           *pProcessID2; <br>PPERF_COUNTER   pCounter1; <br>PPERF_COUNTER   pCounter2; <br>PPERF_INSTANCE  pAddressInstance; <br>INT             i = 0; <br> <br> <br>    if ((pCounter1 = FindCounter (pProcessObject, PX_PROCESS_ID)) &amp;&amp; <br>        (pCounter2 = FindCounter (pAddressObject, PX_PROCESS_ID))) <br>        { <br>        pProcessID1 = (DWORD *) CounterData (pProcessInstance, pCounter1); <br> <br>        pAddressInstance = FirstInstance (pAddressObject); <br> <br>        while (pAddressInstance &amp;&amp; i &lt; pAddressObject-&gt;NumInstances) <br>            { <br>            pProcessID2 = (DWORD *) CounterData (pAddressInstance, pCounter2); <br> <br>            if (*pProcessID1 == *pProcessID2) <br>                { <br>                PaintPviewDlgMemoryData (hPviewDlg, pAddressInstance, pAddressObject); <br>                break; <br>                } <br> <br>            pAddressInstance = NextInstance (pAddressInstance); <br>            i++; <br>            } <br>        } <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshPviewDlgThreadPC <br>// <br>//  Update the thread PC value.  This should be done after the ghCostlyData <br>//  is collected and is no refreshing. <br>// <br>void RefreshPviewDlgThreadPC   (HWND            hPviewDlg, <br>                                LPTSTR          szProcessName, <br>                                LPTSTR          szThreadName, <br>                                PPERF_OBJECT    pThreadDetailsObject, <br>                                PPERF_DATA      pCostlyData) <br>{ <br>PPERF_COUNTER   pCounter; <br>PPERF_INSTANCE  pInstance; <br>PPERF_INSTANCE  pParent; <br>LPTSTR          szInstanceName; <br>LPTSTR          szParentName; <br>TCHAR           str[20]; <br>DWORD           *pdwData; <br>INT             i = 0; <br> <br> <br>    if (pCounter = FindCounter (pThreadDetailsObject, PX_THREAD_PC)) <br>        { <br>        pInstance = FirstInstance (pThreadDetailsObject); <br> <br>        while (pInstance &amp;&amp; i &lt; pThreadDetailsObject-&gt;NumInstances) <br>            { <br>            if (!(szInstanceName = InstanceName (pInstance))) <br>                // can't find name <br>                ; <br>            else if (lstrcmp (szThreadName, szInstanceName)) <br>                // the thread name is different <br>                ; <br>            else if (!(pParent = FindInstanceParent (pInstance, pCostlyData))) <br>                // can't find parent <br>                ; <br>            else if (!(szParentName = InstanceName (pParent))) <br>                // can't find parent's name <br>                ; <br>            else if (!lstrcmp (szProcessName, szParentName)) <br>                { <br>                // Parent's name matches, this is the right one. <br>                // <br> <br>                pdwData = CounterData (pInstance, pCounter); <br>                wsprintf (str, TEXT("0x%08x"), *pdwData); <br>                SetDlgItemText (hPviewDlg, PVIEW_THREAD_PC, str); <br> <br>                return; <br>                } <br> <br>            pInstance = NextInstance (pInstance); <br>            i++; <br>            } <br>        } <br> <br> <br>    // We are here only because we can't find the data to display. <br>    // <br> <br>    SetDlgItemText (hPviewDlg, PVIEW_THREAD_PC, NODATA); <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      ProcessPriority <br>// <br>//  Returns the process priority dialog item id. <br>// <br>WORD    ProcessPriority    (PPERF_OBJECT    pObject, <br>                            PPERF_INSTANCE  pInstance) <br>{ <br>PPERF_COUNTER   pCounter; <br>DWORD           *pdwData; <br> <br> <br>    if (pCounter = FindCounter (pObject, PX_PROCESS_PRIO)) <br>        { <br>        pdwData = (DWORD *) CounterData (pInstance, pCounter); <br> <br>        if (*pdwData &lt; 7) <br>            return PVIEW_PRIORITY_IDL; <br>        else if (*pdwData &lt; 10) <br>            return PVIEW_PRIORITY_NORMAL; <br>        else <br>            return PVIEW_PRIORITY_HIGH; <br>        } <br>    else <br>        return PVIEW_PRIORITY_NORMAL; <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshPerfData <br>// <br>//  Get a new set of performance data.  pData should be NULL initially. <br>// <br>PPERF_DATA RefreshPerfData (HKEY        hPerfKey, <br>                            LPTSTR      szObjectIndex, <br>                            PPERF_DATA  pData, <br>                            DWORD       *pDataSize) <br>{ <br>    if (GetPerfData (hPerfKey, szObjectIndex, &amp;pData, pDataSize) == ERROR_SUCCESS) <br>        return pData; <br>    else <br>        return NULL; <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      SetProcessListText <br>// <br>//  Format the process list text. <br>// <br>void SetProcessListText (PPERF_INSTANCE pInst, <br>                         PPERF_COUNTER  pCPU, <br>                         PPERF_COUNTER  pPRIV, <br>                         PPERF_COUNTER  pProcID, <br>                         double         fTime, <br>                         LPTSTR         str) <br>{ <br>DWORD           *pdwProcID; <br>LARGE_INTEGER   *liCPU; <br>LARGE_INTEGER   *liPRIV; <br>double          fCPU = 0; <br>double          fPRIV = 0; <br>INT             PcntPRIV = 0; <br>INT             PcntUSER = 0; <br>TIME_FIELD      TimeFld; <br>TCHAR           szTemp[100]; <br> <br> <br>    if (pCPU) <br>        { <br>        liCPU = (LARGE_INTEGER *) CounterData (pInst, pCPU); <br>        fCPU  = Li2Double (*liCPU); <br>        } <br> <br>    if (pPRIV) <br>        { <br>        liPRIV = (LARGE_INTEGER *) CounterData (pInst, pPRIV); <br>        fPRIV  = Li2Double (*liPRIV); <br>        } <br> <br>    if (fCPU &gt; 0) <br>        { <br>        PcntPRIV = (INT)(fPRIV / fCPU * 100 + 0.5); <br>        PcntUSER = 100 - PcntPRIV; <br>        } <br> <br> <br> <br>    if (pProcID) <br>        { <br>        pdwProcID = (DWORD *) CounterData (pInst, pProcID); <br>        wsprintf (szTemp, TEXT("%ls (%#x)"), InstanceName(pInst), *pdwProcID); <br>        } <br>    else <br>        wsprintf (szTemp, TEXT("%ls"), InstanceName(pInst)); <br> <br> <br> <br>    FormatTimeFields (fCPU/1.0e7, &amp;TimeFld); <br> <br>    wsprintf (str, <br>              TEXT("%s\t%3ld:%02ld:%02ld.%03ld\t%3ld%%\t%3ld%%"), <br>              szTemp, <br>              TimeFld.Hours, <br>              TimeFld.Mins, <br>              TimeFld.Secs, <br>              TimeFld.mSecs, <br>              PcntPRIV, <br>              PcntUSER); <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshProcessList <br>// <br>//  Find all process and update the process list. <br>// <br>void RefreshProcessList (HWND           hProcessList, <br>                         PPERF_OBJECT   pObject) <br>{ <br>PPERF_INSTANCE  pInstance; <br>TCHAR           szListText[256]; <br>INT             ListIndex; <br> <br>PPERF_COUNTER   pCounterCPU; <br>PPERF_COUNTER   pCounterPRIV; <br>PPERF_COUNTER   pCounterProcID; <br>double          fObjectFreq; <br>double          fObjectTime; <br>double          fTime; <br> <br>INT             InstanceIndex = 0; <br>INT             err; <br> <br> <br>    if (pObject) <br>        { <br>        if ((pCounterCPU    = FindCounter (pObject, PX_PROCESS_CPU))  &amp;&amp; <br>            (pCounterPRIV   = FindCounter (pObject, PX_PROCESS_PRIV)) &amp;&amp; <br>            (pCounterProcID = FindCounter (pObject, PX_PROCESS_ID))) <br>            { <br> <br>            fObjectFreq = Li2Double (pObject-&gt;PerfFreq); <br>            fObjectTime = Li2Double (pObject-&gt;PerfTime); <br>            fTime = fObjectTime / fObjectFreq; <br> <br>            pInstance = FirstInstance (pObject); <br> <br>            while (pInstance &amp;&amp; InstanceIndex &lt; pObject-&gt;NumInstances) <br>                { <br>                SetProcessListText (pInstance, <br>                                    pCounterCPU, <br>                                    pCounterPRIV, <br>                                    pCounterProcID, <br>                                    fTime, <br>                                    szListText); <br> <br>                ListIndex = SendMessage (hProcessList, LB_ADDSTRING, 0, (DWORD)szListText); <br>                err = SendMessage (hProcessList, LB_SETITEMDATA, ListIndex, InstanceIndex); <br> <br>                pInstance = NextInstance (pInstance); <br>                InstanceIndex++; <br>                } <br>            } <br>        } <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshProcessData <br>// <br>//  Find data for a given process and update. <br>// <br>void RefreshProcessData    (HWND            hWnd, <br>                            PPERF_OBJECT    pObject, <br>                            DWORD           ProcessIndex) <br>{ <br>PPERF_INSTANCE  pInstance; <br> <br> <br>    if (pInstance = FindInstanceN (pObject, ProcessIndex)) </code></pre>
<p>
</p>
<pre><code>{ <br>        PutCounterDWKB (hWnd, PVIEW_WS, pInstance, pObject, PX_PROCESS_WORKING_SET); <br> <br> <br>        SetDlgItemText (hWnd, PVIEW_TOTALPRIVATE_COMMIT, NODATA); <br> <br>        // set priority <br>        // <br>        CheckRadioButton (hWnd, <br>                          PVIEW_PRIORITY_HIGH, <br>                          PVIEW_PRIORITY_IDL, <br>                          ProcessPriority (pObject, pInstance)); <br>        } <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      SetThreadListText <br>// <br>//  Format the thread list text. <br>// <br>void SetThreadListText (PPERF_INSTANCE  pInst, <br>                        PPERF_COUNTER   pCPU, <br>                        PPERF_COUNTER   pPRIV, <br>                        double          fTime, <br>                        LPTSTR          str) <br>{ <br>LARGE_INTEGER   *liCPU; <br>LARGE_INTEGER   *liPRIV; <br>double          fCPU = 0; <br>double          fPRIV = 0; <br>INT             PcntPRIV = 0; <br>INT             PcntUSER = 0; <br>TIME_FIELD      TimeFld; <br>TCHAR           szTemp[100]; <br> <br> <br>    if (pCPU) <br>        { <br>        liCPU = (LARGE_INTEGER *) CounterData (pInst, pCPU); <br>        fCPU  = Li2Double (*liCPU); <br>        } <br> <br>    if (pPRIV) <br>        { <br>        liPRIV = (LARGE_INTEGER *) CounterData (pInst, pPRIV); <br>        fPRIV  = Li2Double (*liPRIV); <br>        } <br> <br>    if (fCPU &gt; 0) <br>        { <br>        PcntPRIV = (INT)(fPRIV / fCPU * 100 + 0.5); <br>        PcntUSER = 100 - PcntPRIV; <br>        } <br> <br> <br> <br>    if (pInst-&gt;UniqueID != PERF_NO_UNIQUE_ID) <br>        wsprintf (szTemp, TEXT("%ls (%#x)"), InstanceName(pInst), pInst-&gt;UniqueID); <br>    else <br>        wsprintf (szTemp, TEXT("%ls"), InstanceName(pInst)); <br> <br> <br> <br> <br>    FormatTimeFields (fCPU/1.0e7, &amp;TimeFld); <br> <br>    wsprintf (str, <br>              TEXT("%s\t%3ld:%02ld:%02ld.%03ld\t%3ld%%\t%3ld %%"), <br>              szTemp, <br>              TimeFld.Hours, <br>              TimeFld.Mins, <br>              TimeFld.Secs, <br>              TimeFld.mSecs, <br>              PcntPRIV, <br>              PcntUSER); <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshThreadList <br>// <br>//  Find all threads for a given process and update the thread list. <br>// <br>void RefreshThreadList (HWND            hThreadList, <br>                        PPERF_OBJECT    pObject, <br>                        DWORD           ParentIndex) <br>{ <br>PPERF_INSTANCE  pInstance; <br>TCHAR           szListText[256]; <br>INT             ListIndex; <br> <br>PPERF_COUNTER   pCounterCPU; <br>PPERF_COUNTER   pCounterPRIV; <br>double          fObjectFreq; <br>double          fObjectTime; <br>double          fTime; <br> <br>INT             InstanceIndex = 0; <br>INT             err; <br> <br> <br>    if (pObject) <br>        { <br>        if ((pCounterCPU  = FindCounter (pObject, PX_THREAD_CPU)) &amp;&amp; <br>            (pCounterPRIV = FindCounter (pObject, PX_THREAD_PRIV))) <br>            { <br> <br>            fObjectFreq = Li2Double (pObject-&gt;PerfFreq); <br>            fObjectTime = Li2Double (pObject-&gt;PerfTime); <br>            fTime = fObjectTime / fObjectFreq; <br> <br> <br>            pInstance = FirstInstance (pObject); <br> <br>            while (pInstance &amp;&amp; InstanceIndex &lt; pObject-&gt;NumInstances) <br>                { <br>                if (ParentIndex == pInstance-&gt;ParentObjectInstance) <br>                    { <br>                    SetThreadListText (pInstance, <br>                                       pCounterCPU, <br>                                       pCounterPRIV, <br>                                       fTime, <br>                                       szListText); <br> <br>                    ListIndex = SendMessage (hThreadList, <br>                                             LB_INSERTSTRING, <br>                                             (WPARAM)-1, <br>                                             (DWORD)szListText); <br>                    err = SendMessage (hThreadList, LB_SETITEMDATA, ListIndex, InstanceIndex); <br>                    } <br> <br>                pInstance = NextInstance (pInstance); <br>                InstanceIndex++; <br>                } <br>            } <br>        } <br> <br>} <br> <br> <br> <br> <br>//********************************************************************* <br>// <br>//      RefreshThreadData <br>// <br>//  Find data for a given thread and update. <br>// <br>void RefreshThreadData (HWND              hWnd, <br>                        PPERF_OBJECT      pThreadObj, <br>                        DWORD             ThreadIndex, <br>                        PPERF_OBJECT      pProcessObj, <br>                        PPERF_INSTANCE    pProcessInst) <br>{ <br>PPERF_INSTANCE  pInstance; <br>PPERF_COUNTER   pCounter; <br>DWORD           *pdwData; <br>DWORD           *pdwProcPrio; <br>BOOL            bPrioCounter = TRUE; <br> <br> <br> <br>    if (pInstance = FindInstanceN (pThreadObj, ThreadIndex)) <br>        { <br>        SetDlgItemText (hWnd, PVIEW_THREAD_PC, NODATA); <br> <br>        PutCounterHEX (hWnd, PVIEW_THREAD_START,    pInstance, pThreadObj, PX_THREAD_START); <br>        PutCounterDW  (hWnd, PVIEW_THREAD_SWITCHES, pInstance, pThreadObj, PX_THREAD_SWITCHES); <br>        PutCounterDW  (hWnd, PVIEW_THREAD_DYNAMIC,  pInstance, pThreadObj, PX_THREAD_PRIO); <br>        } <br> <br> <br> <br> <br>    if (pInstance) <br>        { <br>        // get thread base priority <br>        // <br> <br>        if (pCounter = FindCounter (pThreadObj, PX_THREAD_BASE_PRIO)) <br>            pdwData = CounterData (pInstance, pCounter); <br>        else <br>            bPrioCounter = FALSE; <br> <br> <br>        // get process priority <br>        // <br> <br>        if (pCounter = FindCounter (pProcessObj, PX_PROCESS_PRIO)) <br>            pdwProcPrio = CounterData (pProcessInst, pCounter); <br>        else <br>            bPrioCounter = FALSE; <br>        } <br>    else <br>        bPrioCounter = FALSE; <br> <br> <br> <br> <br> <br>    // set thread base priority <br>    // <br> <br>    if (!bPrioCounter) <br>        CheckRadioButton (hWnd, <br>                          PVIEW_THREAD_HIGHEST, <br>                          PVIEW_THREAD_LOWEST, <br>                          PVIEW_THREAD_NORMAL); <br>    else <br>        { <br>        switch (*pdwData - *pdwProcPrio) <br>            { <br>            case 2: <br>                CheckRadioButton (hWnd, <br>                                  PVIEW_THREAD_HIGHEST, <br>                                  PVIEW_THREAD_LOWEST, <br>                                  PVIEW_THREAD_HIGHEST); <br>                break; <br> <br>            case 1: <br>                CheckRadioButton (hWnd, <br>                                  PVIEW_THREAD_HIGHEST, <br>                                  PVIEW_THREAD_LOWEST, <br>                                  PVIEW_THREAD_ABOVE); <br>                break; <br> <br>            case -1: <br>                CheckRadioButton (hWnd, <br>                                  PVIEW_THREAD_HIGHEST, <br>                                  PVIEW_THREAD_LOWEST, <br>                                  PVIEW_THREAD_BELOW); <br>                break; <br> <br>            case -2: <br>                CheckRadioButton (hWnd, <br>                                  PVIEW_THREAD_HIGHEST, <br>                                  PVIEW_THREAD_LOWEST, <br>                                  PVIEW_THREAD_LOWEST); <br>                break; <br> <br>            case 0: <br>            default: <br>                CheckRadioButton (hWnd, <br>                                  PVIEW_THREAD_HIGHEST, <br>                                  PVIEW_THREAD_LOWEST, <br>                                  PVIEW_THREAD_NORMAL); <br>                break; <br>            } <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
