<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PVIEWER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5727"></a>PVIEWER.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>/****************************************************************************** <br> <br>                        P R O C E S S   V I E W E R <br> <br>    Name:       pviewer.c <br> <br>    Description: <br>        This program demonstrates the usage of special registry APIs <br>        for collecting performance data. <br> <br>        C files used in this app: <br>            pviewer.c       - this file <br>            pviewdat.c      - updates the dialog <br>            perfdata.c      - gets performance data structures <br>            objdata.c       - access performance data objects <br>            instdata.c      - access performance data instances <br>            cntrdata.c      - access performance data counters <br> <br>******************************************************************************/ <br> <br> <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winperf.h&gt; <br>#include "perfdata.h" <br>#include "pviewdat.h" <br>#include "pviewdlg.h" <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br> <br> <br> <br>#define INDEX_STR_LEN       10 <br>#define MACHINE_NAME_LEN    MAX_COMPUTERNAME_LENGTH+2 <br>#define MACHINE_NAME_SIZE   MACHINE_NAME_LEN+1 <br> <br> <br>/**** <br>Globals <br>****/ <br> <br>TCHAR           INDEX_PROCTHRD_OBJ[2*INDEX_STR_LEN]; <br>TCHAR           INDEX_COSTLY_OBJ[3*INDEX_STR_LEN]; <br> <br>TCHAR           gszMachineName[MACHINE_NAME_SIZE]; <br>TCHAR           gszCurrentMachine[MACHINE_NAME_SIZE]; <br> <br>DWORD           gPerfDataSize = 50*1024;            // start with 50K <br>PPERF_DATA      gpPerfData; <br> <br>DWORD           gCostlyDataSize = 100*1024;         // start wiih 100K <br>PPERF_DATA      gpCostlyData; <br> <br> <br>PPERF_OBJECT    gpProcessObject;                    // pointer to process objects <br>PPERF_OBJECT    gpThreadObject;                     // pointer to thread objects <br>PPERF_OBJECT    gpThreadDetailsObject;              // pointer to thread detail objects <br>PPERF_OBJECT    gpAddressSpaceObject;               // pointer to address space objects <br>PPERF_OBJECT    gpImageObject;                      // pointer to image objects <br> <br> <br>HKEY            ghPerfKey = HKEY_PERFORMANCE_DATA;  // get perf data from this key <br>HKEY            ghMachineKey = HKEY_LOCAL_MACHINE;  // get title index from this key <br> <br> <br>HCURSOR         ghCursor[2];                        // 0 = arrow, 1 = hourglass <br> <br>HANDLE          ghMemUpdateEvent;                   // to signal a refresh of mem stats <br>HANDLE          ghMemUpdateMutex;                   // to restrict overlapping refreshes <br> <br>HINSTANCE       ghInstance;                         // handle for pviewer app <br> <br> <br> <br>/**** <br>Prototypes <br>****/ <br> <br>BOOL CALLBACK   PviewDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam); <br>void    PviewDlgRefresh (HWND hWnd); <br>void    PviewDlgRefreshCostlyData (HWND hPviewDlg); <br>void    PviewDlgRefreshProcess (HWND hWnd); <br>void    PviewDlgRefreshThread (HWND hWnd); <br>void    PviewDlgRefreshCurSelProcess (HWND hWnd); <br>void    PviewDlgRefreshCurSelThread (HWND hWnd); <br>WORD    PviewDlgGetCurSelPriority (HWND hWnd); <br>BOOL    PviewDlgChangePriority (HWND hWnd, DWORD wParam, WORD wItem); <br>BOOL    PviewDlgTerminateProcess (HWND hPviewDlg); <br> <br>BOOL CALLBACK   MemDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam); <br>void    MemDlgUpdateThread (HWND hWnd); <br>void    MemDlgRefresh (HWND hWnd, HWND hPviewDlg); <br>void    MemDlgRefreshCurSelImage (HWND hMemDlg, HWND hPviewDlg); <br> <br>INT     GetCurSelText (HWND hList, LPTSTR str); <br>DWORD   GetCurSelData (HWND hWnd, DWORD dwList); <br>INT     ReSelectText (HWND hList, INT StartIndex, LPTSTR str); <br>void    SetPerfIndexes (HWND hWnd); <br>DWORD   GetTitleIdx (HWND hWnd, LPTSTR TitleSz[], DWORD LastIndex, LPTSTR Name); <br>void    SetListBoxTabStops (HWND hWnd); <br>void    SetLocalMachine (void); <br>BOOL    ConnectComputer (HWND hWnd); <br>void    DisableControls (HWND hPviewDlg); <br>void    EnableControls (HWND hPviewDlg); <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  WinMain -- <br>// <br>//      Build Up: create the program's dialog box, <br>//          load the desired icons, enter the message <br>//          loop. <br>// <br>//      Tear Down: free up the memory allocated by the <br>//          dialog box proc, and exit. <br>// <br>int WINAPI WinMain (HINSTANCE   hInstance, <br>                    HINSTANCE   hPrevInstance, <br>                    LPSTR       lpCmdLine, <br>                    int         nCmdShow) <br>{ <br>HANDLE  hWndDialog; <br>MSG     msg; <br> <br> <br>    ghInstance = hInstance; <br> <br> <br>    // load our default cursors <br>    // <br>    ghCursor[0] = LoadCursor (0, IDC_ARROW); <br>    ghCursor[1] = LoadCursor (0, IDC_WAIT); <br> <br>    // open our dialog box <br>    // <br>    hWndDialog = CreateDialogParam (hInstance, <br>                                    MAKEINTRESOURCE (PVIEW_DLG), <br>                                    NULL, <br>                                    (DLGPROC) PviewDlgProc, <br>                                    (LONG)0); <br> <br>    // the almighty Windows message loop: <br>    // <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) <br>        if (!IsDialogMessage (hWndDialog, &amp;msg)) <br>            { <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>            } <br> <br>    // close up shop <br>    // <br>    DestroyWindow (hWndDialog); <br>    LocalFree (gpPerfData); <br> <br>    return 0; <br>} <br> <br> <br> <br> <br>/***************** <br>PviewDlg functions <br>*****************/ <br> <br>//******************************************************** <br>// <br>//  PviewDlgProc -- <br>// <br>//      Pview dialog procedure <br>// <br>BOOL CALLBACK   PviewDlgProc   (HWND    hWnd, <br>                                UINT    wMsg, <br>                                WPARAM  wParam, <br>                                LPARAM  lParam) <br>{ <br>WORD    wItem; <br> <br> <br>    switch (wMsg) <br>        { <br> <br>        case WM_INITDIALOG: <br>            SetClassLong (hWnd, GCL_HICON, (LONG)LoadIcon(ghInstance, TEXT("VIEWPICON")) ); <br>            SetListBoxTabStops (hWnd); <br>            SendDlgItemMessage (hWnd, PVIEW_COMPUTER, EM_LIMITTEXT, MACHINE_NAME_LEN, 0); <br>            PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH, 0); <br>            break; <br> <br>        case WM_CLOSE: <br>            PostQuitMessage (0); <br>            break; <br> <br>        case WM_COMMAND: <br>            // <br>            // handle our app-specific controls: <br>            // <br>            switch (LOWORD (wParam)) <br>                { <br>                // works just like "close" <br>                // <br>                case PVIEW_EXIT: <br>                    PostQuitMessage (0); <br>                    break; <br> <br>                // if somebody moved the highlight in the thread list, <br>                //  update the view <br>                // <br>                case PVIEW_THREAD_LIST: <br>                    if (HIWORD(wParam) == LBN_DBLCLK || HIWORD(wParam) == LBN_SELCHANGE) <br>                        { <br>                        PviewDlgRefreshCurSelThread (hWnd); <br>                        PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0); <br>                        } <br>                    break; <br> <br>                // if somebody clicked on a new process, update all of the <br>                //  affected information. <br>                // <br>                case PVIEW_PROCESS_LIST: <br>                    if (HIWORD(wParam) == CBN_DBLCLK || HIWORD(wParam) == CBN_SELCHANGE) <br>                        { <br>                        PviewDlgRefreshCurSelProcess (hWnd); <br>                        PostMessage (hWnd, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0); <br>                        if (HIWORD(wParam) == CBN_DBLCLK) <br>                            PostMessage (hWnd, WM_COMMAND, PVIEW_MEMORY_DETAIL, 0); <br>                        } <br>                    break; <br> <br>                // the user wishes to view the memory stats in detail: <br>                // <br>                case PVIEW_MEMORY_DETAIL: <br>                    // <br>                    // check to see if we can get exclusive access <br>                    //  to the memory statistics <br>                    // <br>                    if (WaitForSingleObject (ghMemUpdateMutex, 0)) <br> <br>                        // we can't, so just return. <br>                        // <br>                        return FALSE; <br> <br>                    else <br>                        { <br>                        // we have exclusive access, so start up the <br>                        //  memory statistics dialog. <br>                        // <br>                        // release the mutex first so the dialog can use it. <br>                        // <br>                        ReleaseMutex (ghMemUpdateMutex); <br>                        DialogBoxParam (NULL, <br>                                        MAKEINTRESOURCE (MEMORY_DLG), <br>                                        hWnd, <br>                                        (DLGPROC) MemDlgProc, <br>                                        (LONG)hWnd); <br>                        } <br>                    break; <br> <br>                // somebody clicked one of the priority radio <br>                //  buttons.  Find out which one was selected... <br>                // <br>                case PVIEW_PRIORITY_HIGH: <br>                case PVIEW_PRIORITY_NORMAL: <br>                case PVIEW_PRIORITY_IDL: <br> <br>                    if (SendDlgItemMessage (hWnd, PVIEW_PRIORITY_HIGH, BM_GETCHECK, 0, 0)) <br>                        wItem = PVIEW_PRIORITY_HIGH; <br>                    else if (SendDlgItemMessage (hWnd, PVIEW_PRIORITY_NORMAL, BM_GETCHECK, 0, 0)) <br>                        wItem = PVIEW_PRIORITY_NORMAL; <br>                    else <br>                        wItem = PVIEW_PRIORITY_IDL; <br> <br>                    // if the user actually clicked on a NEW state, <br>                    //  do the change. <br>                    // <br>                    if (LOWORD(wParam) != wItem) <br>                        { <br>                        // of course, if it's a remote machine, disallow <br>                        //  the modification. <br>                        // <br>                        if (lstrcmp (gszCurrentMachine, gszMachineName)) <br>                            { <br>                            SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0); <br>                            SetFocus (GetDlgItem (hWnd, wItem)); <br>                            MessageBox (hWnd, <br>                                        TEXT("Cannot change process priority on remote machine"), <br>                                        TEXT("Set priority"), <br>                                        MB_ICONEXCLAMATION|MB_OK); <br>                            } <br> <br>                        // at this point, we know we are affecting the local <br>                        //  machine, and a change has to be made. <br>                        //  Just Do It(TM). <br>                        // <br>                        else if (PviewDlgChangePriority (hWnd, wParam, wItem)) <br>                            PviewDlgRefresh (hWnd); <br> <br>                        } <br>                    break; <br> <br>                case PVIEW_THREAD_HIGHEST: <br>                case PVIEW_THREAD_ABOVE: <br>                case PVIEW_THREAD_NORMAL: <br>                case PVIEW_THREAD_BELOW: <br>                case PVIEW_THREAD_LOWEST: <br>                    // <br>                    // this selection hasn't been fleshed out yet. <br>                    // <br>                    PviewDlgRefreshCurSelThread (hWnd); <br>                    break; <br> <br>                // terminate the selected process <br>                // <br>                case PVIEW_TERMINATE: <br>                    if (PviewDlgTerminateProcess (hWnd)) <br>                        PviewDlgRefresh (hWnd); <br>                    break; <br> <br>                // if the text has changed, we want to connect and <br>                //  view another system's processes... <br>                // <br>                case PVIEW_COMPUTER: <br>                    if (HIWORD(wParam) == EN_CHANGE) <br>                        EnableWindow (GetDlgItem (hWnd, PVIEW_CONNECT), TRUE); <br>                    else <br>                        return FALSE; <br>                    break; <br> <br>                // we were told to connect, go ahead and try... <br>                // <br>                case PVIEW_CONNECT: <br>                    if (ConnectComputer (hWnd)) <br>                        { <br>                        SetPerfIndexes (hWnd); <br>                        PviewDlgRefresh (hWnd); <br>                        } <br>                    break; <br> <br>                // refresh the current information displayed <br>                // <br>                case PVIEW_REFRESH: <br>                    if (ConnectComputer (hWnd)) <br>                        SetPerfIndexes (hWnd); <br>                    PviewDlgRefresh (hWnd); <br>                    break; <br> <br>                // refresh the currently updated costly <br>                //  statistics <br>                // <br>                case PVIEW_REFRESH_COSTLY_DATA: <br>                    if (WaitForSingleObject (ghMemUpdateMutex, 0)) <br>                        return FALSE; <br> <br>                    PviewDlgRefreshCostlyData (hWnd); <br>                    ReleaseMutex (ghMemUpdateMutex); <br>                    break; <br> <br>                default: <br>                    return FALSE; <br>                } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgRefresh -- <br>// <br>//      Refresh the pview dialog. <br>// <br>void    PviewDlgRefresh (HWND hWnd) <br>{ <br>static  HANDLE  hMemUpdateThread = NULL; <br>static  DWORD   MemUpdateThreadID; <br>MSG     Msg; <br> <br> <br>    SetCursor (ghCursor[1]); <br> <br> <br>    if (hMemUpdateThread)       // get memory data <br>        SetEvent (ghMemUpdateEvent); <br>    else <br>        hMemUpdateThread = CreateThread (NULL, <br>                                         0, <br>                                         (LPTHREAD_START_ROUTINE)MemDlgUpdateThread, <br>                                         (LPVOID)hWnd, <br>                                         0, <br>                                         &amp;MemUpdateThreadID); <br> <br> <br>    // get performance data <br>    // <br>    gpPerfData = RefreshPerfData (ghPerfKey, INDEX_PROCTHRD_OBJ, gpPerfData, &amp;gPerfDataSize); <br> <br>    gpProcessObject = FindObject (gpPerfData, PX_PROCESS); <br>    gpThreadObject  = FindObject (gpPerfData, PX_THREAD); <br> <br> <br>    // refresh <br>    // <br>    PviewDlgRefreshProcess (hWnd); <br>    PviewDlgRefreshThread (hWnd); <br> <br> <br> <br>    // Remove all mouse and key messages. They are not accepted <br>    //  while the cursor is a hourglass. <br>    // <br>    while (PeekMessage (&amp;Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)); <br>    while (PeekMessage (&amp;Msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE)); <br> <br>    SetCursor (ghCursor[0]); <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgRefreshCostlyData -- <br>// <br>//      Refresh the costly data. <br>// <br>void    PviewDlgRefreshCostlyData (HWND hPviewDlg) <br>{ <br>LPTSTR          szProcessName; <br>LPTSTR          szThreadName; <br>PPERF_INSTANCE  pInstance; <br>DWORD           dwIndex; <br> <br> <br>    dwIndex       = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST); <br>    pInstance     = FindInstanceN (gpProcessObject, dwIndex); <br>    szProcessName = InstanceName (pInstance); <br> <br>    RefreshPviewDlgMemoryData (hPviewDlg, <br>                               pInstance, <br>                               gpProcessObject, <br>                               gpAddressSpaceObject); <br> <br> <br>    dwIndex      = GetCurSelData (hPviewDlg, PVIEW_THREAD_LIST); <br>    pInstance    = FindInstanceN (gpThreadObject, dwIndex); <br>    szThreadName = InstanceName (pInstance); <br> <br>    RefreshPviewDlgThreadPC (hPviewDlg, <br>                             szProcessName, <br>                             szThreadName, <br>                             gpThreadDetailsObject, <br>                             gpCostlyData); <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgRefreshProcess -- <br>// <br>//      Refresh the process list and data in pview dialog. <br>// <br>void    PviewDlgRefreshProcess (HWND hWnd) <br>{ <br>TCHAR   szProcessString[256]; <br>INT     nProcess; <br>INT     nIndex; <br>HWND    hProcessList; <br>DWORD   dwProcessIndex; <br> <br> <br>    // refresh process list <br>    // <br>    hProcessList = GetDlgItem (hWnd, PVIEW_PROCESS_LIST); <br>    nProcess     = GetCurSelText (hProcessList, szProcessString); <br> <br>    SendMessage (hProcessList, WM_SETREDRAW, FALSE, 0); <br>    SendMessage (hProcessList, LB_RESETCONTENT, 0, 0); <br>    SendMessage (hProcessList, LB_SETITEMDATA, 0, 0); <br> <br> <br>    RefreshProcessList (hProcessList, gpProcessObject); <br> <br>    // refresh process data <br>    // <br>    if (nProcess != LB_ERR) <br>        nIndex = ReSelectText (hProcessList, nProcess, szProcessString); <br>    else <br>        nIndex = 0; <br> <br> <br>    dwProcessIndex = SendMessage (hProcessList, LB_GETITEMDATA, nIndex, 0); <br> <br>    RefreshProcessData (hWnd, gpProcessObject, dwProcessIndex); <br> <br>    SendMessage (hProcessList, WM_SETREDRAW, TRUE, 0); <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgRefreshThread -- <br>// <br>//      Refresh the thread list and data in pview dialog. <br>// <br>void    PviewDlgRefreshThread (HWND hWnd) <br>{ <br>TCHAR           szThreadString[256]; <br>INT             nThread; <br>INT             nIndex; <br>HWND            hThreadList; <br>DWORD           dwThreadIndex; <br> <br>PPERF_INSTANCE  pProcessInstance; <br>DWORD           dwProcessIndex; <br> <br> <br>    // get process info <br>    // <br>    dwProcessIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST); <br>    pProcessInstance = FindInstanceN (gpProcessObject, dwProcessIndex); <br> <br> <br>    // refresh thread list <br>    // <br>    hThreadList  = GetDlgItem (hWnd, PVIEW_THREAD_LIST); <br>    nThread      = GetCurSelText (hThreadList, szThreadString); <br> <br>    SendMessage (hThreadList, WM_SETREDRAW, FALSE, 0); <br>    SendMessage (hThreadList, LB_RESETCONTENT, 0, 0); <br>    SendMessage (hThreadList, LB_SETITEMDATA, 0, 0); <br> <br>    RefreshThreadList (hThreadList, gpThreadObject, dwProcessIndex); <br> <br> <br>    // refresh thread data <br>    // <br>    if (nThread != LB_ERR) <br>        nIndex = ReSelectText (hThreadList, nThread, szThreadString); <br>    else <br>        nIndex = 0; <br> <br>    dwThreadIndex    = SendMessage (hThreadList, LB_GETITEMDATA, nIndex, 0); <br> <br>    RefreshThreadData (hWnd, <br>                       gpThreadObject, <br>                       dwThreadIndex, <br>                       gpProcessObject, <br>                       pProcessInstance); <br> <br>    SendMessage (hThreadList, WM_SETREDRAW, TRUE, 0); <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgGetCurSelPriority -- <br>// <br>//      Get the process priority of currently selected process. <br>// <br>WORD    PviewDlgGetCurSelPriority (HWND hWnd) <br>{ <br>DWORD           dwIndex; <br>PPERF_INSTANCE  pInst; <br> <br>    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST); <br>    pInst = FindInstanceN (gpProcessObject, dwIndex); <br>    return ProcessPriority (gpProcessObject, pInst); <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgRefreshCurSelProcess -- <br>// <br>//      Refresh the data of currently selected process. <br>// <br>void    PviewDlgRefreshCurSelProcess (HWND hWnd) <br>{ <br>DWORD   dwIndex; <br> <br>    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST); <br>    RefreshProcessData (hWnd, gpProcessObject, dwIndex); <br> <br>    PviewDlgRefreshThread (hWnd); <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgRefreshCurSelThread -- <br>// <br>//      Refresh the data of currently selected thread. <br>// <br>void    PviewDlgRefreshCurSelThread (HWND hWnd) <br>{ <br>PPERF_INSTANCE  pProcessInstance; <br>DWORD           dwIndex; <br> <br>    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST); <br>    pProcessInstance = FindInstanceN (gpProcessObject, dwIndex); <br> <br>    dwIndex = GetCurSelData (hWnd, PVIEW_THREAD_LIST); <br> <br>    RefreshThreadData (hWnd, <br>                       gpThreadObject, <br>                       dwIndex, <br>                       gpProcessObject, <br>                       pProcessInstance); <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgChangePriority -- <br>// <br>//      Change process priority. <br>// <br>BOOL    PviewDlgChangePriority (HWND hWnd, DWORD wParam, WORD wItem) <br>{ <br>DWORD           dwIndex; <br>PPERF_INSTANCE  pInst; <br>PPERF_COUNTER   pCountID; <br>DWORD           *pProcessID; <br>DWORD           ProcessID; <br>HANDLE          hProcess; <br>BOOL            bStat; <br> <br> <br> <br>    dwIndex = GetCurSelData (hWnd, PVIEW_PROCESS_LIST); <br>    pInst = FindInstanceN (gpProcessObject, dwIndex); <br> <br> <br>    if (pCountID = FindCounter (gpProcessObject, PX_PROCESS_ID)) <br>        { <br>        pProcessID = (DWORD *) CounterData (pInst, pCountID); <br>        ProcessID = *pProcessID; <br>        } <br>    else <br>        { <br>        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0); <br>        SetFocus (GetDlgItem (hWnd, wItem)); <br>        MessageBox (hWnd, <br>                    TEXT("Cannot find ID for this process"), <br>                    TEXT("Set priority"), <br>                    MB_ICONEXCLAMATION|MB_OK); <br>        return FALSE; <br>        } <br> <br> <br>    hProcess = OpenProcess (PROCESS_SET_INFORMATION, FALSE, ProcessID); <br>    if (!hProcess) <br>        { <br>        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0); <br>        SetFocus (GetDlgItem (hWnd, wItem)); <br>        MessageBox (hWnd, <br>                    TEXT("Unable to open the process; Priority not changed"), <br>                    TEXT("Set priority"), <br>                    MB_ICONEXCLAMATION|MB_OK); <br>        return FALSE; <br>        } <br> <br> <br> <br>    switch (wParam) <br>        { <br>        case PVIEW_PRIORITY_HIGH: <br>            bStat = SetPriorityClass (hProcess, HIGH_PRIORITY_CLASS); <br>            break; <br> <br>        case PVIEW_PRIORITY_NORMAL: <br>            bStat = SetPriorityClass (hProcess, NORMAL_PRIORITY_CLASS); <br>            break; <br> <br>        case PVIEW_PRIORITY_IDL: <br>            bStat = SetPriorityClass (hProcess, IDLE_PRIORITY_CLASS); <br>            break; <br> <br>default: <br>    break; <br>        } <br> <br> <br>    CloseHandle (hProcess); <br> <br>    if (!bStat) <br>        { <br>        SendDlgItemMessage (hWnd, wItem, BM_SETCHECK, 1, 0); <br>        SetFocus (GetDlgItem (hWnd, wItem)); <br>        MessageBox (hWnd, <br>                    TEXT("Unable to change priority"), <br>                    TEXT("Set priority"), <br>                    MB_ICONEXCLAMATION|MB_OK); <br>        return FALSE; <br>        } <br> <br> <br>    return TRUE; <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  PviewDlgTerminateProcess -- <br>// <br>//      Terminate the current selected process. <br>// <br>BOOL    PviewDlgTerminateProcess (HWND hPviewDlg) <br>{ <br>DWORD           dwIndex; <br>PPERF_INSTANCE  pInst; <br>PPERF_COUNTER   pCountID; <br>DWORD           *pProcessID; <br>DWORD           ProcessID; <br>HANDLE          hProcess; <br>TCHAR           szTemp[50]; <br> <br> <br>    dwIndex = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST); <br>    pInst = FindInstanceN (gpProcessObject, dwIndex); <br> <br> <br>    if (pCountID = FindCounter (gpProcessObject, PX_PROCESS_ID)) <br>        { <br>        pProcessID = (DWORD *) CounterData (pInst, pCountID); <br>        ProcessID = *pProcessID; <br>        } <br>    else <br>        { <br>        MessageBox (hPviewDlg, <br>                    TEXT("Cannot find ID for this process"), <br>                    TEXT("Terminate Process"), <br>                    MB_ICONEXCLAMATION|MB_OK); <br>        return FALSE; <br>        } <br> <br> <br>    wsprintf (szTemp, TEXT("Terminate process %s (ID %#x)?"), <br>              InstanceName (pInst), ProcessID); <br> <br>    if (MessageBox (hPviewDlg, szTemp, TEXT("Terminate Process"), MB_ICONSTOP|MB_OKCANCEL) != IDOK) <br>        return FALSE; <br> <br> <br>    hProcess = OpenProcess (PROCESS_ALL_ACCESS, FALSE, ProcessID); <br>    if (!hProcess) <br>        { <br>        MessageBox (hPviewDlg, <br>                    TEXT("Unable to open the process; Process not terminated"), <br>                    TEXT("Terminate Process"), <br>                    MB_ICONEXCLAMATION|MB_OK); <br>        return FALSE; <br>        } <br> <br> <br>    if (!TerminateProcess (hProcess, 99)) <br>        { <br>        MessageBox (hPviewDlg, <br>                    TEXT("Unable to terminate the process."), <br>                    TEXT("Terminate Process"), <br>                    MB_ICONEXCLAMATION|MB_OK); <br> <br>        CloseHandle (hProcess); <br>        return FALSE; <br>        } <br> <br> <br>    CloseHandle (hProcess); <br> <br>    return TRUE; <br> <br>} <br> <br> <br> <br> <br>/*************** <br>MemDlg functions <br>***************/ <br> <br>//******************************************************** <br>// <br>//  MemDlgProc -- <br>// <br>//      MemoryDlg procedure <br>// <br>BOOL CALLBACK   MemDlgProc (HWND    hWnd, <br>                            UINT    wMsg, <br>                            WPARAM  wParam, <br>                            LPARAM  lParam) <br>{ <br>static HWND hPviewDlg; <br> <br> <br>    switch (wMsg) <br>        { <br>        case WM_INITDIALOG: <br>            hPviewDlg = (HWND)lParam; <br>            PostMessage (hWnd, WM_COMMAND, MEMORY_REFRESH, 0); <br>            break; <br> <br>        case WM_QUIT: <br>        case WM_CLOSE: <br>            EndDialog (hWnd, TRUE); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD (wParam)) <br>                { <br>                // get the memory statistics for the currently selected <br>                //  process/thread <br>                // <br>                case MEMORY_IMAGE: <br>                    if (HIWORD(wParam) == CBN_DBLCLK || HIWORD(wParam) == CBN_SELCHANGE) <br>                        { <br>                        if (WaitForSingleObject (ghMemUpdateMutex, 0)) <br>                            return FALSE; <br> <br>                        MemDlgRefreshCurSelImage (hWnd, hPviewDlg); <br>                        ReleaseMutex (ghMemUpdateMutex); <br>                        } <br>                    else <br>                        return FALSE; <br>                    break; <br> <br>                // refresh the current memory statistics, <br>                //  retry if we can't get the mutex <br>                // <br>                case MEMORY_REFRESH: <br>                    if (WaitForSingleObject (ghMemUpdateMutex, 1000)) <br>                        { <br>                        // can't get the mutex, retry... <br>                        // <br>                        PostMessage (hWnd, WM_COMMAND, MEMORY_REFRESH, 0); <br>                        return FALSE; <br>                        } <br> <br>                    MemDlgRefresh (hWnd, hPviewDlg); <br>                    ReleaseMutex (ghMemUpdateMutex); <br>                    break; <br> <br>                case IDCANCEL: <br>                case IDOK: <br>                    EndDialog (hWnd, TRUE); <br>                    break; <br> <br>                default: <br>                    return FALSE; <br>                } <br>        default: <br>            return FALSE; <br>        } <br> <br> <br>    return TRUE; <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  MemDlgUpdateThread -- <br>// <br>//      This function runs in a separate thread to collect memory data. <br>// <br>void MemDlgUpdateThread (HWND hPviewDlg) <br>{ <br> <br>    ghMemUpdateMutex = CreateMutex (NULL, TRUE, NULL); <br>    ghMemUpdateEvent = CreateEvent (NULL, FALSE, FALSE, NULL); <br> <br> <br>    while (TRUE) <br>        { <br>        EnableWindow (GetDlgItem (hPviewDlg, PVIEW_MEMORY_DETAIL), FALSE); <br> <br> <br>        gpCostlyData = RefreshPerfData (ghPerfKey, <br>                                        INDEX_COSTLY_OBJ, <br>                                        gpCostlyData, <br>                                        &amp;gCostlyDataSize); <br> <br> <br>        gpAddressSpaceObject  = FindObject (gpCostlyData, PX_PROCESS_ADDRESS_SPACE); <br>        gpThreadDetailsObject = FindObject (gpCostlyData, PX_THREAD_DETAILS); <br>        gpImageObject         = FindObject (gpCostlyData, PX_IMAGE); <br> <br> <br>        EnableWindow (GetDlgItem (hPviewDlg, PVIEW_MEMORY_DETAIL), TRUE); <br> <br>        ReleaseMutex (ghMemUpdateMutex); <br> <br>        PostMessage (hPviewDlg, WM_COMMAND, PVIEW_REFRESH_COSTLY_DATA, 0); <br> <br> <br>        WaitForSingleObject (ghMemUpdateEvent, INFINITE); <br>        WaitForSingleObject (ghMemUpdateMutex, INFINITE); <br>        } <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  MemDlgRefresh -- <br>// <br>//      Refresh the memory dialog. <br>// <br>void MemDlgRefresh (HWND hMemDlg, HWND hPviewDlg) <br>{ <br>HWND            hImageList; <br>DWORD           dwIndex; <br>BOOL            bStat; <br>PPERF_INSTANCE  pInstance; <br> <br> <br>    hImageList = GetDlgItem (hMemDlg, MEMORY_IMAGE); <br> <br>    SendMessage (hImageList, WM_SETREDRAW, FALSE, 0); <br>    SendMessage (hImageList, CB_RESETCONTENT, 0, 0); <br>    SendMessage (hImageList, CB_SETITEMDATA, 0, 0); <br> <br>    dwIndex = GetCurSelData (hPviewDlg, PVIEW_PROCESS_LIST); <br>    pInstance = FindInstanceN (gpProcessObject, dwIndex); <br> <br>    bStat = RefreshMemoryDlg (hMemDlg, <br>                              pInstance, <br>                              gpProcessObject, <br>                              gpAddressSpaceObject, <br>                              gpImageObject); <br> <br>    SendMessage (hImageList, WM_SETREDRAW, TRUE, 0); </code></pre>
<p>
</p>
<pre><code>SendMessage (hImageList, CB_SETCURSEL, 0, 0); <br> <br>    if (!bStat) <br>        { <br>        MessageBox (hMemDlg, <br>                    TEXT("Unable to retrieve memory detail"), <br>                    TEXT("Memory detail"), <br>                    MB_ICONSTOP|MB_OK); <br>        PostMessage (hMemDlg, WM_CLOSE, 0, 0); <br>        } <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  MemDlgRefreshCurSelImage -- <br>// <br>//      Refresh the current selected image for memory dialog. <br>// <br>void    MemDlgRefreshCurSelImage (HWND hMemDlg, HWND hPviewDlg) <br>{ <br>HWND    hList; <br>INT     nIndex; <br>DWORD   dwIndex; <br> <br> <br>    hList = GetDlgItem (hMemDlg, MEMORY_IMAGE); <br>    nIndex = SendMessage (hList, CB_GETCURSEL, 0, 0); <br> <br>    if (nIndex == CB_ERR) <br>        nIndex = 0; <br> <br>    dwIndex = SendMessage (hList, CB_GETITEMDATA, nIndex, 0); <br> <br>    if (dwIndex == 0xFFFFFFFF) <br>        MemDlgRefresh (hMemDlg, hPviewDlg); <br>    else <br>        RefreshMemoryDlgImage (hMemDlg, dwIndex, gpImageObject); <br> <br>} <br> <br> <br> <br> <br>/**************** <br>utility functions <br>****************/ <br> <br>//******************************************************** <br>// <br>//  GetCurSelText -- <br>// <br>//      Get the text of current selection.  Used for later ReSelectText(). <br>// <br>INT     GetCurSelText (HWND hList, LPTSTR str) <br>{ <br>INT     Index; <br>INT     Length; <br> <br>    Index = SendMessage (hList, LB_GETCURSEL, 0, 0); <br>    Length = SendMessage (hList, LB_GETTEXT, Index, (DWORD)str); <br> <br>    return Index; <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  GetCurSelData -- <br>// <br>//      Get the data associated with the current selection. <br>// <br>DWORD   GetCurSelData (HWND hWnd, DWORD dwList) <br>{ <br>HWND    hList; <br>INT     nIndex; <br>DWORD   dwIndex; <br> <br> <br>    hList  = GetDlgItem (hWnd, dwList); <br>    nIndex = SendMessage (hList, LB_GETCURSEL, 0, 0); <br> <br>    if (nIndex == LB_ERR) <br>        nIndex = 0; <br> <br>    dwIndex = SendMessage (hList, LB_GETITEMDATA, nIndex, 0); <br> <br>    return dwIndex; <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  ReSelectText -- <br>// <br>//      Reselect the line specified by str.  Returns the new index.  If cannot <br>//      find the line or any error, then 0 is returned. <br>// <br>INT     ReSelectText (HWND hList, INT StartIndex, LPTSTR str) <br>{ <br>INT     Index; <br>INT     Length; <br>TCHAR   SaveChar = TEXT('\0'); <br> <br> <br>    Index = SendMessage (hList, LB_FINDSTRING, StartIndex, (DWORD)str); <br> <br>    if (Index == LB_ERR) <br>        { <br>        Length = lstrlen (str); <br> <br>        while (Index == LB_ERR &amp;&amp; Length) <br>            { <br>            SaveChar = str[Length-1]; <br>            str[Length-1] = TEXT('\0'); <br> <br>            Index = SendMessage (hList, LB_FINDSTRING, StartIndex, (DWORD)str); <br> <br>            str[Length-1] = SaveChar; <br>            Length--; <br>            } <br>        } <br> <br>    if (Index == LB_ERR) <br>        return 0; <br>    else <br>        { <br>        SendMessage (hList, LB_SETCURSEL, Index, 0); <br>        return Index; <br>        } <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  SetPerfIndexes <br>// <br>//      Setup the perf data indexes. <br>// <br>void    SetPerfIndexes (HWND hWnd) <br>{ <br>LPTSTR  TitleBuffer; <br>LPTSTR  *Title; <br>DWORD   Last; <br>TCHAR   szTemp[50]; <br>DWORD   dwR; <br> <br> <br>    dwR = GetPerfTitleSz (ghMachineKey, ghPerfKey, &amp;TitleBuffer, &amp;Title, &amp;Last); <br> <br>    if (dwR != ERROR_SUCCESS) <br>        { <br>        wsprintf (szTemp, TEXT("Unable to retrieve counter indexes, ERROR -&gt; %#x"), dwR); <br>        MessageBox (hWnd, szTemp, TEXT("Pviewer"), MB_OK|MB_ICONEXCLAMATION); <br>        return; <br>        } <br> <br> <br>    PX_PROCESS                       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS); <br>    PX_PROCESS_CPU                   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_CPU); <br>    PX_PROCESS_PRIV                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIV); <br>    PX_PROCESS_USER                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_USER); <br>    PX_PROCESS_WORKING_SET           = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_WORKING_SET); <br>    PX_PROCESS_PEAK_WS               = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PEAK_WS); <br>    PX_PROCESS_PRIO                  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIO); <br>    PX_PROCESS_ELAPSE                = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ELAPSE); <br>    PX_PROCESS_ID                    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ID); <br>    PX_PROCESS_PRIVATE_PAGE          = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_PAGE); <br>    PX_PROCESS_VIRTUAL_SIZE          = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_VIRTUAL_SIZE); <br>    PX_PROCESS_PEAK_VS               = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PEAK_VS); <br>    PX_PROCESS_FAULT_COUNT           = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_FAULT_COUNT); <br> <br>    PX_THREAD                        = GetTitleIdx (hWnd, Title, Last, PN_THREAD); <br>    PX_THREAD_CPU                    = GetTitleIdx (hWnd, Title, Last, PN_THREAD_CPU); <br>    PX_THREAD_PRIV                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PRIV); <br>    PX_THREAD_USER                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_USER); <br>    PX_THREAD_START                  = GetTitleIdx (hWnd, Title, Last, PN_THREAD_START); <br>    PX_THREAD_SWITCHES               = GetTitleIdx (hWnd, Title, Last, PN_THREAD_SWITCHES); <br>    PX_THREAD_PRIO                   = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PRIO); <br>    PX_THREAD_BASE_PRIO              = GetTitleIdx (hWnd, Title, Last, PN_THREAD_BASE_PRIO); <br>    PX_THREAD_ELAPSE                 = GetTitleIdx (hWnd, Title, Last, PN_THREAD_ELAPSE); <br> <br>    PX_THREAD_DETAILS                = GetTitleIdx (hWnd, Title, Last, PN_THREAD_DETAILS); <br>    PX_THREAD_PC                     = GetTitleIdx (hWnd, Title, Last, PN_THREAD_PC); <br> <br>    PX_IMAGE                         = GetTitleIdx (hWnd, Title, Last, PN_IMAGE); <br>    PX_IMAGE_NOACCESS                = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_NOACCESS); <br>    PX_IMAGE_READONLY                = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_READONLY); <br>    PX_IMAGE_READWRITE               = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_READWRITE); <br>    PX_IMAGE_WRITECOPY               = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_WRITECOPY); <br>    PX_IMAGE_EXECUTABLE              = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXECUTABLE); <br>    PX_IMAGE_EXE_READONLY            = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_READONLY); <br>    PX_IMAGE_EXE_READWRITE           = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_READWRITE); <br>    PX_IMAGE_EXE_WRITECOPY           = GetTitleIdx (hWnd, Title, Last, PN_IMAGE_EXE_WRITECOPY); <br> <br>    PX_PROCESS_ADDRESS_SPACE         = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_ADDRESS_SPACE); <br>    PX_PROCESS_PRIVATE_NOACCESS      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_NOACCESS); <br>    PX_PROCESS_PRIVATE_READONLY      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_READONLY); <br>    PX_PROCESS_PRIVATE_READWRITE     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_READWRITE); <br>    PX_PROCESS_PRIVATE_WRITECOPY     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_WRITECOPY); <br>    PX_PROCESS_PRIVATE_EXECUTABLE    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXECUTABLE); <br>    PX_PROCESS_PRIVATE_EXE_READONLY  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_READONLY); <br>    PX_PROCESS_PRIVATE_EXE_READWRITE = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_READWRITE); <br>    PX_PROCESS_PRIVATE_EXE_WRITECOPY = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_PRIVATE_EXE_WRITECOPY); <br> <br>    PX_PROCESS_MAPPED_NOACCESS       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_NOACCESS); <br>    PX_PROCESS_MAPPED_READONLY       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_READONLY); <br>    PX_PROCESS_MAPPED_READWRITE      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_READWRITE); <br>    PX_PROCESS_MAPPED_WRITECOPY      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_WRITECOPY); <br>    PX_PROCESS_MAPPED_EXECUTABLE     = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXECUTABLE); <br>    PX_PROCESS_MAPPED_EXE_READONLY   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_READONLY); <br>    PX_PROCESS_MAPPED_EXE_READWRITE  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_READWRITE); <br>    PX_PROCESS_MAPPED_EXE_WRITECOPY  = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_MAPPED_EXE_WRITECOPY); <br> <br>    PX_PROCESS_IMAGE_NOACCESS        = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_NOACCESS); <br>    PX_PROCESS_IMAGE_READONLY        = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_READONLY); <br>    PX_PROCESS_IMAGE_READWRITE       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_READWRITE); <br>    PX_PROCESS_IMAGE_WRITECOPY       = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_WRITECOPY); <br>    PX_PROCESS_IMAGE_EXECUTABLE      = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXECUTABLE); <br>    PX_PROCESS_IMAGE_EXE_READONLY    = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_READONLY); <br>    PX_PROCESS_IMAGE_EXE_READWRITE   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_READWRITE); <br>    PX_PROCESS_IMAGE_EXE_WRITECOPY   = GetTitleIdx (hWnd, Title, Last, PN_PROCESS_IMAGE_EXE_WRITECOPY); <br> <br> <br>    wsprintf (INDEX_PROCTHRD_OBJ, TEXT("%ld %ld"), PX_PROCESS, PX_THREAD); <br>    wsprintf (INDEX_COSTLY_OBJ, TEXT("%ld %ld %ld"), <br>              PX_PROCESS_ADDRESS_SPACE, PX_IMAGE, PX_THREAD_DETAILS); <br> <br> <br>    LocalFree (TitleBuffer); <br>    LocalFree (Title); <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  GetTitleIdx <br>// <br>//      Searches Titles[] for Name.  Returns the index found. <br>// <br>DWORD   GetTitleIdx (HWND hWnd, LPTSTR Title[], DWORD LastIndex, LPTSTR Name) <br>{ <br>DWORD   Index; <br> <br>    for (Index = 0; Index &lt;= LastIndex; Index++) <br>        if (Title[Index]) <br>            if (!lstrcmpi (Title[Index], Name)) <br>                return Index; <br> <br>    MessageBox (hWnd, Name, TEXT("Pviewer cannot find index"), MB_OK); <br>    return 0; <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  SetListBoxTabStops -- <br>// <br>//      Set tab stops in the two list boxes. <br>// <br>void    SetListBoxTabStops (HWND hWnd) <br>{ <br>HWND    hListBox; <br>INT     Tabs[4] = {22*4, 36*4, 44*4}; <br> <br>    hListBox = GetDlgItem (hWnd, PVIEW_PROCESS_LIST); <br>    SendMessage (hListBox, LB_SETTABSTOPS, 3, (DWORD)Tabs); <br> <br>    hListBox = GetDlgItem (hWnd, PVIEW_THREAD_LIST); <br>    SendMessage (hListBox, LB_SETTABSTOPS, 3, (DWORD)Tabs); <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  SetLocalMachine -- <br>// <br>//      Set local machine as performance data focus. <br>// <br>//      Sets    ghPerfKey <br>//              ghMachineKey <br>//              gszMachineName <br>//              gszCurrentMachine <br>// <br>void    SetLocalMachine (void) <br>{ <br>TCHAR   szName[MACHINE_NAME_SIZE]; <br>DWORD   dwSize = MACHINE_NAME_SIZE; <br> <br> <br>    // close remote connections, if any <br>    // <br>    if (ghPerfKey != HKEY_PERFORMANCE_DATA) <br>        RegCloseKey (ghPerfKey); <br> <br>    if (ghMachineKey != HKEY_LOCAL_MACHINE) <br>        RegCloseKey (ghMachineKey); <br> <br> <br>    // set to registry keys on local machine <br>    // <br>    ghPerfKey    = HKEY_PERFORMANCE_DATA; <br>    ghMachineKey = HKEY_LOCAL_MACHINE; <br> <br> <br> <br>    // get computer name <br>    GetComputerName (szName, &amp;dwSize); <br> <br> <br> <br>    if (szName[0] != '\\' || szName[1] != '\\')     // must have two '\\' <br>        { <br>        wsprintf (gszMachineName, TEXT("\\\\%s"), szName); <br>        lstrcpy (gszCurrentMachine, gszMachineName); <br>        } <br>    else <br>        { <br>        lstrcpy (gszMachineName, szName); <br>        lstrcpy (gszCurrentMachine, gszMachineName); <br>        } <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  ConnectComputer -- <br>// <br>//      Connect to a computer with name entered in PVIEW_COMPUTER. <br>//      If a new connection is made, then return TRUE else return FALSE. <br>// <br>//      Sets    gszCurrentMachine <br>//              ghPerfKey <br>//              ghMachineKey <br>// <br>BOOL    ConnectComputer (HWND hWnd) <br>{ <br>DWORD   dwR; <br>HKEY    hKey; <br>TCHAR   szTemp[MACHINE_NAME_SIZE]; <br>TCHAR   szTemp2[MACHINE_NAME_SIZE+100]; <br>BOOL    bResult = TRUE; <br>MSG     Msg; <br> <br> <br> <br>    SetCursor (ghCursor[1]); <br> <br> <br>    if (!GetDlgItemText (hWnd, PVIEW_COMPUTER, szTemp, sizeof (szTemp))) <br>        { <br>        SetLocalMachine (); <br>        SetDlgItemText (hWnd, PVIEW_COMPUTER, gszCurrentMachine); <br>        } <br> <br>    else if (!lstrcmpi (szTemp, gszCurrentMachine))     // didn't change name <br>        bResult = FALSE; <br> <br>    else if (!lstrcmpi (szTemp, gszMachineName))        // local machine <br>        { <br>        SetLocalMachine (); <br>        EnableControls (hWnd); <br>        } <br> <br>    else <br>        { <br>        // a remote machine, connect to it <br>        // <br>        dwR = RegConnectRegistry (szTemp, HKEY_PERFORMANCE_DATA, &amp;hKey); <br> <br>        if (dwR != ERROR_SUCCESS) <br>            { <br>            wsprintf (szTemp2, TEXT("Cannot connect to computer %s"), szTemp); <br>            MessageBox (hWnd, szTemp2, TEXT(""), MB_ICONEXCLAMATION|MB_OK); <br> <br>            SetDlgItemText (hWnd, PVIEW_COMPUTER, gszCurrentMachine); <br> <br>            bResult = FALSE; <br>            } <br>        else <br>            { <br>            // connected <br>            // <br>            lstrcpy (gszCurrentMachine, szTemp); <br> <br>            if (ghPerfKey != HKEY_PERFORMANCE_DATA) <br>                RegCloseKey (ghPerfKey); <br> <br>            ghPerfKey = hKey; <br> <br> <br> <br>            DisableControls (hWnd); <br> <br> <br> <br>            // we also need to get the remote machine's title indexes. <br>            // <br>            dwR = RegConnectRegistry (gszCurrentMachine, HKEY_LOCAL_MACHINE, &amp;hKey); <br> <br>            if (ghMachineKey != HKEY_LOCAL_MACHINE) <br>                RegCloseKey (ghMachineKey); <br> <br>            if (dwR == ERROR_SUCCESS) <br>                ghMachineKey = hKey; <br>            else <br>                // unable to connect, so we'll use our own indexes. <br>                // <br>                ghMachineKey = HKEY_LOCAL_MACHINE; <br>            } <br>        } <br> <br> <br> <br>    // Remove all mouse and key messages. They are not accepted <br>    //  while the cursor is a hourglass. <br>    // <br>    while (PeekMessage (&amp;Msg, hWnd, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)); <br>    while (PeekMessage (&amp;Msg, hWnd, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE)); <br> <br>    SetCursor (ghCursor[0]); <br> <br> <br>    EnableWindow (GetDlgItem (hWnd, PVIEW_CONNECT), FALSE); <br> <br> <br>    return bResult; <br> <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  DisableControls -- <br>// <br>//      Disable controls that don't make sense on remote machine <br>// <br>void DisableControls (HWND hPviewDlg) <br>{ <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_TERMINATE), FALSE); <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_HIGH), FALSE); <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_NORMAL), FALSE); <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_IDL), FALSE); <br>} <br> <br> <br> <br> <br>//******************************************************** <br>// <br>//  EnableControls -- <br>// <br>//      Enable controls disabled by DisableControl(). <br>// <br>void EnableControls (HWND hPviewDlg) <br>{ <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_TERMINATE), TRUE); <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_HIGH), TRUE); <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_NORMAL), TRUE); <br>    EnableWindow (GetDlgItem (hPviewDlg, PVIEW_PRIORITY_IDL), TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
