<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PSTAT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5759"></a>PSTAT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "pwalk.h" <br> <br>#define ONE_K      1024 <br>#define ONE_MEG       1048576 <br> <br>extern HFONT     hFont; <br>extern LPVOID     lpWalkerList; <br>extern DBGPROCESS    *lpChildProcess; <br>extern int     yChar; <br>extern SIZE     sChar0; <br> <br>/* static variables that determine size of 3D status box */ <br>intxSTATBOX; <br>intcxSTATBOX; <br>intdxSTATBOX; <br>intySTATBOX; <br>intdyuSTATBOX; <br>intdylSTATBOX; <br> <br> <br> <br>void WINAPI TallyProcessStats (HWND, int *, int *, int *); <br>void WINAPI DrawBorders (HWND, LPPAINTSTRUCT); <br>void WINAPI DrawStatusText (HWND, LPPAINTSTRUCT, char *, COLORREF); <br> <br> <br>/* status window proc */ <br>LONG WINAPI StatusWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>  LONG      lRet = 1; <br>static  BOOL      bDefault; <br>static  char      szDefault[MAX_PATH]; <br>static  COLORREF    crText; <br> <br>    switch (uMsg) <br>{ <br>case WM_CREATE: <br>    { <br>    RECT    rc; <br> <br>    SetWindowLong (hWnd, <br>   WXB_HPENHILITE, <br>   (LONG)CreatePen (PS_SOLID, 0, GetSysColor (COLOR_BTNHIGHLIGHT))); <br>    SetWindowLong (hWnd, <br>   WXB_HPENSHADOW, <br>   (LONG)CreatePen (PS_SOLID, 0, GetSysColor (COLOR_BTNSHADOW))); <br> <br>    /* initialize default status text */ <br>    LoadString (GetModuleHandle (NULL), <br>IDS_STATUSREADY, <br>szDefault, <br>sizeof (szDefault)); <br>    crText = GetSysColor (COLOR_WINDOWTEXT); <br> <br>    /* add rewalk button */ <br>    GetClientRect (GetParent (hWnd), &amp;rc); <br>    CreateWindow ("button", <br>  "Rewalk", <br>  WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <br>  rc.right-74, -1, 75, sChar0.cy+10*GetSystemMetrics (SM_CYBORDER), <br>  hWnd, <br>  (HMENU)IDC_REWALK, <br>  GetModuleHandle (NULL), <br>  NULL); <br> <br>    bDefault = TRUE; <br>    } <br>    break; <br> <br>case WM_SIZE: <br>    { <br>    RECT    rc; <br> <br>    GetClientRect (GetParent (hWnd), &amp;rc); <br> <br>    xSTATBOX = 10 * GetSystemMetrics (SM_CXBORDER); <br>    cxSTATBOX = rc.right/3 + 50; <br>    dxSTATBOX = 4 * GetSystemMetrics (SM_CXBORDER); <br>    ySTATBOX = 2 * GetSystemMetrics (SM_CYBORDER); <br>    dyuSTATBOX = 1 * GetSystemMetrics (SM_CYBORDER); <br>    dylSTATBOX = 2 * GetSystemMetrics (SM_CYBORDER); <br> <br>    /* move child windows in view */ <br>    MoveWindow (GetDlgItem (hWnd, IDC_REWALK), <br>rc.right-74, <br>-1, <br>75, <br>yChar+10*GetSystemMetrics (SM_CYBORDER), <br>TRUE); <br> <br>    /* make sure we repaint correctly */ <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    } <br>    break; <br> <br>case WM_TIMER: <br>    { <br>    RECT    rcStatus; <br> <br>    KillTimer (hWnd, IDT_STATUS); <br>    bDefault = TRUE; <br>    /* invalidate status text area */ <br>    SetRect (&amp;rcStatus, <br>     xSTATBOX+1, <br>     ySTATBOX+1, <br>     xSTATBOX+cxSTATBOX, <br>     ySTATBOX+dylSTATBOX+dyuSTATBOX+yChar); <br>    InvalidateRect (hWnd, &amp;rcStatus, TRUE); <br>    crText = GetSysColor (COLOR_WINDOWTEXT); <br>    } <br>    break; <br> <br>case WM_SETTEXT: <br>    { <br>    RECT    rcStatus; <br> <br>    /* release current string */ <br>    if (GetWindowLong (hWnd, WXB_LPWINDOWTEXT)) <br>LocalFree ((HLOCAL)GetWindowLong (hWnd, WXB_LPWINDOWTEXT)); <br>    SetWindowLong (hWnd, WXB_LPWINDOWTEXT, 0); <br> <br>    /* if null string, reset to default */ <br>    if ((char *)lParam == NULL) <br>{ <br>bDefault = TRUE; <br>crText = GetSysColor (COLOR_WINDOWTEXT); <br>} <br>    else <br>{ <br>crText = (COLORREF)wParam; <br> <br>/* allocate space for new string */ <br>SetWindowLong (hWnd, <br>       WXB_LPWINDOWTEXT, <br>       (LONG)LocalAlloc (LPTR, strlen ((LPSTR)lParam)+1)); <br>strcpy ((char *)GetWindowLong (hWnd, WXB_LPWINDOWTEXT), (char *)lParam); <br> <br>/* restart five second timer */ <br>KillTimer (hWnd, IDT_STATUS); <br>SetTimer (hWnd, IDT_STATUS, 5000, NULL); <br> <br>bDefault = FALSE; <br>} <br> <br>    /* invalidate status text area */ <br>    SetRect (&amp;rcStatus, <br>     xSTATBOX+1, <br>     ySTATBOX+1, <br>     xSTATBOX+cxSTATBOX, <br>     ySTATBOX+dylSTATBOX+dyuSTATBOX+yChar); <br>    InvalidateRect (hWnd, &amp;rcStatus, TRUE); <br>    } <br>    break; <br> <br>case WM_PAINT: <br>    { <br>    PAINTSTRUCT    ps; <br>    RECT   rc; <br> <br>    BeginPaint (hWnd, &amp;ps); <br>    GetClientRect (hWnd, &amp;rc); <br> <br>    /* draw 3D effects in window */ <br>    DrawBorders (hWnd, &amp;ps); <br> <br>    /* update text */ <br>    if (bDefault) <br>DrawStatusText (hWnd, &amp;ps, szDefault, crText); <br>    else <br>DrawStatusText (hWnd, <br>&amp;ps, <br>(char *)GetWindowLong (hWnd, WXB_LPWINDOWTEXT), <br>crText); <br> <br>    EndPaint (hWnd, &amp;ps); <br>    } <br>    break; <br> <br>/* user defined message for updating child process information */ <br>case UM_UPDATE: <br>    EnableWindow (GetDlgItem (hWnd, IDC_REWALK), ((LPVOID)wParam != NULL)); <br>    break; <br> <br>case WM_COMMAND: <br>    if (LOWORD (wParam) == IDC_REWALK) <br>PostMessage (GetParent (hWnd), WM_COMMAND, IDM_PROCESSREWALK, 0); <br>    break; <br> <br>case WM_DESTROY: <br>    /* free pen objects */ <br>    DeleteObject ((HPEN)GetWindowLong (hWnd, WXB_HPENHILITE)); <br>    DeleteObject ((HPEN)GetWindowLong (hWnd, WXB_HPENSHADOW)); <br> <br>    /* free local memory from window text */ <br>    if (GetWindowLong (hWnd, WXB_LPWINDOWTEXT)) <br>LocalFree ((HLOCAL)GetWindowLong (hWnd, WXB_LPWINDOWTEXT)); <br>    break; <br> <br>default: <br>    lRet = DefWindowProc (hWnd, uMsg, wParam, lParam); <br>    break; <br>} <br> <br>    return lRet; <br>} <br> <br> <br> <br> <br>/* system statistics window proc */ <br>LONG WINAPI SysStatWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>    LONG    lRet = 1; <br> <br>static  MEMORYSTATUS  msInfo, msInfoOld; <br>static  SYSTEM_INFO  sysInfo, sysInfoOld; <br>static  DWORD   dwFreeDiskOld, dwFreeDisk; <br>static  DWORD   dwTotalDiskOld, dwTotalDisk; <br> <br>    switch (uMsg) <br>{ <br>case WM_CREATE: <br>    /* get system info */ <br>    GlobalMemoryStatus (&amp;msInfo); <br>    GetSystemInfo (&amp;sysInfo); <br>    GetFreeDiskSpace (&amp;dwTotalDisk, &amp;dwFreeDisk); <br> <br>    /* update old data with current data */ <br>    msInfoOld = msInfo; <br>    sysInfoOld = sysInfo; <br>    dwTotalDiskOld = dwTotalDisk; <br>    dwFreeDiskOld = dwFreeDisk; <br> <br>    /* create buttons controls */ <br>    CreateWindow ("button", <br>  "Refresh", <br>  WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, <br>  100, 210, 75, 25, <br>  hWnd, <br>  (HMENU)IDC_REFRESH, <br>  GetModuleHandle (NULL), <br>  NULL); <br> <br>    CreateWindow ("button", <br>  "Cancel", <br>  WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <br>  205, 210, 75, 25, <br>  hWnd, <br>  (HMENU)IDC_CANCEL, <br>  GetModuleHandle (NULL), <br>  NULL); <br>    break; <br> <br>case WM_CHAR: <br>    switch (wParam) <br>{ <br>case VK_RETURN: <br>    GlobalMemoryStatus (&amp;msInfo); <br>    GetSystemInfo (&amp;sysInfo); <br>    GetFreeDiskSpace (&amp;dwTotalDisk, &amp;dwFreeDisk); <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    UpdateWindow (hWnd); <br>    break; <br> <br>case VK_ESCAPE: <br>    DestroyWindow (hWnd); <br>    break; <br>} <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>{ <br>case IDC_REFRESH: <br>    /* save previous values */ <br>    msInfoOld = msInfo; <br>    sysInfoOld = sysInfo; <br>    dwTotalDiskOld = dwTotalDisk; <br>    dwFreeDiskOld = dwFreeDisk; <br> <br>    /* get current values */ <br>    GlobalMemoryStatus (&amp;msInfo); <br>    GetSystemInfo (&amp;sysInfo); <br>    GetFreeDiskSpace (&amp;dwTotalDisk, &amp;dwFreeDisk); <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    UpdateWindow (hWnd); <br>    break; <br> <br>case IDC_CANCEL: <br>    DestroyWindow (hWnd); <br>    break; <br>} <br>    break; <br> <br> <br>case WM_PAINT: <br>    { <br>    PAINTSTRUCT    ps; <br>    char   szText[100]; <br>    HFONT   hOldFont; <br>    int    nLen; <br>    SIZE   size; <br>    POINT   pt; <br>    COLORREF   crText; <br> <br>    BeginPaint (hWnd, &amp;ps); <br> <br>    /* set background mode to transparent */ <br>    SetBkMode (ps.hdc, TRANSPARENT); <br>    hOldFont = SelectObject (ps.hdc, hFont); <br> <br>    /* draw vertical separating line */ <br>    MoveToEx (ps.hdc, 395, 5, &amp;pt); <br>    LineTo (ps.hdc, 395, 200); <br> <br>    /* refresh change header */ <br>    wsprintf (szText, "%13s", "current value"); <br>    SetRect (&amp;(ps.rcPaint), 0, 5, 395, 20); <br>    ExtTextOut (ps.hdc, 275, 5, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* refresh change header */ <br>    wsprintf (szText, "%10s", "changed by"); <br>    SetRect (&amp;(ps.rcPaint), 395, 5, 500, 20); <br>    ExtTextOut (ps.hdc, 400, 5, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* memory load statistic */ <br>    nLen = wsprintf (szText, "%30s     %10lu", "Relative memory load [0-100]: ", msInfo.dwMemoryLoad); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 20, 395, 35); <br>    ExtTextOut (ps.hdc, 10, 20, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>    if (msInfo.dwMemoryLoad &gt; msInfoOld.dwMemoryLoad) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (0, 100, 0)); <br>wsprintf (szText, "+%-1lu", (msInfo.dwMemoryLoad-msInfoOld.dwMemoryLoad)); <br>SetRect (&amp;(ps.rcPaint), 395, 20, 500, 35); <br>ExtTextOut (ps.hdc, 400, 20, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br>    else if (msInfo.dwMemoryLoad &lt; msInfoOld.dwMemoryLoad) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (100, 0, 0)); <br>wsprintf (szText, "-%-1lu", (msInfoOld.dwMemoryLoad-msInfo.dwMemoryLoad)); <br>SetRect (&amp;(ps.rcPaint), 395, 20, 500, 65); <br>ExtTextOut (ps.hdc, 400, 20, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br> <br>    /* pagesize */ <br>    nLen = wsprintf (szText, "%22s             %10lub", "Pagesize granularity: ", sysInfo.dwPageSize); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 35, 395, 50); <br>    ExtTextOut (ps.hdc, 10, 35, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* total physical memory */ <br>    nLen = wsprintf (szText, "%23s            %10luKb", "Total physical memory: ", msInfo.dwTotalPhys/ONE_K); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 50, 395, 65); <br>    ExtTextOut (ps.hdc, 10, 50, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* available physical memory */ <br>    nLen = wsprintf (szText, "%27s        %10luKb", "Available physical memory: ", msInfo.dwAvailPhys/ONE_K); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 65, 395, 80); <br>    ExtTextOut (ps.hdc, 10, 65, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>    if (msInfo.dwAvailPhys &gt; msInfoOld.dwAvailPhys) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (0, 100, 0)); <br>wsprintf (szText, "+%-1luKb", (msInfo.dwAvailPhys-msInfoOld.dwAvailPhys)/ONE_K); <br>SetRect (&amp;(ps.rcPaint), 395, 65, 500, 80); <br>ExtTextOut (ps.hdc, 400, 65, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br>    else if (msInfo.dwAvailPhys &lt; msInfoOld.dwAvailPhys) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (100, 0, 0)); <br>wsprintf (szText, "-%-1luKb", (msInfoOld.dwAvailPhys-msInfo.dwAvailPhys)/ONE_K); <br>SetRect (&amp;(ps.rcPaint), 395, 65, 500, 80); <br>ExtTextOut (ps.hdc, 400, 65, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br> <br>    /* total pagefile space */ <br>    nLen = wsprintf (szText, "%24s           %10luMb", "Maximum pagefile space: ", msInfo.dwTotalPageFile/ONE_MEG); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 80, 395, 95); <br>    ExtTextOut (ps.hdc, 10, 80, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>    if (msInfo.dwTotalPageFile &gt; msInfoOld.dwTotalPageFile) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (0, 100, 0)); <br>wsprintf (szText, "+%-1luMb", (msInfo.dwTotalPageFile-msInfoOld.dwTotalPageFile)/ONE_MEG); <br>SetRect (&amp;(ps.rcPaint), 395, 80, 500, 95); <br>ExtTextOut (ps.hdc, 400, 80, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br>    else if (msInfo.dwTotalPageFile &lt; msInfoOld.dwTotalPageFile) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (100, 0, 0)); <br>wsprintf (szText, "-%-1luMb", (msInfoOld.dwTotalPageFile-msInfo.dwTotalPageFile)/ONE_MEG); <br>SetRect (&amp;(ps.rcPaint), 395, 80, 500, 95); <br>ExtTextOut (ps.hdc, 400, 65, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br> <br>    /* available pagefile space */ <br>    nLen = wsprintf (szText, "%26s         %10luMb", "Available pagefile space: ", (msInfo.dwAvailPageFile)/ONE_MEG); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 95, 395, 110); <br>    ExtTextOut (ps.hdc, 10, 95, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>    if (msInfo.dwAvailPageFile &gt; msInfoOld.dwAvailPageFile) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (0, 100, 0)); <br>wsprintf (szText, "+%-1luKb", (msInfo.dwAvailPageFile-msInfoOld.dwAvailPageFile)/ONE_K); <br>SetRect (&amp;(ps.rcPaint), 395, 95, 500, 110); <br>ExtTextOut (ps.hdc, 400, 95, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br>    else if (msInfo.dwAvailPageFile &lt; msInfoOld.dwAvailPageFile) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (100, 0, 0)); <br>wsprintf (szText, "-%-1luKb", (msInfoOld.dwAvailPageFile-msInfo.dwAvailPageFile)/ONE_K); <br>SetRect (&amp;(ps.rcPaint), 395, 95, 500, 110); <br>ExtTextOut (ps.hdc, 400, 95, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br> <br>    /* total virtual address space */ <br>    nLen = wsprintf (szText, "%29s      %10luMb", "Total virtual address space: ", msInfo.dwTotalVirtual/ONE_MEG); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 110, 395, 125); <br>    ExtTextOut (ps.hdc, 10, 110, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* available virtual address space */ <br>    nLen = wsprintf (szText, "%33s  %10luMb", "Available virtual address space: ", msInfo.dwAvailVirtual/ONE_MEG); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 125, 395, 140); <br>    ExtTextOut (ps.hdc, 10, 125, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* lowest available virtual address */ <br>    nLen = wsprintf (szText, "%25s            %#08lx", "Minimum virtual address: ", sysInfo.lpMinimumApplicationAddress); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 140, 395, 155); <br>    ExtTextOut (ps.hdc, 10, 140, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* highest available virtual address */ <br>    nLen = wsprintf (szText, "%25s            %#08lx", "Maximum virtual address: ", sysInfo.lpMaximumApplicationAddress); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 155, 395, 170); <br>    ExtTextOut (ps.hdc, 10, 155, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* total disk space */ <br>    nLen = wsprintf (szText, "%24s           %10luMb", "Total local disk space: ", dwTotalDisk/ONE_MEG); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 170, 395, 185); <br>    ExtTextOut (ps.hdc, 10, 170, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br> <br>    /* free disk disk space */ <br>    nLen = wsprintf (szText, "%23s            %10luMb", "Free local disk space: ", dwFreeDisk/ONE_MEG); <br>    GetTextExtentPoint (ps.hdc, szText, nLen, &amp;size); <br>    SetRect (&amp;(ps.rcPaint), 0, 185, 395, 200); <br>    ExtTextOut (ps.hdc, 10, 185, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>    if (dwFreeDisk &gt; dwFreeDiskOld) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (0, 100, 0)); <br>wsprintf (szText, "+%-1luMb", (dwFreeDisk-dwFreeDiskOld)/ONE_MEG); <br>SetRect (&amp;(ps.rcPaint), 395, 185, 500, 200); <br>ExtTextOut (ps.hdc, 400, 185, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br>    else if (dwFreeDisk &lt; dwFreeDiskOld) <br>{ <br>crText = SetTextColor (ps.hdc, RGB (100, 0, 0)); <br>wsprintf (szText, "-%-1luMb", (dwFreeDiskOld-dwFreeDisk)/ONE_MEG); <br>SetRect (&amp;(ps.rcPaint), 395, 185, 500, 200); <br>ExtTextOut (ps.hdc, 400, 185, ETO_CLIPPED, &amp;(ps.rcPaint), szText, strlen (szText), 0); <br>SetTextColor (ps.hdc, crText); <br>} <br> <br>    /* replace old font */ <br>    SelectObject (ps.hdc, hOldFont); <br>    EndPaint (hWnd, &amp;ps); <br>    } <br>    break; <br> <br>default: <br>    lRet = DefWindowProc (hWnd, uMsg, wParam, lParam); <br>} <br> <br>    return lRet; <br>} <br> <br> <br> <br> <br>/* process statistics window proc */ <br>LONG WINAPI ProStatWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>  LONG  lRet = 1; <br>static  int nTotalFree, nTotalCommit, nTotalReserve; <br> <br>    switch (uMsg) <br>{ <br>case WM_CREATE: <br>    { <br>    /* create buttons controls */ <br>    CreateWindow ("button", <br>  "Refresh", <br>  WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, <br>  45, 55, 75, 25, <br>  hWnd, <br>  (HMENU)IDC_REFRESH, <br>  GetModuleHandle (NULL), <br>  NULL); <br> <br>    CreateWindow ("button", <br>  "Rewalk", <br>  WS_CHILD | WS_VISIBLE | BS_DEFPUSHBUTTON, <br>  140, 55, 75, 25, <br>  hWnd, <br>  (HMENU)IDM_PROCESSREWALK, <br>  GetModuleHandle (NULL), <br>  NULL); <br> <br>    CreateWindow ("button", <br>  "Cancel", <br>  WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <br>  235, 55, 75, 25, <br>  hWnd, <br>  (HMENU)IDC_CANCEL, <br>  GetModuleHandle (NULL), <br>  NULL); <br> <br>    /* tally process statictics */ <br>    TallyProcessStats (hWnd, &amp;nTotalFree, &amp;nTotalReserve, &amp;nTotalCommit); <br>    } <br>    break; <br> <br>case WM_CHAR: <br>    switch (wParam) <br>{ <br>case VK_RETURN: <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    UpdateWindow (hWnd); <br>    break; <br> <br>case VK_ESCAPE: <br>    DestroyWindow (hWnd); <br>    break; <br>} <br>    break; <br> <br>case WM_PAINT: <br>    { <br>    PAINTSTRUCT    ps; <br>    HFONT   hOldFont; <br>    char   szText[100]; <br> <br>    BeginPaint (hWnd, &amp;ps); <br>    hOldFont = SelectObject (ps.hdc, hFont); <br>    SetBkMode (ps.hdc, TRANSPARENT); <br> <br>    /* total free memory */ <br>    wsprintf (szText, <br>      "%19s          %10luKb", <br>      "Total free memory: ", <br>      nTotalFree/ONE_K); <br>    SetRect (&amp;(ps.rcPaint), ps.rcPaint.left, 0, ps.rcPaint.right, 20); <br>    ExtTextOut (ps.hdc, <br>10, <br>5, <br>ETO_CLIPPED, <br>&amp;(ps.rcPaint), <br>szText, <br>strlen (szText), <br>0); <br> <br>    /* total committed memory */ <br>    wsprintf (szText, <br>      "%24s     %10luKb", <br>      "Total committed memory: ", <br>      nTotalCommit/ONE_K); <br>    SetRect (&amp;(ps.rcPaint), ps.rcPaint.left, 20, ps.rcPaint.right, 35); <br>    ExtTextOut (ps.hdc, <br>10, <br>20, <br>ETO_CLIPPED, <br>&amp;(ps.rcPaint), <br>szText, <br>strlen (szText), <br>0); <br> <br>    /* total reserved memory */ <br>    wsprintf (szText, <br>      "%22s       %10luKb", <br>      "Total reserved memory:", <br>      nTotalReserve/ONE_K); <br>    SetRect (&amp;(ps.rcPaint), ps.rcPaint.left, 35, ps.rcPaint.right, 50); <br>    ExtTextOut (ps.hdc, <br>10, <br>35, <br>ETO_CLIPPED, <br>&amp;(ps.rcPaint), <br>szText, <br>strlen (szText), <br>0); <br> <br>    SelectObject (ps.hdc, hOldFont); <br>    EndPaint (hWnd, &amp;ps); <br>    } <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>{ <br>case IDM_PROCESSREWALK: <br>    { <br>    /* send message to parent to rewalk process */ <br>    SendMessage (GetParent (hWnd), uMsg, wParam, lParam); <br> <br>    /* tally new process statistics */ <br>    TallyProcessStats (hWnd, &amp;nTotalFree, &amp;nTotalReserve, &amp;nTotalCommit); <br> <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    UpdateWindow (hWnd); <br>    } <br>    break; <br> <br>case IDC_REFRESH: <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    UpdateWindow (hWnd); <br>    break; <br> <br>case IDC_CANCEL: <br>    DestroyWindow (hWnd); <br>    break; <br>} <br>    break; <br> <br>default: <br>    lRet = DefWindowProc (hWnd, uMsg, wParam, lParam); <br>} <br> <br>    return lRet; <br>} <br> <br> <br> <br> <br>/* determine process statistics from existing information */ <br>void WINAPI TallyProcessStats ( <br>    HWND    hWnd, <br>    int     *nTotalFree, <br>    int     *nTotalReserve, <br>    int     *nTotalCommit) <br>{ <br>    LPVMOBJECT  lpVMO = (LPVMOBJECT)lpWalkerList; <br>    int   nRegions, i; <br> <br>    *nTotalFree = 0; <br>    *nTotalCommit = 0; <br>    *nTotalReserve = 0; <br> <br>    /* determine number of memory regions by number of entries in listbox */ <br>    nRegions = (int)SendMessage (GetWindow (GetParent (hWnd), GW_CHILD), <br> LB_GETCOUNT, <br> 0, <br> 0); <br> <br>    /* get stats for all memory regions in process */ <br>    for (i=0; i&lt;nRegions; i++) <br>{ <br>if (lpVMO[i].mbi.State &amp; MEM_FREE) <br>    *nTotalFree += lpVMO[i].mbi.RegionSize; <br>else if (lpVMO[i].mbi.State &amp; MEM_COMMIT) <br>    *nTotalCommit += lpVMO[i].mbi.RegionSize; <br>else <br>    *nTotalReserve += lpVMO[i].mbi.RegionSize; <br>} <br>} <br> <br> <br> <br> <br>void WINAPI DrawBorders ( <br>    HWND     hWnd, <br>    LPPAINTSTRUCT    lpps) <br>{ <br>    POINT   pt; <br>    HPEN   hOldPen; <br> <br> <br> <br>    /* draw window hilites for 3D affect */ <br>    hOldPen = SelectObject (lpps-&gt;hdc, (HPEN)GetWindowLong (hWnd, WXB_HPENHILITE)); <br>    /* top line across window */ <br>    MoveToEx (lpps-&gt;hdc, lpps-&gt;rcPaint.left, lpps-&gt;rcPaint.top, &amp;pt); <br>    LineTo (lpps-&gt;hdc, lpps-&gt;rcPaint.right, lpps-&gt;rcPaint.top); <br>    /* bottom line in status box */ <br>    MoveToEx (lpps-&gt;hdc, <br>      xSTATBOX, <br>      ySTATBOX+yChar+dyuSTATBOX+dylSTATBOX, <br>      &amp;pt); <br>    LineTo (lpps-&gt;hdc, <br>    xSTATBOX+cxSTATBOX, <br>    ySTATBOX+yChar+dylSTATBOX+dyuSTATBOX); <br>    /* right line in status box */ <br>    MoveToEx (lpps-&gt;hdc, xSTATBOX+cxSTATBOX, ySTATBOX, &amp;pt); <br>    LineTo (lpps-&gt;hdc, <br>    xSTATBOX+cxSTATBOX, <br>    ySTATBOX+yChar+dylSTATBOX+dyuSTATBOX+1); <br> <br>    /* draw window shadows for 3D affect */ <br>    hOldPen = SelectObject (lpps-&gt;hdc, (HPEN)GetWindowLong (hWnd, WXB_HPENSHADOW)); <br>    /* top line in status box */ <br>    MoveToEx (lpps-&gt;hdc, xSTATBOX, ySTATBOX, &amp;pt); <br>    LineTo (lpps-&gt;hdc, xSTATBOX+cxSTATBOX+1, ySTATBOX); <br>    /* left line in status box */ <br>    MoveToEx (lpps-&gt;hdc, xSTATBOX, ySTATBOX, &amp;pt); <br>    LineTo (lpps-&gt;hdc, xSTATBOX, ySTATBOX+yChar+dylSTATBOX+dyuSTATBOX+1); <br> <br>    SelectObject (lpps-&gt;hdc, hOldPen); <br>} <br> <br> <br> <br> <br>void WINAPI DrawStatusText ( <br>    HWND     hWnd, <br>    LPPAINTSTRUCT    lpps, <br>    char     *lpszText, <br>    COLORREF     crText) <br>{ <br>    HFONT   hOldFont = SelectObject (lpps-&gt;hdc, hFont); <br>    RECT    rcStatus; <br> <br>    SetBkColor (lpps-&gt;hdc, GetSysColor (COLOR_BTNFACE)); <br>    SetTextColor (lpps-&gt;hdc, crText); <br> <br>    SetRect (&amp;rcStatus, <br>     xSTATBOX+1, <br>     ySTATBOX+1, <br>     xSTATBOX+cxSTATBOX, <br>     ySTATBOX+dylSTATBOX+dyuSTATBOX+yChar); <br> <br>    ExtTextOut (lpps-&gt;hdc, <br>xSTATBOX+dxSTATBOX, <br>ySTATBOX+dyuSTATBOX, <br>ETO_OPAQUE | ETO_CLIPPED, <br>&amp;rcStatus, <br>lpszText, <br>strlen (lpszText), <br>NULL); <br> <br>    SelectObject (lpps-&gt;hdc, hOldFont); <br>} <br> <br> <br> <br> <br>void WINAPI SetStatusText ( <br>    HWNDhWnd, <br>    int nIDS_STATUS, <br>    COLORREFcrText) <br>{ <br>    char    szStatus[MAX_PATH]; <br> <br>    LoadString (GetModuleHandle (NULL), nIDS_STATUS, szStatus, sizeof (szStatus)); <br>    SendMessage (GetDlgItem (hWnd, IDC_STATUSWND), WM_SETTEXT, crText, (LONG)szStatus); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
