<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PVIEW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5760"></a>PVIEW.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "pwalk.h" <br> <br>#define BYTE_WIN_WIDTH    77 <br>#define CLINESSHOW   8 <br>#define ABS(x) ((x) &lt; 0? -(x) : (x)) <br> <br>/* externally defined system constants */ <br>extern int    xChar, <br>    yChar, <br>    xScreen, <br>    yScreen, <br>    yFrame, <br>    xFrame, <br>    yCaption, <br>    xVScrollBar; <br>extern HFONT hFont; <br>extern HWND  hMemWnd; <br> <br>voidWINAPI VScrollBytes (HWND, int, int, LPMEMVIEW); <br>voidWINAPI KeyToScrollMsg (HWND, WPARAM); <br>voidWINAPI DisplayBytes (HDC, LPRECT, LPMEMVIEW, LPMEMVIEW); <br>voidWINAPI GetBytesLine (LPBYTE, UINT, DWORD, int, char *); <br>BOOLWINAPI parcmp (LPBYTE, LPBYTE, int, LPBYTE); <br> <br> <br> <br> <br>HWND   WINAPI EnumViewWindows ( <br>    HWND    hWndParent, <br>    HWND    hWndLast) <br>{ <br> <br>    HMENU   hMenu = GetMenu (hWndParent); <br>    HMENU   hViewMenu = GetSubMenu (hMenu, 2); <br>    char    szClass[MAX_PATH]; <br>    char    szCaption[MAX_PATH]; <br>    HWND    hWnd; <br>    int     i; <br> <br>static  int  nWindows; <br>static  ATOM  *aMenuItems = NULL; <br>static  int  iWnd; <br> <br>    /* load window class name */ <br>    LoadString (GetModuleHandle (NULL), IDS_MEMVIEWCLASS, szClass, MAX_PATH); <br> <br>    if (hWndLast == NULL) <br>{ <br>/* start with first window in menu list */ <br>iWnd = 0; <br> <br>/* determine number of windows */ <br>nWindows = GetMenuItemCount (hViewMenu) - 5; <br> <br>/* if no popup windows, just return */ <br>if (nWindows &lt;= 0) <br>    return NULL; <br> <br>/* free memory from last time, if any */ <br>if (aMenuItems != NULL) <br>    LocalFree ((HANDLE)aMenuItems); <br> <br>/* get menuitem IDs */ <br>aMenuItems = (ATOM *)LocalAlloc (LPTR, nWindows*sizeof (ATOM)); <br>for (i=5; i-5&lt;nWindows; i++) <br>    aMenuItems[i-5] = (ATOM)GetMenuItemID (hViewMenu, i); <br>} <br> <br>    else <br>if (iWnd &gt;= nWindows) <br>    return (NULL); <br> <br>    GetAtomName (aMenuItems[iWnd], szCaption, MAX_PATH); <br>    hWnd = FindWindow (szClass, szCaption); <br>    iWnd++; <br> <br>    return (hWnd); <br>} <br> <br> <br> <br>/* activate view window identified by atom */ <br>void   WINAPI ActivateViewWindow ( <br>    ATOM    aCaption) <br>{ <br>    char    szClass[MAX_PATH]; <br>    char    szCaption[MAX_PATH]; <br>    HWND    hWnd; <br> <br>    GetAtomName (aCaption, szCaption, MAX_PATH); <br>    LoadString (GetModuleHandle (NULL), IDS_MEMVIEWCLASS, szClass, MAX_PATH); <br>    hWnd = FindWindow (szClass, szCaption); <br>    BringWindowToTop (hWnd); <br>} <br> <br> <br> <br>/* function creates a window for viewing memory */ <br>HWND  WINAPI ViewMemory ( <br>    HWND      hWndParent, <br>    char      *lpszObject, <br>    LPVOID    lpMem, <br>    int       nSize, <br>    int       nBase) <br>{ <br>    char      szClass[MAX_PATH]; <br> <br>    /* load resource strings for class and window title */ <br>    LoadString (GetModuleHandle (NULL), IDS_MEMVIEWCLASS, szClass, MAX_PATH); <br> <br>    /* create memory view window */ <br>    return (CreateWindow (szClass, <br>  lpszObject, <br>  WS_POPUPWINDOW | WS_VISIBLE | WS_CAPTION | <br>  WS_VSCROLL | WS_THICKFRAME | WS_MAXIMIZEBOX, <br>  nSize,   /* use xposition to pass memory size to window */ <br>  nBase,   /* use yposition to pass base memory location  */ <br>  BYTE_WIN_WIDTH * xChar + xVScrollBar + 2*xFrame + xChar, <br>  yScreen/2, <br>  hWndParent, <br>  NULL, <br>  GetModuleHandle (NULL), <br>  lpMem)); <br>} <br> <br> <br> <br>LONG WINAPI MemWndProc ( <br>    HWND      hWnd, <br>    UINT      uMsg, <br>    WPARAM    wParam, <br>    LPARAM    lParam) <br>{ <br>    LONG       lRet = 1; <br>    MEMVIEW    *pmv = (LPMEMVIEW)GetWindowLong (hWnd, WXB_LPMEMVIEW); <br> <br>     <br>    switch (uMsg) <br>{ <br>case WM_CREATE: <br>    pmv = (LPMEMVIEW)LocalAlloc (LPTR, sizeof (MEMVIEW)); <br>    SetWindowLong (hWnd, WXB_LPMEMVIEW, (LONG)pmv); <br>    SetWindowLong (hWnd, WXB_LPOLDMEMVIEW, 0); <br> <br>    pmv-&gt;lpMem = ((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>    pmv-&gt;nSize = ((LPCREATESTRUCT)lParam)-&gt;x; <br>    pmv-&gt;nBase = ((LPCREATESTRUCT)lParam)-&gt;y; <br>    pmv-&gt;nLines = (pmv-&gt;nSize+15)/16; <br>    pmv-&gt;nExtraBytes = (pmv-&gt;nSize &amp; 0x0000000F); <br>    pmv-&gt;PosV = 0; <br> <br>    /* reposition window with proper x,y positions */ <br>    MoveWindow (hWnd, <br>15, <br>15, <br>((LPCREATESTRUCT)lParam)-&gt;cx, <br>((LPCREATESTRUCT)lParam)-&gt;cy, <br>TRUE); <br>            break; <br> <br>case WM_SIZE: <br>    pmv-&gt;xWin = LOWORD (lParam); <br>    pmv-&gt;yWin = HIWORD (lParam); <br> <br>    pmv-&gt;RangeV = pmv-&gt;nLines-pmv-&gt;yWin/yChar; <br> <br>    if (pmv-&gt;RangeV &lt; 0) <br>pmv-&gt;RangeV = 0; <br> <br>    if (pmv-&gt;PosV &gt; pmv-&gt;RangeV) <br>pmv-&gt;PosV = pmv-&gt;RangeV; <br> <br>    SetScrollRange (hWnd, SB_VERT, 0, pmv-&gt;RangeV, FALSE); <br>    SetScrollPos (hWnd, SB_VERT, pmv-&gt;PosV, TRUE); <br>            break; <br> <br>case WM_PAINT: <br>    { <br>    PAINTSTRUCT    ps; <br> <br>    BeginPaint (hWnd, &amp;ps); <br>    DisplayBytes (ps.hdc, <br>  &amp;(ps.rcPaint), <br>  pmv, <br>  (LPMEMVIEW)GetWindowLong (hWnd, WXB_LPOLDMEMVIEW)); <br>    EndPaint (hWnd, &amp;ps); <br>    } <br>            break; <br> <br>case UM_UPDATE: <br>    InvalidateRect (hWnd, NULL, TRUE); <br>    UpdateWindow (hWnd); <br>    break; <br> <br>        case WM_KEYDOWN: <br>    KeyToScrollMsg (hWnd, wParam); <br>            break; <br> <br>        case WM_VSCROLL: <br>    VScrollBytes (hWnd, LOWORD (wParam), GetScrollPos (hWnd, SB_VERT), pmv); <br>            break; <br> <br>case WM_DESTROY: <br>    { <br>    char szCaption[MAX_PATH]; <br>    LPMEMVIEW lpmv; <br> <br>    /* free virtual memory block  and local memory buffer */ <br>    VirtualFree (pmv-&gt;lpMem, 0, MEM_RELEASE); <br>    LocalFree ((HANDLE)pmv); <br> <br>    /* remove any old view memory */ <br>    if ((lpmv = (LPMEMVIEW)GetWindowLong (hWnd, WXB_LPOLDMEMVIEW)) != NULL) <br>{ <br>VirtualFree (lpmv-&gt;lpMem, 0, MEM_RELEASE); <br>LocalFree ((HANDLE)lpmv); <br>} <br> <br>    /* send message to parent to remove menuitem */ <br>    GetWindowText (hWnd, szCaption, MAX_PATH); <br>    SendMessage (GetParent (hWnd), WM_COMMAND, IDM_REMOVEVIEWWND, (LONG)szCaption); <br>    } <br>            break; <br> <br>        default: <br>    return (DefWindowProc(hWnd, uMsg, wParam, lParam)); <br>            break; <br>} <br>    return 0L; <br>} <br> <br> <br> <br> <br>void  WINAPI VScrollBytes ( <br>    HWND hWnd, <br>    int  cmd, <br>    int  pos, <br>    LPMEMVIEW lpmv) <br>{ <br>    int    nScrollInc; <br> <br>    switch (cmd) <br>{ <br>        case SB_TOP: <br>    nScrollInc = -lpmv-&gt;PosV; <br>            break ; <br> <br>        case SB_BOTTOM: <br>    nScrollInc = lpmv-&gt;RangeV - lpmv-&gt;PosV; <br>            break ; <br> <br>        case SB_LINEUP: <br>            nScrollInc = -1; <br>            break; <br> <br>        case SB_LINEDOWN: <br>            nScrollInc = 1; <br>            break; <br> <br>        case SB_PAGEDOWN: <br>    nScrollInc = max (1, lpmv-&gt;yWin/yChar); <br>            break; <br> <br>        case SB_PAGEUP: <br>    nScrollInc = min (-1, -(lpmv-&gt;yWin/yChar)); <br>            break; <br>     <br>        case SB_THUMBPOSITION: <br>    nScrollInc = pos - lpmv-&gt;PosV; <br>            break; <br> <br>case SB_THUMBTRACK: <br>    nScrollInc = pos - lpmv-&gt;PosV; <br>            break; <br> <br>        default: <br>            nScrollInc = 0; <br>} <br> <br>    if (nScrollInc &gt; lpmv-&gt;RangeV-lpmv-&gt;PosV) <br>nScrollInc = lpmv-&gt;RangeV-lpmv-&gt;PosV; <br> <br>    if (nScrollInc &lt; -lpmv-&gt;PosV) <br>nScrollInc = -lpmv-&gt;PosV; <br> <br>    if (nScrollInc) <br>{ <br>lpmv-&gt;PosV += nScrollInc; <br> <br>if (ABS (nScrollInc) &lt; lpmv-&gt;yWin/yChar) <br>    ScrollWindow (hWnd, 0, -(yChar*nScrollInc), NULL, NULL); <br>else <br>    InvalidateRect (hWnd, NULL, TRUE); <br> <br>SetScrollPos (hWnd, SB_VERT, lpmv-&gt;PosV, TRUE); <br>UpdateWindow(hWnd); <br>} <br>} <br> <br> <br> <br>void  WINAPI KeyToScrollMsg ( <br>    HWND      hWnd, <br>    WPARAM    wParam) <br>{ <br>    int       i, nKeys; <br>    static    struct <br>{ <br>        WORD wVirtKey; <br>        int  iMessage; <br>        WORD wRequest; <br>}key2scroll [] = { <br> VK_HOME,  WM_VSCROLL, SB_TOP,  VK_END,   WM_VSCROLL, <br> SB_BOTTOM, VK_PRIOR, WM_VSCROLL, SB_PAGEUP, VK_NEXT, <br> WM_VSCROLL, SB_PAGEDOWN, VK_UP,    WM_VSCROLL, SB_LINEUP, <br> VK_DOWN,  WM_VSCROLL, SB_LINEDOWN, VK_LEFT,  WM_HSCROLL, <br> SB_LINEUP, VK_RIGHT, WM_HSCROLL, SB_LINEDOWN, <br> }; <br> <br>    nKeys = sizeof key2scroll / sizeof key2scroll[0]; <br> <br>    for (i=0; i&lt;nKeys; i++) <br>{ <br>        if (wParam == key2scroll[i].wVirtKey)    <br>    { <br>            SendMessage (hWnd, key2scroll[i].iMessage, key2scroll[i].wRequest, 0L); <br>            return; <br>    } <br>} <br>} <br> <br> <br> <br>void  WINAPI DisplayBytes ( <br>    HDC  hDC, <br>    RECT *pRect, <br>    LPMEMVIEW lpmv, <br>    LPMEMVIEW lpmvOld) <br>{ <br>    UINT      i, r, iFirst, iLast, y; <br>    char      szBuf[MAX_PATH], szText[MAX_PATH]; <br>    LPBYTE    pMem = (LPBYTE)lpmv-&gt;lpMem; <br>    LPBYTE    pOldMem; <br>    BYTE      bRes[16]; <br>    COLORREF  crOldColor = 0; <br>    SIZE      sz; <br>    int       cx; <br> <br>    if (lpmvOld != NULL) <br>{ <br>pOldMem = (LPBYTE)lpmvOld-&gt;lpMem; <br> <br>/* normalize to beginning of section relative to current memory */ <br>(int)pOldMem += lpmvOld-&gt;nBase - lpmv-&gt;nBase; <br>} <br> <br>    SelectObject (hDC, hFont); <br>    SetTextColor (hDC, GetSysColor (COLOR_WINDOWTEXT)); <br>    SetBkColor (hDC, GetSysColor (COLOR_WINDOW)); <br> <br>    y = lpmv-&gt;PosV; <br> <br>    iFirst = y + pRect-&gt;top/yChar-1; <br> <br>    if (iFirst == 0xFFFFFFFFL) <br>iFirst = 0; <br> <br>    iLast = min (y + pRect-&gt;bottom/yChar+1, (UINT)lpmv-&gt;nLines-1); <br>    pMem += iFirst &lt;&lt; 4; <br>    pOldMem += iFirst &lt;&lt; 4; <br> <br>    if (lpmv-&gt;nExtraBytes) <br>        iLast--; <br> <br>    /* paint complete lines (lines with 16 bytes) */ <br>    GetBytesLine (NULL, 0, 0, 0, NULL); <br> <br>    y = (iFirst - y) * yChar; <br>    for (i = iFirst; i&lt;iLast; i++) <br>{ <br>GetBytesLine (pMem, i, lpmv-&gt;nBase, 16, szBuf); <br> <br>if (lpmvOld != NULL &amp;&amp; <br>    ((int)pMem-(int)lpmv-&gt;lpMem + lpmv-&gt;nBase) &gt;= lpmvOld-&gt;nBase &amp;&amp; <br>    ((int)pMem-(int)lpmv-&gt;lpMem + lpmv-&gt;nBase) &lt; (lpmvOld-&gt;nBase + lpmvOld-&gt;nSize) &amp;&amp; <br>    !parcmp (pMem, pOldMem, 16, bRes)) <br>    { <br>    /* write line number and leading space */ <br>    strncpy (szText, szBuf, 12); <br>    szText[12] = 0; <br>    GetTextExtentPoint (hDC, szText, 12, &amp;sz); <br>    cx = xChar; <br>    SetTextColor (hDC, GetSysColor (COLOR_HIGHLIGHTTEXT)); <br>    TextOut (hDC, cx, LOWORD (y), szText, 12); <br> <br>    /* check each hex byte for change */ <br>    for (r=0; r&lt;16; r++) <br>{ <br>if (bRes[r]) <br>    SetTextColor (hDC, RGB (191, 0, 0)); <br>else <br>    SetTextColor (hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>/* draw next byte */ <br>szText[0] = szBuf[3*r+12]; <br>szText[1] = szBuf[3*r+1+12]; <br>szText[2] = szBuf[3*r+2+12]; <br>szText[3] = 0; <br>cx += sz.cx; <br>GetTextExtentPoint (hDC, szText, 3, &amp;sz); <br>TextOut (hDC, cx, LOWORD (y), szText, 3); <br>} <br> <br>    /* check each ascii byte */ <br>    for (r=0; r&lt;16; r++) <br>{ <br>if (bRes[r]) <br>    SetTextColor (hDC, RGB (191, 0, 0)); <br>else <br>    SetTextColor (hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>/* draw next byte */ <br>szText[0] = szBuf[r+60]; <br>szText[1] = 0; <br>cx += sz.cx; <br>GetTextExtentPoint (hDC, szText, 1, &amp;sz); <br>TextOut (hDC, cx, LOWORD (y), szText, 3); <br>} <br>    } <br> <br>else <br>    { <br>    SetTextColor (hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>    TextOut (hDC, xChar, LOWORD (y), szBuf, lstrlen (szBuf)); <br>    } <br> <br>pMem += 16; <br>pOldMem += 16; <br>y += yChar; <br>} <br> <br>    /* paint last partial line if any (line with less than 16 bytes) */ <br>    if (lpmv-&gt;nExtraBytes) <br>{ <br>GetBytesLine (pMem, i, lpmv-&gt;nBase, lpmv-&gt;nExtraBytes, szBuf); <br> <br>if (lpmvOld != NULL &amp;&amp; <br>    ((int)pMem-(int)lpmv-&gt;lpMem + lpmv-&gt;nBase) &gt;= lpmvOld-&gt;nBase &amp;&amp; <br>    ((int)pMem-(int)lpmv-&gt;lpMem + lpmv-&gt;nBase) &lt; (lpmvOld-&gt;nBase + lpmvOld-&gt;nSize) &amp;&amp; <br>    !parcmp (pMem, pOldMem, lpmv-&gt;nExtraBytes, bRes)) <br>    { <br>    /* write line number and leading space */ <br>    strncpy (szText, szBuf, 12); <br>    szText[12] = 0; <br>    GetTextExtentPoint (hDC, szText, 12, &amp;sz); <br>    cx = xChar; <br>    SetTextColor (hDC, RGB (191, 0, 0)); <br>    TextOut (hDC, cx, LOWORD (y), szText, 12); <br> <br>    /* check each hex byte for change */ <br>    for (r=0; r&lt;(UINT)lpmv-&gt;nExtraBytes; r++) <br>{ <br>if (bRes[r]) <br>    SetTextColor (hDC, RGB (191, 0, 0)); <br>else <br>    SetTextColor (hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>/* draw next byte */ <br>szText[0] = szBuf[3*r+12]; <br>szText[1] = szBuf[3*r+1+12]; <br>szText[2] = szBuf[3*r+2+12]; <br>szText[3] = 0; <br>cx += sz.cx; <br>GetTextExtentPoint (hDC, szText, 3, &amp;sz); <br>TextOut (hDC, cx, LOWORD (y), szText, 3); <br>} <br> <br>    /* check each ascii byte */ <br>    for (r=0; r&lt;(UINT)lpmv-&gt;nExtraBytes; r++) <br>{ <br>if (bRes[r]) <br>    SetTextColor (hDC, RGB (191, 0, 0)); <br>else <br>    SetTextColor (hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>/* draw next byte */ <br>szText[0] = szBuf[r+60]; <br>szText[1] = 0; <br>cx += sz.cx; <br>GetTextExtentPoint (hDC, szText, 1, &amp;sz); <br>TextOut (hDC, cx, LOWORD (y), szText, 1); <br>} <br>    } <br> <br>else <br>    { <br>    SetTextColor (hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>    TextOut(hDC, xChar, y, szBuf, lstrlen (szBuf)); <br>    } <br>} <br> <br>    SelectObject(hDC, GetStockObject(SYSTEM_FONT)); <br>} <br> <br> <br> <br> <br> <br>void  WINAPI GetBytesLine ( <br>    LPBYTE   pBytes, <br>    UINT     LineNum, <br>    DWORD    dwBase, <br>    int      nBytes, <br>    char     *szLine) <br>{ <br>    int      j; <br>    unsigned char    ch; <br>    char     szAscii[18]; <br>    static BOOL      bDBCS; <br> <br>    if (NULL == pBytes) { <br>bDBCS = FALSE; <br>return; <br>    } <br> <br>    wsprintf (szLine, "%#08lx  ", dwBase + (LineNum*16)); <br>         <br>    for (j = 0; j &lt; nBytes; j++) <br>{ <br>ch = *pBytes++; <br>wsprintf (szLine, "%s%02X ", (LPSTR)szLine, (WORD)ch); <br> <br>if (bDBCS) <br>    { <br>    szAscii[j] = (0 == j) ? '.' : ch; <br>    bDBCS = FALSE; <br>    } <br>else if (IsDBCSLeadByte(ch)) <br>    { <br>    szAscii[j] = ch; <br>    bDBCS = TRUE; <br>    } <br>else <br>    { <br>    szAscii[j] = ((ch &amp; 0x7F) &gt;= ' ') ? ch : '.'; <br>    } <br>} <br> <br>    if (bDBCS &amp;&amp; 16 == nBytes) <br>szAscii[j++] = *pBytes; <br>    szAscii[j] = 0; <br>    wsprintf(szLine, "%-59s%s", (LPSTR)szLine, (LPSTR)szAscii); <br>} <br> <br> <br> <br> <br>BOOLWINAPI parcmp ( <br>    LPBYTE    pMem, <br>    LPBYTE    pOldMem, <br>    int       nWidth, <br>    LPBYTE    pRes) <br>{ <br>    BOOL    bResult = TRUE; <br>    int     i; <br> <br>    /* clear result array */ <br>    for (i=0; i&lt;16; i++) <br>pRes[i] = 0; <br> <br>    for (i=0; i&lt;nWidth; i++) <br>{ <br>if (pMem[i] ^ pOldMem[i]) <br>    { <br>    pRes[i] = 1; <br>    bResult = FALSE; <br>    } <br>} <br> <br>    return bResult; <br>} <br> <br> <br> <br> <br>BOOL WINAPI AddrDlgProc ( <br>    HWND      hDlg, <br>    UINT      uMsg, <br>    WPARAM    wParam, <br>    LPARAM    lParam) <br>{ <br>    BOOL    bRet = TRUE; <br>    char    szAddr[MAX_PATH]; <br>    int     nAddr; <br>    HWND    hAddr = GetDlgItem (hDlg, IDC_ADDR); <br> <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>    SetFocus (hAddr); <br>    bRet = FALSE; <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD (wParam)) <br>{ <br>case IDC_HEX: <br>    if (HIWORD (wParam) == BN_CLICKED) <br>{ <br>GetWindowText (hAddr, szAddr, MAX_PATH); <br> <br>if (SendMessage (GetDlgItem (hDlg, IDC_HEX), BM_GETCHECK, 0, 0)) <br>    { <br>    /* convert to hex and return to control */ <br>    nAddr = atoi (szAddr); <br>    wsprintf (szAddr, "%16x", nAddr); <br>    SetWindowText (hAddr, szAddr); <br>    } <br>else <br>    { <br>    /* convert to decimal and return to control */ <br>    sscanf (szAddr, "%16x", &amp;nAddr); <br>    SetWindowText (hAddr, itoa (nAddr, szAddr, 10)); <br>    } <br> <br>/* select entire string for easy change */ <br>SendMessage (hAddr, EM_SETSEL, 0, (LONG)-1); <br>SetFocus (hAddr); <br>} <br>    break; <br> <br>case IDOK: <br>    GetWindowText (hAddr, szAddr, MAX_PATH); <br> <br>    /* if hex, convert to decimal integer */ <br>    if (SendMessage (GetDlgItem (hDlg, IDC_HEX), BM_GETCHECK, 0, 0)) <br>sscanf (szAddr, "%16x", &amp;nAddr); <br>    else <br>nAddr = atoi (szAddr); <br> <br>    EndDialog (hDlg, nAddr); <br>    break; <br> <br>case IDCANCEL: <br>    EndDialog (hDlg, 0); <br>    break; <br>} <br>    break; <br> <br>default: <br>    bRet = FALSE; <br>} <br> <br>    return (bRet); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
