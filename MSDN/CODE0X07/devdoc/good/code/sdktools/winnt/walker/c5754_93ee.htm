<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PEFILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5756"></a>PEFILE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "pefile.h" <br> <br> <br> <br>PIMAGE_SECTION_HEADERWINAPI IDSectionHeaderOffset (LPVOID); <br> <br> <br>BOOL WINAPI DllMain ( <br>    HANDLE    hModule, <br>    DWORD     dwFunction, <br>    LPVOID    lpNot) <br>{ <br>    return TRUE; <br>} <br> <br> <br> <br>/* return offset to file header */ <br>PIMAGE_FILE_HEADER   WINAPI FileHeaderOffset ( <br>    LPVOID    lpFile) <br>{ <br>    int      ImageHdrOffset = 0; <br> <br>    /* if DOS based file, skip DOS header and file signature */ <br>    if (*((USHORT *)lpFile) == IMAGE_DOS_SIGNATURE) <br>{ <br>/* file image header offset exists after DOS header and nt signature */ <br>ImageHdrOffset = (int)((ULONG *)lpFile)[15] + sizeof (ULONG); <br>if (*((ULONG *)((char *)lpFile + ImageHdrOffset - sizeof (ULONG))) != IMAGE_NT_SIGNATURE) <br>    return NULL; <br>} <br> <br>    /* optional header exists immediately after file header and image header */ <br>    return (PIMAGE_FILE_HEADER)((int)lpFile + ImageHdrOffset); <br>} <br> <br> <br> <br> <br>/* return optional header data */ <br>PIMAGE_OPTIONAL_HEADERWINAPI OptionalHeaderOffset ( <br>    LPVOID    lpFile) <br>{ <br>    int      ImageHdrOffset = 0; <br> <br>    /* if DOS based file, skip DOS header and file signature */ <br>    if (*((USHORT *)lpFile) == IMAGE_DOS_SIGNATURE) <br>{ <br>/* file image header offset exists after DOS header and nt signature */ <br>ImageHdrOffset = (int)((ULONG *)lpFile)[15] + sizeof (ULONG); <br>if (*((ULONG *)((char *)lpFile + ImageHdrOffset - sizeof (ULONG))) != IMAGE_NT_SIGNATURE) <br>    return NULL; <br>} <br> <br>    /* optional header exists immediately after file header and image header */ <br>    return (PIMAGE_OPTIONAL_HEADER)((char *)lpFile + ImageHdrOffset + sizeof (IMAGE_FILE_HEADER)); <br>} <br> <br> <br> <br> <br>/* return pointer to first section header */ <br>PIMAGE_SECTION_HEADERWINAPI SectionHeaderOffset ( <br>    LPVOID    lpFile) <br>{ <br>    int      ImageHdrOffset = 0; <br> <br>    /* if DOS based file, skip DOS header and file signature */ <br>    if (*((USHORT *)lpFile) == IMAGE_DOS_SIGNATURE) <br>{ <br>/* file image header offset exists after DOS header and nt signature */ <br>ImageHdrOffset = (int)((ULONG *)lpFile)[15] + sizeof (ULONG); <br>if (*((ULONG *)((char *)lpFile + ImageHdrOffset - sizeof (ULONG))) != IMAGE_NT_SIGNATURE) <br>    return NULL; <br>} <br> <br>    /* optional header exists immediately after file header and image header */ <br>    return (PIMAGE_SECTION_HEADER)((int)OptionalHeaderOffset (lpFile) + <br>(int)((PIMAGE_FILE_HEADER)((int)lpFile + ImageHdrOffset))-&gt;SizeOfOptionalHeader); <br>} <br> <br> <br> <br> <br> <br>/* return offset to first IMAGE_IMPORT_DIRECTORY entry */ <br>PIMAGE_IMPORT_DIRECTORY  WINAPI ImportDirectoryOffset ( <br>LPVOID  lpFile) <br>{ <br>    PIMAGE_OPTIONAL_HEADER   poh = OptionalHeaderOffset (lpFile); <br>    PIMAGE_SECTION_HEADER    psh = SectionHeaderOffset (lpFile); <br>    int      nSections = NumOfSections (lpFile); <br>    int      i = 0; <br>    LPVOID     VAImportDir; <br> <br>    VAImportDir = (LPVOID)poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; <br> <br>    /* locate section containing import directory */ <br>    while (i++&lt;nSections) <br>{ <br>if (psh-&gt;VirtualAddress &lt;= (DWORD)VAImportDir &amp;&amp; <br>    psh-&gt;VirtualAddress + psh-&gt;SizeOfRawData &gt; (DWORD)VAImportDir) <br>    break; <br>psh++; <br>} <br> <br>    if (i &gt; nSections) <br>return 0; <br> <br>    /* return image import directory offset */ <br>    return (PIMAGE_IMPORT_DIRECTORY)(((int)lpFile + (int)VAImportDir - psh-&gt;VirtualAddress) + <br>   (int)psh-&gt;PointerToRawData); <br>} <br> <br> <br> <br> <br>/* return pointer to image directory section header */ <br>PIMAGE_SECTION_HEADERWINAPI IDSectionHeaderOffset ( <br>    LPVOID    lpFile) <br>{ <br>    int      ImageHdrOffset = 0; <br>    PIMAGE_OPTIONAL_HEADER   poh = OptionalHeaderOffset (lpFile); <br>    PIMAGE_SECTION_HEADER    psh = SectionHeaderOffset (lpFile); <br>    int      nSections = NumOfSections (lpFile); <br>    int      i = 0; <br>    LPVOID     VAImportDir; <br> <br>    VAImportDir = (LPVOID)poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; <br> <br>    /* locate section containing import directory */ <br>    while (i++&lt;nSections) <br>{ <br>if (psh-&gt;VirtualAddress &lt;= (DWORD)VAImportDir &amp;&amp; <br>    psh-&gt;VirtualAddress + psh-&gt;SizeOfRawData &gt; (DWORD)VAImportDir) <br>    break; <br>psh++; <br>} <br> <br>    if (i &gt; nSections) <br>return 0; <br>    else <br>return psh; <br>} <br> <br> <br> <br> <br> <br>/* return the total number of sections in the module */ <br>int   WINAPI NumOfSections ( <br>    LPVOID    lpFile) <br>{ <br>    int      ImageHdrOffset = 0; <br> <br>    /* if DOS based file, skip DOS header and file signature */ <br>    if (*((USHORT *)lpFile) == IMAGE_DOS_SIGNATURE) <br>{ <br>/* file image header offset exists after DOS header and nt signature */ <br>ImageHdrOffset = (int)((ULONG *)lpFile)[15] + sizeof (ULONG); <br>if (*((ULONG *)((char *)lpFile + ImageHdrOffset - sizeof (ULONG))) != IMAGE_NT_SIGNATURE) <br>    return 0; <br>} <br> <br>    /* section total is found in the file header */ <br>    return (int)((PIMAGE_FILE_HEADER)((int)lpFile + ImageHdrOffset))-&gt;NumberOfSections; <br>} <br> <br> <br> <br>/* retrieve name of module from module's open file handle */ <br>void WINAPI RetrieveModuleName ( <br>    char      *lpszModule, <br>    HANDLE    hFile) <br>{ <br>    HANDLE     hMapFile; <br>    LPVOID     lpFile; <br>    char     *lpszName; <br>    int      nSections; <br>    ULONG     VAExportDir; <br>    int      i=0; <br>    int      ImageHdrOffset; <br>    PIMAGE_SECTION_HEADER    psh; <br>    PIMAGE_FILE_HEADER     pfh; <br>    PIMAGE_OPTIONAL_HEADER   poh; <br>    PIMAGE_EXPORT_DIRECTORY  ped; <br> <br> <br>    /* memory map handle to DLL for easy access */ <br>    hMapFile = CreateFileMapping (hFile, <br>  (LPSECURITY_ATTRIBUTES)NULL, <br>  PAGE_READONLY, <br>  0, <br>  0, <br>  NULL); <br> <br>    /* map view of entire file */ <br>    lpFile = MapViewOfFile (hMapFile, FILE_MAP_READ, 0, 0, 0); <br> <br>    /* if DOS based file */ <br>    if (*((USHORT *)lpFile) == IMAGE_DOS_SIGNATURE) <br>{ <br>/* file image header offset exists after DOS header and nt signature */ <br>ImageHdrOffset = (int)((ULONG *)lpFile)[15] + sizeof (ULONG); <br>if (*((ULONG *)((char *)lpFile + ImageHdrOffset - sizeof (ULONG))) != <br>    IMAGE_NT_SIGNATURE) <br>    { <br>    strcpy (lpszModule, "Error, no IMAGE_NT_SIGNATURE"); <br>    goto EXIT; <br>    } <br>} <br> <br>    pfh = (PIMAGE_FILE_HEADER)((char *)lpFile + ImageHdrOffset); <br> <br>    /* if optional header exists and exports directory exists proceed */ <br>    if (pfh-&gt;SizeOfOptionalHeader) <br>{ <br>/* locate virtual address for Export Image Directory in OptionalHeader */ <br>poh = (PIMAGE_OPTIONAL_HEADER)((char *)pfh + sizeof (IMAGE_FILE_HEADER)); <br>VAExportDir = poh-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress; <br> <br>/* locate section where export virtual address is located */ <br>psh = (PIMAGE_SECTION_HEADER)((char *)poh + pfh-&gt;SizeOfOptionalHeader); <br>nSections = pfh-&gt;NumberOfSections; <br>while (i++&lt;nSections) <br>    { <br>    if (psh-&gt;VirtualAddress &lt;= VAExportDir &amp;&amp; <br>psh-&gt;VirtualAddress + psh-&gt;SizeOfRawData &gt; VAExportDir) <br>break; <br>    psh++; <br>    } <br> <br>/* locate export image directory */ <br>if (i &lt; nSections) <br>    ped = (PIMAGE_EXPORT_DIRECTORY)((char *)lpFile + <br>(VAExportDir - psh-&gt;VirtualAddress) + psh-&gt;PointerToRawData); <br>else <br>    { <br>    strcpy (lpszModule, "IMAGE_EXPORT_DIRECTORY not found"); <br>    goto EXIT; <br>    } <br> <br>/* read name from export directory */ <br>lpszName = (char *)lpFile + ped-&gt;Name + (psh-&gt;PointerToRawData - psh-&gt;VirtualAddress); <br>strcpy (lpszModule, lpszName); <br>} <br> <br>    else <br>strcpy (lpszModule, "Error, no IMAGE_OPTIONAL_HEADER"); <br> <br>EXIT: <br>    /* clean up before exiting */ <br>    UnmapViewOfFile (lpFile); <br>    CloseHandle (hMapFile); <br>} <br> <br> <br> <br> <br>/* retieve section names from module file handle */ <br>void WINAPI RetrieveSectionNames ( <br>    HANDLE  hHeap, <br>    HANDLE  hFile, <br>    SECTIONINFO   **pSection) <br>{ <br>    HANDLE     hMapFile; <br>    LPVOID     lpFile; <br>    int      nSections; <br>    int      i=0; <br>    int      ImageHdrOffset; <br>    PIMAGE_SECTION_HEADER    psh; <br>    PIMAGE_FILE_HEADER     pfh; <br>    SECTIONINFO      *ps; <br> <br> <br>    /* memory map handle to DLL for easy access */ <br>    hMapFile = CreateFileMapping (hFile, <br>  (LPSECURITY_ATTRIBUTES)NULL, <br>  PAGE_READONLY, <br>  0, <br>  0, <br>  NULL); <br> <br>    /* map view of entire file */ <br>    lpFile = MapViewOfFile (hMapFile, FILE_MAP_READ, 0, 0, 0); <br> <br>    /* if DOS based file */ <br>    if (*((USHORT *)lpFile) == IMAGE_DOS_SIGNATURE) <br>{ <br>/* file image header offset exists after DOS header and nt signature */ <br>ImageHdrOffset = (int)((ULONG *)lpFile)[15] + sizeof (ULONG); <br>if (*((ULONG *)((char *)lpFile + ImageHdrOffset - sizeof (ULONG))) != <br>    IMAGE_NT_SIGNATURE) <br>    goto EXIT; <br>} <br> <br>    pfh = (PIMAGE_FILE_HEADER)((char *)lpFile + ImageHdrOffset); <br> <br>    /* if optional header exists, offset first section header */ <br>    psh = (PIMAGE_SECTION_HEADER)((char *)pfh + <br>      sizeof (IMAGE_FILE_HEADER) + pfh-&gt;SizeOfOptionalHeader); <br> <br>    /* allocate one section header for each section */ <br>    ps = *pSection = (SECTIONINFO *)HeapAlloc (hHeap, <br>       HEAP_ZERO_MEMORY, <br>       sizeof (SECTIONINFO)); <br>    nSections = pfh-&gt;NumberOfSections; <br>    while (TRUE) <br>{ <br>strcpy (ps-&gt;szSection, psh[i].Name); <br>ps-&gt;uVirtualAddress = psh[i].VirtualAddress; <br>ps-&gt;uSize = psh[i].SizeOfRawData; <br> <br>if (++i &gt;= nSections) <br>    break; <br> <br>/* allocate heap memory for sections */ <br>ps-&gt;Next = (LPSECTIONINFO)HeapAlloc (hHeap, <br>     HEAP_ZERO_MEMORY, <br>     sizeof (SECTIONINFO)); <br>ps = (SECTIONINFO *)ps-&gt;Next; <br>} <br> <br>EXIT: <br>    /* clean up before exiting */ <br>    UnmapViewOfFile (lpFile); <br>    CloseHandle (hMapFile); <br>} <br> <br> <br> <br> <br>/* function returns the entry point for an exe module lpFile must <br>   be a memory mapped file pointer to the beginning of the image file */ <br>LPVOIDWINAPI GetModuleEntryPoint ( <br>    LPVOID    lpFile) <br>{ <br>    PIMAGE_OPTIONAL_HEADER   poh = OptionalHeaderOffset (lpFile); <br> <br>    if (poh != NULL) <br>return (LPVOID)(poh-&gt;AddressOfEntryPoint); <br>    else <br>return NULL; <br>} <br> <br> <br> <br> <br>/* retrieve entry point */ <br>LPVOIDWINAPI GetImageBase ( <br>    LPVOID    lpFile) <br>{ <br>    PIMAGE_OPTIONAL_HEADER   poh = OptionalHeaderOffset (lpFile); <br> <br>    if (poh != NULL) <br>return (LPVOID)(poh-&gt;ImageBase); <br>    else <br>return NULL; <br>} <br> <br> <br> <br> <br>/* get import modules names separated by null terminators, return module count */ <br>int  WINAPI GetImportModuleNames ( <br>    LPVOID    lpFile, <br>    HANDLE    hHeap, <br>    char      **pszModules) <br>{ <br>    PIMAGE_IMPORT_DIRECTORY  pid = ImportDirectoryOffset (lpFile); <br>    PIMAGE_SECTION_HEADER    pidsh = IDSectionHeaderOffset (lpFile); <br>    BYTE     *pData = (BYTE *)pid; <br>    int      nCnt = 0, nSize = 0, i; <br>    char     *pModule[1024];  /* hardcoded maximum number of modules?? */ <br>    char     *psz; <br> <br>    /* extract all import modules */ <br>    while (pid-&gt;dwRVAModule) <br>{ <br>/* allocate temporary buffer for absolute string offsets */ <br>pModule[nCnt] = (char *)(pData + (pid-&gt;dwRVAModule-pidsh-&gt;VirtualAddress)); <br>nSize += strlen (pModule[nCnt]) + 1; <br> <br>/* increment to the next import directory entry */ <br>pid++; <br>nCnt++; <br>} <br> <br>    /* copy all strings to one chunk of heap memory */ <br>    *pszModules = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize); <br>    psz = *pszModules; <br>    for (i=0; i&lt;nCnt; i++) <br>{ <br>strcpy (psz, pModule[i]); <br>psz += strlen (psz) + 1; <br>} <br> <br>    return nCnt; <br>} <br> <br> <br> <br> <br>/* get import module function names separated by null terminators, return function count */ <br>int  WINAPI GetImportFunctionNamesByModule ( <br>    LPVOID    lpFile, <br>    HANDLE    hHeap, <br>    char      *pszModule, <br>    char      **pszFunctions) <br>{ <br>    PIMAGE_IMPORT_DIRECTORY  pid = ImportDirectoryOffset (lpFile); <br>    PIMAGE_SECTION_HEADER    pidsh = IDSectionHeaderOffset (lpFile); <br>    DWORD     dwBase = ((DWORD)pid - pidsh-&gt;VirtualAddress); <br>    int      nCnt = 0, nSize = 0; <br>    DWORD     dwFunction; <br>    char     *psz; <br> <br>    /* find module's pid */ <br>    while (pid-&gt;dwRVAModule &amp;&amp; <br>   strcmp (pszModule, (char *)(pid-&gt;dwRVAModule+dwBase))) <br>pid++; <br> <br>    /* count functions and total space required for them */ <br>    nSize += strlen ((char *)((*(DWORD *)(pid-&gt;dwRVAFirstFunction + dwBase)) + dwBase+2)) + 1; <br> <br>    /* last image directory does not have a separate function list, so improvise */ <br>    if (!(dwFunction = pid-&gt;dwRVAFunctionList)) <br>dwFunction = pid-&gt;dwRVAFirstFunction + 4; <br> <br>    while (dwFunction &amp;&amp; <br>   *(char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) <br>{ <br>nSize += strlen ((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) + 1; <br>dwFunction += 4; <br>nCnt++; <br>} <br> <br>    /* allocate memory off heap for function names */ <br>    *pszFunctions = HeapAlloc (hHeap, HEAP_ZERO_MEMORY, nSize); <br>    psz = *pszFunctions; <br>    strcpy (psz, (char *)((*(DWORD *)(pid-&gt;dwRVAFirstFunction + dwBase)) + dwBase+2)); <br>    psz += strlen ((char *)((*(DWORD *)(pid-&gt;dwRVAFirstFunction + dwBase)) + dwBase+2)) + 1; <br> <br>    /* last image directory does not have a separate function list, so improvise */ <br>    if (!(dwFunction = pid-&gt;dwRVAFunctionList)) <br>dwFunction = pid-&gt;dwRVAFirstFunction + 4; <br> <br>    while (dwFunction &amp;&amp; <br>   *((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2))) <br>{ <br>strcpy (psz, (char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)); <br>psz += strlen ((char *)((*(DWORD *)(dwFunction + dwBase)) + dwBase+2)) + 1; <br>dwFunction += 4; <br>} <br> <br>    return nCnt; <br>} <br> <br> <br> <br> <br>/* get exported function names separated by null terminators, return count of functions */ <br>int  WINAPI GetExportFunctionNames ( <br>    LPVOID    lpFile, <br>    HANDLE    hHeap, <br>    char      **pszFunctions) <br>{ <br> <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
