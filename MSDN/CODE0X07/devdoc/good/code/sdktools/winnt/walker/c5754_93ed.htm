<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PDEBUG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5755"></a>PDEBUG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "pwalk.h" <br>#include &lt;memory.h&gt; <br> <br> <br>/* module globals */ <br>LPVOID  PMAAddress; <br>LPVOID  PMABuffer; <br>DWORD  PMASize; <br>extern  char  szCurPath[MAX_PATH]; <br> <br> <br>/* local debug functions */ <br>BOOL   WINAPI DebugEventThread (DBGPROCESS *); <br>BOOL   WINAPI CreateDebugEvents (LPHANDLE); <br>void   WINAPI AddThreadNode (DBGPROCESS *, DWORD, HANDLE, int, LPTHREAD_START_ROUTINE, HANDLE); <br>int    WINAPI HandleBreakPoint(DBGPROCESS *, DWORD); <br>void   WINAPI RemoveThreadNode (DBGPROCESS *, DWORD); <br>void   WINAPI AddDllNode (DBGPROCESS *, LOAD_DLL_DEBUG_INFO *); <br>void   WINAPI RemoveDllNode (DBGPROCESS *, LOAD_DLL_DEBUG_INFO *); <br>void   WINAPI SuspendDebuggeeProcess (DBGPROCESS *); <br>void   WINAPI ResumeDebuggeeProcess (DBGPROCESS *); <br>void   WINAPI NameObjects (HANDLE, LPVOID, LPVMOBJECT, int, char *, char *); <br>BOOL   WINAPI VMCompare (LPVMOBJECT, LPVMOBJECT); <br>BOOL   WINAPI InterruptThread_HookProcess (DBGPROCESS *, LPPROCESS_STATE); <br>void   WINAPI ResetInterruptedThread (DBGPROCESS *, LPPROCESS_STATE); <br>void   WINAPI RecordException (DBGPROCESS *, DEBUG_EVENT *); <br>HANDLE WINAPI FindThreadHandle (DBGPROCESS *, DWORD); <br> <br> <br> <br>/* start debug thread, and return event active handle */ <br>DBGPROCESS* WINAPI StartChildProcess ( <br>    HWNDhWnd, <br>    char*lpszModule, <br>    LPHANDLElpDbgEvents) <br>{ <br>    DWORD  TID; <br>    HANDLE  hDebugHeap; <br>    DBGPROCESS  *lpDbgProcess; <br>    int   i; <br> <br>    /* create unique debug events using debuggee process ID */ <br>    if (!CreateDebugEvents (lpDbgEvents)) <br>return NULL; <br> <br>    /* create serialized heap of dynamic size */ <br>    if (!(hDebugHeap = HeapCreate (0, sizeof (DBGPROCESS) + sizeof (DBGTHREAD), 0))) <br>{ <br>/* close all event handles */ <br>for (i=0; i&lt;nDEBUGEVENTS; i++) <br>    CloseHandle (lpDbgEvents[i]); <br> <br>return NULL; <br>} <br> <br>    /* allocate and initialize debug heap structure */ <br>    lpDbgProcess = (DBGPROCESS *)HeapAlloc (hDebugHeap, 0, sizeof (DBGPROCESS)); <br>    lpDbgProcess-&gt;hDbgHeap = hDebugHeap; <br>    strcpy (lpDbgProcess-&gt;szModule, lpszModule); <br>    lpDbgProcess-&gt;hWnd = hWnd; <br>    lpDbgProcess-&gt;lpThreads = NULL; <br>    lpDbgProcess-&gt;lpSection = NULL; <br>    lpDbgProcess-&gt;lpERs = NULL; <br> <br>    /* create debug thread */ <br>    if (!(CreateThread ((LPSECURITY_ATTRIBUTES)NULL, <br>4096, <br>(LPTHREAD_START_ROUTINE)DebugEventThread, <br>(LPVOID)lpDbgProcess, <br>0, <br>&amp;TID))) <br>return NULL; <br> <br>    /* wait 15 seconds for debugger to complete initialization, else error */ <br>    if (WAIT_TIMEOUT == WaitForSingleObject (lpDbgEvents[ACKNOWLEDGE], 15000)) <br>{ <br>HeapDestroy (lpDbgProcess-&gt;hDbgHeap); <br> <br>/* close all event handles */ <br>for (i=0; i&lt;nDEBUGEVENTS; i++) <br>    CloseHandle (lpDbgEvents[i]); <br> <br>return NULL; <br>} <br> <br>    /* reset acknowledge event */ <br>    ResetEvent (lpDbgEvents[ACKNOWLEDGE]); <br> <br>    /* successfull thread and event start */ <br>    return lpDbgProcess; <br>} <br> <br> <br> <br> <br>/* function notifies debug thread to terminate, frees handles, and destroys heap */ <br>void   WINAPI CloseChildProcess ( <br>    DBGPROCESS *lpDbgProcess, <br>    LPHANDLE   lpDbgEvents) <br>{ <br>    int  i; <br>    DBGTHREAD *pNode = lpDbgProcess-&gt;lpThreads; <br> <br>    /* set close event for debug thread and wait for acknowledge */ <br>    SetEvent (lpDbgEvents[CLOSEDEBUGGER]); <br>    WaitForSingleObject (lpDbgEvents[ACKNOWLEDGE], INFINITE); <br> <br>    /* close all event handles */ <br>    for (i=0; i&lt;nDEBUGEVENTS; i++) <br>CloseHandle (lpDbgEvents[i]); <br> <br>    /* close all thread handles in the list */ <br>    while (pNode != NULL) <br>{ <br>RemoveThreadNode (lpDbgProcess, pNode-&gt;dwThreadID); <br>pNode = lpDbgProcess-&gt;lpThreads; <br>} <br> <br>    /* destroy the debug heap */ <br>    HeapDestroy (lpDbgProcess-&gt;hDbgHeap); <br>} <br> <br> <br> <br> <br>/* local function creates debug event objects for thread synchronization */ <br>BOOL WINAPI CreateDebugEvents ( <br>    LPHANDLElpDbgEvents) <br>{ <br>    char    szEvent[MAX_PATH]; <br> <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTACTIVE, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[DEBUGACTIVE] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br>  TRUE, <br>  TRUE, <br>  szEvent))) <br>return FALSE; <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTCLOSE, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[CLOSEDEBUGGER] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br>   TRUE, <br>   FALSE, <br>   szEvent))) <br>{ <br>CloseHandle (lpDbgEvents[DEBUGACTIVE]); <br>return FALSE; <br>} <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTSTOP, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[SUSPENDDEBUGGER] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br>      TRUE, <br>      FALSE, <br>      szEvent))) <br>{ <br>CloseHandle (lpDbgEvents[DEBUGACTIVE]); <br>CloseHandle (lpDbgEvents[CLOSEDEBUGGER]); <br>return FALSE; <br>} <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTSTART, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[RESUMEDEBUGGER] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br>     TRUE, <br>     FALSE, <br>     szEvent))) <br>{ <br>CloseHandle (lpDbgEvents[DEBUGACTIVE]); <br>CloseHandle (lpDbgEvents[CLOSEDEBUGGER]); <br>CloseHandle (lpDbgEvents[SUSPENDDEBUGGER]); <br>return FALSE; <br>} <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTREAD, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[READMEMORY] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br> TRUE, <br> FALSE, <br> szEvent))) <br>{ <br>CloseHandle (lpDbgEvents[DEBUGACTIVE]); <br>CloseHandle (lpDbgEvents[CLOSEDEBUGGER]); <br>CloseHandle (lpDbgEvents[SUSPENDDEBUGGER]); <br>CloseHandle (lpDbgEvents[RESUMEDEBUGGER]); <br>return FALSE; <br>} <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTWRITE, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[WRITEMEMORY] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br>  TRUE, <br>  FALSE, <br>  szEvent))) <br>{ <br>CloseHandle (lpDbgEvents[DEBUGACTIVE]); <br>CloseHandle (lpDbgEvents[CLOSEDEBUGGER]); <br>CloseHandle (lpDbgEvents[SUSPENDDEBUGGER]); <br>CloseHandle (lpDbgEvents[RESUMEDEBUGGER]); <br>CloseHandle (lpDbgEvents[READMEMORY]); <br>return FALSE; <br>} <br> <br>    LoadString (GetModuleHandle (NULL), IDS_DBGEVNTACK, szEvent, sizeof (szEvent)); <br>    if (!(lpDbgEvents[ACKNOWLEDGE] = CreateEvent ((LPSECURITY_ATTRIBUTES)NULL, <br>  TRUE, <br>  FALSE, <br>  szEvent))) <br>{ <br>CloseHandle (lpDbgEvents[DEBUGACTIVE]); <br>CloseHandle (lpDbgEvents[CLOSEDEBUGGER]); <br>CloseHandle (lpDbgEvents[SUSPENDDEBUGGER]); <br>CloseHandle (lpDbgEvents[RESUMEDEBUGGER]); <br>CloseHandle (lpDbgEvents[READMEMORY]); <br>CloseHandle (lpDbgEvents[WRITEMEMORY]); <br>return FALSE; <br>} <br> <br>    /* success */ <br>    return TRUE; <br>} <br> <br> <br> <br> <br> <br>/* main daddyo thread that is the debugger residing over a debuggee */ <br>BOOL WINAPI DebugEventThread ( <br>    DBGPROCESS  *lpDbgProcess) <br>{ <br>    DEBUG_EVENT    de; <br>    HANDLE   hDbgEvent[nDEBUGEVENTS]; <br>    STARTUPINFO    si; <br>    PROCESS_INFORMATION    pi; <br>    HANDLE   hChildProcess; <br>    BOOL   bHooked, bUnHooked; <br>//    PROCESS_STATE   ProcessState; <br> <br> <br>    bHooked = FALSE; <br>    bUnHooked = FALSE; <br> <br>    /* initialize process startup information */ <br>    si.cb       = sizeof (si); <br>    si.lpReserved      = NULL; <br>    si.lpDesktop       = NULL; <br>    si.lpTitle       = NULL; <br>    si.dwX       = 0; <br>    si.dwY       = 0; <br>    si.dwXSize       = 0; <br>    si.dwYSize       = 0; <br>    si.dwXCountChars   = 0; <br>    si.dwYCountChars   = 0; <br>    si.dwFillAttribute = 0; <br>    si.dwFlags       = STARTF_FORCEONFEEDBACK | STARTF_USESHOWWINDOW; <br>    si.wShowWindow     = SW_SHOWNORMAL; <br>    si.cbReserved2     = 0; <br>    si.lpReserved2     = NULL; <br> <br>    /* create debug process on module name */ <br>    if (!CreateProcess (lpDbgProcess-&gt;szModule, <br>NULL, <br>(LPSECURITY_ATTRIBUTES)NULL, <br>(LPSECURITY_ATTRIBUTES)NULL, <br>FALSE, <br>DEBUG_PROCESS, <br>NULL, <br>NULL, <br>(LPSTARTUPINFO)&amp;si, <br>(LPPROCESS_INFORMATION)&amp;pi)) <br>{ <br>ReportError (IDS_ERRCREATEPROCESS); <br>return FALSE; <br>} <br>    /* open process for all access */ <br>    if ((hChildProcess = OpenProcess (PROCESS_ALL_ACCESS, <br>      FALSE, <br>      pi.dwProcessId)) == NULL) <br>{ <br>ReportError (IDS_ERROPENPROCESS); <br>TerminateProcess (pi.hProcess, 0); <br>return FALSE; <br>} <br> <br>    /* store process info */ <br>    lpDbgProcess-&gt;hProcess = hChildProcess; <br>    lpDbgProcess-&gt;dwPriority = GetPriorityClass (pi.hProcess); <br>    lpDbgProcess-&gt;dwProcessID = pi.dwProcessId; <br>    lpDbgProcess-&gt;bActive = TRUE; <br> <br>    /* close process and thread handles in pi structure */ <br>    CloseHandle (pi.hThread); <br>    CloseHandle (pi.hProcess); <br> <br>    /* open debug events */ <br>    CreateDebugEvents (hDbgEvent); <br> <br>    /* signale completion of task */ <br>    SetEvent (hDbgEvent[ACKNOWLEDGE]); <br> <br>    /* start debug event loop */ <br>    while (TRUE) <br>{ <br>int    nIndex; <br> <br>/* wait for debugger active */ <br>switch (nIndex = WaitForMultipleObjects (nDEBUGEVENTS, hDbgEvent, FALSE, INFINITE)) <br>    { <br>    case CLOSEDEBUGGER: <br>{ <br>int    i; <br> <br>/* terminate debuggee process */ <br>TerminateProcess (lpDbgProcess-&gt;hProcess, 0); <br>CloseHandle (lpDbgProcess-&gt;hProcess); <br> <br>/* signal completion of task */ <br>SetEvent (hDbgEvent[ACKNOWLEDGE]); <br> <br>/* close all debug events */ <br>for (i=0; i&lt;nDEBUGEVENTS; i++) <br>    CloseHandle (hDbgEvent[i]); <br> <br>/* exit debugger now */ <br>return TRUE; <br>} <br>break; <br> <br>    case SUSPENDDEBUGGER: <br>SuspendDebuggeeProcess (lpDbgProcess); <br>ResetEvent (hDbgEvent[DEBUGACTIVE]); <br>ResetEvent (hDbgEvent[SUSPENDDEBUGGER]); <br>break; <br> <br>    case RESUMEDEBUGGER: <br>ResumeDebuggeeProcess (lpDbgProcess); <br>SetEvent (hDbgEvent[DEBUGACTIVE]); <br>ResetEvent (hDbgEvent[RESUMEDEBUGGER]); <br>break; <br> <br>    case READMEMORY: <br>{ <br>MEMORY_BASIC_INFORMATION    mbi; <br>DWORD    Protect = 0; <br> <br>/* reset event so we don't do repeat */ <br>ResetEvent (hDbgEvent [READMEMORY]); <br> <br>/* if not committed memory abort */ <br>if (!VirtualQueryEx (lpDbgProcess-&gt;hProcess, <br>     PMAAddress, <br>     &amp;mbi, <br>     sizeof (MEMORY_BASIC_INFORMATION)) || <br>    mbi.State != MEM_COMMIT) <br>    { <br>    PMASize = 0; <br>    SetEvent (hDbgEvent [ACKNOWLEDGE]); <br>    break; <br>    } <br> <br>/* if guarded memory, change protection temporarily */ <br>if (!(mbi.Protect &amp; PAGE_READONLY) &amp;&amp; <br>    !(mbi.Protect &amp; PAGE_READWRITE)) <br>    VirtualProtectEx (lpDbgProcess-&gt;hProcess, <br>      PMAAddress, <br>      PMASize, <br>      PAGE_READONLY, <br>      &amp;Protect); <br> <br>if (!ReadProcessMemory (lpDbgProcess-&gt;hProcess, <br>PMAAddress, <br>PMABuffer, <br>PMASize, <br>NULL)) <br>    { <br>    if (mbi.AllocationProtect != PAGE_READONLY &amp;&amp; <br>mbi.AllocationProtect != PAGE_READWRITE) <br>NotifyUser (NULL, IDS_ERROR, 0, "BaseProtect NOACCESS", 0); <br>    else <br>{ <br>ReportError (IDS_ERRREADPROCESSMEMORY); <br>PMASize = 0; <br>} <br>    } <br> <br>/* reset protection if changed */ <br>if (Protect) <br>    VirtualProtectEx (lpDbgProcess-&gt;hProcess, <br>      PMAAddress, <br>      PMASize, <br>      Protect, <br>      &amp;Protect); <br> <br>/* acknowledge success */ <br>SetEvent (hDbgEvent [ACKNOWLEDGE]); <br>} <br>break; <br> <br>    case WRITEMEMORY: <br>if (!WriteProcessMemory (lpDbgProcess-&gt;hProcess, <br> PMAAddress, <br> PMABuffer, <br> PMASize, <br> NULL)) <br>    { <br>    ReportError (IDS_ERRWRITEPROCESSMEMORY); <br>    PMASize = 0; <br>    } <br> <br>ResetEvent (hDbgEvent [WRITEMEMORY]); <br>SetEvent (hDbgEvent [ACKNOWLEDGE]); <br>break; <br> <br>    case DEBUGACTIVE: <br>/* if debug active */ <br>if ((WaitForDebugEvent (&amp;de, (DWORD)100))) <br>    { <br>    if (de.dwProcessId == lpDbgProcess-&gt;dwProcessID) <br>{ <br>switch (de.dwDebugEventCode) <br>    { <br>    case EXIT_PROCESS_DEBUG_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, IDS_EXITPROCESS, 0); <br> <br>/* uninitialize probe dll */ <br>ResetProbe (); <br> <br>/* process is going away so notify main window */ <br>SendNotifyMessage (lpDbgProcess-&gt;hWnd, <br>   WM_COMMAND, <br>   IDM_PROCESSUNLOAD, <br>   0); <br>break; <br> <br>    case LOAD_DLL_DEBUG_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, IDS_LOADDLL, 0); <br>AddDllNode (lpDbgProcess, <br>    (LOAD_DLL_DEBUG_INFO *)&amp;(de.u.LoadDll)); <br>break; <br> <br>    case UNLOAD_DLL_DEBUG_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, IDS_UNLOADDLL, 0); <br>RemoveDllNode (lpDbgProcess, <br>       (LOAD_DLL_DEBUG_INFO *)&amp;(de.u.LoadDll)); <br>break; <br> <br>    case CREATE_PROCESS_DEBUG_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, IDS_CREATEPROCESS, 0); <br>/* add first thread to linked list of dbg structures */ <br>AddThreadNode (lpDbgProcess, <br>de.dwThreadId, <br>de.u.CreateProcessInfo.hThread, <br>GetThreadPriority (de.u.CreateProcessInfo.hThread), <br>de.u.CreateProcessInfo.lpStartAddress, <br>de.u.CreateProcessInfo.hFile); <br>lpDbgProcess-&gt;hFile = de.u.CreateProcessInfo.hFile; <br>lpDbgProcess-&gt;lpImage = de.u.CreateProcessInfo.lpBaseOfImage; <br>lpDbgProcess-&gt;dwDbgInfoOffset = de.u.CreateProcessInfo.dwDebugInfoFileOffset; <br>lpDbgProcess-&gt;nDbgInfoSize = de.u.CreateProcessInfo.nDebugInfoSize; <br>break; <br> <br>    case CREATE_THREAD_DEBUG_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, IDS_CREATETHREAD, 0); <br>/* add thread to linked list of dbg structures */ <br>AddThreadNode (lpDbgProcess, <br> de.dwThreadId, <br> de.u.CreateThread.hThread, <br> GetThreadPriority (de.u.CreateThread.hThread), <br> de.u.CreateThread.lpStartAddress, <br> NULL); <br>break; <br> <br>    case EXIT_THREAD_DEBUG_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, IDS_EXITTHREAD, 0); <br>/* remove thread record */ <br>RemoveThreadNode (lpDbgProcess, <br>    de.dwThreadId); <br>break; <br> <br>    case EXCEPTION_DEBUG_EVENT: <br>switch (de.u.Exception.ExceptionRecord.ExceptionCode) <br>    { <br>    case EXCEPTION_BREAKPOINT: <br> <br>HandleBreakPoint(lpDbgProcess, de.dwThreadId); <br>SetStatusText (lpDbgProcess-&gt;hWnd, <br>       IDS_BREAKPOINTEXCEPTION, <br>       RGB (0, 0xff, 0)); <br> <br>/* post message to get ball rolling in main thread */ <br>PostMessage (lpDbgProcess-&gt;hWnd, <br> WM_COMMAND, <br> IDM_PROCESSREWALK, <br> 0); <br>break; <br> <br>    case EXCEPTION_ACCESS_VIOLATION: <br>/* record exception information */ <br>SetStatusText (lpDbgProcess-&gt;hWnd, <br>       IDS_ACCESSVIOLATIONEXCEPTION, <br>       RGB (0xff, 0, 0)); <br>RecordException (lpDbgProcess, &amp;de); <br>break; <br> <br>    default: <br>SetStatusText (lpDbgProcess-&gt;hWnd, <br>       IDS_UNHANDLEDEXCEPTION, <br>       RGB (0xff, 0, 0)); <br>RecordException (lpDbgProcess, &amp;de); <br>break; <br>    } <br>break; <br> <br>    case RIP_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, <br>       IDS_RIPEVENT, <br>       RGB (0, 0xff, 0)); <br>break; <br> <br>    case OUTPUT_DEBUG_STRING_EVENT: <br>SetStatusText (lpDbgProcess-&gt;hWnd, <br>       IDS_OUTPUTDEBUGSTRING, <br>       RGB (0, 0xff, 0)); <br>break; <br> <br>    default: <br>break; <br>    } <br>} <br> <br>            if(de.u.Exception.ExceptionRecord.ExceptionCode != EXCEPTION_BREAKPOINT) <br>        ContinueDebugEvent (de.dwProcessId, de.dwThreadId, DBG_EXCEPTION_NOT_HANDLED); <br>            else <br>        ContinueDebugEvent (de.dwProcessId, de.dwThreadId, DBG_CONTINUE); <br>    } <br>break; <br>    } <br> <br>} <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>void WINAPI SuspendDebuggeeProcess ( <br>    DBGPROCESS  *lppr) <br>{ <br>    DBGTHREAD *lpth = (DBGTHREAD *)lppr-&gt;lpThreads; <br> <br>    while (lpth) <br>{ <br>SuspendThread (lpth-&gt;hThread); <br>lpth = (DBGTHREAD *)lpth-&gt;Next; <br>} <br> <br>    /* inform user via status bar */ <br>    SetStatusText (lppr-&gt;hWnd, IDS_PROCESSSUSPENDED, RGB (0xff, 0, 0)); <br>    lppr-&gt;bActive = FALSE; <br>} <br> <br> <br> <br> <br>void WINAPI ResumeDebuggeeProcess ( <br>    DBGPROCESS  *lppr) <br>{ <br>    DBGTHREAD *lpth = (DBGTHREAD *)lppr-&gt;lpThreads; <br> <br>    while (lpth) <br>{ <br>ResumeThread (lpth-&gt;hThread); <br>lpth = (DBGTHREAD *)lpth-&gt;Next; <br>} <br> <br>    /* inform user via status bar */ <br>    SetStatusText (lppr-&gt;hWnd, IDS_PROCESSRESUMED, RGB (0, 0xff, 0)); <br>    lppr-&gt;bActive = TRUE; <br>} <br> <br> <br> <br> <br>void WINAPI AddThreadNode ( <br>    DBGPROCESS      *lppr, <br>    DWORD      dwThreadID, <br>    HANDLE      hThread, <br>    int       nPriority, <br>    LPTHREAD_START_ROUTINE    lpStart, <br>    HANDLE      hFile) <br>{ <br>    DBGTHREAD *lpth; <br>    DBGTHREAD *pNode = lppr-&gt;lpThreads; <br> <br>    /* allocate thread node off heap */ <br>    lpth = (DBGTHREAD *)HeapAlloc (lppr-&gt;hDbgHeap, 0, sizeof (DBGTHREAD)); <br> <br>    /* initialize thread data */ <br>    lpth-&gt;lpStartAddress = lpStart; <br>    lpth-&gt;nPriority = nPriority; <br>    lpth-&gt;dwThreadID = dwThreadID; <br>    lpth-&gt;hThread = hThread; <br>    lpth-&gt;Next = NULL; <br> <br>    /* retieve section names for executable module if file handle passed */ <br>    if (hFile) <br>{ <br>RetrieveModuleName (lppr-&gt;szModule, hFile); <br>lppr-&gt;lpSection = NULL; <br>RetrieveSectionNames (lppr-&gt;hDbgHeap, hFile, &amp;(lppr-&gt;lpSection)); <br>} <br> <br>    /* set linked list pointers */ <br>    while (pNode &amp;&amp; pNode-&gt;Next) <br>pNode = (DBGTHREAD *)pNode-&gt;Next; <br> <br>    if (!pNode) <br>lppr-&gt;lpThreads = lpth; <br>    else <br>(DBGTHREAD *)pNode-&gt;Next = lpth; <br>} <br> <br> <br> <br> <br>void WINAPI RemoveThreadNode ( <br>    DBGPROCESS  *lppr, <br>    DWORD  dwThreadID) <br>{ <br>    DBGTHREAD *pNode = lppr-&gt;lpThreads; <br>    DBGTHREAD *lpth; <br> <br>    while (pNode-&gt;Next &amp;&amp; <br>   ((DBGTHREAD *)(pNode-&gt;Next))-&gt;dwThreadID != dwThreadID) <br>pNode = (DBGTHREAD *)pNode-&gt;Next; <br> <br>    if (pNode-&gt;Next) <br>{ <br>lpth = (DBGTHREAD *)pNode-&gt;Next; <br>pNode-&gt;Next = ((DBGTHREAD *)(pNode-&gt;Next))-&gt;Next; <br>CloseHandle (lpth-&gt;hThread); <br>HeapFree (lppr-&gt;hDbgHeap, 0, (LPSTR)lpth); <br>} <br> <br>    else if (pNode-&gt;dwThreadID == dwThreadID) <br>{ <br>lpth = pNode; <br>lppr-&gt;lpThreads = NULL; <br>CloseHandle (lpth-&gt;hThread); <br>HeapFree (lppr-&gt;hDbgHeap, 0, (LPSTR)lpth); <br>} <br>} <br> <br> <br> <br>/* find a thread's handle based on thread ID */ <br>HANDLEWINAPI FindThreadHandle ( <br>    DBGPROCESS  *lppr, <br>    DWORD  dwThreadId) <br>{ <br>    DBGTHREAD *pNode = lppr-&gt;lpThreads; <br> <br>    while (pNode != NULL) <br>if (pNode-&gt;dwThreadID == dwThreadId) <br>    return (pNode-&gt;hThread); <br>    return NULL; <br>} <br> <br> <br> <br> <br>void WINAPI AddDllNode ( <br>    DBGPROCESS   *lppr, <br>    LOAD_DLL_DEBUG_INFO    *lpdbgDll) <br>{ <br>    DBGDLL    *lpdll; <br>    DBGDLL    *pNode = lppr-&gt;lpDlls; <br> <br>    /* allocate Dll node off heap */ <br>    if ((lpdll = (DBGDLL *)HeapAlloc (lppr-&gt;hDbgHeap, 0, sizeof (DBGDLL))) == NULL) <br>ReportError (IDS_ERRHEAPALLOC); <br> <br>    /* initialize Dll structure */ <br>    lpdll-&gt;hFile = lpdbgDll-&gt;hFile; <br>    lpdll-&gt;lpBaseOfDll = lpdbgDll-&gt;lpBaseOfDll; <br>    lpdll-&gt;dwDebugInfoFileOffset = lpdbgDll-&gt;dwDebugInfoFileOffset; <br>    lpdll-&gt;nDebugInfoSize = lpdbgDll-&gt;nDebugInfoSize; <br>    lpdll-&gt;fUnicode = lpdbgDll-&gt;fUnicode; <br>    lpdll-&gt;Next = NULL; <br>    lpdll-&gt;lpSection = NULL; <br> <br>RetrieveModuleName (lpdll-&gt;szImageName, lpdbgDll-&gt;hFile); <br> <br>    /* get section names for DLL */ <br>    RetrieveSectionNames (lppr-&gt;hDbgHeap, lpdbgDll-&gt;hFile, &amp;(lpdll-&gt;lpSection)); <br> <br>    /* set linked list pointers */ <br>    while (pNode &amp;&amp; pNode-&gt;Next) <br>pNode = (DBGDLL *)pNode-&gt;Next; <br> <br>    if (!pNode) <br>lppr-&gt;lpDlls = lpdll; <br>    else <br>(DBGDLL *)pNode-&gt;Next = lpdll; <br>} <br> <br> <br> <br>void WINAPI RemoveDllNode ( <br>    DBGPROCESS   *lppr, <br>    LOAD_DLL_DEBUG_INFO    *lpdbgDll) <br>{ <br>    DBGDLL  *pNode = lppr-&gt;lpDlls; <br>    DBGDLL  *lpdll; <br>    SECTIONINFO    *pSection, *pNext; <br> <br>    while (pNode-&gt;Next &amp;&amp; <br>   ((DBGDLL *)(pNode-&gt;Next))-&gt;lpBaseOfDll != lpdbgDll-&gt;lpBaseOfDll) <br>pNode = (DBGDLL *)pNode-&gt;Next; <br> <br>    if (pNode-&gt;Next) <br>{ <br>lpdll = (DBGDLL *)pNode-&gt;Next; <br>pNode-&gt;Next = ((DBGDLL *)(pNode-&gt;Next))-&gt;Next; <br> <br>pSection = pNext = lpdll-&gt;lpSection; <br>while (pNext) <br>    { <br>    pNext = (SECTIONINFO *)pSection-&gt;Next; <br>    HeapFree (lppr-&gt;hDbgHeap, 0, (LPSTR)pSection); <br>    pSection = pNext; <br>    } <br> <br>HeapFree (lppr-&gt;hDbgHeap, 0, (LPSTR)lpdll); <br>} <br> <br>    else if (pNode-&gt;lpBaseOfDll == lpdbgDll-&gt;lpBaseOfDll) <br>{ <br>lpdll = pNode; <br>lppr-&gt;lpDlls = NULL; <br> <br>pSection = pNext = lpdll-&gt;lpSection; <br>while (pNext) <br>    { <br>    pNext = (SECTIONINFO *)pSection-&gt;Next; <br>    HeapFree (lppr-&gt;hDbgHeap, 0, (LPSTR)pSection); <br>    pSection = pNext; <br>    } <br> <br>HeapFree (lppr-&gt;hDbgHeap, 0, (LPSTR)lpdll); <br>} <br>} <br> <br> <br> <br>void WINAPI RecordException ( <br>    DBGPROCESS   *lppr, <br>    DEBUG_EVENT    *de) <br>{ <br>    DBGEXCEPTREC    *lper; <br>    DBGEXCEPTREC    *per = lppr-&gt;lpERs; <br>    HANDLE    hThread; <br>    int     i; <br> <br>    /* allocate Dll node off heap */ <br>    if ((lper = (DBGEXCEPTREC *)HeapAlloc (lppr-&gt;hDbgHeap, 0, sizeof (DBGEXCEPTREC))) == NULL) <br>ReportError (IDS_ERRHEAPALLOC); <br> <br>    /* initialize exception record structure */ <br>    lper-&gt;dwThreadId = de-&gt;dwThreadId; <br>    lper-&gt;dwFirstChance = de-&gt;u.Exception.dwFirstChance; <br>    lper-&gt;ExceptRecord.ExceptionCode = de-&gt;u.Exception.ExceptionRecord.ExceptionCode; <br>    lper-&gt;ExceptRecord.ExceptionFlags = de-&gt;u.Exception.ExceptionRecord.ExceptionFlags; <br>    lper-&gt;ExceptRecord.ExceptionRecord = NULL; <br>    lper-&gt;ExceptRecord.ExceptionAddress = de-&gt;u.Exception.ExceptionRecord.ExceptionAddress; <br>    lper-&gt;ExceptRecord.NumberParameters = de-&gt;u.Exception.ExceptionRecord.NumberParameters; <br>    for (i=0; i&lt;EXCEPTION_MAXIMUM_PARAMETERS; i++) <br>lper-&gt;ExceptRecord.ExceptionInformation[i] = <br>   de-&gt;u.Exception.ExceptionRecord.ExceptionInformation[i]; <br> <br>    /* get exception thread handle */ <br>    hThread = FindThreadHandle (lppr, de-&gt;dwThreadId); <br>    lper-&gt;Context.ContextFlags = CONTEXT_CONTROL; <br>    GetThreadContext (hThread, &amp;(lper-&gt;Context)); <br> <br>    /* set linked list pointers */ <br>    while (per &amp;&amp; per-&gt;Next) <br>per = (DBGEXCEPTREC *)per-&gt;Next; <br>    if (!per) <br>lppr-&gt;lpERs = lper; <br>    else <br>(DBGEXCEPTREC *)per-&gt;Next = lper; <br>} <br> <br> <br> <br>/* <br> * MIPS/ALPHA/PPC must increment the FIR/Iar on a breakpoint <br> * in order to fetch the next instruction <br> */ <br> <br>int WINAPI HandleBreakPoint( <br>    DBGPROCESS      *lppr, <br>    DWORD      dwThreadID <br>    ) <br>{ <br>    CONTEXT   ThreadContext; <br>    DBGTHREAD *pNode = lppr-&gt;lpThreads; <br>    HANDLE    hThread; <br> <br>    while (pNode &amp;&amp; pNode-&gt;dwThreadID != dwThreadID) <br>pNode = (DBGTHREAD *)pNode-&gt;Next; <br> <br>    if(!pNode) <br>return(0); <br>    else <br>{ <br>        hThread = (HANDLE) pNode-&gt;hThread; <br> <br>        ThreadContext.ContextFlags = CONTEXT_CONTROL; <br>        if (!GetThreadContext (hThread, &amp;ThreadContext)) <br>    { <br>    ReportError (IDS_ERRGETTHREADCONTEXT); <br>            return(0); <br>    } <br> <br>#ifdef _PPC_ <br>        ThreadContext.Iar += 4; <br>#elif !defined _X86_ <br>        ThreadContext.Fir += 4; <br>#endif <br> <br>        if (!SetThreadContext (hThread, &amp;ThreadContext)) <br>    { <br>    ReportError (IDS_ERRSETTHREADCONTEXT); <br>    return (0); <br>    } <br> <br>return (1); <br>} <br>} <br> <br> <br> <br>int   WINAPI WhereIsStack ( <br>    HANDLE  hThreadContext) <br>{ <br>    CONTEXTThreadContext; <br> <br>    ThreadContext.ContextFlags = CONTEXT_CONTROL; <br>    if (!GetThreadContext (hThreadContext, &amp;ThreadContext)) <br>ReportError (IDS_ERRGETTHREADCONTEXT); <br> <br>#ifdef _X86_ <br>    return ThreadContext.Esp; <br>#elif defined (_PPC_) <br>    return (int) ThreadContext.Gpr1; <br>#else /* _MIPS_ */ <br>    return (int) ThreadContext.IntSp; <br>#endif <br> <br>} <br> <br> <br> <br>/* function walks memory regions of process */ <br>int    WINAPI WalkProcess ( <br>    HANDLE    hChildProcess, <br>    LPVOID    *lpWalk, <br>    LPINT     *lpObjects) <br>{ <br>    LPVMOBJECT  lpList; <br>    LPVOID  lpMem = 0; <br>    LPVOID  lpStack = 0; <br>    int   nCnt, i; <br>    SYSTEM_INFO   si; <br> <br>    /* if pointer exists, reset to no commit */ <br>    if (*lpWalk) <br>{ <br>if (!VirtualFree (*lpWalk, 0, MEM_DECOMMIT)) <br>    ReportError (IDS_ERRVIRTUALFREE); <br>} <br> <br>    /* else perform initial reserve */ <br>    else <br>if ((*lpWalk = VirtualAlloc (NULL, <br>     TOTALVMRESERVE, <br>     MEM_RESERVE, <br>     PAGE_NOACCESS)) == NULL) <br>    ReportError (IDS_ERRVIRTUALALLOC); <br> <br>    /* initialize list pointer to beginning of walker list */ <br>    lpList = (LPVMOBJECT)*lpWalk; <br> <br>    /* Get maximum address range from system info */ <br>    GetSystemInfo(&amp;si); <br> <br>    /* walk process addresses */ <br>    while (lpMem &lt; si.lpMaximumApplicationAddress) <br>{ <br>try  /* virtual memory exception handler automatically commits mem */ <br>    { <br>    /* touch memory in VMOBJECT structure that exists after mbi field to trigger <br>       access violation for a new page of memory.  Do this here since VirtualQueryEx <br>       does not seem to generate exceptions, rather it just fails calls */ <br>    *lpList-&gt;szObjType = 0; <br>    *lpList-&gt;szModule = 0; <br>    *lpList-&gt;szSection = 0; <br>    lpList-&gt;bNew = 0; <br> <br>    VirtualQueryEx (hChildProcess, <br>    lpMem, <br>    &amp;(lpList-&gt;mbi), <br>    sizeof (MEMORY_BASIC_INFORMATION)); <br> <br>    /* increment lpMem to next region of memory */ <br>    lpMem = (LPVOID)((DWORD)lpList-&gt;mbi.BaseAddress + <br>     (DWORD)lpList-&gt;mbi.RegionSize); <br> <br>    lpList++; <br>    } <br> <br>except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) <br>    { <br>    /* commit next page of walker list memory */ <br>    if (((int)lpList + 4096) &lt; (int)*lpWalk + TOTALVMRESERVE) <br>VirtualAlloc ((LPVOID)((int)lpList + sizeof (VMOBJECT)), <br>      4096, <br>      MEM_COMMIT, <br>      PAGE_READWRITE); <br>    else <br>{ <br>NotifyUser (NULL, <br>    IDS_ERROR, <br>    IDS_NOTENOUGHMEM, <br>    " reserved for Objects", <br>    MB_OK); <br>return 0; <br>} <br>    } <br>} <br> <br>    /* allocate objects index array */ <br>    if (*lpObjects) <br>LocalFree (*lpObjects); <br>    nCnt = (((int)(LPVOID)lpList)-(int)*lpWalk)/sizeof (VMOBJECT); <br>    *lpObjects = LocalAlloc (LPTR, nCnt * sizeof (int)); <br>    for (i=0; i&lt;nCnt; i++) <br>(*lpObjects)[i] = i; <br> <br>    /* return number of item in list */ <br>    return (nCnt); <br>} <br> <br> <br> <br> <br>void WINAPI AnalyzeProcess ( <br>    DBGPROCESS  *lpDbgProcess, <br>    LPVMOBJECT  lpVMObject, <br>    int   nObjects) <br>{ <br>    DBGTHREAD*pTh = lpDbgProcess-&gt;lpThreads; <br>    DBGDLL*pDll = lpDbgProcess-&gt;lpDlls; <br>    int nStack; <br>    int nThreadCnt = 0; <br>    charszNum[10]; <br>    charszObjDesc[MAX_PATH]; <br>    SECTIONINFO  *pSection; <br>    int i; <br>    MEMORY_BASIC_INFORMATIONmbi; <br>    LPPROBElpProbe; <br> <br> <br>    /* name default heap in process if available */ <br>    if (lpProbe = RetrieveProbeData ()) <br>{ <br>VirtualQueryEx (lpDbgProcess-&gt;hProcess, (PVOID)lpProbe-&gt;hDefHeap, &amp;mbi, sizeof (mbi)); <br> <br>/* ignore invalid regions with a base region of 0 */ <br>if (mbi.AllocationBase) <br>    { <br>    /* find all objects with same base region */ <br>    for (i=0; i&lt;nObjects; i++) <br>{ <br>if (lpVMObject[i].mbi.AllocationBase == mbi.AllocationBase) <br>    { <br>    strcpy (lpVMObject[i].szObjType, "heap"); <br>    strcpy (lpVMObject[i].szModule, "process default"); <br>    } <br>} <br>    } <br>} <br> <br>    /* name stack object for each thread in process */ <br>    while (pTh != NULL) <br>{ <br>/* get stack location for thread */ <br>nStack = WhereIsStack (pTh-&gt;hThread); <br> <br>strcpy (szObjDesc, "Thread "); <br>strcat (szObjDesc, itoa (nThreadCnt, szNum, 10)); <br> <br>/* locate base region */ <br>VirtualQueryEx (lpDbgProcess-&gt;hProcess, (PVOID)nStack, &amp;mbi, sizeof (mbi)); <br> <br>/* ignore invalid regions with a base region of 0 */ <br>if (mbi.AllocationBase) <br>    { <br>    /* find all objects with same base region */ <br>    for (i=0; i&lt;nObjects; i++) <br>{ <br>if (lpVMObject[i].mbi.AllocationBase == mbi.AllocationBase) <br>    { <br>    strcpy (lpVMObject[i].szObjType, "stack"); <br>    strcpy (lpVMObject[i].szModule, szObjDesc); <br>    } <br>} <br>    } <br> <br>/* locate and identify the guard page in each stack. <br>   The guard page is a single page of committed memory at the lower end of <br>   committed memory and immediately adjacent to the stack's reserved memory. <br>   If there is no more reserved stack space left, the guard page will be the <br>   last page of committed memory.  A stack cannot exist without a guard page. <br>   There will be at most three regions of memory in the stack: the actual stack <br>   space is committed, the guard page is committed and the remaining address <br>   space is marked reserved. */ <br>/* locate lowest region of stack, since objects array is not sorted until after <br>   this function, it is always in ascending address order :) */ <br>i=0; <br>while (i&lt;nObjects &amp;&amp; <br>       (int)lpVMObject[i].mbi.BaseAddress &lt; nStack &amp;&amp; <br>       lpVMObject[i].mbi.AllocationBase != mbi.AllocationBase) <br>    i++; <br> <br>if (i&lt;nObjects &amp;&amp; <br>    lpVMObject[i].mbi.AllocationBase == mbi.AllocationBase) <br>    { <br>    if (lpVMObject[i].mbi.State == MEM_RESERVE) <br>i++; <br> <br>    /* identify guard page in section field */ <br>    strcpy (lpVMObject[i].szSection, "guard"); <br>    } <br> </code></pre>
<p>
</p>
<pre><code>/* increment thread count */ <br>nThreadCnt++; <br> <br>/* increment list pointer */ <br>pTh = (DBGTHREAD *)pTh-&gt;Next; <br>} <br> <br>    /* name DLL objects in process */ <br>    while (pDll != NULL) <br>{ <br>/* locate dll base region */ <br>VirtualQueryEx (lpDbgProcess-&gt;hProcess, pDll-&gt;lpBaseOfDll, &amp;mbi, sizeof (mbi)); <br> <br>/* ignore invalid regions with a base region of 0 */ <br>if (mbi.AllocationBase) <br>    { <br>    /* find all objects with same base region */ <br>    for (i=0; i&lt;nObjects; i++) <br>{ <br>if (lpVMObject[i].mbi.AllocationBase == mbi.AllocationBase) <br>    { <br>    strcpy (lpVMObject[i].szObjType, "dll"); <br>    strcpy (lpVMObject[i].szModule, pDll-&gt;szImageName); <br>    } <br>} <br>    } <br> <br>/* name dll sections */ <br>pSection = (SECTIONINFO *)pDll-&gt;lpSection; <br>while (pSection != NULL) <br>    { <br>    i = 0; <br>    while (i++&lt;nObjects) <br>{ <br>if (lpVMObject[i].mbi.BaseAddress == <br>((char *)pDll-&gt;lpBaseOfDll + pSection-&gt;uVirtualAddress)) <br>    { <br>    strcpy (lpVMObject[i].szSection, pSection-&gt;szSection); <br>    break; <br>    } <br>} <br>    pSection = (SECTIONINFO *)pSection-&gt;Next; <br>    } <br> <br>/* increment list pointer */ <br>pDll = (DBGDLL *)pDll-&gt;Next; <br>} <br> <br>    /* locate exe base region */ <br>    VirtualQueryEx (lpDbgProcess-&gt;hProcess, lpDbgProcess-&gt;lpImage, &amp;mbi, sizeof (mbi)); <br> <br>    /* ignore invalid regions with a base region of 0 */ <br>    if (mbi.AllocationBase) <br>{ <br>/* find all objects with same base region */ <br>for (i=0; i&lt;nObjects; i++) <br>    { <br>    if (lpVMObject[i].mbi.AllocationBase == mbi.AllocationBase) <br>{ <br>strcpy (lpVMObject[i].szObjType, "exe"); <br>strcpy (lpVMObject[i].szModule, lpDbgProcess-&gt;szModule); <br>} <br>    } <br>} <br> <br>    /* name exe sections */ <br>    pSection = lpDbgProcess-&gt;lpSection; <br>    while (pSection != NULL) <br>{ <br>i = 0; <br>while (i++&lt;nObjects) <br>    { <br>    if (lpVMObject[i].mbi.BaseAddress == <br>    ((char *)lpDbgProcess-&gt;lpImage + pSection-&gt;uVirtualAddress)) <br>{ <br>strcpy (lpVMObject[i].szSection, pSection-&gt;szSection); <br>break; <br>} <br>    } <br>pSection = (SECTIONINFO *)pSection-&gt;Next; <br>} <br>} <br> <br> <br> <br> <br>/* find all occurrances of objects having same base region */ <br>void WINAPI NameObjects ( <br>    HANDLE  hProcess, <br>    LPVOID  lpAddress, <br>    LPVMOBJECT  lpVMObj, <br>    int   nObjects, <br>    char  *lpszObjType, <br>    char  *lpszModule) <br>{ <br>    int i; <br>    MEMORY_BASIC_INFORMATIONmbi; <br> <br>    /* locate base region */ <br>    VirtualQueryEx (hProcess, lpAddress, &amp;mbi, sizeof (mbi)); <br> <br>    /* ignore invalid regions with a base region of 0 */ <br>    if (!mbi.AllocationBase) <br>return; <br> <br>    /* find all objects with same base region */ <br>    for (i=0; i&lt;nObjects; i++) <br>{ <br>if (lpVMObj[i].mbi.AllocationBase == mbi.AllocationBase) <br>    { <br>    strcpy (lpVMObj[i].szObjType, lpszObjType); <br>    strcpy (lpVMObj[i].szModule, lpszModule); <br>    } <br>} <br>} <br> <br> <br> <br> <br>void WINAPI IdentifyNewObjects ( <br>    LPVMOBJECT  lpVMObjectOld, <br>    int   nObjectsOld, <br>    LPVMOBJECT  lpVMObject, <br>    int   nObjects) <br>{ <br>    int    i, j; <br> <br>    for (i=0; i&lt;nObjects; i++) <br>{ <br>for (j=0; j&lt;nObjectsOld; j++) <br>    { <br>    if (VMCompare (lpVMObject+i, lpVMObjectOld+j)) <br>goto NEXT; <br>    } <br> <br>/* if not found must be a new item */ <br>lpVMObject[i].bNew = TRUE; <br>NEXT:; <br>} <br>} <br> <br> <br>BOOL WINAPI VMCompare ( <br>    LPVMOBJECT  lpVM1, <br>    LPVMOBJECT  lpVM2) <br>{ <br> <br>    /* compare memory info */ <br>    if (lpVM1-&gt;mbi.AllocationBase      != lpVM2-&gt;mbi.AllocationBase  || <br>lpVM1-&gt;mbi.BaseAddress       != lpVM2-&gt;mbi.BaseAddress  || <br>lpVM1-&gt;mbi.RegionSize       != lpVM2-&gt;mbi.RegionSize   || <br>lpVM1-&gt;mbi.Protect       != lpVM2-&gt;mbi.Protect  || <br>lpVM1-&gt;mbi.AllocationProtect   != lpVM2-&gt;mbi.AllocationProtect  || <br>lpVM1-&gt;mbi.State       != lpVM2-&gt;mbi.State  || <br>lpVM1-&gt;mbi.Type        != lpVM2-&gt;mbi.Type     ) <br>return FALSE; <br> <br>    /* compare character information */ <br>    if (memcmp ((LPVOID)lpVM1-&gt;szObjType, (LPVOID)lpVM2-&gt;szObjType, 12) || <br>memcmp ((LPVOID)lpVM1-&gt;szSection, <br>(LPVOID)lpVM2-&gt;szSection, <br>IMAGE_SIZEOF_SHORT_NAME)|| <br>memcmp ((LPVOID)lpVM1-&gt;szModule, (LPVOID)lpVM2-&gt;szModule, MAX_PATH)) <br>return FALSE; <br> <br>    /* if still here, must be a match */ <br>    return TRUE; <br>} <br> <br> <br> <br> <br>/* test to see if all memory objects in range are committed */ <br>BOOL   WINAPI CommittedMemoryRange ( <br>    int   i, <br>    int   j, <br>    LPVMOBJECT  lpvm, <br>    int   *Objects) <br>{ <br>    int    k; <br> <br>    /* test each memory object in range */ <br>    for (k = min(i, j); k &lt;= max (i, j); k++) <br>/* report any non committed memory regions */ <br>if (lpvm[Objects[k]].mbi.State != MEM_COMMIT) <br>    return FALSE; <br> <br>    /* report all committed range */ <br>    return TRUE; <br>} <br> <br> <br> <br> <br>/* signal debugger thread to access process memory */ <br>BOOL WINAPI AccessProcessMemory ( <br>    HANDLE    hMemoryEvent, <br>    HANDLE    hAckEvent, <br>    LPVOID    lpAddress, <br>    LPVOID    lpBuffer, <br>    DWORD     *dwSize) <br>{ <br>    DWORD    dwResult; <br> <br>    /* copy data to module globals */ <br>    PMAAddress = lpAddress; <br>    PMABuffer = lpBuffer; <br>    PMASize = *dwSize; <br> <br>    /* signal debugger thread to read memory from process */ <br>    SetEvent (hMemoryEvent); <br> <br>    /* wait on debugger thread to signal completion of memory task */ <br>    dwResult = WaitForSingleObject (hAckEvent, 100000); <br>    ResetEvent (hAckEvent); <br> <br>    /* reset size accessed to verify operation */ <br>    *dwSize = PMASize; <br> <br>    return (dwResult == WAIT_OBJECT_0 &amp;&amp; <br>    PMASize != 0); <br>} <br> <br> <br> <br> <br>BOOL WINAPI InterruptThread_HookProcess ( <br>    DBGPROCESS       *lpDbgProcess, <br>    LPPROCESS_STATE    lpState) <br>{ <br>    DBGDLL*pDlls = lpDbgProcess-&gt;lpDlls; <br>    int nBytes, nLen, i; <br>    MEMORY_BASIC_INFORMATIONmbi; <br>    LPVOIDlpLoadLibrary = NULL; <br>    charszKernel[] = "KERNEL32.DLL"; <br>    charszFunction[] = "LoadLibraryA"; <br>    BYTEpCode[PAGESIZE]; <br>    BYTEpStack[PAGESIZE]; <br>    HANDLEhDll; <br> <br> <br>    /* initialize stack and code pages */ <br>    for (i=0; i&lt;PAGESIZE; i++) <br>{ <br>pStack[i] = 0; <br>pCode[i] = 0; <br>} <br> <br>    /* find kernel32 Dll */ <br>    while (pDlls != NULL) <br>{ <br>if (!stricmp (pDlls-&gt;szImageName, szKernel)) <br>    break; <br>pDlls = (DBGDLL *)pDlls-&gt;Next; <br>} <br> <br>    /* if DLL not loaded abort */ <br>    if (pDlls == NULL) <br>return FALSE; <br> <br>    /* load the dll in this process, find the function offset in this <br>       process and normalize to the offset in the child process */ <br>    hDll = LoadLibrary (szKernel); <br>    lpLoadLibrary = GetProcAddress (hDll, szFunction); <br>    VirtualQuery (lpLoadLibrary, &amp;mbi, sizeof (mbi)); <br>    (int)lpLoadLibrary += ((int)pDlls-&gt;lpBaseOfDll - (int)mbi.AllocationBase); <br>    FreeLibrary (hDll); <br> <br>    /* get thread context information and save for replacement */ <br>    lpState-&gt;Context.ContextFlags = CONTEXT_FULL; <br>    if (!GetThreadContext (lpDbgProcess-&gt;lpThreads-&gt;hThread, &amp;(lpState-&gt;Context))) <br>return FALSE; <br> <br>#ifdef _X86_ <br>    lpState-&gt;Eip = (LPVOID)lpState-&gt;Context.Eip; <br>    lpState-&gt;Esp = (LPVOID)lpState-&gt;Context.Esp; <br>#elif defined(_PPC_) <br>    lpState-&gt;Eip = (LPVOID)lpState-&gt;Context.Iar; <br>    lpState-&gt;Esp = (LPVOID)lpState-&gt;Context.Gpr1; <br>#else /* MIPS */ <br>    lpState-&gt;Eip = (LPVOID)lpState-&gt;Context.Fir; <br>    lpState-&gt;Esp = (LPVOID)lpState-&gt;Context.IntSp; <br>#endif <br> <br>    /* locate first writeable code page in exe module */ <br>    lpState-&gt;pCodePage = lpDbgProcess-&gt;lpImage; <br>    VirtualQueryEx (lpDbgProcess-&gt;hProcess, lpState-&gt;pCodePage, &amp;mbi, sizeof (mbi)); <br>    while (!(mbi.Protect &amp; PAGE_READWRITE) &amp;&amp; <br>   mbi.AllocationBase == lpDbgProcess-&gt;lpImage) <br>{ <br>(int)lpState-&gt;pCodePage = (int)mbi.BaseAddress + mbi.RegionSize; <br>VirtualQueryEx (lpDbgProcess-&gt;hProcess, lpState-&gt;pCodePage, &amp;mbi, sizeof (mbi)); <br>} <br> <br>    if (mbi.AllocationBase != lpDbgProcess-&gt;lpImage) <br>return FALSE; <br> <br>    /* save code page for reset process */ <br>    ReadProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pCodePage, lpState-&gt;Code, PAGESIZE, &amp;nBytes); <br> <br>    /* write DLL path to code page */ <br>    strcpy ((char *)pCode, szCurPath); <br>    strcat ((char *)pCode, "\\probe.dll"); <br>    nLen = strlen ((char *)pCode) + 1; <br> <br>    /* find current stack page and save  */ <br> <br>#ifdef _X86_ <br>    lpState-&gt;pStackPage = (LPVOID)((((int)lpState-&gt;Context.Esp)/PAGESIZE) * PAGESIZE); <br>#elif defined(_PPC_) <br>    lpState-&gt;pStackPage = (LPVOID)((((int)lpState-&gt;Context.Gpr1)/PAGESIZE) * PAGESIZE); <br>#else /* MIPS */ <br>    lpState-&gt;pStackPage = (LPVOID)((((int)lpState-&gt;Context.IntSp)/PAGESIZE) * PAGESIZE); <br>#endif <br> <br>    ReadProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pStackPage, lpState-&gt;Stack, PAGESIZE, &amp;nBytes); <br> <br>    /* push address of DLL string on stack */ <br>    *((int *)(pStack+4092)) = (int)lpState-&gt;pCodePage; <br> <br>    /* push return address on stack */ <br>    *((int *)(pStack+4088)) = (int)lpState-&gt;pCodePage+nLen; <br> <br>    /* return to Int 3 breakpoint instruction */ <br>    pCode[nLen] = 0xCC; <br> <br>    /* write new code and stack pages */ <br>    WriteProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pCodePage, pCode, PAGESIZE, &amp;nBytes); <br>    WriteProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pStackPage, pStack, PAGESIZE, &amp;nBytes); <br> <br>    /* update Eip to execute at actual LoadLibrary function */ <br>    /* adjust stack pointer to point to return address */ <br> <br>#ifdef _X86_ <br>    lpState-&gt;Context.Eip = (UINT)lpLoadLibrary; <br>    lpState-&gt;Context.Esp = (UINT)lpState-&gt;pStackPage+4088; <br>#elif defined(_PPC_) <br>    lpState-&gt;Context.Iar = (UINT)lpLoadLibrary; <br>    lpState-&gt;Context.Gpr1 = (UINT)lpState-&gt;pStackPage+4088; <br>#else /* _MIPS_ */ <br>    lpState-&gt;Context.Fir = (UINT)lpLoadLibrary; <br>    lpState-&gt;Context.IntSp = (UINT)lpState-&gt;pStackPage+4088; <br>#endif <br> <br>    if (!SetThreadContext (lpDbgProcess-&gt;lpThreads-&gt;hThread, &amp;(lpState-&gt;Context))) <br>{ <br>ReportError (IDS_ERRSETTHREADCONTEXT); <br>/* replace code and stack pages */ <br>WriteProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pCodePage, lpState-&gt;Code, PAGESIZE, &amp;nBytes); <br>WriteProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pStackPage, lpState-&gt;Stack, PAGESIZE, &amp;nBytes); <br>return FALSE; <br>} <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>void WINAPI ResetInterruptedThread ( <br>    DBGPROCESS       *lpDbgProcess, <br>    LPPROCESS_STATE    lpState) <br>{ <br>    int    nBytes; <br> <br>    /* return thread context information */ <br> <br>#ifdef _X86_ <br>    lpState-&gt;Context.Eip = (UINT)lpState-&gt;Eip; <br>    lpState-&gt;Context.Esp = (UINT)lpState-&gt;Esp; <br>#elif defined(_PPC_) <br>    lpState-&gt;Context.Iar = (UINT)lpState-&gt;Eip; <br>    lpState-&gt;Context.Gpr1 = (UINT)lpState-&gt;Esp; <br>#else /* MIPS */ <br>    lpState-&gt;Context.Fir = (UINT)lpState-&gt;Eip; <br>    lpState-&gt;Context.IntSp = (UINT)lpState-&gt;Esp; <br>#endif <br> <br>    SetThreadContext (lpDbgProcess-&gt;lpThreads-&gt;hThread, &amp;(lpState-&gt;Context)); <br> <br>    /* return code and stack information */ <br>    WriteProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pCodePage, lpState-&gt;Code, PAGESIZE, &amp;nBytes); <br>    WriteProcessMemory (lpDbgProcess-&gt;hProcess, lpState-&gt;pStackPage, lpState-&gt;Stack, PAGESIZE, &amp;nBytes); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
