<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PWALK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5761"></a>PWALK.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>* <br>* <br>*  Note:  pwalk will only work correctly with Win32 applications. <br>* <br>* <br>\******************************************************************************/ <br> <br>#include "pwalk.h" <br> <br>#define strtok      My_mbstok <br> <br>#define MAX_DRIVES    26    /* maximum number of logical drives */ <br> <br>/* system constants used externally */ <br>int     xChar, <br>     yChar, <br>     xScreen, <br>     yScreen, <br>     yFrame, <br>     xFrame, <br>     yCaption, <br>     xVScrollBar; <br> <br>char     szCaptionText[] ="Address\0State\0Prot\0Size\0BaseAddr\0Object\0Section\0Name\0"; <br>char     szFormat[] = "%08lX~%s ~%s ~%lu~%08lX~%s ~%s ~%s ~"; <br>SIZE                 sChar0; <br>char     szFormatPages[] = "%05lX~%s ~%s ~%lu~%05lX~%s ~%s ~%s ~"; <br>int                  taColumns[] = {TA_RIGHT,  TA_LEFT, TA_LEFT, TA_RIGHT, <br>                                    TA_RIGHT, TA_RIGHT, TA_LEFT,  TA_LEFT, <br>                                   }; <br>int                  xColumns[]  = {      8,       9,      17,       31, <br>                                         40,      46,      47,       55, <br>                                   }; <br>BOOL     bNumbersAsBytes = TRUE; <br>HFONT     hFontVar; <br> <br>char     szFilePath[MAX_PATH] = ""; <br>char     szFilename[MAX_PATH] = ""; <br>HFONT     hFont; <br>LPVOID     lpWalkerList = NULL; <br>int     *Objects; <br>int     nSortType = IDM_SORTADDRESS; <br>HWND     hWndSysStat, hWndProStat, hInitDlg, hMemWnd; <br>HANDLE     hChildEvents[nDEBUGEVENTS]; <br>DBGPROCESS     *lpChildProcess = NULL; <br>HMENU     hPopup[MENUPOPUPS]; <br>char     szCurPath[MAX_PATH]; <br> <br> <br>/* local functions */ <br>BOOL   WINAPI InitEnvironment (HANDLE, int, char *); <br>void   WINAPI InitMenu (HWND); <br>void   WINAPI DrawListItem (DRAWITEMSTRUCT *); <br>int    WINAPI MakeVMQString (int, char *); <br>DWORD  WINAPI VMExceptionFilter (EXCEPTION_POINTERS *); <br>void   WINAPI SortList (HWND, int); <br>BOOL   WINAPI ViewableMemorySelection (HWND); <br>static void TextOutFields (HDC, int, LPRECT, LPSTR); <br> <br> <br>/**************************************************************************** <br>    My_mbschr:  strchr() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbschr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    if (*psz == '\0' &amp;&amp; uiSep != '\0') { <br>        return NULL; <br>    } else { <br>        return psz; <br>    } <br>} <br>/**************************************************************************** <br>    My_mbstok:  strtok() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbstok( <br>    unsigned char *pszSrc, unsigned char *pszSep) <br>{ <br>    static char *pszSave = NULL; <br>    char *pszHead; <br>    char *psz; <br> <br>    if (pszSrc == NULL) { <br>        if (pszSave == NULL) { <br>            return NULL; <br>        } else { <br>            psz = pszSave; <br>        } <br>    } else { <br>        psz = pszSrc; <br>    } <br> <br>    /*********************************************/ <br>    /* Skip delimiters to find a head of a token */ <br>    /*********************************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            break; <br>        } else if (NULL == My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        //No more token <br>        return (pszSave = NULL); <br>    } <br>    pszHead = psz; <br> <br>    /******************************/ <br>    /* Search a Tail of the token */ <br>    /******************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            psz += 2; <br>            continue; <br>        } else if (NULL != My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        pszSave = NULL; <br>    } else { <br>        //Found next delimiter <br>        pszSave = psz + 1; <br>        *psz = '\0'; <br>    } <br>    return pszHead; <br>} <br> <br> <br>/* entry point of this executable */ <br>int WINAPI WinMain (hInstance, hPrevInstance, lpCmdLine, nCmdShow) <br>    HINSTANCE hInstance; <br>    HINSTANCE hPrevInstance; <br>    LPSTR     lpCmdLine; <br>    int       nCmdShow; <br>{ <br>    MSG      msg; <br>    char     *lpszCmdLine = NULL; <br>    char     *lpCL; <br>    BOOL     bSwitch; <br> <br>    /* set current path for use later */ <br>    GetCurrentDirectory (MAX_PATH, szCurPath); <br> <br>    // parse and copy command line parameters to local memory <br>    lpCL = GetCommandLine (); <br>    if (lpszCmdLine = (char *)LocalAlloc (LPTR, strlen (lpCL) + 1)) <br>GetCmdLine (lpCL, lpszCmdLine, &amp;bSwitch); <br> <br>    /* start window environment */ <br>    if (!InitEnvironment (hInstance, nCmdShow, IsValidFile (lpszCmdLine) ? lpszCmdLine : NULL)) <br>return FALSE; <br> <br>    /* free memory allocated for lpCmdLine */ <br>    if (lpszCmdLine) <br>LocalFree ((HLOCAL)lpszCmdLine); <br> <br>    /* main window message loop */ <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) <br>{ <br>TranslateMessage (&amp;msg); <br>DispatchMessage (&amp;msg); <br>} <br> <br>    /* return success of application */ <br>    return TRUE; <br>} <br> <br> <br> <br>/*  start app */ <br>BOOL WINAPI InitEnvironment ( <br>    HANDLE    hInstance, <br>    int       nCmdShow, <br>    char      *lpszCmdLine) <br>    { <br>    WNDCLASS   wc; <br>    char       szClass[MAX_PATH]; <br>    char       szTitle[MAX_PATH]; <br>    char       szFilename[MAX_PATH]; <br>    HWND       hWnd; <br> <br> <br>    /* register system statistics window class */ <br>    LoadString (hInstance, IDS_SYSSTATCLASS, szClass, sizeof (szClass)); <br>    wc.style     = 0; <br>    wc.lpfnWndProc   = (WNDPROC)SysStatWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon     = LoadIcon (hInstance, MAKEINTRESOURCE (IDR_SYSSTATICON)); <br>    wc.hCursor     = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = szClass; <br>    if (!RegisterClass (&amp;wc) ) <br>return FALSE; <br> <br>    /* register process statistics window class */ <br>    LoadString (hInstance, IDS_PROSTATCLASS, szClass, sizeof (szClass)); <br>    wc.style     = 0; <br>    wc.lpfnWndProc   = (WNDPROC)ProStatWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon     = LoadIcon (hInstance, MAKEINTRESOURCE (IDR_PROSTATICON)); <br>    wc.hCursor     = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = szClass; <br>    if (!RegisterClass (&amp;wc) ) <br>return FALSE; <br> <br>    /* register the status bar window class */ <br>    LoadString (hInstance, IDS_STATUSCLASS, szClass, sizeof (szClass)); <br>    wc.style     = 0; <br>    wc.lpfnWndProc   = (WNDPROC)StatusWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = STATUSWXB; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon     = (HICON)NULL; <br>    wc.hCursor     = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = szClass; <br>    if (!RegisterClass (&amp;wc) ) <br>return FALSE; <br> <br>    /* register the main frame window class */ <br>    LoadString (hInstance, IDS_MEMVIEWCLASS, szClass, sizeof (szClass)); <br>    wc.style     = 0; <br>    wc.lpfnWndProc   = (WNDPROC)MemWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = VIEWWXB; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon     = LoadIcon (hInstance, MAKEINTRESOURCE (IDR_MAINICON)); <br>    wc.hCursor     = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = szClass; <br>    if (!RegisterClass (&amp;wc) ) <br>return FALSE; <br> <br>    /* register the main frame window class */ <br>    LoadString (hInstance, IDS_WALKERCLASS, szClass, sizeof (szClass)); <br>    wc.style     = 0; <br>    wc.lpfnWndProc   = (WNDPROC)WalkerWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon     = LoadIcon (hInstance, MAKEINTRESOURCE (IDR_MAINICON)); <br>    wc.hCursor     = LoadCursor (0, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = MAKEINTRESOURCE (IDR_WALKERMENU); <br>    wc.lpszClassName = szClass; <br>    if (!RegisterClass (&amp;wc) ) <br>return FALSE; <br> <br>    /* create window caption */ <br>    LoadString (hInstance, IDS_CAPTION, szTitle, sizeof (szTitle)); <br>    if (lpszCmdLine != NULL &amp;&amp; <br>((lpChildProcess = StartChildProcess (NULL, lpszCmdLine, hChildEvents)) != NULL)) <br>GetFileFromPath (lpszCmdLine, szFilename); <br>    else <br>LoadString (hInstance, IDS_SELF, szFilename, MAX_PATH); <br>    strcat (szTitle, szFilename); <br> <br>    /* create main frame window */ <br>    hWnd = CreateWindow (szClass, <br> szTitle, <br> WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br> CW_USEDEFAULT, <br> 0, <br> CW_USEDEFAULT, <br> 0, <br> NULL, <br> NULL, <br> hInstance, <br> NULL); <br> <br>    /* update parent window handle in child process information structure */ <br>    if (lpChildProcess != NULL) <br>lpChildProcess-&gt;hWnd = hWnd; <br> <br>    if (!hWnd) <br>return 0; <br> <br>    ShowWindow (hWnd, nCmdShow); <br>    UpdateWindow (hWnd); <br>    return TRUE; <br>} <br> <br> <br>/* main window procedure */ <br>LONG WINAPI WalkerWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>       LONG    lRet = 1; <br> <br>static LOGFONT lf_Font = { <br> -10, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, ANSI_CHARSET, <br> OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, <br> DEFAULT_QUALITY, FIXED_PITCH | FF_DONTCARE, <br>                         "Courier", <br> }; <br>static LOGFONT lf_FontVar = { <br>   -10, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE, ANSI_CHARSET, <br> OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, <br> DEFAULT_QUALITY, 0, // FIXED_PITCH | FF_DONTCARE, <br>                         "MS Sans Serif", <br> }; <br> <br> <br>    /* On a Japanese system, change the fonts...  should generalize to all FE */ <br>    if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) { <br>        lf_Font.lfCharSet = SHIFTJIS_CHARSET; <br>        lstrcpy (lf_Font.lfFaceName , "Terminal"); <br> <br>        lf_FontVar.lfHeight= -12; <br>        lf_FontVar.lfCharSet = SHIFTJIS_CHARSET; <br>        lstrcpy (lf_Font.lfFaceName , " l r  S V b N"); <br>    } <br> <br> <br> <br>    switch (uMsg) <br>{ <br>/* initialize menu before drawing */ <br>case WM_INITMENU: <br>    InitMenu (hWnd); <br>    break; <br> <br>/* display status messages for menu commands */ <br>case WM_MENUSELECT: <br>    { <br>    char     *lpszMenuString; <br> <br>    lpszMenuString = LocalAlloc (LPTR, MAX_PATH); <br> <br>    if (HIWORD (wParam) ==  0xFFFF) <br>{ <br>LocalFree (lpszMenuString); <br>lpszMenuString = NULL; <br>} <br> <br>    else if (HIWORD (wParam) &amp; MF_POPUP) <br>{ <br>int i; <br>HMENU hPopupMenu = GetSubMenu ((HMENU)lParam, LOWORD (wParam)); <br> <br>lpszMenuString = LocalAlloc (LPTR, MAX_PATH); <br> <br>for (i=0; i&lt;MENUPOPUPS; i++) <br>    { <br>    if (hPopup[i] == hPopupMenu) <br>{ <br>LoadString (GetModuleHandle (NULL), <br>    i+IDM_POPUPMENUS, <br>    lpszMenuString, <br>    MAX_PATH); <br>break; <br>} <br>    } <br>} <br>    else <br>LoadString (GetModuleHandle (NULL), <br>    LOWORD (wParam), <br>    lpszMenuString, <br>    MAX_PATH); <br> <br>    /* send the status string, gray if necessary */ <br>    SendMessage (GetDlgItem (hWnd, IDC_STATUSWND), <br> WM_SETTEXT, <br> (HIWORD (wParam) &amp; MF_GRAYED) ? <br>     (LPARAM)GetSysColor (COLOR_GRAYTEXT): <br>     0, <br> (WPARAM)lpszMenuString); <br> <br>    LocalFree (lpszMenuString); <br>    } <br>    break; <br> <br>case WM_CREATE: <br>    { <br>    HCURSOR  hOldCursor; <br>    HDC   hDC; <br>    TEXTMETRIC  tm; <br>    char  szWndClass[MAX_PATH]; <br>    HWND  hList, hStatus; <br>    int   i=0, j, k; <br>    HMENU  hMenu; <br> <br>    /* build array of popup menu handles */ <br>    hMenu = GetMenu (hWnd); <br>    for (k=0; k&lt;MENUPOPUPS-(i-1); k++) <br>{ <br>hPopup[i] = GetSubMenu (hMenu, k); <br>j=0; <br>while ((hPopup[i+j+1] = GetSubMenu (hPopup[i], j)) != NULL) <br>    j++; <br>if (j) <br>    i+=j; <br>i++; <br>} <br> <br>    /* put hourglass cursor up */ <br>    hOldCursor = (HCURSOR)SetClassLong (hWnd, GCL_HCURSOR, 0); <br>    SetCursor (LoadCursor (0, IDC_WAIT)); <br> <br>    hDC = GetDC(hWnd); <br> <br>    /* want a font with point size of 10 (smallest size it comes in) */ <br>    lf_Font.lfHeight = -(10 * GetDeviceCaps(hDC, LOGPIXELSY)/72); <br>    hFont = CreateFontIndirect(&amp;lf_Font); <br>    hFontVar = CreateFontIndirect(&amp;lf_FontVar); <br> <br> <br>            // find the width of a '0' in the variable font <br>            // <br>            SelectObject(hDC, hFontVar); <br>            GetTextExtentPoint (hDC, "0", 1, &amp;sChar0); <br> <br>            SelectObject(hDC, hFont); <br> <br>    /* initialize system constants */ <br>    GetTextMetrics(hDC, &amp;tm); <br>    yChar = tm.tmHeight; <br>    xChar = tm.tmAveCharWidth; <br>    xScreen = GetSystemMetrics(SM_CXSCREEN); <br>    yScreen = GetSystemMetrics(SM_CYSCREEN); <br>    yFrame = GetSystemMetrics(SM_CYFRAME); <br>    xFrame = GetSystemMetrics(SM_CXFRAME); <br>    yCaption = GetSystemMetrics(SM_CYCAPTION); <br>    xVScrollBar = GetSystemMetrics(SM_CXVSCROLL); <br> <br>    //Actually, it's not good that a width of each column <br>    // depends on a width of "0"!! <br>    if (xChar &gt; sChar0.cx) { <br>//sChar0.cx = xChar; <br>sChar0.cx = sChar0.cx * 12 / 10;//sChar0.cx *= 1.2 <br>    } <br> <br>            SelectObject(hDC, GetStockObject(SYSTEM_FONT)); <br>            ReleaseDC(hWnd, hDC); <br> <br>    /* create listbox for client area */ <br>    LoadString (GetModuleHandle (NULL), <br>IDS_LISTBOX, <br>szWndClass, <br>sizeof (szWndClass)); <br>    hList = CreateWindow (szWndClass, <br>  NULL, <br>  WS_CHILD | WS_VISIBLE | WS_VSCROLL | <br>  LBS_EXTENDEDSEL | LBS_NOTIFY | LBS_OWNERDRAWFIXED | <br>  LBS_WANTKEYBOARDINPUT | LBS_NOINTEGRALHEIGHT, <br>  0, 0, 0, 0, <br>  hWnd, <br>  (HMENU)IDC_LISTBOX, <br>  GetModuleHandle (NULL), <br>  NULL); <br> <br>    /* if listbox failed, abort app */ <br>    if (!IsWindow (hList)) <br>DestroyWindow(hWnd); <br>    SendMessage (hList, WM_SETFONT, (WPARAM)hFontVar, 0L); <br> <br>    /* create status window for client area */ <br>    LoadString (GetModuleHandle (NULL), <br>IDS_STATUSCLASS, <br>szWndClass, <br>sizeof (szWndClass)); <br>    if (!(hStatus = CreateWindow (szWndClass, <br>  NULL, <br>  WS_CHILD | WS_VISIBLE | WS_BORDER, <br>  0, 0, 0, 0, <br>  hWnd, <br>  (HMENU)IDC_STATUSWND, <br>  GetModuleHandle (NULL), <br>  NULL))) <br>ReportError (IDS_ERRCREATEWINDOW); <br> <br>    /* initialize status window */ <br>    SendMessage (GetDlgItem (hWnd, IDC_STATUSWND), <br> UM_UPDATE, <br> (WPARAM)lpChildProcess, <br> 0); <br> <br>    /* if child process post message to display initialization dialog */ <br>    if (lpChildProcess != NULL) <br>PostMessage (hWnd, UM_STARTINITDIALOG, 0, 0); <br> <br>    /* remove hourglass cursor */ <br>    SetClassLong (hWnd, GCL_HCURSOR, (LONG)hOldCursor); <br>    SetCursor (hOldCursor); <br>    } <br>    break; <br> <br>case UM_STARTINITDIALOG: <br>    /* start modal initializing information window */ <br>    DialogBoxParam (GetModuleHandle (NULL), <br>    (char *)IDD_INITIALIZING, <br>    hWnd, <br>    InitDlgProc, <br>    (LPARAM)&amp;hInitDlg); <br>    hInitDlg = NULL; <br>    break; <br> <br>case WM_SETFOCUS: <br>    /* keep focus in listbox when possible */ <br>    SetFocus (GetDlgItem (hWnd, IDC_LISTBOX)); <br>    break; <br> <br>case WM_MEASUREITEM: <br>            ((MEASUREITEMSTRUCT FAR *)lParam)-&gt;itemHeight = sChar0.cy; <br>            break; <br> <br>case WM_DRAWITEM: <br>    DrawListItem ((DRAWITEMSTRUCT FAR *)lParam); <br>            break; <br> <br>case WM_PAINT: <br>    { <br>    PAINTSTRUCT ps; <br>    RECT rc; <br> <br>    /* draw the caption line above the list box */ <br>    BeginPaint(hWnd, &amp;ps); <br>    SetRect(&amp;rc, 0, 0, GetSystemMetrics (SM_CXSCREEN), sChar0.cy); <br> <br>    SelectObject(ps.hdc, hFontVar); <br>    SetTextColor(ps.hdc, GetSysColor(COLOR_CAPTIONTEXT)); <br>    SetBkColor(ps.hdc, GetSysColor(COLOR_ACTIVECAPTION)); <br>            TextOutFields (ps.hdc, 6, &amp;rc, szCaptionText); <br>    SelectObject(ps.hdc, GetStockObject(SYSTEM_FONT)); <br>    EndPaint(hWnd, &amp;ps); <br>    } <br>    break; <br> <br>case WM_SIZE: <br>    /* size listbox and status bar */ <br>    if ((wParam == SIZE_RESTORED) || (wParam == SIZE_MAXIMIZED)) <br>{ <br>int    yBorder = GetSystemMetrics (SM_CYBORDER); <br>int    xBorder = GetSystemMetrics (SM_CXBORDER); <br>int    yStatus = yChar + 10*yBorder; <br> <br>/* size listbox */ <br>MoveWindow(GetDlgItem (hWnd, IDC_LISTBOX), <br>   0, <br>   sChar0.cy, <br>   LOWORD(lParam), <br>   HIWORD(lParam)-(sChar0.cy + yStatus - yBorder), <br>   TRUE); <br> <br>/* size status bar */ <br>MoveWindow(GetDlgItem (hWnd, IDC_STATUSWND), <br>   0-xBorder, <br>   HIWORD(lParam)-yStatus+yBorder, <br>   LOWORD(lParam) + 2*xBorder, <br>   yStatus, <br>   TRUE); <br>} <br>    break; <br> <br>case WM_COMMAND: <br>    { <br>    switch (LOWORD (wParam)) <br>{ <br>case IDM_EXIT: <br>    SendMessage (hWnd, WM_CLOSE, 0, 0); <br>    break; <br> <br>case IDM_PROCESSUNLOAD: <br>    { <br>    char    szFilename[MAX_PATH]; <br>    char    szTitle[MAX_PATH]; <br>    HWND    hViewWnd = NULL; <br> <br>    /* close child process */ <br>    CloseChildProcess (lpChildProcess, hChildEvents); <br>    lpChildProcess = NULL; <br>    SendMessage (GetDlgItem (hWnd, IDC_LISTBOX), LB_RESETCONTENT, 0, 0); <br>    SendMessage (GetDlgItem (hWnd, IDC_STATUSWND), <br> UM_UPDATE, <br> 0, <br> 0); <br> <br>    /* reset caption */ <br>    LoadString (GetModuleHandle (NULL), <br>IDS_CAPTION, <br>szTitle, <br>MAX_PATH); <br>    LoadString (GetModuleHandle (NULL), <br>IDS_SELF, <br>szFilename, <br>MAX_PATH); <br>    strcat (szTitle, szFilename); <br>    SetWindowText (hWnd, szTitle); <br> <br>    if (IsWindow (hWndSysStat)) <br>{ <br>InvalidateRect (hWndSysStat, NULL, TRUE); <br>UpdateWindow (hWndSysStat); <br>} <br> <br>    if (IsWindow (hWndProStat)) <br>DestroyWindow (hWndProStat); <br> <br>    while ((hViewWnd = EnumViewWindows (hWnd, hViewWnd)) != NULL) <br>DestroyWindow (hViewWnd); <br>    } <br>    break; <br> <br>case IDM_PROCESSLOAD: <br>    { <br>    char      szTitle[MAX_PATH]; <br>    char      szFilePath[MAX_PATH]; <br>    HWND      hViewWnd = NULL; <br> <br>    /* detaching from old process, okay?? */ <br>    if (lpChildProcess != NULL) <br>{ <br>strcpy (szTitle, "Detach from process "); <br>strcat (szTitle, lpChildProcess-&gt;szModule); <br>strcat (szTitle, "?"); <br> <br>LoadString (GetModuleHandle (NULL), <br>    IDS_WALKERCLASS, <br>    szFilePath, <br>    MAX_PATH); <br>if (IDYES != MessageBox (hWnd, <br> szTitle, <br> szFilePath, <br> MB_YESNO | MB_ICONQUESTION)) <br>    break; <br>} <br> <br>    /* call open file dialog to get filename of exe, and validate */ <br>    *szFilePath = 0; <br>    if (GetFileName (hWnd, szFilePath, NULL)) <br>{ <br>if (IsValidFile (szFilePath)) <br>    { <br>    if (lpChildProcess != NULL) <br>{ <br>/* close any open view windowsfor this process */ <br>while ((hViewWnd = EnumViewWindows (hWnd, hViewWnd)) != NULL) <br>    DestroyWindow (hViewWnd); <br> <br>CloseChildProcess (lpChildProcess, hChildEvents); <br>SendMessage (GetDlgItem (hWnd, IDC_LISTBOX), <br>     LB_RESETCONTENT, <br>     0, <br>     0); <br>SendMessage (GetDlgItem (hWnd, IDC_STATUSWND), <br>     UM_UPDATE, <br>     0, <br>     0); <br>} <br> <br>    if ((lpChildProcess = <br> StartChildProcess (hWnd, szFilePath, hChildEvents)) != NULL) <br>{ <br>/* force rewalk of process */ <br>PostMessage (hWnd, UM_STARTINITDIALOG, 0, 0); <br>SendMessage (GetDlgItem (hWnd, IDC_STATUSWND), <br>     UM_UPDATE, <br>     (WPARAM)lpChildProcess, <br>     0); <br> <br>/* load new window caption */ <br>LoadString (GetModuleHandle (NULL), <br>    IDS_CAPTION, <br>    szTitle, <br>    MAX_PATH); <br> <br>GetFileFromPath (szFilePath, szFilename); <br>strcat (szTitle, szFilename); <br>SetWindowText (hWnd, szTitle); <br>} <br>    } <br>} <br>    } <br>    break; <br> <br>case IDM_PROCESSREWALK: <br>    { <br>    HWND      hList = GetDlgItem (hWnd, IDC_LISTBOX); <br>    int       nCnt, nNewCnt, i; <br>    LPVOID    lpNewList=NULL, lpTempList=NULL; <br>    HWND      hViewWnd = NULL; <br> <br> <br>    /* clear listbox of current contents, but first find out how many exist */ <br>    nCnt = SendMessage (hList, LB_GETCOUNT, 0, 0); <br>    SendMessage (hList, WM_SETREDRAW, 0, 0); <br>    SendMessage (hList, LB_RESETCONTENT, 0, 0); <br> <br>    /* walk process address space */ <br>    if (lpChildProcess != NULL) <br>{ <br>nNewCnt = WalkProcess (lpChildProcess-&gt;hProcess, &amp;lpNewList, &amp;Objects); <br>AnalyzeProcess (lpChildProcess, (LPVMOBJECT)lpNewList, nNewCnt); <br> <br>/* indentify which objects are new */ <br>if (nCnt) <br>    IdentifyNewObjects (lpWalkerList, nCnt, lpNewList, nNewCnt); <br> <br>/* free old list and update cnt */ <br>lpTempList = lpWalkerList; <br>lpWalkerList = lpNewList; <br>VirtualFree (lpTempList, TOTALVMRESERVE, MEM_DECOMMIT); <br>VirtualFree (lpTempList, 0, MEM_RELEASE); <br>nCnt = nNewCnt; <br>} <br> <br>    for (i=0; i&lt;nCnt; i++) <br>SendMessage (hList, LB_ADDSTRING, 0, i); <br> <br>    /* sort if other than by address is selected */ <br>    if (nSortType != IDM_SORTADDRESS) <br>SortList (hList, nSortType); <br> <br>    /* reenable redraw of listbox */ <br>    SendMessage (hList, WM_SETREDRAW, 1, 0); <br>    InvalidateRect (hList, NULL, TRUE); <br>    UpdateWindow (hList); <br> <br>    /* if any memory view windows, send update message */ <br>    while ((hViewWnd = EnumViewWindows (hWnd, hViewWnd)) != NULL) <br>{ <br>LPMEMVIEW    pmv, pmvOld; <br>int    nAddress, nSize; <br>MEMORY_BASIC_INFORMATION    mbi; <br>char    *szCaption; <br> <br>/* retrieve view memory range */ <br>szCaption = HeapAlloc (GetProcessHeap (), HEAP_ZERO_MEMORY, MAX_PATH); <br>GetWindowText (hViewWnd, szCaption, MAX_PATH); <br> <br>/* validate range */ <br>sscanf (strtok (szCaption, "-"), "%8x", &amp;nAddress); <br>sscanf (strtok (NULL, " \0"), "%8x", &amp;nSize); <br>nSize -= nAddress; <br>VirtualQueryEx (lpChildProcess-&gt;hProcess, <br>(LPVOID)nAddress, <br>&amp;mbi, <br>sizeof (MEMORY_BASIC_INFORMATION)); <br> <br>if (mbi.State != MEM_COMMIT) <br>    { <br>    NotifyUser (hWnd, IDS_ERROR, IDS_NOTCOMMITTEDMEMORY, NULL, 0); <br>    DestroyWindow (hViewWnd); <br>    goto NOT; <br>    } <br> <br>/* if size of committed region changed, update caption */ <br>if (mbi.RegionSize != (DWORD)nSize) <br>    { <br>    wsprintf (szCaption, <br>      "%4lx-%-4lx", <br>      (DWORD)mbi.BaseAddress, <br>      (DWORD)mbi.BaseAddress+mbi.RegionSize); <br>    SetWindowText (hViewWnd, szCaption); <br>    } <br> <br>/* free default heap memory */ <br>HeapFree (GetProcessHeap (), 0, szCaption); <br> <br>/* if an old view structure existed, release virtual memory */ <br>if ((pmvOld = (LPMEMVIEW)GetWindowLong (hViewWnd, WXB_LPOLDMEMVIEW)) != NULL) <br>    VirtualFree (pmvOld-&gt;lpMem, 0, MEM_RELEASE); <br> <br>pmvOld = (LPMEMVIEW)GetWindowLong (hViewWnd, WXB_LPMEMVIEW); <br>/* save past pmv for update comparison */ <br>SetWindowLong (hViewWnd, <br>       WXB_LPOLDMEMVIEW, <br>       (LONG)pmvOld); <br> <br>/* allocate memory structure for view memory object */ <br>pmv = (LPMEMVIEW)LocalAlloc (LPTR, sizeof (MEMVIEW)); <br> <br>/* copy old mem view to new mem view */ <br>for (i=0; i&lt;sizeof (MEMVIEW); i++) <br>    ((LPBYTE)pmv)[i] = ((LPBYTE)pmvOld)[i]; <br> <br>/* update structure for new mem structure */ <br>pmv-&gt;nBase = (int)mbi.BaseAddress; <br>pmv-&gt;nSize = (int)mbi.RegionSize; <br> <br>if ((pmv-&gt;lpMem = VirtualAlloc (NULL, pmv-&gt;nSize, MEM_COMMIT, PAGE_READWRITE)) == NULL) <br>    { <br>    ReportError (IDS_ERRVIRTUALALLOC); <br>    DestroyWindow (hViewWnd); <br>    } <br> <br>else if (AccessProcessMemory (hChildEvents[READMEMORY], <br>      hChildEvents[ACKNOWLEDGE], <br>      (LPVOID)nAddress, <br>      pmv-&gt;lpMem, <br>      &amp;(pmv-&gt;nSize))  &amp;&amp; pmv-&gt;nSize) <br>    { <br>    pmv-&gt;nLines = (pmv-&gt;nSize+15)/16; <br>    pmv-&gt;nExtraBytes = (pmv-&gt;nSize &amp; 0x0000000F); <br>    SetWindowLong (hViewWnd, WXB_LPMEMVIEW, (LONG)pmv); <br> <br>    /* post message to view window to update */ <br>    PostMessage (hViewWnd, UM_UPDATE, 0, 0); <br>    } <br> <br>else <br>    { <br>    NotifyUser (hWnd, IDS_ERROR, IDS_COULDNOTREADPROCESS, NULL, 0); <br>    DestroyWindow (hViewWnd); <br>    } <br> <br>} <br> <br>NOT: <br>    /* if initialization dialog, send notification to remove */ <br>    if (IsWindow (hInitDlg)) <br>PostMessage (hInitDlg, UM_ENDDIALOG, 0, 0); <br>    } <br>    break; <br> <br>case IDM_PROCESSSUSPEND: <br>    SetEvent (hChildEvents[SUSPENDDEBUGGER]); <br>    break; <br> <br>case IDM_PROCESSRESUME: <br>    SetEvent (hChildEvents[RESUMEDEBUGGER]); <br>    break; <br> <br>case IDM_VIEWSYSSTAT: <br>    /* if window exists, destroy it */ <br>    if (IsWindow (hWndSysStat)) <br>{ <br>DestroyWindow (hWndSysStat); <br>CheckMenuItem (GetMenu (hWnd), wParam, MF_UNCHECKED); <br>} <br>    else <br>{ <br>charszClass[100]; <br>charszTitle[100]; <br>RECTrc; <br> <br>GetWindowRect (hWnd, &amp;rc); <br>LoadString (GetModuleHandle (NULL), IDS_SYSSTATCLASS, szClass, 100); <br>LoadString (GetModuleHandle (NULL), IDS_SYSSTATTITLE, szTitle, 100); <br>hWndSysStat = CreateWindow (szClass, <br>    szTitle, <br>    WS_POPUP | WS_CAPTION | WS_MINIMIZEBOX | <br>    WS_SYSMENU | WS_DLGFRAME | WS_VISIBLE, <br>    rc.left+50, rc.top+50, 500, 270, <br>    hWnd, <br>    NULL, <br>    GetModuleHandle (NULL), <br>    NULL); <br>UpdateWindow (hWndSysStat); <br>ShowWindow (hWndSysStat, SW_SHOWNORMAL); <br>CheckMenuItem (GetMenu (hWnd), wParam, MF_CHECKED); <br>} <br>    break; <br> <br>case IDM_VIEWPROSTAT: <br>    /* if window exists, destroy it */ <br>    if (IsWindow (hWndProStat)) <br>{ <br>DestroyWindow (hWndProStat); <br>CheckMenuItem (GetMenu (hWnd), wParam, MF_UNCHECKED); <br>} <br>    else <br>{ <br>charszClass[100]; <br>charszTitle[100]; <br>RECTrc; <br> <br>GetWindowRect (hWnd, &amp;rc); <br>LoadString (GetModuleHandle (NULL), IDS_PROSTATCLASS, szClass, 100); <br>LoadString (GetModuleHandle (NULL), IDS_PROSTATTITLE, szTitle, 100); <br>hWndProStat = CreateWindow (szClass, <br>    szTitle, <br>    WS_POPUP | WS_CAPTION | WS_MINIMIZEBOX | <br>    WS_SYSMENU | WS_DLGFRAME | WS_VISIBLE, <br>    rc.left+75, rc.top+75, 355, 120, <br>    hWnd, <br>    NULL, <br>    GetModuleHandle (NULL), <br>    NULL); <br>UpdateWindow (hWndProStat); <br>ShowWindow (hWndProStat, SW_SHOWNORMAL); <br>CheckMenuItem (GetMenu (hWnd), wParam, MF_CHECKED); <br>} <br>    break; <br> <br>/* accept bouble click messages from listbox only */ <br>case IDC_LISTBOX: <br>    if (HIWORD (wParam) != LBN_DBLCLK) <br>break; <br> <br>case IDM_VIEWMEMORY: <br>    if (ViewableMemorySelection (hWnd)) <br>{ <br>char  szBuff[50]; <br>HWND  hList = GetDlgItem (hWnd, IDC_LISTBOX); <br>int  iCaret = SendMessage (hList, LB_GETCARETINDEX, 0, 0); <br>DWORD  nAddress = <br>  (DWORD)((LPVMOBJECT)lpWalkerList)[Objects[iCaret]].mbi.BaseAddress; <br>int  nSize = ((LPVMOBJECT)lpWalkerList)[Objects[iCaret]].mbi.RegionSize; <br>LPVOID  lpMem; <br>HCURSOR   hOldCursor; <br> <br>if ((lpMem = VirtualAlloc (NULL, nSize, MEM_COMMIT, PAGE_READWRITE)) == NULL) <br>    { <br>    ReportError (IDS_ERRVIRTUALALLOC); <br>    break; <br>    } <br> <br>/* put wait cursor up */ <br>hOldCursor = (HCURSOR)SetClassLong (hWnd, GCL_HCURSOR, 0); <br>SetCursor (LoadCursor (0, IDC_WAIT)); <br> <br>/* signal debugger thread to read process memory */ <br>if (AccessProcessMemory (hChildEvents[READMEMORY], <br> hChildEvents[ACKNOWLEDGE], <br> (LPVOID)nAddress, <br> lpMem, <br> &amp;nSize)  &amp;&amp; nSize) <br>    { <br>    wsprintf (szBuff, "%4lx-%-4lx", nAddress, nAddress+nSize); <br>    ViewMemory (hWnd, szBuff, lpMem, nSize, nAddress); <br> <br>    /* if first view window, add separator */ <br>    if (GetMenuItemCount (GetSubMenu (GetMenu (hWnd), 2)) == 5) <br>AppendMenu (GetSubMenu (GetMenu (hWnd), 2), <br>    MF_SEPARATOR, <br>    0, <br>    NULL); <br> <br>    AppendMenu (GetSubMenu (GetMenu (hWnd), 2), <br>MF_STRING | MF_CHECKED, <br>AddAtom (szBuff), <br>szBuff); <br>    } <br> <br>else <br>    NotifyUser (hWnd, IDS_ERROR, IDS_COULDNOTREADPROCESS, NULL, 0); <br> <br> <br>/* replace wait cursor with old cursor */ <br>SetClassLong (hWnd, GCL_HCURSOR, (LONG)hOldCursor); <br>SetCursor (hOldCursor); <br>} <br>    else <br>{ <br>NotifyUser (hWnd, IDS_ERROR, IDS_NOTCOMMITTEDMEMORY, NULL, 0); <br>break; <br>} <br>    break; <br> <br>case IDM_VIEWADDRESS: <br>    { <br>    int nAddress; <br>    MEMORY_BASIC_INFORMATIONmbi; <br>    LPVOIDlpMem; <br>    charszBuff[MAX_PATH]; <br>    int nLine; <br>    HWNDhViewWnd; <br> <br> <br>    if (nAddress = DialogBox (GetModuleHandle (NULL), (char *)IDD_ADDR, hWnd, AddrDlgProc)) <br>{ <br>VirtualQueryEx (lpChildProcess-&gt;hProcess, <br>(LPVOID)nAddress, <br>&amp;mbi, <br>sizeof (MEMORY_BASIC_INFORMATION)); <br> <br>if (mbi.State != MEM_COMMIT) </code></pre>
<p>
</p>
<pre><code>{ <br>    NotifyUser (hWnd, IDS_ERROR, IDS_NOTCOMMITTEDMEMORY, NULL, 0); <br>    break; <br>    } <br> <br>if ((lpMem = VirtualAlloc (NULL, mbi.RegionSize, MEM_COMMIT, PAGE_READWRITE)) == NULL) <br>    { <br>    ReportError (IDS_ERRVIRTUALALLOC); <br>    break; <br>    } <br> <br>/* signal debugger thread to read process memory */ <br>if (AccessProcessMemory (hChildEvents[READMEMORY], <br> hChildEvents[ACKNOWLEDGE], <br> (LPVOID)mbi.BaseAddress, <br> lpMem, <br> &amp;(mbi.RegionSize))  &amp;&amp; mbi.RegionSize) <br>    { <br>    wsprintf (szBuff, <br>      "%4lx-%-4lx", <br>      (int)mbi.BaseAddress, <br>      (int)mbi.BaseAddress+mbi.RegionSize); <br> <br>    hViewWnd = ViewMemory (hWnd, szBuff, lpMem, mbi.RegionSize, (int)mbi.BaseAddress); <br> <br>    /* if first view window, add separator */ <br>    if (GetMenuItemCount (GetSubMenu (GetMenu (hWnd), 2)) == 4) <br>AppendMenu (GetSubMenu (GetMenu (hWnd), 2), <br>    MF_SEPARATOR, <br>    0, <br>    NULL); <br> <br>    AppendMenu (GetSubMenu (GetMenu (hWnd), 2), <br>MF_STRING | MF_CHECKED, <br>AddAtom (szBuff), <br>szBuff); <br> <br>    /* send WM_VSCROLL message to scroll address into view */ <br>    nLine = (nAddress - (int)mbi.BaseAddress)/16 - 5; <br>    PostMessage (hViewWnd, WM_VSCROLL, MAKELONG (SB_THUMBPOSITION, nLine), 0); <br>    } <br> <br>else <br>    NotifyUser (hWnd, IDS_ERROR, IDS_COULDNOTREADPROCESS, NULL, 0); <br>} <br>    } <br>    break; <br> <br>case IDM_REMOVEVIEWWND: <br>    { <br>    ATOM    aCaption = FindAtom ((char *)lParam); <br>    HMENU   hMenu = GetMenu (hWnd); <br>    HMENU   hViewMenu = GetSubMenu (hMenu, 2); <br> <br>    RemoveMenu (hMenu, (UINT)aCaption, MF_BYCOMMAND); <br>    DeleteAtom (aCaption); <br> <br>    /* there are 4 menuitems in the view menu without view windows open */ <br>    if (GetMenuItemCount (hViewMenu) == 6) <br>RemoveMenu (hViewMenu, 5, MF_BYPOSITION); <br>    } <br>    break; <br> <br>case IDM_SORTADDRESS: <br>case IDM_SORTSTATE: <br>case IDM_SORTPROTECTION: <br>case IDM_SORTSIZE: <br>case IDM_SORTBASEADDRESS: <br>    { <br>    HWND    hList = GetDlgItem (hWnd, IDC_LISTBOX); <br>    HCURSOR hOldCursor; <br> <br>    if (nSortType != (int)LOWORD (wParam)) <br>{ <br>/* put wait cursor up */ <br>hOldCursor = (HCURSOR)SetClassLong (hWnd, GCL_HCURSOR, 0); <br>SetCursor (LoadCursor (0, IDC_WAIT)); <br> <br>/* reset menuitems to indicate which sort method is being used */ <br>CheckMenuItem (GetMenu (hWnd), nSortType, MF_UNCHECKED); <br>CheckMenuItem (GetMenu (hWnd), wParam, MF_CHECKED); <br> <br>/* save new sort type and resort */ <br>SortList (hList, nSortType = wParam); <br> <br>/* repaint after sorting */ <br>InvalidateRect (hList, NULL, TRUE); <br>UpdateWindow (hList); <br> <br>/* replace wait cursor with old cursor */ <br>SetClassLong (hWnd, GCL_HCURSOR, (LONG)hOldCursor); <br>SetCursor (hOldCursor); <br> } <br>    } <br>    break; <br> <br>                case IDM_OPTBYTES: <br>                case IDM_OPTPAGES: <br>                    { <br>                    HWND hList = GetDlgItem (hWnd, IDC_LISTBOX); <br>                    bNumbersAsBytes = (LOWORD(wParam) == IDM_OPTBYTES); <br>                    InvalidateRect (hList, NULL, TRUE); <br>                    } <br>                    break; <br> <br>default: <br>    /* if popup window, bring to front */ <br>    ActivateViewWindow (LOWORD (wParam)); <br>    lRet = TRUE; <br>    break; <br>} <br>    } <br>    break; <br> <br>case WM_CLOSE: <br>case WM_QUERYENDSESSION: <br>    /* if child process is active, close it first then exit */ <br>    if (lpChildProcess != NULL) <br>CloseChildProcess (lpChildProcess, hChildEvents); <br> <br>    /* destroy this window */ <br>    DestroyWindow (hWnd); <br>    break; <br> <br>case WM_DESTROY: <br>    PostQuitMessage (0); <br>    break; <br> <br>default: <br>    /* pass all unhandled messages to DefWindowProc */ <br>    lRet = DefWindowProc (hWnd, uMsg, wParam, lParam); <br>    break; <br>} <br> <br>    /* return 1 if handled message, 0 if not */ <br>    return lRet; <br>} <br> <br> <br> <br>/* initialize all menuitems */ <br>void WINAPI InitMenu ( <br>    HWND    hWnd) <br>{ <br>    HMENUhMenu = GetMenu (hWnd); <br> <br>    /* if child process exists enable options */ <br>    EnableMenuItem (hMenu, <br>    IDM_PROCESSREWALK, <br>    MF_BYCOMMAND | ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br>    EnableMenuItem (hMenu, <br>    IDM_PROCESSUNLOAD, <br>    MF_BYCOMMAND | ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br> <br>    /* check appropriate sort menuitem */ <br>    CheckMenuItem (hMenu, nSortType, MF_CHECKED); <br> <br>    /* check view as bytes/pages menuitems */ <br>    CheckMenuItem (hMenu, IDM_OPTBYTES, bNumbersAsBytes ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem (hMenu, IDM_OPTPAGES, bNumbersAsBytes ? MF_UNCHECKED : MF_CHECKED); <br> <br>    /* enable process and selection stat windows only when child process exists */ <br>    EnableMenuItem (hMenu, <br>    IDM_VIEWPROSTAT, <br>    MF_BYCOMMAND | ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br>    EnableMenuItem (hMenu, <br>    IDM_VIEWSYSSTAT, <br>    MF_BYCOMMAND | ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br> <br>    /* check all appropriate view menuitem */ <br>    CheckMenuItem (hMenu, <br>   IDM_VIEWSYSSTAT, <br>   IsWindow (hWndSysStat) ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem (hMenu, <br>   IDM_VIEWPROSTAT, <br>   IsWindow (hWndProStat) ? MF_CHECKED : MF_UNCHECKED); <br> <br>    /* if child process exists */ <br>    if (lpChildProcess != NULL) <br>{ <br>/* child process is active */ <br>if (lpChildProcess-&gt;bActive) <br>    { <br>    EnableMenuItem (hMenu, IDM_PROCESSRESUME, MF_GRAYED); <br>    EnableMenuItem (hMenu, IDM_PROCESSSUSPEND, MF_ENABLED); <br>    } <br> <br>else <br>    { <br>    EnableMenuItem (hMenu, IDM_PROCESSSUSPEND, MF_GRAYED); <br>    EnableMenuItem (hMenu, IDM_PROCESSRESUME, MF_ENABLED); <br>    } <br>} <br> <br>    /* diasble both menuitems */ <br>    else <br>{ <br>EnableMenuItem (hMenu, IDM_PROCESSSUSPEND, MF_GRAYED); <br>EnableMenuItem (hMenu, IDM_PROCESSRESUME, MF_GRAYED); <br>} <br> <br>    /* sort only when process exists */ <br>    EnableMenuItem (hMenu, <br>    IDM_SORTADDRESS, <br>    ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br>    EnableMenuItem (hMenu, <br>    IDM_SORTSTATE, <br>    ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br>    EnableMenuItem (hMenu, <br>    IDM_SORTPROTECTION, <br>    ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br>    EnableMenuItem (hMenu, <br>    IDM_SORTSIZE, <br>    ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br>    EnableMenuItem (hMenu, <br>    IDM_SORTBASEADDRESS, <br>    ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br> <br>    /* if child process &amp; selection, and selection is committed memory */ <br>    if (lpChildProcess != NULL &amp;&amp; <br>ViewableMemorySelection (hWnd)) <br>EnableMenuItem (hMenu, IDM_VIEWMEMORY, MF_ENABLED); <br>    else <br>EnableMenuItem (hMenu, IDM_VIEWMEMORY, MF_GRAYED); <br> <br>/* View address if child process */ <br>EnableMenuItem (hMenu, <br>IDM_VIEWADDRESS, <br>    ((lpChildProcess != NULL) ? MF_ENABLED : MF_GRAYED)); <br> <br> <br>} <br> <br> <br> <br> <br>int WINAPI MakeVMQString ( <br>    int   nItem, <br>    char  *lpszMem) <br>{ <br>    char  szState[10], szProtection[3]; <br>    LPVMOBJECT  lpVMObject; <br>    int           nLen; <br>    int           nBaseAddr; <br>    int           nRegionSize; <br>    int           nAllocBase; <br>    LPSTR         lpszFormat; <br> <br>    /* lookup object offset in array index */ <br>    lpVMObject = ((VMOBJECT *)lpWalkerList)+Objects[nItem]; <br> <br> <br>    /* determine state of memory object */ <br>    if (lpVMObject-&gt;mbi.State &amp; MEM_COMMIT) <br>strcpy (szState, "Commit "); <br>    else if (lpVMObject-&gt;mbi.State &amp; MEM_RESERVE) <br>strcpy (szState, "Reserve"); <br>    else <br>strcpy (szState, "Free   "); <br> <br>    /* determine protection of memory */ <br>    if (lpVMObject-&gt;mbi.Protect &amp; PAGE_READWRITE) <br>strcpy (szProtection, "RW"); <br>    else if (lpVMObject-&gt;mbi.Protect &amp; PAGE_READONLY) <br>strcpy (szProtection, "RO"); <br>    else <br>strcpy (szProtection, "NA"); <br> <br>    lpszFormat = szFormat; <br>    nBaseAddr = (int)(lpVMObject-&gt;mbi.BaseAddress); <br>    nRegionSize = lpVMObject-&gt;mbi.RegionSize; <br>    nAllocBase = (int)(lpVMObject-&gt;mbi.AllocationBase); <br> <br>    if (!bNumbersAsBytes) <br>       { <br>       nBaseAddr /= PAGESIZE; <br>       nRegionSize /= PAGESIZE; <br>       nAllocBase /= PAGESIZE; <br>       lpszFormat = szFormatPages; <br>       } <br> <br>    /* create list object */ <br>    wsprintf(lpszMem, <br>     lpszFormat, <br>     nBaseAddr, <br>     szState, <br>     szProtection, <br>     nRegionSize, <br>     nAllocBase, <br>     lpVMObject-&gt;szObjType, <br>     lpVMObject-&gt;szSection, <br>            lpVMObject-&gt;szModule); <br> <br>    /* return length of resulting string */ <br>    nLen = strlen (lpszMem); <br> <br>    // convert the ~ separators to \0 for the benefit of <br>    // TextOutFields <br>    // <br>    while (*lpszMem) <br>       { <br>       if (*lpszMem == '~') { <br>           *lpszMem = 0; <br>           // CharNext() returns the same pointer, if 'lpszMem' points '\0'. <br>           // So, we must not call CharNext() in this case. <br>           ++lpszMem; <br>       } else { <br>           lpszMem = CharNext(lpszMem); <br>       } <br>       } <br> <br>    return nLen; <br>} <br> <br> <br> <br>static void TextOutFields ( <br>   HDC    hDC, <br>   int    x, <br>   LPRECT lprc, <br>   LPSTR  lpszItems) <br>   { <br>   int eto = ETO_CLIPPED | ETO_OPAQUE; <br>   int ii = 0; <br>   PSTR psz = lpszItems; <br>   int nLen; <br> <br>   // copy fields until we get one of zero size. <br>   // <br>   do { <br>      SetTextAlign (hDC, taColumns[ii]); <br> <br>      ExtTextOut(hDC, <br>                 lprc-&gt;left + (xColumns[ii] * sChar0.cx) + x, <br>                 lprc-&gt;top, <br>                 eto, <br>                 lprc, <br>                 psz, <br>                 nLen = strlen(psz), <br>                 0L); <br> <br>      psz += (nLen + 1); <br>      eto = ETO_CLIPPED; <br>      ++ii; <br>      } while (nLen); <br>   } <br> <br> <br> <br>void WINAPI DrawListItem( <br>    DRAWITEMSTRUCT *lpItem) <br>{ <br>    DWORD dwBkColor=0xffffffff, dwTextColor=0xffffffff; <br>    char  szListItem[200]; <br>    int   nLen; <br> <br>    /* Make sure it is the list box with a valid item ID */ <br>    if (lpItem-&gt;CtlType != ODT_LISTBOX || <br>lpItem-&gt;CtlID != IDC_LISTBOX) <br>        return; <br> <br>    if (lpItem-&gt;itemAction &amp; (ODA_DRAWENTIRE | ODA_SELECT)) <br>{ <br>        /* Alter the bk and text color for selected items */ <br>if (lpItem-&gt;itemState &amp; ODS_SELECTED) <br>    { <br>    dwBkColor = SetBkColor (lpItem-&gt;hDC, GetSysColor(COLOR_HIGHLIGHT)); <br>    dwTextColor = SetTextColor (lpItem-&gt;hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>    } <br> <br>/* change TextColor for new entries too */ <br>else if ((((LPVMOBJECT)lpWalkerList)+Objects[lpItem-&gt;itemData])-&gt;bNew) <br>    { <br>    dwBkColor = SetBkColor (lpItem-&gt;hDC, GetSysColor(COLOR_HIGHLIGHT)); <br>    dwTextColor = SetTextColor (lpItem-&gt;hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>    } <br> <br>/* make listbox string from virtual memory object */ <br>nLen = MakeVMQString (lpItem-&gt;itemData, szListItem); <br>        TextOutFields (lpItem-&gt;hDC, 6, &amp;lpItem-&gt;rcItem, szListItem); <br> <br>/* Restore previous bk and text color if necessary */ <br>if (dwBkColor != 0xffffffff) <br>            SetBkColor(lpItem-&gt;hDC, dwBkColor); <br>if (dwTextColor != 0xffffffff) <br>    SetTextColor(lpItem-&gt;hDC, dwTextColor); <br> <br>        if (lpItem-&gt;itemState &amp; ODS_FOCUS) <br>    lpItem-&gt;itemAction |= ODA_FOCUS; <br> <br>} <br> <br>    if (lpItem-&gt;itemAction &amp; ODA_FOCUS) <br>        DrawFocusRect(lpItem-&gt;hDC, &amp;lpItem-&gt;rcItem); <br>} <br> <br> <br> <br>/* perform bubble sort on indexes to virtual memory objects as stored in <br>   ownerdraw listbox do not actually sort the objects, just the indexes  */ <br>void  WINAPI SortList ( <br>    HWND    hList, <br>    int     nSort) <br>{ <br>    int   nItems = SendMessage (hList, LB_GETCOUNT, 0, 0); <br>    int   i, j, t; <br>    LPVMOBJECT  lpVMO = (LPVMOBJECT)lpWalkerList; <br> <br>    /* loop through all items in list box */ <br>    for (i=0; i&lt;nItems-1; i++) <br>for (j=i+1; j&lt;nItems; j++) <br>    { <br>    /* compare on sort order */ <br>    switch (nSort) <br>{ <br>case IDM_SORTADDRESS: <br>    if (lpVMO[Objects[i]].mbi.BaseAddress &gt; lpVMO[Objects[j]].mbi.BaseAddress) <br>{ <br>/* swap */ <br>t = Objects[j]; <br>Objects[j] = Objects[i]; <br>Objects[i] = t; <br>} <br>    break; <br> <br>case IDM_SORTSTATE: <br>    if ((lpVMO[Objects[i]].mbi.State &gt; lpVMO[Objects[j]].mbi.State) || <br>(lpVMO[Objects[i]].mbi.State == lpVMO[Objects[j]].mbi.State &amp;&amp; <br> lpVMO[Objects[i]].mbi.BaseAddress &gt; lpVMO[Objects[j]].mbi.BaseAddress)) <br>{ <br>/* swap */ <br>t = Objects[j]; <br>Objects[j] = Objects[i]; <br>Objects[i] = t; <br>} <br>    break; <br> <br>case IDM_SORTPROTECTION: <br>    if ((lpVMO[Objects[i]].mbi.Protect &gt; lpVMO[Objects[j]].mbi.Protect) || <br>(lpVMO[Objects[i]].mbi.Protect == lpVMO[Objects[j]].mbi.Protect &amp;&amp; <br> lpVMO[Objects[i]].mbi.BaseAddress &gt; lpVMO[Objects[j]].mbi.BaseAddress)) <br>{ <br>/* swap */ <br>t = Objects[j]; <br>Objects[j] = Objects[i]; <br>Objects[i] = t; <br>} <br>    break; <br> <br>case IDM_SORTSIZE: <br>    if ((lpVMO[Objects[i]].mbi.RegionSize &gt; lpVMO[Objects[j]].mbi.RegionSize) || <br>(lpVMO[Objects[i]].mbi.RegionSize == lpVMO[Objects[j]].mbi.RegionSize &amp;&amp; <br> lpVMO[Objects[i]].mbi.BaseAddress &gt; lpVMO[Objects[j]].mbi.BaseAddress)) <br>{ <br>/* swap */ <br>t = Objects[j]; <br>Objects[j] = Objects[i]; <br>Objects[i] = t; <br>} <br>    break; <br> <br>case IDM_SORTBASEADDRESS: <br>    if ((lpVMO[Objects[i]].mbi.AllocationBase &gt; lpVMO[Objects[j]].mbi.AllocationBase) || <br>(lpVMO[Objects[i]].mbi.AllocationBase == lpVMO[Objects[j]].mbi.AllocationBase &amp;&amp; <br> lpVMO[Objects[i]].mbi.BaseAddress &gt; lpVMO[Objects[j]].mbi.BaseAddress)) <br>{ <br>/* swap */ <br>t = Objects[j]; <br>Objects[j] = Objects[i]; <br>Objects[i] = t; <br>} <br>    break; <br>} <br>    } <br>} <br> <br> <br> <br> <br>/* get free disk space on all fixed drives */ <br>BOOL   WINAPI GetFreeDiskSpace ( <br>    LPDWORD    lpdwTotalSpace, <br>    LPDWORD    lpdwFreeSpace) <br>{ <br>    DWORD    dwBytesPerSector, dwSectorsPerCluster, dwFreeClusters, dwTotalClusters; <br>    DWORD    dwDriveMask = GetLogicalDrives(); <br>    int      i; <br>    char     szDir[4]; <br> <br>    *lpdwTotalSpace = 0; <br>    *lpdwFreeSpace = 0; <br>    szDir[1] = TEXT(':'); <br>    szDir[2] = TEXT('\\'); <br>    szDir[3] = 0; <br> <br>    /* enumerate all logical, fixed drives */ <br>    for (i = 0; i &lt; MAX_DRIVES; dwDriveMask &gt;&gt;= 1, i++) <br>{ <br>/* if logical drive exists */ <br>if (dwDriveMask &amp; 0x01) <br>    { <br>    szDir[0] = TEXT('A') + i; <br> <br>    /* if it is a fixed drive */ <br>    if (GetDriveType(szDir) == DRIVE_FIXED) <br>{ <br>/* determine free space and total capacity */ <br>GetDiskFreeSpace (szDir, <br>  &amp;dwSectorsPerCluster, <br>  &amp;dwBytesPerSector, <br>  &amp;dwFreeClusters, <br>  &amp;dwTotalClusters); <br> <br>*lpdwTotalSpace += dwTotalClusters * dwSectorsPerCluster * dwBytesPerSector; <br>*lpdwFreeSpace += dwFreeClusters * dwSectorsPerCluster * dwBytesPerSector; <br>} <br>    } <br>} <br> <br>    return (*lpdwTotalSpace || *lpdwFreeSpace); <br>} <br> <br> <br> <br>/* generic message notification */ <br>int WINAPI NotifyUser ( <br>    HWND    hWndParent, <br>    int     nTitle, <br>    int     nError, <br>    char    *lpszAppend, <br>    UINT    uFlags) <br>{ <br>    char    szError[MAX_PATH]; <br>    char    szTitle[MAX_PATH]; <br> <br>    LoadString (GetModuleHandle (NULL), nTitle, szTitle, MAX_PATH); <br>    LoadString (GetModuleHandle (NULL), nError, szError, MAX_PATH); <br> <br>    if (lpszAppend != NULL &amp;&amp; *lpszAppend != 0) <br>strcat (szError, lpszAppend); <br> <br>    if (!uFlags) <br>uFlags = MB_ICONSTOP | MB_OK | MB_TASKMODAL | MB_SETFOREGROUND; <br> <br>    /* return message box response */ <br>    return (MessageBox (hWndParent, szError, szTitle, uFlags)); <br>} <br> <br> <br> <br> <br>void   WINAPI ReportError ( <br>    int     nIDS_CAPTION) <br>{ <br>    char    *lpszError; <br>    char    szText[MAX_PATH]; <br> <br>    /* get formatted error message from system */ <br>    if (!FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, <br>GetLastError (), <br>MAKELONG (MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), 0), <br>(LPTSTR)&amp;lpszError, <br>0, <br>NULL)) <br>return; <br> <br>    /* if resource string provided, load caption string */ <br>    if (nIDS_CAPTION) <br>LoadString (GetModuleHandle (NULL), nIDS_CAPTION, szText, MAX_PATH); <br>    else <br>strcpy (szText, "Error"); <br> <br>    MessageBox (NULL, <br>lpszError, <br>szText, <br>MB_ICONSTOP | MB_OK | MB_TASKMODAL | MB_SETFOREGROUND); <br>} <br> <br> <br> <br> <br> <br>BOOL WINAPI ViewableMemorySelection ( <br>    HWND    hWnd) <br>{ <br>    HWND   hList = GetDlgItem (hWnd, IDC_LISTBOX); <br>    int    iCaret = SendMessage (hList, LB_GETCARETINDEX, 0, 0); <br>    int    iAnchor = SendMessage (hList, LB_GETANCHORINDEX, 0, 0); <br> <br>    if (iCaret &gt; -1 &amp;&amp; <br>iAnchor &gt; -1 &amp;&amp; <br>SendMessage (hList, LB_GETSEL, iCaret, 0) &amp;&amp; <br>CommittedMemoryRange (iCaret, <br>      iAnchor, <br>      (LPVMOBJECT)lpWalkerList, <br>      Objects)) <br>return TRUE; <br>    else <br>return FALSE; <br>} <br> <br> <br> <br> <br>BOOL WINAPI InitDlgProc ( <br>    HWND      hDlg, <br>    UINT      uMsg, <br>    WPARAM    wParam, <br>    LPARAM    lParam) <br>{ <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>    *(HANDLE *)lParam = hDlg; <br>    break; <br> <br>case WM_CLOSE: <br>case UM_ENDDIALOG: <br>    EndDialog (hDlg, TRUE); <br>    break; <br> <br>case WM_COMMAND: <br>    if (LOWORD (wParam) == IDCANCEL || <br>LOWORD (wParam) == IDOK) <br>EndDialog (hDlg, TRUE); <br>    break; <br> <br>default: <br>    return FALSE; <br>} <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
