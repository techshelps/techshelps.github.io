<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DACLWRAP.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5576"></a>DACLWRAP.CXX</h2>
<pre><code>//+------------------------------------------------------------------- <br>// <br>// Copyright (C) 1995, Microsoft Corporation. <br>// <br>//  File:        daclwrap.cxx <br>// <br>//  Contents:    class encapsulating file security. <br>// <br>//  Classes:     CDaclWrap <br>// <br>//  History:     Nov-93        Created         DaveMont <br>// <br>//-------------------------------------------------------------------- <br>#include &lt;t2.hxx&gt; <br>#include &lt;daclwrap.hxx&gt; <br> <br>#if DBG <br>extern ULONG Debug; <br>#endif <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap::CDaclWrap, public <br>// <br>//  Synopsis:   initialize data members, constructor will not throw <br>// <br>//  Arguments:  none <br>// <br>//---------------------------------------------------------------------------- <br>CDaclWrap::CDaclWrap() <br>      : _ccaa(0) <br>{ <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     Dtor, public <br>// <br>//  Synopsis:   cleanup allocated data <br>// <br>//  Arguments:  none <br>// <br>//---------------------------------------------------------------------------- <br>CDaclWrap::~CDaclWrap() <br>{ <br>    for (ULONG j = 0; j &lt; _ccaa; j++) <br>        delete _aaa[j].pcaa; <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap::SetAccess, public <br>// <br>//  Synopsis:   caches data for a new ACE <br>// <br>//  Arguments:  IN [option] - rePlace, Revoke, Grant, Deny <br>//              IN [Name] - principal (username) <br>//              IN [System] - server/machine where Name is defined <br>//              IN [access] - access mode (Read Change None All) <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::SetAccess(ULONG option, WCHAR *Name, WCHAR *System, ULONG access) <br>{ <br>    ULONG ret; <br> <br>    // sorry, static number of ACCESSes can be set at one time <br> <br>    if (_ccaa &gt;= CMAXACES) <br>        return(ERROR_BUFFER_OVERFLOW); <br> <br>    // allocate a new account access class <br> <br>    if (NULL == (_aaa[_ccaa].pcaa = new CAccountAccess(Name, System))) <br>    { <br>        return(ERROR_NOT_ENOUGH_MEMORY); <br>    } <br> <br>    // to fix the bug where someone asks to both grant and deny under <br>    // the /p option (the deny is thru access = N) <br> <br>    if ((GENERIC_NONE == access) &amp;&amp; (OPTION_REPLACE == option)) <br>    { <br>_aaa[_ccaa].option = OPTION_DENY; <br>    } else <br>    { <br>_aaa[_ccaa].option = option; <br>    } <br> <br>    SID *psid; <br> <br>    if (ERROR_SUCCESS == ( ret = _aaa[_ccaa].pcaa-&gt;Init(access))) <br>    { <br>        // get the sid to make sure the username is valid <br> <br>        if (ERROR_SUCCESS == ( ret =_aaa[_ccaa].pcaa-&gt;Sid(&amp;psid))) <br>        { <br>            // loop thru the existing sids, making sure the new one is not a duplicate <br> <br>            SID *poldsid; <br>            for (ULONG check = 0;check &lt; _ccaa ; check++) <br>            { <br>                if (ERROR_SUCCESS == ( ret =_aaa[check].pcaa-&gt;Sid(&amp;poldsid))) <br>                { <br>                    if (EqualSid(psid,poldsid)) <br>                    { <br>                        VERBOSE((stderr, "SetAccess found matching new sids\n")) <br>                        return(ERROR_BAD_ARGUMENTS); <br>                    } <br>                } <br>            } <br>            _ccaa++; <br>        } <br>    } <br>    return(ret); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap:BuildAcl, public <br>// <br>//  Synopsis:   merges cached new aces with the input ACL <br>// <br>//  Arguments:  OUT [pnewdacl] - Address of new ACL to build <br>//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged <br>//              IN  [revision] - ACL revision <br>//              IN  [fdir]     - True = directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::BuildAcl(ACL **pnewdacl, ACL *poldacl, UCHAR revision, BOOL fdir) <br>{ <br>    ULONG ret, caclsize; <br> <br>    // get the size of the new ACL we are going to create <br> <br>    if (ERROR_SUCCESS == (ret =  _GetNewAclSize(&amp;caclsize, poldacl, fdir))) <br>    { <br>        // allocate the new ACL <br> <br>        if (ERROR_SUCCESS == (ret =  _AllocateNewAcl(pnewdacl, caclsize, revision))) <br>        { <br>            // and fill it up <br> <br>            if (ERROR_SUCCESS != (ret =  _FillNewAcl(*pnewdacl, poldacl, fdir))) <br>            { <br>                // free the buffer if we failed <br> <br>                LocalFree(*pnewdacl); <br>            } <br> <br>        } <br>    } <br>    return(ret); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap:_GetNewAclSize, private <br>// <br>//  Synopsis:   returns the size need to merge the new ACEs with the old ACL, <br>//              this is an ugly algorithm: <br>// <br>//if (old aces exist) <br>//   for (new aces) <br>//      if (new ace option == GRANT) <br>//         for (old aces) <br>//            if (new ace SID == old ace SID) <br>//               do inheritance check <br>//               found = true <br>//               if (old ace type == ALLOWED) <br>//                  old ace mask |= new ace mask <br>//               else <br>//                  old ace mask &amp;= ~new ace mask <br>//         if (!found) <br>//            add size of new ace <br>//         else <br>//            new ace mask = 0 <br>//      else <br>//         add size of new ace <br>// <br>//   for (old aces) <br>//      for (new aces) <br>//         if (new ace option == DENY, REPLACE, REVOKE) <br>//            if (new ace SID == old ace SID) <br>//               found = true <br>//               break <br>//      if (!found) <br>//         add size of old ace <br>//      else <br>//         old ace mask = 0 <br>//else <br>//   for (new aces) <br>//      add size of new ace <br>// <br>// <br>//  Arguments:  OUT [caclsize] - returns size <br>//              IN  [poldacl]  - (OPTIONAL) old ACL that is to be merged <br>//              IN  [fdir]     - True = directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::_GetNewAclSize(ULONG *caclsize, ACL *poldacl, BOOL fdir) <br>{ <br>    ULONG ret; <br> <br>    // the size for the ACL header <br> <br>    *caclsize = sizeof(ACL); <br> <br>    // initialize the access requests <br>    for (ULONG j = 0; j &lt; _ccaa; j++) <br>       _aaa[j].pcaa-&gt;ReInit(); <br> <br>    // if we are merging, calculate the merge size <br> <br>    if (poldacl) <br>    { <br>        // first the grant options <br> <br>        for (j = 0; j &lt; _ccaa; j++) <br>        { <br>            SID *psid; <br>            if (OPTION_GRANT == _aaa[j].option) <br>            { <br>                BOOL ffound = FALSE; <br>                ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL)); <br> <br>                for (ULONG cace = 0; cace &lt; poldacl-&gt;AceCount; <br>                     cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah-&gt;AceSize)) <br>                { <br>                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>                    { <br>                        if (EqualSid(psid, <br>                                     (SID *)&amp;((ACCESS_ALLOWED_ACE *) <br>                                     pah)-&gt;SidStart) ) <br>                        { <br>                            // if old and new types are the same, just and with the old <br> <br>                            if (fdir &amp;&amp; (pah-&gt;AceType == _aaa[j].pcaa-&gt;AceType())) <br>                            { <br>                                // make sure that we can handle the inheritance <br>                                _aaa[j].pcaa-&gt;AddInheritance(pah-&gt;AceFlags); <br> <br>                                ffound = TRUE; <br>                            } else if (pah-&gt;AceType == _aaa[j].pcaa-&gt;AceType()) <br>                            { <br>                                ffound = TRUE; <br>                            } <br>                             <br>                            if (ACCESS_ALLOWED_ACE_TYPE == pah-&gt;AceType) <br>                            { <br>                                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *) <br>                                pah)-&gt;Mask |= _aaa[j].pcaa-&gt;AccessMask(); <br>                            } else if (ACCESS_DENIED_ACE_TYPE == pah-&gt;AceType) <br>                            { <br>                                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *) <br>                                pah)-&gt;Mask &amp;= ~_aaa[j].pcaa-&gt;AccessMask(); <br>                            } else <br>                            { <br>                                VERBOSE((stderr, "_GetNewAclSize found an ace that was not allowed or denied\n")) <br>                                return(ERROR_INVALID_DATA); <br>                            } <br>                        } <br>                    } else <br>                    { <br>                        return(ret); <br>                    } <br>                } <br>                if (!ffound) <br>                { <br>                    // bugbug allowed/denied sizes currently the same <br>                     <br>                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) - <br>                                 sizeof(DWORD) + <br>                                 GetLengthSid(psid); <br>                     <br>                    SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize)) <br>                } else <br>                { <br>                    if (fdir &amp;&amp; (ERROR_SUCCESS != (ret = _aaa[j].pcaa-&gt;TestInheritance()))) <br>                        return(ret); <br>                    _aaa[j].pcaa-&gt;ClearAccessMask(); <br>                } <br>            } else if ( (OPTION_REPLACE == _aaa[j].option) || <br>                        (OPTION_DENY == _aaa[j].option) ) <br>            { <br>                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>                { <br>                    // bugbug allowed/denied sizes currently the same <br>                 <br>                    *caclsize += sizeof(ACCESS_ALLOWED_ACE) - <br>                                 sizeof(DWORD) + <br>                                 GetLengthSid(psid); <br>                 <br>                    SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize)) <br>                } else <br>                    return(ret); <br>            } <br>        } <br>        // now for the deny, replace &amp; revoke options <br> <br>        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL)); <br>        SID *psid; <br> <br>        // loop thru the old ACL <br> <br>        for (ULONG cace = 0; cace &lt; poldacl-&gt;AceCount; <br>            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah-&gt;AceSize)) <br>        { <br>            BOOL ffound = FALSE; <br> <br>            // and thru the new ACEs looking for matching SIDs <br> <br>            for (ULONG j = 0; j &lt; _ccaa; j++) <br>            { <br>                if ( (_aaa[j].option &amp; OPTION_DENY ) || <br>                     (_aaa[j].option &amp; OPTION_REPLACE ) || <br>                     (_aaa[j].option &amp; OPTION_REVOKE ) ) <br>                { <br>                    if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>                    { <br>                        if (EqualSid(psid, <br>                                     (SID *)&amp;((ACCESS_ALLOWED_ACE *) <br>                                     pah)-&gt;SidStart) ) <br>                        { <br>                            ffound = TRUE; <br>                        } <br>                    } else <br>                        return(ret); <br>                } <br>            } <br>            if (!ffound) <br>            { <br>                // if we did not find a match, add the size of the old ACE <br> <br>                *caclsize += ((ACE_HEADER *)pah)-&gt;AceSize; <br> <br>                SIZE((stderr, "adding on size of an old ACE (to the new ACL) = %d\n",*caclsize)) <br>            } else <br>            { <br>                (ACCESS_MASK) ((ACCESS_ALLOWED_ACE *)pah)-&gt;Mask = 0; <br>            } <br>        } <br>        SIZE((stderr, "final size for new ACL = %d\n",*caclsize)) <br>    } else <br>    { <br>        // no old ACL, just add up the sizes of the new aces <br> <br>        for (j = 0; j &lt; _ccaa; j++) <br>        { <br>            // need to know the size of the sid <br>     <br>            SID *psid; <br>            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>            { <br>                // bugbug allowed/denied sizes currently the same <br>     <br>                *caclsize += sizeof(ACCESS_ALLOWED_ACE) - <br>                             sizeof(DWORD) + <br>                             GetLengthSid(psid); <br>     <br>                SIZE((stderr, "adding on size of an new ACE (to the new ACL) = %d\n",*caclsize)) <br>            } else <br>            { <br>                return(ret); <br>            } <br>        } <br>        SIZE((stderr, "final size for new ACL = %d\n",*caclsize)) <br>    } <br>    return(ERROR_SUCCESS); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap:_AllocateNewAcl, private <br>// <br>//  Synopsis:   allocates and initializes the new ACL <br>// <br>//  Arguments:  OUT [pnewdacl] - address of new ACL to allocate <br>//              IN  [caclsize] - size to allocate for the new ACL <br>//              IN  [revision] - revision of the new ACL <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::_AllocateNewAcl(ACL **pnewdacl, ULONG caclsize, ULONG revision) <br>{ <br>    if (NULL == (*pnewdacl = (ACL *) LocalAlloc(LMEM_FIXED, caclsize))) <br>    { <br>        return(ERROR_NOT_ENOUGH_MEMORY); <br>    } <br> <br>    if (!InitializeAcl(*pnewdacl,caclsize, revision)) <br>    { <br>        ULONG ret = GetLastError(); <br>        LocalFree(*pnewdacl); <br>        return(ret); <br> <br>    } <br> <br>    return(ERROR_SUCCESS); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap:_SetAllowedAce, private <br>// <br>//  Synopsis:   appends an allowed ACE to the input ACL <br>// <br>//  Arguments:  IN [dacl] - ACL to add the ACE to <br>//              IN [mask] - access mask to add <br>//              IN [psid] - SID to add <br>//              IN [fdir] - if a Dir add inherit ACE as well <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::_SetAllowedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir) <br>{ <br>    ULONG ret = ERROR_SUCCESS; <br> <br>    // compute the size of the ACE we are making <br> <br>    USHORT acesize = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psid); <br> <br>    SIZE((stderr, "adding allowed ace, size = %d\n",fdir ? acesize*2 : acesize)) <br> <br>    // static buffer in the hopes we won't have to allocate memory <br> <br>    BYTE buf[1024]; <br> <br>    // allocator either uses buf or allocates a new buffer if size is not enough <br> <br>    FastAllocator fa(buf, 1024); <br> <br>    // get the buffer for the ACE <br> <br>    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)fa.GetBuf(acesize); <br> <br>    // fill in the ACE <br> <br>    memcpy(&amp;paaa-&gt;SidStart,psid,GetLengthSid(psid)); <br>    paaa-&gt;Mask = mask; <br> <br>    paaa-&gt;Header.AceType = ACCESS_ALLOWED_ACE_TYPE; <br>    paaa-&gt;Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0; <br>    paaa-&gt;Header.AceSize = acesize; <br> <br>    // put the ACE into the ACL <br> <br>    if (!AddAce(dacl, <br>                dacl-&gt;AclRevision, <br>                0xffffffff, <br>                paaa, <br>                paaa-&gt;Header.AceSize)) <br>        ret = GetLastError(); <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap:_SetDeniedAce, private <br>// <br>//  Synopsis:   appends a denied ACE to the input ACL <br>// <br>//  Arguments:  IN [dacl] - ACL to add the ACE to <br>//              IN [mask] - access mask to add <br>//              IN [psid] - SID to add <br>//              IN [fdir] - if a Dir add inherit ACE as well <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::_SetDeniedAce(ACL *dacl, ACCESS_MASK mask, SID *psid, BOOL fdir) <br>{ <br>    ULONG ret = ERROR_SUCCESS; <br> <br>    // compute the size of the ACE we are making <br> <br>    USHORT acesize = sizeof(ACCESS_DENIED_ACE) - <br>                   sizeof(DWORD) + <br>                   GetLengthSid(psid); <br> <br>    SIZE((stderr, "adding denied ace, size = %d\n",acesize)) <br> <br>    // static buffer in the hopes we won't have to allocate memory <br> <br>    BYTE buf[1024]; <br> <br>    // allocator either uses buf or allocates a new buffer if size is not enough <br> <br>    FastAllocator fa(buf, 1024); <br> <br>    // get the buffer for the ACE <br> <br>    ACCESS_DENIED_ACE *paaa = (ACCESS_DENIED_ACE *)fa.GetBuf(acesize); <br> <br>    // fill in the ACE <br> <br>    memcpy(&amp;paaa-&gt;SidStart,psid,GetLengthSid(psid)); <br>    paaa-&gt;Mask = mask; <br> <br>    paaa-&gt;Header.AceType = ACCESS_DENIED_ACE_TYPE; <br>    paaa-&gt;Header.AceFlags = fdir ? CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE : 0; <br>    paaa-&gt;Header.AceSize = acesize; <br> <br>    // put the ACE into the ACL <br> <br>    if (!AddAce(dacl, <br>                dacl-&gt;AclRevision, <br>                0xffffffff, <br>                paaa, <br>                paaa-&gt;Header.AceSize)) <br>        ret = GetLastError(); <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CDaclWrap:_FillNewAcl, private <br>// <br>//  Synopsis:   The worker routine that actually fills the ACL, it adds the <br>//              new denied ACEs, then if the new ACEs are being merged with <br>//              an existing ACL, the existing ACL's ACE's (that don't <br>//              conflict) are added, finally the new allowed ACEs are added. <br>//              another ugly algorithm: <br>// <br>//for (new aces) <br>//   if (new ace option == DENY) <br>//      add new ace <br>// <br>//if (old aces) <br>//   for (old aces) <br>//      if (old ace mask != 0) <br>//         add old ace <br>// <br>//   for (new aces) <br>//      if (new ace option != DENY) <br>//         if ( new ace option != REVOKE) <br>//            if (new ace mask != 0 <br>//                add new ace <br>// <br>//else <br>//   for (new aces) <br>//      if (new ace option != DENY) <br>//         add new ace <br>// <br>//  Arguments:  IN [pnewdacl] - the new ACL to be filled <br>//              IN [poldacl]  - (OPTIONAL) old ACL that is to be merged <br>//              IN [fdir]     - TRUE = directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CDaclWrap::_FillNewAcl(ACL *pnewdacl, ACL *poldacl, BOOL fdir) <br>{ <br>    SID *psid; <br>    ULONG ret; <br> <br>    // set new denied aces <br> <br>    VERBOSE((stderr, "start addr of new ACL %0lx\n",pnewdacl)) <br> <br>    for (ULONG j = 0; j &lt; _ccaa; j++) <br>    { <br>        if (_aaa[j].option &amp; OPTION_DENY) <br>        { <br>            if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>            { <br>                if (ERROR_SUCCESS != (ret = _SetDeniedAce(pnewdacl, <br>                                                           _aaa[j].pcaa-&gt;AccessMask(), <br>                                                           psid, <br>                                                           fdir ))) <br>                    return(ret); <br>            } else <br>                return(ret); <br>        } <br>    } <br> <br>    // check and see if the ACL from from the file is in correct format <br> <br>    if (poldacl) <br>    { <br>        SIZE((stderr, "old ACL size = %d, acecount = %d\n",poldacl-&gt;AclSize, <br>              poldacl-&gt;AceCount)) <br> <br>        ACE_HEADER *pah = (ACE_HEADER *)Add2Ptr(poldacl, sizeof(ACL)); <br> <br>        // loop thru the old ACL, looking for matches with the new ACEs <br> <br>        BOOL fallowedacefound = FALSE; <br>        for (ULONG cace = 0; cace &lt; poldacl-&gt;AceCount; <br>            cace++, pah = (ACE_HEADER *)Add2Ptr(pah, pah-&gt;AceSize)) <br>        { <br>            // error exit if the old ACL is incorrectly formated <br> <br>            if (pah-&gt;AceType == ACCESS_DENIED_ACE_TYPE &amp;&amp; fallowedacefound) <br>            { <br>                VERBOSE((stderr, "_FillNewAcl found an denied ACE after an allowed ACE\n")) <br>                return(ERROR_INVALID_DATA); <br>            } <br>            else if (pah-&gt;AceType == ACCESS_ALLOWED_ACE_TYPE) <br>                fallowedacefound = TRUE; <br> <br>            // add the old ace to the new ACL if the old ace's mask is not zero <br> <br>            if ( 0 != (ACCESS_MASK)((ACCESS_ALLOWED_ACE *)pah)-&gt;Mask) <br>            { <br>                // add the old ace <br>                if (!AddAce(pnewdacl, <br>                            pnewdacl-&gt;AclRevision, <br>                            0xffffffff, <br>                            pah, <br>                            pah-&gt;AceSize)) <br>                    return(GetLastError()); <br>            } <br>        } <br>        // now for the new aces <br> <br>        for (ULONG j = 0; j &lt; _ccaa; j++) <br>        { <br>            if ( (_aaa[j].option != OPTION_DENY) &amp;&amp;  <br>                 (_aaa[j].option != OPTION_REVOKE) &amp;&amp; <br>                 (_aaa[j].pcaa-&gt;AccessMask() != 0) ) <br>            { <br>                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>                { <br>                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl, <br>                                                               _aaa[j].pcaa-&gt;AccessMask(), <br>                                                               psid, <br>                                                               fdir ))) <br>                        return(ret); <br>                } else <br>                    return(ret); <br>            } <br>             <br>        } <br>    } else <br>    { <br>        // no old acl, just add the (rest) of the new aces <br>        for (ULONG j = 0; j &lt; _ccaa; j++) <br>        { <br>            if (_aaa[j].option != OPTION_DENY) <br>            { <br>                if (ERROR_SUCCESS == (ret = _aaa[j].pcaa-&gt;Sid(&amp;psid))) <br>                { <br>                    if (ERROR_SUCCESS != (ret = _SetAllowedAce(pnewdacl, <br>                                                               _aaa[j].pcaa-&gt;AccessMask(), <br>                                                               psid, <br>                                                               fdir ))) <br>                        return(ret); <br>                } else <br>                    return(ret); <br>            } <br>        } <br>    } <br> <br>    return(ERROR_SUCCESS); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
