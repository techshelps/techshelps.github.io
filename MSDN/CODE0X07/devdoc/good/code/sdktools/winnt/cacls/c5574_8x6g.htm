<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILEENUM.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5578"></a>FILEENUM.CXX</h2>
<pre><code>//+------------------------------------------------------------------ <br>// <br>// Copyright (C) 1995, Microsoft Corporation. <br>// <br>// File:        FileEnum.cxx <br>// <br>// Contents:    class encapsulating file enumeration, including a deep option <br>// <br>// Classes:     CFileEnumeration <br>// <br>// History:     Nov-93      DaveMont         Created. <br>// <br>//------------------------------------------------------------------- <br> <br>#include &lt;t2.hxx&gt; <br>#include &lt;FileEnum.hxx&gt; <br>#if DBG <br>extern ULONG Debug; <br>#endif <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::CFileEnumerate, public <br>// <br>//  Synopsis:   initializes data members, constructor will not throw <br>// <br>//  Arguments:  IN [fdeep] - TRUE = go into sub-directories <br>// <br>//---------------------------------------------------------------------------- <br>CFileEnumerate::CFileEnumerate(BOOL fdeep) <br>    : _fdeep(fdeep), <br>      _findeep(FALSE), <br>      _froot(FALSE), <br>      _fcannotaccess(FALSE), <br>      _pcfe(NULL), <br>      _pwfileposition(NULL), <br>      _handle(INVALID_HANDLE_VALUE) <br>{ <br>    ENUMERATE_RETURNS((stderr, "CFileEnumerate ctor\n")) <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     Dtor, public <br>// <br>//  Synopsis:   closes handles <br>// <br>//  Arguments:  none <br>// <br>//---------------------------------------------------------------------------- <br>CFileEnumerate::~CFileEnumerate() <br>{ <br>    if (_handle != INVALID_HANDLE_VALUE) <br>        FindClose(_handle); <br>    ENUMERATE_RETURNS((stderr, "CFileEnumerate dtor (%ws)\n", _wpath)) <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::Init, public <br>// <br>//  Synopsis:   Init must be called before any other methods - this <br>//              is not enforced. converts a ASCII file/path to a UNICODE <br>//              file/path, and gets the first file in the enumeration <br>// <br>//  Arguments:  IN  [filename]  - the path/file to enumerate <br>//              OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::Init(CHAR *filename, WCHAR **wfilename, BOOL *fdir) <br>{ <br>    // Initialize the file name <br> <br>    if (filename &amp;&amp; (strlen(filename) &lt; MAX_PATH)) <br>    { <br>        // make it wchar <br>        WCHAR winfilename[MAX_PATH]; <br> <br>        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, <br>                                filename, -1, <br>                                winfilename, sizeof(winfilename)) == 0) <br>            return(ERROR_INVALID_NAME); <br> <br>        // finish initialization <br> <br>        return(_ialize(winfilename, wfilename, fdir)); <br>    } <br>    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME)) <br>    return(ERROR_INVALID_NAME); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::Init, public <br>// <br>//  Synopsis:   Same as previous, except takes UNICODE file/path as input <br>// <br>//  Arguments:  IN  [filename]  - the path/file to enumerate <br>//              OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::Init(WCHAR *filename, WCHAR **wfilename, BOOL *fdir) <br>{ <br>    // Initialize the file name <br> <br>    if (filename &amp;&amp; (wcslen(filename) &lt; MAX_PATH)) <br>    { <br>        return(_ialize(filename, wfilename, fdir)); <br>    } <br>    ENUMERATE_FAIL((stderr, "Init bad file name: %ld\n",ERROR_INVALID_NAME)) <br>    return(ERROR_INVALID_NAME); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::_ialize, private <br>// <br>//  Synopsis:   finishes initialization and starts search for first file in <br>//              the enumeration <br>// <br>//  Arguments:  OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::_ialize(WCHAR *winfilename, WCHAR **wfilename, BOOL *fdir) <br>{ <br>    ENUMERATE_RETURNS((stderr, "Init start, path =  %ws\n", winfilename)) <br>    ULONG ret = ERROR_SUCCESS; <br> <br>    ENUMERATE_STAT((stderr, "start path = %ws\n",winfilename)) <br> <br>    // save the location of the filename or wildcards <br> <br>    ULONG cwcharcount; <br> <br>    if (!(cwcharcount = GetFullPathName(winfilename, <br>                                       MAX_PATH, <br>                                       _wpath, <br>                                       &amp;_pwfileposition))) <br>    { <br>        return(ERROR_INVALID_NAME); <br>    } <br> <br>    ENUMERATE_STAT((stderr, "got full path name = %ws, filename = (%ws), total chars = %d\n",_wpath, _pwfileposition, cwcharcount)) <br> <br>    // if the filepart (_pwfileposition) is NULL, then the name must end in a slash. <br>    // add a * <br> <br>    if (NULL == _pwfileposition) <br>    { <br>       _pwfileposition = (WCHAR *)Add2Ptr(_wpath,wcslen(_wpath)*sizeof(WCHAR)); <br>    } <br> <br>    // save the filename/wildcards <br> <br>    wcscpy(_wwildcards, _pwfileposition); <br> <br>    ENUMERATE_EXTRA((stderr, "wild cards = %ws\n",_wwildcards)) <br> <br>    // if we are at a root (path ends in :\) <br> <br>    if ( (_wpath[wcslen(_wpath) - 1] == L'\\') &amp;&amp; <br>         (wcslen(_wpath) &gt; 1) &amp;&amp; <br>         (_wpath[wcslen(_wpath) - 2] == L':') ) <br>    { <br>        _wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY; <br>        _wfd.cFileName[0] = L'\0'; <br>        *wfilename = _wpath; <br>        *fdir = TRUE; <br>        _froot = TRUE; <br>    } else <br>    { <br>    // check to see if we can iterate through files <br>        if ( (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile(_wpath, &amp;_wfd) ) ) ) <br>        { <br>            ret = GetLastError(); <br>            _fcannotaccess = (ERROR_ACCESS_DENIED == ret); <br> <br>            ENUMERATE_FAIL((stderr, "find first returned: %ld\n",ret)) <br>        } <br>        if (ERROR_SUCCESS == ret) <br>        { <br>            // reject . &amp; .. filenames (go on to next file ) <br> <br>            if ( (0 == wcscmp(_wfd.cFileName, L".")) || <br>                 (0 == wcscmp(_wfd.cFileName, L"..")) ) <br>            { <br>                ret = _NextLocal(wfilename,fdir); <br>            } else <br>            { <br>                // return the current directory <br> <br>                if (_wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) <br>                    *fdir = TRUE; <br>                else <br>                    *fdir = FALSE; <br> <br>                // add the filename to the path so the whole thing is returned <br> <br>                wcscpy(_pwfileposition, _wfd.cFileName); <br> <br>                *wfilename = _wpath; <br>            } <br>        } <br> <br>        ENUMERATE_STAT((stderr, "next filename = %ws\n", *wfilename)) <br>    } <br> <br>    // if we are going deep and we did not find a file yet: <br> <br>    if ( _fdeep &amp;&amp; ( ( ERROR_NO_MORE_FILES == ret ) || <br>                     ( ERROR_FILE_NOT_FOUND == ret ) ) ) <br>    { <br>        if (_handle != INVALID_HANDLE_VALUE) <br>        { <br>            FindClose(_handle); <br>            _handle = INVALID_HANDLE_VALUE; <br>        } <br>        ret = _InitDir(wfilename, fdir); <br>    } <br> <br>    ENUMERATE_RETURNS((stderr, "Init returning  =  %ws(%ld)\n\n", *wfilename, ret)) <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::Next, public <br>// <br>//  Synopsis:   finds the next file in the enumeration <br>// <br>//  Arguments:  OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::Next(WCHAR **wfilename, BOOL *fdir) <br>{ <br>    ENUMERATE_RETURNS((stderr, "Next start, path =  %ws\n", _wpath)) <br>    ULONG ret = ERROR_NO_MORE_FILES; <br> <br>    // if we failed to initialize with an ERROR_ACCESS_DENIED, then exit <br>    if (_fcannotaccess) <br>        return(ERROR_NO_MORE_FILES); <br> <br>    // if we are not in deep <br> <br>    if (!_findeep) <br>    { <br>        if (!_froot) <br>           ret = _NextLocal(wfilename, fdir); <br> <br>        // if we ran out of files and we are going deep: <br> <br>        if ( _fdeep &amp;&amp; <br>             ( ( ERROR_NO_MORE_FILES == ret ) || <br>               ( ERROR_FILE_NOT_FOUND == ret ) || _froot ) ) <br>        { <br>            if (_handle != INVALID_HANDLE_VALUE) <br>            { <br>                FindClose(_handle); <br>                _handle = INVALID_HANDLE_VALUE; <br>            } <br>            ret = _InitDir(wfilename, fdir); <br>            _froot = FALSE; // (we are past the root now) <br>        } <br> <br>    } else <br>    { <br>        // if we are already down a directory (and in deep) <br> <br>        if (_pcfe) <br>        { <br>            if (ERROR_SUCCESS != (ret = _pcfe-&gt;Next(wfilename, fdir))) <br>            { <br>                if (ERROR_ACCESS_DENIED != ret) <br>                { <br>                    delete _pcfe; <br>                    _pcfe = NULL; <br>                } <br>            } <br>        } <br> <br>        // we need to go to the next directory in the current dir <br> <br>        if (ERROR_NO_MORE_FILES == ret) <br>        { <br>            ret = _NextDir(wfilename, fdir); <br>        } <br>    } <br>    ENUMERATE_RETURNS((stderr, "Next returning  =  %ws(%ld)\n\n", *wfilename, ret)) <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::_NextLocal, private <br>// <br>//  Synopsis:   searchs for the next file in the current directory <br>// <br>//  Arguments:  OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::_NextLocal(WCHAR **wfilename, BOOL *fdir) <br>{ <br>    ENUMERATE_RETURNS((stderr, "_NextLocal start, path =  %ws\n", _wpath)) <br>    ULONG ret = ERROR_SUCCESS; <br> <br>    // ensure that we have a valid handle for a findnextfile <br> <br>    if (INVALID_HANDLE_VALUE == _handle) <br>    { <br>        ret = ERROR_INVALID_HANDLE; <br>    } else <br>    { <br>        do <br>        { <br>            if (!FindNextFile(_handle, &amp;_wfd)) <br>            { <br>                ret = GetLastError(); <br>                ENUMERATE_FAIL((stderr, "find next returned: %ld\n",ret)) <br>            } else <br>                ret = ERROR_SUCCESS; <br>        } <br>        while ( (ERROR_SUCCESS == ret) &amp;&amp; <br>                ( (0 == wcscmp(_wfd.cFileName, L".")) || <br>                  (0 == wcscmp(_wfd.cFileName, L"..")) ) ); <br> <br> <br>        // if we found a file <br> <br>        if (ERROR_SUCCESS == ret) <br>        { <br>            // return the directory attrib. <br> <br>            if (_wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) <br>                *fdir = TRUE; <br>            else <br>                *fdir = FALSE; <br> <br>            // add the filename to the path so the whole thing is returned <br> <br>            wcscpy(_pwfileposition, _wfd.cFileName); <br> <br>            *wfilename = _wpath; <br> <br>            ENUMERATE_STAT((stderr, "next filename = %ws\n", *wfilename)) <br>        } <br>    } <br>    ENUMERATE_RETURNS((stderr, "_NextLocal returning  =  %ws(%ld)\n", *wfilename, ret)) <br> <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::_InitDir, private <br>// <br>//  Synopsis:   (only called if going deep) <br>//              goes down a directory (and thus causing a new CFileEnumerator <br>//              to be created, or re-initializies <br>// <br>//  Arguments:  OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::_InitDir(WCHAR **wfilename, BOOL *fdir) <br>{ <br>    ENUMERATE_RETURNS((stderr, "_InitDir start, path =  %ws\n", _wpath)) <br>    ULONG ret = ERROR_SUCCESS; <br> <br>    // check and see if a directory was entered as the filename <br> <br>    if ( (0 == _wcsicmp(_wwildcards, _wfd.cFileName)) &amp;&amp; <br>         (_wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) ) <br>    { <br>        ENUMERATE_EXTRA((stderr, "first file matched directory = %ws\n", _wpath)) <br>        _pwfileposition += wcslen(_wfd.cFileName); <br>        wcscpy(_pwfileposition, L"\\*.*"); <br>        _pwfileposition++; <br>        wcscpy(_wwildcards, L"*.*"); <br>        ENUMERATE_EXTRA((stderr, "      path = %ws\n",_wpath)) <br>        ENUMERATE_EXTRA((stderr, "wild cards = %ws\n",_wwildcards)) <br> <br>        WCHAR winfilename[MAX_PATH]; <br>        wcscpy(winfilename, _wpath); <br> <br>        ret = _ialize(winfilename, wfilename, fdir); <br>    } else <br>    { <br> <br>        // we are in deep <br> <br>        _findeep = TRUE; <br> <br>        // search thru all directories <br> <br>        wcscpy(_pwfileposition, L"*.*"); <br> <br>        if (INVALID_HANDLE_VALUE == ( _handle = FindFirstFile(_wpath, &amp;_wfd) )) <br>        { <br>            ret = GetLastError(); <br>            ENUMERATE_FAIL((stderr, "find first (dir) returned: %ld\n",ret)) <br>        } else <br>        { <br>            if ( !(_wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) || <br>                 (0 == wcscmp(_wfd.cFileName, L".")) || <br>                 (0 == wcscmp(_wfd.cFileName, L"..")) ) <br>            { <br>                ret = _NextDir(wfilename, fdir); <br>            } else <br>            { <br>                // if we have a sub directory, go down it <br> <br>                ret = _DownDir(wfilename, fdir); <br> <br>                // if we found nothing in that first sub directory, go the the next one <br> <br>                if ( (ERROR_NO_MORE_FILES == ret ) || <br>                     (ERROR_FILE_NOT_FOUND == ret ) ) <br>                { <br>                    ret = _NextDir(wfilename, fdir); <br>                } <br>            } <br>        } <br>    } <br>    ENUMERATE_RETURNS((stderr, "_InitDir returning  =  %ws(%ld)\n", *wfilename, ret)) <br> <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::_NextDir, private <br>// <br>//  Synopsis:   (only called if going deep) <br>//              finds the next sub-directory from the current directory, <br>//              and then goes down into that directory <br>// <br>//  Arguments:  OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::_NextDir(WCHAR **wfilename, BOOL *fdir) <br>{ <br>    ENUMERATE_RETURNS((stderr, "_NextDir start, path =  %ws\n", _wpath)) <br>    ULONG ret = ERROR_SUCCESS; <br> <br>    // skip the . &amp; .. &amp; files we cannot access <br> <br>    if (INVALID_HANDLE_VALUE == _handle) <br>    { <br>        ret = ERROR_INVALID_HANDLE; <br>    } else <br>    { <br>        do <br>        { <br>            do <br>            { <br>                if (!FindNextFile(_handle, &amp;_wfd)) <br>                { <br>                    ret = GetLastError(); <br>                    ENUMERATE_FAIL((stderr, "find next returned: %ld\n",ret)) <br>                } else <br>                    ret = ERROR_SUCCESS; <br>            } <br>            while ( (ERROR_SUCCESS == ret) &amp;&amp; <br>                    ( !(_wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) || <br>                      (0 == wcscmp(_wfd.cFileName, L".")) || <br>                      (0 == wcscmp(_wfd.cFileName, L"..")) ) ); <br> <br>            // if we found a directory <br> <br>            if (ERROR_SUCCESS == ret) <br>            { <br>                ret = _DownDir(wfilename, fdir); <br>            } else <br>            { <br>                // out of subdirectories to search, break out of the loop <br>                break; <br>            } <br>        } <br>        while (( ERROR_NO_MORE_FILES == ret) || (ERROR_FILE_NOT_FOUND == ret)); <br>    } <br>    ENUMERATE_RETURNS((stderr, "_NextDir returning  =  %ws(%ld)\n", *wfilename, ret)) <br> <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileEnumerate::_DownDir, private <br>// <br>//  Synopsis:   (only called if going deep) <br>//              creates a new CFileEnumerator for a sub-directory <br>// <br>//  Arguments:  OUT [wfilename] - first file in the enumeration <br>//              OUT [fdir]      - TRUE = returned file is a directory <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileEnumerate::_DownDir(WCHAR **wfilename, BOOL *fdir) <br>{ <br>    ENUMERATE_RETURNS((stderr, "_DownDir start, path =  %ws\n", _wpath)) <br>    ULONG ret; <br> <br>    // make a new file enumerator class (this one) We should only go down <br>    // 8 directories at most. <br> <br>    _pcfe = new CFileEnumerate(_fdeep); <br> <br>    // add the wildcards to the end of the directory we are going down <br> <br>    wcscpy(_pwfileposition, _wfd.cFileName); <br>    wcscat(_pwfileposition, L"\\"); <br>    wcscat(_pwfileposition, _wwildcards); <br> <br>    // start it up and see if we find a match <br> <br>    if (ERROR_SUCCESS != (ret = _pcfe-&gt;Init(_wpath, wfilename, fdir))) <br>    { <br>        if (ERROR_ACCESS_DENIED != ret) <br>        { <br>            delete _pcfe; <br>            _pcfe = NULL; <br>        } <br>    } <br>    ENUMERATE_RETURNS((stderr, "_DownDir returning  =  %ws(%ld)\n", *wfilename, ret)) <br>    return(ret); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
