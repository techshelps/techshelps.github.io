<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>T2.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5581"></a>T2.CXX</h2>
<pre><code>//+------------------------------------------------------------------ <br>// <br>// Copyright (C) 1995, Microsoft Corporation. <br>// <br>// File:        t2.cxx <br>// <br>// Contents: <br>// <br>// Classes: <br>// <br>// History:     Nov-93      DaveMont         Created. <br>// <br>//------------------------------------------------------------------- <br>#include &lt;t2.hxx&gt; <br>#include &lt;filesec.hxx&gt; <br>#include &lt;fileenum.hxx&gt; <br>#include &lt;dumpsec.hxx&gt; <br>#include "caclsmsg.h" <br>#include &lt;locale.h&gt; <br>#include &lt;string.h&gt; <br> <br>#if DBG <br>ULONG Debug; <br>#endif <br>//+---------------------------------------------------------------------------- <br>// <br>// local prototypes <br>// <br>//+---------------------------------------------------------------------------- <br>BOOLEAN OpenToken(PHANDLE ph); <br>void printfsid(SID *psid, ULONG *outputoffset); <br>void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset); <br>void printfmask(ULONG mask, UCHAR acetype, BOOL fdir, ULONG outputoffset); <br>WCHAR *mbstowcs(char *aname ); <br>BOOL GetUserAndAccess(CHAR *arg, WCHAR **user, ULONG *access); <br>#if DBG <br>ULONG DebugEnumerate(CHAR *filename, ULONG option); <br>#endif <br>ULONG DisplayAces(CHAR *filename, ULONG option); <br>ULONG ModifyAces(CHAR *filename, <br>                 MODE emode, <br>                 ULONG option, <br>                 CHAR *argv[], <br>                 LONG astart[], LONG aend[] ); <br>ULONG GetCmdLineArgs(INT argc, char *argv[], <br>                     ULONG *option, <br>                     LONG astart[], LONG aend[], <br>                     MODE *emode <br>#if DBG <br>                     ,ULONG *debug <br>#endif <br>                     ); <br>ULONG  printmessage (FILE* fp, DWORD messageID, ...); <br>//+---------------------------------------------------------------------------- <br>// <br>//  Function:   Usage <br>// <br>//  Synopsis:   prints usage functionality <br>// <br>//  Arguments: none <br>// <br>//---------------------------------------------------------------------------- <br>VOID usage() <br>{ <br>    printmessage(stdout, MSG_CACLS_USAGE, NULL); <br> <br>#if DBG <br>    if (Debug) <br>    { <br>        printf("\n   /B            deBug &lt;[#]&gt;\n"); <br>        printf("                 default is display error returned\n"); <br>        printf("                 in /B '#' is a mask: 1  display SIDS values\n"); <br>        printf("                                      2  display access masks\n"); <br>        printf("                                      4  display error returned\n"); <br>        printf("                                      8  display error location\n"); <br>        printf("                                   0x10  verbose\n"); <br>        printf("                                   0x20  verboser\n"); <br>        printf("                                   0x40  enumerate names\n"); <br>        printf("                                   0x80  enumerate failures\n"); <br>        printf("                                  0x100  enumerate starts and returns\n"); <br>        printf("                                  0x200  enumerate extra data\n"); <br>        printf("                                  0x400  size allocation data\n"); <br>        printf("                                  0x800  display enumeration of files\n"); <br>    } <br>#endif <br>} <br>//+---------------------------------------------------------------------------- <br>// <br>//  Function:     Main, Public <br>// <br>//  Synopsis:     main!! <br>// <br>//  Arguments:    IN [argc] - cmdline arguement count <br>//                IN [argv] - input cmdline arguements <br>// <br>//---------------------------------------------------------------------------- <br>VOID main(INT argc, char *argv[]) <br>{ <br>    char lBuf[6]; <br> <br>    DWORD dw = GetConsoleOutputCP(); <br> <br>//fix kksuzuka: #2383 <br>//for bilingual messages <br>   switch (dw) { <br>       case 932: <br>       case 936: <br>       case 949: <br>       case 950: <br>           SetThreadLocale( <br>               MAKELCID( MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()), <br>                                     SUBLANG_ENGLISH_US ), <br>                   SORT_DEFAULT ) ); <br>           sprintf(lBuf, ".%d", dw); <br>           setlocale(LC_ALL, lBuf); <br>           break; <br>       default: <br>           SetThreadLocale( <br>               MAKELCID( MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ), <br>                   SORT_DEFAULT ) ); <br>           setlocale(LC_ALL,".437"); <br>           break; <br>    } <br> <br>    LONG astart[MAX_OPTIONS], aend[MAX_OPTIONS]; <br>    MODE emode; <br> <br>    LONG ret; <br>    ULONG option; <br> <br>    if (ERROR_SUCCESS != (ret = GetCmdLineArgs(argc, argv, <br>                                               &amp;option, <br>                                               astart, aend, <br>                                               &amp;emode <br>#if DBG <br>                                               ,&amp;Debug <br>#endif <br>                                               ))) <br>    { <br>        usage(); <br>        exit(ret); <br>    } <br> <br>    switch (emode) <br>    { <br>        case MODE_DISPLAY: <br>            ret = DisplayAces(argv[1], option); <br>            break; <br>        case MODE_REPLACE: <br>        case MODE_MODIFY: <br>            ret = ModifyAces(argv[1], emode, option, argv, astart, aend ); <br>            break; <br>#if DBG <br>        case MODE_DEBUG_ENUMERATE: <br>            ret = DebugEnumerate(argv[1], option); <br>            break; <br>#endif <br>        default: <br>        { <br>            usage(); <br>            exit(1); <br>        } <br>    } <br>    if (ERROR_SUCCESS != ret) <br>    { <br>        LAST_ERROR((stderr, "Cacls failed, %ld\n",ret)) <br>        printmessage(stderr, ret, NULL); <br> } <br> <br>    exit(ret); <br>} <br>//--------------------------------------------------------------------------- <br>// <br>//  Function:     GetCmdLineArgs <br>// <br>//  Synopsis:     gets and parses command line arguments into commands <br>//                recognized by this program <br>// <br>//  Arguments:    IN  [argc]   - cmdline arguement count <br>//                IN  [argv]   - input cmdline arguements <br>//                OUT [option] - requested option <br>//                OUT [astart] - start of arguments for each option <br>//                OUT [aend]   - end of arguments for each option <br>//                OUT [emode]  - mode of operation <br>//                OUT [debug]  - debug mask <br>// <br>// <br>//---------------------------------------------------------------------------- <br>ULONG GetCmdLineArgs(INT argc, char *argv[], <br>                     ULONG *option, <br>                     LONG astart[], LONG aend[], <br>                     MODE *emode <br>#if DBG <br>                     ,ULONG *debug <br>#endif <br>                     ) <br>{ <br>    ARG_MODE_INDEX am = ARG_MODE_INDEX_NEED_OPTION; <br> <br>#if DBG <br>    *debug = 0; <br>#endif <br>    *emode = MODE_DISPLAY; <br>    *option = 0; <br> <br>    for (LONG j=0; j &lt; MAX_OPTIONS ;j++ ) <br>    { <br>        astart[j] = 0; <br>        aend[j] = 0; <br>    } <br> <br>    if ( (argc &lt; 2) || (argv[1][0] == '/') ) <br>    { <br>#if DBG <br>        // do this so debug args are printed out <br> <br>        if (argc &gt;= 2) <br>        { <br>            if ( (0 == _stricmp(&amp;argv[1][1], "deBug")) || <br>                 (0 == _stricmp(&amp;argv[1][1], "b"))  ) <br>            { <br>                *debug = DEBUG_LAST_ERROR; <br>            } <br>        } <br>#endif <br>        return(ERROR_BAD_ARGUMENTS); <br>    } <br> <br>    for (LONG k = 2; k &lt; argc ; k++ ) <br>    { <br>        if (argv[k][0] == '/') <br>        { <br>            switch (am) <br>            { <br>                case ARG_MODE_INDEX_NEED_OPTION: <br>#if DBG <br>                case ARG_MODE_INDEX_DEBUG: <br>#endif <br>                    break; <br> <br>                case ARG_MODE_INDEX_DENY: <br>                case ARG_MODE_INDEX_REVOKE: <br>                case ARG_MODE_INDEX_GRANT: <br>                case ARG_MODE_INDEX_REPLACE: <br>                    if (astart[am] == k) <br>                        return(ERROR_BAD_ARGUMENTS); <br>                    break; <br> <br>                default: <br>                    return(ERROR_BAD_ARGUMENTS); <br>            } <br> <br>            if ( (0 == _stricmp(&amp;argv[k][1], "Tree")) || <br>                 (0 == _stricmp(&amp;argv[k][1], "t")) ) <br>            { <br>                if (*option &amp; OPTION_TREE) <br>                    return(ERROR_BAD_ARGUMENTS); <br>                *option |= OPTION_TREE; <br>                am = ARG_MODE_INDEX_NEED_OPTION; <br>                continue; <br>            } <br> <br>            if ( (0 == _stricmp(&amp;argv[k][1], "Continue")) || <br>                 (0 == _stricmp(&amp;argv[k][1], "c")) ) <br>            { <br>                if (*option &amp; OPTION_CONTINUE_ON_ERROR) <br>                    return(ERROR_BAD_ARGUMENTS); <br>                *option |= OPTION_CONTINUE_ON_ERROR; <br>                am = ARG_MODE_INDEX_NEED_OPTION; <br>                continue; <br>            } <br> <br>            if ( (0 == _stricmp(&amp;argv[k][1], "Edit")) || <br>                 (0 == _stricmp(&amp;argv[k][1], "E")) ) <br>            { <br>                if (*emode != MODE_DISPLAY) <br>                    return(ERROR_BAD_ARGUMENTS); <br>                *emode = MODE_MODIFY; <br>                am = ARG_MODE_INDEX_NEED_OPTION; <br>                continue; <br>            } <br> <br>#if DBG <br>            if ( (0 == _stricmp(&amp;argv[k][1], "deBug")) || <br>                 (0 == _stricmp(&amp;argv[k][1], "b"))  ) <br>            { <br>                if (*debug) <br>                    return(ERROR_BAD_ARGUMENTS); <br>                am = ARG_MODE_INDEX_DEBUG; <br>                *debug = DEBUG_LAST_ERROR; <br>                continue; <br>            } <br>#endif <br>            if ( (0 == _stricmp(&amp;argv[k][1], "Deny")) || <br>                 (0 == _stricmp(&amp;argv[k][1], "D")) ) <br>            { <br>                am = ARG_MODE_INDEX_DENY; <br>                *option |= OPTION_DENY; <br>            } else if ( (0 == _stricmp(&amp;argv[k][1], "Revoke")) || <br>                        (0 == _stricmp(&amp;argv[k][1], "R")) ) <br>            { <br>                am = ARG_MODE_INDEX_REVOKE; <br>                *option |= OPTION_REVOKE; <br>            } else if ( (0 == _stricmp(&amp;argv[k][1], "Grant")) || <br>                        (0 == _stricmp(&amp;argv[k][1], "G")) ) <br>            { <br>                am = ARG_MODE_INDEX_GRANT; <br>                *option |= OPTION_GRANT; <br>            } else if ( (0 == _stricmp(&amp;argv[k][1], "rePlace")) || <br>                        (0 == _stricmp(&amp;argv[k][1], "P")) ) <br>            { <br>                *option |= OPTION_REPLACE; <br>                am = ARG_MODE_INDEX_REPLACE; <br>            } else <br>                return(ERROR_BAD_ARGUMENTS); <br> <br>            if (astart[am] != 0) <br>                return(ERROR_BAD_ARGUMENTS); <br>            astart[am] = k+1; <br>        } else <br>        { <br>            switch (am) <br>            { <br>                case ARG_MODE_INDEX_NEED_OPTION: <br>                    return(ERROR_BAD_ARGUMENTS); <br> <br>#if DBG <br>                case ARG_MODE_INDEX_DEBUG: <br>                    *debug = atol(argv[k]); <br>                    if (*debug &amp; DEBUG_ENUMERATE) <br>                        if (*emode == MODE_DISPLAY) <br>                            *emode = MODE_DEBUG_ENUMERATE; <br>                        else <br>                            return(ERROR_BAD_ARGUMENTS); <br> <br>                    am = ARG_MODE_INDEX_NEED_OPTION; <br>                    break; <br>#endif <br>                case ARG_MODE_INDEX_DENY: <br>                case ARG_MODE_INDEX_REVOKE: <br>                case ARG_MODE_INDEX_GRANT: <br>                case ARG_MODE_INDEX_REPLACE: <br>                    aend[am] = k+1; <br>                    break; <br> <br>                default: <br>                    return(ERROR_BAD_ARGUMENTS); <br>            } <br>        } <br>    } <br> <br>    if ( ( (*option &amp; OPTION_DENY) &amp;&amp; (aend[ARG_MODE_INDEX_DENY] == 0) ) || <br>         ( (*option &amp; OPTION_REVOKE) &amp;&amp; (aend[ARG_MODE_INDEX_REVOKE] == 0) ) || <br>         ( (*option &amp; OPTION_GRANT) &amp;&amp; (aend[ARG_MODE_INDEX_GRANT] == 0) ) || <br>         ( (*option &amp; OPTION_REPLACE) &amp;&amp; (aend[ARG_MODE_INDEX_REPLACE] == 0) ) ) <br>    { <br>        return(ERROR_BAD_ARGUMENTS); <br>    } else if ( (*option &amp; OPTION_DENY) || <br>                (*option &amp; OPTION_REVOKE) || <br>                (*option &amp; OPTION_GRANT) || <br>                (*option &amp; OPTION_REPLACE) ) <br>    { <br>        if (*emode == MODE_DISPLAY) <br>        { <br>            if (*option &amp; OPTION_REVOKE) <br>            { <br>                return(ERROR_BAD_ARGUMENTS); <br>            } <br>            *emode = MODE_REPLACE; <br>        } <br>    } <br>    return(ERROR_SUCCESS); <br>} <br> <br>//--------------------------------------------------------------------------- <br>// <br>//  Function:     DisplayAces <br>// <br>//  Synopsis:     displays ACL from specified file <br>// <br>//  Arguments:    IN [filename] - file name <br>//                IN [option]   - display option <br>// <br>//---------------------------------------------------------------------------- <br>ULONG DisplayAces(CHAR *filename, ULONG option) <br>{ <br>    CFileEnumerate cfe(option &amp; OPTION_TREE); <br>    WCHAR *pwfilename; <br>    BOOL fdir; <br>    ULONG ret; <br> <br>    if (NO_ERROR == (ret = cfe.Init(filename, &amp;pwfilename, &amp;fdir))) <br>    { <br>        while ( (NO_ERROR == ret) || <br>                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&amp;&amp; <br>                  (option &amp; OPTION_CONTINUE_ON_ERROR) ) ) <br>        { <br>#if DBG <br>            if (fdir) <br>                DISPLAY((stderr, "processing file: ")) <br>            else <br>                DISPLAY((stderr, "processing dir: ")) <br>#endif <br>            wprintf(L"%s",  pwfilename); <br>            if (ERROR_ACCESS_DENIED == ret) <br>            { <br>                printmessage(stdout,MSG_CACLS_ACCESS_DENIED, NULL); <br>            } else if (ERROR_SHARING_VIOLATION == ret) <br>            { <br>                printmessage(stdout,MSG_CACLS_SHARING_VIOLATION, NULL); <br>            } else <br>            { <br>                DISPLAY((stderr, "\n")) <br>                VERBOSE((stderr, "\n")) <br>                CDumpSecurity cds(pwfilename); <br> <br>                if (NO_ERROR == (ret = cds.Init())) <br>                { <br>#if DBG <br>                    if (Debug &amp; DEBUG_VERBOSE) <br>                    { <br>                        SID *psid; <br>                        ULONG oo; <br> <br>                        if (NO_ERROR == (ret = cds.GetSDOwner(&amp;psid))) <br>                        { <br>                            printf("  Owner = "); <br>                            printfsid(psid, &amp;oo); <br>                            if (NO_ERROR == (ret = cds.GetSDGroup(&amp;psid))) <br>                            { <br>                                printf("  Group = "); <br>                                printfsid(psid, &amp;oo); <br>                            } <br>                            else <br>                                ERRORS((stderr, "GetSDGroup failed, %d\n",ret)) <br>                        } <br>                        else <br>                            ERRORS((stderr, "GetSDOwner failed, %d\n",ret)) <br>                    } <br>#endif <br>                    ACE_HEADER *paceh; <br> <br>                    LONG retace; <br>                    if (NO_ERROR == ret) <br>                        for (retace = cds.GetNextAce(&amp;paceh); retace &gt;= 0; ) <br>                        { <br>                            printface(paceh, fdir, wcslen(pwfilename)); <br>                            retace = cds.GetNextAce(&amp;paceh); <br>                            if (retace &gt;= 0) <br>                                printf("%*s", <br>                                       WideCharToMultiByte(CP_ACP, 0, <br>                                               pwfilename, -1, <br>                                               NULL, 0, <br>                                               NULL, NULL)-1," "); <br>                        } <br>                } <br>#if DBG <br>                   else <br>                    ERRORS((stderr, "cds.init failed, %d\n",ret)) <br>#endif <br>            } <br>            fprintf(stdout, "\n"); <br> <br>            if ( (NO_ERROR == ret) || <br>                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&amp;&amp; <br>                   (option &amp; OPTION_CONTINUE_ON_ERROR) ) ) <br>                ret = cfe.Next(&amp;pwfilename, &amp;fdir); <br>        } <br> <br>        switch (ret) <br>        { <br>            case ERROR_NO_MORE_FILES: <br>                ret = ERROR_SUCCESS; <br>                break; <br>            case ERROR_ACCESS_DENIED: <br>            case ERROR_SHARING_VIOLATION: <br>                break; <br>            case ERROR_SUCCESS: <br>                break; <br>            default: <br>                break; <br>        } <br> <br>    } else <br>    { <br>        ERRORS((stderr, "cfe.init failed, %d\n",ret)) <br>    } <br>    return(ret); <br>} <br>//--------------------------------------------------------------------------- <br>// <br>//  Function:     ModifyAces <br>// <br>//  Synopsis:     modifies the aces for the specified file(s) <br>// <br>//  Arguments:    IN [filename] - name of file(s) to modify the aces on <br>//                IN [emode]  - mode of operation <br>//                IN [option] - requested option <br>//                IN [astart] - start of arguments for each option <br>//                IN [aend]   - end of arguments for each option <br>// <br>//---------------------------------------------------------------------------- <br>ULONG ModifyAces(CHAR *filename, <br>                 MODE emode, <br>                 ULONG option, <br>                 CHAR *argv[], <br>                 LONG astart[], LONG aend[]) <br>{ <br>    CDaclWrap cdw; <br>    CFileEnumerate cfe(option &amp; OPTION_TREE); <br>    WCHAR *user = NULL; <br>    ULONG access; <br>    ULONG ret = ERROR_SUCCESS; <br>    WCHAR *pwfilename; <br>    ULONG curoption; <br> <br>    VERBOSER((stderr, "user:permission pairs\n")) <br> <br>    // first proces the command line args to build up the new ace <br> <br>    for (ULONG j = 0, k = 1;j &lt; MAX_OPTIONS ; k &lt;&lt;= 1, j++ ) <br>    { <br>        curoption = k; <br>        if (option &amp; k) <br>        { <br>            for (LONG q = astart[j]; <br>                      q &lt; aend[j] ; q++ ) <br>            { <br>                VERBOSER((stderr, "      %s\n",argv[q])) <br> <br>                if ((k &amp; OPTION_GRANT) || (k &amp; OPTION_REPLACE)) <br>                { <br>                    if (!GetUserAndAccess(argv[q], &amp;user, &amp;access)) <br>                    { <br>                        if (user) <br>                            LocalFree(user); <br>                        return(ERROR_BAD_ARGUMENTS); <br>                    } <br>                    if (GENERIC_NONE == access) <br>                    { <br>                        if (!(k &amp; OPTION_REPLACE)) <br>                        { <br>                            if (user) <br>                                LocalFree(user); <br>                            return(ERROR_BAD_ARGUMENTS); <br>                        } <br>                    } <br>                } else <br>                { <br>                    user = mbstowcs(argv[q]); <br>                    access = GENERIC_NONE; <br>                } <br> <br>                VERBOSER((stderr, "OPTION = %d, USER = %ws, ACCESS = %lx\n", <br>                       option, <br>                       user, <br>                       access)) <br> <br> <br>                if (ERROR_SUCCESS != (ret = cdw.SetAccess(curoption, <br>                                                     user, <br>                                                     NULL, <br>                                                     access))) <br>                { <br>                    ERRORS((stderr, "SetAccess for %ws:%lx failed, %d\n", <br>                           user, <br>                           access, <br>                           ret)) <br> <br>                    LocalFree(user); <br>                    return(ret); <br>                } <br>                LocalFree(user); <br>                user = NULL; <br>            } <br>        } <br>    } <br> <br>    BOOL fdir; <br> <br>    if (emode == MODE_REPLACE) <br>    { <br>        CHAR well[MAX_PATH]; <br>        CHAR msgbuf[MAX_PATH]; <br>        printmessage(stdout,MSG_CACLS_ARE_YOU_SURE, NULL); <br>        FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_Y, 0, <br>                      msgbuf, MAX_PATH, NULL); <br>        fgets(well,MAX_PATH,stdin); <br> <br>        // remove the trailing return <br>        if ('\n' == well[strlen(well) - sizeof(CHAR)]) <br>            well[strlen(well) - sizeof(CHAR)] = '\0'; <br> <br>        if (0 != _stricmp(well, msgbuf)) <br>        { <br>            FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE, NULL, MSG_CACLS_YES, 0, <br>                          msgbuf, MAX_PATH, NULL); <br>            if (0 != _stricmp(well, msgbuf)) <br>                return(ERROR_SUCCESS); <br>        } <br>    } <br> <br>    if (NO_ERROR == (ret = cfe.Init(filename, &amp;pwfilename, &amp;fdir))) <br>    { <br>        while ( (NO_ERROR == ret) || <br>                ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) )&amp;&amp; <br>                  (option &amp; OPTION_CONTINUE_ON_ERROR) ) ) <br>        { <br>            CFileSecurity cfs(pwfilename); <br> <br>            if (NO_ERROR == (ret = cfs.Init())) <br>            { <br>                if (NO_ERROR != (ret = cfs.SetFS(emode == MODE_REPLACE ? FALSE : TRUE, &amp;cdw, fdir))) <br>                { <br>                    if (!(((ERROR_ACCESS_DENIED == ret) || (ERROR_SHARING_VIOLATION == ret)) &amp;&amp; <br>                          (option &amp; OPTION_CONTINUE_ON_ERROR))) <br>                    { <br>                        ERRORS((stderr, "SetFS on %ws failed %ld\n",pwfilename, ret)) <br>                        return(ret); <br>                    } <br>                } <br>            } <br>            else <br>            { <br>               // <br>               // If the error is access denied or sharing violation and we are to continue on error, <br>               // then keep going. Otherwise bail out here. <br>               // <br> <br>               if (!(((ERROR_ACCESS_DENIED == ret) || (ERROR_SHARING_VIOLATION == ret)) &amp;&amp; <br>                   (option &amp; OPTION_CONTINUE_ON_ERROR))) { <br> <br>                  ERRORS((stderr, "init failed, %d\n",ret)) <br>                  return(ret); <br>               } <br>            } <br> <br>            if (NO_ERROR == ret) <br>            { <br> <br>                if (fdir) <br>                { <br>                    printmessage(stdout, MSG_CACLS_PROCESSED_DIR, NULL); <br>                    wprintf(L"%s",  pwfilename); <br>                } <br>                else <br>                { <br>                    printmessage(stdout, MSG_CACLS_PROCESSED_FILE, NULL); <br>                    wprintf(L"%s",  pwfilename); <br>                } <br>            } <br>            else if (ERROR_ACCESS_DENIED == ret) <br>            { <br>                printmessage(stdout, MSG_CACLS_ACCESS_DENIED, NULL); <br>                wprintf(L"%s",  pwfilename); <br>            } <br>            else if (ret == ERROR_SHARING_VIOLATION) <br>            { <br>                printmessage(stdout, MSG_CACLS_SHARING_VIOLATION, NULL); <br>                wprintf(L"%s",  pwfilename); <br>            } <br> <br>            if ( (NO_ERROR == ret) || <br>                 ( ( (ERROR_ACCESS_DENIED == ret ) || (ERROR_SHARING_VIOLATION == ret) ) &amp;&amp; <br>                   (option &amp; OPTION_CONTINUE_ON_ERROR) ) ) <br>                ret = cfe.Next(&amp;pwfilename, &amp;fdir); <br>        } <br> <br>        switch (ret) <br>        { <br>            case ERROR_NO_MORE_FILES: <br>                ret = ERROR_SUCCESS; <br>                break; <br>            case ERROR_ACCESS_DENIED: <br>            case ERROR_SHARING_VIOLATION: <br>                break; <br>            case ERROR_SUCCESS: <br>                break; <br>            default: <br>                DISPLAY((stderr, "%ws failed: %d\n", pwfilename, ret)) <br>                break; <br>        } <br>    } else <br>        ERRORS((stderr, "file enumeration failed to initialize %ws, %ld\n",pwfilename, ret)) <br> <br>    if (ret == ERROR_NO_MORE_FILES) <br>    { <br>        ret = ERROR_SUCCESS; <br>    } <br> <br>    if (ret != ERROR_SUCCESS) <br>    { <br>        ERRORS((stderr, "Enumeration failed, %d\n",ret)) <br>    } <br> <br>    return(ret); <br>} <br>#if DBG <br>//--------------------------------------------------------------------------- <br>// <br>//  Function:     DebugEnumerate <br>// <br>//  Synopsis:     debug function <br>// <br>//  Arguments:    IN [filename] - file name <br>//                IN [option]   - option <br>// <br>//---------------------------------------------------------------------------- <br>ULONG DebugEnumerate(CHAR *filename, ULONG option) <br>{ <br>    CFileEnumerate cfe(option &amp; OPTION_TREE); <br>    WCHAR *pwfilename; <br>    BOOL fdir; <br>    ULONG ret; <br> <br>    ret = cfe.Init(filename, &amp;pwfilename, &amp;fdir); <br>    while ( (ERROR_SUCCESS == ret) || <br>            ( (ERROR_ACCESS_DENIED == ret ) &amp;&amp; <br>              (option &amp; OPTION_CONTINUE_ON_ERROR) ) ) <br>    { <br>        if (fdir) <br>            printf("dir  name = %ws%ws\n",pwfilename, <br>                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L""); <br>        else <br>            printf("file name = %ws%ws\n",pwfilename, <br>                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L""); <br>        ret = cfe.Next(&amp;pwfilename, &amp;fdir); <br>    } <br>    if (ret == ERROR_ACCESS_DENIED) <br>    { <br>        if (fdir) <br>            printf("dir  name = %ws%ws\n",pwfilename, <br>                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L""); <br>        else <br>            printf("file name = %ws%ws\n",pwfilename, <br>                   ERROR_ACCESS_DENIED == ret ? L"ACCESS DENIED" : L""); <br>    } <br>    if (ret != ERROR_NO_MORE_FILES) <br>        printf("Enumeration failed, %d\n",ret); <br> <br>    return(ret); <br>} <br>#endif <br>//--------------------------------------------------------------------------- <br>// <br>//  Function:     GetUserAccess <br>// <br>//  Synopsis:     parses an input string for user:access <br>// <br>//  Arguments:    IN  [arg]    - input string to parse <br>//                OUT [user]   - user if found <br>//                OUT [access] - access if found <br>// <br>//---------------------------------------------------------------------------- <br>BOOL GetUserAndAccess(CHAR *arg, WCHAR **user, ULONG *access) <br>{ <br>    CHAR *saccess = strchr(arg,':'); <br>    if (saccess) <br>    { <br>        *saccess = NULL; <br>        saccess++; <br> <br>        if (strchr(saccess,':')) <br>            return(FALSE); <br>        *user = mbstowcs(arg); <br> <br>        if (0 == _stricmp(saccess,"F")) <br>        { <br>            *access = ( STANDARD_RIGHTS_ALL | <br>                        FILE_READ_DATA | <br>                        FILE_WRITE_DATA | <br>                        FILE_APPEND_DATA | <br>                        FILE_READ_EA | <br>                        FILE_WRITE_EA | <br>                        FILE_EXECUTE | <br>                        FILE_DELETE_CHILD | <br>                        FILE_READ_ATTRIBUTES | <br>                        FILE_WRITE_ATTRIBUTES ); <br>        } <br>        else if (0 == _stricmp(saccess,"R")) <br>        { <br>            *access = FILE_GENERIC_READ | FILE_EXECUTE; <br>        } <br>        else if (0 == _stricmp(saccess,"C")) <br>        { <br>            *access = FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE; <br>        } <br>        else if (0 == _stricmp(saccess,"N")) <br>        { <br>            *access = GENERIC_NONE; <br>        } <br>        else if (0 == _stricmp(saccess,"W")) <br>        { <br>            *access = FILE_GENERIC_WRITE | FILE_EXECUTE; <br>        } <br>        else <br>            return(FALSE); <br>        return(TRUE); <br>    } <br>    return(FALSE); <br>} <br>//--------------------------------------------------------------------------- <br>// <br>//  Function:     mbstowcs <br>// <br>//  Synopsis:     converts char to wchar, allocates space for wchar <br>// <br>//  Arguments:    IN [aname] - char string <br>// <br>//---------------------------------------------------------------------------- <br>WCHAR *mbstowcs(char *aname ) <br>{ <br>    if (aname) <br>    { <br>        WCHAR *pwname = NULL; <br>        pwname = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * (strlen(aname)+1)); <br>        if (NULL == pwname) <br>            return(NULL); <br>        WCHAR *prwname = pwname; <br>        if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, <br>                                aname, -1, <br>                                prwname, sizeof(WCHAR)*(strlen(aname)+1)) == 0) <br>            return(NULL); <br>        return(pwname); <br>    } else <br>        return(NULL); <br>} <br>//---------------------------------------------------------------------------- <br>// <br>//  Function: <br>// <br>//  Synopsis: <br>// <br>//  Arguments: <br>// <br>//---------------------------------------------------------------------------- <br>BOOLEAN OpenToken(PHANDLE ph) <br>{ <br>    HANDLE hprocess; <br> <br>    hprocess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId()); <br>    if (hprocess == NULL) <br>        return(FALSE); <br> <br>    if (OpenProcessToken(hprocess, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ph)) <br>    { <br>        CloseHandle(hprocess); <br>        return(TRUE); <br>    } <br> <br>    CloseHandle(hprocess); <br>    return(FALSE); <br>} <br>//---------------------------------------------------------------------------- <br>// <br>//  Function:     printfsid <br>// <br>//  Synopsis:     prints a NT SID <br>// <br>//  Arguments:    IN [psid] - pointer to the sid to print <br>// <br>//---------------------------------------------------------------------------- <br>void printfsid(SID *psid, ULONG *outputoffset) <br>{ <br>#if DBG <br>    if ((Debug &amp; DEBUG_VERBOSE) || (Debug &amp; DEBUG_DISPLAY_SIDS)) <br>    { <br>        printf("S-%lx",psid-&gt;Revision); <br> <br>        if ( (psid-&gt;IdentifierAuthority.Value[0] != 0) || <br>             (psid-&gt;IdentifierAuthority.Value[1] != 0) ) <br>        { <br>            printf("0x%02hx%02hx%02hx%02hx%02hx%02hx", <br>                        (USHORT)psid-&gt;IdentifierAuthority.Value[0], <br>                        (USHORT)psid-&gt;IdentifierAuthority.Value[1], <br>                        (USHORT)psid-&gt;IdentifierAuthority.Value[2], <br>                        (USHORT)psid-&gt;IdentifierAuthority.Value[3], <br>                        (USHORT)psid-&gt;IdentifierAuthority.Value[4], <br>                        (USHORT)psid-&gt;IdentifierAuthority.Value[5] ); <br>        } else <br>        { <br>            printf("-%lu", <br>                   (ULONG)psid-&gt;IdentifierAuthority.Value[5]          + <br>                   (ULONG)(psid-&gt;IdentifierAuthority.Value[4] &lt;&lt;  8)  + <br>                   (ULONG)(psid-&gt;IdentifierAuthority.Value[3] &lt;&lt; 16)  + </code></pre>
<p>
</p>
<pre><code>(ULONG)(psid-&gt;IdentifierAuthority.Value[2] &lt;&lt; 24) ); <br>        } <br> <br>        if ( 0 &lt; psid-&gt;SubAuthorityCount ) <br>        { <br>            for (int k = 0; k &lt; psid-&gt;SubAuthorityCount; k++ ) <br>            { <br>                printf("-%d",psid-&gt;SubAuthority[k]); <br>            } <br>        } <br>    } <br>#endif <br>    ULONG ret; <br> <br>    CAccount ca(psid, NULL); <br> <br>    WCHAR *domain = NULL; <br>    WCHAR *user; <br> <br>    if (NO_ERROR == ( ret = ca.GetAccountDomain(&amp;domain) ) ) <br>    { <br>        if ( (NULL == domain) || (0 == wcslen(domain)) ) <br>        { <br>            fprintf(stdout, " "); <br>            *outputoffset +=1; <br>        } <br>        else <br>        { <br>            fprintf(stdout, " "); <br>            wprintf(L"%s",  domain); <br>fprintf(stdout, "\\"); <br>            *outputoffset += 2 + wcslen( domain );; <br>        } <br> <br>        if (NO_ERROR == ( ret = ca.GetAccountName(&amp;user) ) ) <br>        { <br>            wprintf(L"%s",  user); <br>fprintf(stdout, ":"); <br>            *outputoffset += 1 + wcslen(user); <br>        } else <br>        { <br>            *outputoffset += printmessage(stdout, MSG_CACLS_NAME_NOT_FOUND, NULL); <br> <br>            ERRORS((stderr, "(%lx)",ret)) <br>        } <br>    } else <br>    { <br>        *outputoffset+= printmessage(stdout, MSG_CACLS_DOMAIN_NOT_FOUND, NULL); <br>        ERRORS((stderr, "(%lx)",ret)) <br>    } <br>    VERBOSE((stderr, "\n")) <br>} <br>//---------------------------------------------------------------------------- <br>// <br>//  Function:     printface <br>// <br>//  Synopsis:     prints the specifed ace <br>// <br>//  Arguments:    IN [paceh] - input ace (header) <br>//                IN [fdir]  - TRUE = directory (different display options) <br>// <br>//---------------------------------------------------------------------------- <br>void printface(ACE_HEADER *paceh, BOOL fdir, ULONG outputoffset) <br>{ <br>    VERBOSE((stderr, "  ")) <br>    VERBOSER((stderr, "\npaceh-&gt;AceType  = %x\n",paceh-&gt;AceType  )) <br>    VERBOSER((stderr, "paceh-&gt;AceFlags = %x\n",paceh-&gt;AceFlags )) <br>    VERBOSER((stderr, "paceh-&gt;AceSize  = %x\n",paceh-&gt;AceSize  )) <br>    ACCESS_ALLOWED_ACE *paaa = (ACCESS_ALLOWED_ACE *)paceh; <br>    printfsid((SID *)&amp;(paaa-&gt;SidStart),&amp;outputoffset); <br>    if (paceh-&gt;AceFlags &amp; OBJECT_INHERIT_ACE      ) <br>    { <br>        outputoffset+= printmessage(stdout, MSG_CACLS_OBJECT_INHERIT, NULL); <br>    } <br>    if (paceh-&gt;AceFlags &amp; CONTAINER_INHERIT_ACE   ) <br>    { <br>        outputoffset+= printmessage(stdout, MSG_CACLS_CONTAINER_INHERIT, NULL); <br>    } <br>    if (paceh-&gt;AceFlags &amp; NO_PROPAGATE_INHERIT_ACE) <br>    { <br>        outputoffset+= printmessage(stdout, MSG_CACLS_NO_PROPAGATE_INHERIT, NULL); <br>    } <br>    if (paceh-&gt;AceFlags &amp; INHERIT_ONLY_ACE        ) <br>    { <br>        outputoffset+= printmessage(stdout, MSG_CACLS_INHERIT_ONLY, NULL); <br>    } <br> <br>    if (paceh-&gt;AceType == ACCESS_DENIED_ACE_TYPE) <br>    { <br>            DISPLAY_MASK((stderr, "(DENIED)")) <br>            VERBOSE((stderr, "(DENIED)")) <br>    } <br> <br>    printfmask(paaa-&gt;Mask, paceh-&gt;AceType, fdir, outputoffset); <br>    fprintf(stdout, "\n"); <br>} <br>//---------------------------------------------------------------------------- <br>// <br>//  Function:     printfmask <br>// <br>//  Synopsis:     prints the access mask <br>// <br>//  Arguments:    IN [mask]    - the access mask <br>//                IN [acetype] -  allowed/denied <br>//                IN [fdir]    - TRUE = directory <br>// <br>//---------------------------------------------------------------------------- <br>CHAR  *aRightsStr[] = { "STANDARD_RIGHTS_ALL", <br>                        "DELETE", <br>                        "READ_CONTROL", <br>                        "WRITE_DAC", <br>                        "WRITE_OWNER", <br>                        "SYNCHRONIZE", <br>                        "STANDARD_RIGHTS_REQUIRED", <br>                        "SPECIFIC_RIGHTS_ALL", <br>                        "ACCESS_SYSTEM_SECURITY", <br>                        "MAXIMUM_ALLOWED", <br>                        "GENERIC_READ", <br>                        "GENERIC_WRITE", <br>                        "GENERIC_EXECUTE", <br>                        "GENERIC_ALL", <br>                        "FILE_GENERIC_READ", <br>                        "FILE_GENERIC_WRITE", <br>                        "FILE_GENERIC_EXECUTE", <br>                        "FILE_READ_DATA", <br>                        //FILE_LIST_DIRECTORY <br>                        "FILE_WRITE_DATA", <br>                        //FILE_ADD_FILE <br>                        "FILE_APPEND_DATA", <br>                        //FILE_ADD_SUBDIRECTORY <br>                        "FILE_READ_EA", <br>                        "FILE_WRITE_EA", <br>                        "FILE_EXECUTE", <br>                        //FILE_TRAVERSE <br>                        "FILE_DELETE_CHILD", <br>                        "FILE_READ_ATTRIBUTES", <br>                        "FILE_WRITE_ATTRIBUTES" }; <br> <br>#define NUMRIGHTS 26 <br>ULONG aRights[NUMRIGHTS] = { STANDARD_RIGHTS_ALL  , <br>                         DELETE                   , <br>                         READ_CONTROL             , <br>                         WRITE_DAC                , <br>                         WRITE_OWNER              , <br>                         SYNCHRONIZE              , <br>                         STANDARD_RIGHTS_REQUIRED , <br>                         SPECIFIC_RIGHTS_ALL      , <br>                         ACCESS_SYSTEM_SECURITY   , <br>                         MAXIMUM_ALLOWED          , <br>                         GENERIC_READ             , <br>                         GENERIC_WRITE            , <br>                         GENERIC_EXECUTE          , <br>                         GENERIC_ALL              , <br>                         FILE_GENERIC_READ        , <br>                         FILE_GENERIC_WRITE       , <br>                         FILE_GENERIC_EXECUTE     , <br>                         FILE_READ_DATA           , <br>                         //FILE_LIST_DIRECTORY    , <br>                         FILE_WRITE_DATA          , <br>                         //FILE_ADD_FILE          , <br>                         FILE_APPEND_DATA         , <br>                         //FILE_ADD_SUBDIRECTORY  , <br>                         FILE_READ_EA             , <br>                         FILE_WRITE_EA            , <br>                         FILE_EXECUTE             , <br>                         //FILE_TRAVERSE          , <br>                         FILE_DELETE_CHILD        , <br>                         FILE_READ_ATTRIBUTES     , <br>                         FILE_WRITE_ATTRIBUTES  }; <br> <br>void printfmask(ULONG mask, UCHAR acetype, BOOL fdir, ULONG outputoffset) <br>{ <br>    ULONG savmask = mask; <br>    VERBOSER((stderr, "mask = %08lx ", mask)) <br>    DISPLAY_MASK((stderr, "mask = %08lx\n", mask)) <br> <br>    VERBOSE((stderr, "    ")) <br> <br>#if DBG <br>    if (!(Debug &amp; (DEBUG_VERBOSE | DEBUG_DISPLAY_MASK))) <br>    { <br>#endif <br>        if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &amp;&amp; <br>                   (mask == (FILE_GENERIC_READ | FILE_EXECUTE))) <br>        { <br>            printmessage(stdout, MSG_CACLS_READ, NULL); <br>        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &amp;&amp; <br>                   (mask == (FILE_GENERIC_WRITE | FILE_GENERIC_READ | FILE_EXECUTE | DELETE))) <br>        { <br>            printmessage(stdout, MSG_CACLS_CHANGE, NULL); <br>        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &amp;&amp; <br>                   (mask == (GENERIC_WRITE | GENERIC_READ | GENERIC_EXECUTE | DELETE))) <br>        { <br>            printmessage(stdout, MSG_CACLS_CHANGE, NULL); <br>        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &amp;&amp; <br>                   (mask ==  ( STANDARD_RIGHTS_ALL | <br>                             FILE_READ_DATA | <br>                             FILE_WRITE_DATA | <br>                             FILE_APPEND_DATA | <br>                             FILE_READ_EA | <br>                             FILE_WRITE_EA | <br>                             FILE_EXECUTE | <br>                             FILE_DELETE_CHILD | <br>                             FILE_READ_ATTRIBUTES | <br>                             FILE_WRITE_ATTRIBUTES )) ) <br>        { <br>            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL); <br>        } else if ((acetype == ACCESS_ALLOWED_ACE_TYPE) &amp;&amp; <br>                   (mask ==  GENERIC_ALL)) <br>        { <br>            printmessage(stdout, MSG_CACLS_FULL_CONTROL, NULL); <br>        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &amp;&amp; <br>                   (mask == GENERIC_ALL)) <br>        { <br>            printmessage(stdout, MSG_CACLS_NONE, NULL); <br>        } else if ((acetype == ACCESS_DENIED_ACE_TYPE) &amp;&amp; <br>                   (mask ==  ( STANDARD_RIGHTS_ALL | <br>                             FILE_READ_DATA | <br>                             FILE_WRITE_DATA | <br>                             FILE_APPEND_DATA | <br>                             FILE_READ_EA | <br>                             FILE_WRITE_EA | <br>                             FILE_EXECUTE | <br>                             FILE_DELETE_CHILD | <br>                             FILE_READ_ATTRIBUTES | <br>                             FILE_WRITE_ATTRIBUTES )) ) <br>        { <br>            printmessage(stdout, MSG_CACLS_NONE, NULL); <br>        } else <br>        { <br>            if (acetype == ACCESS_DENIED_ACE_TYPE) <br>                printmessage(stdout, MSG_CACLS_DENY, NULL); <br> <br>            printmessage(stdout, MSG_CACLS_SPECIAL_ACCESS, NULL); <br> <br>            for (int k = 0; k&lt;NUMRIGHTS ; k++ ) <br>            { <br>                if ((mask &amp; aRights[k]) == aRights[k]) <br>                { <br>                    fprintf(stdout, "%*s%s\n",outputoffset, " ", aRightsStr[k]); <br>                } <br>                if (mask == 0) <br>                    break; <br>            } <br>        } <br>#if DBG <br>    } else <br>    { <br>        if (Debug &amp; (DEBUG_DISPLAY_MASK | DEBUG_VERBOSE)) <br>        { <br>            printf("\n"); <br>            for (int k = 0; k&lt;NUMRIGHTS ; k++ ) <br>            { <br>                if ((mask &amp; aRights[k]) == aRights[k]) <br>                { <br>                    if (mask != savmask) printf(" |\n"); <br>                    printf("    %s",aRightsStr[k]); <br>                    mask &amp;= ~aRights[k]; <br>                } <br>                if (mask == 0) <br>                break; <br>            } <br>        } <br>        VERBOSE((stderr, "=%x",mask)) <br>        if (mask != 0) <br>            DISPLAY((stderr, "=%x/%x",mask,savmask)) <br>    } <br>#endif <br>    fprintf(stdout, " "); <br>} <br>//---------------------------------------------------------------------------- <br>// <br>//  Function:     printmessage <br>// <br>//  Synopsis:     prints a message, either from the local message file, or from the system <br>// <br>//  Arguments:    IN [fp]    - stderr, stdio, etc. <br>//                IN [messageID] - variable argument list <br>// <br>//  Returns:      length of the output buffer <br>// <br>//---------------------------------------------------------------------------- <br>ULONG  printmessage (FILE* fp, DWORD messageID, ...) <br>{ <br>    WCHAR  messagebuffer[4096]; <br>        va_list ap; <br> <br>    va_start(ap, messageID); <br> <br>    if (!FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, messageID, 0, <br>                      messagebuffer, 4095, &amp;ap)) <br>       FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, messageID, 0, <br>                        messagebuffer, 4095, &amp;ap); <br> <br>    fwprintf(fp,  messagebuffer); <br> <br>    va_end(ap); <br>    return(wcslen(messagebuffer)); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
