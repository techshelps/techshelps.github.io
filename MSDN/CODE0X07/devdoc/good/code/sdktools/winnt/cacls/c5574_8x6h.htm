<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILESEC.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5579"></a>FILESEC.CXX</h2>
<pre><code>//+------------------------------------------------------------------ <br>// <br>// Copyright (C) 1995, Microsoft Corporation. <br>// <br>// File:        filesec.cxx <br>// <br>// Classes:     CFileSecurity class encapsulating SECURITY_DESCRIPTOR <br>// <br>// History:     Nov-93      DaveMont         Created. <br>// <br>//------------------------------------------------------------------- <br> <br>#include &lt;filesec.hxx&gt; <br>//+--------------------------------------------------------------------------- <br>// Function:    Add2Ptr <br>// <br>// Synopsis:    Add an unscaled increment to a ptr regardless of type. <br>// <br>// Arguments:   [pv]-- Initial ptr. <br>//              [cb]-- Increment <br>// <br>// Returns:     Incremented ptr. <br>// <br>//---------------------------------------------------------------------------- <br>VOID * Add2Ptr(VOID *pv, ULONG cb) <br>{ <br>    return((BYTE *) pv + cb); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileSecurity::CFileSecurity, public <br>// <br>//  Synopsis:   initializes data members <br>//              constructor will not throw <br>// <br>//  Arguments:  [filename] - name of file to apply security descriptor to <br>// <br>//---------------------------------------------------------------------------- <br>CFileSecurity::CFileSecurity(WCHAR *filename) <br>    : _psd(NULL), <br>      _pwfilename(filename) <br>{ <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileSecurity::Init, public <br>// <br>//  Synopsis:   Init must be called before any other methods - this <br>//              is not enforced.  gets security descriptor from file <br>// <br>//  Arguments:  none <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileSecurity::Init() <br>{ <br>    ULONG ret; <br>    ULONG cpsd; <br> <br>    // get the size of the security buffer <br> <br>    if (!GetFileSecurity(_pwfilename, <br>                         DACL_SECURITY_INFORMATION | <br>                         GROUP_SECURITY_INFORMATION | <br>                         OWNER_SECURITY_INFORMATION, <br>                         NULL, <br>                         0, <br>                         &amp;cpsd) ) <br>    { <br>        if (ERROR_INSUFFICIENT_BUFFER == (ret = GetLastError())) <br>        { <br>            if (NULL == (_psd = (BYTE *)LocalAlloc(LMEM_FIXED, cpsd))) <br>            { <br>                 return(ERROR_NOT_ENOUGH_MEMORY); <br>            } <br> <br>            // actually get the buffer this time <br> <br>            if ( GetFileSecurity(_pwfilename, <br>                                 DACL_SECURITY_INFORMATION | <br>                                 GROUP_SECURITY_INFORMATION | <br>                                 OWNER_SECURITY_INFORMATION, <br>                                 _psd, <br>                                 cpsd, <br>                                 &amp;cpsd) ) <br>                ret = ERROR_SUCCESS; <br>            else <br>                ret = GetLastError(); <br> <br>        } <br>    } else <br>        return(ERROR_NO_SECURITY_ON_OBJECT); <br>    return(ret); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     Dtor, public <br>// <br>//  Synopsis:   frees security descriptor if allocated <br>// <br>//  Arguments:  none <br>// <br>//---------------------------------------------------------------------------- <br>CFileSecurity::~CFileSecurity() <br>{ <br>    if (_psd) <br>    { <br>        LocalFree(_psd); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFileSecurity::SetFS, public <br>// <br>//  Synopsis:   sets or modifies the security descriptor DACL on the specified file <br>// <br>//  Arguments:  IN - [fmodify] - TRUE = modify ACL, FALSE = replace ACL <br>//              IN - [pcdw]    - wrapper around new ACEs <br>//              IN - [fdir]    - TRUE = directory <br>// <br>//  Returns:    status <br>// <br>//---------------------------------------------------------------------------- <br>ULONG CFileSecurity::SetFS(BOOL fmodify, CDaclWrap *pcdw, BOOL fdir) <br>{ <br>   BOOL fdaclpresent; <br>   BOOL cod; <br>   ACL *pdacl; <br>   ULONG ret; <br> <br>   // get the ACL from the security descriptor <br> <br>   if ( GetSecurityDescriptorDacl(_psd, <br>                                  &amp;fdaclpresent, <br>                                  &amp;pdacl, <br>                                  &amp;cod) ) <br> <br>   { <br>       if (fdaclpresent) <br>       { <br>           // build the new ACL (from the new ACEs and the old ACL) <br> <br>           ACL *pnewdacl = NULL; <br> <br>           if (ERROR_SUCCESS == (ret =  pcdw-&gt;BuildAcl(&amp;pnewdacl, fmodify ? pdacl : NULL, pdacl ? pdacl-&gt;AclRevision : ACL_REVISION, fdir))) <br>           { <br>               // make a new security descriptor <br> <br>               SECURITY_DESCRIPTOR newsd; <br>               newsd.Revision = ((SECURITY_DESCRIPTOR*) _psd)-&gt;Revision; <br>               newsd.Sbz1 = 0; <br>               newsd.Control = SE_DACL_PRESENT; <br>               newsd.Owner = _psd + (ULONG)((SECURITY_DESCRIPTOR*)_psd)-&gt;Owner; // convert to absolute <br>               newsd.Group = _psd + (ULONG)((SECURITY_DESCRIPTOR*)_psd)-&gt;Group; // convert to absolute <br>               newsd.Sacl  = (ACL *) (_psd + (ULONG)((SECURITY_DESCRIPTOR*)_psd)-&gt;Sacl); // convert to absolute <br>               newsd.Dacl = pnewdacl; <br> <br>               // apply it to the file <br> <br>               if (!SetFileSecurity(_pwfilename, <br>                                    DACL_SECURITY_INFORMATION, <br>                                    &amp;newsd)) <br>               { <br>                   ret = GetLastError(); <br>               } <br>               LocalFree(pnewdacl); <br>           } <br>       } <br>       else <br>           return(ERROR_NO_SECURITY_ON_OBJECT); <br>    } else <br>    { <br>        ret = GetLastError(); <br>    } <br> <br>    return(ret); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
