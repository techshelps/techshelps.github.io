<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UCONVERT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5752"></a>UCONVERT.C</h2>
<pre><code>/**************************************************************************\ <br>* uconvert.c -- convert to/from unicode using <br>*                MulitByteToWideChar &amp; WideCharToMulitByte <br>* <br>*         Steve Firebaugh <br>*         Microsoft Developer Support <br>*         Copyright 1992 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br>#define UNICODE <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include "uconvert.h" <br>#include "install.h" <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  Global variables. <br>\**************************************************************************/ <br> <br>HANDLE hInst; <br> <br>/* declare global HWNDs for the child windows. <br>*   They are created at WM_CREATE  of the main window. <br>*   Also used in the "View" dialogs. <br>*/ <br>HWND hwndLabel0, hwndLabel1; <br>HWND hwndName0, hwndName1; <br>HWND hwndSize0, hwndSize1; <br>HWND hwndCodePage0, hwndCodePage1; <br>HWND hwndByteOrder0, hwndByteOrder1; <br>HWND hwndButton0, hwndButton1; <br> <br>/* Global variables storing the source and destination "type" information. <br>* <br>* used to communicate between main wnd proc, and *OptionsProc. <br>* <br>* gTypeSource - stores the type interpretation of the source data <br>*       (and implicitly the destination data.) <br>*   TYPEUNKNOWN: indeterminant... not set. Can not do conversion. <br>*   TYPEUNICODE: source unicode &amp; destination giDestinationCodePage. <br>*   TYPECODEPAGE: source giSourceCodePage &amp; destination unicode. <br>* <br>* giSourceCodePage stores valid source code page iff gTypeSource == TRUE <br>* giDestinationCodePage stores valid destination code page iff gTypeSource == FALSE <br>* <br>*/ <br>int gTypeSource; <br>UINT giSourceCodePage; <br>UINT giDestinationCodePage; <br> <br>/* Pointers to the source and destination data, and the <br> *  count of bytes in each of the buffers. <br> */ <br>#define NODATA 0 <br>PBYTE pSourceData =       NULL; <br>PBYTE pDestinationData =  NULL; <br>int   nBytesSource =      NODATA; <br>int   nBytesDestination = NODATA; <br> <br>/* Conversion Options variables. */ <br>DWORD gMBFlags = MB_PRECOMPOSED; <br>DWORD gWCFlags = 0; <br> <br>char  glpDefaultChar[4] = "?"; <br>BOOL  gUsedDefaultChar = FALSE; <br> <br>/* Handling the Byte Order Mark (BOM). <br>* <br>* If the input file begins with a BOM, then we know it is unicode, <br>*  we skip over the BOM and decrement the size of data by SIZEOFBOM. <br>* <br>* <br>* Before writing data that we know is unicode, write the szBOM string <br>*  to the file. <br>* <br>* Notice that this means that the file sizes we show in the window <br>*  do NOT include the BOM. <br>*/ <br> <br>char szBOM[] = "\377\376";  // 0xFF, 0xFE  // leave off TEXT() macro. <br>char szRBOM[] = "\376\377";  // 0xFF, 0xFE  // leave off TEXT() macro. <br>#define SIZEOFBOM 2 <br> <br>/* Title of main window */ <br>TCHAR TitleMBToWC[]= TEXT("UConvert -- MultiByteToWideChar()"); <br>TCHAR TitleWCToMB[]= TEXT("UConvert -- WideCharToMultiByte()"); <br>TCHAR TitleUnknown[]= TEXT("UConvert."); <br> <br>/* file name of the online help file */ <br>TCHAR szHelpPathName[] = TEXT("uconvert.HLP"); <br> <br>/* Strings used to fill onscreen windows. */ <br>TCHAR szBlank[] = TEXT(""); <br> <br>/* MessageBox() strings and flags. */ <br>TCHAR MBTitle[30]= TEXT(""); <br>UINT  MBFlags = MB_OK | MB_ICONEXCLAMATION; <br> <br> <br>/* misc. defines affecting size and placement of child windows */ <br>#define BORDER    GetSystemMetrics (SM_CXFRAME)*4 <br>#define WHEIGHT   GetSystemMetrics (SM_CYMENU) <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  WinMain() <br>* <br>* <br>\**************************************************************************/ <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                     LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG    msg; <br>    WNDCLASS  wc; <br>    HWND   hwndMain; <br>    HACCEL haccel; <br> <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br>    UNREFERENCED_PARAMETER(  nCmdShow ); <br>    hInst = hInstance; <br> <br> <br>    /* Check for previous instance.  If none, then register class. */ <br>    if (!hPrevInstance) { <br> <br>      wc.style = 0; <br>      wc.lpfnWndProc = (WNDPROC)MainWndProc; <br> <br>      wc.cbClsExtra = 0; <br>      wc.cbWndExtra = 0; <br>      wc.hInstance = hInstance; <br>      wc.hIcon = LoadIcon(hInstance, TEXT("uconvertIcon")); <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hbrBackground = GetStockObject (LTGRAY_BRUSH); <br>      wc.lpszMenuName =  TEXT("uconvertMenu"); <br>      wc.lpszClassName = TEXT("uconvert"); <br> <br>      if (!RegisterClass(&amp;wc)) return (FALSE); <br> <br>    }  /* class registered o.k. */ <br> <br> <br>    /* Create the main window.  Return false if CreateWindow() fails */ <br>    hwndMain = CreateWindow( <br>        TEXT("uconvert"), <br>        TitleUnknown, <br>        (WS_OVERLAPPEDWINDOW &amp; ~(WS_THICKFRAME | WS_MAXIMIZEBOX)) | WS_VISIBLE, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        512,  // Big enough for most of the text. <br>        16*WHEIGHT, <br>        NULL, NULL, hInst, NULL); <br> <br>    if (!hwndMain) return (FALSE); <br> <br> <br>    /* Load the accelerator table that provides clipboard support. */ <br>    haccel = LoadAccelerators (hInst, TEXT("uconvertAccel")); <br> <br>    LoadString(hInst,IDS_APP_WARNING,MBTitle,sizeof(MBTitle)); <br> <br>    /* Loop getting messages and dispatching them. */ <br>    while (GetMessage(&amp;msg, NULL, 0,0)) { <br>      if (!TranslateAccelerator(hwndMain, haccel, &amp;msg)) { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>      } <br>    } <br> <br>    return (msg.wParam); <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  MainWndProc() <br>* <br>* <br>* On WM_CREATE create all of the child windows. <br>* On WM_DESTROY make sure that all dynamically allocated memory is freed. <br>* On WM_PAINT, outline many of the child windows. <br>* On WM_COMMAND, respond to the command messages properly. <br>* <br>\**************************************************************************/ <br>LRESULT CALLBACK MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br> <br>/* misc. variables used in multiple messages cases. */ <br>RECT clientrect; <br>RECT rect; <br>TCHAR buffer[50]; <br>static TCHAR szFilter[MAX_PATH]; <br> <br>  switch (message) { <br> <br>    /**********************************************************************\ <br>    *  WM_CREATE <br>    * <br>    * Create all of the child windows used on this main window. <br>    *  Assign the HWNDs to the correct static variables. <br>    * <br>    \**********************************************************************/ <br>    case WM_CREATE: { <br>      GetClientRect (hwnd, &amp;clientrect); <br> <br>      /* Create Source Windows. */ <br>      CopyRect (&amp;rect, &amp;clientrect); <br>      rect.right = (clientrect.right - clientrect.left) /2; <br>      InflateRect (&amp;rect, -2*BORDER, -BORDER); <br>      createwindows(&amp;rect, <br>                   hwnd, <br>                   &amp;hwndLabel0, <br>                   &amp;hwndName0, <br>                   &amp;hwndSize0, <br>                   &amp;hwndCodePage0, <br>                   &amp;hwndByteOrder0, <br>                   &amp;hwndButton0); <br> <br>      /* Create Destination Windows. */ <br>      CopyRect (&amp;rect, &amp;clientrect); <br>      rect.left = (clientrect.right - clientrect.left) /2; <br>      InflateRect (&amp;rect, -2*BORDER, -BORDER); <br>      createwindows(&amp;rect, <br>                   hwnd, <br>                   &amp;hwndLabel1, <br>                   &amp;hwndName1, <br>                   &amp;hwndSize1, <br>                   &amp;hwndCodePage1, <br>                   &amp;hwndByteOrder1, <br>                   &amp;hwndButton1); <br> <br>      /* fill in window information that is different for source/destination */ <br>      SetWindowText (hwndLabel0, LoadResourceString(IDS_SOURCE)); <br>      SetWindowText (hwndLabel1, LoadResourceString(IDS_DESTINATION)); <br> <br>      SetWindowText (hwndButton0, LoadResourceString(IDS_VIEW_SOURCE_BTN)); <br>      SetWindowText (hwndButton1, LoadResourceString(IDS_VIEW_DESTINATION_BTN)); <br> <br>      SetWindowLong (hwndButton0, GWL_ID, BID_VIEWSOURCE      ); <br>      SetWindowLong (hwndButton1, GWL_ID, BID_VIEWDESTINATION ); <br> <br>      gTypeSource = TYPEUNKNOWN; <br>      giSourceCodePage =      GetACP();  // Just some reasonable initializer. <br>      giDestinationCodePage = GetACP();  // Just some reasonable initializer. <br> <br>      /* initialize source &amp; destination data correctly */ <br>      SendMessage (hwnd, WM_COMMAND, MID_CLEARSOURCE,      0); <br>      SendMessage (hwnd, WM_COMMAND, MID_CLEARDESTINATION, 0); <br> <br>      /* Build up the correct filter strings for OPENFILENAME structure <br>       *  Do it here so that we only have to do it once. <br>       */ <br>      { <br>        TCHAR *p; <br> <br>        p = szFilter; <br>        lstrcpy (buffer,LoadResourceString(IDS_FILE_FILTER_SPEC1)); <br>        lstrcpy (p,buffer); <br>        p += lstrlen (buffer) +1; <br>        lstrcpy (buffer,TEXT("*.*")); <br>        lstrcpy (p,buffer); <br>        p += lstrlen (buffer) +1; <br> <br>        lstrcpy (buffer,LoadResourceString(IDS_FILE_FILTER_SPEC2)); <br>        lstrcpy (p,buffer); <br>        p += lstrlen (buffer) +1; <br>        lstrcpy (buffer,TEXT("*.txt")); <br>        lstrcpy (p,buffer); <br>        p += lstrlen (buffer) +1; <br> <br>        lstrcpy (buffer,LoadResourceString(IDS_FILE_FILTER_SPEC3)); <br>        lstrcpy (p,buffer); <br>        p += lstrlen (buffer) +1; <br>        lstrcpy (buffer,TEXT("*.utf")); <br>        lstrcpy (p,buffer); <br>        p += lstrlen (buffer) +1; <br> <br>        lstrcpy (p,TEXT("\0")); <br>      } <br>    } break; /* end WM_CREATE */ <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_DESTROY <br>    * <br>    * Release the Online help, and free allocated memory if any. <br>    \**********************************************************************/ <br>    case WM_DESTROY: <br>      WinHelp( hwnd, szHelpPathName, (UINT) HELP_QUIT, (DWORD) NULL ); <br>      ManageMemory (MMFREE, MMSOURCE,      0, pSourceData); <br>      ManageMemory (MMFREE, MMDESTINATION, 0, pDestinationData); <br>      PostQuitMessage(0); <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_CTLCOLOR* <br>    * <br>    * Set the background of the child controls to be gray here. <br>    \**********************************************************************/ <br>    case WM_CTLCOLORBTN: <br>    case WM_CTLCOLORSTATIC: { <br>      HDC hdc; <br> <br>      hdc = (HDC) wParam; <br>      SetBkMode (hdc, TRANSPARENT); <br>      return (LRESULT)GetStockObject (LTGRAY_BRUSH); <br>    } break; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PAINT <br>    * <br>    * Simply draw the two vertical divider lines, and 3D frame the children. <br>    * <br>    \**********************************************************************/ <br>    case WM_PAINT: { <br>      HDC hdc; <br>      PAINTSTRUCT ps; <br> <br>      hdc = BeginPaint(hwnd, &amp;ps); <br>      GetClientRect (hwnd, &amp;clientrect); <br> <br>      /* draw vertical separator line in the center */ <br>      rect.left = (clientrect.right - clientrect.left ) /2 -1; <br>      rect.top = clientrect.top; <br>      rect.right = rect.left +1;; <br>      rect.bottom = clientrect.bottom; <br>      FrameRect (hdc, &amp;rect, GetStockObject (GRAY_BRUSH)); <br>      SelectObject (hdc, GetStockObject (WHITE_PEN)); <br>      MoveToEx (hdc, rect.right, rect.top, NULL); <br>      LineTo (hdc,rect.right, rect.bottom); <br> <br>      /* draw 3D outlines of child windows. */ <br>      framechildwindow (hdc, hwnd, hwndName0); <br>      framechildwindow (hdc, hwnd, hwndSize0); <br>      framechildwindow (hdc, hwnd, hwndCodePage0); <br>      framechildwindow (hdc, hwnd, hwndByteOrder0); <br> <br>      framechildwindow (hdc, hwnd, hwndName1); <br>      framechildwindow (hdc, hwnd, hwndSize1); <br>      framechildwindow (hdc, hwnd, hwndCodePage1); <br>      framechildwindow (hdc, hwnd, hwndByteOrder1); <br> <br>      /* underline the labels */ <br>      underlinechildwindow (hdc, hwnd, hwndLabel0); <br>      underlinechildwindow (hdc, hwnd, hwndLabel1); <br> <br>      EndPaint (hwnd, &amp;ps); <br>    } break; /* end WM_PAINT */ <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_ADJUSTFORNEWSOURCE <br>    * <br>    * lParam - szName of source (file, clipboard, ...) <br>    * <br>    * global - nBytesSource <br>    * <br>    * "user message."  Set the text of the Source windows <br>    \**********************************************************************/ <br>    case WMU_ADJUSTFORNEWSOURCE: { <br>      LPVOID szName; <br> <br>      szName = (LPVOID) lParam; <br> <br>      /* Set Window text appropriately */ <br>      SetWindowText (hwndName0, szName); <br>      wsprintf (buffer, LoadResourceString(IDS_BYTES), nBytesSource); <br>      SetWindowText (hwndSize0, buffer); <br>      SetWindowText (hwndByteOrder0, szBlank); <br> <br>      /* Clear the destination data if any to avoid user confusion. */ <br>      SendMessage (hwnd, WM_COMMAND, MID_CLEARDESTINATION, 0); <br> <br>      /* Reset the "type strings" based on new gTypeSource. */ <br>      SendMessage (hwnd, WMU_SETTYPESTRINGS, 0,0); <br>    } break; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_SETTYPESTRINGS <br>    * <br>    * "user message."  Set the text of the "type" windows to reflect <br>    *  the state stored in gTypeSource and gi*CodePage. <br>    * <br>    \**********************************************************************/ <br>    case WMU_SETTYPESTRINGS: <br>      switch (gTypeSource) { <br>        case TYPEUNICODE: <br>          SetWindowText (hwndCodePage0, TEXT("Unicode")); <br>          wsprintf (buffer, LoadResourceString(IDS_CODE_PAGE), <br>                  giDestinationCodePage); <br>          SetWindowText (hwndCodePage1, buffer); <br>          SetWindowText (hwnd, TitleWCToMB); <br>        break; <br>        case TYPECODEPAGE: <br>          wsprintf (buffer, LoadResourceString(IDS_CODE_PAGE), <br>                  giSourceCodePage); <br>          SetWindowText (hwndCodePage0, buffer); <br>          SetWindowText (hwndCodePage1, TEXT("Unicode")); <br>          SetWindowText (hwnd, TitleMBToWC); <br>        break; <br>        case TYPEUNKNOWN: <br>          SetWindowText (hwndCodePage0, szBlank); <br>          SetWindowText (hwndCodePage1, szBlank); <br>          SetWindowText (hwnd, TitleUnknown); <br>        break; <br>      } /* end switch gTypeSource */ <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_INITMENU <br>    * <br>    * Manage the enabled state of all of the menus. <br>    *  Notice that the button enabled state is taken care of in ManageMemory(). <br>    * <br>    * In general, this is dependent upon pSourceData &amp; pDestinationData. <br>    *  They are either NULL or non-NULL, and menu items are dependent upon <br>    *  this state. <br>    * <br>    * One exception is the "Paste from Clipboard menu" which is enabled <br>    *  conditional upon there being text data in the clipboard. <br>    * <br>    \**********************************************************************/ <br>    case WM_INITMENU: <br> <br>      /* Adjust the "Paste from Clipboard menu" */ <br>      OpenClipboard (hwnd); <br>      if (IsClipboardFormatAvailable (CF_UNICODETEXT) || <br>          IsClipboardFormatAvailable (CF_OEMTEXT) || <br>          IsClipboardFormatAvailable (CF_TEXT)) <br>        EnableMenuItem (GetMenu (hwnd),MID_PASTESOURCE,      MF_ENABLED); <br>      else <br>        EnableMenuItem (GetMenu (hwnd),MID_PASTESOURCE,      MF_GRAYED); <br>      CloseClipboard (); <br> <br> <br>      /* Adjust the source data dependent menus. */ <br>      if (pSourceData != NULL) { <br>        EnableMenuItem (GetMenu (hwnd),MID_SOURCEOPT,        MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_SWAPSOURCE,       MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CLEARSOURCE,      MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CONVERTNOW,       MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CONVERSIONOPT,    MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_DESTINATIONOPT,   MF_ENABLED); <br>      } else { <br>        EnableMenuItem (GetMenu (hwnd),MID_SOURCEOPT,        MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_SWAPSOURCE,       MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CLEARSOURCE,      MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CONVERTNOW,       MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CONVERSIONOPT,    MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_DESTINATIONOPT,   MF_GRAYED); <br>      } <br> <br> <br>      /* Adjust the destination data dependent menus. */ <br>      if (pDestinationData != NULL) { <br>        EnableMenuItem (GetMenu (hwnd),MID_SAVEAS,           MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_SWAPDESTINATION,  MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_COPYDESTINATION,  MF_ENABLED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CLEARDESTINATION, MF_ENABLED); <br>      } else { <br>        EnableMenuItem (GetMenu (hwnd),MID_SAVEAS,           MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_SWAPDESTINATION,  MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_COPYDESTINATION,  MF_GRAYED); <br>        EnableMenuItem (GetMenu (hwnd),MID_CLEARDESTINATION, MF_GRAYED); <br>      } <br> <br>    break; <br> <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_COMMAND <br>    * <br>    * Just switch() on the command ID.  Notice that menu and button <br>    *  command messages are treated the same. <br>    * <br>    \**********************************************************************/ <br>    case WM_COMMAND: <br>      switch (LOWORD(wParam)) { <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_OPEN <br>        * <br>        * Put up common dialog, try to open &amp; read file. <br>        *  Fill windows with correct text &amp; fill pSourceData. <br>        \******************************************************************/ <br>        case MID_OPEN  : { <br>          HANDLE hFile; <br>          DWORD nBytesRead; <br>          TCHAR szFile[MAX_PATH],szFileTitle[MAX_PATH]; <br> <br>          /* First set up the structure for the GetOpenFileName <br>           *  common dialog. <br>           */ <br>          { <br>            OPENFILENAME OpenFileName; <br>            /* buffers for the file names. */ <br> <br>            wsprintf (szFile, szBlank); <br>            wsprintf (szFileTitle, szBlank); <br> <br> <br>            OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>            OpenFileName.hwndOwner         = hwnd; <br>            OpenFileName.hInstance         = (HANDLE) hInst; <br>            OpenFileName.lpstrFilter       = szFilter; // built in WM_CREATE <br>            OpenFileName.lpstrCustomFilter = NULL; <br>            OpenFileName.nMaxCustFilter    = 0L; <br>            OpenFileName.nFilterIndex      = 1L; <br>            OpenFileName.lpstrFile         = szFile; <br>            OpenFileName.nMaxFile          = MAX_PATH; <br>            OpenFileName.lpstrFileTitle    = szFileTitle; <br>            OpenFileName.nMaxFileTitle     = MAX_PATH; <br>            OpenFileName.lpstrInitialDir   = NULL; <br>            OpenFileName.lpstrTitle        = LoadResourceString(IDS_OPEN_FILE_TITLE); <br> <br>            OpenFileName.nFileOffset       = 0; <br>            OpenFileName.nFileExtension    = 0; <br>            OpenFileName.lpstrDefExt       = NULL; <br> <br>            OpenFileName.lCustData         = 0; <br>            OpenFileName.lpfnHook          = NULL; <br>            OpenFileName.lpTemplateName    = NULL; <br> <br>            OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST; <br> <br>            if (!GetOpenFileName(&amp;OpenFileName)) return 0; <br>          } <br> <br> <br>          /* User has filled in the file information. <br>           *  Try to open that file for reading. <br>           */ <br>          hFile = CreateFile(szFile, <br>                       GENERIC_READ, <br>                       0, <br>                       NULL, <br>                       OPEN_EXISTING, <br>                       FILE_ATTRIBUTE_NORMAL, <br>                       NULL); <br>          if (hFile == INVALID_HANDLE_VALUE) { <br>            MessageBox (hwnd, LoadResourceString(IDS_OPEN_FILE_FAILED), <br>                    MBTitle, MBFlags); <br>            return 0; <br>          } <br> <br> <br>          /* make sure file is not too big... i.e. &gt; 2^32 <br>           *  If it is OK, write the file size in hwndSize0 <br>           */ <br>          { <br>            BY_HANDLE_FILE_INFORMATION bhfi; <br> <br>            GetFileInformationByHandle (hFile, &amp;bhfi); <br>            if (bhfi.nFileSizeHigh != 0) { <br>              MessageBox (hwnd, LoadResourceString(IDS_FILE_TOO_BIG), <br>                      MBTitle, MBFlags); <br>              CloseHandle (hFile); <br>              return 0; <br>            } <br> <br>            nBytesSource= bhfi.nFileSizeLow; <br> <br>          } <br> <br>          /* Allocate space for string, including potential UNICODE_NULL */ <br>          pSourceData = ManageMemory (MMALLOC, MMSOURCE, nBytesSource +2, pSourceData); <br>          if (pSourceData == NULL) { <br>            CloseHandle (hFile); <br>            return 0; <br>          } <br> <br>          if (nBytesSource &lt; SIZEOFBOM) { <br>              gTypeSource = TYPEUNKNOWN; <br>              goto no_bom; <br>          } <br> <br>          /* first read two bytes and look for BOM */ <br>          if (!ReadFile (hFile, pSourceData,SIZEOFBOM, &amp;nBytesRead, NULL)) { <br>            MessageBox (hwnd, LoadResourceString(IDS_READFILE_FAILED), <br>                    MBTitle, MBFlags); <br>            CloseHandle (hFile); <br>            pSourceData = ManageMemory (MMFREE, MMSOURCE, 0, pSourceData); <br>            return 0; <br>          } <br> <br> <br> <br>          /* If file begins with BOM, then we know the type, <br>           *  we'll decrement the number of bytes by two, <br>           *  and read the rest of the data. <br>           */ <br>          if (IsBOM (pSourceData)) { <br>            gTypeSource = TYPEUNICODE; <br>            nBytesSource -=SIZEOFBOM; <br> <br>          /* If file begins with Reverse BOM, then we know the type, <br>           *  we'll decrement the number of bytes by two, <br>           *  and read the rest of the data, and post a message so <br>           *  that we know to swap the order later. <br>           */ <br>          } else if (IsRBOM (pSourceData)) { <br>            gTypeSource = TYPEUNICODE; <br>            nBytesSource -=SIZEOFBOM; <br>            MessageBox (hwnd, LoadResourceString(IDS_SWAPPING_BYTE_ORDER), <br>                    MBTitle, MBFlags); <br>            PostMessage (hwnd, WM_COMMAND, MID_SWAPSOURCE, 0); <br> <br>          /* Oops, does not begin with BOM. <br>           *  Reset file pointer, and read data. <br>           */ <br>          } else { <br>            gTypeSource = TYPEUNKNOWN; <br>            SetFilePointer (hFile, -SIZEOFBOM, NULL, FILE_CURRENT); <br>          } <br> <br>          no_bom: <br> <br> <br>          /* try to read all of it into memory */ <br>          if (!ReadFile (hFile, pSourceData,nBytesSource, &amp;nBytesRead, NULL)) { <br>            MessageBox (hwnd, LoadResourceString(IDS_READFILE_FAILED), <br>                    MBTitle, MBFlags); <br>            CloseHandle (hFile); <br>            pSourceData = ManageMemory (MMFREE, MMSOURCE, 0, pSourceData); <br>            return 0; <br>          } <br> <br>          CloseHandle (hFile); <br> <br>          /* If we don't know the file type at this point, <br>           *  try to determine if it is unicode. <br>           */ <br>          if (gTypeSource == TYPEUNKNOWN) { <br>            if (IsUnicode (pSourceData)) { <br>              gTypeSource = TYPEUNICODE; <br>              pSourceData[nBytesSource]   = 0;  // UNICODE_NULL <br>              pSourceData[nBytesSource+1] = 0; <br>            } else { <br>              gTypeSource = TYPECODEPAGE; <br>              pSourceData[nBytesSource] = 0; <br>            } <br>          } <br> <br>          SendMessage (hwnd, WMU_ADJUSTFORNEWSOURCE, 0, (LPARAM)szFile); <br> <br> <br> <br>        } break;  /* end case MID_OPEN */ <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_SAVEAS <br>        * <br>        * Put up common dialog, try to open file, and write data to it. <br>        \******************************************************************/ <br>        case MID_SAVEAS: { <br>          HANDLE hFile; <br>          DWORD nBytesRead; <br>          TCHAR szFile[MAX_PATH],szFileTitle[MAX_PATH]; <br> <br>          if (nBytesDestination == NODATA ) { <br>            MessageBox (hwnd, LoadResourceString(IDS_NOTEXT_TO_SAVE), <br>                    MBTitle, MBFlags); <br>            return 0; <br>          } <br> <br> <br>          /* Set up the structure for the GetSaveFileName <br>           *  common dialog. <br>           */ <br>          { <br>            OPENFILENAME OpenFileName; <br>            /* buffers for the file names. */ <br> <br>            wsprintf (szFile, szBlank); <br>            wsprintf (szFileTitle, szBlank); <br> <br>            OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>            OpenFileName.hwndOwner         = hwnd; <br>            OpenFileName.hInstance         = (HANDLE) hInst; <br>            OpenFileName.lpstrFilter       = szFilter; <br>            OpenFileName.lpstrCustomFilter = NULL; <br>            OpenFileName.nMaxCustFilter    = 0L; <br>            OpenFileName.nFilterIndex      = 1L; <br>            OpenFileName.lpstrFile         = szFile; <br>            OpenFileName.nMaxFile          = MAX_PATH; <br>            OpenFileName.lpstrFileTitle    = szFileTitle; <br>            OpenFileName.nMaxFileTitle     = MAX_PATH; <br>            OpenFileName.lpstrInitialDir   = NULL; <br>            OpenFileName.lpstrTitle        = LoadResourceString(IDS_SAVE_AS_TITLE); <br> <br>            OpenFileName.nFileOffset       = 0; <br>            OpenFileName.nFileExtension    = 0; <br>            OpenFileName.lpstrDefExt       = NULL; <br> <br>            OpenFileName.lCustData         = 0; <br>            OpenFileName.lpfnHook          = NULL; <br>            OpenFileName.lpTemplateName    = NULL; <br> <br>            OpenFileName.Flags = OFN_HIDEREADONLY; <br> <br>            if (!GetSaveFileName(&amp;OpenFileName)) return 0; <br>          } <br> <br> <br>          /* User has filled in the file information. <br>           *  Try to open that file for writing. <br>           */ <br>          hFile = CreateFile(szFile, <br>                      GENERIC_WRITE, <br>                      0, <br>                      NULL, <br>                      CREATE_ALWAYS, <br>                      FILE_ATTRIBUTE_NORMAL, <br>                      NULL); <br> <br>          if (hFile == INVALID_HANDLE_VALUE) { <br>            MessageBox (hwnd, LoadResourceString(IDS_CREATEFILE_FAILED), <br>                    MBTitle, MBFlags); <br>            return 0; <br>          } <br> <br> <br>          /* if destination is unicode, try to write BOM first. <br>           *  unless the bytes have been swapped <br>           *  (criterion: hwndByteOrder contains text) <br>           *  in which case, write a Reverse Byte Order Mark. <br>           */ <br>          if (gTypeSource == TYPECODEPAGE) { <br>            if (GetWindowTextLength (hwndByteOrder1) == 0) { <br> <br>              if (!WriteFile (hFile, szBOM, SIZEOFBOM, &amp;nBytesRead, NULL)) { <br>                MessageBox (hwnd, LoadResourceString(IDS_WRITEFILE_FAILED), <br>                        MBTitle, MBFlags); <br>                CloseHandle (hFile); <br>                return 0; <br>              } <br> <br>            }else { <br>              if (!WriteFile (hFile, szRBOM, SIZEOFBOM, &amp;nBytesRead, NULL)) { <br>                MessageBox (hwnd, LoadResourceString(IDS_WRITEFILE_FAILED), <br>                        MBTitle, MBFlags); <br>                CloseHandle (hFile); <br>                return 0; <br>              } <br> <br>            } <br>          } <br> <br> <br>          /* try to write all of it into memory */ <br>          if (!WriteFile (hFile, pDestinationData,nBytesDestination, &amp;nBytesRead, NULL)) { <br>            MessageBox (hwnd, LoadResourceString(IDS_WRITEFILE_FAILED), <br>                    MBTitle, MBFlags); <br>            CloseHandle (hFile); <br>            return 0; <br>          } <br> <br>          SetWindowText (hwndName1, szFile); <br>          CloseHandle (hFile); <br> <br>        } break; <br> <br> <br>        /**********************************************************************\ <br>        *  WM_COMMAND, MID_PASTESOURCE <br>        * <br>        * Paste the clipboard's prefered data format into the source. <br>        *  Fills pSourceData. <br>        \**********************************************************************/ <br>        case MID_PASTESOURCE: { <br>          UINT  iFormat; <br>          PVOID pData; <br> <br>          OpenClipboard (hwnd); <br> <br>          iFormat = 0; <br>          while (iFormat = EnumClipboardFormats(iFormat)) <br>            if ((iFormat == CF_UNICODETEXT) || (iFormat == CF_OEMTEXT) || (iFormat == CF_TEXT)) { <br> <br>              HGLOBAL hMem; <br> <br>              hMem = GetClipboardData (iFormat); <br>              pData = GlobalLock(hMem); <br> <br>              switch (iFormat) { <br>                case CF_UNICODETEXT: <br>                  nBytesSource = lstrlenW (pData) *2; <br>                  pSourceData= ManageMemory (MMALLOC, MMSOURCE, nBytesSource+2, pSourceData); <br>                  lstrcpyW ((LPVOID)pSourceData, pData); <br>                  gTypeSource = TYPEUNICODE; <br>                break; <br> <br>                case CF_OEMTEXT: <br>                  nBytesSource = lstrlenA (pData); <br>                  pSourceData= ManageMemory (MMALLOC, MMSOURCE, nBytesSource+1, pSourceData); <br>                  lstrcpyA (pSourceData, pData); <br>                  gTypeSource = TYPECODEPAGE; <br>                  giSourceCodePage = GetOEMCP(); <br>                break; <br> <br>                case CF_TEXT: <br>                  nBytesSource = lstrlenA (pData); <br>                  pSourceData= ManageMemory (MMALLOC, MMSOURCE, nBytesSource+1, pSourceData); <br>                  lstrcpyA (pSourceData, pData); <br>                  gTypeSource = TYPECODEPAGE; <br>                  giSourceCodePage = GetACP(); <br>                break; <br> <br>                default: break;  // shouldn't get here <br>              } /* end switch (iFormat) */ <br> <br>              SendMessage (hwnd, WMU_ADJUSTFORNEWSOURCE, 0, </code></pre>
<p>
</p>
<pre><code>(LPARAM)LoadResourceString(IDS_FROM_CLIPBOARD)); <br> <br>              GlobalUnlock(hMem); <br>            break;  /* break out of while loop. */ <br>            } /* end if iFormat */ <br> <br> <br>          CloseClipboard (); <br> <br>        } break; <br> <br> <br> <br>        /**********************************************************************\ <br>        *  WM_COMMAND, MID_COPYDESTINATION <br>        * <br>        * Copy destination data to the clipboard. <br>        \**********************************************************************/ <br>        case MID_COPYDESTINATION: <br>        { <br>          HGLOBAL hMem; <br>          if (pDestinationData == NULL) return FALSE; <br> <br>          if (gTypeSource != TYPEUNICODE) { <br>              if (!(hMem = GlobalAlloc( <br>                      GMEM_MOVEABLE | GMEM_DDESHARE, <br>                      (lstrlenW((LPWSTR)pDestinationData)+1) * 2))) { <br>                  return FALSE; <br>              } <br>              lstrcpyW(GlobalLock(hMem), (LPWSTR)pDestinationData); <br>              GlobalUnlock(hMem); <br>          } else { <br>              if (!(hMem = GlobalAlloc( <br>                      GMEM_MOVEABLE | GMEM_DDESHARE, <br>                      lstrlenA(pDestinationData)+1))) { <br>                  return FALSE; <br>              } <br>              lstrcpyA(GlobalLock(hMem), pDestinationData); <br>              GlobalUnlock(hMem); <br>          } <br> <br>          OpenClipboard (hwnd); <br>          EmptyClipboard(); <br> <br>          /* if source NOT unicode, then destination is, else look at dest CP */ <br>          if (gTypeSource != TYPEUNICODE) <br>            SetClipboardData (CF_UNICODETEXT, hMem); <br>          else if (giDestinationCodePage == GetOEMCP()) <br>            SetClipboardData (CF_OEMTEXT, hMem); <br>          else <br>            SetClipboardData (CF_TEXT, hMem); <br> <br> <br>          CloseClipboard (); <br> <br>        break; <br>        } <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_CONVERTNOW <br>        * <br>        * This is where the conversion actually takes place. <br>        *  In either case, make the call twice.  Once to determine how <br>        *  much memory is needed, allocate space, and then make the call again. <br>        * <br>        *  If conversion succeeds, it fills pDestinationData. <br>        \******************************************************************/ <br>        case MID_CONVERTNOW: { <br>          int nBytesNeeded, nWCharNeeded, nWCharSource; <br> <br> <br>          if (nBytesSource == NODATA ) { <br>            MessageBox (hwnd, LoadResourceString(IDS_LOAD_SOURCE_FILE), <br>                    MBTitle, MBFlags); <br>            return 0; <br>          } <br> <br> <br>          /* Converting UNICODE -&gt; giDestinationCodePage*/ <br>          if (gTypeSource == TYPEUNICODE) { <br> <br>            nWCharSource = nBytesSource/2; <br> <br>            /* Query the number of bytes required to store the Dest string */ <br>            nBytesNeeded = WideCharToMultiByte(giDestinationCodePage, gWCFlags, <br>                             (LPWSTR)pSourceData, nWCharSource, <br>                             NULL, 0, <br>                             glpDefaultChar, &amp;gUsedDefaultChar); <br> <br>            /* Allocate the required amount of space */ <br> <br>            if (nBytesNeeded == 0) { <br>                MessageBox (hwnd, LoadResourceString(IDS_FIRSTCALL_FAILED), <br>                        MBTitle, MBFlags); <br>                break; <br>            } <br> <br>            /* We need more 1 byte for '\0' */ <br>            pDestinationData= ManageMemory (MMALLOC, MMDESTINATION, nBytesNeeded + 2, pDestinationData); <br> <br>            /* Do the conversion */ <br>            nBytesDestination = WideCharToMultiByte(giDestinationCodePage, gWCFlags, <br>                             (LPWSTR)pSourceData, nWCharSource, <br>                             pDestinationData, nBytesNeeded, glpDefaultChar, &amp;gUsedDefaultChar); <br>            if (nBytesNeeded == 0) { <br>                MessageBox (hwnd, LoadResourceString(IDS_FIRSTCALL_FAILED), <br>                        MBTitle, MBFlags); <br>                break; <br>            } <br>            *(LPSTR)((LPSTR)pDestinationData + nBytesNeeded) = '\0'; <br>          } <br> <br> <br>          /* converting giSourceCodePage -&gt; UNICODE */ <br>          else if (gTypeSource == TYPECODEPAGE) { <br> <br>            /* Query the number of WChar required to store the Dest string */ <br>            nWCharNeeded = MultiByteToWideChar(giSourceCodePage, gMBFlags, <br>                             pSourceData, nBytesSource, NULL, 0 ); <br> <br>            /* Allocate the required amount of space */ <br> <br>            /* We need more 2 bytes for '\0' */ <br>            pDestinationData= ManageMemory (MMALLOC, MMDESTINATION, (nWCharNeeded+1)*2, pDestinationData); <br> <br>            /* Do the conversion */ <br>            nWCharNeeded = MultiByteToWideChar(giSourceCodePage, gMBFlags, <br>                             pSourceData, nBytesSource, <br>                             (LPWSTR)pDestinationData, nWCharNeeded); <br> <br>            *(LPWSTR)((LPWSTR)pDestinationData + nWCharNeeded) = L'\0'; <br> <br>            /* MultiByteToWideChar returns # WCHAR, so multiply by 2 */ <br>            nBytesDestination = 2*nWCharNeeded ; <br>          } else { <br>            MessageBox (hwnd, LoadResourceString(IDS_SOURCE_TYPE_UNKNOWN), <br>                    MBTitle, MBFlags); <br>            return 0; <br>          } <br> <br> <br>          /* code common to all conversions... */ <br>          SetWindowText (hwndName1, LoadResourceString(IDS_DATA_NOT_SAVED)); <br>          wsprintf (buffer, LoadResourceString(IDS_BYTES), nBytesDestination); <br>          SetWindowText (hwndSize1, buffer); <br>          SetWindowText (hwndByteOrder1, szBlank); <br> <br> <br>          /* Throw up "Save as" dialog to help the user along. <br>           *  They can always &lt;esc&gt; if need be. <br>           */ <br>          SendMessage (hwnd, WM_COMMAND, MID_SAVEAS, 0); <br> <br>        } break; /* end  case BID_CONVERT */ <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, BID_VIEWSOURCE <br>        * <br>        \******************************************************************/ <br>        case BID_VIEWSOURCE: <br>          if (gTypeSource == TYPEUNICODE) <br>            DialogBoxW (hInst, L"ShowTextDlg", hwnd, (DLGPROC)ViewSourceProc); <br>          else <br>            DialogBoxA (hInst, "ShowTextDlg", hwnd, (DLGPROC)ViewSourceProc); <br>        break; <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, BID_VIEWDESTINATION <br>        * <br>        \******************************************************************/ <br>        case BID_VIEWDESTINATION: <br>          if (gTypeSource == TYPEUNICODE) <br>            DialogBoxA (hInst, "ShowTextDlg", hwnd, (DLGPROC)ViewDestinationProc); <br>          else <br>            DialogBoxW (hInst, L"ShowTextDlg", hwnd, (DLGPROC)ViewDestinationProc); <br>        break; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_SOURCEOPT <br>        * <br>        * Allows user to change interpretation options for the source data. <br>        * <br>        *  Put up appropriate dialog box, and reset window text in response. <br>        \******************************************************************/ <br>        case MID_SOURCEOPT: <br>          if (DialogBox (hInst, TEXT("DataOptionsDlg"), hwnd, (DLGPROC)SourceOptionsProc)) { <br>            SendMessage (hwnd, WMU_SETTYPESTRINGS, 0,0); <br>            SendMessage (hwnd, WM_COMMAND, MID_CLEARDESTINATION, 0); <br>          } <br>        break; <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_DESTINATIONOPT <br>        * <br>        * Allows user to change options for destination data. <br>        * <br>        *  Put up appropriate dialog box, and reset window text in response. <br>        \******************************************************************/ <br>        case MID_DESTINATIONOPT: <br>          if (DialogBox (hInst, TEXT("DataOptionsDlg"), hwnd, (DLGPROC)DestinationOptionsProc)) { <br>            SendMessage (hwnd, WMU_SETTYPESTRINGS, 0,0); <br>            SendMessage (hwnd, WM_COMMAND, MID_CLEARDESTINATION, 0); <br>          } <br>        break; <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_CONVERSIONOPT <br>        * <br>        \******************************************************************/ <br>        case MID_CONVERSIONOPT: <br>          if (DialogBox (hInst, TEXT("ConversionOptionsDlg"), hwnd, (DLGPROC)ConversionOptionsProc)) { <br>            SendMessage (hwnd, WM_COMMAND, MID_CLEARDESTINATION, 0); <br>          } <br>        break; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_SWAPSOURCE <br>        * <br>        * Allows user to reverse byte order of data. <br>        * <br>        \******************************************************************/ <br>        case MID_SWAPSOURCE: { <br>          int i, end; <br>          BYTE temp; <br> <br>          if (pSourceData == NULL) return FALSE; <br> <br>          end =  nBytesSource - 2; <br>          for (i = 0; i&lt;= end; i+=2) { <br>            temp             = pSourceData[i]; <br>            pSourceData[i]   = pSourceData[i+1]; <br>            pSourceData[i+1] = temp; <br>          } <br> <br>          if (GetWindowTextLength (hwndByteOrder0) == 0) <br>            SetWindowText (hwndByteOrder0, <br>                    LoadResourceString(IDS_BYTE_ORDER_REVERSED)); <br>          else <br>            SetWindowText (hwndByteOrder0, szBlank); <br> <br>          /* Since source is different, invalidate Destination data. */ <br>          SendMessage (hwnd, WM_COMMAND, MID_CLEARDESTINATION, 0); <br> <br>        } break; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_SWAPDESTINATION <br>        * <br>        * Allows user to reverse byte order of data. <br>        * <br>        \******************************************************************/ <br>        case MID_SWAPDESTINATION: { <br>          int i, end; <br>          BYTE temp; <br> <br>          if (pDestinationData == NULL) return FALSE; <br> <br>          end =  nBytesDestination - 2; <br>          for (i = 0; i&lt;= end; i+=2) { <br>            temp             = pDestinationData[i]; <br>            pDestinationData[i]   = pDestinationData[i+1]; <br>            pDestinationData[i+1] = temp; <br>          } <br> <br>          if (GetWindowTextLength (hwndByteOrder1) == 0) <br>            SetWindowText (hwndByteOrder1, <br>                    LoadResourceString(IDS_BYTE_ORDER_REVERSED)); <br>          else <br>            SetWindowText (hwndByteOrder1, szBlank); <br> <br>        } break; <br> <br> <br>        /**********************************************************************\ <br>        *  WM_COMMAND, MID_CLEARDESTINATION <br>        * <br>        * Clear the destination information.  May cause data to be lost. <br>        \**********************************************************************/ <br>        case MID_CLEARDESTINATION: <br>          SetWindowText (hwndSize1, szBlank); <br>          SetWindowText (hwndName1, szBlank); <br>          SetWindowText (hwndByteOrder1, szBlank); <br>          pDestinationData= ManageMemory (MMFREE, MMDESTINATION, 0, pDestinationData); <br>        break; <br> <br> <br>        /**********************************************************************\ <br>        *  WM_COMMAND, MID_CLEARSOURCE <br>        * <br>        * Clear the SOURCE information.  May cause data to be lost. <br>        \**********************************************************************/ <br>        case MID_CLEARSOURCE: <br>          SetWindowText (hwndSize0, szBlank); <br>          SetWindowText (hwndName0, szBlank); <br>          SetWindowText (hwndByteOrder0, szBlank); <br>          pSourceData= ManageMemory (MMFREE, MMSOURCE, 0, pSourceData); <br>        break; <br> <br> <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, MID_INSTALLTABLES <br>        * <br>        \******************************************************************/ <br>        case MID_INSTALLTABLES: <br>          DialogBox (hInst, TEXT("InstallTableDlg"), hwnd, (DLGPROC)InstallTableProc); <br>        break; <br> <br> <br> <br> <br>        /* Simply call WinHelp to display the OnLine help file. */ <br>        case MID_HELP: <br>          WinHelp( hwnd, szHelpPathName, HELP_INDEX, (DWORD) NULL ); <br>        break; <br> <br> <br>        /* No-op Window procedure to simply display the dialog box. */ <br>        case MID_ABOUT: <br>          ShellAbout (hwnd, TEXT("UConvert"), NULL, LoadIcon (hInst, TEXT("uconvertIcon"))); <br>        break; <br> <br>        /* Just close the window. */ <br>        case MID_EXIT: <br>          PostMessage (hwnd, WM_CLOSE, 0,0); <br>        break; <br> <br> <br> <br> <br>      } /* end switch (LOWORD(wParam)) */ <br>    break;  /* end WM_COMMAND */ <br> <br> <br> <br>    default: break; <br>  } /* end switch */ <br> <br>  return (DefWindowProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  IsUnicode() <br>* <br>* HACK... eventually use a proper function for IsUnicode <br>*  Use function from unipad? <br>* <br>\**************************************************************************/ <br>BOOL IsUnicode (PBYTE pb) <br>{ <br>  return (IsBOM (pb)); <br>} <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  IsBOM() <br>* <br>* true iff pb points to a Byte Order Mark. <br>* <br>\**************************************************************************/ <br>BOOL IsBOM (PBYTE pb) <br>{ <br>  if ((*pb == 0xFF) &amp; (*(pb+1) == 0xFE))  // BOM <br>    return TRUE; <br>  else <br>    return FALSE; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  IsRBOM() <br>* <br>* true iff pb points to a reversed Byte Order Mark. <br>* <br>\**************************************************************************/ <br>BOOL IsRBOM (PBYTE pb) <br>{ <br>  if ((*pb == 0xFE) &amp; (*(pb+1) == 0xFF))  // RBOM <br>    return TRUE; <br>  else <br>    return FALSE; <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  framechildwindow() <br>* <br>* Simply draw a 3D frame around child window. <br>* <br>\**************************************************************************/ <br>VOID framechildwindow (HDC hdc, HWND hwndParent, HWND hwndChild) <br>{ <br>RECT rect; <br> <br>      GetWindowRect (hwndChild, &amp;rect); <br> <br>      /* minor hack... assumes RECT is two points, right field starting first */ <br>      ScreenToClient (hwndParent, (LPPOINT)&amp;rect); <br>      ScreenToClient (hwndParent, (LPPOINT)&amp;(rect.right)); <br> <br>      InflateRect (&amp;rect, 1, 1); <br>      FrameRect (hdc, &amp;rect, GetStockObject (GRAY_BRUSH)); <br>      InflateRect (&amp;rect, -1, -1); <br>      SelectObject (hdc, GetStockObject (WHITE_PEN)); <br>      MoveToEx (hdc, rect.right, rect.top, NULL); <br>      LineTo (hdc,rect.right, rect.bottom); <br>      LineTo (hdc,rect.left, rect.bottom); <br> <br>    return; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  underlinechildwindow() <br>* <br>* Underline child window. <br>* <br>\**************************************************************************/ <br>VOID underlinechildwindow (HDC hdc, HWND hwndParent, HWND hwndChild) <br>{ <br>RECT rect; <br> <br>      GetWindowRect (hwndChild, &amp;rect); <br> <br>      /* minor hack... assumes RECT is two points, right field starting first */ <br>      ScreenToClient (hwndParent, (LPPOINT)&amp;rect); <br>      ScreenToClient (hwndParent, (LPPOINT)&amp;(rect.right)); <br> <br>      InflateRect (&amp;rect, 1, 1); <br>      rect.top = rect.bottom-1; <br>      FrameRect (hdc, &amp;rect, GetStockObject (GRAY_BRUSH)); <br>      SelectObject (hdc, GetStockObject (WHITE_PEN)); <br>      MoveToEx (hdc, rect.right, rect.bottom, NULL); <br>      LineTo (hdc,rect.left, rect.bottom); <br> <br>    return; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  createwindows() <br>* <br>* Create the child windows and pass the handles back in parameters. <br>*  Each Window is created relative to (inside of) prect. <br>*  top is a spacial pointer to the Y coordinate of the next window. <br>* <br>\**************************************************************************/ <br>VOID createwindows(PRECT prect, <br>                   HWND  hwndParent, <br>                   HWND* hwndLabel, <br>                   HWND* hwndName, <br>                   HWND* hwndSize, <br>                   HWND* hwndCodePage, <br>                   HWND* hwndByteOrder, <br>                   HWND* hwndButton) <br>{ <br>int top; <br> <br>  top = prect-&gt;top; <br>  *hwndLabel = CreateWindow( <br>          TEXT("STATIC"), <br>          szBlank, <br>          WS_CHILD | WS_VISIBLE | SS_CENTER, <br>          prect-&gt;left, <br>          top, <br>          prect-&gt;right - prect-&gt;left, <br>          WHEIGHT, <br>          hwndParent, NULL, hInst, 0); <br> <br>  top += WHEIGHT*5/2; <br>  *hwndName = CreateWindow( <br>          TEXT("STATIC"), <br>          szBlank, <br>          WS_CHILD | WS_VISIBLE | SS_RIGHT, <br>          prect-&gt;left, <br>          top, <br>          prect-&gt;right - prect-&gt;left, <br>          WHEIGHT, <br>          hwndParent, NULL, hInst, 0); <br> <br>  top += WHEIGHT*2; <br>  *hwndSize = CreateWindow( <br>          TEXT("STATIC"), <br>          szBlank, <br>          WS_CHILD | WS_VISIBLE | SS_LEFT, <br>          prect-&gt;left, <br>          top, <br>          (prect-&gt;right - prect-&gt;left) *3/4, <br>          WHEIGHT, <br>          hwndParent, NULL, hInst, 0); <br> <br>  top += WHEIGHT*2; <br>  *hwndCodePage = CreateWindow( <br>          TEXT("STATIC"), <br>          szBlank, <br>          WS_CHILD | WS_VISIBLE | SS_LEFT, <br>          prect-&gt;left, <br>          top, <br>          (prect-&gt;right - prect-&gt;left) *3/4, <br>          WHEIGHT, <br>          hwndParent, NULL, hInst, 0); <br> <br>  top += WHEIGHT*2; <br>  *hwndByteOrder = CreateWindow( <br>          TEXT("STATIC"), <br>          szBlank, <br>          WS_CHILD | WS_VISIBLE | SS_LEFT, <br>          prect-&gt;left, <br>          top, <br>          (prect-&gt;right - prect-&gt;left) *3/4, <br>          WHEIGHT, <br>          hwndParent, NULL, hInst, 0); <br> <br>  top += WHEIGHT*2; <br>  *hwndButton = CreateWindow( <br>          TEXT("BUTTON"), <br>          TEXT("ViewText"), <br>          WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <br>          prect-&gt;left, <br>          top, <br>          prect-&gt;right - prect-&gt;left, <br>          WHEIGHT*9/7, <br>          hwndParent, NULL, hInst, 0); <br> <br>  return; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  ManageMemory() <br>* <br>* Do all memory management here for the source and destination pointers. <br>*  We also enable/disable the "View..." buttons to reflect existence of data. <br>* <br>* <br>* PARAMETERS <br>* <br>*  message : {MMALLOC, MMFREE} <br>*    Alloc when requested by MMALLOC, and free the existing, passed in, pointer. <br>*    Free when requested by MMFREE. <br>*  sourcedestination : {MMSOURCE, MMDESTINATION} <br>*  nBytes - number to alloc on MMALLOC messages. <br>*  p - old pointer to be freed. <br>* <br>* <br>* GLOBALS <br>* <br>*  hwndButton0, hwndButton1 <br>* <br>\**************************************************************************/ <br>LPVOID ManageMemory (UINT message, UINT sourcedestination, DWORD nBytes, LPVOID p) <br>{ <br>  switch (message) { <br>    case MMFREE : <br>      if (sourcedestination == MMSOURCE) <br>        EnableWindow (hwndButton0, FALSE); <br>      else if (sourcedestination == MMDESTINATION) <br>        EnableWindow (hwndButton1, FALSE); <br> <br>      if (p != NULL) GlobalFree (GlobalHandle (p)); <br>      return NULL; <br>    break; <br> <br>    case MMALLOC : <br>      if (sourcedestination == MMSOURCE) <br>        EnableWindow (hwndButton0, TRUE); <br>      else if (sourcedestination == MMDESTINATION) <br>        EnableWindow (hwndButton1, TRUE); <br> <br>      if (p != NULL) GlobalFree (GlobalHandle (p)); <br>      p = (LPVOID) GlobalAlloc (GPTR, nBytes); <br>      return p; <br>    break; <br> <br>  } /* end switch (message) */ <br>  return NULL; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  LoadResourceString() <br>* <br>*  Loads a resource string from string table and returns a pointer <br>*  to the string. <br>* <br>*  PARAMETERS: wID - resource string id <br>* <br>\**************************************************************************/ <br>LPTSTR LoadResourceString(UINT wID) <br>{ <br>    static TCHAR szBuf[512]; <br> <br>    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf)); <br>    return szBuf; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
