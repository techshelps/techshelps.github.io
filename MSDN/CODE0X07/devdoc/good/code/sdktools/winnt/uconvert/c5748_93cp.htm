<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INSTALL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5749"></a>INSTALL.C</h2>
<pre><code>/**************************************************************************\ <br>* install.c -- install c_*.nls conversion tables. <br>* <br>*         Steve Firebaugh <br>*         Microsoft Developer Support <br>*         Copyright 1992 - 1998 Microsoft Corporation <br>* <br>* <br>* <br>* Note, this module must have UNICODE defined because the registry <br>*  code will not work without it. <br>* <br>\**************************************************************************/ <br>#define UNICODE <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "uconvert.h" <br>#include "install.h" <br> <br>/**************************************************************************\ <br>*  Global variables. <br>\**************************************************************************/ <br> <br>/* This is the registry key that we store conversion table information under. */ <br>TCHAR NlsRegEntryStr[]=TEXT("SYSTEM\\CurrentControlSet\\Control\\Nls\\CodePage"); <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: InstallTableProc <br>* <br>* Dialog window procedure for the Install *.nls tables dialog. <br>* <br>\***************************************************************************/ <br>LRESULT CALLBACK InstallTableProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br> <br>  switch (message) { <br> <br>    /**********************************************************************\ <br>    *  WM_INITDIALOG <br>    * <br>    * Fill dialog with a list of the currently existing tables. <br>    \**********************************************************************/ <br>    case WM_INITDIALOG: <br>      if (!ListInstalledTables (GetDlgItem (hwnd, DID_LISTBOX), LB_ADDSTRING, FALSE)) <br>        EndDialog (hwnd, FALSE); <br>        return TRUE; <br>    break; <br> <br>    case WM_COMMAND: <br>      switch (wParam) { <br>        case IDCANCEL: <br>        case IDOK: <br>          EndDialog (hwnd, TRUE); <br>        break; <br> <br> <br>        /**********************************************************************\ <br>        *  WM_COMMAND, BID_ADD <br>        * <br>        * Use common dialog, get new *.nls name, and try to install it. <br>        \**********************************************************************/ <br>        case BID_ADD: <br>          if (GetTableFileNames(hwnd)) <br>            ListInstalledTables (GetDlgItem (hwnd, DID_LISTBOX), LB_ADDSTRING, FALSE); <br>        break; <br>      } <br>    break; /* end WM_COMMAND */ <br> <br> <br>    case WM_SYSCOMMAND: <br>      if (wParam == SC_CLOSE) <br>        EndDialog (hwnd, TRUE); <br>    break; /* end WM_SYSCOMMAND */ <br> <br> <br>  } /* end switch */ <br>  return FALSE; <br>} <br> <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: GetTableFileNames <br>* <br>* Throw up a common dialog to the user, and let them search for the *.nls <br>*  file to install. <br>* <br>* LIMITATION:  Currently only works for one file at a time. <br>*  Should rewrite to accept multiple files. <br>* <br>\***************************************************************************/ <br>int GetTableFileNames (HWND hwnd) <br>{ <br>    OPENFILENAME OpenFileName; <br> <br> <br>    /* buffers for the file names. */ <br>    TCHAR szFile[MAX_PATH],szFileTitle[MAX_PATH]; <br>    TCHAR szFilter[MAX_PATH], buffer[50]; <br>    TCHAR *p; <br> <br>    /* Build up the correct filter strings for OPENFILENAME structure */ <br> <br>    p = szFilter; <br>    lstrcpy (buffer,LoadResourceString(IDS_FILE_FILTER_SPEC4)); <br>    lstrcpy (p,buffer); <br>    p += lstrlen (buffer) +1; <br>    lstrcpy (buffer,TEXT("*.nls")); <br>    lstrcpy (p,buffer); <br>    p += lstrlen (buffer) +1; <br> <br>    lstrcpy (p,TEXT("\0")); <br> <br> <br>    wsprintf (szFile, TEXT("")); <br>    wsprintf (szFileTitle, TEXT("")); <br> <br>    OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = hwnd; <br>    OpenFileName.hInstance         = NULL; <br>    OpenFileName.lpstrFilter       = szFilter; <br>    OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nMaxCustFilter    = 0L; <br>    OpenFileName.nFilterIndex      = 1L; <br>    OpenFileName.lpstrFile         = szFile; <br>    OpenFileName.nMaxFile          = MAX_PATH; <br>    OpenFileName.lpstrFileTitle    = szFileTitle; <br>    OpenFileName.nMaxFileTitle     = MAX_PATH; <br>    OpenFileName.lpstrInitialDir   = NULL; <br>    OpenFileName.lpstrTitle        = LoadResourceString(IDS_TABLE_FILE_TITLE); <br> <br>    OpenFileName.nFileOffset       = 0; <br>    OpenFileName.nFileExtension    = 0; <br>    OpenFileName.lpstrDefExt       = NULL; <br> <br>    OpenFileName.lCustData         = 0; <br>    OpenFileName.lpfnHook          = NULL; <br>    OpenFileName.lpTemplateName    = NULL; <br> <br>//    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_ALLOWMULTISELECT; <br>    OpenFileName.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST ; <br> <br>    if (!GetOpenFileName(&amp;OpenFileName)) return 0; <br> <br> <br>    return (InstallFile (szFile,szFileTitle)); <br>} <br> <br> <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: InstallFile <br>* <br>* Given full path name, and just file name, copy that file into the <br>*  system directory, and change the registry to indicate that the file <br>*  has now been "installed." <br>* <br>\***************************************************************************/ <br>int InstallFile (TCHAR* szPathAndName, TCHAR* szName) <br>{ <br>TCHAR szTargetFile[MAX_PATH], buffer[MAX_PATH]; <br>TCHAR keyname[MAX_PATH]; <br>HKEY hKey; <br>int cp, nChar; <br>LONG rValue; <br> <br>    /* First verify that they have selected a valid file name. */ <br>    CharLowerBuff (szName,lstrlen (szName)); <br>    if (myScanf (szName, &amp;cp) != 1) { <br>      MessageBox (NULL, LoadResourceString(IDS_INCORRECT_FILE_TYPE), <br>                        NULL, MB_ICONSTOP | MB_OK); <br>      return FALSE; <br>    } <br> <br> <br> <br> <br>    /* Build up a complete path name for the target file. <br>     *  Get the system directory, and prepend it before szName. <br>     */ <br>    GetSystemDirectory (buffer, MAX_PATH); <br>    nChar = wsprintf (szTargetFile, TEXT("%s\\%s"), buffer, szName); <br> <br>    if (nChar &gt;= MAX_PATH) { <br>      MessageBox (NULL, LoadResourceString(IDS_FILENAME_OVERFLOW),NULL, MB_ICONSTOP | MB_OK); <br>      return FALSE; <br>    } <br> <br> <br> <br>    /* Now, try to open the registry for writing... This may fail if <br>     *  the current user has insufficient privilege, or it may fail <br>     *  for other, unforeseen, reasons. <br>     */ <br>    rValue = RegOpenKeyEx (HKEY_LOCAL_MACHINE, NlsRegEntryStr, 0, KEY_SET_VALUE, &amp;hKey); <br>    if (rValue == ERROR_ACCESS_DENIED) { <br>      MessageBox (NULL, LoadResourceString(IDS_LOGON_AS_ADMIN), <br>               LoadResourceString(IDS_ACCESS_DENIED), MB_ICONSTOP | MB_OK); <br>      return FALSE; <br>    } <br>    if (rValue != ERROR_SUCCESS) { <br>      MessageBox (NULL, LoadResourceString(IDS_REGOPENKEYEX_FAILED),NULL, MB_ICONSTOP | MB_OK); <br>      return FALSE; <br>    } <br> <br> <br>    /* Try to copy file... one reason for failure is file already <br>     *  exists.  If so, query the user to try again. <br>     *  If fails again, just report problem and exit. <br>     */ <br>    if (!CopyFile (szPathAndName, szTargetFile, TRUE)) { <br> <br>      /* if failure was from existing file, query user preference <br>       *  regarding replacing it. <br>       */ <br>      if (GetLastError() == ERROR_FILE_EXISTS) { <br>        if (MessageBox (NULL, LoadResourceString(IDS_FILE_ALREADY_EXISTS), <br>                        LoadResourceString(IDS_APP_WARNING), <br>                        MB_ICONEXCLAMATION | MB_YESNO) == IDNO) { <br>          goto close_and_exit; <br>        } else { <br>          if (!CopyFile (szPathAndName, szTargetFile, FALSE)) { <br>            MessageBox (NULL, LoadResourceString(IDS_FILE_CP_FAILED_AGAIN), <br>                          NULL, MB_ICONSTOP | MB_OK); <br>            goto close_and_exit; <br>          } <br>        } <br> <br>      /* no duplicate file, CopyFile() failed for other reasons <br>       *  report failure and return. <br>       */ <br>      } else { <br>        MessageBox (NULL, LoadResourceString(IDS_FILE_CP_FAILED), <br>                      NULL, MB_ICONSTOP | MB_OK); <br>        goto close_and_exit; <br> <br>      } <br>    } <br> <br> <br>    /* Finally, write the new key value to the registry. */ <br>    if (myScanf (szName, &amp;cp) == 1) { <br>      wsprintf (keyname, TEXT("%d"), cp); <br>      RegSetValueEx (hKey, keyname, 0, REG_SZ, (LPBYTE)szName, <br>                     (DWORD)((lstrlen(szName) +1)*sizeof(TCHAR))); <br> <br>    } else <br>      MessageBox (NULL, szName, LoadResourceString(IDS_FILE_PARSE_FAILED), <br>              MB_ICONSTOP | MB_OK); <br> <br> <br>close_and_exit: <br> <br>    RegCloseKey (hKey); <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: ListInstalledTables <br>* <br>* Display the *.nls conversion tables currently installed, according to the <br>*  registry.  Display either the file name, or just the codepage number. <br>* <br>* hwndFill - listbox or combobox to fill with names. <br>* message - LB_ADDSTRING or CB_ADDSTRING <br>* NumberOnly - FALSE then use full file name, TRUE then just use number. <br>* <br>* CRITERION for table being installed: <br>*  value in registry is c_* where * is number. <br>* <br>\***************************************************************************/ <br>int ListInstalledTables (HWND hwndFill, UINT message, int NumberOnly) <br>{ <br> <br>  TCHAR szKeyname[MAX_PATH], szValue[MAX_PATH]; <br>  DWORD cBytesName, cBytesValue, iSubKey; <br>  int  cp; <br>  HKEY hKey; <br> <br>  /* open the registry key for reading.  If failure, report and exit. */ <br>  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, NlsRegEntryStr, 0, KEY_QUERY_VALUE, &amp;hKey)) { <br>    MessageBox (NULL, LoadResourceString(IDS_REGOPENKEYEX_FAILED), <br>            NULL, MB_ICONSTOP | MB_OK); <br>    return FALSE; <br>  } <br> <br> <br>  /* empty the current contents. */ <br>  if (message == LB_ADDSTRING) <br>    SendMessage (hwndFill, LB_RESETCONTENT, 0, 0); <br>  else if (message == CB_ADDSTRING) <br>    SendMessage (hwndFill, CB_RESETCONTENT, 0, 0); <br> <br> <br>  iSubKey = 0; <br>  cBytesName = cBytesValue = MAX_PATH; <br>  while (!RegEnumValue (hKey, iSubKey, szKeyname, &amp;cBytesName, NULL, NULL, (LPBYTE)szValue, &amp;cBytesValue)) { <br> <br>    if (myScanf (szValue, &amp;cp) == 1) { <br> <br>      /* if we are to display only the number, then reformat szValue string */ <br>      if (NumberOnly) <br>        wsprintf (szValue, TEXT("%d"), cp); <br> <br> <br>      SendMessage (hwndFill, message, 0 ,(LPARAM) szValue); <br>    } <br> <br>    iSubKey++; <br>    cBytesName = cBytesValue = MAX_PATH;  // undoc.ed feature, must be set each time. <br>  } <br> <br>  RegCloseKey (hKey); <br> <br>  return TRUE; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: myScanf <br>* <br>* Convert a string into a number (like sscanf). <br>*  However, this function works independent of UNICODE turned on. <br>* <br>* NOT a general function... looking for "c_%d.nls" <br>* <br>\***************************************************************************/ <br>int myScanf (TCHAR* pSource, int* pValue) <br>{ <br>char ansibuffer[MAX_PATH]; <br>int iStrLen; <br> <br>  iStrLen = lstrlen (pSource); <br>  if (iStrLen == 0) return 0; <br> <br>#ifdef UNICODE <br>  WideCharToMultiByte (CP_ACP, 0, pSource, -1, <br>           ansibuffer, MAX_PATH, NULL, NULL); <br>#else <br>  lstrcpy (ansibuffer, pSource); <br>#endif <br> <br>  CharLowerBuffA (ansibuffer,lstrlenA (ansibuffer)); <br> <br>  return (sscanf (ansibuffer, "c_%d.nls", pValue)); // leave off TEXT() <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
