<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RWRES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5619"></a>RWRES.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: rwres.c <br>* <br>* Does all the reading and writing of the .RES (resource) file. <br>* <br>* Functions: <br>* <br>*    OpenResFile() <br>*    WriteRes() <br>*    LoadResFile() <br>*    IsValidResFile() <br>*    SafeParseResHeader() <br>*    SafeNameOrdLen() <br>*    SafeDWordAlign() <br>*    WriteDlgIncludeRes() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br> <br>/* <br> * The bytes in the special RT_RESOURCE32 type resource that is the <br> * first resource in every Win32 format res file.  The first 8 bytes <br> * in this resource's header were specially designed to be invalid <br> * for a 16 bit format resource file, so that tools can determine <br> * immediately if they are reading a 16 bit or a Win32 format res <br> * file. <br> */ <br>static BYTE abResource32[] = { <br>    0x00, 0x00, 0x00, 0x00,                 // DataSize (0 bytes). <br>    0x20, 0x00, 0x00, 0x00,                 // HeaderSize (32 bytes). <br>    0xff, 0xff, 0x00, 0x00,                 // Type (RT_RESOURCE32). <br>    0xff, 0xff, 0x00, 0x00,                 // Name (ordinal 0). <br>    0x00, 0x00, 0x00, 0x00,                 // DataVersion <br>    0x00, 0x00,                             // MemoryFlags <br>    0x00, 0x00,                             // LanguageId <br>    0x00, 0x00, 0x00, 0x00,                 // Version <br>    0x00, 0x00, 0x00, 0x00                  // Characteristics <br>}; <br> <br> <br>STATICFN BOOL LoadResFile(HANDLE hfRes, LPTSTR pszFullResFile, <br>    LPTSTR pszIncludeBuf); <br>STATICFN BOOL IsValidResFile(PRES pRes, INT cbFileSize); <br>STATICFN PRES SafeParseResHeader(PRES pRes, INT cbMaxSize); <br>STATICFN INT SafeNameOrdLen(LPTSTR psz, INT cbMaxLen); <br>STATICFN VOID SafeDWordAlign(PBYTE *ppb, PINT pcbMax); <br>STATICFN BOOL WriteDlgIncludeRes(HANDLE hfWrite, LPTSTR pszFullResFile); <br> <br> <br> <br>/************************************************************************ <br>* OpenResFile <br>* <br>* High level function to load the data in a resource file.  The <br>* function LoadResFile is called to do the actual work, after <br>* this code does some housekeeping. <br>* <br>* Arguments: <br>*     LPTSTR pszFullPath - The full path to the resource file. <br>* <br>* Returns: <br>*     TRUE if resource file was opened; otherwise, FALSE. <br>* <br>************************************************************************/ <br> <br>BOOL OpenResFile( <br>    LPTSTR pszFullPath) <br>{ <br>    HCURSOR hcurSave; <br>    PRESLINK prl; <br>    PRESLINK prlSave; <br>    BOOL fSuccess = FALSE; <br>    INT cDlg; <br>    HANDLE hfRes; <br>    TCHAR szInclude[CCHMAXPATH]; <br>    TCHAR szFullInclude[CCHMAXPATH]; <br>    BOOL fIncOpened = FALSE; <br> <br>    hcurSave = SetCursor(hcurWait); <br> <br>    /* <br>     * Close any existing resource and include file and free memory. <br>     * It is assumed that if either had been changed, the user was asked <br>     * if they wanted to save them, because it is too late now. <br>     */ <br>    FreeRes(); <br>    FreeInclude(); <br> <br>    if ((hfRes = CreateFile(pszFullPath, GENERIC_READ, <br>            FILE_SHARE_READ, NULL, OPEN_EXISTING, <br>            FILE_FLAG_SEQUENTIAL_SCAN, NULL)) != (HANDLE)-1 &amp;&amp; <br>            LoadResFile(hfRes, pszFullPath, szInclude)) { <br>        lstrcpy(szFullResFile, pszFullPath); <br>        pszResFile = FileInPath(szFullResFile); <br> <br>        ShowFileStatus(TRUE); <br> <br>        /* <br>         * If there was a DLGINCLUDE resource found, try and open the <br>         * specified include file, after making sure that it is a <br>         * fully formed path. <br>         */ <br>        if (*szInclude) { <br>            /* <br>             * Does the include filespec from the res file appear to <br>             * be a simple filename without a path?  If so, look for <br>             * it in the same directory that the res file is in. <br>             * Otherwise, assume it has a fully qualified path. <br>             */ <br>            if (!HasPath(szInclude)) { <br>                lstrcpy(szFullInclude, szFullResFile); <br>                lstrcpy(FileInPath(szFullInclude), szInclude); <br>            } <br>            else { <br>                lstrcpy(szFullInclude, szInclude); <br>            } <br> <br>            fIncOpened = OpenIncludeFile(szFullInclude); <br>        } <br> <br>        /* <br>         * If there wasn't an include resource found, or there was <br>         * but it couldn't be opened, we want to ask the user for the <br>         * include file to use for this resource file. <br>         */ <br>        if (!fIncOpened) <br>            Open(FILE_INCLUDE); <br> <br>        /* <br>         * Start counting the dialogs in the resource, but stop at two. <br>         */ <br>        cDlg = 0; <br>        for (cDlg = 0, prl = gprlHead; prl; prl = prl-&gt;prlNext) { <br>            if (prl-&gt;fDlgResource) { <br>                if (++cDlg &gt; 1) <br>                    break; <br> <br>                prlSave = prl; <br>            } <br>        } <br> <br>        /* <br>         * If there are multiple dialogs, display the "Select Dialog" <br>         * dialog to ask the user which one they want to edit.  If <br>         * there is exactly one dialog, just go ahead and show it <br>         * initially. <br>         */ <br>        if (cDlg == 1) <br>            ResLinkToDialog(prlSave); <br>        else if (cDlg &gt; 1) <br>            SelectDialogDialog(); <br> <br>        fSuccess = TRUE; <br>    } <br> <br>    if (hfRes != (HANDLE)-1) <br>        CloseHandle(hfRes); <br> <br>    ShowFileStatus(TRUE); <br>    SetCursor(hcurSave); <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* LoadResFile <br>* <br>* Loads the resource file specified by the passed in file handle. <br>* This function first verifies that it is a valid resource file. <br>* <br>* Arguments: <br>*   HANDLE hfRes           - File handle to read from. <br>*   LPTSTR pszFullResFile  - Full name of resource file being loaded. <br>*   LPTSTR pszIncludeBuf   - Where to return the include file name, if <br>*                            a DLGINCLUDE resource is found in the res <br>*                            file.  If not, this buffer gets a null byte <br>*                            as its first character. <br>* <br>* Returns: <br>*   TRUE if load was successful; otherwise, FALSE is returned. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL LoadResFile( <br>    HANDLE hfRes, <br>    LPTSTR pszFullResFile, <br>    LPTSTR pszIncludeBuf) <br>{ <br>    HANDLE hAllRes; <br>    PRES pRes; <br>    PRES pResAll; <br>    PRESLINK prl; <br>    PRESLINK prlT; <br>    INT cbRead; <br>    LPTSTR pszResType; <br>    DWORD cbFileSize; <br> <br>    cbFileSize = GetFileSize((HANDLE)hfRes, NULL); <br> <br>    if (!(hAllRes = GlobalAlloc(GMEM_MOVEABLE, cbFileSize))) { <br>        Message(MSG_OUTOFMEMORY); <br>        return FALSE; <br>    } <br> <br>    *pszIncludeBuf = CHAR_NULL; <br>    pRes = pResAll = (PRES)GlobalLock(hAllRes); <br>    if ((cbRead = _lread((HFILE)hfRes, (LPSTR)pResAll, cbFileSize)) != -1 &amp;&amp; <br>            cbRead == (INT)cbFileSize) { <br>        if (!IsValidResFile(pResAll, cbFileSize)) { <br>            Message(MSG_BADRESFILE, pszFullResFile); <br>        } <br>        else do { <br>            pszResType = ResourceType(pRes); <br> <br>            if (IsOrd(pszResType) &amp;&amp; OrdID(pszResType) == ORDID_RT_DLGINCLUDE) { <br>                /* <br>                 * Pass back the include file name.  This resource <br>                 * will not be saved in the res list because it is <br>                 * going to be explicitly written out later if <br>                 * necessary. <br>                 */ <br>                NameOrdCpy(pszIncludeBuf, (LPTSTR)SkipResHeader(pRes)); <br>            } <br>            else if (IsOrd(pszResType) &amp;&amp; <br>                    OrdID(pszResType) == ORDID_RT_RESOURCE32) { <br>                /* <br>                 * This is the dummy resource that identifies a <br>                 * 32 bit resource file.  This resource should be <br>                 * skipped also. <br>                 */ <br>            } <br>            else { <br>                /* <br>                 * This is some other kind of a resource. <br>                 * Save it in the resource list. <br>                 */ <br>                if (!(prlT = AllocResLink(pRes))) { <br>                    FreeResList(); <br>                    break; <br>                } <br> <br>                if (!gprlHead) { <br>                    gprlHead = prl = prlT; <br>                } <br>                else { <br>                    prl-&gt;prlNext = prlT; <br>                    prl = prlT; <br>                } <br>            } <br> <br>            /* <br>             * Move to the next resource. <br>             */ <br>            pRes = (PRES)((PBYTE)pRes + pRes-&gt;HeaderSize + pRes-&gt;DataSize); <br>            DWordAlign((PBYTE *)&amp;pRes); <br>        } while (pRes &lt; (PRES)((PBYTE)pResAll + cbFileSize)); <br>    } <br> <br>    GlobalUnlock(hAllRes); <br>    GlobalFree(hAllRes); <br> <br>    return (gprlHead ? TRUE : FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* IsValidResFile <br>* <br>* This function does some basic checks on the resource file in memory <br>* pointed to by pbRes.  It does this by walking through the resource <br>* checking for the resource header info and lengths. <br>* <br>* Arguments: <br>*   PRES pRes      - Pointer to the first resource in the file. <br>*   INT cbFileSize - Size of the file in memory. <br>* <br>* Returns: <br>*   TRUE if it is a valid resource file, FALSE if not. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL IsValidResFile( <br>    PRES pRes, <br>    INT cbFileSize) <br>{ <br>    INT cbCurLoc = 0; <br>    PRES pResT; <br> <br>    /* <br>     * The file is zero size. <br>     */ <br>    if (!cbFileSize) <br>        return FALSE; <br> <br>    pResT = pRes; <br>    while (cbCurLoc &lt; cbFileSize) { <br>        /* <br>         * Check this resource for validity. <br>         */ <br>        if (!(pResT = SafeParseResHeader(pResT, cbFileSize - cbCurLoc))) <br>            return FALSE; <br> <br>        /* <br>         * Point just past the resource that was just checked. <br>         */ <br>        cbCurLoc = (PBYTE)pResT - (PBYTE)pRes; <br>    } <br> <br>    return (cbCurLoc == cbFileSize) ? TRUE : FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SafeParseResHeader <br>* <br>* This function parses the specified resource header and returns a <br>* pointer to the next resource header in the resource file.  It does <br>* it in a safe manner, not touching memory beyond the maximum size <br>* specified.  If the resource header is somehow messed up and <br>* specifies a size that is larger than will fit in the given maximum <br>* size, NULL is returned. <br>* <br>* Arguments: <br>*   PRES pRes     - Pointer to the resource. <br>*   INT cbMaxSize - Maximum size the resource can be. <br>* <br>* Returns: <br>*   A pointer to just past this resource, or NULL if the resource <br>*   is larger than cbMaxSize. <br>* <br>************************************************************************/ <br> <br>STATICFN PRES SafeParseResHeader( <br>    PRES pRes, <br>    INT cbMaxSize) <br>{ <br>    INT cbLen; <br>    DWORD cbDataSize; <br>    PBYTE pb; <br> <br>    pb = (PBYTE)pRes; <br> <br>    /* <br>     * There must be room for the first part of the resource header. <br>     */ <br>    if (sizeof(RES) &gt; cbMaxSize) <br>        return FALSE; <br> <br>    pb += sizeof(RES); <br>    cbMaxSize -= sizeof(RES); <br> <br>    /* <br>     * Parse the type field then skip over it. <br>     */ <br>    cbLen = SafeNameOrdLen((LPTSTR)pb, cbMaxSize); <br>    if (cbLen &gt; cbMaxSize) <br>        return NULL; <br> <br>    pb += cbLen; <br>    cbMaxSize -= cbLen; <br> <br>    /* <br>     * Parse the name field then skip over it. <br>     */ <br>    cbLen = SafeNameOrdLen((LPTSTR)pb, cbMaxSize); <br>    if (cbLen &gt; cbMaxSize) <br>        return NULL; <br> <br>    pb += cbLen; <br>    cbMaxSize -= cbLen; <br> <br>    SafeDWordAlign(&amp;pb, &amp;cbMaxSize); <br> <br>    /* <br>     * There must be room for the second part of the resource header. <br>     */ <br>    if (sizeof(RES2) &gt; cbMaxSize) <br>        return FALSE; <br> <br>    pb += sizeof(RES2); <br>    cbMaxSize -= sizeof(RES2); <br> <br>    /* <br>     * The header size field must be valid. <br>     */ <br>    if (pRes-&gt;HeaderSize != (DWORD)(pb - (PBYTE)pRes)) <br>        return FALSE; <br> <br>    /* <br>     * Calculate the size of the data, taking into account any <br>     * padding that may be at the end to make it DWORD aligned. <br>     */ <br>    cbDataSize = pRes-&gt;DataSize; <br>    DWordAlign((PBYTE *)&amp;cbDataSize); <br> <br>    /* <br>     * There must be room enough left for the data. <br>     */ <br>    if (cbDataSize &gt; (DWORD)cbMaxSize) <br>        return FALSE; <br> <br>    return (PRES)(pb + cbDataSize); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SafeNameOrdLen <br>* <br>* This function returns the size of the specified name/ordinal.  It <br>* does it in a safe manner, not touching memory beyond the specified <br>* maximum size.  If it is a string and the terminating null is not <br>* found within cbMaxLen bytes, then cbMaxLen plus one is returned. <br>* <br>* Arguments: <br>*   LPTSTR psz   - Pointer to the name/ordinal. <br>*   INT cbMaxLen - Maximum length to probe. <br>* <br>* Returns: <br>*   The length of the ordinal if it is an ordinal, or the length <br>*   of the string (plus the null terminator) if it is a string. <br>* <br>************************************************************************/ <br> <br>STATICFN INT SafeNameOrdLen( <br>    LPTSTR psz, <br>    INT cbMaxLen) <br>{ <br>    INT cbLen = 0; <br> <br>    if (cbMaxLen == 0) <br>        return 1; <br> <br>    if (IsOrd(psz)) <br>        return sizeof(ORDINAL); <br> <br>    for (cbLen = 0; cbLen &lt; cbMaxLen &amp;&amp; *psz; psz++, cbLen += sizeof(TCHAR)) <br>        ; <br> <br>    /* <br>     * Account for the null terminator. <br>     */ <br>    cbLen += sizeof(TCHAR); <br> <br>    return cbLen; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SafeDWordAlign <br>* <br>* This function aligns the passed pointer to a DWORD boundary.  At the <br>* same time, it subtracts from the specified counter the amount that <br>* it had to add to the pointer, if any. <br>* <br>* Arguments: <br>*   PBYTE *ppb  - Points to the pointer to align. <br>*   PINT pcbMax - Points to the current count to decrement. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID SafeDWordAlign( <br>    PBYTE *ppb, <br>    PINT pcbMax) <br>{ <br>    INT cbAlign; <br> <br>    cbAlign = (4 - (((WORD)(DWORD)*ppb) &amp; 3)) % 4; <br>    *ppb += cbAlign; <br>    *pcbMax -= cbAlign; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteRes <br>* <br>* Worker routine that does the actual writing out of the resource data. <br>* <br>* Arguments: <br>*   HANDLE hfWrite         - Resource file to write to. <br>*   LPTSTR pszFullResFile  - Full pathname to the resource file that <br>*                            is being written. <br>* <br>* Returns: <br>*   TRUE if successful; otherwise, FALSE. <br>* <br>************************************************************************/ <br> <br>BOOL WriteRes( <br>    HANDLE hfWrite, <br>    LPTSTR pszFullResFile) <br>{ <br>    PRESLINK prl; <br>    PRES pRes; <br> <br>    /* <br>     * Write the special RT_RESOURCE32 dummy resource to the beginning <br>     * of the resource file.  This resource is aligned, so no padding <br>     * needs to be done before writing the resource that follows it. <br>     */ <br>    if (_lwrite((HFILE)hfWrite, abResource32, sizeof(abResource32)) == -1) <br>        return FALSE; <br> <br>    /* <br>     * Write out any DLGINCLUDE resource there may be. <br>     */ <br>    if (!WriteDlgIncludeRes(hfWrite, pszFullResFile)) <br>        return FALSE; <br> <br>    /* <br>     * Loop through all the resources. <br>     */ <br>    for (prl = gprlHead; prl; prl = prl-&gt;prlNext) { <br>        if (!(pRes = (PRES)GlobalLock(prl-&gt;hRes))) <br>            return FALSE; <br> <br>        /* <br>         * Write the actual data. <br>         */ <br>        if (_lwrite((HFILE)hfWrite, (LPSTR)pRes, prl-&gt;cbRes) == -1) <br>            return FALSE; <br> <br>        /* <br>         * Write pads out to the next DWORD boundary. <br>         */ <br>        if (!WriteDWordPad(hfWrite, prl-&gt;cbRes)) <br>            return FALSE; <br> <br>        GlobalUnlock(prl-&gt;hRes); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDlgIncludeRes <br>* <br>* Writes out a DLGINCLUDE resource to the specified resource file for <br>* the currently open include file. <br>* <br>* Arguments: <br>*   HANDLE hfWrite         - Resource file handle to write to. <br>*   LPTSTR pszFullResFile  - Full pathname to the resource file that <br>*                            is being written. <br>* <br>* Returns: <br>*   Number of characters written if the include resource was <br>*   written successfully (or there wasn't one to write) or -1 <br>*   if an error occurred. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteDlgIncludeRes( <br>    HANDLE hfWrite, <br>    LPTSTR pszFullResFile) <br>{ <br>    INT cbResSize; <br>    INT cbDataSize; <br>    PRES pResBegin; <br>    PBYTE pb; <br>    INT cbWritten; <br>    LPTSTR pszInc; <br>    ORDINAL ordDlgIncName; <br>    BOOL fSuccess = FALSE; <br> <br>    /* <br>     * No include file.  Do nothing (return success). <br>     */ <br>    if (!pszIncludeFile) <br>        return TRUE; <br> <br>    /* <br>     * If the include file is in a different directory than the resource <br>     * file, write the full path to it.  Otherwise, we just write the <br>     * include file name. <br>     */ <br>    if (DifferentDirs(pszFullResFile, szFullIncludeFile)) <br>        pszInc = szFullIncludeFile; <br>    else <br>        pszInc = pszIncludeFile; <br> <br>    /* <br>     * The DLGINCLUDE resource name always is the same (a value of 1). <br>     */ <br>    WriteOrd(&amp;ordDlgIncName, ORDID_DLGINCLUDE_NAME); <br> <br>    /* <br>     * Determine the size of the resource data. <br>     */ <br>    cbDataSize = NameOrdLen(pszInc); <br> <br>    /* <br>     * Determine the resource size.  Note that there is no need for <br>     * DWORD padding after the res header, because the header will <br>     * be aligned (there are no strings in it). <br>     */ <br>    cbResSize = sizeof(RES) +                       // First part of res header. <br>            sizeof(ORDINAL) +                       // Type ordinal. <br>            sizeof(ORDINAL) +                       // Name ordinal. <br>            sizeof(RES2) +                          // Second half of header. <br>            cbDataSize;                             // Size of data. <br> <br>    if (!(pResBegin = (PRES)MyAlloc(cbResSize))) <br>        return FALSE; <br> <br>    /* <br>     * Write the resource header. <br>     */ <br>    pb = WriteResHeader(pResBegin, cbDataSize, ORDID_RT_DLGINCLUDE, <br>            (LPTSTR)&amp;ordDlgIncName, MMF_MOVEABLE | MMF_PURE | MMF_DISCARDABLE, <br>            0, 0, 0, 0); <br> <br>    /* <br>     * Write the resource data.  This is simply the name <br>     * of the include file. <br>     */ <br>    NameOrdCpy((LPTSTR)pb, pszInc); <br> <br>    /* <br>     * Write the resource to the file. <br>     */ <br>    cbWritten = _lwrite((HFILE)hfWrite, (LPSTR)pResBegin, cbResSize); <br> <br>    if (cbWritten == cbResSize) { <br>        /* <br>         * Write pads out to the next DWORD boundary. <br>         */ <br>        if (WriteDWordPad(hfWrite, cbWritten)) <br>            fSuccess = TRUE; <br>    } <br> <br>    MyFree(pResBegin); <br> <br>    return fSuccess; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
