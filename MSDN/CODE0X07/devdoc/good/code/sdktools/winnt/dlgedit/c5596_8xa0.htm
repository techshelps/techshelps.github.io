<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CUSTCNTL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5598"></a>CUSTCNTL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: custcntl.c <br>* <br>* Contains functions to support custom controls. <br>* <br>* Functions: <br>*    NewCustDlgProc() <br>*    OpenCustomDialog() <br>*    SelCustDialog() <br>*    SelCustDlgProc() <br>*    RemCustDlgProc() <br>*    CustomWndProc() <br>*    AddCustomLink() <br>*    RemoveCustomLink() <br>*    CallCustomStyle() <br>*    CallCustomSizeToText() <br>*    ReadCustomProfile() <br>*    WriteCustomProfile() <br>*    NewCustInit() <br>*    NewCustOK() <br>*    OpenDLLFile() <br>*    CallCustomInfoA() <br>*    SelCustInit() <br>*    SelCustSelect() <br>*    SelCustOK() <br>*    RemCustInit() <br>*    RemCustOK() <br>*    AllocCUSTLINK() <br>*    FreeCUSTLINK() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br>#include "dlghelp.h" <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include &lt;commdlg.h&gt; <br> <br> <br>/* <br> * Minimum margin around the sample control. <br> */ <br>#define SAMPLEMARGIN                4 <br> <br> <br>STATICFN VOID NewCustInit(HWND hwnd); <br>STATICFN BOOL NewCustOK(HWND hwnd); <br>STATICFN VOID OpenDLLFile(LPTSTR pszFileName); <br>STATICFN UINT CallCustomInfoA(LPFNCCINFOA lpfnInfoA, LPCCINFO acciW, <br>    INT nControls); <br>STATICFN VOID SelCustInit(HWND hwnd); <br>STATICFN VOID SelCustSelect(HWND hwnd); <br>STATICFN BOOL SelCustOK(HWND hwnd); <br>STATICFN VOID RemCustInit(HWND hwnd); <br>STATICFN BOOL RemCustOK(HWND hwnd); <br>STATICFN PCUSTLINK AllocCUSTLINK(LPCCINFO pcci, BOOL fEmulated, <br>    BOOL fUnicodeDLL, LPTSTR pszFileName, HANDLE hmod); <br>STATICFN VOID FreeCUSTLINK(PCUSTLINK pclFree); <br> <br> <br>/* <br> * Used to return the pwcd that is chosen from the Select Custom <br> * Control dialog. <br> */ <br>static PWINDOWCLASSDESC pwcdChosen; <br> <br>/* <br> * Has the window handle of the sample custom control in the <br> * Select Custom Control dialog. <br> */ <br>static HWND hwndCustomSample; <br> <br> <br> <br> <br>/************************************************************************ <br>* NewCustDlgProc <br>* <br>* This is the Add Custom Control dialog procedure. <br>* <br>* : <br>* <br>************************************************************************/ <br> <br>DIALOGPROC NewCustDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            NewCustInit(hwnd); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case IDOK: <br>                    if (NewCustOK(hwnd)) <br>                        EndDialog(hwnd, IDOK); <br> <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hwnd, IDCANCEL); <br>                    break; <br> <br>                case IDHELPDLG: <br>                    WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, <br>                            HELPID_NEWCUST); <br>                    break; <br>            } <br> <br>            return TRUE; <br> <br>        default: <br>            return FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* NewCustInit <br>* <br>* Processes the WM_INITDIALOG message for the New Temporary Custom Control <br>* dialog procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID NewCustInit( <br>    HWND hwnd) <br>{ <br>    TCHAR szStyles[32]; <br> <br>    SendDlgItemMessage(hwnd, DID_NEWCUSTCLASS, EM_LIMITTEXT, CCHCCCLASS - 1, 0L); <br> <br>    SendDlgItemMessage(hwnd, DID_NEWCUSTSTYLES, EM_LIMITTEXT, CCHHEXLONGMAX, 0L); <br>    wsprintf(szStyles, L"%#.8lx", awcd[W_CUSTOM].flStyles); <br>    SetDlgItemText(hwnd, DID_NEWCUSTSTYLES, szStyles); <br> <br>    SendDlgItemMessage(hwnd, DID_NEWCUSTCX, EM_LIMITTEXT, 3, 0L); <br>    SetDlgItemInt(hwnd, DID_NEWCUSTCX, awcd[W_CUSTOM].cxDefault, FALSE); <br> <br>    SendDlgItemMessage(hwnd, DID_NEWCUSTCY, EM_LIMITTEXT, 3, 0L); <br>    SetDlgItemInt(hwnd, DID_NEWCUSTCY, awcd[W_CUSTOM].cyDefault, FALSE); <br> <br>    SendDlgItemMessage(hwnd, DID_NEWCUSTTEXT, EM_LIMITTEXT, CCHCCTEXT - 1, 0L); <br> <br>    CenterWindow(hwnd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* NewCustOK <br>* <br>* Processes the OK button from the New Temporary Custom Control dialog. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL NewCustOK( <br>    HWND hwnd) <br>{ <br>    TCHAR szStyles[CCHHEXLONGMAX + 1]; <br>    CCINFO cci; <br> <br>    /* <br>     * Read the class field.  It is required. <br>     */ <br>    if (!GetDlgItemText(hwnd, DID_NEWCUSTCLASS, cci.szClass, CCHCCCLASS)) { <br>        Message(MSG_NOCLASS); <br>        SetFocus(GetDlgItem(hwnd, DID_NEWCUSTCLASS)); <br>        return FALSE; <br>    } <br> <br>    GetDlgItemText(hwnd, DID_NEWCUSTSTYLES, szStyles, CCHHEXLONGMAX + 1); <br>    cci.flStyleDefault = valtoi(szStyles); <br> <br>    if (!(cci.cxDefault = GetDlgItemInt(hwnd, DID_NEWCUSTCX, NULL, FALSE))) { <br>        Message(MSG_GTZERO, ids(IDS_WIDTH)); <br>        SetFocus(GetDlgItem(hwnd, DID_NEWCUSTCX)); <br>        return FALSE; <br>    } <br> <br>    if (!(cci.cyDefault = GetDlgItemInt(hwnd, DID_NEWCUSTCY, NULL, FALSE))) { <br>        Message(MSG_GTZERO, ids(IDS_HEIGHT)); <br>        SetFocus(GetDlgItem(hwnd, DID_NEWCUSTCY)); <br>        return FALSE; <br>    } <br> <br>    GetDlgItemText(hwnd, DID_NEWCUSTTEXT, cci.szTextDefault, CCHCCTEXT); <br> <br>    cci.flOptions = 0; <br>    *cci.szDesc = TEXT('\0'); <br>    cci.flExtStyleDefault = 0; <br>    cci.flCtrlTypeMask = 0; <br>    cci.cStyleFlags = 0; <br>    cci.aStyleFlags = NULL; <br>    cci.lpfnStyle = NULL; <br>    cci.lpfnSizeToText = NULL; <br>    cci.dwReserved1 = 0; <br>    cci.dwReserved2 = 0; <br> <br>    if (AddCustomLink(&amp;cci, TRUE, FALSE, NULL, NULL)) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OpenCustomDialog <br>* <br>* Displays the file open dialog and allows a custom DLL to be selected <br>* and loaded. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID OpenCustomDialog(VOID) <br>{ <br>    BOOL fGotName; <br>    OPENFILENAME ofn; <br>    TCHAR szNewFileName[CCHMAXPATH]; <br>    TCHAR szFilter[CCHTEXTMAX]; <br>    INT idPrevDlg; <br> <br>    /* <br>     * Begin setting up the globals and the open file dialog structure. <br>     */ <br>    *szNewFileName = CHAR_NULL; <br> <br>    /* <br>     * Build up the filter string. <br>     */ <br>    BuildFilterString(FILE_DLL, szFilter); <br> <br>    ofn.lStructSize = sizeof(ofn); <br>    ofn.hwndOwner = ghwndMain; <br>    ofn.hInstance = NULL; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = szNewFileName; <br>    ofn.nMaxFile = CCHMAXPATH; <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrTitle = ids(IDS_DLLOPENTITLE); <br>    ofn.Flags = OFN_HIDEREADONLY | OFN_SHOWHELP | OFN_FILEMUSTEXIST; <br>    ofn.lpstrDefExt = ids(IDS_DLLEXT); <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = NULL; <br>    ofn.lpTemplateName = NULL; <br> <br>    /* <br>     * Fire off the dialog box to open the file. <br>     */ <br>    EnteringDialog(DID_COMMONFILEOPENDLL, &amp;idPrevDlg, TRUE); <br>    fGotName = GetOpenFileName(&amp;ofn); <br>    EnteringDialog(idPrevDlg, NULL, FALSE); <br> <br>    if (fGotName) <br>        OpenDLLFile(szNewFileName); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OpenDLLFile <br>* <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OpenDLLFile( <br>    LPTSTR pszFileName) <br>{ <br>    HANDLE hmod; <br>    LPFNCCINFOA lpfnInfoA; <br>    LPFNCCINFOW lpfnInfoW; <br>    INT i; <br>    BOOL fSuccess = FALSE; <br>    BOOL fUnicodeDLL; <br>    PCUSTLINK pclT; <br>    INT nControls; <br>    INT nControls2; <br>    LPCCINFO acci; <br> <br>    /* <br>     * Check to see if the DLL has already been loaded. <br>     */ <br>    for (pclT = gpclHead; pclT &amp;&amp; <br>            (pclT-&gt;pwcd-&gt;fEmulated || <br>            lstrcmpi(pclT-&gt;pszFileName, pszFileName) != 0); <br>            pclT = pclT-&gt;pclNext) <br>        ; <br> <br>    /* <br>     * Is the DLL already loaded? <br>     */ <br>    if (pclT) { <br>        Message(MSG_CUSTALREADYLOADED, pszFileName); <br>        return; <br>    } <br> <br>    if (!(hmod = LoadLibrary(pszFileName))) { <br>        Message(MSG_CANTLOADDLL, pszFileName); <br>        return; <br>    } <br> <br>    lpfnInfoA = (LPFNCCINFOA)GetProcAddress(hmod, "CustomControlInfoA"); <br>    lpfnInfoW = (LPFNCCINFOW)GetProcAddress(hmod, "CustomControlInfoW"); <br> <br>    if (!lpfnInfoA &amp;&amp; !lpfnInfoW) { <br>        Message(MSG_BADCUSTDLL, pszFileName); <br>        goto Error1; <br>    } <br> <br>    if (lpfnInfoW) { <br>        nControls = (*lpfnInfoW)(NULL); <br>        fUnicodeDLL = TRUE; <br>    } <br>    else { <br>        nControls = (*lpfnInfoA)(NULL); <br>        fUnicodeDLL = FALSE; <br>    } <br> <br>    if (!nControls) { <br>        Message(MSG_CANTINITDLL, pszFileName); <br>        goto Error1; <br>    } <br> <br>    if (!(acci = (LPCCINFO)MyAlloc(nControls * sizeof(CCINFO)))) <br>        goto Error1; <br> <br>    if (fUnicodeDLL) <br>        nControls2 = (*lpfnInfoW)(acci); <br>    else <br>        nControls2 = CallCustomInfoA(lpfnInfoA, acci, nControls); <br> <br>    if (!nControls2) { <br>        Message(MSG_CANTINITDLL, pszFileName); <br>        goto Error2; <br>    } <br> <br>    for (i = 0; i &lt; nControls; i++) { <br>        if (!AddCustomLink(&amp;acci[i], FALSE, fUnicodeDLL, pszFileName, hmod)) <br>            goto Error2; <br>    } <br> <br>    fSuccess = TRUE; <br> <br>Error2: <br>    MyFree(acci); <br> <br>Error1: <br>    if (!fSuccess) <br>        FreeLibrary(hmod); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CallCustomInfoA <br>* <br>* Thunks the call from the unicode DlgEdit to the ANSI custom control <br>* info procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN UINT CallCustomInfoA( <br>    LPFNCCINFOA lpfnInfoA, <br>    LPCCINFO acciW, <br>    INT nControls) <br>{ <br>    LPCCINFOA acciA; <br>    INT nControls2; <br>    INT i; <br>    INT j; <br>    LPCCSTYLEFLAGA lpFlagsA; <br>    LPCCSTYLEFLAGW aFlagsW = NULL; <br>    INT cch; <br> <br>    /* <br>     * Allocate the appropriate number of ANSI info structures. <br>     */ <br>    if (!(acciA = (LPCCINFOA)MyAlloc(nControls * sizeof(CCINFOA)))) <br>        return 0; <br> <br>    /* <br>     * Call the ANSI info function. <br>     */ <br>    if (nControls2 = (*lpfnInfoA)(acciA)) { <br>        /* <br>         * Copy all the ANSI structures to the UNICODE structures, <br>         * converting strings to UNICODE as we go. <br>         */ <br>        for (i = 0; i &lt; nControls; i++) { <br>            MultiByteToWideChar(CP_ACP, 0, acciA[i].szClass, -1, <br>                    acciW[i].szClass, CCHCCCLASS); <br>            acciW[i].flOptions = acciA[i].flOptions; <br>            MultiByteToWideChar(CP_ACP, 0, acciA[i].szDesc, -1, <br>                    acciW[i].szDesc, CCHCCDESC); <br>            acciW[i].cxDefault = acciA[i].cxDefault; <br>            acciW[i].cyDefault = acciA[i].cyDefault; <br>            acciW[i].flStyleDefault = acciA[i].flStyleDefault; <br>            acciW[i].flExtStyleDefault = acciA[i].flExtStyleDefault; <br>            acciW[i].flCtrlTypeMask = acciA[i].flCtrlTypeMask; <br>            MultiByteToWideChar(CP_ACP, 0, acciA[i].szTextDefault, -1, <br>                    acciW[i].szTextDefault, CCHCCTEXT); <br> <br>            /* <br>             * Is there a table of style flags?  If so, we need to build <br>             * up a table of unicode style flags.  Note that since we <br>             * allocate this table, the table must be freed when the <br>             * custom link is destroyed! <br>             */ <br>            if (acciA[i].cStyleFlags) { <br>                /* <br>                 * If they specified that there are style flags, the pointer <br>                 * to the table must not be NULL. <br>                 */ <br>                if (!acciA[i].aStyleFlags) <br>                    return 0; <br> <br>                if (!(aFlagsW = (LPCCSTYLEFLAGW)MyAlloc( <br>                        acciA[i].cStyleFlags * sizeof(CCSTYLEFLAGW)))) <br>                    return 0; <br> <br>                /* <br>                 * Copy all the flags to the new unicode style flag table. <br>                 */ <br>                for (j = 0, lpFlagsA = acciA[i].aStyleFlags; <br>                        j &lt; acciA[i].cStyleFlags; j++, lpFlagsA++) { <br>                    aFlagsW[j].flStyle = lpFlagsA-&gt;flStyle; <br>                    aFlagsW[j].flStyleMask = lpFlagsA-&gt;flStyleMask; <br> <br>                    cch =  lstrlenA(lpFlagsA-&gt;pszStyle) + 1; <br>                    aFlagsW[j].pszStyle = (LPWSTR)MyAlloc(cch * sizeof(WCHAR)); <br> <br>                    if (!aFlagsW[j].pszStyle) <br>                        return 0; <br> <br>                    MultiByteToWideChar(CP_ACP, 0, lpFlagsA-&gt;pszStyle, -1, <br>                            aFlagsW[j].pszStyle, cch); <br>                } <br>            } <br> <br>            acciW[i].cStyleFlags = acciA[i].cStyleFlags; <br>            acciW[i].aStyleFlags = aFlagsW; <br> <br>            acciW[i].lpfnStyle = (LPFNCCSTYLE)acciA[i].lpfnStyle; <br>            acciW[i].lpfnSizeToText = (LPFNCCSIZETOTEXT)acciA[i].lpfnSizeToText; <br>            acciW[i].dwReserved1 = acciA[i].dwReserved1; <br>            acciW[i].dwReserved2 = acciA[i].dwReserved2; <br>        } <br>    } <br> <br>    MyFree(acciA); <br> <br>    return nControls2; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelCustDialog <br>* <br>* Displays the Select Custom Control dialog to choose which custom <br>* control tool should be selected. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>PWINDOWCLASSDESC SelCustDialog(VOID) <br>{ <br>    if (DlgBox(DID_SELCUST, (WNDPROC)SelCustDlgProc) == IDOK) <br>        return pwcdChosen; <br>    else <br>        return NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelCustDlgProc <br>* <br>* This is the Select Custom Control dialog procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>DIALOGPROC SelCustDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            SelCustInit(hwnd); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case DID_SELCUSTLIST: <br>                    switch (HIWORD(wParam)) { <br>                        case LBN_DBLCLK: <br>                            if (SelCustOK(hwnd)) <br>                                EndDialog(hwnd, IDOK); <br> <br>                            break; <br> <br>                        case LBN_SELCHANGE: <br>                            SelCustSelect(hwnd); <br>                            break; <br>                    } <br> <br>                    break; <br> <br>                case IDOK: <br>                    if (SelCustOK(hwnd)) <br>                        EndDialog(hwnd, IDOK); <br> <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hwnd, IDCANCEL); <br>                    break; <br> <br>                case IDHELPDLG: <br>                    WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, <br>                            HELPID_SELCUST); <br>                    break; <br>            } <br> <br>            return TRUE; <br> <br>        default: <br>            return FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelCustInit <br>* <br>* Processes the WM_INITDIALOG message for the Select Custom Control <br>* dialog procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID SelCustInit( <br>    HWND hwnd) <br>{ <br>    HWND hwndLB; <br>    INT i; <br>    PCUSTLINK pcl; <br>    LPTSTR pszDesc; <br> <br>    hwndLB = GetDlgItem(hwnd, DID_SELCUSTLIST); <br> <br>    /* <br>     * Insert each custom control into the listbox. <br>     */ <br>    for (pcl = gpclHead; pcl; pcl = pcl-&gt;pclNext) { <br>        /* <br>         * Use the short description, if the control has one, <br>         * otherwise use the class name itself. <br>         */ <br>        if (pcl-&gt;pszDesc) <br>            pszDesc = pcl-&gt;pszDesc; <br>        else <br>            pszDesc = pcl-&gt;pwcd-&gt;pszClass; <br> <br>        i = (INT)SendMessage(hwndLB, LB_ADDSTRING, 0, (DWORD)pszDesc); <br>        SendMessage(hwndLB, LB_SETITEMDATA, i, (DWORD)pcl); <br>    } <br> <br>    hwndCustomSample = NULL; <br> <br>    /* <br>     * Select the first item. <br>     */ <br>    SendMessage(hwndLB, LB_SETCURSEL, 0, 0L); <br>    SelCustSelect(hwnd); <br> <br>    CenterWindow(hwnd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelCustSelect <br>* <br>* Called every time that a different control is selected in the list box <br>* in the Select Custom Control dialog.  It will create a sample control <br>* and show it in the Sample box. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID SelCustSelect( <br>    HWND hwnd) <br>{ <br>    HWND hwndLB; <br>    INT iSelect; <br>    PCUSTLINK pcl; <br>    PWINDOWCLASSDESC pwcd; <br>    LPTSTR pszClass; <br>    RECT rc; <br>    RECT rcParent; <br>    HWND hwndParent; <br>    INT x; <br>    INT y; <br>    INT cx; <br>    INT cy; <br>    INT cxParent; <br>    INT cyParent; <br> <br>    hwndLB = GetDlgItem(hwnd, DID_SELCUSTLIST); <br> <br>    if ((iSelect = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0)) == LB_ERR) <br>        return; <br> <br>    /* <br>     * Get a pointer to the custom control link (stored in the listbox <br>     * items data field). <br>     */ <br>    pcl = (PCUSTLINK)SendMessage(hwndLB, LB_GETITEMDATA, iSelect, 0L); <br>    pwcd = pcl-&gt;pwcd; <br> <br>    /* <br>     * Get the coordinates of the Sample box. <br>     */ <br>    hwndParent = GetDlgItem(hwnd, DID_SELCUSTSAMPLE); <br>    GetWindowRect(hwndParent, &amp;rcParent); <br>    ScreenToClientRect(hwnd, &amp;rcParent); <br>    cxParent = (rcParent.right - rcParent.left) - (2 * SAMPLEMARGIN); <br>    cyParent = (rcParent.bottom - rcParent.top) - (2 * SAMPLEMARGIN); <br> <br>    /* <br>     * Calculate the window size of the sample control. <br>     */ <br>    SetRect(&amp;rc, 0, 0, pwcd-&gt;cxDefault, pwcd-&gt;cyDefault); <br>    DUToWinRect(&amp;rc); <br>    cx = rc.right - rc.left; <br>    cy = rc.bottom - rc.top; <br> <br>    /* <br>     * Be sure that the control can fit within the sample box.  Adjust <br>     * it down if necessary. <br>     */ <br>    if (cx &lt; cxParent) { <br>        x = ((cxParent - cx) / 2) + SAMPLEMARGIN; <br>    } <br>    else { <br>        x = SAMPLEMARGIN; <br>        cx = cxParent; <br>    } <br> <br>    if (cy &lt; cyParent) { <br>        y = ((cyParent - cy) / 2) + SAMPLEMARGIN; <br>    } <br>    else { <br>        y = SAMPLEMARGIN; <br>        cy = cyParent; <br>    } <br> <br>    x += rcParent.left; <br>    y += rcParent.top; <br> <br>    /* <br>     * Destroy the old sample. <br>     */ <br>    if (hwndCustomSample) <br>        DestroyWindow(hwndCustomSample); <br> <br>    /* <br>     * Get the class name to use. <br>     * If the control is emulated, use the special emulator class. <br>     * Otherwise, it is an installed custom control, and we can use <br>     * it's real class string. <br>     */ <br>    if (pwcd-&gt;fEmulated) <br>        pszClass = szCustomClass; <br>    else <br>        pszClass = pwcd-&gt;pszClass; <br> <br>    /* <br>     * Create the sample control.  We always create it visible here, <br>     * even if the style says it isn't. <br>     */ <br>    hwndCustomSample = CreateWindow( <br>            pszClass, <br>            pwcd-&gt;pszTextDefault, <br>            pwcd-&gt;flStyles | WS_VISIBLE, <br>            x, y, cx, cy, <br>            hwnd, <br>            0, <br>            ghInst, <br>            NULL); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelCustOK <br>* <br>* Processes the final selection of a custom control from the <br>* Select Custom Control dialog. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL SelCustOK( <br>    HWND hwnd) <br>{ <br>    HWND hwndLB; <br>    INT iSelect; <br>    PCUSTLINK pcl; <br> <br>    hwndLB = GetDlgItem(hwnd, DID_SELCUSTLIST); <br> <br>    if ((iSelect = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0)) == LB_ERR) <br>        return FALSE; <br> <br>    /* <br>     * Get a pointer to the custom control link (stored in the listbox <br>     * items data field). <br>     */ <br>    pcl = (PCUSTLINK)SendMessage(hwndLB, LB_GETITEMDATA, iSelect, 0L); <br> <br>    pwcdChosen = pcl-&gt;pwcd; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* RemCustDlgProc <br>* <br>* This is the Remove Custom Control dialog procedure. <br>* It is used to de-install a custom control. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>DIALOGPROC RemCustDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            RemCustInit(hwnd); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case DID_REMCUSTLIST: <br>                    if (HIWORD(wParam) == LBN_DBLCLK) { <br>                        if (RemCustOK(hwnd)) <br>                            EndDialog(hwnd, IDOK); <br>                    } <br> <br>                    break; <br> <br>                case IDOK: <br>                    if (RemCustOK(hwnd)) <br>                        EndDialog(hwnd, IDOK); <br> <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hwnd, IDCANCEL); <br>                    break; <br> <br>                case IDHELPDLG: <br>                    WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, <br>                            HELPID_REMCUST); <br>                    break; <br>            } <br> <br>            return TRUE; <br> <br>        default: <br>            return FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* RemCustInit <br>* <br>* Processes the WM_INITDIALOG message for the Remove Custom Control <br>* dialog procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID RemCustInit( <br>    HWND hwnd) <br>{ <br>    HWND hwndLB; <br>    INT i; <br>    PCUSTLINK pcl; <br>    LPTSTR pszDesc; <br> <br>    hwndLB = GetDlgItem(hwnd, DID_REMCUSTLIST); <br> <br>    /* <br>     * Insert each custom control into the listbox. <br>     */ <br>    for (pcl = gpclHead; pcl; pcl = pcl-&gt;pclNext) { <br>        /* <br>         * Use the short description, if the control has one, <br>         * otherwise use the class name itself. <br>         */ <br>        if (pcl-&gt;pszDesc) <br>            pszDesc = pcl-&gt;pszDesc; <br>        else <br>            pszDesc = pcl-&gt;pwcd-&gt;pszClass; <br> <br>        i = (INT)SendMessage(hwndLB, LB_ADDSTRING, 0, (DWORD)pszDesc); <br>        SendMessage(hwndLB, LB_SETITEMDATA, i, (DWORD)pcl); <br>    } <br> <br>    /* <br>     * Select the first item. <br>     */ <br>    SendMessage(hwndLB, LB_SETCURSEL, 0, 0L); <br> <br>    CenterWindow(hwnd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* RemCustOK <br>* <br>* Processes the selection of a custom control to delete from the <br>* Remove Custom Control dialog. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL RemCustOK( <br>    HWND hwnd) <br>{ <br>    HWND hwndLB; <br>    INT iSelect; <br>    PCUSTLINK pcl; <br>    NPCTYPE npc; <br> <br>    hwndLB = GetDlgItem(hwnd, DID_REMCUSTLIST); <br> <br>    if ((iSelect = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0)) != LB_ERR) { <br>        /* <br>         * Get a pointer to the custom control link (stored in the listbox <br>         * items data field). <br>         */ <br>        pcl = (PCUSTLINK)SendMessage(hwndLB, LB_GETITEMDATA, iSelect, 0L); <br> <br>        /* <br>         * Cannot delete if any controls in the current dialog <br>         * are of this type. <br>         */ <br>        for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>            if (pcl-&gt;pwcd == npc-&gt;pwcd) { <br>                Message(MSG_CUSTCNTLINUSE); <br>                return FALSE; <br>            } <br>        } <br> <br>        RemoveCustomLink(pcl); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/**************************************************************************** <br>* CustomWndProc <br>* <br>* This is the window procedure for the emulated Custom control. <br>* <br>* History: <br>* <br>****************************************************************************/ <br> <br>WINDOWPROC CustomWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_PAINT: <br>            { <br>                HDC hDC; <br>                PAINTSTRUCT ps; <br>                RECT rc; <br>                TCHAR szText[CCHTEXTMAX]; <br> <br>                hDC = BeginPaint(hwnd, &amp;ps); <br> <br>                SelectObject(hDC, GetStockObject(LTGRAY_BRUSH)); <br>                GetClientRect(hwnd, &amp;rc); <br>                Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom); <br>                GetWindowText(hwnd, szText, CCHTEXTMAX); <br>#ifdef JAPAN <br>                { <br>                    TCHAR   szTmp[CCHTEXTMAX]; <br> <br>                    KDExpandCopy(szTmp, szText, CCHTEXTMAX); <br>                    lstrcpy(szText, szTmp); <br>                } <br>#endif <br>                SetBkMode(hDC, TRANSPARENT); <br> <br>                if (gcd.hFont) <br>                    SelectObject(hDC, gcd.hFont); <br> <br>                DrawText(hDC, szText, -1, &amp;rc, <br>                        DT_CENTER | DT_NOCLIP | DT_VCENTER | DT_SINGLELINE); <br> <br>                EndPaint(hwnd, &amp;ps); <br>            } <br> <br>            break; <br> <br>        default: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AddCustomLink <br>* <br>* Adds a new custom control to the linked list. <br>* <br>* Note that normally duplicates are checked for, but it allows multiple <br>* links to be added with the same class if it is a DLL control.  This <br>* is to support multiple control types being added from the same DLL. <br>* Because of this, if the caller is adding a non-emulated link, they <br>* are responsible for checking the list for duplicates first! <br>* <br>* There is one special case.  If it is adding a DLL link, and an <br>* emulated link with the same class name is found, it will walk the <br>* current list of controls and replace all of them with the new DLL <br>* control type, then delete the emulated link.  This is to support <br>* the case where the user creates some controls of class FOO, where <br>* FOO is emulated, then later loads the FOO DLL.  All controls of <br>* this emulated class will be changed to be the real FOO class, and <br>* the DLL FOO link replaces the emulated one. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>PCUSTLINK AddCustomLink( <br>    LPCCINFO pcci, <br>    BOOL fEmulated, <br>    BOOL fUnicodeDLL, <br>    LPTSTR pszFileName, <br>    HANDLE hmod) <br>{ <br>    PCUSTLINK pcl; <br>    PCUSTLINK pclT; <br>    PCUSTLINK pclPrev; <br>    NPCTYPE npc; <br>    HWND hwndOld; <br> <br>    if (!(pcl = AllocCUSTLINK(pcci, fEmulated, fUnicodeDLL, pszFileName, hmod))) <br>        return NULL; <br> <br>    if (fEmulated) { <br>        /* <br>         * Search the list for another link with the same class. <br>         */ <br>        for (pclT = gpclHead; <br>                pclT &amp;&amp; lstrcmpi(pclT-&gt;pwcd-&gt;pszClass, pcci-&gt;szClass) != 0; <br>                pclT = pclT-&gt;pclNext) <br>            ; <br> <br>        /* <br>         * Was a duplicate found? <br>         */ <br>        if (pclT) { <br>            FreeCUSTLINK(pcl); <br>            Message(MSG_CUSTALREADYLOADED, pcci-&gt;szClass); <br> <br>            return NULL; <br>        } <br>    } <br>    else { <br>        /* <br>         * Search the list for another link with the same class that <br>         * is an emulated control. <br>         */ <br>        for (pclT = gpclHead; <br>                pclT &amp;&amp; <br>                (lstrcmpi(pclT-&gt;pwcd-&gt;pszClass, pcci-&gt;szClass) != 0 || <br>                !pclT-&gt;pwcd-&gt;fEmulated); <br>                pclT = pclT-&gt;pclNext) <br>            ; <br> <br>        /* <br>         * Was a duplicate found? <br>         */ <br>        if (pclT) { <br>            /* <br>             * At this point we know that this is a DLL link replacing <br>             * an existing emulated control class.  We want to go through <br>             * the existing controls and replace any of this class with <br>             * the new DLL class.  This allows a user to load a dialog <br>             * with some emulated controls, then later install the custom <br>             * DLL and have all the existing controls of that class <br>             * change to show the real control. <br>             */ <br>            for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>                /* <br>                 * Is the control of the type that we are replacing? <br>                 */ </code></pre>
<p>
</p>
<pre><code>if (npc-&gt;pwcd == pclT-&gt;pwcd) { <br>                    hwndOld = npc-&gt;hwnd; <br> <br>                    /* <br>                     * Unsubclass the old control window, then switch <br>                     * the pwcd pointer before calling CreateControl. <br>                     */ <br>                    SetWindowLong(hwndOld, GWL_WNDPROC, <br>                            (DWORD)npc-&gt;pwcd-&gt;pfnOldWndProc); <br>                    UNSETPCINTOHWND(hwndOld); <br>                    npc-&gt;pwcd = pcl-&gt;pwcd; <br> <br>                    /* <br>                     * Create a control of the new type in the same position. <br>                     */ <br>                    if (CreateControl(npc, npc-&gt;text, npc-&gt;flStyle, <br>                            npc-&gt;flExtStyle, npc-&gt;id, &amp;npc-&gt;rc, <br>                            hwndOld, NULL)) { <br>                        /* <br>                         * Get rid of the old control window. <br>                         */ <br>                        DestroyWindow(hwndOld); <br> <br>                        /* <br>                         * Adjust the size and position of its drag window. <br>                         */ <br>                        SizeDragToControl(npc); <br>                    } <br>                } <br>            } <br> <br>            /* <br>             * Remove the old link, now that all the controls that <br>             * used it are gone. <br>             */ <br>            RemoveCustomLink(pclT); <br>        } <br>    } <br> <br>    /* <br>     * Search for the end of the list.  Get a pointer to the last link. <br>     */ <br>    for (pclT = gpclHead, pclPrev = NULL; pclT; <br>            pclPrev = pclT, pclT = pclT-&gt;pclNext) <br>        ; <br> <br>    /* <br>     * Add the new link to the list.  Add it to the end if there are <br>     * other links, or initialize the head pointer if this is the <br>     * first one. <br>     */ <br>    if (pclPrev) <br>        pclPrev-&gt;pclNext = pcl; <br>    else <br>        gpclHead = pcl; <br> <br>    return pcl; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AllocCUSTLINK <br>* <br>* Allocates a CUSTLINK structure and initializes it.  This includes <br>* allocating an associated WINDOWCLASSDESC structure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN PCUSTLINK AllocCUSTLINK( <br>    LPCCINFO pcci, <br>    BOOL fEmulated, <br>    BOOL fUnicodeDLL, <br>    LPTSTR pszFileName, <br>    HANDLE hmod) <br>{ <br>    PCUSTLINK pcl; <br>    PWINDOWCLASSDESC pwcd; <br> <br>    if (!(pwcd = (PWINDOWCLASSDESC)MyAlloc(sizeof(WINDOWCLASSDESC)))) <br>        return NULL; <br> <br>    /* <br>     * Initialize the structure to be like an emulated custom control. <br>     */ <br>    *pwcd = awcd[W_CUSTOM]; <br> <br>    /* <br>     * Now override some values. <br>     */ <br>    pwcd-&gt;flStyles = pcci-&gt;flStyleDefault; <br>    pwcd-&gt;flExtStyle = pcci-&gt;flExtStyleDefault; <br>    pwcd-&gt;cxDefault = pcci-&gt;cxDefault; <br>    pwcd-&gt;cyDefault = pcci-&gt;cyDefault; <br>    pwcd-&gt;fEmulated = fEmulated; <br>    pwcd-&gt;fUnicodeDLL = fUnicodeDLL; <br>    pwcd-&gt;hmod = hmod; <br>    pwcd-&gt;cStyleFlags = pcci-&gt;cStyleFlags; <br>    pwcd-&gt;aStyleFlags = pcci-&gt;aStyleFlags; <br>    pwcd-&gt;lpfnStyle = (PROC)pcci-&gt;lpfnStyle; <br>    pwcd-&gt;lpfnSizeToText = (PROC)pcci-&gt;lpfnSizeToText; <br>    pwcd-&gt;flCtrlTypeMask = pcci-&gt;flCtrlTypeMask; <br> <br>    if (pcci-&gt;flOptions &amp; CCF_NOTEXT) <br>        pwcd-&gt;fHasText = FALSE; <br>    else <br>        pwcd-&gt;fHasText = TRUE; <br> <br>    if (pcci-&gt;lpfnSizeToText &amp;&amp; pwcd-&gt;fHasText) <br>        pwcd-&gt;fSizeToText = TRUE; <br> <br>    /* <br>     * Copy the class name. <br>     */ <br>    if (!(pwcd-&gt;pszClass = NameOrdDup(pcci-&gt;szClass))) <br>        goto error1; <br> <br>    /* <br>     * Copy the default text.  This is an optional field. <br>     */ <br>    if (*pcci-&gt;szTextDefault) { <br>        if (!(pwcd-&gt;pszTextDefault = NameOrdDup(pcci-&gt;szTextDefault))) <br>            goto error2; <br>    } <br>    else { <br>        pwcd-&gt;pszTextDefault = NULL; <br>    } <br> <br>    if (!(pcl = (PCUSTLINK)MyAlloc(sizeof(CUSTLINK)))) <br>        goto error3; <br> <br>    /* <br>     * Copy the DLL file name (NULL for emulated controls). <br>     */ <br>    if (pszFileName &amp;&amp; *pszFileName) { <br>        if (!(pcl-&gt;pszFileName = NameOrdDup(pszFileName))) <br>            goto error4; <br>    } <br>    else { <br>        pcl-&gt;pszFileName = NULL; <br>    } <br> <br>    /* <br>     * Copy the descriptive text.  This is an optional field. <br>     */ <br>    if (*pcci-&gt;szDesc) { <br>        if (!(pcl-&gt;pszDesc = NameOrdDup(pcci-&gt;szDesc))) <br>            goto error5; <br>    } <br>    else { <br>        pcl-&gt;pszDesc = NULL; <br>    } <br> <br>    pcl-&gt;pclNext = NULL; <br>    pcl-&gt;pwcd = pwcd; <br> <br>    return pcl; <br> <br>error5: <br>    if (pcl-&gt;pszFileName) <br>        MyFree(pcl-&gt;pszFileName); <br> <br>error4: <br>    MyFree(pcl); <br> <br>error3: <br>    if (pwcd-&gt;pszTextDefault) <br>        MyFree(pwcd-&gt;pszTextDefault); <br> <br>error2: <br>    MyFree(pwcd-&gt;pszClass); <br> <br>error1: <br>    MyFree(pwcd); <br> <br>    return NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* RemoveCustomLink <br>* <br>* Removes and frees a custom control link from the list. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID RemoveCustomLink( <br>    PCUSTLINK pclFree) <br>{ <br>    PCUSTLINK pcl; <br>    PCUSTLINK pclPrev; <br> <br>    /* <br>     * Search for the link in the list. <br>     */ <br>    for (pcl = gpclHead, pclPrev = NULL; pcl != pclFree; <br>            pclPrev = pcl, pcl = pcl-&gt;pclNext) <br>        ; <br> <br>    /* <br>     * Link was not found. <br>     */ <br>    if (!pcl) <br>        return; <br> <br>    /* <br>     * Remove the link from the list. <br>     */ <br>    if (pclPrev) <br>        pclPrev-&gt;pclNext = pclFree-&gt;pclNext; <br>    else <br>        gpclHead = pclFree-&gt;pclNext; <br> <br>    /* <br>     * Finally, free the link completely. <br>     */ <br>    FreeCUSTLINK(pclFree); <br>} <br> <br> <br> <br>/************************************************************************ <br>* FreeCUSTLINK <br>* <br>* Frees a CUSTLINK structure.  This includes freeing the <br>* associated WINDOWCLASSDESC structure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>STATICFN VOID FreeCUSTLINK( <br>    PCUSTLINK pclFree) <br>{ <br>    PCUSTLINK pcl; <br>    INT i; <br> <br>    /* <br>     * Do we need to unload the associated DLL? <br>     */ <br>    if (pclFree-&gt;pwcd-&gt;hmod) { <br>        /* <br>         * Run throught the custom list looking to see if any other <br>         * installed custom control has the same module handle as the <br>         * one that we are freeing. <br>         */ <br>        for (pcl = gpclHead; <br>                pcl &amp;&amp; <br>                (pcl == pclFree || pcl-&gt;pwcd-&gt;hmod != pclFree-&gt;pwcd-&gt;hmod); <br>                pcl = pcl-&gt;pclNext) <br>            ; <br> <br>        /* <br>         * If none were found, it is safe to unload this library. <br>         * Otherwise, we must leave the library loaded for the <br>         * others! <br>         */ <br>        if (!pcl) <br>            FreeLibrary(pclFree-&gt;pwcd-&gt;hmod); <br>    } <br> <br>    MyFree(pclFree-&gt;pwcd-&gt;pszClass); <br> <br>    if (pclFree-&gt;pwcd-&gt;pszTextDefault) <br>        MyFree(pclFree-&gt;pwcd-&gt;pszTextDefault); <br> <br>    /* <br>     * Is this a non-unicode DLL?  If so, then when it was loaded, <br>     * the dialog editor allocated a table of unicode style strings. <br>     * This table must now be freed.  If the DLL was a unicode one, <br>     * then the table pointed to by aStyleFlags belongs to the DLL, <br>     * and it must NOT be freed. <br>     */ <br>    if (pclFree-&gt;pwcd-&gt;hmod &amp;&amp; !pclFree-&gt;pwcd-&gt;fUnicodeDLL) { <br>        for (i = 0; i &lt; pclFree-&gt;pwcd-&gt;cStyleFlags; i++) <br>            MyFree(pclFree-&gt;pwcd-&gt;aStyleFlags[i].pszStyle); <br> <br>        if (pclFree-&gt;pwcd-&gt;aStyleFlags) <br>            MyFree(pclFree-&gt;pwcd-&gt;aStyleFlags); <br>    } <br> <br>    MyFree(pclFree-&gt;pwcd); <br> <br>    if (pclFree-&gt;pszFileName) <br>        MyFree(pclFree-&gt;pszFileName); <br> <br>    if (pclFree-&gt;pszDesc) <br>        MyFree(pclFree-&gt;pszDesc); <br> <br>    MyFree(pclFree); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CallCustomStyle <br>* <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>BOOL CallCustomStyle( <br>    NPCTYPE npc, <br>    PDWORD pflStyleNew, <br>    PDWORD pflExtStyleNew, <br>    LPTSTR pszTextNew) <br>{ <br>    CCSTYLE ccs; <br>    CCSTYLEA ccsA; <br>    BOOL fSuccess; <br>    BOOL fDefCharUsed; <br>    INT idPrevDlg; <br> <br>    /* <br>     * Because we are about ready to display the dialog, we need to <br>     * call EnteringDialog so that the properties bar, toolbox and <br>     * work mode dialog get disabled.  The first parameter is the <br>     * dialog id, used so that the proper help will be brought up <br>     * for this dialog.  Since we don't have a meaningful help screen <br>     * for any old random custom control, just pass in a value of <br>     * zero, which will cause the Help Contents screen to be <br>     * brought up if the user presses F1 while the dialog is up. <br>     */ <br>    EnteringDialog(0, &amp;idPrevDlg, TRUE); <br> <br>    /* <br>     * Is this a UNICODE DLL? <br>     */ <br>    if (npc-&gt;pwcd-&gt;fUnicodeDLL) { <br>        ccs.flStyle = *pflStyleNew; <br>        ccs.flExtStyle = *pflExtStyleNew; <br>        lstrcpy(ccs.szText, pszTextNew); <br>        ccs.lgid = gcd.di.wLanguage; <br>        ccs.wReserved1 = 0; <br> <br>        fSuccess = ((LPFNCCSTYLE)(*npc-&gt;pwcd-&gt;lpfnStyle))(ghwndMain, &amp;ccs); <br> <br>        if (fSuccess) { <br>            *pflStyleNew = ccs.flStyle; <br>            *pflExtStyleNew = ccs.flExtStyle; <br>            lstrcpy(pszTextNew, ccs.szText); <br>        } <br>    } <br>    else { <br>        ccsA.flStyle = *pflStyleNew; <br>        ccsA.flExtStyle = *pflExtStyleNew; <br>        WideCharToMultiByte(CP_ACP, 0, pszTextNew, -1, ccsA.szText, CCHCCTEXT, <br>                NULL, &amp;fDefCharUsed); <br>        ccsA.lgid = gcd.di.wLanguage; <br>        ccsA.wReserved1 = 0; <br> <br>        fSuccess = ((LPFNCCSTYLEA)(*npc-&gt;pwcd-&gt;lpfnStyle))(ghwndMain, &amp;ccsA); <br> <br>        if (fSuccess) { <br>            *pflStyleNew = ccsA.flStyle; <br>            *pflExtStyleNew = ccsA.flExtStyle; <br>            MultiByteToWideChar(CP_ACP, 0, ccsA.szText, -1, pszTextNew, <br>                    CCHTEXTMAX); <br>        } <br>    } <br> <br>    EnteringDialog(idPrevDlg, NULL, FALSE); <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* CallCustomSizeToText <br>* <br>* <br>* <br>* Returns: <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>INT CallCustomSizeToText( <br>    NPCTYPE npc) <br>{ <br>    INT x; <br>    INT xDU; <br>    BOOL fDefCharUsed; <br>    CHAR szTextA[CCHTEXTMAX]; <br>    PSTR pszTextA; <br> <br>    /* <br>     * Does this custom control have a SizeToText function? <br>     */ <br>    if (!npc-&gt;pwcd-&gt;lpfnSizeToText) <br>        return -1; <br> <br>    /* <br>     * Is this a UNICODE DLL that we are calling to? <br>     */ <br>    if (npc-&gt;pwcd-&gt;fUnicodeDLL) { <br>        x = ((LPFNCCSIZETOTEXT)(*npc-&gt;pwcd-&gt;lpfnSizeToText)) <br>                (npc-&gt;flStyle, npc-&gt;flExtStyle, gcd.hFont, npc-&gt;text); <br>    } <br>    else { <br>        /* <br>         * No, not a UNICODE DLL.  We must convert from UNICODE to <br>         * ANSI first.  NULL text cases must be handled properly. <br>         */ <br>        if (npc-&gt;text) { <br>            WideCharToMultiByte(CP_ACP, 0, npc-&gt;text, -1, szTextA, CCHTEXTMAX, <br>                    NULL, &amp;fDefCharUsed); <br>            pszTextA = szTextA; <br>        } <br>        else { <br>            pszTextA = NULL; <br>        } <br> <br>        x = ((LPFNCCSIZETOTEXTA)(*npc-&gt;pwcd-&gt;lpfnSizeToText)) <br>                (npc-&gt;flStyle, npc-&gt;flExtStyle, gcd.hFont, pszTextA); <br>    } <br> <br>    /* <br>     * Did the call to the DLL fail? <br>     */ <br>    if (x == -1) <br>        return -1; <br> <br>    /* <br>     * Convert the size in pixels to a size in Dialog Units.  Be sure <br>     * that we round any fraction up to the next higher DU.  Since <br>     * we know how wide the control must be to fit the text, we must <br>     * be sure that the size does not get rounded down below this <br>     * value when converting to DU's. <br>     */ <br>    xDU = MulDiv(x, 4, gcd.cxChar); <br>    if (MulDiv(xDU, gcd.cxChar, 4) != x) <br>        xDU++; <br> <br>    return xDU; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ReadCustomProfile <br>* <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID ReadCustomProfile(VOID) <br>{ <br>    TCHAR szBuf[CCHTEXTMAX]; <br>    TCHAR szBuf2[CCHTEXTMAX]; <br>    LPTSTR pszKey; <br> <br>    GetPrivateProfileString(szCustomDLL, NULL, szEmpty, <br>            szBuf, CCHTEXTMAX, ids(IDS_DLGEDITINI)); <br> <br>    /* <br>     * Get the file name for each custom control DLL and load it. <br>     */ <br>    for (pszKey = szBuf; *pszKey; pszKey += lstrlen(pszKey) + 1) { <br>        if (GetPrivateProfileString(szCustomDLL, pszKey, szEmpty, <br>                szBuf2, CCHTEXTMAX, ids(IDS_DLGEDITINI))) <br>            OpenDLLFile(szBuf2); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteCustomProfile <br>* <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID WriteCustomProfile(VOID) <br>{ <br>    PCUSTLINK pcl; <br>    PCUSTLINK pcl2; <br>    BOOL fSecond; <br> <br>    /* <br>     * Clear out the section. <br>     */ <br>    WritePrivateProfileString(szCustomDLL, NULL, NULL, ids(IDS_DLGEDITINI)); <br> <br>    for (pcl = gpclHead; pcl; pcl = pcl-&gt;pclNext) { <br>        /* <br>         * Only write out installed DLL's, not emulated controls. <br>         */ <br>        if (pcl-&gt;pszFileName) { <br>            /* <br>             * Before writing out the path to the DLL, be sure <br>             * that this DLL's path has not been written out <br>             * already.  This would only occur if they have <br>             * multiple control types within the DLL. <br>             */ <br>            for (pcl2 = gpclHead, fSecond = FALSE; <br>                    pcl2 &amp;&amp; pcl2 != pcl; pcl2 = pcl2-&gt;pclNext) { <br>                if (lstrcmpi(pcl2-&gt;pszFileName, pcl-&gt;pszFileName) == 0) { <br>                    fSecond = TRUE; <br>                    break; <br>                } <br>            } <br> <br>            if (!fSecond) <br>                WritePrivateProfileString(szCustomDLL, pcl-&gt;pwcd-&gt;pszClass, <br>                        pcl-&gt;pszFileName, ids(IDS_DLGEDITINI)); <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
