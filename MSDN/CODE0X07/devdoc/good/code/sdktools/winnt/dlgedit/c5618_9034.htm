<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SELECT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5620"></a>SELECT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: select.c <br>* <br>* Contains routines for selecting and positioning controls. <br>* <br>* Functions: <br>* <br>*    SelectControl() <br>*    SelectControl2() <br>*    RedrawSelection() <br>*    SetAnchorToFirstSel() <br>*    SelectNext() <br>*    SelectPrevious() <br>*    UnSelectControl() <br>*    CalcSelectedRect() <br>*    CancelSelection() <br>*    OutlineSelectBegin() <br>*    OutlineSelectDraw() <br>*    OutlineSelectCancel() <br>*    OutlineSelectEnd() <br>*    MyFrameRect() <br>*    MoveControl() <br>*    PositionControl() <br>*    RepositionDialog() <br>*    SaveDlgClientRect() <br>*    SizeToText() <br>*    AlignControls() <br>*    ArrangeSpacing() <br>*    ArrangeSize() <br>*    ArrangePushButtons() <br>*    InvalidateDlgHandles() <br>*    OutlineSelectHide() <br>*    OutlineSelectSetRect() <br>*    PositionControl2() <br>*    SizeCtrlToText() <br>*    QueryTextExtent() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br> <br>STATICFN VOID InvalidateDlgHandles(VOID); <br>STATICFN VOID OutlineSelectHide(VOID); <br>STATICFN VOID OutlineSelectSetRect(INT x, INT y); <br>STATICFN HANDLE PositionControl2(NPCTYPE npc, PRECT prc, HANDLE hwpi); <br>STATICFN BOOL SizeCtrlToText(NPCTYPE npc); <br>STATICFN INT QueryTextExtent(HWND hwnd, LPTSTR pszText, BOOL fWordBreak); <br> <br>static POINT gptOutlineSelect; <br>static RECT grcOutlineSelect; <br>static RECT grcOutlineSelectLimit; <br>static BOOL gfOutlineSelectShown = FALSE; <br> <br> <br> <br>/************************************************************************ <br>* SelectControl <br>* <br>* This routine selects a control, showing its drag window and handles. <br>* If fCheckShift is TRUE and the shift key is down, this routine adds <br>* the control to the existing selection, unless the control is already <br>* selected, in which case it is removed from the existing selection. <br>* <br>* This routine handles the case where a controls is clicked on to select <br>* it, and this may cause other controls to be unselected.  If it is <br>* known for sure that a control should be selected or added to the <br>* existing selection, SelectControl2 can be used instead. <br>* <br>* Arguments: <br>*   NPCTYPE npc      = The control to select. <br>*   BOOL fCheckShift = TRUE if the state of the shift key should be <br>*                      taken into consideration. <br>* <br>* Returns: <br>*   The return will be FALSE if the control was just unselected. <br>* <br>************************************************************************/ <br> <br>BOOL SelectControl( <br>    NPCTYPE npc, <br>    BOOL fCheckShift) <br>{ <br>    BOOL fShiftDown; <br>    BOOL fSelectDone = TRUE; <br> <br>    if (npc-&gt;pwcd-&gt;iType == W_DIALOG) { <br>        if (gnpcSel == npc) <br>            return TRUE; <br> <br>        CancelSelection(FALSE); <br>        SelectControl2(npc, FALSE); <br>    } <br>    else { <br>        if (fCheckShift) <br>            fShiftDown = (GetKeyState(VK_SHIFT) &amp; 0x8000) ? TRUE : FALSE; <br>        else <br>            fShiftDown = FALSE; <br> <br>        if (npc-&gt;fSelected) { <br>            /* <br>             * If the shift key is down, and they are NOT trying to <br>             * select the dialog, toggle the selection of this control <br>             * to off. <br>             */ <br>            if (fShiftDown &amp;&amp; npc-&gt;pwcd-&gt;iType != W_DIALOG) { <br>                UnSelectControl(npc); <br>                CalcSelectedRect(); <br>                fSelectDone = FALSE; <br>            } <br>            else { <br>                if (gnpcSel == npc) <br>                    return TRUE; <br>                else <br>                    SelectControl2(npc, FALSE); <br>            } <br>        } <br>        else { <br>            /* <br>             * If they are NOT holding the shift key down, or the <br>             * dialog is selected, cancel the selection first. <br>             */ <br>            if (!fShiftDown || gcd.npc-&gt;fSelected == TRUE) <br>                CancelSelection(FALSE); <br> <br>            SelectControl2(npc, FALSE); <br>        } <br>    } <br> <br>    StatusUpdate(); <br>    StatusSetEnable(); <br> <br>    return fSelectDone; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelectControl2 <br>* <br>* This routine is the worker for SelectControl.  It does the actual <br>* work to "select" a control, updating globals and showing the drag <br>* windows with handles. <br>* <br>* This routine handles the special case where we are selecting a <br>* control that is already selected.  The editor has the concept of <br>* a control being selected, as well as there being the currently <br>* selected control (pointed to by gnpcSel).  There can be the case <br>* where there are multiple controls selected, but only one will be <br>* the current selection (usually the last one clicked on).  This <br>* routine will never unselect other controls.  This must be done <br>* prior to here, if appropriate. <br>* <br>* Arguments: <br>*   NPCTYPE npc      = The control to make the current selection. <br>*   BOOL fDontUpdate = TRUE if the selection should NOT be redrawn <br>*                      after the specified control is added to it. <br>*                      This allows painting to be deferred until <br>*                      later if a number of controls are being <br>*                      selected in a loop.  It also does not call <br>*                      CalcSelectedRect (this MUST be done later <br>*                      for drags to work, however!). <br>* Comments: <br>* <br>* If fDontUpdate is TRUE, the selection will not be redrawn, and it <br>* is required that CalcSelectedRect be called before doing any drag <br>* operations. <br>* <br>************************************************************************/ <br> <br>VOID SelectControl2( <br>    NPCTYPE npc, <br>    BOOL fDontUpdate) <br>{ <br>    BOOL fUpdate = FALSE; <br> <br>    /* <br>     * Is the control already selected? <br>     */ <br>    if (npc-&gt;fSelected) { <br>        /* <br>         * It is already selected (hwndDrag is visible).  If it is <br>         * not the current selection, we want all drag windows to <br>         * be redrawn in the proper order to update their appearance. <br>         */ <br>        if (gnpcSel != npc) <br>            fUpdate = TRUE; <br>    } <br>    else { <br>        /* <br>         * The control is not yet selected.  If another control is <br>         * currently selected, we want all drag windows to be <br>         * updated so that their handle appearance gets updated. <br>         */ <br>        if (gnpcSel) <br>            fUpdate = TRUE; <br> <br>        /* <br>         * Flip its flag and add to the selected count. <br>         */ <br>        npc-&gt;fSelected = TRUE; <br>        gcSelected++; <br>    } <br> <br>    gnpcSel = npc; <br> <br>    if (!fDontUpdate) <br>        CalcSelectedRect(); <br> <br>    if (npc-&gt;pwcd-&gt;iType == W_DIALOG) { <br>        gfDlgSelected = TRUE; <br>        InvalidateDlgHandles(); <br>    } <br>    else { <br>        gfDlgSelected = FALSE; <br>        ShowWindow(npc-&gt;hwndDrag, SW_SHOW); <br> <br>        if (fUpdate &amp;&amp; !fDontUpdate) <br>            RedrawSelection(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* RedrawSelection <br>* <br>* This function cause all the selected drag windows to be invalidated. <br>* This is necessary whenever one of them changes, because of the very <br>* touchy painting order that has to be maintained.  Without invalidating <br>* all of them as a unit, there are cases where handles do not get <br>* properly painted. <br>* <br>************************************************************************/ <br> <br>VOID RedrawSelection(VOID) <br>{ <br>    NPCTYPE npc; <br> <br>    if (!gcSelected) { <br>        return; <br>    } <br>    else if (gcSelected == 1) { <br>        InvalidateRect(gfDlgSelected ? gnpcSel-&gt;hwnd : gnpcSel-&gt;hwndDrag, <br>                NULL, TRUE); <br>    } <br>    else { <br>        for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>            if (npc-&gt;fSelected) <br>                InvalidateRect(npc-&gt;hwndDrag, NULL, TRUE); <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* SetAnchorToFirstSel <br>* <br>* This function makes the current selection (the anchor) be the <br>* first selected control.  It is used after making a group selection, <br>* and ensures that the control that ends up being the anchor is <br>* consistently the first one in Z-order. <br>* <br>* Arguments: <br>*   BOOL fDontUpdate = TRUE if the selection should NOT be redrawn. <br>* <br>************************************************************************/ <br> <br>VOID SetAnchorToFirstSel( <br>    BOOL fDontUpdate) <br>{ <br>    NPCTYPE npc; <br> <br>    if (gcSelected) { <br>        for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>            if (npc-&gt;fSelected) { <br>                SelectControl2(npc, fDontUpdate); <br>                break; <br>            } <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelectNext <br>* <br>* This selects the next control in the dialog box.  The enumeration <br>* includes the dialog box itself, and wraps around. <br>* <br>************************************************************************/ <br> <br>VOID SelectNext(VOID) <br>{ <br>    NPCTYPE npcSelect; <br> <br>    /* <br>     * Disable the tabbing functions if there is no dialog <br>     * or if the dialog is already selected and there are <br>     * no controls (the tabs would be a noop in this case). <br>     */ <br>    if (!gfEditingDlg || (gfDlgSelected &amp;&amp; !npcHead)) <br>        return; <br> <br>    /* <br>     * Is nothing selected? <br>     */ <br>    if (!gnpcSel) { <br>        /* <br>         * Select the first control, unless there are none, in which <br>         * case select the dialog. <br>         */ <br>        if (npcHead) <br>            npcSelect = npcHead; <br>        else <br>            npcSelect = gcd.npc; <br>    } <br>    else { <br>        /* <br>         * Is the dialog selected? <br>         */ <br>        if (gfDlgSelected) { <br>            /* <br>             * Select the first control, unless there are none, in which <br>             * case do nothing. <br>             */ <br>            if (npcHead) <br>                npcSelect = npcHead; <br>            else <br>                npcSelect = NULL; <br>        } <br>        else { <br>            /* <br>             * Find the current control.  If there is one after it, <br>             * select it, otherwise wrap around to the dialog and <br>             * select it. <br>             */ <br>            if (gnpcSel-&gt;npcNext) <br>                npcSelect = gnpcSel-&gt;npcNext; <br>            else <br>                npcSelect = gcd.npc; <br>        } <br>    } <br> <br>    if (npcSelect) <br>        SelectControl(npcSelect, FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SelectPrevious <br>* <br>* This selects the previous control in the dialog box.  The enumeration <br>* includes the dialog box itself, and wraps around. <br>* <br>************************************************************************/ <br> <br>VOID SelectPrevious(VOID) <br>{ <br>    NPCTYPE npc; <br>    NPCTYPE npcSelect; <br> <br>    /* <br>     * Disable the tabbing functions if there is no dialog <br>     * or if the dialog is already selected and there are <br>     * no controls (the tabs would be a noop in this case). <br>     */ <br>    if (!gfEditingDlg || (gfDlgSelected &amp;&amp; !npcHead)) <br>        return; <br> <br>    /* <br>     * Is nothing selected? <br>     */ <br>    if (!gnpcSel) { <br>        /* <br>         * Select the last control, unless there are none, in which <br>         * case select the dialog. <br>         */ <br>        if (npcHead) { <br>            npc = npcHead; <br>            while (npc-&gt;npcNext) <br>                npc = npc-&gt;npcNext; <br> <br>            npcSelect = npc; <br>        } <br>        else { <br>            npcSelect = gcd.npc; <br>        } <br>    } <br>    else { <br>        /* <br>         * Is the dialog selected? <br>         */ <br>        if (gfDlgSelected) { <br>            /* <br>             * Select the last control, unless there are none, in which <br>             * case select nothing. <br>             */ <br>            if (npcHead) { <br>                npc = npcHead; <br>                while (npc-&gt;npcNext) <br>                    npc = npc-&gt;npcNext; <br> <br>                npcSelect = npc; <br>            } <br>            else { <br>                npcSelect = NULL; <br>            } <br>        } <br>        else { <br>            /* <br>             * If the first control is selected, select the dialog. <br>             * Otherwise hunt for and select the previous control. <br>             */ <br>            if (npcHead == gnpcSel) { <br>                npcSelect = gcd.npc; <br>            } <br>            else { <br>                npc = npcHead; <br>                while (npc-&gt;npcNext != gnpcSel) <br>                    npc = npc-&gt;npcNext; <br> <br>                npcSelect = npc; <br>            } <br>        } <br>    } <br> <br>    if (npcSelect) <br>        SelectControl(npcSelect, FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* UnSelectControl <br>* <br>* This unselects the specified control, hiding its drag window and handles. <br>* <br>* Arguments: <br>*     NPCTYPE npc = The control to deselect. <br>* <br>************************************************************************/ <br> <br>VOID UnSelectControl( <br>    NPCTYPE npc) <br>{ <br>    npc-&gt;fSelected = FALSE; <br>    gcSelected--; <br> <br>    /* <br>     * We don't have a current selection if there are no selected <br>     * windows, or if the control we are unselecting was the current <br>     * selection. <br>     */ <br>    if (!gcSelected || npc == gnpcSel) <br>        gnpcSel = NULL; <br> <br>    if (npc-&gt;pwcd-&gt;iType == W_DIALOG) { <br>        gfDlgSelected = FALSE; <br>        InvalidateDlgHandles(); <br>    } <br>    else { <br>        ShowWindow(npc-&gt;hwndDrag, SW_HIDE); <br>    } <br> <br>    /* <br>     * Are there still some selected controls, and was the control <br>     * we just unselected the current selection?  If so, we need <br>     * to set the current selection to something. <br>     */ <br>    if (gcSelected &amp;&amp; !gnpcSel) <br>        SetAnchorToFirstSel(FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* InvalidateDlgHandles <br>* <br>* This function invalidates the handles for the dialog.  This is <br>* used as an optimization so that the entire dialog does not need <br>* to be invalidated just to force the handles to be drawn. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID InvalidateDlgHandles(VOID) <br>{ <br>    RECT rc; <br>    RECT rcClient; <br>    RECT rcFrame; <br>    POINT pt; <br>    INT xOffset; <br>    INT yOffset; <br> <br>    /* <br>     * Redraw the dialog border. <br>     */ <br>    SetWindowPos(gcd.npc-&gt;hwnd, NULL, 0, 0, 0, 0, <br>            SWP_DRAWFRAME | SWP_NOACTIVATE | <br>            SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* <br>     * Get the frame and client rectangles. <br>     */ <br>    GetWindowRect(gcd.npc-&gt;hwnd, &amp;rcFrame); <br>    GetClientRect(gcd.npc-&gt;hwnd, &amp;rcClient); <br> <br>    /* <br>     * Determine the offset from the frame origin to the client <br>     * origin. <br>     */ <br>    pt.x = pt.y = 0; <br>    ClientToScreen(gcd.npc-&gt;hwnd, &amp;pt); <br>    xOffset = rcFrame.left - pt.x; <br>    yOffset = rcFrame.top - pt.y; <br> <br>    /* <br>     * Make the frame rectangle zero based. <br>     */ <br>    OffsetRect(&amp;rcFrame, -rcFrame.left, -rcFrame.top); <br> <br>    rc.left = 0; <br>    rc.top = 0; <br>    rc.right = CHANDLESIZE; <br>    rc.bottom = CHANDLESIZE; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = ((rcFrame.right + 1) / 2) - (CHANDLESIZE / 2); <br>    rc.top = 0; <br>    rc.right = rc.left + CHANDLESIZE; <br>    rc.bottom = CHANDLESIZE; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = rcFrame.right - CHANDLESIZE; <br>    rc.top = 0; <br>    rc.right = rcFrame.right; <br>    rc.bottom = CHANDLESIZE; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = rcFrame.right - CHANDLESIZE; <br>    rc.top = ((rcFrame.bottom + 1) / 2) - (CHANDLESIZE / 2); <br>    rc.right = rcFrame.right; <br>    rc.bottom = rc.top + CHANDLESIZE; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = rcFrame.right - CHANDLESIZE; <br>    rc.top = rcFrame.bottom - CHANDLESIZE; <br>    rc.right = rcFrame.right; <br>    rc.bottom = rcFrame.bottom; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = ((rcFrame.right + 1) / 2) - (CHANDLESIZE / 2); <br>    rc.top = rcFrame.bottom - CHANDLESIZE; <br>    rc.right = rc.left + CHANDLESIZE; <br>    rc.bottom = rcFrame.bottom; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = 0; <br>    rc.top = rcFrame.bottom - CHANDLESIZE; <br>    rc.right = CHANDLESIZE; <br>    rc.bottom = rcFrame.bottom; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br> <br>    rc.left = 0; <br>    rc.top = ((rcFrame.bottom + 1) / 2) - (CHANDLESIZE / 2); <br>    rc.right = CHANDLESIZE; <br>    rc.bottom = rc.top + CHANDLESIZE; <br>    OffsetRect(&amp;rc, xOffset, yOffset); <br>    InvalidateRect(gcd.npc-&gt;hwnd, &amp;rc, TRUE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CalcSelectedRect <br>* <br>* This routine updates the gwrcSelected rectangle.  This is used during <br>* dragging operations.  It contains the minimum rectangle that spans <br>* all the selected controls.  If there are no selected controls, the <br>* contents of this global are not defined.  This routine must be called <br>* every time that a control is selected of unselected to keep this <br>* rectangle updated, or tracking will not work properly. <br>* <br>************************************************************************/ <br> <br>VOID CalcSelectedRect(VOID) <br>{ <br>    NPCTYPE npc; <br>    INT nBottom; <br>    INT nBottomLowest; <br> <br>    /* <br>     * Nothing is selected.  The rectangle values are considered <br>     * undefined, so we can quit. <br>     */ <br>    if (!gcSelected) <br>        return; <br> <br>    if (gcSelected == 1) { <br>        /* <br>         * Only one control is selected.  Set the rectangle to its <br>         * rectangle.  Note that since the dialog cannot be selected <br>         * along with other controls, this handles the case where the <br>         * dialog is selected. <br>         */ <br>        grcSelected = gnpcSel-&gt;rc; <br>        gnOverHang = GetOverHang(gnpcSel-&gt;pwcd-&gt;iType, <br>                gnpcSel-&gt;rc.bottom - gnpcSel-&gt;rc.top); <br>    } <br>    else { <br>        /* <br>         * Seed the rectangle with impossible values. <br>         */ <br>        SetRect(&amp;grcSelected, 32000, 32000, -32000, -32000); <br>        nBottomLowest = 0; <br> <br>        /* <br>         * Loop through all the controls, expanding the rectangle to <br>         * fit around all the selected controls. <br>         */ <br>        for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>            if (npc-&gt;fSelected) { <br>                if (npc-&gt;rc.left &lt; grcSelected.left) <br>                    grcSelected.left = npc-&gt;rc.left; <br> <br>                if (npc-&gt;rc.right &gt; grcSelected.right) <br>                    grcSelected.right = npc-&gt;rc.right; <br> <br>                if (npc-&gt;rc.top &lt; grcSelected.top) <br>                    grcSelected.top = npc-&gt;rc.top; <br> <br>                nBottom = npc-&gt;rc.bottom - GetOverHang(npc-&gt;pwcd-&gt;iType, <br>                        npc-&gt;rc.bottom - npc-&gt;rc.top); <br>                if (nBottom &gt; nBottomLowest) <br>                    nBottomLowest = nBottom; <br> <br>                if (npc-&gt;rc.bottom &gt; grcSelected.bottom) <br>                    grcSelected.bottom = npc-&gt;rc.bottom; <br>            } <br>        } <br> <br>        gnOverHang = grcSelected.bottom - nBottomLowest; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* CancelSelection <br>* <br>* This unselects all selected controls. <br>* <br>* Arguments: <br>*   BOOL fUpdate - If TRUE, the status ribbon is updated. <br>* <br>************************************************************************/ <br> <br>VOID CancelSelection( <br>    BOOL fUpdate) <br>{ <br>    if (gcSelected) { <br>        while (gcSelected) <br>            UnSelectControl(gnpcSel); <br> <br>        if (fUpdate) { <br>            StatusUpdate(); <br>            StatusSetEnable(); <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* OutlineSelectBegin <br>* <br>* This function begins an Outline Selection operation.  This will <br>* draw a tracking rectangle on the screen that can be used to enclose <br>* controls.  When the selection is completed, all the enclosed controls <br>* will be selected. <br>* <br>* The x and y coordinates are relative to the dialog window, not it's <br>* client. <br>* <br>* Arguments: <br>*   INT x   - Starting X location (window coords). <br>*   INT y   - Starting Y location (window coords). <br>* <br>************************************************************************/ <br> <br>VOID OutlineSelectBegin( <br>    INT x, <br>    INT y) <br>{ <br>    /* <br>     * Always be sure the focus is where we want it, not on something <br>     * like the status ribbon or "Esc" won't work to cancel the tracking. <br>     */ <br>    SetFocus(ghwndMain); <br> <br>    /* <br>     * Remember the starting point.  It comes in coords relative to the <br>     * window, and the DC we are getting is one for the dialog's client, <br>     * so we have to map it from window coords to the client's coords. <br>     */ <br>    gptOutlineSelect.x = x; <br>    gptOutlineSelect.y = y; <br>    MapDlgClientPoint(&amp;gptOutlineSelect, FALSE); <br> <br>    gState = STATE_SELECTING; <br>    ghwndTrackOver = gcd.npc-&gt;hwnd; <br>    ghDCTrack = GetDC(ghwndTrackOver); <br>    SetROP2(ghDCTrack, R2_NOT); <br> <br>    /* <br>     * Get the rectangle for the client area of the dialog.  This is <br>     * used to limit the tracking. <br>     */ <br>    GetClientRect(gcd.npc-&gt;hwnd, &amp;grcOutlineSelectLimit); <br>    OutlineSelectDraw(x, y); <br> <br>    /* <br>     * The mouse messages from now on will go to the dialog window, <br>     * so that the following routines can know that the mouse movement <br>     * points are relative to that window. <br>     */ <br>    SetCapture(gcd.npc-&gt;hwnd); <br> <br>    SetCursor(hcurOutSel); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OutlineSelectDraw <br>* <br>* This routine draws the outline selection rectangle.  It is assumed <br>* that the window has been locked for update appropriately or this <br>* could leave garbage around.  The outline selection rectangle is <br>* drawn from the starting point in gptOutlineSelect to the given <br>* x,y location. <br>* <br>* Arguments: <br>*   INT x   - Mouse X location (window coords relative to the dialog). <br>*   INT y   - Mouse Y location (window coords relative to the dialog). <br>* <br>************************************************************************/ <br> <br>VOID OutlineSelectDraw( <br>    INT x, <br>    INT y) <br>{ <br>    OutlineSelectHide(); <br>    OutlineSelectSetRect(x, y); <br>    MyFrameRect(ghDCTrack, &amp;grcOutlineSelect, DSTINVERT); <br>    gfOutlineSelectShown = TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OutlineSelectHide <br>* <br>* This routine hides the current outline selection rectangle. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OutlineSelectHide(VOID) <br>{ <br>    if (gfOutlineSelectShown) { <br>        MyFrameRect(ghDCTrack, &amp;grcOutlineSelect, DSTINVERT); <br>        gfOutlineSelectShown = FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* OutlineSelectSetRect <br>* <br>* This function takes an x,y point and makes a rectangle that goes <br>* from this point to the starting outline selection point.  The cases <br>* are handled where the new point has negative coordinates relative <br>* to the starting point, and the rectangle produced is limited to <br>* the rectangle in grcOutlineSelectLimit. <br>* <br>* The rectangle is placed into the global grcOutlineSelect.  The <br>* global point gwptOutlineSelect is assumed to have previously been <br>* set to the starting point of the outline selection. <br>* <br>* The x and y coordinates are relative to the dialog window, not it's <br>* client. <br>* <br>* Arguments: <br>*   INT x   - Mouse X location (window coords relative to the dialog). <br>*   INT y   - Mouse Y location (window coords relative to the dialog). <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OutlineSelectSetRect( <br>    INT x, <br>    INT y) <br>{ <br>    POINT pt; <br> <br>    /* <br>     * The point is coming in relative to the upper left of the <br>     * dialog window.  It needs to be mapped to points relative <br>     * to the client of the dialog window. <br>     */ <br>    pt.x = x; <br>    pt.y = y; <br>    MapDlgClientPoint(&amp;pt, FALSE); <br> <br>    if (pt.x &gt; gptOutlineSelect.x) { <br>        grcOutlineSelect.left = gptOutlineSelect.x; <br>        grcOutlineSelect.right = pt.x; <br>    } <br>    else { <br>        grcOutlineSelect.left = pt.x; <br>        grcOutlineSelect.right = gptOutlineSelect.x; <br>    } <br> <br>    if (pt.y &gt; gptOutlineSelect.y) { <br>        grcOutlineSelect.top = gptOutlineSelect.y; <br>        grcOutlineSelect.bottom = pt.y; <br>    } <br>    else { <br>        grcOutlineSelect.top = pt.y; <br>        grcOutlineSelect.bottom = gptOutlineSelect.y; <br>    } <br> <br>    if (grcOutlineSelect.left &lt; grcOutlineSelectLimit.left) <br>        grcOutlineSelect.left = grcOutlineSelectLimit.left; <br> <br>    if (grcOutlineSelect.right &gt; grcOutlineSelectLimit.right) <br>        grcOutlineSelect.right = grcOutlineSelectLimit.right; <br> <br>    if (grcOutlineSelect.top &lt; grcOutlineSelectLimit.top) <br>        grcOutlineSelect.top = grcOutlineSelectLimit.top; <br> <br>    if (grcOutlineSelect.bottom &gt; grcOutlineSelectLimit.bottom) <br>        grcOutlineSelect.bottom = grcOutlineSelectLimit.bottom; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OutlineSelectCancel <br>* <br>* This routine is used to cancel the display of the outline selection <br>* rectangle. <br>* <br>************************************************************************/ <br> <br>VOID OutlineSelectCancel(VOID) <br>{ <br>    OutlineSelectHide(); <br>    ReleaseDC(ghwndTrackOver, ghDCTrack); <br> <br>    gState = STATE_NORMAL; <br>    ReleaseCapture(); <br>    SetCursor(hcurArrow); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OutlineSelectEnd <br>* <br>* This function completes an outline selection operation.  All the <br>* enclosed controls will be selected.  If the Shift key is down, <br>* the enclosed controls will be added to the selection, otherwise the <br>* current selection will be cancelled first. <br>* <br>* The current selection will only be cancelled if there is <br>* at least one new control enclosed.  This is so that simply clicking and <br>* releasing the mouse without enclosing any controls leaves the current <br>* selection alone. <br>* <br>* Arguments: <br>*   INT x   - Mouse X location (dialog client coords). <br>*   INT y   - Mouse Y location (dialog client coords). <br>* <br>************************************************************************/ <br> <br>VOID OutlineSelectEnd( <br>    INT x, <br>    INT y) <br>{ <br>    NPCTYPE npc; <br>    BOOL fFirstOne = TRUE; <br> <br>    OutlineSelectCancel(); <br>    OutlineSelectSetRect(x, y); <br> <br>    /* <br>     * If the mouse was not moved at all, consider this a request <br>     * to select the dialog instead of an outline selection operation. <br>     */ <br>    if (grcOutlineSelect.left == grcOutlineSelect.right &amp;&amp; <br>            grcOutlineSelect.top == grcOutlineSelect.bottom) { <br>        SelectControl(gcd.npc, FALSE); <br>        return; <br>    } <br> <br>    /* <br>     * Convert the selected rectangle to dialog units. <br>     */ <br>    WinToDURect(&amp;grcOutlineSelect); <br> <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        /* <br>         * Do the rectangles intersect? <br>         */ <br>        if (npc-&gt;rc.left &lt; grcOutlineSelect.right &amp;&amp; <br>                grcOutlineSelect.left &lt; npc-&gt;rc.right &amp;&amp; <br>                npc-&gt;rc.bottom &gt; grcOutlineSelect.top &amp;&amp; <br>                grcOutlineSelect.bottom &gt; npc-&gt;rc.top) { <br>            if (fFirstOne) { <br>                /* <br>                 * If the Shift key is not held down, cancel any outstanding <br>                 * selections. <br>                 */ <br>                if (!(GetKeyState(VK_SHIFT) &amp; 0x8000)) <br>                    CancelSelection(FALSE); <br> <br>                fFirstOne = FALSE; <br>            } <br> <br>            /* <br>             * If the control is not selected, select it. <br>             */ <br>            if (!npc-&gt;fSelected) <br>                SelectControl2(npc, TRUE); <br>        } <br>    } <br> <br>    /* <br>     * Update some things if there was at least one control enclosed. <br>     */ <br>    if (!fFirstOne) { <br>        SetAnchorToFirstSel(TRUE); <br>        StatusUpdate(); <br>        StatusSetEnable(); <br>        RedrawSelection(); <br>        CalcSelectedRect(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* MyFrameRect <br>* <br>* This function draws a one-pixel width rectangle using the given <br>* raster operation. <br>* <br>* Arguments: <br>*   HDC hDC     - DC to use. <br>*   PRECT prc   - Rectangle to draw the frame around. </code></pre>
<p>
</p>
<pre><code>*   DWORD dwRop - RasterOp to use (DSTINVERT, BLACKNESS, etc.). <br>* <br>************************************************************************/ <br> <br>VOID MyFrameRect( <br>    HDC hDC, <br>    PRECT prc, <br>    DWORD dwRop) <br>{ <br>    INT x; <br>    INT y; <br>    POINT pt; <br> <br>    x = prc-&gt;right  - (pt.x = prc-&gt;left); <br>    y = prc-&gt;bottom - (pt.y = prc-&gt;top); <br> <br>    PatBlt(hDC, pt.x, pt.y, x, 1, dwRop); <br>    pt.y = prc-&gt;bottom - 1; <br>    PatBlt(hDC, pt.x, pt.y, x, 1, dwRop); <br>    pt.y = prc-&gt;top; <br>    PatBlt(hDC, pt.x, pt.y, 1, y, dwRop); <br>    pt.x = prc-&gt;right - 1; <br>    PatBlt(hDC, pt.x, pt.y, 1, y, dwRop); <br>} <br> <br> <br> <br>/************************************************************************ <br>* MoveControl <br>* <br>* This function moves the current control to the next grid boundary in <br>* the specified direction. <br>* <br>* Arguments: <br>*   WPARAM vKey - Virtual key code that was pressed. <br>* <br>************************************************************************/ <br> <br>VOID MoveControl( <br>    WPARAM vKey) <br>{ <br>    RECT rc; <br>    INT dx; <br>    INT dy; <br> <br>    /* <br>     * Nothing is selected. <br>     */ <br>    if (!gcSelected) <br>        return; <br> <br>    rc = grcSelected; <br> <br>    switch (vKey) { <br>        case VK_UP: <br>            dx = 0; <br>            if (!(dy = -(rc.top % gcyGrid))) <br>                dy = -gcyGrid; <br>            break; <br> <br>        case VK_DOWN: <br>            dx = 0; <br>            dy = gcyGrid - (rc.top % gcyGrid); <br>            break; <br> <br>        case VK_RIGHT: <br>            dx = gcxGrid - (rc.left % gcxGrid); <br>            dy = 0; <br>            break; <br> <br>        case VK_LEFT: <br>            if (!(dx = -(rc.left % gcxGrid))) <br>                dx = -gcxGrid; <br>            dy = 0; <br>            break; <br>    } <br> <br>    OffsetRect(&amp;rc, dx, dy); <br>    FitRectToBounds(&amp;rc, gnOverHang, DRAG_CENTER, gfDlgSelected); <br>    gHandleHit = DRAG_CENTER; <br>    PositionControl(&amp;rc); <br>} <br> <br> <br> <br>/************************************************************************ <br>* PositionControl <br>* <br>* This function positions and sizes the current control.  Both the control <br>* window and its associated drag window are moved at the same time.  The <br>* coordinates in the control, and the status window display are updated. <br>* The given rectangle is in dialog units, and it should have already been <br>* range limited and grid aligned as appropriate. <br>* <br>* Arguments: <br>*   NPWRECT nprc - The rectangle to size/position the control with. <br>* <br>************************************************************************/ <br> <br>VOID PositionControl( <br>    PRECT prc) <br>{ <br>    INT cx; <br>    INT cy; <br>    RECT rcT; <br>    NPCTYPE npcT; <br>    HANDLE hwpi; <br> <br>    if (gcSelected == 1) { <br>        /* <br>         * Did nothing change? <br>         */ <br>        if (EqualRect(prc, &amp;gnpcSel-&gt;rc)) <br>            return; <br> <br>        /* <br>         * Only a single control is selected.  Move it. <br>         */ <br>        PositionControl2(gnpcSel, prc, NULL); <br> <br>        /* <br>         * Is the dialog selected, being sized (not just moved), and <br>         * does it have at least one control? <br>         */ <br>        if (gfDlgSelected &amp;&amp; gHandleHit != DRAG_CENTER &amp;&amp; npcHead) { <br>            cx = prc-&gt;left - grcSelected.left; <br>            cy = prc-&gt;top - grcSelected.top; <br> <br>            /* <br>             * Did the top or left edge of the dialog move? <br>             */ <br>            if (cx || cy) { <br>                /* <br>                 * Loop through all the controls.  Move all of them by <br>                 * the dialog movement delta. <br>                 */ <br>                hwpi = BeginDeferWindowPos(cWindows * 2); <br>                for (npcT = npcHead; npcT; npcT = npcT-&gt;npcNext) { <br>                    SetRect(&amp;rcT, npcT-&gt;rc.left - cx, npcT-&gt;rc.top - cy, <br>                            npcT-&gt;rc.right - cx, npcT-&gt;rc.bottom - cy); <br>                    hwpi = PositionControl2(npcT, &amp;rcT, hwpi); <br>                } <br>                EndDeferWindowPos(hwpi); <br>            } <br>        } <br>    } <br>    else { <br>        /* <br>         * Did nothing change? <br>         */ <br>        if (EqualRect(prc, &amp;grcSelected)) <br>            return; <br> <br>        /* <br>         * There is a group of controls selected. <br>         * Calculate how much the group rectangle was moved. <br>         * It is assumed that a group of controls cannot be <br>         * sized, only moved. <br>         */ <br>        cx = prc-&gt;left - grcSelected.left; <br>        cy = prc-&gt;top - grcSelected.top; <br> <br>        /* <br>         * Loop through all the controls.  Move all the selected <br>         * ones by the group delta. <br>         */ <br>        hwpi = BeginDeferWindowPos(gcSelected * 2); <br>        for (npcT = npcHead; npcT; npcT = npcT-&gt;npcNext) { <br>            if (npcT-&gt;fSelected) { <br>                SetRect(&amp;rcT, <br>                        npcT-&gt;rc.left + cx, npcT-&gt;rc.top + cy, <br>                        npcT-&gt;rc.right + cx, npcT-&gt;rc.bottom + cy); <br>                GridizeRect(&amp;rcT, <br>                        GRIDIZE_LEFT | GRIDIZE_TOP | GRIDIZE_SAMESIZE); <br>                FitRectToBounds(&amp;rcT, <br>                        GetOverHang(npcT-&gt;pwcd-&gt;iType, <br>                        npcT-&gt;rc.bottom - npcT-&gt;rc.top), <br>                        DRAG_CENTER, gfDlgSelected); <br>                hwpi = PositionControl2(npcT, &amp;rcT, hwpi); <br>            } <br>        } <br>        EndDeferWindowPos(hwpi); <br>    } <br> <br>    CalcSelectedRect(); <br>    StatusSetCoords(&amp;gnpcSel-&gt;rc); <br>    gfResChged = gfDlgChanged = TRUE; <br>    ShowFileStatus(FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* PositionControl2 <br>* <br>* This function positions and sizes a single control.  Both the control <br>* window and its associated drag window are moved at the same time.  The <br>* coordinates in the control are updated. <br>* <br>* The given rectangle is in dialog units, and it should have already been <br>* range limited and grid aligned as appropriate. <br>* <br>* Arguments: <br>*   NPCTYPE npc - The control to position. <br>*   PRECT prc   - The rectangle to size/position the control with. <br>*   HANDLE hwpi - Handle that has been returned from a BeginDeferWindowPos <br>*                 call.  If this parameter is not NULL, the calls to <br>*                 position the control and drag window will use this <br>*                 handle. <br>* <br>* Returns: <br>* <br>* The return will be the hwpi handle that is currently being used. <br>* The variable that the caller is using must be updated with the <br>* return value each call, because each call to DeferWindowPos can <br>* possibly change this value. <br>* <br>************************************************************************/ <br> <br>STATICFN HANDLE PositionControl2( <br>    NPCTYPE npc, <br>    PRECT prc, <br>    HANDLE hwpi) <br>{ <br>    RECT rc; <br>    RECT rcDrag; <br>    HANDLE hwpi2; <br> <br>    /* <br>     * Make a local copy of the rectangle. <br>     */ <br>    rc = *prc; <br> <br>    /* <br>     * Start calculating the new position.  Begin by mapping the dialog <br>     * points to window coordinates. <br>     */ <br>    DUToWinRect(&amp;rc); <br> <br>    if (npc-&gt;pwcd-&gt;iType == W_DIALOG) { <br>        InvalidateDlgHandles(); <br> <br>        AdjustWindowRectEx(&amp;rc, npc-&gt;flStyle, FALSE, <br>                (npc-&gt;flStyle &amp; DS_MODALFRAME) ? <br>                npc-&gt;flExtStyle | WS_EX_DLGMODALFRAME : npc-&gt;flExtStyle); <br>        ClientToScreenRect(ghwndSubClient, &amp;rc); <br>        MoveWindow(npc-&gt;hwnd, rc.left, rc.top, <br>                rc.right - rc.left, rc.bottom - rc.top, TRUE); <br> <br>        /* <br>         * Update the control structure with the new rectangle. <br>         */ <br>        npc-&gt;rc = *prc; <br> <br>        /* <br>         * Since this was the dialog that was just positioned, we need to <br>         * recalculate and save the size of its "client" area. <br>         */ <br>        SaveDlgClientRect(npc-&gt;hwnd); <br>    } <br>    else { <br>        rcDrag = rc; <br>        InflateRect(&amp;rcDrag, CHANDLESIZE / 2, CHANDLESIZE / 2); <br> <br>        if (hwpi) <br>            hwpi2 = hwpi; <br>        else <br>            hwpi2 = BeginDeferWindowPos(2); <br> <br>        hwpi2 = DeferWindowPos(hwpi2, npc-&gt;hwndDrag, NULL, <br>                rcDrag.left, rcDrag.top, <br>                rcDrag.right - rcDrag.left, rcDrag.bottom - rcDrag.top, <br>                SWP_NOACTIVATE | SWP_NOZORDER); <br> <br>        hwpi2 = DeferWindowPos(hwpi2, npc-&gt;hwnd, NULL, rc.left, rc.top, <br>                rc.right - rc.left, rc.bottom - rc.top, <br>                SWP_NOACTIVATE | SWP_NOZORDER); <br> <br>        if (!hwpi) <br>            EndDeferWindowPos(hwpi2); <br> <br>        /* <br>         * Update the control structure with the new rectangle. <br>         */ <br>        npc-&gt;rc = *prc; <br> <br>        InvalidateRect(npc-&gt;hwndDrag, NULL, TRUE); <br>    } <br> <br>    return hwpi2; <br>} <br> <br> <br> <br>/************************************************************************ <br>* RepositionDialog <br>* <br>* This routine forces the dialog to be moved to the location that <br>* is stored in it's npc rectangle.  This is necessary after the <br>* main application has been moved, because the dialog is relative <br>* to the app's window and does not automatically move with it. <br>* <br>************************************************************************/ <br> <br>VOID RepositionDialog(VOID) <br>{ <br>    PositionControl2(gcd.npc, &amp;gcd.npc-&gt;rc, NULL); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SaveDlgClientRect <br>* <br>* This routine saves away a global that will contain the offset, in window <br>* coordinates, of the origin of the "client" area for the current dialog. <br>* <br>* Arguments: <br>*   HWND hwndDlg - The dialog window. <br>* <br>************************************************************************/ <br> <br>VOID SaveDlgClientRect( <br>    HWND hwndDlg) <br>{ <br>    RECT rcFrame; <br>    POINT pt; <br> <br>    GetWindowRect(hwndDlg, &amp;rcFrame); <br>    GetClientRect(hwndDlg, &amp;grcDlgClient); <br>    pt.x = pt.y = 0; <br>    ClientToScreen(hwndDlg, &amp;pt); <br>    OffsetRect(&amp;grcDlgClient, pt.x - rcFrame.left, pt.y - rcFrame.top); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SizeToText <br>* <br>* This function will size all the selected controls to fit their text. <br>* This is to support the "Size to text" command of the "Edit" menu. <br>* <br>* Globals are updated appropriately if anything actually had to change. <br>* <br>************************************************************************/ <br> <br>VOID SizeToText(VOID) <br>{ <br>    NPCTYPE npc; <br>    BOOL fSized = FALSE; <br> <br>    /* <br>     * Loop through all the controls. <br>     */ <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        /* <br>         * Is the control selected, and can it be sized to its text? <br>         */ <br>        if (npc-&gt;fSelected &amp;&amp; npc-&gt;pwcd-&gt;fSizeToText) <br>            fSized |= SizeCtrlToText(npc); <br>    } <br> <br>    /* <br>     * Was anything modified? <br>     */ <br>    if (fSized) { <br>        CalcSelectedRect(); <br>        StatusSetCoords(&amp;gnpcSel-&gt;rc); <br>        gfResChged = gfDlgChanged = TRUE; <br>        ShowFileStatus(FALSE); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* SizeCtrlToText <br>* <br>* This function sizes a single control so that it just fits its text. <br>* This does not make sense for all controls (see the fSizeToText flag <br>* in the awcd array), and there are different rules for the different <br>* types of controls. <br>* <br>* Arguments: <br>*   NPCTYPE npc - The control to size. <br>* <br>* Returns: <br>* <br>* The return value is TRUE if the control was modified (sized) or <br>* FALSE if it was not. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL SizeCtrlToText( <br>    NPCTYPE npc) <br>{ <br>    RECT rc; <br>    INT x; <br>    INT cxLowern; <br> <br>    switch (npc-&gt;pwcd-&gt;iType) { <br>        case W_CHECKBOX: <br>            /* <br>             * Take the width of the text, plus some pixels for the square. <br>             */ <br>            x = QueryTextExtent(npc-&gt;hwnd, npc-&gt;text, TRUE) + 20; <br>            x = MulDiv(x, 4, gcd.cxChar) + 1; <br>            break; <br> <br>        case W_PUSHBUTTON: <br>            /* <br>             * The UITF definition of the size of a pushbutton says <br>             * that the left and right margins should be approximately <br>             * the width of a lowercase "n".  In any event, the width <br>             * cannot be less than the default size. <br>             */ <br>            cxLowern = QueryTextExtent(npc-&gt;hwnd, L"n", FALSE); <br>            x = QueryTextExtent(npc-&gt;hwnd, npc-&gt;text, FALSE) + (2 * cxLowern); <br>            x = MulDiv(x, 4, gcd.cxChar); <br> <br>            if (x &lt; awcd[W_PUSHBUTTON].cxDefault) <br>                x = awcd[W_PUSHBUTTON].cxDefault; <br> <br>            break; <br> <br>        case W_RADIOBUTTON: <br>            /* <br>             * Take the width of the text, plus some for the circle. <br>             */ <br>            x = QueryTextExtent(npc-&gt;hwnd, npc-&gt;text, TRUE) + 20; <br>            x = MulDiv(x, 4, gcd.cxChar) + 1; <br>            break; <br> <br>        case W_TEXT: <br>            /* <br>             * Take the width of the text. <br>             */ <br>            x = QueryTextExtent(npc-&gt;hwnd, npc-&gt;text, TRUE); <br>            x = MulDiv(x, 4, gcd.cxChar) + 1; <br>            break; <br> <br>        case W_CUSTOM: <br>            /* <br>             * Call out to the custom control and let it decide <br>             * how wide the text should be. <br>             */ <br>            x = CallCustomSizeToText(npc); <br>            break; <br> <br>        default: <br>            x = -1; <br>            break; <br>    } <br> <br>    /* <br>     * Does it need to be sized? <br>     */ <br>    if (x != -1 &amp;&amp; x != npc-&gt;rc.right - npc-&gt;rc.left) { <br>        /* <br>         * Now that we know the size we want the control, position <br>         * it to change that size.  Note that we do NOT gridize <br>         * the left edge here.  The user probably just wants the <br>         * right edge of the control to be adjusted to fit the new <br>         * text, and probably does not want the left edge shifting <br>         * on them. <br>         */ <br>        rc = npc-&gt;rc; <br>        rc.right = rc.left + x; <br>        FitRectToBounds(&amp;rc, <br>                GetOverHang(npc-&gt;pwcd-&gt;iType, npc-&gt;rc.bottom - npc-&gt;rc.top), <br>                DRAG_CENTER, gfDlgSelected); <br>        PositionControl2(npc, &amp;rc, NULL); <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* QueryTextExtent <br>* <br>* This function takes a window handle and text, and will return the <br>* number of pixels that the specified text is wide in that window. <br>* It is used to determine how wide a control needs to be to display <br>* its text. <br>* <br>* The font set into the current dialog is taken into consideration <br>* when calculating the size. <br>* <br>* Arguments: <br>*   HWND hwnd       - The control window handle. <br>*   LPTSTR pszText  - The text of the control. <br>*   BOOL fWordBreak - TRUE if this text will be drawn with DT_WORDBREAK. <br>* <br>* Returns: <br>* <br>* The number of pixels wide the selected text is. <br>* <br>************************************************************************/ <br> <br>STATICFN INT QueryTextExtent( <br>    HWND hwnd, <br>    LPTSTR pszText, <br>    BOOL fWordBreak) <br>{ <br>    HDC hDC; <br>    INT iHeight; <br>    RECT rc; <br>    INT nLen; <br>    HFONT hfontOld; <br> <br>    if (!pszText || *pszText == CHAR_NULL) <br>        return 0; <br> <br>    hDC = GetDC(hwnd); <br> <br>    /* <br>     * If there is a valid font, select it into the DC.  Note that <br>     * we look at gcd.hFont instead of gcd.fFontSpecified, because <br>     * it is possible to specify a font for the dialog but not have <br>     * been able to create it. <br>     */ <br>    if (gcd.hFont) <br>        hfontOld = SelectObject(hDC, gcd.hFont); <br> <br>    /* <br>     * First, calculate the length of the text. <br>     */ <br>    rc.left = rc.top = 0; <br>    rc.right = 10000; <br>    rc.bottom = 10000; <br>    nLen = lstrlen(pszText); <br>    DrawText(hDC, pszText, nLen, &amp;rc, <br>            DT_CALCRECT | DT_NOCLIP | DT_EXPANDTABS); <br> <br>    /* <br>     * First save the height of the line.  This works because the <br>     * DrawText call above with DT_CALCRECT will always draw on <br>     * a single line.  Then we move the upwards the rectangle to draw <br>     * in a large amount, so that it is outside the dimensions of <br>     * the control.  Finally, we do a real draw of the text, <br>     * increasing the width a little each time until we are able <br>     * to draw entirely on one line.  This is inefficient, but it does <br>     * ensure that the returned width will be enough to actually <br>     * draw the string. <br>     */ <br>    if (fWordBreak) { <br>        iHeight = rc.bottom - rc.top; <br>        rc.top -= 10000; <br>        rc.bottom -= 10000; <br>        while (TRUE) { <br>            /* <br>             * Determine if we have enough width to draw on a single <br>             * line yet. <br>             */ <br>            if (DrawText(hDC, pszText, nLen, &amp;rc, <br>                    DT_NOCLIP | DT_EXPANDTABS | DT_WORDBREAK) == iHeight) <br>                break; <br> <br>            /* <br>             * Nope, push the right margin out and try again... <br>             */ <br>            rc.right++; <br>        } <br>    } <br> <br>    if (gcd.hFont) <br>        SelectObject(hDC, hfontOld); <br> <br>    ReleaseDC(hwnd, hDC); <br> <br>    return rc.right - rc.left; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AlignControls <br>* <br>* This function will align all the selected controls.  The point to <br>* align to is always taken from the currently selected control. <br>* <br>* In all cases, the resulting desired position of the control will be <br>* gridized and limited to the dialogs "client" area.  The size of the <br>* controls will not be changed. <br>* <br>* Arguments: <br>*   INT cmd - The alignment menu command. <br>* <br>*   The following are valid values for cmd: <br>* <br>*   MENU_ALIGNLEFT      - Align to the left edge. <br>*   MENU_ALIGNVERT      - Align to the center vertically. <br>*   MENU_ALIGNRIGHT     - Align to the right edge. <br>*   MENU_ALIGNTOP       - Align to the top edge. <br>*   MENU_ALIGNHORZ      - Align to the center horizontally. <br>*   MENU_ALIGNBOTTOM    - Align to the bottom edge. <br>* <br>************************************************************************/ <br> <br>VOID AlignControls( <br>    INT cmd) <br>{ <br>    register INT sDelta; <br>    NPCTYPE npc; <br>    RECT rc; <br>    BOOL fMove; <br>    BOOL fModified = FALSE; <br> <br>    /* <br>     * Loop through all the controls.  Align all the selected ones. <br>     */ <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        if (npc-&gt;fSelected &amp;&amp; npc != gnpcSel) { <br>            rc = npc-&gt;rc; <br>            fMove = FALSE; <br> <br>            switch (cmd) { <br>                case MENU_ALIGNLEFT: <br>                    if (sDelta = gnpcSel-&gt;rc.left - rc.left) { <br>                        fMove = TRUE; <br>                        rc.left += sDelta; <br>                        rc.right += sDelta; <br>                    } <br> <br>                    break; <br> <br>                case MENU_ALIGNVERT: <br>                    if (sDelta = <br>                            (((gnpcSel-&gt;rc.right - gnpcSel-&gt;rc.left) / 2) <br>                            + gnpcSel-&gt;rc.left) - <br>                            (((rc.right - rc.left) / 2) + <br>                            rc.left)) { <br>                        fMove = TRUE; <br>                        rc.left += sDelta; <br>                        rc.right += sDelta; <br>                    } <br> <br>                    break; <br> <br>                case MENU_ALIGNRIGHT: <br>                    if (sDelta = gnpcSel-&gt;rc.right - rc.right) { <br>                        fMove = TRUE; <br>                        rc.left += sDelta; <br>                        rc.right += sDelta; <br>                    } <br> <br>                    break; <br> <br>                case MENU_ALIGNTOP: <br>                    if (sDelta = gnpcSel-&gt;rc.top - rc.top) { <br>                        fMove = TRUE; <br>                        rc.top += sDelta; <br>                        rc.bottom += sDelta; <br>                    } <br> <br>                    break; <br> <br>                case MENU_ALIGNHORZ: <br>                    if (sDelta = <br>                            (((gnpcSel-&gt;rc.bottom - gnpcSel-&gt;rc.top) / 2) <br>                            + gnpcSel-&gt;rc.top) - <br>                            (((rc.bottom - rc.top) / 2) + <br>                            rc.top)) { <br>                        fMove = TRUE; <br>                        rc.top += sDelta; <br>                        rc.bottom += sDelta; <br>                    } <br> <br>                    break; <br> <br>                case MENU_ALIGNBOTTOM: <br>                    if (sDelta = gnpcSel-&gt;rc.bottom - rc.bottom) { <br>                        fMove = TRUE; <br>                        rc.top += sDelta; <br>                        rc.bottom += sDelta; <br>                    } <br> <br>                    break; <br>            } <br> <br>            if (fMove) { <br>                GridizeRect(&amp;rc, <br>                        GRIDIZE_LEFT | GRIDIZE_TOP | GRIDIZE_SAMESIZE); <br>                FitRectToBounds(&amp;rc, GetOverHang(npc-&gt;pwcd-&gt;iType, <br>                        npc-&gt;rc.bottom - npc-&gt;rc.top), <br>                        DRAG_CENTER, FALSE); <br> <br>                if (!EqualRect(&amp;rc, &amp;npc-&gt;rc)) { <br>                    PositionControl2(npc, &amp;rc, NULL); <br>                    fModified = TRUE; <br>                } <br>            } <br>        } <br>    } <br> <br>    if (fModified) { <br>        RedrawSelection(); <br>        CalcSelectedRect(); <br>        gfResChged = gfDlgChanged = TRUE; <br>        ShowFileStatus(FALSE); <br>        StatusUpdate(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ArrangeSpacing <br>* <br>* This function will evenly space all the selected controls.  The <br>* currently selected control is not moved (unless it has to be gridized) <br>* and any previous controls in Z order will be evenly spaced to the <br>* left or above the anchor, and all controls following in Z order will <br>* be evenly spaced below or to the right of the anchor. <br>* <br>* The spacing values used are gxSpace and gySpace. <br>* <br>* In all cases, the resulting desired position of the control will be <br>* gridized and limited to the dialogs "client" area.  The size of the <br>* controls is not changed. <br>* <br>* Arguments: <br>*   INT cmd - The Arrange/Even spacing menu command. <br>* <br>*   The following are valid values for cmd: <br>* <br>*   MENU_SPACEHORZ - Space the controls left and right. <br>*   MENU_SPACEVERT - Space all the controls up and down. <br>* <br>************************************************************************/ <br> <br>VOID ArrangeSpacing( <br>    INT cmd) <br>{ <br>    NPCTYPE npc; <br>    RECT rc; <br>    BOOL fModified = FALSE; <br>    INT x; <br>    INT y; <br>    INT cPreceding; <br>    INT xTotalWidth; <br>    INT yTotalWidth; <br> <br>    cPreceding = 0; <br>    xTotalWidth = 0; <br>    yTotalWidth = 0; <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        if (npc-&gt;fSelected) { <br>            if (npc == gnpcSel) <br>                break; <br> <br>            cPreceding++; <br>            xTotalWidth += npc-&gt;rc.right - npc-&gt;rc.left; <br>            yTotalWidth += npc-&gt;rc.bottom - npc-&gt;rc.top; <br>        } <br>    } <br> <br>    x = gnpcSel-&gt;rc.left; <br>    y = gnpcSel-&gt;rc.top; <br> <br>    if (cPreceding) { <br>        x -= xTotalWidth + (gxSpace * cPreceding); <br>        y -= yTotalWidth + (gySpace * cPreceding); <br>    } <br> <br>    /* <br>     * Loop through all the controls.  Space all the selected ones. <br>     */ <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        if (npc-&gt;fSelected) { <br>            rc = npc-&gt;rc; <br> <br>            switch (cmd) { <br>                case MENU_SPACEVERT: <br>                    rc.top = y; <br>                    rc.bottom = y + (npc-&gt;rc.bottom - npc-&gt;rc.top); <br>                    y = rc.bottom + gySpace; <br>                    break; <br> <br>                case MENU_SPACEHORZ: <br>                    rc.left = x; <br>                    rc.right = x + (npc-&gt;rc.right - npc-&gt;rc.left); <br>                    x = rc.right + gxSpace; <br>                    break; <br>            } <br> <br>            GridizeRect(&amp;rc, GRIDIZE_LEFT | GRIDIZE_TOP | GRIDIZE_SAMESIZE); <br>            FitRectToBounds(&amp;rc, GetOverHang(npc-&gt;pwcd-&gt;iType, <br>                    npc-&gt;rc.bottom - npc-&gt;rc.top), <br>                    DRAG_CENTER, FALSE); <br> <br>            if (!EqualRect(&amp;rc, &amp;npc-&gt;rc)) { <br>                PositionControl2(npc, &amp;rc, NULL); <br>                fModified = TRUE; <br>            } <br>        } <br>    } <br> <br>    if (fModified) { <br>        RedrawSelection(); <br>        CalcSelectedRect(); <br>        gfResChged = gfDlgChanged = TRUE; <br>        ShowFileStatus(FALSE); <br>        StatusUpdate(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ArrangeSize <br>* <br>* This function will evenly size all the selected controls.  The <br>* currently selected control determines the size that the other <br>* controls will be set to in the given dimension. <br>* <br>* In all cases, the resulting size of the control will be gridized and <br>* limited to the dialogs "client" area. <br>* <br>* Arguments: <br>*   INT cmd - The Arrange/Same size menu command. <br>* <br>* The following are valid values for cmd: <br>* <br>*   MENU_ARRSIZEWIDTH  - Size the widths of the controls. <br>*   MENU_ARRSIZEHEIGHT - Size the heights of the controls. <br>* <br>************************************************************************/ <br> <br>VOID ArrangeSize( <br>    INT cmd) <br>{ <br>    NPCTYPE npc; <br>    RECT rc; <br>    BOOL fModified = FALSE; <br>    INT cx; <br>    INT cy; <br> <br>    cx = gnpcSel-&gt;rc.right - gnpcSel-&gt;rc.left; <br>    cy = gnpcSel-&gt;rc.bottom - gnpcSel-&gt;rc.top; <br> <br>    /* <br>     * Loop through all the controls, operating on the selected ones. <br>     */ <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        /* <br>         * Is the control selected, and is it sizeable? <br>         */ <br>        if (npc-&gt;fSelected &amp;&amp; npc-&gt;pwcd-&gt;fSizeable) { <br>            rc = npc-&gt;rc; <br> <br>            switch (cmd) { <br>                case MENU_ARRSIZEWIDTH: <br>                    rc.right = npc-&gt;rc.left + cx; <br>                    break; <br> <br>                case MENU_ARRSIZEHEIGHT: <br>                    rc.top = npc-&gt;rc.bottom - cy; <br>                    break; <br>            } <br> <br>            GridizeRect(&amp;rc, GRIDIZE_LEFT | GRIDIZE_TOP | <br>                    GRIDIZE_RIGHT | GRIDIZE_BOTTOM); <br>            FitRectToBounds(&amp;rc, GetOverHang(npc-&gt;pwcd-&gt;iType, <br>                    npc-&gt;rc.bottom - npc-&gt;rc.top), <br>                    DRAG_CENTER, FALSE); <br> <br>            if (!EqualRect(&amp;rc, &amp;npc-&gt;rc)) { <br>                PositionControl2(npc, &amp;rc, NULL); <br>                fModified = TRUE; <br>            } <br>        } <br>    } <br> <br>    if (fModified) { <br>        RedrawSelection(); <br>        CalcSelectedRect(); <br>        gfResChged = gfDlgChanged = TRUE; <br>        ShowFileStatus(FALSE); <br>        StatusUpdate(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ArrangePushButtons <br>* <br>* This function will arrange push buttons along either the bottom of <br>* the dialog or along the right side of the dialog.  It will operate <br>* on the selected buttons (which button is currently selected does not <br>* matter) but this function can also be used if buttons are not selected <br>* in a couple of special cases.  If either the dialog or nothing is <br>* selected, ALL the push buttons in the dialog will be arranged. <br>* <br>* The margin values used are gxMargin and gyMargin, and the spacing <br>* between buttons is gxMinPushSpace, gxMaxPushSpace and gyPushSpace. <br>* <br>* In all cases, the resulting desired position of the buttons will be <br>* gridized and limited to the dialogs "client" area.  The size of the <br>* push buttons is not changed. <br>* <br>* Arguments: <br>*   INT cmd - The Arrange/Push buttons menu command. <br>* <br>*   The following are valid values for cmd: <br>* <br>*   MENU_ARRPUSHBOTTOM - Arrange push buttons along the bottom. <br>*   MENU_ARRPUSHRIGHT  - Arrange push buttons along the right side. <br>* <br>************************************************************************/ <br> <br>VOID ArrangePushButtons( <br>    INT cmd) <br>{ <br>    NPCTYPE npc; <br>    RECT rc; <br>    BOOL fModified = FALSE; <br>    INT x;                          // Note: These values must be signed. <br>    INT y; <br>    INT cxDlg; <br>    INT cButtons; <br>    INT xTotal; <br>    INT xInterSpace; <br> <br>    switch (cmd) { <br>        case MENU_ARRPUSHBOTTOM: <br>            cxDlg = gcd.npc-&gt;rc.right - gcd.npc-&gt;rc.left; <br>            y = (gcd.npc-&gt;rc.bottom - gcd.npc-&gt;rc.top) - gyMargin; <br> <br>            for (cButtons = 0, xTotal = 0, npc = npcHead; npc; <br>                    npc = npc-&gt;npcNext) { <br>                if (npc-&gt;pwcd-&gt;iType == W_PUSHBUTTON &amp;&amp; <br>                        (!gcSelected || gfDlgSelected || npc-&gt;fSelected)) { <br>                    cButtons++; <br>                    xTotal += npc-&gt;rc.right - npc-&gt;rc.left; <br>                } <br>            } <br> <br>            if (cButtons == 1) { <br>                x = (cxDlg - xTotal) / 2; <br>                xInterSpace = 0; <br>            } <br>            else { <br>                xInterSpace = (cxDlg - xTotal) / (cButtons + 1); <br> <br>                if (xInterSpace &gt; gxMaxPushSpace) <br>                    xInterSpace = gxMaxPushSpace; <br>                else if (xInterSpace &lt; gxMinPushSpace) <br>                    xInterSpace = gxMinPushSpace; <br> <br>                x = (cxDlg - ((cButtons - 1) * xInterSpace) - xTotal) / 2; <br>                if (x &lt; 0) <br>                    x = 0; <br> <br>                if (x &lt; gxMargin &amp;&amp; xInterSpace &gt; gxMinPushSpace) { <br>                    xInterSpace = (cxDlg - xTotal - (2 * gxMargin)) <br>                            / (cButtons - 1); <br> <br>                    if (xInterSpace &lt; gxMinPushSpace) <br>                        xInterSpace = gxMinPushSpace; </code></pre>
<p>
</p>
<pre><code><br>                    x = (cxDlg - ((cButtons - 1) * xInterSpace) - xTotal) <br>                            / 2; <br>                    if (x &lt; 0) <br>                        x = 0; <br>                } <br>            } <br> <br>            break; <br> <br>        case MENU_ARRPUSHRIGHT: <br>            x = (gcd.npc-&gt;rc.right - gcd.npc-&gt;rc.left) - gxMargin; <br>            y = gyMargin; <br>            break; <br>    } <br> <br>    /* <br>     * Loop through all the controls. <br>     */ <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        /* <br>         * We will arrange this control only if it is a pushbutton, <br>         * and only if one of the following is true: there are no <br>         * controls selected, or the dialog itself is selected, or <br>         * there are some controls selected and this pushbutton is <br>         * one of them. <br>         */ <br>        if (npc-&gt;pwcd-&gt;iType == W_PUSHBUTTON &amp;&amp; <br>                (!gcSelected || gfDlgSelected || npc-&gt;fSelected)) { <br>            rc = npc-&gt;rc; <br> <br>            switch (cmd) { <br>                case MENU_ARRPUSHBOTTOM: <br>                    rc.left = x; <br>                    rc.top = y - (npc-&gt;rc.bottom - npc-&gt;rc.top); <br>                    rc.bottom = y; <br>                    rc.right = rc.left + (npc-&gt;rc.right - npc-&gt;rc.left); <br> <br>                    x = rc.right + xInterSpace; <br> <br>                    break; <br> <br>                case MENU_ARRPUSHRIGHT: <br>                    rc.left = x - (npc-&gt;rc.right - npc-&gt;rc.left); <br>                    rc.bottom = y + (npc-&gt;rc.bottom - npc-&gt;rc.top); <br>                    rc.right = x; <br>                    rc.top = y; <br> <br>                    y = rc.bottom + gyPushSpace; <br> <br>                    break; <br>            } <br> <br>            GridizeRect(&amp;rc, GRIDIZE_LEFT | GRIDIZE_TOP | GRIDIZE_SAMESIZE); <br>            FitRectToBounds(&amp;rc, GetOverHang(npc-&gt;pwcd-&gt;iType, <br>                    npc-&gt;rc.bottom - npc-&gt;rc.top), <br>                    DRAG_CENTER, FALSE); <br> <br>            if (!EqualRect(&amp;rc, &amp;npc-&gt;rc)) { <br>                PositionControl2(npc, &amp;rc, NULL); <br>                fModified = TRUE; <br>            } <br>        } <br>    } <br> <br>    if (fModified) { <br>        if (gfDlgSelected || !gcSelected) <br>            InvalidateRect(gcd.npc-&gt;hwnd, NULL, TRUE); <br> <br>        CalcSelectedRect(); <br>        gfResChged = gfDlgChanged = TRUE; <br>        ShowFileStatus(FALSE); <br>        StatusUpdate(); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
