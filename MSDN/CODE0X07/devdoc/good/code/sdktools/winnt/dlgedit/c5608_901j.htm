<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RWDLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5617"></a>RWDLG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: rwdlg.c <br>* <br>* Does the writing of .DLG files. <br>* <br>* Functions: <br>*    WriteDlg() <br>*    WriteDlgInclude() <br>*    WriteDialogHeader() <br>*    WriteDialogHeaderLanguage() <br>*    WriteControl() <br>*    WriteNameOrd() <br>*    WriteText() <br>*    WriteIDDlg() <br>*    GetControlKeyword() <br>*    WriteClass() <br>*    WriteStyles() <br>*    WriteClassStyle() <br>*    WriteCustomStyle() <br>*    WriteCoords() <br>*    WriteValue() <br>*    WriteHexWord() <br>*    WriteHexDWord() <br>*    WriteString() <br>*    WriteQuotedString() <br>*    WriteEscapedString() <br>*    WriteDlgChar() <br>*    WriteDlgFlush() <br>*    Tab() <br>*    NewLine() <br>*    Quote() <br>*    Comma() <br>*    Space() <br>*    ORSymbol() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>/* <br> * Wrap lines before they go over this right margin. <br> */ <br>#define CCHRIGHTMARGIN      76 <br> <br>/* <br> * Defines for the tabs and tab indent levels. <br> */ <br>#define CCHTABWIDTH         4           // Tabs are four spaces wide. <br>#define TABLEVELNONE        0           // No indent (at left margin). <br>#define TABLEVELCONTROL     1           // Indent to start of controls. <br>#define TABLEVELCONTROLDESC 5           // Indent to control description. <br> <br>/* <br> * Macro to set the current tab level.  The level is multiplied <br> * by the tab width. <br> */ <br>#define SetTab(t)           (cTabStop = ((t)*CCHTABWIDTH)) <br> <br>/* <br> * Macro that determines if the current position is the first <br> * column for the current tab setting. <br> */ <br>#define AtFirstTabColumn()  ((cColumn == cTabStop) ? TRUE : FALSE) <br> <br>STATICFN VOID WriteDlgInclude(LPTSTR pszFullDlgFile); <br>STATICFN PCONTROLDATA WriteDialogHeader(PRES pRes, PDIALOGBOXHEADER pdbh); <br>STATICFN VOID WriteDialogHeaderLanguage(WORD wLanguage); <br>STATICFN PCONTROLDATA WriteControl(PCONTROLDATA pcd); <br>STATICFN VOID WriteNameOrd(LPTSTR pszNameOrd); <br>STATICFN VOID WriteText(LPTSTR pszText); <br>STATICFN VOID WriteIDDlg(INT id, BOOL fHexOK); <br>STATICFN LPTSTR GetControlKeyword(INT iClass, DWORD flStyle, <br>    DWORD *pflStylePredef, DWORD *pflStyleDefault, BOOL *pfWriteText, <br>    BOOL *pfNotFound); <br>STATICFN VOID WriteClass(LPTSTR pszClass); <br>STATICFN BOOL WriteStyles(INT iClass, LPTSTR pszClass, DWORD flStyle, <br>    DWORD flStylePredef, DWORD flStyleDefault, PDWORD pflStyleLeft, <br>    BOOL fNullStyles, BOOL fCommaPrefix); <br>STATICFN BOOL WriteClassStyle(INT iClass, DWORD flStyle, <br>    DWORD flStylePredef, DWORD flStyleDefault, PDWORD pflStyleLeft, <br>    BOOL fPrevWritten, BOOL fNullStyles, BOOL fCommaPrefix); <br>STATICFN BOOL WriteCustomStyle(LPTSTR pszClass, DWORD flStyle, <br>    PDWORD pflStyleLeft); <br>STATICFN VOID WriteCoords(INT x, INT y, INT cx, INT cy); <br>STATICFN VOID WriteValue(INT n); <br>STATICFN VOID WriteHexWord(WORD w); <br>STATICFN VOID WriteHexDWord(DWORD dw); <br>STATICFN VOID WriteString(LPTSTR psz); <br>STATICFN VOID WriteQuotedString(LPTSTR psz); <br>STATICFN VOID WriteEscapedString(LPTSTR psz); <br>STATICFN VOID WriteDlgChar(TCHAR ch); <br>STATICFN VOID WriteDlgFlush(VOID); <br>STATICFN VOID Tab(VOID); <br>STATICFN VOID NewLine(VOID); <br>STATICFN VOID Quote(VOID); <br>STATICFN VOID Comma(VOID); <br>STATICFN VOID Space(VOID); <br>STATICFN VOID ORSymbol(VOID); <br> <br>static INT cColumn;                 /* Current column in the line.      */ <br>static INT cTabStop;                /* Current tabstop column.          */ <br>static HANDLE hfDlg;                /* All workers write to this file.  */ <br>static jmp_buf jbWriteDlg;          /* Capture the state for longjmp.   */ <br> <br> <br> <br>/************************************************************************ <br>* WriteDlg <br>* <br>* This function writes the dialog boxes in the given resource to the <br>* hfWrite file in the .DLG file RC format. <br>* <br>* Arguments: <br>*    HANDLE - handle to the file <br>*    LPTSTR - pointer to the resource file name <br>* <br>************************************************************************/ <br> <br>BOOL WriteDlg( <br>    HANDLE hfWrite, <br>    LPTSTR pszFullDlgFile) <br>{ <br>    HANDLE hResLocked = NULL; <br>    PRES pRes = NULL; <br>    PRESLINK prl; <br>    PDIALOGBOXHEADER pdbh; <br>    PCONTROLDATA pcd; <br>    INT cItems; <br> <br>    /* <br>     * Set our error trap up.  The api setjmp will return a zero at first, <br>     * then if a write error occurs later and longjmp is called, it <br>     * will return non-zero and we will return the failure up to the <br>     * caller.  After this point, there must be no calls to allocate <br>     * memory, open files, etc., unless this trap has a way to detect <br>     * what happened and clean it up.  See the c-runtime help file for more <br>     * information about setjump/longjmp. <br>     */ <br>    if (_setjmp(jbWriteDlg)) { <br>        /* <br>         * If the resource is locked, unlock it. <br>         */ <br>        if (hResLocked) <br>            GlobalUnlock(hResLocked); <br> <br>        return FALSE; <br>    } <br> <br>    /* <br>     * Initialize our globals.  The hfDlg global is used so that hfWrite <br>     * doesn't have to be passed on the stack over and over. <br>     */ <br>    hfDlg = hfWrite; <br>    cColumn = 0; <br>    SetTab(TABLEVELNONE); <br> <br>    WriteDlgInclude(pszFullDlgFile); <br> <br>    /* <br>     * Process each resource in the list. <br>     */ <br>    for (prl = gprlHead; prl; prl = prl-&gt;prlNext) { <br>        /* <br>         * Skip if it is not a dialog resource. <br>         */ <br>        if (!prl-&gt;fDlgResource) <br>            continue; <br> <br>        /* <br>         * Set up pointers to this dialog resource. <br>         */ <br>        pRes = (PRES)GlobalLock(prl-&gt;hRes); <br>        hResLocked = prl-&gt;hRes; <br> <br>        pdbh = (PDIALOGBOXHEADER)SkipResHeader(pRes); <br> <br>        NewLine(); <br>        pcd = WriteDialogHeader(pRes, pdbh); <br> <br>        WriteString(ids(IDS_BEGIN)); <br>        NewLine(); <br> <br>        /* <br>         * Write the controls. <br>         */ <br>        cItems = (INT)pdbh-&gt;NumberOfItems; <br>        while (cItems--) <br>            pcd = WriteControl(pcd); <br> <br>        /* <br>         * Finish up dialog template. <br>         */ <br>        WriteString(ids(IDS_END)); <br>        NewLine(); <br> <br>        GlobalUnlock(prl-&gt;hRes); <br>        hResLocked = NULL; <br>    } <br> <br>    /* <br>     * Flush any remaining characters in the write buffer. <br>     */ <br>    WriteDlgFlush(); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDlgInclude <br>* <br>* This routine writes out the "DLGINCLUDE" lines to the .DLG file. <br>* <br>* Arguments: <br>*    LPTSTR - dialog file name <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteDlgInclude( <br>    LPTSTR pszFullDlgFile) <br>{ <br>    if (pszIncludeFile) { <br>        WriteValue(ORDID_DLGINCLUDE_NAME); <br>        Space(); <br>        WriteString(ids(IDS_DLGINCLUDE)); <br>        Space(); <br>        Quote(); <br> <br>        /* <br>         * If the include file is in a different directory than the resource <br>         * file, write the full path to it.  Otherwise, we just write the <br>         * include file name. <br>         */ <br>        if (DifferentDirs(pszFullDlgFile, szFullIncludeFile)) <br>            WriteEscapedString(szFullIncludeFile); <br>        else <br>            WriteEscapedString(pszIncludeFile); <br> <br>        Quote(); <br>        NewLine(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDialogHeader <br>* <br>* Writes out the dialog header lines. <br>* <br>* Arguments: <br>*    PRES - pointer to the resource <br>*    PDIALOGBOXHEADER - pointer to the dialog box header <br>* <br>************************************************************************/ <br> <br>STATICFN PCONTROLDATA WriteDialogHeader( <br>    PRES pRes, <br>    PDIALOGBOXHEADER pdbh) <br>{ <br>    DWORD flStyle; <br>    DWORD flExtStyle; <br>    DWORD flStyleLeft; <br>    INT cdit; <br>    INT x; <br>    INT y; <br>    INT cx; <br>    INT cy; <br>    LPTSTR pszMenuName; <br>    LPTSTR pszClass; <br>    LPTSTR pszCaption; <br>    INT nPointSize; <br>    LPTSTR pszFontName; <br>    PCONTROLDATA pcd; <br>    PRES2 pRes2; <br>    BOOL fWritten; <br> <br>    pRes2 = ResourcePart2(pRes); <br> <br>    WriteNameOrd(ResourceName(pRes)); <br>    Space(); <br>    WriteString(ids(IDS_DIALOG)); <br> <br>    if (pRes2-&gt;MemoryFlags &amp; MMF_PRELOAD) { <br>        Space(); <br>        WriteString(ids(IDS_PRELOAD)); <br>    } <br> <br>    if (!(pRes2-&gt;MemoryFlags &amp; MMF_MOVEABLE)) { <br>        Space(); <br>        WriteString(ids(IDS_FIXED)); <br>    } <br> <br>    if (!(pRes2-&gt;MemoryFlags &amp; MMF_PURE)) { <br>        Space(); <br>        WriteString(ids(IDS_IMPURE)); <br>    } <br> <br>    /* <br>     * Parse out the dialog template. <br>     */ <br>    pcd = ParseDialogBoxHeader(pdbh, &amp;flStyle, &amp;flExtStyle, &amp;cdit, &amp;x, &amp;y, <br>            &amp;cx, &amp;cy, &amp;pszMenuName, &amp;pszClass, &amp;pszCaption, <br>            &amp;nPointSize, &amp;pszFontName); <br> <br>    Space(); <br>    WriteCoords(x, y, cx, cy); <br> <br>    NewLine(); <br> <br>    /* <br>     * Write the language. <br>     */ <br>    WriteDialogHeaderLanguage(pRes2-&gt;LanguageId); <br> <br>    /* <br>     * Print out the "STYLE" line for the dialog. <br>     */ <br>    WriteString(ids(IDS_STYLE)); <br>    Space(); <br>    SetTab(TABLEVELCONTROL); <br>    WriteStyles(IC_DIALOG, NULL, flStyle, 0L, 0L, &amp;flStyleLeft, TRUE, FALSE); <br>    SetTab(TABLEVELNONE); <br>    NewLine(); <br> <br>    /* <br>     * Print out the "EXSTYLE" line for the dialog, if necessary. <br>     */ <br>    if (flExtStyle) { <br>        WriteString(ids(IDS_EXSTYLE)); <br>        Space(); <br>        SetTab(TABLEVELCONTROL); <br> <br>        fWritten = WriteClassStyle(IC_EXSTYLE, flExtStyle, 0L, 0L, <br>                &amp;flStyleLeft, FALSE, TRUE, FALSE); <br> <br>        /* <br>         * If there is anything left (styles that the dialog editor <br>         * does not know about) write it out as a hex constant. <br>         */ <br>        if (flStyleLeft) { <br>            if (fWritten) <br>                ORSymbol(); <br> <br>            WriteHexDWord(flStyleLeft); <br>        } <br> <br>        SetTab(TABLEVELNONE); <br>        NewLine(); <br>    } <br> <br>    /* <br>     * If it has a caption, print it out. <br>     */ <br>    if (*pszCaption) { <br>        WriteString(ids(IDS_CAPTION)); <br>        Space(); <br>        WriteText(pszCaption); <br>        NewLine(); <br>    } <br> <br>    /* <br>     * If it has a font specified, print it out. <br>     */ <br>    if (flStyle &amp; DS_SETFONT) { <br>        WriteString(ids(IDS_FONT)); <br>        Space(); <br> <br>        WriteValue(nPointSize); <br>        Comma(); <br>        WriteQuotedString(pszFontName); <br>        NewLine(); <br>    } <br> <br>    /* <br>     * If it has a class specified, print it out. <br>     */ <br>    if (*pszClass) { <br>        WriteString(ids(IDS_CLASS)); <br>        Space(); <br>        WriteText(pszClass); <br>        NewLine(); <br>    } <br> <br>    /* <br>     * If it has a menu specified, print it out. <br>     */ <br>    if (*pszMenuName) { <br>        WriteString(ids(IDS_MENU)); <br>        Space(); <br>        WriteNameOrd(pszMenuName); <br>        NewLine(); <br>    } <br> <br>    if (pRes2-&gt;Version) { <br>        WriteString(ids(IDS_VERSION)); <br>        Space(); <br>        WriteValue(pRes2-&gt;Version); <br>        NewLine(); <br>    } <br> <br>    if (pRes2-&gt;Characteristics) { <br>        WriteString(ids(IDS_CHARACTERISTICS)); <br>        Space(); <br>        WriteValue(pRes2-&gt;Characteristics); <br>        NewLine(); <br>    } <br> <br>    return pcd; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDialogHeaderLanguage <br>* <br>* Writes out the dialog header "LANGUAGE" line. <br>* <br>* Arguments: <br>*    WORD - language to write out <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteDialogHeaderLanguage( <br>    WORD wLanguage) <br>{ <br>    WORD wPrimary; <br>    WORD wSubLang; <br>    INT i; <br>    INT j; <br>    INT idsLang; <br>    INT idsSubLang; <br> <br>    WriteString(ids(IDS_LANGUAGE)); <br>    Space(); <br> <br>    idsLang = 0; <br>    idsSubLang = 0; <br>    wPrimary = (WORD)PRIMARYLANGID(wLanguage); <br>    wSubLang = SUBLANGID(wLanguage); <br>    for (i = 0; i &lt; gcLanguages; i++) { <br>        if (gaLangTable[i].wPrimary == wPrimary) { <br>            idsLang = gaLangTable[i].idsLang; <br> <br>            for (j = 0; j &lt; gaLangTable[i].cSubLangs; j++) { <br>                if (gaLangTable[i].asl[j].wSubLang == wSubLang) { <br>                    idsSubLang = gaLangTable[i].asl[j].idsSubLang; <br>                    break; <br>                } <br>            } <br> <br>            break; <br>        } <br>    } <br> <br>    if (idsLang) <br>        WriteString(ids(idsLang)); <br>    else <br>        WriteHexWord(wPrimary); <br> <br>    Comma(); <br> <br>    if (idsSubLang) <br>        WriteString(ids(idsSubLang)); <br>    else <br>        WriteHexWord(wSubLang); <br> <br>    NewLine(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteControl <br>* <br>* Writes out a control line. <br>* <br>* Arguments: <br>*    PCONTROLDATA - pointer to the control data <br>* <br>************************************************************************/ <br> <br>STATICFN PCONTROLDATA WriteControl( <br>    PCONTROLDATA pcd) <br>{ <br>    INT x; <br>    INT y; <br>    INT cx; <br>    INT cy; <br>    INT id; <br>    DWORD flStyle; <br>    DWORD flExtStyle; <br>    LPTSTR pszClass; <br>    LPTSTR pszText; <br>    INT iClass; <br>    LPTSTR pszKeyword; <br>    BOOL fWriteText; <br>    BOOL fNotFound; <br>    DWORD flStylePredef; <br>    DWORD flStyleDefault; <br>    DWORD flStyleLeft; <br>    BOOL fWritten; <br> <br>    pcd = ParseControlData(pcd, &amp;flStyle, &amp;flExtStyle, &amp;x, &amp;y, &amp;cx, &amp;cy, <br>            &amp;id, &amp;pszClass, &amp;pszText); <br> <br>    /* <br>     * Determine the class of the control. <br>     */ <br>    iClass = GetiClass(pszClass); <br> <br>    /* <br>     * Determine if there are any predefined RC keywords that we <br>     * can use instead of the generic "CONTROL" keyword for this <br>     * style of control. <br>     */ <br>    pszKeyword = GetControlKeyword(iClass, flStyle, &amp;flStylePredef, <br>            &amp;flStyleDefault, &amp;fWriteText, &amp;fNotFound); <br> <br>    SetTab(TABLEVELCONTROL); <br>    Tab(); <br>    WriteString(pszKeyword); <br>    SetTab(TABLEVELCONTROLDESC); <br>    Tab(); <br> <br>    /* <br>     * Write out the text field, if this type of control has one. <br>     */ <br>    if (fWriteText) { <br>#ifdef JAPAN <br>        TCHAR   szTmp[CCHTEXTMAX]; <br> <br>        KDExpandCopy(szTmp, pszText, CCHTEXTMAX); <br>        WriteText(szTmp); <br>#else <br>        WriteText(pszText); <br>#endif <br>        Comma(); <br>    } <br> <br>    /* <br>     * Write out the id for the control. <br>     */ <br>    WriteIDDlg(id, TRUE); <br> <br>    /* <br>     * If we did not find a predefined keyword to use instead of "CONTROL", <br>     * we have to write out the fields in a different order, and specify <br>     * the class as well. <br>     */ <br>    if (fNotFound) { <br>        WriteClass(pszClass); <br>        Comma(); <br>        fWritten = WriteStyles(iClass, pszClass, flStyle, flStylePredef, <br>                flStyleDefault, &amp;flStyleLeft, fNotFound, FALSE); <br> <br>        if (!fWritten || flStyleLeft) { <br>            if (fWritten) <br>                ORSymbol(); <br> <br>            WriteHexWord(LOWORD(flStyleLeft)); <br>        } <br> <br>        Comma(); <br>        WriteCoords(x, y, cx, cy); <br>    } <br>    else { <br>        Comma(); <br>        WriteCoords(x, y, cx, cy); <br>        fWritten = WriteStyles(iClass, pszClass, flStyle, flStylePredef, <br>                flStyleDefault, &amp;flStyleLeft, fNotFound, TRUE); <br> <br>        if (flStyleLeft) { <br>            if (fWritten) <br>                ORSymbol(); <br>            else <br>                Comma(); <br> <br>            WriteHexWord(LOWORD(flStyleLeft)); <br>            fWritten = TRUE; <br>        } <br>    } <br> <br>    /* <br>     * Write out the extended styles for the control, if necessary. <br>     */ <br>    if (flExtStyle) { <br>        /* <br>         * If writing a predefined keyword (not CONTROL), and there <br>         * were no styles written out at the end of the line, write <br>         * a style of zero.  RC doesn't like consecutive comma's, <br>         * and we need to skip the styles field to get to the <br>         * extended styles field. <br>         */ <br>        if (!fNotFound &amp;&amp; !fWritten) { <br>            Comma(); <br>            WriteValue(0); <br>        } <br> <br>        Comma(); <br> <br>        fWritten = WriteClassStyle(IC_EXSTYLE, flExtStyle, 0L, 0L, <br>                &amp;flStyleLeft, FALSE, TRUE, FALSE); <br> <br>        /* <br>         * If there is anything left (styles that the dialog editor <br>         * does not know about) write it out as a hex constant. <br>         */ <br>        if (flStyleLeft) { <br>            if (fWritten) <br>                ORSymbol(); <br> <br>            WriteHexDWord(flStyleLeft); <br>        } <br>    } <br> <br>    SetTab(TABLEVELNONE); <br>    NewLine(); <br> <br>    return pcd; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteNameOrd <br>* <br>* Writes out the name/ordinal.  Handles the case where the name <br>* is really an ordinal instead of a string.  When it is a string, <br>* it will not be quoted. <br>* <br>* This routine never writes the ordinal out in hex, because the <br>* items that it is intended to write are not parsed properly by <br>* the Windows RC.EXE if they are written in hex notation. <br>* <br>* Arguments: <br>*   LPTSTR pszNameOrd - The name/ordinal to write. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteNameOrd( <br>    LPTSTR pszNameOrd) <br>{ <br>    if (IsOrd(pszNameOrd)) <br>        /* <br>         * Write the name as a numeric ordinal. <br>         */ <br>        WriteIDDlg(OrdID(pszNameOrd), FALSE); <br>    else <br>        WriteString(pszNameOrd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteText <br>* <br>* Writes out the text for a control or dialog.  This will either be <br>* an ordinal (icon's text field) or a quoted string. <br>* <br>* Arguments: <br>*    LPTSTR pszText - text to write out <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteText( <br>    LPTSTR pszText) <br>{ <br>    if (IsOrd(pszText)) <br>        /* <br>         * Write the text as an ID.  Hex notation is allowed. <br>         */ <br>        WriteIDDlg(OrdID(pszText), TRUE); <br>    else <br>        WriteQuotedString(pszText); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteIDDlg <br>* <br>* Writes out the ID.  This may be written out as either a symbol <br>* or a numeric. <br>* <br>* Arguments: <br>*    INT id - id to write out <br>*    BOOL fHexOK - flag specifies whether the id is a hex numeric. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteIDDlg( <br>    INT id, <br>    BOOL fHexOK) <br>{ <br>    TCHAR szID[CCHTEXTMAX]; <br> <br>    IDToLabel(szID, id, fHexOK); <br>    WriteString(szID); <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetControlKeyword <br>* <br>* This routine does a lookup in the predefined RC keyword table <br>* associated with the given class for a keyword that can be used <br>* instead of "CONTROL".  The match is based on the style of the control <br>* that is passed in.  If a match is not found, it defaults all the <br>* returned values to use the "CONTROL" keyword. <br>* <br>* Arguments: <br>*   INT iClass              - The class of the control. <br>*   DWORD flStyle           - The style of the control. <br>*   DWORD *pflStylePredef   - Return for the bits of the predefined control <br>*                             (if found).  These can be removed later from <br>*                             the style flag. <br>*   DWORD *pflStyleDefault  - Return for the default styles. <br>*   BOOL *pfWriteText       - Return for the "Write Text" flag.  This will <br>*                             be TRUE if this control has a text field. <br>*   BOOL *pfNotFound        - Return for the "Not Found" flag.  This will <br>*                             be TRUE if no match was found and the "CONTROL" <br>*                             keyword was defaulted to. <br>* <br>* Returns: <br>*   A pointer to the control keyword to use. <br>*   If a match was found, *pflStylePredef is set to the bits for the match. <br>*       If not found, this is set to zero. <br>*   The default style bits for this keyword will be returned. <br>*   The "Write Text" flag will be set. <br>*   The "Not Found" flag will be set. <br>* <br>************************************************************************/ <br> <br>STATICFN LPTSTR GetControlKeyword( <br>    INT iClass, <br>    DWORD flStyle, <br>    DWORD *pflStylePredef, <br>    DWORD *pflStyleDefault, <br>    BOOL *pfWriteText, <br>    BOOL *pfNotFound) <br>{ <br>    register INT i; <br>    INT iMax; <br>    PRCKEYWORD prckwd; <br> <br>    if (gfUseNewKeywords &amp;&amp; iClass != IC_UNKNOWN) { <br>        iMax = acsd[iClass].cKeywords; <br>        prckwd = acsd[iClass].parckwd; <br> <br>        /* <br>         * Loop through all the keywords for this class. <br>         */ <br>        for (i = 0; i &lt; iMax; i++, prckwd++) { <br>            /* <br>             * Does the style (masked) exactly match the keywords style? <br>             */ <br>            if ((flStyle &amp; prckwd-&gt;flStyleMask) == prckwd-&gt;flStyle) { <br>                /* <br>                 * Yes.  Set the "Has Text" flag, we did find a match, <br>                 * put the found bits in the predefined style flag, <br>                 * set the default styles flag and return the found <br>                 * keyword. <br>                 */ <br>                *pfWriteText = prckwd-&gt;fHasText; <br>                *pfNotFound = FALSE; <br>                *pflStylePredef = prckwd-&gt;flStyle; <br>                *pflStyleDefault = prckwd-&gt;flStyleDefault; <br>                return ids(prckwd-&gt;idsKeyword); <br>            } <br>        } <br>    } <br> <br>    /* <br>     * A match was not found.  We must write text, we didn't find a <br>     * match, we will be using the "CONTROL" keyword and the default <br>     * styles that this keyword implies is the "child" and "visible" <br>     * bits (rc.exe OR's these styles in implicitly). <br>     */ <br>    *pfWriteText = TRUE; <br>    *pfNotFound = TRUE; <br>    *pflStylePredef = 0L; <br>    *pflStyleDefault = WS_VISIBLE | WS_CHILD; <br>    return ids(IDS_CONTROL); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteClass <br>* <br>* Writes out the class for a control. <br>* <br>* Arguments: <br>*    LPTSTR pszClass - pointer to the class string <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteClass( <br>    LPTSTR pszClass) <br>{ <br>    INT i; <br>    WORD idOrd; <br> <br>    Comma(); <br> <br>    /* <br>     * Is this class a predefined type instead of a string? <br>     */ <br>    if (IsOrd(pszClass)) { <br>        /* <br>         * Figure out which type it is and get the class string to <br>         * write. <br>         */ <br>        idOrd = OrdID(pszClass); <br>        for (i = 0; i &lt; IC_DIALOG; i++) { <br>            if (acsd[i].idOrd == idOrd) { <br>                pszClass = ids(acsd[i].idsClass); <br>                break; <br>            } <br>        } <br>    } <br> <br>    WriteQuotedString(pszClass); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteStyles <br>* <br>* This function writes the class and style info to the file <br>* for the control or dialog box in the RC format. <br>* <br>* Arguments: <br>*     INT iClass           = The class of the item. <br>*     LPTSTR pszClass      = Class name of the control. <br>*     DWORD flStyle        = The style of the item. <br>*     DWORD flStylePredef  = The styles bits implicit in the predefined <br>*                            keyword for this control.  This should be <br>*                            zero if this control doesn't have a predefined <br>*                            keyword for it. <br>*     DWORD flStyleDefault = The default styles implicit in the item. <br>*     PDWORD pflStyleLeft  = Where to  return any style bits that do not <br>*                            get written out. <br>*     BOOL fNullStyles     = TRUE if we should still write the style word <br>*                            even if the style flag is zero. <br>*     BOOL fCommaPrefix    = TRUE means that a comma will be written out <br>*                            before writing any styles.  If no styles <br>*                            are written, no comma will be written either. <br>* <br>* Returns: <br>*     TRUE =&gt; Something was written out. <br>*     FALSE =&gt; Nothing was written out. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteStyles( <br>    INT iClass, <br>    LPTSTR pszClass, <br>    DWORD flStyle, <br>    DWORD flStylePredef, <br>    DWORD flStyleDefault, <br>    PDWORD pflStyleLeft, <br>    BOOL fNullStyles, <br>    BOOL fCommaPrefix) <br>{ <br>    DWORD flStyleLeft; <br>    BOOL fWritten = FALSE; <br> <br>    /* <br>     * Write the control specific styles. <br>     */ <br>    if (iClass == IC_CUSTOM) { <br>        fWritten = WriteCustomStyle(pszClass, flStyle, &amp;flStyleLeft); <br>    } <br>    else { <br>        fWritten = WriteClassStyle(iClass, flStyle, flStylePredef, <br>                flStyleDefault, &amp;flStyleLeft, FALSE, fNullStyles, <br>                fCommaPrefix); <br>    } <br> <br>    /* <br>     * If we are writing styles for the dialog, remove the WS_GROUP <br>     * and WS_TABSTOP bits from the style before proceeding.  This is <br>     * because the WS_MINIMIZEBOX and WS_MAXIMIZEBOX styles use the <br>     * same bits, and these keywords will have already been written <br>     * out by the preceding WriteClassStyle call if those bits are <br>     * present. <br>     */ <br>    if (iClass == IC_DIALOG) <br>        flStyle &amp;= ~(WS_GROUP | WS_TABSTOP); <br> <br>    /* <br>     * Write the window styles that are common to the different <br>     * controls (the high word). <br>     */ <br>    fWritten |= WriteClassStyle(IC_WINDOW, flStyleLeft, flStylePredef, <br>            flStyleDefault, &amp;flStyleLeft, fWritten, fNullStyles, fCommaPrefix); <br> <br>    /* <br>     * Pass back any styles that were not written. <br>     */ <br>    *pflStyleLeft = flStyleLeft; <br> <br>    return fWritten; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteClassStyle <br>* <br>* This function writes the class style symbols to the file.  The styles <br>* to write out are passed in flStyle, and the styles that are implicitly <br>* set by this type of control already are passed in flStyleDefault.  The <br>* style keywords corresponding to the bits in flStyle are written out, <br>* separated by " | ", and any bits in flStyleDefault that are NOT set <br>* are written out preceded by a "NOT" to explicitly turn them off.  This <br>* is used in the case of the predefined RC keywords, which often have <br>* styles like WS_TABSTOP or WS_VISIBLE already implicit in them.  There <br>* is no need to explicitly specify them, but if they are not present, we <br>* must NOT them out.  The parameter flStylePredef contains the style bits <br>* that identified the predefined control keyword itself (if any) and <br>* thus are removed from the style before writing anything out. <br>* <br>* Arguments: <br>*     INT iClass           = The class of the control. See the <br>*                            IC_ constants defined in dlgedit.h. <br>*     DWORD flStyle        = The style of control.  This nails <br>*                            down the exact type of control. <br>*     DWORD flStylePredef  = The styles bits implicit in the predefined <br>*                            keyword for this control.  This should be <br>*                            zero if this control doesn't have a predefined <br>*                            keyword for it. <br>*     DWORD flStyleDefault = The default styles that are implicit with <br>*                            this control.  This will only be set if this <br>*                            control is using a predefined RC keyword. A <br>*                            value of zero means that there are no default <br>*                            styles implicitly specified. <br>*     PDWORD pflStyleLeft  = Where to  return any style bits that do not <br>*                            get written out. <br>*     BOOL fPrevWritten    = TRUE means a previous style symbol has <br>*                            been written and to put " | " before <br>*                            the next symbol. <br>*     BOOL fNullStyles     = TRUE if we should still write the style word <br>*                            even if the style flag is zero.  This is used <br>*                            to handle the case where a predefined keyword <br>*                            has been written out that implies a style that <br>*                            also happens to be zero.  Without this flag <br>*                            being FALSE the style flag implicit in the <br>*                            keyword would be redundantly written out again. <br>*                            In general, if we have written out a predefined <br>*                            keyword this flag should be FALSE. <br>*     BOOL fCommaPrefix    = TRUE means that a comma will be written out <br>*                            before writing any styles.  This will only <br>*                            happen if fPrevWritten is FALSE.  If no styles <br>*                            are written, no comma will be written either. <br>* <br>* Returns: <br>*     TRUE =&gt; Something was written out. <br>*     FALSE =&gt; Nothing was written out. <br>* <br>************************************************************************/ </code></pre>
<p>
</p>
<pre><code><br>STATICFN BOOL WriteClassStyle( <br>    INT iClass, <br>    DWORD flStyle, <br>    DWORD flStylePredef, <br>    DWORD flStyleDefault, <br>    PDWORD pflStyleLeft, <br>    BOOL fPrevWritten, <br>    BOOL fNullStyles, <br>    BOOL fCommaPrefix) <br>{ <br>    register WORD i; <br>    WORD iMax; <br>    DWORD flStyleMask; <br>    PCLASSSTYLE pcs; <br> <br>    iMax = (WORD)acsd[iClass].cClassStyles; <br>    pcs = acsd[iClass].pacs; <br> <br>    /* <br>     * Remove the bits that identified the predefined control keyword <br>     * from the style flag before proceeding.  For instance, if I already <br>     * am going to be writing out a "PUSHBUTTON", there is no reason <br>     * to write out the "BS_PUSHBUTTON" style.  If there is no predefined <br>     * control keyword, flStylePredef will be zero and this will do <br>     * nothing. <br>     */ <br>    flStyle &amp;= ~flStylePredef; <br> <br>    /* <br>     * Go through all possible flags for this style. <br>     */ <br>    for (i = 0; i &lt; iMax; i++, pcs++) { <br>        flStyleMask = pcs-&gt;flStyleMask ? pcs-&gt;flStyleMask : pcs-&gt;flStyle; <br> <br>        /* <br>         * Is this styles bits set? <br>         */ <br>        if ((flStyle &amp; flStyleMask) == pcs-&gt;flStyle) { <br>            /* <br>             * Remove these bits from the styles left.  Even if <br>             * we do not write them out, they are still accounted <br>             * for and can be removed from the styles remaining. <br>             */ <br>            flStyle &amp;= ~pcs-&gt;flStyle; <br> <br>            /* <br>             * Skip this style if we don't want to write styles that are <br>             * zero, or if the style is already implicitly specified for <br>             * this control (a non-zero default style mask must be specified). <br>             */ <br>            if ((!pcs-&gt;flStyle &amp;&amp; !fNullStyles) || <br>                    (flStyleDefault &amp;&amp; <br>                    (flStyleDefault &amp; flStyleMask) == pcs-&gt;flStyle)) <br>                continue; <br> <br>            /* <br>             * If there is a string for this style, write it out, preceded <br>             * by an "|" symbol if necessary. <br>             */ <br>            if (*ids(acsd[iClass].idsStylesStart + i)) { <br>                if (fPrevWritten) { <br>                    ORSymbol(); <br>                } <br>                else { <br>                    if (fCommaPrefix) <br>                        Comma(); <br> <br>                    fPrevWritten = TRUE; <br>                } <br> <br>                /* <br>                 * Write the string. <br>                 */ <br>                WriteString(ids(acsd[iClass].idsStylesStart + i)); <br>            } <br>        } <br>        /* <br>         * No the styles bit is not set.  Is it implicit in the keyword <br>         * being used?  If so, we need to explicitly NOT it <br>         * out in the dialog template. <br>         * Note that this should not be done in the case where the style <br>         * is zero. <br>         */ <br>        else if (flStyleDefault &amp;&amp; <br>                (flStyleDefault &amp; flStyleMask) == pcs-&gt;flStyle &amp;&amp; <br>                pcs-&gt;flStyle) { <br>            if (fPrevWritten) { <br>                ORSymbol(); <br>            } <br>            else { <br>                if (fCommaPrefix) <br>                    Comma(); <br> <br>                fPrevWritten = TRUE; <br>            } <br> <br>            WriteString(ids(IDS_NOT)); <br>            Space(); <br>            WriteString(ids(acsd[iClass].idsStylesStart + i)); <br>        } <br>    } <br> <br>    /* <br>     * Pass back the style bits that were not written out. <br>     */ <br>    *pflStyleLeft = flStyle; <br> <br>    return fPrevWritten; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteCustomStyle <br>* <br>* Writes our the custom control information <br>* <br>* Arguments: <br>*    LPTSTR - class name of the control <br>*    DWORD - style of the control <br>*    PDWORD - styles left to be written <br>* <br>* Returns: <br>*    TRUE if custom styles were written out; otherwise, FALSE. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteCustomStyle( <br>    LPTSTR pszClass, <br>    DWORD flStyle, <br>    PDWORD pflStyleLeft) <br>{ <br>    PCUSTLINK pcl; <br>    LPCCSTYLEFLAG pStyleFlags; <br>    DWORD flStyleMask; <br>    INT i; <br>    BOOL fWritten = FALSE; <br> <br>    /* <br>     * Search the list of installed custom controls for one <br>     * that matches the class. <br>     */ <br>    for (pcl = gpclHead; <br>            pcl &amp;&amp; lstrcmpi(pcl-&gt;pwcd-&gt;pszClass, pszClass) != 0; <br>            pcl = pcl-&gt;pclNext) <br>        ; <br> <br>    /* <br>     * Was a match found and is this control from a DLL (not emulated)? <br>     */ <br>    if (pcl &amp;&amp; !pcl-&gt;pwcd-&gt;fEmulated) { <br>        for (i = 0, pStyleFlags = pcl-&gt;pwcd-&gt;aStyleFlags; <br>                i &lt; pcl-&gt;pwcd-&gt;cStyleFlags; <br>                i++, pStyleFlags++) { <br>            flStyleMask = pStyleFlags-&gt;flStyleMask ? <br>                    pStyleFlags-&gt;flStyleMask : pStyleFlags-&gt;flStyle; <br> <br>            /* <br>             * Is this styles bits set? <br>             */ <br>            if ((flStyle &amp; flStyleMask) == pStyleFlags-&gt;flStyle) { <br>                /* <br>                 * Remove these bits from the styles left. <br>                 */ <br>                flStyle &amp;= ~pStyleFlags-&gt;flStyle; <br> <br>                if (fWritten) <br>                    ORSymbol(); <br>                else <br>                    fWritten = TRUE; <br> <br>                /* <br>                 * Write the string. <br>                 */ <br>                WriteString(pStyleFlags-&gt;pszStyle); <br>            } <br>        } <br>    } <br> <br>    /* <br>     * Return the styles that remain to be written. <br>     */ <br>    *pflStyleLeft = flStyle; <br> <br>    return fWritten; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteCoords <br>* <br>* This function writes the coordinates out to the file as decimal <br>* ascii numbers separated by ", ". <br>* <br>* Arguments: <br>*     INT x, y, cx, cy = The coordinates. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteCoords( <br>    INT x, <br>    INT y, <br>    INT cx, <br>    INT cy) <br>{ <br>    WriteValue(x); <br>    Comma(); <br>    WriteValue(y); <br>    Comma(); <br>    WriteValue(cx); <br>    Comma(); <br>    WriteValue(cy); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteValue <br>* <br>* This function writes the value of 'n' as a decimal ascii string to <br>* the file. <br>* <br>* Arguments: <br>*     INT n = The number to write. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteValue( <br>    INT n) <br>{ <br>    TCHAR szNum[32]; <br> <br>    itoaw(n, szNum, 10); <br>    WriteString(szNum); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteHexWord <br>* <br>* This function writes the value of 'w' as a hex constant to the file. <br>* <br>* Arguments: <br>*     WORD w - The word to write. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteHexWord( <br>    WORD w) <br>{ <br>    TCHAR szNum[17]; <br> <br>    itoax(w, szNum); <br>    WriteString(szNum); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteHexDWord <br>* <br>* This function writes the value of 'dw' as a hex constant to the file. <br>* <br>* Arguments: <br>*     DWORD dw - The dword to write. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteHexDWord( <br>    DWORD dw) <br>{ <br>    TCHAR szNum[32]; <br> <br>    wsprintf(szNum, L"0x%8.8X", dw); <br>    WriteString(szNum); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteString <br>* <br>* This function writes the given string to the file.  If the string <br>* would cause it to overflow the margin, a new line, with indenting <br>* to the current tab level, is forced before writing the string. <br>* <br>* Arguments: <br>*   LPTSTR psz = The string to write out. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteString( <br>    LPTSTR psz) <br>{ <br>    register INT nLen; <br> <br>    nLen = lstrlen(psz); <br> <br>    if (!AtFirstTabColumn() &amp;&amp; cColumn + nLen &gt; CCHRIGHTMARGIN) <br>        NewLine(); <br> <br>    while (nLen--) <br>        WriteDlgChar(*psz++); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteQuotedString <br>* <br>* This function writes the given string to the file.  If the string <br>* would cause it to overflow the margin, a new line, with indenting <br>* to the current tab level, is forced before writing the string. <br>* This function will also enclose the given string in double-quotes, <br>* and ensures that the string will not be broken when it is written. <br>* If there are any escape characters (backslashes or quotes) in the <br>* string, they will be escaped properly so that rc.exe can read them <br>* properly. <br>* <br>* Arguments: <br>*   LPTSTR psz = The string to write out. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteQuotedString( <br>    LPTSTR psz) <br>{ <br>    register INT nLen; <br>    LPTSTR pszT; <br> <br>    /* <br>     * Find the actual length of the string.  To do this, we must scan <br>     * for the characters that will be escaped later. <br>     */ <br>    nLen = lstrlen(psz); <br>    pszT = psz; <br>    while (*pszT) { <br>        if (*pszT == CHAR_DBLQUOTE || *pszT == CHAR_BACKSLASH) <br>            nLen++; <br> <br>        pszT = CharNext(pszT); <br>    } <br> <br>    /* <br>     * Start a new line if necessary.  Add 2 for the quotes. <br>     */ <br>    if (!AtFirstTabColumn() &amp;&amp; cColumn + nLen + 2 &gt; CCHRIGHTMARGIN) <br>        NewLine(); <br> <br>    Quote(); <br>    WriteEscapedString(psz); <br>    Quote(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteEscapedString <br>* <br>* This function writes the given string to the file.  It is different <br>* from WriteString in that it will add a '\' in front of other <br>* backslashes and a second double quote in front of double quotes. <br>* This is necessary when writing out a string which will be surrounded <br>* by quotes, such as the Text fields in the .DLG file. <br>* <br>* Arguments: <br>*   LPTSTR psz = The string to write out. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteEscapedString( <br>    LPTSTR psz) <br>{ <br>    while (*psz) { <br>        if (*psz == CHAR_DBLQUOTE) <br>            WriteDlgChar(CHAR_DBLQUOTE); <br>        else if (*psz == CHAR_BACKSLASH) <br>#ifdef JAPAN <br>#ifndef UNICODE <br>#define wcsncmp     strncmp <br>#endif <br>            if ((wcsncmp(psz+1, TEXT("036"), 3)) &amp;&amp; <br>                (wcsncmp(psz+1, TEXT("037"), 3))) <br>#endif <br>            WriteDlgChar(CHAR_BACKSLASH); <br> <br>        if(IsDBCSLeadByte((BYTE)*psz)) <br>            WriteDlgChar(*psz++); <br>        WriteDlgChar(*psz++); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDlgChar <br>* <br>* Low level function to do an actual character write to the file. <br>* Some buffering is done then _lwrite is called. <br>* <br>* Because it is buffered, before closing the file any remaining <br>* characters in the buffer must be flushed to disk using WriteDlgFlush. <br>* <br>* If an error occurs on the write, Throw will be called to jump back <br>* up to WriteDlg and return the failure to the caller. <br>* <br>* The globals gachWriteBuffer and cbWritePos are updated by this routine. <br>* <br>* Arguments: <br>*     TCHAR ch - The character to write. <br>* <br>* Returns: <br>*   If an error occurs on the _lwrite, the execution will be thrown <br>*   back to the WriteDlg function.  Otherwise, nothing is returned. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteDlgChar( <br>    TCHAR ch) <br>{ <br>    INT cbWritten; <br> <br>    gachWriteBuffer[cbWritePos++] = ch; <br> <br>    /* <br>     * Is the buffer full? <br>     */ <br>    if (cbWritePos == CCHFILEBUFFER) { <br>// The abWriteBuffer[] is too small for Japanese language. <br>        // Please don't assume WideChar_length/2 == MultiByte_length. <br>        // July 12, 1992 by ShigeO <br>        CHAR abWriteBuffer[CCHFILEBUFFER*2]; <br>        BOOL fDefCharUsed; <br>        int  iRequired = <br> <br>        WideCharToMultiByte(CP_ACP, 0, gachWriteBuffer, CCHFILEBUFFER, <br>                abWriteBuffer, CCHFILEBUFFER*2, NULL, &amp;fDefCharUsed); <br> <br>        cbWritten = (INT)_lwrite((HFILE)hfDlg, abWriteBuffer, iRequired); <br>        if (cbWritten != iRequired) <br>            longjmp(jbWriteDlg, 1); <br> <br>        cbWritePos = 0; <br>    } <br> <br>    /* <br>     * Update the current column counter. <br>     */ <br>    if (ch == CHAR_RETURN || ch == CHAR_NEWLINE) { <br>        /* <br>         * Carriage return or newline resets column position to 0. <br>         */ <br>        cColumn = 0; <br>    } <br>    else { <br>        cColumn++; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDlgFlush <br>* <br>* This routine flushes the write buffer.  This must be done before <br>* the file is closed or data can be lost. <br>* <br>* The global cbWritePos is updated by this routine. <br>* <br>* Returns: <br>*   If an error occurs on the _lwrite, the execution will be thrown <br>*   back to the WriteDlg function.  Otherwise, nothing is returned. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID WriteDlgFlush(VOID) <br>{ <br>    INT cbWritten; <br> <br>    /* <br>     * Are any bytes remaining in the buffer? <br>     */ <br>    if (cbWritePos) { <br>// The abWriteBuffer[] is too small for Japanese language. <br>        // Please don't assume WideChar_length/2 == MultiByte_length. <br>        // July 12, 1992 by ShigeO <br>        CHAR abWriteBuffer[CCHFILEBUFFER*2]; <br>        BOOL fDefCharUsed; <br>        int  iRequired = <br> <br>        WideCharToMultiByte(CP_ACP, 0, gachWriteBuffer, cbWritePos, <br>                abWriteBuffer, CCHFILEBUFFER*2, NULL, &amp;fDefCharUsed); <br> <br>        cbWritten = (INT)_lwrite((HFILE)hfDlg, abWriteBuffer, iRequired); <br>        if (cbWritten != iRequired) <br>            longjmp(jbWriteDlg, 1); <br> <br>        cbWritePos = 0; <br>    } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* Tab <br>* <br>* Writes spaces up to the current tab level setting. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID Tab(VOID) <br>{ <br>    while (cColumn &lt; cTabStop) <br>        WriteDlgChar(CHAR_SPACE); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* NewLine <br>* <br>* Begins a new line by writing a carriage return and linefeed.  Also <br>* indents the following line up to the current tab level. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID NewLine(VOID) <br>{ <br>    WriteDlgChar(CHAR_RETURN); <br>    WriteDlgChar(CHAR_NEWLINE); <br>    Tab(); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* Quote <br>* <br>* Writes a double quote. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID Quote(VOID) <br>{ <br>    WriteDlgChar(CHAR_DBLQUOTE); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* Comma <br>* <br>* Writes a comma then a space. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID Comma(VOID) <br>{ <br>    WriteDlgChar(CHAR_COMMA); <br>    WriteDlgChar(CHAR_SPACE); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* Space <br>* <br>* Writes a space. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID Space(VOID) <br>{ <br>    WriteDlgChar(CHAR_SPACE); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ORSymbol <br>* <br>* Writes " | ". <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID ORSymbol(VOID) <br>{ <br>    WriteDlgChar(CHAR_SPACE); <br>    WriteDlgChar(CHAR_ORSYMBOL); <br>    WriteDlgChar(CHAR_SPACE); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
