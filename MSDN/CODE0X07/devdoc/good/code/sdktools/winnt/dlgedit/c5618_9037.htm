<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLBOX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5623"></a>TOOLBOX.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: toolbox.c <br>* <br>* Contains routines that handle the toolbox. <br>* <br>* Functions: <br>* <br>*    ToolboxShow() <br>*    ToolboxOnTop() <br>*    ToolboxWndProc() <br>*    ToolBtnWndProc() <br>*    ToolboxSelectTool() <br>*    ToolboxCreate() <br>*    ToolboxDrawBitmap() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>#include "dialogs.h" <br> <br> <br>#define TOOLBOXMARGIN   2       // Pixels around the buttons in the Toolbox. <br>#define TOOLBOXCOLUMNS  2       // Columns in the Toolbox. <br> <br>/* <br> * Style of the toolbox window. <br> */ <br>#define TOOLBOXSTYLE    (WS_POPUP | WS_CLIPSIBLINGS | WS_CAPTION | WS_SYSMENU) <br> <br>STATICFN VOID ToolboxCreate(VOID); <br>STATICFN VOID ToolboxDrawBitmap(HDC hDC, INT type); <br> <br>/* <br> * Dimensions of a tool button bitmap. <br> */ <br>static INT cxToolBtn; <br>static INT cyToolBtn; <br> <br> <br> <br>/**************************************************************************** <br>* ToolboxShow <br>* <br>* This function shows or hides the toolbox window.  It will create <br>* the Toolbox if necessary. <br>* <br>* Arguments: <br>*   BOOL fShow - whether to show or hide the toolbox window. <br>* <br>****************************************************************************/ <br> <br>VOID ToolboxShow( <br>    BOOL fShow) <br>{ <br>    if (fShow) { <br>        /* <br>         * Don't allow a toolbox to be shown in Translate mode. <br>         */ <br>        if (gfTranslateMode) <br>            return; <br> <br>        /* <br>         * Create it if it doesn't exist yet. <br>         */ <br>        if (!ghwndToolbox) <br>            ToolboxCreate(); <br> <br>        if (ghwndToolbox) <br>            ShowWindow(ghwndToolbox, SW_SHOWNA); <br>    } <br>    else { <br>        if (ghwndToolbox) <br>            ShowWindow(ghwndToolbox, SW_HIDE); <br>    } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ToolboxOnTop <br>* <br>* This function positions the toolbox window on top.  It needs to be <br>* called any time that a new dialog window is created to be sure the <br>* dialog does not cover the toolbox. <br>* <br>* It can be called even if the toolbox is not created yet (it will <br>* be a noop in that case). <br>* <br>****************************************************************************/ <br> <br>VOID ToolboxOnTop(VOID) <br>{ <br>   if (ghwndToolbox) { <br>       SetWindowPos(ghwndToolbox, NULL, 0, 0, 0, 0, <br>               SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE); <br>   } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ToolboxCreate <br>* <br>* This function creates the toolbox window. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID ToolboxCreate(VOID) <br>{ <br>    BITMAP bmp; <br>    INT i; <br>    INT x; <br>    INT y; <br>    INT cx; <br>    INT cy; <br>    INT cxDummy; <br>    INT cyDummy; <br>    RECT rc; <br>    RECT rcSubClient; <br>    BOOL fMaximized; <br> <br>    /* <br>     * Load the bitmaps. <br>     */ <br>    if (!(ghbmPointerToolUp = LoadBitmap(ghInst, <br>            MAKEINTRESOURCE(IDBM_TUPOINTR))) || <br>            !(ghbmPointerToolDown = LoadBitmap(ghInst, <br>            MAKEINTRESOURCE(IDBM_TDPOINTR)))) <br>        return; <br> <br>    for (i = 0; i &lt; CCONTROLS; i++) { <br>        if (!(awcd[i].hbmToolBtnUp = LoadBitmap(ghInst, <br>                MAKEINTRESOURCE(awcd[i].idbmToolBtnUp)))) <br>            return; <br> <br>        if (!(awcd[i].hbmToolBtnDown = LoadBitmap(ghInst, <br>                MAKEINTRESOURCE(awcd[i].idbmToolBtnDown)))) <br>            return; <br>    } <br> <br>    /* <br>     * Get the dimensions of the tool button bitmaps. <br>     */ <br>    GetObject(awcd[0].hbmToolBtnUp, sizeof(BITMAP), &amp;bmp); <br>    cxToolBtn = bmp.bmWidth; <br>    cyToolBtn = bmp.bmHeight; <br> <br>    /* <br>     * Calculate the required window size for the client area <br>     * size we want.  The size leaves room for a margin, and <br>     * assumes that adjacent buttons overlap their borders by <br>     * one pixel. <br>     */ <br>    rc.left = 0; <br>    rc.top = 0; <br>    rc.right = TOOLBOXMARGIN + ((cxToolBtn - 1) * 2) + 1 + TOOLBOXMARGIN; <br>    rc.bottom = TOOLBOXMARGIN + ((cyToolBtn - 1) * <br>            ((CCONTROLS / 2) + 1)) + 1 + TOOLBOXMARGIN; <br>    AdjustWindowRect(&amp;rc, TOOLBOXSTYLE, FALSE); <br>    cx = rc.right - rc.left; <br>    cy = rc.bottom - rc.top; <br> <br>    /* <br>     * Get the saved position of the Toolbox.  Note that we throw away <br>     * the size fields, because we just calculated the required size. <br>     */ <br>    if (!ReadWindowPos(szTBPos, &amp;x, &amp;y, &amp;cxDummy, &amp;cyDummy, &amp;fMaximized)) { <br>        /* <br>         * The previous position of the Toolbox  couldn't be found. <br>         * Position the toolbox to the upper right corner of the <br>         * "client" area of the editor, but make sure it is completely <br>         * visible. <br>         */ <br>        GetWindowRect(ghwndSubClient, &amp;rcSubClient); <br>        x = rcSubClient.right - cx - (2 * TOOLBOXMARGIN); <br>        y = rcSubClient.top + (2 * TOOLBOXMARGIN); <br>        SetRect(&amp;rc, x, y, x + cx, y + cy); <br>        FitRectToScreen(&amp;rc); <br>        x = rc.left; <br>        y = rc.top; <br>    } <br> <br>    /* <br>     * Create the toolbox window. <br>     */ <br>    if (!(ghwndToolbox = CreateWindow(szToolboxClass, NULL, TOOLBOXSTYLE, <br>            x, y, cx, cy, ghwndMain, NULL, ghInst, NULL))) <br>        return; <br> <br>    /* <br>     * Create the Pointer (W_NOTHING) button. <br>     */ <br>    CreateWindow(szToolBtnClass, NULL, <br>            WS_CHILD | WS_VISIBLE, <br>            TOOLBOXMARGIN, TOOLBOXMARGIN, (cxToolBtn * 2) - 1, cyToolBtn, <br>            ghwndToolbox, (HMENU)W_NOTHING, ghInst, NULL); <br> <br>    /* <br>     * Create the other buttons. <br>     */ <br>    x = TOOLBOXMARGIN; <br>    y = TOOLBOXMARGIN + cyToolBtn - 1; <br>    for (i = 0; i &lt; CCONTROLS; i++) { <br>        CreateWindow(szToolBtnClass, NULL, <br>                WS_CHILD | WS_VISIBLE, <br>                x, y, cxToolBtn, cyToolBtn, <br>                ghwndToolbox, (HMENU)i, ghInst, NULL); <br> <br>        if (x == TOOLBOXMARGIN) { <br>            x += cxToolBtn - 1; <br>        } <br>        else { <br>            x = TOOLBOXMARGIN; <br>            y += cyToolBtn - 1; <br>        } <br>    } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ToolboxWndProc <br>* <br>* This is the window procedure for the toolbox window. <br>* <br>****************************************************************************/ <br> <br>WINDOWPROC ToolboxWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_CREATE: <br>            { <br>                HMENU hmenu = GetSystemMenu(hwnd, FALSE); <br> <br>                RemoveMenu(hmenu, 7, MF_BYPOSITION);    // Second separator. <br>                RemoveMenu(hmenu, 5, MF_BYPOSITION);    // First separator. <br> <br>                RemoveMenu(hmenu, SC_RESTORE, MF_BYCOMMAND); <br>                RemoveMenu(hmenu, SC_SIZE, MF_BYCOMMAND); <br>                RemoveMenu(hmenu, SC_MINIMIZE, MF_BYCOMMAND); <br>                RemoveMenu(hmenu, SC_MAXIMIZE, MF_BYCOMMAND); <br>                RemoveMenu(hmenu, SC_TASKLIST, MF_BYCOMMAND); <br>            } <br> <br>            return 0; <br> <br>        case WM_KEYDOWN: <br>            { <br>                INT iToolNext; <br> <br>                switch (wParam) { <br>                    case VK_UP: <br>                        if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                            break; <br> <br>                        /* <br>                         * Go up a row, but don't go beyond the top. <br>                         */ <br>                        iToolNext = gCurTool - TOOLBOXCOLUMNS; <br>                        if (iToolNext &lt; 0) <br>                            iToolNext = W_NOTHING; <br> <br>                        ToolboxSelectTool(iToolNext, FALSE); <br> <br>                        break; <br> <br>                    case VK_DOWN: <br>                        if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                            break; <br> <br>                        if (gCurTool == W_NOTHING) { <br>                            iToolNext = 0; <br>                        } <br>                        else { <br>                            /* <br>                             * Go down a row, but don't go beyond the bottom. <br>                             */ <br>                            iToolNext = gCurTool + TOOLBOXCOLUMNS; <br>                            if (iToolNext &gt;= CCONTROLS) <br>                                break; <br>                        } <br> <br>                        ToolboxSelectTool(iToolNext, FALSE); <br> <br>                        break; <br> <br>                    case VK_LEFT: <br>                        if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                            break; <br> <br>                        if (gCurTool == W_NOTHING || <br>                                !(gCurTool % TOOLBOXCOLUMNS)) <br>                            break; <br> <br>                        /* <br>                         * Go left a column. <br>                         */ <br>                        ToolboxSelectTool(gCurTool - 1, FALSE); <br> <br>                        break; <br> <br>                    case VK_RIGHT: <br>                        if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                            break; <br> <br>                        if (gCurTool == W_NOTHING || <br>                                (gCurTool % TOOLBOXCOLUMNS) == <br>                                TOOLBOXCOLUMNS - 1) <br>                            break; <br> <br>                        /* <br>                         * Go right a column. <br>                         */ <br>                        ToolboxSelectTool(gCurTool + 1, FALSE); <br> <br>                        break; <br> <br>                    case VK_TAB: <br>                        if (GetKeyState(VK_CONTROL) &amp; 0x8000) <br>                            break; <br> <br>                        /* <br>                         * Is the shift key pressed also? <br>                         */ <br>                        if (GetKeyState(VK_SHIFT) &amp; 0x8000) { <br>                            if (gCurTool == W_NOTHING) <br>                                iToolNext = CCONTROLS - 1; <br>                            else if (gCurTool == 0) <br>                                iToolNext = W_NOTHING; <br>                            else <br>                                iToolNext = gCurTool - 1; <br>                        } <br>                        else { <br>                            if (gCurTool == W_NOTHING) <br>                                iToolNext = 0; <br>                            else if (gCurTool == CCONTROLS - 1) <br>                                iToolNext = W_NOTHING; <br>                            else <br>                                iToolNext = gCurTool + 1; <br>                        } <br> <br>                        ToolboxSelectTool(iToolNext, FALSE); <br> <br>                        break; <br> <br>                    case VK_END: <br>                        if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                            break; <br> <br>                        ToolboxSelectTool(CCONTROLS - 1, FALSE); <br> <br>                        break; <br> <br>                    case VK_HOME: <br>                    case VK_ESCAPE: <br>                        if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                                (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                            break; <br> <br>                        ToolboxSelectTool(W_NOTHING, FALSE); <br> <br>                        break; <br>                } <br>            } <br> <br>            break; <br> <br>        case WM_ACTIVATE: <br>            if (LOWORD(wParam)) <br>                gidCurrentDlg = DID_TOOLBOX; <br> <br>            break; <br> <br>        case WM_CLOSE: <br>            /* <br>             * The user closed the toolbox from the system menu. <br>             * Hide the toolbox (we don't actually destroy it so <br>             * that it will appear in the same spot when they show <br>             * it again). <br>             */ <br>            ToolboxShow(FALSE); <br>            gfShowToolbox = FALSE; <br>            break; <br> <br>        case WM_DESTROY: <br>            { <br>                INT i; <br>                RECT rc; <br> <br>                DeleteObject(ghbmPointerToolUp); <br>                ghbmPointerToolUp = NULL; <br>                DeleteObject(ghbmPointerToolDown); <br>                ghbmPointerToolDown = NULL; <br> <br>                for (i = 0; i &lt; CCONTROLS; i++) { <br>                    DeleteObject(awcd[i].hbmToolBtnUp); <br>                    awcd[i].hbmToolBtnUp = NULL; <br>                    DeleteObject(awcd[i].hbmToolBtnDown); <br>                    awcd[i].hbmToolBtnDown = NULL; <br>                } <br> <br>                /* <br>                 * Save the position of the toolbox. <br>                 */ <br>                GetWindowRect(hwnd, &amp;rc); <br>                WriteWindowPos(&amp;rc, FALSE, szTBPos); <br> <br>                /* <br>                 * Null out the global window handle for the toolbox <br>                 * for safety's sake. <br>                 */ <br>                ghwndToolbox = NULL; <br>            } <br> <br>            break; <br> <br>        default: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ToolBtnWndProc <br>* <br>* This is the window procedure for the buttons in the toolbox window. <br>* <br>****************************************************************************/ <br> <br>WINDOWPROC ToolBtnWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_LBUTTONDOWN: <br>            /* <br>             * Be sure any outstanding changes get applied <br>             * without errors. <br>             */ <br>            if (!StatusApplyChanges()) <br>                return TRUE; <br> <br>            /* <br>             * Select the tool that was clicked on.  If the Ctrl <br>             * key is down, lock the tool also. <br>             */ <br>            ToolboxSelectTool((UINT)GetWindowLong((hwnd), GWL_ID), <br>                    (GetKeyState(VK_CONTROL) &amp; 0x8000) ? TRUE : FALSE); <br> <br>            break; <br> <br>        case WM_PAINT: <br>            { <br>                HDC hDC; <br>                PAINTSTRUCT ps; <br> <br>                hDC = BeginPaint(hwnd, &amp;ps); <br>                ToolboxDrawBitmap(hDC, (UINT)GetWindowLong((hwnd), GWL_ID)); <br>                EndPaint(hwnd, &amp;ps); <br>            } <br> <br>            break; <br> <br>        default: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ToolboxDrawBitmap <br>* <br>* Draws the current tool bitmap. <br>* <br>* Arguments: <br>*   HDC hDC - handle to the DC for the toolbox window. <br>*   INR type - type of bitmap to draw. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID ToolboxDrawBitmap( <br>    HDC hDC, <br>    INT type) <br>{ <br>    HDC hMemDC; <br>    HBITMAP hbm; <br>    HBITMAP hbmOld; <br>    INT cxBitmap; <br> <br>    if (type == W_NOTHING) { <br>        hbm = (type == gCurTool) ? ghbmPointerToolDown : ghbmPointerToolUp; <br> <br>        /* <br>         * Note that the size of the Pointer tool is twice the width <br>         * of the other bitmaps, but less one pixel.  This is because <br>         * the other tools overlap their adjacent borders. <br>         */ <br>        cxBitmap = (cxToolBtn * 2) - 1; <br>    } <br>    else { <br>        hbm = (type == gCurTool) ? <br>                awcd[type].hbmToolBtnDown : awcd[type].hbmToolBtnUp; <br>        cxBitmap = cxToolBtn; <br>    } <br> <br>    /* <br>     * Draw the image. <br>     */ <br>    hMemDC = CreateCompatibleDC(hDC); <br>    hbmOld = SelectObject(hMemDC, hbm); <br>    BitBlt(hDC, 0, 0, cxBitmap, cyToolBtn, hMemDC, 0, 0, SRCCOPY); <br>    SelectObject(hMemDC, hbmOld); <br>    DeleteDC(hMemDC); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* ToolboxSelectTool <br>* <br>* This function selects a tool to be the current tool. <br>* <br>* Arguments: <br>*   INT type   - Type of control (one of the W_* defines). <br>*   BOOL fLock - TRUE if the tool should be locked down. <br>* <br>****************************************************************************/ <br> <br>VOID ToolboxSelectTool( <br>    INT type, <br>    BOOL fLock) <br>{ <br>    PWINDOWCLASSDESC pwcd; <br> <br>    if (gCurTool != type) { <br>        /* <br>         * Set the current wcd global for the current tool type. <br>         * This will point to the WINDOWCLASSDESC structure of the <br>         * current tool.  If the Custom tool was selected, the user <br>         * is asked which of the installed custom controls that they <br>         * really want. <br>         */ <br>        if (type == W_CUSTOM) { <br>            /* <br>             * There are no custom controls installed.  Beep and <br>             * return without doing anything. <br>             */ <br>            if (!gpclHead) { <br>                MessageBeep(0); <br>                return; <br>            } <br> <br>            /* <br>             * If there are multiple custom controls installed, <br>             * ask the user which one they want.  Note that they <br>             * can press Cancel and return NULL! <br>             */ <br>            if (gpclHead-&gt;pclNext) { <br>                if (!(pwcd = SelCustDialog())) <br>                    return; <br> <br>                gpwcdCurTool = pwcd; <br>            } <br>            else { <br>                /* <br>                 * Since there is only one type of custom control <br>                 * installed, there is no need to ask the user <br>                 * which one they want. <br>                 */ <br>                gpwcdCurTool = gpclHead-&gt;pwcd; <br>            } <br>        } <br>        else { <br>            gpwcdCurTool = (type == W_NOTHING) ? NULL : &amp;awcd[type]; <br>        } <br> <br>        /* <br>         * Force the previous and current buttons to repaint. <br>         */ <br>        if (ghwndToolbox) { <br>            InvalidateRect(GetDlgItem(ghwndToolbox, gCurTool), NULL, FALSE); <br>            InvalidateRect(GetDlgItem(ghwndToolbox, type), NULL, FALSE); <br>        } <br> <br>        /* <br>         * Set the current tool type global.  This will be W_CUSTOM for <br>         * all custom controls. <br>         */ <br>        gCurTool = type; <br>    } <br> <br>    gfToolLocked = fLock; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
