<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADDCTRL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5613"></a>ADDCTRL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: addctrl.c <br>* <br>* Contains routines for adding (creating) and deleting controls. <br>* <br>* Functions: <br>* <br>*    AddNewDialog() <br>*    DropControl() <br>*    AddControl() <br>*    CreateControl() <br>*    CreateDlgFont() <br>*    MyGetCharDimensions() <br>*    AdjustDefaultSizes() <br>*    DeleteControl() <br>*    DeleteDialog() <br>*    DeleteControl2() <br>*    FreeCTYPE() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>STATICFN HFONT CreateDlgFont(HWND hwnd, LPTSTR pszFontName, <br>    INT nPointSize); <br>STATICFN INT MyGetCharDimensions(HWND hwnd, HFONT hFont, <br>    PTEXTMETRIC ptm); <br>STATICFN VOID AdjustDefaultSizes(VOID); <br>STATICFN VOID DeleteControl2(NPCTYPE npcDel); <br>STATICFN VOID FreeCTYPE(NPCTYPE npc); <br> <br>int CALLBACK GetFontCharSetEnumFunc(LPLOGFONT,LPTEXTMETRIC,int,LPARAM); <br>STATICFN BYTE NEAR GetFontCharSet(LPTSTR); <br> <br> <br>/************************************************************************ <br>* AddNewDialog <br>* <br>* High level function to add a new dialog to the current resource. <br>* Any existing dialog will be saved away in the resource buffer. <br>* The dialog is created at a default position and size with default <br>* styles. <br>* <br>************************************************************************/ <br> <br>VOID AddNewDialog(VOID) <br>{ <br>    RECT rc; <br> <br>    if (gfEditingDlg) { <br>        if (!SynchDialogResource()) <br>            return; <br> <br>        DeleteDialog(FALSE); <br>    } <br> <br>    /* <br>     * Now drop a new dialog window. <br>     */ <br>    SetRect(&amp;rc, DEFDIALOGXPOS, DEFDIALOGYPOS, <br>            DEFDIALOGXPOS + awcd[W_DIALOG].cxDefault, <br>            DEFDIALOGYPOS + awcd[W_DIALOG].cyDefault); <br>    DropControl(&amp;awcd[W_DIALOG], &amp;rc); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DropControl <br>* <br>* This function drops a new control of Type at the specified <br>* location.  The default style and text of the control is <br>* determined from the awcd table based on its type.  The control <br>* is selected after being dropped. <br>* <br>* <br>* Arguments: <br>*   PWINDOWCLASSDESC pwcd - Describes the type of new control. <br>*   PRECT prc             - Rectangle of the new control (in dialog units). <br>* <br>************************************************************************/ <br> <br>VOID DropControl( <br>    PWINDOWCLASSDESC pwcd, <br>    PRECT prc) <br>{ <br>    ORDINAL ordIcon; <br>    ORDINAL ordDlg; <br>    LPTSTR pszText; <br>    NPCTYPE npcNew; <br>    INT idCtrl; <br>    DIALOGINFO di; <br> <br>    /* <br>     * Get the next available id to use for the new control. <br>     */ <br>    idCtrl = NextID((pwcd-&gt;iType == W_DIALOG) ? NEXTID_DIALOG : NEXTID_CONTROL, <br>            plInclude, 0); <br> <br>    if (pwcd-&gt;iType == W_ICON) { <br>        /* <br>         * For icon controls, the text is really an ordinal or name <br>         * of the icon resource to display.  We get the next available <br>         * id (skipping the id we just got for the control itself) to <br>         * use as an ordinal. <br>         */ <br>        WriteOrd(&amp;ordIcon, NextID(NEXTID_CONTROL, plInclude, idCtrl)); <br>        pszText = (LPTSTR)&amp;ordIcon; <br>    } <br>    else { <br>        pszText = pwcd-&gt;pszTextDefault; <br>    } <br> <br>    /* <br>     * Make the control. <br>     */ <br>    if (pwcd-&gt;iType == W_DIALOG) { <br>        /* <br>         * Pick a default name for the dialog. <br>         */ <br>        WriteOrd(&amp;ordDlg, NextID(NEXTID_DIALOG, plInclude, 0)); <br> <br>        di.fResFlags = DEFDLGMEMFLAGS; <br>//      di.wLanguage = GetUserDefaultLangID(); <br>di.wLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL); <br>        di.pszClass = NULL; <br>        di.pszMenu = NULL; <br>        di.DataVersion = 0; <br>        di.Version = 0; <br>        di.Characteristics = 0; <br>        di.nPointSize = DEFPOINTSIZE; <br>        lstrcpy(di.szFontName, ids(IDS_DEFFONTNAME)); <br> <br>        npcNew = AddControl(pwcd, pszText, <br>                pwcd-&gt;flStyles, pwcd-&gt;flExtStyle, idCtrl, <br>                prc-&gt;left, prc-&gt;top, <br>                prc-&gt;right - prc-&gt;left, prc-&gt;bottom - prc-&gt;top, <br>                (LPTSTR)&amp;ordDlg, &amp;di); <br>    } <br>    else { <br>        npcNew = AddControl(pwcd, pszText, <br>                pwcd-&gt;flStyles, pwcd-&gt;flExtStyle, idCtrl, <br>                prc-&gt;left, prc-&gt;top, <br>                prc-&gt;right - prc-&gt;left, prc-&gt;bottom - prc-&gt;top, <br>                NULL, NULL); <br>    } <br> <br>    if (!npcNew) <br>        return; <br> <br>    /* <br>     * If we just dropped a dialog, we need to now show it. <br>     * It it was some other control, mark the dialog as having <br>     * been changed. <br>     */ <br>    if (pwcd-&gt;iType == W_DIALOG) { <br>        ShowWindow(npcNew-&gt;hwnd, SW_SHOWNA); <br>        ToolboxOnTop(); <br>    } <br>    else { <br>        gfDlgChanged = TRUE; <br>    } <br> <br>    SelectControl(npcNew, FALSE); <br> <br>    gfResChged = TRUE; <br>    ShowFileStatus(FALSE); <br> <br>    /* <br>     * Now we determine if one of the fields in the status ribbon <br>     * should be given the focus initially.  The assumption is that <br>     * there are some things that a user will always want to change <br>     * when dropping a new control, such as the text in a push <br>     * button, for example. <br>     */ <br>    idCtrl = 0; <br>    switch (pwcd-&gt;iType) { <br>        case W_ICON: <br>            /* <br>             * For icons, the first thing the user will <br>             * probably want to do is to change the name. <br>             */ <br>            idCtrl = DID_STATUSNAME; <br>            break; <br> <br>        default: <br>            /* <br>             * If this control has text, they will probably want <br>             * to change it.  This includes the caption if the <br>             * control is a dialog. <br>             */ <br>            if (pwcd-&gt;fHasText) <br>                idCtrl = DID_STATUSTEXT; <br> <br>            break; <br>    } <br> <br>    if (idCtrl) { <br>        SendDlgItemMessage(hwndStatus, idCtrl, <br> EM_SETSEL, (WPARAM)(0), (LONG)(-1)); <br>        SetFocus(GetDlgItem(hwndStatus, idCtrl)); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* AddControl <br>* <br>* This function is used to add a new control.  CreateControl() does <br>* half the work. <br>* <br>* Arguments: <br>*   PWINDOWCLASSDESC pwcd - Window class structure.  Describes the <br>*                           type of control to add. <br>*   LPTSTR pszText        - Text for the new control. <br>*   DWORD style           - Style of the new control. <br>*   DWORD flExtStyle      - Extended style of the new control. <br>*   INT id                - ID for the new control. <br>*   INT x                 - X location of the new control. <br>*   INT y                 - Y location of the new control. <br>*   INT cx                - Width of the new control. <br>*   INT cy                - Height of the new control. <br>*   LPTSTR pszDlgName     - For dialogs, has dialog name. <br>*   PDIALOGINFO pdi       - Ptr to additional dialog info (NULL for controls). <br>* <br>* Returns: <br>*     A pointer to the CTYPE structure for the new control. <br>*     NULL if it couldn't create the control. <br>* <br>************************************************************************/ <br> <br>NPCTYPE AddControl( <br>    PWINDOWCLASSDESC pwcd, <br>    LPTSTR pszText, <br>    DWORD style, <br>    DWORD flExtStyle, <br>    INT id, <br>    INT x, <br>    INT y, <br>    INT cx, <br>    INT cy, <br>    LPTSTR pszDlgName, <br>    PDIALOGINFO pdi) <br>{ <br>    NPCTYPE npcNew; <br>    NPCTYPE npcT; <br>    NPCTYPE *npnpcLast; <br>    HWND hwndBehind; <br> <br>    if (!(npcNew = (NPCTYPE)MyAlloc(sizeof(CTYPE)))) <br>        return NULL; <br> <br>    /* <br>     * These are checked later if a failure occurs, <br>     * so we null them out now. <br>     */ <br>    npcNew-&gt;hwnd = NULL; <br>    npcNew-&gt;hwndDrag = NULL; <br>    npcNew-&gt;text = NULL; <br> <br>    /* <br>     * Set up some fields and create the control. <br>     */ <br>    npcNew-&gt;npcNext = NULL; <br>    npcNew-&gt;pwcd = pwcd; <br>    npcNew-&gt;fSelected = FALSE; <br>    SetRect(&amp;npcNew-&gt;rc, x, y, x + cx, y + cy); <br> <br>    if (pwcd-&gt;iType == W_DIALOG) <br>        hwndBehind = (HWND)NULL; <br>    else <br>        hwndBehind = (HWND)1; <br> <br>    if (!CreateControl(npcNew, pszText, style, flExtStyle, id, &amp;npcNew-&gt;rc, <br>            hwndBehind, pdi)) <br>        goto CreateFailed; <br> <br>    /* <br>     * Create the drag window, unless this is the dialog. <br>     */ <br>    if (pwcd-&gt;iType != W_DIALOG) { <br>        npcNew-&gt;hwndDrag = CreateWindow( <br>                szDragClass, <br>                NULL, <br>                WS_CHILD, <br>                0, 0, 0, 0, <br>                gcd.npc-&gt;hwnd, <br>                NULL, <br>                ghInst, <br>                NULL); <br> <br>        /* <br>         * Store the CTYPE pointer into the control's drag window. <br>         * This will be used by PCFROMHWND later. <br>         */ <br>        SETPCINTOHWND(npcNew-&gt;hwndDrag, npcNew); <br> <br>        /* <br>         * Move the drag window to the top of the Z-Order. <br>         */ <br>        SetWindowPos(npcNew-&gt;hwndDrag, NULL, 0, 0, 0, 0, <br>                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW); <br> <br>        SizeDragToControl(npcNew); <br>    } <br> <br>    /* <br>     * Did we just create a dialog? <br>     */ <br>    if (pwcd-&gt;iType == W_DIALOG) { <br>        /* <br>         * First, copy the new name (it can be an ordinal!). <br>         */ <br>        if (!(gcd.pszDlgName = MyAlloc(NameOrdLen(pszDlgName)))) <br>            goto CreateFailed; <br> <br>        NameOrdCpy(gcd.pszDlgName, pszDlgName); <br> <br>        /* <br>         * Now, setup some other globals.  We clear the gcd.prl pointer, <br>         * because we are assuming that this dialog was not created <br>         * from a res link (it was dropped instead).  The routines <br>         * that call AddControl when creating a dialog from a res <br>         * link are  responsible for setting this global later. <br>         */ <br>        gcd.prl = NULL; <br>        gcd.npc = npcNew; <br>        gfEditingDlg = TRUE; <br>    } <br>    else { <br>        /* <br>         * Search for the last control in the list. <br>         */ <br>        npnpcLast = &amp;npcHead; <br>        for (npcT = npcHead; npcT; npcT = npcT-&gt;npcNext) <br>            npnpcLast = &amp;npcT-&gt;npcNext; <br> <br>        /* <br>         * Link in the new control at the end of the list. <br>         */ <br>        *npnpcLast = npcNew; <br>        cWindows++; <br>    } <br> <br>    return npcNew; <br> <br>CreateFailed: <br>    FreeCTYPE(npcNew); <br>    return NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* CreateControl <br>* <br>* Creates a control.  Some styles may be masked off of the actual <br>* control created.  This function can also create the dialog box. <br>* <br>* If the control created is the dialog box, it will not be made visible. <br>* This must be done by the caller.  This allows the caller to first add <br>* all the controls to the dialog before showing it. <br>* <br>* The x, y, cx and cy coordinates are all in dialog units.  For a <br>* type of W_DIALOG, this will be relative to the apps client.  For a <br>* control, this will be relative to the "client" area of the dialog. <br>* <br>* Arguments: <br>*   NPCTYPE npc       - The CTYPE pointer to the new control.  The hwnd <br>*                       fields of the npc will be set. <br>*   LPTSTR pszText    - The window text. <br>*   DWORD flStyle     - The style to use. <br>*   DWORD flExtStyle  - Extended style of the new control. <br>*   INT id            - ID for the control. <br>*   PRECT prc         - The size and location of the new control. <br>*   HWND hwndBehind   - Put new control behind this hwnd in Z-order. <br>*   PDIALOGINFO pdi   - Pointer to additional dialog info (NULL for controls). <br>* <br>* Returns: <br>*     Handle of the control created. <br>*     NULL if control was not created. <br>* <br>************************************************************************/ <br> <br>HWND CreateControl( <br>    NPCTYPE npc, <br>    LPTSTR pszText, <br>    DWORD flStyle, <br>    DWORD flExtStyle, <br>    INT id, <br>    PRECT prc, <br>    HWND hwndBehind, <br>    PDIALOGINFO pdi) <br>{ <br>    HWND hwnd; <br>    HWND hwndChild; <br>    WNDPROC lpfnChild; <br>    RECT rcT; <br>    TEXTMETRIC tm; <br>    LPTSTR pszCreateClass; <br>    LPTSTR pszTextOld; <br>    INT iType = npc-&gt;pwcd-&gt;iType; <br> <br>    /* <br>     * Set the text field.  Remember that it can be an ordinal <br>     * (for icon controls). <br>     */ <br>    pszTextOld = npc-&gt;text; <br>    if (pszText &amp;&amp; *pszText) { <br>        if (!(npc-&gt;text = MyAlloc(NameOrdLen(pszText)))) <br>            return NULL; <br> <br>        NameOrdCpy(npc-&gt;text, pszText); <br>    } <br>    else { <br>        npc-&gt;text = NULL; <br>    } <br> <br>    /* <br>     * If there was text before on this control, free it now. <br>     * This should be done after the new text is allocated and <br>     * copied, because it is common to pass this routine the same <br>     * pointer, and we don't want to free the text before we have <br>     * copied it! <br>     */ <br>    if (pszTextOld) <br>        MyFree(pszTextOld); <br> <br>    /* <br>     * Also set some other values in the CTYPE structure. <br>     */ <br>    npc-&gt;id = id; <br>    npc-&gt;flStyle = flStyle; <br>    npc-&gt;flExtStyle = flExtStyle; <br> <br>    /* <br>     * If this is a dialog and it has the WS_CHILD style, remove <br>     * it and make it WS_POPUP instead.  This prevents some problems <br>     * when editing the dialog. <br>     */ <br>    if (iType == W_DIALOG &amp;&amp; (flStyle &amp; WS_CHILD)) { <br>        flStyle &amp;= ~WS_CHILD; <br>        flStyle |= WS_POPUP; <br>    } <br> <br>    /* <br>     * If this is an emulated custom control, we always make it with the <br>     * default styles no matter what the user has specified.  If not, <br>     * remove any styles that can cause problems for a control of this <br>     * type, such as OWNERDRAW styles. <br>     */ <br>    if (npc-&gt;pwcd-&gt;fEmulated) <br>        flStyle = awcd[W_CUSTOM].flStyles; <br>    else <br>        flStyle &amp;= ~npc-&gt;pwcd-&gt;flStylesBad; <br> <br>    if (iType == W_DIALOG) { <br>        /* <br>         * If the style includes the DS_MODALFRAME bit, set the appropriate <br>         * extended style bit. <br>         */ <br>        if (flStyle &amp; DS_MODALFRAME) <br>            flExtStyle |= WS_EX_DLGMODALFRAME; <br> <br>        /* <br>         * Create the dialog, but don't show it yet. <br>         */ <br>        hwnd = CreateWindowEx( <br>                flExtStyle, <br>                MAKEINTRESOURCE(DIALOGCLASS), <br>                npc-&gt;text, <br>                flStyle &amp; ~WS_VISIBLE, <br>                0, 0, 0, 0, <br>                ghwndSubClient, <br>                0, <br>                ghInst, <br>                NULL); <br>    } <br>    else { <br>        /* <br>         * Get the size of the control. <br>         */ <br>        rcT = *prc; <br> <br>        /* <br>         * Map the dialog unit rectangle to window coords. <br>         */ <br>        DUToWinRect(&amp;rcT); <br> <br>        /* <br>         * If this is an icon, the text field is actually going <br>         * to be an ordinal that has the resource id.  We must map this to <br>         * an id of our own or when we create the control it will cause a <br>         * "Resource not found" error. <br>         */ <br>        if (iType == W_ICON) <br>            pszText = (LPTSTR)&amp;gordIcon; <br>        else <br>            pszText = npc-&gt;text; <br> <br>        /* <br>         * Get the class name to use.  In the case of custom controls, <br>         * if the control is emulated, use the special emulator class. <br>         * Otherwise, it is an installed custom control, and we can use <br>         * it's real class string. <br>         */ <br>        if (iType == W_CUSTOM) { <br>            if (npc-&gt;pwcd-&gt;fEmulated) <br>                pszCreateClass = szCustomClass; <br>            else <br>                pszCreateClass = npc-&gt;pwcd-&gt;pszClass; <br>        } <br>        else { <br>            pszCreateClass = ids(acsd[awcd[iType].iClass].idsClass); <br>        } <br> <br>        /* <br>         * Create the control.  We always create it visible in work mode, <br>         * even if the style says it isn't. <br>         */ <br>        hwnd = CreateWindowEx( <br>                flExtStyle, <br>                pszCreateClass, <br>#ifdef JAPAN <br>                // pszText is ordnum for icon control. <br>                iType == W_ICON ? pszText : TEXT(""), <br>#else <br>                pszText, <br>#endif <br>                flStyle | WS_VISIBLE, <br>                rcT.left, rcT.top, <br>                rcT.right - rcT.left, <br>                rcT.bottom - rcT.top, <br>                gcd.npc-&gt;hwnd, <br>                0, <br>                ghInst, <br>                NULL); <br>#ifdef JAPAN <br>        // It isn't necessary for ICON control to handle accel in text. <br>        if( iType != W_ICON ) { <br>            TCHAR   szTmp[CCHTEXTMAX]; <br> <br>            KKExpandCopy(szTmp, pszText, CCHTEXTMAX); <br>            SetWindowText(hwnd, szTmp); <br>        } <br>#endif <br>    } <br> <br>    if (!hwnd) { <br>        Message(MSG_CREATECTRLERROR, pszCreateClass); <br>        return NULL; <br>    } <br> <br>    if (iType == W_DIALOG) { <br>        /* <br>         * Did they specify a font? <br>         */ <br>        if (*pdi-&gt;szFontName) { <br>            gcd.hFont = CreateDlgFont(hwnd, pdi-&gt;szFontName, pdi-&gt;nPointSize); <br>            lstrcpy(gcd.di.szFontName, pdi-&gt;szFontName); <br>            gcd.di.nPointSize = pdi-&gt;nPointSize; <br>            gcd.fFontSpecified = TRUE; <br>        } <br>        else { <br>            gcd.hFont = NULL; <br>            *gcd.di.szFontName = CHAR_NULL; <br>            gcd.di.nPointSize = 0; <br>            gcd.fFontSpecified = FALSE; <br>        } <br> <br>        /* <br>         * Get the dimensions of the font.  It is a possible case that <br>         * they specified a font but it could not be created, so in <br>         * that case we use the system font as well as if they didn't <br>         * specify a font at all. <br>         */ <br>        if (gcd.hFont) { <br>            gcd.cxChar = MyGetCharDimensions(hwnd, gcd.hFont, &amp;tm); <br>            gcd.cyChar = tm.tmHeight; <br>        } <br>        else { <br>            gcd.cxChar = gcxSysChar; <br>            gcd.cyChar = gcySysChar; <br>        } <br> <br>        /* <br>         * Now that we know what font we are using, adjust some entries <br>         * in the awcd (array of window class data) table for default  <br>         * sizing of controls. <br>         */ <br>        AdjustDefaultSizes(); <br>    } <br> <br>    /* <br>     * If there is a valid user specified font, inform the control <br>     * of it.  Once the font has been set into the dialog, it <br>     * must not be destroyed, because the dialog window will <br>     * clean it up when it is destroyed. <br>     */ <br>    if (gcd.hFont) <br>        SendMessage(hwnd, WM_SETFONT, (WPARAM)gcd.hFont, 0L); <br> <br>    /* <br>     * Move the window into the requested Z-Order. <br>     */ <br>    SetWindowPos(hwnd, hwndBehind, 0, 0, 0, 0, <br>            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW); <br> <br>    /* <br>     * Store the CTYPE pointer into the control's hwnd. <br>     * This will be used by PCFROMHWND later. <br>     */ <br>    SETPCINTOHWND(hwnd, npc); <br> <br>    /* <br>     * Subclass the control. <br>     */ <br>    npc-&gt;pwcd-&gt;pfnOldWndProc = <br>            (WNDPROC)SetWindowLong(hwnd, GWL_WNDPROC, <br>            (iType == W_DIALOG) ? (DWORD)DialogCtrlWndProc : <br>            (DWORD)CtrlWndProc); <br> <br>    /* <br>     * Be sure double-clicks are enabled for this control. <br>     */ <br>    (UINT)SetClassLong((hwnd), GCL_STYLE, (LONG)((UINT)GetClassLong((hwnd), GCL_STYLE) | CS_DBLCLKS)); <br> <br>    /* <br>     * Subclass any children this control may have. <br>     */ <br>    for (hwndChild = GetTopWindow(hwnd); hwndChild; <br>            hwndChild = GetNextWindow(hwndChild, GW_HWNDNEXT)) { <br>        lpfnChild = (WNDPROC)SetWindowLong(hwndChild, <br>                GWL_WNDPROC, (DWORD)ChildWndProc); <br>        SETCHILDPROC(hwndChild, lpfnChild); <br>    } <br> <br>    /* <br>     * Did we just create a dialog? <br>     */ <br>    if (iType == W_DIALOG) { <br>        /* <br>         * Now that the dialog is created, we can figure out how to <br>         * size it.  We start by mapping the dialog units to window <br>         * coordinates, <br>         */ <br>        rcT = *prc; <br>        DUToWinRect(&amp;rcT); <br> <br>        /* <br>         * We now have the rectangle for the client area.  Expand it <br>         * to account for the frame controls. <br>         */ <br>        AdjustWindowRectEx(&amp;rcT, flStyle, FALSE, flExtStyle); <br> <br>        /* <br>         * Now we can map the rect from the apps client area <br>         * to the desktop, then we set the dialogs position. <br>         */ <br>        ClientToScreenRect(ghwndSubClient, &amp;rcT); <br>        SetWindowPos(hwnd, NULL, <br>                rcT.left, rcT.top, <br>                rcT.right - rcT.left, rcT.bottom - rcT.top, <br>                SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>        SaveDlgClientRect(hwnd); <br> <br>        /* <br>         * Save the class name, if any. <br>         */ <br>        if (pdi-&gt;pszClass &amp;&amp; *pdi-&gt;pszClass) { <br>            if (!(gcd.di.pszClass = MyAlloc(NameOrdLen(pdi-&gt;pszClass)))) { <br>                DestroyWindow(hwnd); <br>                return (HWND)NULL; <br>            } <br> <br>            NameOrdCpy(gcd.di.pszClass, pdi-&gt;pszClass); <br>        } <br>        else { <br>            gcd.di.pszClass = NULL; <br>        } <br> <br>        /* <br>         * Save the menu name, if any. <br>         */ <br>        if (pdi-&gt;pszMenu &amp;&amp; *pdi-&gt;pszMenu) { <br>            if (!(gcd.di.pszMenu = MyAlloc(NameOrdLen(pdi-&gt;pszMenu)))) { <br>                DestroyWindow(hwnd); <br>                return (HWND)NULL; <br>            } <br> <br>            NameOrdCpy(gcd.di.pszMenu, pdi-&gt;pszMenu); <br>        } <br>        else { <br>            gcd.di.pszMenu = NULL; <br>        } <br> <br>        /* <br>         * Set some other fields in the additional dialog info structure. <br>         */ <br>        gcd.di.fResFlags = pdi-&gt;fResFlags; <br>        gcd.di.wLanguage = pdi-&gt;wLanguage; <br>        gcd.di.DataVersion = pdi-&gt;DataVersion; <br>        gcd.di.Version = pdi-&gt;Version; <br>        gcd.di.Characteristics = pdi-&gt;Characteristics; <br>    } <br> <br>    npc-&gt;hwnd = hwnd; <br>    return hwnd; <br>} <br> <br> <br> <br>/************************************************************************ <br>* CreateDlgFont <br>* <br>* This function creates a font with the given face name and point size <br>* and returns a handle to it. <br>* <br>* Arguments: <br>*   HWND hwnd           - Dialog window handle. <br>*   LPTSTR pszFontName  - Name of the font (for example: "Helv"). <br>*   INT nPointSize      - Point size of the font (for example: 8 or 12). <br>* <br>* Returns: <br>*   A handle to the created font, or NULL if it could not be created. <br>* <br>************************************************************************/ <br> <br>static BYTE bSystemCharset; <br> <br>STATICFN HFONT CreateDlgFont( <br>    HWND hwnd, <br>    LPTSTR pszFontName, <br>    INT nPointSize) <br>{ <br>    HFONT hFont; <br>    HFONT hFontOld; <br>    HDC hDC; <br>    LOGFONT lf; <br>    TCHAR szFaceName[LF_FACESIZE]; <br>    CHARSETINFO csi; <br>    DWORD dw = GetACP(); <br> <br>    if (TranslateCharsetInfo((DWORD*)dw, &amp;csi, TCI_SRCCODEPAGE)) <br>bSystemCharset = csi.ciCharset; <br>    else <br>        bSystemCharset = ANSI_CHARSET; <br> <br>    /* <br>     * Initialize the logical font structure.  Note that filling the <br>     * structure with zeros gives it all the default settings. <br>     */ <br>    memset(&amp;lf, 0, sizeof(LOGFONT)); <br>    lf.lfHeight = (SHORT)-PointSizeToPixels(nPointSize); <br>    if ((lf.lfCharSet = GetFontCharSet(pszFontName)) != bSystemCharset) <br>        lf.lfWeight = FW_BOLD; // allow boldface on non ShiftJIS fonts <br>    lstrcpy(lf.lfFaceName, pszFontName); <br> <br>    if (!(hFont = CreateFontIndirect(&amp;lf))) <br>        return NULL; <br> <br>    /* <br>     * If we didn't get the face name that was requested, delete the <br>     * new font and return NULL.  This will effectively select the <br>     * system font for this dialog. <br>     */ <br>    hDC = GetDC(hwnd); <br>    if (hFontOld = SelectObject(hDC, hFont)) { <br>        GetTextFace(hDC, LF_FACESIZE, szFaceName); <br>        SelectObject(hDC, hFontOld); <br> <br>        if (lstrcmpi(szFaceName, pszFontName) != 0) { <br>            DeleteObject(hFont); <br>            hFont = NULL; <br>        } <br>    } <br>    else { <br>        DeleteObject(hFont); <br>        hFont = NULL; <br>    } <br> <br>    ReleaseDC(hwnd, hDC); <br> <br>    return hFont; <br>} <br> <br> <br> <br>/************************************************************************ <br>* MyGetCharDimensions <br>* <br>* This function calculates the average character width of the given <br>* font for the given window.  This must be used instead of <br>* simply using the tmAveCharWidth field of the text metrics, because <br>* this value is not correct for proportional fonts.   <br>* <br>* Arguments: <br>*   HWND hwnd       - The window handle. <br>*   HFONT hFont     - The font handle. <br>*   PTEXTMETRIC ptm - Where to return the text metrics. <br>* <br>* Returns: <br>*   The average character width.  The text metrics are returned in <br>*   the TEXTMETRIC structure pointed to by ptm. <br>* <br>************************************************************************/ <br> <br>STATICFN INT MyGetCharDimensions( <br>    HWND hwnd, <br>    HFONT hFont, <br>    PTEXTMETRIC ptm) <br>{ <br>    register INT i; <br>    HDC hDC; <br>    SIZE size; <br>    INT iWidth; <br>    TCHAR szAveCharWidth[52]; <br>    HFONT hFontOld; <br> <br>    hDC = GetDC(hwnd); <br>    hFontOld = SelectObject(hDC, hFont); <br> <br>    GetTextMetrics(hDC, ptm); <br> <br>    /* <br>     * Is this a variable pitch font? <br>     */ <br>    if (ptm-&gt;tmPitchAndFamily &amp; 0x01) { <br>        for (i = 0; i &lt; 26; i++) <br>            szAveCharWidth[i] = (TCHAR)(i + CHAR_A); <br> <br>        for (i = 0; i &lt; 26; i++) <br>            szAveCharWidth[i + 26] = (TCHAR)(i + CHAR_CAP_A); <br> <br>        GetTextExtentPoint(hDC, szAveCharWidth, 52, &amp;size); <br>        iWidth = (INT)size.cx / 26; <br> <br>        // <br>        // Round it up. <br>        // <br>        iWidth = (iWidth + 1) / 2; <br>    } <br>    else { <br>        iWidth = ptm-&gt;tmAveCharWidth; <br>    } <br> <br>    SelectObject(hDC, hFontOld); <br>    ReleaseDC(hwnd, hDC); <br> <br>    return iWidth; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AdjustDefaultSizes <br>* <br>* This functions adjusts some default size entries in the awcd (array of <br>* window class data) table. <br>* This must be done at run time, because the actual values depend on the <br>* system that dlgedit is being run on and the font of the current dialog. <br>* <br>* This function should be called any time that a dialog is created, <br>* or its font is changed. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID AdjustDefaultSizes(VOID) <br>{ <br>    awcd[W_ICON].cxDefault = <br>            (((GetSystemMetrics(SM_CXICON) * 4) * 2) + gcd.cxChar) <br>            / (gcd.cxChar * 2); <br> <br>    awcd[W_ICON].cyDefault = <br>            (((GetSystemMetrics(SM_CYICON) * 8) * 2) + gcd.cyChar) <br>            / (gcd.cyChar * 2); <br> <br>    awcd[W_VERTSCROLL].cxDefault = <br>            (((GetSystemMetrics(SM_CXVSCROLL) * 4) * 2) + gcd.cxChar) <br>            / (gcd.cxChar * 2); <br> <br>    awcd[W_HORZSCROLL].cyDefault = <br>            (((GetSystemMetrics(SM_CYHSCROLL) * 8) * 2) + gcd.cyChar) <br>            / (gcd.cyChar * 2); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DeleteControl <br>* <br>* This deletes all selected controls from the dialog being edited <br>* (or the dialog itself, if it is selected). <br>* <br>************************************************************************/ <br> <br>VOID DeleteControl(VOID) <br>{ <br>    if (gfDlgSelected) { <br>        if (Message(MSG_DELETEDIALOG) == IDYES) <br>            /* <br>             * Delete the dialog, including the resource for it. <br>             */ <br>            DeleteDialog(TRUE); <br>    } <br>    else { <br>        while (gnpcSel) <br>            DeleteControl2(gnpcSel); <br> <br>        gfDlgChanged = TRUE; <br>    } <br> <br>    gfResChged = TRUE; <br>    ShowFileStatus(FALSE); <br>    StatusUpdate(); <br>    StatusSetEnable(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DeleteControl2 <br>* <br>* This deletes a control by destroying its window and removing it <br>* from the linked list of controls associated with the dialog box. <br>* The control is destroyed and the window is unlinked and the CTYPE free'd. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID DeleteControl2( <br>    NPCTYPE npcDel) <br>{ <br>    register NPCTYPE npcT; <br>    register NPCTYPE *npnpcLast; <br> <br>    UnSelectControl(npcDel); <br> <br>    /* <br>     * Search for the control, unlink it from the list and free it. <br>     */ <br>    npcT = npcHead; <br>    npnpcLast = &amp;npcHead; <br>    while (npcT) { <br>        if (npcT == npcDel) { <br>            *npnpcLast = npcT-&gt;npcNext; <br>            FreeCTYPE(npcT); <br>            cWindows--; <br>            break; <br>        } <br> <br>        npnpcLast = &amp;npcT-&gt;npcNext; <br>        npcT = npcT-&gt;npcNext; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DeleteDialog <br>* <br>* This deletes the dialog box being worked on and sets globals <br>* and the Status Window appropriately.  All CTYPEs are freed, the <br>* status window is updated and the dialog window is destroyed. <br>* <br>* Arguments: <br>*   BOOL fResAlso - If TRUE, delete the dialog resource also. <br>* <br>************************************************************************/ </code></pre>
<p>
</p>
<pre><code><br>VOID DeleteDialog( <br>    BOOL fResAlso) <br>{ <br>    register NPCTYPE npcT; <br>    register NPCTYPE npcNext; <br> <br>    CancelSelection(FALSE); <br> <br>    /* <br>     * If they requested that the dialog resource be deleted also, <br>     * do it first while some globals are still set. <br>     */ <br>    if (fResAlso) <br>        DeleteDialogResource(); <br> <br>    /* <br>     * Hide the window for better painting speed. <br>     */ <br>    ShowWindow(gcd.npc-&gt;hwnd, SW_HIDE); <br> <br>    /* <br>     * Free all the controls. <br>     */ <br>    npcT = npcHead; <br>    while (npcT) { <br>        npcNext = npcT-&gt;npcNext; <br>        FreeCTYPE(npcT); <br>        npcT = npcNext; <br>    } <br>    npcHead = NULL; <br>    cWindows = 0; <br> <br>    /* <br>     * Free the dialog itself. <br>     */ <br>    FreeCTYPE(gcd.npc); <br> <br>    if (gcd.pszDlgName) { <br>        MyFree(gcd.pszDlgName); <br>        gcd.pszDlgName = NULL; <br>    } <br> <br>    if (gcd.di.pszClass) { <br>        MyFree(gcd.di.pszClass); <br>        gcd.di.pszClass = NULL; <br>    } <br> <br>    if (gcd.di.pszMenu) { <br>        MyFree(gcd.di.pszMenu); <br>        gcd.di.pszMenu = NULL; <br>    } <br> <br>    if (gcd.hFont) { <br>        DeleteObject(gcd.hFont); <br>        gcd.hFont = NULL; <br>    } <br> <br>    gcd.fFontSpecified = FALSE; <br>    *gcd.di.szFontName = CHAR_NULL; <br> <br>    /* <br>     * Set these globals back to the system font values so that <br>     * workers like WinToDUPoint will still work. <br>     */ <br>    gcd.cxChar = gcxSysChar; <br>    gcd.cyChar = gcySysChar; <br> <br>    gcd.prl = NULL; <br> <br>    gcd.npc = NULL; <br>    gfEditingDlg = FALSE; <br>    gfDlgChanged = FALSE; <br> <br>    ToolboxSelectTool(W_NOTHING, FALSE); <br>    StatusUpdate(); <br>    StatusSetEnable(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* FreeCTYPE <br>* <br>* This function frees an allocated CTYPE.  The associated control or <br>* dialog window is destroyed, and memory for the text and/or class <br>* is freed, followed by freeing the actual CTYPE structure itself. <br>* <br>* If the hwnd in the CTYPE is NULL, only the text (if not NULL) is <br>* assumed to be valid and will be freed, followed by the CTYPE structure <br>* itself.  This allows FreeCTYPE to be called when the CTYPE is only <br>* partially initialized.  This is a little dependant on the order that <br>* a CTYPE is allocated and initialized in AddControl(). <br>* <br>* Arguments: <br>*     NPCTYPE npc = The CTYPE to free. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID FreeCTYPE( <br>    NPCTYPE npc) <br>{ <br>    if (npc-&gt;hwnd) <br>        DestroyWindow(npc-&gt;hwnd); <br> <br>    if (npc-&gt;hwndDrag) <br>        DestroyWindow(npc-&gt;hwndDrag); <br> <br>    if (npc-&gt;text) <br>        MyFree(npc-&gt;text); <br> <br>    MyFree(npc); <br>} <br> <br>/************************************************************************ <br>* <br>* <br>* <br>************************************************************************/ <br> <br>int CALLBACK GetFontCharSetEnumFunc(LPLOGFONT lpLf, <br>    LPTEXTMETRIC lpTm, <br>    int nFontType, <br>    LPARAM lParam) <br>{ <br>    LPBYTE lpB = (LPBYTE)lParam; <br>    *lpB = lpTm-&gt;tmCharSet; <br>    return 0; // no more enum <br>} <br> <br>/************************************************************************ <br>* <br>* <br>* <br>************************************************************************/ <br> <br>STATICFN BYTE NEAR GetFontCharSet(LPTSTR lpStr) <br>{ <br>    HDC hDC; <br>    BYTE cbCharset = bSystemCharset; <br>    FONTENUMPROC lpEFCB = (FONTENUMPROC)MakeProcInstance( <br>                              (FARPROC)GetFontCharSetEnumFunc, <br>                              ghInst); <br>    if (hDC = GetDC(ghwndMain)) { <br>        EnumFonts(hDC, lpStr, lpEFCB, (LPARAM)&amp;cbCharset); <br>        ReleaseDC(ghwndMain,hDC); <br>    } <br>    FreeProcInstance(lpEFCB); <br>    return cbCharset; <br>} <br> <br>#ifdef JAPAN <br>/************************************************************************ <br>* Copy strings to the buffer. Codes \036 and \037 are expanded to <br>* text strings "\036" and "\037" respectively. t-Yoshio <br>************************************************************************/ <br> <br>VOID KDExpandCopy(LPTSTR pszDest, LPTSTR pszSrc, WORD wLimit) <br>{ <br>    int  i; <br>    LPTSTR p = pszSrc; <br> <br>    wLimit--; <br>    for (i = 0; i &lt; wLimit &amp;&amp; p &amp;&amp; *p; i++) { <br>        if (*p == 036 || *p == 037) { <br>            if (i &lt; wLimit-4) { <br>                lstrcpy(&amp;pszDest[i], (*p == 036) ? TEXT("\\036") : TEXT("\\037")); <br>                i += 3; <br>            } else { <br>                break; <br>                } <br>        } else { <br>            pszDest[i] = *p; <br>            } <br>        if (IsDBCSLeadByte((BYTE)*p)) { <br>            if (i == wLimit - 1) { <br>                break; <br>            } <br>            pszDest[++i] = *(p+1); <br>        } <br>        p = CharNext(p); <br>    } <br>    pszDest[i] = '\0'; <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
