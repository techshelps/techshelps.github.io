<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTRLPROC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5597"></a>CTRLPROC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: ctrlproc.c <br>* <br>* Contains the window procedures for controls in the dialog being edited. <br>* <br>* Functions: <br>* <br>*    DialogCtrlWndProc() <br>*    CtrlWndProc() <br>*    ChildWndProc() <br>*    DrawOwnerDrawButton() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br> <br> <br>/************************************************************************ <br>* DialogCtrlWndProc <br>* <br>* This is the window procedure that subclasses the dialog being <br>* edited.  It handles a few messages that have to be special-cased <br>* for the dialog.  Most messages, however, are passed on to the <br>* generic control subclass procedure (CtrlWndProc). <br>* <br>* Arguments: <br>*    HWND - Handle to the dialog window <br>*    UINT  - window message <br>*    WPARAM - message parameter <br>*    LPARAM - message parameter <br>* <br>* Returns: <br>*    The default window procedure <br>* <br>************************************************************************/ <br> <br>WINDOWPROC DialogCtrlWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    POINT pt; <br>    BOOL fTracking; <br> <br>    switch (msg) { <br>        case WM_NCPAINT: <br>        case WM_PAINT: <br>            if (gfTrackRectShown) { <br>                fTracking = TRUE; <br>                HideTrackRect(); <br>            } <br>            else { <br>                fTracking = FALSE; <br>            } <br> <br>            /* <br>             * Allow the dialog to paint first. <br>             */ <br>            CallWindowProc((WNDPROC)CtrlWndProc, hwnd, msg, wParam, lParam); <br> <br>            /* <br>             * Draw the handles if the dialog is selected. <br>             */ <br>            if (gfDlgSelected) { <br>                HDC hDC; <br> <br>                hDC = GetWindowDC(hwnd); <br>                DrawHandles(hwnd, hDC, TRUE); <br>                ReleaseDC(hwnd, hDC); <br>            } <br> <br>            if (fTracking) <br>                ShowTrackRect(); <br> <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            /* <br>             * Discard all mouse messages during certain operations. <br>             */ <br>            if (gfDisabled) <br>                break; <br> <br>            /* <br>             * Also, be sure any outstanding changes get applied <br>             * without errors. <br>             */ <br>            if (!StatusApplyChanges()) <br>                break; <br> <br>            /* <br>             * Check to see if we are in a normal mode.  If we are <br>             * in some other mode, like dragging a new control, <br>             * we want to ignore this mouse down and wait for the <br>             * mouse up.  For instance, this can happen when the <br>             * Duplicate command is selected from the Edit menu. <br>             */ <br>            if (gState == STATE_NORMAL) { <br>                ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>                MapDlgClientPoint(&amp;pt, TRUE); <br> <br>                /* <br>                 * Is the dialog selected and was one of its handles hit? <br>                 * If so, call CtrlButtonDown as if we are a drag window. <br>                 */ <br>                if (gfDlgSelected &amp;&amp; <br>                        HandleHitTest(hwnd, pt.x, pt.y) != DRAG_CENTER) { <br>                    CtrlButtonDown(hwnd, pt.x, pt.y, TRUE); <br>                } <br>                else { <br>                    /* <br>                     * If the click was within the client area and <br>                     * there is not a tool selected, start an outline <br>                     * selection operation.  Otherwise call CtrlButtonDown <br>                     * which will either begin dragging the dialog or <br>                     * dragging the new control. <br>                     */ <br>                    if (gCurTool == W_NOTHING &amp;&amp; <br>                            PtInRect(&amp;grcDlgClient, pt)) <br>                        OutlineSelectBegin(pt.x, pt.y); <br>                    else <br>                        CtrlButtonDown(hwnd, pt.x, pt.y, FALSE); <br>                } <br>            } <br> <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br> <br>            /* <br>             * If we are not dragging a new control, then this <br>             * message is for the dialog, and we map it from <br>             * the dialog client to the dialog window. <br>             */ <br>            if (gState != STATE_DRAGGINGNEW) <br>                MapDlgClientPoint(&amp;pt, TRUE); <br> <br>            /* <br>             * Now we process the mouse move message.  If the dialog is <br>             * selected, and if we are not dragging a new control, we <br>             * pass in a TRUE for fDragWindow.  This is because the <br>             * dialog itself does not have a separate drag window like <br>             * controls, and if it is selected this message needs to <br>             * be processed as if a drag window was hit. <br>             */ <br>            CtrlMouseMove(hwnd, <br>                    (gfDlgSelected &amp;&amp; gState != STATE_DRAGGINGNEW) ? <br>                    TRUE : FALSE, pt.x, pt.y); <br> <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br> <br>            /* <br>             * If we are not dragging a new control, then this <br>             * message is for the dialog, and we map it from <br>             * the dialog client to the dialog window. <br>             */ <br>            if (gState != STATE_DRAGGINGNEW) <br>                MapDlgClientPoint(&amp;pt, TRUE); <br> <br>            CtrlButtonUp(pt.x, pt.y); <br> <br>            break; <br> <br>        case WM_DRAWITEM: <br>            return DrawOwnerDrawButton((LPDRAWITEMSTRUCT)lParam); <br> <br>        default: <br>            return CallWindowProc( <br>                    (WNDPROC)CtrlWndProc, hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0L; <br>} <br> <br> <br> <br>/************************************************************************ <br>* CtrlWndProc <br>* <br>* This is the window procedure that subclasses all of the controls. <br>* The dialog being edited will also pass messages that it does not <br>* handle through this procedure. <br>* <br>* Arguments: <br>*    HWND - Handle to the control window <br>*    UINT  - window message <br>*    WPARAM - message parameter <br>*    LPARAM - message parameter <br>* <br>* Returns: <br>*    The default window procedure <br>* <br>************************************************************************/ <br> <br>WINDOWPROC CtrlWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    POINT pt; <br> <br>    switch (msg) { <br>        case WM_NCPAINT: <br>        case WM_PAINT: <br>            { <br>                BOOL fTracking; <br> <br>                if (gfTrackRectShown) { <br>                    fTracking = TRUE; <br>                    HideTrackRect(); <br>                } <br>                else { <br>                    fTracking = FALSE; <br>                } <br> <br>                /* <br>                 * Allow the control to paint first. <br>                 */ <br>                CallWindowProc((WNDPROC)PCFROMHWND(hwnd)-&gt;pwcd-&gt;pfnOldWndProc, <br>                        hwnd, msg, wParam, lParam); <br> <br>                if (fTracking) <br>                    ShowTrackRect(); <br>            } <br> <br>            break; <br> <br>        case WM_SETCURSOR: <br>            /* <br>             * Defeat the system changing cursors on us.  We do it based <br>             * on our own hit testing. <br>             */ <br>            return TRUE; <br> <br>        case WM_TIMER: <br>            PreDragTimeout(hwnd, TRUE); <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            CtrlButtonDown(hwnd, pt.x, pt.y, FALSE); <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            CtrlMouseMove(hwnd, FALSE, pt.x, pt.y); <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            CtrlButtonUp(pt.x, pt.y); <br>            break; <br> <br>        case WM_LBUTTONDBLCLK: <br>            if (gfDisabled) <br>                break; <br> <br>            /* <br>             * Also, be sure any outstanding changes get applied <br>             * without errors. <br>             */ <br>            if (!StatusApplyChanges()) <br>                break; <br> <br>            StylesDialog(); <br> <br>            break; <br> <br>        case WM_NCHITTEST: <br>            return HTCLIENT; <br> <br>        case WM_RBUTTONDOWN: <br>        case WM_MBUTTONDOWN: <br>        case WM_RBUTTONDBLCLK: <br>        case WM_MBUTTONDBLCLK: <br>            /* <br>             * Helps prevent anything from happening when <br>             * the middle or right mouse buttons are pressed <br>             * (or doubleclicked). <br>             */ <br>            break; <br> <br>        case WM_MOUSEACTIVATE: <br>            /* <br>             * Defeat this message so that mouse clicks do not activate <br>             * the control. <br>             */ <br>            return MA_NOACTIVATE; <br> <br>        case WM_DESTROY: <br>            /* <br>             * Unsubclass the control. <br>             */ <br>            SetWindowLong(hwnd, GWL_WNDPROC, <br>                    (DWORD)(WNDPROC)(PCFROMHWND(hwnd)-&gt;pwcd-&gt;pfnOldWndProc)); <br> <br>            UNSETPCINTOHWND(hwnd); <br> <br>            break; <br> <br>        default: <br>            return CallWindowProc( <br>                    (WNDPROC)PCFROMHWND(hwnd)-&gt;pwcd-&gt;pfnOldWndProc, <br>                    hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0L; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ChildWndProc <br>* <br>* This is the window procedure that subclasses all of the children <br>* of controls that have them.  Currently this is only comboboxes. <br>* <br>* Arguments: <br>*    HWND - Handle to the child control window <br>*    UINT  - window message <br>*    WPARAM - message parameter <br>*    LPARAM - message parameter <br>* <br>* Returns: <br>*    The default window procedure <br>* <br>************************************************************************/ <br> <br>WINDOWPROC ChildWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    /* <br>     * Is this a mouse message? <br>     */ <br>    if (msg &gt;= WM_MOUSEFIRST &amp;&amp; msg &lt;= WM_MOUSELAST) { <br>        POINT pt; <br> <br>        /* <br>         * Yes, convert the coordinates and send it to the parent. <br>         */ <br>        ((pt).x = (SHORT)LOWORD(lParam), (pt).y = (SHORT)HIWORD(lParam)); <br>        ClientToScreen(hwnd, &amp;pt); <br>        ScreenToClient(GetParent(hwnd), &amp;pt); <br>        POINT2LONG(pt, lParam); <br>        SendMessage(GetParent(hwnd), msg, wParam, lParam); <br>        return FALSE; <br>    } <br>    else if (msg == WM_SETCURSOR) { <br>        /* <br>         * Defeat the system changing cursors on us.  We do it based <br>         * on our own hit testing. <br>         */ <br>        return TRUE; <br>    } <br>    else if (msg == WM_NCDESTROY) { <br>        /* <br>         * Unsubclass the child. <br>         */ <br>        SetWindowLong(hwnd, GWL_WNDPROC, (DWORD)(WNDPROC)GETCHILDPROC(hwnd)); <br> <br>        /* <br>         * When destroying the child window, we must be sure and <br>         * remove the properties associated with it. <br>         */ <br>        UNSETCHILDPROC(hwnd); <br> <br>        return 0; <br>    } <br>    else { <br>        /* <br>         * A benign message, call the class proc. <br>         */ <br>        return CallWindowProc(GETCHILDPROC(hwnd), hwnd, msg, wParam, lParam); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DrawOwnerDrawButton <br>* <br>* Draws the owner-draw buttons. <br>* <br>* Arguments: <br>*    LPDRAWITEMSTRUCT -  owner-draw item structure <br>* <br>* Returns: <br>*    TRUE if the button was drawn; FALSE if the button could not be drawn. <br>* <br>************************************************************************/ <br> <br>BOOL DrawOwnerDrawButton( <br>    LPDRAWITEMSTRUCT lpdis) <br>{ <br>    TCHAR szText[CCHTEXTMAX]; <br> <br>    if (lpdis-&gt;CtlType != ODT_BUTTON || lpdis-&gt;itemAction != ODA_DRAWENTIRE) <br>        return FALSE; <br> <br>    RoundRect(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.top, <br>            lpdis-&gt;rcItem.right, lpdis-&gt;rcItem.bottom, 4, 4); <br> <br>    GetWindowText(lpdis-&gt;hwndItem, szText, CCHTEXTMAX); <br>    SetBkMode(lpdis-&gt;hDC, TRANSPARENT); <br> <br>    if (gcd.hFont) <br>        SelectObject(lpdis-&gt;hDC, gcd.hFont); <br> <br>#ifdef JAPAN <br>    { <br>        TCHAR   szTmp[CCHTEXTMAX]; <br> <br>        KDExpandCopy(szTmp, szText, CCHTEXTMAX); <br>        lstrcpy(szText, szTmp); <br>    } <br>#endif <br> <br>    DrawText(lpdis-&gt;hDC, szText, -1, &amp;lpdis-&gt;rcItem, <br>            DT_CENTER | DT_NOCLIP | DT_VCENTER | DT_SINGLELINE); <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
