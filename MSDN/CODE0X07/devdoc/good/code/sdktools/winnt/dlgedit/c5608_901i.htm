<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RESUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5616"></a>RESUTIL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: resutil.c <br>* <br>* Contains utility functions for working with the Windows resource file. <br>* <br>* Functions: <br>*   ParseDialogBoxHeader() <br>*   ParseControlData() <br>*   DWordAlign() <br>*   DWordPad() <br>*   ResourceType) <br>*   ResourceName() <br>*   ResourcePart2() <br>*   ResourceSize() <br>*   SkipResHeader() <br>*   SkipSz() <br>*   SkipDialogBoxHeader() <br>*   SkipControlData() <br>*   NameOrdCpy() <br>*   NameOrdCmp() <br>*   NameOrdLen() <br>*   NameOrdDup() <br>*   StrToNameOrd() <br>*   WriteOrd() <br>*   WriteResHeader() <br>*   WriteSz() <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>#include &lt;string.h&gt; <br>#include &lt;wchar.h&gt; <br> <br> <br> <br>/************************************************************************ <br>* ParseDialogBoxHeader <br>* <br>* <br>* Arguments: <br>*   PDIALOGBOXHEADER pdbh - Points to dialog box header to parse. <br>*   PDWORD pflStyle       - Receives the style. <br>*   PDWORD pflExtStyle    - Receives the extended style. <br>*   PINT pcdit            - Receives the number of controls in the dialog. <br>*   PINT px               - Receives starting x location. <br>*   PINT py               - Receives starting y location. <br>*   PINT pcx              - Receives the width. <br>*   PINT pcy              - Receives the height. <br>*   LPTSTR *ppszMenuName  - Receives the menu name. <br>*   LPTSTR *ppszClass     - Receives the class name. <br>*   LPTSTR *ppszCaption   - Receives the caption. <br>*   PINT pPointSize       - Receives the point size. <br>*   LPTSTR *ppszFontName  - Receives the font name. <br>* <br>* Returns: <br>*   A pointer to the first dialog item past the dialog template header. <br>* <br>************************************************************************/ <br> <br>PCONTROLDATA ParseDialogBoxHeader( <br>    PDIALOGBOXHEADER pdbh, <br>    PDWORD pflStyle, <br>    PDWORD pflExtStyle, <br>    PINT pcdit, <br>    PINT px, <br>    PINT py, <br>    PINT pcx, <br>    PINT pcy, <br>    LPTSTR *ppszMenuName, <br>    LPTSTR *ppszClass, <br>    LPTSTR *ppszCaption, <br>    PINT pPointSize, <br>    LPTSTR *ppszFontName) <br>{ <br>    BYTE UNALIGNED *pb; <br> <br>    *pflStyle = pdbh-&gt;lStyle; <br>    *pflExtStyle = pdbh-&gt;lExtendedStyle; <br>    *pcdit = pdbh-&gt;NumberOfItems; <br>    *px = (SHORT)pdbh-&gt;x; <br>    *py = (SHORT)pdbh-&gt;y; <br>    *pcx = (SHORT)pdbh-&gt;cx; <br>    *pcy = (SHORT)pdbh-&gt;cy; <br> <br>    pb = (PBYTE)pdbh + SIZEOF_DIALOGBOXHEADER; <br>    *ppszMenuName = (LPTSTR)pb; <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    *ppszClass = (LPTSTR)pb; <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    *ppszCaption = (LPTSTR)pb; <br>    pb += (lstrlen((LPTSTR)pb) + 1) * sizeof(TCHAR); <br> <br>    /* <br>     * Does the template specify a font? <br>     */ <br>    if (pdbh-&gt;lStyle &amp; DS_SETFONT) { <br>        *pPointSize = (SHORT)(*(PWORD)pb); <br>        pb += sizeof(WORD); <br>        *ppszFontName = (LPTSTR)pb; <br>        pb += (lstrlen((LPTSTR)pb) + 1) * sizeof(TCHAR); <br>    } <br>    else { <br>        *pPointSize = 0; <br>        *ppszFontName = NULL; <br>    } <br> <br>    DWordAlign((PBYTE *)&amp;pb); <br> <br>    return (PCONTROLDATA)pb; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ParseControlData <br>* <br>* <br>* Arguments: <br>*   PCONTROLDATA pcd    - Points to the control data to parse. <br>*   PDWORD pflStyle     - Receives the control style. <br>*   PDWORD pflExtStyle  - Receives the extended control style. <br>*   PINT px             - Receives starting x location. <br>*   PINT py             - Receives starting y location. <br>*   PINT pcx            - Receives the width. <br>*   PINT pcy            - Receives the height. <br>*   PINT pid            - Receives the control id. <br>*   LPTSTR *ppszClass   - Receives the class name. <br>*   LPTSTR *ppszText    - Receives the text. <br>* <br>* Returns: <br>*   A pointer to the next dialog item past the given one. <br>* <br>************************************************************************/ <br> <br>PCONTROLDATA ParseControlData( <br>    PCONTROLDATA pcd, <br>    PDWORD pflStyle, <br>    PDWORD pflExtStyle, <br>    PINT px, <br>    PINT py, <br>    PINT pcx, <br>    PINT pcy, <br>    PINT pid, <br>    LPTSTR *ppszClass, <br>    LPTSTR *ppszText) <br>{ <br>    BYTE UNALIGNED *pb; <br> <br>    *pflStyle = pcd-&gt;lStyle; <br>    *pflExtStyle = pcd-&gt;lExtendedStyle; <br> <br>    *px = (SHORT)pcd-&gt;x; <br>    *py = (SHORT)pcd-&gt;y; <br>    *pcx = (SHORT)pcd-&gt;cx; <br>    *pcy = (SHORT)pcd-&gt;cy; <br>    *pid = (SHORT)pcd-&gt;wId; <br> <br>    pb = (PBYTE)pcd + SIZEOF_CONTROLDATA; <br>    *ppszClass = (LPTSTR)pb; <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    *ppszText = (LPTSTR)pb; <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    /* <br>     * Finally, skip the Create Struct Data. <br>     * After this, pb will be pointing to the next control. <br>     */ <br>    pb += *(PWORD)pb + sizeof(WORD); <br> <br>    DWordAlign((PBYTE *)&amp;pb); <br> <br>    return (PCONTROLDATA)pb; <br>} <br> <br> <br> <br>/************************************************************************ <br>* DWordAlign <br>* <br>* This function aligns the passed pointer to a DWORD boundary. <br>* <br>* Arguments: <br>*   PBYTE *ppb - Points to the pointer to align. <br>* <br>************************************************************************/ <br> <br>VOID DWordAlign( <br>    PBYTE *ppb) <br>{ <br>    *ppb += (4 - (((WORD)(DWORD)*ppb) &amp; 3)) % 4; <br>} <br> <br> <br> <br>/************************************************************************ <br>* DWordPad <br>* <br>* This function aligns the passed pointer to a DWORD boundary, padding <br>* with nulls as it goes. <br>* <br>* Arguments: <br>*   PBYTE *ppb - Points to the pointer to align. <br>* <br>************************************************************************/ <br> <br>VOID DWordPad( <br>    PBYTE *ppb) <br>{ <br>    WORD cbytes; <br> <br>    cbytes = (WORD)((4 - (((WORD)(DWORD)*ppb) &amp; 3)) % 4); <br>    while (cbytes) { <br>        *((*ppb)++) = 0; <br>        cbytes--; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ResourceType <br>* <br>* This function returns a pointer to the type of the resource. <br>* The type can be either a string or an ordinal. <br>* <br>* Arguments: <br>*   PRES pRes - Points to the start of the resource. <br>* <br>* Returns: <br>*     Pointer to the type of the resource. <br>* <br>************************************************************************/ <br> <br>LPTSTR ResourceType( <br>    PRES pRes) <br>{ <br>    /* <br>     * Skip past the two size fields. <br>     */ <br>    return (LPTSTR)((PBYTE)pRes + sizeof(DWORD) + sizeof(DWORD)); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ResourceName <br>* <br>* This function returns a pointer to the name of the resource. <br>* The name can be either a string or an ordinal. <br>* <br>* Arguments: <br>*   PRES pRes - Points to the start of the resource. <br>* <br>* Returns: <br>*     Pointer to the name of the resource. <br>* <br>************************************************************************/ <br> <br>LPTSTR ResourceName( <br>    PRES pRes) <br>{ <br>    PBYTE pb; <br> <br>    /* <br>     * Skip past the two size fields. <br>     */ <br>    pb = (PBYTE)pRes + sizeof(DWORD) + sizeof(DWORD); <br> <br>    /* <br>     * Skip past the "Type" field to the name. <br>     */ <br>    return (LPTSTR)SkipSz((LPTSTR)pb); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ResourcePart2 <br>* <br>* This function returns a pointer to the second half of the resource <br>* header. <br>* <br>* Arguments: <br>*   PRES pRes - Points to the start of the resource. <br>* <br>* Returns: <br>*   A pointer to the second part of the resource header. <br>* <br>************************************************************************/ <br> <br>PRES2 ResourcePart2( <br>    PRES pRes) <br>{ <br>    PBYTE pb; <br> <br>    /* <br>     * Skip past the first part of the resource header. <br>     */ <br>    pb = (PBYTE)pRes + sizeof(RES); <br> <br>    /* <br>     * Skip past the "Type" field to the name. <br>     */ <br>    pb = SkipSz((LPTSTR)pb); <br> <br>    /* <br>     * Skip past the name field also. <br>     */ <br>    pb = SkipSz((LPTSTR)pb); <br>    DWordAlign(&amp;pb); <br> <br>    return (PRES2)pb; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ResourceSize <br>* <br>* This returns the size of the given resource. <br>* <br>* Arguments: <br>*   PRES pRes - Points to the start of the resource. <br>* <br>* Returns: <br>*   Size of the resource, including the header. <br>* <br>************************************************************************/ <br> <br>DWORD ResourceSize( <br>    PRES pRes) <br>{ <br>    return pRes-&gt;HeaderSize + pRes-&gt;DataSize; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SkipResHeader <br>* <br>* This function returns a pointer to the start of the resource data, <br>* just past it's header. <br>* <br>* Arguments: <br>*   PRES pRes - Pointer to the resource. <br>* <br>************************************************************************/ <br> <br>PBYTE SkipResHeader( <br>    PRES pRes) <br>{ <br>    return (PBYTE)pRes + pRes-&gt;HeaderSize; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SkipSz <br>* <br>* This function skips past a string and returns a pointer to just <br>* past it.  It detects if the string is really an ordinal and skips <br>* past these also. <br>* <br>* Arguments: <br>*   LPTSTR pNameOrd - Pointer to the string/ordinal. <br>* <br>************************************************************************/ <br> <br>PBYTE SkipSz( <br>    LPTSTR pNameOrd) <br>{ <br>    if (IsOrd(pNameOrd)) <br>        pNameOrd = (LPTSTR)((PBYTE)pNameOrd + sizeof(ORDINAL)); <br>    else <br>        pNameOrd += lstrlen(pNameOrd) + 1; <br> <br>    return (PBYTE)pNameOrd; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SkipDialogBoxHeader <br>* <br>* This function skips past a dialog template structure and returns <br>* a pointer to the first dialog item template just past it. <br>* <br>* Arguments: <br>*   PDIALOGBOXHEADER pdbh - Points to the dialog box header. <br>* <br>* Returns: <br>*   A pointer to the first dialog item control data in the resource, <br>*   just past the dialog box header that was skipped. <br>* <br>************************************************************************/ <br> <br>PCONTROLDATA SkipDialogBoxHeader( <br>    PDIALOGBOXHEADER pdbh) <br>{ <br>    BYTE UNALIGNED *pb; <br> <br>    /* <br>     * Skip the fixed portion. <br>     */ <br>    pb = (PBYTE)pdbh + SIZEOF_DIALOGBOXHEADER; <br> <br>    /* <br>     * Skip the menu. <br>     */ <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    /* <br>     * Skip the class. <br>     */ <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    /* <br>     * Skip the caption. <br>     */ <br>    pb += (lstrlen((LPTSTR)pb) + 1) * sizeof(TCHAR); <br> <br>    /* <br>     * Does the template specify a font? <br>     */ <br>    if (pdbh-&gt;lStyle &amp; DS_SETFONT) { <br>        pb += sizeof(WORD); <br>        pb += (lstrlen((LPTSTR)pb) + 1) * sizeof(TCHAR); <br>    } <br> <br>    DWordAlign((PBYTE *)&amp;pb); <br> <br>    return (PCONTROLDATA)pb; <br>} <br> <br> <br> <br>/************************************************************************ <br>* SkipControlData <br>* <br>* This function skips past the given control data to the next control. <br>* <br>* Arguments: <br>*   PCONTROLDATA pcd - Points to the control data structure to skip. <br>* <br>* Returns: <br>*   A pointer to the next control data structure. <br>* <br>************************************************************************/ <br> <br>PCONTROLDATA SkipControlData( <br>    PCONTROLDATA pcd) <br>{ <br>    BYTE UNALIGNED *pb; <br> <br>    /* <br>     * Skip the fixed portion. <br>     */ <br>    pb = (PBYTE)pcd + SIZEOF_CONTROLDATA; <br> <br>    /* <br>     * Skip the class. <br>     */ <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    /* <br>     * Skip the text. <br>     */ <br>    pb += NameOrdLen((LPTSTR)pb); <br> <br>    /* <br>     * Finally, skip the Create Struct Data. <br>     * After this, pb will be pointing to the next control. <br>     */ <br>    pb += *(PWORD)pb + sizeof(WORD); <br> <br>    DWordAlign((PBYTE *)&amp;pb); <br> <br>    return (PCONTROLDATA)pb; <br>} <br> <br> <br> <br>/************************************************************************ <br>* NameOrdCpy <br>* <br>* This function copies a string or ordinal.  This function needs to be <br>* used whenever a string could possibly be an ordinal.  It returns a <br>* pointer to the first byte after the copied name/ordinal. <br>* <br>* Arguments: <br>*   LPTSTR pNameOrdDest - The destination buffer. <br>*   LPTSTR pNameOrdSrc  - The source string or ordinal. <br>* <br>************************************************************************/ <br> <br>PBYTE NameOrdCpy( <br>    LPTSTR pNameOrdDest, <br>    LPTSTR pNameOrdSrc) <br>{ <br>    if (IsOrd(pNameOrdSrc)) { <br>        memcpy((PBYTE)pNameOrdDest, (PBYTE)pNameOrdSrc, sizeof(ORDINAL)); <br>        return (PBYTE)pNameOrdDest + sizeof(ORDINAL); <br>    } <br>    else { <br>        lstrcpy(pNameOrdDest, pNameOrdSrc); <br>        return (PBYTE)(pNameOrdDest + (lstrlen(pNameOrdDest) + 1)); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* NameOrdCmp <br>* <br>* This function compares two strings or ordinals.  It returns a <br>* zero if they are equal, or non-zero if they are not.  This <br>* follows the convention of lstrcmp(), but the return should <br>* not be relied upon to determine which is "greater" than <br>* the other. <br>* <br>* Arguments: <br>*   LPTSTR pNameOrd1 - The first string or ordinal. <br>*   LPTSTR pNameOrd2 - The second string or ordinal. <br>* <br>************************************************************************/ <br> <br>INT NameOrdCmp( <br>    LPTSTR pNameOrd1, <br>    LPTSTR pNameOrd2) <br>{ <br>    BOOL fIsOrd1; <br>    BOOL fIsOrd2; <br> <br>    fIsOrd1 = IsOrd(pNameOrd1); <br>    fIsOrd2 = IsOrd(pNameOrd2); <br> <br>    if (fIsOrd1 != fIsOrd2) <br>        return 1; <br> <br>    if (fIsOrd1) <br>        return memcmp((PBYTE)pNameOrd1, (PBYTE)pNameOrd2, sizeof(ORDINAL)); <br>    else <br>        return lstrcmp(pNameOrd1, pNameOrd2); <br>} <br> <br> <br> <br>/************************************************************************ <br>* NameOrdLen <br>* <br>* This function returns the length of a string or ordinal. <br>* If the given name is a string, the length of the string <br>* plus the terminating null is returned.  Otherwise, <br>* the size of an ORDINAL structure is returned. <br>* <br>* The length returned is in bytes, not wide-chars. <br>* <br>* Arguments: <br>*   LPTSTR pNameOrd - The string or ordinal. <br>* <br>************************************************************************/ <br> <br>INT NameOrdLen( <br>    LPTSTR pNameOrd) <br>{ <br>    if (IsOrd(pNameOrd)) <br>        return sizeof(ORDINAL); <br>    else <br>        return (lstrlen(pNameOrd) + 1) * sizeof(TCHAR); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* NameOrdDup <br>* <br>* This function allocates a copy of the given name or ordinal. <br>* <br>* Arguments: <br>*   LPTSTR pNameOrd - The name or ordinal to duplicate. <br>* <br>* Returns a pointer to the new copy if successful, NULL if it fails. <br>* <br>****************************************************************************/ <br> <br>LPTSTR NameOrdDup( <br>    LPTSTR pNameOrd) <br>{ <br>    register INT iLen; <br>    LPTSTR psz; <br> <br>    iLen = NameOrdLen(pNameOrd); <br> <br>    if (!(psz = (LPTSTR)MyAlloc(iLen))) <br>        return NULL; <br> <br>    NameOrdCpy(psz, pNameOrd); <br> <br>    return psz; <br>} <br> <br> <br> <br>/************************************************************************ <br>* StrToNameOrd <br>* <br>* This function takes the given string, determines if it is <br>* all numeric and if so, converts it in place into an ordinal. <br>* It is used to convert the string from an edit field for <br>* a value that can be an ordinal, such as the dialog name or <br>* an icon's text. <br>* <br>* Note that the pszNameOrd buffer must be large enough for an <br>* ordinal in case the string gets converted to an ordinal. <br>* <br>* Arguments: <br>*   LPTSTR pszNameOrd  - On input, contains the string to possibly <br>*                        convert.  On output, it will contain the <br>*                        original string or the string converted to <br>*                        an ordinal. <br>*   BOOL fDecOnly      - TRUE if hex values and negative values (the <br>*                        string starts with a '-') are not allowed. <br>*                        This flag prevents these types of strings <br>*                        from being candidates for conversion to <br>*                        ordinals. <br>* <br>************************************************************************/ <br> <br>VOID StrToNameOrd( <br>    LPTSTR pszNameOrd, <br>    BOOL fDecOnly) <br>{ <br>    register INT i; <br>    INT nOrd; <br>    INT nLen; <br> <br>    /* <br>     * Empty string? <br>     */ <br>    if (!(*pszNameOrd)) <br>        return; <br> <br>    nLen = lstrlen(pszNameOrd); <br> <br>    /* <br>     * Is a hex value ok and does this appear to be a hex value? <br>     */ <br>    if (!fDecOnly &amp;&amp; pszNameOrd[0] == CHAR_0 &amp;&amp; <br>            (pszNameOrd[1] == CHAR_X || pszNameOrd[1] == CHAR_CAP_X)) { <br>        for (i = 2; i &lt; nLen; i++) { <br>            if (!iswxdigit(pszNameOrd[i])) <br>                return; <br>        } <br> <br>        nOrd =  axtoi(&amp;pszNameOrd[2]); <br>    } <br>    else { <br>        /* <br>         * All characters must be numeric.  Negative numbers may <br>         * or may not be allowed, based on the fDecOnly flag. <br>         */ <br>        for (i = 0; i &lt; nLen; i++) { <br>            if (!iswdigit(pszNameOrd[i]) &amp;&amp; <br>                    (fDecOnly || i != 0 || pszNameOrd[0] != CHAR_MINUS)) <br>                return; <br>        } <br> <br>        nOrd = awtoi(pszNameOrd); <br>    } <br> <br>    /* <br>     * Return the ordinal in the original buffer. <br>     */ <br>    WriteOrd((PORDINAL)pszNameOrd, nOrd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteOrd <br>* <br>* This function writes out the given ordinal to the specified <br>* memory location.  It returns the first byte past the newly <br>* written ordinal. <br>* <br>* Arguments: <br>*   PORDINAL pMem   - Pointer to the location to write the ordinal. <br>*   INT nOrdinalID  - Ordinal ID to write. <br>* <br>************************************************************************/ <br> <br>PBYTE WriteOrd( <br>    PORDINAL pOrd, <br>    INT nOrdinalID) <br>{ <br>    pOrd-&gt;wReserved = 0xffff; <br>    pOrd-&gt;wOrdID = (WORD)nOrdinalID; <br> <br>    return (PBYTE)pOrd + sizeof(ORDINAL); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteResHeader <br>* <br>* This function writes out a resource header to the memory location <br>* specified. <br>* <br>* Arguments: <br>* <br>*    PRES pRes            - pointer to the resource  <br>*    DWORD DataSize       - size of the data <br>*    INT iResType         - resource type <br>*    LPTSTR pszResName    - resource name <br>*    WORD fResFlags       - resource flags <br>*    WORD LanguageId      - language id <br>*    DWORD DataVersion    - data version <br>*    DWORD Version        - version <br>*    DWORD Characteristics-characterstics <br>* <br>* Returns: <br>*    number of bytes written <br>* <br>************************************************************************/ <br> <br>PBYTE WriteResHeader( <br>    PRES pRes, <br>    DWORD DataSize, <br>    INT iResType, <br>    LPTSTR pszResName, <br>    WORD fResFlags, <br>    WORD LanguageId, <br>    DWORD DataVersion, <br>    DWORD Version, <br>    DWORD Characteristics) <br>{ <br>    PBYTE pb; <br>    PRES2 pRes2; <br> <br>    pb = (PBYTE)pRes + sizeof(RES); <br>    pb = WriteOrd((PORDINAL)pb, iResType); <br>    pb = NameOrdCpy((LPTSTR)pb, pszResName); <br>    DWordPad(&amp;pb); <br> <br>    pRes-&gt;DataSize = DataSize; <br>    pRes-&gt;HeaderSize = (pb - (PBYTE)pRes) + sizeof(RES2); <br> <br>    pRes2 = (PRES2)pb; <br>    pRes2-&gt;DataVersion = DataVersion; <br>    pRes2-&gt;MemoryFlags = fResFlags; <br>    pRes2-&gt;LanguageId = LanguageId; <br>    pRes2-&gt;Version = Version; <br>    pRes2-&gt;Characteristics = Characteristics; <br> <br>    return (PBYTE)pRes + pRes-&gt;HeaderSize; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteSz <br>* <br>* This function writes out the string given to the specified <br>* memory location.  It returns the first byte past the newly <br>* written string. <br>* <br>* Arguments: <br>*   LPTSTR pszDest - Pointer to the location to write the string. <br>*   LPTSTR pszSrc  - The string to write. <br>* <br>************************************************************************/ <br> <br>PBYTE WriteSz( <br>    LPTSTR pszDest, <br>    LPTSTR pszSrc) <br>{ <br>    while (*pszSrc) <br>        *pszDest++ = *pszSrc++; <br> <br>    *pszDest++ = CHAR_NULL; <br> <br>    return (PBYTE)pszDest; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
