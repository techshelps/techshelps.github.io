<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATUS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5621"></a>STATUS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: status.c <br>* <br>* Support for the Status window. <br>* <br>* Functions: <br>* <br>*    StatusDlgProc() <br>*    StatusApplyChanges() <br>*    StatusFillSymbolList() <br>*    StatusSetCoords() <br>*    StatusUpdate() <br>*    StatusSetEnable() <br>*    StatusInit() <br>*    StatusProcessCommand() <br>*    ValidateNewName() <br>*    ValidateNewID() <br>*    ApplyNewName() <br>*    ApplyNewID() <br>*    ApplyNewText() <br>*    StatusSetText() <br>*    StatusSetTextLabels() <br>*    StatusSetID() <br>*    StatusSetName() <br>*    StatusSetNameID() <br>*    StatusClearID() <br>*    StatusClearName() <br>*    StatusClear() <br>*    StatusShowFields() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br> <br>STATICFN BOOL StatusInit(HWND hwnd); <br>STATICFN VOID StatusProcessCommand(HWND hwnd, INT idCtrl, <br>    INT NotifyCode); <br>STATICFN BOOL ValidateNewName(NPCTYPE npc, LPTSTR pszName, <br>    LPTSTR pszID, LPTSTR pszSym, PINT pidNew, BOOL *pfAddLabel); <br>STATICFN BOOL ValidateNewID(NPCTYPE npc, LPTSTR pszSym, LPTSTR pszID, <br>    PINT pidNew, BOOL *pfAddLabel); <br>STATICFN BOOL ApplyNewName(NPCTYPE npc, LPTSTR pszName, <br>    BOOL fAddLabel, LPTSTR pszSym, INT idNew); <br>STATICFN BOOL ApplyNewID(NPCTYPE npc, INT idNew, BOOL fAddLabel, <br>    LPTSTR pszSym); <br>STATICFN BOOL ApplyNewText(NPCTYPE npc, LPTSTR pszNewText); <br>STATICFN VOID StatusSetText(LPTSTR pszText, INT Type); <br>STATICFN VOID StatusSetTextLabels(INT Type, BOOL fIsOrd); <br>STATICFN VOID StatusSetID(INT id, BOOL fSymAlso); <br>STATICFN VOID StatusSetName(LPTSTR pszName, INT Type); <br>STATICFN VOID StatusSetNameID(INT id, INT Type); <br>STATICFN VOID StatusClearID(VOID); <br>STATICFN VOID StatusClearName(VOID); <br>STATICFN VOID StatusClear(VOID); <br>STATICFN VOID StatusShowFields(INT Type); <br> <br>/* <br> * TRUE if the user has changed the entry fields in the status window. <br> * This will be reset to FALSE whenever new information is placed <br> * into the fields. <br> */ <br>static BOOL gfStatusChanged = FALSE; <br> <br>/* <br> * These globals save the window positions of the upper and lower <br> * combo boxes and edit controls.  This is used to position them <br> * depending on what type of control is selected. <br> */ <br>static RECT grcTopCombo; <br>static RECT grcBottomCombo; <br>static RECT grcTopEdit; <br>static RECT grcBottomEdit; <br> <br> <br> <br>/************************************************************************ <br>* StatusDlgProc <br>* <br>* This is the dialog procedure for the Status ribbon window. <br>* <br>************************************************************************/ <br> <br>DIALOGPROC StatusDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            return StatusInit(hwnd); <br> <br>        case WM_PAINT: <br>            { <br>                HDC hdc; <br>                RECT rc; <br>                PAINTSTRUCT ps; <br>                HPEN hpenWindowFrame; <br> <br>                /* <br>                 * Draw our border lines. <br>                 */ <br>                GetClientRect(hwnd, &amp;rc); <br>                hdc = BeginPaint(hwnd, &amp;ps); <br> <br>                SelectObject(hdc, GetStockObject(WHITE_PEN)); <br>                MoveToEx(hdc, rc.left, rc.top, NULL); <br>                LineTo(hdc, rc.right, rc.top); <br> <br>                SelectObject(hdc, hpenDarkGray); <br>                MoveToEx(hdc, rc.left, (rc.top + gcyStatus) - gcyBorder - 1, NULL); <br>                LineTo(hdc, rc.right, (rc.top + gcyStatus) - gcyBorder - 1); <br> <br>                hpenWindowFrame = CreatePen(PS_SOLID, gcyBorder, <br>                        GetSysColor(COLOR_WINDOWFRAME)); <br>                SelectObject(hdc, hpenWindowFrame); <br>                MoveToEx(hdc, rc.left, (rc.top + gcyStatus) - gcyBorder, NULL); <br>                LineTo(hdc, rc.right, (rc.top + gcyStatus) - gcyBorder); <br> <br>                EndPaint(hwnd, &amp;ps); <br>                DeleteObject(hpenWindowFrame); <br>            } <br> <br>            break; <br> <br>        case WM_CTLCOLORDLG: <br>        case WM_CTLCOLORLISTBOX: <br>        case WM_CTLCOLORSTATIC: <br>            switch ((WORD)(msg - WM_CTLCOLORMSGBOX)) { <br>                case CTLCOLOR_DLG: <br>                case CTLCOLOR_LISTBOX: <br>                    return (BOOL)GetStockObject(LTGRAY_BRUSH); <br> <br>                case CTLCOLOR_STATIC: <br>                    SetBkColor((HDC)(wParam), <br>                            LIGHTGRAY); <br>                    return (BOOL)GetStockObject(LTGRAY_BRUSH); <br>            } <br> <br>            return (BOOL)NULL; <br> <br>        case WM_COMMAND: <br>            StatusProcessCommand(hwnd, <br>                    LOWORD(wParam), <br>                    HIWORD(wParam)); <br>            break; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusInit <br>* <br>* Initializes the Status ribbon window. <br>* <br>* Arguments: <br>*     HWND hwnd = The window handle. <br>* <br>* Returns: <br>*      <br>* TRUE  <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL StatusInit( <br>    HWND hwnd) <br>{ <br>    /* <br>     * Set this global right away.  Other routines that will be called <br>     * before CreateDialog returns depend on this global. <br>     */ <br>    hwndStatus = hwnd; <br> <br>    GetChildRect(GetDlgItem(hwnd, DID_STATUSSYM), &amp;grcTopCombo); <br>    GetChildRect(GetDlgItem(hwnd, DID_STATUSSYMID), &amp;grcTopEdit); <br>    GetChildRect(GetDlgItem(hwnd, DID_STATUSNAME), &amp;grcBottomCombo); <br>    GetChildRect(GetDlgItem(hwnd, DID_STATUSNAMEID), &amp;grcBottomEdit); <br> <br>    SendDlgItemMessage(hwnd, DID_STATUSSYM, EM_LIMITTEXT, CCHTEXTMAX, 0L); <br>    SendDlgItemMessage(hwnd, DID_STATUSNAME, EM_LIMITTEXT, CCHTEXTMAX, 0L); <br>    SendDlgItemMessage(hwnd, DID_STATUSSYMID, EM_LIMITTEXT, CCHIDMAX, 0L); <br>    SendDlgItemMessage(hwnd, DID_STATUSNAMEID, EM_LIMITTEXT, CCHIDMAX, 0L); <br>    SendDlgItemMessage(hwnd, DID_STATUSTEXT, EM_LIMITTEXT, CCHTEXTMAX, 0L); <br> <br>    StatusFillSymbolList(plInclude); <br>    StatusUpdate(); <br>    StatusSetEnable(); <br> <br>    /* <br>     * Return TRUE so that the dialog manager does NOT set the focus <br>     * for me.  This prevents the status window from initially having <br>     * the focus when the editor is started. <br>     */ <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusProcessCommand <br>* <br>* Function that processes commands sent to the status window. <br>* <br>* Arguments: <br>*   HWND hwnd        - The window handle. <br>*   INT idCtrl       - The id of the control the WM_COMMAND is for. <br>*   INT NotifyCode   - The control's notification code. <br>* <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusProcessCommand( <br>    HWND hwnd, <br>    INT idCtrl, <br>    INT NotifyCode) <br>{ <br>    TCHAR szSym[CCHTEXTMAX]; <br>    TCHAR szID[CCHIDMAX + 1]; <br>    NPLABEL npLabel; <br>    INT id; <br>    INT nIndex; <br>    LPTSTR pszOldName; <br> <br>    switch (idCtrl) { <br>        case DID_STATUSSYM: <br>            /* <br>             * Did the symbol edit field change and is <br>             * something selected? <br>             */ <br>            if (gnpcSel &amp;&amp; (NotifyCode == CBN_EDITCHANGE || <br>                    NotifyCode == CBN_SELCHANGE)) { <br>                /* <br>                 * Get the symbol and begin looking for it. <br>                 */ <br>                if (NotifyCode == CBN_EDITCHANGE) { <br>                    /* <br>                     * The edit field was typed into.  Get the <br>                     * new text from there. <br>                     */ <br>                    GetDlgItemText(hwnd, DID_STATUSSYM, szSym, CCHTEXTMAX); <br>                } <br>                else { <br>                    /* <br>                     * A new string was selected from the list <br>                     * box.  Get it from the list box, because <br>                     * at this point the new text is not yet set <br>                     * into the edit control! <br>                     */ <br>                    nIndex = (INT)SendDlgItemMessage(hwnd, <br>                            DID_STATUSSYM, CB_GETCURSEL, 0, 0L); <br> <br>                    if (nIndex != CB_ERR) <br>                        SendDlgItemMessage(hwnd, DID_STATUSSYM, CB_GETLBTEXT, <br>                                nIndex, (DWORD)szSym); <br>                    else <br>                        *szSym = CHAR_NULL; <br>                } <br> <br>                /* <br>                 * Convert the symbol field to the associated id value, <br>                 * taking into account the special IDOK values, etc. <br>                 */ <br>                if (!LabelToID(szSym, &amp;id)) { <br>                    /* <br>                     * The symbol was not found. <br>                     * If the symbol is not blank, and the <br>                     * id of the control is already taken <br>                     * by another label, fill the id field <br>                     * with the next available id.  Otherwise, <br>                     * fill the id field with the controls <br>                     * id value.  It is assumed here that the <br>                     * dialog cannot be selected if the symbol <br>                     * field was able to be changed. <br>                     */ <br>                    if (*szSym &amp;&amp; FindID(gnpcSel-&gt;id, plInclude)) <br>                        id = NextID(NEXTID_CONTROL, plInclude, 0); <br>                    else <br>                        id = gnpcSel-&gt;id; <br>                } <br> <br>                StatusSetID(id, FALSE); <br> <br>                gfStatusChanged = TRUE; <br>            } <br> <br>            break; <br> <br>        case DID_STATUSNAME: <br>            /* <br>             * Did the name edit field change and is <br>             * something selected? <br>             */ <br>            if (gnpcSel &amp;&amp; (NotifyCode == CBN_EDITCHANGE || <br>                    NotifyCode == CBN_SELCHANGE)) { <br>                /* <br>                 * Get the symbol and begin looking for it. <br>                 */ <br>                if (NotifyCode == CBN_EDITCHANGE) { <br>                    /* <br>                     * The edit field was typed into.  Get the <br>                     * new text from there. <br>                     */ <br>                    GetDlgItemText(hwnd, DID_STATUSNAME, szSym, CCHTEXTMAX); <br>                } <br>                else { <br>                    /* <br>                     * A new string was selected from the list <br>                     * box.  Get it from the list box, because <br>                     * at this point the new text is not yet set <br>                     * into the edit control! <br>                     */ <br>                    nIndex = (INT)SendDlgItemMessage(hwnd, <br>                            DID_STATUSNAME, CB_GETCURSEL, 0, 0L); <br> <br>                    if (nIndex != CB_ERR) <br>                        SendDlgItemMessage(hwnd, DID_STATUSNAME, CB_GETLBTEXT, <br>                                nIndex, (DWORD)szSym); <br>                    else <br>                        *szSym = CHAR_NULL; <br>                } <br> <br>                /* <br>                 * Try and convert the name to an ordinal. <br>                 */ <br>                StrToNameOrd(szSym, (gnpcSel-&gt;pwcd-&gt;iType == W_DIALOG) ? <br>                        TRUE : FALSE); <br> <br>                /* <br>                 * Was the name converted to an ordinal? <br>                 */ <br>                if (IsOrd(szSym)) { <br>                    id = OrdID(szSym); <br>                } <br>                /* <br>                 * Is it an existing label? <br>                 */ <br>                else if (npLabel = FindLabel(szSym, plInclude)) { <br>                    id = npLabel-&gt;id; <br>                } <br>                else { <br>                    /* <br>                     * Get a pointer to the original name. <br>                     */ <br>                    pszOldName = (gnpcSel-&gt;pwcd-&gt;iType == W_DIALOG) ? <br>                            gcd.pszDlgName : gnpcSel-&gt;text; <br> <br>                    /* <br>                     * If the old name was originally an ordinal, and <br>                     * there was no corresponding label for it, <br>                     * assume that the user is trying to enter a <br>                     * define for it and leave it alone.  Otherwise, <br>                     * pick the next available id.  But if the user <br>                     * completely blanks out the field, leave it <br>                     * alone also (this is a benign case). <br>                     */ <br>                    if (IsOrd(pszOldName) &amp;&amp; <br>                            (!*szSym || !FindID(OrdID(pszOldName), plInclude))) <br>                        id = OrdID(pszOldName); <br>                    else <br>                        id = NextID((gnpcSel-&gt;pwcd-&gt;iType == W_DIALOG) ? <br>                                NEXTID_DIALOG : NEXTID_CONTROL, plInclude, 0); <br>                } <br> <br>                StatusSetNameID(id, gnpcSel-&gt;pwcd-&gt;iType); <br> <br>                /* <br>                 * Change the labels to reflect that the entered name <br>                 * is an ID instead of a name. <br>                 */ <br>                StatusSetTextLabels(gnpcSel-&gt;pwcd-&gt;iType, TRUE); <br> <br>                gfStatusChanged = TRUE; <br>            } <br> <br>            break; <br> <br>        case DID_STATUSSYMID: <br>        case DID_STATUSNAMEID: <br>        case DID_STATUSTEXT: <br>            if (!gnpcSel) <br>                break; <br> <br>            if (NotifyCode == EN_CHANGE) <br>                gfStatusChanged = TRUE; <br> <br>            if (idCtrl == DID_STATUSNAMEID) { <br>                GetDlgItemText(hwnd, DID_STATUSNAME, szSym, CCHTEXTMAX); <br>                GetDlgItemText(hwnd, DID_STATUSNAMEID, szID, CCHIDMAX + 1); <br>                StrToNameOrd(szSym, (gnpcSel-&gt;pwcd-&gt;iType == W_DIALOG) ? <br>                        TRUE : FALSE); <br> <br>                /* <br>                 * Change the labels to reflect whether the entered name <br>                 * is an ID or a name.  It is considered an id if the <br>                 * edit field has something in it, or if the name field <br>                 * is a valid label, or if the name field represents an <br>                 * ordinal (it is numeric). <br>                 */ <br>                StatusSetTextLabels(gnpcSel-&gt;pwcd-&gt;iType, <br>                        (IsOrd(szSym) || *szID || <br>                        FindLabel(szSym, plInclude)) ? TRUE : FALSE); <br>            } <br> <br>            break; <br> <br>        case IDOK: <br>            if (StatusApplyChanges()) <br>                SetFocus(ghwndMain); <br> <br>            break; <br> <br>        case IDCANCEL: <br>            StatusUpdate(); <br>            SetFocus(ghwndMain); <br>            break; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusApplyChanges <br>* <br>* Processes the Enter command from the "Status" bar window to apply <br>* the current value of the fields to the current control. <br>* <br>* Returns: <br>* <br>* TRUE is successful; otherwise, FALSE is returned. <br>* <br>************************************************************************/ <br> <br>BOOL StatusApplyChanges(VOID) <br>{ <br>    TCHAR szText[CCHTEXTMAX]; <br>    TCHAR szSym[CCHTEXTMAX]; <br>    TCHAR szName[CCHTEXTMAX]; <br>    TCHAR szSymID[CCHIDMAX + 1]; <br>    TCHAR szNameID[CCHIDMAX + 1]; <br>    TCHAR szNameSym[CCHTEXTMAX]; <br>    INT idSymNew; <br>    INT idNameNew; <br>    BOOL fAddSymLabel; <br>    BOOL fAddNameLabel; <br>    BOOL fSuccess = FALSE; <br> <br>    /* <br>     * Quit if nothing is selected, or if nothing was changed. <br>     */ <br>    if (!gnpcSel || !gfStatusChanged) <br>        return TRUE; <br> <br>    idSymNew = gnpcSel-&gt;id; <br> <br>    switch (gnpcSel-&gt;pwcd-&gt;iType) { <br>        case W_DIALOG: <br>            GetDlgItemText(hwndStatus, DID_STATUSNAME, szName, CCHTEXTMAX); <br>            GetDlgItemText(hwndStatus, DID_STATUSNAMEID, szNameID, CCHIDMAX + 1); <br>            GetDlgItemText(hwndStatus, DID_STATUSTEXT, szText, CCHTEXTMAX); <br>            if (!ValidateNewName(gnpcSel, szName, szNameID, szNameSym, <br>                    &amp;idNameNew, &amp;fAddNameLabel)) <br>                return FALSE; <br> <br>            if (ApplyNewName(gnpcSel, szName, fAddNameLabel, <br>                    szNameSym, idNameNew) &amp;&amp; <br>                    ApplyNewText(gnpcSel, szText)) <br>                fSuccess = TRUE; <br> <br>            break; <br> <br>        case W_ICON: <br>            GetDlgItemText(hwndStatus, DID_STATUSNAME, szName, CCHTEXTMAX); <br>            GetDlgItemText(hwndStatus, DID_STATUSNAMEID, szNameID, CCHIDMAX + 1); <br>            GetDlgItemText(hwndStatus, DID_STATUSSYM, szSym, CCHTEXTMAX); <br>            GetDlgItemText(hwndStatus, DID_STATUSSYMID, szSymID, CCHIDMAX + 1); <br>            if (!ValidateNewName(gnpcSel, szName, szNameID, szNameSym, <br>                    &amp;idNameNew, &amp;fAddNameLabel) || <br>                    !ValidateNewID(gnpcSel, szSym, szSymID, <br>                    &amp;idSymNew, &amp;fAddSymLabel)) <br>                return FALSE; <br> <br>            if (ApplyNewID(gnpcSel, idSymNew, fAddSymLabel, szSym) &amp;&amp; <br>                    ApplyNewName(gnpcSel, szName, fAddNameLabel, <br>                    szNameSym, idNameNew)) <br>                fSuccess = TRUE; <br> <br>            break; <br> <br>        default: <br>            GetDlgItemText(hwndStatus, DID_STATUSSYM, szSym, CCHTEXTMAX); <br>            GetDlgItemText(hwndStatus, DID_STATUSSYMID, szSymID, CCHIDMAX + 1); <br>            GetDlgItemText(hwndStatus, DID_STATUSTEXT, szText, CCHTEXTMAX); <br>#ifdef JAPAN <br>            { <br>                TCHAR   szTmp[CCHTEXTMAX]; <br> <br>                KKExpandCopy(szTmp, szText, CCHTEXTMAX); <br>                lstrcpy(szText, szTmp); <br>            } <br>#endif <br>            if (!ValidateNewID(gnpcSel, szSym, szSymID, &amp;idSymNew, &amp;fAddSymLabel)) <br>                return FALSE; <br> <br>            if (ApplyNewID(gnpcSel, idSymNew, fAddSymLabel, szSym) &amp;&amp; <br>                    ApplyNewText(gnpcSel, szText)) <br>                fSuccess = TRUE; <br> <br>            break; <br>    } <br> <br>    if (fSuccess) { <br>        ShowFileStatus(FALSE); <br>        StatusUpdate(); <br>    } <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ValidateNewName <br>* <br>* Validates the new name from the processing of the OK command <br>* from the Status ribbon window. <br>* <br>* The name is considered valid if it does not have any blanks in it, <br>* it is not already used by another dialog in the resource file, and <br>* it is not an empty string. <br>* <br>* Arguments: <br>*   NPCTYPE npc      - Pointer to the control. <br>*   LPTSTR pszName   - The new name. <br>*   LPTSTR pszID     - The ID. <br>*   LPTSTR pszSym    - The symbol. <br>*   PINT pidNew      - Where to return the new ID if successful. <br>*   BOOL *pfAddLabel - Set to TRUE if this symbol/id should be added <br>*                      to the include list.  Not touched otherwise. <br>* <br>* Returns: <br>*   TRUE if the new name is valid, FALSE otherwise. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL ValidateNewName( <br>    NPCTYPE npc, <br>    LPTSTR pszName, <br>    LPTSTR pszID, <br>    LPTSTR pszSym, <br>    PINT pidNew, <br>    BOOL *pfAddLabel) <br>{ <br>    NPLABEL npLabel; <br>    BOOL fIDEmpty = FALSE; <br>    BOOL fNameEmpty = FALSE; <br>    BOOL fAddLabel = FALSE; <br>    INT idNew; <br>    TCHAR szIDTemp[CCHIDMAX + 1]; <br> <br>    /* <br>     * Start by assuming that the label will NOT be added. <br>     */ <br>    *pfAddLabel = FALSE; <br> <br>    /* <br>     * Is the ID field non-blank? <br>     */ <br>    if (*pszID) { <br>        /* <br>         * Is the id valid? <br>         */ <br>        if (!IsValue(pszID)) { <br>            Message(MSG_BADSYMBOLID); <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSNAMEID)); <br>            return FALSE; <br>        } <br> <br>        idNew = valtoi(pszID); <br>    } <br>    else { <br>        /* <br>         * The id field is blank. <br>         */ <br>        fIDEmpty = TRUE; <br>    } <br> <br>    /* <br>     * Is the name field blank? <br>     */ <br>    if (!(*pszName)) <br>        fNameEmpty = TRUE; <br> <br>    if (fNameEmpty) { <br>        if (fIDEmpty) { <br>            Message((npc-&gt;pwcd-&gt;iType == W_DIALOG) ? <br>                    MSG_NODLGNAME : MSG_NOICONNAME); <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSNAME)); <br>            return FALSE; <br>        } <br>        else { <br>            WriteOrd((PORDINAL)pszName, idNew); <br>        } <br>    } <br>    else { <br>        /* <br>         * Error if there are imbedded blanks. <br>         */ <br>        if (HasBlanks(pszName)) { <br>            Message((npc-&gt;pwcd-&gt;iType == W_DIALOG) ? <br>                    MSG_DLGNAMEHASBLANKS : MSG_ICONNAMEHASBLANKS); <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSNAME)); <br>            return FALSE; <br>        } <br> <br>        /* <br>         * Convert the name to an ordinal, if appropriate. <br>         */ <br>        StrToNameOrd(pszName, (npc-&gt;pwcd-&gt;iType == W_DIALOG) ? TRUE : FALSE); <br> <br>        /* <br>         * If the name was translated to an ordinal, we are done. <br>         * Otherwise, keep trying to figure out whether it is a <br>         * name or a define. <br>         */ <br>        if (!IsOrd(pszName)) { <br>            /* <br>             * Is the name a symbol in the current include list? <br>             */ <br>            if (npLabel = FindLabel(pszName, plInclude)) { <br>                /* <br>                 * Yes.  If the id field was blank, just assume they <br>                 * wanted the corresponding id. <br>                 */ <br>                if (fIDEmpty) <br>                    idNew = npLabel-&gt;id; <br> <br>                /* <br>                 * If they somehow entered a valid define but tried to <br>                 * give it a different id value, show an error. <br>                 */ <br>                if (npLabel-&gt;id != idNew) { <br>                    Myitoa(npLabel-&gt;id, szIDTemp); <br>                    Message(MSG_IDSYMMISMATCH, szIDTemp); <br>                    SetFocus(GetDlgItem(hwndStatus, DID_STATUSNAMEID)); <br>                    return FALSE; <br>                } <br> <br>                /* <br>                 * Make the name field into an ordinal. <br>                 */ <br>                WriteOrd((PORDINAL)pszName, idNew); <br>            } <br>            else { <br>                /* <br>                 * The name was not found as a label.  Is the id field <br>                 * empty? <br>                 */ <br>                if (fIDEmpty) { <br>                    /* <br>                     * Since the id field is empty, we can assume that <br>                     * what they entered is a name (not a define) <br>                     * and we are done. <br>                     */ <br>                } <br>                else { <br>                    /* <br>                     * At this point we know the name field is not empty, <br>                     * and there is an id entered along with it.  We also <br>                     * know that the name (which we can now assume is <br>                     * a symbol) is not already found in the include file. <br>                     * We will check it for validity, copy it to the <br>                     * pszSym buffer, translate the name to an ordinal <br>                     * and set a flag saying that the sym/id pair should <br>                     * be added to the include list. <br>                     */ <br>                    if (!IsSymbol(pszName)) { <br>                        Message(MSG_BADSYMBOLID); <br>                        SetFocus(GetDlgItem(hwndStatus, DID_STATUSNAME)); <br>                        return FALSE; <br>                    } <br> <br>                    /* <br>                     * Pass back the values. <br>                     */ <br>                    lstrcpy(pszSym, pszName); <br>                    WriteOrd((PORDINAL)pszName, idNew); <br>                    *pidNew = idNew; <br> <br>                    fAddLabel = TRUE; <br>                } <br>            } <br>        } <br>    } <br> <br>    /* <br>     * Inform caller whether they should add this id/symbol <br>     * as a label to the include list. <br>     */ <br>    *pfAddLabel = fAddLabel; <br> <br>    /* <br>     * Return success. <br>     */ <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ValidateNewID <br>* <br>* Validates the new ID from the processing of the OK command from <br>* the Status ribbon window.  It will return the new id in *pidNew. <br>* Note that the control is not actually updated by this routine.  This <br>* is so that if other validations fail nothing will have been done to the <br>* control.  It is assumed that ApplyNewID will be called later to do <br>* the actual update of the control. <br>* <br>* Arguments: <br>*   NPCTYPE npc      = Pointer to the control. <br>*   LPTSTR pszSym    = The symbol. <br>*   LPTSTR pszID     = The ID. <br>*   PINT pidNew      = Where to return the new ID if successful. <br>*   BOOL *pfAddLabel = Set to TRUE if this symbol/id should be added <br>*                      to the include list.  Not touched otherwise. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise.  If TRUE is returned and they <br>*   changed the id, the new id will have been placed in *pidNew. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL ValidateNewID( <br>    NPCTYPE npc, <br>    LPTSTR pszSym, <br>    LPTSTR pszID, <br>    PINT pidNew, <br>    BOOL *pfAddLabel) <br>{ <br>    NPLABEL npLabel; <br>    BOOL fIDEmpty = FALSE; <br>    BOOL fIDChanged = FALSE; <br>    BOOL fSymEmpty = FALSE; <br>    BOOL fSymChanged = FALSE; <br>    BOOL fAddLabel = FALSE; <br>    INT idNew; <br>    TCHAR szIDTemp[CCHIDMAX + 1]; <br> <br>    /* <br>     * Start by assuming that the label will NOT be added. <br>     */ <br>    *pfAddLabel = FALSE; <br> <br>    /* <br>     * If in translate mode, they cannot change the symbol or id, <br>     * and so it should not be validated.  Even if there was a <br>     * problem, they could not fix it. <br>     */ <br>    if (gfTranslateMode) <br>        return TRUE; <br> <br>    /* <br>     * Special case if they selected the "unused" label. <br>     * Blank out the symbol so it doesn't cause trouble <br>     * later, force the id to be zero, and then check if <br>     * the id was changed. <br>     */ <br>    if (lstrcmp(pszSym, ids(IDS_UNUSED)) == 0) { <br>        pszSym = szEmpty; <br>        idNew = IDUNUSED; <br>        if (idNew != npc-&gt;id) <br>            fIDChanged = TRUE; <br>    } <br>    else if (lstrcmp(pszSym, ids(IDS_IDOK)) == 0 &amp;&amp; <br>            !FindLabel(ids(IDS_IDOK), plInclude)) { <br>        pszSym = szEmpty; <br>        idNew = IDOK; <br>        if (idNew != npc-&gt;id) <br>            fIDChanged = TRUE; <br>    } <br>    else if (lstrcmp(pszSym, ids(IDS_IDCANCEL)) == 0 &amp;&amp; <br>            !FindLabel(ids(IDS_IDCANCEL), plInclude)) { <br>        pszSym = szEmpty; <br>        idNew = IDCANCEL; <br>        if (idNew != npc-&gt;id) <br>            fIDChanged = TRUE; <br>    } <br>    /* <br>     * Is the ID field non-blank? <br>     */ <br>    else if (*pszID) { <br>        /* <br>         * Is the id valid? <br>         */ <br>        if (!IsValue(pszID)) { <br>            Message(MSG_BADSYMBOLID); <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSSYMID)); <br>            return FALSE; <br>        } <br> <br>        /* <br>         * Did they change the id value? <br>         */ <br>        idNew = valtoi(pszID); <br>        if (idNew != npc-&gt;id) <br>            fIDChanged = TRUE; <br>    } <br>    else { <br>        /* <br>         * The id field is blank.  This implies they changed it. <br>         */ <br>        fIDEmpty = TRUE; <br>        fIDChanged = TRUE; <br>    } <br> <br>    /* <br>     * Is the symbol field blank? <br>     */ <br>    if (!(*pszSym)) <br>        fSymEmpty = TRUE; <br> <br>    /* <br>     * Determine if they have changed the symbol. <br>     * Did the original id have a symbol associated with it? <br>     */ <br>    if (npLabel = FindID(npc-&gt;id, plInclude)) { <br>        if (lstrcmp(npLabel-&gt;pszLabel, pszSym) != 0) <br>            fSymChanged = TRUE; <br>    } <br>    else { <br>        /* <br>         * Since the original id did not have a symbol, if they <br>         * have entered a symbol it is changed. <br>         */ <br>        if (!fSymEmpty) <br>            fSymChanged = TRUE; <br>    } <br> <br>    /* <br>     * Quit if nothing changed. <br>     */ <br>    if (!fSymChanged &amp;&amp; !fIDChanged) <br>        return TRUE; <br> <br>    /* <br>     * Is the symbol field empty? <br>     */ <br>    if (fSymEmpty) { <br>        /* <br>         * If the id field is empty also, return an error. <br>         */ <br>        if (fIDEmpty) { <br>            Message(MSG_BADSYMBOLID); <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSSYMID)); <br>            return FALSE; <br>        } <br>        else { <br>            /* <br>             * Otherwise, go on to the final test.  It doesn't matter <br>             * if this new id has a symbol or not. <br>             */ <br>            goto CheckForDups; <br>        } <br>    } <br> <br>    /* <br>     * At this point we know the symbol field is not empty. <br>     * Is it a valid symbol? <br>     */ <br>    if (!IsSymbol(pszSym)) { <br>        Message(MSG_BADSYMBOLID); <br>        SetFocus(GetDlgItem(hwndStatus, DID_STATUSSYM)); <br>        return FALSE; <br>    } <br> <br>    /* <br>     * Does this symbol already exist? <br>     */ <br>    if (npLabel = FindLabel(pszSym, plInclude)) { <br>        /* <br>         * Since the symbol exists, if they blanked the id field <br>         * be friendly and assume they want the matching id value. <br>         */ <br>        if (fIDEmpty) </code></pre>
<p>
</p>
<pre><code>idNew = npLabel-&gt;id; <br> <br>        /* <br>         * Does the id that is in the id field match the id of the <br>         * symbol they entered? <br>         */ <br>        if (npLabel-&gt;id == idNew) { <br>            /* <br>             * Yes, go on to the final test. <br>             */ <br>            goto CheckForDups; <br>        } <br>        else { <br>            /* <br>             * No, give them an error message saying that it has to. <br>             */ <br>            Myitoa(npLabel-&gt;id, szIDTemp); <br>            Message(MSG_IDSYMMISMATCH, szIDTemp); <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSSYMID)); <br>            return FALSE; <br>        } <br>    } <br>    else { <br>        /* <br>         * Since the symbol doesn't exist, if they left the id field <br>         * blank, assume they want the next available id. <br>         */ <br>        if (fIDEmpty) <br>            idNew = NextID(NEXTID_CONTROL, plInclude, 0); <br> <br>        /* <br>         * They should add this id/symbol as a label to the <br>         * include list. <br>         */ <br>        fAddLabel = TRUE; <br>        goto CheckForDups; <br>    } <br> <br>CheckForDups: <br>    /* <br>     * If the id changed, it is not the special "unused" id, <br>     * and it is a duplicate of another id, don't allow it. <br>     */ <br>    if (idNew != npc-&gt;id &amp;&amp; !IsUniqueID(idNew)) { <br>        Message(MSG_CTRLDUPID); <br>        SetFocus(GetDlgItem(hwndStatus, DID_STATUSSYM)); <br>        return FALSE; <br>    } <br>    else { <br>        /* <br>         * Pass back the new id value. <br>         */ <br>        *pidNew = idNew; <br> <br>        /* <br>         * Inform caller whether they should add this id/symbol <br>         * as a label to the include list. <br>         */ <br>        *pfAddLabel = fAddLabel; <br> <br>        /* <br>         * Return success. <br>         */ <br>        return TRUE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ApplyNewName <br>* <br>* Updates an icon control's or dialog's name with a new name. <br>* <br>* If fAddLabel is TRUE, pszSym is assumed to be a string that is <br>* the symbol to be added and idNew contains the value associated with <br>* it.  This will cause a new define to be added to the current include <br>* file.  In either event, pszName will contain either a new name or <br>* an ordinal that is to be the name.  For dialogs, the dialog name will <br>* be updated.  For icon controls, the icon's text is updated with the <br>* name/ordinal. <br>* <br>* Arguments: <br>*   NPCTYPE npc     = Pointer to the control. <br>*   LPTSTR pszName  = New name.  A string or ordinal. <br>*   BOOL fAddLabel  = TRUE if a new label for this id/name should be added. <br>*   LPTSTR pszSym   = The new symbol to add (only valid if fAddLabel is TRUE). <br>*   INT idNew       = The new ID (only valid if fAddLabel is TRUE). <br>* <br>* Returns: <br>* <br>* TRUE if successful; otherwise, FALSE is returned. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL ApplyNewName( <br>    NPCTYPE npc, <br>    LPTSTR pszName, <br>    BOOL fAddLabel, <br>    LPTSTR pszSym, <br>    INT idNew) <br>{ <br>    LPTSTR psz; <br> <br>    if (fAddLabel) { <br>        /* <br>         * Go ahead and quietly add the label for them. <br>         */ <br>        if (AddLabel(pszSym, idNew, FPOS_MAX, 0, &amp;plInclude, <br>                &amp;plDelInclude, NULL, NULL)) { <br>            /* <br>             * Return the controls new id, update the status <br>             * windows symbol combo box, mark the fact that <br>             * we have changed the include file, and return <br>             * success. <br>             */ <br>            gfIncChged = TRUE; <br>            StatusFillSymbolList(plInclude); <br>        } <br>        else { <br>            /* <br>             * An error occurred on the AddLabel.  The most likely <br>             * cause of this is if they are trying to add a symbol <br>             * with a duplicate id. <br>             */ <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSNAMEID)); <br>            return FALSE; <br>        } <br>    } <br> <br>    switch (npc-&gt;pwcd-&gt;iType) { <br>        case W_ICON: <br>            /* <br>             * The resource name for an icon is stored in it's text. <br>             */ <br>            ApplyNewText(npc, pszName); <br>            break; <br> <br>        case W_DIALOG: <br>            /* <br>             * We are done if the name was not changed. <br>             */ <br>            if (NameOrdCmp(gcd.pszDlgName, pszName) == 0) <br>                break; <br> <br>            /* <br>             * Allocate room for the new name (it can be an ordinal!). <br>             */ <br>            if (!(psz = MyAlloc(NameOrdLen(pszName)))) <br>                return FALSE; <br> <br>            NameOrdCpy(psz, pszName); <br> <br>            if (gcd.pszDlgName) <br>                MyFree(gcd.pszDlgName); <br> <br>            gcd.pszDlgName = psz; <br> <br>            /* <br>             * If the new name is an ordinal, update the base id of <br>             * the dialog with it. <br>             */ <br>            if (IsOrd(gcd.pszDlgName)) <br>                gcd.npc-&gt;id = OrdID(gcd.pszDlgName); <br> <br>            /* <br>             * Finally, set the "changed" flag. <br>             */ <br>            gfResChged = gfDlgChanged = TRUE; <br> <br>            break; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ApplyNewID <br>* <br>* Updates the control with the new id. <br>* <br>* Arguments: <br>*   NPCTYPE npc    = Pointer to the control. <br>*   INT idNew      = The ID. <br>*   BOOL fAddLabel = TRUE if a new label for this id/symbol should be added. <br>*   LPTSTR pszSym  = Symbol to add if fAddLabel is TRUE. <br>* <br>* Returns: <br>* <br>* TRUE if successful; otherwise, FALSE is returned. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL ApplyNewID( <br>    NPCTYPE npc, <br>    INT idNew, <br>    BOOL fAddLabel, <br>    LPTSTR pszSym) <br>{ <br>    if (fAddLabel) { <br>        /* <br>         * Go ahead and quietly add the label for them. <br>         */ <br>        if (AddLabel(pszSym, idNew, FPOS_MAX, 0, &amp;plInclude, <br>                &amp;plDelInclude, NULL, NULL)) { <br>            /* <br>             * Return the controls new id, update the status <br>             * windows symbol combo box, mark the fact that <br>             * we have changed the include file, and return <br>             * success. <br>             */ <br>            gfIncChged = TRUE; <br>            StatusFillSymbolList(plInclude); <br>        } <br>        else { <br>            /* <br>             * An error occurred on the AddLabel.  The most likely <br>             * cause of this is if they are trying to add a symbol <br>             * with a duplicate id. <br>             */ <br>            SetFocus(GetDlgItem(hwndStatus, DID_STATUSSYMID)); <br>            return FALSE; <br>        } <br>    } <br> <br>    /* <br>     * Return if the id wasn't changed. <br>     */ <br>    if (npc-&gt;id == idNew) <br>        return TRUE; <br> <br>    /* <br>     * Update the controls id and set the resource changed flag. <br>     */ <br>    npc-&gt;id = idNew; <br>    gfResChged = gfDlgChanged = TRUE; <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ApplyNewText <br>* <br>* Sets the new text from the processing of the OK command from <br>* the Status ribbon window.  If the text was changed, the selected <br>* control will have its text updated. <br>* <br>* Arguments: <br>*   NPCTYPE npc       = Pointer to the control. <br>*   LPTSTR pszNewText = The new text. <br>* <br>* Returns: <br>* <br>* TRUE if successful, FALSE otherwise. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL ApplyNewText( <br>    NPCTYPE npc, <br>    LPTSTR pszNewText) <br>{ <br>    INT cb; <br>    LPTSTR psz; <br> <br>    /* <br>     * Did the text change? <br>     */ <br>    if ((npc-&gt;text == NULL &amp;&amp; *pszNewText) || <br>            (npc-&gt;text != NULL &amp;&amp; NameOrdCmp(npc-&gt;text, pszNewText) != 0)) { <br>        if (*pszNewText) { <br>            cb = NameOrdLen(pszNewText); <br> <br>            if (npc-&gt;text == NULL) <br>                psz = MyAlloc(cb); <br>            else <br>                psz = MyRealloc(npc-&gt;text, cb); <br> <br>            if (psz == NULL) { <br>                return FALSE; <br>            } <br>            else { <br>                NameOrdCpy(psz, pszNewText); <br>                npc-&gt;text = psz; <br>            } <br>        } <br>        else { <br>            if (npc-&gt;text) { <br>                MyFree(npc-&gt;text); <br>                npc-&gt;text = NULL; <br>            } <br>        } <br> <br>        /* <br>         * Change the text of the control, except for W_ICON controls <br>         * because they have resource names.  In that case, we don't <br>         * want to change the text of the actual control because <br>         * the resource would probably not be found. <br>         */ <br>        if (npc-&gt;pwcd-&gt;iType != W_ICON) { <br>            SetWindowText(npc-&gt;hwnd, pszNewText); <br> <br>            /* <br>             * Redraw the control after the text changed.  This is <br>             * necessary because changing the text probably caused <br>             * the drag handles to get overwritten. <br>             */ <br>            if (npc-&gt;pwcd-&gt;iType == W_DIALOG) <br>                /* <br>                 * Redraw the frame, which just overwrote the drag <br>                 * handles when the text was changed. <br>                 */ <br>                SetWindowPos(npc-&gt;hwnd, NULL, 0, 0, 0, 0, <br>                        SWP_DRAWFRAME | SWP_NOACTIVATE | SWP_NOMOVE | <br>                        SWP_NOSIZE | SWP_NOZORDER); <br>            else <br>                /* <br>                 * Redraw the control(s). <br>                 */ <br>                RedrawSelection(); <br>        } <br> <br>        gfResChged = gfDlgChanged = TRUE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusFillSymbolList <br>* <br>* This function fills the Symbol and Name combo boxes with <br>* the given list of labels. <br>* <br>* Arguments: <br>*   NPLABEL plHead - pointer to the list of labels. <br>* <br>************************************************************************/ <br> <br>VOID StatusFillSymbolList( <br>    NPLABEL plHead) <br>{ <br>    NPLABEL npLabel; <br>    HWND hwndSymCB; <br>    HWND hwndNameCB; <br>    HCURSOR hcurSave; <br> <br>    hcurSave = SetCursor(hcurWait); <br> <br>    /* <br>     * Get the handles to the combo boxes and clear out all items. <br>     */ <br>    hwndSymCB = GetDlgItem(hwndStatus, DID_STATUSSYM); <br>    hwndNameCB = GetDlgItem(hwndStatus, DID_STATUSNAME); <br>    SendMessage(hwndSymCB, CB_RESETCONTENT, 0, 0L); <br>    SendMessage(hwndNameCB, CB_RESETCONTENT, 0, 0L); <br> <br>    /* <br>     * Fill the combo boxes with the items. <br>     */ <br>    for (npLabel = plHead; npLabel; npLabel = npLabel-&gt;npNext) { <br>        SendMessage(hwndSymCB, CB_ADDSTRING, 0, (DWORD)npLabel-&gt;pszLabel); <br>        SendMessage(hwndNameCB, CB_ADDSTRING, 0, (DWORD)npLabel-&gt;pszLabel); <br>    } <br> <br>    /* <br>     * Put some special entries into the symbol combo.  Note that we allow <br>     * the user to have defined IDOK and IDCANCEL to be something else, <br>     * in which case we will NOT add these special entries after all. <br>     */ <br>    SendMessage(hwndSymCB, CB_ADDSTRING, 0, (DWORD)ids(IDS_UNUSED)); <br> <br>    if (!FindLabel(ids(IDS_IDOK), plInclude)) <br>        SendMessage(hwndSymCB, CB_ADDSTRING, 0, (DWORD)ids(IDS_IDOK)); <br> <br>    if (!FindLabel(ids(IDS_IDCANCEL), plInclude)) <br>        SendMessage(hwndSymCB, CB_ADDSTRING, 0, (DWORD)ids(IDS_IDCANCEL)); <br> <br>    SetCursor(hcurSave); <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetCoords <br>* <br>* This function sets the coordinates in the status display <br>* to the given rectangle. <br>* <br>* Arguments: <br>*    PRECT prc - coordinates. <br>* <br>************************************************************************/ <br> <br>VOID StatusSetCoords( <br>    PRECT prc) <br>{ <br>    static INT xSave = 0x7FFF; <br>    static INT ySave = 0x7FFF; <br>    static INT cxSave = 0x7FFF; <br>    static INT cySave = 0x7FFF; <br>    static INT x2Save = 0x7FFF; <br>    static INT y2Save = 0x7FFF; <br>    TCHAR szBuf[CCHTEXTMAX]; <br> <br>    if (prc) { <br>        if (prc-&gt;bottom - prc-&gt;top != cySave) { <br>            /* <br>             *  Save it for the next time. <br>             */ <br>            cySave = prc-&gt;bottom - prc-&gt;top; <br> <br>            wsprintf(szBuf, ids(IDS_CYFMTSTR), cySave); <br>            SetDlgItemText(hwndStatus, DID_STATUSCY, szBuf); <br>        } <br> <br>        if (prc-&gt;right != x2Save || prc-&gt;bottom != y2Save) { <br>            /* <br>             *  Save them for the next time. <br>             */ <br>            x2Save = prc-&gt;right; <br>            y2Save = prc-&gt;bottom; <br> <br>            wsprintf(szBuf, L"(%d, %d)", x2Save, y2Save); <br>            SetDlgItemText(hwndStatus, DID_STATUSX2Y2, szBuf); <br>        } <br> <br>        if (prc-&gt;left != xSave || prc-&gt;top != ySave) { <br>            /* <br>             *  Save them for the next time. <br>             */ <br>            xSave = prc-&gt;left; <br>            ySave = prc-&gt;top; <br> <br>            wsprintf(szBuf, L"(%d, %d)", xSave, ySave); <br>            SetDlgItemText(hwndStatus, DID_STATUSXY, szBuf); <br>        } <br> <br>        if (prc-&gt;right - prc-&gt;left != cxSave) { <br>            /* <br>             *  Save it for the next time. <br>             */ <br>            cxSave = prc-&gt;right - prc-&gt;left; <br> <br>            wsprintf(szBuf, ids(IDS_CXFMTSTR), cxSave); <br>            SetDlgItemText(hwndStatus, DID_STATUSCX, szBuf); <br>        } <br>    } <br>    else { <br>        /* <br>         * Clear the fields. <br>         */ <br>        SetDlgItemText(hwndStatus, DID_STATUSXY, szEmpty); <br>        SetDlgItemText(hwndStatus, DID_STATUSX2Y2, szEmpty); <br>        SetDlgItemText(hwndStatus, DID_STATUSCX, szEmpty); <br>        SetDlgItemText(hwndStatus, DID_STATUSCY, szEmpty); <br> <br>        /* <br>         * Reset the cache variables so that the next "set" of <br>         * the coords is sure to update the display fields. <br>         */ <br>        xSave = <br>        ySave = <br>        cxSave = <br>        cySave = <br>        x2Save = <br>        y2Save = 0x7FFF; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetText <br>* <br>* This function sets the "Text" field in the status display <br>* to the given text. <br>* <br>* Arguments: <br>*   LPTSTR pszText - The text to display.  This can be NULL. <br>*   INT Type       - Type of control.  One of the W_* constants. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusSetText( <br>    LPTSTR pszText, <br>    INT Type) <br>{ <br>    /* <br>     * Protect against getting a null value. <br>     */ <br>    if (!pszText) <br>        pszText = szEmpty; <br> <br>    /* <br>     * If this is an icon control, set the name instead (the text <br>     * of an icon is really a resource name). <br>     */ <br>    if (Type == W_ICON) <br>        StatusSetName(pszText, Type); <br>    else <br>#ifdef JAPAN <br>    { <br>        TCHAR   szTmp[CCHTEXTMAX]; <br> <br>        KDExpandCopy(szTmp, pszText, CCHTEXTMAX); <br>        SetDlgItemText(hwndStatus, DID_STATUSTEXT, szTmp); <br>    } <br>#else <br>        SetDlgItemText(hwndStatus, DID_STATUSTEXT, pszText); <br>#endif <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetTextLabels <br>* <br>* This function sets the labels of the descriptive text fields in <br>* Status window based on the type of control that is selected. <br>* <br>* Arguments: <br>*   INT Type    - Type of control.  One of the W_* constants. <br>*   BOOL fIsOrd - TRUE if the name is an ordinal.  This is ignored <br>*                 unless Type is W_DIALOG or W_ICON. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusSetTextLabels( <br>    INT Type, <br>    BOOL fIsOrd) <br>{ <br>    WORD ids1; <br>    WORD ids2; <br> <br>    switch (Type) { <br>        case W_DIALOG: <br>            ids1 = (WORD)(fIsOrd ? IDS_DLGIDLABEL : IDS_DLGNAMELABEL); <br>            ids2 = IDS_CAPTIONLABEL; <br>            break; <br> <br>        case W_ICON: <br>            ids1 = IDS_SYMBOLLABEL; <br>            ids2 = (WORD)(fIsOrd ? IDS_ICONIDLABEL : IDS_ICONNAMELABEL); <br>            break; <br> <br>        default: <br>            ids1 = IDS_SYMBOLLABEL; <br>            ids2 = IDS_TEXTLABEL; <br>            break; <br>    } <br> <br>    SetDlgItemText(hwndStatus, DID_STATUSLABEL1, ids(ids1)); <br>    SetDlgItemText(hwndStatus, DID_STATUSLABEL2, ids(ids2)); <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetID <br>* <br>* Updates the id field of the given label. <br>* <br>* Arguments: <br>*     INT id        = The id. <br>*     BOOL fSymAlso = Find the corresponding label and update the <br>*                     symbol field also. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusSetID( <br>    INT id, <br>    BOOL fSymAlso) <br>{ <br>    TCHAR szValue[CCHIDMAX + 1]; <br>    NPLABEL npLabel; <br>    LPTSTR pszLabel; <br> <br>    Myitoa(id, szValue); <br>    SetDlgItemText(hwndStatus, DID_STATUSSYMID, szValue); <br> <br>    if (fSymAlso) { <br>        /* <br>         * If a matching label is found, the text is used. <br>         * Otherwise, if the id is zero, we use the "unused" <br>         * label.  Otherwise, we just use an empty string. <br>         */ <br>        if (npLabel = FindID(id, plInclude)) <br>            pszLabel = npLabel-&gt;pszLabel; <br>        else if (id == IDUNUSED) <br>            pszLabel = ids(IDS_UNUSED); <br>        else if (id == IDOK &amp;&amp; !FindLabel(ids(IDS_IDOK), plInclude)) <br>            pszLabel = ids(IDS_IDOK); <br>        else if (id == IDCANCEL &amp;&amp; !FindLabel(ids(IDS_IDCANCEL), plInclude)) <br>            pszLabel = ids(IDS_IDCANCEL); <br>        else <br>            pszLabel = szEmpty; <br> <br>        SetDlgItemText(hwndStatus, DID_STATUSSYM, pszLabel); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetName <br>* <br>* This function sets the "Res. Name" field in the status display <br>* to the given text. <br>* <br>* Arguments: <br>* <br>*   LPTSTR pszName - The name to display.  NULL values and ordinals <br>*                    are handled properly. <br>*   INT Type       - Type of control.  One of the W_* constants. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusSetName( <br>    LPTSTR pszName, <br>    INT Type) <br>{ <br>    NPLABEL npLabel; <br> <br>    /* <br>     * Protect against getting a null value. <br>     */ <br>    if (!pszName) <br>        pszName = szEmpty; <br> <br>    /* <br>     * Does the name represent an ordinal?  If so, set the nameid <br>     * field to the value and fill in the name field with the <br>     * associated symbol, if there is one. <br>     * <br>     * Note that this does NOT produce a hex value in Hex Mode for <br>     * dialog names, because rc.exe does not parse hex ordinals <br>     * for dialog names. <br>     */ <br>    if (IsOrd(pszName)) { <br>        StatusSetNameID(OrdID(pszName), Type); <br> <br>        if (npLabel = FindID(OrdID(pszName), plInclude)) <br>            pszName = npLabel-&gt;pszLabel; <br>        else <br>            pszName = szEmpty; <br>    } <br>    else { <br>        SetDlgItemText(hwndStatus, DID_STATUSNAMEID, szEmpty); <br>    } <br> <br>    SetDlgItemText(hwndStatus, DID_STATUSNAME, pszName); <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetNameID <br>* <br>* This function sets the id edit field associated with the <br>* "Res. Name" field in the status display <br>* <br>* Arguments: <br>* <br>*   INT id   - The id to set into the field. <br>*   INT Type - Type of control.  One of the W_* constants. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusSetNameID( <br>    INT id, <br>    INT Type) <br>{ <br>    TCHAR szValue[CCHIDMAX + 1]; <br> <br>    /* <br>     * If the current control is a dialog, do NOT produce a hex <br>     * value, even if the hex mode is on.  RC.Exe doesn't recognize <br>     * hex values for the dialog name as ordinals. <br>     */ <br>    if (Type == W_DIALOG) <br>        itoaw(id, szValue, 10); <br>    else <br>        Myitoa(id, szValue); <br> <br>    SetDlgItemText(hwndStatus, DID_STATUSNAMEID, szValue); <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusClearID <br>* <br>* Clears the id of the status window.. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusClearID(VOID) <br>{ <br>    SetDlgItemText(hwndStatus, DID_STATUSSYM, szEmpty); <br>    SetDlgItemText(hwndStatus, DID_STATUSSYMID, szEmpty); <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusClearName <br>* <br>* Clears the name of the status window. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusClearName(VOID) <br>{ <br>    SetDlgItemText(hwndStatus, DID_STATUSNAME, szEmpty); <br>    SetDlgItemText(hwndStatus, DID_STATUSNAMEID, szEmpty); <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusClear <br>* <br>* Clears the status window. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusClear(VOID) <br>{ <br>    StatusSetCoords(NULL); <br>    StatusSetText(NULL, W_NOTHING); <br>    StatusShowFields(W_NOTHING); <br>    StatusClearID(); <br>    StatusClearName(); <br>    gfStatusChanged = FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusUpdate <br>* <br>* Updates the status window to the current selection. <br>* <br>************************************************************************/ <br> <br>VOID StatusUpdate(VOID) <br>{ <br>    if (gnpcSel) { <br>        StatusSetCoords(&amp;gnpcSel-&gt;rc); <br>        StatusSetText(gnpcSel-&gt;text, gnpcSel-&gt;pwcd-&gt;iType); <br> <br>        if (gfDlgSelected) <br>            StatusSetName(gcd.pszDlgName, W_DIALOG); <br>        else <br>            StatusSetID(gnpcSel-&gt;id, TRUE); <br> <br>        StatusShowFields(gnpcSel-&gt;pwcd-&gt;iType); <br> <br>        gfStatusChanged = FALSE; <br>    } <br>    else { <br>        StatusClear(); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusShowFields <br>* <br>* This function shows and hides fields in the Status ribbon based on <br>* whether the dialog is currently selected or not.  This is necessary <br>* because dialogs have a name, whereas controls do not, and controls <br>* have an id that dialogs do not have, etc. <br>* <br>* It will also call StatusSetTextLabels to set the text for the <br>* descriptive labels in front of the fields. <br>* <br>* This function should be called whenever it is possible that the current <br>* selection has been changed. <br>* <br>* Arguments: <br>*   INT Type - Type of control that is selected (W_* constant). <br>* <br>************************************************************************/ <br> <br>STATICFN VOID StatusShowFields( <br>    INT Type) <br>{ <br>    /* <br>     * This static caches the type of the selected control. <br>     */ <br>    static INT TypeSave = W_NOTHING; <br> <br>    /* <br>     * We only have special cases for the dialog and for icon controls. <br>     * All other types are treated the same (we use W_CHECKBOX arbitrarily). <br>     * This prevents some repainting when switching between controls that <br>     * have the same layout of fields in the status window. <br>     */ <br>    if (Type != W_DIALOG &amp;&amp; Type != W_ICON) <br>        Type = W_CHECKBOX; <br> <br>    if (Type != TypeSave) { <br>        switch (Type) { <br>            case W_DIALOG: <br>                MoveWindow(GetDlgItem(hwndStatus, DID_STATUSNAME), <br>                        grcTopCombo.left, grcTopCombo.top, <br>                        grcTopCombo.right - grcTopCombo.left, <br>                        grcTopCombo.bottom - grcTopCombo.top, TRUE); <br>                MoveWindow(GetDlgItem(hwndStatus, DID_STATUSNAMEID), <br>                        grcTopEdit.left, grcTopEdit.top, <br>                        grcTopEdit.right - grcTopEdit.left, <br>                        grcTopEdit.bottom - grcTopEdit.top, TRUE); <br> <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSNAME), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSNAMEID), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSTEXT), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSSYM), SW_HIDE); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSSYMID), SW_HIDE); <br> <br>                StatusSetTextLabels(Type, IsOrd(gcd.pszDlgName)); <br> <br>                break; <br> <br>            case W_ICON: <br>                MoveWindow(GetDlgItem(hwndStatus, DID_STATUSNAME), <br>                        grcBottomCombo.left, grcBottomCombo.top, <br>                        grcBottomCombo.right - grcBottomCombo.left, <br>                        grcBottomCombo.bottom - grcBottomCombo.top, TRUE); <br>                MoveWindow(GetDlgItem(hwndStatus, DID_STATUSNAMEID), <br>                        grcBottomEdit.left, grcBottomEdit.top, <br>                        grcBottomEdit.right - grcBottomEdit.left, <br>                        grcBottomEdit.bottom - grcBottomEdit.top, TRUE); <br> <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSNAME), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSNAMEID), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSTEXT), SW_HIDE); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSSYM), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSSYMID), SW_SHOW); <br> <br>                StatusSetTextLabels(Type, <br>                        gnpcSel-&gt;text ? IsOrd(gnpcSel-&gt;text) : FALSE); <br> <br>                break; <br> <br>            default: <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSTEXT), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSSYM), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSSYMID), SW_SHOW); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSNAME), SW_HIDE); <br>                ShowWindow(GetDlgItem(hwndStatus, DID_STATUSNAMEID), SW_HIDE); <br> <br>                StatusSetTextLabels(Type, FALSE); <br> <br>                break; <br>        } <br> <br>        TypeSave = Type; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* StatusSetEnable <br>* <br>* This routine sets the enable state of the editable controls in the <br>* status window based on various state globals. <br>* <br>* The controls will be disabled on the following conditions: <br>* <br>*   1. Nothing is selected. <br>*   2. We are in Test mode. <br>*   3. One of the editors own dialogs is up (gfDisabled == TRUE). <br>* <br>* In addition, some controls will always be disabled if in Translate <br>* mode, and the text field will be disabled if this control cannot <br>* have text. <br>* <br>************************************************************************/ <br> <br>VOID StatusSetEnable(VOID) <br>{ <br>    BOOL fEnableText = TRUE; <br>    BOOL fEnableSym = TRUE; <br>    BOOL fEnableName = TRUE; <br> <br>    if (!gnpcSel || gfTestMode || gfDisabled) <br>        fEnableText = fEnableSym = fEnableName = FALSE; <br> <br>    /* <br>     * Disable the text field if this control cannot have text. <br>     */ <br>    if (gnpcSel &amp;&amp; !gnpcSel-&gt;pwcd-&gt;fHasText) <br>        fEnableText = FALSE; <br> <br>    /* <br>     * If the dialog is selected and the style does not include <br>     * a caption, disable the text field. <br>     */ <br>    if (gfDlgSelected &amp;&amp; (gnpcSel-&gt;flStyle &amp; WS_CAPTION) != WS_CAPTION) <br>        fEnableText = FALSE; <br> <br>    /* <br>     * Always disable the symbol and name fields if Translating. <br>     */ <br>    if (gfTranslateMode) <br>        fEnableSym = fEnableName = FALSE; <br> <br>    EnableWindow(GetDlgItem(hwndStatus, DID_STATUSTEXT), fEnableText); <br> <br>    EnableWindow(GetDlgItem(hwndStatus, DID_STATUSSYM), fEnableSym); <br>    EnableWindow(GetDlgItem(hwndStatus, DID_STATUSSYMID), fEnableSym); <br> <br>    EnableWindow(GetDlgItem(hwndStatus, DID_STATUSNAME), fEnableName); <br>    EnableWindow(GetDlgItem(hwndStatus, DID_STATUSNAMEID), fEnableName); <br>} <br>#ifdef JAPAN <br>/************************************************************************ <br>* Copy strings to the buffer. text strings "\036" and "\037" are expanded to <br>* Codes \036 and \037 respectively. <br>************************************************************************/ <br> <br>VOID KKExpandCopy(LPTSTR pszDest, LPTSTR pszSrc, WORD wLimit) <br>{ <br>    int  i; <br>    LPTSTR p = pszSrc; <br>#if defined(DBCS) &amp;&amp; !defined(UNICODE) <br>#define wcsncmp     strncmp <br>#endif <br> <br>    wLimit--; <br>    for (i = 0; i &lt; wLimit &amp;&amp; p &amp;&amp; *p; i++) { <br>        if (*p == TEXT('\\')) { <br>            if(!wcsncmp(p+1, TEXT("036"), 3)) { <br>                pszDest[i] = 036; <br>                p+=4; <br>                continue; <br>            } <br>            else if(!wcsncmp(p+1, TEXT("037"), 3)) { <br>                pszDest[i] = 037; <br>                p+=4; <br>                continue; <br>           } <br>        } <br>        pszDest[i] = *p; <br>        if (IsDBCSLeadByte((BYTE)*p)) { <br>            if (i == wLimit - 1) { <br>                break; <br>            } <br>            pszDest[++i] = *(p+1); <br>        } <br>        p = CharNext(p); <br>    } <br>    pszDest[i] = '\0'; <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
