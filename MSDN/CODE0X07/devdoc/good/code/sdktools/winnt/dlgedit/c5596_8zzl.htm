<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLGEDIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5601"></a>DLGEDIT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: dlgedit.c <br>* <br>* Main function and window procedure for the Dialog Box Editor. <br>* <br>* Functions: <br>* <br>*   MainWndProc() <br>*   ReadWindowPos() <br>*   WriteWindowPos() <br>*   InitApplication() <br>*   InitInstance() <br>*   PenWinRegister() <br>*   GetSystemValues() <br>*   ReadEnv() <br>*   WriteEnv() <br>*   LoadSysColorBitmaps() <br>*   LoadAlterBitmap() <br>*   RGBInvertRGB() <br>*   SizeRibbons() <br>*   DialogTerminate() <br>* <br>* Comments: <br>* <br>* Because of the need for a dialog in both work and test mode to be <br>* shown relative to the client area of its parent, and because the <br>* editor has a ribbon control along the top of its client area, there <br>* needed to be another window created that will be the actual parent <br>* of the dialog being edited.  This window, called the ghwndSubClient <br>* window, is sized to be the size of the editors client area minus <br>* the height of the ribbon window at the top.  This makes it so that <br>* a dialog that has an origin of 0,0 will have the top edge of its <br>* client area just below the bottom of the ribbon window in the <br>* editor.  This window does not need any special processing.  It simply <br>* paints its background with the app workspace color, and is used as <br>* the basis for coordinate conversion for the dialog. <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br> <br>#include &lt;commdlg.h&gt; <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#if defined(DBCS) &amp;&amp; !defined(UNICODE) <br>#define _MBCS <br>#include &lt;mbstring.h&gt; <br>#define strtok      _mbstok <br>#endif <br> <br>STATICFN BOOL InitApplication(HANDLE hInstance); <br>STATICFN BOOL InitInstance(HANDLE hInstance, INT nCmdShow); <br>STATICFN VOID PenWinRegister(VOID); <br>STATICFN VOID GetSystemValues(VOID); <br>STATICFN VOID ReadEnv(VOID); <br>STATICFN VOID WriteEnv(VOID); <br>STATICFN VOID LoadSysColorBitmaps(VOID); <br>STATICFN HBITMAP LoadAlterBitmap(INT idbm, DWORD rgbNew, DWORD rgbNew2); <br>STATICFN DWORD RGBInvertRGB(DWORD rgb); <br>STATICFN VOID SizeRibbons(HWND hwnd); <br>STATICFN VOID DialogTerminate(VOID); <br> <br>static RECT grcAppPos;              // Saves the app's window pos. <br>static UINT gmsgHelp;               // Registered help message from commdlg. <br>static BOOL fStartAsIcon = FALSE;   // TRUE if app is started minimized. <br> <br>/* <br> * Contains the address of the Pen Windows callback. <br> */ <br>typedef VOID ( APIENTRY *LPFNPENWIN)(WORD, BOOL); <br>static LPFNPENWIN lpfnRegisterPenApp; <br> <br> <br> <br>/************************************************************************ <br>* WinMain <br>* <br>* This is the main function for the dialog editor. <br>* <br>************************************************************************/ <br> <br>INT WINAPI WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    INT nCmdShow) <br>{ <br>    MSG msg; <br> <br>    if (!hPrevInstance) { <br>        if (!InitApplication(hInstance)) { <br>            Message(MSG_NOINIT); <br>            return FALSE; <br>        } <br>    } <br> <br>    if (!InitInstance(hInstance, nCmdShow)) { <br>        Message(MSG_NOINIT); <br>        return FALSE; <br>    } <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if (!ghwndTestDlg || !IsDialogMessage(ghwndTestDlg, &amp;msg)) { <br>            if (!hwndStatus || !IsDialogMessage(hwndStatus, &amp;msg)) { <br>                if (!TranslateAccelerator(ghwndMain, ghAccTable, &amp;msg)) { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>            } <br>        } <br>    } <br> <br>    DialogTerminate(); <br> <br>    /* <br>     * Return the value from PostQuitMessage. <br>     */ <br>    return msg.wParam; <br>} <br> <br> <br> <br>/************************************************************************ <br>* InitApplication <br>* <br>* Registers the window classes. <br>* <br>* Arguments: <br>*   HANDLE hInstance - Instance handle from WinMain. <br>* <br>* Returns: <br>*   TRUE if all of the window classes were created; otherwise, FALSE. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL InitApplication( <br>    HANDLE hInstance) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style = CS_DBLCLKS; <br>    wc.lpfnWndProc = MainWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = sizeof(DWORD); <br>    wc.hInstance = hInstance; <br>    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDICON_DLGEDIT)); <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wc.lpszMenuName = MAKEINTRESOURCE(IDMENU_MAIN); <br>    wc.lpszClassName = szMainClass; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = DefWindowProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = NULL; <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName = szSubClientClass; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style = CS_DBLCLKS; <br>    wc.lpfnWndProc = DragWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = sizeof(DWORD); <br>    wc.hInstance = hInstance; <br>    wc.hIcon = NULL; <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName = szDragClass; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = ToolboxWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = NULL; <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName = szToolboxClass; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style = 0; <br>    wc.lpfnWndProc = ToolBtnWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = NULL; <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName = szToolBtnClass; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    wc.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc = CustomWndProc; <br>    wc.cbClsExtra = 0; <br>    wc.cbWndExtra = 0; <br>    wc.hInstance = hInstance; <br>    wc.hIcon = NULL; <br>    wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.lpszMenuName = NULL; <br>    wc.lpszClassName = szCustomClass; <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* InitInstance <br>* <br>* Initializes the dialog editor by loading resources, etc. <br>* <br>* Arguments: <br>*   HANDLE hInstance - Instance handle from WinMain. <br>*   int nCmdShow     - Show command from WinMain. <br>* <br>* Returns: <br>*   FALSE if any errors occurred during initialization <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL InitInstance( <br>    HANDLE hInstance, <br>    INT nCmdShow) <br>{ <br>    HDC hDC; <br>    TEXTMETRIC tm; <br>    INT x; <br>    INT y; <br>    INT cx; <br>    INT cy; <br>    BOOL fMaximized; <br>    INT i; <br>    TCHAR szArg1[CCHTEXTMAX]; <br> <br>    ghInst = hInstance; <br> <br>    /* <br>     * We need a mouse - make sure we have one. <br>     */ <br>    if (!GetSystemMetrics(SM_MOUSEPRESENT)) { <br>        Message(MSG_NOMOUSE); <br>        return FALSE; <br>    } <br> <br>    /* <br>     * Register for Pen Windows, if it is present. <br>     */ <br>    PenWinRegister(); <br> <br>    ghAccTable = LoadAccelerators(ghInst, MAKEINTRESOURCE(IDACCEL_MAIN)); <br> <br>    /* <br>     * Create a dark gray pen for use in borders later. <br>     */ <br>    if (!(hpenDarkGray = CreatePen(PS_SOLID, 1, DARKGRAY))) <br>        return FALSE; <br> <br>    /* <br>     * Get some system constants. <br>     */ <br>    GetSystemValues(); <br> <br>    /* <br>     * Note that this must be done instead of using the text metrics, <br>     * because Windows internally generates a better average value for <br>     * proportional fonts, and we must match it or our dialogs will <br>     * be out of proportion. <br>     */ <br>    gcxSysChar = LOWORD(GetDialogBaseUnits()); <br>    gcySysChar = HIWORD(GetDialogBaseUnits()); <br> <br>    /* <br>     * Because some useful worker routines like WinToDUPoint use <br>     * the values in gcd.c*Char, set them to be the default font right <br>     * away.  When a dialog is loaded with a different font, they <br>     * will be modified. <br>     */ <br>    gcd.cxChar = gcxSysChar; <br>    gcd.cyChar = gcySysChar; <br> <br>    /* <br>     * Build the help file name path.  Assume the help file is in the <br>     * same directory as the executable. <br>     */ <br>    GetModuleFileName(ghInst, gszHelpFile, CCHMAXPATH); <br>    *FileInPath(gszHelpFile) = CHAR_NULL; <br>    lstrcat(gszHelpFile, ids(IDS_HELPFILE)); <br> <br>    /* <br>     * Register the message for help from the common dialogs. <br>     */ <br>    gmsgHelp = RegisterWindowMessage(HELPMSGSTRING); <br> <br>    /* <br>     * Hook the message filter stream so that we can detect F1 keystrokes. <br>     */ <br>    ghhkMsgFilter = SetWindowsHook(WH_MSGFILTER, (HOOKPROC)MsgFilterHookFunc); <br> <br>    /* <br>     * Read the last position for the app. <br>     */ <br>    if (!ReadWindowPos(szAppPos, &amp;x, &amp;y, &amp;cx, &amp;cy, &amp;fMaximized)) { <br>        x = CW_USEDEFAULT; <br>        y = CW_USEDEFAULT; <br>        cx = CW_USEDEFAULT; <br>        cy = CW_USEDEFAULT; <br>        fMaximized = FALSE; <br>    } <br> <br>    /* <br>     * Create the main window. <br>     */ <br>    if (!(ghwndMain = CreateWindow(szMainClass, NULL, <br>            WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>            x, y, cx, cy, NULL, NULL, hInstance, NULL))) <br>        return FALSE; <br> <br>    ShowFileStatus(TRUE); <br> <br>    /* <br>     * Read the Preferences data. <br>     */ <br>    ReadEnv(); <br> <br>    /* <br>     * If the app was saved when maximized (and they didn't start it up <br>     * with some kind of an option to have it minimized or in some <br>     * other funny initial state from the shell), then cause it to <br>     * be maximized when shown. <br>     */ <br>    if (fMaximized &amp;&amp; (nCmdShow == SW_SHOWNORMAL || nCmdShow == SW_SHOW)) <br>        nCmdShow = SW_SHOWMAXIMIZED; <br> <br>    ShowWindow(ghwndMain, nCmdShow); <br>    UpdateWindow(ghwndMain); <br> <br>    /* <br>     * Did the user start this app minimized from the program manager? <br>     */ <br>    if (IsIconic(ghwndMain)) { <br>        /* <br>         * Set a flag.  The showing of the toolbox will be deferred <br>         * until the app is restored. <br>         */ <br>        fStartAsIcon = TRUE; <br>    } <br>    else { <br>        /* <br>         * If they had the Toolbox before, show it now. <br>         */ <br>        if (gfShowToolbox) <br>            ToolboxShow(TRUE); <br>    } <br> <br>    hcurArrow = LoadCursor(NULL, IDC_ARROW); <br>    hcurWait = LoadCursor(NULL, IDC_WAIT); <br>    hcurOutSel = LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_OUTSEL)); <br>    hcurMove = LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_MOVE)); <br>    hcurInsert = LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_INSERT)); <br>    hcurDropTool = LoadCursor(ghInst, MAKEINTRESOURCE(IDCUR_DROPTOOL)); <br>    hcurSizeNESW = LoadCursor(NULL, IDC_SIZENESW); <br>    hcurSizeNS = LoadCursor(NULL, IDC_SIZENS); <br>    hcurSizeNWSE = LoadCursor(NULL, IDC_SIZENWSE); <br>    hcurSizeWE = LoadCursor(NULL, IDC_SIZEWE); <br> <br>    if (!hcurArrow || <br>            !hcurWait || <br>            !hcurOutSel || <br>            !hcurMove || <br>            !hcurDropTool || <br>            !hcurInsert) <br>        return FALSE; <br> <br>    if ((hDC = GetDC(ghwndMain)) == NULL) <br>        return FALSE; <br> <br>    GetTextMetrics(hDC, &amp;tm); <br> <br>    gcyPixelsPerInch = GetDeviceCaps(hDC, LOGPIXELSY); <br> <br>    /* <br>     * Create a memory DC for drawing bitmaps. <br>     */ <br>    ghDCMem = CreateCompatibleDC(hDC); <br> <br>    ReleaseDC(ghwndMain, hDC); <br> <br>    /* <br>     * Load the bitmaps that depend on system colors. <br>     */ <br>    LoadSysColorBitmaps(); <br> <br>    fmtDlg = RegisterClipboardFormat(L"DIALOG"); <br> <br>    /* <br>     * Initialize the icon control ordinal to the icon id from our exe <br>     * that we will use to show these kind of controls. <br>     */ <br>    WriteOrd(&amp;gordIcon, IDICON_ICON); <br> <br>    /* <br>     * Initialize the default text fields in the awcd array.  Because <br>     * CCONTROLS does not include the dialog type, it has to be done <br>     * separately. <br>     */ <br>    awcd[W_DIALOG].pszTextDefault = ids(awcd[W_DIALOG].idsTextDefault); <br>    for (i = 0; i &lt; CCONTROLS; i++) <br>        awcd[i].pszTextDefault = ids(awcd[i].idsTextDefault); <br> <br>    /* <br>     * If there was a command line argument specified, try and open <br>     * it as the initial file. <br>     */ <br>    if (__argc &gt; 1) { <br>        MultiByteToWideChar(CP_ACP, 0, __argv[1], -1, szArg1, CCHTEXTMAX); <br>        OpenCmdLineFile(szArg1); <br>    } <br> <br>    /* <br>     * Be sure the focus is on the main window.  This corrects a <br>     * problem where the accelerators don't initially work because <br>     * the focus gets placed on the Properties Bar. <br>     */ <br>    SetFocus(ghwndMain); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* PenWinRegister <br>* <br>* This function will register for Pen Windows, if it is present. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID PenWinRegister(VOID) <br>{ <br>    HANDLE hmod; <br> <br>    if (!(hmod = (HANDLE)GetSystemMetrics(SM_PENWINDOWS))) <br>        return; <br> <br>    if (lpfnRegisterPenApp = <br>            (LPFNPENWIN)GetProcAddress(hmod, "RegisterPenApp")) <br>        (*lpfnRegisterPenApp)(1, TRUE);     // Be Pen-Enhanced! <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetSystemValues <br>* <br>* This function reads various system values.  It is called at init time, <br>* as well as if we are informed by a WM_SYSVALUECHANGED message that <br>* some of these values have been changed. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID GetSystemValues(VOID) <br>{ <br>    gcyBorder = GetSystemMetrics(SM_CYBORDER); <br> <br>    /* <br>     * The distance that the mouse can move during a pre-drag operation <br>     * before starting to drag the control anyways is based on the <br>     * mouse double-click movement distances in the system. <br>     */ <br>    gcxPreDragMax = GetSystemMetrics(SM_CXDOUBLECLK); <br>    gcyPreDragMax = GetSystemMetrics(SM_CYDOUBLECLK); <br> <br>    /* <br>     * The number of milliseconds that the pre-drag debounce time lasts. <br>     */ <br>    gmsecPreDrag = 250; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ReadWindowPos <br>* <br>* This function retrieves the saved window position for a window and <br>* returns it in the specified variables.  It is used between sessions <br>* to restore the application windows to the position they had when <br>* the editor was last exited. <br>* <br>* Arguments: <br>*   LPTSTR pszKeyName  - KeyName the position was saved under. <br>*   PINT px            - Saved x position. <br>*   PINT py            - Saved y position. <br>*   PINT pcx           - Saved width. <br>*   PINT pcy           - Saved height. <br>*   BOOL *pfMaximized  - Set to TRUE if window was maximized when saved. <br>* <br>* Returns:  <br>*   TRUE if the position could be read, or FALSE otherwise. <br>*   If FALSE is returned, the values in the specified variables are <br>*   not valid!  The caller must be able to handle a FALSE return and <br>*   supply a default position for the window. <br>* <br>************************************************************************/ <br> <br>BOOL ReadWindowPos( <br>    LPTSTR pszKeyName, <br>    PINT px, <br>    PINT py, <br>    PINT pcx, <br>    PINT pcy, <br>    BOOL *pfMaximized) <br>{ <br>    static CHAR szSep[] = " ,"; <br>    TCHAR szBuf[CCHTEXTMAX]; <br>    CHAR szBufAnsi[CCHTEXTMAX]; <br>    PSTR psz; <br>    BOOL fDefCharUsed; <br> <br>    if (!GetPrivateProfileString(ids(IDS_APPNAME), <br>            pszKeyName, szEmpty, szBuf, CCHTEXTMAX, ids(IDS_DLGEDITINI))) <br>        return FALSE; <br> <br>    WideCharToMultiByte(CP_ACP, 0, szBuf, -1, szBufAnsi, CCHTEXTMAX, <br>            NULL, &amp;fDefCharUsed); <br> <br>    if (!(psz = strtok(szBufAnsi, szSep))) <br>        return FALSE; <br> <br>    *px = atoi(psz); <br> <br>    if (!(psz = strtok(NULL, szSep))) <br>        return FALSE; <br> <br>    *py = atoi(psz); <br> <br>    if (!(psz = strtok(NULL, szSep))) <br>        return FALSE; <br> <br>    *pcx = atoi(psz); <br> <br>    if (!(psz = strtok(NULL, szSep))) <br>        return FALSE; <br> <br>    *pcy = atoi(psz); <br> <br>    /* <br>     * If there is a "1" following the coordinates, the window was <br>     * maximized when it was saved. <br>     */ <br>    *pfMaximized = FALSE; <br>    if ((psz = strtok(NULL, szSep)) &amp;&amp; atoi(psz) == 1) <br>        *pfMaximized = TRUE; <br> <br>    /* <br>     * Don't allow a zero sized window. <br>     */ <br>    if (*pcx == 0 || *pcy == 0) <br>        return FALSE; <br> <br>    /* <br>     * Return success. <br>     */ <br>    return TRUE; <br> <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteWindowPos <br>* <br>* This function writes the position of a window to the <br>* editor's profile file under the specified keyname. <br>* The ReadWindowPos function is the counterpart of this <br>* function. <br>* <br>* Arguments: <br>*   PRECT prc          - Rectangle for the "restored" window size. <br>*   BOOL fMaximized    - TRUE if the window is maximized. <br>*   LPTSTR pszKeyName  - KeyName to save the position under. <br>* <br>************************************************************************/ <br> <br>VOID WriteWindowPos( <br>    PRECT prc, <br>    BOOL fMaximized, <br>    LPTSTR pszKeyName) <br>{ <br>    TCHAR szBuf[CCHTEXTMAX]; <br> <br>    wsprintf(szBuf, L"%d %d %d %d", prc-&gt;left, prc-&gt;top, <br>            prc-&gt;right - prc-&gt;left, prc-&gt;bottom - prc-&gt;top); <br> <br>    if (fMaximized) <br>        lstrcat(szBuf, L" 1"); <br> <br>    WritePrivateProfileString(ids(IDS_APPNAME), <br>            pszKeyName, szBuf, ids(IDS_DLGEDITINI)); <br>} <br> <br> <br> <br>/************************************************************************* <br>* ReadEnv <br>* <br>* This function initializes variables from their counterparts <br>* in the private profile file for DlgEdit.  The application <br>* merely needs to construct an array of INIENTRY structures <br>* to describe the variables that must be initialized. <br>* <br>* Note that the original value read from the profile is saved when <br>* it is read.  This allows us to optimize what needs to be written <br>* out with WriteEnv. <br>* <br>*************************************************************************/ <br> <br>STATICFN VOID ReadEnv(VOID) <br>{ <br>    register INT i; <br> <br>    for (i = 0; gaie[i].pszKeyName; i++) { <br>        *gaie[i].pnVar = gaie[i].nSave = <br>                GetPrivateProfileInt(ids(IDS_APPNAME), <br>                gaie[i].pszKeyName, gaie[i].nDefault, <br>                ids(IDS_DLGEDITINI)); <br>    } <br> <br>    ReadCustomProfile(); <br>} <br> <br> <br> <br>/************************************************************************* <br>* WriteEnv <br>* <br>* This function is the counterpart to ReadEnv.  It saves values <br>* in the profile file. <br>* <br>*************************************************************************/ <br> <br>STATICFN VOID WriteEnv(VOID) <br>{ <br>    register INT i; <br>    TCHAR szBuf[17]; <br> <br>    for (i = 0; gaie[i].pszKeyName; i++) { <br>        /* <br>         * Has the user changed the value since it was read? <br>         */ <br>        if (gaie[i].nSave != *gaie[i].pnVar) { <br>            /* <br>             * If the new value is the same as the default value, <br>             * erase the entry from the ini file.  Otherwise, <br>             * write the user-specified value out. <br>             */ <br>            if (*gaie[i].pnVar == gaie[i].nDefault) { <br>                WritePrivateProfileString(ids(IDS_APPNAME), <br>                        gaie[i].pszKeyName, NULL, ids(IDS_DLGEDITINI)); <br>            } <br>            else { <br>                itoaw(*gaie[i].pnVar, szBuf, 10); <br>                WritePrivateProfileString(ids(IDS_APPNAME), <br>                        gaie[i].pszKeyName, szBuf, ids(IDS_DLGEDITINI)); <br>            } <br>        } <br>    } <br> <br>    WriteCustomProfile(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* MainWndProc <br>* <br>* This is the window procedure for the "dlgedit" class.  This is the <br>* class of the main dialog editor "client" window. <br>* <br>************************************************************************/ <br> <br>WINDOWPROC MainWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_CREATE: <br>            { <br>                RECT rc; <br> <br>                /* <br>                 * Create the status window. <br>                 */ <br>                CreateDialog(ghInst, MAKEINTRESOURCE(DID_STATUS), <br>                        hwnd, StatusDlgProc); <br> <br>                /* <br>                 * Save away its height for sizing later (like when <br>                 * the app is minimized then restored). <br>                 */ <br>                GetWindowRect(hwndStatus, &amp;rc); <br>                gcyStatus = rc.bottom - rc.top; <br> <br>                ghwndSubClient = CreateWindow(szSubClientClass, NULL, <br>                        WS_CHILD | WS_VISIBLE, 0, 0, 0, 0, <br>                        hwnd, NULL, ghInst, NULL); <br> <br>                ghMenuMain = GetMenu(hwnd); <br>                LoadMenuBitmaps(ghMenuMain); <br>            } <br> <br>            break; <br> <br>        case WM_ACTIVATE: <br>            /* <br>             * If the main window is getting activated, there is no <br>             * currently active dialog. <br>             */ <br>            if (LOWORD(wParam)) <br>                gidCurrentDlg = 0; <br> <br>            goto DoDefault; <br> <br>        case WM_INITMENU: <br>            if (GetMenu(ghwndMain) == (HMENU)wParam) <br>                InitMenu((HMENU)wParam); <br> <br>            break; <br> <br>        case WM_MENUSELECT: <br>            if (HIWORD(wParam) &amp; <br>                    (MF_POPUP | MF_SYSMENU)) <br>                gMenuSelected = 0; <br>            else <br>                gMenuSelected = LOWORD(wParam); <br> <br>            break; <br> <br>        case WM_COMMAND: <br>            DialogMenu(LOWORD(wParam)); <br>            break; <br> <br>        case WM_KEYDOWN: <br>            switch (wParam) { <br>                case VK_UP: <br>                case VK_DOWN: <br>                case VK_LEFT: <br>                case VK_RIGHT: <br>                    if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                            (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                        break; <br> <br>                    /* <br>                     * Ignore it if we are not in a normal state <br>                     * (don't allow when dragging). <br>                     */ <br>                    if (gState != STATE_NORMAL) <br>                        break; <br> <br>                    /* <br>                     * Be sure any outstanding changes get applied <br>                     * without errors. <br>                     */ <br>                    if (!StatusApplyChanges()) <br>                        break; <br> <br>                    /* <br>                     * Move the control in the specified direction. <br>                     */ <br>                    MoveControl(wParam); <br>                    break; <br> <br>                case VK_TAB: <br>                    if (GetKeyState(VK_CONTROL) &amp; 0x8000) <br>                        break; <br> <br>                    /* <br>                     * Ignore it if we are not in a normal state <br>                     * (don't allow when dragging). <br>                     */ <br>                    if (gState != STATE_NORMAL) <br>                        break; <br> <br>                    /* <br>                     * Be sure any outstanding changes get applied <br>                     * without errors. <br>                     */ <br>                    if (!StatusApplyChanges()) <br>                        break; <br> <br>                    /* <br>                     * Is the shift key pressed also? <br>                     */ <br>                    if (GetKeyState(VK_SHIFT) &amp; 0x8000) <br>                        SelectPrevious(); <br>                    else <br>                        SelectNext(); <br> <br>                    break; <br> <br>                case VK_ESCAPE: <br>                    if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                            (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                        break; <br> <br>                    /* <br>                     * Be sure any outstanding changes get applied <br>                     * without errors. <br>                     */ <br>                    if (!StatusApplyChanges()) <br>                        break; <br> <br>                    if (gState == STATE_SELECTING) <br>                        OutlineSelectCancel(); <br> <br>                    /* <br>                     * Cancel any drag operation they might have been doing. <br>                     */ <br>                    if (gState != STATE_NORMAL) <br>                        DragCancel(); <br> <br>                    break; <br> <br>                case VK_RETURN: <br>                    if ((GetKeyState(VK_SHIFT) &amp; 0x8000) || <br>                            (GetKeyState(VK_CONTROL) &amp; 0x8000)) <br>                        break; <br> <br>                    /* <br>                     * Be sure any outstanding changes get applied <br>                     * without errors. <br>                     */ <br>                    if (!StatusApplyChanges()) <br>                        break; <br> <br>                    switch (gState) { <br>                        POINTS mpt; <br>                        POINT pt; <br>                        DWORD dwPos; <br> <br>                        case STATE_SELECTING: <br>                            /* <br>                             * In outline selection mode.  Map the <br>                             * location of the mouse at the time that <br>                             * the user pressed Enter into a point <br>                             * relative to the dialog client and complete <br>                             * the selection operation. <br>                             */ <br>                            dwPos = GetMessagePos(); <br>                            mpt = (*((POINTS *)&amp;(dwPos))); <br>                            ((pt).x = (mpt).x, (pt).y = (mpt).y); <br>                            ScreenToClient(gcd.npc-&gt;hwnd, &amp;pt); <br>                            OutlineSelectEnd(pt.x, pt.y); <br> <br>                            break; <br> <br>                        case STATE_DRAGGING: <br>                        case STATE_DRAGGINGNEW: <br>                            /* <br>                             * We are dragging something.  Map the <br>                             * location of the mouse at the time <br>                             * that the user pressed Enter into a <br>                             * point relative to the proper window <br>                             * and complete the drag operation. <br>                             */ <br>                            dwPos = GetMessagePos(); <br>                            mpt = (*((POINTS *)&amp;(dwPos))); <br>                            ((pt).x = (mpt).x, (pt).y = (mpt).y); <br> <br>                            /* <br>                             * The point must be changed to be relative to <br>                             * the window that the ending mouse up message <br>                             * would have come through, which will be the <br>                             * capture window for the drag.  This will be <br>                             * the dialog if we are adding a new control, <br>                             * or it will be the selected control if we are <br>                             * dragging an existing control. <br>                             */ <br>                            ScreenToClient((gState == STATE_DRAGGING) ? <br>                                    gnpcSel-&gt;hwnd : gcd.npc-&gt;hwnd, &amp;pt); <br> <br>                            /* <br>                             * If the dialog is selected, map the points from <br>                             * the client area to the window. <br>                             */ <br>                            if (gfDlgSelected) <br>                                MapDlgClientPoint(&amp;pt, TRUE); <br> <br>                            DragEnd(pt.x, pt.y); <br> <br>                            break; <br>                    } <br> <br>                    break; <br>            } <br> <br>            break; <br> <br>        case WM_NCCALCSIZE: <br>            /* <br>             * Save away what is going to be the new window position. <br>             */ <br>            if (!IsIconic(hwnd) &amp;&amp; !IsZoomed(hwnd)) <br>                grcAppPos = *((LPRECT)lParam); <br> <br>            /* <br>             * Now let the DefWindowProc calculate the client area normally. <br>             */ <br>            goto DoDefault; <br> <br>        case WM_MOVE: <br>            if (gfEditingDlg) <br>                RepositionDialog(); <br> <br>            break; <br> <br>        case WM_SIZE: <br>            SizeRibbons(hwnd); <br> <br>            /* <br>             * Did the app start minimized and is it being restored <br>             * for the first time?  If so, show the toolbox if <br>             * the user has requested it. <br>             */ </code></pre>
<p>
</p>
<pre><code>if (fStartAsIcon &amp;&amp; !IsIconic(hwnd)) { <br>                if (gfShowToolbox) <br>                    ToolboxShow(TRUE); <br> <br>                fStartAsIcon = FALSE; <br>            } <br> <br>            break; <br> <br>        case WM_SYSCOLORCHANGE: <br>            LoadSysColorBitmaps(); <br>            break; <br> <br>        case WM_CLOSE: <br>            if (ghwndTestDlg) <br>                DestroyTestDialog(); <br> <br>            if (DoWeSave(FILE_INCLUDE) == IDCANCEL || <br>                    DoWeSave(FILE_RESOURCE) == IDCANCEL) <br>                break; <br> <br>            /* <br>             * First destroy the Properties Bar. <br>             */ <br>            DestroyWindow(hwndStatus); <br>            hwndStatus = NULL; <br> <br>            DestroyWindow(hwnd); <br>            break; <br> <br>        case WM_QUERYENDSESSION: <br>            if (ghwndTestDlg) <br>                DestroyTestDialog(); <br> <br>            if (DoWeSave(FILE_INCLUDE) == IDCANCEL || <br>                    DoWeSave(FILE_RESOURCE) == IDCANCEL) <br>                return FALSE; <br>            else <br>                return TRUE; <br> <br>        case WM_DESTROY: <br>            /* <br>             * Save the position of the app's window. <br>             */ <br>            WriteWindowPos(&amp;grcAppPos, IsZoomed(hwnd), szAppPos); <br> <br>            WinHelp(hwnd, gszHelpFile, HELP_QUIT, 0L); <br>            FreeMenuBitmaps(); <br>            PostQuitMessage(0); <br>            break; <br> <br>        default: <br>            /* <br>             * Is this the registered help message from one of the common <br>             * dialogs?  If so, show the help for it. <br>             * <br>             * The check to be sure gmsgHelp is non-zero is just in <br>             * case the call to register the help message failed <br>             * (it will return zero) and there happens to be a zero <br>             * message that gets sent to this window somehow. <br>             */ <br>            if (msg == gmsgHelp &amp;&amp; gmsgHelp) { <br>                ShowHelp(FALSE); <br>                return 0; <br>            } <br> <br>        DoDefault: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} <br> <br> <br> <br>/************************************************************************ <br>* LoadSysColorBitmaps <br>* <br>* This function loads bitmaps that depend on the system window and <br>* highlight colors.  As it loads them, it replaces two special colors <br>* in them with some system colors. <br>* This is used for the control type bitmaps that appear in lines <br>* in the listbox in the Order/Group dialog. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID LoadSysColorBitmaps(VOID) <br>{ <br>    DWORD rgbWindow; <br>    DWORD rgbWindowText; <br>    DWORD rgbHighlight; <br>    DWORD rgbHighlightText; <br>    INT i; <br> <br>    rgbWindow = GetSysColor(COLOR_WINDOW); <br>    rgbWindowText = GetSysColor(COLOR_WINDOWTEXT); <br>    rgbHighlight = GetSysColor(COLOR_HIGHLIGHT); <br>    rgbHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT); <br> <br>    if (hbmTabStop) <br>        DeleteObject(hbmTabStop); <br> <br>    hbmTabStop = LoadAlterBitmap(IDBM_TABSTOP, rgbWindow, rgbWindowText); <br> <br>    if (hbmTabStopSel) <br>        DeleteObject(hbmTabStopSel); <br> <br>    hbmTabStopSel = LoadAlterBitmap(IDBM_TABSTOP, <br>            rgbHighlight, rgbHighlightText); <br> <br>    for (i = 0; i &lt; CCONTROLS; i++) { <br>        if (awcd[i].hbmCtrlType) <br>            DeleteObject(awcd[i].hbmCtrlType); <br> <br>        awcd[i].hbmCtrlType = LoadAlterBitmap( <br>                awcd[i].idbmCtrlType, rgbWindow, rgbWindowText); <br> <br>        if (awcd[i].hbmCtrlTypeSel) <br>            DeleteObject(awcd[i].hbmCtrlTypeSel); <br> <br>        awcd[i].hbmCtrlTypeSel = LoadAlterBitmap( <br>                awcd[i].idbmCtrlType, rgbHighlight, rgbHighlightText); <br>    } <br> <br>    if (ghbmDragHandle) <br>        DeleteObject(ghbmDragHandle); <br> <br>    ghbmDragHandle = LoadAlterBitmap(IDBM_DRAGHANDLE, <br>            rgbWindow, rgbHighlight); <br> <br>    if (ghbmDragHandle2) <br>        DeleteObject(ghbmDragHandle2); <br> <br>    ghbmDragHandle2 = LoadAlterBitmap(IDBM_DRAGHANDLE2, <br>            rgbWindow, rgbHighlight); <br>} <br> <br> <br> <br>/************************************************************************ <br>* LoadAlterBitmap <br>* <br>* This function loads a single bitmap.  As it does, it replaces a <br>* couple special RGB colors (REPLACECOLOR1 and REPLACECOLOR2) with <br>* the passed in RGB colors. <br>* <br>* Arguments: <br>*   INT idbm      - Integer ID of the bitmap to load. <br>*   DWORD rgbNew  - Color to replace the special color with. <br>*   DWORD rgbNew2 - A second color to replace the second special color with. <br>* <br>* Returns: <br>*   The handle to the bitmap, or NULL if an error occurs. <br>* <br>************************************************************************/ <br> <br>STATICFN HBITMAP LoadAlterBitmap( <br>    INT idbm, <br>    DWORD rgbNew, <br>    DWORD rgbNew2) <br>{ <br>    register INT i; <br>    LPBITMAPINFOHEADER lpbihInfo; <br>    HDC hdcScreen; <br>    HANDLE hresLoad; <br>    HANDLE hres; <br>    DWORD FAR *qlng; <br>    LPBYTE lpbBits; <br>    HANDLE hbmp; <br>    DWORD rgbReplace1; <br>    DWORD rgbReplace2; <br> <br>    hresLoad = FindResource(ghInst, MAKEINTRESOURCE(idbm), RT_BITMAP); <br>    if (!hresLoad) <br>        return NULL; <br> <br>    hres = LoadResource(ghInst, hresLoad); <br>    if (!hresLoad) <br>        return NULL; <br> <br>    rgbNew = RGBInvertRGB(rgbNew); <br>    rgbNew2 = RGBInvertRGB(rgbNew2); <br>    rgbReplace1 = RGBInvertRGB(REPLACECOLOR1); <br>    rgbReplace2 = RGBInvertRGB(REPLACECOLOR2); <br>    lpbihInfo = (LPBITMAPINFOHEADER)LockResource(hres); <br>    qlng = (LPDWORD)((PBYTE)(lpbihInfo) + lpbihInfo-&gt;biSize); <br> <br>    for (i = 0; i &lt; (1 &lt;&lt; lpbihInfo-&gt;biBitCount); i++, qlng++) { <br>        if (*qlng == rgbReplace1) <br>            *qlng = rgbNew; <br>        else if (*qlng == rgbReplace2) <br>            *qlng = rgbNew2; <br>    } <br> <br>    /* <br>     * First skip over the header structure. <br>     */ <br>    lpbBits = (LPBYTE)(lpbihInfo + 1); <br> <br>    /* <br>     * Skip the color table entries, if any. <br>     */ <br>    lpbBits += (1 &lt;&lt; (lpbihInfo-&gt;biBitCount)) * sizeof(RGBQUAD); <br> <br>    /* <br>     * Create a color bitmap compatible with the display device. <br>     */ <br>    if (hdcScreen = GetDC(NULL)) { <br>        hbmp = CreateDIBitmap(hdcScreen, lpbihInfo, (LONG)CBM_INIT, <br>                lpbBits, (LPBITMAPINFO)lpbihInfo, DIB_RGB_COLORS); <br>        ReleaseDC(NULL, hdcScreen); <br>    } <br> <br>    UnlockResource(hres); <br>    FreeResource(hres); <br> <br>    return hbmp; <br>} <br> <br> <br> <br>/************************************************************************ <br>* RGBInvertRGB <br>* <br>* Reverses the RGB order of a color.  This needs to be done to match <br>* the resource file format of the color table. <br>* <br>************************************************************************/ <br> <br>STATICFN DWORD RGBInvertRGB( <br>    DWORD rgb) <br>{ <br>    return (DWORD)RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)); <br>} <br> <br> <br> <br>/************************************************************************ <br>* SizeRibbons <br>* <br>* This function positions and sizes the child ribbon and subclient <br>* windows in the dialog editor.  It needs to be called any time the <br>* size of the main windows changes. <br>* <br>* Arguments: <br>*   HWND hwnd - Parent window handle. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID SizeRibbons( <br>    HWND hwnd) <br>{ <br>    RECT rcClient; <br> <br>    if (hwndStatus &amp;&amp; !IsIconic(hwnd)) { <br>        /* <br>         * Get the client area. <br>         */ <br>        GetClientRect(hwnd, &amp;rcClient); <br> <br>        /* <br>         * Size/move the status and subclient window to fit <br>         * the new client area. <br>         */ <br>        SetWindowPos(hwndStatus, NULL, <br>                0, 0, <br>                rcClient.right - rcClient.left, <br>                min(rcClient.bottom - rcClient.top, gcyStatus), <br>                SWP_NOACTIVATE | SWP_NOZORDER); <br> <br>        SetWindowPos(ghwndSubClient, NULL, <br>                0, gcyStatus, <br>                rcClient.right - rcClient.left, <br>                max((rcClient.bottom - rcClient.top) - gcyStatus, 0), <br>                SWP_NOACTIVATE | SWP_NOZORDER); <br>    } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* DialogTerminate <br>* <br>* This undoes what DialogInit does.  It should be called before terminating <br>* and after a DialogInit. <br>* <br>****************************************************************************/ <br> <br>STATICFN VOID DialogTerminate(VOID) <br>{ <br>    register INT i; <br> <br>    /* <br>     * Save the Preferences data. <br>     */ <br>    WriteEnv(); <br> <br>    if (hbmTabStop) <br>        DeleteObject(hbmTabStop); <br> <br>    if (hbmTabStopSel) <br>        DeleteObject(hbmTabStopSel); <br> <br>    if (ghbmDragHandle) <br>        DeleteObject(ghbmDragHandle); <br> <br>    if (ghbmDragHandle2) <br>        DeleteObject(ghbmDragHandle2); <br> <br>    if (ghDCMem) <br>        DeleteDC(ghDCMem); <br> <br>    /* <br>     * Free the control type bitmaps. <br>     */ <br>    for (i = 0; i &lt; CCONTROLS; i++) { <br>        if (awcd[i].hbmCtrlType) <br>            DeleteObject(awcd[i].hbmCtrlType); <br> <br>        if (awcd[i].hbmCtrlTypeSel) <br>            DeleteObject(awcd[i].hbmCtrlTypeSel); <br>    } <br> <br>    /* <br>     * Free all the custom control links.  This must be done before the <br>     * app exits so that any loaded DLL's get unloaded! <br>     */ <br>    while (gpclHead) <br>        RemoveCustomLink(gpclHead); <br> <br>    if (hpenDarkGray) <br>        DeleteObject(hpenDarkGray); <br> <br>    if (ghhkMsgFilter) <br>        UnhookWindowsHookEx(ghhkMsgFilter); <br> <br>    if (lpfnRegisterPenApp) <br>        (*lpfnRegisterPenApp)((WORD)1, FALSE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
