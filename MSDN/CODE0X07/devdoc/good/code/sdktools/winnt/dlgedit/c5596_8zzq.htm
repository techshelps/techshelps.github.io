<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5606"></a>DRAG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: drag.c <br>* <br>* Contains routines for dragging and sizing controls. <br>* <br>* Functions: <br>*    ShowTrackRect() <br>*    HideTrackRect() <br>*    FitRectToBounds() <br>*    GetOverHang() <br>*    GridizeRect() <br>*    SizeDragToControl() <br>*    DragWndProc() <br>*    DrawHandles() <br>*    HandleHitTest() <br>*    CtrlButtonDown() <br>*    DragNewBegin() <br>*    CtrlMouseMove() <br>*    PreDragTimeout() <br>*    DragCancel() <br>*    CtrlButtonUp() <br>*    DragEnd() <br>*    CalcCursorOffset() <br>*    InitTracking() <br>*    DrawTrackRect() <br>*    CancelTracking() <br>*    AtOrAbove() <br>*    AtOrBelow() <br>*    PaintUnderDrag() <br>*    MouseToDragRect() <br>*    MouseToDU() <br>*    DragBegin() <br>*    CtrlHitTest() <br>*    DragBegin2() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>#include &lt;stdlib.h&gt; <br> <br>STATICFN VOID CalcCursorOffset(POINT *ppt); <br>STATICFN VOID InitTracking(VOID); <br>STATICFN VOID DrawTrackRect(PRECT prc, BOOL fDialog, BOOL fDraw); <br>STATICFN VOID CancelTracking(VOID); <br>STATICFN INT AtOrAbove(INT nStart, INT nGrid); <br>STATICFN INT AtOrBelow(INT nStart, INT nGrid); <br>STATICFN VOID PaintUnderDrag(HWND hwndDrag); <br>STATICFN VOID MouseToDragRect(INT x, INT y, PRECT prc); <br>STATICFN VOID MouseToDU(PPOINT ppt); <br>STATICFN VOID DragBegin(HWND hwnd, INT x, INT y, BOOL fHandleWindow); <br>STATICFN HWND CtrlHitTest(HWND hwnd, PPOINT ppt); <br>STATICFN VOID DragBegin2(PPOINT ppt); <br> <br>/* <br> * This contains the initial location of the mouse when going into <br> * pre-drag mode.  If the mouse pointer is moved too far away from <br> * this point, we will start the drag operation, even if the pre-drag <br> * timer has not elapsed yet. <br> */ <br>static POINT gptPreDragStart; <br> <br> <br> <br>/************************************************************************ <br>* CalcCursorOffset <br>* <br>* This routine updates the gptCursorOffset point.  This is used during <br>* dragging operations.  It contains the offset from the mouse pointer <br>* at the time a dragging operation is begun and the upper left corner <br>* of the dragging rectangle.  This value is needed for determining <br>* where mouse events are occuring in relation to where the drag was <br>* initially begun from. <br>* <br>* Arguments: <br>*    POINT - offset where the mouse pointer began drag. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID CalcCursorOffset( <br>    POINT *ppt) <br>{ <br>    RECT rc; <br>    POINT pt; <br> <br>    if (gfDlgSelected) { <br>        gptCursorOffset = *ppt; <br>    } <br>    else { <br>        rc = grcSelected; <br>        pt = *ppt; <br>        DUToWinRect(&amp;rc); <br> <br>        ClientToScreen(gnpcSel-&gt;hwnd, &amp;pt); <br>        ScreenToClient(gcd.npc-&gt;hwnd, &amp;pt); <br> <br>        gptCursorOffset.x = pt.x - rc.left; <br>        gptCursorOffset.y = pt.y - rc.top; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* InitTracking <br>* <br>* This function initializes a tracking operation.  The pointer is <br>* changed to be the system "move" pointer if we are moving the <br>* control (not sizing it). <br>* <br>************************************************************************/ <br> <br>STATICFN VOID InitTracking(VOID) <br>{ <br>    if (gfDlgSelected) <br>        ghDCTrack = CreateDC(L"DISPLAY", NULL, NULL, NULL); <br>    else <br>        ghDCTrack = GetDC(gcd.npc-&gt;hwnd); <br> <br>    SetROP2(ghDCTrack, R2_NOT); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DrawTrackRect <br>* <br>* This routine draws the drag rectangle.  It is assumed that the window <br>* has been locked for update appropriately or this could leave garbage <br>* around.  The rectangle given is in dialog units, and is converted <br>* to window coordinates using different rules based on the value of <br>* fDialog.  After this routine has been called to set the rectangle, <br>* the HideTrackRect and ShowTrackRect functions can be called to <br>* temporarily hide the track rectangle, but this routine must be called <br>* again every time that the tracking rectangle is to be changed. <br>* <br>* Arguments: <br>*   PRECT prc     - Drag rectangle to draw (in dialog units). <br>*   BOOL fDialog  - TRUE if the control being dragged is the dialog. <br>*   BOOL fDraw    - If TRUE, the rectangle will be drawn.  Having this <br>*                   FALSE is useful to just initialize the state globals, <br>*                   but defer the drawing of the rectangle until the mouse <br>*                   is moved from its starting point. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID DrawTrackRect( <br>    PRECT prc, <br>    BOOL fDialog, <br>    BOOL fDraw) <br>{ <br>    HideTrackRect(); <br> <br>    grcTrackWin = grcTrackDU = *prc; <br>    DUToWinRect(&amp;grcTrackWin); <br> <br>    if (fDialog) { <br>        AdjustWindowRectEx(&amp;grcTrackWin, gcd.npc-&gt;flStyle, FALSE, <br>                (gcd.npc-&gt;flStyle &amp; DS_MODALFRAME) ? <br>                gcd.npc-&gt;flExtStyle | WS_EX_DLGMODALFRAME : <br>                gcd.npc-&gt;flExtStyle); <br>        ClientToScreenRect(ghwndSubClient, &amp;grcTrackWin); <br>    } <br> <br>    if (fDraw) <br>        ShowTrackRect(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ShowTrackRect <br>* <br>* This routine shows the current tracking rectangle. <br>* <br>************************************************************************/ <br> <br>VOID ShowTrackRect(VOID) <br>{ <br>    if (!gfTrackRectShown) { <br>        MyFrameRect(ghDCTrack, &amp;grcTrackWin, DSTINVERT); <br>        gfTrackRectShown = TRUE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* HideTrackRect <br>* <br>* This routine hides the current tracking rectangle. <br>* <br>************************************************************************/ <br> <br>VOID HideTrackRect(VOID) <br>{ <br>    if (gfTrackRectShown) { <br>        MyFrameRect(ghDCTrack, &amp;grcTrackWin, DSTINVERT); <br>        gfTrackRectShown = FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* CancelTracking <br>* <br>* This routine is used to cancel the display of the tracking rectangle. <br>* It is basically the opposite of InitTracking. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID CancelTracking(VOID) <br>{ <br>    if (gfTrackRectShown) { <br>        HideTrackRect(); <br> <br>        if (gfDlgSelected) <br>            DeleteDC(ghDCTrack); <br>        else <br>            ReleaseDC(gcd.npc-&gt;hwnd, ghDCTrack); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* FitRectToBounds <br>* <br>* This routine fits the given rectangle to the appropriate boundary. <br>* If fDialog is FALSE, the rectangle is a control and it must fall <br>* entirely within the area of the current dialog being edited.  If the <br>* rectangle is adjusted to fit, the moved edge(s) will be aligned on <br>* a grid boundary.  The wHandleHit parameter is used to tell this routine <br>* what edges are allowed to move, in other words, what edges are <br>* "anchored" down and what edges are being tracked. <br>* <br>* Arguments: <br>*   PRECT prc     - Rectangle to be adjusted to the allowed size. <br>*   INT nOverHang - How much the control can hang below the dialog. <br>*                   This is primarily for the combobox listboxes. <br>*   INT HandleHit - One of the DRAG_* constants. <br>*   BOOL fDialog  - TRUE if the rectangle is for a dialog. <br>* <br>************************************************************************/ <br> <br>VOID FitRectToBounds( <br>    PRECT prc, <br>    INT nOverHang, <br>    INT HandleHit, <br>    BOOL fDialog) <br>{ <br>    INT cxDlg; <br>    INT cyDlg; <br>    INT dx; <br>    INT dy; <br> <br>    /* <br>     * Are we just moving the control (not sizing)? <br>     */ <br>    if (HandleHit == DRAG_CENTER) { <br>        /* <br>         * We only do range checking if it is a control (not on the dialog). <br>         */ <br>        if (!fDialog) { <br>            dx = prc-&gt;right - prc-&gt;left; <br>            dy = prc-&gt;bottom - prc-&gt;top; <br>            cxDlg = gcd.npc-&gt;rc.right - gcd.npc-&gt;rc.left; <br>            cyDlg = gcd.npc-&gt;rc.bottom - gcd.npc-&gt;rc.top + nOverHang; <br> <br>            if (prc-&gt;right &gt; cxDlg) { <br>                prc-&gt;left = AtOrBelow(cxDlg - dx, gcxGrid); <br>                prc-&gt;right = prc-&gt;left + dx; <br>            } <br> <br>            if (prc-&gt;left &lt; 0) { <br>                prc-&gt;left = 0; <br>                prc-&gt;right = prc-&gt;left + dx; <br>            } <br> <br>            if (prc-&gt;bottom &gt; cyDlg) { <br>                prc-&gt;top = AtOrBelow(cyDlg - dy, gcyGrid); <br>                prc-&gt;bottom = prc-&gt;top + dy; <br>            } <br> <br>            if (prc-&gt;top &lt; 0) { <br>                prc-&gt;top = 0; <br>                prc-&gt;bottom = prc-&gt;top + dy; <br>            } <br>        } <br> <br>        return; <br>    } <br> <br>    if (fDialog) { <br>        /* <br>         * When dealing with the dialog, we want to take into account <br>         * the controls so that the dialog is never sized to hide a <br>         * control.  This routine assumes that grcMinDialog has already <br>         * been set to enclose the controls.  If the dialog has no <br>         * controls, this rectangle is not used, but the dialog's size <br>         * is still limited so that it never goes negative. <br>         */ <br>        /* <br>         * First deal with the x coordinates. <br>         */ <br>        switch (HandleHit) { <br>            case DRAG_LEFTBOTTOM: <br>            case DRAG_LEFT: <br>            case DRAG_LEFTTOP: <br>                if (npcHead) { <br>                    if (prc-&gt;left &gt; grcMinDialog.left) <br>                        prc-&gt;left = AtOrBelow(grcMinDialog.left, gcxGrid); <br>                } <br>                else { <br>                    if (prc-&gt;left &gt; prc-&gt;right) <br>                        prc-&gt;left = AtOrBelow(prc-&gt;right, gcxGrid); <br>                } <br> <br>                break; <br> <br>            case DRAG_RIGHTBOTTOM: <br>            case DRAG_RIGHT: <br>            case DRAG_RIGHTTOP: <br>                if (npcHead) { <br>                    if (prc-&gt;right &lt; grcMinDialog.right) <br>                        prc-&gt;right = AtOrAbove(grcMinDialog.right, gcxGrid); <br>                } <br>                else { <br>                    if (prc-&gt;right &lt; prc-&gt;left) <br>                        prc-&gt;right = AtOrAbove(prc-&gt;left, gcxGrid); <br>                } <br> <br>                break; <br>        } <br> <br>        /* <br>         * Now deal with the y coordinates. <br>         */ <br>        switch (HandleHit) { <br>            case DRAG_LEFTBOTTOM: <br>            case DRAG_BOTTOM: <br>            case DRAG_RIGHTBOTTOM: <br>                if (npcHead) { <br>                    if (prc-&gt;bottom &lt; grcMinDialog.bottom) <br>                        prc-&gt;bottom = AtOrAbove(grcMinDialog.bottom, gcyGrid); <br>                } <br>                else { <br>                    if (prc-&gt;bottom &lt; prc-&gt;top) <br>                        prc-&gt;bottom = AtOrAbove(prc-&gt;top, gcyGrid); <br>                } <br> <br>                break; <br> <br>            case DRAG_LEFTTOP: <br>            case DRAG_TOP: <br>            case DRAG_RIGHTTOP: <br>                if (npcHead) { <br>                    if (prc-&gt;top &gt; grcMinDialog.top) <br>                        prc-&gt;top = AtOrBelow(grcMinDialog.top, gcyGrid); <br>                } <br>                else { <br>                    if (prc-&gt;top &gt; prc-&gt;bottom) <br>                        prc-&gt;top = AtOrBelow(prc-&gt;bottom, gcyGrid); <br>                } <br> <br>                break; <br>        } <br>    } <br>    else { <br>        /* <br>         * First deal with the x coordinates. <br>         */ <br>        switch (HandleHit) { <br>            case DRAG_LEFTBOTTOM: <br>            case DRAG_LEFT: <br>            case DRAG_LEFTTOP: <br>                if (prc-&gt;left &gt; prc-&gt;right) <br>                    prc-&gt;left = AtOrBelow(prc-&gt;right, gcxGrid); <br> <br>                if (prc-&gt;left == prc-&gt;right) <br>                    prc-&gt;left -= gcxGrid; <br> <br>                if (prc-&gt;left &lt; 0) <br>                    prc-&gt;left = 0; <br> <br>                break; <br> <br>            case DRAG_RIGHTBOTTOM: <br>            case DRAG_RIGHT: <br>            case DRAG_RIGHTTOP: <br>                cxDlg = gcd.npc-&gt;rc.right - gcd.npc-&gt;rc.left; <br>                if (prc-&gt;right &gt; cxDlg) <br>                    prc-&gt;right = AtOrBelow(cxDlg, gcxGrid); <br> <br>                if (prc-&gt;right &lt; prc-&gt;left) <br>                    prc-&gt;right = AtOrAbove(prc-&gt;left, gcxGrid); <br> <br>                if (prc-&gt;right == prc-&gt;left) <br>                    prc-&gt;right += gcxGrid; <br> <br>                break; <br>        } <br> <br>        /* <br>         * Now deal with the y coordinates. <br>         */ <br>        switch (HandleHit) { <br>            case DRAG_LEFTTOP: <br>            case DRAG_TOP: <br>            case DRAG_RIGHTTOP: <br>                if (prc-&gt;top &gt; prc-&gt;bottom) <br>                    prc-&gt;top = AtOrBelow(prc-&gt;bottom, gcyGrid); <br> <br>                if (prc-&gt;top == prc-&gt;bottom) <br>                    prc-&gt;top -= gcyGrid; <br> <br>                if (prc-&gt;top &lt; 0) <br>                    prc-&gt;top = 0; <br> <br>                break; <br> <br>            case DRAG_LEFTBOTTOM: <br>            case DRAG_BOTTOM: <br>            case DRAG_RIGHTBOTTOM: <br>                cyDlg = gcd.npc-&gt;rc.bottom - gcd.npc-&gt;rc.top; <br> <br>                /* <br>                 * Note that if there is an overhang allowed, then <br> * we do not limit how far down the bottom of the <br>                 * control can be. <br>                 */ <br>                if (prc-&gt;bottom &gt; cyDlg &amp;&amp; !nOverHang) <br>                    prc-&gt;bottom = AtOrBelow(cyDlg, gcyGrid); <br> <br>                if (prc-&gt;bottom &lt; prc-&gt;top) <br>                    prc-&gt;bottom = AtOrAbove(prc-&gt;top, gcyGrid); <br> <br>                if (prc-&gt;bottom == prc-&gt;top) <br>                    prc-&gt;bottom += gcyGrid; <br> <br>                break; <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* AtOrAbove <br>* <br>* This routine takes a number, and returns the closest number that <br>* is equal to or above that number and is an integral of the given <br>* grid value. <br>* <br>* Arguments: <br>*   INT nStart - Starting number (can be negative). <br>*   INT nGrid  - Grid value. <br>* <br>************************************************************************/ <br> <br>STATICFN INT AtOrAbove( <br>    INT nStart, <br>    INT nGrid) <br>{ <br>    register INT nAbove; <br> <br>    nAbove = (nStart / nGrid) * nGrid; <br> <br>    if (nStart &gt; 0 &amp;&amp; nStart != nAbove) <br>        nAbove += nGrid; <br> <br>    return nAbove; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AtOrBelow <br>* <br>* This routine takes a number, and returns the closest number that <br>* is equal to or below that number and is an integral of the given <br>* grid value. <br>* <br>* Arguments: <br>*   INT nStart - Starting number (can be negative). <br>*   INT nGrid  - Grid value. <br>* <br>************************************************************************/ <br> <br>STATICFN INT AtOrBelow( <br>    INT nStart, <br>    INT nGrid) <br>{ <br>    register INT nBelow; <br> <br>    nBelow = (nStart / nGrid) * nGrid; <br> <br>    if (nStart &lt; 0 &amp;&amp; nStart != nBelow) <br>        nBelow -= nGrid; <br> <br>    return nBelow; <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetOverHang <br>* <br>* This function returns the height that the control can overhang the <br>* bottom of the dialog.  This is currently only meaningful for comboboxes. <br>* If the control is not a combobox, zero is returned. <br>* <br>* Arguments: <br>*   INT iType - Type of control (W_* constant). <br>*   INT cy    - Height of the control (in DU's). <br>* <br>************************************************************************/ <br> <br>INT GetOverHang( <br>    INT iType, <br>    INT cy) <br>{ <br>    if (iType != W_COMBOBOX) <br>        return 0; <br> <br>    return max(cy - COMBOEDITHEIGHT, 0); <br>} <br> <br> <br> <br>/************************************************************************ <br>* GridizeRect <br>* <br>* This function "gridizes" coordinates in a rectangle.  The current <br>* grid values are used.  The fsGrid flag can contain OR'd together <br>* GRIDIZE_* values that specify which points to apply the gridding to. <br>* Upon return, all coordinates specified will have been rounded to the <br>* nearest grid boundary. <br>* <br>* If GRIDIZE_SAMESIZE is specified, the size of the control will be <br>* kept the same.  This overrides the GRIDIZE_RIGHT and GRIDIZE_BOTTOM <br>* flags.  In other words, any delta applied to left or top will <br>* be added to right and bottom to retain the original size of the <br>* rectangle. <br>* <br>* Arguments: <br>*   PRECT prc       - Rectangle to adjust to the current grid. <br>*   INT fGridFlags  - GRIDIZE_* flags.  Specifies which points to gridize. <br>* <br>************************************************************************/ <br> <br>VOID GridizeRect( <br>    PRECT prc, <br>    INT fGridFlags) <br>{ <br>    register INT nTemp; <br>    INT leftOld = prc-&gt;left; <br>    INT topOld = prc-&gt;top; <br> <br>    if (fGridFlags &amp; GRIDIZE_LEFT) { <br>        nTemp = AtOrBelow(prc-&gt;left, gcxGrid); <br> <br>        if (prc-&gt;left - nTemp &gt; gcxGrid / 2) <br>            nTemp += gcxGrid; <br> <br>        prc-&gt;left = nTemp; <br>    } <br> <br>    if (fGridFlags &amp; GRIDIZE_TOP) { <br>        nTemp = AtOrBelow(prc-&gt;top, gcyGrid); <br> <br>        if (prc-&gt;top - nTemp &gt; gcyGrid / 2) <br>            nTemp += gcyGrid; <br> <br>        prc-&gt;top = nTemp; <br>    } <br> <br>    /* <br>     * Do they want to retain the same size of the rectangle? <br>     */ <br>    if (fGridFlags &amp; GRIDIZE_SAMESIZE) { <br>        /* <br>         * Shift the right coordinate over by the delta that <br>         * was applied to the left. <br>         */ <br>        prc-&gt;right += prc-&gt;left - leftOld; <br>        prc-&gt;bottom += prc-&gt;top - topOld; <br>    } <br>    else { <br>        if (fGridFlags &amp; GRIDIZE_RIGHT) { <br>            nTemp = AtOrBelow(prc-&gt;right, gcxGrid); <br> <br>            if (prc-&gt;right - nTemp &gt; gcxGrid / 2) <br>                nTemp += gcxGrid; <br> <br>            prc-&gt;right = nTemp; <br>        } <br> <br>        if (fGridFlags &amp; GRIDIZE_BOTTOM) { <br>            nTemp = AtOrBelow(prc-&gt;bottom, gcyGrid); <br> <br>            if (prc-&gt;bottom - nTemp &gt; gcyGrid / 2) <br>                nTemp += gcyGrid; <br> <br>            prc-&gt;bottom = nTemp; <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* SizeDragToControl <br>* <br>* This routine sizes and positions the drag window associated with a <br>* control, based on the current size and position of the control. <br>* <br>* It takes into account the different origin that controls and dialogs <br>* have, and sizes the drag window to fit around the control properly. <br>* The Z order of the drag window is NOT changed. <br>* <br>* This routine should only be called for controls, not the dialog. <br>* <br>* Arguments: <br>*   NPCTYPE npc - Control whose drag window needs to be sized. <br>* <br>************************************************************************/ <br> <br>VOID SizeDragToControl( <br>    NPCTYPE npc) <br>{ <br>    RECT rc; <br> <br>    rc = npc-&gt;rc; <br>    DUToWinRect(&amp;rc); <br> <br>    InflateRect(&amp;rc, CHANDLESIZE / 2, CHANDLESIZE / 2); <br> <br>    SetWindowPos(npc-&gt;hwndDrag, NULL, rc.left, rc.top, <br>            rc.right - rc.left, rc.bottom - rc.top, <br>            SWP_NOACTIVATE | SWP_NOZORDER); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DragWndProc <br>* <br>* This is the window procedure for the "drag" class.  This window <br>* is placed behind a control and is what the user grabs to size a <br>* window with the mouse. <br>* <br>************************************************************************/ <br> <br>WINDOWPROC DragWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    POINT pt; <br> <br>    switch (msg) { <br>        case WM_PAINT: <br>            { <br>                PAINTSTRUCT ps; <br>                HDC hDC; <br> <br>                PaintUnderDrag(hwnd); <br> <br>                hDC = BeginPaint(hwnd, &amp;ps); <br>                DrawHandles(hwnd, hDC, <br>                        (gnpcSel &amp;&amp; hwnd == gnpcSel-&gt;hwndDrag) ? TRUE : FALSE); <br>                EndPaint(hwnd, &amp;ps); <br>            } <br> <br>            break; <br> <br>        case WM_NCHITTEST: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            ScreenToClient(hwnd, &amp;pt); <br> <br>            if (HandleHitTest(hwnd, pt.x, pt.y) == DRAG_CENTER) <br>                return HTTRANSPARENT; <br>            else <br>                return HTCLIENT; <br> <br>        case WM_SETCURSOR: <br>            /* <br>             * Defeat the system changing cursors on us.  We do it based <br>             * on our own hit testing. <br>             */ <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            CtrlButtonDown(hwnd, pt.x, pt.y, TRUE); <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            CtrlMouseMove(hwnd, TRUE, pt.x, pt.y); <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>            CtrlButtonUp(pt.x, pt.y); <br>            break; <br> <br>        case WM_RBUTTONDOWN: <br>        case WM_MBUTTONDOWN: <br>        case WM_LBUTTONDBLCLK: <br>        case WM_RBUTTONDBLCLK: <br>        case WM_MBUTTONDBLCLK: <br>            /* <br>             * Prevents calling SetFocus when the middle or right <br>             * mouse buttons are pressed (or doubleclicked). <br>             */ <br>            break; <br> <br>        case WM_NCCALCSIZE: <br>            /* <br>             * The client area is the entire control. <br>             */ <br>            break; <br> <br>        case WM_DESTROY: <br>            /* <br>             * When destroying the drag window, we must be sure and <br>             * remove the properties associated with it. <br>             */ <br>            UNSETPCINTOHWND(hwnd); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0L; <br>} <br> <br> <br> <br>/************************************************************************ <br>* DrawHandles <br>* <br>* This routine draws the drag handles for a drag window.  The handles <br>* will be solid (filled) if fCurrentSelection is TRUE, or hollow if it <br>* is FALSE. <br>* <br>* Arguments: <br>*   HWND hwnd              - Drag window handle. <br>*   HDC hDC                - DC to use to draw in this window. <br>*   BOOL fCurrentSelection - TRUE if this control is the "current" <br>*                            selection. <br>* <br>************************************************************************/ <br> <br>VOID DrawHandles( <br>    HWND hwnd, <br>    HDC hDC, <br>    BOOL fCurrentSelection) <br>{ <br>    RECT rc; <br>    INT xMid; <br>    INT yMid; <br>    INT x2; <br>    INT y2; <br>    HBITMAP hbmOld; <br> <br>    GetWindowRect(hwnd, &amp;rc); <br>    OffsetRect(&amp;rc, -rc.left, -rc.top); <br> <br>    /* <br>     * Precalculate some points. <br>     */ <br>    xMid = ((rc.right + 1) / 2) - (CHANDLESIZE / 2); <br>    yMid = ((rc.bottom + 1) / 2) - (CHANDLESIZE / 2); <br>    x2 = rc.right - CHANDLESIZE; <br>    y2 = rc.bottom - CHANDLESIZE; <br> <br>    /* <br>     * Draw a solid box if this is the currently selected <br>     * control, otherwise draw a hollow box. <br>     */ <br>    if (fCurrentSelection) <br>        hbmOld = SelectObject(ghDCMem, ghbmDragHandle); <br>    else <br>        hbmOld = SelectObject(ghDCMem, ghbmDragHandle2); <br> <br>    BitBlt(hDC, 0, 0, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, xMid, 0, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, x2, 0, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, x2, yMid, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, x2, y2, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, xMid, y2, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, 0, y2, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br>    BitBlt(hDC, 0, yMid, CHANDLESIZE, CHANDLESIZE, <br>            ghDCMem, 0, 0, SRCCOPY); <br> <br>    SelectObject(ghDCMem, hbmOld); <br>} <br> <br> <br> <br>/************************************************************************ <br>* PaintUnderDrag <br>* <br>* This function is used during a paint operation for a visible drag <br>* window.  It checks underneath the area to update and forces any <br>* windows down there to paint themselves, in such an order as to cause <br>* the last one painted to be the visually top window.  This is necessary <br>* to implement the drag windows as "transparent" windows.  After this <br>* routine finishes, the caller can paint the "handles".  The caller must <br>* call this routine before calling BeginPaint, or the update area <br>* will be null and nothing will get painted. <br>* <br>* It is assumed that the drag windows are for controls, not for the <br>* dialog. <br>* <br>* Arguments: <br>*   HWND hwndDrag - Drag window to paint under. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID PaintUnderDrag( <br>    HWND hwndDrag) <br>{ <br>    RECT rc; <br>    RECT rcInt; <br>    RECT rcUpdate; <br>    HWND hwnd; <br>    HWND hwndControl; <br>    NPCTYPE npc; <br> <br>    /* <br>     * Get our corresponding control window. <br>     */ <br>    hwndControl = (PCFROMHWND(hwndDrag))-&gt;hwnd; <br> <br>    /* <br>     * Get the update rectangle and convert to screen coords. <br>     */ <br>    GetUpdateRect(hwndDrag, &amp;rcUpdate, TRUE); <br>    ClientToScreenRect(hwndDrag, &amp;rcUpdate); <br> <br>    /* <br>     * Start enumerating windows. <br>     */ <br>    hwnd = hwndDrag; <br>    while (hwnd = GetWindow(hwnd, GW_HWNDNEXT)) { <br>        /* <br>         * Skip invisible drag windows. <br>         */ <br>        if (IsWindowVisible(hwnd)) { <br>            /* <br>             * Does the window rectangle intersect the update rectangle? <br>             */ <br>            GetWindowRect(hwnd, &amp;rc); <br>            if (IntersectRect(&amp;rcInt, &amp;rc, &amp;rcUpdate)) { <br>                npc = PCFROMHWND(hwnd); <br> <br>                if (npc-&gt;hwndDrag == hwnd || !npc-&gt;fSelected) { <br>                    ScreenToClientRect(hwnd, &amp;rcInt); <br>                    InvalidateRect(hwnd, &amp;rcInt, TRUE); <br>                    UpdateWindow(hwnd); <br>                } <br> <br>                if (npc-&gt;hwndDrag == hwnd) <br>                    break; <br>            } <br>        } <br>    } <br> <br>    /* <br>     * Finally, paint the control associated with this drag window. <br>     */ <br>    InvalidateRect(hwndControl, NULL, TRUE); <br>    UpdateWindow(hwndControl); <br>} <br> <br> <br> <br>/************************************************************************ <br>* HandleHitTest <br>* <br>* This routine takes a point from a mouse button press on a drag window <br>* and returns which "handle" was hit, if any. <br>* <br>* The coordinates are given in zero based coordinates of the drag <br>* window. <br>* <br>* Arguments: <br>*   HWND hwnd   - Drag window handle the x,y point is relative to. <br>*   INT x       - Mouse X location (in the drag's client coordinates). <br>*   INT y       - Mouse Y location (in the drag's client coordinates). <br>* <br>* Returns: <br>*   One of the DRAG_* constants.  If no handle was hit, the <br>*   return will be DRAG_CENTER. <br>* <br>************************************************************************/ <br> <br>INT HandleHitTest( <br>    HWND hwnd, <br>    INT x, <br>    INT y) <br>{ <br>    RECT rc; <br>    INT xMidStart; <br>    INT yMidStart; <br> <br>    /* <br>     * If there are multiple controls selected, or if the control <br>     * type does not allow sizing, defeat the ability to size <br>     * with the handles by returning DRAG_CENTER. <br>     */ <br>    if (gcSelected &gt; 1 || !(PCFROMHWND(hwnd))-&gt;pwcd-&gt;fSizeable) <br>        return DRAG_CENTER; <br> <br>    /* <br>     * Get the window rectangle and cause it to be zero-origined. <br>     */ <br>    GetWindowRect(hwnd, &amp;rc); <br>    OffsetRect(&amp;rc, -rc.left, -rc.top); <br> <br>    /* <br>     * Calculate the starting points for the handles <br>     * that are not on a corner. <br>     */ <br>    xMidStart = ((rc.right + 1) / 2) - (CHANDLESIZE / 2); <br>    yMidStart = ((rc.bottom + 1) / 2) - (CHANDLESIZE / 2); <br> <br>    if (x &lt; CHANDLESIZE) { <br>        if (y &lt; CHANDLESIZE) <br>            return DRAG_LEFTTOP; <br>        else if (y &gt; rc.bottom - CHANDLESIZE) <br>            return DRAG_LEFTBOTTOM; <br>        else if (y &gt;= yMidStart &amp;&amp; y &lt; yMidStart + CHANDLESIZE) <br>            return DRAG_LEFT; <br>    } <br>    else if (x &gt; rc.right - CHANDLESIZE) { <br>        if (y &lt; CHANDLESIZE) <br>            return DRAG_RIGHTTOP; <br>        else if (y &gt; rc.bottom - CHANDLESIZE) <br>            return DRAG_RIGHTBOTTOM; <br>        else if (y &gt;= yMidStart &amp;&amp; y &lt; yMidStart + CHANDLESIZE) <br>            return DRAG_RIGHT; <br>    } <br>    else if (x &gt;= xMidStart &amp;&amp; x &lt; xMidStart + CHANDLESIZE) { <br>        if (y &lt; CHANDLESIZE) <br>            return DRAG_TOP; <br>        else if (y &gt; rc.bottom - CHANDLESIZE) <br>            return DRAG_BOTTOM; <br>    } <br> <br>    return DRAG_CENTER; <br>} <br> <br> <br> <br>/************************************************************************ <br>* MouseToDragRect <br>* <br>* This routine takes the mouse pointer coordinates from a mouse message </code></pre>
<p>
</p>
<pre><code>* and produces a rectangle that contains the coordinates that the drag <br>* rectangle should be displayed as.  This is for tracking (moving/sizing) <br>* operations.  It relies on a number of globals to have been set up <br>* prior to the call with such things as the current control, type of <br>* drag, old location of the control, offset of the original mouse press <br>* from the origin of the control, etc. <br>* <br>* The returned rectangle is pegged to the boundaries of the dialog (if it <br>* is for a control), and is aligned to the current grid units.  It is in <br>* dialog units relative to the appropriate point based on whether it is <br>* for a control or the dialog, and must be converted to window points <br>* before the actual drag rectangle can be drawn on the screen. <br>* <br>* Arguments: <br>*   INT x       - Mouse X location (in window coordinates). <br>*   INT y       - Mouse Y location (in window coordinates). <br>*   PRECT prc   - Rectangle to return the appropriate drag rectangle <br>*                 in. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID MouseToDragRect( <br>    INT x, <br>    INT y, <br>    PRECT prc) <br>{ <br>    POINT pt; <br>    INT fGridFlags; <br> <br>    pt.x = x; <br>    pt.y = y; <br>    MouseToDU(&amp;pt); <br> <br>    switch (gHandleHit) { <br>        case DRAG_LEFTBOTTOM: <br>            SetRect(prc, pt.x, grcSelected.top, grcSelected.right, <br>                    (grcSelected.bottom - grcSelected.top) + pt.y); <br>            fGridFlags = GRIDIZE_LEFT | GRIDIZE_BOTTOM; <br>            break; <br> <br>        case DRAG_BOTTOM: <br>            SetRect(prc, grcSelected.left, grcSelected.top, <br>                    grcSelected.right, <br>                    (grcSelected.bottom - grcSelected.top) + pt.y); <br>            fGridFlags = GRIDIZE_BOTTOM; <br>            break; <br> <br>        case DRAG_RIGHTBOTTOM: <br>            SetRect(prc, grcSelected.left, grcSelected.top, <br>                    (grcSelected.right - grcSelected.left) + pt.x, <br>                    (grcSelected.bottom - grcSelected.top) + pt.y); <br>            fGridFlags = GRIDIZE_BOTTOM | GRIDIZE_RIGHT; <br>           break; <br> <br>        case DRAG_RIGHT: <br>            SetRect(prc, grcSelected.left, grcSelected.top, <br>                    (grcSelected.right - grcSelected.left) + pt.x, <br>                    grcSelected.bottom); <br>            fGridFlags = GRIDIZE_RIGHT; <br>            break; <br> <br>        case DRAG_RIGHTTOP: <br>            SetRect(prc, grcSelected.left, pt.y, <br>                    (grcSelected.right - grcSelected.left) + pt.x, <br>                    grcSelected.bottom); <br>            fGridFlags = GRIDIZE_RIGHT | GRIDIZE_TOP; <br>            break; <br> <br>        case DRAG_TOP: <br>            SetRect(prc, grcSelected.left, pt.y, <br>                    grcSelected.right, grcSelected.bottom); <br>            fGridFlags = GRIDIZE_TOP; <br>            break; <br> <br>        case DRAG_LEFTTOP: <br>            SetRect(prc, pt.x, pt.y, grcSelected.right, grcSelected.bottom); <br>            fGridFlags = GRIDIZE_LEFT | GRIDIZE_TOP; <br>            break; <br> <br>        case DRAG_LEFT: <br>            SetRect(prc, pt.x, grcSelected.top, <br>                    grcSelected.right, grcSelected.bottom); <br>            fGridFlags = GRIDIZE_LEFT; <br>            break; <br> <br>        case DRAG_CENTER: <br>            SetRect(prc, pt.x, pt.y, <br>                    (grcSelected.right - grcSelected.left) + pt.x, <br>                    (grcSelected.bottom - grcSelected.top) + pt.y); <br>            fGridFlags = GRIDIZE_LEFT | GRIDIZE_TOP | GRIDIZE_SAMESIZE; <br>            break; <br>    } <br> <br>    GridizeRect(prc, fGridFlags); <br>    FitRectToBounds(prc, gnOverHang, gHandleHit, gfDlgSelected); <br>} <br> <br> <br> <br>/************************************************************************ <br>* MouseToDU <br>* <br>* This routine converts the point at ppt from window coordinates <br>* for the current control into the closest Dialog Unit point. <br>* <br>* This routine normally assumes that the point is relative to the selected <br>* control, and will convert the point into DU's.  The current control <br>* can either be the current dialog or one of its child controls. <br>* The DU's returned will be appropriate for the type of control.  If <br>* it is the dialog, they will be relative to the apps client area. <br>* If it is a control, they will be relative to the "client" area of <br>* the current dialog. <br>* <br>* If there is no current selection (such as when dropping a new control), <br>* the point is assumed to already be relative to the dialog and it will <br>* will not be mapped.  This only applies when called with a point for a <br>* control, not a dialog. <br>* <br>* Arguments: <br>*   PPOINT ppt - Point to convert. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID MouseToDU( <br>    PPOINT ppt) <br>{ <br>    if (gfDlgSelected) { <br>        /* <br>         * Map the points from the dialog to the app client. <br>         */ <br>        ClientToScreen(gcd.npc-&gt;hwnd, ppt); <br>        ScreenToClient(ghwndSubClient, ppt); <br> <br>        /* <br>         * Subtract the cursor offset. <br>         */ <br>        ppt-&gt;x -= gptCursorOffset.x; <br>        ppt-&gt;y -= gptCursorOffset.y; <br>    } <br>    else { <br>        /* <br>         * Map the points from the control to the dialog window, <br>         * but only if there is a current selection.  There will <br>         * not be a current selection when dropping a new control, <br>         * and the point must already be relative to the dialog! <br>         */ <br>        if (gnpcSel) { <br>            ClientToScreen(gnpcSel-&gt;hwnd, ppt); <br>            ScreenToClient(gcd.npc-&gt;hwnd, ppt); <br>        } <br> <br>        /* <br>         * Subtract the cursor offset, then the dialogs frame <br>         * controls offset. <br>         */ <br>        ppt-&gt;x -= gptCursorOffset.x; <br>        ppt-&gt;y -= gptCursorOffset.y; <br>    } <br> <br>    /* <br>     * Convert this position to dialog units. <br>     */ <br>    WinToDUPoint(ppt); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CtrlButtonDown <br>* <br>* This routine is called by the control and drag window procs when <br>* the left mouse button is pressed.  It checks for the Ctrl modifier key <br>* then passes control on to the appropriate routine. <br>* <br>* When hwnd is the dialog itself, fHandleWindow must be TRUE, even <br>* if a handle was not hit, because of the special-case code that must <br>* be done for the dialog (it doesn't have a separate drag window). <br>* <br>* Arguments: <br>*   HWND hwnd          - Window handle, can be a drag window or control. <br>*   INT x              - X mouse location (window coordinates). <br>*   INT y              - Y mouse location (window coordinates). <br>*   BOOL fHandleWindow - TRUE if a handle was clicked on, or FALSE if the <br>*                        body of a control was clicked on. <br>* <br>************************************************************************/ <br> <br>VOID CtrlButtonDown( <br>    HWND hwnd, <br>    INT x, <br>    INT y, <br>    BOOL fHandleWindow) <br>{ <br>    POINT pt; <br>    HWND hwndHit; <br>    INT nOverHang; <br> <br>    /* <br>     * Discard all mouse messages during certain operations. <br>     */ <br>    if (gfDisabled) <br>        return; <br> <br>    /* <br>     * Also, be sure any outstanding changes get applied <br>     * without errors. <br>     */ <br>    if (!StatusApplyChanges()) <br>        return; <br> <br>    if (gCurTool != W_NOTHING) { <br>        nOverHang = GetOverHang(gpwcdCurTool-&gt;iType, gpwcdCurTool-&gt;cyDefault); <br>        DragNewBegin(gpwcdCurTool-&gt;cxDefault, <br>                gpwcdCurTool-&gt;cyDefault, nOverHang); <br>    } <br>    else { <br>        /* <br>         * If the Control key is down, duplicate the control, unless <br>         * it is the dialog (mouse duplicate of the dialog is not <br>         * supported). <br>         */ <br>        if ((GetKeyState(VK_CONTROL) &amp; 0x8000) &amp;&amp; <br>                (PCFROMHWND(hwnd))-&gt;pwcd-&gt;iType != W_DIALOG) { <br>            /* <br>             * First, figure out which control was hit and select it. <br>             */ <br>            if (fHandleWindow) { <br>                hwndHit = hwnd; <br>            } <br>            else { <br>                pt.x = x; <br>                pt.y = y; <br>                hwndHit = CtrlHitTest(hwnd, &amp;pt); <br>            } <br> <br>            SelectControl(PCFROMHWND(hwndHit), TRUE); <br> <br>            /* <br>             * If there is still a selection, begin dragging a copy <br>             * of it.  The check here is necessary because the prior <br>             * call to SelectControl can unselect the last selected <br>             * control if the Shift key was held down. <br>             */ <br>            if (gcSelected) <br>                Duplicate(); <br>        } <br>        else { <br>            /* <br>             * Start a drag operation.  This can be either moving or sizing <br>             * the control, depending on fHandleWindow and where the mouse <br>             * click is at. <br>             */ <br>            DragBegin(hwnd, x, y, fHandleWindow); <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DragNewBegin <br>* <br>* This routine begins a drag operation when dropping a new control, or <br>* group of controls.  It is NOT used when dragging existing controls. <br>* <br>* Arguments: <br>*   INT cx        - Width of the new control. <br>*   INT cy        - Height of the new control. <br>*   INT nOverHang - How much the control can overhang the dialog bottom. <br>* <br>************************************************************************/ <br> <br>VOID DragNewBegin( <br>    INT cx, <br>    INT cy, <br>    INT nOverHang) <br>{ <br>    POINTS mpt; <br>    POINT pt; <br>    DWORD dwPos; <br> <br>    /* <br>     * Always be sure the focus is where we want it, not on something <br>     * like the status ribbon or "Esc" won't work to cancel the tracking. <br>     */ <br>    SetFocus(ghwndMain); <br> <br>    /* <br>     * Cancel any current selection, and set some state globals. <br>     */ <br>    CancelSelection(TRUE); <br>    gHandleHit = DRAG_CENTER; <br>    gState = STATE_DRAGGINGNEW; <br>    SetCursor(hcurMove); <br> <br>    /* <br>     * The cursor offset is set to be located in the middle of the <br>     * new control.  This causes the pointer to be initially located <br>     * exactly in the center. <br>     */ <br>    gptCursorOffset.x = cx; <br>    gptCursorOffset.y = cy; <br>    DUToWinPoint(&amp;gptCursorOffset); <br>    gptCursorOffset.x /= 2; <br>    gptCursorOffset.y /= 2; <br> <br>    /* <br>     * Set a global with the overhang.  This is used all during the <br>     * drag operation we are starting. <br>     */ <br>    gnOverHang = nOverHang; <br> <br>    /* <br>     * Now we make up a dummy rectangle for the new control.  We start <br>     * it at (0,0) with a size of cx and cy.  The point where the mouse <br>     * was when the command was done is obtained and mapped to the dialog <br>     * (it is assumed that only controls will be done here, not a dialog). <br>     * The new control rectangle is then converted to be at this location, <br>     * it is gridized, the tracking rectangle is shown and we are off. <br>     */ <br>    SetRect(&amp;grcSelected, 0, 0, cx, cy); <br>    dwPos = GetMessagePos(); <br>    mpt = (*((POINTS *)&amp;(dwPos))); <br>    ((pt).x = (mpt).x, (pt).y = (mpt).y); <br>    ScreenToClient(gcd.npc-&gt;hwnd, &amp;pt); <br>    MouseToDragRect(pt.x, pt.y, &amp;grcSelected); <br>    InitTracking(); <br>    DrawTrackRect(&amp;grcSelected, FALSE, TRUE); <br> <br>    /* <br>     * Display the initial coordinates. <br>     */ <br>    StatusSetCoords(&amp;grcSelected); <br> <br>    /* <br>     * The mouse messages will come through the dialog subclass proc for <br>     * these kinds of operations. <br>     */ <br>    SetCapture(gcd.npc-&gt;hwnd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DragBegin <br>* <br>* This routine begins a drag operation for either moving a control or <br>* sizing it.  The tracking rectangle is not actually drawn until the <br>* mouse moves by a grid unit, however. <br>* <br>* To begin a drag on the dialog itself, fHandleWindow must be TRUE, even <br>* if a handle was not hit, because of the special-case code that must <br>* be done for the dialog (it doesn't have a separate drag window). <br>* <br>* Arguments: <br>*   HWND hwnd          - Window handle, can be a drag window or control. <br>*   INT x              - Starting X mouse location (window coordinates). <br>*   INT y              - Starting Y mouse location (window coordinates). <br>*   BOOL fHandleWindow - TRUE if the drag is happening because a drag <br>*                        handle was clicked on, or FALSE if the drag is <br>*                        happening because the body of a control is <br>*                        clicked on. <br>* <br>* <br>************************************************************************/ <br> <br>STATICFN VOID DragBegin( <br>    HWND hwnd, <br>    INT x, <br>    INT y, <br>    BOOL fHandleWindow) <br>{ <br>    NPCTYPE npcT; <br>    HWND hwndHit; <br>    POINT pt; <br>    NPCTYPE npc; <br>    BOOL fPrevSelect = FALSE; <br>    INT nBottom; <br> <br>    /* <br>     * Always be sure the focus is where we want it, not on something <br>     * like the status ribbon or "Esc" won't work to cancel the tracking. <br>     */ <br>    SetFocus(ghwndMain); <br> <br>    pt.x = x; <br>    pt.y = y; <br> <br>    /* <br>     * Is this drag happening because a drag handle was clicked on? <br>     */ <br>    if (fHandleWindow) { <br>        /* <br>         * Find out which handle was clicked on.  It is assumed that <br>         * hwnd is a drag window. <br>         */ <br>        gHandleHit = HandleHitTest(hwnd, pt.x, pt.y); <br>        hwndHit = hwnd; <br>    } <br>    else { <br>        /* <br>         * The body of a control was clicked on.  Set a global to say <br>         * that we are moving a control, then find out which control <br>         * was hit (with our own hit testing). <br>         */ <br>        gHandleHit = DRAG_CENTER; <br>        hwndHit = CtrlHitTest(hwnd, &amp;pt); <br>    } <br> <br>    /* <br>     * Find out if the control clicked on was the currently selected <br>     * control already. <br>     */ <br>    npc = PCFROMHWND(hwndHit); <br>    if (npc == gnpcSel) <br>        fPrevSelect = TRUE; <br> <br>    /* <br>     * Select the control.  This can return FALSE if the control is <br>     * unselected (shift key is down and the control is already selected). <br>     */ <br>    if (!SelectControl(npc, TRUE)) <br>        return; <br> <br>    /* <br>     * If the dialog is selected, we make a rectangle that encloses all <br>     * the controls.  This will be used to limit the size that the dialog <br>     * can be sized to so that it cannot cover any existing controls. <br>     */ <br>    if (gfDlgSelected) { <br>        /* <br>         * Seed the rectangle with impossible values. <br>         */ <br>        SetRect(&amp;grcMinDialog, 32000, 32000, -32000, -32000); <br> <br>        /* <br>         * Loop through all the controls, expanding the rectangle to <br>         * fit around all the controls. <br>         */ <br>        for (npcT = npcHead; npcT; npcT = npcT-&gt;npcNext) { <br>            if (npcT-&gt;rc.left &lt; grcMinDialog.left) <br>                grcMinDialog.left = npcT-&gt;rc.left; <br> <br>            if (npcT-&gt;rc.right &gt; grcMinDialog.right) <br>                grcMinDialog.right = npcT-&gt;rc.right; <br> <br>            if (npcT-&gt;rc.top &lt; grcMinDialog.top) <br>                grcMinDialog.top = npcT-&gt;rc.top; <br> <br>            /* <br>             * When calculating the bottom boundary of the controls, <br>             * make the rectangle shorter by the ovehang amount.  This <br>             * allows the dialog to be sized up so that it covers <br>             * parts of controls with overhang (comboboxes). <br>             */ <br>            nBottom = npcT-&gt;rc.bottom - GetOverHang(npcT-&gt;pwcd-&gt;iType, <br>                    npcT-&gt;rc.bottom - npcT-&gt;rc.top); <br>            if (nBottom &gt; grcMinDialog.bottom) <br>                grcMinDialog.bottom = nBottom; <br>        } <br> <br>        OffsetRect(&amp;grcMinDialog, gcd.npc-&gt;rc.left, gcd.npc-&gt;rc.top); <br>    } <br> <br>    /* <br>     * If the control clicked on was already the anchor, go right into <br>     * dragging mode.  If it was not, go into pre-drag mode, which will <br>     * defer the calculation of offsets, etc., until after a certain <br>     * small amount of time so the mouse can be "debounced". <br>     */ <br>    if (fPrevSelect) { <br>        DragBegin2(&amp;pt); <br>    } <br>    else { <br>        gState = STATE_PREDRAG; <br> <br>        /* <br>         * Save the point in a global.  If the mouse pointer is moved <br> * too far away from this point, we will start the drag operation <br>         * even if the pre-drag time has not elapsed yet. <br>         */ <br>        gptPreDragStart = pt; <br> <br>        /* <br>         * Start the pre-drag timer. <br>         */ <br>        SetTimer(hwndHit, TID_PREDRAG, gmsecPreDrag, NULL); <br>    } <br> <br>    /* <br>     * The mouse messages from now on will go to the window clicked on, <br>     * either the drag window or the control window. <br>     */ <br>    SetCapture(hwndHit); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DragBegin2 <br>* <br>* This routine continues the initiation of a drag operation started <br>* by DragBegin.  It is separate because it calculates offsets based <br>* on where the mouse pointer is, and these calculations can be deferred <br>* until a later time than when DragBegin was called so that the mouse <br>* can be "debounced". <br>* <br>* Arguments: <br>*   POINT ppt - Starting mouse location (window coordinates). <br>* <br>************************************************************************/ <br> <br>STATICFN VOID DragBegin2( <br>    PPOINT ppt) <br>{ <br>    gState = STATE_DRAGGING; <br> <br>    /* <br>     * Set the pointer to the "move" pointer if we are moving. <br>     * Otherwise, the pointer should already be set to the proper <br>     * sizing pointer. <br>     */ <br>    if (gHandleHit == DRAG_CENTER) <br>        SetCursor(hcurMove); <br> <br>    /* <br>     * Save away the initial offset of the cursor. <br>     */ <br>    CalcCursorOffset(ppt); <br> <br>    /* <br>     * Initialize the track rectangle.  Note we are calling DrawTrackRect <br>     * with FALSE. <br>     */ <br>    DrawTrackRect(&amp;grcSelected, gfDlgSelected, FALSE); <br>} <br> <br> <br> <br>/**************************************************************************** <br>* CtrlHitTest <br>* <br>* This routine walks the list of controls and determines which one is <br>* "hit" by this point.  If a hit is found, the point is also converted <br>* to coordinates for the hit window. <br>* <br>* There is a special case when hitting controls over a groupbox. <br>* Controls within a groupbox will always be hit instead of the <br>* groupbox itself. <br>* <br>* Arguments: <br>*   HWND hwnd  - Window handle the coordinates are relative to. <br>*   PPOINT ppt - Window point where the click occurred (window coords). <br>* <br>* Returns: <br>*   The hwnd of the "hit" control will be returned.  If no control was hit, <br>*   the hwnd that was passed in is returned. <br>* <br>****************************************************************************/ <br> <br>STATICFN HWND CtrlHitTest( <br>    HWND hwnd, <br>    PPOINT ppt) <br>{ <br>    NPCTYPE npc; <br>    RECT rc; <br>    HWND hwndHit = (HWND)NULL; <br>    BOOL fGroupHit = FALSE; <br> <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        GetWindowRect(npc-&gt;hwnd, &amp;rc); <br>        ScreenToClientRect(npc-&gt;hwnd, &amp;rc); <br>        MyMapWindowRect(npc-&gt;hwnd, hwnd, &amp;rc); <br> <br>        /* <br>         * Is this a hit, and was there either no control hit as <br>         * yet, or this control is not a groupbox, or the control <br>         * that was previously hit was a groupbox also? <br>         */ <br>        if (PtInRect(&amp;rc, *ppt) &amp;&amp; <br>                (!hwndHit || npc-&gt;pwcd-&gt;iType != W_GROUPBOX || fGroupHit)) { <br>            hwndHit = npc-&gt;hwnd; <br>            if (npc-&gt;pwcd-&gt;iType == W_GROUPBOX) <br>                fGroupHit = TRUE; <br>            else <br>                fGroupHit = FALSE; <br>        } <br>    } <br> <br>    if (hwndHit) { <br>        MapWindowPoint(hwnd, hwndHit, ppt); <br>        return hwndHit; <br>    } <br>    else { <br>        return hwnd; <br>    } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* PreDragTimeout <br>* <br>* This function handles the WM_TIMER message from the control window <br>* proc.  It is used so that the dragging of a newly selected control <br>* can be deferred for a small period of time to "debounce" the mouse. <br>* <br>* This function is also called if the mouse is moved too much during the <br>* debounce time, effectively cutting the debounce time short. <br>* <br>* Arguments: <br>*   HWND hwnd      - Window handle the timer came from. <br>*   BOOL fTimedOut - TRUE if the predrag is ending because the timer <br>*                    expired.  FALSE if the predrag is ending because <br>*     the mouse was moved too far. <br>* <br>****************************************************************************/ <br> <br>VOID PreDragTimeout( <br>    HWND hwnd, <br>    BOOL fTimedOut) <br>{ <br>    POINT pt; <br> <br>    /* <br>     * The debounce time is over and the mouse button is still <br>     * down.  Get the current mouse pointer location and go into <br>     * drag mode. <br>     */ <br>    if (gState == STATE_PREDRAG) { <br>        /* <br>         * If we timed out (the mouse was not moved a large distance), <br>         * eat any small movement that may have been done during the <br>         * predrag time by setting the mouse cursor back to the location <br>         * that it started at.  Note that we do not do this if the mouse <br>         * was moved a large distance, because the efect would be <br>         * noticeable for that case, and we want the control to be <br>         * moved then anyways. <br>         */ <br>        if (fTimedOut) { <br>            pt = gptPreDragStart; <br>            ClientToScreen(hwnd, &amp;pt); <br>            SetCursorPos(pt.x, pt.y); <br>        } <br> <br>        DragBegin2(&amp;gptPreDragStart); <br>    } <br> <br>    KillTimer(hwnd, TID_PREDRAG); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CtrlMouseMove <br>* <br>* This routine handles the mouse move messages for controls, the dialog, <br>* drag windows and when dropping a new control. <br>* <br>* During a drag operation, the tracking rectangle will be adjusted. <br>* If there is not a drag operation is effect, the mouse cursor will <br>* be changed to a sizing pointer if it is over a drag handle.  If not <br>* over a drag handle, the pointer will be changed back to the arrow. <br>* <br>* Arguments: <br>*   HWND hwnd        - Window handle the x and y are relative to. <br>*   BOOL fDragWindow - TRUE if hwnd is a drag window. <br>*   INT x            - X location of the mouse movement (window coords). <br>*   INT y            - Y location of the mouse movement (window coords). <br>* <br>************************************************************************/ <br> <br>VOID CtrlMouseMove( <br>    HWND hwnd, <br>    BOOL fDragWindow, <br>    INT x, <br>    INT y) <br>{ <br>    RECT rc; <br>    RECT rc2; <br>    HCURSOR hcur = NULL; <br> <br>    /* <br>     * Discard all mouse messages during certain operations <br>     * (but still set the pointer properly). <br>     */ <br>    if (gfDisabled) { <br>        SetCursor(hcurArrow); <br>        return; <br>    } <br> <br>    switch (gState) { <br>        case STATE_PREDRAG: <br>            /* <br>     * If the mouse was moved too far, consider the <br>             * pre-drag time elapsed and go into drag mode. <br>             */ <br>            if (abs(gptPreDragStart.x - x) &gt; gcxPreDragMax || <br>                    abs(gptPreDragStart.y - y) &gt; gcyPreDragMax) <br>                PreDragTimeout(hwnd, FALSE); <br> <br>            break; <br> <br>        case STATE_DRAGGING: <br>        case STATE_DRAGGINGNEW: <br>            MouseToDragRect(x, y, &amp;rc); <br> <br>            if (!EqualRect(&amp;rc, &amp;grcTrackDU)) { <br>                /* <br>                 * If the tracking rectangle is not shown, this means that <br>                 * this is the first significant mouse move since the start <br>                 * of a drag operation, and we need to lock the window, get <br>                 * our clip DC, etc. <br>                 */ <br>                if (!gfTrackRectShown) <br>                    InitTracking(); <br> <br>                DrawTrackRect(&amp;rc, gfDlgSelected, TRUE); <br> <br>                if (gcSelected &gt; 1) { <br>                    /* <br>                     * Since there are multiple controls selected, <br>                     * rc will be the rectangle that surrounds them <br>                     * all.  We really want to just show the anchor <br>                     * controls new position, so we have to do a <br>                     * little math to calculate and display it. <br>                     */ <br>                    rc2 = gnpcSel-&gt;rc; <br>                    OffsetRect(&amp;rc2, rc.left - grcSelected.left, <br>                            rc.top - grcSelected.top); <br>                    StatusSetCoords(&amp;rc2); <br>                } <br>                else { <br>                    /* <br>                     * Either a single control is being dragged or <br>                     * a new control is being dropped. <br>                     */ <br>                    StatusSetCoords(&amp;rc); <br>                } <br>            } <br> <br>            break; <br> <br>        case STATE_SELECTING: <br>            OutlineSelectDraw(x, y); <br>            break; <br> <br>        default: <br>            /* <br>             * Is there a tool selected? <br>             */ <br>            if (gCurTool != W_NOTHING) { <br>                hcur = hcurDropTool; <br>            } <br>            else { <br>                /* <br>                 * If hwnd is a drag window, see if the pointer is over <br>                 * over any of the handles and change it to one of the <br>                 * sizing pointers if necessary.  Otherwise set the pointer <br>                 * to the default arrow pointer. <br>                 */ <br>                if (fDragWindow) { <br>                    switch (HandleHitTest(hwnd, x, y)) { <br>                        case DRAG_LEFTBOTTOM: <br>                        case DRAG_RIGHTTOP: <br>                            hcur = hcurSizeNESW; <br>                            break; <br> <br>                        case DRAG_LEFTTOP: <br>                        case DRAG_RIGHTBOTTOM: <br>                            hcur = hcurSizeNWSE; <br>                            break; <br> <br>                        case DRAG_BOTTOM: <br>                        case DRAG_TOP: <br>                            hcur = hcurSizeNS; <br>                            break; <br> <br>                        case DRAG_RIGHT: <br>                        case DRAG_LEFT: <br>                            hcur = hcurSizeWE; <br>                            break; <br> <br>                        case DRAG_CENTER: <br>                        default: <br>                            hcur = hcurArrow; <br>                            break; <br>                    } <br>                } <br>                else { <br>                    hcur = hcurArrow; <br>                } <br>            } <br> <br>            break; <br>    } <br> <br>    if (hcur) <br>        SetCursor(hcur); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DragCancel <br>* <br>* This function cancels any drag operation in effect.  It handles <br>* such things as erasing any visible tracking rectangle, freeing any <br>* "copy" data, setting globals and updating the status display.  It <br>* can be used no matter how the drag operation was started. <br>* <br>************************************************************************/ <br> <br>VOID DragCancel(VOID) <br>{ <br>    HWND hwnd; <br> <br>    switch (gState) { <br>        case STATE_PREDRAG: <br>            /* <br>             * Stop the timer.  Note that this assumes the timer <br>             * was attached to the capture window.  This should <br>             * be safe (see the associated SetTimer). <br>             */ <br>            if (hwnd = GetCapture()) <br>                KillTimer(hwnd, TID_PREDRAG); <br> <br>            break; <br> <br>        case STATE_DRAGGING: <br>        case STATE_DRAGGINGNEW: <br>            CancelTracking(); <br> <br>            if (gpResCopy) { <br>                MyFree(gpResCopy); <br>                gpResCopy = NULL; <br>            } <br> <br>            break; <br>    } <br> <br>    gState = STATE_NORMAL; <br>    ReleaseCapture(); <br>    SetCursor(hcurArrow); <br> <br>    StatusUpdate(); <br>    StatusSetEnable(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CtrlButtonUp <br>* <br>* This function is called when the left mouse button is released.  Depending <br>* on the mode, it will complete the operation started when the button <br>* was pressed down. <br>* <br>* Arguments: <br>*   INT x - Mouse X location (in window coords). <br>*   INT y - Mouse Y location (in window coords). <br>* <br>************************************************************************/ <br> <br>VOID CtrlButtonUp( <br>    INT x, <br>    INT y) <br>{ <br>    /* <br>     * Discard all mouse messages during certain operations. <br>     */ <br>    if (gfDisabled) <br>        return; <br> <br>    switch (gState) { <br>        case STATE_PREDRAG: <br>            /* <br>             * They released the mouse button during the debounce time, <br>             * so cancel the drag. <br>             */ <br>            DragCancel(); <br>            break; <br> <br>        case STATE_DRAGGING: <br>        case STATE_DRAGGINGNEW: <br>            DragEnd(x, y); <br>            break; <br> <br>        case STATE_SELECTING: <br>            OutlineSelectEnd(x, y); <br>            break; <br> <br>        default: <br>            break; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DragEnd <br>* <br>* This function completes all kinds of drag operations.  If dragging a <br>* new control, it will be dropped at the specified location.  If dragging <br>* an existing control, it will be positioned to the given location. <br>* <br>* Arguments: <br>*   INT x - X location the control ended up at (in window coords). <br>*   INT y - Y location the control ended up at (in window coords). <br>* <br>************************************************************************/ <br> <br>VOID DragEnd( <br>    INT x, <br>    INT y) <br>{ <br>    PDIALOGBOXHEADER pdbh; <br>    PCONTROLDATA pcd; <br>    INT cControls; <br>    RECT rc; <br>    INT i; <br>    INT cx; <br>    INT cy; <br> </code></pre>
<p>
</p>
<pre><code>CancelTracking(); <br>    MouseToDragRect(x, y, &amp;rc); <br> <br>    if (gState == STATE_DRAGGING) { <br>        PositionControl(&amp;rc); <br>    } <br>    else { <br>        if (gpResCopy) { <br>            pdbh = (PDIALOGBOXHEADER)SkipResHeader(gpResCopy); <br>            cControls = (INT)pdbh-&gt;NumberOfItems; <br>            pcd = SkipDialogBoxHeader(pdbh); <br>            cx = rc.left - grcCopy.left; <br>            cy = rc.top - grcCopy.top; <br> <br>            /* <br>             * Loop through all the controls, adjusting their position <br>             * according to where the drag rectangle ended up. <br>             */ <br>            for (i = 0; i &lt; cControls; i++) { <br>                /* <br>                 * Add cx and cy to the resource's x and y fields. <br>                 */ <br>                pcd-&gt;x += (WORD)cx; <br>                pcd-&gt;y += (WORD)cy; <br> <br>                pcd = SkipControlData(pcd); <br>            } <br> <br>            /* <br>             * Now we go and create all the controls, adding them to <br>             * the current dialog.  It is assumed that the image in <br>             * gpResCopy specifies controls to add, and not a dialog <br>             * to create! <br>             */ <br>            if (ResToDialog(gpResCopy, FALSE)) { <br>                gfResChged = gfDlgChanged = TRUE; <br>                ShowFileStatus(FALSE); <br>            } <br> <br>            MyFree(gpResCopy); <br>            gpResCopy = NULL; <br> <br>            StatusUpdate(); <br>            StatusSetEnable(); <br>        } <br>        else { <br>            /* <br>             * Drop the new control. <br>             */ <br>            DropControl(gpwcdCurTool, &amp;rc); <br> <br>            if (!gfToolLocked) <br>                ToolboxSelectTool(W_NOTHING, FALSE); <br>        } <br>    } <br> <br>    gState = STATE_NORMAL; <br>    ReleaseCapture(); <br>    SetCursor(hcurArrow); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
