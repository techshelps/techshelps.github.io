<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5607"></a>FILE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: file.c <br>* <br>* This file contains the high level routines that begin opening <br>* and saving files. <br>* <br>* Functions: <br>*    Open() <br>*    BuildFilterString() <br>*    DoWeSave() <br>*    Save() <br>*    OpenCmdLineFile() <br>*    FileInPath() <br>*    ShowFileStatus() <br>*    DifferentDirs() <br>*    HasPath() <br>*    WriteDWordPad() <br>*    BuildDefSaveName() <br>*    WriteTheFile() <br>*    FormTempFileName() <br>*    FileCat() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br> <br>#include &lt;wchar.h&gt; <br> <br>#include &lt;commdlg.h&gt; <br> <br> <br>/* <br> * File types. <br> */ <br>#define FILE_RES    0               // Resource (.RES) file. <br>#define FILE_DLG    1               // Dialog (.DLG) file. <br>#define FILE_INC    2               // Include (.H) file. <br> <br>STATICFN VOID BuildDefSaveName(INT FileType, LPTSTR pszFullFileName, <br>    LPTSTR pszFileName, LPTSTR pszOtherFullFileName, LPTSTR pszOtherFileName, <br>    LPTSTR pszFullFileNameBuffer, INT cchBuffer); <br>STATICFN BOOL WriteTheFile(LPTSTR pszFile, INT fmt); <br>STATICFN VOID FormTempFileName(LPTSTR pszBaseName,  LPTSTR pszBuffer); <br>STATICFN VOID FileCat(LPTSTR pchName, LPTSTR pchCat, BOOL fChop); <br> <br> <br> <br>/************************************************************************ <br>* Open <br>* <br>* Handles opening of resource and include files. <br>* Saves current dialog in the resource. <br>* Might put up a message box. <br>* Cancels moves. <br>* Changes szFullResFile, pszResFile, szFullIncludeFile, pszIncludeFile <br>* Puts up dialog boxes. <br>* Restores dialog box from resource. <br>* Sets changed flags. <br>* <br>* Arguments: <br>*   INT FileType - FILE_RESOURCE or FILE_INCLUDE. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>************************************************************************/ <br> <br>BOOL Open( <br>    INT FileType) <br>{ <br>    BOOL fSuccess; <br>    BOOL fGotName; <br>    OPENFILENAME ofn; <br>    TCHAR szNewFileName[CCHMAXPATH]; <br>    TCHAR szInitialDir[CCHMAXPATH]; <br>    TCHAR szFilter[CCHTEXTMAX]; <br>    INT idPrevDlg; <br> <br>    /* <br>     * Cancel any outstanding selection(s). <br>     */ <br>    CancelSelection(TRUE); <br> <br>    /* <br>     * Put current dialog back into the resource buffer. <br>     */ <br>    if (!SynchDialogResource()) <br>        return FALSE; <br> <br>    /* <br>     * Begin setting up the globals and the open file dialog structure. <br>     */ <br>    fSuccess = FALSE; <br>    *szNewFileName = CHAR_NULL; <br> <br>    /* <br>     * Build up the filter string. <br>     */ <br>    BuildFilterString(FileType, szFilter); <br> <br>    ofn.lStructSize = sizeof(ofn); <br>    ofn.hwndOwner = ghwndMain; <br>    ofn.hInstance = NULL; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = szNewFileName; <br>    ofn.nMaxFile = CCHMAXPATH; <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.nMaxFileTitle = 0; <br> <br>    if (FileType == FILE_INCLUDE) { <br>        /* <br>         * If there is a res file, set the default include file <br>         * name to open to be the basename of the res file with <br>         * a .H extension, if such a file exists.  We use szInitialDir <br>         * here as a temporary buffer. <br>         */ <br>        if (pszResFile) { <br>            lstrcpy(szInitialDir, szFullResFile); <br>            FileCat(szInitialDir, ids(IDS_DOTH), TRUE); <br>            if (GetFileAttributes(szInitialDir) != -1) { <br>                lstrcpy(szNewFileName, pszResFile); <br>                FileCat(szNewFileName, ids(IDS_DOTH), TRUE); <br>            } <br>        } <br> <br>        ofn.lpstrTitle = ids(IDS_INCOPENTITLE); <br>        ofn.lpstrDefExt = ids(IDS_INCEXT); <br>    } <br>    else { <br>        ofn.lpstrTitle = ids(IDS_RESOPENTITLE); <br>        ofn.lpstrDefExt = ids(IDS_RESEXT); <br>    } <br> <br>    /* <br>     * If they have already opened one res file, start looking for <br>     * any new files to open in the same directory.  Otherwise, just <br>     * default to the current directory. <br>     */ <br>    if (pszResFile) { <br>        lstrcpy(szInitialDir, szFullResFile); <br>        *FileInPath(szInitialDir) = CHAR_NULL; <br>        ofn.lpstrInitialDir = szInitialDir; <br>    } <br>    else { <br>        ofn.lpstrInitialDir = NULL; <br>    } <br> <br>    ofn.Flags = OFN_HIDEREADONLY | OFN_SHOWHELP | OFN_FILEMUSTEXIST; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = NULL; <br>    ofn.lpTemplateName = NULL; <br> <br>    /* <br>     * Fire off the dialog box to open the file. <br>     */ <br>    EnteringDialog((FileType == FILE_INCLUDE) ? <br>            DID_COMMONFILEOPENINCLUDE : DID_COMMONFILEOPENRES, <br>            &amp;idPrevDlg, TRUE); <br>    fGotName = GetOpenFileName(&amp;ofn); <br>    EnteringDialog(idPrevDlg, NULL, FALSE); <br>    if (fGotName) { <br>        if (FileType == FILE_INCLUDE) { <br>            if (OpenIncludeFile(szNewFileName)) { <br>                /* <br>                 * Since we just loaded a new include file, we mark the <br>                 * resource as changed so that the .RES and .DLG files <br>                 * will be written out with the proper name in the <br>                 * DLGINCLUDE statement. <br>                 */ <br>                gfResChged = TRUE; <br>                fSuccess = TRUE; <br>            } <br>        } <br>        else { <br>            if (OpenResFile(szNewFileName)) <br>                fSuccess = TRUE; <br>        } <br>    } <br> <br>    ShowFileStatus(TRUE); <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* BuildFilterString <br>* <br>* This function creates a filter string to be passed into the <br>* standard file open and save dialogs.  This will be something like: <br>* "Resource (*.res)\0*.res\0\0" <br>* <br>* Arguments: <br>*   INT FileType      - Flags for type of file, FILE_INCLUDE, FILE_RESOURCE <br>*                       or FILE_DLL. <br>*   LPTSTR pszFilter  - Where to return the filter string. <br>* <br>************************************************************************/ <br> <br>VOID BuildFilterString( <br>    INT FileType, <br>    LPTSTR pszFilter) <br>{ <br>    INT idsFileSpecName; <br>    INT idsFileSpec; <br>    LPTSTR psz; <br> <br>    if (FileType &amp; FILE_INCLUDE) { <br>        idsFileSpecName = IDS_DEFINCFILESPECNAME; <br>        idsFileSpec = IDS_DEFINCFILESPEC; <br>    } <br>    else if (FileType &amp; FILE_RESOURCE) { <br>        idsFileSpecName = IDS_DEFRESFILESPECNAME; <br>        idsFileSpec = IDS_DEFRESFILESPEC; <br>    } <br>    else { // Must be a DLL. <br>        idsFileSpecName = IDS_DEFDLLFILESPECNAME; <br>        idsFileSpec = IDS_DEFDLLFILESPEC; <br>    } <br> <br>    /* <br>     * Build up the filter string.  This will be something like: <br>     * "Resource (*.res)\0*.res\0\0" <br>     */ <br>    psz = (LPTSTR)WriteSz(pszFilter, ids(idsFileSpecName)); <br>    psz = (LPTSTR)WriteSz(psz, ids(idsFileSpec)); <br>    *psz = CHAR_NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OpenCmdLineFile <br>* <br>* Handles opening of the resource file specified on the command line. <br>* <br>* Arguments: <br>*   LPTSTR - pointer to the file name string <br>* <br>************************************************************************/ <br> <br>VOID OpenCmdLineFile( <br>    LPTSTR pszFileName) <br>{ <br>    TCHAR szFullPath[CCHMAXPATH]; <br>    LPTSTR pszOnlyFileName; <br> <br>    if (SearchPath(L".", pszFileName, ids(IDS_DOTRES), CCHMAXPATH, <br>            szFullPath, &amp;pszOnlyFileName) == -1) { <br>        Message(MSG_CANTOPENRES, pszFileName); <br>    } <br>    else { <br>        OpenResFile(szFullPath); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DoWeSave <br>* <br>* This function checks to see if the include file or the resource file <br>* needs to be saved.  It first checks the changed flags and if TRUE, <br>* asks the user if they want to save the file.  If they say yes, it <br>* calls Save to do the actual work. <br>* <br>* Arguments: <br>*     INT rgbFlags = FILE_RESOURCE or FILE_INCLUDE (but not both). <br>* <br>* Returns: <br>*     IDYES    - The user wanted to save the file AND the save <br>*                was successful, or the file has not been changed. <br>*     IDNO     - The file had been changed but the user did not <br>*                want it saved. <br>*     IDCANCEL - The file had been changed, and either the user wanted <br>*                it saved and the save failed, or they specified that <br>*                they wanted the operation cancelled. <br>* <br>************************************************************************/ <br> <br>INT DoWeSave( <br>    INT rgbFlags) <br>{ <br>    LPTSTR pszFile; <br>    INT MsgCode; <br>    BOOL fChanged; <br>    INT nRet = IDYES; <br> <br>    /* <br>     * First set variables for current case. <br>     */ <br>    if (rgbFlags &amp; FILE_RESOURCE) { <br>        fChanged = gfResChged; <br>        MsgCode = MSG_CLOSING; <br>        pszFile = pszResFile ? pszResFile : ids(IDS_UNTITLED); <br>    } <br>    else { <br>        fChanged = gfIncChged; <br>        MsgCode = MSG_INCLCLOSING; <br>        pszFile = pszIncludeFile ? pszIncludeFile : ids(IDS_UNTITLED); <br>    } <br> <br>    if (fChanged) { <br>        nRet = Message(MsgCode, pszFile); <br>        if (nRet == IDYES) { <br>            if (!Save(FILE_NOSHOW | rgbFlags)) <br>                nRet = IDCANCEL; <br>        } <br>    } <br> <br>    return nRet; <br>} <br> <br> <br> <br>/************************************************************************ <br>* Save <br>* <br>* Handles all saving of files based on menu choice.  Does a <br>* CancelSelection and a SynchDialogResource. <br>* <br>* Arguments: <br>*     INT rgbFlags - Can include FILE_SHOW, FILE_INCLUDE, FILE_SAVEAS. <br>* <br>* Returns: <br>*     TRUE if the file was saved, FALSE if not. <br>* <br>************************************************************************/ <br> <br>BOOL Save( <br>    INT rgbFlags) <br>{ <br>    OPENFILENAME ofn; <br>    BOOL fGotName; <br>    LPTSTR pszFileName; <br>    LPTSTR pszFileNameDlg; <br>    LPTSTR pszFullFileName; <br>    BOOL fSuccess = FALSE; <br>    TCHAR szInitialDir[CCHMAXPATH]; <br>    TCHAR szSaveFileName[CCHMAXPATH]; <br>    TCHAR szSaveFileNameDlg[CCHMAXPATH]; <br>    TCHAR szFilter[CCHTEXTMAX]; <br>    INT idPrevDlg; <br> <br>    /* <br>     * Put current dialog back into the resource buffer. <br>     */ <br>    if (!SynchDialogResource()) <br>        return FALSE; <br> <br>    /* <br>     * If the file being saved has not been named, force a "Save As". <br>     */ <br>    if ((rgbFlags &amp; FILE_INCLUDE) ? !pszIncludeFile : !pszResFile) <br>        rgbFlags |= FILE_SAVEAS; <br> <br>    if (rgbFlags &amp; FILE_SAVEAS) { <br>        ofn.lStructSize = sizeof(ofn); <br>        ofn.hwndOwner = ghwndMain; <br>        ofn.hInstance = NULL; <br> <br>        /* <br>         * Build up the filter string. <br>         */ <br>        BuildFilterString(rgbFlags, szFilter); <br>        ofn.lpstrFilter = szFilter; <br>        ofn.lpstrCustomFilter = NULL; <br>        ofn.nMaxCustFilter = 0; <br>        ofn.nFilterIndex = 1; <br> <br>        ofn.lpstrFile = szSaveFileName; <br>        ofn.nMaxFile = CCHMAXPATH; <br>        ofn.lpstrFileTitle = NULL; <br>        ofn.nMaxFileTitle = 0; <br> <br>        if (rgbFlags &amp; FILE_INCLUDE) { <br>            ofn.lpstrTitle = ids(IDS_INCSAVETITLE); <br>            ofn.lpstrDefExt = ids(IDS_INCEXT); <br>            BuildDefSaveName(FILE_INCLUDE, <br>                    szFullIncludeFile, pszIncludeFile, <br>                    szFullResFile, pszResFile, <br>                    szInitialDir, CCHMAXPATH); <br>        } <br>        else { <br>            ofn.lpstrTitle = ids(IDS_RESSAVETITLE); <br>            ofn.lpstrDefExt = ids(IDS_RESEXT); <br>            BuildDefSaveName(FILE_RESOURCE, <br>                    szFullResFile, pszResFile, <br>                    szFullIncludeFile, pszIncludeFile, <br>                    szInitialDir, CCHMAXPATH); <br>        } <br> <br>        /* <br>         * At this point, szInitialDir contains the full path to <br>         * the suggested save file name.  Find the end of the path, <br>         * copy just the filename to the file name buffer and cut <br>         * the filename portion off the initial directory buffer. <br>         */ <br>        pszFileName = FileInPath(szInitialDir); <br>        lstrcpy(szSaveFileName, pszFileName); <br>        *pszFileName = CHAR_NULL; <br>        ofn.lpstrInitialDir = szInitialDir; <br> <br>        ofn.Flags = OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY | OFN_SHOWHELP; <br>        ofn.lCustData = 0; <br>        ofn.lpfnHook = NULL; <br>        ofn.lpTemplateName = NULL; <br> <br>        /* <br>         * Fire off the dialog box to get the file name to use. <br>         */ <br>        EnteringDialog((rgbFlags &amp; FILE_INCLUDE) ? <br>                DID_COMMONFILESAVEINCLUDE : DID_COMMONFILESAVERES, <br>                &amp;idPrevDlg, TRUE); <br>        fGotName = GetSaveFileName(&amp;ofn); <br>        EnteringDialog(idPrevDlg, NULL, FALSE); <br>        if (fGotName) { <br>            pszFullFileName = szSaveFileName; <br>            pszFileName = FileInPath(szSaveFileName); <br>            fSuccess = TRUE; <br>        } <br>    } <br>    else { <br>        if (rgbFlags &amp; FILE_INCLUDE) { <br>            pszFileName = pszIncludeFile; <br>            pszFullFileName = szFullIncludeFile; <br>        } <br>        else { <br>            pszFileName = pszResFile; <br>            pszFullFileName = szFullResFile; <br>        } <br> <br>        fSuccess = TRUE; <br>    } <br> <br>    if (fSuccess) { <br>        if (rgbFlags &amp; FILE_INCLUDE) { <br>            /* <br>             * Save include file. <br>             */ <br>            if (!WriteTheFile(pszFullFileName, FILE_INC)) { <br>                Message(MSG_CANTCREATE, pszFileName); <br>                fSuccess = FALSE; <br>            } <br>        } <br>        else { <br>            /* <br>             * Form the same name as the .res file but with <br>             * a .dlg extension. <br>             */ <br>            lstrcpy(szSaveFileNameDlg, pszFullFileName); <br>            pszFileNameDlg = FileInPath(szSaveFileNameDlg); <br>            FileCat(pszFileNameDlg, ids(IDS_DOTDLG), TRUE); <br> <br>            /* <br>             * Save .RES file, then the .DLG file.  It is done <br>             * in this order so that makes wil notice that the <br>             * .dlg file has a newer time stamp than the .res <br>             * and will cause the .res to be rebuilt.  This <br>             * could be necessary to pick up other changes <br>             * in the resources in a project. <br>             */ <br>            if (!WriteTheFile(pszFullFileName, FILE_RES)) { <br>                Message(MSG_CANTCREATE, pszFileName); <br>                fSuccess = FALSE; <br>            } <br>            else if (!WriteTheFile(szSaveFileNameDlg, FILE_DLG)) { <br>                Message(MSG_CANTCREATE, pszFileNameDlg); <br>                fSuccess = FALSE; <br>            } <br>            else { <br>                /* <br>                 * Successfully saved both files.  Update our <br>                 * globals. <br>                 */ <br>                lstrcpy(szFullResFile, pszFullFileName); <br>                pszResFile = FileInPath(szFullResFile); <br>                gfResChged = FALSE; <br>            } <br>        } <br>    } <br> <br>    ShowFileStatus(TRUE); <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* BuildDefSaveName <br>* <br>* This function takes the filenames of the current resource and include <br>* files and builds the default filename that will be shown in the <br>* "Save As" dialog.  If the current file is still untitled, it will <br>* attempt to pick a default name based on the other files name. <br>* <br>* To use, pass in the file type (FILE_RESOURCE or FILE_INCLUDE) and <br>* give the current file name and full file name of both the current <br>* file you are building, and the other type of file.  The following <br>* rules will be followed, in order: <br>* <br>*   1. If the file name is valid (not NULL) and it is either the <br>*      include file we are naming or it is the res file but there <br>*      is no include file, it will copy the full file name to the <br>*      output buffer. <br>* <br>*   2. If the other file name is valid, it will take this name, add the <br>*      appropriate extension and copy it to the output buffer. <br>* <br>*   3. If neither of the file names are valid (they are BOTH untitled), <br>*      it will assume the current directory and make a default file <br>*      name with the appropriate extension. <br>* <br>* Rule 1 is a little complicated, but it's purpose is to make it so <br>* that if a default res file name is being requested, and they changed <br>* the directory and/or name for the include file that was just saved, <br>* the default directory and name for the res file will be the same <br>* directory and base name as the new include file directory and name. <br>* <br>* Arguments: <br>*   INT FileType                 - Either FILE_RESOURE or FILE_INCLUDE. <br>*   LPTSTR pszFullFileName       - The full file name.  This will only <br>*                                  be used if pszFileName is not NULL. <br>*   LPTSTR pszFileName           - File name to use, or NULL if it is <br>*                                  currently untitled. <br>*   LPTSTR pszOtherFullFileName  - Full file name of the other file.  Only <br>*                                  considered valid if pszOtherFileName is <br>*                                  not NULL. <br>*   LPTSTR pszOtherFileName      - File name of the other file, or NULL if <br>*                                  it is untitled. <br>*   LPTSTR pszFullFileNameBuffer - Where to put the full file name. <br>*   INT cchBuffer                - Size of the buffer in characters. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID BuildDefSaveName( <br>    INT FileType, <br>    LPTSTR pszFullFileName, <br>    LPTSTR pszFileName, <br>    LPTSTR pszOtherFullFileName, <br>    LPTSTR pszOtherFileName, <br>    LPTSTR pszFullFileNameBuffer, <br>    INT cchBuffer) <br>{ <br>    TCHAR szBuffer[CCHMAXPATH]; <br> <br>    if (pszFileName &amp;&amp; (FileType == FILE_INCLUDE || !pszOtherFileName)) { <br>        /* <br>         * Simple case.  The file already has a title. <br>         */ <br>        lstrcpy(pszFullFileNameBuffer, pszFullFileName); <br>    } <br>    else if (pszOtherFileName) { <br>        /* <br>         * Copy the other files name and add the proper extension. <br>         */ <br>        lstrcpy(pszFullFileNameBuffer, pszOtherFullFileName); <br>        FileCat(pszFullFileNameBuffer, <br>                (FileType == FILE_INCLUDE) ? ids(IDS_DOTH) : <br>                ids(IDS_DOTRES), TRUE); <br>    } <br>    else { <br>        /* <br>         * Pick a default name in the current directory and <br>         * add the proper extension. <br>         */ <br>        lstrcpy(szBuffer, ids(IDS_DEFSAVENAME)); <br>        FileCat(szBuffer, <br>                (FileType == FILE_INCLUDE) ? ids(IDS_DOTH) : <br>                ids(IDS_DOTRES), TRUE); <br>        GetFullPathName(szBuffer, cchBuffer, pszFullFileNameBuffer, NULL); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteTheFile <br>* <br>* This function accepts a pointer to a resource buffer and a format <br>* type.  It writes the buffer out in the appropriate format.  It <br>* gets the file name from pszFile, adding the appropriate extension <br>* for the type of file.  The file is first written to a temporary file <br>* then the old file is removed and finally the new file is renamed. <br>* <br>* Arguments: <br>*   LPTSTR pszFile  - The name to save to. <br>*   INT fmt         - format to write the buffer out in, <br>*                     FILE_RES, FILE_INC or FILE_DLG. <br>* <br>* Returns: <br>*     TRUE =&gt; File successfully written. <br>*     FALSE =&gt; Failure in writing file. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteTheFile( <br>    LPTSTR pszFile, <br>    INT fmt) <br>{ <br>    TCHAR szTempFile[CCHMAXPATH]; /* Used for temporary filename            */ <br>    TCHAR szSrcFile[CCHMAXPATH];  /* Source file with proper extension      */ <br>    HANDLE hfWrite; <br>    HCURSOR hcurSave; <br>    BOOL fSuccess = FALSE; <br>    WORD idsExt; <br> <br>    hcurSave = SetCursor(hcurWait); <br> <br>    switch (fmt) { <br>        case FILE_RES: <br>            idsExt = IDS_DOTRES; <br>            break; <br> <br>        case FILE_DLG: <br>            idsExt = IDS_DOTDLG; <br>            break; <br> <br>        case FILE_INC: <br>            idsExt = IDS_DOTH; <br>            break; <br>    } <br> <br>    /* <br>     * Append appropriate file name extension. <br>     */ <br>    lstrcpy(szSrcFile, pszFile); <br>    FileCat(szSrcFile, ids(idsExt), fmt == FILE_DLG ? TRUE : FALSE); <br> <br>    /* <br>     * Generate appropriate temporary file name in the same directory. <br>     * It is done in the same directory so that a simple rename can <br>     * be done later. <br>     */ <br>    FormTempFileName(szSrcFile, szTempFile); <br> <br>    if ((hfWrite = CreateFile(szTempFile, GENERIC_READ | GENERIC_WRITE, <br>            FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, <br>            NULL)) == (HANDLE)-1) <br>        goto Exit; <br> <br>    switch (fmt) { <br>        case FILE_RES: <br>            if (!WriteRes(hfWrite, szSrcFile)) <br>                goto CloseAndExit; <br> <br>            break; <br> <br>        case FILE_DLG: <br>            if (!WriteDlg(hfWrite, szSrcFile)) <br>                goto CloseAndExit; <br> <br>            break; <br> <br>        case FILE_INC: <br>            if (!WriteInc(hfWrite)) <br>                goto CloseAndExit; <br> <br>            break; <br>    } <br> <br>    CloseHandle((HANDLE)hfWrite); <br>    DeleteFile(szSrcFile); <br>    if (!MoveFile(szTempFile, szSrcFile)) { <br>        DeleteFile(szTempFile); <br>        goto Exit; <br>    } <br> <br>    fSuccess = TRUE; <br> <br>    /* <br>     * If we just wrote to the include file, read it to get the new <br>     * file offsets, etc. <br>     */ <br>    if (fmt == FILE_INC) { <br>        if (!OpenIncludeFile(szSrcFile)) <br>            fSuccess = FALSE; <br>    } <br> <br>Exit: <br>    SetCursor(hcurSave); <br>    return fSuccess; <br> <br>CloseAndExit: <br>    CloseHandle(hfWrite); <br>    DeleteFile(szTempFile); <br>    SetCursor(hcurSave); <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* FormTempFileName <br>* <br>* This function forms a temporary file name in the provided string. <br>* The provided string is assumed to have been filled with a filename <br>* that includes a path.  The temp file will be created in the same <br>* directory as the file that is currently in the string. <br>* <br>* Arguments: <br>*   LPTSTR pszBaseName - The base name (a filename that includes a path). <br>*   LPTSTR pszBuffer   - Where to return the <br>* <br>************************************************************************/ <br> <br>STATICFN VOID FormTempFileName( <br>    LPTSTR pszBaseName, <br>    LPTSTR pszBuffer) <br>{ <br>    TCHAR szBuffer[CCHMAXPATH]; <br>    LPTSTR psz; <br> <br>    /* <br>     * Cut the base file name down to just the path portion. <br>     */ <br>    lstrcpy(szBuffer, pszBaseName); <br>    psz = FileInPath(szBuffer); <br>    psz--; <br>    *psz = TEXT('\0'); <br> <br>    /* <br>     * Create a temporary file in the same directory. <br>     */ <br>    GetTempFileName(szBuffer, L"dlg", 0, pszBuffer); <br>} <br> <br> <br> <br>/************************************************************************ <br>* FileInPath <br>* <br>* This function takes a path and returns a pointer to the file name <br>* portion of it.  For instance, it will return a pointer to <br>* "abc.res" if it is given the following path: "c:\windows\abc.res". <br>* <br>* Arguments: <br>*   LPTSTR pszPath - Path to look through. <br>* <br>************************************************************************/ <br> <br>LPTSTR FileInPath( <br>    LPTSTR pszPath) <br>{ <br>    LPTSTR psz; <br> <br>    psz = pszPath + lstrlen(pszPath); <br>    while (psz &gt; pszPath) { <br>        psz--; <br>        if (*psz == CHAR_BACKSLASH || *psz == CHAR_COLON) { <br>            psz++; <br>            break; <br>        } <br>    } <br> <br>    return psz; <br>} <br> <br> <br> <br>/************************************************************************ <br>* FileCat <br>* <br>* This function puts the extension pchCat on the file spec pch. <br>* If fChop, this is done regardless of whether pch has an extension <br>* or not (replacing the old extension).  Otherwise, pchCat is added <br>* only if there is no extension on the spec pch. <br>* <br>* Arguments: <br>*     LPTSTR pch        - The file spec to "cat" the extension to. <br>*     LPTSTR pchCat     - The extension to "cat" on to pch, <br>*                         including the '.' <br>* <br>************************************************************************/ <br> <br>STATICFN VOID FileCat( <br>    LPTSTR pchName, <br>    LPTSTR pchCat, <br>    BOOL fChop) <br>{ <br>    LPTSTR pch; <br> <br>    pch = pchName + lstrlen(pchName); <br>    pch--; <br> <br>    /* back up to '.' or '\\' */ <br>    while (*pch != CHAR_DOT) { <br>        if (*pch == CHAR_BACKSLASH || pch &lt;= pchName) { <br>            /* no extension, add one */ <br>            lstrcat(pchName, pchCat); <br>            return; <br>        } <br> <br>        pch--; <br>    } <br> <br>    if (fChop) <br>        lstrcpy(pch, pchCat); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ShowFileStatus <br>* <br>* This function displays the title of the Dialog Editor, along with <br>* the file names for the RES and H files with asterisks if they have <br>* changed.  It displays this information only if one of these items <br>* has changed or if fForce is TRUE. <br>* <br>* Arguments: <br>*   BOOL fForce - TRUE if the title should be updated even if the value <br>*                 of gfResChged or gfIncChged has not changed since the <br>*                 last call.  This function should be called with fForce <br>*                 equal to TRUE if it is known that one of the file names <br>*                 has just been changed. <br>* <br>************************************************************************/ <br> <br>VOID ShowFileStatus( <br>    BOOL fForce) <br>{ <br>    static BOOL fResChgedSave = FALSE; <br>    static BOOL fIncChgedSave = FALSE; <br>    TCHAR szTitle[CCHTEXTMAX]; <br> <br>    if (gfResChged != fResChgedSave || gfIncChged != fIncChgedSave || <br>            fForce) { <br>        lstrcpy(szTitle, ids(IDS_DLGEDIT)); <br>        lstrcat(szTitle, L" - "); <br>        lstrcat(szTitle, pszResFile ? pszResFile : ids(IDS_UNTITLED)); <br>        if (gfResChged) <br>            lstrcat(szTitle, L"*"); <br> <br>        lstrcat(szTitle, L", "); <br>        lstrcat(szTitle, pszIncludeFile ? pszIncludeFile : ids(IDS_UNTITLED)); <br>        if (gfIncChged) <br>            lstrcat(szTitle, L"*"); <br> <br>        SetWindowText(ghwndMain, szTitle); <br> <br>        fResChgedSave = gfResChged; <br>        fIncChgedSave = gfIncChged; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DifferentDirs <br>* <br>* This function returns TRUE if the given full paths are to files <br>* that are in different directories. <br>* <br>* Arguments: <br>*   LPTSTR pszPath1 - First path. <br>*   LPTSTR pszPath2 - Second path. <br>* <br>************************************************************************/ <br> <br>BOOL DifferentDirs( <br>    LPTSTR pszPath1, <br>    LPTSTR pszPath2) <br>{ <br>    INT nLen1; <br>    INT nLen2; <br>    LPTSTR pszFile1; <br>    LPTSTR pszFile2; <br> <br>    pszFile1 = FileInPath(pszPath1); <br>    pszFile2 = FileInPath(pszPath2); <br> <br>    nLen1 = lstrlen(pszPath1) - lstrlen(pszFile1); <br>    nLen2 = lstrlen(pszPath2) - lstrlen(pszFile2); <br>    if (nLen1 != nLen2 || _wcsnicmp(pszPath1, pszPath2, nLen1) != 0) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* HasPath <br>* <br>* This function returns TRUE if the given filespec includes a path <br>* specification.  It returns false if it is a filename without a <br>* path. <br>* <br>* A filespec is considered to have a path if a backslash character (\) <br>* is found in it. <br>* <br>* Arguments: <br>*   LPTSTR pszFileSpec - File spec to check. <br>* <br>************************************************************************/ <br> <br>BOOL HasPath( <br>    LPTSTR pszFileSpec) <br>{ <br>    LPTSTR psz; <br> <br>    for (psz = pszFileSpec; *psz; psz = CharNext(psz)) <br>        if (*psz == CHAR_BACKSLASH) <br>            return TRUE; <br>    return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDWordPad <br>* <br>* This function writes nulls to the specified file until it is <br>* dword aligned.  If the file is already dword aligned, nothing <br>* will be written. <br>* <br>* Arguments: <br>*   HANDLE hf    - The file to write to. <br>*   DWORD cbFile - Where the file pointer is at in the file. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>* <br>************************************************************************/ <br> <br>BOOL WriteDWordPad( <br>    HANDLE hf, <br>    DWORD cbFile) <br>{ <br>    static BYTE Buf[3] = {0, 0, 0}; <br>    WORD cb; <br> <br>    cb = (WORD)((4 - (((WORD)cbFile) &amp; 3)) % 4); <br>    if (cb) { <br>        if (_lwrite((HFILE)hf, (LPSTR)Buf, cb) == -1) <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
