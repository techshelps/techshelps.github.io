<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GROUPDLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5609"></a>GROUPDLG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: groupdlg.c <br>* <br>* This module handles the "Group Controls" dialog, which changes the <br>* logical order and grouping of controls in the dialog. <br>* <br>* <br>* Functions: <br>*   OrderGroupDialog() <br>*   OrderDlgProc() <br>*   OrderDlgInit() <br>*   OrderDlgFillList() <br>*   OrderDlgLBWndProc() <br>*   OrderDlgInsertHitTest() <br>*   OrderDlgEnableControls() <br>*   OrderDlgSelChange() <br>*   OrderDlgMakeGroup() <br>*   OrderDlgMarkGroupEnds() <br>*   OrderDlgSetTabs() <br>*   OrderDlgClearTabs() <br>*   OrderDlgToggleTab() <br>*   OrderDlgReorder() <br>*   OrderDlgDrawItem() <br>*   OrderWindows() <br>*   IsListChanged() <br>* <br>* <br>* Comments: <br>* <br>* Note that once a control has either it's WS_TABSTOP or WS_GROUP style <br>* bit changed by this dialog, the style of the actual control in work <br>* mode is not changed.  This should not be a problem, however, because <br>* the appearance of controls does not change based on these styles, and <br>* the saved resource and the Test mode dialog WILL have the proper styles <br>* set in them. <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br>#include "dlghelp.h" <br> <br>/* <br> * Various constants for sizes of items in the list box (in pixels). <br> * Note that if the size of the bitmaps in the .bmp files change, <br> * these defines must be adjusted to match! <br> */ <br>#define CYORDERDLGLINE      18  // Height of a line. <br>#define CXTABBMP            10  // Width of the tabstop bmp. <br>#define CYTABBMP            16  // Height of the tabstop bmp. <br>#define CXTYPEBMP           16  // Width of a control type bitmap. <br>#define CYTYPEBMP           14  // Height of a control type bitmap. <br> <br>/* <br> * Structure for ordering the controls into a new order. <br> */ <br>typedef struct { <br>    INT wNewOrder;                  // Indexes in the new order. <br>    WORD fTaken:1;                  // TRUE if this item has been copied. <br>    WORD fSelected:1;               // TRUE if this item is selected. <br>} NEWORDER, *PNEWORDER; <br> <br>STATICFN VOID OrderDlgInit(HWND hwnd); <br>STATICFN VOID OrderDlgFillList(VOID); <br>WINDOWPROC OrderDlgLBWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>STATICFN BOOL OrderDlgInsertHitTest(INT y, PINT piInsert); <br>STATICFN VOID OrderDlgEnableControls(VOID); <br>STATICFN VOID OrderDlgSelChange(VOID); <br>STATICFN VOID OrderDlgMakeGroup(VOID); <br>STATICFN VOID OrderDlgMarkGroupEnds(VOID); <br>STATICFN VOID OrderDlgSetTabs(VOID); <br>STATICFN VOID OrderDlgClearTabs(VOID); <br>STATICFN VOID OrderDlgToggleTab(INT y); <br>STATICFN VOID OrderDlgReorder(INT iInsert); <br>STATICFN VOID OrderDlgDrawItem(LPDRAWITEMSTRUCT lpdis); <br>STATICFN VOID OrderWindows(VOID); <br>STATICFN BOOL IsListChanged(VOID); <br> <br>static HWND hwndOrderDlg;           // Window handle of the Order/Group dlg. <br>static HWND hwndOrderList;          // Window handle of the list box. <br>static NPCTYPE *anpcSave;           // Points to array of controls in old order. <br>static PDWORD aflStyleSave;         // Points to array of original styles. <br>static PINT aiSelItem;              // Points to array of selected items. <br>static BOOL fContiguousSel;         // TRUE if selection in LB is contiguous. <br>static PNEWORDER aNewOrder;         // Points to array with new control order. <br>static INT cSelItems;               // Count of selected items in the array. <br>static WNDPROC lpfnOldLBWndProc;    // Original list box window proc. <br> <br> <br> <br>/************************************************************************ <br>* OrderGroupDialog <br>* <br>* This function puts up the Order/Group dialog box. <br>* Any move is cancelled. <br>* The Order/Group dialog box is put up. <br>* The child windows are reordered and group and tabstop bits set. <br>* File change is noted. <br>* <br>************************************************************************/ <br> <br>VOID OrderGroupDialog(VOID) <br>{ <br>    NPCTYPE npc; <br>    INT i; <br> <br>    /* <br>     * Nothing to order.  This also protects some calculations below. <br>     */ <br>    if (!cWindows) <br>        return; <br> <br>    if (!(anpcSave = (NPCTYPE *)MyAlloc(cWindows * sizeof(NPCTYPE)))) <br>        return; <br> <br>    /* <br>     * Allocate an array of indexes for selected items.  Make it large <br>     * enough to handle selecting all of the items in the list. <br>     */ <br>    if (!(aiSelItem = (PINT)MyAlloc(cWindows * sizeof(INT)))) { <br>        MyFree(anpcSave); <br>        return; <br>    } <br> <br>    /* <br>     * Allocate an array to save the original styles in. <br>     */ <br>    if (!(aflStyleSave = (PDWORD)MyAlloc(cWindows * sizeof(DWORD)))) { <br>        MyFree(anpcSave); <br>        MyFree(aiSelItem); <br>        return; <br>    } <br> <br>    if (!(aNewOrder = (PNEWORDER)MyAlloc(cWindows * sizeof(NEWORDER)))) { <br>        MyFree(aflStyleSave); <br>        MyFree(anpcSave); <br>        MyFree(aiSelItem); <br>        return; <br>    } <br> <br>    CancelSelection(TRUE); <br> <br>    /* <br>     * Save the original order of the controls, and their styles. <br>     */ <br>    for (i = 0, npc = npcHead; npc; i++, npc = npc-&gt;npcNext) { <br>        anpcSave[i] = npc; <br>        aflStyleSave[i] = npc-&gt;flStyle; <br>    } <br> <br>    if (DlgBox(DID_ORDERGROUP, (WNDPROC)OrderDlgProc) == IDOK) { <br>        if (IsListChanged()) { <br>            gfResChged = gfDlgChanged = TRUE; <br>            ShowFileStatus(FALSE); <br>        } <br> <br>        OrderWindows(); <br>    } <br>    else { <br>        /* <br>         * Restore the linked list to the order that it originally was. <br>         */ <br>        npcHead = anpcSave[0]; <br>        for (i = 0; i &lt; cWindows - 1; i++) <br>            (anpcSave[i])-&gt;npcNext = anpcSave[i + 1]; <br>        (anpcSave[i])-&gt;npcNext = NULL; <br> <br>        /* <br>         * Then restore the styles to the way that they were. <br>         */ <br>        for (i = 0, npc = npcHead; npc; i++, npc = npc-&gt;npcNext) <br>            npc-&gt;flStyle = aflStyleSave[i]; <br>    } <br> <br>    MyFree(aNewOrder); <br>    MyFree(aflStyleSave); <br>    MyFree(aiSelItem); <br>    MyFree(anpcSave); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgProc <br>* <br>* This is the dialog function for the group ordering dialog box. <br>* <br>************************************************************************/ <br> <br>DIALOGPROC OrderDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            OrderDlgInit(hwnd); <br>            return TRUE; <br> <br>        case WM_MEASUREITEM: <br>            ((LPMEASUREITEMSTRUCT)lParam)-&gt;itemHeight = CYORDERDLGLINE; <br>            return TRUE; <br> <br>        case WM_DRAWITEM: <br>            OrderDlgDrawItem((LPDRAWITEMSTRUCT)lParam); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case DID_ORDERLIST: <br>                    switch (HIWORD(wParam)) { <br>                        case LBN_SELCHANGE: <br>                            OrderDlgSelChange(); <br>                            break; <br>                    } <br> <br>                    break; <br> <br>                case DID_ORDERMAKEGROUP: <br>                    OrderDlgMakeGroup(); <br>                    break; <br> <br>                case DID_ORDERSETTAB: <br>                    OrderDlgSetTabs(); <br>                    break; <br> <br>                case DID_ORDERCLEARTAB: <br>                    OrderDlgClearTabs(); <br>                    break; <br> <br>                case IDCANCEL: <br>                case IDOK: <br>                    EndDialog(hwnd, LOWORD(wParam)); <br>                    break; <br> <br>                case IDHELP: <br>                    WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, <br>                            HELPID_ORDERGROUP); <br>                    break; <br>            } <br> <br>            return TRUE; <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgInit <br>* <br>* Initializes the Order/Group dialog. <br>* <br>* Arguments: <br>*     HWND hwnd = The dialog window handle. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgInit( <br>    HWND hwnd) <br>{ <br>    hwndOrderDlg = hwnd; <br>    hwndOrderList = GetDlgItem(hwnd, DID_ORDERLIST); <br> <br>    lpfnOldLBWndProc = (WNDPROC)SetWindowLong(hwndOrderList, <br>            GWL_WNDPROC, (DWORD)OrderDlgLBWndProc); <br> <br>    OrderDlgFillList(); <br>    OrderDlgMarkGroupEnds(); <br>    OrderDlgSelChange(); <br> <br>    CenterWindow(hwnd); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgFillList <br>* <br>* Fill the order listbox <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgFillList(VOID) <br>{ <br>    NPCTYPE npc; <br> <br>    SendMessage(hwndOrderList, LB_RESETCONTENT, 0, 0L); <br> <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) <br>        SendMessage(hwndOrderList, LB_INSERTSTRING, (WPARAM)-1, (DWORD)npc); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgLBWndProc <br>* <br>* window procedure for the left button <br>* <br>************************************************************************/ <br> <br>WINDOWPROC OrderDlgLBWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    INT iInsert; <br> <br>    switch (msg) { <br>        case WM_SETCURSOR: <br>            /* <br>             * Defeat the system changing cursors on us in the client area. <br>             */ <br>            if (LOWORD(lParam) == HTCLIENT) <br>                return TRUE; <br> <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            if (!(GetKeyState(VK_LBUTTON) &amp; 0x8000) &amp;&amp; <br>                    OrderDlgInsertHitTest(HIWORD(lParam), &amp;iInsert)) <br>                SetCursor(hcurInsert); <br>            else <br>                SetCursor(hcurArrow); <br> <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            if (OrderDlgInsertHitTest(HIWORD(lParam), &amp;iInsert)) { <br>                OrderDlgReorder(iInsert); <br>                return FALSE; <br>            } <br> <br>            break; <br> <br>        case WM_LBUTTONDBLCLK: <br>            if (!OrderDlgInsertHitTest(HIWORD(lParam), &amp;iInsert)) { <br>                OrderDlgToggleTab(HIWORD(lParam)); <br>                return FALSE; <br>            } <br> <br>            break; <br>    } <br> <br>    return CallWindowProc((WNDPROC)lpfnOldLBWndProc, <br>            hwnd, msg, wParam, lParam); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgInsertHitTest <br>* <br>* Inserts item in list box <br>* <br>* Arguments: <br>*   INT - the y coordinate of the mouse hit <br>*   PINT - pointer to insertion point <br>* <br>* Returns: <br>*   Where the mouse hit in the listbox <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL OrderDlgInsertHitTest( <br>    INT y, <br>    PINT piInsert) <br>{ <br>    INT i; <br>    INT iPixel; <br>    INT iInsert; <br>    INT iLine; <br>    BOOL fInsertZone; <br> <br>    /* <br>     * Cannot insert if nothing is selected. <br>     */ <br>    if (!cSelItems) <br>        return FALSE; <br> <br>    /* <br>     * Find which pixel it hit. <br>     */ <br>    iPixel = y % CYORDERDLGLINE; <br> <br>    /* <br>     * Determine if they are in the upper or lower insert zones. <br>     */ <br>    if (iPixel &lt; 3) { <br>        iLine = y / CYORDERDLGLINE; <br>        fInsertZone = TRUE; <br>    } <br>    else if (iPixel &gt; CYORDERDLGLINE - 3) { <br>        iLine = (y / CYORDERDLGLINE) + 1; <br>        fInsertZone = TRUE; <br>    } <br>    else { <br>        fInsertZone = FALSE; <br>    } <br> <br>    if (fInsertZone) { <br>        /* <br>         * Do some math, taking into account the top index of the <br>         * listbox, to determine which line they are inserting into. <br>         */ <br>        iInsert = iLine + (INT)SendMessage(hwndOrderList, <br>                LB_GETTOPINDEX, 0, 0L); <br> <br>        /* <br> * If we are too far down the listbox, act as if we are not <br>         * in the insert zone. <br>         */ <br>        if (iInsert &gt; cWindows) { <br>            fInsertZone = FALSE; <br>        } <br>        else { <br>            /* <br>             * Check for whether the cursor was inside a selected <br>             * area.  If it is, we don't allow inserting there <br>             * (because it is a noop).  However, if the selection <br>             * is discontiguous, we always allow inserting, because <br>             * inserting at any point with a discontiguous selection <br>             * will always cause something to happen, even if it <br>             * is just gathering the selection together. <br>             */ <br>            if (fContiguousSel) { <br>                for (i = 0; i &lt; cSelItems; i++) { <br>                    if (aiSelItem[i] == iInsert || <br>                            aiSelItem[i] == iInsert - 1) <br>                        return FALSE; <br>                } <br>            } <br> <br>            *piInsert = iInsert; <br>        } <br>    } <br> <br>    return fInsertZone; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgEnableControls <br>* <br>* Enable items in order dialog <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgEnableControls(VOID) <br>{ <br>    NPCTYPE npc; <br>    BOOL fEnableSetTab = FALSE; <br>    BOOL fEnableClearTab = FALSE; <br>    INT i; <br> <br>    if (cSelItems) { <br>        /* <br>         * Walk through all the selected items.  We will enable the <br>         * set/clear tab buttons based on whether there are any tabs <br>         * to set/clear in the current selection. <br>         */ <br>        for (i = 0; i &lt; cSelItems &amp;&amp; (!fEnableSetTab || !fEnableClearTab); i++) { <br>            npc = (NPCTYPE)SendMessage( <br>                    hwndOrderList, LB_GETITEMDATA, aiSelItem[i], 0L); <br> <br>            if (npc-&gt;flStyle &amp; WS_TABSTOP) <br>                fEnableClearTab = TRUE; <br>            else <br>                fEnableSetTab = TRUE; <br>        } <br>    } <br> <br>    /* <br>     * Normally, if there is a selection we enable "Make Group", <br>     * but if the selection is not contiguous, we disable it. <br>     */ <br>    EnableWindow(GetDlgItem(hwndOrderDlg, DID_ORDERMAKEGROUP), <br>            cSelItems &amp;&amp; fContiguousSel); <br> <br>    EnableWindow(GetDlgItem(hwndOrderDlg, DID_ORDERSETTAB), <br>            fEnableSetTab); <br>    EnableWindow(GetDlgItem(hwndOrderDlg, DID_ORDERCLEARTAB), <br>            fEnableClearTab); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgSelChange <br>* <br>* get selection change in order dialog <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgSelChange(VOID) <br>{ <br>    INT i; <br> <br>    cSelItems = (INT)SendMessage(hwndOrderList, LB_GETSELITEMS, <br>            cWindows, (DWORD)aiSelItem); <br> <br>    /* <br>     * Set a flag saying whether the selection is contiguous or not. <br>     */ <br>    fContiguousSel = TRUE; <br>    if (cSelItems &gt; 1) { <br>        for (i = 1; i &lt; cSelItems; i++) { <br>            if (aiSelItem[i] != aiSelItem[i - 1] + 1) { <br>                fContiguousSel = FALSE; <br>                break; <br>            } <br>        } <br>    } <br> <br>    OrderDlgEnableControls(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgMakeGroup <br>* <br>* Creates a group <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgMakeGroup(VOID) <br>{ <br>    INT i; <br>    NPCTYPE npc; <br> <br>    for (i = 0; i &lt; cSelItems; i++) { <br>        npc = (NPCTYPE)SendMessage( <br>                hwndOrderList, LB_GETITEMDATA, aiSelItem[i], 0L); <br> <br>        /* <br>         * Set the WS_GROUP style on the first selected control <br>         * and clear it from all others. <br>         */ <br>        if (i == 0) <br>            npc-&gt;flStyle |= WS_GROUP; <br>        else <br>            npc-&gt;flStyle &amp;= ~WS_GROUP; <br> <br>        /* <br>         * Are we on the last selected item and is this item not the <br>         * very last item in the list?  If so, set the "group" style <br>         * on the next control. <br>         */ <br>        if (i == cSelItems - 1 &amp;&amp; aiSelItem[i] &lt; cWindows - 1) { <br>            npc = (NPCTYPE)SendMessage( <br>                    hwndOrderList, LB_GETITEMDATA, aiSelItem[i] + 1, 0L); <br>            npc-&gt;flStyle |= WS_GROUP; <br>        } <br>    } <br> <br>    OrderDlgMarkGroupEnds(); <br>    OrderDlgEnableControls(); <br>    InvalidateRect(hwndOrderList, NULL, FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgMarkGroupEnds <br>* <br>* Set the end for the items in the group <br>* <br>* Arguments: <br>*     HWND hwnd = The dialog window handle. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgMarkGroupEnds(VOID) <br>{ <br>    NPCTYPE npc; <br>    NPCTYPE npcPrev; <br> <br>    for (npc = npcHead, npcPrev = NULL; npc; <br>            npcPrev = npc, npc = npc-&gt;npcNext) { <br>        npc-&gt;fGroupEnd = FALSE; <br> <br>        if ((npc-&gt;flStyle &amp; WS_GROUP) &amp;&amp; npcPrev) <br>            npcPrev-&gt;fGroupEnd = TRUE; <br>    } <br> <br>    if (npcPrev) <br>        npcPrev-&gt;fGroupEnd = TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgSetTabs <br>* <br>* Set WS_TABSTOP behavior for group <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgSetTabs(VOID) <br>{ <br>    INT i; <br>    NPCTYPE npc; <br> <br>    for (i = 0; i &lt; cSelItems; i++) { <br>        npc = (NPCTYPE)SendMessage(hwndOrderList, LB_GETITEMDATA, aiSelItem[i], 0L); <br> <br>        npc-&gt;flStyle |= WS_TABSTOP; <br>    } <br> <br>    OrderDlgEnableControls(); <br>    InvalidateRect(hwndOrderList, NULL, FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgClearTabs <br>* <br>* Clear WS_TABSTOPS for group items. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgClearTabs(VOID) <br>{ <br>    INT i; <br>    NPCTYPE npc; <br> <br>    for (i = 0; i &lt; cSelItems; i++) { <br>        npc = (NPCTYPE)SendMessage(hwndOrderList, LB_GETITEMDATA, aiSelItem[i], 0L); <br> <br>        npc-&gt;flStyle &amp;= ~WS_TABSTOP; <br>    } <br> <br>    OrderDlgEnableControls(); <br>    InvalidateRect(hwndOrderList, NULL, FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgToggleTab <br>* <br>* Toggle to WS_TABSTOP attribute for the selected item <br>* <br>* Arguments: <br>*   INT - the y coordinate of the item that was selected <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgToggleTab( <br>    INT y) <br>{ <br>    NPCTYPE npc; <br>    RECT rcItem; <br>    INT iLine; <br> <br>    /* <br>     * Determine which item was clicked on. <br>     */ <br>    iLine = (y / CYORDERDLGLINE) + <br>            (INT)SendMessage(hwndOrderList, LB_GETTOPINDEX, 0, 0L); <br> <br>    /* <br>     * If it is a valid item (it was not in the white space below <br>     * all the listbox items), then toggle the WS_TABSTOP style on <br>     * it and update the display. <br>     */ <br>    if (iLine &lt; cWindows) { <br>        npc = (NPCTYPE)SendMessage(hwndOrderList, LB_GETITEMDATA, iLine, 0L); <br>        npc-&gt;flStyle ^= WS_TABSTOP; <br> <br>        OrderDlgEnableControls(); <br>        SendMessage(hwndOrderList, LB_GETITEMRECT, <br>                iLine, (DWORD)(LPRECT)&amp;rcItem); <br>        InvalidateRect(hwndOrderList, &amp;rcItem, FALSE); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgReorder <br>* <br>* Inserts a new item at the point indicated <br>* <br>* Arguments: <br>*   INT iInsert - Index of where to insert the selection. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgReorder( <br>    INT iInsert) <br>{ <br>    INT i; <br>    INT j; <br>    INT iNewSelStart; <br>    INT iNewSelEnd; <br>    INT iTopIndex; <br>    INT iNew = 0; <br>    NPCTYPE npc; <br>    NPCTYPE npcPrev; <br> <br>    /* <br>     * If there is nothing selected or there is only one item, the <br>     * order cannot change so we just return. <br>     */ <br>    if (!cSelItems || cWindows &lt; 2) <br>        return; <br> <br>    iTopIndex = (INT)SendMessage(hwndOrderList, LB_GETTOPINDEX, 0, 0L); <br> <br>    for (i = 0; i &lt; cWindows; i++) { <br>        aNewOrder[i].fTaken = FALSE; <br>        aNewOrder[i].fSelected = FALSE; <br>    } <br> <br>    for (i = 0; i &lt; cSelItems; i++) <br>        aNewOrder[aiSelItem[i]].fSelected = TRUE; <br> <br>    for (j = 0; j &lt; iInsert; j++) { <br>        if (aNewOrder[j].fSelected == FALSE) <br>            aNewOrder[iNew++].wNewOrder = j; <br>    } <br> <br>    iNewSelStart = iNew; <br> <br>    for (i = 0; i &lt; cWindows; i++) { <br>        if (aNewOrder[i].fSelected) { <br>            aNewOrder[iNew++].wNewOrder = i; <br>            aNewOrder[i].fTaken = TRUE; <br>        } <br>    } <br> <br>    iNewSelEnd = iNew - 1; <br> <br>    for (; j &lt; cWindows; j++) { <br>        if (!aNewOrder[j].fTaken) <br>            aNewOrder[iNew++].wNewOrder = j; <br>    } <br> <br>    /* <br>     * Was the order changed at all? <br>     */ <br>    for (i = 1; i &lt; cWindows; i++) <br>        if (aNewOrder[i].wNewOrder != aNewOrder[i - 1].wNewOrder + 1) <br>            break; <br> <br>    /* <br>     * No, get out because there is nothing to do. <br>     */ <br>    if (i == cWindows) <br>        return; <br> <br>    for (i = 0; i &lt; cWindows; i++) { <br>        npc = (NPCTYPE)SendMessage( <br>                hwndOrderList, LB_GETITEMDATA, aNewOrder[i].wNewOrder, 0L); <br> <br>        if (!i) { <br>            npcHead = npc; <br>            npcPrev = npc; <br>        } <br>        else { <br>            npcPrev-&gt;npcNext = npc; <br>            npcPrev = npc; <br>        } <br>    } <br> <br>    npcPrev-&gt;npcNext = NULL; <br> <br>    OrderDlgMarkGroupEnds(); <br>    SendMessage(hwndOrderList, WM_SETREDRAW, FALSE, 0L); <br>    OrderDlgFillList(); <br>    SendMessage(hwndOrderList, LB_SETTOPINDEX, iTopIndex, 0L); <br>    SendMessage(hwndOrderList, LB_SELITEMRANGE, <br>            TRUE, MAKELONG(iNewSelStart, iNewSelEnd)); <br>    OrderDlgSelChange(); <br>    SendMessage(hwndOrderList, WM_SETREDRAW, TRUE, 0L); <br>    InvalidateRect(hwndOrderList, NULL, FALSE); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderDlgDrawItem <br>* <br>* draws the text for the group item <br>* <br>* Arguments: <br>*     LPDRAWITEMSTRUCT - pointer to the item <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderDlgDrawItem( <br>    LPDRAWITEMSTRUCT lpdis) <br>{ <br>    NPCTYPE npc; <br>    TCHAR szItem[CCHTEXTMAX]; <br>    HBITMAP hbmCtrlType; <br>    HBITMAP hbmTab; <br>    HBITMAP hbmOld; <br> <br>    npc = (NPCTYPE)lpdis-&gt;itemData; <br> <br>    /* <br>     * Begin building the text string to draw. <br>     */ <br>    *szItem = CHAR_NULL; <br> <br>    if (npc-&gt;pwcd-&gt;iType == W_CUSTOM) <br>        wsprintf(szItem, L"'%s', ", npc-&gt;pwcd-&gt;pszClass); <br> <br>    if (npc-&gt;text) { <br>        if (IsOrd(npc-&gt;text)) { <br>            IDToLabel(szItem + lstrlen(szItem), OrdID(npc-&gt;text), TRUE); <br>            lstrcat(szItem, L", "); <br>        } <br>        else { <br>            wsprintf(szItem + lstrlen(szItem), L"\"%s\", ", npc-&gt;text); <br>        } <br>    } <br> <br>    IDToLabel(szItem + lstrlen(szItem), npc-&gt;id, TRUE); <br> <br>    if (lpdis-&gt;itemState &amp; ODS_SELECTED) { <br>        SetBkColor(lpdis-&gt;hDC, GetSysColor(COLOR_HIGHLIGHT)); <br>        SetTextColor(lpdis-&gt;hDC, GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>        hbmCtrlType = npc-&gt;pwcd-&gt;hbmCtrlTypeSel; <br>        hbmTab = hbmTabStopSel; <br>    } <br>    else { <br>        SetBkColor(lpdis-&gt;hDC, GetSysColor(COLOR_WINDOW)); <br>        SetTextColor(lpdis-&gt;hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>        hbmCtrlType = npc-&gt;pwcd-&gt;hbmCtrlType; <br>        hbmTab = hbmTabStop; <br>    } <br> <br>    /* <br>     * Draw the string (and paint the background). <br>     */ <br>    ExtTextOut(lpdis-&gt;hDC, <br>        CXTABBMP + 2 + CXTYPEBMP + 2, <br>        lpdis-&gt;rcItem.top + (CYORDERDLGLINE - gcySysChar), <br>        ETO_OPAQUE | ETO_CLIPPED, &amp;lpdis-&gt;rcItem, <br>        szItem, lstrlen(szItem), NULL); <br> <br>    /* <br>     * Draw the group marker separator line. <br>     */ <br>    if (npc-&gt;fGroupEnd) { <br>        SelectObject(lpdis-&gt;hDC, hpenDarkGray); <br>        MoveToEx(lpdis-&gt;hDC, lpdis-&gt;rcItem.left, lpdis-&gt;rcItem.bottom - 1, NULL); <br>        LineTo(lpdis-&gt;hDC, lpdis-&gt;rcItem.right, lpdis-&gt;rcItem.bottom - 1); <br>    } <br> <br>    /* <br>     * Draw the tabstop bitmap if necessary. <br>     */ <br>    if (npc-&gt;flStyle &amp; WS_TABSTOP) { <br>        hbmOld = SelectObject(ghDCMem, hbmTab); <br>        BitBlt(lpdis-&gt;hDC, <br>                0, lpdis-&gt;rcItem.top + ((CYORDERDLGLINE - CYTABBMP) / 2), <br>                CXTABBMP, CYTABBMP, ghDCMem, 0, 0, SRCCOPY); <br>        SelectObject(ghDCMem, hbmOld); <br>    } <br> <br>    /* <br>     * Draw the control type bitmap. <br>     */ <br>    hbmOld = SelectObject(ghDCMem, hbmCtrlType); <br>    BitBlt(lpdis-&gt;hDC, <br>            lpdis-&gt;rcItem.left + CXTABBMP + 2, <br>            lpdis-&gt;rcItem.top + ((CYORDERDLGLINE - CYTYPEBMP) / 2), <br>            CXTYPEBMP, CYTYPEBMP, ghDCMem, 0, 0, SRCCOPY); <br>    SelectObject(ghDCMem, hbmOld); <br> <br>    /* <br>     * Draw the focus rectangle, if necessary. <br>     */ <br>    if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>        DrawFocusRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem); <br>} <br> <br> <br> <br>/************************************************************************ <br>* OrderWindows <br>* <br>* Orders the controls in Windows' linked list of windows to be the <br>* same as the order in the linked list of CTYPEs. <br>* <br>* The Z order of the drag windows and the control windows is critical <br>* to all the painting, dragging and selection code working properly! <br>* <br>************************************************************************/ <br> <br>STATICFN VOID OrderWindows(VOID) <br>{ <br>    register NPCTYPE npc; <br> <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        /* <br>         * The control goes to the bottom of the list. <br>         */ <br>        SetWindowPos(npc-&gt;hwnd, (HWND)1, 0, 0, 0, 0, <br>                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW); <br> <br>        /* <br>         * The drag window goes to the top of the list. <br>         */ <br>        SetWindowPos(npc-&gt;hwndDrag, NULL, 0, 0, 0, 0, <br>                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOREDRAW); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* IsListChanged <br>* <br>* This function returns TRUE if the current order of the linked list <br>* of controls is different than what it was when the Order/Group dialog <br>* was first entered, or if any of the styles were changed (tabs were <br>* set/cleared, groups were changed, etc.). <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL IsListChanged(VOID) <br>{ <br>    NPCTYPE *pnpcSave; <br>    NPCTYPE npc; <br>    INT i; <br> <br>    pnpcSave = anpcSave; <br>    for (i = 0, npc = npcHead; npc; i++, npc = npc-&gt;npcNext, pnpcSave++) <br>        if (npc != *pnpcSave || npc-&gt;flStyle != aflStyleSave[i]) <br>            return TRUE; <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
