<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RESTODLG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5615"></a>RESTODLG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: restodlg.c <br>* <br>* Routines that take a dialog resource and create the dialog to edit, or <br>* the other way around. <br>* <br>* Fucntions: <br>*   SynchDialogResource() <br>*   AllocDialogResource() <br>*   ResLinkToDialog() <br>*   ResToDialog() <br>*   GetiClass() <br>*   Duplicate() <br>*   MakeCopyFromRes() <br>*   TypeFromClassStyle() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>STATICFN INT TypeFromClassStyle(INT iClass, DWORD flStyle); <br> <br> <br> <br>/************************************************************************ <br>* SynchDialogResource <br>* <br>* This routine synchronizes the resource buffer with the contents of <br>* the current dialog being edited.  This may involve deleting the old <br>* contents of the current dialog prior to adding the new data. <br>* <br>* It is ok to call this routine even if there is not an existing dialog <br>* being edited (it will just return) and it should be called before any <br>* operation that needs the in memory copy of the dialog to accurately <br>* reflect the contents of the current dialog, such as just before a <br>* save to disk. <br>* <br>* Returns: <br>*     TRUE if all goes well (includes the case where nothing was done). <br>*     FALSE if an error occurs updating the resource. <br>* <br>************************************************************************/ <br> <br>BOOL SynchDialogResource(VOID) <br>{ <br>    PRES pRes; <br>    PRESLINK prl; <br>    PRESLINK prlNew; <br>    PRESLINK prlPrev; <br> <br>    if (!gfEditingDlg) <br>        return TRUE; <br> <br>    /* <br>     * Allocate a resource for the current dialog. <br>     */ <br>    if (!(pRes = AllocDialogResource(FALSE, FALSE))) <br>        return FALSE; <br> <br>    /* <br>     * Allocate a new link for it. <br>     */ <br>    if (!(prlNew = AllocResLink(pRes))) <br>        return FALSE; <br> <br>    /* <br>     * Free the local copy of the dialog resource now that the <br>     * link has been created (and the resource copied to global <br>     * memory). <br>     */ <br>    MyFree(pRes); <br> <br>    /* <br>     * Does a link for the dialog already exist? <br>     */ <br>    if (gcd.prl) { <br>        /* <br>         * Find the existing link and get it's previous link. <br>         */ <br>        for (prl = gprlHead, prlPrev = NULL; prl &amp;&amp; prl != gcd.prl; <br>                prlPrev = prl, prl = prl-&gt;prlNext) <br>            ; <br> <br>        /* <br>         * Start linking it in. <br>         */ <br>        prlNew-&gt;prlNext = gcd.prl-&gt;prlNext; <br> <br>        if (prlPrev) <br>            prlPrev-&gt;prlNext = prlNew; <br>        else <br>            gprlHead = prlNew; <br> <br>        /* <br>         * Delete the old link now that it is replaced. <br>         */ <br>        FreeResLink(gcd.prl); <br>    } <br>    else { <br>        /* <br>         * Search for the end of the list.  Get a pointer to the last link. <br>         */ <br>        for (prl = gprlHead, prlPrev = NULL; prl; <br>                prlPrev = prl, prl = prl-&gt;prlNext) <br>            ; <br> <br>        /* <br>         * Add the new link to the end of the list. <br>         */ <br>        if (prlPrev) <br>            prlPrev-&gt;prlNext = prlNew; <br>        else <br>            gprlHead = prlNew; <br>    } <br> <br>    /* <br>     * Update our global with the new link.  Clear the "dialog changed" <br>     * flag. <br>     */ <br>    gcd.prl = prlNew; <br>    gfDlgChanged = FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AllocDialogResource <br>* <br>* This function allocates memory and builds a resource file format <br>* image in it of the current dialog. <br>* <br>* Arguments: <br>*   BOOL fTestMode     - TRUE if a special test mode version of the current <br>*                        dialog should be created. <br>*   BOOL fClipboard    - If TRUE, only the selected control(s) will be <br>*                        placed in the resource.  This is used when putting <br>*                        controls or groups of controls into the clipboard. <br>*                        If the dialog is selected, this flag is ignored, <br>*                        because selecting the dialog implies all the <br>*                        controls will be written out also. <br>* <br>* Returns: <br>*     Pointer to the resource buffer. <br>*     NULL if unable to create the resource. <br>* <br>************************************************************************/ <br> <br>PRES AllocDialogResource( <br>    BOOL fTestMode, <br>    BOOL fClipboard) <br>{ <br>    NPCTYPE npc; <br>    INT cControls; <br>    BOOL fSelectedOnly = FALSE; <br>    INT cbDlgName; <br>    INT cbCaption; <br>    INT cbPointSize; <br>    INT cbFontName; <br>    INT cbCD; <br>    INT cbResHeader; <br>    INT cbResData; <br>    INT cbResSize; <br>    INT cbMenuName; <br>    INT cbClass; <br>    INT cbText; <br>    INT cbAlloc; <br>    PBYTE pb; <br>    PRES pResBegin; <br>    PRES pResBegin2; <br>    LPTSTR pszClass; <br>    LPTSTR pszMenu; <br>    LPTSTR pszText; <br>    DWORD flStyle; <br>    PDIALOGBOXHEADER pdbh; <br>    PCONTROLDATA pcd; <br>    ORDINAL ordClass; <br> <br>    cControls = cWindows; <br>    if (fClipboard &amp;&amp; !gfDlgSelected) { <br>        fSelectedOnly = TRUE; <br>        for (cControls = 0, npc = npcHead; npc; npc = npc-&gt;npcNext) <br>            if (npc-&gt;fSelected) <br>                cControls++; <br>    } <br> <br>    /* <br>     * If testing, don't allow a dialog to be created with any <br>     * special class, or with the real menu. <br>     */ <br>    if (fTestMode) { <br>        pszClass = NULL; <br>        pszMenu = NULL; <br>    } <br>    else { <br>        pszClass = gcd.di.pszClass; <br>        pszMenu = gcd.di.pszMenu; <br>    } <br> <br>    cbDlgName = NameOrdLen(gcd.pszDlgName); <br>    cbCaption = (gcd.npc-&gt;text) ? <br>            (lstrlen(gcd.npc-&gt;text) + 1) * sizeof(TCHAR) : sizeof(TCHAR); <br>    cbClass = pszClass ? NameOrdLen(pszClass) : sizeof(TCHAR); <br>    cbMenuName = pszMenu ? NameOrdLen(pszMenu) : sizeof(TCHAR); <br> <br>    if (gcd.fFontSpecified) { <br>        cbPointSize = sizeof(WORD); <br>        cbFontName = (lstrlen(gcd.di.szFontName) + 1) * sizeof(TCHAR); <br>    } <br>    else { <br>        cbPointSize = cbFontName = 0; <br>    } <br> <br>    /* <br>     * Calculate the size of the resource header. <br>     */ <br>    cbResHeader = sizeof(RES) +             // The first fixed part. <br>            sizeof(ORDINAL) +               // The RT_DIALOG ordinal. <br>            cbDlgName;                      // The dialog's name. <br>    DWordAlign((PBYTE *)&amp;cbResHeader);      // Pad for the dialog's name. <br>    cbResHeader += sizeof(RES2);            // The last fixed part. <br> <br>    /* <br>     * Calculate the size of the resource data.  This will just include <br>     * the dialog box header right now. <br>     */ <br>    cbResData = SIZEOF_DIALOGBOXHEADER +    // The first fixed part. <br>            cbMenuName +                    // The menu. <br>            cbClass +                       // The class. <br>            cbCaption +                     // The caption. <br>            cbPointSize +                   // The point size. <br>            cbFontName;                     // The font name. <br> <br>    /* <br>     * Allocate some buffer space.  Be sure to round this up to a DWORD <br>     * boundary to allow space for padding if necessary, but don't round <br>     * cbResData field because it will need to be written into the header <br>     * later, and the value that is written is an exact size (not rounded <br>     * up). <br>     */ <br>    cbAlloc = cbResSize = cbResHeader + cbResData; <br>    DWordAlign((PBYTE *)&amp;cbAlloc); <br>    if (!(pResBegin = (PRES)MyAlloc(cbAlloc))) <br>        return NULL; <br> <br>    /* <br>     * Write the resource header. <br>     */ <br>    pdbh = (PDIALOGBOXHEADER)WriteResHeader(pResBegin, 0, ORDID_RT_DIALOG, <br>            gcd.pszDlgName, gcd.di.fResFlags, gcd.di.wLanguage, <br>            gcd.di.DataVersion, gcd.di.Version, gcd.di.Characteristics); <br> <br>    /* <br>     * Write out the style. <br>     */ <br>    flStyle = gcd.npc-&gt;flStyle; <br>    if (fTestMode) { <br>        flStyle &amp;= ~awcd[W_DIALOG].flStylesTestBad; <br>        flStyle |= WS_VISIBLE; <br>    } <br> <br>    pdbh-&gt;lStyle = flStyle; <br>    pdbh-&gt;lExtendedStyle = gcd.npc-&gt;flExtStyle; <br>    pdbh-&gt;NumberOfItems = (WORD)cControls; <br> <br>    /* <br>     * Write the coordinates. <br>     * <br>     * If we are allocating a template that only has the selected controls <br>     * in it, we put the value of CONTROLS_ONLY in the "cx" field of the <br>     * dialog header.  This is what we will check when the user pastes <br>     * something from the clipboard into a dialog to determine whether <br>     * to paste the entire dialog, or only the controls within the dialog <br>     * item array. <br>     */ <br>    pdbh-&gt;x = (WORD)gcd.npc-&gt;rc.left; <br>    pdbh-&gt;y = (WORD)gcd.npc-&gt;rc.top; <br> <br>    if (fSelectedOnly) <br>        pdbh-&gt;cx = CONTROLS_ONLY; <br>    else <br>        pdbh-&gt;cx = (WORD)(gcd.npc-&gt;rc.right - gcd.npc-&gt;rc.left); <br> <br>    pdbh-&gt;cy = (WORD)(gcd.npc-&gt;rc.bottom - gcd.npc-&gt;rc.top); <br> <br>    pb = (PBYTE)pdbh + SIZEOF_DIALOGBOXHEADER; <br> <br>    /* <br>     * Write the menu name if there is one (we always write at least a null. <br>     */ <br>    pb = NameOrdCpy((LPTSTR)pb, pszMenu ? pszMenu : szEmpty); <br> <br>    /* <br>     * Write the class if there is one (we always write at least a null. <br>     */ <br>    pb = NameOrdCpy((LPTSTR)pb, pszClass ? pszClass : szEmpty); <br> <br>    /* <br>     * Write the caption if there is one (we always write at least a null). <br>     */ <br>    pb = WriteSz((LPTSTR)pb, gcd.npc-&gt;text ? gcd.npc-&gt;text : szEmpty); <br> <br>    /* <br>     * Write out the font, if there is one specified. <br>     */ <br>    if (gcd.fFontSpecified) { <br>        *(PWORD)pb = (WORD)gcd.di.nPointSize; <br>        pb += sizeof(WORD); <br> <br>        pb = WriteSz((LPTSTR)pb, gcd.di.szFontName); <br>    } <br> <br>    /* <br>     * Pad to a DWORD boundary.  This is ok even if there are no controls <br>     * that follow, because we were sure to allocate on an even dword <br>     * boundary above. <br>     */ <br>    DWordPad(&amp;pb); <br> <br>    /* <br>     * Now do dialog items. <br>     */ <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        /* <br>         * Skip the control if it is NOT selected and we only want the <br>         * selected controls. <br>         */ <br>        if (fSelectedOnly &amp;&amp; !npc-&gt;fSelected) <br>            continue; <br> <br>        /* <br>         * If we are testing, we don't want to really create a control <br>         * with some funny class because it probably won't be found. <br>         * We will substitute our custom class emulator instead. <br>         */ <br>        if (fTestMode &amp;&amp; npc-&gt;pwcd-&gt;fEmulated) <br>            pszClass = szCustomClass; <br>        else <br>            pszClass = npc-&gt;pwcd-&gt;pszClass; <br> <br>        /* <br>         * Get a pointer to the text.  If this is an icon control and <br>         * we are going into test mode, change the text field so that <br>         * it points to an ordinal for DlgEdit's icon to display, or <br>         * the icon resource will probably not be found when the dialog <br>         * is created. <br>         */ <br>        pszText = npc-&gt;text; <br>        if (npc-&gt;pwcd-&gt;iType == W_ICON &amp;&amp; fTestMode) <br>            pszText = (LPTSTR)&amp;gordIcon; <br> <br>        cbText = pszText ? NameOrdLen(pszText) : sizeof(TCHAR); <br>        cbClass = pszClass ? NameOrdLen(pszClass) : sizeof(ORDINAL); <br> <br>        cbCD = SIZEOF_CONTROLDATA +         // The fixed portion. <br>                cbClass +                   // The class. <br>                cbText +                    // The text. <br>                sizeof(WORD);               // nExtraStuff field. <br> <br>        /* <br>         * Since we are adding a new control, we dword align the <br>         * previous size of the resource data to ensure the new <br>         * control starts on a dword boundary. <br>         */ <br>        DWordAlign((PBYTE *)&amp;cbResSize); <br> <br>        /* <br>         * Allocate room for this control.  This includes room for the <br>         * template structure, class, text and a byte for the cb field <br>         * for the create struct data. <br>         */ <br>        cbAlloc = cbResSize + cbCD; <br>        DWordAlign((PBYTE *)&amp;cbAlloc); <br>        pResBegin2 = (PRES)MyRealloc((PBYTE)pResBegin, cbAlloc); <br>        if (!pResBegin2) { <br>            MyFree(pResBegin); <br>            return NULL; <br>        } <br> <br>        pResBegin = pResBegin2; <br>        pcd = (PCONTROLDATA)((PBYTE)pResBegin + cbResSize); <br>        cbResSize += cbCD; <br> <br>        /* <br>         * Write the style.  If testing, remove any styles that can <br>         * cause problems, such as ownerdraw styles.  If testing and <br>         * this is an emulated custom control, always make it with <br>         * the default styles no matter what the user has specified. <br>         */ <br>        flStyle = npc-&gt;flStyle; <br>        if (fTestMode) { <br>            if (npc-&gt;pwcd-&gt;fEmulated) <br>                flStyle = awcd[W_CUSTOM].flStyles; <br>            else <br>                flStyle &amp;= ~npc-&gt;pwcd-&gt;flStylesTestBad; <br>        } <br> <br>        pcd-&gt;lStyle = flStyle; <br>        pcd-&gt;lExtendedStyle = npc-&gt;flExtStyle; <br> <br>        /* <br>         * Write the coordinates. <br>         */ <br>        pcd-&gt;x = (WORD)npc-&gt;rc.left; <br>        pcd-&gt;y = (WORD)npc-&gt;rc.top; <br>        pcd-&gt;cx = (WORD)(npc-&gt;rc.right - npc-&gt;rc.left); <br>        pcd-&gt;cy = (WORD)(npc-&gt;rc.bottom - npc-&gt;rc.top); <br> <br>        /* <br>         * Write the id. <br>         */ <br>        pcd-&gt;wId = (WORD)npc-&gt;id; <br> <br>        pb = (PBYTE)pcd + SIZEOF_CONTROLDATA; <br> <br>        /* <br>         * Write the class.  This will be a string, except for the <br>         * predefined control classes, which all have an ordinal <br>         * value defined for them. <br>         */ <br>        if (pszClass) { <br>            pb = NameOrdCpy((LPTSTR)pb, pszClass); <br>        } <br>        else { <br>            WriteOrd(&amp;ordClass, acsd[awcd[npc-&gt;pwcd-&gt;iType].iClass].idOrd); <br>            pb = NameOrdCpy((LPTSTR)pb, (LPTSTR)&amp;ordClass); <br>        } <br> <br>        /* <br>         * Write the text. <br>         */ <br>        pb = NameOrdCpy((LPTSTR)pb, pszText ? pszText : szEmpty); <br> <br>        /* <br>         * Write out a zero because there are no additional bytes <br>         * of create struct data. <br>         */ <br>        *(PWORD)pb = 0; <br>        pb += sizeof(WORD); <br> <br>        /* <br>         * Pad to a DWORD boundary.  This is ok even if there are no more <br>         * controls, because we were sure to allocate on an even dword <br>         * boundary above. <br>         */ <br>        DWordPad(&amp;pb); <br>    } <br> <br>    /* <br>     * Now go back and fill in the resource data size field. <br>     */ <br>    pResBegin-&gt;DataSize = cbResSize - cbResHeader; <br> <br>    return pResBegin; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ResLinkToDialog <br>* <br>* This function is used to create a dialog out of a dialog resource <br>* that has been stored in the resource linked list. <br>* <br>* Arguments: <br>*   PRESLINK prl - Points to the link that describes the dialog to <br>*                  create.  It is assumed that the resource is a <br>*                  dialog resource. <br>* <br>************************************************************************/ <br> <br>VOID ResLinkToDialog( <br>    PRESLINK prl) <br>{ <br>    PRES pRes; <br> <br>    pRes = (PRES)GlobalLock(prl-&gt;hRes); <br>    ResToDialog(pRes, TRUE); <br>    GlobalUnlock(prl-&gt;hRes); <br> <br>    /* <br>     * If the dialog was successfully created, remember which res link <br>     * it was created from. <br>     */ <br>    if (gfEditingDlg) <br>        gcd.prl = prl; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ResToDialog <br>* <br>* This function creates a dialog box, complete with controls, <br>* from a dialog resource template. <br>* <br>* Arguments: <br>*   PRES pRes        - Pointer to the dialog resource to use. <br>*   BOOL fDoDialog   - TRUE if a new dialog should be created, followed <br>*                      by the controls.  If this is FALSE, just the <br>*                      controls will be created and added to the current <br>*                      dialog. <br>* <br>* Returns: <br>*     TRUE on success, FALSE if an error occured. <br>* <br>************************************************************************/ <br> <br>BOOL ResToDialog( <br>    PRES pRes, <br>    BOOL fDoDialog) <br>{ <br>    LPTSTR pszText; <br>    LPTSTR pszClass; <br>    INT x; <br>    INT y; <br>    INT cx; <br>    INT cy; <br>    INT id; <br>    INT iClass; <br>    INT cdit; <br>    INT Type; <br>    DWORD flStyle; <br>    DWORD flExtStyle; <br>    NPCTYPE npc; <br>    LPTSTR pszMenuName; <br>    LPTSTR pszFontName; <br>    INT nPointSize; <br>    LPTSTR pszDlgName; <br>    LPTSTR pszCaption; <br>    PDIALOGBOXHEADER pdbh; <br>    PCONTROLDATA pcd; <br>    PWINDOWCLASSDESC pwcd; <br>    PCUSTLINK pcl; <br>    PRES2 pRes2; <br>    DIALOGINFO di; <br>    CCINFO cci; <br> <br>    /* <br>     * First check that the pointer is ok. <br>     */ <br>    if (!pRes) <br>        return FALSE; <br> <br>    pRes2 = ResourcePart2(pRes); <br>    pdbh = (PDIALOGBOXHEADER)SkipResHeader(pRes); <br> <br>    /* <br>     * Parse out the dialog box header. <br>     * After this point, pcd is pointing to the first dialog control item. <br>     */ <br>    pcd = ParseDialogBoxHeader(pdbh, <br>            &amp;flStyle, &amp;flExtStyle, &amp;cdit, &amp;x, &amp;y, &amp;cx, &amp;cy, <br>            &amp;pszMenuName, &amp;pszClass, &amp;pszCaption, <br>            &amp;nPointSize, &amp;pszFontName); <br> <br>    /* <br>     * Are we pasting the entire dialog? <br>     */ <br>    if (fDoDialog) { <br>        pszDlgName = ResourceName(pRes); <br> <br>        /* <br>         * Determine the best base id for the dialog. <br>         */ <br>        if (IsOrd(pszDlgName)) <br>            id = OrdID(pszDlgName); <br>        else <br>            id = NextID(NEXTID_DIALOG, plInclude, 0); <br> <br>        di.fResFlags = pRes2-&gt;MemoryFlags; <br>        di.wLanguage = pRes2-&gt;LanguageId; <br>        di.pszClass = pszClass; <br>        di.pszMenu = pszMenuName; <br>        di.DataVersion = pRes2-&gt;DataVersion; <br>        di.Version = pRes2-&gt;Version; <br>        di.Characteristics = pRes2-&gt;Characteristics; <br>        di.nPointSize = nPointSize; <br>        lstrcpy(di.szFontName, pszFontName ? pszFontName : szEmpty); <br> <br>        /* <br>         * Create the dialog. <br>         */ <br>        if (!AddControl(&amp;awcd[W_DIALOG], pszCaption, flStyle, flExtStyle, id, <br>                x, y, cx, cy, pszDlgName, &amp;di)) <br>            return FALSE; <br>    } <br> <br>    while (cdit--) { <br>        pcd = ParseControlData(pcd, &amp;flStyle, &amp;flExtStyle, &amp;x, &amp;y, &amp;cx, &amp;cy, <br>                &amp;id, &amp;pszClass, &amp;pszText); <br> <br>        /* <br>         * If we are not creating a new dialog, and the id in <br>         * the resource is already in use, we will use the next <br>         * available one instead. <br>         */ <br>        if (!fDoDialog &amp;&amp; !IsUniqueID(id)) <br>            id = NextID(NEXTID_CONTROL, plInclude, 0); <br> <br>        /* <br>         * Fix up the class.  If the class is a predefined ordinal type, <br>         * we will null out pszClass so it doesn't confuse AddControl <br>         * into thinking that there is a string class for this control. <br>         */ <br>        iClass = GetiClass(pszClass); <br>        Type = TypeFromClassStyle(iClass, flStyle); <br>        if (IsOrd(pszClass)) <br>            pszClass = NULL; <br> <br>        if (Type == W_CUSTOM) { <br>            /* <br>             * Search the list of installed custom controls for one <br>             * that matches the class. <br>             */ <br>            for (pcl = gpclHead; <br>                    pcl &amp;&amp; lstrcmpi(pcl-&gt;pwcd-&gt;pszClass, pszClass) != 0; <br>                    pcl = pcl-&gt;pclNext) <br>                ; <br> <br>            /* <br>             * Was a match found? <br>             */ <br>            if (pcl) { <br>                pwcd = pcl-&gt;pwcd; <br>            } <br>            else { <br>                /* <br>                 * An existing custom control link for this class was <br>                 * not found.  We will add an emulated custom control <br>                 * to support it.  We assume the default style and size <br>                 * should be what this control has. <br>                 */ <br>                lstrcpy(cci.szClass, pszClass); <br>                cci.flOptions = 0; <br>                *cci.szDesc = TEXT('\0'); <br>                cci.cxDefault = cx; <br>                cci.cyDefault = cy; <br>                cci.flStyleDefault = flStyle; <br>                cci.flExtStyleDefault = flExtStyle; <br>                *cci.szTextDefault = TEXT('\0'); <br>                cci.cStyleFlags = 0; <br>                cci.aStyleFlags = NULL; <br>                cci.lpfnStyle = NULL; <br>                cci.lpfnSizeToText = NULL; <br>                cci.dwReserved1 = 0; <br>                cci.dwReserved2 = 0; <br> <br>                if (pcl = AddCustomLink(&amp;cci, TRUE, FALSE, NULL, NULL)) <br>                    pwcd = pcl-&gt;pwcd; <br>                else <br>                    /* <br>                     * Skip this control and continue creating the <br>                     * rest of the dialog. <br>                     */ <br>                    continue; <br>            } <br>        } <br>        else { <br>            pwcd = &amp;awcd[Type]; <br>        } <br> <br>        /* <br>         * If we are not creating the entire dialog (we allow existing <br>         * resource files to be a little messed up), and this control <br>         * is a default pushbutton, we will then loop through all the <br>         * existing controls checking for another default pushbutton. <br>         * If one is found, we convert the default pushbutton being <br>         * created into a normal pushbutton instead.  It is not allowed <br>         * to have more than one default pushbuttons in the same dialog. <br>         */ <br>        if (!fDoDialog &amp;&amp; Type == W_PUSHBUTTON &amp;&amp; <br>                (flStyle &amp; BS_ALL) == BS_DEFPUSHBUTTON) { <br>            for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>                if (npc-&gt;pwcd-&gt;iType == W_PUSHBUTTON &amp;&amp; <br>                        (npc-&gt;flStyle &amp; BS_ALL) == BS_DEFPUSHBUTTON) { <br>                    flStyle = (flStyle &amp; ~BS_ALL) | BS_PUSHBUTTON; <br>                    break; <br>                } <br>            } <br>        } <br> <br>        npc = AddControl(pwcd, pszText, flStyle, flExtStyle, id, <br>                x, y, cx, cy, NULL, NULL); <br> <br>        /* <br>         * If the control creation succeeded, and we are just adding <br>         * controls (not creating a whole new dialog), select the <br>         * controls as they are added, but don't do any drawing yet. <br>         */ <br>        if (!fDoDialog &amp;&amp; npc) <br>            SelectControl2(npc, TRUE); <br>    } <br> <br>    /* <br>     * Update the selected rectangle.  This is normally done by <br>     * SelectControl2 but we told it not to so that the selection <br>     * could be done faster.  We also select the first control here. <br>     */ <br>    if (!fDoDialog) { <br>        SetAnchorToFirstSel(TRUE); <br>        CalcSelectedRect(); <br>    } <br> <br>    ShowWindow(gcd.npc-&gt;hwnd, SW_SHOWNA); <br>    ToolboxOnTop(); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* TypeFromClassStyle <br>* <br>* This function returns the type of a control (one of the W_ constants) <br>* based on the class in iClass and the style in flStyle. <br>* <br>* Arguments: <br>*     INT iClass    = The class of the control, as an IC_* defined constant. <br>*     DWORD flStyle = The style of the control. <br>* <br>* Returns: <br>*     The type of the control (W_* constant). <br>*     W_NOTHING is the error return. <br>* <br>************************************************************************/ <br> <br>STATICFN INT TypeFromClassStyle( <br>    INT iClass, <br>    DWORD flStyle) <br>{ <br>    switch (iClass) { <br>        case IC_BUTTON: <br>            return rgmpiClsBtnType[flStyle &amp; BS_ALL]; <br> <br>        case IC_EDIT: <br>            return W_EDIT; <br> <br>        case IC_SCROLLBAR: <br>            return (flStyle &amp; SBS_VERT) ? W_VERTSCROLL : W_HORZSCROLL; <br> <br>        case IC_STATIC: <br>            return rgmpiClsStcType[flStyle &amp; SS_ALL]; <br> <br>        case IC_LISTBOX: <br>            return W_LISTBOX; <br> <br>        case IC_COMBOBOX: <br>            return W_COMBOBOX; <br> <br>        case IC_CUSTOM: <br>            return W_CUSTOM; <br> <br>        case IC_DIALOG: <br>            return W_DIALOG; <br> <br>        default: <br>            return W_NOTHING; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetiClass <br>* <br>* This function returns the class identifier number for the <br>* window class of the control, given the class string from the <br>* dialog template. <br>* <br>* An ordinal class is a special ordinal that is used to identify <br>* each of the standard control classes.  It is used in the <br>* dialog template to save space.  The class string passed in <br>* can be an ordinal and if so, it will be checked against these <br>* predefined ordinal class values for a match. <br>* <br>* Arguments: <br>*     LPTSTR pszClass - The class string or ordinal. <br>* <br>* Returns: <br>*     The class identifier, one of the IC_* symbols in dlgedit.h. <br>*     If the class cannot be determined, it assumes it is a custom <br>*     class and returns IC_CUSTOM. <br>* <br>************************************************************************/ <br> <br>INT GetiClass( <br>    LPTSTR pszClass) <br>{ <br>    INT i; <br>    WORD idOrd; <br> <br>    if (IsOrd(pszClass)) { <br>        idOrd = OrdID(pszClass); <br>        for (i = 0; i &lt; IC_DIALOG; i++) { <br>            if (acsd[i].idOrd == idOrd) <br>                return i; <br>        } <br>    } <br>    else { <br>        for (i = 0; i &lt; IC_DIALOG; i++) { <br>            if (lstrcmpi(ids(acsd[i].idsClass), pszClass) == 0) <br>                return i; <br>        } <br>    } <br> <br>    /* <br>     * Not found.  Assume it is a user defined class. <br>     */ <br>    return IC_CUSTOM; <br>} <br> <br> <br> <br>/************************************************************************ <br>* Duplicate <br>* <br>* This routine duplicates the current selection. <br>* <br>************************************************************************/ <br> <br>VOID Duplicate(VOID) <br>{ <br>    PRES pRes; <br> <br>    if (gcSelected) { <br>        /* <br>         * Store the current selection in a dialog resource. <br>         */ <br>        if (!(pRes = AllocDialogResource(FALSE, TRUE))) <br>            return; <br> <br>        MakeCopyFromRes(pRes); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* MakeCopyFromRes <br>* <br>* This function uses the given dialog template to either add a new <br>* dialog to the current resource file, or drop controls from the <br>* template into the current dialog.  If copying a dialog, it is created <br>* right away.  If copying controls, an operation is begun to start <br>* tracking them to their final destination in the current dialog. <br>* <br>* The caller of this function should NOT free pRes.  This will <br>* be done either before the function returns, or after the drag <br>* operation is complete. <br>* <br>* Arguments: <br>*   PRES pRes - Points to the dialog resource that contains <br>*               the dialog or controls to make a copy of. <br>* <br>************************************************************************/ <br> <br>VOID MakeCopyFromRes( <br>    PRES pRes) <br>{ <br>    PDIALOGBOXHEADER pdbh; <br>    PCONTROLDATA pcd; <br>    INT cControls; <br>    INT i; <br>    BOOL fFreeData = TRUE; <br>    INT iType; <br>    INT iClass; <br>    INT nBottom; <br>    INT nBottomLowest; <br> <br>    gpResCopy = pRes; <br>    pdbh = (PDIALOGBOXHEADER)SkipResHeader(gpResCopy); <br> <br>    /* <br>     * If cx is CONTROLS_ONLY, then we know that we only <br>     * want to copy the controls in the template, not <br>     * the entire dialog plus controls. <br>     */ <br>    if (pdbh-&gt;cx == CONTROLS_ONLY) { <br>        /* <br>         * Begin copying in new controls into the current dialog. <br>         */ <br>        cControls = pdbh-&gt;NumberOfItems; <br>        if (cControls) { <br>            /* <br>             * Seed the rectangle with impossible values. <br>             */ <br>            SetRect(&amp;grcCopy, 32000, 32000, -32000, -32000); <br>            nBottomLowest = 0; <br> <br>            /* <br>             * Loop through all the controls, expanding the rectangle <br>             * to fit around all of them. <br>             */ <br>            pcd = SkipDialogBoxHeader(pdbh); <br>            for (i = 0; i &lt; cControls; i++) { <br>                iClass = GetiClass((LPTSTR)((PBYTE)pcd + SIZEOF_CONTROLDATA)); <br>                iType = TypeFromClassStyle(iClass, pcd-&gt;lStyle); <br> <br>                if (grcCopy.left &gt; (INT)pcd-&gt;x) <br>                    grcCopy.left = (INT)pcd-&gt;x; <br> <br>                if (grcCopy.top &gt; (INT)pcd-&gt;y) <br>                    grcCopy.top = (INT)pcd-&gt;y; <br> <br>                if (grcCopy.right &lt; (INT)pcd-&gt;x + (INT)pcd-&gt;cx) <br>                    grcCopy.right = (INT)pcd-&gt;x + (INT)pcd-&gt;cx; <br> <br>                nBottom = ((INT)pcd-&gt;y + (INT)pcd-&gt;cy) - <br>                        GetOverHang(iType, (INT)pcd-&gt;cy); <br>                if (nBottom &gt; nBottomLowest) <br>                    nBottomLowest = nBottom; <br> <br>                if (grcCopy.bottom &lt; (INT)pcd-&gt;y + (INT)pcd-&gt;cy) <br>                    grcCopy.bottom = (INT)pcd-&gt;y + (INT)pcd-&gt;cy; <br> <br>                pcd = SkipControlData(pcd); <br>            } <br> <br>            /* <br>             * Begin dragging the new control(s).  Set a flag so that <br>             * the resource data is NOT free'd until after the drag <br>             * is finished. <br>             */ <br>            DragNewBegin(grcCopy.right - grcCopy.left, <br>                    grcCopy.bottom - grcCopy.top, <br>                    grcCopy.bottom - nBottomLowest); <br>            fFreeData = FALSE; </code></pre>
<p>
</p>
<pre><code>} <br>    } <br>    else { <br>        /* <br>         * Begin copying in a new dialog, complete with controls. <br>         */ <br>        if (SynchDialogResource()) { <br>            /* <br>             * Remove any existing dialog. <br>             */ <br>            if (gfEditingDlg) <br>                DeleteDialog(FALSE); <br> <br>            if (ResToDialog(gpResCopy, TRUE)) { <br>                SelectControl(gcd.npc, FALSE); <br>                gfResChged = TRUE; <br>                ShowFileStatus(FALSE); <br>            } <br>        } <br>    } <br> <br>    if (fFreeData) { <br>        MyFree(gpResCopy); <br>        gpResCopy = NULL; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
