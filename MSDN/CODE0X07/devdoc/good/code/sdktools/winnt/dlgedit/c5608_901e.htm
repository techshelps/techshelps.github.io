<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MENU.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5612"></a>MENU.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: menu.c <br>* <br>* Contains the main menu switching functions and the clipboard functions. <br>* <br>* Functions: <br>*   DialogMenu() <br>*   LoadMenuBitmaps() <br>*   FreeMenuBitmaps() <br>*   InitMenu() <br>*   MsgFilterHookFunc() <br>*   ShowHelp() <br>*   CopyToClipboard() <br>*   DlgInClipboard() <br>*   PasteFromClipboard() <br>*   GetHelpContext() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br>#include "dialogs.h" <br> <br>#include &lt;string.h&gt; <br> <br> <br>#define MM10PERINCH         254         // Tenths of a millimeter per inch. <br> <br>typedef struct { <br>    WORD idm; <br>    INT idbm; <br>    HBITMAP hbm; <br>} BITMAPMENU; <br> <br> <br>STATICFN VOID CopyToClipboard(VOID); <br>STATICFN BOOL DlgInClipboard(VOID); <br>STATICFN VOID PasteFromClipboard(VOID); <br>STATICFN INT GetHelpContext(INT idSubject, PHELPMAP phmap); <br> <br> <br>static BITMAPMENU bmpmenuTable[] = { <br>    {MENU_ALIGNLEFT,        IDBM_ALEFT,         NULL }, <br>    {MENU_ALIGNVERT,        IDBM_AVERT,         NULL }, <br>    {MENU_ALIGNRIGHT,       IDBM_ARIGHT,        NULL }, <br>    {MENU_ALIGNTOP,         IDBM_ATOP,          NULL }, <br>    {MENU_ALIGNHORZ,        IDBM_AHORZ,         NULL }, <br>    {MENU_ALIGNBOTTOM,      IDBM_ABOTTOM,       NULL }, <br>    {MENU_SPACEVERT,        IDBM_ASPCVERT,      NULL }, <br>    {MENU_SPACEHORZ,        IDBM_ASPCHORZ,      NULL }, <br>    {MENU_ARRSIZEWIDTH,     IDBM_ASZWIDTH,      NULL }, <br>    {MENU_ARRSIZEHEIGHT,    IDBM_ASZHGHT,       NULL }, <br>    {MENU_ARRPUSHBOTTOM,    IDBM_APBBOTTM,      NULL }, <br>    {MENU_ARRPUSHRIGHT,     IDBM_APBRIGHT,      NULL } <br>}; <br> <br> <br> <br>/************************************************************************ <br>* DialogMenu <br>* <br>* This is the main switching function to send menu commands to the <br>* appropriate function. <br>* <br>* Arguments: <br>*   INT - the menu command <br>* <br>************************************************************************/ <br> <br>VOID DialogMenu( <br>    INT cmd) <br>{ <br>    /* <br>     * Be sure any outstanding changes get applied without errors. <br>     */ <br>    if (!StatusApplyChanges()) <br>        return; <br> <br>    switch (cmd) { <br> <br>        /* <br>         * File menu ---------------------------------------------------- <br>         */ <br> <br>        case MENU_NEWRES: <br>            if (DoWeSave(FILE_INCLUDE) == IDCANCEL || <br>                    DoWeSave(FILE_RESOURCE) == IDCANCEL) <br>                break; <br> <br>            FreeInclude(); <br>            FreeRes(); <br>            AddNewDialog(); <br>            ShowFileStatus(TRUE); <br>            break; <br> <br>        case MENU_OPEN: <br>            if (DoWeSave(FILE_INCLUDE) == IDCANCEL || <br>                    DoWeSave(FILE_RESOURCE) == IDCANCEL) <br>                break; <br> <br>            Open(FILE_RESOURCE); <br> <br>            break; <br> <br>        case MENU_SAVE: <br>            if (gfIncChged) { <br>                if (!Save(FILE_NOSHOW | FILE_INCLUDE)) <br>                    break; <br>            } <br> <br>            if (gfResChged) <br>                Save(FILE_NOSHOW | FILE_RESOURCE); <br> <br>            break; <br> <br>        case MENU_SAVEAS: <br>            /* <br>             * Save the include file, but only if there is one. <br>             */ <br>            if (pszIncludeFile || plInclude) { <br>                if (!Save(FILE_NOSHOW | FILE_INCLUDE | FILE_SAVEAS)) <br>                    break; <br>            } <br> <br>            /* <br>             * Save the resource file. <br>             */ <br>            Save(FILE_NOSHOW | FILE_RESOURCE | FILE_SAVEAS); <br> <br>            break; <br> <br>        case MENU_NEWCUST: <br>            DlgBox(DID_NEWCUST, (WNDPROC)NewCustDlgProc); <br>            break; <br> <br>        case MENU_OPENCUST: <br>            OpenCustomDialog(); <br>            break; <br> <br>        case MENU_REMCUST: <br>            DlgBox(DID_REMCUST, (WNDPROC)RemCustDlgProc); <br>            break; <br> <br>        case MENU_SETINCLUDE: <br>            if (DoWeSave(FILE_INCLUDE) != IDCANCEL) <br>                Open(FILE_INCLUDE); <br> <br>            break; <br> <br>        case MENU_EXIT: <br>            PostMessage(ghwndMain, WM_CLOSE, 0, 0L); <br>            break; <br> <br>        /* <br>         * Edit menu ---------------------------------------------------- <br>         */ <br> <br>        case MENU_RESTOREDIALOG: <br>            RestoreDialog(); <br>            break; <br> <br>        case MENU_CUT: <br>        case MENU_COPY: <br>            if (gfEditingDlg) { <br>                /* <br>                 * Save current stuff in clipboard. <br>                 */ <br>                CopyToClipboard(); <br> <br>                /* <br>                 * Clear the selection if they did a "cut" instead of <br>                 * a "copy". <br>                 */ <br>                if (cmd == MENU_CUT) <br>                    DeleteControl(); <br>            } <br> <br>            break; <br> <br>        case MENU_PASTE: <br>            PasteFromClipboard(); <br>            break; <br> <br>        case MENU_DELETE: <br>            DeleteControl(); <br>            break; <br> <br>        case MENU_DUPLICATE: <br>            Duplicate(); <br>            break; <br> <br>        case MENU_SYMBOLS: <br>            ViewInclude(); <br>            break; <br> <br>        case MENU_STYLES: <br>            StylesDialog(); <br>            break; <br> <br>        case MENU_SIZETOTEXT: <br>            SizeToText(); <br>            break; <br> <br>        case MENU_NEWDIALOG: <br>            AddNewDialog(); <br>            break; <br> <br>        case MENU_SELECTDIALOG: <br>            SelectDialogDialog(); <br>            break; <br> <br>        /* <br>         * Arrange menu ------------------------------------------------- <br>         */ <br> <br>        case MENU_ALIGNLEFT: <br>        case MENU_ALIGNVERT: <br>        case MENU_ALIGNRIGHT: <br>        case MENU_ALIGNTOP: <br>        case MENU_ALIGNHORZ: <br>        case MENU_ALIGNBOTTOM: <br>            AlignControls(cmd); <br>            break; <br> <br>        case MENU_SPACEVERT: <br>        case MENU_SPACEHORZ: <br>            ArrangeSpacing(cmd); <br>            break; <br> <br>        case MENU_ARRSIZEWIDTH: <br>        case MENU_ARRSIZEHEIGHT: <br>            ArrangeSize(cmd); <br>            break; <br> <br>        case MENU_ARRPUSHBOTTOM: <br>        case MENU_ARRPUSHRIGHT: <br>            ArrangePushButtons(cmd); <br>            break; <br> <br>        case MENU_ORDERGROUP: <br>            OrderGroupDialog(); <br>            break; <br> <br>        case MENU_ARRSETTINGS: <br>            ArrangeSettingsDialog(); <br>            break; <br> <br>        /* <br>         * Options menu ------------------------------------------------- <br>         */ <br> <br>        case MENU_TESTMODE: <br>            if (gfTestMode) <br>                DestroyTestDialog(); <br>            else <br>                CreateTestDialog(); <br> <br>            break; <br> <br>        case MENU_HEXMODE: <br>            /* <br>             * Flip the flag, and update the status display so that <br>             * the id value will be displayed in the new format. <br>             */ <br>            gfHexMode = gfHexMode ? FALSE : TRUE; <br>            StatusUpdate(); <br>            break; <br> <br>        case MENU_TRANSLATE: <br>            /* <br>             * Flip the flag, and set the enable state of the fields <br>             * in the status window.  Changing the translate mode can <br>             * effect whether they are allowed to change ids of controls. <br>             */ <br>            gfTranslateMode = gfTranslateMode ? FALSE : TRUE; <br> <br>            /* <br>             * If they turned on Translate mode, reset the tool and <br>             * hide the Toolbox.  Otherwise, show the toolbox if they <br>             * want it shown. <br>             */ <br>            if (gfTranslateMode) { <br>                ToolboxShow(FALSE); <br>                ToolboxSelectTool(W_NOTHING, FALSE); <br>            } <br>            else if (gfShowToolbox) { <br>                ToolboxShow(TRUE); <br>            } <br> <br>            StatusSetEnable(); <br>            break; <br> <br>        case MENU_USENEWKEYWORDS: <br>            /* <br>             * Flip the flag. <br>             */ <br>            gfUseNewKeywords = gfUseNewKeywords ? FALSE : TRUE; <br>            break; <br> <br>        case MENU_SHOWTOOLBOX: <br>            /* <br>             * Toggle the state of the Toolbox. <br>             */ <br>            gfShowToolbox = gfShowToolbox ? FALSE : TRUE; <br>            ToolboxShow(gfShowToolbox); <br> <br>            break; <br> <br>        /* <br>         * Help menu ---------------------------------------------------- <br>         */ <br> <br>        case MENU_CONTENTS: <br>            WinHelp(ghwndMain, gszHelpFile, HELP_CONTENTS, 0L); <br>            break; <br> <br>        case MENU_SEARCH: <br>            /* <br>             * Tell winhelp to be sure this app's help file is current, <br>             * then invoke a search with an empty starting key. <br>             */ <br>            WinHelp(ghwndMain, gszHelpFile, HELP_FORCEFILE, 0); <br>            WinHelp(ghwndMain, gszHelpFile, HELP_PARTIALKEY, (DWORD)szEmpty); <br>            break; <br> <br>        case MENU_ABOUT: <br>            DlgBox(DID_ABOUT, (WNDPROC)AboutDlgProc); <br>            break; <br> <br>        /* <br>         * Hidden menu commands (accessed by accelerators) -------------- <br>         */ <br> <br>        case MENU_HIDDEN_TOTOOLBOX: <br>            if (ghwndToolbox &amp;&amp; IsWindowVisible(ghwndToolbox)) <br>                SetFocus(ghwndToolbox); <br> <br>            break; <br> <br>        case MENU_HIDDEN_TOPROPBAR: <br>            SetFocus(hwndStatus); <br>            break; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* LoadMenuBitmaps <br>* <br>* This function loads and inserts the menu items that are bitmaps. <br>* This has to be done at runtime because windows does not have a <br>* way to specify bitmap menu items in the rc file. <br>* <br>* Arguments: <br>*   HMENU hMenu - The menu handle. <br>* <br>************************************************************************/ <br> <br>VOID LoadMenuBitmaps( <br>    HMENU hMenu) <br>{ <br>    INT i; <br> <br>    for (i = 0; i &lt; sizeof(bmpmenuTable) / sizeof(BITMAPMENU); i++) { <br>        bmpmenuTable[i].hbm = <br>                LoadBitmap(ghInst, MAKEINTRESOURCE(bmpmenuTable[i].idbm)); <br> <br>        ModifyMenu(hMenu, bmpmenuTable[i].idm, <br>                MF_BYCOMMAND | MF_BITMAP, bmpmenuTable[i].idm, <br>                (LPTSTR)(DWORD)bmpmenuTable[i].hbm); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* FreeMenuBitmaps <br>* <br>* This function frees the menu bitmaps that were loaded by <br>* LoadMenuBitmaps.  This function should be called only when <br>* the application is exiting, because it frees the bitmaps <br>* without removing them from the menu first. <br>* <br>************************************************************************/ <br> <br>VOID FreeMenuBitmaps(VOID) <br>{ <br>    INT i; <br> <br>    for (i = 0; i &lt; sizeof(bmpmenuTable) / sizeof(BITMAPMENU); i++) <br>        if (bmpmenuTable[i].hbm) <br>            DeleteObject(bmpmenuTable[i].hbm); <br>} <br> <br> <br> <br>/************************************************************************ <br>* InitMenu <br>* <br>* This function grays/enables and checks/unchecks the menu items <br>* appropriately for the given state. <br>* <br>* Arguments: <br>*   HMENU hMenu - The menu handle. <br>* <br>************************************************************************/ <br> <br>VOID InitMenu( <br>    HMENU hMenu) <br>{ <br>    register INT i; <br>    BOOL fEnable; <br>    NPCTYPE npc; <br>    HMENU hMenuArrange; <br> <br>    MyEnableMenuItem(hMenu, MENU_NEWRES, !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_SAVE, <br>            (gfEditingDlg || gprlHead) &amp;&amp; (gfResChged || gfIncChged)); <br> <br>    MyEnableMenuItem(hMenu, MENU_SAVEAS, gfEditingDlg || gprlHead); <br> <br>    MyEnableMenuItem(hMenu, MENU_SETINCLUDE, <br>            (gfEditingDlg || gprlHead) &amp;&amp; !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_REMCUST, gpclHead); <br> <br>    MyEnableMenuItem(hMenu, MENU_RESTOREDIALOG, gfDlgChanged &amp;&amp; gcd.prl); <br> <br>    MyEnableMenuItem(hMenu, MENU_CUT, <br>            gnpcSel &amp;&amp; gfEditingDlg &amp;&amp; !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_COPY, gnpcSel &amp;&amp; gfEditingDlg); <br> <br>    MyEnableMenuItem(hMenu, MENU_PASTE, !gfTranslateMode &amp;&amp; <br>            IsClipboardFormatAvailable(fmtDlg) &amp;&amp; <br>            (gfEditingDlg || DlgInClipboard())); <br> <br>    MyEnableMenuItem(hMenu, MENU_DELETE, gnpcSel &amp;&amp; !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_DUPLICATE, gnpcSel &amp;&amp; !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_SYMBOLS, <br>            (gfEditingDlg || gprlHead) &amp;&amp; !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_STYLES, gnpcSel &amp;&amp; !gfTranslateMode); <br> <br>    /* <br>     * For the "Size to text" menu command to be enabled, there <br>     * must be at least one control selected, and one of the <br>     * controls selected has to be able to be sized to its text. <br>     */ <br>    fEnable = FALSE; <br>    if (gcSelected) { <br>        for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>            if (npc-&gt;fSelected &amp;&amp; npc-&gt;pwcd-&gt;fSizeToText) { <br>                fEnable = TRUE; <br>                break; <br>            } <br>        } <br>    } <br> <br>    MyEnableMenuItem(hMenu, MENU_SIZETOTEXT, fEnable); <br> <br>    MyEnableMenuItem(hMenu, MENU_NEWDIALOG, !gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_SELECTDIALOG, gfEditingDlg || gprlHead); <br> <br>    hMenuArrange = GetSubMenu(hMenu, MENUPOS_ARRANGE); <br> <br>    MyEnableMenuItemByPos(hMenuArrange, MENUPOS_ARRANGEALIGN, gcSelected &gt; 1); <br> <br>    MyEnableMenuItemByPos(hMenuArrange, MENUPOS_ARRANGESPACE, gcSelected &gt; 1); <br> <br>    /* <br>     * For the "Same size" menu option to be enabled, there <br>     * must be more than one control selected, and they <br>     * must be sizeable controls. <br>     */ <br>    fEnable = FALSE; <br>    if (gcSelected &gt; 1) { <br>        for (i = 0, npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>            if (npc-&gt;fSelected &amp;&amp; npc-&gt;pwcd-&gt;fSizeable) { <br>                i++; <br> <br>                if (i &gt; 1) { <br>                    fEnable = TRUE; <br>                    break; <br>                } <br>            } <br>        } <br>    } <br> <br>    MyEnableMenuItemByPos(hMenuArrange, MENUPOS_ARRANGESIZE, fEnable); <br> <br>    /* <br>     * For the Arrange/Push buttons menu item to be enabled, <br>     * there must be a dialog up and it must have at least one <br>     * push button.  In addition, if there are control(s) other <br>     * than the dialog selected, at least one of the selected <br>     * controls must be a push button. <br>     */ <br>    fEnable = FALSE; <br>    if (gfEditingDlg || gprlHead) { <br>        if (!gcSelected || gfDlgSelected) { <br>            for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>                if (npc-&gt;pwcd-&gt;iType == W_PUSHBUTTON) { <br>                    fEnable = TRUE; <br>                    break; <br>                } <br>            } <br>        } <br>        else { <br>            for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>                if (npc-&gt;pwcd-&gt;iType == W_PUSHBUTTON &amp;&amp; npc-&gt;fSelected) { <br>                    fEnable = TRUE; <br>                    break; <br>                } <br>            } <br>        } <br>    } <br> <br>    MyEnableMenuItemByPos(hMenuArrange, MENUPOS_ARRANGEPUSH, fEnable); <br> <br>    MyEnableMenuItem(hMenu, MENU_ORDERGROUP, <br>            npcHead &amp;&amp; !gfTranslateMode &amp;&amp; !gfTestMode &amp;&amp; cWindows &gt; 1); <br> <br>    MyEnableMenuItem(hMenu, MENU_TESTMODE, gfEditingDlg); <br>    MyCheckMenuItem(hMenu, MENU_TESTMODE, gfTestMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_HEXMODE, !gfTestMode); <br>    MyCheckMenuItem(hMenu, MENU_HEXMODE, gfHexMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_TRANSLATE, !gfTestMode); <br>    MyCheckMenuItem(hMenu, MENU_TRANSLATE, gfTranslateMode); <br> <br>    MyEnableMenuItem(hMenu, MENU_USENEWKEYWORDS, !gfTestMode); <br>    MyCheckMenuItem(hMenu, MENU_USENEWKEYWORDS, gfUseNewKeywords); <br> <br>    MyEnableMenuItem(hMenu, MENU_SHOWTOOLBOX, !gfTestMode &amp;&amp; !gfTranslateMode); <br>    MyCheckMenuItem(hMenu, MENU_SHOWTOOLBOX, gfShowToolbox); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CopyToClipboard <br>* <br>* Puts the current dialog and a bitmap image of it into the clipboard. <br>* Gives a dialog box resource to the Clipboard. <br>* Gives a bit map to the clipboard. <br>* Clears everything else out of clipboard. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID CopyToClipboard(VOID) <br>{ <br>    INT cbRes; <br>    HANDLE hResClip; <br>    PRES lpRes; <br>    PRES pRes; <br>    HDC hdcSrc; <br>    HDC hdcDst; <br>    RECT rc; <br>    HBITMAP hbm; <br> <br>    /* <br>     * Store the current selection in a dialog resource. <br>     */ <br>    if (!(pRes = AllocDialogResource(FALSE, TRUE))) <br>        return; <br> <br>    /* <br>     * Allocate global memory for it. <br>     */ <br>    cbRes = ResourceSize(pRes); <br>    if (!cbRes || !(hResClip = GlobalAlloc(GHND | GMEM_DDESHARE, cbRes))) { <br>        MyFree(pRes); <br>        Message(MSG_OUTOFMEMORY); <br>        return; <br>    } <br> <br>    /* <br>     * Copy it to the global memory. <br>     */ <br>    lpRes = (PRES)GlobalLock(hResClip); <br>    memcpy(lpRes, pRes, cbRes); <br>    GlobalUnlock(hResClip); <br>    MyFree(pRes); <br> <br>    /* <br>     * Now place it in the clipboard. <br>     */ <br>    if (OpenClipboard(ghwndMain)) { <br>        EmptyClipboard(); <br>        SetClipboardData(fmtDlg, hResClip); <br> <br>        /* <br>         * If the dialog is selected, place a bitmap image of it <br>         * in the clipboard also.  The drag handles will be removed <br>         * first and the dialog will be activated so that the <br>         * image looks proper. <br>         */ <br>        if (gfDlgSelected) { <br>            CancelSelection(FALSE); <br>            SetActiveWindow(gcd.npc-&gt;hwnd); <br>            UpdateWindow(gcd.npc-&gt;hwnd); <br> <br>            if (hdcSrc = GetDC(NULL)) { <br>                GetWindowRect(gcd.npc-&gt;hwnd, &amp;rc); <br>                if (hbm = CreateCompatibleBitmap(hdcSrc, <br>                        rc.right - rc.left, rc.bottom - rc.top)) { <br>                    if (hdcDst = CreateCompatibleDC(hdcSrc)) { <br>                        /* <br>                         * Calculate the dimensions of the bitmap and <br>                         * convert them to tenths of a millimeter for <br>                         * setting the size with the SetBitmapDimensionEx <br>                         * call.  This allows programs like WinWord to <br>                         * retrieve the bitmap and know what size to <br>                         * display it as. <br>                         */ <br>                        SetBitmapDimensionEx(hbm, <br>                                ((rc.right - rc.left) * MM10PERINCH) / <br>                                GetDeviceCaps(hdcSrc, LOGPIXELSX), <br>                                ((rc.bottom - rc.top) * MM10PERINCH) / <br>                                GetDeviceCaps(hdcSrc, LOGPIXELSY), <br>                                NULL); <br> <br>                        SelectObject(hdcDst, hbm); <br>                        BitBlt(hdcDst, 0, 0, <br>                                rc.right - rc.left, rc.bottom - rc.top, <br>                                hdcSrc, rc.left, rc.top, SRCCOPY); <br>                        DeleteDC(hdcDst); <br>                        SetClipboardData(CF_BITMAP, hbm); <br>                    } <br>                    else { <br>                        DeleteObject(hbm); <br>                    } <br>                } <br> <br>                ReleaseDC(NULL, hdcSrc); <br>            } <br> <br>            SetActiveWindow(ghwndMain); <br>            SelectControl(gcd.npc, FALSE); <br>        } <br> <br>        CloseClipboard(); <br>    } <br>    else { <br>        Message(MSG_NOCLIP); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* DlgInClipboard <br>* <br>* This function returns TRUE if there is data in the clipboard in the <br>* dialog format, and this data is for a complete dialog, not just for <br>* a group of controls. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL DlgInClipboard(VOID) <br>{ <br>    HANDLE hClip; <br>    PRES pRes; <br>    PDIALOGBOXHEADER pdbh; <br>    BOOL fDlgResFound = FALSE; <br> <br>    if (!OpenClipboard(ghwndMain)) <br>        return FALSE; <br> <br>    if (hClip = GetClipboardData(fmtDlg)) { <br>        pRes = (PRES)GlobalLock(hClip); <br> <br>        /* <br>         * If cx is CONTROLS_ONLY, then we know that we only <br>         * want to copy the controls in the template, not the <br>         * entire dialog plus controls. <br>         */ <br>        pdbh = (PDIALOGBOXHEADER)SkipResHeader(pRes); <br>        if (pdbh-&gt;cx != CONTROLS_ONLY) <br>            fDlgResFound = TRUE; <br> <br>        GlobalUnlock(hClip); <br>    } <br> <br>    CloseClipboard(); <br> <br>    return fDlgResFound; <br>} <br> <br> <br> <br>/************************************************************************ <br>* PasteFromClipboard <br>* <br>* This routine pastes any data from the clipboard into the current <br>* resource file.  If the data represents a complete dialog, a new dialog <br>* is added.  If it represents some controls, the operation to drop them <br>* into the current dialog is begun. <br>* <br>************************************************************************/ <br> <br>STATICFN VOID PasteFromClipboard(VOID) <br>{ <br>    HANDLE hClip; <br>    PRES pResClip; <br>    PRES pResCopy; <br>    INT cbRes; <br> <br>    if (!OpenClipboard(ghwndMain)) { <br>        Message(MSG_NOCLIP); <br>        return; <br>    } <br> <br>    if (hClip = GetClipboardData(fmtDlg)) { <br>        pResClip = (PRES)GlobalLock(hClip); <br>        cbRes = ResourceSize(pResClip); <br> <br>        /* <br>         * Make a copy of the clipboard data.  This needs to be done <br>         * because we may need to drag the new controls for a while, <br>         * and it is rude to leave the clipboard open that long. <br>         */ <br>        if (pResCopy = (PRES)MyAlloc(cbRes)) { <br>            memcpy((PBYTE)pResCopy, (PBYTE)pResClip, cbRes); <br> <br>            /* <br>             * Now duplicate the dialog or controls in the clipboard. <br>             * The pResCopy buffer does NOT need to be freed here, because <br>             * it will be freed after the drag operation is complete. <br>             */ <br>            MakeCopyFromRes(pResCopy); <br>        } <br> <br>        GlobalUnlock(hClip); <br>    } <br> <br>    CloseClipboard(); <br>} <br> <br> <br> <br>/************************************************************************ <br>* MsgFilterHookFunc <br>* <br>* This is the exported message filter function that is hooked into <br>* the message stream for detecting the pressing of the F1 key, at <br>* which time it calls up the appropriate help. <br>* <br>************************************************************************/ <br> <br>BOOL APIENTRY MsgFilterHookFunc( <br>    INT nCode, <br>    WPARAM wParam, <br>    LPMSG lpMsg) <br>{ <br>    if ((nCode == MSGF_MENU || nCode == MSGF_DIALOGBOX) &amp;&amp; <br>            (lpMsg-&gt;message == WM_KEYDOWN &amp;&amp; lpMsg-&gt;wParam == VK_F1)) { <br>        /* <br>         * Display help. <br>         */ <br>        ShowHelp((nCode == MSGF_MENU) ? TRUE : FALSE); <br> <br>        /* <br>         * Tell Windows to swallow this message. <br>         */ <br>        return 1; <br>    } <br> <br>    return CallNextHookEx(ghhkMsgFilter, nCode, wParam, (LONG)lpMsg); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ShowHelp <br>* <br>* This function is called when the user has requested help.  It will <br>* look at the menu state (if fMenuHelp is TRUE) or which dialog <br>* is currently up to determine the help topic, then it calls WinHelp. <br>* <br>* Arguments: <br>*   BOOL fMenuHelp - TRUE if this help is for a menu (help was requested <br>*                    in the menu modal loop).  If FALSE, general help <br>*                    or help for a dialog is assumed. <br>* <br>************************************************************************/ <br> <br>VOID ShowHelp( <br>    BOOL fMenuHelp) <br>{ <br>    INT nHelpContext = 0; <br>    HWND hwndFocus; <br> <br>    if (fMenuHelp) { <br>        nHelpContext = GetHelpContext(gMenuSelected, gahmapMenu); <br>    } <br>    else { <br>        /* <br>         * Look for help for the current dialog. <br>         */ <br>        if (gidCurrentDlg) { <br>            nHelpContext = GetHelpContext(gidCurrentDlg, gahmapDialog); <br>        } <br>        else { <br>            /* <br>             * There is no current dialog.  Is the window with the <br>             * focus a control on the Properties Bar? <br>             */ <br>            if ((hwndFocus = GetFocus()) &amp;&amp; IsChild(hwndStatus, hwndFocus)) <br>                nHelpContext = GetHelpContext(DID_STATUS, gahmapDialog); <br>        } <br>    } <br> <br>    /* <br>     * If there is help context, display it.  Otherwise display <br>     * the Contents screen. <br>     */ <br>    if (nHelpContext) <br>        WinHelp(ghwndMain, gszHelpFile, HELP_CONTEXT, nHelpContext); <br>    else <br>        WinHelp(ghwndMain, gszHelpFile, HELP_CONTENTS, 0L); <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetHelpContext <br>* <br>* This function takes a subject and returns its matching help <br>* context id from the given HELPMAP table. <br>* <br>* Arguments: <br>*   INT idSubject   - ID of the subject to find the help context for. <br>*   PHELPMAP phmap  - The help map table.  It is assumed that the <br>*                     last entry in the table has a NULL subject id. <br>* <br>************************************************************************/ <br> <br>STATICFN INT GetHelpContext( <br>    INT idSubject, <br>    PHELPMAP phmap) <br>{ <br>    while (phmap-&gt;idSubject) { <br>        if (phmap-&gt;idSubject == idSubject) <br>            return phmap-&gt;HelpContext; <br> <br>        phmap++; <br>    } <br> <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
