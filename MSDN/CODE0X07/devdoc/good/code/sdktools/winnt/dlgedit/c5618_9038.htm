<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5624"></a>UTIL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: util.c <br>* <br>* Contains miscellaneous utility functions for dlgedit. <br>* <br>* Functions: <br>*   MyAlloc() <br>*   MyRealloc() <br>*   MyFree() <br>*   IsValue() <br>*   HasBlanks() <br>*   valtoi() <br>*   axtoi() <br>*   Myitoa() <br>*   itoax() <br>*   IsUniqueID() <br>*   NextID() <br>*   Message() <br>*   ClientToScreenRect() <br>*   ScreenToClientRect() <br>*   DUToWinPoint() <br>*   WinToDUPoint() <br>*   DUToWinRect() <br>*   WinToDURect() <br>*   MapDlgClientPoint() <br>*   MapWindowPoint() <br>*   MyMapWindowRect() <br>*   GetChildRect() <br>*   CenterWindow() <br>*   FitRectToScreen() <br>*   ids() <br>*   PixelsToPointSize() <br>*   PointSizeToPixels() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>#include &lt;stdarg.h&gt; <br>#include &lt;ctype.h&gt; <br> <br> <br>#define CBOVERHEAD      (sizeof(INT)+sizeof(INT)+sizeof(INT)) <br>#define MEMSIGHEAD      0x1234 <br>#define MEMSIGTAIL      0x5678 <br> <br> <br>STATICFN BOOL IDUsedByCtrl(INT id); <br> <br> <br> <br>/**************************************************************************** <br>* MyAlloc <br>* <br>* Does a local alloc. <br>*  <br>* Arguments: <br>*   INT cbAlloc - number of bytes to allocate. <br>* <br>* Returns: <br>* <br>* A pointer to the memory if succesful; otherwise, NULL. <br>* <br>****************************************************************************/ <br> <br>VOID *MyAlloc( <br>    INT cbAlloc) <br>{ <br>    register HANDLE hMem; <br> <br>    if (hMem = LocalAlloc(LMEM_FIXED, cbAlloc)) { <br>        return (VOID *)hMem; <br>    } <br>    else { <br>        MessageBeep(0); <br>        Message(MSG_OUTOFMEMORY); <br> <br>        return NULL; <br>    } <br>} <br> <br> <br>/**************************************************************************** <br>* MyRealloc <br>* <br>* reallocates memory and returns a pointer to the memory block. <br>* <br>****************************************************************************/ <br> <br>VOID *MyRealloc( <br>    VOID *npMem, <br>    INT cbNewAlloc) <br>{ <br>    npMem = (VOID *)LocalReAlloc((HANDLE)npMem, cbNewAlloc, LMEM_MOVEABLE); <br> <br>    if (!npMem) { <br>        MessageBeep(0); <br>        Message(MSG_OUTOFMEMORY); <br> <br>        return NULL; <br>    } <br> <br>    return npMem; <br>} <br> <br>/**************************************************************************** <br>* MyFree <br>* <br>* Frees the specified memory. <br>* <br>****************************************************************************/ <br> <br>VOID *MyFree( <br>    VOID *npMem) <br>{ <br>    if (LocalFree((HANDLE)npMem)) { <br>        MessageBeep(0); <br>        Message(MSG_MEMERROR); <br> <br>        return npMem; <br>    } <br> <br>    return NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* IsValue <br>* <br>* This function tells you if the string you give it represents a <br>* valid value or not.  For this purpose, a valid value can only <br>* have the ascii characters from '0' to '9' with possibly the <br>* first character being '-'.  Or be a Hex Number, with 0x preceeding <br>* it. <br>* <br>* Arguments: <br>*     LPTSTR pszValue  = The string to test. <br>* <br>* Returns: <br>*     (0 == 0) if szValue represents a value. <br>*     (c == 0) if szValue does not represent a value where c is <br>*               non-zero. <br>* <br>* <br>************************************************************************/ <br> <br>BOOL IsValue( <br>    LPTSTR pszValue) <br>{ <br>    INT i; <br> <br>    if (pszValue[0] == CHAR_0 &amp;&amp; <br>            (pszValue[1] == CHAR_X || pszValue[1] == CHAR_CAP_X)) { <br>        for (i = 2; iswxdigit(pszValue[i]); i++) <br>            ; <br>    } <br>    else { <br>        for (i = 0; iswdigit(pszValue[i]) || <br>                (i == 0 &amp;&amp; pszValue[i] == CHAR_MINUS); i++) <br>            ; <br>    } <br> <br>    return (pszValue[i] == 0); <br>} <br> <br> <br> <br>/************************************************************************ <br>* HasBlanks <br>* <br>* This function returns TRUE if the given string has imbedded <br>* blanks in it. <br>* <br>* Arguments: <br>*   LPTSTR psz - String to check. <br>* <br>* <br>************************************************************************/ <br> <br>BOOL HasBlanks( <br>    LPTSTR psz) <br>{ <br>    while (*psz) <br>        if (*psz == CHAR_SPACE) <br>            return TRUE; <br>        else <br>            psz = CharNext(psz); <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* valtoi <br>* <br>* Takes a string and returns its integer representation. <br>* This function handles both hex ("0x1234") and decimal ("1234") <br>* strings transparently. <br>* <br>* Arguments: <br>*   LPTSTR pszValue = The string to convert. <br>* <br>* <br>************************************************************************/ <br> <br>INT valtoi( <br>    LPTSTR pszValue) <br>{ <br>    return (pszValue[0] == CHAR_0 &amp;&amp; <br>            (pszValue[1] == CHAR_CAP_X || pszValue[1] == CHAR_X)) ? <br>            axtoi(&amp;pszValue[2]) : awtoi(pszValue); <br>} <br> <br> <br> <br>/************************************************************************ <br>* axtoi <br>* <br>* This function converts a null terminated ascii string for a <br>* hex number to its integer value.  Should just be the number <br>* with no preceeding "0x" or trailing "H".  Garbage will result <br>* if there are non-hex digits in the string.  Hex digits are: <br>* 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, a, b, c, d, e, f. <br>* Non-hex digits will be treated like '0'. <br>* <br>* Arguments: <br>*     LPTSTR pch  = The null terminated hex string. <br>* <br>* Returns: <br>*     The integer value represented by the given ascii string. <br>* <br>************************************************************************/ <br> <br>INT axtoi( <br>    LPTSTR pch) <br>{ <br>    register TCHAR ch; <br>    register INT n = 0; <br> <br>    while((ch = *pch++) != 0) { <br>        if (iswdigit(ch)) <br>            ch -= CHAR_0; <br>        else if (ch &gt;= CHAR_CAP_A &amp;&amp; ch &lt;= CHAR_CAP_F) <br>            ch += (TCHAR)(10 - CHAR_CAP_A); <br>        else if (ch &gt;= CHAR_A &amp;&amp; ch &lt;= CHAR_F) <br>            ch += (TCHAR)(10 - CHAR_A); <br>        else <br>            ch = (TCHAR)0; <br> <br>        n = 16 * n + ch; <br>    } <br> <br>    return n; <br>} <br> <br> <br> <br>/************************************************************************ <br>* Myitoa <br>* <br>* This function converts a word to an ascii string.  It builds either <br>* a decimal string or a hex string, based on whether Hex Mode is on <br>* when it is called. <br>* <br>* Arguments: <br>*   INT n      - The number to convert. <br>*   LPTSTR psz - The buffer to put the string in, should have at least <br>*                17 bytes to take the string. <br>* <br>************************************************************************/ <br> <br>VOID Myitoa( <br>    INT n, <br>    LPTSTR psz) <br>{ <br>    if (gfHexMode) <br>        itoax(n, psz); <br>    else <br>        itoaw(n, psz, 10); <br>} <br> <br> <br> <br>/************************************************************************ <br>* itoax <br>* <br>* This function converts an int, 'n', to an ascii string <br>* representing it as a 4 digit hex number with "0x" preceeding it. <br>* <br>* Arguments: <br>*   INT n          = The number to convert. <br>*   LPTSTR pszBuff = The buffer to put the string in, must <br>*                    be at least 7 characters long to take the string. <br>* <br>* <br>************************************************************************/ <br> <br>VOID itoax( <br>    INT n, <br>    LPTSTR pszBuff) <br>{ <br>    INT i; <br>    INT j; <br> <br>    pszBuff[0] = CHAR_0; <br>    pszBuff[1] = CHAR_X; <br> <br>    for (i = 5; i &gt; 1; i--) { <br>        j = n &amp; 15; <br> <br>        if (j &gt; 9) <br>            pszBuff[i] = (TCHAR)(j + (CHAR_A - 10)); <br>        else <br>            pszBuff[i] = (TCHAR)(j + CHAR_0); <br> <br>        n = n &gt;&gt; 4; <br>    } <br> <br>    pszBuff[6] = CHAR_NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* NextID <br>* <br>* This function returns the next available id. <br>* <br>* For dialogs, it starts at 100 and increments by 100.  It will not <br>* return a value until it finds one that begins a range that is <br>* not used by any control in any of the dialogs in the res list. <br>* In other words, it is guaranteed that the number returned and <br>* the range of the next 99 numbers are not used by any control in <br>* any dialog in the current res file. <br>* <br>* When returning a new id for a control, it usually starts at the <br>* dialog base, but if there are any controls, it starts at one higher <br>* than the id of the last control in the dialog that does not have <br>* one of the special-cased ids (the unused id, IDOK or IDCANCEL). <br>* It will find the first available id above this. <br>* <br>* When returning a default id for a new label, it starts at the dialog <br>* base (or 100 if there is not a dialog being edited) and starts <br>* searching for the first available one.  It guarantees that the <br>* id returned is not used by any control in the current dialog, or <br>* any other label, or any control in the entire resource list. <br>* <br>* Arguments: <br>*   INT idType      - The type of id desired: <br>*                     NEXTID_DIALOG  = ID for a new dialog. <br>*                     NEXTID_CONTROL = ID for a new control. <br>*                     NEXTID_LABEL   = ID for a new label. <br>*   NPLABEL plHead  - The current label list to check for conflicts with. <br>*   INT idExclude   - An id that you specifically want to skip over. <br>*                     Set to zero if you don't care. <br>* <br>* Returns: <br>*     The "next" unused id value. <br>* <br>* <br>************************************************************************/ <br> <br>INT NextID( <br>    INT idType, <br>    NPLABEL plHead, <br>    INT idExclude) <br>{ <br>    INT id; <br> <br>    if (idType == NEXTID_CONTROL) { <br>        /* <br>         * Start at the base from the dialog plus one.  It is <br>         * assumed that this routine will not be called for an <br>         * id for a control if there is not a dialog being <br>         * edited first. <br>         */ <br>        id = gcd.npc-&gt;id + 1; <br> <br>        /* <br>         * Keep looping until an unused id is found. <br>         */ <br>        while (!IsUniqueID(id) || FindID(id, plHead) || id == idExclude) <br>            id++; <br>    } <br>    else if (idType == NEXTID_DIALOG) { <br>        /* <br>         * Start at 100. <br>         */ <br>        id = 100; <br> <br>        /* <br>         * Keep looping by hundreds until an unused id is found. <br>         */ <br>        while (!IsUniqueID(id) || FindID(id, plHead) || id == idExclude) <br>            id += 100; <br>    } <br>    else { <br>        /* <br>         * We are looking for a default id for a new label.  Start <br>         * at the dialog base, if there is a dialog being edited. <br>         */ <br>        if (gfEditingDlg) <br>            id = gcd.npc-&gt;id + 1; <br>        else <br>            id = 100; <br> <br>        /* <br>         * Keep looping until an unused id is found.  The id should <br>         * not be used by any control in the current dialog, any <br>         * other label already, or any control in the res file. <br>         */ <br>        while (FindID(id, plHead) || FindIDInRes(id) || id == idExclude) <br>            id++; <br>    } <br> <br>    /* <br>     * We found an unused one.  Return it. <br>     */ <br>    return id; <br>} <br> <br> <br> <br>/************************************************************************ <br>* IDUsedByCtrl <br>* <br>* This function returns TRUE if the given ID is used by any control <br>* in the current dialog.  This also counts the text field of W_ICON <br>* controls, if they are ordinals. <br>* <br>* Arguments: <br>*   INT id = The ID to look for. <br>* <br>* Returns: <br>*   TRUE if the id is used, FALSE if not. <br>* <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL IDUsedByCtrl( <br>    INT id) <br>{ <br>    register NPCTYPE npc; <br> <br>    for (npc = npcHead; npc; npc = npc-&gt;npcNext) { <br>        if (npc-&gt;id == id || <br>                (npc-&gt;pwcd-&gt;iType == W_ICON &amp;&amp; <br>                npc-&gt;text &amp;&amp; <br>                IsOrd(npc-&gt;text) &amp;&amp; <br>                id == (INT)OrdID(npc-&gt;text))) <br>            return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* IsUniqueID <br>* <br>* This function returns TRUE if the given id is unique.  A unique <br>* id is either the special "unused" id value, or it is an id that <br>* is not already assigned to any other control in the current dialog <br>* and it is not assigned to any other dialog in the current res list. <br>* <br>* Note that this routine does NOT look for duplicates in the include <br>* file of this id, only for ids that have been used by other controls <br>* or dialogs already. <br>* <br>* Arguments: <br>*   INT id = The id to verify is unique. <br>* <br>* Returns: <br>*   TRUE if the id is "unique", FALSE if it is not. <br>* <br>* <br>************************************************************************/ <br> <br>BOOL IsUniqueID( <br>    INT id) <br>{ <br>    ORDINAL ord; <br> <br>    /* <br>     * If the id is the special unused id, it is considered unique. <br>     */ <br>    if (id == IDUNUSED) <br>        return TRUE; <br> <br>    /* <br>     * Not unique if another control in the dialog has the same id. <br>     */ <br>    if (IDUsedByCtrl(id)) <br>        return FALSE; <br> <br>    /* <br>     * Not unique if another dialog has the same id. <br>     */ <br>    WriteOrd(&amp;ord, id); <br>    if (FindDialog((LPTSTR)&amp;ord)) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* Message <br>* <br>* This function puts up a message box with a string indexed by idMsg. <br>* <br>* Returns: <br>*     What MessageBox returns. <br>* <br>************************************************************************/ <br> <br>INT Message( <br>    INT idMsg, <br>    ...) <br>{ <br>    va_list marker; <br>    INT RetCode; <br>    TCHAR szT[CCHTEXTMAX]; <br>    BOOL fDisabledSave; <br> <br>    va_start(marker, idMsg); <br>    wvsprintf(szT, ids(gamdMessages[idMsg].ids), marker); <br> <br>    fDisabledSave = gfDisabled; <br>    gfDisabled = TRUE; <br>    RetCode = MessageBox(NULL, szT, ids(IDS_DLGEDIT), <br>            (WORD)(gamdMessages[idMsg].fMessageBox | MB_TASKMODAL)); <br>    gfDisabled = fDisabledSave; <br> <br>    va_end(marker); <br> <br>    return RetCode; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ClientToScreenRect <br>* <br>* This function converts the coordinates in a rectangle from points <br>* relative to the client area into points that are relative to the <br>* screen. <br>* <br>* Arguments: <br>*   HWND hwnd - Window handle for the conversion. <br>*   PRECT prc - Pointer to the rectangle to convert. <br>* <br>* <br>************************************************************************/ <br> <br>VOID ClientToScreenRect( <br>    HWND hwnd, <br>    PRECT prc) <br>{ <br>    ClientToScreen(hwnd, (PPOINT)prc); <br>    ClientToScreen(hwnd, ((PPOINT)prc) + 1); <br>} <br> <br> <br> <br>/************************************************************************ <br>* ScreenToClientRect <br>* <br>* This function converts the coordinates in a rectangle from points <br>* relative to the screen into points that are relative to the given <br>* window's client area. <br>* <br>* Arguments: <br>*   HWND hwnd - Window handle for the conversion. <br>*   PRECT prc - Pointer to the rectangle to convert. <br>* <br>* <br>************************************************************************/ <br> <br>VOID ScreenToClientRect( <br>    HWND hwnd, <br>    PRECT prc) <br>{ <br>    ScreenToClient(hwnd, (PPOINT)prc); <br>    ScreenToClient(hwnd, ((PPOINT)prc) + 1); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DUToWinPoint <br>* <br>* This function converts the coordinates in the given point from <br>* dialog units (DU's) to window units for the current dialog. <br>* <br>* Arguments: <br>*   PPOINT ppt - Pointer to the point to convert. <br>* <br>* <br>************************************************************************/ <br> <br>VOID DUToWinPoint( <br>    PPOINT ppt) <br>{ <br>    ppt-&gt;x = MulDiv(ppt-&gt;x, gcd.cxChar, 4); <br>    ppt-&gt;y = MulDiv(ppt-&gt;y, gcd.cyChar, 8); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WinToDUPoint <br>* <br>* This function converts the coordinates in the given point from <br>* window points to dialog units (DU's) for the current dialog. <br>* <br>* Arguments: <br>*   PPOINT ppt - Pointer to the point to convert. <br>* <br>* <br>************************************************************************/ <br> <br>VOID WinToDUPoint( <br>    PPOINT ppt) <br>{ <br>    ppt-&gt;x = MulDiv(ppt-&gt;x, 4, gcd.cxChar); <br>    ppt-&gt;y = MulDiv(ppt-&gt;y, 8, gcd.cyChar); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DUToWinRect <br>* <br>* This function converts the coordinates in a rectangle from <br>* dialog units for the current dialog to window units. <br>* <br>* Arguments: <br>*   PRECT prc - Pointer to the rectangle to convert. <br>* <br>* <br>************************************************************************/ <br> <br>VOID DUToWinRect( <br>    PRECT prc) <br>{ <br>    DUToWinPoint((PPOINT)prc); <br>    DUToWinPoint(((PPOINT)prc) + 1); <br>} <br> <br> <br> <br>/************************************************************************ <br>* WinToDURect <br>* <br>* This function converts the coordinates in a rectangle from <br>* window units to dialog units for the current dialog. <br>* <br>* Arguments: <br>*   PRECT prc - Pointer to the rectangle to convert. <br>* <br>* <br>************************************************************************/ <br> <br>VOID WinToDURect( <br>    PRECT prc) <br>{ <br>    WinToDUPoint((PPOINT)prc); <br>    WinToDUPoint(((PPOINT)prc) + 1); <br>} <br> <br> <br> <br>/************************************************************************ <br>* MapDlgClientPoint <br>* <br>* This function converts client points to be relative to the window <br>* origin instead, or the other way around.  If fFromClient is TRUE, <br>* the point is considered to be relative to the client origin in <br>* the dialog, and will be converted to a point relative to the <br>* window origin instead. <br>* <br>* If fFromClient is FALSE, the point is considered to be relative <br>* to the window origin, and will be mapped to a point that is <br>* relative to the client origin. <br>* <br>* This function assumes that the global grcDlgClient has been <br>* previously calculated.  It should only be called to map points <br>* for the current dialog being edited (for which grcDlgClient has <br>* been calculated). <br>* <br>* Arguments: <br>*   PPOINT ppt       - Pointer to the point to convert. <br>*   BOOL fFromClient - TRUE if the point is relative to the client origin. <br>* <br>* <br>************************************************************************/ <br> <br>VOID MapDlgClientPoint( <br>    PPOINT ppt, <br>    BOOL fFromClient) <br>{ <br>    if (fFromClient) { <br>        ppt-&gt;x += grcDlgClient.left; <br>        ppt-&gt;y += grcDlgClient.top; <br>    } <br>    else { <br>        ppt-&gt;x -= grcDlgClient.left; <br>        ppt-&gt;y -= grcDlgClient.top; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* MapWindowPoint <br>* <br>* This function maps a point from one window to another.  The point <br>* given is in window coordinates (not client coordinates) and is <br>* mapped so that it is relative to the destination window. <br>* <br>* Arguments: <br>*   HWND hwndFrom   - Source window. <br>*   HWND hwndTo     - Destination window. <br>*   PPOINT ppt      - Pointer to the point to convert. <br>* <br>* Comments: <br>* In Win 3.1 (and NT) the MapWindowPoints call can be used and this one can be removed. <br>* It is only needed here for compatibility with Win 3.0. <br>* <br>************************************************************************/ <br> <br>VOID MapWindowPoint( <br>    HWND hwndFrom, <br>    HWND hwndTo, <br>    PPOINT ppt) <br>{ <br>    RECT rcFrom; <br>    RECT rcTo; <br> <br>    GetWindowRect(hwndFrom, &amp;rcFrom); <br>    GetWindowRect(hwndTo, &amp;rcTo); <br> <br>    ppt-&gt;x += rcFrom.left - rcTo.left; <br>    ppt-&gt;y += rcFrom.top - rcTo.top; <br>} <br> <br> <br> <br>/************************************************************************ <br>* MyMapWindowRect <br>* <br>* This function maps a rectangle from one window to another.  The rectangle <br>* given is in window coordinates (not client coordinates) and is <br>* mapped so that it is relative to the destination window. <br>* <br>* Arguments: <br>*   HWND hwndFrom   - Source window. <br>*   HWND hwndTo     - Destination window. <br>*   PRECT prc       - Pointer to the rectangle to convert. <br>* <br>* Comments: <br>* In Win 3.1 (and NT) the MapWindowRect call can be used and this one can be removed. <br>* It is only needed here for compatibility with Win 3.0. <br>************************************************************************/ <br> <br>VOID MyMapWindowRect( <br>    HWND hwndFrom, <br>    HWND hwndTo, <br>    PRECT prc) <br>{ <br>    RECT rcFrom; <br>    RECT rcTo; <br> <br>    GetWindowRect(hwndFrom, &amp;rcFrom); <br>    GetWindowRect(hwndTo, &amp;rcTo); <br> <br>    OffsetRect(prc, rcFrom.left - rcTo.left, rcFrom.top - rcTo.top); <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetChildRect <br>* <br>* This function returns the client rectangle for a given child control, <br>* mapped to its parent window. <br>* <br>* Arguments: <br>*   HWND hwndChild - Child window. <br>*   PRECT prc      - Where to return the rectangle. <br>* <br>************************************************************************/ <br> <br>VOID GetChildRect( <br>    HWND hwndChild, <br>    PRECT prc) <br>{ <br>    HWND hwndParent; <br> <br>    hwndParent = GetParent(hwndChild); <br>    GetClientRect(hwndChild, prc); <br>    ClientToScreenRect(hwndChild, prc); <br>    ScreenToClientRect(hwndParent, prc); <br>} <br> <br> <br> <br>/************************************************************************ <br>* CenterWindow <br>* <br>* This function centers the given window over its owner.  It ensures <br>* that the window is entirely within the visible screen, however. <br>* If the window does not have an owner, it is centered over the <br>* desktop. <br>* <br>* Arguments: <br>*   HWND hwnd - The window to center. <br>* <br>************************************************************************/ <br> <br>VOID CenterWindow( <br>    HWND hwnd) <br>{ <br>    RECT rc; <br>    RECT rcOwner; <br>    RECT rcCenter; <br>    HWND hwndOwner; <br> <br>    GetWindowRect(hwnd, &amp;rc); <br> <br>    if (!(hwndOwner = GetWindow(hwnd, GW_OWNER))) <br>        hwndOwner = GetDesktopWindow(); <br> <br>    GetWindowRect(hwndOwner, &amp;rcOwner); <br> <br>    /* <br>     *  Calculate the starting x,y for the new <br>     *  window so that it would be centered. <br>     */ <br>    rcCenter.left = rcOwner.left + <br>            (((rcOwner.right - rcOwner.left) - <br>            (rc.right - rc.left)) <br>            / 2); <br> <br>    rcCenter.top = rcOwner.top + <br>            (((rcOwner.bottom - rcOwner.top) - <br>            (rc.bottom - rc.top)) <br>            / 2); <br> <br>    rcCenter.right = rcCenter.left + (rc.right - rc.left); <br>    rcCenter.bottom = rcCenter.top + (rc.bottom - rc.top); <br> <br>    FitRectToScreen(&amp;rcCenter); <br> <br>    SetWindowPos(hwnd, NULL, rcCenter.left, rcCenter.top, 0, 0, <br>            SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br> <br>/************************************************************************ <br>* FitRectToScreen <br>* <br>* This function ensures that the given rectangle is entirely within <br>* the visible screen, adjusting it if necessary. <br>* <br>* Arguments: <br>*   PRECT prc - The rectangle. <br>* <br>************************************************************************/ <br> <br>VOID FitRectToScreen( <br>    PRECT prc) <br>{ <br>    INT cxScreen; <br>    INT cyScreen; <br>    INT delta; <br> <br>    cxScreen = GetSystemMetrics(SM_CXSCREEN); <br>    cyScreen = GetSystemMetrics(SM_CYSCREEN); <br> <br>    if (prc-&gt;right &gt; cxScreen) { <br>        delta = prc-&gt;right - prc-&gt;left; <br>        prc-&gt;right = cxScreen; <br>        prc-&gt;left = prc-&gt;right - delta; <br>    } <br> <br>    if (prc-&gt;left &lt; 0) { <br>        delta = prc-&gt;right - prc-&gt;left; <br>        prc-&gt;left = 0; <br>        prc-&gt;right = prc-&gt;left + delta; <br>    } <br> <br>    if (prc-&gt;bottom &gt; cyScreen) { <br>        delta = prc-&gt;bottom - prc-&gt;top; <br>        prc-&gt;bottom = cyScreen; <br>        prc-&gt;top = prc-&gt;bottom - delta; <br>    } <br> <br>    if (prc-&gt;top &lt; 0) { <br>        delta = prc-&gt;bottom - prc-&gt;top; <br>        prc-&gt;top = 0; <br>        prc-&gt;bottom = prc-&gt;top + delta; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* ids <br>* <br>* This function will return a string, given the string id.  If this is <br>* the first time that the string has been retrieved, memory will be <br>* allocated for it and it will be loaded.  After it is loaded once, it <br>* is then cached in a LPTSTR array and is available for later without <br>* having to load it again. <br>* <br>* Arguments: <br>*   UINT idString - String ID of the string to retrieve. <br>* <br>************************************************************************/ <br> <br>LPTSTR ids( <br>    UINT idString) <br>{ <br>    static LPTSTR apsz[CSTRINGS];       // String resource array cache. <br>    LPTSTR psz; <br>    INT cch; <br> <br>    if (apsz[idString]) <br>        return apsz[idString]; <br> <br>    if (!(psz = MyAlloc(CCHTEXTMAX * sizeof(TCHAR)))) <br>        return szEmpty; <br> <br>    if (!(cch = LoadString(ghInst, idString, psz, CCHTEXTMAX))) { <br>        MyFree(psz); <br>        return szEmpty; <br>    } <br> <br>    apsz[idString] = psz = MyRealloc(psz, (cch + 1) * sizeof(TCHAR)); <br> <br>    return (psz ? psz : szEmpty); <br>} <br> <br> <br> <br>/************************************************************************ <br>* PixelsToPointSize <br>* <br>* This function takes a font height in pixels and converts it to <br>* the equivalent point size.  Note that the pixel height of a font <br>* is actually the tmHeight field of the TEXTMETRIC structure minus <br>* the tmInternalLeading value. <br>* <br>* This function relies on the global gcyPixelsPerInch having been <br>* set before it is called. <br>* <br>* Arguments: <br>*   INT nPixels - Pixel size to convert to point size. <br>* <br>************************************************************************/ <br> <br>INT PixelsToPointSize( <br>    INT nPixels) <br>{ <br>    return MulDiv(nPixels, 72, gcyPixelsPerInch); <br>} <br> <br> <br> <br>/************************************************************************ <br>* PointSizeToPixels <br>* <br>* This function takes a given point size and converts it to the <br>* equivalent pixel text height.  This value can be placed in <br>* the TEXTMETRIC structure's tmHeight field if it is made negative <br>* first.  This will cause a CreateFont call to automatically <br>* subtract the internal leading value before creating the font. <br>* <br>* This function relies on the global gcyPixelsPerInch having been <br>* set before it is called. <br>* <br>* Arguments: <br>*   INT nPointSize - Point size to convert to pixels. <br>* <br>************************************************************************/ <br> <br>INT PointSizeToPixels( <br>    INT nPointSize) <br>{ <br>    return MulDiv(nPointSize, gcyPixelsPerInch, 72); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
