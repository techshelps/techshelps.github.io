<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INCLUDE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5611"></a>INCLUDE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: include.c <br>* <br>* This module contains routines that manipulate the linked lists <br>* of labels (symbols plus id values). <br>* <br>* Functions: <br>*    AddLabel() <br>*    FindLabel() <br>*    FindID() <br>*    FindIDInRes() <br>*    DeleteLabel() <br>*    IsSymbol() <br>*    IDToLabel() <br>*    LabelToID() <br>*    FreeLabels() <br>* <br>* Comments: <br>* <br>* The following describes the linked lists of LABEL structures that <br>* contain all the symbols that are in the include file.  It is <br>* important that these structures and lists be maintained properly <br>* for the udpating of the include file to occur properly. <br>* <br>* The following fields are in the LABEL structure: <br>* <br>*   npNext   - points to * the next label in the list.  This is NULL  <br>*              for the last link in the list.   <br>*   pszLabel - points to a null terminated, allocated string that  <br>*              has the symbol.  This needs to be free'd if the structure <br>*              is free'd. <br>*   id       - the current id value for this symbol. <br>*   idOrig   - the id value as read from the include file.  This <br>*              field is used to determine if the id value has been changed  <br>*              or not, so it is the same as the id unless the user has  <br>*              modified the id value of the symbol.   <br>*   fpos     - the file pointer offset to the "#" in the "#define" in  <br>*              the include file as it was read in.  This field is used  <br>*              to determine where the "#define" line starts in the <br>*              file.  If the label is added by the user (it does not exist  <br>*              in the include file) this field will be set to FPOS_MAX. <br>*   nValueOffset - the offset in bytes from the fpos value to the start of  <br>*              the id value in the "#define" line in the include file.  This  <br>*              will be ignored if fpos is set to FPOS_MAX. <br>* <br>* The order of the linked lists of labels are very important.  The order <br>* will be exactly the same as is read from the include file.  This <br>* allows any changes to be merged back out to the new  include file <br>* when it is saved.  If any labels are added by the user, they will be <br>* added to the end of the list.  The start of the new ones is detected <br>* by the first label with an fpos value of FPOS_MAX (which all the <br>* new ones should have).  Because the order of the new labels is not <br>* critical (they will be added to the end of the include file) the <br>* new labels are sorted by id value.  Because the id values given <br>* to dialogs and controls by default are ascending, this will tend to <br>* group dialogs labels and their associated control labels together. <br>* <br>* Linked lists of labels always come in pairs.  There is the linked <br>* list of current labels (ones read from the include file followed <br>* by labels added later), and there is also a separate linked list <br>* of "deleted" labels.  The deleted label list is required because <br>* when the include file is saved, the deleted labels must be removed <br>* from the include file, so the label structure for them (which <br>* contains their file offset and so on) must be kept around.  When <br>* the user deletes a label, it is removed from the current label <br>* linked list and added to the deleted label list.  The deleted label <br>* list MUST be kept in order by fpos, but if the label that is <br>* deleted is one that did not exist in the include file (its fpos <br>* was FPOS_MAX) then it does NOT have to be added to the deleted <br>* list, and can simply be free'd.  When the user adds a new label, <br>* the deleted list is searched first to see if the label was <br>* previously deleted.  If it was, it is removed from the deleted list <br>* and placed back in the current label list (sorted by fpos, of <br>* course).  If it is a new label, it is simply added to the new labels <br>* at the end of the list (sorted by id value).  This is why every <br>* function that takes a pointer to the head of a label list also <br>* takes a pointer to the head of a deleted label list. <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br> <br> <br>/************************************************************************ <br>* AddLabel <br>* <br>* This adds a symbol/label into the given include file list.  The deleted <br>* include list is first searched and if a deleted label is found with the <br>* same symbol, it is transfered back into the include list.  This is to <br>* handle the case where a user reads in an include file, deletes one of <br>* the labels then adds it back in later. <br>* <br>* The npLabelSkip parameter is for the special case of changing a <br>* label.  This is done by adding a new label then deleting the old <br>* one, so setting this parameter prevents a spurious "duplicate id" <br>* message during the add. <br>* <br>* The pfDups parameter can be used to set a flag when there is a <br>* duplicate symbol, or a symbol with the same id found in the include <br>* list.  If this parameter is NULL, nothing is returned and the appropriate <br>* error message is displayed if a dup is found.  If this parameter is not <br>* NULL, it is assumed to point to a BOOL that will be set to TRUE if either <br>* of these conditions is found.  The flag will NOT be set to FALSE if this <br>* condition is NOT found, so AddLabel can be used in a loop and when the <br>* loop is done, *pfDups will contain TRUE if there were any duplicates. <br>* Note that if pfDups is not NULL, the dup error messages will be supressed. <br>* This routine truncates pszLabel at the first space.  It can allocate  <br>* memory for a LABEL and for its string. The pplHead and pplDelHead lists <br>* are updated. <br>* <br>* Arguments: <br>*     LPTSTR pszLabel      = The label to add. <br>*     INT id               = The id associated with rgchLabel. <br>*     DWORD fpos           = The file position in the include file where the <br>*                            "#define" for this label starts, or FPOS_MAX <br>*                            if the label was not read from an include file. <br>*     INT nValueOffset     = Offset from fpos where the id value begins. <br>*     NPLABEL *pplHead     = Pointer to the head of the include list to use. <br>*     NPLABEL *pplDelHead  = Pointer to the head of the deleted include list. <br>*     NPLABEL npLabelSkip  = If not NULL, points to a label to skip when <br>*                            checking for duplicates. <br>*     BOOL *pfDups         = Points to a BOOL that is set to TRUE if there <br>*                            is a duplicate symbol or id found. <br>* <br>* Returns: <br>*     Pointer to the allocated LABEL structure - NULL for an error. <br>* <br>************************************************************************/ <br> <br>NPLABEL AddLabel( <br>    LPTSTR pszLabel, <br>    INT id, <br>    DWORD fpos, <br>    INT nValueOffset, <br>    NPLABEL *pplHead, <br>    NPLABEL *pplDelHead, <br>    NPLABEL npLabelSkip, <br>    BOOL *pfDups) <br>{ <br>    register NPLABEL npTmp; <br>    NPLABEL npLabel; <br>    NPLABEL npPrevLabel; <br>    BOOL fFoundDeleted = FALSE; <br> <br>    /* <br>     * First check for a duplicate id or symbol. <br>     */ <br>    for (npTmp = *pplHead; npTmp; npTmp = npTmp-&gt;npNext) { <br>        if ((npTmp-&gt;id == id || lstrcmp(pszLabel, npTmp-&gt;pszLabel) == 0) &amp;&amp; <br>                npTmp != npLabelSkip) { <br>            if (pfDups) { <br>                *pfDups = TRUE; <br>            } <br>            else { <br>                if (npTmp-&gt;id == id) <br>                    Message(MSG_LABELDUPID); <br>                else <br>                    Message(MSG_SYMEXISTS); <br>            } <br> <br>            return NULL; <br>        } <br>    } <br> <br>    /* <br>     * Search for this symbol in the deleted list first. <br>     */ <br>    npPrevLabel = NULL; <br>    for (npLabel = *pplDelHead; npLabel; npLabel = npLabel-&gt;npNext) { <br>        if (lstrcmp(pszLabel, npLabel-&gt;pszLabel) == 0) { <br>            fFoundDeleted = TRUE; <br>            break; <br>        } <br> <br>        npPrevLabel = npLabel; <br>    } <br> <br>    /* <br>     * Was the label found in the deleted list? <br>     */ <br>    if (fFoundDeleted) { <br>        /* <br>         * Close up the deleted list where the deleted label was. <br>         */ <br>        if (npPrevLabel) <br>            npPrevLabel-&gt;npNext = npLabel-&gt;npNext; <br>        else <br>            *pplDelHead = npLabel-&gt;npNext; <br> <br>        /* <br>         * Set the id in case the user is adding the same symbol <br>         * but with a different id. <br>         */ <br>        npLabel-&gt;id = id; <br> <br>        /* <br>         * Search for where the label should be inserted <br>         * based on its fpos. <br>         */ <br>        npPrevLabel = NULL; <br>        for (npTmp = *pplHead; npTmp; npTmp = npTmp-&gt;npNext) { <br>            if (npTmp-&gt;fpos == FPOS_MAX || npTmp-&gt;fpos &gt; npLabel-&gt;fpos) <br>                break; <br> <br>            npPrevLabel = npTmp; <br>        } <br>    } <br>    else { <br>        /* <br>         * Label was not found in the deleted list.  Allocate, etc. <br>         */ <br>        if (!(npLabel = (NPLABEL)MyAlloc(sizeof(LABEL)))) <br>            return NULL; <br> <br>        npLabel-&gt;id = id; <br>        npLabel-&gt;idOrig = id; <br>        npLabel-&gt;fpos = fpos; <br>        npLabel-&gt;nValueOffset = nValueOffset; <br> <br>        if (!(npLabel-&gt;pszLabel = <br>                (LPTSTR)MyAlloc((lstrlen(pszLabel) + 1) * sizeof(TCHAR)))) { <br>            MyFree(npLabel); <br>            return NULL; <br>        } <br> <br>        lstrcpy(npLabel-&gt;pszLabel, pszLabel); <br> <br>        /* <br>         * Find where to insert the new label.  This will either be <br>         * at the end of the list, or in ascending numerical order <br>         * among the new labels. <br>         */ <br>        npPrevLabel = NULL; <br>        for (npTmp = *pplHead; <br>                npTmp &amp;&amp; (npTmp-&gt;fpos != FPOS_MAX || npTmp-&gt;id &lt; id); <br>                npTmp = npTmp-&gt;npNext) <br>            npPrevLabel = npTmp; <br>    } <br> <br>    /* <br>     * At this point, npLabel points to the label to add, either <br>     * transferred from the deleted list, or allocated fresh. <br>     * The variable npPrevLabel points to the label to insert <br>     * after, or is NULL to indicate that the new label should <br>     * be inserted at the head of the list. <br>     */ <br> <br>    /* <br>     * If this is the first label in the list, or if the <br>     * first label had a greater fpos than the new label, <br>     * insert the new label at the head of the list. <br>     */ <br>    if (!npPrevLabel) { <br>        npLabel-&gt;npNext = *pplHead; <br>        *pplHead = npLabel; <br>    } <br>    /* <br>     * Otherwise, insert it either in the middle of the <br>     * list or at the end. <br>     */ <br>    else { <br>        npLabel-&gt;npNext = npPrevLabel-&gt;npNext; <br>        npPrevLabel-&gt;npNext = npLabel; <br>    } <br> <br>    return npLabel; <br>} <br> <br> <br> <br>/************************************************************************ <br>* FindLabel <br>* <br>* Tells you if the named label is in the given include label list. <br>* <br>* Arguments: <br>*     LPTSTR pszLabel = The label to find. <br>*     NPLABEL plHead  = Head of the include list to traverse. <br>* <br>* Returns: <br>*     NULL if the label is not found. <br>*     Pointer to label structure if the label was found. <br>* <br>* <br>************************************************************************/ <br> <br>NPLABEL FindLabel( <br>    LPTSTR pszLabel, <br>    NPLABEL plHead) <br>{ <br>    NPLABEL npLabel; <br> <br>    for (npLabel = plHead; npLabel; npLabel = npLabel-&gt;npNext) { <br>        if (lstrcmp(pszLabel, npLabel-&gt;pszLabel) == 0) <br>            break; <br>    } <br> <br>    return npLabel; <br>} <br> <br> <br> <br>/************************************************************************ <br>* FindID <br>* <br>* Tells you if the named id is in the given include file buffer. <br>* <br>* Arguments: <br>*     INT id         = The id to find. <br>*     NPLABEL plHead = Head of the label list to use. <br>* <br>* Returns: <br>*     NULL if the id was not found. <br>*     Pointer to label struct if the id was found. <br>* <br>* <br>************************************************************************/ <br> <br>NPLABEL FindID( <br>    INT id, <br>    NPLABEL plHead) <br>{ <br>    NPLABEL npLabel; <br> <br>    for (npLabel = plHead; npLabel; npLabel = npLabel-&gt;npNext) { <br>        if (npLabel-&gt;id == id) <br>            break; <br>    } <br> <br>    return npLabel; <br>} <br> <br> <br> <br>/************************************************************************ <br>* FindIDInRes <br>* <br>* Tells you if the named id is used by any control in the current <br>* resource list.  This also includes searching through the dialog <br>* currently being edited, if there is one. <br>* <br>* Arguments: <br>*   INT id = The id to find. <br>* <br>* Returns: <br>*   TRUE if the id was found, or FALSE if it was not. <br>* <br>* <br>************************************************************************/ <br> <br>BOOL FindIDInRes( <br>    INT id) <br>{ <br>    INT cControls; <br>    PRESLINK prl; <br>    PRES pRes; <br>    PDIALOGBOXHEADER pdbh; <br>    PCONTROLDATA pcd; <br>    NPCTYPE npc; <br>    BOOL fFound = FALSE; <br> <br>    /* <br>     * Is there a current dialog?  If so, search it first and <br>     * we will skip any image for it in the resource list (the <br>     * resource list is probably out of date, anyways). <br>     */ <br>    if (gfEditingDlg) { <br>        /* <br>         * Is the id the same as the current dialog's name? <br>         */ <br>        if (IsOrd(gcd.pszDlgName) &amp;&amp; id == (INT)OrdID(gcd.pszDlgName)) <br>            return TRUE; <br> <br>        /* <br>         * Loop through the current controls, looking for an id match. <br>         */ <br>        for (npc = npcHead; npc; npc = npc-&gt;npcNext) <br>            if (npc-&gt;id == id) <br>                return TRUE; <br>    } <br> <br>    for (prl = gprlHead; prl &amp;&amp; !fFound; prl = prl-&gt;prlNext) { <br>        /* <br>         * Is this a dialog resource and is it NOT the current <br>         * dialog being edited?  If it is the current dialog, <br>         * we skip it because it is probably out of date. <br>         */ <br>        if (prl-&gt;fDlgResource &amp;&amp; prl != gcd.prl) { <br>            if (IsOrd(prl-&gt;pszName) &amp;&amp; id == (INT)OrdID(prl-&gt;pszName)) { <br>                fFound = TRUE; <br>            } <br>            else { <br>                pRes = (PRES)GlobalLock(prl-&gt;hRes); <br>                pdbh = (PDIALOGBOXHEADER)SkipResHeader(pRes); <br>                cControls = (INT)pdbh-&gt;NumberOfItems; <br>                pcd = SkipDialogBoxHeader(pdbh); <br>                while (cControls--) { <br>                    if (id == (INT)pcd-&gt;wId) { <br>                        fFound = TRUE; <br>                        break; <br>                    } <br> <br>                    pcd = SkipControlData(pcd); <br>                } <br> <br>                GlobalUnlock(prl-&gt;hRes); <br>            } <br>        } <br>    } <br> <br>    return fFound; <br>} <br> <br> <br> <br>/************************************************************************ <br>* DeleteLabel <br>* <br>* Removes the LABEL with text pszLabel from the list of labels in <br>* pplHead, closing up the link, and might add it to the deleted list. <br>* <br>* If the label is one that exists in the include file (fpos is valid) <br>* then the label is added to the pplDelHead list in the proper position <br>* (sorted ascending by fpos).  If the label does not exist in the <br>* include file, there is no need to track it and it can be tossed. <br>* <br>* Arguments: <br>*     LPTSTR pszLabel     = The text of the label to delete. <br>*     NPLABEL *pplHead    = Pointer to the head of the include list to use. <br>*     NPLABEL *pplDelHead = Pointer to the head of the deleted include list. <br>* <br>* Side Effects: <br>*     Deletes from the pplHead list. <br>*     Can null *pplHead if the last label is deleted. <br>*     Can add to the pplDelHead list. <br>*     Can free the memory associated with the LABEL and its string. <br>* <br>* <br>************************************************************************/ <br> <br>VOID DeleteLabel( <br>    LPTSTR pszLabel, <br>    NPLABEL *pplHead, <br>    NPLABEL *pplDelHead) <br>{ <br>    NPLABEL npLabel; <br>    NPLABEL npDelLabel; <br>    NPLABEL npPrevLabel; <br> <br>    npPrevLabel = NULL; <br>    for (npLabel = *pplHead; npLabel; npLabel = npLabel-&gt;npNext) { <br>        if (lstrcmp(pszLabel, npLabel-&gt;pszLabel) == 0) { <br>            /* <br>             * Close up the linked list where the deleted label was. <br>             */ <br>            if (npPrevLabel) <br>                npPrevLabel-&gt;npNext = npLabel-&gt;npNext; <br>            else <br>                *pplHead = npLabel-&gt;npNext; <br> <br>            /* <br>             * Is this a label that is NOT in the include file? <br>             * If so, just toss it away. <br>             */ <br>            if (npLabel-&gt;fpos == FPOS_MAX) { <br>                MyFree(npLabel-&gt;pszLabel); <br>                MyFree(npLabel); <br>            } <br>            /* <br>             * Otherwise, it must be added to the deleted list. <br>             */ <br>            else { <br>                /* <br>                 * Search for where the label should be inserted <br>                 * based on its fpos. <br>                 */ <br>                npPrevLabel = NULL; <br>                for (npDelLabel = *pplDelHead; npDelLabel; <br>                        npDelLabel = npDelLabel-&gt;npNext) { <br>                    if (npDelLabel-&gt;fpos &gt; npLabel-&gt;fpos) <br>                        break; <br> <br>                    npPrevLabel = npDelLabel; <br>                } <br> <br>                /* <br>                 * If this is the first label in the deleted list, or <br>                 * if the first label had a greater fpos than the new <br>                 * label, insert the new label at the head of the list. <br>                 */ <br>                if (!npPrevLabel) { <br>                    npLabel-&gt;npNext = *pplDelHead; <br>                    *pplDelHead = npLabel; <br>                } <br>                /* <br>                 * Otherwise, insert it either in the middle of the <br>                 * list or at the end. <br>                 */ <br>                else { <br>                    npLabel-&gt;npNext = npPrevLabel-&gt;npNext; <br>                    npPrevLabel-&gt;npNext = npLabel; <br>                } <br>            } <br> <br>            break; <br>        } <br> <br>        npPrevLabel = npLabel; <br>    } <br>} <br> <br> <br> <br>/**************************************************************************** <br>* IsSymbol <br>* <br>* This routine returns TRUE if the given string is a valid "C" or "RC" <br>* identifier. <br>* <br>* Valid is:  First char is a letter or '_'. <br>* <br>****************************************************************************/ <br> <br>BOOL IsSymbol( <br>    LPTSTR pszSym) <br>{ <br>    register TCHAR ch = *pszSym; <br> <br>    return ((ch &gt;= CHAR_CAP_A &amp;&amp; ch &lt;= CHAR_CAP_Z) || <br>            (ch &gt;= CHAR_A &amp;&amp; ch &lt;= CHAR_Z) || <br>            (ch == CHAR_UNDERLINE)); <br>} <br> <br> <br> <br>/************************************************************************ <br>* IDToLabel <br>* <br>* This function finds the label with the given id. <br>* The first LABEL in the list with the given id will be found. <br>* The label will be put in pchLabel. <br>* If the id was not found then the id is converted to an ascii <br>* representation and put in pchLabel.  This ascii representation <br>* will be in hex notation if hex mode is in effect (unless fHexOK <br>* is FALSE). <br>* <br>* This function special cases the IDOK and IDCANCEL id values. <br>* If there happens to be a label in the include file for these values <br>* then that label will be returned, but if not, either "IDOK" or <br>* "IDCANCEL" will be returned. <br>* <br>* Arguments: <br>*   LPTSTR pchLabel - Where to put the label. <br>*   INT id          - The id of the label to find or match. <br>*   BOOL fHexOK     - TRUE if hex representations of the id are allowed. <br>* <br>* <br>************************************************************************/ <br> <br>VOID IDToLabel( <br>    LPTSTR pchLabel, <br>    INT id, <br>    BOOL fHexOK) <br>{ <br>    NPLABEL npLabel; <br> <br>    npLabel = FindID(id, plInclude); <br> <br>    if (npLabel) { <br>        lstrcpy(pchLabel, npLabel-&gt;pszLabel); <br>    } <br>    else { <br>        if (id == IDOK &amp;&amp; !FindLabel(ids(IDS_IDOK), plInclude)) { <br>            lstrcpy(pchLabel, ids(IDS_IDOK)); <br>        } <br>        else if (id == IDCANCEL &amp;&amp; !FindLabel(ids(IDS_IDCANCEL), plInclude)) { <br>            lstrcpy(pchLabel, ids(IDS_IDCANCEL)); <br>        } <br>        else { <br>            if (fHexOK) <br>                Myitoa(id, pchLabel); <br>            else <br>                itoaw(id, pchLabel, 10); <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* LabelToID <br>* <br>* This function converts a label string to its associated id value. <br>* It first checks the labels in the current include file for a <br>* match.  If it is not found, it then checks for some special values, <br>* like "IDOK", "IDCANCEL" and "(Unused)". <br>* <br>* The return value will be TRUE of the label (symbol) was found, or <br>* FALSE if it was not. <br>* <br>* Arguments: <br>*   LPTSTR pszLabel - The symbol to search for. <br>*   PINT pID        - Where to return the associated id, if found. <br>* <br>************************************************************************/ <br> <br>BOOL LabelToID( <br>    LPTSTR pszLabel, <br>    PINT pID) <br>{ <br>    INT id; <br>    NPLABEL npLabel; <br> <br>    /* <br>     * Is it an existing label? <br>     */ <br>    if (npLabel = FindLabel(pszLabel, plInclude)) { <br>        id = npLabel-&gt;id; <br>    } <br>    /* <br>     * Is it the "unused" symbol? <br>     */ <br>    else if (lstrcmp(pszLabel, ids(IDS_UNUSED)) == 0) { <br>        id = IDUNUSED; <br>    } <br>    /* <br>     * How about the special IDOK entry? <br>     */ <br>    else if (lstrcmp(pszLabel, ids(IDS_IDOK)) == 0) { <br>        id = IDOK; <br>    } <br>    /* <br>     * How about the special IDCANCEL entry? <br>     */ <br>    else if (lstrcmp(pszLabel, ids(IDS_IDCANCEL)) == 0) { <br>        id = IDCANCEL; <br>    } <br>    else { <br>        return FALSE; <br>    } <br> <br>    *pID = id; <br>    return TRUE; <br>} <br> <br> <br> <br>/**************************************************************************** <br>* FreeLabels <br>* <br>* This function frees the labels in the label list pointed to by <br>* nppLabels, including the strings.  When it is done, the label <br>* list head is set to NULL. <br>* <br>****************************************************************************/ <br> <br>VOID FreeLabels( <br>    NPLABEL *nppLabels) <br>{ <br>    register NPLABEL npl; <br>    register NPLABEL nplTemp; <br> <br>    npl = *nppLabels; <br> <br>    while (npl) { <br>        MyFree(npl-&gt;pszLabel); <br> <br>        nplTemp = npl-&gt;npNext; <br> <br>        MyFree(npl); <br>        npl = nplTemp; <br>    } <br> <br>    *nppLabels = NULL; <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
