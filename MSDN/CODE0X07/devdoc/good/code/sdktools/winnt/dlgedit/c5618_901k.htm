<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RWINC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5618"></a>RWINC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: rwinc.c <br>* <br>* Does the include file reading and writing. <br>* <br>* Functions: <br>* <br>*    OpenIncludeFile() <br>*    FreeInclude() <br>*    WriteInc() <br>*    LoadIncludeFile() <br>*    GetChar() <br>*    ReadChar() <br>*    GetLabel() <br>*    GetValue() <br>*    GetWord() <br>*    FindDefine() <br>*    GetNextInc() <br>*    RWToOffset() <br>*    WriteIncChar() <br>*    WriteIncFlush() <br>*    WriteChangedInc() <br>*    WriteDeletedInc() <br>*    WriteAddedInc() <br>*    WriteSymbol() <br>*    WriteIDInc() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include "dlgedit.h" <br>#include "dlgfuncs.h" <br>#include "dlgextrn.h" <br> <br>#include &lt;ctype.h&gt; <br> <br> <br>/* <br> * Field width that the symbol is printed within.  This indirectly <br> * determines where the id value starts, because blanks are added <br> * after the symbol is printed up to this width value. <br> */ <br>#define CCHSYMFIELDWIDTH    27 <br> <br>/* <br> * Return codes from the file reading functions. <br> */ <br>#define READ_OK             1 <br>#define READ_EOF            2 <br>#define READ_BAD            3 <br>#define READ_WRONG          4 <br>#define BAD_POINTER         ((VOID *)0xFFFF) <br> <br>/* <br> * Return codes from the GetNextInc function. <br> */ <br>#define GNI_DONE            0 <br>#define GNI_NOCHANGE        1 <br>#define GNI_CHANGED         2 <br>#define GNI_DELETED         3 <br>#define GNI_ADDED           4 <br> <br>static BYTE abBuffer[CCHFILEBUFFER];    /* Buffer for read file data.       */ <br>static TCHAR achBuffer[CCHFILEBUFFER];  /* Unicode buffer for data.         */ <br>static INT cbBuf;                       /* Pointer into achBuffer.          */ <br>static DWORD cchFile;                   /* Count of characters read.        */ <br>static DWORD cchFileMax;                /* Max characters in file.          */ <br>static DWORD fposLastDefine;            /* Saves location of "#define".     */ <br>static DWORD fposWordStart;             /* Saves start of id value.         */ <br>static BOOL fAtNewLine;                 /* At start or \r or \n.            */ <br>static HANDLE hfInclude;                /* The current include file.        */ <br> <br>STATICFN BOOL LoadIncludeFile(VOID); <br>STATICFN LPTSTR GetChar(VOID); <br>STATICFN LPTSTR ReadChar(VOID); <br>STATICFN INT GetLabel(BOOL *pfDups); <br>STATICFN INT GetValue(PINT pnValue); <br>STATICFN INT GetWord(LPTSTR pch); <br>STATICFN INT FindDefine(VOID); <br>STATICFN INT GetNextInc(NPLABEL *pplReturn, BOOL fFirst); <br>STATICFN BOOL RWToOffset(HANDLE hfWrite, DWORD lOffset); <br>STATICFN BOOL WriteIncChar(HANDLE hfWrite, TCHAR ch); <br>STATICFN BOOL WriteIncFlush(HANDLE hfWrite); <br>STATICFN BOOL WriteChangedInc(HANDLE hfWrite, NPLABEL plInc); <br>STATICFN BOOL WriteDeletedInc(HANDLE hfWrite, NPLABEL plInc); <br>STATICFN BOOL WriteAddedInc(HANDLE hfWrite, NPLABEL plInc); <br>STATICFN BOOL WriteSymbol(HANDLE hfWrite, LPTSTR pszSymbol); <br>STATICFN BOOL WriteIDInc(HANDLE hfWrite, INT id); <br> <br> <br> <br>/**************************************************************************** <br>* OpenIncludeFile <br>* <br>* This function attempts to open and load the include file with name <br>* pointed to by pszOpenInclude.  If pszOpenInclude is just a file name, and <br>* not a path, then the path is taken from szFullLoadFile.  Otherwise <br>* pszOpenInclude itself is used.  The full pathname is put in <br>* szFullIncludeFile and pszIncludeFile is set to point to just the file <br>* name in it.   <br>* <br>* If fDoOpen is TRUE, the file is opened.  If it is FALSE, it is assumed <br>* that hfInc contains the file handle to the opened include file and this <br>* handle is used.  In addition, the caller is responsible for closing <br>* any passed in file handle if an error occurs. <br>* <br>* Any existing includes are freed,  szFullIncludeFile is set to the full  <br>* include path, pszIncludeFile is set to the filename portion of this full  <br>* path and hfInclude will contain the file handle to the include file. <br>* <br>* Arguments: <br>*   LPTSTR pszOpenInclude - name of the include file to open. <br>* <br>* Returns: <br>*   If the load is successful, TRUE is returned.  Otherwise, <br>*   FALSE is returned. <br>* <br>****************************************************************************/ <br> <br>BOOL OpenIncludeFile( <br>    LPTSTR pszOpenInclude) <br>{ <br>    TCHAR szFullIncludeFileTemp[CCHMAXPATH]; <br>    HCURSOR hcurSave; <br>    BOOL fSuccess = FALSE; <br> <br>    hcurSave = SetCursor(hcurWait); <br> <br>    if (FileInPath(pszOpenInclude) == pszOpenInclude) { <br>        lstrcpy(szFullIncludeFileTemp, szFullResFile); <br>        lstrcpy(FileInPath(szFullIncludeFileTemp), pszOpenInclude); <br>    } <br>    else { <br>        lstrcpy(szFullIncludeFileTemp, pszOpenInclude); <br>    } <br> <br>    /* <br>     * Close any existing include file and free memory. <br>     */ <br>    FreeInclude(); <br> <br>    if ((hfInclude = CreateFile(szFullIncludeFileTemp, GENERIC_READ, <br>            FILE_SHARE_READ, NULL, OPEN_EXISTING, <br>            FILE_FLAG_SEQUENTIAL_SCAN, NULL)) != (HANDLE)-1) { <br>        if (LoadIncludeFile()) { <br>            lstrcpy(szFullIncludeFile, szFullIncludeFileTemp); <br>            pszIncludeFile = FileInPath(szFullIncludeFile); <br>            fSuccess = TRUE; <br>        } <br> <br>        CloseHandle(hfInclude); <br>    } <br> <br>    /* <br>     * Update the status windows symbol combo box.  Update other fields <br>     * also, in case the currently selected control's symbol was affected <br>     * by the reading of the new include file. <br>     */ <br>    StatusFillSymbolList(plInclude); <br>    StatusUpdate(); <br> <br>    ShowFileStatus(TRUE); <br>    SetCursor(hcurSave); <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/************************************************************************ <br>* LoadIncludeFile <br>* <br>* This function creates or adds to plInclude with all the #define <br>* statements in the file with handle hfInclude. <br>* <br>* Returns: <br>*     TRUE - Load succeeded. <br>*     FALSE - Load failed (a read error). <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL LoadIncludeFile(VOID) <br>{ <br>    INT RetCode; <br>    BOOL fDups = FALSE; <br> <br>    /* <br>     * Set char count, get file cb. <br>     */ <br>    cchFile = 0L; <br>    cchFileMax = GetFileSize((HANDLE)hfInclude, NULL); <br>    cbBuf = CCHFILEBUFFER; <br>    fAtNewLine = TRUE; <br> <br>    /* <br>     * Loop through and extract all id definitions. <br>     */ <br>    while ((RetCode = FindDefine()) != READ_EOF) { <br>        if (RetCode == READ_BAD || (RetCode = GetLabel(&amp;fDups)) == READ_BAD) { <br>            Message(MSG_INTERNAL); <br>            return FALSE; <br>        } <br>    } <br> <br>    /* <br>     * Warn the user if there were duplicate symbols, <br>     * or symbols with duplicate ids. <br>     */ <br>    if (fDups) <br>        Message(MSG_IDUPIDS); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/**************************************************************************** <br>* FindDefine <br>* <br>* This function looks for ^#define[\s\t], that "#define" at the start <br>* of a line and followed by a space or a tab. <br>* <br>* Returns: <br>*     READ_OK -&gt; All OK &amp; #define found. <br>*     READ_EOF -&gt; All OK, but EOF found before #define. <br>*     READ_BAD = Failure on read. <br>* <br>****************************************************************************/ <br> <br>STATICFN INT FindDefine(VOID) <br>{ <br>    LPTSTR pchIn; <br>    LPTSTR pchCmp; <br>    BOOL fLastAtNewLine; <br> <br>tryagain: <br> <br>    /* <br>     * Skip blank lines looking for a newline followed by a '#'. <br>     */ <br>    while (TRUE) { <br>        fLastAtNewLine = fAtNewLine; <br>        pchIn = GetChar(); <br> <br>        if (pchIn == NULL) <br>            return READ_EOF; <br>        else if (pchIn == BAD_POINTER) <br>            return READ_BAD; <br>        else if (fLastAtNewLine &amp;&amp; *pchIn == CHAR_POUND) <br>            break; <br>        else if (IsDBCSLeadByte((BYTE)*pchIn)) <br>            pchIn = GetChar(); <br>    } <br> <br>    /* <br>     * At this point a newline followed by a '#' has been found. <br>     * Begin checking for "define".  Save away the file offset, <br>     * in case we have really found one. <br>     */ <br>    fposLastDefine = cchFile - 1; <br>    pchCmp = ids(IDS_DEFINE); <br>    do { <br>        pchIn = GetChar(); <br> <br>        if (pchIn == BAD_POINTER) <br>            return READ_BAD; <br>        else if (pchIn == NULL || *pchIn != *pchCmp++) <br>            goto tryagain; <br>    } while (*pchCmp); <br> <br>    /* <br>     * Finally, look for the trailing space or tab after the "#define". <br>     */ <br>    pchIn = GetChar(); <br>    if (pchIn == BAD_POINTER) <br>        return READ_BAD; <br>    else if (pchIn == NULL || (*pchIn != CHAR_SPACE &amp;&amp; *pchIn != CHAR_TAB)) <br>        goto tryagain; <br> <br>    return READ_OK; <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetLabel <br>* <br>* This function gets the next two words from the file hfInclude and treats <br>* them as a label and id, respectively.  It allocates another LABEL <br>* and string to hold this information. <br>* <br>* Arguments: <br>*   BOOL *pfDups = Points to a BOOL that will be set to TRUE if AddLabel <br>*                  finds a duplicate symbol or id. <br>* <br>* Returns: <br>*     READ_OK -&gt; All OK. <br>*     READ_BAD = Failure on read. <br>* <br>************************************************************************/ <br> <br>STATICFN INT GetLabel( <br>    BOOL *pfDups) <br>{ <br>    INT id; <br>    INT RetCode; <br>    TCHAR szLabel[CCHTEXTMAX]; <br> <br>    /* <br>     * Get string and ID at current position <br>     */ <br>    switch (RetCode = GetWord(szLabel)) { <br>        case READ_OK: <br>            if ((RetCode = GetValue(&amp;id)) == READ_OK) { <br>                AddLabel(szLabel, id, fposLastDefine, <br>                        (INT)(fposWordStart - fposLastDefine), <br>                        &amp;plInclude, &amp;plDelInclude, NULL, pfDups); <br>            } <br> <br>            break; <br> <br>        default: <br>            break; <br>    } <br> <br>    return RetCode; <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetWord <br>* <br>* This function uses GetChar to get the next word from the include <br>* file.  First it removes tabs and spaces, then it collects everything <br>* to the next white space.  Finally it null terminates the word. <br>* <br>* Arguments: <br>*     LPTSTR pch  - Where to put the word. <br>* <br>* Returns: <br>*     READ_OK - a word was found. <br>*     READ_EOF - EOF was found. <br>*     READ_BAD - Error on Read. <br>*     READ_WRONG - Found other than ' ' or '\t' followed by a letter, <br>*                   number or _, +, -. <br>* <br>************************************************************************/ <br> <br>STATICFN INT GetWord( <br>    LPTSTR pch) <br>{ <br>    TCHAR ch; <br>    LPTSTR pchIn; <br> <br>    /* <br>     * Skip spaces. <br>     */ <br>    while ((pchIn = GetChar()) != NULL &amp;&amp; pchIn != BAD_POINTER &amp;&amp; <br>                ((ch = *pchIn) == CHAR_SPACE || ch == CHAR_TAB)) <br>        ; <br> <br>    /* <br>     * Errors or EOF? <br>     */ <br>    if (pchIn == NULL) <br>        return READ_EOF; <br>    else if (pchIn == BAD_POINTER) <br>        return READ_BAD; <br>    if (!iscsym(ch) &amp;&amp; ch != CHAR_MINUS &amp;&amp; ch != CHAR_PLUS) <br>        return READ_WRONG; <br> <br>    /* <br>     * Save starting location of the word in the file. <br>     */ <br>    fposWordStart = cchFile - 1; <br> <br>    /* <br>     * Pick out the current word. <br>     */ <br>    do { <br>        *pch++ = ch; <br>    } while ((pchIn = GetChar()) != NULL &amp;&amp; pchIn != BAD_POINTER &amp;&amp; <br>            (ch = *pchIn) != CHAR_SPACE &amp;&amp; ch != CHAR_TAB &amp;&amp; <br>            ch != CHAR_NEWLINE &amp;&amp; ch != CHAR_RETURN); <br> <br>    /* <br>     * Errors or EOF? <br>     */ <br>    if (pchIn == NULL) <br>        return READ_WRONG; <br>    else if (pchIn == BAD_POINTER) <br>        return READ_BAD; <br> <br>    /* <br>     * Null terminate the word. <br>     */ <br>    *pch = (TCHAR)0; <br> <br>    return READ_OK; <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetChar <br>* <br>* This function returns a pointer to the next character in the <br>* stream hfInclude.  It calls ReadChar to do the actual work. <br>* <br>* As it is reading the stream, it will compress a comment sequence to <br>* a single space.  This means that from a slash+asterisk to the next <br>* asterisk+slash and from a pair of slashes to the end of the line all <br>* that will be returned is a single space character. <br>* <br>* Returns: <br>*     A pointer to next character in the stream hfInclude. <br>*     NULL =&gt; End of file. <br>*     BAD_POINTER =&gt; Problems reading file. <br>* <br>************************************************************************/ <br> <br>STATICFN LPTSTR GetChar(VOID) <br>{ <br>    register LPTSTR pch; <br> <br>    /* <br>     * Read the next character. <br>     */ <br>    pch = ReadChar(); <br>    if (pch == NULL || pch == BAD_POINTER) <br>        return pch; <br> <br>    /* <br>     * Possibly starting a comment? <br>     */ <br>    if (*pch == CHAR_SLASH) { <br>        /* <br>         * Starting a traditional comment? <br>         */ <br>        if (*(pch + 1) == CHAR_ASTERISK) { <br>            /* <br>             * Read the '*'. <br>             */ <br>            pch = ReadChar(); <br>            if (pch == NULL || pch == BAD_POINTER) <br>                return pch; <br> <br>            /* <br>             * Read until the next asterisk+slash is found. <br>             */ <br>            do { <br>                pch = ReadChar(); <br>                if (pch == NULL || pch == BAD_POINTER) <br>                    return pch; <br>            } while (*pch != CHAR_ASTERISK || *(pch + 1) != CHAR_SLASH); <br> <br>            /* <br>             * Read the final '/'. <br>             */ <br>            pch = ReadChar(); <br>            if (pch == NULL || pch == BAD_POINTER) <br>                return pch; <br> <br>            /* <br>             * Change it to a space. <br>             */ <br>            *pch = CHAR_SPACE; <br>        } <br>        /* <br>         * Starting a single line comment? <br>         */ <br>        else if (*(pch + 1) == CHAR_SLASH) { <br>            /* <br>             * Read up to the end of line. <br>             */ <br>            do { <br>                pch = ReadChar(); <br>                if (pch == NULL || pch == BAD_POINTER) <br>                    return pch; <br>            } while (*(pch + 1) != CHAR_RETURN &amp;&amp; *(pch + 1) != CHAR_NEWLINE); <br> <br>            /* <br>             * Convert the last character before the newline into a space. <br>             */ <br>            *pch = CHAR_SPACE; <br>        } <br>    } <br> <br>    return pch; <br>} <br> <br> <br> <br>/************************************************************************ <br>* ReadChar <br>* <br>* This function returns a pointer to the next character in the <br>* stream hfInclude, but does it in a buffered fashion.  That is, abBuffer <br>* is filled from hfInclude and pointers are returned to there. <br>* Note that after ReadChar is called, all previous pointers <br>* returned are meaningless. <br>* <br>* Returns: <br>*     A pointer to next character in the stream hfInclude. <br>*     NULL =&gt; End of file. <br>*     BAD_POINTER =&gt; Problems reading file. <br>* <br>* Comments: <br>*     May cause abBuffer to be filled from file with handle hfInclude. <br>*     cbBuf is changed. <br>*     cchFile is changed. <br>*     Sets fAtNewLine = TRUE if char returned is '\n' or '\r', or FALSE <br>*         otherwise.  Not changed unless a character is returned. <br>* <br>************************************************************************/ <br> <br>STATICFN LPTSTR ReadChar(VOID) <br>{ <br>    register LPTSTR pch; <br>    INT cbRead; <br> <br>    if (cchFile &gt;= cchFileMax) <br>        return NULL; <br> <br>    if (cbBuf &gt;= CCHFILEBUFFER) { <br>        if ((cbRead = _lread((HFILE)hfInclude, abBuffer, CCHFILEBUFFER)) == -1) <br>            return BAD_POINTER; <br> <br>        MultiByteToWideChar(CP_ACP, 0, abBuffer, cbRead, achBuffer, <br>                CCHFILEBUFFER); <br> <br>        cbBuf = 0; <br>    } <br> <br>    pch = achBuffer + cbBuf; <br>    cbBuf++; <br>    cchFile++; <br> <br>    if (*pch == CHAR_DOSEOF) { <br>        cchFile = cchFileMax; <br>        return NULL; <br>    } <br> <br>    fAtNewLine = (*pch == CHAR_RETURN || *pch == CHAR_NEWLINE) ? TRUE : FALSE; <br> <br>    return pch; <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetValue <br>* <br>* This function reads the next word in the file hfInclude with GetWord <br>* and converts that word to a number. <br>* <br>* If the second character of the word is an 'x' or 'X', the word is <br>* assumed to be a hex number and it is converted appropriately. <br>* <br>* Arguments: <br>*     npsValue - Where to put the value of the next word in file. <br>* <br>* Returns: <br>*     READ_OK - success. <br>*     READ_BAD - am error occured. <br>*     READ_WRONG - Something other than a number was found. <br>* <br>************************************************************************/ <br> <br>STATICFN INT GetValue( <br>    PINT pnValue) <br>{ <br>    TCHAR achValue[CCHTEXTMAX]; <br>    LPTSTR pch; <br>    INT RetValue; <br> <br>    *pnValue = 0; <br>    if ((RetValue = GetWord(achValue)) != READ_OK) <br>        return RetValue; <br> <br>    /* <br>     * Verify we have only a number. <br>     */ <br>    pch = achValue; <br>    if (pch[1] == CHAR_CAP_X || pch[1] == CHAR_X) { <br>        if (*pch != CHAR_0) { <br>            RetValue = READ_WRONG; <br>        } <br>        else { <br>            for (pch += 2; *pch; pch++) { <br>                if (!iswxdigit(*pch)) { <br>                    RetValue = READ_WRONG; <br>                    break; <br>                } <br>            } <br> <br>            if (RetValue == READ_OK) <br>                *pnValue = axtoi(&amp;achValue[2]); <br>        } <br>    } <br>    else { <br>        if (!iswdigit(*pch) &amp;&amp; *pch != CHAR_MINUS &amp;&amp; *pch != CHAR_PLUS) { <br>            RetValue = READ_WRONG; <br>        } <br>        else { <br>            for (pch++; *pch; pch++) { <br>                if (!iswdigit(*pch)) { <br>                    RetValue = READ_WRONG; <br>                    break; <br>                } <br>            } <br> <br>            if (RetValue == READ_OK) <br>                *pnValue = awtoi(achValue); <br>        } <br>    } <br> <br>    return RetValue; <br>} <br> <br> <br> <br>/************************************************************************ <br>* FreeInclude <br>* <br>* This function frees the memory associated with an include file, <br>* sets global variables to match, and closes the currently open <br>* include file.  It frees plInclude, plDelInclude and all the LABELs in them. <br>* It sets gfIncChged to FALSE, sets pszIncludeFile to NULL, and <br>* closes any open include file. <br>* <br>************************************************************************/ <br> <br>VOID FreeInclude(VOID) <br>{ <br>    FreeLabels(&amp;plInclude); <br>    FreeLabels(&amp;plDelInclude); <br>    gfIncChged = FALSE; <br>    pszIncludeFile = NULL; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteInc <br>* <br>* This function writes the labels in plInclude to an include file. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - handle to the file to write to. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>************************************************************************/ <br> <br>BOOL WriteInc( <br>    HANDLE hfWrite) <br>{ <br>    INT nGNIRet; <br>    NPLABEL plInc; <br>    BOOL fEOF; <br> <br>    /* <br>     * Is there an include file already specified?  If so, <br>     * open it.  If not, we are effectively at EOF now. <br>     */ <br>    if (pszIncludeFile) { <br>        if ((hfInclude = CreateFile(szFullIncludeFile, GENERIC_READ, <br>                FILE_SHARE_READ, NULL, OPEN_EXISTING, <br>                FILE_FLAG_SEQUENTIAL_SCAN, NULL)) == (HANDLE)-1) { <br>            //if the include file is missing or locked... <br>            return FALSE; <br>        } <br> <br>        fEOF = FALSE; <br>    } <br>    else { <br>        fEOF = TRUE; <br>    } <br> <br>    cchFile = 0; <br>    cbWritePos = 0; <br>    cbBuf = CCHFILEBUFFER; <br>    fAtNewLine = TRUE; <br> <br>    /* <br>     * Loop through all the includes. <br>     */ <br>    nGNIRet = GetNextInc(&amp;plInc, TRUE); <br>    while (nGNIRet != GNI_DONE) { <br>        switch (nGNIRet) { <br>            case GNI_NOCHANGE: <br>                break; <br> <br>            case GNI_CHANGED: <br>                if (!WriteChangedInc(hfWrite, plInc)) <br>                    return FALSE; <br> <br>                break; <br> <br>            case GNI_DELETED: <br>                if (!WriteDeletedInc(hfWrite, plInc)) <br>                    return FALSE; <br> <br>                break; <br> <br>            case GNI_ADDED: <br>                /* <br>                 * The first time we reach an added label, we know that <br>                 * there are no more changed or deleted ones to handle <br>                 * so we read/write up to the end of the old include file. <br>                 * This only has to be done once. <br>                 */ <br>                if (!fEOF) { <br>                    if (!RWToOffset(hfWrite, FPOS_MAX)) <br>                        return FALSE; <br> <br>                    fEOF = TRUE; <br> <br>                    /* <br>                     * In the unlikely case that the read include file <br>                     * does not end with a carriage return and/or <br>                     * linefeed character, add them before beginning <br>                     * to write added labels.  This ensures that the <br>                     * first label added always starts on a new line. <br>                     */ <br>                    if (!fAtNewLine) { <br>                        if (!WriteIncChar(hfWrite, CHAR_RETURN)) <br>                            return FALSE; <br> <br>                        if (!WriteIncChar(hfWrite, CHAR_NEWLINE)) <br>                            return FALSE; <br>                    } <br>                } <br> <br>                if (!WriteAddedInc(hfWrite, plInc)) <br>                    return FALSE; <br> <br>                break; <br>        } <br> <br>        nGNIRet = GetNextInc(&amp;plInc, FALSE); <br>    } <br> <br>    /* <br>     * Write the rest of the file, if there is any left. <br>     */ <br>    if (!fEOF) <br>        if (!RWToOffset(hfWrite, FPOS_MAX)) <br>            return FALSE; <br> <br>    /* <br>     * Flush any remaining characters in the write buffer. <br>     */ <br>    if (!WriteIncFlush(hfWrite)) <br>        return FALSE; <br> <br>    /* <br>     * If we just opened the old include file, close it. <br>     */ <br>    if (pszIncludeFile) <br>        CloseHandle(hfInclude); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* GetNextInc <br>* <br>* This routine will return the next label in the plInclude and plDelInclude <br>* linked lists, as well as the status of the returned label. <br>* <br>* The labels will be returned in order based upon their location in the <br>* lists, which is their order found in the include file if their fpos <br>* field is not FPOS_MAX.  This routine looks at the next label in both the <br>* plInclude and plDelInclude lists and returns the one with the lowest <br>* fpos.  Labels are returned from plInclude and plDelInclude in order of <br>* their fpos until all have been returned with a valid fpos.  After this, <br>* all new includes are returned from plInclude. <br>* <br>* Call it with fFirst equal to TRUE to initialize it. <br>* <br>* Arguments: <br>*   NPLABEL *pplReturn - label to return. <br>*   BOOL fFirst - TRUE if initializing. <br>* <br>* Returns: <br>*   GNI_DONE     - No more labels exist. <br>*   GNI_NOCHANGE - An existing label is being returned. <br>*   GNI_CHANGED  - An existing label with a changed id is being returned. <br>*   GNI_DELETED  - A deleted label is being returned. <br>*   GNI_ADDED    - An added label is being returned. <br>* <br>************************************************************************/ <br> <br>STATICFN INT GetNextInc( <br>    NPLABEL *pplReturn, <br>    BOOL fFirst) <br>{ <br>    static NPLABEL plCur; <br>    static NPLABEL plDelCur; <br> <br>    /* <br>     * Initialize if this is the first time. <br>     */ <br>    if (fFirst) { <br>        plCur = plInclude; <br>        plDelCur = plDelInclude; <br>    } <br> <br>    /* <br>     * Are we out of valid includes? <br>     */ <br>    if (!plCur) { <br>        /* <br>         * If there are deleted ones left, return the next one. <br>         * Otherwise we are done. <br>         */ <br>        if (plDelCur) { <br>            *pplReturn = plDelCur; <br>            plDelCur = plDelCur-&gt;npNext; <br>            return GNI_DELETED; <br>        } <br>        else { <br>            return GNI_DONE; <br>        } <br>    } <br>    /* <br>     * Have we reached the added includes (fpos == FPOS_MAX)? <br>     */ <br>    else if (plCur-&gt;fpos == FPOS_MAX) { <br>        /* <br>         * If there are deleted ones remaining, return them first. <br>         * Otherwise, return the next added one. <br>         */ <br>        if (plDelCur) { <br>            *pplReturn = plDelCur; <br>            plDelCur = plDelCur-&gt;npNext; <br>            return GNI_DELETED; <br>        } <br>        else { <br>            *pplReturn = plCur; <br>            plCur = plCur-&gt;npNext; <br>            return GNI_ADDED; <br>        } <br>    } <br>    else { <br>        /* <br>         * Return either the next label or the next deleted label, <br>         * based on whether there are any deleted labels and who <br>         * has the lowest file position (fpos). <br>         */ <br>        if (plDelCur &amp;&amp; plDelCur-&gt;fpos &lt; plCur-&gt;fpos) { <br>            *pplReturn = plDelCur; <br>            plDelCur = plDelCur-&gt;npNext; <br>            return GNI_DELETED; <br>        } <br>        else { <br>            *pplReturn = plCur; <br>            plCur = plCur-&gt;npNext; <br>            /* <br>             * Return either GNI_CHANGE or GNI_NOCHANGE based on <br>             * whether the original id value has been changed. <br>             */ <br>            return ((*pplReturn)-&gt;id == (*pplReturn)-&gt;idOrig) ? <br>                    GNI_NOCHANGE : GNI_CHANGED; <br>        } <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* RWToOffset <br>* <br>* This routine reads from the current include file and writes to the <br>* hfWrite file up to the lOffset position in the file.  If lOffset is <br>* set to FPOS_MAX, reads/writes are performed up to the end of the <br>* read file. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - handle to the file to write to. <br>*   DWORD lOffset - where to write up to. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>* Comments: <br>*   This routine relies on cchFile and cchFileMax to be properly updated <br>*   by the reading and writing routines. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL RWToOffset( <br>    HANDLE hfWrite, <br>    DWORD lOffset) <br>{ <br>    LPTSTR pchIn; <br>    DWORD cbWrite; <br> <br>    if (lOffset == FPOS_MAX) <br>        lOffset = cchFileMax; <br> <br>    for (cbWrite = lOffset - cchFile; cbWrite; cbWrite--) { <br>        /* <br>         * NULL can be returned if there is an EOF character found in <br>         * the file.  This is not an error, and we will stop reading <br>         * and writing at this point. <br>         */ <br>        if ((pchIn = ReadChar()) == NULL) <br>            return TRUE; <br> <br>        /* <br>         * If BAD_POINTER is returned, there was an error reading the <br>         * include file. <br>         */ <br>        if (pchIn == BAD_POINTER) <br>            return FALSE; <br> <br>        /* <br>         * Write out the character. <br>         */ <br>        if (!WriteIncChar(hfWrite, *pchIn)) <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteIncChar <br>* <br>* This routine writes a character (ch) to the hfWrite file, doing it in a <br>* buffered fashion.  Because it is buffered, before closing the file <br>* any remaining characters in the buffer must be "flushed" to disk. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - handle to the file to write to. <br>*   TCHAR ch - character to write. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>* Comments: <br>* The globals gachWriteBuffer and cbWritePos are updated by this routine. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteIncChar( <br>    HANDLE hfWrite, <br>    TCHAR ch) <br>{ <br>    INT cbWritten; <br> <br>    gachWriteBuffer[cbWritePos++] = ch; <br> <br>    /* <br>     * Is the buffer full? <br>     */ <br>    if (cbWritePos == CCHFILEBUFFER) { <br>        CHAR abWriteBuffer[CCHFILEBUFFER]; <br>        BOOL fDefCharUsed; <br> <br>        WideCharToMultiByte(CP_ACP, 0, gachWriteBuffer, CCHFILEBUFFER, <br>                abWriteBuffer, CCHFILEBUFFER, NULL, &amp;fDefCharUsed); <br> <br>        cbWritten = (INT)_lwrite((HFILE)hfWrite, abWriteBuffer, cbWritePos); <br>        if (cbWritten != cbWritePos) <br>            return FALSE; <br> <br>        cbWritePos = 0; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteIncFlush <br>* <br>* This routine flushes the write buffer.  This must be done before <br>* the file is closed or data can be lost. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - handle to the file to write to. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>* Comments: <br>*   The global cbWritePos is updated by this routine. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteIncFlush( <br>    HANDLE hfWrite) <br>{ <br>    INT cbWritten; <br> <br>    /* <br>     * Are any bytes remaining in the buffer? <br>     */ <br>    if (cbWritePos) { <br>        CHAR abWriteBuffer[CCHFILEBUFFER]; <br>        BOOL fDefCharUsed; </code></pre>
<p>
</p>
<pre><code><br>        WideCharToMultiByte(CP_ACP, 0, gachWriteBuffer, cbWritePos, <br>                abWriteBuffer, CCHFILEBUFFER, NULL, &amp;fDefCharUsed); <br> <br>        cbWritten = (INT)_lwrite((HFILE)hfWrite, abWriteBuffer, cbWritePos); <br>        if (cbWritten != cbWritePos) <br>            return FALSE; <br> <br>        cbWritePos = 0; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>  <br>/************************************************************************ <br>* WriteChangedInc <br>* <br>* This routine writes out a label that has had its id changed since the <br>* include file was last read. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - File to write to. <br>*   NPLABEL plInc  - Label to write. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>* History: <br>*   03/13/90 Byron Dazey - Created. <br>************************************************************************/ <br> <br>STATICFN BOOL WriteChangedInc( <br>    HANDLE hfWrite, <br>    NPLABEL plInc) <br>{ <br>    TCHAR ch; <br>    LPTSTR pchIn; <br> <br>    if (!RWToOffset(hfWrite, plInc-&gt;fpos + plInc-&gt;nValueOffset)) <br>        return FALSE; <br> <br>    /* <br>     * Consume the old id value (up to the next space, tab, <br>     * beginning of a comment, newline or return). <br>     */ <br>    while ((pchIn = ReadChar()) != NULL &amp;&amp; pchIn != BAD_POINTER &amp;&amp; <br>            (ch = *pchIn) != CHAR_SPACE &amp;&amp; ch != CHAR_TAB &amp;&amp; <br>            ch != CHAR_SLASH &amp;&amp; ch != CHAR_NEWLINE &amp;&amp; ch != CHAR_RETURN) <br>        ; <br> <br>    /* <br>     * It is an error if ReadChar returns BAD_POINTER.  Note that it <br>     * is NOT an error if it reaches EOF (and returns NULL). <br>     */ <br>    if (pchIn == BAD_POINTER) <br>        return FALSE; <br> <br>    /* <br>     * Write the new one. <br>     */ <br>    if (!WriteIDInc(hfWrite, plInc-&gt;id)) <br>        return FALSE; <br> <br>    /* <br>     * Remember to write the last character read after the old value. <br>     */ <br>    if (pchIn != NULL) <br>        if (!WriteIncChar(hfWrite, *pchIn)) <br>            return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteDeletedInc <br>* <br>* This routine deletes a label in the include file, closing up the <br>* space.  The entire line will be deleted, unless a comment is found <br>* after the id value.  If so, the comment and following characters will <br>* be left. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - File to write to. <br>*   NPLABEL plInc  - Label to delete. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>* History: <br>*   03/13/90 Byron Dazey - Created. <br>************************************************************************/ <br> <br>STATICFN BOOL WriteDeletedInc( <br>    HANDLE hfWrite, <br>    NPLABEL plInc) <br>{ <br>    register INT i; <br>    TCHAR ch; <br>    LPTSTR pchIn; <br> <br>    /* <br>     * Read and write up to the #define to be deleted. <br>     */ <br>    if (!RWToOffset(hfWrite, plInc-&gt;fpos)) <br>        return FALSE; <br> <br>    /* <br>     * Consume up to the id value. <br>     */ <br>    for (i = plInc-&gt;nValueOffset; i; i--) <br>        if ((pchIn = ReadChar()) == NULL || pchIn == BAD_POINTER) <br>            return FALSE; <br> <br>    /* <br>     * Consume the id value and following characters up to the end of <br>     * the line or the beginning of a comment. <br>     */ <br>    while ((pchIn = ReadChar()) != NULL &amp;&amp; pchIn != BAD_POINTER &amp;&amp; <br>            (ch = *pchIn) != CHAR_NEWLINE &amp;&amp; ch != CHAR_RETURN &amp;&amp; <br>            ch != CHAR_SLASH) <br>        ; <br> <br>    if (pchIn == BAD_POINTER) <br>        return FALSE; <br> <br>    /* <br>     * We are done if we have reached EOF. <br>     */ <br>    if (pchIn == NULL) <br>        return TRUE; <br> <br>    /* <br>     * If the beginning of a comment was found, be sure to write the <br>     * character back out and leave the rest of the comment. <br>     */ <br>    if (ch == CHAR_SLASH) { <br>        if (!WriteIncChar(hfWrite, ch)) <br>            return FALSE; <br>    } <br>    else { <br>        /* <br>         * At this point either a newline or a return was found <br>         * and we are going to consume it.  We also want to check <br>         * for a return following the newline, or a newline <br>         * following the return and consume it also. <br>         */ <br>        if ((ch == CHAR_NEWLINE &amp;&amp; *(pchIn + 1) == CHAR_RETURN) || <br>                (ch == CHAR_RETURN &amp;&amp; *(pchIn + 1) == CHAR_NEWLINE)) <br>            if (ReadChar() == BAD_POINTER) <br>                return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteAddedInc <br>* <br>* Adds a label to the new include file. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - File to write to. <br>*   NPLABEL plInc  - Label to add. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>* History: <br>*   03/13/90 Byron Dazey - Created. <br>************************************************************************/ <br> <br>STATICFN BOOL WriteAddedInc( <br>    HANDLE hfWrite, <br>    NPLABEL plInc) <br>{ <br>    register LPTSTR psz; <br> <br>    /* <br>     * Write the "#define " string. <br>     */ <br>    psz = ids(IDS_POUNDDEFINE); <br>    while (*psz) <br>        if (!WriteIncChar(hfWrite, *psz++)) <br>            return FALSE; <br> <br>    /* <br>     * Write the symbol, followed by a space. <br>     */ <br>    if (!WriteSymbol(hfWrite, plInc-&gt;pszLabel)) <br>        return FALSE; <br>    if (!WriteIncChar(hfWrite, CHAR_SPACE)) <br>        return FALSE; <br> <br>    /* <br>     * Write the id, followed by a carriage return and newline. <br>     */ <br>    if (!WriteIDInc(hfWrite, plInc-&gt;id)) <br>        return FALSE; <br>    if (!WriteIncChar(hfWrite, CHAR_RETURN)) <br>        return FALSE; <br>    if (!WriteIncChar(hfWrite, CHAR_NEWLINE)) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteSymbol <br>* <br>* Writes out a "#define DID_xxx  " string to hfWrite.  If the symbol <br>* is smaller than CCHSYMFIELDWIDTH, it will be padded with spaces out <br>* to this width. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - handle to the file to write to. <br>*   LPTSTR pszSymbol - symbol to write. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteSymbol( <br>    HANDLE hfWrite, <br>    LPTSTR pszSymbol) <br>{ <br>    register INT cch; <br> <br>    /* <br>     * Write the symbol. <br>     */ <br>    cch = 0; <br>    while (*pszSymbol) { <br>        if (!WriteIncChar(hfWrite, *pszSymbol++)) <br>            return FALSE; <br> <br>        cch++; <br>    } <br> <br>    /* <br>     * Pad the field with blanks out to CCHSYMFIELDWIDTH, if necessary. <br>     */ <br>    if (cch &lt; CCHSYMFIELDWIDTH) { <br>        cch = CCHSYMFIELDWIDTH - cch; <br>        while (cch--) <br>            if (!WriteIncChar(hfWrite, CHAR_SPACE)) <br>                return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* WriteIDInc <br>* <br>* Writes out an id value to the hfWrite file.  The format will be in <br>* either hex or decimal, depending on the current mode. <br>* <br>* Arguments: <br>*   HANDLE hfWrite - File to write to. <br>*   INT id         - ID to write. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>************************************************************************/ <br> <br>STATICFN BOOL WriteIDInc( <br>    HANDLE hfWrite, <br>    INT id) <br>{ <br>    register LPTSTR psz; <br>    TCHAR szValue[CCHIDMAX + 1]; <br> <br>    Myitoa(id, szValue); <br> <br>    psz = szValue; <br>    while (*psz) <br>        if (!WriteIncChar(hfWrite, *psz++)) <br>            return FALSE; <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
