<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPARROW.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5512"></a>CPARROW.C</h2>
<pre><code>/** FILE: arrow.c ********** Module Header ******************************** <br> * <br> * Control panel utility library routines for managing "cpArrow" window <br> * class/spinner controls used in applet dialogs. <br> * <br> * History: <br> *  15:30 on Thur  25 Apr 1991  -by-  Steve Cathcart   [stevecat] <br> *        Took base code from Win 3.1 source <br> *  10:30 on Tues  04 Feb 1992  -by-  Steve Cathcart   [stevecat] <br> *        Updated code to latest Win 3.1 sources <br> *  12:00 on Fri   07 Aug 1992  -by-  Steve Cathcart   [stevecat] <br> *        Implemented new drawing scheme for spinner/arrow control <br> * <br> *  Copyright 1990 - 1998 Microsoft Corporation <br> * <br> *************************************************************************/ <br>//========================================================================== <br>//                        Include files <br>//========================================================================== <br>// C Runtime <br>#include &lt;stddef.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include &lt;windows.h&gt; <br> <br>// Application specific <br>#include "cparrow.h" <br> <br>//========================================================================== <br>//                        Local Definitions <br>//========================================================================== <br> <br>//  Offsets to use with GetWindowLong <br>#define GWL_SPINNERSTATE    0 <br> <br>//  Control state flags. <br>#define SPINNERSTATE_GRAYED      0x0001 <br>#define SPINNERSTATE_HIDDEN      0x0002 <br>#define SPINNERSTATE_MOUSEOUT    0x0004 <br>#define SPINNERSTATE_UPCLICK     0x0008 <br>#define SPINNERSTATE_DOWNCLICK   0x0010 <br> <br>//  Combination of click states. <br>#define SPINNERSTATE_CLICKED   (SPINNERSTATE_UPCLICK | SPINNERSTATE_DOWNCLICK) <br> <br>//  Combination of state flags. <br>#define SPINNERSTATE_ALL         0x001F <br> <br>//  Sinner Control color indices <br>#define SPINNERCOLOR_FACE        0 <br>#define SPINNERCOLOR_ARROW       1 <br>#define SPINNERCOLOR_SHADOW      2 <br>#define SPINNERCOLOR_HIGHLIGHT   3 <br>#define SPINNERCOLOR_FRAME       4 <br> <br>#define CCOLORS                  5 <br> <br>//========================================================================== <br>//                        External Declarations <br>//========================================================================== <br> <br> <br>//========================================================================== <br>//                        Local Data Declarations <br>//========================================================================== <br> <br>/* <br> * Macros to change the control state given the state flag(s) <br> */ <br>#define StateSet(dwState, wFlags)    (dwState |=  (wFlags)) <br>#define StateClear(dwState, wFlags)  (dwState &amp;= ~(wFlags)) <br>#define StateTest(dwState, wFlags)   (dwState &amp;   (wFlags)) <br> <br> <br>//Array of default colors, matching the order of SPINNERCOLOR_* values. <br>DWORD rgColorDef[CCOLORS]={ <br>                         COLOR_BTNFACE,             //  SPINNERCOLOR_FACE <br>                         COLOR_BTNTEXT,             //  SPINNERCOLOR_ARROW <br>                         COLOR_BTNSHADOW,           //  SPINNERCOLOR_SHADOW <br>                         COLOR_BTNHIGHLIGHT,        //  SPINNERCOLOR_HIGHLIGHT <br>                         COLOR_WINDOWFRAME          //  SPINNERCOLOR_FRAME <br>                         }; <br> <br>BOOL   bArrowTimed = FALSE; <br>BOOL   bRight; <br>HANDLE hParent; <br> <br> <br>//========================================================================== <br>//                        Local Function Prototypes <br>//========================================================================== <br>void Draw3DButtonRect (HDC hDC, HPEN hPenHigh, HPEN hPenShadow, int x1, <br>                       int y1, int x2, int y2, BOOL fClicked); <br>LONG SpinnerPaint (HWND hWnd, DWORD dwSpinnerState); <br> <br> <br>//========================================================================== <br>//                            Functions <br>//========================================================================== <br> <br>BOOL OddArrowWindow(HWND hArrowWnd) <br>{ <br> <br>#ifdef  OLD_CODE <br>    HWND hParent; <br>    RECT rResize; <br>    BOOL bResize; <br> <br> <br>    GetWindowRect(hArrowWnd, (LPRECT) &amp;rResize); <br>    if (!(bResize = (rResize.right - rResize.left) % 2)) <br>    { <br>        rResize.right++; <br>        ScreenToClient(hParent = GetParent(hArrowWnd), (LPPOINT) &amp; rResize.left); <br>        ScreenToClient(hParent, (LPPOINT) &amp; rResize.right); <br>        MoveWindow(hArrowWnd, rResize.left, rResize.top, <br>                             (rResize.right - rResize.left), <br>                             (rResize.bottom - rResize.top), FALSE); <br>    } <br>    return(bResize); <br>#endif  //  OLD_CODE <br> <br>    return(TRUE); <br>} <br> <br> <br>VOID ArrowTimerProc(HWND hWnd, UINT wMsg, UINT nID, DWORD dwTime) <br>{ <br>    WORD  wScroll; <br>    DWORD dwSpinnerState; <br> <br>    dwSpinnerState = (DWORD) GetWindowLong (hWnd, GWL_SPINNERSTATE); <br> <br>    if (StateTest(dwSpinnerState, SPINNERSTATE_CLICKED)) <br>    { <br>        wScroll = (StateTest(dwSpinnerState, SPINNERSTATE_DOWNCLICK)) ? <br>                                                    SB_LINEDOWN : SB_LINEUP; <br>        if (bRight == WM_RBUTTONDOWN) <br>            wScroll += SB_PAGEUP - SB_LINEUP; <br> <br>            SendMessage(hParent, WM_VSCROLL, <br>                        MAKELONG(wScroll, GetWindowLong(hWnd, GWL_ID)), <br>                        (LONG) hWnd); <br>    } <br> <br>    //  Don't need to call KillTimer(), because SetTimer will <br>    //  reset the right one <br> <br>    SetTimer(hWnd, nID, 50, (TIMERPROC) ArrowTimerProc); <br> <br>    return ; <br> <br>    wMsg = wMsg; <br>    dwTime = dwTime; <br>} <br> <br> <br>/* <br> * ClickedRectCalc <br> * <br> * Description: <br> *  Calculates the rectangle of the clicked region based on the <br> *  state flags SPINNERSTATE_UPCLICK and SPINNERSTATE_DOWNCLICK. <br> * <br> * Parameter: <br> *  hWnd            HWND handle to the control window. <br> *  lpRect          LPRECT rectangle structure to fill. <br> * <br> * Return Value: <br> *  void <br> * <br> */ <br> <br>void ClickedRectCalc(HWND hWnd, DWORD dwState, LPRECT lpRect) <br>{ <br>    int  cx, cy; <br> <br>    GetClientRect (hWnd, lpRect); <br> <br>    cx = lpRect-&gt;right  &gt;&gt; 1; <br>    cy = lpRect-&gt;bottom &gt;&gt; 1; <br> <br>    if (StateTest(dwState, SPINNERSTATE_DOWNCLICK)) <br>        lpRect-&gt;top = cy; <br>    else <br>        lpRect-&gt;bottom = 1+cy; <br> <br>    return; <br>} <br> <br>/* <br> * ArrowControlProc <br> * <br> * Description: <br> * <br> *  Window Procedure for the Spinner/Arrow custom control.  Handles all <br> *  messages like WM_PAINT just as a normal application window would. <br> *  State information about the control is maintained ALL drawing is <br> *  handled during WM_PAINT message processing. <br> * <br> */ <br>LRESULT APIENTRY ArrowControlProc(HWND hArrow, UINT message, WPARAM wParam, LONG lParam) <br>{ <br>    WORD    wScroll; <br>    POINT   pt; <br>    RECT    rect; <br>    int     x, y; <br>    int     cy; <br>    DWORD   dwSpinnerState, dwState; <br> <br> <br>    dwSpinnerState = (DWORD) GetWindowLong (hArrow, GWL_SPINNERSTATE); <br> <br>    switch (message) <br>    { <br>    case WM_CREATE: <br>        dwSpinnerState = 0; <br>        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState); <br>        break; <br> <br> <br>    case WM_ENABLE: <br>        //  Handles disabling/enabling case.  Example of a <br>        //  change-state-and-repaint strategy since we let the <br>        //  painting code take care of the visuals. <br> <br>        if (wParam) <br>            StateClear(dwSpinnerState, SPINNERSTATE_GRAYED); <br>        else <br>            StateSet(dwSpinnerState, SPINNERSTATE_GRAYED); <br> <br>        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState); <br> <br>        //  Force a repaint since the control will look different. <br> <br>        InvalidateRect (hArrow, NULL, TRUE); <br>        UpdateWindow (hArrow); <br>        break; <br> <br> <br>    case WM_SHOWWINDOW: <br>        //  Set or clear the hidden flag. Windows will <br>        //  automatically force a repaint if we become visible. <br> <br>        if (wParam) <br>            StateClear(dwSpinnerState, SPINNERSTATE_HIDDEN); <br>        else <br>            StateSet(dwSpinnerState, SPINNERSTATE_HIDDEN); <br> <br>        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState); <br>        break; <br> <br> <br>    case WM_CANCELMODE: <br>        //  IMPORTANT MESSAGE!  WM_CANCELMODE means that a <br>        //  dialog or some other modal process has started. <br>        //  we must make sure that we cancel any clicked state <br>        //  we are in, kill the timers, and release the capture. <br> <br>        StateClear(dwSpinnerState, SPINNERSTATE_CLICKED); <br>        if (bArrowTimed) <br>        { <br>            SendMessage (hParent, WM_VSCROLL, MAKELONG(SB_ENDSCROLL, <br>                           GetWindowLong (hArrow, GWL_ID)), (LONG) hArrow); <br>            KillTimer (hArrow, GetWindowLong (hArrow, GWL_ID)); <br>            bArrowTimed = FALSE; <br>        } <br>        ReleaseCapture(); <br>        break; <br> <br>    case WM_RBUTTONDOWN: <br>    case WM_LBUTTONDOWN: <br>        //  When we get a mouse down message, we know that the mouse <br>        //  is over the control.  We then do the following steps <br>        //  to set up the new state: <br>        //   1.  Hit-test the coordinates of the click to <br>        //       determine in which half the click occurred. <br>        //   2.  Set the appropriate SPINNERSTATE_*CLICK state <br>        //       and repaint that clicked half.  This is another <br>        //       example of a change-state-and-repaint strategy. <br>        //   3.  Send an initial scroll message. <br>        //   4.  Set the mouse capture. <br>        //   5.  Set the initial delay timer before repeating <br>        //       the scroll message. <br> <br>        if (bRight) <br>            break; <br> <br>        bRight = message; <br> <br>        hParent = GetParent (hArrow); <br> <br>        //  Get the mouse coordinates. <br>        x = (int) LOWORD(lParam); <br>        y = (int) HIWORD(lParam); <br> <br>        //  Only need to hit-test the upper half <br>        //  Then change-state-and-repaint <br> <br>        GetClientRect (hArrow, &amp;rect); <br>        cy = rect.bottom &gt;&gt; 1; <br> <br>        if (y &gt; cy) <br>        { <br>            StateSet(dwSpinnerState, SPINNERSTATE_DOWNCLICK); <br>            rect.top = cy; <br>            wScroll = SB_LINEDOWN; <br>        } <br>        else <br>        { <br>            StateSet(dwSpinnerState, SPINNERSTATE_UPCLICK); <br>            rect.bottom = cy + 1; <br>            wScroll = SB_LINEUP; <br>        } <br> <br>        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState); <br> <br>        InvalidateRect (hArrow, &amp;rect, TRUE); <br>        UpdateWindow (hArrow); <br> <br>        SetCapture (hArrow); <br> <br>        //  Process SHIFT key state along with button message <br> <br>        if (wParam &amp; MK_SHIFT) <br>        { <br>            if (message != WM_RBUTTONDOWN) <br>                wScroll += (WORD) (SB_TOP - SB_LINEUP); <br>            else <br>                wScroll += (WORD) (SB_THUMBPOSITION - SB_LINEUP); <br>        } <br>        else <br>        { <br>            if (message == WM_RBUTTONDOWN) <br>                wScroll += SB_PAGEUP - SB_LINEUP; <br> <br>            bArrowTimed = SetTimer (hArrow, GetWindowLong (hArrow, GWL_ID), <br>                                             200, (TIMERPROC) ArrowTimerProc); <br>        } <br>        SendMessage (hParent, WM_VSCROLL, MAKELONG(wScroll, <br>                              GetWindowLong (hArrow, GWL_ID)), (LONG) hArrow); <br>        break; <br> <br>    case WM_MOUSEMOVE: <br>        //  On WM_MOUSEMOVE messages we want to know if the mouse <br>        //  has moved out of the control when the control is in <br>        //  a clicked state.  If the control has not been clicked, <br>        //  then we have nothing to do.  Otherwise we want to set <br>        //  the SPINNERSTATE_MOUSEOUT flag and repaint so the button <br>        //  visually comes up. <br> <br>        if (!StateTest(dwSpinnerState, SPINNERSTATE_CLICKED)) <br>            break; <br> <br>        //  Save copy of original state <br>        dwState = dwSpinnerState; <br> <br>        //  Get the mouse coordinates. <br>        pt.x = (int) LOWORD(lParam); <br>        pt.y = (int) HIWORD(lParam); <br> <br>        //  Get the area we originally clicked and the new POINT <br>        ClickedRectCalc (hArrow, dwSpinnerState, &amp;rect); <br> <br>        //  Hit-Test the rectange and change the state if necessary. <br>        if (PtInRect(&amp;rect, pt)) <br>            StateClear(dwSpinnerState, SPINNERSTATE_MOUSEOUT); <br>        else <br>            StateSet(dwSpinnerState, SPINNERSTATE_MOUSEOUT); <br> <br>        SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState); <br> <br>        //  If the state changed, repaint the appropriate part of <br>        //  the control. <br>        if (dwState != dwSpinnerState) <br>        { <br>            InvalidateRect (hArrow, &amp;rect, TRUE); <br>            UpdateWindow (hArrow); <br>        } <br> <br>        break; <br> <br> <br>    case WM_LBUTTONUP: <br>    case WM_RBUTTONUP: <br>        //  A mouse button up event is much like WM_CANCELMODE since <br>        //  we have to clean out whatever state the control is in: <br>        //   1.  Kill any repeat timers we might have created. <br>        //   2.  Release the mouse capture. <br>        //   3.  Clear the clicked states and repaint, another example <br>        //       of a change-state-and-repaint strategy. <br> <br>        if ((UINT) (bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == message) <br>        { <br>            bRight = 0; <br>            ReleaseCapture(); <br> <br>            if (bArrowTimed) <br>            { <br>                SendMessage (hParent, WM_VSCROLL, MAKELONG(SB_ENDSCROLL, <br>                               GetWindowLong (hArrow, GWL_ID)), (LONG) hArrow); <br>                KillTimer (hArrow, GetWindowLong (hArrow, GWL_ID)); <br>                bArrowTimed = FALSE; <br>            } <br> <br>            //  Repaint if necessary, only if we are clicked AND the mouse <br>            //  is still in the boundaries of the control. <br> <br>            if (StateTest(dwSpinnerState, SPINNERSTATE_CLICKED) &amp;&amp; <br>                StateTest(dwSpinnerState, ~SPINNERSTATE_MOUSEOUT)) <br>            { <br>                //  Calculate the rectangle before clearing states. <br>                ClickedRectCalc (hArrow, dwSpinnerState, &amp;rect); <br> <br>                //  Clear the states so we repaint properly. <br>                StateClear(dwSpinnerState, SPINNERSTATE_CLICKED | SPINNERSTATE_MOUSEOUT); <br> <br>                SetWindowLong (hArrow, GWL_SPINNERSTATE, (LONG) dwSpinnerState); <br>                InvalidateRect (hArrow, &amp;rect, TRUE); <br>                UpdateWindow (hArrow); <br>            } <br>        } <br>        break; <br> <br> <br>    case WM_PAINT: <br>        return SpinnerPaint (hArrow, dwSpinnerState); <br> <br> <br>    default: <br>        return (DefWindowProc (hArrow, message, wParam, lParam)); <br>        break; <br>    } <br>    return(0L); <br>} <br> <br> <br>/* <br> * SpinnerPaint <br> * <br> * Description: <br> * <br> *  Handles all WM_PAINT messages for the control and paints <br> *  the control for the current state, whether it be clicked <br> *  or disabled. <br> * <br> * Parameters: <br> *  hWnd            HWND Handle to the control. <br> *  dwSpinnerState  DWORD Spinner control status flags <br> * <br> * Return Value: <br> *  LONG            0L. <br> */ <br> <br>LONG SpinnerPaint (HWND hWnd, DWORD dwSpinnerState) <br>{ <br>    PAINTSTRUCT ps; <br>    LPRECT      lpRect; <br>    RECT        rect; <br>    HDC         hDC; <br>    COLORREF    rgCr[CCOLORS]; <br>    HPEN        rgHPen[CCOLORS]; <br>    int         iColor; <br> <br>    HBRUSH      hBrushArrow; <br>    HBRUSH      hBrushFace; <br>    HBRUSH      hBrushBlack; <br> <br>    POINT       rgpt1[3]; <br>    POINT       rgpt2[3]; <br> <br>    int         xAdd1=0, yAdd1=0; <br>    int         xAdd2=0, yAdd2=0; <br> <br>    int         cx,  cy;        //  Whole dimensions <br>    int         cx2, cy2;       //  Half dimensions <br>    int         cx4, cy4;       //  Quarter dimensions <br> <br>    lpRect = &amp;rect; <br> <br>    hDC = BeginPaint (hWnd, &amp;ps); <br>    GetClientRect (hWnd, lpRect); <br> <br>    //  Get colors that we'll need.  We do not want to cache these <br>    //  items since we may our top-level parent window may have <br>    //  received a WM_WININICHANGE message at which time the control <br>    //  is repainted.  Since this control never sees that message, <br>    //  we cannot assume that colors will remain the same throughout <br>    //  the life of the control. <br> <br>    for (iColor = 0; iColor &lt; CCOLORS; iColor++) <br>    { <br>        rgCr[iColor] = GetSysColor (rgColorDef[iColor]); <br> <br>        rgHPen[iColor] = CreatePen (PS_SOLID, 1, rgCr[iColor]); <br>    } <br> <br>    hBrushFace  = CreateSolidBrush (rgCr[SPINNERCOLOR_FACE]); <br>    hBrushArrow = CreateSolidBrush (rgCr[SPINNERCOLOR_ARROW]); <br>    hBrushBlack = GetStockObject (BLACK_BRUSH); <br> <br>    //  These values are extremely cheap to calculate for the amount <br>    //  we are going to use them. <br> <br>    cx  = lpRect-&gt;right  - lpRect-&gt;left; <br>    cy  = lpRect-&gt;bottom - lpRect-&gt;top; <br>    cx2 = cx  &gt;&gt; 1; <br>    cy2 = cy  &gt;&gt; 1; <br>    cx4 = cx2 &gt;&gt; 1; <br>    cy4 = cy2 &gt;&gt; 1; <br> <br>    //  If one half is depressed, set the x/yAdd varaibles that we use <br>    //  to shift the small arrow image down and right. <br> <br>    if (!StateTest(dwSpinnerState, SPINNERSTATE_MOUSEOUT)) <br>    { <br>        if (StateTest(dwSpinnerState, SPINNERSTATE_UPCLICK)) <br>        { <br>            xAdd1 = 1; <br>            yAdd1 = 1; <br>        } <br>        else if (StateTest(dwSpinnerState, SPINNERSTATE_DOWNCLICK)) <br>        { <br>            xAdd2 = 1; <br>            yAdd2 = 1; <br>        } <br>    } <br> <br>    //  Draw the face color and the outer frame <br>    SelectObject (hDC, hBrushFace); <br>    SelectObject (hDC, rgHPen[SPINNERCOLOR_FRAME]); <br> <br>    Rectangle (hDC, lpRect-&gt;left, lpRect-&gt;top, lpRect-&gt;right, lpRect-&gt;bottom); <br> <br>    //  Draw the horizontal center line. <br>    MoveToEx (hDC, 0, cy2, NULL); <br>    LineTo (hDC, cx, cy2); <br> <br>    //  We do one of three modifications for drawing the borders: <br>    //   1) Both halves un-clicked. <br>    //   2) Top clicked,   bottom unclicked. <br>    //   3) Top unclicked, bottom clicked. <br>    // <br>    //  Case 1 is xAdd1==xAdd2==0 <br>    //  Case 2 is xAdd1==1, xAdd2=0 <br>    //  Case 3 is xAdd1==0, xAdd2==1 <br> <br>    //  Draw top and bottom buttons borders. <br>    Draw3DButtonRect (hDC, rgHPen[SPINNERCOLOR_HIGHLIGHT], <br>                      rgHPen[SPINNERCOLOR_SHADOW], <br>                      0,  0,  cx-1, cy2,  (BOOL) xAdd1); <br> <br>    Draw3DButtonRect (hDC, rgHPen[SPINNERCOLOR_HIGHLIGHT], <br>                      rgHPen[SPINNERCOLOR_SHADOW], <br>                      0, cy2, cx-1, cy-1, (BOOL) xAdd2); <br> <br> <br>    //  Select default line color. <br>    SelectObject (hDC, rgHPen[SPINNERCOLOR_ARROW]); <br> <br>    //  Draw the arrows depending on the enable state. <br>    if (StateTest (dwSpinnerState, SPINNERSTATE_GRAYED)) <br>    { <br>        //  Draw arrow color lines in the upper left of the <br>        //  top arrow and on the top of the bottom arrow. <br>        //  Pen was already selected as a default. <br> <br>        MoveToEx (hDC, cx2,   cy4-2, NULL);      //Top arrow <br>        LineTo   (hDC, cx2-3, cy4+1); <br>        MoveToEx (hDC, cx2-3, cy2+cy4-2, NULL);  //Bottom arrow <br>        LineTo   (hDC, cx2+3, cy2+cy4-2); <br> <br>        //  Draw highlight color lines in the bottom of the <br>        //  top arrow and on the lower right of the bottom arrow. <br> <br>        SelectObject (hDC, rgHPen[SPINNERCOLOR_HIGHLIGHT]); <br>        MoveToEx (hDC, cx2-3, cy4+1, NULL);      //Top arrow <br>        LineTo   (hDC, cx2+3, cy4+1); <br>        MoveToEx (hDC, cx2+3, cy2+cy4-2, NULL);  //Bottom arrow <br>        LineTo   (hDC, cx2,   cy2+cy4+1); <br>        SetPixel (hDC, cx2,   cy2+cy4+1, rgCr[SPINNERCOLOR_HIGHLIGHT]); <br>    } <br>    else <br>    { <br>        //  Top arrow polygon <br>        rgpt1[0].x = xAdd1 + cx2; <br>        rgpt1[0].y = yAdd1 + cy4 - 2; <br>        rgpt1[1].x = xAdd1 + cx2 - 3; <br>        rgpt1[1].y = yAdd1 + cy4 + 1; <br>        rgpt1[2].x = xAdd1 + cx2 + 3; <br>        rgpt1[2].y = yAdd1 + cy4 + 1; <br> <br>        //  Bottom arrow polygon <br>        rgpt2[0].x = xAdd2 + cx2; <br>        rgpt2[0].y = yAdd2 + cy2 + cy4 + 1; <br>        rgpt2[1].x = xAdd2 + cx2 - 3; <br>        rgpt2[1].y = yAdd2 + cy2 + cy4 - 2; <br>        rgpt2[2].x = xAdd2 + cx2 + 3; <br>        rgpt2[2].y = yAdd2 + cy2 + cy4 - 2; <br> <br>        //  Draw the arrows <br>        SelectObject (hDC, hBrushArrow); <br>        Polygon (hDC, (LPPOINT)rgpt1, 3); <br>        Polygon (hDC, (LPPOINT)rgpt2, 3); <br>    } <br> <br>    //  Clean up <br>    EndPaint(hWnd, &amp;ps); <br> <br>    DeleteObject (hBrushFace); <br>    DeleteObject (hBrushArrow); <br> <br>    for (iColor = 0; iColor &lt; CCOLORS; iColor++) <br>    { <br>        if (rgHPen[iColor]) <br>            DeleteObject (rgHPen[iColor]); <br>    } <br> <br>    return 0L; <br>} <br> <br> <br>/* <br> * Draw3DButtonRect <br> * <br> * Description: <br> *  Draws the 3D button look within a given rectangle.  This rectangle <br> *  is assumed to be bounded by a one pixel black border, so everything <br> *  is bumped in by one. <br> * <br> * Parameters: <br> *  hDC         DC to draw to. <br> *  hPenHigh    HPEN highlight color pen. <br> *  hPenShadow  HPEN shadow color pen. <br> *  x1          int Upper left corner x. <br> *  y1          int Upper left corner y. <br> *  x2          int Lower right corner x. <br> *  y2          int Lower right corner y. <br> *  fClicked    BOOL specifies if the button is down or not (TRUE==DOWN) <br> * <br> * Return Value: <br> *  void <br> * <br> */ <br> <br>void Draw3DButtonRect (HDC hDC, HPEN hPenHigh, HPEN hPenShadow, int x1, <br>                       int y1, int x2, int y2, BOOL fClicked) <br>{ <br>    HPEN  hPenOrg; <br> <br>    //  Shrink the rectangle to account for borders. <br>    x1+=1; <br>    x2-=1; <br>    y1+=1; <br>    y2-=1; <br> <br>    hPenOrg = SelectObject (hDC, hPenShadow); <br> <br>    if (fClicked) <br>    { <br>        //  Shadow on left and top edge when clicked. <br>        MoveToEx (hDC, x1, y2, NULL); <br>        LineTo (hDC, x1, y1); <br>        LineTo (hDC, x2+1, y1); <br>    } <br>    else <br>    { <br>        //  Lowest shadow line. <br>        MoveToEx (hDC, x1, y2, NULL); <br>        LineTo (hDC, x2, y2); <br>        LineTo (hDC, x2, y1-1); <br> <br>        //  Upper shadow line. <br>        MoveToEx (hDC, x1+1, y2-1, NULL); <br>        LineTo (hDC, x2-1, y2-1); <br>        LineTo (hDC, x2-1, y1); <br> <br>        SelectObject (hDC, hPenHigh); <br> <br>        //  Upper highlight line. <br>        MoveToEx (hDC, x1, y2-1, NULL); <br>        LineTo (hDC, x1, y1); <br>        LineTo (hDC, x2, y1); <br>    } <br> <br>    if (hPenOrg) <br>        SelectObject (hDC, hPenOrg); <br> <br>    return; <br>} <br> <br> <br>BOOL RegisterArrowClass (HANDLE hModule) <br>{ <br>    WNDCLASS wcArrow; <br> <br>    wcArrow.lpszClassName = TEXT("cpArrow"); <br>    wcArrow.hInstance     = hModule; <br>    wcArrow.lpfnWndProc   = ArrowControlProc; <br>    wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wcArrow.hIcon         = NULL; <br>    wcArrow.lpszMenuName  = NULL; <br>    wcArrow.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1); <br>    wcArrow.style         = CS_HREDRAW | CS_VREDRAW; <br>    wcArrow.cbClsExtra    = 0; <br>    wcArrow.cbWndExtra    = sizeof(DWORD); <br> <br>    return(RegisterClass((LPWNDCLASS) &amp;wcArrow)); <br>} <br> <br> <br>/* <br>short ArrowVScrollProc(wScroll, nCurrent, lpAVS) <br> <br>wScroll is an SB_* message <br>nCurrent is the base value to change <br>lpAVS is a far pointer to the structure containing change amounts <br>      and limits to be used, along with a flags location for errors <br> <br>returns a short value of the final amount <br>        the flags element in the lpAVS struct is <br>                0 if no problems found <br>         OVERFLOW set if the change exceeded upper limit (limit is returned) <br>        UNDERFLOW set if the change exceeded lower limit (limit is returned) <br>   UNKNOWNCOMMAND set if wScroll is not a known SB_* message <br> <br>NOTE: Only one of OVERFLOW or UNDERFLOW may be set.  If you send in values <br>      that would allow both to be set, that's your problem.  Either can <br>      be set in combination with UNKNOWNCOMMAND (when the command is not <br>      known and the input value is out of bounds). <br>*/ <br> <br>short ArrowVScrollProc(short wScroll, short nCurrent, LPARROWVSCROLL lpAVS) <br>{ <br>    short    nDelta; <br> <br>/* Find the message and put the relative change in nDelta.  If the <br>   message is an absolute change, put 0 in nDelta and set nCurrent <br>   to the value specified.  If the command is unknown, set error <br>   flag, set nDelta to 0, and proceed through checks. <br>*/ <br> <br>    switch (wScroll) <br>    { <br>    case SB_LINEUP: <br>        nDelta = lpAVS-&gt;lineup; <br>        break; <br>    case SB_LINEDOWN: <br>        nDelta = lpAVS-&gt;linedown; <br>        break; <br>    case SB_PAGEUP: <br>        nDelta = lpAVS-&gt;pageup; <br>        break; <br>    case SB_PAGEDOWN: <br>        nDelta = lpAVS-&gt;pagedown; <br>        break; <br>    case SB_TOP: <br>        nCurrent = lpAVS-&gt;top; <br>        nDelta = 0; <br>        break; <br>    case SB_BOTTOM: <br>        nCurrent = lpAVS-&gt;bottom; <br>        nDelta = 0; <br>        break; <br>    case SB_THUMBTRACK: <br>        nCurrent = lpAVS-&gt;thumbtrack; <br>        nDelta = 0; <br>        break; <br>    case SB_THUMBPOSITION: <br>        nCurrent = lpAVS-&gt;thumbpos; <br>        nDelta = 0; <br>        break; <br>    case SB_ENDSCROLL: <br>        nDelta = 0; <br>        break; <br>    default: <br>        lpAVS-&gt;flags = UNKNOWNCOMMAND; <br>        nDelta = 0; <br>        break; <br>    } <br>    if (nCurrent + nDelta &gt; lpAVS-&gt;top) <br>    { <br>        nCurrent = lpAVS-&gt;top; <br>        nDelta = 0; <br>        lpAVS-&gt;flags = OVERFLOW; <br>    } <br>    else if (nCurrent + nDelta &lt; lpAVS-&gt;bottom) <br>    { <br>        nCurrent = lpAVS-&gt;bottom; <br>        nDelta = 0; <br>        lpAVS-&gt;flags = UNDERFLOW; <br>    } <br>    else <br>        lpAVS-&gt;flags = 0; <br>    return(nCurrent + nDelta); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
