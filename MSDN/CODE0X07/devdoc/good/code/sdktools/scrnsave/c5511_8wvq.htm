<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SKELETON.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5516"></a>SKELETON.C</h2>
<pre><code>#define WIN31 <br>#include &lt;windows.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include "cparrow.h" <br>#include "comstrin.h" <br>#include "uniconv.h" <br> <br> <br>/* Global variables... */ <br>HANDLE  hMainInst; <br>HWND    hMainWindow; <br> <br>TCHAR   szName[TITLEBARNAMELEN]; <br>TCHAR   szAppName[APPNAMEBUFFERLEN];       // Section name in CONTROL.INI <br>TCHAR   szIniFile[MAXFILELEN]; <br>TCHAR   szScreenSaver[22]; <br>TCHAR   szHelpFile[MAXFILELEN]; <br>TCHAR   szNoHelpMemory[BUFFLEN]; <br>UINT    MyHelpMessage; <br> <br> <br>/* Local Function definitions... */ <br>BOOL AppInit           (HANDLE hInst, HANDLE hPrev, WORD sw, LPTSTR szCmdLine); <br>int  DoConfigureDialog (HANDLE hInst, BOOL fParent); <br> <br>HCURSOR hcurOld; <br> <br>HHOOK hhkNextMsgFilterHookFunc = NULL; <br> <br>LRESULT CALLBACK HelpMessageFilterHookFunction (int nCode, WPARAM wParam, LPMSG lpMsg); <br> <br>#define THRESHOLD   3 <br> <br> <br>//*************************************************************************** <br> <br>BOOL AppInit (HANDLE hInst, HANDLE hPrev, WORD sw, LPTSTR szCmdLine) <br>{ <br>    WNDCLASS cls; <br>    int    dx, dy; <br> <br>    if (hPrev != NULL) <br>        return FALSE; <br> <br>    /* <br>     *  Register a class for the main application window <br>     */ <br>    cls.hCursor        = NULL; <br>    cls.hIcon          = LoadIcon (hInst, MAKEINTATOM (ID_APP)); <br>    cls.lpszMenuName   = NULL; <br>    cls.lpszClassName  = TEXT("WindowsScreenSaverClass"); <br>    cls.hbrBackground  = GetStockObject (BLACK_BRUSH); <br>    cls.hInstance      = hInst; <br>    cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>    cls.lpfnWndProc    = ScreenSaverProc; <br>    cls.cbWndExtra     = 0; <br>    cls.cbClsExtra     = 0; <br> <br>    if (!RegisterClass (&amp;cls)) <br>        return FALSE; <br> <br>    dx = GetSystemMetrics (SM_CXSCREEN); <br>    dy = GetSystemMetrics (SM_CYSCREEN); <br>    hMainWindow = CreateWindowEx (WS_EX_TOPMOST, <br>                            TEXT("WindowsScreenSaverClass"), // Class name <br>                            TEXT("\0"),                      // Caption <br>                            WS_POPUP | WS_VISIBLE |          // Style bits <br>                            WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>                            0, 0,                            // Position <br>                            dx, dy,                          // Size <br>                            (HWND)NULL,                      // Parent window (no parent) <br>                            (HMENU)NULL,                     // use class menu <br>                            (HANDLE)hInst,                   // handle to window instance <br>                            (LPVOID)NULL                     // no params to pass on <br>                               ); <br>    if (hMainWindow) <br>        return TRUE; <br> <br>    return FALSE; <br>} <br> <br> <br>//*************************************************************************** <br> <br>int _CRTAPI1 main (USHORT argc, CHAR **argv) <br>{ <br>    HANDLE   hInst; <br>    HANDLE   hPrev     = NULL; <br>    LPTSTR   szCmdLine = GetCommandLine(); <br>    WORD     sw        = SW_SHOWNORMAL; <br>    MSG      msg; <br>    LPTSTR   lpT; <br> <br>    hInst = GetModuleHandle (NULL); <br> <br>    /* Save instance handle for DialogBoxs */ <br>    hMainInst = hInst; <br> <br>    // This has to be loaded first so we know who we are and to find if we <br>    // already around. <br> <br>    LoadString (hInst, idsAppName, szAppName, CharSizeOf(szAppName)); <br> <br>    //================================================================= <br>    // on NT, szCmdLine's first string includes its own name, remove this <br>    // to make it exactly like the windows command line. <br> <br>    if (*szCmdLine) <br>    { <br>        lpT = _tcschr (szCmdLine, TEXT(' '));   // skip self name <br>        if (lpT) <br>        { <br>            szCmdLine = lpT; <br>            while (*szCmdLine == TEXT(' ')) <br>                szCmdLine++;            // skip spaces to end or first cmd <br>        } <br>        else <br>        { <br>            szCmdLine += lstrlen(szCmdLine);   // point to NULL <br>        } <br>    } <br>    //===================================================================== <br> <br>    MyHelpMessage = RegisterWindowMessage (szAppName); <br> <br>    if (MyHelpMessage) <br>        hhkNextMsgFilterHookFunc = SetWindowsHook (WH_MSGFILTER, <br>                                      (HOOKPROC)HelpMessageFilterHookFunction); <br>    /* Parse through the command line.  If the parameter is -s, /s, or s, then <br>       bring up a configure dialog box.  Otherwise, bring up the normal <br>       window...*/ <br>    if (!((!_tcsnicmp (szCmdLine, TEXT("/s"), 2) || !_tcsicmp (szCmdLine, TEXT("-s"))) || <br>        !_tcsicmp (szCmdLine, TEXT("s")))) <br>    { <br>        if (!((!_tcsicmp (szCmdLine, TEXT("/c")) || !_tcsicmp (szCmdLine, TEXT("-c"))) || <br>            !_tcsicmp (szCmdLine, TEXT("c")))) <br>            return DoConfigureDialog (hInst, FALSE); <br>        else <br>            return DoConfigureDialog (hInst, TRUE); <br>    } <br> <br>    /* Call initialization procedure */ <br>    if (!AppInit (hInst, hPrev, sw, szCmdLine)) <br>        return FALSE; <br> <br>    /* Message Loop for the program... */ <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) <br>    { <br>        TranslateMessage (&amp;msg); <br>        DispatchMessage (&amp;msg); <br>    } <br> <br>    if (MyHelpMessage) <br>        UnhookWindowsHook (WH_MSGFILTER, (HOOKPROC)HelpMessageFilterHookFunction); <br> <br>    return msg.wParam; <br>} <br> <br> <br>//*************************************************************************** <br> <br> <br>LONG DefScreenSaverProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    static BOOL     fHere = FALSE; <br>    static POINT    ptLast; <br>    static BOOL     bDialogUp = FALSE; <br>    POINT           ptCursor, ptCheck; <br> <br>    switch (msg) <br>    { <br>    case WM_SYSCOMMAND: <br>        if ((wParam==SC_SCREENSAVE) || (wParam==SC_CLOSE)) <br>            return FALSE; <br>        break; <br> <br>    case WM_DESTROY: <br>        PostQuitMessage (0); <br>        break; <br> <br>    case WM_SETCURSOR: <br>        SetCursor (NULL); <br>        break; <br> <br>    case WM_NCACTIVATE: <br>        if (wParam==FALSE &amp;&amp; !bDialogUp) <br>            return FALSE; <br>        break; <br> <br>    case WM_ACTIVATE: <br>    case WM_ACTIVATEAPP: <br>        if (wParam != FALSE)        // only fall through if we are <br>            break;                  // losing the focus... <br> <br>    case WM_MOUSEMOVE: <br>        if (!fHere) <br>        { <br>            GetCursorPos (&amp;ptLast); <br>            fHere = TRUE; <br>        } <br>        else <br>        { <br>            GetCursorPos (&amp;ptCheck); <br>            if (ptCursor.x = ptCheck.x - ptLast.x) <br>            { <br>                if (ptCursor.x &lt; 0) <br>                    ptCursor.x *= -1; <br>            } <br>            if (ptCursor.y = ptCheck.y - ptLast.y) <br>            { <br>                if (ptCursor.y &lt; 0) <br>                    ptCursor.y *= -1; <br>            } <br>            if ((ptCursor.x + ptCursor.y) &gt; THRESHOLD) <br>                goto SHOWDIALOG; <br>        } <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>    case WM_MBUTTONDOWN: <br>    case WM_RBUTTONDOWN: <br>        GetCursorPos (&amp;ptCursor); <br>        ptCursor.x ++; <br>        ptCursor.y ++; <br>        SetCursorPos (ptCursor.x, ptCursor.y); <br>        GetCursorPos (&amp;ptCheck); <br>        if (ptCheck.x != ptCursor.x &amp;&amp; ptCheck.y != ptCursor.y) <br>            ptCursor.x -= 2; <br>        ptCursor.y -= 2; <br>        SetCursorPos (ptCursor.x, ptCursor.y); <br> <br>        // fall thru <br> <br>    case WM_KEYDOWN: <br>    case WM_SYSKEYDOWN: <br>SHOWDIALOG: <br>        PostMessage (hWnd, WM_CLOSE, 0, 0l); <br>        break; <br>    } <br>    return DefWindowProc (hWnd, msg, wParam, lParam); <br>} <br> <br> <br>//*************************************************************************** <br> <br>int    DoConfigureDialog (HANDLE hInst, BOOL fParent ) <br>{ <br>    HWND    hWndParent; <br> <br>    if (fParent) <br>        hWndParent = GetActiveWindow (); <br>    else <br>        hWndParent = NULL; <br> <br>    if (RegisterDialogClasses (hInst)) <br>    { <br>        hMainWindow = NULL; <br>        DialogBox (hInst, MAKEINTRESOURCE (DLG_SCRNSAVECONFIGURE), <br>                          hWndParent, (WNDPROC) ScreenSaverConfigureDialog); <br>    } <br> <br>    return TRUE; <br>} <br> <br>//*************************************************************************** <br> <br>LRESULT CALLBACK HelpMessageFilterHookFunction (int nCode, WPARAM wParam, LPMSG lpMsg) <br>{ <br> <br>    if (nCode &lt; 0) <br>        goto DefHook; <br> <br>    if (nCode == MSGF_DIALOGBOX) <br>        if (lpMsg-&gt;message == WM_KEYDOWN &amp;&amp; lpMsg-&gt;wParam == VK_F1) <br>        { <br>            HWND hTemp; <br>            HWND hParent = lpMsg-&gt;hwnd; <br> <br>            while (hParent != NULL) <br>            { <br>                hTemp = hParent; <br>                if (!(GetWindowLong(hTemp, GWL_STYLE) &amp; WS_CHILD)) <br>                    break; <br>                hParent = (HWND) GetWindowLong (hParent, GWL_HWNDPARENT); <br>            } <br> <br>            PostMessage (hTemp, MyHelpMessage, 0, 0L); <br>            return TRUE; <br>        } <br>        else <br>DefHook: <br>        return (int)DefHookProc(nCode, wParam, (LONG)lpMsg, &amp;hhkNextMsgFilterHookFunc); <br> <br>    return 0; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
