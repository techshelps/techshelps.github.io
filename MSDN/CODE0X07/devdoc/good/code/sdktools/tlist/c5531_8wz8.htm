<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMMON.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5534"></a>COMMON.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright (C) 1994-1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>/*++ <br> <br>Module Name: <br> <br>    common.c <br> <br>Abstract: <br> <br>    This module contains common apis used by tlist &amp; kill. <br> <br>--*/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winperf.h&gt;   // for Windows NT <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;tlhelp32.h&gt;  // for Windows 95 <br> <br>#include "common.h" <br> <br> <br>// <br>// manafest constants <br>// <br>#define INITIAL_SIZE        51200 <br>#define EXTEND_SIZE         25600 <br>#define REGKEY_PERF         "software\\microsoft\\windows nt\\currentversion\\perflib" <br>#define REGSUBKEY_COUNTERS  "Counters" <br>#define PROCESS_COUNTER     "process" <br>#define PROCESSID_COUNTER   "id process" <br>#define UNKNOWN_TASK        "unknown" <br> <br> <br>// <br>// Function pointer types for accessing Toolhelp32 functions dynamically. <br>// By dynamically accessing these functions, we can do so only on Windows <br>// 95 and still run on Windows NT, which does not have these functions. <br>// <br>typedef BOOL (WINAPI *PROCESSWALK)(HANDLE hSnapshot, LPPROCESSENTRY32 lppe); <br>typedef HANDLE (WINAPI *CREATESNAPSHOT)(DWORD dwFlags, DWORD th32ProcessID); <br> <br> <br>// <br>// prototypes <br>// <br>BOOL CALLBACK <br>EnumWindowsProc( <br>    HWND    hwnd, <br>    DWORD   lParam <br>    ); <br> <br> <br> <br>DWORD <br>GetTaskList95( <br>    PTASK_LIST  pTask, <br>    DWORD       dwNumTasks <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Provides an API for getting a list of tasks running at the time of the <br>    API call.  This function uses Toolhelp32to get the task list and is  <br>    therefore straight WIN32 calls that anyone can call. <br> <br>Arguments: <br> <br>    dwNumTasks       - maximum number of tasks that the pTask array can hold <br> <br>Return Value: <br> <br>    Number of tasks placed into the pTask array. <br> <br>--*/ <br> <br>{ <br>   CREATESNAPSHOT pCreateToolhelp32Snapshot = NULL; <br>   PROCESSWALK    pProcess32First           = NULL; <br>   PROCESSWALK    pProcess32Next            = NULL; <br> <br>   HANDLE         hKernel        = NULL; <br>   HANDLE         hProcessSnap   = NULL; <br>   PROCESSENTRY32 pe32           = {0}; <br>   DWORD          dwTaskCount    = 0; <br> <br> <br>   // Guarantee to the code later on that we'll enum at least one task. <br>   if (dwNumTasks == 0) <br>      return 0; <br> <br>    // Obtain a module handle to KERNEL so that we can get the addresses of <br>    // the 32-bit Toolhelp functions we need. <br>    hKernel = GetModuleHandle("KERNEL32.DLL"); <br> <br>    if (hKernel) <br>    { <br>        pCreateToolhelp32Snapshot = <br>          (CREATESNAPSHOT)GetProcAddress(hKernel, "CreateToolhelp32Snapshot"); <br> <br>        pProcess32First = (PROCESSWALK)GetProcAddress(hKernel, <br>                                                      "Process32First"); <br>        pProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel, <br>                                                      "Process32Next"); <br>    } <br>     <br>    // make sure we got addresses of all needed Toolhelp functions. <br>    if (!(pProcess32First &amp;&amp; pProcess32Next &amp;&amp; pCreateToolhelp32Snapshot)) <br>       return 0; <br>        <br> <br>    // Take a snapshot of all processes currently in the system. <br>    hProcessSnap = pCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); <br>    if (hProcessSnap == (HANDLE)-1) <br>        return 0; <br> <br>    // Walk the snapshot of processes and for each process, get information <br>    // to display. <br>    dwTaskCount = 0; <br>    pe32.dwSize = sizeof(PROCESSENTRY32);   // must be filled out before use <br>    if (pProcess32First(hProcessSnap, &amp;pe32)) <br>    { <br>        do <br>        { <br>            LPSTR pCurChar; <br> <br>            // strip path and leave executabe filename splitpath <br>            for (pCurChar = (pe32.szExeFile + lstrlen (pe32.szExeFile)); <br>                 *pCurChar != '\\' &amp;&amp; pCurChar != pe32.szExeFile;  <br>                 --pCurChar) <br> <br>            lstrcpy(pTask -&gt; ProcessName, pCurChar); <br>            pTask -&gt; flags = 0; <br>            pTask -&gt; dwProcessId = pe32.th32ProcessID; <br> <br>            ++dwTaskCount;   // keep track of how many tasks we've got so far <br>            ++pTask;         // get to next task info block. <br>        } <br>        while (dwTaskCount &lt; dwNumTasks &amp;&amp; pProcess32Next(hProcessSnap, &amp;pe32)); <br>    } <br>    else <br>        dwTaskCount = 0;    // Couldn't walk the list of processes. <br> <br>    // Don't forget to clean up the snapshot object... <br>    CloseHandle (hProcessSnap); <br> <br>    return dwTaskCount; <br>} <br> <br> <br>DWORD <br>GetTaskListNT( <br>    PTASK_LIST  pTask, <br>    DWORD       dwNumTasks <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Provides an API for getting a list of tasks running at the time of the <br>    API call.  This function uses the registry performance data to get the <br>    task list and is therefore straight WIN32 calls that anyone can call. <br> <br>Arguments: <br> <br>    dwNumTasks       - maximum number of tasks that the pTask array can hold <br> <br>Return Value: <br> <br>    Number of tasks placed into the pTask array. <br> <br>--*/ <br> <br>{ <br>    DWORD                        rc; <br>    HKEY                         hKeyNames; <br>    DWORD                        dwType; <br>    DWORD                        dwSize; <br>    LPBYTE                       buf = NULL; <br>    CHAR                         szSubKey[1024]; <br>    LANGID                       lid; <br>    LPSTR                        p; <br>    LPSTR                        p2; <br>    PPERF_DATA_BLOCK             pPerf; <br>    PPERF_OBJECT_TYPE            pObj; <br>    PPERF_INSTANCE_DEFINITION    pInst; <br>    PPERF_COUNTER_BLOCK          pCounter; <br>    PPERF_COUNTER_DEFINITION     pCounterDef; <br>    DWORD                        i; <br>    DWORD                        dwProcessIdTitle; <br>    DWORD                        dwProcessIdCounter; <br>    CHAR                         szProcessName[MAX_PATH]; <br>    DWORD                        dwLimit = dwNumTasks - 1; <br> <br> <br> <br>    // <br>    // Look for the list of counters.  Always use the neutral <br>    // English version, regardless of the local language.  We <br>    // are looking for some particular keys, and we are always <br>    // going to do our looking in English.  We are not going <br>    // to show the user the counter names, so there is no need <br>    // to go find the corresponding name in the local language. <br>    // <br>    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL ); <br>    sprintf( szSubKey, "%s\\%03x", REGKEY_PERF, lid ); <br>    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, <br>                       szSubKey, <br>                       0, <br>                       KEY_READ, <br>                       &amp;hKeyNames <br>                     ); <br>    if (rc != ERROR_SUCCESS) { <br>        goto exit; <br>    } <br> <br>    // <br>    // get the buffer size for the counter names <br>    // <br>    rc = RegQueryValueEx( hKeyNames, <br>                          REGSUBKEY_COUNTERS, <br>                          NULL, <br>                          &amp;dwType, <br>                          NULL, <br>                          &amp;dwSize <br>                        ); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        goto exit; <br>    } <br> <br>    // <br>    // allocate the counter names buffer <br>    // <br>    buf = (LPBYTE) malloc( dwSize ); <br>    if (buf == NULL) { <br>        goto exit; <br>    } <br>    memset( buf, 0, dwSize ); <br> <br>    // <br>    // read the counter names from the registry <br>    // <br>    rc = RegQueryValueEx( hKeyNames, <br>                          REGSUBKEY_COUNTERS, <br>                          NULL, <br>                          &amp;dwType, <br>                          buf, <br>                          &amp;dwSize <br>                        ); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        goto exit; <br>    } <br> <br>    // <br>    // now loop thru the counter names looking for the following counters: <br>    // <br>    //      1.  "Process"           process name <br>    //      2.  "ID Process"        process id <br>    // <br>    // the buffer contains multiple null terminated strings and then <br>    // finally null terminated at the end.  the strings are in pairs of <br>    // counter number and counter name. <br>    // <br> <br>    p = buf; <br>    while (*p) { <br>        if (p &gt; buf) { <br>            for( p2=p-2; isdigit(*p2); p2--) ; <br>            } <br>        if (stricmp(p, PROCESS_COUNTER) == 0) { <br>            // <br>            // look backwards for the counter number <br>            // <br>            for( p2=p-2; isdigit(*p2); p2--) ; <br>            strcpy( szSubKey, p2+1 ); <br>        } <br>        else <br>        if (stricmp(p, PROCESSID_COUNTER) == 0) { <br>            // <br>            // look backwards for the counter number <br>            // <br>            for( p2=p-2; isdigit(*p2); p2--) ; <br>            dwProcessIdTitle = atol( p2+1 ); <br>        } <br>        // <br>        // next string <br>        // <br>        p += (strlen(p) + 1); <br>    } <br> <br>    // <br>    // free the counter names buffer <br>    // <br>    free( buf ); <br> <br> <br>    // <br>    // allocate the initial buffer for the performance data <br>    // <br>    dwSize = INITIAL_SIZE; <br>    buf = malloc( dwSize ); <br>    if (buf == NULL) { <br>        goto exit; <br>    } <br>    memset( buf, 0, dwSize ); <br> <br> <br>    while (TRUE) { <br> <br>        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA, <br>                              szSubKey, <br>                              NULL, <br>                              &amp;dwType, <br>                              buf, <br>                              &amp;dwSize <br>                            ); <br> <br>        pPerf = (PPERF_DATA_BLOCK) buf; <br> <br>        // <br>        // check for success and valid perf data block signature <br>        // <br>        if ((rc == ERROR_SUCCESS) &amp;&amp; <br>            (dwSize &gt; 0) &amp;&amp; <br>            (pPerf)-&gt;Signature[0] == (WCHAR)'P' &amp;&amp; <br>            (pPerf)-&gt;Signature[1] == (WCHAR)'E' &amp;&amp; <br>            (pPerf)-&gt;Signature[2] == (WCHAR)'R' &amp;&amp; <br>            (pPerf)-&gt;Signature[3] == (WCHAR)'F' ) { <br>            break; <br>        } <br> <br>        // <br>        // if buffer is not big enough, reallocate and try again <br>        // <br>        if (rc == ERROR_MORE_DATA) { <br>            dwSize += EXTEND_SIZE; <br>            buf = realloc( buf, dwSize ); <br>            memset( buf, 0, dwSize ); <br>        } <br>        else { <br>            goto exit; <br>        } <br>    } <br> <br>    // <br>    // set the perf_object_type pointer <br>    // <br>    pObj = (PPERF_OBJECT_TYPE) ((DWORD)pPerf + pPerf-&gt;HeaderLength); <br> <br>    // <br>    // loop thru the performance counter definition records looking <br>    // for the process id counter and then save its offset <br>    // <br>    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD)pObj + pObj-&gt;HeaderLength); <br>    for (i=0; i&lt;(DWORD)pObj-&gt;NumCounters; i++) { <br>        if (pCounterDef-&gt;CounterNameTitleIndex == dwProcessIdTitle) { <br>            dwProcessIdCounter = pCounterDef-&gt;CounterOffset; <br>            break; <br>        } <br>        pCounterDef++; <br>    } <br> <br>    dwNumTasks = min( dwLimit, (DWORD)pObj-&gt;NumInstances ); <br> <br>    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD)pObj + pObj-&gt;DefinitionLength); <br> <br>    // <br>    // loop thru the performance instance data extracting each process name <br>    // and process id <br>    // <br>    for (i=0; i&lt;dwNumTasks; i++) { <br>        // <br>        // pointer to the process name <br>        // <br>        p = (LPSTR) ((DWORD)pInst + pInst-&gt;NameOffset); <br> <br>        // <br>        // convert it to ascii <br>        // <br>        rc = WideCharToMultiByte( CP_ACP, <br>                                  0, <br>                                  (LPCWSTR)p, <br>                                  -1, <br>                                  szProcessName, <br>                                  sizeof(szProcessName), <br>                                  NULL, <br>                                  NULL <br>                                ); <br> <br>        if (!rc) { <br>            // <br>    // if we cant convert the string then use a default value <br>            // <br>            strcpy( pTask-&gt;ProcessName, UNKNOWN_TASK ); <br>        } <br> <br>        if (strlen(szProcessName)+4 &lt;= sizeof(pTask-&gt;ProcessName)) { <br>            strcpy( pTask-&gt;ProcessName, szProcessName ); <br>            strcat( pTask-&gt;ProcessName, ".exe" ); <br>        } <br> <br>        // <br>        // get the process id <br>        // <br>        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD)pInst + pInst-&gt;ByteLength); <br>        pTask-&gt;flags = 0; <br>        pTask-&gt;dwProcessId = *((LPDWORD) ((DWORD)pCounter + dwProcessIdCounter)); <br>        if (pTask-&gt;dwProcessId == 0) { <br>            pTask-&gt;dwProcessId = (DWORD)-2; <br>        } <br> <br>        // <br>        // next process <br>        // <br>        pTask++; <br>        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD)pCounter + pCounter-&gt;ByteLength); <br>    } <br> <br>exit: <br>    if (buf) { <br>        free( buf ); <br>    } <br> <br>    RegCloseKey( hKeyNames ); <br>    RegCloseKey( HKEY_PERFORMANCE_DATA ); <br> <br>    return dwNumTasks; <br>} <br> <br> <br> <br>BOOL <br>EnableDebugPriv95( <br>    VOID <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Changes the process's privilege so that kill works properly. <br> <br>Arguments: <br> <br> <br>Return Value: <br> <br>    TRUE             - success <br>    FALSE            - failure <br> <br>Comments:  <br>    Always returns TRUE <br> <br>--*/ <br> <br>{ <br>   return TRUE; <br>} <br> <br> <br> <br>BOOL <br>EnableDebugPrivNT( <br>    VOID <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Changes the process's privilege so that kill works properly. <br> <br>Arguments: <br> <br> <br>Return Value: <br> <br>    TRUE             - success <br>    FALSE            - failure <br> <br>--*/ <br> <br>{ <br>    HANDLE hToken; <br>    LUID DebugValue; <br>    TOKEN_PRIVILEGES tkp; <br> <br> <br>    // <br>    // Retrieve a handle of the access token <br>    // <br>    if (!OpenProcessToken(GetCurrentProcess(), <br>            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>            &amp;hToken)) { <br>        printf("OpenProcessToken failed with %d\n", GetLastError()); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Enable the SE_DEBUG_NAME privilege <br>    // <br>    if (!LookupPrivilegeValue((LPSTR) NULL, <br>            SE_DEBUG_NAME, <br>            &amp;DebugValue)) { <br>        printf("LookupPrivilegeValue failed with %d\n", GetLastError()); <br>        return FALSE; <br>    } <br> <br>    tkp.PrivilegeCount = 1; <br>    tkp.Privileges[0].Luid = DebugValue; <br>    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br> <br>    AdjustTokenPrivileges(hToken, <br>        FALSE, <br>        &amp;tkp, <br>        sizeof(TOKEN_PRIVILEGES), <br>        (PTOKEN_PRIVILEGES) NULL, <br>        (PDWORD) NULL); <br> <br>    // <br>    // The return value of AdjustTokenPrivileges can't be tested <br>    // <br>    if (GetLastError() != ERROR_SUCCESS) { <br>        printf("AdjustTokenPrivileges failed with %d\n", GetLastError()); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>KillProcess( <br>    PTASK_LIST tlist, <br>    BOOL       fForce <br>    ) <br>{ <br>    HANDLE            hProcess; <br> <br> <br>    if (fForce || !tlist-&gt;hwnd) { <br>        hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist-&gt;dwProcessId ); <br>        if (hProcess) { <br>            hProcess = OpenProcess( PROCESS_ALL_ACCESS, FALSE, tlist-&gt;dwProcessId ); <br>            if (hProcess == NULL) { <br>                return FALSE; <br>            } <br> <br>            if (!TerminateProcess( hProcess, 1 )) { <br>                CloseHandle( hProcess ); <br>                return FALSE; <br>            } <br> <br>            CloseHandle( hProcess ); <br>            return TRUE; <br>        } <br>    } <br> <br>    // <br>    // kill the process <br>    // <br>    PostMessage( tlist-&gt;hwnd, WM_CLOSE, 0, 0 ); <br> <br>    return TRUE; <br>} <br> <br> <br>VOID <br>GetWindowTitles( <br>    PTASK_LIST_ENUM te <br>    ) <br>{ <br>    // <br>    // enumerate all windows <br>    // <br>    EnumWindows( EnumWindowsProc, (LPARAM) te ); <br>} <br> <br> <br> <br>BOOL CALLBACK <br>EnumWindowsProc( <br>    HWND    hwnd, <br>    DWORD   lParam <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Callback function for window enumeration. <br> <br>Arguments: <br> <br>    hwnd             - window handle <br>    lParam           - ** not used ** <br> <br>Return Value: <br> <br>    TRUE  - continues the enumeration <br> <br>--*/ <br> <br>{ <br>    DWORD             pid = 0; <br>    DWORD             i; <br>    CHAR              buf[TITLE_SIZE]; <br>    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam; <br>    PTASK_LIST        tlist = te-&gt;tlist; <br>    DWORD             numTasks = te-&gt;numtasks; <br> <br> <br>    // <br>    // get the processid for this window <br>    // <br>    if (!GetWindowThreadProcessId( hwnd, &amp;pid )) { <br>        return TRUE; <br>    } <br> <br>    // <br>    // look for the task in the task list for this window <br>    // <br>    for (i=0; i&lt;numTasks; i++) { <br>        if (tlist[i].dwProcessId == pid) { <br>            tlist[i].hwnd = hwnd; <br>            // <br>    // we found the task so lets try to get the <br>            // window text <br>            // <br>            if (GetWindowText( tlist[i].hwnd, buf, sizeof(buf) )) { <br>                // <br>// got it, so lets save it <br>                // <br>                strcpy( tlist[i].WindowTitle, buf ); <br>            } <br>            break; <br>        } <br>    } <br> <br>    // <br>    // continue the enumeration <br>    // <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>MatchPattern( <br>    PUCHAR String, <br>    PUCHAR Pattern <br>    ) <br>{ <br>    UCHAR   c, p, l; <br> <br>    for (; ;) { <br>        switch (p = *Pattern++) { <br>            case 0:                             // end of pattern <br>                return *String ? FALSE : TRUE;  // if end of string TRUE <br> <br>            case '*': <br>                while (*String) {               // match zero or more char <br>                    if (MatchPattern (String++, Pattern)) <br>                        return TRUE; <br>                } <br>                return MatchPattern (String, Pattern); <br> <br>            case '?': <br>                if (*String++ == 0)             // match any one char <br>                    return FALSE;                   // not end of string <br>                break; <br> <br>            case '[': <br>                if ( (c = *String++) == 0)      // match char set <br>                    return FALSE;                   // syntax <br> <br>                c = toupper(c); <br>                l = 0; <br>                while (p = *Pattern++) { <br>                    if (p == ']')               // if end of char set, then <br>                        return FALSE;           // no match found <br> <br>                    if (p == '-') {             // check a range of chars? <br>                        p = *Pattern;           // get high limit of range <br>                        if (p == 0  ||  p == ']') <br>                            return FALSE;           // syntax <br> <br>                        if (c &gt;= l  &amp;&amp;  c &lt;= p) <br>                            break;              // if in range, move on <br>                    } <br> <br>                    l = p; <br>                    if (c == p)                 // if char matches this element <br>                        break;                  // move on <br>                } <br> <br>                while (p  &amp;&amp;  p != ']')         // got a match in char set <br>                    p = *Pattern++;             // skip to end of set <br> <br>                break; <br> <br>            default: <br>                c = *String++; <br>                if (toupper(c) != p)            // check for exact char <br>                    return FALSE;                   // not a match <br> <br>                break; <br>        } <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
