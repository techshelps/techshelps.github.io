<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KILL.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5533"></a>KILL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright (C) 1994-1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*++ <br> <br>Module Name: <br> <br>    kill.c <br> <br>Abstract: <br> <br>    This module implements a task killer application. <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include "common.h" <br> <br> <br>#define MAX_TASKS           256 <br> <br>BOOL        ForceKill; <br>DWORD       pid; <br>CHAR        pname[MAX_PATH]; <br>TASK_LIST   tlist[MAX_TASKS]; <br> <br> <br>VOID GetCommandLineArgs(VOID); <br>VOID Usage(VOID); <br> <br> <br> <br>int _cdecl <br>main( <br>    int argc, <br>    char *argv[] <br>    ) <br>{ <br>    DWORD             i; <br>    DWORD             numTasks; <br>    TASK_LIST_ENUM    te; <br>    int               rval = 0; <br>    char              tname[PROCESS_SIZE]; <br>    LPSTR             p; <br>    DWORD             ThisPid; <br>    OSVERSIONINFO     verInfo = {0}; <br>    LPGetTaskList     GetTaskList; <br>    LPEnableDebugPriv EnableDebugPriv; <br> <br> <br>    GetCommandLineArgs(); <br> <br>    if (pid == 0 &amp;&amp; pname[0] == 0) { <br>        printf( "missing pid or task name\n" <br>                "type kill /? for help\n"); <br>        return 1; <br>    } <br> <br> <br>    // <br>    // Determine what system we're on and do the right thing <br>    // <br>    verInfo.dwOSVersionInfoSize = sizeof (verInfo); <br>    GetVersionEx(&amp;verInfo); <br> <br>    switch (verInfo.dwPlatformId) <br>    { <br>    case VER_PLATFORM_WIN32_NT: <br>       GetTaskList     = GetTaskListNT; <br>       EnableDebugPriv = EnableDebugPrivNT; <br>       break; <br> <br>    case VER_PLATFORM_WIN32_WINDOWS: <br>       GetTaskList = GetTaskList95; <br>       EnableDebugPriv = EnableDebugPriv95; <br>       break; <br> <br>    default: <br>       printf ("tlist requires Windows NT or Windows 95\n"); <br>       return 1; <br>    } <br> <br> <br>    // <br>    // Obtain the ability to manipulate other processes <br>    // <br>    EnableDebugPriv(); <br> <br>    if (pid) { <br>        tlist[0].dwProcessId = pid; <br>        if (KillProcess( tlist, TRUE )) { <br>            printf( "process #%d killed\n", pid ); <br>            return 0; <br>        } else { <br>            printf( "process #%d could not be killed\n", pid ); <br>            return 1; <br>        } <br>    } <br> <br>    // <br>    // get the task list for the system <br>    // <br>    numTasks = GetTaskList( tlist, MAX_TASKS ); <br> <br>    // <br>    // enumerate all windows and try to get the window <br>    // titles for each task <br>    // <br>    te.tlist = tlist; <br>    te.numtasks = numTasks; <br>    GetWindowTitles( &amp;te ); <br> <br>    ThisPid = GetCurrentProcessId(); <br> <br>    for (i=0; i&lt;numTasks; i++) { <br>        // <br>        // this prevents the user from killing KILL.EXE and <br>        // it's parent cmd window too <br>        // <br>        if (ThisPid == tlist[i].dwProcessId) { <br>            continue; <br>        } <br>        if (MatchPattern( tlist[i].WindowTitle, "*KILL*" )) { <br>            continue; <br>        } <br> <br>        tname[0] = 0; <br>        strcpy( tname, tlist[i].ProcessName ); <br>        p = strchr( tname, '.' ); <br>        if (p) { <br>            p[0] = '\0'; <br>        } <br>        if (MatchPattern( tname, pname )) { <br>            tlist[i].flags = TRUE; <br>        } else if (MatchPattern( tlist[i].ProcessName, pname )) { <br>            tlist[i].flags = TRUE; <br>        } else if (MatchPattern( tlist[i].WindowTitle, pname )) { <br>            tlist[i].flags = TRUE; <br>        } <br>    } <br> <br>    for (i=0; i&lt;numTasks; i++) { <br>        if (tlist[i].flags) { <br>            if (KillProcess( &amp;tlist[i], ForceKill )) { <br>                printf( "process #%d [%s] killed\n", tlist[i].dwProcessId, tlist[i].ProcessName ); <br>            } else { <br>                printf( "process #%d [%s] could not be killed\n", tlist[i].dwProcessId, tlist[i].ProcessName ); <br>                rval = 1; <br>            } <br>        } <br>    } <br> <br>    return rval; <br>} <br> <br>VOID <br>GetCommandLineArgs( <br>    VOID <br>    ) <br>{ <br>    char        *lpstrCmd; <br>    UCHAR       ch; <br>    char        *p = pname; <br> <br> <br>    pid = 0; <br>    *p = '\0'; <br> <br>    lpstrCmd = GetCommandLine(); <br> <br>    // skip over program name <br>    do  <br>    { <br>       ch = *lpstrCmd++; <br>    } <br>    while (!isspace(ch)); <br> <br>    //  skip over any white space following the program name <br>    while (isspace(ch))  <br>    { <br>       ch = *lpstrCmd++; <br>    } <br> <br> <br>    // Follow this pattern strictly: <br>    //  KILL [options] &lt;&lt;pid&gt; | &lt;pattern&gt;&gt;\n\n"  <br>    //  where options is /f, <br>    //  and PID is a positive or negative decimal number, and <br>    //  pattern is a string of characters <br> <br>    // Look for an option, which will be prefaced with '/' <br>    if (ch == '/') <br>    { <br>       ch = *lpstrCmd++; <br>   <br>       switch (ch)  <br>       { <br>       case 'F':     // found "kill /f" so far <br>       case 'f': <br>          ForceKill = TRUE; <br>          ch = *lpstrCmd++; <br>          break; <br> <br>       case '?':    // found "kill /?" <br>          Usage(); <br>          return;   // don't do anything after printing usage <br>          break; <br> <br>       default: <br>          printf ("%c is an invalid switch\n", ch);  // invalid switch <br>          return;    <br>       } <br>     <br>       // eat whitepace after option switch <br>       while (isspace(ch))  <br>       { <br>          ch = *lpstrCmd++; <br>       } <br>    } <br> <br>    // In the 3 cases below, look for either a PID or a pattern  <br>    // a PID could be a positive or negative decimal integer <br> <br>    // Look for a negative PID <br>    if (ch == '-') <br>    { <br>       ch = *lpstrCmd++; <br> <br>       while (isdigit(ch))  <br>       { <br>          pid = pid * 10 - ( ch - '0' ); <br>          ch = *lpstrCmd++; <br>       } <br>       return; // found "kill -pid" or "kill /f -pid" so we're done <br>    } <br> <br>    // Look for a postive PID <br>    if (isdigit(ch))  <br>    { <br>       while (isdigit(ch))  <br>       { <br>          pid = pid * 10 + ch - '0'; <br>          ch = *lpstrCmd++; <br>       } <br>       return;  // found "kill pid" or "kill /f pid" so we're done <br>    } <br>  <br>    // Look for a pattern <br>    while (ch)  <br>    { <br>       *p++ = ch; <br>       ch = *lpstrCmd++; <br>    } <br>    *p = '\0'; <br>    strupr(pname); <br> <br>    return;  // found "kill pattern" or "kill /f pattern" so we're done <br>} <br>       <br> <br> <br>VOID <br>Usage( <br>    VOID <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Prints usage text for this tool. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    fprintf( stderr, "Microsoft (R) Windows (TM) KILL\n" ); <br>    fprintf( stderr, "Copyright (C) 1994-1996 Microsoft Corp. All rights reserved\n\n" ); <br>    fprintf( stderr, "usage: KILL [options] &lt;&lt;pid&gt; | &lt;pattern&gt;&gt;\n\n" ); <br>    fprintf( stderr, "           [options]:\n" ); <br>    fprintf( stderr, "               /?     This help\n\n" ); <br>    fprintf( stderr, "               /f     Force process kill\n\n" ); <br>    fprintf( stderr, "           &lt;pid&gt;\n" ); <br>    fprintf( stderr, "              This is the process id for the task\n" ); <br>    fprintf( stderr, "               to be killed.  Use TLIST to get a\n" ); <br>    fprintf( stderr, "               valid pid\n\n" ); <br>    fprintf( stderr, "           &lt;pattern&gt;\n" ); <br>    fprintf( stderr, "              The pattern can be a complete task\n" ); <br>    fprintf( stderr, "              name or a regular expression pattern\n" ); <br>    fprintf( stderr, "              to use as a match.  Kill matches the\n" ); <br>    fprintf( stderr, "              supplied pattern against the task names\n" ); <br>    fprintf( stderr, "              and the window titles.\n" ); <br>    ExitProcess(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
