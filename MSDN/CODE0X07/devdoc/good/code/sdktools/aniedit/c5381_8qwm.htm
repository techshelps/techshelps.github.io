<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ANIEDIT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5386"></a>ANIEDIT.C</h2>
<pre><code>/****************************************************************************\ <br>* <br>*     PROGRAM: AniEdit.c <br>* <br>*     PURPOSE: Animated Cursor Editor for Windows NT <br>* <br>*     Copyright 1993-1996 Microsoft Corp. <br>* <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Wrote it. <br>* <br>\****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "anidefs.h" <br> <br>HANDLE hInst; <br>HWND ghwndMain; <br>HWND ghwndRateScroll = NULL; <br> <br>ANICUR ganiAcon; <br> <br>int gcyCursor, gcxCursor; <br> <br>HBRUSH  ghbrPrevBackgnd, ghbrWindow, ghbrHighlight; <br>COLORREF gcrHighlightText; <br>HICON   ghIcon; <br> <br>TCHAR   gszModPath[MAX_PATH];     /* name for above font module */ <br>TCHAR   gszWindowTitle[MAX_PATH] = TEXT("AniEdit"); <br>TCHAR   gszDots[] = TEXT("..."); <br>PFRAME  gpfrmFrames = NULL; <br>PCLPBRDDAT gpbdClipBoard = NULL; <br>TCHAR   gszCursorEditor[MAX_PATH]; <br> <br>//HACCEL haccel; <br>int giradColor = 0; /* Default to desktop color */ <br>RADIOCOLOR garadColor[] = { <br>        {DLG_OPTIONS_RADIO_DESKCOL, COLOR_BACKGROUND}, <br>        {DLG_OPTIONS_RADIO_WINCOL,  COLOR_WINDOW}, <br>        {0, 0} <br>}; <br> <br>#if DLG_OPTIONS_RADIO_DESKCOL == 0 || DLG_OPTIONS_RADIO_WINCOL == 0 <br>#   error("Dialog IDs must not equal zero!") <br>#endif <br> <br> <br>/* <br> * Registry Strings <br> * (Since the registry is not localized, these don't have to be read in <br> *  from the strings RC) <br> */ <br>TCHAR gszAppKey[] = "Software\\Microsoft\\AniEdit"; <br>TCHAR gszKeyCurEditor[] = "Editor"; <br>TCHAR gszKeyPrevColor[] = "Preview Color"; <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: ParseCmdLine <br>* <br>*     PURPOSE: Returns a pointer to the first arg of the command line <br>* <br>* History: <br>*   31-May-1995 JonPa   Created it <br>* <br>\****************************************************************************/ <br>TCHAR gszParseToken[MAX_PATH]; <br> <br>LPTSTR ParseCmdLine( int iToken ) { <br>    LPTSTR szFile; <br>    LPTSTR szCmdLine; <br>    BOOL fSkipBlank; <br>    BOOL fInQuote; <br> <br>    fSkipBlank = TRUE;      // skip leading blanks <br>    fInQuote = FALSE; <br>    szFile = gszParseToken; <br>    iToken++; <br> <br>    for(szCmdLine = GetCommandLine(); *szCmdLine != TEXT('\0') &amp;&amp; iToken != 0; <br>            szCmdLine++ ) { <br> <br>        switch (*szCmdLine) { <br>        case TEXT('"'): <br>            fInQuote = !fInQuote; <br>            break; <br> <br>        case TEXT(' '): <br>        case TEXT('\t'): <br>            if (fInQuote) { <br>                *szFile++ = *szCmdLine; <br>            } else if (!fSkipBlank) { <br>                iToken--; <br>                *szFile++ = TEXT('\0'); <br>                szFile = gszParseToken; <br>                fSkipBlank = TRUE; <br>            } <br>            break; <br> <br>        default: <br>            *szFile++ = *szCmdLine; <br>            fSkipBlank = FALSE; <br>            break; <br> <br>        } <br>    } <br> <br>    if (*szCmdLine == TEXT('\0') &amp;&amp; !fSkipBlank ) { <br>        iToken--; <br>        *szFile++ = TEXT('\0'); <br>    } <br> <br>    if (iToken == 0 ) <br>        return gszParseToken; <br>    else <br>        return NULL; <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br>* <br>*     PURPOSE: calls initialization function, processes message loop <br>* <br>*     COMMENTS: <br>* <br>*         Windows recognizes this function by name as the initial entry point <br>*         for the program.  This function calls the application initialization <br>*         routine, if no other instance of the program is running, and always <br>*         calls the instance initialization routine.  It then executes a message <br>*         retrieval and dispatch loop that is the top-level control structure <br>*         for the remainder of execution.  The loop is terminated when a WM_QUIT <br>*         message is received, at which time this function exits the application <br>*         instance by returning the value passed by PostQuitMessage(). <br>* <br>*         If this function must abort before entering the message loop, it <br>*         returns the conventional value NULL. <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br> <br>    MSG msg;                                 /* message                      */ <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>    if (!hPrevInstance)                  /* Other instances of app running? */ <br>        if (!InitApplication(hInstance)) /* Initialize shared things        */ <br>            return (FALSE);              /* Exits if unable to initialize   */ <br> <br>    /* Perform initializations that apply to a specific instance */ <br>    if (!InitInstance(hInstance, nCmdShow)) <br>        return (FALSE); <br> <br>    ghIcon = LoadIcon(hInstance, MAKEINTRESOURCE(ANI_ICON)); <br> <br>    {   HACCEL hAccel; <br>        HWND hwndDlg; <br>        MSG msg; <br> <br>        hAccel = LoadAccelerators(hInstance, "AniEditMenu"); <br> <br>        hwndDlg = CreateDialogParam( hInstance, MAKEINTRESOURCE(DLG_MAIN), GetDesktopWindow(), <br>            MainWndProc, (LPARAM)ParseCmdLine(1) ); <br> <br>        while (GetMessage(&amp;msg, NULL, 0L, 0L)) <br>        { <br>            if (!TranslateAccelerator(hwndDlg, hAccel, &amp;msg)) <br>            { <br>                if (!IsDialogMessage(hwndDlg, &amp;msg)) <br>                { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>            } <br>        } <br>    } <br> <br>    /* Write user profile */ <br>    WriteRegistry(); <br> <br>    //BUGBUG - unregister preview class <br> <br>    if (gszModPath[0] != TEXT('\0')) { <br>        RemoveFontResource(gszModPath); <br>        PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0); <br>    } <br> <br> <br>    DeleteObject(ghbrPrevBackgnd); <br> <br>    /* Return the value from PostQuitMessage */ <br>    return (msg.wParam); <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: InitApplication(HANDLE) <br>* <br>*     PURPOSE: Initializes window data and registers window class <br>* <br>*     COMMENTS: <br>* <br>*         This function is called at initialization time only if no other <br>*         instances of the application are running.  This function performs <br>*         initialization tasks that can be done once for any number of running <br>*         instances. <br>* <br>*         In this case, we initialize a window class by filling out a data <br>*         structure of type WNDCLASS and calling the Windows RegisterClass() <br>*         function.  Since all instances of this application use the same window <br>*         class, we only need to do this when the first instance is initialized. <br>* <br>* <br>\****************************************************************************/ <br> <br>BOOL InitApplication(HANDLE hInstance)       /* current instance             */ <br>{ <br>    WNDCLASS cls; <br> <br>    /* <br>     * Register a new window class to handle the cursor preview. <br>     */ <br>    cls.style = 0; <br>    cls.lpfnWndProc = PreviewWndProc; <br>    cls.cbClsExtra = 0; <br>    cls.cbWndExtra = 0; <br>    cls.hInstance = hInstance; <br>    cls.hIcon = NULL; <br>    cls.hCursor = NULL; <br>    cls.hbrBackground = NULL; <br>    cls.lpszMenuName = NULL; <br>    cls.lpszClassName = szPREVIEW; <br>    RegisterClass(&amp;cls); <br> <br>    AniAddFontModule(hInstance); <br> <br>    return TRUE; <br>} <br> <br> <br>void AniAddFontModule(HINSTANCE hInst) { <br> <br> <br>    if (GetModuleFileName(hInst, gszModPath, MAX_PATH)) <br>        AddFontResource(gszModPath); <br>    else <br>        gszModPath[0] = TEXT('\0'); <br>} <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION:  InitInstance(HANDLE, int) <br>* <br>*     PURPOSE:  Saves instance handle and creates main window <br>* <br>*     COMMENTS: <br>* <br>*         This function is called at initialization time for every instance of <br>*         this application.  This function performs initialization tasks that <br>*         cannot be shared by multiple instances. <br>* <br>*         In this case, we save the instance handle in a static variable and <br>*         create and display the main program window. <br>* <br>\****************************************************************************/ <br> <br>BOOL InitInstance( <br>    HANDLE          hInstance, <br>    int             nCmdShow) <br>{ <br> <br>    /* Save the instance handle in static variable, which will be used in  */ <br>    /* many subsequence calls from this application to Windows.            */ <br> <br>    hInst = hInstance; <br> <br>    gcyCursor = GetSystemMetrics(SM_CYCURSOR); <br>    gcxCursor = GetSystemMetrics(SM_CXCURSOR); <br> <br>#ifdef DBCS <br>    /* Load resource strings */ <br>    if (!LoadResourceStr()) <br>        return FALSE; <br>#endif <br> <br>    /* Load user profile */ <br>    ReadRegistry(); <br> <br>#if 0 <br>    /* Load the accel table */ <br>    if (!(haccel = LoadAccelerators(hInstance, "AniEditAccel"))) <br>        return FALSE; <br>#endif <br> <br>    return (TRUE);               /* Returns the value from PostQuitMessage */ <br> <br>} <br> <br>/* Copied from winfile: <br> */ <br>INT  APIENTRY GetHeightFromPoints( int pts) <br>{ <br>    HDC hdc; <br>    INT height; <br> <br>    hdc = GetDC (NULL); <br>    height = MulDiv(-pts, GetDeviceCaps (hdc, LOGPIXELSY), 72); <br>    ReleaseDC (NULL, hdc); <br> <br>    return height; <br>} <br> <br> <br> <br>/**************************************************************************** <br>* <br>*     FUNCTION: MainWndProc(HWND, unsigned, WORD, LONG) <br>* <br>*     PURPOSE:  Processes messages <br>* <br>*     MESSAGES: <br>* <br>*         WM_COMMAND    - application menu (About dialog box) <br>*         WM_DESTROY    - destroy window <br>* <br>*     COMMENTS: <br>* <br>*         To process the IDM_ABOUT message, call MakeProcInstance() to get the <br>*         current instance address of the About() function.  Then call Dialog <br>*         box which will create the box according to the information in your <br>*         aniedit.rc file and turn control over to the About() function.  When <br>*         it returns, free the intance address. <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br> <br>BOOL APIENTRY MainWndProc( <br>        HWND hWnd,                /* window handle                   */ <br>        UINT message,             /* type of message                 */ <br>        UINT wParam,              /* additional information          */ <br>        LONG lParam)              /* additional information          */ <br>{ <br>    static HWND     hwndChildApp = NULL; <br>    static HBRUSH   hbrBtnBar; <br>    static HFONT    hfontButton; <br> <br>    switch (message) { <br>    case WM_INITDIALOG: <br>        ghwndMain = hWnd; <br> <br>        gcrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT); <br>        ghbrHighlight = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)); <br>        ghbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        hbrBtnBar = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br> <br>        hfontButton = CreateFont (GetHeightFromPoints(8), 0, 0, 0, 400, <br>                                0, 0, 0, ANSI_CHARSET, OUT_DEFAULT_PRECIS, <br>                                CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, <br>                                DEFAULT_PITCH | FF_SWISS, <br>                                TEXT("AniEdit Button")); <br> <br>        SendDlgItemMessage (hWnd, DLG_MAIN_BTNNEW, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>        SendDlgItemMessage (hWnd, DLG_MAIN_BTNOPEN, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>        SendDlgItemMessage (hWnd, DLG_MAIN_BTNSAVE, WM_SETFONT, (WPARAM)hfontButton, 0L); <br> <br>        SendDlgItemMessage (hWnd, DLG_MAIN_BTNCUT, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>        SendDlgItemMessage (hWnd, DLG_MAIN_BTNCOPY, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>        SendDlgItemMessage (hWnd, DLG_MAIN_BTNPASTE, WM_SETFONT, (WPARAM)hfontButton, 0L); <br> <br>        SendDlgItemMessage (hWnd, DLG_MAIN_DELFRAME, WM_SETFONT, (WPARAM)hfontButton, 0L); <br> <br>        SendDlgItemMessage (hWnd, DLG_MAIN_ADDFRAME, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>        SendDlgItemMessage (hWnd, DLG_MAIN_EDITFRAME, WM_SETFONT, (WPARAM)hfontButton, 0L); <br> <br>        SendDlgItemMessage (hWnd, DLG_MAIN_PLAY, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>        SendDlgItemMessage (hWnd, DLG_MAIN_STOP, WM_SETFONT, (WPARAM)hfontButton, 0L); <br> <br>#ifndef DBCS <br>        // ANIBTN.FNT file has been changed. This font doesn't include <br>        // capital letters. So we shouldn't set the font to this control. <br>        SendDlgItemMessage (hWnd, DLG_MAIN_FRAMETXT, WM_SETFONT, (WPARAM)hfontButton, 0L); <br>#endif <br> <br> <br> <br>        GetWindowText(hWnd, gszWindowTitle, COUNTOF(gszWindowTitle)); <br> <br>        /* cache scroll bar window handle */ <br>        ghwndRateScroll = GetDlgItem(hWnd, DLG_MAIN_RATESPIN); <br> <br>        /* limit title and author string lengths */ <br> <br>        SendDlgItemMessage(hWnd, DLG_MAIN_TITLE, EM_LIMITTEXT, <br>                COUNTOF(ganiAcon.azTitle), 0); <br> <br>        SendDlgItemMessage(hWnd, DLG_MAIN_AUTHOR, EM_LIMITTEXT, <br>                COUNTOF(ganiAcon.azCreator), 0); <br> <br>        NewAniCursor(hWnd); <br> <br>        if (lParam != (LPARAM)NULL) { <br>            HANDLE hf; <br>            LPTSTR pszFileName = (LPTSTR)lParam; <br> <br>            hf = CreateFile(pszFileName, GENERIC_READ, <br>                    0, NULL, <br>                    OPEN_EXISTING, <br>                    FILE_ATTRIBUTE_NORMAL, <br>                    NULL); <br> <br>            if (hf == INVALID_HANDLE_VALUE) { <br>                // User may have left the file type off, add it on, and try <br>                // again. <br>                // <br>                // HACK ALERT!  -- This code assumes that pszFileName points <br>                // to a buffer that is MAX_PATH in length. <br>                // <br>                int cchName; <br>                cchName = lstrlen( pszFileName ); <br>                if (cchName + 4 &lt; MAX_PATH) { <br>                    lstrcat( pszFileName, TEXT(".Ani") ); <br> <br>                    hf = CreateFile(pszFileName, GENERIC_READ, <br>                            0, NULL, <br>                            OPEN_EXISTING, <br>                            FILE_ATTRIBUTE_NORMAL, <br>                            NULL); <br> <br>                    if (hf == INVALID_HANDLE_VALUE) { <br>                        FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                            TRUE, MSG_CANTOPENFILE, pszFileName ); <br>                        return (TRUE); <br>                    } <br>                } <br>            } <br> <br>            LoadAniFile(hWnd, hf, pszFileName, pszFileName); <br>        } <br>        return (TRUE); <br> <br>    case WM_COMMAND:           /* message: command from application menu */ <br>        return DoCommand( hWnd, wParam, lParam ); <br> <br> <br>    case AIM_SETCHILDAPP: <br>        /* <br>         * A child app has just been started.  Remeber its hwnd and defer <br>         * all activation to it. <br>         */ <br>        DPRINT(("MT:Child HWND = 0x%lx\n", lParam)); <br>        hwndChildApp = (HWND)lParam; <br> <br>        if (hwndChildApp == NULL) <br>            EnableWindow(hWnd, FALSE); <br> <br>        break; <br> <br>    case AIM_PROCESSTERM: <br>        /* <br>         * The copy of ImagEdit that we spanwed off has just ended. <br>         * Time to read in the cursor file and put it back into the list. <br>         */ <br> <br>        /* "enable" our window */ <br>        DPRINT(("MT:got AIM_PROCESSTERM\n")); <br> <br>        hwndChildApp = NULL; <br> <br>        EnableWindow(hWnd, TRUE); <br> <br>        SetForegroundWindow(hWnd); <br> <br>        /* call CreateFrameFromCursorFile to reload the modified cursor */ <br>        if(CreateFrameFromCursorFile(hWnd, gszTempFile,  gfEditFrame)) <br>            DeleteFile(gszTempFile); <br> <br>        break; <br> <br>    case WM_ACTIVATE: <br>        /* <br>         * Convert WM_ACTIVATE to WM_NCACTIVATE <br>         */ <br>        switch (LOWORD(wParam)) { <br> <br>        case WA_CLICKACTIVE: <br>            /* <br>             * Simulate disabled window's beep <br>             */ <br>            if (IsWindow( hwndChildApp )) <br>                MessageBeep(MB_OK); <br> <br>            wParam = TRUE; <br>            break; <br> <br>        case WA_ACTIVE: <br>            wParam = TRUE; <br>            break; <br> <br>        default: <br>            wParam = FALSE; <br>            break; <br>        } <br> <br>        FALLTHRU(WM_NCACTIVATE); <br> <br>    case WM_NCACTIVATE: <br>    case WM_ACTIVATEAPP: <br>        DPRINT(("MT:got Activate (%04x) %c %08x\n", message, wParam ? 'T' : 'F', lParam)); <br> <br>        if (wParam == TRUE &amp;&amp; IsWindow( hwndChildApp )) { <br>            /* <br>             * We have a 'modal' child app upp, defer the activation to it. <br>             */ <br>            DPRINT(("MT:Defering Now\n")); <br>            return SetForegroundWindow(hwndChildApp); <br>        } <br> <br>        /* <br>         * Let DefWndProc process this message <br>         */ <br>        return FALSE; <br> <br>    case WM_MEASUREITEM: <br>        ((MEASUREITEMSTRUCT *)lParam)-&gt;itemHeight = gcyCursor + 2; <br>        break; <br> <br>    case WM_DRAWITEM: <br>        DrawCursorListItem((DRAWITEMSTRUCT *)lParam); <br>        break; <br> <br> <br>    case WM_DELETEITEM: { <br>        PSTEP ps; <br> <br>        if (wParam != DLG_MAIN_FRAMELIST) <br>            return FALSE; <br> <br>        ps = (PSTEP)((LPDELETEITEMSTRUCT)lParam)-&gt;itemData; <br> <br>        if (IsValidPS(ps)) { <br>            DestroyStep(ps); <br>        } <br>        break; <br>    } <br> <br> <br>    case WM_VSCROLL: <br>        if( (HWND)lParam == ghwndRateScroll ) { <br>            LONG iDelta; <br> <br>            switch( LOWORD(wParam) ) { <br>            case SB_LINEUP: <br>            case SB_PAGEUP: <br>                iDelta = 1; <br>                break; <br> <br>            case SB_LINEDOWN: <br>            case SB_PAGEDOWN: <br>                iDelta = -1; <br>                break; <br> <br>            default: <br>                iDelta = 0; <br>            } <br> <br>            if (iDelta != 0) { <br>                BOOL fOK; <br>                JIF jifRate = GetDlgItemInt(hWnd, DLG_MAIN_RATE, &amp;fOK, FALSE); <br> <br>                if( fOK ) { <br>                    if ((jifRate += iDelta) != 0) { <br>                        int *piSel, cSel; <br> <br>                        SetDlgItemInt(hWnd, DLG_MAIN_RATE, jifRate, FALSE); <br> <br>                        cSel = GetSelStepCount(hWnd); <br> <br>                        if (cSel &gt; 0 &amp;&amp; (piSel = AllocMem(cSel * sizeof(int))) != <br>                                NULL) { <br>                            int i; <br> <br>                            ganiAcon.fDirty = TRUE; <br>                            GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, piSel, cSel, <br>                                    &amp;cSel); <br> <br>                            for( i = 0; i &lt; cSel; i++ ) { <br>                                PSTEP ps = GetStep(hWnd, piSel[i]); <br>                                if (IsValidPS(ps)) { <br>                                    ps-&gt;jif = jifRate; <br>                                } <br>                            } <br> <br>                            InvalidateRect(GetDlgItem(hWnd, DLG_MAIN_FRAMELIST), <br>                                    NULL, TRUE); <br>                            FreeMem(piSel); <br>                        } <br>                    } <br>                } else { <br>                    int *piSel, cSel, i; <br>                    JIF jifMin, jifTmp; <br> <br>                    cSel = GetSelStepCount(hWnd); <br> <br>                    if (cSel &gt; 0 &amp;&amp; (piSel = AllocMem(cSel * sizeof(int))) != <br>                            NULL) { <br> <br>                        ganiAcon.fDirty = TRUE; <br>                        GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, piSel, cSel, <br>                                &amp;cSel); <br> <br>                        jifMin = MAXLONG; <br> <br>                        for( i = 0; i &lt; cSel; i++ ) { <br>                            PSTEP ps = GetStep(hWnd, piSel[i]); <br>                            if (IsValidPS(ps)) { <br>                                jifMin = min(jifMin, ps-&gt;jif); <br>                            } <br>                        } <br> <br>                        for( i = 0; i &lt; cSel; i++ ) { <br>                            PSTEP ps = GetStep(hWnd, piSel[i]); <br>                            if (IsValidPS(ps)) { <br> <br>                                jifTmp = ps-&gt;jif; <br> <br>                                if (iDelta == 1) { <br>                                    ps-&gt;jif += (ps-&gt;jif / jifMin); <br>                                } else { <br>                                    ps-&gt;jif -= (ps-&gt;jif / jifMin); <br>                                } <br> <br>                                /* check for over/under-flow */ <br>                                if (ps-&gt;jif == 0) { <br>                                    ps-&gt;jif = jifTmp; <br>                                } <br>                            } <br>                        } <br> <br>                        InvalidateRect(GetDlgItem(hWnd, DLG_MAIN_FRAMELIST), <br>                                NULL, TRUE); <br>                        FreeMem(piSel); <br>                    } <br>                } <br>            } <br>        } <br>        break; <br> <br>    case WM_SYSCOMMAND: <br>        if (wParam == SC_CLOSE) { <br>            ExitCommand(hWnd); <br>        } else { <br>            return FALSE; <br>        } <br> <br>        break; <br> <br>    case WM_SYSCOLORCHANGE: <br>        DeleteObject(ghbrPrevBackgnd); <br>        DeleteObject(ghbrWindow); <br>        DeleteObject(ghbrHighlight); <br>        DeleteObject(hbrBtnBar); <br> <br>        ghbrHighlight = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)); <br>        gcrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT); <br>        ghbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        ghbrPrevBackgnd = CreateSolidBrush(GetSysColor( <br>                garadColor[giradColor].idSys)); <br> <br>        hbrBtnBar = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>        break; <br> <br>    case WM_ERASEBKGND: <br>        if (IsIconic(hWnd)) { <br>            RECT rc; <br>            HBRUSH hbr =  CreateSolidBrush(GetSysColor(COLOR_BACKGROUND)); <br> <br>            GetClientRect(hWnd, &amp;rc); <br>            FillRect((HDC)wParam, &amp;rc, hbr); <br>            DeleteObject(hbr); <br>            break; <br> <br>        } else { <br>            RECT rc; <br>            // Fix this to use a real tool bar <br>            HBRUSH hbr =  CreateSolidBrush(GetSysColor(COLOR_3DFACE)); <br> <br>            GetClientRect(hWnd, &amp;rc); <br>            FillRect((HDC)wParam, &amp;rc, hbr); <br>            DeleteObject(hbr); <br> <br>            GetWindowRect(GetDlgItem(hWnd, DLG_MAIN_BTNBAR), &amp;rc); <br>            ScreenToClient(hWnd, (LPPOINT)&amp;(rc.left)); <br>            ScreenToClient(hWnd, (LPPOINT)&amp;(rc.right)); <br>            FillRect((HDC)wParam, &amp;rc, hbrBtnBar); <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        if (IsIconic(hWnd)) { <br>            HDC hdc; <br>            PAINTSTRUCT ps; <br> <br>            hdc = BeginPaint(hWnd, &amp;ps); <br>            DrawIcon(hdc, 0, 0, ghIcon); <br> <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br>        } else <br>            return FALSE; <br> <br> <br>    case WM_DESTROY: <br>#ifdef DBCS <br>        GlobalFree(gpszAniFilter); <br>        GlobalFree(gpszCurFilter); <br>        GlobalFree(gpszUnknownError); <br>        GlobalFree(gpszUntitled); <br>        GlobalFree(gpszImport); <br>#endif <br>        DeleteObject(ghbrPrevBackgnd); <br>        DeleteObject(ghbrWindow); <br>        DeleteObject(ghbrHighlight); <br>        DeleteObject(hbrBtnBar); <br>        DeleteObject(hfontButton ); <br>        PostQuitMessage(0); <br>        return FALSE; <br> <br>#if 0 <br>    case WM_CHAR: <br>        switch( (TCHAR)wParam ) { <br>        case CTRL_X: <br>            PostMessage(hWnd, WM_COMMAND, MENU_EDIT_CUT, 0L); <br>            break; <br> <br>        case CTRL_C: <br>            PostMessage(hWnd, WM_COMMAND, MENU_EDIT_COPY, 0L); <br>            break; <br> <br>        case CTRL_V: <br>            PostMessage(hWnd, WM_COMMAND, MENU_EDIT_PASTE, 0L); <br>            break; <br>        } <br> <br>        // fall through to DefDlgProc <br>#endif <br> <br>    default: <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************\ <br>* <br>* DrawCursorListItem <br>* <br>* <br>* History: <br>* 22-Dec-1991 DarrinM       Created in the Cursors cpa. <br>* 22-Apr-1993 JonPa         copied into this app and tweeked it. <br>\***************************************************************************/ <br> <br>void DrawCursorListItem( <br>    DRAWITEMSTRUCT *pdis) <br>{ <br>    COLORREF crPrev; <br>    static LONG cxAvgChar = 0; <br>    TEXTMETRIC tm; <br>    PSTEP ps; <br>    TCHAR szJif[CCH_JIF]; <br> <br> <br>    /* <br>     * If item == -1 and we are getting the focus, then draw an empty <br>     * focus rect. <br>     */ <br>    if (pdis-&gt;itemAction == ODA_FOCUS &amp;&amp; pdis-&gt;itemID == (UINT)-1) { <br>        FillRect(pdis-&gt;hDC, &amp;pdis-&gt;rcItem, ghbrWindow); <br>        if (pdis-&gt;itemState &amp; ODS_FOCUS) { <br>            RECT rc; <br> <br>            CopyRect( &amp;rc, &amp;pdis-&gt;rcItem ); <br>            InflateRect( &amp;rc, -2, -2 ); <br>            DrawFocusRect(pdis-&gt;hDC, &amp;rc); <br>        } <br>        return; <br>    } <br> <br> <br> <br>    /* find the average char width for this listbox and cache it */ <br>    if (cxAvgChar == 0) { <br>        if (GetTextMetrics( pdis-&gt;hDC, &amp;tm)) { <br>            cxAvgChar = tm.tmAveCharWidth; <br>        } <br>    } <br> <br>    if (!(ps = (PSTEP)(pdis-&gt;itemData))) <br>        return; <br> <br>    SetBkMode(pdis-&gt;hDC, TRANSPARENT); <br> <br>    if (pdis-&gt;itemState &amp; ODS_SELECTED) { <br>        FillRect(pdis-&gt;hDC, &amp;pdis-&gt;rcItem, ghbrHighlight); <br>        crPrev = SetTextColor(pdis-&gt;hDC, gcrHighlightText); <br>    } else { <br>        FillRect(pdis-&gt;hDC, &amp;pdis-&gt;rcItem, ghbrWindow); <br>    } <br> <br> <br>    /* Draw the frame */ <br>    DrawIcon(pdis-&gt;hDC, pdis-&gt;rcItem.left + 2, pdis-&gt;rcItem.top + 1, <br>            ps-&gt;pfrmFrame-&gt;hcur); <br> <br> <br>    pdis-&gt;rcItem.left += gcxCursor + 2 + ((cxAvgChar != 0) ? cxAvgChar : 8); <br> <br> <br>    /* write the rate text */ <br>    wsprintf( szJif, "%d", (int)ps-&gt;jif ); <br> <br>    DrawText(pdis-&gt;hDC, szJif, strlen(szJif), &amp;pdis-&gt;rcItem, <br>            DT_SINGLELINE | DT_LEFT | DT_VCENTER); <br> <br>    if (pdis-&gt;itemState &amp; ODS_SELECTED) { <br>        SetTextColor(pdis-&gt;hDC, crPrev); <br>    } <br> <br>    if (pdis-&gt;itemState &amp; ODS_FOCUS) { <br>        RECT rc; <br> <br>        CopyRect( &amp;rc, &amp;pdis-&gt;rcItem ); <br>        InflateRect( &amp;rc, -1, -2 ); <br>        OffsetRect( &amp;rc, -1, 0 ); <br>        DrawFocusRect(pdis-&gt;hDC, &amp;rc); <br>    } <br>} <br> <br> <br> <br> <br> <br>/***************************************************************************\ <br>* <br>*     FUNCTION: FmtMessageBox( HWND hwnd, DWORD dwTitleID, UINT fuStyle, <br>*                   BOOL fSound, DWORD dwTextID, ... ); <br>* <br>*     PURPOSE:  Formats messages with FormatMessage and then displays them <br>*               in a message box <br>* <br>* <br>* <br>* <br>* History: <br>* 22-Apr-1993 JonPa         Created it. <br>\***************************************************************************/ <br>int FmtMessageBox( HWND hwnd, DWORD dwTitleID, LPTSTR pszTitleStr, <br>    UINT fuStyle, BOOL fSound, DWORD dwTextID, ... ) { <br>    LPTSTR pszMsg; <br>    LPTSTR pszTitle; <br>    int idRet; <br> <br>    va_list marker; <br> <br>    va_start( marker, dwTextID ); <br> <br>    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, hInst, <br>            dwTextID, 0, (LPTSTR)&amp;pszMsg, 1, &amp;marker)) <br>        pszMsg = gpszUnknownError; <br> <br>    va_end( marker ); <br> <br>    GetLastError(); <br> <br>    pszTitle = NULL; <br> <br>    if (dwTitleID == (DWORD)-1 || <br>            FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK | <br>                FORMAT_MESSAGE_ARGUMENT_ARRAY, <br>                hInst, dwTitleID, 0, (LPTSTR)&amp;pszTitle, 1, (va_list *)(DWORD)&amp;pszTitleStr)) { <br>    } <br> <br>    GetLastError(); <br> <br>    if (fSound) { <br>        MessageBeep( fuStyle &amp; (MB_ICONASTERISK | MB_ICONEXCLAMATION | <br>                MB_ICONHAND | MB_ICONQUESTION | MB_OK) ); <br>    } <br> <br>    idRet = MessageBox(hwnd, pszMsg, pszTitle, fuStyle); <br> <br>    if (pszTitle != NULL) <br>        LocalFree( pszTitle ); <br> <br>    if (pszMsg != gpszUnknownError) <br>        LocalFree( pszMsg ); <br> <br>    return idRet; <br>} <br> <br>/***************************************************************************\ <br>* <br>*     FUNCTION: FmtSprintf( DWORD id, ... ); <br>* <br>*     PURPOSE:  sprintf but it gets the pattern string from the message rc. <br>* <br>* History: <br>* 03-May-1993 JonPa         Created it. <br>\***************************************************************************/ <br>LPTSTR FmtSprintf( DWORD id, ... ) { <br>    LPTSTR pszMsg; <br>    va_list marker; <br> <br>    va_start( marker, id ); <br> <br>    if(!FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK, hInst, <br>            id, 0, (LPTSTR)&amp;pszMsg, 1, &amp;marker)) { <br>        GetLastError(); <br>        pszMsg = gszDots; <br>    } <br>    va_end( marker ); <br> <br>    return pszMsg; <br>} <br> <br>/***************************************************************************\ <br>* <br>*     FUNCTION: PVOID AllocMem( DWORD cb ); <br>* <br>*     PURPOSE:  allocates memory, checking for errors <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Wrote it. <br>\***************************************************************************/ <br>PVOID AllocMem( DWORD cb ) { <br>    PVOID pv = (PVOID)LocalAlloc(LPTR, cb); <br> <br>    if (pv == NULL) { <br>        FmtMessageBox( ghwndMain, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                TRUE, MSG_OUTOFMEM ); <br>    } <br> <br>    return pv; <br>} <br> <br> <br>/***************************************************************************\ <br>* PreviewWndProc <br>* <br>* <br>* History: <br>* 08-07-92 DarrinM      Created in CURSORS.CPL. <br>* 24-Apr-1993 JonPa     Copied here and tweeked. <br>\***************************************************************************/ </code></pre>
<p>
</p>
<pre><code><br>LRESULT CALLBACK <br>PreviewWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    HDC hdc; <br>    RECT rc; <br>    PAINTSTRUCT ps; <br>    PPREVIEWDATA ppd; <br>    static int cxBM, cyBM; <br>    static int cxCenter, cyCenter; <br> <br>    switch (msg) { <br>    case WM_CREATE: <br>        if (!(ppd = (PPREVIEWDATA)LocalAlloc(LPTR, sizeof(PREVIEWDATA)))) <br>            return -1; <br> <br>        SetWindowLong(hwnd, GWL_USERDATA, (LONG)ppd); <br> <br>        /* <br>         * Create a temp DC and bitmap to be used for buffering the <br>         * preview rendering. <br>         */ <br>        cxCenter = gcxCursor; <br>        cyCenter = gcyCursor; <br> <br>        cxBM = cxCenter * 2; <br>        cyBM = cyCenter * 2; <br> <br>        hdc = GetDC(hwnd); <br>        ppd-&gt;hdcMem = CreateCompatibleDC(hdc); <br>        ppd-&gt;hbmMem = CreateCompatibleBitmap(hdc, cxBM, cyBM); <br>        ppd-&gt;hbmOld = SelectObject(ppd-&gt;hdcMem, ppd-&gt;hbmMem); <br>        ppd-&gt;iFrame = 0; <br>        ppd-&gt;hcur = NULL; <br>        ppd-&gt;xHot = ppd-&gt;yHot = 0; <br>        ReleaseDC(hwnd, hdc); <br>        break; <br> <br>    case WM_SIZE: <br>        ppd = (PPREVIEWDATA)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>        SelectObject(ppd-&gt;hdcMem, ppd-&gt;hbmOld); <br>        DeleteObject(ppd-&gt;hbmMem); <br> <br>        cxBM = LOWORD(lParam); <br>        cyBM = HIWORD(lParam); <br>        cxCenter = cxBM / 2; <br>        cyCenter = cyBM / 2; <br> <br>        hdc = GetDC(hwnd); <br>        ppd-&gt;hbmMem = CreateCompatibleBitmap(hdc, cxBM, cyBM); <br>        ppd-&gt;hbmOld = SelectObject(ppd-&gt;hdcMem, ppd-&gt;hbmMem); <br>        ReleaseDC(hwnd, hdc); <br>        break; <br> <br>    case WM_DESTROY: <br>        ppd = (PPREVIEWDATA)GetWindowLong(hwnd, GWL_USERDATA); <br>        SelectObject(ppd-&gt;hdcMem, ppd-&gt;hbmOld); <br>        DeleteObject(ppd-&gt;hbmMem); <br>        DeleteDC(ppd-&gt;hdcMem); <br>        LocalFree(ppd); <br>        break; <br> <br>    case PM_PAUSEANIMATION: <br>        KillTimer(hwnd, ID_PREVIEWTIMER); <br>        break; <br> <br>    case PM_UNPAUSEANIMATION: <br>        NextFrame(hwnd, TRUE); <br>        break; <br> <br>    case PM_NEWCURSOR: <br>        wParam = 0; <br>        FALLTHRU(PM_SETSTEP); <br> <br>    case PM_SETSTEP: { <br>        BOOL fRun = KillTimer(hwnd, ID_PREVIEWTIMER); <br> <br>        ppd = (PPREVIEWDATA)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>        ppd-&gt;iFrame = wParam; <br> <br>        NextFrame(hwnd, fRun); <br>        InvalidateRect(hwnd, NULL, FALSE); <br>        break; <br>    } <br> <br>    case WM_TIMER: <br>        if (wParam != ID_PREVIEWTIMER) <br>            break; <br> <br>        NextFrame(hwnd, TRUE); <br>        break; <br> <br>    case WM_PAINT: <br>        BeginPaint(hwnd, &amp;ps); <br> <br>        ppd = (PPREVIEWDATA)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>        if (ppd-&gt;hcur != NULL) <br>        { <br>            rc.left = rc.top = 0; <br>            rc.right = cxBM; <br>            rc.bottom = cyBM; <br>            FillRect(ppd-&gt;hdcMem, &amp;rc, ghbrPrevBackgnd); <br> <br> <br>            DrawIcon(ppd-&gt;hdcMem, cxCenter - ppd-&gt;xHot, cyCenter - ppd-&gt;yHot, <br>                    ppd-&gt;hcur); <br> <br>            BitBlt(ps.hdc, 0, 0, cxBM, cyBM, ppd-&gt;hdcMem, 0, 0, SRCCOPY); <br>        } <br>        else <br>        { <br>            FillRect(ps.hdc, &amp;ps.rcPaint, ghbrPrevBackgnd); <br>        } <br> <br>        EndPaint(hwnd, &amp;ps); <br>        break; <br> <br>    case WM_ERASEBKGND: <br>        break; <br> <br>    default: <br>        return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} <br> <br>/*****************************************************************************\ <br>* NextFrame <br>* <br>* Sets up for the next frame in the preview window. <br>* <br>* Arguments: <br>*   HWND hwnd - Dialog window handle. <br>* <br>\*****************************************************************************/ <br> <br>VOID <br>NextFrame( <br>    HWND hwnd, BOOL fRun <br>    ) <br>{ <br>    PPREVIEWDATA ppd; <br>    HWND hwndLB; <br>    DWORD cFrame; <br>    PSTEP ps; <br> <br>    ppd = (PPREVIEWDATA)GetWindowLong(hwnd, GWL_USERDATA); <br> <br>    // <br>    // Be sure there is a cursor specified.  If not, or it is <br>    // not an animated cursor, we are done. <br>    // <br>    hwndLB = GetDlgItem(GetParent(hwnd), DLG_MAIN_FRAMELIST); <br>    cFrame = SendMessage(hwndLB, LB_GETCOUNT, 0, 0); <br>    if (cFrame == LB_ERR || cFrame == 0) { <br>        ppd-&gt;hcur = NULL; <br>        InvalidateRect(hwnd, NULL, FALSE); <br>        return; <br>    } <br> <br>    if (ppd-&gt;iFrame &gt;= cFrame) <br>        ppd-&gt;iFrame = 0; <br> <br>    /* <br>     * Find how long this frame should be displayed (i.e. get jifRate) <br>     */ <br>    ps = (PSTEP)SendMessage(hwndLB, LB_GETITEMDATA, ppd-&gt;iFrame, 0); <br> <br>    if (IsValidPS(ps)) { <br>        ppd-&gt;xHot = ps-&gt;pfrmFrame-&gt;xHotSpot; <br>        ppd-&gt;yHot = ps-&gt;pfrmFrame-&gt;yHotSpot; <br> <br>        ppd-&gt;hcur = ps-&gt;pfrmFrame-&gt;hcur; <br> <br>        if (fRun) <br>            SetTimer(hwnd, ID_PREVIEWTIMER, ps-&gt;jif * 16, NULL); <br> <br>        ppd-&gt;iFrame += 1; <br>    } else { <br>        ppd-&gt;hcur = NULL; <br>    } <br> <br>    /* <br>     * Redraw this frame of the cursor. <br>     */ <br>    InvalidateRect(hwnd, NULL, FALSE); <br>} <br> <br>/*****************************************************************************\ <br>* ReadRegistry <br>* <br>* Opens (creates if necessary) the registry key for preferences and then <br>* reads the last saved values. <br>* <br>*   03-Jul-1993 JonPa   Copied from Spy, but changed greatly <br>* <br>\*****************************************************************************/ <br> <br>VOID ReadRegistry( VOID ) { <br>    DWORD dw; <br>    DWORD cbData; <br>    HKEY hkey; <br> <br>    if (RegOpenKeyEx(HKEY_CURRENT_USER, gszAppKey, 0, KEY_QUERY_VALUE, &amp;hkey)){ <br> <br>        lstrcpy( gszCursorEditor, gpszImagEdit ); <br> <br>    } else { <br> <br>        cbData = sizeof(gszCursorEditor); <br>        if (RegQueryValueEx(hkey, gszKeyCurEditor, NULL, NULL, <br>            gszCursorEditor, &amp;cbData) != ERROR_SUCCESS) { <br> <br>            lstrcpy( gszCursorEditor, gpszImagEdit ); <br> <br>        } <br> <br>        cbData = sizeof(dw); <br>        if (RegQueryValueEx(hkey, gszKeyPrevColor, NULL, NULL, (LPBYTE)&amp;dw, <br>                &amp;cbData) == ERROR_SUCCESS) { <br> <br>            giradColor = (int)dw; <br>        } <br> <br>        RegCloseKey(hkey); <br>    } <br> <br>    ghbrPrevBackgnd = CreateSolidBrush(GetSysColor(garadColor[giradColor].idSys)); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* WriteRegistry <br>* <br>* Writes out preference data to the registry when the app exits, then <br>* closes the registry key. <br>* <br>*   03-Jul-1993 JonPa   Copied from Spy, but changed greatly <br>\*****************************************************************************/ <br> <br>VOID WriteRegistry( VOID ) { <br>    HKEY hkey; <br>    DWORD dw; <br> <br>    if (RegCreateKeyEx(HKEY_CURRENT_USER, gszAppKey, 0, NULL, <br>                REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &amp;hkey, &amp;dw)) <br>        return; <br> <br>    RegSetValueEx(hkey, gszKeyCurEditor, 0, REG_SZ, gszCursorEditor, <br>            lstrlen(gszCursorEditor)+1); <br> <br>    dw = giradColor; <br>    RegSetValueEx(hkey, gszKeyPrevColor, 0, REG_DWORD, (LPBYTE)&amp;dw, sizeof(dw)); <br> <br>    RegCloseKey(hkey); <br> <br>} <br> <br>#ifdef DBCS <br>/*****************************************************************************\ <br>* LoadResourceStr <br>* <br>* Load resource string. <br>* <br>\*****************************************************************************/ <br> <br>BOOL LoadResourceStr( VOID ) { <br>    static TCHAR lpszTmp[MAX_PATH]; <br>    static TCHAR lpszBuf[MAX_PATH]; <br>    UINT  wID; <br>    INT   nLen, nOffset; <br> <br>    /* Load Ani Filter */ <br>    for(wID = IDS_ANI_FILTER1, nOffset = 0; wID &lt;= IDS_ANI_FILTER4; wID++) { <br>        nLen = LoadString(hInst,wID,lpszTmp,sizeof(lpszTmp)); <br>        lstrcpy(&amp;lpszBuf[nOffset],lpszTmp); <br>        nOffset += nLen + 1; <br>    } <br>    nLen += nOffset + 1; <br>    if((gpszAniFilter = (LPTSTR)GlobalAlloc(GMEM_FIXED,nLen)) == NULL) <br>        return FALSE; <br>    CopyMemory(gpszAniFilter,lpszBuf,nLen); <br> <br>    /* Load Cur Filter */ <br>    for(wID = IDS_CUR_FILTER1, nOffset = 0; wID &lt;= IDS_CUR_FILTER6; wID++) { <br>        nLen = LoadString(hInst,wID,lpszTmp,sizeof(lpszTmp)); <br>        lstrcpy(&amp;lpszBuf[nOffset],lpszTmp); <br>        nOffset += nLen + 1; <br>    } <br>    nLen += nOffset + 1; <br>    if((gpszCurFilter = (LPTSTR)GlobalAlloc(GMEM_FIXED,nLen)) == NULL) <br>        return FALSE; <br>    CopyMemory(gpszCurFilter,lpszBuf,nLen); <br> <br>    /* Load Other strings */ <br>    nLen = LoadString(hInst,IDS_UNKNOWN_ERROR,lpszBuf,sizeof(lpszBuf)); <br>    if((gpszUnknownError = (LPTSTR)GlobalAlloc( <br>                        GMEM_FIXED,nLen+1)) == NULL) <br>        return FALSE; <br>    lstrcpy(gpszUnknownError,lpszBuf); <br>    nLen = LoadString(hInst,IDS_UNTITLED,lpszBuf,sizeof(lpszBuf)); <br>    if((gpszUntitled = (LPTSTR)GlobalAlloc( <br>                        GMEM_FIXED,nLen+1)) == NULL) <br>        return FALSE; <br>    lstrcpy(gpszUntitled,lpszBuf); <br>    nLen = LoadString(hInst,IDS_IMPORT,lpszBuf,sizeof(lpszBuf)); <br>    if((gpszImport = (LPTSTR)GlobalAlloc( <br>                        GMEM_FIXED,nLen+1)) == NULL) <br>        return FALSE; <br>    lstrcpy(gpszImport,lpszBuf); <br> <br>    return TRUE; <br>} <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
