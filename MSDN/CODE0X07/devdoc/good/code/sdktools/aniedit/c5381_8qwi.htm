<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ANICMD.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5382"></a>ANICMD.C</h2>
<pre><code>/****************************************************************************\ <br>* <br>*     MODULE: anicmd.c <br>* <br>*     PURPOSE: Processes WM_COMMANDs for the Animated Cursor Editor <br>* <br>*     Copyright 1993-1996 Microsoft Corp. <br>* <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Wrote it. <br>* <br>\****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;search.h&gt; <br>#include "anidefs.h" <br> <br>static DWORD WINAPI ProcWaitThread( LPVOID lpv ); <br>static BOOL CALLBACK ETWProc( HWND hwnd, LPARAM lParam ); <br> <br>BOOL gfEditFrame = FALSE; <br>TCHAR gszTempFile[MAX_PATH]; <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: void AniEndDialog( HDLG hdlg, int i ) <br>* <br>*     PURPOSE:  Destroys Modless Dialogs <br>* <br>* <br>* History: <br>*   08-Sep-1995 JonPa   Created it <br>* <br>\****************************************************************************/ <br>#define AniEndDialog( hdlg, i )         DestroyWindow( hdlg ) <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: void LoadAniFile(hWnd, hfCursor, szFileTitle, szFile) <br>* <br>*     PURPOSE:  Loads an ANI from the given handle, and sets up ganiAcon <br>* <br>* <br>* History: <br>*   31-May-1995 JonPa   Created it <br>* <br>\****************************************************************************/ <br>void LoadAniFile(HWND hWnd, HANDLE hfCursor, LPTSTR szFileTitle, LPTSTR szFile) <br>{ <br>    /* delete any existing ani file */ <br>    NewAniCursor( hWnd ); <br> <br>    /* read in the file */ <br>    if (!ReadAniFile( hWnd, hfCursor )) { <br>        FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, TRUE, <br>                MSG_INVALIDCURSORFILE, szFileTitle ); <br>    } else { <br>        /* <br>         * Put the filename in the title. <br>         */ <br>        lstrcpy(ganiAcon.szFile, szFile); <br>        SetWindowFileTitle(hWnd, szFileTitle); <br>        SetDlgItemInt( hWnd, DLG_MAIN_RATE, ganiAcon.anih.jifRate, FALSE); <br>    } <br> <br>    ResumePreview(hWnd, DLG_MAIN_PREVIEW); <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: DoCommand(HWND, unsigned, WORD, LONG) <br>* <br>*     PURPOSE:  Processes commands for the main dialog box <br>* <br>*     MESSAGES: <br>* <br>*         WM_INITDIALOG - initialize dialog box <br>*         WM_COMMAND    - Input received <br>* <br>*     COMMENTS: <br>* <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>BOOL DoCommand( HWND hWnd, UINT wParam, LONG lParam ) <br>{ <br>    int cmd = LOWORD(wParam); <br> <br>    switch(cmd){ <br> <br> <br>    case MENU_FILE_NEW: <br>    case DLG_MAIN_BTNNEW: <br>        /* If dirty, then prompt for save */ <br>        if(!CheckDirty(hWnd)) <br>            break; <br> <br>        /* free used memory and init structures and dlg */ <br>        NewAniCursor(hWnd); <br>        ResumePreview(hWnd, DLG_MAIN_PREVIEW); <br>        break; <br> <br>    case DLG_MAIN_BTNOPEN: <br>    case MENU_FILE_OPEN: { <br>        HANDLE hfCursor; <br>        TCHAR szFileTitle[MAX_PATH]; <br>        TCHAR szFile[MAX_PATH]; <br> <br> <br>        szFile[0] = TEXT('\0'); <br> <br>        /* check for dirty file */ <br>        if(!CheckDirty(hWnd)) <br>            break; <br> <br>        /* Put up the open file dialog and get the open handle back */ <br>        hfCursor = PromptAndOpenFile(hWnd, MAX_PATH, szFileTitle, <br>                 COUNTOF(ganiAcon.szFile), szFile, gpszAniFilter); <br> <br>        if (hfCursor == INVALID_HANDLE_VALUE) <br>            break; <br> <br>        LoadAniFile(hWnd, hfCursor, szFileTitle, szFile ); <br> <br>        break; <br>    } <br> <br>    case DLG_MAIN_BTNSAVE: <br>    case MENU_FILE_SAVE: <br>    case MENU_FILE_SAVEAS: <br>        SaveFile(hWnd, cmd == MENU_FILE_SAVEAS); <br>        break; <br> <br>    case MENU_FILE_INSERT: { <br>        TCHAR szFile[MAX_PATH]; <br> <br>        szFile[0] = TEXT('\0'); <br> <br>        /* Put up the open file dialog and get the open handle back */ <br>        if (PromptForFile(hWnd, 0, NULL, <br>                 MAX_PATH, szFile, gpszCurFilter, gpszImport, FALSE)) { <br> <br>            /* <br>             * If we got a file, open it and read the icon data, linking <br>             * it into the frame list and maintaining the steps as well. <br>             */ <br>            ganiAcon.fDirty = TRUE; <br>            CreateFrameFromCursorFile(hWnd, szFile, FALSE); <br>        } <br>        break; <br>    } <br> <br>    case MENU_FILE_EXPORT: { <br>#if 0 <br>        TCHAR szFile[MAX_PATH]; <br>        szFile[0] = TEXT('\0'); <br> <br>        /* Put up the open file dialog and get the open handle back */ <br>        if (PromptForFile(hWnd, 0, NULL, <br>                 MAX_PATH, szFile, NULL, gpszExport, TRUE)) { <br> <br>            /* <br>             * If we got a file, open it and read the icon data, linking <br>             * it into the frame list and maintaining the steps as well. <br>             */ <br>            ???? <br>        } <br>#else <br>        WRITEME(hWnd); <br>#endif <br>        break; <br>    } <br> <br>    case MENU_FILE_EXIT: <br>        ExitCommand(hWnd); <br>        break; <br> <br>    case DLG_MAIN_BTNCUT: <br>    case MENU_EDIT_CUT: <br>        ganiAcon.fDirty = TRUE; <br> <br>        FALLTHRU(MENU_EDIT_COPY); <br> <br>    case DLG_MAIN_BTNCOPY: <br>    case MENU_EDIT_COPY: { <br>        int *piSel; <br>        int cSel; <br> <br>        cSel = GetSelStepCount(hWnd); <br> <br>        if( cSel &gt; 0 &amp;&amp; (piSel = AllocMem(cSel * sizeof(int))) != NULL) { <br>            PCLPBRDDAT pcbd, pcbdNext, *ppcbd; <br> <br>            int i; <br> <br>            GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, piSel, cSel, &amp;cSel); <br> <br>            /* Clear clipboard */ <br>            for( pcbd = gpbdClipBoard; pcbd != NULL; pcbd = pcbdNext ) { <br>                pcbdNext = pcbd-&gt;pcbdNext; <br> <br>                DestroyClpBrdDat(pcbd); <br>            } <br> <br>            /* <br>             * Get the steps and put them in the clipboard in the correct order <br>             */ <br>            ppcbd = &amp;gpbdClipBoard; <br> <br>            for( i = 0; i &lt; cSel; i++ ) { <br>                PSTEP ps; <br> <br>                ps = GetStep(hWnd, piSel[i]); <br> <br>                if( IsValidPS(ps) &amp;&amp; (pcbd = NewClpBrdDat()) != NULL) { <br>                    CopyStep(&amp;(pcbd-&gt;stp), ps); <br>                    *ppcbd = pcbd; <br>                    ppcbd = &amp;(pcbd-&gt;pcbdNext); <br>                } <br>            } <br> <br>            *ppcbd = NULL; <br> <br>            /* <br>             * If this is a cut, then yank them out of the listbox <br>             */ <br>            if (cmd == MENU_EDIT_CUT || cmd == DLG_MAIN_BTNCUT) { <br>                qsort( piSel, cSel, sizeof(piSel[0]), RevCompInts ); <br>                for( i = 0; i &lt; cSel; i++ ) { <br>                    SendDlgItemMessage(hWnd, DLG_MAIN_FRAMELIST, <br>                            LB_DELETESTRING, piSel[i], 0); <br>                } <br> <br>                FreeMem(piSel); <br> <br>                ClearStepSel(hWnd); <br>            } <br>        } <br> <br>        break; <br>    } <br> <br>    case DLG_MAIN_BTNPASTE: <br>    case MENU_EDIT_PASTE: { <br>        PCLPBRDDAT pcbd; <br>        int iSel, cSel; <br> <br>        cSel = GetSelStepCount(hWnd); <br> <br>        if (cSel &gt; 1) { <br>            FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                    TRUE, MSG_LESSEQONEFRAME); <br>            break; <br>        } <br> <br>        GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, &amp;iSel, 1, &amp;cSel); <br> <br>        if (cSel == 0) <br>            iSel = GetStepCount(hWnd) - 1; <br> <br>        cSel = iSel; <br>        ganiAcon.fDirty = TRUE; <br> <br>        for( pcbd = gpbdClipBoard; pcbd != NULL; pcbd = pcbd-&gt;pcbdNext ) { <br>            PSTEP ps = NewStep(); <br> <br>            if (IsValidPS(ps)) { <br>                CopyStep(ps, &amp;(pcbd-&gt;stp)); <br> <br>                SendDlgItemMessage(hWnd, DLG_MAIN_FRAMELIST, LB_INSERTSTRING, <br>                    ++cSel, (LPARAM)ps); <br>            } else { <br>                FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OKCANCEL | <br>                        MB_ICONEXCLAMATION, TRUE, MSG_PASTEERR ); <br>            } <br>        } <br> <br>        /* in this case, cSel is actually an index */ <br>        iSel += 1; <br>        ClearStepSel(hWnd); <br>        SetStepSel(hWnd, iSel, cSel); <br> <br>        break; <br>    } <br> <br>    case DLG_MAIN_DELFRAME: <br>    case MENU_EDIT_CLEAR: { <br>        int *piSel; <br>        int cSteps = GetSelStepCount(hWnd); <br>        int i; <br> <br>        if (cSteps &lt;= 0) <br>            //BUGBUG - should we put a message box up here? <br>            break; <br> <br>        ganiAcon.fDirty = TRUE; <br> <br>        piSel = AllocMem(cSteps * sizeof(int)); <br>        if (piSel == NULL) <br>            break; <br> <br>        GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, piSel, cSteps, &amp;cSteps); <br> <br>        qsort( piSel, cSteps, sizeof(piSel[0]), RevCompInts ); <br>        for( i = 0; i &lt; cSteps; i++ ) { <br>            SendDlgItemMessage(hWnd, DLG_MAIN_FRAMELIST, LB_DELETESTRING, <br>                    piSel[i], 0); <br>        } <br> <br>        FreeMem(piSel); <br>        ClearStepSel(hWnd); <br> <br>        break; <br>    } <br> <br>    case DLG_MAIN_DUPFRAME: <br>    case MENU_EDIT_DUP: <br>        /* copy */ <br>        /* paste */ <br>        ganiAcon.fDirty = TRUE; <br>        WRITEME(hWnd); <br>        break; <br> <br>    case DLG_MAIN_EDITFRAME: <br>    case MENU_EDIT_EDITFRAME: <br>    case DLG_MAIN_ADDFRAME: <br>    case MENU_EDIT_ADDFRAME: { <br>        BOOL fEditFrame; <br> <br>        ganiAcon.fDirty = TRUE; <br> <br>        fEditFrame = (cmd == MENU_EDIT_EDITFRAME || <br>                    cmd == DLG_MAIN_EDITFRAME); <br> <br> <br>        EditFrame(hWnd, fEditFrame); <br> <br>        break; <br>    } <br> <br>    case DLG_MAIN_STOP: <br>        PausePreview(hWnd, DLG_MAIN_PREVIEW); <br>        break; <br> <br>    case DLG_MAIN_PLAY: <br>        ResumePreview(hWnd, DLG_MAIN_PREVIEW); <br>        break; <br> <br>    case MENU_HELP_ABOUT: <br>        DialogBox(hInst, MAKEINTRESOURCE(DLG_ABOUT), hWnd, About); <br>        break; <br> <br>    case MENU_HELP_CONTENTS: <br> <br>        //WinHelp(hWnd, TEXT("RKTOOLS.HLP"), HELP_COMMAND, (DWORD)TEXT("JI(\"RKTOOLS.HLP\"&gt;\"main\",\"aniedit\")")); <br>        //WinHelp(hWnd, TEXT("RKTOOLS.HLP"), HELP_COMMAND, (DWORD)TEXT("JI(\"RKTOOLS.HLP\",\"aniedit\")")); <br>        WinHelp(hWnd, TEXT("RKTOOLS.HLP"), HELP_COMMAND, (DWORD)TEXT("JI(\"RKTOOLS.HLP&gt;main\",\"aniedit\")")); <br>        break; <br> <br>    case MENU_EDIT_OPTIONS: <br>        if (DialogBox(hInst, MAKEINTRESOURCE(DLG_OPTIONS), hWnd, OptionsProc)){ <br>            InvalidateRect( GetDlgItem(hWnd, DLG_MAIN_PREVIEW), NULL, TRUE); <br>        } <br>        break; <br> <br>    case DLG_MAIN_FRAMELIST: { <br>        HWND hwndLB = (HWND)lParam; <br> <br>        switch(HIWORD(wParam)) { <br> <br>            case LBN_SELCHANGE: { <br>                PSTEP ps; <br>                int cSel; <br>                LPTSTR pszText; <br> <br>                cSel = SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0); <br> <br>                if (cSel &gt; 1) { <br>                    int *piSel; <br>                    int i; <br> <br>                    pszText = FmtSprintf( cSel == GetStepCount(hWnd) ? <br>                            MSG_ALLFRAMES : MSG_FRAMESSELECTED, cSel ); <br>                    SetDlgItemText(hWnd, DLG_MAIN_FRAMEGRP, pszText); <br>                    FmtFree( pszText ); <br> <br>                    piSel = AllocMem( cSel * sizeof(int) ); <br>                    if( piSel == NULL ) <br>                        break; <br> <br>                    GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, piSel, cSel, &amp;cSel); <br>                    for( i = 0; i &lt; cSel; i++ ) { <br>                        ps = GetStep(hWnd, piSel[i]); <br> <br>                        if( IsValidPS(ps) ) { <br>                            if (i == 0) { <br>                                ganiAcon.anih.jifRate = ps-&gt;jif; <br>                            } else if(ganiAcon.anih.jifRate != ps-&gt;jif) { <br>                                break; <br>                            } <br>                        } <br>                    } <br> <br>                    if (i &lt; cSel) { <br>                        /* rates differ, wipe out jiffy edit control */ <br>                        SetDlgItemText(hWnd, DLG_MAIN_RATE, ""); <br>                    } else { <br>                        SetDlgItemInt(hWnd, DLG_MAIN_RATE, <br>                                ganiAcon.anih.jifRate, FALSE); <br>                    } <br> <br>                    FreeMem(piSel); <br> <br>                } else if (cSel == 1) { <br>                    int iLBSel; <br> <br>                    GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, &amp;iLBSel, 1, &amp;cSel); <br> <br>                    SetPreviewStep(hWnd, DLG_MAIN_PREVIEW, iLBSel); <br> <br>                    pszText = FmtSprintf( MSG_FRAMEOFSEL, iLBSel + 1, <br>                            GetStepCount(hWnd) ); <br>                    SetDlgItemText(hWnd, DLG_MAIN_FRAMEGRP, pszText); <br>                    FmtFree( pszText ); <br> <br>                    ps = (PSTEP)SendMessage(hwndLB, LB_GETITEMDATA, iLBSel, 0); <br> <br>                    if (IsValidPS(ps)) { <br>                        SetDlgItemInt( hWnd, DLG_MAIN_RATE, ps-&gt;jif, FALSE); <br>                    } <br>                } else { <br>                    pszText = FmtSprintf( MSG_NOFRAMESSEL ); <br>                    SetDlgItemText(hWnd, DLG_MAIN_FRAMEGRP, pszText); <br>                    FmtFree( pszText ); <br>                    SetPreviewStep(hWnd, DLG_MAIN_PREVIEW, 0); <br>                } <br>                break; <br> <br>            case LBN_DBLCLK: <br>                ganiAcon.fDirty = TRUE; <br>                EditFrame(hWnd, TRUE); <br>                break; <br>            } <br>        } <br>        break; <br> <br>    } <br> <br>    case DLG_MAIN_RATE: { <br>        static BOOL fEditCtlHasFocus = FALSE; <br>        static BOOL fEditCtlHasChanged = FALSE; <br>        int *piSel; <br>        int cSteps; <br>        int i; <br> <br>        switch(HIWORD(wParam)) { <br>        case EN_SETFOCUS: <br>            fEditCtlHasFocus = TRUE; <br>            break; <br> <br>        case EN_KILLFOCUS: <br>            fEditCtlHasFocus = FALSE; <br>            break; <br> <br>        case EN_CHANGE: <br> <br>            cSteps = GetSelStepCount(hWnd); <br> <br>            if (fEditCtlHasFocus &amp;&amp; cSteps &gt;=1 &amp;&amp; <br>                    GetWindowTextLength(GetDlgItem(hWnd, DLG_MAIN_RATE)) &gt; 0) { <br>                JIF jif; <br>                BOOL fOK; <br> <br>                ganiAcon.fDirty = TRUE; <br>                piSel = AllocMem( cSteps * sizeof(int) ); <br>                if (piSel == NULL) { <br>                    SetFocus((HWND)lParam); <br>                    break; <br>                } <br> <br> <br>                jif = GetDlgItemInt(hWnd, DLG_MAIN_RATE, &amp;fOK, FALSE); <br> <br>                if (jif == 0 || !fOK) { <br>                    FmtMessageBox(hWnd, MSG_LITERAL, gszWindowTitle, <br>                        MB_OK | MB_ICONEXCLAMATION, TRUE, <br>                        MSG_RATERANGE); <br>                    SetFocus((HWND)lParam); <br>                    break; <br>                } <br> <br>                GetCurrentSel(hWnd, DLG_MAIN_FRAMELIST, piSel, cSteps, <br>                        &amp;cSteps); <br> <br>                for( i = 0; i &lt; cSteps; i++ ) { <br>                    PSTEP ps = GetStep(hWnd, piSel[i]); <br> <br>                    if (IsValidPS(ps)) { <br>                        ps-&gt;jif = jif; <br>                    } <br>                } <br>                InvalidateRect(GetDlgItem(hWnd,DLG_MAIN_FRAMELIST), NULL,TRUE); <br> <br>                FreeMem( piSel ); <br>            } <br>            break; <br>        } <br>        break; <br>    } <br> <br>    default: <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: About(HWND, unsigned, WORD, LONG) <br>* <br>*     PURPOSE:  Processes messages for "About" dialog box <br>* <br>*     MESSAGES: <br>* <br>*         WM_INITDIALOG - initialize dialog box <br>*         WM_COMMAND    - Input received <br>* <br>*     COMMENTS: <br>* <br>*         No initialization is needed for this particular dialog box, but TRUE <br>*         must be returned to Windows. <br>* <br>*         Wait for user to click on "Ok" button, then close the dialog box. <br>* <br>\****************************************************************************/ <br> <br>BOOL APIENTRY About( <br>        HWND hDlg,                /* window handle of the dialog box */ <br>        UINT message,             /* type of message                 */ <br>        UINT wParam,              /* message-specific information    */ <br>        LONG lParam) <br>{ <br>    switch (message) { <br>        case WM_INITDIALOG:                /* message: initialize dialog box */ <br>            return (TRUE); <br> <br>        case WM_COMMAND:                      /* message: received a command */ <br>            if (LOWORD(wParam) == IDOK        /* "OK" box selected?          */ <br>                || LOWORD(wParam) == IDCANCEL) { /*System menu close command?*/ <br>                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */ <br>                return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE);                           /* Didn't process a message    */ <br>        UNREFERENCED_PARAMETER(lParam); <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: OptionsProc(HWND, unsigned, WORD, LONG) <br>* <br>*     PURPOSE:  Processes messages for "Options" dialog box <br>* <br>*     MESSAGES: <br>* <br>*         WM_INITDIALOG - initialize dialog box <br>*         WM_COMMAND    - Input received <br>* <br>\****************************************************************************/ <br> <br>BOOL APIENTRY OptionsProc( <br>        HWND hDlg,                /* window handle of the dialog box */ <br>        UINT message,             /* type of message                 */ <br>        UINT wParam,              /* message-specific information    */ <br>        LONG lParam) <br>{ <br>    int i; <br>    int fRepaint = FALSE; <br> <br>    switch (message) { <br>    case WM_INITDIALOG:                /* message: initialize dialog box */ <br>        SendDlgItemMessage(hDlg, DLG_OPTIONS_EDITOR, EM_LIMITTEXT, MAX_PATH, 0); <br>        SetDlgItemText(hDlg, DLG_OPTIONS_EDITOR, gszCursorEditor); <br>        CheckRadioButton( hDlg, <br>                          DLG_OPTIONS_RADIO_DESKCOL, <br>                          DLG_OPTIONS_RADIO_WINCOL, <br>                          garadColor[giradColor].id ); <br>        return (TRUE); <br> <br>    case WM_COMMAND:                      /* message: received a command */ <br>        switch(LOWORD(wParam)) { <br>        case IDOK: <br> <br>            /* <br>             * Get the new desk color <br>             */ <br>            for( i = 0; garadColor[i].id != 0; i++ ) { <br>                if( IsDlgButtonChecked(hDlg, garadColor[i].id) ) { <br>                    break; <br>                } <br>            } <br> <br>            if (i != giradColor ) { <br>                /* new color, make new brush and repaint */ <br>                if (ghbrPrevBackgnd != NULL) <br>                    DeleteObject(ghbrPrevBackgnd); <br> <br>                ghbrPrevBackgnd = <br>                        CreateSolidBrush(GetSysColor(garadColor[i].idSys)); <br>                giradColor = i; <br>                fRepaint = TRUE; <br>            } <br> <br>            /* <br>             * Get new editor <br>             */ <br>            GetDlgItemText(hDlg,DLG_OPTIONS_EDITOR, <br>                    gszCursorEditor,COUNTOF(gszCursorEditor)); <br> <br>            for( i = 0; i &lt; COUNTOF(gszCursorEditor); i++ ) { <br> <br>                if (gszCursorEditor[i] == TEXT('\0')) <br>                    break; <br> <br>                if (gszCursorEditor[i] == TEXT('%') &amp;&amp; <br>                        ++i &lt; COUNTOF(gszCursorEditor) &amp;&amp; <br>                        gszCursorEditor[i] == TEXT('1')) { <br>                    break; <br>                } <br>#if defined(DBCS) &amp;&amp; !defined(UNICODE) <br>                if (IsDBCSLeadByte(gszCursorEditor[i])) { <br>                    i++; <br>                } <br>#endif <br>            } <br> <br> <br>            if (i &gt;= COUNTOF(gszCursorEditor) || <br>                gszCursorEditor[i] != TEXT('1')) { <br> <br>                if (i &gt;= (COUNTOF(gszCursorEditor) - 4)) { <br>                    i =  COUNTOF(gszCursorEditor) - 4; <br>                } <br> <br>                lstrcpy(&amp;gszCursorEditor[i], TEXT(" %1")); <br>            } <br> <br>        case IDCANCEL: <br>            EndDialog(hDlg, fRepaint);        /* Exits the dialog box        */ <br>            return (TRUE); <br> <br>        default: <br>            break; <br>        } <br>        break; <br>    } <br>    return (FALSE);                           /* Didn't process a message    */ <br>        UNREFERENCED_PARAMETER(lParam); <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: ExitCommand(HWND) <br>* <br>*     PURPOSE:  Exit the program chekcing for dirty files etc. <br>* <br>* <br>\****************************************************************************/ <br>VOID ExitCommand(HWND hWnd) { <br> <br>    /* if file is dirty then prompt for save */ <br>    if(CheckDirty(hWnd)) <br>        AniEndDialog(hWnd, TRUE); <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: CheckDirty(HWND) <br>* <br>*     PURPOSE:  check for dirty files and return TRUE if it is OK to continue. <br>* <br>* <br>\****************************************************************************/ <br>BOOL CheckDirty(HWND hWnd) { <br>    int idRet; <br> <br>    /* if file is dirty then prompt for save */ <br>    if (ganiAcon.fDirty) { <br>        idRet = FmtMessageBox( hWnd, MSG_LITERAL, gszWindowTitle, <br>                MB_YESNOCANCEL | MB_ICONEXCLAMATION, TRUE, MSG_SAVEFILEQUEST, <br>                ganiAcon.szFile); <br> <br>        switch( idRet ) { <br>        case IDYES: <br>            SaveFile(hWnd, FALSE); <br>            break; <br> <br>        case IDNO: <br>            break; <br> <br>        case IDCANCEL: <br>            return FALSE; <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: HWND ExecProgram(  HWND hwndCaller, LPTSTR pszCmdLine ) <br>* <br>*     PURPOSE:  Creates a process and returns the new processes main window <br>* <br>*     RETURNS: NULL if the process could not be created, otherwise the <br>*              processes main window handle. <br>* <br>*     SIDEEFFECT: This function will also start a thread that will block <br>*               on the process handle until the process terminates.  At that <br>*               time, the thread will post a message back to the calliers <br>*               window. <br>* <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>BOOL ExecProgram( HWND hwndCaller, LPTSTR pszCmdLine ) { <br>    STARTUPINFO si; <br>    PROCESS_INFORMATION pi; <br>    HWND hwnd; <br>    PTHDDATA pthd; <br>    DWORD tid; <br>    HANDLE hthrd; <br> <br>    /* <br>     * Create the monitor thread (suspened) <br>     */ <br>    pthd = AllocMem(sizeof(THDDATA)); <br> <br>    if (pthd == NULL) <br>        return FALSE; <br> <br>    /* set thread data to be invalid incase we have to abort */ <br>    pthd-&gt;hprocMonitor = NULL; <br>    pthd-&gt;hwndCaller = hwndCaller; <br> <br>    if ((hthrd = CreateThread( NULL, 0, ProcWaitThread, pthd, CREATE_SUSPENDED, <br>            &amp;tid )) == NULL) { <br>        /* could not create the monitor thread, return error */ <br>        FreeMem(pthd); <br>        return FALSE; <br>    } <br> <br>    /* <br>     * Create the process <br>     */ <br>    ZeroMemory( &amp;si, sizeof(si) ); <br>    si.cb = sizeof(si); <br>    si.wShowWindow = SW_SHOW; <br>    si.dwFlags = STARTF_USESHOWWINDOW; <br> <br>    if (!CreateProcess( NULL, pszCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, <br>            &amp;si, &amp;pi)) { <br>        ResumeThread(hthrd);    // make thread localfree the data and exit <br>        return FALSE; <br>    } <br> <br>    DPRINT(("MT:Child IDs proc/thd: 0x%lx / 0x%lx\n", pi.dwProcessId, pi.dwThreadId)); <br>    DPRINT(("MT:Child Hnd proc/thd: 0x%lx / 0x%lx\n", pi.hProcess, pi.hThread)); <br> <br>    /* <br>     * Wait for the main window to be created <br>     */ <br>    if( WaitForInputIdle( pi.hProcess, CMS_WAIT_FOR_PROCESS ) != 0 ) { <br>        ResumeThread(hthrd);    // make thread localfree the data and exit <br>        return FALSE; <br>    } <br> <br>    DPRINT(("MT:Child is idle\n")); <br> <br>    /* <br>     * Enumerate the new processes main thread's windows and <br>     * return the main one. <br>     */ <br>    hwnd = NULL; <br>    EnumThreadWindows( pi.dwThreadId, ETWProc, (LPARAM)&amp;hwnd ); <br> <br>#if 0 <br>    if (hwnd != NULL) { <br>        pthd-&gt;hprocMonitor = pi.hProcess; <br>        pthd-&gt;hwndMonitor = hwnd; <br> <br>        SendMessage(hwndCaller, AIM_SETCHILDAPP, 0, hwnd); <br>    } <br>#else <br>    pthd-&gt;hprocMonitor = pi.hProcess; <br>    pthd-&gt;hwndMonitor = hwnd; <br> <br>    if (pthd-&gt;hprocMonitor != NULL) <br>        SendMessage(hwndCaller, AIM_SETCHILDAPP, 0, (LPARAM)hwnd); <br>#endif <br> <br>    ResumeThread(hthrd); <br>    CloseHandle(hthrd); <br>    CloseHandle(pi.hThread); <br>    return TRUE; <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: BOOL CALLBACK ETWProc( HWND hwnd, LPARAM lParam ) <br>* <br>*     PURPOSE:  Enumeration proc for ExecProgram.  It looks for the thread's <br>*               top level window. <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>BOOL CALLBACK ETWProc( HWND hwnd, LPARAM lParam ) { <br>    DWORD *pdw = (DWORD *)lParam; <br> <br>    /* <br>     * If this window has no parent, then it is a toplevel <br>     * window for the thread.  Remember the last one we find since it <br>     * is probably the main window. <br>     */ <br> <br>    if (GetParent(hwnd) == NULL) { <br>        DPRINT(("MT:EnumThdWin found 0x%lx\n", (DWORD)hwnd)); <br>        *pdw = (DWORD)hwnd; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: DWORD ProcWaitThread( LPDWORD lpdw ) <br>* <br>*     PURPOSE:  Thread to wait on a process and then post a message <br>* <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>DWORD WINAPI ProcWaitThread( LPVOID lpv ) { <br>    LPDWORD lpdw = lpv; <br>    PTHDDATA pthd = (PTHDDATA)lpdw; <br>    DWORD dwRet; <br> <br>    if (pthd-&gt;hprocMonitor == NULL) { <br>        /* something went wrong, just exit now */ <br>        DPRINT(("wt:Aborting\n")); <br>        FreeMem( lpdw ); <br>        ExitThread(0); <br>    } <br> <br>    DPRINT(("wt:Waiting\n")); <br>    dwRet = WaitForSingleObject( pthd-&gt;hprocMonitor, INFINITE ); <br> <br>    DPRINT(("wt:Send AIM_PROCESSTERM\n")); <br>    SendMessage(pthd-&gt;hwndCaller, AIM_PROCESSTERM, (dwRet == WAIT_OBJECT_0), <br>            (LPARAM)pthd-&gt;hwndMonitor); <br> <br>    CloseHandle( pthd-&gt;hprocMonitor ); <br>    FreeMem( lpdw ); <br>    ExitThread(0); <br> <br>    return 0; <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: void NewAniCursor( HWND hwnd ) <br>* <br>*     PURPOSE:  erase any used memory and init to a clean slate <br>* <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>void NewAniCursor( HWND hwnd ) { <br>    int i, cSteps; <br>    LPTSTR psz; <br> <br>    PausePreview(hwnd, DLG_MAIN_PREVIEW); <br> <br>    /* Step through the list box, deleting all the lb entryies and everything <br>     * that they point to (except the icons). <br>     */ <br>    cSteps = GetStepCount(hwnd); <br> <br>    if (cSteps != LB_ERR) { <br>        for( i = 0; i &lt; cSteps; i++ ) { <br>            /* <br>             * Delete the top item of the list.  Note that once that item <br>             * (current index 0) is deleted, then the next item will move <br>             * up and become index 0. <br>             */ <br>            SendDlgItemMessage( hwnd, DLG_MAIN_FRAMELIST, LB_DELETESTRING,0,0); <br>        } <br>    } <br> <br> <br>    /* <br>     * Step through the icon list deleting them.  We don't need to call <br>     * DestroyFrame since we are trashing the whole chain. <br>     */ <br> <br>#if 0 <br>    pf = gpfrmFrames; <br>    gpfrmFrames = NULL; <br> <br>    DON'T DO THIS!!! it will wipe out the clip board accidentally! <br> <br>    for(; pf != NULL; pf = pfrmNext ) { <br>        pfrmNext = pf-&gt;pfrmNext; <br> <br>        DestroyIcon( pf-&gt;hcur ); <br>        FreeMem(pf); <br>    } <br>#endif <br> <br>    /* <br>     * Init Ani header <br>     */ <br>    ZeroMemory( &amp;ganiAcon, sizeof(ganiAcon) ); <br>    ganiAcon.anih.cbSizeof = sizeof(ganiAcon); <br>    ganiAcon.anih.cbSizeof = AF_ICON; <br>    ganiAcon.anih.jifRate = 10; <br> <br>    SetDlgItemTextA(hwnd, DLG_MAIN_TITLE, ganiAcon.azTitle); <br>    SetDlgItemTextA(hwnd, DLG_MAIN_AUTHOR, ganiAcon.azCreator); <br> <br>    SetDlgItemInt( hwnd, DLG_MAIN_RATE, ganiAcon.anih.jifRate, FALSE); <br> <br>    PreviewCursor(hwnd, DLG_MAIN_PREVIEW); <br> <br>    SetWindowFileTitle(hwnd, gpszUntitled ); <br> <br>    psz = FmtSprintf(MSG_NOFRAMESSEL); <br>    SetDlgItemText(hwnd, DLG_MAIN_FRAMEGRP, psz); <br>    FmtFree( psz ); <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: BOOL GetCurrentSel( HWND hwnd, int id, int * paiSel, <br>*                                                   int ciSel, int *pcSel ); <br>* <br>*     PURPOSE:  Gets the selections and returns it's index <br>* <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>BOOL GetCurrentSel( HWND hwnd, int id, int * paiSel, int ciSel, int *pcSel ) { <br> <br>#ifdef MULTISEL <br>    *pcSel = SendDlgItemMessage(hwnd,id, LB_GETSELITEMS, ciSel,(LPARAM)paiSel); <br> <br>    if (*pcSel == LB_ERR) { <br>        *pcSel = 0; <br>    } <br>#else <br> <br>    *paiSel = SendDlgItemMessage(hwnd, id, LB_GETCURSEL, 0, 0); <br>    *pcSel = 1; <br> <br>    if (*paiSel == LB_ERR) <br>        *pcSel = 0; <br>#endif <br> </code></pre>
<p>
</p>
<pre><code>return TRUE; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID SetCurrentSel( HWND hwnd, int id, BOOL fExtend, int iSel); <br>* <br>*     PURPOSE:  Sets the selections and returns it's index <br>* <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID SetCurrentSel( HWND hwnd, int id, BOOL fExtend, int iSel) { <br>#ifdef MULTISEL <br>    if (!fExtend) { <br>        SendDlgItemMessage(hwnd, id, LB_SETSEL, FALSE, -1); <br>    } <br> <br>    SendDlgItemMessage(hwnd, id, LB_SETSEL, TRUE, iSel); <br>#else <br>    SendDlgItemMessage(hwnd, id, LB_SETCURSEL, iSel, 0); <br>#endif <br> <br>    UpdateStepSel( hwnd ); <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID EditFrame(HWND hwnd, int iSel); <br>* <br>*     PURPOSE:  Runs ImagEdit on the frame indexed by iSel <br>* <br>* <br>* History: <br>*   27-Apr-1993 JonPa <br>* <br>\****************************************************************************/ <br>VOID EditFrame(HWND hWnd, BOOL fEditFrame) { <br>    LPTSTR pszCmdLine = NULL; <br>    int cchCmdLine; <br>    HANDLE hf; <br>    DWORD cb; <br>    PBYTE pbIcon; <br>    DWORD cbIcon; <br>    int iSel; <br>    int cSel; <br>    BOOL fExeced; <br> <br>    /* create a temp .cur file name */ <br>    if( !GetTempCursorFileName( gszTempFile ) ) { <br>        FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                TRUE, MSG_OUTOFRESOUCES ); <br>        return; <br>    } <br> <br> <br>    cSel = GetSelStepCount(hWnd); <br> <br>    if ( (fEditFrame &amp;&amp; (cSel != 1)) || cSel &gt; 1 ) { <br> <br>        FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                TRUE, fEditFrame ? MSG_MUSTEQONEFAME : MSG_LESSEQONEFRAME); <br>        return; <br>    } <br> <br>    /* cache the currently selected item (Singluar) */ <br>    GetCurrentSel( hWnd, DLG_MAIN_FRAMELIST, &amp;iSel, 1, &amp;cSel ); <br> <br>    /* <br>     * If edit, then write the frame to the file and save checksum <br>     * otherwise write the blank cursor to the file. <br>     */ <br> <br>    hf = CreateFile( gszTempFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, <br>            FILE_ATTRIBUTE_NORMAL, NULL ); <br> <br> <br>    if (hf == INVALID_HANDLE_VALUE) { <br>        FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, TRUE, <br>            MSG_CANTCREATEFILE, gszTempFile ); <br>        return; <br>    } <br> <br>    if (fEditFrame || cSel != 0) { <br>        PSTEP ps = GetStep(hWnd, iSel); <br> <br>        if( !IsValidPS(ps) ) { <br>            FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                    TRUE, MSG_OUTOFRESOUCES ); <br>            CloseHandle(hf); <br>            return; <br>        } <br> <br> <br>        pbIcon = ps-&gt;pfrmFrame-&gt;abIcon; <br>        cbIcon = ps-&gt;pfrmFrame-&gt;rtag.ckSize; <br> <br>    } else { <br> <br>        HRSRC hr = FindResource(hInst, MAKEINTRESOURCE(ID_BLANKCUR), <br>                MAKEINTRESOURCE(RCT_RAWDATA)); <br> <br>        if (hr == NULL || (pbIcon =LockResource(LoadResource(hInst, hr))) == <br>                NULL) { <br>            FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                    TRUE, MSG_OUTOFRESOUCES ); <br>            CloseHandle(hf); <br>            return; <br>        } <br> <br>        cbIcon = SizeofResource(hInst, hr); <br>    } <br> <br>    WriteFile(hf, pbIcon, cbIcon, &amp;cb, NULL); <br> <br>    CloseHandle(hf); <br> <br>    /* <br>     * change .tmp to .cur <br>     */ <br>    { TCHAR szOldName[MAX_PATH]; <br> <br>        cchCmdLine = lstrlen(gszTempFile); <br> <br>        lstrcpy( szOldName, gszTempFile ); <br>        lstrcpy( &amp;gszTempFile[cchCmdLine - 3], gpszCUR ); <br> <br>        if(!MoveFile(szOldName, gszTempFile)) <br>            lstrcpy( gszTempFile, szOldName ); <br> <br>        cchCmdLine = (cchCmdLine + lstrlen(gszCursorEditor) + 1 + 1) * <br>                sizeof(TCHAR); <br> <br>        pszCmdLine = AllocMem(cchCmdLine); <br>    } <br> <br>    if (pszCmdLine == NULL) <br>        return; <br> <br>    { <br>        LPTSTR pszTempFile = gszTempFile; <br> <br>        FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, <br>                gszCursorEditor, 0, 0, pszCmdLine, cchCmdLine, (va_list *)(DWORD)&amp;pszTempFile); <br>    } <br> <br>    /* spawn imagedit on the file */ <br>    fExeced = ExecProgram( hWnd, pszCmdLine ); <br>    DPRINT(("MT:Begin Defer to child\n")); <br> <br>    FreeMem(pszCmdLine); <br> <br>    if ( fExeced  ) { <br>        gfEditFrame = fEditFrame; <br>    } else { <br>        FmtMessageBox( hWnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                    TRUE, MSG_NOIMAGEDIT, gszCursorEditor ); <br>    } <br>} <br> <br> <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: PSTEP NewStep( void ); <br>* <br>* <br>*     PURPOSE:  Creates a new step and set's its pfrmFrame to NULL; <br>* <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>PSTEP NewStep( void ) { <br>    PSTEP ps; <br> <br>    ps = AllocMem(sizeof(STEP)); <br> <br>    if (IsValidPS(ps)) <br>        ps-&gt;pfrmFrame = NULL; <br> <br>    return ps; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID DestroyStep( PSTEP ps ); <br>* <br>* <br>*     PURPOSE:  Deletes a step, and derefernces its frame, deleting it if <br>*               necessary. <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID DestroyStep( PSTEP ps ) { <br>    LinkStepFrame(ps, NULL); <br> <br>    FreeMem(ps); <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID CopyStep( PSTEP psDst, PSTEP psSrc ); <br>* <br>* <br>*     PURPOSE:  Copyies a step, bumping the ref count of the frame if it <br>*               needs it. <br>* <br>* History: <br>*   07-May-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID CopyStep( PSTEP psDst, PSTEP psSrc ) { <br>    *psDst = *psSrc; <br> <br>    if( psDst-&gt;pfrmFrame != NULL ) { <br>        psDst-&gt;pfrmFrame-&gt;cRef += 1; <br>    } <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID LinkStepFrame( PSTEP ps, PFRAME pf ); <br>* <br>* <br>*     PURPOSE:  Unlinks a step from its frame and then links the new <br>*               frame in its place.  If the old frame is an orphan, it <br>*               gets destroyed. <br>* <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID LinkStepFrame(PSTEP ps, PFRAME pf ) { <br>    PFRAME pfOld = ps-&gt;pfrmFrame; <br> <br>    if (pf != NULL) <br>        pf-&gt;cRef++; <br> <br>    if (pfOld != NULL &amp;&amp; --(pfOld-&gt;cRef) == 0) <br>        DestroyFrame(pfOld); <br> <br>    ps-&gt;pfrmFrame = pf; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID DestroyFrame( PFRAME pf ); <br>* <br>* <br>*     PURPOSE:  Unlinks a frame from the list, deletes its hcur, and <br>*               Frees its memory. <br>* <br>* <br>* History: <br>*   28-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID DestroyFrame( PFRAME pf ) { <br>    PFRAME pfList; <br> <br>    if (pf == gpfrmFrames) { <br>        gpfrmFrames = pf-&gt;pfrmNext; <br>    } else { <br> <br>        for( pfList = gpfrmFrames; pfList != NULL; <br>                pfList = pfList-&gt;pfrmNext ) { <br> <br>            if (pfList-&gt;pfrmNext == pf) { <br>                break; <br>            } <br>        } <br> <br>        if (pfList != NULL) { <br>            pfList-&gt;pfrmNext = pf-&gt;pfrmNext; <br>        } <br>    } <br> <br>    DestroyIcon( pf-&gt;hcur ); <br>    FreeMem(pf); <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: PCLPBRDDAT NewClpBrdDat( void ) <br>* <br>* <br>*     PURPOSE:  Creates a new clip board data struct <br>* <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>PCLPBRDDAT NewClpBrdDat( void ) { <br>    PCLPBRDDAT pcbd = AllocMem( sizeof(CLPBRDDAT) ); <br> <br>    if (pcbd != NULL) <br>        pcbd-&gt;stp.pfrmFrame = NULL; <br> <br>    return pcbd; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID DestroyClpBrdDat(PCLPBRDDAT pcbd) <br>* <br>* <br>*     PURPOSE:  Creates a new clip board data struct <br>* <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID DestroyClpBrdDat(PCLPBRDDAT pcbd) { <br>    LinkStepFrame(&amp;(pcbd-&gt;stp), NULL); <br> <br>    FreeMem(pcbd); <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID SetWindowFileTitle(HWND hWnd, LPTSTR szFileTitle) <br>* <br>* <br>*     PURPOSE:  Sets the file title <br>* <br>* <br>* History: <br>*   30-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID SetWindowFileTitle(HWND hWnd, LPTSTR szFileTitle) { <br> <br>    /* <br>     * We use LocalAlloc here instead of AllocMem because we don't really <br>     * char if it fails <br>     */ <br>    int cch = lstrlen( gszWindowTitle ) + lstrlen(szFileTitle); <br>    LPTSTR pszTitle = LocalAlloc(LPTR, (cch+4) * sizeof(TCHAR) ); <br> <br>    if (pszTitle != NULL) { <br>        wsprintf( pszTitle, "%s - %s", gszWindowTitle, szFileTitle ); <br>        SetWindowText(hWnd, pszTitle); <br> <br>        LocalFree(pszTitle); <br>    } else { <br>        SetWindowText(hWnd, gszWindowTitle); <br>    } <br>} <br> <br>int __cdecl RevCompInts(const void *elm1, const void *elm2) { <br>    return *((int *)elm2) - *((int *)elm1); <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: ClearStepSel <br>* <br>* <br>*     PURPOSE:  Clears all selections from the frame list <br>* <br>* <br>* History: <br>*   02-Jul-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>VOID ClearStepSel( HWND hWnd )  { <br>    int cItems = GetStepCount(hWnd); <br> <br>    if (cItems != 0) { <br>        SendDlgItemMessage(hWnd, DLG_MAIN_FRAMELIST, <br>                LB_SELITEMRANGE, (WPARAM)FALSE, MAKELPARAM(0, cItems - 1)); <br>    } <br> <br>    UpdateStepSel(hWnd); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
