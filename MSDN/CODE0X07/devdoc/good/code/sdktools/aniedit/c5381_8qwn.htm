<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ANIFILE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5387"></a>ANIFILE.C</h2>
<pre><code>/****************************************************************************\ <br>* <br>*     MODULE: anifile.c <br>* <br>*     PURPOSE: Processes files for the Animated Cursor Editor <br>* <br>*     Copyright 1993-1996 Microsoft Corp. <br>* <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Wrote it. <br>* <br>\****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include "anidefs.h" <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: BOOL CreateFrameFromCursorFile( LPSTR pszFile ) <br>* <br>*     PURPOSE:  Opens a cursor file, reads the icon info out of it, <br>*               and creates a frame and step for that icon, then links <br>*               everything together and updates the listbox. <br>* <br>*     NOTES:    This function accesses the global flag gfEditFrame. <br>*               If this bool is TRUE, then the currently selected frame <br>*               in the listbox is overwritten.  If it is false, then <br>*               a new frame is created and inserted after the currently <br>*               selected frame (or at the end if no selection). <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>BOOL CreateFrameFromCursorFile(HWND hwnd,  LPTSTR pszFile, BOOL fEdit) { <br>    PFRAME pf; <br>    HANDLE hf; <br>    PSTEP psOld, psNew; <br>    DWORD ckSize; <br>    int iSel; <br>    int cSel; <br> <br>    cSel = GetSelStepCount(hwnd); <br> <br>    if ( (fEdit &amp;&amp; (cSel != 1)) || cSel &gt; 1) { <br>        FmtMessageBox( hwnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                TRUE, fEdit ? MSG_MUSTEQONEFAME : MSG_LESSEQONEFRAME); <br>        return FALSE; <br>    } <br> <br>    /* get currently selected frame */ <br>    GetCurrentSel(hwnd, DLG_MAIN_FRAMELIST, &amp;iSel, 1, &amp;cSel ); <br> <br>    if (cSel == 0) <br>        psOld = NULL; <br>    else <br>        psOld = GetStep(hwnd, iSel); <br> <br>    /* <br>     * If not editing, create a new step <br>     */ <br>    if (!fEdit || !IsValidPS(psOld)) { <br>        psNew = NewStep(); <br> <br>        if (psNew == NULL) { <br>            return FALSE; <br>        } <br>    } else { <br>        psNew = NULL; <br>    } <br> <br>    hf = CreateFile(pszFile, GENERIC_READ, <br>             0, NULL, <br>             OPEN_EXISTING, <br>             FILE_ATTRIBUTE_NORMAL, <br>             NULL); <br> <br>    if (hf == INVALID_HANDLE_VALUE) <br>        return FALSE; <br> <br>    ckSize = GetFileSize(hf, NULL); <br> <br>    /* get the frame out of the file */ <br>    pf = ReadIconFromFile(hwnd, hf, ckSize); <br>    CloseHandle(hf); <br> <br>    if (pf == NULL) { <br>        if (psNew != NULL) <br>            FreeMem(psNew); <br>        return FALSE; <br>    } <br> <br>    if (psNew != NULL) { <br> <br>        if (IsValidPS(psOld)) { <br>            psNew-&gt;jif = psOld-&gt;jif; <br>            iSel += 1; <br>        } else { <br>            psNew-&gt;jif = ganiAcon.anih.jifRate; <br>            iSel = SendDlgItemMessage(hwnd, DLG_MAIN_FRAMELIST, LB_GETCOUNT, <br>                    0, 0); <br>        } <br> <br>        LinkStepFrame(psNew, pf); <br> <br>        SendDlgItemMessage(hwnd, DLG_MAIN_FRAMELIST, LB_INSERTSTRING, iSel, <br>            (LPARAM)psNew); <br> <br>        SetCurrentSel(hwnd, DLG_MAIN_FRAMELIST, FALSE, iSel); <br> <br>    } else { <br>        HWND hwndLB = GetDlgItem(hwnd, DLG_MAIN_FRAMELIST); <br> <br>        /* <br>         * Delete the old frame and point the step to the new one. <br>         */ <br>        LinkStepFrame(psOld, pf); <br> <br>        InvalidateRect(hwndLB, NULL, TRUE); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: HICON ConvertDataToIcon( PFRAME pf ) <br>* <br>*     PURPOSE: <br>* <br>* <br>* <br>* <br>* History: <br>*   23-Apr-1993 JonPa   copied from Win NT USERs ReadIconGuts <br>* <br>\****************************************************************************/ <br>HICON ConvertDataToIcon( PFRAME pf, WORD *pxHotSave, WORD *pyHotSave ) <br>{ <br>    NEWHEADER *pnh; <br>    NEWHEADER *pnhBase; <br>    RESDIR *prd; <br>    int offMatch; <br>    ICONFILERESDIR *pird; <br>    PCURSORRESOURCE pcres; <br>    BOOL fIcon; <br>    HICON hicon; <br>    WORD x, y; <br>    LPBYTE pbBits; <br> <br>    pnhBase = (NEWHEADER *)pf-&gt;abIcon; <br> <br>    /* <br>     * Construct a fake array of RESDIR entries using the info at the head <br>     * of the file.  Store the data offset in the idIcon WORD so it can be <br>     * returned by RtlGetIdFromDirectory. <br>     */ <br>    pnh = (NEWHEADER *)LocalAlloc(LMEM_FIXED, sizeof(NEWHEADER) + <br>            (pnhBase-&gt;cResources * sizeof(RESDIR))); <br>    if (pnh == NULL) <br>        return NULL; <br> <br>    *pnh = *pnhBase; <br>    prd = (RESDIR *)(pnh + 1); <br>    pird = (ICONFILERESDIR *)(pnhBase + 1); <br> <br>    /* prime pird for first line of loop */ <br>    pird--; <br> <br>    for (offMatch = 0; offMatch &lt; (int)pnh-&gt;cResources; offMatch++, prd++) { <br> <br>        /* <br>         * Get the next resource directory from the icon file. <br>         */ <br> <br>        ++pird; <br> <br>        /* <br>         * Convert from the icon editor's resource directory format <br>         * to the post-RC.EXE format LookupIconIdFromDirectory expects. <br>         */ <br>        if (pnh-&gt;rt == 1) {     // ICON <br>            prd-&gt;ResInfo.Icon.Width = pird-&gt;bWidth; <br>            prd-&gt;ResInfo.Icon.Height = pird-&gt;bHeight; <br>            prd-&gt;ResInfo.Icon.ColorCount = pird-&gt;bColorCount; <br>            prd-&gt;ResInfo.Icon.reserved = 0; <br>        } else {                // CURSOR <br>            prd-&gt;ResInfo.Cursor.Width = pird-&gt;bWidth; <br>            prd-&gt;ResInfo.Cursor.Height = pird-&gt;bHeight; <br>        } <br>        prd-&gt;Planes = 0;                // Hopefully nobody uses this <br>        prd-&gt;BitCount = 0;              //        "        " <br>        prd-&gt;BytesInRes = pird-&gt;dwDIBSize; <br>        prd-&gt;idIcon = (WORD)pird-&gt;dwDIBOffset; <br>    } <br> <br>    /* <br>     * NOTE: nh.rt is NOT an RT_ type value.  For instance, nh.rt == 1 for <br>     * an icon file where as 1 == RT_CURSOR, not RT_ICON. <br>     */ <br> <br>    fIcon = (pnhBase-&gt;rt == 1); <br>    offMatch = LookupIconIdFromDirectory((PBYTE)pnh, fIcon); <br> <br>    LocalFree(pnh); <br> <br>    if (fIcon) { <br>        pcres = (PCURSORRESOURCE)&amp;(pf-&gt;abIcon[offMatch]); <br>        *pxHotSave = gcxCursor / 2; <br>        *pyHotSave = gcyCursor / 2; <br>    } else { <br> <br>        offMatch -= (sizeof(pcres-&gt;xHotspot) + sizeof(pcres-&gt;yHotspot)); <br> <br>        for(; pird-&gt;dwDIBOffset != (WORD)offMatch &amp;&amp; <br>                pird != (ICONFILERESDIR *)(pnhBase + 1); pird--); <br> <br>        pcres = (PCURSORRESOURCE)&amp;(pf-&gt;abIcon[offMatch]); <br> <br>        x = pcres-&gt;xHotspot; <br>        y = pcres-&gt;yHotspot; <br>        *pxHotSave = pcres-&gt;xHotspot = pird-&gt;xHotspot; <br>        *pyHotSave = pcres-&gt;yHotspot = pird-&gt;yHotspot; <br>    } <br> <br> <br>    // Buffer must be aligned <br>    pbBits = LocalAlloc(LMEM_FIXED, pf-&gt;rtag.ckSize - offMatch ); <br>    if (pbBits) { <br>        CopyMemory( pbBits, pcres, pf-&gt;rtag.ckSize - offMatch ); <br> <br>        hicon = CreateIconFromResource( pbBits, <br>                pf-&gt;rtag.ckSize - offMatch, fIcon, 0x00030000); <br> <br>        LocalFree( pbBits ); <br>    } else <br>        hicon = NULL; <br> <br>    if(!fIcon) { <br>        pcres-&gt;xHotspot = x; <br>        pcres-&gt;yHotspot = y; <br>    } <br> <br>    return hicon; <br>} <br> <br> <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: PFRAME ReadIconFromFile(HWND hwnd, HANDLE hf, DWORD ckSize) <br>* <br>*     PURPOSE:  Reads the icon info out of a file, <br>*               and creates a frame for that icon. <br>* <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>PFRAME ReadIconFromFile(HWND hwnd, HANDLE hf, DWORD ckSize) { <br>    PFRAME pf = AllocMem( sizeof( FRAME ) + ckSize ); <br>    DWORD cbRead; <br>    PFRAME pfList; <br> <br>    if (pf != NULL) { <br>        pf-&gt;cRef = 0; <br> <br>        if (ReadFile(hf, pf-&gt;abIcon, ckSize, &amp;cbRead, NULL) &amp;&amp; <br>                cbRead == ckSize) { <br>            /* got the data, now set up the rest of the frame and link it in */ <br>            pf-&gt;dwCheckSum = CalcCheckSum( pf-&gt;abIcon, ckSize ); <br>            pf-&gt;rtag.ckID = FOURCC_icon; <br>            pf-&gt;rtag.ckSize = ckSize; <br> <br>            /* Check if this fram is already in the list */ <br>            for (pfList = gpfrmFrames; pfList != NULL; <br>                    pfList = pfList-&gt;pfrmNext ) { <br>                if (pf-&gt;dwCheckSum == pfList-&gt;dwCheckSum &amp;&amp; <br>                        pf-&gt;rtag.ckSize == pfList-&gt;rtag.ckSize &amp;&amp; <br>                        memcmp( pf-&gt;abIcon, pfList-&gt;abIcon, ckSize ) == 0) { <br>                    /* <br>                     * These frames are the same, coalesce them into a <br>                     * sequence. <br>                     */ <br>                    FreeMem(pf); <br>                    pf = pfList; <br>                    break; <br>                } <br>            } <br> <br>            if (pfList == NULL) { <br>                /* <br>                 * Did not find a dup, create an icon for this frame <br>                 */ <br>                pf-&gt;hcur = ConvertDataToIcon( pf, &amp;(pf-&gt;xHotSpot), <br>                        &amp;(pf-&gt;yHotSpot) ); <br> <br>                pf-&gt;pfrmNext = gpfrmFrames; <br>                gpfrmFrames = pf; <br>            } <br> <br>        } else { <br>            /* File Error */ <br>            FreeMem(pf); <br>            pf = NULL; <br>        } <br> <br>    } <br> <br>    return pf; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: HANDLE PromptAndOpenFile( ) <br>* <br>*     PURPOSE:  Pust up the standard open dialog and then opens the file <br>* <br>* <br>* <br>* <br>* History: <br>*   21-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>HANDLE PromptAndOpenFile( <br>    HWND hwnd, <br>    DWORD  cchFileTitle, <br>    LPTSTR pszFileTitle, <br>    DWORD  cchFileName, <br>    LPTSTR pszFileName, <br>    LPTSTR pszFilter <br>    ) <br>{ <br>    HANDLE hf = INVALID_HANDLE_VALUE; <br> <br>    if (PromptForFile( hwnd, cchFileTitle, pszFileTitle, cchFileName, <br>                pszFileName, pszFilter, NULL, FALSE )) { <br> <br>        /* Open the file. */ <br> <br>        hf = CreateFile(pszFileName, GENERIC_READ, <br>                0, NULL, <br>                OPEN_EXISTING, <br>                FILE_ATTRIBUTE_NORMAL, <br>                NULL); <br> <br>        if (hf == INVALID_HANDLE_VALUE) { <br>            FmtMessageBox( hwnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, TRUE, <br>                MSG_CANTOPENFILE, pszFileName ); <br>        } <br>    } <br> <br>    return hf; <br>} <br> <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: HANDLE PromptForFile( ) <br>* <br>*     PURPOSE:  Pust up the standard open dialog <br>* <br>* <br>* <br>* <br>* History: <br>*   28-Apr-1993 JonPa   Created it from PromptAndOpenFile <br>* <br>\****************************************************************************/ <br>BOOL PromptForFile( <br>    HWND hwnd, <br>    DWORD  cchFileTitle, <br>    LPTSTR pszFileTitle, <br>    DWORD  cchFileName, <br>    LPTSTR pszFile, <br>    LPTSTR pszFilter, <br>    LPTSTR pszDlgTitle, <br>    BOOL fSave <br>    ) <br>{ <br>    OPENFILENAME ofn; <br> <br>    ZeroMemory(&amp;ofn, sizeof(ofn)); <br> <br>    /* Set the members of the OPENFILENAME structure. */ <br> <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hwnd; <br> <br>    ofn.lpstrFilter = pszFilter; <br>    ofn.nFilterIndex = 0; <br> <br>    ofn.lpstrFile = pszFile; <br>    ofn.nMaxFile = cchFileName; <br> <br>    ofn.lpstrFileTitle = pszFileTitle; <br>    ofn.nMaxFileTitle = cchFileTitle; <br> <br>    ofn.lpstrTitle = pszDlgTitle; <br> <br>    ofn.lpstrDefExt = gpszANI; <br> <br>    if (fSave) { <br>        ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT; <br>    } else { <br>        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br>    } <br> <br>    /* Display the SaveAs or Open dialog box. */ <br> <br>    return fSave ? GetSaveFileName(&amp;ofn) : GetOpenFileName(&amp;ofn); <br> <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: BOOL ReadAniFile( HWND hwnd, HANDLE hf ) { <br>* <br>*     PURPOSE: <br>&amp; <br>*   Loads an animatied cursor from a RIFF file.  The RIFF file format for <br>*   animated cursors looks like this: <br>* <br>*   RIFF( 'ACON' <br>*       LIST( 'INFO' <br>*           INAM( &lt;name&gt; ) <br>*           IART( &lt;artist&gt; ) <br>*       ) <br>*       anih( &lt;anihdr&gt; ) <br>*       [rate( &lt;rateinfo&gt; )  ] <br>*       ['seq '( &lt;seq_info&gt; )] <br>*       LIST( 'fram' icon( &lt;icon_file&gt; ) ) <br>*   ) <br>* <br>* <br>* History: <br>*   02-Oct-1991 DarrinM     Created. (in Win32 user) <br>*   17-Mar-1993 JonPa       Rewrote to use RIFF format instead of RAD <br>*   21-Apr-1993 JonPa       Copied it to anifile.c and tweeked it. <br>* <br>\****************************************************************************/ <br>BOOL ReadAniFile( HWND hwnd, HANDLE hf ) { <br> <br>    RTAG tag; <br>    DWORD cbRead; <br>    BOOL fSuccess = FALSE; <br>    JIF *pjifRate = NULL; <br>    DWORD *pseq = NULL; <br>    PFRAME *ppfram = NULL; <br>    int iFrame = 0; <br>    int i; <br> <br>    if (!ReadTag(hf, &amp;tag)) <br>        goto laiFileErr; <br> <br>    /* <br>     * Make sure it's a RIFF ANI file <br>     */ <br>    if (tag.ckID != FOURCC_RIFF) <br>        goto laiFileErr; <br> <br>    /* read the chunk type */ <br>    if(!ReadFile(hf, &amp;tag.ckID, sizeof(tag.ckID), &amp;cbRead, NULL) || <br>            cbRead &lt; sizeof(tag.ckID)) { <br>        goto laiFileErr; <br>    } <br> <br>    if (tag.ckID != FOURCC_ACON) <br>        goto laiFileErr; <br> <br>    /* look for 'anih', 'rate', 'seq ', and 'icon' chunks */ <br>    while( ReadTag(hf, &amp;tag)) { <br> <br>        switch( tag.ckID ) { <br>        case FOURCC_anih: <br>            if (!ReadChunk(hf, &amp;tag, &amp;ganiAcon.anih)) <br>                goto laiFileErr; <br> <br>            if (!(ganiAcon.anih.fl &amp; AF_ICON) || (ganiAcon.anih.cFrames == 0)) <br>                goto laiFileErr; <br> <br>            /* <br>             * Allocate space for the ANIHEADER, and a seq and <br>             * rate table (in case we run into one later). <br>             */ <br> <br>            pjifRate = AllocMem( ganiAcon.anih.cSteps * sizeof(JIF) + <br>                    ganiAcon.anih.cSteps * sizeof(DWORD) + <br>                    ganiAcon.anih.cSteps * sizeof(PFRAME)); <br> <br> <br>            if (pjifRate == NULL) <br>                goto laiFileErr; <br> <br>            pseq = (DWORD *)(pjifRate + ganiAcon.anih.cSteps); <br>            ppfram = (PFRAME *)(pseq + ganiAcon.anih.cSteps); <br> <br>            for( i = 0; i &lt; (int)ganiAcon.anih.cSteps; i++ ) { <br>                pjifRate[i] = ganiAcon.anih.jifRate; <br>                pseq[i] = i; <br>                ppfram[i] = NULL; <br>            } <br>            break; <br> <br> <br>        case FOURCC_rate: <br>            /* <br>             * If we find a rate chunk, read it into its preallocated <br>             * space. <br>             */ <br>            if(!ReadChunk(hf, &amp;tag, (PBYTE)pjifRate)) <br>                goto laiFileErr; <br>            break; <br> <br> <br>        case FOURCC_seq: <br>            /* <br>             * If we find a seq chunk, read it into its preallocated <br>             * space. <br>             */ <br>            if(!ReadChunk(hf, &amp;tag, (PBYTE)pseq)) <br>                goto laiFileErr; <br>            break; <br> <br> <br>        case FOURCC_LIST: { <br>            DWORD cbChunk = PADUP(tag.ckSize); <br> <br>            /* <br>             * See if this list is the 'fram' list of icon chunks <br>             */ <br>            if(!ReadFile(hf, &amp;tag.ckID, sizeof(tag.ckID), &amp;cbRead, NULL) || <br>                    cbRead &lt; sizeof(tag.ckID)) { <br>                goto laiFileErr; <br>            } <br> <br>            cbChunk -= cbRead; <br> <br>            if (tag.ckID == FOURCC_fram) { <br> <br>                while(cbChunk &gt;= sizeof(tag)) { <br>                    if (!ReadTag(hf, &amp;tag)) <br>                        goto laiFileErr; <br> <br>                    cbChunk -= sizeof(tag); <br> <br>                    if(tag.ckID == FOURCC_icon) { <br>                        PFRAME pfrm; <br> <br>                        /* <br>                         * Ok, load the icon/cursor bits, <br>                         */ <br>                        pfrm = ReadIconFromFile(hwnd, hf, tag.ckSize); <br> <br>                        if (pfrm == NULL) { <br>                            goto laiFileErr; <br>                        } <br> <br>                        for( i = 0; i &lt; (int)ganiAcon.anih.cSteps; i++ ) { <br>                            if (pseq[i] == (DWORD)iFrame) { <br>                                ppfram[i] = pfrm; <br>                            } <br>                        } <br> <br>                        iFrame++; <br> <br>                    } else { <br>                        /* <br>                         * Unknown chunk in fram list, just ignore it <br>                         */ <br>                        SkipChunk(hf, &amp;tag); <br>                    } <br> <br>                    cbChunk -= PADUP(tag.ckSize); <br>                } <br>            } else if (tag.ckID == FOURCC_INFO) { <br>                /* now look for INAM and IART chunks */ <br> <br>                while( cbChunk &gt;= sizeof(tag) ) { <br> <br>                    if (!ReadTag(hf, &amp;tag)) <br>                        goto laiFileErr; <br> <br>                    cbChunk -= sizeof(tag); <br> <br>                    switch( tag.ckID ) { <br>                    case FOURCC_INAM: <br>                        if (cbChunk &lt; tag.ckSize || <br>                                !ReadChunkN(hf, &amp;tag, ganiAcon.azTitle, <br>                                                sizeof(ganiAcon.azTitle))) <br>                            goto laiFileErr; <br> <br>                        cbChunk -= PADUP(tag.ckSize); <br>                        break; <br> <br>                    case FOURCC_IART: <br>                        if (cbChunk &lt; tag.ckSize || <br>                                !ReadChunkN(hf, &amp;tag, ganiAcon.azCreator, <br>                                        sizeof(ganiAcon.azCreator))) <br>                            goto laiFileErr; <br> <br>                        cbChunk -= PADUP(tag.ckSize); <br>                        break; <br> <br>                    default: <br>                        if (!SkipChunk( hf, &amp;tag )) <br>                            goto laiFileErr; <br> <br>                        cbChunk -= PADUP(tag.ckSize); <br>                        break; <br>                    } <br>                } <br> <br>            } else { <br>                /* <br>                 * Not the fram list or the INFO list.  Skip <br>                 * the rest of this chunk.  (Don't forget that we have <br>                 * already skipped one dword!) <br>                 */ <br>                tag.ckSize = cbChunk; <br>                SkipChunk(hf, &amp;tag); <br>                break; <br>            } <br> <br>            break; <br>        } <br> <br> <br> <br>        default: <br>            /* <br>             * We're not interested in this chunk, skip it. <br>             */ <br>            if(!SkipChunk(hf, &amp;tag)) <br>                goto laiFileErr; <br>            break; <br> <br>        } <br> <br>    } <br> <br>    /* <br>     * Update the frame count incase we coalesced some frames while reading <br>     * in the file. <br>     */ <br>    ganiAcon.anih.cFrames = iFrame; <br> <br>    /* <br>     * Now build up the listbox <br>     */ <br> <br>    for( i = 0; i &lt; (int)ganiAcon.anih.cSteps; i++ ) { <br>        PSTEP ps; <br> <br>        ps = NewStep(); <br>        if (ps == NULL) <br>            goto laiFileErr; <br> <br>        ps-&gt;jif = pjifRate[i]; <br>        LinkStepFrame(ps, ppfram[i]); <br> <br>        SendDlgItemMessage(hwnd, DLG_MAIN_FRAMELIST, LB_INSERTSTRING, i, <br>                (LPARAM)ps); <br>    } <br> <br>    SetDlgItemText(hwnd, DLG_MAIN_TITLE, ganiAcon.azTitle); <br>    SetDlgItemText(hwnd, DLG_MAIN_AUTHOR, ganiAcon.azCreator); <br> <br>    SendDlgItemMessage(hwnd, DLG_MAIN_PREVIEW, PM_NEWCURSOR, 0, 0); <br>    fSuccess = TRUE; <br> <br>laiFileErr: <br> <br>    if (pjifRate != NULL) <br>        FreeMem(pjifRate); <br> <br>    if (!fSuccess) <br>        NewAniCursor(hwnd); <br> <br>    CloseHandle(hf); <br> <br>    return fSuccess; <br>} <br> <br> <br> <br>/***************************************************************************\ <br>* DWORD CalcCheckSum( PBYTE pb ); <br>* <br>* <br>* History: <br>* <br>* 23-Apr-1993 JonPa     Created. <br>\***************************************************************************/ <br>DWORD CalcCheckSum( PBYTE pb, DWORD cb ) { <br>    DWORD dw = 0; <br> <br>    while(cb--) <br>        dw += (DWORD)*pb++; <br> <br>    return dw; <br>} <br> <br>/***************************************************************************\ <br>* ReadTag, ReadChunk, SkipChunk <br>* <br>* Some handy functions for reading RIFF files. <br>* <br>* History: <br>* 10-02-91 DarrinM      Created. <br>* 03-25-93 Jonpa        Changed to use RIFF format instead of ASDF <br>* 23-Apr-1993 JonPa     Copied from Win NT USER. <br>\***************************************************************************/ <br>BOOL ReadTag( <br>    HANDLE hf, <br>    PRTAG ptag) <br>{ <br>    DWORD cbActual; <br> <br>    ptag-&gt;ckID = ptag-&gt;ckSize = 0L; <br> <br>    if (!ReadFile(hf, ptag, sizeof(RTAG), &amp;cbActual, NULL) || <br>            (cbActual != sizeof(RTAG))) <br>        return FALSE; <br> <br>    /* no need to align file pointer since RTAG is already word aligned */ <br>    return TRUE; <br>} <br> <br> <br>BOOL ReadChunk( <br>    HANDLE hf, <br>    PRTAG ptag, <br>    PVOID pv) <br>{ <br>    DWORD cbActual; <br> <br>    if (!ReadFile(hf, pv, ptag-&gt;ckSize, &amp;cbActual, NULL) || <br>            (cbActual != ptag-&gt;ckSize)) <br>        return FALSE; <br> <br>    /* WORD align file pointer */ <br>    if( ptag-&gt;ckSize &amp; 1 ) <br>        SetFilePointer(hf, 1, NULL, FILE_CURRENT); <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL ReadChunkN( <br>    HANDLE hf, <br>    PRTAG ptag, <br>    PVOID pv, <br>    DWORD cbMax) <br>{ <br>    DWORD cbActual; <br>    DWORD cbRead = min( cbMax, ptag-&gt;ckSize ); <br> <br>    if (!ReadFile(hf, pv, ptag-&gt;ckSize, &amp;cbActual, NULL) || <br>            (cbActual != cbRead)) <br>        return FALSE; <br> <br>    /* WORD align file pointer */ <br> <br>    cbRead = ptag-&gt;ckSize - cbActual; <br> <br>    if( ptag-&gt;ckSize &amp; 1 ) <br>        cbRead++; <br> <br>    return SetFilePointer(hf, cbRead, NULL, FILE_CURRENT) != 0xFFFFFFFF; <br>} <br> <br>BOOL SkipChunk( <br>    HANDLE hf, <br>    PRTAG ptag) <br>{ <br>    /* Round ptag-&gt;ckSize up to nearest word boundary to maintain alignment */ <br>    return SetFilePointer(hf, PADUP(ptag-&gt;ckSize), NULL, FILE_CURRENT) != <br>            0xFFFFFFFFL; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: VOID GetTempCursorFileName( szFileName ); <br>* <br>*     PURPOSE:  Create a temporary .cur filename <br>* <br>* <br>* History: <br>*   22-Apr-1993 JonPa   Created it <br>* <br>\****************************************************************************/ <br>BOOL GetTempCursorFileName( LPTSTR pszName ) { <br>    TCHAR szPath[MAX_PATH]; <br> <br>    if( GetTempPath( MAX_PATH, szPath ) &gt;= MAX_PATH ) <br>        lstrcpy( pszName, TEXT(".") ); <br> <br> <br>    return GetTempFileName(szPath, TEXT("ae"), 0, pszName) != 0; <br>} <br> <br>/****************************************************************************\ <br>* <br>*     FUNCTION: BOOL SaveAniFile( HWND hwnd, HANDLE hf ) <br>* <br>*     PURPOSE: <br>&amp; <br>*   Saves an animatied cursor to a RIFF file.  The RIFF file format for <br>*   animated cursors looks like this: <br>* <br>*   RIFF( 'ACON' <br>*       [LIST( 'INFO' <br>*           [INAM( &lt;name&gt; )] <br>*           [IART( &lt;artist&gt; )] <br>*       )] <br>*       anih( &lt;anihdr&gt; ) <br>*       [rate( &lt;rateinfo&gt; )  ] <br>*       ['seq '( &lt;seq_info&gt; )] <br>*       LIST( 'fram' icon( &lt;icon_file&gt; ) ) <br>*   ) <br>* <br>* <br>* History: <br>*   29-Apr-1993 JonPa   Created it. <br>* <br>\****************************************************************************/ <br>BOOL SaveAniFile( HWND hwnd, HANDLE hf ) { <br>    int cSteps, i; <br>    int cFrames; <br>    PFRAME pf; <br>    DWORD cbFile, cbFram, cbINFO, cbTitle, cbAuthor; <br>    BOOL fRate, fSeq; <br>    RTAG rtag; <br>    PJIF pjif; <br>    DWORD *pseq; <br>    PFRAME *pfrm; <br> <br>    fRate = fSeq = FALSE; <br>    cbINFO = cbFram = cbFile = cbTitle = cbAuthor = 0; <br> <br>    PausePreview(hwnd, DLG_MAIN_PREVIEW); <br> <br>    cSteps = GetStepCount(hwnd); <br> <br>    if( cSteps == LB_ERR ) { <br>        FmtMessageBox( ghwndMain, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, <br>                TRUE, MSG_OUTOFRESOUCES ); <br>        return FALSE; <br>    } <br> <br>    cFrames = 0; <br>    for( pf = gpfrmFrames; pf != NULL; pf = pf-&gt;pfrmNext ) { <br>        pf-&gt;iFrame = -1; <br>        cFrames++; <br>    } <br> <br>    ganiAcon.anih.cSteps = cSteps; <br> <br>    pjif = AllocMem( (sizeof(JIF) + sizeof(DWORD) + sizeof(PFRAME)) * cSteps ); <br> <br>    if(pjif == NULL) <br>        return FALSE; <br> <br>    pseq = (DWORD *)&amp;pjif[cSteps]; <br>    pfrm = (PFRAME *)&amp;pseq[cSteps]; <br> <br>    cFrames = 0; <br> <br>    for( i = 0; i &lt; cSteps; i++ ) { <br>        PSTEP ps; <br> <br>        ps = GetStep(hwnd, i); <br> <br>        if( IsValidPS(ps) ) { <br> <br>            if (ps-&gt;pfrmFrame-&gt;iFrame == -1) { <br> <br>                cbFram += sizeof(RTAG); <br>                cbFram += PADUP(ps-&gt;pfrmFrame-&gt;rtag.ckSize); <br> <br>                ps-&gt;pfrmFrame-&gt;iFrame = cFrames; <br>                pfrm[cFrames++] = ps-&gt;pfrmFrame; <br> <br>            } else <br>                fSeq = TRUE; <br> <br>            pseq[i] = ps-&gt;pfrmFrame-&gt;iFrame; <br> <br>            if ((pjif[i] = ps-&gt;jif) != ganiAcon.anih.jifRate) { <br>                fRate = TRUE; <br>            } <br>        } <br>    } <br> <br>    ganiAcon.anih.cbSizeof = sizeof(ganiAcon.anih); <br>    ganiAcon.anih.cFrames = cFrames; <br>    ganiAcon.anih.fl = AF_ICON | (fSeq ? AF_SEQUENCE : 0); <br> <br>    cbTitle = GetDlgItemTextA(hwnd, DLG_MAIN_TITLE, ganiAcon.azTitle, <br>                            COUNTOF(ganiAcon.azTitle)); <br> <br>    cbAuthor = GetDlgItemTextA(hwnd, DLG_MAIN_AUTHOR, ganiAcon.azCreator, <br>                            COUNTOF(ganiAcon.azCreator)); <br> <br>    /* <br>     * At this point, cbFram == the size required by all the frames, <br>     * add in the rate, seq, anih, and INFO list sizes as well as <br>     * all the other overhead. <br>     */ <br> <br>    cbFram += sizeof(FOURCC);     //fram type <br> <br>    cbFile = cbFram; <br> <br>    cbFile += sizeof(FOURCC) +    //ACON type <br>                    sizeof(RTAG) +      //anih tag <br>                        PADUP(sizeof(ANIHEADER)) + <br>                    sizeof(RTAG);       //LIST tag (for fram list) <br> <br> <br>    if( cbTitle || cbAuthor) { <br>        /* <br>         * Remember, azCreator, and azTitle are ANSI strings! <br>         */ <br>        if( cbTitle ) { <br>            cbTitle += 1; //add in ASCIIZ terminator <br>            cbINFO +=   sizeof(RTAG) +     //INAM tag <br>                        PADUP( cbTitle * sizeof(char)); <br>        } <br> <br>        if (cbAuthor) { <br>            cbAuthor += 1; //add in ASCIIZ terminator <br>            cbINFO +=   sizeof(RTAG) +     //IART tag <br>                        PADUP(cbAuthor * sizeof(char)); <br>        } <br> <br>        cbINFO +=  sizeof(FOURCC);      //INFO type <br> <br>        cbFile +=   sizeof(RTAG) +      //LIST tag <br>                    cbINFO; <br>    } <br> <br> <br>    if (fSeq) { <br>        cbFile += sizeof(RTAG) +    //seq tag <br>                    PADUP(cSteps * sizeof(DWORD)); <br>    } <br> <br>    if (fRate) { <br>        cbFile += sizeof(RTAG) +    //rate tag <br>                    PADUP(cSteps * sizeof(JIF)); <br>    } <br> <br>    /* <br>     * Now we have all the structures built in memory, it's time to <br>     * write them out in RIFF ACON format! <br>     */ <br>    rtag.ckID = FOURCC_RIFF; <br>    rtag.ckSize = cbFile; <br> <br>    RET_CLOSE_IF_ERR( WriteTag(hf, &amp;rtag), hf ); <br> <br>    RET_CLOSE_IF_ERR( WriteType(hf, FOURCC_ACON), hf ); <br> <br>    if( cbTitle || cbAuthor) { <br>        rtag.ckID = FOURCC_LIST; <br>        rtag.ckSize = cbINFO; <br> <br>        RET_CLOSE_IF_ERR( WriteTag(hf, &amp;rtag), hf ); <br> <br>        RET_CLOSE_IF_ERR( WriteType(hf, FOURCC_INFO), hf ); <br> <br>        if (cbTitle) { <br>            rtag.ckID = FOURCC_INAM; <br>            rtag.ckSize = cbTitle; <br>            RET_CLOSE_IF_ERR( WriteTagData(hf, &amp;rtag, ganiAcon.azTitle), hf ); <br>        } <br> <br>        if (cbAuthor) { <br>            rtag.ckID = FOURCC_IART; <br>            rtag.ckSize = cbAuthor; <br>            RET_CLOSE_IF_ERR( WriteTagData(hf, &amp;rtag, ganiAcon.azCreator), hf ); <br>        } <br>    } <br> <br>    /* write anih */ <br>    rtag.ckID = FOURCC_anih; <br>    rtag.ckSize = sizeof(ganiAcon.anih); <br> <br>    RET_CLOSE_IF_ERR( WriteTagData(hf, &amp;rtag, &amp;(ganiAcon.anih)), hf ); <br> <br>    /* if rate then write it */ <br>    if (fRate) { <br>        rtag.ckID = FOURCC_rate; <br>        rtag.ckSize = cSteps * sizeof(JIF); <br> <br>        RET_CLOSE_IF_ERR( WriteTagData(hf, &amp;rtag, pjif), hf ); <br>    } <br> <br>    /* if seq, then write it */ <br>    if (fSeq) { <br>        rtag.ckID = FOURCC_seq; <br>        rtag.ckSize = cSteps * sizeof(DWORD); <br> <br>        RET_CLOSE_IF_ERR( WriteTagData(hf, &amp;rtag, pseq), hf ); <br>    } <br> <br>    /* write the fram list */ <br>    rtag.ckID = FOURCC_LIST; <br>    rtag.ckSize = cbFram; <br> <br>    RET_CLOSE_IF_ERR( WriteTag(hf, &amp;rtag), hf ); <br>    RET_CLOSE_IF_ERR( WriteType(hf, FOURCC_fram), hf ); <br> <br>    for( i = 0; i &lt; cFrames; i++ ) { <br>        RET_CLOSE_IF_ERR( WriteTagData(hf, &amp;(pfrm[i]-&gt;rtag), pfrm[i]-&gt;abIcon), <br>                hf); <br>    } <br> <br>    /* Close the file */ <br>    CloseHandle(hf); <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************\ <br>* WriteTag, WriteType, WriteTagData <br>* <br>* Some handy functions for writing RIFF files. <br>* <br>* History: <br>*   30-Apr-1993 JonPa   Created them. <br>\***************************************************************************/ <br>BOOL WriteTag(HANDLE hf, PRTAG prtag) { <br>    DWORD cbWritten; <br> <br>    return (WriteFile(hf, prtag, sizeof(RTAG), &amp;cbWritten, NULL) &amp;&amp; <br>            cbWritten == sizeof(RTAG)); <br>} <br> <br>BOOL WriteType(HANDLE hf, FOURCC ckID ) { <br>    DWORD cbWritten; <br> <br>    return (WriteFile(hf, &amp;ckID, sizeof(FOURCC), &amp;cbWritten, NULL) &amp;&amp; </code></pre>
<p>
</p>
<pre><code>cbWritten == sizeof(FOURCC)); <br>} <br> <br>BOOL WriteTagData(HANDLE hf, PRTAG prtag, VOID *pvData ) { <br>    DWORD cbWritten; <br>    DWORD cbWrite = PADUP(prtag-&gt;ckSize); <br> <br>    return  WriteTag(hf, prtag) &amp;&amp; WriteFile(hf, pvData, cbWrite, <br>            &amp;cbWritten, NULL) &amp;&amp; cbWritten == cbWrite; <br>} <br> <br> <br> <br> <br>/***************************************************************************\ <br>* VOID SaveFile(HWND hwnd, BOOL fPrompt) <br>* <br>* Conditionally Prompt the user for a name and then save the file <br>* <br>* History: <br>*   04-May-1993 JonPa   It <br>\***************************************************************************/ <br>VOID SaveFile(HWND hwnd, BOOL fPrompt) { <br>    TCHAR szFileTitle[MAX_PATH]; <br>    HANDLE hf; <br> <br>    szFileTitle[0] = TEXT('\0'); <br> <br>    if (fPrompt || ganiAcon.szFile[0] == TEXT('\0')) { <br>tryagain: <br>        if (!PromptForFile(hwnd, COUNTOF(szFileTitle), szFileTitle, <br>                COUNTOF(ganiAcon.szFile), ganiAcon.szFile, gpszAniFilter, <br>                NULL, TRUE)) { <br>            return; <br>        } <br>    } <br> <br>    hf = CreateFile( ganiAcon.szFile, GENERIC_WRITE, 0, NULL, <br>            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); <br> <br>    if (hf == INVALID_HANDLE_VALUE) { <br>        FmtMessageBox(hwnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, TRUE, <br>                MSG_CANTCREATEFILE, ganiAcon.szFile); <br> <br>        goto tryagain; <br>    } <br> <br>    if( !SaveAniFile(hwnd, hf) ) { <br>        FmtMessageBox(hwnd, TITL_ERROR, NULL, MB_OK | MB_ICONSTOP, TRUE, <br>                MSG_FILEWRITEERR, ganiAcon.szFile); <br>        return; <br>    } <br> <br>    if (szFileTitle[0] != TEXT('\0')) <br>        SetWindowFileTitle(hwnd, szFileTitle); <br> <br>    ganiAcon.fDirty = FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
