<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PFMON.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5461"></a>PFMON.C</h2>
<pre><code>/*++ <br> <br>Copyright 1995 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    pfmon.c <br> <br>Abstract: <br> <br>    USAGE: pfmon [pfmon switches] command-line-of-application <br> <br> <br>Platform: <br> <br>   PFMON will run only on Windows NT. <br>    It requires psapi.dll which is distributed with the Win32 SDK. <br> <br>Author: <br> <br>    Mark Lucovsky (markl) 26-Jan-1995 <br> <br>--*/ <br> <br>#include "pfmonp.h" <br> <br>#define WORKING_SET_BUFFER_ENTRYS 4096 <br>PSAPI_WS_WATCH_INFORMATION WorkingSetBuffer[WORKING_SET_BUFFER_ENTRYS]; <br> <br>#define MAX_SYMNAME_SIZE  1024 <br>CHAR PcSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE]; <br>PIMAGEHLP_SYMBOL PcSymbol = (PIMAGEHLP_SYMBOL) PcSymBuffer; <br>CHAR VaSymBuffer[sizeof(IMAGEHLP_SYMBOL)+MAX_SYMNAME_SIZE]; <br>PIMAGEHLP_SYMBOL VaSymbol = (PIMAGEHLP_SYMBOL) VaSymBuffer; <br> <br> <br> <br>int <br>main () <br>{ <br>    CHAR Line[256]; <br> <br>    if (!InitializePfmon()) { <br>        ExitProcess( 1 ); <br>        } <br>    else { <br>        DebugEventLoop(); <br>        sprintf(Line,"\n PFMON: Total Faults %d  (KM %d UM %d Soft %d, Hard %d, Code %d, Data %d)\n", <br>            TotalSoftFaults + TotalHardFaults, <br>            TotalKernelFaults, <br>            TotalUserFaults, <br>            TotalSoftFaults, <br>            TotalHardFaults, <br>            TotalCodeFaults, <br>            TotalDataFaults <br>            ); <br>        fprintf(stdout,"%s",Line); <br>        if ( LogFile ) { <br>            fprintf(LogFile,"%s",Line); <br>            fclose(LogFile); <br>            } <br>        ExitProcess( 0 ); <br>        } <br> <br>    return 0; <br>} <br> <br>VOID <br>ProcessPfMonData( <br>    VOID <br>    ) <br>{ <br>    BOOL b; <br>    BOOL DidOne; <br>    INT i; <br>    PMODULE_INFO PcModule; <br>    PMODULE_INFO VaModule; <br>    DWORD PcOffset; <br>    DWORD VaOffset; <br>    CHAR PcLine[256]; <br>    CHAR VaLine[256]; <br>    CHAR PcModuleStr[256]; <br>    CHAR VaModuleStr[256]; <br>    LPVOID Pc; <br>    LPVOID Va; <br>    BOOL SoftFault; <br>    BOOL CodeFault; <br>    BOOL KillLog; <br>    static int cPfCnt = 0; <br> <br> <br> <br>    PcSymbol-&gt;SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL); <br>    PcSymbol-&gt;MaxNameLength = MAX_SYMNAME_SIZE; <br>    VaSymbol-&gt;SizeOfStruct  = sizeof(IMAGEHLP_SYMBOL); <br>    VaSymbol-&gt;MaxNameLength = MAX_SYMNAME_SIZE; <br> <br>    //Get the buffer of recent page faults from the process's data structure <br>    b = GetWsChanges(hProcess,&amp;WorkingSetBuffer[0],sizeof(WorkingSetBuffer)); <br> <br>    if ( b ) { <br>        DidOne = FALSE; <br>        i = 0; <br>        while (WorkingSetBuffer[i].FaultingPc) { <br>            if ( WorkingSetBuffer[i].FaultingVa ) { <br>                Pc = WorkingSetBuffer[i].FaultingPc; <br>                Va = WorkingSetBuffer[i].FaultingVa; <br> <br> <br>                if ( (DWORD)Pc &amp; 0x80000000 ) { <br>                    TotalKernelFaults++; <br>                    if ( !fKernel ) { <br>                        i++; <br>                        continue; <br>                        } <br>                    } <br>                else { <br>                    TotalUserFaults++; <br>                    if ( fKernelOnly ) { <br>                        i++; <br>                        continue; <br>                        } <br>                    } <br> <br>                //Check least sig bit which stores whether it was a hard <br>                //or soft fault <br> <br>                if ( (ULONG)Va &amp; 1 ) { <br>                    TotalSoftFaults++; <br>                    SoftFault = TRUE; <br>                    } <br>                else { <br>                    TotalHardFaults++; <br>                    SoftFault = FALSE; <br>                    } <br> <br>                Va = (LPVOID)( (ULONG)Va &amp; 0xfffffffe); <br>                if ( (LPVOID)((ULONG)Pc &amp; 0xfffffffe) == Va ) { <br>                    CodeFault = TRUE; <br>                    TotalCodeFaults++; <br>                    } <br>                else { <br>                    TotalDataFaults++; <br>                    CodeFault = FALSE; <br>                    } <br> <br> <br>                PcModule = FindModuleContainingAddress(Pc); <br>                VaModule = FindModuleContainingAddress(Va); <br> <br>                if ( PcModule ) { <br>                    PcModule-&gt;NumberCausedFaults++; <br>                    sprintf(PcModuleStr, "%s", PcModule-&gt;DebugInfo-&gt;ImageFileName); <br>                    } <br>                else { <br>                    PcModuleStr[0] = '\0'; <br>                    } <br> <br>                //Va was either a code reference or global <br>                //reference as opposed to a heap reference <br> <br>                if ( VaModule ) { <br>                    if ( SoftFault ) { <br>                        VaModule-&gt;NumberFaultedSoftVas++; <br>                        } <br>                    else { <br>                        VaModule-&gt;NumberFaultedHardVas++; <br>                        } <br>                    sprintf(VaModuleStr, "%s", VaModule-&gt;DebugInfo-&gt;ImageFileName); <br>                    } <br>                else <br>                    VaModuleStr[0] = '\0'; <br> <br>                if (SymGetSymFromAddr(hProcess, (DWORD)Pc, &amp;PcOffset, PcSymbol)) { <br>                    if ( PcOffset ) { <br>                        sprintf(PcLine,"%s+0x%x",PcSymbol-&gt;Name,PcOffset); <br>                        } <br>                    else { <br>                        sprintf(PcLine,"%s",PcSymbol-&gt;Name); <br>                        } <br>                    } <br>                else { <br>                    sprintf(PcLine,"0x%08x : ",Pc); <br>                    } <br> <br>                if (SymGetSymFromAddr(hProcess, (DWORD)Va, &amp;VaOffset, VaSymbol)) { <br>                    if ( VaOffset ) { <br>                        sprintf(VaLine,"%s+0x%x",VaSymbol-&gt;Name,VaOffset); <br>                        } <br>                    else { <br>                        sprintf(VaLine,"%s",VaSymbol-&gt;Name); <br>                        } <br>                    } <br>                else { <br>                    sprintf(VaLine,"0x%08x",Va); <br>                    } <br> <br>                KillLog = FALSE; <br> <br>                if ( fCodeOnly &amp;&amp; !CodeFault ) { <br>                    KillLog = TRUE; <br>                    } <br>                if ( fHardOnly &amp;&amp; SoftFault ) { <br>                    KillLog = TRUE; <br>                    } <br> <br>                if ( !KillLog ) { <br>                    if ( !fLogOnly ) { <br>                        if (!fDatabase) { <br>                            fprintf(stdout,"%s%s : %s\n",SoftFault ? "SOFT: " : "HARD: ",PcLine,VaLine); <br>                            } <br>                        else { <br> <br>                            //Addresses are printed out in decimal <br>                            //because most databases don't support <br>                            //hex formats <br> <br>                            fprintf(stdout,"%8d\t%s\t%s\t%s\t%u\t%s\t%s\t%u\n", <br>                                    cPfCnt, <br>                                    SoftFault ? "SOFT" : "HARD", <br>                                    PcModuleStr, <br>                                    PcLine, <br>                                    (DWORD) Pc, <br>                                    VaModuleStr, <br>                                    VaLine, <br>                                    (DWORD) Va); <br>                            } <br>                        } <br> <br>                    if ( LogFile ) { <br>                        if (!fDatabase) { <br>                            fprintf(LogFile,"%s%s : %s\n",SoftFault ? "SOFT: " : "HARD: ",PcLine,VaLine); <br>                            } <br>                        else { <br>                            fprintf(LogFile,"%8d\t%s\t%s\t%s\t%u\t%s\t%s\t%u\n", <br>                                    cPfCnt, <br>                                    SoftFault ? "SOFT" : "HARD", <br>                                    PcModuleStr, <br>                                    PcLine, <br>                                    (DWORD) Pc, <br>                                    VaModuleStr, <br>                                    VaLine, <br>                                    (DWORD) Va); <br>                            } <br>                        } <br>                    DidOne = TRUE; <br>                    cPfCnt++; <br>                    } <br>                } <br>            i++; <br>            } <br> <br>        if ( DidOne ) { <br>            if ( !fLogOnly  &amp;&amp; !fDatabase) { <br>                fprintf(stdout,"\n"); <br>                } <br>            } <br> <br>        //If the buffer overflowed then a non-zero value for <br>        //the Va was stored in the last record. <br>        if ((ULONG)WorkingSetBuffer[i].FaultingVa) <br>            fprintf(stdout,"Warning: Page fault buffer has overflowed\n"); <br> <br> <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
