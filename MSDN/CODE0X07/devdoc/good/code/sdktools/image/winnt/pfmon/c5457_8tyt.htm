<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBUG.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5465"></a>DEBUG.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    debug.c <br> <br>Abstract: <br> <br>    Main debug loop for pfmon <br> <br>Author: <br> <br>    Mark Lucovsky (markl) 26-Jan-1995 <br> <br>Revision History: <br> <br>--*/ <br> <br>#include "pfmonp.h" <br> <br>DWORD <br>DebugEventHandler( <br>    LPDEBUG_EVENT DebugEvent <br>    ); <br> <br>VOID <br>DebugEventLoop( VOID ) <br>{ <br>    DEBUG_EVENT DebugEvent; <br>    DWORD ContinueStatus; <br>    DWORD OldPriority; <br> <br>    // <br>    // We want to process debug events quickly <br>    // <br> <br>    OldPriority = GetPriorityClass( GetCurrentProcess() ); <br>    SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS ); <br> <br>    do { <br>retry_debug_wait: <br>        ProcessPfMonData(); <br>        if (!WaitForDebugEvent( &amp;DebugEvent, 500 )) { <br>            if ( GetLastError() == ERROR_SEM_TIMEOUT ) { <br>                goto retry_debug_wait; <br>                } <br>            DeclareError( PFMON_WAITDEBUGEVENT_FAILED, GetLastError() ); <br>            ExitProcess( 1 ); <br>            } <br>        ProcessPfMonData(); <br>        if ( fVerbose ) { <br>            if (DebugEvent.dwDebugEventCode == EXCEPTION_DEBUG_EVENT) { <br>                fprintf(stderr,"Debug exception event - Code: %x  Address: %x  Info: [%u] %x %x %x %x\n", <br>                        DebugEvent.u.Exception.ExceptionRecord.ExceptionCode, <br>                        DebugEvent.u.Exception.ExceptionRecord.ExceptionAddress, <br>                        DebugEvent.u.Exception.ExceptionRecord.NumberParameters, <br>                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 0 ], <br>                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 1 ], <br>                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 2 ], <br>                        DebugEvent.u.Exception.ExceptionRecord.ExceptionInformation[ 3 ] <br>                        ); <br>                } <br>            else { <br>                fprintf(stderr,"Debug %x event\n", DebugEvent.dwDebugEventCode); <br>                } <br>            } <br> <br>        ContinueStatus = DebugEventHandler( &amp;DebugEvent ); <br> <br>        if ( fVerbose ) { <br>            fprintf(stderr,"Continue Status %x\n", ContinueStatus); <br>            } <br> <br>        if (!ContinueDebugEvent( DebugEvent.dwProcessId, <br>                                 DebugEvent.dwThreadId, <br>                                 ContinueStatus <br>                               ) <br>           ) { <br>            DeclareError( PFMON_CONTDEBUGEVENT_FAILED, GetLastError() ); <br>            ExitProcess( 1 ); <br>            } <br>        } <br>    while (!IsListEmpty( &amp;ProcessListHead )); <br> <br> <br>    // <br>    // Drop back to old priority to interact with user. <br>    // <br> <br>    SetPriorityClass( GetCurrentProcess(), OldPriority ); <br>} <br> <br>DWORD <br>DebugEventHandler( <br>    LPDEBUG_EVENT DebugEvent <br>    ) <br>{ <br>    DWORD ContinueStatus; <br>    PPROCESS_INFO Process; <br>    PTHREAD_INFO Thread; <br>    CONTEXT Context; <br>    PCONTEXT pContext; <br> <br> <br>    ContinueStatus = (DWORD)DBG_CONTINUE; <br>    if (FindProcessAndThreadForEvent( DebugEvent, &amp;Process, &amp;Thread )) { <br>        switch (DebugEvent-&gt;dwDebugEventCode) { <br>            case CREATE_PROCESS_DEBUG_EVENT: <br>                // <br>                // Create process event includes first thread of process <br>                // as well.  Remember process and thread in our process tree <br>                // <br> <br>                if (AddProcess( DebugEvent, &amp;Process )) { <br>                    AddModule( DebugEvent ); <br>                    AddThread( DebugEvent, Process, &amp;Thread ); <br>                    } <br>                break; <br> <br>            case EXIT_PROCESS_DEBUG_EVENT: <br>                // <br>                // Exit process event includes last thread of process <br>                // as well.  Remove process and thread from our process tree <br>                // <br> <br>                if (DeleteThread( Process, Thread )) { <br>                    DeleteProcess( Process ); <br>                    } <br>                break; <br> <br>            case CREATE_THREAD_DEBUG_EVENT: <br>                // <br>                // Create thread.  Remember thread in our process tree. <br>                // <br> <br>                AddThread( DebugEvent, Process, &amp;Thread ); <br>                break; <br> <br>            case EXIT_THREAD_DEBUG_EVENT: <br>                // <br>                // Exit thread.  Remove thread from our process tree. <br>                // <br> <br>                DeleteThread( Process, Thread ); <br>                break; <br> <br>            case LOAD_DLL_DEBUG_EVENT: <br>                AddModule( DebugEvent ); <br>                break; <br> <br>            case UNLOAD_DLL_DEBUG_EVENT: <br>                break; <br> <br>            case OUTPUT_DEBUG_STRING_EVENT: <br>            case RIP_EVENT: <br>                // <br>                // Ignore these <br>                // <br>                break; <br> <br>            case EXCEPTION_DEBUG_EVENT: <br>                // <br>                // Assume we wont handle this exception <br>                // <br> <br>                ContinueStatus = (DWORD)DBG_CONTINUE; <br>                switch (DebugEvent-&gt;u.Exception.ExceptionRecord.ExceptionCode) { <br>                    // <br>                    // Breakpoint exception. <br>                    // <br> <br>                    case STATUS_BREAKPOINT: <br>                            Context.ContextFlags = CONTEXT_FULL; <br> <br>                            if (!GetThreadContext( Thread-&gt;Handle, &amp;Context )) { <br>                                fprintf(stderr,"Failed to get context for thread %x (%x) - %u\n", Thread-&gt;Id, Thread-&gt;Handle, GetLastError()); <br>                                ExitProcess(1); <br>                                } <br>                            pContext = &amp;Context; <br>                            CONTEXT_TO_PROGRAM_COUNTER(pContext) = (ULONG)((PCHAR)DebugEvent-&gt;u.Exception.ExceptionRecord.ExceptionAddress + BPSKIP); <br> <br>                            if (!SetThreadContext( Thread-&gt;Handle, &amp;Context )) { <br>                                fprintf(stderr,"Failed to set context for thread %x (%x) - %u\n", Thread-&gt;Id, Thread-&gt;Handle, GetLastError()); <br>                                ExitProcess(1); <br>                                } <br> <br>                        break; <br> <br>                    default: <br>                        ContinueStatus = (DWORD) DBG_EXCEPTION_NOT_HANDLED; <br>                        if ( fVerbose ) { <br>                            fprintf(stderr,"Unknown exception: %08x at %08x\n", <br>                                    DebugEvent-&gt;u.Exception.ExceptionRecord.ExceptionCode, <br>                                    DebugEvent-&gt;u.Exception.ExceptionRecord.ExceptionAddress <br>                                    ); <br>                            } <br>                        break; <br>                    } <br>                break; <br> <br>            default: <br>                break; <br>            } <br>        } <br>    return( ContinueStatus ); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
