<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROCESS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5463"></a>PROCESS.C</h2>
<pre><code>/*++ <br> <br>Copyright 1995 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    process.c <br> <br>Abstract: <br> <br>    This module maintains state about each process/thread created by the application <br>    pfmon program. <br> <br>Author: <br> <br>    Mark Lucovsky (markl) 26-Jan-1995 <br> <br>Revision History: <br> <br>--*/ <br> <br>#include "pfmonp.h" <br> <br>BOOL <br>AddProcess( <br>    LPDEBUG_EVENT DebugEvent, <br>    PPROCESS_INFO *ReturnedProcess <br>    ) <br>{ <br>    PPROCESS_INFO Process; <br> <br>    Process = LocalAlloc(LMEM_ZEROINIT, sizeof( *Process ) ); <br>    if (Process == NULL) { <br>        return FALSE; <br>        } <br> <br>    Process-&gt;Id = DebugEvent-&gt;dwProcessId; <br>    Process-&gt;Handle = DebugEvent-&gt;u.CreateProcessInfo.hProcess; <br>    InitializeListHead( &amp;Process-&gt;ThreadListHead ); <br>    InsertTailList( &amp;ProcessListHead, &amp;Process-&gt;Entry ); <br>    *ReturnedProcess = Process; <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>DeleteProcess( <br>    PPROCESS_INFO Process <br>    ) <br>{ <br>    PLIST_ENTRY Next, Head; <br>    PTHREAD_INFO Thread; <br>    PMODULE_INFO Module; <br>    CHAR Line[256]; <br> <br>    RemoveEntryList( &amp;Process-&gt;Entry ); <br> <br>    Head = &amp;Process-&gt;ThreadListHead; <br>    Next = Head-&gt;Flink; <br>    while (Next != Head) { <br>        Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry ); <br>        Next = Next-&gt;Flink; <br>        DeleteThread( Process, Thread ); <br>        } <br> <br>    LocalFree( Process ); <br>    fprintf(stdout,"\n"); <br> <br>    Next = ModuleListHead.Flink; <br>    while ( Next != &amp;ModuleListHead ) { <br>        Module = CONTAINING_RECORD(Next,MODULE_INFO,Entry); <br> <br> <br>        sprintf(Line,"%16s Caused %6d faults had %6d Soft %6d Hard faulted VA's\n", <br>            Module-&gt;DebugInfo-&gt;ImageFileName, <br>            Module-&gt;NumberCausedFaults, <br>            Module-&gt;NumberFaultedSoftVas, <br>            Module-&gt;NumberFaultedHardVas <br>            ); <br>        if ( !fLogOnly ) { <br>            fprintf(stdout,"%s",Line); <br>            } <br>        if ( LogFile ) { <br>            fprintf(LogFile,"%s",Line); <br>            } <br> <br>        Next = Next-&gt;Flink; <br>        } <br> <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>AddThread( <br>    LPDEBUG_EVENT DebugEvent, <br>    PPROCESS_INFO Process, <br>    PTHREAD_INFO *ReturnedThread <br>    ) <br>{ <br>    PTHREAD_INFO Thread; <br> <br>    Thread = LocalAlloc(LMEM_ZEROINIT, sizeof( *Thread ) ); <br>    if (Thread == NULL) { <br>        return FALSE; <br>        } <br> <br>    Thread-&gt;Id = DebugEvent-&gt;dwThreadId; <br>    if (DebugEvent-&gt;dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) { <br>        Thread-&gt;Handle = DebugEvent-&gt;u.CreateProcessInfo.hThread; <br>        Thread-&gt;StartAddress = DebugEvent-&gt;u.CreateProcessInfo.lpStartAddress; <br>        } <br>    else { <br>        Thread-&gt;Handle = DebugEvent-&gt;u.CreateThread.hThread; <br>        Thread-&gt;StartAddress = DebugEvent-&gt;u.CreateThread.lpStartAddress; <br>        } <br>    InsertTailList( &amp;Process-&gt;ThreadListHead, &amp;Thread-&gt;Entry ); <br>    *ReturnedThread = Thread; <br>    return TRUE; <br>} <br> <br>BOOL <br>DeleteThread( <br>    PPROCESS_INFO Process, <br>    PTHREAD_INFO Thread <br>    ) <br>{ <br> <br>    RemoveEntryList( &amp;Thread-&gt;Entry ); <br> <br>    LocalFree( Thread ); <br>    return TRUE; <br>} <br> <br> <br>PPROCESS_INFO <br>FindProcessById( <br>    ULONG Id <br>    ) <br>{ <br>    PLIST_ENTRY Next, Head; <br>    PPROCESS_INFO Process; <br> <br>    Head = &amp;ProcessListHead; <br>    Next = Head-&gt;Flink; <br>    while (Next != Head) { <br>        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry ); <br>        if (Process-&gt;Id == Id) { <br>            return Process; <br>            } <br> <br>        Next = Next-&gt;Flink; <br>        } <br> <br>    return NULL; <br>} <br> <br>BOOL <br>FindProcessAndThreadForEvent( <br>    LPDEBUG_EVENT DebugEvent, <br>    PPROCESS_INFO *ReturnedProcess, <br>    PTHREAD_INFO *ReturnedThread <br>    ) <br>{ <br>    PLIST_ENTRY Next, Head; <br>    PPROCESS_INFO Process; <br>    PTHREAD_INFO Thread; <br> <br>    Head = &amp;ProcessListHead; <br>    Next = Head-&gt;Flink; <br>    Process = NULL; <br>    Thread = NULL; <br>    while (Next != Head) { <br>        Process = CONTAINING_RECORD( Next, PROCESS_INFO, Entry ); <br>        if (Process-&gt;Id == DebugEvent-&gt;dwProcessId) { <br>            Head = &amp;Process-&gt;ThreadListHead; <br>            Next = Head-&gt;Flink; <br>            while (Next != Head) { <br>                Thread = CONTAINING_RECORD( Next, THREAD_INFO, Entry ); <br>                if (Thread-&gt;Id == DebugEvent-&gt;dwThreadId) { <br>                    break; <br>                    } <br> <br>                Thread = NULL; <br>                Next = Next-&gt;Flink; <br>                } <br> <br>            break; <br>            } <br> <br>        Process = NULL; <br>        Next = Next-&gt;Flink; <br>        } <br> <br>    *ReturnedProcess = Process; <br>    *ReturnedThread = Thread; <br> <br>    if (DebugEvent-&gt;dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) { <br>        if (Process != NULL) { <br>            DeclareError( PFMON_DUPLICATE_PROCESS_ID, 0, DebugEvent-&gt;dwProcessId ); <br>            return FALSE; <br>            } <br>        } <br>    else <br>    if (DebugEvent-&gt;dwDebugEventCode == CREATE_THREAD_DEBUG_EVENT) { <br>        if (Thread != NULL) { <br>            DeclareError( PFMON_DUPLICATE_THREAD_ID, 0, DebugEvent-&gt;dwThreadId, DebugEvent-&gt;dwProcessId ); <br>            return FALSE; <br>            } <br>        if (Process == NULL) { <br>            DeclareError( PFMON_MISSING_PROCESS_ID, 0, DebugEvent-&gt;dwProcessId ); <br>            return FALSE; <br>            } <br>        } <br>    else <br>    if (Process == NULL) { <br>        DeclareError( PFMON_MISSING_PROCESS_ID, 0, DebugEvent-&gt;dwProcessId ); <br>        return FALSE; <br>        } <br>    else <br>    if (Thread == NULL) { <br>        DeclareError( PFMON_MISSING_THREAD_ID, 0, DebugEvent-&gt;dwThreadId, DebugEvent-&gt;dwProcessId ); <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
