<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MODULE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5460"></a>MODULE.C</h2>
<pre><code>/*++ <br> <br>Copyright 1995 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    module.c <br> <br>Abstract: <br> <br>    This module maintains the module (symbol) information for the pfmon application <br> <br>Author: <br> <br>    Mark Lucovsky (markl) 27-Jan-1995 <br> <br>Revision History: <br> <br>--*/ <br> <br>#include "pfmonp.h" <br> <br>BOOL <br>AddModule( <br>    LPDEBUG_EVENT DebugEvent <br>    ) <br>{ <br>    PMODULE_INFO Module; <br>    LPVOID BaseAddress; <br>    HANDLE Handle; <br> <br>    if ( DebugEvent-&gt;dwDebugEventCode == CREATE_PROCESS_DEBUG_EVENT) { <br>        Handle = DebugEvent-&gt;u.CreateProcessInfo.hFile; <br>        BaseAddress = DebugEvent-&gt;u.CreateProcessInfo.lpBaseOfImage; <br>        } <br>    else { <br>        Handle = DebugEvent-&gt;u.LoadDll.hFile; <br>        BaseAddress = DebugEvent-&gt;u.LoadDll.lpBaseOfDll; <br>        } <br> <br>    Module = FindModuleContainingAddress(BaseAddress); <br>    if ( Module ) { <br>        DeleteModule(Module); <br>        } <br> <br>    Module = LocalAlloc(LMEM_ZEROINIT, sizeof( *Module ) ); <br> <br>    if (Module == NULL) { <br>        return FALSE; <br>        } <br> <br>    Module-&gt;Handle = Handle; <br>    Module-&gt;BaseAddress = BaseAddress; <br> <br>    if ( !Module-&gt;Handle ) { <br>        LocalFree(Module); <br>        return FALSE; <br>        } <br> <br>    Module-&gt;DebugInfo = MapDebugInformation( <br>                            Module-&gt;Handle, <br>                            NULL, <br>                            SymbolSearchPath, <br>                            (DWORD)Module-&gt;BaseAddress <br>                            ); <br> <br>    if ( !Module-&gt;DebugInfo ) { <br>        LocalFree(Module); <br>        return FALSE; <br>        } <br>    Module-&gt;VirtualSize = Module-&gt;DebugInfo-&gt;SizeOfImage; <br> <br>    SymLoadModule(hProcess,Handle,NULL,NULL,(DWORD)BaseAddress,0); <br> <br>    InsertTailList( &amp;ModuleListHead, &amp;Module-&gt;Entry ); <br> <br>    return TRUE; <br>} <br> <br>BOOL <br>DeleteModule( <br>    PMODULE_INFO Module <br>    ) <br>{ <br>    CHAR Line[256]; <br> <br>    if ( Module ) { <br>        RemoveEntryList(&amp;Module-&gt;Entry); <br> <br>        sprintf(Line,"%16s Caused %6d faults had %6d Soft %6d Hard faulted VA's\n", <br>            Module-&gt;DebugInfo-&gt;ImageFileName, <br>            Module-&gt;NumberCausedFaults, <br>            Module-&gt;NumberFaultedSoftVas, <br>            Module-&gt;NumberFaultedHardVas <br>            ); <br>        if ( !fLogOnly ) { <br>            fprintf(stdout,"%s",Line); <br>            } <br>        if ( LogFile ) { <br>            fprintf(LogFile,"%s",Line); <br>            } <br> <br>        UnmapDebugInformation(Module-&gt;DebugInfo); <br>        LocalFree(Module); <br>        } <br> <br>    return TRUE; <br>} <br> <br> <br>PMODULE_INFO <br>FindModuleContainingAddress( <br>    LPVOID Address <br>    ) <br>{ <br>    PLIST_ENTRY Next; <br>    PMODULE_INFO Module; <br> <br>    Next = ModuleListHead.Flink; <br>    while ( Next != &amp;ModuleListHead ) { <br>        Module = CONTAINING_RECORD(Next,MODULE_INFO,Entry); <br>        if ( Address &gt;= Module-&gt;BaseAddress &amp;&amp; <br>             Address &lt; (LPVOID)((PUCHAR)(Module-&gt;BaseAddress)+Module-&gt;VirtualSize) ) { <br>            return Module; <br>            } <br>        Next = Next-&gt;Flink; <br>        } <br>    return NULL; <br>} <br> <br>VOID <br>SetSymbolSearchPath( ) <br>{ <br>    LPSTR lpSymPathEnv, lpAltSymPathEnv, lpSystemRootEnv; <br>    ULONG cbSymPath; <br>    DWORD dw; <br> <br>    cbSymPath = 18; <br>    if (lpSymPathEnv = getenv("_NT_SYMBOL_PATH")) { <br>        cbSymPath += strlen(lpSymPathEnv) + 1; <br>    } <br>    if (lpAltSymPathEnv = getenv("_NT_ALT_SYMBOL_PATH")) { <br>        cbSymPath += strlen(lpAltSymPathEnv) + 1; <br>    } <br> <br>    if (lpSystemRootEnv = getenv("SystemRoot")) { <br>        cbSymPath += strlen(lpSystemRootEnv) + 1; <br>    } <br> <br>    SymbolSearchPath = LocalAlloc(LMEM_ZEROINIT,cbSymPath); <br> <br>    if (lpAltSymPathEnv) { <br>        dw = GetFileAttributes(lpAltSymPathEnv); <br>        if ( dw != 0xffffffff &amp;&amp; dw &amp; FILE_ATTRIBUTE_DIRECTORY ) { <br>            strcat(SymbolSearchPath,lpAltSymPathEnv); <br>            strcat(SymbolSearchPath,";"); <br>            } <br>    } <br>    if (lpSymPathEnv) { <br>        dw = GetFileAttributes(lpSymPathEnv); <br>        if ( dw != 0xffffffff &amp;&amp; dw &amp; FILE_ATTRIBUTE_DIRECTORY ) { <br>            strcat(SymbolSearchPath,lpSymPathEnv); <br>            strcat(SymbolSearchPath,";"); <br>            } <br>    } <br> <br>    if (lpSystemRootEnv) { <br>        dw = GetFileAttributes(lpSystemRootEnv); <br>        if ( dw != 0xffffffff &amp;&amp; dw &amp; FILE_ATTRIBUTE_DIRECTORY ) { <br>            strcat(SymbolSearchPath,lpSystemRootEnv); <br>            strcat(SymbolSearchPath,";"); <br>            } <br>    } <br> <br>    strcat(SymbolSearchPath,".;"); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
