<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVCOMMON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5451"></a>CVCOMMON.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    cvcommon.c <br> <br>Abstract: <br> <br>    This file contians a set of common routines which are used in <br>    doing symbol conversions from one type of symbols to CodeView <br>    symbols. <br> <br>Author: <br> <br>    Wesley A. Witt (wesw) 19-April-1993 <br>    Jim Schaad (jimsch) 22 May 1993 <br> <br>--*/ <br> <br>#include        &lt;windows.h&gt; <br>#include        &lt;stdlib.h&gt; <br>#include        "cv.h" <br>#include        "symcvt.h" <br>#include        "cvcommon.h" <br> <br>typedef struct tagSYMHASH { <br>    DWORD       dwHashVal;         // hash value for the symbol <br>    DWORD       dwHashBucket;      // hash bucket number <br>    DATASYM16 * dataSym;           // pointer to the symbol info <br>} SYMHASH; <br> <br>typedef struct tagOFFSETSORT { <br>    DWORD       dwOffset;          // offset for the symbol <br>    DWORD       dwSection;         // section number of the symbol <br>    DATASYM16 * dataSym;           // pointer to the symbol info <br>} OFFSETSORT; <br> <br> <br>int _CRTAPI1 SymHashCompare( const void *arg1, const void *arg2 ); <br>int _CRTAPI1 OffsetSortCompare( const void *arg1, const void *arg2 ); <br> <br>  <br>DWORD <br>CreateSignature( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the CODEVIEW signature record.  Currently this converter only <br>    generates NB09 data (MS C/C++ 8.0). <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    number of records generates, this is always 1. <br> <br>--*/ <br> <br>{ <br>    OMFSignature        *omfSig; <br> <br>    omfSig = (OMFSignature *) p-&gt;pCvCurr; <br>    strcpy( omfSig-&gt;Signature, "NB09" ); <br>    omfSig-&gt;filepos = 0; <br>    p-&gt;pCvStart.size += sizeof(OMFSignature); <br>    p-&gt;pCvCurr = (PUCHAR) p-&gt;pCvCurr + sizeof(OMFSignature); <br>    return 1; <br>}                               /* CreateSignature() */ <br> <br>  <br>DWORD <br>CreateDirectories( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the control function for the generation of the CV directories. <br>    It calls individual functions for the generation of specific types of <br>    debug directories. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    the number of directories created. <br> <br>--*/ <br> <br>{ <br>    OMFDirHeader        *omfDir = (OMFDirHeader *)p-&gt;pCvCurr; <br>    OMFSignature        *omfSig = (OMFSignature *)p-&gt;pCvStart.ptr; <br>    OMFDirEntry         *omfDirEntry = NULL; <br> <br>    omfSig-&gt;filepos = (DWORD)p-&gt;pCvCurr - (DWORD)p-&gt;pCvStart.ptr; <br> <br>    omfDir-&gt;cbDirHeader = sizeof(OMFDirHeader); <br>    omfDir-&gt;cbDirEntry  = sizeof(OMFDirEntry); <br>    omfDir-&gt;cDir        = 0; <br>    omfDir-&gt;lfoNextDir  = 0; <br>    omfDir-&gt;flags       = 0; <br> <br>    p-&gt;pCvStart.size += sizeof(OMFDirHeader); <br>    p-&gt;pCvCurr = (PUCHAR) p-&gt;pCvCurr + sizeof(OMFDirHeader); <br> <br>    omfDir-&gt;cDir += CreateModuleDirectoryEntries( p ); <br>    omfDir-&gt;cDir += CreatePublicDirectoryEntries( p ); <br>    omfDir-&gt;cDir += CreateSegMapDirectoryEntries( p ); <br>    omfDir-&gt;cDir += CreateSrcModulesDirectoryEntries( p ); <br> <br>    strcpy(p-&gt;pCvCurr, "NB090000"); <br>    p-&gt;pCvStart.size += 8; <br>    p-&gt;pCvCurr += 8; <br>    *((DWORD *) (p-&gt;pCvCurr-4)) = p-&gt;pCvStart.size; <br> <br>    return omfDir-&gt;cDir; <br>}                               /* CreateDirectories() */ <br> <br>  <br>DWORD <br>CreateModuleDirectoryEntries( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates directory entries for each module in the image. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    the number of directory entries created. <br> <br>--*/ <br> <br>{ <br>    OMFDirEntry   *omfDirEntry = NULL; <br>    OMFModule     *m = NULL; <br>    OMFModule     *mNext = NULL; <br>    DWORD         i = 0; <br>    DWORD         mSize = 0; <br>    DWORD         lfo = (DWORD)p-&gt;pCvModules.ptr - (DWORD)p-&gt;pCvStart.ptr; <br> <br>    m = (OMFModule *) p-&gt;pCvModules.ptr; <br>    for (i=0; i&lt;p-&gt;pCvModules.count; i++) { <br>        mNext = NextMod(m); <br> <br>        omfDirEntry = (OMFDirEntry *) p-&gt;pCvCurr; <br> <br>        mSize = (DWORD)mNext - (DWORD)m; <br>        omfDirEntry-&gt;SubSection = sstModule; <br>        omfDirEntry-&gt;iMod       = (USHORT) i + 1; <br>        omfDirEntry-&gt;lfo        = lfo; <br>        omfDirEntry-&gt;cb         = mSize; <br> <br>        lfo += mSize; <br> <br>        p-&gt;pCvStart.size += sizeof(OMFDirEntry); <br>        p-&gt;pCvCurr = (PUCHAR) p-&gt;pCvCurr + sizeof(OMFDirEntry); <br> <br>        m = mNext; <br>    } <br> <br>    return p-&gt;pCvModules.count; <br>}                               /* CreateModuleDirectoryEntries() */ <br> <br>  <br>DWORD <br>CreatePublicDirectoryEntries( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the directory entry for the global publics. <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    the number of directory entries created, always 1. <br> <br>--*/ <br> <br>{ <br>    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p-&gt;pCvCurr; <br> <br>    omfDirEntry-&gt;SubSection = sstGlobalPub; <br>    omfDirEntry-&gt;iMod       = 0xffff; <br>    omfDirEntry-&gt;lfo        = (DWORD)p-&gt;pCvPublics.ptr - (DWORD)p-&gt;pCvStart.ptr; <br>    omfDirEntry-&gt;cb         = p-&gt;pCvPublics.size; <br> <br>    p-&gt;pCvStart.size += sizeof(OMFDirEntry); <br>    p-&gt;pCvCurr = (PUCHAR) p-&gt;pCvCurr + sizeof(OMFDirEntry); <br> <br>    return 1; <br>}                               /* CreatePublicDirectoryEntries() */ <br> <br> <br>DWORD <br>CreateSegMapDirectoryEntries( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the directory entry for the segment map. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    the number of directory entries created, always 1. <br> <br>--*/ <br> <br>{ <br>    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p-&gt;pCvCurr; <br> <br>    omfDirEntry-&gt;SubSection = sstSegMap; <br>    omfDirEntry-&gt;iMod       = 0xffff; <br>    omfDirEntry-&gt;lfo        = (DWORD)p-&gt;pCvSegMap.ptr - (DWORD)p-&gt;pCvStart.ptr; <br>    omfDirEntry-&gt;cb         = p-&gt;pCvSegMap.size; <br> <br>    p-&gt;pCvStart.size += sizeof(OMFDirEntry); <br>    p-&gt;pCvCurr = (PUCHAR) p-&gt;pCvCurr + sizeof(OMFDirEntry); <br> <br>    return 1; <br>}                               /* CreateSegMapDirectoryEntries() */ <br> <br>  <br>DWORD <br>CreateSrcModulesDirectoryEntries( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates directory entries for each source module in the image. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    the number of directory entries created. <br> <br>--*/ <br> <br>{ <br>    OMFDirEntry         *omfDirEntry = NULL; <br>    DWORD               i; <br>    DWORD               lfo = (DWORD)p-&gt;pCvSrcModules.ptr - (DWORD)p-&gt;pCvStart.ptr; <br>    DWORD               j = lfo; <br>    OMFSourceModule     *m; <br> <br> <br>    // <br>    // if there were no linenumber conversions then bail out <br>    // <br>    if (!p-&gt;pCvSrcModules.count) { <br>        return 0; <br>    } <br> <br>    for (i=0; i&lt;p-&gt;pCvSrcModules.count; i++) { <br> <br>        if (!p-&gt;pMi[i].SrcModule) { <br>            continue; <br>        } <br> <br>        omfDirEntry = (OMFDirEntry *) p-&gt;pCvCurr; <br> <br>        omfDirEntry-&gt;SubSection = sstSrcModule; <br>        omfDirEntry-&gt;iMod = (USHORT) p-&gt;pMi[i].iMod; <br>        omfDirEntry-&gt;lfo = lfo; <br>        omfDirEntry-&gt;cb = p-&gt;pMi[i].cb; <br> <br>        m = (OMFSourceModule*) p-&gt;pMi[i].SrcModule; <br> <br>        lfo += omfDirEntry-&gt;cb; <br> <br>        p-&gt;pCvStart.size += sizeof(OMFDirEntry); <br>        p-&gt;pCvCurr = (PUCHAR) p-&gt;pCvCurr + sizeof(OMFDirEntry); <br>    } <br> <br>    free( p-&gt;pMi ); <br> <br>    return p-&gt;pCvSrcModules.count; <br>}                               /* CreateSrcModulesDirectoryEntries() */ <br> <br>  <br> <br>#define byt_toupper(b)      (b &amp; 0xDF) <br>#define dwrd_toupper(dw)    (dw &amp; 0xDFDFDFDF) <br> <br>DWORD <br>DWordXorLrl( char *szSym ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function will take an ascii character string and generate <br>    a hash for that string.  The hash algorithm is the CV NB09 hash <br>    algorithm. <br> <br> <br>Arguments: <br> <br>    szSym    - a character pointer, the first char is the string length <br> <br> <br>Return Value: <br> <br>    The generated hash value. <br> <br>--*/ <br> <br>{ <br>    char                *pName = szSym+1; <br>    int                 cb =  *szSym; <br>    char                *pch; <br>    char                c; <br>    DWORD               hash = 0, ulEnd = 0; <br>    DWORD UNALIGNED     *pul; <br> <br>    // Replace all "::" with "__" for hashing purposes <br> <br>    c = *(pName+cb); <br>    *(pName+cb) = '\0'; <br>    pch = strstr( pName, "::" ); <br>    if ( pch ) { <br>        *pch++ = '_'; <br>        *pch   = '_'; <br>    } <br>    *(pName+cb) = c; <br> <br>    // If we're standard call, skip the trailing @999 <br> <br>    pch = pName + cb - 1; <br>    while (isdigit(*pch)) { <br>        pch--; <br>    } <br> <br>    if (*pch == '@') { <br>        cb = pch - pName; <br>    } <br> <br>    // If we're fastcall, skip the leading '@' <br> <br>    if (*pName == '@') { <br>        pName++; <br>        cb--; <br>    } <br> <br>    // Calculate the odd byte hash. <br> <br>    while (cb &amp; 3) { <br>        ulEnd |= byt_toupper (pName[cb-1]); <br>        ulEnd &lt;&lt;=8; <br>        cb--; <br>    } <br> <br>    pul = (DWORD UNALIGNED *)pName; <br> <br>    // calculate the dword hash for the remaining <br> <br>    while (cb) { <br>        hash ^= dwrd_toupper(*pul); <br>        hash = _lrotl (hash, 4); <br>        pul++; <br>        cb -=4; <br>    } <br> <br>    // or in the remainder <br> <br>    hash ^= ulEnd; <br> <br>    return hash; <br>}                               /* DWordXorLrl() */ <br> <br> <br>  <br>OMFModule * <br>NextMod( <br>        OMFModule *             pMod <br>        ) <br>/*++ <br> <br>Routine Description: <br> <br>    description-of-function. <br> <br>Arguments: <br> <br>    argument-name - Supplies | Returns description of argument. <br>    . <br>    . <br> <br>Return Value: <br> <br>    return-value - Description of conditions needed to return value. - or - <br>    None. <br> <br>--*/ <br> <br>{ <br>    char *      pb; <br> <br>    pb = (char *) &amp;(pMod-&gt;SegInfo[pMod-&gt;cSeg]); <br>    pb += *pb + 1; <br>    pb = (char *) (((unsigned long) pb + 3) &amp; ~3); <br> <br>    return (OMFModule *) pb; <br>}                               /* NextMod() */ <br> <br> <br>  <br>int <br>_CRTAPI1 <br>SymHashCompare( <br>               const void *     arg1, <br>               const void *     arg2 <br>               ) <br>/*++ <br> <br>Routine Description: <br> <br>    Sort compare function for sorting SYMHASH records by hashed <br>    bucket number. <br> <br> <br>Arguments: <br> <br>    arg1     - record #1 <br>    arg2     - record #2 <br> <br> <br>Return Value: <br> <br>   -1        - record #1 is &lt; record #2 <br>    0        - records are equal <br>    1        - record #1 is &gt; record #2 <br> <br>--*/ <br> <br>{ <br>    if (((SYMHASH*)arg1)-&gt;dwHashBucket &lt; ((SYMHASH*)arg2)-&gt;dwHashBucket) { <br>        return -1; <br>    } <br>    if (((SYMHASH*)arg1)-&gt;dwHashBucket &gt; ((SYMHASH*)arg2)-&gt;dwHashBucket) { <br>        return 1; <br>    } <br> <br>    // BUGBUG: Should we second sort on the hash value? <br> <br>    return 0; <br>}                               /* SymHashCompare() */ <br> <br>  <br>// Symbol Offset/Hash structure <br> <br>typedef struct _SOH { <br>    DWORD uoff; <br>    DWORD ulHash; <br>} SOH; <br> <br>#define MINHASH     6           // Don't create a hash with fewer than 6 slots <br> <br>DWORD <br>CreateSymbolHashTable( <br>    PPOINTERS p <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the CV symbol hash table.  This hash table is used <br>    primarily by debuggers to access symbols in a quick manner. <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br>Return Value: <br> <br>    The number of buckets is the hash table. <br> <br>--*/ <br>{ <br>    DWORD           i; <br>    DWORD           j; <br>    int             k; <br>    DWORD           numsyms; <br>    DWORD           numbuckets; <br>    OMFSymHash      *omfSymHash; <br>    DATASYM16       *dataSymStart; <br>    DATASYM16       *dataSym; <br>    LPVOID          pHashData; <br>    USHORT          *pCHash; <br>    DWORD           *pHashTable; <br>    DWORD           *pBucketCounts; <br>    DWORD           *pChainTable; <br>    SYMHASH         *symHashStart; <br>    SYMHASH         *symHash; <br>//    DWORD           dwHashVal; <br>    char *          sz; <br> <br>    numsyms = p-&gt;pCvPublics.count; <br>    numbuckets = (numsyms+9) / 10; <br>    numbuckets = (1 + numbuckets) &amp; ~1; <br>    numbuckets = __max(numbuckets, MINHASH); <br> <br>    symHashStart = <br>    symHash = (SYMHASH *) malloc( numsyms * sizeof(SYMHASH) ); <br>    if (symHashStart == NULL) { <br>        return 0; <br>    } <br> <br>    memset( symHashStart, 0, numsyms * sizeof(SYMHASH) ); <br> <br>    pHashData = (LPVOID) p-&gt;pCvCurr; <br>    pCHash = (USHORT *) pHashData; <br>    pHashTable = (DWORD *) ((DWORD)pHashData + sizeof(DWORD)); <br>    pBucketCounts = (DWORD *) ((DWORD)pHashTable + <br>                                  (sizeof(DWORD) * numbuckets)); <br>    memset(pBucketCounts, 0, sizeof(DWORD) * numbuckets); <br> <br>    pChainTable = (DWORD *) ((DWORD)pBucketCounts + <br>                                 ((sizeof(ULONG) * numbuckets))); <br> <br>    omfSymHash = (OMFSymHash *) p-&gt;pCvPublics.ptr; <br>    dataSymStart = <br>    dataSym = (DATASYM16 *) ((DWORD)omfSymHash + sizeof(OMFSymHash)); <br> <br>    *pCHash = (USHORT)numbuckets; <br> <br>    /* <br>     *  cruise thru the symbols and calculate the hash values <br>     *  and the hash bucket numbers; save the info away for later use <br>     */ <br>    for (i=0; i&lt;numsyms; i++, symHash++) { <br>        switch( dataSym-&gt;rectyp ) { <br>        case S_PUB16: <br>            sz = dataSym-&gt;name; <br>            break; <br> <br>        case S_PUB32: <br>            sz = ((DATASYM32 *) dataSym)-&gt;name; <br>            break; <br> <br>        default: <br>            continue; <br>        } <br> <br>        symHash-&gt;dwHashVal = DWordXorLrl( sz ); <br>        symHash-&gt;dwHashBucket = symHash-&gt;dwHashVal % numbuckets; <br>        pBucketCounts[symHash-&gt;dwHashBucket] += 1; <br>        symHash-&gt;dataSym = dataSym; <br>        dataSym = ((DATASYM16 *) ((char *) dataSym + dataSym-&gt;reclen + 2)); <br>    } <br> <br>    qsort( (void*)symHashStart, numsyms, sizeof(SYMHASH), SymHashCompare ); <br> <br>    j = (char *)pChainTable - (char *)pHashData; <br>    for (i=0, k = 0; <br>         i &lt; numbuckets; <br>         k += pBucketCounts[i], i += 1, pHashTable++ ) <br>    { <br>        *pHashTable = (DWORD) j + (k * sizeof(DWORD) * 2); <br>    } <br> <br>    dataSymStart = (DATASYM16 *) (PUCHAR)((DWORD)omfSymHash); <br>    for (i=0,symHash=symHashStart; i&lt;numsyms; i++,symHash++,pChainTable++) { <br>        *pChainTable = (DWORD) (DWORD)symHash-&gt;dataSym - (DWORD)dataSymStart; <br>        ++pChainTable; <br>        *pChainTable = symHash-&gt;dwHashVal; <br>    } <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvSymHash, (LPVOID)pChainTable, numsyms ); <br> <br>    omfSymHash-&gt;symhash = 10; <br>    omfSymHash-&gt;cbHSym = p-&gt;pCvSymHash.size; <br> <br>    free( symHashStart ); <br> <br>    return numbuckets; <br>}                               /* CreateSymbolHashTable() */ <br> <br>  <br>VOID <br>UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called by ALL functions that put data into the <br>    CV data area.  After putting the data into the CV memory this function <br>    must be called.  It will adjust all of the necessary pointers so the <br>    the next guy doesn't get hosed. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br>    pi       - the CV pointer that is to be updated <br>    lpv      - current pointer into the CV data <br>    count    - the number of items that were placed into the CV data <br> <br> <br>Return Value: <br> <br>    void <br> <br>--*/ <br> <br>{ <br>    if (!count) { <br>        return; <br>    } <br> <br>    pi-&gt;ptr = p-&gt;pCvCurr; <br>    pi-&gt;size = (DWORD) ((DWORD)lpv - (DWORD)p-&gt;pCvCurr); <br>    pi-&gt;count = count; <br> <br>    p-&gt;pCvStart.size += pi-&gt;size; <br>    p-&gt;pCvCurr = (PUCHAR) lpv; <br> <br>    return; <br>}                               /* UpdatePtrs() */ <br> <br>  <br>int <br>_CRTAPI1 <br>OffsetSortCompare( const void *arg1, const void *arg2 ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Sort compare function for sorting OFFETSORT records by section number. <br> <br> <br>Arguments: <br> <br>    arg1     - record #1 <br>    arg2     - record #2 <br> <br> <br>Return Value: <br> <br>   -1        - record #1 is &lt; record #2 <br>    0        - records are equal <br>    1        - record #1 is &gt; record #2 <br> <br>--*/ <br> <br>{ <br>    if (((OFFSETSORT*)arg1)-&gt;dwSection &lt; ((OFFSETSORT*)arg2)-&gt;dwSection) { <br>        return -1; <br>    } <br>    if (((OFFSETSORT*)arg1)-&gt;dwSection &gt; ((OFFSETSORT*)arg2)-&gt;dwSection) { <br>        return 1; <br>    } <br>    if (((OFFSETSORT*)arg1)-&gt;dwOffset &lt; ((OFFSETSORT*)arg2)-&gt;dwOffset) { <br>        return -1; <br>    } <br>    if (((OFFSETSORT*)arg1)-&gt;dwOffset &gt; ((OFFSETSORT*)arg2)-&gt;dwOffset) { <br>        return 1; <br>    } <br>    return 0; <br>}                               /* OffsetSortCompare() */ <br> <br>  <br>DWORD <br>CreateAddressSortTable( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br> <br>    Creates the CV address sort table. This hash table is used <br>    primarily by debuggers to access symbols in a quick manner when <br>    all you have is an address. <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    The number of sections in the table. <br> <br>--*/ <br> <br>{ <br>    DWORD               i; <br>    DWORD               j; <br>    int                 k; <br>    DWORD               numsyms = p-&gt;pCvPublics.count; <br>    DWORD               numsections; <br>    OMFSymHash          *omfSymHash; <br>    DATASYM16           *dataSymStart; <br>    DATASYM16           *dataSym; <br>    LPVOID              pAddressData; <br>    USHORT              *pCSeg; <br>    DWORD               *pSegTable; <br>    DWORD               *pOffsetCounts; <br>    DWORD               *pOffsetTable; <br>    OFFSETSORT          *pOffsetSortStart; <br>    OFFSETSORT          *pOffsetSort; <br> <br>    extern int          CSymSegs; <br> <br>    if (p-&gt;iptrs.fileHdr) { <br>        numsections = p-&gt;iptrs.fileHdr-&gt;NumberOfSections; <br>    } else if (p-&gt;iptrs.sepHdr) { <br>        numsections = p-&gt;iptrs.sepHdr-&gt;NumberOfSections; <br>    } else { <br>        numsections = CSymSegs; <br>    } <br> <br>    pOffsetSortStart = <br>      pOffsetSort = (OFFSETSORT *) malloc( numsyms * sizeof(OFFSETSORT) ); <br> <br>    if (pOffsetSort == NULL) { <br>        return 0; <br>    } <br> <br>    memset( pOffsetSortStart, 0, numsyms * sizeof(OFFSETSORT) ); <br> <br>    pAddressData = (LPVOID) p-&gt;pCvCurr; <br>    pCSeg = (USHORT *) pAddressData; <br>    pSegTable = (DWORD *) ((DWORD)pAddressData + sizeof(DWORD)); <br>    pOffsetCounts = (DWORD *) ((DWORD)pSegTable + <br>                                (sizeof(DWORD) * numsections)); <br>    pOffsetTable = (DWORD *) ((DWORD)pOffsetCounts + <br>                              ((sizeof(DWORD) * numsections))); <br>//    if (numsections &amp; 1) { <br>//        pOffsetTable = (DWORD *) ((DWORD)pOffsetTable + 2); <br>//    } <br> <br>    omfSymHash = (OMFSymHash *) p-&gt;pCvPublics.ptr; <br>    dataSymStart = <br>      dataSym = (DATASYM16 *) ((DWORD)omfSymHash + sizeof(OMFSymHash)); <br> <br>    *pCSeg = (USHORT)numsections; <br> <br>    for (i=0; <br>         i&lt;numsyms; <br>         i++, pOffsetSort++) <br>    { <br>        switch(dataSym-&gt;rectyp) { <br>        case S_PUB16: <br>            pOffsetSort-&gt;dwOffset = dataSym-&gt;off; <br>            pOffsetSort-&gt;dwSection = dataSym-&gt;seg; <br>            break; <br> <br>        case S_PUB32: <br>            pOffsetSort-&gt;dwOffset = ((DATASYM32 *) dataSym)-&gt;off; <br>            pOffsetSort-&gt;dwSection = ((DATASYM32 *) dataSym)-&gt;seg; <br>        } <br> <br>        pOffsetSort-&gt;dataSym = dataSym; <br>        pOffsetCounts[pOffsetSort-&gt;dwSection - 1] += 1; <br>        dataSym = ((DATASYM16 *) ((char *) dataSym + dataSym-&gt;reclen + 2));    } <br> <br>//#if 0 <br>    qsort((void*)pOffsetSortStart, numsyms, sizeof(OFFSETSORT), <br>          OffsetSortCompare ); <br>//#endif <br> <br>    j = (DWORD) (DWORD)pOffsetTable - (DWORD)pAddressData; <br>    for (i=0, k=0; <br>         i &lt; numsections; <br>         k += pOffsetCounts[i], i += 1, pSegTable++) <br>    { <br>        *pSegTable = (DWORD) j + (k * sizeof(DWORD) * 2); <br>    } <br> <br>    dataSymStart = (DATASYM16 *) (PUCHAR)((DWORD)omfSymHash); <br>    for (i=0, pOffsetSort=pOffsetSortStart; <br>         i &lt; numsyms; <br>         i++, pOffsetSort++, pOffsetTable++) <br>    { <br>        *pOffsetTable = (DWORD)pOffsetSort-&gt;dataSym - (DWORD)dataSymStart; <br>        pOffsetTable++; <br>        *pOffsetTable = pOffsetSort-&gt;dwOffset; <br>    } <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvAddrSort, (LPVOID)pOffsetTable, numsyms ); <br> <br>    omfSymHash-&gt;addrhash = 12; <br>    omfSymHash-&gt;cbHAddr = p-&gt;pCvAddrSort.size; <br> <br>    free( pOffsetSortStart ); <br> <br>    return numsections; <br>}                               /* CreateAddressSort() */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
