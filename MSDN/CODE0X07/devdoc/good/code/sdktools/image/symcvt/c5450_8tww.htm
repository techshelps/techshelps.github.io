<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COFFTOCV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5450"></a>COFFTOCV.C</h2>
<pre><code>/*++ <br> <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    cv.c <br> <br>Abstract: <br> <br>    This module handles the conversion activities requires for converting <br>    COFF debug data to CODEVIEW debug data. <br> <br>Author: <br> <br>    Wesley A. Witt (wesw) 19-April-1993 <br> <br>Environment: <br> <br>    Win32, User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;imagehlp.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "cv.h" <br>#define _SYMCVT_SOURCE_ <br>#include "symcvt.h" <br>#include "cvcommon.h" <br> <br>typedef struct tagOFFSETSORT { <br>    DWORD       dwOffset;          // offset for the symbol <br>    DWORD       dwSection;         // section number of the symbol <br>    DATASYM32   *dataSym;          // pointer to the symbol info <br>} OFFSETSORT; <br> <br> <br>#define n_name          N.ShortName <br>#define n_zeroes        N.Name.Short <br>#define n_nptr          N.LongName[1] <br>#define n_offset        N.Name.Long <br> <br>static LPSTR GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, char *s ); <br>DWORD  CreateModulesFromCoff( PPOINTERS p ); <br>DWORD  CreatePublicsFromCoff( PPOINTERS p ); <br>DWORD  CreateSegMapFromCoff( PPOINTERS p ); <br>DWORD  CreateSrcLinenumbers( PPOINTERS p ); <br> <br> <br> <br>LONG <br>GuardPageFilterFunction( <br>    DWORD                ec, <br>    LPEXCEPTION_POINTERS lpep <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function catches all exceptions from the convertcofftocv function <br>    and all that it calls.  The purpose of this function is allocate memory <br>    when it is necessary.  This happens because the cofftocv conversion cannot <br>    estimate the memory requirements before the conversion takes place.  To <br>    handle this properly space in the virtual address space is reserved, the <br>    reservation amount is 10 times the image size.  The first page is commited <br>    and then the conversion is started.  When an access violation occurs and the <br>    page that is trying to be access has a protection of noaccess then the <br>    page is committed.  Any other exception is not handled. <br> <br>Arguments: <br> <br>    ec      - the ecxeption code (should be EXCEPTION_ACCESS_VIOLATION) <br>    lpep    - pointer to the exception record and context record <br> <br> <br>Return Value: <br> <br>    EXCEPTION_CONTINUE_EXECUTION    - access violation handled <br>    EXCEPTION_EXECUTE_HANDLER       - unknown exception and is not handled <br> <br>--*/ <br> <br>{ <br>    LPVOID                      vaddr; <br>    SYSTEM_INFO                 si; <br>    MEMORY_BASIC_INFORMATION    mbi; <br> <br> <br>    if (ec == EXCEPTION_ACCESS_VIOLATION) { <br>        vaddr = (LPVOID)lpep-&gt;ExceptionRecord-&gt;ExceptionInformation[1]; <br>        VirtualQuery( vaddr, &amp;mbi, sizeof(mbi) ); <br>        if (mbi.AllocationProtect == PAGE_NOACCESS) { <br>            GetSystemInfo( &amp;si ); <br>            VirtualAlloc( vaddr, si.dwPageSize, MEM_COMMIT, PAGE_READWRITE ); <br>            return EXCEPTION_CONTINUE_EXECUTION; <br>        } <br>    } <br> <br>//  return EXCEPTION_CONTINUE_SEARCH; <br>    return EXCEPTION_EXECUTE_HANDLER; <br>} <br> <br> <br>BOOL <br>ConvertCoffToCv( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the control function for the conversion of COFF to CODEVIEW <br>    debug data.  It calls individual functions for the conversion of <br>    specific types of debug data. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure <br> <br> <br>Return Value: <br> <br>    TRUE     - conversion succeded <br>    FALSE    - conversion failed <br> <br>--*/ <br> <br>{ <br>    SYSTEM_INFO                 si; <br>    DWORD                       cbsize; <br>    BOOL                        rval = TRUE; <br> <br> <br>    GetSystemInfo( &amp;si ); <br>    cbsize = max( p-&gt;iptrs.fsize * 10, si.dwPageSize * 10 ); <br> <br>    // <br>    // reserve all necessary pages <br>    // <br>    p-&gt;pCvCurr = p-&gt;pCvStart.ptr = VirtualAlloc( NULL, cbsize, MEM_RESERVE, PAGE_NOACCESS ); <br> <br>    // <br>    // commit the first pages <br>    // <br>    VirtualAlloc( p-&gt;pCvCurr, min( cbsize, 5 * si.dwPageSize), MEM_COMMIT, PAGE_READWRITE ); <br> <br> <br>    try { <br> <br>        CreateSignature( p ); <br>        CreateModulesFromCoff( p ); <br>        CreatePublicsFromCoff( p ); <br>        CreateSymbolHashTable( p ); <br>        CreateAddressSortTable( p ); <br>        CreateSegMapFromCoff( p ); <br>//      CreateSrcLinenumbers( p ); <br>        CreateDirectories( p ); <br> <br>    } except ( GuardPageFilterFunction( GetExceptionCode(), GetExceptionInformation() )) { <br> <br>        VirtualFree( p-&gt;pCvStart.ptr, cbsize, MEM_DECOMMIT ); <br>        p-&gt;pCvStart.ptr = NULL; <br>        rval = FALSE; <br> <br>    } <br> <br>    if (rval) { <br>        p-&gt;pCvCurr = malloc( p-&gt;pCvStart.size ); <br>        CopyMemory( p-&gt;pCvCurr, p-&gt;pCvStart.ptr, p-&gt;pCvStart.size ); <br>        VirtualFree( p-&gt;pCvStart.ptr, cbsize, MEM_DECOMMIT ); <br>        p-&gt;pCvStart.ptr = p-&gt;pCvCurr; <br>    } <br> <br>    return rval; <br>} <br> <br> <br>DWORD <br>CreateModulesFromCoff( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the individual CV module records.  There is one CV module <br>    record for each .FILE record in the COFF debug data.  This is true <br>    even if the COFF size is zero. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure <br> <br> <br>Return Value: <br> <br>    The number of modules that were created. <br> <br>--*/ <br> <br>{ <br>    int                 i,j; <br>    DWORD               dwOff; <br>    DWORD               numaux; <br>    DWORD               nummods = 0; <br>    char                szSymName[256]; <br>    PIMAGE_SYMBOL       Symbol; <br>    PIMAGE_AUX_SYMBOL   AuxSymbol; <br>    OMFModule           *m = NULL; <br>    int                 cSeg = 0; <br>    char *              pb; <br>    BOOLEAN             rgfCode[500]; <br> <br> <br>    memset(rgfCode, 2, sizeof(rgfCode)); <br> <br>    for (i=0,j=0, Symbol=p-&gt;iptrs.AllSymbols; <br>         i&lt;(int)p-&gt;iptrs.numberOfSymbols; <br>         i+=numaux+1,Symbol+=numaux+1) { <br> <br>        numaux = Symbol-&gt;NumberOfAuxSymbols; <br>        if (Symbol-&gt;StorageClass == IMAGE_SYM_CLASS_FILE) { <br>            j++; <br>        } <br> <br>    } <br> <br>    p-&gt;pMi = (LPMODULEINFO) malloc( sizeof(MODULEINFO) * (j + 1) ); <br>    ZeroMemory( p-&gt;pMi, sizeof(MODULEINFO) * (j + 1) ); <br> <br> <br>    if (!j) { <br>        // <br>        //  Handle the situation where there are not any .file records in the <br>        //  COFF symbol table.  This can happen for ROM images.  If this happens <br>        //  then we will fabricate a bogus module. <br>        // <br>        m = (OMFModule *) p-&gt;pCvCurr; <br>        m-&gt;ovlNumber = 0; <br>        m-&gt;iLib = 0; <br>        m-&gt;Style[0] = 'C'; <br>        m-&gt;Style[1] = 'V'; <br> <br>        for (i=0,j=0, dwOff=0; i&lt;p-&gt;iptrs.numberOfSections; i++) { <br>            if (p-&gt;iptrs.sectionHdrs[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) { <br>                m-&gt;SegInfo[j].Seg = i + 1; <br>                m-&gt;SegInfo[j].cbSeg = p-&gt;iptrs.sectionHdrs[i].SizeOfRawData; <br>                m-&gt;SegInfo[j++].Off = dwOff; <br>            } <br>            dwOff += p-&gt;iptrs.sectionHdrs[i].SizeOfRawData; <br>        } <br> <br>        m-&gt;cSeg = j; <br> <br>        strcpy(szSymName,"foo.c"); <br>        pb = (char *) &amp;m-&gt;SegInfo[j]; <br>        *pb = strlen(szSymName); <br>        memcpy(pb+1, szSymName, *pb); <br> <br>        p-&gt;pMi[0].name = strdup(szSymName); <br>        p-&gt;pMi[0].iMod = 1; <br>        p-&gt;pMi[0].cb = 0; <br>        p-&gt;pMi[0].SrcModule = 0; <br> <br>        m = NextMod(m); <br>        p-&gt;modcnt = 1; <br>        UpdatePtrs( p, &amp;p-&gt;pCvModules, (LPVOID)m, 1 ); <br> <br>        return 1; <br>    } <br> <br> <br>    for (i=0, Symbol = p-&gt;iptrs.AllSymbols; <br>         i &lt; (int) p-&gt;iptrs.numberOfSymbols; <br>         i += numaux + 1, Symbol += numaux + 1) { <br> <br>        // <br>        // Get the number of aux symbol records for this symbol <br>        // <br>        numaux = Symbol-&gt;NumberOfAuxSymbols; <br>        AuxSymbol = (PIMAGE_AUX_SYMBOL) (Symbol+1); <br> <br>        if ((i == 0) &amp;&amp; ((Symbol+numaux+1)-&gt;StorageClass != IMAGE_SYM_CLASS_FILE)) { <br>            // <br>            // we have a situation where the first '.file' record <br>            // is missing.  currently this only happens with the <br>            // claxp compiler on alpha. <br>            // <br>            m = (OMFModule *) p-&gt;pCvCurr; <br>            cSeg = 0; <br>            m-&gt;ovlNumber = 0; <br>            m-&gt;iLib = 0; <br>            m-&gt;Style[0] = 'C'; <br>            m-&gt;Style[1] = 'V'; <br>            strcpy( szSymName, "fake.c" ); <br>        } else <br> <br>        // <br>        //  If this is a FILE record -- then we need to create a <br>        //      module item to correspond to this file record. <br>        // <br> <br>        if (Symbol-&gt;StorageClass == IMAGE_SYM_CLASS_FILE) { <br>            if (m == NULL) { <br>                m = (OMFModule *) p-&gt;pCvCurr; <br>            } else { <br>                // <br>                //      Clean up the last item,  if we saw any <br>                //      section records then drop them in here <br>                // <br> <br>                if (cSeg &gt; 0) { <br>                    m-&gt;cSeg  = cSeg; <br>                    pb = (char *) &amp;m-&gt;SegInfo[cSeg]; <br>                    *pb = strlen(szSymName); <br>                    memcpy(pb+1, szSymName, *pb); <br> <br>                    p-&gt;pMi[nummods].name = strdup(szSymName); <br>                    p-&gt;pMi[nummods].iMod = nummods + 1; <br>                    p-&gt;pMi[nummods].cb = 0; <br>                    p-&gt;pMi[nummods].SrcModule = 0; <br> <br>                    m = NextMod(m); <br>                    nummods++; <br>                } <br>            } <br> <br>            cSeg = 0; <br>            m-&gt;ovlNumber        = 0; <br>            m-&gt;iLib             = 0; <br>            m-&gt;Style[0]         = 'C'; <br>            m-&gt;Style[1]         = 'V'; <br> <br>            /* <br>             *  Save off the file name to use when we have finished <br>             *  processing this module <br>             */ <br> <br>            memcpy(szSymName, (char *)AuxSymbol, numaux*sizeof(IMAGE_AUX_SYMBOL)); <br>            szSymName[numaux*sizeof(IMAGE_AUX_SYMBOL)] = 0; <br> <br>        } <br>        /* <br>         *  We have found a "SECTION" record.  Add the info to the <br>         *      module record <br>         */ <br>        else <br>        if ((Symbol-&gt;SectionNumber &amp; 0xffff) &gt; 0xfff0) { <br>            continue; <br>        } else <br>        if (Symbol-&gt;SectionNumber &gt; sizeof(rgfCode)/sizeof(rgfCode[0])) { <br>            return 0; <br>        } else <br>        if ((m != NULL) &amp;&amp; <br>            (rgfCode[Symbol-&gt;SectionNumber] != 0) &amp;&amp; <br>            (Symbol-&gt;StorageClass == IMAGE_SYM_CLASS_STATIC) &amp;&amp; <br>            ((*Symbol-&gt;n_name == '.') || <br>             (Symbol-&gt;Type == IMAGE_SYM_TYPE_NULL)) &amp;&amp; <br>            (Symbol-&gt;NumberOfAuxSymbols == 1) &amp;&amp; <br>            (AuxSymbol-&gt;Section.Length != 0)) { <br> <br>            if (rgfCode[Symbol-&gt;SectionNumber] == 2) { <br>                if ((p-&gt;iptrs.sectionHdrs[Symbol-&gt;SectionNumber - 1]. <br>                    Characteristics &amp; IMAGE_SCN_CNT_CODE) == 0) { <br>                    rgfCode[Symbol-&gt;SectionNumber] = 0; <br>                    continue; <br>                } <br>                rgfCode[Symbol-&gt;SectionNumber] = 1; <br>            } <br> <br>            m-&gt;SegInfo[cSeg].Seg = Symbol-&gt;SectionNumber; <br>            m-&gt;SegInfo[cSeg].cbSeg = AuxSymbol-&gt;Section.Length; <br>            m-&gt;SegInfo[cSeg].Off = Symbol-&gt;Value - <br>                     p-&gt;iptrs.sectionHdrs[Symbol-&gt;SectionNumber-1]. <br>                       VirtualAddress; <br>            cSeg += 1; <br>        } <br>    } <br> <br>    /* <br>     *  Wrap up the last possible open module record <br>     */ <br> <br>    if (m != NULL) { <br>        if (cSeg &gt; 0) { <br>            m-&gt;cSeg             = cSeg; <br>            pb = (char *) &amp;m-&gt;SegInfo[cSeg]; <br>            *pb = strlen(szSymName); <br>            memcpy(pb+1, szSymName, *pb); <br> <br>            p-&gt;pMi[nummods].name = strdup(szSymName); <br>            p-&gt;pMi[nummods].iMod = nummods + 1; <br>            p-&gt;pMi[nummods].cb = 0; <br>            p-&gt;pMi[nummods].SrcModule = 0; <br> <br>            m = NextMod(m); <br>            nummods++; <br>        } <br>    } <br> <br> <br>    p-&gt;modcnt = nummods; <br>    UpdatePtrs( p, &amp;p-&gt;pCvModules, (LPVOID)m, nummods ); <br> <br>    return nummods; <br>} <br> <br> <br>DWORD <br>CreatePublicsFromCoff( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the individual CV public symbol records.  There is one CV <br>    public record created for each COFF symbol that is marked as EXTERNAL <br>    and has a section number greater than zero.  The resulting CV publics <br>    are sorted by section and offset. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure <br> <br> <br>Return Value: <br> <br>    The number of publics created. <br> <br>--*/ <br> <br>{ <br>    int                 i; <br>    DWORD               numaux; <br>    DWORD               numsyms = 0; <br>    char                szSymName[256]; <br>    PIMAGE_SYMBOL       Symbol; <br>    OMFSymHash          *omfSymHash; <br>    DATASYM32           *dataSym; <br>    DATASYM32           *dataSym2; <br> <br>    omfSymHash = (OMFSymHash *) p-&gt;pCvCurr; <br>    dataSym = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash + sizeof(OMFSymHash)); <br> <br>    for (i= 0, Symbol = p-&gt;iptrs.AllSymbols; <br>         i &lt; p-&gt;iptrs.numberOfSymbols; <br>         i += numaux + 1, Symbol += numaux + 1) { <br> <br>        if ((Symbol-&gt;StorageClass == IMAGE_SYM_CLASS_EXTERNAL) &amp;&amp; <br>            (Symbol-&gt;SectionNumber &gt; 0)) { <br> <br>            if (GetSymName( Symbol, p-&gt;iptrs.stringTable, szSymName )) { <br>                dataSym-&gt;rectyp = S_PUB32; <br>                dataSym-&gt;seg = Symbol-&gt;SectionNumber; <br>                dataSym-&gt;off = Symbol-&gt;Value - <br>                     p-&gt;iptrs.sectionHdrs[Symbol-&gt;SectionNumber-1].VirtualAddress; <br>                dataSym-&gt;typind = 0; <br>                dataSym-&gt;name[0] = strlen( szSymName ); <br>                strcpy( &amp;dataSym-&gt;name[1], szSymName ); <br>                dataSym2 = NextSym32( dataSym ); <br>                dataSym-&gt;reclen = (USHORT) ((DWORD)dataSym2 - (DWORD)dataSym) - 2; <br>                dataSym = dataSym2; <br>                numsyms += 1; <br>            } <br>        } <br>        numaux = Symbol-&gt;NumberOfAuxSymbols; <br>    } <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvPublics, (LPVOID)dataSym, numsyms ); <br> <br>    omfSymHash-&gt;cbSymbol = p-&gt;pCvPublics.size - sizeof(OMFSymHash); <br>    omfSymHash-&gt;symhash  = 0; <br>    omfSymHash-&gt;addrhash = 0; <br>    omfSymHash-&gt;cbHSym   = 0; <br>    omfSymHash-&gt;cbHAddr  = 0; <br> <br>    return numsyms; <br>}                               /* CreatePublisFromCoff() */ <br> <br> <br>DWORD <br>CreateSrcLinenumbers( <br>    PPOINTERS p <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the individual CV soure line number records. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure <br> <br> <br>Return Value: <br> <br>    The number of publics created. <br> <br>--*/ <br> <br>{ <br>    typedef struct _SEGINFO { <br>        DWORD   start; <br>        DWORD   end; <br>        DWORD   cbLines; <br>        DWORD   ptrLines; <br>        DWORD   va; <br>        DWORD   num; <br>        BOOL    used; <br>    } SEGINFO, *LPSEGINFO; <br> <br>    typedef struct _SRCINFO { <br>        LPSEGINFO   seg; <br>        DWORD       numSeg; <br>        DWORD       cbSeg; <br>        CHAR        name[MAX_PATH+1]; <br>    } SRCINFO, *LPSRCINFO; <br> <br>    typedef struct _SECTINFO { <br>        DWORD       va; <br>        DWORD       size; <br>        DWORD       ptrLines; <br>        DWORD       numLines; <br>    } SECTINFO, *LPSECTINFO; <br> <br> <br>    DWORD               i; <br>    DWORD               j; <br>    DWORD               k; <br>    DWORD               l; <br>    DWORD               actual; <br>    DWORD               sidx; <br>    DWORD               NumSrcFiles; <br>    DWORD               SrcFileCnt; <br>    DWORD               numaux; <br>    PIMAGE_SYMBOL       Symbol; <br>    PIMAGE_AUX_SYMBOL   AuxSymbol; <br>    BOOL                first = TRUE; <br>    OMFSourceModule     *SrcModule; <br>    OMFSourceFile       *SrcFile; <br>    OMFSourceLine       *SrcLine; <br>    LPBYTE              lpb; <br>    LPDWORD             lpdw; <br>    PUSHORT             lps; <br>    PUCHAR              lpc; <br>    PIMAGE_LINENUMBER   pil, pilSave; <br>    LPSRCINFO           si; <br>    LPSECTINFO          sections; <br> <br> <br>    // <br>    // setup the section info structure <br>    // <br>    sections = (LPSECTINFO) malloc( sizeof(SECTINFO) * p-&gt;iptrs.numberOfSections ); <br>    for (i=0; i&lt;(DWORD)p-&gt;iptrs.numberOfSections; i++) { <br>        sections[i].va        = p-&gt;iptrs.sectionHdrs[i].VirtualAddress; <br>        sections[i].size      = p-&gt;iptrs.sectionHdrs[i].SizeOfRawData; <br>        sections[i].ptrLines  = p-&gt;iptrs.sectionHdrs[i].PointerToLinenumbers; <br>        sections[i].numLines  = p-&gt;iptrs.sectionHdrs[i].NumberOfLinenumbers; <br>    } <br> <br>    // <br>    // count the number of source files that contibute linenumbers <br>    // <br>    SrcFileCnt = 100; <br>    si = (LPSRCINFO) malloc( sizeof(SRCINFO) * SrcFileCnt ); <br>    ZeroMemory( si, sizeof(SRCINFO) * SrcFileCnt ); <br>    for (i=0, j=0, Symbol=p-&gt;iptrs.AllSymbols, NumSrcFiles=0; <br>         i&lt;(DWORD)p-&gt;iptrs.numberOfSymbols; <br>         i+=(numaux+1), Symbol+=(numaux + 1)) { <br> <br>        numaux = Symbol-&gt;NumberOfAuxSymbols; <br>        AuxSymbol = (PIMAGE_AUX_SYMBOL) (Symbol+1); <br> <br>        if (Symbol-&gt;StorageClass == IMAGE_SYM_CLASS_FILE) { <br> <br>            if (!first) { <br>                si[NumSrcFiles].cbSeg = j; <br>                NumSrcFiles++; <br>                if (NumSrcFiles == SrcFileCnt) { <br>                    SrcFileCnt += 100; <br>                    si = (LPSRCINFO) realloc( si, sizeof(SRCINFO) * SrcFileCnt ); <br>                } <br>            } <br> <br>            memcpy(si[NumSrcFiles].name, (char *)AuxSymbol, numaux*sizeof(IMAGE_AUX_SYMBOL)); <br>            si[NumSrcFiles].name[numaux*sizeof(IMAGE_AUX_SYMBOL)] = 0; <br>            si[NumSrcFiles].numSeg = 100; <br>            si[NumSrcFiles].seg = (LPSEGINFO) malloc( sizeof(SEGINFO) * si[NumSrcFiles].numSeg ); <br>            ZeroMemory( si[NumSrcFiles].seg, sizeof(SEGINFO) * si[NumSrcFiles].numSeg ); <br>            first = FALSE; <br>            j = 0; <br> <br>        } <br> <br>        // <br>        // we do not want to look for segment information until we <br>        // have found a valid source file <br>        // <br>        if (first) { <br>            continue; <br>        } <br> <br>        // <br>        // check the symbol to see if it is a segment record <br>        // <br>        if (numaux &amp;&amp; Symbol-&gt;StorageClass == IMAGE_SYM_CLASS_STATIC &amp;&amp; <br>            (*Symbol-&gt;n_name == '.' || <br>             ((Symbol-&gt;Type &amp; 0xf) == IMAGE_SYM_TYPE_NULL &amp;&amp; AuxSymbol-&gt;Section.Length)) &amp;&amp; <br>            AuxSymbol-&gt;Section.NumberOfLinenumbers &gt; 0) { <br> <br>            // <br>            // find the section that this symbol belongs to <br>            // <br>            for (k=0; k&lt;(DWORD)p-&gt;iptrs.numberOfSections; k++) { <br>                if (Symbol-&gt;Value &gt;= sections[k].va &amp;&amp; <br>                    Symbol-&gt;Value &lt; sections[k].va + sections[k].size) { <br> <br>                    sidx = k; <br>                    break; <br> <br>                } <br>            } <br> <br>            if (k != (DWORD)p-&gt;iptrs.numberOfSections &amp;&amp; <br>                p-&gt;iptrs.sectionHdrs[k].NumberOfLinenumbers) { <br> <br>                pil = (PIMAGE_LINENUMBER) (p-&gt;iptrs.fptr + sections[sidx].ptrLines); <br>                k = 0; <br> <br>                while( k &lt; AuxSymbol-&gt;Section.NumberOfLinenumbers ) { <br> <br>                    // <br>                    // count the linenumbers in this section or sub-section <br>                    // <br>                    for ( pilSave=pil,l=0; <br>                          k&lt;AuxSymbol-&gt;Section.NumberOfLinenumbers; <br>                          k++,pilSave++,l++ ) { <br> <br>                        if ((k != (DWORD)AuxSymbol-&gt;Section.NumberOfLinenumbers-1) &amp;&amp; <br>                            (pilSave-&gt;Linenumber &gt; (pilSave+1)-&gt;Linenumber)) { <br>                            pilSave++; <br>                            l++; <br>                            break; <br>                        } <br> <br>                    } <br> <br>                    // <br>                    // pil     == beginning of the range <br>                    // pilSave == end of the range <br>                    // <br> <br>                    si[NumSrcFiles].seg[j].start = <br>                                     (pil-&gt;Type.VirtualAddress - sections[sidx].va); <br> <br>                    if (sections[sidx].numLines == l) { <br>                        pilSave--; <br>                        si[NumSrcFiles].seg[j].end = <br>                                     (pilSave-&gt;Type.VirtualAddress - sections[sidx].va) + 1; <br>//                                   (Symbol-&gt;Value - sections[sidx].va) + 1; <br>                    } else { <br>                        si[NumSrcFiles].seg[j].end = <br>                                     (pilSave-&gt;Type.VirtualAddress - sections[sidx].va) - 1; <br>//                                   (Symbol-&gt;Value - sections[sidx].va) - 1; <br>                    } <br> <br>                    si[NumSrcFiles].seg[j].ptrLines = sections[sidx].ptrLines; <br>                    si[NumSrcFiles].seg[j].cbLines = l; <br>                    si[NumSrcFiles].seg[j].va = sections[sidx].va; <br>                    si[NumSrcFiles].seg[j].num = sidx + 1; <br>                    si[NumSrcFiles].seg[j].used = FALSE; <br> <br>                    sections[sidx].ptrLines += (l * sizeof(IMAGE_LINENUMBER)); <br>                    sections[sidx].numLines -= l; <br> <br>                    j++; <br>                    if (j == si[NumSrcFiles].numSeg) { <br>                        si[NumSrcFiles].numSeg += 100; <br>                        si[NumSrcFiles].seg = (LPSEGINFO) realloc( si[NumSrcFiles].seg, sizeof(SEGINFO) * si[NumSrcFiles].numSeg ); <br>                    } <br>                    k++; <br>                    pil = pilSave; <br>                } <br> <br>            } <br> <br>        } <br> <br>    } <br> <br>    lpb = (LPBYTE) p-&gt;pCvCurr; <br> <br>    // <br>    // if there is nothing to do then bail out <br>    // <br>    if (!NumSrcFiles) { <br>        UpdatePtrs( p, &amp;p-&gt;pCvSrcModules, (LPVOID)lpb, 0 ); <br>        return 0; <br>    } <br> <br>    for (i=0,actual=0,l=0; i&lt;NumSrcFiles; i++) { <br> <br>        if (si[i].cbSeg == 0) { <br>            continue; <br>        } <br> <br>        // <br>        // create the source module header <br>        // <br>        SrcModule = (OMFSourceModule*) lpb; <br>        SrcModule-&gt;cFile = 1; <br>        SrcModule-&gt;cSeg = (USHORT)si[i].cbSeg; <br>        SrcModule-&gt;baseSrcFile[0] = 0; <br> <br>        // <br>        // write the start/end pairs <br>        // <br>        lpdw = (LPDWORD) ((LPBYTE)SrcModule + sizeof(OMFSourceModule)); <br>        for (k=0; k&lt;si[i].cbSeg; k++) { <br>            *lpdw++ = si[i].seg[k].start; <br>            *lpdw++ = si[i].seg[k].end; <br>        } <br> <br>        // <br>        // write the segment numbers <br>        // <br>        lps = (PUSHORT) lpdw; <br>        for (k=0; k&lt;si[i].cbSeg; k++) { <br>            *lps++ = (USHORT)si[i].seg[k].num; <br>        } <br> <br>        // <br>        // align to a dword boundry <br>        // <br>        lps = (PUSHORT) ((LPBYTE)lps + align(lps)); <br> <br>        // <br>        // update the base pointer <br>        // <br>        SrcModule-&gt;baseSrcFile[0] = (DWORD) ((LPBYTE)lps - (LPBYTE)SrcModule); <br> <br>        // <br>        // write the source file record <br>        // <br>        SrcFile = (OMFSourceFile*) lps; <br>        SrcFile-&gt;cSeg = (USHORT)si[i].cbSeg; <br>        SrcFile-&gt;reserved = 0; <br> <br>        for (k=0; k&lt;si[i].cbSeg; k++) { <br>            SrcFile-&gt;baseSrcLn[k] = 0; <br>        } <br> <br>        // <br>        // write the start/end pairs <br>        // <br>        lpdw = (LPDWORD) ((LPBYTE)SrcFile + 4 + (4 * si[i].cbSeg)); <br>        for (k=0; k&lt;si[i].cbSeg; k++) { <br>            *lpdw++ = si[i].seg[k].start; <br>            *lpdw++ = si[i].seg[k].end; <br>        } <br> <br>        // <br>        // write the source file name <br>        // <br>        lpc = (PUCHAR) lpdw; <br>        k = strlen(si[i].name); <br>        *lpc++ = (UCHAR) k; <br>        strcpy( lpc, si[i].name ); <br>        lpb = lpc + k; <br> <br>        // <br>        // find the module info struct <br>        // <br>        for (; l&lt;p-&gt;modcnt; l++) { <br>            if (stricmp(p-&gt;pMi[l].name,si[i].name)==0) { <br>                break; <br>            } <br>        } <br> <br>        p-&gt;pMi[l].SrcModule = (DWORD) SrcModule; <br> <br>        // <br>        // align to a dword boundry <br>        // <br>        lpb = (LPBYTE) (lpb + align(lpb)); <br> <br>        // <br>        // create the line number pairs <br>        // <br>        for (k=0; k&lt;si[i].cbSeg; k++) { <br> <br>            // <br>            // find the first line number that applies to this segment <br>            // <br>            pil = (PIMAGE_LINENUMBER) (p-&gt;iptrs.fptr + si[i].seg[k].ptrLines); <br> <br>            // <br>            // update the base pointer <br>            // <br>            SrcFile-&gt;baseSrcLn[k] = (DWORD) (lpb - (LPBYTE)SrcModule); <br> <br>            // <br>            // write the line numbers <br>            // <br>            SrcLine = (OMFSourceLine*) lpb; <br>            SrcLine-&gt;Seg = (USHORT)si[i].seg[k].num; <br>            SrcLine-&gt;cLnOff = (USHORT) si[i].seg[k].cbLines; <br>            pilSave = pil; <br>            lpdw = (LPDWORD) (lpb + 4); <br>            for (j=0; j&lt;SrcLine-&gt;cLnOff; j++) { <br>                *lpdw++ = pil-&gt;Type.VirtualAddress - si[i].seg[k].va; <br>                pil++; <br>            } <br>            lps = (PUSHORT) lpdw; <br>            pil = pilSave; <br>            for (j=0; j&lt;SrcLine-&gt;cLnOff; j++) { <br>                *lps++ = pil-&gt;Linenumber; <br>                pil++; <br>            } <br> <br>            // <br>            // align to a dword boundry <br>            // <br>            lps = (PUSHORT) ((LPBYTE)lps + align(lps)); <br> <br>            lpb = (LPBYTE) lps; <br>        } <br> <br>        p-&gt;pMi[l].cb = (DWORD)lpb - (DWORD)SrcModule; <br>        actual++; <br> <br>    } <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvSrcModules, (LPVOID)lpb, actual ); <br> <br>    // <br>    // cleanup all allocated memory <br>    // <br> <br>    free( sections ); <br> <br>    for (i=0; i&lt;SrcFileCnt; i++) { <br>        if (si[i].seg) { <br>            free( si[i].seg ); <br>        } <br>    } <br> <br>    free( si ); <br> <br>    return NumSrcFiles; <br>}                               /* CreateSrcLinenumbers() */ <br> <br> <br>DWORD <br>CreateSegMapFromCoff( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the CV segment map.  The segment map is used by debuggers <br>    to aid in address lookups.  One segment is created for each COFF <br>    section in the image. <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure <br> <br> <br>Return Value: <br> <br>    The number of segments in the map. <br> <br>--*/ <br> <br>{ <br>    int                         i; <br>    SGM                         *sgm; <br>    SGI                         *sgi; <br>    PIMAGE_SECTION_HEADER       sh; <br> <br> <br>    sgm = (SGM *) p-&gt;pCvCurr; <br>    sgi = (SGI *) ((DWORD)p-&gt;pCvCurr + sizeof(SGM)); <br> <br>    sgm-&gt;cSeg = p-&gt;iptrs.numberOfSections; <br>    sgm-&gt;cSegLog = p-&gt;iptrs.numberOfSections; <br> <br>    sh = p-&gt;iptrs.sectionHdrs; <br> <br>    for (i=0; i&lt;p-&gt;iptrs.numberOfSections; i++, sh++) { <br>        sgi-&gt;sgf.fRead        = (USHORT) (sh-&gt;Characteristics &amp; IMAGE_SCN_MEM_READ) ==    IMAGE_SCN_MEM_READ; <br>        sgi-&gt;sgf.fWrite       = (USHORT) (sh-&gt;Characteristics &amp; IMAGE_SCN_MEM_WRITE) ==   IMAGE_SCN_MEM_WRITE; <br>        sgi-&gt;sgf.fExecute     = (USHORT) (sh-&gt;Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE; <br>        sgi-&gt;sgf.f32Bit       = 1; <br>        sgi-&gt;sgf.fSel         = 0; <br>        sgi-&gt;sgf.fAbs         = 0; <br>        sgi-&gt;sgf.fGroup       = 1; <br>        sgi-&gt;iovl             = 0; <br>        sgi-&gt;igr              = 0; <br>        sgi-&gt;isgPhy           = (USHORT) i + 1; <br>        sgi-&gt;isegName         = 0; <br>        sgi-&gt;iclassName       = 0; <br>        sgi-&gt;doffseg          = 0; <br>        sgi-&gt;cbSeg            = sh-&gt;SizeOfRawData; <br>        sgi++; <br>    } <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvSegMap, (LPVOID)sgi, i ); <br> <br>    return i; <br>} <br> <br> <br>LPSTR <br>GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, char *s ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Extracts the COFF symbol from the image symbol pointer and puts <br>    the ascii text in the character pointer passed in. <br> <br> <br>Arguments: <br> <br>    Symbol        - COFF Symbol Record <br>    StringTable   - COFF string table <br>    s             - buffer for the symbol string <br> <br> <br>Return Value: <br> <br>    void <br> <br>--*/ <br> <br>{ <br>    DWORD i; <br> <br>    if (Symbol-&gt;n_zeroes) { <br>        for (i=0; i&lt;8; i++) { <br>            if ((Symbol-&gt;n_name[i]&gt;0x1f) &amp;&amp; (Symbol-&gt;n_name[i]&lt;0x7f)) { <br>                *s++ = Symbol-&gt;n_name[i]; <br>            } <br>        } <br>        *s = 0; <br>    } <br>    else { <br>        if (StringTable[Symbol-&gt;n_offset] == '?') { <br>            i = UnDecorateSymbolName( &amp;StringTable[Symbol-&gt;n_offset], <br>                                  s, <br>                                  255, <br>                                  UNDNAME_COMPLETE                | <br>                                  UNDNAME_NO_LEADING_UNDERSCORES  | <br>                                  UNDNAME_NO_MS_KEYWORDS          | <br>                                  UNDNAME_NO_FUNCTION_RETURNS     | <br>                                  UNDNAME_NO_ALLOCATION_MODEL     | <br>                                  UNDNAME_NO_ALLOCATION_LANGUAGE  | <br>                                  UNDNAME_NO_MS_THISTYPE          | <br>                                  UNDNAME_NO_CV_THISTYPE          | <br>                                  UNDNAME_NO_THISTYPE             | <br>                                  UNDNAME_NO_ACCESS_SPECIFIERS    | <br>                                  UNDNAME_NO_THROW_SIGNATURES     | <br>                                  UNDNAME_NO_MEMBER_TYPE          | <br>                                  UNDNAME_NO_RETURN_UDT_MODEL     | <br>                                  UNDNAME_NO_ARGUMENTS            | <br>                                  UNDNAME_NO_SPECIAL_SYMS         | <br>                                  UNDNAME_NAME_ONLY <br>                                ); <br>            if (!i) { <br>                return NULL; <br>            } <br>        } else { <br>            strcpy( s, &amp;StringTable[Symbol-&gt;n_offset] ); </code></pre>
<p>
</p>
<pre><code>} <br>    } <br> <br>    return s; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
