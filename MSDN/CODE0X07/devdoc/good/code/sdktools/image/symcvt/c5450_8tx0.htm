<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SYMTOCV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5454"></a>SYMTOCV.C</h2>
<pre><code>/*++ <br> <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    symtocv.c <br> <br>Abstract: <br> <br>    This module handles the conversion activities requires for converting <br>    C7/C8 SYM files to CODEVIEW debug data. <br> <br>Author: <br> <br>    Wesley A. Witt (wesw) 13-April-1993 <br> <br>Environment: <br> <br>    Win32, User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "cv.h" <br>#define _SYMCVT_SOURCE_ <br>#include "symcvt.h" <br>#include "cvcommon.h" <br> <br>typedef struct tagSYMNAME { <br>    BYTE        length; <br>    char        name[1]; <br>} SYMNAME, *PSYMNAME; <br> <br>typedef struct tagSYMSYMBOL { <br>    WORD        offset; <br>    SYMNAME     symName; <br>} SYMSYMBOL, *PSYMSYMBOL; <br> <br>typedef struct tagSYMFILEHEADER { <br>    DWORD       fileSize; <br>    WORD        reserved1; <br>    WORD        numSyms; <br>    DWORD       reserved2; <br>    WORD        nextOffset; <br>    BYTE        reserved3; <br>    SYMNAME     symName; <br>} SYMFILEHEADER, *PSYMFILEHEADER; <br> <br>typedef struct tagSYMHEADER { <br>    WORD        nextOffset; <br>    WORD        numSyms; <br>    WORD        reserved1; <br>    WORD        segment; <br>    BYTE        reserved2[12]; <br>    SYMNAME     symName; <br>} SYMHEADER, *PSYMHEADER; <br> <br>#define SIZEOFSYMFILEHEADER   16 <br>#define SIZEOFSYMHEADER       21 <br>#define SIZEOFSYMBOL           3 <br> <br>#define SYM_SEGMENT_NAME       0 <br>#define SYM_SYMBOL_NAME        1 <br>#define SYM_SEGMENT_ABS        2 <br>#define SYM_SYMBOL_ABS         3 <br> <br>typedef struct tagENUMINFO { <br>    DATASYM16           *dataSym; <br>    DATASYM16           *dataSym2; <br>    DWORD               numsyms; <br>    SGI                 *sgi; <br>} ENUMINFO, *PENUMINFO; <br> <br>typedef BOOL (CALLBACK* SYMBOLENUMPROC)(PSYMNAME pSymName, int symType, <br>                                        SEGMENT segment, UOFF16 offset, <br>                                        PENUMINFO pEnumInfo); <br> <br> <br>static VOID   GetSymName( PIMAGE_SYMBOL Symbol, PUCHAR StringTable, <br>                          char * s ); <br>DWORD  CreateModulesFromSyms( PPOINTERS p ); <br>DWORD  CreatePublicsFromSyms( PPOINTERS p ); <br>DWORD  CreateSegMapFromSyms( PPOINTERS p ); <br>static BOOL   EnumSymbols( PPOINTERS p, SYMBOLENUMPROC lpEnumProc, <br>                           PENUMINFO pEnumInfo  ); <br> <br>int             CSymSegs; <br> <br>BOOL CALLBACK <br>SymbolCount(PSYMNAME pSymName, int symType, SEGMENT segment, <br>            UOFF16 offset, PENUMINFO pEnumInfo ) <br>{ <br>    if ((symType == SYM_SEGMENT_NAME) &amp;&amp; (segment &gt; 0)) { <br>        CSymSegs += 1; <br>    } <br>    pEnumInfo-&gt;numsyms++; <br>    return TRUE; <br>} <br> <br>BOOL <br>ConvertSymToCv( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the control function for the conversion of COFF to CODEVIEW <br>    debug data.  It calls individual functions for the conversion of <br>    specific types of debug data. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    TRUE     - conversion succeded <br>    FALSE    - conversion failed <br> <br>--*/ <br> <br>{ <br>    ENUMINFO            enumInfo; <br>    DWORD               dwSize; <br> <br>    CSymSegs = 0; <br>    enumInfo.numsyms = 0; <br>    EnumSymbols( p, SymbolCount, &amp;enumInfo ); <br>    dwSize = (enumInfo.numsyms * (sizeof(DATASYM16) + 10)) + 256000; <br>    p-&gt;pCvCurr = p-&gt;pCvStart.ptr = malloc( dwSize ); <br>    if (p-&gt;pCvStart.ptr == NULL) { <br>        return FALSE; <br>    } <br>    memset( p-&gt;pCvStart.ptr, 0, dwSize ); <br> <br>    try { <br> <br>        CreateSignature( p ); <br>        CreatePublicsFromSyms( p ); <br>        CreateSymbolHashTable( p ); <br>        CreateAddressSortTable( p ); <br>        CreateSegMapFromSyms( p ); <br>        CreateModulesFromSyms( p ); <br>        CreateDirectories( p ); <br>        p-&gt;pCvStart.ptr = realloc( p-&gt;pCvStart.ptr, p-&gt;pCvStart.size ); <br>        return TRUE; <br> <br>    } except (EXCEPTION_EXECUTE_HANDLER) { <br> <br>        free( p-&gt;pCvStart.ptr ); <br>        p-&gt;pCvStart.ptr = NULL; <br>        return FALSE; <br> <br>    } <br>} <br> <br> <br>DWORD <br>CreateModulesFromSyms( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the individual CV module records.  There is one CV module <br>    record for each .FILE record in the COFF debug data.  This is true <br>    even if the COFF size is zero. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    The number of modules that were created. <br> <br>--*/ <br> <br>{ <br>    char                szDrive    [_MAX_DRIVE]; <br>    char                szDir      [_MAX_DIR]; <br>    char                szFname    [_MAX_FNAME]; <br>    char                szExt      [_MAX_EXT]; <br>    OMFModule           *m; <br>    int                 i; <br>    char *              pb; <br> <br>    _splitpath( p-&gt;iptrs.szName, szDrive, szDir, szFname, szExt ); <br> <br>    m = (OMFModule *) p-&gt;pCvCurr; <br> <br>    m-&gt;ovlNumber        = 0; <br>    m-&gt;iLib             = 0; <br>    m-&gt;cSeg             = CSymSegs; <br>    m-&gt;Style[0]         = 'C'; <br>    m-&gt;Style[1]         = 'V'; <br>    for (i=0; i&lt;CSymSegs; i++) { <br>        m-&gt;SegInfo[i].Seg   = i+1; <br>        m-&gt;SegInfo[i].pad   = 0; <br>        m-&gt;SegInfo[i].Off   = 0; <br>        m-&gt;SegInfo[i].cbSeg = 0xffff; <br>    } <br>    pb = (char *) &amp;m-&gt;SegInfo[CSymSegs]; <br>    sprintf( &amp;pb[1], "%s.c", szFname ); <br>    pb[0] = strlen( &amp;pb[1] ); <br> <br>    pb = (char *) NextMod(m); <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvModules, (LPVOID)pb, 1 ); <br> <br>    return 1; <br>} <br> <br>BOOL CALLBACK <br>ConvertASymtoPublic(PSYMNAME pSymName, int symType, SEGMENT segment, <br>                    UOFF16 offset, PENUMINFO pEnumInfo ) <br>{ <br>    if (symType != SYM_SYMBOL_NAME) { <br>        return TRUE; <br>    } <br> <br>    pEnumInfo-&gt;dataSym-&gt;rectyp     = S_PUB16; <br>    pEnumInfo-&gt;dataSym-&gt;seg        = segment; <br>    pEnumInfo-&gt;dataSym-&gt;off        = offset; <br>    pEnumInfo-&gt;dataSym-&gt;typind     = 0; <br>    pEnumInfo-&gt;dataSym-&gt;name[0]    = pSymName-&gt;length; <br>    strncpy( &amp;pEnumInfo-&gt;dataSym-&gt;name[1], pSymName-&gt;name, pSymName-&gt;length ); <br>    pEnumInfo-&gt;dataSym2 = NextSym16( pEnumInfo-&gt;dataSym ); <br>    pEnumInfo-&gt;dataSym-&gt;reclen = (USHORT) ((DWORD)pEnumInfo-&gt;dataSym2 - <br>                                  (DWORD)pEnumInfo-&gt;dataSym) - 2; <br>    pEnumInfo-&gt;dataSym = pEnumInfo-&gt;dataSym2; <br>    pEnumInfo-&gt;numsyms++; <br> <br>    return TRUE; <br>} <br> <br>DWORD <br>CreatePublicsFromSyms( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the individual CV public symbol records.  There is one CV <br>    public record created for each COFF symbol that is marked as EXTERNAL <br>    and has a section number greater than zero.  The resulting CV publics <br>    are sorted by section and offset. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    The number of publics created. <br> <br>--*/ <br> <br>{ <br>    OMFSymHash          *omfSymHash; <br>    ENUMINFO            enumInfo; <br> <br> <br>    enumInfo.dataSym = (DATASYM16 *) <br>                 (PUCHAR)((DWORD)p-&gt;pCvCurr + sizeof(OMFSymHash)); <br>    enumInfo.numsyms = 0; <br> <br>    EnumSymbols( p, ConvertASymtoPublic, &amp;enumInfo ); <br> <br>    omfSymHash = (OMFSymHash *) p-&gt;pCvCurr; <br>    UpdatePtrs(p, &amp;p-&gt;pCvPublics, (LPVOID)enumInfo.dataSym, <br>               enumInfo.numsyms ); <br> <br>    omfSymHash-&gt;cbSymbol = p-&gt;pCvPublics.size - sizeof(OMFSymHash); <br>    omfSymHash-&gt;symhash  = 0; <br>    omfSymHash-&gt;addrhash = 0; <br>    omfSymHash-&gt;cbHSym   = 0; <br>    omfSymHash-&gt;cbHAddr  = 0; <br> <br>    return enumInfo.numsyms; <br>} <br> <br> <br>BOOL CALLBACK <br>ConvertASegment( PSYMNAME pSymName, int symType, SEGMENT segment, <br>            UOFF16 offset, PENUMINFO pEnumInfo ) <br>{ <br>    if (symType != SYM_SEGMENT_NAME) { <br>        return TRUE; <br>    } <br> <br>    if (segment == 0) { <br>        return TRUE; <br>    } <br> <br>    pEnumInfo-&gt;numsyms++; <br> <br>    pEnumInfo-&gt;sgi-&gt;sgf.fRead        = TRUE; <br>    pEnumInfo-&gt;sgi-&gt;sgf.fWrite       = TRUE; <br>    pEnumInfo-&gt;sgi-&gt;sgf.fExecute     = TRUE; <br>    pEnumInfo-&gt;sgi-&gt;sgf.f32Bit       = 0; <br>    pEnumInfo-&gt;sgi-&gt;sgf.fSel         = 0; <br>    pEnumInfo-&gt;sgi-&gt;sgf.fAbs         = 0; <br>    pEnumInfo-&gt;sgi-&gt;sgf.fGroup       = 1; <br>    pEnumInfo-&gt;sgi-&gt;iovl             = 0; <br>    pEnumInfo-&gt;sgi-&gt;igr              = 0; <br>    pEnumInfo-&gt;sgi-&gt;isgPhy           = (USHORT) pEnumInfo-&gt;numsyms; <br>    pEnumInfo-&gt;sgi-&gt;isegName         = 0; <br>    pEnumInfo-&gt;sgi-&gt;iclassName       = 0; <br>    pEnumInfo-&gt;sgi-&gt;doffseg          = offset; <br>    pEnumInfo-&gt;sgi-&gt;cbSeg            = 0xFFFF; <br>    pEnumInfo-&gt;sgi++; <br> <br>    return TRUE; <br>} <br> <br> <br>DWORD <br>CreateSegMapFromSyms( PPOINTERS p ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Creates the CV segment map.  The segment map is used by debuggers <br>    to aid in address lookups.  One segment is created for each COFF <br>    section in the image. <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    The number of segments in the map. <br> <br>--*/ <br> <br>{ <br>    SGM          *sgm; <br>    ENUMINFO     enumInfo; <br> <br> <br>    sgm = (SGM *) p-&gt;pCvCurr; <br>    enumInfo.sgi = (SGI *) ((DWORD)p-&gt;pCvCurr + sizeof(SGM)); <br>    enumInfo.numsyms = 0; <br> <br>    EnumSymbols( p, ConvertASegment, &amp;enumInfo ); <br> <br>    sgm-&gt;cSeg = (USHORT)enumInfo.numsyms; <br>    sgm-&gt;cSegLog = (USHORT)enumInfo.numsyms; <br> <br>    UpdatePtrs( p, &amp;p-&gt;pCvSegMap, (LPVOID)enumInfo.sgi, enumInfo.numsyms ); <br> <br>    return enumInfo.numsyms; <br>} <br> <br>BOOL <br>EnumSymbols( PPOINTERS p, SYMBOLENUMPROC lpEnumProc, PENUMINFO pEnumInfo ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function enumerates all symbols ine the mapped SYM file <br> <br> <br>Arguments: <br> <br>    p             -  pointer to a POINTERS structure <br>    lpEnumProc    -  function to be called once for each function <br>    pEnumInfo     -  data to be passed between the caller and the enum func <br> <br>Return Value: <br> <br>    TRUE     - success <br>    FALSE    - failure <br> <br>--*/ <br> <br>{ <br>    PSYMFILEHEADER      pSymFileHead; <br>    PSYMHEADER          pSymHead; <br>    PSYMHEADER          pSymHead2; <br>    PSYMSYMBOL          pSymSymbol; <br>    DWORD               i; <br>    DWORD               startPosition; <br>    DWORD               position; <br>    BOOL                fV86Mode; <br>    WORD                Segment; <br>    UOFF16              Offset; <br> <br> <br>    pSymFileHead = (PSYMFILEHEADER) p-&gt;iptrs.fptr; <br>    pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymFileHead + SIZEOFSYMFILEHEADER + <br>                               pSymFileHead-&gt;symName.length + 1); <br> <br>    if (!lpEnumProc(&amp;pSymFileHead-&gt;symName, SYM_SEGMENT_ABS, <br>                    0, 0, pEnumInfo )) { <br>        return FALSE; <br>    } <br> <br>    for (i=0; i&lt;pSymFileHead-&gt;numSyms; i++) { <br>        if (!lpEnumProc(&amp;pSymSymbol-&gt;symName, SYM_SYMBOL_ABS, <br>                        0, pSymSymbol-&gt;offset, pEnumInfo )) { <br>            return FALSE; <br>        } <br>        pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymSymbol + SIZEOFSYMBOL + <br>                                   pSymSymbol-&gt;symName.length); <br>    } <br> <br>    position = startPosition = ((LONG)pSymFileHead-&gt;nextOffset) &lt;&lt; 4; <br> <br>    // <br>    //  Determine if this is a V86Mode sym file. <br>    // <br>    //  We'll read the first two headers. If their segment numbers are <br>    //  not 1 and 2, then we assume V86Mode. <br>    // <br>    pSymHead  = (PSYMHEADER) ((DWORD)p-&gt;iptrs.fptr + position); <br>    position  = ((LONG)pSymHead-&gt;nextOffset) &lt;&lt; 4; <br>    if ( position != startPosition &amp;&amp; position != 0 ) { <br>        pSymHead2 = (PSYMHEADER) ((DWORD)p-&gt;iptrs.fptr + position); <br>    } else { <br>        pSymHead2 = NULL; <br>    } <br> <br>    if ( pSymHead-&gt;segment == 1 &amp;&amp; <br>         (!pSymHead2 || pSymHead2-&gt;segment == 2)) { <br>        fV86Mode = FALSE; <br>    } else { <br>        fV86Mode = TRUE; <br>        Segment  = 0; <br>    } <br> <br>    position = startPosition; <br> <br>    do { <br>        pSymHead = (PSYMHEADER) ((DWORD)p-&gt;iptrs.fptr + position); <br>        pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymHead + SIZEOFSYMHEADER + <br>                                   pSymHead-&gt;symName.length); <br> <br>        if ( fV86Mode ) { <br>            Segment++; <br>            Offset  = pSymHead-&gt;segment; <br>        } else { <br>            Segment = pSymHead-&gt;segment; <br>            Offset  = 0; <br>        } <br> <br>        position = ((LONG)pSymHead-&gt;nextOffset) &lt;&lt; 4; <br> <br>        if (!lpEnumProc( &amp;pSymHead-&gt;symName, SYM_SEGMENT_NAME, <br>                        Segment, Offset, pEnumInfo )) { <br>            return FALSE; <br>        } <br> <br>        for (i=0; i&lt;pSymHead-&gt;numSyms; i++) { <br>            if (!lpEnumProc(&amp;pSymSymbol-&gt;symName, SYM_SYMBOL_NAME, <br>                            Segment, pSymSymbol-&gt;offset, <br>                            pEnumInfo )) { <br>                return FALSE; <br>            } <br>            pSymSymbol = (PSYMSYMBOL) ((DWORD)pSymSymbol + SIZEOFSYMBOL + <br>                                       pSymSymbol-&gt;symName.length); <br>        } <br>    } while ( position != startPosition &amp;&amp; position != 0 ); <br> <br>    return 0; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
