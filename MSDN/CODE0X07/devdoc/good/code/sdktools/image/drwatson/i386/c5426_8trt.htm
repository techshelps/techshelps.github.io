<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REGS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5429"></a>REGS.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    regs.c <br> <br>Abstract: <br> <br>    This file provides access to the machine's register set. <br> <br>Author: <br> <br>    Wesley Witt (wesw) 1-May-1993  (ported from ntsd) <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "drwatson.h" <br>#include "proto.h" <br>#include "regs.h" <br> <br> <br> <br>ULONG  GetDregValue (PDEBUGPACKET dp, ULONG index); <br> <br> <br> <br> <br>char    szGsReg[]    = "gs"; <br>char    szFsReg[]    = "fs"; <br>char    szEsReg[]    = "es"; <br>char    szDsReg[]    = "ds"; <br>char    szEdiReg[]   = "edi"; <br>char    szEsiReg[]   = "esi"; <br>char    szEbxReg[]   = "ebx"; <br>char    szEdxReg[]   = "edx"; <br>char    szEcxReg[]   = "ecx"; <br>char    szEaxReg[]   = "eax"; <br>char    szEbpReg[]   = "ebp"; <br>char    szEipReg[]   = "eip"; <br>char    szCsReg[]    = "cs"; <br>char    szEflReg[]   = "efl"; <br>char    szEspReg[]   = "esp"; <br>char    szSsReg[]    = "ss"; <br>char    szDiReg[]    = "di"; <br>char    szSiReg[]    = "si"; <br>char    szBxReg[]    = "bx"; <br>char    szDxReg[]    = "dx"; <br>char    szCxReg[]    = "cx"; <br>char    szAxReg[]    = "ax"; <br>char    szBpReg[]    = "bp"; <br>char    szIpReg[]    = "ip"; <br>char    szFlReg[]    = "fl"; <br>char    szSpReg[]    = "sp"; <br>char    szBlReg[]    = "bl"; <br>char    szDlReg[]    = "dl"; <br>char    szClReg[]    = "cl"; <br>char    szAlReg[]    = "al"; <br>char    szBhReg[]    = "bh"; <br>char    szDhReg[]    = "dh"; <br>char    szChReg[]    = "ch"; <br>char    szAhReg[]    = "ah"; <br>char    szIoplFlag[] = "iopl"; <br>char    szFlagOf[]   = "of"; <br>char    szFlagDf[]   = "df"; <br>char    szFlagIf[]   = "if"; <br>char    szFlagTf[]   = "tf"; <br>char    szFlagSf[]   = "sf"; <br>char    szFlagZf[]   = "zf"; <br>char    szFlagAf[]   = "af"; <br>char    szFlagPf[]   = "pf"; <br>char    szFlagCf[]   = "cf"; <br>char    szFlagVip[]  = "vip"; <br>char    szFlagVif[]  = "vif"; <br> <br>struct Reg { <br>        char    *psz; <br>        ULONG   value; <br>        }; <br> <br>struct SubReg { <br>        ULONG   regindex; <br>        ULONG   shift; <br>        ULONG   mask; <br>        }; <br> <br>struct Reg regname[] = { <br>        { szGsReg,    REGGS    }, <br>        { szFsReg,    REGFS    }, <br>        { szEsReg,    REGES    }, <br>        { szDsReg,    REGDS    }, <br>        { szEdiReg,   REGEDI   }, <br>        { szEsiReg,   REGESI   }, <br>        { szEbxReg,   REGEBX   }, <br>        { szEdxReg,   REGEDX   }, <br>        { szEcxReg,   REGECX   }, <br>        { szEaxReg,   REGEAX   }, <br>        { szEbpReg,   REGEBP   }, <br>        { szEipReg,   REGEIP   }, <br>        { szCsReg,    REGCS    }, <br>        { szEflReg,   REGEFL   }, <br>        { szEspReg,   REGESP   }, <br>        { szSsReg,    REGSS    }, <br>        { szDiReg,    REGDI    }, <br>        { szSiReg,    REGSI    }, <br>        { szBxReg,    REGBX    }, <br>        { szDxReg,    REGDX    }, <br>        { szCxReg,    REGCX    }, <br>        { szAxReg,    REGAX    }, <br>        { szBpReg,    REGBP    }, <br>        { szIpReg,    REGIP    }, <br>        { szFlReg,    REGFL    }, <br>        { szSpReg,    REGSP    }, <br>        { szBlReg,    REGBL    }, <br>        { szDlReg,    REGDL    }, <br>        { szClReg,    REGCL    }, <br>        { szAlReg,    REGAL    }, <br>        { szBhReg,    REGBH    }, <br>        { szDhReg,    REGDH    }, <br>        { szChReg,    REGCH    }, <br>        { szAhReg,    REGAH    }, <br>        { szIoplFlag, FLAGIOPL }, <br>        { szFlagOf,   FLAGOF   }, <br>        { szFlagDf,   FLAGDF   }, <br>        { szFlagIf,   FLAGIF   }, <br>        { szFlagTf,   FLAGTF   }, <br>        { szFlagSf,   FLAGSF   }, <br>        { szFlagZf,   FLAGZF   }, <br>        { szFlagAf,   FLAGAF   }, <br>        { szFlagPf,   FLAGPF   }, <br>        { szFlagCf,   FLAGCF   }, <br>        { szFlagVip,  FLAGVIP  }, <br>        { szFlagVif,  FLAGVIF  }, <br>        }; <br> <br>#define REGNAMESIZE (sizeof(regname) / sizeof(struct Reg)) <br> <br>struct SubReg subregname[] = { <br>        { REGEDI,  0, 0xffff },         //  DI register <br>        { REGESI,  0, 0xffff },         //  SI register <br>        { REGEBX,  0, 0xffff },         //  BX register <br>        { REGEDX,  0, 0xffff },         //  DX register <br>        { REGECX,  0, 0xffff },         //  CX register <br>        { REGEAX,  0, 0xffff },         //  AX register <br>        { REGEBP,  0, 0xffff },         //  BP register <br>        { REGEIP,  0, 0xffff },         //  IP register <br>        { REGEFL,  0, 0xffff },         //  FL register <br>        { REGESP,  0, 0xffff },         //  SP register <br>        { REGEBX,  0,   0xff },         //  BL register <br>        { REGEDX,  0,   0xff },         //  DL register <br>        { REGECX,  0,   0xff },         //  CL register <br>        { REGEAX,  0,   0xff },         //  AL register <br>        { REGEBX,  8,   0xff },         //  BH register <br>        { REGEDX,  8,   0xff },         //  DH register <br>        { REGECX,  8,   0xff },         //  CH register <br>        { REGEAX,  8,   0xff },         //  AH register <br>        { REGEFL, 12,      3 },         //  IOPL level value <br>        { REGEFL, 11,      1 },         //  OF (overflow flag) <br>        { REGEFL, 10,      1 },         //  DF (direction flag) <br>        { REGEFL,  9,      1 },         //  IF (interrupt enable flag) <br>        { REGEFL,  8,      1 },         //  TF (trace flag) <br>        { REGEFL,  7,      1 },         //  SF (sign flag) <br>        { REGEFL,  6,      1 },         //  ZF (zero flag) <br>        { REGEFL,  4,      1 },         //  AF (aux carry flag) <br>        { REGEFL,  2,      1 },         //  PF (parity flag) <br>        { REGEFL,  0,      1 },         //  CF (carry flag) <br>        { REGEFL, 20,      1 },         //  VIP (virtual interrupt pending) <br>        { REGEFL, 19,      1 }          //  VIF (virtual interrupt flag) <br>        }; <br> <br>DWORDLONG <br>GetRegFlagValue (PDEBUGPACKET dp, ULONG regnum) <br>{ <br>    DWORDLONG value; <br> <br>    if (regnum &lt; FLAGBASE) <br>        value = GetRegValue(dp, regnum); <br>    else { <br>        regnum -= FLAGBASE; <br>        value = GetRegValue(dp, subregname[regnum].regindex); <br>        value = (value &gt;&gt; subregname[regnum].shift) &amp; subregname[regnum].mask; <br>        } <br>    return value; <br>} <br> <br>DWORDLONG <br>GetRegValue ( <br>    PDEBUGPACKET dp, <br>    ULONG regnum <br>    ) <br>{ <br>    switch (regnum) { <br>        case REGGS: <br>            return dp-&gt;tctx-&gt;context.SegGs; <br>        case REGFS: <br>            return dp-&gt;tctx-&gt;context.SegFs; <br>        case REGES: <br>            return dp-&gt;tctx-&gt;context.SegEs; <br>        case REGDS: <br>            return dp-&gt;tctx-&gt;context.SegDs; <br>        case REGEDI: <br>            return dp-&gt;tctx-&gt;context.Edi; <br>        case REGESI: <br>            return dp-&gt;tctx-&gt;context.Esi; <br>        case REGSI: <br>            return(dp-&gt;tctx-&gt;context.Esi &amp; 0xffff); <br>        case REGDI: <br>            return(dp-&gt;tctx-&gt;context.Edi &amp; 0xffff); <br>        case REGEBX: <br>            return dp-&gt;tctx-&gt;context.Ebx; <br>        case REGEDX: <br>            return dp-&gt;tctx-&gt;context.Edx; <br>        case REGECX: <br>            return dp-&gt;tctx-&gt;context.Ecx; <br>        case REGEAX: <br>            return dp-&gt;tctx-&gt;context.Eax; <br>        case REGEBP: <br>            return dp-&gt;tctx-&gt;context.Ebp; <br>        case REGEIP: <br>            return dp-&gt;tctx-&gt;context.Eip; <br>        case REGCS: <br>            return dp-&gt;tctx-&gt;context.SegCs; <br>        case REGEFL: <br>            return dp-&gt;tctx-&gt;context.EFlags; <br>        case REGESP: <br>            return dp-&gt;tctx-&gt;context.Esp; <br>        case REGSS: <br>            return dp-&gt;tctx-&gt;context.SegSs; <br>        case PREGEA: <br>            return 0; <br>        case PREGEXP: <br>            return 0; <br>        case PREGRA: { <br>            struct { <br>                ULONG   oldBP; <br>                ULONG   retAddr; <br>            } stackRead; <br>            DoMemoryRead( dp, <br>                          (LPVOID)dp-&gt;tctx-&gt;context.Ebp, <br>                          (LPVOID)&amp;stackRead, <br>                          sizeof(stackRead), <br>                          NULL <br>                        ); <br>            return stackRead.retAddr; <br>            } <br>        case PREGP: <br>            return 0; <br>        case REGDR0: <br>            return dp-&gt;tctx-&gt;context.Dr0; <br>        case REGDR1: <br>            return dp-&gt;tctx-&gt;context.Dr1; <br>        case REGDR2: <br>            return dp-&gt;tctx-&gt;context.Dr2; <br>        case REGDR3: <br>            return dp-&gt;tctx-&gt;context.Dr3; <br>        case REGDR6: <br>            return dp-&gt;tctx-&gt;context.Dr6; <br>        case REGDR7: <br>            return dp-&gt;tctx-&gt;context.Dr7; <br>        default: <br>            return 0; <br>        } <br>} <br> <br>ULONG <br>GetRegString (PUCHAR pszString) <br>{ <br>    ULONG   count; <br> <br>    for (count = 0; count &lt; REGNAMESIZE; count++) { <br>        if (!strcmp(pszString, regname[count].psz)) { <br>            return regname[count].value; <br>        } <br>    } <br>    return (ULONG)-1; <br>} <br> <br>void <br>OutputAllRegs( PDEBUGPACKET dp, BOOL Show64 ) <br>{ <br>    lprintfs("eax=%08lx ebx=%08lx ecx=%08lx edx=%08lx esi=%08lx edi=%08lx\r\n", <br>                (DWORD)GetRegValue(dp,REGEAX), <br>                (DWORD)GetRegValue(dp,REGEBX), <br>                (DWORD)GetRegValue(dp,REGECX), <br>                (DWORD)GetRegValue(dp,REGEDX), <br>                (DWORD)GetRegValue(dp,REGESI), <br>                (DWORD)GetRegValue(dp,REGEDI)); <br> <br>    lprintfs("eip=%08lx esp=%08lx ebp=%08lx iopl=%1lx " <br>        "%s %s %s %s %s %s %s %s %s %s\r\n", <br>                (DWORD)GetRegValue(dp,REGEIP), <br>                (DWORD)GetRegValue(dp,REGESP), <br>                (DWORD)GetRegValue(dp,REGEBP), <br>                (DWORD)GetRegFlagValue(dp,FLAGIOPL), <br>        (DWORD)GetRegFlagValue(dp,FLAGVIP) ? "vip" : "   ", <br>        (DWORD)GetRegFlagValue(dp,FLAGVIF) ? "vif" : "   ", <br>        (DWORD)GetRegFlagValue(dp,FLAGOF) ? "ov" : "nv", <br>        (DWORD)GetRegFlagValue(dp,FLAGDF) ? "dn" : "up", <br>        (DWORD)GetRegFlagValue(dp,FLAGIF) ? "ei" : "di", <br>        (DWORD)GetRegFlagValue(dp,FLAGSF) ? "ng" : "pl", <br>        (DWORD)GetRegFlagValue(dp,FLAGZF) ? "zr" : "nz", <br>        (DWORD)GetRegFlagValue(dp,FLAGAF) ? "ac" : "na", <br>        (DWORD)GetRegFlagValue(dp,FLAGPF) ? "po" : "pe", <br>        (DWORD)GetRegFlagValue(dp,FLAGCF) ? "cy" : "nc"); <br>    lprintfs("cs=%04lx  ss=%04lx  ds=%04lx  es=%04lx  fs=%04lx  gs=%04lx" <br>        "             efl=%08lx\r\n", <br>                (DWORD)GetRegValue(dp,REGCS), <br>                (DWORD)GetRegValue(dp,REGSS), <br>                (DWORD)GetRegValue(dp,REGDS), <br>                (DWORD)GetRegValue(dp,REGES), <br>                (DWORD)GetRegValue(dp,REGFS), <br>                (DWORD)GetRegValue(dp,REGGS), <br>        (DWORD)GetRegFlagValue(dp,REGEFL)); <br>    lprintfs("\r\n\r\n"); <br>} <br> <br>void <br>OutputOneReg (PDEBUGPACKET dp, ULONG regnum, BOOL Show64) <br>{ <br>    DWORD value; <br> <br>    value = (DWORD)GetRegFlagValue(dp,regnum); <br>    if (regnum &lt; FLAGBASE) { <br>        lprintfs("%08lx\r\n", value); <br>    } else { <br>        lprintfs("%lx\r\n", value); <br>    } <br>} <br> <br>ULONG <br>GetDregValue (PDEBUGPACKET dp, ULONG index) <br>{ <br>    if (index &lt; 4) { <br>        index += REGDR0; <br>    } else { <br>        index += REGDR6 - 6; <br>    } <br>    return (DWORD)GetRegValue(dp,index); <br>} <br> <br>PUCHAR <br>RegNameFromIndex (ULONG index) <br>{ <br>    ULONG    count; <br> <br>    for (count = 0; count &lt; REGNAMESIZE; count++) { <br>        if (regname[count].value == index) { <br>            return regname[count].psz; <br>        } <br>    } <br>    return NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
