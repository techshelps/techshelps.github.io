<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NOTIFY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5410"></a>NOTIFY.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    browse.c <br> <br>Abstract: <br>    This file implements the functions that make use of the common <br>    file open dialogs for browsing for files/directories. <br> <br>Author: <br> <br>    Wesley Witt (wesw) 1-May-1993 <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;direct.h&gt; <br> <br>#include "drwatson.h" <br>#include "proto.h" <br>#include "resource.h" <br>#include "messages.h" <br> <br> <br>// <br>// defines <br>// <br>#define DEFAULT_WAIT_TIME   (1000 * 60 * 5)     // wait for 5 minutes <br> <br>// <br>// static global variables <br>// <br>static HANDLE         hThreadDebug; <br>static PDEBUGPACKET   dp; <br> <br> <br>LRESULT NotifyWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK UsageDialogProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam); <br> <br> <br>void <br>NotifyWinMain ( void ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the entry point for DRWTSN32 <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    MSG            msg; <br>    WNDCLASS       wndclass; <br>    DWORD          dwThreadId; <br>    HINSTANCE      hInst; <br> <br> <br>    dp = (PDEBUGPACKET) malloc( sizeof(DEBUGPACKET) ); <br>    memset( dp, 0, sizeof(DEBUGPACKET) ); <br>    GetCommandLineArgs( &amp;dp-&gt;dwPidToDebug, &amp;dp-&gt;hEventToSignal ); <br> <br>    InitializeListHead(&amp;dp-&gt;ThreadList); <br> <br>    RegInitialize( &amp;dp-&gt;options ); <br> <br>    if (dp-&gt;options.fVisual) { <br>        hInst                   = GetModuleHandle( NULL ); <br>        wndclass.style          = CS_HREDRAW | CS_VREDRAW; <br>        wndclass.lpfnWndProc    = NotifyWndProc; <br>        wndclass.cbClsExtra     = 0; <br>        wndclass.cbWndExtra     = DLGWINDOWEXTRA; <br>        wndclass.hInstance      = hInst; <br>        wndclass.hIcon          = LoadIcon( hInst, MAKEINTRESOURCE(APPICON) ); <br>        wndclass.hCursor        = LoadCursor( NULL, IDC_ARROW ); <br>        wndclass.hbrBackground  = (HBRUSH) (COLOR_3DFACE + 1); <br>        wndclass.lpszMenuName   = NULL; <br>        wndclass.lpszClassName  = "NotifyDialog"; <br>        RegisterClass( &amp;wndclass ); <br> <br>        dp-&gt;hwnd = CreateDialog( hInst, <br>                                 MAKEINTRESOURCE( NOTIFYDIALOG ), <br>                                 0, <br>                                 NotifyWndProc ); <br>    } <br> <br>    hThreadDebug = CreateThread( NULL, <br>                            16000, <br>                            (LPTHREAD_START_ROUTINE)DispatchDebugEventThread, <br>                            dp, <br>                            0, <br>                            (LPDWORD)&amp;dwThreadId <br>                          ); <br> <br>    if (dp-&gt;options.fSound) { <br>        if ((waveOutGetNumDevs() == 0) || (!strlen(dp-&gt;options.szWaveFile))) { <br>            MessageBeep( MB_ICONHAND ); <br>            MessageBeep( MB_ICONHAND ); <br>        } <br>        else { <br>            PlaySound( dp-&gt;options.szWaveFile, NULL, SND_FILENAME ); <br>        } <br>    } <br> <br>    if (dp-&gt;options.fVisual) { <br>        ShowWindow( dp-&gt;hwnd, SW_SHOWNORMAL ); <br>        while (GetMessage (&amp;msg, NULL, 0, 0)) { <br>            if (!IsDialogMessage( dp-&gt;hwnd, &amp;msg )) { <br>                TranslateMessage (&amp;msg) ; <br>                DispatchMessage (&amp;msg) ; <br>            } <br>        } <br>    } <br>    else { <br>        WaitForSingleObject( hThreadDebug, INFINITE ); <br>    } <br> <br>    CloseHandle( hThreadDebug ); <br> <br>    return; <br>} <br> <br>LRESULT <br>NotifyWndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Window procedure for the DRWTSN32.EXE popup.  This is the popup <br>    that is displayed when an application error occurs. <br> <br>Arguments: <br> <br>    hwnd       - window handle to the dialog box <br>    message    - message number <br>    wParam     - first message parameter <br>    lParam     - second message parameter <br> <br>Return Value: <br> <br>    TRUE       - did not process the message <br>    FALSE      - did process the message <br> <br>--*/ <br> <br>{ <br>    DWORD          dwThreadId; <br>    DWORD          dwSize; <br>    HANDLE         hThread; <br>    char           szTaskName[MAX_PATH]; <br>    char           szHelpFileName[MAX_PATH]; <br> <br>    switch (message) { <br>        case WM_CREATE: <br>            return FALSE; <br> <br>        case WM_INITDIALOG: <br> <br>            SubclassControls( hwnd ); <br> <br>            // <br>            // OK is not enabled until the debugger thread finishes <br>            // <br>            EnableWindow( GetDlgItem( hwnd, IDOK ), FALSE ); <br> <br>            // <br>            // CANCEL is not enabled until debugactiveprocess is finished <br>            // <br>            EnableWindow( GetDlgItem( hwnd, IDCANCEL ), FALSE ); <br> <br>            // <br>            //  make sure that the user can see the dialog box <br>            // <br>            SetForegroundWindow( hwnd ); <br> <br>            // <br>            // get the task name and display it on the dialog box <br>            // <br>            dwSize = sizeof(szTaskName); <br>            GetTaskName( dp-&gt;dwPidToDebug, szTaskName, &amp;dwSize ); <br> <br>            // <br>            // prevent recursion in the case where drwatson faults <br>            // <br>            if (_stricmp(szTaskName,"drwtsn32")==0) { <br>                ExitProcess(0); <br>            } <br> <br>            SetDlgItemText( hwnd, ID_TEXT1, szTaskName); <br> <br>            return TRUE; <br> <br>        case WM_ACTIVATEAPP: <br>        case WM_SETFOCUS: <br>            SetFocusToCurrentControl(); <br>            return 0; <br> <br>        case WM_COMMAND: <br>            switch (wParam) { <br>                case IDOK: <br>                    PostQuitMessage( 0 ); <br>                    break; <br> <br>                case IDCANCEL: <br>                    // <br>                    // terminate the debugger thread <br>                    // <br>                    TerminateThread( hThreadDebug, 0 ); <br> <br>                    // <br>                    // create a thread to terminate the debuggee <br>                    // this is necessary if cancel is pressed before the <br>                    // debugger thread finishes the postmortem dump <br>                    // <br>                    hThread = CreateThread( NULL, <br>                                  16000, <br>                                  (LPTHREAD_START_ROUTINE)TerminationThread, <br>                                  dp, <br>                                  0, <br>                                  (LPDWORD)&amp;dwThreadId <br>                                ); <br> <br>                    // <br>                    // wait for the termination thread to kill the debuggee <br>                    // <br>                    WaitForSingleObject( hThread, 30000 ); <br> <br>                    CloseHandle( hThread ); <br> <br>                    // <br>                    // now post a quit message so that DrWatson will go away <br>                    // <br>                    PostQuitMessage( 0 ); <br>                    break; <br> <br>                case ID_HELP: <br>                    // <br>                    // call winhelp <br>                    // <br>                    GetHelpFileName( szHelpFileName, sizeof(szHelpFileName) ); <br>                    WinHelp( hwnd, szHelpFileName, HELP_FINDER, IDH_WHAT ); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_NEXTDLGCTL: <br>            DefDlgProc( hwnd, message, wParam, lParam ); <br>            return 0; <br> <br>        case WM_DUMPCOMPLETE: <br> <br>            // <br>            // the message is received from the debugger thread <br>            // when the postmortem dump is finished.  all we need to do <br>            // is enable the OK button and wait for the user to press the <br>            // OK button or for the timer to expire.  in either case <br>            // DrWatson will terminate. <br>            // <br>            EnableWindow( GetDlgItem( hwnd, IDOK ), TRUE ); <br>            SetFocus( GetDlgItem(hwnd, IDOK) ); <br>            SetFocusToCurrentControl(); <br>            return 0; <br> <br>        case WM_ATTACHCOMPLETE: <br> <br>            // <br>            // the message is received from the debugger thread when <br>            // the debugactiveprocess() is completed <br>            // <br>            EnableWindow( GetDlgItem( hwnd, IDCANCEL ), TRUE ); <br>            return 0; <br> <br>        case WM_EXCEPTIONINFO: <br> <br>            SetDlgItemText( hwnd, ID_TEXT2, (char *) lParam); <br>            return 0; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage( 0 ); <br>            return 0; <br>    } <br> <br>    return DefWindowProc( hwnd, message, wParam, lParam ); <br>} <br> <br>BOOLEAN <br>GetCommandLineArgs( LPDWORD dwPidToDebug, LPHANDLE hEventToSignal ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Parses the command line for the 3 possible command lines <br>    arguments: <br> <br>         -p %ld        process id <br>         -e %ld        event id <br>         -g            go <br> <br>Arguments: <br> <br>    dp             - pointer to a debug packet <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    char        *lpstrCmd = GetCommandLine(); <br>    UCHAR       ch; <br>    char        buf[4096]; <br>    BOOLEAN     rval = FALSE; <br> <br>    // skip over program name <br>    do { <br>        ch = *lpstrCmd++; <br>    } <br>    while (ch != ' ' &amp;&amp; ch != '\t' &amp;&amp; ch != '\0'); <br> <br>    //  skip over any following white space <br>    while (ch == ' ' || ch == '\t') { <br>        ch = *lpstrCmd++; <br>    } <br> <br>    //  process each switch character '-' as encountered <br> <br>    while (ch == '-') { <br>        ch = *lpstrCmd++; <br>        //  process multiple switch characters as needed <br>        do { <br>            switch (ch) { <br>                case 'e': <br>                case 'E': <br>                    // event to signal takes decimal argument <br>                    // skip whitespace <br>                    do { <br>                        ch = *lpstrCmd++; <br>                    } <br>                    while (ch == ' ' || ch == '\t'); <br>                    while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { <br>                        (DWORD)*hEventToSignal = <br>                                  (DWORD)*hEventToSignal * 10 + ch - '0'; <br>                        ch = *lpstrCmd++; <br>                    } <br>                    rval = TRUE; <br>                    break; <br> <br>                case 'p': <br>                case 'P': <br>                    // pid debug takes decimal argument <br> <br>                    do <br>                        ch = *lpstrCmd++; <br>                    while (ch == ' ' || ch == '\t'); <br> <br>                    if ( ch == '-' ) { <br>                        ch = *lpstrCmd++; <br>                        if ( ch == '1' ) { <br>                            *dwPidToDebug = 0xffffffff; <br>                            ch = *lpstrCmd++; <br>                        } <br>                    } <br>                    else { <br>                        while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { <br>                            *dwPidToDebug = <br>                                       *dwPidToDebug * 10 + ch - '0'; <br>                            ch = *lpstrCmd++; <br>                        } <br>                    } <br>                    rval = TRUE; <br>                    break; <br> <br>                case 'g': <br>                case 'G': <br>                    ch = *lpstrCmd++; <br>                    break; <br> <br>                case '?': <br>                    DialogBox( GetModuleHandle(NULL), <br>                               MAKEINTRESOURCE(USAGEDIALOG), <br>                               NULL, <br>                               UsageDialogProc <br>                             ); <br>                    rval = TRUE; <br>                    ch = *lpstrCmd++; <br>                    break; <br> <br>                case 'i': <br>                case 'I': <br>                    FormatMessage( <br>                      FORMAT_MESSAGE_FROM_HMODULE, <br>                      NULL, <br>                      MSG_INSTALL_NOTIFY, <br>                      0, <br>                      buf, <br>                      sizeof(buf), <br>                      NULL <br>                      ); <br>                    RegInstallDrWatson( tolower(lpstrCmd[0]) == 'q' ); <br>                    MessageBox( NULL, <br>                                buf, <br>                                "Dr. Watson for Windows NT", <br>                                MB_ICONINFORMATION | MB_OK | <br>                                MB_SETFOREGROUND ); <br>                    rval = TRUE; <br>                    ch = *lpstrCmd++; <br>                    break; <br> <br>                default: <br>                    return rval; <br>            } <br>        } <br>        while (ch != ' ' &amp;&amp; ch != '\t' &amp;&amp; ch != '\0'); <br> <br>        while (ch == ' ' || ch == '\t') { <br>            ch = *lpstrCmd++; <br>        } <br>    } <br>    return rval; <br>} <br> <br>BOOL CALLBACK <br>UsageDialogProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the dialog procedure for the assert dialog box.  Normally <br>    an assertion box is simply a message box but in this case a Help <br>    button is desired so a dialog box is used. <br> <br>Arguments: <br> <br>    hDlg       - window handle to the dialog box <br>    message    - message number <br>    wParam     - first message parameter <br>    lParam     - second message parameter <br> <br>Return Value: <br> <br>    TRUE       - did not process the message <br>    FALSE      - did process the message <br> <br>--*/ <br> <br>{ <br>    char        buf[4096]; <br> <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            FormatMessage( <br>              FORMAT_MESSAGE_FROM_HMODULE, <br>              NULL, <br>              MSG_USAGE, <br>              0, // GetUserDefaultLangID(), <br>              buf, <br>              sizeof(buf), <br>              NULL <br>              ); <br>            SetDlgItemText( hDlg, ID_USAGE, buf ); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (wParam) { <br>                case IDOK: <br>                    EndDialog( hDlg, 0 ); <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
