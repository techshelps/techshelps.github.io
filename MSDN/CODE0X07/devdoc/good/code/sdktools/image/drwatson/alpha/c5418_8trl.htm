<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OPTABLE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5421"></a>OPTABLE.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Digital Equipment Corporation <br> <br>Module Name: <br> <br>    optable.c <br> <br>Abstract: <br> <br>    Declaration for - <br>    Table of operations, their names and charactersitics <br>    Used by ntsd, windbg and acc's dissassembler <br> <br>Author: <br> <br>    Miche Baker-Harvey (mbh) 10-Jan-1993 <br> <br>Revision History: <br> <br>--*/ <br>#include &lt;excpt.h&gt; <br>#include &lt;windef.h&gt; <br>#include &lt;winnt.h&gt; <br>#include &lt;alphaops.h&gt; <br>#define DEFINE_STRINGS <br>#include "strings.h" <br>#include "optable.h" <br> <br>// for strcmp <br>#include &lt;string.h&gt; <br> <br>// for fVerboseOutput <br>BOOLEAN fVerboseOutput = FALSE; <br> <br>// <br>// These are the parsing functions.  In ntsd, they are defined <br>// in ntasm.c.  In windbg, they are defined in MBH - WHERE???? <br>// <br> <br>ULONG ParseIntMemory (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseFltMemory (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseMemSpec   (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseJump      (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseIntBranch (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseFltBranch (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseIntOp     (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParsePal       (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br>ULONG ParseUnknown   (PUCHAR, PUCHAR *, POPTBLENTRY, PULONG); <br> <br> <br>#define NOFNCTBL (POPTBLENTRY) 0 <br>#define NOSIZE (ULONG)0 <br> <br> <br>// <br>// These fields are used to find the beginning of the sections <br>// containing different "ENTRY_TYPE"s <br>// <br> <br>POPTBLENTRY InvalidTab; <br>POPTBLENTRY NonTerminalTab; <br>POPTBLENTRY TerminalTab; <br>POPTBLENTRY FunctionTab; <br> <br>ULONG        InvalidTabSize; <br>ULONG        NonTerminalTabSize; <br>ULONG        TerminalTabSize; <br>ULONG        FunctionTabSize; <br> <br> <br>// <br>// THE OPCODE TABLE ITSELF <br>// <br>// The opcode table "opTable" describes each opcode and function. <br>// There is an entry for each opcode, and for each function. <br>// <br>// The table is organized as follows: <br>//                invalid-ops, <br>//                non-terminal-ops, <br>//                terminal-ops, <br>//                functions, <br>// <br>//    This organization is NOT required: <br>//           no assumptions are made on it. <br>// <br>//    Searches based on opcode must search <br>//             INVALID, TERMINAL and NON_TERMINAL <br>// <br>//    Searches based on instruction name must search <br>//             TERMINAL and FUNCTION <br>// <br>// <br> <br>OPTBLENTRY opTable[] = { <br> <br> <br>      // <br>      // First, the INVALID_ETYPE section. <br>      // (opcode searches begin here) <br>      // <br> <br> <br>{ "?Opc01", ParseUnknown, _01_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc02", ParseUnknown, _02_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc03", ParseUnknown, _03_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc04", ParseUnknown, _04_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc05", ParseUnknown, _05_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc06", ParseUnknown, _06_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc07", ParseUnknown, _07_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc0A", ParseUnknown, _0A_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc0C", ParseUnknown, _0C_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc0D", ParseUnknown, _0D_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc0E", ParseUnknown, _0E_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc14", ParseUnknown, _14_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br>{ "?Opc1C", ParseUnknown, _1C_OP, NO_FUNC, ALPHA_UNKNOWN, INVALID_ETYPE}, <br> <br> <br>// <br>//         This is what hasn't been done yet - <br>//  the EV4 stuff - there are no names for it <br>//  in the alphaops.h header file.  Should we <br>//  put them there?  Should they be elsewhere? <br>//  Do we want to assemble them? <br>// <br>// For the moment, just pretend they are invalid.  They never <br>// come up for all practical purposes, anyway. <br>// <br> <br> <br>{ "MFPR", ParseUnknown, MFPR_OP, NO_FUNC, <br>                                      ALPHA_EV4_PR, INVALID_ETYPE }, <br>{ "MTPR", ParseUnknown, MTPR_OP, NO_FUNC, <br>                                      ALPHA_EV4_PR, INVALID_ETYPE }, <br> <br> <br> <br>      // <br>      // Secondly, the NON_TERMINAL_ETYPE section <br>      // <br> <br> <br> <br>{  (char *)NOFNCTBL, NOSIZE, CALLPAL_OP, NO_FUNC, <br>                                   ALPHA_CALLPAL, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, ARITH_OP, NO_FUNC, <br>                                   ALPHA_OPERATE, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, BIT_OP, NO_FUNC, <br>                                   ALPHA_OPERATE, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, BYTE_OP, NO_FUNC, <br>                                   ALPHA_OPERATE, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, MUL_OP, NO_FUNC, <br>                                   ALPHA_OPERATE, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, MEMSPC_OP, NO_FUNC, <br>                                   ALPHA_MEMSPC,  NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, JMP_OP, NO_FUNC, <br>                                   ALPHA_JUMP,    NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, VAXFP_OP, NO_FUNC, <br>                                   ALPHA_FP_OPERATE, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, IEEEFP_OP, NO_FUNC, <br>                                   ALPHA_FP_OPERATE, NON_TERMINAL_ETYPE }, <br>{  (char *)NOFNCTBL, NOSIZE, FPOP_OP,    NO_FUNC, <br>                                   ALPHA_FP_OPERATE, NON_TERMINAL_ETYPE }, <br> <br> <br> <br>      // <br>      // Thirdly, the TERMINAL_ETYPE section <br>      // (everything from here on has an instruction name) <br>      // <br> <br> <br> <br>{ szLda,   ParseIntMemory, LDA_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szLdah,  ParseIntMemory, LDAH_OP, NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szLdl,   ParseIntMemory, LDL_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szLdq,   ParseIntMemory, LDQ_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szLdf,   ParseFltMemory, LDF_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szLdg,   ParseFltMemory, LDG_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szLds,   ParseFltMemory, LDS_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szLdt,   ParseFltMemory, LDT_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szLdq_u, ParseIntMemory, LDQ_U_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szLdl_l, ParseIntMemory, LDL_L_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szLdq_l, ParseIntMemory, LDQ_L_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br> <br>{ szStl,   ParseIntMemory, STL_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szStq,   ParseIntMemory, STQ_OP,  NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szStf,   ParseFltMemory, STF_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szStg,   ParseFltMemory, STG_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szSts,   ParseFltMemory, STS_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szStt,   ParseFltMemory, STT_OP,  NO_FUNC, ALPHA_FP_MEMORY, TERMINAL_ETYPE }, <br>{ szStq_u, ParseIntMemory, STQ_U_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szStl_c, ParseIntMemory, STL_C_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br>{ szStq_c, ParseIntMemory, STQ_C_OP,NO_FUNC, ALPHA_MEMORY, TERMINAL_ETYPE }, <br> <br>{ szBeq,   ParseIntBranch, BEQ_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBne,   ParseIntBranch, BNE_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBlt,   ParseIntBranch, BLT_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBle,   ParseIntBranch, BLE_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBgt,   ParseIntBranch, BGT_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBge,   ParseIntBranch, BGE_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBlbc,  ParseIntBranch, BLBC_OP, NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBlbs,  ParseIntBranch, BLBS_OP, NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBr,    ParseIntBranch, BR_OP,   NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br>{ szBsr,   ParseIntBranch, BSR_OP,  NO_FUNC, ALPHA_BRANCH, TERMINAL_ETYPE }, <br> <br>{ szFbeq,  ParseFltBranch, FBEQ_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE }, <br>{ szFbne,  ParseFltBranch, FBNE_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE }, <br>{ szFblt,  ParseFltBranch, FBLT_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE }, <br>{ szFble,  ParseFltBranch, FBLE_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE }, <br>{ szFbgt,  ParseFltBranch, FBGT_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE }, <br>{ szFbge,  ParseFltBranch, FBGE_OP, NO_FUNC, ALPHA_FP_BRANCH, TERMINAL_ETYPE }, <br> <br> <br>{ "REI",   ParseUnknown, PAL1B_OP, NO_FUNC, ALPHA_EV4_REI, TERMINAL_ETYPE}, <br>{ "HW_LD", ParseUnknown, PAL1E_OP, NO_FUNC, ALPHA_EV4_MEM, TERMINAL_ETYPE}, <br>{ "HW_ST", ParseUnknown, PAL1F_OP, NO_FUNC, ALPHA_EV4_MEM, TERMINAL_ETYPE}, <br> <br> <br>      // <br>      // Fourthly, (and finally) the FUNCTION_ETYPE section <br>      // (opcode searches needn't include this section) <br>      // <br> <br>           // <br>           // The memory-special functions <br>           // <br> <br>{ szMb,   ParseMemSpec, MEMSPC_OP, MB_FUNC,    ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szWmb,  ParseMemSpec, MEMSPC_OP, WMB_FUNC,   ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szMb2,  ParseMemSpec, MEMSPC_OP, MB2_FUNC,   ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szMb3,  ParseMemSpec, MEMSPC_OP, MB3_FUNC,   ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szFetch,ParseMemSpec, MEMSPC_OP, FETCH_FUNC, ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szFetch_m,ParseMemSpec,MEMSPC_OP,FETCH_M_FUNC,ALPHA_MEMSPC,FUNCTION_ETYPE }, <br>{ szRs,   ParseMemSpec, MEMSPC_OP, RS_FUNC,    ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szTrapb,ParseMemSpec, MEMSPC_OP, TRAPB_FUNC, ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szExcb, ParseMemSpec, MEMSPC_OP, EXCB_FUNC,  ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szRpcc, ParseMemSpec, MEMSPC_OP, RPCC_FUNC,  ALPHA_MEMSPC, FUNCTION_ETYPE }, <br>{ szRc,   ParseMemSpec, MEMSPC_OP, RC_FUNC,    ALPHA_MEMSPC, FUNCTION_ETYPE }, <br> <br>           // <br>           // The jump functions <br>           // <br> <br>{ szJmp,  ParseJump,  JMP_OP, JMP_FUNC, ALPHA_JUMP, FUNCTION_ETYPE }, <br>{ szJsr,  ParseJump,  JMP_OP, JSR_FUNC, ALPHA_JUMP, FUNCTION_ETYPE }, <br>{ szRet,  ParseJump,  JMP_OP, RET_FUNC, ALPHA_JUMP, FUNCTION_ETYPE }, <br>{ szJsr_co,  ParseJump,  JMP_OP, JSR_CO_FUNC, ALPHA_JUMP, FUNCTION_ETYPE }, <br> <br>           // <br>           // The arithmetic ops, which are ALPHA_OPERATE <br>           // <br> <br>{ szAddl,   ParseIntOp, ARITH_OP, ADDL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szAddlv,  ParseIntOp, ARITH_OP, ADDLV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szAddq,   ParseIntOp, ARITH_OP, ADDQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szAddqv,  ParseIntOp, ARITH_OP, ADDQV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szSubl,   ParseIntOp, ARITH_OP, SUBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szSublv,  ParseIntOp, ARITH_OP, SUBLV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szSubq,   ParseIntOp, ARITH_OP, SUBQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szSubqv,  ParseIntOp, ARITH_OP, SUBQV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br> <br>{ szCmpeq,  ParseIntOp, ARITH_OP, CMPEQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmplt,  ParseIntOp, ARITH_OP, CMPLT_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmple,  ParseIntOp, ARITH_OP, CMPLE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpult, ParseIntOp, ARITH_OP, CMPULT_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpule, ParseIntOp, ARITH_OP, CMPULE_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpbge, ParseIntOp, ARITH_OP, CMPBGE_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br> <br>{ szS4addl, ParseIntOp, ARITH_OP, S4ADDL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS4addq, ParseIntOp, ARITH_OP, S4ADDQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS4subl, ParseIntOp, ARITH_OP, S4SUBL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS4subq, ParseIntOp, ARITH_OP, S4SUBQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS8addl, ParseIntOp, ARITH_OP, S8ADDL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS8addq, ParseIntOp, ARITH_OP, S8ADDQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS8subl, ParseIntOp, ARITH_OP, S8SUBL_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szS8subq, ParseIntOp, ARITH_OP, S8SUBQ_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br>           // <br>           // The bit ops, which are ALPHA_OPERATE <br>           // <br> <br>{ szAnd,   ParseIntOp, BIT_OP, AND_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szBic,   ParseIntOp, BIT_OP, BIC_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szBis,   ParseIntOp, BIT_OP, BIS_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szOrnot, ParseIntOp, BIT_OP, ORNOT_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szXor,   ParseIntOp, BIT_OP, XOR_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szEqv,   ParseIntOp, BIT_OP, EQV_FUNC,   ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br>{ szCmoveq,  ParseIntOp, BIT_OP, CMOVEQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovne,  ParseIntOp, BIT_OP, CMOVNE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovlbs, ParseIntOp, BIT_OP, CMOVLBS_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovlt,  ParseIntOp, BIT_OP, CMOVLT_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovge,  ParseIntOp, BIT_OP, CMOVGE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovlbc, ParseIntOp, BIT_OP, CMOVLBC_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovle,  ParseIntOp, BIT_OP, CMOVLE_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szCmovgt,  ParseIntOp, BIT_OP, CMOVGT_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br>           // <br>           // The byte ops, which are ALPHA_OPERATE <br>           // <br> <br>{ szSll,    ParseIntOp, BYTE_OP, SLL_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szSra,    ParseIntOp, BYTE_OP, SRA_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szSrl,    ParseIntOp, BYTE_OP, SRL_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtbl,  ParseIntOp, BYTE_OP, EXTBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtwl,  ParseIntOp, BYTE_OP, EXTWL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtll,  ParseIntOp, BYTE_OP, EXTLL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtql,  ParseIntOp, BYTE_OP, EXTQL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtwh,  ParseIntOp, BYTE_OP, EXTWH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtlh,  ParseIntOp, BYTE_OP, EXTLH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szExtqh,  ParseIntOp, BYTE_OP, EXTQH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInsbl,  ParseIntOp, BYTE_OP, INSBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInswl,  ParseIntOp, BYTE_OP, INSWL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInsll,  ParseIntOp, BYTE_OP, INSLL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInsql,  ParseIntOp, BYTE_OP, INSQL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInswh,  ParseIntOp, BYTE_OP, INSWH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInslh,  ParseIntOp, BYTE_OP, INSLH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szInsqh,  ParseIntOp, BYTE_OP, INSQH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMskbl,  ParseIntOp, BYTE_OP, MSKBL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMskwl,  ParseIntOp, BYTE_OP, MSKWL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMskll,  ParseIntOp, BYTE_OP, MSKLL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMskql,  ParseIntOp, BYTE_OP, MSKQL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMskwh,  ParseIntOp, BYTE_OP, MSKWH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMsklh,  ParseIntOp, BYTE_OP, MSKLH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMskqh,  ParseIntOp, BYTE_OP, MSKQH_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szZap,    ParseIntOp, BYTE_OP, ZAP_FUNC,    ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szZapnot, ParseIntOp, BYTE_OP, ZAPNOT_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br>           // <br>           // The multiply ops, which are ALPHA_OPERATE <br>           // <br> <br>{ szMull,   ParseIntOp,  MUL_OP, MULL_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMulqv,  ParseIntOp,  MUL_OP, MULQV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMullv,  ParseIntOp,  MUL_OP, MULLV_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szUmulh,  ParseIntOp,  MUL_OP, UMULH_FUNC, ALPHA_OPERATE, FUNCTION_ETYPE }, <br>{ szMulq,   ParseIntOp,  MUL_OP, MULQ_FUNC,  ALPHA_OPERATE, FUNCTION_ETYPE }, <br> <br>           // <br>           // The call pal functions <br>           // <br> <br> <br>{ szBpt,       ParsePal, CALLPAL_OP,  BPT_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szCallsys,   ParsePal, CALLPAL_OP, CALLSYS_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szImb,       ParsePal, CALLPAL_OP, IMB_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdteb,     ParsePal, CALLPAL_OP, RDTEB_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szGentrap,   ParsePal, CALLPAL_OP, GENTRAP_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szKbpt,      ParsePal, CALLPAL_OP, KBPT_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szCallKD,    ParsePal, CALLPAL_OP, CALLKD_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szHalt, ParsePal, CALLPAL_OP, HALT_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRestart, ParsePal, CALLPAL_OP, RESTART_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szDraina, ParsePal, CALLPAL_OP, DRAINA_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szInitpal, ParsePal, CALLPAL_OP, INITPAL_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szWrentry, ParsePal, CALLPAL_OP, WRENTRY_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szSwpirql, ParsePal, CALLPAL_OP, SWPIRQL_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdirql, ParsePal, CALLPAL_OP, RDIRQL_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szDi, ParsePal, CALLPAL_OP, DI_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szEi, ParsePal, CALLPAL_OP, EI_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szSwppal, ParsePal, CALLPAL_OP, SWPPAL_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szSsir, ParsePal, CALLPAL_OP, SSIR_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szCsir, ParsePal, CALLPAL_OP, CSIR_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRfe, ParsePal, CALLPAL_OP, RFE_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRetsys, ParsePal, CALLPAL_OP, RETSYS_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szSwpctx, ParsePal, CALLPAL_OP, SWPCTX_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szSwpprocess, ParsePal, CALLPAL_OP, SWPPROCESS_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdmces, ParsePal, CALLPAL_OP, RDMCES_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szWrmces, ParsePal, CALLPAL_OP, WRMCES_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szTbia, ParsePal, CALLPAL_OP, TBIA_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szTbis, ParsePal, CALLPAL_OP, TBIS_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szDtbis, ParsePal, CALLPAL_OP, DTBIS_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdksp, ParsePal, CALLPAL_OP, RDKSP_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szSwpksp, ParsePal, CALLPAL_OP, SWPKSP_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdpsr, ParsePal, CALLPAL_OP, RDPSR_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdpcr, ParsePal, CALLPAL_OP, RDPCR_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdthread, ParsePal, CALLPAL_OP, RDTHREAD_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdcounters, ParsePal, CALLPAL_OP, RDCOUNTERS_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRdstate, ParsePal, CALLPAL_OP, RDSTATE_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szInitpcr, ParsePal, CALLPAL_OP, INITPCR_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szWrperfmon, ParsePal, CALLPAL_OP, WRPERFMON_FUNC, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szMt, ParsePal, CALLPAL_OP, MTPR_OP, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szMf, ParsePal, CALLPAL_OP, MFPR_OP, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szHwld, ParsePal, CALLPAL_OP, HWLD_OP, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szHwst, ParsePal, CALLPAL_OP, HWST_OP, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br>{ szRei, ParsePal, CALLPAL_OP, REI_OP, <br>                                  ALPHA_CALLPAL, FUNCTION_ETYPE }, <br> <br> <br>           // <br>           // The VAX Floating point functions <br>           // <br> <br> <br>{ szAddf,   ParseUnknown, VAXFP_OP, ADDF_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtdg,  ParseUnknown, VAXFP_OP, CVTDG_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szAddg,   ParseUnknown, VAXFP_OP, ADDG_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpgeq, ParseUnknown, VAXFP_OP, CMPGEQ_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpglt, ParseUnknown, VAXFP_OP, CMPGLT_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpgle, ParseUnknown, VAXFP_OP, CMPGLE_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtgf,  ParseUnknown, VAXFP_OP, CVTGF_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtgd,  ParseUnknown, VAXFP_OP, CVTGD_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtqf,  ParseUnknown, VAXFP_OP, CVTQF_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtqg,  ParseUnknown, VAXFP_OP, CVTQG_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szDivf,   ParseUnknown, VAXFP_OP, DIVF_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szDivg,   ParseUnknown, VAXFP_OP, DIVG_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szMulf,   ParseUnknown, VAXFP_OP, MULF_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szMulg,   ParseUnknown, VAXFP_OP, MULG_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szSubf,   ParseUnknown, VAXFP_OP, SUBF_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szSubg,   ParseUnknown, VAXFP_OP, SUBG_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtgq,  ParseUnknown, VAXFP_OP, CVTGQ_FUNC, <br>                                    ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>           // <br>           // The IEEE Floating point functions <br>           // <br> <br>{ szAdds,   ParseUnknown, IEEEFP_OP, ADDS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szSubs,   ParseUnknown, IEEEFP_OP, SUBS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szMuls,   ParseUnknown, IEEEFP_OP, MULS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szDivs,   ParseUnknown, IEEEFP_OP, DIVS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szAddt,   ParseUnknown, IEEEFP_OP, ADDT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szSubt,   ParseUnknown, IEEEFP_OP, SUBT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szMult,   ParseUnknown, IEEEFP_OP, MULT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szDivt,   ParseUnknown, IEEEFP_OP, DIVT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmptun, ParseUnknown, IEEEFP_OP, CMPTUN_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmpteq, ParseUnknown, IEEEFP_OP, CMPTEQ_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmptlt, ParseUnknown, IEEEFP_OP, CMPTLT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCmptle, ParseUnknown, IEEEFP_OP, CMPTLE_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtts,  ParseUnknown, IEEEFP_OP, CVTTS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvttq,  ParseUnknown, IEEEFP_OP, CVTTQ_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtqs,  ParseUnknown, IEEEFP_OP, CVTQS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtqt,  ParseUnknown, IEEEFP_OP, CVTQT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtst,  ParseUnknown, IEEEFP_OP, CVTST_FUNC, <br>                                     ALPHA_FP_CONVERT, FUNCTION_ETYPE }, <br>{ szCvtsts, ParseUnknown, IEEEFP_OP, CVTST_S_FUNC, <br>                                     ALPHA_FP_CONVERT, FUNCTION_ETYPE }, <br> <br> <br>           // <br>           // The Common Floating point functions <br>           // <br> <br> <br>{ szCvtlq,    ParseUnknown,  FPOP_OP, CVTLQ_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCpys,     ParseUnknown,  FPOP_OP, CPYS_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCpysn,    ParseUnknown,  FPOP_OP, CPYSN_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCpyse,    ParseUnknown,  FPOP_OP, CPYSE_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szMt_fpcr,  ParseUnknown,  FPOP_OP, MT_FPCR_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szMf_fpcr,  ParseUnknown,  FPOP_OP, MF_FPCR_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szFcmoveq,  ParseUnknown,  FPOP_OP, FCMOVEQ_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szFcmovne,  ParseUnknown,  FPOP_OP, FCMOVNE_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szFcmovlt,  ParseUnknown,  FPOP_OP, FCMOVLT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szFcmovge,  ParseUnknown,  FPOP_OP, FCMOVGE_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szFcmovle,  ParseUnknown,  FPOP_OP, FCMOVLE_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szFcmovgt,  ParseUnknown,  FPOP_OP, FCMOVGT_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtql,    ParseUnknown,  FPOP_OP, CVTQL_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtqlv,   ParseUnknown,  FPOP_OP, CVTQLV_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br>{ szCvtqlsv,  ParseUnknown,  FPOP_OP, CVTQLSV_FUNC, <br>                                     ALPHA_FP_OPERATE, FUNCTION_ETYPE }, <br> <br>};       // end of opTable <br> <br> <br>#define SEARCHNUM  sizeof(opTable) / sizeof(OPTBLENTRY) <br> <br> <br> <br>// <br>// Here are the tables of Floating Point flags. <br>// <br> <br>FPFLAGS ConvertFlags[] = { <br>    { NONE_FLAGS, NONE_FLAGS_STR }, <br>    { C_FLAGS, C_FLAGS_STR }, <br>    { V_FLAGS, V_FLAGS_STR }, <br>    { VC_FLAGS, VC_FLAGS_STR }, <br>    { SV_FLAGS, SV_FLAGS_STR }, <br>    { SVC_FLAGS, SVC_FLAGS_STR }, <br>    { SVI_FLAGS, SVI_FLAGS_STR }, <br>    { SVIC_FLAGS, SVIC_FLAGS_STR }, <br> <br>    { D_FLAGS, D_FLAGS_STR }, <br>    { VD_FLAGS, VD_FLAGS_STR }, <br>    { SVD_FLAGS, SVD_FLAGS_STR }, <br>    { SVID_FLAGS, SVID_FLAGS_STR }, <br>    { M_FLAGS, M_FLAGS_STR }, <br>    { VM_FLAGS, VM_FLAGS_STR }, <br>    { SVM_FLAGS, SVM_FLAGS_STR }, <br>    { SVIM_FLAGS, SVIM_FLAGS_STR }, <br> <br>    { S_FLAGS, S_FLAGS_STR }, <br>    { SC_FLAGS, SC_FLAGS_STR }, <br>    { FPFLAGS_NOT_AN_ENTRY, "" } <br>}; <br> <br>FPFLAGS FloatOpFlags[] = { <br>    { C_FLAGS, C_FLAGS_STR }, <br>    { M_FLAGS, M_FLAGS_STR }, <br>    { NONE_FLAGS, NONE_FLAGS_STR }, <br>    { D_FLAGS, D_FLAGS_STR }, <br>    { UC_FLAGS, UC_FLAGS_STR }, <br>    { UM_FLAGS, UM_FLAGS_STR }, <br>    { U_FLAGS, U_FLAGS_STR }, <br>    { UD_FLAGS, UD_FLAGS_STR }, <br>    { SC_FLAGS, SC_FLAGS_STR }, <br>    { S_FLAGS, S_FLAGS_STR }, <br>    { SUC_FLAGS, SUC_FLAGS_STR }, <br>    { SUM_FLAGS, SUM_FLAGS_STR }, <br>    { SU_FLAGS, SU_FLAGS_STR }, <br>    { SUD_FLAGS, SUD_FLAGS_STR }, <br>    { SUIC_FLAGS, SUIC_FLAGS_STR }, <br>    { SUIM_FLAGS, SUIM_FLAGS_STR }, <br>    { SUI_FLAGS, SUI_FLAGS_STR }, <br>    { SUID_FLAGS, SUID_FLAGS_STR }, <br>    { FPFLAGS_NOT_AN_ENTRY, "" } <br>}; <br> <br> <br>  <br>/*** findNameEntry - find POPTBLENTRY based on name <br>* <br>*   Purpose: <br>*       Search the opTable for a match with the token <br>*       pointed by *pszOp.  Must search through the <br>*       TERMINAL and the FUNCTION tables <br>* <br>*   Input: <br>*       *pszOp - string to search as mnemonic <br>* <br>*   Returns: <br>*       Pointer to entry in the opTable <br>* <br>*************************************************************************/ <br> <br>POPTBLENTRY <br>findStringEntry (PUCHAR pszOp) <br>{ <br> <br>    POPTBLENTRY pEntry; <br> <br>    for (pEntry = TerminalTab; <br>         pEntry &lt; &amp;TerminalTab[TerminalTabSize]; <br>         pEntry++) { <br> <br>        if (!strcmp(pszOp, pEntry-&gt;pszAlphaName)) <br>                return(pEntry); <br>    } <br> <br>    for (pEntry = FunctionTab; <br>         pEntry &lt; &amp;FunctionTab[FunctionTabSize]; <br>         pEntry++) { <br> <br>        if (!strcmp(pszOp, pEntry-&gt;pszAlphaName)) <br>                return(pEntry); </code></pre>
<p>
</p>
<pre><code>} <br> <br>    return((POPTBLENTRY)-1); <br>} <br> <br>  <br>/* findOpCodeEntry - find POPTBLENTRY based on opcode <br>* <br>*   Purpose: <br>*       Search the opTable for a match with the opcode <br>*       Must search through the <br>*       INVALID, TERMINAL and NON_TERMINAL tables <br>* <br>*   Input: <br>*       pOpEntry - pointer to NON_TERMINAL_ETYPE in opTable <br>*       function - the function value to be looked up <br>* <br>*   Output: <br>*       pointer to string mnemonic for the function <br>* <br>***********************************************************************/ <br> <br>POPTBLENTRY <br>findOpCodeEntry(ULONG opcode) <br>{ <br>    POPTBLENTRY pEntry; <br> <br>    for (pEntry = TerminalTab; <br>         pEntry &lt; &amp;TerminalTab[TerminalTabSize]; <br>         pEntry++) { <br> <br>        if (pEntry-&gt;opCode == opcode) <br>                return(pEntry); <br>    } <br> <br>    for (pEntry = NonTerminalTab; <br>         pEntry &lt; &amp;NonTerminalTab[NonTerminalTabSize]; <br>         pEntry++) { <br> <br>        if (pEntry-&gt;opCode == opcode) <br>                return(pEntry); <br>    } <br> <br>    for (pEntry = InvalidTab; <br>         pEntry &lt; &amp;InvalidTab[InvalidTabSize]; <br>         pEntry++) { <br> <br>        if (pEntry-&gt;opCode == opcode) <br>                return(pEntry); <br>    } <br> <br>    return((POPTBLENTRY)-1); <br>} <br> <br>  <br>/*** findTypeFromOpcode - find the instruction type <br>* <br>*   Purpose: <br>*       This routine finds the type of the instruction (ALPHA_*) <br>*       from the opcode.  It returns a single value so that it <br>*       can be called from other dll's without passing storage. <br>* <br>*   Input: <br>*       the opcode number. <br>* <br>*   Output: <br>*       the type of the opcode (ALPHA_* in alphaops.h) <br>* <br>*   Errors: <br>*       returns ALPHA_UNKNOWN for an invalid opcode <br>* <br>*   Exceptions: <br>*       None. <br>* <br>* <br>*************************************************************************/ <br> <br>ULONG <br>findTypeFromOpcode(ULONG opcode) <br>{ <br>    POPTBLENTRY pEntry; <br> <br>    pEntry = findOpCodeEntry(opcode); <br> <br>    if (pEntry != (POPTBLENTRY)(-1)) { <br>        return(pEntry-&gt;iType); <br>    } else { <br>        return(ALPHA_UNKNOWN); <br>    } <br>} <br> <br>  <br>/*** findNonTerminalEntry - find pointer to set of functions <br>* <br>*   Purpose: <br>*       This routine finds the entry in the table which the is <br>*       nonterminal entry for an opcode. <br>* <br>*   Input: <br>*       The type of function that is interesting <br>* <br>*   Output: <br>*       Pointer to the nonterminal entry in opTable <br>* <br>*   Errors: <br>*       If the entry is not found, a message is printed, and the <br>*       routine exits. <br>* <br>*   Exceptions: <br>*       None. <br>* <br>*   Note: <br>*       This routine is called BEFORE NonTerminalTable is established! <br>*       (it's used to set up these tables, in fact). <br>* <br>*************************************************************************/ <br> <br>POPTBLENTRY <br>findNonTerminalEntry(ULONG opCode) <br>{ <br>    ULONG index; <br> <br>    for ( index = 0 ; index &lt; SEARCHNUM; index++ ) { <br> <br>        if ( ( opTable[index].eType == NON_TERMINAL_ETYPE ) &amp;&amp; <br>             ( opTable[index].opCode == opCode ) ) { <br> <br>                 return(&amp;opTable[index]); <br>        } <br>    } <br> <br>} <br> <br> <br>  <br>/* findFuncName - get string name for a function <br>* <br>*   Purpose: <br>*       to get function name, given the function number, and a <br>*       pointer to the opTable entry for the NON_TERMINAL_ETYPE <br>*       opcode associated with the function <br>* <br>*   Input: <br>*       pOpEntry - pointer to NON_TERMINAL_ETYPE in opTable <br>*       function - the function value to be looked up <br>* <br>*   Output: <br>*       pointer to string mnemonic for the function <br>* <br>***********************************************************************/ <br> <br>char * <br>findFuncName(POPTBLENTRY pEntry, ULONG function) <br>{ <br>    int cIndex; <br>    POPTBLENTRY pFncEntry; <br> <br>    pFncEntry = pEntry-&gt;funcTable; <br>    cIndex = (int)pEntry-&gt;funcTableSize; <br> <br>    // <br>    // make sure that this entry pts to a function table <br>    // <br> <br>    if (pEntry-&gt;eType != NON_TERMINAL_ETYPE) { <br>        return("???"); <br>    } <br> <br>    while(cIndex-- &gt; 0) { <br>        if (function == pFncEntry-&gt;funcCode) <br>            return(pFncEntry-&gt;pszAlphaName); <br>        pFncEntry++; <br>    }; <br> <br>    return("???"); <br>} <br> <br>  <br>/** findFlagName - get the string associated with a flag <br>* <br>*    Purpose - return a string associated with the flags for a <br>*              floating point instruction <br>* <br>*    Input: <br>*      flag    - the flags on the opcode <br>*      opcode  - the opcode; if it's Cvt*, we use different flags <br>* <br>*    Output: <br>*      pointer to string describing flags, or "/???" <br>* <br>***************/ <br> <br>char * <br>findFlagName(ULONG flag, ULONG function) <br>{ <br> <br>     PFPFLAGS table; <br> <br>     if (function == CVTQL_FUNC) { <br>         switch (flag) { <br>         case C_FLAGS: <br>              return ""; <br>         case VC_FLAGS: <br>              return "/v"; <br>         case SVC_FLAGS: <br>              return "/sv"; <br>         } <br>     } <br> <br>     if ((function == CVTTQ_FUNC) || (function == CVTGQ_FUNC)) { <br>         table = ConvertFlags; <br>     } else { <br>         table = FloatOpFlags; <br>     } <br> <br>     while (table-&gt;flags != FPFLAGS_NOT_AN_ENTRY) { <br> <br>         if (table-&gt;flags == flag) { <br>              return(table-&gt;flagname); <br>         } <br>         table++; <br>    } <br> <br>    // no match found <br>    // <br> <br>    return("/???"); <br>} <br> <br>  <br>/*** opTableInit - initialize fields used in and with the opTable <br>* <br>*   Purpose: <br>*       This routine is called once, and sets up pointers to the <br>*       subtables embedded in the opTable, such as AddOpTab, and <br>*       sizes for these subtables.  It also checks that all like <br>*       instructions are grouped together in the table, which is <br>*       the only requirement on it. <br>* <br>*   Input: <br>*       None. <br>* <br>*   Output: <br>*       None. <br>* <br>*   Errors: <br>*       If the table is not properly organized (four types separated, <br>*       and the functions for a single opcode grouped), this prints a <br>*       messages and fails <br>* <br>*   Exceptions: <br>*       None. <br>* <br>*************************************************************************/ <br> <br>void <br>opTableInit() <br>{ <br> <br>    ULONG typesDone[4] = {0,0,0,0}; <br> <br>    ULONG palDone, arithDone, bitDone, byteDone, jmpDone; <br>    ULONG fpopDone, vaxDone, IEEEDone, mulDone, memSpcDone; <br> <br>    ULONG        index; <br> <br>    POPTBLENTRY  entry; <br> <br>    ENTRY_TYPE   curType = NOT_AN_ETYPE; <br>    ULONG        curFunc = NO_FUNC;    // OPCODE field in func entry <br> <br>    // <br>    // To set the end of the table, and its size, without having <br>    // nested case statements, maintain pointers to the entry and <br>    // function tables we are currently walking through <br>    // <br> <br>    PULONG        curTypeSize,       curFuncSize; <br>    POPTBLENTRY * curTypeTable,    * curFuncTable; <br> <br> <br>    // <br>    // these will be reset before they are needed, but not before <br>    // they are used. <br>    // <br> <br>    curTypeTable = (POPTBLENTRY *)&amp;curTypeTable; <br>    curTypeSize  = (PULONG)&amp;curTypeSize; <br>    curFuncTable = (POPTBLENTRY *)&amp;curFuncTable; <br>    curFuncSize  = (PULONG)&amp;curFuncSize; <br> <br>    palDone = arithDone = bitDone = byteDone = jmpDone = 0; <br>    fpopDone = vaxDone = IEEEDone = mulDone = memSpcDone = 0; <br> <br>    for (index = 0 ; index &lt; SEARCHNUM; index++) { <br> <br>        entry = &amp;opTable[index]; <br> <br>        switch(entry-&gt;eType) { <br> <br>         case INVALID_ETYPE: <br> <br>             if (curType == entry-&gt;eType) <br>                 continue; <br> <br>             // <br>             // Finish off the old tables <br>             // <br> <br>             *curTypeSize = entry - *curTypeTable; <br>             if (curType == FUNCTION_ETYPE) { <br>                 *curFuncSize = entry - *curFuncTable; <br>             } <br> <br>             // <br>             // Set up the new table <br>             // <br> <br>             InvalidTab = entry; <br>             curTypeSize = &amp;InvalidTabSize; <br>             curTypeTable = &amp;InvalidTab; <br>             curType = INVALID_ETYPE; <br>             typesDone[INVALID_ETYPE] = 1; <br>             break; <br> <br>         case NON_TERMINAL_ETYPE: <br> <br>             if (curType == entry-&gt;eType) <br>                 continue; <br> <br>             *curTypeSize = entry - *curTypeTable; <br>             if (curType == FUNCTION_ETYPE) { <br>                 *curFuncSize = entry - *curFuncTable; <br>             } <br> <br>             NonTerminalTab = entry; <br>             curTypeSize = &amp;NonTerminalTabSize; <br>             curTypeTable = &amp;NonTerminalTab; <br>             curType = NON_TERMINAL_ETYPE; <br>             typesDone[NON_TERMINAL_ETYPE] = 1; <br>             break; <br> <br>         case TERMINAL_ETYPE: <br> <br>             if (curType == entry-&gt;eType) <br>                 continue; <br> <br>             *curTypeSize = entry - *curTypeTable; <br>             if (curType == FUNCTION_ETYPE) { <br>                 *curFuncSize = entry - *curFuncTable; <br>             } <br> <br>             TerminalTab = entry; <br>             curTypeSize = &amp;TerminalTabSize; <br>             curTypeTable = &amp;TerminalTab; <br>             curType = TERMINAL_ETYPE; <br>             typesDone[TERMINAL_ETYPE] = 1; <br>             break; <br> <br> <br>         case FUNCTION_ETYPE: <br> <br>             if (entry-&gt;opCode == curFunc) <br>                      continue; <br> <br>             // <br>             // Take care of a new eType table; this exactly <br>             // parallels the three cases above (*_ETYPE) <br>             // <br> <br>             if (curType != FUNCTION_ETYPE) { <br> <br>                 *curTypeSize = entry - *curTypeTable; <br> <br>                 FunctionTab = entry; <br>                 curTypeSize = &amp;FunctionTabSize; <br>                 curTypeTable = &amp;FunctionTab; <br>                 curType = FUNCTION_ETYPE; <br>                 typesDone[FUNCTION_ETYPE] = 1; <br> <br>             } <br> <br>             // <br>             // Next, handle a new function table when this is a new <br>             // function (==&gt; when this is the first entry in the <br>             // FunctionTab) <br>             // <br> <br> <br>             switch(entry-&gt;opCode) { <br> <br>             POPTBLENTRY e; <br> <br>             case CALLPAL_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(CALLPAL_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = CALLPAL_OP; <br>                 palDone = 1; <br> <br>                 break; <br> <br>             case ARITH_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(ARITH_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = ARITH_OP; <br>                 arithDone = 1; <br> <br>                 break; <br> <br>             case BIT_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(BIT_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = BIT_OP; <br>                 bitDone = 1; <br> <br>                 break; <br> <br>             case BYTE_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(BYTE_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = BYTE_OP; <br>                 byteDone = 1; <br> <br>                 break; <br> <br>             case MUL_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(MUL_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = MUL_OP; <br>                 mulDone = 1; <br> <br>                 break; <br> <br>             case MEMSPC_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(MEMSPC_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = MEMSPC_OP; <br>                 memSpcDone = 1; <br> <br>                 break; <br> <br>             case JMP_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(JMP_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = JMP_OP; <br>                 jmpDone = 1; <br> <br>                 break; <br> <br>             case VAXFP_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(VAXFP_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = VAXFP_OP; <br>                 vaxDone = 1; <br> <br>                 break; <br> <br>             case IEEEFP_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(IEEEFP_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = IEEEFP_OP; <br>                 IEEEDone = 1; <br> <br>                 break; <br> <br>             case FPOP_OP: <br> <br>                 *curFuncSize = entry - *curFuncTable; <br> <br>                 e = findNonTerminalEntry(FPOP_OP); <br>                 e-&gt;funcTable = entry; <br>                 curFuncSize = &amp;(e-&gt;funcTableSize); <br>                 curFuncTable = &amp;(e-&gt;funcTable); <br> <br>                 curFunc = FPOP_OP; <br>                 fpopDone = 1; <br> <br>                 break; <br> <br>             default: <br>                 break; <br> <br>            }  // end of Function table switch <br> <br>            break; <br> <br>        default: <br>            break; <br> <br>        }      // end of etype table switch <br>    }          // end of For switch <br> <br>    // <br>    // close out the size of the last tables <br>    // <br> <br>    if (curType == FUNCTION_ETYPE) { <br>        *curFuncSize = &amp;opTable[SEARCHNUM] - *curFuncTable; <br>    } <br>    *curTypeSize = &amp;opTable[SEARCHNUM] - *curTypeTable; <br> <br>#if 0 <br>    if (fVerboseOutput) { <br>        printTable(); <br>    } <br>#endif <br> <br>}              // end of opTableInit <br> <br>void <br>printTable() <br>{ <br>   ULONG i; <br>   POPTBLENTRY e; <br> <br>   for (i = 0 ; i &lt; SEARCHNUM; i++) { <br>       e = &amp;opTable[i]; <br>       switch (e-&gt;eType) { <br>       case INVALID_ETYPE: <br>           break; <br> <br>       case TERMINAL_ETYPE: <br>           break; <br> <br>       case FUNCTION_ETYPE: <br>           break; <br> <br>       case NON_TERMINAL_ETYPE: <br>           break; <br>       } <br>   } <br>} <br> <br> <br>// <br>// These routines are part of the assembler, which is not <br>// yet referenced in windbg, so these are place holders till then <br>// <br> <br> <br>ULONG ParseIntMemory (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseFltMemory (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseMemSpec   (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseJump      (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseIntBranch (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseFltBranch (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseIntOp     (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParsePal       (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} <br>ULONG ParseUnknown   (PUCHAR a, PUCHAR * b, POPTBLENTRY c, PULONG d) <br>{ <br>   return(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
