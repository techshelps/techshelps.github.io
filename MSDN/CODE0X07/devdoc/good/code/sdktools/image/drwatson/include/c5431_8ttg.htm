<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVINFO.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5434"></a>CVINFO.H</h2>
<pre><code>/***    cvinfo.h - Generic CodeView information definitions <br> * <br> *      Structures, constants, etc. for accessing and interpreting <br> *      CodeView information. <br> * <br> */ <br> <br> <br>/***    The master copy of this file resides in the CodeView project. <br> *      All Microsoft projects are required to use the master copy without <br> *      modification.  Modification of the master version or a copy <br> *      without consultation with all parties concerned is extremely <br> *      risky. <br> * <br> *      The projects known to use this version (4.00.00) are: <br> * <br> *          Codeview <br> *          Sequoia <br> *          C7.00 (all passes) <br> *          Cvpack <br> *          Cvdump <br> */ <br> <br>#ifndef _CV_INFO_INCLUDED <br>#define _CV_INFO_INCLUDED <br> <br>#pragma pack(1) <br>typedef unsigned long   CV_uoff32_t; <br>typedef          long   CV_off32_t; <br>typedef unsigned short  CV_uoff16_t; <br>typedef          short  CV_off16_t; <br>typedef unsigned short  CV_typ_t; <br> <br> <br> <br>#ifdef _REAL10 <br>typedef struct { <br>    char b[10]; <br>} REAL10; <br>#endif <br> <br>#define CV_SIGNATURE_C6         0L /* Actual signature is &gt;64K */ <br>#define CV_SIGNATURE_C7         1L /* First explicit signature */ <br>#define CV_SIGNATURE_RESERVED   2L /* All signatures from 2 to 64K are reserved */ <br> <br>#define CV_MAXOFFSET   0xffffffff <br> <br>/**     CodeView Symbol and Type OMF type information is broken up into two <br> *      ranges.  Type indices less than 0x1000 describe frequently used <br> *      type information that is frequently used.  Type indices above <br> *      0x1000 are used to describe more complex features such as function, <br> *      arrays and structures. <br> */ <br> <br> <br> <br> <br>/**     Primitive types have predefined meaning that is encoded in the <br> *      values of the various bit fields in the value. <br> * <br> *      A CodeView primitive type is defined as: <br> * <br> *      1 1 <br> *      1 089  7654  3  210 <br> *      r mode type  r  sub <br> * <br> *      Where <br> *          mode is the pointer mode <br> *          type is a type indicator <br> *          sub  is a subtype enumeration <br> *          r    is a reserved field <br> * <br> *      See Microsoft Symbol and Type OMF (Version 4.0) for more <br> *      information. <br> */ <br> <br> <br>#define CV_MMASK        0x700   /* mode mask */ <br>#define CV_TMASK        0x0f0   /* type mask */ <br>#define CV_SMASK        0x007   /* subtype mask */ <br> <br>#define CV_MSHIFT       8       /* primitive mode right shift count */ <br>#define CV_TSHIFT       4       /* primitive type right shift count */ <br>#define CV_SSHIFT       0       /* primitive subtype right shift count */ <br> <br>/* <br> *      macros to extract primitive mode, type and size <br> */ <br> <br>#define CV_MODE(typ)    (((typ) &amp; CV_MMASK) &gt;&gt; CV_MSHIFT) <br>#define CV_TYPE(typ)    (((typ) &amp; CV_TMASK) &gt;&gt; CV_TSHIFT) <br>#define CV_SUBT(typ)    (((typ) &amp; CV_SMASK) &gt;&gt; CV_SSHIFT) <br> <br>/* <br> *      macros to insert new primitive mode, type and size <br> */ <br> <br>#define CV_NEWMODE(typ, nm)     (((typ) &amp; ~CV_MMASK) | ((nm) &lt;&lt; CV_MSHIFT)) <br>#define CV_NEWTYPE(typ, nt)     (((typ) &amp; ~CV_TMASK) | ((nt) &lt;&lt; CV_TSHIFT)) <br>#define CV_NEWSUBT(typ, ns)     (((typ) &amp; ~CV_SMASK) | ((ns) &lt;&lt; CV_SSHIFT)) <br> <br>/* <br> *      pointer mode enumeration values <br> */ <br> <br>typedef enum CV_prmode_e { <br>    CV_TM_DIRECT = 0,           /* mode is not a pointer */ <br>    CV_TM_NPTR   = 1,           /* mode is a near pointer */ <br>    CV_TM_FPTR   = 2,           /* mode is a far pointer */ <br>    CV_TM_HPTR   = 3,           /* mode is a huge pointer */ <br>    CV_TM_NPTR32 = 4,           /* mode is a 32 bit near pointer */ <br>    CV_TM_FPTR32 = 5,           /* mode is a 32 bit far pointer */ <br>    CV_TM_NPTR64 = 6            /* mode is a 64 bit near pointer */ <br>} CV_prmode_e; <br> <br>/* <br> *      type enumeration values <br> */ <br> <br>typedef enum CV_type_e { <br>    CV_SPECIAL      = 0x00,     /* special type size values */ <br>    CV_SIGNED       = 0x01,     /* signed integral size values */ <br>    CV_UNSIGNED     = 0x02,     /* unsigned integral size values */ <br>    CV_BOOLEAN      = 0x03,     /* Boolean size values */ <br>    CV_REAL         = 0x04,     /* real number size values */ <br>    CV_COMPLEX      = 0x05,     /* complex number size values */ <br>    CV_SPECIAL2     = 0x06,     /* second set of special types */ <br>    CV_INT          = 0x07,     /* integral (int) values */ <br>    CV_CVRESERVED   = 0x0f <br>} CV_type_e; <br> <br>/* <br> *      subtype enumeration values for CV_SPECIAL <br> */ <br> <br>typedef enum CV_special_e { <br>    CV_SP_NOTYPE    = 0x00, <br>    CV_SP_ABS       = 0x01, <br>    CV_SP_SEGMENT   = 0x02, <br>    CV_SP_VOID      = 0x03, <br>    CV_SP_CURRENCY  = 0x04, <br>    CV_SP_NBASICSTR = 0x05, <br>    CV_SP_FBASICSTR = 0x06, <br>    CV_SP_NOTTRANS  = 0x07 <br>} CV_special_e; <br> <br>/* <br> *      subtype enumeration values for CV_SPECIAL2 <br> */ <br> <br> <br>typedef enum CV_special2_e { <br>    CV_S2_BIT       = 0x00, <br>    CV_S2_PASCHAR   = 0x01      /* Pascal CHAR */ <br>} CV_special2_e; <br> <br>/* <br> *      subtype enumeration values for CV_SIGNED, CV_UNSIGNED and CV_BOOLEAN <br> */ <br> <br>typedef enum CV_integral_e { <br>    CV_IN_1BYTE     = 0x00, <br>    CV_IN_2BYTE     = 0x01, <br>    CV_IN_4BYTE     = 0x02, <br>    CV_IN_8BYTE     = 0x03 <br>} CV_integral_e; <br> <br>/* <br> *      subtype enumeration values for CV_REAL and CV_COMPLEX <br> */ <br> <br>typedef enum CV_real_e { <br>    CV_RC_REAL32    = 0x00, <br>    CV_RC_REAL64    = 0x01, <br>    CV_RC_REAL80    = 0x02, <br>    CV_RC_REAL128   = 0x03, <br>    CV_RC_REAL48    = 0x04 <br>} CV_real_e; <br> <br>/* <br> *      subtype enumeration values for CV_INT (really int) <br> */ <br> <br>typedef enum CV_int_e { <br>    CV_RI_CHAR      = 0x00, <br>    CV_RI_WCHAR     = 0x01, <br>    CV_RI_INT2      = 0x02, <br>    CV_RI_UINT2     = 0x03, <br>    CV_RI_INT4      = 0x04, <br>    CV_RI_UINT4     = 0x05, <br>    CV_RI_INT8      = 0x06, <br>    CV_RI_UINT8     = 0x07 <br>} CV_int_e; <br> <br>/* <br> *      macros to check the type of a primitive <br> */ <br> <br>#define CV_TYP_IS_DIRECT(typ)   (CV_MODE(typ) == CV_TM_DIRECT) <br>#define CV_TYP_IS_PTR(typ)      (CV_MODE(typ) != CV_TM_DIRECT) <br>#define CV_TYP_IS_NPTR(typ)     (CV_MODE(typ) == CV_TM_NPTR) <br>#define CV_TYP_IS_FPTR(typ)     (CV_MODE(typ) == CV_TM_FPTR) <br>#define CV_TYP_IS_HPTR(typ)     (CV_MODE(typ) == CV_TM_HPTR) <br>#define CV_TYP_IS_NPTR32(typ)   (CV_MODE(typ) == CV_TM_NPTR32) <br>#define CV_TYP_IS_FPTR32(typ)   (CV_MODE(typ) == CV_TM_FPTR32) <br> <br>#define CV_TYP_IS_SIGNED(typ)(((CV_TYPE(typ) == CV_SIGNED)  &amp;&amp; \ <br>                                        CV_TYP_IS_DIRECT(typ)) || \ <br>                                        (typ == T_INT2)        || \ <br>                                        (typ == T_INT4)        || \ <br>                                        (typ == T_INT8)        || \ <br>                                        (typ == T_RCHAR)) <br> <br>#define CV_TYP_IS_UNSIGNED(typ) (((CV_TYPE(typ) == CV_UNSIGNED) &amp;&amp; \ <br>                                         CV_TYP_IS_DIRECT(typ)) || \ <br>                                         (typ == T_UINT2)       || \ <br>                                         (typ == T_UINT4)       || \ <br>                                         (typ == T_UINT8)       || \ <br>                                         (typ == T_RCHAR)) <br> <br>#define CV_TYP_IS_REAL(typ)     ((CV_TYPE(typ) == CV_REAL)  &amp;&amp; CV_TYP_IS_DIRECT(typ)) <br> <br>#define CV_FIRST_NONPRIM 0x1000 <br>#define CV_IS_PRIMITIVE(typ)       ((typ) &lt; CV_FIRST_NONPRIM) <br> <br> <br> <br>/* <br> *      selected values for type_index - for a more complete definition, see <br> *      Microsoft Symbol and Type OMF document <br> */ <br> <br>/* <br> *      Special Types <br> */ <br> <br>#define T_NOTYPE        0x0000  /* uncharacterized type (no type) */ <br>#define T_ABS           0x0001  /* absolute symbol */ <br>#define T_SEGMENT       0x0002  /* segment type */ <br>#define T_VOID          0x0003  /* void */ <br>#define T_PVOID         0x0103  /* near pointer to void */ <br>#define T_PFVOID        0x0203  /* far pointer to void */ <br>#define T_PHVOID        0x0303  /* huge pointer to void */ <br>#define T_32PVOID       0x0403  /* 16:32 near pointer to void */ <br>#define T_32PFVOID      0x0503  /* 16:32 far pointer to void */ <br>#define T_CURRENCY      0x0004  /* BASIC 8 byte currency value */ <br>#define T_NBASICSTR     0x0005  /* Near BASIC string */ <br>#define T_FBASICSTR     0x0006  /* Far BASIC string */ <br>#define T_NOTTRANS      0x0007  /* type not translated by cvpack */ <br>#define T_BIT           0x0060  /* bit */ <br>#define T_PASCHAR       0x0061  /* Pascal CHAR */ <br> <br>/* <br> *      Character types <br> */ <br> <br>#define T_CHAR          0x0010  /* 8 bit signed */ <br>#define T_UCHAR         0x0020  /* 8 bit unsigned */ <br>#define T_PCHAR         0x0110  /* near pointer to 8 bit signed */ <br>#define T_PUCHAR        0x0120  /* near pointer to 8 bit unsigned */ <br>#define T_PFCHAR        0x0210  /* far pointer to 8 bit signed */ <br>#define T_PFUCHAR       0x0220  /* far pointer to 8 bit unsigned */ <br>#define T_PHCHAR        0x0310  /* huge pointer to 8 bit signed */ <br>#define T_PHUCHAR       0x0320  /* huge pointer to 8 bit unsigned */ <br>#define T_32PCHAR       0x0410  /* 16:32 near pointer to 8 bit signed */ <br>#define T_32PUCHAR      0x0420  /* 16:32 near pointer to 8 bit unsigned */ <br>#define T_32PFCHAR      0x0510  /* 16:32 far pointer to 8 bit signed */ <br>#define T_32PFUCHAR     0x0520  /* 16:32 far pointer to 8 bit unsigned */ <br> <br>/* <br> *      really a character types <br> */ <br> <br>#define T_RCHAR         0x0070  /* really a char */ <br>#define T_PRCHAR        0x0170  /* 16:16 near pointer to a real char */ <br>#define T_PFRCHAR       0x0270  /* 16:16 far pointer to a real char */ <br>#define T_PHRCHAR       0x0370  /* 16:16 huge pointer to a real char */ <br>#define T_32PRCHAR      0x0470  /* 16:32 near pointer to a real char */ <br>#define T_32PFRCHAR     0x0570  /* 16:32 far pointer to a real char */ <br> <br>/* <br> *      really a wide character types (UNICODE) <br> */ <br> <br>#define T_WCHAR         0x0071  /* wide char */ <br>#define T_PWCHAR        0x0171  /* 16:16 near pointer to a wide char */ <br>#define T_PFWCHAR       0x0271  /* 16:16 far pointer to a wide char */ <br>#define T_PHWCHAR       0x0371  /* 16:16 huge pointer to a wide char */ <br>#define T_32PWCHAR      0x0471  /* 16:32 near pointer to a wide char */ <br>#define T_32PFWCHAR     0x0571  /* 16:32 far pointer to a wide char */ <br> <br>/* <br> *      16 bit short types <br> */ <br> <br>#define T_SHORT         0x0011  /* 16 bit signed */ <br>#define T_USHORT        0x0021  /* 16 bit unsigned */ <br>#define T_PSHORT        0x0111  /* near pointer to 16 bit signed */ <br>#define T_PUSHORT       0x0121  /* near pointer to 16 bit unsigned */ <br>#define T_PFSHORT       0x0211  /* far pointer to 16 bit signed */ <br>#define T_PFUSHORT      0x0221  /* far pointer to 16 bit unsigned */ <br>#define T_PHSHORT       0x0311  /* huge pointer to 16 bit signed */ <br>#define T_PHUSHORT      0x0321  /* huge pointer to 16 bit unsigned */ <br> <br>#define T_32PSHORT      0x0411  /* 16:32 near pointer to 16 bit signed */ <br>#define T_32PUSHORT     0x0421  /* 16:32 near pointer to 16 bit unsigned */ <br>#define T_32PFSHORT     0x0511  /* 16:32 far pointer to 16 bit signed */ <br>#define T_32PFUSHORT    0x0521  /* 16:32 far pointer to 16 bit unsigned */ <br> <br>/* <br> *      16 bit int types <br> */ <br> <br>#define T_INT2          0x0072  /* 16 bit signed int */ <br>#define T_UINT2         0x0073  /* 16 bit unsigned int */ <br>#define T_PINT2         0x0172  /* near pointer to 16 bit signed int */ <br>#define T_PUINT2        0x0173  /* near pointer to 16 bit unsigned int */ <br>#define T_PFINT2        0x0272  /* far pointer to 16 bit signed int */ <br>#define T_PFUINT2       0x0273  /* far pointer to 16 bit unsigned int */ <br>#define T_PHINT2        0x0372  /* huge pointer to 16 bit signed int */ <br>#define T_PHUINT2       0x0373  /* huge pointer to 16 bit unsigned int */ <br> <br>#define T_32PINT2       0x0472  /* 16:32 near pointer to 16 bit signed int */ <br>#define T_32PUINT2      0x0473  /* 16:32 near pointer to 16 bit unsigned int */ <br>#define T_32PFINT2      0x0572  /* 16:32 far pointer to 16 bit signed int */ <br>#define T_32PFUINT2     0x0573  /* 16:32 far pointer to 16 bit unsigned int */ <br> <br>/* <br> *      32 bit long types <br> */ <br> <br>#define T_LONG          0x0012  /* 32 bit signed */ <br>#define T_ULONG         0x0022  /* 32 bit unsigned */ <br>#define T_PLONG         0x0112  /* near pointer to 32 bit signed */ <br>#define T_PLONG         0x0112  /* near pointer to 32 bit signed */ <br>#define T_PULONG        0x0122  /* near pointer to 32 bit unsigned */ <br>#define T_PFLONG        0x0212  /* far pointer to 32 bit signed */ <br>#define T_PFULONG       0x0222  /* far pointer to 32 bit unsigned */ <br>#define T_PHLONG        0x0312  /* huge pointer to 32 bit signed */ <br>#define T_PHULONG       0x0322  /* huge pointer to 32 bit unsigned */ <br> <br>#define T_32PLONG       0x0412  /* 16:32 near pointer to 32 bit signed */ <br>#define T_32PULONG      0x0422  /* 16:32 near pointer to 32 bit unsigned */ <br>#define T_32PFLONG      0x0512  /* 16:32 far pointer to 32 bit signed */ <br>#define T_32PFULONG     0x0522  /* 16:32 far pointer to 32 bit unsigned */ <br> <br>/* <br> *      32 bit int types <br> */ <br> <br>#define T_INT4          0x0074  /* 32 bit signed int */ <br>#define T_UINT4         0x0075  /* 32 bit unsigned int */ <br>#define T_PINT4         0x0174  /* near pointer to 32 bit signed int */ <br>#define T_PUINT4        0x0175  /* near pointer to 32 bit unsigned int */ <br>#define T_PFINT4        0x0274  /* far pointer to 32 bit signed int */ <br>#define T_PFUINT4       0x0275  /* far pointer to 32 bit unsigned int */ <br>#define T_PHINT4        0x0374  /* huge pointer to 32 bit signed int */ <br>#define T_PHUINT4       0x0375  /* huge pointer to 32 bit unsigned int */ <br> <br>#define T_32PINT4       0x0474  /* 16:32 near pointer to 32 bit signed int */ <br>#define T_32PUINT4      0x0475  /* 16:32 near pointer to 32 bit unsigned int */ <br>#define T_32PFINT4      0x0574  /* 16:32 far pointer to 32 bit signed int */ <br>#define T_32PFUINT4     0x0575  /* 16:32 far pointer to 32 bit unsigned int */ <br> <br>/* <br> *      64 bit quad types <br> */ <br> <br> <br>#define T_QUAD          0x0013  /* 64 bit signed */ <br>#define T_UQUAD         0x0023  /* 64 bit unsigned */ <br>#define T_PQUAD         0x0113  /* near pointer to 64 bit signed */ <br>#define T_PUQUAD        0x0123  /* near pointer to 64 bit unsigned */ <br>#define T_PFQUAD        0x0213  /* far pointer to 64 bit signed */ <br>#define T_PFUQUAD       0x0223  /* far pointer to 64 bit unsigned */ <br>#define T_PHQUAD        0x0313  /* huge pointer to 64 bit signed */ <br>#define T_PHUQUAD       0x0323  /* huge pointer to 64 bit unsigned */ <br> <br>/* <br> *      64 bit int types <br> */ <br> <br>#define T_INT8          0x0076  /* 64 bit signed int */ <br>#define T_UINT8         0x0077  /* 64 bit unsigned int */ <br>#define T_PINT8         0x0176  /* near pointer to 64 bit signed int */ <br>#define T_PUINT8        0x0177  /* near pointer to 64 bit unsigned int */ <br>#define T_PFINT8        0x0276  /* far pointer to 64 bit signed int */ <br>#define T_PFUINT8       0x0277  /* far pointer to 64 bit unsigned int */ <br>#define T_PHINT8        0x0376  /* huge pointer to 64 bit signed int */ <br>#define T_PHUINT8       0x0377  /* huge pointer to 64 bit unsigned int */ <br> <br>#define T_32PINT8       0x0476  /* 16:32 near pointer to 64 bit signed int */ <br>#define T_32PUINT8      0x0477  /* 16:32 near pointer to 64 bit unsigned int */ <br>#define T_32PFINT8      0x0576  /* 16:32 far pointer to 64 bit signed int */ <br>#define T_32PFUINT8     0x0577  /* 16:32 far pointer to 64 bit unsigned int */ <br> <br>/* <br> *      32 bit real types <br> */ <br> <br>#define T_REAL32        0x0040  /* 32 bit real */ <br>#define T_PREAL32       0x0140  /* near pointer to 32 bit real */ <br>#define T_PFREAL32      0x0240  /* far pointer to 32 bit real */ <br>#define T_PHREAL32      0x0340  /* huge pointer to 32 bit real */ <br>#define T_32PREAL32     0x0440  /* 16:32 near pointer to 32 bit real */ <br>#define T_32PFREAL32    0x0540  /* 16:32 far pointer to 32 bit real */ <br> <br>/* <br> *      48 bit real types <br> */ <br> <br>#define T_REAL48        0x0044  /* 48 bit real */ <br>#define T_PREAL48       0x0144  /* near pointer to 48 bit real */ <br>#define T_PFREAL48      0x0244  /* far pointer to 48 bit real */ <br>#define T_PHREAL48      0x0344  /* huge pointer to 48 bit real */ <br>#define T_32PREAL48     0x0444  /* 16:32 near pointer to 48 bit real */ <br>#define T_32PFREAL48    0x0544  /* 16:32 far pointer to 48 bit real */ <br> <br>/* <br> *      64 bit real types <br> */ <br> <br>#define T_REAL64        0x0041  /* 64 bit real */ <br>#define T_PREAL64       0x0141  /* near pointer to 64 bit real */ <br>#define T_PFREAL64      0x0241  /* far pointer to 64 bit real */ <br>#define T_PHREAL64      0x0341  /* huge pointer to 64 bit real */ <br>#define T_32PREAL64     0x0441  /* 16:32 near pointer to 64 bit real */ <br>#define T_32PFREAL64    0x0541  /* 16:32 far pointer to 64 bit real */ <br> <br>/* <br> *      80 bit real types <br> */ <br> <br>#define T_REAL80        0x0042  /* 80 bit real */ <br>#define T_PREAL80       0x0142  /* near pointer to 80 bit real */ <br>#define T_PFREAL80      0x0242  /* far pointer to 80 bit real */ <br>#define T_PHREAL80      0x0342  /* huge pointer to 80 bit real */ <br>#define T_32PREAL80     0x0442  /* 16:32 near pointer to 80 bit real */ <br>#define T_32PFREAL80    0x0542  /* 16:32 far pointer to 80 bit real */ <br> <br>/* <br> *      128 bit real types <br> */ <br> <br>#define T_REAL128       0x0043  /* 128 bit real */ <br>#define T_PREAL128      0x0143  /* near pointer to 128 bit real */ <br>#define T_PFREAL128     0x0243  /* far pointer to 128 bit real */ <br>#define T_PHREAL128     0x0343  /* huge pointer to 128 bit real */ <br>#define T_32PREAL128    0x0443  /* 16:32 near pointer to 128 bit real */ <br>#define T_32PFREAL128   0x0543  /* 16:32 far pointer to 128 bit real */ <br> <br>/* <br> *      32 bit complex types <br> */ <br> <br>#define T_CPLX32        0x0050  /* 32 bit complex */ <br>#define T_PCPLX32       0x0150  /* near pointer to 32 bit complex */ <br>#define T_PFCPLX32      0x0250  /* far pointer to 32 bit complex */ <br>#define T_PHCPLX32      0x0350  /* huge pointer to 32 bit complex */ <br>#define T_32PCPLX32     0x0450  /* 16:32 near pointer to 32 bit complex */ <br>#define T_32PFCPLX32    0x0550  /* 16:32 far pointer to 32 bit complex */ <br> <br>/* <br> *      48 bit complex types <br> */ <br> <br>#define T_CPLX48        0x0054  /* 48 bit complex */ <br>#define T_PCPLX48       0x0154  /* near pointer to 48 bit complex */ <br>#define T_PFCPLX48      0x0254  /* far pointer to 48 bit complex */ <br>#define T_PHCPLX48      0x0354  /* huge pointer to 48 bit complex */ <br>#define T_32PCPLX48     0x0454  /* 16:32 near pointer to 48 bit complex */ <br>#define T_32PFCPLX48    0x0554  /* 16:32 far pointer to 48 bit complex */ <br> <br>/* <br> *      64 bit complex types <br> */ <br> <br>#define T_CPLX64        0x0051  /* 64 bit complex */ <br>#define T_PCPLX64       0x0151  /* near pointer to 64 bit complex */ <br>#define T_PFCPLX64      0x0251  /* far pointer to 64 bit complex */ <br>#define T_PHCPLX64      0x0351  /* huge pointer to 64 bit complex */ <br>#define T_32PCPLX64     0x0451  /* 16:32 near pointer to 64 bit complex */ <br>#define T_32PFCPLX64    0x0551  /* 16:32 far pointer to 64 bit complex */ <br> <br>/* <br> *      80 bit complex types <br> */ <br> <br>#define T_CPLX80        0x0052  /* 80 bit complex */ <br>#define T_PCPLX80       0x0152  /* near pointer to 80 bit complex */ <br>#define T_PFCPLX80      0x0252  /* far pointer to 80 bit complex */ <br>#define T_PHCPLX80      0x0352  /* huge pointer to 80 bit complex */ <br>#define T_32PCPLX80     0x0452  /* 16:32 near pointer to 80 bit complex */ <br>#define T_32PFCPLX80    0x0552  /* 16:32 far pointer to 80 bit complex */ <br> <br>/* <br> *      128 bit complex types <br> */ <br> <br>#define T_CPLX128       0x0053  /* 128 bit complex */ <br>#define T_PCPLX128      0x0153  /* near pointer to 128 bit complex */ <br>#define T_PFCPLX128     0x0253  /* far pointer to 128 bit complex */ <br>#define T_PHCPLX128     0x0353  /* huge pointer to 128 bit real */ <br>#define T_32PCPLX128    0x0453  /* 16:32 near pointer to 128 bit complex */ <br>#define T_32PFCPLX128   0x0553  /* 16:32 far pointer to 128 bit complex */ <br> <br>/* <br> *      boolean types <br> */ <br> <br>#define T_BOOL08        0x0030  /* 8 bit boolean */ <br>#define T_BOOL16        0x0031  /* 16 bit boolean */ <br>#define T_BOOL32        0x0032  /* 32 bit boolean */ <br>#define T_PBOOL08       0x0130  /* near pointer to  8 bit boolean */ <br>#define T_PBOOL16       0x0131  /* near pointer to 16 bit boolean */ <br>#define T_PBOOL32       0x0132  /* near pointer to 32 bit boolean */ <br>#define T_PFBOOL08      0x0230  /* far pointer to  8 bit boolean */ <br>#define T_PFBOOL16      0x0231  /* far pointer to 16 bit boolean */ <br>#define T_PFBOOL32      0x0232  /* far pointer to 32 bit boolean */ <br>#define T_PHBOOL08      0x0330  /* huge pointer to  8 bit boolean */ <br>#define T_PHBOOL16      0x0331  /* huge pointer to 16 bit boolean */ <br>#define T_PHBOOL32      0x0332  /* huge pointer to 32 bit boolean */ <br> <br>#define T_32PBOOL08     0x0430  /* 16:32 near pointer to 8 bit boolean */ <br>#define T_32PFBOOL08    0x0530  /* 16:32 far pointer to 8 bit boolean */ <br>#define T_32PBOOL16     0x0431  /* 16:32 near pointer to 18 bit boolean */ <br>#define T_32PFBOOL16    0x0531  /* 16:32 far pointer to 16 bit boolean */ <br>#define T_32PBOOL32     0x0432  /* 16:32 near pointer to 32 bit boolean */ <br>#define T_32PFBOOL32    0x0532  /* 16:32 far pointer to 32 bit boolean */ <br> <br> <br>#define T_NCVPTR        0x01f0  /* CV Internal type for created near pointers */ <br>#define T_FCVPTR        0x02f0  /* CV Internal type for created far pointers */ <br>#define T_HCVPTR        0x03f0  /* CV Internal type for created huge pointers */ <br> <br>/**     No leaf index can have a value of 0x0000.  The leaf indices are <br> *      separated into ranges depending upon the use of the type record. <br> *      The second range is for the type records that are directly referenced <br> *      in symbols. The first range is for type records that are not <br> *      referenced by symbols but instead are referenced by other type <br> *      records.  All type records must have a starting leaf index in these <br> *      first two ranges.  The third range of leaf indices are used to build <br> *      up complex lists such as the field list of a class type record.  No <br> *      type record can begin with one of the leaf indices. The fourth ranges <br> *      of type indices are used to represent numeric data in a symbol or <br> *      type record. These leaf indices are greater than 0x8000.  At the <br> *      point that type or symbol processor is expecting a numeric field, the <br> *      next two bytes in the type record are examined.  If the value is less <br> *      than 0x8000, then the two bytes contain the numeric value.  If the <br> *      value is greater than 0x8000, then the data follows the leaf index in <br> *      a format specified by the leaf index. The final range of leaf indices <br> *      are used to force alignment of subfields within a complex type record.. <br> */ <br> <br>/* <br> *      leaf indices starting records but referenced from symbol records <br> */ <br> <br>#define LF_MODIFIER     0x0001 <br>#define LF_POINTER      0x0002 <br>#define LF_ARRAY        0x0003 <br>#define LF_CLASS        0x0004 <br>#define LF_STRUCTURE    0x0005 <br>#define LF_UNION        0x0006 <br>#define LF_ENUM         0x0007 <br>#define LF_PROCEDURE    0x0008 <br>#define LF_MFUNCTION    0x0009 <br>#define LF_VTSHAPE      0x000a <br>#define LF_COBOL0       0x000b <br>#define LF_COBOL1       0x000c <br>#define LF_BARRAY       0x000d <br>#define LF_LABEL        0x000e <br>#define LF_NULL         0x000f <br>#define LF_NOTTRAN      0x0010 <br>#define LF_DIMARRAY     0x0011 <br>#define LF_VFTPATH      0x0012 <br>#define LF_PRECOMP      0x0013  /* not refereced from symbol */ <br>#define LF_ENDPRECOMP   0x0014  /* not refereced from symbol */ <br>#define LF_OEM          0x0015 <br>#define LF_TYPESERVER   0x0016 <br> <br>/* <br> * leaf indices starting records but referenced only from type records <br> */ <br> <br>#define LF_SKIP         0x0200 <br>#define LF_ARGLIST      0x0201 <br>#define LF_DEFARG       0x0202 <br>#define LF_LIST         0x0203 <br>#define LF_FIELDLIST    0x0204 <br>#define LF_DERIVED      0x0205 <br>#define LF_BITFIELD     0x0206 <br>#define LF_METHODLIST   0x0207 <br>#define LF_DIMCONU      0x0208 <br>#define LF_DIMCONLU     0x0209 <br>#define LF_DIMVARU      0x020a <br>#define LF_DIMVARLU     0x020b <br>#define LF_REFSYM       0x020c <br> <br>#define LF_BCLASS       0x0400 <br>#define LF_VBCLASS      0x0401 <br>#define LF_IVBCLASS     0x0402 <br>#define LF_ENUMERATE    0x0403 <br>#define LF_FRIENDFCN    0x0404 <br>#define LF_INDEX        0x0405 <br>#define LF_MEMBER       0x0406 <br>#define LF_STMEMBER     0x0407 <br>#define LF_METHOD       0x0408 <br>#define LF_NESTTYPE     0x0409 <br>#define LF_VFUNCTAB     0x040a <br>#define LF_FRIENDCLS    0x040b <br> <br>#define LF_NUMERIC      0x8000 <br>#define LF_CHAR         0x8000 <br>#define LF_SHORT        0x8001 <br>#define LF_USHORT       0x8002 <br>#define LF_LONG         0x8003 <br>#define LF_ULONG        0x8004 <br>#define LF_REAL32       0x8005 <br>#define LF_REAL64       0x8006 <br>#define LF_REAL80       0x8007 <br>#define LF_REAL128      0x8008 <br>#define LF_QUADWORD     0x8009 <br>#define LF_UQUADWORD    0x800a <br>#define LF_REAL48       0x800b <br> <br>#define LF_PAD0         0xf0 <br>#define LF_PAD1         0xf1 <br>#define LF_PAD2         0xf2 <br>#define LF_PAD3         0xf3 <br>#define LF_PAD4         0xf4 <br>#define LF_PAD5         0xf5 <br>#define LF_PAD6         0xf6 <br>#define LF_PAD7         0xf7 <br>#define LF_PAD8         0xf8 <br>#define LF_PAD9         0xf9 <br>#define LF_PAD10        0xfa <br>#define LF_PAD11        0xfb <br>#define LF_PAD12        0xfc <br>#define LF_PAD13        0xfd <br>#define LF_PAD14        0xfe <br>#define LF_PAD15        0xff <br> <br>/* <br> * end of leaf indices <br> */ <br> <br>/* <br> *      Type enum for pointer records <br> *      Pointers can be one of the following types <br> */ <br> <br>typedef enum CV_ptrtype_e { <br>    CV_PTR_NEAR         = 0x00, /* near pointer */ <br>    CV_PTR_FAR          = 0x01, /* far pointer */ <br>    CV_PTR_HUGE         = 0x02, /* huge pointer */ <br>    CV_PTR_BASE_SEG     = 0x03, /* based on segment */ <br>    CV_PTR_BASE_VAL     = 0x04, /* based on value of base */ <br>    CV_PTR_BASE_SEGVAL  = 0x05, /* based on segment value of base */ <br>    CV_PTR_BASE_ADDR    = 0x06, /* based on address of base */ <br>    CV_PTR_BASE_SEGADDR = 0x07, /* based on segment address of base */ <br>    CV_PTR_BASE_TYPE    = 0x08, /* based on type */ <br>    CV_PTR_BASE_SELF    = 0x09, /* based on self */ <br>    CV_PTR_NEAR32       = 0x0a, /* 16:32 near pointer */ <br>    CV_PTR_FAR32        = 0x0b, /* 16:32 far pointer */ <br>    CV_PTR_UNUSEDPTR    = 0x0c  /* first unused pointer type */ <br>} CV_ptrtype_e; <br> <br>/* <br> *      Mode enum for pointers <br> *      Pointers can have one of the following modes <br> */ <br> <br>typedef enum CV_ptrmode_e { <br>    CV_PTR_MODE_PTR     = 0x00, /* "normal" pointer */ <br>    CV_PTR_MODE_REF     = 0x01, /* reference */ <br>    CV_PTR_MODE_PMEM    = 0x02, /* pointer to data member */ <br>    CV_PTR_MODE_PMFUNC  = 0x03, /* pointer to member function */ <br>    CV_PTR_MODE_RESERVED= 0x04  /* first unused pointer mode */ <br>} CV_ptrmode_e; <br> <br>/* <br> *      Enumeration for function call type <br> */ <br> <br>typedef enum CV_call_e { <br>    CV_CALL_NEAR_C      = 0x00, /* near right to left push, caller pops stack */ <br>    CV_CALL_FAR_C       = 0x01, /* far right to left push, caller pops stack */ <br>    CV_CALL_NEAR_PASCAL = 0x02, /* near left to right push, callee pops stack */ <br>    CV_CALL_FAR_PASCAL  = 0x03, /* far left to right push, callee pops stack */ <br>    CV_CALL_NEAR_FAST   = 0x04, /* near left to right push with regs, callee pops stack */ <br>    CV_CALL_FAR_FAST    = 0x05, /* far left to right push with regs, callee pops stack */ <br>    CV_CALL_PCODE       = 0x06, /* pcode */ <br>    CV_CALL_NEAR_STD    = 0x07, /* near standard call */ <br>    CV_CALL_FAR_STD     = 0x08, /* far standard call */ <br>    CV_CALL_NEAR_SYS    = 0x09, /* near sys call */ <br>    CV_CALL_FAR_SYS     = 0x0a, /* far sys call */ <br>    CV_CALL_THISCALL    = 0x0b, /* this call (this passed in register) */ <br>    CV_CALL_MIPSCALL    = 0x0c, /* Mips call */ <br>    CV_CALL_GENERIC     = 0x0d, // Generic call sequence <br>CV_CALL_ALPHACALL= 0x0e, // Alpha call <br>CV_CALL_RESERVED= 0x0f// first unused call enumeration <br> <br>} CV_call_e; <br> <br>/* <br> *      Values for the access protection of class attributes <br> */ <br> <br>typedef enum CV_access_e { <br>    CV_private   = 1, <br>    CV_protected = 2, <br>    CV_public    = 3 <br>} CV_access_e; <br> <br>/* <br> *      enumeration for method properties <br> */ <br> <br>typedef enum CV_methodprop_e { <br>    CV_MTvanilla        = 0x00, <br>    CV_MTvirtual        = 0x01, <br>    CV_MTstatic         = 0x02, <br>    CV_MTfriend         = 0x03, <br>    CV_MTintro          = 0x04, <br>    CV_MTpurevirt       = 0x05, <br>    CV_MTpureintro      = 0x06 <br>} CV_methodprop_e; <br> <br>/* <br> *      enumeration for virtual shape table entries <br> */ <br> <br>typedef enum CV_VTS_desc_e { <br>    CV_VTS_near         = 0x00, <br>    CV_VTS_far          = 0x01, <br>    CV_VTS_thin         = 0x02, <br>    CV_VTS_outer        = 0x03, <br>    CV_VTS_meta         = 0x04, <br>    CV_VTS_near32       = 0x05, <br>    CV_VTS_far32        = 0x06, <br>    CV_VTS_unused       = 0x07 <br>} CV_VTS_desc_e; <br> <br>/* <br> *      enumeration for LF_LABEL address modes <br> */ <br> <br>typedef enum CV_LABEL_TYPE_e { <br>    CV_LABEL_NEAR = 0,          /* near return */ <br>    CV_LABEL_FAR  = 4           /* far return */ <br>} CV_LABEL_TYPE_e; <br> <br>/* <br> *      enumeration for LF_MODIFIER values <br> */ <br> <br>typedef struct CV_modifier_t { <br>    unsigned short  MOD_const       :1; <br>    unsigned short  MOD_volatile    :1; <br>    unsigned short  MOD_unused      :14; <br>} CV_modifier_t; <br> <br>/* <br> *  bit field structure describing class/struct/union/enum properties <br> */ <br> <br>typedef struct CV_prop_t { <br>    unsigned short  packed      :1; /* structure is packed */ <br>    unsigned short  ctor        :1; /* constructors or destructors present */ <br>    unsigned short  ovlops      :1; /* overloaded operators present */ <br>    unsigned short  isnested    :1; /* this is a nested class */ <br>    unsigned short  cnested     :1; /* this class contains nested types */ <br>    unsigned short  opassign    :1; /* overloaded assignment (=) */ <br>    unsigned short  opcast      :1; /* casting methods */ <br>    unsigned short  fwdref      :1; /* forward reference (incomplete defn) */ </code></pre>
<p>
</p>
<pre><code>unsigned short  scoped      :1; /* scoped definition */ <br>    unsigned short  reserved    :7; <br>} CV_prop_t; <br> <br>/* <br> *  class field attribute <br> */ <br> <br>typedef struct CV_fldattr_t { <br>    unsigned short  access      :2; /* access protection CV_access_t */ <br>    unsigned short  mprop       :3; /* method properties CV_methodprop_t */ <br>    unsigned short  pseudo      :1; /* compiler generated fcn and does not exist */ <br>    unsigned short  noinherit   :1; /* true if class cannot be inherited */ <br>    unsigned short  noconstruct :1; /* true if class cannot be constructed */ <br>    unsigned short  unused      :8; /* unused */ <br>} CV_fldattr_t; <br> <br>/* <br> *  Structures to access to the type records <br> */ <br> <br>typedef struct TYPTYPE { <br>    unsigned short  len; <br>    unsigned short  leaf; <br>#ifdef CV <br>    unsigned char   data[]; <br>#else <br>    unsigned char   data[1]; <br>#endif <br>} TYPTYPE;                      /* general types record */ <br> <br>typedef enum CV_PMEMBER { <br>    CV_PDM16_NONVIRT    = 0x00, /* 16:16 data no virtual fcn or base (null = -1) */ <br>    CV_PDM16_VFCN       = 0x01, /* 16:16 data with virtual functions null = 0 */ <br>    CV_PDM16_VBASE      = 0x02, /* 16:16 data with virtual bases null = (,,-1) */ <br>    CV_PDM32_NVVFCN     = 0x03, /* 16:32 data w/wo virtual functions null = 0x80000000 */ <br>    CV_PDM32_VBASE      = 0x04, /* 16:32 data with virtual bases (,,-1L) */ <br> <br>    CV_PMF16_NEARNVSA   = 0x05, /* 16:16 near method nonvirtual single address point */ <br>    CV_PMF16_NEARNVMA   = 0x06, /* 16:16 near method nonvirtual multiple address points */ <br>    CV_PMF16_NEARVBASE  = 0x07, /* 16:16 near method virtual bases */ <br>    CV_PMF16_FARNVSA    = 0x08, /* 16:16 far method nonvirtual single address point */ <br>    CV_PMF16_FARNVMA    = 0x09, /* 16:16 far method nonvirtual multiple address points */ <br>    CV_PMF16_FARVBASE   = 0x0a, /* 16:16 far method virtual bases */ <br> <br>    CV_PMF32_NVSA       = 0x0b, /* 16:32 method nonvirtual single address point */ <br>    CV_PMF32_NVMA       = 0x0c, /* 16:32 method nonvirtual multiple address point */ <br>    CV_PMF32_VBASE      = 0x0d  /* 16:32 method virtual bases */ <br>} CV_PMEMBER; <br> <br> <br>/* <br> *  memory representation of pointer to member.  These representations are <br> *  indexed by the enumeration above in the LF_POINTER record <br> */ <br> <br>/*  representation of a 16:16 pointer to data for a class with no <br> *  virtual functions or virtual bases <br> */ <br> <br>struct CV_PDMR16_NONVIRT { <br>    CV_off16_t      mdisp;      /* displacement to data (NULL = -1) */ <br>}; <br> <br> <br>/* <br> *  representation of a 16:16 pointer to data for a class with virtual <br> *  functions <br> */ <br> <br>struct CV_PMDR16_VFCN { <br>    CV_off16_t      mdisp;      /* displacement to data ( NULL = 0) */ <br>}; <br> <br>/* <br> *  representation of a 16:16 pointer to data for a class with <br> *  virtual bases <br> */ <br> <br>struct CV_PDMR16_VBASE { <br>    CV_off16_t      mdisp;      /* displacement to data */ <br>    CV_off16_t      pdisp;      /* this pointer displacement to vbptr */ <br>    CV_off16_t      vdisp;      /* displacement within vbase table */ <br>}; <br> <br>/* <br> *  representation of a 16:32 near pointer to data for a class with <br> *  or without virtual functions and no virtual bases <br> */ <br> <br>struct CV_PDMR32_NVVFCN { <br>    CV_off32_t      mdisp;      /* displacement to data (NULL = 0x80000000) */ <br>}; <br> <br> <br>/* <br> *  representation of a 16:32 near pointer to data for a class <br> *  with virtual bases <br> */ <br> <br> <br>struct CV_PDMR32_VBASE { <br>    CV_off32_t      mdisp;      /* displacement to data */ <br>    CV_off32_t      pdisp;      /* this pointer displacement */ <br>    CV_off32_t      vdisp;      /* vbase table displacement */ <br>}; <br> <br>/* <br> *  representation of a 16:16 pointer to near member function for a <br> *  class with no virtual functions or bases and a single address point <br> */ <br> <br>struct CV_PMFR16_NEARNVSA { <br>    CV_uoff16_t     off;        /* near address of function (NULL = 0) */ <br>}; <br> <br> <br>/* <br> *  representation of a 16:16 pointer to far member function for a <br> *  class with no virtual bases and a single address point <br> */ <br> <br>struct CV_PMFR16_FARNVSA { <br>    CV_uoff16_t     off;        /* offset of function (NULL = 0:0) */ <br>    unsigned short  seg;        /* segment of function */ <br>}; <br> <br> <br> <br>/* <br> *  representation of a 16:16 near pointer to member functions of an <br> *  class with no virtual bases and multiple address points <br> */ <br> <br>struct CV_PMFR16_NEARNVMA { <br>    CV_uoff16_t     off;        /* offset of function (NULL = 0,x) */ <br>    signed short    disp; <br>}; <br> <br>/* <br> *  representation of a 16:16 far pointer to member functions of a <br> *  class with no virtual bases and multiple address points <br> */ <br> <br>struct CV_PMFR16_FARNVMA { <br>    CV_uoff16_t     off;        /* offset of function (NULL = 0:0,x) */ <br>    unsigned short  seg; <br>    signed short    disp; <br>}; <br> <br>/* <br> *  representation of a 16:16 near pointer to member function of a <br> *  class with virtual bases <br> */ <br> <br>struct CV_PMFR16_NEARVBASE { <br>    CV_uoff16_t     off;        /* offset of function (NULL = 0,x,x,x) */ <br>    CV_off16_t      mdisp;      /* displacement to data */ <br>    CV_off16_t      pdisp;      /* this pointer displacement */ <br>    CV_off16_t      vdisp;      /* vbase table displacement */ <br>}; <br> <br>/* <br> *  representation of a 16:16 far pointer to member function of a <br> *  class with virtual bases <br> */ <br> <br>struct CV_PMFR16_FARVBASE { <br>    CV_uoff16_t     off;        /* offset of function (NULL = 0:0,x,x,x) */ <br>    unsigned short  seg; <br>    CV_off16_t      mdisp;      /* displacement to data */ <br>    CV_off16_t      pdisp;      /* this pointer displacement */ <br>    CV_off16_t      vdisp;      /* vbase table displacement */ <br> <br>}; <br> <br>/* <br> *  representation of a 16:32 near pointer to member function for a <br> *  class with no virtual bases and a single address point <br> */ <br> <br>struct CV_PMFR32_NVSA { <br>    CV_uoff32_t      off;       /* near address of function (NULL = 0L) */ <br>}; <br> <br>/* <br> *  representation of a 16:32 near pointer to member function for a <br> *  class with no virtual bases and multiple address points <br> */ <br> <br>struct CV_PMFR32_NVMA { <br>    CV_uoff32_t     off;        /* near address of function (NULL = 0L,x) */ <br>    CV_off32_t      disp; <br>}; <br> <br>/* <br> *  representation of a 16:32 near pointer to member function for a <br> *  class with virtual bases <br> */ <br> <br>struct CV_PMFR32_VBASE { <br>    CV_uoff32_t     off;        /* near address of function (NULL = 0L,x,x,x) */ <br>    CV_off32_t      mdisp;      /* displacement to data */ <br>    CV_off32_t      pdisp;      /* this pointer displacement */ <br>    CV_off32_t      vdisp;      /* vbase table displacement */ <br>}; <br> <br>/* <br> *  Easy leaf - used for generic casting to reference leaf field <br> *  of a subfield of a complex list <br> */ <br> <br>typedef struct lfEasy { <br>    unsigned short  leaf;       /* LF_... */ <br>} lfEasy; <br> <br> <br>/*      The following type records are basically variant records of the <br> *      above structure.  The "unsigned short leaf" of the above structure and <br> *      the "unsigned short leaf" of the following type definitions are the <br> *      same symbol.  When the OMF record is locked via the MHOMFLock API <br> *      call, the address of the "unsigned short leaf" is returned <br> */ <br> <br>/* <br> *      Type record for LF_MODIFIER <br> */ <br> <br>typedef struct lfModifier { <br>    unsigned short  leaf;       /* LF_MODIFIER */ <br>    CV_modifier_t   attr;       /* modifier attribute modifier_t */ <br>    CV_typ_t        type;       /* modified type */ <br>} lfModifier; <br> <br>/* <br> *      type record for LF_POINTER <br> */ <br> <br>typedef struct lfPointer { <br>    struct lfPointerBody { <br>        unsigned short      leaf; /* LF_POINTER */ <br>        struct { <br>            unsigned char   ptrtype     :5; /* ordinal specifying pointer type (ptrtype-t) */ <br>            unsigned char   ptrmode     :3; /* ordinal specifying pointer mode (ptrmode_t) */ <br>            unsigned char   isflat32    :1; /* true if 0:32 pointer */ <br>            unsigned char   isvolatile  :1; /* TRUE if volatile pointer */ <br>            unsigned char   isconst     :1; /* TRUE if const pointer */ <br>            unsigned char   unused      :5; <br>        } attr; <br>        CV_typ_t    utype;      /* type index of the underlying type */ <br>    } u; <br>    union  { <br>        struct { <br>            CV_typ_t        pmclass; /* index of containing class for pointer to member */ <br>            unsigned short  pmenum; /* enumeration specifying pm format */ <br>        } pm; <br>        unsigned short      bseg; /* base segment if PTR_BASE_SEG */ <br>        unsigned char       Sym[1]; /* copy of base symbol record (including length) */ <br>        struct  { <br>            unsigned short  index; /* type index if CV_PTR_BASE_TYPE */ <br>            unsigned char   name[1]; /* name of base type */ <br>        } btype; <br>    } pbase; <br>} lfPointer; <br> <br>/* <br> *      type record for LF_ARRAY <br> */ <br> <br>typedef struct lfArray { <br>    unsigned short  leaf;       /* LF_ARRAY */ <br>    CV_typ_t        elemtype;   /* type index of element type */ <br>    CV_typ_t        idxtype;    /* type index of indexing type */ <br>    unsigned char   data[];     /* variable length data specifying */ <br>                                /* size in bytes and name */ <br>} lfArray; <br> <br>/* <br> *      type record for LF_CLASS, LF_STRUCTURE <br> */ <br> <br>typedef struct lfClass { <br>    unsigned short  leaf;       /* LF_CLASS, LF_STRUCT */ <br>    unsigned short  count;      /* count of number of elements in class */ <br>    CV_typ_t        field;      /* type index of LF_FIELD descriptor list */ <br>    CV_prop_t       property;   /* property attribute field (prop_t) */ <br>    CV_typ_t        derived;    /* type index of derived from list if not zero */ <br>    CV_typ_t        vshape;     /* type index of vshape table for this class */ <br>    unsigned char   data[];     /* data describing length of structure in */ <br>                                /* bytes and name */ <br>} lfClass; <br>typedef lfClass lfStructure; <br> <br>/* <br> *      type record for LF_UNION <br> */ <br> <br>typedef struct lfUnion { <br>    unsigned short  leaf;       /* LF_UNION */ <br>    unsigned short  count;      /* count of number of elements in class */ <br>    CV_typ_t        field;      /* type index of LF_FIELD descriptor list */ <br>    CV_prop_t       property;   /* property attribute field */ <br>    unsigned char   data[];     /* variable length data describing length of */ <br>                                /* structure and name */ <br>} lfUnion; <br> <br>/* <br> *      type record for LF_ENUM <br> */ <br> <br>typedef struct lfEnum { <br>    unsigned short  leaf;       /* LF_ENUM */ <br>    unsigned short  count;      /* count of number of elements in class */ <br>    CV_typ_t        utype;      /* underlying type of the enum */ <br>    CV_typ_t        field;      /* type index of LF_FIELD descriptor list */ <br>    CV_prop_t       property;   /* property attribute field */ <br>    unsigned char   Name[1];    /* length prefixed name of enum */ <br>} lfEnum; <br> <br>/* <br> *      Type record for LF_PROCEDURE <br> */ <br> <br>typedef struct lfProc { <br>    unsigned short  leaf;       /* LF_PROCEDURE */ <br>    CV_typ_t        rvtype;     /* type index of return value */ <br>    unsigned char   calltype;   /* calling convention (call_t) */ <br>    unsigned char   reserved;   /* reserved for future use */ <br>    unsigned short  parmcount;  /* number of parameters */ <br>    CV_typ_t        arglist;    /* type index of argument list */ <br>} lfProc; <br> <br>/* <br> *      Type record for member function <br> */ <br> <br>typedef struct lfMFunc { <br>    unsigned short  leaf;       /* LF_MFUNCTION */ <br>    CV_typ_t        rvtype;     /* type index of return value */ <br>    CV_typ_t        classtype;  /* type index of containing class */ <br>    CV_typ_t        thistype;   /* type index of this pointer (model specific) */ <br>    unsigned char   calltype;   /* calling convention (call_t) */ <br>    unsigned char   reserved;   /* reserved for future use */ <br>    unsigned short  parmcount;  /* number of parameters */ <br>    CV_typ_t        arglist;    /* type index of argument list */ <br>    long            thisadjust; /* this adjuster (long because pad required anyway) */ <br>} lfMFunc; <br> <br>/* <br> *     type record for virtual function table shape <br> */ <br> <br>typedef struct lfVTShape { <br>    unsigned short  leaf;       /* LF_VTSHAPE */ <br>    unsigned short  count;      /* number of entries in vfunctable */ <br>    unsigned char   desc[];     /* variable number of 4 bit (VTS_desc) descriptors */ <br>} lfVTShape; <br> <br>/* <br> *      type record for cobol0 <br> */ <br> <br>typedef struct lfCobol0 { <br>    unsigned short  leaf;       /* LF_COBOL0 */ <br>    CV_typ_t        type; <br>    unsigned char   data[]; <br>} lfCobol0; <br> <br>/* <br> *      type record for cobol1 <br> */ <br> <br>typedef struct lfCobol1 { <br>    unsigned short  leaf;       /* LF_COBOL1 */ <br>    unsigned char   data[]; <br>} lfCobol1; <br> <br>/* <br> *      type record for basic array <br> */ <br> <br>typedef struct lfBArray { <br>    unsigned short  leaf;       /* LF_BARRAY */ <br>    CV_typ_t        utype;      /* type index of underlying type */ <br>} lfBArray; <br> <br>/* <br> *      type record for assembler labels <br> */ <br> <br>typedef struct lfLabel { <br>    unsigned short  leaf;       /* LF_LABEL */ <br>    unsigned short  mode;       /* addressing mode of label */ <br>} lfLabel; <br> <br>/* <br> *      type record for dimensioned arrays <br> */ <br> <br>typedef struct lfDimArray { <br>    unsigned short  leaf;       /* LF_DIMARRAY */ <br>    CV_typ_t        utype;      /* underlying type of the array */ <br>    CV_typ_t        diminfo;    /* dimension information */ <br>    char            name[1];    /* length prefixed name */ <br>} lfDimArray; <br> <br>/* <br> *      type record describing path to virtual function table <br> */ <br> <br> <br>typedef struct lfVFTPath { <br>    unsigned short  leaf;       /* LF_VFTPATH */ <br>    unsigned short  count;      /* count of number of bases in path */ <br>    CV_typ_t        base[1];    /* bases from root to leaf */ <br>} lfVFTPath; <br> <br>/* <br> *      type record describing inclusion of precompiled types <br> */ <br> <br>typedef struct lfPreComp { <br>    unsigned short  leaf;       /* LF_PRECOMP */ <br>    unsigned short  start;      /* starting type index included */ <br>    unsigned short  count;      /* number of types in inclusion */ <br>    unsigned long   signature;  /* signature */ <br>    unsigned char   name[];     /* length prefixed name of included type file */ <br>} lfPreComp; <br> <br>/* <br> *      type record describing end of precompiled types that will be <br> *      included by another file <br> */ <br> <br>typedef struct lfEndPreComp { <br>    unsigned short  leaf;       /* LF_ENDPRECOMP */ <br>    unsigned long   signature;  /* signature */ <br>} lfEndPreComp; <br> <br>/* <br> *      description of type records that can be referenced from <br> *      type records referenced by symbols <br> */ <br> <br>/* <br> *      type record for skip record <br> */ <br> <br>typedef struct lfSkip { <br>    unsigned short  leaf;       /* LF_SKIP */ <br>    CV_typ_t        type;       /* next valid index */ <br>    unsigned char   data[];     /* pad data */ <br>} lfSkip; <br> <br>/* <br> *      argument list leaf <br> */ <br> <br>typedef struct lfArgList { <br>    unsigned short  leaf;       /* LF_ARGLIST */ <br>    unsigned short  count;      /* number of arguments */ <br>    CV_typ_t        arg[];      /* number of arguments */ <br>} lfArgList; <br> <br>/* <br> *      derived class list leaf <br> */ <br> <br>typedef struct lfDerived { <br>    unsigned short  leaf;       /* LF_DERIVED */ <br>    unsigned short  count;      /* number of arguments */ <br>    CV_typ_t        drvdcls[];  /* type indices of derived classes */ <br>} lfDerived; <br> <br>/* <br> *      leaf for default arguments <br> */ <br> <br>typedef struct lfDefArg { <br>    unsigned short  leaf;       /* LF_DEFARG */ <br>    CV_typ_t        type;       /* type of resulting expression */ <br>    unsigned char   expr[];     /* length prefixed expression string */ <br>} lfDefArg; <br> <br>/* <br> *      list leaf <br> *          This list should no longer be used because the utilities cannot <br> *          verify the contents of the list without knowing what type of list <br> *          it is.  New specific leaf indices should be used instead. <br> */ <br> <br>typedef struct lfList { <br>    unsigned short  leaf;       /* LF_LIST */ <br>    char            data[];     /* data format specified by indexing type */ <br>} lfList; <br> <br>/* <br> *      field list leaf <br> *      This is the header leaf for a complex list of class and structure <br> *      subfields. <br> */ <br> <br>typedef struct lfFieldList { <br>    unsigned short  leaf;       /* LF_FIELDLIST */ <br>    char            data[];     /* field list sub lists */ <br>} lfFieldList; <br> <br>/* <br> *  type record for non-static methods and friends in method list <br> */ <br> <br>typedef struct mlMethod { <br>    CV_fldattr_t   attr;        /* method attribute */ <br>    CV_typ_t       index;       /* index to type record for procedure */ <br>#ifdef CV <br>    unsigned long  vbaseoff[0]; /* offset in vfunctable if intro virtual */ <br>#else <br>//    unsigned long   vbaseoff[1]; <br>#endif <br>} mlMethod; <br> <br>typedef struct lfMethodList { <br>    unsigned short leaf; <br>    unsigned char  mList[];     /* really a mlMethod type */ <br>} lfMethodList; <br> <br>/* <br> *      type record for LF_BITFIELD <br> */ <br> <br>typedef struct lfBitfield { <br>    unsigned short  leaf;       /* LF_BITFIELD */ <br>    unsigned char   length; <br>    unsigned char   position; <br>    CV_typ_t        type;       /* type of bitfield */ <br> <br>} lfBitfield; <br> <br>/* <br> *      type record for dimensioned array with constant bounds <br> */ <br> <br>typedef struct lfDimCon { <br>    unsigned short  leaf;       /* LF_DIMCONU or LF_DIMCONLU */ <br>    unsigned short  rank;       /* number of dimensions */ <br>    CV_typ_t        typ;        /* type of index */ <br>    unsigned char   dim[];      /* array of dimension information with */ <br>                                /* either upper bounds or lower/upper bound */ <br>} lfDimCon; <br> <br>/* <br> *      type record for dimensioned array with variable bounds <br> */ <br> <br>typedef struct lfDimVar { <br>    unsigned short  leaf;       /* LF_DIMVARU or LF_DIMVARLU */ <br>    unsigned short  rank;       /* number of dimensions */ <br>    CV_typ_t        typ;        /* type of index */ <br>    unsigned char   dim[];      /* array of type indices for either */ <br>                                /* variable upper bound or variable */ <br>                                /* lower/upper bound.  The referenced */ <br>                                /* types must be LF_REFSYM or T_VOID */ <br>} lfDimVar; <br> <br>/* <br> *      type record for referenced symbol <br> */ <br> <br>typedef struct lfRefSym { <br>    unsigned short  leaf;       /* LF_REFSYM */ <br>    unsigned char   Sym[1];     /* copy of referenced symbol record */ <br>                                /* (including length) */ <br>} lfRefSym; <br> <br>/**     the following are numeric leaves.  They are used to indicate the <br> *      size of the following variable length data.  When the numeric <br> *      data is a single byte less than 0x8000, then the data is output <br> *      directly.  If the data is more the 0x8000 or is a negative value, <br> *      then the data is preceeded by the proper index. <br> */ <br> <br>/*      signed character leaf */ <br> <br>typedef struct lfChar { <br>    unsigned short  leaf;       /* LF_CHAR */ <br>    signed char     val;        /* signed 8-bit value */ <br>} lfChar; <br> <br>/*      signed short leaf */ <br> <br>typedef struct lfShort { <br>    unsigned short  leaf;       /* LF_SHORT */ <br>    short           val;        /* signed 16-bit value */ <br>} lfShort; <br> <br>/*      unsigned short leaf */ <br> <br>typedef struct lfUShort { <br>    unsigned short  leaf;       /* LF_unsigned short */ <br>    unsigned short  val;        /* unsigned 16-bit value */ <br>} lfUShort; <br> <br>/*      signed long leaf */ <br> <br>typedef struct lfLong { <br>    unsigned short  leaf;       /* LF_LONG */ <br>    long            val;        /* signed 32-bit value */ <br>} lfLong; <br> <br>/*      unsigned long leaf */ <br> <br>typedef struct lfULong { <br>    unsigned short  leaf;       /* LF_ULONG */ <br>    unsigned long   val;        /* unsigned 32-bit value */ <br>} lfULong; <br> <br>/*      real 32-bit leaf */ <br> <br>typedef struct lfReal32 { <br>    unsigned short  leaf;       /* LF_REAL32 */ <br>    float           val;        /* 32-bit real value */ <br>} lfReal32; <br> <br>/*      real 48-bit leaf */ <br> <br>typedef struct lfReal48 { <br>    unsigned short  leaf;       /* LF_REAL48 */ <br>    unsigned char   val[6];     /* 48-bit real value */ <br>} lfReal48; <br> <br>/*      real 64-bit leaf */ <br> <br>typedef struct lfReal64 { <br>    unsigned short  leaf;       /* LF_REAL64 */ <br>    double          val;        /* 64-bit real value */ <br>} lfReal64; <br> <br>/*      real 80-bit leaf */ <br> <br>typedef struct lfReal80 { <br>    unsigned short  leaf;       /* LF_REAL80 */ <br>    REAL10          val;        /* real 80-bit value */ <br>} lfReal80; <br> <br>/*      real 128-bit leaf */ <br> <br>typedef struct lfReal128 { <br>    unsigned short  leaf;       /* LF_REAL128 */ <br>    char            val[16];    /* real 128-bit value */ <br>} lfReal128; <br> <br>/************************************************************************/ <br> <br>/*      index leaf - contains type index of another leaf */ <br>/*      a major use of this leaf is to allow the compilers to emit a */ <br>/*      long complex list (LF_FIELD) in smaller pieces. */ <br> <br>typedef struct lfIndex { <br>    unsigned short  leaf;       /* LF_INDEX */ <br>    CV_typ_t        index;      /* type index of referenced leaf */ <br>} lfIndex; <br> <br>/*      subfield record for base class field */ <br> <br>typedef struct lfBClass { <br>    unsigned short  leaf;       /* LF_BCLASS */ <br>    CV_typ_t        index;      /* type index of base class */ <br>    CV_fldattr_t    attr;       /* attribute */ <br>    unsigned char   offset[];   /* variable length offset of base within class */ <br>} lfBClass; <br> <br>/*      subfield record for direct and indirect virtual base class field */ <br> <br>typedef struct lfVBClass { <br>    unsigned short  leaf;       /* LF_VBCLASS | LV_IVBCLASS */ <br>    CV_typ_t        index;      /* type index of direct virtual base class */ <br>    CV_typ_t        vbptr;      /* type index of virtual base pointer */ <br>    CV_fldattr_t    attr;       /* attribute */ <br>    unsigned char   vbpoff[];   /* virtual base pointer offset from address point */ <br>                                /* followed by virtual base offset from vbtable */ <br>} lfVBClass; <br> <br>/*      subfield record for friend class */ <br> <br>typedef struct lfFriendCls { <br>    unsigned short  leaf;       /* LF_FRIENDCLS */ <br>    CV_typ_t        index;      /* index to type record of friend class */ <br>} lfFriendCls; <br> <br>/*      subfield record for friend function */ <br> <br>typedef struct lfFriendFcn { <br>    unsigned short  leaf;       /* LF_FRIENDFCN */ <br>    CV_typ_t        index;      /* index to type record of friend function */ <br>    char            Name[1];    /* name of friend function */ <br>} lfFriendFcn; <br> <br>/*      subfield record for non-static data members */ <br> <br>typedef struct lfMember { <br>    unsigned short  leaf;       /* LF_MEMBER */ <br>    CV_typ_t        index;      /* index of type record for field */ <br>    CV_fldattr_t    attr;       /* attribute mask */ <br>    unsigned char   offset[];   /* variable length offset of field followed */ <br>                                /* by length prefixed name of field */ <br>} lfMember; <br> <br>/*  type record for static data members */ <br> <br>typedef struct lfSTMember { <br>    unsigned short  leaf;       /* LF_STMEMBER */ <br>    CV_typ_t        index;      /* index of type record for field */ <br>    CV_fldattr_t    attr;       /* attribute mask */ <br>    char            Name[1];    /* length prefixed name of field */ <br>} lfSTMember; <br> <br>/*      subfield record for virtual function table pointer */ <br> <br>typedef struct lfVFuncTab { <br>    unsigned short  leaf;       /* LF_VFUNCTAB */ <br>    CV_typ_t        type;       /* type index of pointer */ <br>} lfVFuncTab; <br> <br>/*      subfield record for method and friend list */ <br> <br>typedef struct lfMethod { <br>    unsigned short  leaf;       /* LF_METHOD */ <br>    unsigned short  count;      /* number of occurances of function */ <br>    CV_typ_t        mList;      /* index to LF_METHODLIST record */ <br>    char            Name[1];    /* length prefixed name of method */ <br>} lfMethod; <br> <br>/*      subfield record for enumerate */ <br> <br>typedef struct lfEnumerate { <br>    unsigned short  leaf;       /* LF_ENUMERATE */ <br>    CV_fldattr_t    attr;       /* access (ACC_...) */ <br>    unsigned char   value[];    /* variable length value field followed */ <br>                                /* by length prefixed name */ <br>} lfEnumerate; <br> <br>/*  type record for nested (scoped) type definition */ <br> <br>typedef struct lfNestType { <br>    unsigned short  leaf;       /* LF_NESTTYPE */ <br>    CV_typ_t        index;      /* index of nested type definition */ <br>    unsigned char   Name[1];    /* length prefixed type name */ <br>} lfNestType; <br> <br>/*  type record for pad leaf */ <br> <br>typedef struct lfPad { <br>    unsigned char   leaf; <br>} SYM_PAD; <br> <br>/*  Symbol definitions */ <br> <br>typedef enum SYM_ENUM_e { <br>    S_COMPILE    =  0x0001,     /* Compile flags symbol */ <br>    S_REGISTER   =  0x0002,     /* Register variable */ <br>    S_CONSTANT   =  0x0003,     /* constant symbol */ <br>    S_UDT        =  0x0004,     /* User defined type */ <br>    S_SSEARCH    =  0x0005,     /* Start Search */ <br>    S_END        =  0x0006,     /* Block, procedure, "with" or thunk end */ <br>    S_SKIP       =  0x0007,     /* Reserve symbol space in $$Symbols table */ <br>    S_CVRESERVE  =  0x0008,     /* Reserve symbol for CV internal use */ <br>    S_OBJNAME    =  0x0009,     /* path to object file name */ <br>    S_ENDARG     =  0x000a,     /* end of argument list */ <br>    S_COBOLUDT   =  0x000b,     /* special UDT for cobol -- not packed */ <br> <br>    S_BPREL16    =  0x0100,     /* BP-relative */ <br>    S_LDATA16    =  0x0101,     /* Module-local symbol */ <br>    S_GDATA16    =  0x0102,     /* Global data symbol */ <br>    S_PUB16      =  0x0103,     /* a public symbol */ <br>    S_LPROC16    =  0x0104,     /* Local procedure start */ <br>    S_GPROC16    =  0x0105,     /* Global procedure start */ <br>    S_THUNK16    =  0x0106,     /* Thunk Start */ <br>    S_BLOCK16    =  0x0107,     /* block start */ <br>    S_WITH16     =  0x0108,     /* with start */ <br>    S_LABEL16    =  0x0109,     /* code label */ <br>    S_CEXMODEL16 =  0x010a,     /* change execution model */ <br>    S_VFTABLE16  =  0x010b,     /* address of virtual function table */ <br>    S_REGREL16   =  0x010c,     /* register relative address */ <br> <br>    S_BPREL32    =  0x0200,     /* BP-relative */ <br>    S_LDATA32    =  0x0201,     /* Module-local symbol */ <br>    S_GDATA32    =  0x0202,     /* Global data symbol */ <br>    S_PUB32      =  0x0203,     /* a public symbol (CV internal reserved) */ <br>    S_LPROC32    =  0x0204,     /* Local procedure start */ <br>    S_GPROC32    =  0x0205,     /* Global procedure start */ <br>    S_THUNK32    =  0x0206,     /* Thunk Start */ <br>    S_BLOCK32    =  0x0207,     /* block start */ <br>    S_WITH32     =  0x0208,     /* with start */ <br>    S_LABEL32    =  0x0209,     /* code label */ <br>    S_CEXMODEL32 =  0x020a,     /* change execution model */ <br>    S_VFTABLE32  =  0x020b,     /* address of virtual function table */ <br>    S_REGREL32   =  0x020c,     /* register relative address */ <br>    S_LTHREAD32  =  0x020d, <br>    S_GTHREAD32  =  0x020e, <br> <br>    S_LPROCMIPS  =  0x0300,     /* Local procedure start */ <br>    S_GPROCMIPS  =  0x0301,     /* Global procedure start */ <br> <br>    S_PROCREF    =  0x400,      /* Procedure reference */ <br>    S_DATAREF    =  0x401,      /* Data reference */ <br>    S_ALIGN      =  0x402       /* Page Alignment */ <br>} SYM_ENUM_e; <br> <br>/*  enum describing the compile flag source language */ <br> <br>typedef enum { <br>    CV_CFL_C        = 0x00, <br>    CV_CFL_CXX      = 0x01, <br>    CV_CFL_FORTRAN  = 0x02, <br>    CV_CFL_MASM     = 0x03, <br>    CV_CFL_PASCAL   = 0x04, <br>    CV_CFL_BASIC    = 0x05, <br>    CV_CFL_COBOL    = 0x06 <br>} CV_CFL_LANG; <br> <br>/*  enum describing target processor */ <br> <br>typedef enum CV_CPU_TYPE_e { <br>    CV_CFL_8080         = 0x00, <br>    CV_CFL_8086         = 0x01, <br>    CV_CFL_80286        = 0x02, <br>    CV_CFL_80386        = 0x03, <br>    CV_CFL_80486        = 0x04, <br>    CV_CFL_PENTIUM      = 0x05, <br>    CV_CFL_MIPSR4000    = 0x10, <br>    CV_CFL_M68000       = 0x20, <br>    CV_CFL_M68010       = 0x21, <br>    CV_CFL_M68020       = 0x22, <br>    CV_CFL_M68030       = 0x23, <br>    CV_CFL_M68040       = 0x24, <br>    CV_CFL_ALPHA        = 0x30 <br> <br>} CV_CPU_TYPE_e; <br> <br>/*  enum describing compile flag ambiant data model */ <br> <br>typedef enum { <br>    CV_CFL_DNEAR    = 0x00, <br>    CV_CFL_DFAR     = 0x01, <br>    CV_CFL_DHUGE    = 0x02 <br>} CV_CFL_DATA; <br> <br>/*  enum describing compile flag ambiant code model */ <br> <br>typedef enum CV_CFL_CODE_e { <br>    CV_CFL_CNEAR    = 0x00, <br>    CV_CFL_CFAR     = 0x01, <br>    CV_CFL_CHUGE    = 0x02 <br>} CV_CFL_CODE_e; <br> <br>/*  enum describing compile flag target floating point package */ <br> <br>typedef enum CV_CFL_FPKG_e { <br>    CV_CFL_NDP      = 0x00, <br>    CV_CFL_EMU      = 0x01, <br>    CV_CFL_ALT      = 0x02 <br>} CV_CFL_FPKG_e; <br> <br>typedef struct SYMTYPE { <br>    unsigned short      reclen; /* Record length */ <br>    unsigned short      rectyp; /* Record type */ <br>    char        data[]; <br>} SYMTYPE; <br> <br>/* <br> *  cobol information --- <br> */ <br> <br>typedef enum CV_COBOL_e { <br>    CV_COBOL_dontstop, <br>    CV_COBOL_pfm, <br>    CV_COBOL_false, <br>    CV_COBOL_extcall <br>} CV_COBOL_e; <br> <br>struct { <br>    unsigned short subtype;     /* see CV_COBOL_e above */ <br>    unsigned short flag; <br>} cobol; <br> <br> <br>/*      non-model specific symbol types */ <br> <br>typedef struct REGSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_REGISTER */ <br>    unsigned short  typind;     /* Type index */ <br>    unsigned short  reg;        /* register enumerate */ </code></pre>
<p>
</p>
<pre><code>unsigned char   name[1];    /* Length-prefixed name */ <br>} REGSYM; <br> <br>typedef struct CONSTSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_CONSTANT */ <br>    CV_typ_t        typind;     /* Type index (containing enum if enumerate) */ <br>    unsigned short  value;      /* numeric leaf containing value */ <br>    unsigned char   name[];     /* Length-prefixed name */ <br>} CONSTSYM; <br> <br>typedef struct UDTSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_UDT |S_COBOLUDT */ <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} UDTSYM; <br> <br>typedef struct SEARCHSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_SSEARCH */ <br>    unsigned long   startsym;   /* offset of the procedure */ <br>    unsigned short  seg;        /* segment of symbol */ <br>} SEARCHSYM; <br> <br>typedef struct CFLAGSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_COMPILE */ <br>    unsigned char   machine;    /* target processor */ <br>    struct  { <br>        unsigned char   language    :8; /* language index */ <br>        unsigned char   pcode       :1; /* true if pcode present */ <br>        unsigned char   floatprec   :2; /* floating precision */ <br>        unsigned char   floatpkg    :2; /* float package */ <br>        unsigned char   ambdata     :3; /* ambiant data model */ <br>        unsigned char   ambcode     :3; /* ambiant code model */ <br>        unsigned char   mode32      :1; /* true if compiled 32 bit mode */ <br>        unsigned char   pad         :4; /* reserved */ <br>    } flags; <br>    unsigned char       ver[1]; /* Length-prefixed compiler version string */ <br>} CFLAGSYM; <br> <br>typedef struct OBJNAMESYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_OBJNAME */ <br>    unsigned long   signature;  /* signature */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} OBJNAMESYM; <br> <br>/*      symbol types for 16:16 memory model */ <br> <br>typedef struct BPRELSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_BPREL16 */ <br>    CV_off16_t      off;        /* BP-relative offset */ <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} BPRELSYM16; <br> <br>typedef struct DATASYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_LDATA16 or S_GDATA16 or S_PUB16 */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} DATASYM16; <br>typedef DATASYM16 PUBSYM16; <br> <br>typedef struct PROCSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_GPROC16 or S_LPROC16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>    unsigned short  len;        /* Proc length */ <br>    unsigned short  DbgStart;   /* Debug start offset */ <br>    unsigned short  DbgEnd;     /* Debug end offset */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    CV_typ_t        typind;     /* Type index */ <br>    char            rtntyp;     /* Return type (NEAR/FAR) */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} PROCSYM16; <br> <br>typedef struct THUNKSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_THUNK16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    unsigned short  len;        /* length of thunk */ <br>    unsigned char   ord;        /* ordinal specifying type of thunk */ <br>    unsigned char   name[1];    /* name of thunk */ <br>#ifdef CV <br>    unsigned char   variant[0]; /* variant portion of thunk */ <br>#else <br>    unsigned char   variant[1]; /* variant portion of thunk */ <br>#endif <br>} THUNKSYM16; <br> <br>typedef enum { <br>    THUNK_ORDINAL_NOTYPE, <br>    THUNK_ORDINAL_ADJUSTOR, <br>    THUNK_ORDINAL_VCALL <br>} THUNK_ORDINAL; <br> <br>typedef struct LABELSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_LABEL16 */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    char            rtntyp;     /* Return type (NEAR/FAR) */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} LABELSYM16; <br> <br>typedef enum CV_RETURN_TYPE_e { <br>    CV_RETURN_NEAR = 0,         /* near return */ <br>    CV_RETURN_FAR  = 4          /* far return */ <br>} CV_RETURN_TYPE_e; <br> <br>typedef struct BLOCKSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_BLOCK16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned short  len;        /* Block length */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} BLOCKSYM16; <br> <br>typedef struct WITHSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_WITH16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned short  len;        /* Block length */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} WITHSYM16; <br> <br>typedef enum CEXM_MODEL_e { <br>    CEXM_MDL_table  = 0x00,     /* not executable */ <br>    CEXM_MDL_native = 0x20,     /* native */ <br>    CEXM_MDL_cobol  = 0x21,     /* cobol */ <br>    CEXM_MDL_pcode  = 0x40      /* pcode */ <br>} CEXM_MODEL_e; <br> <br>typedef struct CEXMSYM16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_CEXMODEL16 */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  seg;        /* segment of symbol */ <br>    unsigned short  model;      /* execution model */ <br>    union variant { <br>        struct  { <br>            CV_uoff16_t pcdtable; /* offset to pcode function table */ <br>            CV_uoff16_t pcdspi; /* offset to segment pcode information */ <br>        } pcode; <br>    } u; <br>} CEXMSYM16; <br> <br>typedef struct VPATHSYM16 { <br>    unsigned short  reclen;     /* record length */ <br>    unsigned short  rectyp;     /* S_VFTPATH16 */ <br>    CV_uoff16_t     off;        /* offset of virtual function table */ <br>    unsigned short  seg;        /* segment of virtual function table */ <br>    CV_typ_t        root;       /* type index of the root of path */ <br>    CV_typ_t        path;       /* type index of the path record */ <br>} VPATHSYM16; <br> <br>typedef struct REGREL16 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_REGREL16 */ <br>    CV_uoff16_t     off;        /* offset of symbol */ <br>    unsigned short  reg;        /* register index */ <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} REGREL16; <br> <br>typedef struct BPRELSYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_BPREL32 */ <br>    CV_off32_t      off;        /* BP-relative offset */ <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} BPRELSYM32; <br> <br>typedef struct DATASYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_LDATA32, S_GDATA32, S_LTHREAD32, <br>                                   S_GTHREAD32 or S_PUB32 */ <br>    CV_uoff32_t     off; <br>    unsigned short  seg; <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} DATASYM32; <br>typedef DATASYM32 PUBSYM32; <br> <br>typedef struct PROCSYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_GPROC32 or S_LPROC32 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>    unsigned long   len;        /* Proc length */ <br>    unsigned long   DbgStart;   /* Debug start offset */ <br>    unsigned long   DbgEnd;     /* Debug end offset */ <br>    CV_uoff32_t     off; <br>    unsigned short  seg; <br>    CV_typ_t        typind;     /* Type index */ <br>    char            rtntyp;     /* Return type (NEAR/FAR) */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} PROCSYM32; <br> <br>typedef struct THUNKSYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_THUNK32 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>    CV_uoff32_t     off; <br>    unsigned short  seg; <br>    unsigned short  len;        /* length of thunk */ <br>    unsigned char   ord;        /* ordinal specifying type of thunk */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>#ifdef CV <br>    unsigned char   variant[0]; /* variant portion of thunk */ <br>#else <br>    unsigned char   variant[1]; /* variant portion of thunk */ <br>#endif <br>} THUNKSYM32; <br> <br>typedef struct LABELSYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_LABEL32 */ <br>    CV_uoff32_t     off; <br>    unsigned short  seg; <br>    char            rtntyp;     /* Return type (NEAR/FAR) */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} LABELSYM32; <br> <br>typedef struct BLOCKSYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_BLOCK32 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   len;        /* Block length */ <br>    CV_uoff32_t     off;        /* Offset in code segment */ <br>    unsigned short  seg;        /* segment of label */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} BLOCKSYM32; <br> <br>typedef struct WITHSYM32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_WITH32 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   len;        /* Block length */ <br>    CV_uoff32_t     off;        /* Offset in code segment */ <br>    unsigned short  seg;        /* segment of label */ <br>    unsigned char   name[1];    /* Length-prefixed expression string */ <br>} WITHSYM32; <br> <br>typedef struct VPATHSYM32 { <br>    unsigned short  reclen;     /* record length */ <br>    unsigned short  rectyp;     /* S_VFTPATH32 */ <br>    CV_uoff32_t     off;        /* offset of virtual function table */ <br>    unsigned short  seg;        /* segment of virtual function table */ <br>    CV_typ_t        root;       /* type index of the root of path */ <br>    CV_typ_t        path;       /* type index of the path record */ <br>} VPATHSYM32; <br> <br>typedef struct REGREL32 { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_REGREL32 */ <br>    CV_uoff32_t     off;        /* offset of symbol */ <br>    unsigned short  reg;        /* register index for symbol */ <br>    CV_typ_t        typind;     /* Type index */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} REGREL32, * LPREGREL32; <br> <br>typedef struct PROCSYMMIPS { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_GPROCMIPS or S_LPROCMIPS */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>    unsigned long   len;        /* Proc length */ <br>    unsigned long   DbgStart;   /* Debug start offset */ <br>    unsigned long   DbgEnd;     /* Debug end offset */ <br>    unsigned long   regSave;    /* int register save mask */ <br>    unsigned long   fpSave;     /* fp register save mask */ <br>    unsigned long   intOff;     /* int register save offset */ <br>    unsigned long   fpOff;      /* fp register save offset */ <br>    CV_uoff32_t     off;        /* Symbol offset */ <br>    unsigned short  seg;        /* Symbol segment */ <br>    CV_typ_t        typind;     /* Type index */ <br>    char            retReg;     /* Register return value is in */ <br>    char            frameReg;   /* Frame pointer register */ <br>    unsigned char   name[1];    /* Length-prefixed name */ <br>} PROCSYMMIPS, *PROCPTRMIPS; <br> <br>/*  generic block definition symbols */ <br>/*  these are similar to the equivalent 16:16 or 16:32 symbols but */ <br>/*  only define the length, type and linkage fields */ <br> <br>typedef struct PROCSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_GPROC16 or S_LPROC16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>} PROCSYM; <br> <br>typedef struct THUNKSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_THUNK */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>    unsigned long   pNext;      /* pointer to next symbol */ <br>} THUNKSYM; <br> <br>typedef struct BLOCKSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_BLOCK16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>} BLOCKSYM; <br> <br>typedef struct WITHSYM { <br>    unsigned short  reclen;     /* Record length */ <br>    unsigned short  rectyp;     /* S_WITH16 */ <br>    unsigned long   pParent;    /* pointer to the parent */ <br>    unsigned long   pEnd;       /* pointer to this blocks end */ <br>} WITHSYM; <br> <br>typedef enum CV_HREG_e { <br>    /* <br>     *  Register set for the Intel 80x86 and ix86 processor series <br>     *  (plus PCODE registers) <br>     */ <br> <br>    CV_REG_NONE  =   0, <br>    CV_REG_AL    =   1, <br>    CV_REG_CL    =   2, <br>    CV_REG_DL    =   3, <br>    CV_REG_BL    =   4, <br>    CV_REG_AH    =   5, <br>    CV_REG_CH    =   6, <br>    CV_REG_DH    =   7, <br>    CV_REG_BH    =   8, <br>    CV_REG_AX    =   9, <br>    CV_REG_CX    =  10, <br>    CV_REG_DX    =  11, <br>    CV_REG_BX    =  12, <br>    CV_REG_SP    =  13, <br>    CV_REG_BP    =  14, <br>    CV_REG_SI    =  15, <br>    CV_REG_DI    =  16, <br>    CV_REG_EAX   =  17, <br>    CV_REG_ECX   =  18, <br>    CV_REG_EDX   =  19, <br>    CV_REG_EBX   =  20, <br>    CV_REG_ESP   =  21, <br>    CV_REG_EBP   =  22, <br>    CV_REG_ESI   =  23, <br>    CV_REG_EDI   =  24, <br>    CV_REG_ES    =  25, <br>    CV_REG_CS    =  26, <br>    CV_REG_SS    =  27, <br>    CV_REG_DS    =  28, <br>    CV_REG_FS    =  29, <br>    CV_REG_GS    =  30, <br>    CV_REG_IP    =  31, <br>    CV_REG_FLAGS =  32, <br>    CV_REG_EIP   =  33, <br>    CV_REG_EFLAGS = 34, <br>    CV_REG_TEMP  =  40,         /* PCODE Temp */ <br>    CV_REG_TEMPH =  41,         /* PCODE TempH */ <br>    CV_REG_QUOTE =  42,         /* PCODE Quote */ <br>    CV_REG_PCDR3 =  43,         /* PCODE reserved */ <br>    CV_REG_PCDR4 =  44,         /* PCODE reserved */ <br>    CV_REG_PCDR5 =  45,         /* PCODE reserved */ <br>    CV_REG_PCDR6 =  46,         /* PCODE reserved */ <br>    CV_REG_PCDR7 =  47,         /* PCODE reserved */ <br>    CV_REG_CR0   =  80,         /* CR0 -- control registers */ <br>    CV_REG_CR1   =  81, <br>    CV_REG_CR2   =  82, <br>    CV_REG_CR3   =  83, <br>    CV_REG_DR0   =  90,         /* Debug register */ <br>    CV_REG_DR1   =  91, <br>    CV_REG_DR2   =  92, <br>    CV_REG_DR3   =  93, <br>    CV_REG_DR4   =  94, <br>    CV_REG_DR5   =  95, <br>    CV_REG_DR6   =  96, <br>    CV_REG_DR7   =  97, <br>    CV_REG_ST0   =  128, <br>    CV_REG_ST1   =  129, <br>    CV_REG_ST2   =  130, <br>    CV_REG_ST3   =  131, <br>    CV_REG_ST4   =  132, <br>    CV_REG_ST5   =  133, <br>    CV_REG_ST6   =  134, <br>    CV_REG_ST7   =  135, <br>    CV_REG_CTRL  =  136, <br>    CV_REG_STAT  =  137, <br>    CV_REG_TAG   =  138, <br>    CV_REG_FPIP  =  139, <br>    CV_REG_FPCS  =  140, <br>    CV_REG_FPDO  =  141, <br>    CV_REG_FPDS  =  142, <br>    CV_REG_ISEM  =  143, <br>    CV_REG_FPEIP =  144, <br>    CV_REG_FPEDO =  145, <br> <br>    /* <br>     * registers for the 68K processors <br>     */ <br> <br>    CV_R68_D0   =   0, <br>    CV_R68_D1   =   1, <br>    CV_R68_D2   =   2, <br>    CV_R68_D3   =   3, <br>    CV_R68_D4   =   4, <br>    CV_R68_D5   =   5, <br>    CV_R68_D6   =   6, <br>    CV_R68_D7   =   7, <br>    CV_R68_A0   =   8, <br>    CV_R68_A1   =   9, <br>    CV_R68_A2   =   10, <br>    CV_R68_A3   =   11, <br>    CV_R68_A4   =   12, <br>    CV_R68_A5   =   13, <br>    CV_R68_A6   =   14, <br>    CV_R68_A7   =   15, <br>    CV_R68_CCR  =   16, <br>    CV_R68_SR   =   17, <br>    CV_R68_USP  =   18, <br>    CV_R68_MSP  =   19, <br>    CV_R68_SFC  =   20, <br>    CV_R68_DFC  =   21, <br>    CV_R68_CACR =   22, <br>    CV_R68_VBR  =   23, <br>    CV_R68_CAAR =   24, <br>    CV_R68_ISP  =   25, <br>    CV_R68_PC   =   26, <br>                                /* reserved  27 */ <br>    CV_R68_FPCR =   28, <br>    CV_R68_FPSR =   29, <br>    CV_R68_FPIAR=   30, <br>                                /* reserved  31 */ <br>    CV_R68_FP0  =   32, <br>    CV_R68_FP1  =   33, <br>    CV_R68_FP2  =   34, <br>    CV_R68_FP3  =   35, <br>    CV_R68_FP4  =   36, <br>    CV_R68_FP5  =   37, <br>    CV_R68_FP6  =   38, <br>    CV_R68_FP7  =   39, <br>                                /* reserved  40-50 */ <br>    CV_R68_PSR  =   51, <br>    CV_R68_PCSR =   52, <br>    CV_R68_VAL  =   53, <br>    CV_R68_CRP  =   54, <br>    CV_R68_SRP  =   55, <br>    CV_R68_DRP  =   56, <br>    CV_R68_TC   =   57, <br>    CV_R68_AC   =   58, <br>    CV_R68_SCC  =   59, <br>    CV_R68_CAL  =   60, <br>    CV_R68_TT0  =   61, <br>    CV_R68_TT1  =   62, <br>                                /* reserved  63 */ <br>    CV_R68_BAD0 =   64, <br>    CV_R68_BAD1 =   65, <br>    CV_R68_BAD2 =   66, <br>    CV_R68_BAD3 =   67, <br>    CV_R68_BAD4 =   68, <br>    CV_R68_BAD5 =   69, <br>    CV_R68_BAD6 =   70, <br>    CV_R68_BAD7 =   71, <br>    CV_R68_BAC0 =   72, <br>    CV_R68_BAC1 =   73, <br>    CV_R68_BAC2 =   74, <br>    CV_R68_BAC3 =   75, <br>    CV_R68_BAC4 =   76, <br>    CV_R68_BAC5 =   77, <br>    CV_R68_BAC6 =   78, <br>    CV_R68_BAC7 =   79, <br> <br>    /* <br>     * Register set for the MIPS 4000 <br>     */ <br> <br>    CV_M4_NOREG    =   CV_REG_NONE, <br> <br>    CV_M4_IntZERO  =   10,      /* CPU REGISTER */ <br>    CV_M4_IntAT    =   11, <br>    CV_M4_IntV0    =   12, <br>    CV_M4_IntV1    =   13, <br>    CV_M4_IntA0    =   14, <br>    CV_M4_IntA1    =   15, <br>    CV_M4_IntA2    =   16, <br>    CV_M4_IntA3    =   17, <br>    CV_M4_IntT0    =   18, <br>    CV_M4_IntT1    =   19, <br>    CV_M4_IntT2    =   20, <br>    CV_M4_IntT3    =   21, <br>    CV_M4_IntT4    =   22, <br>    CV_M4_IntT5    =   23, <br>    CV_M4_IntT6    =   24, <br>    CV_M4_IntT7    =   25, <br>    CV_M4_IntS0    =   26, <br>    CV_M4_IntS1    =   27, <br>    CV_M4_IntS2    =   28, <br>    CV_M4_IntS3    =   29, <br>    CV_M4_IntS4    =   30, <br>    CV_M4_IntS5    =   31, <br>    CV_M4_IntS6    =   32, <br>    CV_M4_IntS7    =   33, <br>    CV_M4_IntT8    =   34, <br>    CV_M4_IntT9    =   35, <br>    CV_M4_IntKT0   =   36, <br>    CV_M4_IntKT1   =   37, <br>    CV_M4_IntGP    =   38, <br>    CV_M4_IntSP    =   39, <br>    CV_M4_IntS8    =   40, <br>    CV_M4_IntRA    =   41, <br>    CV_M4_IntLO    =   42, <br>    CV_M4_IntHI    =   43, <br> <br>    CV_M4_Fir      =   50, <br>    CV_M4_Psr      =   51, <br> <br>    CV_M4_FltF0    =   60,      /* Floating point registers */ <br>    CV_M4_FltF1    =   61, <br>    CV_M4_FltF2    =   62, <br>    CV_M4_FltF3    =   63, <br>    CV_M4_FltF4    =   64, <br>    CV_M4_FltF5    =   65, <br>    CV_M4_FltF6    =   66, <br>    CV_M4_FltF7    =   67, <br>    CV_M4_FltF8    =   68, <br>    CV_M4_FltF9    =   69, <br>    CV_M4_FltF10   =   70, <br>    CV_M4_FltF11   =   71, <br>    CV_M4_FltF12   =   72, <br>    CV_M4_FltF13   =   73, <br>    CV_M4_FltF14   =   74, <br>    CV_M4_FltF15   =   75, <br>    CV_M4_FltF16   =   76, <br>    CV_M4_FltF17   =   77, <br>    CV_M4_FltF18   =   78, <br>    CV_M4_FltF19   =   79, <br>    CV_M4_FltF20   =   80, <br>    CV_M4_FltF21   =   81, <br>    CV_M4_FltF22   =   82, <br>    CV_M4_FltF23   =   83, <br>    CV_M4_FltF24   =   84, <br>    CV_M4_FltF25   =   85, <br>    CV_M4_FltF26   =   86, <br>    CV_M4_FltF27   =   87, <br>    CV_M4_FltF28   =   88, <br>    CV_M4_FltF29   =   89, <br>    CV_M4_FltF30   =   90, <br>    CV_M4_FltF31   =   92, <br>    CV_M4_FltFsr   =   93, <br> <br>    /* <br>     * Register set for the ALPHA AXP <br>     */ <br> <br>    CV_ALPHA_NOREG    = CV_REG_NONE, <br> <br>CV_ALPHA_FltF0  =   10,  /* Floating point registers */ <br>CV_ALPHA_FltF1, // 11 <br>CV_ALPHA_FltF2, // 12 <br>CV_ALPHA_FltF3, // 13 <br>CV_ALPHA_FltF4, // 14 <br>CV_ALPHA_FltF5, // 15 <br>CV_ALPHA_FltF6, // 16 <br>CV_ALPHA_FltF7, // 17 <br>CV_ALPHA_FltF8, // 18 <br>CV_ALPHA_FltF9, // 19 <br>CV_ALPHA_FltF10,// 20 <br>CV_ALPHA_FltF11,// 21 <br>CV_ALPHA_FltF12,// 22 <br>CV_ALPHA_FltF13,// 23 <br>CV_ALPHA_FltF14,// 24 <br>CV_ALPHA_FltF15,// 25 <br>CV_ALPHA_FltF16,// 26 <br>CV_ALPHA_FltF17,// 27 <br>CV_ALPHA_FltF18,// 28 <br>CV_ALPHA_FltF19,// 29 <br>CV_ALPHA_FltF20,// 30 <br>CV_ALPHA_FltF21,// 31 <br>CV_ALPHA_FltF22,// 32 <br>CV_ALPHA_FltF23,// 33 <br>CV_ALPHA_FltF24,// 34 <br>CV_ALPHA_FltF25,// 35 <br>CV_ALPHA_FltF26,// 36 <br>CV_ALPHA_FltF27,// 37 <br>CV_ALPHA_FltF28,// 38 <br>CV_ALPHA_FltF29,// 39 <br>CV_ALPHA_FltF30,// 30 <br>CV_ALPHA_FltF31,// 41 <br> <br>CV_ALPHA_IntV0, // 42Integer registers <br>CV_ALPHA_IntT0, // 43 <br>CV_ALPHA_IntT1, // 44 <br>CV_ALPHA_IntT2, // 45 <br>CV_ALPHA_IntT3, // 46 <br>CV_ALPHA_IntT4, // 47 <br>CV_ALPHA_IntT5, // 48 <br>CV_ALPHA_IntT6, // 49 <br>CV_ALPHA_IntT7, // 50 <br>CV_ALPHA_IntS0, // 51 <br>CV_ALPHA_IntS1, // 52 <br>CV_ALPHA_IntS2, // 53 <br>CV_ALPHA_IntS3, // 54 <br>CV_ALPHA_IntS4, // 55 <br>CV_ALPHA_IntS5, // 56 <br>CV_ALPHA_IntFP, // 57 <br>CV_ALPHA_IntA0, // 58 <br>CV_ALPHA_IntA1, // 59 <br>CV_ALPHA_IntA2, // 60 <br>CV_ALPHA_IntA3, // 61 <br>CV_ALPHA_IntA4, // 62 <br>CV_ALPHA_IntA5, // 63 <br>CV_ALPHA_IntT8, // 64 <br>CV_ALPHA_IntT9, // 65 <br>CV_ALPHA_IntT10,// 66 <br>CV_ALPHA_IntT11,// 67 <br>CV_ALPHA_IntRA, // 68 <br>CV_ALPHA_IntT12,// 69 <br>CV_ALPHA_IntAT, // 70 <br>CV_ALPHA_IntGP, // 71 <br>CV_ALPHA_IntSP, // 72 <br>CV_ALPHA_IntZERO,// 73 <br> <br> <br>CV_ALPHA_Fpcr,// 74Control registers <br>CV_ALPHA_Fir,// 75 <br>CV_ALPHA_Psr,// 76 <br>CV_ALPHA_FltFsr // 77 <br> <br>} CV_HREG_e; <br> <br> <br>#pragma pack() <br> <br>#endif /* CV_INFO_INCLUDED */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
