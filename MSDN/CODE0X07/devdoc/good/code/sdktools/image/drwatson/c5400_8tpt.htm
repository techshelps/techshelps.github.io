<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROCESS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5411"></a>PROCESS.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    process.c <br> <br>Abstract: <br> <br>    This code provides access to the task list. <br> <br>Author: <br> <br>    Wesley Witt (wesw) 16-June-1993 <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;winperf.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "drwatson.h" <br>#include "proto.h" <br>#include "messages.h" <br> <br>// <br>// task list structure returned from GetTaskList() <br>// <br>typedef struct _TASK_LIST { <br>    DWORD   dwProcessId; <br>    char    ProcessName[MAX_PATH]; <br>} TASK_LIST, *PTASK_LIST; <br> <br> <br>// <br>// defines <br>// <br>#define INITIAL_SIZE        51200 <br>#define EXTEND_SIZE         25600 <br>#define REGKEY_PERF         "software\\microsoft\\windows nt\\currentversion\\perflib" <br>#define REGSUBKEY_COUNTERS  "Counters" <br>#define PROCESS_COUNTER     "process" <br>#define PROCESSID_COUNTER   "id process" <br>#define UNKNOWN_TASK        "unknown" <br> <br> <br>// <br>// prototypes <br>// <br>PTASK_LIST GetTaskList( LPLONG pNumTasks ); <br> <br> <br>void <br>LogTaskList( void ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function gets the current task list and logs the process id &amp; <br>    process name to the log file. <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PTASK_LIST   pTask; <br>    PTASK_LIST   pTaskBegin; <br>    LONG         NumTasks; <br> <br> <br>    lprintf( MSG_TASK_LIST ); <br> <br>    pTask = pTaskBegin = GetTaskList( &amp;NumTasks ); <br> <br>    if (pTask == NULL) { <br>        printf( "ERROR: could not get the task list\n" ); <br>    } <br> <br>    while (NumTasks--) { <br>        lprintfs("%4d %s\r\n",pTask-&gt;dwProcessId, pTask-&gt;ProcessName ); <br>        pTask++; <br>    } <br>    lprintfs( "\r\n" ); <br> <br>    free( pTaskBegin ); <br>} <br> <br>void <br>GetTaskName( ULONG pid, char *szTaskName, LPDWORD pdwSize ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Gets the task name for a given process id. <br> <br>Arguments: <br> <br>    pid              - Process id to look for. <br>    szTaskName       - Buffer to put the task name into. <br>    lpdwSize         - Pointer to a dword.  On entry it contains the <br>                       size of the szTaskName buffer.  On exit it contains <br>                       the number of characters in the buffer. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PTASK_LIST   pTask; <br>    PTASK_LIST   pTaskBegin; <br>    LONG         NumTasks; <br> <br> <br>    pTask = pTaskBegin = GetTaskList( &amp;NumTasks ); <br> <br>    if (pTask == NULL) { <br>        if (szTaskName) { <br>            strncpy( szTaskName, "unknown", *pdwSize ); <br>        } <br>        *pdwSize = min( 7, *pdwSize ); <br> <br>    } else { <br> <br>        while (NumTasks--) { <br>            if (pTask-&gt;dwProcessId == pid) { <br>                if (szTaskName) { <br>                    strncpy( szTaskName, pTask-&gt;ProcessName, *pdwSize ); <br>                } <br>                *pdwSize = min( strlen(pTask-&gt;ProcessName), *pdwSize ); <br>                break; <br>            } <br>            pTask++; <br>        } <br> <br>        if (NumTasks &lt; 0) { <br>            if (szTaskName) { <br>                strncpy( szTaskName, "&lt;exited&gt;", *pdwSize ); <br>            } <br>            *pdwSize = min( 8, *pdwSize ); <br>        } <br> <br>        free( pTaskBegin ); <br>    } <br>} <br> <br>PTASK_LIST <br>GetTaskList( LPLONG pNumTasks ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Provides an API for getting a list of tasks running at the time of the <br>    API call.  This function uses the registry performance data to get the <br>    task list and is therefor straight WIN32 calls that anyone can call. <br> <br>Arguments: <br> <br>    pNumTasks      - pointer to a dword that will be set to the <br>                       number of tasks returned. <br> <br>Return Value: <br> <br>    PTASK_LIST       - pointer to an array of TASK_LIST records. <br> <br>--*/ <br> <br>{ <br>    DWORD                        rc; <br>    HKEY                         hKeyNames; <br>    DWORD                        dwType; <br>    DWORD                        dwSize; <br>    LPBYTE                       buf = NULL; <br>    char                         szSubKey[1024]; <br>    LANGID                       lid; <br>    LPSTR                        p; <br>    LPSTR                        p2; <br>    PPERF_DATA_BLOCK             pPerf; <br>    PPERF_OBJECT_TYPE            pObj; <br>    PPERF_INSTANCE_DEFINITION    pInst; <br>    PPERF_COUNTER_BLOCK          pCounter; <br>    PPERF_COUNTER_DEFINITION     pCounterDef; <br>    DWORD                        i; <br>    DWORD                        dwProcessIdTitle; <br>    DWORD                        dwProcessIdCounter; <br>    PTASK_LIST                   pTask; <br>    PTASK_LIST                   pTaskReturn = NULL; <br>    char                         szProcessName[MAX_PATH]; <br> <br> <br>    // <br>    // set the number of tasks to zero until we get some <br>    // <br>    *pNumTasks = 0; <br> <br>    // <br>    // Look for the list of counters.  Always use the neutral <br>    // English version, regardless of the local language.  We <br>    // are looking for some particular keys, and we are always <br>    // going to do our looking in English.  We are not going <br>    // to show the user the counter names, so there is no need <br>    // to go find the corresponding name in the local language. <br>    // <br>    lid = MAKELANGID( LANG_ENGLISH, SUBLANG_NEUTRAL ); <br>    sprintf( szSubKey, "%s\\%03x", REGKEY_PERF, lid ); <br>    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, <br>                       szSubKey, <br>                       0, <br>                       KEY_READ, <br>                       &amp;hKeyNames <br>                     ); <br>    if (rc != ERROR_SUCCESS) { <br>        goto exit; <br>    } <br> <br>    // <br>    // get the buffer size for the counter names <br>    // <br>    rc = RegQueryValueEx( hKeyNames, <br>                          REGSUBKEY_COUNTERS, <br>                          NULL, <br>                          &amp;dwType, <br>                          NULL, <br>                          &amp;dwSize <br>                        ); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        goto exit; <br>    } <br> <br>    // <br>    // allocate the counter names buffer <br>    // <br>    buf = (LPBYTE) malloc( dwSize ); <br>    if (buf == NULL) { <br>        goto exit; <br>    } <br>    memset( buf, 0, dwSize ); <br> <br>    // <br>    // read the counter names from the registry <br>    // <br>    rc = RegQueryValueEx( hKeyNames, <br>                          REGSUBKEY_COUNTERS, <br>                          NULL, <br>                          &amp;dwType, <br>                          buf, <br>                          &amp;dwSize <br>                        ); <br> <br>    if (rc != ERROR_SUCCESS) { <br>        goto exit; <br>    } <br> <br>    // <br>    // now loop thru the counter names looking for the following counters: <br>    // <br>    //      1.  "Process"           process name <br>    //      2.  "ID Process"        process id <br>    // <br>    // the buffer contains multiple null terminated strings and then <br>    // finally null terminated at the end.  the strings are in pairs of <br>    // counter number and counter name. <br>    // <br> <br>    p = buf; <br>    while (*p) { <br>        if (_stricmp(p, PROCESS_COUNTER) == 0) { <br>            // <br>            // look backwards for the counter number <br>            // <br>            for( p2=p-2; isdigit(*p2); p2--) ; <br>            strcpy( szSubKey, p2+1 ); <br>        } <br>        else <br>        if (_stricmp(p, PROCESSID_COUNTER) == 0) { <br>            // <br>            // look backwards for the counter number <br>            // <br>            for( p2=p-2; isdigit(*p2); p2--) ; <br>            dwProcessIdTitle = atol( p2+1 ); <br>        } <br>        // <br>        // next string <br>        // <br>        p += (strlen(p) + 1); <br>    } <br> <br>    // <br>    // free the counter names buffer <br>    // <br>    free( buf ); <br> <br> <br>    // <br>    // allocate the initial buffer for the performance data <br>    // <br>    dwSize = INITIAL_SIZE; <br>    buf = malloc( dwSize ); <br>    if (buf == NULL) { <br>        goto exit; <br>    } <br>    memset( buf, 0, dwSize ); <br> <br> <br>    while (TRUE) { <br> <br>        rc = RegQueryValueEx( HKEY_PERFORMANCE_DATA, <br>                              szSubKey, <br>                              NULL, <br>                              &amp;dwType, <br>                              buf, <br>                              &amp;dwSize <br>                            ); <br> <br>        pPerf = (PPERF_DATA_BLOCK) buf; <br> <br>        // <br>        // check for success and valid perf data block signature <br>        // <br>        if ((rc == ERROR_SUCCESS) &amp;&amp; <br>            (dwSize &gt; 0) &amp;&amp; <br>            (pPerf)-&gt;Signature[0] == (WCHAR)'P' &amp;&amp; <br>            (pPerf)-&gt;Signature[1] == (WCHAR)'E' &amp;&amp; <br>            (pPerf)-&gt;Signature[2] == (WCHAR)'R' &amp;&amp; <br>            (pPerf)-&gt;Signature[3] == (WCHAR)'F' ) { <br>            break; <br>        } <br> <br>        // <br>        // if buffer is not big enough, reallocate and try again <br>        // <br>        if (rc == ERROR_MORE_DATA) { <br>            dwSize += EXTEND_SIZE; <br>            buf = realloc( buf, dwSize ); <br>            memset( buf, 0, dwSize ); <br>        } <br>        else { <br>            goto exit; <br>        } <br>    } <br> <br>    // <br>    // set the perf_object_type pointer <br>    // <br>    pObj = (PPERF_OBJECT_TYPE) ((DWORD)pPerf + pPerf-&gt;HeaderLength); <br> <br>    // <br>    // loop thru the performance counter definition records looking <br>    // for the process id counter and then save its offset <br>    // <br>    pCounterDef = (PPERF_COUNTER_DEFINITION) ((DWORD)pObj + pObj-&gt;HeaderLength); <br>    for (i=0; i&lt;(DWORD)pObj-&gt;NumCounters; i++) { <br>        if (pCounterDef-&gt;CounterNameTitleIndex == dwProcessIdTitle) { <br>            dwProcessIdCounter = pCounterDef-&gt;CounterOffset; <br>            break; <br>        } <br>        pCounterDef++; <br>    } <br> <br>    // <br>    // allocate a buffer for the returned task list <br>    // <br>    dwSize = pObj-&gt;NumInstances * sizeof(TASK_LIST); <br>    pTask = pTaskReturn = (PTASK_LIST) malloc( dwSize ); <br>    if (pTask == NULL) { <br>        goto exit; <br>    } <br>    memset( pTask, 0, dwSize); <br> <br>    // <br>    // loop thru the performance instance data extracting each process name <br>    // and process id <br>    // <br>    *pNumTasks = pObj-&gt;NumInstances; <br>    pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD)pObj + pObj-&gt;DefinitionLength); <br>    for (i=0; i&lt;(DWORD)pObj-&gt;NumInstances; i++) { <br>        // <br>        // pointer to the process name <br>        // <br>        p = (LPSTR) ((DWORD)pInst + pInst-&gt;NameOffset); <br> <br>        // <br>        // convert it to ascii <br>        // <br>        rc = WideCharToMultiByte( CP_ACP, <br>                                  0, <br>                                  (LPCWSTR)p, <br>                                  -1, <br>                                  szProcessName, <br>                                  sizeof(szProcessName), <br>                                  NULL, <br>                                  NULL <br>                                ); <br> <br>        if (!rc) { <br>            // <br>            // if we cant convert the string then use a bogus value <br>            // <br>            strcpy( pTask-&gt;ProcessName, UNKNOWN_TASK ); <br>        } <br> <br>        if (strlen(szProcessName)+4 &lt;= sizeof(pTask-&gt;ProcessName)) { <br>            strcpy( pTask-&gt;ProcessName, szProcessName ); <br>            strcat( pTask-&gt;ProcessName, ".exe" ); <br>        } <br> <br>        // <br>        // get the process id <br>        // <br>        pCounter = (PPERF_COUNTER_BLOCK) ((DWORD)pInst + pInst-&gt;ByteLength); <br>        pTask-&gt;dwProcessId = *((LPDWORD) ((DWORD)pCounter + dwProcessIdCounter)); <br> <br>        // <br>        // next process <br>        // <br>        pTask++; <br>        pInst = (PPERF_INSTANCE_DEFINITION) ((DWORD)pCounter + pCounter-&gt;ByteLength); <br>    } <br> <br>exit: <br>    if (buf) { <br>        free( buf ); <br>    } <br> <br>    RegCloseKey( hKeyNames ); <br> <br>    return pTaskReturn; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
