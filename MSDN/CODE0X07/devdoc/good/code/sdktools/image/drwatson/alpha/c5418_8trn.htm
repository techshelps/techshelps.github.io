<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REGS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5423"></a>REGS.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    regs.c <br> <br>Abstract: <br> <br>    This file provides access to the machine's register set. <br> <br>Author: <br> <br>    Miche Baker-Harvey (v-michbh) 1-May-1993  (ported from ntsd) <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br> <br>/* <br>// <br>// This line keeps alpha pseudo ops from being defined in kxalpha.h <br>#ifdef ALPHA <br>#define HEADER_FILE <br>#endif <br>*/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "drwatson.h" <br>#include "proto.h" <br>#include "regs.h" <br> <br>#include &lt;alphaops.h&gt; <br>#include "strings.h" <br> <br>// we want the definitions of PSR_MODE, etc, which <br>// are derived in genalpha.c by Joe for ksalpha.h. <br>// They don't exist as separate defines anywhere else. <br>// However, if we include ksalpha.h, we get bunches <br>// of duplicate definitions.  So for now (hack,hack), <br>// just make a local copy of the definitions. <br>// MBH TODO bugbug - ksalpha.h hack <br>// #include &lt;ksalpha.h&gt; <br> <br>#define PSR_USER_MODE 0x1 <br> <br>#define PSR_MODE 0x0                    // Mode bit in PSR (bit 0) <br>#define PSR_MODE_MASK 0x1               // Mask (1 bit) for mode in PSR <br>#define PSR_IE 0x1                      // Interrupt Enable bit in PSR (bit 1) <br>#define PSR_IE_MASK 0x1                 // Mask (1 bit) for IE in PSR <br>#define PSR_IRQL 0x2                    // IRQL in PSR (bit 2) <br>#define PSR_IRQL_MASK 0x7               // Mask (2 bits) for IRQL in PSR <br> <br> <br>CONTEXT SavedRegisterContext; <br> <br>extern  ULONG   EXPRLastExpression;     // from module ntexpr.c <br>extern  ULONG   EXPRLastDump;           // from module ntcmd.c <br>extern  int     fControlC; <br> <br>PUCHAR  UserRegs[10] = {0}; <br> <br> <br>ULONG   GetIntRegNumber(ULONG); <br>BOOLEAN UserRegTest(ULONG); <br>BOOLEAN NeedUpper(DWORDLONG); <br> <br>void    GetFloatingPointRegValue(PDEBUGPACKET, ULONG , PCONVERTED_DOUBLE); <br>PUCHAR  RegNameFromIndex(ULONG); <br>ULONG   GetRegString(PUCHAR); <br> <br> <br> <br>// <br>// This is the length of an instruction, and the instruction <br>// to be used in setting a breakpoint (common code writes the <br>// breakpoint instruction into the memory stream. <br>// <br>ULONG   cbBrkptLength = 4; <br>// these are defined in alphaops.h <br>ULONG   trapInstr = CALLPAL_OP | BPT_FUNC ; <br>ULONG   breakInstrs[] = {CALLPAL_OP | BPT_FUNC, <br>                         CALLPAL_OP | KBPT_FUNC, <br>                         CALLPAL_OP | CALLKD_FUNC}; <br> <br>ULONG   ContextType = CONTEXT_FULL; <br> <br>#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK &gt;&gt; Register) &amp; 1L) <br>#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK &gt;&gt; Register) &amp; 1L) <br> <br> <br>// <br>// Define saved register masks. <br> <br>#define SAVED_FLOATING_MASK 0xfff00000  // saved floating registers <br>#define SAVED_INTEGER_MASK 0xf3ffff02   // saved integer registers <br> <br> <br>// <br>// Instruction opcode values are defined in alphaops.h <br>// <br> <br>// <br>// Define stack register and zero register numbers. <br>// <br> <br>#define RA 0x1a                         // integer register 26 <br>#define SP 0x1e                         // integer register 30 <br>#define ZERO 0x1f                        // integer register 31 <br> <br>// <br>// Some Alpha specific register names <br>// <br> <br>#define FP 0x0f                         // integer register 15 <br>#define GP 0x1d                         // integer register 29 <br> <br> <br>// <br>// This parallels ntreg.h <br>// <br> <br>PUCHAR  pszReg[] = { <br>    szF0,  szF1,  szF2,  szF3,  szF4,  szF5,  szF6,  szF7, <br>    szF8,  szF9,  szF10, szF11, szF12, szF13, szF14, szF15, <br>    szF16, szF17, szF18, szF19, szF20, szF21, szF22, szF23, <br>    szF24, szF25, szF26, szF27, szF28, szF29, szF30, szF31, <br> <br>    szR0,  szR1,  szR2,  szR3,  szR4,  szR5,  szR6,  szR7, <br>    szR8,  szR9,  szR10, szR11, szR12, szR13, szR14, szR15, <br>    szR16, szR17, szR18, szR19, szR20, szR21, szR22, szR23, <br>    szR24, szR25, szR26, szR27, szR28, szR29, szR30, szR31, <br> <br>    szFpcr, szSoftFpcr, szFir, szPsr, //szIE, <br> <br>    szFlagMode, szFlagIe, szFlagIrql, <br>// <br>// Currently assuming this is right since shadows alpha.h; <br>// but know that alpha.h flag's are wrong. <br>// <br>    szEaPReg, szExpPReg, szRaPReg, szGPReg,             //  psuedo-registers <br>    szU0Preg, szU1Preg,  szU2Preg, szU3Preg, szU4Preg, <br>    szU5Preg, szU6Preg,  szU7Preg, szU8Preg, szU9Preg <br>    }; <br> <br>#define REGNAMESIZE     sizeof(pszReg) / sizeof(PUCHAR) <br> <br>// <br>// from ntsdp.h: ULONG RegIndex, Shift, Mask; <br>// PSR &amp; IE definitions are from ksalpha.h <br>// which is generated automatically. <br>// Steal from \\bbox2\alphado\nt\public\sdk\inc\ksalpha.h <br>// NB: our masks are already shifted: <br>// <br>struct Reg { <br>        char    *psz; <br>        ULONG   value; <br>        }; <br> <br>struct SubReg { <br>        ULONG   regindex; <br>        ULONG   shift; <br>        ULONG   mask; <br>        }; <br> <br>struct SubReg subregname[] = { <br>    { REGPSR,   PSR_MODE,  PSR_MODE_MASK }, <br>    { REGPSR,   PSR_IE,    PSR_IE_MASK   }, <br>    { REGPSR,   PSR_IRQL,  PSR_IRQL_MASK }, <br>    }; <br> <br> <br>/*** UserRegTest - test if index is a user-defined register <br>* <br>*   Purpose: <br>*       Test if register is user-defined for upper routines. <br>* <br>*   Input: <br>*       index - index of register <br>* <br>*   Returns: <br>*       TRUE if user-defined register, else FALSE <br>* <br>*************************************************************************/ <br> <br>BOOLEAN UserRegTest (ULONG index) <br>{ <br>    return (BOOLEAN)(index &gt;= PREGU0 &amp;&amp; index &lt;= PREGU12); <br>} <br> <br> <br> <br>/*** GetRegFlagValue - get register or flag value <br>* <br>*   Purpose: <br>*       Return the value of the specified register or flag. <br>*       This routine calls GetRegValue to get the register <br>*       value and shifts and masks appropriately to extract a <br>*       flag value. <br>* <br>*   Input: <br>*       regnum - register or flag specification <br>* <br>*   Returns: <br>*       Value of register or flag. <br> <br>*************************************************************************/ <br> <br>DWORDLONG <br>GetRegFlagValue ( <br>    PDEBUGPACKET dp, <br>    ULONG regnum <br>    ) <br>{ <br>    DWORDLONG value; <br> <br>    if (regnum &lt; FLAGBASE || regnum &gt;= PREGBASE) { <br>        value = GetRegValue(dp, regnum); <br>    }else { <br>        regnum -= FLAGBASE; <br>        value = GetRegValue(dp, subregname[regnum].regindex); <br>        value = (value &gt;&gt; subregname[regnum].shift) &amp; subregname[regnum].mask; <br>    } <br>    return value; <br>} <br> <br>BOOLEAN <br>NeedUpper( <br>    DWORDLONG value <br>    ) <br>{ <br>    // <br>    // if the high bit of the low part is set, then the <br>    // high part must be all ones, else it must be zero. <br>    // <br> <br>    return ( ((value &amp; 0xffffffff80000000L) != 0xffffffff80000000L) &amp;&amp; <br>         (((value &amp; 0x80000000L) != 0) || ((value &amp; 0xffffffff00000000L) != 0)) ); <br>} <br> <br> <br>/*** GetRegValue - get register value <br>* <br>*   Purpose: <br>*       Returns the value of the register from the processor <br>*       context structure. <br>* <br>*   Input: <br>*       regnum - register specification <br>* <br>*   Returns: <br>*       value of the register from the context structure <br>* <br>*************************************************************************/ <br> <br>DWORDLONG <br>GetRegValue ( <br>    PDEBUGPACKET dp, <br>    ULONG regnum <br>    ) <br>{ <br>    return *(&amp;dp-&gt;tctx-&gt;context.FltF0 + regnum); <br>} <br> <br>void <br>GetFloatingPointRegValue( <br>    PDEBUGPACKET dp, <br>    ULONG regnum, <br>    PCONVERTED_DOUBLE dv <br>    ) <br>{ <br>    dv-&gt;li.LowPart  = (DWORD)(*(&amp;dp-&gt;tctx-&gt;context.FltF0 + regnum) &amp; 0xffffffff); <br>    dv-&gt;li.HighPart = (DWORD)(*(&amp;dp-&gt;tctx-&gt;context.FltF0 + regnum) &gt;&gt; 32); <br> <br>} <br> <br>/*** GetIntRegNumber - Get a register number <br>* <br>* <br>*   Purpose: <br>*       Get a register number, from an index value. <br>*       There are places where we want integers to be <br>*       numbered from 0-31, and this converts into <br>*       a CONTEXT structure. <br>* <br>*   Input: <br>*       index: integer register number, between 0 and 31 <br>* <br>*   Output: <br>*       regnum: offset into the CONTEXT structure <br>* <br>*   Exceptions: <br>*       None <br>* <br>*   Notes: <br>*       This is dependent on the CONTEXT structure <br>* <br>******************************************************************/ <br> <br>ULONG GetIntRegNumber (ULONG index) <br>{ <br>/* <br>        if (index == 26) { <br>                return(REGRA); <br>        } <br> <br>        if (index &lt; 26) { <br>                return(REGBASE + index); <br>        } <br>        if (index &gt; 26) { <br>                return(REGBASE + index - 1); <br>        } <br>*/ <br>        return(REGBASE + index); <br>} <br> <br> <br>ULONG GetRegString (PUCHAR pszString) <br>{ <br>    ULONG   count; <br> <br>    for (count = 0; count &lt; REGNAMESIZE; count++) <br>        if (!strcmp(pszString, pszReg[count])) <br>            return count; <br>    return 0xffffffff; <br>} <br> <br>void GetRegPCValue (PDEBUGPACKET dp, PDWORDLONG Address) <br>{ <br> <br>    *Address =  GetRegValue(dp, REGFIR); <br>    return; <br>} <br> <br>#if 0 <br>PULONG GetRegFPValue (PDEBUGPACKET dp) <br>{ <br>    static DWORDLONG addrFP; <br> <br>    addrFP =  GetRegValue(dp, FP_REG); <br>    return &amp;addrFP; <br>} <br>#endif <br> <br>/*** OutputAllRegs - output all registers and present instruction <br>* <br>*   Purpose: <br>*       Function of "r" command. <br>* <br>*       To output the current register state of the processor. <br>*       All integer registers are output as well as processor status <br>*       registers.  Important flag fields are also output separately. <br>*       OutDisCurrent is called to output the current instruction(s). <br>* <br>*   Input: <br>*       None. <br>* <br>*   Output: <br>*       None. <br>* <br>*************************************************************************/ <br> <br>VOID <br>OutputAllRegs( <br>    PDEBUGPACKET dp, <br>    BOOL Show64 <br>    ) <br>{ <br>    int     regindex; <br>    int     regnumber; <br>    DWORDLONG regvalue; <br> <br>    for (regindex = 0; regindex &lt; 34; regindex++) { <br> <br>        regnumber = GetIntRegNumber(regindex); <br>        regvalue = GetRegValue(dp, regnumber); <br> <br>        if ( Show64 || regindex == 32 || regindex == 33) { <br> <br>            lprintfs("%4s=%08lx %08lx", <br>                    pszReg[regnumber], <br>                    (ULONG)(regvalue &gt;&gt; 32), <br>                    (ULONG)(regvalue &amp; 0xffffffff)); <br>            if (regindex % 3 == 2) { <br>                lprintfs("\r\n"); <br>            } else { <br>                lprintfs(" "); <br>            } <br> <br>        } else { <br> <br>            lprintfs("%4s=%08lx%c", <br>                    pszReg[regnumber], <br>                    (ULONG)(regvalue &amp; 0xfffffff), <br>                    NeedUpper(regvalue) ? '*' : ' ' ); <br>            if (regindex % 5 == 4) { <br>                lprintfs("\r\n"); <br>            } else { <br>                lprintfs(" "); <br>            } <br> <br>        } <br>    } <br> <br> <br>    // <br>    // print out the fpcr as 64 bits regardless, <br>    // and the FIR and Fpcr's - assuming we know they follow <br>    // the floating and integer registers. <br>    // <br> <br>    regnumber = GetIntRegNumber(34);    // Fir <br>    lprintfs("%4s=%08lx\r\n", pszReg[regnumber], <br>                           (ULONG)GetRegValue(dp, regnumber)); <br> <br>    regnumber = GetIntRegNumber(35);    // Psr <br>    lprintfs("%4s=%08lx\r\n", pszReg[regnumber], <br>                           (ULONG)GetRegValue(dp, regnumber)); <br> <br>    lprintfs("mode=%1lx ie=%1lx irql=%1lx \r\n", <br>                (ULONG)GetRegFlagValue(dp, FLAGMODE), <br>                (ULONG)GetRegFlagValue(dp, FLAGIE), <br>                (ULONG)GetRegFlagValue(dp, FLAGIRQL)); <br>} <br> <br>/*** OutputOneReg - output one register value <br>* <br>*   Purpose: <br>*       Function for the "r &lt;regname&gt;" command. <br>* <br>*       Output the value for the specified register or flag. <br>* <br>*   Input: <br>*       regnum - register or flag specification <br>* <br>*   Output: <br>*       None. <br>* <br>*************************************************************************/ <br> <br>VOID <br>OutputOneReg ( <br>    PDEBUGPACKET dp, <br>    ULONG regnum, <br>    BOOLEAN Show64 <br>    ) <br>{ <br>    DWORDLONG value; <br> <br>    value = GetRegFlagValue(dp, regnum); <br>    if (regnum &gt;= FLAGBASE) { <br>        lprintfs("%lx\r\n", (ULONG)value); <br>    } else if (Show64) { <br>        lprintfs("%08lx %08lx\r\n", (ULONG)(value &gt;&gt; 32), (ULONG)(value &amp; 0xffffffff)); <br>    } else { <br>        lprintfs("%08lx%s\r\n", (ULONG)value, NeedUpper(value)?"*":""); <br>    } <br>} <br> <br>PUCHAR RegNameFromIndex (ULONG index) <br>{ <br>    return pszReg[index]; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
