<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISASM.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5419"></a>DISASM.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    regs.c <br> <br>Abstract: <br> <br>    This file provides disassembly  ( alpha ) <br> <br>Author: <br> <br>    Miche Baker-Harvey (v-michbh) 1-May-1993  (ported from ntsd) <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stddef.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include &lt;alphaops.h&gt; <br>#include "disasm.h" <br>#include "regs.h" <br>#include "optable.h" <br> <br>#include "drwatson.h" <br>#include "proto.h" <br> <br>void BlankFill(ULONG); <br>void OutputHex(ULONG, ULONG, BOOLEAN); <br> <br>void OutputEffectiveAddress(PDEBUGPACKET, ULONG); <br>void OutputString(char *); <br>void OutputReg(ULONG); <br>void OutputFReg(ULONG); <br>void GetNextOffset(PDEBUGPACKET, PULONG, BOOLEAN); <br>ULONG GetIntRegNumber(ULONG); <br> <br> <br>ALPHA_INSTRUCTION disinstr; <br> <br>extern PUCHAR pszReg[]; <br> <br>BOOLEAN disasm(PDEBUGPACKET, PDWORD, PUCHAR, BOOLEAN); <br> <br> <br>static char *pBufStart; <br>static char *pBuf; <br> <br> <br>#define OPRNDCOL  27            // Column for first operand <br>#define EACOL     40            // column for effective address <br>#define FPTYPECOL 40            // .. for the type of FP instruction <br> <br>  <br>BOOLEAN <br>disasm (PDEBUGPACKET dp, PDWORD poffset, PUCHAR bufptr, BOOLEAN fEAout) <br>{ <br>    static      initialized = 0; <br>    ULONG       opcode; <br>    ULONG       Ea;                     // Effective Address <br>    POPTBLENTRY pEntry; <br> <br>    if (!initialized) { <br>        opTableInit(); <br>        initialized = 1; <br>    } <br>    pBufStart = pBuf = bufptr;          // Initialize pointers to buffer that <br>                                        //  will receive the disassembly text <br>    OutputHex(*poffset, 8, FALSE);// Output Hex address of instruction <br>    *pBuf++ = ':'; <br>    *pBuf++ = ' '; <br> <br>    if (!DoMemoryRead( dp, <br>                       (LPVOID)*poffset, <br>                       (LPVOID)&amp;disinstr.Long, <br>                       sizeof(DWORD), <br>                       NULL <br>                       )) { <br>        OutputString("???????? ????"); <br>        *pBuf = '\0'; <br>        return(FALSE); <br>    } <br> <br>    OutputHex(disinstr.Long, 8, FALSE); // Output instruction in Hex <br>    *pBuf++ = ' '; <br> <br>    opcode = disinstr.Memory.Opcode;    // Select disassembly procedure from <br> <br>    pEntry = findOpCodeEntry(opcode);   // Get non-func entry for this code <br>    if (pEntry == (POPTBLENTRY)-1) { <br>        OutputString("??????? ????"); <br>        *pBuf = '\0'; <br>        return (FALSE); <br>    } <br> <br> <br>    switch (pEntry-&gt;iType) { <br>    case ALPHA_UNKNOWN: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        break; <br> <br>    case ALPHA_MEMORY: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        BlankFill(OPRNDCOL); <br>        OutputReg(disinstr.Memory.Ra); <br>        *pBuf++ = ','; <br>        OutputHex(disinstr.Memory.MemDisp, (WIDTH_MEM_DISP + 3)/4, TRUE ); <br>        *pBuf++ = '('; <br>        OutputReg(disinstr.Memory.Rb); <br>        *pBuf++ = ')'; <br> <br>        break; <br> <br>    case ALPHA_FP_MEMORY: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        BlankFill(OPRNDCOL); <br>        OutputFReg(disinstr.Memory.Ra); <br>        *pBuf++ = ','; <br>        OutputHex(disinstr.Memory.MemDisp, (WIDTH_MEM_DISP + 3)/4, TRUE ); <br>        *pBuf++ = '('; <br>        OutputReg(disinstr.Memory.Rb); <br>        *pBuf++ = ')'; <br> <br>        break; <br> <br>    case ALPHA_MEMSPC: <br>        OutputString(findFuncName(pEntry, disinstr.Memory.MemDisp &amp; BITS_MEM_DISP)); <br>        // <br>        // Some memory special instructions have an operand <br>        // <br> <br>        switch (disinstr.Memory.MemDisp &amp; BITS_MEM_DISP) { <br>        case FETCH_FUNC: <br>        case FETCH_M_FUNC: <br>             // one operand, in Rb <br>             BlankFill(OPRNDCOL); <br>             *pBuf++ = '0'; <br>             *pBuf++ = '('; <br>             OutputReg(disinstr.Memory.Rb); <br>             *pBuf++ = ')'; <br>             break; <br> <br>        case RS_FUNC: <br>        case RC_FUNC: <br>        case RPCC_FUNC: <br>             // one operand, in Ra <br>             BlankFill(OPRNDCOL); <br>             OutputReg(disinstr.Memory.Ra); <br>             break; <br> <br>        case MB_FUNC: <br>        case WMB_FUNC: <br>        case MB2_FUNC: <br>        case MB3_FUNC: <br>        case TRAPB_FUNC: <br>        case EXCB_FUNC: <br>             // no operands <br>             break; <br> <br>        default: <br>             printf("we shouldn't get here \n"); <br>             break; <br>        } <br> <br>        break; <br> <br> <br>    case ALPHA_JUMP: <br>        OutputString(findFuncName(pEntry, disinstr.Jump.Function)); <br>        BlankFill(OPRNDCOL); <br>        OutputReg(disinstr.Jump.Ra); <br>        *pBuf++ = ','; <br>        *pBuf++ = '('; <br>        OutputReg(disinstr.Jump.Rb); <br>        *pBuf++ = ')'; <br>        *pBuf++ = ','; <br>        OutputHex(disinstr.Jump.Hint, (WIDTH_HINT + 3)/4, TRUE); <br> <br>        Ea = (ULONG) GetRegValue(dp, GetIntRegNumber(disinstr.Jump.Rb)) &amp; (~3); <br>        OutputEffectiveAddress(dp, Ea); <br>        break; <br> <br>    case ALPHA_BRANCH: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        BlankFill(OPRNDCOL); <br>        OutputReg(disinstr.Branch.Ra); <br>        *pBuf++ = ','; <br> <br>        // <br>        // The next line might be a call to GetNextOffset, but <br>        // GetNextOffset assumes that it should work from REGFIR. <br>        // <br> <br>        Ea = *poffset + <br>             sizeof(DWORD) + <br>             (disinstr.Branch.BranchDisp &lt;&lt; 2); <br>        OutputHex(Ea, 8, FALSE); <br>        OutputEffectiveAddress(dp, Ea); <br> <br>        break; <br> <br>    case ALPHA_FP_BRANCH: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        BlankFill(OPRNDCOL); <br>        OutputFReg(disinstr.Branch.Ra); <br>        *pBuf++ = ','; <br> <br>        // <br>        // The next line might be a call to GetNextOffset, but <br>        // GetNextOffset assumes that it should work from REGFIR. <br>        // <br> <br>        Ea = *poffset + <br>             sizeof(DWORD) + <br>             (disinstr.Branch.BranchDisp &lt;&lt; 2); <br>        OutputHex(Ea, 8, FALSE); <br>        OutputEffectiveAddress(dp, Ea); <br> <br>        break; <br> <br>    case ALPHA_OPERATE: <br>        OutputString(findFuncName(pEntry, disinstr.OpReg.Function)); <br>        BlankFill(OPRNDCOL); <br>        OutputReg(disinstr.OpReg.Ra); <br>        *pBuf++ = ','; <br>        if (disinstr.OpReg.RbvType) { <br>            *pBuf++ = '#'; <br>            OutputHex(disinstr.OpLit.Literal, (WIDTH_LIT + 3)/4, TRUE); <br>        } else <br>            OutputReg(disinstr.OpReg.Rb); <br>        *pBuf++ = ','; <br>        OutputReg(disinstr.OpReg.Rc); <br>        break; <br> <br>    case ALPHA_FP_OPERATE: <br> <br>      { <br>        ULONG Function; <br>        ULONG Flags; <br> <br>        Flags = disinstr.FpOp.Function &amp; MSK_FP_FLAGS; <br>        Function = disinstr.FpOp.Function &amp; MSK_FP_OP; <br> <br>//        if (fVerboseOutput) { <br>//           dprintf("In FP_OPERATE: Flags %08x Function %08x\n", <br>//                    Flags, Function); <br>//           dprintf("opcode %d \n", opcode); <br>//        } <br> <br>        // <br>        // CVTST and CVTST/S are different: they look like <br>        // CVTTS with some flags set <br>        // <br>        if (Function == CVTTS_FUNC) { <br>            if (disinstr.FpOp.Function == CVTST_S_FUNC) { <br>                Function = CVTST_S_FUNC; <br>                Flags = NONE_FLAGS; <br>            } <br>            if (disinstr.FpOp.Function == CVTST_FUNC) { <br>                Function = CVTST_FUNC; <br>                Flags = NONE_FLAGS; <br>            } <br>        } <br> <br>        OutputString(findFuncName(pEntry, Function)); <br> <br>        // <br>        // Append the opcode qualifier, if any, to the opcode name. <br>        // <br> <br>        if ( (opcode == IEEEFP_OP) || (opcode == VAXFP_OP) <br>                                   || (Function == CVTQL_FUNC) ) { <br>            OutputString(findFlagName(Flags, Function)); <br>        } <br> <br>        BlankFill(OPRNDCOL); <br>        // <br>        // If this is a convert instruction, only Rb and Rc are used <br>        // <br>        if (strncmp("cvt", findFuncName(pEntry, Function), 3) != 0) { <br>            OutputFReg(disinstr.FpOp.Fa); <br>            *pBuf++ = ','; <br>        } <br>        OutputFReg(disinstr.FpOp.Fb); <br>        *pBuf++ = ','; <br>        OutputFReg(disinstr.FpOp.Fc); <br> <br>        break; <br>      } <br> <br>    case ALPHA_FP_CONVERT: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        BlankFill(OPRNDCOL); <br>        OutputFReg(disinstr.FpOp.Fa); <br>        *pBuf++ = ','; <br>        OutputFReg(disinstr.FpOp.Fb); <br>        break; <br> <br>    case ALPHA_CALLPAL: <br>        OutputString(findFuncName(pEntry, disinstr.Pal.Function)); <br>        break; <br> <br>    case ALPHA_EV4_PR: <br>        if ((disinstr.Long &amp; MSK_EV4_PR) == 0) <br>                OutputString("NOP"); <br>        else { <br>            OutputString(pEntry-&gt;pszAlphaName); <br>            BlankFill(OPRNDCOL); <br>            OutputReg(disinstr.EV4_PR.Ra); <br>            *pBuf++ = ','; <br>            if(disinstr.EV4_PR.Ra != disinstr.EV4_PR.Rb) { <br>                OutputReg(disinstr.EV4_PR.Rb); <br>                *pBuf++ = ','; <br>            }; <br>            OutputString(findFuncName(pEntry, (disinstr.Long &amp; MSK_EV4_PR))); <br>        }; <br>        break; <br>    case ALPHA_EV4_MEM: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        BlankFill(OPRNDCOL); <br>        OutputReg(disinstr.EV4_MEM.Ra); <br>        *pBuf++ = ','; <br>        OutputReg(disinstr.EV4_MEM.Rb); <br>        break; <br>    case ALPHA_EV4_REI: <br>        OutputString(pEntry-&gt;pszAlphaName); <br>        break; <br>    default: <br>        OutputString("Invalid type"); <br>        break; <br>    }; <br> <br> <br>    *poffset += sizeof(ULONG); <br>    *pBuf = '\0'; <br>    return(TRUE); <br>} <br>  <br>/* BlankFill - blank-fill buffer <br>* <br>*   Purpose: <br>*       To fill the buffer at *pBuf with blanks until <br>*       position count is reached. <br>* <br>*   Input: <br>*       None. <br>* <br>*   Output: <br>*       None. <br>* <br>***********************************************************************/ <br> <br>void BlankFill(ULONG count) <br>{ <br>    do <br>        *pBuf++ = ' '; <br>    while (pBuf &lt; pBufStart + count); <br>} <br> <br>/* OutputHex - output hex value <br>* <br>*   Purpose: <br>*       Output the value in outvalue into the buffer <br>*       pointed by *pBuf.  The value may be signed <br>*       or unsigned depending on the value fSigned. <br>* <br>*   Input: <br>*       outvalue - value to output <br>*       length - length in digits <br>*       fSigned - TRUE if signed else FALSE <br>* <br>*   Output: <br>*       None. <br>* <br>***********************************************************************/ <br> <br>UCHAR HexDigit[16] = { <br>    '0', '1', '2', '3', '4', '5', '6', '7', <br>    '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' <br>    }; <br> <br>void OutputHex (ULONG outvalue, ULONG length, BOOLEAN fSigned) <br>{ <br>    UCHAR   digit[8]; <br>    LONG    index = 0; <br> <br>    if (fSigned &amp;&amp; (LONG)outvalue &lt; 0) { <br>        *pBuf++ = '-'; <br>        outvalue = - (LONG)outvalue; <br>    } <br>    do { <br>        digit[index++] = HexDigit[outvalue &amp; 0xf]; <br>        outvalue &gt;&gt;= 4; <br>    } <br> <br>    while ((fSigned &amp;&amp; outvalue) || (!fSigned &amp;&amp; index &lt; (LONG)length)) <br>        ; <br>    while (--index &gt;= 0) <br>        *pBuf++ = digit[index]; <br>} <br> <br>/* OutputString - output string <br>* <br>*   Purpose: <br>*       Copy the string into the buffer pointed by pBuf. <br>* <br>*   Input: <br>*       *pStr - pointer to string <br>* <br>*   Output: <br>*       None. <br>* <br>***********************************************************************/ <br> <br>void OutputString (char *pStr) <br>{ <br>    while (*pStr) <br>        *pBuf++ = *pStr++; <br>} <br> <br>void OutputReg (ULONG regnum) <br>{ <br>    OutputString(pszReg[GetIntRegNumber(regnum)]); <br>} <br> <br>void OutputFReg (ULONG regnum) <br>{ <br>    *pBuf++ = 'f'; <br>    if (regnum &gt; 9) <br>        *pBuf++ = (UCHAR)('0' + regnum / 10); <br>    *pBuf++ = (UCHAR)('0' + regnum % 10); <br>} <br> <br>  <br>/*** OutputEffectiveAddress - Print EA symbolically <br>* <br>*   Purpose: <br>*       Given the effective address (for a branch, jump or <br>*       memory instruction, print it symbolically, if <br>*       symbols are available. <br>* <br>*   Input: <br>*       offset - computed by the caller as <br>*               for jumps, the value in Rb <br>*               for branches, func(PC, displacement) <br>*               for memory, func(PC, displacement) <br>* <br>*   Returns: <br>*       None <br>* <br>*************************************************************************/ <br>void OutputEffectiveAddress(PDEBUGPACKET dp, ULONG offset) <br>{ <br>    ULONG   displacement; <br>    PUCHAR  pszTemp; <br>    UCHAR   ch; <br> <br> <br>    BlankFill(EACOL); <br> <br>    if (SymGetSymFromAddr( dp-&gt;hProcess, offset, &amp;displacement, sym )) { <br>        pszTemp = sym-&gt;Name; <br>        while (ch = *pszTemp++) <br>            *pBuf++ = ch; <br>        if (displacement) { <br>            *pBuf++ = '+'; <br>            OutputHex(displacement, 8, TRUE); <br>            } <br>    } <br>    else { <br>        OutputHex(offset, 8, FALSE); <br>    } <br>} <br> <br>  <br>/*** GetNextOffset - compute offset for trace or step <br>* <br>*   Purpose: <br>*       From a limited disassembly of the instruction pointed <br>*       by the FIR register, compute the offset of the next <br>*       instruction for either a trace or step operation. <br>* <br>*       trace -&gt; the next instruction to execute <br>*       step -&gt; the instruction in the next memory location or the <br>*               next instruction executed due to a branch (step over <br>*               subroutine calls). <br>* <br>*   Input: <br>*       result - where to put the next offset <br>*       fStep - TRUE for step offset; FALSE for trace offset <br>* <br>*   Returns: <br>*       step or trace offset if input is TRUE or FALSE, respectively <br>*       in result <br>* <br>*************************************************************************/ <br>/* <br>void <br>GetNextOffset (PDEBUGPACKET dp, PULONG result, BOOLEAN fStep) <br>{ <br>    ULONG   rv; <br>    ULONG   opcode; <br>    ULONG   firaddr; <br>    ULONG   updatedpc; <br>    ULONG   branchTarget; <br>    DWORD   fir; <br> <br>    // Canonical form to shorten tests; Abs is absolute value <br> <br>    LONG    Can, Abs; <br> <br>    CONVERTED_DOUBLE    Rav; <br>    CONVERTED_DOUBLE    Fav; <br>    CONVERTED_DOUBLE    Rbv; <br> <br>    // <br>    // Get current address <br>    // <br> <br>    firaddr = (ULONG) GetRegValue(dp, REGFIR); <br> <br>    // <br>    // relative addressing updates PC first <br>    // Assume next sequential instruction is next offset <br>    // <br> <br>    updatedpc = firaddr + sizeof(ULONG); <br>    rv = updatedpc; <br> <br>    DoMemoryRead( dp, <br>                  (LPVOID)firaddr, <br>                  (LPVOID)&amp;disinstr.Long, <br>                  sizeof(ULONG), <br>                  NULL <br>                  ); <br> <br>    opcode = disinstr.Memory.Opcode; <br> <br>    switch(findOpCodeEntry(opcode)-&gt;iType) { <br> <br>    case ALPHA_JUMP: <br> <br>        switch(disinstr.Jump.Function) { <br> <br>        case JSR_FUNC: <br>        case JSR_CO_FUNC: <br> <br>            if (fStep) { <br> <br>                // <br>                // Step over the subroutine call; <br>                // <br> <br>                break; <br>            } <br> <br>            // <br>            // fall through <br>            // <br> <br>        case JMP_FUNC: <br>        case RET_FUNC: <br> <br>            GetQuadRegValue(dp, GetIntRegNumber(disinstr.Jump.Rb), &amp;Rbv); <br>            rv = (Rbv.li.LowPart &amp; (~3)); <br>            break; <br> <br>        } <br> <br>        break; <br> <br>        case ALPHA_BRANCH: <br> <br>        branchTarget = (updatedpc + (disinstr.Branch.BranchDisp * 4)); <br> <br>        GetQuadRegValue(dp, GetIntRegNumber(disinstr.Branch.Ra), &amp;Rav.li); <br> <br>        // <br>        // set up a canonical value for computing the branch test <br>        // - works with ALPHA, MIPS and 386 hosts <br>        // <br> <br>        Can = Rav.li.LowPart &amp; 1; <br> <br>        if ((LONG)Rav.li.HighPart &lt; 0) { <br>            Can |= 0x80000000; <br>        } <br> <br>        if ((Rav.li.LowPart &amp; 0xfffffffe) || (Rav.li.HighPart &amp; 0x7fffffff)) { <br>            Can |= 2; <br>        } <br> <br>//        if (fVerboseOutput) { <br>//           dprintf("Rav High %08lx Low %08lx Canonical %08lx\n", <br>//                    Rav.li.HighPart, Rav.li.LowPart, Can); <br>//           dprintf("returnvalue %08lx branchTarget %08lx\n", <br>//                    rv, branchTarget); <br>//        } <br> <br>        switch(opcode) { <br>        case BR_OP:                         rv = branchTarget; break; <br>        case BSR_OP:  if (!fStep)           rv = branchTarget; break; <br>        case BEQ_OP:  if (Can == 0)         rv = branchTarget; break; <br>        case BLT_OP:  if (Can &lt;  0)         rv = branchTarget; break; <br>        case BLE_OP:  if (Can &lt;= 0)         rv = branchTarget; break; <br>        case BNE_OP:  if (Can != 0)         rv = branchTarget; break; <br>        case BGE_OP:  if (Can &gt;= 0)         rv = branchTarget; break; <br>        case BGT_OP:  if (Can &gt;  0)         rv = branchTarget; break; <br>        case BLBC_OP: if ((Can &amp; 0x1) == 0) rv = branchTarget; break; <br>        case BLBS_OP: if ((Can &amp; 0x1) == 1) rv = branchTarget; break; <br>        }; <br> <br>        break; <br> <br> <br>    case ALPHA_FP_BRANCH: <br> <br>        branchTarget = (updatedpc + (disinstr.Branch.BranchDisp * 4)); <br> <br>        GetFloatingPointRegValue(dp, disinstr.Branch.Ra, &amp;Fav); <br> <br>        // <br>        // Set up a canonical value for computing the branch test <br>        // <br> <br>        Can = Fav.li.HighPart &amp; 0x80000000; <br> <br>        // <br>        // The absolute value is needed -0 and non-zero computation <br>        // <br> <br>        Abs = Fav.li.LowPart || (Fav.li.HighPart &amp; 0x7fffffff); <br> <br>        if (Can &amp;&amp; (Abs == 0x0)) { <br> <br>            // <br>            // negative 0 should be considered as zero <br>            // <br> <br>            Can = 0x0; <br> <br>        } else { <br> <br>            Can |= Abs; <br> <br>        } <br> <br>//        if (fVerboseOutput) { <br>//           dprintf("Fav High %08lx Low %08lx Canonical %08lx Absolute %08lx\n", <br>//                    Fav.li.HighPart, Fav.li.LowPart, Can, Abs); <br>//           dprintf("returnvalue %08lx branchTarget %08lx\n", <br>//                    rv, branchTarget); <br>//        } <br> <br>        switch(opcode) { <br>        case FBEQ_OP: if (Can == 0)  rv =  branchTarget; break; <br>        case FBLT_OP: if (Can &lt;  0)  rv =  branchTarget; break; <br>        case FBNE_OP: if (Can != 0)  rv =  branchTarget; break; <br>        case FBLE_OP: if (Can &lt;= 0)  rv =  branchTarget; break; <br>        case FBGE_OP: if (Can &gt;= 0)  rv =  branchTarget; break; <br>        case FBGT_OP: if (Can &gt;  0)  rv =  branchTarget; break; <br>        }; <br> <br>        break; <br>    }; <br> <br>//    if (fVerboseOutput) { <br>//        dprintf("GetNextOffset returning %08lx\n", rv); <br>//    } <br> <br>    *result = rv; <br>} <br> <br> <br>*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
