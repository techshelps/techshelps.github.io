<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ERROR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5405"></a>ERROR.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    error.c <br> <br>Abstract: <br> <br>    This file implements the error handeling functions for the <br>    entire DRWTSN32 application.  This includes error popups, <br>    debug prints, and assertions. <br> <br>Author: <br> <br>    Wesley Witt (wesw) 1-May-1993 <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "drwatson.h" <br>#include "proto.h" <br>#include "resource.h" <br>#include "messages.h" <br> <br> <br>void <br>FatalError(char *format, ...) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is called when there is nothing else to do, hence <br>    the name FatalError.  It puts up a popup and then terminates. <br> <br>Arguments: <br> <br>    Same as printf. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    char      vbuf[1024]; <br>    char      buf[1024]; <br>    char      szErrorCode[10]; <br>    DWORD     dwCount; <br>    DWORD     dwArgs[4]; <br>    va_list   arg_ptr; <br> <br>    va_start(arg_ptr, format); <br>    _vsnprintf(vbuf, sizeof(vbuf), format, arg_ptr); <br>    wsprintf( szErrorCode, "%d", GetLastError() ); <br>    dwArgs[0] = (DWORD)vbuf; <br>    dwArgs[1] = (DWORD)szErrorCode; <br>    dwCount = FormatMessage( <br>                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY, <br>                NULL, <br>                MSG_FATAL_ERROR, <br>                0, // GetUserDefaultLangID(), <br>                buf, <br>                sizeof(buf), <br>                (va_list*)dwArgs <br>                ); <br>    Assert( dwCount != 0 ); <br>    MessageBox( NULL, <br>                buf, <br>                LoadRcString( IDS_FATAL_ERROR ), <br>                MB_SETFOREGROUND | MB_OK <br>              ); <br>    ExitProcess( 0 ); <br>} <br> <br>void <br>NonFatalError(char *format, ...) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is used to generate a popup with some kind of <br>    warning message inside. <br> <br>Arguments: <br> <br>    Same as printf. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    char      vbuf[1024]; <br>    char      buf[1024]; <br>    char      szErrorCode[10]; <br>    DWORD     dwCount; <br>    DWORD     dwArgs[4]; <br>    va_list   arg_ptr; <br> <br>    va_start(arg_ptr, format); <br>    _vsnprintf(vbuf, sizeof(vbuf), format, arg_ptr); <br>    wsprintf( szErrorCode, "%d", GetLastError() ); <br>    dwArgs[0] = (DWORD)vbuf; <br>    dwArgs[1] = (DWORD)szErrorCode; <br>    dwCount = FormatMessage( <br>                FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY, <br>                NULL, <br>                MSG_FATAL_ERROR, <br>                0, // GetUserDefaultLangID(), <br>                buf, <br>                sizeof(buf), <br>                (va_list*)dwArgs <br>                ); <br>    Assert( dwCount != 0 ); <br>    MessageBox( NULL, <br>                buf, <br>                LoadRcString( IDS_NONFATAL_ERROR ), <br>                MB_SETFOREGROUND | MB_OK <br>              ); <br>} <br> <br>void <br>dprintf(char *format, ...) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is a var-args version of OutputDebugString. <br> <br>Arguments: <br> <br>    Same as printf. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    char    buf[1024]; <br> <br>    va_list arg_ptr; <br>    va_start(arg_ptr, format); <br>    _vsnprintf(buf, sizeof(buf), format, arg_ptr); <br>    OutputDebugString( buf ); <br>    return; <br>} <br> <br>BOOL CALLBACK <br>AssertDialogProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the dialog procedure for the assert dialog box.  Normally <br>    an assertion box is simply a message box but in this case a Help <br>    button is desired so a dialog box is used. <br> <br>Arguments: <br> <br>    hDlg       - window handle to the dialog box <br>    message    - message number <br>    wParam     - first message parameter <br>    lParam     - second message parameter <br> <br>Return Value: <br> <br>    TRUE       - did not process the message <br>    FALSE      - did process the message <br> <br>--*/ <br> <br>{ <br>    char     *p; <br>    HICON    hIcon; <br>    char     szHelpFileName[MAX_PATH]; <br> <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            // <br>            // lParam comes in as a pointer to a buffer containing <br>            // 2 null terminated strings <br>            // <br> <br>            // <br>            // get the assertion text <br>            // <br>            p = (char *) lParam; <br>            SetDlgItemText( hDlg, ID_ASSERT_TEXT, p ); <br> <br>            // <br>            // get the app name and use it as the title <br>            // <br>            p += (strlen(p)+1); <br>            SetWindowText( hDlg, p ); <br> <br>            // <br>            // set the icon <br>            // <br>            hIcon = LoadIcon( NULL, IDI_HAND ); <br>            SendMessage( GetDlgItem( hDlg, ID_ASSERT_ICON ), STM_SETICON, (WPARAM) hIcon, 0 ); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (wParam) { <br>                case IDABORT: <br>                    // <br>                    // end the dialog and say why <br>                    // <br>                    EndDialog( hDlg, IDABORT ); <br>                    break; <br> <br>                case IDRETRY: <br>                    // <br>                    // end the dialog and say why <br>                    // <br>                    EndDialog( hDlg, IDRETRY ); <br>                    break; <br> <br>                case IDIGNORE: <br>                    // <br>                    // end the dialog and say why <br>                    // <br>                    EndDialog( hDlg, IDIGNORE ); <br>                    break; <br> <br>                case ID_HELP: <br>                    // <br>                    // get the help file name <br>                    // <br>                    GetHelpFileName( szHelpFileName, sizeof(szHelpFileName) ); <br> <br>                    // <br>                    // call winhelp <br>                    // <br>                    WinHelp( hDlg, szHelpFileName, HELP_FINDER, IDH_ASSERT ); <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return FALSE; <br>} <br> <br>void <br>AssertError( <br>    char   *Expression, <br>    char   *File, <br>    DWORD  LineNumber <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Display an assertion failure message box which gives the user a choice <br>    as to whether the process should be aborted, the assertion ignored or <br>    a break exception generated. <br> <br>Arguments: <br> <br>    Expression  - Supplies a string representation of the failed assertion. <br>    File        - Supplies a pointer to the file name where the assertion <br>                  failed. <br>    LineNumber  - Supplies the line number in the file where the assertion <br>                  failed. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    int        Response; <br>    char       ModuleBuffer[ MAX_PATH ]; <br>    DWORD      Length; <br>    char       Buffer[ 4096 ]; <br>    DWORD      Args[ ] = { <br>        ( DWORD ) Expression, <br>        ( DWORD ) GetLastError( ), <br>        ( DWORD ) File, <br>        ( DWORD ) LineNumber <br>    }; <br> <br>    // <br>    // Format the assertion string that describes the failure. <br>    // <br>    FormatMessage( <br>                  FORMAT_MESSAGE_ARGUMENT_ARRAY <br>                | FORMAT_MESSAGE_FROM_STRING <br>                &amp; ~FORMAT_MESSAGE_FROM_HMODULE, <br>                ( LPVOID ) "Assertion Failed : %1!s! (%2!d!)\nin file %3!hs! at line %4!d!\n", <br>                0, <br>                0, // GetUserDefaultLangID(), <br>                Buffer, <br>                sizeof( Buffer ), <br>                (va_list*)Args <br>                ); <br> <br> <br>    // <br>    // Get the asserting module's file name. <br>    // <br>    Length = GetModuleFileName( <br>                    NULL, <br>                    ModuleBuffer, <br>                    sizeof( ModuleBuffer ) <br>                    ); <br> <br>    // <br>    // put it at the end of the buffer <br>    // <br>    strcpy( &amp;Buffer[strlen(Buffer)+1], ModuleBuffer ); <br> <br>    Response = DialogBoxParam( GetModuleHandle( NULL ), <br>                            MAKEINTRESOURCE( ASSERTDIALOG ), <br>                            0, <br>                            AssertDialogProc, <br>                            (LPARAM) Buffer <br>                          ); <br> <br>    switch( Response ) { <br>        case IDABORT: <br>            // <br>            // Terminate the process. <br>            // <br>            ExitProcess( (UINT) -1 ); <br>            break; <br> <br>        case IDIGNORE: <br>            // <br>            // Ignore the failed assertion. <br>            // <br>            break; <br> <br>        case IDRETRY: <br>            // <br>            // Break into a debugger. <br>            // <br>            DebugBreak( ); <br>            break; <br> <br>        default: <br>            // <br>            // Break into a debugger because of a catastrophic failure. <br>            // <br>            DebugBreak( ); <br>            break; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
