<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DUMP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5404"></a>DUMP.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    dump.c <br> <br>Abstract: <br> <br>    This file implements the crash dump code. <br> <br>Author: <br> <br>    Wesley Witt (wesw) 27-Jan-1995 <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stddef.h&gt; <br>#include &lt;crash.h&gt; <br> <br>#include "drwatson.h" <br>#include "proto.h" <br>#include "messages.h" <br>#include "resource.h" <br> <br> <br>#define MEM_SIZE (64*1024) <br> <br> <br>// <br>// these are here only so that we can link <br>// with crashlib.  they are only referenced <br>// when reading a kernel mode crash dump <br>// <br>DWORD KiProcessors; <br>DWORD KiPcrBaseAddress; <br> <br>// <br>// private data structure use for communcating <br>// crash dump data to the callback function <br>// <br>typedef struct _CRASH_DUMP_INFO { <br>    PDEBUGPACKET                dp; <br>    EXCEPTION_DEBUG_INFO        *ExceptionInfo; <br>    DWORD                       MemoryCount; <br>    DWORD                       Address; <br>    PUCHAR                      MemoryData; <br>    MEMORY_BASIC_INFORMATION    mbi; <br>    BOOL                        MbiOffset; <br>    ULONG                       MbiRemaining; <br>    PTHREADCONTEXT              ptctx; <br>    IMAGEHLP_MODULE             mi; <br>    PCRASH_MODULE               CrashModule; <br>} CRASH_DUMP_INFO, *PCRASH_DUMP_INFO; <br> <br>LPSTR <br>ExpandPath( <br>    LPSTR lpPath <br>    ); <br> <br>DWORD <br>GetTeb( <br>    HANDLE hTread <br>    ); <br> <br>BOOL <br>CrashDumpCallback( <br>    DWORD               DataType, <br>    PVOID               *DumpData, <br>    LPDWORD             DumpDataLength, <br>    PCRASH_DUMP_INFO    CrashdumpInfo <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is the callback used by crashlib. <br>    Its purpose is to provide data to DmpCreateUserDump() <br>    for writting to the crashdump file. <br> <br>Arguments: <br> <br>    DataType        - requested data type <br>    DumpData        - pointer to a pointer to the data <br>    DumpDataLength  - pointer to the data length <br>    CrashdumpInfo   - DrWatson private data <br> <br>Return Value: <br> <br>    TRUE    - continue calling back for the requested data type <br>    FALSE   - stop calling back and go on to the next data type <br> <br>--*/ <br> <br>{ <br>    DWORD   cb; <br> <br>    switch( DataType ) { <br>        case DMP_DEBUG_EVENT: <br>            *DumpData = &amp;CrashdumpInfo-&gt;dp-&gt;DebugEvent; <br>            *DumpDataLength = sizeof(DEBUG_EVENT); <br>            break; <br> <br>        case DMP_THREAD_STATE: <br>            { <br>                static CRASH_THREAD CrashThread; <br>                PTHREADCONTEXT  ptctx; <br>                PLIST_ENTRY     ListEntry; <br> <br>                *DumpData = &amp;CrashThread; <br> <br>                if (CrashdumpInfo-&gt;ptctx == NULL) { <br>                    ListEntry = CrashdumpInfo-&gt;dp-&gt;ThreadList.Flink; <br>                } else { <br>                    ListEntry = CrashdumpInfo-&gt;ptctx-&gt;ThreadList.Flink; <br>                } <br> <br>                if (ListEntry == &amp;CrashdumpInfo-&gt;dp-&gt;ThreadList) { <br>                    CrashdumpInfo-&gt;ptctx = NULL; <br>                    return FALSE; <br>                } <br> <br>                ptctx = <br>                CrashdumpInfo-&gt;ptctx = CONTAINING_RECORD(ListEntry, THREADCONTEXT, ThreadList); <br> <br>                ZeroMemory(&amp;CrashThread, sizeof(CrashThread)); <br> <br>                CrashThread.ThreadId = ptctx-&gt;dwThreadId; <br>                CrashThread.SuspendCount = SuspendThread(ptctx-&gt;hThread); <br>                if (CrashThread.SuspendCount != (DWORD)-1) { <br>                    ResumeThread(ptctx-&gt;hThread); <br>                } <br>                CrashThread.PriorityClass = GetPriorityClass(CrashdumpInfo-&gt;dp-&gt;hProcess); <br>                CrashThread.Priority = GetThreadPriority(ptctx-&gt;hThread); <br>                CrashThread.Teb = GetTeb(ptctx-&gt;hThread); <br> <br>                *DumpDataLength = sizeof(CRASH_THREAD); <br>            } <br>            break; <br> <br>        case DMP_MEMORY_BASIC_INFORMATION: <br>            while( TRUE ) { <br>                CrashdumpInfo-&gt;Address += CrashdumpInfo-&gt;mbi.RegionSize; <br>                if (!VirtualQueryEx( <br>                        CrashdumpInfo-&gt;dp-&gt;hProcess, <br>                        (LPVOID)CrashdumpInfo-&gt;Address, <br>                        &amp;CrashdumpInfo-&gt;mbi, <br>                        sizeof(MEMORY_BASIC_INFORMATION) )) { <br>                    return FALSE; <br>                } <br>                if ((CrashdumpInfo-&gt;mbi.AllocationProtect &amp; PAGE_GUARD) || <br>                    (CrashdumpInfo-&gt;mbi.AllocationProtect &amp; PAGE_NOACCESS)) { <br>                    continue; <br>                } <br>                if ((CrashdumpInfo-&gt;mbi.State &amp; MEM_FREE) || <br>                    (CrashdumpInfo-&gt;mbi.State &amp; MEM_RESERVE)) { <br>                    continue; <br>                } <br>                break; <br>            } <br>            *DumpData = &amp;CrashdumpInfo-&gt;mbi; <br>            *DumpDataLength = sizeof(MEMORY_BASIC_INFORMATION); <br>            break; <br> <br>        case DMP_THREAD_CONTEXT: <br>            { <br>                PLIST_ENTRY     ListEntry; <br> <br>                if (CrashdumpInfo-&gt;ptctx == NULL) { <br>                    ListEntry = CrashdumpInfo-&gt;dp-&gt;ThreadList.Flink; <br>                } else { <br>                    ListEntry = CrashdumpInfo-&gt;ptctx-&gt;ThreadList.Flink; <br>                } <br> <br>                if (ListEntry == &amp;CrashdumpInfo-&gt;dp-&gt;ThreadList) { <br>                    CrashdumpInfo-&gt;ptctx = NULL; <br>                    return FALSE; <br>                } <br> <br>                CrashdumpInfo-&gt;ptctx = CONTAINING_RECORD(ListEntry, THREADCONTEXT, ThreadList); <br> <br>                *DumpData = &amp;CrashdumpInfo-&gt;ptctx-&gt;context; <br>                *DumpDataLength = sizeof(CONTEXT); <br>            } <br>            break; <br> <br>        case DMP_MODULE: <br>            if (CrashdumpInfo-&gt;mi.BaseOfImage == 0) { <br>                return FALSE; <br>            } <br>            CrashdumpInfo-&gt;CrashModule-&gt;BaseOfImage = CrashdumpInfo-&gt;mi.BaseOfImage; <br>            CrashdumpInfo-&gt;CrashModule-&gt;SizeOfImage = CrashdumpInfo-&gt;mi.ImageSize; <br>            CrashdumpInfo-&gt;CrashModule-&gt;ImageNameLength = strlen(CrashdumpInfo-&gt;mi.ImageName) + 1; <br>            strcpy( CrashdumpInfo-&gt;CrashModule-&gt;ImageName, CrashdumpInfo-&gt;mi.ImageName ); <br>            *DumpData = CrashdumpInfo-&gt;CrashModule; <br>            *DumpDataLength = sizeof(CRASH_MODULE) + CrashdumpInfo-&gt;CrashModule-&gt;ImageNameLength; <br>            if (!SymGetModuleInfo( CrashdumpInfo-&gt;dp-&gt;hProcess, (DWORD)-1, &amp;CrashdumpInfo-&gt;mi )) { <br>                CrashdumpInfo-&gt;mi.BaseOfImage = 0; <br>            } <br>            break; <br> <br>        case DMP_MEMORY_DATA: <br>            if (!CrashdumpInfo-&gt;MemoryCount) { <br>                CrashdumpInfo-&gt;Address = 0; <br>                CrashdumpInfo-&gt;MbiOffset = 0; <br>                CrashdumpInfo-&gt;MbiRemaining = 0; <br>                ZeroMemory( &amp;CrashdumpInfo-&gt;mbi, sizeof(MEMORY_BASIC_INFORMATION) ); <br>                CrashdumpInfo-&gt;MemoryData = VirtualAlloc( <br>                    NULL, <br>                    MEM_SIZE, <br>                    MEM_COMMIT, <br>                    PAGE_READWRITE <br>                    ); <br>            } <br>            if (!CrashdumpInfo-&gt;MbiRemaining) { <br>                while( TRUE ) { <br>                    CrashdumpInfo-&gt;Address += CrashdumpInfo-&gt;mbi.RegionSize; <br>                    if (!VirtualQueryEx( <br>                            CrashdumpInfo-&gt;dp-&gt;hProcess, <br>                            (LPVOID)CrashdumpInfo-&gt;Address, <br>                            &amp;CrashdumpInfo-&gt;mbi, <br>                            sizeof(MEMORY_BASIC_INFORMATION) )) { <br>                        if (CrashdumpInfo-&gt;MemoryData) { <br>                            VirtualFree( CrashdumpInfo-&gt;MemoryData, MEM_SIZE, MEM_RELEASE ); <br>                        } <br>                        return FALSE; <br>                    } <br>                    if ((CrashdumpInfo-&gt;mbi.Protect &amp; PAGE_GUARD) || <br>                        (CrashdumpInfo-&gt;mbi.Protect &amp; PAGE_NOACCESS)) { <br>                        continue; <br>                    } <br>                    if ((CrashdumpInfo-&gt;mbi.State &amp; MEM_FREE) || <br>                        (CrashdumpInfo-&gt;mbi.State &amp; MEM_RESERVE)) { <br>                        continue; <br>                    } <br>                    CrashdumpInfo-&gt;MbiOffset = 0; <br>                    CrashdumpInfo-&gt;MbiRemaining = CrashdumpInfo-&gt;mbi.RegionSize; <br>                    CrashdumpInfo-&gt;MemoryCount += 1; <br>                    break; <br>                } <br>            } <br>            *DumpDataLength = min( CrashdumpInfo-&gt;MbiRemaining, MEM_SIZE ); <br>            CrashdumpInfo-&gt;MbiRemaining -= *DumpDataLength; <br>            ReadProcessMemory( <br>                CrashdumpInfo-&gt;dp-&gt;hProcess, <br>                (PUCHAR)((ULONG)CrashdumpInfo-&gt;mbi.BaseAddress + (ULONG)CrashdumpInfo-&gt;MbiOffset), <br>                CrashdumpInfo-&gt;MemoryData, <br>                *DumpDataLength, <br>                &amp;cb <br>                ); <br>            *DumpData = CrashdumpInfo-&gt;MemoryData; <br>            CrashdumpInfo-&gt;MbiOffset += *DumpDataLength; <br>            break; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL <br>CreateDumpFile( <br>    PDEBUGPACKET            dp, <br>    LPEXCEPTION_DEBUG_INFO  ed <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function creates a crash dump file. <br> <br>Arguments: <br> <br>    dp              - debug packet for current process <br> <br>    ed              - exception data <br> <br>Return Value: <br> <br>    TRUE    - Crash dump was created <br>    FALSE   - Crash dump was NOT created <br> <br>--*/ <br> <br>{ <br>    CRASH_DUMP_INFO     CrashdumpInfo; <br>    LPSTR               p; <br> <br> <br>    ZeroMemory( &amp;CrashdumpInfo, sizeof(CRASH_DUMP_INFO) ); <br> <br>    CrashdumpInfo.dp = dp; <br>    CrashdumpInfo.ExceptionInfo = ed; <br>    CrashdumpInfo.ptctx = NULL; <br>    // <br>    // Get first entry in module list <br>    // <br>    SymGetModuleInfo( dp-&gt;hProcess, (DWORD)0, &amp;CrashdumpInfo.mi ); <br>    CrashdumpInfo.CrashModule = LocalAlloc( LPTR, 4096 ); <br> <br>    p = ExpandPath( dp-&gt;options.szCrashDump ); <br>    if (!p) { <br>        return FALSE; <br>    } <br> <br>    DmpCreateUserDump( p, CrashDumpCallback, &amp;CrashdumpInfo ); <br> <br>    free( p ); <br> <br>    LocalFree( CrashdumpInfo.CrashModule ); <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
