<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISASM.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5427"></a>DISASM.C</h2>
<pre><code>/*++ <br> <br>Copyright 1993 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    disasm.c <br> <br>Abstract: <br> <br>    This file provides support disassembly ( x86 ). <br> <br>Author: <br> <br>    Gerd Immeyer       19-Oct-1989 <br>    Wesley Witt (wesw) 1-May-1993    ( ported from ntsd to drwatson) <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stddef.h&gt; <br>#include &lt;string.h&gt; <br>#include "regs.h" <br>#include "disasm.h" <br>#include "drwatson.h" <br>#include "proto.h" <br> <br>/*****                     macros and defines                          *****/ <br> <br>#define BIT20(b) (b &amp; 0x07) <br>#define BIT53(b) (b &gt;&gt; 3 &amp; 0x07) <br>#define BIT76(b) (b &gt;&gt; 6 &amp; 0x03) <br>#define MAXL     16 <br>#define MAXOPLEN 10 <br> <br>#define OBOFFSET 26 <br>#define OBOPERAND 34 <br>#define OBLINEEND 77 <br> <br>/*****                     static tables and variables                 *****/ <br> <br>static char regtab[] = "alcldlblahchdhbhaxcxdxbxspbpsidi";  /* reg table */ <br>static char *mrmtb16[] = { "bx+si",  /* modRM string table (16-bit) */ <br>                           "bx+di", <br>                           "bp+si", <br>                           "bp+di", <br>                           "si", <br>                           "di", <br>                           "bp", <br>                           "bx" <br>                         }; <br> <br>static char *mrmtb32[] = { "eax",       /* modRM string table (32-bit) */ <br>                           "ecx", <br>                           "edx", <br>                           "ebx", <br>                           "esp", <br>                           "ebp", <br>                           "esi", <br>                           "edi" <br>                         }; <br> <br>static char seg16[8]   = { REGDS,  REGDS,  REGSS,  REGSS, <br>                           REGDS,  REGDS,  REGSS,  REGDS }; <br>static char reg16[8]   = { REGEBX, REGEBX, REGEBP, REGEBP, <br>                           REGESI, REGEDI, REGEBP, REGEBX }; <br>static char reg16_2[4] = { REGESI, REGEDI, REGESI, REGEDI }; <br> <br>static char seg32[8]   = { REGDS,  REGDS,  REGDS,  REGDS, <br>                           REGSS,  REGSS,  REGDS,  REGDS }; <br>static char reg32[8]   = { REGEAX, REGECX, REGEDX, REGEBX, <br>                           REGESP, REGEBP, REGESI, REGEDI }; <br> <br>static char sregtab[] = "ecsdfg";  // first letter of ES, CS, SS, DS, FS, GS <br> <br>char    hexdigit[] = { '0', '1', '2', '3', '4', '5', '6', '7', <br>                       '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' }; <br> <br>static int              mod;            /* mod of mod/rm byte */ <br>static int              rm;             /* rm of mod/rm byte */ <br>static int              ttt;            /* return reg value (of mod/rm) */ <br>static unsigned char    *pMem;          /* current position in instruction */ <br>static int              mode_32;        /* local addressing mode indicator */ <br>static int              opsize_32;      /* operand size flag */ <br> <br>ULONG                   EAaddr[2];      //  offset of effective address <br>static int              EAsize[2];      //  size of effective address item <br>static char             *pchEAseg[2];   //  normal segment for operand <br> <br>int                     G_mode_32 = 1;  /* global address mode indicator */ <br> <br>static BOOLEAN          fMovX;          // indicates a MOVSX or MOVZX <br> <br>//      internal function definitions <br> <br>BOOLEAN disasm(PDEBUGPACKET, PULONG, PUCHAR, BOOLEAN); <br>void DIdoModrm(PDEBUGPACKET dp,char **, int, BOOLEAN); <br> <br>void OutputHexString(char **, char *, int); <br>void OutputHexValue(char **, char *, int, int); <br>void OutputHexCode(char **, char *, int); <br>void OutputString(char **, char *); <br>void OutputSymbol(PDEBUGPACKET, char **, char *, int, int); <br> <br>void GetNextOffset(PDEBUGPACKET, PULONG, BOOLEAN); <br>void OutputHexAddr(PUCHAR *, ULONG); <br>USHORT GetSegRegValue(PDEBUGPACKET,int); <br> <br>/**** disasm - disassemble an 80x86/80x87 instruction <br>* <br>*  Input: <br>*       pOffset = pointer to offset to start disassembly <br>*       fEAout = if set, include EA (effective address) <br>* <br>*  Output: <br>*       pOffset = pointer to offset of next instruction <br>*       pchDst = pointer to result string <br>* <br>***************************************************************************/ <br> <br>BOOLEAN <br>disasm( PDEBUGPACKET dp, PULONG pOffset, PUCHAR pchDst, BOOLEAN fEAout ) <br>{ <br>    int     opcode;                     /* current opcode */ <br>    int     olen = 2;                   /* operand length */ <br>    int     alen = 2;                   /* address length */ <br>    int     end = FALSE;                /* end of instruction flag */ <br>    int     mrm = FALSE;                /* indicator that modrm is generated*/ <br>    unsigned char *action;              /* action for operand interpretation*/ <br>    long    tmp;                        /* temporary storage field */ <br>    int     indx;                       /* temporary index */ <br>    int     action2;                    /* secondary action */ <br>    int     instlen;                    /* instruction length */ <br>    int     cBytes;                     //  bytes read into instr buffer <br>    int     segOvr = 0;                 /* segment override opcode */ <br>    char    membuf[MAXL];               /* current instruction buffer */ <br>    char    *pEAlabel = "";             //  optional label for operand <br> <br>    char    *pchResultBuf = pchDst;     //  working copy of pchDst pointer <br>    char    RepPrefixBuffer[32];        //  rep prefix buffer <br>    char    *pchRepPrefixBuf = RepPrefixBuffer; //  pointer to prefix buffer <br>    char    OpcodeBuffer[8];            //  opcode buffer <br>    char    *pchOpcodeBuf = OpcodeBuffer; //  pointer to opcode buffer <br>    char    OperandBuffer[80];          //  operand buffer <br>    char    *pchOperandBuf = OperandBuffer; //  pointer to operand buffer <br>    char    ModrmBuffer[80];            //  modRM buffer <br>    char    *pchModrmBuf = ModrmBuffer; //  pointer to modRM buffer <br>    char    EABuffer[42];               //  effective address buffer <br>    char    *pchEABuf = EABuffer;       //  pointer to EA buffer <br> <br>    int     obOpcode = OBOFFSET; <br>    int     obOpcodeMin; <br>    int     obOpcodeMax; <br> <br>    int     obOperand = OBOPERAND; <br>    int     obOperandMin; <br>    int     obOperandMax; <br> <br>    int     cbOpcode; <br>    int     cbOperand; <br>    int     cbOffset; <br>    int     cbEAddr; <br> <br>    int     fTwoLines = FALSE; <br> <br>    fMovX = FALSE; <br>    EAsize[0] = EAsize[1] = 0;          //  no effective address <br>    pchEAseg[0] = dszDS_; <br>    pchEAseg[1] = dszES_; <br> <br>    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */ <br>    olen = alen = (1 + mode_32) &lt;&lt; 1;   //  set operand/address lengths <br>                                        //  2 for 16-bit and 4 for 32-bit <br> <br>    OutputHexAddr(&amp;pchResultBuf, *pOffset); <br> <br>    *pchResultBuf++ = ' '; <br> <br>    DoMemoryRead( dp, <br>                  (LPVOID)*pOffset, <br>                  (LPVOID)membuf, <br>                  MAXL, <br>                  &amp;cBytes <br>                ); <br> <br>                                        /* move full inst to local buffer */ <br>    pMem = membuf;                      /* point to begin of instruction */ <br>    opcode = *pMem++;                   /* get opcode */ <br>    OutputString(&amp;pchOpcodeBuf, distbl[opcode].instruct); <br>    action = actiontbl + distbl[opcode].opr; /* get operand action */ <br> <br>/*****          loop through all operand actions               *****/ <br> <br>    do { <br>        action2 = (*action) &amp; 0xc0; <br>        switch((*action++) &amp; 0x3f) { <br>            case ALT:                   /* alter the opcode if 32-bit */ <br>                if (opsize_32) { <br>                    indx = *action++; <br>                    pchOpcodeBuf = &amp;OpcodeBuffer[indx]; <br>                    if (indx == 0) <br>                        OutputString(&amp;pchOpcodeBuf, dszCWDE); <br>                    else { <br>                        *pchOpcodeBuf++ = 'd'; <br>                        if (indx == 1) <br>                            *pchOpcodeBuf++ = 'q'; <br>                        } <br>                    } <br>                break; <br> <br>            case STROP: <br>                //  compute size of operands in indx <br>                //  also if dword operands, change fifth <br>                //  opcode letter from 'w' to 'd'. <br> <br>                if (opcode &amp; 1) { <br>                    if (opsize_32) { <br>                        indx = 4; <br>                        OpcodeBuffer[4] = 'd'; <br>                        } <br>                    else <br>                        indx = 2; <br>                    } <br>                else <br>                    indx = 1; <br> <br>                if (*action &amp; 1) { <br>                    if (fEAout) { <br>                        EAaddr[0] = (DWORD)GetRegValue(dp, REGESI); <br>                        EAsize[0] = indx; <br>                        } <br>                    } <br>                if (*action++ &amp; 2) { <br>                    if (fEAout) { <br>                        EAaddr[1] = (DWORD)GetRegValue(dp, REGEDI); <br>                        EAsize[1] = indx; <br>                        } <br>                    } <br>                break; <br> <br>            case CHR:                   /* insert a character */ <br>                *pchOperandBuf++ = *action++; <br>                break; <br> <br>            case CREG:                  /* set debug, test or control reg */ <br>                if ((opcode - 231) &amp; 0x04)      //  remove bias from opcode <br>                    *pchOperandBuf++ = 't'; <br>                else if ((opcode - 231) &amp; 0x01) <br>                    *pchOperandBuf++ = 'd'; <br>                else <br>                    *pchOperandBuf++ = 'c'; <br>                *pchOperandBuf++ = 'r'; <br>                *pchOperandBuf++ = (char)('0' + ttt); <br>                break; <br> <br>            case SREG2:                 /* segment register */ <br>                ttt = BIT53(opcode);    //  set value to fall through <br> <br>            case SREG3:                 /* segment register */ <br>                *pchOperandBuf++ = sregtab[ttt];  // reg is part of modrm <br>                *pchOperandBuf++ = 's'; <br>                break; <br> <br>            case BRSTR:                 /* get index to register string */ <br>                ttt = *action++;        /*    from action table */ <br>                goto BREGlabel; <br> <br>            case BOREG:                 /* byte register (in opcode) */ <br>                ttt = BIT20(opcode);    /* register is part of opcode */ <br>                goto BREGlabel; <br> <br>            case ALSTR: <br>                ttt = 0;                /* point to AL register */ <br>BREGlabel: <br>            case BREG:                  /* general register */ <br>                *pchOperandBuf++ = regtab[ttt * 2]; <br>                *pchOperandBuf++ = regtab[ttt * 2 + 1]; <br>                break; <br> <br>            case WRSTR:                 /* get index to register string */ <br>                ttt = *action++;        /*    from action table */ <br>                goto WREGlabel; <br> <br>            case VOREG:                 /* register is part of opcode */ <br>                ttt = BIT20(opcode); <br>                goto VREGlabel; <br> <br>            case AXSTR: <br>                ttt = 0;                /* point to eAX register */ <br>VREGlabel: <br>            case VREG:                  /* general register */ <br>                if (opsize_32)          /* test for 32bit mode */ <br>                    *pchOperandBuf++ = 'e'; <br>WREGlabel: <br>            case WREG:                  /* register is word size */ <br>                *pchOperandBuf++ = regtab[ttt * 2 + 16]; <br>                *pchOperandBuf++ = regtab[ttt * 2 + 17]; <br>                break; <br> <br>            case IST_ST: <br>                OutputString(&amp;pchOperandBuf, "st(0),st"); <br>                *(pchOperandBuf - 5) += rm; <br>                break; <br> <br>            case ST_IST: <br>                OutputString(&amp;pchOperandBuf, "st,"); <br>            case IST: <br>                OutputString(&amp;pchOperandBuf, "st(0)"); <br>                *(pchOperandBuf - 2) += rm; <br>                break; <br> <br>            case xBYTE:                 /* set instruction to byte only */ <br>                EAsize[0] = 1; <br>                pEAlabel = "byte ptr "; <br>                break; <br> <br>            case VAR: <br>                if (opsize_32) <br>                    goto DWORDlabel; <br> <br>            case xWORD: <br>                EAsize[0] = 2; <br>                pEAlabel = "word ptr "; <br>                break; <br> <br>            case EDWORD: <br>                opsize_32 = 1;    //  for control reg move, use eRegs <br>            case xDWORD: <br>DWORDlabel: <br>                EAsize[0] = 4; <br>                pEAlabel = "dword ptr "; <br>                break; <br> <br>            case QWORD: <br>                EAsize[0] = 8; <br>                pEAlabel = "qword ptr "; <br>                break; <br> <br>            case TTBYTE: <br>                EAsize[0] = 10; <br>                pEAlabel = "tbyte ptr "; <br>                break; <br> <br>            case FARPTR: <br>                if (opsize_32) { <br>                    EAsize[0] = 6; <br>                    pEAlabel = "fword ptr "; <br>                    } <br>                else { <br>                    EAsize[0] = 4; <br>                    pEAlabel = "dword ptr "; <br>                    } <br>                break; <br> <br>            case LMODRM:                //  output modRM data type <br>                if (mod != 3) <br>                    OutputString(&amp;pchOperandBuf, pEAlabel); <br>                else <br>                    EAsize[0] = 0; <br> <br>            case MODRM:                 /* output modrm string */ <br>                if (segOvr)             /* in case of segment override */ <br>                    OutputString(&amp;pchOperandBuf, distbl[segOvr].instruct); <br>                *pchModrmBuf = '\0'; <br>                OutputString(&amp;pchOperandBuf, ModrmBuffer); <br>                break; <br> <br>            case ADDRP:                 /* address pointer */ <br>                OutputHexString(&amp;pchOperandBuf, pMem + olen, 2); // segment <br>                *pchOperandBuf++ = ':'; <br>                OutputSymbol(dp, &amp;pchOperandBuf, pMem, olen, segOvr); <br>                pMem += olen + 2; <br>                break; <br> <br>            case REL8:                  /* relative address 8-bit */ <br>                if (opcode == 0xe3 &amp;&amp; mode_32) { <br>                    pchOpcodeBuf = OpcodeBuffer; <br>                    OutputString(&amp;pchOpcodeBuf, dszJECXZ); <br>                    } <br>                tmp = (long)*(char *)pMem++; /* get the 8-bit rel offset */ <br>                goto DoRelDispl; <br> <br>            case REL16:                 /* relative address 16-/32-bit */ <br>                tmp = 0; <br>                memmove(&amp;tmp,pMem,sizeof(long)); <br>                pMem += alen;           /* skip over offset */ <br>DoRelDispl: <br>                tmp += *pOffset + (pMem - membuf); /* calculate address */ <br>                OutputSymbol(dp, &amp;pchOperandBuf, (char *) &amp;tmp, alen, segOvr); <br>                                                   // address <br>                break; <br> <br>            case UBYTE:                 //  unsigned byte for int/in/out <br>                OutputHexString(&amp;pchOperandBuf, pMem, 1);  //  ubyte <br>                pMem++; <br>                break; <br> <br>            case IB:                    /* operand is immediate byte */ <br>                if ((opcode &amp; ~1) == 0xd4) {  // postop for AAD/AAM is 0x0a <br>                    if (*pMem++ != 0x0a) // test post-opcode byte <br>                        OutputString(&amp;pchOperandBuf, dszRESERVED); <br>                    break; <br>                    } <br>                olen = 1;               /* set operand length */ <br>                goto DoImmed; <br> <br>            case IW:                    /* operand is immediate word */ <br>                olen = 2;               /* set operand length */ <br> <br>            case IV:                    /* operand is word or dword */ <br>DoImmed: <br>                OutputHexValue(&amp;pchOperandBuf, pMem, olen, FALSE); <br>                pMem += olen; <br>                break; <br> <br>            case OFFS:                  /* operand is offset */ <br>                EAsize[0] = (opcode &amp; 1) ? olen : 1; <br> <br>                if (segOvr)             /* in case of segment override */ <br>                    OutputString(&amp;pchOperandBuf, distbl[segOvr].instruct); <br> <br>                *pchOperandBuf++ = '['; <br>                OutputSymbol(dp,&amp;pchOperandBuf, pMem, alen, segOvr);  //  offset <br>                pMem += alen; <br>                *pchOperandBuf++ = ']'; <br>                break; <br> <br>            case GROUPP:                 /* operand is of group 1,2,4,6 or 8 */ <br>                                        /* output opcode symbol */ <br>                OutputString(&amp;pchOpcodeBuf, group[*action++][ttt]); <br>                break; <br> <br>            case GROUPT:                /* operand is of group 3,5 or 7 */ <br>                indx = *action;         /* get indx into group from action */ <br>                goto doGroupT; <br> <br>            case EGROUPT:               /* x87 ESC (D8-DF) group index */ <br>                indx = BIT20(opcode) * 2; /* get group index from opcode */ <br>                if (mod == 3) {         /* some operand variations exists */ <br>                                        /*   for x87 and mod == 3 */ <br>                    ++indx;             /* take the next group table entry */ <br>                    if (indx == 3) {    /* for x87 ESC==D9 and mod==3 */ <br>                        if (ttt &gt; 3) {  /* for those D9 instructions */ <br>                            indx = 12 + ttt; /* offset index to table by 12 */ <br>                            ttt = rm;   /* set secondary index to rm */ <br>                            } <br>                        } <br>                    else if (indx == 7) { /* for x87 ESC==DB and mod==3 */ <br>                        if (ttt == 4)   /* only valid if ttt==4 */ <br>                            ttt = rm;   /* set secondary group table index */ <br>                        else <br>                            ttt = 7;    /* no an x87 instruction */ <br>                        } <br>                    } <br>doGroupT: <br>                /* handle group with different types of operands */ <br> <br>                OutputString(&amp;pchOpcodeBuf, groupt[indx][ttt].instruct); <br>                action = actiontbl + groupt[indx][ttt].opr; <br>                                                        /* get new action */ <br>                break; <br> <br>            case OPC0F:                 /* secondary opcode table (opcode 0F) */ <br>                opcode = *pMem++;       /* get real opcode */ <br>                fMovX  = (BOOLEAN)(opcode == 0xBF || opcode == 0xB7); <br>                if (opcode &lt; 7) /* for the first 7 opcodes */ <br>                    opcode += 256;      /* point begin of secondary opcode tab. */ <br>                else if (opcode &gt; 0x1f &amp;&amp; opcode &lt; 0x27) <br>                    opcode += 231;      /* adjust for non-existing opcodes */ <br>                else if (opcode &gt; 0x2f &amp;&amp; opcode &lt; 0x33) <br>                    opcode += 222;      /* adjust for non-existing opcodes */ <br>                else if (opcode &gt; 0x7e &amp;&amp; opcode &lt; 0xd0) <br>                    opcode += 148;      /* adjust for non-existing opcodes */ <br>                else <br>                    opcode = 260;       /* all non-existing opcodes */ <br>                goto getNxtByte1; <br> <br>            case ADR_OVR:               /* address override */ <br>                mode_32 = !G_mode_32;   /* override addressing mode */ <br>                alen = (mode_32 + 1) &lt;&lt; 1; /* toggle address length */ <br>                goto getNxtByte; <br> <br>            case OPR_OVR:               /* operand size override */ <br>                opsize_32 = !G_mode_32; /* override operand size */ <br>                olen = (opsize_32 + 1) &lt;&lt; 1; /* toggle operand length */ <br>                goto getNxtByte; <br> <br>            case SEG_OVR:               /* handle segment override */ <br>                segOvr = opcode;        /* save segment override opcode */ <br>                pchOpcodeBuf = OpcodeBuffer;  // restart the opcode string <br>                goto getNxtByte; <br> <br>            case REP:                   /* handle rep/lock prefixes */ <br>                *pchOpcodeBuf = '\0'; <br>                if (pchRepPrefixBuf != RepPrefixBuffer) <br>                    *pchRepPrefixBuf++ = ' '; <br>                OutputString(&amp;pchRepPrefixBuf, OpcodeBuffer); <br>                pchOpcodeBuf = OpcodeBuffer; <br>getNxtByte: <br>                opcode = *pMem++;        /* next byte is opcode */ <br>getNxtByte1: <br>                action = actiontbl + distbl[opcode].opr; <br>                OutputString(&amp;pchOpcodeBuf, distbl[opcode].instruct); <br> <br>            default:                    /* opcode has no operand */ <br>                break; <br>            } <br>        switch (action2) {              /* secondary action */ <br>            case MRM:                   /* generate modrm for later use */ <br>                if (!mrm) {             /* ignore if it has been generated */ <br>                    DIdoModrm(dp, &amp;pchModrmBuf, segOvr, fEAout); <br>                                        /* generate modrm */ <br>                    mrm = TRUE;         /* remember its generation */ <br>                    } <br>                break; <br> <br>            case COM:                   /* insert a comma after operand */ <br>                *pchOperandBuf++ = ','; <br>                break; <br> <br>            case END:                   /* end of instruction */ <br>                end = TRUE; <br>                break; <br>            } <br> } while (!end);                        /* loop til end of instruction */ <br> <br>/*****       prepare disassembled instruction for output              *****/ <br> <br>    instlen = pMem - membuf; <br> <br>    if (instlen &lt; cBytes) <br>        cBytes = instlen; <br> <br>    OutputHexCode(&amp;pchResultBuf, membuf, cBytes); <br> <br>    if (instlen &gt; cBytes) { <br>        *pchResultBuf++ = '?'; <br>        *pchResultBuf++ = '?'; <br>        (*pOffset)++;                   //  point past unread byte <br>        } <br> <br>    *pOffset += instlen;                /* set instruction length */ <br> <br>    if (instlen &gt; cBytes) { <br>        do <br>            *pchResultBuf++ = ' '; <br>        while (pchResultBuf &lt; pchDst + OBOFFSET); <br>        OutputString(&amp;pchResultBuf, "???"); <br>        *pchResultBuf++ = '\0'; <br>        return FALSE; <br>        } <br> <br>    //  if fEAout is set, build each EA with trailing space in EABuf <br>    //  point back over final trailing space if buffer nonnull <br> <br>    if (fEAout) { <br> <br>        for (indx = 0; indx &lt; 2; indx++) <br>            if (EAsize[indx]) { <br>                OutputString(&amp;pchEABuf, segOvr ? distbl[segOvr].instruct <br>                                               : pchEAseg[indx]); <br>                OutputHexAddr(&amp;pchEABuf, EAaddr[indx]); <br>                *pchEABuf++ = '='; <br> <br>                DoMemoryRead( dp, <br>                              (LPVOID)EAaddr[indx], <br>                              (LPVOID)membuf, <br>                              EAsize[indx], <br>                              &amp;tmp <br>                            ); <br> <br>                if (tmp == EAsize[indx]) <br>                    OutputHexString(&amp;pchEABuf, (char *)membuf, <br>                                               EAsize[indx]); <br>                else <br>                    while (EAsize[indx]--) { <br>                        *pchEABuf++ = '?'; <br>                        *pchEABuf++ = '?'; <br>                        } <br>                *pchEABuf++ = ' '; <br>                } <br>        if (pchEABuf != EABuffer) <br>            pchEABuf--; <br>        } <br> <br>    //  compute lengths of component strings. <br>    //  if the rep string is nonnull, <br>    //      add the opcode string length to the operand <br>    //      make the rep string the opcode string <br> <br>    cbOffset = pchResultBuf - pchDst; <br>    cbOperand = pchOperandBuf - OperandBuffer; <br>    cbOpcode = pchOpcodeBuf - OpcodeBuffer; <br>    if (pchRepPrefixBuf != RepPrefixBuffer) { <br>        cbOperand += cbOpcode + (cbOperand != 0); <br>        cbOpcode = pchRepPrefixBuf - RepPrefixBuffer; <br>        } <br>    cbEAddr = pchEABuf - EABuffer; <br> <br>    //  for really long strings, where the opcode and operand <br>    //      will not fit on a 77-character line, make two lines <br>    //      with the opcode on offset 0 on the second line with <br>    //      the operand following after one space <br> <br>    if (cbOpcode + cbOperand &gt; OBLINEEND - 1) { <br>        fTwoLines = TRUE; <br>        obOpcode = 0; <br>        obOperand = cbOpcode + 1; <br>        } <br>    else { <br> <br>        //  compute the minimum and maximum offset values for <br>        //      opcode and operand strings. <br>        //  if strings are nonnull, add extra for separating space <br> <br>        obOpcodeMin = cbOffset + 1; <br>        obOperandMin = obOpcodeMin + cbOpcode + 1; <br>        obOperandMax = OBLINEEND - cbEAddr - (cbEAddr != 0) - cbOperand; <br>        obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode; <br> <br>        //  if minimum offset is more than the maximum, the strings <br>        //      will not fit on one line.  recompute the min/max <br>        //      values with no offset and EA strings. <br> <br>        if (obOpcodeMin &gt; obOpcodeMax) { <br>            fTwoLines = TRUE; <br>            obOpcodeMin = 0; <br>            obOperandMin = cbOpcode + 1; <br>            obOperandMax = OBLINEEND - cbOperand; <br>            obOpcodeMax = obOperandMax - (cbOperand != 0) - cbOpcode; <br>            } <br> <br>        //  compute the opcode and operand offsets.  set offset as <br>        //      close to the default values as possible. <br> <br>        if (obOpcodeMin &gt; OBOFFSET) <br>            obOpcode = obOpcodeMin; <br>        else if (obOpcodeMax &lt; OBOFFSET) <br>            obOpcode = obOpcodeMax; <br> <br>        obOperandMin = obOpcode + cbOpcode + 1; <br> <br>        if (obOperandMin &gt; OBOPERAND) <br>            obOperand = obOperandMin; <br>        else if (obOperandMax &lt; OBOPERAND) <br>            obOperand = obOperandMax; <br>        } <br> <br>    //  build the resultant string with the offsets computed <br> <br>    //  if two lines are to be output, <br>    //      append the EAddr string <br>    //      output a new line and reset the pointer <br> <br>    if (fTwoLines) { <br>        if (pchEABuf != EABuffer) { <br>            do <br>                *pchResultBuf++ = ' '; <br>            while (pchResultBuf &lt; pchDst + OBLINEEND - cbEAddr); <br>            *pchEABuf = '\0'; <br>            OutputString(&amp;pchResultBuf, EABuffer); <br>            OutputString(&amp;pchResultBuf, "\n        "); <br>            } <br>        pchDst = pchResultBuf; <br>        } <br> <br>    //  output rep, opcode, and operand strings <br> <br>    do <br>        *pchResultBuf++ = ' '; <br>    while (pchResultBuf &lt; pchDst + obOpcode); <br> <br>    if (pchRepPrefixBuf != RepPrefixBuffer) { <br>        *pchRepPrefixBuf = '\0'; <br>        OutputString(&amp;pchResultBuf, RepPrefixBuffer); <br>        do <br>            *pchResultBuf++ = ' '; <br>        while (pchResultBuf &lt; pchDst + obOperand); <br>        } <br> <br>    *pchOpcodeBuf = '\0'; <br>    OutputString(&amp;pchResultBuf, OpcodeBuffer); <br> <br>    if (pchOperandBuf != OperandBuffer) { <br>        do <br>            *pchResultBuf++ = ' '; <br>        while (pchResultBuf &lt; pchDst + obOperand); <br>        *pchOperandBuf = '\0'; <br>        OutputString(&amp;pchResultBuf, OperandBuffer); <br>        } <br> <br>    //  if one line is to be output, append the EAddr string <br> <br>    if (!fTwoLines &amp;&amp; pchEABuf != EABuffer) { <br>        *pchEABuf = '\0'; <br>        do <br>            *pchResultBuf++ = ' '; <br>        while (pchResultBuf &lt; pchDst + OBLINEEND - cbEAddr); <br>        OutputString(&amp;pchResultBuf, EABuffer); <br>        } <br> <br>    *pchResultBuf = '\0'; <br>    return TRUE; <br>} <br> <br>/*...........................internal function..............................*/ <br>/*                                                                          */ <br>/*                       generate a mod/rm string                           */ <br>/*                                                                          */ <br> <br>void <br>DIdoModrm (PDEBUGPACKET dp, char **ppchBuf, int segOvr, BOOLEAN fEAout) <br>{ <br>    int     mrm;                        /* modrm byte */ <br>    char    *src;                       /* source string */ <br>    int     sib; <br>    int     ss; <br>    int     ind; <br>    int     oldrm; <br> <br>    mrm = *pMem++;                      /* get the mrm byte from instruction */ <br>    mod = BIT76(mrm);                   /* get mod */ <br>    ttt = BIT53(mrm);                   /* get reg - used outside routine */ <br>    rm  = BIT20(mrm);                   /* get rm */ <br> <br>    if (mod == 3) {                     /* register only mode */ <br>        src = &amp;regtab[rm * 2];          /* point to 16-bit register */ <br>        if (EAsize[0] &gt; 1) { <br>            src += 16;                  /* point to 16-bit register */ <br>            if (opsize_32 &amp;&amp; !fMovX) <br>                *(*ppchBuf)++ = 'e';    /* make it a 32-bit register */ <br>            } <br>        *(*ppchBuf)++ = *src++;         /* copy register name */ <br>        *(*ppchBuf)++ = *src; <br>        EAsize[0] = 0;                  //  no EA value to output <br>        return; <br>        } <br> <br>    if (mode_32) {                      /* 32-bit addressing mode */ <br>        oldrm = rm; <br>        if (rm == 4) {                  /* rm == 4 implies sib byte */ <br>            sib = *pMem++;              /* get s_i_b byte */ <br>            rm = BIT20(sib);            /* return base */ <br>            } <br> <br>        *(*ppchBuf)++ = '['; <br>        if (mod == 0 &amp;&amp; rm == 5) { <br>            OutputSymbol(dp,ppchBuf, pMem, 4, segOvr); // offset <br>            pMem += 4; <br>            } <br>        else { <br>            if (fEAout) { <br>                if (segOvr) { <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg32[rm]); <br>                    pchEAseg[0] = distbl[segOvr].instruct; <br>                    } <br>                else if (reg32[rm] == REGEBP || reg32[rm] == REGESP) { <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg32[rm]); <br>                    pchEAseg[0] = dszSS_; <br>                    } <br>                else <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg32[rm]); <br>                } <br>            OutputString(ppchBuf, mrmtb32[rm]); <br>            } <br> <br>        if (oldrm == 4) {               //  finish processing sib <br>            ind = BIT53(sib); </code></pre>
<p>
</p>
<pre><code>if (ind != 4) { <br>                *(*ppchBuf)++ = '+'; <br>                OutputString(ppchBuf, mrmtb32[ind]); <br>                ss = 1 &lt;&lt; BIT76(sib); <br>                if (ss != 1) { <br>                    *(*ppchBuf)++ = '*'; <br>                    *(*ppchBuf)++ = (char)(ss + '0'); <br>                    } <br>                if (fEAout) <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg32[ind]); <br>                } <br>            } <br>        } <br>    else {                              //  16-bit addressing mode <br>        *(*ppchBuf)++ = '['; <br>        if (mod == 0 &amp;&amp; rm == 6) { <br>            OutputSymbol(dp,ppchBuf, pMem, 2, segOvr);   // 16-bit offset <br>            pMem += 2; <br>            } <br>        else { <br>            if (fEAout) { <br>                if (segOvr) { <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg16[rm]); <br>                    pchEAseg[0] = distbl[segOvr].instruct; <br>                    } <br>                else if (reg16[rm] == REGEBP) { <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg16[rm]); <br>                    pchEAseg[0] = dszSS_; <br>                    } <br>                else <br>                    EAaddr[0] = (DWORD)GetRegValue(dp, reg16[rm]); <br>                if (rm &lt; 4) <br>                    EAaddr[0] += (DWORD)GetRegValue(dp, reg16_2[rm]); <br>            } <br>            OutputString(ppchBuf, mrmtb16[rm]); <br>            } <br>        } <br> <br>    //  output any displacement <br> <br>    if (mod == 1) { <br>        if (fEAout) <br>            EAaddr[0] += (ULONG)pMem; <br>        OutputHexValue(ppchBuf, pMem, 1, TRUE); <br>        pMem++; <br>        } <br>    else if (mod == 2) { <br>        long tmp = 0; <br>        if (mode_32) { <br>            memmove(&amp;tmp,pMem,sizeof(long)); <br>            if (fEAout) <br>                EAaddr[0] += (ULONG)tmp; <br>            OutputHexValue(ppchBuf, pMem, 4, TRUE); <br>            pMem += 4; <br>            } <br>        else { <br>            memmove(&amp;tmp,pMem,sizeof(short)); <br>            if (fEAout) <br>                EAaddr[0] += tmp; <br>            OutputHexValue(ppchBuf, pMem, 2, TRUE); <br>            pMem += 2; <br>            } <br>        } <br> <br>    if (!mode_32 &amp;&amp; fEAout) { <br>        EAaddr[0] &amp;= 0xffff; <br>        EAaddr[1] &amp;= 0xffff; <br>    } <br> <br>    *(*ppchBuf)++ = ']'; <br>} <br> <br>/*** OutputHexValue - output hex value <br>* <br>*   Purpose: <br>*       Output the value pointed by *ppchBuf of the specified <br>*       length.  The value is treated as signed and leading <br>*       zeroes are not printed.  The string is prefaced by a <br>*       '+' or '-' sign as appropriate. <br>* <br>*   Input: <br>*       *ppchBuf - pointer to text buffer to fill <br>*       *pchMemBuf - pointer to memory buffer to extract value <br>*       length - length in bytes of value (1, 2, and 4 supported) <br>*       fDisp - set if displacement to output '+' <br>* <br>*   Output: <br>*       *ppchBuf - pointer updated to next text character <br>* <br>*************************************************************************/ <br> <br>void OutputHexValue (char **ppchBuf, char *pchMemBuf, int length, int fDisp) <br>{ <br>    long    value; <br>    int     index; <br>    char    digit[8]; <br> <br>    value = 0; <br>    if (length == 1) <br>        value = (long)(*(char *)pchMemBuf); <br>    else if (length == 2) <br>        memmove(&amp;value,pchMemBuf,2); <br>    else <br>        memmove(&amp;value,pchMemBuf,sizeof(long)); <br> <br>    length &lt;&lt;= 1;               //  shift once to get hex length <br> <br>    if (value != 0 || !fDisp) { <br>        if (fDisp) <br>            if (value &lt; 0 &amp;&amp; length == 2) {   //  use neg value for byte <br>                value = -value;               //    displacement <br>                *(*ppchBuf)++ = '-'; <br>                } <br>            else <br>                *(*ppchBuf)++ = '+'; <br> <br>        *(*ppchBuf)++ = '0'; <br>        *(*ppchBuf)++ = 'x'; <br>        for (index = length - 1; index != -1; index--) { <br>            digit[index] = (char)(value &amp; 0xf); <br>            value &gt;&gt;= 4; <br>            } <br>        index = 0; <br>        while (digit[index] == 0 &amp;&amp; index &lt; length - 1) <br>            index++; <br>        while (index &lt; length) <br>            *(*ppchBuf)++ = hexdigit[digit[index++]]; <br>        } <br>} <br> <br>/*** OutputHexString - output hex string <br>* <br>*   Purpose: <br>*       Output the value pointed by *ppchMemBuf of the specified <br>*       length.  The value is treated as unsigned and leading <br>*       zeroes are printed. <br>* <br>*   Input: <br>*       *ppchBuf - pointer to text buffer to fill <br>*       *pchValue - pointer to memory buffer to extract value <br>*       length - length in bytes of value <br>* <br>*   Output: <br>*       *ppchBuf - pointer updated to next text character <br>*       *ppchMemBuf - pointer update to next memory byte <br>* <br>*************************************************************************/ <br> <br>void <br>OutputHexString (char **ppchBuf, char *pchValue, int length) <br>{ <br>    unsigned char    chMem; <br> <br>    pchValue += length; <br>    while (length--) { <br>        chMem = *--pchValue; <br>        *(*ppchBuf)++ = hexdigit[chMem &gt;&gt; 4]; <br>        *(*ppchBuf)++ = hexdigit[chMem &amp; 0x0f]; <br>        } <br>} <br> <br>/*** OutputHexCode - output hex code <br>* <br>*   Purpose: <br>*       Output the code pointed by pchMemBuf of the specified <br>*       length.  The value is treated as unsigned and leading <br>*       zeroes are printed.  This differs from OutputHexString <br>*       in that bytes are printed from low to high addresses. <br>* <br>*   Input: <br>*       *ppchBuf - pointer to text buffer to fill <br>*       pchMemBuf - pointer to memory buffer to extract value <br>*       length - length in bytes of value <br>* <br>*   Output: <br>*       *ppchBuf - pointer updated to next text character <br>* <br>*************************************************************************/ <br> <br>void <br>OutputHexCode (char **ppchBuf, char *pchMemBuf, int length) <br>{ <br>    unsigned char    chMem; <br> <br>    while (length--) { <br>        chMem = *pchMemBuf++; <br>        *(*ppchBuf)++ = hexdigit[chMem &gt;&gt; 4]; <br>        *(*ppchBuf)++ = hexdigit[chMem &amp; 0x0f]; <br>        } <br>} <br> <br>/*** OutputString - output string <br>* <br>*   Purpose: <br>*       Copy the string into the buffer pointed by *ppBuf. <br>* <br>*   Input: <br>*       *pStr - pointer to string <br>* <br>*   Output: <br>*       *ppBuf points to next character in buffer. <br>* <br>*************************************************************************/ <br> <br>void <br>OutputString (char **ppBuf, char *pStr) <br>{ <br>    while (*pStr) <br>        *(*ppBuf)++ = *pStr++; <br>} <br> <br>/*** OutputSymbol - output symbolic value <br>* <br>*   Purpose: <br>*       Output the value in outvalue into the buffer <br>*       pointed by *pBuf.  Express the value as a <br>*       symbol plus displacment, if possible. <br>* <br>*   Input: <br>*       *ppBuf - pointer to text buffer to fill <br>*       *pValue - pointer to memory buffer to extract value <br>*       length - length in bytes of value <br>* <br>*   Output: <br>*       *ppBuf - pointer updated to next text character <br>* <br>*************************************************************************/ <br> <br>void <br>OutputSymbol (PDEBUGPACKET dp, char **ppBuf, char *pValue, int length, int segOvr) <br>{ <br>    ULONG               displacement; <br>    ULONG               value; <br>    char                *szSymName; <br> <br>    value = 0; <br>    if (length == 1) <br>        value = (long)(*(char *)pValue); <br>    else if (length == 2) <br>        memmove(&amp;value,pValue,sizeof(short)); <br>    else <br>        memmove(&amp;value,pValue,sizeof(long)); <br> <br>    EAaddr[0] = value; <br> <br>    if (SymGetSymFromAddr( dp-&gt;hProcess, value, &amp;displacement, sym )) { <br>        szSymName = sym-&gt;Name; <br>        OutputString(ppBuf, szSymName); <br>        OutputHexValue(ppBuf, (char *)&amp;displacement, length, TRUE); <br>        *(*ppBuf)++ = ' '; <br>        *(*ppBuf)++ = '('; <br>        OutputHexString(ppBuf, pValue, length); <br>        *(*ppBuf)++ = ')'; <br>        } <br>    else <br>        OutputHexString(ppBuf, pValue, length); <br>} <br> <br>/*** X86GetNextOffset - compute offset for trace or step <br>* <br>*   Purpose: <br>*       From a limited disassembly of the instruction pointed <br>*       by the FIR register, compute the offset of the next <br>*       instruction for either a trace or step operation. <br>* <br>*   Input: <br>*       fStep - TRUE if step offset returned - FALSE for trace offset <br>* <br>*   Returns: <br>*       step or trace offset if input is TRUE or FALSE, respectively <br>*       -1 returned for trace flag to be used <br>* <br>*************************************************************************/ <br> <br>void <br>GetNextOffset (PDEBUGPACKET dp, PULONG pcaddr, BOOLEAN fStep) <br>{ <br>    int     mode_32; <br>    int     opsize_32; <br>    int     cBytes; <br>    char    membuf[MAXL];               //  current instruction buffer <br>    ULONG   addrReturn; <br>    USHORT  retAddr[3];                 //  return address buffer <br>    char    *pMem; <br>    UCHAR   opcode; <br>    int     fPrefix = TRUE; <br>    int     fRepPrefix = FALSE; <br>    int     ttt; <br>    int     rm; <br>    ULONG   instroffset; <br> <br>    //  read instruction stream bytes into membuf and set mode and <br>    //      opcode size flags <br> <br>    *pcaddr = (DWORD)GetRegValue(dp,REGEIP); <br>    instroffset = *pcaddr; <br>    G_mode_32 = TRUE; <br>    mode_32 = opsize_32 = (G_mode_32 == 1); /* local addressing mode */ <br>    DoMemoryRead( dp, <br>                  (LPVOID)*pcaddr, <br>                  (LPVOID)membuf, <br>                  MAXL, <br>                  &amp;cBytes <br>                ); <br>                                        /* move full inst to local buffer */ <br>    pMem = membuf;                      /* point to begin of instruction */ <br> <br>    //  read and process any prefixes first <br> <br>    do { <br>        opcode = (UCHAR)*pMem++;        /* get opcode */ <br>        if (opcode == 0x66) <br>            opsize_32 = !G_mode_32; <br>        else if (opcode == 0x67) <br>            mode_32 = !G_mode_32; <br>        else if ((opcode &amp; ~1) == 0xf2) <br>            fRepPrefix = TRUE; <br>        else if (opcode != 0xf0 &amp;&amp; (opcode &amp; ~0x18) != 0x26 <br>                                &amp;&amp; (opcode &amp; ~1) != 0x64) <br>            fPrefix = FALSE; <br>        } <br>    while (fPrefix); <br> <br>    //  for instructions that alter the TF (trace flag), return the <br>    //      offset of the next instruction despite the flag of fStep <br> <br>    if (((opcode &amp; ~0x3) == 0x9c)) <br>        //  9c-9f, pushf, popf, sahf, lahf <br>        ; <br> <br>    else if (opcode == 0xcf) {          //  cf - iret - get RA from stack <br> <br>        addrReturn = (DWORD)GetRegValue(dp, REGESP); <br>        DoMemoryRead( dp, <br>                      (LPVOID)addrReturn, <br>                      (LPVOID)retAddr, <br>                      sizeof(retAddr), <br>                      NULL <br>                    ); <br> <br>        *pcaddr = retAddr[2]; <br>        return; <br>        } <br> <br>    //  repeated string/port instructions <br> <br>    if (opcode == 0xe8)            //  near direct jump <br>        pMem += (1 + opsize_32) * 2; <br> <br>    else if (opcode == 0x9a)            //  far direct jump <br>        pMem += (2 + opsize_32) * 2; <br> <br>    else if (opcode == 0xcd || <br>             (opcode &gt;= 0xe0 &amp;&amp; opcode &lt;= 0xe2)) //  loop / int nn instrs <br>        pMem++; <br> <br>    else if (opcode == 0xff) {          //  indirect call - compute length <br>        opcode = *pMem++;               //  get modRM <br>        ttt = BIT53(opcode); <br>        if ((ttt &amp; ~1) == 2) { <br>            mod = BIT76(opcode); <br>            if (mod != 3) {                     //  nonregister operand <br>                rm = BIT20(opcode); <br>                if (mode_32) { <br>                    if (rm == 4) <br>                        rm = BIT20(*pMem++);    //  get base from SIB <br>                    if (mod == 0) { <br>                        if (rm == 5) <br>                            pMem += 4;          //  long direct address <br>                        }                       //  else register <br>                    else if (mod == 1) <br>                        pMem++;                 //  register with byte offset <br>                    else <br>                        pMem += 4;              //  register with long offset <br>                    } <br>                else {                          //  16-bit mode <br>                    if (mod == 0) { <br>                        if (rm == 6) <br>                            pMem += 2;          //  short direct address <br>                        } <br>                    else <br>                        pMem += mod;            //  reg, byte, word offset <br>                    } <br>                } <br>            } <br>        else <br>            instroffset = (ULONG)-1;            //  0xff, but not call <br>        } <br> <br>    else if (!((fRepPrefix &amp;&amp; ((opcode &amp; ~3) == 0x6c || <br>                               (opcode &amp; ~3) == 0xa4 || <br>                               (opcode &amp; ~1) == 0xaa || <br>                               (opcode &amp; ~3) == 0xac)) || <br>                               opcode == 0xcc || opcode == 0xce)) <br>        instroffset = (ULONG)-1;                //  not repeated string op <br>                                                //  or int 3 / into <br> <br>    //  if not enough bytes were read for instruction parse, <br>    //      just give up and trace the instruction <br> <br>    if (cBytes &lt; pMem - membuf) <br>        instroffset = (ULONG)-1; <br> <br>    //  if not tracing, compute the new instruction offset <br> <br>    if (instroffset != (ULONG)-1) <br>        instroffset += pMem - membuf; <br> <br>    *pcaddr = instroffset; <br>} <br> <br>void <br>OutputHexAddr (PUCHAR *ppBuffer, ULONG offset) <br>{ <br>    OutputHexString(ppBuffer, (char *)&amp;offset, sizeof(ULONG)); <br>} <br> <br>USHORT <br>GetSegRegValue (PDEBUGPACKET dp, int segOpcode) <br>{ <br>    ULONG    regnum; <br> <br>    switch (segOpcode) { <br>        case 0x26: <br>            regnum = REGES; <br>            break; <br>        case 0x2e: <br>            regnum = REGCS; <br>            break; <br>        case 0x36: <br>            regnum = REGSS; <br>            break; <br>        case 0x64: <br>            regnum = REGFS; <br>            break; <br>        case 0x65: <br>            regnum = REGGS; <br>            break; <br>        case 0x3e: <br>        default: <br>            regnum = REGDS; <br>        } <br> <br>    return (USHORT)GetRegValue(dp,regnum); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
