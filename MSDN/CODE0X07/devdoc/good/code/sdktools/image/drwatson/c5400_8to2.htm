<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBUG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5402"></a>DEBUG.C</h2>
<pre><code>/*++ <br> <br>Copyright (c) 1993  Microsoft Corporation <br> <br>Module Name: <br> <br>    debug.c <br> <br>Abstract: <br> <br>    This file implements the debug module for drwatson.  This module <br>    processes all debug events and generates the postmortem dump. <br> <br>Author: <br> <br>    Wesley Witt (wesw) 1-May-1993 <br> <br>Environment: <br> <br>    User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stddef.h&gt; <br> <br>#include "drwatson.h" <br>#include "cv.h" <br>#include "cvfmt.h" <br>#include "proto.h" <br>#include "messages.h" <br>#include "resource.h" <br> <br>typedef struct tagSYSINFO { <br>    char    szUserName[MAX_PATH]; <br>    char    szMachineName[MAX_PATH]; <br>} SYSINFO, *PSYSINFO; <br> <br> <br>#define DBG_EXCEPTION_HANDLED           ((DWORD)0x00010001L) <br>#define STATUS_POSSIBLE_DEADLOCK        ((DWORD)0xC0000194L) <br>#define STATUS_VDM_EVENT                STATUS_SEGMENT_NOTIFICATION <br> <br>PTHREADCONTEXT <br>AllocTctx( <br>    PDEBUGPACKET dp <br>    ); <br> <br>void <br>PostMortemDump( <br>    PDEBUGPACKET dp, <br>    LPEXCEPTION_DEBUG_INFO ed <br>    ); <br> <br>void <br>AttachToActiveProcess ( <br>    PDEBUGPACKET dp <br>    ); <br> <br>void <br>ProcessCreateProcess( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ); <br> <br>void <br>ProcessCreateThread( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ); <br> <br>void <br>ProcessExitThread( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ); <br> <br>void <br>ProcessLoadDll( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ); <br> <br>void <br>LogSystemInformation( <br>    PDEBUGPACKET dp <br>    ); <br> <br>DWORD <br>SysInfoThread( <br>    PSYSINFO si <br>    ); <br> <br>void <br>LogDisassembly( <br>    PDEBUGPACKET dp, <br>    PCRASHES pCrash <br>    ); <br> <br>void <br>LogStackWalk( <br>    PDEBUGPACKET dp <br>    ); <br> <br>void <br>LogStackDump( <br>    PDEBUGPACKET dp <br>    ); <br> <br>char * <br>GetExceptionText( <br>    DWORD dwExceptionCode <br>    ); <br> <br>LPSTR <br>ExpandPath( <br>    LPSTR lpPath <br>    ); <br> <br>void <br>SetFaultingContext( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ); <br> <br>void <br>SkipOverBreakpoint( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ); <br> <br>DWORD <br>DispatchDebugEventThread( <br>    PDEBUGPACKET dp <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This is the entry point for DRWTSN32 <br> <br>Arguments: <br> <br>    None. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    DEBUG_EVENT   de; <br>    DWORD         rc = 0; <br>    char          szLogFileName[1024]; <br>    char          buf[1024]; <br>    LPSTR         p; <br>    DWORD         ContinueStatus; <br> <br> <br>    if (dp-&gt;dwPidToDebug == 0) { <br>        rc = 1; <br>        goto exit; <br>    } <br> <br>    SetErrorMode( SEM_FAILCRITICALERRORS | <br>                  SEM_NOGPFAULTERRORBOX  | <br>                  SEM_NOOPENFILEERRORBOX   ); <br> <br>    AttachToActiveProcess( dp ); <br> <br>    p = ExpandPath( dp-&gt;options.szLogPath ); <br>    if (p) { <br>        strcpy( szLogFileName, p ); <br>        free( p ); <br>    } else { <br>        strcpy( szLogFileName, dp-&gt;options.szLogPath ); <br>    } <br>    MakeLogFileName( szLogFileName ); <br>    OpenLogFile( szLogFileName, <br>                 dp-&gt;options.fAppendToLogFile, <br>                 dp-&gt;options.fVisual <br>               ); <br> <br>    while (TRUE) { <br>        if (!WaitForDebugEvent( &amp;de, 10000 )) { <br>            rc = GetLastError(); <br>            goto exit; <br>        } <br>        ContinueStatus = DBG_CONTINUE; <br> <br>        switch (de.dwDebugEventCode) { <br>            case EXCEPTION_DEBUG_EVENT: <br>                if (de.u.Exception.ExceptionRecord.ExceptionCode == STATUS_BREAKPOINT) { <br>                    if (de.u.Exception.dwFirstChance) { <br>                        SkipOverBreakpoint(dp, &amp;de); <br>                        ContinueStatus = DBG_EXCEPTION_HANDLED; <br>                        // <br>                        // The aedebug event will be signalled AFTER this <br>                        // thread exits, so that it will disappear before <br>                        // the dump snapshot is taken. <br>                        // <br>                        break; <br>                    } <br>                } <br>                if (dp-&gt;options.fVisual) { <br>                    // <br>                    // this notification is necessary because the shell must know when <br>                    // the debugee has been attached.  if it doesn't know and the user is <br>                    // allowed to terminate drwatson then the system may intervene with <br>                    // a popup. <br>                    // <br>                    SendMessage( dp-&gt;hwnd, WM_ATTACHCOMPLETE, 0, 0 ); <br>                    wsprintf( buf, <br>                              LoadRcString( IDS_AE_TEXT ), <br>                              GetExceptionText(de.u.Exception.ExceptionRecord.ExceptionCode), <br>                              de.u.Exception.ExceptionRecord.ExceptionCode, <br>                              de.u.Exception.ExceptionRecord.ExceptionAddress ); <br>                    SendMessage( dp-&gt;hwnd, WM_EXCEPTIONINFO, 0, (LPARAM) buf ); <br>                } <br>                SetFaultingContext(dp, &amp;de); <br>                PostMortemDump( dp, &amp;de.u.Exception ); <br>                if (dp-&gt;options.fCrash) { <br>                    CreateDumpFile( dp, &amp;de.u.Exception ); <br>                } <br>                ContinueStatus = DBG_EXCEPTION_NOT_HANDLED; <br>                break; <br> <br>            case CREATE_THREAD_DEBUG_EVENT: <br>                ProcessCreateThread( dp, &amp;de ); <br>                break; <br> <br>            case CREATE_PROCESS_DEBUG_EVENT: <br>                ProcessModuleLoad( dp, &amp;de ); <br>                de.u.CreateThread.hThread = de.u.CreateProcessInfo.hThread; <br>                ProcessCreateThread( dp, &amp;de ); <br>                break; <br> <br>            case EXIT_THREAD_DEBUG_EVENT: <br>                ProcessExitThread( dp, &amp;de ); <br>                if ( dp-&gt;hEventToSignal ) { <br>                    SetEvent(dp-&gt;hEventToSignal); <br>                    dp-&gt;hEventToSignal = 0L; <br>                } <br>                break; <br> <br>            case EXIT_PROCESS_DEBUG_EVENT: <br>                goto exit; <br>                break; <br> <br>            case LOAD_DLL_DEBUG_EVENT: <br>                ProcessModuleLoad( dp, &amp;de ); <br>                break; <br> <br>            case UNLOAD_DLL_DEBUG_EVENT: <br>                break; <br> <br>            case OUTPUT_DEBUG_STRING_EVENT: <br>                break; <br> <br>            case RIP_EVENT: <br>                break; <br> <br>            default: <br>                lprintf( MSG_INVALID_DEBUG_EVENT, de.dwDebugEventCode ); <br>                break; <br>        } <br>        ContinueDebugEvent( de.dwProcessId, de.dwThreadId, ContinueStatus ); <br>    } <br> <br>exit: <br>    CloseLogFile(); <br> <br>    if (dp-&gt;options.fVisual) { <br>        SendMessage( dp-&gt;hwnd, WM_DUMPCOMPLETE, 0, 0 ); <br>    } <br> <br>    return 0; <br>} <br> <br>PTHREADCONTEXT <br>AllocTctx( <br>    PDEBUGPACKET dp <br>    ) <br>{ <br>    PTHREADCONTEXT ptctx; <br> <br>    ptctx = (PTHREADCONTEXT) malloc( sizeof(THREADCONTEXT) ); <br>    if (ptctx == NULL) { <br>        if (dp-&gt;options.fVisual) { <br>            FatalError( LoadRcString(IDS_MEMORY) ); <br>        } <br>        else { <br>            ExitProcess( 1 ); <br>        } <br>    } <br>    memset( ptctx, 0, sizeof(THREADCONTEXT) ); <br> <br>    return ptctx; <br>} <br> <br>void <br>ProcessCreateThread( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ) <br>{ <br>    dp-&gt;tctx              = AllocTctx( dp ); <br>    dp-&gt;tctx-&gt;hThread     = de-&gt;u.CreateThread.hThread; <br>    dp-&gt;tctx-&gt;dwThreadId  = de-&gt;dwThreadId; <br> <br>    InsertTailList(&amp;dp-&gt;ThreadList, &amp;dp-&gt;tctx-&gt;ThreadList); <br> <br>    return; <br>} <br> <br>void <br>ProcessExitThread( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ) <br>{ <br>    PTHREADCONTEXT ptctx; <br>    PLIST_ENTRY List = dp-&gt;ThreadList.Flink; <br> <br>    while (List != &amp;dp-&gt;ThreadList) { <br>        ptctx = CONTAINING_RECORD(List, THREADCONTEXT, ThreadList); <br>        if (ptctx-&gt;dwThreadId == de-&gt;dwThreadId) { <br>            RemoveEntryList(List); <br>            free(ptctx); <br>            break; <br>        } <br>        List = List-&gt;Flink; <br>    } <br>} <br> <br>void <br>PostMortemDump( <br>    PDEBUGPACKET dp, <br>    LPEXCEPTION_DEBUG_INFO ed <br>    ) <br>{ <br>    IMAGEHLP_MODULE   mi; <br>    char              dbuf[1024]; <br>    char              szDate[20]; <br>    char              szTime[20]; <br>    CRASHES           crash; <br>    DWORD             dwThreadId; <br>    HANDLE            hThread; <br>    PLIST_ENTRY        List; <br> <br> <br>    GetLocalTime( &amp;crash.time ); <br>    crash.dwExceptionCode = ed-&gt;ExceptionRecord.ExceptionCode; <br>    crash.dwAddress = (DWORD)ed-&gt;ExceptionRecord.ExceptionAddress; <br>    strcpy( crash.szAppName, szApp ); <br> <br>    lprintf( MSG_APP_EXCEPTION ); <br>    wsprintf( dbuf, "%d", dp-&gt;dwPidToDebug ); <br>    lprintf( MSG_APP_EXEP_NAME, crash.szAppName, dbuf ); <br>    wsprintf( szDate, "%d/%d/%d", crash.time.wMonth, <br>                                  crash.time.wDay, <br>                                  crash.time.wYear ); <br>    wsprintf( szTime, "%d:%d:%d.%d", crash.time.wHour, <br>                                     crash.time.wMinute, <br>                                     crash.time.wSecond, <br>                                     crash.time.wMilliseconds ); <br>    lprintf( MSG_APP_EXEP_WHEN, szDate, szTime ); <br>    wsprintf( dbuf, "%08lx", ed-&gt;ExceptionRecord.ExceptionCode ); <br>    lprintf( MSG_EXCEPTION_NUMBER, dbuf ); <br> <br> <br>    lprintfs( "(%s)\r\n\r\n", <br>              GetExceptionText(ed-&gt;ExceptionRecord.ExceptionCode) ); <br> <br>    LogSystemInformation( dp ); <br> <br>    LogTaskList(); <br> <br>    if (SymGetModuleInfo( dp-&gt;hProcess, 0, &amp;mi )) { <br>        do { <br>            lprintfs( "(%08x - %08x) %s\r\n", <br>                      (DWORD)mi.BaseOfImage, <br>                      (DWORD)mi.BaseOfImage + mi.ImageSize, <br>                      mi.LoadedImageName <br>                    ); <br>        } while( SymGetModuleInfo( dp-&gt;hProcess, (DWORD)-1, &amp;mi )); <br>        lprintfs( "\r\n" ); <br>    } <br> <br>    List = dp-&gt;ThreadList.Flink; <br>    while (List != &amp;dp-&gt;ThreadList) { <br> <br>        dp-&gt;tctx = CONTAINING_RECORD(List, THREADCONTEXT, ThreadList); <br>        List = List-&gt;Flink; <br> <br>        GetContextForThread( dp ); <br> <br>        if (dp-&gt;tctx-&gt;fFaultingContext || dp-&gt;options.fDumpAllThreads) { <br>            wsprintf( dbuf, "%x", dp-&gt;tctx-&gt;dwThreadId ); <br>            lprintf( MSG_STATE_DUMP, dbuf ); <br>            OutputAllRegs( dp, TRUE ); <br>            LogDisassembly( dp, &amp;crash ); <br>            LogStackWalk( dp ); <br>            LogStackDump( dp ); <br>        } <br>    } <br> <br>    if (dp-&gt;options.fDumpSymbols) { <br>        DumpSymbols( dp ); <br>    } <br> <br>    ElSaveCrash( &amp;crash, dp-&gt;options.dwMaxCrashes ); <br> <br>    hThread = CreateThread( NULL, <br>                            16000, <br>                            (LPTHREAD_START_ROUTINE)TerminationThread, <br>                            dp, <br>                            0, <br>                            (LPDWORD)&amp;dwThreadId <br>                          ); <br> <br>    WaitForSingleObject( hThread, 30000 ); <br> <br>    CloseHandle( hThread ); <br> <br>    return; <br>} <br> <br>void <br>LogStackDump( <br>    PDEBUGPACKET dp <br>    ) <br>{ <br>    DWORD   i; <br>    DWORD   j; <br>    BYTE    stack[1024]; <br> <br> <br> <br>    memset( stack, 0, sizeof(stack) ); <br>    if (!DoMemoryRead( dp, <br>                       (LPVOID)dp-&gt;tctx-&gt;stack, <br>                       (LPVOID)stack, <br>                       sizeof(stack), <br>                       (LPDWORD)&amp;i )) { <br>        return; <br>    } <br> <br>    lprintf( MSG_STACK_DUMP_HEADER ); <br> <br>    for( i = 0; i &lt; 20; i++ ) { <br>        j = i * 16; <br>        lprintfs( "%08x  %02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x  %c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\r\n", <br>                  j + dp-&gt;tctx-&gt;stack, <br>                  stack[ j +  0 ], <br>                  stack[ j +  1 ], <br>                  stack[ j +  2 ], <br>                  stack[ j +  3 ], <br>                  stack[ j +  4 ], <br>                  stack[ j +  5 ], <br>                  stack[ j +  6 ], <br>                  stack[ j +  7 ], <br>                  stack[ j +  8 ], <br>                  stack[ j +  9 ], <br>                  stack[ j + 10 ], <br>                  stack[ j + 11 ], <br>                  stack[ j + 12 ], <br>                  stack[ j + 13 ], <br>                  stack[ j + 14 ], <br>                  stack[ j + 15 ], <br>                  isprint( stack[ j +  0 ]) ? stack[ j +  0 ] : '.', <br>                  isprint( stack[ j +  1 ]) ? stack[ j +  1 ] : '.', <br>                  isprint( stack[ j +  2 ]) ? stack[ j +  2 ] : '.', <br>                  isprint( stack[ j +  3 ]) ? stack[ j +  3 ] : '.', <br>                  isprint( stack[ j +  4 ]) ? stack[ j +  4 ] : '.', <br>                  isprint( stack[ j +  5 ]) ? stack[ j +  5 ] : '.', <br>                  isprint( stack[ j +  6 ]) ? stack[ j +  6 ] : '.', <br>                  isprint( stack[ j +  7 ]) ? stack[ j +  7 ] : '.', <br>                  isprint( stack[ j +  8 ]) ? stack[ j +  8 ] : '.', <br>                  isprint( stack[ j +  9 ]) ? stack[ j +  9 ] : '.', <br>                  isprint( stack[ j + 10 ]) ? stack[ j + 10 ] : '.', <br>                  isprint( stack[ j + 11 ]) ? stack[ j + 11 ] : '.', <br>                  isprint( stack[ j + 12 ]) ? stack[ j + 12 ] : '.', <br>                  isprint( stack[ j + 13 ]) ? stack[ j + 13 ] : '.', <br>                  isprint( stack[ j + 14 ]) ? stack[ j + 14 ] : '.', <br>                  isprint( stack[ j + 15 ]) ? stack[ j + 15 ] : '.' <br>                ); <br>    } <br> <br>    lprintfs( "\r\n" ); <br>    return; <br>} <br> <br>void <br>LogStackWalk( <br>    PDEBUGPACKET dp <br>    ) <br>{ <br>    #define SAVE_EBP(f)        f.Reserved[0] <br>    #define TRAP_TSS(f)        f.Reserved[1] <br>    #define TRAP_EDITED(f)     f.Reserved[1] <br>    #define SAVE_TRAP(f)       f.Reserved[2] <br> <br>    DWORD             dwDisplacement = 0; <br>    DWORD             frames = 0; <br>    LPSTR             szSymName; <br>    IMAGEHLP_MODULE   mi; <br>    DWORD             i; <br>    DWORD             machType; <br>    CONTEXT           Context; <br>    STACKFRAME        stk; <br> <br> <br>    Context = dp-&gt;tctx-&gt;context; <br>    ZeroMemory( &amp;stk, sizeof(stk) ); <br> <br>    stk.AddrPC.Offset       = dp-&gt;tctx-&gt;pc; <br>    stk.AddrPC.Mode         = AddrModeFlat; <br> <br>#if defined(_M_IX86) <br>    machType = IMAGE_FILE_MACHINE_I386; <br>    stk.AddrStack.Offset    = dp-&gt;tctx-&gt;stack; <br>    stk.AddrStack.Mode      = AddrModeFlat; <br>    stk.AddrFrame.Offset    = dp-&gt;tctx-&gt;frame; <br>    stk.AddrFrame.Mode      = AddrModeFlat; <br>#elif defined(_M_MRX000) <br>    machType = IMAGE_FILE_MACHINE_R4000; <br>#elif defined(_M_ALPHA) <br>    machType = IMAGE_FILE_MACHINE_ALPHA; <br>#elif defined(_M_PPC) <br>    machType = IMAGE_FILE_MACHINE_POWERPC; <br>#else <br>#error( "unknown target machine" ); <br>#endif <br> <br>    lprintf( MSG_STACKTRACE ); <br> <br>    for (i=0; i&lt;100; i++) { <br>        if (!StackWalk( machType, <br>                        (HANDLE)dp, <br>                        NULL, <br>                        &amp;stk, <br>                        &amp;Context, <br>                        SwReadProcessMemory, <br>                        SwFunctionTableAccess, <br>                        SwGetModuleBase, <br>                        SwTranslateAddress )) { <br>            break; <br>        } <br>        if (SymGetSymFromAddr( dp-&gt;hProcess, stk.AddrPC.Offset, &amp;dwDisplacement, sym )) { <br>            szSymName = sym-&gt;Name; <br>        } <br>        else { <br>            szSymName = "&lt;nosymbols&gt;"; <br>        } <br>        lprintfs( "%08x %08x %08x %08x %08x %08x ", <br>                  stk.AddrFrame.Offset, <br>                  stk.AddrReturn.Offset, <br>                  stk.Params[0], <br>                  stk.Params[1], <br>                  stk.Params[2], <br>                  stk.Params[3] <br>                ); <br> <br>        if (SymGetModuleInfo( dp-&gt;hProcess, stk.AddrPC.Offset, &amp;mi )) { <br>            lprintfs( "%s!", mi.ModuleName ); <br>        } <br> <br>        lprintfs( "%s ", szSymName ); <br> <br>        if (sym &amp;&amp; (sym-&gt;Flags &amp; SYMF_OMAP_GENERATED || sym-&gt;Flags &amp; SYMF_OMAP_MODIFIED)) { <br>            lprintfs( "[omap] " ); <br>        } <br> <br>        if (stk.FuncTableEntry &amp;&amp; machType == IMAGE_FILE_MACHINE_I386) { <br>            PFPO_DATA pFpoData = (PFPO_DATA)stk.FuncTableEntry; <br>            switch (pFpoData-&gt;cbFrame) { <br>                case FRAME_FPO: <br>                    if (pFpoData-&gt;fHasSEH) { <br>                        lprintfs( "(FPO: [SEH])" ); <br>                    } else { <br>                        lprintfs( " (FPO:" ); <br>                        if (pFpoData-&gt;fUseBP) { <br>                            lprintfs( " [EBP 0x%08x]", SAVE_EBP(stk) ); <br>                        } <br>                        lprintfs(" [%d,%d,%d])", pFpoData-&gt;cdwParams, <br>                                                 pFpoData-&gt;cdwLocals, <br>                                                 pFpoData-&gt;cbRegs); <br>                    } <br>                    break; <br>                case FRAME_NONFPO: <br>                    lprintfs( "(FPO: Non-FPO [%d,%d,%d])", <br>                                 pFpoData-&gt;cdwParams, <br>                                 pFpoData-&gt;cdwLocals, <br>                                 pFpoData-&gt;cbRegs); <br>                    break; <br> <br>                case FRAME_TRAP: <br>                case FRAME_TSS: <br>                default: <br>                    lprintfs( "(UNKNOWN FPO TYPE)" ); <br>                    break; <br>            } <br>        } <br> <br>        lprintfs( "\r\n" ); <br> <br>    } <br> <br>    lprintfs( "\r\n" ); <br>    return; <br>} <br> <br> <br>void <br>LogDisassembly( <br>    PDEBUGPACKET dp, <br>    PCRASHES pCrash <br>    ) <br>{ <br>    DWORD             dwFuncAddr; <br>    DWORD             dwFuncSize; <br>    DWORD             dwDisplacement = 0; <br>    char              *szSymName; <br>    DWORD             offset; <br>    int               i; <br>    int               j; <br>    char              dbuf[1024]; <br>    BOOL              fFaultingInst; <br>    int               dwStartDis; <br>    int               dwEndDis; <br> <br> <br>    if (SymGetSymFromAddr( dp-&gt;hProcess, dp-&gt;tctx-&gt;pc, &amp;dwDisplacement, sym )) { <br>        dwFuncAddr = sym-&gt;Address; <br>        dwFuncSize = sym-&gt;Size; <br>        if (dwFuncSize &lt; 1) { <br>            dwFuncSize = 100; <br>        } <br>        szSymName = sym-&gt;Name; <br>    } <br>    else { <br>        dwFuncAddr = dp-&gt;tctx-&gt;pc - 50; <br>        dwFuncSize = 100; <br>        szSymName = "&lt;nosymbols&gt;"; <br>    } <br> <br>    if (dp-&gt;tctx-&gt;fFaultingContext) { <br>        strcpy( pCrash-&gt;szFunction, szSymName ); <br>    } <br> <br>    lprintf( MSG_FUNCTION, szSymName ); <br> <br>tryagain: <br>    // <br>    // count the number of instructions in the function <br>    // also, save the instruction number of context's pc <br>    // <br>    for (i=0,offset=dwFuncAddr,j=-1; offset&lt;dwFuncAddr+dwFuncSize; i++) { <br>        if (offset == dp-&gt;tctx-&gt;pc) { <br>            j = i; <br>        } <br>        if (!disasm( dp, &amp;offset, dbuf, TRUE )) { <br>            break; <br>        } <br>    } <br> <br>    if (j == -1) { <br>        // <br>        // we didn't find a match for the current pc <br>        // this because we don't have symbols for the current pc and <br>        // therefore had to just backup and start disassembling.  we try <br>        // to recover by adding 1 to the func addr and do it again. <br>        // eventually we will hit the pc and we will be a-ok. <br>        // <br>        dwFuncAddr++; <br>        goto tryagain; <br>    } <br> <br>    // <br>    // print the disassemled instructions.  only print the number <br>    // of instructions before and after the current pc that the <br>    // user specified in the registry options. <br>    // <br>    dwStartDis = max(0,j - (int)dp-&gt;options.dwInstructions); <br>    dwEndDis = j+(int)dp-&gt;options.dwInstructions; <br>    fFaultingInst = FALSE; <br>    for (i=0,offset=dwFuncAddr; offset&lt;dwFuncAddr+dwFuncSize; i++) { <br>        if (offset == dp-&gt;tctx-&gt;pc) { <br>            fFaultingInst = TRUE; <br>        } <br>        if (!disasm( dp, &amp;offset, dbuf, TRUE )) { <br>            break; <br>        } <br>        if (i &gt;= dwStartDis) { <br>            if (fFaultingInst &amp;&amp; dp-&gt;tctx-&gt;fFaultingContext) { <br>                fFaultingInst = FALSE; <br>                lprintf( MSG_FAULT ); <br>            } <br>            else { <br>                lprintfs( "        " ); <br>            } <br>            lprintfs( "%s\r\n", dbuf ); <br>        } <br>        if (i &gt; dwEndDis) { <br>            break; <br>        } <br>    } <br> <br>    lprintfs( "\r\n" ); <br>    return; <br>} <br> <br>void <br>AttachToActiveProcess ( <br>    PDEBUGPACKET dp <br>    ) <br>{ <br>    HANDLE              Token; <br>    PTOKEN_PRIVILEGES   NewPrivileges; <br>    BYTE                OldPriv[1024]; <br>    PBYTE               pbOldPriv; <br>    ULONG               cbNeeded; <br>    BOOLEAN             fRc; <br>    LUID                LuidPrivilege; <br> <br>    // <br>    // Make sure we have access to adjust and to get the old token privileges <br>    // <br>    if (!OpenProcessToken( GetCurrentProcess(), <br>                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, <br>                           &amp;Token)) { <br>        if (dp-&gt;options.fVisual) { <br>            FatalError( LoadRcString(IDS_DEBUGPRIV) ); <br>        } <br>        else { <br>            ExitProcess( 1 ); <br>        } <br>    } <br> <br>    cbNeeded = 0; <br> <br>    // <br>    // Initialize the privilege adjustment structure <br>    // <br> <br>    LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &amp;LuidPrivilege ); <br> <br>    NewPrivileges = <br>        (PTOKEN_PRIVILEGES)LocalAlloc(LMEM_ZEROINIT, <br>                                      sizeof(TOKEN_PRIVILEGES) + <br>                                          (1 - ANYSIZE_ARRAY) * <br>                                          sizeof(LUID_AND_ATTRIBUTES)); <br>    if (NewPrivileges == NULL) { <br>        if (dp-&gt;options.fVisual) { <br>            FatalError( LoadRcString(IDS_DEBUGPRIV) ); <br>        } <br>        else { <br>            ExitProcess( 1 ); <br>        } <br>    } <br> <br>    NewPrivileges-&gt;PrivilegeCount = 1; <br>    NewPrivileges-&gt;Privileges[0].Luid = LuidPrivilege; <br>    NewPrivileges-&gt;Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; <br> <br>    // <br>    // Enable the privilege <br>    // <br> <br>    pbOldPriv = OldPriv; <br>    fRc = AdjustTokenPrivileges( Token, <br>                                 FALSE, <br>                                 NewPrivileges, <br>                                 1024, <br>                                 (PTOKEN_PRIVILEGES)pbOldPriv, <br>                                 &amp;cbNeeded ); <br> <br>    if (!fRc) { <br> <br>        // <br>        // If the stack was too small to hold the privileges <br>        // then allocate off the heap <br>        // <br>        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) { <br> <br>            pbOldPriv = LocalAlloc(LMEM_FIXED, cbNeeded); <br>            if (pbOldPriv == NULL) { <br>                if (dp-&gt;options.fVisual) { <br>                    FatalError( LoadRcString(IDS_DEBUGPRIV) ); <br>                } <br>                else { <br>                    ExitProcess( 1 ); <br>                } <br>            } <br> <br>            fRc = AdjustTokenPrivileges( Token, <br>                                         FALSE, <br>                                         NewPrivileges, <br>                                         cbNeeded, <br>                                         (PTOKEN_PRIVILEGES)pbOldPriv, <br>                                         &amp;cbNeeded ); <br>        } <br>    } <br> <br> <br>    if (!DebugActiveProcess( dp-&gt;dwPidToDebug )) { <br>        if (dp-&gt;options.fVisual) { <br>            FatalError( LoadRcString(IDS_ATTACHFAIL) ); <br>        } <br>        else { <br>            ExitProcess( 1 ); <br>        } <br>    } <br> <br>    return; <br>} <br> <br>void <br>LogSystemInformation( <br>    PDEBUGPACKET dp <br>    ) <br>{ <br>    char          buf[1024]; <br>    SYSTEM_INFO   si; <br>    DWORD         ver; <br>    SYSINFO       mySi; <br>    DWORD         dwThreadId; <br>    HANDLE        hThread; <br> <br>    lprintf( MSG_SYSINFO_HEADER ); <br>    hThread = CreateThread( NULL, <br>                            16000, <br>                            (LPTHREAD_START_ROUTINE)SysInfoThread, <br>                            &amp;mySi, <br>                            0, <br>                            (LPDWORD)&amp;dwThreadId <br>                          ); <br>    Sleep( 0 ); <br>    if (WaitForSingleObject( hThread, 30000 ) == WAIT_TIMEOUT) { <br>        Assert(TerminateThread( hThread, 0 ) == TRUE); <br>    } <br>    CloseHandle( hThread ); <br>    lprintf( MSG_SYSINFO_COMPUTER, mySi.szMachineName ); <br>    lprintf( MSG_SYSINFO_USER, mySi.szUserName ); <br>    GetSystemInfo( &amp;si ); <br>    wsprintf( buf, "%d", si.dwNumberOfProcessors ); <br>    lprintf( MSG_SYSINFO_NUM_PROC, buf ); <br>    RegLogProcessorType(); <br>    ver = GetVersion(); <br>    wsprintf( buf, "%d.%d", LOBYTE(LOWORD(ver)), HIBYTE(LOWORD(ver)) ); <br>    lprintf( MSG_SYSINFO_WINVER, buf ); <br>    RegLogCurrentVersion(); <br>    lprintfs( "\r\n" ); <br>} <br> <br>DWORD <br>SysInfoThread( <br>    PSYSINFO si <br>    ) <br>{ <br>    DWORD len; <br> <br>    strcpy( si-&gt;szMachineName, LoadRcString( IDS_UNKNOWN_MACHINE ) ); <br>    strcpy( si-&gt;szUserName,    LoadRcString( IDS_UNKNOWN_USER ) ); <br>    len = sizeof(si-&gt;szMachineName); <br>    GetComputerName( si-&gt;szMachineName, &amp;len ); <br>    len = sizeof(si-&gt;szUserName); <br>    GetUserName( si-&gt;szUserName, &amp;len ); <br> <br>    return 0; <br>} <br> <br>DWORD <br>TerminationThread( <br>    PDEBUGPACKET dp <br>    ) <br>{ <br>    HANDLE hProcess; <br> <br>    hProcess = OpenProcess( PROCESS_TERMINATE, FALSE, dp-&gt;dwPidToDebug ); <br>    if (hProcess != NULL) { <br>        TerminateProcess( hProcess, 0 ); <br>        CloseHandle( hProcess ); <br>    } <br> <br>    return 0; <br>} <br> <br>char * <br>GetExceptionText( <br>    DWORD dwExceptionCode <br>    ) <br>{ <br>    static char buf[80]; <br>    DWORD dwFormatId = 0; <br> <br>    memset( buf, 0, sizeof(buf) ); <br> <br>    switch (dwExceptionCode) { <br>        case STATUS_SINGLE_STEP: <br>            dwFormatId = MSG_SINGLE_STEP_EXCEPTION; <br>            break; <br> <br>        case DBG_CONTROL_C: <br>            dwFormatId = MSG_CONTROLC_EXCEPTION; <br>            break; <br> <br>        case DBG_CONTROL_BREAK: <br>            dwFormatId = MSG_CONTROL_BRK_EXCEPTION; <br>            break; <br> <br>        case STATUS_ACCESS_VIOLATION: <br>            dwFormatId = MSG_ACCESS_VIOLATION_EXCEPTION; <br>            break; <br> <br>        case STATUS_STACK_OVERFLOW: <br>            dwFormatId = MSG_STACK_OVERFLOW_EXCEPTION; <br>            break; <br> <br>        case STATUS_INTEGER_DIVIDE_BY_ZERO: <br>            dwFormatId = MSG_INTEGER_DIVIDE_BY_ZERO_EXCEPTION; <br>            break; <br> <br>        case STATUS_PRIVILEGED_INSTRUCTION: <br>            dwFormatId = MSG_PRIVILEGED_INSTRUCTION_EXCEPTION; <br>            break; <br> <br>        case STATUS_ILLEGAL_INSTRUCTION: <br>            dwFormatId = MSG_ILLEGAL_INSTRUCTION_EXCEPTION; <br>            break; <br> <br>        case STATUS_IN_PAGE_ERROR: <br>            dwFormatId = MSG_IN_PAGE_IO_EXCEPTION; <br>            break; <br> <br>        case STATUS_DATATYPE_MISALIGNMENT: <br>            dwFormatId = MSG_DATATYPE_EXCEPTION; <br>            break; <br> <br>        case STATUS_POSSIBLE_DEADLOCK: <br>            dwFormatId = MSG_DEADLOCK_EXCEPTION; <br>            break; <br> <br>        case STATUS_VDM_EVENT: <br>            dwFormatId = MSG_VDM_EXCEPTION; <br>            break; <br> <br>        case STATUS_BREAKPOINT: <br>            dwFormatId = MSG_BREAKPOINT_EXCEPTION; <br>            break; <br> <br>        default: <br>            lprintfs( "\r\n" ); <br>            break; <br>    } <br> <br>    FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY, <br>                   NULL, <br>                   dwFormatId, <br>                   0, // GetUserDefaultLangID(), <br>                   buf, <br>                   sizeof(buf), <br>                   NULL <br>                 ); <br> <br>    return buf; <br>} <br> <br>BOOL <br>DoMemoryRead( <br>    PDEBUGPACKET  dp, <br>    LPVOID        addr, <br>    LPVOID        buf, <br>    DWORD         size, <br>    LPDWORD       lpcb <br>    ) <br>{ <br>    return ReadProcessMemory( dp-&gt;hProcess, addr, buf, size, lpcb ); <br>} <br> <br>LPSTR <br>ExpandPath( <br>    LPSTR lpPath <br>    ) <br>{ <br>    DWORD   len; <br>    LPSTR   p; <br> <br> <br>    len = ExpandEnvironmentStrings( lpPath, NULL, 0 ); <br>    if (!len) { <br>        return NULL; <br>    } <br> <br>    len += 1; <br>    p = malloc( len ); <br>    if (!p) { <br>        return NULL; <br>    } <br> <br>    len = ExpandEnvironmentStrings( lpPath, p, len ); <br>    if (!len) { <br>        free( p ); <br>        return NULL; <br>    } <br> <br>    return p; <br>} <br> <br>void <br>SetFaultingContext( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ) <br>{ <br>    PTHREADCONTEXT ptctx; <br>    PLIST_ENTRY List = dp-&gt;ThreadList.Flink; <br> <br>    dp-&gt;DebugEvent = *de; <br> <br>    while (List != &amp;dp-&gt;ThreadList) { <br>        ptctx = CONTAINING_RECORD(List, THREADCONTEXT, ThreadList); <br>        List = List-&gt;Flink; <br>        if (ptctx-&gt;dwThreadId == de-&gt;dwThreadId) { <br>            ptctx-&gt;fFaultingContext = TRUE; <br>            break; <br>        } <br>    } <br>} <br> <br>PTHREADCONTEXT <br>DebugEventToThreadContext( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ) <br>{ <br>    PTHREADCONTEXT ptctx; <br>    PLIST_ENTRY List = dp-&gt;ThreadList.Flink; <br> <br>    while (List != &amp;dp-&gt;ThreadList) { <br>        ptctx = CONTAINING_RECORD(List, THREADCONTEXT, ThreadList); <br>        List = List-&gt;Flink; <br>        if (ptctx-&gt;dwThreadId == de-&gt;dwThreadId) { <br>            return ptctx; <br>        } <br>    } <br>    return NULL; <br>} <br> <br>void <br>SkipOverBreakpoint( <br>    PDEBUGPACKET dp, <br>    LPDEBUG_EVENT de <br>    ) <br>{ <br>    PTHREADCONTEXT ptctx; <br>    CONTEXT Context; <br> <br>    ptctx = DebugEventToThreadContext(dp, de); <br>    Context.ContextFlags = CONTEXT_FULL; <br>    GetThreadContext(ptctx-&gt;hThread, &amp;Context); <br>    PC(&amp;Context) = (DWORD) de-&gt;u.Exception.ExceptionRecord.ExceptionAddress + BP_SIZE; <br>    SetThreadContext(ptctx-&gt;hThread, &amp;Context); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
