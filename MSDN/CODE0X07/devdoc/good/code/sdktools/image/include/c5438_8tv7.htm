<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVTYPES.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5443"></a>CVTYPES.H</h2>
<pre><code>/************************************************************************* <br>**                                                                      ** <br>**                          CVTYPES.H                                   ** <br>**                                                                      ** <br>************************************************************************** <br>**                                                                      ** <br>**  This file contains a common set of base type declarations           ** <br>**  between multiple CodeView projects.  If you touch this in one       ** <br>**  project be sure to copy it to all other projects as well.           ** <br>**                                                                      ** <br>*************************************************************************/ <br> <br>#ifndef CV_PROJECT_BASE_TYPES <br> <br>#define CV_PROJECT_BASE_TYPES <br> <br>#include "dbapiver.h" <br> <br>#ifndef _CV_INFO_INCLUDED <br>#include "cvinfo.h" <br>#endif <br> <br>#if !defined(OSDEBUG4) <br>/* <br>**  HDEP is a machine dependent size and passes as a general handle. <br>**  HIND is a machine independent sized handle and is used for things <br>**      which are passed between machines <br>** <br>*/ <br> <br>#ifdef QCWIN32 <br>    typedef HANDLE      HDEP; <br>    typedef DWORD       HIND; <br>#else <br>    DECLARE_HANDLE(HDEP); <br>    DECLARE_HANDLE(HIND); <br>#endif // QCWIN32 <br> <br> <br>typedef HDEP FAR *      LPHDEP; <br>typedef HIND FAR *      LPHIND; <br> <br> <br>/* HMEM should be avoided (HDEP should be used instead), but for now we'll <br>** define it for backwards compatibility. <br>*/ <br> <br>typedef HDEP            HMEM; <br>typedef HMEM FAR *      LPHMEM; <br>#endif // !OSDEBUG4 <br> <br>/* These values are used in the SegType field of the Expression Evaluator's <br>** TI structure, and as the third parameter to the Symbol Handler's <br>** SHGetNearestHsym function. <br>*/ <br>#define EECODE          0x01 <br>#define EEDATA          0x02 <br>#define EEANYSEG        0xFFFF <br> <br>#if !defined(OSDEBUG4) <br>/* <br>**  HPID <br>**  HTID <br>** <br>*/ <br> <br>DECLARE_HANDLE(HPID); <br>DECLARE_HANDLE(HTID); <br> <br>typedef USHORT      SEGMENT;    // 32-bit compiler doesn't like "_segment" <br>typedef ULONG       UOFF32; <br>typedef USHORT      UOFF16; <br>typedef LONG        OFF32; <br>typedef SHORT       OFF16; <br> <br>#if defined (ADDR_16) <br>    // we are operating as a 16:16 evaluator only <br>    // the address packet will be defined as an offset and a 16 bit filler <br>    typedef OFF16       OFFSET; <br>    typedef UOFF16      UOFFSET; <br>#else <br>    typedef OFF32       OFFSET; <br>    typedef UOFF32      UOFFSET; <br>#endif // ADDR_16 <br> <br>typedef UOFFSET FAR *LPUOFFSET; <br> <br>//  address definitions <br>//  the address packet is always a 16:32 address. <br> <br>typedef struct { <br>    UOFF32          off; <br>    SEGMENT         seg; <br>} address_t; <br> <br>#define SegAddrT(a)   ((a).seg) <br>#define OffAddrT(a)   ((a).off) <br>#define AddrTInit(paddrT,segSet,offSet)     \ <br>        {                                   \ <br>            SegAddrT(*(paddrT)) = segSet;   \ <br>            OffAddrT(*(paddrT)) = offSet;   \ <br>        } <br> <br>typedef struct { <br>    BYTE    fFlat   :1;         // true if address is flat <br>    BYTE    fOff32  :1;         // true if offset is 32 bits <br>    BYTE    fIsLI   :1;         // true if segment is linker index <br>    BYTE    fReal   :1;         // x86: is segment a real mode address <br>    BYTE    unused  :4;         // unused <br>} memmode_t; <br> <br>#define MODE_IS_FLAT(m)     ((m).fFlat) <br>#define MODE_IS_OFF32(m)    ((m).fOff32) <br>#define MODE_IS_LI(m)       ((m).fIsLI) <br>#define MODE_IS_REAL(m)     ((m).fReal) <br> <br>#define ModeInit(pmode,fFlat,fOff32,fLi,fRealSet)   \ <br>        {                                           \ <br>            MODE_IS_FLAT(*(pmode))    = fFlat;      \ <br>            MODE_IS_OFF32(*(pmode))   = fOff32;     \ <br>            MODE_IS_LI(*(pmode))      = fLi;        \ <br>            MODE_IS_REAL(*(pmode))    = fRealSet;   \ <br>        } <br> <br>typedef HIND    HEMI;           // Executable Module Index <br> <br>typedef struct ADDR { <br>    address_t       addr; <br>    HEMI            emi; <br>    memmode_t       mode; <br>} ADDR;             //* An address specifier <br>typedef ADDR FAR *  PADDR;      //* REVIEW: BUG: shouldn't be explicitly far <br>typedef ADDR FAR *  LPADDR; <br> <br>#define addrAddr(a)     ((a).addr) <br>#define emiAddr(a)      ((a).emi) <br>#define modeAddr(a)     ((a).mode) <br> <br>#define AddrInit(paddr,emiSet,segSet,offSet,fFlat,fOff32,fLi,fRealSet)  \ <br>        {                                                               \ <br>            AddrTInit( &amp;(addrAddr(*(paddr))), segSet, offSet );         \ <br>            emiAddr(*(paddr)) = emiSet;                                 \ <br>            ModeInit( &amp;(modeAddr(*(paddr))),fFlat,fOff32,fLi,fRealSet); \ <br>        } <br> <br>#define ADDR_IS_FLAT(a)     (MODE_IS_FLAT(modeAddr(a))) <br>#define ADDR_IS_OFF32(a)    (MODE_IS_OFF32(modeAddr(a))) <br>#define ADDR_IS_LI(a)       (MODE_IS_LI(modeAddr(a))) <br>#define ADDR_IS_REAL(a)     (MODE_IS_REAL(modeAddr(a))) <br> <br>#define ADDRSEG16(a)   { ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = FALSE; } <br>#define ADDRSEG32(a)   { ADDR_IS_FLAT(a) = FALSE; ADDR_IS_OFF32(a) = TRUE;  } <br>#define ADDRLIN32(a)   { ADDR_IS_FLAT(a) = TRUE;  ADDR_IS_OFF32(a) = TRUE;  } <br> <br>#define GetAddrSeg(a)   ((a).addr.seg) <br>#define GetAddrOff(a)   ((a).addr.off) <br>#define SetAddrSeg(a,s) ((a)-&gt;addr.seg=s) <br>#define SetAddrOff(a,o) ((a)-&gt;addr.off=o) <br> <br>// Because an ADDR has some filler areas (in the mode and the address_t), <br>// it's bad to use memcmp two ADDRs to see if they're equal.  Use this <br>// macro instead.  (I deliberately left out the test for fAddr32(), because <br>// I think it's probably not necessary when comparing.) <br>#define FAddrsEq(a1, a2)                        \ <br>    (                                           \ <br>    GetAddrOff(a1) == GetAddrOff(a2) &amp;&amp;         \ <br>    GetAddrSeg(a1) == GetAddrSeg(a2) &amp;&amp;         \ <br>    ADDR_IS_LI(a1) == ADDR_IS_LI(a2) &amp;&amp;         \ <br>    emiAddr(a1)    == emiAddr(a2)               \ <br>    ) <br> <br>//      address definitions <br>//      the address packet is always a 16:32 address. <br>#endif // !OSDEBUG4 <br> <br>typedef struct FRAME { <br>    SEGMENT         SS; <br>    address_t       BP; <br>    SEGMENT         DS; <br>    memmode_t       mode; <br>    HPID            PID; <br>    HTID            TID; <br>    address_t       SLP;    // Static link pointer <br>} FRAME; <br>typedef FRAME FAR *PFRAME;      //* REVIEW: BUG: shouldn't be explicitly far <br> <br>#define addrFrameSS(a)     ((a).SS) <br>#define addrFrameBP(a)     ((a).BP) <br>#define GetFrameBPOff(a)   ((a).BP.off) <br>#define GetFrameBPSeg(a)   ((a).BP.seg) <br>#define SetFrameBPOff(a,o) ((a).BP.off = o) <br>#define SetFrameBPSeg(a,s) ((a).BP.seg = s) <br>#define GetFrameSLPOff(a)   ((a).SLP.off) <br>#define GetFrameSLPSeg(a)   ((a).SLP.seg) <br>#define SetFrameSLPOff(a,o) ((a).SLP.off = o) <br>#define SetFrameSLPSeg(a,s) ((a).SLP.seg = s) <br>#define FRAMEMODE(a)       ((a).mode) <br>#define FRAMEPID(a)        ((a).PID) <br>#define FRAMETID(a)        ((a).TID) <br> <br>#define FrameFlat(a)       MODE_IS_FLAT((a).mode) <br>#define FrameOff32(a)      MODE_IS_OFF32((a).mode) <br>#define FrameReal(a)       MODE_IS_REAL((a).mode) <br> <br>#if !defined(OSDEBUG4) <br>/* <br>** A few public types related to the linked list manager <br>*/ <br> <br>typedef HDEP        HLLI;       //* A handle to a linked list <br>typedef HIND        HLLE;       //* A handle to a linked list entry <br> <br>typedef void (FAR PASCAL * LPFNKILLNODE)( LPV ); <br>typedef int  (FAR PASCAL * LPFNFCMPNODE)( LPV, LPV, LONG ); <br> <br>typedef USHORT      LLF;        //* Linked List Flags <br>#define llfNull             (LLF)0x0 <br>#define llfAscending        (LLF)0x1 <br>#define llfDescending       (LLF)0x2 <br>#endif // !OSDEBUG4 <br> <br>/* <br>**  EXPCALL indicates that a function should use whatever calling <br>**      convention is preferable for exported functions.  Under most <br>**      operating systems, this is PASCAL, because the name will be <br>**      left undecorated if it's PASCAL; but under NT and Win32s, <br>**      PASCAL is #defined to __stdcall, but _cdecl will leave the <br>**      name (mostly) undecorated.  (It will add an underscore, but <br>**      that's desirable under Win32s and NT, because you can't <br>**      export a name that *doesn't* have an underscore.) <br>** <br>**      Furthermore, we use _cdecl instead of CDECL because the current <br>**      NT header files don't necessarily define CDECL to _cdecl. <br>** <br>**      EXPCALL does NOT do everything that may be necessary for an <br>**      exported function (e.g. LOADDS, EXPORT, and FAR), because <br>**      it's too hard at the moment to clean up all the uses of <br>**      EXPCALL to use the same modifiers.  Someday. <br>*/ <br> <br>#if HOST32 <br>    #define EXPCALL     __stdcall <br>#else <br>    #define EXPCALL     PASCAL <br>#endif <br> <br>typedef struct _MEMINFO { <br>    ADDR addr; <br>    ADDR addrAllocBase; <br>    UOFF32 uRegionSize; <br>    DWORD dwProtect; <br>    DWORD dwState; <br>    DWORD dwType; <br>} MEMINFO; <br>typedef MEMINFO FAR * LPMEMINFO; <br> <br>/* <br>**      Return values for mtrcEndian -- big or little endian -- which <br>**      byte is [0] most or least significat byte <br>*/ <br>enum _END { <br>    endBig, <br>    endLittle <br>}; <br>typedef DWORD END; <br> <br>enum _MPT { <br>    mptix86, <br>    mptm68k, <br>    mptdaxp, <br>    mptmips, <br>    mptmppc, <br>    mptUnknown <br>}; <br>typedef DWORD MPT; <br> <br>#if !defined(OSDEBUG4) <br>#include &lt;dbgver.h&gt; <br>#endif // !OSDEBUG4 <br> <br>#endif // CV_PROJECT_BASE_TYPES </code></pre>
<p>&nbsp;</p></body>
</HTML>
