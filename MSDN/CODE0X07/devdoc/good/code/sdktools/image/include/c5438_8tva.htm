<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MIPSINST.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5446"></a>MIPSINST.H</h2>
<pre><code>/*++ BUILD Version: 0001    // Increment this if a change has global effects <br> <br>Copyright (c) 1993-1997  Microsoft Corporation <br> <br>Module Name: <br> <br>    mipsinst.h <br> <br>Abstract: <br> <br>    Mips instruction and floating constant definitions. <br> <br>Author: <br> <br>    David N. Cutler (davec) 8-May-1992 <br> <br>Revision History: <br> <br>--*/ <br> <br>#ifndef _MIPSINST_ <br>#define _MIPSINST_ <br>  <br>// <br>// Define MIPS instruction format structures. <br>// <br> <br>typedef union _MIPS_INSTRUCTION { <br>    ULONG Long; <br>    UCHAR Byte[4]; <br> <br>    struct { <br>        ULONG Target : 26; <br>        ULONG Opcode : 6; <br>    } j_format; <br> <br>    struct { <br>        LONG Simmediate : 16; <br>        ULONG Rt : 5; <br>        ULONG Rs : 5; <br>        ULONG Opcode : 6; <br>    } i_format; <br> <br>    struct { <br>        ULONG Uimmediate : 16; <br>        ULONG Rt : 5; <br>        ULONG Rs : 5; <br>        ULONG Opcode : 6; <br>    } u_format; <br> <br>    struct { <br>        ULONG Function : 6; <br>        ULONG Re : 5; <br>        ULONG Rd : 5; <br>        ULONG Rt : 5; <br>        ULONG Rs : 5; <br>        ULONG Opcode : 6; <br>    } r_format; <br> <br>    struct { <br>        ULONG Function : 6; <br>        ULONG Re : 5; <br>        ULONG Rd : 5; <br>        ULONG Rt : 5; <br>        ULONG Format : 4; <br>        ULONG Fill1 : 1; <br>        ULONG Opcode : 6; <br>    } f_format; <br> <br>    struct { <br>        ULONG Function : 6; <br>        ULONG Fd : 5; <br>        ULONG Fs : 5; <br>        ULONG Ft : 5; <br>        ULONG Format : 4; <br>        ULONG Fill1 : 1; <br>        ULONG Opcode : 6; <br>    } c_format; <br> <br>} MIPS_INSTRUCTION, *PMIPS_INSTRUCTION; <br> <br>// <br>// Define MIPS instruction opcode values. <br>// <br> <br>#define SPEC_OP 0x0                     // special opcode - use function field <br>#define BCOND_OP 0x1                    // condition branch <br>#define J_OP 0x2                        // unconditional jump <br>#define JAL_OP 0x3                      // jump and link <br> <br>#define BEQ_OP 0x4                      // branch equal <br>#define BNE_OP 0x5                      // branch not equal <br>#define BLEZ_OP 0x6                     // branch less than or equal <br>#define BGTZ_OP 0x7                     // branch greater than <br> <br>#define ADDI_OP 0x8                     // add immediate signed integer <br>#define ADDIU_OP 0x9                    // add immediate unsigned integer <br>#define SLTI_OP 0xa                     // set less than signed integer <br>#define SLTIU_OP 0xb                    // set less than unsigned integer <br> <br>#define ANDI_OP 0xc                     // and unsigned immediate integer <br>#define ORI_OP 0xd                      // or unsigned immediate integer <br>#define XORI_OP 0xe                     // exclusive or unsigned immediate <br>#define LUI_OP  0xf                     // load upper immediate integer <br> <br>#define COP0_OP 0x10                    // coprocessor 0 operation <br>#define COP1_OP 0x11                    // coprocessor 1 operation <br> <br>#define BEQL_OP 0x14                    // branch equal likely <br>#define BNEL_OP 0x15                    // branch not equal likely <br>#define BLEZL_OP 0x16                   // branch less than or equal likely <br>#define BGTZL_OP 0x17                   // branch greater than likely <br> <br>#define LDL_OP 0x1a                     // load double left integer <br>#define LDR_OP 0x1b                     // load double right integer <br> <br>#define LB_OP 0x20                      // load byte signed integer <br>#define LH_OP 0x21                      // load halfword signed integer <br>#define LWL_OP 0x22                     // load word left integer <br>#define LW_OP 0x23                      // load word integer <br> <br>#define LBU_OP 0x24                     // load byte unsigned integer <br>#define LHU_OP 0x25                     // load halfword unsigned integer <br>#define LWR_OP 0x26                     // load word right integer <br>#define LWU_OP 0x27                     // load word unsigned integer <br> <br>#define SB_OP 0x28                      // store byte integer <br>#define SH_OP 0x29                      // store halfword integer <br>#define SWL_OP 0x2a                     // store word left integer <br>#define SW_OP 0x2b                      // store word integer register <br> <br>#define SDL_OP 0x2c                     // store double left integer <br>#define SDR_OP 0x2d                     // store double right integer <br>#define SWR_OP 0x2e                     // store word right integer <br>#define CACHE_OP 0x2f                   // cache operation <br> <br>#define LL_OP 0x30                      // load linked integer register <br>#define LWC1_OP 0x31                    // load word floating <br>#define LWC2_OP 0x32                    // load word coprocessor 2 <br> <br>#define LLD_OP 0x34                     // load locked double integer <br>#define LDC1_OP 0x35                    // load word double floating <br>#define LDC2_OP 0x36                    // load double coprocessor 2 <br>#define LD_OP 0x37                      // load double integer <br> <br>#define SC_OP 0x38                      // store conditional word integer <br>#define SWC1_OP 0x39                    // store word floating <br>#define SWC2_OP 0x3a                    // store double coprocessor 2 <br> <br>#define SDC_OP 0x3c                     // store conditional double integer <br>#define SDC1_OP 0x3d                    // store double floating <br>#define SDC2_OP 0x3e                    // store double copreocessor 2 <br>#define SD_OP 0x3f                      // store double integer register <br> <br>// <br>// Define special function subopcodes. <br>// <br> <br>#define SLL_OP 0x0                      // shift left logical integer <br>#define SRL_OP 0x2                      // shift right logical integer <br>#define SRA_OP 0x3                      // shift right arithmetic integer <br> <br>#define SLLV_OP 0x4                     // shift left logical variable integer <br>#define SRLV_OP 0x6                     // shift right logical variable integer <br>#define SRAV_OP 0x7                     // shift right arithmetic variable integer <br> <br>#define JR_OP 0x8                       // jump register <br>#define JALR_OP 0x9                     // jump and link register <br> <br>#define SYSCALL_OP 0xc                  // system call trap <br>#define BREAK_OP 0xd                    // breakpoint trap <br> <br>#define MFHI_OP 0x10                    // more from high integer <br>#define MTHI_OP 0x11                    // move to high integer <br>#define MFLO_OP 0x12                    // move from low integer <br>#define MTLO_OP 0x13                    // move to low integer <br> <br>#define MULT_OP 0x18                    // multiply signed integer <br>#define MULTU_OP 0x19                   // multiply unsigned integer <br>#define DIV_OP 0x1a                     // divide signed integer <br>#define DIVU_OP 0x1b                    // divide unsigned integer <br> <br>#define ADD_OP 0x20                     // add signed integer <br>#define ADDU_OP 0x21                    // add unsigned integer <br>#define SUP_OP 0x22                     // subtract signed integer <br>#define SUBU_OP 0x23                    // subtract unsigned integer <br> <br>#define AND_OP 0x24                     // and integer <br>#define OR_OP 0x25                      // or integer <br>#define XOR_OP 0x26                     // exclusive or integer <br>#define NOR_OP 0x27                     // nor integer <br> <br>#define SLT_OP 0x2a                     // set less signed integer <br>#define SLTU_OP 0x2b                    // set less unsigned integer <br> <br>// <br>// Define branch conditional subopcodes. <br>// <br> <br>#define BLTZ_OP 0x0                     // branch less that zero integer <br>#define BGEZ_OP 0x1                     // branch greater than or equal zero integer <br>#define BLTZL_OP 0x2                    // branch less that zero integer liekly <br>#define BGEZL_OP 0x3                    // branch greater than or equal zero integer likely <br> <br>#define BLTZAL_OP 0x10                  // branch less than zero integer and link <br>#define BGEZAL_OP 0x11                  // branch greater than or equal zero integer and link <br>#define BLTZALL_OP 0x12                 // branch less than zero integer and link likely <br>#define BGEZALL_OP 0x13                 // branch greater than or equal zero integer and link likely <br> <br>// <br>// Coprocessor branch true and false subfunctions and mask values. <br>// <br> <br>#define COPz_BC_MASK 0x3e10000          // coprocessor z branch condition mask <br>#define COPz_BF 0x1000000               // coprocessor z branch false subfunction <br>#define COPz_BT 0x1010000               // coprocessor z branch true subfunction <br> <br>// <br>// Define floating coprocessor 1 opcodes. <br>// <br> <br>#define FLOAT_ADD 0                     // floating add <br>#define FLOAT_SUBTRACT 1                // floating subtract <br>#define FLOAT_MULTIPLY 2                // floating multiply <br>#define FLOAT_DIVIDE 3                  // floating divide <br>#define FLOAT_SQUARE_ROOT 4             // floating square root <br>#define FLOAT_ABSOLUTE 5                // floating absolute value <br>#define FLOAT_MOVE 6                    // floating move <br>#define FLOAT_NEGATE 7                  // floating negate <br> <br>#define FLOAT_ROUND_QUADWORD 8          // floating round to longword <br>#define FLOAT_TRUNC_QUADWORD 9          // floating truncate to longword <br>#define FLOAT_CEIL_QUADWORD 10          // floating ceiling <br>#define FLOAT_FLOOR_QUADWORD 11         // floating floor <br> <br>#define FLOAT_ROUND_LONGWORD 12         // floating round to longword <br>#define FLOAT_TRUNC_LONGWORD 13         // floating truncate to longword <br>#define FLOAT_CEIL_LONGWORD 14          // floating ceiling <br>#define FLOAT_FLOOR_LONGWORD 15         // floating floor <br> <br>#define FLOAT_ILLEGAL 16                // illegal floating opcode <br> <br>#define FLOAT_COMPARE_SINGLE 17         // floating compare single <br>#define FLOAT_COMPARE_DOUBLE 18         // floating compare double <br> <br>#define FLOAT_CONVERT_SINGLE 32         // floating convert to single <br>#define FLOAT_CONVERT_DOUBLE 33         // floating convert to double <br> <br>#define FLOAT_CONVERT_LONGWORD 36       // floating convert to longword integer <br>#define FLOAT_CONVERT_QUADWORD 37       // floating convert to quadword integer <br> <br>#define FLOAT_COMPARE 48                // starting floating compare code <br> <br>// <br>// Define floating format values. <br>// <br> <br>#define FORMAT_SINGLE 0                 // single floating format <br>#define FORMAT_DOUBLE 1                 // double floating format <br>#define FORMAT_LONGWORD 4               // longword integer format <br>#define FORMAT_QUADWORD 5               // quadword integer format <br> <br>// <br>// Define jump indirect return address register. <br>// <br> <br>#define JUMP_RA 0x3e00008               // jump indirect return address <br> <br>// <br>// Define maximum and minimum single and double exponent values. <br>// <br> <br>#define DOUBLE_MAXIMUM_EXPONENT 2047 <br>#define DOUBLE_MINIMUM_EXPONENT 0 <br>#define SINGLE_MAXIMUM_EXPONENT 255 <br>#define SINGLE_MINIMUM_EXPONENT 0 <br> <br>// <br>// Define single and double exponent bias values. <br>// <br> <br>#define SINGLE_EXPONENT_BIAS 127 <br>#define DOUBLE_EXPONENT_BIAS 1023 <br> <br>// <br>// Define the largest single and double values; <br>// <br> <br>#define DOUBLE_MAXIMUM_VALUE 0x7fefffffffffffff <br>#define DOUBLE_MAXIMUM_VALUE_LOW 0xffffffff <br>#define DOUBLE_MAXIMUM_VALUE_HIGH 0x7fefffff <br>#define SINGLE_MAXIMUM_VALUE 0x7f7fffff <br> <br>// <br>// Define single and double quite and signaling Nan values. <br>// <br> <br>#define DOUBLE_NAN_LOW 0xffffffff <br>#define DOUBLE_QUIET_NAN 0x7ff7ffff <br>#define DOUBLE_SIGNAL_NAN 0x7fffffff <br>#define SINGLE_QUIET_NAN 0x7fbfffff <br>#define SINGLE_SIGNAL_NAN 0x7fffffff <br>#define DOUBLE_INTEGER_NAN 0x7fffffffffffffff <br>#define SINGLE_INTEGER_NAN 0x7fffffff <br> <br>// <br>// Define positive single and double infinity values. <br>// <br> <br>#define DOUBLE_INFINITY_VALUE 0x7ff0000000000000 <br>#define DOUBLE_INFINITY_VALUE_LOW 0x0 <br>#define DOUBLE_INFINITY_VALUE_HIGH 0x7ff00000 <br>#define SINGLE_INFINITY_VALUE 0x7f800000 <br> <br>// <br>// Define rounding modes. <br>// <br> <br>#define ROUND_TO_NEAREST 0              // round to nearest representable value <br>#define ROUND_TO_ZERO 1                 // round toward zero <br>#define ROUND_TO_PLUS_INFINITY 2        // round toward plus infinity <br>#define ROUND_TO_MINUS_INFINITY 3       // round toward minus infinity <br> <br>#endif // MIPSINST </code></pre>
<p>&nbsp;</p></body>
</HTML>
