<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CVEXEFMT.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5441"></a>CVEXEFMT.H</h2>
<pre><code>/***    cvexefmt.h - format of CodeView information in exe <br> * <br> *      Structures, constants, etc. for reading CodeView information <br> *      from the executable. <br> * <br> */ <br> <br>//  The following structures and constants describe the format of the <br>//  CodeView Debug OMF for that will be accepted by CodeView 4.0 and <br>//  later.  These are executables with signatures of NB05, NB06 and NB08. <br>//  There is some confusion about the signatures NB03 and NB04 so none <br>//  of the utilites will accept executables with these signatures.  NB07 is <br>//  the signature for QCWIN 1.0 packed executables. <br> <br>//  All of the structures described below must start on a long word boundary <br>//  to maintain natural alignment.  Pad space can be inserted during the <br>//  write operation and the addresses adjusted without affecting the contents <br>//  of the structures. <br> <br>#ifndef _CV_INFO_INCLUDED <br>#include "cvinfo.h" <br>#endif <br> <br>#ifndef    FAR <br>#if _M_IX86 &gt;= 300 <br>#define    FAR <br>#else <br>#define FAR far <br>#endif <br>#endif <br> <br> <br>//  Type of subsection entry. <br> <br>#define sstModule           0x120 <br>#define sstTypes            0x121 <br>#define sstPublic           0x122 <br>#define sstPublicSym        0x123   // publics as symbol (waiting for link) <br>#define sstSymbols          0x124 <br>#define sstAlignSym         0x125 <br>#define sstSrcLnSeg         0x126   // because link doesn't emit SrcModule <br>#define sstSrcModule        0x127 <br>#define sstLibraries        0x128 <br>#define sstGlobalSym        0x129 <br>#define sstGlobalPub        0x12a <br>#define sstGlobalTypes      0x12b <br>#define sstMPC              0x12c <br>#define sstSegMap           0x12d <br>#define sstSegName          0x12e <br>#define sstPreComp          0x12f   // precompiled types <br>#define sstPreCompMap       0x130   // map precompiled types in global types <br>#define sstOffsetMap16      0x131 <br>#define sstOffsetMap32      0x132 <br>#define sstFileIndex        0x133   // Index of file names <br>#define sstStaticSym        0x134 <br> <br>typedef enum OMFHash { <br>    OMFHASH_NONE,           // no hashing <br>    OMFHASH_SUMUC16,        // upper case sum of chars in 16 bit table <br>    OMFHASH_SUMUC32,        // upper case sum of chars in 32 bit table <br>    OMFHASH_ADDR16,         // sorted by increasing address in 16 bit table <br>    OMFHASH_ADDR32          // sorted by increasing address in 32 bit table <br>} OMFHASH; <br> <br>//  CodeView Debug OMF signature.  The signature at the end of the file is <br>//  a negative offset from the end of the file to another signature.  At <br>//  the negative offset (base address) is another signature whose filepos <br>//  field points to the first OMFDirHeader in a chain of directories. <br>//  The NB05 signature is used by the link utility to indicated a completely <br>//  unpacked file.  The NB06 signature is used by ilink to indicate that the <br>//  executable has had CodeView information from an incremental link appended <br>//  to the executable.  The NB08 signature is used by cvpack to indicate that <br>//  the CodeView Debug OMF has been packed.  CodeView will only process <br>//  executables with the NB08 signature. <br> <br> <br>typedef struct OMFSignature { <br>    char        Signature[4];   // "NBxx" <br>    long        filepos;        // offset in file <br>} OMFSignature; <br> <br> <br> <br>//  directory information structure <br>//  This structure contains the information describing the directory. <br>//  It is pointed to by the signature at the base address or the directory <br>//  link field of a preceeding directory.  The directory entries immediately <br>//  follow this structure. <br> <br> <br>typedef struct OMFDirHeader { <br>    unsigned short  cbDirHeader;    // length of this structure <br>    unsigned short  cbDirEntry;     // number of bytes in each directory entry <br>    unsigned long   cDir;           // number of directorie entries <br>    long            lfoNextDir;     // offset from base of next directory <br>    unsigned long   flags;          // status flags <br>} OMFDirHeader; <br> <br> <br> <br> <br>//  directory structure <br>//  The data in this structure is used to reference the data for each <br>//  subsection of the CodeView Debug OMF information.  Tables that are <br>//  not associated with a specific module will have a module index of <br>//  oxffff.  These tables are the global types table, the global symbol <br>//  table, the global public table and the library table. <br> <br> <br>typedef struct OMFDirEntry { <br>    unsigned short  SubSection;     // subsection type (sst...) <br>    unsigned short  iMod;           // module index <br>    long            lfo;            // large file offset of subsection <br>    unsigned long   cb;             // number of bytes in subsection <br>} OMFDirEntry; <br> <br> <br> <br>//  information decribing each segment in a module <br> <br>typedef struct OMFSegDesc { <br>    unsigned short  Seg;            // segment index <br>    unsigned short  pad;            // pad to maintain alignment <br>    unsigned long   Off;            // offset of code in segment <br>    unsigned long   cbSeg;          // number of bytes in segment <br>} OMFSegDesc; <br> <br> <br> <br> <br>//  per module information <br>//  There is one of these subsection entries for each module <br>//  in the executable.  The entry is generated by link/ilink. <br>//  This table will probably require padding because of the <br>//  variable length module name. <br> <br>typedef struct OMFModule { <br>    unsigned short  ovlNumber;      // overlay number <br>    unsigned short  iLib;           // library that the module was linked from <br>    unsigned short  cSeg;           // count of number of segments in module <br>    char            Style[2];       // debugging style "CV" <br>    OMFSegDesc      SegInfo[1];     // describes segments in module <br>    char            Name[];         // length prefixed module name padded to <br>                                    // long word boundary <br>} OMFModule; <br> <br> <br> <br>//  Symbol hash table format <br>//  This structure immediately preceeds the global publics table <br>//  and global symbol tables. <br> <br>typedef struct OMFSymHash { <br>    unsigned short  symhash;        // symbol hash function index <br>    unsigned short  addrhash;       // address hash function index <br>    unsigned long   cbSymbol;       // length of symbol information <br>    unsigned long   cbHSym;         // length of symbol hash data <br>    unsigned long   cbHAddr;        // length of address hashdata <br>} OMFSymHash; <br> <br> <br> <br>//  Global types subsection format <br>//  This structure immediately preceeds the global types table. <br>//  The offsets in the typeOffset array are relative to the address <br>//  of ctypes.  Each type entry following the typeOffset array must <br>//  begin on a long word boundary. <br> <br>typedef struct OMFTypeFlags { <br>    unsigned long   sig     :8; <br>    unsigned long   unused  :24; <br>} OMFTypeFlags; <br> <br> <br>typedef struct OMFGlobalTypes { <br>    OMFTypeFlags    flags; <br>    unsigned long   cTypes;         // number of types <br>    unsigned long   typeOffset[];   // array of offsets to types <br>} OMFGlobalTypes; <br> <br> <br> <br> <br>//  Precompiled types mapping table <br>//  This table should be ignored by all consumers except the incremental <br>//  packer. <br> <br> <br>typedef struct OMFPreCompMap { <br>    unsigned short  FirstType;      // first precompiled type index <br>    unsigned short  cTypes;         // number of precompiled types <br>    unsigned long   signature;      // precompiled types signature <br>    unsigned short  pad; <br>    CV_typ_t        map[];          // mapping of precompiled types <br>} OMFPreCompMap; <br> <br> <br> <br> <br>//  Source line to address mapping table. <br>//  This table is generated by the link/ilink utility from line number <br>//  information contained in the object file OMF data.  This table contains <br>//  only the code contribution for one segment from one source file. <br> <br> <br>typedef struct OMFSourceLine { <br>    unsigned short  Seg;            // linker segment index <br>    unsigned short  cLnOff;         // count of line/offset pairs <br>    unsigned long   offset[1];      // array of offsets in segment <br>    unsigned short  lineNbr[1];     // array of line lumber in source <br>} OMFSourceLine; <br> <br>typedef OMFSourceLine FAR * LPSL; <br> <br> <br>//  Source file description <br>//  This table is generated by the linker <br> <br> <br>typedef struct OMFSourceFile { <br>    unsigned short  cSeg;           // number of segments from source file <br>    unsigned short  reserved;       // reserved <br>    unsigned long   baseSrcLn[1];   // base of OMFSourceLine tables <br>                                    // this array is followed by array <br>                                    // of segment start/end pairs followed by <br>                                    // an array of linker indices <br>                                    // for each segment in the file <br>    unsigned short  cFName;         // length of source file name <br>    char            Name;           // name of file padded to long boundary <br>} OMFSourceFile; <br> <br>typedef OMFSourceFile FAR * LPSF; <br> <br> <br>//  Source line to address mapping header structure <br>//  This structure describes the number and location of the <br>//  OMFAddrLine tables for a module.  The offSrcLine entries are <br>//  relative to the beginning of this structure. <br> <br> <br>typedef struct OMFSourceModule { <br>    unsigned short  cFile;          // number of OMFSourceTables <br>    unsigned short  cSeg;           // number of segments in module <br>    unsigned long   baseSrcFile[1]; // base of OMFSourceFile table <br>                                    // this array is followed by array <br>                                    // of segment start/end pairs followed <br>                                    // by an array of linker indices <br>                                    // for each segment in the module <br>} OMFSourceModule; <br> <br>typedef OMFSourceModule FAR * LPSM; <br> <br>//  sstLibraries <br> <br>typedef struct OMFLibrary { <br>    unsigned char   cbLibs;     // count of library names <br>    char            Libs[1];    // array of length prefixed lib names (first entry zero length) <br>} OMFLibrary; <br> <br> <br>// sstFileIndex - An index of all of the files contributing to an <br>//  executable. <br> <br>typedef struct OMFFileIndex { <br>    unsigned short  cmodules;       // Number of modules <br>    unsigned short  cfilerefs;      // Number of file references <br>    unsigned short  modulelist[1];  // Index to beginning of list of files <br>                                    // for module i. (0 for module w/o files) <br>    unsigned short  cfiles[1];      // Number of file names associated <br>                                    // with module i. <br>    unsigned long   ulNames[1];     // Offsets from the beginning of this <br>                                    // table to the file names <br>    char            Names[];        // The length prefixed names of files <br>} OMFFileIndex; <br> <br> <br>//  Offset mapping table <br>//  This table provides a mapping from logical to physical offsets. <br>//  This mapping is applied between the logical to physical mapping <br>//  described by the seg map table. <br> <br>typedef struct OMFOffsetMap16 { <br>    unsigned long   csegment;       // Count of physical segments <br> <br>    // The next six items are repeated for each segment <br> <br>    unsigned long   crangeLog;      // Count of logical offset ranges <br>    unsigned short  rgoffLog[1];    // Array of logical offsets <br>    short           rgbiasLog[1];   // Array of logical-&gt;physical bias <br>    unsigned long   crangePhys;     // Count of physical offset ranges <br>    unsigned short  rgoffPhys[1];   // Array of physical offsets <br>    short           rgbiasPhys[1];  // Array of physical-&gt;logical bias <br>} OMFOffsetMap16; <br> <br>typedef struct OMFOffsetMap32 { <br>    unsigned long   csection;       // Count of physical sections <br> <br>    // The next six items are repeated for each section <br> <br>    unsigned long   crangeLog;      // Count of logical offset ranges <br>    unsigned long   rgoffLog[1];    // Array of logical offsets <br>    long            rgbiasLog[1];   // Array of logical-&gt;physical bias <br>    unsigned long   crangePhys;     // Count of physical offset ranges <br>    unsigned long   rgoffPhys[1];   // Array of physical offsets <br>    long            rgbiasPhys[1];  // Array of physical-&gt;logical bias <br>} OMFOffsetMap32; <br> <br>//  Pcode support.  This subsection contains debug information generated <br>//  by the MPC utility used to process Pcode executables.  Currently <br>//  it contains a mapping table from segment index (zero based) to <br>//  frame paragraph.  MPC converts segmented exe's to non-segmented <br>//  exe's for DOS support.  To avoid backpatching all CV info, this <br>//  table is provided for the mapping.  Additional info may be provided <br>//  in the future for profiler support. <br> <br>typedef struct OMFMpcDebugInfo { <br>    unsigned short  cSeg;           // number of segments in module <br>    unsigned short  mpSegFrame[1];  // map seg (zero based) to frame <br>} OMFMpcDebugInfo; <br> <br>//  The following structures and constants describe the format of the <br>//  CodeView Debug OMF for linkers that emit executables with the NB02 <br>//  signature.  Current utilities with the exception of cvpack and cvdump <br>//  will not accept or emit executables with the NB02 signature.  Cvdump <br>//  will dump an unpacked executable with the NB02 signature.  Cvpack will <br>//  read an executable with the NB02 signature but the packed executable <br>//  will be written with the table format, contents and signature of NB08. <br> <br> <br>//  subsection type constants <br> <br>#define SSTMODULE       0x101    // Basic info. about object module <br>#define SSTPUBLIC       0x102    // Public symbols <br>#define SSTTYPES        0x103    // Type information <br>#define SSTSYMBOLS      0x104    // Symbol Data <br>#define SSTSRCLINES     0x105    // Source line information <br>#define SSTLIBRARIES    0x106    // Names of all library files used <br>#define SSTIMPORTS      0x107    // Symbols for DLL fixups <br>#define SSTCOMPACTED    0x108    // Compacted types section <br>#define SSTSRCLNSEG     0x109    // Same as source lines, contains segment <br> <br> <br>typedef struct DirEntry{ <br>    unsigned short  SubSectionType; <br>    unsigned short  ModuleIndex; <br>    long            lfoStart; <br>    unsigned short  Size; <br>} DirEntry; <br> <br> <br>//  information decribing each segment in a module <br> <br>typedef struct oldnsg { <br>    unsigned short  Seg;         // segment index <br>    unsigned short  Off;         // offset of code in segment <br>    unsigned short  cbSeg;       // number of bytes in segment <br>} oldnsg; <br> <br> <br>//  old subsection module information <br> <br>typedef struct oldsmd { <br>    oldnsg          SegInfo;     // describes first segment in module <br>    unsigned short  ovlNbr;      // overlay number <br>    unsigned short  iLib; <br>    unsigned char   cSeg;        // Number of segments in module <br>    char            reserved; <br>    unsigned char   cbName[1];   // length prefixed name of module <br>    oldnsg          arnsg[];     // cSeg-1 structures exist for alloc text or comdat code <br>} oldsmd; <br> <br>typedef struct{ <br>    unsigned short  Seg; <br>    unsigned long   Off; <br>    unsigned long   cbSeg; <br>} oldnsg32; <br> <br>typedef struct { <br>    oldnsg32        SegInfo;     // describes first segment in module <br>    unsigned short  ovlNbr;      // overlay number <br>    unsigned short  iLib; <br>    unsigned char   cSeg;        // Number of segments in module <br>    char            reserved; <br>    unsigned char   cbName[1];   // length prefixed name of module <br>    oldnsg32        arnsg[];     // cSeg-1 structures exist for alloc text or comdat code <br>} oldsmd32; <br> <br>// OMFSegMap - This table contains the mapping between the logical segment indices <br>// used in the symbol table and the physical segments where the program is loaded <br> <br>typedef struct OMFSegMapDesc { <br>    unsigned short  flags;       // descriptor flags bit field. <br>    unsigned short  ovl;         // the logical overlay number <br>    unsigned short  group;       // group index into the descriptor array <br>    unsigned short  frame;       // logical segment index - interpreted via flags <br>    unsigned short  iSegName;    // segment or group name - index into sstSegName <br>    unsigned short  iClassName;  // class name - index into sstSegName <br>    unsigned long   offset;      // byte offset of the logical within the physical segment <br>    unsigned long   cbSeg;       // byte count of the logical segment or group <br>} OMFSegMapDesc; <br> <br>typedef struct OMFSegMap { <br>    unsigned short  cSeg;        // total number of segment descriptors <br>    unsigned short  cSegLog;     // number of logical segment descriptors <br>    OMFSegMapDesc   rgDesc[0];   // array of segment descriptors <br>} OMFSegMap; </code></pre>
<p>&nbsp;</p></body>
</HTML>
