<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CRASH.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5438"></a>CRASH.H</h2>
<pre><code>/*++ <br> <br>Copyright 1993 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    crash.h <br> <br>Abstract: <br> <br>    This module implements support for handling crash dump files. <br> <br>    *** Use this file when linking againts crashxxx.lib <br> <br>Revision History: <br> <br>--*/ <br> <br>#ifndef _CRASHLIB_ <br>#define _CRASHLIB_ <br> <br>#ifdef __cplusplus <br>#pragma warning(disable:4200) <br>extern "C" { <br>#endif <br> <br> <br>typedef struct _USERMODE_CRASHDUMP_HEADER { <br>    DWORD       Signature; <br>    DWORD       ValidDump; <br>    DWORD       MajorVersion; <br>    DWORD       MinorVersion; <br>    DWORD       MachineImageType; <br>    DWORD       ThreadCount; <br>    DWORD       ModuleCount; <br>    DWORD       MemoryRegionCount; <br>    DWORD       ThreadOffset; <br>    DWORD       ModuleOffset; <br>    DWORD       DataOffset; <br>    DWORD       MemoryRegionOffset; <br>    DWORD       DebugEventOffset; <br>    DWORD       ThreadStateOffset; <br>    DWORD       Spare0; <br>    DWORD       Spare1; <br>} USERMODE_CRASHDUMP_HEADER, *PUSERMODE_CRASHDUMP_HEADER; <br> <br>typedef struct _CRASH_MODULE { <br>    DWORD       BaseOfImage; <br>    DWORD       SizeOfImage; <br>    DWORD       ImageNameLength; <br>    CHAR        ImageName[0]; <br>} CRASH_MODULE, *PCRASH_MODULE; <br> <br>typedef struct _CRASH_THREAD { <br>    DWORD       ThreadId; <br>    DWORD       SuspendCount; <br>    DWORD       PriorityClass; <br>    DWORD       Priority; <br>    DWORD       Teb; <br>    DWORD       Spare0; <br>    DWORD       Spare1; <br>    DWORD       Spare2; <br>    DWORD       Spare3; <br>    DWORD       Spare4; <br>    DWORD       Spare5; <br>    DWORD       Spare6; <br>} CRASH_THREAD, *PCRASH_THREAD; <br> <br> <br>// <br>// usermode crash dump data types <br>// <br>#define DMP_EXCEPTION                 1 // obsolete <br>#define DMP_MEMORY_BASIC_INFORMATION  2 <br>#define DMP_THREAD_CONTEXT            3 <br>#define DMP_MODULE                    4 <br>#define DMP_MEMORY_DATA               5 <br>#define DMP_DEBUG_EVENT               6 <br>#define DMP_THREAD_STATE              7 <br> <br>// <br>// usermode crashdump callback function <br>// <br>typedef BOOL  (*PDMP_CREATE_DUMP_CALLBACK)( <br>    DWORD       DataType, <br>    PVOID*      DumpData, <br>    LPDWORD     DumpDataLength, <br>    PVOID       UserData <br>    ); <br> <br>BOOL <br>DmpCreateUserDump( <br>    IN LPSTR                       CrashDumpName, <br>    IN PDMP_CREATE_DUMP_CALLBACK   DmpCallback, <br>    IN PVOID                       lpv <br>    ); <br> <br> <br>BOOL <br>DmpInitialize ( <br>    IN  LPSTR               FileName, <br>    OUT PCONTEXT            *Context, <br>    OUT PEXCEPTION_RECORD   *Exception, <br>    OUT PVOID               *DmpHeader <br>    ); <br> <br>VOID <br>DmpUnInitialize ( <br>    VOID <br>    ); <br> <br>DWORD <br>DmpReadMemory ( <br>    IN PVOID BaseAddress, <br>    IN PVOID Buffer, <br>    IN ULONG Size <br>    ); <br> <br>DWORD <br>DmpWriteMemory ( <br>    IN PVOID BaseAddress, <br>    IN PVOID Buffer, <br>    IN ULONG Size <br>    ); <br> <br>PVOID <br>VaToLocation ( <br>    IN PVOID VirtualAddress <br>    ); <br> <br>PVOID <br>PhysicalToLocation ( <br>    IN PVOID PhysicalAddress <br>    ); <br> <br>PVOID <br>PageToLocation ( <br>    IN ULONG Page <br>    ); <br> <br>ULONG <br>GetPhysicalPage ( <br>    IN PVOID PhysicalAddress <br>    ); <br> <br>BOOL <br>MapDumpFile( <br>    IN  LPSTR  FileName <br>    ); <br> <br>ULONG <br>PteToPfn ( <br>    IN ULONG Pte <br>    ); <br> <br>ULONG <br>GetPhysicalPage ( <br>    IN PVOID PhysicalAddress <br>    ); <br> <br>DWORD <br>DmpReadPhysicalMemory ( <br>    IN PVOID BaseAddress, <br>    IN PVOID Buffer, <br>    IN ULONG Size <br>    ); <br> <br>DWORD <br>DmpWritePhysicalMemory ( <br>    IN PVOID BaseAddress, <br>    IN PVOID Buffer, <br>    IN ULONG Size <br>    ); <br> <br>BOOL <br>DmpReadControlSpace( <br>    IN USHORT   Processor, <br>    IN PVOID    TargetBaseAddress, <br>    OUT PVOID   UserInterfaceBuffer, <br>    OUT ULONG   TransferCount, <br>    OUT PULONG  ActualBytesRead <br>    ); <br> <br>BOOL <br>DmpGetContext( <br>    IN  ULONG     Processor, <br>    OUT PVOID     Context <br>    ); <br> <br>INT <br>DmpGetCurrentProcessor( <br>    VOID <br>    ); <br> <br>BOOL <br>DmpGetThread( <br>    IN  ULONG           Processor, <br>    OUT PCRASH_THREAD   Thread <br>    ); <br> <br>#ifdef __cplusplus <br>} <br>#pragma warning(default:4200) <br>#endif <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
