<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SYMEDIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5456"></a>SYMEDIT.C</h2>
<pre><code>/*++ <br> <br>Copyright 1996 - 1997 Microsoft Corporation <br> <br>Module Name: <br> <br>    symedit.c <br> <br>Abstract: <br> <br> <br>Author: <br> <br>    Wesley A. Witt (wesw) 19-April-1993 <br> <br>Environment: <br> <br>    Win32, User Mode <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "symcvt.h" <br>#include "cv.h" <br>#include "strings.h" <br> <br>#include &lt;imagehlp.h&gt; <br> <br>//  prototypes for this module <br> <br>BOOL    CalculateOutputFilePointers( PIMAGEPOINTERS pi, PIMAGEPOINTERS po ); <br>void    ProcessCommandLineArgs( int argc, char *argv[] ); <br>void    PrintCopyright( void ); <br>void    PrintUsage( void ); <br>void    FatalError( int, ... ); <br>BOOL    MapOutputFile ( PPOINTERS p, char *fname, int ); <br>void    ComputeChecksum(  char *szExeFile ); <br>void    ReadDebugInfo( PPOINTERS p ); <br>void    WriteDebugInfo( PPOINTERS p, BOOL); <br>void    MungeDebugHeadersCoffToCv( PPOINTERS  p, BOOL fAddCV ); <br>void    MungeExeName( PPOINTERS p, char * szExeName ); <br>void    DoCoffToCv(char *, char *, BOOL); <br>void    DoSymToCv(char *, char *, char *, char *); <br>void    DoNameChange(char *, char *, char *); <br>void    DoExtract(char *, char *, char *); <br>void    DoStrip(char *, char *); <br> <br>IMAGE_DEBUG_DIRECTORY   DbgDirSpare; <br> <br>#define AdjustPtr(ptr) (((ptr) != NULL) ? \ <br>                          ((DWORD)ptr - (DWORD)pi-&gt;fptr + (DWORD)po-&gt;fptr) : \ <br>                          ((DWORD)(ptr))) <br> <br>  <br>int _CRTAPI1 <br>main( <br>    int        argc, <br>    char *     argv[] <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Shell for this utility. <br> <br>Arguments: <br> <br>    argc     - argument count <br>    argv     - argument pointers <br> <br> <br>Return Value: <br> <br>    0        - image was converted <br>    &gt;0       - image could not be converted <br> <br>--*/ <br> <br>{ <br>    // Scan the command line and check what operations we are doing <br> <br>    ProcessCommandLineArgs( argc, argv ); <br>    return 0; <br>} <br> <br>__inline void PrintCopyright( void ) <br>{ <br>    puts( "\nMicrosoft(R) Windows NT SymEdit Version 1.0\n" <br>          "(C) 1989-1995 Microsoft Corp. All rights reserved.\n"); <br>} <br> <br>__inline void PrintUsage( void ) <br>{ <br>    PrintCopyright(); <br>    puts ("\nUsage: SYMEDIT &lt;OPERATION&gt; -q -o&lt;file out&gt; &lt;file in&gt;\n\n" <br>          "\t&lt;OPERATION&gt; is:\n" <br>          "\tC\tModify CodeView symbol information\n" <br>          "\tN\tEdit name field\n" <br>          "\tX\tExtract debug information\n" <br>          "\tS\tStrip all debug information\n\n" <br>          "Options:\n" <br>          "\t-a\t\tAdd CodeView debug info to file\n" <br>          "\t-n&lt;name&gt;\tName to change to\n" <br>          "\t-o&lt;file&gt;\tspecify output file\n" <br>          "\t-q\t\tquiet mode\n" <br>          "\t-r\t\tReplace COFF debug info with CV info\n" <br>          "\t-s&lt;file&gt;\tSym file source"); <br>} <br> <br>void <br>ProcessCommandLineArgs( <br>    int argc, <br>    char *argv[] <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Processes the command line arguments and sets global flags to <br>    indicate the user's desired behavior. <br> <br>Arguments: <br> <br>    argc     - argument count <br>    argv     - argument pointers <br> <br> <br>Return Value: <br> <br>    void <br> <br>--*/ <br> <br>{ <br>    int     i; <br>    BOOL    fQuiet = FALSE; <br>    BOOL    fSilent = FALSE; <br>    char *  szOutputFile = NULL; <br>    char *  szInputFile = NULL; <br>    char *  szExeName = NULL; <br>    char *  szDbgFile = NULL; <br>    char *  szSymFile = NULL; <br>    int     iOperation; <br>    BOOLEAN fAddCV = FALSE; <br> <br>    // Minimun number of of arguments is 2 -- program and operation <br> <br>    if (argc &lt; 2 || <br>        (strcmp(argv[1], "-?") == 0) || <br>        (strcmp(argv[1], "?") == 0) ) <br>    { <br>        PrintUsage(); <br>        exit(1); <br>    } <br> <br>    // All operations on 1 character wide <br> <br>    if (argv[1][1] != 0) { <br>        FatalError(ERR_OP_UNKNOWN, argv[1]); <br>    } <br> <br>    // Validate the operation <br> <br>    switch( argv[1][0] ) { <br>        case 'C': <br>        case 'N': <br>        case 'X': <br>        case 'S': <br>            iOperation = argv[1][0]; <br>            break; <br>        default: <br>            FatalError(ERR_OP_UNKNOWN, argv[1]); <br>    } <br> <br>    // Parse out any other switches on the command line <br> <br>    for (i=2; i&lt;argc; i++) { <br>        if ((argv[i][0] == '-') || (argv[i][0] == '/')) { <br>            switch (toupper(argv[i][1])) { <br> <br>                // Add the CV debug information section rather than <br>                // replace the COFF section with the CV info. <br> <br>                case 'A': <br>                    fAddCV = TRUE; <br>                    break; <br> <br>                // Specify the output name for the DBG file <br> <br>                case 'D': <br>                    if (argv[i][2] == 0) { <br>                        i += 1; <br>                        szDbgFile = argv[i]; <br>                    } else { <br>                        szDbgFile = &amp;argv[i][2]; <br>                    } <br>                    break; <br> <br>                // Specify a new name to shove into the name of the <br>                // debuggee field in the Misc. Debug info field <br> <br>                case 'N': <br>                    if (argv[i][2] == 0) { <br>                        i += 1; <br>                        szExeName = argv[i]; <br>                    } else { <br>                        szExeName = &amp;argv[i][2]; <br>                    } <br>                    break; <br> <br>                // Specify the name of the output file <br> <br>                case 'O': <br>                    if (argv[i][2] == 0) { <br>                        i += 1; <br>                        szOutputFile = argv[i]; <br>                    } else { <br>                        szOutputFile = &amp;argv[i][2]; <br>                    } <br>                    break; <br> <br>                // Be quite and don't put out the banner <br> <br>                case 'Q': <br>                    fQuiet = TRUE; <br>                    fSilent = TRUE; <br>                    break; <br> <br>                //  Replace COFF debug information with CODEVIEW debug information <br> <br>                case 'R': <br>                    break; <br> <br>                //  Convert a Symbol File to CV info <br> <br>                case 'S': <br>                    if (argv[i][2] == 0) { <br>                        i += 1; <br>                        szSymFile = argv[i]; <br>                    } else { <br>                        szSymFile = &amp;argv[i][2]; <br>                    } <br>                    break; <br> <br>                // Print the command line options <br> <br>                case '?': <br>                    PrintUsage(); <br>                    exit(1); <br>                    break; <br> <br>                // Unrecognized option <br> <br>                default: <br>                    FatalError( ERR_OP_UNKNOWN, argv[i] ); <br>                    break; <br>            } <br>        } else { <br>            //  No leading switch character -- must be a file name <br> <br>            szInputFile = &amp;argv[i][0]; <br> <br>            //  Process the file(s) <br> <br>            if (!fQuiet) { <br>                PrintCopyright(); <br>                fQuiet = TRUE; <br>            } <br> <br>            if (!fSilent) { <br>                printf("processing file: %s\n", szInputFile ); <br>            } <br> <br>            //  Do switch validation cheching and setup any missing global variables <br> <br>            switch ( iOperation ) { <br> <br>                // For conversions -- there are three types <br>                // <br>                //      1.  Coff to CV -- add <br>                //      2.  Coff to CV -- replace <br>                //      3.  SYM to CV --- add <br>                //      4.  SYM to CV -- seperate file <br>                // <br>                //      Optional input file (not needed for case 4) <br>                //      Optional output file <br>                //      Optional sym file (implys sym-&gt;CV) <br>                //      Optional DBG file <br> <br>                case 'C': <br>                    if (szSymFile == NULL) { <br>                        DoCoffToCv(szInputFile, szOutputFile, fAddCV); <br>                    } else { <br>                        DoSymToCv(szInputFile, szOutputFile, szDbgFile, szSymFile); <br>                    } <br>                    szInputFile = NULL; <br>                    szOutputFile = NULL; <br>                    szDbgFile = NULL; <br>                    szSymFile = NULL; <br>                    break; <br> <br>                //  For changing the name of the debuggee -- <br>                //      Must specify input file <br>                //      Must specify new name <br>                //      Optional output file <br> <br>                case 'N': <br>                    DoNameChange(szInputFile, szOutputFile, szExeName); <br>                    szInputFile = NULL; <br>                    szOutputFile = NULL; <br>                    szExeName = NULL; <br>                    break; <br> <br>                //  For extraction of debug information <br>                //      Must specify input file <br>                //      Optional output file name <br>                //      Optional debug file name <br> <br>                case 'X': <br>                    DoExtract(szInputFile, szOutputFile, szDbgFile); <br>                    break; <br> <br>                //  For full strip of debug information <br>                //      Must specify input file <br>                //      Optional output file <br> <br>                case 'S': <br>                    DoStrip(szInputFile, szOutputFile); <br>                    break; <br>            } <br>        } <br>    } <br>    return; <br>} <br> <br>  <br>void <br>ReadDebugInfo( <br>    PPOINTERS   p <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function will go out and read in all of the debug information <br>    into memory -- this is required because the input and output <br>    files might be the same, if so then writing out informaiton may <br>    destory data we need at a later time. <br> <br>Arguments: <br> <br>    p   - Supplies a pointer to the structure describing the debug info file <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    int                         i; <br>//    int                         cb; <br>//    char *                      pb; <br>//    PIMAGE_COFF_SYMBOLS_HEADER  pCoffDbgInfo; <br> <br>    // Allocate space to save pointers to debug info <br> <br>    p-&gt;iptrs.rgpbDebugSave = (PCHAR *) malloc(p-&gt;iptrs.cDebugDir * sizeof(PCHAR)); <br>    memset(p-&gt;iptrs.rgpbDebugSave, 0, p-&gt;iptrs.cDebugDir * sizeof(PCHAR)); <br> <br>    // Check each possible debug type record <br> <br>    for (i=0; i&lt;p-&gt;iptrs.cDebugDir; i++) { <br> <br>        // If there was debug information then copy over the <br>        // description block and cache in the actual debug data. <br> <br>        if (p-&gt;iptrs.rgDebugDir[i] != NULL) { <br>            p-&gt;iptrs.rgpbDebugSave[i] = <br>              malloc( p-&gt;iptrs.rgDebugDir[i]-&gt;SizeOfData ); <br>            if (p-&gt;iptrs.rgpbDebugSave[i] == NULL) { <br>                FatalError(ERR_NO_MEMORY); <br>            } <br>            __try { <br>                memcpy(p-&gt;iptrs.rgpbDebugSave[i], <br>                       p-&gt;iptrs.fptr + <br>                       p-&gt;iptrs.rgDebugDir[i]-&gt;PointerToRawData, <br>                       p-&gt;iptrs.rgDebugDir[i]-&gt;SizeOfData ); <br>            } __except(EXCEPTION_EXECUTE_HANDLER ) { <br>                free(p-&gt;iptrs.rgpbDebugSave[i]); <br>                p-&gt;iptrs.rgpbDebugSave[i] = NULL; <br>            } <br>        } <br>    } <br>    return; <br>} <br> <br> <br>  <br>void <br>WriteDebugInfo( <br>    PPOINTERS   p, <br>    BOOL        fAddCV <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    This function will go out and read in all of the debug information <br>    into memory -- this is required because the input and output <br>    files might be the same, if so then writing out informaiton may <br>    destory data we need at a later time. <br> <br>Arguments: <br> <br>    p   - Supplies a pointer to the structure describing the debug info file <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    ULONG  PointerToDebugData = 0; //  Offset from the start of the file <br>                                   //  to the current location to write <br>                                   //  debug information out. <br>    ULONG  BaseOfDebugData = 0; <br>    int    i, flen; <br>    PIMAGE_DEBUG_DIRECTORY  pDir, pDbgDir = NULL; <br> <br>    if (p-&gt;optrs.debugSection) { <br>        BaseOfDebugData = PointerToDebugData = <br>          p-&gt;optrs.debugSection-&gt;PointerToRawData; <br>    } else if (p-&gt;optrs.sepHdr) { <br>        BaseOfDebugData =  PointerToDebugData = <br>          sizeof(IMAGE_SEPARATE_DEBUG_HEADER) + <br>          p-&gt;optrs.sepHdr-&gt;NumberOfSections * sizeof(IMAGE_SECTION_HEADER) + <br>          p-&gt;optrs.sepHdr-&gt;ExportedNamesSize; <br>    } <br> <br>    //  Step 2. If the debug information is mapped, we know this <br>    //          from the section headers, then we may need to write <br>    //          out a new debug director to point to the debug information <br> <br>    if (fAddCV) { <br>        if (p-&gt;optrs.optHdr) { <br>            p-&gt;optrs.optHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG]. <br>              VirtualAddress = p-&gt;optrs.debugSection-&gt;VirtualAddress; <br>            p-&gt;optrs.optHdr-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size += <br>              sizeof(IMAGE_DEBUG_DIRECTORY); <br>        } else if (p-&gt;optrs.sepHdr) { <br>            p-&gt;optrs.sepHdr-&gt;DebugDirectorySize += sizeof(IMAGE_DEBUG_DIRECTORY); <br>        } else { <br>            exit(1); <br>        } <br> <br>        if (p-&gt;optrs.sepHdr) { <br>            pDbgDir = (PIMAGE_DEBUG_DIRECTORY) malloc(p-&gt;optrs.cDebugDir * sizeof(IMAGE_DEBUG_DIRECTORY)); <br>            for (i=0; i&lt;p-&gt;optrs.cDebugDir; i++) { <br>                if (p-&gt;optrs.rgDebugDir[i] != NULL) { <br>                    pDbgDir[i] = *(p-&gt;optrs.rgDebugDir[i]); <br>                    p-&gt;optrs.rgDebugDir[i] = &amp;pDbgDir[i]; <br>                } <br>            } <br>        } <br>        for (i=0; i&lt;p-&gt;optrs.cDebugDir; i++) { <br>            if (p-&gt;optrs.rgDebugDir[i]) { <br>                pDir = (PIMAGE_DEBUG_DIRECTORY) (PointerToDebugData + <br>                                                 p-&gt;optrs.fptr); <br>                *pDir = *(p-&gt;optrs.rgDebugDir[i]); <br>                p-&gt;optrs.rgDebugDir[i] = pDir; <br>                PointerToDebugData += sizeof(IMAGE_DEBUG_DIRECTORY); <br>            } <br>        } <br>    } <br> <br>    // Step 3.  For every debug info type, write out the debug information <br>    //          and update any header information required <br> <br>    for (i=0; i&lt;p-&gt;optrs.cDebugDir; i++) { <br>        if (p-&gt;optrs.rgDebugDir[i] != NULL) { <br>            if (p-&gt;optrs.rgpbDebugSave[i] != NULL) { <br>                p-&gt;optrs.rgDebugDir[i]-&gt;PointerToRawData = <br>                  PointerToDebugData; <br>                if (p-&gt;optrs.debugSection) { <br>                    p-&gt;optrs.rgDebugDir[i]-&gt;AddressOfRawData = <br>                      p-&gt;optrs.debugSection-&gt;VirtualAddress + <br>                        PointerToDebugData - BaseOfDebugData; <br>                } <br>                memcpy(p-&gt;optrs.fptr + PointerToDebugData, <br>                       p-&gt;optrs.rgpbDebugSave[i], <br>                       p-&gt;optrs.rgDebugDir[i]-&gt;SizeOfData); <br> <br>                if ((i == IMAGE_DEBUG_TYPE_COFF) &amp;&amp; <br>                    (p-&gt;optrs.fileHdr != NULL)) { <br> <br>                    PIMAGE_COFF_SYMBOLS_HEADER  pCoffDbgInfo; <br>                    pCoffDbgInfo = (PIMAGE_COFF_SYMBOLS_HEADER)p-&gt;optrs.rgpbDebugSave[i]; <br>                    p-&gt;optrs.fileHdr-&gt;PointerToSymbolTable = <br>                      PointerToDebugData + pCoffDbgInfo-&gt;LvaToFirstSymbol; <br>                } <br>            } <br>            PointerToDebugData += p-&gt;optrs.rgDebugDir[i]-&gt;SizeOfData; <br>        } <br>    } <br> <br>    // Step 4.  Clean up any COFF structures if we are replacing <br>    //          the coff information with CV info. <br> <br>    if ((p-&gt;optrs.rgDebugDir[IMAGE_DEBUG_TYPE_COFF] == NULL) &amp;&amp; <br>        (p-&gt;optrs.fileHdr != NULL)) { <br> <br>        // Since there is no coff debug information -- clean out <br>        // both fields pointing to the debug info <br> <br>        p-&gt;optrs.fileHdr-&gt;PointerToSymbolTable = 0; <br>        p-&gt;optrs.fileHdr-&gt;NumberOfSymbols = 0; <br>    } <br> <br>    // Step 5.  Correct the alignments if needed.  If there is a real .debug <br>    //          section in the file (i.e. it is mapped) then update it. <br> <br>    if (p-&gt;optrs.debugSection) { <br>        p-&gt;optrs.debugSection-&gt;SizeOfRawData = <br>          FileAlign(PointerToDebugData - BaseOfDebugData); <br> <br>        // update the optional header with the new image size <br> <br>        p-&gt;optrs.optHdr-&gt;SizeOfImage = <br>          SectionAlign(p-&gt;optrs.debugSection-&gt;VirtualAddress + <br>                       p-&gt;optrs.debugSection-&gt;SizeOfRawData); <br>        p-&gt;optrs.optHdr-&gt;SizeOfInitializedData += <br>          p-&gt;optrs.debugSection-&gt;SizeOfRawData; <br>    } <br> <br>    // calculate the new file size <br> <br>    if (p-&gt;optrs.optHdr != NULL) { <br>        flen = FileAlign(PointerToDebugData); <br>    } else { <br>        flen = PointerToDebugData; <br>    } <br> <br>    // finally, update the eof pointer and close the file <br> <br>    UnmapViewOfFile( p-&gt;optrs.fptr ); <br> <br>    if (!SetFilePointer( p-&gt;optrs.hFile, flen, 0, FILE_BEGIN )) { <br>        FatalError( ERR_FILE_PTRS ); <br>    } <br> <br>    if (!SetEndOfFile( p-&gt;optrs.hFile )) { <br>        FatalError( ERR_SET_EOF ); <br>    } <br> <br>    CloseHandle( p-&gt;optrs.hFile ); <br> <br>    // Exit -- we are done. <br> <br>    return; <br>} <br> <br> <br>  <br>void <br>MungeDebugHeadersCoffToCv( <br>    PPOINTERS   p, <br>    BOOL        fAddCV <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br> <br>Return Value: <br> <br>    void <br> <br>--*/ <br> <br>{ <br>    if (!fAddCV) { <br>        CV_DIR(&amp;p-&gt;optrs) = COFF_DIR(&amp;p-&gt;optrs); <br>        COFF_DIR(&amp;p-&gt;optrs) = 0; <br>    } else { <br>        CV_DIR(&amp;p-&gt;optrs) = &amp;DbgDirSpare; <br>        *(COFF_DIR(&amp;p-&gt;optrs)) = *(COFF_DIR(&amp;p-&gt;iptrs)); <br>    }; <br> <br>    *CV_DIR(&amp;p-&gt;optrs) = *(COFF_DIR(&amp;p-&gt;iptrs)); <br>    CV_DIR(&amp;p-&gt;optrs)-&gt;Type = IMAGE_DEBUG_TYPE_CODEVIEW; <br>    CV_DIR(&amp;p-&gt;optrs)-&gt;SizeOfData =  p-&gt;pCvStart.size; <br>    p-&gt;optrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_CODEVIEW] = p-&gt;pCvStart.ptr; <br> <br>    return; <br>} <br> <br> <br>  <br>BOOL <br>MapOutputFile ( <br>    PPOINTERS p, <br>    char *fname, <br>    int cb <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Maps the output file specified by the fname argument and saves the <br>    file handle &amp; file pointer in the POINTERS structure. <br> <br> <br>Arguments: <br> <br>    p        - pointer to a POINTERS structure (see symcvt.h) <br>    fname    - ascii string for the file name <br> <br> <br>Return Value: <br> <br>    TRUE     - file mapped ok <br>    FALSE    - file could not be mapped <br> <br>--*/ <br> <br>{ <br>    BOOL    rval; <br>    HANDLE  hMap   = NULL; <br>    DWORD   oSize; <br> <br>    rval = FALSE; <br> <br>    p-&gt;optrs.hFile = CreateFile( fname, <br>                        GENERIC_READ | GENERIC_WRITE, <br>                        FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                        NULL, <br>                        OPEN_ALWAYS, <br>                        0, <br>                        NULL ); <br> <br>    if (p-&gt;optrs.hFile == INVALID_HANDLE_VALUE) { <br>       goto exit; <br>    } <br> <br>    oSize = p-&gt;iptrs.fsize; <br>    if (p-&gt;pCvStart.ptr != NULL) { <br>        oSize += p-&gt;pCvStart.size; <br>    } <br>    oSize += cb; <br>    oSize += p-&gt;iptrs.cDebugDir * sizeof(IMAGE_DEBUG_DIRECTORY); <br> <br>    hMap = CreateFileMapping( p-&gt;optrs.hFile, NULL, PAGE_READWRITE, <br>                                0, oSize, NULL ); <br> <br>    if (hMap == NULL) { <br>       goto exit; <br>    } <br> <br>    p-&gt;optrs.fptr = MapViewOfFile( hMap, FILE_MAP_WRITE, 0, 0, 0 ); <br> <br>    CloseHandle(hMap); <br> <br>    if (p-&gt;optrs.fptr == NULL) { <br>       goto exit; <br>    } <br>    rval = TRUE; <br>exit: <br>    return rval; <br>} <br> <br>BOOL <br>CalculateOutputFilePointers( <br>    PIMAGEPOINTERS pi, <br>    PIMAGEPOINTERS po <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function calculates the output file pointers based on the <br>    input file pointers.  The same address is used but they are all <br>    re-based off the output file's file pointer. <br> <br>Arguments: <br> <br>    p        - pointer to a IMAGEPOINTERS structure (see symcvt.h) <br> <br> <br>Return Value: <br> <br>    TRUE     - pointers were created <br>    FALSE    - pointers could not be created <br> <br>--*/ <br>{ <br>    int i; <br> <br>    // fixup the pointers relative the fptr for the output file <br>    po-&gt;dosHdr       = (PIMAGE_DOS_HEADER)      AdjustPtr(pi-&gt;dosHdr); <br>    po-&gt;ntHdr        = (PIMAGE_NT_HEADERS)      AdjustPtr(pi-&gt;ntHdr); <br>    po-&gt;fileHdr      = (PIMAGE_FILE_HEADER)     AdjustPtr(pi-&gt;fileHdr); <br>    po-&gt;optHdr       = (PIMAGE_OPTIONAL_HEADER) AdjustPtr(pi-&gt;optHdr); <br>    po-&gt;sectionHdrs  = (PIMAGE_SECTION_HEADER)  AdjustPtr(pi-&gt;sectionHdrs); <br>    po-&gt;sepHdr       = (PIMAGE_SEPARATE_DEBUG_HEADER) AdjustPtr(pi-&gt;sepHdr); <br>    po-&gt;debugSection = (PIMAGE_SECTION_HEADER)  AdjustPtr(pi-&gt;debugSection); <br>    po-&gt;AllSymbols   = (PIMAGE_SYMBOL)          AdjustPtr(pi-&gt;AllSymbols); <br>    po-&gt;stringTable  = (PUCHAR)                 AdjustPtr(pi-&gt;stringTable); <br> <br>    // move the data from the input file to the output file <br>    memcpy( po-&gt;fptr, pi-&gt;fptr, pi-&gt;fsize ); <br> <br>    po-&gt;cDebugDir = pi-&gt;cDebugDir; <br>    po-&gt;rgDebugDir = malloc(po-&gt;cDebugDir * sizeof(po-&gt;rgDebugDir[0])); <br>    memset(po-&gt;rgDebugDir, 0, po-&gt;cDebugDir * sizeof(po-&gt;rgDebugDir[0])); <br> <br>    for (i=0; i&lt;po-&gt;cDebugDir; i++) { <br>        po-&gt;rgDebugDir[i] = (PIMAGE_DEBUG_DIRECTORY) AdjustPtr(pi-&gt;rgDebugDir[i]); <br>    } <br>    po-&gt;rgpbDebugSave = pi-&gt;rgpbDebugSave; <br> <br>    return TRUE; <br>} <br> <br>  <br>void <br>FatalError( <br>    int  idMsg, <br>    ... <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    Prints a message string to stderr and then exits. <br> <br>Arguments: <br> <br>    s        - message string to be printed <br> <br>Return Value: <br> <br>    void <br> <br>--*/ <br> <br>{ <br>    va_list marker; <br>    char    rgchFormat[256]; <br>    char    rgch[256]; <br> <br>    LoadString(GetModuleHandle(NULL), idMsg, rgchFormat, sizeof(rgchFormat)); <br> <br>    va_start(marker, idMsg); <br>    vsprintf(rgch, rgchFormat, marker); <br>    va_end(marker); <br> <br>    fprintf(stderr, "%s\n", rgch); <br> <br>    exit(1); <br>} <br> <br> <br>void <br>ComputeChecksum( <br>    char *szExeFile <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Computes a new checksum for the image by calling imagehlp.dll <br> <br>Arguments: <br> <br>    szExeFile - exe file name <br> <br> <br>Return Value: <br> <br>    void <br> <br>--*/ <br> <br>{ <br>    DWORD              dwHeaderSum = 0; <br>    DWORD              dwCheckSum = 0; <br>    HANDLE             hFile; <br>    DWORD              cb; <br>    IMAGE_DOS_HEADER   dosHdr; <br>    IMAGE_NT_HEADERS   ntHdr; <br> <br>    if (MapFileAndCheckSum(szExeFile, &amp;dwHeaderSum, &amp;dwCheckSum) != CHECKSUM_SUCCESS) { <br>        FatalError( ERR_CHECKSUM_CALC ); <br>    } <br> <br>    hFile = CreateFile( szExeFile, <br>                        GENERIC_READ | GENERIC_WRITE, <br>                        FILE_SHARE_READ | FILE_SHARE_WRITE, <br>                        NULL, <br>                        OPEN_EXISTING, <br>                        0, <br>                        NULL <br>                      ); <br> <br>    // seek to the beginning of the file <br>    SetFilePointer( hFile, 0, 0, FILE_BEGIN ); <br> <br>    // read in the dos header <br>    if ((ReadFile(hFile, &amp;dosHdr, sizeof(dosHdr), &amp;cb, 0) == FALSE) || (cb != sizeof(dosHdr))) { <br>        FatalError( ERR_CHECKSUM_CALC ); <br>    } <br> <br>    // read in the pe header <br>    if ((dosHdr.e_magic != IMAGE_DOS_SIGNATURE) || <br>        (SetFilePointer(hFile, dosHdr.e_lfanew, 0, FILE_BEGIN) == -1L)) { <br>        FatalError( ERR_CHECKSUM_CALC ); <br>    } <br> <br>    // read in the nt header <br>    if ((!ReadFile(hFile, &amp;ntHdr, sizeof(ntHdr), &amp;cb, 0)) || (cb != sizeof(ntHdr))) { <br>        FatalError( ERR_CHECKSUM_CALC ); <br>    } <br> <br>    if (SetFilePointer(hFile, dosHdr.e_lfanew, 0, FILE_BEGIN) == -1L) { <br>        FatalError( ERR_CHECKSUM_CALC ); <br>    } <br> <br>    ntHdr.OptionalHeader.CheckSum = dwCheckSum; <br> <br>    if (!WriteFile(hFile, &amp;ntHdr, sizeof(ntHdr), &amp;cb, NULL)) { <br>        FatalError( ERR_CHECKSUM_CALC ); <br>    } <br> <br>    CloseHandle(hFile); <br>    return; <br>} <br> <br>  <br>void <br>MungeExeName( <br>    PPOINTERS   p, <br>    char *      szExeName <br>    ) <br>/*++ <br> <br>Routine Description: <br> <br>    description-of-function. <br> <br>Arguments: <br> <br>    argument-name - Supplies | Returns description of argument. <br>    . <br>    . <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    PIMAGE_DEBUG_MISC   pMiscIn; <br>    PIMAGE_DEBUG_MISC   pMiscOut; <br>    int                 cb; <br>    int                 i; <br> <br>    for (i=0; i&lt;p-&gt;iptrs.cDebugDir; i++) { <br>        if (p-&gt;optrs.rgDebugDir[i] != 0) { <br>            *(p-&gt;optrs.rgDebugDir[i]) = *(p-&gt;iptrs.rgDebugDir[i]); <br>        } <br>    } <br> <br>    pMiscIn = (PIMAGE_DEBUG_MISC) <br>      p-&gt;iptrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_MISC]; <br> <br>    if (p-&gt;optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC] == NULL) { <br>        p-&gt;optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC] = &amp;DbgDirSpare; <br>        memset(&amp;DbgDirSpare, 0, sizeof(DbgDirSpare)); <br>    } <br> <br>    pMiscOut = (PIMAGE_DEBUG_MISC) <br>      p-&gt;optrs.rgpbDebugSave[IMAGE_DEBUG_TYPE_MISC] = <br>      malloc(p-&gt;optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]-&gt;SizeOfData + <br>             strlen(szExeName)); <br>    cb = p-&gt;optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]-&gt;SizeOfData; <br> <br>    while ( cb &gt; 0 ) { <br>        if (pMiscIn-&gt;DataType == IMAGE_DEBUG_MISC_EXENAME) { <br>            pMiscOut-&gt;DataType = IMAGE_DEBUG_MISC_EXENAME; <br>            pMiscOut-&gt;Length = (sizeof(IMAGE_DEBUG_MISC) + <br>                                strlen(szExeName) + 3) &amp; ~3; <br>            pMiscOut-&gt;Unicode = FALSE; <br>            strcpy(&amp;pMiscOut-&gt;Data[0], szExeName); <br>            szExeName = NULL; <br>        } else { <br>            memcpy(pMiscOut, pMiscIn, pMiscIn-&gt;Length); <br>        } <br> <br>        p-&gt;optrs.rgDebugDir[IMAGE_DEBUG_TYPE_MISC]-&gt;SizeOfData += <br>          (pMiscOut-&gt;Length - pMiscIn-&gt;Length); <br> <br>        cb -= pMiscIn-&gt;Length; <br>        pMiscIn = (PIMAGE_DEBUG_MISC) (((char *) pMiscIn) + pMiscIn-&gt;Length); <br>        pMiscOut = (PIMAGE_DEBUG_MISC) (((char *) pMiscOut) + pMiscOut-&gt;Length); <br>    } <br> <br>    if (szExeName) { <br>        pMiscOut-&gt;DataType = IMAGE_DEBUG_MISC_EXENAME; <br>        pMiscOut-&gt;Length = (sizeof(IMAGE_DEBUG_MISC) + <br>                            strlen(szExeName) + 3) &amp; ~3; <br>        pMiscOut-&gt;Unicode = FALSE; <br>        strcpy(&amp;pMiscOut-&gt;Data[0], szExeName); <br>    } <br> <br>    return; <br>} <br> <br> <br>/***    DoCoffToCv <br> * <br> * <br> */ <br> <br>void DoCoffToCv( <br>    char * szInput, <br>    char * szOutput, <br>    BOOL fAddCV <br>    ) <br>{ <br>    POINTERS    p; <br> <br>    // Do default checking <br> <br>    if (szOutput == NULL) { <br>        szOutput = szInput; <br>    } <br> <br>    // Open the input file name and setup the pointers into the file <br> <br>    if (!MapInputFile( &amp;p, NULL, szInput )) { <br>        FatalError( ERR_OPEN_INPUT_FILE, szInput ); <br>    } <br> <br>    // Now, if we thing we are playing with PE exes then we need <br>    // to setup the pointers into the map file <br> <br>    if (!CalculateNtImagePointers( &amp;p.iptrs )) { <br>        FatalError( ERR_INVALID_PE, szInput ); <br>    } <br> <br>    // We are about to try and do the coff to cv symbol conversion. <br>    // <br>    // Verify that the operation is legal. <br>    // <br>    // 1.  We need to have coff debug information to start with <br>    // 2.  If the debug info is not mapped then we must not <br>    //     be trying to add CodeView info. <br> <br>    if ((p.iptrs.AllSymbols == NULL) || (COFF_DIR(&amp;p.iptrs) == NULL)) { <br>        FatalError( ERR_NO_COFF ); <br>    } <br> <br>    if (fAddCV &amp;&amp; (p.iptrs.debugSection == 0) &amp;&amp; (p.iptrs.sepHdr == NULL)) { <br>        FatalError( ERR_NOT_MAPPED ); <br>    } <br> <br>    // Now go out an preform the acutal conversion. <br> <br>    if (!ConvertCoffToCv( &amp;p )) { <br>        FatalError( ERR_COFF_TO_CV ); <br>    } <br> <br>    // Read in any additional debug information in the file <br> <br>    ReadDebugInfo(&amp;p); <br> <br>    // Open the output file and adjust the pointers so that we are ok. <br> <br>    if (!MapOutputFile( &amp;p, szOutput, 0 )) { <br>        FatalError( ERR_MAP_FILE, szOutput ); <br>    } <br> <br>    CalculateOutputFilePointers( &amp;p.iptrs, &amp;p.optrs ); <br> <br>    // Munge the various debug information structures to preform the correct <br>    // operations <br> <br>    MungeDebugHeadersCoffToCv( &amp;p, fAddCV ); <br> <br>    // Free our handles on the input file <br> <br>    UnMapInputFile(&amp;p); <br> <br>    // Write out the debug information to the end of the exe <br> <br>    WriteDebugInfo( &amp;p, fAddCV ); <br> <br>    // and finally compute the checksum <br> <br>    if (p.iptrs.fileHdr != NULL) { <br>        ComputeChecksum( szOutput ); <br>    } <br> <br>    return; <br>} <br> <br>/***    DoSymToCv <br> * <br> */ <br> <br>void <br>DoSymToCv( <br>    char * szInput, <br>    char * szOutput, <br>    char * szDbg, <br>    char * szSym <br>    ) <br>{ <br>    POINTERS    p; <br>    HANDLE      hFile; <br>    DWORD       cb; <br>    OFSTRUCT    ofs; <br> <br>    // Open the input file name and setup the pointers into the file <br> <br>    if (!MapInputFile( &amp;p, NULL, szSym )) { <br>        FatalError(ERR_OPEN_INPUT_FILE, szSym); <br>    } <br> <br>    // Now preform the desired operation <br> <br>    if ((szOutput == NULL) &amp;&amp; (szDbg == NULL)) { <br>        szOutput = szInput; <br>    } <br> <br>    ConvertSymToCv( &amp;p ); <br> <br>    if (szOutput) { <br>        if (szOutput != szInput) { <br>            if (OpenFile(szInput, &amp;ofs, OF_EXIST) == 0) { <br>                FatalError(ERR_OPEN_INPUT_FILE, szInput); <br>            } <br>            if (CopyFile(szInput, szOutput, FALSE) == 0) { <br>                FatalError(ERR_OPEN_WRITE_FILE, szOutput); <br>            } <br>        } <br>        hFile = CreateFile(szOutput, GENERIC_WRITE, 0, NULL, <br>                           CREATE_ALWAYS, <br>                           FILE_ATTRIBUTE_NORMAL,  NULL); <br>        if (hFile == INVALID_HANDLE_VALUE) { </code></pre>
<p>
</p>
<pre><code>FatalError(ERR_OPEN_WRITE_FILE, szOutput); <br>        } <br>        SetFilePointer(hFile, 0, 0, FILE_END); <br>    } else if (szDbg) { <br>        hFile = CreateFile(szDbg, GENERIC_WRITE, 0, NULL, <br>                               OPEN_ALWAYS, <br>                               FILE_ATTRIBUTE_NORMAL,  NULL); <br>        if (hFile == INVALID_HANDLE_VALUE) { <br>            FatalError(ERR_OPEN_WRITE_FILE, szDbg); <br>        } <br>    } <br> <br>    WriteFile(hFile, p.pCvStart.ptr, p.pCvStart.size, &amp;cb, NULL); <br>    CloseHandle(hFile); <br> <br>    return; <br>} <br> <br> <br>void <br>DoNameChange( <br>    char * szInput, <br>    char * szOutput, <br>    char * szNewName <br>    ) <br>{ <br>    POINTERS    p; <br> <br>    // Open the input file name and setup the pointers into the file <br> <br>    if (!MapInputFile( &amp;p, NULL, szInput )) { <br>        FatalError(ERR_OPEN_INPUT_FILE, szInput); <br>    } <br> <br>    // Now, if we thing we are playing with PE exes then we need <br>    // to setup the pointers into the map file <br> <br>    if (!CalculateNtImagePointers( &amp;p.iptrs )) { <br>        FatalError(ERR_INVALID_PE, szInput); <br>    } <br> <br>    //  Now preform the desired operation <br> <br>    if (szOutput == NULL) { <br>        szOutput = szInput; <br>    } <br> <br>    if (szNewName == NULL) { <br>        szNewName = szOutput; <br>    } <br> <br>    if (p.iptrs.sepHdr != NULL) { <br>        FatalError(ERR_EDIT_DBG_FILE); <br>    } <br> <br>    // Read in all of the debug information <br> <br>    ReadDebugInfo(&amp;p); <br> <br>    // Open the output file and adjust the pointers. <br> <br>    if (!MapOutputFile(&amp;p, szOutput, <br>                       sizeof(szNewName) * 2 + sizeof(IMAGE_DEBUG_MISC))) { <br>        FatalError(ERR_MAP_FILE, szOutput); <br>    } <br> <br>    CalculateOutputFilePointers(&amp;p.iptrs, &amp;p.optrs); <br> <br>    // Munge the name of the file <br> <br>    MungeExeName(&amp;p, szNewName); <br> <br>    // Close the input file <br> <br>    UnMapInputFile(&amp;p); <br> <br>    // Write out the debug information to the end of the exe <br> <br>    WriteDebugInfo(&amp;p, FALSE); <br> <br>    // and finally compute the checksum <br> <br>    if (p.iptrs.fileHdr != NULL) { <br>        ComputeChecksum( szOutput ); <br>    } <br> <br>    return; <br>} <br> <br> <br>void <br>DoStrip( <br>    char * szInput, <br>    char * szOutput <br>    ) <br>{ <br>    char OutputFile[_MAX_PATH]; <br> <br>    // Make sure we only have the path to the output file (it will always be <br>    //  named filename.DBG) <br> <br>    if (szOutput != NULL) { <br>        CopyFileA(szInput, szOutput, FALSE); <br>    } <br> <br>    SplitSymbols(szOutput, NULL, OutputFile, SPLITSYM_EXTRACT_ALL); <br> <br>    // Always delete the output file. <br> <br>    DeleteFileA(OutputFile); <br> <br>    return; <br>} <br> <br>void <br>DoExtract( <br>    char * szInput, <br>    char * szOutput, <br>    char * szDbgFile <br>    ) <br>{ <br>    char OutputFile[_MAX_PATH]; <br>    char szExt[_MAX_EXT]; <br>    char szFileName[_MAX_FNAME]; <br> <br>    if (szOutput != NULL) { <br>        CopyFileA(szInput, szOutput, FALSE); <br>        szInput = strdup(szOutput); <br>        _splitpath(szOutput, NULL, NULL, szFileName, szExt); <br>        *(szOutput + strlen(szOutput) - strlen(szFileName) - strlen(szExt)) = '\0'; <br>    } <br> <br>    SplitSymbols(szInput, szOutput, OutputFile, 0); <br> <br>    CopyFileA(szDbgFile, OutputFile, TRUE); <br> <br>    if (szOutput) { <br>        free(szInput); <br>    } <br> <br>    return; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
