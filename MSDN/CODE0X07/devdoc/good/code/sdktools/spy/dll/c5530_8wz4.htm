<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOOK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5530"></a>HOOK.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* hook.c - Windows message spy application dll <br>* <br>* Functions: <br>* <br>* DllMain() <br>* FindSpyWindow() <br>* HookProc() <br>* SpyGetMsgProc() <br>* SpyCallWndProc() <br>* DbgPrintf() <br>* <br>* Comments: <br>* <br>\*****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "..\hook.h" <br> <br> <br>PRIVATE HWND ghwndSpyHook = NULL;   // the handle back to the spy executable <br>PRIVATE SPYMSGDATA gsmd; <br>PRIVATE COPYDATASTRUCT gcds = { 0, sizeof(SPYMSGDATA), &amp;gsmd }; <br> <br> <br>PRIVATE VOID FindSpyWindow(VOID); <br> <br>#ifdef DBG <br>VOID DbgPrintf(LPTSTR fmt, ...); <br>#endif <br> <br> <br> <br>/*****************************************************************************\ <br>* DllMain (hModule,cbHeap,lpchCmdLine) <br>* <br>* Called when the libary is loaded <br>* <br>* Arguments: <br>*    PVOID hModule - Module handle for the libary. <br>*    ULONG ulReason - DLL purpose <br>*    PCONTEXT pctx - not used <br>* <br>* Returns: <br>*    TRUE - Everything is ok <br>*    FALSE- Error. <br>\*****************************************************************************/ <br> <br>BOOL <br>APIENTRY DllMain( <br>    PVOID hModule, <br>    ULONG ulReason, <br>    PCONTEXT pctx <br>    ) <br>{ <br>    UNREFERENCED_PARAMETER(hModule); <br>    UNREFERENCED_PARAMETER(pctx); <br> <br>    // <br>    // This function is called for every instance of the DLL. We must find <br>    // and store the handle to the spy window every time an instance of the <br>    // DLL is instantiated. <br>    // <br>    if ( ulReason == DLL_PROCESS_ATTACH ) { <br>        FindSpyWindow(); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* FindSpyWindow <br>* <br>* Finds the spy window and store a local copy in this instances data. <br>* This must be called everytime that a new instance of the DLL is <br>* created. <br>* <br>* Arguments: <br>*    none <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>FindSpyWindow( <br>    VOID <br>    ) <br>{ <br>    ghwndSpyHook = FindWindow(HOOKWINDOWCLASS, HOOKWINDOWNAME); <br>} <br> <br> <br>/*****************************************************************************\ <br>* HookProc( hWnd, uiMessage, wParam, lParam ) <br>* <br>* The hook proc for the windows hook being spied on <br>* <br>* Arguments: <br>*    HWND hWnd - window handle for the parent window <br>*    UINT uiMessage - message number <br>*    WPARAM wParam - message-dependent <br>*    LPARAM lParam - message-dependent <br>* <br>* Returns: <br>*    0 if processed, nonzero if ignored <br>\*****************************************************************************/ <br> <br>BOOL WINAPI <br>HookProc( <br>    HWND hwnd, <br>    UINT uiMessage, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    HWND hwndSpyingOn; <br>    HWND hwndSpyApp; <br> <br>    if (ghwndSpyHook == NULL || !IsWindow(ghwndSpyHook)) <br>    { <br>        // <br>        // Spy has terminated. Find the new window. <br>        // <br>        FindSpyWindow(); <br>    } <br> <br>    if (ghwndSpyHook != NULL &amp;&amp; hwnd != ghwndSpyHook) <br>    { <br>        hwndSpyingOn = (HWND)GetWindowLong(ghwndSpyHook, 0); <br>        hwndSpyApp = (HWND)GetWindowLong(ghwndSpyHook, sizeof(HWND)); <br>//DbgPrintf("H ghwndSpyHook:%8.8x", ghwndSpyHook); <br>//DbgPrintf("H hwndSpyingOn:%8.8x", hwndSpyingOn); <br>//DbgPrintf("H hwndSpyApp:%8.8x", hwndSpyApp); <br> <br>        // <br>        // Send the message on asynchronously for Spy to deal with if <br>        // it is the appropriate hwndSpyingOn window to spy on. <br>        // <br> <br>        if (hwndSpyingOn == hwnd <br>            || (hwndSpyingOn == HWND_ALL &amp;&amp; hwnd != hwndSpyApp <br>            &amp;&amp; !IsChild(hwndSpyApp, hwnd))) <br>        { <br>            gsmd.wParam = wParam; <br>            gsmd.lParam = lParam; <br> <br>            gcds.dwData = uiMessage; <br> <br>//DbgPrintf("H Sending Message hwnd:%8.8x msg:%d", hwnd, uiMessage); <br>            SendMessage(ghwndSpyHook, WM_COPYDATA, (WPARAM)hwnd, (LPARAM)&amp;gcds); <br>//DbgPrintf("H Sent Message hwnd:%8.8x msg:%d", hwnd, uiMessage); <br> <br>//DbgPrintf(""); <br>            return TRUE; <br>        } <br>//DbgPrintf(""); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SpyGetMsgProc <br>* <br>* The Get Message hook function. <br>* <br>\*****************************************************************************/ <br> <br>LRESULT CALLBACK <br>SpyGetMsgProc( <br>    INT hc, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    PMSG pmsg; <br> <br>    pmsg = (PMSG)lParam; <br> <br>    if (hc &gt;= 0 &amp;&amp; pmsg &amp;&amp; pmsg-&gt;hwnd) <br>    { <br>        return HookProc(pmsg-&gt;hwnd, pmsg-&gt;message, pmsg-&gt;wParam, pmsg-&gt;lParam); <br>    } <br> <br>    // <br>    // Note that CallNextHookEx ignores the first parameter (hhook) so <br>    // it is acceptable (barely) to pass in a NULL. <br>    // <br>    return CallNextHookEx(NULL, hc, wParam, lParam); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SpyCallWndProc <br>* <br>* The Call Window Proc (Send Message) hook function. <br>* <br>\*****************************************************************************/ <br> <br>LRESULT CALLBACK <br>SpyCallWndProc( <br>    INT hc, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    PCWPSTRUCT pcwps; <br> <br>    pcwps = (PCWPSTRUCT)lParam; <br> <br>    if (hc &gt;= 0 &amp;&amp; pcwps &amp;&amp; pcwps-&gt;hwnd) <br>    { <br>        return HookProc(pcwps-&gt;hwnd, pcwps-&gt;message, pcwps-&gt;wParam, pcwps-&gt;lParam); <br>    } <br> <br>    // <br>    // Note that CallNextHookEx ignores the first parameter (hhook) so <br>    // it is acceptable (barely) to pass in a NULL. <br>    // <br>    return CallNextHookEx(NULL, hc, wParam, lParam); <br>} <br> <br> <br> <br>#ifdef DBG <br>/**************************************************************************** <br>* DBGprintf <br>* <br>* This debugging function prints out a string to the debug output. <br>* An optional set of substitutional parameters can be specified, <br>* and the final output will be the processed result of these combined <br>* with the format string, just like printf.  A newline is always <br>* output after every call to this function. <br>* <br>* Arguments: <br>*   LPTSTR fmt - Format string (printf style). <br>*   ...        - Variable number of arguments. <br>* Returns: <br>*    VOID <br>\****************************************************************************/ <br> <br>VOID DbgPrintf( <br>    LPTSTR fmt, <br>    ... <br>    ) <br>{ <br>    va_list marker; <br>    TCHAR szBuf[256]; <br> <br>    va_start(marker, fmt); <br>    wvsprintf(szBuf, fmt, marker); <br>    va_end(marker); <br> <br>    OutputDebugString(szBuf); <br>    OutputDebugString(TEXT("\r\n")); <br>} <br>#endif <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
