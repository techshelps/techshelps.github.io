<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MISC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5523"></a>MISC.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* <br>* Module: misc.c <br>* <br>*   Contains miscellaneous routines for the Windows debugging Spy SDK applet. <br>* <br>* Functions: <br>* <br>*   ReadRegistry() <br>*   WriteRegistry() <br>*   Message() <br>*   SetSpyCaption() <br>*   GetWindowName() <br>*   StripExtension() <br>* <br>* Comments: <br>* <br>\*****************************************************************************/ <br> <br>#include "spy.h" <br>#include &lt;string.h&gt; <br> <br> <br>// <br>// Registry flags for the "Flags" value. <br>// <br>#define REGFLAG_OUTPUTWIN           0x00000001 <br>#define REGFLAG_OUTPUTCOM1          0x00000002 <br>#define REGFLAG_OUTPUTFILE          0x00000004 <br>#define REGFLAG_MSGSUSER            0x00000010 <br>#define REGFLAG_MSGSUNKNOWN         0x00000020 <br> <br> <br>PRIVATE HKEY ghkeySpy = NULL; <br>PRIVATE CHAR gszSpyAppKey[] = "Software\\Microsoft\\Spy"; <br>PRIVATE CHAR gszKeyPosition[] = "Position"; <br>PRIVATE CHAR gszKeyFont[] = "Font"; <br>PRIVATE CHAR gszKeyMessages[] = "Messages"; <br>PRIVATE CHAR gszKeyFileName[] = "FileName"; <br>PRIVATE CHAR gszKeyLines[] = "Lines"; <br>PRIVATE CHAR gszKeyFlags[] = "Flags"; <br>PRIVATE CHAR gszDefFileName[] = "spy.log"; <br>PRIVATE BYTE BitTable[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 }; <br> <br> <br>PRIVATE VOID GetWindowName(HWND hwnd, PSTR sz); <br>PRIVATE LPSTR StripExtension(LPSTR pszFileName); <br> <br> <br> <br> <br>/*****************************************************************************\ <br>* ReadRegistry <br>* <br>* Opens (creates if necessary) the registry key for spy preferences and then <br>* reads the last saved values. <br>* <br>* Arguments: <br>*    none <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>VOID <br>ReadRegistry( <br>    VOID <br>    ) <br>{ <br>    LOGFONT lf; <br>    BYTE abMsgs[128]; <br>    DWORD fFlags; <br>    HDC hdc; <br>    INT i; <br>    DWORD dwType; <br>    DWORD cbData; <br> <br>    RegCreateKey(HKEY_CURRENT_USER, gszSpyAppKey, &amp;ghkeySpy); <br> <br>    cbData = gwndpl.length = sizeof(gwndpl); <br>    if (!ghkeySpy || RegQueryValueEx(ghkeySpy, gszKeyPosition, NULL, &amp;dwType, <br>        (LPVOID)&amp;gwndpl, &amp;cbData) != ERROR_SUCCESS) <br>    { <br>        gwndpl.length = 0; <br>    } <br> <br> <br>    // <br>    // If the spy process is killed while the registry key is open, the <br>    //  position data can be indeterminant...  Here we catch the case that <br>    //  the reg. data is not good, and we set sensible defaults. <br>    // <br> <br>    if (gwndpl.length != sizeof(gwndpl)) <br>    { <br> <br>        gwndpl.length = sizeof(gwndpl); <br>        gwndpl.flags = 0; <br>        gwndpl.showCmd = SW_SHOWNORMAL; <br>        gwndpl.ptMinPosition.x = 0; <br>        gwndpl.ptMinPosition.y = 0; <br>        gwndpl.ptMaxPosition.x = 0; <br>        gwndpl.ptMaxPosition.y = 0; <br>        gwndpl.rcNormalPosition.left = 10; <br>        gwndpl.rcNormalPosition.top = 10; <br>        gwndpl.rcNormalPosition.right = <br>            10 + (GetSystemMetrics(SM_CXSCREEN) / 3); <br>        gwndpl.rcNormalPosition.bottom = <br>            10 + (GetSystemMetrics(SM_CYSCREEN) / 3); <br>    } <br> <br>    cbData = sizeof(lf); <br>    if (!ghkeySpy || RegQueryValueEx(ghkeySpy, gszKeyFont, NULL, &amp;dwType, <br>        (LPVOID)&amp;lf, &amp;cbData) != ERROR_SUCCESS) <br>    { <br>        hdc = GetDC(NULL); <br>        GetObject(GetStockObject(SYSTEM_FONT), sizeof(lf), &amp;lf); <br>        ReleaseDC(NULL, hdc); <br>    } <br> <br>    ghfontPrintf = CreateFontIndirect(&amp;lf); <br> <br>    cbData = sizeof(abMsgs); <br>    if (!ghkeySpy || RegQueryValueEx(ghkeySpy, gszKeyMessages, NULL, &amp;dwType, <br>        (LPVOID)abMsgs, &amp;cbData) != ERROR_SUCCESS) <br>    { <br>        // <br>        // Select all messages by default <br>        // <br>        for (i = 0; i &lt; gcMessages; i++) <br>        { <br>            gaMsgs[i].Flags |= MTF_SELECTED; <br>        } <br>    } <br>    else <br>    { <br>        for (i = 0; i &lt; gcMessages; i++) <br>        { <br>            if (abMsgs[gaMsgs[i].msg &gt;&gt; 3] &amp; BitTable[gaMsgs[i].msg &amp; 0x07]) <br>                gaMsgs[i].Flags |= MTF_SELECTED; <br>        } <br>    } <br> <br>    cbData = MAXSTRING * sizeof(TCHAR); <br>    if (!ghkeySpy || RegQueryValueEx(ghkeySpy, gszKeyFileName, NULL, &amp;dwType, <br>        (LPVOID)gszFile, &amp;cbData) != ERROR_SUCCESS) <br>    { <br>        lstrcpy(gszFile, gszDefFileName); <br>    } <br> <br>    cbData = sizeof(DWORD); <br>    if (!ghkeySpy || RegQueryValueEx(ghkeySpy, gszKeyLines, NULL, &amp;dwType, <br>        (LPVOID)&amp;gnLines, &amp;cbData) != ERROR_SUCCESS || <br>        gnLines &gt; LINES_MAX) <br>    { <br>        gnLines = LINES_MAX; <br>    } <br> <br>    cbData = sizeof(DWORD); <br>    if (!ghkeySpy || RegQueryValueEx(ghkeySpy, gszKeyFlags, NULL, &amp;dwType, <br>        (LPVOID)&amp;fFlags, &amp;cbData) != ERROR_SUCCESS) <br>    { <br>        gfOutputWin = TRUE; <br>        gfOutputCom1 = FALSE; <br>        gfOutputFile = FALSE; <br>        gfMsgsUser = TRUE; <br>        gfMsgsUnknown = TRUE; <br>    } <br>    else <br>    { <br>        if (fFlags &amp; REGFLAG_OUTPUTWIN) <br>            gfOutputWin = TRUE; <br> <br>        if (fFlags &amp; REGFLAG_OUTPUTCOM1) <br>            gfOutputCom1 = TRUE; <br> <br>        if (fFlags &amp; REGFLAG_OUTPUTFILE) <br>            gfOutputFile = TRUE; <br> <br>        if (fFlags &amp; REGFLAG_MSGSUSER) <br>            gfMsgsUser = TRUE; <br> <br>        if (fFlags &amp; REGFLAG_MSGSUNKNOWN) <br>            gfMsgsUnknown = TRUE; <br>    } <br> <br>    if (gfOutputFile) <br>    { <br>        gfhFile = _lcreat(gszFile, 0); <br>        if (gfhFile == (HFILE)-1)        //BUGBUG put up a message here. <br>            gfhFile = 0; <br>    } <br> <br>    if (gfOutputCom1) <br>    { <br>        gfhCom1 = CreateFile( <br>                "com1", <br>                GENERIC_WRITE, <br>                0,                    // exclusive access <br>                NULL,                 // no security attrs <br>                OPEN_EXISTING, <br>                FILE_ATTRIBUTE_NORMAL, <br>                NULL); <br>    } <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* WriteRegistry <br>* <br>* Writes out preference data to the registry when the app exits, then <br>* closes the registry key. <br>* <br>* Arguments: <br>*    none <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>VOID <br>WriteRegistry( <br>    VOID <br>    ) <br>{ <br>    LOGFONT lf; <br>    BYTE abMsgs[128]; <br>    INT i; <br>    DWORD fFlags; <br>    WINDOWPLACEMENT wndpl; <br> <br>    if (ghkeySpy) <br>    { <br>        wndpl.length = sizeof(WINDOWPLACEMENT); <br>        GetWindowPlacement(ghwndSpyApp, &amp;wndpl); <br>        RegSetValueEx(ghkeySpy, gszKeyPosition, 0, REG_BINARY, <br>            (LPBYTE)&amp;wndpl, sizeof(wndpl)); <br> <br>        GetObject(ghfontPrintf, sizeof(lf), &amp;lf); <br>        RegSetValueEx(ghkeySpy, gszKeyFont, 0, REG_BINARY, <br>            (LPBYTE)&amp;lf, sizeof(lf)); <br> <br>        memset(abMsgs, 0, sizeof(abMsgs)); <br>        for (i = 0; i &lt; gcMessages; i++) <br>        { <br>            if (gaMsgs[i].Flags &amp; MTF_SELECTED) <br>                abMsgs[gaMsgs[i].msg &gt;&gt; 3] |= BitTable[gaMsgs[i].msg &amp; 0x07]; <br>        } <br> <br>        RegSetValueEx(ghkeySpy, gszKeyMessages, 0, REG_BINARY, <br>            (LPBYTE)&amp;abMsgs, sizeof(abMsgs)); <br> <br>        RegSetValueEx(ghkeySpy, gszKeyFileName, 0, REG_SZ, <br>            (LPBYTE)gszFile, (lstrlen(gszFile) + 1) * sizeof(TCHAR)); <br> <br>        RegSetValueEx(ghkeySpy, gszKeyLines, 0, REG_DWORD, <br>            (LPBYTE)&amp;gnLines, sizeof(DWORD)); <br> <br>        fFlags = 0; <br>        if (gfOutputWin) <br>            fFlags |= REGFLAG_OUTPUTWIN; <br> <br>        if (gfOutputCom1) <br>            fFlags |= REGFLAG_OUTPUTCOM1; <br> <br>        if (gfOutputFile) <br>            fFlags |= REGFLAG_OUTPUTFILE; <br> <br>        if (gfMsgsUser) <br>            fFlags |= REGFLAG_MSGSUSER; <br> <br>        if (gfMsgsUnknown) <br>            fFlags |= REGFLAG_MSGSUNKNOWN; <br> <br>        RegSetValueEx(ghkeySpy, gszKeyFlags, 0, REG_DWORD, <br>            (LPBYTE)&amp;fFlags, sizeof(DWORD)); <br> <br>        RegCloseKey(ghkeySpy); <br>    } <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* Message <br>* <br>* Puts up a message box. <br>* <br>* Arguments: <br>*   UINT fuStyle    - Flags for MessageBox (MB_YESNOCANCEL, etc). <br>*   LPSTR pszFormat - Format string for the message. <br>* <br>* Returns: <br>*   Whatever MessageBox returns. <br>* <br>\*****************************************************************************/ <br> <br>INT <br>Message( <br>    UINT fuStyle, <br>    LPSTR pszFormat, <br>    ... <br>    ) <br>{ <br>    va_list marker; <br>    INT RetCode; <br>    TCHAR szT[MAXSTRING]; <br> <br>    va_start(marker, pszFormat); <br>    wvsprintf(szT, pszFormat, marker); <br>    RetCode = MessageBox(ghwndSpyApp, szT, gszWindowName, fuStyle|MB_TASKMODAL); <br>    va_end(marker); <br> <br>    return RetCode; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SetSpyCaption <br>* <br>* This routine sets the Spy app's caption bar to display info on the window <br>* that is currently being spy'ed upon. <br>* <br>* Arguments: <br>*    none <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>VOID <br>SetSpyCaption( <br>    VOID <br>    ) <br>{ <br>    CHAR szText[MAXSTRING]; <br>    CHAR szTemp[MAXSTRING]; <br> <br>    if (ghwndSpyingOn != NULL &amp;&amp; ghwndSpyingOn != HWND_ALL) <br>    { <br>        GetWindowName(ghwndSpyingOn, szTemp); <br> <br>        if (lstrlen(gszWindowName) + lstrlen(szTemp) + 3 &gt; MAXSTRING) <br>            szTemp[MAXSTRING - 3 - lstrlen(szTemp)] = 0; <br> <br>        if (gfSpyOn) <br>            wsprintf(szText, "%s - %s", gszWindowName, szTemp); <br>        else <br>            wsprintf(szText, "&lt;%s - %s&gt;", gszWindowName, szTemp); <br>    } <br>    else <br>    { <br>        lstrcpy(szText, gszWindowName); <br>    } <br> <br>    SetWindowText(ghwndSpyApp, szText); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* GetWindowName <br>* <br>* Builds the name of the window being spy'd on in the specified buffer. <br>* This will be something like "EXENAME!WindowText" or "EXENAME!Class". <br>* <br>* Arguments: <br>* <br>*    HWND hwnd - handle to the window being spy'd on. <br>*    PSTR pstr - pointer to string to return. <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>GetWindowName( <br>    HWND hwnd, <br>    PSTR sz <br>    ) <br>{ <br>    PSTR szSave = sz; <br> <br>    if (hwnd != NULL &amp;&amp; IsWindow(hwnd)) <br>    { <br>#if 0 <br>        // THIS DOES NOT WORK ON NT SINCE HINST'S ARE NOT GLOBAL <br> <br>        HINSTANCE hinst; <br> <br>        SetLastError(0); <br>        hinst = (HINSTANCE)GetWindowLong(hwnd, GWL_HINSTANCE); <br>        GetLastError(); <br> <br>        /* <br>         * Get the module name <br>         */ <br>#ifdef JAPAN <br>        //DBCS_FIX <br>        if (GetModuleFileName((HANDLE)GetWindowLong(hwnd, GWL_HINSTANCE), <br>            sz, MAXSTRING)) { <br>            //Probably this function will fail on NT <br>#else <br>        SetLastError(0); <br>        GetModuleFileName(hinst, sz, MAXSTRING); <br>        GetLastError(); <br>#endif <br>        lstrcpy(sz, StripExtension(sz)); <br> <br>        sz += lstrlen(sz); <br>        *sz++ = '!'; <br>#ifdef Japan <br>        } <br>#endif <br>        *sz = 0; <br> <br>        GetWindowText(hwnd, sz, MAXSTRING - (sz - szSave)); <br>#else // !0 <br>        GetWindowText(hwnd, sz, MAXSTRING); <br>#endif <br> <br>        /* <br>         * If the window has no caption string then use the Class name <br>         */ <br>        if (*sz == 0) <br>            GetClassName(hwnd, sz, MAXSTRING - (sz - szSave)); <br>    } <br>    else <br>    { <br>        *sz = 0; <br>    } <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* StripExtension <br>* <br>*   Strips the extension off of a filename. <br>* <br>* Arguments: <br>*   LPSTR pszFileName - File name to process. <br>* <br>* Returns: <br>*   Returns a pointer to the beginning of the filename.  The extension <br>*   will have been stripped off. <br>* <br>\*****************************************************************************/ <br> <br>PRIVATE LPSTR <br>StripExtension( <br>    LPSTR pszFileName <br>    ) <br>{ <br>    LPSTR p = pszFileName; <br> <br>    while (*p) <br>        p++; <br> <br>    while (p &gt; pszFileName &amp;&amp; *p != '\\' &amp;&amp; *p != ':') { <br>        p = CharPrev(pszFileName, p); <br>        if (*p == '.') { <br>            *p = 0; <br>        } <br>    } <br>    if (*p == '\\' || *p == ':') { <br>        p++; <br>    } <br>    return p; <br>} <br> <br> <br>/*****************************************************************************\ <br>* LoadResourceString <br>* <br>*   Loads a resource string from SPY and returns a pointer to the string. <br>* <br>* Arguments: <br>*   wId        - resource string id <br>* <br>* Returns: <br>*   Returns a pointer to the string. <br>* <br>\*****************************************************************************/ <br>LPTSTR <br>LoadResourceString( UINT wId ) <br>{ <br>    static TCHAR lpBuf[1024]; <br> <br>    LoadString( GetModuleHandle(NULL), wId, lpBuf, sizeof(lpBuf) ); <br> <br>    return lpBuf; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
