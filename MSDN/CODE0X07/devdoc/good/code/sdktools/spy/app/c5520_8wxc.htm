<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5520"></a>DIALOGS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* <br>* Module: dialogs.c <br>* <br>*   Contains dialog procs for the Windows debugging Spy SDK applet. <br>* <br>* Functions: <br>* <br>*   MyDialogBox() <br>*   AboutDlgProc() <br>*   SelectWindowDlgProc() <br>*   OutputDlgProc() <br>*   SelectFont() <br>*   MessagesDlgProc() <br>*   SelectWindowCommand() <br>*   FillListBox() <br>*   AddOneWindow() <br>*   MakeWindowName() <br>*   FindHwndInListBox() <br>*   HighlightWindow() <br>*   SelectWindowUpdateInfo() <br>*   SelectWindowEnableFields() <br>*   OutputCommand() <br>*   MessagesInit() <br>*   MessagesCommand() <br>*   MessagesUpdateCheckBoxes() <br>* <br>* Comments: <br>* <br>\*****************************************************************************/ <br> <br>#include "spy.h" <br> <br>#include &lt;commdlg.h&gt; <br> <br> <br>#define DINV                3 <br> <br> <br>PRIVATE HWND ghwndSpyingOnTemp;     // Temp when selecting hwnd to spy on. <br>PRIVATE HWND ghwndDlgBeingFilled = NULL; <br>PRIVATE BOOL bBorderOn = FALSE; <br>PRIVATE INT gcItemsSave; <br> <br> <br>PRIVATE BOOL SelectWindowCommand(HWND hwnd, INT nCmd, INT nNotifyCode); <br>PRIVATE VOID FillListBox(HWND hDlg, HWND hwndList, HWND hwnd); <br>BOOL CALLBACK AddOneWindow(HWND hwnd, LPARAM hwndListLP); <br>PRIVATE VOID MakeWindowName(HWND hwnd, LPSTR lpString, INT nStringLen); <br>PRIVATE INT FindHwndInListBox(HWND hwndList, HWND hSpyWnd); <br>PRIVATE VOID HighlightWindow(HWND hwnd, BOOL fDraw); <br>PRIVATE VOID SelectWindowUpdateInfo(HWND hDlg, HWND hwnd); <br>PRIVATE VOID SelectWindowEnableFields(HWND hwnd, BOOL fEnable); <br>PRIVATE BOOL OutputCommand(HWND hwnd, INT nCmd, INT nNotifyCode); <br>PRIVATE VOID MessagesInit(HWND hwnd); <br>PRIVATE BOOL MessagesCommand(HWND hwnd, INT nCmd, INT nNotifyCode); <br>PRIVATE VOID MessagesUpdateCheckBoxes(HWND hwnd); <br> <br> <br>CHAR szConsoleWindowClass[] = "ConsoleWindowClass"; <br> <br>/*****************************************************************************\ <br>* MyDialogBox <br>* <br>* Puts up the specified dialog. <br>* <br>* Arguments: <br>*   INT idDlg          - The resource id of the dialog to display. <br>*   DLGPROC pfnDlgProc - The dialog proc to use. <br>* <br>* Returns: <br>*   The return value from DialogBox (whatever the dialog proc passes <br>*   to EndDialog). <br>\*****************************************************************************/ <br> <br>BOOL <br>MyDialogBox( <br>    INT idDlg, <br>    DLGPROC pfnDlgProc <br>    ) <br>{ <br>    return DialogBox(ghInst, MAKEINTRESOURCE(idDlg), ghwndSpyApp, pfnDlgProc); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* AboutDlgProc <br>* <br>*   Dialog proc for the About box. <br>* <br>\*****************************************************************************/ <br> <br>BOOL CALLBACK <br>AboutDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            EndDialog(hwnd, IDOK); <br>            break; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SelectWindowDlgProc <br>* <br>* Dialog proc for the Select Window dialog.  This dialog allows the user <br>* to select which window they want to spy on. <br>* <br>* Arguments: <br>*   HWND hwnd       - Window handle of the dialog. <br>*   UINT msg        - Message sent to window. <br>*   WPARAM wParam   - Message parameter. <br>*   LPARAM lParam   - Message parameter. <br>* <br>* Returns: <br>*   The value that the dialog proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>\*****************************************************************************/ <br> <br>BOOL CALLBACK <br>SelectWindowDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    HWND hwndList; <br>    INT nIndex; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>    switch (msg) <br>    { <br>        case WM_INITDIALOG: <br>            hwndList = GetDlgItem(hwnd, DID_SELWINLIST); <br>            ghwndSpyingOnTemp = ghwndSpyingOn == HWND_ALL ? NULL : (ghwndSpyingOn == NULL ? NULL <br>                : GetParent(ghwndSpyingOn)); <br>            FillListBox(hwnd, hwndList, ghwndSpyingOnTemp); <br>            nIndex = FindHwndInListBox(hwndList, ghwndSpyingOn == HWND_ALL ? NULL <br>                : ghwndSpyingOn); <br>            SendMessage(hwndList, LB_SETCURSEL, nIndex, 0); <br>            ghwndSpyingOnTemp = (HWND)SendMessage(hwndList, LB_GETITEMDATA, nIndex, 0); <br>            SelectWindowUpdateInfo(hwnd, ghwndSpyingOnTemp); <br>            CheckDlgButton(hwnd, DID_SELWINALLWINDOWS, gfSpyAll); <br>            SelectWindowEnableFields(hwnd, !gfSpyAll); <br>            SetFocus(hwnd); <br>            HighlightWindow(ghwndSpyingOnTemp, TRUE); <br> <br>            return TRUE; <br> <br>        case WM_NCLBUTTONDOWN: <br>            if (wParam == HTCAPTION) <br>            { <br>                // <br>                // The mouse is down for a move of the dialog, so clean up the <br>                // border stuff. <br>                // <br>                if (bBorderOn) <br>                    HighlightWindow(ghwndSpyingOnTemp, FALSE); <br>            } <br> <br>            return FALSE; <br> <br>        case WM_KEYDOWN: <br>        case WM_LBUTTONUP: <br>        case WM_NCLBUTTONUP: <br>            // <br>            // The mouse is up from a move of the dialog, so put up the <br>            // border stuff again. <br>            // <br>            if (!bBorderOn) <br>                HighlightWindow(ghwndSpyingOnTemp, TRUE); <br> <br>            return FALSE; <br> <br>        case WM_CANCELMODE: <br>            return FALSE; <br> <br>        case WM_COMMAND: <br>            return SelectWindowCommand(hwnd, LOWORD(wParam), HIWORD(wParam)); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SelectWindowCommand <br>* <br>* Handles thw WM_COMMAND messages for the Select Window dialog. <br>* <br>* Arguments: <br>*   HWND hwnd       - Window handle of the dialog. <br>*   INT nCmd        - Command value. <br>*   INT nNotifyCode - The notify code. <br>* <br>* Returns: <br>*   The value that the dialog proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>\*****************************************************************************/ <br> <br>PRIVATE BOOL <br>SelectWindowCommand( <br>    HWND hwnd, <br>    INT nCmd, <br>    INT nNotifyCode <br>    ) <br>{ <br>    INT nIndex; <br>    HWND hwndList; <br>    CHAR rgString[32]; <br> <br>    switch (nCmd) <br>    { <br>        case IDOK: <br>            SetWindowToSpyOn(IsDlgButtonChecked(hwnd, DID_SELWINALLWINDOWS) ? <br>                HWND_ALL : ghwndSpyingOnTemp); <br> <br>            if (bBorderOn) <br>                HighlightWindow(ghwndSpyingOnTemp, FALSE); <br> <br>            EndDialog(hwnd, IDOK); <br>            return TRUE; <br> <br>        case IDCANCEL: <br>            if (bBorderOn) <br>                HighlightWindow(ghwndSpyingOnTemp, FALSE); <br> <br>            EndDialog(hwnd, IDCANCEL); <br>            return TRUE; <br> <br>        case DID_SELWINLIST: <br>            // <br>            // User single clicked or doubled clicked in listbox - <br>            //   Single click means select a window to spy on <br>            //   Double click means enumerate all the children of that window. <br>            // <br>            hwndList = GetDlgItem(hwnd, DID_SELWINLIST); <br>            switch (nNotifyCode) <br>            { <br>                case LBN_SELCHANGE: <br>                    // <br>                    // Single click case. Select a window to spy upon. <br>                    // <br>                    // Get the window handle, set it as the window to spy on. <br>                    // <br> <br>                    if (bBorderOn) <br>                        HighlightWindow(ghwndSpyingOnTemp, FALSE); <br> <br>                    nIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0); <br>                    ghwndSpyingOnTemp = (HWND)SendMessage(hwndList, LB_GETITEMDATA, <br>                        nIndex, 0); <br>                    SelectWindowUpdateInfo(hwnd, ghwndSpyingOnTemp); <br> <br>                    HighlightWindow(ghwndSpyingOnTemp, TRUE); <br> <br>                    break; <br> <br>                case LBN_DBLCLK: <br>                    // <br>                    // Double click case - first click has already been <br>                    // processed as single click. In this case, the user has <br>                    // requested to look at all the children of a given <br>                    // selection. <br>                    // <br>                    // Get the current selection, and check to see if it is the <br>                    // " [ parent.. ]" entry. If so, go up one level first. <br>                    // <br> <br>                    SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>                    if (bBorderOn) <br>                        HighlightWindow(ghwndSpyingOnTemp, FALSE); <br> <br>                    nIndex = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0); <br>                    ghwndSpyingOnTemp = (HWND)SendMessage(hwndList, LB_GETITEMDATA, <br>                        nIndex, 0); <br>                    SendMessage(hwndList, LB_GETTEXT, nIndex, (LPARAM)rgString); <br> <br>                    if (rgString[0] == ' ') <br>                    { <br>                        // At top?  If so, we are done. <br>                        if (ghwndSpyingOnTemp == NULL) <br>                        { <br>                            SetCursor(LoadCursor(NULL, IDC_ARROW)); <br>                            break; <br>                        } <br> <br>                        ghwndSpyingOnTemp = GetParent(ghwndSpyingOnTemp); <br>                    } <br> <br>                    SendMessage(hwndList, LB_RESETCONTENT, 0, 0); <br>                    FillListBox(hwnd, hwndList, ghwndSpyingOnTemp); <br> <br>                    nIndex = FindHwndInListBox(hwndList, ghwndSpyingOnTemp); <br>                    SendMessage(hwndList, LB_SETCURSEL, nIndex, 0); <br>                    ghwndSpyingOnTemp = (HWND)SendMessage(hwndList, LB_GETITEMDATA, <br>                        nIndex, 0); <br>                    HighlightWindow(ghwndSpyingOnTemp,TRUE); <br>                    SelectWindowUpdateInfo(hwnd, ghwndSpyingOnTemp); <br>                    SetCursor(LoadCursor(NULL, IDC_ARROW)); <br>                    break; <br>            } <br> <br>            break; <br> <br>        case DID_SELWINALLWINDOWS: <br>            SelectWindowEnableFields(hwnd, <br>                !IsDlgButtonChecked(hwnd, DID_SELWINALLWINDOWS)); <br> <br>            break; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* FillListBox <br>* <br>* Fills the listbox in the Select Window dialog with the names of <br>* the child windows of the given window. <br>* <br>* Arguments: <br>*   hDlg     - Window handle of the dialog window <br>*   hwndList - Handle to the listbox within the dialog. <br>*   hwnd     - Parent whose children to enumerate. <br>* <br>* Returns: <br>*   VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>FillListBox( <br>    HWND hDlg, <br>    HWND hwndList, <br>    HWND hwnd <br>    ) <br>{ <br>    INT nIndex; <br> <br>    // <br>    // First fill the list box with child windows <br>    // <br>    // Make sure we display the list box after things are added. <br>    // <br> <br>    SendMessage(hwndList, WM_SETREDRAW, 0, 0); <br> <br>    // <br>    // remember which dialog we are processing <br>    // <br> <br>    ghwndDlgBeingFilled = hDlg; <br> <br>    if (hwnd == NULL) <br>    { <br>        // <br>        // Enumerate the top level separately... gross unsymmetry, but <br>        // hey. <br>        // <br>        EnumWindows(AddOneWindow, (LPARAM)hwndList); <br>    } <br>    else <br>    { <br>        EnumChildWindows(hwnd, AddOneWindow, (LPARAM)hwndList); <br>    } <br> <br>    // <br>    // Now give the user a method of getting back to the parent. The space at <br>    // the beginning of the " [parent]" string identifies the entry as the <br>    // parent entry and makes it different from all the other entries since <br>    // the others start with a handle number of some sort. <br>    // <br> <br>    nIndex = SendMessage(hwndList, LB_ADDSTRING, 0, <br>                        (LPARAM)(LPCTSTR)LoadResourceString(IDS_PARENT)); <br>    SendMessage(hwndList, LB_SETITEMDATA, nIndex, (LONG)hwnd); <br> <br>    // <br>    // Now do the redraw... <br>    // <br> <br>    SendMessage(hwndList, WM_SETREDRAW, 1, 0); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* AddOneWindow <br>* <br>* Gets the windows to add to the list of windows to spy on. <br>* <br>* Arguments: <br>*     HWND hwnd - handle of the window to add. <br>*     HWND hwndList - handle to the listbox. <br>* <br>* Returns: <br>*     TRUE - if a window was created. <br>\*****************************************************************************/ <br>#define CCH_RGBUF   32 <br> <br>BOOL CALLBACK <br>AddOneWindow( <br>    HWND hwnd, <br>    LPARAM hwndListLP <br>    ) <br>{ <br>    CHAR rgBuf[CCH_RGBUF]; <br>    INT nIndex; <br>    HWND htemp; <br>    HWND hwndList = (HWND)hwndListLP; <br>    // <br>    // Make sure we don't add any window that has anything to do with <br>    // the dialog or any other spy window <br>    // <br> <br>    htemp = GetParent(hwnd); <br> <br>    // Don't put console windows in the list since they can not be hooked <br>    if (GetClassName(hwnd, rgBuf, CCH_RGBUF) != 0 &amp;&amp; <br>        strcmp(rgBuf, szConsoleWindowClass) == 0 ) <br>    { <br>        return 1; <br>    } <br> <br>    // Don't put windows that belong to spy in the list <br>    if (hwnd == ghwndDlgBeingFilled || htemp == ghwndDlgBeingFilled <br>        || hwnd == ghwndSpyApp <br>        || htemp == ghwndSpyApp || hwnd == ghwndPrintf || htemp == ghwndPrintf <br>        || hwnd == ghwndSpyHook || htemp == ghwndSpyHook) <br>    { <br>        return 1; <br>    } <br> <br>    MakeWindowName(hwnd, rgBuf, CCH_RGBUF); <br> <br>    nIndex = SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)rgBuf); <br> <br>    if (nIndex == LB_ERR || nIndex == LB_ERRSPACE) <br>        return 0; <br> <br>    if (SendMessage(hwndList, LB_SETITEMDATA, nIndex, (LPARAM)hwnd) == LB_ERR) <br>        return 0; <br> <br>    return 1; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* MakeWindowName <br>* <br>* Builds the window name from the window handle passed in. <br>* <br>* Arguments: <br>*     HWND hwnd - handle to the window. <br>*     LPSTR lpString - String to put window name into. <br>*     INT nSTringLen - Length of window string. <br>* <br>* Returns: <br>*     VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>MakeWindowName( <br>    HWND hwnd, <br>    LPSTR lpString, <br>    INT nStringLen <br>    ) <br>{ <br>    wsprintf(lpString, "%8.8lX:", hwnd); <br> <br>    if (hwnd == NULL || !IsWindow(hwnd)) <br>    { <br>        lstrcat(lpString, "!!!"); <br>    } <br>    else <br>    { <br>        GetWindowText(hwnd, lpString + 9, nStringLen - 9); <br>    } <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* FindHwndInListBox <br>* <br>* Gets the window from the list of windows in the listbox. <br>* <br>* Arguments: <br>*     HWND hwndList - handle to the listbox. <br>*     HWND hSpyWnd - handle to the spy window. <br>* <br>* Returns: <br>*     INT - Index to the window in the listbox.  <br>\*****************************************************************************/ <br> <br>PRIVATE INT <br>FindHwndInListBox( <br>    HWND hwndList, <br>    HWND hSpyWnd <br>    ) <br>{ <br>    CHAR rgBuf[9]; <br>    INT nIndex; <br> <br>    wsprintf(rgBuf, "%08lX", (LONG)hSpyWnd); <br> <br>    nIndex = SendMessage(hwndList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)rgBuf); <br> <br>    if (nIndex == LB_ERR) <br>        nIndex = 0; <br> <br>    return nIndex; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* HighlightWindow <br>* <br>* Used to temporarily highlight the window that the user has selected from <br>* the Select Window dialog.  It does this by inverting a border around the <br>* window. <br>* <br>* Arguments: <br>*     HWND hwnd - handle to the selected window. <br>*     BOOL fdraw - whether to draw the window inverted on non-inverted. <br>* <br>* Returns: <br>*     VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>HighlightWindow( <br>    HWND hwnd, <br>    BOOL fDraw <br>    ) <br>{ <br>    HDC hdc; <br>    RECT rc; <br> <br>    bBorderOn = fDraw; <br> <br>    if (hwnd == NULL || !IsWindow(hwnd)) <br>        return; <br> <br>    hdc = GetWindowDC(hwnd); <br>    GetWindowRect(hwnd, &amp;rc); <br>    OffsetRect(&amp;rc, -rc.left, -rc.top); <br> <br>    if (!IsRectEmpty(&amp;rc)) <br>    { <br>        PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, DINV,  DSTINVERT); <br>        PatBlt(hdc, rc.left, rc.bottom - DINV, DINV, <br>            -(rc.bottom - rc.top - 2 * DINV), DSTINVERT); <br>        PatBlt(hdc, rc.right - DINV, rc.top + DINV, DINV, <br>            rc.bottom - rc.top - 2 * DINV, DSTINVERT); <br>        PatBlt(hdc, rc.right, rc.bottom - DINV, -(rc.right - rc.left), <br>            DINV, DSTINVERT); <br>    } <br> <br>    ReleaseDC(hwnd, hdc); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SelectWindowUpdateInfo <br>* <br>* Updates the informational fields in the Select Window dialog when <br>* a new window is selected from the hwnd listbox. <br>* <br>* Arguments: <br>*     HWND hDlg - handle to the select window dialog box. <br>*     HWND hwnd - handle to the new window selected. <br>* <br>* Returns: <br>*     VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>SelectWindowUpdateInfo( <br>    HWND hDlg, <br>    HWND hwnd <br>    ) <br>{ <br>    HWND hParent; <br>    DWORD dwStyle; <br>    RECT rc; <br>    CHAR szTemp[MAXSTRING]; <br> <br>    if (hwnd) <br>    { <br>        hParent = GetParent(hwnd); <br>        dwStyle = GetWindowLong(hwnd, GWL_STYLE); <br> <br>        MakeWindowName(hwnd, szTemp, MAXSTRING); <br>        SetDlgItemText(hDlg, DID_SELWINWINDOW, szTemp); <br> <br>        GetClassName(hwnd, szTemp, MAXSTRING); <br>        SetDlgItemText(hDlg, DID_SELWINCLASS, szTemp); <br> <br>        if (hParent) <br>        { <br>            MakeWindowName(hParent, szTemp, MAXSTRING); <br>            SetDlgItemText(hDlg, DID_SELWINPARENT, szTemp); <br>        } <br>        else <br>        { <br>            SetDlgItemText(hDlg, DID_SELWINPARENT, <br>                           LoadResourceString(IDS_NOPARENT)); <br>        } <br> <br>        GetWindowRect(hwnd, &amp;rc); <br>        wsprintf(szTemp, "(%d,%d)-(%d,%d) %dx%d", rc, <br>            rc.right-rc.left, rc.bottom-rc.top); <br>        SetDlgItemText(hDlg, DID_SELWINRECT, szTemp); <br> <br>        if (dwStyle &amp; WS_POPUP) <br>            wsprintf (szTemp, "%08lX: WS_POPUP", dwStyle); <br>        else if (dwStyle &amp; WS_CHILD) <br>            wsprintf (szTemp, "%08lX: WS_CHILD, ID: %lX", dwStyle, <br>            GetWindowLong(hwnd, GWL_ID)); <br>        else if (dwStyle &amp; WS_ICONIC) <br>            wsprintf (szTemp, "%08lX: WS_ICONIC", dwStyle); <br>        else <br>            wsprintf (szTemp, "%08lX: WS_OVERLAPPED", dwStyle); <br> <br>        SetDlgItemText(hDlg, DID_SELWINSTYLE, szTemp); <br>    } <br>    else <br>    { <br>        TCHAR lpBuf[256]; <br>        LoadString(GetModuleHandle(NULL), IDS_UNDEFINED, lpBuf, sizeof(lpBuf)); <br>        SetDlgItemText(hDlg, DID_SELWINWINDOW, lpBuf); <br>        SetDlgItemText(hDlg, DID_SELWINCLASS,  lpBuf); <br>        SetDlgItemText(hDlg, DID_SELWINPARENT, lpBuf); <br>        SetDlgItemText(hDlg, DID_SELWINRECT,   lpBuf); <br>        SetDlgItemText(hDlg, DID_SELWINSTYLE,  lpBuf); <br>    } <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SelectWindowEnableFields <br>* <br>* Enables/disables the different fields in the Select Window dialog <br>* based on whether the user wants to spy on all windows or individually <br>* select one. <br>* <br>* Arguments: <br>*   HWND hwnd    - Dialog window handle. <br>*   BOOL fEnable - TRUE to enable the fields, FALSE to disable them. <br>* <br>* Returns: <br>*   VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>SelectWindowEnableFields( <br>    HWND hwnd, <br>    BOOL fEnable <br>    ) <br>{ <br>    EnableWindow(GetDlgItem(hwnd, DID_SELWINLIST), fEnable); <br>    EnableWindow(GetDlgItem(hwnd, DID_SELWINWINDOW), fEnable); <br>    EnableWindow(GetDlgItem(hwnd, DID_SELWINCLASS), fEnable); <br>    EnableWindow(GetDlgItem(hwnd, DID_SELWINPARENT), fEnable); <br>    EnableWindow(GetDlgItem(hwnd, DID_SELWINRECT), fEnable); <br>    EnableWindow(GetDlgItem(hwnd, DID_SELWINSTYLE), fEnable); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* OutputDlgProc <br>* <br>* Dialog proc for the Output dialog. <br>* <br>* Arguments: <br>*   HWND hwnd - handle to the output dialog <br>*   UINT msg - message sent to output dialog <br>*   WPARAM wParam - message parameter. <br>*   LPARAM lParam - message parameter. <br>* <br>* Returns: <br>*   The value that the dialog proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>* <br>\*****************************************************************************/ <br> <br>BOOL CALLBACK <br>OutputDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    switch (msg) <br>    { <br>        case WM_INITDIALOG: <br>            CheckDlgButton(hwnd, DID_OUTPUTWINDOW, gfOutputWin); <br>            CheckDlgButton(hwnd, DID_OUTPUTCOM1, gfOutputCom1); <br>            CheckDlgButton(hwnd, DID_OUTPUTFILE, gfOutputFile); <br> <br>            SetDlgItemText(hwnd, DID_OUTPUTFILENAME, gszFile); <br>            SetDlgItemInt(hwnd, DID_OUTPUTLINES, gnLines, FALSE); <br> <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            return OutputCommand(hwnd, LOWORD(wParam), HIWORD(wParam)); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* OutputCommand <br>* <br>* Handles the WM_COMMAND messages for the Output dialog. <br>* <br>* Arguments: <br>*   HWND hwnd       - Window handle of the dialog. <br>*   INT nCmd        - Command value. <br>*   INT nNotifyCode - The notify code. <br>* <br>* Returns: <br>*   The value that the dialog proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>* <br>\*****************************************************************************/ <br> <br>PRIVATE BOOL <br>OutputCommand( <br>    HWND hwnd, <br>    INT nCmd, <br>    INT nNotifyCode <br>    ) <br>{ <br>    HFILE fh; <br>    INT i; <br>    CHAR szTemp[MAXSTRING]; <br> <br>    switch (nCmd) <br>    { <br>        case IDOK: <br>            i = GetDlgItemInt(hwnd, DID_OUTPUTLINES, &amp;i, FALSE); <br>            if (i != gnLines) <br>            { <br>                if ( i &gt; 0 &amp;&amp; i &lt;= LINES_MAX) <br>                { <br>                    gnLines = i; <br>                    MyCreatePrintfWin(ghwndSpyApp); <br>                } <br>                else <br>                { <br>                    Message(MB_OK | MB_ICONEXCLAMATION, <br>                        LoadResourceString(IDS_ERROR_WND_LINE), LINES_MAX); <br>                    SetFocus(GetDlgItem(hwnd, DID_OUTPUTLINES)); <br>                    break; <br>                } <br>            } <br> <br>            gfOutputWin = IsDlgButtonChecked(hwnd, DID_OUTPUTWINDOW); <br>            gfOutputCom1 = IsDlgButtonChecked(hwnd, DID_OUTPUTCOM1); <br>            gfOutputFile = IsDlgButtonChecked(hwnd, DID_OUTPUTFILE); <br> <br>            if (gfOutputFile) <br>            { <br>                GetDlgItemText(hwnd, DID_OUTPUTFILENAME, szTemp, MAXSTRING); <br>                /* <br>                 * If they changed the filename, or the file is not open <br>                 * then open it. <br>                 */ <br>                if (lstrcmp(gszFile, szTemp) != 0 || gfhFile == 0) <br>                { <br>                    fh = _lcreat(szTemp, 0); <br>                    if (fh == (HFILE)(-1)) <br>                    { <br>                        if (Message(MB_OKCANCEL | MB_ICONEXCLAMATION, <br>                            LoadResourceString(IDS_ERROR_CANT_OPEN_FILE), szTemp) == IDCANCEL) <br>                        { <br>                            EndDialog(hwnd, FALSE); <br>                        } <br> <br>                        return TRUE; <br>                    } <br> <br>                    lstrcpy(gszFile, szTemp); <br>                    if (gfhFile) <br>                        _lclose(gfhFile); <br>                    gfhFile = fh; <br>                } <br>            } <br>            else <br>            { <br>                if (gfhFile) <br>                { <br>                    _lclose(gfhFile); <br>                    gfhFile = 0; <br>                } <br>            } <br> <br>            if (gfOutputCom1) <br>            { <br>                if (gfhCom1 != INVALID_HANDLE_VALUE) <br>                    CloseHandle(gfhCom1); <br> <br>                gfhCom1 = CreateFile( <br>                        "com1", <br>                        GENERIC_WRITE, <br>                        0,                    // exclusive access <br>                        NULL,                 // no security attrs <br>                        OPEN_EXISTING, <br>                        FILE_ATTRIBUTE_NORMAL, <br>                        NULL); <br>                if (gfhCom1 == INVALID_HANDLE_VALUE) <br>                { <br>                    if (Message(MB_OKCANCEL | MB_ICONEXCLAMATION, <br>                        LoadResourceString(IDS_ERROR_CANT_OPEN_COM1)) == IDCANCEL) <br>                    { <br>                        EndDialog(hwnd, FALSE); <br>                    } <br> <br>                    return TRUE; <br>                } <br>            } <br>            else <br>            { <br>                if (gfhCom1 != INVALID_HANDLE_VALUE) <br>                { <br>                    CloseHandle(gfhCom1); <br>                } <br>            } <br> <br>            EndDialog(hwnd, TRUE); <br>            return TRUE; <br> <br>        case IDCANCEL: <br>            EndDialog(hwnd, FALSE); <br>            return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SelectFont <br>* <br>* Allows the user to select a new font for the display. <br>* <br>* Arguments: <br>*    none <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>VOID <br>SelectFont( <br>    VOID <br>    ) <br>{ <br>    CHOOSEFONT cf; <br>    LOGFONT lf; <br>    HFONT hfontNew; <br> <br>    GetObject(ghfontPrintf, sizeof(LOGFONT), (LPVOID)&amp;lf); <br> <br>    cf.lStructSize = sizeof(cf); <br>    cf.hwndOwner = ghwndSpyApp; <br>    cf.hDC = NULL; <br>    cf.lpLogFont = &amp;lf; <br>    cf.iPointSize = 0; <br>    cf.Flags = CF_ANSIONLY | CF_FORCEFONTEXIST | CF_INITTOLOGFONTSTRUCT <br>        | CF_SCREENFONTS; <br>    cf.rgbColors = 0; <br>    cf.lCustData = 0; <br>    cf.lpfnHook = NULL; <br>    cf.lpTemplateName = NULL; <br>    cf.hInstance = NULL; <br>    cf.lpszStyle = NULL; <br>    cf.nFontType = 0; <br>    cf.nSizeMin = 0; <br>    cf.nSizeMax = 0; <br> <br>    if (ChooseFont(&amp;cf)) <br>    { <br>        if (hfontNew = CreateFontIndirect(&amp;lf)) <br>        { <br>            SetPrintfFont(ghwndPrintf, hfontNew); <br>            ghfontPrintf = hfontNew; <br>        } <br>    } <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* MessagesDlgProc <br>* <br>* Dialog proc for the Messages dialog.  This dialog allows the user <br>* to select which messages they want to spy on. <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the dialog window. <br>*    UINT msg - message to the window <br>*    WPARAM wParam - message parameter <br>*    LPARAM lParam - message parameter <br>* <br>* Returns: <br>*   The value that the dialog proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>\*****************************************************************************/ <br> <br>BOOL CALLBACK <br>MessagesDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    switch (msg) <br>    { <br>        case WM_INITDIALOG: <br>            MessagesInit(hwnd); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            return MessagesCommand(hwnd, LOWORD(wParam), HIWORD(wParam)); <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* MessagesInit <br>* <br>* Initializes the messages dialog. <br>* <br>* Arguments: <br>*   HWND hwnd - Dialog window handle. <br>* <br>* Returns: <br>*   VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>MessagesInit( <br>    HWND hwnd <br>    ) <br>{ <br>    HWND hwndList; <br>    INT i; <br>    INT j; <br>    INT iSel; <br>    PMSGDESC pmd; <br> <br>    for (j = 0; j &lt; gcMsgGroups; j++) <br>        gaMsgGroup[j].cUseCount = 0; <br> <br>    hwndList = GetDlgItem(hwnd, DID_MSGSLIST); <br> <br>    for (i = 0, pmd = gaMsgs; i &lt; gcMessages; i++, pmd++) <br>    { <br>        iSel = (INT)SendMessage(hwndList, LB_ADDSTRING, 0, (LPARAM)pmd-&gt;pszMsg); <br>        SendMessage(hwndList, LB_SETITEMDATA, iSel, (LPARAM)pmd); <br> <br>        if (pmd-&gt;Flags &amp; MTF_SELECTED) <br>        { <br>            SendMessage(hwndList, LB_SETSEL, TRUE, iSel); <br> <br>            for (j = 0; j &lt; gcMsgGroups; j++) <br>            { <br>                if (gaMsgGroup[j].flMask &amp; pmd-&gt;Flags) <br>                    gaMsgGroup[j].cUseCount++; <br>            } <br>        } <br>    } <br> <br>    // <br>    // Set the selection rectangle to the first item in the listbox. </code></pre>
<p>
</p>
<pre><code>// <br>    SendMessage(hwndList, LB_SETCARETINDEX, 0, FALSE); <br> <br>    // <br>    // Loop through all the message groups. <br>    // <br>    for (j = 0; j &lt; gcMsgGroups; j++) <br>    { <br>        // <br>        // Is at least one message in the group selected? <br>        // <br>        if (gaMsgGroup[j].cUseCount) <br>        { <br>            // <br>            // Check the corresponding checkbox.  If all messages <br>            // in the group are selected, the checkbox is checked. <br>            // If only some are selected, the checkbox is set to <br>            // grayed (3-state). <br>            // <br>            CheckDlgButton(hwnd, gaMsgGroup[j].idCheckBox, <br>                (gaMsgGroup[j].cUseCount == gaMsgGroup[j].cMsgs) ? 1 : 2); <br>        } <br>    } <br> <br>    if (gfMsgsUser) <br>        CheckDlgButton(hwnd, DID_MSGSUSER, 1); <br> <br>    if (gfMsgsUnknown) <br>        CheckDlgButton(hwnd, DID_MSGSUNKNOWN, 1); <br> <br>    gcItemsSave = SendMessage(hwndList, LB_GETSELITEMS, <br>        gcMessages, (LPARAM)gaiSelected); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* MessagesCommand <br>* <br>* Handles the WM_COMMAND messages for the Messages dialog. <br>* <br>* Arguments: <br>*   HWND hwnd       - Window handle of the dialog. <br>*   INT nCmd        - Command value. <br>*   INT nNotifyCode - The notify code. <br>* <br>* Returns: <br>*   The value that the dialog proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>* <br>\*****************************************************************************/ <br> <br>PRIVATE BOOL <br>MessagesCommand( <br>    HWND hwnd, <br>    INT nCmd, <br>    INT nNotifyCode <br>    ) <br>{ <br>    INT i; <br>    INT j; <br>    PMSGGROUP pmg; <br>    PMSGDESC pmd; <br>    BOOL fChecked; <br>    HWND hwndList; <br>    INT cItems; <br>    BOOL fSel; <br>    INT iSel; <br>    INT cSelItemsMax; <br>    INT iTopIndex; <br> <br>    switch (nCmd) <br>    { <br>        case DID_MSGSLIST: <br>            if (nNotifyCode == LBN_SELCHANGE) <br>            { <br>                hwndList = GetDlgItem(hwnd, DID_MSGSLIST); <br>                cItems = SendMessage(hwndList, LB_GETSELITEMS, <br>                    gcMessages, (LPARAM)gaiSelected2); <br>                if (cItems == gcItemsSave) <br>                { <br>                    // <br>                    // Nothing changed except for the selection <br>                    // rectangle moving.  We are done. <br>                    // <br>                    break; <br>                } <br> <br>                if (cItems &gt; gcItemsSave) <br>                { <br>                    // <br>                    // A message was selected.  Look for it. <br>                    // <br>                    for (i = 0; i &lt; gcItemsSave &amp;&amp; <br>                        gaiSelected[i] == gaiSelected2[i]; i++) <br>                        ; <br> <br>                    iSel = gaiSelected2[i]; <br>                    fSel = TRUE; <br>                } <br>                else <br>                { <br>                    // <br>                    // A message was unselected.  Look for it. <br>                    // <br>                    for (i = 0; i &lt; cItems &amp;&amp; <br>                        gaiSelected[i] == gaiSelected2[i]; i++) <br>                        ; <br> <br>                    iSel = gaiSelected[i]; <br>                    fSel = FALSE; <br>                } <br> <br>                // <br>                // Get the currently selected item.  It was either <br>                // just turned on or off. <br>                // <br>                pmd = (PMSGDESC)SendMessage(hwndList, LB_GETITEMDATA, iSel, 0); <br> <br>                // <br>                // Loop through the message groups and update the use <br>                // counts for all groups that contain this message. <br>                // <br>                for (i = 0; i &lt; gcMsgGroups; i++) <br>                { <br>                    if (pmd-&gt;Flags &amp; gaMsgGroup[i].flMask) <br>                    { <br>                        gaMsgGroup[i].cUseCount += fSel ? 1 : -1; <br>                    } <br>                } <br> <br>                // <br>                // Be sure that the checkboxes reflect the updated <br>                // status of the message group use counts. <br>                // <br>                MessagesUpdateCheckBoxes(hwnd); <br> <br>                // <br>                // Save away the new selected item array. <br>                // <br>                cSelItemsMax = max(cItems, gcItemsSave); <br>                for (i = 0; i &lt; cSelItemsMax; i++) <br>                { <br>                    gaiSelected[i] = gaiSelected2[i]; <br>                } <br> <br>                gcItemsSave = cItems; <br>            } <br> <br>            break; <br> <br>        case DID_MSGSALL: <br>            hwndList = GetDlgItem(hwnd, DID_MSGSLIST); <br>            SendMessage(hwndList, LB_SETSEL, TRUE, (LPARAM)-1); <br> <br>            for (i = 0; i &lt; gcMsgGroups; i++) <br>            { <br>                gaMsgGroup[i].cUseCount = gaMsgGroup[i].cMsgs; <br>                CheckDlgButton(hwnd, gaMsgGroup[i].idCheckBox, 1); <br>            } <br> <br>            gcItemsSave = SendMessage(hwndList, LB_GETSELITEMS, gcMessages, <br>                (LPARAM)gaiSelected); <br> <br>            CheckDlgButton(hwnd, DID_MSGSUSER, 1); <br>            CheckDlgButton(hwnd, DID_MSGSUNKNOWN, 1); <br> <br>            break; <br> <br>        case DID_MSGSNONE: <br>            hwndList = GetDlgItem(hwnd, DID_MSGSLIST); <br>            SendMessage(hwndList, LB_SETSEL, FALSE, (LPARAM)-1); <br> <br>            for (i = 0; i &lt; gcMsgGroups; i++) <br>            { <br>                gaMsgGroup[i].cUseCount = 0; <br>                CheckDlgButton(hwnd, gaMsgGroup[i].idCheckBox, 0); <br>            } <br> <br>            gcItemsSave = 0; <br> <br>            CheckDlgButton(hwnd, DID_MSGSUSER, 0); <br>            CheckDlgButton(hwnd, DID_MSGSUNKNOWN, 0); <br> <br>            break; <br> <br>        case DID_MSGSDDE: <br>        case DID_MSGSCLIP: <br>        case DID_MSGSMOUSE: <br>        case DID_MSGSNC: <br>        case DID_MSGSKEYBD: <br>#ifdef FE_IME <br>        case DID_MSGSIME: <br>#endif <br>        case DID_MSGSBM: <br>        case DID_MSGSCB: <br>        case DID_MSGSEM: <br>        case DID_MSGSLB: <br>        case DID_MSGSSTM: <br>            for (i = 0; i &lt; gcMsgGroups; i++) <br>            { <br>                if (gaMsgGroup[i].idCheckBox == nCmd) <br>                { <br>                    pmg = &amp;gaMsgGroup[i]; <br>                    break; <br>                } <br>            } <br> <br>            fChecked = IsDlgButtonChecked(hwnd, pmg-&gt;idCheckBox); <br>            if (fChecked == 1) <br>                fChecked = FALSE; <br>            else <br>                fChecked = TRUE; <br> <br>            hwndList = GetDlgItem(hwnd, DID_MSGSLIST); <br> <br>            if (fChecked) <br>            { <br>                SendMessage(hwndList, WM_SETREDRAW, FALSE, 0); <br>                iTopIndex = SendMessage(hwndList, LB_GETTOPINDEX, 0, 0); <br>            } <br> <br>            // <br>            // Get the list of currently selected items. <br>            // <br>            cItems = SendMessage(hwndList, LB_GETSELITEMS, <br>                gcMessages, (LPARAM)gaiSelected); <br> <br>            // <br>            // Look for all the messages in this group. <br>            // <br>            for (i = 0, iSel = 0; i &lt; gcMessages; i++) <br>            { <br>                pmd = (PMSGDESC)SendMessage(hwndList, LB_GETITEMDATA, i, 0); <br>                if (pmd-&gt;Flags &amp; pmg-&gt;flMask) <br>                { <br>                    // <br>                    // Bump up through the list of selected items, looking <br>                    // to see if this item is currently selected. <br>                    // <br>                    for (fSel = FALSE; iSel &lt; cItems &amp;&amp; <br>                        gaiSelected[iSel] &lt;= i; iSel++) <br>                    { <br>                        // <br>                        // A match was found.  The item is selected. <br>                        // <br>                        if(gaiSelected[iSel] == i) <br>                        { <br>                            fSel = TRUE; <br>                            break; <br>                        } <br>                    } <br> <br>                    // <br>                    // Is the current selection state of the item <br>                    // different from the desired selection state? <br>                    // <br>                    if (fSel != fChecked) <br>                    { <br>                        // <br>                        // Update the use counts of all groups that contain <br>                        // this message. <br>                        // <br>                        for (j = 0; j &lt; gcMsgGroups; j++) <br>                        { <br>                            if (pmd-&gt;Flags &amp; gaMsgGroup[j].flMask) <br>                            { <br>                                gaMsgGroup[j].cUseCount += fChecked ? 1 : -1; <br>                            } <br>                        } <br> <br>                        // <br>                        // Select/deselect the message in the list box. <br>                        // <br>                        SendMessage(hwndList, LB_SETSEL, fChecked, i); <br>                    } <br>                } <br>            } <br> <br>            // <br>            // Be sure that the checkboxes reflect the updated <br>            // status of the message group use counts. <br>            // <br>            MessagesUpdateCheckBoxes(hwnd); <br> <br>            if (fChecked) <br>            { <br>                SendMessage(hwndList, LB_SETTOPINDEX, iTopIndex, 0); <br>                SendMessage(hwndList, WM_SETREDRAW, TRUE, 0); <br>                InvalidateRect(hwndList, NULL, FALSE); <br>            } <br> <br>            gcItemsSave = SendMessage(hwndList, LB_GETSELITEMS, <br>                gcMessages, (LPARAM)gaiSelected); <br> <br>            break; <br> <br>        case IDOK: <br>            hwndList = GetDlgItem(hwnd, DID_MSGSLIST); <br>            cItems = SendMessage(hwndList, LB_GETSELITEMS, <br>                gcMessages, (LPARAM)gaiSelected); <br> <br>            // <br>            // Unselect all messages. <br>            // <br>            for (i = 0; i &lt; gcMessages; i++) <br>                gaMsgs[i].Flags &amp;= ~MTF_SELECTED; <br> <br>            // <br>            // Mark all the messages that are selected. <br>            // <br>            for (i = 0; i &lt; cItems; i++) <br>            { <br>                pmd = (PMSGDESC)SendMessage(hwndList, LB_GETITEMDATA, <br>                    gaiSelected[i], 0); <br>                pmd-&gt;Flags |= MTF_SELECTED; <br>            } <br> <br>            if (IsDlgButtonChecked(hwnd, DID_MSGSUSER)) <br>                gfMsgsUser = TRUE; <br>            else <br>                gfMsgsUser = FALSE; <br> <br>            if (IsDlgButtonChecked(hwnd, DID_MSGSUNKNOWN)) <br>                gfMsgsUnknown = TRUE; <br>            else <br>                gfMsgsUnknown = FALSE; <br> <br>#if 0  //Debug code! <br>for (i = 0; i &lt; gcMsgGroups; i++) <br>{ <br>    iSel = 0; <br>    for (j = 0; j &lt; cItems; j++) <br>    { <br>        pmd = (PMSGDESC)SendMessage(hwndList, LB_GETITEMDATA, <br>            gaiSelected[j], 0); <br>        if (pmd-&gt;Flags &amp; gaMsgGroup[i].flMask) <br>            iSel++; <br>    } <br> <br>    if (iSel != gaMsgGroup[i].cUseCount) <br>    { <br>        DbgPrintf("Use counts are wrong!!!"); <br>        for (j = 0; j &lt; gcMsgGroups; j++) <br>        { <br>            DbgPrintf("cMsgs:%d Use:%d", gaMsgGroup[j].cMsgs, gaMsgGroup[j].cUseCount); <br>        } <br>    } <br>} <br>#endif // end debug code <br> <br>            EndDialog(hwnd, IDOK); <br>            return TRUE; <br> <br>        case IDCANCEL: <br>            EndDialog(hwnd, IDCANCEL); <br>            return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* MessagesUpdateCheckBoxes <br>* <br>* Updates the message group checkboxes in the Messages dialog. <br>* This routine should be called when the use counts in the <br>* message group table are changed, so that the state of the <br>* checkboxes will get updated also. <br>* <br>* Arguments: <br>*   HWND hwnd - Dialog window handle. <br>* <br>* Returns: <br>*   VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>MessagesUpdateCheckBoxes( <br>    HWND hwnd <br>    ) <br>{ <br>    INT i; <br>    INT fState; <br> <br>    for (i = 0; i &lt; gcMsgGroups; i++) <br>    { <br>        if (gaMsgGroup[i].cUseCount == gaMsgGroup[i].cMsgs) <br>            fState = 1; <br>        else if (gaMsgGroup[i].cUseCount == 0) <br>            fState = 0; <br>        else <br>            fState = 2; <br> <br>        CheckDlgButton(hwnd, gaMsgGroup[i].idCheckBox, fState); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
