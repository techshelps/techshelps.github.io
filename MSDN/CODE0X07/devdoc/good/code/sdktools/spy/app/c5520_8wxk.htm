<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WPRINTF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5528"></a>WPRINTF.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* <br>* Module: wprintf.c <br>* <br>*   Contains the routines for using printf windows <br>* <br>* Functions: <br>* <br>*   MyCreatePrintfWin() <br>*   SetPrintFont() <br>*   SetPrintfTabs() <br>*   ClearPrintfWindow() <br>*   CopyToClipboard() <br>*   IsPrintfEmpty() <br>*   PrintfWndProc() <br>*   DebugPaint() <br>*   InsertString() <br>*   DebugHScroll() <br>*   DebugVScroll() <br>*   SetWindowClass() <br>*   LinesInDebugWindow() <br>*   CharsInDebugWindow() <br>*   wprintfSetScrollRange() <br>*   NewLine() <br>* <br>* Comments: <br>* <br>\*****************************************************************************/ <br> <br>#include "spy.h" <br> <br> <br> <br>/*****************************************************************************\ <br>*                                                                              <br>*  g e n e r a l   c o n s t a n t s                                           <br>*                                                                              <br>\*****************************************************************************/ <br> <br>#define MAXBUFLEN 200         /* Maximum string length for wprintf */ <br> <br>#define FIRST(pTxt) ((pTxt)-&gt;iFirst) <br>#define TOP(pTxt)   (((pTxt)-&gt;iFirst + (pTxt)-&gt;iTop) % (pTxt)-&gt;iMaxLines) <br>#define LAST(pTxt)  (((pTxt)-&gt;iFirst + (pTxt)-&gt;iCount-1) % (pTxt)-&gt;iMaxLines) <br>#define INC(pTxt,x) ((x) = ++(x) % (pTxt)-&gt;iMaxLines) <br>#define DEC(pTxt,x) ((x) = --(x) % (pTxt)-&gt;iMaxLines) <br>#define OFFSETX (pTxt-&gt;Tdx/2) <br>#define OFFSETY 1 <br>#define VARSIZE 1 <br> <br>#define BOUND(x,mn,mx) ((x) &lt; (mn) ? (mn) : ((x) &gt; (mx) ? (mx) : (x))) <br> <br>#define FTwixtI3(l,x,h) ((x)&gt;=(l) &amp;&amp; (x&lt;=h)) <br> <br>#define EnterCrit(p) <br>#define LeaveCrit(p) <br> <br>/*****************************************************************************\ <br>*                                                                               <br>*   g l o b a l   v a r i a b l e s                                             <br>*                                                                               <br>\*****************************************************************************/ <br> <br>typedef struct { <br>    INT     iLen; <br>    CHAR    * *hText; <br>}   LINE; <br> <br>struct TEXT_STRUCT { <br>    CRITICAL_SECTION csSync;      // CritSect to sync the threads <br> <br>    INT     iFirst;               /* First line in queue */ <br>    INT     iCount;               /* Number of lines in queue */ <br>    INT     iTop;                 /* Line at top of window */ <br>    INT     iLeft;                /* X offset of the window */ <br>    INT     MaxLen;               /* Max String Length */ <br>    INT     iMaxLines;            /* max number of LINEs */ <br>    HFONT   hFont;                /* Font to draw with */ <br>    DWORD   Tdx, Tdy;             /* Font Size */ <br>    LINE    arLines[VARSIZE];     /* array of iMaxLines LINEs */ <br>}; <br> <br>typedef struct TEXT_STRUCT *PTXT; /* pointer to a text struct */ <br>typedef PTXT               *HTXT; /* Handle to a text struct */ <br> <br>PRIVATE INT iSem = 0; <br> <br>INT tabs[20]; <br>INT nTabs = 0; <br> <br>/*****************************************************************************\ <br>*                                                                               <br>*   f u n c t i o n   d e f i n i t i o n s                                     <br>*                                                                               <br>\*****************************************************************************/ <br> <br>LONG APIENTRY PrintfWndProc(HWND, UINT, WPARAM, LONG); <br> <br>PRIVATE VOID DebugPaint(HWND hwnd, LPPAINTSTRUCT pps); <br>PRIVATE INT  InsertString (PTXT, CHAR *); <br>PRIVATE VOID DebugHScroll(HWND, PTXT, INT); <br>PRIVATE VOID DebugVScroll(HWND, PTXT, INT); <br>PRIVATE BOOL SetWindowClass (HANDLE, LPSTR); <br>PRIVATE INT  LinesInDebugWindow (HWND); <br>PRIVATE INT  CharsInDebugWindow (HWND); <br>PRIVATE VOID wprintfSetScrollRange (HWND, BOOL); <br>PRIVATE VOID NewLine (PTXT pTxt); <br>PRIVATE INT mwprintf( HWND hwnd, LPSTR format, ... ); <br> <br> <br> <br>/*****************************************************************************\ <br>* MyCreatePrintfWin <br>* <br>* Creates a window to printf to. <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the parent window <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>VOID <br>MyCreatePrintfWin( <br>    HWND hwnd <br>    ) <br>{ <br>    RECT rc; <br> <br>    if (ghwndPrintf) <br>        DestroyWindow(ghwndPrintf); <br> <br>    GetClientRect(hwnd, &amp;rc); <br> <br>    ghwndPrintf = CreatePrintfWin(hwnd, ghInst, "", WS_CHILD | WS_VSCROLL | <br>        WS_HSCROLL, -gcxBorder, -gcyBorder, rc.right + (2 *gcxBorder), <br>        rc.bottom + (2 * gcyBorder), gnLines); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* DebugPaint(hwnd, pps)                                                        <br>*                                                                              <br>* The paint function.                                                     <br>*                                                                         <br>* Arguments:                                                              <br>*    HWND hwnd - Window to paint to.                                     <br>*    LPPAINTSTRUCT - pps               <br>*                                                                               <br>*   Returns:                                                                    <br>*       nothing                                                                 <br>*                                                                               <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>DebugPaint( <br>    HWND hwnd, <br>    LPPAINTSTRUCT pps <br>    ) <br>{ <br>    PTXT pTxt; <br>    HTXT hTxt; <br>    INT iQueue; <br>    INT xco; <br>    INT yco; <br>    INT iLast; <br>    HBRUSH hb; <br>    COLORREF c; <br> <br>    hTxt = (HTXT)GetWindowLong(hwnd, 0); <br>    pTxt = *hTxt; <br> <br>    SetTextColor(pps-&gt;hdc, GetSysColor(COLOR_WINDOWTEXT)); <br>    c = GetSysColor(COLOR_WINDOW); <br>    SetBkColor(pps-&gt;hdc, c); <br>    hb = CreateSolidBrush(c); <br>    if (pTxt-&gt;hFont) <br>        SelectObject(pps-&gt;hdc, pTxt-&gt;hFont); <br> <br>    iLast  = LAST(pTxt); <br>    iQueue = TOP(pTxt); <br> <br>    xco = OFFSETX - pTxt-&gt;iLeft * pTxt-&gt;Tdx; <br>    yco = OFFSETY; <br> <br>    for (;;) <br>    { <br>        if (yco &lt;= pps-&gt;rcPaint.bottom &amp;&amp; <br>                (yco + (LONG)(pTxt-&gt;Tdy)) &gt;= pps-&gt;rcPaint.top) <br>        { <br>            if (pTxt-&gt;arLines[iQueue].hText == NULL <br>                || (LPSTR)*(pTxt-&gt;arLines[iQueue].hText) == NULL) <br>            { <br>                RECT rcT; <br> <br>                rcT.top = yco; <br>                rcT.bottom = yco+pTxt-&gt;Tdy; <br>                rcT.left = pps-&gt;rcPaint.left; <br>                rcT.right = pps-&gt;rcPaint.right; <br>                FillRect(pps-&gt;hdc, &amp;rcT, hb); <br>            } <br>            else <br>            { <br>                TabbedTextOut(pps-&gt;hdc, xco, yco, <br>                    (LPSTR)*(pTxt-&gt;arLines[iQueue].hText), <br>                    pTxt-&gt;arLines[iQueue].iLen, nTabs, tabs, xco); <br>            } <br>        } <br> <br>        if (iQueue == iLast) <br>            break; <br> <br>        yco += pTxt-&gt;Tdy; <br>        INC(pTxt, iQueue); <br>    } <br> <br>    DeleteObject((HANDLE)hb); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SetWindowClass (hInstance)                                                 <br>*      <br>* Registers the window class of the printf window <br>*                                                                          <br>* Arguments:                                                                  <br>*   HANDLE hInstance - instance handle of current instance                     <br>*   LPSTR lpch - pointer to class name <br>*                                                                               <br>* Returns:                                                                    <br>*   TRUE if successful, FALSE if not                                        <br>\*****************************************************************************/ <br> <br>PRIVATE BOOL <br>SetWindowClass( <br>    HANDLE hInstance, <br>    LPSTR lpch <br>    ) <br>{ <br>    WNDCLASS wc; <br> <br>    wc.style          = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc    = PrintfWndProc; <br>    wc.cbClsExtra     = 0; <br>    wc.cbWndExtra     = sizeof(HANDLE); <br>    wc.hInstance      = hInstance; <br>    wc.hIcon          = NULL; <br>    wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.lpszMenuName   = NULL; <br>    wc.lpszClassName  = lpch; <br> <br>    return RegisterClass(&amp;wc); <br>} <br> <br> <br>/*****************************************************************************\ <br>* CreatePrintfWin (hParent, lpchName, dwStyle, x, y, dx, dy, iMaxLines)        <br>*                                                                              <br>* Creates a window for the depositing of debuging messages.                 <br>*                                                                               <br>* Arguments:                                                                  <br>*   HWND hParent - Window handle of the parent window.                           <br>*   HANDLE hInstance - Module instance handle.                                      <br>*   lPSTR lpchName - String to appear in the caption bar of the debuging window    <br>*   DWORD dwStyle - Window style                                                  <br>*   INT x,y - Location of window                                            <br>*   INT dx,dy - Size of the window                                            <br>*   INT iMaxLines - The maximum number of text lines to display in the window     <br>*                                                                               <br>* Returns:                                                                    <br>*   A window handle of the debuging window, or NULL if a error occured.       <br>\*****************************************************************************/ <br> <br>PUBLIC HWND APIENTRY <br>CreatePrintfWin ( <br>HWND   hParent, <br>HANDLE hInstance, <br>LPSTR  lpchName, <br>DWORD  dwStyle, <br>INT   x, <br>INT   y, <br>INT   dx, <br>INT   dy, <br>INT    iMaxLines <br>) <br>{ <br>    static BOOL bClass = FALSE;   /* Is the class registered */ <br> <br>    HWND   hwnd; <br>    HTXT   hTxt;      /* handle to a debuging window struct */ <br>    PTXT   pTxt; <br>    static CHAR achClass[40]; <br> <br>    /* <br>        *  Make a Class name that is unique across instances <br>        */ <br>    if (!bClass++) { <br>        wsprintf(achClass, "WPRINTF_%4.4X", hInstance); <br>        SetWindowClass(hInstance, achClass); <br>    } <br> <br>    /* Allocate the window long before create the window, such that the <br>           window proc can find the window long during the create. */ <br> <br>    hTxt = (HTXT)LocalAlloc(LHND, sizeof(struct TEXT_STRUCT) + (iMaxLines <br>        - VARSIZE) * sizeof(LINE)); <br> <br>    if (!hTxt) { <br>        return FALSE; <br>    } <br> <br>    pTxt = *hTxt; <br> <br>    //InitializeCriticalSection(&amp;pTxt-&gt;csSync); <br> <br>    pTxt-&gt;iFirst            = 0;    /* Set the queue up to have 1 NULL line */ <br>    pTxt-&gt;iCount            = 1; <br>    pTxt-&gt;iTop              = 0; <br>    pTxt-&gt;iLeft             = 0; <br>    pTxt-&gt;MaxLen            = 0; <br>    pTxt-&gt;iMaxLines         = iMaxLines; <br>    pTxt-&gt;arLines[0].hText  = NULL; <br>    pTxt-&gt;arLines[0].iLen   = 0; <br> <br>    hwnd = CreateWindow((LPSTR)achClass, (LPSTR)lpchName, dwStyle, x, y, <br>        dx, dy, (HWND)hParent,     /* parent window */ <br>    (HMENU)NULL,       /* use class menu */ <br>    (HANDLE)hInstance, /* handle to window instance */ <br>    (LPSTR)hTxt        /* used by WM_CREATE to set the window long */ <br>    ); <br> <br>    if (!hwnd) { <br>        return FALSE; <br>    } <br> <br>    wprintfSetScrollRange(hwnd, FALSE); <br> <br>    /* Make window visible */ <br>    ShowWindow(hwnd, SHOW_OPENWINDOW); <br>    return hwnd; <br>} <br> <br> <br>/*****************************************************************************\ <br>* SetPrintfFont (hwnd,hFont)                                                 <br>*                <br>* Sets the font for the printf window. <br>*                                                                <br>* Arguments:                                                                  <br>*   HWND hwnd - Window handle of the printf window.                           <br>*   HFONT hFont - Font handle                                                   <br>*                                                                               <br>* Returns:                                                                    <br>*                                                                               <br>\*****************************************************************************/ <br> <br>VOID <br>SetPrintfFont( <br>    HWND hwnd, <br>    HFONT hfont <br>    ) <br>{ <br>    PTXT pTxt; <br>    HDC hDC; <br>    TEXTMETRIC tm; <br>    HFONT hfontOld; <br> <br>    pTxt = *(HTXT)GetWindowLong(hwnd, 0); <br>    pTxt-&gt;hFont = hfont; <br> <br>    /* Find out the size of a Char in the font */ <br>    hDC = GetDC(hwnd); <br>    hfontOld = SelectObject(hDC, hfont); <br>    DeleteObject(hfontOld); <br>    GetTextMetrics(hDC, &amp;tm); <br>    pTxt-&gt;Tdy = tm.tmHeight; <br>    pTxt-&gt;Tdx = tm.tmAveCharWidth; <br>    ReleaseDC(hwnd, hDC); <br> <br>    CalculatePrintfTabs(hfont); <br> <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    UpdateWindow(hwnd); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SetPrintfTabs                                                              <br>* <br>* Sets the Tabstops in the printf window. <br>*         <br>* Arguments: <br>*    INT n - number of tabs to set. <br>*    LPINT pTabs - arrays of tabstops <br>* <br>* Returns:                                                                    <br>*    VOID                                                                               <br>\*****************************************************************************/ <br> <br>VOID <br>SetPrintfTabs( <br>    INT n, <br>    LPINT pTabs <br>    ) <br>{ <br>    INT i; <br> <br>    nTabs = n; <br>    for (i = 0; i &lt; nTabs; i++) <br>        tabs[i] = *pTabs++; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* ClearPrintfWindow <br>*                                                                               <br>* Clears all text from the window                                              <br>*                                                                              <br>* Arguments:                                                                  <br>*    HWND hwnd - window handle for the Degubing window                   <br>* <br>* Returns: <br>*    VOID                                                                               <br>\*****************************************************************************/ <br> <br>VOID <br>ClearPrintfWindow( <br>    HWND hwnd <br>    ) <br>{ <br>    INT   i, iQueue; <br>    PTXT  pTxt; <br>    HTXT  hTxt; <br> <br>    if (hwnd != NULL &amp;&amp; IsWindow(hwnd)) { <br>        hTxt  = (HTXT)GetWindowLong(hwnd, 0); <br>        pTxt = *hTxt; <br> <br>        EnterCrit(pTxt); <br> <br>        iQueue = TOP(pTxt); <br>        for (i = 0; i &lt; (pTxt)-&gt;iCount; i++, INC(pTxt, iQueue)) <br>            if ((pTxt)-&gt;arLines[iQueue].hText != NULL) { <br>                LocalFree ((HANDLE)pTxt-&gt;arLines[iQueue].hText); <br>                pTxt-&gt;arLines[iQueue].hText = NULL; <br>            } <br> <br>        pTxt-&gt;iFirst            = 0;  /* Set the queue up to have 1 NULL line */ <br>        pTxt-&gt;iCount            = 1; <br>        pTxt-&gt;iTop              = 0; <br>        pTxt-&gt;iLeft             = 0; <br>        pTxt-&gt;MaxLen            = 0; <br>        pTxt-&gt;arLines[0].hText  = NULL; <br>        pTxt-&gt;arLines[0].iLen   = 0; <br> <br>        wprintfSetScrollRange(hwnd, FALSE); <br>        InvalidateRect(hwnd, NULL, TRUE); <br> <br>        LeaveCrit(pTxt); <br>    } <br>} <br> <br> <br>/*****************************************************************************\ <br>* PrintfWndProc( hwnd, uiMessage, wParam, lParam )                           <br>* <br>* The window proc for the debugging window.  This processes all           <br>* of the window's messages.                                               <br>*                                                                               <br>* Arguments:                                                                  <br>*   HWND hwnd - window handle for the parent window                     <br>*   UINT uiMessage -message number                                          <br>*   WPARAM wParam - message-dependent                                       <br>*   LPARAM lParam - message-dependent                                       <br>*                                                                               <br>* Returns:                                                                    <br>*   0 if processed, nonzero if ignored                                      <br>\*****************************************************************************/ <br> <br>PUBLIC LONG APIENTRY <br>PrintfWndProc( <br>HWND   hwnd, <br>UINT   uiMessage, <br>WPARAM wParam, <br>LONG   lParam <br>) <br>{ <br>    PAINTSTRUCT rPS; <br>    HTXT        hTxt; <br>    PTXT        pTxt; <br> <br>    hTxt  = (HTXT)GetWindowLong(hwnd, 0); <br> <br>    if ( hTxt ) { <br>        pTxt = *hTxt; <br>    } <br> <br>    switch (uiMessage) { <br>    case WM_CREATE: <br>        { <br>            /* set the WindowLong before any other message tries to <br>                         * reference it during the create of a window <br>                         */ <br>            LPCREATESTRUCT csWindowLong = (LPCREATESTRUCT) lParam; <br> <br>            hTxt = (HTXT)csWindowLong-&gt;lpCreateParams; <br> <br>            SetWindowLong(hwnd, 0, (LONG)hTxt); <br>            SetPrintfFont(hwnd, ghfontPrintf); <br>            wprintfSetScrollRange(hwnd, FALSE); <br>        } <br>        break; <br> <br>    case WM_DESTROY: <br>        { <br>            INT i, iQueue; <br> <br>            EnterCrit(pTxt); <br> <br>            iQueue = TOP(pTxt); <br>            for (i = 0; i &lt; (pTxt)-&gt;iCount; i++, INC(pTxt, iQueue)) <br>                if ((pTxt)-&gt;arLines[iQueue].hText != NULL) { <br>                    LocalFree ((HANDLE)(pTxt)-&gt;arLines[iQueue].hText); <br>                    pTxt-&gt;arLines[iQueue].hText = NULL; <br>                } <br> <br>            LeaveCrit(pTxt); <br>            // DeleteCriticalSection(&amp;pTxt-&gt;csSync); <br> <br>            LocalFree((HANDLE)hTxt); <br>            break; <br>        } <br> <br>    case WM_SIZE: <br>        EnterCrit(pTxt); <br>        if (!iSem) { <br>            wprintfSetScrollRange(hwnd, TRUE); <br>        } <br>        DebugVScroll(hwnd, pTxt, 0); <br>        LeaveCrit(pTxt); <br>        break; <br> <br>    case WM_VSCROLL: <br>        EnterCrit(pTxt); <br> <br>        switch (LOWORD(wParam)) { <br>        case SB_LINEDOWN: <br>            DebugVScroll(hwnd, pTxt, 1); <br>            break; <br>        case SB_LINEUP: <br>            DebugVScroll(hwnd, pTxt, -1); <br>            break; <br>        case SB_PAGEUP: <br>            DebugVScroll(hwnd, pTxt, -LinesInDebugWindow(hwnd)); <br>            break; <br>        case SB_PAGEDOWN: <br>            DebugVScroll(hwnd, pTxt, LinesInDebugWindow(hwnd)); <br>            break; <br>        case SB_THUMBTRACK: <br>        case SB_THUMBPOSITION: <br>            DebugVScroll(hwnd, pTxt, HIWORD(wParam) - pTxt-&gt;iTop); <br>            break; <br>        case SB_ENDSCROLL: <br>            break; <br>        } <br> <br>        LeaveCrit(pTxt); <br>        break; <br> <br>    case WM_HSCROLL: <br>        EnterCrit(pTxt); <br> <br>        switch (LOWORD(wParam)) { <br>        case SB_LINEDOWN: <br>            DebugHScroll (hwnd, pTxt, 1); <br>            break; <br>        case SB_LINEUP: <br>            DebugHScroll (hwnd, pTxt, -1); <br>            break; <br>        case SB_PAGEUP: <br>            DebugHScroll (hwnd, pTxt, -CharsInDebugWindow(hwnd)); <br>            break; <br>        case SB_PAGEDOWN: <br>            DebugHScroll (hwnd, pTxt, CharsInDebugWindow(hwnd)); <br>            break; <br>        case SB_THUMBTRACK: <br>        case SB_THUMBPOSITION: <br>            DebugHScroll(hwnd, pTxt, HIWORD(wParam) - pTxt-&gt;iLeft); <br>            break; <br>        case SB_ENDSCROLL: <br>            break; <br>        } <br> <br>        LeaveCrit(pTxt); <br>        break; <br> <br>    case WM_PAINT: <br>        EnterCrit(pTxt); <br> <br>        BeginPaint(hwnd, (LPPAINTSTRUCT) &amp; rPS); <br>        DebugPaint(hwnd, &amp;rPS); <br>        EndPaint(hwnd, (LPPAINTSTRUCT) &amp; rPS); <br> <br>        LeaveCrit(pTxt); <br>        break; <br> <br>    case WM_KEYDOWN: <br>        EnterCrit(pTxt); <br> <br>        switch (wParam) { <br>        case VK_UP: <br>            DebugVScroll(hwnd, pTxt, -1); <br>            break; <br>        case VK_DOWN: <br>            DebugVScroll(hwnd, pTxt, 1); <br>            break; <br>        case VK_PRIOR: <br>            DebugVScroll(hwnd, pTxt, -LinesInDebugWindow(hwnd)); <br>            break; <br>        case VK_NEXT: <br>            DebugVScroll(hwnd, pTxt, LinesInDebugWindow(hwnd)); <br>            break; <br>        case VK_LEFT: <br>            DebugHScroll(hwnd, pTxt, -1); <br>            break; <br>        case VK_RIGHT: <br>            DebugHScroll(hwnd, pTxt, 1); <br>            break; <br>        } <br> <br>        LeaveCrit(pTxt); <br>        break; <br> <br>    case WM_KEYUP: <br>        break; <br> <br>    case WM_VWPRINTF: <br>        return mwprintf( hwnd, (LPSTR)"%s", (LPSTR)wParam ); <br> <br>    default: <br>        return DefWindowProc(hwnd, uiMessage, wParam, lParam); <br>    } <br>    return 0L; <br>} <br> <br> <br>/*****************************************************************************\ <br>* DebugScroll <br>*    <br>* Scrolls the debug window vertically <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the debug window <br>*    PTXT pTxt - pointer to the text to scroll <br>*    INT n - number of lines to scroll <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>DebugVScroll( <br>HWND hwnd, <br>PTXT pTxt, <br>INT  n <br>) <br>{ <br>    RECT rect; <br>    INT  iMinPos, iMaxPos; <br> <br>    GetScrollRange(hwnd, SB_VERT, (LPINT) &amp;iMinPos, (LPINT) &amp;iMaxPos); <br>    GetClientRect(hwnd, (LPRECT) &amp;rect); <br>    rect.left += OFFSETX; <br>    rect.top  += OFFSETY; <br> <br>    n = BOUND(pTxt-&gt;iTop + n, iMinPos, iMaxPos) - pTxt-&gt;iTop; <br>    if (n == 0) <br>        return; <br> <br>    pTxt-&gt;iTop += n; <br>    ScrollWindow(hwnd, 0, -n * pTxt-&gt;Tdy, (LPRECT) &amp;rect, (LPRECT) &amp;rect); <br>    SetScrollPos(hwnd, SB_VERT, pTxt-&gt;iTop, TRUE); <br>} <br> <br>/*****************************************************************************\ <br>* DebugHScroll <br>* <br>* Performs the horizontal scroll calculations <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the debug window <br>*    PTXT pTxt - pointer to the text to scroll <br>*    INT n - number of characters to scroll <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>DebugHScroll( <br>HWND hwnd, <br>PTXT pTxt, <br>INT  n <br>) <br>{ <br>    RECT rect; <br>    INT  iMinPos, iMaxPos; <br> <br>    GetScrollRange (hwnd, SB_HORZ, (LPINT) &amp;iMinPos, (LPINT) &amp;iMaxPos); <br>    GetClientRect (hwnd, (LPRECT) &amp; rect); <br>    rect.left += OFFSETX; <br>    rect.top  += OFFSETY; <br> <br>    n = BOUND(pTxt-&gt;iLeft + n, iMinPos, iMaxPos) - pTxt-&gt;iLeft; <br>    if (n == 0) <br>        return; <br> <br>    pTxt-&gt;iLeft += n; <br>    ScrollWindow(hwnd, -n * pTxt-&gt;Tdx, 0, (LPRECT) &amp; rect, (LPRECT) &amp; rect); <br>    SetScrollPos(hwnd, SB_HORZ, pTxt-&gt;iLeft, TRUE); <br>} <br> <br>/*****************************************************************************\ <br>* LinesInDebugWindow <br>* <br>* Calculates the number of lines in the debug window <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the debug window <br>* <br>* Returns: <br>*    INT - number of lines in the debug window <br>\*****************************************************************************/ <br> <br>PRIVATE INT <br>LinesInDebugWindow ( <br>HWND hwnd <br>) <br>{ <br>    RECT CRect; <br>    PTXT pTxt; <br> <br>    pTxt = *(HTXT)GetWindowLong(hwnd, 0); <br>    GetClientRect(hwnd, &amp;CRect); <br>    if ( pTxt-&gt;Tdy == 0 ) { <br>        return 0; <br>    } <br>    return pTxt ? (CRect.bottom - CRect.top - OFFSETY) / pTxt-&gt;Tdy : 0; <br>} <br> <br> <br>/*****************************************************************************\ <br>* CharsInDebugWindow <br>* <br>* Calculates the number of characters horizontally in the debug window <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the debug window <br>* <br>* Returns: <br>*    INT - number of horizontal characters in the debug window <br>\*****************************************************************************/ <br> <br>PRIVATE INT <br>CharsInDebugWindow ( <br>HWND hwnd <br>) <br>{ <br>    RECT CRect; <br>    PTXT pTxt; <br> <br>    pTxt = *(HTXT)GetWindowLong (hwnd, 0); <br>    GetClientRect(hwnd, (LPRECT) &amp; CRect); <br>    if ( pTxt-&gt;Tdx == 0 ) { <br>        return 0; <br>    } <br>    return pTxt ? (CRect.right - CRect.left - OFFSETX) / pTxt-&gt;Tdx : 0; <br>} <br> <br>PRIVATE INT <br>mwprintf( <br>    HWND hwnd, <br>    LPSTR format, <br>    ... <br>    ) <br>{ <br>    va_list marker; <br>    INT i; <br> <br>    va_start(marker, format); <br> <br>    i = vwprintf(hwnd, format, marker); <br> <br>    va_end(marker); <br> <br>    return i; <br>} <br> <br> <br>/*****************************************************************************\ <br>* vwprintf <br>* <br>* variable printf - works like the C runtime printf <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the debug window <br>*    LPSTR format - pointer to the format string <br>*    va_list marker - pointer to marker <br>* <br>* Returns: <br>*    INT - number of arguments printed <br>\*****************************************************************************/ <br>PUBLIC INT FAR cdecl <br>vwprintf( <br>HWND  hwnd, <br>LPSTR format, <br>va_list marker <br>) <br>{ <br>    static HWND hwndLast = NULL; <br>    static CHAR  pchBuf[MAXBUFLEN]; <br>    RECT  rect, rcClient; <br>    INT   iRet; <br>    INT   cLinesDisplayed;       // lines of output to show <br>    INT   cLinesFitInWindow;    // lines that can fit in the current window <br>    INT   cLinesNew;  // how much left to scroll <br>    PTXT  pTxt; <br>    HTXT  hTxt; <br>    BOOL  fNoScrollB; <br> <br>    if (hwnd == NULL) <br>        hwnd = hwndLast; <br> <br>    if (hwnd == NULL || !IsWindow(hwnd)) <br>        return 0;  /* exit if bad window handle */ <br> <br>    hwndLast = hwnd; <br> <br>    // <br>    // First format the line and wait until we can play with the Txt structure <br>    // <br>    iRet = wvsprintf((LPSTR)pchBuf, format, marker); <br>    hTxt = (HTXT)GetWindowLong(hwnd, 0); <br>    pTxt = (PTXT)LocalLock((HANDLE)hTxt); <br>    if(pTxt == NULL) <br>        return 0;  // exit if bad memory block <br> <br>    EnterCrit(pTxt); <br> <br>    // <br>    // Number of lines that we can display stuff in <br>    // <br>    cLinesFitInWindow   = LinesInDebugWindow(hwnd); <br> <br>    if (cLinesFitInWindow &gt; pTxt-&gt;iMaxLines) { <br>        fNoScrollB = TRUE; <br>        cLinesFitInWindow = pTxt-&gt;iMaxLines; <br>    } else { <br>        fNoScrollB = FALSE; <br>    } <br> <br>    // <br>    // Number of lines actually displayed in the current window <br>    // <br>    cLinesDisplayed   = min(pTxt-&gt;iCount, cLinesFitInWindow); <br> <br>    // <br>    // Return value is number of new lines to display <br>    // <br>    cLinesNew = InsertString(pTxt, pchBuf); <br> <br>    // <br>    // Now make sure the new text is painted only if visable <br>    // <br>    GetClientRect(hwnd, (LPRECT) &amp; rect); <br>    rcClient = rect; <br> <br>    // <br>    // Calculate how much of the window to invalidate <br>    // <br>    rect.top += (cLinesDisplayed - 1) * pTxt-&gt;Tdy; <br> <br>    InvalidateRect(hwnd, (LPRECT)&amp;rect, TRUE); <br> <br>    // <br>    // If we have more lines than we can display, scroll the window <br>    // such that the last line printed is now at the bottom <br>    // <br>    if (cLinesDisplayed + cLinesNew &gt; cLinesFitInWindow) { <br>        cLinesNew = cLinesDisplayed + cLinesNew - cLinesFitInWindow; <br> <br>        if (fNoScrollB) { <br>            rcClient.bottom = cLinesDisplayed * pTxt-&gt;Tdy; <br>            ScrollWindow(hwnd, 0, -cLinesNew * pTxt-&gt;Tdy, (LPRECT) &amp;rcClient, (LPRECT) &amp;rcClient); <br>        } else { <br>            wprintfSetScrollRange(hwnd, FALSE); <br>            DebugVScroll(hwnd, pTxt, cLinesNew); <br>        } <br>        LeaveCrit(pTxt); <br>    } else { <br>        LeaveCrit(pTxt); <br>    } <br> <br>    LocalUnlock((HANDLE)hTxt); <br> <br>    return(iRet);       /* return the count of arguments printed */ <br>} <br> <br>/*****************************************************************************\ <br>* wprintfSetScrollRange <br>* <br>* Sets the scroll range of the debug window <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the debug window <br>*    BOOL fRedraw - whether or not to redraw the window <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>wprintfSetScrollRange ( <br>HWND hwnd, <br>BOOL bRedraw <br>) <br>{ <br>    PTXT pTxt; <br>    INT  iRange; <br>    INT  iLeftCritSect = 0; <br> <br>    iSem++; <br>    pTxt = *(HTXT)GetWindowLong(hwnd, 0); <br> <br>    /* Update the scroll bars */ <br>    iRange = pTxt-&gt;iCount - 1 - LinesInDebugWindow(hwnd); <br> <br>    if (iRange &lt; 0) { <br>        iRange = 0; <br>        DebugVScroll(hwnd, pTxt, -pTxt-&gt;iTop); <br>    } <br> <br>    while (GetCurrentThreadId() == (DWORD)pTxt-&gt;csSync.OwningThread){ <br>LeaveCrit(pTxt); <br>iLeftCritSect++; <br>    } <br> <br>    SetScrollRange(hwnd, SB_VERT, 0, iRange, FALSE); <br>    SetScrollPos(hwnd, SB_VERT, pTxt-&gt;iTop, bRedraw); <br> <br>    if(iLeftCritSect) { <br>EnterCrit(pTxt); <br>    } <br> <br>    iRange = pTxt-&gt;MaxLen - CharsInDebugWindow(hwnd) + 1; </code></pre>
<p>
</p>
<pre><code>if (iRange &lt; 0) { <br>        iRange = 0; <br>        DebugHScroll(hwnd, pTxt, -pTxt-&gt;iLeft); <br>    } <br> <br>    if(iLeftCritSect) <br>LeaveCrit(pTxt); <br> <br>    SetScrollRange(hwnd, SB_HORZ, 0, iRange, FALSE); <br>    SetScrollPos(hwnd, SB_HORZ, pTxt-&gt;iLeft, bRedraw); <br> <br>    while (iLeftCritSect--) { <br>EnterCrit(pTxt); <br>    } <br> <br>    iSem--; <br>} <br> <br>/*****************************************************************************\ <br>* NewLine <br>* <br>* Calculates when a new line is needed in the debug window <br>* <br>* Arguments: <br>*    PTXT pTxt - pointer to the text <br>* <br>* Returns: <br>*    VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>NewLine ( <br>PTXT pTxt <br>) <br>{ <br>    INT iLast = LAST(pTxt); <br> <br>    if (pTxt-&gt;iCount == pTxt-&gt;iMaxLines) { <br>        LocalFree ((HANDLE)pTxt-&gt;arLines[pTxt-&gt;iFirst].hText); <br>        pTxt-&gt;arLines[pTxt-&gt;iFirst].hText = NULL; <br>        INC (pTxt, pTxt-&gt;iFirst); <br>        if (pTxt-&gt;iTop &gt; 0) { <br>            pTxt-&gt;iTop--; <br>        } <br>    } else { <br>        pTxt-&gt;iCount++; <br>    } <br>    iLast = LAST(pTxt); <br>    pTxt-&gt;arLines[iLast].hText = NULL; <br>    pTxt-&gt;arLines[iLast].iLen  = 0; <br>} <br> <br>/*****************************************************************************\ <br>* InsertString <br>* <br>* Inserts a string into the debug window <br>* <br>* Arguments: <br>*    PTXT pTxt - pointer to the text <br>*    CHAR *str - pointer to insertion string <br>* <br>* Returns: <br>*    INT - Line number at which string was inserted <br>\*****************************************************************************/ <br> <br>PRIVATE INT <br>InsertString ( <br>PTXT  pTxt, <br>CHAR  *str <br>) <br>{ <br>    CHAR   pchBuf[MAXBUFLEN];        /* intermediate buffer */ <br>    INT    iBuf; <br>    INT    iLast = LAST(pTxt); <br>    INT    cLine = 0; <br> <br>    for (iBuf = 0; iBuf &lt; pTxt-&gt;arLines[iLast].iLen; iBuf++) <br>        pchBuf[iBuf] = (*pTxt-&gt;arLines[iLast].hText)[iBuf]; <br> <br>    while (*str != '\0') { <br>        while ((*str != '\n') &amp;&amp; (*str != '\0')) <br>            pchBuf[iBuf++] = *str++; <br> <br>        if (pTxt-&gt;arLines[iLast].hText != NULL) <br>            LocalFree((HANDLE)pTxt-&gt;arLines[iLast].hText); <br> <br>        /* Test for the case of a zero length line, Only brian would do this */ <br> <br>        if (iBuf == 0) <br>            pTxt-&gt;arLines[iLast].hText == NULL; <br>        else { <br>            if ((pTxt-&gt;arLines[iLast].hText = (CHAR **)LocalAlloc(LHND, iBuf)) <br>                == NULL) { <br>                return 0; <br>            } <br>        } <br> <br>        pTxt-&gt;arLines[iLast].iLen = iBuf; <br>        while (--iBuf &gt;= 0 ) <br>            (*pTxt-&gt;arLines[iLast].hText)[iBuf] = pchBuf[iBuf]; <br> <br>        if (*str == '\n') {   /* Now do the next string after the \n */ <br>            str++; <br>            cLine++; <br>            iBuf = 0; <br>            NewLine(pTxt); <br>            INC(pTxt, iLast); <br>        } <br>    } <br> <br>    return cLine; <br>} <br> <br>/*****************************************************************************\ <br>* CopyToClipboard <br>* <br>* Copies all lines to the clipboard in text format. <br>* <br>* Arguments: <br>*   none <br>* <br>* Returns: <br>*   TRUE if successful, FALSE if not. <br>* <br>\*****************************************************************************/ <br> <br>BOOL <br>CopyToClipboard( <br>    VOID <br>    ) <br>{ <br>    PTXT pTxt; <br>    INT iQueue; <br>    INT cch; <br>    INT i; <br>    BOOL fSuccess = FALSE; <br>    LPSTR pBuf = NULL; <br>    LPSTR pb; <br> <br>    pTxt = *(HTXT)GetWindowLong(ghwndPrintf, 0); <br> <br>    EnterCrit(pTxt); <br> <br>    iQueue = FIRST(pTxt); <br>    cch = 0; <br>    for (i = 0; i &lt; pTxt-&gt;iCount; i++, INC(pTxt, iQueue)) <br>    { <br>        if (pTxt-&gt;arLines[iQueue].hText != NULL) <br>        { <br>            // <br>            // Count the characters in the line, plus room for the <br>            // carriage return and newline. <br>            // <br>            cch += pTxt-&gt;arLines[iQueue].iLen; <br>            cch += 2; <br>        } <br>    } <br> <br>    // <br>    // Add one for the terminating null. <br>    // <br>    cch++; <br> <br>    if (!(pBuf = (LPSTR)GlobalAlloc(GMEM_DDESHARE, cch * sizeof(TCHAR)))) <br>    { <br>        LeaveCrit(pTxt); <br>        return FALSE; <br>    } <br> <br>    pb = pBuf; <br>    iQueue = FIRST(pTxt); <br>    for (i = 0; i &lt; pTxt-&gt;iCount; i++, INC(pTxt, iQueue)) <br>    { <br>        if (pTxt-&gt;arLines[iQueue].hText != NULL) <br>        { <br>            lstrcpy(pb, *pTxt-&gt;arLines[iQueue].hText); <br>            pb += pTxt-&gt;arLines[iQueue].iLen; <br>            *pb++ = '\r'; <br>            *pb++ = '\n'; <br>        } <br>    } <br> <br>    LeaveCrit(pTxt); <br> <br>    if (OpenClipboard(ghwndSpyApp)) <br>    { <br>        EmptyClipboard(); <br>        fSuccess = SetClipboardData(CF_TEXT, pBuf) ? TRUE : FALSE; <br>        CloseClipboard(); <br>    } <br> <br>    return fSuccess; <br>} <br> <br>/*****************************************************************************\ <br>* IsPrintfEmpty <br>* <br>* Used to determine if the printf window is empty or not. <br>* <br>* Arguments: <br>*   none <br>* <br>* Returns: <br>*   TRUE if the printf window is empty, FALSE if there is at least <br>*   one line in the window. <br>* <br>\*****************************************************************************/ <br> <br>BOOL <br>IsPrintfEmpty( <br>    VOID <br>    ) <br>{ <br>    PTXT pTxt; <br> <br>    pTxt = *(HTXT)GetWindowLong(ghwndPrintf, 0); <br> <br>    // <br>    // It is empty if the line count is zero (doesn't currently happen) <br>    // or if there is only one line and it is NULL. <br>    // <br>    return (pTxt-&gt;iCount == 0 || <br>        (pTxt-&gt;iCount == 1 &amp;&amp; pTxt-&gt;arLines[FIRST(pTxt)].hText == NULL)) <br>        ? TRUE : FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
