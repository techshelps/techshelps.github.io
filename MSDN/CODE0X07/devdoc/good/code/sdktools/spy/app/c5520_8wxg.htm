<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5524"></a>SPY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* <br>* Module: spy.c <br>* <br>*   Main module for the Windows debugging Spy SDK applet. <br>* <br>* Functions: <br>* <br>*   WinMain() <br>*   SpyWndProc() <br>*   SpyInit() <br>*   PutOptions() <br>*   InitMenu() <br>*   SpyCommand() <br>* <br>* Comments: <br>* <br>\*****************************************************************************/ <br> <br>#include "spy.h" <br>#include &lt;stdlib.h&gt; <br> <br> <br>#define WM_EXECINSTANCE     (WM_USER+100) <br> <br> <br>/* <br> * Macros to simplify working with menus. <br> */ <br>#define MyEnableMenuItem(hMenu, wIDEnableItem, fEnable) \ <br>    EnableMenuItem((hMenu),(wIDEnableItem),(fEnable)?MF_ENABLED:MF_GRAYED) <br> <br>#define MyCheckMenuItem(hMenu, wIDCheckItem, fCheck) \ <br>    CheckMenuItem((hMenu),(wIDCheckItem),(fCheck)?MF_CHECKED:MF_UNCHECKED) <br> <br> <br>HANDLE ghInst; <br>HWND ghwndSpyApp; <br>HWND ghwndPrintf = NULL; <br>HANDLE ghHookThread = NULL; <br>HWND ghwndSpyHook = NULL; <br>HWND ghwndSpyingOn = NULL;              // The window we are spying on. <br>HFONT ghfontPrintf; <br>INT gnLines; <br>BOOL gfSpyOn = FALSE; <br>BOOL gfSpyAll; <br>BOOL gfOutputWin; <br>BOOL gfOutputCom1; <br>BOOL gfOutputFile; <br>HFILE gfhFile; <br>HANDLE gfhCom1; <br>CHAR gszFile[MAXSTRING]; <br>INT gcxBorder; <br>INT gcyBorder; <br>BOOL gfMsgsUser;                        // TRUE to spy on all WM_USER messages. <br>BOOL gfMsgsUnknown;                     // TRUE to spy on all unknown msgs. <br>CHAR gszAppName[] = SPYAPPNAME; <br>UCHAR gszWindowName[40]; <br>WINDOWPLACEMENT gwndpl; <br> <br> <br>PRIVATE HANDLE ghaccelTbl;              // Accelerator table handle. <br>PRIVATE CHAR gszSpyClassName[] = SPYCLASSNAME; <br> <br> <br>PRIVATE BOOL SpyInit(HANDLE hInstance, INT nCmdShow); <br>PRIVATE VOID PutOptions(VOID); <br>PRIVATE VOID InitMenu(HMENU hmenu); <br>PRIVATE LRESULT SpyCommand(HWND hwnd, INT nCmd, INT nNotifyCode); <br> <br> <br> <br>/*****************************************************************************\ <br>* WinMain <br>* <br>* Main entry point for the Spy app. <br>* <br>\*****************************************************************************/ <br> <br>INT WINAPI <br>WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    INT nCmdShow <br>    ) <br>{ <br>    MSG msg; <br> <br>    if (!SpyInit(hInstance, nCmdShow)) <br>        return FALSE; <br> <br>    if (!CreateHookThread()) <br>        goto closespy; <br> <br>    /* <br>     * Polling messages from event queue <br>     */ <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>        if (!TranslateAccelerator(ghwndSpyApp, ghaccelTbl, &amp;msg)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>closespy: <br>    if (IsWindow(ghwndSpyApp)) <br>    { <br>        if (DestroyWindow(ghwndSpyApp)) <br>        { <br>            ghwndSpyApp = NULL; <br>        } <br>    } <br> <br>    if (IsWindow(ghwndPrintf)) <br>    { <br>        if (DestroyWindow(ghwndPrintf)) <br>        { <br>            ghwndPrintf = NULL; <br>        } <br>    } <br> <br>    return (INT)msg.wParam; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SpyInit <br>* <br>* Initializes the Spy application. <br>* <br>* Arguments: <br>*   HANDLE hInstance - handle to the instance of SPY. <br>*   INT nCmdShow - show the window? <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>* <br>\*****************************************************************************/ <br> <br>PRIVATE BOOL <br>SpyInit( <br>    HANDLE hInstance, <br>    INT nCmdShow <br>    ) <br>{ <br>    WNDCLASS wc; <br>    HWND hwndT; <br>    CHAR szClassName[40]; <br>    BOOL bFoundPrevSpy = FALSE; <br>    INT i; <br>    INT j; <br> <br>    ghInst = hInstance; <br> <br>    /* <br>     * Loop through windows to find one of the spy class. <br>     */ <br>    for (hwndT = GetWindow(GetDesktopWindow(), GW_CHILD); hwndT; <br>        hwndT = GetWindow(hwndT, GW_HWNDNEXT)) <br>    { <br>        if (GetClassName(hwndT, szClassName, 40)) <br>        { <br>            if (!lstrcmpi(szClassName, gszSpyClassName)) <br>            { <br>                bFoundPrevSpy = TRUE; <br>                break; <br>            } <br>        } <br>    } <br> <br>    if (bFoundPrevSpy) <br>    { <br>        if (hwndT) <br>            SendMessage(hwndT, WM_EXECINSTANCE, 0, 0); <br> <br>        return FALSE; <br>    } <br> <br>    if (!(ghaccelTbl = LoadAccelerators(ghInst, "spy"))) <br>        return FALSE; <br> <br>    ReadRegistry(); <br> <br>    gcxBorder = GetSystemMetrics(SM_CXBORDER); <br>    gcyBorder = GetSystemMetrics(SM_CYBORDER); <br> <br>    // <br>    // Calculate the counts in the message groups.  This is best <br>    // done at run time to be safe. <br>    // <br>    for (i = 0; i &lt; gcMessages; i++) <br>    { <br>        // <br>        // If this message belongs to a message group, <br>        // increment the total for that group. <br>        // <br>        for (j = 0; j &lt; gcMsgGroups; j++) <br>        { <br>            if (gaMsgGroup[j].flMask &amp; gaMsgs[i].Flags) <br>                gaMsgGroup[j].cMsgs++; <br>        } <br>    } <br> <br>    lstrcpy(gszWindowName,LoadResourceString(IDS_APPLICATION_NAME)); <br> <br>    wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>    wc.hIcon          = LoadIcon(hInstance, gszAppName); <br>    wc.lpszMenuName   = gszAppName; <br>    wc.lpszClassName  = gszSpyClassName; <br>    wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.hInstance      = hInstance; <br>    wc.style          = CS_BYTEALIGNCLIENT; <br>    wc.lpfnWndProc    = SpyWndProc; <br>    wc.cbWndExtra     = 0; <br>    wc.cbClsExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    ghwndSpyApp = CreateWindow(gszSpyClassName, gszWindowName, <br>        WS_OVERLAPPEDWINDOW, 0, 0, 0, 0, <br>        NULL, NULL, hInstance, NULL); <br> <br>    if (!ghwndSpyApp) <br>        return FALSE; <br> <br>    if (nCmdShow != SW_SHOWNORMAL) <br>        gwndpl.showCmd = nCmdShow; <br> <br>    SetWindowPlacement(ghwndSpyApp, &amp;gwndpl); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SpyWndProc <br>* <br>* Main window procedure for the spy app. <br>* <br>* Arguments: <br>*    HWND hwnd - handle to the spy window <br>*    UINT msg - message <br>*    WPARAM wParam - message parameter <br>*    LPARAM lParam - message parameter <br>* <br>* Returns: <br>*   The value that the window proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>\*****************************************************************************/ <br> <br>LRESULT CALLBACK <br>SpyWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    switch (msg) <br>    { <br>        case WM_CREATE: <br>            MyCreatePrintfWin(hwnd); <br>            return 0; <br> <br>        case WM_INITMENU: <br>            if (GetMenu(ghwndSpyApp) == (HMENU)wParam) <br>                InitMenu((HMENU)wParam); <br> <br>            break; <br> <br>        case WM_COMMAND: <br>            return SpyCommand(hwnd, LOWORD(wParam), HIWORD(wParam)); <br> <br>        case WM_ACTIVATE: <br>            /* <br>             * Set the focus to the printf window if we are being activated. <br>             */ <br>            if (LOWORD(wParam)) <br>                SetFocus(ghwndPrintf); <br> <br>            break; <br> <br>        case WM_SIZE: <br>            /* <br>             * Size the printf window to fit into the new client area size. <br>             */ <br>            MoveWindow(ghwndPrintf, -gcxBorder, -gcyBorder, <br>                LOWORD(lParam) + (2 * gcxBorder), <br>                HIWORD(lParam) + (2 * gcyBorder), TRUE); <br>            break; <br> <br>        case WM_CLOSE: <br>            SetSpyHook(FALSE); <br> <br>            if (gfhCom1 != INVALID_HANDLE_VALUE) <br>                CloseHandle(gfhCom1); <br>            if (gfhFile) <br>                _lclose(gfhFile); <br> <br>            SendMessage(ghwndSpyHook, WM_CLOSE, 0, 0); <br>            WriteRegistry(); <br>            WaitForSingleObject(ghHookThread, INFINITE); <br>            DestroyWindow(ghwndSpyApp); <br>            break; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0);   /* Kill the main window */ <br>            ghwndSpyApp = NULL; <br>            ghwndPrintf = NULL; <br>            break; <br> <br>        case WM_EXECINSTANCE: <br>            /* <br>             * another instance of spy has been started. <br>             */ <br>            if (IsIconic(hwnd)) <br>                ShowWindow(hwnd,SW_SHOWNORMAL); <br> <br>            SetForegroundWindow(hwnd); <br>            BringWindowToTop(hwnd); <br> <br>            break; <br> <br>        default: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* InitMenu <br>* <br>* This function grays/enables and checks/unchecks the menu items <br>* appropriately for the given state. <br>* <br>* Arguments: <br>*   HMENU hmenu - The menu handle. <br>* <br>* Returns: <br>*   VOID <br>\*****************************************************************************/ <br> <br>PRIVATE VOID <br>InitMenu( <br>    HMENU hmenu <br>    ) <br>{ <br>    BOOL fEnable = !IsPrintfEmpty(); <br> <br>    MyEnableMenuItem(hmenu, MENU_EDIT_CUT, fEnable); <br>    MyEnableMenuItem(hmenu, MENU_EDIT_COPY, fEnable); <br>    MyEnableMenuItem(hmenu, MENU_EDIT_CLEAR, fEnable); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SpyCommand <br>* <br>* Handles thw WM_COMMAND messages for the Spy app. <br>* <br>* Arguments: <br>*   HWND hwnd       - Window handle of the main app window. <br>*   INT nCmd        - Command value. <br>*   INT nNotifyCode - The notify code. <br>* <br>* Returns: <br>*   The value that the window proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>\*****************************************************************************/ <br> <br>PRIVATE LRESULT <br>SpyCommand( <br>    HWND hwnd, <br>    INT nCmd, <br>    INT nNotifyCode <br>    ) <br>{ <br>    HMENU hmenu; <br> <br>    switch (nCmd) <br>    { <br>        case MENU_SPY_SELECTWINDOW: <br>            MyDialogBox(DID_SELECTWINDOW, SelectWindowDlgProc); <br>            break; <br> <br>        case MENU_SPY_ABOUT: <br>            MyDialogBox(DID_ABOUT, AboutDlgProc); <br>            break; <br> <br>        case MENU_SPY_EXIT: <br>            PostMessage(hwnd, WM_CLOSE, 0, 0); <br>            break; <br> <br>        case MENU_EDIT_CUT: <br>            if (CopyToClipboard()) <br>                ClearPrintfWindow(ghwndPrintf); <br> <br>            break; <br> <br>        case MENU_EDIT_COPY: <br>            CopyToClipboard(); <br>            break; <br> <br>        case MENU_EDIT_CLEAR: <br>            ClearPrintfWindow(ghwndPrintf); <br>            break; <br> <br>        case MENU_OPTIONS_MESSAGES: <br>            MyDialogBox(DID_MESSAGES, MessagesDlgProc); <br>            break; <br> <br>        case MENU_OPTIONS_FONT: <br>            SelectFont(); <br>            break; <br> <br>        case MENU_OPTIONS_OUTPUT: <br>            MyDialogBox(DID_OUTPUT, OutputDlgProc); <br>            break; <br> <br>        case MENU_START: <br>            if (SetSpyHook(TRUE)) <br>            { <br>                hmenu = GetMenu(hwnd); <br>                ModifyMenu(hmenu, MENUPOS_STARTSTOP, MF_BYPOSITION | MF_STRING, <br>                    MENU_STOP, LoadResourceString(IDS_MENU_STOP)); <br>                DrawMenuBar(hwnd); <br> <br>                SetSpyCaption(); <br>            } <br> <br>            break; <br> <br>        case MENU_STOP: <br>            if (SetSpyHook(FALSE)) <br>            { <br>                hmenu = GetMenu(hwnd); <br>                ModifyMenu(hmenu, MENUPOS_STARTSTOP, MF_BYPOSITION | MF_STRING, <br>                    MENU_START, LoadResourceString(IDS_MENU_START)); <br>                DrawMenuBar(hwnd); <br> <br>                SetSpyCaption(); <br>            } <br> <br>            break; <br>    } <br> <br>    return 0; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
