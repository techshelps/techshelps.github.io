<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HOOK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5522"></a>HOOK.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*****************************************************************************\ <br>* <br>* Module: hook.c <br>* <br>*   Contains the message hooking functions for the Windows debugging Spy <br>*   SDK applet. <br>* <br>* Functions: <br>* <br>*   CreateHookThread() <br>*   HookMain() <br>*   HookWndProc() <br>*   SetSpyHook() <br>*   SetWindowToSpyOn() <br>*   DbgPrintf() <br>* <br>* Comments: <br>* <br>\*****************************************************************************/ <br> <br>#include "spy.h" <br> <br> <br>PRIVATE BOOL gfProcessHooks = TRUE; <br> <br> <br>/*****************************************************************************\ <br>* CreateHookThread <br>* <br>*    Creates the hook thread. <br>* <br>* Arguments:  <br>*    none <br>* <br>* Returns: <br>*    BOOL - Whether or not hook create succeeeded. <br>\*****************************************************************************/ <br> <br>BOOL <br>CreateHookThread( <br>    VOID <br>    ) <br>{ <br>    WNDCLASS wc; <br>    DWORD Id; <br> <br>    // <br>    // Register a class for the hook stuff to forward its messages to. <br>    // <br>    wc.hCursor        = NULL;    // this window never shown, so no <br>    wc.hIcon          = NULL;    // cursor or icon are necessary <br>    wc.lpszMenuName   = NULL; <br>    wc.lpszClassName  = HOOKWINDOWCLASS; <br>    wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.hInstance      = ghInst; <br>    wc.style          = 0; <br>    wc.lpfnWndProc    = HookWndProc; <br>    wc.cbWndExtra     = sizeof(HWND) + sizeof(HWND); <br>    wc.cbClsExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    // <br>    // Now create another thread to handle the new queue <br>    // <br>    if (!(ghHookThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)HookMain, <br>        0L, STANDARD_RIGHTS_REQUIRED, &amp;Id))) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* HookMain <br>* <br>*    Main window procedure for the Hook window <br>* <br>\*****************************************************************************/ <br> <br>DWORD <br>HookMain( <br>    LPVOID lpv <br>    ) <br>{ <br>    MSG msg; <br> <br>    // <br>    // Create a hidden window for all to find, but not to see <br>    // <br>    ghwndSpyHook = CreateWindow(HOOKWINDOWCLASS, HOOKWINDOWNAME, <br>        WS_OVERLAPPEDWINDOW, <br>        0, 0, 0, 0, <br>        (HWND) NULL,        /* no parent */ <br>        (HMENU) NULL,       /* use class menu */ <br>        (HANDLE) ghInst,    /* handle to window instance */ <br>        (LPSTR) NULL        /* no params to pass on */ <br>        ); <br> <br>    if (!ghwndSpyHook) <br>    { <br>        ExitThread(0); <br>    } <br> <br>    SetWindowToSpyOn(HWND_ALL); <br> <br>    // <br>    // Polling forwarded messages from hook's event queue <br>    // <br>    while (IsWindow(ghwndSpyHook) &amp;&amp; GetMessage(&amp;msg, ghwndSpyHook, 0, 0)) <br>    { <br>        if (gfProcessHooks) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    ghwndSpyHook = NULL; <br> <br>    return 0; // not reached <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* HookWndProc <br>* <br>* Window procedure for the spy hook. <br>* <br>* Arguments: <br>*   HWND hwnd - handle to the hook window.    <br>*   UINT msg - message sent to hook window. <br>*   WPARAM wParam - message parameter. <br>*   LPARAM lParam - message parameter. <br>* <br>* Returns: <br>*   The value that the proc should return, based on the processing <br>*   of the specific WM_COMMAND message received. <br>\*****************************************************************************/ <br> <br>LRESULT CALLBACK <br>HookWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>    ) <br>{ <br>    switch (msg) <br>    { <br>        // <br>        // New message for Win32 - allows the application to pass data to another application. <br>        //       <br>        case WM_COPYDATA: <br>            { <br>                MSG msgT; <br> <br>                msgT.hwnd = (HWND)wParam; <br>                msgT.message = ((PCOPYDATASTRUCT)lParam)-&gt;dwData; <br>                msgT.wParam = ((PSPYMSGDATA)((PCOPYDATASTRUCT)lParam)-&gt;lpData)-&gt;wParam; <br>                msgT.lParam = ((PSPYMSGDATA)((PCOPYDATASTRUCT)lParam)-&gt;lpData)-&gt;lParam; <br>//DbgPrintf("S Received Message hwnd:%8.8x msg:%d", msgT.hwnd, msgT.message); <br>                PrintMsg(&amp;msgT); <br>//DbgPrintf("S Printed Message hwnd:%8.8x msg:%d", msgT.hwnd, msgT.message); <br>            } <br> <br>            return TRUE; <br> <br>        case WM_CREATE: <br>            // <br>            // Initialize the second HWND in the window words to be the <br>            // window handle of the spy app.  This will be queried by <br>            // the hook DLL. <br>            // <br>            SetWindowLong(hwnd, sizeof(HWND), (LONG)ghwndSpyApp); <br>            return 0; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            return 0; <br> <br>        case WM_NCDESTROY: <br>            gfProcessHooks = FALSE; <br>            break; <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SetSpyHook <br>* <br>* Sets the windows hooks used to trap the messages.  After this <br>* is called with a TRUE for fSet, the messages will start flowing <br>* through the hook DLL. <br>* <br>* Arguments: <br>*   BOOL fSet - TRUE to hook, FALSE to unhook. <br>* <br>* Returns: <br>*   TRUE if successful. <br>* <br>\*****************************************************************************/ <br> <br>BOOL <br>SetSpyHook( <br>    BOOL fSet <br>    ) <br>{ <br>    static HHOOK hhkGetMessage = NULL; <br>    static HHOOK hhkCallWndProc = NULL; <br>    static HANDLE hmodHook; <br> <br>    if (fSet) <br>    { <br>        if (!hmodHook) <br>        { <br>            if (!(hmodHook = LoadLibrary("hook"))) <br>            { <br>                Message(MB_OK | MB_ICONEXCLAMATION,  <br>                        LoadResourceString(IDS_ERROR_CANT_LOAD_DLL)); <br>                return FALSE; <br>            } <br>        } <br> <br>        if (!hhkGetMessage) <br>        { <br>            if (!(hhkGetMessage = SetWindowsHookEx(WH_GETMESSAGE, <br>                (HOOKPROC)GetProcAddress(hmodHook, "SpyGetMsgProc"), hmodHook, 0))) <br>            { <br>                return FALSE; <br>            } <br>        } <br> <br>        if (!hhkCallWndProc) <br>        { <br>            if (!(hhkCallWndProc = SetWindowsHookEx(WH_CALLWNDPROC, <br>                (HOOKPROC)GetProcAddress(hmodHook, "SpyCallWndProc"), hmodHook, 0))) <br>            { <br>                UnhookWindowsHookEx(hhkGetMessage); <br>                return FALSE; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        if (hhkGetMessage) <br>        { <br>            UnhookWindowsHookEx(hhkGetMessage); <br>            hhkGetMessage = NULL; <br>        } <br> <br>        if (hhkCallWndProc) <br>        { <br>            UnhookWindowsHookEx(hhkCallWndProc); <br>            hhkCallWndProc = NULL; <br>        } <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/*****************************************************************************\ <br>* SetWindowToSpyOn <br>* <br>* Sets the current window to spy on to the specified hwnd.  This hwnd can <br>* also be the special value HWND_ALL to specify that all windows should <br>* be spy'd upon. <br>* <br>* Arguments: <br>*   HWND hwndSpyingOn - Window handle to spy on, or HWND_ALL for all windows. <br>* <br>* Returns: <br>*   VOID <br>\*****************************************************************************/ <br> <br>VOID <br>SetWindowToSpyOn( <br>    HWND hwndSpyingOn <br>    ) <br>{ <br>    ghwndSpyingOn = hwndSpyingOn; <br>    gfSpyAll = (ghwndSpyingOn == HWND_ALL) ? TRUE : FALSE; <br>    SetWindowLong(ghwndSpyHook, 0, (LONG)ghwndSpyingOn); <br>    SetSpyCaption(); <br>} <br> <br> <br> <br>#ifdef DBG <br>/**************************************************************************** <br>* DBGprintf <br>* <br>* This debugging function prints out a string to the debug output. <br>* An optional set of substitutional parameters can be specified, <br>* and the final output will be the processed result of these combined <br>* with the format string, just like printf.  A newline is always <br>* output after every call to this function. <br>* <br>* Arguments: <br>*   LPTSTR fmt - Format string (printf style). <br>*   ...        - Variable number of arguments. <br>* <br>* Returns: <br>*    VOID <br>****************************************************************************/ <br> <br>VOID DbgPrintf( <br>    LPTSTR fmt, <br>    ... <br>    ) <br>{ <br>    va_list marker; <br>    TCHAR szBuf[256]; <br> <br>    va_start(marker, fmt); <br>    wvsprintf(szBuf, fmt, marker); <br>    va_end(marker); <br> <br>    OutputDebugString(szBuf); <br>    OutputDebugString(TEXT("\r\n")); <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
