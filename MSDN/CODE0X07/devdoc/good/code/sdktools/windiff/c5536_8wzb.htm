<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPITEM.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5537"></a>COMPITEM.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: COMPITEM.C <br>* <br>* Module which does the comparison between two files.  <br>* <br>* Functions: <br>* <br>* ci_copytext() <br>* ci_makecomposite() <br>* ci_compare() <br>* ci_onesection() <br>* compitem_new() <br>* compitem_delete() <br>* compitem_discardsections() <br>* compitem_getcomposite() <br>* compitem_getleftsections() <br>* compitem_getrightsections() <br>* compitem_getleftfile() <br>* compitem_getrightfile() <br>* compitem_getstate() <br>* compitem_gettext_tag() <br>* compitem_gettext_result() <br>* compitem_getfilename() <br>* compitem_frefilename() <br>* <br>* Comments: <br>* <br>* This module uses the structure compitem which is a data type that knows <br>* about two files, and can compare them. The result of the comparison <br>* is a list of sections for each file, and a composite list of sections <br>* representing the comparison of the two files. <br>* <br>* A compitem has a state (one of the integer values defined in state.h) <br>* representing the result of the comparison. It can also be <br>* queried for the text result (text equivalent of the state) as well <br>* as the tag - or title for this compitem (usually a text string containing <br>* the name(s) of the files being compared). <br>* <br>* A compitem will supply a composite section list even if the files are <br>* the same, or if there is only one file. The composite section list will <br>* only be built (and the files read in) when the compitem_getcomposite() <br>* call is made (and not at compitem_new time). <br>*  <br>*   <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "gutils.h" <br>#include "state.h" <br>#include "windiff.h" <br>#include "wdiffrc.h" <br>#include "list.h" <br>#include "line.h" <br>#include "scandir.h" <br>#include "file.h" <br>#include "section.h" <br>#include "compitem.h" <br> <br> <br>struct compitem { <br> <br>        FILEDATA left;          /* handle for left-hand file */ <br>        FILEDATA right;         /* handle for right-hand file */ <br> <br>        LIST secs_composite;    /* list of sections (composite file)*/ <br>        LIST secs_left;         /* list of sections (left file) */ <br>        LIST secs_right;        /* list of sections (right file) */ <br> <br>        int state;              /* compitem state - result of compare */ <br>        BOOL bDiscard;          /* true if not alloc-ed on list */ <br>        LPSTR tag;              /* text for tag (title of compitem) */ <br>        LPSTR result;           /* text equivalent of state */ <br> <br>}; <br> <br> <br>LPSTR ci_copytext(LPSTR in); <br>void ci_makecomposite(COMPITEM ci); <br>void ci_compare(COMPITEM ci); <br> <br> <br>/*************************************************************************** <br> * Function: compitem_new <br> * <br> * Purpose: <br> * <br> * Returns a handle to a new compitem - given the filenames for the <br> * left and right files to be compared. Either left or right or neither <br> * (but not both) may be null. In this case we set the state accordingly. <br> * <br> * The parameters are handles to DIRITEM objects: these allow us to get the <br> * the name of the file relative to the compare roots (needed for the tag) <br> * and the absolute name of the file (needed for opening the file). <br> * <br> * Comments: <br> * <br> * If the list parameter is not null, the List_New* functions are used to <br> * allocate memory for the compitem. We remember this (in the bDiscard flag) <br> * so we do not delete the compitem if it was allocated on the list. <br> * <br> * If the list parameter is null, the memory <br> * for the compitem is allocated from the gmem_* heap initialised by the app. <br> * <br> ****************************************************************************/ <br>COMPITEM <br>compitem_new(DIRITEM leftname, DIRITEM rightname, LIST list, BOOL fExact) <br>{ <br>        COMPITEM ci; <br>        LPSTR str1, str2; <br>        char buf[2*MAX_PATH+20]; <br> <br> <br>        /* <br>         * Allocate the memory for the compitem, either at the end of the <br>         * list or in the gmem_* heap. <br>         */ <br>        if (list == NULL) { <br>                /* no list passed */ <br>                ci = (COMPITEM) gmem_get(hHeap, sizeof(struct compitem)); <br>                memset(ci, 0, sizeof(struct compitem)); <br>                ci-&gt;bDiscard = TRUE; <br>        } else { <br>                /* add to end of list */ <br>                ci = (COMPITEM) List_NewLast(list, sizeof(struct compitem)); <br>                ci-&gt;bDiscard = FALSE; <br>        } <br> <br>        ci-&gt;secs_composite = NULL; <br>        ci-&gt;secs_left = NULL; <br>        ci-&gt;secs_right = NULL; <br> <br>        /* <br>         * Make a filedata for each of the files that are non-null. <br>         * Filedata objects are responsible for reading the file and <br>         * accessing the lines in it. Don't read in the files until we need to. <br>         */ <br>        if (leftname != NULL) { <br>                ci-&gt;left = file_new(leftname, FALSE); <br>                if (ci-&gt;left == NULL) { <br>                        return(NULL); <br>                } <br>        } else { <br>                ci-&gt;left = NULL; <br>        } <br>        if ( rightname != NULL) { <br>                ci-&gt;right = file_new(rightname, FALSE); <br>                if (ci-&gt;right == NULL) { <br>                        return(NULL); <br>                } <br>        } else { <br>                ci-&gt;right = NULL; <br>        } <br> <br> <br>        /* <br>         * See if we have one or two files, and set the state accordingly <br>         */ <br>        if ( ! ci-&gt;left &amp;&amp; !ci-&gt;right) { <br>                /* two NULL files - this is wrong */ <br>                return(NULL); <br>        } <br> <br> <br>        /* Set the tag (title field) for this item. If the <br>         * two files have names that match, we use just that name - <br>         * otherwise we use both names separated by a colon 'left : right'. <br>         * <br>         * In both cases, use the names relative to compare root (the <br>         * names will certainly be different if we compare the abs paths) <br>         */ <br>        str1 = dir_getrelname(leftname); <br>        str2 = dir_getrelname(rightname); <br> <br>        /* If only one file - set name to that */ <br>        if (ci-&gt;left == NULL) { <br>                ci-&gt;tag = ci_copytext(str2); <br>        } else if (ci-&gt;right == NULL) { <br>                ci-&gt;tag = ci_copytext(str1); <br>        } else { <br>                if (lstrcmpi(str1, str2) == 0) { <br>                        ci-&gt;tag = ci_copytext(str2); <br>                } else { <br>                        wsprintf(buf, "%s : %s", str1, str2); <br>                        ci-&gt;tag = ci_copytext(buf); <br>                } <br>        } <br> <br>        dir_freerelname(leftname, str1); <br>        dir_freerelname(leftname, str2); <br> <br> <br>        if (ci-&gt;left == NULL) { <br>                str1 = dir_getroot_item(rightname); <br>                wsprintf(buf, LoadRcString(IDS_ONLY_IN), str1); <br>                dir_freeroot_item(rightname, str1); <br> <br>                ci-&gt;result = ci_copytext(buf); <br>                ci-&gt;state = STATE_FILERIGHTONLY; <br>        } else if (ci-&gt;right == NULL) { <br>                str1 = dir_getroot_item(leftname); <br>                wsprintf(buf, LoadRcString(IDS_ONLY_IN), str1); <br>                dir_freeroot_item(leftname, str1); <br> <br>                ci-&gt;result = ci_copytext(buf); <br>                ci-&gt;state = STATE_FILELEFTONLY; <br>        } else { <br>                /* two files - are they the same ? compare <br>                 * the file sizes <br>                 */ <br> <br> <br>                if (dir_getfilesize(leftname) != dir_getfilesize(rightname))  <br>                { <br>                    ci-&gt;state = STATE_DIFFER; <br>                    ci-&gt;result = ci_copytext(LoadRcString(IDS_DIFFERENT_SIZES)); <br>                } else if (!fExact){ <br>                    ci-&gt;result = ci_copytext(LoadRcString(IDS_SAME_SIZE)); <br>                    ci-&gt;state = STATE_SAME; <br>                } else { <br>                    ci-&gt;result =  ci_copytext(LoadRcString(IDS_IDENTICAL)); <br>                    ci-&gt;state = STATE_SAME; <br>                } <br>        } <br> <br> <br>#if FALSE <br>                if (dir_getfilesize(leftname) == dir_getfilesize(rightname)) { <br>                    if (  !fExact ) <br>                       { <br>                        ci-&gt;result = ci_copytext("same size etc."); <br>                        ci-&gt;state = STATE_SAME; <br>                    } else { <br>                        ci-&gt;result = ci_copytext("files differ"); <br>                        ci-&gt;state = STATE_DIFFER; <br>                        ci-&gt;result = ci_copytext("files differ"); <br>                     } <br>                } else { <br>                        ci-&gt;result = ci_copytext("files differ"); <br>                        ci-&gt;state = STATE_DIFFER; <br>                } <br>        } <br>#endif <br> <br>        /* <br>         * Building the section lists and composite lists can wait <br>         * until needed. <br>         */ <br>        return(ci); <br>} /* compitem_new */ <br> <br>/*************************************************************************** <br> * Function: compitem_delete <br> * <br> * Purpose: <br> * <br> * Deletes a compitem and free all associated data. <br> * <br> * Comments: <br> * <br> * If the ci-&gt;bDiscard flag is set, the compitem was alloc-ed on a list, <br> * and should not be discarded (the list itself will be deleted). <br> * <br> * The DIRDATA we were passed are not deleted. the filedata, lines <br> * and sections are. <br> ***************************************************************************/ <br>void <br>compitem_delete(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return; <br>        } <br> <br>        compitem_discardsections(ci); <br> <br>        /* Delete the two filedatas (and associated line lists) */ <br>        file_delete(ci-&gt;left); <br>        file_delete(ci-&gt;right); <br> <br>        /* text we allocated */ <br>        gmem_free(hHeap, ci-&gt;tag, lstrlen(ci-&gt;tag) + 1); <br>        gmem_free(hHeap, ci-&gt;result, lstrlen(ci-&gt;result) + 1); <br> <br>        /* Free the compitem struct itself if not alloced on a list */ <br>        if (ci-&gt;bDiscard) { <br>                gmem_free(hHeap, (LPSTR) ci, sizeof(struct compitem)); <br>        } <br>} <br> <br> <br>/* <br>/*************************************************************************** <br> * Function: compitem_discardsections <br> * <br> * Purpose: <br> * <br> * To discard sections - throw away cached information relating to the <br> * comparison (but not the files if they are read into memory). This <br> * is used to force a re-compare if changes in the comparison options <br> * are made <br> * <br> ***************************************************************************/ <br>void <br>compitem_discardsections(COMPITEM ci) <br>{ <br>        /* delete the lists of sections we built */ <br>        if (ci == NULL) { <br>                return; <br>        } <br>        if (ci-&gt;secs_composite) { <br>                section_deletelist(ci-&gt;secs_composite); <br>                ci-&gt;secs_composite = NULL; <br>        } <br>        if (ci-&gt;secs_left) { <br>                section_deletelist(ci-&gt;secs_left); <br>                ci-&gt;secs_left = NULL; <br>        } <br>        if (ci-&gt;secs_right) { <br>                section_deletelist(ci-&gt;secs_right); <br>                ci-&gt;secs_right = NULL; <br>        } <br> <br>        /* reset the line lists to throw away cached hash codes and links */ <br>        if (ci-&gt;left != NULL) { <br>                file_reset(ci-&gt;left); <br>        } <br>        if (ci-&gt;right != NULL) { <br>                file_reset(ci-&gt;right); <br>        } <br> <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getcomposite <br> * <br> * Purpose: <br> * <br> * To get the handle for the composite section list  <br> * <br> ***************************************************************************/ <br>LIST <br>compitem_getcomposite(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return NULL; <br>        } <br>        /* <br>         * do the comparison if we haven't already done it <br>         */ <br>        if (ci-&gt;secs_composite == NULL) { <br>                ci_makecomposite(ci); <br>        } <br> <br>        return(ci-&gt;secs_composite); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getleftsections <br> * <br> * Purpose: <br> * <br> * To get the handle for the list of sections in the left file  <br> * <br> ***************************************************************************/ <br>LIST <br>compitem_getleftsections(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return NULL; <br>        } <br>        /* <br>         * do the comparison if we haven't already done it <br>         */ <br>        if (ci-&gt;secs_composite == NULL) { <br>                ci_makecomposite(ci); <br>        } <br> <br>        return(ci-&gt;secs_left); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getrightsections <br> * <br> * Purpose: <br> * <br> * To get the handle for the list of sections in the right file  <br> * <br> ***************************************************************************/ <br>LIST <br>compitem_getrightsections(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return NULL; <br>        } <br>        /* <br>         * do the comparison if we haven't already done it <br>         */ <br>        if (ci-&gt;secs_composite == NULL) { <br>                ci_makecomposite(ci); <br>        } <br> <br>        return(ci-&gt;secs_right); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getleftfile <br> * <br> * Purpose: <br> * <br> * To get the handle to the left file itself <br> * <br> ***************************************************************************/ <br>FILEDATA <br>compitem_getleftfile(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return(NULL); <br>        } <br>        return(ci-&gt;left); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getrightfile <br> * <br> * Purpose: <br> * <br> * To get the handle to the right file itself  <br> * <br> ***************************************************************************/ <br>FILEDATA <br>compitem_getrightfile(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return(NULL); <br>        } <br>        return(ci-&gt;right); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getstate <br> * <br> * Purpose: <br> * <br> * To get the state (compare result) of this compitem  <br> * <br> ***************************************************************************/ <br>int <br>compitem_getstate(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return(0); <br>        } <br>        return(ci-&gt;state); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_gettext_tag <br> * <br> * Purpose: <br> * <br> * To get the tag (text for the compitem title)  <br> * <br> ***************************************************************************/ <br>LPSTR <br>compitem_gettext_tag(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return(NULL); <br>        } <br>        return(ci-&gt;tag); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_gettext_result <br> * <br> * Purpose: <br> * <br> * To get the result text (text equiv of state)  <br> * <br> ***************************************************************************/ <br>LPSTR <br>compitem_gettext_result(COMPITEM ci) <br>{ <br>        if (ci == NULL) { <br>                return(NULL); <br>        } <br>        return(ci-&gt;result); <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_getfilename <br> * <br> * Purpose: <br> * <br> * To return the name of the file associated with this compitem. The option <br> * argument (one of CI_LEFT, CI_RIGHT, CI_COMP) indicates which file <br> * is required. <br> * <br> * Comments: <br> * <br> * CI_LEFT and CI_RIGHT just result in calls to dir_getopenname to get <br> * an open-able filename. <br> * <br> * For CI_COMP, we create a temporary file, write out all the text in the <br> * composite section list to this file, and then pass the name of the <br> * temporary file to the caller. This file will be deleted on <br> * the call to compitem_freefilename(). <br> *  <br> ***************************************************************************/ <br>LPSTR <br>compitem_getfilename(COMPITEM item, int option) <br>{ <br>        LPSTR fname; <br>        LINE line; <br>        LPSTR tag, text; <br>        SECTION sec; <br>        OFSTRUCT os; <br>        int fh; <br> <br>        if (item == NULL) { <br>                return(NULL); <br>        } <br> <br>        switch(option) { <br>        case CI_LEFT: <br>                if (item-&gt;left != NULL) { <br>                        return(dir_getopenname(file_getdiritem(item-&gt;left))); <br>                } else { <br>                        return(NULL); <br>                } <br> <br>        case CI_RIGHT: <br>                if (item-&gt;right != NULL) { <br>                        return(dir_getopenname(file_getdiritem(item-&gt;right))); <br>                } else { <br>                        return(NULL); <br>                } <br> <br>        case CI_COMP: <br> <br>                /* caller has asked for the filename of the composite file. <br>                 * we need to create a temporary file and write the <br>                 * lines in the composite section list out to it. <br>                 */ <br>                fname = gmem_get(hHeap, MAX_PATH); <br>                GetTempPath(MAX_PATH, fname); <br>                GetTempFileName(fname, "wdf", 0, fname); <br> <br>                fh = OpenFile(fname, &amp;os, OF_READWRITE|OF_SHARE_DENY_NONE); <br>                if (fh &lt; 0) { <br>                        MessageBox(NULL, LoadRcString(IDS_CANT_OPEN_TMP_FILE), NULL, MB_OK | MB_ICONSTOP); <br>                        return(NULL); <br>                } <br> <br>                /* make sure the composite list has been built */ <br> <br>                if (item-&gt;secs_composite == NULL) { <br>                        ci_makecomposite(item); <br>                } <br> <br>                /* write out every line in every section on the composite <br>                 * list to the temp file. <br>                 */ <br>                List_TRAVERSE(item-&gt;secs_composite, sec) { <br> <br>                        /* get the tag field based on the section state*/ <br>                        switch(section_getstate(sec)) { <br>                        case STATE_SAME: <br>                                tag = "    "; <br>                                break; <br> <br>                        case STATE_LEFTONLY: <br>                                tag = " &lt;! "; <br>                                break; <br>                        case STATE_RIGHTONLY: <br>                                tag = " !&gt; "; <br>                                break; <br> <br>                        case STATE_MOVEDLEFT: <br>                                tag = " &lt;- "; <br>                                break; <br> <br>                        case STATE_MOVEDRIGHT: <br>                                tag = " -&gt; "; <br>                                break; <br>                        } <br> <br>                        /* write out each line in this section. <br>                         * non-standard traverse of list as we only <br>                         * want to go from section first to section last <br>                         * inclusive. <br>                         */ <br>                        for (line = section_getfirstline(sec); <br>                             line != NULL; <br>                             line = List_Next(line) ) { <br> <br>                                text = line_gettext(line); <br> <br>                                /* write out to file */ <br>                                _lwrite(fh, tag, lstrlen(tag)); <br>                                _lwrite(fh, text, lstrlen(text)); <br> <br>                                if (line == section_getlastline(sec)) { <br>                                        break; <br>                                } <br>                        } <br>                } <br> <br>                /* now close the file and return its name */ <br>                _lclose(fh); <br>                return(fname); <br> <br> <br>        default: <br>                MessageBox(NULL, LoadRcString(IDS_BAD_ARGUMENT), NULL, MB_OK | MB_ICONSTOP); <br>                return(NULL); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: compitem_freefilename <br> * <br> * Purpose: <br> * <br> * Free memory created by a call to compitem_getfilename. If a temporary <br> * file was created, this may cause it to be deleted. The option argument must <br> * be the same as passed to the original compitem_getfilename call. <br> * <br> * If we created a temporary file for CI_COMP, then delete it; otherwise, <br> * just pass the name to dir_freeopenname. <br> * <br> ***************************************************************************/ <br>void <br>compitem_freefilename(COMPITEM item, int option, LPSTR filename) <br>{ <br>        OFSTRUCT os; <br> <br> <br>        if ((item == NULL) || (filename == NULL)) { <br>                return; <br>        } <br> <br>        switch(option) { <br> <br>        case CI_LEFT: <br>                dir_freeopenname(file_getdiritem(item-&gt;left), filename); <br>                break; <br> <br>        case CI_RIGHT: <br>                dir_freeopenname(file_getdiritem(item-&gt;right), filename); <br>                break; <br> <br>        case CI_COMP: <br> <br>                /* this is a temporary file we created. Delete it. */ <br>                OpenFile(filename, &amp;os, OF_DELETE); <br> <br>                gmem_free(hHeap, filename, MAX_PATH); <br>                break; <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: ci_copytext <br> * <br> * Purpose: <br> * <br> * To alloc a buffer large enough for the text string and copy the text into <br> * it and return a pointer to the string. <br> * <br> ***************************************************************************/ <br>LPSTR <br>ci_copytext(LPSTR in) <br>{ <br>        LPSTR out; <br> <br>        if (in == NULL) { <br>                out = gmem_get(hHeap, 1); <br>                out[0] = '\0'; <br>        } else { <br>                out = gmem_get(hHeap, lstrlen(in) + 1); <br>                lstrcpy(out, in); <br>        } <br>        return(out); <br>} <br> <br>/*************************************************************************** <br> * Function: ci_onesection <br> * <br> * Purpose: <br> * <br> * To make a list containing a single section from the whole list of lines  <br> * <br> ***************************************************************************/ <br>LIST <br>ci_onesection(FILEDATA file) <br>{ <br>        LIST lines; <br>        LIST sections; <br>        SECTION section; <br> <br>        lines = file_getlinelist(file); <br> <br>        /* create a null list */ <br>        sections = List_Create(); <br> <br>        /* tell the section to create itself on the end of this list. */ <br>        section = section_new(List_First(lines), List_Last(lines), sections); <br>        section_setstate(section, STATE_SAME); <br> <br> <br>        return(sections); <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: ci_makecomposite <br> * <br> * Purpose: <br> * <br> * Compare the two files and build the composite list. This function is <br> * called whenever we need one of the section lists and only does the  <br> * comparison if the composite list does not already exist. <br> * <br> ***************************************************************************/ <br>void <br>ci_makecomposite(COMPITEM ci) <br>{ <br>        if (ci-&gt;secs_composite != NULL) { <br>                return; <br>        } <br> <br>        /* if there is only one file, make a single item list <br>         * of sections <br>         */ <br>        if (ci-&gt;left == NULL) { <br>                ci-&gt;secs_left = NULL; <br>                ci-&gt;secs_right = ci_onesection(ci-&gt;right); <br> <br>                /* make a second list, not a pointer to the first <br>                 * or we will get confused when deleting <br>                 */ <br>                ci-&gt;secs_composite = ci_onesection(ci-&gt;right); <br>                return; <br>        } else if (ci-&gt;right == NULL) { <br>                ci-&gt;secs_right = NULL; <br>                ci-&gt;secs_left = ci_onesection(ci-&gt;left); <br> <br>                /* make a second list, not a pointer to the first <br>                 * or we will get confused when deleting <br>                 */ <br>                ci-&gt;secs_composite = ci_onesection(ci-&gt;left); <br>                return; <br>        } <br> <br>        /* we have two files - we need to compare them fully */ <br>        ci_compare(ci); <br>} <br> <br>/*************************************************************************** <br> * Function: ci_compare <br> * <br> * Purpose: <br> * <br> * Compare files and build a composite list. <br> * <br> * Comments: <br> * <br> * Comparison method: <br> * <br> *    0   Break each file into lines and hash each line.  Lines which  <br> *        don't match can be rapidly eliminated by comparing the hash code. <br> * <br> *        Store the hash codes in a binary search tree that <br> *        will give for each hash code the number of times that it <br> *        occurred in each file and one of the lines where it occurred <br> *        in each file.  The tree is used to rapidly find the partner <br> *        of a line which occurs exactly once in each file. <br> * <br> *    1   Make a section covering the whole file (for both) <br> *        and link unique lines between these sections (i.e. link lines <br> *        which occur exactly once in each file as they must match each other). <br> *        These are referred to as anchor points. <br> * <br> *    2   Build section lists for both files by traversing line lists and <br> *        making a section for each set of adjacent lines that are unmatched <br> *        and for each set of adjacent lines that match a set of adjacent <br> *        lines in the other file.  In making a section we start from a <br> *        known matching line and work both forwards and backwards through <br> *        the file including lines which match, whether they are unique or not. <br> * <br> *    3   Establish links between sections that match <br> *        and also between sections that don't match but do <br> *        correspond (by position in file between matching sections) <br> * <br> *    4   For each section pair that don't match but do correspond, <br> *        link up matching lines unique within that section.  (i.e. do <br> *        the whole algorithm again on just this section). <br> * <br> *    There may be some lines which occur many times over in each file. <br> *    As these occurrences are matched up, so the number left to match <br> *    reduces, and may reach one in each file.  At this point these two <br> *    can be matched.  Therefore we... <br> * <br> *    Repeat steps 0-4 until no more new links are added, but (especially <br> *    in step 0) we only bother with lines which have not yet been matched. <br> *    This means that a line which has only one unmatched instance in each <br> *    file gets a count of one and so is a new anchor point. <br> * <br> *    Finally build a composite list from the two lists of sections. <br> * <br> ***************************************************************************/ <br>void <br>ci_compare(COMPITEM ci) <br>{ <br>        LIST lines_left, lines_right; <br>        SECTION whole_left, whole_right; <br>        BOOL bChanges; <br> <br>        /* get the list of lines for each file */ <br>        lines_left = file_getlinelist(ci-&gt;left); <br>        lines_right = file_getlinelist(ci-&gt;right); <br> <br>        if ((lines_left == NULL) || (lines_right == NULL)) { <br>                ci-&gt;secs_left = NULL; <br>                ci-&gt;secs_right = NULL; <br>                ci-&gt;secs_composite = NULL; <br>                return; <br>        } <br> <br>        do { <br> <br>                /* we have made no changes so far this time round the <br>                 * loop <br>                 */ <br>                bChanges = FALSE; <br> <br>                /* make a section covering the whole file */ <br>                whole_left = section_new(List_First(lines_left), <br>                                         List_Last(lines_left), NULL); <br> <br>                whole_right = section_new(List_First(lines_right), <br>                                         List_Last(lines_right), NULL); <br> <br>                /* link up matching unique lines between these sections */ <br>                if (section_match(whole_left, whole_right)) { <br>                        bChanges = TRUE; <br>                } <br> <br>                /* delete the two temp sections */ <br>                section_delete(whole_left); <br>                section_delete(whole_right); <br> <br>                /* discard previous section lists if made */ <br>                if (ci-&gt;secs_left) { <br>                        section_deletelist(ci-&gt;secs_left); <br>                        ci-&gt;secs_left = NULL; <br>                } <br>                if (ci-&gt;secs_right) { <br>                        section_deletelist(ci-&gt;secs_right); <br>                        ci-&gt;secs_right = NULL; <br>                } <br>                /* build new section lists for both files */ <br>                ci-&gt;secs_left = section_makelist(lines_left, TRUE); <br>                ci-&gt;secs_right = section_makelist(lines_right, FALSE); <br> <br>                /* match up sections - make links and corresponds between <br>                 * sections. Attempts to section_match corresponding <br>                 * sections that are not matched. returns true if any <br>                 * further links were made </code></pre>
<p>
</p>
<pre><code>*/ <br>                if (section_matchlists(ci-&gt;secs_left, ci-&gt;secs_right)) { <br>                        bChanges = TRUE; <br>                } <br> <br>        /* repeat as long as we keep adding new links */ <br> <br>        } while (bChanges); <br> <br>        /* all possible lines linked, and section lists made . <br>         * combine the two section lists to get a view of the <br>         * whole comparison - the composite section list. This also <br>         * sets the state of each section in the composite list. <br>         */ <br>        ci-&gt;secs_composite = section_makecomposite(ci-&gt;secs_left, ci-&gt;secs_right); <br> <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
