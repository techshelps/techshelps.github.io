<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIEW.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5569"></a>VIEW.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: VIEW.C <br>* <br>* Maps rows in window to items in COMPLIST <br>* <br>* Functions: <br>* <br>* view_new() <br>* view_setcomplist() <br>* view_getcomplist() <br>* view_close() <br>* view_delete() <br>* view_outline() <br>* view_expand() <br>* view_gettext() <br>* view_getlinenr_left() <br>* view_getlinenr_right() <br>* view_getwidth() <br>* view_getrowcount() <br>* view_getstate() <br>* view_getitem() <br>* view_isexpanded() <br>* view_getcurrenttag() <br>* view_newitem() <br>* view_changeviewoptions() <br>* view_changediffoptions() <br>* view_findchange() <br>* view_outline_opt() <br>* view_freemappings() <br>* view_findrow() <br>* view_expand_item() <br>* <br>* Comments: <br>* <br>* A view owns a COMPLIST, and talks to a table window. The table window <br>* shows 3 columns: line nr, tag and text. We also need to supply a state <br>* for each row (used to select colour scheme). <br>* <br>* The COMPLIST can give us a list of its COMPITEMs. Each of these can give <br>* us a tag (eg the filenames compared) and the text (usually the compare <br>* result), and the state. We make the line number from the <br>* COMPITEM's place in the list. <br>* <br>* If we are asked to switch to 'expand' mode, we ask the selected COMPITEM <br>* for its composite section list. We can then get the state (and thus <br>* the tag) from each SECTION, and the line nr and text from the LINEs within <br>* each section. <br>* <br>* When moving between expand and outline, and when refreshing the view <br>* for some option change, we have to be careful to keep the current row <br>* and the selected row in the table what the user would expect. <br>* <br>* Functions in this module can be called from the UI thread (to refresh <br>* the display) and simultaneously from a worker thread to update the <br>* view mapping (view_setcomplist, view_newitem). We use a critical section <br>* to manage the synchronisation. We need to protect all access/modification <br>* to the view structure elements (particularly bExpand, rows, pLines and <br>* pItems), BUT we must not hold the critical section over any calls <br>* to SendMessage. <br>* <br>* We use the global options in windiff.h, and we allocate memory from the <br>* heap hHeap which has been initialised elsewhere. Points in time-intensive <br>* loops call Poll() defined elsewhere. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "gutils.h" <br>#include "table.h" <br>#include "state.h" <br>#include "windiff.h" <br>#include "wdiffrc.h" <br>#include "list.h" <br>#include "line.h" <br>#include "scandir.h" <br>#include "file.h" <br>#include "section.h" <br>#include "compitem.h" <br>#include "complist.h" <br>#include "view.h" <br> <br>/* <br> * data structures <br> */ <br> <br>/* in expand mode, we keep an array of one of these per screen line. */ <br>typedef struct viewline { <br>        LINE line;              /* handle to LINE for this row */ <br>        SECTION section;        /* handle to section containing this line */ <br>        int nr_left;            /* line nr in left file */ <br>        int nr_right;           /* line nr in right file */ <br>} VIEWLINE, FAR * PVIEWLINE; <br> <br> <br>/* <br> * The users VIEW handle is in fact a pointer to this structure <br> */ <br>struct view { <br> <br>        HWND     hwnd;          /* the table window to send notifies to */ <br> <br>        COMPLIST cl;            /* the complist that we own */ <br> <br>   BOOL          bExpand;       /* true if we are in expand mode */ <br> <br>        COMPITEM ciSelect;      /* selected compitem (in expand mode) */ <br> <br>        int      rows;          /* number of rows in this view */ <br> <br>        char     nrtext[12];    /* we use this in view_gettext for the line <br>                                 * number column. overwritten on each call <br>                                 */ <br>        int      maxtag, maxrest;/* column widths in characters for cols 1, 2 */ <br> <br>        /* if we are in outline mode, we map the row number to one entry <br>         * in this array of COMPITEM handles. this pointer will <br>         * be NULL in expand mode <br>         */ <br>        COMPITEM FAR * pItems; <br> <br>        /* in expand mode we use this array of line and section handles */ <br>        PVIEWLINE pLines; <br>}; <br> <br> <br>CRITICAL_SECTION CSView; <br>static BOOL bDoneInit = FALSE; <br> <br>#define ViewEnter()     EnterCriticalSection(&amp;CSView); <br>#define ViewLeave()     LeaveCriticalSection(&amp;CSView); <br> <br>void view_outline_opt(VIEW view, BOOL bRedraw); <br>void view_freemappings(VIEW view); <br>int view_findrow(VIEW view, int number, BOOL bRight); <br>BOOL view_expand_item(VIEW view, COMPITEM ci); <br> <br> <br>/*************************************************************************** <br> * Function: view_new <br> * <br> * Purpose: <br> * <br> * Create a new view. At this point, we are told the table window handle, <br> * and nothing else. <br> * <br> */ <br>VIEW <br>view_new(HWND hwndTable) <br>{ <br>        VIEW view; <br> <br>        if (!bDoneInit) { <br>                InitializeCriticalSection(&amp;CSView); <br>                bDoneInit = TRUE; <br>        } <br> <br>        /* alloc the view from the heap */ <br>        view = (VIEW) gmem_get(hHeap, sizeof(struct view)); <br> <br>        /* set the default fields */ <br>        view-&gt;hwnd = hwndTable; <br>        view-&gt;cl = NULL; <br>        view-&gt;bExpand = FALSE; <br>        view-&gt;ciSelect = NULL; <br>        view-&gt;rows = 0; <br>        view-&gt;pItems = NULL; <br>        view-&gt;pLines = NULL; <br> <br>        return(view); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_setcomplist <br> * <br> * Purpose: <br> * <br> * We have to separate view_new and view_setcomplist because we need <br> * to give the view handle to the complist and the complist handle to the <br> * view. So do a view_new to create a null view; then complist_new() to <br> * which you pass a view handle. The complist will then register itself <br> * with the view by calling this function. During the build of the complist, <br> * it will also update us by calling view_additem, so that we can refresh <br> * the display. <br> * <br> * Here we should initialise an outline view of the complist. <br> * <br> * We also talk to the status bar using SetNames to set the names of <br> * the two items. <br> */ <br>BOOL <br>view_setcomplist(VIEW view, COMPLIST cl) <br>{ <br>        LPSTR left, right, both; <br> <br>        if (view == NULL) { <br>                return(FALSE); <br>        } <br> <br>        /* there can be only one call to this per VIEW */ <br>        if (view-&gt;cl != NULL) { <br>                return (FALSE); <br>        } <br> <br>        ViewEnter(); <br> <br>        view-&gt;cl = cl; <br> <br>        /* set names on status bar to root names of left and right trees */ <br>        left = complist_getroot_left(cl); <br>        right = complist_getroot_right(cl); <br>        both = gmem_get(hHeap, lstrlen(left) + lstrlen(right) +4); <br>        wsprintf((LPTSTR)both, "%s : %s", left, right); <br>        ViewLeave();    <br>        SetNames(both); <br>        ViewEnter();    <br>        gmem_free(hHeap, both, lstrlen(both)+1); <br>        complist_freeroot_left(cl, left); <br>        complist_freeroot_right(cl, right); <br> <br>        ViewLeave(); <br> <br>        view_outline(view); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_getcomplist <br> * <br> * Purpose: <br> * <br> * Return a handle to the complist owned by this view <br> */ <br>COMPLIST <br>view_getcomplist(VIEW view) <br>{ <br>        if (view == NULL) { <br>                return(NULL); <br>        } <br> <br>        return(view-&gt;cl); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_close <br> * <br> * Purpose: <br> * <br> * Close a view. Notify the table window that this view should be <br> * closed. When the table window has finished with it, it will send <br> * a TQ_CLOSE notify that should result in view_delete being called <br> * and the memory being freed. <br> */ <br>void <br>view_close(VIEW view) <br>{ <br>        if (view == NULL) { <br>                return; <br>        } <br> <br>        SendMessage(view-&gt;hwnd, TM_NEWID, 0, 0); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_delete <br> * <br> * Purpose: <br> * <br> * Delete a view and all associated data. <br> * <br> * This function should only be called in response to the table window <br> * sending a TQ_CLOSE message. To close the view, call view_close and <br> * wait for the TQ_CLOSE before calling this. <br> * <br> * We delete the associated COMPLIST and all its associated structures. <br> */ <br>void <br>view_delete(VIEW view) <br>{ <br>        if (view == NULL) { <br>                return; <br>        } <br> <br>        /* we have two arrays that are used for the mapping - an array <br>         * of compitem handles in outline mode, and an array of <br>         * VIEWLINE structures in expand mode <br>         */ <br> <br>        view_freemappings(view); <br> <br>        complist_delete(view-&gt;cl); <br> <br>        gmem_free(hHeap, (LPSTR) view, sizeof(struct view)); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_outline <br> * <br> * Purpose: <br> * <br> * Build an outline mode mapping where one row represents one COMPITEM in <br> * the list. Check the global option flag outline_include to see which items <br> * we should include. <br> * <br> * If we were in expand mode, then set as the selection the row in outline mode <br> * that we were expanding. Also remember to free up the expand mode mapping <br> * array <br> * <br> * Once we have built the new mapping, notify the table window to <br> * redraw itself. <br> */ <br>void <br>view_outline(VIEW view) <br>{ <br>        if (view == NULL) { <br>                return; <br>        } <br> <br>        /* all work done by view_outline_opt - this function <br>         * gives us the option of not updating the display <br>         */ <br>        view_outline_opt(view, TRUE); <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: view_expand <br> * <br> * Purpose: <br> * <br> * Switch to expand mode, expanding the given row into a view <br> * of the differences in that file. <br> * <br> * Map the given row nr into a compitem handle, and then <br> * call the internal function with that. <br> */ <br>BOOL     <br>view_expand(VIEW view, long row) <br>{ <br>        COMPITEM ci; <br>        BOOL bRet; <br> <br>        ViewEnter(); <br> <br>        if ((view == NULL) || (view-&gt;bExpand)) { <br>                /* no view, or already expanded */ <br>                ViewLeave(); <br>                return(FALSE); <br>        } <br> <br>        if (row &gt;= view-&gt;rows) { <br>                /* no such row */ <br>                ViewLeave(); <br>                return FALSE; <br>        } <br> <br>        /* remember the compitem we are expanding */ <br>        ci = view-&gt;pItems[row]; <br> <br>        bRet = view_expand_item(view, ci); <br>        // view_expand_item does the... <br>        // ViewLeave(); <br>        return(bRet); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_gettext <br> * <br> * Purpose: <br> * <br> * Return the text associated with a given column of a given row. <br> * Return a pointer that does not need to be freed after use - ie <br> * a pointer into our data somewhere, not a copy <br> */ <br>LPSTR <br>view_gettext(VIEW view, long row, int col) <br>{ <br>        int line; <br>        int state; <br>        LPSTR pstr; <br> <br> <br>        if (view == NULL) { <br>                return (NULL); <br>        } <br> <br>        ViewEnter(); <br> <br>        if (row &gt;= view-&gt;rows) { <br>                ViewLeave(); <br>                return(NULL); <br>        } <br> <br>        if (view-&gt;bExpand) { <br>                /* we are in expand mode */ <br>                 <br>                state = section_getstate(view-&gt;pLines[row].section); <br> <br>                switch(col) { <br>                case 0: <br>                        /* row nr */ <br>                                                 <br>                        /* line numbers can be from either original file <br>                         * this is a menu-selectable option <br>                         */ <br>                        switch(line_numbers) { <br>                        case IDM_NONRS: <br>                                pstr = NULL; <br>                                break; <br> <br>                        case IDM_LNRS: <br>                                line = view-&gt;pLines[row].nr_left; <br>                                if (state == STATE_MOVEDRIGHT) { <br>                                        line = -line; <br>                                } <br>                                break; <br> <br>                        case IDM_RNRS: <br>                                line = view-&gt;pLines[row].nr_right; <br>                                if (state == STATE_MOVEDLEFT) { <br>                                        line = -line; <br>                                } <br>                                break; <br>                        } <br>                        if (line == 0) { <br>                                ViewLeave(); <br>                                return(NULL); <br>                        } <br> <br>                        if (line &lt; 0) { <br>                                /* lines that are moved appear twice. <br>                                 * show the correct-sequence line nr <br>                                 * for the out-of-seq. copy in brackets. <br>                                 */ <br>                                wsprintf((LPTSTR)view-&gt;nrtext, "(%d)", abs(line)); <br>                        } else  { <br>                                wsprintf((LPTSTR)view-&gt;nrtext, "%d", line); <br>                        } <br>                        pstr = view-&gt;nrtext; <br>                        break; <br> <br>                case 1: <br>                        /* tag text - represents the state of the line */ <br> <br> <br>                        switch(state) { <br>                        case STATE_SAME: <br>                                pstr = "    "; <br>                                break; <br> <br>                        case STATE_LEFTONLY: <br>                                pstr = " &lt;! "; <br>                                break; <br> <br>                        case STATE_RIGHTONLY: <br>                                pstr = " !&gt; "; <br>                                break; <br> <br>                        case STATE_MOVEDLEFT: <br>                                pstr = " &lt;- "; <br>                                break; <br> <br>                        case STATE_MOVEDRIGHT: <br>                                pstr = " -&gt; "; <br>                                break; <br>                        } <br>                        break; <br> <br>                case 2: <br>                        /* main text - line */ <br>                        pstr = line_gettext(view-&gt;pLines[row].line); <br>                        break; <br>                } <br>        } else { <br>                /* outline mode */ <br>                switch(col) { <br>                case 0: <br>                        /* row number - just the line number */ <br>                        wsprintf((LPTSTR)view-&gt;nrtext, "%d", row+1); <br>                        pstr = view-&gt;nrtext; <br>                        break; <br> <br>                case 1: <br>                        /* tag */ <br>                        pstr = compitem_gettext_tag(view-&gt;pItems[row]); <br>                        break; <br> <br>                case 2: <br>                        /* result text */ <br>                        pstr = compitem_gettext_result(view-&gt;pItems[row]); <br>                        break; <br>                } <br>        } <br>        ViewLeave(); <br>        return(pstr); <br>} <br> <br>/*************************************************************************** <br> * Function: view_getlinenr_left <br> * <br> * Purpose: <br> * <br> * Return the line number that this row had in the original left <br> * file. 0 if not in expand mode. 0 if this row was not in the left file. <br> * -(linenr) if this row is a MOVED line, and this is the right file <br> * copy <br> */ <br>int <br>view_getlinenr_left(VIEW view, long row) <br>{ <br>        int state, line; <br> <br>        if ((view == NULL) || (row &gt;= view-&gt;rows) || !view-&gt;bExpand) { <br>                return 0; <br>        } <br> <br>        ViewEnter(); <br>        state = section_getstate(view-&gt;pLines[row].section); <br>        line = view-&gt;pLines[row].nr_left; <br>        if (state == STATE_MOVEDRIGHT) { <br>                line = -line; <br>        } <br>        ViewLeave(); <br> <br>        return(line); <br>} <br> <br>/*************************************************************************** <br> * Function: view_getlinenr_right <br> * <br> * Purpose: <br> * <br> * Return the line number that this row had in the original right <br> * file. 0 if not in expand mode. 0 if this row was not in the right file. <br> * -(linenr) if this row is a MOVED line, and this is the left file <br> * copy <br> */ <br>int <br>view_getlinenr_right(VIEW view, long row) <br>{ <br>        int state, line; <br> <br>        if ((view == NULL) || (row &gt; view-&gt;rows) || !view-&gt;bExpand) { <br>                return 0; <br>        } <br> <br>        ViewEnter(); <br> <br>        state = section_getstate(view-&gt;pLines[row].section); <br>        line = view-&gt;pLines[row].nr_right; <br>        if (state == STATE_MOVEDLEFT) { <br>                line = -line; <br>        } <br>        ViewLeave(); <br> <br>        return(line); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_getwidth <br> * <br> * Purpose: <br> * <br> * Find the maximum width in characters for the given column  <br> */ <br>int <br>view_getwidth(VIEW view, int col) <br>{ <br>        if (view == NULL) { <br>                return(0); <br>        } <br> <br>        switch(col) { <br>        case 0: <br>                /* line nr column - always 5 characters wide */ <br>                return(5); <br> <br>        case 1: <br>                /* this is a proportional font field, so add on a margin <br>                 * for error <br>                 */ <br>                return(view-&gt;maxtag + (view-&gt;maxtag / 20)); <br>        case 2: <br>                /* this now includes the tab expansion allowance */ <br>                return(view-&gt;maxrest); <br>        default: <br>                return(0); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: view_getrowcount <br> * <br> * Purpose: <br> * <br> * How many rows are there in this view ?  <br> */ <br>long <br>view_getrowcount(VIEW view) <br>{ <br>        if (view == NULL) { <br>                return(0); <br>        } <br> <br>        return(view-&gt;rows); <br>} <br> <br>/*************************************************************************** <br> * Function: view_getstate <br> * <br> * Purpose: <br> * <br> * Return the state for the current row. This is used <br> * to select the text colour for the row <br> * <br> * States for sections are obtained from section_getstate (and apply, and <br> * to all lines in that section. States for compitems are obtained <br> * from compitem_getstate. <br> */ <br>int <br>view_getstate(VIEW view, long row) <br>{ <br>        int state; <br> <br>        if (view == NULL) { <br>                return(0); <br>        } <br> <br>        ViewEnter(); <br>        if (row &gt;= view-&gt;rows) { <br>                state = 0; <br>        } else if (view-&gt;bExpand) { <br>                /* its a line state that's needed */ <br>                state = section_getstate(view-&gt;pLines[row].section); <br>        } else { <br> <br>                /* its a compitem state */ <br>                state = compitem_getstate(view-&gt;pItems[row]); <br>        } <br>        ViewLeave(); <br>        return(state); <br>} <br> <br>/*************************************************************************** <br> * Function: view_gethandle <br> * <br> * Purpose: <br> * <br> * Return a handle to the current compitem. In expand mode, <br> * returns the handle to the compitem we are expanding. In outline <br> * mode, returns the handle to the compitem for the given row, if valid, <br> * or NULL otherwise. row is only used if not in expand mode. <br> */ <br>COMPITEM <br>view_getitem(VIEW view, long row) <br>{ <br>        COMPITEM ci; <br> <br>        if (view == NULL) { <br>                return(NULL); <br>        } <br> <br>        ViewEnter(); <br> <br>        if (!view-&gt;bExpand) { <br>                if ((row &gt;= 0) &amp;&amp; (row &lt; view-&gt;rows)) { <br>                        ci = view-&gt;pItems[row]; <br>                } else { <br>                        ci = NULL; <br>                } <br>        } else { <br>                ci = view-&gt;ciSelect; <br>        } <br> <br>        ViewLeave(); <br>        return(ci); <br>} <br> <br>/*************************************************************************** <br> * Function: view_isexpanded <br> * <br> * Purpose: <br> * <br> * Return TRUE if the current mapping is expanded mode <br> */ <br>BOOL <br>view_isexpanded(VIEW view)       <br>{ <br>        if (view == NULL) { <br>                return(FALSE); <br>        } <br>        return(view-&gt;bExpand); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_getcurrenttag <br> * <br> * Purpose: <br> * <br> * Return a text string describing the view. This is NULL in outline mode, <br> * or the tag text for the current compitem in expanded mode <br> */ <br>LPSTR <br>view_getcurrenttag(VIEW view) <br>{ <br>        LPSTR str; <br> <br>        if ((view == NULL) || (!view-&gt;bExpand)) { <br>                return(NULL); <br>        } else { <br>                ViewEnter(); <br> <br>                str = compitem_gettext_tag(view-&gt;ciSelect); <br> <br>                ViewLeave(); <br>                return(str); <br> <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_newitem <br> * <br> * Purpose: <br> * <br> * Notify that CompItems have been added to the complist. <br> * <br> * Rebuild the view (if in outline mode), and refresh the table. Use <br> * the table message TM_APPEND if possible (if column widths have not <br> * change). If we have to do TM_NEWLAYOUT, then ensure we scroll <br> * back to the right row afterwards. <br> * <br> * This causes a Poll() to take place. We return TRUE if an abort is <br> * pending - in this case, the caller should abandon the scan loop. <br> * <br> * Enter the critical section for this function since this can be <br> * called from the worker thread while the UI thread is using the <br> * view that we are about to change. <br> * <br> * EXCEPT THAT WE DON'T DARE.  We cannot ever call SendMessage from the <br> * worker thread within CSView.  If there is conflict, it will hang. <br> */ <br>BOOL <br>view_newitem(VIEW view) <br>{ <br>        int maxtag, maxrest; <br>        long rownr; <br> <br>        if ((view == NULL) || (view-&gt;bExpand)) { <br>                /* not in outline mode - nothing to do */ <br>                return(Poll()); <br>        } <br> <br>        /* save some state about the present mapping */ <br>        maxtag = view-&gt;maxtag; <br>        maxrest = view-&gt;maxrest; <br> <br>        /* re-do the outline mapping, but don't tell the table <br>         * class. <br>         */ <br>        view_outline_opt(view, FALSE); <br> <br>        /* have the column widths changed ? */ <br>        if ((maxtag &lt; view-&gt;maxtag) || (maxrest &lt; view-&gt;maxrest)) { <br>                /* yes - need complete redraw */ <br> <br>                /* find the row at the top of the window */ <br>                rownr = SendMessage(view-&gt;hwnd, TM_TOPROW, FALSE, 0); <br> <br>                /* switch to new mapping */ <br>                SendMessage(view-&gt;hwnd, TM_NEWLAYOUT, 0, (DWORD) view); <br> <br>                /* return to old row if possible - we know <br>                 * that row is still there since we have only added <br>                 * rows, and not changed any of the existing mapping <br>                 * <br>                 * Alas this is no longer true.  However the table class <br>                 * will defend itself against calls for a bogus top row. <br>                 */ <br>                if (rownr &gt;= 0) { <br>                        SendMessage(view-&gt;hwnd, TM_TOPROW, TRUE, rownr); <br>                } <br>        } else { <br>                /* no - we can just append */ <br> <br>                /* <br>                 * The mapping may have <br>                 * changed since we released the critsec. however we are still <br>                 * safe. The table will not allow us to reduce the number of <br>                 * rows, so the worst that can happen is that the table will <br>                 * think there are too many rows, and the table message handler <br>                 * will handle this correctly (return null for the text). <br>                 * The only visible effect is therefore that the scrollbar <br>                 * position is wrong. <br>                 */ <br> <br>                SendMessage(view-&gt;hwnd, TM_APPEND, view-&gt;rows, (DWORD) view); <br>        } <br> <br> <br>        /* Poll to keep the UI updated on NT. Returns true if abort pending. <br>         */ <br>        return(Poll()); <br>} <br> <br>/*************************************************************************** <br> * Function: view_changeviewoptions <br> * <br> * Purpose: <br> * <br> * The view mapping options (eg outline_include, expand_mode) have changed - <br> * re-do the mapping and then scroll back to the same position in the window <br> * if possible. <br> */ <br>void <br>view_changeviewoptions(VIEW view) <br>{ <br>        long row; <br>        int state, number; <br>        BOOL bRight; <br> <br>        if (view == NULL) { <br>                return; <br>        } <br> <br>        /* find what row we are currently on. Do this BEFORE we enter CSView */ <br>        row = SendMessage(view-&gt;hwnd, TM_TOPROW, FALSE, 0); <br> <br>        ViewEnter(); <br> <br>        if (!view-&gt;bExpand) { <br> <br>                /* outline mode. maintaining current position is <br>                 * unimportant <br>                 */ <br>                view_outline(view); <br>                ViewLeave(); <br>                return; <br>        } <br> <br>        /* expanded mode */ <br>         <br> <br>        /* save the line number on one side (and remember which side) */ <br>        if (row &gt;= view-&gt;rows) { <br>                number = -1; <br>        } else { <br>                state = section_getstate(view-&gt;pLines[row].section); <br>                if ((state == STATE_MOVEDRIGHT) || <br>                    (state == STATE_RIGHTONLY)) { <br>                            bRight = TRUE; <br>                            number = view-&gt;pLines[row].nr_right; <br>                } else { <br>                        bRight = FALSE; <br>                        number = view-&gt;pLines[row].nr_left; <br>                } <br>        } <br> <br>        /* make the new mapping */ <br>        view_expand_item(view, view-&gt;ciSelect); <br> <br>        /* find the nearest row in the new view */ <br>        if (number &gt;= 0) { <br> <br>                ViewEnter(); <br>                row = view_findrow(view, number, bRight); <br>                ViewLeave(); <br>         <br>                /* scroll this row to top of window */ <br>                if (row &gt;= 0) { <br> <br>                        SendMessage(view-&gt;hwnd, TM_TOPROW, TRUE, row); <br>                        return; <br>                } <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: view_changediffoptions <br> * <br> * Purpose: <br> * <br> * The compare options have changed - re-do the compare completely <br> * and make the new mapping. Retain current position in the file. <br> */ <br>void <br>view_changediffoptions(VIEW view) <br>{ <br>        int state, number; <br>        long row; <br>        BOOL bRight; <br>        LIST li; <br>        COMPITEM ci; <br> <br>        if (view == NULL) { <br>                return; <br>        } <br> <br>        /* <br>         * get current row before entering critsec. <br>         */ <br>        row = SendMessage(view-&gt;hwnd, TM_TOPROW, FALSE, 0); <br> <br>        ViewEnter(); <br> <br>        /* find the current line number so we can go back to it <br>         * (only if we are in expanded mode <br>         */ <br>        if (view-&gt;bExpand) { <br> <br>                state = section_getstate(view-&gt;pLines[row].section); <br>                if ((state == STATE_MOVEDRIGHT) || <br>                    (state == STATE_RIGHTONLY)) { <br>                            bRight = TRUE; <br>                            number = view-&gt;pLines[row].nr_right; <br>                } else { <br>                        bRight = FALSE; <br>                        number = view-&gt;pLines[row].nr_left; <br>                } <br>        } <br> <br>        /* To force a recompare using the new options, we must <br>         * tell each compitem to discard its current compare result. <br>         * We need to traverse the list of compitems calling this <br>         * for each compare. <br>         */ <br>        li = complist_getitems(view-&gt;cl); <br> <br>        for (ci = (COMPITEM) List_First(li); ci != NULL; ci = (COMPITEM) List_Next(ci)) { <br>                compitem_discardsections(ci); <br>        } <br> <br>        /* if we are in outline mode, we have nothing more to do */ <br>        if (!view-&gt;bExpand) { <br>                ViewLeave(); <br>                return; <br>        } <br> <br>        view_expand_item(view, view-&gt;ciSelect); <br> <br>        /* find the nearest row in the new view */ <br>        ViewEnter(); <br>        row = view_findrow(view, number, bRight); <br>        ViewLeave(); <br> <br>        /* scroll this row to top of window */ <br>        if (row &gt;= 0) { <br>                SendMessage(view-&gt;hwnd, TM_TOPROW, TRUE, row); <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_findchange <br> * </code></pre>
<p>
</p>
<pre><code>* Purpose: <br> * <br> * Find the next changed - ie non-same - row in a given direction. <br> * For outline mode we find the next STATE_DIFFER. For expand mode, we <br> * find the next section <br> */ <br>long <br>view_findchange(VIEW view, long startrow, BOOL bForward) <br>{ <br>        long i; <br> <br>        if (view == NULL) { <br>                return(0); <br>        } <br> <br>        ViewEnter(); <br> <br>        if (bForward) { <br> <br>                if (startrow &gt;= view-&gt;rows) { <br>                        ViewLeave(); <br>                        return(-1); <br>                } <br> <br>                if (!view-&gt;bExpand) { <br> <br>                        /* look for next compitem with an expandable state*/ <br>                        for (i = startrow; i &lt; view-&gt;rows; i++) { <br>                                if (compitem_getstate(view-&gt;pItems[i]) == STATE_DIFFER) { <br>                                        ViewLeave(); <br>                                        return(i); <br>                                } <br>                        } <br>                        /* none found */ <br>                        ViewLeave(); <br>                        return(-1); <br>                } else { <br>                        /* <br>                         * find the next line that matches, then go on to the <br>                         * next line that does not match <br>                         * <br>                         */ <br>                        for (i= startrow; i &lt; view-&gt;rows; i++) { <br>                                if (section_getstate(view-&gt;pLines[i].section) <br>                                        == STATE_SAME) { <br>                                                break; <br>                                } <br>                        } <br>                        for ( ; i &lt; view-&gt;rows; i++) { <br>                                if (section_getstate(view-&gt;pLines[i].section) <br>                                        != STATE_SAME) { <br>                                                ViewLeave(); <br>                                                return(i); <br>                                } <br>                        } <br> <br>                        ViewLeave(); <br> <br>                        return(-1); <br>                } <br>        } else { <br>                /* same search backwards */ <br>                if (startrow &lt;= 0) { <br>                        ViewLeave(); <br>                        return(-1); <br>                } <br>                if (view-&gt;bExpand) { <br>                        /* search backwards for first row that is not <br>                         * changed (has state SAME). then carry on for <br>                         * the next changed row. <br>                         */ <br>                        for (i = startrow; i &gt;= 0; i--) { <br>                                if (section_getstate(view-&gt;pLines[i].section) <br>                                        == STATE_SAME) { <br>                                                break; <br>                                } <br>                        } <br>                        for ( ; i &gt;= 0; i--) { <br>                                if (section_getstate(view-&gt;pLines[i].section) <br>                                        != STATE_SAME) { <br>                                                ViewLeave(); <br>                                                return(i); <br>                                } <br>                        } <br>                        ViewLeave(); <br>                        return(-1); <br>                } else { <br>                        for (i = startrow; i &gt;= 0; i--) { <br>                                if(compitem_getstate(view-&gt;pItems[i]) == STATE_DIFFER) { <br>                                        ViewLeave(); <br>                                        return(i); <br>                                } <br>                        } <br>                        ViewLeave(); <br>                        return(-1); <br>                } <br>        } <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: view_findrow <br> * <br> * Purpose: <br> * <br> * Find the new row number for the line numbered 'number' <br> * or the nearest line if possible. If bRight is true, number is <br> * a right file number; otherwise it is a left file number. <br> * <br> * We must be in expand mode <br> */ <br>int      <br>view_findrow(VIEW view, int number, BOOL bRight) <br>{ <br>        int i; <br> <br>        if (!view-&gt;bExpand) {    <br>                return(0); <br>        } <br> <br>        for (i = 0; i &lt; view-&gt;rows; i++) { <br> <br>                if (bRight) { <br>                        if (view-&gt;pLines[i].nr_right == number) { <br> <br>                                /* found the exact number */ <br>                                return(i); <br> <br>                        } else if (view-&gt;pLines[i].nr_right &gt; number) { <br> <br>                                /* passed our line -stop here */ <br>                                return(i); <br>                        } <br>                } else { <br>                        if (view-&gt;pLines[i].nr_left == number) { <br> <br>                                /* found the exact number */ <br>                                return(i); <br> <br>                        } else if (view-&gt;pLines[i].nr_left &gt; number) { <br> <br>                                /* passed our line -stop here */ <br>                                return(i); <br>                        } <br>                } <br>        } <br>        return(-1); <br>} <br> <br>/*************************************************************************** <br> * Function: view_freemappings <br> * <br> * Purpose: <br> * <br> * Free memory associated with the expand mode or outline mode mappings <br> * called whenever we rebuild the mapping, and on deletion <br> */ <br>void <br>view_freemappings(VIEW view) <br>{ <br> <br>        if (view-&gt;pLines) { <br>                gmem_free(hHeap, (LPSTR) view-&gt;pLines, <br>                        view-&gt;rows * sizeof(VIEWLINE)); <br>                view-&gt;pLines = NULL; <br>        } else if (view-&gt;pItems) { <br> <br>                /* previous outline mapping array is still there - free it <br>                 * before we build a new one <br>                 */ <br> <br>                gmem_free(hHeap, (LPSTR) view-&gt;pItems, <br>                        view-&gt;rows * sizeof(COMPLIST)); <br>                view-&gt;pItems = NULL; <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: view_outline_opt <br> * <br> * Purpose: <br> * <br> * Build a view outline to map one row to a COMPITEM handle by traversing <br> * the list of COMPITEMs obtained from our complist. <br> * Optionally tell the table class to redraw (if bRedraw), and if so, <br> * scroll the new table to select the row that represents the <br> * file we were expanding, if possible <br> */ <br>void <br>view_outline_opt(VIEW view, BOOL bRedraw) <br>{ <br>        int prev_row = -1;      /* the row nr of the previously-expanded row*/ <br>        int i;                  /* nr of includable items */ <br>        LIST li; <br>        COMPITEM ci; <br>        int state; <br>        TableSelection select; <br> <br>        /* <br>         * check that view_setcomplist has already been called. if not, <br>         * nothing to do <br>         */ <br>        if (view-&gt;cl == NULL) { <br>                return; <br>        } <br> <br>        ViewEnter(); <br> <br>        /* clear the mode flag and free up memory associated with expand mode */ <br>        view-&gt;bExpand = FALSE; <br>        view_freemappings(view); <br> <br>        /* traverse the list of compitems counting up the number of <br>         * includable items <br>         */ <br>        li = complist_getitems(view-&gt;cl); <br> <br>        ci = (COMPITEM) List_First(li); <br>        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) { <br> <br>                state = compitem_getstate(ci); <br> <br>                if (((outline_include &amp; INCLUDE_SAME) &amp;&amp; (state == STATE_SAME)) || <br>                    ((outline_include &amp; INCLUDE_DIFFER) &amp;&amp; (state == STATE_DIFFER)) || <br>                    ((outline_include &amp; INCLUDE_LEFTONLY) &amp;&amp; (state == STATE_FILELEFTONLY)) || <br>                    ((outline_include &amp; INCLUDE_RIGHTONLY) &amp;&amp; (state == STATE_FILERIGHTONLY))) { <br>                        i++; <br>                } <br>        } <br> <br> <br>        /* allocate an array big enough for all of these */ <br>        view-&gt;pItems = (COMPITEM FAR *) gmem_get(hHeap, i * sizeof(COMPITEM)); <br>        view-&gt;rows = i; <br> <br>        /* keep track of the column widths */ <br>        view-&gt;maxtag = 0; <br>        view-&gt;maxrest = 0; <br> <br>        /* loop through again filling the array, and at the same time looking <br>         * out for the handle of the previously expanded item <br>         */ <br>        ci = (COMPITEM) List_First(li); <br>        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) { <br> <br>                state = compitem_getstate(ci); <br> <br>                if (((outline_include &amp; INCLUDE_SAME) &amp;&amp; (state == STATE_SAME)) || <br>                    ((outline_include &amp; INCLUDE_DIFFER) &amp;&amp; (state == STATE_DIFFER)) || <br>                    ((outline_include &amp; INCLUDE_LEFTONLY) &amp;&amp; (state == STATE_FILELEFTONLY)) || <br>                    ((outline_include &amp; INCLUDE_RIGHTONLY) &amp;&amp; (state == STATE_FILERIGHTONLY))) { <br> <br>                        view-&gt;pItems[i] = ci; <br> <br>                        if (ci == view-&gt;ciSelect) { <br>                                prev_row = i; <br>                        } <br> <br>                        /* check the column widths in characters */ <br>                        view-&gt;maxtag = max(view-&gt;maxtag, <br>                                           lstrlen(compitem_gettext_tag(ci))); <br>                        view-&gt;maxrest = max(view-&gt;maxrest, <br>                                            lstrlen(compitem_gettext_result(ci))); <br> <br> <br>                        i++; <br> <br>                } <br>        } <br>        ViewLeave(); <br> <br>        /* inform table of new layout of table - force refresh */        <br>        if (bRedraw) { <br>                SendMessage(view-&gt;hwnd, TM_NEWLAYOUT, 0, (DWORD) view); <br>         <br>                /* scroll to and highlight the row that represents the file <br>                 * we were previously expanding <br>                 */ <br>                if (prev_row != -1) { <br>                        select.startrow = prev_row; <br>                        select.startcell = 0; <br>                        select.nrows = 1; <br>                        select.ncells = 1; <br>                        SendMessage(view-&gt;hwnd, TM_SELECT, 0, <br>                                (DWORD) (LPSTR) &amp;select); <br>                } <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: view_expand_item <br> * <br> * Purpose: <br> * <br> * Expand a view - given the handle to the compitem to expand. <br> * <br> * Called from view_expand, and also to re-do an expanded view <br> * after options change in view_changediffoptions and _changeviewoptions <br> * <br> * We get the composite section list from the compitem, <br> * and pick out all the sections that are includable (according <br> * to the global option expand_mode: we include all sections, or <br> * just those in one side left or right). Once we know the count of rows, <br> * allocate the mapping array: in each element of the array we keep <br> * a handle to the section for that row (to get the state and hence the <br> * tag text), and a handle to the line within that section (for the line text). <br> * <br> * We no longer insist on only expanding text files that differ - if the <br> * compitem can give us a composite section list, we will map it. <br> * <br> * We need to be able to give a line number for a line, in either of <br> * the original files according to which option is in force. Each section <br> * can give us its base line number (number of first line in section) in <br> * each of the two files or 0 if not present, and we track these here. <br> * <br> * MUST BE INSIDE CSView BEFORE CALLING HERE. <br> */ <br>BOOL <br>view_expand_item(VIEW view, COMPITEM ci) <br>{ <br>        LIST li; <br>        SECTION sh; <br>        LINE line1, line2; <br>        int i, base_left, base_right, state; <br> <br>        /* remember the compitem we are expanding */ <br>        view-&gt;ciSelect = ci; <br> <br>        /* get the composite section list */ <br>        li = compitem_getcomposite(view-&gt;ciSelect); <br>        if (li == NULL) { <br>                ViewLeave(); <br>                return FALSE; <br>        } <br> <br>        /* switch modes and free the current mapping <br>         * <br>         * NOTE: must do this AFTER the compitem_getcomposite, <br>         * since that can fail: if it fails it could put up a <br>         * message box, and that could cause a queued paint message <br>         * to be processed, which would cause us to use these mappings <br>         * and gpfault if they had been cleared first. <br>         */ <br>        view-&gt;bExpand = TRUE; <br>        view_freemappings(view); <br> <br> <br>        /* loop through totalling the lines in sections <br>         * that we should include <br>         */ <br>        view-&gt;rows = 0; <br>        for (sh = (SECTION) List_First(li); sh != NULL; <br>            sh = (SECTION) List_Next(sh)) { <br>                 <br>                state = section_getstate(sh); <br>                 <br>                if (expand_mode == IDM_RONLY) { <br>                        if ((state == STATE_LEFTONLY) || <br>                            (state == STATE_MOVEDLEFT)) { <br>                                    continue; <br>                        } <br>                } else if (expand_mode == IDM_LONLY) { <br>                        if ((state == STATE_RIGHTONLY) || <br>                            (state == STATE_MOVEDRIGHT)) { <br>                                    continue; <br>                        } <br>                } <br> <br>                /* include all lines in this section */ <br>                view-&gt;rows += section_getlinecount(sh); <br>        } <br>         <br>        /* allocate the memory for the mapping array */ <br>        view-&gt;pLines = (PVIEWLINE) gmem_get(hHeap, view-&gt;rows * sizeof(VIEWLINE)); <br>         <br>        /* loop through the sections again filling in the mapping array */ <br>        i = 0; <br>        view-&gt;maxtag = 5; <br>        view-&gt;maxrest = 0; <br>        for (sh = (SECTION) List_First(li); sh != NULL; <br>            sh = (SECTION) List_Next(sh)) { <br>                 <br>                state = section_getstate(sh); <br>                 <br>                if (expand_mode == IDM_RONLY) { <br>                        if ((state == STATE_LEFTONLY) || <br>                            (state == STATE_MOVEDLEFT)) { <br>                                    continue; <br>                        } <br>                } else if (expand_mode == IDM_LONLY) { <br>                        if ((state == STATE_RIGHTONLY) || <br>                            (state == STATE_MOVEDRIGHT)) { <br>                                    continue; <br>                        } <br>                } <br> <br>                /* find the base line number in each file */ <br>                base_left = section_getleftbasenr(sh); <br>                base_right = section_getrightbasenr(sh); <br> <br>                /* add each line in section to the view. section_getfirst() <br>                 * returns us to a handle that is in a list. We can <br>                 * call List_Next and will eventually get to the <br>                 * line returned by section_getlast(). Sections always have <br>                 * at least one line <br>                 */ <br>                line1 = section_getfirstline(sh); <br>                line2 = section_getlastline(sh); <br> <br>                for (; line1 != NULL; line1 = (LINE) List_Next(line1)) { <br> <br>                        view-&gt;pLines[i].line = line1; <br>                        view-&gt;pLines[i].section = sh; <br> <br>                        /* calculate the line number for this line by <br>                         * incrementing the base nr for this section <br>                         */ <br>                 <br>                        view-&gt;pLines[i].nr_left = base_left; <br>                        if (base_left != 0) { <br>                                base_left++; <br>                        } <br> <br>                        view-&gt;pLines[i].nr_right = base_right; <br>                        if (base_right != 0) { <br>                                base_right++; <br>                        } <br> <br>                        /* increment index into view */ <br>                        i++; <br> <br>                        /* check the column widths */ <br>                        view-&gt;maxrest = max(view-&gt;maxrest, <br>                                            (line_gettabbedlength(line1, 8))); <br> <br>                        /* end of section ? */ <br>                        if (line1 == line2) { <br>                                break; <br>                        } <br>                } <br>        } <br> <br>        /* We must NOT hold a critical section here as SendMessage may hang */ <br>        ViewLeave(); <br> <br>        /*inform table window of revised mapping */ <br>        SendMessage(view-&gt;hwnd, TM_NEWLAYOUT, 0, (DWORD) view); <br> <br>        return(TRUE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
