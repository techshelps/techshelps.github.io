<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SECTION.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5556"></a>SECTION.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: SECTION.C <br>* <br>* Manages sections of lines, and lists of sections. <br>* <br>* Functions: <br>* <br>* section_new() <br>* section_delete() <br>* section_match() <br>* section_getfirstline() <br>* section_getlastline() <br>* section_getlink() <br>* section_getcorrespond() <br>* section_getstate() <br>* section_setstate() <br>* section_getlinecount() <br>* section_getleftbasenr() <br>* section_setleftbasenr() <br>* section_getrightbasenr() <br>* section_setrightbasenr() <br>* FindEndOfUnmatched() <br>* NextNonIngnorable() <br>* FinEndOfMatched() <br>* section_makelist() <br>* section_deletelist() <br>* FindFirstWithLink() <br>* section_matchlists() <br>* section_takesection() <br>* section_makecomposite() <br>* AbsorbAnyBlanks() <br>* section_makectree() <br>* section_expandanchor() <br>* <br>* Comments: <br>* <br>* A section is a data type that represents a contiguous block of lines <br>* of the same state (all unmatched, or all matched to a contiguous block of <br>* lines). A section can link up matching lines within the section. <br>* <br>* Section list functions can make and match lists of sections from lists of <br>* lines, and create a composite list by combining sections from two lists <br>* to create a list that 'best represents' the similarities and differences <br>* between the two lists of lines. <br>*  <br>* Assumptions: the lines passed in are on a list (can be traversed with <br>* List_Next() etc. Line numbering using the section_get*basenr() <br>* functions work only if lines are numbered sequentially in ascending order. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "gutils.h" <br>#include "tree.h" <br>#include "state.h" <br>#include "windiff.h" <br>#include "wdiffrc.h" <br>#include "list.h" <br>#include "line.h" <br>#include "section.h" <br> <br>/* <br> * a section handle (SECTION) is a pointer to one of these structures <br> */ <br>struct section { <br>        LINE first;             /* first line in section */ <br>        LINE last;              /* last line in section */ <br> <br>        BOOL bDiscard;          /* true if not alloc-ed on list */ <br> <br>        SECTION link;           /* we match this section */ <br>        SECTION correspond;     /* we correspond to this section, but <br>                                 * don't match it <br>                                 */ <br> <br>        int state;              /* compare state for section */ <br> <br>        int leftbase;           /* nr in original left list of first line*/ <br>        int rightbase;          /* nr in original right list of first line*/ <br>}; <br> <br>/* --- function prototypes ------------------------------------------*/ <br> <br>TREE section_makectree(SECTION sec); <br>BOOL section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2); <br> <br> <br> <br>/*************************************************************************** <br> * Function: section_new <br> * <br> * Purpose: <br> * <br> * Makes a new section, given handles to a first and last line. <br> * <br> * A section must be at least one line long. The lines passed in must be <br> * on a list in order. <br> * <br> * If the list parameter is non-null, we will allocate the section struct <br> * on the list. otherwise we will alloc it from gmem_get(hHeap). We remember <br> * this in the bDiscard flag for section_delete, so that we only <br> * hand back to gmem_free memory that we got. <br> **************************************************************************/ <br>SECTION <br>section_new(LINE first, LINE last, LIST list) <br>{ <br>        SECTION sec; <br> <br>        /* alloc the sec and remember where we alloc-ed it */ <br>        if (list) { <br>                sec = (SECTION) List_NewLast(list, sizeof(struct section)); <br>                sec-&gt;bDiscard = TRUE; <br>        } else { <br>                sec = (SECTION) gmem_get(hHeap, sizeof(struct section)); <br>                sec-&gt;bDiscard = FALSE; <br>        } <br> <br>        sec-&gt;first = first; <br>        sec-&gt;last = last; <br>        sec-&gt;link = NULL; <br>        sec-&gt;correspond = NULL; <br>        sec-&gt;state = 0; <br>        sec-&gt;leftbase = 1; <br>        sec-&gt;rightbase = 1; <br> <br>        return(sec); <br>} <br> <br>/*************************************************************************** <br> * Function: section_delete <br> * <br> * Purpose: <br> * <br> * Discard a section. Free all associated memory (not the line list). <br> * Free up the section itself if it was not alloc-ed on a list. <br> */ <br>void <br>section_delete(SECTION section) <br>{ <br>        if (section-&gt;bDiscard) { <br>                gmem_free(hHeap, (LPSTR) section, sizeof(struct section)); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: section_match <br> * <br> * Purpose: <br> * <br> * Match up two sections: match all lines that <br> * are unique and identical between the two sections. <br> * <br> * We use a tree of line handles, keyed by the line hash code. We use a <br> * ctree, which keeps a count for multiple identical keys. This allows <br> * us to rapidly find lines that are unique within this section. <br> * We build two of these trees (one for each line list). For each line <br> * that is unique in both trees, we attempt to link the lines. <br> * <br> * We also attempt to link the first and last line of the section. <br> * <br> * For each line we successfully link, we spread up and down from <br> * this anchor point attempting to link lines. <br> * <br> * We return true if we linked any lines <br> * <br> * This routine may be called more than once on the same list of lines. <br> * In matching lines we want to find unique, *unmatched* lines: so we only <br> * insert lines into the ctree if they are currently unlinked. <br> */ <br>BOOL <br>section_match(SECTION sec1, SECTION sec2) <br>{ <br>        TREE ctleft, ctright; <br>        LINE line, line2; <br>        BOOL bLinked = FALSE; <br> <br> <br>        if ((sec1 == NULL) || (sec2 == NULL)) { <br>                return(FALSE); <br>        } <br> <br>        if ((sec1-&gt;first == NULL) || (sec2-&gt;first == NULL)) { <br>                return(FALSE); <br>        } <br>        /* ASSERT if first is non-null, so is last */ <br> <br>        /* attempt to link the first line of each file, and <br>         * if matched, expand as long as we keep matching <br>         */ <br>        bLinked |= section_expandanchor(sec1, sec1-&gt;first, sec2, sec2-&gt;first); <br> <br>        /* attempt to link the last lines of each file and <br>         * expand upwards <br>         */ <br>        bLinked |= section_expandanchor(sec1, sec1-&gt;last, sec2, sec2-&gt;last); <br> <br> <br>        /* build a tree of lines, indexed by the line hashcode. <br>         * a ctree will hold only the first value of any given key, but <br>         * it will keep track of the number of items inserted on this key. <br>         * thus we can keep count of the number of times this line <br>         * (or at least this hashcode) appears. <br>         */ <br>        ctleft = section_makectree(sec1); <br>        ctright = section_makectree(sec2); <br> <br>        /* for each unlinked line in one list (doesnt matter which), find if <br>         * appears once only in each list. if so, link, and expand <br>         * the link to link lines before and after the matching line <br>         * as long as they continue to match. <br>         */ <br>        for (line = sec1-&gt;first; line != NULL; line = List_Next(line)) { <br> <br>                if ((line_getlink(line) == NULL) &amp;&amp; <br>                   (ctree_getcount(ctleft, line_gethashcode(line)) == 1) &amp;&amp; <br>                   (ctree_getcount(ctright, line_gethashcode(line)) == 1)) { <br> <br>                        /* line appears exactly once in each list */ <br>                        line2 = * ((LINE FAR *)ctree_find(ctright, <br>                                        line_gethashcode(line))); <br>                        bLinked |= section_expandanchor(sec1, line, sec2, line2); <br>                }                <br> <br>                if (line == sec1-&gt;last) { <br>                        break; <br>                } <br>        } <br> <br>        /* delete the ctrees */ <br>        ctree_delete(ctleft); <br>        ctree_delete(ctright); <br> <br>        return(bLinked); <br>} /* section_match */ <br> <br>/*************************************************************************** <br> * Function: section_getfirstline <br> * <br> * Purpose: <br> * <br> * Gets a handle to the first line in this section <br> */ <br>LINE <br>section_getfirstline(SECTION section) <br>{ <br>        if (section == NULL) { <br>                return(NULL); <br>        } <br>        return(section-&gt;first); <br>} <br> <br>/*************************************************************************** <br> * Function: section_getlastline <br> * <br> * Purpose: <br> * <br> * Returns a handle to the last line in a section <br> */ <br>LINE <br>section_getlastline(SECTION section) <br>{ <br>        if (section == NULL) { <br>                return(NULL); <br>        } <br>        return(section-&gt;last); <br>} <br> <br>/*************************************************************************** <br> * Function: section_getlink <br> * <br> * Purpose: <br> * <br> * Returns a handle to the linked section, if any. A linked section <br> * is a section whose lines all match the lines in this section <br> */ <br>SECTION <br>section_getlink(SECTION section) <br>{ <br>        if (section == NULL) { <br>                return NULL; <br>        } <br>        return(section-&gt;link); <br>} <br> <br>/*************************************************************************** <br> * Function: section_getcorrespond <br> * <br> * Purpose: <br> * <br> * Returns a handle to the corresponding section (a section which <br> * corresponds in position to this one, but whose lines do not match). <br> */ <br>SECTION <br>section_getcorrespond(SECTION section) <br>{ <br>        if (section == NULL) { <br>                return(NULL); <br>        } <br>        return(section-&gt;correspond);     <br>} <br>/*************************************************************************** <br> * Function: section_getstate <br> * <br> * Purpose: <br> * <br> * Gets the state for this section */ <br>int <br>section_getstate(SECTION section) <br>{ <br>        if (section == NULL)  <br>                return(0); <br>        return(section-&gt;state); <br>} <br> <br>/*************************************************************************** <br> * Function: section_setstate <br> * <br> * Purpose: <br> * <br> * Sets the state for this section */ <br>void <br>section_setstate(SECTION section, int state) <br>{ <br>        section-&gt;state = state; <br>} <br> <br>/*************************************************************************** <br> * Function: section_getlinecount <br> * <br> * Purpose: <br> * <br> * Returns the number of lines in the section. Here we assume that <br> * lines in the section are number sequentially in ascending order, and we <br> * simply look at the first and last line numbers. <br> */ <br>int <br>section_getlinecount(SECTION section) <br>{ <br>        return(line_getlinenr(section-&gt;last) - <br>                        line_getlinenr(section-&gt;first)) + 1; <br>} <br> <br>/* <br> * -- base line numbers -- <br> * <br> * These functions only apply to sections in the composite list. When creating <br> * a composite section, we record the line number of the first line in each <br> * of the two sections we built it from. Thus we can calculate the <br> * line number of any line in the section in either file it appeared in, <br> * by adding the index of the line within the section to the base line <br> * number. <br> */ <br>int <br>section_getleftbasenr(SECTION section) <br>{ <br>        return(section-&gt;leftbase); <br>} <br> <br>void <br>section_setleftbasenr(SECTION section, int base) <br>{ <br>        section-&gt;leftbase = base; <br>} <br> <br>int <br>section_getrightbasenr(SECTION section) <br>{ <br>        return(section-&gt;rightbase); <br>} <br> <br>void <br>section_setrightbasenr(SECTION section, int base) <br>{ <br>        section-&gt;rightbase = base; <br>} <br> <br> <br>/* --- section list functions -------------------------------------*/ <br> <br>/* Theory of handling blank lines: <br>|    <br>|  If ignore_blanks is FALSE then a blank is just another character. <br>|  If it is TRUE then we will normally include unmatched blanks in whatever <br>|  section is surrounding them.  It would be nice if we could arrange to <br>|  never have a section that is only unmatched blanks, but (at least at <br>|  the start of the file) it can happen. <br>| <br>|  Note that there are two DIFFERENT blank handling techniques: <br>|  In the first phase of the comparison when we are just trying to match up <br>|  lines, we skip over blank lines both forwards and backwards from an anchor. <br>|  When we are making real sections for display we only go forwards. <br>|  This results in a possible anomaly at the top of the whole file where <br>|  there could be some blanks which do not match and which can only possibly <br>|  be described as the start of a section. <br>|  For this reason, we label the sections with their state as early as possible <br>|  and go by that rather than by the presence or absence of link fields. <br>|  (It takes some scanning to find a link.  The first line in the section <br>|  could be a blank). <br>*/ <br> <br>/*************************************************************************** <br> * Function: FindEndOfUnmatched <br> * <br> * Purpose: <br> * <br> * Returns a LINE which is the last line in an unmatched section <br> * containing (probably starting with) Line. <br> * Note that it does not necessarily make progress. <br> * <br> * As noted above, even if blank lines are being ignored, we don't <br> * mind tagging them onto the end of an already unmatching section. <br> * This means we carry on until we find the first real link <br> */ <br>LINE FindEndOfUnmatched(LINE line) <br>{ <br>        LINE next; <br> <br>        for (; ; ) <br>        {       next = List_Next(line); <br>                if (next==NULL) return line; <br>                if (line_getlink(next)!=NULL) return line; <br>                line = next; <br>        } <br>} /* FindEndOfUnmatched */ <br> <br> <br>/*************************************************************************** <br> * Function: NextNonIgnorable <br> * <br> * Purpose: <br> * <br> * An ignorable line is a blank line with no link and ignore_blanks set <br> * <br> * Given that line is initially not NULL and not ignorable: <br> * If line is the last line in the list then return NULL <br> * Else If ignore_blanks is FALSE then return the next line after line <br> * else return next line which has a link or which is non-blank. <br> * If there is no such line then return the last line in the list. <br> * <br> * Note that this does always make progress (at the cost of <br> * sometimes returning NULL). <br> */ <br>LINE NextNonIgnorable(LINE line) <br>{       LINE next; <br> <br>        next = List_Next(line); <br>        if (next==NULL) return NULL; <br>        for (; ; ) { <br>                line = next; <br>                if (  line_getlink(line)!=NULL) return line; <br>                if (! ignore_blanks)            return line; <br>                if (! line_isblank(line))       return line; <br>                next = List_Next(line); <br>                if (next==NULL) return line; <br>        } <br>} /* NextNonIgnorable */ <br> <br> <br>/*************************************************************************** <br> * Function: FindEndOfMatched <br> * <br> * Purpose: <br> * <br> * Given that line is either linked or an ignorable blank: <br> * Return a LINE which is the last line in a matched section <br> * containing (probably starting with) line. <br> * This could mean returning the line we were given. <br> * <br> * If the lines linked to are not consecutive then the section ends. <br> * If blanks are being ignored, then any blank line is deemed <br> * to match (even if it doesn't match).  In this case we need the <br> * links of the lines before and after the blanks to be consecutive <br> * in order to carry on.  There could be blank lines on either or both <br> * ends of the links. <br> */ <br>LINE FindEndOfMatched(LINE line) <br>{ <br>        LINE next;              /* next non-ignored or linked line */ <br>        LINE nextlink;          /* next in other file */ <br> <br>        /* The basic algorithm is to set up next and nextlink to point to <br>           candidate lines.  Examine them.  If they are good then step <br>           on to them, else return the line one before. <br>           There are confusion factors associated with the beginning and <br>           end of the file. <br>        */ <br> <br>        /* ASSERT( line is either an ignorable blank or else is linked) */ <br> <br>        /* As a section (at least at the start of the file) might start <br>           with an ignored non-linked blank line, first step over any such <br>        */ <br>        if( line_getlink(line)==NULL &amp;&amp; line_isblank(line) ) { <br>                next = NextNonIgnorable(line); <br> <br>                /* There are unfortunately 6 cases to deal with <br>                   * marks where next will be. * against eof means next==NULL <br>                   blank(s) refer to ignorable unlinked blanks. <br>                          A         B        C        D        E        F <br>                   line-&gt; xxxxx     xxxxx    xxxxx    xxxxx    xxxxx    xxxxx <br>                         *unlinked  blanks  *linked   blanks  *eof     *blanks <br>                                   *unlinked         *linked            eof <br> <br>                   next could be: <br>                 <br>                      null - case E =&gt; return line <br>                      unlinked ignorable blank - case F =&gt; return that blank line <br>                      unlinked other - cases A,B return prev(that unlinked line) <br>                      linked - cases C,D continue from that linked line <br>                */ <br>                if (next==NULL) return line; <br>                if (line_getlink(next)==NULL) { <br>                        if (ignore_blanks &amp;&amp; line_isblank(next)) { <br>                                return next; <br>                        } <br>                        return List_Prev(next); <br>                } <br> <br>                line = next; <br>        } <br> <br>        /* we have stepped over inital blanks and now do have a link */ <br> <br>        for ( ; ; ) { <br> <br>                next = NextNonIgnorable(line); <br>                /* Same 6 cases - basically same again */ <br>                if (next==NULL) return line; <br>                if (line_getlink(next)==NULL) { <br>                        if (ignore_blanks &amp;&amp; line_isblank(next)) { <br>                                return next; <br>                        } <br>                        return List_Prev(next); <br>                } <br> <br>                nextlink = NextNonIgnorable(line_getlink(line)); <br> <br>                /* WEAK LOOP INVARIANT <br>                   line is linked. <br>                   next is the next non-ignorable line in this list after line. <br>                   nextlink is the next non-ignorable line after link(line) <br>                                        in the other list (could be NULL etc). <br>                */ <br>                if (line_getlink(next) != nextlink) return List_Prev(next); <br> <br>                line = next; <br>        } <br>        return line; <br>} /* FindEndOfMatched */ <br> <br> <br>/*************************************************************************** <br> * Function: section_makelist <br> * <br> * Purpose: <br> * <br> * Make a list of sections by traversing a list of lines. Consecutive <br> * linked lines that are linked to consecutive lines are put in a single <br> * section. Blocks of unlinked lines are placed in a section. <br> * If ignore_blanks is set then we first try to link them as normal. <br> * but if they won't link then we just skip over them and keep them <br> * in the same section. <br> * <br> * Left must be set TRUE iff the list of lines is a left hand section. <br> * Returns a handle to a list of sections <br> */ <br>LIST <br>section_makelist(LIST linelist, BOOL left) <br>{ <br>        LINE line1, line2; <br>        LIST sections; <br>        BOOL matched; <br>        SECTION sect; <br> <br>        /* make an empty list of sections */ <br>        sections = List_Create(); <br> <br>        /* for each line in the list */ <br> <br>        List_TRAVERSE(linelist, line1) { <br> <br>                /* is it linked ? */ <br> <br>                if( line_getlink(line1) != NULL <br>                  || ( ignore_blanks &amp;&amp; line_isblank(line1)) <br>                  ) { <br>                        line2 = FindEndOfMatched(line1); <br>                        matched = TRUE; <br>                } else { <br>                        line2 = FindEndOfUnmatched(line1); <br>                        matched = FALSE; <br>                } <br> <br>                /* create the section and add to list */ <br>                sect = section_new(line1, line2, sections); <br>                sect-&gt;state = (matched ? STATE_SAME <br>                                       : left ? STATE_LEFTONLY <br>                                              : STATE_RIGHTONLY <br>                              ); <br> <br>                /* advance to end of section (no-op if 1 line section) */ <br>                line1 = line2; <br>        } <br> <br>        return(sections); <br>} /* section_makelist */ <br> <br> <br> <br>/*************************************************************************** <br> * Function: section_deletelist <br> * <br> * Purpose: <br> * <br> * Delete a list of sections <br> * <br> * Sections have no dangling pointers, so all we do is delete the list <br> */ <br>void     <br>section_deletelist(LIST sections) <br>{ <br>        List_Destroy(&amp;sections); <br>} <br> <br>/*************************************************************************** <br> * Function: FindFirstWithLink <br> * <br> * Purpose: <br> * <br> * Return the first line in the range first..last <br> * which has a link.  Return last if none of them have a link. <br> * List_Next must lead from first to last eventually. <br> * It is legit for last to be NULL. <br> */ <br>LINE FindFirstWithLink(LINE first, LINE last) <br>{        <br>        /* The strategy of including blanks on the ENDS of sections rather <br>           than the start of new sections will mean that this function <br>           usually strikes gold immediately.  A file with a leading <br>           blank section is its raison d'etre. <br>        */ <br>        while (line_getlink(first)==NULL &amp;&amp; first!=last) <br>                first = List_Next(first); <br> <br>        if (line_getlink(first)==NULL) { <br>        } <br>        return first; <br>} /* FindFirstWithLink */ <br> <br> <br>/*************************************************************************** <br> * Function: section_matchlists <br> * <br> * Purpose: <br> * <br> * Match up two lists of sections. Establish links between sections <br> * that match, and establish 'correspondence' between sections that <br> * are in the same place, but don't match. <br> * <br> * For each pair of corresponding sections, we also call section_match <br> * to try and link up more lines. <br> * <br> * We return TRUE if we made any more links between lines, or false <br> * otherwise. <br> * <br> */ <br>BOOL <br>section_matchlists(LIST secsleft, LIST secsright) <br>{ <br>        BOOL bLinked = FALSE; <br>        SECTION sec1, sec2; <br> <br>        /* match up linked sections - We know whether a section is <br>           supposed to link from its state, but we don't know what section <br>           it links to.  Also we can have sections which are defined to <br>           be matching but actually contain nothing but ignorable <br>           blank lines <br>        */ <br>         <br>        /*  for each linked section try to find the section  linked to it. */ <br>        List_TRAVERSE(secsleft, sec1) { <br>                if (sec1-&gt;state==STATE_SAME) { <br>                        LINE FirstWithLink = FindFirstWithLink(sec1-&gt;first, sec1-&gt;last); <br>                        List_TRAVERSE(secsright, sec2) { <br>                                if ( sec2-&gt;state==STATE_SAME <br>                                   &amp;&amp; line_getlink(FirstWithLink) <br>                                        == FindFirstWithLink(sec2-&gt;first, sec2-&gt;last)) { <br>                                            break; <br>                                } <br>                        } <br>                        /* sec2 could be NULL if sec1 is all allowable blanks */ <br>                        if (sec2!=NULL) { <br>                                sec1-&gt;link = sec2; <br>                                sec2-&gt;link = sec1; <br>                        } <br>                } <br>        } <br> <br>        /* go through all unmatched sections. Note that we need to complete <br>         * the link-up of matching sections before this, since we need <br>         * all the links in place for this to work. <br>         */ <br> <br>        List_TRAVERSE(secsleft, sec1) { <br>                SECTION secTemp; <br> <br>                if (sec1-&gt;state == STATE_SAME) { <br>                        /* skip the linked sections */ <br>                        continue; <br>                } <br> <br>                /* check that the previous and next sections, if <br>                 * they exist, are linked. this should not fail since <br>                 * two consecutive unlinked sections should be made into <br>                 * one section <br>                 */ <br>                secTemp = List_Prev(sec1); <br>                if (secTemp &amp;&amp; secTemp-&gt;state!= STATE_SAME) { <br>                        continue; <br>                } <br>                secTemp = List_Next(sec1); <br>                if (secTemp &amp;&amp; secTemp-&gt;state!= STATE_SAME) { <br>                        continue; <br>                } <br> <br>                /* find the section that corresponds to this - that is, the <br>                 * section following the section linked to our previous section. <br>                 * we could be at beginning or end of list. <br>                 */ <br>                if (List_Prev(sec1) != NULL) { <br>                        SECTION secOther; <br>                        secOther = section_getlink(List_Prev(sec1)); <br>                        if (secOther==NULL) <br>                                continue; <br> <br>                        sec2 = List_Next(secOther); <br> <br>                        /* check this section is not linked */ <br>                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) { <br>                                continue; <br>                        } <br>                         <br>                        /* check that the section after these are linked <br>                         * to each other (or both are at end of list). <br>                         */ <br>                        if (List_Next(sec1) != NULL) { <br> <br>                                if (section_getlink(List_Next(sec1)) != <br>                                    List_Next(sec2)) { <br>                                        continue; <br>                                } <br>                        } else { <br>                                if (List_Next(sec2) == NULL) { <br>                                        continue; <br>                                } <br>                        } <br> <br>                } else if (List_Next(sec1) != NULL) { <br>                        SECTION secOther; <br>                        secOther = section_getlink(List_Next(sec1)); <br>                        if (secOther==NULL) <br>                                continue; <br> <br>                        sec2 = List_Prev(secOther); <br> <br>                        /* check this section is not linked */ <br>                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) { <br>                                continue; <br>                        } <br>                         <br>                        /* check that the section before these are linked <br>                         * to each other (or both are at start of list). <br>                         */ <br>                        if (List_Prev(sec1) != NULL) { <br> <br>                                if (section_getlink(List_Prev(sec1)) != <br>                                    List_Prev(sec2)) { <br>                                        continue; <br>                                } <br>                        } else { <br>                                if (List_Prev(sec2) == NULL) { <br>                                        continue; <br>                                } <br>                        } <br>                } else { <br>                        /* there must be at most one section in each <br>                         * file, and they are unmatched. make these correspond. <br>                         */ <br>                        sec2 = List_First(secsright); <br>                } <br> <br> <br>                /* make the correspondence links <br>                 */ <br>                if ((sec1 != NULL) &amp;&amp; (sec2 != NULL)) { <br>                        sec1-&gt;correspond = sec2; <br>                        sec2-&gt;correspond = sec1; <br>                } <br> <br>                /* attempt to link up lines */ <br>                if (section_match(sec1, sec2)) { <br>                        bLinked = TRUE; <br>                } <br>        } <br> <br>        return(bLinked); <br>} /* section_matchlists */ <br> <br>/*************************************************************************** <br> * Function: section_takesection <br> * <br> * Purpose: <br> * <br> * Add a section to the composite list. Called from make_composites <br> * to copy a section, add it to the composite list and set the state, <br> * leftbase and rightbase.   Note that the state could be STATE_SAME <br> * with a NULL section on the left.  May NOT call with STATE_SAME and <br> * a NULL right section! <br> * <br> */ <br>void <br>section_takesection(LIST compo, SECTION left, SECTION right, int state) <br>{ <br>        SECTION newsec; <br>        SECTION sec; <br> <br>        /* select which section is being output, and change the state <br>         * to indicate it has been output <br>         */ <br>        switch(state) { <br>        case STATE_SAME: <br>                /* both the same. we mark both as output, and <br>                 * take the right one.  It is possible that the <br>                 * left one could be NULL (an ignorable blank section) </code></pre>
<p>
</p>
<pre><code>*/ <br>                if (left!=NULL) left-&gt;state = STATE_MARKED; <br>                right-&gt;state = STATE_MARKED; <br>                sec = right; <br>                break; <br> <br>        case STATE_LEFTONLY: <br>        case STATE_MOVEDLEFT: <br>                sec = left; <br>                left-&gt;state = STATE_MARKED; <br>                break; <br> <br>        case STATE_RIGHTONLY: <br>        case STATE_MOVEDRIGHT: <br>                sec = right; <br>                right-&gt;state = STATE_MARKED; <br>                break; <br>        } <br> <br> <br>        /* create a new section on the list */ <br>        newsec = section_new(sec-&gt;first, sec-&gt;last, compo); <br> <br>        newsec-&gt;state = state; <br> <br> <br>        if (left != NULL) { <br>                newsec-&gt;leftbase = line_getlinenr(left-&gt;first); <br>        } else { <br>                newsec-&gt;leftbase = 0; <br>        } <br> <br>        if (right != NULL) { <br>                newsec-&gt;rightbase = line_getlinenr(right-&gt;first); <br>        } else { <br>                newsec-&gt;rightbase = 0; <br>        } <br> <br>} /* section_takesection */ <br> <br>/*************************************************************************** <br> * Function: section_makecomposite <br> * <br> * Purpose: <br> * <br> * Make a composite list of sections by traversing a list of sections. <br> * <br> * Return a handle to a list of sections. <br> * <br> * During this, set state, leftbase and rightbase for sections. <br> * <br> * Comments: <br> * <br> * This function creates a list that corresponds to the 'best' view <br> * of the differences between the two lists. We place sections from the <br> * two lists into one composite list. Sections that match each other are only <br> * inserted once (from the right list). Sections that match, but in different <br> * positions in the two lists are inserted twice, once in each position, with <br> * status to indicate this. Unmatched sections are inserted in the correct <br> * position. <br> * <br> * - Take sections from the left list until the section is linked to one not <br> *   already taken. <br> * - Then take sections from right until we find a section linked to one not <br> *   already taken. <br> * - If the two sections waiting are linked to each other, take them both <br> *   (once- we take the right one and advance past both). <br> * <br> * - Now we have to decide which to take in place and which to declare <br> *   'moved'. Consider the case where the only change is that the first line <br> *   has been moved to the end. We should take the first line (as a move), <br> *   then the bulk of the file (SAME) then the last line (as a move). Hence, <br> *   in difficult cases, we take the smaller section first, to ensure that <br> *   the larger section is taken as SAME. <br> * <br> *   To indicate which section has been output, we set the state field <br> *   to STATE_MARKED once we have taken it.   States in left and right <br> *   lists are of no further interest once we have built the composite. <br> * <br> *   Up to this point we have worked off the STATE of a section.  By now <br> *   all the section links are in place, so we can use them too. <br> */ <br>LIST <br>section_makecomposite(LIST secsleft, LIST secsright) <br>{ <br>        SECTION left, right; <br>        LIST compo; <br> <br>        /* make an empty list for the composite */ <br>        compo = List_Create(); <br> <br>        left = List_First(secsleft); <br>        right = List_First(secsright); <br> <br>        while ( (left != NULL) || (right != NULL)) { <br> <br>                if (left == NULL) { <br>                        /* no more in left list - take right section */ <br>                        /* is it moved or just unmatched ? */ <br>                        if (right-&gt;link == NULL) { <br>                                section_takesection(compo, NULL, right, STATE_RIGHTONLY); <br>                                right = List_Next(right); <br>                        } else { <br>                                section_takesection(compo, right-&gt;link, right, STATE_MOVEDRIGHT); <br>                                right = List_Next(right); <br>                        } <br>                } else if (right == NULL) { <br>                        /* right list empty - must be left next */ <br> <br>                        /* is it moved or just unmatched ? */ <br>                        if (left-&gt;link == NULL) { <br>                                section_takesection(compo, left, NULL, STATE_LEFTONLY); <br>                                left = List_Next(left); <br>                        } else { <br>                                section_takesection(compo, left, left-&gt;link, STATE_MOVEDLEFT); <br>                                left = List_Next(left); <br>                        } <br> <br>                } else if (left-&gt;state == STATE_LEFTONLY) { <br>                        /* unlinked section on left */ <br>                        section_takesection(compo, left, NULL, STATE_LEFTONLY); <br>                        left = List_Next(left); <br> <br>                } else if (left-&gt;link==NULL) { <br>                        /* This is an ignorable blank section on the left. <br>                         * We ignore it. (We will take any such from the right) <br>                         */ <br>                        left = List_Next(left); <br> <br>                } else if (left-&gt;link-&gt;state==STATE_MARKED) { <br>                        /* left is linked to section that is already taken*/ <br>                        section_takesection(compo, left, left-&gt;link, STATE_MOVEDLEFT); <br>                        left = List_Next(left); <br> <br>                } else  if (right-&gt;link == NULL) { <br>                        /* take unlinked section on right <br>                         * Either unmatched or ignorable blanks <br>                         */ <br>                        section_takesection(compo, NULL, right, right-&gt;state); <br>                        right = List_Next(right); <br>                 <br>                } else if (right-&gt;link-&gt;state==STATE_MARKED) { <br>                        /* right is linked to section that's already taken */ <br>                        section_takesection(compo, right-&gt;link, right, STATE_MOVEDRIGHT); <br>                        right = List_Next(right); <br>                 <br>                } else if (left-&gt;link == right) { <br>                        /* sections match */ <br>                        section_takesection(compo, left, right, STATE_SAME); <br>                        right = List_Next(right); <br>                        left = List_Next(left); <br>                } else { <br>                        /* both sections linked to forward sections <br>                         * decide first based on size of sections <br>                         * - smallest first as a move so that largest <br>                         * is an unchanged. <br>                         */ <br>                        if (section_getlinecount(right) &gt; section_getlinecount(left)) { <br>                                section_takesection(compo, left, left-&gt;link, STATE_MOVEDLEFT); <br>                                left = List_Next(left); <br>                        } else { <br>                                section_takesection(compo, right-&gt;link, right, STATE_MOVEDRIGHT); <br>                                right = List_Next(right); <br>                        } <br>                } <br>        } <br> <br>        return(compo); <br>} /* section_makecomposite */ <br> <br>typedef LINE (APIENTRY * MOVEPROC)(LINE); <br> <br>/*************************************************************************** <br> * Function: AbsorbAnyBlanks <br> * <br> * Purpose: <br> * <br> * Update PLINE by making it point to the first non-blank <br> * at-or-after from but not after limit. <br> * If they are all blank then make it point to limit <br> * If from is non-blank then leave it alone. <br> * Return TRUE iff PLINE was updated. <br> * It is legit for limit to be NULL (meaning end of file). <br> */ <br>BOOL AbsorbAnyBlanks(LINE * from, LINE limit, MOVEPROC Move) <br>{       BOOL progress = FALSE; <br> <br>        while ( (from!=NULL) <br>              &amp;&amp; (line_isblank(*from)) <br>              &amp;&amp; (*from!=limit) <br>              ) { <br>                *from = Move(*from); <br>                progress = TRUE; <br>        } <br>        return progress; <br>} /* AbsorbAnyBlanks */ <br> <br> <br>/*************************************************************************** <br> * Function: section_expandanchor <br> * <br> * Purpose: <br> * <br> * Given an anchor point (two lines that we think should match), <br> * try to link them, and the lines above and below them for as long <br> * as the lines can be linked (are the same, are unlinked). <br> * <br> * Return TRUE if we make any links. <br> * <br> */ <br>BOOL <br>section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2) <br>{ <br>        /* when a line is matched we set bChanges.  If we notice some <br>         * blank lines, but do NOT link any new non-blank lines, we <br>         * do NOT set bChanges.  (If we did it would cause a closed <br>         * loop as they would get noticed again next time.  line_link <br>         * only returns TRUE if it is a NEW link). <br>         * At this stage we are only interested in making links, not in <br>         * the size of the section that results (that fun comes later). <br>         * therefore trailing blanks at the end of a section are not <br>         * interesting and we don't look for them. <br>         */ <br>        BOOL bChanges = FALSE; <br>        LINE left, right; <br> <br>        /* We handle the section limits by using a sentinel which is one <br>         * past the end of the section.  (If the section ends at the end <br>         * of the list then the sentinel is NULL). <br>         */ <br>        LINE leftend, rightend; <br>        leftend = List_Next(sec1-&gt;last); <br>        rightend = List_Next(sec2-&gt;last); <br> <br>        /* null lines shall not match */ <br>        if ((line1 == NULL) || (line2 == NULL)) { <br>                return(FALSE); <br>        } <br> <br>        /* check all lines forward until fail to link (because null, <br>         * not matching, or already linked). <br>         * include the passed in anchor point since this has not <br>         * yet been linked. <br>         * If blanks are ignorable then skip over any number of whole <br>         * blank lines. <br>         */ <br>        left = line1; <br>        right = line2; <br>        for (; ; ) { <br>                if (line_link(left, right) ) { <br> <br>                        bChanges = TRUE; <br>                        left = List_Next(left); <br>                        right = List_Next(right); <br>                        if (left==leftend || right==rightend) break; <br>                } <br>                else if (ignore_blanks){ <br>                        /* even though no match, maybe an ignorable blank? */ <br> <br>                        BOOL moved = FALSE; <br>                        moved |= AbsorbAnyBlanks(&amp;left, leftend, (MOVEPROC)List_Next); <br>                        moved |= AbsorbAnyBlanks(&amp;right, rightend, (MOVEPROC)List_Next); <br>                        if (!moved) break; /* it didn't match and we didn't move on */ <br>                        if (left==leftend || right==rightend) break; <br>                } <br>                else break; <br>        } <br> <br>        /* check all matches going backwards from anchor point <br>           but only if it was a real anchor  (could have been <br>           end-of-section/end-of-file and non-matching). <br>        */ <br>        if (line_getlink(line1)==NULL) return bChanges; <br> <br>        left = List_Prev(line1); <br>        right = List_Prev(line2); <br>        if (left==NULL || right==NULL) return bChanges; <br> <br>        leftend = List_Prev(sec1-&gt;first); <br>        rightend = List_Prev(sec2-&gt;first); <br> <br>        for (; ; ) { <br>                if (line_link(left, right)) { <br> <br>                        bChanges = TRUE; <br>                        left = List_Prev(left); <br>                        right = List_Prev(right); <br>                        if (left == leftend || right == rightend) break; <br> <br>                } <br>                else if (ignore_blanks){ <br>                        /* even though no match, maybe an ignorable blank? */ <br> <br>                        BOOL moved = FALSE; <br>                        moved |= AbsorbAnyBlanks(&amp;left, leftend, (MOVEPROC)List_Prev); <br>                        moved |= AbsorbAnyBlanks(&amp;right, rightend, (MOVEPROC)List_Prev); <br>                        if (!moved) break; /* it didn't match and we didn't move on */ <br>                        if (left==leftend || right==rightend) break; <br> <br>                } <br>                else break; <br>        } <br> <br>        return(bChanges); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: section_makectree <br> * <br> * Purpose: <br> * <br> * Build a ctree from the lines in the section given <br> * <br> * Remember that we are only interested in the lines that are <br> * not already linked. <br> * <br> * The value we store in the tree is the handle of the line. the key <br> * is the line hash code <br> */ <br>TREE <br>section_makectree(SECTION sec) <br>{ <br>        TREE tree; <br>        LINE line; <br> <br>        /* make an empty tree */ <br>        tree = ctree_create(hHeap); <br> <br>        for (line = sec-&gt;first; line != NULL; line = List_Next(line)) { <br>                if (line_getlink(line) == NULL) { <br>                        ctree_update(tree, line_gethashcode(line), <br>                                        &amp;line, sizeof(LINE)); <br>                } <br>                if (line == sec-&gt;last) { <br>                        break; <br>                } <br>        } <br>        return(tree); <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
