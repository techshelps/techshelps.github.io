<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TPRINT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5563"></a>TPRINT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: TPRINT.C <br>* <br>* Print functions. <br>* <br>* Functions: <br>* <br>* gtab_print() <br>* gtab_printsetup() <br>* gtab_prtwidths() <br>* gtab_printjob() <br>* AbortProc() <br>* AbortDlg() <br>* gtab_printpage() <br>* gtab_setrects() <br>* gtab_printhead() <br>* <br>* Comments: <br>* <br>* See table.h for interface description. <br>* <br>****************************************************************************/ <br> <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "gutils.h" <br>#include "gutilsrc.h" <br>#include "table.h" <br>#include "tpriv.h" <br> <br>/* in tpaint.c, calls GetTextExtentPoint */ <br>extern int GetTextExtent(HDC, LPSTR, int); <br> <br>extern HANDLE hLibInst; <br> <br>/* function prototypes */ <br>lpTable gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap, <br>        lpPrintContext pcontext); <br>BOOL gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext <br>        pcontext); <br>void gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext); <br>int APIENTRY AbortProc(HDC hpr, int code); <br>int APIENTRY AbortDlg(HWND hdlg, UINT msg, UINT wParam, LONG lParam); <br>BOOL gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page); <br>void gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter); <br>void gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page); <br> <br> <br>/*************************************************************************** <br> * Function: gtab_print <br> * <br> * Purpose: <br> * <br> * Prints a table. <br> */ <br>void <br>gtab_print(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext) <br>{ <br>        BOOL fNoContext, fNoMargin, fNoPD; <br>        lpTable ptab_prt; <br> <br>        fNoContext = FALSE; <br>        fNoPD = FALSE; <br>        fNoMargin = FALSE; <br> <br>        if (pcontext == NULL) { <br>                fNoContext = TRUE; <br>                pcontext = (lpPrintContext) gmem_get(heap, <br>                        sizeof(PrintContext)); <br>                pcontext-&gt;head = pcontext-&gt;foot = NULL; <br>                pcontext-&gt;margin = NULL; <br>                pcontext-&gt;pd = NULL; <br>                pcontext-&gt;id = 0; <br>        } <br>        if (pcontext-&gt;pd == NULL) { <br>                fNoPD = TRUE; <br>        } <br>        if (pcontext-&gt;margin == NULL) { <br>                fNoMargin = TRUE; <br>        } <br>        ptab_prt = gtab_printsetup(hwnd, ptab, heap, pcontext); <br> <br>        if (ptab_prt != NULL) { <br>                gtab_printjob(hwnd, ptab_prt, pcontext); <br> <br>                gtab_deltable(hwnd, ptab_prt); <br>        } <br>        if (fNoMargin) { <br>                gmem_free(heap, (LPSTR)pcontext-&gt;margin, <br>                        sizeof(Margin)); <br>                pcontext-&gt;margin = NULL; <br>        } <br>        if (fNoPD) { <br>                if (pcontext-&gt;pd-&gt;hDevMode != NULL) { <br>                        GlobalFree(pcontext-&gt;pd-&gt;hDevMode); <br>                } <br>                if (pcontext-&gt;pd-&gt;hDevNames != NULL) { <br>                        GlobalFree(pcontext-&gt;pd-&gt;hDevNames); <br>                } <br>                gmem_free(heap, (LPSTR) pcontext-&gt;pd, sizeof(PRINTDLG)); <br>                pcontext-&gt;pd = NULL; <br>        } <br>        if (fNoContext) { <br>                gmem_free(heap, (LPSTR) pcontext, sizeof(PrintContext)); <br>        } <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: gtab_printsetup <br> * <br> * Purpose: <br> * <br> * Sets up printercontext - builds lpTable for printer, incl. sizing <br> * and initialises pcontext fields that may be null. <br> */ <br>lpTable <br>gtab_printsetup(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext) <br>{ <br>        lpTable pprttab; <br>        PRINTDLG FAR * pd; <br>        int ncols, i; <br>        ColPropsList cplist; <br> <br>        /* set fields for context that user left null */ <br>        if (pcontext-&gt;margin == NULL) { <br>                pcontext-&gt;margin = (lpMargin) gmem_get(heap, sizeof(Margin)); <br>                if (pcontext-&gt;margin == NULL) { <br>                        return(NULL); <br>                } <br>                pcontext-&gt;margin-&gt;left = 10; <br>                pcontext-&gt;margin-&gt;right = 10; <br>                pcontext-&gt;margin-&gt;top = 15; <br>                pcontext-&gt;margin-&gt;bottom = 15; <br>                pcontext-&gt;margin-&gt;topinner = 15; <br>                pcontext-&gt;margin-&gt;bottominner = 15; <br>        } <br> <br>        if (pcontext-&gt;pd == NULL) { <br>                pd = (PRINTDLG FAR *) gmem_get(heap, sizeof(PRINTDLG)); <br>                if (pd == NULL) { <br>                        return(NULL); <br>                } <br>                pcontext-&gt;pd = pd; <br> <br>                pd-&gt;lStructSize = sizeof(PRINTDLG); <br>                pd-&gt;hwndOwner = hwnd; <br>                pd-&gt;hDevMode = (HANDLE) NULL; <br>                pd-&gt;hDevNames = (HANDLE) NULL; <br>                pd-&gt;Flags = PD_RETURNDC|PD_RETURNDEFAULT; <br> <br>                if (PrintDlg(pd) == FALSE) { <br>                        return(NULL); <br>                } <br>        } <br> <br>        /* now create a Table struct by querying the owner */ <br>        pprttab = (lpTable) gmem_get(heap, sizeof(Table)); <br> <br>        if (pprttab == NULL) { <br>                return(NULL); <br>        } <br>        pprttab-&gt;hdr = ptab-&gt;hdr; <br> <br>        /* get the row/column count from owner window */ <br>        if (pcontext-&gt;id == 0) { <br>                pprttab-&gt;hdr.id = ptab-&gt;hdr.id; <br>        } else { <br>                pprttab-&gt;hdr.id = pcontext-&gt;id; <br>        } <br>        pprttab-&gt;hdr.props.valid = 0; <br>        pprttab-&gt;hdr.sendscroll = FALSE; <br>        if (gtab_sendtq(hwnd, TQ_GETSIZE, (long) (LPSTR)&amp;pprttab-&gt;hdr) == FALSE) { <br>                return(NULL); <br>        } <br> <br>        /* alloc and init the col data structs */ <br>        ncols = pprttab-&gt;hdr.ncols; <br>        pprttab-&gt;pcolhdr = (lpColProps) gmem_get(heap, sizeof(ColProps) * ncols); <br>        if (pprttab-&gt;pcolhdr == NULL) { <br>                gmem_free(heap, (LPSTR)pprttab, sizeof(Table)); <br>                return(NULL); <br>        } <br> <br>        /* init col properties to default */ <br>        for (i=0; i &lt; ncols; i++) { <br>                pprttab-&gt;pcolhdr[i].props.valid = 0; <br>                pprttab-&gt;pcolhdr[i].nchars = 0; <br>        } <br>        /* get the column props from owner */ <br>        cplist.plist = pprttab-&gt;pcolhdr; <br>        cplist.id = pprttab-&gt;hdr.id; <br>        cplist.startcol = 0; <br>        cplist.ncols = ncols; <br>        gtab_sendtq(hwnd, TQ_GETCOLPROPS, (long) (LPSTR)&amp;cplist); <br> <br> <br>        pprttab-&gt;scrollscale = 1; <br>        pprttab-&gt;pcellpos = (lpCellPos) gmem_get(heap, <br>                sizeof(CellPos) * ptab-&gt;hdr.ncols); <br>        if (pprttab-&gt;pcellpos == NULL) { <br>                gmem_free(heap, (LPSTR) pprttab-&gt;pcolhdr, sizeof(ColProps) * ncols); <br>                gmem_free(heap, (LPSTR)pprttab, sizeof(Table)); <br>                return(NULL); <br>        } <br>                 <br> <br>        pprttab-&gt;pdata = NULL; <br>        pprttab-&gt;nlines = 0; <br> <br>        if (!gtab_prtwidths(hwnd, pprttab, heap, pcontext)) { <br>                gmem_free(heap, (LPSTR)pprttab-&gt;pcellpos, <br>                        sizeof(CellPos) * ptab-&gt;hdr.ncols); <br>                gmem_free(heap, (LPSTR)pprttab, sizeof(Table)); <br>                return(NULL); <br>        } <br>        return(pprttab); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_prtwidths <br> * <br> * Purpose: <br> * <br> * Calc the height/width settings and alloc line data  <br> */ <br>BOOL <br>gtab_prtwidths(HWND hwnd, lpTable ptab, HANDLE heap, lpPrintContext pcontext) <br>{ <br>        TEXTMETRIC tm; <br>        int cx, cxtotal, i, curx, cury; <br>        lpProps hdrprops, cellprops; <br>        lpCellPos xpos, ypos; <br>        RECT rcinner, rcouter; <br> <br>        hdrprops = &amp;ptab-&gt;hdr.props; <br>        GetTextMetrics(pcontext-&gt;pd-&gt;hDC, &amp;tm); <br>        ptab-&gt;avewidth = tm.tmAveCharWidth; <br>        ptab-&gt;rowheight = tm.tmHeight + tm.tmExternalLeading; <br>        if (hdrprops-&gt;valid &amp; P_HEIGHT) { <br>                ptab-&gt;rowheight = hdrprops-&gt;height; <br>        } <br> <br>        /* set sizes for headers */ <br>        gtab_setrects(pcontext, &amp;rcinner, &amp;rcouter); <br> <br>        /* set width/pos for each col. */ <br>        cxtotal = 0; <br>        curx = rcinner.left; <br>        for (i = 0; i &lt; ptab-&gt;hdr.ncols; i++) { <br>                cellprops = &amp;ptab-&gt;pcolhdr[i].props; <br>                xpos = &amp;ptab-&gt;pcellpos[i]; <br> <br>                if (cellprops-&gt;valid &amp; P_WIDTH) { <br>                        cx = cellprops-&gt;width; <br>                } else if (hdrprops-&gt;valid &amp; P_WIDTH) { <br>                        cx = hdrprops-&gt;width; <br>                } else { <br>                        cx = ptab-&gt;pcolhdr[i].nchars + 1; <br>                        cx *= ptab-&gt;avewidth; <br>                } <br>                /* add 2 for intercol spacing */ <br>                cx += 2; <br> <br>                xpos-&gt;size = cx; <br>                xpos-&gt;start = curx + 1; <br>                xpos-&gt;clipstart = xpos-&gt;start; <br>                xpos-&gt;clipend = xpos-&gt;start + xpos-&gt;size - 2; <br>                xpos-&gt;clipend = min(xpos-&gt;clipend, rcinner.right); <br> <br>                cxtotal += xpos-&gt;size; <br>                curx += xpos-&gt;size; <br>        } <br>        ptab-&gt;rowwidth = cxtotal; <br> <br>        if(pcontext-&gt;head != NULL) { <br>                xpos = &amp;pcontext-&gt;head-&gt;xpos; <br>                ypos = &amp;pcontext-&gt;head-&gt;ypos; <br> <br>                xpos-&gt;start = rcouter.left + 1; <br>                xpos-&gt;clipstart = rcouter.left + 1; <br>                xpos-&gt;clipend = rcouter.right - 1; <br>                xpos-&gt;size = rcouter.right - rcouter.left; <br> <br>                ypos-&gt;start = rcouter.top; <br>                ypos-&gt;clipstart = rcouter.top; <br>                ypos-&gt;clipend = rcinner.top; <br>                ypos-&gt;size = ptab-&gt;rowheight; <br>        } <br> <br>        if (pcontext-&gt;foot != NULL) { <br>                xpos = &amp;pcontext-&gt;foot-&gt;xpos; <br>                ypos = &amp;pcontext-&gt;foot-&gt;ypos; <br> <br>                xpos-&gt;start = rcouter.left + 1; <br>                xpos-&gt;clipstart = rcouter.left + 1; <br>                xpos-&gt;clipend = rcouter.right - 1; <br>                xpos-&gt;size = rcouter.right - rcouter.left; <br> <br>                ypos-&gt;start = rcouter.bottom - ptab-&gt;rowheight; <br>                ypos-&gt;clipstart = rcinner.bottom; <br>                ypos-&gt;clipend = rcouter.bottom; <br>                ypos-&gt;size = ptab-&gt;rowheight; <br>        } <br> <br>        /* set nr of lines per page */ <br>        ptab-&gt;nlines = (rcinner.bottom - rcinner.top) / ptab-&gt;rowheight; <br>        if (!gtab_alloclinedata(hwnd, heap, ptab)) { <br>                return(FALSE); <br>        } <br>        /* set line positions */ <br>        cury = rcinner.top; <br>        for (i = 0; i &lt; ptab-&gt;nlines; i++) { <br>                ypos = &amp;ptab-&gt;pdata[i].linepos; <br>                ypos-&gt;start = cury; <br>                ypos-&gt;clipstart = ypos-&gt;start; <br>                ypos-&gt;clipend = ypos-&gt;start + ypos-&gt;size; <br>                ypos-&gt;clipend = min(ypos-&gt;clipend, rcinner.bottom); <br>                cury += ypos-&gt;size; <br>        } <br>        return(TRUE); <br>} <br> <br> <br>/* static information for this module */ <br>BOOL bAbort; <br>FARPROC lpAbortProc; <br>DLGPROC lpAbortDlg; <br>HWND hAbortWnd; <br>int npage; <br>int pages; <br> <br>/*************************************************************************** <br> * Function: gtab_printjob <br> * <br> * Purpose: <br> * <br> * Sets up print job and dialogs <br> */  <br>void <br>gtab_printjob(HWND hwnd, lpTable ptab, lpPrintContext pcontext) <br>{ <br>        int moveables; <br>        int endpage; <br>        int startpage = 1; <br>        HDC hpr; <br>        int status; <br>        HANDLE hcurs; <br>        static char str[256]; <br>        DOCINFO di; <br> <br>        CHAR szPage[60];  /* for LoadString */ <br> <br> <br>        hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>        moveables = ptab-&gt;nlines - ptab-&gt;hdr.fixedrows; <br>        pages = (int) (ptab-&gt;hdr.nrows - ptab-&gt;hdr.fixedrows + moveables - 1) <br>                        / moveables; <br>        endpage = pages; <br> <br>        if (pcontext-&gt;pd-&gt;Flags &amp; PD_PAGENUMS) { <br>                startpage = pcontext-&gt;pd-&gt;nFromPage; <br>                endpage = pcontext-&gt;pd-&gt;nToPage; <br>        } <br>        hpr = pcontext-&gt;pd-&gt;hDC; <br> <br>        lpAbortDlg = (DLGPROC) MakeProcInstance((WNDPROC) AbortDlg, hLibInst); <br>        lpAbortProc = (FARPROC) MakeProcInstance((WNDPROC)AbortProc, hLibInst); <br> <br>        SetAbortProc(hpr, (ABORTPROC) lpAbortProc); <br> <br>        ZeroMemory( &amp;di, sizeof( DOCINFO ) ); <br>        di.lpszDocName = "Table"; <br>        di.cbSize = sizeof( DOCINFO ); <br>        di.lpszOutput = NULL; <br> <br>        StartDoc(hpr, &amp;di); <br> <br>        bAbort = FALSE; <br> <br>        /* add abort modeless dialog later!! */ <br>        hAbortWnd = CreateDialog(hLibInst, "GABRTDLG", hwnd, lpAbortDlg); <br>        if (hAbortWnd != NULL) { <br>                ShowWindow(hAbortWnd, SW_NORMAL); <br>                EnableWindow(hwnd, FALSE); <br>        } <br>        SetCursor(hcurs); <br> <br>        for (npage = startpage; npage&lt;=endpage; npage++) { <br>                LoadString(hLibInst, IDS_PAGE_STR, szPage, sizeof(szPage)); <br>                wsprintf(str, szPage,  npage, pages); <br>                SetDlgItemText(hAbortWnd, IDC_LPAGENR, str); <br>                status = gtab_printpage(hwnd, ptab, pcontext, npage); <br>                if (status &lt; 0) { <br>                        AbortDoc(hpr); <br>                        break; <br>                } <br>        } <br>        if (status &gt;= 0) { <br>                EndDoc(hpr); <br>        } <br>         <br>        if (hAbortWnd != NULL) { <br>                EnableWindow(hwnd, TRUE); <br>                DestroyWindow(hAbortWnd); <br>        } <br>        FreeProcInstance((WNDPROC) lpAbortDlg); <br>        FreeProcInstance(lpAbortProc); <br> <br>        DeleteDC(hpr); <br>} <br> <br>/*************************************************************************** <br> * Function: AbortProc <br> * <br> * Purpose: <br> * <br> * Abort procedure for print job <br> */ <br>int APIENTRY <br>AbortProc(HDC hpr, int code) <br>{ <br> <br>        MSG msg; <br> <br>        if (!hAbortWnd) { <br>                return(TRUE); <br>        } <br>        while (!bAbort &amp;&amp; PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>                if (!IsDialogMessage(hAbortWnd, &amp;msg)) { <br>                        TranslateMessage(&amp;msg); <br>                        DispatchMessage(&amp;msg); <br>                } <br>        } <br>        return(!bAbort); <br>} <br> <br>/*************************************************************************** <br> * Function: AbortDlg <br> * <br> * Purpose: <br> * <br> * Dialog for abort procedure <br> */ <br>int APIENTRY <br>AbortDlg(HWND hdlg, UINT msg, UINT wParam, LONG lParam) <br>{ <br>        switch(msg) { <br> <br>        case WM_COMMAND: <br>                bAbort = TRUE; <br>                DestroyWindow (hdlg); <br>                return TRUE; <br> <br>        case WM_INITDIALOG: <br>                return TRUE; <br>        } <br>        return(FALSE); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_printpage <br> * <br> * Purpose: <br> * <br> * Print a single page. page number is 1-based <br> */ <br>BOOL <br>gtab_printpage(HWND hwnd, lpTable ptab, lpPrintContext pcontext, int page) <br>{ <br>        HDC hpr; <br>        int moveables, i; <br>        int x1, y1, x2, y2; <br> <br>        hpr = pcontext-&gt;pd-&gt;hDC; <br>        StartPage(hpr); <br> <br>        moveables = ptab-&gt;nlines - ptab-&gt;hdr.fixedrows; <br>        ptab-&gt;toprow = moveables * (page-1); <br>        gtab_invallines(hwnd, ptab, ptab-&gt;hdr.fixedrows, moveables); <br> <br>        for (i =0; i &lt; ptab-&gt;nlines; i++) { <br>                gtab_paint(hwnd, hpr, ptab, i); <br>        } <br>        if ((ptab-&gt;hdr.vseparator) &amp;&amp; (ptab-&gt;hdr.fixedcols &gt; 0)) { <br>                x1 = ptab-&gt;pcellpos[ptab-&gt;hdr.fixedcols -1].clipend+1; <br>                y1 = ptab-&gt;pdata[0].linepos.clipstart; <br>                y2 = ptab-&gt;pdata[ptab-&gt;nlines-1].linepos.clipend; <br>                MoveToEx(hpr, x1, y1, NULL); <br>                LineTo(hpr, x1, y2); <br>        } <br>        if ((ptab-&gt;hdr.hseparator) &amp;&amp; (ptab-&gt;hdr.fixedrows &gt; 0)) { <br>                y1 = ptab-&gt;pdata[ptab-&gt;hdr.fixedrows-1].linepos.clipend; <br>                x1 = ptab-&gt;pcellpos[0].clipstart; <br>                x2 = ptab-&gt;pcellpos[ptab-&gt;hdr.ncols-1].clipend; <br>                MoveToEx(hpr, x1, y1, NULL); <br>                LineTo(hpr, x2, y1); <br>        } <br> <br>        if (pcontext-&gt;head != NULL) { <br>                gtab_printhead(hwnd, hpr, ptab, pcontext-&gt;head, page); <br>        } <br>        if (pcontext-&gt;foot != NULL) { <br>                gtab_printhead(hwnd, hpr, ptab, pcontext-&gt;foot, page); <br>        } <br> <br>        return(EndPage(hpr)); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_setrects <br> * <br> * Purpose: <br> * <br> * Calculate the outline positions in pixels for the headers <br> * (outer rect) and for the page itself (inner rect). Based on <br> * page size and PrintContext margin info (which is in millimetres). <br> */ <br>void <br>gtab_setrects(lpPrintContext pcontext, LPRECT rcinner, LPRECT rcouter) <br>{ <br>        HDC hpr; <br>        int hpixels, hmms; <br>        int vpixels, vmms; <br>        int h_pixpermm, v_pixpermm; <br> <br>        hpr = pcontext-&gt;pd-&gt;hDC; <br>        hpixels = GetDeviceCaps(hpr, HORZRES); <br>        vpixels = GetDeviceCaps(hpr, VERTRES); <br>        vmms = GetDeviceCaps(hpr, VERTSIZE); <br>        hmms = GetDeviceCaps(hpr, HORZSIZE); <br> <br>        h_pixpermm = hpixels / hmms; <br>        v_pixpermm = vpixels / vmms; <br> <br>        rcouter-&gt;top = (pcontext-&gt;margin-&gt;top * v_pixpermm); <br>        rcouter-&gt;bottom = vpixels - (pcontext-&gt;margin-&gt;bottom * v_pixpermm); <br>        rcouter-&gt;left = (pcontext-&gt;margin-&gt;left * h_pixpermm); <br>        rcouter-&gt;right = hpixels - (pcontext-&gt;margin-&gt;right * h_pixpermm); <br> <br>        rcinner-&gt;left = rcouter-&gt;left; <br>        rcinner-&gt;right = rcouter-&gt;right; <br>        rcinner-&gt;top = rcouter-&gt;top + <br>                (pcontext-&gt;margin-&gt;topinner * v_pixpermm); <br>        rcinner-&gt;bottom = rcouter-&gt;bottom - <br>                (pcontext-&gt;margin-&gt;bottominner * v_pixpermm); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_printhead <br> * <br> * Purpose: <br> * <br> * Print header information <br> */ <br>void <br>gtab_printhead(HWND hwnd, HDC hdc, lpTable ptab, lpTitle head, int page) <br>{ <br>        RECT rc, rcbox; <br>        int i, cx, x, y, tab; <br>        UINT align; <br>        LPSTR chp, tabp; <br>        DWORD fcol, bkcol; <br>        char str[256]; <br> <br>        rc.top = head-&gt;ypos.clipstart; <br>        rc.bottom = head-&gt;ypos.clipend; <br>        rc.left = head-&gt;xpos.clipstart; <br>        rc.right = head-&gt;xpos.clipend; <br> <br>        /* update page number */ <br>        chp = str; <br>        for (i = 0; i &lt; lstrlen(head-&gt;ptext); i++) { <br>                switch(head-&gt;ptext[i]) { <br> <br>                case '#': <br>                        chp += wsprintf(chp, "%d", page); <br>                        break; <br>                 <br>                case '$': <br>                        chp += wsprintf(chp, "%d", pages); <br>                        break; <br>                 <br>                default: <br>                        if (IsDBCSLeadByte(head-&gt;ptext[i]) &amp;&amp; <br>                            head-&gt;ptext[i+1]) { <br>                                *chp = head-&gt;ptext[i]; <br>                                chp++; <br>                                i++; <br>                        } <br>                        *chp++ = head-&gt;ptext[i]; <br>                        break; <br>                } <br>        } <br>        *chp = '\0'; <br>        chp = str; <br> <br>        if (head-&gt;props.valid &amp; P_ALIGN) { <br>                align = head-&gt;props.alignment; <br>        } else { <br>                align = P_LEFT; <br>        } <br> <br>        /* set colours if not default */ <br>        if (head-&gt;props.valid &amp; P_FCOLOUR) { <br>                fcol = SetTextColor(hdc, head-&gt;props.forecolour); <br>        } <br>        if (head-&gt;props.valid &amp; P_BCOLOUR) { <br>                bkcol = SetBkColor(hdc, head-&gt;props.backcolour); <br>        } <br> <br>        /* calc offset of text within cell for right-align or centering */ <br>        if (align == P_LEFT) { <br>                cx = ptab-&gt;avewidth/2; <br>        } else { <br>                cx = LOWORD(GetTextExtent(hdc, chp, lstrlen(chp))); <br>                if (align == P_CENTRE) { <br>                        cx = (head-&gt;xpos.size - cx) / 2; <br>                } else { <br>                        cx = head-&gt;xpos.size - cx - (ptab-&gt;avewidth/2); <br>                } <br>        } <br>        cx += head-&gt;xpos.start; <br> <br>        /* expand tabs on output */ <br>        tab = ptab-&gt;avewidth * 8; <br>        x = 0; <br>        y = head-&gt;ypos.start; <br> <br>        for ( ; (tabp = strchr(chp, '\t')) != NULL; ) { <br>                /* perform output upto tab char */ <br>                ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &amp;rc, chp, tabp-chp, NULL); <br>                 <br>                /* advance past the tab */ <br>                x += LOWORD(GetTextExtent(hdc, chp, tabp - chp)); <br>                x = ( (x + tab) / tab) * tab; <br>                chp = ++tabp; <br>        } <br> <br>        /*no more tabs - output rest of string */ <br>        ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &amp;rc, chp, lstrlen(chp), NULL); <br> <br>        /* reset colours to original if not default */ <br>        if (head-&gt;props.valid &amp; P_FCOLOUR) { <br>                SetTextColor(hdc, fcol); <br>        } <br>        if (head-&gt;props.valid &amp; P_BCOLOUR) { <br>                SetBkColor(hdc, bkcol); <br>        } <br> <br>        /* now box cell if marked */ <br>        if (head-&gt;props.valid &amp; P_BOX) { <br>                if (head-&gt;props.box != 0) { <br>                        rcbox.top = head-&gt;ypos.start; <br>                        rcbox.bottom = rcbox.top + head-&gt;ypos.size; <br>                        rcbox.left = head-&gt;xpos.start; <br>                        rcbox.right = rcbox.left + head-&gt;xpos.size; <br>                        gtab_boxcell(hwnd, hdc, &amp;rcbox, &amp;rc, head-&gt;props.box); <br>                } <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
