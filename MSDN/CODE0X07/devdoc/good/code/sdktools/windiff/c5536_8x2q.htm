<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LIST.H</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5552"></a>LIST.H</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> * LIST.H <br> */ <br>/*------------------------------------------------------------------------ <br>| Abstract data type LIST OF (*untyped*) object. <br>| Different lists can have different types of object in them <br>| Different items in a list can have different types of object in them. <br>| The price of this lack of typing is that you have a slightly more <br>| awkward syntax and you get no help from the compiler if you try to <br>| put the wrong type of data into the list. <br>| <br>| The list is implemented as a collection of items.  Within the item <br>| somewhere is the object. <br>| <br>| Objects are stored UNALIGNED within items. <br>| <br>| Use: <br>| <br>|   #include &lt;list.h&gt; <br>|   . . . <br>|   LIST MyList; (* or LIST liMyList for Hungarians *) <br>|   . . . <br>|   MyList = List_Create(); <br>|   List_AddLast(MyList,&amp;MyObject,sizeof(OBJECT)); <br>| <br>| In the abstract a LIST is a list of objects.  The representation <br>| is a linked collection of items.  The manner of the linking is <br>| implementation dependent (as I write this it's linear but when you <br>| read it it might be a tree (See Knuth for why a tree)). <br>| <br>| A LIST is a "handle" for a list which may be thought of as a POINTER <br>| (whether it is really a pointer or not is implementation dependent) <br>| so that it can be copied at the risk of creating an alias. e.g. <br>| <br>|   L = List_Create(); <br>|   L1 = L;             (* L and L1 are both healthy and empty *) <br>|   List_AddFirst(L, &amp;elem, sizeof(elem)); <br>|   (* L1 may also appear to have one object, there again it may be sick *) <br>|   L1 = L;               (* Now they both surely see the one element *) <br>|   List_Destroy(&amp;L1);    (* L is almost certainly sick now too *) <br>|   L1 = List_Create();   (* All bets off as to what L is like now <br>|                            but L1 is empty and healthy <br>|                         *) <br>| <br>| If two handles compare equal then the lists must be equal, but <br>| unequal handles could address two similar lists i.e. the same list <br>| of objects held in two different LISTs of items (like pointers). <br>| <br>| A LIST can be transferred from one variable to another like this: <br>| <br>|   NewList = OldList;           (* copy the handle *) <br>|   OldList = List_Create();     (* kill the old alias *) <br>| <br>| and the Create statement can be omitted if OldList is never touched again. <br>| <br>| Items are identified by Cursors.  A cursor is the address of an object <br>| within an item in the list. i.e. it is the address of the piece of your <br>| data that you had inserted.  (It is probably NOT the address of the item). <br>| It is typed as pointer to void here, but you should declare it as a pointer <br>| to whatever sort of object you are putting in the LIST. <br>| <br>| The operations AddFirst, AddLast, AddAfter and AddBefore <br>| all copy elements by direct assignment.  If an element is itself <br>| a complex structure (say a tree) then this will only copy a pointer <br>| or an anchor block or whatever and give all the usual problems of <br>| aliases.  Clear will make the list empty, but will only free the <br>| storage that it can "see" directly.  SplitBefore or Split After may <br>| also perform a Clear operation.  To deal with fancy data structures <br>| use New rather than Add calls and copy the data yourself <br>|   e.g.  P = List_NewLast(MyList, sizeof(MyArray[14])*(23-14+1)); <br>|         CopyArraySlice(P, MyArray, 14, 23); <br>| <br>| The operations NewFirst, NewLast, NewAfter, NewBefore, First and Last <br>| all return pointers to elements and thus allow you to do any copying. <br>| This is how you might copy a whole list of fancy structures: <br>| <br>|    void CopyFancyList(LIST * To, LIST From) <br>|             (* Assumes that To has been Created and is empty *) <br>|    { PELEMENT Cursor; <br>|      PELEMENT P; <br>| <br>|      List_TRAVERSE(From, Cursor); <br>|      { P = List_NewLast(To, sizeof(element) ); <br>|        FancyCopy(P, Cursor);    (* Copy so that *Cursor==*P afterwords *) <br>|      } <br>|    } <br> --------------------------------------------------------------------*/ <br> <br>  typedef struct item_tag FAR * LIST; <br>  typedef LIST FAR * PLIST; <br> <br>  void APIENTRY List_Init(void); <br>  /* MUST BE CALLED BEFORE ANY OF THE OTHER FUNCTIONS. */ <br> <br>  void APIENTRY List_Dump(LPSTR Header, LIST lst); <br>  /* Dump the internals to current output stream -- debug only */ <br> <br>  void APIENTRY List_Show(LIST lst); <br>  /* Dump hex representation of handle to current out stream -- debug only */ <br> <br>  LIST APIENTRY List_Create(void); <br>  /* Create a list.  It will be initially empty */ <br> <br>  void APIENTRY List_Destroy(PLIST plst); <br>  /* Destroy *plst.  It does not need to be empty first. <br>  |  All storage directly in the list wil be freed. <br>  */ <br> <br>  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen); <br>  /* Add an item holding Object to the beginning of * plst */ <br> <br>  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen); <br>  /* Return the address of the place for Len bytes of data in a new <br>  |  item at the start of *plst <br>  */ <br> <br>  void APIENTRY List_DeleteFirst(LIST lst); <br>  /* Delete the first item in lst.  Error if lst is empty */ <br> <br>  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen); <br>  /* Add an item holding Object to the end of lst */ <br> <br>  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen); <br>  /* Return the address of the place for uLen bytes of data in a new <br>  |  item at the end of lst <br>  */ <br> <br>  void APIENTRY List_DeleteLast(LIST lst); <br>  /* Delete the last item in lst.  Error if lst is empty */ <br> <br>  void APIENTRY List_AddAfter( LIST lst <br>                    , LPVOID Curs <br>                    , LPVOID pObject <br>                    , UINT uLen <br>                    ); <br>  /*-------------------------------------------------------------------- <br>  | Add an item holding *pObject to lst immediately after Curs. <br>  | List_AddAfter(lst, NULL, pObject, Len) adds it to the start of the lst <br>   ---------------------------------------------------------------------*/ <br> <br>  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen); <br>  /*-------------------------------------------------------------------- <br>  | Return the address of the place for uLen bytes of data in a new <br>  | item immediately after Curs. <br>  | List_NewAfter(Lst, NULL, uLen) returns a pointer <br>  | to space for uLen bytes in a new first element. <br>   ---------------------------------------------------------------------*/ <br> <br>  void APIENTRY List_AddBefore( LIST lst <br>                     , LPVOID Curs <br>                     , LPVOID pObject <br>                     , UINT uLen <br>                     ); <br>  /*-------------------------------------------------------------------- <br>  | Add an item holding Object to lst immediately before Curs. <br>  | List_AddBefore(Lst, NULL, Object, uLen) adds it to the end of the list <br>   ---------------------------------------------------------------------*/ <br> <br>  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen ); <br>  /*-------------------------------------------------------------------- <br>  | Return the address of the place for uLen bytes of data in a new <br>  | item immediately before Curs. <br>  | List_NewBefore(Lst, NULL, uLen) returns a pointer <br>  | to space for uLen bytes in a new last element. <br>   ---------------------------------------------------------------------*/ <br> <br>  void APIENTRY List_Delete(LPVOID Curs); <br>  /*------------------------------------------------------------------ <br>  | Delete the item that Curs identifies. <br>  | This will be only a few (maybe as little as 3) machine instructions <br>  | quicker than DeleteAndNext or DeleteAndPrev but leaves Curs dangling. <br>  | It is therefore NOT usually to be preferred. <br>  | It may be useful when you have a function which returns an LPVOID <br>  | since the argument does not need to be a variable. <br>  |     Trivial example: List_Delete(List_First(L)); <br>   -------------------------------------------------------------------*/ <br> <br>  int APIENTRY List_ItemLength(LPVOID Curs); <br>  /* Return the length of the object identified by the cursor Curs */ <br> <br>  /*------------------------------------------------------------------ <br>  | TRAVERSING THE ULIST <br>  | <br>  | LIST lst; <br>  | object * Curs; <br>  | . . . <br>  | Curs = List_First(lst); <br>  | while (Curs!=NULL) <br>  | {  DoSomething(*Curs);   (* Curs points to YOUR data not to chain ptrs *) <br>  |    Curs = List_Next(Curs); <br>  | } <br>  | <br>  | This is identically equal to <br>  | List_TRAVERSE(lst, Curs)  // note NO SEMI COLON! <br>  | {  DoSomething(*Curs); } <br>   -------------------------------------------------------------------*/ <br> <br>  #define List_TRAVERSE(lst, curs)  for(  curs=List_First(lst)            \ <br>                                       ;  curs!=NULL                      \ <br>                                       ;  curs = List_Next((LPVOID)curs)  \ <br>                                       ) <br> <br>  LPVOID APIENTRY List_First(LIST lst); <br>  /*------------------------------------------------------------------ <br>  | Return the address of the first object in lst <br>  |  If lst is empty then Return NULL. <br>  --------------------------------------------------------------------*/ <br> <br>  LPVOID APIENTRY List_Last(LIST lst); <br>  /*------------------------------------------------------------------ <br>  | Return the address of the last object in lst <br>  | If lst is empty then return NULL. <br>  --------------------------------------------------------------------*/ <br> <br>  LPVOID APIENTRY List_Next(LPVOID Curs); <br>  /*------------------------------------------------------------------ <br>  | Return the address of the object after Curs^. <br>  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error. <br>  | List_Next(List_Prev(curs)) is illegal if curs identifies first el <br>  --------------------------------------------------------------------*/ <br> <br>  LPVOID APIENTRY List_Prev(LPVOID Curs); <br>  /*------------------------------------------------------------------ <br>  | Return the address of the object after Curs^. <br>  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error. <br>  | List_Prev(List_Next(curs)) is illegal if curs identifies last el <br>  --------------------------------------------------------------------*/ <br> <br>  /*------------------------------------------------------------------ <br>  |  Whole list operations <br>   -----------------------------------------------------------------*/ <br>  void APIENTRY List_Clear(LIST lst); <br>  /* arrange that lst is empty after this */ <br> <br>  BOOL APIENTRY List_IsEmpty(LIST lst); <br>  /* Return TRUE if and only if lst is empty */ <br> <br>  void APIENTRY List_Join(LIST l1, LIST l2); <br>  /*----------------------------------------------------------------------- <br>  | l1 := l1||l2; l2 := empty <br>  | The elements themselves are not moved, so pointers to them remain valid. <br>  | <br>  | l1 gets all the elements of l1 in their original order followed by <br>  | all the elements of l2 in the order they were in in l2. <br>  | l2 becomes empty. <br>   ------------------------------------------------------------------------*/ <br> <br>  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs); <br>  /*----------------------------------------------------------------------- <br>  | l1 := l1[...Curs] || l2 || l1[Curs+1...]; l2 := empty <br>  | Curs=NULL means insert l2 at the start of l1 <br>  | The elements themselves are not moved, so pointers to them remain valid. <br>  | <br>  | l1 gets the elements of l1 from the start up to and including the element <br>  | that Curs points at, in their original order, <br>  | followed by all the elements that were in l2, in their original order, <br>  | followed by the rest of l1 <br>   ------------------------------------------------------------------------*/ <br> <br>  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs); <br>  /*----------------------------------------------------------------------- <br>  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty <br>  | Curs=NULL means insert l2 at the end of l1 <br>  | The elements themselves are not moved, so pointers to them remain valid. <br>  | <br>  | l1 gets the elements of l1 from the start up to but not including the <br>  | element that Curs points at, in their original order, <br>  | followed by all the elements that were in l2, in their original order, <br>  | followed by the rest of l1. <br>   ------------------------------------------------------------------------*/ <br> <br>  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs); <br>  /*----------------------------------------------------------------------- <br>  | Let l1 be l1 and l2 be l2 <br>  | Split l2 off from the front of l1:    final l2,l1 = original l1 <br>  | <br>  | Split l1 into l2: objects of l1 up to and including Curs object <br>  |               l1: objects of l1 after Curs <br>  | Any original contents of l2 are freed. <br>  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all. <br>  | The elements themselves are not moved. <br>   ------------------------------------------------------------------------*/ <br> <br>  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs); <br>  /*---------------------------------------------------------------------- <br>  | Split l2 off from the back of l1:  final l1,l2 = original l1 <br>  | <br>  | Split l1 into l1: objects of l1 up to but not including Curs object <br>  |               l2: objects of l1 from Curs onwards <br>  | Any original contants of l2 are freed. <br>  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all. <br>  | The elements themselves are not moved. <br>   -----------------------------------------------------------------------*/ <br> <br>  int APIENTRY List_Card(LIST lst); <br>  /* Return the number of items in L */ <br> <br>  /*------------------------------------------------------------------ <br>  | Error handling. <br>  | <br>  | Each list has within it a flag which indicates whether any illegal <br>  | operation has been detected (e.g. DeleteFirst when empty). <br>  | Rather than have a flag on every operation, there is a flag held <br>  | within the list that can be queried when convenient.  Many operations <br>  | do not have enough redundancy to allow any meaningful check.  This <br>  | is a design compromise (for instance to allow P = List_Next(P); <br>  | rather than P = List_Next(L, P); which is more awkward, especially <br>  | if L is actually a lengthy phrase). <br>  | <br>  | List_IsOK tests this flag (so is a very simple, quick operation). <br>  | MakeOK sets the flag to TRUE, in other words to accept the current <br>  | state of the list. <br>  | <br>  | It is possible for a list to be damaged (whether or not the flag <br>  | says OK) for instance by the storage being overwritten. <br>  | <br>  | List_Check attempts to verify that the list is sound (for instance where <br>  | there are both forward and backward pointers they should agree). <br>  | <br>  | List_Recover attempts to make a sound list out of whatever debris is left. <br>  | If the list is damaged, Recover may trap (e.g. address error) but <br>  | if the list was damaged then ANY operation on it may trap. <br>  | If Check succeeds without trapping then so will Recover. <br>   -----------------------------------------------------------------*/ <br> <br>  BOOL APIENTRY List_IsOK(LIST lst); <br>  /* Check return code */ <br> <br>  void APIENTRY List_MakeOK(LIST lst); <br>  /* Set return code to good */ <br> <br>  BOOL APIENTRY List_Check(LIST lst); <br>  /* Attempt to validate the chains */ <br> <br>  void APIENTRY List_Recover(PLIST plst); <br>  /* Desperate stuff.  Attempt to reconstruct something */ <br> <br>/*------------------------------------------------------------------ <br>|  It is designed to be as easy to USE as possible, consistent <br>|  only with being an opaque type. <br>| <br>|  In particular, the decision to use the address of an object a list cursor <br>|  means that there is a small amount of extra arithmetic (in the <br>|  IMPLEMENTATION) in cursor operations (e.g. Next and Prev). <br>|  and spurious arguments are avoided whenever possible, even though <br>|  it would allow greater error checking. <br>| <br>| Of the "whole list" operations, Clear is given because it seems to be <br>| a common operation, even though the caller can implement it with almost <br>| the same efficiency as the List implementation module. <br>| Join, Split and InsertListXxx cannot be implemented efficiently without <br>| knowing the representation. <br> --------------------------------------------------------------------*/ </code></pre>
<p>&nbsp;</p></body>
</HTML>
