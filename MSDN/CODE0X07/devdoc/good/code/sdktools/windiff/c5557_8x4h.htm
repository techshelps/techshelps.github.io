<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TABLE.H</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5561"></a>TABLE.H</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> * TABLE.H <br> * <br> * public interface definition for table window class. <br> * <br> * include after gutils.h and commdlg.h <br> */ <br> <br>/* -------class and message names --------------------------------------*/ <br> <br>/* create a window of this class */ <br>#define  TableClassName "GTableClass" <br> <br> <br>/* all messages to the owner window are sent with this message. <br> * call RegisterWindowsMessage with this string for the message UINT. <br> */ <br>#define TableMessage  "GTableQuery" <br> <br>/* -------- messages to and from table class  --------------------------*/ <br> <br>/* messages to owner window are: <br> *      message:        TableMessage <br> *      wParam:         command code (below) <br> * lParam:              struct pointer according to code <br> * below is list of wParam codes &amp; associated lParam struct <br> */ <br>#define TQ_GETSIZE      1       /* lParam: lpTableHdr */ <br>#define TQ_GETCOLPROPS  2       /* lParam: lpColPropList */ <br>#define TQ_GETDATA      3       /* lParam: lpCellDataList */ <br>#define TQ_PUTDATA      4       /* lParam: lpCellDataList */ <br>#define TQ_SELECT       5       /* lParam: lpTableSelection */ <br>#define TQ_ENTER        6       /* lParam: lpTableSelection */ <br>#define TQ_CLOSE        7       /* lParam: the data id to be closed */ <br> <br>/* optional */ <br>#define TQ_SCROLL       8       /* lParam: the new top row nr */ <br> <br> <br>/* messages to Table class */ <br> <br>/* data, or nrows has changed  wParam/lParam null*/ <br>#define TM_REFRESH      (WM_USER) <br> <br>/* nr cols/props/layout has changed  - wparam/lparam null */ <br>#define TM_NEWLAYOUT    (WM_USER+1) <br> <br>/* Close old id, and display new - wParam null, lParam has new id */ <br>#define TM_NEWID        (WM_USER+2) <br> <br>/* Select and show this area - wParam null, lParam is lpTableSelection */ <br>#define TM_SELECT       (WM_USER+3) <br> <br>/* Print current table - wParam null, lParam either null <br> * or lpPrintContext. <br> */ <br>#define TM_PRINT        (WM_USER+4) <br> <br>/* Return the top row in the window. If wParam is TRUE, then set <br> * lParam to be the new toprow. top row is the number of rows scrolled down <br> * from the top. Thus the first visible non-fixed row is toprow+fixedrows <br> */ <br>#define TM_TOPROW       (WM_USER+5) <br> <br> <br>/* Return the end row visible. This is the 0-based rownr of the last <br> * visible row in the window <br> */ <br>#define TM_ENDROW       (WM_USER+6) <br> <br>/* New rows have been added to the end of the table, but no other <br> * rows or cols or properties have been changed. <br> * wParam contains the new total nr of rows. lParam contains the id <br> * in case this has changed. <br> */ <br>#define TM_APPEND       (WM_USER+7) <br> <br>/*-----display properties -------------------------------------------------*/ <br> <br>/* <br> * Display properties struct. can be set for whole table, for <br> * each column, or for each cell. When looking for <br> * a property, we search cell-&gt;column-&gt;table <br> */ <br>typedef struct { <br>        UINT valid;             /* flags (below) for what props we set */ <br> <br>/* remaining fields only valid when corresponding flag set in valid */ <br> <br>        DWORD forecolour;       /* RGB colour value */ <br>        DWORD backcolour;       /* ditto */ <br>        /* font to use - also set through WM_SETFONT. owner application <br>         * is responsible for DeleteObject call when no longer used <br>         */ <br>        HFONT hFont;            /* handle to font  - caller should delete*/ <br>        UINT alignment;         /* flags below */ <br>        UINT box;               /* whether cell boxed (see below) */ <br> <br>        /* width/height settings not valid at cell level - only table or col.*/ <br>        int width;              /* pixel width of this cell/column */ <br>        int height;             /* pixel cell height */ <br>} Props, FAR * lpProps; <br> <br>/* Valid flags for fields that are changed in this Props struct */ <br>#define P_FCOLOUR       1 <br>#define P_BCOLOUR       2 <br>#define P_FONT          4 <br>#define P_ALIGN         8 <br>#define P_BOX           0x20 <br>#define P_WIDTH         0x40 <br>#define P_HEIGHT        0x80 <br> <br>/* Box settings  or-ed together */ <br>#define P_BOXTOP        1 <br>#define P_BOXBOTTOM     2 <br>#define P_BOXLEFT       4 <br>#define P_BOXRIGHT      8 <br>#define P_BOXALL        0xF <br> <br>/* Alignment settings (expand later to include various tab-align settings */ <br>#define P_LEFT          0 <br>#define P_RIGHT         1 <br>#define P_CENTRE        2 <br> <br>/* This struct is the master information about a table. It is <br> * passed to the owner window with the id field filled in; fill in <br> * all remaining fields and return. <br> */ <br>typedef struct { <br>        DWORD id;               /* owner's data id */ <br> <br>        long nrows;             /* how many rows ? TM_REFRESH to change */ <br>        int ncols;              /* how many columns ? TM_NEWLAYOUT to chg */ <br> <br>        int fixedrows;          /* for headers - usually 0 or 1 */ <br>        int fixedcols;          /* for hdrs - 0 or 1 normally */ <br>        BOOL fixedselectable;   /* is fixed area selectable ? */ <br>        BOOL hseparator;        /* is there a horz. line after fixed rows */ <br>        BOOL vseparator;        /* is there a vert. line after fixed rows */ <br> <br>        UINT selectmode;        /* multiple/single selection - flags below*/ <br>        BOOL sendscroll;        /* TRUE if TQ_SCROLL to be sent on scrolling*/ <br> <br>        Props props; <br>} TableHdr, FAR * lpTableHdr; <br> <br>/* <br> * selection mode; <br> * <br> * choose TM_CELL or TM_ROW, and TM_SINGLE or TM_MANY, and <br> * TM_SOLID or TM_FOCUS and or them together. <br> * <br> * current implementation does not support TM_MANY !! <br> */ <br>#define TM_ROW          1       /* selectable items are rows */ <br>#define TM_CELL         0       /* selectable items are cells */ <br> <br>#define TM_MANY         2       /* multiple selects possible */ <br>#define TM_SINGLE       0       /* single item selectable at once only */ <br> <br>#define TM_SOLID        0       /* (default) use a solid black for selection*/ <br>#define TM_FOCUS        4       /* use a dotted focus rect for selection */ <br> <br> <br>/* --------- column header structs --------------------------------------*/ <br> <br>/* <br> * This struct is sent to request column width and properties - <br> * owner window must fill nchars and props.valid, at minimum. <br> */ <br>typedef struct { <br>        int nchars;     /* expected text width in chars */ <br>        Props props; <br>} ColProps, FAR * lpColProps; <br> <br> <br>/* This is a set of column requests - owner should fill each one*/ <br>typedef struct { <br>        DWORD id;               /* caller's id for data */ <br>        int startcol;           /* zero-based column nr of first request */ <br>        int ncols;              /* nr of columns in this set */ <br>        lpColProps plist;       /* ptr to _array_ of ColProps */ <br>} ColPropsList, FAR * lpColPropsList; <br> <br> <br>/* --- cell data structs ---------------------------------------------*/ <br> <br>/* This is the per-cell data struct. <br> * When providing data (responding to TQ_GETDATA), fill out ptext[] and <br> * props as appropriate. ptext will be pre-allocated with nchars bytes of <br> * space. This may be larger than ColProps-&gt;nchars if the user has <br> * stretched this column's width on screen <br> * <br> * Don't re-alloc ptext, or change flags. <br> */ <br>typedef struct { <br>        int nchars;             /* space in buffer */ <br>        LPSTR ptext;            /* ptr to nchars of text space */ <br>        Props props;            /* per-cell props */ <br>        DWORD flags;            /* private table class flags */ <br>} CellData, FAR * lpCellData; <br> <br>/* List of cell data structures - please fill out all of these*/ <br>typedef struct { <br>        DWORD id;               /* caller's id for data */ <br>        long row;               /* zero-based row nr to fetch */ <br>        int startcell;          /* zero-based cell nr on this row */ <br>        int ncells;             /* count of cells to fetch */ <br>        lpCellData plist;       /* ptr to array CellData[ncells] */ <br>} CellDataList, FAR * lpCellDataList; <br> <br> <br>/*----- current selection----------------------------------------------*/ <br> <br>/* Describes the current selection - a rectangular selection area */ <br>typedef struct { <br>        DWORD id;               /* caller's id for data */ <br>        long startrow;          /* zero-based row nr of start of sel. */ <br>        long startcell;         /* zero-based col nr of  start of sel */ <br>        long nrows;             /* vertical depth of selection */ <br>        long ncells;            /* horz width of selection */ <br>} TableSelection, FAR * lpTableSelection; <br> <br> <br> <br>/*----- print context -----------------------------------------------*/ <br> <br>/* Describes the margin settings for the print job - these are in CMs*/ <br>typedef struct { <br>        int left;               /* edge of paper to start of print area */ <br>        int right;              /* edge of paper to start of print area */ <br>        int top;                /* edge of paper to start of hdr */ <br>        int bottom;             /* end of hdr to end of paper */ <br>        int topinner;           /* start of hdr to start of data */ <br>        int bottominner;        /* end of data to start of hdr */ <br>} Margin, FAR * lpMargin; <br> <br>/* Position and clipping info - only used by table class <br> */ <br>typedef struct { <br>        int start;              /* co-ord of cell start (left or top) */ <br>        int clipstart;          /* start of clipping (vis area) */ <br>        int clipend;            /* end of clipping (vis area) */ <br>        int size;               /* pixel size of cell (width or height) */ <br>} CellPos, FAR * lpCellPos; <br> <br> <br>/* One of these for each header lines (top and bottom) */ <br>typedef struct { <br>        CellPos xpos, ypos;     /* private: for table-class use only */ <br>        Props props; <br>        LPSTR ptext; <br>} Title, FAR * lpTitle; <br> <br>/* Print context data structure - any or all 4 pointers may be null */ <br>typedef struct { <br>        DWORD id;               /* id of table to print */ <br>        lpTitle head; <br>        lpTitle foot; <br>        lpMargin margin; <br>        PRINTDLG FAR * pd; <br>} PrintContext, FAR * lpPrintContext; <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
