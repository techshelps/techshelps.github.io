<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TREE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5565"></a>TREE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: TREE.C <br>* <br>* Functions supporting an unbalanced binary tree. <br>* <br>* Functions: <br>* <br>* tree_delitem() <br>* tree_newitem() <br>* tree_getitem() <br>* tree_create() <br>* tree_delete() <br>* tree_update() <br>* tree_find() <br>* tree_search() <br>* tree_addafter() <br>* ctree_create() <br>* ctree_delete() <br>* ctree_update() <br>* ctree_getcount() <br>* ctree_find() <br>* <br>* Comments: <br>* <br>* TREE is a data type providing a map between a KEY and a VALUE. The KEY is a <br>* 32-bit DWORD, and the VALUE is any arbitrary area of storage. <br>* <br>* Mmemory is allocated from gmem_get, using hHeap as the heap handle. <br>* hHeap must be declared and initialised elsewhere. <br>* <br>* Currently implemented as a unbalanced binary tree. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#include "gutils.h" <br>#include "tree.h" <br> <br> <br>/* -- data types ----------------------------------------------- */ <br> <br>/* on creating a tree, we return a TREE handle. This is in fact a pointer <br> * to a struct tree, defined here. <br> */ <br>struct tree { <br>        HANDLE hHeap; <br>        TREEITEM first; <br>}; <br> <br>/* each element in the tree is stored in a TREEITEM. a TREEITEM handle <br> * is a pointer to a struct treeitem, defined here <br> */ <br>struct treeitem { <br>        TREE root; <br> <br>        TREEKEY key; <br> <br>        TREEITEM left, right; <br> <br>        UINT length;            /* length of the user's data */ <br> <br>        LPVOID data;            /* pointer to our copy of the users data */ <br> <br>}; <br> <br>/*************************************************************************** <br> * Function: tree_delitems <br> * <br> * Purpose: <br> * <br> * Free up an element of the tree. Recursively calls itself to <br> * free left and right children <br> */ <br>void <br>tree_delitem(TREEITEM item) <br>{ <br>        if (item == NULL) { <br>                return; <br>        } <br>        if (item-&gt;left != NULL) { <br>                tree_delitem(item-&gt;left); <br>        } <br>        if (item-&gt;right != NULL) { <br>                tree_delitem(item-&gt;right); <br>        } <br>        if (item-&gt;data != NULL) { <br>                gmem_free(item-&gt;root-&gt;hHeap, item-&gt;data, item-&gt;length); <br>        } <br> <br>        gmem_free(item-&gt;root-&gt;hHeap, (LPSTR) item, sizeof(struct treeitem)); <br>} <br> <br>/*************************************************************************** <br> * Function: tree_newitem <br> * <br> * Purpose: <br> * <br> * Creates a new treeitem, with a data block of length bytes. <br> * If the value pointer is not NULL, initialise the data block with <br> * the contents of value. <br> */ <br>TREEITEM <br>tree_newitem(TREE root, TREEKEY key, LPVOID value, UINT length) <br>{ <br>        TREEITEM item; <br> <br>        item = (TREEITEM) gmem_get(root-&gt;hHeap, sizeof(struct treeitem)); <br> <br>        item-&gt;root = root; <br>        item-&gt;key = key; <br>        item-&gt;left = NULL; <br>        item-&gt;right = NULL; <br>        item-&gt;length = length; <br>        item-&gt;data = gmem_get(root-&gt;hHeap, length); <br>        if (value != NULL) { <br>                memcpy(item-&gt;data, value, length); <br>        } <br> <br>        return(item); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: tree_getitem <br> * <br> * Purpose: <br> * <br> * Finds the item with the given key. If it does not exist, return <br> * the parent item to which it would be attached. Returns NULL if <br> * no items in the tree <br> */ <br>TREEITEM <br>tree_getitem(TREE tree, TREEKEY key) <br>{ <br>        TREEITEM item, prev; <br> <br> <br>        prev = NULL; <br>        for (item = tree-&gt;first; item != NULL; ) { <br>                 <br>                if (item-&gt;key == key) { <br>                        return(item); <br>                } <br> <br>                /* not this item - go on to the correct child item. <br>                 * remember this item as if the child is NULL, this item <br>                 * will be the correct insertion point for the new item <br>                 */ <br>                prev = item; <br> <br>                if (key &lt; item-&gt;key) { <br>                        item = item-&gt;left; <br>                } else { <br>                        item = item-&gt;right; <br>                } <br>        }        <br>        /* prev is the parent - or null if nothing in tree */ <br>        return(prev); <br>} <br> <br>/*************************************************************************** <br> * Function: tree_create <br> * <br> * Purpose: <br> * <br> * Creates an empty tree. hHeap is the handle to use for all <br> * memory allocations for this tree. <br> */ <br>TREE APIENTRY <br>tree_create(HANDLE hHeap) <br>{ <br>        TREE tree; <br> <br>        tree = (TREE) gmem_get(hHeap, sizeof(struct tree)); <br>        tree-&gt;first = NULL; <br>        tree-&gt;hHeap = hHeap; <br>        return(tree); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: tree_delete <br> * <br> * Purpose: <br> * <br> * Deletes an entire tree, including all the user data <br> */ <br>void APIENTRY <br>tree_delete(TREE tree) <br>{ <br> <br>        tree_delitem(tree-&gt;first); <br> <br>        gmem_free(tree-&gt;hHeap, (LPSTR) tree, sizeof(struct tree)); <br>} <br> <br>/*************************************************************************** <br> * Function: tree_update <br> * <br> * Purpose: <br> * <br> * Adds a new element to the tree, mapping the key given to the value given. <br> * The value is a block of storage: a copy of this is inserted into the tree. <br> * We return a pointer to the copy of the data in the tree. <br> * <br> * The value pointer can be NULL: in this case, we insert a block of <br> * length bytes, but don't initialise it. You get a pointer to it and <br> * can initialise it yourself. <br> * <br> * If the key already exists, the value will be replaced with the new data. <br> */ <br>LPVOID APIENTRY <br>tree_update(TREE tree, TREEKEY key, LPVOID value, UINT length) <br>{ <br>        TREEITEM item; <br> <br>        /* find the place in the tree for this key to go */ <br>        item = tree_getitem(tree, key); <br> <br>        if (item == NULL) { <br>                /* there is nothing in the tree: this item should <br>                 * go at the top <br>                 */ <br>                tree-&gt;first = tree_newitem(tree, key, value, length); <br>                return(tree-&gt;first-&gt;data); <br>        } <br> <br>        /* is this the same key ? */ <br>        if (item-&gt;key == key) { <br> <br>                /* this key already inserted. re-alloc the data */ <br>                if (length != item-&gt;length) { <br>                        gmem_free(tree-&gt;hHeap, item-&gt;data, item-&gt;length); <br>                        item-&gt;data = gmem_get(tree-&gt;hHeap, length); <br>                } <br>                /* don't initialise block if no pointer passed */ <br>                if (value != NULL) { <br>                        memcpy(item-&gt;data, value, length); <br>                } <br>                return(item-&gt;data); <br>        } <br> <br>        /* not the same key - getitem returned the parent for <br>         * the new tree. insert it as a child of item. <br>         */ <br>        return(tree_addafter(tree, &amp;item, key, value, length)); <br>} <br> <br>/*************************************************************************** <br> * Function: tree_find <br> * <br> * Purpose: <br> * <br> * Returns a pointer to the value (data block) for a given key. Returns <br> * null if not found. <br> */ <br>LPVOID APIENTRY <br>tree_find(TREE tree, TREEKEY key) <br>{ <br>        TREEITEM item; <br> <br>        /* find the correct place in the tree */ <br>        item = tree_getitem(tree, key); <br> <br>        if (item == NULL) { <br>                /* nothing in the tree */ <br>                return(NULL); <br>        } <br> <br>        if (item-&gt;key != key) { <br>                /* this key not in. getitem has returned parent */ <br>                return(NULL); <br>        } <br> <br>        /* found the right element - return pointer to the <br>         * data block <br>         */ <br>        return(item-&gt;data); <br>} <br> <br>/* The next two routines are an optimisation for a common tree operation. In <br> * this case, the user will want to insert a new element only if <br> * the key is not there. If it is there, he will want to modify the <br> * existing value (increment a reference count, for example). <br> * <br> * If tree_search fails to find the key, it will return a TREEITEM handle <br> * for the parent. This can be passed to tree_addafter to insert the <br> * new element without re-searching the tree. <br> */ <br> <br>/*************************************************************************** <br> * Function: tree_search <br> * <br> * Purpose: <br> * <br> * Find an element. If not, find it's correct parent item <br> */ <br>LPVOID APIENTRY <br>tree_search(TREE tree, TREEKEY key, PTREEITEM pplace) <br>{ <br>        TREEITEM item; <br> <br>        item = tree_getitem(tree, key); <br> <br>        if (item == NULL) { <br>                /* no items in tree. set placeholder to NULL to <br>                 * indicate insert at top of tree <br>                 */ <br>                *pplace = NULL;          <br> <br>                /* return NULL to indicate key not found */ <br>                return(NULL); <br>        } <br> <br>        if (item-&gt;key == key) { <br>                /* found the key already there - <br>                 * set pplace to null just for safety <br>                 */ <br>                *pplace = NULL; <br> <br>                /* give the user a pointer to his data */ <br>                return(item-&gt;data); <br>        } <br> <br> <br>        /* key was not found - getitem has returned the parent <br>         * - set this as the place for new insertions <br>         */ <br>        *pplace = item;          <br> <br>        /* return NULL to indicate that the key was not found */ <br>        return(NULL); <br>} <br> <br>/*************************************************************************** <br> * Function: tree_addafter <br> * <br> * Purpose: <br> * <br> * Insert a key in the position already found by tree_search. <br> * <br> * Return a pointer to the user's data in the tree. If the value <br> * pointer passed in is null, then we allocate the block, but don't <br> * initialise it to anything. <br> */ <br>LPVOID APIENTRY <br>tree_addafter(TREE tree, PTREEITEM place, TREEKEY key, LPVOID value, UINT length) <br>{ <br>        TREEITEM item, child; <br> <br>        item = *place; <br>        if (item == NULL) { <br>                tree-&gt;first = tree_newitem(tree, key, value, length); <br>                return (tree-&gt;first-&gt;data); <br>        }                <br> <br>        child = tree_newitem(tree, key, value, length);          <br>        if (child-&gt;key &lt; item-&gt;key ) { <br>                /* should go on left leg */ <br>                item-&gt;left = child; <br>        } else {         <br>                item-&gt;right = child; <br>        } <br>        return(child-&gt;data); <br>} <br> <br> <br>/* --- ctree ------------------------------------------------------*/ <br> <br>/* <br> * ctree is a class of tree built on top of the tree interface. a <br> * ctree keeps count of the number of insertions of identical keys. <br> * <br> * We do this be adding a long counter to the beginning of the user <br> * data before inserting into the tree. If the key is not found, we set <br> * this to one. If the key was already there, we *do not* insert the <br> * data (data is always from the first insertion) - we simply increment <br> * the count. <br> */ <br> <br>/* Create a tree for use by CTREE - same as an ordinary tree <br> */ <br>TREE APIENTRY <br>ctree_create(HANDLE hHeap) <br>{ <br>        return(tree_create(hHeap)); <br>} <br> <br>/* <br> * Delete a ctree - same as for TREE <br> */ <br>void APIENTRY <br>ctree_delete(TREE tree) <br>{ <br>        tree_delete(tree); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: ctree_update <br> * <br> * Purpose: <br> * <br> * Insert an element in the tree. If the element is not there, <br> * insert the data and set the reference count for this key to 1. <br> * If the key was there already, don't change the data, just increment <br> * the reference count <br> * <br> * If the value pointer is not null, we initialise the value block <br> * in the tree to contain this. <br> * <br> * We return a pointer to the users data in the tree <br> */ <br>LPVOID APIENTRY <br>ctree_update(TREE tree, TREEKEY key, LPVOID value, UINT length) <br>{ <br>        TREEITEM item; <br>        long FAR * pcounter; <br>        LPVOID datacopy; <br> <br>        pcounter = tree_search(tree, key, &amp;item); <br> <br>        if (pcounter == NULL) { <br>                /* element not found - insert a new one <br>                 * the data block for this element should be <br>                 * the user's block with our reference count at <br>                 * the beginning <br>                 */ <br>                pcounter = tree_addafter(tree, &amp;item, key, NULL, <br>                                length + sizeof(long)); <br>                *pcounter = 1; <br>                /* add on size of one long to get the start of the user <br>                 * data <br>                 */ <br>                datacopy = pcounter + 1; <br>                if (value != NULL) { <br>                        memcpy(datacopy, value, length); <br>                } <br>                return(datacopy); <br>        } <br> <br>        /* key was already there - increment reference count and <br>         * return pointer to data <br>         */ <br> <br>        (*pcounter)++; <br> <br>        /* add on size of one long to get the start of the user <br>         * data <br>         */ <br>        datacopy = pcounter + 1; <br>        return(datacopy); <br>} <br> <br>/*************************************************************************** <br> * Function: ctree_getcount <br> * <br> * Purpose: <br> * <br> * Return the reference count for this key  <br> */ <br>long APIENTRY <br>ctree_getcount(TREE tree, TREEKEY key) <br>{ <br>        long FAR * pcounter; <br> <br>        pcounter = tree_find(tree, key); <br>        if (pcounter == NULL) { <br>                return(0); <br>        } <br>        return(*pcounter); <br>} <br> <br>/*************************************************************************** <br> * Function: ctree_find <br> * <br> * Purpose: <br> * <br> * Return a pointer to the user's data block for this key, <br> * or NULL if key not present <br> */ <br>LPVOID APIENTRY <br>ctree_find(TREE tree, TREEKEY key) <br>{ <br>        long FAR * pcounter; <br> <br> <br>        pcounter = tree_find(tree, key); <br>        if (pcounter == NULL) { <br>                return(0); <br>        } <br> <br>        /* increment pointer by size of 1 long to point to <br>         * user's datablock <br>         */ <br>        return(pcounter+1); <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
