<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TSCROLL.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5567"></a>TSCROLL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: TSCROLL.C <br>* <br>* Scrolling and selection routines. <br>* <br>* Functions: <br>* <br>* gtab_msg_vscroll() <br>* gtab_msg_hscroll() <br>* gtab_dovscroll() <br>* gtab_dohscroll() <br>* gtab_linetorow() <br>* gtab_rowtoline() <br>* gtab_select() <br>* gtab_ytoline() <br>* gtab_xtocol() <br>* gtab_isborder() <br>* gtab_enter() <br>* gtab_trackcol() <br>* gtab_press() <br>* gtab_release() <br>* gtab_move() <br>* gtab_dblclick() <br>* gtab_showsel() <br>* gtab_showsel_middle() <br>* gtab_changesel() <br>* gtab_selhome() <br>* gtab_key() <br>* <br>* Comments: <br>* <br>* This implementation currently only supports TM_SINGLE, not TM_MANY <br>* modes of selection. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "gutils.h" <br>#include "table.h" <br>#include "tpriv.h" <br> <br>/*************************************************************************** <br> * Function: gtab_msg_vscroll <br> * <br> * Purpose: <br> * <br> * Handle a vscroll message  <br> */ <br>void <br>gtab_msg_vscroll(HWND hwnd, lpTable ptab, int opcode, int pos) <br>{ <br>        long change; <br> <br>        switch(opcode) { <br>        case SB_THUMBPOSITION: <br>                change = (pos * ptab-&gt;scrollscale) - ptab-&gt;toprow; <br>                break; <br> <br>        case SB_LINEUP: <br>                change = -1; <br>                break; <br> <br>        case SB_LINEDOWN: <br>                change = 1; <br>                break; <br> <br>        case SB_PAGEUP: <br>                change = - (ptab-&gt;nlines - 3); <br>                break; <br> <br>        case SB_PAGEDOWN: <br>                change = (ptab-&gt;nlines - 3); <br>                break; <br> <br>        default: <br>                return; <br>        } <br>        gtab_dovscroll(hwnd, ptab, change); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_msg_hscroll <br> * <br> * Purpose: <br> * <br> * Handle a hscroll message  <br> */ <br>void <br>gtab_msg_hscroll(HWND hwnd, lpTable ptab, int opcode, int pos) <br>{ <br>        int change; <br> <br>        switch(opcode) { <br>        case SB_THUMBPOSITION: <br>                change = pos - ptab-&gt;scroll_dx; <br>                break; <br> <br>        case SB_LINEUP: <br>                change = -(ptab-&gt;avewidth); <br>                break; <br> <br>        case SB_LINEDOWN: <br>                change = ptab-&gt;avewidth; <br>                break; <br> <br>        case SB_PAGEUP: <br>                change = - (ptab-&gt;winwidth * 2 / 3); <br>                break; <br> <br>        case SB_PAGEDOWN: <br>                change = (ptab-&gt;winwidth * 2 / 3); <br>                break; <br> <br>        default: <br>                return; <br>        } <br>        gtab_dohscroll(hwnd, ptab, change); <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: gtab_dovscroll <br> * <br> * Purpose: <br> * <br> * Set new vertical scroll pos, <br> * adjust linedata array <br> * set line win-relative start posns &amp; clip top/bottom posns <br> * revise display. <br> */ <br>void <br>gtab_dovscroll(HWND hwnd, lpTable ptab, long change) <br>{ <br>        int cury, i; <br>        long ncopy; <br>        lpCellPos cp; <br>        LineData ldtemp; <br>        RECT rc, rcpaint; <br>        long range; <br>        long newtop; <br>        int newpos; <br> <br> <br>        range = ptab-&gt;hdr.nrows - (ptab-&gt;nlines - 1); <br>        newtop = ptab-&gt;toprow + change; <br>        if (range &lt; 0) { <br>                range = 0; <br>        } <br>        if (newtop &gt; range) { <br>                change = range - ptab-&gt;toprow; <br>        } else if (newtop &lt; 0) { <br>                change = -(ptab-&gt;toprow); <br>        } <br>        ptab-&gt;toprow += change; <br> <br>        newpos = (int) (newtop / ptab-&gt;scrollscale); <br>        SetScrollPos(hwnd, SB_VERT, newpos, TRUE); <br> <br>        if (ptab-&gt;hdr.sendscroll) { <br>                gtab_sendtq(hwnd, TQ_SCROLL, ptab-&gt;toprow); <br>        } <br> <br>        /* adjust data ptrs rather than invalidate, to retain the <br>         * data we know is still valid <br>         */ <br>        if (abs(change) &gt;= ptab-&gt;nlines) { <br>                gtab_invallines(hwnd, ptab, ptab-&gt;hdr.fixedrows, <br>                        ptab-&gt;nlines - ptab-&gt;hdr.fixedrows); <br>                InvalidateRect(hwnd, NULL, TRUE); <br>                change = 0; <br>        } else if (change &lt; 0) { <br>                /* copy data down */ <br>                ncopy = (ptab-&gt;nlines - ptab-&gt;hdr.fixedrows) - abs(change); <br>                for (i =  ptab-&gt;nlines - 1; <br>                  i &gt;= (ptab-&gt;hdr.fixedrows + abs(change)); i--) { <br>                        ldtemp = ptab-&gt;pdata[i - abs(change)]; <br>                        ptab-&gt;pdata[i - abs(change)] = ptab-&gt;pdata[i]; <br>                        ptab-&gt;pdata[i] = ldtemp; <br>                } <br>                gtab_invallines(hwnd, ptab, <br>                        ptab-&gt;hdr.fixedrows, (int) abs(change)); <br>        } else if (change &gt; 0) { <br>                ncopy = (ptab-&gt;nlines - ptab-&gt;hdr.fixedrows) - change; <br>                for (i = ptab-&gt;hdr.fixedrows; <br>                  i &lt; (ncopy + ptab-&gt;hdr.fixedrows); i++) { <br>                        ldtemp = ptab-&gt;pdata[i + change]; <br>                        ptab-&gt;pdata[i + change] = ptab-&gt;pdata[i]; <br>                        ptab-&gt;pdata[i] = ldtemp; <br>                } <br>                gtab_invallines(hwnd, ptab, <br>                        (int) ncopy + ptab-&gt;hdr.fixedrows, (int) change); <br>        } <br> <br>        /* scroll window */ <br>        GetClientRect(hwnd, &amp;rc); <br>        rcpaint = rc; <br>        if (change &gt; 0) { <br>                rc.top += (int) (change + ptab-&gt;hdr.fixedrows) * ptab-&gt;rowheight; <br>                rcpaint.top = (ptab-&gt;hdr.fixedrows * ptab-&gt;rowheight); <br>                rcpaint.top += rc.bottom - rc.top; <br>        } else if (change &lt; 0) { <br>                rc.top += (ptab-&gt;hdr.fixedrows * ptab-&gt;rowheight); <br>                rc.bottom -= (int) (change * ptab-&gt;rowheight); <br>                rcpaint.bottom -= rc.bottom - rc.top; <br>        } <br> <br>        /* loop through each line setting relative posn and clipping */ <br> <br>        /* set up all rows  - the fixed/moveable difference for <br>         * rows is made at fetch-time during painting, when we remember <br>         * which absolute row nr to ask for, for a given screen line <br>         */ <br>        cury = 0; <br>        for (i = 0; i &lt; ptab-&gt;nlines; i++) { <br>                cp = &amp;ptab-&gt;pdata[i].linepos; <br>                cp-&gt;start = cury; <br>                cp-&gt;clipstart = cury; <br>                cp-&gt;clipend = cury + cp-&gt;size; <br>                cury += cp-&gt;size; <br>        } <br> <br>        /* now move and repaint the window */ <br>        if (change != 0) { <br>                if (rc.top &lt; rc.bottom) { <br>                        ScrollWindow(hwnd, 0, (int) -(change * ptab-&gt;rowheight), <br>                                &amp;rc, NULL); <br> <br>                } <br> <br>                /* force repaint now, not just post message for later, <br>                 * since we want to repaint that line before the next <br>                 * scroll down occurs <br>                 */ <br>                RedrawWindow(hwnd, &amp;rcpaint, NULL, <br>                        RDW_ERASE | RDW_INVALIDATE|RDW_UPDATENOW); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_dohscroll <br> * <br> * Purpose: <br> * <br> * Set new horizontal scroll pos, <br> * set col win-relative start posns &amp; clip left/right posns <br> * revise display. <br> */ <br>void <br>gtab_dohscroll(HWND hwnd, lpTable ptab, long change) <br>{ <br>        int curx, i; <br>        int moveable; <br>        lpCellPos cp; <br>        int newdx, range; <br> <br> <br>        /* check that the new scroll pos is still within the valid range */ <br>        range = ptab-&gt;rowwidth - ptab-&gt;winwidth; <br>        newdx = ptab-&gt;scroll_dx + (int) change; <br>        if (range &lt; 0) { <br>                range = 0; <br>        } <br>        if (newdx &gt; range) { <br>                change = range - ptab-&gt;scroll_dx; <br>        } else if (newdx &lt; 0) { <br>                change = -(ptab-&gt;scroll_dx); <br>        } <br>        ptab-&gt;scroll_dx += (int) change; <br> <br>        SetScrollPos(hwnd, SB_HORZ, ptab-&gt;scroll_dx, TRUE); <br>        InvalidateRect(hwnd, NULL, TRUE); <br>         <br>        /* loop through each col setting relative posn and clipping */ <br>        /* clip off 1 pixel left and right (we added 2 on to size for this) */ <br> <br>        /* first set up fixed columns */ <br>        curx = 0; <br>        for (i = 0; i &lt; ptab-&gt;hdr.fixedcols; i++) { <br>                cp = &amp;ptab-&gt;pcellpos[i]; <br>                cp-&gt;start = curx + 1; <br>                cp-&gt;clipstart = cp-&gt;start; <br>                cp-&gt;clipend = cp-&gt;start + cp-&gt;size - 2; <br>                curx += cp-&gt;size; <br>        } <br> <br>        /* now moveable columns. remember start of moveable cols */ <br>        moveable = curx; <br>        curx = - ptab-&gt;scroll_dx;       /* rel. pos of col */ <br>        for (i = ptab-&gt;hdr.fixedcols; i &lt; ptab-&gt;hdr.ncols; i++) { <br>                cp = &amp;ptab-&gt;pcellpos[i]; <br>                cp-&gt;start = curx + moveable + 1; <br>                cp-&gt;clipstart = max(moveable+1, cp-&gt;start); <br>                cp-&gt;clipend = cp-&gt;start + cp-&gt;size - 2; <br>                curx += cp-&gt;size; <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_linetorow <br> * <br> * Purpose: <br> * <br> * Convert screen line nr to table row nr <br> */ <br>long <br>gtab_linetorow(HWND hwnd, lpTable ptab, int line) <br>{ <br>        if (line &lt; ptab-&gt;hdr.fixedrows) { <br>                return(line); <br>        } <br> <br>        return (line + ptab-&gt;toprow); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_rowtoline <br> * <br> * Purpose: <br> * <br> * Convert table row nr to screen line nr or -1 if not on screen <br> */ <br>int <br>gtab_rowtoline(HWND hwnd, lpTable ptab, long row) <br>{ <br>        if (row &lt; ptab-&gt;hdr.fixedrows) { <br>                return( (int) row); <br>        } <br> <br>        row -= ptab-&gt;toprow; <br>        if ((row &gt;= ptab-&gt;hdr.fixedrows) &amp;&amp; (row &lt; ptab-&gt;nlines)) { <br>                return ( (int) row); <br>        } <br>        return(-1); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_select <br> * <br> * Purpose: <br> * <br> * Replace old selection with new. Notify owner if bNotify. Change <br> * display to reflect new display. <br> */ <br>void <br>gtab_select( <br>        HWND hwnd, <br>        lpTable ptab, <br>        long row, <br>        long col, <br>        long nrows, <br>        long ncells, <br>        BOOL bNotify) <br>{ <br>        int line; <br> <br>        /* if in ROW mode, force col and ncells to reflect the entire row. */ <br>        if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                col = 0; <br>                ncells = ptab-&gt;hdr.ncols; <br>        } <br> <br>        /* clear existing sel if valid and visible */ <br>        if ((ptab-&gt;select.nrows &gt; 0) &amp;&amp; (ptab-&gt;selvisible == TRUE)) { <br> <br>                /* only clear sel if it is different from the new one */ <br>                if ((ptab-&gt;select.startrow != row) || <br>                    (ptab-&gt;select.startcell != col) || <br>                    (ptab-&gt;select.nrows != nrows) || <br>                    (ptab-&gt;select.ncells != ncells)) { <br>                        line = gtab_rowtoline(hwnd, ptab, <br>                                ptab-&gt;select.startrow); <br>                        if (line &gt;= 0) { <br>                                gtab_invertsel(hwnd, ptab, NULL); <br>                        } <br>                        ptab-&gt;selvisible = FALSE; <br>                } <br>        } <br> <br>        /* set select fields and send TQ_SELECT */ <br>        if (row &lt; ptab-&gt;hdr.nrows) { <br>                ptab-&gt;select.startrow = row; <br>                ptab-&gt;select.startcell = col; <br>                ptab-&gt;select.nrows = nrows; <br>                ptab-&gt;select.ncells = ncells; <br>        } else { <br>                ptab-&gt;select.nrows = 0; <br>                ptab-&gt;select.startrow = 0; <br>                ptab-&gt;select.startcell = 0; <br>                ptab-&gt;select.ncells = 0; <br>        } <br> <br>        if (bNotify) { <br>                gtab_sendtq(hwnd, TQ_SELECT, (long) (LPSTR) &amp;ptab-&gt;select); <br>        } <br> <br>        /* paint in selection */ <br>        if (nrows &gt; 0) { <br>                if (!ptab-&gt;selvisible) { <br>                        gtab_invertsel(hwnd, ptab, NULL); <br>                        ptab-&gt;selvisible = TRUE; <br>                } <br>        } else { <br>                if (ptab-&gt;selvisible) { <br>                        gtab_invertsel(hwnd, ptab, NULL); <br>                        ptab-&gt;selvisible = FALSE; <br>                } <br>                ptab-&gt;selvisible = FALSE; <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_ytoline <br> * <br> * Purpose: <br> * <br> * Convert window y co-ord to a line nr <br> */ <br>int <br>gtab_ytoline(HWND hwnd, lpTable ptab, int y) <br>{ <br>        return(y / ptab-&gt;rowheight); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_xtocol <br> * <br> * Purpose: <br> * <br> * Convert window x co-ord to a cell nr <br> */ <br>int <br>gtab_xtocol(HWND hwnd, lpTable ptab, int x) <br>{ <br>        int i; <br>        lpCellPos ppos; <br> <br>        for (i = 0; i &lt; ptab-&gt;hdr.ncols; i++) { <br>                ppos = &amp;ptab-&gt;pcellpos[i]; <br>                if (ppos-&gt;clipstart &lt; ppos-&gt;clipend) { <br>                        if ( (x &gt;= ppos-&gt;clipstart) &amp;&amp; (x &lt; ppos-&gt;clipend)) { <br>                                return(i); <br>                        } <br>                } <br>        } <br>        return(-1); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_isborder <br> * <br> * Purpose: <br> * <br> * Check if x co-ord is 'near' (+- 2 pixels) the right border of given cell <br> */ <br>BOOL <br>gtab_isborder(HWND hwnd, lpTable ptab, int x, int col) <br>{ <br>         <br>        if (abs(ptab-&gt;pcellpos[col].clipend - x) &lt; 2) { <br>                return(TRUE); <br>        } else { <br>                return(FALSE); <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_enter <br> * <br> * Purpose: <br> * <br> * Set selection and send 'TQ_ENTER' event to owner <br> */ <br>void <br>gtab_enter(HWND hwnd, lpTable ptab, long row, long col, long nrows, <br>        long ncells) <br>{ <br>        int line; <br> <br>        /* clear existing sel if valid and visible */ <br>        if ((ptab-&gt;select.nrows &gt; 0) &amp;&amp; (ptab-&gt;selvisible == TRUE)) { <br> <br>                /* only clear sel if it is different from the new one */ <br>                if ((ptab-&gt;select.startrow != row) || <br>                    (ptab-&gt;select.startcell != col) || <br>                    (ptab-&gt;select.nrows != nrows) || <br>                    (ptab-&gt;select.ncells != ncells)) { <br>                        line = gtab_rowtoline(hwnd, ptab, <br>                                ptab-&gt;select.startrow); <br>                        if (line &gt;= 0) { <br>                                gtab_invertsel(hwnd, ptab, NULL); <br>                        } <br>                        ptab-&gt;selvisible = FALSE; <br>                } <br>        } <br> <br>        /* set select fields and send TQ_SELECT */ <br>        if (row &lt; ptab-&gt;hdr.nrows) { <br>                ptab-&gt;select.startrow = row; <br>                ptab-&gt;select.startcell = col; <br>                ptab-&gt;select.nrows = nrows; <br>                ptab-&gt;select.ncells = ncells; <br>        } else { <br>                ptab-&gt;select.nrows = 0; <br>                ptab-&gt;select.startrow = 0; <br>                ptab-&gt;select.startcell = 0; <br>                ptab-&gt;select.ncells = 0; <br>        } <br> <br>        /* paint in selection */ <br>        if (nrows &gt; 0) { <br>                if (!ptab-&gt;selvisible) { <br>                        gtab_invertsel(hwnd, ptab, NULL); <br>                        ptab-&gt;selvisible = TRUE; <br>                } <br>                /* do this at end because it could cause a layout-change */ <br>                gtab_sendtq(hwnd, TQ_ENTER, (long) (LPSTR) &amp;ptab-&gt;select); <br>        } else { <br>                if (ptab-&gt;selvisible) { <br>                        gtab_invertsel(hwnd, ptab, NULL); <br>                } <br>                ptab-&gt;selvisible = FALSE; <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_trackcol <br> * <br> * Purpose: <br> * <br> * Start re-sizing a column <br> */ <br>void <br>gtab_trackcol(HWND hwnd, lpTable ptab, int col, int x) <br>{ <br> <br>        /* ensure we see the mouse-up */ <br>        SetCapture(hwnd); <br>        ptab-&gt;trackmode = TRACK_COLUMN; <br>        ptab-&gt;tracknr = col; <br>        ptab-&gt;trackline1 = x; <br> <br>        /* if line at other side of cell is visible, draw that too */ <br>        if (ptab-&gt;pcellpos[col].start &gt;= ptab-&gt;pcellpos[col].clipstart) { <br>                ptab-&gt;trackline2 = ptab-&gt;pcellpos[col].start; <br>        } else { <br>                ptab-&gt;trackline2 = -1; <br>        } <br>        gtab_drawvertline(hwnd, ptab); <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: gtab_press <br> * <br> * Purpose: <br> * <br> * Called on mouse-down events. decide what to start tracking. <br> */ <br>void <br>gtab_press(HWND hwnd, lpTable ptab, int x, int y) <br>{ <br>        int cell; <br>        long row; <br> <br>        if (ptab-&gt;trackmode != TRACK_NONE) { <br>                return; <br>        } <br> <br>        /* has he grabbed a cell-edge to resize ? */ <br>        cell = gtab_xtocol(hwnd, ptab, x); <br>        if (cell == -1) { <br>                return; <br>        } <br>        if (gtab_isborder(hwnd, ptab, x, cell)) { <br>                gtab_trackcol(hwnd, ptab, cell, x); <br>                return; <br>        } <br>        if ( (cell &gt; 0) &amp;&amp; gtab_isborder(hwnd, ptab, x, cell-1)) { <br>                gtab_trackcol(hwnd, ptab, cell, x); <br>                return; <br>        } <br> <br>        /* find which line he selected */ <br>        row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y)); <br> <br>        /* is he selecting a disabled fixed area ? */ <br>        if ( (row &lt; ptab-&gt;hdr.fixedrows) || (cell &lt; ptab-&gt;hdr.fixedcols)) { <br>                if (ptab-&gt;hdr.fixedselectable == FALSE) { <br>                        return; <br>                } <br>        } <br> <br>        /* ok, start cell selection */ <br>        ptab-&gt;trackmode = TRACK_CELL; <br>        SetCapture(hwnd); <br> <br>        /* record and paint new selection */ <br>        if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                gtab_select(hwnd, ptab, row, 0, 1, ptab-&gt;hdr.ncols, FALSE); <br>        } else { <br>                gtab_select(hwnd, ptab, row, cell, 1, 1, FALSE); <br>        } <br>        return; <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_release <br> * <br> * Purpose: <br> * <br> * Called on mouse-up. complete any tracking that was happening <br> */ <br>void <br>gtab_release(HWND hwnd, lpTable ptab, int x, int y) <br>{ <br>        lpCellPos ppos; <br>        lpProps pprop; <br>        long row; <br>        int cx; <br> <br>        switch(ptab-&gt;trackmode) { <br> <br>        case TRACK_NONE: <br>                return; <br>         <br>        case TRACK_COLUMN: <br>                /* erase marker lines */ <br>                gtab_drawvertline(hwnd, ptab); <br>                ReleaseCapture(); <br>                ptab-&gt;trackmode = TRACK_NONE; <br> <br>                /* adjust cell width */ <br>                ppos = &amp;ptab-&gt;pcellpos[ptab-&gt;tracknr]; <br>                cx = ptab-&gt;trackline1 - ppos-&gt;start; <br>                pprop = &amp;ptab-&gt;pcolhdr[ptab-&gt;tracknr].props; <br>                pprop-&gt;valid |= P_WIDTH; <br>                pprop-&gt;width = cx; <br>                gtab_calcwidths(hwnd, ptab); <br>                gtab_setsize(hwnd, ptab); <br>                InvalidateRect(hwnd, NULL, TRUE); <br>                return; <br> <br>        case TRACK_CELL: <br>                row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y)); <br>                ReleaseCapture(); <br>                ptab-&gt;trackmode = TRACK_NONE; <br> <br>                /* keep the same selection. if the mouse is still <br>                 * in the box, select it, otherwise de-select it <br>                 */ <br>                if ((row == ptab-&gt;select.startrow) &amp;&amp; <br>                  ( (ptab-&gt;hdr.selectmode &amp; TM_ROW) || <br>                    (ptab-&gt;select.startcell == gtab_xtocol(hwnd, ptab, x))) ) { <br> <br>                        gtab_select(hwnd, ptab, ptab-&gt;select.startrow, <br>                                ptab-&gt;select.startcell, <br>                                ptab-&gt;select.nrows, ptab-&gt;select.ncells, TRUE); <br>                } else { <br>                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE); <br>                } <br>                return; <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_move <br> * <br> * Purpose: <br> * <br> * Called on mouse-move. if tracking - adjust position, if not, <br> * set correct cursor <br> */ <br>void <br>gtab_move(HWND hwnd, lpTable ptab, int x, int y) <br>{ <br>        BOOL fOK; <br>        long row; <br>        int col; <br>        lpCellPos ppos; <br> <br>        switch(ptab-&gt;trackmode) { <br> <br>        case TRACK_NONE: <br>                col = gtab_xtocol(hwnd, ptab, x); <br>                if (col == -1) { <br>                        SetCursor(hNormCurs); <br>                        return; <br>                } <br>                if (gtab_isborder(hwnd, ptab, x, col)) { <br>                        SetCursor(hVertCurs); <br>                        return; <br>                } <br>                if ( (col &gt; 0) &amp;&amp; gtab_isborder(hwnd, ptab, x, col-1)) { <br>                        SetCursor(hVertCurs); <br>                        return; <br>                } <br>                SetCursor(hNormCurs); <br>                return; <br> <br>        case TRACK_CELL: <br>                row = gtab_linetorow(hwnd, ptab, gtab_ytoline(hwnd, ptab, y)); <br> <br>                /* keep the same selection. if the mouse is still <br>                 * in the box, select it, otherwise de-select it <br>                 */ <br>                if ((row == ptab-&gt;select.startrow) &amp;&amp; <br>                  ( (ptab-&gt;hdr.selectmode &amp; TM_ROW) || <br>                    (ptab-&gt;select.startcell == gtab_xtocol(hwnd, ptab, x))) ) { <br> <br>                        if (!ptab-&gt;selvisible) { <br>                                gtab_invertsel(hwnd, ptab, NULL); <br>                                ptab-&gt;selvisible = TRUE; <br>                        } <br>                } else { <br>                        if (ptab-&gt;selvisible) { <br>                                gtab_invertsel(hwnd, ptab, NULL); <br>                                ptab-&gt;selvisible = FALSE; <br>                        } <br>                } <br>                return; <br>         <br>        case TRACK_COLUMN: <br>                /* check that new x is still visible/valid */ <br>                ppos = &amp;ptab-&gt;pcellpos[ptab-&gt;tracknr]; <br>                fOK = FALSE; <br> <br>                if (ptab-&gt;tracknr &lt; ptab-&gt;hdr.fixedcols)  { <br>                        if ((x &gt; ppos-&gt;start) &amp;&amp; (x &lt; ptab-&gt;winwidth)) { <br>                                fOK = TRUE; <br>                        } <br>                } else { <br>                        if ((x &gt; ppos-&gt;clipstart) &amp;&amp; (x &lt; ptab-&gt;winwidth)) { <br>                                fOK = TRUE; <br>                        } <br>                } <br>                if (fOK == TRUE) { <br>                        gtab_drawvertline(hwnd, ptab); <br>                        ptab-&gt;trackline1 = x; <br>                        gtab_drawvertline(hwnd, ptab); <br>                } <br>                return; <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_dblclick <br> * <br> * Purpose: <br> * <br> * dbl-click - send an TQ_ENTER event to the owner (if valid)  <br> */ <br>void <br>gtab_dblclick(HWND hwnd, lpTable ptab, int x, int y) <br>{ <br>        int cell, line; <br>        long row; <br> <br>        line = gtab_ytoline(hwnd, ptab, y); <br>        cell = gtab_xtocol(hwnd, ptab, x); <br>        if ( (line &lt; ptab-&gt;hdr.fixedrows) || (cell &lt; ptab-&gt;hdr.fixedcols) ) { <br>                if (!ptab-&gt;hdr.fixedselectable) { <br>                        return; <br>                } <br>        } <br>        row = gtab_linetorow(hwnd, ptab, line); <br> <br>        if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                gtab_enter(hwnd, ptab, row, 0, 1, ptab-&gt;hdr.ncols); <br>        } else { <br>                gtab_enter(hwnd, ptab, row, cell, 1, 1); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_showsel <br> * <br> * Purpose: <br> * <br> * Move selection area to visible part of window. Argument bToBottom <br> * indicates whether to move the line onto the bottom or the top of the <br> * window if not visible - this affects the smoothness of scrolling <br> * line-by-line. <br> */ <br>void <br>gtab_showsel(HWND hwnd, lpTable ptab, BOOL bToBottom) <br>{ <br>        int line; <br>        long change; <br> <br>        line = gtab_rowtoline(hwnd, ptab, ptab-&gt;select.startrow); <br> <br>        /* move up if last line or not at all visible */ <br>        if ( (line &lt; 0) || line == (ptab-&gt;nlines - 1)) { <br>                change = ptab-&gt;select.startrow - ptab-&gt;toprow; <br>                if (bToBottom) { <br>                        /* change to bottom of window. subtract 2 not 1 <br>                         * since nlines includes one line that is only <br>                         * partly visible <br>                         */ <br>                        change -= (ptab-&gt;nlines - 2); <br>                } <br>                change -= ptab-&gt;hdr.fixedrows; <br>                gtab_dovscroll(hwnd, ptab, change); <br>        } <br>        /* add support for TM_CELL here! */ <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_showsel_middle <br> * <br> * Purpose: <br> * <br> * Scroll the window so that if possible, the selected row is in the <br> * middle 60% of the screen so that context around it is visible. <br> */ <br>void <br>gtab_showsel_middle(HWND hwnd, lpTable ptab) <br>{ <br>        int line; <br>        long change; <br>        int mid_top, mid_end; <br> <br>        line = gtab_rowtoline(hwnd, ptab, ptab-&gt;select.startrow); <br> <br> <br>        /* is this within the middle 60 % ?  */ <br>        mid_top = ptab-&gt;nlines * 20 / 100; <br>        mid_end = ptab-&gt;nlines * 80 / 100; <br>        if ((line &lt; mid_top) || (line &gt; mid_end)) { <br> <br>                /* no - scroll so that selected line is at <br>                 * the 20% mark <br>                 */ <br>                change = (ptab-&gt;select.startrow - mid_top) - ptab-&gt;toprow;               <br>                change -= ptab-&gt;hdr.fixedrows; <br>                gtab_dovscroll(hwnd, ptab, change); <br>        } <br>        /* again - need code here for TM_CELL mode to ensure that <br>         * active cell is horizontally scrolled correctly <br>         */ <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: gtab_changesel <br> * <br> * Purpose: <br> * <br> * Move the selection a specified nr of rows or cells <br> * if no selection, select first visible unit <br> */ <br>VOID <br>gtab_changesel(HWND hwnd, lpTable ptab, long rowincr, int cellincr, BOOL bToBottom) <br>{ <br>        long row, col, nrows, ncols; <br> <br>        /* is there a selection ? */ <br>        if (ptab-&gt;select.nrows &lt; 1) { <br> <br>                /* no selection - force a selection <br>                 * at the first visible unit <br>                 */ <br>                if (ptab-&gt;hdr.fixedselectable) { <br>                        row = 0; <br>                        col = 0; <br>                } else { <br>                        row = gtab_linetorow(hwnd, ptab, ptab-&gt;hdr.fixedrows); <br>                        /* should really check for first visible cell */ <br>                        col = ptab-&gt;hdr.fixedcols; <br>                } <br>                nrows = 1; <br>                ncols = 1; <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        col = 0; <br>                        ncols = ptab-&gt;hdr.ncols; <br>                } <br>        } else { <br>                row = ptab-&gt;select.startrow + rowincr; <br>                col = ptab-&gt;select.startcell + cellincr; <br>                while (col &gt;= ptab-&gt;hdr.ncols) { <br>                        col -= ptab-&gt;hdr.ncols; <br>                        row++; <br>                } <br>                while (col &lt; 0) { <br>                        col += ptab-&gt;hdr.ncols; <br>                        row--; <br>                } <br>                if (row &lt; 0) { <br>                        row = 0; <br>                } <br>                if (row &gt;= ptab-&gt;hdr.nrows) { <br>                        row = ptab-&gt;hdr.nrows-1; <br>                } <br>                /* check we haven't moved into non-selectable region */ <br>                if ((row &lt; ptab-&gt;hdr.fixedrows) &amp;&amp; <br>                        (!ptab-&gt;hdr.fixedselectable)) { <br>                                row = ptab-&gt;hdr.fixedrows; <br>                } <br>                nrows = ptab-&gt;select.nrows; <br>                ncols = ptab-&gt;select.ncells; <br>        } <br>        gtab_select(hwnd, ptab, row, col, nrows, ncols, TRUE); <br>        /* ensure selection visible */ <br>        gtab_showsel(hwnd, ptab, bToBottom); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_selhome <br> * </code></pre>
<p>
</p>
<pre><code>* Purpose: <br> * <br> * Set the topmost selectable unit in window as the selection  <br> */ <br>void <br>gtab_selhome(HWND hwnd, lpTable ptab) <br>{ <br>        long row; <br> <br>        if (ptab-&gt;hdr.fixedselectable) { <br>                row = gtab_linetorow(hwnd, ptab, 0); <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        gtab_select(hwnd, ptab, row, 0, 1, <br>                                ptab-&gt;hdr.ncols, TRUE); <br>                } else { <br>                        gtab_select(hwnd, ptab, row, 0, 1, 1, TRUE); <br>                } <br>        } else { <br>                row = gtab_linetorow(hwnd, ptab, ptab-&gt;hdr.fixedrows); <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        gtab_select(hwnd, ptab, row, 0, 1, <br>                                ptab-&gt;hdr.ncols, TRUE); <br>                } else { <br>                        gtab_select(hwnd, ptab, row, <br>                                ptab-&gt;hdr.fixedcols, 1, 1, TRUE); <br>                } <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_key <br> * <br> * Purpose: <br> * <br> * Handle key-down events - scroll windows and/or move selection  <br> */ <br>int <br>gtab_key(HWND hwnd, lpTable ptab, int vkey) <br>{ <br>        long row; <br>        BOOL bControl = FALSE; <br> <br>        if (GetKeyState(VK_CONTROL) &amp; 0x8000) { <br>                bControl = TRUE; <br>        } <br> <br>        switch(vkey) { <br> <br>        case VK_UP: <br>                if (bControl) { <br>                        /* control-uparrow scrolls window without selection. <br>                         * the selection is de-selected (to avoid surprises <br>                         * moving back to it). <br>                         */ <br>                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE); <br>                        gtab_dovscroll(hwnd, ptab, -1); <br>                } else { <br>                        /* uparrow moves selection up one line */ <br>                        gtab_changesel(hwnd, ptab, -1, 0, FALSE); <br>                } <br>                return(0); <br> <br>        case VK_DOWN: <br>                if (bControl) { <br>                        /* control downarrow scrolls window without <br>                         * a selection. <br>                         */ <br>                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE); <br>                        gtab_dovscroll(hwnd, ptab, 1); <br>                } else { <br>                        /* the normal gtab_changesel behaviour is <br>                         * that if the selected line is not visible now, <br>                         * we scroll it to the top of the window. This is fine <br>                         * in most cases but causes unacceptable jumps when <br>                         * repeatedly scrolling down with the down key. <br>                         * <br>                         * Thus we now have an argument to changesel to say <br>                         * that in this case, if you need to move the line onto <br>                         * the window, move it to the bottom and not the top <br>                         */ <br>                        gtab_changesel(hwnd, ptab, 1, 0, TRUE); <br>                } <br>                return(0); <br> <br>        case VK_LEFT: <br>                /* if cell-selection mode, move left one cell. <br>                 * otherwise the whole row is selected - scroll <br>                 * the line left a little <br>                 */ <br> <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        if (bControl) { <br>                                /* ctrl-left moves to start of line */ <br>                                gtab_dohscroll(hwnd, ptab, -(ptab-&gt;scroll_dx)); <br>                        } else { <br>                                gtab_dohscroll(hwnd, ptab, -(ptab-&gt;avewidth)); <br>                        } <br>                } else { <br>                        gtab_changesel(hwnd, ptab, 0, -1, FALSE); <br>                } <br>                return(0); <br> <br>        case VK_RIGHT: <br>                /* if cell-selection mode, move right one cell. <br>                 * otherwise the whole row is selected - scroll <br>                 * the line right a little <br>                 */ <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        if (bControl) { <br>                                /* control-right moves to right end of line */ <br>                                gtab_dohscroll(hwnd, ptab, ptab-&gt;rowwidth - <br>                                                ptab-&gt;winwidth); <br>                        } else { <br>                                gtab_dohscroll(hwnd, ptab, ptab-&gt;avewidth); <br>                        } <br>                } else { <br>                        gtab_changesel(hwnd, ptab, 0, 1, TRUE); <br>                } <br>                return(0); <br> <br>        case VK_HOME: <br>                if (bControl) { <br>                        /* control-home == top of file */ <br>                        gtab_dovscroll(hwnd, ptab, -(ptab-&gt;toprow)); <br>                } <br>                /* top of window */ <br>                gtab_selhome(hwnd, ptab); <br>                gtab_showsel(hwnd, ptab, FALSE); <br>                 <br>                return(0); <br> <br>        case VK_END: <br>                if (bControl) { <br>                        /* control-end -&gt; end of file */ <br>                        row = ptab-&gt;hdr.nrows-1; <br>                } else { <br>                        row = gtab_linetorow(hwnd, ptab, ptab-&gt;nlines - 1); <br>                        if (row &gt;= ptab-&gt;hdr.nrows) { <br>                                row = ptab-&gt;hdr.nrows-1; <br>                        } <br>                } <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        gtab_select(hwnd, ptab, row, 0, 1, <br>                                ptab-&gt;hdr.ncols, TRUE); <br>                } else { <br>                        gtab_select(hwnd, ptab, row, <br>                                ptab-&gt;hdr.ncols-1, 1, 1, TRUE); <br>                } <br>                /* we have selected the bottom line. We don't want to <br>                 * move it up into the window, since the intended <br>                 * effect is to select the lowest line. This doesn't <br>                 * apply to the ctrl-end behaviour (move to bottom of <br>                 * buffer. <br>                 */ <br>                if (bControl) { <br>                        /* move the selection to make it visible - but move it <br>                         * to the bottom and not to the top of the window <br>                         */ <br>                        gtab_showsel(hwnd, ptab, TRUE); <br>                } <br>                return(0); <br> <br>        case VK_RETURN: <br>                if (ptab-&gt;select.nrows &gt; 0) { <br>                        gtab_showsel(hwnd, ptab, FALSE); <br>                        gtab_enter(hwnd, ptab, ptab-&gt;select.startrow, <br>                                ptab-&gt;select.startcell, <br>                                ptab-&gt;select.nrows, ptab-&gt;select.ncells); <br>                } <br>                return(0); <br> <br>        case VK_SPACE: <br>                /* toggle the selection */ <br>                if (ptab-&gt;select.nrows &lt; 1) { <br>                        /* no selection - make one */ <br>                        gtab_changesel(hwnd, ptab, 0, 0, TRUE); <br>                } else { <br>                        /* there is a selection - deselect it */ <br>                        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE); <br>                } <br>                return(0); <br> <br>        case VK_PRIOR:          /* page up */ <br> <br>                gtab_dovscroll(hwnd, ptab, -(ptab-&gt;nlines - 3)); <br>                gtab_selhome(hwnd, ptab); <br>                return(0); <br> <br>        case VK_NEXT:           /* page down */ <br> <br>                /* scroll down one page */ <br>                gtab_dovscroll(hwnd, ptab, (ptab-&gt;nlines - 3)); <br> <br>                /* select new bottom line */ <br>                row = gtab_linetorow(hwnd, ptab, ptab-&gt;nlines - 1); <br>                if (row &gt;= ptab-&gt;hdr.nrows) { <br>                        row = ptab-&gt;hdr.nrows-1; <br>                } <br>                /* select bottom line, but don't call showsel <br>                 * since we don't want to adjust it's position - we <br>                 * want it to remain at the bottom of the window <br>                 */ <br>                if (ptab-&gt;hdr.selectmode &amp; TM_ROW) { <br>                        gtab_select(hwnd, ptab, row, 0, 1, <br>                                ptab-&gt;hdr.ncols, TRUE); <br>                } else { <br>                        gtab_select(hwnd, ptab, row, <br>                                ptab-&gt;hdr.ncols-1, 1, 1, TRUE); <br>                } <br> <br>                return(0); <br> <br>        default: <br>                return(1); <br>        } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
