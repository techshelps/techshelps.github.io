<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5549"></a>LINE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: LINE.C <br>* <br>* Functions that handle lines of text to be output. <br>* <br>* Functions: <br>* <br>* line_new() <br>* line_delete() <br>* line_reset() <br>* line_gettext() <br>* line_gettabbedlength() <br>* line_getlink() <br>* line_getlinenr() <br>* line_compare() <br>* line_link() <br>* line_isblank() <br>* <br>* Comments: <br>* <br>* LINE is a data type representing a string of ascii text along with  <br>* a line number. <br>* <br>* A LINE can compare itself to another line, and maintain a link if the <br>* lines are similar.  <br>* <br>* Comparisons between lines take note of the global option flag <br>* ignore_blanks, defined elsewhere. If this is true, we ignore <br>* differences in spaces and tabs when comparing lines, and when <br>* generating hashcodes. <br>* <br>* Links and are only generated once. To clear the link call line_reset. <br>* <br>* Lines can be allocated on a list. If a null list handle is passed, the <br>* line will be allocated using gmem_get() from the hHeap defined and <br>* initialised elsewhere. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "gutils.h" <br>#include "windiff.h"    /* defines hHeap and ignore_blanks */ <br>#include "list.h" <br>#include "line.h" <br> <br>struct fileline { <br> <br>        UINT flags;     /* see below */ <br> <br>        LPSTR text;     /* null-terminated copy of line text */ <br>        DWORD hash;     /* hashcode for line */ <br>        LINE link;      /* handle for linked line */ <br>        UINT linenr;    /* line number (any arbitrary value) */ <br>}; <br> <br>/* flag values (or-ed) */ <br>#define LF_DISCARD      1       /* if true, alloced from gmem heap */ <br>#define LF_HASHVALID    2       /* if true, hashcode need not be recalced */ <br> <br> <br>/*************************************************************************** <br> * Function: line_new <br> * <br> * Purpose: <br> * <br> * Creates a new line and makes a copy of the text. <br> * <br> * If the list is non-null, allocate on the list. If null, alloc from <br> * gmem_get. <br> * <br> ***************************************************************************/ <br>LINE <br>line_new(LPSTR text, int linelength, UINT linenr, LIST list) <br>{ <br>        LINE line; <br> <br>        /* alloc a line. from the list if there is a list */ <br>        if (list) { <br>                line = List_NewLast(list, sizeof(struct fileline)); <br>                if (line == NULL) { <br>                        return(NULL); <br>                } <br>                line-&gt;flags = 0; <br>        } else { <br>                line = (LINE) gmem_get(hHeap, sizeof(struct fileline)); <br>                if (line == NULL) { <br>                        return(NULL); <br>                } <br>                line-&gt;flags = LF_DISCARD; <br>        } <br> <br>        /* alloc space for the text. remember the null character */ <br>        line-&gt;text = gmem_get(hHeap, linelength + 1); <br>        strncpy(line-&gt;text, text, linelength); <br>        line-&gt;text[linelength] = '\0'; <br> <br>        line-&gt;link = NULL; <br>        line-&gt;linenr = linenr; <br> <br>        return(line); <br>} <br> <br>/*************************************************************************** <br> * Function: line_delete <br> * <br> * Purpose: <br> * <br> * Deletes a line and frees up all associated memory and if the line <br> * was not alloc-ed from a list, frees up the line struct itself <br> * <br> ***************************************************************************/ <br>void <br>line_delete(LINE line) <br>{ <br>        if (line == NULL) { <br>                return; <br>        } <br> <br>        /* free up text space */ <br>        gmem_free(hHeap, line-&gt;text, lstrlen(line-&gt;text)+1); <br> <br>        /* free up line itself only if not on list */ <br>        if (line-&gt;flags &amp; LF_DISCARD) { <br>                gmem_free(hHeap, (LPSTR) line, sizeof(struct fileline)); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: line_reset <br> * <br> * Purpose: <br> * <br> * Clears the link and force recalc of the hash code. <br> * <br> ***************************************************************************/ <br>void <br>line_reset(LINE line) <br>{ <br>        if (line == NULL) { <br>                return; <br>        } <br> <br>        line-&gt;link = NULL; <br> <br>        line-&gt;flags &amp;= ~LF_HASHVALID; <br>} <br> <br> <br>/*************************************************************************** <br> * Function: line_gettext <br> * <br> * Purpose: <br> * <br> * Returns a pointer to the line text <br> * <br> ***************************************************************************/ <br>LPSTR <br>line_gettext(LINE line) <br>{ <br>        if (line == NULL) { <br>                return(NULL); <br>        } <br> <br>        return (line-&gt;text); <br>} <br> <br>/*************************************************************************** <br> * Function: line_gettabbedlength <br> * <br> * Purpose: <br> * <br> * Returns the length of line in characters, expanding tabs.  <br> * <br> ***************************************************************************/ <br>int <br>line_gettabbedlength(LINE line, int tabstops) <br>{ <br>        int length; <br>        LPSTR chp; <br> <br>        if (line == NULL) { <br>                return(0); <br>        } <br> <br>        for (length = 0, chp = line-&gt;text; *chp != '\0'; chp++) { <br>                if (*chp == '\t') { <br>                         length = (length + tabstops) / tabstops * tabstops; <br>                } else { <br>                        length++; <br>                } <br>        } <br>        return(length); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: line_gethashcode <br> * <br> * Purpose: <br> * <br> * Returns the hashcode for this line  <br> * <br> ***************************************************************************/ <br>DWORD <br>line_gethashcode(LINE line) <br>{ <br>        if (line == NULL) { <br>                return(0); <br>        } <br> <br>        if (! (line-&gt;flags &amp; LF_HASHVALID)) { <br> <br> <br>                /* hashcode needs to be recalced */ <br>                line-&gt;hash = hash_string(line-&gt;text, ignore_blanks); <br>                line-&gt;flags |= LF_HASHVALID; <br>        } <br>        return (line-&gt;hash); <br>} <br> <br>/*************************************************************************** <br> * Function: line_getlink <br> * <br> * Purpose: <br> * <br> * Returns the handle for the line that is linked to this line (the <br> * result of a successful line_link() operation). This line is <br> * identical in text to the linked line (allowing for ignore_blanks). <br> * <br> ***************************************************************************/ <br>LINE <br>line_getlink(LINE line) <br>{ <br>        if (line == NULL) { <br>                return(NULL); <br>        } <br> <br>        return(line-&gt;link); <br>} <br> <br>/*************************************************************************** <br> * Function: line_getlinenr <br> * <br> * Purpose: <br> * <br> * Returns the line number associated with this line  <br> * <br> ***************************************************************************/ <br>UINT <br>line_getlinenr(LINE line) <br>{ <br>        if (line == NULL) { <br>                return(0); <br>        } <br> <br>        return(line-&gt;linenr); <br>} <br> <br>/*************************************************************************** <br> * Function: line_compare <br> * <br> * Purpose: <br> * <br> * Compares two lines and returns TRUE if they are the same. <br> * <br> ***************************************************************************/ <br>BOOL <br>line_compare(LINE line1, LINE line2) <br>{ <br>        LPSTR p1, p2; <br> <br>        /* Assert: At least one of them is not null ??? */ <br> <br>        if ((line1 == NULL) || (line2 == NULL)) { <br>                /* null line handles do not compare */ <br>                return(FALSE); <br>        } <br> <br>        /* check that the hashcodes match */ <br>        if (line_gethashcode(line1) != line_gethashcode(line2)) { <br>                return(FALSE); <br>        } <br> <br>        /* hashcodes match - are the lines really the same ? */ <br>        /* note that this is coupled to gutils\utils.c in definition of blank */ <br>        p1 = line_gettext(line1); <br>        p2 = line_gettext(line2); <br> <br>// Japanese friendy <br>        do { <br>                if (ignore_blanks) { <br>                        while ( (*p1 == ' ') || (*p1 == '\t')) { <br>                                p1 = CharNext(p1); <br>                        } <br>                        while ( (*p2 == ' ') || (*p2 == '\t')) { <br>                                p2 = CharNext(p2); <br>                        } <br>                } <br>                if (IsDBCSLeadByte(*p1) &amp;&amp; *(p1+1) != '\0' <br>                &amp;&amp;  IsDBCSLeadByte(*p2) &amp;&amp; *(p2+1) != '\0') { <br>                        if (*p1 != *p2 || *(p1+1) != *(p2+1)) { <br>                                return(FALSE); <br>                        } <br>                        p1 += 2; <br>                        p2 += 2; <br>                } else { <br>                        if (*p1 != *p2) { <br>                                return(FALSE); <br>                        } <br>                        p1++; <br>                        p2++; <br>                } <br>        } while ( (*p1 != '\0') &amp;&amp; (*p2 != '\0')); <br> <br>        return(TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: line_link <br> * <br> * Purpose: <br> * <br> * Attempts to link two lines and returns TRUE if succesful. <br> * <br> * This will fail if either line is NULL, or already linked, or if <br> * they differ. <br> * <br> ***************************************************************************/ <br>BOOL <br>line_link(LINE line1, LINE line2) <br>{ <br>        if ( (line1 == NULL) || (line2 == NULL)) { <br>                return(FALSE); <br>        } <br> <br>        if ( (line1-&gt;link != NULL) || (line2-&gt;link != NULL)) { <br>                return(FALSE); <br>        } <br> <br>        if (line_compare(line1, line2)) { <br>                line1-&gt;link = line2; <br>                line2-&gt;link = line1; <br>                return(TRUE); <br>        } else { <br>                return(FALSE); <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: line_isblank <br> * <br> * Purpose: <br> * <br> * Returns TRUE iff line is blank.  NULL =&gt; return FALSE  <br> * <br> ***************************************************************************/ <br>BOOL line_isblank(LINE line) <br>{ <br>        return line!=NULL &amp;&amp; utils_isblank(line-&gt;text); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
