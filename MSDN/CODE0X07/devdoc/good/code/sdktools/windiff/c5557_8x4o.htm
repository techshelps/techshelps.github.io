<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5568"></a>UTILS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: UTILS.C <br>* <br>* standard file-reading utilities. <br>* <br>* Functions: <br>* <br>* readfile_new() <br>* readfile_next() <br>* readfile_delete() <br>* utils_CompPath() <br>* has_string() <br>* utils_isblank() <br>* StringInput() <br>* dodlg_stringin() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "gutils.h" <br>#include "gutilsrc.h" <br> <br> <br>/* <br> * we need an instance handle. this should be the dll instance <br> */ <br>extern HANDLE hLibInst; <br> <br> <br> <br>/* <br> * -- forward declaration of procedures ----------------------------------- <br> */ <br>int FAR PASCAL dodlg_stringin(HWND hDlg, UINT message, UINT wParam, LONG lParam); <br> <br> <br> <br> <br>/*-- readfile: buffered line input ------------------------------*/ <br> <br>/* <br> * set of functions to read a line at a time from a file, using <br> * a buffer to read a block at a time from the file <br> * <br> */ <br> <br>/* <br> * a FILEBUFFER handle is a pointer to a struct filebuffer <br> */ <br>struct filebuffer { <br>        int fh;         /* open file handle */ <br>        PSTR start;     /* offset within buffer of next character */ <br>        PSTR last;      /* offset within buffer of last valid char read in */ <br> <br>        char buffer[512]; <br>}; <br> <br>/*************************************************************************** <br> * Function: readfile_new <br> * <br> * Purpose: <br> * <br> * Initialise a filebuffer and return a handle to it <br> */ <br>FILEBUFFER APIENTRY <br>readfile_new(int fh) <br>{ <br>        FILEBUFFER fbuf; <br> <br>        fbuf = (FILEBUFFER) LocalLock(LocalAlloc(LHND, sizeof(struct filebuffer))); <br>        if (fbuf == NULL) { <br>                return(NULL); <br>        } <br> <br>        fbuf-&gt;fh = fh; <br>        fbuf-&gt;start = fbuf-&gt;buffer; <br>        fbuf-&gt;last = fbuf-&gt;buffer; <br>        /* return file pointer to beginning of file */ <br>        _llseek(fh, 0, 0); <br> <br>        return(fbuf); <br>} <br> <br>/*************************************************************************** <br> * Function: readfile_next <br> * <br> * Purpose: <br> * <br> * Get the next line from a file. Returns a pointer to the line <br> * in the buffer - so copy it before changing it. <br> * <br> * The line is *not* null-terminated. *plen is set to the length of the <br> * line. <br> */ <br>LPSTR APIENTRY <br>readfile_next(FILEBUFFER fbuf, int FAR * plen) <br>{ <br>        PSTR cstart; <br> <br>        /* look for an end of line in the buffer we have*/ <br>        for (cstart = fbuf-&gt;start; cstart &lt; fbuf-&gt;last; cstart++) { <br> <br>                if (*cstart == '\n') { <br>                        *plen = (cstart - fbuf-&gt;start) + 1; <br>                        cstart = fbuf-&gt;start; <br>                        fbuf-&gt;start += *plen; <br>                        return(cstart); <br>                } <br> <br>        } <br> <br>        /* no cr in this buffer - this buffer contains a partial line. <br>         * copy the partial up to the beginning of the buffer, and <br>         * adjust the pointers to reflect this move <br>         */ <br>        Old_strncpy(fbuf-&gt;buffer, fbuf-&gt;start, fbuf-&gt;last - fbuf-&gt;start); <br>        fbuf-&gt;last = &amp;fbuf-&gt;buffer[fbuf-&gt;last - fbuf-&gt;start]; <br>        fbuf-&gt;start = fbuf-&gt;buffer; <br> <br>        /* read in to fill the block */ <br>        fbuf-&gt;last += _lread(fbuf-&gt;fh, fbuf-&gt;last, <br>                        &amp;fbuf-&gt;buffer[sizeof(fbuf-&gt;buffer)] - fbuf-&gt;last); <br> <br>        /* look for an end of line in the newly filled buffer */ <br>        for (cstart = fbuf-&gt;start; cstart &lt; fbuf-&gt;last; cstart++) { <br> <br>                if (*cstart == '\n') { <br>                        *plen = (cstart - fbuf-&gt;start) + 1; <br>                        cstart = fbuf-&gt;start; <br>                        fbuf-&gt;start += *plen; <br>                        return(cstart); <br>                } <br>        } <br> <br> <br>        /* still no end of line. either the buffer is empty - <br>         * because of end of file - or the line is longer than <br>         * the buffer. in either case, return all that we have <br>         */ <br>        *plen = fbuf-&gt;last - fbuf-&gt;start; <br>        { // for JAPAN (nChars != nBytes) <br>            PSTR ptr; <br>            for(ptr=fbuf-&gt;start;ptr&lt;fbuf-&gt;last;ptr++) ; <br>            if(ptr!=fbuf-&gt;last &amp;&amp; *plen) { <br>                --(*plen); <br>                --(fbuf-&gt;last); <br>                _llseek(fbuf-&gt;fh,-1,1); <br>            } <br>        } <br>        cstart = fbuf-&gt;start; <br>        fbuf-&gt;start += *plen; <br>        if (*plen == 0) { <br>                return(NULL); <br>        } else { <br>                return(cstart); <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: readfile_delete <br> * <br> * Purpose: <br> * <br> * Delete a FILEBUFFER - close the file handle and free the buffer <br> */ <br>void APIENTRY <br>readfile_delete(FILEBUFFER fbuf) <br>{ <br>        _lclose(fbuf-&gt;fh); <br> <br>        LocalUnlock(LocalHandle( (PSTR) fbuf)); <br>        LocalFree(LocalHandle( (PSTR) fbuf)); <br>} <br> <br> <br>/* ----------- things for strings-------------------------------------*/ <br> <br> <br>/* <br> * Compare two pathnames, and if not equal, decide which should come first. <br> * Both path names should be lower cased by AnsiLowerBuff before calling. <br> * <br> * Returns 0 if the same, -1 if left is first, and +1 if right is first. <br> * <br> * The comparison is such that all filenames in a directory come before any <br> * file in a subdirectory of that directory. <br> * <br> * Given direct\thisfile v. direct\subdir\thatfile, we take <br> * thisfile &lt; thatfile   even though it is second alphabetically. <br> * We do this by picking out the shorter path <br> * (fewer path elements), and comparing them up till the last element of that <br> * path (in the example: compare the 'dir\' in both cases.) <br> * If they are the same, then the name with more path elements is <br> * in a subdirectory, and should come second. <br> * <br> * We have had trouble with apparently multiple collating sequences and <br> * the position of \ in the sequence.  To eliminate this trouble <br> * a. EVERYTHING is mapped to lower case first (actually this is done <br> *    before calling this routine). <br> * b. All comparison is done by using lstrcmpi with two special cases. <br> *    1. Subdirs come after parents as noted above <br> *    2. \ must compare low so that fred2\x &gt; fred\x in the same way <br> *       that fred2 &lt; fred.  Unfortunately in ANSI '2' &lt; '\\' <br> * <br> */ <br>int APIENTRY <br>utils_CompPath(LPSTR left, LPSTR right) <br>{ <br>        int compval;            // provisional value of comparison <br> <br>        if (left==NULL) return -1;        // empty is less than anything else <br>        else if (right==NULL) return 1;  // anything is greater than empty <br> <br>        for (; ; ) { <br>                if (*left=='\0' &amp;&amp; *right=='\0') return 0; <br>                if (*left=='\0')  return -1; <br>                if (*right=='\0')  return 1; <br>                if (IsDBCSLeadByte(*left) || IsDBCSLeadByte(*right)) { <br>                        if (*right != *left) { <br>                                compval = (*left - *right); <br>                                break; <br>                        } <br>                        ++left; <br>                        ++right; <br>                        if (*right != *left) { <br>                                compval = (*left - *right); <br>                                break; <br>                        } <br>                        ++left; <br>                        ++right; <br>                } else { <br>                if (*right==*left)  {++left; ++right; continue;} <br>                if (*left=='\\') {compval = -1; break;} <br>                if (*right=='\\') {compval = 1; break;} <br>                compval = (*left - *right); <br>                break; <br>                } <br>        } <br> <br>        /* We have detected a difference.  If the rest of one <br>           of the strings (including the current character) contains <br>           some \ characters, but the other one does not, then all <br>           elements up to the last element of the one with the fewer <br>           elements are equal and so the other one lies in a subdir <br>           and so compares greater i.e. x\y\f &gt; x\f <br>           Otherwise compval tells the truth. <br>        */ <br> <br>        left = strchr(left, '\\'); <br>        right = strchr(right, '\\'); <br>        if (left &amp;&amp; !right) return 1; <br>        if (right &amp;&amp; !left) return -1; <br> <br>        return compval; <br> <br>} /* utils_CompPath */ <br> <br> <br>/*************************************************************************** <br> * Function: hash_string <br> * <br> * Purpose: <br> * <br> * Generate a hashcode for a null-terminated ascii string. <br> * <br> * If bIgnoreBlanks is set, then ignore all spaces and tabs in calculating <br> * the hashcode. <br> * <br> * Multiply each character by a function of its position and sum these. <br> * The function chosen is to multiply the position by successive <br> * powers of a large number. <br> * The large multiple ensures that anagrams generate different hash <br> * codes. <br> */ <br>DWORD APIENTRY <br>hash_string(LPSTR string, BOOL bIgnoreBlanks) <br>{ <br>#define LARGENUMBER     6293815 <br> <br>        DWORD sum = 0; <br>        DWORD multiple = LARGENUMBER; <br>        int index = 1; <br> <br>        while (*string != '\0') { <br> <br>                if (bIgnoreBlanks) { <br>                        while ( (*string == ' ') || (*string == '\t')) { <br>                                string = CharNext(string); <br>                        } <br>                } <br> <br>                sum += multiple * index++ * (*string++); <br>                multiple *= LARGENUMBER; <br>        } <br>        return(sum); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: utils_isblank <br> * <br> * Purpose: <br> * <br> * Return TRUE iff the string is blank.  Blank means the same as <br> * the characters which are ignored in hash_string when ignore_blanks is set <br> */ <br>BOOL APIENTRY <br>utils_isblank(LPSTR string) <br>{ <br>        while ( (*string == ' ') || (*string == '\t')) { <br>                string = CharNext(string); <br>        } <br> <br>        /* having skipped all the blanks, do we see the end delimiter? */ <br>        return (*string == '\0' || *string == '\r' || *string == '\n'); <br>} <br> <br> <br> <br>/* --- simple string input -------------------------------------- */ <br> <br>/* <br> * static variables for communication between function and dialog <br> */ <br>LPSTR dlg_result; <br>int dlg_size; <br>LPSTR dlg_prompt, dlg_default, dlg_caption; <br> <br>/*************************************************************************** <br> * Function: StringInput <br> * <br> * Purpose: <br> * <br> * Input of a single text string, using a simple dialog. <br> * <br> * Returns TRUE if ok, or FALSE if error or user canceled. If TRUE, <br> * puts the string entered into result (up to resultsize characters). <br> * <br> * Prompt is used as the prompt string, caption as the dialog caption and <br> * default as the default input. All of these can be null. <br> */ <br> <br>int APIENTRY <br>StringInput(LPSTR result, int resultsize, LPSTR prompt, LPSTR caption, <br>                LPSTR def_input) <br>{ <br>        DLGPROC lpProc; <br>        BOOL fOK; <br> <br>        /* copy args to static variable so that winproc can see them */ <br> <br>        dlg_result = result; <br>        dlg_size = resultsize; <br>        dlg_prompt = prompt; <br>        dlg_caption = caption; <br>        dlg_default = def_input; <br> <br>        lpProc = (DLGPROC)MakeProcInstance((WNDPROC)dodlg_stringin, hLibInst); <br>        fOK = DialogBox(hLibInst, "StringInput", GetFocus(), lpProc); <br>        FreeProcInstance((WNDPROC)lpProc); <br> <br>        return(fOK); <br>} <br> <br>/*************************************************************************** <br> * Function: dodlg_stringin <br> * <br> */ <br>int FAR PASCAL <br>dodlg_stringin(HWND hDlg, UINT message, UINT wParam, LONG lParam) <br>{ <br>        switch(message) { <br> <br>        case WM_INITDIALOG: <br>                if (dlg_caption != NULL) { <br>                        SendMessage(hDlg, WM_SETTEXT, 0, (LONG) dlg_caption); <br>                } <br>                if (dlg_prompt != NULL) { <br>                        SetDlgItemText(hDlg, IDD_LABEL, dlg_prompt); <br>                } <br>                if (dlg_default) { <br>                        SetDlgItemText(hDlg, IDD_FILE, dlg_default); <br>                } <br>                return(TRUE); <br> <br>        case WM_COMMAND: <br>                switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br> <br>                case IDCANCEL: <br>                        EndDialog(hDlg, FALSE); <br>                        return(TRUE); <br> <br>                case IDOK: <br>                        GetDlgItemText(hDlg, IDD_FILE, dlg_result, dlg_size); <br>                        EndDialog(hDlg, TRUE); <br>                        return(TRUE); <br>                } <br>        } <br>        return (FALSE); <br>} <br> <br>/*************************************************************************** <br> * Function: My_mbschr <br> * <br> * Purpose: <br> * <br> * DBCS version of strchr <br> * <br> */ <br>unsigned char * _CRTAPI1 My_mbschr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    return *psz == uiSep ? psz : NULL; <br>} <br>/*************************************************************************** <br> * Function: My_mbsncpy <br> * <br> * Purpose: <br> * <br> * DBCS version of strncpy <br> * <br> */ <br>unsigned char * _CRTAPI1 My_mbsncpy( <br>unsigned char *psz1, const unsigned char *psz2, size_t Length) <br>{ <br>        int nLen = (int)Length; <br>unsigned char *pszSv = psz1; <br> <br>while (0 &lt; nLen) { <br>if (*psz2 == '\0') { <br>*psz1++ = '\0'; <br>nLen--; <br>} else if (IsDBCSLeadByte(*psz2)) { <br>if (nLen == 1) { <br>*psz1 = '\0'; <br>} else { <br>*psz1++ = *psz2++; <br>*psz1++ = *psz2++; <br>} <br>nLen -= 2; <br>} else { <br>*psz1++ = *psz2++; <br>nLen--; <br>} <br>} <br>return pszSv; <br>} <br> <br>/*************************************************************************** <br> * Function: LoadRcString <br> * <br> * Purpose: Loads a resource string from string table and returns a pointer <br> *          to the string. <br> * <br> * Parameters: wID - resource string id <br> * <br> */ <br>LPTSTR APIENTRY LoadRcString(UINT wID) <br>{ <br>    static TCHAR szBuf[512]; <br> <br>    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf)); <br>    return szBuf; <br>} <br> <br>LPTSTR APIENTRY LoadRcString2(UINT wID) <br>{ <br>    static TCHAR szBuf[512]; <br> <br>    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf)); <br>    return szBuf; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
