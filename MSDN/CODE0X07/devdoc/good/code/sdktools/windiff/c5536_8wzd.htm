<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPLIST.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5539"></a>COMPLIST.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: COMPLIST.C <br>* <br>* Supports a list of compitems, where each compitem represents <br>* a pair of matching files, or an unmatched file. <br>* <br>* Functions: <br>* <br>* complist_filedialog() <br>* complist_dirdialog() <br>* complist_args() <br>* complist_getitems() <br>* complist_delete() <br>* complist_savelist() <br>* complist_copyfiles() <br>* complist_dodlg_savelist() <br>* complist_dodlg_copyfiles() <br>* complist_match() <br>* complist_new() <br>* complist_dodlg_dir() <br>* <br>* Comments: <br>* <br>* We build lists of filenames from two pathnames (using the <br>* scandir module) and then traverse the two lists comparing names. <br>* Where the names match, we create a CompItem from the matching <br>* names. Where there is an unmatched name, we create a compitem for it. <br>* <br>* We may also be asked to create a complist for two individual files: <br>* here we create a single compitem for them as a matched pair even if <br>* the names don't match. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;dos.h&gt; <br>#include &lt;direct.h&gt; <br> <br>#include "gutils.h" <br>#include "state.h" <br>#include "windiff.h" <br>#include "wdiffrc.h" <br>#include "list.h" <br>#include "line.h" <br>#include "scandir.h" <br>#include "file.h" <br>#include "section.h" <br>#include "compitem.h" <br>#include "complist.h" <br>#include "view.h" <br> <br> <br>extern BOOL bAbort;             /* defined in windiff.c  Read only here */ <br> <br>/* <br> * The COMPLIST handle is typedef-ed to be a pointer to one <br> * of these struct complist <br> */ <br>struct complist { <br>        DIRLIST left;           /* left list of files */ <br>        DIRLIST right;          /* right list of files */ <br>        LIST items;             /* list of COMPITEMs */ <br>}; <br> <br>/* ---- module-wide data -------------------------------------*/ <br> <br>/* data for communicating between the SaveList dlg and complist_savelist() */ <br> <br>char dlg_file[256];                /* filename to save to */ <br> <br>/* checkbox options */ <br>BOOL dlg_identical, dlg_differ, dlg_left, dlg_right; <br>BOOL dlg_recursive = FALSE; <br> <br>/* data for Directory and SaveList */ <br>char dialog_leftname[256]; <br>char dialog_rightname[256]; <br> <br>/* <br> * data used by dodlg_copyfiles <br> */ <br>UINT dlg_options; <br>char dlg_root[256]; <br> <br>/*------------------------timing for performance measurements-----------------*/ <br> <br>static DWORD TickCount;         /* time operation started, then time taken*/ <br> <br> <br>int FAR PASCAL complist_dodlg_savelist(HWND hDlg, UINT message, <br>        UINT wParam, long lParam); <br>int FAR PASCAL complist_dodlg_copyfiles(HWND hDlg, UINT message, <br>        UINT wParam, long lParam); <br>BOOL complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact); <br>COMPLIST complist_new(void); <br>int FAR PASCAL complist_dodlg_dir(HWND hDlg, unsigned message, <br>        WORD wParam, LONG lParam); <br> <br> <br> <br>/*************************************************************************** <br> * Function: complist_filedialog <br> * <br> * Purpose: <br> * <br> * Builds a complist by putting up two dialogs to allow the user to <br> * select two files. This will build a Complist with one CompItem (even <br> * if the names don't match). <br> * <br> ***************************************************************************/ <br>COMPLIST <br>complist_filedialog(VIEW view) <br>{ <br>        COMPLIST cl; <br>        OFSTRUCT os1, os2; <br>        char fname[256], FileExt[256], FileOpenSpec[256]; <br> <br>        /* ask for the filenames */ <br>        lstrcpy(FileExt, ".c"); <br>        lstrcpy(FileOpenSpec, "*.*"); <br>        lstrcpy(fname,""); <br> <br>        if (!complist_open(LoadRcString(IDS_SELECT_FIRST_FILE), FileExt, FileOpenSpec, <br>                        &amp;os1, fname) ) <br>                return(NULL); <br> <br>        lstrcpy(FileExt, ".c"); <br>        lstrcpy(FileOpenSpec, "*.*"); <br>        lstrcpy(fname,""); <br> <br>        if (!complist_open(LoadRcString(IDS_SELECT_SECOND_FILE), FileExt, FileOpenSpec, <br>                        &amp;os2, fname) ) <br>                return(NULL); <br> <br>        /* alloc a new structure */ <br>        cl = complist_new(); <br> <br>        cl-&gt;left = dir_buildlist(os1.szPathName, TRUE); <br>        cl-&gt;right = dir_buildlist(os2.szPathName, TRUE); <br> <br> <br>        /* register with the view (must be done after the list is non-null) */ <br>        view_setcomplist(view, cl); <br> <br>        complist_match(cl, view, FALSE, TRUE); <br> <br>        return(cl); <br>}/* complist_filedialog */ <br> <br>/*************************************************************************** <br> * Function: complist_dirdialog <br> * <br> * Purpose: <br> * <br> * Builds a new complist by querying the user for two directory <br> * names and scanning those in parallel. <br> * <br> * Names that match in the same directory will be paired - unmatched <br> * names will go in a compitem on their own. <br> * <br> ***************************************************************************/ <br>COMPLIST <br>complist_dirdialog(VIEW view) <br>{ <br>        DLGPROC lpProc; <br>        BOOL fOK; <br> <br>        /* put up a dialog for the two pathnames */ <br>        lpProc = (DLGPROC)MakeProcInstance((WNDPROC)complist_dodlg_dir, hInst); <br>        windiff_UI(TRUE); <br>        fOK = DialogBox(hInst, "Directory", hwndClient, lpProc); <br>        windiff_UI(FALSE); <br>        FreeProcInstance(lpProc); <br> <br>        if (!fOK) { <br>                return(NULL); <br>        } <br> <br>        return complist_args( dialog_leftname, dialog_rightname <br>                            , view, dlg_recursive); <br>} /* complist_dirdialog */ <br> <br> <br>/*************************************************************************** <br> * Function: complist_args <br> * <br> * Purpose: <br> * <br> * Given two pathname strings, scan the directories and traverse them <br> * in parallel comparing matching names. <br> * <br> ***************************************************************************/ <br>COMPLIST <br>complist_args(LPSTR p1, LPSTR p2, VIEW view, BOOL fDeep) <br>{ <br>        COMPLIST cl; <br>        char msg[256]; <br> <br> <br>        /* alloc a new complist */ <br>        cl = complist_new(); <br> <br>        cl-&gt;left = dir_buildlist(p1, TRUE); <br>        /* check that we could find the paths, and report if not */ <br>        if (cl-&gt;left == NULL) { <br>                wsprintf((LPTSTR)msg, LoadRcString(IDS_COULDNT_FIND), p1); <br>                MessageBox(NULL, msg, NULL, MB_OK | MB_ICONSTOP); <br>                return(NULL); <br>        } <br> <br>        cl-&gt;right = dir_buildlist(p2, TRUE); <br>        if (cl-&gt;right == NULL) { <br>                wsprintf((LPTSTR)msg, LoadRcString(IDS_COULDNT_FIND), p2); <br>                MessageBox(NULL, msg, NULL, MB_OK | MB_ICONSTOP); <br>                return(NULL); <br>        } <br> <br>        /* register with the view (must be done after building lists) */ <br>        view_setcomplist(view, cl); <br> <br>        complist_match(cl, view, fDeep, TRUE); <br> <br>        return(cl); <br>} /* complist_args */ <br> <br>/*************************************************************************** <br> * Function: complist_getitems <br> * <br> * Purpose: <br> * <br> * Gets the handle to the list of COMPITEMs. The list continues to be <br> * owned by the COMPLIST, so don't delete except by calling complist_delete. <br> * <br> ***************************************************************************/ <br>LIST <br>complist_getitems(COMPLIST cl) <br>{ <br>        if (cl == NULL) { <br>                return(NULL); <br>        } <br> <br>        return(cl-&gt;items); <br>} <br> <br>/*************************************************************************** <br> * Function: complist_delete <br> * <br> * Purpose: <br> * <br> * Deletes a complist and all associated CompItems and DIRLISTs. Note this <br> * does not delete any VIEW - the VIEW owns the COMPLIST and not the other <br> * way around. <br> * <br> **************************************************************************/ <br>void <br>complist_delete(COMPLIST cl) <br>{ <br>        COMPITEM item; <br> <br>        if (cl == NULL) { <br>                return; <br>        } <br> <br>        /* delete the two directory scan lists */ <br>        dir_delete(cl-&gt;left); <br>        dir_delete(cl-&gt;right); <br> <br>        /* delete the compitems in the list */ <br>        List_TRAVERSE(cl-&gt;items, item) { <br>                        compitem_delete(item); <br>        } <br> <br>        /* delete the list itself */ <br>        List_Destroy(&amp;cl-&gt;items); <br> <br>        gmem_free(hHeap, (LPSTR) cl, sizeof(struct complist)); <br> <br>} <br> <br>/*************************************************************************** <br> * Function: complist_savelist <br> * <br> * Purpose: <br> * <br> * Writes out to a text file the list of compitems as relative filenames <br> * one per line. <br> * <br> * If savename is non-null, use this as the filename for output; otherwise, <br> * query the user via a dialog for the filename and include options. <br> * <br> **************************************************************************/ <br>void <br>complist_savelist(COMPLIST cl, LPSTR savename, UINT options) <br>{ <br>        DLGPROC lpProc; <br>        static BOOL done_init = FALSE; <br>        BOOL bOK; <br>        int fh, state; <br>        OFSTRUCT os; <br>        char msg[256]; <br>        HCURSOR hcurs; <br>        COMPITEM ci; <br>        LPSTR pstr, lhead, rhead; <br>        int nFiles = 0; <br> <br>        if (!done_init) { <br>                /* init the options once round - but keep the same options <br>                 * for the rest of the session. <br>                 */ <br> <br>                /* first init default options */ <br>                dlg_identical = FALSE; <br>                dlg_differ = TRUE; <br>                dlg_left = TRUE; <br>                dlg_right = FALSE; <br> <br>                dlg_file[0] = '\0'; <br> <br>                done_init = TRUE; <br>        } <br> <br>        if (cl == NULL) { <br>                return; <br>        } <br> <br>        if (savename == NULL) { <br> <br>                /* store the left and right rootnames so that dodlg_savelist <br>                 * can display them in the dialog. <br>                 */ <br>                pstr = dir_getroot_list(cl-&gt;left); <br>                lstrcpy(dialog_leftname, pstr); <br>                dir_freeroot_list(cl-&gt;left, pstr); <br> <br>                pstr = dir_getroot_list(cl-&gt;right); <br>                lstrcpy(dialog_rightname, pstr); <br>                dir_freeroot_list(cl-&gt;right, pstr); <br> <br>                lpProc = (DLGPROC)MakeProcInstance((WNDPROC)complist_dodlg_savelist, hInst); <br>                windiff_UI(TRUE); <br>                bOK = DialogBox(hInst, "SaveList", hwndClient, lpProc); <br>                windiff_UI(FALSE); <br>                FreeProcInstance(lpProc); <br> <br>                if (!bOK) { <br>                        /* user cancelled from dialog box */ <br>                        return; <br>                } <br>                savename = dlg_file; <br> <br>        } else { <br>                dlg_identical = (options &amp; INCLUDE_SAME); <br>                dlg_differ = (options &amp; INCLUDE_DIFFER); <br>                dlg_left = (options &amp; INCLUDE_LEFTONLY); <br>                dlg_right = (options &amp; INCLUDE_RIGHTONLY); <br>        } <br> <br> <br>        /* try to open the file */ <br>        fh = OpenFile(savename, &amp;os, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE); <br>        if (fh &lt; 0) { <br>                wsprintf((LPTSTR)msg, LoadRcString(IDS_CANT_OPEN), savename); <br>                windiff_UI(TRUE); <br>                MessageBox(NULL, msg, "Windiff", MB_ICONSTOP|MB_OK); <br>                windiff_UI(FALSE); <br>                return; <br>        } <br> <br>        hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>        /* write out the header line */ <br>        lhead = dir_getroot_list(cl-&gt;left); <br>        rhead = dir_getroot_list(cl-&gt;right); <br>{ <br>        TCHAR szBuf1[20],szBuf2[20],szBuf3[20],szBuf4[20]; <br>        lstrcpy(szBuf1,(LPSTR)(dlg_identical ? LoadRcString(IDS_IDENTICAL_COMMA) : "")); <br>        lstrcpy(szBuf2,(LPSTR)(dlg_left ? LoadRcString(IDS_LEFT_ONLY_COMMA) : "")); <br>        lstrcpy(szBuf3,(LPSTR)(dlg_right ? LoadRcString(IDS_RIGHT_ONLY_COMMA) : "")); <br>        lstrcpy(szBuf4,(LPSTR)(dlg_differ ? LoadRcString(IDS_DIFFERING) : "")); <br>        wsprintf(msg, LoadRcString(IDS_HEADER_LINE_STR), <br>                lhead, rhead, szBuf1, szBuf2, szBuf3, szBuf4); <br>} <br>        _lwrite(fh, msg, lstrlen(msg)); <br>        dir_freeroot_list(cl-&gt;left, lhead); <br>        dir_freeroot_list(cl-&gt;right, rhead); <br> <br> <br>        /* traverse the list of compitems looking for the <br>         * ones we are supposed to include <br>         */ <br>        List_TRAVERSE(cl-&gt;items, ci) { <br> <br>                /* check if files of this type are to be listed */ <br>                state = compitem_getstate(ci); <br> <br>                if ((state == STATE_SAME) &amp;&amp; (!dlg_identical)) { <br>                        continue; <br>                } else if ((state == STATE_DIFFER) &amp;&amp; (!dlg_differ)) { <br>                        continue; <br>                } else if ((state == STATE_FILELEFTONLY) &amp;&amp; (!dlg_left)) { <br>                        continue; <br>                } else if ((state == STATE_FILERIGHTONLY) &amp;&amp; (!dlg_right)) { <br>                        continue; <br>                } <br> <br>                nFiles++; <br> <br>                /* output the list line */ <br>                wsprintf((LPTSTR)msg, "%s\r\n", compitem_gettext_tag(ci)); <br>                _lwrite(fh, msg, lstrlen(msg)); <br>        } <br> <br>        /* write tail line */ <br>        wsprintf((LPTSTR)msg, LoadRcString(IDS_FILES_LISTED), nFiles); <br>        _lwrite(fh, msg, lstrlen(msg)); <br> <br>        /* - close file and we are finished */ <br>        _lclose(fh); <br> <br>        SetCursor(hcurs); <br>} /* complist_savelist */ <br> <br>/*************************************************************************** <br> * Function: complist_copyfiles <br> * <br> * Purpose: <br> * <br> * To copy files to a new directory newroot. if newroot is NULL, query the user <br> * via a dialog to get the new dir name and options. <br> * <br> * Options are either COPY_FROMLEFT or COPY_FROMRIGHT (indicating which <br> * tree is to be the source of the files, plus any or all of <br> * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT <br> * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option <br> * indicates which side to copy from). <br> * <br> ***************************************************************************/ <br>void <br>complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options) <br>{ <br>        int nFiles = 0; <br>        int nFails = 0; <br>        static BOOL done_init = FALSE; <br>        LPSTR pstr; <br>        char buffer[64]; <br>        DIRITEM diritem; <br>        DLGPROC lpProc; <br>        BOOL bOK; <br>        COMPITEM ci; <br>        int state; <br> <br>        if (!done_init) { <br>                /* <br>                 * one-time initialisation of dialog defaults <br>                 */ <br>                dlg_options = COPY_FROMLEFT|INCLUDE_LEFTONLY|INCLUDE_DIFFER; <br>                dlg_root[0] = '\0'; <br>                done_init = TRUE; <br>        } <br> <br>        if (cl == NULL) { <br>                return; <br>        } <br> <br> <br>        if (newroot == NULL) { <br>                /* <br>                 * put up dialog to query rootname and options <br>                 */ <br> <br>                /* store the left and right rootnames so that the dlg proc <br>                 * can display them in the dialog. <br>                 */ <br>                pstr = dir_getroot_list(cl-&gt;left); <br>                lstrcpy(dialog_leftname, pstr); <br>                dir_freeroot_list(cl-&gt;left, pstr); <br> <br>                pstr = dir_getroot_list(cl-&gt;right); <br>                lstrcpy(dialog_rightname, pstr); <br>                dir_freeroot_list(cl-&gt;right, pstr); <br> <br>                do { <br>                        lpProc = (DLGPROC)MakeProcInstance((WNDPROC)complist_dodlg_copyfiles, hInst); <br>                        windiff_UI(TRUE); <br>                        bOK = DialogBox(hInst, "CopyFiles", hwndClient, lpProc); <br>                        windiff_UI(FALSE); <br>                        FreeProcInstance(lpProc); <br> <br>                        if (!bOK) { <br>                                /* user cancelled from dialog box */ <br>                                return; <br>                        } <br>                        if (lstrlen(dlg_root) == 0) { <br>                                windiff_UI(TRUE); <br>                                MessageBox(NULL, LoadRcString(IDS_ENTER_DIR_NAME), <br>                                                "Windiff", MB_ICONSTOP|MB_OK); <br>                                windiff_UI(FALSE); <br>                        } <br>                } while (lstrlen(dlg_root) == 0); <br> <br>        } else { <br>                dlg_options = options; <br>                lstrcpy(dlg_root, newroot); <br>        } <br> <br>        TickCount = GetTickCount(); <br> <br>        if (dlg_options &amp; COPY_FROMLEFT) { <br>                if (!dir_startcopy(cl-&gt;left)) <br>                        return; <br>        } else { <br>                if (!dir_startcopy(cl-&gt;right)) <br>                        return; <br>        } <br> <br>        /* <br>         * traverse the list of compitems copying files as necessary <br>         */ <br>        List_TRAVERSE(cl-&gt;items, ci) { <br> <br>                if (bAbort){ <br>                        break;  /* fall into end_copy processing */ <br>                } <br>                /* check if files of this type are to be copied */ <br>                state = compitem_getstate(ci); <br> <br>                if ((state == STATE_SAME) &amp;&amp; !(dlg_options &amp; INCLUDE_SAME)) { <br>                        continue; <br>                } else if ((state == STATE_DIFFER) &amp;&amp; !(dlg_options &amp; INCLUDE_DIFFER)) { <br>                        continue; <br>                } else if (state == STATE_FILELEFTONLY) { <br>                        if (dlg_options &amp; COPY_FROMRIGHT) { <br>                                continue; <br>                        } <br>                        if ((dlg_options &amp; (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) { <br>                                continue; <br>                        } <br>                } else if (state == STATE_FILERIGHTONLY) { <br>                        if (dlg_options &amp; COPY_FROMLEFT) { <br>                                continue; <br>                        } <br>                        if ((dlg_options &amp; (INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY)) == 0) { <br>                                continue; <br>                        } <br>                } <br> <br>                if (dlg_options &amp; COPY_FROMLEFT) { <br>                        diritem = file_getdiritem(compitem_getleftfile(ci)); <br>                } else { <br>                        diritem = file_getdiritem(compitem_getrightfile(ci)); <br>                } <br> <br>                /* <br>                 * copy the file to the new root directory <br>                 */ <br>                if (dir_copy(diritem, dlg_root) == FALSE) { <br>                        nFails++; <br>                        pstr = dir_getrelname(diritem); <br>                        wsprintf((LPTSTR)buffer, LoadRcString(IDS_FAILED_TO_COPY), pstr); <br>                        dir_freerelname(diritem, pstr); <br> <br>                        if (MessageBox(NULL, buffer, NULL, MB_OKCANCEL | MB_ICONSTOP) == IDCANCEL) <br>                            /* user pressed cancel - abort current operation*/ <br>                            /* fall through to end-copy processing */ <br>                            break; <br> <br>                } else { <br>                        nFiles++; <br>                } <br> <br>                wsprintf((LPTSTR)buffer, LoadRcString(IDS_COPYING), nFiles); <br>                SetStatus(buffer); <br> <br> <br>                /* <br>                 * allow user interface to continue <br>                 */ <br>                if (Poll()) { <br>                        /* abort requested */ <br>                        TickCount = GetTickCount()-TickCount; <br>                        windiff_UI(TRUE); <br>                        MessageBox(hwndClient, LoadRcString(IDS_COPY_ABORTED), <br>                                "WinDiff", MB_OK|MB_ICONINFORMATION); <br>                        windiff_UI(FALSE); <br>                        break; <br>                } <br> <br>        } /* traverse */ <br>        if (dlg_options &amp; COPY_FROMLEFT) { <br>                nFails = dir_endcopy(cl-&gt;left); <br>        } else { <br>                nFails = dir_endcopy(cl-&gt;right); <br>        } <br>        TickCount = GetTickCount()-TickCount; <br> <br>        if (nFails&lt;0) { <br>                wsprintf((LPTSTR)buffer, LoadRcString(IDS_COPY_FAILED), -nFails); <br>        } else { <br>                wsprintf((LPTSTR)buffer, LoadRcString(IDS_COPY_COMPLETE), nFails); <br>        } <br>        windiff_UI(TRUE); <br>        MessageBox(hwndClient, buffer, "WinDiff", MB_OK|MB_ICONINFORMATION); <br>        windiff_UI(FALSE); <br> <br>        buffer[0] = '\0'; <br>        SetStatus(buffer); <br>} /* complist_copyfiles */ <br> <br> <br>/*************************************************************************** <br> * Function: complist_match <br> * <br> * Purpose: <br> * <br> * Matches up two lists of filenames <br> * <br> * Commentsz: <br> * <br> * We can find out from the DIRLIST handle whether the original list <br> * was a file or a directory name. <br> * If the user typed: <br> *      two file names  - match these two item even if the names differ <br> * <br> *      two dirs        - match only those items whose names match <br> * <br> *      one file and one dir <br> *                      - try to find a file of that name in the dir. <br> * <br> * This function returns TRUE if the complist_match was ok, or FALSE if it was <br> * aborted in some way. <br> * <br> ***************************************************************************/ <br>BOOL <br>complist_match(COMPLIST cl, VIEW view, BOOL fDeep, BOOL fExact) <br>{ <br>        LPSTR lname; <br>        LPSTR rname; <br>        DIRITEM leftitem, rightitem; <br>        int cmpvalue; <br> <br>        TickCount = GetTickCount(); <br> <br>        if (dir_isfile(cl-&gt;left) ) { <br> <br>                if (dir_isfile(cl-&gt;right)) { <br>                        /* two files */ <br> <br>                        /* there should be one item in each list - make <br>                         * a compitem by matching these two and append it to the <br>                         * list <br>                         */ <br>                        compitem_new(dir_firstitem(cl-&gt;left), <br>                                       dir_firstitem(cl-&gt;right), cl-&gt;items, fExact); <br> <br>                        view_newitem(view); <br> <br>                        TickCount = GetTickCount() - TickCount; <br>                        return TRUE; <br>                } <br>                /* left is file, right is dir */ <br>                leftitem = dir_firstitem(cl-&gt;left); <br>                rightitem = dir_firstitem(cl-&gt;right); <br>                lname = dir_getrelname(leftitem); <br>                while (rightitem != NULL) { <br>                        rname = dir_getrelname(rightitem); <br>                        cmpvalue = lstrcmpi(lname, rname); <br>                        dir_freerelname(rightitem, rname); <br> <br>                        if (cmpvalue == 0) { <br>                                /* this is the match */ <br>                                compitem_new(leftitem, rightitem, cl-&gt;items, fExact); <br>                                view_newitem(view); <br> <br>                                dir_freerelname(leftitem, lname); <br> <br>                                TickCount = GetTickCount() - TickCount; <br>                                return(TRUE); <br>                        } <br> <br>                        rightitem = dir_nextitem(cl-&gt;right, rightitem, fDeep); <br>                } <br>                /* not found */ <br>                dir_freerelname(leftitem, lname); <br>                compitem_new(leftitem, NULL, cl-&gt;items, fExact); <br>                view_newitem(view); <br>                TickCount = GetTickCount() - TickCount; <br>                return(TRUE); <br> <br>        } else if (dir_isfile(cl-&gt;right)) { <br> <br>                /* left is dir, right is file */ <br> <br>                /* loop through the left dir, looking for <br>                 * a file that has the same name as rightitem <br>                 */ <br> <br>                leftitem = dir_firstitem(cl-&gt;left); <br>                rightitem = dir_firstitem(cl-&gt;right); <br>                rname = dir_getrelname(rightitem); <br>                while (leftitem != NULL) { <br>                        lname = dir_getrelname(leftitem); <br>                        cmpvalue = lstrcmpi(lname, rname); <br>                        dir_freerelname(leftitem, lname); <br> <br>                        if (cmpvalue == 0) { <br>                                /* this is the match */ <br>                                compitem_new(leftitem, rightitem, cl-&gt;items, fExact); <br>                                view_newitem(view); <br> <br>                                dir_freerelname(rightitem, rname); <br> <br>                                TickCount = GetTickCount() - TickCount; <br>                                return(TRUE); <br>                        } <br> <br>                        leftitem = dir_nextitem(cl-&gt;left, leftitem, fDeep); <br>                } <br>                /* not found */ <br>                dir_freerelname(rightitem, rname); <br>                compitem_new(NULL, rightitem, cl-&gt;items, fExact); <br>                view_newitem(view); <br>                TickCount = GetTickCount() - TickCount; <br>                return(TRUE); <br>        } <br> <br>        /* two directories */ <br> <br>        /* traverse the two lists in parallel comparing the relative names*/ <br> <br>        leftitem = dir_firstitem(cl-&gt;left); <br>        rightitem = dir_firstitem(cl-&gt;right); <br>        while ((leftitem != NULL) &amp;&amp; (rightitem != NULL)) { <br> <br>                lname = dir_getrelname(leftitem); <br>                rname = dir_getrelname(rightitem); <br>                cmpvalue = utils_CompPath(lname, rname); <br>                dir_freerelname(leftitem, lname); <br>                dir_freerelname(rightitem, rname); <br> <br>                if (cmpvalue == 0) { <br>                        compitem_new(leftitem, rightitem, cl-&gt;items, fExact); <br>                        if (view_newitem(view)) { <br>                                TickCount = GetTickCount() - TickCount; <br>                                return(FALSE); <br>                        } <br>                        leftitem = dir_nextitem(cl-&gt;left, leftitem, fDeep); <br>                        rightitem = dir_nextitem(cl-&gt;right, rightitem, fDeep); <br> <br>                } else if (cmpvalue &lt; 0) { <br>                        compitem_new(leftitem, NULL, cl-&gt;items, fExact); <br>                        if (view_newitem(view)) { <br>                                TickCount = GetTickCount() - TickCount; <br>                                return(FALSE); <br>                        } <br>                        leftitem = dir_nextitem(cl-&gt;left, leftitem, fDeep); <br>                }  else { <br>                        compitem_new(NULL, rightitem, cl-&gt;items, fExact); <br>                        if (view_newitem(view)) { <br>                                TickCount = GetTickCount() - TickCount; <br>                                return(FALSE); <br>                        } <br>                        rightitem = dir_nextitem(cl-&gt;right, rightitem, fDeep); <br>                } <br>        } <br> <br> <br>        /* any left over are unmatched */ <br>        while (leftitem != NULL) { <br>                compitem_new(leftitem, NULL, cl-&gt;items, fExact); <br>                if (view_newitem(view)) { <br>                        TickCount = GetTickCount() - TickCount; <br>                        return(FALSE); <br>                } <br>                leftitem = dir_nextitem(cl-&gt;left, leftitem, fDeep); <br>        } <br>        while (rightitem != NULL) { <br>                compitem_new(NULL, rightitem, cl-&gt;items, fExact); <br>                if (view_newitem(view)) { <br>                        TickCount = GetTickCount() - TickCount; <br>                        return(FALSE); <br>                } <br>                rightitem = dir_nextitem(cl-&gt;right, rightitem, fDeep); <br>        } <br>        TickCount = GetTickCount() - TickCount; <br>        return(TRUE); <br>} /* complist_match */ <br> <br>/* return time last operation took in milliseconds */ <br>DWORD complist_querytime(void) <br>{       return TickCount; <br>} <br> <br> <br>/*************************************************************************** <br> * Function: complist_dodlg_savelist <br> * <br> * Purpose: <br> * <br> * Dialog to query about filename and types of files. Init dlg fields from <br> * the dlg_* variables, and save state to the dlg_* variables on dialog <br> * close. return TRUE for OK, or FALSE for cancel (from the dialogbox() <br> * using EndDialog). <br> * <br> **************************************************************************/ <br>int FAR PASCAL <br>complist_dodlg_savelist(HWND hDlg, UINT message, UINT wParam, long lParam) <br>{ <br>        static char buffer[256]; <br> <br>        switch(message) { <br> <br> <br>        case WM_INITDIALOG: <br>                SendDlgItemMessage(hDlg, IDD_IDENTICAL, BM_SETCHECK, <br>                        dlg_identical ? 1 : 0, 0); <br>                SendDlgItemMessage(hDlg, IDD_DIFFER, BM_SETCHECK, <br>                        dlg_differ ? 1 : 0, 0); <br>                SendDlgItemMessage(hDlg, IDD_LEFT, BM_SETCHECK, <br>                        dlg_left ? 1 : 0, 0); <br>                SendDlgItemMessage(hDlg, IDD_RIGHT, BM_SETCHECK, <br>                        dlg_right ? 1 : 0, 0); <br> <br>                SetDlgItemText(hDlg, IDD_FILE, dlg_file); <br> <br>                /* convert 'left tree' into the right name */ <br>                wsprintf((LPTSTR)buffer, LoadRcString(IDS_FILES_ONLY), (LPSTR) dialog_leftname); <br>                SendDlgItemMessage(hDlg, IDD_LEFT, WM_SETTEXT, 0, (DWORD) (LPSTR) buffer); </code></pre>
<p>
</p>
<pre><code>/* convert 'right tree' msg into correct path */ <br>                wsprintf((LPTSTR)buffer, LoadRcString(IDS_FILES_ONLY), (LPSTR) dialog_rightname); <br>                SendDlgItemMessage(hDlg, IDD_RIGHT, WM_SETTEXT, 0, (DWORD) (LPSTR) buffer); <br> <br> <br>                return(TRUE); <br> <br>        case WM_COMMAND: <br>                switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br> <br>                case IDOK: <br>                        dlg_identical = (SendDlgItemMessage(hDlg, IDD_IDENTICAL, <br>                                        BM_GETCHECK, 0, 0) == 1); <br>                        dlg_differ = (SendDlgItemMessage(hDlg, IDD_DIFFER, <br>                                        BM_GETCHECK, 0, 0) == 1); <br>                        dlg_left = (SendDlgItemMessage(hDlg, IDD_LEFT, <br>                                        BM_GETCHECK, 0, 0) == 1); <br>                        dlg_right = (SendDlgItemMessage(hDlg, IDD_RIGHT, <br>                                        BM_GETCHECK, 0, 0) == 1); <br>                        GetDlgItemText(hDlg, IDD_FILE, dlg_file, sizeof(dlg_file)); <br> <br>                        EndDialog(hDlg, TRUE); <br>                        break; <br> <br>                case IDCANCEL: <br>                        EndDialog(hDlg, FALSE); <br>                        break; <br>                } <br>        } <br>        return(FALSE); <br>} /* complist_dodlg_savelist */ <br> <br>/*************************************************************************** <br> * Function: complist_dodlg_copyfiles <br> * <br> * Purpose: <br> * <br> * dialog to get directory name and inclusion options. Init dlg fields from <br> * the dlg_* variables, and save state to the dlg_* variables on dialog <br> * close. return TRUE for OK, or FALSE for cancel (from the dialogbox() <br> * using EndDialog). <br> *  <br> **************************************************************************/ <br>int FAR PASCAL <br>complist_dodlg_copyfiles(HWND hDlg, UINT message, UINT wParam, long lParam) <br>{ <br>        static char buffer[256]; <br> <br>        switch(message) { <br> <br> <br>        case WM_INITDIALOG: <br>                /* <br>                 * set checkboxes and directory field to defaults <br>                 */ <br>                CheckDlgButton(hDlg, IDD_IDENTICAL, <br>                        (dlg_options &amp; INCLUDE_SAME) ? 1 : 0); <br> <br>                CheckDlgButton(hDlg, IDD_DIFFER, <br>                        (dlg_options &amp; INCLUDE_DIFFER) ? 1 : 0); <br> <br>                CheckDlgButton(hDlg, IDD_LEFT, <br>                        (dlg_options &amp; (INCLUDE_LEFTONLY|INCLUDE_RIGHTONLY)) ? 1 : 0); <br> <br>                SetDlgItemText(hDlg, IDD_DIR1, dlg_root); <br> <br>                /* <br>                 * set 'copy from' buttons to have the full pathname <br>                 */ <br>                SetDlgItemText(hDlg, IDD_FROMLEFT, dialog_leftname); <br>                SetDlgItemText(hDlg, IDD_FROMRIGHT, dialog_rightname); <br> <br>                /* <br>                 * set default radio button for copy from, and set <br>                 * the text on the 'files only in...' checkbox to <br>                 * indicate which path is being selected <br>                 */ <br>                if (dlg_options &amp; COPY_FROMLEFT) { <br>                        CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT, <br>                                        IDD_FROMLEFT); <br> <br>                        wsprintf((LPTSTR)buffer, LoadRcString(IDS_FILES_ONLY), (LPSTR) dialog_leftname); <br>                        SetDlgItemText(hDlg, IDD_LEFT, buffer); <br>                } else { <br>                        CheckRadioButton(hDlg, IDD_FROMLEFT, IDD_FROMRIGHT, <br>                                        IDD_FROMRIGHT); <br> <br>                        wsprintf((LPTSTR)buffer, LoadRcString(IDS_FILES_ONLY), (LPSTR) dialog_rightname); <br>                        SetDlgItemText(hDlg, IDD_LEFT, buffer); <br>                } <br> <br>                return(TRUE); <br> <br>        case WM_COMMAND: <br>                switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br> <br>                case IDD_FROMLEFT: <br>                        wsprintf((LPTSTR)buffer, LoadRcString(IDS_FILES_ONLY), (LPSTR) dialog_leftname); <br>                        SetDlgItemText(hDlg, IDD_LEFT, buffer); <br> <br>                        dlg_options &amp;= ~(COPY_FROMRIGHT); <br>                        dlg_options |= COPY_FROMLEFT; <br>                        break; <br> <br>                case IDD_FROMRIGHT: <br>                        wsprintf((LPTSTR)buffer, LoadRcString(IDS_FILES_ONLY), (LPSTR) dialog_rightname); <br>                        SetDlgItemText(hDlg, IDD_LEFT, buffer); <br> <br>                        dlg_options &amp;= ~(COPY_FROMLEFT); <br>                        dlg_options |= COPY_FROMRIGHT; <br>                        break; <br> <br>                case IDOK: <br>                        if (SendDlgItemMessage(hDlg, IDD_IDENTICAL, <br>                            BM_GETCHECK, 0, 0) == 1) { <br>                                dlg_options |= INCLUDE_SAME; <br>                        } else { <br>                                dlg_options &amp;= ~INCLUDE_SAME; <br>                        } <br>                        if (SendDlgItemMessage(hDlg, IDD_DIFFER, <br>                            BM_GETCHECK, 0, 0) == 1) { <br>                                dlg_options |= INCLUDE_DIFFER; <br>                        } else { <br>                                dlg_options &amp;= ~INCLUDE_DIFFER; <br>                        } <br>                        if (SendDlgItemMessage(hDlg, IDD_LEFT, <br>                            BM_GETCHECK, 0, 0) == 1) { <br>                                dlg_options |= INCLUDE_LEFTONLY; <br>                        } else { <br>                                dlg_options &amp;= ~INCLUDE_LEFTONLY; <br>                        } <br>                        GetDlgItemText(hDlg, IDD_DIR1, dlg_root, sizeof(dlg_root)); <br> <br>                        EndDialog(hDlg, TRUE); <br>                        break; <br> <br>                case IDCANCEL: <br>                        EndDialog(hDlg, FALSE); <br>                        break; <br>                } <br>        } <br>        return(FALSE); <br>} /* complist_dodlg_copyfiles */ <br> <br>/*************************************************************************** <br> * Function: complist_new <br> * <br> * Purpose: <br> * <br> * Allocates a new complist and initialise it  <br> * <br> **************************************************************************/ <br>COMPLIST <br>complist_new(void) <br>{ <br>        COMPLIST cl; <br> <br>        cl = (COMPLIST) gmem_get(hHeap, sizeof(struct complist)); <br>        cl-&gt;left = NULL; <br>        cl-&gt;right = NULL; <br>        cl-&gt;items = List_Create(); <br> <br>        return(cl); <br>} /* complist_new */ <br> <br>/*************************************************************************** <br> * Function: complist_dodlg_dir <br> * <br> * Purpose: <br> * <br> * Dialog box function to ask for two directory names. <br> * no listing of files etc - just two edit fields  in which the <br> * user can type a file or a directory name. <br> * <br> * Initialises the names from win.ini, and stores them to win.ini first. <br> * <br> **************************************************************************/ <br>int FAR PASCAL <br>complist_dodlg_dir(HWND hDlg, unsigned message, WORD wParam, LONG lParam) <br>{ <br>        static char path[256]; <br>        static char buffer[256]; <br> <br>        switch (message) { <br> <br>        case WM_INITDIALOG: <br> <br>                /* fill the edit fields with the current <br>                 * directory as a good starting point <br>                 */ <br>                _getcwd(path, sizeof(path)); <br>                AnsiLowerBuff(path, strlen(path)); <br>                GetProfileString(APPNAME, "NameLeft", path, buffer, 256); <br>                SetDlgItemText(hDlg, IDD_DIR1, buffer); <br>                GetProfileString(APPNAME, "NameRight", path, buffer, 256); <br>                SetDlgItemText(hDlg, IDD_DIR2, buffer); <br>                /* set recursive option to most recent value */ <br>                CheckDlgButton(hDlg, IDD_RECURSIVE, dlg_recursive); <br>                return(TRUE); <br> <br>        case WM_COMMAND: <br>                switch (LOWORD(wParam)) { <br>                case IDCANCEL: <br>                        EndDialog(hDlg, FALSE); <br>                        return(TRUE); <br> <br>                case IDOK: <br>                        /* fetch the text from the dialog, and remember <br>                         * it in win.ini <br>                         */ <br> <br>                        GetDlgItemText(hDlg, IDD_DIR1, <br>                                dialog_leftname, sizeof(dialog_leftname)); <br>                        WriteProfileString(APPNAME, "NameLeft", dialog_leftname); <br> <br>                        GetDlgItemText(hDlg, IDD_DIR2, <br>                                dialog_rightname, sizeof(dialog_rightname)); <br>                        WriteProfileString(APPNAME, "NameRight", dialog_rightname); <br> <br>                        /* fetch recursive option */ <br>                        dlg_recursive = SendDlgItemMessage(hDlg, IDD_RECURSIVE, <br>                                BM_GETCHECK, 0, 0); <br> <br>                        EndDialog(hDlg, TRUE); <br>                        return(TRUE); <br>                } <br>                break; <br>        } <br>        return(FALSE); <br>} /* complist_dodlg_dir */ <br> <br>/*************************************************************************** <br> * Function: complist_open <br> * <br> * Purpose: <br> *       <br> * Puts up dialog asking the user to select an existing file to open. <br> * <br> * Parameters: <br> * <br> *      prompt - message to user indicating purpose of file <br> *               (to be displayed somewhere in dialog box. <br> * <br> *      ext    - default file extension if user enters file without <br> *               extension. <br> * <br> *      spec   - default file spec (eg *.*) <br> * <br> *      osp    - OFSTRUCT representing file, if successfully open. <br> * <br> *      fn     - buffer where filename (just final element) is returned. <br> * <br> * Returns: <br> * <br> * TRUE - if file selected and exists (tested with OF_EXIST). <br> * <br> * FALSE - if dialog cancelled. If user selects a file that we cannot <br> *           open, we complain and restart the dialog. <br> * <br> * Comments: <br> * <br> *           if TRUE is returned, the file will have been successfully opened, <br> *           for reading and then closed again. <br> * <br> **************************************************************************/ <br> <br>BOOL FAR PASCAL <br>complist_open(LPSTR prompt, LPSTR ext, LPSTR spec, OFSTRUCT FAR *osp, LPSTR fn) <br>{ <br>    OPENFILENAME ofn; <br>    char achFilters[256]; <br>    char achPath[256]; <br>    LPSTR chp; <br>    int fh; <br> <br>    /* build filter-pair buffer to contain one pair - the spec filter, <br>     * twice (one of the pair should be the filter, the second should be <br>     * the title of the filter - we don't have a title so we use the <br>     * filter both times. remember double null at end of list of strings. <br>     */ <br>    lstrcpy(achFilters, spec);             // filter + null <br>    chp = &amp;achFilters[lstrlen(achFilters)+1];      //2nd string just after null <br>    lstrcpy(chp, spec);                    // filter name (+null) <br>    chp[lstrlen(chp)+1] = '\0';            // double null at end of list <br>    /* <br>     * initialise arguments to dialog proc <br>     */ <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = NULL; <br>    ofn.hInstance = NULL; <br>    ofn.lpstrFilter = achFilters; <br>    ofn.lpstrCustomFilter = (LPSTR)NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1L;              // first filter pair in list <br>    achPath[0] = '\0'; <br>    ofn.lpstrFile = achPath;            // we need to get the full path to open <br>    ofn.nMaxFile = sizeof(achPath); <br>    ofn.lpstrFileTitle = fn;            // return final elem of name here <br>    ofn.nMaxFileTitle = sizeof(fn); <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = prompt;            // dialog title is good place for prompt text <br>    ofn.Flags = OFN_FILEMUSTEXIST | <br>                OFN_HIDEREADONLY | <br>                OFN_PATHMUSTEXIST; <br>    ofn.lpstrDefExt = ext; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lCustData = 0; <br> <br>    /* <br>     * loop until the user cancels, or selects a file that we can open <br>     */ <br>    do { <br>        if (!GetOpenFileName(&amp;ofn)) { <br>            return(FALSE); <br>        } <br> <br>        fh = OpenFile(achPath, osp, OF_READ); <br>         <br>        if (fh == HFILE_ERROR) { <br>            if (MessageBox(NULL, LoadRcString(IDS_COULDNT_BE_OPENED), LoadRcString2(IDS_FILEOPEN), <br>                            MB_OKCANCEL|MB_ICONSTOP) == IDCANCEL) { <br>                return(FALSE); <br>            } <br>        } <br>    } while (fh == HFILE_ERROR); <br> <br>    _lclose(fh); <br> <br>    return(TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: complist_getroot_left <br> * <br> * Purpose: <br> * <br> * Gets the root names of the left tree used to build this complist. <br> * <br> **************************************************************************/ <br>LPSTR <br>complist_getroot_left(COMPLIST cl) <br>{ <br>        return( dir_getroot_list(cl-&gt;left)); <br>} <br> <br>/*************************************************************************** <br> * Function: complist_getroot_right <br> * <br> * Purpose: <br> * <br> * Gets the root names of the right tree used to build this complist. <br> * <br> **************************************************************************/ <br>LPSTR <br>complist_getroot_right(COMPLIST cl) <br>{ <br>        return( dir_getroot_list(cl-&gt;right)); <br>} <br>/*************************************************************************** <br> * Function: complist_freeroot_* <br> * <br> * Purpose: <br> * <br> * Frees up memory allocated in a call to complist_getroot*()  <br> * <br> **************************************************************************/ <br>void <br>complist_freeroot_left(COMPLIST cl, LPSTR path) <br>{ <br>        dir_freeroot_list(cl-&gt;left, path); <br>} <br> <br>void <br>complist_freeroot_right(COMPLIST cl, LPSTR path) <br>{ <br>        dir_freeroot_list(cl-&gt;right, path); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
