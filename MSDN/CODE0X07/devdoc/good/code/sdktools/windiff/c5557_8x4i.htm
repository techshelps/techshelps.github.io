<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TPAINT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5562"></a>TPAINT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: TPAINT.C <br>* <br>* Paint functions <br>* <br>* Functions: <br>* <br>* GetTextExtent() <br>* gtab_updatecontig() <br>* gtab_delcr() <br>* gtab_updateline() <br>* gtab_updatecontig() <br>* gtab_boxcell() <br>* gtab_paintcell() <br>* gtab_paint() <br>* gtab_vsep() <br>* gtab_hsep() <br>* gtab_drawvertline() <br>* gtab_invertsel() <br>*  <br>* Comments: <br>* <br>* See table.h for interface design. <br>* <br>****************************************************************************/ <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "gutils.h" <br>#include "table.h" <br>#include "tpriv.h" <br> <br> <br>/*************************************************************************** <br> * Function: GetTextExtent <br> * <br> * Purpose: <br> *  <br> * Calls GetTextExtentPoint - for ease of porting. <br> */ <br> int <br>GetTextExtent(HDC hdc, LPSTR text, int len) <br>{ <br>    SIZE sz; <br> <br>    GetTextExtentPoint(hdc, text, len, &amp;sz); <br>    return(sz.cx); <br>} <br> <br>void gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count); <br> <br>/*************************************************************************** <br> * Function: gtab_delcr <br> * <br> * Purpose: <br> * <br> * change all cr/lf chars in input text to spaces  <br> */ <br>void gtab_delcr(LPSTR ptext) <br>{ <br>        LPSTR chp; <br> <br>        if (ptext == NULL) { <br>                return; <br>        } <br>        for(chp = ptext; (chp = strchr(chp, '\r')) != NULL; ) { <br>                *chp = ' '; <br>        } <br>        for(chp = ptext; (chp = strchr(chp, '\n')) != NULL; ) { <br>                *chp = ' '; <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_updateline <br> * <br> * Purpose: <br> * <br> * Ensures that all visible cells in the given line have valid <br> * text and property contents. loop through the cells, picking out <br> * contiguous blocks of visible, invalid cells and call <br> * gtab_updatecontig to update these from the owner window. <br> */ <br>void <br>gtab_updateline(HWND hwnd, lpTable ptab, int line) <br>{ <br>        lpCellPos ppos; <br>        int cell1, cellcount; <br>        lpLineData pline; <br>        lpCellData cd; <br>        int i; <br> <br>        pline = &amp;ptab-&gt;pdata[line]; <br>        cell1 = 0; <br>        cellcount = 0; <br>        for (i = 0; i &lt; ptab-&gt;hdr.ncols; i++) { <br>                ppos = &amp;ptab-&gt;pcellpos[i]; <br>                cd = &amp;pline-&gt;pdata[i]; <br>                if (ppos-&gt;clipstart &lt; ppos-&gt;clipend) { <br>                        if ((cd-&gt;flags &amp; CELL_VALID) == 0) { <br>                                /* add a cell to the list to be updated*/ <br>                                if (cellcount++ == 0) { <br>                                        cell1 = i; <br>                                } <br>                        } else { <br>                                /* this cell already valid - so end of <br>                                 * a contig block. if the contig <br>                                 * block just ended contained cells to update, <br>                                 * do it now <br>                                 */ <br>                                if (cellcount &gt; 0) { <br>                                        gtab_updatecontig(hwnd, ptab, <br>                                          line, cell1, cellcount); <br>                                } <br>                                cellcount = 0; <br>                        } <br>                } <br>                /* cell not visible - end of a contig block. If it was a <br>                 * non-empty contig block, then update it now. <br>                 */ <br>                if (cellcount &gt; 0)  { <br>                        gtab_updatecontig(hwnd, ptab, line, cell1, cellcount); <br>                        cellcount = 0;   <br>                } <br>        } <br>        if (cellcount &gt; 0) { <br>                gtab_updatecontig(hwnd, ptab, line, cell1, cellcount); <br>                cellcount = 0; <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_updatecontig <br> * <br> * Purpose: <br> * <br> * Updates a contiguous block of invalid cells by calling the owner window <br> */ <br>void <br>gtab_updatecontig(HWND hwnd, lpTable ptab, int line, int cell1, int count) <br>{ <br>        lpLineData pline; <br>        lpCellData cd; <br>        CellDataList list; <br>        lpProps colprops; <br>        int i; <br> <br>        pline = &amp;ptab-&gt;pdata[line]; <br>        cd = &amp;pline-&gt;pdata[cell1]; <br> <br>        list.id = ptab-&gt;hdr.id; <br>        list.row = gtab_linetorow(hwnd, ptab, line); <br>        list.startcell = cell1; <br>        list.ncells = count; <br>        list.plist = cd; <br> <br>        /* clear out prop flags */ <br>        for (i = 0; i &lt; count; i++) { <br>                cd[i].props.valid = 0; <br>                if (cd[i].nchars &gt; 0) { <br>                        cd[i].ptext[0] = '\0'; <br>                } <br>        } <br> <br>        if (list.row &lt; ptab-&gt;hdr.nrows) { <br>                gtab_sendtq(hwnd, TQ_GETDATA, (long) (LPSTR) &amp;list); <br>        } <br> <br>        /* for each cell, mark valid and set properties */ <br>        for (i = 0; i &lt; count; i++) { <br>                cd[i].flags |= CELL_VALID; <br>                gtab_delcr(cd[i].ptext); <br>                /* fetch properties from hdr and colhdr */ <br>                colprops = &amp;ptab-&gt;pcolhdr[i + cell1].props; <br>                if (!(cd[i].props.valid &amp; P_FCOLOUR)) { <br>                        if (colprops-&gt;valid &amp; P_FCOLOUR) { <br>                                cd[i].props.valid |= P_FCOLOUR; <br>                                cd[i].props.forecolour = colprops-&gt;forecolour; <br>                        } else if (ptab-&gt;hdr.props.valid &amp; P_FCOLOUR) { <br>                                cd[i].props.valid |= P_FCOLOUR; <br>                                cd[i].props.forecolour = <br>                                        ptab-&gt;hdr.props.forecolour; <br>                        } <br>                } <br> <br>                if (!(cd[i].props.valid &amp; P_BCOLOUR)) { <br>                        if (colprops-&gt;valid &amp; P_BCOLOUR) { <br>                                cd[i].props.valid |= P_BCOLOUR; <br>                                cd[i].props.backcolour = colprops-&gt;backcolour; <br>                        } else if (ptab-&gt;hdr.props.valid &amp; P_BCOLOUR) { <br>                                cd[i].props.valid |= P_BCOLOUR; <br>                                cd[i].props.backcolour = <br>                                        ptab-&gt;hdr.props.backcolour; <br>                        } <br>                } <br> <br>                if (!(cd[i].props.valid &amp; P_FONT)) { <br>                        if (colprops-&gt;valid &amp; P_FONT) { <br>                                cd[i].props.valid |= P_FONT; <br>                                cd[i].props.hFont = colprops-&gt;hFont; <br>                        } else if (ptab-&gt;hdr.props.valid &amp; P_FONT) { <br>                                cd[i].props.valid |= P_FONT; <br>                                cd[i].props.hFont = ptab-&gt;hdr.props.hFont; <br>                        } <br>                } <br> <br>                if (!(cd[i].props.valid &amp; P_ALIGN)) { <br>                        if (colprops-&gt;valid &amp; P_ALIGN) { <br>                                cd[i].props.valid |= P_ALIGN; <br>                                cd[i].props.alignment = colprops-&gt;alignment; <br>                        } else if (ptab-&gt;hdr.props.valid &amp; P_ALIGN) { <br>                                cd[i].props.valid |= P_ALIGN; <br>                                cd[i].props.alignment = <br>                                        ptab-&gt;hdr.props.alignment; <br>                        } <br>                } <br> <br>                if (!(cd[i].props.valid &amp; P_BOX)) { <br>                        if (colprops-&gt;valid &amp; P_BOX) { <br>                                cd[i].props.valid |= P_BOX; <br>                                cd[i].props.box = colprops-&gt;box; <br>                        } else if (ptab-&gt;hdr.props.valid &amp; P_BOX) { <br>                                cd[i].props.valid |= P_BOX; <br>                                cd[i].props.box = ptab-&gt;hdr.props.box; <br>                        } <br>                } <br>                /* you can't set width/height per cell - this <br>                 * is ignored at cell level. <br>                 */ <br>        } <br> <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_boxcell <br> * <br> * Purpose: <br> * <br> * Draws box around a cell in a table. <br> */  <br>void <br>gtab_boxcell(HWND hwnd, HDC hdc, LPRECT rcp, LPRECT pclip, UINT boxmode) <br>{ <br>        if (boxmode &amp; P_BOXTOP) { <br>                MoveToEx(hdc, max(rcp-&gt;left, pclip-&gt;left), <br>                        max(rcp-&gt;top, pclip-&gt;top), NULL); <br>                LineTo(hdc, min(rcp-&gt;right, pclip-&gt;right), <br>                        max(rcp-&gt;top, pclip-&gt;top)); <br>        } <br>        if (boxmode &amp; P_BOXBOTTOM) { <br>                MoveToEx(hdc, max(rcp-&gt;left, pclip-&gt;left), <br>                        min(rcp-&gt;bottom, pclip-&gt;bottom), NULL); <br>                LineTo(hdc, min(rcp-&gt;right, pclip-&gt;right), <br>                        min(rcp-&gt;bottom, pclip-&gt;bottom)); <br>        } <br>        if (boxmode &amp; P_BOXLEFT) { <br>                MoveToEx(hdc, max(rcp-&gt;left, pclip-&gt;left), <br>                        max(rcp-&gt;top, pclip-&gt;top), NULL); <br>                MoveToEx(hdc, max(rcp-&gt;left, pclip-&gt;left), <br>                        min(rcp-&gt;bottom, pclip-&gt;bottom), NULL); <br>        } <br>        if (boxmode &amp; P_BOXRIGHT) { <br>                MoveToEx(hdc, min(rcp-&gt;right, pclip-&gt;right), <br>                        max(rcp-&gt;top, pclip-&gt;top), NULL); <br>                LineTo(hdc, min(rcp-&gt;right, pclip-&gt;right), <br>                        min(rcp-&gt;bottom, pclip-&gt;bottom)); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_paintcell <br> * <br> * Purpose: <br> * <br> * Paints a cell. <br> */ <br>void <br>gtab_paintcell(HWND hwnd, HDC hdc, lpTable ptab, int line, int cell) <br>{ <br>        lpLineData pline; <br>        lpCellData cd; <br>        lpCellPos ppos; <br>        RECT rc, rcbox; <br>        int cx, x, y, tabwidth; <br>        UINT align; <br>        LPSTR chp, tabp; <br>        DWORD fcol, bkcol; <br>        HFONT hfont; <br>        TEXTMETRIC tm; <br>        HBRUSH hbr; <br> <br>        /* init pointers to cell text and properties */ <br>        pline = &amp;ptab-&gt;pdata[line]; <br>        cd = &amp;pline-&gt;pdata[cell]; <br>        ppos = &amp;ptab-&gt;pcellpos[cell]; <br> <br>        /* clip all output to this rectangle */ <br>        rc.top = pline-&gt;linepos.clipstart; <br>        rc.bottom = pline-&gt;linepos.clipend; <br>        rc.left = ppos-&gt;clipstart; <br>        rc.right = ppos-&gt;clipend; <br> <br> <br>        /* check cell properties and colours */ <br>        if (cd-&gt;props.valid &amp; P_ALIGN) { <br>                align = cd-&gt;props.alignment; <br>        } else { <br>                align = P_LEFT; <br>        } <br>        if (cd-&gt;props.valid &amp; P_FONT) { <br>                hfont = SelectObject(hdc, cd-&gt;props.hFont); <br>                GetTextMetrics(hdc, &amp;tm); <br>                tabwidth = tm.tmAveCharWidth * 8; <br>        } else { <br>                tabwidth = ptab-&gt;avewidth * 8; <br>        } <br> <br>        /* set colours if not default */ <br>        if (cd-&gt;props.valid &amp; P_FCOLOUR) { <br>                fcol = SetTextColor(hdc, cd-&gt;props.forecolour); <br>        } <br>        if (cd-&gt;props.valid &amp; P_BCOLOUR) { <br>                /* there is a non-default background colour. <br>                 * create a brush and fill the entire cell with it <br>                 */ <br>                hbr = CreateSolidBrush(cd-&gt;props.backcolour); <br>                FillRect(hdc, &amp;rc, hbr); <br>                DeleteObject(hbr); <br> <br>                /* also set colour as background colour for the text */ <br>                bkcol = SetBkColor(hdc, cd-&gt;props.backcolour); <br>        } <br> <br>        /* calc offset of text within cell for right-align or centering */ <br>        if (align == P_LEFT) { <br>                cx = ptab-&gt;avewidth/2; <br>        } else { <br>                if (cd-&gt;ptext == NULL) { <br>                        cx = 0; <br>                } else { <br>                        cx = LOWORD(GetTextExtent(hdc, cd-&gt;ptext, <br>                                        lstrlen(cd-&gt;ptext))); <br>                } <br>                if (align == P_CENTRE) { <br>                        cx = (ppos-&gt;size - cx) / 2; <br>                } else { <br>                        cx = ppos-&gt;size - cx - (ptab-&gt;avewidth/2); <br>                } <br>        } <br>        cx += ppos-&gt;start; <br> <br>        /* expand tabs on output */ <br>        x = 0; <br>        y = pline-&gt;linepos.start; <br> <br>        for (chp = cd-&gt;ptext; <br>            ((chp != NULL) &amp;&amp; ((tabp = strchr(chp, '\t')) != NULL)); ) { <br>                /* perform output upto tab char */ <br>                ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &amp;rc, chp, tabp-chp, NULL); <br>                 <br>                /* advance past the tab */ <br>                x += LOWORD(GetTextExtent(hdc, chp, tabp - chp)); <br>                x = ( (x + tabwidth) / tabwidth) * tabwidth; <br>                chp = ++tabp; <br>        } <br> <br>        /*no more tabs - output rest of string */ <br>        if (chp != NULL) { <br>                ExtTextOut(hdc, x+cx, y, ETO_CLIPPED, &amp;rc, <br>                                chp, lstrlen(chp), NULL); <br>        } <br> <br>        /* reset colours to original if not default */ <br>        if (cd-&gt;props.valid &amp; P_FCOLOUR) { <br>                SetTextColor(hdc, fcol); <br>        } <br>        if (cd-&gt;props.valid &amp; P_BCOLOUR) { <br>                SetBkColor(hdc, bkcol); <br>        } <br>        if (cd-&gt;props.valid &amp; P_FONT) { <br>                SelectObject(hdc, hfont); <br>        } <br> <br>        /* now box cell if marked */ <br>        if (cd-&gt;props.valid &amp; P_BOX) { <br>                if (cd-&gt;props.box != 0) { <br>                        rcbox.top = pline-&gt;linepos.start; <br>                        rcbox.bottom = rcbox.top + pline-&gt;linepos.size; <br>                        rcbox.left = ppos-&gt;start; <br>                        rcbox.right = ppos-&gt;start + ppos-&gt;size; <br>                        gtab_boxcell(hwnd, hdc, &amp;rcbox, &amp;rc, cd-&gt;props.box); <br>                } <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_paint <br> * <br> * Purpose: <br> * <br> * Fetch and paint the specified line  <br> */ <br>void <br>gtab_paint(HWND hwnd, HDC hdc, lpTable ptab, int line) <br>{ <br>        lpCellPos ppos; <br>        int i; <br> <br>        gtab_updateline(hwnd, ptab, line); <br> <br>        for (i = 0; i &lt; ptab-&gt;hdr.ncols; i++) { <br>                ppos = &amp;ptab-&gt;pcellpos[i]; <br>                if (ppos-&gt;clipstart &lt; ppos-&gt;clipend) { <br>                        gtab_paintcell(hwnd, hdc, ptab, line, i); <br>                } <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_vsep <br> * <br> * Purpose: <br> * <br> */ <br>void <br>gtab_vsep(HWND hwnd, lpTable ptab, HDC hdc) <br>{ <br>        int x; <br>        RECT rc; <br> <br>        if (ptab-&gt;hdr.fixedcols &lt; 1) { <br>                return; <br>        } <br>        x = ptab-&gt;pcellpos[ptab-&gt;hdr.fixedcols - 1].clipend+1; <br>        GetClientRect(hwnd, &amp;rc); <br>        MoveToEx(hdc, x, rc.top, NULL); <br>        LineTo(hdc, x, rc.bottom); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_hsep <br> * <br> * Purpose: <br> */ <br>void <br>gtab_hsep(HWND hwnd, lpTable ptab, HDC hdc) <br>{ <br>        int y; <br>        RECT rc; <br> <br>        if (ptab-&gt;hdr.fixedrows &lt; 1) { <br>                return; <br>        } <br>        y = ptab-&gt;rowheight * ptab-&gt;hdr.fixedrows; <br>        GetClientRect(hwnd, &amp;rc); <br>        MoveToEx(hdc, rc.left, y-1, NULL); <br>        LineTo(hdc, rc.right, y-1); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_drawverline <br> * <br> * Purpose: <br> * <br> * Draw in (inverting) the dotted selection lines for tracking a col width <br> */ <br>void <br>gtab_drawvertline(HWND hwnd, lpTable ptab) <br>{ <br>        RECT rc; <br>        HDC hdc; <br>        HPEN hpen; <br> <br>        hdc = GetDC(hwnd); <br>        SetROP2(hdc, R2_XORPEN); <br>        hpen = SelectObject(hdc, hpenDotted); <br>        GetClientRect(hwnd, &amp;rc); <br> <br>        MoveToEx(hdc, ptab-&gt;trackline1, rc.top, NULL); <br>        LineTo(hdc, ptab-&gt;trackline1, rc.bottom); <br>        if (ptab-&gt;trackline2 != -1) { <br>                MoveToEx(hdc, ptab-&gt;trackline2, rc.top, NULL); <br>                LineTo(hdc, ptab-&gt;trackline2, rc.bottom); <br>        } <br> <br>        SelectObject(hdc, hpen); <br>        ReleaseDC(hwnd, hdc); <br>} <br>         <br> <br>/*************************************************************************** <br> * Function: gtab_invertsel <br> * <br> * Purpose: <br> * <br> * Mark the selected line, if visible, in the style chosen by the <br> * client app. This can be TM_SOLID, meaning an inversion of <br> * the whole selected area or TM_FOCUS, meaning, inversion of the first <br> * cell, and then a dotted focus rectangle for the rest. <br> * <br> * This function inverts either style, and so will turn the selection <br> * both on and off. <br> */ <br>void <br>gtab_invertsel(HWND hwnd, lpTable ptab, HDC hdc_in) <br>{ <br>        HDC hdc; <br>        int line; <br>        RECT rc; <br>        int lastcell; <br> <br> <br>        /* is row visible on screen ?  */ <br>        line = gtab_rowtoline(hwnd, ptab, ptab-&gt;select.startrow); <br>        if (line &lt; 0) { <br>                return; <br>        } <br> <br>        /* selection mode includes a flag TM_FOCUS indicating we should <br>         * use a focus rect instead of the traditional inversion for <br>         * selections in this table. This interferes with multiple backgrnd <br>         * colours less.  However we still do inversion for fixedcols. <br>         */ <br> <br>        lastcell = (int)(ptab-&gt;select.startcell + ptab-&gt;select.ncells - 1); <br> <br>        rc.top = ptab-&gt;pdata[line].linepos.clipstart; <br>        rc.bottom = ptab-&gt;pdata[line].linepos.clipend; <br> <br>        /* <br>         * invert the whole area for TM_SOLID or just the first <br>         * cell for TM_FOCUS <br>         */ <br>        rc.left = ptab-&gt;pcellpos[ptab-&gt;select.startcell].clipstart; <br>        if (ptab-&gt;hdr.selectmode &amp; TM_FOCUS) { <br>                rc.right = ptab-&gt;pcellpos[ptab-&gt;select.startcell].clipend; <br>        }else { <br>                rc.right = ptab-&gt;pcellpos[lastcell].clipend; <br>        } <br> <br>        if (hdc_in == NULL) { <br>                hdc = GetDC(hwnd); <br>        } else { <br>                hdc = hdc_in; <br>        } <br> <br>        InvertRect(hdc, &amp;rc); <br> <br>        /* <br>         * draw focus rectangle around remaining cells on this line, if there <br>         * are any <br>         */ <br>        if (ptab-&gt;hdr.selectmode &amp; TM_FOCUS) { <br>                if (ptab-&gt;select.ncells &gt; 1) { <br>                        rc.left = ptab-&gt;pcellpos[ptab-&gt;select.startcell+1].clipstart; <br>                        rc.right = ptab-&gt;pcellpos[lastcell].clipend; <br>                        DrawFocusRect(hdc, &amp;rc); <br>                } <br>        } <br> <br>        if (hdc_in == NULL) { <br>                ReleaseDC(hwnd, hdc); <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
