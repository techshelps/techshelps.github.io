<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATUS.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5559"></a>STATUS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: STATUS.C <br>* <br>* Status line handler. <br>* <br>* Functions: <br>* <br>* StatusInit() <br>* StatusCreate() <br>* StatusHeight() <br>* StatusAlloc() <br>* StatusAddItem() <br>* StatusCreateTools() <br>* StatusDeleteTools() <br>* StatusWndProc() <br>* StatusResize() <br>* StatusCalcHeight() <br>* StatusCalcWidth() <br>* StatusGetItem() <br>* LowerRect() <br>* RaiseRect() <br>* StatusPaint() <br>* BottomRight() <br>* TopLeft() <br>* StatusButtonDown() <br>* StatusButtonUp() <br>* InitDC() <br>* <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "gutils.h" <br> <br> <br>/* --- data structures ------------------------------------------------- */ <br>#define SF_MAXLABEL     80   /* no more than 80 in an item within the bar */ <br>                             /* Is this adequate for long pathnames on a <br>                                hi-res screen? <br>                             */ <br> <br>typedef struct statel { <br>        int type;                       /* SF_BUTTON or SF_STATIC */ <br>        int flags;                      /* SF_VAR =&gt; variable width <br>                                           SF_LEFT=&gt; left aligned (else right) <br>                                           SF_RAISE=&gt; paint as 'raised' 3d rect <br>                                           SF_LOWER=&gt; paint as lowered 3D rect <br>                                           SF_SZMIN=&gt;together with SF_VAR <br>                                                     allows minimum size for <br>                                                     var sized item <br>                                           SF_SZMAX=&gt;see SZMIN and use nouse <br>                                        */ <br>        int id;                         /* control id */ <br>        int width;                      /* width of control in chars */ <br>        char text[SF_MAXLABEL+1];       /* null-term string for label */ <br> <br>        RECT rc;                        /* used by status.c */ <br>} STATEL, FAR * PSTATEL; <br> <br>typedef struct itemlist { <br>        int nitems; <br>        PSTATEL statels; <br> <br>        int selitem;                    /* used by status.c */ <br>        BOOL isselected;                /* used by status.c */ <br>} ILIST, FAR * PILIST; <br> <br>/* prototypes of routines in this module */ <br> <br>void StatusCreateTools(void); <br>void StatusDeleteTools(void); <br>long APIENTRY StatusWndProc(HWND, UINT, UINT, LONG); <br>void StatusResize(HWND hWnd, PILIST pilist); <br>int StatusCalcHeight(HWND hWnd, PSTATEL ip); <br>int StatusCalcWidth(HWND hWnd, PSTATEL ip); <br>PSTATEL StatusGetItem(PILIST plist, int id); <br>void LowerRect(HDC hDC, LPRECT rcp); <br>void RaiseRect(HDC hDC, LPRECT rcp); <br>void StatusPaint(HWND hWnd, PILIST iplistp); <br>void BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners); <br>void TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners); <br>void StatusButtonDown(HDC hDC, PSTATEL ip); <br>void StatusButtonUp(HDC hDC, PSTATEL ip); <br>void InitDC(HDC hdc); <br> <br> <br>/*--global data---------------------------------------------------------*/ <br> <br>HPEN hpenHilight, hpenLowlight; <br>HPEN hpenBlack, hpenNeutral; <br>HBRUSH hbrBackground; /* pieces and board */ <br>HFONT hFont; <br>int status_charheight, status_charwidth; <br> <br>/* default pt size for font (tenths of a pt) */ <br>#define         DEF_PTSIZE      80 <br> <br>/*************************************************************************** <br> * Function: StatusInit <br> * <br> * Purpose: <br> * <br> * Create window class <br> */ <br>BOOL <br>StatusInit(HANDLE hInstance) <br>{ <br>        WNDCLASS    wc; <br>        BOOL resp; <br>        TEXTMETRIC tm; <br>        HDC hDC; <br> <br> <br>        StatusCreateTools(); <br> <br>        wc.style = CS_HREDRAW|CS_VREDRAW|CS_GLOBALCLASS; <br>        wc.lpfnWndProc = (WNDPROC) StatusWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = sizeof(HANDLE); <br>        wc.hInstance = hInstance; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = hbrBackground; <br>        wc.lpszClassName = (LPSTR) "gdstatusclass"; <br>        wc.lpszMenuName = NULL; <br> <br>        resp = RegisterClass(&amp;wc); <br> <br>        hDC = GetDC(NULL); <br>        InitDC(hDC); <br>        GetTextMetrics(hDC, &amp;tm); <br>        status_charheight = (int)(tm.tmHeight + tm.tmExternalLeading); <br>        status_charwidth = (int)tm.tmAveCharWidth; <br>        ReleaseDC(NULL, hDC); <br> <br>        return(resp); <br>} <br> <br>/* <br>/*************************************************************************** <br> * Function: StatusCreate <br> * <br> * Purpose: <br> * <br> * Create and show the window <br> */ <br>HWND APIENTRY <br>StatusCreate(HANDLE hInst, HWND hParent, int id, LPRECT rcp, HANDLE hmem) <br>{ <br> <br>        HWND hWnd; <br> <br>        /* create a child window of status class */ <br> <br> <br>        hWnd = CreateWindow("gdstatusclass", <br>                        NULL, <br>                        WS_CHILD | WS_VISIBLE, <br>                        rcp-&gt;left, <br>                        rcp-&gt;top, <br>                        (rcp-&gt;right - rcp-&gt;left), <br>                        (rcp-&gt;bottom - rcp-&gt;top), <br>                        hParent, <br>                        (HANDLE) id, <br>                        hInst, <br>                        (LPVOID) hmem); <br> <br>        return(hWnd); <br>} <br> <br>/*************************************************************************** <br> * Function: StatusHeight <br> * <br> * Purpose: <br> * <br> * Return default height of this window  <br> */ <br>int APIENTRY <br>StatusHeight(HANDLE hmem) <br>/* The window has a number of items which are arranged horizontally, <br>   so the window height is the maximum of the individual heights <br>*/ <br>{ <br>        PILIST plist; <br>        int i; <br>        int sz; <br>        int maxsize = 0; <br> <br>        plist = (PILIST) GlobalLock(hmem); <br>        if (plist != NULL) { <br>                for (i = 0; i&lt;plist-&gt;nitems; i++) { <br>                        sz = StatusCalcHeight(NULL, &amp;plist-&gt;statels[i]); <br>                        maxsize = max(sz, maxsize); <br>                } <br>        } <br>        GlobalUnlock(hmem); <br>        if (maxsize &gt; 0) { <br>                return(maxsize + 4); <br>        } else { <br>                return(status_charheight + 4); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: StatusAlloc <br> * <br> * Purpose: <br> * <br> * Alloc the plist struct and return handle to caller  <br> */ <br>HANDLE FAR PASCAL <br>StatusAlloc(int nitems) <br>{ <br>        HANDLE hmem; <br>        PILIST pilist; <br>        LPSTR chp; <br> <br>        hmem = GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT, <br>                sizeof(ILIST) + (sizeof(STATEL) * nitems)); <br>        chp = GlobalLock(hmem); <br>        if (chp == NULL) { <br>                return(NULL); <br>        } <br> <br>        pilist = (PILIST) chp; <br>        pilist-&gt;nitems = nitems; <br>        pilist-&gt;statels = (PSTATEL) &amp;chp[sizeof(ILIST)]; <br>        GlobalUnlock(hmem); <br> <br>        return(hmem); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: StatusAddItem <br> * <br> * Purpose: <br> * <br> * Insert an item into the plist  <br> */ <br>BOOL FAR PASCAL <br>StatusAddItem(HANDLE hmem, int itemnr, int type, int flags, int id, <br>        int width, LPSTR text) <br>{ <br>        PILIST pilist; <br>        PSTATEL pel; <br> <br>        pilist = (PILIST) GlobalLock(hmem); <br>        if ((pilist == NULL) || (itemnr &gt;= pilist-&gt;nitems)) { <br>                GlobalUnlock(hmem); <br>                return(FALSE); <br>        } <br>        pel = &amp;pilist-&gt;statels[itemnr]; <br>        pel-&gt;type = type; <br>        pel-&gt;flags = flags; <br>        pel-&gt;id = id; <br>        pel-&gt;width = width; <br>        if (text == NULL) { <br>                pel-&gt;text[0] = '\0'; <br>        } else { <br>                lstrcpy(pel-&gt;text, text); <br>        } <br> <br> <br>        GlobalUnlock(hmem); <br>        return(TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: InitDC <br> * <br> * Purpose: <br> * <br> * Initialize colors and font <br> */  <br>void <br>InitDC(HDC hdc) <br>{ <br>        SetBkColor(hdc, RGB(192,192,192)); <br>        SelectObject(hdc, hbrBackground); <br>        SelectObject(hdc, hFont); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: StatusCreateTools <br> * <br> * Purpose: <br> * <br> * Create Pens and brushes <br> */  <br>void <br>StatusCreateTools() <br>{ <br>    LOGFONT lf; <br>    HDC hdc; <br>    int scale; <br> <br>    hbrBackground = CreateSolidBrush(RGB(192,192,192)); <br>    hpenHilight = CreatePen(0, 1, RGB(255, 255, 255)); <br>    hpenLowlight = CreatePen(0, 1, RGB(128, 128, 128)); <br>    hpenNeutral = CreatePen(0, 1, RGB(192, 192, 192)); <br>    hpenBlack = CreatePen(0, 1, RGB(0, 0, 0)); <br> <br>    hdc = GetDC(NULL); <br>    scale = GetDeviceCaps(hdc, LOGPIXELSY); <br>    ReleaseDC(NULL, hdc); <br> <br>    lf.lfHeight = -MulDiv(DEF_PTSIZE, scale, 720); <br>    lf.lfWidth = 0; <br>    lf.lfEscapement = 0; <br>    lf.lfOrientation = 0; <br>    lf.lfWeight = FW_REGULAR; <br>    lf.lfItalic = 0; <br>    lf.lfUnderline = 0; <br>    lf.lfStrikeOut = 0; <br>    lf.lfCharSet = ANSI_CHARSET; <br>    lf.lfOutPrecision = OUT_DEFAULT_PRECIS; <br>    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br>    lf.lfQuality = PROOF_QUALITY; <br>    lf.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS; <br>    lf.lfFaceName[0] = '\0'; <br>#ifdef COMPLEX <br>    hFont = CreateFontIndirect(&amp;lf); <br>#else <br>    hFont = GetStockObject(SYSTEM_FONT); <br>#endif <br> <br> <br> <br>} <br> <br>/*************************************************************************** <br> * Function: StatusDeleteTools <br> * <br> * Purpose: <br> * <br> * Delete brushes and pens <br> */ <br>void <br>StatusDeleteTools() <br>{ <br>    DeleteObject(hbrBackground); <br>    DeleteObject(hpenHilight); <br>    DeleteObject(hpenLowlight); <br>    DeleteObject(hpenBlack); <br>    DeleteObject(hpenNeutral); <br> <br>#ifdef COMPLEX <br>    DeleteObject(hFont); <br>#endif <br>} <br> <br>/*************************************************************************** <br> * Function: StatusWndProc <br> * <br> * Purpose: <br> * <br> * Main winproc for status windows <br> * <br> * handles create/destroy and paint requests <br> */ <br> <br>long FAR PASCAL <br>StatusWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam) <br>{ <br>    HANDLE hitems; <br>    PSTATEL ip; <br>    PILIST plist; <br>    CREATESTRUCT FAR * cp; <br>    int i; <br>    HDC hDC; <br>    RECT rc; <br>    POINT pt; <br> <br>    switch(message) { <br> <br>    case WM_CREATE: <br>        cp = (CREATESTRUCT FAR *) lParam; <br>        hitems = (HANDLE) (LONG) cp-&gt;lpCreateParams; <br>        SetWindowLong(hWnd, 0,  (LONG)hitems); <br>        plist = (PILIST) GlobalLock(hitems); <br>        if (plist != NULL) { <br>                plist-&gt;selitem = -1; <br>                GlobalUnlock(hitems); <br>        } <br>        break; <br> <br>    case WM_SIZE: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        plist = (PILIST) GlobalLock(hitems); <br>        if (plist != NULL) { <br>                StatusResize(hWnd, plist); <br>                GlobalUnlock(hitems); <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        plist = (PILIST) GlobalLock(hitems); <br>        StatusPaint(hWnd, plist); <br>        GlobalUnlock(hitems); <br> <br>        break; <br> <br>    case WM_LBUTTONUP: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        plist = (PILIST) GlobalLock(hitems); <br>        pt.x = LOWORD(lParam); <br>        pt.y = HIWORD(lParam); <br> <br>        if (plist == NULL) { <br>                break; <br>        } <br>        if (plist-&gt;selitem != -1) { <br>                ip = &amp;plist-&gt;statels[plist-&gt;selitem]; <br>                if (plist-&gt;isselected) { <br>                        hDC = GetDC(hWnd); <br>                        InitDC(hDC); <br>                        StatusButtonUp(hDC, ip); <br>                        ReleaseDC(hWnd, hDC); <br>                } <br>                plist-&gt;selitem = -1; <br>                ReleaseCapture(); <br>                if (PtInRect(&amp;ip-&gt;rc, pt)) { <br>                        SendMessage(GetParent(hWnd), WM_COMMAND, <br>                                MAKELONG(ip-&gt;id, WM_LBUTTONUP), (LONG)hWnd); <br>                } <br>        } <br>        GlobalUnlock(hitems); <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        plist = (PILIST) GlobalLock(hitems); <br>        if (plist == NULL) { <br>                break; <br>        } <br>        pt.x = LOWORD(lParam); <br>        pt.y = HIWORD(lParam); <br>        if (plist-&gt;selitem == -1) { <br>                for (i = 0; i&lt; plist-&gt;nitems; i++) { <br>                        ip = &amp;plist-&gt;statels[i]; <br>                        if (PtInRect(&amp;ip-&gt;rc, pt)) { <br>                                if (ip-&gt;type != SF_BUTTON) { <br>                                        break; <br>                                } <br>                                plist-&gt;selitem = i; <br>                                SetCapture(hWnd); <br> <br>                                plist-&gt;isselected = TRUE; <br>                                hDC = GetDC(hWnd); <br>                                InitDC(hDC); <br>                                StatusButtonDown(hDC, ip); <br>                                ReleaseDC(hWnd, hDC); <br>                                break; <br>                        } <br>                } <br>        } <br>        GlobalUnlock(hitems); <br>        break; <br> <br>    case WM_MOUSEMOVE: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        plist = (PILIST) GlobalLock(hitems); <br>        if (plist == NULL) { <br>                break; <br>        } <br>        pt.x = LOWORD(lParam); <br>        pt.y = HIWORD(lParam); <br>        if (plist-&gt;selitem != -1) { <br>                ip = &amp;plist-&gt;statels[plist-&gt;selitem]; <br>                if (PtInRect(&amp;ip-&gt;rc, pt)) { <br>                        if (!plist-&gt;isselected) { <br>                                hDC = GetDC(hWnd); <br>                                InitDC(hDC); <br>                                StatusButtonDown(hDC, ip); <br>                                ReleaseDC(hWnd, hDC); <br>                                plist-&gt;isselected = TRUE; <br>                        } <br>                } else { <br>                        if(plist-&gt;isselected) { <br>                                hDC = GetDC(hWnd); <br>                                InitDC(hDC); <br>                                StatusButtonUp(hDC, ip); <br>                                ReleaseDC(hWnd, hDC); <br>                                plist-&gt;isselected = FALSE; <br>                        } <br>                } <br>        } <br>        GlobalUnlock(hitems); <br>        break; <br> <br> <br>    case WM_DESTROY: <br> <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        GlobalUnlock(hitems); <br>        GlobalFree(hitems); <br> <br>        SetWindowLong(hWnd, 0, 0L); <br>        break; <br> <br>    case SM_NEW: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        if (hitems != NULL) { <br>                GlobalFree(hitems); <br>        } <br>        hitems = (HANDLE) wParam; <br>        if (hitems == NULL) { <br>                SetWindowLong(hWnd, 0, 0L); <br>                InvalidateRect(hWnd, NULL, TRUE); <br>                break; <br>        } <br>        plist = (PILIST) GlobalLock(hitems); <br>        if (plist == NULL) { <br>                SetWindowLong(hWnd, 0, 0L); <br>                InvalidateRect(hWnd, NULL, TRUE); <br>                break; <br>        } <br>        plist-&gt;selitem = -1; <br>        StatusResize(hWnd, plist); <br>        GlobalUnlock(hitems); <br>        SetWindowLong(hWnd, 0, (LONG)hitems); <br>        InvalidateRect(hWnd, NULL, TRUE); <br>        break; <br> <br>    case SM_SETTEXT: <br>        hitems = (HANDLE) GetWindowLong(hWnd, 0); <br>        if (hitems == NULL) { <br>                break; <br>        } <br>        plist = (PILIST) GlobalLock(hitems); <br>        ip = StatusGetItem(plist, wParam); <br>        if (ip != NULL) { <br>                if (lParam == 0) { <br>                        ip-&gt;text[0] = '\0'; <br>                } else { <br>                        strncpy(ip-&gt;text, (LPSTR) lParam, SF_MAXLABEL); <br>                        ip-&gt;text[SF_MAXLABEL] = '\0'; <br>                } <br> <br>                /* if this is a variable width field, we need to redo <br>                 * all size calcs in case the field width has changed. <br>                 * in that case, we need to repaint the entire window <br>                 * and not just this field - so set rc to indicate the <br>                 * area to be redrawn. <br>                 */ <br>                if (ip-&gt;flags &amp; SF_VAR) { <br>                        StatusResize(hWnd, plist); <br>                        GetClientRect(hWnd, &amp;rc); <br>                        RedrawWindow(hWnd, &amp;rc, NULL, <br>                                RDW_INVALIDATE|RDW_ERASE|RDW_UPDATENOW); <br>                } else { <br>                        /* instead of just invalidating the window, we can <br>                         * force the window to be repainted now. This is <br>                         * essential for status updates during a busy <br>                         * loop when no messages are being processed, <br>                         * but we should still update the user on what's <br>                         * happening. <br>                         */ <br>                        RedrawWindow(hWnd, &amp;ip-&gt;rc, NULL, <br>                                RDW_INVALIDATE|RDW_NOERASE|RDW_UPDATENOW); <br>                } <br> <br>        } <br>        GlobalUnlock(hitems); <br>        break; <br> <br>    default: <br>        return(DefWindowProc(hWnd, message, wParam, lParam)); <br>    } <br>    return 0; <br>} <br> <br>/*************************************************************************** <br> * Function: StatusResize <br> * <br> * Purpose: <br> * <br> * Position the labels and buttons within the status window  <br> */ <br>void <br>StatusResize(HWND hWnd, PILIST iplistp) <br>{ <br>        RECT rc; <br>        int curpos_right, curpos_left; <br>        int height, width; <br>        int i; <br>        PSTATEL ip; <br> <br> <br>        if (iplistp == NULL) { <br>                return; <br>        } <br>        GetClientRect(hWnd, &amp;rc); <br>        curpos_left = rc.left + status_charwidth / 2; <br>        curpos_right = rc.right - (status_charwidth / 2); <br> <br>        /* loop through all items setting their position rects. <br>         * items are flagged as being left or right. We place them <br>         * in order starting at the left and the right, with a single <br>         * char's width between each item <br>         */ <br>        for (i = 0; i &lt; iplistp-&gt;nitems; i++) { <br>                ip = &amp;iplistp-&gt;statels[i]; <br> <br>                width = StatusCalcWidth(hWnd, ip); <br>                height = StatusCalcHeight(hWnd, ip); <br>                ip-&gt;rc.top = (rc.bottom - height) / 2; <br>                ip-&gt;rc.bottom = ip-&gt;rc.top + height; <br> <br>                /* see if  this item fits. Items that partially fit <br>                 * are placed reduced in size. <br>                 */ <br>                if (ip-&gt;flags &amp; SF_LEFT) { <br> <br>                        if (curpos_left+width &gt;= curpos_right) { <br>                                /* doesn't completely fit-does it partly? */ <br>                                if ((curpos_left + 1) &gt;= curpos_right){ <br> <br>                                        /* no - this item does not fit */ <br>                                        ip-&gt;rc.left = 0; <br>                                        ip-&gt;rc.right = 0; <br>                                } else { <br>                                        /* partial fit */ <br>                                        ip-&gt;rc.left = curpos_left; <br>                                        ip-&gt;rc.right = curpos_right - 1; <br>                                        curpos_left = curpos_right; <br>                                } <br>                        } else { <br>                                /* complete fit */ <br>                                ip-&gt;rc.left = curpos_left; <br>                                ip-&gt;rc.right = curpos_left + width; <br>                                curpos_left += width + 1; <br>                        } <br>                } else { <br> <br>                        /* same size check for right-aligned items */ <br>                        if (curpos_right-width &lt;= curpos_left) { <br> <br>                                /* partial fit ? */ <br>                                if (curpos_right &lt;= curpos_left+1) { <br>                                        ip-&gt;rc.left = 0; <br>                                        ip-&gt;rc.right = 0; <br>                                } else { <br>                                        /* yes - partial fit */ <br>                                        ip-&gt;rc.left = curpos_left + 1; <br>                                        ip-&gt;rc.right = curpos_right; <br>                                        curpos_right = curpos_left; <br>                                } <br>                        } else { <br>                                /* complete fit */ <br>                                ip-&gt;rc.right = curpos_right; <br>                                ip-&gt;rc.left = curpos_right - width; <br>                                curpos_right -= (width + 1); <br>                        } <br>                } <br>        } <br>} <br> <br> <br>/*************************************************************************** <br> * Function: StatusPaint <br> * <br> * Purpose: <br> * <br> * Paint the status window <br> */ <br>void <br>StatusPaint(HWND hWnd, PILIST iplistp) <br>{ <br>        RECT rc; <br>        HDC hDC; <br>        PAINTSTRUCT ps; <br>        int i; <br>        PSTATEL ip; <br>        HPEN hpenOld; <br> <br>        GetClientRect(hWnd, &amp;rc); <br>        hDC = BeginPaint(hWnd, &amp;ps); <br>        InitDC(hDC); <br> <br>        RaiseRect(hDC, &amp;rc); <br>        if (iplistp == NULL) { <br>                EndPaint(hWnd, &amp;ps); <br>                return; <br>        } <br>        for (i =0; i &lt; iplistp-&gt;nitems; i++) { <br>                ip = &amp;iplistp-&gt;statels[i]; <br> <br>                if (ip-&gt;rc.left == ip-&gt;rc.right) { <br>                        continue; <br>                } <br>                if (ip-&gt;type == SF_STATIC) { <br>                        if (ip-&gt;flags &amp; SF_RAISE) { <br>                                RaiseRect(hDC, &amp;ip-&gt;rc); <br>                        } else if (ip-&gt;flags &amp; SF_LOWER) { <br>                                LowerRect(hDC, &amp;ip-&gt;rc); <br>                        } <br>                        rc = ip-&gt;rc; <br>                        rc.left += (status_charwidth / 2); <br>                        rc.right--; <br>                        rc.top++; <br>                        rc.bottom--; <br>                        hpenOld = SelectObject(hDC, hpenNeutral); <br>                        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom); <br>                        SelectObject(hDC, hpenOld); <br>                        DrawText(hDC, ip-&gt;text, lstrlen(ip-&gt;text), &amp;rc, <br>                                        DT_LEFT | DT_VCENTER); <br>                } else { <br>                        StatusButtonUp(hDC, ip); <br>                } <br>        } <br> <br>        EndPaint(hWnd, &amp;ps); <br>} <br> <br>/*************************************************************************** <br> * Function: RaiseRect <br> * <br> * Purpose: <br> * <br> */ <br>void <br>RaiseRect(HDC hDC, LPRECT rcp) <br>{ <br>        TopLeft(hDC, rcp, hpenHilight, FALSE); <br>        BottomRight(hDC, rcp, hpenLowlight, FALSE); <br>} <br> <br>/*************************************************************************** <br> * Function: LowerRect <br> * <br> * Purpose: <br> * <br> */  <br>void <br>LowerRect(HDC hDC, LPRECT rcp) <br>{ <br>        TopLeft(hDC, rcp, hpenLowlight, FALSE); <br>        BottomRight(hDC, rcp, hpenHilight, FALSE); <br>} <br> <br>/*************************************************************************** <br> * Function: StatusButtonUp <br> * <br> * Purpose: <br> * <br> */ <br>void <br>StatusButtonUp(HDC hDC, PSTATEL ip) <br>{ <br>        RECT rc; <br>        HPEN hpenOld; <br> <br>        rc = ip-&gt;rc; <br>        TopLeft(hDC, &amp;rc, hpenBlack, TRUE); <br>        BottomRight(hDC, &amp;rc, hpenBlack, FALSE); <br> <br>        rc.top++; <br>        rc.bottom--; <br>        rc.left++; <br>        rc.right--; <br>        TopLeft(hDC, &amp;rc, hpenHilight, FALSE); <br>        BottomRight(hDC, &amp;rc, hpenLowlight, TRUE); <br> <br>        rc.top++; <br>        rc.bottom--; <br>        rc.left++; <br>        rc.right--; <br>        BottomRight(hDC, &amp;rc, hpenLowlight, TRUE); <br>        rc.bottom--; <br>        rc.right--; <br>        hpenOld = SelectObject(hDC, hpenNeutral); <br>        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom); <br>        SelectObject(hDC, hpenOld); <br>        DrawText(hDC, ip-&gt;text, lstrlen(ip-&gt;text), &amp;rc, DT_CENTER | DT_VCENTER); <br>} <br> <br>/*************************************************************************** <br> * Function: StatusButtonDown <br> * <br> * Purpose: <br> * <br> */ <br>void <br>StatusButtonDown(HDC hDC, PSTATEL ip) <br>{ <br>        RECT rc; <br>        HPEN hpenOld; <br> <br>        rc = ip-&gt;rc; <br>        TopLeft(hDC, &amp;rc, hpenBlack, TRUE); <br>        BottomRight(hDC, &amp;rc, hpenBlack, FALSE); <br> <br>        rc.top++; <br>        rc.bottom--; <br>        rc.left++; <br>        rc.right--; <br>        TopLeft(hDC, &amp;rc, hpenLowlight, TRUE); <br>        rc.top++; <br>        rc.left++; <br>        TopLeft(hDC, &amp;rc, hpenNeutral, TRUE); <br>        rc.top++; <br>        rc.left++; <br>        TopLeft(hDC, &amp;rc, hpenNeutral, TRUE); <br>        rc.top++; <br>        rc.left++; <br>        hpenOld = SelectObject(hDC, hpenNeutral); <br>        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom); <br>        SelectObject(hDC, hpenOld); <br>        DrawText(hDC, ip-&gt;text, lstrlen(ip-&gt;text), &amp;rc, DT_CENTER | DT_VCENTER); <br>} <br> <br>/*************************************************************************** <br> * Function: TopLeft <br> * <br> * Purpose: <br> * <br> */ <br>void <br>TopLeft(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners) <br>{ <br>        HPEN hpenOld; <br>        int x, y; <br> <br>        hpenOld = SelectObject(hDC, hpen); <br>        x = rcp-&gt;right - 1; <br>        y = rcp-&gt;bottom; <br>        if (!bCorners) { <br>                x--; <br>                y--; <br>        } <br>        MoveToEx(hDC, x, rcp-&gt;top, NULL); <br>        LineTo(hDC, rcp-&gt;left, rcp-&gt;top); <br>        LineTo(hDC, rcp-&gt;left, y); <br>        SelectObject(hDC, hpenOld); <br>} <br> <br>/*************************************************************************** <br> * Function: BottomRight <br> * <br> * Purpose: <br> * <br> */ <br>void <br>BottomRight(HDC hDC, LPRECT rcp, HPEN hpen, BOOL bCorners) <br>{ <br>        HPEN hpenOld; <br>        int x, y; <br> <br>        hpenOld = SelectObject(hDC, hpen); <br>        x = rcp-&gt;left - 1; <br>        y = rcp-&gt;top; <br>        if (!bCorners) { <br>                x++; <br>                y++; <br>        } <br>        MoveToEx(hDC, rcp-&gt;right-1, y, NULL); <br>        LineTo(hDC, rcp-&gt;right-1, rcp-&gt;bottom-1); <br>        LineTo(hDC, x, rcp-&gt;bottom-1); <br>        SelectObject(hDC, hpenOld); <br>} <br> <br>/*************************************************************************** <br> * Function: StatusGetItem <br> * <br> * Purpose: <br> * <br> */ <br>PSTATEL <br>StatusGetItem(PILIST plist, int id) <br>{ <br>        int i; <br> <br>        if (plist == NULL) { <br>                return(NULL); <br>        } <br>        for (i = 0; i &lt; plist-&gt;nitems; i++) { <br>                if (plist-&gt;statels[i].id == id) { <br>                        return(&amp;plist-&gt;statels[i]); <br>                } <br>        } <br>        return(NULL); <br>} <br> <br>/*************************************************************************** <br> * Function: StatusCalcWidth <br> * <br> * Purpose: <br> * <br> * Calculate the width of a given field. This is the width in characters <br> * multiplied by the average character width, plus a few units for <br> * borders. <br> * <br> * If SF_VAR is set, this field size varies depending on the text, so <br> * we use GetTextExtent for the field size. If SF_VAR is selected, the caller <br> * can specify that the size is not to exceed the (width * avecharwidth) <br> * size (using SF_SZMAX) or that it is not be less than it (SF_SZMIN). <br> */ <br>int <br>StatusCalcWidth(HWND hWnd, PSTATEL ip) <br>{ <br>        int ch_size, t_size; <br>        SIZE sz; <br>        HDC hDC; <br> <br>        ch_size = ip-&gt;width * status_charwidth; <br>        if (ip-&gt;flags &amp; SF_VAR) { <br>                hDC = GetDC(hWnd); <br>                InitDC(hDC); <br>                GetTextExtentPoint(hDC, ip-&gt;text, lstrlen(ip-&gt;text), &amp;sz); <br>                ReleaseDC(hWnd, hDC); <br>                t_size = sz.cx; <br> <br>                /* <br>                 * check this size against min/max size if <br>                 * requested <br>                 */ <br> <br>                if (ip-&gt;flags &amp; SF_SZMIN) { <br>                        if (ch_size &gt; t_size) { <br>                                t_size = ch_size; <br>                        } <br>                } <br>                if (ip-&gt;flags &amp; SF_SZMAX) { <br>                        if (ch_size &lt; t_size) { <br>                                t_size = ch_size; <br>                        } <br>                } <br>                ch_size = t_size; <br>        } <br> <br>        if (ch_size != 0) { <br>                if (ip-&gt;type == SF_BUTTON) { <br>                        return(ch_size+6); <br>                } else { <br>                        return(ch_size+4); <br>                } <br>        } else { <br>                return(0); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: StatusCalcHeight <br> * <br> * Purpose: <br> * <br> * Calculate the height of a given field <br> */ <br>int <br>StatusCalcHeight(HWND hWnd, PSTATEL ip) </code></pre>
<p>
</p>
<pre><code>{ <br>        int size; <br> <br>        size = status_charheight; <br>        if (ip-&gt;type == SF_BUTTON) { <br>                return(size + 6); <br>        } else { <br>                return(size + 2); <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
