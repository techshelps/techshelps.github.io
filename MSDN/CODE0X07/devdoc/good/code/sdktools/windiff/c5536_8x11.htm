<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GMEM.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5545"></a>GMEM.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: GMEM.C <br>* <br>* Memory utility functions. <br>* <br>* Functions: <br>* <br>* gmem_panic() <br>* gmem_init() <br>* gmem_get() <br>* gmem_free() <br>* gmem_freeall() <br>* <br>* Comments: <br>* <br>* Global heap functions - allocate and free many small <br>* pieces of memory by calling global alloc for large pieces <br>* and breaking them up. A heap contains a critical section, so <br>* multiple simultaneous calls to gmem_get and gmem_free will be <br>* protected. <br>* <br>* gmem_freeall should not be called until all other users have finished <br>* with the heap. <br>* <br>* Out-of-memory is not something we regard as normal. <br>* If we cannot allocate memory - we put up an abort-retry-ignore <br>* error, and only return from the function if the user selects ignore. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#include "gutils.h" <br>#include "gutilsrc.h" <br> <br>int gmem_panic(void); <br> <br> <br>/* ensure BLKSIZE is multiple of sizeof(DWORD) */ <br>#define BLKSIZE         64               /* blk size in bytes */ <br>#define ALLOCSIZE       32768 <br>#define NBLKS           (ALLOCSIZE / BLKSIZE) <br>#define MAPSIZE         (NBLKS / 8) <br>#define MAPLONGS        (MAPSIZE / sizeof(DWORD)) <br>#define TO_BLKS(x)      (((x) + BLKSIZE - 1) / BLKSIZE) <br> <br>typedef struct seghdr { <br>        HANDLE hseg; <br>        CRITICAL_SECTION critsec; <br>        struct seghdr FAR * pnext; <br>        long nblocks; <br>        DWORD segmap[MAPLONGS]; <br>} SEGHDR, FAR * SEGHDRP; <br> <br> <br>/* anything above this size, we alloc directly from global heap */ <br>#define MAXGALLOC       20000 <br> <br> <br>/*************************************************************************** <br> * Function: gmem_init <br> * <br> * Purpose: <br> * <br> * init heap - create first segment <br> */ <br>HANDLE APIENTRY <br>gmem_init(void) <br>{ <br>        HANDLE hNew; <br>        SEGHDRP hp; <br> <br>        /* retry all memory allocations after calling gmem_panic */ <br>        do { <br>                hNew = GlobalAlloc(GHND, ALLOCSIZE); <br>                if (hNew == NULL) { <br>                        if (gmem_panic() == IDIGNORE) { <br>                                return(NULL); <br>                        } <br>                } <br>        } while  (hNew == NULL); <br> <br>        hp = (SEGHDRP) GlobalLock(hNew); <br>        if (hp == NULL) { <br>                return(NULL); <br>        } <br>        hp-&gt;hseg = hNew; <br>        InitializeCriticalSection(&amp;hp-&gt;critsec); <br>        hp-&gt;pnext = NULL; <br>        gbit_init(hp-&gt;segmap, NBLKS); <br>        gbit_alloc(hp-&gt;segmap, 1, TO_BLKS(sizeof(SEGHDR))); <br>        hp-&gt;nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR)); <br> <br>        return(hNew); <br>} <br> <br>/*************************************************************************** <br> * Function: gmem_get <br> * <br> * Purpose: <br> * <br> * Get memory from heap <br> */ <br>LPSTR APIENTRY <br>gmem_get(HANDLE hHeap, int len) <br>{ <br>        SEGHDRP chainp; <br>        HANDLE hNew; <br>        SEGHDRP hp; <br>        LPSTR chp; <br>        long nblks; <br>        long start; <br>        long nfound; <br> <br> <br>        /* the heap is always locked (in gmem_init)- so having got the <br>         * pointer, we can always safely unlock it <br>         */ <br>        chainp = (SEGHDRP) GlobalLock(hHeap); <br>        GlobalUnlock(hHeap); <br> <br>        if (len &lt; 1) { <br>                return(NULL); <br>        } <br> <br>        /* <br>         * too big to be worth allocing from heap - get from globalalloc <br>         */ <br>        if (len &gt; MAXGALLOC) { <br>                /* retry all memory allocations after calling gmem_panic */ <br>                do { <br>                        hNew = GlobalAlloc(GHND, len); <br>                        if (hNew == NULL) { <br>                                if (gmem_panic() == IDIGNORE) { <br>                                        return(NULL); <br>                                } <br>                        } <br>                } while  (hNew == NULL); <br> <br>                chp = GlobalLock(hNew); <br>                if (chp == NULL) { <br>                        return(NULL); <br>                } <br>                return(chp); <br>        } <br> <br> <br>        /* <br>         * get critical section during all access to the heap itself <br>         */ <br>        EnterCriticalSection(&amp;chainp-&gt;critsec); <br> <br>        nblks = TO_BLKS(len + sizeof(HANDLE)); <br> <br>        for (hp = chainp; hp !=NULL; hp = hp-&gt;pnext) { <br>                if (hp-&gt;nblocks &gt;= nblks) { <br>                        nfound = gbit_findfree(hp-&gt;segmap, nblks,NBLKS, &amp;start); <br>                        if (nfound &gt;= nblks) { <br>                                gbit_alloc(hp-&gt;segmap, start, nblks); <br>                                hp-&gt;nblocks -= nblks; <br> <br>                                /* convert blocknr to pointer <br>                                 * store seg handle in block <br>                                 */ <br>                                chp = (LPSTR) hp; <br>                                chp = &amp;chp[ (start-1) * BLKSIZE]; <br>                                * ( (HANDLE FAR *) chp) = hp-&gt;hseg; <br>                                chp += sizeof(HANDLE); <br> <br>                                break; <br>                        } <br>                } <br>        } <br>        if (hp == NULL) { <br>                /* retry all memory allocations after calling gmem_panic */ <br>                do { <br>                        hNew = GlobalAlloc(GHND, ALLOCSIZE); <br>                        if (hNew == NULL) { <br>                                if (gmem_panic() == IDIGNORE) { <br>                                        LeaveCriticalSection(&amp;chainp-&gt;critsec); <br>                                        return(NULL); <br>                                } <br>                        } <br>                } while  (hNew == NULL); <br> <br>                hp = (SEGHDRP) GlobalLock(hNew); <br>                if (hp == NULL) { <br>                        LeaveCriticalSection(&amp;chainp-&gt;critsec); <br>                        return(NULL); <br>                } <br>                hp-&gt;pnext = chainp-&gt;pnext; <br>                hp-&gt;hseg = hNew; <br>                chainp-&gt;pnext = hp; <br>                gbit_init(hp-&gt;segmap, NBLKS); <br>                gbit_alloc(hp-&gt;segmap, 1, TO_BLKS(sizeof(SEGHDR))); <br>                hp-&gt;nblocks = NBLKS - TO_BLKS(sizeof(SEGHDR)); <br>                nfound = gbit_findfree(hp-&gt;segmap, nblks, NBLKS, &amp;start); <br>                if (nfound &gt;= nblks) { <br>                        gbit_alloc(hp-&gt;segmap, start, nblks); <br>                        hp-&gt;nblocks -= nblks; <br> <br>                        /* convert block nr to pointer */ <br>                        chp = (LPSTR) hp; <br>                        chp = &amp;chp[ (start-1) * BLKSIZE]; <br>                        /* add a handle into the block and skip past */ <br>                        * ( (HANDLE FAR *) chp) = hp-&gt;hseg; <br>                        chp += sizeof(HANDLE); <br>                } <br>        } <br>        LeaveCriticalSection(&amp;chainp-&gt;critsec); <br>        memset(chp, 0, len); <br>        return(chp); <br>} <br> <br>/*************************************************************************** <br> * Function: gmem_free <br> * <br> * Purpose: <br> * <br> * Free memory alloced <br> */ <br>void APIENTRY <br>gmem_free(HANDLE hHeap, LPSTR ptr, int len) <br>{ <br>        SEGHDRP chainp; <br>        SEGHDRP hp; <br>        HANDLE hmem; <br>        long nblks, blknr; <br>        LPSTR chp; <br> <br>        if (len &lt; 1) { <br>                return; <br>        } <br> <br>        /* <br>         * allocs greater than MAXGALLOC are too big to be worth <br>         * allocing from the heap - they will have been allocated <br>         * directly from globalalloc <br>         */ <br>        if (len &gt; MAXGALLOC) { <br>                hmem = GlobalHandle( (LPSTR) ptr); <br>                GlobalUnlock(hmem); <br>                GlobalFree(hmem); <br>                return; <br>        } <br> <br>        chainp = (SEGHDRP) GlobalLock(hHeap); <br>        EnterCriticalSection(&amp;chainp-&gt;critsec); <br> <br> <br>        /* just before the ptr we gave the user, is the handle to <br>         * the block <br>         */ <br>        chp = (LPSTR) ptr; <br>        chp -= sizeof(HANDLE); <br>        hmem = * ((HANDLE FAR *) chp); <br>        hp = (SEGHDRP) GlobalLock(hmem); <br> <br>        nblks = TO_BLKS(len + sizeof(HANDLE)); <br> <br>        /* convert ptr to block nr */ <br>        blknr = TO_BLKS( (unsigned) (chp - (LPSTR) hp) ) + 1; <br> <br>        gbit_free(hp-&gt;segmap, blknr, nblks); <br>        hp-&gt;nblocks += nblks; <br> <br>        GlobalUnlock(hmem); <br> <br>   LeaveCriticalSection(&amp;chainp-&gt;critsec); <br>        GlobalUnlock(hHeap); <br> <br>} <br> <br>/*************************************************************************** <br> * Function: gmem_freeall <br> * <br> * Purpose: <br> * <br> * Free heap <br> */ <br>void APIENTRY <br>gmem_freeall(HANDLE hHeap) <br>{ <br>        SEGHDRP chainp; <br>        HANDLE hSeg; <br> <br>        chainp = (SEGHDRP) GlobalLock(hHeap); <br>        /* this segment is always locked - so we need to unlock <br>         * it here as well as below <br>         */ <br>        GlobalUnlock(hHeap); <br> <br>        /* finished with the critical section  - <br>         * caller must ensure that at this point there is no <br>         * longer any contention <br>         */ <br>        DeleteCriticalSection(&amp;chainp-&gt;critsec); <br> <br>        while (chainp != NULL) { <br>                hSeg = chainp-&gt;hseg; <br>                chainp = chainp-&gt;pnext; <br>                GlobalUnlock(hSeg); <br>                GlobalFree(hSeg); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gmem_panic <br> * <br> * Purpose: <br> * <br> * A memory allocation attempt has failed. Return IDIGNORE to ignore the <br> * error and return NULL to the caller, and IDRETRY to retry the allocation <br> * attempt. <br> */ <br>int <br>gmem_panic(void) <br>{ <br>        int code; <br>    extern HANDLE hLibInst; <br>TCHAR szBuf1[512]; <br>    TCHAR szBuf2[512]; <br> <br>        LoadString(hLibInst, IDS_MEMORY_ALLOC_FAIL, szBuf1, sizeof(szBuf1)); <br>        LoadString(hLibInst, IDS_OUT_OF_MEMORY, szBuf2, sizeof(szBuf2)); <br> <br>        code = MessageBox(NULL, szBuf1, szBuf2, <br>                        MB_ICONSTOP|MB_ABORTRETRYIGNORE); <br>        if (code == IDABORT) { <br>                /* abort this whole process */ <br>                ExitProcess(1); <br>        } else { <br>                return(code); <br>        } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
