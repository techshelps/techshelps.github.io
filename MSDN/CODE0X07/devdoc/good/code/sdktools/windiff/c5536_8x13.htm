<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GUTILS.H</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5547"></a>GUTILS.H</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/* <br> * GUTILS.H <br> */ <br> <br>/* win32 msg crackers */ <br>#define GET_WM_COMMAND_ID(w, l) (LOWORD(w)) <br>#define GET_WM_COMMAND_CMD(w, l) (HIWORD(w)) <br>#define GET_WM_COMMAND_HWND(w, l) (l) <br>#define GET_SCROLL_OPCODE(w, l)     (LOWORD(w)) <br>#define GET_SCROLL_POS(w, l)        (HIWORD(w)) <br> <br>/* ------- memory allocator ------------------------------------------*/ <br>HANDLE APIENTRY gmem_init(void); <br>LPSTR APIENTRY gmem_get(HANDLE hHeap, int len); <br>void APIENTRY gmem_free(HANDLE hHeap, LPSTR ptr, int len); <br>void APIENTRY gmem_freeall(HANDLE hHeap); <br> <br> <br>/* --------- date conversion functions    -----------------------*/ <br>void APIENTRY gdate_daytodmy(LONG days, <br>        int FAR* yrp, int FAR* monthp, int FAR* dayp); <br>LONG APIENTRY gdate_dmytoday(int yr, int month, int day); <br>int APIENTRY gdate_monthdays(int month, int year); <br>int APIENTRY gdate_weekday(long daynr); <br> <br> <br>/* --- status line window class ---------------------------------- */ <br>/* The status line is a bar across the top or bottom of the window. <br> * It can hold a number of fields which can be either static text <br> * or buttons.  The so called "static" text can be changed at any time. <br> * The fields can be left or right aligned (default is RIGHT). <br> * If the text is marked as VAR then the screen real estate allocated <br> * for it will be adjusted whenever the text changes.  VAR fields <br> * can be given minimum or maximum sizes (but not both). <br> * <br> * STATIC text fields can be drawn as raised or lowered rectangles (using <br> * shades of grey), or (default) without a border. BUTTON fields will <br> * always be drawn as raised rectangles, and will lower when pressed. <br> * <br> * Button fields will send WM_COMMAND messages when clicked including the <br> * field id and the WM_LBUTTONUP notification code. Note that that this <br> * is not a full implementation of the button class, and no other messages <br> * will be sent. In general, none of the fields of a status bar are <br> * implemented as separate windows, so GetDlgItem() and similar calls will not <br> * work. Buttons only respond to mouse down events, and there is no handling <br> * of the focus or of keyboard events. <br> * <br> * To use: <br> *    call StatusAlloc giving the number of items you are going to add to the <br> *    status bar. This returns a handle to use in subsequent calls. <br> * <br> *    Then call StatusAddItem to define each item in turn. <br> *    Buttons are placed in order of definition along the bar starting from <br> *    the left (SF_LEFT) and from the right (SF_RIGHT) until the two <br> *    sides meet. <br> * <br> *    Call StatusHeight to find the expected height of this status bar, and <br> *    set its position within the parent window, then call StatusCreate to <br> *    create the window. <br> * <br> * Having created the window, send SM_SETTEXT messages to set the new <br> * text of a field (static or button), or SM_NEW with a handle (obtained from <br> * StatusAlloc) to change the contents of the status line. <br> */ <br> <br>/* values for type argument to StatusAddItem */ <br>#define SF_BUTTON       1 <br>#define SF_STATIC       2 <br> <br>/* bits in flags argument to StatusAddItem */ <br>#define SF_RAISE        1       /* paint static as raised 3D rectangle */ <br>#define SF_LOWER        2       /* paint static as lowered 3D rectangle */ <br>#define SF_LEFT         4       /* align field on left of status bar */ <br>#define SF_RIGHT        8       /* align field on right (DEFAULT) */ <br>#define SF_VAR          0x10    /* size of field depends on actual text extent*/ <br>#define SF_SZMAX        0x20    /* (with SF_VAR): width argument is maximum */ <br>#define SF_SZMIN        0x40    /* (with SF_VAR) width arg is minimum size */ <br> <br>HWND APIENTRY StatusCreate(HANDLE hInst, HWND hParent, int id, <br>                LPRECT rcp, HANDLE hmem); <br>int APIENTRY StatusHeight(HANDLE hmem); <br>HANDLE APIENTRY StatusAlloc(int nitems); <br>BOOL APIENTRY StatusAddItem(HANDLE hmem, int itemnr, int type, int flags, <br>        int id, int width, LPSTR text); <br> <br>/* send these window messages to the class */ <br> <br>#define SM_NEW          (WM_USER+1)     /* wParam handle for new status line */ <br>#define SM_SETTEXT      (WM_USER+2)     /* wparam: item id, lparam new label*/ <br> <br>void APIENTRY gbit_init(DWORD FAR * map, long nblks); <br>BOOL APIENTRY gbit_alloc(DWORD FAR * map, long blknr, long nblks); <br>BOOL APIENTRY gbit_free(DWORD FAR * map, long blknr, long nblks); <br>long APIENTRY gbit_findfree(DWORD FAR* map, long nblks, <br>                long mapsize, long FAR * blknr); <br> <br> <br>/* ----- buffered line input ----------------------------------*/ <br> /* handle to a file buffer */ <br>typedef struct filebuffer * FILEBUFFER; <br> <br>FILEBUFFER APIENTRY readfile_new(int fh); <br>LPSTR APIENTRY readfile_next(FILEBUFFER fb, int FAR * plen); <br>void APIENTRY readfile_delete(FILEBUFFER fb); <br> <br>LPTSTR APIENTRY LoadRcString(UINT); <br>LPTSTR APIENTRY LoadRcString2(UINT); <br> <br>/* ------ hashing  ------------------------------------------- */ <br>DWORD APIENTRY hash_string(LPSTR string, BOOL bIgnoreBlanks); <br>BOOL APIENTRY utils_isblank(LPSTR string); <br>int APIENTRY utils_CompPath(LPSTR left, LPSTR right); <br> <br>/* --- simple input ------------------------------------------------------*/ <br>int APIENTRY StringInput(LPSTR result, int resultsize, LPSTR prompt, <br>                         LPSTR caption, LPSTR def_input); <br> <br>// DBCS friendly versions of string library functions <br>// These are for both WINDIFF.EXE and GUTILS.DLL. <br>#define strchr          My_mbschr <br>#define Old_strncpystrncpy <br>#define strncpy         My_mbsncpy <br>unsigned char * _CRTAPI1 My_mbschr(unsigned char *, unsigned short); <br>unsigned char * _CRTAPI1 My_mbsncpy( <br>                unsigned char *, const unsigned char *, size_t); <br> <br>// These are for WINDIFF.EXE. <br>#define strrchr         My_mbsrchr <br>#define strncmp         My_mbsncmp <br>unsigned char * _CRTAPI1 My_mbsrchr(unsigned char *, unsigned short); <br>int _CRTAPI1 My_mbsncmp(const unsigned char *, const unsigned char *, size_t); </code></pre>
<p>&nbsp;</p></body>
</HTML>
