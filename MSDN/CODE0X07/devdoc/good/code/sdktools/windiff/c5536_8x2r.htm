<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BAR.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5553"></a>BAR.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: BAR.C <br>* <br>* This module contains functions for bar window  <br>* graphically showing two lists of sections and showing  <br>* colored vertical bars for the sections of text, <br>* with linking lines for the sections that are the same. <br>* <br>* Functions: <br>* <br>* BarWndProc() <br>* BarPaint() <br>* DrawSection() <br>* DrawLink() <br>* BarClick()  <br>* InitBarClass() <br>* BarDrawPosition() <br>*  <br>* Comments: <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "gutils.h" <br>#include "table.h" <br>#include "state.h" <br>#include "wdiffrc.h" <br>#include "windiff.h" <br>#include "list.h" <br>#include "line.h" <br>#include "scandir.h" <br>#include "file.h" <br>#include "section.h" <br>#include "compitem.h" <br>#include "complist.h" <br>#include "view.h" <br> <br> <br>long APIENTRY BarWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam); <br>void BarPaint(HWND hwnd); <br>void DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode); <br>void DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec); <br>void BarClick(HWND hwnd, int x, int y); <br> <br> <br>HPEN hpenSame, hpenLeft, hpenRight; <br>HBRUSH hbrSame, hbrLeft, hbrRight; <br>HBRUSH hbrSideBar; <br> <br> <br>/*************************************************************************** <br> * Function: InitBarClass <br> * <br> * Purpose: <br> * <br> * Create bar window class <br> */ <br>BOOL <br>InitBarClass(HINSTANCE hInstance) <br>{ <br>        WNDCLASS    wc; <br>        BOOL resp; <br> <br> <br> <br>        wc.style = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc = BarWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = hInstance; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>        wc.lpszClassName = "BarClass"; <br>        wc.lpszMenuName = NULL; <br> <br>        resp = RegisterClass(&amp;wc); <br> <br>        return(resp); <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: BarWndProc <br> * <br> * Purpose: <br> * <br> * Window procedure supporting bar window <br> * <br> */ <br> <br>long APIENTRY <br>BarWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam) <br>{ <br> <br>        switch(message) { <br> <br> <br>        case WM_CREATE: <br> <br>                hpenSame = CreatePen(PS_SOLID, 1, RGB(0,0,0)); <br>                hbrSame = CreateSolidBrush(RGB(255,255,255)); <br> <br>                hpenLeft = CreatePen(PS_SOLID, 1, rgb_barleft); <br>                hbrLeft = CreateSolidBrush(rgb_barleft); <br> <br>                hpenRight = CreatePen(PS_SOLID, 1, rgb_barright); <br>                hbrRight = CreateSolidBrush(rgb_barright); <br> <br>                hbrSideBar = CreateSolidBrush(rgb_barcurrent); <br>                break; <br> <br>        case WM_DESTROY: <br>                DeleteObject(hpenSame); <br>                DeleteObject(hpenLeft); <br>                DeleteObject(hpenRight); <br>                DeleteObject(hbrSame); <br>                DeleteObject(hbrLeft); <br>                DeleteObject(hbrRight); <br>                DeleteObject(hbrSideBar); <br>                break; <br> <br>        case WM_PAINT: <br>                BarPaint(hWnd); <br>                break; <br> <br>        case WM_LBUTTONDOWN: <br>                BarClick(hWnd, LOWORD(lParam), HIWORD(lParam)); <br>                break; <br> <br>        default: <br>                return(DefWindowProc(hWnd, message, wParam, lParam)); <br>        } <br>        return 0; <br>} <br> <br>/*************************************************************************** <br> * Function: BarDrawPosition <br> * <br> * Purpose: <br> * <br> * Draw the current position as side-bars down the bar window, <br> * showing which lines from each file are currently in view. HDC can be <br> * NULL (we get one ourselves if so). If bErase is true, we clear <br> * the previous side-bars first. <br> * <br> * This is called from BarPaint when we paint the whole window, and <br> * from TableServer() whenever it receives a TQ_SCROLL notification that <br> * the table window has been scrolled. <br> */ <br>void <br>BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase) <br>{ <br>        HDC hdc; <br>        int total_lines, cy, cx; <br>        RECT rc, rcLeft, rcRight; <br>        VIEW view; <br>        COMPITEM item; <br>        LIST listleft, listright; <br>        long toprow, endrow, i; <br>        int left_first, left_last, right_first, right_last, linenr; <br> <br> <br>        /* get a hdc if we weren't given one */ <br>        if (hdcIn == NULL) { <br>                hdc = GetDC(hwndBar); <br>        } else { <br>                hdc = hdcIn; <br>        } <br> <br>        /* set horz position of bars */ <br>        GetClientRect(hwndBar, &amp;rc); <br>        cx = (int)(rc.right - rc.left); <br>        cy = (int)(rc.bottom - rc.top); <br> <br>        /* layout constants are defined as percentages of window width */ <br>        rcLeft.left = cx * L_POS_START / 100; <br>        rcRight.left = cx * R_POS_START / 100; <br>        rcLeft.right = rcLeft.left +  (cx * L_POS_WIDTH / 100); <br>        rcRight.right = rcRight.left +  (cx * R_POS_WIDTH / 100); <br> <br>        /* erase the whole marker section if requested */ <br>        if (bErase) { <br>                rcLeft.top = rc.top; <br>                rcLeft.bottom = rc.bottom; <br>                rcRight.top = rc.top; <br>                rcRight.bottom = rc.bottom; <br> <br>                FillRect(hdc, &amp;rcLeft, GetStockObject(WHITE_BRUSH)); <br> <br>                FillRect(hdc, &amp;rcRight, GetStockObject(WHITE_BRUSH)); <br>        } <br> <br> <br>        /* <br>         * calculate the vertical scaling - depends on the <br>         * total number of lines shown <br>         */ <br> <br>        /* get the handles to the two lists of sections */ <br>        view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0); <br>        /* make sure we are in expand mode */ <br>        if (view_isexpanded(view) == FALSE) { <br>                /* get rid of the dc if we made it ourselves */ <br>                if (hdcIn == NULL) { <br>                        ReleaseDC(hwndBar, hdc); <br>                } <br>                return; <br>        } <br> <br>        item = view_getitem(view, 0); <br> <br>        listleft = compitem_getleftsections(item); <br>        listright = compitem_getrightsections(item); <br> <br>        /* if there is only one list of sections, draw nothing. The <br>         * picture for a single file is not very exciting. <br>         */ <br> <br>        if ((listleft == NULL) || (listright == NULL)) { <br>                /* get rid of the dc if we made it ourselves */ <br>                if (hdcIn == NULL) { <br>                        ReleaseDC(hwndBar, hdc); <br>                } <br>                return; <br>        } <br> <br>        /* take the longest of the two files and use this <br>         * for vertical scaling. the scale is such that the longest file <br>         * *just fits*. <br>         */ <br>        total_lines = line_getlinenr(section_getlastline(List_Last(listleft))); <br>        total_lines = max(total_lines, <br>                       (int) line_getlinenr(section_getlastline(List_Last(listright)))); <br> <br> <br>        /* get the current top row and nr of rows visible */ <br>        toprow = SendMessage(hwndRCD, TM_TOPROW, FALSE, 0); <br>        endrow = SendMessage(hwndRCD, TM_ENDROW, FALSE, 0); <br>        endrow = min(endrow, view_getrowcount(view)-1); <br> <br> <br> <br>        /* <br>         * find the first and last line nrs from each file currently visible. <br>         * <br>         */ <br>        left_first = left_last = right_first = right_last = 0; <br> <br>        for (i = toprow; i &lt;= endrow; i++) { <br>                linenr = view_getlinenr_left(view, i); <br> <br>                if (linenr &gt; 0) { <br> <br>                        if (left_first == 0) { <br>                                left_first = linenr; <br>                        } <br>                        left_first = min(left_first, linenr); <br>                        left_last = max(left_last, linenr); <br>                } <br> <br>                linenr = view_getlinenr_right(view, i); <br>                if (linenr &gt; 0) { <br>                        if (right_first == 0) { <br>                                right_first = linenr; <br>                        } <br>                        right_first = min(right_first, linenr); <br>                        right_last = max(right_last, linenr); <br>                } <br> <br>        } <br> <br>        /* draw the two markers as thick bars -&gt; elongated rectangles */ <br>        rcLeft.top = MulDiv(left_first-1, cy, total_lines); <br>        rcLeft.bottom = MulDiv(left_last, cy, total_lines); <br>        FillRect(hdc, &amp;rcLeft, hbrSideBar); <br> <br>        rcRight.top = MulDiv(right_first-1, cy, total_lines); <br>        rcRight.bottom = MulDiv(right_last, cy, total_lines); <br>        FillRect(hdc, &amp;rcRight, hbrSideBar); <br> <br>        /* get rid of the dc if we made it ourselves */ <br>        if (hdcIn == NULL) { <br>                ReleaseDC(hwndBar, hdc); <br>        } <br> <br>} <br> <br> <br>/*************************************************************************** <br> * Function: BarPaint <br> * <br> * Purpose: <br> * <br> * Paint the bar window  <br> */ <br>void <br>BarPaint(HWND hwnd) <br>{ <br>        PAINTSTRUCT ps; <br>        HDC hdc; <br>        VIEW view; <br>        COMPITEM item; <br>        LIST listleft, listright; <br>        SECTION sec; <br>        int total_lines, cx, cy; <br>        RECT rc; <br> <br>        hdc = BeginPaint(hwnd, &amp;ps); <br> <br>        /* draw a separator line at the very edge of the window */ <br>        GetClientRect(hwnd, &amp;rc); <br>        MoveToEx(hdc, (int)(rc.right-1), rc.top, NULL); <br>        LineTo(hdc, (int)(rc.right-1), rc.bottom); <br> <br> <br>        /* first gather information about what is to be displayed */ <br> <br>        /* find the total lines (for horz. scaling) */ <br> <br>        /* get the handles to the two lists of sections */ <br>        view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0); <br> <br>        /* make sure we are in expand mode */ <br>        if (view_isexpanded(view) == FALSE) { <br>                return; <br>        } <br> <br>        item = view_getitem(view, 0); <br> <br>        listleft = compitem_getleftsections(item); <br>        listright = compitem_getrightsections(item); <br> <br>        /* <br>         * don't bother if there is only one list - not very interesting <br>         */ <br>        if ((listleft == NULL) || (listright == NULL)) { <br>                EndPaint(hwnd, &amp;ps); <br>                return; <br>        } <br> <br>        /* take the longest of the two files and use this <br>         * for vertical scaling. the scale is such that the longest file <br>         * *just fits*. <br>         */ <br>        total_lines = (int) line_getlinenr(section_getlastline(List_Last(listleft))); <br>        total_lines = max(total_lines, <br>                       (int) line_getlinenr(section_getlastline(List_Last(listright)))); <br> <br> <br> <br>        /* horizontal spacing: <br>         * <br>         * there are two columns, for the left and right files, and a gap <br>         * between them criss-crossed by lines marking the links. <br>         * <br>         * Each of the columns then has three sections, for the <br>         * position marker, the different sections <br>         * and the linked sections. The width and positions of these items <br>         * are defined (in windiff.h) as percentages of the window width. <br>         */ <br> <br>        cx = (int)(rc.right - rc.left); <br>        cy = (int)(rc.bottom - rc.top); <br> <br> <br>        /* draw all the left sections and links */ <br>        List_TRAVERSE(listleft, sec) { <br>                DrawSection(hdc, cx, cy, total_lines, sec, STATE_LEFTONLY); <br> <br>                if (section_getlink(sec) != NULL) { <br>                        DrawLink(hdc, cx, cy, total_lines, sec); <br>                } <br>        } <br> <br>        /* draw all the right sections */ <br>        List_TRAVERSE(listright, sec) { <br>                DrawSection(hdc, cx, cy, total_lines, sec, STATE_RIGHTONLY); <br>        } <br> <br> <br> <br>        /* now draw current position markers */ <br>        BarDrawPosition(hwnd, hdc, FALSE); <br> <br>        EndPaint(hwnd, &amp;ps); <br>} <br> <br>/*************************************************************************** <br> * Function: DrawSection <br> * <br> * Purpose: <br> * <br> * Paint a single section  <br> */ <br>void <br>DrawSection(HDC hdc, int cx, int cy, int lines, SECTION sec, int sidecode) <br>{ <br>        int x1, y1, x2, y2; <br>        HPEN hpenOld; <br>        HBRUSH hbrOld; <br> <br>        /* calculate the vertical position from the scaling. the scaling <br>         * is such that the longest file just fits <br>         */ <br>        y1 = MulDiv(line_getlinenr(section_getfirstline(sec))- 1, cy, lines); <br>        y2 = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines); <br> <br> <br>        /* left or right  - set bar position and width*/ <br>        if (sidecode == STATE_LEFTONLY) { <br>                if (section_getlink(sec) != NULL) { <br>                        x1 = L_MATCH_START; <br>                        x2 = L_MATCH_WIDTH; <br>                } else { <br>                        x1 = L_UNMATCH_START; <br>                        x2 = L_UNMATCH_WIDTH; <br>                } <br>        } else { <br>                if (section_getlink(sec) != NULL) { <br>                        x1 = R_MATCH_START; <br>                        x2 = R_MATCH_WIDTH; <br>                } else { <br>                        x1 = R_UNMATCH_START; <br>                        x2 = R_UNMATCH_WIDTH; <br>                } <br>        } <br>        /* bar position defines are in percentages of the win width (cx) */ <br>        x1 = cx * x1 / 100; <br>        x2 = (cx * x2 / 100) + x1; <br> <br> <br>        /* select pens and brushes */ <br>        if (section_getlink(sec) != NULL) { <br>                hpenOld = SelectObject(hdc, hpenSame); <br>                hbrOld = SelectObject(hdc, hbrSame); <br>        } else if (sidecode == STATE_LEFTONLY) { <br>                hpenOld = SelectObject(hdc, hpenLeft); <br>                hbrOld = SelectObject(hdc, hbrLeft); <br>        } else { <br>                hpenOld = SelectObject(hdc, hpenRight); <br>                hbrOld = SelectObject(hdc, hbrRight); <br>        } <br> <br>        /* draw the section as a coloured elongated rectangle */ <br>        Rectangle(hdc, x1, y1, x2, y2); <br> <br>        /* de-select the pen and brush in favour of the default */ <br>        SelectObject(hdc, hpenOld); <br>        SelectObject(hdc, hbrOld); <br> <br>} <br> <br>/*************************************************************************** <br> * Function: DrawLink <br> * <br> * Purpose: <br> * <br> * Draw a line linking two sections. Indicates a section from each <br> * file that match each other. psec points to the section in the <br> * left file. <br> */ <br>void <br>DrawLink(HDC hdc, int cx, int cy, int lines, SECTION sec) <br>{ <br>        int x1, y1, x2, y2; <br>        int ybase, yrange; <br>        SECTION other; <br> <br>        other = section_getlink(sec); <br> <br>        /* position the link line halfway down the section <br>         * - allow for the case where <br>         * the section is one line (ie halve the co-ords, not the line nr) <br>         */ <br>        ybase = MulDiv(line_getlinenr(section_getfirstline(sec)) - 1, cy, lines); <br>        yrange = MulDiv(line_getlinenr(section_getlastline(sec)), cy, lines); <br>        y1 = ((yrange - ybase) / 2) + ybase; <br> <br>        ybase = MulDiv(line_getlinenr(section_getfirstline(other)) - 1, cy, lines); <br>        yrange = MulDiv(line_getlinenr(section_getlastline(other)), cy, lines); <br>        y2 = ((yrange - ybase) / 2) + ybase; <br> <br>        /* horizontal layout constants are defined as percentages of the <br>         * window width <br>         */ <br>        x1 = cx * (L_MATCH_START + L_MATCH_WIDTH) / 100; <br>        x2 = cx * R_UNMATCH_START / 100; <br> <br>        MoveToEx(hdc, x1, y1, NULL); <br>        LineTo(hdc, x2, y2); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: BarClick <br> * <br> * Purpose: <br> * <br> * The user has clicked on the bar window. Translate the clicked position into <br> * a line in one of the files if possible, and scroll the table window to <br> * show that line. <br> */ <br>void <br>BarClick(HWND hwnd, int x, int y) <br>{ <br>        RECT rc; <br>        int xleft, xright; <br>        int linenr, i, this; <br>        BOOL bIsLeft; <br>        int tot_left, tot_right, total_lines; <br>        LIST listleft, listright; <br>        VIEW view; <br>        COMPITEM item; <br>        TableSelection select; <br> <br> <br>        /* find size of the window to get horz scaling, and see <br>         * where click was <br>         */ <br>        GetClientRect(hwnd, &amp;rc); <br> <br>        /* was it near either of the bars ? */ <br> <br>        /* horz positioning is in percentages of window width */ <br>        xleft = max(L_UNMATCH_START + L_UNMATCH_WIDTH, <br>                     L_MATCH_START + L_MATCH_WIDTH); <br>        xright = min(R_UNMATCH_START, R_MATCH_START); <br>        xleft = xleft * (rc.right - rc.left) / 100; <br>        xright = xright * (rc.right - rc.left) / 100; <br> <br> <br>        if (x &lt; xleft) { <br>                bIsLeft = TRUE; <br>        } else if (x &gt; xright) { <br>                bIsLeft = FALSE; <br>        } else { <br>                /* click was between the two bars - ignore it */ <br>                return; <br>        } <br> <br> <br>        /* calculate the vertical scaling (based on total lines displayed) <br>         * so that we can convert the y position into a line nr <br>         */ <br> <br>        /* get the handles to the two lists of sections */ <br>        view = (VIEW) SendMessage(hwndClient, TM_CURRENTVIEW, 0, 0); <br> <br>        /* make sure we are in expand mode */ <br>        if (view_isexpanded(view) == FALSE) { <br>                return; <br>        } <br> <br>        item = view_getitem(view, 0); <br> <br>        listleft = compitem_getleftsections(item); <br>        listright = compitem_getrightsections(item); <br> <br>        /* ignore the click if only one list of sections, since in <br>         * this case there is nothing drawn for him to click on. <br>         */ <br>        if ((listleft == NULL) || (listright == NULL)) { <br>                return; <br>        } <br> <br>        /* take the longest of the two files and use this <br>         * for vertical scaling. the scale is such that the longest file <br>         * *just fits*. <br>         */ <br>        tot_left = line_getlinenr(section_getlastline(List_Last(listleft))); <br>        tot_right = line_getlinenr(section_getlastline(List_Last(listright))); <br> <br>        total_lines = max(tot_left, tot_right); <br> <br> <br>        /* convert vertical position into a line nr. The vertical scaling <br>         * can be calculated from knowing that the longest list of <br>         * lines just fits in the window. <br>         */ <br>        linenr = (int) (((long) total_lines * y) / (rc.bottom - rc.top)) + 1; <br> <br>        /* check that the line is valid */ <br>        if (bIsLeft) { <br>                if (linenr &gt; tot_left) { <br>                        return; <br>                } <br>        } else { <br>                if (linenr &gt; tot_right) { <br>                        return; <br>                } <br>        } <br> <br>        /* search the current view, looking for a row with this <br>         * line nr on the correct side <br>         */ <br>        for (i = 0; i &lt; view_getrowcount(view); i++) { <br>                if (bIsLeft) { <br>                        this = view_getlinenr_left(view,i); <br>                } else { <br>                        this = view_getlinenr_right(view,i); <br>                } <br> <br>                if (linenr == this) { <br>                        /* found the matching line- select it in the <br>                         * table window <br>                         */ <br>                        select.startrow = i; <br>                        select.startcell = 0; <br>                        select.nrows = 1; <br>                        select.ncells = 1; <br>                        SendMessage(hwndRCD, TM_SELECT, 0, (long) (LPSTR)&amp;select); <br>                        return; <br>                } <br>        } <br> <br>        windiff_UI(TRUE); <br>        MessageBox(hwndClient, LoadRcString(IDS_LINE_NOT_VISIBLE), <br>                "WinDiff", MB_ICONSTOP|MB_OK); <br>        windiff_UI(FALSE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
