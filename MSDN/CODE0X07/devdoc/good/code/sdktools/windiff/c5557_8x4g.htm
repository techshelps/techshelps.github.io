<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TABLE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5560"></a>TABLE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: TABLE.C <br>* <br>* Standard table class and main interface functions. <br>* <br>* Functions: <br>* <br>* gtab_init() <br>* gtab_deltools() <br>* gtab_sendtq() <br>* gtab_freelinedata() <br>* gtab_wndproc() <br>* gtab_createtools() <br>* gtab_deltable() <br>* gtab_buildtable() <br>* gtab_setsize() <br>* gtab_newsize() <br>* gtab_calcwidths() <br>* gtab_alloclinedata() <br>* gtab_invallines() <br>* gtab_append() <br>* <br>* Comments: <br>* <br>* The table class communicates with its 'owner' window to <br>* get the layout info and the data to display. The owner window handle <br>* can be sent as the lParam in CreateWindow - if not, the parent window will <br>* be used. <br>* <br>* After creating the window, send it a TM_NEWID message, with a 'data id' <br>* as the lParam. This is any non-zero 32-bit value. The table will then call <br>* back to its owner window to find out how many rows/columns, then to fetch <br>* the name/properties of each column, and finally to get the data to display. <br>* <br>* Send TM_NEWID of 0 to close (or destroy the window) - wait for TQ_CLOSE <br>* (in either case) before discarding data. Send <br>* TM_REFRESH if data or row-count changes; send TM_NEWLAYOUT if column <br>* properties or nr cols change etc - this is the same as sending TM_NEWID <br>* except that no TQ_CLOSE happens on TM_NEWLAYOUT. <br>* <br>* TQ_SELECT is sent whenever the current selection changes. TQ_ENTER is sent <br>* when enter or double-click occurs. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "gutils.h" <br>#include "table.h" <br>#include "tpriv.h" <br> <br>/* global tools etc */ <br>extern HANDLE hLibInst; <br>HANDLE hVertCurs; <br>HANDLE hNormCurs; <br>HPEN hpenDotted; <br>UINT gtab_msgcode; <br> <br>/* function prototypes */ <br>long FAR PASCAL gtab_wndproc(HWND, UINT, UINT, long); <br>void gtab_createtools(void); <br>void gtab_deltable(HWND hwnd, lpTable ptab); <br>lpTable gtab_buildtable(HWND hwnd, DWORD id); <br>void gtab_setsize(HWND hwnd, lpTable ptab); <br>void gtab_newsize(HWND hwnd, lpTable ptab); <br>void gtab_calcwidths(HWND hwnd, lpTable ptab); <br>BOOL gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab); <br>void gtab_invallines(HWND hwnd, lpTable ptab, int start, int count); <br>void gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD id); <br> <br>/*************************************************************************** <br> * Function: gtab_init <br> * <br> * Purpose: <br> * <br> * Initialise window class - called from DLL main init <br> */ <br>void <br>gtab_init(void) <br>{ <br>        WNDCLASS wc; <br> <br>        gtab_createtools(); <br>        gtab_msgcode = RegisterWindowMessage(TableMessage); <br> <br>        wc.style = CS_GLOBALCLASS | CS_DBLCLKS; <br>        wc.lpfnWndProc = gtab_wndproc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = WLTOTAL; <br>        wc.hInstance = hLibInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = NULL; <br>        wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>        wc.lpszClassName = TableClassName; <br>        wc.lpszMenuName = NULL; <br> <br>        RegisterClass(&amp;wc); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_createtools <br> * <br> * Purpose: <br> * <br> * Load cursors and pens. <br> */ <br> void <br>gtab_createtools(void) <br>{ <br>        hVertCurs = LoadCursor(hLibInst, "VertLine"); <br>        hNormCurs = LoadCursor(NULL, IDC_ARROW); <br> <br>        hpenDotted = CreatePen(PS_DOT, 1, RGB(0, 0, 0)); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_deltools <br> * <br> * Purpose: <br> * <br> * Delete pen <br> */ <br> void <br>gtab_deltools(void) <br>{ <br>        DeleteObject(hpenDotted); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_wndproc <br> * <br> * Purpose: <br> * <br> * Window procedure for table <br> */ <br> long FAR PASCAL <br>gtab_wndproc(HWND hwnd, UINT msg, UINT wParam, long lParam) <br>{ <br>        CREATESTRUCT FAR * csp; <br>        HWND hOwner; <br>        lpTable ptab; <br>        HANDLE hHeap; <br>        PAINTSTRUCT ps; <br>        int y, y2, i; <br>        HDC hDC; <br>        lpTableSelection pselect; <br>        long oldtop; <br>        long change; <br> <br>        switch(msg) { <br> <br>        case WM_CREATE: <br>                /* create window. set the wnd extra bytes to <br>                 * contain the owner window, a heap and a null table. <br>                 * Owner window is either in lParam or the parent. <br>                 * Then wait for TM_NEWID. <br>                 */ <br>                csp = (CREATESTRUCT FAR *) lParam; <br>                if (csp-&gt;lpCreateParams == NULL) { <br>                        hOwner = GetParent(hwnd); <br>                } else { <br>                        hOwner = (HWND) (long) csp-&gt;lpCreateParams; <br>                } <br>                ptab = NULL; <br>                hHeap = gmem_init(); <br>                SetWindowLong(hwnd, WL_TABLE, (LONG) ptab); <br>                SetWindowLong(hwnd, WW_OWNER, (LONG) hOwner); <br>                SetWindowLong(hwnd, WW_HEAP, (LONG) hHeap); <br> <br>                SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>                SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>                break; <br> <br>        case TM_NEWID: <br>                /* complete change of table. <br>                 * close old table, discard memory and <br>                 * build new table <br>                 */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_sendtq(hwnd, TQ_CLOSE, ptab-&gt;hdr.id); <br>                        gtab_deltable(hwnd, ptab); <br>                        SetCursor(hNormCurs); <br>                        SetWindowLong(hwnd, WL_TABLE, 0); <br>                } <br>                if ( (ptab = gtab_buildtable(hwnd, lParam)) != NULL) { <br>                        SetWindowLong(hwnd, WL_TABLE, (long) (LPSTR) ptab); <br>                        gtab_setsize(hwnd, ptab); <br>                } else { <br>                        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>                        SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>                } <br>                InvalidateRect(hwnd, NULL, TRUE); <br>                break; <br> <br>        case TM_NEWLAYOUT: <br>                /* change of layout but for same id. no TQ_CLOSE, <br>                 * but otherwise same as TM_NEWID <br>                 */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_deltable(hwnd, ptab); <br>                        SetCursor(hNormCurs); <br>                        SetWindowLong(hwnd, WL_TABLE, 0); <br>                } <br>                if ( (ptab = gtab_buildtable(hwnd, lParam)) != NULL) { <br>                        SetWindowLong(hwnd, WL_TABLE, (long) (LPSTR) ptab); <br>                        gtab_setsize(hwnd, ptab); <br>                } else { <br>                        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>                        SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>                } <br>                InvalidateRect(hwnd, NULL, TRUE); <br>                break; <br> <br>        case TM_REFRESH: <br>                /* data in table has changed. nrows may have <br>                 * changed. ncols and col types have not changed <br>                 */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_newsize(hwnd, ptab); <br>                } <br>                InvalidateRect(hwnd, NULL, TRUE); <br>                break; <br> <br>        case TM_SELECT: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        pselect = (lpTableSelection) lParam; <br> <br>                        /* <br>                         * we only support TM_SINGLE - so force the <br>                         * selection to a single row or cell. <br>                         */ <br>                        gtab_select(hwnd, ptab, pselect-&gt;startrow, <br>                                pselect-&gt;startcell, <br>                                1, <br>                                (ptab-&gt;hdr.selectmode &amp; TM_ROW) ? <br>                                        ptab-&gt;hdr.ncols : 1, <br>                                TRUE); <br>                        gtab_showsel_middle(hwnd, ptab); <br>                } <br>                break; <br> <br>        case TM_PRINT: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP); <br>                if (ptab != NULL) { <br>                        gtab_print(hwnd, ptab, hHeap, (lpPrintContext) lParam); <br>                        return(TRUE); <br>                } <br> <br>        case TM_TOPROW: <br> <br>                /* return top row. if wParam is TRUE, set lParam <br>                 * as the new toprow <br>                 */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab == NULL) { <br>                        return(0); <br>                } <br>                oldtop = ptab-&gt;toprow; <br>                if ((wParam) &amp;&amp; (lParam &lt; ptab-&gt;hdr.nrows)) { <br>                        change = lParam - ptab-&gt;toprow; <br>                        change -= ptab-&gt;hdr.fixedrows; <br>                        gtab_dovscroll(hwnd, ptab, change); <br>                } <br>                return(oldtop); <br> <br>        case TM_ENDROW: <br>                /* return the last visible row in the window */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab == NULL) { <br>                        return(0); <br>                } <br>                return(ptab-&gt;nlines + ptab-&gt;toprow - 1); <br> <br> <br>        case TM_APPEND: <br>                /* new rows have been added to the end of the <br>                 * table, but the rest of the table has no <br>                 * been change. Update without forcing redraw of <br>                 * everything. <br>                 * lParam contains the new total nr of rows <br>                 */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_append(hwnd, ptab, wParam, lParam); <br>                        return(TRUE); <br>                } <br>                break; <br> <br>        case WM_SIZE: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_setsize(hwnd, ptab); <br>                } <br>                break; <br> <br>        case WM_DESTROY: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_sendtq(hwnd, TQ_CLOSE, ptab-&gt;hdr.id); <br>                        gtab_deltable(hwnd, ptab); <br>                } <br>                hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP); <br>                gmem_freeall(hHeap); <br>                break; <br> <br>        case WM_PAINT: <br>                hDC = BeginPaint(hwnd, &amp;ps); <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        /* separator lines between fixed rows/columns <br>                         * (ie headers) and the rest - if enabled <br>                         */ <br>                        /* paint here first for good impression, <br>                         * and again after to clean up!! <br>                         */ <br>                        if (ptab-&gt;hdr.vseparator) { <br>                                gtab_vsep(hwnd, ptab, hDC); <br>                        } <br>                        if (ptab-&gt;hdr.hseparator) { <br>                                gtab_hsep(hwnd, ptab, hDC); <br>                        } <br> <br>                        /* paint only the rows that need painting */ <br>                        for (i = 0; i &lt; ptab-&gt;nlines; i++) { <br>                                y = ptab-&gt;pdata[i].linepos.start; <br>                                y2 = y + ptab-&gt;pdata[i].linepos.size; <br>                                if ( (y &lt;= ps.rcPaint.bottom) &amp;&amp; <br>                                     (y2 &gt;= ps.rcPaint.top)) { <br>                                        gtab_paint(hwnd, hDC, ptab, i); <br>                                } <br>                        } <br>                        if (ptab-&gt;hdr.vseparator) { <br>                                gtab_vsep(hwnd, ptab, hDC); <br>                        } <br>                        if (ptab-&gt;hdr.hseparator) { <br>                                gtab_hsep(hwnd, ptab, hDC); <br>                        } <br>                        if (ptab-&gt;selvisible) { <br>                                gtab_invertsel(hwnd, ptab, hDC); <br>                        } <br>                } <br> <br>                EndPaint(hwnd, &amp;ps); <br>                break; <br> <br>        case WM_HSCROLL: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_msg_hscroll(hwnd, ptab, <br>                          GET_SCROLL_OPCODE(wParam, lParam), <br>                          GET_SCROLL_POS(wParam, lParam)); <br>                } <br>                break; <br> <br>        case WM_VSCROLL: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_msg_vscroll(hwnd, ptab, <br>                          GET_SCROLL_OPCODE(wParam, lParam), <br>                          GET_SCROLL_POS(wParam, lParam)); <br>                } <br>                break; <br> <br>        case WM_MOUSEMOVE: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_move(hwnd, ptab, LOWORD(lParam), HIWORD(lParam)); <br>                } else { <br>                        SetCursor(hNormCurs); <br>                } <br>                break; <br> <br>        case WM_LBUTTONDOWN: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_press(hwnd, ptab, LOWORD(lParam), HIWORD(lParam)); <br>                } <br>                break; <br> <br>        case WM_LBUTTONUP: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_release(hwnd, ptab, <br>                                LOWORD(lParam), HIWORD(lParam)); <br>                } <br>                break; <br> <br>        case WM_LBUTTONDBLCLK: <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        gtab_dblclick(hwnd, ptab, <br>                                LOWORD(lParam), HIWORD(lParam)); <br>                } <br>                break; <br> <br>        case WM_KEYDOWN: <br>                /* handle key presses for cursor movement about <br>                 * the table, and return/space for selection. <br>                 * Any key we don't handle is passed to the owner window <br>                 * for him to handle. <br>                 * The table window should have the focus <br>                 */ <br>                ptab = (lpTable) GetWindowLong(hwnd, WL_TABLE); <br>                if (ptab != NULL) { <br>                        if (gtab_key(hwnd, ptab, wParam) != 0) { <br>                                /* pass key to owner since <br>                                 * we don't know what to do with it <br>                                 */ <br>                                hOwner = (HANDLE) GetWindowLong(hwnd, WW_OWNER); <br>                                return(SendMessage(hOwner, WM_KEYDOWN, <br>                                        wParam, lParam)); <br>                        } else { <br>                                return(0);       <br>                        } <br>                } <br>                break; <br> <br>        default: <br>                return(DefWindowProc(hwnd, msg, wParam, lParam)); <br>        } <br>        return(TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_sendtq <br> * <br> * Purpose: <br> * <br> * Send a table-query message to the owner window. Returns message <br> * value. <br> */ <br>long <br>gtab_sendtq(HWND hwnd, UINT cmd, long lParam) <br>{ <br>        HWND hOwner; <br> <br>        hOwner = (HANDLE) GetWindowLong(hwnd, WW_OWNER); <br>        return (SendMessage(hOwner, gtab_msgcode, cmd, lParam)); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_freelinedata <br> * <br> * Purpose: <br> * <br> * Free the memory allocated for the array of lines (each containing <br> * an array of Cells, each containing an array of chars for the actual <br> * data). Called on any occasion that would change the number of visible lines <br> */ <br>void <br>gtab_freelinedata(HANDLE hHeap, lpTable ptab) <br>{ <br>        int i, j, ncols; <br>        lpCellData cd; <br> <br> <br>        ncols = ptab-&gt;hdr.ncols; <br> <br>        /* for each line */ <br>        for(i = 0; i &lt; ptab-&gt;nlines; i++) { <br>                /* for each cell */ <br>                for (j = 0; j &lt; ncols; j++) { <br>                        /* free up the actual text space */ <br>                        cd = &amp;ptab-&gt;pdata[i].pdata[j]; <br>                        gmem_free(hHeap, (LPSTR) cd-&gt;ptext, cd-&gt;nchars); <br>                } <br>                /* dealloc array of CellData */ <br>                gmem_free(hHeap, (LPSTR) ptab-&gt;pdata[i].pdata, <br>                        sizeof(CellData) * ncols); <br>        } <br>        /* de-alloc array of linedatas */ <br>        gmem_free(hHeap, (LPSTR) ptab-&gt;pdata, <br>                sizeof(LineData) * ptab-&gt;nlines); <br>        ptab-&gt;pdata = NULL; <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_alloclinedata <br> * <br> * Purpose: <br> * <br> * Allocate and init array of linedatas (include cell array <br> * and text for each cell) <br> */ <br>BOOL <br>gtab_alloclinedata(HWND hwnd, HANDLE heap, lpTable ptab) <br>{ <br>        lpLineData pline; <br>        lpCellData cd; <br>        int i, j; <br> <br>        ptab-&gt;pdata = (lpLineData) gmem_get(heap, <br>                sizeof(LineData) * ptab-&gt;nlines); <br>        if (ptab-&gt;pdata == NULL) { <br>                return(FALSE); <br>        } <br>        for (i = 0; i &lt; ptab-&gt;nlines; i++) { <br>                pline = &amp;ptab-&gt;pdata[i]; <br>                pline-&gt;linepos.size = ptab-&gt;rowheight; <br>                pline-&gt;pdata = (lpCellData) gmem_get(heap, <br>                        sizeof(CellData) * ptab-&gt;hdr.ncols); <br>                if (pline-&gt;pdata == NULL) { <br>                        return(FALSE); <br>                } <br>                for (j = 0; j &lt; ptab-&gt;hdr.ncols; j++) { <br>                        cd = &amp;pline-&gt;pdata[j]; <br>                        cd-&gt;props.valid = 0; <br>                        cd-&gt;flags = 0; <br>                        cd-&gt;nchars = ptab-&gt;pcolhdr[j].nchars; <br>                        if (cd-&gt;nchars &gt; 0) { <br>                                cd-&gt;ptext = gmem_get(heap, cd-&gt;nchars); <br>                                if (cd-&gt;ptext == NULL) { <br>                                        return(FALSE); <br>                                } <br>                        } <br>                } <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_deltable <br> * <br> * Purpose: <br> * <br> * Free up all table data structures. Called for new layout or new data. <br> */ <br>void <br>gtab_deltable(HWND hwnd, lpTable ptab) <br>{ <br>        HANDLE hHeap; <br>        int ncols; <br> <br>        if (ptab == NULL) { <br>                return; <br>        } <br>        hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP); <br>        ncols = ptab-&gt;hdr.ncols; <br> <br>        if (ptab-&gt;pcolhdr != NULL) { <br>                gmem_free(hHeap, (LPSTR) ptab-&gt;pcolhdr, <br>                        sizeof(ColProps) * ncols); <br>        } <br>        if (ptab-&gt;pcellpos != NULL) { <br>                gmem_free(hHeap, (LPSTR) ptab-&gt;pcellpos, <br>                        sizeof(CellPos) * ncols); <br>        } <br>        if (ptab-&gt;pdata != NULL) { <br>                gtab_freelinedata(hHeap, ptab); <br>        } <br>        gmem_free(hHeap, (LPSTR) ptab, sizeof(Table)); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gtab_buildtable <br> * <br> * Purpose: <br> * <br> * Build up a Table struct (excluding data allocation and <br> * anything to do with font or window size). <br> * Return ptr to this or NULL if error <br> */ <br>lpTable <br>gtab_buildtable(HWND hwnd, DWORD id) <br>{ <br>        lpTable ptab; <br>        HANDLE hHeap; <br>        int ncols, i; <br>        ColPropsList cplist; <br> <br>        hHeap = (HANDLE) GetWindowLong(hwnd, WW_HEAP); <br>        ptab = (lpTable) gmem_get(hHeap, sizeof(Table)); <br>        if (ptab == NULL) { <br>                return(NULL); <br>        } <br> <br>        /* get the row/column count from owner window */ <br>        ptab-&gt;hdr.id = id; <br>        ptab-&gt;hdr.props.valid = 0; <br>        ptab-&gt;hdr.sendscroll = FALSE; <br>        if (gtab_sendtq(hwnd, TQ_GETSIZE, (long) (LPSTR)&amp;ptab-&gt;hdr) == FALSE) { <br>                return(NULL); <br>        } <br> <br>        ncols = ptab-&gt;hdr.ncols; <br>        ptab-&gt;pcolhdr = (lpColProps) gmem_get(hHeap, sizeof(ColProps) * ncols); <br>        if (ptab-&gt;pcolhdr == NULL) { <br>                /* should prob send TQ_CLOSE at this point */ <br>                return(NULL); <br>        } <br> <br>        /* init col properties to default */ <br>        for (i=0; i &lt; ncols; i++) { <br>                ptab-&gt;pcolhdr[i].props.valid = 0; <br>                ptab-&gt;pcolhdr[i].nchars = 0; <br>        } <br>        /* get the column props from owner */ <br>        cplist.plist = ptab-&gt;pcolhdr; <br>        cplist.id = id; <br>        cplist.startcol = 0; <br>        cplist.ncols = ncols; <br>        gtab_sendtq(hwnd, TQ_GETCOLPROPS, (long) (LPSTR)&amp;cplist); <br> <br>        /* init remaining fields */ <br>        ptab-&gt;pcellpos = (lpCellPos) gmem_get(hHeap, sizeof(CellPos) * ncols); <br>        if (ptab-&gt;pcellpos == NULL) { <br>                return(NULL); <br>        } <br> <br>        ptab-&gt;scrollscale = 1; <br>        ptab-&gt;scroll_dx = 0; <br>        ptab-&gt;toprow = 0; <br>        ptab-&gt;pdata = NULL; <br>        ptab-&gt;nlines = 0; <br>        ptab-&gt;trackmode = TRACK_NONE; <br> <br>        /* we have to notify owner of the current selection <br>         * whenever it is changed <br>         */ <br>        ptab-&gt;select.id = id; <br>        gtab_select(hwnd, ptab, 0, 0, 0, 0, TRUE); <br> <br>        /* calc ave height/width, cell widths and min height. <br>         * these change only when cell properties / col count changes - <br>         * ie only on rebuild-header events <br>         */ <br>        gtab_calcwidths(hwnd, ptab); <br>        return(ptab); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_setsize <br> * <br> * Purpose: <br> * <br> * Set sizes that are based on window size and scroll pos <br> * set: <br> *      winwidth <br> *      nlines <br> *      cellpos start, clip start/end <br> * Alloc linedata and init <br> */ <br>void <br>gtab_setsize(HWND hwnd, lpTable ptab) <br>{ <br>        RECT rc; <br>        int nlines; <br>        HANDLE heap; <br>        long range, change; <br> <br>        GetClientRect(hwnd, &amp;rc); <br>        ptab-&gt;winwidth = rc.right - rc.left; <br>        nlines = (rc.bottom - rc.top) / ptab-&gt;rowheight; <br>        /* nlines is the number of whole lines - add one extra <br>         * for the partial line at the bottom <br>         */ <br>        nlines += 1; <br> <br>        /* alloc space for nlines of data - if nlines has changed */ <br>        if (nlines != ptab-&gt;nlines) { <br>                heap = (HANDLE) GetWindowLong(hwnd, WW_HEAP); <br>                gtab_freelinedata(heap, ptab); <br>                ptab-&gt;nlines = nlines; <br>                if (!gtab_alloclinedata(hwnd, heap, ptab)) { <br>                        ptab-&gt;nlines = 0; <br>                        return; <br>                } <br>        } <br> <br>        /* set scroll vertical range */ <br>        range = ptab-&gt;hdr.nrows - (ptab-&gt;nlines - 1); <br>        if (range &lt; 0) { <br>                range = 0; <br>                change =  -(ptab-&gt;toprow); <br>        } else if (ptab-&gt;toprow &gt; range) { <br>                change = range - ptab-&gt;toprow; <br>        } else { <br>                change = 0; <br>        } <br>        /* the scroll range must be 16-bits for Win3 <br>         * scale until this is true <br>         */ <br>        ptab-&gt;scrollscale = 1; <br>        while (range &gt; 32766) { <br>                ptab-&gt;scrollscale *= 16; <br>                range /= 16; <br>        } <br> <br>        SetScrollRange(hwnd, SB_VERT, 0, (int) range, TRUE); <br>        gtab_dovscroll(hwnd, ptab, change); <br> <br>        /* set horz scroll range */ <br>        range = ptab-&gt;rowwidth - ptab-&gt;winwidth; <br>        if (range &lt; 0) { <br>                range = 0; <br>                change = -(ptab-&gt;scroll_dx); <br>        } else if (ptab-&gt;scroll_dx &gt; range) { <br>                change = range - ptab-&gt;scroll_dx; <br>        } else { <br>                change = 0; <br>        } <br>        /* horz scroll range will always be &lt; 16 bits */ <br>        SetScrollRange(hwnd, SB_HORZ, 0, (int) range, TRUE); <br>        gtab_dohscroll(hwnd, ptab, change); <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_calcwidths <br> * <br> * Purpose: <br> * <br> * Set column widths/height and totals (based on column props) <br> * - no assumption of window size (see gtab_setsize) <br> * sets avewidth,rowheight,cellpos.size,rowwidth (total of cellpos.size) <br> */ <br>void <br>gtab_calcwidths(HWND hwnd, lpTable ptab) <br>{ <br>        int i, cxtotal, cx, ave; <br>        TEXTMETRIC tm, tmcol; <br>        HDC hdc; <br>        lpProps hdrprops, cellprops; <br>        HFONT hfont; <br> <br>        hdrprops = &amp;ptab-&gt;hdr.props; <br>        hdc = GetDC(hwnd); <br>        if (hdrprops-&gt;valid &amp; P_FONT) { <br>                hfont = SelectObject(hdc, hdrprops-&gt;hFont); <br>        } <br>        GetTextMetrics(hdc, &amp;tm); <br>        if (hdrprops-&gt;valid &amp; P_FONT) { <br>                SelectObject(hdc, hfont); <br>        } <br>        ReleaseDC(hwnd, hdc); <br> <br>        /* get width and height of average character */ <br>        ptab-&gt;avewidth = tm.tmAveCharWidth; <br>        ptab-&gt;rowheight = tm.tmHeight + tm.tmExternalLeading; <br>        if (hdrprops-&gt;valid &amp; P_HEIGHT) { <br>                ptab-&gt;rowheight = hdrprops-&gt;height; <br>        } <br> <br>        /* set pixel width of each cell (and add up for row total) <br>         * based on ave width * nr chars, unless P_WIDTH set <br>         */ <br>        cxtotal = 0; <br>        for (i = 0; i &lt; ptab-&gt;hdr.ncols; i++) { <br>                cellprops = &amp;ptab-&gt;pcolhdr[i].props; <br> <br>                if (cellprops-&gt;valid &amp; P_WIDTH) { <br>                        cx = cellprops-&gt;width; <br>                } else if (hdrprops-&gt;valid &amp; P_WIDTH) { <br>                        cx = hdrprops-&gt;width; <br>                } else { <br> <br>                        if (cellprops-&gt;valid &amp; P_FONT) { <br>                                hdc = GetDC(hwnd); <br>                                hfont = SelectObject(hdc, cellprops-&gt;hFont); <br>                                GetTextMetrics(hdc, &amp;tmcol); <br>                                SelectObject(hdc, hfont); <br>                                ReleaseDC(hwnd, hdc); <br>                                ave = tmcol.tmAveCharWidth; <br>                        } else { <br>                                ave = ptab-&gt;avewidth; <br>                        } <br>                        /* ave width * nchars */ <br>                        cx =  ptab-&gt;pcolhdr[i].nchars + 1; <br>                        cx *= ave; <br>                } <br>                /* add 2 pixels for box lines */ <br>                cx += 2; <br>                ptab-&gt;pcellpos[i].size = cx; <br>                cxtotal += cx; <br>        } <br>        ptab-&gt;rowwidth = cxtotal; <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_newsize <br> * <br> * Purpose: <br> * <br> * Called when row data + possible nrows changes. <br> * other changes are ignored <br> */ <br>void <br>gtab_newsize(HWND hwnd, lpTable ptab) <br>{ <br>        TableHdr hdr; <br> <br>        /* get new row count */ <br>        hdr = ptab-&gt;hdr; <br>        gtab_sendtq(hwnd, TQ_GETSIZE, (long) (LPSTR) &amp;hdr); <br>        if (hdr.nrows != ptab-&gt;hdr.nrows) { <br>                ptab-&gt;hdr.nrows = hdr.nrows; <br>                gtab_setsize(hwnd, ptab); <br>        } <br> <br>        gtab_invallines(hwnd, ptab, 0, ptab-&gt;nlines); <br> <br>        InvalidateRect(hwnd, NULL, TRUE); <br>} <br> <br>void <br>gtab_invallines(HWND hwnd, lpTable ptab, int start, int count) <br>{ <br>        int i, j; <br> <br>        for (i = start; i &lt; start + count; i++) { <br>                for (j = 0; j &lt; ptab-&gt;hdr.ncols; j++) { <br>                        ptab-&gt;pdata[i].pdata[j].flags = 0; <br>                } <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: gtab_append <br> * <br> * Purpose: <br> * <br> * New rows have been added to the table. Adjust the scroll range and <br> * position, and redraw the rows if the end of the table is currently <br> * visible. <br> * rows = the new total row count. <br> */ <br>void <br>gtab_append(HWND hwnd, lpTable ptab, int rows, DWORD id) <br>{ <br>        long range; <br>        long oldrows; <br>        int line, nupdates; <br>        RECT rc; <br> <br> <br>        /* change to the new id */ <br>        ptab-&gt;hdr.id = id; <br>        ptab-&gt;select.id = id; <br> <br>        /* update the header, but remember the old nr of rows <br>         * so we know where to start updating <br>         */ <br>        oldrows = ptab-&gt;hdr.nrows; </code></pre>
<p>
</p>
<pre><code><br>        /* check that the new nr of rows is not smaller. this is <br>         * illegal at this point and should be ignored <br>         */ <br>        if (oldrows &gt;= rows) { <br>                return;  <br>        } <br> <br>        ptab-&gt;hdr.nrows = rows; <br> <br>        /* set the vertical scroll range */ <br>        range = rows - (ptab-&gt;nlines - 1); <br> <br>        if (range &lt; 0) { <br>                range = 0;       <br>        } <br> <br>        /* force the scroll range into 16-bits for win 3.1 */ <br>        ptab-&gt;scrollscale = 1; <br>        while (range &gt; 32766) { <br>                ptab-&gt;scrollscale *= 16; <br>                range /= 16; <br>        } <br> <br>        /* now set the scroll bar range and position */ <br>        SetScrollRange(hwnd, SB_VERT, 0, (int) range, TRUE); <br>        if (range &gt; 0) { <br>                SetScrollPos(hwnd, SB_VERT, <br>                        (int) (ptab-&gt;toprow / ptab-&gt;scrollscale), TRUE); <br>        } <br> <br>        /* calculate which screen lines need to be updated - find what <br>         * screen line the start of the new section is at <br>         */ <br>        line = gtab_rowtoline(hwnd, ptab, oldrows); <br>        if (line == -1) { <br>                /* not visible -&gt; no more to do */ <br>                return; <br>        } <br> <br>        /* how many lines to update - rest of screen or nr of <br>         * new lines if less than rest of screen <br>         */ <br>        nupdates = min((ptab-&gt;nlines - line), (int)(rows - oldrows)); <br> <br>        /* invalidate the screen line buffers to indicate data <br>         * needs to be refetch from parent window <br>         */ <br>        gtab_invallines(hwnd, ptab, line, nupdates); <br> <br>        /* calculate the region of the screen to be repainted - <br>         * left and right are same as window. top and bottom <br>         * need to be calculated from screen line height <br>         */ <br>         <br>        GetClientRect(hwnd, &amp;rc); <br>        rc.top += line * ptab-&gt;rowheight; <br>        rc.bottom = rc.top + (nupdates * ptab-&gt;rowheight); <br> <br>        /* force a repaint of the updated region */ <br>        InvalidateRect(hwnd, &amp;rc, TRUE); <br>} <br>         <br> <br> <br>         </code></pre>
<p>&nbsp;</p></body>
</HTML>
