<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GBIT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5543"></a>GBIT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: GBIT.C <br>* <br>* Bitmap allocation routines to manage a bit-mapped free list, and find <br>* free sections. <br>* <br>* Functions: <br>* <br>* gbit_set() <br>* gbit_init() <br>* gbit_alloc() <br>* gbit_free() <br>* gbit_findfree() <br>* <br>* Comments: <br>* <br>* Each map is an array of unsigned longs where bit 0 of the first  <br>* long represents block 1. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "gutils.h" <br> <br> <br>BOOL gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set); <br> <br>/*************************************************************************** <br> * Function: gbit_init <br> * <br> * Purpose: <br> * <br> * Initialise a pre-allocated map of ulongs to represent a free <br> * area of nblks <br> */ <br>void APIENTRY <br>gbit_init(DWORD FAR * map, long nblks) <br>{ <br>        long i; <br>        long leftover = nblks % 32; <br>        long blks = nblks / 32; <br>        DWORD last = 0; <br> <br>        for (i=0; i &lt; blks; i++) { <br>                map[i] = 0xffffffff; <br>        } <br>        for (i = 0; i &lt; leftover; i++) { <br>                last = (last &lt;&lt; 1) | 1; <br>        } <br>        if(leftover) <br>                map[blks] = last; <br>} <br> <br>/*************************************************************************** <br> * Function: gbit_alloc <br> * <br> * Purpose: <br> * <br> * Mark a region starting at blknr for nblks, as busy (ie 0)  <br> */ <br>BOOL APIENTRY <br>gbit_alloc(DWORD FAR * map, long blknr, long nblks) <br>{ <br>        return(gbit_set(map, blknr, nblks, FALSE)); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gbit_set <br> * <br> * Purpose: <br> * <br> * Mark region - if op_set, to 1s, otherwise to 0s  <br> */ <br>BOOL <br>gbit_set(DWORD FAR * map, long blknr, long nblks, BOOL op_set) <br>{ <br>        long first; <br>        long last; <br>        long fullwords; <br>        long startbit, startword; <br>        long i; <br>        DWORD dword = 0; <br> <br>        blknr--; <br>        first = min(32 - (blknr % 32), nblks); <br>        nblks -= first; <br>        last = nblks % 32; <br>        fullwords = (nblks - last) / 32; <br>         <br>        startword = blknr / 32; <br>        startbit = blknr % 32; <br>        for (i = 0; i &lt; first; i++) { <br>                dword = (dword &lt;&lt; 1) | 1; <br>        } <br>        dword &lt;&lt;= startbit; <br>        if (op_set) { <br>                map[startword] |= dword; <br>                dword = 0xffffffff; <br>        } else { <br>                map[startword] &amp;= ~dword; <br>                dword = 0; <br>        } <br>        startword++; <br>        for (i = 0; i &lt; fullwords; i++) { <br>                map[startword+i] = dword; <br>        } <br>        startword += fullwords; <br>        for(i = 0, dword = 0; i &lt; last; i++) { <br>                dword = (dword &lt;&lt; 1) | 1; <br>        } <br>        if (last) { <br>                if (op_set) { <br>                        map[startword] |= dword; <br>                } else { <br>                        map[startword] &amp;= ~dword; <br>                } <br>        } <br> <br>        return(TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: gbit_free <br> * <br> * Purpose: <br> * <br> * Mark region of nblks starting at blknr to 0s - ie not busy  <br> */ <br>BOOL APIENTRY <br>gbit_free(DWORD FAR * map, long blknr, long nblks) <br>{ <br>        return(gbit_set(map, blknr, nblks, TRUE)); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: gbit_findfree <br> * <br> * Purpose: <br> * <br> * Find a free segment (ie contiguous sequence of 1s) of nblks in length. <br> * If not found, find longest sequence. Store address of segment in *blknr. <br> * <br> * Return value is nr of blks in sequence found. Region is *not* marked busy. <br> */ <br>long APIENTRY <br>gbit_findfree(DWORD FAR* map, long nblks, long mapsize, long FAR * blknr) <br>{ <br>        long curblk, startblk, len, i; <br>        long startbit, nfull, nlast, nbitsleft; <br>        DWORD mask; <br>        long mapblks = (mapsize + 31) / 32; <br>        long aubegin = 0, aulen = 0; <br>        long curbit = 0; <br> <br>        /* main loop looking at segments */ <br>        for (curblk = 0; curblk &lt; mapblks; ) { <br>loop: <br>                /* loop finding first 1 */ <br>                for (; curblk &lt; mapblks; curblk++, curbit = 0) { <br>                        if (map[curblk] &gt; 0) { <br>                                break; <br>                        } <br>                } <br>                if (curblk &gt;= mapblks)  <br>                        break; <br>                 <br>                /* find first 1 in this long */ <br>                startblk = curblk; <br>                for (mask = 1, i = 0; i &lt; curbit; i++) { <br>                        mask &lt;&lt;= 1; <br>                } <br>                for(; curbit &lt; 32; curbit++, mask &lt;&lt;= 1) { <br>                        if (map[curblk] &amp; mask) { <br>                                break; <br>                        } <br>                }  <br>                if (curbit &gt;= 32) { <br>                        /* abandon this word - start again with next word */ <br>                        curblk++; <br>                        curbit = 0; <br>                        goto loop; <br>                } <br> <br>                /* we've now found a 1 - calc remaining <br>                 * bits in this word, complete words etc required. <br>                 */ <br>                startbit = curbit; <br>                nbitsleft = min( (32 - curbit), nblks); <br>                nfull = (nblks - nbitsleft) / 32; <br>                nlast = (nblks - nbitsleft) % 32; <br> <br>                /* check for required sequence within this word */ <br> <br>                for (i = 0; i &lt; nbitsleft; i++, curbit++, mask &lt;&lt;= 1) { <br>                        if ((map[curblk] &amp; mask) == 0) { <br>                                /* abandon and start again - start <br>                                 * next pass at curbit in same word <br>                                 */ <br>                                /* store free region if longest yet */ <br>                                if (i &gt; aulen) { <br>                                        aulen = i; <br>                                        aubegin = curblk * 32 + startbit +1; <br>                                } <br>                                goto loop; <br>                        } <br>                } <br>                 <br>                /* check for nfull full words */ <br>                for (curblk++; curblk &lt;= startblk + nfull; curblk++) { <br>                        if (curblk &gt;= mapblks) { <br>                                /* end of map - abandon here and exit at top <br>                                 * of loop <br>                                 */ <br>                                len = nbitsleft + <br>                                        ((curblk - (startblk + 1)) * 32); <br>                                if (len &gt; aulen) { <br>                                        aubegin = startblk * 32 + startbit + 1; <br>                                        aulen = len; <br>                                } <br>                                goto loop; <br>                        } <br>                        if (map[curblk] != 0xffffffff) { <br>                                /* not a full word - start again at this bit */ <br>                                len = 0; <br>                                curbit = 0; <br>                                for (mask = 1; mask &amp; map[curblk]; mask &lt;&lt;= 1) { <br>                                        len++; <br>                                        curbit++; <br>                                } <br>                                len += nbitsleft + <br>                                        (curblk - (startblk+ 1)) * 32; <br>                                if (len &gt; aulen) { <br>                                        aulen = len; <br>                                        aubegin = startblk * 32 + startbit + 1; <br>                                } <br>                                /* continue with current blk, bit */ <br>                                goto loop; <br>                        } <br>                } <br> <br>                /* left-over bits required in last word */ <br>                mask = 1; <br>                for (curbit = 0; curbit &lt; nlast;  curbit++, mask &lt;&lt;= 1) { <br>                        if ((map[curblk] &amp; mask) == 0) { <br>                                len = nbitsleft + (nfull * 32); <br>                                len += curbit; <br>                                if (len &gt; aulen) { <br>                                        aulen = len; <br>                                        aubegin = startblk * 32 + startbit + 1; <br>                                } <br>                                goto loop; <br>                        } <br>                } <br>                /* ok - found a block big enough! */ <br>                aubegin = startblk * 32 + startbit + 1; <br>                *blknr = aubegin; <br>                return(nblks); <br>        } <br> <br>        /* end of map - return longest sequence */ <br>        *blknr = aubegin; <br>        return(aulen); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
