<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCANDIR.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5554"></a>SCANDIR.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: SCANDIR.C <br>* <br>* Scan a directory tree and build a sorted list of filenames within that <br>* tree. <br>* <br>* Functions: <br>* <br>* dir_buildlist() <br>* dir_delete() <br>* dir_isfile() <br>* dir_firstitem() <br>* dir_nextitem() <br>* dir_findnextfile() <br>* dir_getrelname() <br>* dir_getfullname() <br>* dir_getroot_list() <br>* dir_getroot_item() <br>* dir_freerelname() <br>* dir_freefullname() <br>* dir_freeroot_list() <br>* dir_freerootitem() <br>* dir_getopenname() <br>* dir_freeopenname() <br>* dir_openfile() <br>* dir_closefile() <br>* dir_filesize() <br>* dir_startcopy() <br>* dir_endcopy() <br>* dir_copy() <br>* dir_finalelem() <br>* dir_cleardirect() <br>* dir_adddirect() <br>* dir_addfile() <br>* dir_scan() <br>* dir_isvaliddir() <br>* dir_isvalidfile() <br>* dir_fileinit() <br>* dir_dirinit() <br>* dir_getpathsize() <br>* dir_findnextfile() <br>* <br>* Comments: <br>* <br>* The call dir_buildlist takes a pathname and returns a handle. Subsequent <br>* calls to dir_firstitem and dir_nextitem return handles to <br>* items within the list, from which you can get the name of the <br>* file (relative to the original pathname, or complete), and filesize. <br>* <br>* The list can be either built entirely during the build call, or <br>* built one directory at a time as required by dir_nextitem calls. This <br>* option affects only relative performance, and is taken as a <br>* recommendation only (ie some of the time we will ignore the flag). <br>* <br>* The list is ordered alphabetically (case-insensitive using lstrcmpi). <br>* within any one directory, we list filenames before going on <br>* to subdirectory contents. <br>* <br>* All memory is allocated from a gmem_* heap hHeap declared <br>* and initialised elsewhere. <br>* <br>* The caller gets handles to two things: a DIRLIST, representing the <br>* entire list of filenames, and a DIRITEM: one item within the list. <br>* <br>* From the DIRITEM he can get the filename (including or excluding the <br>* tree root passed to dir_build*) - and also he can get to the next <br>* DIRITEM. <br>* <br>* We permit lazy building of the tree (usually so the caller can keep <br>* the user-interface up-to-date as we go along). In this case, <br>* we need to store information about how far we have scanned and <br>* what is next to do. We need to scan an entire directory at a time and then <br>* sort it so we can return files in the correct order. <br>* <br>* We scan an entire directory and store it in a DIRECT struct. This contains <br>* a list of DIRITEMs for the files in the current directory, and a list of <br>* DIRECTs for the subdirectories (possible un-scanned). <br>* <br>* dir_nextitem will use the list functions to get the next DIRITEM on the list. <br>* When the end of the list is reached, it will use the backpointer back to the <br>* DIRECT struct to find the next directory to scan. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;dos.h&gt; <br>#include &lt;direct.h&gt; <br> <br>#include "gutils.h" <br>#include "list.h" <br>#include "scandir.h" <br>#include "windiff.h" <br>#include "wdiffrc.h" <br> <br>/* <br> * Hold name and information about a given file (one ITEM in a DIRectory) <br> * caller's DIRITEM handle is a pointer to one of these structures <br> */ <br>struct diritem { <br>        LPSTR name;             /* ptr to filename (final element only) */ <br>        long size;              /* filesize */ <br>        struct direct FAR * direct; /* containing directory */ <br>        LPSTR localname;        /* name of temp copy of file */ <br>        BOOL bLocalIsTemp;      /* true if localname is tempfile. <br>                                 */ <br>}; <br> <br> <br>/* DIRECT: Hold state about directory and current position in list of filenames. <br> */ <br>typedef struct direct { <br>        LPSTR relname;          /* name of dir relative to DIRLIST root */ <br>        DIRLIST head;           /* back ptr (to get fullname) */ <br>        struct direct FAR * parent; /* parent directory (NULL if above tree root)*/ <br> <br>        BOOL bScanned;          /* TRUE if scanned */ <br>        LIST diritems;          /* list of DIRITEMs for files in cur. dir */ <br>        LIST directs;           /* list of DIRECTs for child dirs */ <br> <br>        int pos;                /* where are we begin, files, dirs */ <br>        struct direct FAR * curdir; /* subdir being scanned (ptr to list element)*/ <br>} FAR * DIRECT; <br> <br>/* Values for direct.pos */ <br>#define DL_FILES        1       /* reading files from the diritems */ <br>#define DL_DIRS         2       /* in the dirs: List_Next on curdir */ <br> <br> <br>/* <br> * The DIRLIST handle returned from a build function is in fact <br> * a pointer to one of these <br> */ <br>struct dirlist { <br> <br>        char rootname[256];        /* name of root of tree */ <br>        BOOL bFile;             /* TRUE if root of tree is file, not dir */ <br>        DIRECT dot;             /* dir  for '.' - for tree root dir */ <br>}; <br> <br>extern BOOL bAbort;             /* from windiff.c (read only here). */ <br> <br> <br>/* ------ memory allocation ---------------------------------------------*/ <br> <br>/* All memory is allocated from a heap created by the application */ <br>extern HANDLE hHeap; <br> <br>/*-- forward declaration of internal functions ---------------------------*/ <br> <br>LPSTR dir_finalelem(LPSTR path); <br>void dir_cleardirect(DIRECT dir); <br>void dir_adddirect(DIRECT dir, LPSTR path); <br>void dir_addfile(DIRECT dir, LPSTR path, DWORD size); <br>void dir_scan(DIRECT dir, BOOL bRecurse); <br>BOOL dir_isvaliddir(LPSTR path); <br>BOOL dir_isvalidfile(LPSTR path); <br>void dir_fileinit(DIRITEM pfile, DIRECT dir, LPSTR path, long size); <br>void dir_dirinit(DIRECT dir, DIRLIST head, DIRECT parent, LPSTR name); <br>long dir_getpathsize(LPSTR path); <br>DIRITEM dir_findnextfile(DIRLIST dl, DIRECT curdir); <br> <br> <br> <br>/*************************************************************************** <br> * Function: dir_buildlist <br> * <br> * Purpose: <br> * <br> * Build a list of filenames <br> * <br> * Optionally build the list on demand, in which case we scan the <br> * entire directory but don't recurse into subdirs until needed <br> * <br> */ <br> <br>DIRLIST <br>dir_buildlist(LPSTR path, BOOL bOnDemand) <br>{ <br>        DIRLIST dl; <br>        BOOL bFile; <br>         <br>        /* first check if the path is valid */ <br>        if (dir_isvaliddir(path)) { <br>                bFile = FALSE; <br>        } else if (dir_isvalidfile(path)) { <br>                bFile = TRUE; <br>        } else { <br>                /* not valid */ <br>                return(NULL); <br>        } <br> <br> <br>        /* alloc and init the DIRLIST head */ <br> <br>        dl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist)); <br>        memset(dl, 0, sizeof(struct dirlist)); <br> <br>        /* convert the pathname to an absolute path */ <br> <br>        _fullpath(dl-&gt;rootname, path, sizeof(dl-&gt;rootname)); <br> <br>        dl-&gt;bFile = bFile; <br>        /* make a '.' directory for the current directory - <br>         * all files and subdirs will be listed from here <br>         */ <br>        dl-&gt;dot = (DIRECT) gmem_get(hHeap, sizeof(struct direct)); <br>        dir_dirinit(dl-&gt;dot, dl, NULL, "."); <br> <br>        /* were we given a file or a directory ? */ <br>        if (bFile) { <br>                /* its a file. create a single file entry <br>                 * and set the state accordingly <br>                 */ <br>                dl-&gt;dot-&gt;bScanned = TRUE; <br> <br>                dir_addfile(dl-&gt;dot, dir_finalelem(path), <br>                                dir_getpathsize(path)); <br> <br>                return(dl); <br>        } <br> <br>        /* scan the root directory and return. if we are asked <br>         * to scan the whole thing, this will cause a recursive <br>         * scan all the way down the tree <br>         */ <br>        dir_scan(dl-&gt;dot, (!bOnDemand) ); <br> <br>        return(dl); <br>} /* dir_buildlist */ <br> <br>/*************************************************************************** <br> * Function: dir_delete <br> * <br> * Purpose: <br> * <br> * Free up the DIRLIST and all associated memory  <br> */ <br>void <br>dir_delete(DIRLIST dl) <br>{ <br>        if (dl == NULL) { <br>                return; <br>        } <br>        dir_cleardirect(dl-&gt;dot); <br>        gmem_free(hHeap, (LPSTR) dl-&gt;dot, sizeof(struct direct)); <br> <br> <br>        gmem_free(hHeap, (LPSTR) dl, sizeof(struct dirlist)); <br>} <br> <br> <br> <br>/*************************************************************************** <br> * Function: dir_isfile <br> * <br> * Purpose: <br> * <br> * Was the original build request a file or a directory ?  <br> */ <br>BOOL <br>dir_isfile(DIRLIST dl) <br>{ <br>        if (dl == NULL) { <br>                return(FALSE); <br>        } <br> <br>        return(dl-&gt;bFile); <br>} <br> <br>/*************************************************************************** <br> * Function: dir_firstitem <br> * <br> * Purpose: <br> * <br> * Return the first file in the list, or NULL if no files found. <br> * Returns a DIRITEM. This can be used to get filename, size and chcksum. <br> * If there are no files in the root, we recurse down until we find a file. <br> */ <br>DIRITEM <br>dir_firstitem(DIRLIST dl) <br>{ <br>        if (dl == NULL) { <br>                return(NULL); <br>        } <br>        /* <br>         * reset the state to indicate that no files have been read yet <br>         */ <br>        dl-&gt;dot-&gt;pos = DL_FILES; <br>        dl-&gt;dot-&gt;curdir = NULL; <br> <br>        /* now get the next filename */ <br>        return(dir_findnextfile(dl, dl-&gt;dot)); <br>} /* dir_firstitem */ <br> <br> <br>/*************************************************************************** <br> * Function:dir_nextitem <br> * <br> * Purpose: <br> * <br> * Get the next filename after the one given. <br> * <br> * The List_Next function can give us the next element on the list of files. <br> * If this is null, we need to go back to the DIRECT and find the <br> * next list of files to traverse (in the next subdir). <br> * <br> * After scanning all the subdirs, return to the parent to scan further <br> * dirs that are peers of this, if there are any. If we have reached the end of <br> * the tree (no more dirs in dl-&gt;dot to scan), return NULL. <br> * <br> * Don't recurse to lower levels unless fDeep is TRUE <br> */ <br>DIRITEM <br>dir_nextitem(DIRLIST dl, DIRITEM cur, BOOL fDeep) <br>{ <br>        DIRITEM next; <br> <br>        if ((dl == NULL) || (cur == NULL)) { <br>                return(NULL); <br>        } <br>        if (bAbort) return NULL;  /* user requested abort */ <br> <br>        if ( (next = List_Next(cur)) != NULL) { <br>                /* there was another file on this list */ <br>                return(next); <br>        } <br>        if (!fDeep) return NULL; <br> <br>        /* get the head of the next list of filenames from the directory */ <br>        cur-&gt;direct-&gt;pos = DL_DIRS; <br>        cur-&gt;direct-&gt;curdir = NULL; <br>        return(dir_findnextfile(dl, cur-&gt;direct)); <br>} /* dir_nextitem */ <br> <br>/*************************************************************************** <br> * Function: dir_findnextfile <br> * <br> * Purpose: <br> * <br> * Gets the next file in the directory <br> */ <br>DIRITEM <br>dir_findnextfile(DIRLIST dl, DIRECT curdir) <br>{ <br>        DIRITEM curfile; <br> <br>        if ((dl == NULL) || (curdir == NULL)) { <br>                return(NULL); <br>        } <br> <br>        /* scan the subdir if necessary */ <br>        if (!curdir-&gt;bScanned) { <br>                dir_scan(curdir, FALSE); <br>        } <br> <br>        /* have we already read the files in this directory ? */ <br>        if (curdir-&gt;pos == DL_FILES) { <br>                /* no - return head of file list */ <br>                curfile = (DIRITEM) List_First(curdir-&gt;diritems); <br>                if (curfile != NULL) { <br>                        return(curfile); <br>                } <br> <br>                /* no more files - try the subdirs */ <br>                curdir-&gt;pos = DL_DIRS; <br>        } <br> <br>        /* try the next subdir on the list, if any */ <br>        /* is this the first or the next */ <br>        if (curdir-&gt;curdir == NULL) { <br>                curdir-&gt;curdir = (DIRECT) List_First(curdir-&gt;directs); <br>        } else { <br>                curdir-&gt;curdir = (DIRECT) List_Next(curdir-&gt;curdir); <br>        } <br>        /* did we find a subdir ? */ <br>        if (curdir-&gt;curdir == NULL) { <br> <br>                /* no more dirs - go back to parent if there is one */ <br>                if (curdir-&gt;parent == NULL) { <br>                        /* no parent - we have exhausted the tree */ <br>                        return(NULL); <br>                } <br> <br>                /* reset parent state to indicate this is the current <br>                 * directory - so that next gets the next after this. <br>                 * this ensures that multiple callers of dir_nextitem() <br>                 * to the same tree work. <br>                 */ <br>                curdir-&gt;parent-&gt;pos = DL_DIRS; <br>                curdir-&gt;parent-&gt;curdir = curdir; <br> <br>                return(dir_findnextfile(dl, curdir-&gt;parent)); <br>        } <br> <br>        /* there is a next directory - set it to the <br>         * beginning and get the first file from it <br>         */ <br>        curdir-&gt;curdir-&gt;pos = DL_FILES; <br>        curdir-&gt;curdir-&gt;curdir = NULL; <br>        return(dir_findnextfile(dl, curdir-&gt;curdir)); <br> <br>} /* dir_findnextfile */ <br> <br> <br>/*-- pathnames ---- <br> * <br> * This module supports two types of pathnames, called relative and full. <br> * Relative names are relative to the root passed in the initial call <br> * to dir_build*, and full names include the tree root. <br> * <br> * Note that this is a different distinction to relative vs absolute <br> * pathnames, since the tree root may still be either relative or absolute. <br> * <br> * Examples: <br> * <br> *  - if you called dir_buildlist("c:\") <br> *              getrelname gives:               ".\config.sys" <br> *              getfullname gives:              "c:\config.sys" <br> * <br> * - if you called dir_buildlist(".\geraintd") <br> *              getrelname gives:               ".\source\scandir.h" <br> *              getfullname gives either <br> *                      ".\geraintd\source\scandir.h" <br> *                    or "c:\geraintd\source\scandir.h" <br> *                   (depending on the implementation). <br> * <br> * To support this, we maintain the tree root name in the DIRLIST head, and <br> * in each directory, the name of that directory relative to tree root. <br> * Files just have the filename, so we need to prepend the directory name, <br> * and (for getfullname) the tree root name as well <br> * <br> * We store the directory name with a trailing <br> * slash to make concatenation easier <br> * <br> * ----- <br> */ <br> <br>/*************************************************************************** <br> * Function: dir_getrelname <br> * <br> * Purpose: <br> * <br> * Return the name of the current file relative to tree root <br> */ <br>LPSTR <br>dir_getrelname(DIRITEM cur) <br>{ <br>        LPSTR name; <br>        int size; <br> <br>        /* check this is a valid item */ <br>        if (cur == NULL) { <br>                return(NULL); <br>        } <br>        /* remember to include the NULL when sizing */ <br>        size = lstrlen(cur-&gt;direct-&gt;relname) + lstrlen(cur-&gt;name) + 1; <br>        name = gmem_get(hHeap, size); <br>        lstrcpy(name, cur-&gt;direct-&gt;relname); <br>        lstrcat(name, cur-&gt;name); <br> <br>        return(name); <br>} /* dir_getrelname */ <br> <br>/*************************************************************************** <br> * Function: dir_getfullname <br> * <br> * Purpose: <br> * <br> * Return the fullname of the file (including the tree root passed in)  <br> */ <br>LPSTR <br>dir_getfullname(DIRITEM cur) <br>{ <br>        LPSTR name; <br>        int size; <br>        LPSTR head; <br> <br>        /* check this is a valid item */ <br>        if (cur == NULL)  { <br>                return(NULL); <br>        } <br> <br>        if (cur-&gt;direct-&gt;head-&gt;bFile) { <br>                return(cur-&gt;direct-&gt;head-&gt;rootname); <br>        } <br> <br>        /* remember to include the NULL when sizing */ <br>        size = lstrlen(cur-&gt;name) + 1; <br> <br>        size += lstrlen(cur-&gt;direct-&gt;relname); <br> <br>        /* add on root name */ <br>        head = cur-&gt;direct-&gt;head-&gt;rootname; <br>        size += lstrlen(head); <br> <br>        /* root names may not end in a slash. we need to <br>         * insert one in this case. Also, relnames always begin .\, so <br>         * we skip the . always, and the .\ if we don't need to <br>         * append a slash <br>         * <br>         */ <br>        size--;         /* omit the '.' */ <br>        if (*CharPrev(head, head+lstrlen(head)) == '\\') { <br>                size--;                         /* omit the .\ */ <br>        } <br> <br>        name = gmem_get(hHeap, size); <br> <br>        lstrcpy(name, cur-&gt;direct-&gt;head-&gt;rootname); <br> <br>        /* add relname and then name, omiting the .\ */ <br> <br>                /* skip . or .\ before relname */ <br>                if (*CharPrev(head, head+lstrlen(head)) == '\\') { <br>                        lstrcat(name, &amp;cur-&gt;direct-&gt;relname[2]); <br>                } else { <br>                        lstrcat(name, &amp;cur-&gt;direct-&gt;relname[1]); <br>                } <br>                lstrcat(name, cur-&gt;name); <br>        return(name); <br>} /* dir_getfullname */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_getroot_list <br> * <br> * Purpose: <br> * <br> * Return the name of the tree root given a handle to the DIRLIST. <br> */ <br>LPSTR <br>dir_getroot_list(DIRLIST dl) <br>{ <br>        if (dl == NULL)  <br>                return(NULL); <br>        return(dl-&gt;rootname); <br>} /* dir_getroot_list */ <br> <br>/*************************************************************************** <br> * Function: dir_getroot_item <br> * <br> * Purpose: <br> * <br> * Return the root name of this tree given a handle to a DIRITEM in the <br> * list. <br> */ <br>LPSTR dir_getroot_item(DIRITEM item) <br>{ <br>        if (item == NULL)  <br>                return(NULL); <br> <br>        return(dir_getroot_list(item-&gt;direct-&gt;head)); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: dir_freerelname <br> * <br> * Purpose: <br> * <br> * Free up a relname that we allocated. This interface allows us <br> * some flexibility in how we store relative and complete names <br> * <br> */ <br>void <br>dir_freerelname(DIRITEM cur, LPSTR name) <br>{ <br>        if((cur != NULL) &amp;&amp; (name != NULL)) <br>                        gmem_free(hHeap, name, lstrlen(name) +1); <br>} /* dir_freerelname */ <br> <br>/*************************************************************************** <br> * Function: dir_freefullname <br> * <br> * Purpose: <br> * <br> */ <br>void <br>dir_freefullname(DIRITEM cur, LPSTR name) <br>{ <br>        if (cur-&gt;direct-&gt;head-&gt;bFile) <br>                return; <br> <br>        if (name != NULL)  <br>                gmem_free(hHeap, name, lstrlen(name) + 1); <br>} /* dir_freefullname            */ <br> <br>/*************************************************************************** <br> * Function: dir_freeroot_list <br> * <br> * Purpose: <br> * <br> * Free up rootname allocated by dir_getroot_list. <br> * We just gave a pointer to the rootname, so do nothing. <br> */ <br>void <br>dir_freeroot_list(DIRLIST dl, LPSTR name) <br>{ <br>        if ((dl == NULL) || (name == NULL)) { <br>                return; <br>        } <br>        return; <br>} /* dir_freeroot_list */ <br> <br>/*************************************************************************** <br> * Function: dir_freeroot_item <br> * <br> * Purpose: <br> * <br> * Free up memory alloc-ed by a call to dir_getroot_item.  <br> */ <br>void <br>dir_freeroot_item(DIRITEM item, LPSTR name) <br>{ <br>        if ((item == NULL) || (name == NULL))  <br>                return; <br>        dir_freeroot_list(item-&gt;direct-&gt;head, name); <br>} <br> <br>/*************************************************************************** <br> * Function: dir_getopenname <br> * <br> * Purpose: <br> * <br> * Get an open-able name for the file. This will be the same as the fullname. <br> */ <br>LPSTR <br>dir_getopenname(DIRITEM item) <br>{ <br>        LPSTR fname; <br> <br>        if (item == NULL)  <br>                return(NULL); <br> <br>        fname = dir_getfullname(item); <br> <br>                return(fname); <br>} /* dir_getopenname */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_freeopenname <br> * <br> * Purpose: <br> * <br> * Free up memory created by a call to dir_getopenname(). This *may* <br> * cause the file to be deleted if it was a temporary copy. <br> */ <br>void <br>dir_freeopenname(DIRITEM item, LPSTR openname) <br>{ <br>        if ((item == NULL) || (openname == NULL))  <br>                return; <br> <br>        dir_freefullname(item, openname); <br>} /* dir_freeopenname */ <br> <br>/*************************************************************************** <br> * Function: dir_openfile <br> * <br> * Purpose: <br> * <br> * Return an open file handle to the file.  <br> */ <br>int <br>dir_openfile(DIRITEM item) <br>{ <br>        LPSTR fname; <br>        int fh; <br>        OFSTRUCT os; <br> <br>        fname = dir_getfullname(item); <br>        fh = OpenFile(fname, &amp;os, OF_READ|OF_SHARE_DENY_NONE); <br>        dir_freefullname(item, fname); <br>        return(fh); <br>} /* dir_openfile */ <br> <br>/*************************************************************************** <br> * Function: dir_closefile <br> * <br> * Purpose: <br> * <br> * Close a file opened with dir_openfile. <br> */ <br>void <br>dir_closefile(DIRITEM item, int fh) <br>{ <br>        _lclose(fh); <br> <br>} /* dir_closefile */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_getfilesize <br> * <br> * Purpose: <br> * <br> * Return the file size (set during scanning)  <br> */ <br>long <br>dir_getfilesize(DIRITEM cur) <br>{ <br>        /* check this is a valid item */ <br>        if (cur == NULL) <br>                return(0); <br> <br>        return(cur-&gt;size); <br>} /* dir_getfilesize */ <br> <br> <br> <br>/* ss_endcopy returns a number indicating the number of files copied, <br>   but we may have some local copies too.  We need to count these <br>   ourselves and add them in <br>*/ <br> <br>int nLocalCopies;        /* cleared in startcopy, ++d in copy <br>                                ** inspected in endcopy <br>                                */ <br> <br>/*************************************************************************** <br> * Function: dir_startcopy <br> * <br> * Purpose: <br> * <br> * Start a bulk copy  <br> */ <br>BOOL dir_startcopy(DIRLIST dl) <br>{ <br>        nLocalCopies = 0; <br>        return(TRUE); <br> <br>} /* dir_startcopy */ <br>/*************************************************************************** <br> * Function: dir_endcopy <br> * <br> */ <br>  <br>int dir_endcopy(DIRLIST dl) <br>{ <br>        return(nLocalCopies); <br> <br>} /* dir_endcopy */ <br> <br>/*************************************************************************** <br> * Function: dir_copy <br> * <br> * Purpose: <br> * <br> * Create a copy of the file, in the new root directory. Creates sub-dirs as <br> * necessary.  <br> * <br> * Returns TRUE for success and FALSE for failure. <br> */ <br>BOOL dir_copy(DIRITEM item, LPSTR newroot) <br>{ <br>        static char newpath[256]; <br>        LPSTR relname, fullname; <br>        LPSTR pstart, pdest, pel; <br>        BOOL bOK; <br> <br>        BY_HANDLE_FILE_INFORMATION bhfi; <br>        HANDLE hfile; <br> <br>        /* <br>         * check that the newroot directory itself exists <br>         */ <br>        if ((item == NULL) || !dir_isvaliddir(newroot)) { <br>                return(FALSE); <br>        } <br> <br>        /* <br>         * name of file relative to the tree root <br>         */ <br>        relname = dir_getrelname(item); <br> <br>        /* <br>         * build the new pathname by concatenating the new root and <br>         * the old relative name. add one path element at a time and <br>         * ensure that the directory exists, creating it if necessary. <br>         */ <br>        lstrcpy(newpath, newroot); <br> <br>        /* add separating slash if not already there */ <br>        if (*CharPrev(newpath, newpath+lstrlen(newpath)) != '\\') { <br>                lstrcat(newpath, "\\"); <br>        } <br> <br>        pstart = relname; <br>        while ( (pel = strchr(pstart, '\\')) != NULL) { <br> <br>                /* found another element ending in slash. incr past the \\ */ <br>                pel++; <br> <br>                /* <br>                 * ignore . <br>                 */ <br>                if (strncmp(pstart, ".\\", 2) != 0) { <br> <br>                        pdest = &amp;newpath[lstrlen(newpath)]; <br>                        strncpy(pdest, pstart, pel - pstart); <br>                        pdest[pel - pstart] = '\0'; <br> <br>                        /* create subdir if necessary */ <br>                        if (!dir_isvaliddir(newpath)) { <br>                                if (_mkdir(newpath) != 0) { <br>                                        return(FALSE); <br>                                } <br>                        } <br>                } <br> <br>                pstart = pel; <br>        } <br> <br>        /* <br>         * there are no more slashes, so pstart points at the final <br>         * element <br>         */ <br>        lstrcat(newpath, pstart); <br> <br>        fullname = dir_getfullname(item); <br> <br>                bOK = CopyFile(fullname, newpath, FALSE); <br> <br>                /* having copied the file, now copy the times, attributes */ <br>                hfile = CreateFile(fullname, GENERIC_READ, 0, NULL, <br>                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); <br>                bhfi.dwFileAttributes = GetFileAttributes(fullname); <br>                GetFileTime(hfile, &amp;bhfi.ftCreationTime, <br>                                &amp;bhfi.ftLastAccessTime, &amp;bhfi.ftLastWriteTime); <br>                CloseHandle(hfile); <br> <br>                hfile = CreateFile(newpath, GENERIC_WRITE, 0, NULL, <br>                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); <br>                SetFileTime(hfile, &amp;bhfi.ftCreationTime, <br>                                   &amp;bhfi.ftLastAccessTime, <br>                                   &amp;bhfi.ftLastWriteTime); <br>                CloseHandle(hfile); <br>                SetFileAttributes(newpath, bhfi.dwFileAttributes); <br> <br> <br>                if (bOK) ++nLocalCopies; <br> <br>        dir_freerelname(item, relname); <br>        dir_freefullname(item, fullname); <br> <br>        return(bOK); <br>} /* dir_copy */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_dirinit <br> * <br> * Purpose: <br> * <br> * Fill out a new DIRECT for a subdirectory (pre-allocated). <br> * Init files and dirs lists to empty (List_Create). Set the relname <br> * of the directory by pre-pending the parent relname if there <br> * is a parent, and appending a trailing slash (if there isn't one). <br> */ <br>void <br>dir_dirinit(DIRECT dir, DIRLIST head, DIRECT parent, LPSTR name) <br>{ <br>        int size; <br> <br>        dir-&gt;head = head; <br>        dir-&gt;parent = parent; <br> <br>        /* add on one for the null and one for the trailing slash */ <br>        size = lstrlen(name) + 2; <br>        if (parent != NULL) { <br>                size += lstrlen(parent-&gt;relname); <br>        } <br> <br>        /* build the relname from the parent and the current name <br>         * with a terminating slash <br>         */ <br>        dir-&gt;relname = gmem_get(hHeap, size); <br>        if (parent != NULL) { <br>                lstrcpy(dir-&gt;relname, parent-&gt;relname); <br>        } else{ <br>                dir-&gt;relname[0] = '\0'; <br>        } <br> <br>        lstrcat(dir-&gt;relname, name); <br> <br>        if (*CharPrev(dir-&gt;relname, <br>                        dir-&gt;relname+lstrlen(dir-&gt;relname)) != '\\') { <br>                lstrcat(dir-&gt;relname, "\\"); <br>        } <br> <br>        /* force name to lowercase */ <br>        AnsiLowerBuff(dir-&gt;relname, lstrlen(dir-&gt;relname)); <br> <br>        dir-&gt;diritems = List_Create(); <br>        dir-&gt;directs = List_Create(); <br>        dir-&gt;bScanned = FALSE; <br>        dir-&gt;pos = DL_FILES; <br> <br>} /* dir_dirinit */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_fileinit <br> * <br> * Purpose: <br> * <br> * Initialise the contents of an (allocated) DIRITEM struct.  <br> */ <br>void <br>dir_fileinit(DIRITEM pfile, DIRECT dir, LPSTR path, long size) <br>{ <br> <br>        pfile-&gt;name = gmem_get(hHeap, lstrlen(path) + 1); <br>        lstrcpy(pfile-&gt;name, path); <br> <br>        /* force name to lower case */ <br>        AnsiLowerBuff(pfile-&gt;name, lstrlen(path)); <br> <br>        pfile-&gt;direct = dir; <br>        pfile-&gt;size = size; <br> <br>        pfile-&gt;localname = NULL; <br> <br>} /* dir_fileinit */ <br> <br>/*************************************************************************** <br> * Function: dir_isfilevalid <br> * <br> * Purpose: <br> * <br> * Is this a valid file or not  <br> */ <br>BOOL <br>dir_isvalidfile(LPSTR path) <br>{ <br>        DWORD dwAttrib; <br> <br>        dwAttrib = GetFileAttributes(path); <br>        if (dwAttrib == -1) { <br>                return(FALSE); <br>        } <br>        if (dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY) { <br>                return(FALSE); <br>        } <br>        return(TRUE); <br>} /* dir_isvalidfile */ <br> <br>/*************************************************************************** <br> * Function: dir_isvaliddir <br> * <br> * Purpose: <br> * <br> * Is this a valid directory ?  <br> */ <br>BOOL <br>dir_isvaliddir(LPSTR path) <br>{ <br>        DWORD dwAttrib; <br> <br>        dwAttrib = GetFileAttributes(path); <br>        if (dwAttrib == -1) { <br>                return(FALSE); <br>        } <br>        if (dwAttrib &amp; FILE_ATTRIBUTE_DIRECTORY) { <br>                return(TRUE); <br>        } <br>        return(FALSE); <br>} /* dir_isvaliddir */ <br> </code></pre>
<p>
</p>
<pre><code>/*************************************************************************** <br> * Function: dir_scan <br> * <br> * Purpose: <br> * <br> * Scan the directory given. Add all files to the list <br> * in alphabetic order, and add all directories in alphabetic <br> * order to the list of child DIRITEMs. If bRecurse is true, go on to <br> * recursive call dir_scan for each of the child DIRITEMs <br> */ <br>void <br>dir_scan(DIRECT dir, BOOL bRecurse) <br>{ <br>        PSTR path; <br>        int size; <br>        DIRECT child; <br>        BOOL bMore; <br>        long filesize; <br>        BOOL bIsDir; <br>        LPSTR name; <br> <br>        HANDLE hFind; <br>        WIN32_FIND_DATA finddata; <br> <br>        char debugmsg[200]; <br>        wsprintf(debugmsg, "scandir: %s %s\n", <br>                 dir-&gt;relname, bRecurse?"recursive":"non-recursive" <br>                ); <br> <br>        /* make the complete search string including *.* */ <br>        size = lstrlen(dir-&gt;head-&gt;rootname); <br>        size += lstrlen(dir-&gt;relname); <br> <br>        /* add on one null and *.* */ <br>        size += 4; <br> <br>        path = LocalLock(LocalAlloc(LHND, size)); <br> <br>        lstrcpy(path, dir-&gt;head-&gt;rootname); <br> <br>        /* omit the . at the beginning of the relname, and the <br>         * .\ if there is a trailing \ on the rootname <br>         */ <br>        if (*CharPrev(path, path+lstrlen(path)) == '\\') { <br>                lstrcat(path, &amp;dir-&gt;relname[2]); <br>        } else { <br>                lstrcat(path, &amp;dir-&gt;relname[1]); <br>        } <br>        lstrcat(path, "*.*"); <br> <br>        /* read all entries in the directory */ <br>        hFind = FindFirstFile(path, &amp;finddata); <br>        bMore = (hFind != (HANDLE) -1); <br>        LocalUnlock(LocalHandle ( (PSTR) path)); <br>        LocalFree(LocalHandle ( (PSTR) path)); <br> <br>        while (bMore) { <br> <br>                bIsDir = (finddata.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY); <br>                name = (LPSTR) &amp;finddata.cFileName; <br>                filesize = finddata.nFileSizeLow; <br>                if (!bIsDir) { <br> <br>                        dir_addfile(dir, name, filesize); <br> <br>                } else if ( (lstrcmp(name, ".") != 0) &amp;&amp; <br>                           ( lstrcmp(name, "..") != 0) ) { <br> <br>                        dir_adddirect(dir, name); <br>                } <br> <br>                bMore = FindNextFile(hFind, &amp;finddata); <br>        } <br> <br>        FindClose(hFind); <br> <br>        dir-&gt;bScanned = TRUE; <br>        dir-&gt;pos = DL_FILES; <br> <br>        if (bRecurse) { <br>                List_TRAVERSE(dir-&gt;directs, child) { <br>                        dir_scan(child, TRUE); <br>                } <br>        } <br> <br>} /* dir_scan */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_addfile <br> * <br> * Purpose: <br> * <br> * Add the file 'path' to the list of files in dir, in order. <br> */ <br>void <br>dir_addfile(DIRECT dir, LPSTR path, DWORD size) <br>{ <br>        DIRITEM pfile; <br> <br>        AnsiLowerBuff(path, lstrlen(path));  // needless? <br> <br>        List_TRAVERSE(dir-&gt;diritems, pfile) { <br>                /////if (lstrcmpi(pfile-&gt;name, path) &gt; 0) { <br>                if (utils_CompPath(pfile-&gt;name, path) &gt; 0) { <br> <br>                        /* goes before this one */ <br>                        pfile = List_NewBefore(dir-&gt;diritems, pfile, sizeof(struct diritem)); <br>                        dir_fileinit(pfile, dir, path, size); <br>                        return; <br>                } <br>        } <br>        /* goes at end */ <br>        pfile = List_NewLast(dir-&gt;diritems, sizeof(struct diritem)); <br>        dir_fileinit(pfile, dir, path, size); <br>} /* dir_addfile */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_addirect <br> * <br> * Purpose: <br> * <br> * Add a new directory in alphabetic order on <br> * the list dir-&gt;directs <br> * <br> */ <br>void <br>dir_adddirect(DIRECT dir, LPSTR path) <br>{ <br>        DIRECT child; <br>        LPSTR finalel; <br>        char achTempName[256]; <br> <br>        AnsiLowerBuff(path, lstrlen(path)); <br>        List_TRAVERSE(dir-&gt;directs, child) { <br> <br>                int cmpval; <br> <br>                /* we need to compare the child name with the new name. <br>                 * the child name is a relname with a trailing <br>                 * slash - so compare only the name up to but <br>                 * not including the final slash. <br>                 */ <br>                finalel = dir_finalelem(child-&gt;relname); <br> <br>                /* <br>                 * we cannot use strnicmp since this uses a different <br>                 * collating sequence to lstrcmpi. So copy the portion <br>                 * we are interested in to a null-term. buffer. <br>                 */ <br>                strncpy(achTempName, finalel, lstrlen(finalel)-1); <br>                achTempName[lstrlen(finalel)-1] = '\0'; <br> <br>                cmpval = utils_CompPath(achTempName, path); <br> <br>                if (cmpval &gt; 0) { <br> <br>                        /* goes before this one */ <br>                        child = List_NewBefore(dir-&gt;directs, child, sizeof(struct direct)); <br>                        dir_dirinit(child, dir-&gt;head, dir, path); <br>                        return; <br>                } <br>        } <br>        /* goes at end */ <br>        child = List_NewLast(dir-&gt;directs, sizeof(struct direct)); <br>        dir_dirinit(child, dir-&gt;head, dir, path); <br>} /* dir_adddirect */ <br> <br> <br>/*************************************************************************** <br> * Function: dir_cleardirect <br> * <br> * Purpose: <br> * <br> * Free all memory associated with a DIRECT (including freeing <br> * child lists). Don't de-alloc the direct itself (allocated on a list) <br> */ <br>void <br>dir_cleardirect(DIRECT dir) <br>{ <br>        DIRITEM pfile; <br>        DIRECT child; <br> <br>        /* clear contents of files list */ <br>        List_TRAVERSE(dir-&gt;diritems, pfile) { <br>                gmem_free(hHeap, pfile-&gt;name, lstrlen(pfile-&gt;name)); <br>                if ((pfile-&gt;localname) &amp;&amp; (pfile-&gt;bLocalIsTemp)) { <br> <br>                        /* <br>                         * the copy will have copied the attributes, <br>                         * including read-only. We should unset this bit <br>                         * so we can delete the temp file. <br>                         */ <br>                        SetFileAttributes(pfile-&gt;localname, <br>                                GetFileAttributes(pfile-&gt;localname) <br>                                        &amp; ~FILE_ATTRIBUTE_READONLY); <br>                        DeleteFile(pfile-&gt;localname); <br>                        gmem_free(hHeap, pfile-&gt;localname, 256); <br>                        pfile-&gt;localname = NULL; <br>                } <br> <br>        } <br>        List_Destroy(&amp;dir-&gt;diritems); <br> <br>        /* clear contents of dirs list (recursively) */ <br>        List_TRAVERSE(dir-&gt;directs, child) { <br>                dir_cleardirect(child); <br>        } <br>        List_Destroy(&amp;dir-&gt;directs); <br> <br>        gmem_free(hHeap, dir-&gt;relname, lstrlen(dir-&gt;relname) + 1); <br> <br>} /* dir_cleardirect */ <br> <br>/*************************************************************************** <br> * Function: dir_finalelem <br> * <br> * Purpose: <br> * <br> * Return a pointer to the final element in a path. Note that <br> * we may be passed relnames with a trailing final slash - ignore this <br> * and return the element before that final slash. <br> */ <br>LPSTR <br>dir_finalelem(LPSTR path) <br>{ <br>        LPSTR chp; <br>        int size; <br> <br>        /* is the final character a slash ? */ <br>        size = lstrlen(path) - 1; <br>        if (*(chp = CharPrev(path, path+lstrlen(path))) == '\\') { <br>                /* find the slash before this */ <br>                while (chp &gt; path) { <br>                        if (*(chp = CharPrev(path, chp)) == '\\') { <br>                                /* skip the slash itself */ <br>                                chp++; <br>                                break; <br>                        } <br>                } <br>                return(chp); <br>        } <br>        /* look for final slash */ <br>        chp = strrchr(path, '\\'); <br>        if (chp != NULL) { <br>                return(chp+1); <br>        } <br> <br>        /* no slash - is there a drive letter ? */ <br>        chp = strrchr(path, ':'); <br>        if (chp != NULL) { <br>                return(chp+1); <br>        } <br> <br>        /* this is a final-element anyway */ <br>        return(path); <br> <br>} /* dir_finalelem */ <br> <br>/*************************************************************************** <br> * Function: dir_getpathsize <br> * <br> * Purpose: <br> * <br> * Find the size of a file given a pathname to it  <br> */ <br>long <br>dir_getpathsize(LPSTR path) <br>{ <br>        int fh; <br>        OFSTRUCT os; <br>        long size; <br>        fh = OpenFile(path, &amp;os, OF_READ|OF_SHARE_DENY_NONE); <br>        if (fh == -1) { <br>                return(0); <br>        } <br> <br>        size = GetFileSize( (HANDLE) fh, NULL); <br>        _lclose(fh); <br>        return(size); <br>} /* dir_getpathsize */ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
