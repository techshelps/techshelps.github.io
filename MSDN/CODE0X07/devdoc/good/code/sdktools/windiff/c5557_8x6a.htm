<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINDIFF.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5572"></a>WINDIFF.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: WINDIFF.C <br>* <br>* File and directory comparisions. <br>* <br>* Functions: <br>* <br>* windiff_UI() <br>* WinMain() <br>* windiff_usage() <br>* Poll() <br>* DoResize() <br>* AboutBox() <br>* DoPrint() <br>* FindNextChange() <br>* FindPrevChange() <br>* WriteProfileInt() <br>* ToOutline() <br>* ToMoved() <br>* do_editfile() <br>* do_editthread() <br>* SetStatus() <br>* SetNames() <br>* IsBusy() <br>* BusyError() <br>* StateToColour() <br>* SetSelection() <br>* do_gethdr() <br>* do_getprops() <br>* do_getdata() <br>* SvrClose() <br>* TableServer() <br>* wd_dirdialog() <br>* wd_copy() <br>* InitApplication() <br>* InitInstance() <br>* CreateTools() <br>* DeleteTools() <br>* MainWndProc() <br>* SetBusy() <br>* SetNotBusy() <br>* SetSelection() <br>* SetButtonText() <br>* ToExpand() <br>* ParseArgs() <br>* wd_initial() <br>* <br>* Comments: <br>* <br>* Compare two directories (including all files and subdirs). Look for names <br>* that are present in both (report all that are not). For files that <br>* are present in both, produce a line-by-line comparison of the differences <br>* between the two files (if any). <br>* <br>* Overview of Windiff internals - the whole program. <br>* <br>* Windiff is built from several modules (a "module" has a .h file <br>* which describes its interface and a .c file which implements it). <br>* Apart from THIS comment which tries to give an overview of the whole <br>* scheme of things, each module is as self-contained as possible. <br>* This is enforced by the use of opaque data types.  Modules cannot <br>* see each others' internal data structures.  Modules are abstract <br>* data types.  The term "Module" (from Modula2) and "Class" (from C++) <br>* are used synonymously. <br>* <br>*    Windiff  - main program - parse arguments, put up main window, <br>*               handle input, calling other modules as needed <br>*               invoke table class to create the main display and <br>*               service callbacks from the table class. <br>*               Contains global flags for options (e.g. ignore_blanks) <br>*    list     - (in gutils) a generalised LIST of anything data type <br>*               has full set of operations for insert, delete, join etc. <br>*    line     - a LINE is a numbered line of text.  Information is kept to <br>*               allow fast comparisons of LINEs.  A LINE can hold a <br>*               link to another LINE.  The links are used to connect <br>*               lines in one file to matching lines in the other file. <br>*    file     - a FILEDATA represents a file as a file name in the form <br>*               of a DIRITEM and a LIST of LINEs <br>*    scandir  - a DIRITEM represents information about a file.  (for <br>*               instance its name, whether it has a local copy). <br>*    compitem - a COMPITEM is a pair of files together with information <br>*               on how they compare in the form of a breakdown of the <br>*               files into a LIST of matching or non-matching sections. <br>*               Either file can be absent.  This module contains the <br>*               file "contrast" algorithm used for the actual comparison <br>*    tree       (in gutils) A binary tree.  Important because it is what <br>*               gives the file comparison its speed as it makes it <br>*               an "N log N" algorithm rather than "N squared" <br>*    complist - a COMPLIST is the master data structure.  It has a DIRLIST <br>*               of the left hand files, a DIRLIST of the right hand files <br>*               and a LIST of COMPITEMs. The left and right hand DIRLISTs <br>*               are working data used to produce the COMPLIST.  The LIST <br>*               is displayed as the outline table.  Any given COMPITEM can <br>*               be displayed as an expanded item. <br>*    section  - a SECTION is a section of a file (first line, last line) <br>*               and information as to what it matches in the other file. <br>*    bar.c    - the picture down the left of the screen <br>*               has a WNDPROC.   <br>*    view     - Although the COMPLIST is the master state, it doesn't do <br>*               all the work itself.  The data is actually displayed by <br>*               the table class which is highly generalised.  View <br>*               owns a COMPLIST (and therefore calls upon the functions <br>*               in complist to fill it and interrogate it) and calls <br>*               upon (and is called back by) the functions in table to <br>*               actually display it.  Read about table in gutils.h <br>*    table.c    (in gutils) a highly generalised system for displaying <br>*               data in rows and columns.  The interface is in gutils.h. <br>*    status.c   (in gutils) the status line at the top. See gutils.h <br>************************************************************************* <br>* <br>* Overview of this file: <br>* <br>*   We create a table window (gutils.dll) to show the files and the <br>*   results of their comparisons. We create a COMPLIST object representing <br>*   a list of files and their differences, and a VIEW object to map between <br>*   the rows of the table window and the COMPLIST. <br>* <br>*   This module is responsible for creating and managing the main window, <br>*   placing the child windows (table, status window etc) within it, and <br>*   handling all menu items. We maintain global option flags set by <br>*   menu commands. <br>* <br>*   Creating a COMPLIST creates a list of unmatched files, and of matching <br>*   files that are compared with each other (these are COMPITEMS). <br>*   The VIEW provides a mapping between rows on the screen, and items in <br>*   the COMPLIST. <br>* <br>*   This version tries to maintain a responsive user interface by <br>*   creating worker threads to do long jobs.  This potentially creates <br>*   conflicts between the threads as they will both want to update common <br>*   variables (for instance the UI thread may be changing the options to <br>*   exclude identical files while the worker thread is adding in the <br>*   results of new comparisons).  Critical sections are used to manage <br>*   the conflicts. <br>* <br>*   The Edit options invoke an editor on a separate thread.  This allows <br>*   us to repaint our window and thereby allow the user to refer back to <br>*   what he saw before invoking the editor.  When he's finished editing, <br>*   we would of course like to refresh things and if this is still on the <br>*   separate thread it might clash. We avoid this clash by POSTing ourselves <br>*   a (WM_COMMAND, IDM_UPDATE) message. <br>* <br>****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "gutils.h" <br>#include "table.h" <br>#include "list.h" <br>#include "scandir.h"            /* needed for file.h     */ <br>#include "file.h"               /* needed for compitem.h */ <br>#include "compitem.h"           /* needed for view.h     */ <br>#include "complist.h" <br>#include "view.h" <br>#include "state.h" <br>#include "windiff.h" <br>#include "wdiffrc.h" <br> <br> <br>/*--constants and data types--------------------------------------------*/ <br> <br>int Version = 2; <br>int SubVersion = 01; <br> <br>/* When we print the current table, we pass this id as the table id <br> * When we are queried for the properties of this table, we know they <br> * want the printing properties for the current view. We use this to <br> * select different fonts and colours for the printer. <br> */ <br>#define TABID_PRINTER   1 <br> <br> <br> <br>/* <br> * structure containing args passed to worker thread in initial <br> * case (executing command line instructions).  <br> */ <br>typedef struct { <br> <br>        LPSTR first; <br>        LPSTR second; <br>        LPSTR savelist; <br>        UINT saveopts; <br>        VIEW view; <br>        BOOL fDeep; <br>} THREADARGS, FAR * PTHREADARGS; <br> <br> <br>/* Structure containing all the arguments we'd like to give to do_editfile <br>   Need a structure because CreateThread only allows for one argument. <br>*/ <br>typedef struct { <br>        VIEW view; <br>        int option; <br>        int selection; <br>} EDITARGS, FAR * PEDITARGS; <br> <br>/*---- colour scheme------------------------------- */ <br> <br>/* outline */ <br>DWORD rgb_outlinehi = RGB(255, 0, 0);   /* hilighted files in outline mode  */ <br> <br>/* expand view */ <br>DWORD rgb_leftfore =   RGB(  0,   0,   0);         /* foregrnd for left lines */ <br>DWORD rgb_leftback  =  RGB(255,   0,   0);         /* backgrnd for left lines */ <br>DWORD rgb_rightfore =  RGB(  0,   0,   0);         /* foregrnd for right lines*/ <br>DWORD rgb_rightback =  RGB(255, 255,   0);         /* backgrnd for right lines*/ <br> <br>/* moved lines */ <br>DWORD rgb_mleftfore =  RGB(  0,   0, 128);         /* foregrnd for moved-left */ <br>DWORD rgb_mleftback =  RGB(255,   0,   0);         /* backgrnd for moved-left */ <br>DWORD rgb_mrightfore = RGB(  0,   0, 255);         /* foregrnd for moved-right*/ <br>DWORD rgb_mrightback = RGB(255, 255,   0);         /* backgrnd for moved-right*/ <br> <br>/* bar window */ <br>DWORD rgb_barleft =    RGB(255,   0,   0);         /* bar sections in left only  */ <br>DWORD rgb_barright =   RGB(255, 255,   0);         /* bar sections in right only */ <br>DWORD rgb_barcurrent = RGB(  0,   0, 255);         /* current pos markers in bar */ <br> <br> <br>/* module static data -------------------------------------------------*/ <br> <br> <br>/* current value of window title */ <br>char AppTitle[256]; <br> <br> <br>HWND hwndClient;        /* main window */ <br>HWND hwndRCD;           /* table window */ <br>HWND hwndStatus;        /* status bar across top */ <br>HWND hwndBar;           /* graphic of sections as vertical bars */ <br> <br>HACCEL haccel; <br> <br>/* The status bar told us it should be this high. Rest of client area <br> * goes to the hwndBar and hwndRCD. <br> */ <br>int status_height; <br> <br>HINSTANCE hInst;   /* handle to current app instance */ <br>HMENU hMenu;    /* handle to menu for hwndClient */ <br> <br>int nMinMax = SW_SHOWNORMAL;         /* default state of window normal */ <br> <br>/* The message sent to us as a callback by the table window needs to be <br> * registered - table_msgcode is the result of the RegisterMessage call <br> */ <br>UINT table_msgcode; <br> <br>/* True if we are currently doing some scan or comparison. <br> * Must get critical section before checking/changing this (call <br> * SetBusy. <br> */ <br>BOOL fBusy = FALSE; <br> <br>int     selection       =       -1;     /* selected row in table*/ <br> <br>/* Options for DisplayMode field indicating what is currently shown. <br> * We use this to know whether or not to show the graphic bar window. <br> */ <br>#define MODE_NULL       0       /* nothing displayed */ <br>#define MODE_OUTLINE    1       /* a list of files displayed */ <br>#define MODE_EXPAND     2       /* view is expanded view of one file */ <br> <br>int DisplayMode = MODE_NULL;    /* indicates whether we are in expand mode */ <br> <br>VIEW current_view = NULL; <br> <br>/* command line parameters */ <br>extern int __argc; <br>extern char ** __argv; <br> <br>BOOL bAbort = FALSE;    /* set to request abort of current operation */ <br> <br>char editor_cmdline[256] = "notepad %p";  /* editor cmdline */ <br>                          /* slick version is "s %p -#%l" */ <br> <br>/* app-wide global data --------------------------------------------- */ <br> <br>/* Handle returned from gmem_init - we use this for all memory allocations */ <br>HANDLE hHeap; <br> <br>/* Current state of menu options */ <br>int line_numbers = IDM_LNRS; <br>int expand_mode = IDM_BOTHFILES; <br>int outline_include = INCLUDE_LEFTONLY|INCLUDE_RIGHTONLY|INCLUDE_SAME|INCLUDE_DIFFER; <br>BOOL ignore_blanks = TRUE; <br>BOOL picture_mode = TRUE; <br> <br>/* function prototypes ---------------------------------------------*/ <br> <br>BOOL InitApplication(HINSTANCE hInstance); <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow); <br>void CreateTools(void); <br>void DeleteTools(void); <br>long APIENTRY MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam); <br>BOOL SetBusy(void); <br>void SetNotBusy(void); <br>void SetSelection(long rownr); <br>void SetButtonText(LPSTR cmd); <br>BOOL ToExpand(HWND hwnd); <br>void ParseArgs(int argc, char ** argv); <br> <br> <br>DWORD wd_initial(LPVOID arg); <br> <br>static HANDLE ghThread = NULL; <br> <br>static DWORD gdwMainThreadId;     /* threadid of main (user interface) thread <br>                                     initialised in winmain(), thereafter constant. <br>                                     See windiff_UI() <br>                                  */ <br> <br>/*************************************************************************** <br> * Function: windiff_UI <br> * <br> * Purpose: <br> * <br> * If you are about to put up a dialog box or in fact process input in any way <br> * on any thread other than the main thread - or if you MIGHT be on a thread other <br> * than the main thread, then you must call this function with TRUE before doing <br> * it and with FALSE immediately afterwards.  Otherwise you will get one of a <br> * number of flavours of not-very-responsiveness <br> */ <br>void windiff_UI(BOOL bAttach) <br>{ <br>        DWORD dwThreadId = GetCurrentThreadId(); <br>        if (dwThreadId==gdwMainThreadId) return; <br> <br>        if (bAttach) GetDesktopWindow(); <br>        AttachThreadInput(dwThreadId, gdwMainThreadId, bAttach); <br>} /* windiff_UI */ <br> <br>/*************************************************************************** <br> * Function: WinMain <br> * <br> * Purpose: <br> * <br> * Main entry point. Register window classes, create windows, <br> * parse command line arguments and then perform a message loop <br> */ <br>int WINAPI <br>WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>        MSG msg; <br> <br>        gdwMainThreadId = GetCurrentThreadId(); <br> <br>        /* create any pens/brushes etc and read in profile defaults */ <br>        CreateTools(); <br> <br>        /* init window class unless other instances running */ <br>        if (!hPrevInstance) <br>            if (!InitApplication(hInstance)) <br>                return(FALSE); <br> <br> <br>        /* init this instance - create all the windows */ <br>        if (!InitInstance(hInstance, nCmdShow)) <br>            return(FALSE); <br> <br>        ParseArgs(__argc, __argv); <br> <br> <br>        /* message loop */ <br>        while(GetMessage(&amp;msg, NULL, 0, 0)) { <br>                if (!TranslateAccelerator(hwndClient, haccel, &amp;msg)) { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>        } <br> <br>        return (msg.wParam); <br> <br>} <br> <br>/*************************************************************************** <br> * Function: InitApplication <br> * <br> * Purpose: <br> * <br> * Register window class for the main window and the bar window. <br> */ <br>BOOL <br>InitApplication(HINSTANCE hInstance) <br>{ <br>        WNDCLASS    wc; <br>        BOOL resp; <br> <br> <br>        /* register the bar window class */ <br>        InitBarClass(hInstance); <br> <br>        wc.style = 0; <br>        wc.lpfnWndProc = MainWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = hInstance; <br>        wc.hIcon = LoadIcon(hInstance, "WinDiff"); <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = NULL; <br>        wc.lpszClassName =  "WinDiffViewerClass"; <br>        wc.lpszMenuName = NULL; <br> <br>        resp = RegisterClass(&amp;wc); <br> <br>        return(resp); <br>} <br> <br>/*************************************************************************** <br> * Function: InitInstance <br> * <br> * Purpose: <br> * <br> * Create and show the windows <br> */ <br>BOOL <br>InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>        RECT rect; <br>        HANDLE hstatus; <br>        int bar_width; <br>        RECT childrc; <br> <br>        hInst = hInstance; <br> <br>        /* initialise a heap. we use this one heap throughout <br>         * the app. for all memory requirements <br>         */ <br>        hHeap = gmem_init(); <br>        /* initialise the list package */ <br>        List_Init(); <br> <br> <br>        hMenu = LoadMenu(hInstance, "WinDiffMenu"); <br>        haccel = LoadAccelerators(hInstance, "WinDiffAccel"); <br> <br>        /* create the main window */ <br>        hwndClient = CreateWindow("WinDiffViewerClass", <br>                            "WinDiff", <br>                            WS_OVERLAPPEDWINDOW, <br>                            CW_USEDEFAULT, <br>                            CW_USEDEFAULT, <br>                            CW_USEDEFAULT, <br>                            CW_USEDEFAULT, <br>                            NULL, <br>                            hMenu, <br>                            hInstance, <br>                            NULL <br>                ); <br> <br> <br> <br>        if (!hwndClient) { <br>            return(FALSE); <br>        } <br> <br>        /* create 3 child windows, one status, one table and one bar <br>         * Initially, the bar window is hidden and covered by the table. <br>         */ <br> <br>        /* create a status bar window as <br>         * a child of the main window. <br>         */ <br> <br>        /* build a status struct for two labels and an abort button */ <br>        hstatus = StatusAlloc(3); <br>        StatusAddItem(hstatus, 0, SF_STATIC, SF_LEFT|SF_VAR|SF_SZMIN, IDL_STATLAB, 14, NULL); <br>        StatusAddItem(hstatus, 1, SF_BUTTON, SF_RIGHT|SF_RAISE, IDM_ABORT, 8, <br>                LoadRcString(IDS_EXIT)); <br>        StatusAddItem(hstatus, 2, SF_STATIC, SF_LOWER|SF_LEFT|SF_VAR, <br>                        IDL_NAMES, 60, NULL); <br> <br>        /* ask the status bar how high it should be for the controls <br>         * we have chosen, and save this value for re-sizing. <br>         */ <br>        status_height = StatusHeight(hstatus); <br> <br>        /* create a window of this height */ <br>        GetClientRect(hwndClient, &amp;rect); <br>        childrc = rect; <br>        childrc.bottom = status_height; <br>        hwndStatus = StatusCreate(hInst, hwndClient, IDC_STATUS, &amp;childrc, <br>                        hstatus); <br> <br>        /* layout constants are stated as percentages of the window width */ <br>        bar_width = (rect.right - rect.left) * BAR_WIN_WIDTH / 100; <br> <br>        /* create the table class covering all the remaining part of <br>         * the main window <br>         */ <br>        hwndRCD = CreateWindow(TableClassName, <br>                        NULL, <br>                        WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL, <br>                        0, <br>                        status_height, <br>                        (int)(rect.right - rect.left), <br>                        (int)(rect.bottom - status_height), <br>                        hwndClient, <br>                        (HANDLE) IDC_RCDISP1, <br>                        hInst, <br>                        NULL); <br> <br>        /* create a bar window as a child of the main window. <br>         * this window remains hidden until we switch into MODE_EXPAND <br>         */ <br>        hwndBar = CreateWindow("BarClass", <br>                        NULL, <br>                        WS_CHILD | WS_VISIBLE, <br>                        0, <br>                        status_height, <br>                        bar_width, <br>                        (int)(rect.bottom - status_height), <br>                        hwndClient, <br>                        (HANDLE) IDC_BAR, <br>                        hInst, <br>                        NULL); <br> <br>        /* nMinMax indicates whether we are to be minimised on startup, <br>         * on command line parameters <br>         */ <br>        ShowWindow(hwndBar, SW_HIDE); <br> <br>        if (GetProfileInt(APPNAME, "OutlineSaved", 0)) <br>        { <br>                WINDOWPLACEMENT wp; <br> <br>                /* restore the previous expanded size and position */ <br>                wp.length                  = sizeof( WINDOWPLACEMENT ); <br>                wp.flags                   = 0; <br>                wp.showCmd                 = GetProfileInt( APPNAME, "OutlineShowCmd", <br>                                                            SW_SHOWNORMAL); <br>                wp.ptMaxPosition.x         = GetProfileInt( APPNAME, "OutlineMaxX",       0); <br>                wp.ptMaxPosition.y         = GetProfileInt( APPNAME, "OutlineMaxY",       0); <br>                wp.rcNormalPosition.left   = (int)GetProfileInt( APPNAME, "OutlineNormLeft",  (UINT)(-1)); <br>                wp.rcNormalPosition.top    = (int)GetProfileInt( APPNAME, "OutlineNormTop",   (UINT)(-1)); <br>                wp.rcNormalPosition.right  = (int)GetProfileInt( APPNAME, "OutlineNormRight", (UINT)(-1)); <br>                wp.rcNormalPosition.bottom = (int)GetProfileInt( APPNAME, "OutlineNormBottom",(UINT)(-1)); <br>                SetWindowPlacement(hwndClient,&amp;wp); <br>        } <br>        else ShowWindow(hwndClient, nMinMax); <br> <br>        UpdateWindow(hwndClient); <br> <br> <br>        /* initialise busy flag and status line to show we are idle <br>         * (ie not comparing or scanning) <br>         */ <br>        SetNotBusy(); <br> <br>        return(TRUE); <br> <br>} /* InitInstance */ <br> <br>/*************************************************************************** <br> * Function: windiff_usage <br> * <br> * Purpose: <br> * <br> * Complain to command line users about poor syntax, <br> * will be replaced by proper help file. <br> */ <br>void <br>windiff_usage(LPSTR msg) <br>{ <br>        int retval; <br>        TCHAR szBuf[MAX_PATH]; <br> <br>        if (msg==NULL) <br>                msg = LoadRcString(IDS_USAGE_STR); <br> <br>        LoadString(hInst, IDS_WINDIFF_USAGE, szBuf, sizeof(szBuf)); <br>        retval = MessageBox(hwndClient, <br>                msg, <br>                szBuf, MB_ICONINFORMATION|MB_OKCANCEL); <br>        if (retval == IDCANCEL) { <br>                exit(1); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: ParseArgs <br> * <br> * Purpose: <br> * <br> * Parse command line arguments <br> * <br> * The user can give one or two paths. If only one, we assume the second <br> * is '.' for the current directory. If one of the two paths is a directory <br> * and the other a file, we compare a file of the same name in the two dirs. <br> * <br> * The command -s filename causes the outline list to be written to a file <br> * and then the program exits. -s{slrd} filename allows selection of which <br> * files are written out; by default, we assume -sld for files left and different. <br> * <br> * -T means tree.  Go deep. <br> * <br> * The default is Deep, -L overrides and implies shallow, -T overrides -L <br> */ <br>void <br>ParseArgs(int argc, char ** argv) <br>{ <br>        int i; <br>        LPSTR chp; <br>        PTHREADARGS ta; <br>        DWORD threadid; <br> <br>        /* thread args can't be on the stack since the stack will change <br>         * before the thread completes execution <br>         */ <br>        ta = (PTHREADARGS) gmem_get(hHeap, sizeof(THREADARGS)); <br>        ta-&gt;first = NULL; <br>        ta-&gt;second = NULL; <br>        ta-&gt;savelist = NULL; <br>        ta-&gt;saveopts = 0; <br>        ta-&gt;fDeep = FALSE;  /* No -T option seen yet */ <br> <br>        for (i = 1; i &lt; argc; i++) { <br> <br>                /* is this an option ? */ <br>                if ((argv[i][0] == '-') || (argv[i][0] == '/')) { <br>                        switch(argv[i][1]) { <br> <br>                        case 's': <br>                        case 'S': <br>                                /* read letters for the save option: s,l,r,d */ <br>                                for(chp = &amp;argv[i][2]; *chp != '\0'; chp++) { <br>                                        switch(*chp) { <br>                                        case 's': <br>                                        case 'S': <br>                                                ta-&gt;saveopts |= INCLUDE_SAME; <br>                                                break; <br>                                        case 'l': <br>                                        case 'L': <br>                                                ta-&gt;saveopts |= INCLUDE_LEFTONLY; <br>                                                break; <br>                                        case 'r': <br>                                        case 'R': <br>                                                ta-&gt;saveopts |= INCLUDE_RIGHTONLY; <br>                                                break; <br>                                        case 'd': <br>                                        case 'D': <br>                                                ta-&gt;saveopts |= INCLUDE_DIFFER; <br>                                                break; <br>                                        default: <br>                                                windiff_usage(NULL); <br>                                                return; <br>                                        } <br>                                } <br> <br>                                if (ta-&gt;saveopts == 0) { <br>                                        /* default to left and differ */ <br>                                        ta-&gt;saveopts = (INCLUDE_LEFTONLY) | (INCLUDE_DIFFER); <br>                                } <br>                                ta-&gt;savelist = argv[++i]; <br>                                break; <br>                        case 't': <br>                        case 'T': <br>                                ta-&gt;fDeep = TRUE; <br>                                break; <br>                        default: <br>                                windiff_usage(NULL); <br>                                return; <br>                        } <br>                } else { <br>                        if (ta-&gt;first == NULL) { <br>                                ta-&gt;first = argv[i]; <br>                        } else { <br>                                ta-&gt;second = argv[i]; <br>                        } <br>                } <br>        } <br> <br>        /* set the correct depth */ <br>        if (ta-&gt;fDeep) <br>                ;                       /* explicitly set -- leave it alone */ <br>        else ta-&gt;fDeep = TRUE;          /* global default */ <br> <br>        /* any paths to scan ? */ <br>        if (ta-&gt;first == NULL) { <br>                return; <br>        } <br> <br>        if (ta-&gt;second == NULL) { <br>                ta-&gt;second = "."; <br>        } <br> <br>        SetBusy(); <br> <br>        /* minimise the window if -s flag given */ <br>        if (ta-&gt;savelist != NULL) { <br>                ShowWindow(hwndClient, SW_MINIMIZE); <br>        } <br> <br>        /* make an empty view */ <br>        current_view = view_new(hwndRCD); <br>        DisplayMode = MODE_OUTLINE; <br> <br>        ta-&gt;view = current_view; <br> <br>        /* attempt to create a worker thread */ <br> <br>        ghThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)wd_initial, (LPVOID) ta, <br>                        0, &amp;threadid); <br>        if (ghThread == NULL) <br>        { <br>                wd_initial( (LPVOID) ta); <br>        } <br>} /* ParseArgs */ <br> <br> <br>/*************************************************************************** <br> * Function: CreateTools <br> * <br> * Purpose: <br> * <br> * Create any pens/brushes, and read defaults <br> * from the profile file for menu settings etc. <br> */ <br>void <br>CreateTools(void) <br>{ <br> <br>        /* standard message that table class sends us for <br>         * notifications and queries. <br>         */ <br>        table_msgcode = RegisterWindowMessage(TableMessage); <br> <br>        line_numbers = GetProfileInt(APPNAME, "LineNumbers", line_numbers); <br>        outline_include = GetProfileInt(APPNAME, "FileInclude", outline_include); <br>        ignore_blanks = GetProfileInt(APPNAME, "Blanks", ignore_blanks); <br>        picture_mode = GetProfileInt(APPNAME, "Picture", picture_mode); <br> <br>        GetProfileString(APPNAME, "Editor", editor_cmdline, (LPTSTR)editor_cmdline, <br>                        sizeof(editor_cmdline)); <br>        InitializeCriticalSection(&amp;CSWindiff); <br> <br>} <br> <br>/*************************************************************************** <br> * Function: DeleteTools <br> * <br> * Purpose: <br> * <br> * Delete any pens or brushes that were created in CreateTools  <br> */ <br>void <br>DeleteTools(void) <br>{ <br> <br>        DeleteCriticalSection(&amp;CSWindiff); <br> <br>} <br> <br> <br>/*************************************************************************** <br> * Function: <br> * <br> * Purpose: <br> * <br> * Check whether we have had an abort request (IDM_ABORT), and <br> * return TRUE if abort requested, otherwise FALSE <br> */ <br>BOOL <br>Poll(void) <br>{ <br>    return(bAbort); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: DoResize <br> * <br> * Purpose: <br> * <br> * Position child windows on a resize of the main window <br> */ <br>void <br>DoResize(HWND hWnd) <br>{ <br>        RECT rc; <br>        int bar_width; <br> <br>        GetClientRect(hWnd, &amp;rc); <br>        MoveWindow(hwndStatus, 0, 0, rc.right - rc.left, status_height, TRUE); <br> <br>        bar_width = (rc.right - rc.left) * BAR_WIN_WIDTH / 100; <br> <br>        /* bar window is hidden unless in expand mode */ <br>        if ((DisplayMode == MODE_EXPAND) &amp;&amp; (picture_mode)) { <br>                ShowWindow(hwndBar, SW_SHOW); <br>                MoveWindow(hwndBar, 0, status_height, <br>                        bar_width, rc.bottom - status_height, TRUE); <br>                MoveWindow(hwndRCD, bar_width, status_height, <br>                        (rc.right - rc.left) - bar_width, <br>                        rc.bottom - status_height, TRUE); <br>        } else { <br>                MoveWindow(hwndRCD, 0, status_height, (rc.right - rc.left), <br>                        rc.bottom - status_height, TRUE); <br>                ShowWindow(hwndBar, SW_HIDE); <br>        } <br> <br>} <br>/*************************************************************************** <br> * Function: AboutBox <br> * <br> * Purpose: <br> * <br> * Standard processing for About box. <br> */ <br>int APIENTRY <br>AboutBox(HWND hDlg, unsigned message, UINT wParam, LONG lParam) <br>{ <br>        char ch[256]; <br> <br>        switch (message) { <br> <br>        case WM_INITDIALOG: <br>                wsprintf((LPTSTR)ch, "%d.%02d", Version, SubVersion); <br>                SetDlgItemText(hDlg, IDD_VERSION, ch); </code></pre>
<p>
</p>
<pre><code>return(TRUE); <br> <br>        case WM_COMMAND: <br>                switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK: <br>                        EndDialog(hDlg, 0); <br>                        return(TRUE); <br>                } <br>                break; <br>        } <br>        return(FALSE); <br>} <br> <br> <br>/* -- menu commands ---------------------------------------------------*/ <br> <br>/*************************************************************************** <br> * Function: DoPrint <br> * <br> * Purpose: <br> * <br> * Print the current view  <br> */ <br>void <br>DoPrint(void) <br>{ <br>        Title head, foot; <br>        PrintContext context; <br>        TCHAR szPage[50]; <br> <br>        /* print context contains the header and footer. Use the <br>         * default margins and printer selection <br>         */ <br> <br>        /* we set the table id to be TABID_PRINTER. When the table calls <br>         * back to get text and properties, we use this to indicate <br>         * that the table refered to is the 'current_view', but in print <br>         * mode, and thus we will use different colours/fonts. <br>         */ <br>        context.head = &amp;head; <br>        context.foot = &amp;foot; <br>        context.margin = NULL; <br>        context.pd = NULL; <br>        context.id = TABID_PRINTER; <br> <br>        /* header is filenames or just WinDiff if no names known*/ <br>        if (strlen(AppTitle) &gt; 0) { <br>                head.ptext = AppTitle; <br>        } else { <br>                head.ptext = "WinDiff"; <br>        } <br> <br>        /* header is centred, footer is right-aligned and <br>         * consists of the page number <br>         */ <br>        head.props.valid = P_ALIGN; <br>        head.props.alignment = P_CENTRE; <br>        lstrcpy(szPage,LoadRcString(IDS_PAGE)); <br>        foot.ptext = (LPSTR)szPage; <br>        foot.props.valid = P_ALIGN; <br>        foot.props.alignment = P_RIGHT; <br> <br>        SendMessage(hwndRCD, TM_PRINT, 0, (DWORD) (LPSTR) &amp;context); <br>} <br> <br>/*************************************************************************** <br> * Function: FindNextChange <br> * <br> * Purpose: <br> * <br> * Find the next line in the current view that is <br> * not STATE_SAME. Start from the current selection, if valid, or <br> * from the top of the window if no selection. <br> * <br> */ <br>BOOL <br>FindNextChange(void) <br>{ <br>        long row; <br> <br>        /* start from the selection or top of the window if no selection */ <br>        if (selection &gt;= 0) { <br>                row = selection; <br>        } else { <br>                row = (int) SendMessage(hwndRCD, TM_TOPROW, FALSE, 0); <br>        } <br> <br> <br>        /* find the next 'interesting' line */ <br>        row = view_findchange(current_view, row, TRUE); <br>        if (row &gt;= 0) { <br>                SetSelection(row); <br>                return(TRUE); <br>        } else { <br>                windiff_UI(TRUE); <br>                MessageBox(hwndClient, LoadRcString(IDS_NO_MORE_CHANGES), "Windiff", <br>                        MB_ICONINFORMATION|MB_OK); <br>                windiff_UI(FALSE); <br> <br>                return(FALSE); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: FindPrevChange <br> * <br> * Purpose: <br> * <br> * Find the previous line in the current view that is not STATE_SAME <br> */ <br>BOOL <br>FindPrevChange(void) <br>{ <br>        long row; <br> <br>        /* start from the selection or top of window if no selection */ <br>        if (selection &gt;= 0) { <br>                row = selection; <br>        } else { <br>                row = (int) SendMessage(hwndRCD, TM_TOPROW, FALSE, 0); <br>        } <br> <br>        /* find the previous 'interesting' line */ <br>        row = view_findchange(current_view, row, FALSE); <br>        if (row &gt;= 0) { <br>                SetSelection(row); <br>                return(TRUE); <br>        } else { <br>                windiff_UI(TRUE); <br>                MessageBox(hwndClient, LoadRcString(IDS_NO_PREV_CHANGES), "Windiff", <br>                        MB_ICONINFORMATION|MB_OK); <br>                windiff_UI(FALSE); <br> <br>                return(FALSE); <br>        } <br> <br>} <br>/*************************************************************************** <br> * Function: WriteProfileInt <br> * <br> */ <br>  <br>BOOL WriteProfileInt(LPSTR AppName, LPSTR Key, int Int) <br>{       char Str[40]; <br> <br>        wsprintf((LPTSTR)Str, "%d", Int); <br>        return WriteProfileString(AppName, Key, Str); <br> <br>} /* WriteProfileInt */ <br> <br> <br>/*************************************************************************** <br> * Function: ToExpand <br> * <br> * Purpose: <br> * <br> * Switch to expand view of the selected line  <br> */ <br>BOOL <br>ToExpand(HWND hwnd) <br>{ <br>        if (selection &lt; 0) { <br>                return(FALSE); <br>        } <br> <br>        if (!view_isexpanded(current_view)) { <br>                /* save the current outline size and position */ <br>                WINDOWPLACEMENT wp; <br>                if (GetWindowPlacement(hwndClient,&amp;wp)) { <br>                        WriteProfileInt(APPNAME, "OutlineShowCmd", wp.showCmd); <br>                        WriteProfileInt(APPNAME, "OutlineMaxX", wp.ptMaxPosition.x); <br>                        WriteProfileInt(APPNAME, "OutlineMaxY", wp.ptMaxPosition.y); <br>                        WriteProfileInt(APPNAME, "OutlineNormLeft", wp.rcNormalPosition.left); <br>                        WriteProfileInt(APPNAME, "OutlineNormTop", wp.rcNormalPosition.top); <br>                        WriteProfileInt(APPNAME, "OutlineNormRight", wp.rcNormalPosition.right); <br>                        WriteProfileInt(APPNAME, "OutlineNormBottom", wp.rcNormalPosition.bottom); <br>                        WriteProfileInt(APPNAME, "OutlineSaved", 1); <br>                } <br> <br>                /* restore the previous expanded size and position, if any */ <br>                if (GetProfileInt(APPNAME, "ExpandedSaved", 0)) { <br>                        wp.flags                   = 0; <br>                        wp.showCmd <br>                                = GetProfileInt( APPNAME, "ExpandShowCmd" <br>                                               , SW_SHOWMAXIMIZED); <br>                        wp.ptMaxPosition.x <br>                                = GetProfileInt( APPNAME, "ExpandMaxX", 0); <br>                        wp.ptMaxPosition.y <br>                                = GetProfileInt( APPNAME, "ExpandMaxY", 0); <br>                        wp.rcNormalPosition.left <br>                                = GetProfileInt( APPNAME, "ExpandNormLeft" <br>                                               , wp.rcNormalPosition.left); <br>                        wp.rcNormalPosition.top <br>                                = GetProfileInt( APPNAME, "ExpandNormTop" <br>                                               , wp.rcNormalPosition.top); <br>                        wp.rcNormalPosition.right <br>                                = GetProfileInt( APPNAME, "ExpandNormRight" <br>                                               , wp.rcNormalPosition.right); <br>                        wp.rcNormalPosition.bottom <br>                                = GetProfileInt( APPNAME, "ExpandNormBottom" <br>                                               , wp.rcNormalPosition.bottom); <br>                        SetWindowPlacement(hwndClient,&amp;wp); <br>                } <br>                else ShowWindow(hwndClient, SW_SHOWMAXIMIZED); <br>        } <br> <br>        /*change the view mapping to expand mode */ <br>        if (view_expand(current_view, selection)) { <br> <br>                /* ok - we now have an expanded view - change status <br>                 * to show this <br>                 */ <br> <br>                DisplayMode = MODE_EXPAND; <br> <br>                /* resize to show the graphic bar picture */ <br>                DoResize(hwndClient); <br> <br> <br>                /* change button,status text-if we are not still busy*/ <br>                if (!fBusy) { <br>                        TCHAR szBuf[10]; <br>                        lstrcpy(szBuf,LoadRcString(IDS_OUTLINE)); <br>                        /* the status field when we are expanded shows the <br>                         * tag field (normally the file name) for the <br>                         * item we are expanding <br>                         */ <br>                        SetStatus(view_getcurrenttag(current_view) ); <br>                        SetButtonText(szBuf); <br>                } <br> <br>                return(TRUE); <br>        } <br>        return(FALSE); <br>} /* ToExpand */ <br> <br>/*************************************************************************** <br> * Function: ToOutline <br> * <br> * Purpose: <br> * <br> * Switch back to outline view - showing just the list of file names. <br> */ <br>void <br>ToOutline(HWND hwnd) <br>{ <br>        if (view_isexpanded(current_view)) { <br>                /* save the current expanded size and position */ <br>                WINDOWPLACEMENT wp; <br>                if (GetWindowPlacement(hwndClient,&amp;wp)) { <br>                        WriteProfileInt(APPNAME, "ExpandShowCmd", wp.showCmd); <br>                        WriteProfileInt(APPNAME, "ExpandMaxX", wp.ptMaxPosition.x); <br>                        WriteProfileInt(APPNAME, "ExpandMaxY", wp.ptMaxPosition.y); <br>                        WriteProfileInt(APPNAME, "ExpandNormLeft", wp.rcNormalPosition.left); <br>                        WriteProfileInt(APPNAME, "ExpandNormTop", wp.rcNormalPosition.top); <br>                        WriteProfileInt(APPNAME, "ExpandNormRight", wp.rcNormalPosition.right); <br>                        WriteProfileInt(APPNAME, "ExpandNormBottom", wp.rcNormalPosition.bottom); <br>                        WriteProfileInt(APPNAME, "ExpandedSaved", 1); <br>                } <br> <br>                /* restore the previous expanded size and position, if any */ <br>                if (GetProfileInt(APPNAME, "OutlineSaved", 0))  { <br>                        wp.flags = 0; <br>                        wp.showCmd <br>                                = GetProfileInt( APPNAME, "OutlineShowCmd" <br>                                               , SW_SHOWNORMAL); <br>                        wp.ptMaxPosition.x <br>                                = GetProfileInt( APPNAME, "OutlineMaxX", 0); <br>                        wp.ptMaxPosition.y <br>                                = GetProfileInt( APPNAME, "OutlineMaxY", 0); <br>                        wp.rcNormalPosition.left <br>                                = GetProfileInt( APPNAME, "OutlineNormLeft" <br>                                               , wp.rcNormalPosition.left); <br>                        wp.rcNormalPosition.top <br>                                = GetProfileInt( APPNAME, "OutlineNormTop" <br>                                               , wp.rcNormalPosition.top); <br>                        wp.rcNormalPosition.right <br>                                = GetProfileInt( APPNAME, "OutlineNormRight" <br>                                               , wp.rcNormalPosition.right); <br>                        wp.rcNormalPosition.bottom <br>                                = GetProfileInt( APPNAME, "OutlineNormBottom" <br>                                               , wp.rcNormalPosition.bottom); <br>                        SetWindowPlacement(hwndClient,&amp;wp); <br>                } <br>                ShowWindow(hwndClient, SW_SHOWNORMAL); <br>        } <br> <br>        DisplayMode = MODE_OUTLINE; <br> <br>        /* switch mapping back to outline view */ <br>        view_outline(current_view); <br> <br>        /* hide bar window and resize to cover */ <br>        DoResize(hwndClient); <br> <br> <br>        /* change label on button */ <br>        if (!fBusy) { <br>                TCHAR szBuf[8]; <br>                lstrcpy(szBuf,LoadRcString(IDS_EXPAND)); <br>                SetButtonText(szBuf); <br>                SetStatus(NULL); <br>        } <br>} /* ToOutline */ <br> <br>/*************************************************************************** <br> * Function: ToMoved <br> * <br> * Purpose: <br> * <br> * If the user clicks on a MOVED line in expand mode, we jump to the <br> * other line. We return TRUE if this was possible,  or FALSE otherwise. <br> */ <br>BOOL <br>ToMoved(HWND hwnd) <br>{ <br>        BOOL bIsLeft; <br>        int linenr, state; <br>        long i, total; <br> <br>        if (DisplayMode != MODE_EXPAND) { <br>                return(FALSE); <br>        } <br>        if (selection &lt; 0) { <br>                return(FALSE); <br>        } <br> <br>        state = view_getstate(current_view, selection); <br>        if (state == STATE_MOVEDLEFT) { <br>                bIsLeft = TRUE; <br>                /* get the linenr of the other copy */ <br>                linenr = abs(view_getlinenr_right(current_view, selection)); <br>        } else if (state == STATE_MOVEDRIGHT) { <br>                bIsLeft = FALSE; <br>                /* get the linenr of the other copy */ <br>                linenr = abs(view_getlinenr_left(current_view, selection)); <br>        } else { <br>                /* not a moved line - so we can't find another copy */ <br>                return(FALSE); <br>        } <br> <br>        /* search the view for this line nr */ <br>        total = view_getrowcount(current_view); <br>        for (i = 0; i &lt; total; i++) { <br>                if (bIsLeft) { <br>                        if (linenr == view_getlinenr_right(current_view, i)) { <br>                                /* found it */ <br>                                SetSelection(i); <br>                                return(TRUE); <br>                        } <br>                } else { <br>                        if (linenr == view_getlinenr_left(current_view, i)) { <br>                                SetSelection(i); <br>                                return(TRUE); <br>                        } <br>                } <br>        } <br>        return(FALSE); <br>} <br> <br>/*************************************************************************** <br> * Function: do_editfile <br> * <br> * Purpose: <br> * <br> * Launch an editor on the current file (the file we are expanding, or <br> * in outline mode the selected row. Option allows selection of the <br> * left file, the right file or the composite view of this item. <br> * pe points to a packet of parameters that must be freed before returning. <br> * The return value is meaningless (just to conform to CreateThread). <br> */ <br>LONG <br>do_editfile(PEDITARGS pe) <br>{ <br>        VIEW view = pe-&gt;view; <br>        int option = pe-&gt;option; <br>        int selection = pe-&gt;selection; <br> <br>        COMPITEM item; <br>        LPSTR fname; <br>        char cmdline[256]; <br>        int currentline; <br>        char * pOut = cmdline; <br>        char * pIn = editor_cmdline; <br> <br>        STARTUPINFO si; <br>        PROCESS_INFORMATION pi; <br> <br>        item = view_getitem(view, selection); <br>        if (item == NULL) { <br>                return -1; <br>        } <br> <br>        fname = compitem_getfilename(item, option); <br> <br>        if ( 0 == fname ) <br>        { <br>            windiff_UI(TRUE); <br>            MessageBox(hwndClient, LoadRcString(IDS_FILE_DOESNT_EXIST), <br>                       "Windiff", MB_ICONSTOP|MB_OK); <br>            windiff_UI(FALSE); <br>            goto error; <br>        } <br> <br>       switch ( option ) <br>        { <br>        case CI_LEFT: <br>            currentline = view_getlinenr_left( view, <br>                                               selection &gt; 0 ? selection : 1); <br>            break; <br> <br>        case CI_RIGHT: <br>            currentline = view_getlinenr_right( view, <br>                                                selection &gt; 0 ? selection : 1); <br>            break; <br> <br>        default: <br>            currentline = 1; <br>            break; <br>        } <br> <br>        while( *pIn ) <br>        { <br>            switch( *pIn ) <br>            { <br>            case '%': <br>                pIn++; <br>                switch ( *pIn ) <br>                { <br>                case 'p': <br>                    lstrcpy( (LPTSTR)pOut, fname ); <br>                    while ( *pOut ) <br>                        pOut++; <br>                    break; <br> <br>                case 'l': <br>                    _ltoa( currentline, pOut, 10 ); <br>                    while ( *pOut ) <br>                        pOut++; <br>                    break; <br> <br>                default: <br>                    if (IsDBCSLeadByte(*pIn) &amp;&amp; *(pIn+1)) { <br>                        *pOut++ = *pIn++; <br>                    } <br>                    *pOut++ = *pIn; <br>                    break; <br>                } <br>                pIn++; <br>                break; <br> <br>            default: <br>                if (IsDBCSLeadByte(*pIn) &amp;&amp; *(pIn+1)) { <br>                    *pOut++ = *pIn++; <br>                } <br>                *pOut++ = *pIn++; <br>                break; <br>            } <br>        } <br> <br> <br>        /* Launch the process and waits for it to complete */ <br> <br>        si.cb = sizeof(STARTUPINFO); <br>        si.lpReserved = NULL; <br>        si.lpReserved2 = NULL; <br>        si.cbReserved2 = 0; <br>        si.lpTitle = (LPSTR)cmdline;  <br>        si.lpDesktop = (LPTSTR)NULL; <br>        si.dwFlags = STARTF_FORCEONFEEDBACK; <br> <br> <br>        if (!CreateProcess(NULL, <br>                        cmdline, <br>                        NULL, <br>                        NULL, <br>                        FALSE, <br>                        NORMAL_PRIORITY_CLASS, <br>                        NULL, <br>                        (LPTSTR)NULL, <br>                        &amp;si, <br>                        &amp;pi)) { <br>                windiff_UI(TRUE); <br>                MessageBox(hwndClient, LoadRcString(IDS_FAILED_TO_LAUNCH_EDT), <br>                        "Windiff", MB_ICONSTOP|MB_OK); <br>                windiff_UI(FALSE); <br>                goto error; <br>        } <br> <br>        /* wait for completion. */ <br>        WaitForSingleObject(pi.hProcess, INFINITE); <br> <br>        /* close process and thread handles */ <br>        CloseHandle(pi.hThread); <br>        CloseHandle(pi.hProcess); <br> <br>        /* finished with the filename. deletes it if it was a temp. */ <br>        compitem_freefilename(item, option, fname); <br> <br>        /* <br>         * refresh cached view always .  A common trick is to edit the <br>         * composite file and then save it as a new left or right file. <br>         * Equally the user can edit the left and save as a new right. <br>         */ <br> <br>        /* We want to force both files to be re-read, but it's not a terribly <br>         * good idea to throw the lines away on this thread.  Someone might <br>         * be reading them on another thread! <br>         */ <br>        /* file_discardlines(compitem_getleftfile(item)) */ <br>        /* file_discardlines(compitem_getrightfile(item)) */ <br> <br>        /* force the compare to be re-done */ <br>        PostMessage(hwndClient, WM_COMMAND, IDM_UPDATE, (LONG)item); <br>error: <br>        gmem_free(hHeap, (LPSTR) pe, sizeof(EDITARGS)); <br> <br>        return 0; <br> <br>} /* do_editfile */ <br> <br> <br>/*************************************************************************** <br> * Function: do_editthread <br> * <br> * Purpose: <br> * <br> * Launch an editor on a separate thread.  It will actually get a separate <br> * process, but we want our own thread in this process.  This thread will <br> * wait until it's finished and then order up a refresh of the UI. <br> * Need to give it its parameters as a gmem allocated packet because <br> * it IS on a separate thread. <br> */ <br>void do_editthread(VIEW view, int option) <br>{ <br>        PEDITARGS pe; <br>        HANDLE thread; <br>        DWORD threadid; <br> <br>        pe = (PEDITARGS) gmem_get(hHeap, sizeof(EDITARGS)); <br>        pe-&gt;view = view; <br>        pe-&gt;option = option; <br>        pe-&gt;selection = selection; <br> <br>        thread = CreateThread( NULL <br>                             , 0 <br>                             , (LPTHREAD_START_ROUTINE)do_editfile <br>                             , (LPVOID) pe <br>                             , 0 <br>                             , &amp;threadid <br>                             ); <br>        if (thread == NULL) <br>        { <br>                /* The createthread failed, do without the extra thread - just <br>                 * call the function synchronously <br>                 */ <br>                 do_editfile(pe); <br>        } <br>        else CloseHandle(thread); <br>} /* do_editthread */ <br> <br> <br>/* status bar and busy flags --------------------------------------------*/ <br> <br> <br>/*************************************************************************** <br> * Function: SetButtonText <br> * <br> * Purpose: <br> * <br> * Set the Text on the statusbar button to reflect the current state  <br> */ <br>void <br>SetButtonText(LPSTR cmd) <br>{ <br>        SendMessage(hwndStatus, SM_SETTEXT, IDM_ABORT, (DWORD) cmd); <br>} <br> <br>/*************************************************************************** <br> * Function: SetStatus <br> * <br> * Purpose: <br> * <br> * Set the status field (left-hand part) of the status bar.  <br> */ <br>void <br>SetStatus(LPSTR cmd) <br>{ <br>        SendMessage(hwndStatus, SM_SETTEXT, IDL_STATLAB, (DWORD) cmd); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: SetNames <br> * <br> * Purpose: <br> * <br> * Set the names field - the central box in the status bar  <br> */ <br>void <br>SetNames(LPSTR names) <br>{ <br>        SendMessage(hwndStatus, SM_SETTEXT, IDL_NAMES, (DWORD) names); <br>        if (names == NULL) { <br>                AppTitle[0] = '\0'; <br>        } else { <br>                strncpy(AppTitle, names, sizeof(AppTitle)); <br>        } <br>} <br> <br>/*************************************************************************** <br> * Function: SetBusy <br> * <br> * Purpose: <br> * <br> * If we are not already busy, set the busy flag. <br> * <br> * Enter critical section first. <br> */ <br>BOOL <br>SetBusy(void) <br>{ <br>        HMENU hmenu; <br> <br> <br>        WDEnter(); <br> <br>        if (fBusy) { <br>                WDLeave(); <br>                return(FALSE); <br>        } <br> <br> <br>        fBusy = TRUE; <br> <br>        SetStatus(LoadRcString(IDS_COMPARING)); <br>        /* status also on window text, so that you can see even from <br>         * the icon when the scan has finished <br>         */ <br>        SetWindowText(hwndClient, LoadRcString(IDS_SCANNING)); <br> <br>        /* disable appropriate parts of menu */ <br>        hmenu = GetMenu(hwndClient); <br>        EnableMenuItem(hmenu, IDM_FILE,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND); <br>        EnableMenuItem(hmenu, IDM_DIR,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND); <br>        EnableMenuItem(hmenu, IDM_PRINT,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND); <br> <br>        /* enable abort only when busy */ <br>        EnableMenuItem(hmenu, IDM_ABORT,MF_ENABLED|MF_BYCOMMAND); <br>        SetButtonText(LoadRcString(IDS_ABORT));  /* leave DisplayMode unchanged */ <br> <br>        WDLeave(); <br>        return(TRUE); <br>} /* SetBusy */ <br>/*************************************************************************** <br> * Function: SetNotBusy <br> * <br> * Purpose: <br> * <br> * This function can be called from the worker thread. <br> * Thus we must not cause any SendMessage calls to windows <br> * owned by the main thread while holding the CritSec or we <br> * could cause deadlock. <br> * <br> * The critsec is only needed to protect the fBusy flag - so <br> * clear the busy flag last, and only get the crit sec as needed. <br> */ <br>void <br>SetNotBusy(void) <br>{ <br>        HMENU hmenu; <br> <br>        /* reset button and status bar (clearing out busy flags) */ <br>        if (current_view == NULL) { <br>                SetButtonText(LoadRcString(IDS_EXIT)); <br>                SetStatus(NULL); <br>                DisplayMode = MODE_NULL; <br>        } else if (view_isexpanded(current_view)) { <br>                TCHAR szBuf[10]; <br>                lstrcpy(szBuf,LoadRcString(IDS_OUTLINE)); <br>                SetButtonText(szBuf); <br>                SetStatus(view_getcurrenttag(current_view) ); <br>                DisplayMode = MODE_EXPAND; <br>        } else { <br>                TCHAR szBuf[8]; <br>                lstrcpy(szBuf,LoadRcString(IDS_EXPAND)); <br>                SetButtonText(szBuf); <br>                SetStatus(NULL); <br>                DisplayMode = MODE_OUTLINE; <br>        } <br> <br>        SetWindowText(hwndClient, "WinDiff"); <br> <br>        /* re-enable appropriate parts of menu */ <br>        hmenu = GetMenu(hwndClient); <br>        EnableMenuItem(hmenu, IDM_FILE,MF_ENABLED|MF_BYCOMMAND); <br>        EnableMenuItem(hmenu, IDM_DIR,MF_ENABLED|MF_BYCOMMAND); <br>        EnableMenuItem(hmenu, IDM_PRINT,MF_ENABLED|MF_BYCOMMAND); <br> <br>        /* disable abort now no longer busy */ <br>        EnableMenuItem(hmenu, IDM_ABORT,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND); <br> <br> <br>        /* clear the busy flag, protected by critical section */ <br>        WDEnter(); <br> <br>        fBusy = FALSE; <br>        bAbort = FALSE; <br> <br>        if (ghThread!=NULL){ <br>            CloseHandle(ghThread); <br>            ghThread = NULL; <br>        } <br>        WDLeave(); <br>} /* SetNotBusy */ <br> <br>/*************************************************************************** <br> * Function: IsBusy <br> * <br> * Purpose: <br> * <br> * Checks whether or not crit sec is open <br> */ <br>BOOL <br>IsBusy() <br>{ <br>        BOOL bOK; <br> <br>        WDEnter(); <br>        bOK = fBusy; <br>        WDLeave(); <br>        return(bOK); <br>} /* IsBusy */ <br> <br>/*************************************************************************** <br> * Function: BusyError <br> * <br> * Purpose: <br> * <br> * Puts up message box that system is busy. <br> */ <br>void <br>BusyError(void) <br>{ <br>        windiff_UI(TRUE); <br>        MessageBox(hwndClient, <br>                LoadRcString(IDS_PLEASE_WAIT), <br>                "WinDiff", MB_OK|MB_ICONSTOP); <br>        windiff_UI(FALSE); <br>} /* BusyError */ <br> <br>/* --- colour scheme --------------------------------------------------- */ <br> <br>/*************************************************************************** <br> * Function: StateToColour <br> * <br> * Purpose: <br> * <br> * Map the state given into a foreground and a background colour <br> * for states that are highlighted. Return P_FCOLOUR if the foreground <br> * colour (put in *foreground) is to be used, return P_FCOLOUR|P_BCOLOUR if <br> * both *foreground and *background are to be used, or 0 if the default <br> * colours are to be used. <br> */ <br>UINT <br>StateToColour(int state, int col, DWORD FAR * foreground, DWORD FAR * background) <br>{ <br> <br> <br>        switch (state) { <br> <br>        case STATE_DIFFER: <br>                /* files that differ are picked out in a foreground highlight, <br>                 * with the default background <br>                 */ <br>                *foreground = rgb_outlinehi; <br>                return(P_FCOLOUR); <br> <br>        case STATE_LEFTONLY: <br>                /* lines only in the left file */ <br>                *foreground = rgb_leftfore; <br>                *background = rgb_leftback; <br>                return(P_FCOLOUR|P_BCOLOUR); <br> <br>        case STATE_RIGHTONLY: <br>                /* lines only in the right file */ <br>                *foreground = rgb_rightfore; <br>                *background = rgb_rightback; <br>                return(P_FCOLOUR|P_BCOLOUR); <br> <br>        case STATE_MOVEDLEFT: <br>                /* displaced lines in both files - left file version */ <br>                *foreground = rgb_mleftfore; <br>                *background = rgb_mleftback; <br>                return(P_FCOLOUR|P_BCOLOUR); <br> <br>        case STATE_MOVEDRIGHT: <br>                /* displaced lines in both files - right file version */ <br>                *foreground = rgb_mrightfore; <br>                *background = rgb_mrightback; <br>                return(P_FCOLOUR|P_BCOLOUR); <br> <br>        default: <br> <br>                /* no highlighting - default colours */ <br>                return(0); <br>        } <br> <br>} <br> <br>/* table window communication routines ---------------------------------*/ <br> <br>/*************************************************************************** <br> * Function: SetSelection <br> * <br> * Purpose: <br> * <br> * Set a given row as the selected row in the table window  <br> */ <br>void <br>SetSelection(long rownr) <br>{ <br>        TableSelection select; <br> <br>        select.startrow = rownr; <br>        select.startcell = 0; <br>        select.nrows = 1; <br>        select.ncells = 1; <br>        SendMessage(hwndRCD, TM_SELECT, 0, (long) (LPSTR)&amp;select); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: do_gethdr <br> * <br> * Purpose: <br> * <br> * Handle table class call back to get nr of rows and columns, <br> * and properties for the whole table. <br> * The 'table id' is either TABID_PRINTER - meaning we are <br> * printing the current_view, or it is the view to <br> * use for row/column nr information <br> */ <br>long <br>do_gethdr(HWND hwnd, lpTableHdr phdr) <br>{ <br>        VIEW view; <br>        BOOL bIsPrinter = FALSE; <br> <br>        if (phdr-&gt;id == TABID_PRINTER) { <br>                view = current_view; <br>                bIsPrinter = TRUE; <br>        } else { <br>                view = (VIEW) phdr-&gt;id; <br>        } <br>        if (view == NULL) { <br>                return(FALSE); <br>        } <br> <br>        phdr-&gt;nrows = view_getrowcount(view); <br> <br>        /*  three columns: line nr, tag and rest of line */ <br> <br>        /* <br>         * if IDM_NONRS (no line numbers) is selected, suppress the <br>         * line-nr column entirely to save screen space <br>         */ <br>        if (line_numbers == IDM_NONRS) { <br>                phdr-&gt;ncols = 2; <br>                phdr-&gt;fixedcols = 0; <br>        } else { <br>                phdr-&gt;ncols = 3; <br>                phdr-&gt;fixedcols = 1; <br>        } <br> <br>        phdr-&gt;fixedrows = 0; <br>        phdr-&gt;fixedselectable = FALSE; <br>        phdr-&gt;hseparator = TRUE; <br>        phdr-&gt;vseparator = TRUE; <br> <br>        phdr-&gt;selectmode = TM_ROW | TM_SINGLE; <br>        /* <br>         * find if we are in expand mode - ask for the item we are expanding. <br>         */ <br>        if (view_isexpanded(view) == TRUE) { <br> <br>                /* use focus rect as selection mode in expand mode <br>                 * so as not to interfere with background colours. <br>                 */ <br>                phdr-&gt;selectmode |= TM_FOCUS; <br>        } else { <br>                /* use default solid inversion when possible as it is clearer.*/ <br>                phdr-&gt;selectmode |= TM_SOLID; <br>        } <br> <br>        /* please send TQ_SCROLL notifications when the table is scrolled */ <br>        phdr-&gt;sendscroll = TRUE; <br>        phdr-&gt;props.valid = 0; <br> <br>        return TRUE; </code></pre>
<p>
</p>
<pre><code>} <br> <br>/*************************************************************************** <br> * Function: do_getprops <br> * <br> * Purpose: <br> * <br> * Respond to table callback asking for the size and properties <br> * of each column. Table id is either TABID_PRINTER (meaning the <br> * current_view, for printing) or it is the view to be used. <br> */ <br>long <br>do_getprops(HWND hwnd, lpColPropsList propslist) <br>{ <br>        int i, cell; <br>        BOOL bIsPrinter = FALSE; <br>        VIEW view; <br> <br>        if (propslist-&gt;id == TABID_PRINTER) { <br>                view = current_view; <br>                bIsPrinter = TRUE; <br>        } else { <br>                view = (VIEW) propslist-&gt;id; <br>        } <br>        if (view == NULL) { <br>                return(FALSE); <br>        } <br> <br>        /* The table inteface is slightly confused here. we are not <br>         * guaranteed which columns we are being asked about, so instead <br>         * of just setting each column cols[0], cols[1] etc, we need <br>         * to loop through, looking at each column in the table and <br>         * seeing which it is. <br>         */ <br>        for (i = 0; i &lt; propslist-&gt;ncols; i++) { <br>                cell = i + propslist-&gt;startcol; <br>                propslist-&gt;plist[i].props.valid = 0; <br> <br>                /* for all column widths, add on 1 for the NULL char. */ <br> <br>                /* <br>                 * skip the line nr column if IDM_NONRS <br>                 */ <br>                if (line_numbers == IDM_NONRS) { <br>                        cell++; <br>                } <br> <br>                if (cell == 0) { <br>                        /* properties for line nr column */ <br> <br>                        propslist-&gt;plist[i].nchars = view_getwidth(view, 0)+1; <br>                        propslist-&gt;plist[i].props.valid |= P_ALIGN; <br>                        propslist-&gt;plist[i].props.alignment = P_CENTRE; <br>                } else if (cell == 1) { <br> <br>                        /* properties for tag field */ <br>                        propslist-&gt;plist[i].nchars = view_getwidth(view, 1)+1; <br>                        propslist-&gt;plist[i].props.valid |= P_ALIGN; <br>                        propslist-&gt;plist[i].props.alignment = P_LEFT; <br>                } else { <br>                        /* properties for main text column - <br>                         * use a fixed font unless printing (if <br>                         * printing, best to use the default font, because <br>                         * of resolution differences. <br>                         * add on 8 chars to the width to ensure that <br>                         * the width of lines beginning with tabs <br>                         * works out ok <br>                         */ <br>                        propslist-&gt;plist[i].nchars = view_getwidth(view, 2)+1; <br>                        propslist-&gt;plist[i].props.valid |= P_ALIGN; <br>                        propslist-&gt;plist[i].props.alignment = P_LEFT; <br>                        if (!bIsPrinter) { <br>                                propslist-&gt;plist[i].props.valid |= P_FONT; <br>                                propslist-&gt;plist[i].props.hFont = <br>                                        GetStockObject(SYSTEM_FIXED_FONT); <br>                        } <br>                } <br>        } <br>        return (TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: do_getdata <br> * <br> * Purpose: <br> * <br> * Respond to a table callback asking for the contents of individual cells. <br> * table id is either TABID_PRINTER, or it is a pointer to the view <br> * to use for data. If going to the printer, don't set the <br> * colours (stick to black and white). <br> */ <br>long <br>do_getdata(HWND hwnd, lpCellDataList cdlist) <br>{ <br>        int start, endcell, col, i; <br>        lpCellData cd; <br>        VIEW view; <br>        LPSTR textp; <br>        BOOL bIsPrinter = FALSE; <br> <br>        if (cdlist-&gt;id == TABID_PRINTER) { <br>                view = current_view; <br>                bIsPrinter = TRUE; <br>        } else { <br>                view = (VIEW) cdlist-&gt;id; <br>        } <br> <br>        start = cdlist-&gt;startcell; <br>        endcell = cdlist-&gt;ncells + start; <br>        if (cdlist-&gt;row &gt;= view_getrowcount(view)) { <br>                return(FALSE); <br>        } <br>        for (i = start; i &lt; endcell; i++) { <br>                cd = &amp;cdlist-&gt;plist[i - start]; <br> <br> <br>                /* skip the line number column if IDM_NONRS */ <br>                if (line_numbers == IDM_NONRS) { <br>                        col = i+1; <br>                } else { <br>                        col = i; <br>                } <br> <br>                /* set colour of text to mark out <br>                 * lines that are changed, if not printer - for the <br>                 * printer everything should stay in the default colours <br>                 */ <br> <br>                if (!bIsPrinter) { <br> <br>                        /* convert the state of the requested row into a <br>                         * colour scheme. returns P_FCOLOUR and/or <br>                         * P_BCOLOUR if it sets either of the colours <br>                         */ <br>                        cd-&gt;props.valid |= <br>                            StateToColour(view_getstate(view, cdlist-&gt;row), col, <br>                                        &amp;cd-&gt;props.forecolour, <br>                                        &amp;cd-&gt;props.backcolour); <br>                } <br> <br>                textp = view_gettext(view, cdlist-&gt;row, col); <br>                if (cd-&gt;nchars != 0) { <br>                        if (textp == NULL) { <br>                                cd-&gt;ptext[0] = '\0'; <br>                        } else { <br>                                strncpy(cd-&gt;ptext, textp, cd-&gt;nchars -1); <br>                                cd-&gt;ptext[cd-&gt;nchars - 1] = '\0'; <br>                        } <br>                } <br> <br>        } <br>        return(TRUE); <br>} <br> <br>/*************************************************************************** <br> * Function: SvrClose <br> * <br> * Purpose: <br> * <br> * Table window has finished with this view. It can be deleted. <br> */ <br>void <br>SvrClose(void) <br>{ <br>        view_delete(current_view); <br>        current_view = NULL; <br> <br>        /* hide picture - only visible when we are in MODE_EXPAND */ <br>        DisplayMode = MODE_NULL; <br>        DoResize(hwndClient); <br> <br>        /* if we already busy when closing this view (ie <br>         * we are in the process of starting a new scan, <br>         * then leave the status bar alone, otherwise <br>         * we should clean up the state of the status bar <br>         */ <br>        if (!fBusy) { <br>                SetButtonText(LoadRcString(IDS_EXIT)); <br>                SetNames(NULL); <br>                SetStatus(NULL); <br> <br>        } <br> <br>} /* SvrClose */ <br> <br> <br>/*************************************************************************** <br> * Function: TableServer <br> * <br> * Purpose: <br> * <br> * Handle callbacks and notifications from the table class  <br> */ <br>long <br>TableServer(HWND hwnd, UINT cmd, long lParam) <br>{ <br>        lpTableHdr phdr; <br>        lpColPropsList proplist; <br>        lpCellDataList cdlist; <br>        lpTableSelection pselect; <br> <br>        switch(cmd) { <br>        case TQ_GETSIZE: <br>                /* get the nr of rows and cols in this table */ <br>                phdr = (lpTableHdr) lParam; <br>                return(do_gethdr(hwnd, phdr)); <br> <br>        case TQ_GETCOLPROPS: <br>                /* get the size and properties of each column */ <br>                proplist = (lpColPropsList) lParam; <br>                return (do_getprops(hwnd, proplist)); <br> <br>        case TQ_GETDATA: <br>                /* get the contents of individual cells */ <br>                cdlist = (lpCellDataList) lParam; <br>                return (do_getdata(hwnd, cdlist)); <br> <br> <br>        case TQ_SELECT: <br>                /* selection has changed */ <br>        case TQ_ENTER: <br>                /* user has double-clicked or pressed enter */ <br> <br>                pselect = (lpTableSelection) lParam; <br> <br>                /* store location for use in later search (IDM_FCHANGE) */ <br>                if (pselect-&gt;nrows &lt; 1) { <br>                        selection = -1; <br>                } else { <br>                        selection = (int) pselect-&gt;startrow; <br>                        if (cmd == TQ_ENTER) { <br>                                /* try to expand this row */ <br>                                if (!ToExpand(hwnd)) { <br>                                        /* expand failed - maybe this <br>                                         * is a moved line- show the other <br>                                         * copy <br>                                         */ <br>                                        ToMoved(hwnd); <br>                                } <br> <br>                        } <br>                } <br>                break; <br> <br>        case TQ_CLOSE: <br>                /* close this table - table class no longer needs data*/ <br>                SvrClose(); <br>                break; <br> <br>        case TQ_SCROLL: <br>                /* notification that the rows visible in the window <br>                 * have changed -change the current position lines in <br>                 * the graphic bar view (the sections picture) <br>                 */ <br>                if (picture_mode) { <br>                        BarDrawPosition(hwndBar, NULL, TRUE); <br>                } <br>                break; <br> <br>        default: <br>                return(FALSE); <br>        } <br>        return(TRUE); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: wd_initial <br> * <br> * Purpose: <br> * <br> * Called on worker thread (not UI thread) to handle the work <br> * requested on the command line.  <br> * arg is a pointer to a THREADARGS block allocated from gmem_get(hHeap). This <br> * needs to be freed before exiting. <br> */ <br>DWORD <br>wd_initial(LPVOID arg) <br>{ <br>        PTHREADARGS pta = (PTHREADARGS) arg; <br>        COMPLIST cl; <br> <br> <br>        /* build a complist from these args, <br>         * and register with the view we have made <br>         */ <br>        cl = complist_args(pta-&gt;first, pta-&gt;second, pta-&gt;view, pta-&gt;fDeep); <br> <br>        if (cl == NULL) { <br>                view_close(pta-&gt;view); <br>                gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS)); <br>                SetNotBusy(); <br>                return 0; <br>        } <br> <br> <br>        /* if savelist was selected, write out the list and exit */ <br>        if(pta-&gt;savelist != NULL) { <br>                complist_savelist(cl, pta-&gt;savelist, pta-&gt;saveopts); <br>                gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS)); <br>                SetNotBusy(); <br>                exit(0); <br>        } <br> <br>        /* if there was only one file, expand it */ <br>        if (view_getrowcount(pta-&gt;view) == 1) { <br>                SetSelection(0); <br>                ToExpand(hwndClient); <br>        } <br> <br> <br>        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS)); <br>        SetNotBusy(); <br>        return(0); <br>} /* wd_initial */ <br> <br> <br>/*************************************************************************** <br> * Function: wd_dirdialog <br> * <br> * Purpose: <br> * <br> * Called on worker thread (not UI thread) to handle a Dir request <br> */ <br>DWORD <br>wd_dirdialog(LPVOID arg) <br>{ <br> <br>        VIEW view = (VIEW) arg; <br> <br>        /* make a COMPLIST using the directory dialog, <br>         * and notify the view <br>         */ <br>        if (complist_dirdialog(view) == NULL) { <br>                view_close(view); <br>        } <br> <br>        /* all done! */ <br>        SetNotBusy(); <br>        return(0); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: wd_copy <br> * <br> * Purpose: <br> * <br> * Called on worker thread to do a copy-files operation <br> */ <br>DWORD <br>wd_copy(LPVOID arg) <br>{ <br> <br>        VIEW view = (VIEW) arg; <br> <br>        complist_copyfiles(view_getcomplist(view), NULL, 0); <br> <br>        SetNotBusy(); <br> <br>        return(0); <br>} <br> <br> <br>/*************************************************************************** <br> * Function: MainWndProc <br> * <br> * Purpose: <br> * <br> * Window processing for main window <br> */ <br>long APIENTRY <br>MainWndProc(HWND hWnd, UINT message, UINT wParam, LONG lParam) <br>{ <br>        char str[32]; <br>        long ret; <br>        DWORD threadid; <br> <br>        switch(message) { <br> <br> <br>        case WM_CREATE: <br> <br>                /* initialise menu options to default/saved <br>                 * option settings <br>                 */ <br> <br>                CheckMenuItem(hMenu, IDM_INCSAME, <br>                      (outline_include &amp; INCLUDE_SAME) ? <br>                                MF_CHECKED:MF_UNCHECKED); <br> <br>                CheckMenuItem(hMenu, IDM_INCLEFT, <br>                      (outline_include &amp; INCLUDE_LEFTONLY) ? <br>                                MF_CHECKED:MF_UNCHECKED); <br> <br>                CheckMenuItem(hMenu, IDM_INCRIGHT, <br>                      (outline_include &amp; INCLUDE_RIGHTONLY) ? <br>                                MF_CHECKED:MF_UNCHECKED); <br>                CheckMenuItem(hMenu, IDM_INCDIFFER, <br>                      (outline_include &amp; INCLUDE_DIFFER) ? <br>                                MF_CHECKED:MF_UNCHECKED); <br> <br>                CheckMenuItem(hMenu, line_numbers, MF_CHECKED); <br>                CheckMenuItem(hMenu, expand_mode, MF_CHECKED); <br> <br>                CheckMenuItem(hMenu, IDM_IGNBLANKS, <br>                        ignore_blanks ? MF_CHECKED : MF_UNCHECKED); <br>                CheckMenuItem(hMenu, IDM_PICTURE, <br>                        picture_mode ? MF_CHECKED : MF_UNCHECKED); <br> <br>                /* nothing currently displayed */ <br>                DisplayMode = MODE_NULL; <br> <br>                break; <br> <br> <br>        case WM_COMMAND: <br>                switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDM_EXIT: <br>                        if (ghThread!=NULL) { <br>                                extern CRITICAL_SECTION CSView; <br>                                /* Stop any other thread from allocating things that we <br>                                   want to free!  See the threads DOGMA at the top <br>                                   of this file. <br>                                */ <br> <br>                                /* Because the thread that we are about to kill might be in <br>                                   a critical section, we first grab them both.  It is <br>                                   essential that anyone else who ever does this, does <br>                                   so in the same order! <br>                                */ <br>                                WDEnter(); <br>                                EnterCriticalSection(&amp;CSView); <br>                                TerminateThread(ghThread, 31); <br>                                CloseHandle(ghThread); <br>                                ghThread = NULL; <br>                                LeaveCriticalSection(&amp;CSView); <br>                                WDLeave(); <br>                        } <br>                        if (!view_isexpanded(current_view)) { <br>                                /* save the current outline size and position */ <br>                                WINDOWPLACEMENT wp; <br>                                if (GetWindowPlacement(hwndClient,&amp;wp)) { <br>                                        WriteProfileInt(APPNAME, "OutlineShowCmd", wp.showCmd); <br>                                        WriteProfileInt(APPNAME, "OutlineMaxX", wp.ptMaxPosition.x); <br>                                        WriteProfileInt(APPNAME, "OutlineMaxY", wp.ptMaxPosition.y); <br>                                        WriteProfileInt(APPNAME, "OutlineNormLeft", wp.rcNormalPosition.left); <br>                                        WriteProfileInt(APPNAME, "OutlineNormTop", wp.rcNormalPosition.top); <br>                                        WriteProfileInt(APPNAME, "OutlineNormRight", wp.rcNormalPosition.right); <br>                                        WriteProfileInt(APPNAME, "OutlineNormBottom", wp.rcNormalPosition.bottom); <br>                                        WriteProfileInt(APPNAME, "OutlineSaved", 1); <br>                                } <br>                        } else { <br>                                /* save the current expanded size and position */ <br>                                WINDOWPLACEMENT wp; <br>                                if (GetWindowPlacement(hwndClient,&amp;wp)) { <br>                                        WriteProfileInt(APPNAME, "ExpandShowCmd", wp.showCmd); <br>                                        WriteProfileInt(APPNAME, "ExpandMaxX", wp.ptMaxPosition.x); <br>                                        WriteProfileInt(APPNAME, "ExpandMaxY", wp.ptMaxPosition.y); <br>                                        WriteProfileInt(APPNAME, "ExpandNormLeft", wp.rcNormalPosition.left); <br>                                        WriteProfileInt(APPNAME, "ExpandNormTop", wp.rcNormalPosition.top); <br>                                        WriteProfileInt(APPNAME, "ExpandNormRight", wp.rcNormalPosition.right); <br>                                        WriteProfileInt(APPNAME, "ExpandNormBottom", wp.rcNormalPosition.bottom); <br>                                        WriteProfileInt(APPNAME, "ExpandedSaved", 1); <br>                                } <br>                        } <br>                        DestroyWindow(hWnd); <br>                        break; <br> <br>                case IDM_ABORT: <br>                        /* abort menu item, or status bar button. <br>                         * the status bar button text gives the appropriate <br>                         * action depending on our state - abort, outline <br>                         * or expand. But the command sent is always <br>                         * IDM_ABORT. Thus we need to check the state <br>                         * to see what to do. If we are busy, set the abort <br>                         * flag. If there is nothing to view, <br>                         * exit, otherwise switch outline&lt;-&gt;expand <br>                         */ <br>                        if (IsBusy()) { <br>                                bAbort = TRUE; <br>                                SetStatus(LoadRcString(IDS_ABORT_PENDING)); <br> <br>                        } else if (DisplayMode == MODE_NULL) { <br>                                DestroyWindow(hWnd); <br>                        } else if (DisplayMode == MODE_EXPAND) { <br>                                ToOutline(hWnd); <br>                        } else { <br>                                ToExpand(hWnd); <br>                        } <br>                        break; <br> <br>                case IDM_FILE: <br>                        /* select two files and compare them */ <br>                        if (SetBusy()) { <br> <br>                               /* close the current view */ <br>                                view_close(current_view); <br> <br>                                /* make a new empty view */ <br>                                current_view = view_new(hwndRCD); <br> <br>                                /* make a COMPLIST using the files dialog, <br>                                 * and notify the view <br>                                 */ <br>                                if (complist_filedialog(current_view) == NULL) { <br>                                        view_close(current_view); <br>                                } <br> <br>                                /* all done! */ <br>                                SetNotBusy(); <br>                        } else { <br>                                BusyError(); <br>                        } <br>                        break; <br> <br>                case IDM_DIR: <br> <br>                        /* read two directory names, scan them and <br>                         * compare all the files and subdirs. <br>                         */ <br>                        if (SetBusy()) { <br> <br>                                /* close the current view */ <br>                                view_close(current_view); <br> <br>                                /* make a new empty view */ <br>                                current_view = view_new(hwndRCD); <br> <br>                                ghThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)wd_dirdialog, <br>                                        (LPVOID) current_view, 0, &amp;threadid); <br> <br>                                if (ghThread == NULL) <br>                                { <br>                                        wd_dirdialog( (LPVOID) current_view); <br>                                } <br> <br>                        } else { <br>                                BusyError(); <br>                        } <br>                        break; <br> <br>                case IDM_CLOSE: <br>                        /* close the output list - <br>                         * discard all results so far <br>                         */ <br>                        if (!IsBusy()) { <br>                                view_close(current_view); <br>                        } <br>                        break; <br> <br>                case IDM_PRINT: <br>                        /* print the current view - <br>                         * either the outline list of filenames, <br>                         * or the currently expanded file. <br>                         */ <br>                        if (!IsBusy()) { <br>                                DoPrint(); <br>                        } else { <br>                                BusyError(); <br>                        } <br>                        break; <br> <br>                case IDM_TIME: <br>                        /* show time it took */ <br>                        {       char msg[50]; <br>                                DWORD tim; <br>                                if (IsBusy()) { <br>                                         BusyError(); <br>                                } <br>                                else{ <br>                                        tim = complist_querytime(); <br>                                        wsprintf((LPTSTR)msg, LoadRcString(IDS_SECONDS), tim/1000, tim%1000); <br>                                } <br>                        } <br>                        break; <br> <br>                case IDM_SAVELIST: <br>                        /* allow user to save list of same/different files <br>                         * to a text file. dialog box to give filename <br>                         * and select which types of file to include <br>                         */ <br>                        complist_savelist(view_getcomplist(current_view), NULL, 0); <br>                        break; <br> <br>                case IDM_COPYFILES: <br>                        /* <br>                         * copy files that are same/different to a new <br>                         * root directory. dialog box allows user <br>                         * to select new root and inclusion options <br>                         */ <br>                        if (current_view == NULL) { <br>                                MessageBox(hWnd, <br>                                    LoadRcString(IDS_CREATE_DIFF_LIST), <br>                                    "WinDiff", MB_OK|MB_ICONSTOP); <br>                                break; <br>                        } <br> <br>                        if (SetBusy()) { <br>                                ghThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)wd_copy, <br>                                        (LPVOID) current_view, 0, &amp;threadid); <br>                                if (ghThread == NULL) <br>                                { <br>                                        wd_copy( (LPVOID) current_view); <br>                                } <br> <br>                        } else { <br>                                BusyError(); <br>                        } <br> <br>                        break; <br> <br>                case IDM_ABOUT: <br> <br>                        DialogBox( hInst, "About", hWnd, (DLGPROC)AboutBox); <br>                        break; <br> <br>                /* launch an editor on the current item - left, right or <br>                 * composite view <br>                 */ <br>                case IDM_EDITLEFT: <br>                        do_editthread(current_view, CI_LEFT); <br>                        break; <br> <br>                case IDM_EDITRIGHT: <br>                        do_editthread(current_view, CI_RIGHT); <br>                        break; <br> <br>                case IDM_EDITCOMP: <br>                        do_editthread(current_view, CI_COMP); <br>                        break; <br> <br>                /* allow customisation of the editor command line */ <br>                case IDM_SETEDIT: <br>                        if (StringInput(editor_cmdline, sizeof(editor_cmdline), <br>                                        LoadRcString(IDS_ENTER_EDT_CMD_LINE), <br>                                        "Windiff", editor_cmdline))  { <br>                                WriteProfileString(APPNAME, "Editor", <br>                                        (LPCSTR)editor_cmdline); <br>                        } <br>                        break; <br> <br> <br>                case IDM_LNRS: <br>                case IDM_RNRS: <br>                case IDM_NONRS: <br> <br>                        /* option selects whether the line nrs displayed <br>                         * in expand mode are the line nrs in the left <br>                         * file, the right file or none <br>                         */ <br> <br>                        CheckMenuItem(GetMenu(hWnd), <br>                                line_numbers, MF_UNCHECKED); <br>                        line_numbers = GET_WM_COMMAND_ID(wParam, lParam); <br>                        CheckMenuItem(GetMenu(hWnd), line_numbers, MF_CHECKED); <br>                        wsprintf((LPTSTR)str, "%d", line_numbers); <br>                        WriteProfileString(APPNAME, "LineNumbers", str); <br> <br>                        /* change the display to show the line nr style <br>                         * chosen <br>                         */ <br> <br>                        view_changeviewoptions(current_view); <br> <br> <br>                        break; <br> <br>                /* <br>                 * options selecting which files to include in the <br>                 * outline listing, based on their state <br>                 */ <br>                case IDM_INCLEFT: <br> <br> <br>                        /* toggle flag in outline_include options */ <br>                        outline_include ^= INCLUDE_LEFTONLY; <br> <br>                        /* check/uncheck as necessary */ <br>                        CheckMenuItem(hMenu, IDM_INCLEFT, <br>                              (outline_include &amp; INCLUDE_LEFTONLY) ? <br>                                        MF_CHECKED:MF_UNCHECKED); <br> <br>                        wsprintf((LPTSTR)str, "%d", outline_include); <br>                        WriteProfileString(APPNAME, "FileInclude", str); <br>                        view_changeviewoptions(current_view); <br> <br> <br>                        break; <br> <br>                case IDM_INCRIGHT: <br> <br> <br>                        outline_include ^= INCLUDE_RIGHTONLY; <br> <br>                        CheckMenuItem(hMenu, IDM_INCRIGHT, <br>                              (outline_include &amp; INCLUDE_RIGHTONLY) ? <br>                                        MF_CHECKED:MF_UNCHECKED); <br>                        wsprintf((LPTSTR)str, "%d", outline_include); <br>                        WriteProfileString(APPNAME, "FileInclude", str); <br>                        view_changeviewoptions(current_view); <br> <br>                        break; <br> <br>                case IDM_INCSAME: <br> <br> <br>                        outline_include ^= INCLUDE_SAME; <br> <br>                        CheckMenuItem(hMenu, IDM_INCSAME, <br>                              (outline_include &amp; INCLUDE_SAME) ? <br>                                        MF_CHECKED:MF_UNCHECKED); <br>                        wsprintf((LPTSTR)str, "%d", outline_include); <br>                        WriteProfileString(APPNAME, "FileInclude", str); <br>                        view_changeviewoptions(current_view); <br> <br> <br>                        break; <br> <br> <br>                case IDM_INCDIFFER: <br> <br> <br> <br>                        outline_include ^= INCLUDE_DIFFER; <br> <br>                        CheckMenuItem(hMenu, IDM_INCDIFFER, <br>                              (outline_include &amp; INCLUDE_DIFFER) ? <br>                                        MF_CHECKED:MF_UNCHECKED); <br> <br>                        wsprintf((LPTSTR)str, "%d", outline_include); <br>                        WriteProfileString(APPNAME, "FileInclude", str); <br>                        view_changeviewoptions(current_view); <br> <br> <br>                        break; <br> <br>                case IDM_UPDATE: <br>                        /* update the display.  Options or files may have changed */ <br>                        /* discard lines  (thereby forcing re-read). <br>                         */ <br>                        file_discardlines(compitem_getleftfile( (COMPITEM)lParam) ); <br>                        file_discardlines(compitem_getrightfile( (COMPITEM)lParam) ); <br> <br>                        view_changediffoptions(current_view); <br> <br>                        /* force repaint of bar window */ <br>                        InvalidateRect(hwndBar, NULL, TRUE); <br>                        break; <br> <br> <br> <br>                case IDM_LONLY: <br>                case IDM_RONLY: <br>                case IDM_BOTHFILES: <br>                        /* option selects whether the expanded file <br>                         * show is the combined file, or just one <br>                         * or other of the input files. <br>                         * <br>                         * if we are not in expand mode, this also <br>                         * causes us to expand the selection <br>                         */ <br> <br> <br>                        CheckMenuItem(GetMenu(hWnd), expand_mode, MF_UNCHECKED); <br>                        expand_mode = GET_WM_COMMAND_ID(wParam, lParam); <br>                        CheckMenuItem(GetMenu(hWnd), expand_mode, MF_CHECKED); <br> <br>                        /* change the current view to show only the lines <br>                         * of the selected type. <br>                         */ <br>                        if (DisplayMode == MODE_OUTLINE) { <br>                                ToExpand(hWnd); <br>                        } else { <br>                                view_changeviewoptions(current_view); <br>                        } <br> <br> </code></pre>
<p>
</p>
<pre><code>break; <br> <br> <br>                case IDM_IGNBLANKS: <br> <br>                        /* if selected, ignore all spaces and tabs on <br>                         * comparison - expand view only: outline view <br>                         * will still show that 'text files differ' <br>                         */ <br> <br>                        ignore_blanks = !ignore_blanks; <br>                        CheckMenuItem(hMenu, IDM_IGNBLANKS, <br>                                ignore_blanks? MF_CHECKED:MF_UNCHECKED); <br>                        wsprintf((LPTSTR)str, "%d", ignore_blanks); <br>                        WriteProfileString(APPNAME, "Blanks", str); <br> <br>                        /* invalidate all diffs since we have <br>                         * changed diff options, and re-do and display the <br>                         * current diff if we are in expand mode. <br>                         */ <br>                        view_changediffoptions(current_view); <br> <br>                        /* force repaint of bar window */ <br>                        InvalidateRect(hwndBar, NULL, TRUE); <br> <br>                        break; <br> <br>                case IDM_PICTURE: <br>                        /* do we show the bar picture in expand mode ? */ <br>                        picture_mode = !picture_mode; <br>                        CheckMenuItem(hMenu, IDM_PICTURE, <br>                                picture_mode? MF_CHECKED:MF_UNCHECKED); <br>                        wsprintf((LPTSTR)str, "%d", picture_mode); <br>                        WriteProfileString(APPNAME, "Picture", str); <br>                        DoResize(hWnd); <br>                        break; <br> <br> <br>                case IDM_EXPAND: <br> <br>                        /* show the expanded view of the <br>                         * selected file <br>                         */ <br>                        if (current_view != NULL) { <br>                                ToExpand(hWnd); <br>                        } <br> <br>                        break; <br> <br>                case IDM_OUTLINE: <br>                        /* return to the outline view (list of filenames) */ <br>                        ToOutline(hWnd); <br> <br>                        break; <br> <br>                case IDM_FCHANGE: <br>                        /* find the next line in the current view <br>                         * that is not the same in both files - <br>                         * in outline view, finds the next filename that <br>                         * is not identical <br>                         */ <br>                        FindNextChange(); <br> <br>                        break; <br> <br>                case IDM_FPCHANGE: <br>                        /* same as IDM_FCHANGE, but going backwards from <br>                         * current position <br>                         */ <br>                        FindPrevChange(); <br> <br>                        break; <br>                } <br>                break; <br> <br>        case WM_SIZE: <br>                DoResize(hWnd); <br>                break; <br> <br>        case WM_SETFOCUS: <br>                /* set the focus on the table class so it can process <br>                 * page-up /pagedown keys etc. <br>                 */ <br>                SetFocus(hwndRCD); <br>                break; <br> <br>        case WM_KEYDOWN: <br>                /* although the table window has the focus, he passes <br>                 * back to us any keys he doesn't understand <br>                 * We handle escape here to mean 'return to outline view' <br>                 */ <br>                if (wParam == VK_ESCAPE) { <br>                        ToOutline(hWnd); <br>                } <br>                break; <br> <br>        case WM_CLOSE: <br>                /* don't allow close when busy - process this message in <br>                 * order to ensure this <br>                 */ <br>                if (IsBusy()) { <br>                        return(TRUE); <br>                } else { <br>                        return(DefWindowProc(hWnd, message, wParam, lParam)); <br>                } <br>                break; <br> <br>        case WM_DESTROY: <br> <br>                DeleteTools(); <br>                PostQuitMessage(0); <br>                break; <br> <br>        case TM_CURRENTVIEW: <br>                /* allow other people such as the bar window to query the <br>                 * current view <br>                 */ <br>                return((DWORD) current_view); <br> <br>        default: <br>                /* handle registered table messages */ <br>                if (message == table_msgcode) { <br>                        ret = TableServer(hWnd, wParam, lParam); <br>                        return(ret); <br>                } <br>                return(DefWindowProc(hWnd, message, wParam, lParam)); <br>        } <br>        return(0); <br>} <br> <br>/*************************************************************************** <br> * Function: My_mbschr <br> * <br> * Purpose: <br> * <br> * DBCS version of strchr <br> * <br> */ <br>unsigned char * _CRTAPI1 My_mbschr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    return *psz == uiSep ? psz : NULL; <br>} <br>/*************************************************************************** <br> * Function: My_mbsncpy <br> * <br> * Purpose: <br> * <br> * DBCS version of strncpy <br> * <br> */ <br>unsigned char * _CRTAPI1 My_mbsncpy( <br>unsigned char *psz1, const unsigned char *psz2, size_t Length) <br>{ <br>        int nLen = (int)Length; <br>unsigned char *pszSv = psz1; <br> <br>while (0 &lt; nLen) { <br>if (*psz2 == '\0') { <br>*psz1++ = '\0'; <br>nLen--; <br>} else if (IsDBCSLeadByte(*psz2)) { <br>if (nLen == 1) { <br>*psz1 = '\0'; <br>} else { <br>*psz1++ = *psz2++; <br>*psz1++ = *psz2++; <br>} <br>nLen -= 2; <br>} else { <br>*psz1++ = *psz2++; <br>nLen--; <br>} <br>} <br>return pszSv; <br>} <br>/*************************************************************************** <br> * Function: My_mbsrchr <br> * <br> * Purpose: <br> * <br> * DBCS version of strrchr <br> * <br> */ <br>unsigned char * _CRTAPI1 My_mbsrchr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    unsigned char *pszHead; <br> <br>    pszHead = psz; <br> <br>    while (*psz != '\0') { <br>        psz++; <br>    } <br>    if (uiSep == '\0') { <br>        return psz; <br>    } <br> <br>    while (psz &gt; pszHead) { <br>        psz = CharPrev(pszHead, psz); <br>        if (*psz == uiSep) { <br>            break; <br>        } <br>    } <br>    return *psz == uiSep ? psz : NULL; <br>} <br>/*************************************************************************** <br> * Function: My_mbsncmp <br> * <br> * Purpose: <br> * <br> * DBCS version of strncmp <br> * If 'nLen' splits a DBC, this function compares the DBC's 2nd byte also. <br> * <br> */ <br>int _CRTAPI1 My_mbsncmp( <br>    const unsigned char *psz1, const unsigned char *psz2, size_t nLen) <br>{ <br>    int Length = (int)nLen; <br> <br>    while (0 &lt; Length) { <br>        if ('\0' == *psz1 || '\0' == *psz2) { <br>            return *psz1 - *psz2; <br>        } <br>        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) { <br>            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) { <br>                return *psz1 - *psz2; <br>            } <br>            psz1 += 2; <br>            psz2 += 2; <br>            Length -= 2; <br>        } else { <br>            if (*psz1 != *psz2) { <br>                return *psz1 - *psz2; <br>            } <br>            psz1++; <br>            psz2++; <br>            Length--; <br>        } <br>    } <br>    return 0; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
