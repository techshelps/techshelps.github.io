<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LIST.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5551"></a>LIST.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/****************************** Module Header ******************************* <br>* Module Name: LIST.C <br>* <br>* <br>* Functions: <br>* <br>* Alloc() <br>* Free() <br>* List_Init() <br>* List_Dump() <br>* List_Show() <br>* List_Create() <br>* List_Destroy() <br>* List_AddFirst() <br>* List_NewFirst() <br>* List_DeleteFirst() <br>* List_AddLast() <br>* List_NewLast() <br>* LIst_DeleteLast() <br>* List_AddAfter() <br>* List_NewAfter() <br>* List_AddBefore() <br>* List_NewBefore() <br>* List_Delete() <br>* List_DeleteForwards() <br>* List_DeleteBackwards() <br>* List_ItemLength() <br>* List_First() <br>* List_Last() <br>* List_Next() <br>* List_Prev() <br>* List_Clear() <br>* List_IsEmpty() <br>* SwitchLists() <br>* List_Join() <br>* List_InsertListAfter() <br>* List_InsertListBefore() <br>* List_SplitAfter() <br>* List_SplitBefore() <br>* List_Card() <br>* List_IsOK() <br>* LIst_MakeOK() <br>* List_Check() <br>* List_Recover() <br>* <br>* Comments: <br>* <br>* <br>****************************************************************************/ <br> <br>#include &lt;memory.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "gutils.h" <br>#include "list.h" <br>#include "gutilsrc.h" <br> <br>#define memcpy  memcpy <br> <br>char msg[80];  /* a temp for building up wsprintf messages in */ <br> <br>#define BLOCKSIZE 25000 <br> typedef struct <br> { HANDLE hMem;     /* memory handle for this block */ <br>   int iInUse;    /* number of allocations taken out of it.  0 =&gt; free it */ <br>   int iNext;     /* next byte to use */ <br>   char chData[BLOCKSIZE]; <br> } BLOCK, FAR *PBLOCK; <br> <br>static CRITICAL_SECTION CritSec;  /* to protect pCurrent */ <br>#define List_Enter_Crit(x)      EnterCriticalSection(x) <br>#define List_Leave_Crit(x)      LeaveCriticalSection(x) <br> <br>static PBLOCK pCurrent = NULL;  /* block currently in use */ <br>                          /* must always be either NULL or valid */ <br> <br> /* Allocate storage for List elements.  n.b. after a call to this <br>    you MUST record the value of pCurrent as you need to hand that in <br>    to Free.  You don't hand in the value of the actual storage. <br>    See screed above. <br>    This function Enters the critical section.  The caller must Leave it. <br> */ <br>static LPVOID Alloc(int size) <br> { HANDLE hMem; <br>   LPVOID pRet; <br>   List_Enter_Crit(&amp;CritSec); <br>   if ((pCurrent==NULL)||(pCurrent-&gt;iNext+size&gt;BLOCKSIZE+1)) <br>   { hMem = GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE,(DWORD)(sizeof(BLOCK))); <br>     if (hMem==NULL) <br>       { pCurrent = NULL; <br>         OutputDebugString("GlobalAlloc failed!!\n"); <br>         return NULL; <br>       } <br>     pCurrent = (PBLOCK)GlobalLock(hMem); <br>     if (pCurrent==NULL) <br>       { OutputDebugString("GlobalLock failed!!\n"); <br>         return NULL; <br>       } <br>     pCurrent-&gt;hMem = hMem; <br>     pCurrent-&gt;iInUse = 0; <br>     pCurrent-&gt;iNext = 0; <br>   } <br>   pRet = &amp;(pCurrent-&gt;chData[pCurrent-&gt;iNext]); <br>   ++(pCurrent-&gt;iInUse); <br>   pCurrent-&gt;iNext += size; <br> <br>   /* for MIPS we must also ensure that the data is aligned 4 byte*/ <br>   pCurrent-&gt;iNext += 3; <br>   pCurrent-&gt;iNext -= pCurrent-&gt;iNext % 4; <br> <br>   return pRet; <br> } /* Alloc */ <br> <br>static void Free(PBLOCK pBlock, LPVOID p) <br> { HANDLE hMem; <br>   List_Enter_Crit(&amp;CritSec); <br>    --pBlock-&gt;iInUse; <br>   if (pBlock-&gt;iInUse&lt;=0) <br>   { if (pBlock-&gt;iInUse&lt;0) <br>     {  <br>        extern HANDLE hLibInst; <br>        TCHAR szBuf[512]; <br>        LoadString(hLibInst, IDS_LIST_ALLOC_NEGATIVE, szBuf, sizeof(szBuf)); <br>  <br>        wsprintf(msg, szBuf, pBlock-&gt;iInUse); <br>        MessageBox(NULL, msg, NULL, MB_OK | MB_ICONSTOP); <br>      } <br>  <br>     hMem = pBlock-&gt;hMem; <br>     GlobalUnlock(hMem); <br>     GlobalFree(hMem); <br>     if (pCurrent==pBlock) pCurrent = NULL; /* defend the invariant */ <br>   } <br>   List_Leave_Crit(&amp;CritSec); <br> } /* Free */ <br> <br>  /* The following definition tells the truth about what an ITEM is.  The <br>  |  header file says only that there's a structure with the tag item_tag and <br>  |  that a LIST is a pointer to one.  Here we spell out what that structure <br>  |  is (and a LIST is still a pointer to one).  A PLIST is defined as a <br>  |  pointer to one of those, but is only really used because the C <br>  |  parameter mechanism demands an extra level of indirection for a <br>  |  parameter that can be updated.  (Modula-2 VAR parameter). <br>  */ <br>  typedef struct item_tag <br>  { struct item_tag FAR *pitNext;    /* to next in circular list */ <br>    struct item_tag FAR *pitPrev;    /* to prev in circular list */ <br>    PBLOCK pBlock;               /* to memory block */ <br>    BOOL bAnchor;                /* TRUE iff an anchor block */ <br>    BOOL bOK;                    /* true unless a list op has failed */ <br>    int iLen;                    /* length of data only */ <br>    char Data[1];                /* the caller's data.  The '1' is a lie */ <br>  } ITEM; <br> <br>  /* For an anchor block, only the fields pitNext thru bAnchor are allocated. <br>  |  For a normal list element, Data may well be longer than 1 byte. <br>  |  The bOK flag is to support a style of programming where several <br>  |  successive operations can be done without having to check the return <br>  |  code at each stage.  At the end, the list can be examined to see if <br>  |  the data in it is valid or if it has been made invalid by the failure <br>  |  of any of the previous operations.  Certain operations may result in <br>  |  having no list at all if they fail (e.g. create) and for these, you'd <br>  |  better check the result at once! <br>  |  ??? Some of this screed belongs in the header!!! <br>  */ <br> <br>  static int iAnchorSize;      /* Size of anchor block (no data, no dummy) */ <br>  static int iHeaderSize;      /* Size of data block not counting Data <br>                                  and offset from cursor back to item. <br>                               */ <br>  static BOOL bInited = FALSE; /* TRUE &lt;=&gt; iAnchorSize and iHeaderSize are OK*/ <br> <br>#define MOVEBACK(Curs)                                               \ <br>   { Curs = ((char FAR *)Curs-iHeaderSize); } /*move from Data to pitNext*/ <br> <br>  /*================================================================== <br>  || Lists are circular, doubly linked with an anchor block which holds <br>  || pointers to both ends.  Every block has a flag which shows whether <br>  || it's an anchor or not. <br>  || <br>  || Empty list: <br>  || <br>  ||      ------------- <br>  ||     |             | <br>  ||     |   Anchor    | <br>  ||     v   -------   | <br>  ||  Ul---&gt;| Next--+--| <br>  ||        |-------|  | <br>  ||        | Prev--+-- <br>  ||         ------- <br>  || <br>  || One entry list: <br>  || <br>  ||      ------------------------------------ <br>  ||     |                                    | <br>  ||     |   Anchor                           | <br>  ||     v   -------                ------    | <br>  ||  Ul---&gt;| Next--+-------------&gt;| Next-+---| <br>  ||        |-------|    |         |------|   | <br>  ||        | Prev--+----          | Prev-+--- <br>  ||         -------               |------| <br>  ||                               | Len  | <br>  ||                               |------| <br>  ||                               | Data | <br>  ||                                ------ <br>  || Two entry list: <br>  || <br>  ||      ------------------------------------------------- <br>  ||     | ---------------    ---------------              | <br>  ||     ||               |  |               |             | <br>  ||     ||  Anchor       |  |               |             | <br>  ||     vv  --------     |  v    ------     |    ------   | <br>  ||  Ul---&gt;| Next--+-----+-----&gt;| Next-+----+--&gt;| Next-+-- <br>  ||        |-------|     |      |------|  | |   |------| <br>  ||        | Prev--+--    ------+-Prev |  |  ---+-Prev | <br>  ||         -------   |         |------|  |     |------| <br>  ||                   |         | Len  |  |     | Len  | <br>  ||                   |         |------|  |     |------|&lt;----Cursor <br>  ||                   |         | Data |  |     | Data | <br>  ||                   |          ------   |      ------ <br>  ||                   |                   | <br>  ||                    ------------------- <br>  || <br>  || etc. <br>  || <br>  || Note that an external cursor (i.e one which is seen by the caller) <br>  || points to the Data field, not to the start of the structure. <br>  || This allows easy access to the data by the user at the cost of a <br>  || slightly slower traverse. <br>  || Within this module, we may sometimes traverse a list with  a cursor <br>  || that points to the start of an item.  This is called an item cursor. <br>   ===================================================================*/ <br> <br>  /*------------------------------------------------------------------ <br>  | Set iAnchorSize and iHeaderSize.  Implementation independent! <br>   -------------------------------------------------------------------*/ <br>void APIENTRY List_Init(void) <br>  {  LIST P; <br>     P = (LIST)&amp;P;                  /* really any old address will do */ <br>     iAnchorSize = (char FAR *)&amp;(P-&gt;iLen) - (char FAR *)&amp;(P-&gt;pitNext); <br>     iHeaderSize = (char FAR *)&amp;(P-&gt;Data) - (char FAR *)&amp;(P-&gt;pitNext); <br>     InitializeCriticalSection(&amp;CritSec); <br>     /* assumes layout in storage is linear */ <br>  } <br> <br>  /* Dump the internals to the debugger. */ <br>void APIENTRY List_Dump(LPSTR Header, LIST lst) <br>  {  LIST pit; <br>     char msg[250]; <br> <br>     OutputDebugString(Header);  OutputDebugString("\n"); <br>     pit = lst; <br>     do <br>     { wsprintf(msg,"%8x %8x %8x %ld %s " <br>               , pit, pit-&gt;pitNext, pit-&gt;pitPrev, pit-&gt;iLen <br>               , (pit-&gt;bAnchor ? "Anchor" : "Data") <br>               ); <br>       OutputDebugString(msg); <br>       if (pit-&gt;pitNext-&gt;pitPrev != pit) <br>         OutputDebugString(" Next Prev error!!"); <br>       if (pit-&gt;pitPrev-&gt;pitNext != pit) <br>         OutputDebugString(" Prev Next error!!"); <br>       OutputDebugString("\n"); <br>       pit = pit-&gt;pitNext; <br>     } while (pit!=lst); <br>     OutputDebugString("End of list dump\n"); <br>  } /* List_Dump */ <br> <br>  /* Dump hex representation of handle to debugger */ <br>void APIENTRY List_Show(LIST lst) <br>  { char msg[50];                <br>    wsprintf(msg, "%8x", lst); <br>    OutputDebugString(msg); <br>  } /* List_Show */ <br> <br>  /*------------------------------------------------------------------ <br>  | Create a list.  It will be initially empty <br>   -------------------------------------------------------------------*/ <br>LIST APIENTRY List_Create(void) <br>  {  LIST lst; <br>     if (!bInited) {List_Init(); }          /* prevent some silly errors */ <br>     lst = Alloc(iAnchorSize); <br>     if (lst==NULL) { return NULL; } <br>     lst-&gt;pBlock = pCurrent; <br>     List_Leave_Crit(&amp;CritSec); <br>     lst-&gt;bOK = TRUE; <br>     lst-&gt;pitNext = lst; <br>     lst-&gt;pitPrev = lst; <br>     lst-&gt;bAnchor = TRUE; <br>     /* no length field set in an anchor block */ <br>     return lst; <br>  } /* List_Create */ <br> <br>  /*------------------------------------------------------------------ <br>  | Destroy *plst.  It does not need to be empty first <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_Destroy(PLIST plst) <br>  {  LIST pitP;    /* item cursor on * plst */ <br>     LIST pitQ;    /* item cursor runs one step ahead of pitQ */ <br> <br>     if (plst==NULL) <br>       return; <br>     /* There is at least an anchor block to destroy */ <br>     pitP = *plst; <br>     do <br>     {  pitQ = pitP-&gt;pitNext; <br>        Free(pitP-&gt;pBlock, pitP); <br>        pitP = pitQ; <br>     }while(pitP != *plst); <br>     *plst = NULL; <br>  } /* List_Destroy */ <br> <br>  /*------------------------------------------------------------------ <br>  | Add an item holding Object to the beginning of * plst <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_AddFirst(LIST lst, LPVOID pObject, UINT uLen) <br>  {  LIST pit;      /* newly allocated item */ <br> <br>     if (lst==NULL) <br>       return; <br>     pit = Alloc(iHeaderSize+uLen); <br>     if (pit==NULL) { lst-&gt;bOK = FALSE; return; } <br>     pit-&gt;pBlock = pCurrent; <br>     List_Leave_Crit(&amp;CritSec); <br>     pit-&gt;iLen = uLen; <br>     pit-&gt;pitPrev = lst; <br>     pit-&gt;pitNext = lst-&gt;pitNext; <br>     lst-&gt;pitNext-&gt;pitPrev = pit; /* for empty list that set lst-&gt;pitPrev */ <br>     lst-&gt;pitNext = pit; <br>     pit-&gt;bAnchor = FALSE; <br>     memcpy( &amp;(pit-&gt;Data), pObject, uLen ); <br>  } /* List_AddFirst */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the address of the place for Len bytes of data in a new <br>  | item at the start of lst <br>   -------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_NewFirst(LIST lst, UINT uLen) <br>  {  LIST pit; <br> <br>     if (lst==NULL) <br>       return NULL; <br>     pit = Alloc(iHeaderSize+uLen); <br>     if (pit==NULL) { lst-&gt;bOK = FALSE; return NULL; } <br>     pit-&gt;pBlock = pCurrent; <br>     List_Leave_Crit(&amp;CritSec); <br>     pit-&gt;iLen = uLen; <br>     pit-&gt;pitPrev = lst; <br>     pit-&gt;pitNext = lst-&gt;pitNext; <br>     lst-&gt;pitNext-&gt;pitPrev = pit; /* for empty list that set lst-&gt;pitPrev */ <br>     lst-&gt;pitNext = pit; <br>     pit-&gt;bAnchor = FALSE; <br>     return (char FAR *)&amp;(pit-&gt;Data); <br>  } /* List_NewFirst */ <br> <br>  /*------------------------------------------------------------------ <br>  | Delete the first item in lst.  Error if lst is empty <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_DeleteFirst(LIST lst) <br>  {  LIST pit; <br> <br>     if (lst==NULL) <br>       return; <br>                               /* attempting to delete the anchor block! */ <br>     if (lst-&gt;pitNext==lst) {lst-&gt;bOK = FALSE; } <br>     else <br>        {  pit = lst-&gt;pitNext; <br>           pit-&gt;pitNext-&gt;pitPrev = pit-&gt;pitPrev; <br>           pit-&gt;pitPrev-&gt;pitNext = pit-&gt;pitNext; <br>           Free(pit-&gt;pBlock, pit); <br>        } <br>  } /* List_DeleteFirst */ <br> <br>  /*------------------------------------------------------------------ <br>  | Add an item holding Object to the end of lst <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_AddLast(LIST lst, LPVOID pObject, UINT uLen) <br>  {  LIST pit; <br> <br>     if (lst==NULL) <br>       return; <br>     pit = Alloc(iHeaderSize+uLen); <br>     if (pit==NULL) { lst-&gt;bOK = FALSE; return; } <br>     pit-&gt;pBlock = pCurrent; <br>     List_Leave_Crit(&amp;CritSec); <br>     pit-&gt;iLen = uLen; <br>     pit-&gt;pitNext = lst; <br>     pit-&gt;pitPrev = lst-&gt;pitPrev; <br>     lst-&gt;pitPrev-&gt;pitNext = pit; /* for empty list that set lst-&gt;pitNext */ <br>     lst-&gt;pitPrev = pit; <br>     pit-&gt;bAnchor = FALSE; <br>     memcpy( &amp;(pit-&gt;Data), pObject, uLen ); <br>  } /* ListAddLast */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the address of the place for uLen bytes of data in a new <br>  |  item at the end of lst <br>   -------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_NewLast(LIST lst, UINT uLen) <br>  {  LIST pit; <br> <br>     if (lst==NULL) <br>       return NULL; <br>     pit = Alloc(iHeaderSize+uLen); <br>     if (pit==NULL) { lst-&gt;bOK = FALSE; return NULL; } <br>     pit-&gt;pBlock = pCurrent; <br>     List_Leave_Crit(&amp;CritSec); <br>     pit-&gt;iLen = uLen; <br>     pit-&gt;pitNext = lst; <br>     pit-&gt;pitPrev = lst-&gt;pitPrev; <br>     lst-&gt;pitPrev-&gt;pitNext = pit; /* for empty list that set lst-&gt;pitNext */ <br>     lst-&gt;pitPrev = pit; <br>     pit-&gt;bAnchor = FALSE; <br>     return (char FAR *)&amp;(pit-&gt;Data); <br>  } /* ListNewLast */ <br> <br>  /*------------------------------------------------------------------ <br>  | Delete the last item in lst.  Error if lst is empty <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_DeleteLast(LIST lst) <br>  {  LIST pit; <br> <br>     if (lst==NULL) <br>       return; <br>                               /* attempting to delete the anchor block! */ <br>     if (lst-&gt;pitNext==lst) {lst-&gt;bOK = FALSE; } <br>     else <br>        {  pit = lst-&gt;pitPrev; <br>           pit-&gt;pitNext-&gt;pitPrev = pit-&gt;pitPrev; <br>           pit-&gt;pitPrev-&gt;pitNext = pit-&gt;pitNext; <br>           Free(pit-&gt;pBlock, pit); <br>        } <br>  } /* List_DeleteLast */ <br> <br>  /*-------------------------------------------------------------------- <br>  | Add an item holding * pObject to lst immediately after Curs. <br>  | List_AddAfter(lst,NULL,pObject,Len) adds it to the start of the lst <br>   ---------------------------------------------------------------------*/ <br>  void APIENTRY List_AddAfter( LIST lst <br>                    , LPVOID Curs <br>                    , LPVOID pObject <br>                    , UINT uLen <br>                    ) <br>  {  LIST pitNew; <br>     LIST pitAfter; <br> <br>     if (lst==NULL) <br>       return; <br>     if (Curs==NULL){ List_AddFirst(lst, pObject, uLen);} <br>     else <br>        {  MOVEBACK(Curs); <br>           pitAfter = (LIST)Curs; <br>           pitNew = Alloc(iHeaderSize+uLen); <br>           if (pitNew==NULL) { lst-&gt;bOK = FALSE; return; } <br>           pitNew-&gt;pBlock = pCurrent; <br>           List_Leave_Crit(&amp;CritSec); <br>           pitNew-&gt;iLen = uLen; <br>           pitNew-&gt;pitPrev = pitAfter; <br>           pitNew-&gt;pitNext = pitAfter-&gt;pitNext; <br>           pitAfter-&gt;pitNext-&gt;pitPrev = pitNew; <br>           pitAfter-&gt;pitNext = pitNew; <br>           pitNew-&gt;bAnchor = FALSE; <br>           memcpy( &amp;(pitNew-&gt;Data), pObject, uLen ); <br>        } <br>  } /* List_AddAfter */ <br> <br>  /*-------------------------------------------------------------------- <br>  | Return the address of the place for uLen bytes of data in a new <br>  | item immediately after Curs. <br>  | List_NewAfter(Lst,NULL,uLen) returns a pointer <br>  | to space for uLen bytes in a new first element. <br>   ---------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_NewAfter(LIST lst, LPVOID Curs, UINT uLen) <br>  {  LIST pitNew; <br>     LIST pitAfter; <br> <br>     if (lst==NULL) <br>       return NULL; <br>     if (Curs==NULL){ return List_NewFirst(lst, uLen);} <br>     else <br>        {  MOVEBACK(Curs); <br>           pitAfter = (LIST)Curs; <br>           pitNew = Alloc(iHeaderSize+uLen); <br>           if (pitNew==NULL) { lst-&gt;bOK = FALSE; return NULL; } <br>           pitNew-&gt;pBlock = pCurrent; <br>           List_Leave_Crit(&amp;CritSec); <br>           pitNew-&gt;iLen = uLen; <br>           pitNew-&gt;pitPrev = pitAfter; <br>           pitNew-&gt;pitNext = pitAfter-&gt;pitNext; <br>           pitAfter-&gt;pitNext-&gt;pitPrev = pitNew; <br>           pitAfter-&gt;pitNext = pitNew; <br>           pitNew-&gt;bAnchor = FALSE; <br>           return (char FAR *)&amp;(pitNew-&gt;Data); <br>        } <br>  } /* List_NewAfter */ <br> <br>  /*-------------------------------------------------------------------- <br>  | Add an item holding Object to lst immediately before Curs. <br>  | List_AddBefore(Lst,NULL,Object,uLen) adds it to the end of the list <br>   ---------------------------------------------------------------------*/ <br>  void APIENTRY List_AddBefore( LIST lst <br>                     , LPVOID Curs <br>                     , LPVOID pObject <br>                     , UINT uLen <br>                     ) <br>  {  LIST pitNew; <br>     LIST pitBefore; <br> <br>     if (lst==NULL) <br>       return; <br>     if (Curs==NULL){ List_AddLast(lst, pObject, uLen);} <br>     else <br>        {  MOVEBACK(Curs); <br>           pitBefore = (LIST)Curs; <br>           pitNew = Alloc(iHeaderSize+uLen); <br>           if (pitNew==NULL) { lst-&gt;bOK = FALSE; return; } <br>           pitNew-&gt;pBlock = pCurrent; <br>           List_Leave_Crit(&amp;CritSec); <br>           pitNew-&gt;iLen = uLen; <br>           pitNew-&gt;pitNext = pitBefore; <br>           pitNew-&gt;pitPrev = pitBefore-&gt;pitPrev; <br>           pitBefore-&gt;pitPrev-&gt;pitNext = pitNew; <br>           pitBefore-&gt;pitPrev = pitNew; <br>           pitNew-&gt;bAnchor = FALSE; <br>           memcpy( &amp;(pitNew-&gt;Data), pObject, uLen ); <br>        } <br>  } /* List_AddBefore */ <br> <br>  /*-------------------------------------------------------------------- <br>  | Return the address of the place for uLen bytes of data in a new <br>  | item immediately before Curs. <br>  | List_NewBefore(Lst,NULL,uLen) returns a pointer <br>  | to space for uLen bytes in a new last element. <br>   ---------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_NewBefore(LIST lst, LPVOID Curs, UINT uLen ) <br>  {  LIST pitNew; <br>     LIST pitBefore; <br> <br>     if (lst==NULL) <br>       return NULL; <br>     if (Curs==NULL){ return List_NewLast(lst, uLen);} <br>     else <br>        {  MOVEBACK(Curs); <br>           pitBefore = (LIST)Curs; <br>           pitNew = Alloc(iHeaderSize+uLen); <br>           if (pitNew==NULL) { lst-&gt;bOK = FALSE; return NULL; } <br>           pitNew-&gt;pBlock = pCurrent; <br>           List_Leave_Crit(&amp;CritSec); <br>           pitNew-&gt;iLen = uLen; <br>           pitNew-&gt;pitNext = pitBefore; <br>           pitNew-&gt;pitPrev = pitBefore-&gt;pitPrev; <br>           pitBefore-&gt;pitPrev-&gt;pitNext = pitNew; <br>           pitBefore-&gt;pitPrev = pitNew; <br>           pitNew-&gt;bAnchor = FALSE; <br>           return (char FAR *) &amp;(pitNew-&gt;Data); <br>        } <br>  } /* List_NewBefore */ <br> <br>  /*------------------------------------------------------------------ <br>  | Delete the item that Curs identifies. <br>  | This will be only a few (maybe as little as 3) machine instructions <br>  | quicker than DeleteForwards or DeleteBackwards but leaves Curs dangling. <br>  | It is therefore NOT usually to be preferred. <br>  | It may be useful when you have a function which returns an LPVOID <br>  | since the argument does not need to be a variable. <br>  |     Trivial example: List_Delete(List_First(L)); <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_Delete(LPVOID Curs) <br>  {  LIST pit; <br> <br>     if(Curs==NULL) <br>       return; <br>     MOVEBACK(Curs) <br>     pit = (LIST)Curs; <br>     pit-&gt;pitNext-&gt;pitPrev = pit-&gt;pitPrev; <br>     pit-&gt;pitPrev-&gt;pitNext = pit-&gt;pitNext; <br>     Free(pit-&gt;pBlock, pit); <br>  } /* List_Delete */ <br> <br>  /*----------------------------------------------------------------------- <br>  | Delete the item that Curs identifies and return a cursor that <br>  | identifies the next item (NULL if already on last) <br>   ------------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_DeleteForwards(LPVOID Curs) <br>  {  LIST pitDel;  /* the item to delete */ <br>     LIST pitN;    /* the item after (could be anchor) */ <br> <br>     if(Curs==NULL) <br>       return NULL; <br>     MOVEBACK(Curs) <br>     pitDel = (LIST)Curs; <br>     pitN = pitDel-&gt;pitNext; <br> <br>     pitN-&gt;pitPrev = pitDel-&gt;pitPrev; <br>     pitDel-&gt;pitPrev-&gt;pitNext = pitN; <br>     Free(pitDel-&gt;pBlock, pitDel); <br>     if (pitN-&gt;bAnchor) return NULL; <br>     else return (char FAR *)&amp;(pitN-&gt;Data); <br>  } /* List_DeleteForwards */ <br> <br>  /*----------------------------------------------------------------------- <br>  | Delete the item that Curs identifies and return a cursor that <br>  | identifies the previous item (NULL if already on first) <br>   ------------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_DeleteBackwards(LPVOID Curs) <br>  {  LIST pitDel;  /* the one to delete */ <br>     LIST pitB;    /* the one before */ <br> <br>     if(Curs==NULL) <br>       return NULL; <br>     MOVEBACK(Curs) <br>     pitDel = (LIST)Curs; <br>     pitB = pitDel-&gt;pitPrev; <br>     pitDel-&gt;pitNext-&gt;pitPrev = pitB; <br>     pitB-&gt;pitNext = pitDel-&gt;pitNext; <br>     Free(pitDel-&gt;pBlock, pitDel); <br>     if (pitB-&gt;bAnchor) return NULL; <br>     else return (char FAR *)&amp;(pitB-&gt;Data); <br>  } /* List_DeleteBackwards */ <br> <br>  /*------------------------------------------------------------------- <br>  | Return the length of the object identified by the cursor Curs <br>   -------------------------------------------------------------------*/ <br>  int APIENTRY List_ItemLength(LPVOID Curs) <br>  {  LIST pit; <br> <br>     if(Curs==NULL) <br>       return 0; <br>     MOVEBACK(Curs) <br>     pit = (LIST)Curs; <br>     return pit-&gt;iLen; <br>  } /* List_ItemLength */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the address of the first object in lst <br>  |  If lst is empty then Return NULL. <br>   -------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_First(LIST lst) <br>  {   <br>     if (lst==NULL) <br>       return NULL; <br>     if (lst-&gt;pitNext==lst) { return NULL; } <br>     return &amp;(lst-&gt;pitNext-&gt;Data); <br>  } /* List_First */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the address of the last object in lst <br>  | If lst is empty then return NULL. <br>   -------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_Last(LIST lst) <br>  {   <br>     if (lst==NULL) <br>       return NULL; <br>     if (lst-&gt;pitNext==lst) { return NULL; } <br>     return &amp;(lst-&gt;pitPrev-&gt;Data); <br>  } /* List_Last */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the address of the object after Curs^. <br>  | List_Next(List_Last(lst)) == NULL;  List_Next(NULL) is an error. <br>   -------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_Next(LPVOID Curs) <br>  {  LIST pit; <br> <br>     if(Curs==NULL) <br>       return NULL; <br>     MOVEBACK(Curs) <br>     pit = (LIST)Curs; <br>     pit = pit-&gt;pitNext; <br>     if (pit-&gt;bAnchor) {return NULL;} else {return &amp;(pit-&gt;Data);} <br>  } /* List_Next */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the address of the object after Curs^. <br>  | List_Prev(List_First(L)) == NULL;  List_Prev(NULL) is an error. <br>   -------------------------------------------------------------------*/ <br>  LPVOID APIENTRY List_Prev(LPVOID Curs) <br>  {  LIST pit; <br> <br>     if(Curs==NULL) <br>       return NULL; <br>     MOVEBACK(Curs) <br>     pit = (LIST)Curs; <br>     pit = pit-&gt;pitPrev; <br>     if (pit-&gt;bAnchor) {return NULL;} else {return &amp;(pit-&gt;Data);} <br>  } /* List_Prev */ <br> <br>  /*------------------------------------------------------------------- <br>  | Arrange that lst is empty after this call <br>   --------------------------------------------------------------------*/ <br>  void APIENTRY List_Clear(LIST lst) <br>  {  LIST pitP;   /* item cursor on List, points to element starts */ <br>     LIST pitQ;   /* runs one step ahead of pitP                   */ <br> <br>     if (lst==NULL) <br>       return; <br>     pitP = lst-&gt;pitNext;   /* first element of list proper */ <br>     while (pitP!=lst)      /* while not wrapped onto anchor */ <br>        {  pitQ = pitP-&gt;pitNext; <br>           Free(pitP-&gt;pBlock, pitP); <br>           pitP = pitQ; <br>        } <br>     lst-&gt;bOK = TRUE; <br>     lst-&gt;pitNext = lst; <br>     lst-&gt;pitPrev = lst; <br>  } /* List Clear */ <br> <br>  /*--------------------------------------------------------------------- <br>  | Return TRUE if and only if lst is empty <br>   ----------------------------------------------------------------------*/ <br>  BOOL APIENTRY List_IsEmpty(LIST lst) <br>  {  if (lst==NULL) <br>       return TRUE;   /* well it's sort of true isn't it? */ <br>     return lst-&gt;pitNext ==lst; <br>  } /* List_IsEmpty */ <br> <br>  /*------------------------------------------------------------------ <br>  | l1 had better be empty.  l1 then acquires all the elements from l2 <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY SwitchLists(LIST l1, LIST l2) <br>  {  /* connect l1 to l2's elements, l1 had better be initially empty */ <br>     l1-&gt;pitPrev = l2-&gt;pitPrev; <br>     l1-&gt;pitNext = l2-&gt;pitNext; <br>     /* connect the elements to l1 anchor block. */ <br>     l1-&gt;pitPrev-&gt;pitNext = l1; <br>     l1-&gt;pitNext-&gt;pitPrev = l1; <br>     /* make l2 empty */ <br>     l2-&gt;pitPrev = l2; <br>     l2-&gt;pitNext = l2; <br>  } /* SwitchLists */ <br> <br>  /*----------------------------------------------------------------------- <br>  | l1 := l1||l2; l2 := empty <br>  | The elements themselves are not moved, so pointers to them remain valid. <br>  | <br>  | l1 gets all the elements of l1 in their original order followed by <br>  | all the elements of l2 in the order they were in in l2. <br>  | l2 becomes empty. <br>   ------------------------------------------------------------------------*/ <br>  void APIENTRY List_Join(LIST l1, LIST l2) <br>  {  if((l1==NULL)||(l2==NULL)) <br>       return; <br>     l1-&gt;bOK = l1-&gt;bOK &amp;&amp;l2-&gt;bOK;  /* result OK if both inputs OK */ <br>     l2-&gt;bOK = TRUE;               /* as l2 always becomes empty */ <br>     if (l2-&gt;pitNext==l2) { /* no elements need moving */ } <br>     else if (l2-&gt;pitNext==l2) { SwitchLists(l1,l2); return; } <br>     else <br>        {  l2-&gt;pitNext-&gt;pitPrev = l1-&gt;pitPrev; <br>           l1-&gt;pitPrev-&gt;pitNext = l2-&gt;pitNext; <br>           l1-&gt;pitPrev = l2-&gt;pitPrev; <br>           l1-&gt;pitPrev-&gt;pitNext = l1; <br>           l2-&gt;pitNext = l2; <br>           l2-&gt;pitPrev = l2; <br>        } <br>  } /* List_Join */ <br> <br>  /*----------------------------------------------------------------------- <br>  | Let L1 be *pl1 and L2 be *pl2 <br>  | L1 := L1[...Curs] || L2 || L1[Curs+1...]; L2 := empty <br>  | Curs=NULL means insert L2 at the start of L1 <br>  | The elements themselves are not moved, so pointers to them remain valid. <br>  | <br>  | L1 gets the elements of L1 from the start up to and including the element <br>  | that Curs points at, in their original order, <br>  | followed by all the elements that were in L2, in their original order, <br>  | followed by the rest of L1 <br>   ------------------------------------------------------------------------*/ <br>  void APIENTRY List_InsertListAfter(LIST l1, LIST l2, LPVOID Curs) <br>  {  LIST pitA;     /* The element after Curs, could be anchor */ <br>     LIST pit;      /* The start of the element that Curs points at <br>                    |  or the anchor block if Curs==NULL <br>                    */ <br> <br>     if ( (l1==NULL) || (l2==NULL)) <br>       return; <br>     l1-&gt;bOK = l1-&gt;bOK &amp;&amp; l2-&gt;bOK; <br>     l2-&gt;bOK = TRUE; <br>     if (l2-&gt;pitNext==l2) { /* no elements need moving */ } <br>     else if ( l1-&gt;pitNext==l1) </code></pre>
<p>
</p>
<pre><code>{  /* the easy way to code this would be simply to switch the two <br>        |  pointers l1 and l2, but they are value parameters and we don't <br>        |  want to change that. <br>        */ <br>        SwitchLists(l1,l2); <br>        return; <br>     } <br>     else <br>     {  if(Curs==NULL){ pit = l1;} <br>        else <br>        {  MOVEBACK(Curs) <br>           pit = (LIST)Curs; <br>        } <br>        /* pit points to a block to insert after, could be anchor */ <br>        pitA = pit-&gt;pitNext;      /* Cannot be same as P, already checked */ <br>        l2-&gt;pitNext-&gt;pitPrev = pit;    /*  P&lt;-- elems-of-l2    A */ <br>        l2-&gt;pitPrev-&gt;pitNext = pitA;   /*  P&lt;-- elems-of-l2 --&gt;A */ <br>        pit-&gt;pitNext = l2-&gt;pitNext;    /*  P&lt;--&gt;elems-of-l2 --&gt;A */ <br>        pitA-&gt;pitPrev = l2-&gt;pitPrev;   /*  P&lt;--&gt;elems-of-l2&lt;--&gt;A */ <br> <br>        l2-&gt;pitNext = l2; <br>        l2-&gt;pitPrev = l2; <br>     } <br>  }  /* List_InsertListAfter */ <br> <br> <br>  /*----------------------------------------------------------------------- <br>  | l1 := l1[...Curs-1] || l2 || l1[Curs...]; l2 := empty <br>  | Curs=NULL means insert l2 at the end of l1 <br>  | The elements themselves are not moved, so pointers to them remain valid. <br>  | <br>  | l1 gets the elements of l1 from the start up to but not including the <br>  | element that Curs points at, in their original order, <br>  | followed by all the elements that were in l2, in their original order, <br>  | followed by the rest of l1. <br>   ------------------------------------------------------------------------*/ <br>  void APIENTRY List_InsertListBefore(LIST l1, LIST l2, LPVOID Curs) <br>  {  LIST pitB;     /* The element before Curs, could be anchor */ <br>     LIST pit;      /* The start of the element that Curs points at <br>                    |  or the anchor block if Curs==NULL <br>                    */ <br> <br>     if ((l1==NULL) || (l2==NULL)) <br>       return; <br>     l1-&gt;bOK = l1-&gt;bOK &amp;&amp; l2-&gt;bOK; <br>     l2 -&gt;bOK = TRUE; <br>     if (l2-&gt;pitNext==l2) { /* no action needed */ } <br>     else if (l1-&gt;pitNext==l1) <br>     {  /* the easy way to code this would be simply to switch the two <br>        |  pointers l1 and l2, but they are value parameters and we don't <br>        |  want to change that. <br>        */ <br>        SwitchLists(l1,l2); <br>        return; <br>     } <br>     else <br>     {  if(Curs==NULL) { pit = l1; } <br>        else <br>        {  MOVEBACK(Curs) <br>           pit = (LIST)Curs; <br>        } <br> <br>        /* P points to a block to insert before, could be anchor */ <br>        pitB = pit-&gt;pitPrev;       /* Cannot be same as P, already checked */ <br>        l2-&gt;pitNext-&gt;pitPrev = pitB; /*  B&lt;-- elems-of-L2    P */ <br>        l2-&gt;pitPrev-&gt;pitNext = pit;  /*  B&lt;-- elems-of-L2 --&gt;P */ <br>        pitB-&gt;pitNext = l2-&gt;pitNext; /*  B&lt;--&gt;elems-of-L2 --&gt;P */ <br>        pit-&gt;pitPrev = l2-&gt;pitPrev;  /*  B&lt;--&gt;elems-of-L2&lt;--&gt;P */ <br>        l2-&gt;pitNext = l2; <br>        l2-&gt;pitPrev = l2; <br>     } <br>  } /* List_InsertListBefore */ <br> <br> <br>  /*----------------------------------------------------------------------- <br>  | Let l1 be l1 and l2 be l2 <br>  | Split l2 off from the front of l1:    final l2,l1 = original l1 <br>  | <br>  | Split l1 into l2: objects of l1 up to and including Curs object <br>  |               l1: objects of l1 after Curs <br>  | Any original contents of l2 are freed. <br>  | List_Spilt(l1, l2, NULL) splits l1 before the first object so l1 gets all. <br>  | The elements themselves are not moved. <br>   ------------------------------------------------------------------------*/ <br>  void APIENTRY List_SplitAfter(LIST l1, LIST l2, LPVOID Curs) <br>  {  LIST pit; <br> <br>     if ((l1==NULL) || (l2==NULL)) <br>       return; <br>     if (l2-&gt;pitNext!=l2){ List_Clear(l2); }; <br>     if (Curs!=NULL) <br>     {  MOVEBACK(Curs) <br>        pit = (LIST)Curs; <br>        /* Curs had better be an item in l1! l2 had better be created! */ <br>        if (pit==l1) { l1-&gt;bOK = FALSE; l2-&gt;bOK = FALSE; return; } <br>        if (pit-&gt;pitNext==l1) <br>        {  /* transfer whole of l2 to l1 */ <br>           SwitchLists(l2,l1); <br>           return; <br>        } <br>        l2-&gt;pitPrev = pit; <br>        l2-&gt;pitNext = l1-&gt;pitNext; <br>        l1-&gt;pitNext = pit-&gt;pitNext; <br>        pit-&gt;pitNext = l2; <br>        l2-&gt;pitNext-&gt;pitPrev = l2; <br>        l1-&gt;pitNext-&gt;pitPrev = l1; <br>     } <br>  } /* List_SplitAfter */ <br> <br>  /*---------------------------------------------------------------------- <br>  | Split l2 off from the back of l1:  final l1,l2 = original l1 <br>  | <br>  | Split l1 into l1: objects of l1 up to but not including Curs object <br>  |               l2: objects of l1 from Curs onwards <br>  | Any original contants of l2 are freed. <br>  | List_Spilt(l1, l2, NULL) splits l1 after the last object so l1 gets all. <br>  | The elements themselves are not moved. <br>   -----------------------------------------------------------------------*/ <br>  void APIENTRY List_SplitBefore(LIST l1, LIST l2, LPVOID Curs) <br>  {  LIST pit; <br> <br>     if ((l1==NULL) || (l2==NULL)) <br>       return; <br>     if (l2-&gt;pitNext!=l2){ List_Clear(l2); } <br>     if (Curs!=NULL) <br>     {  MOVEBACK(Curs) <br>        pit = (LIST)Curs; <br>        /* Curs had better be an item in L1! L2 had better be created! */ <br>        if (pit==l1){ l1-&gt;bOK = FALSE; l2-&gt;bOK = FALSE; return; } <br>        if (pit-&gt;pitPrev==l1) { SwitchLists(l2,l1); return; } <br>        l2-&gt;pitNext = pit; <br>        l2-&gt;pitPrev = l1-&gt;pitPrev; <br>        l1-&gt;pitPrev = pit-&gt;pitPrev; <br>        pit-&gt;pitPrev = l2; <br>        l2-&gt;pitPrev-&gt;pitNext = l2; <br>        l1-&gt;pitPrev-&gt;pitNext = l1; <br>     } <br>  } /* List_SplitBefore */ <br> <br>  /*------------------------------------------------------------------ <br>  | Return the number of items in L <br>   -------------------------------------------------------------------*/ <br>  int APIENTRY List_Card(LIST lst) <br>  {  LIST pit;     /* item cursor on lst */ <br>     int cit; <br> <br>     if (lst==NULL) <br>       return 0;    /* well it is sort of 0 */ <br>     pit = lst-&gt;pitNext; <br>     cit = 0; <br>     while(pit!=lst) <br>        {  cit++; <br>           pit = pit-&gt;pitNext; <br>        } <br>     return cit; <br>  } /* List_Card */ <br> <br>  /*------------------------------------------------------------------ <br>  | Check return code <br>   -------------------------------------------------------------------*/ <br>  BOOL APIENTRY List_IsOK(LIST lst) <br>  {  if(lst==NULL) <br>       return FALSE;       /* well it is sick ain't it! */ <br>     return lst-&gt;bOK; <br>  } /* List_IsOK */ <br> <br>  /*------------------------------------------------------------------ <br>  | Set return code to good <br>   -------------------------------------------------------------------*/ <br>  void APIENTRY List_MakeOK(LIST lst) <br>  {  if(lst==NULL) <br>       return; <br>     lst-&gt;bOK = TRUE; <br>  } /* List_MakeOK */ <br> <br>  BOOL APIENTRY List_Check(LIST lst) <br>  { LIST pel; <br>    BOOL bOK; <br>    /*----------------------------------------------------------------- <br>    | Check the anchor block has the Anchor flag set. <br>    | Run through the LIST using the Anchor flag (which should be FALSE) <br>    | to mark where we have been (to test for loops in the chain) <br>    | and carry on until we see the Anchor flag again.  Check that this <br>    | is the anchor block that we started from.  Now do another pass <br>    | turning the Anchor flags off again and checking the Prev pointers. <br>     -------------------------------------------------------------------*/ <br>    if(lst==NULL) return FALSE;  /* Should we trap?  Arguable */ <br>    bOK = lst-&gt;bAnchor; <br>    pel = lst-&gt;pitNext; <br>    while(! pel-&gt;bAnchor) <br>    { pel-&gt;bAnchor = TRUE; <br>      pel = pel-&gt;pitNext; <br>    } <br>    bOK = bOK &amp;&amp; (pel==lst); <br>    if(bOK) <br>    { /* Turn all the bAnchor flags off */ <br>      pel = lst; <br>      do <br>      { pel-&gt;bAnchor = FALSE; <br>        bOK = bOK &amp; (pel-&gt;pitNext-&gt;pitPrev==pel); <br>        pel = pel-&gt;pitNext; <br>      } while (pel!=lst); <br>      lst-&gt;bAnchor = TRUE;  /* except the real one */ <br>    } <br>    else <br>    { /* just turn off those that we set on */ <br>      pel = lst-&gt;pitNext; <br>      while (pel-&gt;bAnchor) <br>      { pel-&gt;bAnchor = FALSE; <br>        pel = pel-&gt;pitNext; <br>      } <br>      lst-&gt;bAnchor = TRUE; <br>    } <br>    return bOK; <br>  } /* List_Check */ <br> <br> <br>  void APIENTRY List_Recover(PLIST plst) <br>  {  LIST Last, P,Q; <br>     BOOL OK; <br>    /* For no particular reason we presume that the forward chain <br>       is good and reconstruct the back chain from it.  A better <br>       algorithm would do the kind of things that List_Check does <br>       to figure out where the problems lie.  This just steps along <br>       until it sees either an address that it has already seen or <br>       else the anchor block.  (It's an n-squared algorithm). <br>       It links the last good block found back to the anchor and <br>       fixes all the Anchor flags. <br>    */ <br>    if (plst==NULL) return; <br>    if (*plst==NULL) <br>    {  *plst = List_Create(); <br>       return; <br>    } <br>    (*plst)-&gt;bAnchor = TRUE; <br>    P = (*plst)-&gt;pitNext; <br>    Last = *plst; <br>    for (; ; ) <br>    {  if (P==*plst) break; <br>       Last = P; <br>       if (P-&gt;pitNext!=*plst) <br>       {   OK = TRUE; <br>           Q = *plst; <br>           for (; ; ) <br>           {   OK &amp;= (P-&gt;pitNext!=Q); <br>               if (Q==P) break; <br>               Q = Q-&gt;pitNext; <br>           } <br>           if (!OK) break; <br>       } <br>       P = P-&gt;pitNext; <br>    } <br>    P = *plst; <br>    while (P!=Last) <br>    {  P-&gt;pitNext-&gt;pitPrev = P; <br>       P-&gt;bAnchor = FALSE; <br>       P = P-&gt;pitNext; <br>    } <br>    Last-&gt;pitNext = *plst; <br>    (*plst)-&gt;pitPrev = Last; <br>    (*plst)-&gt;bAnchor = TRUE; <br>    (*plst)-&gt;bOK = TRUE;   /* Here's hoping! */ <br>  } /* List_Recover */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
