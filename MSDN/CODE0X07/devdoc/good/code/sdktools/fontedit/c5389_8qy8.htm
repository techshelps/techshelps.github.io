<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONTCHAR.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5390"></a>FONTCHAR.C</h2>
<pre><code>#include "windows.h" <br>#include &lt;windowsx.h&gt; <br>#include "fontedit.h" <br>#include "fcntl.h" <br>#include &lt;stdio.h&gt; <br> <br>/****************************************************************************/ <br>/*              Shared Variables                                            */ <br>/****************************************************************************/ <br> <br>POINT SnapPointToGrid(POINT Pt); <br>LONG  APIENTRY FontEditWndProc(HWND, WORD, WPARAM, LONG); <br>BOOL  APIENTRY AboutDlg( <br>HWND   hDlg, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>); <br>BOOL   NewFile;                         /* flag indicating that NEW menu <br>                                           item was selected */ <br>extern DLGPROC lpHeaderProc;            /* Pointer to Dialog Box Procedure */ <br>extern DLGPROC lpReSizeProc;            /* Pointer to Dialog Box Procedure */ <br>extern DLGPROC lpWidthProc;             /* Pointer to Dialog Box Procedure */ <br> <br>extern FontHeaderType font;             /* Structure of Font File Header */ <br>extern CHAR matBox [wBoxLim] [kBoxLim]; /* array to hold Box */ <br>extern HCURSOR hCross;                  /* handle to "+" shaped cursor(displayed <br>                                           when in ROW or COLUMN menus */ <br>extern BOOL fReadOnly; <br>extern HANDLE hInst;                    /* Module Handle */ <br>extern HBRUSH hbrBackGround; <br>extern HWND hFont; <br>extern HWND hBox; <br>extern RECT rectWin;                    /* Client Rectangle */ <br>extern BOOL fLoaded;                    /* Set if a file loaded */ <br>extern BOOL fChanged;                   /* Anything has changed */ <br>extern BOOL fEdited;                    /* This character changed */ <br>extern DWORD kBox;                       /* height of character */ <br>extern DWORD wBox;                       /* Width of character */ <br>extern DWORD kStuff;                     /* Width of Show Header */ <br>extern INT  swH;                        /* Position in Show Window 0-100 */ <br>extern BYTE iChar;                      /* Character being edited */ <br>extern BYTE jChar;                      /* Last Char. of edit block */ <br>extern CHAR szNewFile[];                /* Name of New File */ <br>extern CHAR szFontFile[];               /* Name of Font File */ <br>extern CHAR szFontFileFull[];               /* Name of Font File */ <br>extern CHAR szFileNameTemp[]; <br>extern CHAR *szFileNameSave; <br>extern INT cSysHeight; <br> <br>extern CHAR *vrgsz[];                    /* total number of strings */ <br>extern OFSTRUCT ofstrFile; <br>extern CHAR szExt[];                    /* default extension */ <br>extern CHAR szAppName[]; <br>extern CHAR szSCC[]; <br>extern HCURSOR hOldCursor;              /* handle to old arrow shaped cursor */ <br>/****************************************************************************/ <br>/*                      Local Variables                                     */ <br>/****************************************************************************/ <br> <br>HBRUSH hbrWhite; <br>HBRUSH hbrBlack; <br>HBRUSH hbrGray; <br>HBRUSH hbrDkGray; <br>HBRUSH hNullBrush; <br>HPEN hWhitePen; <br>DWORD colors[3] = {WHITENESS, BLACKNESS, PATCOPY}; <br> <br> <br>CHAR matBackup [wBoxLim] [kBoxLim];     /* Backup for UNDO */ <br>DWORD wBoxBackup; <br> <br>LONG scale = 7;/* height/width of squares in box */ <br>WORD cursor = 0;/* Add/Del cursor */ <br> <br>BOOL fAll = TRUE;/* Redraw all if TRUE */ <br>POINT ptBox = {10, 5};/* where edit box is */ <br> <br>RECTrectRubber;/* Rubber banding rectangle */ <br>HDChDst;/* Rubber banding dc */ <br> <br>POINT ptA;/* Start of draw/rectangle */ <br>POINT ptB;/* End of rectangle */ <br>POINT ptC;/* Current square */ <br>CHAR colorA;/* Color at/under point A */ <br>DWORD newWidth;/* Width set in WIDER option */ <br>BOOL FillingRect = FALSE; <br>BOOL fRubberBanding = FALSE;/* flag indicating if rubberbanding in <br>                                   progress for row/column add/delete */ <br>BOOL fStartRubberBand = FALSE;  /* flag indicating that rubberbanding <br>                                   can start */ <br>BOOL fCaptured = FALSE;/* set if mouse is caputred */ <br>BOOL fJustZapped = FALSE;/* Set on row/col add/delete */ <br>RECT FontRect;/* rectangle bounding font pattern */ <br> <br>/****************************************************************************/ <br>/*                      Local Functions                                     */ <br>/****************************************************************************/ <br> <br>VOID ClearFill(DWORD col, DWORD row, WORD mode); <br>VOID FontEditCommand(HWND hBox, WORD id); <br>VOID BoxRestore(VOID); <br>VOID CharRectDimensions(LPRECT Rect); <br>VOID BoxPaint(VOID); <br>VOID DrawBox(HDC, DWORD, DWORD, DWORD, DWORD, INT, DWORD); <br>VOID PASCAL DrawRubberBand(HDC hDst, LPRECT lpRect, DWORD rop); <br>VOID FontEditPaint(HWND hBox, HDC hDC); <br>BOOL CheckSave(VOID); <br>VOID DupCol(DWORD col, DWORD row); <br>VOID DupRow(DWORD col, DWORD row); <br>VOID ZapCol(DWORD col, DWORD row); <br>VOID ZapRow(DWORD col, DWORD row); <br>VOID AddDel(DWORD col, DWORD row, WORD mode); <br>VOID MouseInBox(HWND hBox, WORD message, POINT ptMouse); <br>VOID BoxBackup(VOID); <br>VOID ReadRect(VOID); <br> <br>/*****************************************************************************/ <br>VOID <br>BoxPaint( <br>VOID <br>)      /* Our call to FontEditPaint */ <br>{ <br>HDC hDC; <br> <br>hDC = GetDC(hBox); <br>FontEditPaint(hBox,  hDC); <br>ReleaseDC(hBox, hDC); <br>if (fRubberBanding) <br>DrawRubberBand(hDst, &amp;rectRubber, R2_XORPEN); <br>} <br> <br> <br>/****************************************************************************** <br> * FontEditPaint(hBox, hDC) <br> * <br> * purpose: calculates coordinates for text in main window and repaints edit <br> *          box,small character boxes and text <br> * <br> * params:  HWND hBox : handle to main window <br> *          HDC hDC   I handle to display context <br> * returns: none <br> * <br> * side effects:  alters matBox (global 2-d array with ready pixel info. on <br> *                currently displayed box) <br> *****************************************************************************/ <br>VOID <br>FontEditPaint( <br>HWND hBox, <br>HDC hDC <br>) <br>{ <br>CHAR szTemp[20]; <br>DWORD len, yText, xText; <br> <br>if (!fLoaded)               /* Must load font first */ <br>return; <br> <br>/* Here the application paints its window. */ <br>if (fAll) {               /* Draw box setting */ <br>GetClientRect(hBox, (LPRECT)&amp;rectWin); <br>scale = (rectWin.bottom-rectWin.top-kStuff-20) / (kBox+1); <br>scale = min(scale, (min(320, rectWin.right - rectWin.left) -  <br>90) / ((int)wBox + 1)); <br>scale = max(scale, 4); <br>xText = ptBox.x + scale * wBox + 16; <br> <br>SelectObject(hDC, hbrDkGray); <br>Rectangle(hDC, <br>    ptBox.x - 2, <br>    ptBox.y - 2, <br>    ptBox.x + 3 + wBox * scale, <br>    ptBox.y + 5 + kBox * scale); <br>SelectObject(hDC, hbrGray); <br> <br>Rectangle(hDC,          /* Surround for font displays */ <br>    xText, <br>    ptBox.y - 2, <br>    xText + wBox + 8, <br>    ptBox.y + 3 + kBox * 2 + font.ExtLeading); <br> <br>/* Now put up the text */ <br>yText = 14 + 2 * kBox + font.ExtLeading; <br>len = (DWORD) sprintf(szTemp, vszCHAR, iChar); <br>TextOut(hDC, xText, yText, (LPSTR)szTemp, len); <br>len = (DWORD) sprintf(szTemp, vszWIDTH, wBox); <br>TextOut(hDC, xText, yText + cSysHeight, (LPSTR)szTemp, len); <br>len = (DWORD) sprintf(szTemp, vszHEIGHT, kBox); <br>TextOut(hDC, xText, yText + cSysHeight + cSysHeight,  <br>(LPSTR)szTemp, len); <br>} <br> <br>/* Draw Character Box */ <br>DrawBox(hDC, ptBox.x, ptBox.y, wBox, kBox, scale, 1); <br> <br>/* Draw small character */ <br>xText = ptBox.x + scale * wBox + 16; <br>DrawBox(hDC, <br>    xText + 4, <br>    ptBox.y, <br>    wBox, <br>    kBox, <br>    1, 0); <br> <br>/* Draw another small character to show leading */ <br>DrawBox(hDC, <br>    xText + 4, <br>    ptBox.y + kBox + font.ExtLeading, <br>    wBox, <br>    kBox, <br>    1, 0); <br>fAll = TRUE; <br>} <br> <br> <br>/****************************************************************************** <br> * DrawBox(hDC, xChar, yChar, wChar, kChar, scale, htSep) <br> * <br> * purpose: draws the edit box for the character being edited and colors the <br> *          grid squares according to the pixels set for the character. <br> * <br> * params:  HDC hDC         : handle to display context <br> *          DWORD xChar      : x-location of char box. <br> *          DWORD yChar      : y-location of char box <br> *          DWORD wChar      : width of char box <br> *          DWORD kChar      : height of char <br> *          INT   wScale     : Scale of the squares. <br> *          DWORD htSep      : height of square separators <br> * <br> * returns: none <br> * <br> * side effects:  alters matBox (global 2-d array with ready pixel info. on <br> *                currently displayed box) <br> *****************************************************************************/ <br>VOID <br>DrawBox( <br>HDC hDC, <br>DWORD xChar,                             /* x-location of char. */ <br>DWORD yChar,                             /* y-location of char. */ <br>DWORD wChar,                             /* width of char. */ <br>DWORD kChar,                             /* height of char */ <br>INT   wScale, /* scale of the squares. */ <br>DWORD htSep                              /* hgt of square separators */ <br>) <br>/* draw a character of separate squares of height 'scale' with sep. 'htSep' */ <br>{ <br>DWORD i, j, sep; <br> <br>if (fAll) {               /* redraw them all */ <br>    for (j = 0; j &lt; kChar; j++) { <br>sep = (j &gt;= font.Ascent) ? htSep : 0; <br>for (i = 0; i &lt; wChar; i++) { <br>    if (wScale == 1) <br>SetPixel(hDC, xChar + i, yChar + j, <br>matBox[i][j] == TRUE ? BLACK : WHITE); <br>    else <br>PatBlt(hDC, <br>xChar + wScale * i, <br>yChar + wScale * j + sep, <br>wScale - htSep, <br>wScale - htSep, <br>colors[matBox[i][j] == TRUE ? 1 : 0]); <br>} <br>    } <br>} <br>else {/* redraw one just flipped */ <br>    if (wScale == 1) <br>SetPixel(hDC, <br>xChar + ptC.x, <br>yChar + ptC.y, <br>matBox[ptC.x][ptC.y] == TRUE ? BLACK : WHITE); <br>    else { <br>sep = (((DWORD) ptC.y &gt;= font.Ascent) ? htSep : 0L); <br>SelectObject(hDC, hbrGray); <br>PatBlt(hDC, <br>xChar + wScale * ptC.x, <br>yChar + wScale * ptC.y + sep, <br>wScale - htSep, <br>wScale - htSep, <br>colors[matBox[ptC.x][ptC.y]]); <br>    } <br>} <br> <br>} <br> <br> <br>/****************************************************************************** <br> * FontEditCommand(hBox, id) <br> * <br> * purpose: interprets menu id and calls appropriate function to do the task <br> * <br> * params:  HWND hBox : handle to main window <br> *          WORD id   : menu command id <br> * returns: none <br> * <br> * side effects: plenty <br> * <br> *****************************************************************************/ <br>VOID <br>FontEditCommand( <br>HWND hBox, <br>WORD id <br>) <br>{ <br>CHAR * szError;                 /* String for error messages */ <br>LONG w;  <br>DWORD y, i, j; <br>BOOL fRepaint = FALSE; <br>HMENU hMenu; <br>DLGPROC lpprocAboutDlg; <br>MSG message; <br> <br>szError = "";               /* No Errors yet */ <br> <br>switch (id) { <br>    case FONT_EXIT: <br>if (!CheckSave())    /* See if any files need saving */ <br>break; <br>/* Window's being destroyed. */ <br>if (fLoaded)         /* 4/8/87 Linsh added */ <br>DeleteGlobalBitmap(); /* Get rid of memory DC */ <br>PostQuitMessage(0);  /* Cause application to be terminated */ <br>break; <br> <br>    case FONT_ABOUT: <br>lpprocAboutDlg = (DLGPROC)AboutDlg; <br>DialogBox (hInst, vszABOUT, hBox, lpprocAboutDlg); <br>FreeProcInstance (lpprocAboutDlg); <br>break; <br> <br>    case FONT_LOAD:             /*  Check File Name  */ <br>    case FONT_NEW : <br>if (!CheckSave())       /*  See if current font needs saving */ <br>return; <br>/* to prevent scrambling of Show window chars, Bring back Show <br>        ** window to parent window's client area before invoking the dialog */ <br> <br>if (CommDlgOpen(hBox,&amp;ofstrFile,szNewFile,szExt,szFontFile,id) <br>== FALSE) { <br> <br>InvalidateRect(hFont, (LPRECT)NULL, FALSE); <br>UpdateWindow(hFont); <br>return; <br>} <br>/* else drop thru */ <br> <br>    case FONT_START:/*  Here if file name passed as argument */ <br>InvalidateRect(hFont, (LPRECT)NULL, FALSE); <br>UpdateWindow(hFont); <br> <br>szError = FontLoad (szNewFile, &amp;ofstrFile); <br> <br>/* Hack : needed to remove umwanted WM_MOUSEMOVE messages from the  <br>         * queue. <br>         * Apparently, Windows needs to reposition the mouse after a dialog <br>         * is ended with a mouse double-click (releases mouse capture?) for <br>         * which a couple of WM_MOUSEMOVEs may get sent to parent app. <br>         * These mess with the edit box below the dialog if they happen to  <br>         * overlap. <br>         */ <br>PeekMessage((LPMSG) &amp;message, hBox, WM_MOUSEMOVE, WM_MOUSEMOVE, <br>    PM_REMOVE); <br> <br>if (fLoaded)    /* If loaded then do a few things */ { <br>    jChar = iChar = 65;                 /* Show an A */ <br>    if ((BYTE)iChar &gt; (BYTE)font.LastChar) <br>jChar = iChar = font.FirstChar; /* .. if we can */ <br>    swH = 15;                   /* Good bet to make A visible */ <br>    fEdited = fChanged = FALSE; <br>    ResizeShow();               /* Set Box to proper size */ <br>    ScrollFont();               /* Set thumb */ <br>    CharToBox(iChar); <br>} <br>FontRename(szError); <br>SetFocus(hBox); <br>return; <br> <br>    case FONT_SAVE: <br>if (!NewFile) { <br>    if (fLoaded &amp;&amp; fChanged) { <br>lstrcpy((LPSTR)szNewFile, (LPSTR)szFontFileFull); <br>BoxToChar(iChar);           /* Just in case */ <br>szError = FontSave (szNewFile, &amp;ofstrFile); <br>FontRename(szError);        /* Rename or Print Error */ <br>return; <br>    } <br>    else <br>return; <br>} <br>/* else file has been opened by selecting NEW... on menu. <br>         * Fall thro' and bring up SaveAs dialog minus default <br>         * filename in edit window */ <br> <br>    case FONT_SAVEAS: <br>BoxToChar(iChar);               /* Just in case */ <br> <br>if (CommDlgSaveAs (hInst, hBox, &amp;ofstrFile, szNewFile, szExt, <br>szFontFile) == TRUE) { <br> <br>    szError = FontSave (szNewFile, &amp;ofstrFile); <br>    FontRename (szError);          /* Rename or Print Error */ <br>} <br> <br>/* to prevent scrambling of Show window chars, <br>           repaint show window after dialog is brought down */ <br>InvalidateRect (hFont, (LPRECT)NULL, TRUE); <br>UpdateWindow (hFont); <br>return; <br> <br>    case FONT_HEADER: <br>/* to prevent scrambling of Show window chars, <br> * repaint show window after dialog is invoked */ <br>DialogBox(hInst, (LPSTR)vszDHeader, hBox, lpHeaderProc); <br>InvalidateRect(hFont, (LPRECT)NULL, TRUE); <br>UpdateWindow(hFont); <br>return; <br> <br>    case FONT_RESIZE: <br>/* to prevent scrambling of Show window chars, <br>   repaint show window after dialog is brought down */ <br>if (DialogBox(hInst, (LPSTR)vszDResize, hBox, lpReSizeProc)) { <br>    /* BoxToChar(iChar);*/ /* save current before resizing */ <br>    ResizeShow();       /* New Font Display Size */ <br>    CharToBox(iChar);               /* New Box display */ <br>} <br>InvalidateRect(hFont, (LPRECT)NULL, TRUE); <br>UpdateWindow(hFont); <br>return; <br> <br>    case FONT_COPY:                     /* Copy to Clipboard */ <br>BoxToChar(iChar);               /* Just in case */ <br>ToClipboard(iChar, wBox, kBox); <br>break; <br> <br>    case FONT_PASTE:            /* Paste in Character form Clipboard */ <br>BoxBackup();            /* In case we change our minds */ <br>ptA.x = ptA.y = 0; <br>wBox = ClipboardToBox(ptA, wBox, kBox, TRUE); <br>fRepaint = TRUE; <br>break; <br> <br>    case WIDER_LEFT: <br>    case WIDER_RIGHT: <br>    case WIDER_BOTH: <br>    case NARROWER_LEFT: <br>    case NARROWER_RIGHT: <br>    case NARROWER_BOTH: <br>    case WIDTH: <br>w = newWidth = wBox; <br>if (font.Family &amp; 1)            /* Variable width or else */ { <br>    switch (id) { <br>case WIDER_BOTH: <br>    w++; <br>case WIDER_LEFT: <br>case WIDER_RIGHT: <br>    w++; <br>    break; <br>case NARROWER_BOTH: <br>    w--; <br>case NARROWER_LEFT: <br>case NARROWER_RIGHT: <br>    w--; <br>    break; <br>case WIDTH: <br>    if (DialogBox(hInst, <br>(LPSTR)vszDWidth, hBox, lpWidthProc)) <br>w = newWidth; <br>    break; <br>    } <br> <br>    if (w &lt; 0 || w &gt;= wBoxLim) { <br>MessageBox(hBox, <br>(LPSTR)vszEdLimits0To64, <br>(LPSTR)szAppName, <br>MB_OK | MB_ICONASTERISK); <br>break;                  /* Out of range! quit */ <br>    } <br>    if (w &gt; (LONG) font.MaxWidth) { <br>if (IDOK == MessageBox(hBox, <br>    (LPSTR)vszMaxWidthIncrease, <br>    (LPSTR)szAppName, <br>    MB_OKCANCEL | MB_ICONQUESTION)) <br>    font.MaxWidth = (WORD)w; <br>else <br>    break; <br>    } <br>    BoxBackup();                /* In case we change our minds */ <br>    wBox = (WORD)w;             /* Reset width */ <br>    fRepaint = TRUE;            /* Signal redraw */ <br>    switch (id) { <br>    case WIDER_LEFT: <br>DupCol(0, kBoxLim - 1); <br>for (y = 0; y &lt; kBoxLim; y++) <br>    matBox[0][y] = FALSE;       /* Clear left column */ <br>break; <br>    case WIDER_BOTH:            /* Shift character one right */ <br>DupCol(0, kBoxLim - 1); <br>for (y = 0; y &lt; kBoxLim; y++) <br>    matBox[wBox -1][y] = FALSE; /* Clear right column */ <br>for (y = 0; y &lt; kBoxLim; y++) <br>    matBox[0][y] = FALSE;       /* Clear left column */ <br>break; <br>    case NARROWER_LEFT: <br>    case NARROWER_BOTH:/* Shift character one left */ <br>if (wBox) {/* .. unless width is already 0 */ <br>    for (j = 0; j &lt;= kBox - 1; j++) <br>for (i = 0; i &lt;= wBox - 1; i++) <br>    matBox[i][j] = matBox[i + 1][j]; <br>    break; <br>} <br>    } <br>} <br>else { <br>    MessageBox(hBox, <br>    (LPSTR)vszCannotChangeWidth, <br>    (LPSTR)szAppName, <br>    MB_OK | MB_ICONASTERISK); <br>} <br>break; <br> <br>    case ROW_ADD: <br>    case ROW_DEL: <br>    case COL_ADD: <br>    case COL_DEL: <br>/* set cursor to "+" shaped cursor */ <br>SetCapture (hBox); /* so that cursor doesn't get restored <br>      before we are done */ <br>hOldCursor = SetCursor (LoadCursor (NULL, IDC_CROSS)); <br>fCaptured = TRUE; <br>cursor = id; <br>break; <br> <br>    case BOX_CLEAR: <br>    case BOX_FILL: <br>    case BOX_INV: <br>    case BOX_HATCH: <br>    case BOX_LEFTRIGHT: <br>    case BOX_TOPBOTTOM: <br>    case BOX_COPY: <br>    case BOX_PASTE: <br>/* Get one o' da funky cursors */ <br>SetCapture(hBox); <br>hOldCursor = SetCursor(LoadCursor(hInst, MAKEINTRESOURCE(id))); <br>fStartRubberBand = TRUE; <br>CharRectDimensions((LPRECT)&amp;FontRect); <br>cursor = id; <br>break; <br> <br>    case BOX_REFRESH:           /* Go get old version of character */ <br>BoxBackup();            /* In case we change our minds */ <br>CharToBox(iChar); <br>hMenu = GetMenu(hBox); <br>EnableMenuItem(hMenu, BOX_UNDO, MF_ENABLED);    /* Can Unrefresh! */ <br>break; <br>    case BOX_UNDO: <br>BoxRestore(); <br>hMenu = GetMenu(hBox); <br>EnableMenuItem(hMenu, BOX_REFRESH, MF_ENABLED); <br>fRepaint = TRUE; <br>break; <br>} <br>if (fRepaint) { <br>fEdited = fChanged = TRUE; <br>InvalidateRect(hBox, (LPRECT)NULL, TRUE); <br>} <br>} <br> <br> <br>VOID <br>CharRectDimensions( <br>LPRECT Rect <br>) <br>/* returns the dimensions of the edit box */ <br>{ <br>Rect-&gt;top    =  ptBox.y; <br>Rect-&gt;bottom =  ptBox.y + (kBox) * (scale); <br>Rect-&gt;left   =  ptBox.x; <br>Rect-&gt;right  =  ptBox.x + (wBox) * (scale); <br>} <br> <br> <br>/****************************************************************************** <br> * BOOL  APIENTRY WidthProc(hDial, message, wParam, lParam) <br> * <br> * purpose: dialog function for Width menu function <br> * <br> * params:  same as for all dialog fns. <br> * <br> * side effects: changes Box width variable <br> * <br> *****************************************************************************/ <br>BOOL  APIENTRY  <br>WidthProc( <br>HWND   hDial, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>) <br>{ <br>INT i; <br>BOOL fOk; <br> <br>UNREFERENCED_PARAMETER(lParam); <br> <br>switch (message) { <br>default: <br>return FALSE; <br>case WM_INITDIALOG: <br>SetDlgItemInt(hDial, BOX_WIDTH, newWidth, FALSE); <br>break; <br> <br>case WM_COMMAND: <br>switch (LOWORD(wParam)) { <br>case IDOK: <br>fChanged = TRUE; <br>i = GetDlgItemInt(hDial, BOX_WIDTH, (LPBOOL)&amp;fOk, FALSE); <br>if (fOk &amp;&amp; i &lt; wBoxLim) <br>newWidth = i; <br>else <br>ErrorBox(hDial, vszWidthOutOfBounds); <br> <br>case IDCANCEL: <br>EndDialog(hDial, LOWORD(wParam) != IDCANCEL); <br>break; <br> <br>default: <br>break; <br>} <br>} <br>return TRUE; <br>} <br> <br> <br>/****************************************************************************** <br> * BOOL CheckSave() <br> * <br> * purpose: checks if font is dirty and prompts user to save font. If yes, <br> *          edit box is saved and file save function is called. <br> * <br> * params:  none <br> * <br> * returns: TRUE : font has been changed <br> *          FALSE: font untouched <br> * <br> * side effects: file dirty flag is reset. <br> * <br> *****************************************************************************/ <br>BOOL  <br>CheckSave( <br>VOID <br>) <br>{ <br>CHAR * szError;                 /* String for error messages */ <br>CHAR szMessage[MAX_STR_LEN+MAX_FNAME_LEN]; <br> <br>/* Check if anything changed */ <br>if (fLoaded &amp;&amp; fChanged &amp;&amp; (!fReadOnly)) { <br>lstrcpy((LPSTR)szNewFile, (LPSTR)szFontFileFull); <br>DlgMergeStrings(szSCC, szNewFile, szMessage); <br>switch (MessageBox(hFont, <br>    (LPSTR)szMessage, <br>    (LPSTR)szAppName, <br>    MB_YESNOCANCEL | MB_ICONQUESTION)) { <br>case IDYES: <br>BoxToChar(iChar);            /* Just in case */ <br>szError = FontSave (szNewFile, &amp;ofstrFile); <br>FontRename(szError);            /* Rename or Print Error */ <br>case IDNO: <br>return TRUE; <br>case IDCANCEL: <br>return FALSE; <br>} <br>} <br>return TRUE; <br>} <br> <br> <br>/****************************************************************************** <br> * MouseInBox(hBox, message, ptMouse) <br> * <br> * purpose: do edit operation depending on currently active menu command <br> * <br> * params: HWND hBox       : handle to main window <br> *         WORD message    : Message retrieved by main window's window fn. <br> *         POINT ptMouse   : current mouse coordinates <br> * returns: none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box). Also assigns values to ptA and ptB <br> *****************************************************************************/ <br>VOID <br>MouseInBox( <br>HWND hBox, <br>WORD message, <br>POINT ptMouse <br>) <br>{ <br>POINT pt; <br>BOOL fRepaint = FALSE; <br>short nct = 0 ; <br> <br>pt = SnapPointToGrid(ptMouse); <br> <br>if (pt.x &gt;= 0L &amp;&amp; pt.y &gt;= 0L &amp;&amp; <br>    ((DWORD)pt.x) &lt; wBox &amp;&amp; ((DWORD)pt.y) &lt; kBox) { <br>fEdited = fChanged = TRUE; <br>ptC.x = pt.x; <br>ptC.y = pt.y;/* Current square */ <br>if (message == WM_LBUTTONDOWN) <br>BoxBackup();/* Set up for UNDO */ <br>switch (cursor) { <br>case BOX_COPY: <br>case BOX_PASTE: <br>case BOX_CLEAR: <br>case BOX_FILL: <br>case BOX_INV: <br>case BOX_HATCH: <br>case BOX_LEFTRIGHT: <br>case BOX_TOPBOTTOM: <br>ptA.x = pt.x; <br>ptA.y = pt.y;/* save anchor point */ <br>/* save color under marker */ <br>colorA = matBox[pt.x][pt.y]; <br>fAll = FALSE; <br> <br>fRepaint = TRUE; <br>break; <br>default: <br>AddDel(pt.x, pt.y, cursor); <br>fRepaint = TRUE; <br>cursor = FALSE; <br>break; <br>case FALSE: <br>switch (message) { <br>case WM_LBUTTONDOWN:/*invert */ <br>nct =1 ; <br>colorA = (matBox[pt.x][pt.y] ^= TRUE); <br>break; <br> <br>case WM_LBUTTONUP: <br>break; <br> <br>case WM_MOUSEMOVE: <br>matBox[pt.x][pt.y] = colorA;    /* paint */ <br>break; <br>} <br>/* <br>if( nct != 0 ) <br>{ <br>*/ <br>fRepaint = TRUE; <br>fAll = FALSE;               /* Limited redraw */ <br>/* <br>} <br>*/ <br>break; <br>} <br>if (fRepaint) { <br>BoxPaint(); <br>return; <br>} <br>} <br>cursor = FALSE; <br>} <br> <br> <br>/****************************************************************************** <br> * ReadRect(ptMouse) <br> * <br> * purpose:      defines the rectangular region in edit box to be filled by <br> *               fill menu command  by fixing top left (ptA) and bottom right <br> *               (ptB) coordinates of rect. <br> * <br> * params: <br> * <br> * assumes:that rectRubber is normalized (eg, left &lt; right, botton &gt; top) <br> * <br> * returns:    none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box). Also assigns values to ptA and ptB <br> *****************************************************************************/ <br>VOID <br>ReadRect( <br>) <br>{ <br> <br>ptA.x = (rectRubber.left-(ptBox.x+1))   / scale; <br>ptA.y = (rectRubber.top-(ptBox.y+1))    / scale; <br>ptB.x = (rectRubber.right-(ptBox.x-2))  / scale - 1; <br>ptB.y = (rectRubber.bottom-(ptBox.y-2)) / scale - 1; <br> <br>if (((DWORD)ptB.x) &gt; wBox - 1) <br>    ptB.x = wBox - 1; <br>if (((DWORD)ptB.y) &gt; kBox - 1) <br>    ptB.y = kBox - 1; <br> <br>if (ptB.x &gt;= 0 &amp;&amp; ptB.y &gt;= 0) { <br>    ClearFill((DWORD)ptB.x, (DWORD)ptB.y, cursor);         <br>    BoxPaint(); <br>} <br>cursor = FALSE; <br>} <br> <br> <br>/****************************************************************************** <br> * ClearFill(col, row, mode) <br> * <br> * purpose:  fill the specified rectangular region in edit box with fill type <br> *           indicated by mode.Top left corner of rect is global(ptA) <br> * <br> * params:   DWORD row : row (of bottom right corner of rect(ptB.x)) <br> *           DWORD col : column (of bottom right corner of rect(ptB.y)) <br> *           WORD mode: action to be performed <br> * <br> * returns:  none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box) <br> *****************************************************************************/ <br>VOID <br>ClearFill( <br>DWORD col,  <br>DWORD row,  <br>WORD mode <br>) <br>{ <br>DWORD i, x, y; <br>CHAR z; <br> <br>if (col &lt; (DWORD)ptA.x) /* if points are reversed */ { <br>i = col; <br>col = ptA.x; <br>ptA.x = i; <br>}          /* flip them */ <br>if (row &lt; (DWORD) ptA.y) { <br>i = row; <br>row = ptA.y; <br>ptA.y = i; <br>}          /* flip them */ <br> <br>if (mode == BOX_LEFTRIGHT) { <br>for (x = ptA.x; x &lt;= (DWORD)((ptA.x + col) / 2); x++) <br>for (y = ptA.y; y &lt;= row; y++) { <br>z = matBox[x][y]; <br>matBox[x][y] = matBox[ptA.x + col - x][y]; <br>matBox[ptA.x + col - x][y] = z; <br>} <br>return; <br>} <br> <br>if (mode == BOX_TOPBOTTOM) { <br>for (y = ptA.y; y &lt;= ((DWORD)(ptA.y + row) / 2); y++) <br>for (x = ptA.x; x &lt;= col; x++) { <br>z = matBox[x][y]; <br>matBox[x][y] = matBox[x][ptA.y + row - y]; <br>matBox[x][ptA.y + row - y] = z; <br>} <br>return; <br>} <br> <br>if (mode == BOX_COPY) <br>BoxToClipboard(ptA, col - ptA.x + 1, row - ptA.y + 1); <br> <br>if (mode == BOX_PASTE) <br>ClipboardToBox(ptA, col - ptA.x + 1, row - ptA.y + 1, FALSE); <br> <br>for (x = ptA.x; x &lt;= col; x++) <br>for (y = ptA.y; y &lt;= row; y++) { <br>switch (mode) { <br>case BOX_CLEAR: <br>case BOX_FILL: <br>matBox[x][y] = (CHAR)(mode == BOX_FILL); <br>break; <br>case BOX_INV: <br>matBox[x][y] ^= (CHAR)TRUE; <br>break; <br>case BOX_HATCH: <br>matBox[x][y] = (CHAR)((x+y)%2 ? TRUE : FALSE); <br>break; <br>} <br>} <br>} <br> <br> <br>/****************************************************************************** <br> * AddDel(col, row, mode) <br> * <br> * purpose:  Add/Delete row/col as per mode <br> * <br> * params:   DWORD row : row <br> *           DWORD col : column <br> *           WORD mode: action to be performed <br> * <br> * returns:  none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box) <br> *****************************************************************************/ <br>VOID <br>AddDel( <br>DWORD col,  <br>DWORD row,  <br>WORD mode <br>) <br>{ <br>switch (mode) { <br>case ROW_ADD: <br>DupRow(wBox, row); <br>break; <br> <br>case ROW_DEL: <br>ZapRow(wBox, row); <br>break; <br> <br>case COL_ADD: <br>DupCol(col, kBox); <br>break; <br> <br>case COL_DEL: <br>ZapCol(col, kBox); <br>break; <br>} <br>/* restore arrow cursor */ <br>SetCursor (hOldCursor); <br>ReleaseCapture(); <br>fCaptured = FALSE; <br>fJustZapped = TRUE; <br>} <br> <br> <br>/****************************************************************************** <br> * ZapCol(col, row) <br> * <br> * purpose: delete given column in edit box. Shift cols to right given col <br> *          right. Rightmost column gets duplicated. <br> * <br> * params : DWORD col : column <br> *          DWORD row : row <br> * returns: none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box) <br> *****************************************************************************/ <br>VOID <br>ZapCol( <br>DWORD col,  <br>DWORD row <br>) <br>{ <br>DWORD x, y; <br>for (y = 0; y &lt;= row; y++) <br>for (x = col; x &lt; wBox - 1; x++) <br>matBox[x][y] = matBox[x + 1][y]; <br>for (y = 0; y &lt;= row; y++) <br>matBox[x][y] = matBox[x - 1][y]; <br>} <br> <br> <br>/****************************************************************************** <br> * ZapRow(col, row) <br> * <br> * purpose: delete given row in edit box. Shift rows below given row up. Lowest <br> *          row gets duplicated <br> * <br> * params:  DWORD col : column <br> *          DWORD row : row <br> * returns: none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box) <br> *****************************************************************************/ <br>VOID <br>ZapRow( <br>DWORD col,  <br>DWORD row <br>) <br>{ <br>DWORD x, y; <br>for (x = 0; x &lt;= col; x++) <br>for (y = row; y &lt; kBox - 1; y++) <br>matBox[x][y] = matBox[x][y + 1]; <br>for (x = 0; x &lt;= col; x++) <br>matBox[x][y] = matBox[x][y - 1]; <br>} <br> <br> <br>/****************************************************************************** <br> * DupCol(col, row) <br> * <br> * purpose: duplicate given column in edit box. Shift cols to right of given <br> *          col right <br> * <br> * params:  DWORD col : column <br> *          DWORD row : row <br> * returns: none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on </code></pre>
<p>
</p>
<pre><code>*               currently displayed box) <br> *****************************************************************************/ <br>VOID <br>DupCol( <br>DWORD col,  <br>DWORD row <br>) <br>{ <br>DWORD x, y; <br>for (x = wBox - 1; x &gt; col; x--) <br>for (y = 0; y &lt;= row; y++) <br>matBox[x][y] = matBox[x - 1][y]; <br>} <br> <br> <br>/****************************************************************************** <br> * DupRow(col, row) <br> * <br> * purpose: duplicate given row in edit box. Shift rows below given row down. <br> * <br> * params:  DWORD col : column <br> *          DWORD row : row <br> * returns: none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box) <br> *****************************************************************************/ <br>VOID <br>DupRow( <br>DWORD col,  <br>DWORD row <br>) <br>{ <br>DWORD x, y; <br>for (x = 0; x &lt;= col; x++) <br>for (y = kBox - 1; y &gt; row; y--) <br>matBox[x][y] = matBox[x][y - 1]; <br>} <br> <br> <br>/****************************************************************************** <br> * ClearBox(col, row, bb) <br> * <br> * purpose: reset all pixels in edit box (make box white) <br> * <br> * params : none <br> * <br> * returns: none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box) <br> * <br> *****************************************************************************/ <br>VOID <br>ClearBox( <br>VOID <br>)                  /* Clear edit box */ <br>{ <br>DWORD x, y; <br>for (x = 0; x &lt; wBoxLim; x++) <br>for (y = 0; y &lt; kBoxLim; y++) <br>matBox[x][y] = FALSE; <br>} <br> <br> <br>/****************************************************************************** <br> * BoxBackup() <br> * <br> * purpose:   makes a backup of pix. info. of currently displayed edit box <br> * <br> * params:    none <br> * <br> * returns:   none <br> * <br> * side effects: alters matBackup (local 2-d array with backup pixel info. <br> *               on edit box ) <br> *****************************************************************************/ <br>VOID <br>BoxBackup( <br>VOID <br>) <br>{ <br>DWORD x, y; <br>HMENU hMenu; <br> <br>hMenu = GetMenu(hBox); <br>EnableMenuItem(hMenu, BOX_UNDO, MF_ENABLED); <br>EnableMenuItem(hMenu, BOX_REFRESH, MF_ENABLED); <br>for (x = 0; x &lt; wBoxLim; x++) <br>for (y = 0; y &lt; kBoxLim; y++) <br>matBackup[x][y] = matBox[x][y]; <br>wBoxBackup = wBox; <br>} <br> <br> <br>/****************************************************************************** <br> * BoxRestore() <br> * <br> * purpose : Current edit box and backup box exchange places <br> * <br> * params  : none <br> * <br> * returns : none <br> * <br> * side effects: alters matBox (global 2-d array with ready pixel info. on <br> *               currently displayed box <br> * <br> *****************************************************************************/ <br>VOID <br>BoxRestore( <br>VOID <br>)            /* Box and Backup exchange places */ <br>{ <br>DWORD x, y, temp; <br>CHAR z; <br> <br>for (x = 0; x &lt; wBoxLim; x++) <br>for (y = 0; y &lt; kBoxLim; y++) { <br>z = matBackup[x][y]; <br>matBackup[x][y] = matBox[x][y]; <br>matBox[x][y] = z; <br>} <br>temp = wBox; <br>wBox = wBoxBackup; <br>wBoxBackup = temp; <br>} <br> <br> <br>/****************************************************************************** <br> * POINT SnapPointToGrid (Pt) <br> * <br> * purpose : Intended only for the Fill menu command where rubberbanding rect. <br> *           needs to be aligned on the grid lines. Snap the current mouse <br> *           coordinates to nearest grid intersection. <br> * <br> * params  : POINT Pt : current point mouse is over <br> * <br> * returns : POINT    : number of nearest square <br> * <br> * side effects:      : current mouse coordinate(global variable) altered to <br> *                      return value <br> * <br> *****************************************************************************/ <br>POINT  <br>SnapPointToGrid( <br>POINTPt <br>) <br>{ <br> <br>Pt.x = (Pt.x - ptBox.x) / scale; <br>if (Pt.y &gt; (scale * (font.Ascent - 1))) <br>Pt.y = Pt.y - 2;/* Allow for break in box */ <br>Pt.y = (Pt.y - ptBox.y) / scale; <br>return (Pt); <br>} <br> <br> <br>/****************************************************************************** <br> * VOID PASCAL EndRubberBandingRect() <br> * <br> * purpose: Stops rubberbanding rect for Fill menu command and cleans up <br> * <br> * params : HANDLE hDst : handle to dest. DC <br> * <br> * side effects: none <br> * <br> *****************************************************************************/ <br>VOID PASCAL  <br>EndRubberBandingRect( <br>HDC hDst  /* handle to dest. DC */ <br>) <br>{ <br>fRubberBanding = FALSE;      /* reset "in-progress" flag */ <br> <br>ReleaseDC(hBox, hDst); <br>ReleaseCapture(); <br>SetCursor(hOldCursor); <br>} <br> <br> <br>/****************************************************************************** <br> * HDC PASCAL InitialiseRubberBandingRect(hBox) <br> * <br> * purpose: Sets up rubberbanding rect for Fill menu command. <br> * <br> * params : HANDLE hDst : handle to box DC <br> * <br> * returns :handle to destination display context <br> * <br> * side effects: alters few global flags for rubberbanding <br> * <br> *****************************************************************************/ <br>HDC PASCAL  <br>InitialiseRubberBandingRect( <br>HWND hBox  /* handle to  DC  of box */ <br>) <br>{ <br>HDC hDst; <br> <br>fRubberBanding = TRUE;       /* set "in-progress" flag */ <br>fStartRubberBand = FALSE;    /* reset "start-proceedings" flag */ <br>SetCapture(hBox);            /* send all msgs to current window */ <br> <br>hDst = GetDC (hBox); <br> <br>/* select pen and fill mode for rectangle*/ <br>hWhitePen  = SelectObject(hDst, GetStockObject (WHITE_PEN)); <br>hNullBrush = SelectObject(hDst, GetStockObject (NULL_BRUSH)); <br>SetROP2(hDst, R2_XORPEN); <br> <br>return(hDst); <br>} <br> <br> <br>/****************************************************************************** <br> * VOID PASCAL DrawRubberBand() <br> * <br> * purpose: Draw rubberbanding rect for Fill menu command. <br> * <br> * params : HANDLE hDst : handle to dest. DC <br> * <br> * side effects: alters few global flags for rubberbanding <br> * <br> *****************************************************************************/ <br>VOID PASCAL  <br>DrawRubberBand( <br>HDC   hDst,                        /*  handle to dest. DC */ <br>LPRECTlpRect, <br>DWORDrop <br>) <br>{ <br>#ifdef DBG <br>charbuf[256]; <br>        SIZE        Size; <br>        static LONG cxPrev; <br>        INT         nLeftRect; <br>#endif <br> <br>SetROP2(hDst, rop); <br>Rectangle(hDst, lpRect-&gt;left,  lpRect-&gt;top, <br>lpRect-&gt;right, lpRect-&gt;bottom); <br> <br>#ifdef DBG <br>sprintf(buf, "left=%d, top=%d, right=%d, bottom=%d",  <br>lpRect-&gt;left,  lpRect-&gt;top, lpRect-&gt;right, lpRect-&gt;bottom); <br>    GetTextExtentPoint32(hDst, buf, lstrlen(buf), &amp;Size); <br>    nLeftRect = ptBox.x+scale*wBox+16 + Size.cx; <br>    if(nLeftRect &lt; cxPrev) { <br>        RECT rc; <br>        rc.left   = nLeftRect; <br>        rc.top    = 14+2*kBox+font.ExtLeading+3*cSysHeight; <br>        rc.right  = cxPrev; <br>        rc.bottom = 14+2*kBox+font.ExtLeading+3*cSysHeight + Size.cy; <br>    FillRect(hDst, &amp;rc, hbrBackGround); <br>    } <br>    cxPrev = nLeftRect; <br>TextOut(hDst, ptBox.x+scale*wBox+16, <br>      14+2*kBox+font.ExtLeading+3*cSysHeight, <br>      buf, strlen(buf)); <br>#endif <br>} <br> <br> <br>/****************************************************************************** <br> * long  APIENTRY FontEditWndProc(hBox, message, wParam, lParam) <br> * <br> * purpose: Master controller for Fontedit's all-encompassing main window <br> * <br> * params : same as for all window functions <br> * <br> * side effects: countless <br> * <br> *****************************************************************************/ <br>LONG  APIENTRY  <br>FontEditWndProc( <br>HWND   hBox, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>) <br>{ <br>PAINTSTRUCTps; <br>HMENUhMenu; <br>WORDmf; <br>POINTpt; <br>RECTBoxRect; <br> <br>switch (message) { <br>case WM_CLOSE: <br>if (!CheckSave())    /* See if any files need saving */ <br>break; <br>/* Window's being destroyed. */ <br>if (fLoaded)         /* 4/8/87 Linsh added */ <br>DeleteGlobalBitmap(); /* Get rid of memory DC */ <br>DestroyWindow(hFont); <br>DestroyWindow(hBox); <br>break; <br> <br>case WM_DESTROY: <br>PostQuitMessage(0);  /* Cause application to be terminated */ <br>break; <br> <br>case WM_QUERYENDSESSION: <br>if (CheckSave())             /* See if any files need saving */ <br>return TRUE; <br>break; <br> <br>case WM_ENDSESSION: <br>if (fLoaded) <br>DeleteGlobalBitmap();      /* Get rid of memory DC */ <br>break; <br> <br>case WM_SIZE: <br>/* Window's size is changing.  lParam contains the width <br>        ** and height, in the low and high words, respectively. <br>        ** wParam contains SIZENORMAL for "normal" size changes, <br>        ** SIZEICONIC when the window is being made iconic, and <br>        ** SIZEFULLSCREEN when the window is being made full screen. */ <br>switch (wParam) { <br>case SIZEFULLSCREEN: <br>case SIZENORMAL: <br>ResizeShow(); <br>if (kStuff != GetkStuff())/* Did it change ? */ <br>ResizeShow();           /* Yes resize again */ <br>break; <br>} <br>break; <br> <br>case WM_MOVE: /* Tell popup to move with us. */ <br>if (!IsIconic(hBox)) <br>ResizeShow(); <br>break; <br> <br>case WM_PAINT: <br>/* Time for the window to draw itself. */ <br>BeginPaint(hBox, (LPPAINTSTRUCT)&amp;ps); <br>FontEditPaint(hBox,  ps.hdc); <br>EndPaint(hBox, (LPPAINTSTRUCT)&amp;ps); <br>break; <br> <br> <br>case WM_COMMAND: <br>/* A menu item has been selected, or a control is notifying <br> * its parent.  wParam is the menu item value (for menus), <br> * or control ID (for controls).  For controls, the low word <br> * of lParam has the window handle of the control, and the hi <br> * word has the notification code.  For menus, lParam contains <br> * 0L. */ <br>FontEditCommand(hBox, LOWORD(wParam)); <br>break; <br> <br>/* Data interchange request. */ <br>case WM_CUT: <br>case WM_COPY: <br>case WM_PASTE: <br>case WM_CLEAR: <br>case WM_UNDO: <br>case WM_RENDERFORMAT: <br>case WM_RENDERALLFORMATS: <br>case WM_DESTROYCLIPBOARD: <br>case WM_DRAWCLIPBOARD: <br>break; <br>case WM_INITMENU: <br>hMenu = GetMenu(hBox);  /* Gray menu if no clipboard bitmap */ <br>mf = (WORD)(IsClipboardFormatAvailable(CF_BITMAP) ? MF_ENABLED :  <br>MF_GRAYED); <br>EnableMenuItem(hMenu, BOX_PASTE, mf); <br>EnableMenuItem(hMenu, FONT_PASTE, mf); <br>break; <br> <br>/* For each of following mouse window messages, wParam contains <br>** bits indicating whether or not various virtual keys are down, <br>** and lParam is a POINT containing the mouse coordinates.   The <br>** keydown bits of wParam are:  MK_LBUTTON (set if Left Button is <br>** down); MK_RBUTTON (set if Right Button is down); MK_SHIFT (set <br>** if Shift Key is down); MK_ALTERNATE (set if Alt Key is down); <br>** and MK_CONTROL (set if Control Key is down). */ <br> <br>case WM_LBUTTONDOWN: <br>((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br> <br>if (fStartRubberBand) { <br>/* a green signal to rubberband a rectangle for the <br> * Fill menu command rectangle now has null dimensions. <br> * Snap the current mouse point to nearest grid <br> * intersection thus defining upper left corner of <br> * rectangle */ <br> <br>if (PtInRect((LPRECT)&amp;FontRect, pt)) { <br>pt = SnapPointToGrid(pt); <br>rectRubber.top    =  pt.y   *scale+ptBox.y+1; <br>rectRubber.bottom = (pt.y+1)*scale+ptBox.y-2; <br>rectRubber.left   =  pt.x   *scale+ptBox.x+1; <br>rectRubber.right  = (pt.x+1)*scale+ptBox.x-2; <br> <br>hDst = InitialiseRubberBandingRect(hBox); <br>DrawRubberBand(hDst, &amp;rectRubber, R2_XORPEN); <br>} <br>else { <br>fStartRubberBand = fRubberBanding = FALSE; <br>ReleaseCapture(); <br>} <br>} <br>/* do operation depending upon current active command, <br> * but not if we just added/deleted a row/column. */ <br>if (!fJustZapped) { <br>if (fStartRubberBand) { <br>pt.x *= scale; <br>pt.y *= scale; <br>MouseInBox(hBox, message, pt); <br>} <br>else { <br>((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br>MouseInBox(hBox, message, pt); <br>} <br>} <br> <br>break; <br> <br>case WM_LBUTTONUP:               /* Get other corner of rectangle */ <br>fJustZapped = FALSE; <br>if (fRubberBanding) { <br>/* if rubberbanding for the Fill menu command, <br> * terminate proceedings and clean up */ <br>DrawRubberBand(hDst, &amp;rectRubber, R2_NOT); <br>EndRubberBandingRect(hDst); <br>if (cursor) { <br>ReadRect(); <br>} <br>} <br>if (fCaptured ) { <br>/* if cursor is + shaped, restore it to default */ <br>ReleaseCapture(); <br>SetCursor (hOldCursor); <br>} <br>break; <br> <br>case WM_RBUTTONDOWN: <br>case WM_RBUTTONUP: <br>break; <br> <br>case WM_MOUSEMOVE:                      /* If mouse is down */ <br> <br>((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br> <br>if ((fRubberBanding) &amp;&amp; (wParam &amp; MK_LBUTTON)) { <br>/* if any of Fill menu commands is active <br>** (AND the mouse key depressed) draw a rubberband <br>** a rectangle with the mouse movements */ <br> <br>/* get current square number */ <br>pt = SnapPointToGrid(pt); <br> <br>/* calculate grid for new square */ <br>BoxRect.top    =  pt.y   *scale+ptBox.y+1; <br>BoxRect.bottom = (pt.y+1)*scale+ptBox.y-2; <br>BoxRect.left   =  pt.x   *scale+ptBox.x+1; <br>BoxRect.right  = (pt.x+1)*scale+ptBox.x-2; <br> <br>/* erase old mark */ <br>DrawRubberBand(hDst, &amp;rectRubber, R2_NOT); <br> <br>/* limit rubber band to box */ <br>if (BoxRect.right &gt; (LONG) (scale * wBox + ptBox.x)) <br>BoxRect.right = scale * wBox + ptBox.x; <br>if (BoxRect.bottom &gt; (LONG) (scale * kBox + ptBox.y)) <br>BoxRect.bottom = scale * kBox + ptBox.y; <br>if (BoxRect.top &lt; 0) <br>BoxRect.top = 1; <br>if (BoxRect.left &lt; 0) <br>BoxRect.left = 1; <br> <br>if (ptA.x == pt.x) { <br>rectRubber.right  = BoxRect.right; <br>rectRubber.left   = BoxRect.left; <br>} <br>if (ptA.y == pt.y) { <br>rectRubber.bottom = BoxRect.bottom; <br>rectRubber.top    = BoxRect.top; <br>} <br> <br>/* almost an IntersectRect */ <br>if (ptA.x &gt;= pt.x) <br>rectRubber.left   = BoxRect.left; <br>else <br>rectRubber.right  = BoxRect.right; <br> <br>if (ptA.y &gt;= pt.y) <br>rectRubber.top    = BoxRect.top; <br>else <br>rectRubber.bottom = BoxRect.bottom; <br> <br>/* Draw new mark */ <br>DrawRubberBand(hDst, &amp;rectRubber, R2_XORPEN); <br>} <br>else { <br>/* if not "Fill"ing(AND mouse key depressed, <br> * paint with the mouse movements */ <br>if ((wParam &amp; MK_LBUTTON) &amp;&amp; cursor == FALSE &amp;&amp;  <br>    fJustZapped == FALSE) <br>MouseInBox(hBox, message, pt); <br>} <br>break; <br> <br>case WM_LBUTTONDBLCLK: <br>case WM_RBUTTONDBLCLK: <br>break; <br> <br>default: <br> <br>/* Everything else comes here.  This call MUST exist <br>        ** in your window proc.  */ <br> <br>return(DefWindowProc(hBox, message, wParam, lParam)); <br>break; <br>} <br> <br>/* A window proc should always return something */ <br>return(0L); <br>} <br> <br> <br>/***************************** Public  Function ****************************\ <br>* <br>* BOOL  APIENTRY AboutDlg(hDlg, message, wParam, lParam) <br>* HWND     hDlg; <br>* WORD message; <br>* WPARAM wParam; <br>* LPARAM lParam; <br>* <br>* <br>* Effects: none. <br>* <br>\***************************************************************************/ <br>BOOL  APIENTRY  <br>AboutDlg( <br>HWND   hDlg, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>) <br>{ <br>UNREFERENCED_PARAMETER(lParam); <br> <br>switch (message) { <br>case WM_INITDIALOG: <br>break; <br> <br>case WM_COMMAND: <br>EndDialog(hDlg, LOWORD(wParam)); <br>/* idok or idcancel */ <br>break; <br> <br>default: <br>return FALSE; <br>break; <br>} <br>return(TRUE); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
