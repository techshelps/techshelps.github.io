<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TYPECVT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5398"></a>TYPECVT.C</h2>
<pre><code>/*++ <br> <br>Copyright 1993 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    typecvt.c <br> <br>Abstract: <br> <br>    Routines for generically converting between structure formats without <br>    regard to alignment boundries. <br> <br> <br>--*/ <br> <br> <br>#include "windows.h" <br>#include &lt;windowsx.h&gt; <br>#include "typecvt.h" <br> <br>// We want to assert errors for now. <br>#define ASSERT_ERRORS <br> <br>#ifdef ASSERT_ERRORS <br>int sprintf (); <br>#endif <br> <br>// <br>// For lack of any place better to put a general description of the type <br>// conversion functions, The following will attempt to explain what is <br>// needed set up for, and use, the functions. <br>// <br>// The main purpose of these functions is to convert non-aligned structures <br>// to aligned structures and back again. <br>// <br>// In order to convert bewteen two structures it is first necessary to define <br>// what each one looks like.  This is done most easily by statically allocating <br>// and array of StructDefineInfo or SDI structures.  Here is an example: <br>// <br>//      The two structures <br>//      struct                          struct <br>//      {                               { <br>//          CHAR    chElem1;                LONG    rglElem2 [10]; <br>//          WORD    rgwElem2 [5];           ULONG   ulElem1; <br>//      } src;                          } dest; <br>//      could be described by. <br>// <br>//      SDI  rgsdiSrcStructDef [] = { <br>//          { sizeof (CHAR), sizeof (src.chElem1) }, <br>//          { sizeof (WORD), sizeof (src.rgwElem2) }, <br>//          { 0, 0 } }; <br>// <br>//      SDI  rgsdiDestStructDef [] = { <br>//          { sizeof (LONG), sizeof (dest.rglElem2) }, <br>//          { sizeof (ULONG), sizeof (dest.ulElem1) }, <br>//          { 0, 0 } }; <br>// <br>// Once both structures have been defined the conversion between the structures <br>// in different alignments and endian types can be performed with <br>// PerformConversion (). <br>// <br>// For an example of how this is implemented see Fontcvt.c <br>// <br> <br> <br>// <br>// An advantage of the conversions routines is that they are a portable <br>// method of handling machines with Big Endian integer storage.  See header <br>// file typecvt.h for complete description of big and little endian. <br>// <br>// The folowing variables are used to select the endian type of the source <br>// and the destination structures.  The default is Little Endian. <br>// Also, these are not meant to be accessed outside of this module. <br>// Routines have been defined to access these. <br>// <br> <br>INT vfFileEndianType = CVT_FILE_ENDIAN_DEFAULT; <br>INT vfSysEndianType  = CVT_ENDIAN_UNKNOWN;// Set to unknown. <br> <br>  <br>LONG <br>lCalculateStructOffsets ( <br>      PSDI    rgsdiStructDefine, <br>      INT     fAlignmentType, <br>   INTcSizeOfStruct <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is used to calculate the offsets of each element in the <br>    Struct Define Info array.  These values are stored back int the SDI array <br>    which was passed to us.  The offsets are based on the alignment type <br>    sent to this routine.  It will also return the sizeof that structure as <br>    it would be with the alignment or -1 if there is an error. <br> <br>Arguments: <br> <br>    rgsdiStruceDefine   - Definition of this structure as an array of SDI <br>                          structures.  Note, see beginning of this file for <br>                          a complete description of how to define this <br>                          structure. <br> <br>    fAlignmentType      - This is an optional parameter which can be used to <br>                          request the count of bytes for a particular alignment <br>  CVT_ALIGN_PACKED - Return the sizeof the structure <br>if the alignment were packed. <br>  CVT_ALIGN_WORD   - Return the sizeof the structure <br>if the alignment were WORD aligned. <br>  CVT_ALIGN_DWORD  - Return the sizeof the structure <br>if the alignment were DWORD aligned. <br>  Zero or any other value, return 0 on success. <br> <br>cSizeOfStruct    - This value is used only for error detection. <br>  It should be the size of the structure you are <br>  converting in the current system alignment. <br>  (ex. sizeof (FontHeaderType)).  The function will <br>  compare this to it's calculate offset and return <br>  an error if they differ. <br>  Note that if this value is 0, no error checking will <br>  be performed. <br> <br>Return Value: <br> <br>    Postitive Value = The total size of the structure we are looking at. <br>            This should be the same as if we did a sizeof (struct) in the <br>            proper alignment. <br>    -1 = There was an error with the definition of the structure. <br>            Here is how errors are detected.  Along with determining all of <br>            the offsets in the specified alignment type, it will also do it <br>            in CVT_ALIGN_SYSTEM.  If the system alignment does not match the <br>            initial offsets, an error is reported. <br> <br>--*/ <br> <br> <br>{ <br>    LONG   oPackedOffset = 0;     // Counter for packed offset. <br>    LONG   oWordOffset = 0;     // Counter for WORD aligned offset. <br>    LONG   oDWordOffset = 0;      // Counter for DWORD aligned offset. <br> <br>// <br>// Make sure that the system endian type has been computed. <br>// We will probably need this for calls to PerformConversion. <br>// <br> <br>if (vfSysEndianType == CVT_ENDIAN_UNKNOWN) { <br> <br>vfSysEndianType = fDetermineSysEndianType (); <br>} <br> <br>    // <br>    // Keep looping while there are defined elements. <br>    // <br> <br>    while (rgsdiStructDefine-&gt;cTypeSize) { <br> <br>        // <br>        // Make sure we are aligned to either the type boundry or the <br>        // alignment count, whichever is smaller. <br>        // <br> <br>if (rgsdiStructDefine-&gt;cTypeSize &gt;= 2) { <br> <br>oWordOffset += (oWordOffset &amp; 1);// Make sure both are on <br>oDWordOffset += (oDWordOffset &amp; 1);// a WORD boundry. <br>} <br> <br>if (rgsdiStructDefine-&gt;cTypeSize &gt;= 4) { <br> <br>// Add 2 to the DWORD alignment if it is not on a DWORD boundry. <br>// Note that the previous check would already have WORD aligned it. <br> <br>oDWordOffset += (oDWordOffset &amp; 2); <br> <br>} <br> <br>        // <br>        // Store the offset to that element within the structure itsself. <br>        // <br> <br>        rgsdiStructDefine-&gt;oPackedAlign = oPackedOffset; <br>        rgsdiStructDefine-&gt;oWordAlign = oWordOffset; <br>        rgsdiStructDefine-&gt;oDWordAlign = oDWordOffset; <br> <br>        // <br>        // Increase by actual size of the element. <br>        // <br> <br>        oPackedOffset += rgsdiStructDefine-&gt;cActualSize; <br>        oWordOffset += rgsdiStructDefine-&gt;cActualSize; <br>        oDWordOffset += rgsdiStructDefine-&gt;cActualSize; <br> <br>        rgsdiStructDefine++; <br>    } <br> <br>    // <br>    // Be sure that the structure fits within alignement. <br>// Add word and DWORD padding accordingly. <br>    // <br> <br>oWordOffset  += (oWordOffset &amp; 1); <br>oDWordOffset += (oDWordOffset &amp; 1); <br>oDWordOffset += (oDWordOffset &amp; 2); <br> <br>    // <br>    // Check to see if we successfully reached the end of the structure array. <br>// We assume that they have sent us a sizeof(struct) in system alignment. <br>    // If not then return an error, -1.  Otherwise, everything is fine so <br>    // return the sizeof the structure we just got. <br>// Note we only do it if they have given us something to compare. <br>    // <br> <br>if (cSizeOfStruct) { <br> <br>switch (CVT_ALIGN_SYSTEM) { <br> <br>case CVT_ALIGN_PACKED: <br>if (cSizeOfStruct != oPackedOffset) { <br>return (-1); <br>} <br>break; <br> <br>case CVT_ALIGN_WORD: <br>if (cSizeOfStruct != oWordOffset) { <br>return (-1); <br>} <br>break; <br> <br>case CVT_ALIGN_DWORD: <br>if (cSizeOfStruct != oDWordOffset) { <br>return (-1); <br>} <br>break; <br>} <br>} <br> <br>// <br>// Check and see what type of stucture they want us to return to <br>// them.  Generally on NT it will be the packed value they want. <br>// <br> <br>switch (fAlignmentType) { <br> <br>case CVT_ALIGN_PACKED: <br>return (oPackedOffset); <br> <br>case CVT_ALIGN_WORD: <br>return (oWordOffset); <br>break; <br> <br>case CVT_ALIGN_DWORD: <br>return (oDWordOffset); <br>break; <br> <br>default: <br>return (0); <br>} <br>} <br> <br>  <br>VOID <br>vPerformConversion ( <br>     PSDI    rgsdiStructDefine, <br>     PBYTE   pjSrcBuffer, <br> INTfSrcAlignment, <br> INTfSrcEndianType, <br>     PBYTE   pjDestBuffer, <br> INTfDestAlignment, <br> INTfDestEndianType <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>WARNING: CalcStructureOffsets must have previously been called with <br>rgsdiStructDesc as it's argument. <br> <br>    This function is the heart of the generic conversion system.  It steps <br>    through the (PSDI) structure definition array and converts each element <br>from the source buffer to the destination buffer.  To do this it uses the <br>precomputed offset information stored in the structure definition. <br>Also, if the source endian type is different from the destination, it <br>will swap all data in the transfer. <br> <br>Arguments: <br> <br>    rgsdiStruceDefine   - Definition of this structure as an array of SDI <br>                          structures.  Note, see beginning of this file for <br>                          a complete description of how to define this <br>                          structure. <br> <br>    pjSrcBuffer         - This is a pointer to the source strucure in memory. <br>                          This structure does not need to be aligned. <br> <br>    fSrcAlignment       - This is the alignment of the source structure. <br>  The permissible values of this field are: <br>CVT_ALIGN_PACKED - structure is packed. <br>CVT_ALIGN_WORD   - structure is WORD aligned. <br>CVT_ALIGN_DWORD  - structure is DWORD aligned. <br>CVT_ALIGN_SYSTEM - use system default alignment. <br> <br>    fSrcEndianType      - This is the byte ordering of the source data. <br>  The permissible values of this field are: <br>CVT_LITTLE_ENDIAN - data is little endian format. <br>CVT_BIG_ENDIAN    - data is big endian format. <br>CVT_ENDIAN_FILE   - use current file endian type. <br>CVT_ENDIAN_SYSTEM - use current system endian type. <br> <br>    pjDestBuffer        - This is a pointer to the destination structure. <br>                          This structure does not need to be aligned. <br> <br>    fDestAlignment      - This is the alignment of the source structure. <br>  The permissible values of this field: Same as above. <br> <br>    fDestEndianType     - This is the byte ordering of the source data. <br>  The permissible values of this field: Same as above. <br> <br>Return Value: <br> <br>    None.  Any detectable errors would have been found in the initialization <br>    of the SDI structure. <br> <br>--*/ <br> <br>{ <br>register PSDI rgsdiStrDef = rgsdiStructDefine; <br>INT  *poSrcAlign; <br>INT  *poDestAlign; <br>PBYTE  pjSrc; <br>PBYTE  pjDest; <br> <br>// <br>// Get the alignment pointers set to the proper offset into the <br>// structure.  Here is the general trick we use here.  First we set the <br>// offset pointer to the start of the structure array.  We then find out <br>// what offset into that structure will point us to the alignment type <br>// we want.  After that, since we have an array we just add the sizeof <br>// the SDI struct to the pointer and it will give us the next offset. <br>// <br> <br>poSrcAlign = (INT *)rgsdiStrDef; <br> <br>switch (fSrcAlignment) { <br> <br>case CVT_ALIGN_PACKED: <br>((CHAR *)poSrcAlign) += ((CHAR *)&amp;rgsdiStrDef-&gt;oPackedAlign - <br>(CHAR *)rgsdiStrDef); <br>break; <br> <br>case CVT_ALIGN_WORD: <br>((CHAR *)poSrcAlign) += ((CHAR *)&amp;rgsdiStrDef-&gt;oWordAlign - <br>(CHAR *)rgsdiStrDef); <br>break; <br> <br>case CVT_ALIGN_DWORD: <br>((CHAR *)poSrcAlign) += ((CHAR *)&amp;rgsdiStrDef-&gt;oDWordAlign - <br>(CHAR *)rgsdiStrDef); <br>break; <br>} <br> <br>// <br>// Same with dest. <br>// <br> <br>poDestAlign = (INT *)rgsdiStrDef; <br> <br>switch (fDestAlignment) { <br> <br>case CVT_ALIGN_PACKED: <br>((CHAR *)poDestAlign) += ((CHAR *)&amp;rgsdiStrDef-&gt;oPackedAlign - <br>(CHAR *)rgsdiStrDef); <br>break; <br> <br>case CVT_ALIGN_WORD: <br>((CHAR *)poDestAlign) += ((CHAR *)&amp;rgsdiStrDef-&gt;oWordAlign - <br>(CHAR *)rgsdiStrDef); <br>break; <br> <br>case CVT_ALIGN_DWORD: <br>((CHAR *)poDestAlign) += ((CHAR *)&amp;rgsdiStrDef-&gt;oDWordAlign - <br>(CHAR *)rgsdiStrDef); <br>break; <br>} <br> <br> <br>if (fSrcEndianType == fDestEndianType) { <br> <br>INTcTotalCount; <br> <br>// <br>// Keep converting while there exists elements with a valid convert <br>// structure. <br>// <br> <br>while (rgsdiStrDef-&gt;cTypeSize) { <br> <br>// <br>// Store the actual size we need to transfer.  Also, store the <br>// pointers to the offsets within the current structures. <br>// <br> <br>cTotalCount = rgsdiStrDef-&gt;cActualSize; <br>pjSrc = pjSrcBuffer + *poSrcAlign; <br>pjDest = pjDestBuffer + *poDestAlign; <br> <br>// <br>// MemCpy the bytes, probably faster to do it inline. <br>// <br> <br>while (cTotalCount--) { <br> <br>*pjDest++ = *pjSrc++; <br>} <br> <br>// <br>// Now we step our three pointers to the next structure in <br>// the array. <br>// <br> <br>((CHAR *)poSrcAlign) += sizeof (SDI); <br>((CHAR *)poDestAlign) += sizeof (SDI); <br>rgsdiStrDef++; <br>} <br> <br>} else { <br> <br>INTcArrayCount; <br>INTcElemSize; <br>INTwT; <br> <br> <br>// <br>// Keep converting while there exists elements with a valid convert <br>// structure. <br>// <br> <br>while (rgsdiStrDef-&gt;cTypeSize) { <br> <br>cArrayCount = rgsdiStrDef-&gt;cActualSize / rgsdiStrDef-&gt;cTypeSize; <br> <br>// <br>// Store the actual size we need to transfer.  Also, store the <br>// pointers to the offsets within the current structures. <br>// <br> <br>cElemSize = rgsdiStrDef-&gt;cActualSize; <br>pjSrc = pjSrcBuffer + *poSrcAlign; <br>pjDest = pjDestBuffer + *poDestAlign; <br> <br>// <br>// Handle each array element seperately. <br>// <br> <br>while (cArrayCount--) { <br> <br>for (wT = 1; wT &lt;= cElemSize; wT++) { <br> <br>// <br>// Copy in reverse order. <br>// <br> <br>*pjDest++ = *(pjSrc + (cElemSize - wT)); <br>} <br> <br>pjSrc += cElemSize; <br>} <br> <br>// <br>// Now we step our three pointers to the next structure in <br>// the array. <br>// <br> <br>((CHAR *)poSrcAlign) += sizeof (SDI); <br>((CHAR *)poDestAlign) += sizeof (SDI); <br>rgsdiStrDef++; <br>} <br>} <br>} <br> <br>  <br>VOID <br>vSetFileEndianType ( <br>    BOOL     fNewEndianType <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This routine is used to set the endian type of the disk file.  Normally <br>the define CVT_FILE <br> <br>Arguments: <br> <br>    fNewEndianType   - Endian format type to set the source to. <br>                       The only valid types are CVT_LITTLE_ENDIAN and <br>                       CVT_BIG_ENDIAN. <br>                       Portable calls to this function should always <br>                       use either CVT_ENDIAN_SYSTEM or CVT_ENDIAN_FILE. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Set the endian type of the source data. <br>    vfFileEndianType = fNewEndianType; <br>} <br> <br>  <br>INT <br>fDetermineSysEndianType ( <br>VOID <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    This function is used to determine how the current system stores its <br>integers in memory. <br> <br>Arguments: <br> <br>None. <br> <br>Return Value: <br> <br>CVT_LITTLE_ENDIAN   - The system stores integers in little endian <br>  format.  (this is 80x86 default). <br>CVT_BIG_ENDIAN  - The system stores integers in big endian format. <br> <br>--*/ <br> <br>{ <br>INTnCheckInteger; <br>CHARrgchTestBytes [sizeof (INT)]; <br> <br>// <br>// Clear the test bytes to zero. <br>// <br> <br>*((INT *)rgchTestBytes) = 0; <br> <br>// <br>// Set first to some value. <br>// <br> <br>rgchTestBytes [0] = (CHAR) 0xFF; <br> <br>// <br>// Map it to an integer. <br>// <br> <br>nCheckInteger = *((INT *)rgchTestBytes); <br> <br>// <br>// See if value was stored in low order of integer. <br>// If so then system is little endian. <br>// <br> <br>if (nCheckInteger == 0xFF) { <br> <br>return (CVT_LITTLE_ENDIAN); <br>} else { <br> <br>return (CVT_LITTLE_ENDIAN); <br>} <br>} <br> <br>  <br>VOID <br>vCharToShort ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source CHAR to the destination SHORT.  Note that sign extension <br>    is performed.  The destination buffer does not need to be WORD aligned. <br>    This is generally used for transfering file mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a CHAR. <br>    pjDest      - Returns the copied SHORT at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source CHAR and use it as an argument for destination SHORT. <br> <br>    vDestBuffFromSHORT ( <br>             (SHORT)*pjSrc, <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vCharToUShort ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source CHAR to the destination USHORT.  Note that sign <br>    extension is not perfomed.  The destination buffer does not need to be <br>    WORD aligned. This is generally used for transfering file mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a CHAR. <br>    pjDest      - Returns the copied SHORT at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source CHAR and use it as an argument for destination USHORT. <br> <br>    vDestBuffFromUSHORT ( <br>             (USHORT)*pjSrc, <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vCharToLong ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source CHAR to the destination LONG.  Note that sign extension <br>    is performed.  The destination buffer does not need to be DWORD aligned. <br>    This is generally used for transfering file mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a CHAR. <br>    pjDest      - Returns the copied LONG at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source CHAR and use it as an argument for destination LONG. <br> <br>    vDestBuffFromLONG ( <br>             (LONG)*pjSrc, <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vCharToULong ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source CHAR to the destination ULONG.  Note that sign extension <br>    is not performed.  The destination buffer does not need to be DWORD <br>    aligned. This is generally used for transfering file mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a CHAR. <br>    pjDest      - Returns the copied ULONG at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source CHAR and use it as an argument for destination ULONG. <br> <br>    vDestBuffFromULONG ( <br>             (ULONG)*pjSrc, <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vShortToShort ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source SHORT to the destination SHORT.  Neither buffers need <br>    to be WORD aligned.  This is generally used for transfering file mapped <br>    data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a SHORT. <br>    pjDest      - Returns the copied SHORT at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source SHORT and use it as an argument for destination SHORT. <br> <br>    vDestBuffFromSHORT ( <br>             sSHORTFromSrcBuff (pjSrc), <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vShortToLong ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source SHORT to the destination LONG.  Note that sign extension <br>    is perfomed.  Neither buffers need to be WORD or DWORD aligned. <br>    This is generally used for transfering file mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a SHORT. <br>    pjDest      - Returns the copied LONG at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source SHORT and use it as an argument for destination LONG. <br> <br>    vDestBuffFromLONG ( <br>             (LONG)sSHORTFromSrcBuff (pjSrc), <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vShortToULong ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source SHORT to the destination ULONG.  Note that sign extension <br>    is perfomed.  Neither buffers need to be WORD or DWORD aligned. <br>    This is generally used for transfering file mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a SHORT. <br>    pjDest      - Returns the copied ULONG at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source SHORT and use it as an argument for destination ULONG. <br> <br>    vDestBuffFromULONG ( <br>             (LONG)sSHORTFromSrcBuff (pjSrc), <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vLongToLong ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source LONG to the destination LONG.  Neither buffers need to <br>    be WORD or DWORD aligned. This is generally used for transfering file <br>    mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a LONG. <br>    pjDest      - Returns the copied LONG at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source LONG and use it as an argument for destination LONG. <br> <br>    vDestBuffFromLONG ( <br>             (LONG)lLONGFromSrcBuff (pjSrc), <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vLongToShort ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source LONG to the destination SHORT.  Neither buffers need to <br>    be WORD or DWORD aligned. This is generally used for transfering file <br>    mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a LONG. <br>    pjDest      - Returns the copied SHORT at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source LONG and use it as an argument for destination SHORT. <br> <br>    vDestBuffFromSHORT ( <br>             (SHORT)lLONGFromSrcBuff (pjSrc), <br>             pjDest <br>            ); <br>} <br> <br>  <br>VOID <br>vLongToChar ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source LONG to the destination CHAR.  Neither buffers need to <br>    be WORD or DWORD aligned. This is generally used for transfering file <br>    mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a LONG. <br>    pjDest      - Returns the copied CHAR at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source LONG and use it as an argument for destination CHAR. <br> <br>*pjDest = (CHAR)lLONGFromSrcBuff (pjSrc); <br>} <br> <br>  <br>VOID <br>vShortToChar ( <br>             PBYTE   pjSrc, <br>             PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies the source SHORT to the destination CHAR.  Neither buffers need to <br>    be WORD or DWORD aligned. This is generally used for transfering file <br>    mapped data. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a SHORT. <br>    pjDest      - Returns the copied CHAR at the location pointed to. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br>{ <br>    // Get the source SHORT and use it as an argument for destination CHAR. <br> <br>*pjDest = (CHAR)sSHORTFromSrcBuff (pjSrc); <br>} <br> <br>  <br>SHORT <br>sSHORTFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies two byte short from buffer into a signed short.  The buffer does <br>    not need to be WORD aligned.  This is generally used for copying from <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fSrcEndianType is checked before copy. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a SHORT. <br> <br>Return Value: <br> <br>    Signed short which is obtained from the buffer. <br> <br>--*/ <br> <br> <br>{ <br>    SHORT   sStorage; <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        sStorage = (SHORT)          // Source is little endian, shift <br>                (                   // the high bytes high. <br>                 (pjSrc [1] &lt;&lt; 8) | <br>                 (pjSrc [0]) <br>                ); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        sStorage = (SHORT)          // Source is big endian, shift <br>                (                   // the high bytes low. <br>                 (pjSrc [0] &lt;&lt; 8) | <br>                 (pjSrc [1]) <br>                ); <br>    } <br> <br>#endif <br> <br>    return (sStorage); <br>} <br> <br>  <br>USHORT <br>usUSHORTFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies two byte short from buffer into an unsigned short.  The buffer does <br>    not need to be WORD aligned.  This is generally used for copying from <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fSrcEndianType is checked before copy. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a USHORT. <br> <br>Return Value: <br> <br>    Unsigned short which is obtained from the buffer. <br> <br>--*/ <br> <br> <br>{ <br>    USHORT  usStorage; <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        usStorage = (USHORT)            // Source is little endian, shift <br>                (                       // the high bytes high. <br>                 (pjSrc [1] &lt;&lt; 8) | <br>                 (pjSrc [0]) <br>                ); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        usStorage = (USHORT)            // Source is big endian, shift <br>                (                       // the high bytes low. <br>                 (pjSrc [0] &lt;&lt; 8) | <br>                 (pjSrc [1]) <br>                ); <br>    } <br> <br>#endif <br> <br>    return (usStorage); <br>} <br> <br>  <br>LONG <br>lLONGFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies four byte long from buffer into a signed long.  The buffer does <br>    not need to be DWORD aligned.  This is generally used for copying from <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fSrcEndianType is checked before copy. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a LONG. <br> <br>Return Value: <br> <br>    Signed long which is obtained from the buffer. <br> <br>--*/ <br> <br> <br>{ <br>    LONG    lStorage; <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        lStorage = (LONG)               // Source is little endian, shift <br>                ((pjSrc [3] &lt;&lt; 24) |    // the high bytes high. <br>                 (pjSrc [2] &lt;&lt; 16) | <br>                 (pjSrc [1] &lt;&lt; 8) | <br>                 (pjSrc [0]) <br>                ); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        lStorage = (LONG)               // Source is big endian, shift the <br>                ((pjSrc [0] &lt;&lt; 24) |    // high bytes low. <br>                 (pjSrc [1] &lt;&lt; 16) | <br>                 (pjSrc [2] &lt;&lt; 8) | <br>                 (pjSrc [3]) <br>                ); <br>    } <br> <br>#endif <br> <br>    return (lStorage); <br>} <br> <br>  <br>ULONG <br>ulULONGFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies four byte long from buffer into an unsigned long.  The buffer does <br>    not need to be DWORD aligned.  This is generally used for copying from <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fSrcEndianType is checked before copy. <br> <br>Arguments: <br> <br>    pjSrc       - Supplies pointer to the source buffer containing a ULONG. <br> <br>Return Value: <br> <br>    Unsigned long which is obtained from the buffer. <br> <br>--*/ <br> <br> <br>{ <br>    ULONG   ulStorage; <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        ulStorage = (ULONG)             // Source is little endian, shift <br>                ((pjSrc [3] &lt;&lt; 24) |    // the high bytes high. <br>                 (pjSrc [2] &lt;&lt; 16) | <br>                 (pjSrc [1] &lt;&lt; 8) | <br>                 (pjSrc [0]) <br>                ); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        ulStorage = (ULONG)             // Source is big endian, shift the <br>                ((pjSrc [0] &lt;&lt; 24) |    // high bytes low. <br>                 (pjSrc [1] &lt;&lt; 16) | <br>                 (pjSrc [2] &lt;&lt; 8) | <br>                 (pjSrc [3]) <br>                ); <br>    } <br> <br>#endif <br> <br>    return (ulStorage); <br>} <br> <br>  <br>VOID <br>vDestBuffFromSHORT ( <br>         SHORT   sSource, <br>         PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies two byte signed short into a destination buffer.  The buffer does <br>    not need to be WORD aligned.  This is generally used for copying to </code></pre>
<p>
</p>
<pre><code>mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fDestEndianType is checked before copy. <br> <br>Arguments: <br> <br>    sSource     - Signed short to convert to buffer. <br>    pjDest      - Supplies pointer to destination buffer for the USHORT. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br> <br>{ <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        pjDest [0] = ((sSource) &amp; 0xFF); <br>        pjDest [1] = ((sSource &gt;&gt; 8)  &amp; 0xFF); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        pjDest [1] = ((sSource) &amp; 0xFF); <br>        pjDest [0] = ((sSource &gt;&gt; 8)  &amp; 0xFF); <br>    } <br> <br>#endif <br>} <br> <br>  <br>VOID <br>vDestBuffFromUSHORT ( <br>         USHORT  usSource, <br>         PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies two byte unsigned short into a destination buffer.  The buffer <br>    does not need to be WORD aligned.  This is generally used for copying to <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fDestEndianType is checked before copy. <br> <br>Arguments: <br> <br>    usSource    - Unsigned short to convert to buffer. <br>    pjDest      - Supplies pointer to destination buffer for the USHORT. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br> <br>{ <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        pjDest [0] = ((usSource) &amp; 0xFF); <br>        pjDest [1] = ((usSource &gt;&gt; 8)  &amp; 0xFF); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        pjDest [1] = ((usSource) &amp; 0xFF); <br>        pjDest [0] = ((usSource &gt;&gt; 8)  &amp; 0xFF); <br>    } <br> <br>#endif <br>} <br> <br>  <br>VOID <br>vDestBuffFromLONG ( <br>         LONG    lSource, <br>         PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies four byte long into a destination buffer.  The buffer does not <br>    need to be DWORD aligned.  This is generally used for copying to <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fDestEndianType is checked before copy. <br> <br>Arguments: <br> <br>    lSource     - Signed long to convert to buffer. <br>    pjDest      - Supplies pointer to destination buffer for the LONG. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br> <br>{ <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        pjDest [0] = ((lSource) &amp; 0xFF); <br>        pjDest [1] = ((lSource &gt;&gt; 8)  &amp; 0xFF); <br>        pjDest [2] = ((lSource &gt;&gt; 16) &amp; 0xFF); <br>        pjDest [3] = ((lSource &gt;&gt; 24) &amp; 0xFF); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        pjDest [3] = ((lSource) &amp; 0xFF); <br>        pjDest [2] = ((lSource &gt;&gt; 8)  &amp; 0xFF); <br>        pjDest [1] = ((lSource &gt;&gt; 16) &amp; 0xFF); <br>        pjDest [0] = ((lSource &gt;&gt; 24) &amp; 0xFF); <br>    } <br> <br>#endif <br>} <br> <br>  <br>VOID <br>vDestBuffFromULONG ( <br>         ULONG   ulSource, <br>         PBYTE   pjDest <br>    ) <br> <br>/*++ <br> <br>Routine Description: <br> <br>    Copies four byte long into a destination buffer.  The buffer does not <br>    need to be DWORD aligned.  This is generally used for copying to <br>    mapped disk files.  If CVT_BIG_ENDIAN_SUPPORT is defined then the <br>    fDestEndianType is checked before copy. <br> <br>Arguments: <br> <br>    ulSource    - Unsigned long to convert to buffer. <br>    pjDest      - Supplies pointer to destination buffer for the ULONG. <br> <br>Return Value: <br> <br>    None. <br> <br>--*/ <br> <br> <br>{ <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    if (fSrcEndianType == CVT_LITTLE_ENDIAN) { <br>#endif <br>        pjDest [0] = (BYTE)((ulSource) &amp; (ULONG)0xFF); <br>        pjDest [1] = (BYTE)((ulSource &gt;&gt; 8)  &amp; (ULONG)0xFF); <br>        pjDest [2] = (BYTE)((ulSource &gt;&gt; 16) &amp; (ULONG)0xFF); <br>        pjDest [3] = (BYTE)((ulSource &gt;&gt; 24) &amp; (ULONG)0xFF); <br> <br>#ifdef CVT_BIG_ENDIAN_SUPPORT <br>    } else { <br>        pjDest [3] = (BYTE)((ulSource) &amp; (ULONG)0xFF); <br>        pjDest [2] = (BYTE)((ulSource &gt;&gt; 8)  &amp; (ULONG)0xFF); <br>        pjDest [1] = (BYTE)((ulSource &gt;&gt; 16) &amp; (ULONG)0xFF); <br>        pjDest [0] = (BYTE)((ulSource &gt;&gt; 24) &amp; (ULONG)0xFF); <br>    } <br> <br>#endif <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
