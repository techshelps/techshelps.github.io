<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONTEDIT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5393"></a>FONTEDIT.C</h2>
<pre><code>#define  NOVIRTUALKEYCODES <br> <br>#include "windows.h" <br>#include &lt;windowsx.h&gt; <br>#include "fontedit.h" <br>#include "fcntl.h" <br>#include &lt;stdlib.h&gt;   // Causes redefinition warnings. <br>#include &lt;string.h&gt; <br> <br>/****************************************************************************/ <br>/*              Shared Variables (Home base)                                */ <br>/****************************************************************************/ <br> <br>FARPROC lpHeaderProc;                  /* Pointer to Dialog Box Procedure */ <br>FARPROC lpReSizeProc;                  /* Pointer to Dialog Box Procedure */ <br>FARPROC lpWidthProc;                   /* Pointer to Dialog Box Procedure */ <br> <br>FontHeaderType font;                    /* Structure of Font File Header */ <br>LONG lSizeOfOldFontHeader = 0;                  /* Old packed header size.              */ <br>LONG lSizeOfOldFontHeader30 = 0;                /* Old 3.0 packed header size.  */ <br>LONG lSizeOfOldGlyph20 = 0;             /* Old packed 2.0 glyph info size. */ <br>LONG lSizeOfOldGlyph30 = 0;                     /* Old packed 3.0 glyph info size. */ <br>extern CHAR szFontFile[];               /* Name of Font File */ <br>extern CHAR szFontFileFull[];               /* Name of Font File */ <br>extern CHAR szNewFile[];                /* Temporary Name */ <br>extern BOOL NewFile;                    /* flag indicating if file was opened <br>                                           by selecting NEW menu item */ <br>HCURSOR hCross;                         /* handle to a "+" shaped cursor */ <br>HANDLE hInst;                           /* Handle to Window Instance */ <br>HANDLE hgPrev; <br>INT  swH = 0;                           /* Position in Show Window 0-100 */ <br>BYTE iChar = 65;                        /* Character being edited */ <br>BYTE jChar = 65;                        /* Last Char. of edit block */ <br>CHAR szFaceName[szNamesMax] = {""};     /* Face Name of Font */ <br>DWORD offsets[257];                     /* Offsets Table */ <br>CHAR *vrgsz[CSTRINGS];                  /* string table */ <br> <br>BOOL fChanged = FALSE;                  /* Note if we did anything */ <br>BOOL fLoaded = FALSE;                   /* Set if a font is loaded */ <br>BOOL fEdited = FALSE;                   /* Character was edited */ <br>INT  iFontFormat;                       /* Set to id of current font format */ <br>INT  iFontFormatPrev;                   /* Set to id of prev. font format */ <br>BOOL fReadOnly; <br> <br>HWND hBox = NULL;                       /* Handle to Edit Window */ <br>HWND hFont = NULL;                      /* Handle to Show window */ <br>HDC hMemDC = NULL;                      /* Handle to Memory Display Context */ <br>HBITMAP hBitmap = NULL;                 /* Handle to our work bit map */ <br> <br>CHAR matBox [wBoxLim] [kBoxLim];        /* array to hold Box */ <br>WORD wBox = 10;                 /* Width of Character(s) */ <br>WORD kBox = 16;                 /* Height of Characters */ <br>DWORD kStuff;                   /* Height of font window caption etc. */ <br> <br>OFSTRUCT ofstrFile;             /* holds info of file - filled in by dlgopen/save */ <br>//WORD     fp = NULL;             /* global fp of current file - " " " " " " */ <br> <br>/*** string arrays for using stringtable ***/ <br>CHAR    szAppName[MAX_STR_LEN]; <br>CHAR    szIFN[MAX_STR_LEN];         /* illegal filename */ <br>CHAR    szFNF[MAX_STR_LEN];         /* file not found   */ <br>CHAR    szREF[MAX_STR_LEN];         /* replace existing file */ <br>CHAR    szSCC[MAX_STR_LEN];         /* save current changes */ <br>CHAR    szEOF[MAX_STR_LEN];         /* error opening file */ <br>CHAR    szECF[MAX_STR_LEN];         /* error creating file */ <br>CHAR    szFRO[MAX_STR_LEN];         /* error creating file */ <br>CHAR    szExt[MAX_STR_LEN];         /* .FNT */ <br>CHAR    szExtDesc[MAX_STR_LEN];     /* Font Files(.FNT) */ <br>CHAR    szNEWFONT[MAX_STR_LEN];     /* Font Files(.FNT) */ <br>CHAR    szFilter[MAX_STR_LEN];     /* Font Files(.FNT) */ <br> <br> <br>/* size of system font */ <br>INT     cSysWidth; <br>INT     cSysHeight; <br> <br>/****************************************************************************/ <br>/*              Local Variables                                             */ <br>/****************************************************************************/ <br> <br>BYTE FindMouse();               /* Find where mouse is */ <br> <br>HBRUSH hbrWhite; <br>HBRUSH hbrBlack; <br>HBRUSH hbrGray; <br>HBRUSH hbrDkGray; <br>HBRUSH hbrBackGround; <br> <br>BYTE downChar;                          /* Where mouse was pressed */ <br>BYTE lastChar;                          /* Where mouse was last */ <br>WORD wBoxOld;                           /* So we can catch any changes */ <br>RECT rectWin;                           /* Client Rectangle */ <br>LONG origin;                           /* Position in Show Window pixels */ <br>BOOL fFirstShow = TRUE;                /* first time Show Window displayed? */ <br> <br>/****************************************************************************/ <br>/*              Local Functions                                             */ <br>/****************************************************************************/ <br> <br>VOID InvertFont(HDC, BYTE, BYTE); <br>BOOL FontEditInit(HANDLE); <br>VOID InitSizes(VOID); <br> <br>/***************************************************************************** <br> * FontShowHorzScroll(hFont, code, posNew) <br> * <br> * purpose: intepret scroll message for tiny window and call scroll funtion <br> *          accordingly <br> * <br> * params: HWND hFont : handle to tiny window <br> *         int code   : scroll message <br> *         int posNew : thumb position <br> * returns: none <br> * <br> * side effects: scroll position variable altered <br> * <br> ****************************************************************************/ <br>VOID <br>FontShowHorzScroll( <br>    HWND hFont, <br>    INT code, <br>    INT posNew <br>        ) <br>{ <br>    WORD   wChar; <br>    RECT   rect; <br> <br>    /* Get dimensions */ <br>    GetClientRect(hFont, (LPRECT)&amp;rect); <br> <br>    if (font.AvgWidth == 0 ) { // for Japan <br>        font.AvgWidth = 1 ; <br>        } <br>    /* Make a fair guess as to how many characters are in the window */ <br>    /* Convert sorta to hex too. */ <br>    wChar=(WORD)(11*(rect.right-rect.left)/(font.AvgWidth*16)); <br> <br>    switch (code) <br>        { <br>        case SB_LINEUP:     /* line left */ <br>            swH -= 1; <br>            break; <br>        case SB_LINEDOWN:   /* line right */ <br>            swH += 1; <br>            break; <br>        case SB_PAGEUP:     /* page left */ <br>            swH -= wChar; <br>            break; <br>        case SB_PAGEDOWN:   /* page right */ <br>            swH += wChar; <br>            break; <br>        case SB_THUMBPOSITION: <br>            swH = posNew; <br>            break; <br>        case SB_THUMBTRACK: <br>            return; <br>    } <br>    ScrollFont(); <br>} <br> <br>/***************************************************************************** <br> * FontShowPaint(hDC) <br> * <br> * purpose: repaint the little window at the bottom <br> * <br> * params:  HDC hDC : handle to display context. <br> * <br> * returns: none <br> * <br> * side effects: some scroll globals altered. <br> * <br> ****************************************************************************/ <br> <br>VOID <br>FontShowPaint( <br>        HDC hDC <br>        ) <br>{ <br>        DWORD range, nBits; <br>        INT nx; <br> <br>    nx=GetSystemMetrics(SM_CXBORDER); <br>    /* 320 --&gt; 300 */ <br>    nBits = min(300, rectWin.right - rectWin.left-nx-nx) - 24; <br>        /* Window width (pixels) */ <br>    /* 320 --&gt; 300 */ <br>    range = max(0, (font.WidthBytes &lt;&lt; 3) - min(300, nBits)); <br>    origin = (swH * range) / 100;               /* Global variable */ <br>    BitBlt(hDC, 12, 2, nBits, font.PixHeight, <br>           hMemDC, origin, 0, NOTSRCCOPY); <br>    /* Now highlight the current value of iChar */ <br>    InvertFont(hDC, iChar, jChar); <br>} <br> <br> <br>/***************************************************************************** <br> * MouseInFont(ptMouse) <br> * <br> * purpose: Select new char in tiny Show window by inverting current char <br> *          and un-inverting last one <br> * <br> * params:  POINT ptMouse  : mouse coordinates <br> * <br> * returns: none <br> * <br> * side effects: pixels inverted(uninverted) in bitmap. <br> * <br> ****************************************************************************/ <br>VOID <br>MouseInFont( <br>        POINT ptMouse                    /*  .. to get new iChar */ <br>        ) <br>{ <br>        HDC hDC; <br> <br>    BoxToChar(iChar);           /* Replace edited character in Box if changed */ <br>    hDC = GetDC(hFont); <br>    /* UnInvert present inverted region */ <br>    InvertFont(hDC, iChar, jChar); <br>    /* Find where mouse is */ <br>    lastChar = downChar = iChar = jChar = FindMouse(ptMouse); <br>    /* Invert Character touched */ <br>    InvertFont(hDC, iChar, jChar); <br>    ReleaseDC(hFont, hDC); <br>} <br> <br> <br>/***************************************************************************** <br> * <br> * purpose: <br> * <br> * params: <br> * <br> * returns: <br> * <br> * side effects: <br> * <br> ****************************************************************************/ <br>VOID <br>MouseMoveFont( <br>        POINT ptMouse <br>        ) <br>        /* Mouse raised in font */ <br>        /*  .. to get new jChar */ <br>{ <br>        UNREFERENCED_PARAMETER(ptMouse); <br>    return;     /********* NOT YET IN USE !! ********/ <br> <br>#if 0 <br>        BYTE newChar; <br>        HDC hDC; <br> <br>    newChar = FindMouse(ptMouse);               /* Find where mouse is */ <br>    if (newChar == lastChar)            /* Did we move ? */ <br>        return;                         /* No: return */ <br>    lastChar = newChar; <br>    hDC = GetDC(hFont); <br>    if (newChar &gt; jChar) <br>        { <br>        InvertFont(hDC, jChar + 1, newChar);    /* extend jChar */ <br>        jChar = newChar; <br>        } <br>    else if (newChar &lt; iChar)           /* iChar &amp; jChar switch */ <br>        { <br>        InvertFont(hDC, newChar, iChar - 1); <br>        iChar = newChar; <br>        } <br>    else <br>        { <br>        if (newChar &gt;= downChar)        /* width reduced on right */ <br>            { <br>            InvertFont(hDC, newChar + 1, jChar); <br>            jChar = newChar; <br>            } <br>        if (newChar &lt;= downChar)        /* width reduced on left */ <br>            { <br>            InvertFont(hDC, iChar, newChar - 1); <br>            iChar = newChar; <br>            } <br>        } <br>    ReleaseDC(hFont, hDC); <br>#endif <br>} <br> <br> <br>/***************************************************************************** <br> * InvertFont(hDC, iChar, jChar) <br> * <br> * purpose: inverts color on selected chars (iChar thro' jChar) in the Show <br> *          Window <br> * <br> * params:  HDC hDC    : handle to display context <br> *          char iChar : start char <br> *          char jChar : end char <br> * <br> * returns: none <br> * <br> * side effects: changes pixel values in bitmap <br> * <br> ****************************************************************************/ <br>VOID <br>InvertFont( <br>        HDC hDC, <br>        BYTE iChar, <br>        BYTE jChar <br>        ) <br>{ <br>    PatBlt(hDC,                         /* Use Blt to Invert it */ <br>        12 + offsets[iChar] - origin,   /* X: Position */ <br>        2,                              /* Y: Allow for top band */ <br>        offsets[jChar + 1] - offsets[iChar],    /* dx: Compute width */ <br>        font.PixHeight,                 /* dy: Look up the Height */ <br>        DSTINVERT);                     /* Z: Tell it to invert it */ <br>} <br> <br> <br>/***************************************************************************** <br> * MouseOutFont(ptMouse) <br> * <br> * purpose: brings selected char to edit box and sets up tiny window for <br> *          repainting <br> * <br> * params:  POINT ptMouse : mouse location <br> * <br> * returns: none <br> * <br> * side effects: changes matBox(2-d array containing ready pixel info. on <br> *               char being edited) <br> * <br> ****************************************************************************/ <br>VOID <br>MouseOutFont( <br>        POINT ptMouse <br>        ) <br>        /* Mouse raised in font */ <br>        /*  .. to get new jChar */ <br>{ <br>    MouseMoveFont(ptMouse);     /* Check on iChar and jChar */ <br>    CharToBox(iChar); <br>    InvalidateRect(hFont, (LPRECT)NULL, TRUE);  /* Cause repaint */ <br>} <br> <br> <br>/***************************************************************************** <br> * BYTE FindMouse(ptMouse) <br> * <br> * purpose: Locate number of character(in tiny window at bottom) under mouse <br> * <br> * params:  POINT ptMouse : mouse location <br> * <br> * returns: number of character <br> * <br> * side effects: alters scroll position variable <br> * <br> ****************************************************************************/ <br> <br>BYTE <br>FindMouse( <br>        POINT ptMouse <br>        ) <br>{ <br>        int  iChar; <br>        LONG   x; <br> <br> <br>    x = ptMouse.x + origin - 12;        /* Horizontal position of mouse */ <br>    if (x &lt; 0) <br>        iChar = font.FirstChar; <br>    else <br>        { <br>        iChar = x / font.AvgWidth + font.FirstChar; <br>        /* Right if Fixed Pitch -- Best Guess if variable width */ <br>        if (!font.PixWidth)                     /* Scan for new iChar */ <br>            { <br>            if (iChar &gt; (int)font.LastChar) <br>                   iChar = (int)font.LastChar;  /* Don't overshoot */ <br> <br>            while (iChar &lt; (int)font.LastChar &amp;&amp; offsets[iChar] &lt; (DWORD)x) <br>                iChar++; <br>            while (iChar &gt; (int)font.FirstChar &amp;&amp; offsets[iChar] &gt; (DWORD)x) <br>                iChar--; <br>            } <br>        } <br> <br>    /* Bug fix: prevent nil character from showing if mouse is pressed way <br>       over on right side of font scroll with narrow fixed fonts. */ <br>    if (iChar &gt; (int)font.LastChar) <br>        iChar = (int)font.LastChar;  /* Don't overshoot */ <br> <br>    if (iChar &lt; (int)font.FirstChar) <br>        iChar = (int)font.FirstChar;  /* Don't undershoot */ <br> <br>    if (ptMouse.x &lt;= 12L) <br>        { <br>        swH -= 1; <br>        ScrollFont(); <br>        } <br>    if (ptMouse.x &gt; 308L) <br>        { <br>        swH += 1; <br>        ScrollFont(); <br>        } <br>    return (BYTE)iChar; <br>} <br> <br> <br>/***************************************************************************** <br> * ScrollFont() <br> * <br> * purpose: scrolls tiny window at bottom <br> * <br> * params:  none <br> * <br> * returns: none <br> * <br> * side effects: alters scroll position variable <br> * <br> ****************************************************************************/ <br>VOID <br>ScrollFont( <br>        VOID <br>        ) <br>{ <br>        HDC hDC; <br> <br>    swH = max(0, swH); <br>    swH = min(100, swH);        /* maintain 0 - 100 range */ <br>    SetScrollPos(hFont, SB_HORZ, swH, TRUE);     /* Move thumb */ <br>    hDC = GetDC(hFont); <br>    FontShowPaint(hDC); <br>    ReleaseDC(hFont, hDC); <br>} <br> <br> <br>/***************************************************************************** <br> * BoxToChar(iChar) <br> * <br> * purpose: sets pixels in bitmap according to matBox(2-d array containing <br> *          ready pixel info. on char being edited) <br> * <br> * params:  BYTE iChar : index of char in bitmap offset array(offsets) <br> * <br> * returns: none <br> * <br> * side effects: changes font bitmap <br> * <br> ****************************************************************************/ <br>VOID <br>BoxToChar( <br>        BYTE iChar <br>        ) <br>{ <br>        DWORD x, y, offset; <br> <br>    if (!fEdited) <br>        return; <br> <br>    if (wBox != wBoxOld)                /* I.e if width has changed */ <br>        CharWidth(iChar, wBox);         /* .. go fix it */ <br> <br>    offset = offsets[iChar]; <br>    for (x = 0; x &lt; wBox; x++) <br>        { <br>        for (y = 0; y &lt; kBox; y++) <br>            SetPixel(hMemDC, offset + x, y, <br>                matBox[x] [y] == TRUE ? WHITE : BLACK); <br>        } <br>    fEdited = FALSE; <br>} <br> <br> <br>/***************************************************************************** <br> * CharToBox(iChar) <br> * <br> * purpose: assigns matBox(2-d array containing ready pixel info. on char being <br> *          edited) according to pixels in portion of bitmap corresp. to char. <br> * <br> * params:  BYTE iChar : index of char in bitmap offset array(offsets) <br> * <br> * returns: none <br> * <br> * side effects: changes matBox <br> * <br> ****************************************************************************/ <br>VOID <br>CharToBox( <br>        BYTE iChar <br>        ) <br>{ <br>        DWORD x, y, offset; <br>        HMENU hMenu; <br> <br>    ClearBox(); <br>    offset = offsets[iChar]; <br>    wBox = wBoxOld = (WORD) (offsets[iChar + 1] - offset); /* Edit Box width */ <br>    kBox = font.PixHeight;                              /* Edit Box Height */ <br>    for (x = 0; x &lt; wBox; x++) <br>        for (y = 0; y &lt; kBox; y++) <br>            matBox[x][y] = (BYTE) (GetPixel(hMemDC, offset + x, y) ? 1 : 0); <br>    InvalidateRect(hBox, (LPRECT)NULL, TRUE); <br>    fEdited = FALSE;            /* Not Changed Yet */ <br>    hMenu = GetMenu(hBox); <br>    EnableMenuItem(hMenu, BOX_UNDO, MF_GRAYED); <br>    EnableMenuItem(hMenu, BOX_REFRESH, MF_GRAYED); <br>} <br> <br> <br>/*****************************************************************************/ <br>/*              WinMain  and  Friends                                        */ <br>/*****************************************************************************/ <br> <br> <br>/* Procedure called every time a new instance of the application <br>** is created */ <br> <br>INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, INT cmdShow) <br>{ <br>        MSG    msg; <br>        WORD   message; <br>        INT    nx; <br>        HANDLE hAccel; <br> <br>    hInst = hInstance; <br>    hgPrev=hPrevInstance; <br> <br> <br>        if (!FontEditInit( hInstance )) <br>            return FALSE; <br> <br> <br> <br>    LoadString(hInstance, IDS_APPNAME, szAppName, MAX_STR_LEN); <br>    LoadString(hInstance, IDS_IFN, szIFN, MAX_STR_LEN); /* illegal filename */ <br>    LoadString(hInstance, IDS_FNF, szFNF, MAX_STR_LEN); /* file not found   */ <br>    LoadString(hInstance, IDS_REF, szREF, MAX_STR_LEN); <br>                        /* replace existing file */ <br>    LoadString(hInstance, IDS_SCC, szSCC, MAX_STR_LEN); <br>                        /* save current changes */ <br>    LoadString(hInstance, IDS_EOF, szEOF, MAX_STR_LEN); /* error opening file */ <br>    LoadString(hInstance, IDS_ECF, szECF, MAX_STR_LEN); <br>        // File is read only. <br>    LoadString(hInstance, IDS_FRO, szFRO, MAX_STR_LEN); <br>                        /* error creating file */ <br>    LoadString(hInstance, IDS_EXT, szExt, MAX_STR_LEN); /* default file ext. */ <br> <br>        // File extension description for common dialog. <br>    LoadString(hInstance, IDS_EXTDESC, szExtDesc, MAX_STR_LEN); <br>        // Message for new font warning box. <br>    LoadString(hInstance, IDS_NEW_FONT, szNEWFONT, MAX_STR_LEN); <br>    memset(szFilter, 0, MAX_STR_LEN); <br>    LoadString(hInstance, IDS_EXTDESC, szFilter, MAX_STR_LEN); <br>    LoadString(hInstance, IDS_STARDOTFNT, szFilter+strlen(szFilter)+1, <br>                                MAX_STR_LEN-(strlen(szFilter)+1)); <br> <br> <br>    ClearBox(); <br> <br>        /* Create a window instance of class "FontEdit" */ <br> <br>    hBox = CreateWindow((LPSTR) vszFontEdit, <br>                      (LPSTR)szAppName, <br>                      WS_TILEDWINDOW, <br>                      56,34, <br>                      GetSystemMetrics(SM_CXFULLSCREEN)/2, <br>                      GetSystemMetrics(SM_CYFULLSCREEN)/2, <br>                      (HWND)NULL,        /* no parent */ <br>                      (HMENU)NULL,       /* use class menu */ <br>                      (HANDLE)hInstance, /* handle to window instance */ <br>                      (LPSTR)NULL        /* no params to pass on */ <br>                      ); <br> <br>    ShowWindow(hBox, cmdShow); <br>    UpdateWindow(hBox); <br>    InitSizes();     /* 11/21/86 - linsh - get system char width &amp; height */ <br> <br> <br>    GetWindowRect(hBox, (LPRECT)&amp;rectWin); <br>    nx=GetSystemMetrics(SM_CXBORDER); <br>    hFont = CreateWindow((LPSTR) vszFontShow, <br>                       (LPSTR) "", <br>                       WS_BORDER|WS_HSCROLL|WS_CAPTION, <br>                       rectWin.left, <br>                       rectWin.bottom-56, <br>                       min(300, rectWin.right - rectWin.left-nx-nx), <br>                       50 - GetSystemMetrics(SM_CYBORDER), <br>                       (HWND)hBox, <br>                       (HMENU)NULL, <br>                       (HANDLE)hInstance, <br>                       (LPSTR)NULL <br>                       ); <br> <br> <br>    /* Get address of Dialog Box procedure */ <br>    lpHeaderProc = MakeProcInstance((FARPROC)HeaderProc, hInstance); <br>    lpReSizeProc = MakeProcInstance((FARPROC)ReSizeProc, hInstance); <br>    lpWidthProc = MakeProcInstance((FARPROC)WidthProc, hInstance); <br> <br>    /* Start it loading if it's not iconic */ <br>    if (!IsIconic(hBox)) <br>        { <br>        if (lpszCmdLine[0])     /* If we have a font name use it */ <br>            { <br>            BOOL   fDot; <br>            INT   i; <br> <br>            /* Copy the specified file and make it upper case */ <br>            lstrcpy((LPSTR)szFontFile, CharUpper((LPSTR)lpszCmdLine)); <br> <br>            fDot = FALSE; <br>            nx=lstrlen((LPSTR)szFontFile); <br> <br>            for (i = 0; i &lt; nx; i++) <br>                { <br>                if (szFontFile[i] == '.')       /* Add .FNT if none */ <br>                    fDot = TRUE; <br> <br>                if (szFontFile[i] == ' ') <br>                    szFontFile[i]=0; <br>                } <br> <br>            if (!fDot) <br>                lstrcat((LPSTR)szFontFile, (LPSTR)vszDotFNT); <br> <br>            lstrcpy((LPSTR)szNewFile, (LPSTR)szFontFile); <br> <br>            /* Do this thing that someone forgot.  THe dialog open does it <br>               and affects the Save As initialization. */ <br>            (HFILE)OpenFile((LPSTR)szNewFile, &amp;ofstrFile, OF_READ); <br> <br>            message = FONT_START; <br>            } <br>        else            /* Start by doing a regular file load */ <br>            message = FONT_LOAD; <br> <br>        SetFocus(hBox); <br>        PostMessage(hBox, WM_COMMAND, message, (LONG)0); <br>        } <br> <br>    if (!fLoaded) <br>        ShowWindow(hFont, SW_HIDE); <br> <br>    hAccel=LoadAccelerators(hInstance, "FE"); <br> <br>    /* Quit message will terminate application */ <br>    while (GetMessage((LPMSG)&amp;msg, NULL, 0, 0)) <br>        { <br>        if (!TranslateAccelerator (hBox, hAccel, &amp;msg)) <br>            { <br>            TranslateMessage((LPMSG)&amp;msg); <br>            DispatchMessage((LPMSG)&amp;msg); <br>            } <br>        } <br> <br>    return msg.wParam; <br>} <br> <br>/***************************************************************************** <br> * int FontEditInit( hInstance ) <br> * <br> * purpose: Initialises a whole lot of stuff <br> * <br> * params:  HANDLE hInstance : handle to instance of application <br> * <br> * returns:     TRUE : if everything goes off well <br> *             FALSE : error in initialisation <br> * <br> * side effects: a whole lot <br> * <br> ****************************************************************************/ <br> <br>/* Procedure called when the application is loaded */ <br>BOOL <br>FontEditInit( <br>        HANDLE hInstance <br>        ) <br>{ <br>    INT cch;          /* all variables used to load srings from .RC file */ <br>    INT cchRemaining; <br>    CHAR *pch; <br>    HANDLE hStrings; <br>    INT i; <br>    CHAR ColorStr[CCHCOLORSTRING]; /* background color inf. fronm win.ini */ <br>    BYTE bR, bG, bB;  /* the three primary color values ret. from win.ini */ <br>    // CHAR cDummy;      /* dummy char to hold the " " char */ <br>    PWNDCLASS   pFontEditClass;         /* Edit Box window class */ <br>    PWNDCLASS   pFontShowClass;         /* Show Font window class */ <br> <br>        // <br>        // Initialize the conversion routines to read in the old font structure <br>        // off of disk. <br>        // <br> <br>        if (fConvStructInit () == FALSE) { <br> <br>                return FALSE; <br>        } <br> <br>    /* load strings from resource file */ <br>    if (!(pch = (CHAR *)(hStrings = <br>                LocalAlloc (LPTR, cchRemaining = CCHSTRINGSMAX)))) <br>          return FALSE;        /* unable to alloc. Try increasing initial <br>                                  heapsize in .DEf file */ <br>    for (i=0; i&lt; CSTRINGS; i++){ <br>        cch = 1+LoadString (hInstance, (WORD) i, (LPTSTR)pch, cchRemaining); <br>        if (cch &lt; 2){ <br>            return FALSE; <br>                } <br>        vrgsz[i] = pch; <br>        pch += cch; <br>        if ((cchRemaining -= cch ) &lt;= 0) <br>            return FALSE; <br>    } <br> <br>    /* Allocate class structure in local heap */ <br>    pFontEditClass = (PWNDCLASS)LocalAlloc( LPTR, sizeof(WNDCLASS) ); <br>    if (pFontEditClass == NULL) <br>        return FALSE; <br> <br>    /* set up some default brushes */ <br>    hbrWhite = GetStockObject( WHITE_BRUSH ); <br>    hbrBlack = GetStockObject( BLACK_BRUSH ); <br>    hbrGray  = GetStockObject( GRAY_BRUSH ); <br>    hbrDkGray  = GetStockObject( DKGRAY_BRUSH ); <br> <br>    /* get App. Workspace color from win.ini - LR */ <br>    if (GetProfileString(vszcolors, vszAppWorkspace, "",ColorStr, <br>                                                       CCHCOLORSTRING)){ <br>        bR = (BYTE)atoi((const char *)strtok (ColorStr, " ")); <br>        bG = (BYTE)atoi((const char *)strtok (NULL, " ")); <br>        bB = (BYTE)atoi((const char *)strtok (NULL, "\n")); <br>        hbrBackGround = CreateSolidBrush(RGB(bR, bG, bB)); <br>    } <br>    else  /* set to lt. blue background */ <br>        hbrBackGround = CreateSolidBrush((LONG)0x00FF8000); <br> <br>    /* get necessary resources */ <br>    pFontEditClass-&gt;hCursor  = LoadCursor( NULL, IDC_ARROW); <br>    pFontEditClass-&gt;hIcon    = LoadIcon( hInstance,(LPSTR)vszFontEdit); <br>    pFontEditClass-&gt;lpszMenuName = (LPSTR)vszFontEdit; <br>    pFontEditClass-&gt;lpszClassName = (LPSTR)vszFontEdit; <br>    pFontEditClass-&gt;hbrBackground = hbrBackGround; <br>    pFontEditClass-&gt;hInstance     = hInstance; <br> <br>    pFontEditClass-&gt;style = CS_VREDRAW | CS_HREDRAW; <br> <br>    /* Register our Window Proc */ <br>    pFontEditClass-&gt;lpfnWndProc = (WNDPROC)FontEditWndProc; <br> <br>    /* register this new class with WINDOWS */ <br>    if (!hgPrev) <br>        if (!RegisterClass( (LPWNDCLASS)pFontEditClass ) ) <br>            return FALSE;   /* Initialization failed */ <br> <br>    /* Now repeat the performance for the Show window */ <br> <br>    pFontShowClass = pFontEditClass; <br>    /* get necessary resources */ <br>    pFontShowClass-&gt;hCursor  = LoadCursor(NULL,IDC_ARROW); <br>    pFontShowClass-&gt;hIcon    = (HICON)NULL; <br>    pFontShowClass-&gt;lpszMenuName = NULL; <br>    pFontShowClass-&gt;lpszClassName = (LPSTR)vszFontShow; <br>    pFontShowClass-&gt;hbrBackground = hbrGray; <br>    pFontShowClass-&gt;hInstance     = hInstance; <br>    pFontShowClass-&gt;style = CS_VREDRAW | CS_HREDRAW; <br> <br>    /* Register our Window Proc */ <br>    pFontShowClass-&gt;lpfnWndProc = (WNDPROC)FontShowWndProc; <br> <br>    /* register this new class with WINDOWS */ <br>    if (!hgPrev) <br>        if (!RegisterClass( (LPWNDCLASS)pFontShowClass ) ) <br>            return FALSE;   /* Initialization failed */ <br> <br>    LocalFree( (HANDLE)pFontShowClass ); <br> <br>    return TRUE;    /* Initialization succeeded */ <br>} <br> <br>/***************************************************************************** <br> * InitSizes() <br> * <br> * purpose: gets system char width and height <br> * <br> * params:  none <br> * <br> * returns: none <br> * <br> * side effects: sets width and height globals <br> * <br> ****************************************************************************/ <br>VOID <br>InitSizes( <br>        VOID <br>        ) <br>{ <br>    HDC hDC; <br>    TEXTMETRIC tm; <br> <br>    hDC = GetDC(hFont); <br>    GetTextMetrics(hDC, (LPTEXTMETRIC) &amp;tm); <br>    cSysHeight = tm.tmHeight + tm.tmExternalLeading;; <br>    cSysWidth  = tm.tmAveCharWidth; <br>    ReleaseDC(hFont, hDC); <br>} <br> <br> <br>/***************************************************************************** <br> * long  APIENTRY FontShowWndProc(hFont, message, wParam, lParam) <br> * <br> * purpose: Window function for tiny window at the bottom (showing font chars) <br> *          Independently processes paint, scroll, keyboard and mouse <br> *          messages for the window <br> * <br> * params:  as for window functions <br> * <br> * side effects: lots <br> * <br> ****************************************************************************/ <br> <br>/* Procedures which make up the window class. */ <br>LONG  APIENTRY <br>FontShowWndProc( <br>        HWND   hFont, <br>        WORD   message, <br>        WPARAM wParam, <br>        LPARAM lParam <br>        ) <br>{ <br>        PAINTSTRUCT  ps; <br>        // RECT         rectWin; <br>        POINT        pt; <br> <br>        ((pt).x = ((*((POINTS *)&amp;(lParam)))).x, (pt).y = ((*((POINTS *)&amp;(lParam)))).y); <br> <br>    switch (message) <br>    { <br> <br>        case WM_SIZE : <br>            switch (wParam){ <br>                /* if main window is iconised, hide the child window */ <br>                case SIZEICONIC : <br>                    ShowWindow(hFont, SW_HIDE); <br>                    break; <br>                default: <br>                    return(DefWindowProc(hFont, message, wParam, lParam)); <br>                    break; <br>            } <br>            break; <br> <br> <br>        case WM_PAINT: <br>            /* Time for the window to draw itself. */ <br>            BeginPaint(hFont, (LPPAINTSTRUCT)&amp;ps); <br>            FontShowPaint(ps.hdc); <br>            EndPaint(hFont, (LPPAINTSTRUCT)&amp;ps); <br>            break; <br> <br>        /* For each of following mouse window messages, wParam contains <br>        ** bits indicating whether or not various virtual keys are down, <br>        ** and lParam is a POINT containing the mouse coordinates.   The <br>        ** keydown bits of wParam are:  MK_LBUTTON (set if Left Button is <br>        ** down); MK_RBUTTON (set if Right Button is down); MK_SHIFT (set <br>        ** if Shift Key is down); MK_ALTERNATE (set if Alt Key is down); <br>        ** and MK_CONTROL (set if Control Key is down). */ <br> <br>        case WM_LBUTTONDOWN: <br>            MouseInFont(pt);              /* .. set iChar */ <br>            break; <br>        case WM_LBUTTONUP: <br>            MouseOutFont(pt);     /* .. set jChar */ <br>            break; <br>        case WM_RBUTTONDOWN: <br>        case WM_RBUTTONUP: <br>        case WM_MOUSEMOVE:                      /* If mouse is down */ <br>            if (wParam &amp; MK_LBUTTON) <br>                MouseMoveFont(pt);        /* .. set jChar */ </code></pre>
<p>
</p>
<pre><code>break; <br>        case WM_LBUTTONDBLCLK: <br>        case WM_RBUTTONDBLCLK: <br>            break; <br> <br>        case WM_HSCROLL: <br>            /* wParam contains the scroll code. <br>            ** For the thumb movement codes, the low <br>            ** word of lParam contain the new scroll position. <br>            ** Possible values for wParam are: SB_LINEUP, SB_LINEDOWN, <br>            ** SB_PAGEUP, SB_PAGEDOWN, SB_THUMBPOSITION, SB_THUMBTRACK */ <br>            /* Horizontal scroll bar input.  Parameters same as for <br>            ** WM_HSCROLL.  UP and DOWN should be interpreted as LEFT <br>            ** and RIGHT, respectively. */ <br>            FontShowHorzScroll(hFont, LOWORD(wParam), <br>                                HIWORD(wParam)); <br>            break; <br>        case WM_CLOSE: <br>            break;   /* don't allow this window to be closed before <br>                        bigger one */ <br> <br>        default: <br> <br>            /* Everything else comes here.  This call MUST exist <br>            ** in your window proc.  */ <br> <br>            return(DefWindowProc(hFont, message, wParam, lParam)); <br>            break; <br> <br>    } <br> <br>    /* A window proc should always return something */ <br>    return(0L); <br>} <br> <br> <br>VOID <br>FontRename( <br>        CHAR * szError <br>        ) <br>{ <br>    CHAR *szTitle[MAX_STR_LEN+MAX_FNAME_LEN]; <br> <br>    if (szError[0]) <br>        ErrorBox(hBox, szError); <br>    else <br>        { <br>        lstrcpy((LPSTR)szFontFileFull, (LPSTR)szNewFile); <br>        lstrcpy((LPSTR)szTitle, (LPSTR)szAppName); <br>        lstrcat((LPSTR)szTitle, (LPSTR)vszBlankDashBlank); <br>        lstrcat((LPSTR)szTitle, (LPSTR)szFontFile); <br>        SetWindowText(hBox, (LPSTR)szTitle); <br>        } <br>} <br> <br> <br>/***************************************************************************** <br> * ResizeShow() <br> * <br> * purpose:   resize tiny window at bottom (showing font chars) in proportion <br> *            to large window <br> * <br> * params:    none <br> * <br> * returns:   none <br> * <br> * side effects: <br> * <br> ****************************************************************************/ <br> <br>VOID <br>ResizeShow( <br>        VOID <br>        ) <br>{ <br>        INT    height; <br>        INT    nx; <br> <br>    /* size message for hbox goes thru before hfont created. 06-Jul-1987. */ <br>    if (!hFont) <br>        return; <br> <br>    GetWindowRect(hBox, (LPRECT)&amp;rectWin); <br>    kStuff = GetkStuff();               /* For check on second pass */ <br> <br>#if 0 <br>    height = font.PixHeight + kStuff + 20;  /* 4 Height we want box */ <br>#else <br>    height = font.PixHeight + GetSystemMetrics(SM_CYHSCROLL) <br>                            + GetSystemMetrics(SM_CYCAPTION) <br>                            + 4*GetSystemMetrics(SM_CYBORDER)/*20*/;     /* 4*/ <br>#endif <br> <br>     nx=GetSystemMetrics(SM_CXBORDER); <br>     MoveWindow(hFont, <br>                rectWin.left +nx+4, <br>                rectWin.bottom - (height + GetSystemMetrics(SM_CYBORDER)+2), <br>                min(300, rectWin.right - rectWin.left-nx-nx), <br>                height, <br>                TRUE); <br>    if (!IsWindowVisible(hFont) &amp;&amp; fLoaded) <br>        ShowWindow(hFont, SW_SHOW); <br>} <br> <br> <br>DWORD <br>GetkStuff( <br>        VOID <br>        )     /* Get size of menu, scrollbar etc. */ <br>{ <br>        RECT rect, rectWin; <br> <br>    /* size message for hbox goes thru before hfont created. 06-Jul-1987. */ <br>    if (!hFont) <br>        return 0; <br> <br>    GetClientRect(hFont, (LPRECT)&amp;rect);     /* How much do WE get? */ <br>    GetWindowRect(hFont, (LPRECT)&amp;rectWin); <br>    return (DWORD) (rectWin.bottom - rectWin.top) - (rect.bottom - rect.top); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
