<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TYPECVT.H</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5399"></a>TYPECVT.H</h2>
<pre><code>/*++ <br> <br>Copyright 1993 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    typecvt.h <br> <br>Abstract: <br> <br>    Header file for typecvt.c.  Contains any defines, structures and prototypes <br>    which are needed by programs to call the typecvt routines. <br> <br> <br>--*/ <br> <br> <br>// Make sure we are not already defined. <br> <br>#ifndef _TYPECVT_ <br> <br>#define _TYPECVT_ <br> <br>// <br>// The following preprocessor directives are used to control possible <br>// differences between the way integers are stored on the machine and <br>// how they are stored in the file.  Normally Intel and MIPS chips will <br>// all be little endian so these should not be necessray.  Some time in <br>// the future we may port to a machine which is only big endian. <br>// If this is the case CVT_BIG_ENDIAN_SUPPORT should be defined. <br>// <br> <br>// <br>// The following defines are used to set the type of source and destination <br>// structures.  For those of us who are confused by little endian and big <br>// endian formats, here is a breif recap. <br>// <br>// Little Endian:  (This is used on Intel chips.  The MIPS chip is switchable <br>//      but for NT is will run in little endian format.) <br>//    This is where the high order bytes of a short or long are stored higher <br>//    in memory.  For example the number 0x80402010 is stored as follows. <br>//      Address:        Value: <br>//          00            10 <br>//          01            20 <br>//          02            40 <br>//          03            80 <br>//    This looks backwards when memory is dumped in order: 10 20 40 80 <br>// <br>// Big Endian:  (This is not currently used on any NT systems but hey, this <br>//      is supposed to be portable!!) <br>//    This is where the high order bytes of a short or long are stored lower <br>//    in memory.  For example the number 0x80402010 is stored as follows. <br>//      Address:        Value: <br>//          00            80 <br>//          01            40 <br>//          02            20 <br>//          03            10 <br>//    This looks correct when memory is dumped in order: 80 40 20 10 <br>// <br> <br>#define   CVT_ENDIAN_UNKNOWN  0   // Endian type is unknown. (do not use). <br>#define   CVT_LITTLE_ENDIAN   1   // Format is little endian. <br>#define   CVT_BIG_ENDIAN      2   // Format is big endian. <br> <br>// <br>// Define the endian type of the file.  CVT_FILE_ENDIAN_DEFAULT defines how <br>// most files are stored on disk.  The default is in little endian since most <br>// Microsoft standards are set based on the Intel chip. <br>// <br> <br>#define         CVT_FILE_ENDIAN_DEFAULT        CVT_LITTLE_ENDIAN <br> <br>// <br>// The following variables are used to make "changeable defines."   They <br>// allow the caller to specify a constant which changes from system to <br>// system. <br>// <br> <br>extern INT vfFileEndianType; <br>extern INT vfSysEndianType; <br> <br>#define   CVT_ENDIAN_FILE     vfFileEndianType <br>#define   CVT_ENDIAN_SYSTEM   vfSysEndianType <br> <br>// <br>// Fake structure used to determine system alignment type. <br>// <br> <br>struct tagAlignmentCheck <br>{ <br>charchElem1;// Note that this structure will be different <br>long  lElem2;// sizes based on the system alignment scheme. <br>// The different values follow. <br>}; <br> <br>// <br>// Note that the following defines must correspond to the size of the <br>// preceeding structure in different packing schemes. <br>// <br> <br>#define   CVT_ALIGN_PACKED      5   // Packed = 1-byte boundry ... <br>#define   CVT_ALIGN_WORD        6   // WORD = 2-byte boundry ... <br>#define   CVT_ALIGN_DWORD       8   // DWORD = 4-byte boundry ... <br> <br>// <br>// The following will correspond to one of the above alignment methods and <br>// will then reflect the system that this is compiled under. <br>// <br> <br>#define   CVT_ALIGN_SYSTEM      sizeof(struct tagAlignmentCheck) <br> <br> <br>// <br>// The next two structures are the heart of the conversion process.  The <br>// goal here is to describe two structures individually.  Each element should <br>// be defined in a SDI structure.  An array of these structures will make up <br>// the complete definition. <br>// <br> <br>typedef struct tagStructDefineInfo <br>{ <br>    INT     cTypeSize;          // Size of type. (ex. sizeof (int)). <br>    INT     cActualSize;        // Actual size (ex. sizeof (cTypeSize)). <br>    INT     oPackedAlign;      // Offset of element in PACKED alginment. <br>    INT     oWordAlign;        // Offset of element in WORD alginment. <br>    INT     oDWordAlign;       // Offset of element in DWORD alginment. <br>} SDI, * PSDI; <br> <br>// <br>// Prototypes for base functions which user can call to perfom the conversion. <br>// <br> <br>LONG <br>lCalculateStructOffsets ( <br>     PSDI    rgsdiStructDefine, <br>     INT     fAlignmentType, <br>  INT             cSizeOfStruct <br>    ); <br> <br>VOID <br>vPerformConversion ( <br>     PSDI    rgsdiStructDefine, <br>     PBYTE   pjSrcBuffer, <br> INTfSrcAlignment, <br> INTfSrcEndianType, <br>    PBYTE   pjDestBuffer, <br> INTfDestAlignment, <br> INTfDestEndianType <br>    ); <br> <br>VOID <br>vSetFileEndianType ( <br>    BOOL     fNewEndianType <br>    ); <br> <br>INT <br>fDetermineSysEndianType ( <br>VOID <br>    ); <br> <br>// <br>// Prototypes for convertion functions available to external programs. <br>// These functions are never actually used by <br>// <br> <br>VOID <br>vCharToShort ( <br>          PBYTE  pjSrc, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vCharToUShort ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vCharToLong ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vCharToULong ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vShortToShort ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vShortToLong ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vShortToULong ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vLongToLong ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vLongToShort ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vLongToChar ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br>VOID <br>vShortToChar ( <br>          PBYTE  pjSource, <br>         PBYTE  pjDest <br>         ); <br> <br>// <br>// The following functions are the ones called by the utility functions. <br>// They could also be used in some other situations so I will make them <br>// public. <br>// <br> <br>SHORT <br>sSHORTFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ); <br>USHORT <br>usUSHORTFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ); <br>LONG <br>lLONGFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ); <br>ULONG <br>ulULONGFromSrcBuff ( <br>         PBYTE   pjSrc <br>    ); <br> <br> <br>VOID <br>vDestBuffFromSHORT ( <br>         SHORT   sSource, <br>        PBYTE   pjDest <br>    ); <br>VOID <br>vDestBuffFromUSHORT ( <br>         USHORT  usSource, <br>        PBYTE   pjDest <br>    ); <br>VOID <br>vDestBuffFromLONG ( <br>         LONG    lSource, <br>        PBYTE   pjDest <br>    ); <br>VOID <br>vDestBuffFromULONG ( <br>         ULONG   ulSource, <br>        PBYTE   pjDest <br>    ); <br> <br>#endif  // _TYPECVT_ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
