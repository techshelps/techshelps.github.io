<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONTLOAD.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5396"></a>FONTLOAD.C</h2>
<pre><code>#include "windows.h" <br>#include &lt;windowsx.h&gt; <br>#include "fontedit.h" <br>#include "fcntl.h" <br>#include "memory.h" <br>#include "stdio.h" <br>#include "commdlg.h" <br> <br> <br>/****************************************************************************/ <br>/*              Shared Variables                                            */ <br>/****************************************************************************/ <br>extern CHAR *PASCAL VerifyHeaderContents();/* checks integrity of header */ <br> <br>extern FontHeaderType font;             /* Structure of Font File Header */ <br>extern LONG lSizeOfOldGlyph20;          /* Old packed 2.0 glyph info size. */ <br>extern LONG lSizeOfOldGlyph30;     /* Old packed 3.0 glyph info size. */ <br>extern LONG lSizeOfOldFontHeader;       /* Old packed font header size. */ <br>extern LONG lSizeOfOldFontHeader30;     /* Old 3.0 packed font header size. */ <br>extern CHAR szFaceName[];               /* Face Name of Font */ <br>extern DWORD offsets[];                 /* Offsets Table */ <br> <br>extern BOOL fReadOnly; <br>extern BOOL fChanged;                   /* Note if we did anything */ <br>extern BOOL fLoaded;                    /* Set if a font is loaded */ <br>extern INT iFontFormatPrev;             /* Set to the id of prev.font format */ <br>extern INT iFontFormat;             /* Set to the id of current font format */ <br> <br>extern HWND hFont;                      /* Handle to Show window */ <br>extern HWND hBox;                       /* Handle to Edit Window */ <br>extern HDC hMemDC;                      /* Handle to Memory Display Context */ <br>extern HBITMAP hBitmap;                 /* Handle to our work bit map */ <br>extern CHAR matBox [wBoxLim] [kBoxLim]; /* array to hold Box */ <br> <br>extern CHAR *vrgsz[];                   /* string table */ <br>extern OFSTRUCT ofstrFile; <br>extern BOOL NewFile;                    /* flag indicating if file was opened <br>                                           by selecting NEW on menu */ <br>FontHeaderType fontBuffer;          /* temporary buffer of Font File Header */ <br>WORD cHeader, cTable; <br>HFILE nNewFile;                          /* NT file handle */ <br> <br> <br>/****************************************************************************/ <br>/*              Local Variables                                             */ <br>/****************************************************************************/ <br> <br>DWORD Proport(DWORD, DWORD, DWORD, DWORD);  /* Reproportions a value */ <br> <br>CHAR  *lpFontBody = NULL;  /* Pointer to Font Body */ <br>CHAR  *lpWork = NULL;      /* Pointer to Work Area */ <br>HDC hNewMemDC; <br>HDC hBoxMemDC; <br>HBITMAP hNewBitmap; <br>HBITMAP hBoxBitmap; <br>HCURSOR hOldCursor = NULL;      /* Holds Arrow while we show Hourglass */ <br>HCURSOR hHourGlass = NULL; <br>DWORD oldMode;                   /* For StretchBltMode */ <br>BYTE  *lp1,  *lp2;    /* Pointers to bitmaps in format N */ <br> <br>FontHeader30  font30; <br> <br>#define ALPHA_CNT        26 <br>#define TOTAL_WEIGHTS  1000 <br>#define FSF_FIXED             0x0001 <br>#define FSF_PROPORTIONAL      0x0002 <br> <br>SHORT widthweights[ALPHA_CNT + 1] = <br>        { <br>                 64,        /* a <br>                 14,        /* b     */ <br>                 27,        /* c     */ <br>                 35,        /* d     */ <br>                100,        /* e     */ <br>                 20,        /* f     */ <br>                 14,        /* g     */ <br>                 42,        /* h     */ <br>                 63,        /* i     */ <br>                 3 ,        /* j     */ <br>                 6 ,        /* k     */ <br>                 35,        /* l     */ <br>                 20,        /* m     */ <br>                 56,        /* n     */ <br>                 56,        /* o     */ <br>                 17,        /* p     */ <br>                 4 ,        /* q     */ <br>                 49,        /* r     */ <br>                 56,        /* s     */ <br>                 71,        /* t     */ <br>                 31,        /* u     */ <br>                 10,        /* v     */ <br>                 18,        /* w     */ <br>                 3 ,        /* x     */ <br>                 18,        /* y     */ <br>                 2 ,        /* z     */ <br>                166,        /* space, must be last, to use with the following <br>                               code */ <br>        }; <br> <br>/****************************************************************************/ <br>/*              Local Functions                                             */ <br>/****************************************************************************/ <br> <br>VOID NewAverage(VOID); <br>BOOL GetNewMap(DWORD, DWORD); <br>VOID UseNewMap(VOID); <br>VOID ShrinkFont(DWORD, DWORD); <br> <br>/**************************************************************************** <br> * WORD ConvertToBitmapFormat(width, phase, height) <br> * <br> * purpose  : Takes a part of the font file and converts it to a string of <br> *            bytes for a single scan of bitmap for a character. <br> * <br> * params   : WORD width : width of the character in pixels(bits) <br> *            WORD phase : current deviation from byte alignment (pixels) <br> *            WORD height: height of character(pixels) <br> * <br> * returns  : WORD phase : new deviation from byte alignment (pixels) <br> * <br> * side effects : modifies pointers lp1 and lp2 (pointing to work space and <br> *                font body respectively) <br> * <br> ****************************************************************************/ <br>DWORD PASCAL <br>ConvertToBitmapFormat( <br>     DWORD width,     /* width of the character in pixels(bits) */ <br>     DWORD phase,     /* current deviation from byte alignment (pixels) */ <br>     DWORD height     /* height of character(pixels) */ <br>     ) <br>{ <br>      INT w; <br>      WORD j; <br> <br>      /* in the font file format characters are stored consecutively in <br>         column-major ordering (columns of char 1 followed by columns of char <br>         2 ... etc.). lp2 points to start of columns of current character. <br>         lp1 points to start of row of bitmap for character. */ <br> <br>      for (w = width; w &gt; 0; w -= 8){ <br>          if (phase == 0){ <br>          /*  easy case */ <br>              *lp1++ = *lp2; <br> <br>              if (w &lt; 8) <br>                  phase = w; <br>          } <br>          else{ <br> <br>              --lp1; <br>              j = (WORD)*lp1; <br>              j &lt;&lt;= 8; <br>              j |= (((WORD)*lp2) &lt;&lt; (8 - phase)); <br>              *lp1++ = (BYTE)(j &gt;&gt; 8); <br>              *lp1++ = (BYTE)j; <br>              if (w &lt; 8){ <br>                  phase += w; <br>                  if (phase &lt;= 8) <br>                      lp1--;          /* back up pointer */ <br>                  phase &amp;= 7; <br>              } <br>          } <br>          lp2 += height;          /* move to next column */ <br>      } <br>      return phase; <br>} <br> <br>/**************************************************************************** <br> * char * VerifyTableContents() <br> * <br> * purpose  : scan the offsets table of file just read and check if <br> *            width and offsets lie within limits <br> * <br> * params    : none <br> * <br> * returns   : char * szError : ptr to Error message if table not OK <br> *                              NULL otherwise <br> * <br> * side effects : none <br> * <br> ****************************************************************************/ <br>CHAR * PASCAL <br>VerifyTableContents( <br>    VOID <br>    ) <br>{ <br> PBYTE  pjGlyphData; <br>     GLYPHINFO_20 gi2T20;        /* temp ptr to a 2.0 style table*/ <br>     GLYPHINFO_30 gi3T30;        /* temp ptr to a 2.0 style table*/ <br>     INT i; <br> <br>     /* separate loops written for the 2.0 and 3.0 font processing because <br>        a single loop would involve too many checks (of font type) within <br>        the loop and slow down processing  */ <br>     if (iFontFormat == ID_FORMAT2){ <br>         pjGlyphData = (lpFontBody +1); <br> <br>/* view table as 2.0 table */ <br> <br>         /* check that each and every width and offset lie within limits */ <br> <br>         for (i=0; i &lt; (fontBuffer.LastChar - fontBuffer.FirstChar + 1); i++) { <br> <br>  vGlyphInfo20FromBuffer (pjGlyphData, &amp;gi2T20); <br> <br>              if (gi2T20.GIwidth &gt; 64) <br>                  return vszTableWidthsBad; <br> <br>              if ((gi2T20.GIoffset &gt; (UINT)WORD_LIMIT) || <br>                  (gi2T20.GIoffset &lt; 0) ) <br>                  return vszTableOffsetsBad; <br> <br>  pjGlyphData += lSizeOfOldGlyph20; <br>         } <br>     } <br>     else{ <br> <br>         pjGlyphData = lpFontBody; <br> <br>            /* view table as 3.0 table */ <br>         /* check that each and every width and offset lie within limits */ <br> <br>         for (i=0; i&lt; (fontBuffer.LastChar - fontBuffer.FirstChar +1); i++) { <br> <br>  vGlyphInfo30FromBuffer (pjGlyphData, &amp;gi3T30); <br> <br>              if (gi3T30.GIwidth &gt; 64) <br>                  return vszTableWidthsBad; <br> <br>              if (gi3T30.GIoffset &lt; (DWORD)0) <br>                  return vszTableOffsetsBad; <br> <br>  pjGlyphData += lSizeOfOldGlyph30; <br>         } <br>     } <br>     return NULL; <br>} <br> <br>/**************************************************************************** <br> * char * FontLoad() <br> * <br> * purpose: reads in the specified font file and creates a work bitmap for <br> *          the editor. Also creates a local bitmap-offset table for easy <br> *          access to the characters in the bitmap <br> * <br> * params : pszFileName - File Name to open. <br> * <br> * returns: ptr to NULL string if Open goes off OK <br> *          ptr to error message string otherwise <br> * <br> * side effects: lots <br> * <br> ****************************************************************************/ <br>CHAR * <br>FontLoad( <br>    CHAR *pszFileName, <br>OFSTRUCT*pofsReOpenInfo <br>    ) <br>{ <br> <br>    CHAR  *lpFontBodySav = NULL;  /* local pointer to font body */ <br>    DWORD len, fontlen;               /* length of font body (bytes)*/ <br>UINT i; <br>    INT mf;                      /* menu function ID */ <br>    DWORD iWorkLen;                   /* length of work area (bytes) */ <br>    HDC hDC; <br>    CHAR * pszError;                   /* error msg if header is messed up */ <br> <br>    DWORD row, height, width,phase; <br>    DWORD offset; <br>    GLYPHINFO_20 gi2GlyphTable20;    /* Pointer into 2.0 style offsets table */ <br>    GLYPHINFO_30 gi3GlyphTable30;    /* Pointer into 3.0 style offsets table */ <br>PBYTE pjGlyphData; /* Pointer to Glyph information buffer. */ <br> <br>    BYTE  cDummy [CCHEXTRA];         /* dummy buffer for unneeded 3.0 header <br>                                    * info <br>                                    */ <br> <br>    /* Put up an hourglass ... this may take a while */ <br>    if (!hHourGlass) <br>        hHourGlass = LoadCursor(NULL, IDC_WAIT);        /* Get Hourglass */ <br>    hOldCursor = SetCursor(hHourGlass);         /* Show hourglass */ <br> <br>    /* open file for read. */ <br>nNewFile = (HFILE)OpenFile (pszFileName, pofsReOpenInfo, OF_READ); <br> <br>if (nNewFile &lt; 0) { <br> <br>return vszErrorOpeningFile; <br>} <br> <br>//- ReadFile:  Here is where we need to make some adjustments in order to <br>//- read the file in to a new DWORD aligned format. <br>{ <br>BYTE    jBuffer [200]; <br> <br> <br>/* Read the header */ <br>if (_lread ((HFILE) nNewFile, (LPSTR)&amp;jBuffer, lSizeOfOldFontHeader) != <br>(UINT)lSizeOfOldFontHeader) { <br> <br>_lclose((HFILE)nNewFile); <br>return vszErrorReadingHdr; <br>} <br> <br>// <br>// Call conversion routine to give us a properly aligned buffer. <br>// <br> <br>vFontStructFromBuffer ( <br> (PBYTE)&amp;jBuffer, <br> &amp;fontBuffer <br>); <br> <br>} <br> <br>    /* Check the version number -- make sure it's a font */ <br>    switch (fontBuffer.Version) <br>        { <br>        case 0x200: <br>                iFontFormat = ID_FORMAT2; <br>                break; <br>        case 0x300:        /* added 1/19/88 */ <br>                iFontFormat = ID_FORMAT3; <br>                /* read in the extra fields into a dummy buffer ... they don't <br>                 * mean anything to us  at this stage. <br>                 */ <br>                if ((_lread((HFILE)nNewFile, (LPSTR)cDummy, CCHEXTRA)) <br>                            != CCHEXTRA){ <br>                    _lclose((HFILE)nNewFile); <br>                    return vszErrorReadingHdr; <br>                } <br> <br>                break; <br>        default:                /* Anything else -- toughies */ <br>                _lclose((HFILE)nNewFile); <br>                return vszUnknownFormat; <br>        } <br> <br>    /* check if contents of font header are sensible. If not, <br>       give an error message and quit */ <br> <br>    if ((pszError = VerifyHeaderContents()) != NULL) { <br> <br>_lclose((HFILE)nNewFile); <br>        return pszError; <br>} <br> <br>    /* Ready to load -- Check if we will be overwriting */ <br>    if (fLoaded) <br>{ <br>        DeleteGlobalBitmap(); <br>        fLoaded = FALSE; <br>} <br> <br>    /* Allocate space for font body and Face Name and read them in */ <br>    len= (fontBuffer.Size - lSizeOfOldFontHeader);  /* Compute size */ <br> <br>    if ((lpFontBody = (LPSTR)GlobalAlloc(GMEM_ZEROINIT, (LONG)len)) == 0) { <br> <br>_lclose((HFILE)nNewFile); <br>        return vszNotEnoughMem;                       /* Get Handle to space */ <br>} <br> <br>    if (iFontFormat == ID_FORMAT3) <br>        fontlen = len - CCHEXTRA; <br>    else <br>        fontlen = len; <br> <br>    lpFontBodySav = lpFontBody;                    /* save ptr to font body */ <br>    while (fontlen &gt;= (DWORD)SEGMENT_SIZE) { <br> <br>        /*  file read method if font file size is 64k bytes or greater. <br>            file is read in in chunks of 65536 (SEGMENT_SIZE), taking care to <br>            position buffer ptr at 64k boundary each time */ <br> <br>        /* First read in the maximum number of bytes _lread can read (65534) */ <br>        if ((_lread((HFILE)nNewFile, lpFontBodySav, WORD_LIMIT)) == WORD_LIMIT) { <br> <br>            lpFontBodySav += WORD_LIMIT; /* buffer ptr moved up by 64k bytes */ <br>            fontlen -= WORD_LIMIT;     /* fontlen = no of bytes left to read */ <br> <br>} else { <br> <br>GlobalFree (lpFontBody); <br>_lclose((HFILE)nNewFile); <br>            return vszErrorReadingBody; <br>} <br> <br>        /* read in an additional two bytes to reach end of segment */ <br>        if ((_lread((HFILE)nNewFile, lpFontBodySav, 2)) == 2) { <br> <br>            lpFontBodySav += 2; /* buffer ptr moved up by 2 bytes */ <br>            fontlen -= 2;       /* fontlen = no of bytes left to read */ <br> <br>        } else { <br> <br>GlobalFree (lpFontBody); <br>_lclose((HFILE)nNewFile); <br>            return vszErrorReadingBody; <br>        } <br>} <br> <br>    /* read the partially filled segment  */ <br>    if ((_lread((HFILE)nNewFile, lpFontBodySav, (DWORD)fontlen)) != (UINT) fontlen) { <br> <br>        GlobalFree (lpFontBody); <br>        _lclose((HFILE)nNewFile); <br>        return vszErrorReadingBody; <br>} <br> <br>    /* Close the file */ <br>    _lclose((HFILE)nNewFile); <br> <br>    /* check if the offset table entries are within allowable limits. <br>       If not give an error message, clean up and quit */ <br>    if ((pszError = VerifyTableContents()) != NULL) { <br> <br>        GlobalFree (lpFontBody); <br>        return pszError; <br>} <br> <br>    /* now that everything has been checked, move buffer to font */ <br>    font = fontBuffer; <br> <br>    /* Make local copies of FaceName and Device Name */ <br>    if (font.Face){ <br> <br>        lstrcpy((LPSTR)szFaceName, lpFontBody + font.Face - <br>                                         (iFontFormat == ID_FORMAT2 ? <br>                                                    lSizeOfOldFontHeader   : <br>                                                    lSizeOfOldFontHeader30-1)); <br>    } else { <br> <br>        lstrcpy((LPSTR)szFaceName, (LPSTR)""); <br>} <br> <br>    for (i = 0; i &lt;= 256; i++)      /* Zero offsets Table for below */ <br>        offsets[i] = 0; <br> <br>    /* compute work space needed if a 3.0 file. This has to be done since <br>       3.0 files are compressed versions of 2.0 files and may need a <br>       work bitmap bigger than the actual font body size */ <br> <br>    if (iFontFormat == ID_FORMAT3) { <br> <br>        cTable = (WORD) (6 * (font.LastChar - font.FirstChar + 2)); <br>        iWorkLen = 0; <br> <br>        pjGlyphData = lpFontBody; <br> <br>        /* work bitmap size = sum of sizes of all characters in font */ <br> <br>        for (i = font.FirstChar; i &lt;= font.LastChar; i++) { <br> <br> vGlyphInfo30FromBuffer (pjGlyphData, &amp;gi3GlyphTable30); <br> <br>             iWorkLen += ((gi3GlyphTable30.GIwidth +7) &gt;&gt; 3) * font.PixHeight; <br> <br> pjGlyphData += lSizeOfOldGlyph30; <br>} <br> <br>    } else { /* 2.0 file */ <br> <br>        cTable = (WORD)(4 * (font.LastChar - font.FirstChar + 2)); <br>           /* compute table length */ <br>        iWorkLen = len;  /* work space for a 2.0 file is the same as the <br>                             length of the font body */ <br>    } <br> <br>//- Add some extra space for dword alignment. <br>iWorkLen += (font.PixHeight * sizeof (DWORD)); <br>      /* Get work space */ <br> <br>    if ((lpWork = (LPSTR)GlobalAlloc (GMEM_ZEROINIT, (LONG)iWorkLen)) == 0) { <br> <br>        GlobalFree (lpFontBody); <br>        return vszNotEnoughMem; <br>    } <br> <br>lp1 = lpWork; <br> <br>    height = (DWORD) font.PixHeight; <br>    offset = 0; <br>    /* put the font file into bitmap format */ <br>    if (iFontFormat == ID_FORMAT2){         /* table in 2.0 format */ <br>        for (row = 0; row &lt; height; row++){ <br> <br>             /* view table as a 2.0 style table */ <br>             pjGlyphData = lpFontBody + 1; <br> <br>             phase = 0; <br> <br>             for (i = 0; i &lt; (UINT)(font.LastChar - font.FirstChar + 1); i++) { <br> <br>vGlyphInfo20FromBuffer (pjGlyphData, &amp;gi2GlyphTable20); <br> <br>                width = (DWORD) gi2GlyphTable20.GIwidth; <br> <br>                /* size of each table element = 4bytes */ <br>                lp2 = lpFontBody + (gi2GlyphTable20.GIoffset - <br>lSizeOfOldFontHeader) + row; <br> <br>pjGlyphData += lSizeOfOldGlyph20; <br> <br>                /* offset ends up as the sum of the widths */ <br>                if (row == 0)              /* Once is enough */ <br>offsets[i + font.FirstChar + 1] = offset += width; <br> <br>                /* create a single scan of bitmap for character */ <br>                phase = ConvertToBitmapFormat (width, phase, height); <br>             } <br>             if ((lp1 - lpWork) &amp; 1) <br>                 *lp1++ = 0;             /* Round lp1 up to Word Boundary */ <br>#ifdef DWORDROUND <br>             if ((lp1 - lpWork) &amp; 2) { <br>                 *lp1++ = 0;             /* Round lp1 up to DWord Boundary */ <br>                 *lp1++ = 0;             /* Round lp1 up to DWord Boundary */ <br> } <br>#endif <br>             //if (((offset + 7) &gt;&gt; 3) &amp; 1) <br>                 //*lp1++ = 0;             /* Round lp1 up to Word Boundary */ <br>             //if (((offset + 7) &gt;&gt; 3) &amp; 2) { <br>                 //*lp1++ = 0;             /* Round lp1 up to DWord Boundary */ <br>                 //*lp1++ = 0;             /* Round lp1 up to DWord Boundary */ <br> //} <br>        } <br>    } <br>     /* separate loops written for the 2.0 and 3.0 font processing because <br>        a single loop would involve too many checks (of font type) within <br>        the loop and slow down processing  */ <br>    else {                                 /* table in 3.0 format */ <br> <br>        for (row = 0; row &lt; height; row++){ <br> <br>             phase = 0; <br>             /* view table as a 3.0 style table */ <br>             pjGlyphData = lpFontBody; <br> <br>             for (i = 0; i &lt; (UINT)(font.LastChar - font.FirstChar + 1); i++) { <br> <br>vGlyphInfo30FromBuffer (pjGlyphData, &amp;gi3GlyphTable30); <br> <br>                width = gi3GlyphTable30.GIwidth; <br> <br>                  /* size of each table element = 6bytes */ <br>                lp2 = lpFontBody + (gi3GlyphTable30.GIoffset - <br>lSizeOfOldFontHeader30 +1) + row; <br> <br>pjGlyphData += lSizeOfOldGlyph30; <br> <br>                 /* offset ends up as the sum of the widths */ <br>                if (row == 0)              /* Once is enough */ <br>                    offsets[i + font.FirstChar + 1] = offset += width; <br> <br>                 /* create a single scan of bitmap for character */ <br>                phase = ConvertToBitmapFormat (width, phase, height); <br>             } <br>             if ((lp1 - lpWork) &amp; 1) <br>                 *lp1++ = 0;             /* Round lp1 up to Word Boundary */ <br>#ifdef DWORDROUND <br>             if ((lp1 - lpWork) &amp; 2) { <br>                 *lp1++ = 0;             /* Round lp1 up to DWord Boundary */ <br>                 *lp1++ = 0;             /* Round lp1 up to DWord Boundary */ <br> } <br>#endif <br>        } <br>    } <br>             // FontLoad(): width byte is DWORD align <br>    font.WidthBytes = (WORD) CJ_DIB_SCAN(offset); <br>       /* fixup NEWFON error */ <br> <br>    GlobalFree(lpFontBody); <br>    lpFontBody = lpWork;          /* So that below we free the other buffer */ <br>    /* Create a WINDOWS bitmap to move the font definition bits into */ <br> <br>    hDC = GetDC (hFont);                         /* DC to be compatible with */ <br>    hBitmap = CreateBitmap( <br>                    (INT)font.WidthBytes &lt;&lt; 3, /* Width of font in pixels */ <br>                    (INT)font.PixHeight, <br>                    1, 1, (LPBYTE)NULL); <br>    hMemDC = CreateCompatibleDC(hDC);           /* Create a DC */ <br>    SelectObject(hMemDC, hBitmap);              /* Relate the two of them */ <br>    ReleaseDC(hFont, hDC);                      /* Done with font DC */ <br> <br>    /* Move the bits in */ <br>    SetBitmapBits(hBitmap, <br>          (DWORD)font.WidthBytes * (DWORD)font.PixHeight,(CHAR  *)lpWork); <br> <br>    /* Free up the space we loaded the file into */ <br>    GlobalFree(lpFontBody); <br>    fLoaded = TRUE; <br>    { <br>        HMENU hMenu; <br> <br>        hMenu = GetMenu(hBox);  /* Gray menu if no clipboard bitmap */ <br>        mf = (font.Family &amp; 1) ? MF_ENABLED : MF_GRAYED; <br>        EnableMenuItem(hMenu, FONT_SAVE, MF_ENABLED); <br>        EnableMenuItem(hMenu, FONT_SAVEAS, MF_ENABLED); <br>        EnableMenuItem(hMenu, 1, MF_BYPOSITION | MF_ENABLED); <br>        EnableMenuItem(hMenu, 2, MF_BYPOSITION | MF_ENABLED); <br>        EnableMenuItem(hMenu, 3, MF_BYPOSITION | MF_ENABLED); <br>        EnableMenuItem(hMenu, 4, MF_BYPOSITION | mf); <br>        EnableMenuItem(hMenu, 5, MF_BYPOSITION | MF_ENABLED); <br>        EnableMenuItem(hMenu, 6, MF_BYPOSITION | MF_ENABLED); <br>        DrawMenuBar(hBox); <br>    } <br>    SetCursor(hOldCursor);              /* Restore regular cursor */ <br>    return ""; <br>} <br> <br>/************************************** <br> * compares nBytes bytes of s1 and s2 * <br> **************************************/ <br>BOOL <br>ByteCompare ( <br>    CHAR  *s1, <br>    CHAR  *s2, <br>    DWORD nBytes <br>    ) <br>{ <br>    for ( ; nBytes &gt; 0; nBytes--) <br>        if (*s1++ != *s2++) <br>            return FALSE; <br>    return TRUE; <br>} <br> <br>/*********************************** <br> * copies nBytes bytes of s2 to s1 * <br> ***********************************/ <br>BOOL <br>ByteCopy( <br>    CHAR  *s1, <br>    CHAR  *s2, <br>    LONG  nBytes <br>    ) <br>{ <br>    for ( ; nBytes &gt; 0; nBytes--) <br>        *s1++ = *s2++; <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> * VOID ConvertToFileFormat(width, phase, height) <br> * <br> * purpose  : Takes a part of the bitmap (corresponding to a single character) <br> *            and converts it to a string of bytes in the font file format <br> * <br> * params   : WORD width :  width of the character in pixels(bits) <br> *            WORD phase :  current deviation from byte alignment (pixels) <br> *            WORD height:  height of character(pixels) <br> * <br> * returns:   WORD phase :  new deviation from byte alignment (pixels) <br> * <br> * side effects : modifies pointers lp1 and lp2 (pointing to font body and work <br> *                space respectively) <br> * <br> ****************************************************************************/ <br>DWORD PASCAL <br>ConvertToFileFormat( <br>     DWORD width, <br>     DWORD phase, <br>     DWORD height <br>     ) <br>{ <br>      INT w; <br> <br>      for (w = width; w &gt; 0; w -= 8){  /* for each byte of font */ <br>           if (phase == 0){             /* easy case */ <br> <br>               BYTE b; <br> <br>               b = *lp1++; <br>               if (w &lt; 8){ <br> <br>                   phase = (DWORD) w; <br>                   b &gt;&gt;= 8 - w;    /* Clear left side bits */ <br>                   b &lt;&lt;= 8 - w; <br>               } <br>               *lp2 = b; <br>           } <br>           else{ <br> <br>               DWORD j; <br> <br>               lp1--;          /* Re-read byte prevously read */ <br>               //j = (DWORD) ((BYTE)*lp1++ &lt;&lt; 8) | ((BYTE)*lp1++); <br>               j = (DWORD)((BYTE)*lp1++ &lt;&lt; 8); <br>               j |= (DWORD) ((BYTE)*lp1++); <br>               if (w &lt; 8){ <br> <br>                   j &gt;&gt;= 16 - phase - (w &amp; 7);  /* shove it right */ <br>                   j &lt;&lt;= 8 - (w &amp; 7); /* Left justify in low byte */ <br>                   phase += (DWORD) w; <br>                   if (phase &lt;=  8) <br>                       lp1--;         /* back up pointer */ <br>                   phase &amp;= 7; <br>               } <br>               else <br>                   j &gt;&gt;= 8 - phase; <br>               *lp2 = (BYTE)j; <br>           } <br>           lp2 += height;          /* move to next column */ <br>       } <br>       return phase; <br>} <br> <br>/**************************************************************************** <br> * char * FontSave() <br> * <br> * purpose: saves the work bitmap in the required font file format (2.0 or <br> *          3.0 and cleans up <br> * <br> * params : none <br> * <br> * returns: ptr to a NULL string if Save goes off OK <br> *          ptr to error message string otherwise <br> * <br> * side effects: lots <br> * <br> ****************************************************************************/ <br> <br>CHAR * <br>FontSave( <br>CHAR *pszFileName, <br>OFSTRUCT*pofsReOpenInfo <br>    ) <br>{ <br>    DWORD bytecount;       /* number of bytes returned by lwrite */ <br>    DWORD size;            /* total size of font */ <br> <br>    WORD height, row; <br>    DWORD i, fontlen; <br>    DWORD cBody, cFont,cFontsav, cFace; <br>    CHAR *lpFont;          /* ponter to font body */ <br>    CHAR * sz; <br>    DWORD iMax; <br>    WORD widthsav; <br>PBYTEpjGlyphData; <br>PBYTEpjGlyphSave; <br>    GLYPHINFO_20 gi2GlyphTable20;    /* 2.0 style Glyph data struct */ <br>    GLYPHINFO_30 gi3GlyphTable30;    /* 3.0 style Glyph data struct */ <br> <br>    NewAverage(); /* force ave width to be recomputed 8/17/87 BobM */ <br> <br>    /* reset file pointer */ <br>nNewFile = (HFILE)OpenFile (pszFileName, pofsReOpenInfo, OF_WRITE | OF_REOPEN); <br> <br>if (nNewFile &lt; (HFILE) 0) { <br> <br>return vszErrorOpeningFile; <br>} <br> <br>    /* Put up an houglass ... this may take a while */ <br>    if (!hHourGlass) <br>        hHourGlass = LoadCursor (NULL, IDC_WAIT);        /* Get Hourglass */ <br>    hOldCursor = SetCursor (hHourGlass);         /* Show hourglass */ <br> <br>    height = font.PixHeight; <br>    cBody = (DWORD)height * (DWORD)font.WidthBytes; <br> <br>    /* Recompute file size and update header */ <br>    if (iFontFormat == ID_FORMAT2) <br>       cHeader = (WORD)(lSizeOfOldFontHeader +1); <br>    else <br>       cHeader = (WORD)(lSizeOfOldFontHeader30 - 1); <br> <br>    /* if of 2.0 type, check if size will exceed 64kbytes. If yes, saving <br>       in 2.0 format will result in loss of information (because offset table <br>       of 2.0 file is composed of 16bit words). Warn user and ask if file can <br>       be saved as a 3.0 file */ <br> <br>    if (iFontFormat == ID_FORMAT2) <br>    {  <br>if (((DWORD)cHeader + (DWORD)(lSizeOfOldGlyph20 * (font.LastChar - <br>font.FirstChar+2)) + (DWORD)cBody) &gt;= WORD_LIMIT) <br>               if (MessageBox(hBox, vszTooBigFor20, vszWarning, <br>                              IDOK | IDCANCEL |IDNO) == IDYES) <br>                    iFontFormat = ID_FORMAT3; <br>} <br> <br>if (iFontFormat == ID_FORMAT2) { <br> <br>/* allocate space for a 2.0 style offsets table */ <br>cTable = (WORD)(lSizeOfOldGlyph20 * <br>(font.LastChar - font.FirstChar + 2)); <br> <br>} else { <br> <br>/* allocate space for a 3.0 style offsets table */ <br>cTable = (WORD)(lSizeOfOldGlyph30 * <br>(font.LastChar - font.FirstChar + 2)); <br>} <br> <br>pjGlyphData = (LPSTR)GlobalAlloc (GMEM_ZEROINIT, (DWORD)cTable); <br> <br>if (pjGlyphData == 0) { <br> <br>_lclose((HFILE)nNewFile); <br>return vszNotEnoughMem; <br>} <br> <br>pjGlyphSave = pjGlyphData; <br> <br>    size = cHeader + cTable; <br>    iMax = font.LastChar - font.FirstChar + 1; <br> <br>    // Recreate maximum character width when the font is proportional <br>    // since the WIDTH.. command may grow maxwidth but may not reduce. <br>    if (font.Family &amp; 1) <br>font.MaxWidth = 0; <br> <br>    /* create offsets table of font file */ <br>    for (i = 0; i &lt;= iMax; i++){ <br> <br>         DWORD width, charSize; <br> <br>         width = offsets[i + font.FirstChar + 1] - offsets[i + font.FirstChar]; <br> <br>         if (i == iMax) { <br>             width = 8;      /* Sentinal blank */ <br> } <br> <br>         if (iFontFormat == ID_FORMAT2){ <br> <br>            gi2GlyphTable20.GIwidth  = (SHORT)width; <br>            gi2GlyphTable20.GIoffset = (SHORT)size; <br> <br>vBufferFromGlyphInfo20 (&amp;gi2GlyphTable20, pjGlyphData); <br> <br>pjGlyphData += lSizeOfOldGlyph20; <br> <br>         } else { <br> <br>            gi3GlyphTable30.GIwidth  = (SHORT)width; <br>            gi3GlyphTable30.GIoffset = (INT)size; <br> <br>vBufferFromGlyphInfo30 (&amp;gi3GlyphTable30, pjGlyphData); <br> <br>pjGlyphData += lSizeOfOldGlyph30; <br>         } <br>        // update max width <br>        if(font.Family &amp; 1 ) { <br>            if(width &gt; font.MaxWidth ) <br>                font.MaxWidth = (WORD)width ; <br>        } <br>        if(i == 0x81 &amp;&amp; font.CharSet == SHIFTJIS_CHARSET) { <br>            if(width * 2 &gt; font.MaxWidth) { <br>                font.MaxWidth = (WORD)width * 2 ; <br>            } <br>        } <br> <br>         charSize = height * ((width + 7) &gt;&gt; 3);  /* size in bytes */ <br> <br>         if ((size + charSize) &lt; size){           /* Overflow? */ <br> <br>             GlobalFree (pjGlyphData); <br>             _lclose((HFILE)nNewFile); <br>             return vszFileTooLarge; <br> <br>         } <br>         size += charSize; <br>    } <br> <br>    /* Update stuff in the header */ <br> <br>    font.Face = (DWORD)size; <br>    cFace = (WORD)lstrlen (szFaceName) + 1;   /* Allow for \0 */ </code></pre>
<p>
</p>
<pre><code>size += cFace; <br>    font.Size = (DWORD)size;                                /* new file size */ <br>    font.BitsOffset = (DWORD)(cHeader + cTable); <br>    font.Device = (DWORD)NULL;                   /* Device Name must be NULL */ <br>    cFontsav = size - cHeader - cTable; <br>    cFont =cFontsav; <br> <br>/* alloc extra byte for lp1 in case it needs it */ <br>    if (!(lpFontBody = (LPSTR)GlobalAlloc (GMEM_ZEROINIT, (LONG)cBody + <br>height * 4))) { <br> <br>_lclose((HFILE)nNewFile); <br>        return vszNotEnoughMem; <br>} <br> <br>    GetBitmapBits (hBitmap, (DWORD)cBody, lpFontBody); <br> <br>    /* save current WidthBytes */ <br>    widthsav = font.WidthBytes; <br> <br>    /*  MD - reset WidthBytes from computed width */ <br>    font.WidthBytes = (WORD) (cFont - cFace)/ height; <br> <br>    /* Allocate a block to put bitmap into */ <br>    if ((lpFont = lpWork = GlobalAlloc (GMEM_ZEROINIT,(LONG)cFont)) == 0) <br>{ <br>        GlobalFree (lpFontBody); <br>_lclose((HFILE)nNewFile); <br>        return vszNotEnoughMem; <br>} <br> <br>    lp1 = lpFontBody; <br> <br>    /* convert bitmap to file format */ <br>    if (iFontFormat == ID_FORMAT2){   /* offsets table in 2.0 format */ <br>        INT nChars; <br>        nChars =  font.LastChar - font.FirstChar +1; <br> <br>        for (row = 0; row &lt; height; row++){ <br> <br>            DWORD phase; <br> <br>            phase = 0; <br> <br>            pjGlyphData = pjGlyphSave; <br> <br>            for (i = 0; i &lt; (DWORD) nChars; i++) { <br> <br>                INT width; <br> <br>vGlyphInfo20FromBuffer (pjGlyphData, &amp;gi2GlyphTable20); <br> <br>                width = gi2GlyphTable20.GIwidth; <br> <br>                lp2 = (BYTE  *)(lpWork + (gi2GlyphTable20.GIoffset - <br>cHeader - cTable + row)); <br> <br>pjGlyphData += lSizeOfOldGlyph20; <br> <br>                phase = ConvertToFileFormat (width, phase, height); <br>            } <br>            if ((lp1 - lpWork) &amp; 1) <br>                 lp1++;             /* Round lp1 up to Word Boundary */ <br>#ifdef DWORDROUND <br>            if ((lp1 - lpWork) &amp; 2) { <br>                 lp1++;             /* Round lp1 up to DWord Boundary */ <br>                 lp1++;             /* Round lp1 up to DWord Boundary */ <br>} <br>#endif <br>            //if(((offsets[font.LastChar + 1] + 7) &gt;&gt; 3) &amp; 1) <br>                //lp1++;          /* Round lp1 up to Word Boundary */ <br>        } <br>    } <br>     /* separate loops written for the 2.0 and 3.0 font processing because <br>        a single loop would involve too many checks (of font type) within <br>        the loop and slow down processing  */ <br>    else{  /* table in 3.0 format */ <br> <br>        INT nChars; <br>        nChars =  font.LastChar - font.FirstChar +1; <br>        for (row = 0; row &lt; height; row++){ <br> <br>            DWORD phase; <br> <br>            phase = 0; <br>pjGlyphData = pjGlyphSave; <br> <br>            for (i = 0; i &lt; (DWORD) nChars; i++) { <br> <br>                INT width; <br> <br>vGlyphInfo30FromBuffer (pjGlyphData, &amp;gi3GlyphTable30); <br> <br>                width = gi3GlyphTable30.GIwidth; <br> <br>                lp2 = (BYTE  *)(lpWork + (gi3GlyphTable30.GIoffset - <br>cHeader - cTable + row)); <br> <br>pjGlyphData += lSizeOfOldGlyph30; <br> <br>                phase = ConvertToFileFormat (width, phase, height); <br>            } <br>            if ((lp1 - lpWork) &amp; 1) <br>                 lp1++;             /* Round lp1 up to Word Boundary */ <br>#ifdef DWORDROUND <br>            if ((lp1 - lpWork) &amp; 2) { <br>                 lp1++;             /* Round lp1 up to DWord Boundary */ <br>                 lp1++;             /* Round lp1 up to DWord Boundary */ <br>} <br>#endif <br>            //if(((offsets[font.LastChar + 1] + 7) &gt;&gt; 3) &amp; 1) <br>                //lp1++;          /* Round lp1 up to Word Boundary */ <br>        } <br>    } <br> <br>/* Restore start of data. */ <br>pjGlyphData = pjGlyphSave; <br> <br>    lp2 -= height - 1;              /* Back up to start of character */ <br>    for (i = 0; i &lt; height; i++) <br>         *lp2++ = 0;             /* Fill in guaranteed blank character */ <br> <br>    font.Version = 0x200; <br> <br>    /******  code for compaction in 3.0 fmt borrowed from CMPCTFON ******/ <br>    if (iFontFormat== ID_FORMAT3){ <br>        DWORD iDefBitmapSize = 0;     /* size of default char */ <br>        DWORD cch = 0;                /* count of number of default char */ <br>#if 0 <br>        GLYPHINFO_30  *cur_char;  /* current element of offset table */ <br>        GLYPHINFO_30  *move_char; <br>            /* element from which moving is to be done */ <br>        LONG iDefBitmapOffset;        /* offset of default char */ <br>        INT iDefBitmapWidth;          /* width of default char */ <br>        static LONG iEndOfBitmaps;    /* address of end of font body */ <br>        INT iFirstC;                  /* first char in font */ <br>        INT iLastC;                   /* last char in font */ <br>        INT i,j; <br>        WORD width; <br>        CHAR  *rgbFont;         /* pointer to font body */ <br>        DWORD Offset; <br> <br>        GDI seems to understand compressed 2.0 external formats but not <br>        compressed 3.0 formats, and this is causing it to crash loading a 3.0 <br>        format compressed font. Since compression does not affect the <br>        validity of the font, This code is disabled temporarily till <br>        this problem is verified. Again, the font is perfectly usable in this <br>        form, though a trifle bigger than desired -  LR 20/26/90 <br> <br> <br>Note that this will now not work after the conversion to NT. <br>the glyph table needs to accessed as above.  t-davema 8/20/91 <br> <br>        iFirstC = font.FirstChar &amp; 0x0ff; <br>        iLastC  = font.LastChar &amp; 0x0ff; <br> <br>        iEndOfBitmaps = (LONG)font.BitsOffset+((LONG)font.WidthBytes * <br>                (LONG)font.PixHeight); <br>        rgbFont = (CHAR  *)lpFont;   /* start of font body */ <br>        cur_char =(GLYPHINFO_30  *) lpTable; /* start of offset table */ <br> <br>        /* calculate some parameters for the default char */ <br>        iDefBitmapOffset = cur_char[font.DefaultChar].GIoffset; <br>        iDefBitmapWidth  = cur_char[font.DefaultChar].GIwidth; <br>        iDefBitmapSize   = (DWORD)cur_char[font.DefaultChar+1].GIoffset <br>                                           - (DWORD)iDefBitmapOffset; <br> <br>        /* scan the font body via the offsets table. If a default char <br>           is recognised, move all the bytes to it's right left by the <br>           size of the default char.Make all offset table entries of default <br>           char point to one image of the char (the earliest occuring image) */ <br>        for (i = iFirstC; i &lt;= iLastC; ++i) { <br> <br>            /* important: Check for limiting conditions (in case break char <br>               was modified?)*/ <br>            if (cur_char-&gt;GIoffset == iDefBitmapOffset){ <br>                cur_char++; <br>                continue; <br>            } <br> <br>            Offset = cur_char-&gt;GIoffset -cHeader -cTable; <br>            /* proceed to compare images only if widths are equal */ <br>            if ((cur_char-&gt;GIwidth  == iDefBitmapWidth) &amp;&amp; <br>                (ByteCompare (&amp;rgbFont [Offset], <br>                &amp;rgbFont[iDefBitmapOffset-cHeader-cTable], <br>                                (DWORD)iDefBitmapSize) == TRUE)){ <br> <br>                /* set offset to earliest occurence of the default char */ <br>                if (cur_char-&gt;GIoffset &lt;  iDefBitmapOffset){ <br>                    iDefBitmapOffset = cur_char-&gt;GIoffset; <br>                } <br>                else    { <br>                    if (i != iLastC){ <br>                        /* move bytes to right of default char left by the <br>                           size of the char */ <br>                        ByteCopy (&amp;rgbFont [ Offset], <br>                                  &amp;rgbFont [ Offset+ iDefBitmapSize], <br>                                  (LONG)(iEndOfBitmaps - <br>                                  ((cur_char + 1)-&gt;GIoffset))); <br> <br>                        /* correct the offset table entries */ <br>                        move_char = cur_char + 1; <br>                        for (j=i; j &lt; iLastC; ++j){ <br>                             move_char-&gt;GIoffset -= (LONG)iDefBitmapSize; <br>                             move_char++; <br>                        } <br>                    } <br>                    iEndOfBitmaps -= iDefBitmapSize; <br>                    /* move End-of-font to the left */ <br>                    cur_char-&gt;GIoffset = iDefBitmapOffset; <br>                    /* point offset of cuurent char to default char */ <br>                    cch++; <br>                } <br>            } <br>            cur_char++; <br>        } <br>#endif <br>        /* recalculate some font attributes */ <br>        lp2   -= (cch * iDefBitmapSize + height); <br>        for (i = 0; i &lt; height; i++) <br>            *lp2++ = 0;             /* Fill in guaranteed blank character */ <br> <br>        cFont -= cch * iDefBitmapSize; <br>        font.WidthBytes = (WORD) (cFont - cFace)/ height; <br>        font.Size = (DWORD) (cFont + cHeader + cTable); <br>        font.Face = font.Size - cFace ; <br>        font.Version = 0x300; <br> <br>        /* copy info into 3.0 (new) format header and set the additional <br>           fields */ <br>        ByteCopy ((LPSTR)&amp;font30, (LPSTR)&amp;font, (DWORD)sizeof (font)); <br>        font30.fsFlags        = 0; <br>        font30.fsFlags = (font.Family &amp; 1 ? FSF_PROPORTIONAL : FSF_FIXED); <br>        font30.fsAspace       = 0; <br>        font30.fsBspace       = 0; <br>        font30.fsCspace       = 0; <br>        font30.fsColorPointer = 0L; <br>        for (i = 0; i &lt; 4 ; i++) <br>            font30.fsReserved[i] = 0L; <br>    } <br> <br>    /* Add the FaceName, if any, to the end of the bitmap */ <br>    lstrcpy((LPSTR)lp2, (LPSTR)szFaceName); <br> <br>/* <br> * Again we need to do some tricky things to get the header output <br> * correct.  We want to run it through the conversion backwards until <br> * we get the packed structure. <br> */ <br>{ <br>BYTE jOutputBuffer [sizeof (font30)]; <br> <br>if (iFontFormat == ID_FORMAT2) { <br> <br>vBufferFromFontStruct (&amp;font, (PBYTE)&amp;jOutputBuffer); <br> <br>} else { <br> <br>vBufferFromFont30Struct (&amp;font30, (PBYTE)&amp;jOutputBuffer); <br>} <br> <br>bytecount = _lwrite((HFILE)nNewFile, (PBYTE)&amp;jOutputBuffer, (DWORD)cHeader); <br>} <br> <br>    /* Write out Header Information */ <br>    if (bytecount == cHeader) { <br> <br>            /* Write out OffsetsTable */ <br>         if (cTable == 0 || (_lwrite((HFILE)nNewFile, pjGlyphData, (DWORD)cTable) <br>== (UINT)cTable)){ <br>              /* Write out Body */ <br>              fontlen = cFont; <br>              while (fontlen &gt;= SEGMENT_SIZE){ <br> <br>                 /* file write method if font size is 64k or greater <br>                 file is written in chunks of 65536 bytes (SEGMENT_SIZE)-lr */ <br> <br>                 /* First write as many bytes as _lwrite will allow(65534) */ <br>                  if (_lwrite((HFILE)nNewFile, (CHAR  *)lpFont, WORD_LIMIT) == <br>                        WORD_LIMIT){ <br>                      fontlen -= WORD_LIMIT; <br>                            /* fontlen = no of bytes left to write*/ <br>                      lpFont+= WORD_LIMIT; /* buffer ptr moved up by 64k */ <br>                  } <br>                  else <br>                      sz = vszErrorWritingBody; <br> <br>                  /* write the two bytes remaining in the segment */ <br>                  if (_lwrite((HFILE)nNewFile, (CHAR  *)lpFont, 2) == 2){ <br>                      fontlen -= 2;  /* fontlen = no of bytes left to write*/ <br>                      lpFont+= 2;    /* buffer ptr moved up by 2 */ <br>                  } <br>                  else <br>                      sz = vszErrorWritingBody; <br>              } <br>              /* segment only partially filled. Write the remaining bytes */ <br>              if (_lwrite((HFILE)nNewFile, (CHAR  *)lpFont, (DWORD)fontlen) == <br>                    (UINT) fontlen){ <br>                   fChanged = FALSE; <br>                   sz= ""; <br>              } <br>              else <br>                  sz = vszErrorWritingBody; <br>         } <br>         else <br>             sz = vszErrorWritingOffsets; <br>    } <br>    else <br>         sz = vszErrorWritingHdr; <br> <br>    /* hack: Restore saved value of widthbytes, eliminating a variety <br>       of minor scrolling problems that follow after a File/Save */ <br>    font.WidthBytes = widthsav; <br> <br>    _lclose((HFILE)nNewFile); <br> <br>/* Tidy up */ <br> <br>    GlobalFree(lpFontBody); <br>    GlobalFree(pjGlyphData); <br>    GlobalFree(lpWork); <br> <br>    SetCursor(hOldCursor);              /* Restore regular cursor */ <br> <br>    return sz; <br>} <br> <br>/**************************************************************************** <br> * BOOL ResizeWidths(wChar) <br> * <br> * params : WORD wChar : new width of a single character <br> * <br> * purpose: resize work bitmap according to new character width by stretching/ <br> *          compressing all characters as neccesary <br> * <br> * returns: none <br> * <br> * side effects: Work bitmap changes.Some header info (regarding font dimensions <br> *               altered as well <br> ****************************************************************************/ <br> <br> <br>BOOL <br>ResizeWidths( <br>    DWORD wChar <br>    ) <br>{ <br>    DWORD width; <br>    DWORD offset, i; <br> <br>    /* Create a new bitmap to move the font definition bits into */ <br>    width = (font.LastChar - font.FirstChar + 1) * wChar; /* In pixels */ <br>             // ResizeWidths(): width byte is DWORD align <br>    width = CJ_DIB_SCAN(width); <br>    if (!GetNewMap(width, font.PixHeight)) <br>        return (FALSE); <br> <br>    /* Move the bits in */ <br>    offset = 0; <br>    oldMode = SetStretchBltMode(hNewMemDC, COLORONCOLOR); <br>    for (i = font.FirstChar; i &lt;= font.LastChar; i++) <br>        { <br> <br>        StretchBlt(hNewMemDC, offset, 0, <br>                wChar, font.PixHeight,                  /* New character */ <br>                hMemDC, offsets[i], 0, <br>                font.PixWidth, font.PixHeight,          /* Old character */ <br>                SRCCOPY); <br>        offsets[i] = offset; <br>        offset += wChar; <br>        } <br>    SetStretchBltMode(hNewMemDC, oldMode); <br>    offsets[font.LastChar + 1] = offset; <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br> <br>    font.HorizRes = (WORD) Proport(font.HorizRes, wChar, font.PixWidth, 999); <br>    font.WidthBytes = (WORD) width;            /* Misc. ajustments */ <br>    font.PixWidth = font.AvgWidth = (font.MaxWidth = (WORD) wChar); <br>    font.MaxWidth = (WORD) wChar * 2;// set MaxWidth as DBCS width. <br> <br>    return (TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> * BOOL SpreadWidths(wChar) <br> * <br> * purpose: spread/compress work bitmap (with variable width characters) <br> *          in proportion with the maximum character width <br> * <br> * params : WORD wChar : new width of a character <br> * <br> * returns: none <br> * <br> * side effects: Work bitmap changes.Some header info (regarding font dimensions <br> *               altered as well <br> ****************************************************************************/ <br> <br>BOOL <br>SpreadWidths( <br>    DWORD wChar <br>    ) <br>{ <br>    DWORD offset, i; <br>    DWORD width, oldWidth, newWidths[257]; <br> <br>    /* Create a new bitmap to move the font definition bits into */ <br>    width = 0;          /* Compute the new width */ <br>    for (i = (DWORD) font.FirstChar; i &lt;= (DWORD) font.LastChar; i++) <br>        { <br>        oldWidth = offsets[i + 1] - offsets[i]; <br>        /* Compute new width to nearest whole number */ <br>        newWidths[i] = Proport(oldWidth, wChar, font.MaxWidth, wBoxLim - 1); <br>        width += newWidths[i]; <br>        } <br>             // SpreadWidths(): byte width is DWORD align <br>    width = CJ_DIB_SCAN(width); <br>    if (!GetNewMap(width, font.PixHeight)) <br>        return(FALSE); <br> <br>    /* Move the bits in */ <br>    offset = 0; <br>    oldMode = SetStretchBltMode(hNewMemDC, COLORONCOLOR); <br>    for (i = font.FirstChar; i &lt;= font.LastChar; i++) <br>        { <br>        oldWidth = offsets[i + 1] - offsets[i]; <br>        StretchBlt(hNewMemDC, offset, 0, <br>                newWidths[i], font.PixHeight,           /* New character */ <br>                hMemDC, offsets[i], 0, <br>                oldWidth, font.PixHeight,               /* Old character */ <br>                SRCCOPY); <br>        offsets[i] = offset; <br>        offset += newWidths[i]; <br>        } <br>    SetStretchBltMode(hNewMemDC, oldMode); <br>    offsets[font.LastChar + 1] = offset; <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br>    font.HorizRes = (WORD) Proport(font.HorizRes, wChar, font.MaxWidth, 999); <br>    font.WidthBytes = (WORD) width;            /* Misc. ajustments */ <br>    font.MaxWidth = (WORD) wChar; <br>    NewAverage();                       /* Compute new average width */ <br> <br>    return (TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> * NewAverage() <br> * <br> * purpose: recalculate average width of a character in font <br> * <br> * params : none <br> * <br> * returns: none <br> * <br> * side effects: alters the average width parameter in font header <br> * <br> ****************************************************************************/ <br>VOID <br>NewAverage( <br>    VOID <br>    ) <br>{ <br>#ifdef FOO <br>    WORD i, totalwidth; <br>    /* 12/23/85 -- use weighted avg of lower case letters (mikecr) */ <br> <br>    /* width of the space */ <br>    totalwidth = (offsets[' ' + 1] - offsets[' ']) * widthweights[ALPHA_CNT]; <br> <br>    for (i = 0; i &lt; ALPHA_CNT; i++) <br>            totalwidth += (offsets['a' + i + 1] - offsets['a' + i]) * <br>            widthweights[i]; <br> <br>    font.AvgWidth = totalwidth / TOTAL_WEIGHTS; <br> <br>    /* round up if necessary */ <br>    if (totalwidth % TOTAL_WEIGHTS &gt;= (TOTAL_WEIGHTS &gt;&gt; 1)) <br>            font.AvgWidth++; <br> <br>#endif <br> <br>    /* lets do a simple average here */ <br>    font.AvgWidth = (WORD) (((offsets[font.LastChar+1] - <br>            offsets[font.FirstChar]) + (font.LastChar - font.FirstChar)/2) / <br>            (font.LastChar - font.FirstChar + 1)); <br> <br>    if (font.AvgWidth == 0) { <br>       font.AvgWidth++; <br>    } <br>    if (font.AvgWidth &lt; 1) { <br>        font.AvgWidth = 1; <br>    } <br>} <br> <br> <br>/**************************************************************************** <br> * BOOL ResizeBody(width, height) <br> * <br> * purpose: adjust work bitmap according to new specified dimensions <br> * <br> * params : WORD width  : new width of font in pixels <br> *          WORD height : new height of font in pixels <br> * <br> * returns: none <br> * <br> * side effects: Work bitmap changes.Some header info (regarding font dimensions <br> *               altered as well <br> ****************************************************************************/ <br> <br>BOOL <br>ResizeBody( <br>    DWORD width, <br>    DWORD height <br>    ) <br>{ <br> <br>    /* Create a new bitmap to move the font definition bits into */ <br>    if (!GetNewMap(width, height)) <br>        return(FALSE); <br> <br>    /* Move the bits in */ <br>    oldMode = SetStretchBltMode(hNewMemDC, COLORONCOLOR); <br>    StretchBlt(hNewMemDC, 0, 0, <br>            width &lt;&lt; 3, height,         /* New Char. */ <br>            hMemDC, 0, 0, <br>            width &lt;&lt; 3, font.PixHeight, /* Old Char. */ <br>            SRCCOPY); <br>    SetStretchBltMode(hNewMemDC, oldMode); <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br> <br>    font.ExtLeading = (WORD) Proport(font.ExtLeading, height, font.PixHeight, 999); <br>    font.IntLeading = (WORD) Proport(font.IntLeading, height, font.PixHeight, 999); <br>    font.Ascent = (WORD) Proport(font.Ascent, height, font.PixHeight, 32); <br>    font.VertRes = (WORD) Proport(font.VertRes, height, font.PixHeight, 999); <br>    font.Points = (WORD) Proport(font.Points, height, font.PixHeight, 999); <br>    font.PixHeight = (WORD) height;            /* Fix misc. header values */ <br>    font.WidthBytes = (WORD) width; <br> <br>    return (TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> * BOOL NewFirstChar(first) <br> * <br> * purpose: redefines first character in font and resizes work bitmap <br> *          accordingly <br> * <br> * params : WORD first : new first character to be defined <br> * <br> * returns: none <br> * <br> * side effects: Work bitmap changes.Some header info (regarding font dimensions <br> *               altered as well <br> ****************************************************************************/ <br> <br>BOOL <br>NewFirstChar( <br>    DWORD first <br>    ) <br>{ <br>    DWORD  width, wDefault; <br>    DWORD offset, i; <br>    INT dw; <br> <br>    if (first &gt; font.FirstChar)         /* Smaller? */ <br>        { <br>        ShrinkFont(first, font.LastChar); <br>        font.FirstChar = (BYTE) first; <br>        /*return(FALSE);*/ <br>        return(TRUE); <br>        } <br> <br>    /* If not smaller we must pad with the default character */ <br>    wDefault = offsets[font.DefaultChar + 1] - offsets[font.DefaultChar]; <br>    dw = wDefault * (font.FirstChar - first);           /* Extra width */ <br>    width = offsets[font.LastChar + 1] + dw;    /* New width (pixels) */ <br>             // NewFirstChar(): byte width is DWORD align <br>    width = CJ_DIB_SCAN(width); <br>    if (!GetNewMap(width, font.PixHeight)) <br>        return(FALSE);           /* New work area */ <br> <br>    /* Move it in in two parts */ <br>    /* First move in default characters */ <br>    offset = 0; <br>    for (i = first; i &lt; font.FirstChar; i++) <br>        { <br>        BitBlt(hNewMemDC, offset, 0, <br>                wDefault, font.PixHeight, <br>                hMemDC, offsets[font.DefaultChar], 0, <br>                SRCCOPY); <br>        offsets[i] = offset; <br>        offset += wDefault; <br>        } <br>    /* Now move in the rest */ <br>    BitBlt(hNewMemDC, offset, 0, <br>            offsets[font.LastChar + 1], font.PixHeight, <br>            hMemDC, 0, 0, <br>            SRCCOPY); <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br> <br>    /* Now fix up offsets table */ <br>    for (i = font.FirstChar; i &lt;= (DWORD)(font.LastChar + 1); i++) <br>        offsets[i] = offsets[i] + dw;           /* Shift the rest right */ <br>    font.WidthBytes = (WORD) width; <br>    font.FirstChar = (BYTE) first; <br> <br>    return (TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> * ShrinkFont(first, last) <br> * <br> * purpose:  redefine the first and last charcter in the font and shrink <br> *           work bitmap accordingly <br> * <br> * params :  WORD first : new first character to be defined <br> *           WORD last  : new last character  "  "   " <br> * <br> * returns:  none <br> * <br> * side effects: Work bitmap changes.Some header info (regarding font dimensions <br> *               altered as well <br> ****************************************************************************/ <br> <br>VOID <br>ShrinkFont( <br>    DWORD first, <br>    DWORD last <br>    ) <br>{ <br>    DWORD width, widthPixels; <br>    DWORD i; <br>    INT dw; <br> <br>    dw = offsets[first] - offsets[font.FirstChar];      /* left shift if any */ <br>    widthPixels = offsets[last + 1] - offsets[first];   /* Width in pixels */ <br>             // ShrinkFont(): byte width is DWORD align <br>    width = CJ_DIB_SCAN(widthPixels); <br>    if (!GetNewMap(width, font.PixHeight)) <br>        return;           /* New work area.*/ <br> <br>    /* Now move the font into the reduced space */ <br> <br>    BitBlt(hNewMemDC, 0, 0, <br>            widthPixels, font.PixHeight, <br>            hMemDC, offsets[first], 0, <br>            SRCCOPY); <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br> <br>    if (dw)                             /* Ajust offsets */ <br>        { <br>        for (i = first; i &lt;= last + 1; i++) <br>            offsets[i] -= dw; <br>        } <br> <br>    font.WidthBytes = (WORD) width; <br> <br>} <br> <br> <br>/**************************************************************************** <br> * BOOL NewLastChar(last) <br> * <br> * purpose:  redefines the last character in the font <br> * <br> * params :  WORD last : number of character to be made the last character <br> * <br> * returns:  none <br> * <br> * side effects: Work bitmap changes.Some header info (regarding font dimensions <br> *               altered as well <br> * <br> ****************************************************************************/ <br> <br>BOOL <br>NewLastChar( <br>    DWORD last <br>    ) <br>{ <br>    DWORD  width, wDefault; <br>    DWORD offset, i; <br>    INT dw; <br> <br>    if (last &lt; font.LastChar)           /* Smaller? */ <br>        { <br>        ShrinkFont(font.FirstChar, last); <br>        font.LastChar = (BYTE) last; <br>        return(FALSE); <br>        } <br> <br>    /* If not smaller we must pad with the default character */ <br>    wDefault = offsets[font.DefaultChar + 1] - offsets[font.DefaultChar]; <br>    dw = wDefault * (last - font.LastChar);             /* Extra width */ <br>    offset = offsets[font.LastChar + 1];        /* Current end */ <br>    width = offset + dw;                        /* New width (pixels) */ <br>             // NewLastChar(): byte width is DWORD align <br>    width = CJ_DIB_SCAN(width); <br>    if (!GetNewMap(width, font.PixHeight)) <br>        return(FALSE);           /* New work area */ <br> <br>    /* Move it in in two parts */ <br>    /* First move in the existing font */ <br>    BitBlt(hNewMemDC, 0, 0, <br>            offset, font.PixHeight, <br>            hMemDC, 0, 0, <br>            SRCCOPY); <br>    /* Then move in default characters */ <br>    for (i = font.LastChar + 1; i &lt;= last;) <br>        { <br>        BitBlt(hNewMemDC, offset, 0, <br>                wDefault, font.PixHeight, <br>                hMemDC, offsets[font.DefaultChar], 0, <br>                SRCCOPY); <br>        offset += wDefault; <br>        offsets[++i] = offset; <br>        } <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br> <br>    font.WidthBytes = (WORD) width; <br>    font.LastChar = (BYTE) last; <br> <br>    return (TRUE); <br>} <br> <br> <br>/**************************************************************************** <br> * BOOL CharWidth(iChar, wBox) <br> * <br> * purpose: resizes selected char according to new dimensions. (only for <br> *          variable pitch) <br> * <br> * params : BYTE iChar : character to resize <br> *          WORD wBox  : new width of char in pixels <br> * <br> * returns: none <br> * <br> * side effects: work bitmap pixel values and header info(regarding font <br> *               dimensions) altered <br> * <br> ****************************************************************************/ <br> <br>BOOL <br>CharWidth( <br>    BYTE iChar,                             /* Character to change */ <br>    DWORD wBox                               /* New width */ <br>    ) <br>{ <br>    DWORD  width, nChars; <br>    DWORD  w1, w2, i; <br>    INT dw; <br> <br>    nChars = font.LastChar - font.FirstChar + 1;        /* Character count */ <br>    dw = wBox - (offsets[iChar + 1] - offsets[iChar]);  /* Width change */ <br>    width = offsets[font.LastChar + 1] + dw;            /* New width (pixels) */ <br>             // CharWidth(): byte width is DWORD align <br>    width = CJ_DIB_SCAN(width); <br>    if (!GetNewMap(width, font.PixHeight)) <br>        return(FALSE);                   /* New work area */ <br> <br>    /* Move it in in two parts */ <br>    /* First move up to and including iChar */ <br>    w1 = offsets[iChar + 1];            /* Width (in pixels) to move */ <br>    BitBlt(hNewMemDC, 0, 0, <br>            w1 + dw, font.PixHeight, <br>            hMemDC, 0, 0, <br>            SRCCOPY); <br>    /* Now move in the rest */ <br>    if (iChar &lt; (BYTE) font.LastChar)        /* Part to right of elision */ <br>        { <br>        w2 = offsets[font.LastChar + 1] - offsets[iChar + 1]; <br>        BitBlt(hNewMemDC, offsets[iChar] + wBox, 0, <br>                w2, font.PixHeight, <br>                hMemDC, offsets[iChar + 1], 0, <br>                SRCCOPY); <br>        } <br> <br>    UseNewMap();                /* Switch Pointers and release the space */ <br> <br>    /* Now fix up offsets table */ <br>    for (i = iChar + 1;                         /* Where changes start */ <br>        i &lt;= (DWORD)(font.LastChar + 1); i++)            /* Ajust offsets */ <br>        offsets[i] = offsets[i] + dw;           /*  .. by adding dw */ <br>    font.WidthBytes = (WORD) width; <br>    NewAverage(); <br> <br>    return (TRUE); <br>} <br> <br>/**************************************************************************** <br> * BoxToClipboard(ptA, width, height) <br> * <br> * purpose: write char (or part of it) to clipboard <br> * <br> * params : POINT ptA    : upper left coordinate <br> *          DWORD width  : width of char in pixels <br> *          DWORD height : height of char in pixels <br> * returns: none <br> * <br> * side effects: none <br> * <br> ****************************************************************************/ <br>VOID <br>BoxToClipboard( <br>    POINT ptA,                               /* Upper left point */ <br>    DWORD width, <br>    DWORD height                      /* Size */ <br>    ) <br>{ <br>    HDC hDC; <br>    DWORD x, y; <br> <br>    hDC = GetDC(hFont);                         /* DC to be compatible with */ <br>    hNewBitmap = CreateBitmap( <br>                    width, height, <br>                    1, 1, (LPBYTE)NULL); <br>    hNewMemDC = CreateCompatibleDC(hDC);                /* Create a DC */ <br>    SelectObject(hNewMemDC, hNewBitmap);                /* Relate them */ <br>    ReleaseDC(hFont, hDC);                      /* Done with font DC */ <br> <br>    for (x = 0; x &lt; width; x++) <br>        for (y = 0; y &lt; height; y++) <br>            SetPixel(hNewMemDC, x, y, matBox[x + ptA.x][y + ptA.y] == TRUE ? <br>            BLACK : WHITE); <br> <br>    /* Now wake up Clipboard and empty it */ <br>    if (!OpenClipboard(hFont)) <br>        ErrorBox(hBox, vszCannotOpenClip); // , vszCopyingToClip); <br>    else        /* Ok: We got the Clipboard */ <br>        { <br>        EmptyClipboard(); <br>        SetClipboardData(CF_BITMAP, hNewBitmap);        /* Tell Clipboard */ <br>        } <br> <br>    /* Tidy things up */ <br>    CloseClipboard(); <br>    DeleteDC(hNewMemDC); <br>} <br> <br> <br>/**************************************************************************** <br> * WORD ClipboardToBox(ptA, width, height, fFit) <br> * <br> * purpose: copies char (or part of char ) from clipboard to work bitmap <br> *          stretching it if need be <br> * <br> * params : PIONT ptA    : upper left coordinate <br> *          DWORD width  : width of char in pixels </code></pre>
<p>
</p>
<pre><code>*          DWORD height : height of char in pixels <br> *          BOOL fFit   : flag to indicate if default width is to be used <br> * returns: none <br> * <br> * side effects: pixel values of bitmap may change for char <br> * <br> ****************************************************************************/ <br> <br>DWORD <br>ClipboardToBox( <br>    POINT ptA,                               /* Upper left point */ <br>    DWORD width, <br>    DWORD height,                     /* Size */ <br>    BOOL fFit                               /* Use default width if TRUE */ <br>    ) <br>{ <br>    BITMAP bitmap; <br>    HDC hDC; <br>    DWORD x, y; <br>    HANDLE hT; <br> <br>    if (!OpenClipboard(hFont)) { <br>        ErrorBox(hBox, vszCannotOpenClip); <br>        return 0; <br>    } <br>    hNewBitmap = GetClipboardData(CF_BITMAP); <br> <br>    /* Check if we got something like a character */ <br>    if (GetObject(hNewBitmap, sizeof(BITMAP), (LPSTR)&amp;bitmap) != sizeof(BITMAP)) <br>        {   /* What did we get */ <br>        ErrorBox(hBox, vszErrorClip); <br>        CloseClipboard(); <br>        return 0; <br>    } <br> <br> <br>    if (fFit &amp;&amp; ((WORD)bitmap.bmWidth &lt;= font.MaxWidth)) <br>        width = bitmap.bmWidth; <br> <br>    hDC = GetDC(hFont);                         /* DC to be compatible with */ <br>    hBoxBitmap = CreateBitmap( <br>                    width, height, <br>                    1, 1, (LPBYTE)NULL); <br>    hBoxMemDC = CreateCompatibleDC(hDC);                /* Create a DC */ <br>    hT = SelectObject(hBoxMemDC, hBoxBitmap);           /* Relate them */ <br>    if (hT == NULL || hDC == NULL || hBoxBitmap == NULL || hBoxMemDC == NULL) { <br>        ErrorBox(hBox, vszErrorClip); <br>CloseClipboard(); <br>DeleteDC(hBoxMemDC); <br>DeleteObject(hBoxBitmap); <br>        return 0; <br>    } <br> <br>    /* Get a DC to relate to the Bitmap we just got */ <br>    hNewMemDC = CreateCompatibleDC(hDC);                /* Create a DC */ <br>    hT = SelectObject(hNewMemDC, hNewBitmap);           /* Relate them */ <br>    ReleaseDC(hFont, hDC);                      /* Done with font DC */ <br>    if (hT == NULL || hNewMemDC == NULL) { <br>        ErrorBox(hBox, vszErrorClip); <br>CloseClipboard(); <br>DeleteDC(hNewMemDC); <br>DeleteDC(hBoxMemDC); <br>DeleteObject(hBoxBitmap); <br>        return 0; <br>    } <br> <br>    /* Now StretchBlt whatever was on the clipboard into the character */ <br>    oldMode = SetStretchBltMode(hBoxMemDC, COLORONCOLOR); <br>    fFit = StretchBlt(hBoxMemDC, 0, 0, width, height, <br>                hNewMemDC, 0, 0, bitmap.bmWidth, bitmap.bmHeight, SRCCOPY); <br>    if (!fFit || !oldMode) { <br>        ErrorBox(hBox, vszErrorClip); <br>CloseClipboard(); <br>DeleteDC(hNewMemDC); <br>DeleteDC(hBoxMemDC); <br>DeleteObject(hBoxBitmap); <br>        return 0; <br>    } <br>    (void)SetStretchBltMode(hBoxMemDC, oldMode); <br>    for (x = 0; x &lt; width; x++) <br>        for (y = 0; y &lt; height; y++) <br>            matBox[x + ptA.x] [y + ptA.y] = (CHAR)(GetPixel(hBoxMemDC, x, y) ? <br>                0 : 1); <br>    /* Tidy things up */ <br>    DeleteDC(hNewMemDC); <br>    DeleteDC(hBoxMemDC); <br>    DeleteObject(hBoxBitmap); <br>    CloseClipboard(); <br>    return(width); <br>} <br> <br> <br>/**************************************************************************** <br> * ToClipboard(iChar, width, height) <br> * <br> * purpose: write char in edit box to clipboard <br> * <br> * params : BYTE iChar  : number of char to be copied to clipboard <br> *          DWORD width  : width of char in pixels <br> *          DWORD height : height of char in pixels <br> * <br> * returns: none <br> * <br> * side effects: none <br> * <br> ****************************************************************************/ <br> <br>VOID <br>ToClipboard( <br>    BYTE iChar, <br>    DWORD width,             /* Here in Pixels */ <br>    DWORD height             /* Also in Pixels */ <br>    ) <br>{ <br>    HDC hDC; <br> <br>    hDC = GetDC(hFont);                         /* DC to be compatible with */ <br>    hNewBitmap = CreateBitmap( <br>                    width,                      /* Width of font in pixels */ <br>                    height, <br>                    1, 1, (LPBYTE)NULL); <br>    hNewMemDC = CreateCompatibleDC(hDC);                /* Create a DC */ <br>    SelectObject(hNewMemDC, hNewBitmap);                /* Relate them */ <br>    ReleaseDC(hFont, hDC);                      /* Done with font DC */ <br> <br>    BitBlt(hNewMemDC, 0, 0, width, height,      /* Move Character in */ <br>            hMemDC, offsets[iChar], 0, NOTSRCCOPY); <br> <br>    /* Now wake up Clipboard and empty it */ <br>    if (!OpenClipboard(hFont)) <br>        ErrorBox(hBox, vszCannotOpenClip); // , vszCopyingToClip); <br>    else        /* Ok: We got the Clipboard */ <br>        { <br>        EmptyClipboard(); <br>        SetClipboardData(CF_BITMAP, hNewBitmap);        /* Tell Clipboard */ <br>        } <br> <br>    /* Tidy things up */ <br>    CloseClipboard(); <br>    DeleteDC(hNewMemDC); <br>} <br> <br> <br>/**************************************************************************** <br> * GetNewMap(width, height) <br> * <br> * purpose: create new bitmap of the given width and height. <br> * <br> * params : WORD width  : width of bitmap in pixels <br> *          WORD height : height of bitmap in pixels <br> * <br> * returns: TRUE if successful, FALSE otherwise <br> * <br> * side effects: Handle and DC values of new DC assigned <br> * <br> ****************************************************************************/ <br> <br>BOOL <br>GetNewMap( <br>    DWORD width, <br>    DWORD height              /* New size */ <br>    ) <br>{ <br>    HDC hDC; <br> <br>    if (height==0) /* Check if something stupid is happening */ <br>        height=font.PixHeight; /* Fix it */ <br> <br>    /* Put up an houglass ... this may take a while */ <br>    if (!hHourGlass) <br>        hHourGlass = LoadCursor(NULL, IDC_WAIT);        /* Get Hourglass */ <br>    hOldCursor = SetCursor(hHourGlass);         /* Show hourglass */ <br> <br>    /* Create a new bitmap to move the font definition bits into */ <br>    hDC = GetDC(hFont);                         /* DC to be compatible with */ <br>    hNewBitmap = CreateBitmap( <br>                    width &lt;&lt; 3,                 /* Width of font in pixels */ <br>                    height, <br>                    1, 1, (LPBYTE)NULL); <br>    if (!hNewBitmap) <br>        { <br>        ErrorBox(hBox, vszNotEnoughMem); // , vszAllocatingSpace); <br>        ReleaseDC(hFont, hDC);    /* bug# 2380 */ <br>        return FALSE; <br>        } <br> <br>    hNewMemDC = CreateCompatibleDC(hDC);                /* Create a DC */ <br>    SelectObject(hNewMemDC, hNewBitmap);                /* Relate them */ <br>    ReleaseDC(hFont, hDC);                      /* Done with font DC */ <br>    PatBlt(hNewMemDC, 0, 0, width &lt;&lt; 3, height, BLACKNESS);     /* Clear it */ <br>    return TRUE; <br>} <br> <br> <br>/**************************************************************************** <br> * UseNewMap() <br> * <br> * params : none <br> * <br> * purpose: discard old bitmap and replace it with new one <br> * <br> * returns: none <br> * <br> * side effects: Handle to old bitmap and handle to old bitmap DC replaced <br> *               by those of new bitmap respectively <br> * <br> ****************************************************************************/ <br> <br>VOID <br>UseNewMap( <br>    VOID <br>    ) <br>{ <br>    DeleteDC(hMemDC); <br>    DeleteObject(hBitmap);              /* Release old space */ <br>    hBitmap = hNewBitmap; <br>    hMemDC = hNewMemDC;              /* Release old space */ <br>    SetCursor(hOldCursor);              /* Restore regular cursor */ <br>} <br> <br> <br> <br>VOID <br>DeleteGlobalBitmap( <br>    VOID <br>    ) <br>{ <br>    if (hMemDC) <br>        DeleteDC(hMemDC); <br>    if (hBitmap) <br>        DeleteObject(hBitmap); <br>} <br> <br> <br>DWORD <br>Proport( <br>    DWORD value, <br>    DWORD top, <br>    DWORD bottom, <br>    DWORD limit <br>    ) <br>    /* Reproportion a value by the ratio top/bottom to the nearest integer <br>     * and make sure we are still in range */ <br>{ <br>    return min(limit, (DWORD)((1 + 2 * value * top) / (2 * bottom))); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
