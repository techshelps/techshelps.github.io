<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONTDLG.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5392"></a>FONTDLG.C</h2>
<pre><code>/*++ <br> <br>Copyright 1993 - 1998 Microsoft Corporation <br> <br>Module Name: <br> <br>    fontdlg.c <br> <br>Abstract: <br> <br>    Font Editor interface to the common dialog Open File and Save File <br>functions.  Also, this routine displays and controls the font format <br>save dialog. <br> <br> <br>--*/ <br> <br> <br>#include "windows.h" <br>#include &lt;windowsx.h&gt; <br>#include "fontedit.h" <br>#include "commdlg.h" <br> <br> <br>/* message box strings loaded in sample.c from the stringtable */ <br>extern CHAR szIFN[], szFNF[], szREF[], szSCC[], szEOF[], szECF[]; <br> <br>extern CHAR    szAppName []; <br>extern CHAR    szExt []; <br>extern CHAR    szExtDesc []; <br> <br>extern CHAR    szNEWFONT []; <br>extern CHAR    szFRO []; <br> <br>extern INT iFontFormat;             /* Set to the id of current font format */ <br>extern BOOL fReadOnly; <br> <br>CHAR szDlgMsg [MAX_STR_LEN+MAX_FNAME_LEN]; <br> <br>externCHAR szFilter[]; <br> <br>// <br>// Local Function Prototypes. <br>// <br> <br>BOOL <br>DlgCheckFormat ( <br>HANDLE hInstance,       // app module instance handle <br>HWND   hWndParent       // window handle of parent window <br>); <br> <br>BOOL APIENTRY <br>DlgFnCheckFormat ( <br>HWND   hDlg, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>); <br> <br>// <br>// Functions. <br>// <br> <br>BOOL <br>CommDlgOpen ( <br>HWND   hWndParent,      /* window handle of parent window */ <br>OFSTRUCT *pofsReOpenInfo,/* ptr to current file OFSTRUCT (-&gt;cBytes=0 if no <br> * cur. file)*/ <br>CHAR  *pszNewNameIn,    /* ptr to array which will get new file's name <br> * (no path) */ <br>CHAR  *pszExtIn,        /* ptr to current default extension */ <br>CHAR  *pszFileNameOnly,    /* ptr to application name */ <br>BOOL   fOpenType <br>) <br>{ <br>OPENFILENAMEofTempOF; <br>HFILEhFile; <br>        CHAR            szBuf[_MAX_PATH]; <br> <br>ofTempOF.lStructSize =sizeof(OPENFILENAME); <br>ofTempOF.hwndOwner =hWndParent; <br>ofTempOF.lpstrFilter =szFilter; <br>ofTempOF.lpstrCustomFilter =(LPSTR)NULL; <br>ofTempOF.nMaxCustFilter =0L; <br>ofTempOF.nFilterIndex =0L; <br>ofTempOF.lpstrFile =pszNewNameIn; <br>ofTempOF.nMaxFile =MAX_FNAME_LEN; <br>ofTempOF.lpstrFileTitle =pszFileNameOnly; <br>ofTempOF.nMaxFileTitle =MAX_FNAME_LEN; <br>ofTempOF.lpstrInitialDir =(LPSTR)NULL; <br>ofTempOF.lpstrTitle =(LPSTR)NULL; <br>ofTempOF.Flags =OFN_SHOWHELP; <br>ofTempOF.nFileOffset =0; <br>ofTempOF.nFileExtension =0; <br>ofTempOF.lpstrDefExt =pszExtIn; <br> <br>if (fOpenType == FONT_NEW) <br>{ <br>if (MessageBox (hWndParent, (LPSTR)szNEWFONT, (LPSTR)szAppName, <br>MB_OKCANCEL | MB_ICONEXCLAMATION | MB_APPLMODAL) == IDCANCEL) <br>{ <br>return (FALSE); <br>} <br>} <br> <br>        lstrcpy(szBuf,pszNewNameIn); <br>if (GetOpenFileName (&amp;ofTempOF) == FALSE) <br>{ <br>        lstrcpy(pszNewNameIn,szBuf); <br>return (FALSE); <br>} <br> <br>CharUpper (pszNewNameIn); <br> <br>fReadOnly = FALSE; <br> <br>hFile = (HFILE)OpenFile (pszNewNameIn, pofsReOpenInfo, OF_READWRITE); <br> <br>if (hFile == (HFILE) -1) { <br> <br>hFile = (HFILE)OpenFile (pszNewNameIn, pofsReOpenInfo, OF_READ); <br> <br>if (hFile == (HFILE) -1) { <br> <br>DlgMergeStrings (szFNF, pszNewNameIn, szDlgMsg); <br> <br>MessageBox (hWndParent, szDlgMsg, szAppName, <br>MB_OK | MB_ICONASTERISK | MB_APPLMODAL); <br> <br>return (FALSE); <br> <br>} else if (fOpenType != FONT_NEW) { <br> <br>BOOLfResult; <br> <br>DlgMergeStrings (szFRO, pszNewNameIn, szDlgMsg); <br> <br>/* File Is Read Only */ <br>fResult = MessageBox (hWndParent, szDlgMsg, szAppName, <br>MB_OKCANCEL | MB_ICONEXCLAMATION | MB_APPLMODAL); <br> <br>/* Give them the chance to cancel right now. */ <br>if (fResult == IDCANCEL) { <br> <br>_lclose((HFILE)hFile); <br>return (FALSE); <br>} <br> <br>fReadOnly = TRUE; <br>} <br>} <br> <br>_lclose((HFILE)hFile); <br> <br>return (TRUE); <br>} <br> <br>BOOL <br>CommDlgSaveAs( <br>HANDLE hInstance, <br>HWND   hWndParent,      /* window handle of parent window */ <br>OFSTRUCT *pofsReOpenInfo,/* ptr to current file OFSTRUCT (-&gt;cBytes=0 if no <br> * cur. file)*/ <br>CHAR  *pszNewNameIn,    /* ptr to array which will get new file's name <br> * (no path) */ <br>CHAR  *pszExtIn,        /* ptr to current default extension */ <br>CHAR  *pszFileNameOnly  /* ptr to file name */ <br>) <br>{ <br>OPENFILENAMEofTempOF; <br>HFILEhFile; <br>        CHAR szBuf[_MAX_PATH]; <br> <br>ofTempOF.lStructSize =sizeof(OPENFILENAME); <br>ofTempOF.hwndOwner =hWndParent; <br>ofTempOF.lpstrFilter =szFilter; <br>ofTempOF.lpstrCustomFilter =(LPSTR)NULL; <br>ofTempOF.nMaxCustFilter =0L; <br>ofTempOF.nFilterIndex =0L; <br>ofTempOF.lpstrFile =pszNewNameIn; <br>ofTempOF.nMaxFile =MAX_FNAME_LEN; <br>ofTempOF.lpstrFileTitle =pszFileNameOnly; <br>ofTempOF.nMaxFileTitle =MAX_FNAME_LEN; <br>ofTempOF.lpstrInitialDir =(LPSTR)NULL; <br>ofTempOF.lpstrTitle =(LPSTR)NULL; <br>ofTempOF.Flags =OFN_SHOWHELP; <br>ofTempOF.nFileOffset =0; <br>ofTempOF.nFileExtension =0; <br>ofTempOF.lpstrDefExt =pszExtIn; <br> <br>if (DlgCheckFormat (hInstance, hWndParent) == FALSE) <br>{ <br>return (FALSE); <br>} <br> <br>        // save lpstrFile. Because if GetSaveFileName returns 0(i.e. select <br>        // [Cancel] in dialog, pointer to lpstrFile will be lost. <br>        lstrcpy(szBuf,pszNewNameIn); <br> <br>if (GetSaveFileName (&amp;ofTempOF) == FALSE) <br>{ <br>            lstrcpy(pszNewNameIn,szBuf); <br>return (FALSE); <br>} <br> <br>CharUpper (pszNewNameIn); <br> <br>hFile = (HFILE)OpenFile (pszNewNameIn, pofsReOpenInfo, OF_EXIST); <br> <br>if (hFile &gt;= (HFILE) 0) /* already exists */ <br>{ <br>_lclose((HFILE)hFile); <br> <br>DlgMergeStrings (szREF, pszNewNameIn, szDlgMsg); <br> <br>if (MessageBox (hWndParent, (LPSTR)szDlgMsg, (LPSTR)pszNewNameIn, <br>MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION | MB_APPLMODAL) <br>== IDNO) <br>{ <br>return (FALSE); <br>} <br> <br>hFile = (HFILE)OpenFile (pszNewNameIn, pofsReOpenInfo, OF_WRITE); <br> <br>if (hFile == (HFILE) -1) <br>{ <br>DlgMergeStrings(szEOF, pszNewNameIn, szDlgMsg); <br> <br>MessageBox(hWndParent, (LPSTR)szDlgMsg, (LPSTR)pszNewNameIn, <br>MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL); <br> <br>return (FALSE); <br>} <br> <br>_lclose((HFILE)hFile); <br> <br>return (TRUE); <br>} <br> <br>hFile = (HFILE)OpenFile (pszNewNameIn, pofsReOpenInfo, OF_CREATE); <br> <br>if (hFile == (HFILE) -1) <br>{ <br>DlgMergeStrings(szECF, pszNewNameIn, szDlgMsg); <br> <br>MessageBox(hWndParent, (LPSTR)szDlgMsg, (LPSTR)pszNewNameIn, <br>MB_OK | MB_ICONEXCLAMATION | MB_APPLMODAL); <br> <br>return (FALSE); <br>} <br> <br>_lclose((HFILE)hFile); <br> <br>    return (TRUE); <br> <br>} /* end dlgsaveas */ <br> <br> <br>/*============================================================================= <br> DLGMERGESTRINGS scans string1 for merge spec (%%). If found, insert string2 at <br> that point, and then append remainder of string1.  Result in string3. <br>==============================================================================*/ <br>BOOL <br>DlgMergeStrings( <br>CHAR   *szSrc, <br>CHAR   *szMerge, <br>CHAR   *szDst <br>) <br>{ <br>    CHAR *pchSrc; <br>    CHAR *pchDst; <br> <br>    pchSrc = szSrc; <br>    pchDst = szDst; <br> <br>    /* Find merge spec if there is one. */ <br>    while (!((*pchSrc == '%') &amp;&amp; (*(pchSrc+1) == '%')))  { <br>        *pchDst++ = *pchSrc; <br> <br>        /* If we reach end of string before merge spec, just return. */ <br>        if (!*pchSrc++) <br>            return FALSE; <br> <br>    } <br>    /* If merge spec found, insert sz2 there. (check for null merge string */ <br>    if (szMerge) { <br>        while (*szMerge) <br>            *pchDst++ = *szMerge++; <br> <br>    } <br> <br>    /* Jump over merge spec */ <br>    pchSrc++; pchSrc++; <br> <br> <br>    /* Now append rest of Src String */ <br>    while (*pchDst++ = *pchSrc++); <br>    return TRUE; <br> <br>} /* end dlgmergestrings */ <br> <br> <br>BOOL <br>DlgCheckFormat ( <br>HANDLE hInstance,       // app module instance handle <br>HWND   hWndParent       // window handle of parent window <br>) <br>{ <br>    //FARPROC  lpProc; <br>    BOOL     fResult; <br> <br>    fResult = DialogBox (hInstance, (LPSTR)MAKEINTRESOURCE (IDD_FORMAT), <br>//hWndParent, (WNDPROC)(lpProc = DlgFnCheckFormat)); <br>hWndParent, (WNDPROC)DlgFnCheckFormat); <br> <br>    //FreeProcInstance(lpProc); <br> <br>return (fResult); <br> <br>} /* end dlgcheckformat */ <br> <br> <br>BOOL APIENTRY <br>DlgFnCheckFormat ( <br>HWND   hDlg, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>) <br>{ <br> <br>switch (message) <br>{ <br> <br>case WM_INITDIALOG: <br>CheckRadioButton (hDlg, ID_FORMAT2, ID_FORMAT3, iFontFormat); <br>break; <br> <br>case WM_COMMAND: <br> <br>switch (LOWORD(wParam)) <br>{ <br>case IDOK: <br> <br>EndDialog (hDlg, TRUE); <br>break; <br> <br>case IDCANCEL: <br>EndDialog (hDlg, FALSE); <br>break; <br> <br>case ID_FORMAT2: <br>case ID_FORMAT3: <br>CheckRadioButton(hDlg, ID_FORMAT2,ID_FORMAT3, <br>iFontFormat = LOWORD(wParam)); <br>break; <br> <br>default: <br> <br>return FALSE; <br> <br>} /* end switch wparam */ <br>break; <br> <br>default: <br> <br>return FALSE; <br> <br>} /* end switch message */ <br> <br>return TRUE; <br> <br>} /* end dlgsaveasdlg */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
