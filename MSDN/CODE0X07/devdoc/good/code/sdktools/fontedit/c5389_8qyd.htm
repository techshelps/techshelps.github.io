<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONTHEAD.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5395"></a>FONTHEAD.C</h2>
<pre><code>#include "windows.h" <br>#include &lt;windowsx.h&gt; <br>#include "fontedit.h" <br>#include "fcntl.h" <br>#include "stdio.h" <br> <br>#define ATTRDIRLIST 0x4010      /* Include directories and drives in listbox */ <br> <br>/****************************************************************************/ <br>/*              Shared Variables                                            */ <br>/****************************************************************************/ <br>extern LONG lSizeOfOldFontHeader;/* Old font header type. */ <br>extern FontHeaderType font;             /* Structure of Font File Header */ <br>extern FontHeaderType fontBuffer;       /* temp structure of font file header */ <br>CHAR szFontFileFull[FILENAMEMAX] = {"*.FNT"}; /* Name of Font File */ <br>CHAR szFontFile[FILENAMEMAX] = {"*.FNT"}; /* Name of Font File */ <br>CHAR szNewFile[FILENAMEMAX] = {"*.FNT"};  /* Name of New File */ <br>extern CHAR szFaceName[];               /* Face Name of Font */ <br>extern BOOL NewFile;                    /* flag indicating if file was opened <br>                                           by selecting NEW on menu */ <br>extern CHAR *vrgsz[CSTRINGS];           /* string table */ <br>extern BOOL fChanged;                   /* Note if we did anything */ <br>extern INT swH; <br>extern BYTE iChar, jChar; <br> <br>extern HWND hFont;                      /* Handle to Show window */ <br>extern HWND hBox;                       /* Handle to Edit Window */ <br>extern HDC hMemDC;                      /* Handle to Memory Display Context */ <br> <br>extern CHAR szAppName[]; <br>extern INT iFontFormat;             /* format of font currently being edited */ <br>extern DWORD cTable;                /* offset table size */ <br>/****************************************************************************/ <br>/*              Local Variables                                             */ <br>/****************************************************************************/ <br>WORD newCharSet;                  /* Temporary value of font.CharSet */ <br>WORD newFamily;                   /* Temporary value of font.Family &lt;&lt; 4 */ <br>BOOL newFV;     /* Temporay value of Fixed/Variable flag */ <br>WORD newItalic, newUnderline, newStrikeOut; <br>WORD newWeight;         /* Temporary value of font.Weight */ <br>BOOL fMsgBoxUp; /* Bug Fix Hack explained in ReSizeProc */ <br>/****************************************************************************/ <br>/*              Local Functions                                             */ <br>/****************************************************************************/ <br> <br>VOID SetCharSet(HWND hDial); <br>VOID SetFamily(HWND hDial); <br>VOID SetFixed(HWND hDial, BOOL fFV); <br>VOID SetWeight(HWND hDial); <br> <br>/**************************************************************************** <br> * BOOL  APIENTRY HeaderProc(hDial, message, wParam, lParam) <br> * <br> * purpose : Dialog function which verifies and accepts inputs which may <br> *           alter font's header information (font attributes) <br> * <br> * params  : Same as for all dialog functions <br> * <br> * side effects: may alter font attributes <br> * <br> ***************************************************************************/ <br>BOOL  APIENTRY  <br>HeaderProc( <br>HWND   hDial, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam <br>) <br>{ <br>FontHeaderType FAR * lpFont; <br>BOOL fOk;               /* for GetDlgItemInt errors! */ <br>UINT i; <br> <br>UNREFERENCED_PARAMETER(lParam); <br> <br>    lpFont = (FontHeaderType FAR *)&amp;font; <br>    switch (message) <br>        { <br>    default: <br>        return FALSE; <br>    case WM_INITDIALOG: <br>        newCharSet = font.CharSet; <br>        SetCharSet(hDial);      /* Set OEM/ANSI buttons */ <br> <br>        newFamily = (WORD) (font.Family &gt;&gt; 4);   /* Working value */ <br>        SetFamily(hDial);               /* Set Font Family */ <br> <br>        CheckDlgButton(hDial, ID_ITALIC, newItalic = font.Italic); <br>        CheckDlgButton(hDial, ID_UNDERLINE, newUnderline = font.Underline); <br>        CheckDlgButton(hDial, ID_STRIKEOUT, newStrikeOut = font.StrikeOut); <br> <br>        SetDlgItemInt(hDial, ID_POINTS, lpFont-&gt;Points, FALSE); <br>        SetDlgItemInt(hDial, ID_VERT_RES, lpFont-&gt;VertRes, FALSE); <br>        SetDlgItemInt(hDial, ID_HORIZ_RES, lpFont-&gt;HorizRes, FALSE); <br>        SetDlgItemInt(hDial, ID_ASCENT, lpFont-&gt;Ascent, FALSE); <br>        SetDlgItemInt(hDial, ID_EXT_LEADING, lpFont-&gt;ExtLeading, FALSE); <br>        SetDlgItemInt(hDial, ID_INT_LEADING, lpFont-&gt;IntLeading, FALSE); <br>        SetDlgItemInt(hDial, ID_DEFAULT_CHAR,lpFont-&gt;DefaultChar , FALSE); <br>        SetDlgItemInt(hDial, ID_BREAK_CHAR, lpFont-&gt;BreakChar, FALSE); <br> <br>        SetDlgItemText(hDial, ID_COPYRIGHT, lpFont-&gt;Copyright); <br>        SetDlgItemText(hDial, ID_FACE_NAME, (LPSTR)szFaceName); <br>        SetDlgItemText(hDial, ID_FONT_NAME, (LPSTR)szFontFile); <br>        break; <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) <br>            { <br>        case ID_ANSI: <br>            newCharSet = ANSI_CHARSET; <br>            SetCharSet(hDial);          /* Set OEM/ANSI buttons */ <br>            break; <br>        case ID_SYMBOL: <br>            newCharSet = SYMBOL_CHARSET; <br>            SetCharSet(hDial);          /* Set OEM/ANSI buttons */ <br>            break; <br>        case ID_OEM: <br>            newCharSet = OEM_CHARSET; <br>            SetCharSet(hDial);          /* Set OEM/ANSI buttons */ <br>            break; <br>        case ID_SHIFTJIS: <br>            newCharSet = SHIFTJIS_CHARSET; <br>            SetCharSet(hDial);/* Set OEM/ANSI buttons */ <br>            break; <br>        case ID_UNKNOWN: <br>            newFamily = 0; <br>            SetFamily(hDial); <br>            break; <br>        case ID_ROMAN: <br>            newFamily = 1; <br>            SetFamily(hDial); <br>            break; <br>        case ID_SWISS: <br>            newFamily = 2; <br>            SetFamily(hDial); <br>            break; <br>        case ID_MODERN: <br>            newFamily = 3; <br>            SetFamily(hDial); <br>            break; <br>        case ID_SCRIPT: <br>            newFamily = 4; <br>            SetFamily(hDial); <br>            break; <br>        case ID_DECORATIVE: <br>            newFamily = 5; <br>            SetFamily(hDial); <br>            break; <br>        case ID_ITALIC: <br>            newItalic = (WORD) !newItalic; <br>            CheckDlgButton(hDial, ID_ITALIC, newItalic); <br>            break; <br>        case ID_UNDERLINE: <br>            newUnderline = (WORD) !newUnderline; <br>            CheckDlgButton(hDial, ID_UNDERLINE, newUnderline); <br>            break; <br>        case ID_STRIKEOUT: <br>            newStrikeOut = (WORD) !newStrikeOut; <br>            CheckDlgButton(hDial, ID_STRIKEOUT, newStrikeOut); <br>            break; <br>        case ID_CHAR_SET  : <br>            i = GetDlgItemInt(hDial, ID_CHAR_SET, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk &amp;&amp; (i &lt; 256)) <br>                { <br>                font.CharSet = (BYTE) (newCharSet = (WORD) i); <br>                CheckDlgButton(hDial, ID_ANSI, (WORD) (i == ANSI_CHARSET)); <br>                CheckDlgButton(hDial, ID_SYMBOL, (WORD) (i == SYMBOL_CHARSET)); <br>                CheckDlgButton(hDial, ID_OEM, (WORD) (i == OEM_CHARSET)); <br>                CheckDlgButton(hDial, ID_SHIFTJIS,i == SHIFTJIS_CHARSET); <br>                } <br>            break; <br> <br>        case IDOK: <br>            font.CharSet = (BYTE) newCharSet; <br>            font.Family = (BYTE) ((newFamily &lt;&lt; 4) | (font.Family &amp; 1)); <br>            font.Italic = (BYTE) newItalic; <br>            font.Underline = (BYTE) newUnderline; <br>            font.StrikeOut = (BYTE) newStrikeOut; <br>            fChanged = TRUE; <br> <br>            /* nominal point size */ <br>            i = GetDlgItemInt(hDial, ID_POINTS, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                lpFont-&gt;Points = (WORD) i; <br>            else{ <br>                ErrorBox(hDial, vszNomPtSizeNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_POINTS)); <br>                break; <br>                } <br>            /* nominal vertical resolution */ <br>            i = GetDlgItemInt(hDial, ID_VERT_RES, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                lpFont-&gt;VertRes = (WORD) i; <br>            else{ <br>                ErrorBox(hDial, vszNomVertResNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_VERT_RES)); <br>                break; <br>                } <br>            /* nominal horizontal resolution */ <br>            i = GetDlgItemInt(hDial, ID_HORIZ_RES, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                lpFont-&gt;HorizRes = (WORD) i; <br>            else{ <br>                ErrorBox(hDial, vszNomHorResNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_HORIZ_RES)); <br>                break; <br>                } <br>            /* font ascent */ <br>            i = GetDlgItemInt(hDial, ID_ASCENT, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                { <br>                if (i &lt;= font.PixHeight) <br>                    lpFont-&gt;Ascent = (WORD) i; <br>                else{ <br>                    ErrorBox(hDial, vszAscentTooBig); <br>                    SetFocus(GetDlgItem(hDial, ID_ASCENT)); <br>                    break; <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszAscentNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_ASCENT)); <br>                break; <br>                } <br>            /* font external leading */ <br>            i = GetDlgItemInt(hDial, ID_EXT_LEADING, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                lpFont-&gt;ExtLeading = (WORD) i; <br>            else{ <br>                ErrorBox(hDial, vszExtLeadNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_EXT_LEADING)); <br>                break; <br>                } <br>            /* font internal leading */ <br>            i = GetDlgItemInt(hDial, ID_INT_LEADING, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                { <br>                if (i &lt;= font.Ascent) <br>                    lpFont-&gt;IntLeading = (WORD) i; <br>                else{ <br>                    ErrorBox(hDial, vszIntLeadTooBig); <br>                    SetFocus(GetDlgItem(hDial, ID_INT_LEADING)); <br>                    break; <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszIntLeadNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_INT_LEADING)); <br>                break; <br>                } <br>            /* font character set */ <br>            i = GetDlgItemInt(hDial, ID_CHAR_SET, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk &amp;&amp; i &lt; 256) <br>                { <br>                font.CharSet = (BYTE) i; <br>                SetCharSet(hDial); <br>                } <br>            else{ <br>                ErrorBox(hDial, vszCharSetOutOfBounds); <br>                SetFocus(GetDlgItem(hDial, ID_CHAR_SET)); <br>                break; <br>                } <br>            /* font default char number */ <br>            i = GetDlgItemInt(hDial, ID_DEFAULT_CHAR, (LPBOOL)&amp;fOk, FALSE); <br> <br>            if (fOk) <br>                { <br>#ifdef JAPAN // this makes no sense so it will remain langauge specific <br>                if (i &lt;= (UINT)font.LastChar - (UINT)font.FirstChar) <br>#else <br>                if ((i &gt;= font.FirstChar) &amp;&amp; (i &lt;= font.LastChar)) <br>#endif <br>                    lpFont-&gt;DefaultChar = (BYTE) i; <br>                else{ <br>                    ErrorBox(hDial, vszDefCharOutsideFont); <br>                    SetFocus(GetDlgItem(hDial, ID_DEFAULT_CHAR)); <br>                    break; <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszDefCharNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_DEFAULT_CHAR)); <br>                break; <br>                } <br>            /* break char number */ <br>            i = GetDlgItemInt(hDial, ID_BREAK_CHAR, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                { <br>                if ((BYTE)i &lt;= (font.LastChar - font.FirstChar)) <br>                    lpFont-&gt;BreakChar = (BYTE) i; <br>                else{ <br>                    ErrorBox(hDial, vszBreakCharOutsideFont); <br>                    SetFocus(GetDlgItem(hDial, ID_BREAK_CHAR)); <br>                    break; <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszBreakCharNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_BREAK_CHAR)); <br>                break; <br>                } <br>            /* facename string */ <br>            GetDlgItemText(hDial, ID_COPYRIGHT, lpFont-&gt;Copyright, 60); <br>            GetDlgItemText(hDial, ID_FACE_NAME, (LPSTR)szFaceName, szNamesMax); <br>            if (!lstrlen((LPSTR)szFaceName)) <br>                { <br>                lstrcpy((LPSTR)szFaceName, (LPSTR)vszUnknown); <br>                ErrorBox(hDial, vszUnknownFace); <br>                } <br>            /* fall thru to enddialog */ <br> <br> <br>        case IDCANCEL: <br>            EndDialog(hDial, wParam != IDCANCEL); <br>            break; <br> <br>        default: <br>            break; <br>            } <br>        } <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> * char * VerifyHeaderContents() <br> * <br> * purpose: Checks if the Header information of the file just read makes <br> *          sense. If not, returns an error message string to FontLoad <br> * <br> * params : none <br> * <br> * returns :char *szError : ptr to error string if error occurs <br> *                          NULL otherwise <br> * <br> * side effects: none <br> * <br> ***************************************************************************/ <br>CHAR * PASCAL  <br>VerifyHeaderContents( <br>VOID <br>) <br>{ <br>     if (fontBuffer.Points &gt; 999) <br>        return vszNomPtSizeNotOk; <br>     if (fontBuffer.VertRes &gt; 999) <br>        return vszNomVertResNotOk; <br>     if (fontBuffer.HorizRes &gt; 999) <br>        return vszNomHorResNotOk; <br>     if (fontBuffer.Ascent &gt; fontBuffer.PixHeight) <br>        return vszAscentTooBig; <br>     if (fontBuffer.Ascent &gt; 999) <br>        return vszAscentNotOk; <br>     if (fontBuffer.ExtLeading &gt; 999) <br>        return vszExtLeadNotOk; <br>     if (fontBuffer.IntLeading &gt; fontBuffer.Ascent) <br>        return vszIntLeadTooBig; <br>     if (fontBuffer.IntLeading &gt; 999) <br>        return vszIntLeadNotOk; <br>     if (fontBuffer.LastChar &gt; 255) <br>        return vszCharSetOutOfBounds; <br>     if (fontBuffer.DefaultChar &gt; fontBuffer.FirstChar + (fontBuffer.LastChar - fontBuffer.FirstChar)) <br>#if 0 <br>          fontBuffer.DefaultChar = 0; <br>#else <br>        return vszDefCharOutsideFont; <br>#endif <br>     if (fontBuffer.DefaultChar &gt; 255) <br>        return vszDefCharNotOk; <br>     if (fontBuffer.BreakChar &gt; (fontBuffer.LastChar - fontBuffer.FirstChar)) <br>        return vszBreakCharOutsideFont; <br>     if (fontBuffer.BreakChar &gt; 255) <br>        return vszBreakCharNotOk; <br>     if (fontBuffer.PixHeight &gt; 64)  <br>        return vszHeightOutOfBounds; <br>     if (fontBuffer.MaxWidth &gt; 64) <br>        return vszMaxWidthOutOfBounds; <br>     if (fontBuffer.AvgWidth &gt; 64) <br>        return vszAvgWidthOutOfBounds; <br>     if (iFontFormat == ID_FORMAT2) <br>        if (fontBuffer.BitsOffset &gt; (DWORD)SEGMENT_SIZE) <br>            return vszBitsOffsetNotOk; <br>     return NULL; <br>} <br> <br>/**************************************************************************** <br> * BOOL PASCAL Format20FileTooBig(iHeight, iWidth) <br> * <br> * purpose: Checks if the 2.0 font file size is within the 64k <br> *          limit imposed by the 2.0 format offset table.( if file over <br> *          size limit is saved  in 2.0 format, loss of information will <br> *          result) <br> * <br> * params:  WORD iHeight : current height of font in pixels <br> *          WORD iWidth  : current width of font in pixels <br> * <br> * returns: TRUE  : file too large <br> *          FALSE : ok to save <br> * <br> * side effects: none <br> * <br> ***************************************************************************/ <br>BOOL PASCAL  <br>Format20FileTooBig( <br>WORD iHeight, <br>WORD iWidth <br>) <br>{ <br>    if ((DWORD)lSizeOfOldFontHeader + (DWORD)cTable <br>         + (font.LastChar - font.FirstChar +1) <br>         * (((DWORD)iHeight * (DWORD)iWidth ) &gt;&gt; 3) &gt;= WORD_LIMIT) <br>             return TRUE; <br>    return FALSE; <br>} <br> <br>/**************************************************************************** <br> * BOOL  APIENTRY ReSizeProc(hDial, message, wParam, lParam) <br> * <br> * purpose : dialog fn. which verifies and accepts font resize (stretch, <br> *           shrink...) input and calls the appropriate routine to perform <br> *           the function. Also alters font weight attributes (bold, light, <br> *           extra light...) <br> * <br> * params  : same as for all dialog functions <br> * <br> * side effects: alters header information regarding font dimensions and font <br> *               weight <br> * <br> ***************************************************************************/ <br>BOOL  APIENTRY  <br>ReSizeProc( <br>HWND   hDial, <br>WORD   message, <br>WPARAM wParam, <br>LPARAM lParam  <br>) <br>{ <br>FontHeaderType FAR * lpFont; <br>BOOL fOk;               /* for GetDlgItemInt errors! */ <br>UINT i; <br>HMENU hMenu; <br>static BOOL fFV; /* temporary fixed/var width flag */ <br> <br>UNREFERENCED_PARAMETER(lParam); <br> <br>    lpFont = (FontHeaderType FAR *)&amp;font; <br>    switch (message) <br>        { <br>    case WM_INITDIALOG: <br>        fMsgBoxUp = FALSE; <br>        newWeight = (WORD) font.Weight; <br>        newFV = (BOOL) (font.Family &amp; 1); <br>        fFV = newFV; <br>        SetFixed(hDial, fFV);   /* Set Fixed or Variable width */ <br>        SetDlgItemInt(hDial, ID_PIX_HEIGHT, lpFont-&gt;PixHeight, FALSE); <br>        SetDlgItemInt(hDial, ID_FIRST_CHAR, lpFont-&gt;FirstChar, FALSE); <br>        if (!fFV) <br>            SetDlgItemInt(hDial, ID_WIDTH, lpFont-&gt;AvgWidth, FALSE); <br>        else <br>            SetDlgItemInt(hDial, ID_WIDTH, lpFont-&gt;MaxWidth, FALSE); <br>        SetDlgItemInt(hDial, ID_AVERAGE, lpFont-&gt;AvgWidth, FALSE); <br>        SetDlgItemInt(hDial, ID_LAST_CHAR, lpFont-&gt;LastChar, FALSE); <br>        SetWeight(hDial); <br>        SetFixed(hDial, fFV); <br>        break; <br> <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) <br>            { <br>        case ID_THIN: <br>            newWeight = FW_THIN; <br>            SetWeight(hDial); <br>            break; <br>        case ID_EXTRALIGHT: <br>            newWeight = FW_EXTRALIGHT; <br>            SetWeight(hDial); <br>            break; <br>        case ID_LIGHT: <br>            newWeight = FW_LIGHT; <br>            SetWeight(hDial); <br>            break; <br>        case ID_NORMAL: <br>            newWeight = FW_NORMAL; <br>            SetWeight(hDial); <br>            break; <br>        case ID_MEDIUM: <br>            newWeight = FW_MEDIUM; <br>            SetWeight(hDial); <br>            break; <br>        case ID_BOLD: <br>            newWeight = FW_BOLD; <br>            SetWeight(hDial); <br>            break; <br>        case ID_SEMIBOLD: <br>            newWeight = FW_SEMIBOLD; <br>            SetWeight(hDial); <br>            break; <br>        case ID_EXTRABOLD: <br>            newWeight = FW_EXTRABOLD; <br>            SetWeight(hDial); <br>            break; <br>        case ID_HEAVY: <br>            newWeight = FW_HEAVY; <br>            SetWeight(hDial); <br>            break; <br> <br>        case ID_FIXED: <br>            fFV = 0; <br>            SetFixed(hDial, fFV); <br>            break; <br>        case ID_VARIABLE: <br>            fFV = 1; <br>            SetFixed(hDial, fFV); <br>            break; <br> <br>        case IDOK: <br>            fChanged = TRUE; <br>            font.Weight = newWeight; <br>            /* give warning if user attempts to change from variable to <br>               fixed width */ <br>            if ((fFV == 0) &amp;&amp; (newFV != 0)) <br>                { <br>                fMsgBoxUp = TRUE; <br>                ErrorBox(hDial, vszNoVarToFixChange); <br>                fMsgBoxUp = FALSE; <br>                SetFocus(GetDlgItem(hDial, ID_VARIABLE)); <br>                break; <br>                } <br>            else <br>                newFV = fFV; <br> <br>            if (newFV &amp;&amp; !(font.Family &amp; 1)) <br>                { <br>                font.PixWidth = 0;      /* All we need to do to make this */ <br>                font.Family |= 1;       /* .. font variable width */ <br>                } <br>            /* change height command */ <br>            i = GetDlgItemInt(hDial, ID_PIX_HEIGHT, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk &amp;&amp; i &amp;&amp; i &lt; kBoxLim &amp;&amp; i&gt;0 ) <br>                { <br>                    if (i != font.PixHeight){        /* Same size ? */ <br>                        /* No: Resize body height */ <br>                        if (!ResizeBody(font.WidthBytes, i)){ <br>                            SetFocus(hDial); <br>                            break; <br>                        } <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszHeightOutOfBounds); <br>                SetFocus(GetDlgItem(hDial, ID_PIX_HEIGHT)); <br>                break; <br>                } <br> <br>            /* change width command */ <br>            i = GetDlgItemInt(hDial, ID_WIDTH, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk &amp;&amp; i &lt; wBoxLim &amp;&amp; i &gt; 0){ <br>                int kki; <br>                kki = (newFV) ? font.MaxWidth : font.AvgWidth; <br>                if (i != (UINT)kki){ <br>                    if (newFV){ <br>                        if (!SpreadWidths(i)){ <br>                            SetFocus(hDial); <br>                            break;  /* new variable widths */ <br>                        } <br>                    } <br>                    else{ <br>                        if (!ResizeWidths(i)){ <br>                            SetFocus(hDial); <br>                            break;  /* new fixed widths */ <br>                        } <br>                    } <br>                } <br>            } <br>            else{ <br>                ErrorBox(hDial, vszWidthOutOfBounds); <br>                SetFocus(GetDlgItem(hDial, ID_WIDTH)); <br>                break; <br>                } <br> <br>            /* new first char command */ <br>            i = GetDlgItemInt(hDial, ID_FIRST_CHAR, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk) <br>                { <br>                if ((i &lt;= font.LastChar) &amp;&amp; (i &lt;= font.DefaultChar)) <br>                    { <br>                    if (i != font.FirstChar) <br>                        { <br>                        if (!NewFirstChar(i)) <br>                            break; <br>                        iChar = jChar = (CHAR) i; <br>                        swH = 0; <br>                        ScrollFont();           /* Show front end */ <br>                        } <br>                    } <br>                else{ <br>                    ErrorBox(hDial, vszChar1MoreThanDChar); <br>                    SetFocus(GetDlgItem(hDial, ID_FIRST_CHAR)); <br>                    break; <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszChar1NotOk); <br>                SetFocus(GetDlgItem(hDial, ID_FIRST_CHAR)); <br>                break; <br>                } <br> <br> <br>            /* new last char command */ <br>            i = GetDlgItemInt(hDial, ID_LAST_CHAR, (LPBOOL)&amp;fOk, FALSE); <br>            if (fOk &amp;&amp; i &lt; 256) <br>                { <br>                if ((i &gt;= font.FirstChar) &amp;&amp;  <br>(i &gt;= font.DefaultChar)) <br>                    { <br>                    if (i != font.LastChar) <br>                        { <br>                        if (!NewLastChar(i)) <br>                            break; <br>                        iChar = jChar = (CHAR) i; <br>                        swH = 100; <br>                        ScrollFont();           /* Show back end */ <br>                        } <br>                    } <br>                else{ <br>                    ErrorBox(hDial, vszLastCharTooSmall); <br>                    SetFocus(GetDlgItem(hDial, ID_LAST_CHAR)); <br>                    break; <br>                    } <br>                } <br>            else{ <br>                ErrorBox(hDial, vszLastCharNotOk); <br>                SetFocus(GetDlgItem(hDial, ID_LAST_CHAR)); <br>                break; <br>                } <br> <br>            /* this is moved from SetFixed, since it should only be done <br>             * if idok pressed. */ <br>            if (newFV) <br>                {  /* Enable "width" if variable-width font */ <br>                hMenu = GetMenu(hBox); <br>                EnableMenuItem(hMenu, 4, MF_BYPOSITION | MF_ENABLED); <br>                DrawMenuBar(hBox); <br>                } <br> <br>            /* fall thru to enddialog...*/ <br> <br>        case IDCANCEL: <br>            EndDialog(hDial, wParam != IDCANCEL); <br>            break; <br> <br>        default: <br>            return FALSE; <br>            break; <br>            }  /* end switch wParam */ <br> <br>    default: <br>        return FALSE; <br>        } /* end switch message */ <br> <br>    return TRUE; <br>} <br> <br>VOID <br>ErrorBox( <br>HWND hWndparent,     <br>CHAR * szMessage <br>) <br>/* Show Message Box */ <br>{ <br>    MessageBox(hWndparent, (LPSTR)szMessage, (LPSTR)szAppName, <br>                  MB_OK | MB_ICONASTERISK | MB_APPLMODAL); <br>} <br> <br>/**************************************************************************** <br> * SetCharSet(hDial) <br> * <br> * purpose : Set ANSI/OEM dialog button and set the number in edit window <br> * <br> * param   : HWND hDial : handle to dialog box window <br> * <br> * returns : none <br> * <br> ***************************************************************************/ <br>VOID <br>SetCharSet( <br>HWND hDial <br>) <br>{ <br>    CheckDlgButton(hDial, ID_ANSI, (WORD) (newCharSet == ANSI_CHARSET)); <br>    CheckDlgButton(hDial, ID_SYMBOL, (WORD) (newCharSet == SYMBOL_CHARSET)); <br>    CheckDlgButton(hDial, ID_OEM, (WORD) (newCharSet == OEM_CHARSET)); <br>    CheckDlgButton(hDial, ID_SHIFTJIS, newCharSet == SHIFTJIS_CHARSET); <br>    SetDlgItemInt(hDial,  ID_CHAR_SET, newCharSet, FALSE); <br>} <br> <br>/**************************************************************************** <br> * SetFixed(hDial) <br> * <br> * purpose : Set fixed/variable dialog button <br> * <br> * params  : HWND hDial : handle to dialog box window <br> *           BOOL fFV   : variable or fixed <br> * <br> * returns : none <br> * <br> ***************************************************************************/ <br>VOID <br>SetFixed( <br>HWND hDial, <br>BOOL fFV <br>) <br>{ <br>    CheckDlgButton(hDial, ID_FIXED, (WORD)(fFV == 0)); <br>    CheckDlgButton(hDial, ID_VARIABLE, (WORD)(fFV == 1)); <br>    if (newFV) <br>        SetDlgItemText(hDial, ID_WIDTH_TEXT, (LPSTR)vszMaxWidth); <br>    else <br>        SetDlgItemText(hDial, ID_WIDTH_TEXT, (LPSTR)vszCharPixelWidth); <br>} <br> <br>/**************************************************************************** <br> * SetWeight(hDial) <br> * <br> * purpose : Set font weight dialog button <br> * <br> * params  : HWND hDial : handle to dialog box window <br> * <br> * returns : none <br> * <br> ****************************************************************************/ <br>VOID <br>SetWeight( <br>HWND hDial <br>) <br>{ <br>    CheckDlgButton(hDial, ID_THIN, (WORD)(newWeight == FW_THIN)); <br>    CheckDlgButton(hDial, ID_EXTRALIGHT, (WORD)(newWeight == FW_EXTRALIGHT)); <br>    CheckDlgButton(hDial, ID_LIGHT, (WORD)(newWeight == FW_LIGHT)); <br>    CheckDlgButton(hDial, ID_NORMAL, (WORD)(newWeight == FW_NORMAL)); <br>    CheckDlgButton(hDial, ID_MEDIUM, (WORD)(newWeight == FW_MEDIUM)); <br>    CheckDlgButton(hDial, ID_SEMIBOLD, (WORD)(newWeight == FW_SEMIBOLD)); <br>    CheckDlgButton(hDial, ID_BOLD, (WORD)(newWeight == FW_BOLD)); <br>    CheckDlgButton(hDial, ID_EXTRABOLD, (WORD)(newWeight == FW_EXTRABOLD)); <br>    CheckDlgButton(hDial, ID_HEAVY, (WORD)(newWeight == FW_HEAVY)); <br>} <br> <br>/**************************************************************************** <br> * SetFamily(hDial) <br> * <br> * purpose : Set font family dialog button <br> * <br> * params  : HWND hDial : handle to dialog box window <br> * <br> * returns : none <br> * <br> ***************************************************************************/ <br>VOID <br>SetFamily( <br>HWND hDial <br>) <br>{ <br>    CheckDlgButton(hDial, ID_UNKNOWN, (WORD) (newFamily == 0)); <br>    CheckDlgButton(hDial, ID_ROMAN, (WORD)(newFamily == 1)); <br>    CheckDlgButton(hDial, ID_SWISS, (WORD)(newFamily == 2)); <br>    CheckDlgButton(hDial, ID_MODERN, (WORD)(newFamily == 3)); <br>    CheckDlgButton(hDial, ID_SCRIPT, (WORD)(newFamily == 4)); <br>    CheckDlgButton(hDial, ID_DECORATIVE, (WORD) (newFamily == 5)); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
