<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ZOOMIN.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5772"></a>ZOOMIN.C</h2>
<pre><code>/****************************************************************************/ <br>/*                                                                          */ <br>/*                         Microsoft Confidential                           */ <br>/*                                                                          */ <br>/*                 Copyright (c) Microsoft Corp.  1987-1996                 */ <br>/*                           All Rights Reserved                            */ <br>/*                                                                          */ <br>/****************************************************************************/ <br>/****************************** Module Header ******************************* <br>* Module Name: zoomin.c <br>* <br>* Microsoft ZoomIn utility.  This tool magnifies a portion of the screen, <br>* allowing you to see things at a pixel level. <br>* <br>* History: <br>* 01/01/88                              Created. <br>* 01/01/92                              Ported to NT. <br>* 03/06/92                              Cleanup. <br>* <br>****************************************************************************/ <br> <br>#include "zoomin.h" <br> <br> <br>CHAR szAppName[] = "ZoomIn";            // Aplication name. <br>HINSTANCE ghInst;                       // Instance handle. <br>HWND ghwndApp;                          // Main window handle. <br>HANDLE ghaccelTable;                    // Main accelerator table. <br>INT gnZoom = 4;                         // Zoom (magnification) factor. <br>HPALETTE ghpalPhysical;                 // Handle to the physical palette. <br>INT gcxScreenMax;                       // Width of the screen (less 1). <br>INT gcyScreenMax;                       // Height of the screen (less 1). <br>INT gcxZoomed;                          // Client width in zoomed pixels. <br>INT gcyZoomed;                          // Client height in zoomed pixels. <br>BOOL gfRefEnable = FALSE;               // TRUE if refresh is enabled. <br>INT gnRefInterval = 20;                 // Refresh interval in 10ths of seconds. <br>BOOL gfTracking = FALSE;                // TRUE if tracking is in progress. <br>POINT gptZoom = {100, 100};             // The center of the zoomed area. <br> <br> <br> <br>/************************************************************************ <br>* WinMain <br>* <br>* Main entry point for the application. <br>* <br>* Arguments: <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>INT WINAPI WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, INT nCmdShow) <br>{ <br>    MSG msg; <br> <br>    if (!InitInstance(hInst, nCmdShow)) <br>        return FALSE; <br> <br>    /*     * Polling messages from event queue <br>     */ <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if (!TranslateAccelerator(ghwndApp, ghaccelTable, &amp;msg)) { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    return msg.wParam; <br>} <br> <br> <br> <br>/************************************************************************ <br>* InitInstance <br>* <br>* Instance initialization for the app. <br>* <br>* Arguments: <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>BOOL InitInstance( <br>    HINSTANCE hInst, <br>    INT cmdShow) <br>{ <br>    WNDCLASS wc; <br>    INT dx; <br>    INT dy; <br>    DWORD flStyle; <br>    RECT rc; <br> <br>    ghInst = hInst; <br> <br>    /* <br>     * Register a class for the main application window. <br>     */ <br>    wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>    wc.hIcon          = LoadIcon(hInst, "zoomin"); <br>    wc.lpszMenuName   = MAKEINTRESOURCE(IDMENU_ZOOMIN); <br>    wc.lpszClassName  = szAppName; <br>    wc.hbrBackground  = GetStockObject(BLACK_BRUSH); <br>    wc.hInstance      = hInst; <br>    wc.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW; <br>    wc.lpfnWndProc    = (WNDPROC)AppWndProc; <br>    wc.cbWndExtra     = 0; <br>    wc.cbClsExtra     = 0; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    if (!(ghaccelTable = LoadAccelerators(hInst, MAKEINTRESOURCE(IDACCEL_ZOOMIN)))) <br>        return FALSE; <br> <br>    if (!(ghpalPhysical = CreatePhysicalPalette())) <br>        return FALSE; <br> <br>    gcxScreenMax = GetSystemMetrics(SM_CXSCREEN) - 1;    gcyScreenMax = GetSystemMetrics(SM_CYSCREEN) - 1; <br> <br>    flStyle = WS_CAPTION | WS_OVERLAPPED | WS_SYSMENU | WS_THICKFRAME | <br>            WS_MINIMIZEBOX | WS_VSCROLL; <br>    dx = 44 * gnZoom; <br>    dy = 36 * gnZoom; <br> <br>    SetRect(&amp;rc, 0, 0, dx, dy); <br>    AdjustWindowRect(&amp;rc, flStyle, TRUE); <br> <br>    ghwndApp = CreateWindow(szAppName, szAppName, flStyle, <br>            CW_USEDEFAULT, 0, rc.right - rc.left, rc.bottom - rc.top, <br>            NULL, NULL, hInst, NULL); <br> <br>    if (!ghwndApp) <br>        return FALSE; <br>    ShowWindow(ghwndApp, cmdShow); <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/************************************************************************ <br>* CreatePhysicalPalette <br>* <br>* Creates a palette for the app to use.  The palette references the <br>* physical palette, so that it can properly display images grabbed <br>* from palette managed apps. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>HPALETTE CreatePhysicalPalette(VOID) <br>{ <br>    PLOGPALETTE ppal; <br>    HPALETTE hpal = NULL; <br>    INT i; <br> <br>    ppal = (PLOGPALETTE)LocalAlloc(LPTR, <br>            sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * NPAL); <br>    if (ppal) { <br>        ppal-&gt;palVersion = 0x300; <br>        ppal-&gt;palNumEntries = NPAL; <br> <br>        for (i = 0; i &lt; NPAL; i++) { <br>            ppal-&gt;palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT; <br>            ppal-&gt;palPalEntry[i].peRed   = (BYTE)i; <br>            ppal-&gt;palPalEntry[i].peGreen = (BYTE)0; <br>            ppal-&gt;palPalEntry[i].peBlue  = (BYTE)0; <br>        } <br> <br>        hpal = CreatePalette(ppal); <br>        LocalFree(ppal); <br>    } <br> <br>    return hpal; <br>} <br> <br> <br> <br>/************************************************************************ <br>* AppWndProc <br>* <br>* Main window proc for the zoomin utility. <br>* <br>* Arguments: <br>*   Standard window proc args. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>LONG APIENTRY AppWndProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    HCURSOR hcurOld; <br> <br>    switch (msg) { <br>        case WM_CREATE: <br>            SetScrollRange(hwnd, SB_VERT, MIN_ZOOM, MAX_ZOOM, FALSE); <br>            SetScrollPos(hwnd, SB_VERT, gnZoom, FALSE); <br>            break; <br> <br>        case WM_TIMER: <br>            /* <br>             * Update on every timer message.  The cursor will be <br>             * flashed to the hourglash for some visual feedback <br>             * of when a snapshot is being taken. <br>             */ <br>            hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>            DoTheZoomIn(NULL); <br>            SetCursor(hcurOld); <br>            break; <br> <br>        case WM_PAINT: <br>            BeginPaint(hwnd, &amp;ps); <br>            DoTheZoomIn(ps.hdc); <br>            EndPaint(hwnd, &amp;ps); <br>            return 0L; <br> <br>        case WM_SIZE: <br>            CalcZoomedSize(); <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            ((gptZoom).x = (SHORT)LOWORD(lParam), (gptZoom).y = (SHORT)HIWORD(lParam)); <br>            ClientToScreen(hwnd, &amp;gptZoom); <br>            DrawZoomRect(); <br>            DoTheZoomIn(NULL); <br> <br>            SetCapture(hwnd); <br>            gfTracking = TRUE; <br> <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            if (gfTracking) { <br>                DrawZoomRect(); <br>                ((gptZoom).x = (SHORT)LOWORD(lParam), (gptZoom).y = (SHORT)HIWORD(lParam)); <br>                ClientToScreen(hwnd, &amp;gptZoom); <br>                DrawZoomRect(); <br>                DoTheZoomIn(NULL); <br>            } <br> <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            if (gfTracking) { <br>                DrawZoomRect(); <br>                ReleaseCapture(); <br>                gfTracking = FALSE; <br>            } <br> <br>            break; <br> <br>        case WM_VSCROLL: <br>            switch (LOWORD(wParam)) { <br>                case SB_LINEDOWN: <br>                    gnZoom++; <br>                    break; <br> <br>                case SB_LINEUP: <br>                    gnZoom--; <br>                    break; <br> <br>                case SB_PAGEUP: <br>                    gnZoom -= 2; <br>                    break; <br> <br>                case SB_PAGEDOWN: <br>                    gnZoom += 2; <br>                    break; <br> <br>                case SB_THUMBPOSITION: <br>                case SB_THUMBTRACK: <br>                    gnZoom = HIWORD(wParam); <br>                    break; <br>            } <br> <br>            gnZoom = BOUND(gnZoom, MIN_ZOOM, MAX_ZOOM); <br>            SetScrollPos(hwnd, SB_VERT, gnZoom, TRUE); <br>            CalcZoomedSize(); <br>            DoTheZoomIn(NULL); <br>            break; <br> <br>        case WM_KEYDOWN: <br>            switch (wParam) { <br>                case VK_UP: <br>                case VK_DOWN: <br>                case VK_LEFT: <br>                case VK_RIGHT: <br>                    MoveView((INT)wParam, GetKeyState(VK_SHIFT) &amp; 0x8000, <br>                            GetKeyState(VK_CONTROL) &amp; 0x8000); <br>                    break; <br>            } <br> <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case MENU_EDIT_COPY: <br>                    CopyToClipboard(); <br>                    break; <br> <br>                case MENU_EDIT_REFRESH: <br>                    DoTheZoomIn(NULL); <br>                    break; <br> <br>                case MENU_OPTIONS_REFRESHRATE: <br>                    DialogBox(ghInst, (LPSTR)MAKEINTRESOURCE(DID_REFRESHRATE), <br>                            hwnd, (WNDPROC)RefreshRateDlgProc); <br> <br>                    break; <br> <br>                case MENU_HELP_ABOUT: <br>                    DialogBox(ghInst, (LPSTR)MAKEINTRESOURCE(DID_ABOUT), <br>                            hwnd, (WNDPROC)AboutDlgProc); <br> <br>                    break; <br> <br>                default: <br>                     break; <br>            } <br> <br>            break; <br> <br>        case WM_CLOSE: <br>            if (ghpalPhysical) <br>                DeleteObject(ghpalPhysical); <br> <br>            DestroyWindow(hwnd); <br> <br>            break; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    return 0L; <br>} <br> <br> <br> <br>/************************************************************************ <br>* CalcZoomedSize <br>* <br>* Calculates some globals.  This routine needs to be called any <br>* time that the size of the app or the zoom factor changes. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID CalcZoomedSize(VOID) <br>{ <br>    RECT rc; <br> <br>    GetClientRect(ghwndApp, &amp;rc); <br> <br>    gcxZoomed = (rc.right / gnZoom) + 1; <br>    gcyZoomed = (rc.bottom / gnZoom) + 1; <br>} <br> <br> <br> <br>/************************************************************************ <br>* DoTheZoomIn <br>* <br>* Does the actual paint of the zoomed image. <br>* <br>* Arguments: <br>*   HDC hdc - If not NULL, this hdc will be used to paint with. <br>*             If NULL, a dc for the apps window will be obtained. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID DoTheZoomIn( <br>    HDC hdc) <br>{ <br>    BOOL fRelease; <br>    HPALETTE hpalOld = NULL; <br>    HDC hdcScreen; <br>    INT x; <br>    INT y; <br> <br>    if (!hdc) { <br>        hdc = GetDC(ghwndApp); <br>        fRelease = TRUE; <br>    } <br>    else { <br>        fRelease = FALSE; <br>    } <br> <br>    if (ghpalPhysical) { <br>        hpalOld = SelectPalette(hdc, ghpalPhysical, FALSE); <br>        RealizePalette(hdc); <br>    } <br> <br>    /* <br>     * The point must not include areas outside the screen dimensions. <br>     */ <br>    x = BOUND(gptZoom.x, gcxZoomed / 2, gcxScreenMax - (gcxZoomed / 2)); <br>    y = BOUND(gptZoom.y, gcyZoomed / 2, gcyScreenMax - (gcyZoomed / 2)); <br> <br>    hdcScreen = GetDC(NULL); <br>    SetStretchBltMode(hdc, COLORONCOLOR); <br>    StretchBlt(hdc, 0, 0, gnZoom * gcxZoomed, gnZoom * gcyZoomed, <br>            hdcScreen, x - gcxZoomed / 2, <br>            y - gcyZoomed / 2, gcxZoomed, gcyZoomed, SRCCOPY); <br>    ReleaseDC(NULL, hdcScreen); <br> <br>    if (hpalOld) <br>        SelectPalette(hdc, hpalOld, FALSE); <br> <br>    if (fRelease) <br>        ReleaseDC(ghwndApp, hdc); <br>} <br> <br> <br> <br>/************************************************************************ <br>* MoveView <br>* <br>* This function moves the current view around. <br>* <br>* Arguments: <br>*   INT nDirectionCode - Direction to move.  Must be VK_UP, VK_DOWN, <br>*                        VK_LEFT or VK_RIGHT. <br>*   BOOL fFast         - TRUE if the move should jump a larger increment. <br>*                        If FALSE, the move is just one pixel. <br>*   BOOL fPeg          - If TRUE, the view will be pegged to the screen <br>*                        boundary in the specified direction.  This overides <br>*                        the fFast parameter. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID MoveView( <br>    INT nDirectionCode, <br>    BOOL fFast, <br>    BOOL fPeg) <br>{ <br>    INT delta; <br> <br>    if (fFast) <br>        delta = FASTDELTA; <br>    else <br>        delta = 1; <br> <br>    switch (nDirectionCode) { <br>        case VK_UP: <br>            if (fPeg) <br>                gptZoom.y = gcyZoomed / 2; <br>            else <br>                gptZoom.y -= delta; <br> <br>            gptZoom.y = BOUND(gptZoom.y, 0, gcyScreenMax); <br> <br>            break; <br> <br>        case VK_DOWN: <br>            if (fPeg) <br>                gptZoom.y = gcyScreenMax - (gcyZoomed / 2); <br>            else <br>                gptZoom.y += delta; <br> <br>            gptZoom.y = BOUND(gptZoom.y, 0, gcyScreenMax); <br> <br>            break; <br> <br>        case VK_LEFT: <br>            if (fPeg) <br>                gptZoom.x = gcxZoomed / 2; <br>            else <br>                gptZoom.x -= delta; <br> <br>            gptZoom.x = BOUND(gptZoom.x, 0, gcxScreenMax); <br> <br>            break; <br> <br>        case VK_RIGHT: <br>            if (fPeg) <br>                gptZoom.x = gcxScreenMax - (gcxZoomed / 2); <br>            else <br>                gptZoom.x += delta; <br> <br>            gptZoom.x = BOUND(gptZoom.x, 0, gcxScreenMax); <br> <br>            break; <br>    } <br> <br>    DoTheZoomIn(NULL); <br>} <br> <br> <br> <br>/************************************************************************ <br>* DrawZoomRect <br>* <br>* This function draws the tracking rectangle.  The size and shape of <br>* the rectangle will be proportional to the size and shape of the <br>* app's client, and will be affected by the zoom factor as well. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID DrawZoomRect(VOID) <br>{ <br>    HDC hdc; <br>    RECT rc; <br>    INT x; <br>    INT y; <br> <br>    x = BOUND(gptZoom.x, gcxZoomed / 2, gcxScreenMax - (gcxZoomed / 2)); <br>    y = BOUND(gptZoom.y, gcyZoomed / 2, gcyScreenMax - (gcyZoomed / 2)); <br> <br>    rc.left   = x - gcxZoomed / 2; <br>    rc.top    = y - gcyZoomed / 2; <br>    rc.right  = rc.left + gcxZoomed; <br>    rc.bottom = rc.top + gcyZoomed; <br> <br>    InflateRect(&amp;rc, 1, 1); <br> <br>    hdc = GetDC(NULL); <br> <br>    PatBlt(hdc, rc.left,    rc.top,     rc.right-rc.left, 1,  DSTINVERT); <br>    PatBlt(hdc, rc.left,    rc.bottom,  1, -(rc.bottom-rc.top),   DSTINVERT); <br>    PatBlt(hdc, rc.right-1, rc.top,     1,   rc.bottom-rc.top,   DSTINVERT); <br>    PatBlt(hdc, rc.right,   rc.bottom-1, -(rc.right-rc.left), 1, DSTINVERT); <br> <br>    ReleaseDC(NULL, hdc); <br>} <br> <br> <br> <br>/************************************************************************ <br>* EnableRefresh <br>* <br>* This function turns on or off the auto-refresh feature. <br>* <br>* Arguments: <br>*   BOOL fEnable - TRUE to turn the refresh feature on, FALSE to <br>*                  turn it off. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID EnableRefresh( <br>    BOOL fEnable) <br>{ <br>    if (fEnable) { <br>        /* <br>         * Already enabled.  Do nothing. <br>         */ <br>        if (gfRefEnable) <br>            return; <br> <br>        if (SetTimer(ghwndApp, IDTIMER_ZOOMIN, gnRefInterval * 100, NULL)) <br>            gfRefEnable = TRUE; <br>    } <br>    else { <br>        /* <br>         * Not enabled yet.  Do nothing. <br>         */ <br>        if (!gfRefEnable) <br>            return; <br> <br>        KillTimer(ghwndApp, IDTIMER_ZOOMIN); <br>        gfRefEnable = FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* CopyToClipboard <br>* <br>* This function copies the client area image of the app into the <br>* clipboard. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>VOID CopyToClipboard(VOID) <br>{ <br>    HDC hdcSrc; <br>    HDC hdcDst; <br>    RECT rc; <br>    HBITMAP hbm; <br> <br>    if (OpenClipboard(ghwndApp)) { <br>        EmptyClipboard(); <br> <br>        if (hdcSrc = GetDC(ghwndApp)) { <br>            GetClientRect(ghwndApp, &amp;rc); <br>            if (hbm = CreateCompatibleBitmap(hdcSrc, <br>                    rc.right - rc.left, rc.bottom - rc.top)) { <br>                if (hdcDst = CreateCompatibleDC(hdcSrc)) { <br>                    /* <br>                     * Calculate the dimensions of the bitmap and <br>                     * convert them to tenths of a millimeter for <br>                     * setting the size with the SetBitmapDimensionEx <br>                     * call.  This allows programs like WinWord to <br>                     * retrieve the bitmap and know what size to <br>                     * display it as. <br>                     */ <br>                     <br> <br> <br> <br> <br> <br>SetBitmapDimensionEx(hbm, (DWORD)((INT)(((DWORD)(rc.right - rc.left) * MM10PERINCH) / (DWORD)GetDeviceCaps(hdcSrc, LOGPIXELSX))), (DWORD)((INT)(((DWORD)(rc.bottom - rc.top) * MM10PERINCH) / (DWORD)GetDeviceCaps(hdcSrc, LOGPIXELSY))), NULL); <br> <br>                    SelectObject(hdcDst, hbm); <br>                    BitBlt(hdcDst, 0, 0, <br>                            rc.right - rc.left, rc.bottom - rc.top, <br>                            hdcSrc, rc.left, rc.top, SRCCOPY); <br>                    DeleteDC(hdcDst); <br>                    SetClipboardData(CF_BITMAP, hbm); <br>                } <br>                else { <br>                    DeleteObject(hbm); <br>                } <br>            } <br> <br>            ReleaseDC(ghwndApp, hdcSrc); <br>        } <br> <br>        CloseClipboard(); <br>    } <br>    else { <br>        MessageBeep(0); <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* AboutDlgProc <br>* <br>* This is the About Box dialog procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>BOOL APIENTRY AboutDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            EndDialog(hwnd, IDOK); <br>            return TRUE; <br> <br>        default: <br>            return FALSE; <br>    } <br>} <br> <br> <br> <br>/************************************************************************ <br>* RefreshRateDlgProc <br>* <br>* This is the Refresh Rate dialog procedure. <br>* <br>* History: <br>* <br>************************************************************************/ <br> <br>BOOL APIENTRY RefreshRateDlgProc( <br>    HWND hwnd, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    BOOL fTranslated; <br> <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            SendDlgItemMessage(hwnd, DID_REFRESHRATEINTERVAL, EM_LIMITTEXT, <br>                    3, 0L); <br>            SetDlgItemInt(hwnd, DID_REFRESHRATEINTERVAL, gnRefInterval, FALSE); <br>            CheckDlgButton(hwnd, DID_REFRESHRATEENABLE, gfRefEnable ? 1 : 0); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case IDOK: <br>                    gnRefInterval = GetDlgItemInt(hwnd, DID_REFRESHRATEINTERVAL, <br>                            &amp;fTranslated, FALSE); <br> <br>                    /* <br>                     * Stop any existing timers then start one with the <br>                     * new interval if requested to. <br>                     */ <br>                    EnableRefresh(FALSE); <br>                    EnableRefresh( <br>                            IsDlgButtonChecked(hwnd, DID_REFRESHRATEENABLE)); <br> <br>                    EndDialog(hwnd, IDOK); <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hwnd, IDCANCEL); <br>                    break; <br>            } <br> <br>            break; <br>    } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
