<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PORTTOOL.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5504"></a>PORTTOOL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright (C) 1993-96 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "porttool.h" <br>#include "port.h" <br> <br>/* forward declarations of helper functions in this module */ <br>HWND   WINAPI StartInteractive (HANDLE, char *, int); <br>HANDLE WINAPI StartBackground (HANDLE, HWND, char *); <br>VOID   WINAPI InitializeMenu (HWND, HANDLE); <br>LONG   WINAPI CommandHandler (HWND, UINT, LONG); <br>int    WINAPI SetWrap (HWND); <br>BOOL   WINAPI GetCmdLine (char *, char *, BOOL *, char *); <br>int    WINAPI Save_YNC (HWND); <br>VOID   WINAPI SetWindowTitle (HWND, char*); <br>VOID   WINAPI GetEditSubString (HWND, PUINT, PUINT, char *); <br> <br>UINT    uSearchMsg; <br>HWND    hDlgPortStatus; <br>HWND    hDlgPort; <br> <br>DWORD   dwVersion=0; // Global variable to store current system version info <br> <br> <br>/* test case static variables for background porting */ <br>HANDLE              hEvents[nBKPORTEVENTS]; <br>BKPORTFILESTRUCT    BkPort; <br> <br> <br> <br>/* entry point ot this executable */ <br>int WINAPI WinMain (hInstance, hPrevInstance, lpCmdLine, nCmdShow) <br>    HINSTANCE hInstance; <br>    HINSTANCE hPrevInstance; <br>    LPSTR  lpCmdLine; <br>    int    nCmdShow; <br>{ <br>    MSG        msg; <br>    HWND       hWnd; <br>    HANDLE     hAccel; <br>    BOOL       bBkgnd = 0; <br>    char       *lpszBuff = NULL; <br>    char       *lpszCmdLine = NULL; <br>    char       *lpCL; <br> <br> <br>    /* previous instances do not exist in Win32 */ <br>    if (hPrevInstance) <br>return 0; <br> <br>    /* Get OS version info, and store in a global variable */ <br>dwVersion = GetVersion(); <br> <br>lpszPortIniFilePath[0] = 0; <br> <br>    /* parse and copy command line parameters to local memory */ <br>    lpCL = GetCommandLine (); <br>    if (lpszCmdLine = (char *)LocalAlloc (LPTR, strlen (lpCL) + 1)) <br>GetCmdLine (lpCL, lpszCmdLine, &amp;bBkgnd, lpszPortIniFilePath); <br> <br>    /* if /b switch, start background porting session */ <br>    if (bBkgnd) <br>{ <br>/* invoke background port status dialog */ <br>// MessageBox(NULL, "Backgroud Porting Disabled","Porttool",MB_OK); <br> <br>if (lpszPortIniFilePath[0] == 0 ) <br>{ <br>   ErrorNotify (NULL, IDS_PORTFILEBACKMSG); <br>   return FALSE; <br>} <br>else if ( ! InitPortData(lpszPortIniFilePath) ) <br>   ErrorNotify (NULL, IDS_PORTINITFAILED); <br> <br>if (!(hDlgPortStatus = StartBackground (hInstance, NULL, lpszCmdLine))) <br>return FALSE; <br>} <br> <br>    /* start interactive porting session */ <br>    else <br>{ <br>if (!(hWnd = StartInteractive (hInstance, lpszCmdLine, nCmdShow))) <br>    return FALSE; <br>} <br> <br>    /* free memory allocated for pCmdLine */ <br>    if (lpszCmdLine) <br>LocalFree ((HLOCAL)lpszCmdLine); <br> <br>    /* load main accelerator table */ <br>    hAccel = LoadAccelerators (hInstance, MAKEINTRESOURCE (IDA_PORTTOOL)); <br> <br>    /* main window message loop */ <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) <br>{ <br>if ((!hDlgSearch     || !IsDialogMessage (hDlgSearch, &amp;msg))     &amp;&amp; <br>    (!hDlgPort       || !IsDialogMessage (hDlgPort, &amp;msg))       &amp;&amp; <br>    (!hDlgPortStatus || !IsDialogMessage (hDlgPortStatus, &amp;msg)) &amp;&amp; <br>    (!hAccel         || !TranslateAccelerator (hWnd, hAccel, &amp;msg))) <br>    { <br>    TranslateMessage (&amp;msg); <br>    DispatchMessage (&amp;msg); <br>    } <br>} <br> <br>    /* return success of application */ <br>    return TRUE; <br>} <br> <br> <br>// <br>// Used only on FE versions to screen out vertical fonts <br>// <br> <br>BOOL APIENTRY ChooseFontHookProc( <br>    HWND hDlg,              /* window handle of the dialog box */ <br>    UINT message,           /* type of message                 */ <br>    WPARAM wParam,          /* message-specific information    */ <br>    LPARAM lParam) <br>{ <br>    switch (message) { <br>    case WM_INITDIALOG: <br>        { <br>            LOGFONT lf; <br>            char szFaceName[LF_FACESIZE]; <br>            UINT uiId, uiCount; <br> <br>            uiCount = SendDlgItemMessage(hDlg, cmb1, CB_GETCOUNT, 0, 0L); <br>            /* Delete vertical font */ <br>            for (uiId = 0; uiId &lt; uiCount; uiId++) { <br>                SendDlgItemMessage(hDlg, cmb1, CB_GETLBTEXT, <br>                                   uiId, (LPARAM)(LPSTR)szFaceName); <br>                if (szFaceName[0] == '@') { <br>                    SendDlgItemMessage(hDlg, cmb1, CB_DELETESTRING, uiId, 0L); <br>                    uiId--; <br>                    uiCount--; <br>                } <br>            } <br>            /* Set selection current selected facename */ <br>            SendMessage(hDlg, WM_CHOOSEFONT_GETLOGFONT, 0, (LPARAM)(LPSTR)&amp;lf); <br>            uiId = SendDlgItemMessage(hDlg, cmb1, CB_FINDSTRING, <br>                                     0, (LPARAM)(LPSTR)lf.lfFaceName); <br>            SendDlgItemMessage(hDlg, cmb1, CB_SETCURSEL, uiId, 0L); <br>        } <br>        return (TRUE); <br>        break; <br>    } <br>    return (FALSE); <br>} <br> <br> <br> <br>/* start background port status dialog */ <br>HANDLE WINAPI StartBackground ( <br>    HANDLE    hModule, <br>    HWND      hWndParent, <br>    char      *lpszCmdLine) <br>{ <br>    return (CreateDialogParam (hModule, <br>       IDD_BKPORTDIALOG, <br>       hWndParent, <br>       BkPortDlgProc, <br>       (LPARAM)lpszCmdLine)); <br>} <br> <br> <br>/* start interactive version of app */ <br>HWND WINAPI StartInteractive ( <br>    HANDLE    hInstance, <br>    char      *lpszCmdLine, <br>    int       nCmdShow) <br>    { <br>    WNDCLASS   wc; <br>    char       lpszClass[MAX_PATH]; <br>    HWND       hWnd; <br>char   lpszFileName[MAX_PATH]; <br> <br>    /* load resources strings */ <br>    LoadString (hInstance, IDS_APPNAME, lpszClass, sizeof (lpszClass)); <br> <br>    /* Register the frame class */ <br>    wc.style         = 0; <br>    wc.lpfnWndProc   = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = CBWNDEXTRA; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon         = LoadIcon (hInstance, IDPortTool); <br>    wc.hCursor       = LoadCursor (NULL,IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = IDPortTool; <br>    wc.lpszClassName = lpszClass; <br> <br>    if (!RegisterClass (&amp;wc) ) <br>return FALSE; <br> <br>    /* Create the frame */ <br>    hWnd = CreateWindow (lpszClass, <br> "Win32 Port", <br> WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | DS_LOCALEDIT, <br> CW_USEDEFAULT, <br> 0, <br> CW_USEDEFAULT, <br> 0, <br> NULL, <br> NULL, <br> hInstance, <br> (*lpszCmdLine ? lpszCmdLine : 0)); <br> <br>    /* make sure window was created */ <br>    if (!hWnd) <br>return FALSE; <br> <br>    /* register search/replace message for common dialog use */ <br>    uSearchMsg = RegisterWindowMessage ((char *)FINDMSGSTRING); <br> <br>    /* show and update main window */ <br>    ShowWindow (hWnd, nCmdShow); <br>    UpdateWindow (hWnd); <br> <br>/* Ask for Port Information File */ <br>if (lpszPortIniFilePath[0] == 0 ) <br>   if ( !GetPortIniFileName (hWnd, lpszFileName, lpszPortIniFilePath) ) <br>  return FALSE; <br> <br>if ( ! InitPortData(lpszPortIniFilePath) ) <br>   ErrorNotify (hWnd, IDS_PORTINITFAILED); <br> <br>    return hWnd; <br>} <br> <br>/* main window procedure */ <br>LONG WINAPI MainWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>LONG    lRet = 1; <br>int     nResult; <br>RECT    rc; <br> <br>    switch (uMsg) <br>{ <br>case WM_CREATE: <br>    { <br>    HWND              hWndEdit; <br>    LPCREATESTRUCT    lpcs = (LPCREATESTRUCT)lParam; <br>    char              lpszBuff[MAX_PATH]; <br>    LOGFONT           lfEditFont; <br>    HFONT             hFont; <br>    HCURSOR           hOldCursor; <br> <br>    /* put hourglass cursor up */ <br>    hOldCursor = (HCURSOR)SetClassLong (hWnd, GCL_HCURSOR, 0); <br>    SetCursor (LoadCursor (NULL, IDC_WAIT)); <br> <br>    /* Create an edit control */ <br>    GetClientRect (hWnd, &amp;rc); <br>    hWndEdit = CreateWindow ("edit", <br>     " ", <br>     WS_CHILD | WS_VISIBLE | <br> WS_HSCROLL | WS_VSCROLL | <br> ES_AUTOHSCROLL | ES_AUTOVSCROLL | <br> ES_MULTILINE, <br>     rc.left, <br>     rc.top, <br>     rc.right-rc.left, <br>     rc.bottom-rc.top, <br>     hWnd, <br>     (HMENU)IDC_EDIT, <br>     (HANDLE)GetModuleHandle (NULL), <br>     0); <br> <br>    /* if edit control failed, abort aplication */ <br>    if (!IsWindow (hWndEdit)) <br>{ <br>ErrorNotify (hWnd, IDS_EDITWNDFAILED); <br>return FALSE; <br>} <br> <br>    /* increase edit control max character limit beyond 30,000 default */ <br>    SendMessage (hWndEdit, EM_LIMITTEXT, 0x0FFFFFFF, 0); <br> <br>    /* save edit window handle and init state variables */ <br>    SetWindowLong (hWnd, WL_HWNDEDIT, (LONG) hWndEdit); <br>    SetWindowWord (hWnd, WW_SCROLL, TRUE); <br>    SetWindowWord (hWnd, WW_UNTITLED, TRUE); <br>    SetWindowWord (hWnd, WW_SEARCHCASE, TRUE); <br>    SetWindowWord (hWnd, WW_SEARCHDN, TRUE); <br>    SetWindowLong (hWnd, WL_HPTRDEVNAMES, 0); <br> <br>    /* get printer configuration */ <br>    if (!GetPrinterConfig (hWnd)) <br>ErrorNotify (hWnd, IDS_PTRCONFIGFAILED); <br> <br>    /* if initialization file passed, load file now */ <br>    if (lpcs-&gt;lpCreateParams) <br>{ <br>/* load filename passed at initialization */ <br>if ((nResult = LoadFile (hWnd, lpcs-&gt;lpCreateParams)) &gt; 0) <br>    { <br>    /* save filename and path in global string */ <br>    strcpy (lpszFilePath, lpcs-&gt;lpCreateParams); <br> <br>    /* The file has a title, so reset the UNTITLED flag. */ <br>    SetWindowWord(hWnd, WW_UNTITLED, FALSE); <br> <br>    /* extract filename from path */ <br>    GetFileFromPath (lpszFilePath, lpszBuff); <br> <br>    /* set window text title to be "AppName - filename" */ <br>    SetWindowTitle (hWnd, lpszBuff); <br>    } <br>else <br>    { <br>    /* notify user of error */ <br>ErrorNotify (hWnd, 0-nResult); <br> <br>    /* set window title to "AppName - Untitled" */ <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_UNTITLED, <br>lpszBuff, <br>sizeof (lpszBuff)); <br>    SetWindowTitle (hWnd, lpszBuff); <br>    } <br>} <br>    else <br>{ <br>/* set window title to "AppName - Untitled" */ <br>LoadString ((HANDLE)GetModuleHandle (NULL), <br>    IDS_UNTITLED, <br>    lpszBuff, <br>    sizeof (lpszBuff)); <br>SetWindowTitle (hWnd, lpszBuff); <br> <br>/* set global file and path variables to null */ <br>*lpszFilePath = 0; <br>} <br> <br>        // <br>        // Use system font if Japanese system, <br>        //  may want to add other DBCS languages later <br>        // <br>        if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) { <br>          GetObject(GetStockObject(SYSTEM_FIXED_FONT), <br>                        sizeof(LOGFONT), &amp;lfEditFont); <br> <br>        } else { <br>          /* create fixed pitch font as default font */ <br>          lfEditFont.lfHeight = 16; <br>          lfEditFont.lfWidth = 0; <br>          lfEditFont.lfEscapement = 0; <br>          lfEditFont.lfOrientation = 0; <br>          lfEditFont.lfWeight = 400; <br>          lfEditFont.lfItalic = FALSE; <br>          lfEditFont.lfUnderline = FALSE; <br>          lfEditFont.lfStrikeOut = FALSE; <br>          lfEditFont.lfCharSet = ANSI_CHARSET; <br>          lfEditFont.lfOutPrecision = OUT_DEFAULT_PRECIS; <br>          lfEditFont.lfClipPrecision = CLIP_DEFAULT_PRECIS; <br>          lfEditFont.lfQuality = DEFAULT_QUALITY; <br>          lfEditFont.lfPitchAndFamily = FIXED_PITCH | FF_MODERN; <br>          *lfEditFont.lfFaceName = 0; <br>        } <br> <br>    /* make scroll bars initially visible */ <br>    SetScrollRange (hWndEdit, SB_VERT, 0, 100, TRUE); <br>    SetScrollRange (hWndEdit, SB_HORZ, 0, 100, TRUE); <br> <br>    /* create the logical font */ <br>    if (hFont = CreateFontIndirect (&amp;lfEditFont)) <br>SendMessage (hWndEdit, WM_SETFONT, (UINT)hFont, 0); <br>    else <br>ErrorNotify (hWnd, IDS_FONTFAILEDTOCREATE); <br> <br>    /* remove hourglass cursor */ <br>    SetClassLong (hWnd, GCL_HCURSOR, (LONG)hOldCursor); <br>    SetCursor (hOldCursor); <br> <br>    // Is there anything specific we need to do on different platforms? <br>#if defined (WIN32) <br>    if (dwVersion &lt; 0x80000000) { <br>// Windows NT <br>    } else if (LOBYTE(LOWORD(dwVersion))&lt;4) { <br>// Win32s <br>// Threads aren't available, so disable background porting: <br>EnableMenuItem (GetMenu(hWnd), IDM_PORTBKGND, MF_GRAYED); <br>    } else { <br>// Windows 95 <br>    } <br>#else <br>// Win16 <br>#endif <br> <br>    /* set focus to edit window */ <br>    SetFocus (hWndEdit); <br>    } <br>    break; <br> <br>case WM_SIZE: <br>    { <br>    HWND    hWndEdit; <br> <br>    /* resize the edit control to match the client area */ <br>    hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br>        InvalidateRect(hWndEdit, (LPRECT)NULL, TRUE); <br>    MoveWindow (hWndEdit, <br>0, <br>0, <br>LOWORD(lParam), <br>HIWORD(lParam), <br>TRUE); <br>    } <br>    break; <br> <br>case WM_SETFOCUS: <br>    SetFocus ((HWND)GetWindowLong (hWnd, WL_HWNDEDIT)); <br>    break; <br> <br>case WM_INITMENU: <br>    /* initialize menuitems */ <br>    InitializeMenu (hWnd, (HMENU)uParam); <br>    break; <br> <br>case WM_WININICHANGE: <br>case WM_DEVMODECHANGE: <br>    /* get printer configuration */ <br>    GetPrinterConfig (hWnd); <br>    break; <br> <br>case WM_COMMAND: <br>    /* handle all command messages in a localized function */ <br>    lRet = CommandHandler (hWnd, uParam, lParam); <br>    break; <br> <br>case WM_CLOSE: <br>case WM_QUERYENDSESSION: <br>    { <br>    HWND    hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br> <br>    /* check if there are changes to the edit contents, and offer to save first */ <br>    if (SendMessage (hWndEdit, EM_GETMODIFY, 0, 0)) <br>{ <br>switch (Save_YNC (hWnd)) <br>    { <br>    case IDCANCEL: <br>/* abort exit */ <br>return FALSE; <br>    case IDYES: <br>/* save data then continue */ <br>if (!SendMessage (hWnd, WM_COMMAND, (UINT)UM_SAVEFILE, 0)) <br>    return FALSE; <br>    case IDNO: <br>/* just fall through */ <br>break; <br>    } <br>} <br> <br>    /* call destroy window to cleanup and go away */ <br>    DestroyWindow (hWnd); <br>    } <br>    break; <br> <br>case WM_DESTROY: <br>    { <br>    HFONT    hFont = (HFONT)SendMessage ((HWND)GetWindowLong (hWnd, WL_HWNDEDIT), <br> WM_GETFONT, <br> 0, <br> 0); <br> <br>    /* destroy font handle from edit control if exists */ <br>    if (hFont) <br>DeleteObject (hFont); <br> <br>    PostQuitMessage (0); <br>    } <br>    break; <br> <br>default: <br>    /* process common dialog search message here, then break */ <br>    if (uMsg == uSearchMsg) <br>{ <br>LPFINDREPLACE    lpfr = (LPFINDREPLACE)lParam; <br> <br>if (lpfr-&gt;Flags &amp; FR_DIALOGTERM) <br>    { <br>    /* save case and direction */ <br>    SetWindowWord (hWnd, WW_SEARCHCASE, (WORD)(lpfr-&gt;Flags &amp; FR_MATCHCASE)); <br>    SetWindowWord (hWnd, WW_SEARCHDN, (WORD)(lpfr-&gt;Flags &amp; FR_DOWN)); <br>    hDlgSearch = NULL; <br>    } <br> <br>else if (lpfr-&gt;Flags &amp; FR_FINDNEXT) <br>    if (!LocateText (hWnd, <br>     (WORD)(lpfr-&gt;Flags &amp; FR_MATCHCASE), <br>     (WORD)(lpfr-&gt;Flags &amp; FR_DOWN), <br>     lpszSearch)) <br>ErrorNotify (hWnd, IDS_STRINGNOTFOUND); <br>break; <br>} <br> <br>    /* pass all unhandled messages to DefWindowProc */ <br>    lRet = DefWindowProc (hWnd, uMsg, uParam, lParam); <br>    break; <br>} <br> <br>    /* return 1 if handled message, 0 if not */ <br>    return lRet; <br>} <br> <br> <br>/* about box dialog procedure */ <br>BOOL WINAPI AboutDlgProc ( <br>    HWND    hwnd, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>    BOOL    bRet = TRUE; <br>    static  HFONT hfontDlg; <br>    char szVersion[80]; <br> <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG:  // message: initialize dialog box <br> <br>    // Create a font to use <br>    hfontDlg = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, ""); <br> <br>    SendMessage (GetDlgItem (hwnd, IDC_SYSTEM), WM_SETFONT, (UINT)hfontDlg, TRUE); <br>    SendMessage (GetDlgItem (hwnd, IDC_APP), WM_SETFONT, (UINT)hfontDlg, TRUE); <br>    SendMessage (GetDlgItem (hwnd, IDC_VERSION), WM_SETFONT, (UINT)hfontDlg, TRUE); <br>    SendMessage (GetDlgItem (hwnd, IDC_COPYRIGHT), WM_SETFONT, (UINT)hfontDlg, TRUE); <br>    //SendMessage (GetDlgItem (hwnd, IDC_OSVERSION), WM_SETFONT, (UINT)hfontDlg, TRUE); <br> <br> <br>    //dwVersion = GetVersion(); <br>#if defined (WIN32) <br>    if (dwVersion &lt; 0x80000000) { <br>// Windows NT <br>wsprintf (szVersion, "Microsoft WindowsNT %u.%u (Build: %u)", <br>    (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>    (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>    (DWORD)(HIWORD(dwVersion))); <br>    } else if (LOBYTE(LOWORD(dwVersion))&lt;4) { <br>// Win32s <br>wsprintf (szVersion, "Microsoft Win32s %u.%u (Build: %u)", <br>    (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>    (DWORD)(HIBYTE(LOWORD(dwVersion))), <br>    (DWORD)(HIWORD(dwVersion) &amp; ~0x8000)); <br>    } else { <br>// Windows 95 <br>wsprintf (szVersion, "Microsoft Windows 95 %u.%u", <br>    (DWORD)(LOBYTE(LOWORD(dwVersion))), <br>    (DWORD)(HIBYTE(LOWORD(dwVersion)))); <br>    } <br> <br>#else <br>    wsprintf (szVersion, " Windows %u.%u - DOS %u.%u", <br>(DWORD)(LOBYTE(LOWORD(dwVersion))), <br>(DWORD)(HIBYTE(LOWORD(dwVersion))), <br>(DWORD)(HIBYTE(HIWORD(dwVersion))), <br>(DWORD)(LOBYTE(HIWORD(dwVersion)))); <br> <br>   <br>#endif <br>    SetWindowText (GetDlgItem(hwnd, IDC_OSVERSION), szVersion); <br> <br> <br>    return (TRUE); <br> <br>case WM_COMMAND: <br>    switch (LOWORD (uParam)) <br>{ <br>/* end dialog with TRUE or FALSE for OK or CANCEL */ <br>case IDOK: <br>case IDCANCEL: <br>    EndDialog(hwnd, (LOWORD (uParam) == IDOK)); <br>    break; <br> <br>default: <br>    bRet = FALSE; <br>} <br>    break; <br> <br>default: <br>    bRet =  FALSE; <br>    break; <br>} <br>    return bRet; <br>} <br> <br> <br> <br>/* initialize menu function */ <br>VOID WINAPI InitializeMenu ( <br>    HWND    hWnd, <br>    HANDLE  hMenu) <br>{ <br>    WORD    mfStatus; <br>    DWORD   dwSel; <br>    HWND    hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br>    WORD    wScroll; <br> <br>    /* see if edit control can undo last command */ <br>    if (SendMessage (hWndEdit, EM_CANUNDO, 0, 0L)) <br>mfStatus = MF_ENABLED; <br>    else <br>mfStatus = MF_GRAYED; <br>    EnableMenuItem (hMenu, IDM_EDITUNDO, mfStatus); <br> <br>    /* enable menuitems CUT, COPY and CLEAR if selected text */ <br>    dwSel = SendMessage (hWndEdit, EM_GETSEL, 0, 0); <br>    mfStatus = (WORD)((LOWORD(dwSel) == HIWORD(dwSel))?MF_GRAYED:MF_ENABLED); <br>    EnableMenuItem (hMenu, IDM_EDITCUT, mfStatus); <br>    EnableMenuItem (hMenu, IDM_EDITCOPY, mfStatus); <br>    EnableMenuItem (hMenu, IDM_EDITCLEAR, mfStatus); <br> <br>    /* if text allow for new file, enable menuitem */ <br>    if (SendMessage (hWndEdit, WM_GETTEXTLENGTH, 0, 0)) <br>EnableMenuItem (hMenu, IDM_FILENEW, MF_ENABLED); <br>    else <br>EnableMenuItem (hMenu, IDM_FILENEW, MF_GRAYED); <br> <br>    /* if CF_TEXT format data is available in clipboard */ <br>    if (OpenClipboard (hWnd) &amp; IsClipboardFormatAvailable (CF_TEXT)) <br>EnableMenuItem (hMenu, IDM_EDITPASTE, MF_ENABLED); <br>    else <br>EnableMenuItem (hMenu, IDM_EDITPASTE, MF_GRAYED); <br>    CloseClipboard (); <br> <br>    /* set the scroll bars menuitem */ <br>    wScroll = GetWindowWord (hWnd, WW_SCROLL); <br>    CheckMenuItem (hMenu, IDM_EDITSCROLL, (UINT)(wScroll ? MF_CHECKED : MF_UNCHECKED)); <br> <br>    /* set the word wrap state for the window */ <br>    dwSel = GetWindowLong (hWndEdit, GWL_STYLE); <br>    CheckMenuItem (hMenu, <br>   IDM_EDITWRAP, <br>   (UINT)((dwSel &amp; ES_AUTOHSCROLL) ? MF_UNCHECKED : MF_CHECKED)); <br> <br>    /* enable search menuitems if a search string exists */ <br>    if (*lpszSearch) <br>{ <br>EnableMenuItem (hMenu, IDM_SEARCHNEXT, MF_ENABLED); <br>EnableMenuItem (hMenu, IDM_SEARCHPREV, MF_ENABLED); <br>} <br>    else <br>{ <br>EnableMenuItem (hMenu, IDM_SEARCHNEXT, MF_GRAYED); <br>EnableMenuItem (hMenu, IDM_SEARCHPREV, MF_GRAYED); <br>} <br> <br>    /* enable Print menuitems if a printer is available */ <br>    if (GetWindowLong (hWnd, WL_HPTRDEVNAMES)) <br>{ <br>EnableMenuItem (hMenu, IDM_FILEPRINT, MF_ENABLED); <br>EnableMenuItem ( hMenu, IDM_FILESETUP, MF_ENABLED); <br>} <br>    else <br>{ <br>EnableMenuItem (hMenu, IDM_FILEPRINT, MF_GRAYED); <br>EnableMenuItem ( hMenu, IDM_FILESETUP, MF_GRAYED); <br>} <br> <br>    /* menuitems that are always enabled */ <br>    EnableMenuItem(hMenu, IDM_EDITSCROLL, MF_ENABLED); <br>    EnableMenuItem(hMenu, IDM_EDITSELECT, MF_ENABLED); <br>    EnableMenuItem(hMenu, IDM_EDITWRAP, MF_ENABLED); <br>    EnableMenuItem(hMenu, IDM_SEARCHFIND, MF_ENABLED); <br>} <br> <br> <br> <br>/* handle all WM_COMMAND messages here */ <br>LONG WINAPI CommandHandler ( <br>    HWND    hWnd, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>    int     nResult; <br>    HWND    hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br> <br>    switch (LOWORD(uParam)) <br>{ <br>case IDM_FILENEW: <br>    { <br>    char    lpszMsg[MAX_PATH]; <br> <br>    /* check if there are changes, and offer to save first */ <br>    if (SendMessage (hWndEdit, EM_GETMODIFY, 0, 0)) <br>{ <br>switch (Save_YNC (hWnd)) <br>    { <br>    case IDCANCEL: <br>/* abort operation */ <br>return FALSE; <br>    case IDYES: <br>/* save data then continue if successful */ <br>if (!SendMessage (hWnd, WM_COMMAND, (UINT)UM_SAVEFILE, 0)) <br>    return FALSE; <br>    case IDNO: <br>/* just fall through */ <br>break; <br>    } <br> <br>/* reset edit changes flag */ <br>SendMessage (hWndEdit, EM_SETMODIFY, FALSE, 0); <br>} <br> <br>    /* clear edit control */ <br>    SetWindowText (hWndEdit, ""); <br> <br>    /* set window title to "Untitled" */ <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_UNTITLED, <br>lpszMsg, <br>sizeof (lpszMsg)); <br>    SetWindowTitle (hWnd, lpszMsg); <br>    SetWindowWord (hWnd, WW_UNTITLED, TRUE); <br> <br>    /* reset caret position by sending WM_KILLFOCUS/WM_SETFOCUS messages */ <br>    SetFocus (NULL); <br>    SetFocus (hWndEdit); <br>    } <br>    break; <br> <br>case IDM_FILEOPEN: <br>    { <br>    char    lpszFileName[MAX_PATH]; <br>    int     nResult; <br> <br>    /* if changes to current file, ask to save first */ <br>    if (SendMessage (hWndEdit, EM_GETMODIFY, 0, 0)) <br>{ <br>switch (Save_YNC (hWnd)) <br>    { <br>    case IDCANCEL: <br>/* abort operation */ <br>return FALSE; <br>    case IDYES: <br>/* save data then continue */ <br>if (!SendMessage (hWnd, WM_COMMAND, (UINT)UM_SAVEFILE, 0)) <br>    return FALSE; <br>    case IDNO: <br>/* just fall through */ <br>break; <br>    } <br> <br>/* reset edit changes flag */ <br>SendMessage (hWndEdit, EM_SETMODIFY, FALSE, 0); <br>} <br> <br>    /* get new filename and load into edit control */ <br>    if (GetFileName (hWnd, lpszFileName, lpszFilePath)) <br>{ <br>if ((nResult = LoadFile (hWnd, lpszFilePath)) &lt; 0) <br>    /* notify user of error */ <br>ErrorNotify (hWnd, 0-nResult); <br>else <br>    { <br>    /* update window text */ <br>    SetWindowTitle (hWnd, lpszFileName); <br>    SetWindowWord (hWnd, WW_UNTITLED, FALSE); <br>    } <br>} <br>    else <br>return FALSE; <br>    } <br>    break; <br> <br>case IDM_FILESAVEAS: <br>    { <br>    char    lpszFileTitle[MAX_PATH]; <br>    int     nResult; <br> <br>    /* get a valid filename and path */ <br>    if (SaveAsFileName (hWnd, lpszFileTitle, lpszFilePath)) <br>{ <br>/* if file saves okay */ <br>if ((nResult = SaveFile (hWnd, lpszFilePath)) &gt; 0) <br>    { <br>    /* reset changed flag, and window title */ <br>    SendMessage (hWndEdit, EM_SETMODIFY, FALSE, 0); <br>    SetWindowTitle (hWnd, lpszFileTitle); <br>    SetWindowWord (hWnd, WW_UNTITLED, FALSE); <br>    } <br>else <br>    { <br>    /* unable to save file, return error */ <br>    ErrorNotify (hWnd, nResult); <br>    return FALSE; <br>    } <br>} <br>    else <br>return FALSE; <br>    } <br>    break; <br> <br>case IDM_FILESAVE: <br>    { <br>    char    lpszFileTitle[MAX_PATH]; <br>    int     nResult; <br> <br>        /* if called from menu, check to see if file modified */ <br>        if (!lParam &amp;&amp; !SendMessage (hWndEdit, EM_GETMODIFY, 0, 0)) <br>          return FALSE; <br> <br>/* user defined msg is sent from Exit, Open and New menuitems */ <br>case UM_SAVEFILE: <br> <br>    /* if untitled, get new name */ <br>    if (GetWindowWord (hWnd, WW_UNTITLED) &amp;&amp; <br>!(SaveAsFileName(hWnd, lpszFileTitle, lpszFilePath))) <br>{ <br>/* make sure no name was saved */ <br>*lpszFilePath = 0; <br>return FALSE; <br>} <br> <br>        /* save buffer and reset flag */ <br>        if ((nResult = SaveFile (hWnd, lpszFilePath)) &gt; 0) <br>        { <br>        // get lpszFileTitle <br>        char szDrive[_MAX_DRIVE], szDir[_MAX_DIR], szExt[_MAX_EXT]; <br>        _splitpath(lpszFilePath,szDrive,szDir,lpszFileTitle,szExt); <br>        lstrcat(lpszFileTitle,szExt); <br> <br>        /* if new file name, set window title */ <br>        if (*lpszFileTitle) <br>            { <br>            SetWindowTitle (hWnd, lpszFileTitle); <br>            SetWindowWord (hWnd, WW_UNTITLED, FALSE); <br>            } <br>        SendMessage (hWndEdit, EM_SETMODIFY, FALSE, 0); <br>        } <br>        else <br>        { <br>        /* unable to save file, return error */ <br>        ErrorNotify (hWnd, nResult); <br>        return FALSE; <br>        } <br>        } <br>        break; <br> <br>case IDM_FILEPRINT: <br>    { <br>    int    nRes; <br> <br>    /* print the file */ <br>    if ((nRes = PrintFile (hWnd)) &lt; 0) <br>ErrorNotify (hWnd, nRes); <br>    } <br>    break; <br> <br>case IDM_FILESETUP: <br>    { <br>    int    nRes; <br> <br>    /* set up the printer environment */ <br>    if ((nRes = PrinterSetup (hWnd)) &lt; 0) <br>ErrorNotify (hWnd, nRes); <br>    } <br>    break; <br> <br>case IDM_FILEEXIT: <br>    /* exit application */ <br>    PostMessage (hWnd, WM_CLOSE, 0, 0L); <br>    break; <br> <br>case IDM_FILEABOUT: <br>    /* call about dialog box */ <br>    DialogBox ((HANDLE)GetModuleHandle (NULL), <br>       (LPSTR)IDD_ABOUT, <br>       hWnd, <br>       AboutDlgProc); <br>    break; <br> <br>case IDM_EDITUNDO: <br>    SendMessage (hWndEdit, EM_UNDO, 0, 0); <br>    break; <br> <br>case IDM_EDITCUT: <br>        SendMessage (hWndEdit, WM_CUT, 0, 0); <br>        break; <br> <br>case IDM_EDITCOPY: <br>        SendMessage (hWndEdit, WM_COPY, 0, 0); <br>        break; <br> <br>case IDM_EDITCLEAR: <br>        SendMessage (hWndEdit, WM_CLEAR, 0, 0); <br>        break; <br> <br>case IDM_EDITPASTE: <br>        SendMessage (hWndEdit, WM_PASTE, 0, 0L); <br>        break; <br> <br>case IDM_EDITSELECT: <br>    /* 0, -1 selects the entire string */ <br>    SendMessage (hWndEdit, EM_SETSEL, 0, (LONG)(int)-1); <br>    break; <br> <br>case IDM_EDITSCROLL: <br>    { <br>    WORD    wScroll = !GetWindowWord (hWnd, WW_SCROLL); <br> <br>    /* toggle vertical scroll bar */ <br>    SetScrollRange (hWndEdit, SB_VERT, 0, (int)(wScroll ? 100 : 0), TRUE); <br> <br>    /* if not word wrap, toggle horizontal scroll */ <br>    if (ES_AUTOHSCROLL &amp; GetWindowLong (hWndEdit, GWL_STYLE)) <br>SetScrollRange (hWndEdit, SB_HORZ, 0, (int)(wScroll ? 100 : 0), TRUE); <br> <br>    /* set scroll flag */ <br>    SetWindowWord (hWnd, WW_SCROLL, wScroll); <br>    } <br>    break; <br> <br>case IDM_EDITWRAP: <br>    /* change edit control */ <br>    if ((nResult = SetWrap (hWnd)) &lt; 0) <br>/* notify user of error */ <br>ErrorNotify (hWnd, nResult); <br>    break; <br> <br>case IDM_EDITFONT: <br>    { <br>    CHOOSEFONT    cf; <br>    LOGFONT       lfEditFont; <br>    HFONT         hEditFont; <br> <br>    /* get logical font structure from current font */ <br>    if (hEditFont = (HFONT)SendMessage (hWndEdit, WM_GETFONT, 0, 0)) <br>{ <br>GetObject (hEditFont, sizeof (lfEditFont), &amp;lfEditFont); <br>cf.Flags = CF_INITTOLOGFONTSTRUCT | CF_SCREENFONTS; <br>} <br>    else <br>cf.Flags = CF_SCREENFONTS; <br> <br>        /* call common dialog to select a font */ <br>        cf.lStructSize    = sizeof (CHOOSEFONT); <br>        cf.hwndOwner      = hWnd; <br>        cf.hDC            = NULL; <br>        cf.lpLogFont      = &amp;lfEditFont; <br>        cf.iPointSize     = 0; <br>        cf.rgbColors      = 0; <br>        cf.lCustData      = 0; <br> <br>        // <br>        // On Japanese system set font filter proc, <br>        //  may want to add other DBCS languages later <br>        // <br>        if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) { <br>          cf.lpfnHook = (LPCFHOOKPROC)MakeProcInstance(ChooseFontHookProc, NULL); <br>          cf.Flags |= CF_ENABLEHOOK; <br>        } else { <br>          cf.lpfnHook       = NULL; <br>        } <br> <br>        cf.lpTemplateName = NULL; <br>        cf.hInstance      = NULL; <br>        cf.lpszStyle      = NULL; <br>        cf.nFontType      = SCREEN_FONTTYPE; <br>        cf.nSizeMin       = 0; <br>        cf.nSizeMax       = 0; <br> <br>    if (ChooseFont (&amp;cf)) <br>{ <br>/* create new font and put in edit control */ <br>SendMessage (hWndEdit, <br>     WM_SETFONT, <br>     (UINT)CreateFontIndirect <br>     (&amp;lfEditFont), <br>     TRUE); <br> <br>if (hEditFont) <br>    DeleteObject (hEditFont); <br>} <br>    } <br>    break; <br> <br>case IDM_SEARCHFIND: <br>    { <br>    UINT    uBegSel, uEndSel; <br>    WORD    wCase = GetWindowWord (hWnd, WW_SEARCHCASE); <br>    WORD    wDir = GetWindowWord (hWnd, WW_SEARCHDN); <br> <br>    /* if selected text, replace global search string */ <br>    SendMessage (hWndEdit, EM_GETSEL, (UINT)&amp;uBegSel, (UINT)&amp;uEndSel); <br>    if (uBegSel != uEndSel) <br>GetEditSubString (hWndEdit, &amp;uBegSel, &amp;uEndSel, lpszSearch); <br> <br>    /* Put up the find dialog box */ <br>    if (!FindDialog (hWnd, wCase, wDir, lpszSearch)) <br>ErrorNotify (hWnd, IDS_SEARCHDLGFAILED); <br>    } <br>    break; <br> <br>case IDM_SEARCHNEXT: <br>    /* locate next search string in edit control */ <br>    if (!LocateText (hWnd, <br>     GetWindowWord (hWnd, WW_SEARCHCASE), <br>     TRUE, <br>     lpszSearch)) <br>ErrorNotify (hWnd, IDS_STRINGNOTFOUND); <br>    break; <br> <br>case IDM_SEARCHPREV: <br>    /* locate previous search string in edit control */ <br>    if (!LocateText (hWnd, <br>     GetWindowWord (hWnd, WW_SEARCHCASE), <br>     FALSE, </code></pre>
<p>
</p>
<pre><code>lpszSearch)) <br>ErrorNotify (hWnd, IDS_STRINGNOTFOUND); <br>    break; <br> <br>case IDM_PORTCURFILE: <br>    /* if untitled, save first */ <br>    if (GetWindowWord (hWnd, WW_UNTITLED) &amp;&amp; <br>!SendMessage (hWnd, WM_COMMAND, IDM_FILEOPEN, 0)) <br>{ <br>ErrorNotify (hWnd, IDS_NOFILETOPORT); <br>break; <br>} <br> <br>    /* start port dialog with flags */ <br>    hDlgPort = CreateDialog (GetModuleHandle (NULL), <br>     IDD_PORTDIALOG, <br>     hWnd, <br>     PortDlgProc); <br>    break; <br> <br>case IDM_PORTBKGND: <br>    if (IsWindow (hDlgPortStatus)) <br>ShowWindow (hDlgPortStatus, SW_SHOWNORMAL); <br>    else if (!(hDlgPortStatus = StartBackground (GetModuleHandle (NULL), <br> hWnd, <br> NULL))) <br>ErrorNotify (hWnd, IDS_BKPORTSTARTFAILED); <br>    break; <br> <br>    default: <br>        return FALSE; <br>} <br>    return TRUE; <br>} <br> <br> <br> <br>/* change the word wrapping in an edit control */ <br>int WINAPI SetWrap ( <br>    HWND    hWnd) <br> <br>{ <br>    DWORD   dwStyle; <br>HANDLEhNewData; <br>char*lpNewData; <br>    HWND    hWndOld = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br>    HWND    hWndNew; <br>    RECT    rc; <br>    UINT    uLen; <br>    UINT    uBegSel, uEndSel; <br>    WORD    wScroll = GetWindowWord (hWnd, WW_SCROLL); <br>HFONThEditFont = (HFONT)SendMessage (hWndOld, WM_GETFONT, 0, 0); <br> <br>#ifndef WIN32 <br>HANDLEhOldData; <br>char*lpOldData; <br>#endif <br> <br>    char sz[40]; // temporary string for error messages <br> <br> <br>    /* turn off scroll bars if currently present */ <br>    if (wScroll) <br>{ <br>SetScrollRange (hWndOld, SB_VERT, 0, 0, FALSE); <br>SetScrollRange (hWndOld, SB_HORZ, 0, 0, FALSE); <br>} <br> <br>    /* new edit style = old style XOR ES_AUTOHSCROLL */ <br>    dwStyle = ES_AUTOHSCROLL ^ (DWORD)GetWindowLong (hWndOld, GWL_STYLE); <br> <br>    /* save text selection */ <br>    SendMessage (hWndOld, EM_GETSEL, (UINT)&amp;uBegSel, (UINT)&amp;uEndSel); <br> <br>    /* create a new edit control with the new style */ <br>    GetClientRect (hWnd, &amp;rc); <br>    hWndNew = CreateWindow ("edit", <br>    "", <br>    dwStyle, <br>    rc.left, <br>    rc.top, <br>    rc.right-rc.left, <br>    rc.bottom-rc.top, <br>    hWnd, <br>    (HMENU)IDC_EDIT, <br>    (HANDLE)GetModuleHandle (NULL), <br>    0); <br> <br>    /* check for window created */ <br>    if (!IsWindow (hWndNew)) <br>return IDS_EDITWNDFAILED; <br> <br>    /* reset to no format lines */ <br>    if (dwStyle &amp; ES_AUTOHSCROLL) <br>        SendMessage (hWndOld, EM_FMTLINES, FALSE, 0); <br> <br>#if defined (WIN32) <br>    uLen = GetWindowTextLength (hWndOld); <br> <br>    hNewData = LocalAlloc (LHND, uLen+1); <br>    if (hNewData == NULL) { <br>wsprintf (sz, "Unable to allocate %u bytes", uLen+1); <br>MessageBox (GetFocus(), sz, "PORTTOOL::SetWrap", MB_OK); <br>DestroyWindow(hWndNew); <br>return IDS_GETHANDLEFAILED; <br>    } <br> <br>    lpNewData = LocalLock (hNewData); <br>    if (lpNewData == NULL) { <br>MessageBox (GetFocus(), "Unable to lock memory", "PORTTOOL::SetWrap", MB_OK); <br>DestroyWindow(hWndNew); <br>LocalFree (hNewData); <br>return IDS_GETHANDLEFAILED; <br>    } <br> <br>    GetWindowText (hWndOld, lpNewData, uLen+1); <br>    SetWindowText (hWndNew, lpNewData); <br>    LocalUnlock (hNewData); <br> <br>#else <br>    /* get the data handle of the old control */ <br>    if (!(hOldData = (HANDLE)SendMessage (hWndOld, EM_GETHANDLE, 0, 0))) <br>{ <br>/* delete new edit window and return error */ <br>DestroyWindow (hWndNew); <br>return IDS_GETHANDLEFAILED; <br>} <br> <br>    /* increase edit control max character limit beyond 30,000 default */ <br>    SendMessage (hWndNew, EM_LIMITTEXT, 0x0FFFFFFF, 0); <br> <br>    /* get data handle to new edit control and reallocate to size of old edit text */ <br>    hNewData = (HANDLE)SendMessage (hWndNew, EM_GETHANDLE, 0, 0); <br>    uLen = GetWindowTextLength (hWndOld); <br>    if (LocalReAlloc(hNewData, uLen+1, LHND) == NULL) <br>{ <br>/* abort, clean up and return error */ <br>DestroyWindow (hWndNew); <br>return IDS_REALLOCFAILED; <br>} <br> <br>    lpOldData = LocalLock (hOldData); <br>    lpNewData = LocalLock (hNewData); <br>    lpNewData[uLen+1] = 0; <br> <br>    /* copy from one buffer to the other */ <br>    while (uLen-- &gt; 0) <br>lpNewData[uLen] = lpOldData[uLen]; <br> <br>    /* unlock and release data buffers */ <br>    LocalUnlock (hOldData); <br>    LocalUnlock (hNewData); <br> <br>#endif <br> <br>    /* swap windows */ <br>    SetWindowLong (hWnd, WL_HWNDEDIT, (LONG)hWndNew); <br>    DestroyWindow (hWndOld); <br> <br>#if !defined(WIN32) <br>    SendMessage (hWndNew, EM_SETHANDLE, (UINT)hNewData, 0); <br>#endif <br> <br>    /* set line formatting */ <br>    if (dwStyle &amp; ES_AUTOHSCROLL) <br>        SendMessage (hWndNew, EM_FMTLINES, FALSE, 0); <br> <br>    /* replace font in new edit control */ <br>    if (hEditFont) <br>SendMessage (hWndNew, WM_SETFONT, (UINT)hEditFont, 0); <br> <br>    /* set scroll bars if appropriate */ <br>    if (wScroll) <br>{ <br>SetScrollRange (hWndNew, SB_VERT, 0, 100, TRUE); <br>SetScrollRange (hWndNew, SB_HORZ, 0, (ES_AUTOHSCROLL &amp; dwStyle ? 100 : 0), TRUE); <br>} <br> <br>    /* Set limit to greater than 30K */ <br>    SendMessage (hWndNew, EM_LIMITTEXT, 0x0FFFFFFF, 0); <br> <br>    /* restore text selection, repaint and set focus */ <br>    InvalidateRect (hWndNew, NULL, TRUE); <br>    UpdateWindow (hWndNew); <br>    SendMessage (hWndNew, EM_SETSEL, uBegSel, uEndSel); <br>    SetFocus (hWndNew); <br> <br>#if defined(WIN32) <br>    LocalFree (hNewData); <br>#endif <br> <br>    /* return success */ <br>    return TRUE; <br>} <br> <br> <br> <br>/* get win32 command line parameters */ <br>BOOL WINAPI GetCmdLine( <br>    char    *lpStr, <br>    char    *lpszCmdLine, <br>BOOL*bBkgnd, <br>char*lpszPortFileName) <br>{ <br>    if (*lpStr) <br>    { <br>    /* skip application name which precedes parameters */ <br>    while (*lpStr != ' ' &amp;&amp; *lpStr != 0) <br>        lpStr = CharNext(lpStr);; <br> <br>/* skip spaces */ <br>while (*lpStr == ' ' &amp;&amp; *lpStr != 0) <br>    lpStr++; <br> <br>/* indeed command line parameter(s) present */ <br>if (*lpStr != 0) <br>    { <br>    /* if background switch, set flag and remove switch from command line */ <br>    if ((*lpStr == '/' || *lpStr == '-') &amp;&amp; <br>(*(lpStr+1) == 'b' || *(lpStr+1) == 'B')) <br>{ <br>*bBkgnd = TRUE; <br>lpStr += 2; <br> <br>if (*lpStr == 0) <br>    *lpszCmdLine = 0; <br>else <br>    strcpy (lpszCmdLine, lpStr); <br>} <br>    /* maybe switch is embedded in parameter(s) somewhere */ <br>    else <br>{ <br>char    *pStr = lpStr; <br>char*pCmdLine  = lpszCmdLine; <br>char*pPortFile = lpszPortFileName; <br>int     i, nCnt; <br> <br>while (*pStr != 0) <br>    { <br>    /* background switch is set, so prepare parameters and set flag */ <br>    if ((*pStr == '/' || *pStr == '-') &amp;&amp; <br>(*(pStr+1) == 'b' || *(pStr+1) == 'B')) <br>{ <br>*bBkgnd = TRUE; <br> <br>/* copy from beg. of lpStr to *pStr to lpszCmdLine */ <br>nCnt = pStr - lpStr; <br>for (i=0; i&lt;nCnt; i++) <br>    lpszCmdLine[i] = lpStr[i]; <br>lpszCmdLine[i] = 0; <br>strcat (lpszCmdLine, (pStr+2)); <br> <br>/* break from loop */ <br>break; <br>} <br>else if ((*pStr == '/' || *pStr == '-') &amp;&amp; <br>(*(pStr+1) == 'i' || *(pStr+1) == 'I')) <br>{ <br>  pStr = lpStr; <br> <br>  while (*pStr != ' ' &amp;&amp; *pStr != 0) <br>  { <br>pStr++; <br>lpStr++; <br>  } <br> <br>  while (*pStr == ' ' &amp;&amp; *pStr != 0) <br>  { <br>pStr++; <br>lpStr++; <br>  } <br> <br>  while (*pStr != ' ' &amp;&amp; *pStr != 0) <br>  { <br>*pPortFile = *pStr; <br>pPortFile++; <br>pStr++; <br>lpStr++; <br>  } <br>  *pPortFile = 0; <br>} <br> <br>    pStr++; <br>    } <br> <br>/* no switch found, can only edit one file, remove extra parameters */ <br>if (*pStr == 0) <br>    { <br>    pStr = lpStr; <br> <br>    while (*pStr != ' ' &amp;&amp; *pStr != 0) <br>pStr++; <br> <br>    if (*pStr == ' ') <br>*pStr = 0; <br> <br>    strcpy (lpszCmdLine, lpStr); <br>    } <br>} <br>    } <br>else <br>    return FALSE; <br>} <br>    else <br>return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/* display a Save, Yes|No|Cancel message box */ <br>int WINAPI Save_YNC ( <br>    HWND    hWnd) <br>{ <br>    char    lpszMsg[MAX_PATH]; <br>    char    lpszAppName[MAX_PATH]; <br> <br>    /* load string to prompt user */ <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_DATACHANGED, <br>lpszMsg, <br>sizeof (lpszMsg)); <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_APPNAME, <br>lpszAppName, <br>sizeof (lpszAppName)); <br> <br>    /* return user response */ <br>    return (MessageBox (hWnd, <br>lpszMsg, <br>lpszAppName, <br>MB_YESNOCANCEL | MB_ICONQUESTION)); <br>} <br> <br> <br> <br>/* error notification routine */ <br>VOID WINAPI ErrorNotify ( <br>    HWND    hWnd, <br>    int     nErrorString) <br>{ <br>    char    lpszAppName[MAX_PATH]; <br>    char    lpszErrStr[MAX_PATH]; <br>    char    szNum[10]; <br> <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_APPNAME, <br>lpszAppName, <br>sizeof (lpszAppName)); <br>    if (!LoadString ((HANDLE)GetModuleHandle (NULL), <br>             nErrorString, <br>             lpszErrStr, <br>             sizeof (lpszErrStr))) <br>    { <br>    LoadString((HANDLE)GetModuleHandle(NULL), <br>          IDS_UNKNOWN_ERROR, <br>          lpszErrStr, <br>          sizeof (lpszErrStr)); <br>    strcat (lpszErrStr, itoa (nErrorString, szNum, 10)); <br>    } <br> <br>    MessageBox (NULL, lpszErrStr, lpszAppName, MB_OK | MB_ICONINFORMATION | MB_TASKMODAL); <br>} <br> <br> <br> <br>VOID WINAPI SetWindowTitle ( <br>    HWND    hWnd, <br>    char    *lpszFile) <br>{ <br>    char    lpszAppName[MAX_PATH]; <br> <br>    if (LOBYTE(LOWORD(dwVersion))&gt;=4) { <br>// On Windows 95, only put up the filename <br>SetWindowText (hWnd, lpszFile); <br>    } else { <br>/* load AppName and Window title string into window text */ <br>LoadString ((HANDLE)GetModuleHandle (NULL), <br>    IDS_PRINTJOB, <br>    lpszAppName, <br>    sizeof (lpszAppName)); <br>strcat (lpszAppName, lpszFile); <br>SetWindowText (hWnd, lpszAppName); <br>    } <br>} <br> <br> <br> <br>/* extract a substring from the edit controls data buffer */ <br>VOID WINAPI GetEditSubString ( <br>    HWND    hWndEdit, <br>    PUINT   puStart, <br>    PUINT   puEnd, <br>    char    *lpszString) <br>{ <br>    HANDLE    hEditData; <br>    char      *lpEditData; <br>    UINT      i; <br> <br>    char sz[40]; // temporary string for error reporting <br> <br>    /* maximum search string length is MAXSEARCHSTRING characters */ <br>    if ((*puEnd - *puStart) &gt; MAXSEARCHSTRING) <br>*puEnd = *puStart + MAXSEARCHSTRING; <br> <br>#if defined(WIN32) <br> <br>    i = GetWindowTextLength(hWndEdit); <br>    hEditData = LocalAlloc (LHND, i+1); <br>    if (hEditData == NULL) { <br>wsprintf (sz, "Unable to allocate %u bytes", i+1); <br>MessageBox (GetFocus(), sz, "PORTTOOL::GetEditSubString", MB_OK); <br>    } <br> <br>    lpEditData = LocalLock (hEditData); <br>    if (lpEditData == NULL) { <br>MessageBox (GetFocus(), "Unable to lock memory", "PORTTOOL::GetEditSubString", MB_OK); <br>    } else { <br>GetWindowText (hWndEdit, lpEditData, i+1); <br>    } <br> <br>#else <br> <br>    /* get edit data handle and lock */ <br>    hEditData = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0); <br>    lpEditData = (char *)LocalLock (hEditData); <br> <br>#endif <br> <br>    if (lpEditData != NULL) { <br>/* copy characters to string and terminate */ <br>for (i=*puStart; i&lt;*puEnd; i++) <br>    lpszString[i-*puStart] = lpEditData[i]; <br>lpszString[i-*puStart] = 0; <br>    } <br> <br>    /* unlock and return edit handle */ <br>    LocalUnlock (hEditData); <br> <br>#if defined(WIN32) <br> <br>    LocalFree (hEditData); <br> <br>#endif <br> <br>} <br> <br> <br>/**************************************************************************** <br>    My_mbschr:  strchr() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbschr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    if (*psz == '\0' &amp;&amp; uiSep != '\0') { <br>        return NULL; <br>    } else { <br>        return psz; <br>    } <br>} <br>/**************************************************************************** <br>    My_mbstok:  strtok() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbstok( <br>    unsigned char *pszSrc, unsigned char *pszSep) <br>{ <br>    static char *pszSave = NULL; <br>    char *pszHead; <br>    char *psz; <br> <br>    if (pszSrc == NULL) { <br>        if (pszSave == NULL) { <br>            return NULL; <br>        } else { <br>            psz = pszSave; <br>        } <br>    } else { <br>        psz = pszSrc; <br>    } <br> <br>    /*********************************************/ <br>    /* Skip delimiters to find a head of a token */ <br>    /*********************************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            break; <br>        } else if (NULL == My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        //No more token <br>        return (pszSave = NULL); <br>    } <br>    pszHead = psz; <br> <br>    /******************************/ <br>    /* Search a Tail of the token */ <br>    /******************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            psz += 2; <br>            continue; <br>        } else if (NULL != My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        pszSave = NULL; <br>    } else { <br>        //Found next delimiter <br>        pszSave = psz + 1; <br>        *psz = '\0'; <br>    } <br>    return pszHead; <br>} <br>/**************************************************************************** <br>    My_mbsncpy: <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbsncpy( <br>    unsigned char *psz1, const unsigned char *psz2, size_t nLength) <br>{ <br>    int nLen = (int)nLength; <br>    unsigned char *pszSv = psz1; <br> <br>    while (0 &lt; nLen) { <br>        if (*psz2 == '\0') { <br>            *psz1++ = '\0'; <br>            nLen--; <br>        } else if (IsDBCSLeadByte(*psz2)) { <br>            if (nLen == 1) { <br>                *psz1 = '\0'; <br>            } else { <br>                *psz1++ = *psz2++; <br>                *psz1++ = *psz2++; <br>            } <br>            nLen -= 2; <br>        } else { <br>            *psz1++ = *psz2++; <br>            nLen--; <br>        } <br>    } <br>    return pszSv; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
