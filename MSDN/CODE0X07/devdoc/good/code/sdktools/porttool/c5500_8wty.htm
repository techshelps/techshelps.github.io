<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PTBKPORT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5506"></a>PTBKPORT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright (C) 1993-96 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "porttool.h" <br>#include "port.h" <br> <br> <br>/* define line types returned from GetNextLine */ <br>#define VALID_LINE 0 <br>#define COMMENT_LINE 1 <br>#define EOF_LINE 2 <br> <br>#define CARRIAGE_RETURN  13 <br>#define LINE_FEED 10 <br> <br>/* define worker functions for this module */ <br>int  WINAPI GetNextLine (char *, int, char *, char *, BOOL *); <br>int  WINAPI NextLineLength (char *, char *, int); <br>BOOL WINAPI BkFilePortThread (LPBKPORTFILESTRUCT); <br>void WINAPI DateTimeStamp (char *); <br> <br> <br> <br>/* function creates a background porting thread */ <br>HANDLE WINAPI StartBkPortThread (LPBKPORTFILESTRUCT    lpBkPort) <br>{ <br>    DWORD    id; <br> <br>    /* create thread with initial structure */ <br>    return (lpBkPort-&gt;hThread = CreateThread ((LPSECURITY_ATTRIBUTES)NULL, <br>      4096, <br>      (LPTHREAD_START_ROUTINE)BkFilePortThread, <br>      (LPVOID)lpBkPort, <br>      0, <br>      &amp;id)); <br>} <br> <br> <br>/* independent thread function that performs background file porting */ <br>BOOL WINAPI BkFilePortThread ( <br>    LPBKPORTFILESTRUCT  lpBkPort) <br>{ <br>    HANDLEhEvents[nBKPORTEVENTS]; <br>    HANDLEhFile; <br>    OFSTRUCTof; <br>    DWORDnFileSize; <br>    DWORD       nBytes; <br>    HANDLEhFileBuffer; <br>    char*lpFile, *lpFilePtr; <br>    WORDwComplete, wIssues = 0; <br>    int nLines = 0; <br>    BOOLbCommentOn; <br>    HANDLEhLine; <br>    HANDLEhToken, hIssue, hSuggest, hHelp; <br>    RESULTrIssue; <br>    char*lpLine; <br>    charszHeader[MAX_PATH], szToken[50], szIssue[50], szdt[50], <br>szSuggest[50], szHelp[50], szHelpFile[50], szEOL[50], szNL[5]; <br> <br> <br>    /* adjust our priority to below normal */ <br>    SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_BELOW_NORMAL); <br> <br>    /* attach our thread input to the parent thread so we can post messages directly */ <br>    AttachThreadInput (GetCurrentThreadId (), <br>       GetWindowThreadProcessId (lpBkPort-&gt;hDlg, NULL), <br>       TRUE); <br> <br>    /* load file comment strings */ <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTNEWLINE, szNL, 5); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTHEADER, szHeader, MAX_PATH); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTTOKEN, szToken, 50); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTISSUE, szIssue, 50); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTSUGGEST, szSuggest, 50); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTHELP, szHelp, 50); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTHELPFILE, szHelpFile, 50); <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTEOL, szEOL, 50); <br> <br>    /* initialize wait events for communication between threads */ <br>    if (!CreateEvents (hEvents, lpBkPort)) <br>return FALSE; <br> <br>    /* open file for porting and read into buffer */ <br>    if ((int)(hFile = (HANDLE)OpenFile (lpBkPort-&gt;szFilePath, &amp;of, OF_READWRITE)) == -1) <br>{ <br>DestroyEvents (hEvents); <br>return FALSE; <br>} <br> <br>    /* global allocate buffer for file */ <br>    if (!(hFileBuffer = GlobalAlloc (GPTR, (nFileSize = GetFileSize (hFile, NULL))+1)) || <br>!(lpFile = (char *)GlobalLock (hFileBuffer))) <br>{ <br>CloseHandle (hFile); <br>DestroyEvents (hEvents); <br>return FALSE; <br>} <br> <br>    /* allocate initial line buffer of reasonable size */ <br>    hLine = GlobalAlloc (GMEM_MOVEABLE, 1024); <br> <br>    /* allocate local memory segments for porttool RESULT strings */ <br>    if (!(rIssue.lpszToken = LocalLock (hToken = LocalAlloc (LHND, MAXTOKENLEN))) || <br>!(rIssue.lpszHelpStr = LocalLock (hHelp = LocalAlloc (LHND, MAXHELPLEN))) || <br>!(rIssue.lpszIssue = LocalLock (hIssue = LocalAlloc (LHND, MAXISSUELEN))) || <br>!(rIssue.lpszSuggest = LocalLock (hSuggest = LocalAlloc (LHND, MAXSUGGESTLEN)))) <br>{ <br>CloseHandle (hFile); <br>GlobalUnlock (lpFile); <br>GlobalFree (hFileBuffer); <br>DestroyEvents (hEvents); <br>GlobalFree (hLine); <br>return FALSE; <br>} <br> <br>    /* read entire file into buffer and zero terminate */ <br>    ReadFile (hFile, lpFile, nFileSize, &amp;nBytes, NULL); <br>    lpFile[nFileSize] = 0; <br>    lpFilePtr = lpFile; <br> <br>    /* if bytes read not equal to size of file, abort */ <br>    if (nBytes != nFileSize) <br>{ <br>CloseHandle (hFile); <br>GlobalUnlock (lpFile); <br>GlobalFree (hFileBuffer); <br>DestroyEvents (hEvents); <br>GlobalFree (hLine); <br>return FALSE; <br>} <br> <br>    /* reset file to size zero before beginning porting */ <br>    SetFilePointer (hFile, 0, NULL, FILE_BEGIN); <br>    SetEndOfFile (hFile); <br>    WriteFile (hFile, szHeader, strlen (szHeader), &amp;nBytes, NULL); <br>    WriteFile (hFile, lpBkPort-&gt;szFile, strlen (lpBkPort-&gt;szFile), &amp;nBytes, NULL); <br>    WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br>    WriteFile (hFile, szNL, strlen (szNL), &amp;nBytes, NULL); <br> <br>    while (TRUE) <br>{ <br>/* wait 1ms for either abort or status events to signal */ <br>switch (WaitForMultipleObjects (nBKPORTEVENTS, hEvents, FALSE, 1)) <br>    { <br>    case BKPORT_ABORT: <br>{ <br>charszAbort[MAX_PATH]; <br> <br>/* create time and date */ <br>DateTimeStamp (szdt); <br> <br>/* write header line */ <br>WriteFile (hFile, szHeader, strlen (szHeader), &amp;nBytes, NULL); <br>WriteFile (hFile, szdt, strlen (szdt), &amp;nBytes, NULL); <br>WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br>WriteFile (hFile, szNL, strlen (szNL), &amp;nBytes, NULL); <br> <br>/* load abort string and write to file */ <br>LoadString (GetModuleHandle (NULL), <br>    IDS_BKPORTABORT, <br>    szAbort, <br>    MAX_PATH); <br>WriteFile (hFile, szAbort, strlen (szAbort), (LPDWORD)&amp;nBytes, NULL); <br> <br>/* write rest of file to disk */ <br>WriteFile (hFile, <br>   (VOID *)lpFilePtr, <br>   (nFileSize - (lpFilePtr-lpFile)), <br>   (LPDWORD)&amp;nBytes, <br>   NULL); <br> <br>/* clean up */ <br>CloseHandle (hFile); <br>GlobalUnlock (lpFile); <br>GlobalFree (hFileBuffer); <br>GlobalFree (hLine); <br>DestroyEvents (hEvents); <br> <br>/* free RESULT strings */ <br>LocalUnlock (hToken); LocalFree (hToken); <br>LocalUnlock (hHelp); LocalFree (hHelp); <br>LocalUnlock (hIssue); LocalFree (hIssue); <br>LocalUnlock (hSuggest); LocalFree (hSuggest); <br> <br>/* exit thread */ <br>return FALSE; <br>} <br>break; <br> <br>    case BKPORT_STATUS: <br>/* post message to parent thread with status info */ <br>PostMessage (lpBkPort-&gt;hDlg, <br>     UM_STATUSUPDATE, <br>     MAKELONG (wIssues, wComplete), <br>     nLines); <br>break; <br> <br>    case WAIT_TIMEOUT: <br>/* if we timed out ignore */ <br>break; <br> <br>    default: <br>/* anything else is an error */ <br>ErrorNotify (lpBkPort-&gt;hDlg, GetLastError ()); <br>goto DONE; <br>break; <br>    } <br> <br>/* reset line buffer */ <br>GlobalReAlloc (hLine, <br>       NextLineLength (lpFilePtr, lpFile, nFileSize), <br>       GMEM_MOVEABLE); <br>lpLine = (char *)GlobalLock (hLine); <br>*lpLine = 0; <br> <br>/* get next line from  file buffer */ <br>switch (GetNextLine (lpFile, nFileSize, lpFilePtr, lpLine, &amp;bCommentOn)) <br>    { <br>    /* check valid strings for porting issues */ <br>    case VALID_LINE: <br>/* initialize rIssue string lengths */ <br>*(WORD *)rIssue.lpszToken = MAXTOKENLEN; <br>*(WORD *)rIssue.lpszHelpStr = MAXHELPLEN; <br>*(WORD *)rIssue.lpszIssue = MAXISSUELEN; <br>*(WORD *)rIssue.lpszSuggest = MAXSUGGESTLEN; <br> <br>if (CheckString (lpLine, lpBkPort-&gt;dwPTFlags, &amp;rIssue)) <br>    { <br>    /* create time and date */ <br>    DateTimeStamp (szdt); <br> <br>    /* write header line */ <br>    WriteFile (hFile, szNL, strlen (szNL), &amp;nBytes, NULL); <br>    WriteFile (hFile, szHeader, strlen (szHeader), &amp;nBytes, NULL); <br>    WriteFile (hFile, szdt, strlen (szdt), &amp;nBytes, NULL); <br>    WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br> <br>    /* write token line */ <br>    WriteFile (hFile, szToken, strlen (szToken), &amp;nBytes, NULL); <br>    WriteFile (hFile, <br>       rIssue.lpszToken, <br>       strlen (rIssue.lpszToken), <br>       &amp;nBytes, <br>       NULL); <br>    WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br> <br>    /* write issue line */ <br>    WriteFile (hFile, szIssue, strlen (szIssue), &amp;nBytes, NULL); <br>    WriteFile (hFile, <br>       rIssue.lpszIssue, <br>       strlen (rIssue.lpszIssue), <br>       &amp;nBytes, <br>       NULL); <br>    WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br> <br>    /* if suggestion */ <br>    if (*(rIssue.lpszSuggest)) <br>{ <br>WriteFile (hFile, szSuggest, strlen (szSuggest), &amp;nBytes, NULL); <br>WriteFile (hFile, <br>   rIssue.lpszSuggest, <br>   strlen (rIssue.lpszSuggest), <br>   &amp;nBytes, <br>   NULL); <br>WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br>} <br> <br>    /* if help string */ <br>    if (*(rIssue.lpszSuggest)) <br>{ <br>WriteFile (hFile, szHelp, strlen (szHelp), &amp;nBytes, NULL); <br>WriteFile (hFile, <br>   rIssue.lpszHelpStr, <br>   strlen (rIssue.lpszHelpStr), <br>   &amp;nBytes, <br>   NULL); <br>WriteFile (hFile, szHelpFile, strlen (szHelpFile), &amp;nBytes, NULL); <br>WriteFile (hFile, szEOL, strlen (szEOL), &amp;nBytes, NULL); <br>} <br> <br>    wIssues++; <br>    } <br> <br>    case COMMENT_LINE: <br>/* write line to file whether comment or not */ <br>WriteFile (hFile, lpLine, strlen (lpLine), &amp;nBytes, NULL); <br>break; <br> <br>    case EOF_LINE: <br>if (*lpLine) <br>    WriteFile (hFile, lpLine, strlen (lpLine), &amp;nBytes, NULL); <br>goto DONE; <br>break; <br>    } <br> <br>/* unlock line buffer */ <br>GlobalUnlock (hLine); <br> <br>/* update status counts */ <br>lpFilePtr += strlen (lpLine); <br>nLines++; <br>wComplete = (WORD)(((lpFilePtr-lpFile)*100)/nFileSize); <br>} <br> <br>DONE: <br>    /* clean up */ <br>    CloseHandle (hFile); <br>    GlobalUnlock (lpFile); <br>    GlobalFree (hFileBuffer); <br>    GlobalFree (hLine); <br>    DestroyEvents (hEvents); <br> <br>    /* free RESULT strings */ <br>    LocalUnlock (hToken); LocalFree (hToken); <br>    LocalUnlock (hHelp); LocalFree (hHelp); <br>    LocalUnlock (hIssue); LocalFree (hIssue); <br>    LocalUnlock (hSuggest); LocalFree (hSuggest); <br> <br>    /* send message to parent that thread is dead */ <br>    PostMessage (lpBkPort-&gt;hDlg, <br> UM_THREADCOMPLETE, <br> (WPARAM)lpBkPort-&gt;hThread, <br> 0); <br> <br>    /* exit thread */ <br>    return TRUE; <br>} <br> <br> <br> <br>void WINAPI DateTimeStamp ( <br>    char    *lpszDT) <br>{ <br>    SYSTEMTIME  dt; <br>    char  Buff[10]; <br> <br>    /* create time and date stamp */ <br>    GetSystemTime (&amp;dt); <br> <br>    // <br>    // On Japanese system change the date display order, <br>    //  we should do this right w/ locales eventually. <br>    // <br>    if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) { <br> <br>      strcpy (lpszDT, itoa (dt.wYear, Buff, 10)); <br>      strcat (lpszDT, "/"); <br>      strcat (lpszDT, itoa (dt.wMonth, Buff, 10)); <br>      strcat (lpszDT, "/"); <br>      strcat (lpszDT, itoa (dt.wDay, Buff, 10)); <br>    } else { <br>      strcpy (lpszDT, itoa (dt.wMonth, Buff, 10)); <br>      strcat (lpszDT, "/"); <br>      strcat (lpszDT, itoa (dt.wDay, Buff, 10)); <br>      strcat (lpszDT, "/"); <br>      strcat (lpszDT, itoa (dt.wYear, Buff, 10)); <br>    } <br> <br>    strcat (lpszDT, "    "); <br>    strcat (lpszDT, itoa (dt.wHour, Buff, 10)); <br>    strcat (lpszDT, ":"); <br>    strcat (lpszDT, itoa (dt.wMinute, Buff, 10)); <br>} <br> <br> <br> <br> <br> <br>BOOL WINAPI CreateEvents ( <br>    HANDLE  *lphEvents, <br>    LPBKPORTFILESTRUCT  lpBkPort) <br>{ <br>    char    szEvent[MAX_PATH]; <br> <br> <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTABORT, szEvent, MAX_PATH); <br>    strcat (szEvent, lpBkPort-&gt;szFile); <br>    if (!(lphEvents[BKPORT_ABORT] = CreateEvent (NULL, TRUE, FALSE, szEvent))) <br>return FALSE; <br> <br>    LoadString (GetModuleHandle (NULL), IDS_BKPORTSTATUS, szEvent, MAX_PATH); <br>    strcat (szEvent, lpBkPort-&gt;szFile); <br>    if (!(lphEvents[BKPORT_STATUS] = CreateEvent (NULL, TRUE, FALSE, szEvent))) <br>{ <br>CloseHandle (lphEvents[BKPORT_ABORT]); <br>return FALSE; <br>} <br> <br>    /* return success */ <br>    return TRUE; <br>} <br> <br> <br> <br> <br>void WINAPI DestroyEvents ( <br>    HANDLE    *lphEvents) <br>{ <br>    /* close event handles */ <br>    CloseHandle (lphEvents[BKPORT_ABORT]); <br>    CloseHandle (lphEvents[BKPORT_STATUS]); <br>} <br> <br> <br> <br> <br>int WINAPI NextLineLength ( <br>    char    *lpFilePtr, <br>    char    *lpFile, <br>    int     nFileSize) <br>{ <br>    int    nCnt=0; <br>    char   *lpf = lpFilePtr; <br> <br>    /* count all characters up to end of file or CR/LF sequence */ <br>    while (lpf &amp;&amp; <br>   lpf-lpFile &lt; nFileSize &amp;&amp; <br>   *lpf       != CARRIAGE_RETURN &amp;&amp; <br>   *(lpf+1)   != LINE_FEED) <br>{ <br>lpf++; <br>nCnt++; <br>} <br> <br>    /* length plus 3 for CR/LF/0 terminator sequence */ <br>    return nCnt + 3; <br>} <br> <br> <br> <br> <br>int WINAPI GetNextLine ( <br>    char    *lpFile, <br>    int     nFileSize, <br>    char    *lpFilePtr, <br>    char    *lpLine, <br>    BOOL    *bCommentOn) <br>{ <br>    char    *lpf = lpFilePtr; <br>    char    *lpl = lpLine; <br> <br>    /* copy all characters up to end of file or CR/LF sequence */ <br>    while (lpf &amp;&amp; <br>   lpf-lpFile &lt; nFileSize &amp;&amp; <br>   *lpf       != CARRIAGE_RETURN &amp;&amp; <br>   *(lpf+1)   != LINE_FEED) <br>*lpl++ = *lpf++; <br> <br>    /* check for end of buffer */ <br>    if (lpf-lpFile &gt;= nFileSize) <br>return EOF_LINE; <br> <br>    /* copy carriage return and line feed to line and terminate */ <br>    *lpl++ = *lpf++; <br>    *lpl++ = *lpf++; <br>    *lpl = 0; <br> <br>    /* increment lpl to first non space character in line */ <br>    lpl = lpLine; <br>    while (*lpl == ' ') <br>lpl++; <br> <br>    /* see if single line comments exist */ <br>    if (*lpl == '/' &amp;&amp; <br>*(lpl+1) == '/') <br>return COMMENT_LINE; <br> <br>    /* see if comments begin */ <br>    if (*lpl == '/'  &amp;&amp; <br>*(lpl+1) == '*') <br>*bCommentOn = TRUE; <br> <br>    /* if comment on, see if it terminates yet */ <br>    if (*bCommentOn) <br>{ <br>lpl = lpLine; <br>while (*lpl) <br>    { <br>    if (*lpl == '*'  &amp;&amp; <br>*(lpl+1) == '/') <br>{ <br>*bCommentOn = FALSE; <br>break; <br>} <br>    lpl = CharNext(lpl); <br>    } <br> <br>/* if more text on line, valid line */ <br>while (*lpl) <br>    if (*lpl != '*' &amp;&amp; <br>*(lpl+1) != '/') <br>return VALID_LINE; <br>    else <br>return COMMENT_LINE; <br>} <br> <br>    /* if haven't returned yet, must be valid line */ <br>    return VALID_LINE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
