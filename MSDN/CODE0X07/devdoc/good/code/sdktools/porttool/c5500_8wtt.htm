<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PORT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5501"></a>PORT.C</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "portpriv.h" <br>#include "port.h" <br> <br>// redefine dbcs versions of common string functions <br>#ifdef strnicmp <br>#undef strnicmp <br>#endif <br>#define strnicmp    My_mbsnicmp <br>#define strncmp     My_mbsncmp <br>#define strncpy     My_mbsncpy <br>#define strtok      My_mbstok <br> <br>/* globals for this module */ <br>HANDLE  hMMFile = 0; <br>HANDLE  hDLL; <br>BOOL  bInit = FALSE; <br> <br>/* function prototypes for private module functions */ <br>void WINAPI FreePortData (); <br>int  WINAPI GetFirstToken (LPPORT *); <br>int  WINAPI GetNextToken (LPPORT *); <br>void WINAPI IgnoreToken (char *, LPPORT); <br>BOOL WINAPI LoadSection (char *, char *, DWORD, int *, char *); <br>BOOL WINAPI GetIniFile (HANDLE, char *, char *); <br> <br>/**************************************************************************** <br>    My_mbschr:  strchr() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbschr( <br>    unsigned char *psz, unsigned short uiSep) <br>{ <br>    while (*psz != '\0' &amp;&amp; *psz != uiSep) { <br>        psz = CharNext(psz); <br>    } <br>    if (*psz == '\0' &amp;&amp; uiSep != '\0') { <br>        return NULL; <br>    } else { <br>        return psz; <br>    } <br>} <br>/**************************************************************************** <br>    My_mbstok:  strtok() DBCS version <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbstok( <br>    unsigned char *pszSrc, unsigned char *pszSep) <br>{ <br>    static char *pszSave = NULL; <br>    char *pszHead; <br>    char *psz; <br> <br>    if (pszSrc == NULL) { <br>        if (pszSave == NULL) { <br>            return NULL; <br>        } else { <br>            psz = pszSave; <br>        } <br>    } else { <br>        psz = pszSrc; <br>    } <br> <br>    /*********************************************/ <br>    /* Skip delimiters to find a head of a token */ <br>    /*********************************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            break; <br>        } else if (NULL == My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        //No more token <br>        return (pszSave = NULL); <br>    } <br>    pszHead = psz; <br> <br>    /******************************/ <br>    /* Search a Tail of the token */ <br>    /******************************/ <br>    while (*psz) { <br>        if (IsDBCSLeadByte(*psz)) { <br>            psz += 2; <br>            continue; <br>        } else if (NULL != My_mbschr(pszSep, *psz)) { <br>            break; <br>        } <br>        psz++; <br>    } <br>    if (*psz == '\0') { <br>        pszSave = NULL; <br>    } else { <br>        //Found next delimiter <br>        pszSave = psz + 1; <br>        *psz = '\0'; <br>    } <br>    return pszHead; <br>} <br>/**************************************************************************** <br>    My_mbsnicmp:strnicmp() DBCS version <br>                If 'nLen' splits a DBC, this function compares <br>                the DBC's 2nd byte also. <br>****************************************************************************/ <br>int _CRTAPI1 My_mbsnicmp( <br>    const unsigned char *psz1, const unsigned char *psz2, size_t Length) <br>{ <br>    int nLen = (int)Length; <br> <br>    while (0 &lt; nLen) { <br>        if ('\0' == *psz1 || '\0' == *psz2) { <br>            return *psz1 - *psz2; <br>        } <br>        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) { <br>            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) { <br>                return *psz1 - *psz2; <br>            } <br>            psz1 += 2; <br>            psz2 += 2; <br>            nLen -= 2; <br>        } else { <br>            if((BYTE)CharUpper((LPSTR)*psz1) != (BYTE)CharUpper((LPSTR)*psz2)){ <br>                return *psz1 - *psz2; <br>            } <br>            psz1++; <br>            psz2++; <br>            nLen--; <br>        } <br>    } <br>    return 0; <br>} <br>/**************************************************************************** <br>    My_mbsncmp: strncmp() DBCS version <br>                If 'nLen' splits a DBC, this function compares <br>                the DBC's 2nd byte also. <br>****************************************************************************/ <br>int _CRTAPI1 My_mbsncmp( <br>    const unsigned char *psz1, const unsigned char *psz2, size_t Length) <br>{ <br>    int nLen = (int)Length; <br> <br>    while (0 &lt; nLen) { <br>        if ('\0' == *psz1 || '\0' == *psz2) { <br>            return *psz1 - *psz2; <br>        } <br>        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) { <br>            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) { <br>                return *psz1 - *psz2; <br>            } <br>            psz1 += 2; <br>            psz2 += 2; <br>            nLen -= 2; <br>        } else { <br>            if (*psz1 != *psz2) { <br>                return *psz1 - *psz2; <br>            } <br>            psz1++; <br>            psz2++; <br>            nLen--; <br>        } <br>    } <br>    return 0; <br>} <br>/**************************************************************************** <br>    My_mbsncpy: <br>****************************************************************************/ <br>unsigned char * _CRTAPI1 My_mbsncpy( <br>    unsigned char *psz1, const unsigned char *psz2, size_t Length) <br>{ <br>    int nLen = (int)Length; <br>    unsigned char *pszSv = psz1; <br> <br>    while (0 &lt; nLen) { <br>        if (*psz2 == '\0') { <br>            *psz1++ = '\0'; <br>            nLen--; <br>        } else if (IsDBCSLeadByte(*psz2)) { <br>            if (nLen == 1) { <br>                *psz1 = '\0'; <br>            } else { <br>                *psz1++ = *psz2++; <br>                *psz1++ = *psz2++; <br>            } <br>            nLen -= 2; <br>        } else { <br>            *psz1++ = *psz2++; <br>            nLen--; <br>        } <br>    } <br>    return pszSv; <br>} <br> <br>/* entry point for DLL loading and unloading */ <br>BOOL WINAPI DllMain ( <br>    HANDLE    hModule, <br>    DWORD     dwFunction, <br>    LPVOID    lpNot) <br>{ <br>#ifdef DEBUG <br>DebugBreak (); <br>#endif <br> <br>    switch (dwFunction) <br>{ <br>case DLL_PROCESS_ATTACH: <br>hDLL = hModule; <br>    break; <br> <br>case DLL_PROCESS_DETACH: <br>    FreePortData (); <br>default: <br>    break; <br>} <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/* function initializes port structures */ <br>BOOL WINAPI InitPortData ( <br>char  *szIniFileName <br>) <br>{ <br>    charszSection[MAX_PATH]; <br>    charszIniFilePath[MAX_PATH]; <br>    charszMapFileName[MAX_PATH]; <br>    OFSTRUCTof; <br>    HANDLEhFile; <br>    DWORDnFileSize; <br>    int nOffset = 0; <br>    char*lpMMFile; <br> <br>/* Initialize Flag off */ <br>bInit = FALSE; <br> <br>    /* load name for global file mapping */ <br>    LoadString (hDLL, IDS_MAPFILENAME, szMapFileName, MAX_PATH); <br> <br>    /* after first process initializes port data */ <br>    if ((hMMFile = OpenFileMapping (FILE_MAP_WRITE, FALSE, szMapFileName))) <br>/* exit now since initialization was already performed by another process */ <br>return TRUE; <br> <br>    /* retrive path and file for ini file */ <br>if (!GetIniFile (hDLL, szIniFileName, szIniFilePath)) <br>return FALSE; <br> <br>    /* test for ini file existance and get length of file */ <br>    if ((int)(hFile = (HANDLE)OpenFile (szIniFilePath, &amp;of, OF_READ)) == -1) <br>return FALSE; <br>    else <br>{ <br>nFileSize = GetFileSize (hFile, NULL); <br>CloseHandle (hFile); <br>} <br> <br>    /* allocate a segment of the swap file for shared memory 2*Size of ini file */ <br>    if (!(hMMFile = CreateFileMapping ((HANDLE)0xffffffff, <br>   NULL, <br>   PAGE_READWRITE, <br>   0, <br>   nFileSize * 2, <br>   szMapFileName))) <br>return FALSE; <br> <br>    /* map a view of this file for writing */ <br>    lpMMFile = (char *)MapViewOfFile (hMMFile, FILE_MAP_WRITE, 0, 0, 0); <br> <br>    /* load tokens for APIS section */ <br>    LoadString (hDLL, IDS_PORTAPIS, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_APIS, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* load tokens for MESSAGES section */ <br>    LoadString (hDLL, IDS_PORTMESSAGES, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_MESSAGES, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* load tokens for STRUCTURES section */ <br>    LoadString (hDLL, IDS_PORTSTRUCTURES, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_STRUCTURES, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* load tokens for TYPES section */ <br>    LoadString (hDLL, IDS_PORTTYPES, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_TYPES, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* load tokens for MACROS section */ <br>    LoadString (hDLL, IDS_PORTMACROS, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_MACROS, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* load tokens for CONSTANTS section */ <br>    LoadString (hDLL, IDS_PORTCONSTANTS, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_CONSTANTS, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* load tokens for CUSTOM section */ <br>    LoadString (hDLL, IDS_PORTCUSTOM, szSection, MAX_PATH); <br>    if (!LoadSection (szIniFilePath, szSection, PT_CUSTOM, &amp;nOffset, lpMMFile)) <br>{ <br>/* clean up memory mapped file */ <br>UnmapViewOfFile (lpMMFile); <br>CloseHandle (hMMFile); <br>return FALSE; <br>} <br> <br>    /* release WRITE view of memory mapped file */ <br>    UnmapViewOfFile (lpMMFile); <br> <br>/* success */ <br>bInit = TRUE; <br>    return TRUE; <br>} <br> <br> <br> <br>/* release memory mapped file view */ <br>void WINAPI FreePortData () <br>{ <br>if ( ! bInit ) <br>return; <br> <br>    /* release memory mapped file */ <br>    CloseHandle (hMMFile); <br>    } <br> <br> <br> <br>/* external function to check a string for porting issues */ <br>BOOL WINAPI CheckString ( <br>    char*lpszSrc, <br>    DWORDdwSearch, <br>    LPRESULTlprIssue) <br>{ <br>    BOOL      bRet = FALSE; <br>    LPPORT    lpToken; <br>    char      *lpStr = lpszSrc; <br>    int       nSrcLen = strlen (lpszSrc); <br>    int       nTokLen; <br>    char      *lpMMFile = (char *)MapViewOfFile (hMMFile, FILE_MAP_WRITE, 0, 0, 0); <br> <br> <br>if ( ! bInit ) <br>   return FALSE; <br> <br>/* if view of file failed */ <br>    if (!lpMMFile) <br>return FALSE; <br> <br>    /* if ignore token */ <br>    if (dwSearch &amp; PT_IGNORETOKEN) <br>/* flag token as ignored */ <br>IgnoreToken (lpszSrc, (LPPORT)lpMMFile); <br> <br>    else <br>/* loop through all characters in string */ <br>while ((lpStr-lpszSrc) &lt; nSrcLen) <br>    { <br>    /* initialize lpToken to beginning of list */ <br>    lpToken = (LPPORT)lpMMFile; <br> <br>        /* loop thru all tokens */ <br>    if (nTokLen = GetFirstToken (&amp;lpToken)) <br>    do <br>        { <br>        /* filter tokens for search criteria */ <br>        if (!(lpToken-&gt;dwType &amp; PT_IGNORED) &amp;&amp; <br>            !(dwSearch &amp; lpToken-&gt;dwType) &amp;&amp; <br>            ((dwSearch &amp; PT_IGNORECASE &amp;&amp; <br>              !strnicmp ((char *)lpToken+lpToken-&gt;nPosToken, lpStr, nTokLen)) || <br>             !strncmp ((char *)lpToken+lpToken-&gt;nPosToken, lpStr, nTokLen))) <br>            { <br>            /* token found in line, return ISSUE struct */ <br>            strncpy (lprIssue-&gt;lpszToken, <br>                 (char *)lpToken+lpToken-&gt;nPosToken, <br>                 *(WORD *)lprIssue-&gt;lpszToken); <br>            strncpy (lprIssue-&gt;lpszHelpStr, <br>                 (char *)lpToken+lpToken-&gt;nPosHelpStr, <br>                 *(WORD *)lprIssue-&gt;lpszHelpStr); <br>            strncpy (lprIssue-&gt;lpszIssue, <br>                 (char *)lpToken+lpToken-&gt;nPosIssue, <br>                 *(WORD *)lprIssue-&gt;lpszIssue); <br>            strncpy (lprIssue-&gt;lpszSuggest, <br>                 (char *)lpToken+lpToken-&gt;nPosSuggest, <br>                 *(WORD *)lprIssue-&gt;lpszSuggest); <br>            lprIssue-&gt;nPosToken = (int)(lpStr - lpszSrc); <br> <br>    bRet = TRUE; <br>    goto DONE; <br>    } <br>} <br>    while ((nTokLen = GetNextToken (&amp;lpToken))); <br> <br>        lpStr = CharNext(lpStr); <br>        } <br> <br>DONE: <br> <br>    /* unmap view of memory mapped file */ <br>    UnmapViewOfFile (lpMMFile); <br> <br>    return bRet; <br>} <br> <br> <br> <br>/* function get's the first token in the list */ <br>int WINAPI GetFirstToken ( <br>    LPPORT    *lpToken) <br>{ <br>    /* increment to next non-ignored token in list */ <br>    while (((((LPPORT)*lpToken)-&gt;dwType) == PT_IGNORED) &amp;&amp; <br>   ((((LPPORT)*lpToken)-&gt;nSize) != 0)) <br>(char *)*lpToken += ((LPPORT)*lpToken)-&gt;nSize; <br> <br>    /* if at end of list, reset list to null */ <br>    if ((((LPPORT)*lpToken)-&gt;nSize) == 0) <br>{ <br>*lpToken = 0; <br>return 0; <br>} <br> <br>    /* return length of token */ <br>    return (strlen ((char *)*lpToken + ((LPPORT)*lpToken)-&gt;nPosToken)); <br>} <br> <br> <br>/* function get's the next token in the list */ <br>int WINAPI GetNextToken ( <br>    LPPORT    *lpToken) <br>{ <br>    /* increment to next non-ignored token in list */ <br>    do <br>(char *)*lpToken += ((LPPORT)*lpToken)-&gt;nSize; <br>    while (((((LPPORT)*lpToken)-&gt;dwType) == PT_IGNORED) &amp;&amp; <br>   ((((LPPORT)*lpToken)-&gt;nSize) != 0)); <br> <br>    /* if at end of list, reset list to null */ <br>    if ((((LPPORT)*lpToken)-&gt;nSize) == 0) <br>{ <br>*lpToken = 0; <br>return 0; <br>} <br> <br>    /* return length of token */ <br>    return (strlen ((char *)*lpToken + ((LPPORT)*lpToken)-&gt;nPosToken)); <br>} <br> <br> <br> <br>/* function sets the ignore flag on the specified token */ <br>void WINAPI IgnoreToken ( <br>    char    *lpszToken, <br>    LPPORT  lpToken) <br>{ <br>    /* search for token in list */ <br>    while (lpToken-&gt;nSize != 0) <br>/* if same token */ <br>if (!strcmp ((char *)((char *)lpToken + lpToken-&gt;nPosToken), lpszToken)) <br>    { <br>    lpToken-&gt;dwType |= PT_IGNORED; <br>    break; <br>    } <br>/* increment to  next token */ <br>else <br>    (char *)lpToken += lpToken-&gt;nSize; <br>} <br> <br> <br> <br> <br>/* load tokens from a section of ini file */ <br>BOOL WINAPI LoadSection ( <br>    char    *lpszIniFile, <br>    char    *lpszSection, <br>    DWORD   dwType, <br>    int     *nOffset, <br>    char    *lpMMFile) <br>{ <br>    char    *lpszKeyNames; <br>    char    *lpKey; <br>    char    *lpszValue; <br>    char    *lpVal; <br>    char    *lpszToken; <br>    char    lpszDefault[] = "Default"; <br>    char    *lpMem = lpMMFile + *nOffset; <br>    int     nList; <br> <br> <br>    /* allocate lots of memory off heap to save calling applications' stack */ <br>    if (!(lpszKeyNames = (char *)LocalAlloc (LPTR, FIFTY_K_LINE))) <br>return FALSE; <br>    if (!(lpszValue = (char *)LocalAlloc (LPTR, TWO_K_LINE))) <br>{ <br>LocalFree ((HLOCAL)lpszKeyNames); <br>return FALSE; <br>} <br>    if (!(lpszToken = (char *)LocalAlloc (LPTR, MAXTOKENLEN))) <br>{ <br>LocalFree ((HLOCAL)lpszKeyNames); <br>LocalFree ((HLOCAL)lpszValue); <br>return FALSE; <br>} <br> <br>    /* get all keynames in section */ <br>    if (((nList = GetPrivateProfileString (lpszSection, <br>   NULL, <br>   lpszDefault, <br>   lpszKeyNames, <br>   FIFTY_K_LINE, <br>   lpszIniFile)) == (int)(strlen (lpszDefault))) &amp;&amp; <br>!strcmp (lpszDefault, lpszKeyNames)) <br>{ <br>LocalFree ((HLOCAL)lpszKeyNames); <br>LocalFree ((HLOCAL)lpszValue); <br>LocalFree ((HLOCAL)lpszToken); <br>return FALSE; <br>} <br> <br>    /* initialize token pointer and first token */ <br>    lpKey = lpszKeyNames; <br> <br>    /* loop through all keynames */ <br>    while (TRUE) <br>{ <br>/* get next token */ <br>strcpy (lpszToken, lpKey); <br> <br>/* get value for token */ <br>if ((GetPrivateProfileString (lpszSection, <br>     lpszToken, <br>     lpszDefault, <br>     lpszValue, <br>     TWO_K_LINE, <br>     lpszIniFile) == strlen (lpszDefault)) &amp;&amp; <br>    !strcmp (lpszDefault, lpszValue)) <br>    { <br>    LocalFree ((HLOCAL)lpszKeyNames); <br>    LocalFree ((HLOCAL)lpszValue); <br>    LocalFree ((HLOCAL)lpszToken); <br>    return FALSE; <br>    } <br>else <br>    { <br>    /* break line up into components */ <br>    ((LPPORT)lpMem)-&gt;nPosToken = sizeof (PORT); <br>    strcpy ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosToken), lpszToken); <br> <br>    ((LPPORT)lpMem)-&gt;nPosHelpStr = <br>    ((LPPORT)lpMem)-&gt;nPosToken + strlen ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosToken)) + 1; <br>    if (lpVal = strtok (lpszValue, ";")) <br>strcpy ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosHelpStr), lpVal); <br>    else <br>*(lpMem + ((LPPORT)lpMem)-&gt;nPosHelpStr) = 0; <br> <br>    ((LPPORT)lpMem)-&gt;nPosIssue = <br>    ((LPPORT)lpMem)-&gt;nPosHelpStr + strlen ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosHelpStr)) + 1; <br>    if (lpVal = strtok (NULL, ";")) <br>strcpy ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosIssue), lpVal); <br>    else <br>*(lpMem + ((LPPORT)lpMem)-&gt;nPosIssue) = 0; <br> <br>    ((LPPORT)lpMem)-&gt;nPosSuggest = <br>    ((LPPORT)lpMem)-&gt;nPosIssue + strlen ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosIssue)) + 1; <br>    if (lpVal = strtok (NULL, ";")) <br>strcpy ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosSuggest), lpVal); <br>    else <br>*(lpMem + ((LPPORT)lpMem)-&gt;nPosSuggest) = 0; <br> <br>    /* set size of dynamic token structure */ <br>    ((LPPORT)lpMem)-&gt;nSize = (((LPPORT)lpMem)-&gt;nPosSuggest + <br> strlen ((char *)(lpMem + ((LPPORT)lpMem)-&gt;nPosSuggest)) + 1); <br> <br>    /* adjust nSize for DWORD alignment */ <br>            ((LPPORT)lpMem)-&gt;nSize = ((((LPPORT)lpMem)-&gt;nSize) + 3) &amp; ~3; <br> <br>    /* set token type */ <br>    ((LPPORT)lpMem)-&gt;dwType = dwType; <br> <br>    /* adjust list pointer to point beginning of next list element */ <br>    lpMem += ((LPPORT)lpMem)-&gt;nSize; <br>    } <br> <br>/* increment token pointer and test for end of list */ <br>if (((lpKey += strlen (lpszToken) + 1) - lpszKeyNames) &gt;= (nList - 1)) <br>    { <br>    /* indicate end of list by setting size of next element to 0 */ <br>    ((LPPORT)lpMem)-&gt;nSize = 0; <br>    break; <br>    } <br>} <br> <br>    /* got to end of section, clean up and go away */ <br>    LocalFree ((HLOCAL)lpszKeyNames); <br>    LocalFree ((HLOCAL)lpszValue); <br>    LocalFree ((HLOCAL)lpszToken); <br> <br>    /* recalculate offset */ <br>    *nOffset = lpMem - lpMMFile; <br> <br>    /* return successful load */ <br>    return TRUE; <br>} <br> <br> <br>/* retrieve ini file and path */ <br>BOOL WINAPI GetIniFile ( <br>HANDLEhDLL, <br>char*lpszFileName, <br>    char    *lpszFile) <br>{ <br>    char    lpszPath[MAX_PATH]; <br>    char    *lpPath; <br>// char lpszFileName[MAX_PATH]; <br>OFSTRUCTof; <br> <br>// Is this a full path ? If so there must be a : or \ in there somewhere. <br>lpPath = lpszFileName; <br>while ( *lpPath ) <br>{ <br>   if ( *lpPath == '\\' || *lpPath == ':' ) <br>   { <br>  if ((OpenFile (lpszFileName, &amp;of, OF_EXIST))) <br>  { <br> // Name passed in is OK. <br> strcpy (lpszFile, lpszFileName); <br> return TRUE; <br>  } <br> <br>   } <br>   lpPath = CharNext(lpPath); <br>} <br> <br>// OK, not a full path, we must build one <br> <br>    /* get module directory and path */ <br>    GetModuleFileName (hDLL, lpszPath, MAX_PATH); <br>    lpPath = lpszPath + strlen (lpszPath); <br> <br>    /* find end of path by searching backwards from end to first '\' or ':' */ <br>    while (lpPath &gt; lpszPath) <br>    { <br>    if (*lpPath == '\\' || <br>        *lpPath == ':') <br>        { <br>        lpPath++; <br>        break; <br>        } <br>    lpPath = CharPrev(lpszPath, lpPath); <br>    } <br> <br>    /* terminate at end of path */ <br>    *lpPath = 0; <br> <br>    /* append ini filename to path */ <br>strcat (lpPath, lpszFileName); <br> <br>// check for an extension ( look for '.' before '\' ) <br>lpPath = lpszPath+strlen(lpszPath); <br>while ( lpPath &gt; lpszPath &amp;&amp;  <br>            *lpPath != '\\' &amp;&amp;  <br>            *lpPath != ':') <br>{ <br>   if ( *lpPath == '.') <br>  break; <br>   lpPath = CharPrev(lpszPath, lpPath); <br>} <br> <br>if ( *lpPath != '.' ) <br>{ <br>   // No extension, supply one <br>   strcat (lpszPath, ".INI"); <br>} <br> <br> <br>    /* test for existance */ <br>    if (!(OpenFile (lpszPath, &amp;of, OF_EXIST))) <br>{ <br>GetWindowsDirectory (lpszPath, MAX_PATH); <br>strcat (lpszPath, lpszFileName); <br>if (!(OpenFile (lpszPath, &amp;of, OF_EXIST))) <br>{ <br>return FALSE; <br>} <br>else <br>    { <br>    strcpy (lpszFile, lpszPath); <br>    return TRUE; <br>    } <br>} <br>    else <br>{ <br>strcpy (lpszFile, lpszPath); <br>return TRUE; <br>} <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
