<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PTFILE.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5508"></a>PTFILE.C</h2>
<pre><code>#include "PortTool.h" <br>#include &lt;string.h&gt; <br> <br>/* global file name variables */ <br>char    lpszFilePath[MAX_PATH]; <br>charlpszFilterSpec[128] = "";    // pickup eventually from string table <br> <br>charlpszPortIniFilePath[MAX_PATH]; <br>charlpszPortIniFilterSpec[128] = "";  // pickup eventually from string table <br> <br>/* call the OpenFile common dialog to get a porttool Information filename */ <br> <br> <br>/* load file filter spec strings from resource */ <br>VOID LoadFilterSpecString(LPTSTR lpDest, UINT StartID, UINT EndID) <br>{ <br>   CHAR    szBuf[MAX_PATH]; <br>   UINT    wID; <br>   INT     nOffset; <br>   HMODULE hModule = GetModuleHandle(NULL); <br> <br>    if(!*lpDest) { <br>        for(wID = StartID, nOffset = 0; wID &lt;= EndID; wID++) { <br>            LoadString((HANDLE)hModule, wID, szBuf, sizeof(szBuf)); <br>            lstrcpy(lpDest + nOffset, szBuf); <br>            nOffset += lstrlen(szBuf) + 1; <br>        } <br>    } <br>    return; <br>} <br> <br> <br>/* call the OpenFile common dialog to get a filename */ <br>BOOL WINAPI GetFileName ( <br>    HWND    hWnd, <br>    char    *lpszFileTitle, <br>    char    *lpszFilePath) <br>{ <br>    OPENFILENAME    ofn; <br>    char        lpszFileOpen[25]; <br>    char        lpszExt[10]; <br> <br>memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>strcpy (lpszFileTitle, ""); <br> <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_DEFAULTFILEEXT, <br>lpszExt, <br>sizeof (lpszExt)); <br> <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_FILEOPENTITLE, <br>lpszFileOpen, <br>sizeof (lpszFileOpen)); <br>    LoadFilterSpecString(lpszFilterSpec, IDS_FILE_FILTER_SPEC1, IDS_EXT_FILTER_SPEC3); <br> <br>    /* fill in non-variant fields of OPENFILENAME struct. */ <br>    ofn.lStructSize       = sizeof(OPENFILENAME); <br>ofn.hwndOwner  = hWnd; <br>ofn.lpstrFilter   = lpszFilterSpec; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter    = 0; <br>    ofn.nFilterIndex      = 0; <br>ofn.lpstrFile  = lpszFilePath; <br>ofn.nMaxFile  = MAX_PATH; <br>    ofn.lpstrInitialDir   = NULL; <br>    ofn.lpstrFileTitle    = lpszFileTitle; <br>    ofn.nMaxFileTitle     = MAX_PATH; <br>ofn.lpstrTitle  = lpszFileOpen; <br>ofn.lpstrDefExt   = lpszExt; <br>ofn.Flags  = OFN_FILEMUSTEXIST; <br> <br>    /* call common open dialog and return result */ <br>return (GetOpenFileName ((LPOPENFILENAME)&amp;ofn)); <br>} <br> <br>BOOL WINAPI GetPortIniFileName ( <br>    HWND    hWnd, <br>    char    *lpszFileTitle, <br>    char    *lpszFilePath) <br>{ <br>    OPENFILENAME    ofn; <br>charlpszFileOpen[64]; <br>    char        lpszExt[10]; <br> <br>memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>strcpy (lpszFileTitle, ""); <br> <br>/* load strings from resource string table */ <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_DEFAULTPORTEXT, <br>lpszExt, <br>sizeof (lpszExt)); <br> <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_PORTFILEOPENTITLE, <br>lpszFileOpen, <br>sizeof (lpszFileOpen)); <br> <br>    LoadFilterSpecString(lpszPortIniFilterSpec, IDS_FILE_FILTER_SPEC4, IDS_EXT_FILTER_SPEC5); <br> <br>    /* fill in non-variant fields of OPENFILENAME struct. */ <br>    ofn.lStructSize       = sizeof(OPENFILENAME); <br>ofn.hwndOwner  = hWnd; <br>ofn.lpstrFilter   = lpszPortIniFilterSpec; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter    = 0; <br>    ofn.nFilterIndex      = 0; <br>ofn.lpstrFile  = lpszFilePath; <br>ofn.nMaxFile  = MAX_PATH; <br>    ofn.lpstrInitialDir   = NULL; <br>    ofn.lpstrFileTitle    = lpszFileTitle; <br>    ofn.nMaxFileTitle     = MAX_PATH; <br>ofn.lpstrTitle  = lpszFileOpen; <br>ofn.lpstrDefExt   = lpszExt; <br>ofn.Flags  = 0; <br> <br>    /* call common open dialog and return result */ <br>return (GetOpenFileName ((LPOPENFILENAME)&amp;ofn)); <br>} <br> <br> <br>/* function retrieves the filename from the path */ <br>BOOL WINAPI GetFileFromPath ( <br>    char    *lpszFullPath, <br>    char    *lpszFile) <br>{ <br>    char    *lpPtr = lpszFullPath + strlen (lpszFullPath); <br> <br>    /* file is at end of path, so search backwards to first \ or : char */ <br>    while (lpPtr &gt; lpszFullPath) <br>{ <br>if (*lpPtr == '\\' || <br>    *lpPtr == ':') <br>    { <br>    lpPtr++; <br>    break; <br>    } <br>lpPtr = CharPrev(lpszFullPath, lpPtr); <br>} <br> <br>    /* return filename if found, or full path passed in */ <br>    strcpy (lpszFile, lpPtr); <br> <br>    return (lpPtr &gt; lpszFullPath); <br>} <br> <br> <br> <br> <br>/* open a file and load into edit control */ <br>int WINAPI LoadFile ( <br>    HWND    hWnd, <br>    char    *lpszName) <br>{ <br>    LONG    lLength; <br>    HWND    hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br>    HANDLE  hEditData; <br>    char    *lpEditData; <br>HFILEhFile; <br> <br>    /* open file for read &amp; write */ <br>if ((hFile = (HFILE)CreateFile (lpszName, GENERIC_READ | GENERIC_WRITE, <br>0, NULL, OPEN_EXISTING, <br>FILE_ATTRIBUTE_NORMAL, NULL)) <br>   == (HFILE)INVALID_HANDLE_VALUE) { <br>/* return error */ <br>return 0-IDS_OPENFAILED; <br>    } <br> <br>    /* get file length */ <br>    if (lLength = _llseek(hFile, 0L, 2)) <br>       _llseek(hFile, 0L, 0); <br>    else <br>    { <br>    /* close file and return error */ <br>    CloseHandle ((HANDLE)hFile); <br>return 0-IDS_NOSIZE; <br>    } <br> <br>#if !defined (WIN32) <br> <br>    /* get the edit control's memory handle */ <br>    if (!(hEditData = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0L))) <br>    { <br>    /* close file and return error */ <br>    CloseHandle ((HANDLE)hFile); <br>return 0-IDS_GETHANDLEFAILED; <br>    } <br> <br>    /* realloc the memory to fit the new file size */ <br>    if (((hEditData = LocalReAlloc(hEditData, lLength+1, LHND)) == NULL) || <br> <br>#else <br> <br>    if (((hEditData = LocalAlloc (LHND, lLength+1)) == NULL) || <br> <br>#endif <br> <br>    (!(lpEditData = (char *)LocalLock (hEditData)))) <br>    { <br>    /* close file and return error */ <br>    CloseHandle ((HANDLE)hFile); <br>return 0-IDS_REALLOCFAILED; <br>    } <br> <br> <br>    /* read the file into hEditData buffer */ <br>    if (_lread(hFile, lpEditData, lLength) == -1) <br>    { <br>    /* close file and return error */ <br>    CloseHandle ((HANDLE)hFile); <br>return 0-IDS_READFAILED; <br>    } <br> <br>    /* null terminate edit buffer */ <br>    lpEditData[lLength] = 0; <br>    LocalUnlock (hEditData); <br> <br>    /* load buffer into edit control and close file */ <br> <br>#if !defined(WIN32) <br> <br>    SendMessage (hWndEdit, EM_SETHANDLE, (UINT)hEditData, 0L); <br> <br>#else <br> <br>    lpEditData = LocalLock (hEditData); <br>    SendMessage (hWndEdit, WM_SETTEXT, 0, (LPARAM)lpEditData); <br>    GetLastError(); <br>    LocalUnlock (hEditData); <br>    // LocalFree (hEditData); // Isn't there a synchronization issue with this? <br> <br>#endif <br> <br>    CloseHandle ((HANDLE)hFile); <br> <br>    /* return success */ <br>    return TRUE; <br>} <br> <br> <br> <br>/* save file to disk */ <br>int WINAPI SaveFile ( <br>    HWND    hWnd, <br>    char    *lpszFile) <br>{ <br>    HANDLE   hEditData; <br>    int      nLength; <br>    DWORD    dwWritten; <br>    HANDLE   hFile; <br>    HWND     hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br>    char     *lpEditData; <br> <br> <br>    /* open the file for writing */ <br>    hFile = CreateFile (lpszFile, <br>    GENERIC_WRITE, <br>    0, <br>    NULL, <br>    CREATE_ALWAYS, <br>    FILE_ATTRIBUTE_NORMAL, <br>    NULL); <br> <br>    /* validate file handle */ <br>    if (!hFile) <br>    return IDS_WRITEOPENFAILED; <br> <br>    /* find out the length of the text in the edit control */ <br>    nLength = GetWindowTextLength (hWndEdit); <br> <br>#if !defined (WIN32) <br> <br>    /* get handle to Edit text and lock pointer */ <br>    hEditData  = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0); <br>    lpEditData = (char *)LocalLock (hEditData); <br> <br>#else <br> <br>    hEditData = LocalAlloc (LHND, nLength+1); <br>    lpEditData = (char *) LocalLock (hEditData); <br>    GetWindowText (hWndEdit, lpEditData, nLength+1); <br> <br>#endif <br> <br>    /* write edit data to file. */ <br>    if (!WriteFile(hFile, lpEditData, nLength, &amp;dwWritten, NULL)) <br>    { <br>    /* unlock memory, restore edit handle, close file and return error */ <br>    LocalUnlock (hEditData); <br>    CloseHandle (hFile); <br>    return IDS_WRITEFAILED; <br>    } <br> <br>    /* clean up and go away */ <br>    LocalUnlock (hEditData); <br>    CloseHandle (hFile); <br> <br>    return TRUE; <br>} <br> <br> <br>/* invokes the saveas common dialog to retrieve a file name */ <br>BOOL WINAPI SaveAsFileName ( <br>    HWND    hWnd, <br>    char    *lpszFileTitle, <br>    char    *lpszFilePath) <br>{ <br>    OPENFILENAME    ofn; <br>    char        lpszSaveAs[25]; <br>    char        lpszExt[10]; <br>    BOOL        nResult; <br> <br>memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>    *lpszFileTitle = 0; <br>    *lpszFilePath = 0; <br> <br>    /* load strings from resource string table */ <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_DEFAULTFILEEXT, <br>lpszExt, <br>sizeof (lpszExt)); <br>    LoadString ((HANDLE)GetModuleHandle (NULL), <br>IDS_SAVEASTITLE, <br>lpszSaveAs, <br>sizeof (lpszSaveAs)); <br>    LoadFilterSpecString(lpszFilterSpec, IDS_FILE_FILTER_SPEC1, IDS_EXT_FILTER_SPEC3); <br> <br>    /* fill in non-variant fields of OPENFILENAME struct. */ <br>    ofn.lStructSize   = sizeof (OPENFILENAME); <br>    ofn.hwndOwner     = hWnd; <br>    ofn.lpstrFilter   = lpszFilterSpec; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter    = 0; <br>    ofn.nFilterIndex      = 0; <br>    ofn.lpstrFile     = lpszFilePath; <br>    ofn.nMaxFile      = MAX_PATH; <br>    ofn.lpstrInitialDir   = NULL; <br>    ofn.lpstrFileTitle    = lpszFileTitle; <br>    ofn.nMaxFileTitle     = MAX_PATH; <br>    ofn.lpstrTitle    = lpszSaveAs; <br>    ofn.lpstrDefExt   = lpszExt; <br>    ofn.Flags         = 0; <br> <br>    /* call common saveas dialog and return success */ <br>    if(nResult = GetSaveFileName ((LPOPENFILENAME)&amp;ofn)) { <br>        lstrcpy(lpszFileTitle,ofn.lpstrFileTitle); // save File Title <br>    } <br>    return nResult;  <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
