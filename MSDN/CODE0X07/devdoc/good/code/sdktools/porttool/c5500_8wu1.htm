<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PTFIND.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5509"></a>PTFIND.C</h2>
<pre><code>#include "PortTool.h" <br> <br>/* global search string */ <br>char    lpszSearch[MAXSEARCHSTRING+1] = ""; <br>HWND    hDlgSearch; <br> <br>FINDREPLACE    frSearch; <br> <br> <br>/* compare two substrings */ <br>BOOL WINAPI RealSlowCompare (WORD, char *, char *); <br>BOOL WINAPI RealSlowCompare ( <br>    WORD    wCase, <br>    char    *lpszSubject, <br>    char    *lpszTarget) <br>{ <br>    if (wCase) <br>{ <br>while (*lpszTarget) <br>    if (*lpszTarget++ != *lpszSubject++) <br>return FALSE; <br>} <br>    else <br>{ <br>while (*lpszTarget) { <br>    if (IsDBCSLeadByte(*lpszSubject) || <br>IsDBCSLeadByte(*lpszTarget)) { <br>if (*lpszTarget++ != *lpszSubject++ || <br>    *lpszTarget++ != *lpszSubject++) { <br>    return FALSE; <br>} <br>    } else { <br>if ((CHAR)(DWORD)CharLower ((char *)(DWORD)(BYTE)*lpszTarget++) <br> != (CHAR)(DWORD)CharLower ((char *)(DWORD)(BYTE)*lpszSubject++)) { <br>    return FALSE; <br>} <br>    } <br>} <br>} <br>    return TRUE; <br>} <br> <br> <br> <br> <br>/* invoke the common search/replace dialog */ <br>BOOL WINAPI FindDialog ( <br>    HWND    hWnd, <br>    WORD    wCase, <br>    WORD    wDir, <br>    char    *lpszInit) <br>{ <br>    frSearch.lStructSize      = sizeof (FINDREPLACE); <br>    frSearch.hwndOwner        = hWnd; <br>    frSearch.hInstance        = (HANDLE)GetWindowLong (hWnd, GWL_HINSTANCE); <br>    frSearch.Flags            = FR_HIDEWHOLEWORD; <br> <br>    /* if wCase, case sensitive */ <br>    if (wCase) <br>frSearch.Flags        |= FR_MATCHCASE; <br>    /* if wDir, search forward */ <br>    if (wDir) <br>frSearch.Flags        |= FR_DOWN; <br> <br>    frSearch.lpstrFindWhat    = lpszInit; <br>    frSearch.lpstrReplaceWith = NULL; <br>    frSearch.wFindWhatLen     = MAXSEARCHSTRING+1; <br>    frSearch.wReplaceWithLen  = 0; <br>    frSearch.lCustData        = 0; <br>    frSearch.lpfnHook         = NULL; <br>    frSearch.lpTemplateName   = NULL; <br> <br>    /* call common search dialog */ <br>    if (hDlgSearch = FindText (&amp;frSearch)) <br>return TRUE; <br>    else <br>return FALSE; <br>} <br> <br> <br> <br>/* perform the actual text searching in the edit control data */ <br>BOOL WINAPI LocateText ( <br>    HWND        hWnd, <br>    WORD        wCase, <br>    WORD        wDir, <br>    char        *lpszStr) <br>{ <br>    UINT    uBegSel, uEndSel, uOrgBegSel, uOrgEndSel; <br>    HANDLE  hEditData; <br>    HWND    hWndEdit = (HANDLE)GetWindowLong (hWnd, WL_HWNDEDIT); <br>    char    *lpEditData; <br>    char    *lpEditHead; <br>    UINT    uLen; <br>    int     nStrLen = strlen (lpszStr); <br>    int     nChars; <br> <br>    /* test for valid string */ <br>    if (!*lpszStr) <br>return FALSE; <br> <br>    /* locate beginning of selected text */ <br>    SendMessage (hWndEdit, EM_GETSEL, (UINT)&amp;uBegSel, (UINT)&amp;uEndSel); <br>    uOrgBegSel = uBegSel; <br>    uOrgEndSel = uEndSel; <br> <br>    /* get length of the text */ <br>    uLen = (UINT)SendMessage (hWndEdit, WM_GETTEXTLENGTH, 0, 0); <br> <br>    /* Get handle to edit text data and lock it */ <br> <br>#if !defined (WIN32) <br> <br>    hEditData = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0); <br>    lpEditData = LocalLock (hEditData); <br>    lpEditHead = lpEditData; <br> <br>#else <br> <br>    hEditData = LocalAlloc (LHND, uLen); <br>    lpEditData = LocalLock (hEditData); <br>    lpEditHead = lpEditData; <br>    GetWindowText (hWndEdit, lpEditData, uLen); <br> <br>#endif <br> <br>    /* advance starting point past selection one char */ <br>    if (wDir) { <br>        if (IsDBCSLeadByte(lpEditData[uBegSel])) { <br>            uBegSel += 2; <br>        } else { <br>            uBegSel += 1; <br>        } <br>    } else { <br>        if (IsDBCSLeadByte(*CharPrev(lpEditData, lpEditData + uBegSel))) { <br>            uBegSel -= 2; <br>        } else { <br>            uBegSel -= 1; <br>        } <br>    } <br>    lpEditData += uBegSel; <br> <br>    /* count characters to search (either forward to end of file or back to beginning) */ <br>    if (wDir) <br>nChars = (int)(uLen - uBegSel + 1 - nStrLen); <br>    else <br>nChars = (int)uBegSel; <br> <br>    /* compare character by character for a substring match */ <br>    //DBCS_FIX <br>    while ((wDir &amp;&amp; nChars &gt;= nStrLen) || (!wDir &amp;&amp; nChars &gt;= 0)) <br>{ <br>/* compare this substring for a match */ <br>if (RealSlowCompare (wCase, lpEditData, lpszStr)) <br>    { <br>    /* string found, cleanup and go away */ <br>    LocalUnlock(hEditData); <br> <br>    /* scroll parent edit control and select offending text */ <br>    SendMessage (hWndEdit, EM_LINESCROLL, 0, <br>SendMessage (hWndEdit, EM_LINEFROMCHAR, uBegSel, 0) - <br>SendMessage (hWndEdit, EM_GETFIRSTVISIBLELINE, 0, 0)); <br> <br>    /* Select the located string */ <br>    uEndSel = uBegSel + nStrLen; <br>    SendMessage(hWndEdit, EM_SETSEL, uBegSel, uEndSel); <br> <br>    /* return success */ <br>    return TRUE; <br>    } <br> <br>if (wDir) { <br>    if (IsDBCSLeadByte(*lpEditData)) { <br>nChars -= 2; <br>lpEditData += 2; <br>uBegSel += 2; <br>    } else { <br>nChars--; <br>lpEditData++; <br>uBegSel++; <br>    } <br>} else { <br>    lpEditData = CharPrev(lpEditHead, lpEditData); <br>    if (IsDBCSLeadByte(*lpEditData)) { <br>nChars -= 2; <br>uBegSel -= 2; <br>    } else { <br>nChars--; <br>uBegSel--; <br>    } <br>} <br>} <br> <br>    LocalUnlock (hEditData); <br>    SendMessage (hWndEdit, EM_SETSEL, uOrgBegSel, uOrgEndSel); <br> <br>    /* return failed search  */ <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
