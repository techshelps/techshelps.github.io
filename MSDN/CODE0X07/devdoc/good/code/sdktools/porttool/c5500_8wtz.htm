<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PTDLGS.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5507"></a>PTDLGS.C</h2>
<pre><code>#include "porttool.h" <br>#include "port.h" <br> <br>int DLGOFFSET = 100; <br> <br>RESULTrIssue; <br> <br>HANDLE    hBkFileHeap; <br>extern HWND    hDlgPort; <br>extern HWND    hDlgPortStatus; <br> <br> <br>/* function prototypes for helper functions */ <br>void WINAPI GrowDialog (HWND, BOOL); <br>BOOL WINAPI GetHelpFileName (char *); <br>BOOL WINAPI BuildFileList (char *, LPBKFILELIST *); <br>BOOL WINAPI AddFile (char *, char *, BKFILELIST *); <br>BOOL WINAPI RemoveFile (char *, LPBKFILELIST *); <br>BOOL WINAPI FreeFileList (BKFILELIST *); <br> <br>BOOL MySetEvent (HWND hWnd, HANDLE hEvent); <br>BOOL MyResetEvent (HWND hWnd, HANDLE hEvent); <br> <br>/* port options dialog */ <br>BOOL WINAPI OptionsDlgProc ( <br>    HWND    hDlg, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>BOOL       bRet = TRUE; <br>static  DWORD      *dwPTFlags; <br>static  HFONT      hStrikeoutFont; <br>static  HFONT      hSystemFont; <br>LOGFONT    lf; <br> <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>    /* create strikeout font for ignored tokens */ <br>    hSystemFont = GetStockObject (SYSTEM_FONT); <br>    GetObject (hSystemFont, sizeof (LOGFONT), &amp;lf); <br>    lf.lfStrikeOut = TRUE; <br>    hStrikeoutFont = CreateFontIndirect (&amp;lf); <br> <br>    /* initialize token control with stock system font */ <br>    SendMessage (GetDlgItem (hDlg, IDC_CURTOKEN), <br> WM_SETFONT, <br> (UINT)hSystemFont, <br> FALSE); <br> <br>    /* save dwPTFlags from lParam */ <br>    dwPTFlags = (DWORD *)lParam; <br> <br>    /* initialize current token if any */ <br>    if (*(WORD *)rIssue.lpszToken != MAXTOKENLEN) <br>SetDlgItemText (hDlg, IDC_CURTOKEN, rIssue.lpszToken); <br>    else <br>EnableWindow (GetDlgItem (hDlg, IDC_IGNORETOKEN), FALSE); <br> <br>    /* initialize search flag check boxes */ <br>    CheckDlgButton (hDlg, IDC_NOAPIS, (*dwPTFlags &amp; PT_NOAPIS)); <br>    CheckDlgButton (hDlg, IDC_NOMESSAGES, (*dwPTFlags &amp; PT_NOMESSAGES)); <br>    CheckDlgButton (hDlg, IDC_NOSTRUCTURES, (*dwPTFlags &amp; PT_NOSTRUCTURES)); <br>    CheckDlgButton (hDlg, IDC_NOMACROS, (*dwPTFlags &amp; PT_NOMACROS)); <br>    CheckDlgButton (hDlg, IDC_NOCONSTANTS, (*dwPTFlags &amp; PT_NOCONSTANTS)); <br>    CheckDlgButton (hDlg, IDC_NOTYPES, (*dwPTFlags &amp; PT_NOTYPES)); <br>    CheckDlgButton (hDlg, IDC_NOCUSTOM, (*dwPTFlags &amp; PT_NOCUSTOM)); <br>    CheckDlgButton (hDlg, IDC_IGNORECASE, (*dwPTFlags &amp; PT_IGNORECASE)); <br> <br>    /* set focus to first check box, return FALSE */ <br>    SetFocus (GetDlgItem (hDlg, IDC_NOAPIS)); <br>    bRet = FALSE; <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD (uParam)) <br>{ <br>case IDOK: <br>    /* get check box states and return as FLAGS in UM_PORT message */ <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_IGNORECASE) ^ <br>(IsDlgButtonChecked (hDlg, IDC_IGNORECASE) ? PT_IGNORECASE : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOAPIS) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOAPIS) ? PT_NOAPIS : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOMESSAGES) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOMESSAGES) ? PT_NOMESSAGES : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOSTRUCTURES) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOSTRUCTURES) ? PT_NOSTRUCTURES : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOMACROS) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOMACROS) ? PT_NOMACROS : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOCONSTANTS) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOCONSTANTS) ? PT_NOCONSTANTS : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOTYPES) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOTYPES) ? PT_NOTYPES : 0); <br>    *dwPTFlags = (*dwPTFlags &amp; ~PT_NOCUSTOM) ^ <br>(IsDlgButtonChecked (hDlg, IDC_NOCUSTOM) ? PT_NOCUSTOM : 0); <br> <br>case IDCANCEL: <br>    SendMessage (GetDlgItem (hDlg, IDC_CURTOKEN), WM_SETFONT, 0, FALSE); <br>    DeleteObject (hStrikeoutFont); <br>    EndDialog (hDlg, LOWORD (uParam) == IDOK); <br>    break; <br> <br>case IDC_IGNORETOKEN: <br>    /* toggle ignore bit */ <br>    *dwPTFlags ^= PT_IGNORETOKEN; <br> <br>    /* have control draw in strikeout if ignored */ <br>    if (*dwPTFlags &amp; PT_IGNORETOKEN) <br>SendMessage (GetDlgItem (hDlg, IDC_CURTOKEN), <br>     WM_SETFONT, <br>     (UINT)hStrikeoutFont, <br>     TRUE); <br>    /* else draw in system font */ <br>    else <br>SendMessage (GetDlgItem (hDlg, IDC_CURTOKEN), <br>     WM_SETFONT, <br>     (UINT)hSystemFont, <br>     TRUE); <br>    break; <br>} <br>    break; <br> <br>default: <br>    bRet = FALSE; <br>    break; <br>} <br> <br>    /* return (message was processed); */ <br>    return bRet; <br>} <br> <br> <br> <br>/* port options dialog */ <br>BOOL WINAPI PortDlgProc ( <br>    HWND    hDlg, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>BOOL    bRet = TRUE; <br>static  DWORD   dwPTFlags; <br>static  BOOL    bSearching = TRUE; <br>static  BOOL    bHelpActive = FALSE, bIsHelpFile = FALSE; <br>static  HBRUSH  hBkBrush; <br>static  HWND    hWndEdit; <br>static  HANDLE  hEditData = NULL; <br>static  int     nIssues = 0; <br>static  int     iLineNo, iStartPos; <br>static  HLOCAL  hToken, hHelp, hIssue, hSuggest; <br>static  HLOCAL  hEditLine; <br> <br>static  UINT    uLen = 0; <br> <br> <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>    { <br>    char    lpszTitle[MAX_PATH]; <br>    char    lpszFilename[MAX_PATH]; <br>    RECT    rc; <br> <br>    HDC     hDC; <br>    HFONT   hFont; <br>    TEXTMETRIC tm; <br> <br>    hFont = GetStockObject(SYSTEM_FONT); <br>    hDC = GetDC(NULL); <br>    hFont = SelectObject(hDC, hFont); <br>    GetTextMetrics(hDC, &amp;tm); <br>    SelectObject(hDC, hFont); <br>    ReleaseDC(NULL, hDC); <br>    DLGOFFSET = tm.tmHeight * 5; <br> <br>    /* reposition self on bottom of screen */ <br>    GetWindowRect (hDlg, &amp;rc); <br>    SetWindowPos (hDlg, <br>  NULL, <br>  rc.left, <br>  GetSystemMetrics (SM_CYSCREEN) - <br>   (rc.bottom - rc.top + DLGOFFSET), <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOZORDER | SWP_NOSIZE); <br> <br>    /* set help available flag */ <br>    if (GetHelpFileName (lpszTitle)) <br>{ <br>EnableWindow (GetDlgItem (hDlg, IDC_HELPM), TRUE); <br>bIsHelpFile = TRUE; <br>} <br> <br>    /* allocate strings for Issue struct from local heap to reduce stack overhead */ <br>    if (!(rIssue.lpszToken = LocalLock (hToken = LocalAlloc (LHND, MAXTOKENLEN))) || <br>!(rIssue.lpszHelpStr = LocalLock (hHelp = LocalAlloc (LHND, MAXHELPLEN))) || <br>!(rIssue.lpszIssue = LocalLock (hIssue = LocalAlloc (LHND, MAXISSUELEN))) || <br>!(rIssue.lpszSuggest = LocalLock (hSuggest = LocalAlloc (LHND, MAXSUGGESTLEN)))) <br>{ <br>ErrorNotify (hDlg, IDS_MEMORYFAILED); <br>PostMessage (hDlg, WM_COMMAND, IDC_DONE, 0); <br>break; <br>} <br>    /* initialize line and token offset position stuff */ <br>    iLineNo = 0; <br>    iStartPos = 0; <br>    rIssue.nPosToken = 0; <br> <br>    /* initialize background brush for use in WM_CTLCOLOR message */ <br>    hBkBrush = (HBRUSH)GetClassLong (hDlg, GCL_HBRBACKGROUND); <br> <br>    /* set initial search flags to default */ <br>    dwPTFlags = 0; <br> <br>    /* initialize filename in caption */ <br>    LoadString (GetModuleHandle (NULL), IDS_PORTFILE, lpszTitle, MAX_PATH); <br>    GetFileFromPath (lpszFilePath, lpszFilename); <br>    strcat (lpszTitle, lpszFilename); <br>    SetWindowText (hDlg, lpszTitle); <br> <br>    /* IDC_SUGGESTION to SW_HIDE */ <br>    ShowWindow (GetDlgItem (hDlg, IDC_SUGGESTION), SW_HIDE); <br>    ShowWindow (GetDlgItem (hDlg, IDC_SUGGESTLABEL), SW_HIDE); <br> <br>    /* get edit window and data handle */ <br>    hWndEdit = (HWND)GetWindowLong (GetParent (hDlg), WL_HWNDEDIT); <br> <br>#if !defined (WIN32) <br> <br>    hEditData = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0); <br> <br>#else <br>    { <br>char    *lpEditData; <br>char    sz[80]; <br>MEMORYSTATUS memstat; <br> <br>uLen = GetWindowTextLength (hWndEdit); <br>hEditData = LocalAlloc (LHND, uLen+1); <br>if (hEditData == NULL) { <br>    memstat.dwLength = sizeof(MEMORYSTATUS); <br>    GlobalMemoryStatus (&amp;memstat); <br>    wsprintf (sz, "Failed Allocation: %u | %u (%u%%)", (UINT)uLen+1, (UINT)memstat.dwAvailPhys, memstat.dwMemoryLoad); <br>    //MessageBox (GetFocus(), sz, "PortTool", MB_OK); <br>    uLen = 500000; <br>    while (hEditData == NULL &amp;&amp; uLen &gt; 1000) { <br>uLen -= 1000; <br>hEditData = LocalAlloc (LHND, uLen+1); <br>    } <br>    wsprintf (sz, "hEditData = %u : uLen = %u", (UINT)hEditData, (UINT)uLen); <br>    //MessageBox (GetFocus(), sz, "PortTool", MB_OK); <br>} <br>lpEditData = LocalLock (hEditData); <br>if (lpEditData == NULL) { <br>    MessageBox (GetFocus(), "Unalble To Lock Memory!", "PortTool", MB_OK); <br>} else { <br>    UINT i; <br>    i = GetWindowText (hWndEdit, lpEditData, uLen+1); <br>    wsprintf (sz, "length: %u", i); <br>    //MessageBox (GetFocus(), sz, "PortTool", MB_OK); <br>} <br>LocalUnlock (hEditData); <br>    } <br>#endif <br> <br>    /* allocate here, reallocate later when needed */ <br>    hEditLine = LocalAlloc (LHND, 1); <br> <br>    /* post message to start ball rolling */ <br>    PostMessage (hDlg, WM_COMMAND, (UINT)IDC_CONTINUE, 0); <br> <br>    /* don't worry about focus here since were going to drive the search anyway */ <br>    bRet = TRUE; <br>    } <br>    //MessageBox (GetFocus(), "End Of Init", "PortTool", MB_OK); <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD (uParam)) <br>{ <br>case IDC_CONTINUE: <br>    { <br>    int     iLastLine, nCharOffset, nLineLen; <br>    MSG     msg; <br>    char    lpszBuff[MAXTOKENLEN]; <br>    char    *lpszLine; <br>    char    *lpLine; <br>    char    *lpEditData; <br> <br>    /* disable continue button */ <br>    EnableWindow (GetDlgItem (hDlg, IDC_CONTINUE), FALSE); <br>    EnableWindow (GetDlgItem (hDlg, IDC_OPTIONS), FALSE); <br>    EnableWindow (GetDlgItem (hDlg, IDCANCEL), TRUE); <br> <br>    /* set IDC_SEARCHFOUND to green searching */ <br>    LoadString (GetModuleHandle (NULL), IDS_SEARCHING, <br>lpszBuff, <br>sizeof (lpszBuff)); <br>    SetWindowText (GetDlgItem (hDlg, IDC_SEARCHFOUND), lpszBuff); <br>    bSearching = TRUE; <br> <br>    /* set last line */ <br>    iLastLine = (int)SendMessage (hWndEdit, EM_GETLINECOUNT, 0, 0); <br> <br>    /* find next port issue */ <br>    while (TRUE) <br>{ <br>if (iLineNo &gt;= iLastLine) <br>    { <br>    /* no more issues found, so clean up and go away */ <br>    ErrorNotify (hDlg, IDS_NOMOREPORTISSUES); <br> <br>    /* nullify any selection in line edit control */ <br>    SendMessage (GetDlgItem (hDlg, IDC_LINE), EM_SETSEL, 0, 0); <br>    break; <br>    } <br> <br>/* increment line no */ <br>SetWindowText (GetDlgItem (hDlg, IDC_LINENO), <br>       itoa (iLineNo, lpszBuff, 10)); <br> <br>/* get length and number of edit line */ <br>nCharOffset = SendMessage (hWndEdit, EM_LINEINDEX, iLineNo, 0); <br>if ((nLineLen = SendMessage (hWndEdit, EM_LINELENGTH, nCharOffset, 0)) &lt;= 2) <br>    goto NEXT_LINE; <br> <br>/* allocate enough memory for edit line */ <br>if (!(hEditLine = LocalReAlloc (hEditLine, <br>nLineLen+1, <br>LHND))) <br>    { <br>    /* no more issues found, so clean up and go away */ <br>    ErrorNotify (hDlg, IDS_MEMORYFAILED); <br>    PostMessage (hDlg, WM_COMMAND, IDC_DONE, 0); <br>    break; <br>    } <br> <br>/* get line from edit control, and null terminate */ <br> <br>/* get edit window and data handle */ <br> <br>lpEditData = LocalLock (hEditData); <br> <br>lpLine = lpszLine = LocalLock (hEditLine); <br> <br>strncpy (lpszLine, lpEditData+nCharOffset, nLineLen); <br>lpszLine[nLineLen] = 0; <br> <br>/* increment the token position for multiple errors in a line */ <br>lpLine += iStartPos; <br>LocalUnlock (hEditData); <br> <br>/* initialize line and hilight token */ <br>SetWindowText (GetDlgItem (hDlg, IDC_LINE), lpszLine); <br> <br>/* reinitialize rIssue strings lengths */ <br>*(WORD *)rIssue.lpszToken = MAXTOKENLEN; <br>*(WORD *)rIssue.lpszHelpStr = MAXHELPLEN; <br>*(WORD *)rIssue.lpszIssue = MAXISSUELEN; <br>*(WORD *)rIssue.lpszSuggest = MAXSUGGESTLEN; <br> <br>/* search next line */ <br>if (CheckString (lpLine, dwPTFlags, &amp;rIssue)) <br>    { <br>    /* set SEARCHFOUND string to found */ <br>    LoadString (GetModuleHandle (NULL), <br>IDS_FOUND, <br>lpszBuff, <br>sizeof (lpszBuff)); <br>    strcat (lpszBuff, rIssue.lpszToken); <br>    SetWindowText (GetDlgItem (hDlg, IDC_SEARCHFOUND), lpszBuff); <br> <br>    /* reenable options button */ <br>    EnableWindow (GetDlgItem (hDlg, IDC_OPTIONS), TRUE); <br> <br>    /* set searching flag off */ <br>    bSearching = FALSE; <br> <br>    /* increment issue cnt */ <br>    SetWindowText (GetDlgItem (hDlg, IDC_ISSUECNT), <br>   itoa (++nIssues, lpszBuff, 10)); <br> <br>    /* initialize Issue */ <br>    SetWindowText (GetDlgItem (hDlg, IDC_ISSUE), rIssue.lpszIssue); <br> <br>    /* if help, enble button */ <br>    EnableWindow (GetDlgItem (hDlg, IDC_HELPM), <br>  ((*(rIssue.lpszSuggest) != 0) &amp;&amp; bIsHelpFile)); <br> <br>    /* if suggest, show suggestion */ <br>    if (*(rIssue.lpszSuggest)) <br>{ <br>SetWindowText (GetDlgItem (hDlg, IDC_SUGGESTION), <br>       rIssue.lpszSuggest); <br>if (!IsWindowVisible (GetDlgItem (hDlg, IDC_SUGGESTION))) <br>    GrowDialog (hDlg, TRUE); <br>} <br> <br>    else if (IsWindowVisible (GetDlgItem (hDlg, IDC_SUGGESTION))) <br>GrowDialog (hDlg, FALSE); <br> <br>    /* scroll parent edit control and select offending text */ <br>    SendMessage (hWndEdit, EM_LINESCROLL, 0, iLineNo - <br>    SendMessage (hWndEdit, EM_GETFIRSTVISIBLELINE, 0, 0)); <br>    SendMessage (hWndEdit, <br> EM_SETSEL, <br> iStartPos + nCharOffset + rIssue.nPosToken, <br> iStartPos + nCharOffset + rIssue.nPosToken + <br>     strlen (rIssue.lpszToken)); <br> <br>    /* select text in line edit control */ <br>    SendMessage (GetDlgItem (hDlg, IDC_LINE), <br> EM_SETSEL, <br> iStartPos + rIssue.nPosToken, <br> iStartPos + rIssue.nPosToken + <br>     strlen (rIssue.lpszToken)); <br> <br>    /* reset nPosToken to check rest of line */ <br>    iStartPos += (rIssue.nPosToken + strlen (rIssue.lpszToken)); <br>    LocalUnlock (hEditLine); <br>    break; <br>    } <br> <br>/* call peek message to let user cancel if they choose */ <br>if (PeekMessage (&amp;msg, <br> GetDlgItem (hDlg, IDCANCEL), <br> WM_LBUTTONDOWN, <br> WM_LBUTTONDOWN, <br> PM_REMOVE)) <br>    { <br>    /* reset appropriate buttons */ <br>    EnableWindow (GetDlgItem (hDlg, IDCANCEL), FALSE); <br>    EnableWindow (GetDlgItem (hDlg, IDC_HELPM), FALSE); <br>    EnableWindow (GetDlgItem (hDlg, IDC_OPTIONS), TRUE); <br> <br>    /* break to let message get delivered */ <br>    break; <br>    } <br> <br>/* also let the user exit from searching */ <br>if (PeekMessage (&amp;msg, <br> GetDlgItem (hDlg, IDC_DONE), <br> WM_LBUTTONDOWN, <br> WM_LBUTTONDOWN, <br> PM_REMOVE)) <br>    { <br>    PostMessage (hDlg, WM_COMMAND, IDC_DONE, 0); <br>    break; <br>    } <br> <br>/* unlock local edit line */ <br>LocalUnlock (hEditLine); <br> <br>/* reset token position */ <br>rIssue.nPosToken = 0; <br>iStartPos = 0; <br>NEXT_LINE: <br>/* increment line and continue */ <br>iLineNo++; <br>} <br> <br>    /* enable continue button unless at end of file */ <br>    if (iLineNo &lt; iLastLine) <br>{ <br>EnableWindow (GetDlgItem (hDlg, IDC_CONTINUE), TRUE); <br>SetFocus (GetDlgItem (hDlg, IDC_CONTINUE)); <br>} <br>    else <br>{ <br>EnableWindow (GetDlgItem (hDlg, IDC_CONTINUE), FALSE); <br>EnableWindow (GetDlgItem (hDlg, IDCANCEL), FALSE); <br>SetFocus (GetDlgItem (hDlg, IDC_DONE)); <br>} <br>    } <br>    break; <br> <br>case WM_CLOSE: <br>case IDC_DONE: <br>    { <br>    char    lpszFile[MAX_PATH]; <br> <br>    if (bHelpActive &amp;&amp; <br>GetHelpFileName (lpszFile)) <br>WinHelp (hDlg, lpszFile, HELP_QUIT, 0); <br> <br>    /* clean up and go away */ <br>    LocalUnlock (hToken); LocalFree (hToken); <br>    LocalUnlock (hHelp); LocalFree (hHelp); <br>    LocalUnlock (hIssue); LocalFree (hIssue); <br>    LocalUnlock (hSuggest); LocalFree (hSuggest); <br>    LocalFree (hEditLine); <br>DestroyWindow (hDlg); <br>hDlgPort = NULL; <br> <br>    } <br>    break; <br> <br>case IDC_OPTIONS: <br>    { <br>    DWORD    dwOptions = dwPTFlags; <br> <br>    /* call dialog to start port process */ <br>    if (DialogBoxParam (GetModuleHandle (NULL), <br>IDD_OPTIONSDLG, <br>hDlg, <br>OptionsDlgProc, <br>(LPARAM)&amp;dwOptions)) <br>{ <br>dwPTFlags = dwOptions; <br> <br>/* if PT_IGNORETOKEN, call CheckString */ <br>if (dwOptions &amp; PT_IGNORETOKEN) <br>    { <br>    CheckString (rIssue.lpszToken, dwPTFlags, NULL); <br>    dwPTFlags ^= PT_IGNORETOKEN; <br>    } <br>} <br> <br>    } <br>    break; <br> <br>case IDC_HELPM: <br>    { <br>    char    lpszFile[MAX_PATH]; <br> <br>    if (bIsHelpFile &amp;&amp; GetHelpFileName (lpszFile)) <br>{ <br>WinHelp (hDlg, lpszFile, HELP_KEY, (DWORD)rIssue.lpszHelpStr); <br>bHelpActive = TRUE; <br>} <br>    } <br>    break; <br> <br>case IDC_RESTART: <br>    iLineNo = 0; <br>    rIssue.nPosToken = 0; <br>    iStartPos = 0; <br>    PostMessage (hDlg, WM_COMMAND, IDC_CONTINUE, 0); <br>    break; <br>} <br>    break; <br> <br>default: <br>    bRet = FALSE; <br>    break; <br>} <br> <br>    /* return (message was processed); */ <br>    return bRet; <br>} <br> <br> <br> <br> <br>/* background porting status dialog */ <br>BOOL WINAPI BkPortDlgProc ( <br>    HWND    hDlg, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>  BOOL          bRet = TRUE; <br>  char          szFileName[MAX_PATH]; <br>  char          szFilePath[MAX_PATH]; <br>static    BKFILELIST    *lpbkFiles; <br>static    int           iCurThread; <br>static    BOOL          bStarted = FALSE; <br>  BKFILELIST    *lpNode; <br> <br>//char szDebug[80]; <br> <br>// wsprintf (szDebug, "%i : [0x%X - 0x%X]", uMsg, uParam, lParam); <br>// OutputDebugString (szDebug); <br> <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>    { <br>    HWND          hIssues = GetDlgItem (hDlg, IDC_ISSUES); <br>    HWND          hLines = GetDlgItem (hDlg, IDC_LINES); <br>    HWND          hComplete = GetDlgItem (hDlg, IDC_COMPLETE); <br> <br>    /* set background icon to porttool background icon and start minimized */ <br>    SetClassLong (hDlg, <br>  GCL_HICON, <br>  (LONG)LoadIcon (GetModuleHandle (NULL), IDBkPort)); <br> <br>    lpbkFiles = NULL; <br>    iCurThread = -1; <br> <br>    /* build list of files to port from lParam */ <br>    if (lParam) <br>{ <br>if (!BuildFileList ((char *)lParam, &amp;lpbkFiles)) <br>    { <br>    lpbkFiles = NULL; <br>    break; <br>    } <br>} <br> <br>    else <br>{ <br>/* get file from user first */ <br>*szFileName = 0; <br>*szFilePath = 0; <br> <br>GetFileName (hDlg, szFileName, szFilePath); <br>if (!BuildFileList (szFilePath, &amp;lpbkFiles)) <br>    { <br>    lpbkFiles = NULL; <br>    break; <br>    } <br>} <br> <br>    lpNode = lpbkFiles; <br>    /* initialize each file in list */ <br>    while (lpNode) <br>{ <br>/* add filename to listbox */ <br>SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br>     LB_ADDSTRING, <br>     0, <br>     (LPARAM)lpNode-&gt;bkFile.szFile); <br> <br>/* initialize some stuff */ <br>lpNode-&gt;bkFile.hDlg = hDlg; <br>lpNode-&gt;bkFile.dwPTFlags = PT_DEFAULT; <br> <br>/* start background thread on each file */ <br>if (!StartBkPortThread (&amp;lpNode-&gt;bkFile)) { <br>    MessageBox(GetFocus(), "Failed to spawn background porting thread", "PortTool", MB_OK); <br>} <br> <br>/* traverse list */ <br>lpNode = lpNode-&gt;Next; <br>} <br> <br>    /* select first thread in listbox */ <br>    SendMessage (GetDlgItem (hDlg, IDC_FILELIST), LB_SETCURSEL, 0, 0); <br>    SetDlgItemText (hDlg, IDC_FILEPATH, lpbkFiles-&gt;bkFile.szFilePath); <br> <br>    /* if started with /b switch */ <br>    if (!GetParent (hDlg)) <br>ShowWindow (hDlg, SW_SHOWMINIMIZED); <br>    else <br>MySetEvent (hDlg, lpbkFiles-&gt;hEvents[BKPORT_STATUS]); <br> <br>    iCurThread = 0; <br>    bStarted = TRUE; <br>} <br>    break; <br> <br>case WM_SHOWWINDOW: <br>    if (bStarted) <br>{ <br>int    i = 0; <br> <br>lpNode = lpbkFiles; <br>while (i++ &lt; iCurThread) <br>    lpNode = lpNode-&gt;Next; <br> <br>if (!uParam &amp;&amp; lpNode) <br>    MyResetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_STATUS]); <br>else if(lpNode) <br>    MySetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_STATUS]); <br>} <br>    break; <br> <br>case WM_SIZE: <br>    if (bStarted) { <br>    int    i = 0; <br> <br>    lpNode = lpbkFiles; <br>     <br>    while (i++ &lt; iCurThread) { <br>        lpNode = lpNode-&gt;Next; <br>    } <br> <br>    if (uParam == SIZEICONIC &amp;&amp; lpNode) { <br>        MyResetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_STATUS]); <br>    } else if(lpNode) { <br>        MySetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_STATUS]); <br>    } <br>    } <br>    break; <br> <br>case UM_STATUSUPDATE: <br>    { <br>    char    Buff[10]; <br> <br>    /* update status info controls */ <br>    SetDlgItemText (hDlg, IDC_ISSUES, itoa (LOWORD (uParam), Buff, 10)); <br>    SetDlgItemText (hDlg, IDC_COMPLETE, itoa (HIWORD (uParam), Buff, 10)); <br>    SetDlgItemText (hDlg, IDC_LINES, itoa (lParam, Buff, 10)); <br>    } <br>    break; <br> <br>case UM_THREADCOMPLETE: <br>    { <br>    int    iThread = 0; <br> <br>    /* find handle in list */ <br>    lpNode = lpbkFiles; <br>    while (lpNode) <br>{ <br>if ((HANDLE)uParam == lpNode-&gt;bkFile.hThread) <br>    break; <br>lpNode = lpNode-&gt;Next; <br>iThread++; <br>} <br> <br>    if (lpNode) <br>{ <br>/* remove file list item */ <br>RemoveFile (lpNode-&gt;bkFile.szFilePath, &amp;lpbkFiles); <br> <br>/* remove item from list box */ <br>SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br>     LB_DELETESTRING, <br>     iThread, <br>     0); <br> <br>/* if current thread ended and more threads exist */ <br>if (iThread == iCurThread &amp;&amp; <br>    lpbkFiles             &amp;&amp; <br>    SendMessage (GetDlgItem (hDlg, IDC_FILELIST), LB_GETCOUNT, 0, 0)) <br>    { <br>    SendMessage (GetDlgItem (hDlg, IDC_FILELIST), LB_SETCURSEL, 0, 0); <br>    MySetEvent (hDlg, lpbkFiles-&gt;hEvents[BKPORT_STATUS]); <br>    iCurThread = 0; <br>    } <br> <br>else if (iThread == iCurThread) <br>    { <br>    iCurThread = -1; <br>    PostMessage (hDlg, WM_COMMAND, IDC_BKDONE, 0); <br>    } <br> <br>/* clean up controls */ <br>SetDlgItemText (hDlg, IDC_FILEPATH, ""); <br>PostMessage (hDlg, UM_STATUSUPDATE, 0, 0); <br>} <br> <br>    else <br>{ <br>                CHAR szBuf[MAX_PATH]; <br>                LoadString((HANDLE)GetModuleHandle(NULL), <br>                    IDS_ERR_INVALID_THREADHND, <br>                    szBuf,sizeof(szBuf)); <br>MessageBox (hDlg, szBuf, NULL, MB_ICONSTOP | MB_OK); <br>ExitProcess (FALSE); <br>} <br> <br>    } <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD (uParam)) <br>{ <br>case IDC_FILELIST: <br>    /* if new file selected change update signal to active thread */ <br>    if (HIWORD (uParam) == LBN_SELCHANGE) <br>{ <br>int    i = 0; <br>int    iNewThread = SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br> LB_GETCURSEL, <br> 0, <br> 0); <br> <br>/* reset current thread */ <br>lpNode = lpbkFiles; <br>while (lpNode) <br>    { <br>    if (i == iCurThread) <br>MyResetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_STATUS]); <br> <br>    if (i == iNewThread) <br>{ <br>MySetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_STATUS]); <br>SetDlgItemText (hDlg, <br>IDC_FILEPATH, <br>lpNode-&gt;bkFile.szFilePath); <br>} <br> <br>    lpNode = lpNode-&gt;Next; <br>    i++; <br>    } <br> <br>iCurThread = iNewThread; <br>} <br>    break; <br> <br>case IDC_ABORTFILE: <br>    { <br>    int        i = 0; <br>    HCURSOR    hOldCursor; <br> <br>    /* reset current thread */ <br>    lpNode = lpbkFiles; <br>    while (lpNode) <br>{ <br>if (i == iCurThread) <br>    { <br>    /* put hourglass cursor up */ <br>    hOldCursor = (HCURSOR)SetClassLong (hDlg, GCL_HCURSOR, 0); <br>    SetCursor (LoadCursor (NULL, IDC_WAIT)); <br> <br>    /* abort porting file where it is */ <br>    MySetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_ABORT]); <br> <br>    /* remove file from list when thread is dead */ <br>    WaitForSingleObject (lpNode-&gt;bkFile.hThread, INFINITE); <br>    RemoveFile (lpNode-&gt;bkFile.szFilePath, &amp;lpbkFiles); <br> <br>    /* replace original cursor */ <br>    SetClassLong (hDlg, GCL_HCURSOR, (LONG)hOldCursor); <br>    SetCursor (hOldCursor); <br> <br>    /* update listbox */ <br>    SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br> LB_DELETESTRING, <br> iCurThread, <br> 0); <br> <br>    /* select new event if any in listbox */ <br>    if (SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br>     LB_GETCOUNT, <br>     0, <br>     0)) <br>{ <br>SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br>     LB_SETCURSEL, <br>     0, <br>     0); <br>MySetEvent (hDlg, lpbkFiles-&gt;hEvents[BKPORT_STATUS]); <br>iCurThread = 0; <br>} <br> <br>    else <br>{ <br>iCurThread = -1; <br>PostMessage (hDlg, WM_COMMAND, IDC_DONE, 0); <br>} <br> <br>    /* clean up controls */ <br>    SetDlgItemText (hDlg, IDC_FILEPATH, ""); <br>    PostMessage (hDlg, UM_STATUSUPDATE, 0, 0); <br>    break; <br>    } <br> <br>lpNode = lpNode-&gt;Next; <br>i++; <br>} <br>    } <br>    break; <br> <br>case IDC_ADDFILE: <br>    { <br>    /* get file from user first */ <br>    *szFileName = 0; <br>    *szFilePath = 0; <br> <br>    /* add a file to the list */ <br>    if (GetFileName (hDlg, szFileName, szFilePath)) <br>{ <br>/* if new list */ <br>            if (!lpbkFiles) <br>            { <br>                if (!BuildFileList (szFilePath, &amp;lpbkFiles)) <br>                { <br>                    lpbkFiles = NULL; <br>                    break; <br>                } <br>            } <br>else if (!AddFile (szFilePath, szFileName, lpbkFiles)) <br>    break; <br> <br>/* find node in list */ <br>lpNode = lpbkFiles; <br>while (lpNode) <br>    { <br>    if (!strcmp (lpNode-&gt;bkFile.szFilePath, szFilePath)) <br>break; <br>    lpNode = lpNode-&gt;Next; <br>    } <br> <br>if (lpNode) <br>    { <br>    /* add filename to listbox */ <br>    SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br> LB_ADDSTRING, <br> 0, <br> (LPARAM)lpNode-&gt;bkFile.szFile); <br> <br>    /* initialize some stuff */ <br>    lpNode-&gt;bkFile.hDlg = hDlg; <br>    lpNode-&gt;bkFile.dwPTFlags = PT_DEFAULT; <br> <br>    /* start background thread on this file */ <br>    StartBkPortThread (&amp;lpNode-&gt;bkFile); <br> <br>    /* if first thread */ <br>    if (iCurThread == -1 || <br>SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br>     LB_GETCOUNT, 0, 0) == 1) <br>{ <br>iCurThread = 0; <br>SendMessage (GetDlgItem (hDlg, IDC_FILELIST), <br>     LB_SETCURSEL, <br>     0, <br>     0); <br>SendMessage (hDlg, <br>     WM_COMMAND, <br>     MAKELONG (IDC_FILELIST, LBN_SELCHANGE), <br>     0); <br>} <br>    } <br>} <br>    } <br>    break; <br> <br>case IDC_CHANGEOPTIONS: <br>    { <br>    DWORD    dwFlags; <br> <br>dwFlags = 0L; <br>    dwFlags = (dwFlags &amp; ~PT_IGNORECASE) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKIGNORECASE) ? PT_IGNORECASE : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOAPIS) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOAPIS) ? PT_NOAPIS : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOMESSAGES) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOMESSAGES) ? PT_NOMESSAGES : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOSTRUCTURES) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOSTRUCTURES) ? PT_NOSTRUCTURES : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOMACROS) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOMACROS) ? PT_NOMACROS : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOCONSTANTS) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOCONSTANTS) ? PT_NOCONSTANTS : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOTYPES) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOTYPES) ? PT_NOTYPES : 0); <br>    dwFlags = (dwFlags &amp; ~PT_NOCUSTOM) ^ <br>(IsDlgButtonChecked (hDlg, IDC_BKNOCUSTOM) ? PT_NOCUSTOM : 0); <br> <br>    /* change the options for the file being ported */ <br>    lpbkFiles-&gt;bkFile.dwPTFlags = dwFlags; <br>    } <br>    break; <br> <br>case IDCANCEL: <br>    { <br>    HCURSOR    hOldCursor; <br>    HANDLE     hThreads[MAXBKTHREADS]; <br>    int        i = 0; <br>                    CHAR       szText[MAX_PATH]; // for LoadString() <br>                    CHAR       szTitle[MAX_PATH]; // for LoadString() <br>                    HMODULE    hModule = GetModuleHandle(NULL); <br> <br>    /* put up confirm message */ <br>                    LoadString((HANDLE)hModule, <br>                        IDS_CANCEL_BKGND_PROCESS, <br>                        szText,sizeof(szText)); <br>                    LoadString((HANDLE)hModule, <br>                        IDS_ABORT_TITLE, <br>                        szTitle,sizeof(szTitle)); <br>    if (MessageBox (hDlg, <br>    szText, szTitle, <br>    MB_ICONQUESTION | MB_OKCANCEL) == IDOK) <br>{ <br>/* put hourglass cursor up */ <br>hOldCursor = (HCURSOR)SetClassLong (hDlg, GCL_HCURSOR, 0); <br>SetCursor (LoadCursor (NULL, IDC_WAIT)); <br> <br>/* if any files in list */ <br>if (lpbkFiles) <br>    { <br>    /* abort all background threads and build thread handle array */ <br>    lpNode = lpbkFiles; <br>    while (lpNode) <br>{ <br>MySetEvent (hDlg, lpNode-&gt;hEvents[BKPORT_ABORT]); <br>hThreads[i++] = lpNode-&gt;bkFile.hThread; <br>lpNode = lpNode-&gt;Next; <br>} <br> <br>    /* wait on completion of background threads */ <br>    WaitForMultipleObjects (i, hThreads, TRUE, INFINITE); <br> <br>    /* free background port resources */ <br>    FreeFileList (lpbkFiles); <br>    } <br> <br>SetClassLong (hDlg, GCL_HCURSOR, (LONG)hOldCursor); <br>SetCursor (hOldCursor); <br>DestroyWindow (hDlg); <br>hDlgPortStatus = NULL; <br> <br>} <br>    } <br>    break; <br> <br>case IDC_BKDONE: <br>    /* if file list post message to cancel */ <br>    if (lpbkFiles) <br>PostMessage (hDlg, WM_COMMAND, IDCANCEL, 0); <br>    else <br>DestroyWindow (hDlg); <br>hDlgPortStatus = NULL; <br>    break; <br> <br>default: <br>    bRet = FALSE; <br>    break; <br>} <br>    break; <br> <br>case WM_DESTROY: <br>    /* if no parent, post quit message */ <br>    if (GetParent (hDlg) == NULL) <br>PostQuitMessage (1); <br>    break; <br> <br>default: <br>    bRet = FALSE; <br>    break; <br>} <br> <br>    return bRet; <br>} <br> <br> <br> <br>/* funtion retrieves the help filename from the ini file */ </code></pre>
<p>
</p>
<pre><code>BOOL WINAPI GetHelpFileName ( <br>    char    *lpszFile) <br>{ <br>    char        szAppName[30]; <br>    char        szWinHelp[30]; <br>    char        szDefault[] = "Default"; <br>    OFSTRUCT    of; <br> <br>    /* get help filename from ini file */ <br>    LoadString (GetModuleHandle (NULL), IDS_APPNAME, szAppName, 30); <br>    LoadString (GetModuleHandle (NULL), IDS_WINHELP, szWinHelp, 30); <br>    GetPrivateProfileString (szAppName, <br>     szWinHelp, <br>     szDefault, <br>     lpszFile, <br>     MAX_PATH, <br> lpszPortIniFilePath); <br> <br>    /* test to see if help file exists */ <br>    return (OpenFile (lpszFile, &amp;of, OF_EXIST) != -1); <br>} <br> <br> <br> <br> <br>/* rearrange dialog and controls */ <br>void WINAPI GrowDialog ( <br>    HWND    hDlg, <br>    BOOL    bBigger) <br>{ <br>    RECT    rc; <br>    int     nChange = (bBigger ? DLGOFFSET : -DLGOFFSET); <br> <br>    /* grow main dialog */ <br>    GetWindowRect (hDlg, &amp;rc); <br>    SetWindowPos (hDlg, <br>  NULL, <br>  rc.left, <br>  rc.top, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top + nChange, <br>  SWP_NOMOVE | SWP_NOZORDER); <br> <br>    /* move stop button down */ <br>    GetWindowRect (GetDlgItem (hDlg, IDCANCEL), &amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc.right); <br>    SetWindowPos (GetDlgItem (hDlg, IDCANCEL), <br>  NULL, <br>  rc.left, <br>  rc.top + nChange, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* move CONTINUE button down */ <br>    GetWindowRect (GetDlgItem (hDlg, IDC_CONTINUE), &amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc.right); <br>    SetWindowPos (GetDlgItem (hDlg, IDC_CONTINUE), <br>  NULL, <br>  rc.left, <br>  rc.top + nChange, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* move restart button down */ <br>    GetWindowRect (GetDlgItem (hDlg, IDC_RESTART), &amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc.right); <br>    SetWindowPos (GetDlgItem (hDlg, IDC_RESTART), <br>  NULL, <br>  rc.left, <br>  rc.top + nChange, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* move options button down */ <br>    GetWindowRect (GetDlgItem (hDlg, IDC_OPTIONS), &amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc.right); <br>    SetWindowPos (GetDlgItem (hDlg, IDC_OPTIONS), <br>  NULL, <br>  rc.left, <br>  rc.top + nChange, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* move help button down */ <br>    GetWindowRect (GetDlgItem (hDlg, IDC_HELPM), &amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc.right); <br>    SetWindowPos (GetDlgItem (hDlg, IDC_HELPM), <br>  NULL, <br>  rc.left, <br>  rc.top + nChange, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* move done button down */ <br>    GetWindowRect (GetDlgItem (hDlg, IDC_DONE), &amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc); <br>    ScreenToClient (hDlg, (LPPOINT)&amp;rc.right); <br>    SetWindowPos (GetDlgItem (hDlg, IDC_DONE), <br>  NULL, <br>  rc.left, <br>  rc.top + nChange, <br>  rc.right-rc.left, <br>  rc.bottom-rc.top, <br>  SWP_NOSIZE | SWP_NOZORDER); <br> <br>    /* show suggestion edit control and label when appropriate */ <br>    ShowWindow (GetDlgItem (hDlg, IDC_SUGGESTION), (bBigger ? SW_SHOW : SW_HIDE)); <br>    ShowWindow (GetDlgItem (hDlg, IDC_SUGGESTLABEL), (bBigger ? SW_SHOW : SW_HIDE)); <br>} <br> <br> <br> <br> <br>BOOL WINAPI BuildFileList ( <br>    char          *lpFileList, <br>    LPBKFILELIST  *lpList) <br>{ <br>    char        *lpFile; <br>    char        szFilePath[MAX_PATH]; <br>    char        szFile[MAX_PATH]; <br>    HFILE       hFile; <br>    OFSTRUCT    of; <br>    BOOL        bList = FALSE; <br> <br>    /* create heap for up to 50 files at a time */ <br>    if (!(hBkFileHeap = HeapCreate (HEAP_NO_SERIALIZE, <br>    sizeof (BKFILELIST), <br>    MAXBKTHREADS * sizeof (BKFILELIST)))) <br>return FALSE; <br> <br>    /* allocate first node in list */ <br>    *lpList = (BKFILELIST *)HeapAlloc (hBkFileHeap, 0, sizeof (BKFILELIST)); <br>    (*lpList)-&gt;hEvents[BKPORT_ABORT] = NULL; <br> <br>    /* parse first file in list */ <br>    lpFile = strtok (lpFileList, " "); <br> <br>    /* loop through all files in list */ <br>    while (lpFile) <br>{ <br>strcpy (szFilePath, lpFile); <br> <br>/* if no path, add current directory as path */ <br>if (!GetFileFromPath (szFilePath, szFile)) <br>    { <br>    strcpy (szFile, szFilePath); <br>    GetCurrentDirectory (MAX_PATH, szFilePath); <br>    strcat (szFilePath, "\\"); <br>    strcat (szFilePath, szFile); <br>    } <br> <br>/* verify file is available */ <br>hFile = OpenFile (szFilePath, &amp;of, OF_READWRITE); <br>if (hFile != -1) <br>    { <br>    /* added at least one file */ <br>    bList = TRUE; <br> <br>    /* close file */ <br>    CloseHandle ((HANDLE)hFile); <br> <br>    /* add file to list */ <br>    AddFile (szFilePath, szFile, *lpList); <br>    } <br> <br>/* get next file in list */ <br>lpFile = strtok (NULL, " "); <br>} <br> <br>    /* if no valid files, cleanup */ <br>    if (!bList) <br>{ <br>HeapDestroy (hBkFileHeap); <br>return FALSE; <br>} <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>BOOL WINAPI AddFile ( <br>    char        *lpFilePath, <br>    char        *lpFile, <br>    BKFILELIST  *lpbkFiles) <br>{ <br>    BKFILELIST    *lpNode; <br> <br> <br>    /* if first item in list don't need to allocate */ <br>    if (!lpbkFiles-&gt;hEvents[BKPORT_ABORT]) <br>lpNode = lpbkFiles; <br>    else <br>{ <br>lpNode = (BKFILELIST *)HeapAlloc (hBkFileHeap, 0, sizeof (BKFILELIST)); <br>if (!lpNode) <br>    return FALSE; <br> <br>/* find end of list then add new node */ <br>while (lpbkFiles-&gt;Next) <br>    lpbkFiles = lpbkFiles-&gt;Next; <br>lpbkFiles-&gt;Next = lpNode; <br>} <br> <br>    /* initialize node structure */ <br>    strcpy (lpNode-&gt;bkFile.szFile, lpFile); <br>    strcpy (lpNode-&gt;bkFile.szFilePath, lpFilePath); <br>    CreateEvents (lpNode-&gt;hEvents, &amp;lpNode-&gt;bkFile); <br>    lpNode-&gt;Next = NULL; <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>BOOL WINAPI RemoveFile ( <br>    char          *lpFilePath, <br>    LPBKFILELIST  *lpbkFiles) <br>{ <br>    BKFILELIST    *pHead = *lpbkFiles; <br>    BKFILELIST    *pTail = *lpbkFiles; <br> <br>    /* loop thru list until file name matches */ <br>    while (pHead) <br>{ <br>if (!strcmp (lpFilePath, pHead-&gt;bkFile.szFilePath)) <br>    { <br>    /* special case remove first node */ <br>    if (pTail == pHead) <br>{ <br>*lpbkFiles = pHead-&gt;Next; <br>DestroyEvents (pHead-&gt;hEvents); <br>HeapFree (hBkFileHeap, 0, (char *)(pHead)); <br> <br>/* if no more nodes, destroy heap */ <br>if (!*lpbkFiles) <br>    HeapDestroy (hBkFileHeap); <br>} <br> <br>    else <br>{ <br>pTail-&gt;Next = pHead-&gt;Next; <br>DestroyEvents (pHead-&gt;hEvents); <br>HeapFree (hBkFileHeap, 0, (char *)pHead); <br>} <br> <br>    return TRUE; <br>    } <br> <br>pTail = pHead; <br>pHead = pHead-&gt;Next; <br>} <br> <br>    return FALSE; <br>} <br> <br> <br> <br> <br>BOOL WINAPI FreeFileList ( <br>    BKFILELIST  *lpbkFiles) <br>{ <br>    /* loop thru each list item */ <br>    while (lpbkFiles) <br>{ <br>/* destroy event handles */ <br>DestroyEvents (lpbkFiles-&gt;hEvents); <br> <br>lpbkFiles = lpbkFiles-&gt;Next; <br>} <br> <br>    /* release entire heap */ <br>    HeapDestroy (hBkFileHeap); <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL MySetEvent (HWND hWnd, HANDLE hEvent) <br>{ <br>    if (SetEvent(hEvent)) { <br>return TRUE; <br>    } else { <br>return PostMessage (hWnd, (UINT)hEvent, 0, 0L); <br>    } <br>} <br> <br>BOOL MyResetEvent (HWND hWnd, HANDLE hEvent) <br>{ <br>    MSG msg; <br> <br>    if (ResetEvent(hEvent)) { <br>return TRUE; <br>    } else { <br>PeekMessage (&amp;msg, hWnd, (UINT)hEvent, (UINT)hEvent, TRUE); <br>return TRUE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
