<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PTPRINT.C</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context5510"></a>PTPRINT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright (C) 1993-96 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "PortTool.h" <br> <br>HWNDhCancelDlg = 0; <br>PRINTDLGpdPrint; <br> <br> <br>/* get default printer configuration and save in hWnd extra bytes for use later */ <br>BOOL WINAPI GetPrinterConfig ( <br>    HWND    hWnd) <br>{ <br>    pdPrint.lStructSize = sizeof (PRINTDLG); <br>pdPrint.Flags= PD_RETURNDEFAULT; <br>pdPrint.hwndOwner= hWnd; <br>pdPrint.hDevMode= NULL; <br>pdPrint.hDevNames= NULL; <br>pdPrint.hDC = NULL; <br> <br>PrintDlg (&amp;pdPrint); <br> <br>SetWindowLong (hWnd, WL_HPTRDEVNAMES, (LONG) pdPrint.hDevNames); <br> <br>return TRUE; <br>} <br> <br> <br> <br>/* abort proc called by gdi during print download process */ <br>int WINAPI AbortProc ( <br>    HDC     hdc, <br>    int     nErr) <br>{ <br>    BOOL    fContinue = TRUE; <br>    MSG     msg; <br> <br>    /* process messages for cancel dialog and other apps */ <br>    while (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>{ <br>if (msg.message == UM_CANCELPRINT) <br>    { <br>    fContinue = FALSE; <br>    break; <br>    } <br> <br>else if (!hCancelDlg || !IsDialogMessage (hCancelDlg, &amp;msg)) <br>    { <br>    TranslateMessage (&amp;msg); <br>    DispatchMessage  (&amp;msg); <br>    } <br>} <br> <br>    return fContinue; <br>} <br> <br> <br> <br> <br>BOOL WINAPI CancelDlgProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br> <br>    switch (uMsg) <br>{ <br>case WM_INITDIALOG: <br>    { <br>    char    *lpdn; <br>    char    lpszTitle[MAX_PATH]; <br>        HWND    hWndOwner = GetWindow(hWnd, GW_OWNER); <br> <br>    /* initialize dialog control information */ <br>    lpdn = LocalLock (pdPrint.hDevNames); <br> <br>    SetDlgItemText (hWnd, <br>    IDC_PRINTDEVICE, <br>    lpdn + sizeof (DEVNAMES) + <br>((DEVNAMES *)lpdn)-&gt;wDeviceOffset); <br>    SetDlgItemText (hWnd, <br>    IDC_PRINTPORT, <br>    lpdn + sizeof (DEVNAMES) + <br>((DEVNAMES *)lpdn)-&gt;wOutputOffset); <br>    LocalUnlock (pdPrint.hDevNames); <br>    GetWindowText (hWndOwner, lpszTitle, sizeof (lpszTitle)); <br>    SetDlgItemText (hWnd, IDC_PRINTTITLE, lpszTitle); <br>    } <br>    break; <br> <br>case WM_COMMAND: <br>    /* if cancel button selected, post message to cancel print job */ <br>    if (LOWORD (uParam) == IDCANCEL) <br>{ <br>PostMessage (GetParent (hWnd), UM_CANCELPRINT, 0, 0); <br>DestroyWindow (hWnd); <br>} <br>    break; <br> <br>default: <br>    return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br> <br>/* put up the print common dialog, and print */ <br>int WINAPI PrintFile ( <br>    HWND    hWnd) <br>{ <br>    char*lpEditData; <br>    HANDLEhEditData; <br>    SIZEsLine; <br>    int yLineExt; <br>    int yExt; <br>    int yPageExt; <br>    UINTuLine; <br>    UINTuNumLines; <br>    UINTuOffset; <br>    UINTuLineLen; <br>    UINTuTitleLen; <br>    HWNDhWndEdit; <br>// PRINTDLGpdPrint; <br>    DOCINFOdiPrint; <br>    charlpszJobName[MAX_PATH]; <br>    HFONThFont; <br>    HFONThFontPrt = NULL; <br>    intnPageCnt = 1; <br> <br> <br>    /* call common print dialog to get initialized printer DC */ <br>    pdPrint.hwndOwner = hWnd; <br>    pdPrint.hDC = NULL; <br>    pdPrint.Flags = PD_RETURNDC ; <br> <br> <br>    /* call common print dialog */ <br>    if (!PrintDlg (&amp;pdPrint)) <br>return IDS_PTRCOMMDLGFAILED; <br> <br>    /* start cancel dialog box */ <br>    hCancelDlg = CreateDialog ((HANDLE)GetModuleHandle (NULL), <br>       IDD_CANCELDLG, <br>       hWnd, <br>       CancelDlgProc); <br> <br> <br>    if (!hCancelDlg) <br>return IDS_CANCELDLGFAILED; <br> <br>    ShowWindow (hCancelDlg, SW_SHOW); <br>    UpdateWindow (hCancelDlg); <br> <br>    /* set AbortProc callback */ <br>    if (SetAbortProc (pdPrint.hDC, AbortProc) &lt; 0) <br>{ <br>/* on error, clean up and go away */ <br>DestroyWindow (hCancelDlg); <br>DeleteDC (pdPrint.hDC); <br>return IDS_SETABORTPROCFAILED; <br>} <br> <br>    hWndEdit = (HWND)GetWindowLong (hWnd, WL_HWNDEDIT); <br>    if (NULL == (hFont = (HFONT)SendMessage(hWndEdit, WM_GETFONT, 0, 0L))) { <br>        hFont = GetStockObject(SYSTEM_FONT); <br>    } else { <br>        HDC     hdcScreen; <br>        LOGFONT lf; <br> <br>        if (NULL != (hdcScreen = GetDC(hWnd))) { <br>            if(GetObject(hFont, sizeof(LOGFONT), &amp;lf)) { <br>                lf.lfWidth = 0; <br>                lf.lfHeight = lf.lfHeight <br>                            * GetDeviceCaps(pdPrint.hDC, LOGPIXELSX) <br>                            / GetDeviceCaps(hdcScreen, LOGPIXELSX); <br>                if (NULL != (hFontPrt = CreateFontIndirect(&amp;lf))) { <br>                    hFont = hFontPrt; <br>                } <br>            } <br>            ReleaseDC(hWnd, hdcScreen); <br>        } <br>    } <br>    hFont = SelectObject(pdPrint.hDC, hFont); <br> <br>    /* initialize printer for job */ <br>    GetWindowText (hWnd, lpszJobName, sizeof (lpszJobName)); <br>    diPrint.cbSize = sizeof (DOCINFO); <br>    diPrint.lpszDocName = lpszJobName; <br>    diPrint.lpszOutput = NULL; <br>    if (StartDoc (pdPrint.hDC, &amp;diPrint) == SP_ERROR ||  StartPage (pdPrint.hDC) &lt; 0) <br>{ <br>/* on error, clean up and go away */ <br>DestroyWindow (hCancelDlg); <br>SelectObject(pdPrint.hDC, hFont); <br>        if (hFontPrt) { <br>    DeleteObject(hFontPrt); <br>        } <br>DeleteDC (pdPrint.hDC); <br>return IDS_STARTDOCFAILED; <br>} <br> <br>    /* job started, so display cancel dialog */ <br>    ShowWindow (hCancelDlg, SW_SHOW); <br>    UpdateWindow (hCancelDlg); <br> <br>    /* retrieve dimensions for printing and init loop variables */ <br>    /* 'hWndEdit' has already been got. */ <br>    hWndEdit = (HWND)GetWindowLong(hWnd, WL_HWNDEDIT); <br>    hEditData = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0L); <br>    uNumLines = (WORD)SendMessage (hWndEdit, EM_GETLINECOUNT, 0, 0L); <br>    GetTextExtentPoint (pdPrint.hDC, "CC", 2, &amp;sLine); <br>    yLineExt = sLine.cy; <br>    yPageExt = GetDeviceCaps (pdPrint.hDC, VERTRES); <br>    yExt = 0; <br>    uLine = 0; <br>    if (pdPrint.Flags &amp; PD_PAGENUMS) { <br>uLine = (pdPrint.nFromPage - 1) * (yPageExt / yLineExt); <br>    } <br> <br>    /* print text line by line from top to bottom */ <br>    while (uLine &lt; uNumLines) <br>{ <br>if ((pdPrint.Flags &amp; PD_PAGENUMS) &amp;&amp; <br>    (uLine &gt;= (UINT)(pdPrint.nToPage * (yPageExt / yLineExt)))) { <br>    break; <br>} <br>/* if at end of page, start a new page */ <br>if ((yExt + yLineExt) &gt; yPageExt) <br>    { <br>    if (!EndPage (pdPrint.hDC) || StartPage (pdPrint.hDC) &lt; 0) <br>{ <br>DestroyWindow (hCancelDlg); <br>SelectObject(pdPrint.hDC, hFont); <br>                if (hFontPrt) { <br>                    DeleteObject(hFontPrt); <br>                } <br>DeleteDC (pdPrint.hDC); <br>return IDS_PRINTABORTED; <br>} <br>    yExt = 0; <br>    } <br> <br>/* determine buffer offset for current line and line length */ <br>uOffset = SendMessage (hWndEdit, EM_LINEINDEX, uLine, 0); <br>uLineLen = SendMessage (hWndEdit, EM_LINELENGTH, uOffset, 0); <br> <br>#if defined (WIN32) <br>    uTitleLen=GetWindowTextLength(hWndEdit); <br>    hEditData=LocalAlloc(LHND,uTitleLen+1);  <br>    lpEditData=LocalLock(hEditData);  <br>    GetWindowText(hWndEdit, lpEditData, uTitleLen+1); <br>#else <br>    hEditData = (HANDLE)SendMessage (hWndEdit, EM_GETHANDLE, 0, 0L); <br>lpEditData = LocalLock (hEditData); <br>#endif <br> <br>/* print current the line and unlock the text handle */ <br>    TextOut (pdPrint.hDC, 0, yExt, (char *)lpEditData+uOffset, uLineLen); <br>LocalUnlock (hEditData); <br> <br>/* increment page position */ <br>yExt += yLineExt; <br>uLine++; <br>} <br> <br>    /* end the last page and document */ <br>    EndPage (pdPrint.hDC); <br>    EndDoc (pdPrint.hDC); <br> <br>    SelectObject(pdPrint.hDC, hFont); <br>    if (hFontPrt) { <br>        DeleteObject(hFontPrt); <br>    } <br>    /* end cancel dialog box, clean up and exit */ <br>    DestroyWindow (hCancelDlg); <br>    DeleteDC(pdPrint.hDC); <br>    return TRUE; <br>} <br> <br> <br> <br>/* printer setup common dialog */ <br>int WINAPI PrinterSetup ( <br>    HWND    hWnd) <br>{ <br>// PRINTDLGpdPrint; <br> <br>pdPrint.Flags= PD_PRINTSETUP; <br>pdPrint.hwndOwner= hWnd; <br> <br>    /* call common print dialog */ <br>if (!PrintDlg (&amp;pdPrint) &amp;&amp; CommDlgExtendedError ()) <br>return IDS_PTRCOMMDLGFAILED; <br>else <br>return 0; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
