<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Providing Appearance Using Constituent Controls</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconprovidingappearanceusingconstituentcontrols"></a>Providing Appearance Using Constituent Controls</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconProvidingAppearanceUsingConstituentControlsC">
</object></p>
<p>
If you're enhancing an existing control, that single constituent control will typically occupy the entire visible surface of your UserControl object. You can accomplish this by using the Move method of the constituent control in the Resize event of the UserControl, as shown below.</p>
<pre><code>Private Sub UserControl_Resize()
   picBase.Move 0, 0, ScaleWidth, ScaleHeight
End Property
</code></pre>
<p>
The code above assumes that an enhanced picture control is being authored. A PictureBox control has been placed on the UserControl, and named picBase.</p>
<p>
If the control you're enhancing has a minimum size, or a dimension that increases in large increments — such as the height of a ListBox control, which changes by the height of a line of text — you will have to add code to determine whether the Move method has produced the desired result.</p>
<p>
You can rely on the control you're enhancing to handle painting, including (where appropriate) default button highlighting.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;You may also have to add code to resize your UserControl object, to accommodate a constituent control that can't be sized arbitrarily — such as a text box or list box. To avoid exhausting stack space with recursive calls to the Resize event, use static variables to determine when the UserControl_Resize event procedure is making recursive calls.</p>
<h3>Resizing a Control Assembly</h3>
<p>
If you're authoring a control assembly, the Resize event will be more complex, because you have to adjust both size and relative location of multiple constituent controls.</p>
<h3>Enforcing a Minimum Control Size</h3>
<p>
If you author a control with a large number of constituent controls, there may be a minimum size below which resizing the constituent controls is futile, because too little of each control is visible to be of any use, or because the enforced minimum sizes of some constituent controls has been reached.</p>
<p>
There is no real harm in allowing the user to reduce the size of your control to absurdity. Most controls allow this, because preventing it is a lot of work, and because at some point you have to rely on your user's desire to produce an application that works and is usable.</p>
<p>
In the event that resizing below some threshold causes your control to malfunction, you might make all of your constituent controls invisible, as an alternative to enforcing a minimum size.</p>
<p>
The following code fragment provides a simple example of enforcing a minimum size.</p>
<pre><code>Private Sub UserControl_Resize()
   Dim sngMinH As Single
   Dim sngMinW As Single

   ' Code to resize constituent controls. It is
   ' assumed that each of these will have some minimum
   ' size, which will go into the calculation of the
   ' UserControl's minimum size.

   sngMinW = &lt;&lt;Width calculation&gt;&gt;
   sngMinH = &lt;&lt;Height calculation&gt;&gt;

   If Width &lt; sngMinW Then Width = sngMinW
   If Height &lt; sngMinH Then Height = sngMinH
End Sub
</code></pre>
<p>
Notice the &lt;&lt;pseudo-code placeholders&gt;&gt; for the calculation of your control's minimum width and height. These calculations will be in the ScaleMode units of your UserControl. They may be very complicated, involving the widths and heights of several of the constituent controls.</p>
<p>
The Width and Height properties of the UserControl are then set, if necessary.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;The Width and Height properties of the UserControl include the thickness of the border, if any. If BorderStyle = 1 (Fixed Single), the area available for constituent controls will be reduced by two <i>pixels</i> (not Twips) in both width and height. If you have exposed the BorderStyle property for your user to set, include code to test the current value.</p>
<p>
As an alternative, you could use the Size method:</p>
<pre><code>   If Width &gt; sngMinW Then sngMinW = Width
   If Height &gt; sngMinH Then sngMinH = Height
   If (sngMinW &lt;&gt; Width) Or (sngMinH &lt;&gt; Height) Then
      ' (Optionally, set recursion flag.)
      Size sngMinW, sngMinH
      ' (Clear recursion flag, if set.)
   End If
</code></pre>
<p>
This code is more slightly more complicated, but it simplifies things if you need to avoid recursion when resizing your control, as discussed below.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;The Width and Height properties of the UserControl are always expressed in Twips, regardless of the ScaleMode setting. If you have set ScaleMode to something other than Twips, use the ScaleX and ScaleY methods to convert your minimum size calculations to Twips.</p>
<h4>Dealing with Recursion</h4>
<p>
No code for recursion is included in the example above, and recursion is virtually guaranteed. For example, if you attempt to resize the control so that both width and height are below the minimum values, the Resize event will reset the Width property, which will cause a second Resize to be raised immediately.</p>
<p>
This second Resize event will test and reset the height, and then return — so that by the time the first Resize event tests the height, it will already have been reset to the minimum. Clearly, this can lead to confusing debugging situations.</p>
<p>
Even if you use the Size method, a second Resize event will occur, repeating all your calculations. This can be avoided by setting a flag when you deliberately resize the control. The Resize event should check this flag, and skip all processing when it is True.</p>
<p>
A recursion flag is not necessary for simple minimum size situations, but is virtually required for more complicated scenarios.</p>
<p>
For example, if you use the code above in a control whose Align property is True, so that it aligns to the form it's placed on, as described in "Making Your Control Align to the Edges of Forms," infinite recursion errors are guaranteed, until stack space is exhausted and an error occurs.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Always use error handling in Resize event procedures. Errors here cannot be handled by the container, and your control component will therefore fail, causing the application using your control to fail, as well.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;The models for creating controls are discussed in "Three Ways to Build ActiveX Controls" earlier in this chapter.</p>
</BODY>
</HTML>
