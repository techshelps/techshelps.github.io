<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Visual Basic Collection Object</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconthevisualbasiccollectionobject"></a>The Visual Basic Collection Object</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconTheVisualBasicCollectionObjectC">
</object></p>
<p>
A collection is a way of grouping a set of related items. Collections are used in Visual Basic to keep track of many things, such as the loaded forms in your program (the Forms collection), or all the controls on a form (the Controls collection).</p>
<p>
Visual Basic provides the generic Collection class to give you the ability to define your own collections. You can create as many Collection objects — that is, instances of the Collection class — as you need. You can use Collection objects as the basis for your own collection classes and object models, as discussed in "Creating Your Own Collection Classes" and "Object Models" later in this chapter.</p>
<p>
For example, collections are a good way to keep track of multiple forms. "Multiple Document Interface (MDI) Applications" in "Creating a User Interface" discusses applications in which the user can open any number of document windows. The following code fragment shows how you might use the Add method of a collection object to keep a list of MDI child windows the user has created. This code assumes that you have a form named mdiDocument, whose MDIChild property is set to True.</p>
<pre><code>' Module-level collection in the parent MDIForm.
Public colDocuments As New Collection

' Code for creating a new MDI child document form.
Private Sub mnuFileNew()
   Dim f As New mdiDocument
   Static intDocumentNumber As Integer
   intDocumentNumber = intDocumentNumber + 1
   ' The following line creates the form.
   f.Caption = "Document" &amp; intDocumentNumber
   ' Add the object reference to the collection.
   colDocuments.Add f
   f.Show
End Sub
</code></pre>
<p>
The <code>colDocuments</code> collection acts like a subset of the built-in Forms collection, containing only instances of the form mdiDocument. The size of the collection is adjusted automatically as each new form is added. You can use For Each ... Next to iterate through the collection. If you want to give the form a key by which it can be retrieved, you can supply a text string as the second parameter of the Add method, as described later in this section.</p>
<p>
The New keyword in the declaration for the variable <code>colDocuments</code> causes a Collection object to be created the first time the variable is referred to in code. Because Collection is a class, rather than a data type, you must create an instance of it and keep a reference to that instance (object) in a variable.</p>
<p>
Like any other object, a Collection object will be destroyed when the last variable that contains a reference to it is set to Nothing or goes out of scope. All the object references it contains will be released. For this reason, the variable <code>colDocuments</code> is declared in the parent MDIForm, so that it exists throughout the life of the program.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you use a collection to keep track of forms, use the collection's Remove method to delete the object reference from the collection after you unload the form. You cannot reclaim the memory the form was using as long as a reference to the form still exists, and the reference the Collection object is holding is just as good as a reference in an object variable.</p>
<h2>What's a Collection Object Made Of?</h2>
<p>
A Collection object stores each item in a Variant. Thus the list of things you can add to a Collection object is the same as the list of things that can be stored in a Variant. This include standard data types, objects, and arrays — but not user-defined types.</p>
<p>
Variants always take up 16 bytes, no matter what's stored in them, so using a Collection object is not as efficient as using arrays. However, you never have to ReDim a Collection object, which results in much cleaner, more maintainable code. In addition, Collection objects have extremely fast look-ups by key, which arrays do not.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;To be precise, a Variant always takes up 16 bytes <i>even if the data are actually stored elsewhere.</i> For example, if you assign a string or an array to a Variant, the Variant contains a pointer to a copy of the string or array data. Only 4 bytes of the Variant is used for the pointer on 32-bit systems, and none of the data is actually inside the Variant.</p>
<p class=indent>
If you store an object, the Variant contains the object reference, just as an object variable would. As with strings and arrays, only 4 bytes of the Variant are being used.</p>
<p class=indent>
Numeric data types are stored inside the Variant. Regardless of the data type, the Variant still takes up 16 bytes.</p>
<p class=indent>
Despite the size of Variants, there will be many cases where it makes sense to use a Collection object to store all of the data types listed above. Just be aware of the tradeoff you're making: Collection objects allow you to write very clean, maintainable code — at the cost of storing items in Variants.</p>
<h2>Properties and Methods of the Collection Object</h2>
<p>
Each Collection object comes with properties and methods you can use to insert, delete, and retrieve the items in the collection.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=32%><b>Property or method</b></td>
<td class=label width=68%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=32%>Add method</td>
<td width=68%>Add items to the collection.</td>
</tr>
<tr valign=top>
<td width=32%>Count property</td>
<td width=68%>Return the number of items in the collection. Read-only.</td>
</tr>
<tr valign=top>
<td width=32%>Item method</td>
<td width=68%>Return an item, by index or by key.</td>
</tr>
<tr valign=top>
<td width=32%>Remove method</td>
<td width=68%>Delete an item from the collection, by index or by key.</td>
</tr>
</table><br>
<p>
These properties and methods provide only the most basic services for collections. For example, the Add method cannot check the type of object being added to a collection, to ensure that the collection contains only one kind of object. You can provide more robust functionality — and additional properties, methods, and events — by creating your own collection class, as described in "Creating Your Own Collection Classes" later in this chapter.</p>
<p>
The basic services of adding, deleting, and retrieving from a collection depend on keys and indexes. A <i>key</i> is String value. It could be a name, a driver's license number, a social security number, or simply an Integer converted to a String. The Add method allows you to associate a key with an item, as described later in this section.</p>
<p>
An <i>index</i> is a Long between one (1) and the number of items in the collection. You can control the initial value of an item's index, using the <b><i>before</i></b> and <b><i>after</i></b> named parameters, but its value may change as other items are added and deleted.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A collection whose index begins at 1 is called <i>one-based</i>, as explained in "Collections in Visual Basic."</p>
<p>
You can use the index to iterate over the items in a collection. For example, the following code shows two ways to give all the employees in a collection of Employee objects a 10 percent raise, assuming that the variable <code>mcolEmployees</code> contains a reference to a Collection object.</p>
<pre><code>Dim lngCt As Long
For lngCt = 1 To mcolEmployees.Count
   mcolEmployees(lngCt).Rate = _
      mcolEmployees(lngCt).Rate * 1.1
Next

Dim emp As Employee
For Each emp In mcolEmployees
   emp.Rate = emp.Rate * 1.1
Next
</code></pre>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;For better performance, use For Each to iterate over the items in a Collection object. For Each is significantly faster than iterating with the index. This is not true of all collection implementations — it's dependent on the way the collection stores data internally.</p>
<h2>Adding Items to a Collection</h2>
<p>
Use the Add method to add an item to a collection. The syntax is:</p>
<p>
<b>Sub Add</b> <b>(</b><i>item</i> <b>As Variant</b> <b>[,</b> <i>key</i> <b>As Variant] [,</b> <b><i>before</i></b> <b>As Variant]</b></p>
<p>
<b>[,</b> <b><i>after</i></b> <b>As Variant] )</b></p>
<p>
For example, to add a work order object to a collection of work orders using the work order's ID property as the key, you can write:</p>
<pre><code>colWorkOrders.Add woNew, woNew.ID
</code></pre>
<p>
This assumes that the ID property is a String. If the property is a number (for example, a Long), use the CStr function to convert it to the String value required for keys:</p>
<pre><code>colWorkOrders.Add woNew, CStr(woNew.ID)
</code></pre>
<p>
The Add method supports named arguments. To add an item as the third element, you can write:</p>
<pre><code>colWorkOrders.Add woNew, woNew.ID, after:=2
</code></pre>
<p>
You can use the <b><i>before</i></b> and <b><i>after</i></b> named arguments to maintain an ordered collection of objects. For example, <code>before:=1</code> inserts an item at the beginning of the collection, because Collection objects are one-based.</p>
<h2>Deleting Items from a Collection</h2>
<p>
Use the Remove method to delete an item from a collection. The syntax is:</p>
<p>
<i>object</i>.<b>Remove</b> <i>index</i></p>
<p>
The <i>index</i> argument can either be the position of the item you want to delete, or the item's key. If the key of the third element in a collection is "W017493," you can use either of these two statements to delete it:</p>
<pre><code>colWorkOrders.Remove 3</code></pre>
<p class=tl>
-or-</P><pre><code>colWorkOrders.Remove "W017493"
</code></pre>
<h2>Retrieving Items from a Collection</h2>
<p>
Use the Item method to retrieve specific items from a collection. The syntax is:</p>
<p>
<b>[Set] </b><i>variable</i> <b>=</b> <i>object</i>.<b>Item(</b><i>index</i><b>)</b></p>
<p>
As with the Remove method, the index can be either the position in the collection, or the item's key. Using the same example as for the Remove method, either of these statements will retrieve the third element in the collection:</p>
<pre><code>Set woCurrent = colWorkOrders.Item(3)</code></pre>
<p class=tl>
-or-</P><pre><code>Set woCurrent = colWorkOrders.Item("W017493")
</code></pre>
<p>
If you use whole numbers as keys, you must use the CStr function to convert them to strings before passing them to the Item or Remove methods. A Collection object always assumes that a whole number is an index.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Don't let Collection objects decide whether a value you're passing is an index or a key. If you want a value to be interpreted as a key, and the variable that contains the value is anything but String, use CStr to convert it. If you want a value to be interpreted as an index, and the variable that contains the value is not one of the integer data types, use CLng to convert it.</p>
<h3>Item Is the Default Method</h3>
<p>
The Item method is the default method for a Collection object, so you can omit it when you access an item in a collection. Thus the previous code example could also be written:</p>
<pre><code>Set woCurrent = colWorkOrders(3) </code></pre>
<p class=tl>
-or-</P><pre><code>Set woCurrent = colWorkOrders("W017493")
</code></pre>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Collection objects maintain their numeric index numbers automatically as you add and delete elements. The numeric index of a given element will thus change over time. Do not save a numeric index value and expect it to retrieve the same element later in your program. Use keys for this purpose.</p>
<h3>Using the Item Method to Invoke Properties and Methods</h3>
<p>
You don't have to retrieve an object reference from a collection and place it in an object variable in order to use it. You can use the reference while it's still in the collection.</p>
<p>
For example, suppose the WorkOrder object in the code above has a Priority property. The following statements will both set the priority of a work order:</p>
<pre><code>colWorkOrders.Item("W017493").Priority = 3
colWorkOrders("W017493").Priority = 3
</code></pre>
<p>
The reason this works is that Visual Basic evaluates the expression from left to right. When it comes to the Item method — explicit or implied — Visual Basic gets a reference to the indicated item (in this case, the WorkOrder object whose key is <code>W017493</code>), and uses this reference to evaluate the rest of the line.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If you're going to invoke more than one property or method of an object in a collection, copy the object reference to a strongly typed object variable first. Using an object reference while it's still in a collection is slower than using it after placing it in a strongly typed object variable (for example, <code>Dim woCurrent As WorkOrder</code>), because the Collection object stores items in Variants. Object references in Variants are always late bound.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;The Collection object is also a useful alternative to arrays for many ordinary programming tasks. See "Using Collections as an Alternative to Arrays" in "More About Programming."</p>
<p>
Visual Basic provides a number of built-in collections. To compare them with the Collection object, see "Collections in Visual Basic."</p>
</BODY>
</HTML>
