<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Passing Strings to a DLL Procedure</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconpassingstringstodllprocedure"></a>Passing Strings to a DLL Procedure</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconPassingStringsToDLLProcedureC">
</object></p>
<p>
In general, strings should be passed to APIs using ByVal. Visual Basic uses a String data type known as a BSTR, which is a data type defined by Automation (formerly called OLE Automation). A BSTR is comprised of a header, which includes information about the length of the string, and the string itself, which may include embedded nulls. A BSTR is passed as a pointer, so the DLL procedure is able to modify the string. (A <i>pointer</i> is a variable that contains the memory location of another variable, rather than the actual data.) BSTRs are Unicode, which means that each character takes two bytes. BSTRs typically end with a two-byte null character.</p>
<p class=label>
<b>Figure 1.2 The BSTR type (each box represents two bytes)</b></p>
<p>
<img src="avtac002.gif" border=0></p>
<p>
The procedures in most DLLs (and in all procedures in the Windows API) recognize LPSTR types, which are pointers to standard null-terminated C strings (also called ASCIIZ strings). LPSTRs have no prefix. The following figure shows an LPSTR that points to an ASCIIZ string.</p>
<p class=label>
<b>Figure 1.3 The LPSTR type</b></p>
<p>
<img src="avtac003.gif" border=0></p>
<p>
If a DLL procedure expects an LPSTR (a pointer to a null-terminated string) as an argument, pass the BSTR by value. Because a pointer to a BSTR is a pointer to the first data byte of a null-terminated string, it looks like an LPSTR to the DLL procedure.</p>
<p>
For example, the sndPlaySound function accepts a string that names a digitized sound (.wav) file and plays that file.</p>
<pre><code>Private Declare Function sndPlaySound Lib "winmm.dll" _
Alias "sndPlaySoundA" (ByVal lpszSoundName As String, _
ByVal uFlags As Long) As Long
</code></pre>
<p>
Because the string argument for this procedure is declared with ByVal, Visual Basic passes a BSTR that points to the first data byte:</p>
<pre><code>Dim SoundFile As String, ReturnLength As Long
SoundFile = Dir("c:\Windows\System\" &amp; "*.wav")
Result = sndPlaySound(SoundFile, 1)
</code></pre>
<p>
In general, use the ByVal keyword when passing string arguments to DLL procedures that expect LPSTR strings. If the DLL expects a pointer to an LPSTR string, pass the Visual Basic string by reference.</p>
<p>
When passing binary data to a DLL procedure, pass a variable as an array of the Byte data type, instead of a String variable. Strings<b> </b>are assumed to contain characters, and binary data may not be properly read in external procedures if passed as a String variable.</p>
<p>
If you declare a string variable without initializing it, and then pass it by value to a DLL, the string variable is passed as NULL, not as an empty string (""). To avoid confusion in your code, use the vbNullString constant to pass a NULL to an LPSTR argument.</p>
<h2>Passing Strings to DLLs that Use Automation</h2>
<p>
Some DLLs may be written specifically to work with Automation data types like BSTR, using procedures supplied by Automation.</p>
<p>
Because Visual Basic uses Automation data types as its own data types, Visual Basic arguments can be passed by reference to any DLL that expects Automation data types. Thus, if a DLL procedure expects a Visual Basic string as an argument, you do not need to declare the argument with the ByVal keyword, unless the procedure specifically needs the string passed by value.</p>
<p>
Some DLL procedures may return strings to the calling procedure. A DLL function cannot return strings unless it is written specifically for use with Automation data types. If it is, the DLL probably supplies a type library that describes the procedures. Consult the documentation for that DLL.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For information on Automation data types, see the <i>OLE 2 Programmer's Reference, </i>published by Microsoft Press.</p>
<h2>Procedures That Modify String Arguments</h2>
<p>
A DLL procedure can modify data in a string variable that it receives as an argument. However, if the changed data is longer than the original string, the procedure writes beyond the end of the string, probably corrupting other data.</p>
<p>
You can avoid this problem by making the string argument long enough so that the DLL procedure can never write past the end of it. For example, the GetWindowsDirectory procedure returns the path for the Windows directory in its first argument:</p>
<pre><code>Declare Function GetWindowsDirectory Lib "kernel32" _
Alias "GetWindowsDirectoryA" (ByVal lpBuffer As _
String, ByVal nSize As Long) As Long
</code></pre>
<p>
A safe way to call this procedure is to first use the String function to set the returned argument to at least 255 characters by filling it with null (binary zero) characters:</p>
<pre><code>Path = String(255, vbNullChar)
ReturnLength = GetWindowsDirectory(Path, Len(Path))
Path = Left(Path, ReturnLength)
</code></pre>
<p>
Another solution is to define the string as fixed length:</p>
<pre><code>Dim Path As String * 255
ReturnLength = GetWindowsDirectory(Path, Len(Path))
</code></pre>
<p>
Both of these processes have the same result: They create a fixed-length string that can contain the longest possible string the procedure might return.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Windows API DLL procedures generally do not expect string buffers longer than 255 characters. While this is true for many other libraries, always consult the documentation for the procedure.</p>
<p>
When the DLL procedure calls for a memory buffer, you can either use the appropriate data type, or use an array of the byte data type.</p>
</BODY>
</HTML>
