<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Understanding Control Lifetime and Key Events</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconwerenotinkansasanymore"></a>Understanding Control Lifetime and Key Events</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconWereNotInKansasAnymoreC">
</object></p>
<p>
Designing ActiveX controls involves a radical shift in perspective. The key events you must respond to are different — for example, your life will revolve around the Resize event — and there's no such thing as QueryUnload. But that's just the beginning.</p>
<p>
"Control Creation Terminology," earlier in this chapter, introduced the idea that a control is not a permanent fixture of a form. Indeed, design-time and run-time instances of your control will be created and destroyed constantly — when forms are opened and closed, and when you run the project.</p>
<p>
Each time an instance of your ActiveX control is created or destroyed, the UserControl object it's based on is created or destroyed, along with all of its constituent controls. ("The UserControl Object," earlier in this chapter, explains the basis of all ActiveX controls created with Visual Basic.)</p>
<p>
Consider, for example, a day in the life of the ShapeLabel control used in the step-by-step procedures in "Creating an ActiveX Control."
<ol>
<li>
The user creates an instance of ShapeLabel — by double-clicking on the Toolbox, or by opening a form on which an instance of ShapeLabel was previously placed.<br><br></li>
<li>
The constituent controls, a Shape and a Label, are created.<br><br></li>
<li>
The UserControl object is created, and the Shape and Label controls are sited on it.<br><br></li>
<li>
The UserControl_Initialize event procedure executes.<br><br></li>
<li>
The ShapeLabel control is sited on the form.<br><br></li>
<li>
If the user is placing a new ShapeLabel, the InitProperties event of the UserControl object occurs, and the control's default property values are set. If an existing form is being opened, the ReadProperties event occurs instead, and the control retrieves its saved property values.<br><br></li>
<li>
The UserControl_Resize event procedure executes, and the constituent controls are resized according to the size the user made the new control instance, or the size they were before the form was closed.<br><br></li>
<li>
The Show and Paint events occur. If there are no constituent controls, the UserControl object draws itself.<br><br></li>
<li>
The user presses f5 to run the project. Visual Basic closes the form.<br><br></li>
<li>
The UserControl object's WriteProperties event occurs, and the control's property values are saved to the in-memory copy of the .frm file.<br><br></li>
<li>
The control is unsited.<br><br></li>
<li>
The UserControl object's Terminate event occurs.<br><br></li>
<li>
The UserControl object and its constituent controls are destroyed.</li>
</ol>
<p>
And that's not the half of it. The run-time instance of the form is now created, along with a run-time instance of the ShapeLabel control. When the user closes the form and returns to design mode, the ShapeLabel is destroyed and re-created once again.</p>
<p>
The rest of this topic explains the key events in a UserControl object's life, and provides reference lists of the events you receive in several important scenarios.</p>
<h2>Key UserControl Events</h2>
<p>
The meanings of the key events in the life of a UserControl object are as follows:
<ul type=disc>
<li>
The Initialize event occurs every time an instance of your control is created or re-created. It is always the first event in a control instance's lifetime.<br><br></li>
<li>
The InitProperties event occurs only in a control instance's first incarnation, when an instance of the control is placed on a form. In this event, you set the initial values of the control's properties.<br><br></li>
<li>
The ReadProperties event occurs the second time a control instance is created, and on all subsequent re-creations. In this event, you retrieve the control instance's property values from the in-memory copy of the .frm file belonging to the form the control was placed on.<br><br></li>
<li>
The Resize event occurs every time a control instance is re-created, and every time it is resized — whether in design mode, by the developer of a form, or at run time, in code. If your UserControl object contains constituent controls, you arrange them in the event procedure for this event, thus providing your control's appearance.<br><br></li>
<li>
The Paint event occurs whenever the container tells the control to draw itself. This can occur at any time, even before the control receives its Show event — for example, if a hidden form prints itself. For user-drawn controls, the Paint event is where you draw your control's appearance.<br><br></li>
<li>
The WriteProperties event occurs when a <i>design-time</i> instance of your control is being destroyed, if at least one property value has changed. In this event, you save all the property values a developer has set for the control instance. The values are written to the in-memory copy of the .frm file.<br><br></li>
<li>
The Terminate event occurs when the control is about to be destroyed.</li>
</ul>
<p>
In addition to the events listed above, the Show and Hide events may be important to your control. Show and Hide occur as indicated in Figure 9.5.</p>
<p class=label>
<b>Figure 9.5&nbsp;&nbsp;&nbsp;Show and Hide Events</b></p>
<p>
<img src="avtcm064.gif" border=0></p>
<p>
In order to draw to the screen in Windows, any control must have a window, temporarily or permanently. Visual Basic ActiveX controls have permanent windows. Before a control has been sited on a form, its window is not on the container. The UserControl object receives Show and Hide events when the window is added and removed.</p>
<p>
While the control's window is on the form, the UserControl receives a Hide event when the control's Visible property changes to False, and a Show event when it changes to True.</p>
<p>
The UserControl object does <i>not</i> receive Hide and Show events if the form is hidden and then shown again, or if the form is minimized and then restored. The control's window remains on the form during these operations, and its Visible property doesn't change.</p>
<p>
If the control is being shown in an internet browser, a Hide event occurs when the page is moved to the history list, and a Show event occurs if the user returns to the page.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If your control is used with earlier versions of Visual Basic, the UserControl object will not receive Show and Hide events at design time. This is because earlier versions of Visual Basic did not put any visible windows on a form at design time.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;The topic "Life and Times of a UserControl Object," one of the step-by-step procedures in "Creating an ActiveX Control," demonstrates the key events in the life of a control and illustrates how often control instances are created and destroyed.</p>
<h2>The Incarnation and Reincarnation of a Control Instance</h2>
<p>
Let's follow a control instance from its placement on a form, through subsequent development sessions, until it's compiled into an application. We'll assume the control was already developed and compiled into an .ocx file, before the curtain opens.</p>
<p>
The scenarios that follow mention both Resize and Paint events. Which event you're interested in depends on the control creation model you're using, as discussed in "Three Ways to Build ActiveX Controls," earlier in this chapter.</p>
<p>
If your control provides its appearance using constituent controls, you'll use the Resize event to size the constituent controls. If you're authoring a user-drawn control, on the other hand, you can ignore the Resize event and remarks about constituent controls. User-drawn controls draw their appearance in the Paint event. This is discussed in "Drawing Your Control," later in this chapter.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In all of these scenarios, the order and number of Resize and Paint events may vary.</p>
<h3>The Control Instance is Placed on a Form</h3>
<p>
When you double-click a control's icon in the Toolbox, a design-time instance of the control is placed on the form you're designing. The following events occur in the UserControl object at the heart of the control instance:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Event</b></td>
<td class=label width=75%><b>What gets done</b></td>
</tr>
<tr valign=top>
<td width=25%>Initialize</td>
<td width=75%>Constituent controls have been created, but the control has not been sited on the form.</td>
</tr>
<tr valign=top>
<td width=25%>InitProperties</td>
<td width=75%>The control instance sets default values for its properties. The control has been sited, so the Extender and AmbientProperties objects are available. This is the only time the instance will ever get this event.</td>
</tr>
<tr valign=top>
<td width=25%>Resize, Paint</td>
<td width=75%>The control instance adjusts the size of its constituent controls, if any, according to its default property settings. A user-drawn control draws itself.</td>
</tr>
</table><br>
<p>
The developer of the form can now see the control, and set its properties in the Properties window. After the developer does this, she may press f5 to run the project.</p>
<h3>From Design Mode to Run Mode</h3>
<p>
When F5 is pressed, the control's design-time instance on the form is destroyed. When the form is loaded at run time, the control is recreated as a run-time instance.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Event</b></td>
<td class=label width=75%><b>What gets done</b></td>
</tr>
<tr valign=top>
<td width=25%>WriteProperties</td>
<td width=75%>Before the design-time instance is destroyed, it has a chance to save property values to the in-memory copy of the .frm file.</td>
</tr>
<tr valign=top>
<td width=25%>Terminate</td>
<td width=75%>Constituent controls still exist, but the design-time control instance is no longer sited on the form. It's about to be destroyed.</td>
</tr>
<tr valign=top>
<td width=25%>Initialize</td>
<td width=75%>Constituent controls have been created, but the run-time control instance has not been sited on the form.</td>
</tr>
<tr valign=top>
<td width=25%>ReadProperties</td>
<td width=75%>The control instance reads the property values that were saved in the in-memory .frm file. The control has been sited on the run-time instance of the form, so the Extender and AmbientProperties objects are available.</td>
</tr>
<tr valign=top>
<td width=25%>Resize, Paint</td>
<td width=75%>The control instance adjusts the size of its constituent controls, if any, according to its current property settings. A user-drawn control draws itself.</td>
</tr>
</table><br>
<p>
The developer tests the form by clicking the control, or taking other actions that cause the control's properties, methods, and events to be exercised.</p>
<h3>From Run Mode to Design Mode</h3>
<p>
Finally the developer closes the form and returns to design mode. The run-time instance of the control is destroyed, and a design-time instance is created:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Event</b></td>
<td class=label width=75%><b>What gets done</b></td>
</tr>
<tr valign=top>
<td width=25%>Terminate</td>
<td width=75%>The run-time instance never gets a chance to save property settings. Changes to property values while the program was running are discarded.</td>
</tr>
<tr valign=top>
<td width=25%>Initialize</td>
<td width=75%>Design-time instances of constituent controls have been created, but the design-time control instance has not been sited on the form.</td>
</tr>
<tr valign=top>
<td width=25%>ReadProperties</td>
<td width=75%>The control reads the property values that were saved in the in-memory copy of the .frm file. The control has been sited on the design-time instance of the form, so the Extender and AmbientProperties objects are available.</td>
</tr>
<tr valign=top>
<td width=25%>Resize, Paint</td>
<td width=75%>The control instance adjusts the size of its constituent controls, if any, according to its saved property settings. A user-drawn control draws itself.</td>
</tr>
</table><br>
<h3>Closing the Form</h3>
<p>
If the developer doesn't need to work on the form any more, she may close it. Or it may be quitting time, and she may close the whole project. In either case, the control instance on the form is destroyed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=25%><b>Event</b></td>
<td class=label width=75%><b>What gets done</b></td>
</tr>
<tr valign=top>
<td width=25%>WriteProperties</td>
<td width=75%>Before the design-time instance is destroyed, it has a chance to save property values to the in-memory copy of the .frm file.</td>
</tr>
<tr valign=top>
<td width=25%>Terminate</td>
<td width=75%>Constituent controls still exist, but the control instance is no longer sited on the form. It's about to be destroyed.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In all of the scenarios above, the control instance has been saving its property values to the in-memory copy of the .frm file. If the developer chooses not to save the project before closing it, those property settings will be discarded.</p>
<h3>Additional Scenarios</h3>
<p>
When the developer re-opens the project, and opens the form to work on it again, the control is reincarnated as a design-time instance. It receives Initialize, ReadProperties, Resize, Paint, and WriteProperties events.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A <i>WriteProperties</i> event? Yes, indeed. When the project is opened, Visual Basic creates an in-memory copy of the .frm file. As each control on the form is created, it gets a ReadProperties event to obtain its saved property values from the .frm file, and a WriteProperties event to write those property values to the in-memory copy of the .frm file.</p>
<h4>Compiling the Project</h4>
<p>
When the project is compiled into an application or component, Visual Basic loads all the form files invisibly, one after another, in order to write the information they contain into the compiled file. A control instance gets the Initialize, ReadProperties, and WriteProperties events. The control's property settings are compiled into the finished executable.</p>
<h4>Running the Compiled Program or Component</h4>
<p>
Whenever a user runs the installed application or component, and the form is loaded, the control receives Initialize, ReadProperties, and Resize events. When the form is unloaded, the control receives a Terminate event.</p>
<h4>Controls on World Wide Web Pages</h4>
<p>
A control on an HTML page is specified using the HTML &lt;OBJECT&gt; and &lt;/OBJECT&gt; tags. When the HTML is processed, the control is created and positioned. If the &lt;OBJECT&gt; tag includes any &lt;PARAM NAME&gt; attributes, the property values supplied with those attributes are passed to the control's ReadProperties event using the standard PropertyBag object, as discussed earlier in this topic.</p>
<p>
Once the HTML page is active, the control's property values may also be set by scripts attached to events that occur on the page.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If there are no &lt;PARAM NAME&gt; attributes other than those that set extender properties, the control may receive an InitProperties event rather than a ReadProperties event. This behavior is dependent on browser implementation, and should not be relied on.</p>
<h2>Events You Won't Get in a UserControl object</h2>
<p>
Some events you're familiar with from working with forms don't exist in a UserControl object. For example, there is no Activate or Deactivate event, because controls are not activated and deactivated the way forms are.</p>
<p>
More striking is the absence of the familiar Load, Unload, and QueryUnload events. Load and Unload simply don't fit the UserControl lifestyle; unlike a form, a control instance isn't loaded at some point after it's created — when a UserControl object's Initialize event occurs, constituent controls have already been created.</p>
<p>
The UserControl object's Initialize and ReadProperties events provide the functionality of a form's Load event. The main difference between the two is that when the Initialize event occurs, the control has not been sited on its container, so the container's Extender and AmbientProperties objects are not available. The control has been sited when ReadProperties occurs.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;ReadProperties doesn't occur the first time a control instance is placed on a container — in that case the InitProperties occurs instead.</p>
<p>
The UserControl event most like a form's Unload event is Terminate. The constituent controls still exist at this point, although you no longer have access to the container, because your control has been unsited.</p>
<p>
The WriteProperties event cannot be used as an analog of Unload, because it occurs only at design time. </p>
<p>
UserControl objects don't have QueryUnload events because controls are just parts of a form; it's not up to a control to decide whether or not the form that contains it should close. A control's duty is to destroy itself when it's told to.</p>
<h2>Events Peculiar to UserControls</h2>
<p>
The GotFocus and LostFocus events of the UserControl object notify user-drawn controls when they should show or stop showing a focus rectangle. These events should not be forwarded to the user of your control, because the container is responsible for focus events.</p>
<p>
If your UserControl has constituent controls that can receive focus, the EnterFocus event will occur when the first constituent control receives the focus, and the ExitFocus event will occur when focus leaves the last constituent control. See "How to Handle Focus in your Control," later in this chapter.</p>
<p>
If you have allowed developers to set access keys for your control, the AccessKeyPress event occurs whenever a user presses an access key. See "Allowing Developers to Set Access Keys for Your Control," later in this chapter. The AccessKeyPress event can also occur if your control is a default button or cancel button. This is discussed in "Allowing Your Control to be a Default or Cancel Button," later in this chapter.</p>
<p>
The AmbientChanged event occurs whenever an Ambient property changes on the container your control has been placed on. See "Using the AmbientProperties Object to Stay Consistent with the Container," later in this chapter.</p>
</BODY>
</HTML>
