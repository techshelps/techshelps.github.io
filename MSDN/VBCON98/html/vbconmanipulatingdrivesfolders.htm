<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Working with Drives and Folders</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconmanipulatingdrivesfolders"></a>Working with Drives and Folders</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconManipulatingDrivesFoldersC">
</object></p>
<p>
With the FSO object model you can work with drives and folders programmatically just as you can in the Windows Explorer interactively. You can copy and move folders, get information about drives and folders, and so forth.</p>
<h2>Getting Information About Drives</h2>
<p>
The Drive object allows you to gain information about the various drives attached to a system, either physically or over a network. Its properties allow you to obtain information about:
<ul type=disc>
<li>
The total size of the drive in bytes (TotalSize property)<br><br></li>
<li>
How much space is available on the drive in bytes (AvailableSpace or FreeSpace properties)<br><br></li>
<li>
What letter is assigned to the drive (DriveLetter<b> </b>property)<br><br></li>
<li>
What type of drive it is, such as removable, fixed, network, CD-ROM, or RAM disk (DriveType<b> </b>property)<br><br></li>
<li>
The drive's serial number (SerialNumber<b> </b>property)<br><br></li>
<li>
The type of file system the drive uses, such as FAT, FAT32, NTFS, and so forth (FileSystem<b> </b>property)<br><br></li>
<li>
Whether a drive is available for use (IsReady<b> </b>property)<br><br></li>
<li>
The name of the share and/or volume (ShareName<b> </b>and VolumeName<b> </b>properties)<br><br></li>
<li>
The path or root folder of the drive (Path and RootFolder properties)</li>
</ul>
<h2>Example Usage of the Drive Object</h2>
<p>
The example below shows how to use the Drive object to gather information about a drive. Remember that you won't see a reference to an actual Drive object in the following code; rather, you use the GetDrive method to get a reference to an existing Drive object (in this case, <code>drv)</code>:</p>
<pre><code>Private Sub Command3_Click()
 &nbsp; Dim fso As New FileSystemObject, drv As Drive, s As String
 &nbsp; Set drv = fso.GetDrive(fso.GetDriveName("c:"))
 &nbsp; s = "Drive " &amp; UCase("c:") &amp; " - "
 &nbsp; s = s &amp; drv.VolumeName &amp; vbCrLf
 &nbsp; s = s &amp; "Total Space: " &amp; FormatNumber(drv.TotalSize / 1024, 0)
 &nbsp; s = s &amp; " Kb" &amp; vbCrLf
 &nbsp; s = s &amp; "Free Space: " &amp; FormatNumber(drv.FreeSpace / 1024, 0)
 &nbsp; s = s &amp; " Kb" &amp; vbCrLf
 &nbsp; MsgBox s
End Sub</code></pre>
<h3>Using CurDir, ChDrive, ChDir, or App.Path</h3>
<p>
If you use the CurDir function, the ChDrive and ChDir statements, or the Path property (App.Path), be aware that they may return a UNC path (that is, \\Server\Share…) rather than a drive path (such as E:\Folder), depending on how you run your program or project.</p>
<p>
<b>App.Path</b> returns a UNC path:
<ul type=disc>
<li>
When you run a project after loading it from a network share, even if the network share is mapped to a drive letter.<br><br></li>
<li>
When you run a compiled executable file from a network share (but only if it is run using a UNC path).</li>
</ul>
<p>
ChDrive cannot handle UNC paths, and thus raises an error when App.Path returns one. You can handle this error by adding On Error Resume Next before the ChDrive statement, or by testing the first two characters of App.Path to see if they are backslashes:</p>
<pre><code>On Error Resume Next
ChDrive App.Path
ChDir App.Path
</code></pre>
<p>
This modification handles all cases in which the program is started from Windows using a UNC path (for example, in the Run dialog accessed from the Start menu), because Windows sets the current directory to a UNC path. ChDir handles changes between UNC paths correctly. (The failure of ChDrive can be ignored, because there is no drive letter for a UNC path.)</p>
<p>
However, the above code above won't work if you run the program by entering a UNC path at MS-DOS command prompt. This is because the command prompt always has a drive path for the current directory, so CurDir is set to a drive path. ChDir does not raise an error, but it fails to change the directory from a drive path to a UNC path. The only workaround for this situation is to locate a local drive that's mapped to the share specified in the UNC path, or to use network commands to create such a mapping.</p>
<p>
If the project is loaded into the Visual Basic IDE from a network share – either a UNC path or a mapped drive path – then App.Path returns a UNC path when the project is run and ChDrive fails and raises an error. ChDir doesn't raise an error, but the directory is not changed. The only workaround is to manually set the drive and directory:</p>
<pre><code>Const PROJECTSHARE = "E:\VBPROJ\MYPROJECT"
#Const Debug = True
#If Debug Then
 &nbsp;&nbsp; ChDrive PROJECTSHARE
 &nbsp;&nbsp; ChDir PROJECTSHARE
#Else
 &nbsp;&nbsp; On Error Resume Next
 &nbsp;&nbsp; ChDrive App.Path
 &nbsp;&nbsp; ChDir App.Path
#End If
</code></pre>
<p>
If more than one person might open the project on the network share, a DOS environment variable can be used to allow each person to have their own mapping for the share:</p>
<pre><code>#Const Debug = True
#If Debug Then
 &nbsp;&nbsp; ChDrive Environ("MYPROJECTDIR")
 &nbsp;&nbsp; ChDir Environ("MYPROJECTDIR")
#Else
 &nbsp;&nbsp; On Error Resume Next
 &nbsp;&nbsp; ChDrive App.Path
 &nbsp;&nbsp; ChDir App.Path
#End If
</code></pre>
<p>
The value of MYPROJECTDIR specifies the mapped drive letter and the path, for example: </p>
<pre><code>SET MYPROJECTDIR=M:\VBProj\MyProject</code></pre>
<h2>Working with Folders</h2>
<p>
This list shows common folder tasks and the methods for doing them:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=43%><b>Task</b></td>
<td class=label width=57%><b>Method</b></td>
</tr>
<tr valign=top>
<td width=43%>Create a folder</td>
<td width=57%>FileSystemObject.CreateFolder </td>
</tr>
<tr valign=top>
<td width=43%>Delete a folder</td>
<td width=57%>Folder.Delete or<br>
FileSystemObject.DeleteFolder </td>
</tr>
<tr valign=top>
<td width=43%>Move a folder</td>
<td width=57%>Folder.Move or<br>
FileSystemObject.MoveFolder </td>
</tr>
<tr valign=top>
<td width=43%>Copy a folder</td>
<td width=57%>Folder.Copy or<br>
FileSystemObject.CopyFolder </td>
</tr>
<tr valign=top>
<td width=43%>Retrieve the name of a folder</td>
<td width=57%>Folder.Name</td>
</tr>
<tr valign=top>
<td width=43%>Find out if a folder exists on a drive</td>
<td width=57%>FileSystemObject.FolderExists </td>
</tr>
<tr valign=top>
<td width=43%>Get an instance of an existing Folder object</td>
<td width=57%>FileSystemObject.GetFolder</td>
</tr>
<tr valign=top>
<td width=43%>Find out the name of a folder's parent folder</td>
<td width=57%>FileSystemObject.GetParentFolderName </td>
</tr>
<tr valign=top>
<td width=43%>Find out the path of system folders</td>
<td width=57%>FileSystemObject.GetSpecialFolder </td>
</tr>
</table><br>
<h3>Example</h3>
<p>
This example demonstrates usage of the Folder and FileSystemObject objects to manipulate folders and gain information about them:</p>
<pre><code>Private Sub Command10_Click()
 &nbsp; ' Get instance of FileSystemObject.
 &nbsp; Dim fso As New FileSystemObject, fldr As Folder, s As String
 &nbsp; ' Get Drive object.
 &nbsp; Set fldr = fso.GetFolder("c:")
 &nbsp; ' Print parent folder name.
 &nbsp; Debug.Print "Parent folder name is: " &amp; fldr
 &nbsp; ' Print drive name.
 &nbsp; Debug.Print "Contained on drive " &amp; fldr.Drive
 &nbsp; ' Print root file name.
 &nbsp; If fldr.IsRootFolder = True Then
 &nbsp;&nbsp;&nbsp;&nbsp; Debug.Print "This folder is a root folder."
 &nbsp; Else
 &nbsp;&nbsp;&nbsp;&nbsp; Debug.Print "This folder isn't a root folder."
 &nbsp; End If
 &nbsp; ' Create a new folder with the FileSystemObject object.
 &nbsp; fso.CreateFolder ("c:\Bogus")
 &nbsp; Debug.Print "Created folder C:\Bogus"
 &nbsp; ' Print the base name of the folder.
 &nbsp; Debug.Print "Basename = " &amp; fso.GetBaseName("c:\bogus")
 &nbsp; ' Get rid of the newly-created folder.
 &nbsp; fso.DeleteFolder ("c:\Bogus")
 &nbsp; Debug.Print "Deleted folder C:\Bogus"
End Sub</code></pre>
</BODY>
</HTML>
