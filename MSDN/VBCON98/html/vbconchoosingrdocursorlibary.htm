<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Choosing an RDO Cursor Libary</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconchoosingrdocursorlibary"></a>Choosing an RDO Cursor Library</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconChoosingRDOCursorLibaryC">
</object></p>
<p>
RDO supports several different cursor libraries — each with a specific purpose. While not all cursor libraries support all types of cursors, all libraries support forward-only result set management. For example, the ODBC client-side driver can only support rdOpenStatic and rdOpenForwardOnly cursor types, while the SQL Server server-side driver supports all four types.</p>
<p>
Selecting the right cursor library is important when it comes to using certain RDO functionality. For example, you must use the client batch library to create dissociate rdoResultset objects or use the BatchUpdate method. To disable creation of cursors and use forward-only, read-only, or single-row result sets, use the rdUseNone option.</p>
<p>
When creating a stand-alone rdoQuery object whose query is to be used as a method, you should set the CursorType before the query is executed because there is no option to do so when the query is executed.</p>
<p>
The value of the CursorType property is used as the <b><i>type</i></b> argument of the OpenResultset method. To choose the type of cursor driver to use, set the rdoDefaultCursorDriver property of the rdoEngine or the CursorDriver property of the rdoEnvironment or rdoConnection object. The following table describes the options available with these properties.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=31%><b>Option</b></td>
<td class=label width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=31%>rdUseODBC</td>
<td width=69%>RDO will use the ODBC cursor library. This gives better performance for small result sets, but degrades quickly for larger result sets.</td>
</tr>
<tr valign=top>
<td width=31%>rdUseServer</td>
<td width=69%>RDO uses server-side cursors if they're available.</td>
</tr>
<tr valign=top>
<td width=31%>rdUseClientBatch</td>
<td width=69%>RDO uses the client batch cursor library.</td>
</tr>
<tr valign=top>
<td width=31%>rdUseIfNeeded</td>
<td width=69%>(Default) The ODBC driver chooses the appropriate style of cursor and uses server-side cursors if available.</td>
</tr>
<tr valign=top>
<td width=31%>rdUseNone</td>
<td width=69%>RDO creates a cursorless result set.</td>
</tr>
</table><br>
<h2>Using the ODBC Cursor Library</h2>
<p>
The ODBC cursor library is the simplest of all of the libraries. It only supports static and forward-only cursors, so it is of limited appeal to many developers. It is also not particularly efficient for situations where you must create cursors of more than a few hundred rows. It is the most flexible in that it can access virtually all ODBC drivers — even those that are not fully ODBC Level II compliant.</p>
<p>
The static cursor implemented by the ODBC cursor library is simply a data dump of the selected rows copied to the workstation.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When using the ODBC cursor library, you cannot execute a stored procedure that returns solely a Binary Large Object (BLOB) data column. You can, however, execute a query that returns another column and a BLOB column using the ODBC cursor driver. This limitation does not apply to the Microsoft SQL Server server-side cursor library.</p>
<h2>Using the rdUseIfNeeded Cursor Library Option</h2>
<p>
This CursorDriver property option tells RDO to choose server-side cursors if available. Because it is the default driver option, this means that if you connect to Microsoft SQL Server, RDO chooses server-side cursors. If you connect to Oracle or other ODBC data sources, the ODBC cursor library is used.</p>
<h2>Using the Server-Side Cursor Library</h2>
<p>
If your data source supports server-side cursors and you choose the rdUseServer CursorDriver option, the remote database engine builds cursor keysets on the server and extends the SQL dialect to support creation and management of data using cursors. Microsoft SQL Server versions 6.0 and higher support server-side cursors, but not all data sources do.</p>
<p>
Server-side cursors reduce the amount of memory and disk space required on the client machines, but shift that load to the server. For SQL Server, cursor keysets are maintained in the TempDB database on the server, so it must be sized to meet the needs of additional temporary cursor keysets generated by multiple clients.</p>
<h3>Server-Side Transact SQL Cursors</h3>
<p>
Another option you might wish to consider leverages SQL Server's ability to implement server-side cursors using its own Transact SQL cursor functions. You can create a server-side cursor, position to specific rows, and perform positioned updates using these functions.</p>
<h3>Server-Side Cursors and Multiple Result Set Queries</h3>
<p>
If you submit a query that contains more than one SELECT statement to SQL Server using the server-side cursor library, the ODBC driver will reject the query because it is unable to handle this situation. If you must execute multiple result set queries or stored procedures that contain multiple SELECT statements, you have several alternatives:
<ul type=disc>
<li>
Convert the query to submit individual SELECT statements.<br><br></li>
<li>
Use the cursorless result set option enabled by setting the CursorDriver property to rdUseNone. <br><br></li>
<li>
Create a forward-only, read-only rdoResultset with the RowsetSize property of the parent rdoQuery object set to 1.<br><br></li>
<li>
Switch to the ODBC cursor library by setting the CursorDriver property to rdUseODBC.</li>
</ul>
<h2>Using the Client Batch Cursor Library</h2>
<p>
RDO 2.0 introduced the Client Batch cursor library. This library is capable of creating all four types of cursors in addition to the forward-only result set. In addition, this library is designed with Microsoft's proprietary Rushmore technology, so it is far more efficient than the ODBC cursor library. This option also enables you to create dissociate rdoResultset objects, perform offline changes to the data, and re-associate the rdoResultset with a live connection to post updates back to the database using optimistic batch updates. Even if you do not create a dissociate rdoResultset, you can still use the BatchUpdate method to submit blocks of database changes.</p>
<p>
This library also creates all cursors on the client. That is, either raw row data row images or keysets are built in on the client system.</p>
<h2>Using the rdUseNone Cursor Library Option</h2>
<p>
This CursorDriver property tells RDO to bypass creation of a cursor and create a single-row, forward-only, read-only result set.</p>
<p>
Not all queries you create need to be returned in the form of a cursor. As a matter of fact, cursors are a particularly expensive way to fetch data and are rarely used in production-class applications. If you set the rdoDefaultCursorDriver property to rdUseNone, all result sets created by your application will be created as if you used the OpenResultset method with the rdOpenForwardOnly and rdConcurReadOnly options set, and with RowsetSize set to 1. This is the most efficient result set available for many applications, as it is the simplest to implement. However, it has the least number of features — some of which your application might require. The efficiency of this technique can permit your application to forgo the luxury of a full cursor.</p>
</BODY>
</HTML>
