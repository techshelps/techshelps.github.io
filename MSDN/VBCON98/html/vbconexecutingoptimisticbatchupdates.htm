<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Executing Optimistic Batch Updates</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconexecutingoptimisticbatchupdates"></a>Executing Optimistic Batch Updates</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconExecutingOptimisticBatchUpdatesC">
</object></p>
<p>
RDO 2.0 implements a new technique to submit multiple database operations as a batch. The ODBC and SQL Server server-side cursor libraries both support multiple statement batches against data sources that support this concept. However, the individual operations are not managed by the cursor driver, so errors and other contingencies must be handled manually. In contrast, the Client Batch cursor library is designed to automatically:
<ul type=disc>
<li>
Track the status of each row in rdoResultset objects it creates. As each row is changed or deleted or new rows are added, the Status property is automatically set to reflect that the row is "dirty." By examining the row status, the Client Batch cursor library can track those rows that have been added, changed, deleted, or unchanged.<br><br></li>
<li>
Manage independent rdoResultset objects. While an rdoResultset cannot be created independently from saved local data, once a static result set is created, you can disconnect from the remote server and perform any number of changes to the rdoResultset object. You can then re-associate the rdoResultset with another connection by setting the ActiveConnection property, and use the BatchUpdate method to post the changes.<br><br></li>
<li>
Permit postponement of the update operation. Because the Client Batch cursor library is designed to operate on an entire set of rows as a batch, you can delay posting the changes to the database for as long as necessary.<br><br></li>
<li>
Build the SQL statements needed to perform the database changes. Basically, the Client Batch cursor library appends a suitable WHERE clause to each SQL statement to correctly identify specific rows by key.<br><br></li>
<li>
Manage the result of each operation and report the success or failure status back to your application.</li>
</ul>
<p>
Basically, when using a deferred update strategy as described here, you generally assume that the data involved is not subject to significant changes while the offline or deferred operations take place. If, on the other hand, the data is being constantly queried and changed, this strategy quickly breaks down. The Client Batch cursor library is designed to trap collisions that occur when unexpected update conflicts occur — as when another user changes a row that is a member of the result set being updated. When this happens, each row involved in a conflict is marked and all three copies of the data are made available to your application:
<ul type=disc>
<li>
The data as it was when first read by your application from the database.<br><br></li>
<li>
The data as it is now recorded in the database — as the other user changed it.<br><br></li>
<li>
The data which your user attempted to save.</li>
</ul>
<p>
Using these three versions of the data, it is your application's job to reconcile the differences.</p>
</BODY>
</HTML>
