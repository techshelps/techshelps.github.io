<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>When to Use Events or Call-Backs for Notifications</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconwhentouseeventsorcallbacksfornotifications"></a>When to Use Events or Call-Backs for Notifications</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconWhenToUseEventsOrCallBacksForNotificationsC">
</object></p>
<p>
The topics "Asynchronous Notifications Using Call-Back Methods" and "Asynchronous Notifications Using Events" demonstrate that call-backs are more work to implement than events. However, you should not base your decision about which to use on the amount of work involved. Call-backs and events represent different approaches to communication, and you should select the approach that best fits your needs.</p>
<p>
You can characterize the difference between events and call-backs as follows: An event is like an anonymous broadcast, while a call-back is like a handshake.</p>
<p>
The corollary of this is that a component that raises events knows nothing about its clients, while a component that makes call-backs knows a great deal.</p>
<p>
Here’s what these things mean to you as a developer:
<ul type=disc>
<li>
A client that has a reference to an object that raises events can handle those events by placing the reference into a WithEvents variable. The object that raises the events has no information about its clients. It's broadcasting to an unknown audience — perhaps to an empty theater.<p class=tl>
By contrast, a component that's making call-backs must have a reference to every object it's going to call. It has to know exactly how many of them there are.</P></li>
<li>
An object that raises events has no control over the order in which clients receive its events. (And you should take care to avoid creating dependencies on any ordering you may observe.)<p class=tl>
By contrast, a component making call-backs can control the order in which it calls clients back. It might give some clients higher priority, for example.</P></li>
<li>
When an object raises an event, all of its clients handle the event before the object that raised the event gets control again.<p class=tl>
By contrast, a component making call-backs gets control back after each call it makes to a client.</P></li>
<li>
If an event contains a ByRef argument, that argument can be altered by any client that handles the event. The last client's changes are the only ones visible to the object that raised the event, because (as noted above) the object that raised the event doesn't get control again until all of its clients have handled the event.<p class=tl>
By contrast, a component making call-backs can examine changes to ByRef arguments after every call to a client, and can pass the next client fresh values for those arguments.</P></li>
<li>
If an unhandled error occurs in a client's event handler, the object that raised the event cannot receive the error. If the object is provided by an in-process component running in the client’s address space, both client and component will terminate as a result of the unhandled error.<p class=tl>
By contrast, a component making call-backs will receive errors that occur in the call-back method, and must be prepared to handle them.</P></li>
</ul>
<p class=indent>
<B><b>Note</b></B> &nbsp; An additional difference between events and call-back methods is that events cannot have optional arguments, named arguments, or ParamArray arguments.</p>
<p>
A component can provide some notifications using call-backs, and some using events. The nature of the notification determines which mechanism should be used. You should use an event to provide a notification when all of the following statements are true:
<ol>
<li>
The notification can be broadcast anonymously.<br><br></li>
<li>
The order in which clients receive the notification is not important.<br><br></li>
<li>
There’s no need for the component to get control back until all clients have received the notification.<br><br></li>
<li>
If the notification involves ByRef arguments, there’s no need for the component to test the values of those arguments after each client receives the notification. The component only needs to know the last value assigned. (You can plan for clients to cooperate in their use of a ByRef argument — for example, once a Cancel argument is set to True, no client changes it — but there’s no way to enforce this.)<br><br></li>
<li>
The component doesn't need to know about errors that occur in the client.</li>
</ol>
<p>
If any one of the statements above is false, then you should do the extra work necessary to provide the notification using call-back methods.</p>
<p>
You may also want to do the extra work to use call-backs when performance is critical. You can get vtable binding with call-back methods by using the Implements statement to add the call-back interface to the client's call-back object. Events are not vtable bound. (This will be much more noticeable with an in-process component that provides events or call-backs.)</p>
</BODY>
</HTML>
