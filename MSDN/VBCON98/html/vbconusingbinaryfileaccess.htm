<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Binary File Access</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconusingbinaryfileaccess"></a>Using Binary File Access</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconUsingBinaryFileAccessC">
</object></p>
<p>
The File System Object model does not provide binary file creation or access methods. If you need to create or read binary files, this information will help you do so.</p>
<p>
Binary access gives you complete control over a file, because the bytes in the file can represent anything. For example, you can conserve disk space by building variable-length records. Use binary access when it is important to keep file size small.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When writing binary data to a file, use a variable that is an array of the Byte data type, instead of a String variable. Strings are assumed to contain characters, and binary data may not be properly stored in String variables.</p>
<h2>Opening a File for Binary Access</h2>
<p>
To open a file for binary access, use the following syntax for the Open statement:</p>
<p>
<b>Open</b> <i>pathname</i> <b>For Binary As</b> <i>filenumber</i></p>
<p>
As you can see, Open for binary access differs from Open for random access in that Len = <i>reclength</i> is not specified. If you include a record length in a binary-access Open statement, it is ignored.</p>
<h2>Storing Information in Variable-Length Fields</h2>
<p>
To best appreciate binary access, consider a hypothetical Employee Records file. This file uses fixed-length records and fields to store information about employees.</p>
<pre><code>Type Person
   ID               As Integer
   MonthlySalary      As Currency
   LastReviewDate      As Long
   FirstName         As String * 15
   LastName            As String * 15
   Title            As String * 15
   ReviewComments      As String * 150
End Type
</code></pre>
<p>
Regardless of the actual contents of the fields, every record in that file takes 209 bytes.</p>
<p>
You can minimize the use of disk space by using binary access. Because this doesn’t require fixed-length fields, the type declaration can omit the string length parameters.</p>
<pre><code>Type Person
   ID               As Integer
   MonthlySalary      As Currency
   LastReviewDate      As Long
   FirstName         As String
   LastName            As String
   Title            As String
   ReviewComments      As String
End Type

Public Empl As Person      ' Defines a record.
</code></pre>
<p>
Each employee record in the Employee Records file now stores only the exact number of bytes required because the fields are variable-length. The drawback to binary input/output with variable-length fields is that you can’t access records randomly — you must access records sequentially to learn the length of each record. You can seek directly to a specified byte position in a file, but there is no direct way to know which record is at which byte position if the records are of variable length.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For additional information on binary file access, see "Open Statement."</p>
</BODY>
</HTML>
