<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Choosing an RDO Cursor Type</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconchoosingrdocursortype"></a>Choosing an RDO Cursor Type</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconChoosingRDOCursorTypeC">
</object></p>
<p>
An rdoResultset object can be defined as a set of rows accessed with or without a cursor. The CursorDriver property of the rdoEnvironment or rdoConnection object determines which cursor library is used and where the cursor keyset will be created — on the client workstation or on the server. However, the <b><i>type</i></b> argument of the OpenConnection method defines <i>how</i> the cursor is built.</p>
<p>
When you chose one of the <b><i>type</i></b> argument settings, the result set is returned as one of the following types:
<ul type=disc>
<li>
Forward-only result set.<br><br></li>
<li>
Static scrollable cursor.<br><br></li>
<li>
Keyset cursor.<br><br></li>
<li>
Dynamic scrollable cursor.</li>
</ul>
<p>
Each of these result set types is built based on the type available and the capability of the ODBC interface for your data source. However, if you set the CursorDriver property to rdUseNone, RDO does not create a cursor for your rdoResultset — it always (and only) creates a forward-only, read-only, single-row, <i>cursorless</i> result set.</p>
<h2>Forward-Only Result Sets</h2>
<p>
In cases where you need to retrieve data quickly with the least amount of overhead, use a forward-only rdoResultset. This type of result set can be updatable, but it only exposes one row at a time. No cursor keyset is created, and data values are static — they are not updated as changes are made on the data source. However, because of its efficiency, it might be faster to rebuild a forward-only rdoResultset than to build and maintain a keyset-type rdoResultset.</p>
<p>
Unless you use the rdConcurReadOnly option and set the RowsetSize to 1, RDO creates a cursor to manage your forward-only result set, which can impact performance. However, if you choose rdUseNone as the cursor driver, a forward-only, read-only cursorless result set is created by default.</p>
<h2>Static Scrollable Cursors</h2>
<p>
A static-type rdoResultset is somewhat similar to a Jet snapshot-type Recordset object, except that static cursors can be updatable. This type of cursor creates a static copy of the data rows on the client or server, depending on the cursor driver chosen. Static cursor data appears to be unchanging. That is, the membership, order, and values in the result set used by a static cursor are generally fixed when the cursor is opened and fully populated. Rows updated, deleted, or inserted by other users (including other cursors in the same application) are not detected by the cursor until it is closed and reopened.</p>
<h2>Keyset Cursors</h2>
<p>
A keyset-type rdoResultset is similar to a Jet dynaset-type Recordset object. A key (basically a bookmark) is built and saved for each row in the cursor and stored either on the client workstation or on the server machine. When you access each row, the stored key is used to fetch the current data values from the data source. In a keyset-driven cursor, membership is frozen once the keyset is fully populated; therefore, additions or updates that affect membership are not made a part of the rdoResultset until it is rebuilt.</p>
<p>
On some ODBC data sources, modifications or additions made directly to keyset cursors using the AddNew and Edit methods <i>are</i> included in the result set, but additions or modifications made using Execute do not affect the cursor. Consult your server manual for details.</p>
<p>
To build a keyset-driven cursor, you must provide sufficient resources on the client or server to hold the keys and a block (based on RowsetSize) of data rows.</p>
<h3>Changing Membership When Using the AddNew Method</h3>
<p>
Although you can use the AddNew method to add a row to the database using an updatable keyset or static cursor, the new row is not always added to the rdoResultset — that is, some cursor libraries add rows to both the cursor and to the underlying table but others do not. The following table summarizes how keyset and static cursors are implemented by the various cursor libraries:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=50%><b>Cursor library</b></td>
<td class=label width=50%><b>Rows added to cursor on AddNew</b></td>
</tr>
<tr valign=top>
<td width=50%>rdUseIfNeeded (server-side)</td>
<td width=50%>Yes</td>
</tr>
<tr valign=top>
<td width=50%>rdUseODBC (ODBC)</td>
<td width=50%>No</td>
</tr>
<tr valign=top>
<td width=50%>rdUseServer (server-side)</td>
<td width=50%>Yes</td>
</tr>
<tr valign=top>
<td width=50%>rdUseClientBatch (client batch)</td>
<td width=50%>Yes</td>
</tr>
<tr valign=top>
<td width=50%>rdUseNone (no cursor)</td>
<td width=50%>Not applicable</td>
</tr>
</table><br>
<h2>Dynamic Scrollable Cursors</h2>
<p>
A dynamic-type rdoResultset is identical to a keyset-driven cursor, except that membership is not frozen and bookmarks are not supported. Because RDO constantly checks that all qualified rows are included in the membership, this type of cursor carries the largest burden of overhead. However, a dynamic cursor may be faster to initiate than a keyset cursor, because the keyset cursor carries the overhead of building the initial keyset.</p>
<p>
Generally, dynamic cursors should be avoided, as they are extremely expensive to implement and maintain — that is, this type of cursor uses a great deal of RAM and requires significant network bandwidth to maintain.</p>
<h2>Using the RowCount Property</h2>
<p>
When a keyset-type or static-type rdoResultset is first created, the RowCount property is set to:
<ul type=disc>
<li>
The number of rows in the populated result set if rows are returned.<br><br></li>
<li>
0 if no rows are returned by the query.<br><br></li>
<li>
–1 if RowCount is not available.</li>
</ul>
<p>
When your code references the RowCount property, RDO fully populates the rdoResultset before returning control to your application. RowCount is not applicable to dynamic cursors where the number of rows can change, or to forward-only result sets that only expose one row.</p>
<h2>Sequencing Operations</h2>
<p>
If there is an unpopulated rdoResultset pending on a data source that can only support a single operation on an rdoConnection object, you cannot create additional rdoQuery or rdoResultset objects or use the Refresh method on the rdoTable object until the rdoResultset is flushed, closed, or fully populated. For example, when using SQL Server 4.2 as a data source or a client-side cursor on SQL Server 6.<i>x</i>, you cannot create an additional rdoResultset object until you move to the last row of the current rdoResultset object. To populate the result set, use the MoreResults method to move through all pending result sets, or use the Cancel or Close method on the rdoResultset to flush all pending result sets. This restriction might not apply to your data source. If you need to submit a query and the hStmt is not available, you must open an additional connection.</p>
<h2>Managing RDO Concurrency</h2>
<p>
You can control how the data source and the chosen cursor library manage row and page locking while you make changes to the data by changing the <i>LockType</i> option of the OpenResultset method. The following table describes the four types of locking.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=38%><b>LockType option</b></td>
<td class=label width=62%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=38%>rdConcurLock</td>
<td width=62%>Pessimistic concurrency. This technique uses the lowest level of locking sufficient to ensure that the row can be updated.</td>
</tr>
<tr valign=top>
<td width=38%>rdConcurRowVer</td>
<td width=62%>Optimistic concurrency using row versions. The ODBC cursor library and the data source compare row ID or TIMESTAMP values to determine if the row has changed.</td>
</tr>
<tr valign=top>
<td width=38%>rdConcurValues</td>
<td width=62%>Optimistic concurrency using row values. The ODBC cursor library and the data source compare data values.</td>
</tr>
<tr valign=top>
<td width=38%>rdConcurReadOnly</td>
<td width=62%>The cursor is read-only. No changes of any kind are permitted.</td>
</tr>
<tr valign=top>
<td width=38%>rdConcurBatch</td>
<td width=62%>The client batch cursor library is being used and you wish to defer all updates until you use the BatchUpdate method.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Caution</b></B>&nbsp;&nbsp;&nbsp;The rdConcurLock option locks the entire rowset as set by the RowsetSize property. This lock is established immediately as the result set is opened — it does not wait until the Edit method has been executed. As the rowset is repositioned, the rows or pages touched by the rowset are locked and those remaining rows are released. Because of this mechanism, pessimistic locking should <i>only</i> be used in special cases.</p>
<h3>Optimistic Locking</h3>
<p>
With optimistic locking, column data values or row versions are compared to test concurrency. In this case the original row as it was prior to the Edit or AddNew method is compared with the row as it exists in the database prior to being changed by the Update method. If the row data changed in this time frame, a trappable error results. At this point, your temporary row buffer is lost. To carry out the changes, you must refresh the current row using the Move 0 technique, then use the Edit or AddNew method, fill in the new values, and repeat the Update method again.</p>
</BODY>
</HTML>
