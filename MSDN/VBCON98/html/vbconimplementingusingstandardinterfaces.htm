<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing and Using Standard Interfaces</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconimplementingusingstandardinterfaces"></a>Implementing and Using Standard Interfaces</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconImplementingUsingStandardInterfacesC">
</object></p>
<p>
Once you’ve defined a standard interface, either by creating a type library with the MkTypLib utility or by compiling a Visual Basic project containing abstract classes (that is, class modules with properties and methods that don’t contain any code), you can implement that interface in classes your components provide.</p>
<p>
Suppose you had a LateCretaceous system that included a number of components, each of which provided objects representing flora, fauna, and business rules of that era. For example, one component might provide a Velociraptor class, while another provided a Tyrannosaur class.</p>
<p>
You might create a standard interface named IPredator, which included Hunt and Attack methods:</p>
<pre><code>' Code for the abstract IPredator class module.
Public Sub Hunt()

End Sub

Public Sub Attack(ByVal Victim As IDinosaur)

End Sub
</code></pre>
<p>
Notice that the argument of the Attack method uses another interface, IDinosaur. One would expect this interface to contain methods describing general dinosaur behavior, such as laying eggs, and that it would be implemented by many classes — Velociraptor, Tyrannosaur, Brontosaur, Triceratops, and so on.</p>
<p>
Notice also that there’s no code in these methods. IPredator is an <i>abstract class</i> that simply defines the interface (referred to as an <i>abstract interface</i>). Implementation details will vary according to the object that implements the interface.</p>
<p>
For example, the Tyrannosaur class might implement IPredator as follows:</p>
<pre><code>Implements IPredator

Private Sub IPredator_Hunt()
   ' Code to stalk around the landscape roaring, until
   '&nbsp;&nbsp; you encounter a dinosaur large enough to 
   '&nbsp;&nbsp; qualify as a meal.
End Sub

Private Sub IPredator_Attack(ByVal Victim As IDinosaur)
   ' Code to charge, roaring and taking huge bites.
End Sub
</code></pre>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;As noted in "Providing Polymorphism by Implementing Interfaces," an interface is a contract. You must implement <i>all</i> of the properties and methods in the interface.</p>
<p>
By contrast, the Velociraptor class might implement IPredator as shown here:</p>
<pre><code>Implements IPredator

Private Sub IPredator_Hunt()
   ' Fan out and hunt with a pack, running down 
   '&nbsp;&nbsp; small dinosaurs or surrounding large ones.
End Sub

Private Sub IPredator_Attack(ByVal Victim As IDinosaur)
   ' Code to dart in from all sides, slashing the 
   '&nbsp;&nbsp; victim and wearing it down.
End Sub
</code></pre>
<h2>Using Implemented Interfaces</h2>
<p>
Once you have classes that implement IPredator, you can upgrade your existing applications one by one to use the new, more competitive interface. You can access the Hunt and Attack methods by assigning a Velociraptor or Tyrannosaur object to a variable of type IPredator, as shown here:</p>
<pre><code>   Dim tyr As New Tyrannosaur
   Dim prd As IPredator
   Set prd = tyr
   prd.Hunt
</code></pre>
<p>
You can also declare procedure arguments <code>As IPredator</code>, and pass the procedure any object that implements the IPredator interface, as here:</p>
<pre><code>Public Sub DevourTheCompetition(ByVal Agent As _
      IPredator, ByVal Target As IDinosaur)
   Agent.Hunt
   Agent.Attack Target
End Sub
</code></pre>
<p>
The Sub procedure shown above could be called with any predatory dinosaur as the first argument, and any dinosaur at all as the second. The caller of the procedure can use whatever predatory dinosaur is most appropriate for the occasion. This kind of flexibility is important in maintaining a business advantage.</p>
<h3>Setting References to Type Libraries</h3>
<p>
A type library containing abstract interfaces provides a reference point for both implementing and using interfaces.</p>
<p>
In order to implement an interface, you must use the References dialog box to set a reference to the type library. This is because the type library contains the information required to specify the arguments and return types of the interface’s members.</p>
<p>
In similar fashion, any application that uses objects which have implemented an abstract interface must also have a reference to the type library that describes the interface. Information about implemented interfaces cannot be included in the type libraries of components, because there is no way to resolve naming conflicts.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;In order to marshal data between processes or between remote computers, out-of-process components must include in their Setup programs any type libraries that describe abstract interfaces. In-process components should also include these type libraries, because a developer may want to pass its objects to other applications, either on the local computer or on a remote computer. See "Deploying Components," in "Debugging, Testing, and Deploying Components."</p>
<h3>Summary</h3>
<p>
The following list provides an outline for implementing multiple interfaces:
<ol>
<li>
Define a set of interfaces, each containing a small group of related properties and methods that describe a service or feature your system requires. This <i>factoring</i> process is discussed in "Providing Polymorphism by Implementing Interfaces."<br><br></li>
<li>
Create a type library containing abstract interfaces — abstract classes, if you create the type library by compiling a Visual Basic project — that specify the arguments and return types of the properties and methods. Use the MkTypLib utility or Visual Basic to generate the type library, as described in "Creating Standard Interfaces with Visual Basic."<br><br></li>
<li>
Develop a component that uses the interfaces, by adding a reference to the type library and then using the Implements statement to give classes secondary interfaces as appropriate.<br><br></li>
<li>
For every interface you’ve added to a class, select each property or method in turn, and add code to implement the functionality in a manner appropriate for that class. See "Polymorphism" in "Programming with Objects" in the <i>Visual Basic Programmer’s Guide.</i><br><br></li>
<li>
Compile the component and create a Setup program, making sure you include the type library that describes the abstract interfaces.<br><br></li>
<li>
Develop an application that uses the component by adding references to the component and to the type library that describes the abstract interfaces.<br><br></li>
<li>
Compile the application and create a Setup program, including the component (and the abstract type library, if the component runs out of process or — with the Enterprise Edition — on a remote computer).</li>
</ol>
<p>
The next section discusses how the process outlined here can be used to gradually enhance a system.</p>
<h2>Systems that Evolve Over Time</h2>
<p>
The observant reader will no doubt have noticed a bug in the code given earlier in this topic. If predatory dinosaurs only ate other dinosaurs, how did they keep the Mammals down? A more general IPredator interface might accept as a victim any object that implemented IAnimal.</p>
<p>
This illustrates a key advantage of component software development using multiple interfaces: As the LateCretaceous system evolves into, say, the Pleistocene system, components that provide predatory dinosaur objects can be replaced by components that provide SaberTooth and DireWolf objects.</p>
<p>
A legacy application compiled to use dinosaurs may be still be able to function quite nicely using the new predator classes, as long as it doesn’t include code specific to dinosaurs.</p>
<p>
The key points to remember when using multiple interfaces in this fashion are:
<ul type=disc>
<li>
Once an interface is defined and in use, it must never change. This concept of <i>interface invariance</i> is discussed in "Providing Polymorphism by Implementing Interfaces," in this chapter, and in "Polymorphism" in "Programming with Objects," in the <i>Visual Basic Programmer’s Guide</i>.<br><br></li>
<li>
If an interface needs to be expanded, create a new interface. This is discussed in "Polymorphism, Interfaces, Type Libraries, and GUIDs," earlier in this chapter.<br><br></li>
<li>
New versions of components can provide new features by implementing new and expanded interfaces.<br><br></li>
<li>
New versions of components can support legacy code by continuing to provide old interfaces.<br><br></li>
<li>
New versions of applications can take advantage of new features (that is, new and expanded interfaces), and if necessary can be written so as to degrade gracefully when only older interfaces are available. (See "Polymorphism, Interfaces, Type Libraries, and GUIDs.")</li>
</ul>
<h2>Implements and Code Reuse</h2>
<p>
The Implements statement also allows you to reuse code in existing objects. In this form of code reuse, the new object (referred to as an <i>outer object</i>) creates an instance of the existing object (or <i>inner object</i>) during its Initialize event.</p>
<p>
In addition to any abstract interfaces it implements, the outer object implements the default interface of the inner object. (To do this, use the References dialog box to add a reference to the component that provides the inner object.)</p>
<p>
When adding code to the outer object’s implementations of the properties and methods of the inner object, you can delegate to the inner object whenever the functionality it provides meets the needs of the outer object.</p>
<p>
For example, the Tyrannosaur class might implement the interface of a Dinosaur object (instead of an abstract IDinosaur interface). The Dinosaur object might have a LayEggs method, which the Tyrannosaur class could implement by simple delegation:</p>
<pre><code>Private dnoInner As Dinosaur

Private Sub Class_Initialize()
   Set dnoInner = New Dinosaur
End Sub

Private Sub Dinosaur_LayEggs()
   ' Delegate to the inner object.
   dnoInner.LayEggs
End Sub
</code></pre>
<p>
This is an extremely powerful and flexible way to reuse code, because the outer object can choose to execute its own code before, after, or instead of delegating to the inner object.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;Code reuse with the Implements statement is discussed in more detail in "Polymorphism," in "Programming with Objects," in the <i>Visual Basic Programmer’s Guide</i>.</p>
</BODY>
</HTML>
