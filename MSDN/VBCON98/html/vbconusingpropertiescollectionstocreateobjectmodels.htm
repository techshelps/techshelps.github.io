<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Properties and Collections to Create Object Models</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconusingpropertiescollectionstocreateobjectmodels"></a>Using Properties and Collections to Create Object Models</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconUsingPropertiesCollectionsToCreateObjectModelsC">
</object></p>
<p>
Objects in a hierarchy are linked together by <i>object properties</i>, that is, properties that return references to objects. An object that contains other objects will have properties that return either references to the objects themselves, or references to collections of objects.</p>
<p>
For example, consider a Bicycle object that contains two Wheel objects; each Wheel object might in turn contain a Rim object and a collection of Spoke objects.Figure 6.6 shows a possible object model for the externally creatable Bicycle object and its dependent objects.</p>
<p class=label>
<b>Figure 6.6&nbsp;&nbsp;&nbsp;An externally creatable object with a hierarchy of dependent objects</b></p>
<p>
<img src="avtcm078.gif" border=0></p>
<p>
The Bicycle object would have a Frame property that returned a reference to its Frame object. The Frame object would have a FrontWheel and BackWheel property, each of which would return a Wheel object. The Wheel object would have a Spokes property that would return a Spokes collection object. The Spokes collection would contain the Spoke objects.</p>
<p>
You may also have dependent objects that are used internally by classes in your component, and which you do not want to provide to users of your component. You can set the Instancing properties of the class modules that define these objects to Private, so they won’t appear when users browse your type library.</p>
<p>
For example, both the Frame and Wheel objects might have collections of Bearing objects, but there may be no reason to expose the Bearings object, or the collections containing it, for manipulation by client applications.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;In order to keep the Bearings property from appearing in the type library, you must declare it using the Friend keyword, as described in "Private Communications Between Your Objects," earlier in this chapter.</p>
<h2>The Simple Way to Link Dependent Objects</h2>
<p>
Frequently it makes sense for a complex object to have only one instance of a dependent object. For example, a Bicycle object only needs one Frame object. In this case, you can implement the linkage as a simple property of the complex object:</p>
<pre><code>Private mFrame As Frame

Public Property Get Frame() As Frame
   Set Frame = mFrame
End Property

Private Sub Class_Initialize()
   ' Create the Frame when the Bicycle is initialized.
   Set mFrame = New Frame
End Sub
</code></pre>
<p>
It’s important to implement such properties as shown above, using a read-only property procedure, rather than simply declaring a public module-level variable, as shown below.</p>
<pre><code>Public Frame As Frame      'Bad idea.
</code></pre>
<p>
With the second implementation, a user of your component might set the Frame property to Nothing. If there are no other references to the Frame object, it will be destroyed. The effect of this on the Bicycle object is left to the reader’s imagination.</p>
<h3>Linking a Fixed Number of Objects</h3>
<p>
Even when a complex object contains more than one instance of a dependent object, it may make more sense to implement the linkage with properties instead of with a collection. For example, a Bicycle object always has two wheels:</p>
<pre><code>' Create the Wheel objects on demand (As New), instead
'&nbsp;&nbsp; of in the Bicycle object's Initialize event.
Private mwhlFront As New Wheel
Private mwhlRear As New Wheel

Public Property Get FrontWheel() As Wheel
   Set FrontWheel = mwhlFront
End Property

Public Property Get RearWheel() As Wheel
   Set RearWheel = mwhlRear
End Property
</code></pre>
<h2>Using Collections in Your Object Model</h2>
<p>
When the relationship between two objects in a hierarchy is such that the first object contains an indeterminate number of the second, the easiest way to implement the link is with a collection. A <i>collection</i> is an object that contains a set of related objects.</p>
<p>
For example, the linkage between the FrontWheel object and its Spoke objects in Figure 6.6 is a <i>collection class</i>. A collection class is a class module that exists solely to group all the objects of another class. In this case, the collection class is named Spokes, the plural of the name of the class of objects it contains. (See "What’s In a Name?", earlier in this chapter, for more information on naming classes.)</p>
<p>
Implementing this part of the object model example requires three class modules. From the bottom up, these are:
<ul type=disc>
<li>
The Spoke class module, which defines the properties and methods of a single spoke.<br><br></li>
<li>
The Spokes class module, which defines a collection object to contain Spoke objects.<br><br></li>
<li>
The Wheel class module, which defines an entire wheel, with a collection of spokes.</li>
</ul>
<h3>Dependent Class: Spoke</h3>
<p>
The Spoke class module is the simplest of the three. It could consist of as little as two Public variables, as in the following code fragment:</p>
<pre><code>' Properties for Spoke
Public PartNumber As Integer
Public Alloy As Integer
</code></pre>
<p>
The Instancing property of the Spoke class is set to PublicNotCreatable. The <i>only</i> way for a client application to create a Spoke object is with the Add method of the Spokes collection, as discussed in the next section.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;This is not a very robust implementation. In practice you would probably implement both of these properties as Property procedures, with code to validate the values that are assigned to them.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For details on using Property procedures, see "Programming with Objects," in the <i>Visual Basic Programmer’s Guide</i>.</p>
<h3>Dependent Collection Class: Spokes</h3>
<p>
The Spokes class module is the template for a collection Spoke objects. It contains a Private variable declared as a Collection object:</p>
<pre><code>Private mcolSpokes As Collection
</code></pre>
<p>
The collection object is created in the Initialize method for the class:</p>
<pre><code>Private Sub Class_Initialize()
   Set mcolSpokes = New Collection
End Sub
</code></pre>
<p>
The methods of the Spokes class module <i>delegate</i> to the default methods of the Visual Basic Collection object. That is, the actual work is done by the methods of the Collection object. The Spokes class might include the following properties and methods:</p>
<pre><code>' Read-only Count property.
Public Property Get Count() As Integer
   Count = mcolSpokes.Count
End Property

' Add method for creating new Spoke objects.
Public Function Add(ByVal PartNumber As Integer, _
               ByVal Alloy As Integer)
   Dim spkNew As New Spoke
   spkNew.PartNumber = PartNumber
   spkNew.Alloy = Alloy
   mcolSpokes.Add spkNew
   Set Add = spkNew
End Function
</code></pre>
<p>
As with the Spoke class, the Instancing property of the Spokes class is set to PublicNotCreatable. The only way to get a Spokes collection object is as part of a Wheel object, as shown in the following section describing the Wheel class.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;See "Object Models" in "Programming with Objects" in the <i>Visual Basic Programmer’s Guide</i> for a discussion of collections, including a more detailed explanation of delegation, a list of methods you need to implement, and instructions for creating a collection that works with For Each.</p>
<h3>Externally Creatable Class: Wheel</h3>
<p>
The Wheel class module has Instancing set to MultiUse, so that any client application can create a Wheel object. The Wheel class module contains a Private variable of the Spokes class:</p>
<pre><code>' Create the Spokes collection object on demand.
Private mSpokes As New Spokes

Public Property Get Spokes() As Spokes
   Set Spokes = mSpokes
End Property
</code></pre>
<p>
Every Wheel object a client creates will have its own Spokes collection. The collection is protected against accidentally being set to Nothing by making it a read-only property (Property Get). A developer can access the methods and properties of the Spokes collection as shown in the following code fragment:</p>
<pre><code>Dim whl As Wheel
Dim spk As Spoke
Set whl = New Wheel
Set spk = whl.Spokes.Add PartNumber:=3222223, Alloy:=7
' Call a method of the Spoke object.
spk.Adjust
MsgBox whl.Spokes.Count      ' Displays 1 (one item).
</code></pre>
<p>
The Add method is used to create a new spoke in the Spokes collection of the Wheel object. The Add method returns a reference to the new Spoke object, so that its properties and methods can be called. A spoke can only be created as a member of the Spokes collection.</p>
<p>
The difference between the Wheel object, which can be created by any client, and its dependent objects is the value of the Instancing properties of the classes.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;The Spokes object is created on demand, while the Collection object <code>mcolSpokes</code> was explicitly created. "Programming with Objects" in the <i>Visual Basic Programmer’s Guide</i> discusses the use of As New for creating variables on demand, including performance implications.</p>
<h2>Considerations for Linking Objects in an Object Model</h2>
<p>
Generally speaking, a simpler implementation will be faster. Accessing an item in a collection involves a series of nested references and function calls. Whenever you know that there will always be a fixed number of a dependent object type, you can implement the linkage as a property.</p>
<p>
Regardless of how the object model is linked, the key difference between externally creatable objects and dependent objects is the value of the Instancing property of the class module. An object that can be created by other applications will have its Instancing property set to any value except Private or PublicNotCreatable.</p>
<p>
All dependent objects, whether they are contained in other dependent objects or in objects that can be created by other applications, will have their Instancing properties set to PublicNotCreatable.</p>
<h4>Using Externally Creatable Objects as Dependent Objects</h4>
<p>
At times you may want to use objects in both ways. That is, you may want the user to be able to create a Widget object independent of the object model, while at the same time providing a Widgets collection as a property of the Mechanism object.</p>
<p>
In fact, you may even want to allow the user to create independent instances of the Widgets collection, to move independent Widgets into and out of any Widgets collection, and to copy or move Widgets between collections.</p>
<p>
You can make the objects externally creatable by setting the Instancing property of the Widget class and the Widgets collection class to MultiUse.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;If the Widget object can be created directly by client applications, you cannot depend on all Widget objects getting initialized by the code in the Add method of the Widgets collection. Objects that will be both creatable and dependent should be designed to require no initialization beyond their Initialize events.</p>
<p>
Allowing free movement of Widgets requires implementation of Insert, Copy, and Move methods for your collection. Insert and Move are fairly straightforward, because moving or inserting a reference to an object is as good as moving the object. Implementing Copy, however, requires more work.</p>
<p>
This is because client application never actually has the object in its possession. All the client application has is a reference to an object the component has created on its behalf. Thus, when you implement Copy, you must create a duplicate object, including duplicates of any dependent objects it contains.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;See "Dealing with Circular References" for a discussion of problems that may arise when linking objects together. See "ActiveX Component Standards and Guidelines" for more information on object models.</p>
</BODY>
</HTML>
