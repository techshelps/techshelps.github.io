<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Three Ways to Build ActiveX Controls</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconthreewaystobuildactivexcontrols"></a>Three Ways to Build ActiveX Controls</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconThreeWaysToBuildActiveXControlsC">
</object></p>
<p>
There are three models for control creation in Visual Basic. You can:
<ul type=disc>
<li>
Author your own control from scratch.<br><br></li>
<li>
Enhance a single existing control.<br><br></li>
<li>
Assemble a new control from several existing controls.</li>
</ul>
<p>
The second and third models are similar, because in both cases you put constituent controls on a UserControl object. However, each of these models has its own special requirements.</p>
<h2>Authoring a User-Drawn Control</h2>
<p>
Writing a control from scratch allows you to do anything you want with your control's appearance and interface. You simply put code into the Paint event to draw your control. If your control's appearance changes when it's clicked, your code does the drawing.</p>
<p>
This is the model you should select if you're creating a new visual widget, such as a button that crumbles to dust and disappears when clicked.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;Creating a user-drawn control is discussed further in "Drawing Your Control," later in this chapter.</p>
<h2>Enhancing an Existing Control</h2>
<p>
Enhancing an existing control means putting an instance of the control on a UserControl designer and adding your own properties, methods, and events.</p>
<p>
You have complete freedom in specifying the interface for your enhanced control. The properties, methods, and events of the control you start with will only be included in your interface if you decide to expose them.</p>
<p>
"Exposing Properties of Constituent Controls," later in this chapter, describes how to do this manually, and how to make it easier by using the ActiveX Control Interface Wizard.</p>
<p>
Enhancing the appearance of an existing control is more difficult than enhancing the interface, because the control you're enhancing already contains code to paint itself, and its paint behavior may depend on Windows messages or other events.</p>
<p>
Experienced Windows programmers can subclass the constituent control using the AddressOf operator described in "Using the Windows API," in the <i>Component Tools Guide</i>. This allows some control over the control's appearance, but there is no way to alter the control's paint code.</p>
<p>
It's easier to work with the control's built-in paint behavior, and instead enhance it by adding properties, methods, and events, or by intercepting and altering existing properties and methods. This is discussed further in "Drawing Your Control," later in this chapter.</p>
<h2>Assembling a Control from Several Existing Controls</h2>
<p>
You can construct your control's appearance and interface quickly by assembling existing controls on a UserControl designer.</p>
<p>
For example, the ShapeLabel control provided in the CtlPlus.vbg sample application, and discussed in the step-by-step procedures in "Creating an ActiveX Control," uses a Shape control to provide its visual background and a Label control to display its caption.</p>
<p>
Figures 9.3 and 9.4 show how multiple constituent controls can contribute to the appearance and interface of an ActiveX control.</p>
<p class=label>
<b>Figure 9.3&nbsp;&nbsp;&nbsp;Constituent controls provide ShapeLabel's appearance</b></p>
<p>
<img src="avtcm038.gif" border=0></p>
<p>
Constituent controls contribute to the appearance of an instance of your control by their mere presence on the UserControl designer. They contribute to your control's interface by <i>delegation, </i>as shown in Figure 9.4.</p>
<p class=label>
<b>Figure 9.4&nbsp;&nbsp;&nbsp;Constituent controls contribute to ShapeLabel's interface</b></p>
<p>
<img src="avtcm037.gif" border=0></p>
<p>
For example, ShapeLabel's Caption property delegates to the Caption property of the constituent control <code>lblCaption</code> as shown in the following code fragment.</p>
<pre><code>Public Property Get Caption() As String
   Caption = lblCaption.Caption
End Property

Public Property Let Caption(NewCaption As String)
   lblCaption.Caption = NewCaption
   PropertyChanged "Caption"
End Property
</code></pre>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;"Drawing Your Control" and "Exposing Properties of Constituent Controls," later in this chapter, discuss control assemblies in more depth. The purpose and importance of PropertyChanged are discussed in "Adding Properties to Controls," later in this chapter.</p>
</BODY>
</HTML>
