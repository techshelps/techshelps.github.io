<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Performing an Action Query</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconperformingactionquery"></a>Performing an Action Query</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconPerformingActionQuery_C">
</object></p>
<h2>RDO</h2>
<p>
In case your application needs to manipulate tables directly, or perform a maintenance operation (like SQL Server’s DBCC functions), you can use the Execute method to run the query directly. In this case, you don’t need ODBC or SQL Server to create a temporary SP to run the query as it’s only being done once. (If this were a regular operation, it would be more efficient to create an SP to do it.) Note that you can use the RowsAffected property to find out the number of rows affected by this query.</p>
<pre><code>Private Sub ExecuteButton_Click()
 &nbsp; sql = "Begin Transaction " _
 &nbsp;&nbsp; &amp; " Update Authors " _
 &nbsp;&nbsp; &amp; " set Year_Born = 1900 where year_born is null" _
 &nbsp;&nbsp; &amp; " rollback transaction"
 &nbsp; Screen.MousePointer = vbHourglass
 &nbsp; cn.Execute sql, rdExecDirect
 &nbsp; ShowRows = cn.RowsAffected
 &nbsp; Screen.MousePointer = vbDefault
End Sub
</code></pre>
<h2>ADO</h2>
<p>
When you need to perform an action query, you can take advantage of the Execute method in ADO. In this case, you have to set a few more properties than you do in RDO, but these properties improve data access performance. This is because ADO doesn’t have to poll the server to determine what to do, or how to handle the query. Note that the new <i>output</i> argument for the Execute method returns the number of rows affected. Generally, you don’t see Visual Basic using arguments passed <i>back</i> to the application; just arguments passed <i>to</i> the object interface.</p>
<pre><code>Private Sub ExecuteButton_Click()
 &nbsp; Dim Qy As New ADODB.Command
 &nbsp; Dim Rows As Long
 &nbsp; sql = "Begin Transaction " _
 &nbsp;&nbsp; &amp; " Update Authors " _
 &nbsp;&nbsp; &amp; " set Year_Born = 1900 where year_born is null" _
 &nbsp;&nbsp; &amp; " rollback transaction"
 &nbsp; Qy.ActiveConnection = cn
 &nbsp; Qy.CommandText = sql
 &nbsp; Qy.CommandType = adCmdText
 &nbsp; Qy.Execute Rows
 &nbsp; MsgBox Rows &amp; " rows would have been affected", vbInformation
End Sub
</code></pre>
</BODY>
</HTML>
