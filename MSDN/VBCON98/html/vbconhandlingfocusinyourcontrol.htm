<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Handle Focus in Your Control</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconhandlingfocusinyourcontrol"></a>How to Handle Focus in Your Control</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconHandlingFocusInYourControlC">
</object></p>
<p>
The way you handle focus for your control depends on which model you're using to develop your control. Models for building ActiveX controls are discussed in "Three Ways to Build ActiveX Controls," earlier in this chapter.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;If you're authoring a control that can be a container for other controls, as described in "Allowing Developers to Put Controls on Your Control," note that the material in this topic <i>does not apply</i> to controls a developer places on an instance of your control. These <i>contained controls</i> will receive focus independent of your control and its constituent controls.</p>
<h3>User-Drawn Controls</h3>
<p>
If you're authoring a user-drawn control, there won't be any constituent controls on your UserControl. If you don't want your control to be able to receive the focus, set the CanGetFocus property of the UserControl object to False. CanGetFocus is True by default.</p>
<p>
If your user-drawn control can receive the focus, the UserControl object will receive GotFocus and LostFocus events when your control receives and loses the focus. A user-drawn control is responsible for drawing its own focus rectangle when it has the focus, as described in "User-Drawn Controls," in this chapter.</p>
<p>
This is the only function your UserControl's GotFocus and LostFocus events need to fulfill for a user-drawn control. You don't need to raise GotFocus or LostFocus events for the user of your control, because the container's extender provides these events if the CanGetFocus property is True.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The UserControl object of a user-drawn control will also receive a EnterFocus event prior to GotFocus, and an ExitFocus event after LostFocus. You don't need to put any code in the event procedures of these event, and in fact it is recommended that you not do so.</p>
<p>
User-drawn controls can respond to access keys, as described later in this topic.</p>
<h3>Controls That Use Constituent Controls</h3>
<p>
If you're authoring a control that enhances a single constituent control, or is an assembly of constituent controls, your UserControl object will be unable to receive the focus, regardless of the setting of the CanGetFocus property, unless <i>none </i>of its constituent controls can receive the focus.</p>
<p>
If no constituent controls can receive the focus, and CanGetFocus is True, then your UserControl object will receive the same events a user-drawn control receives. The only thing you need to do with these events is provide a visual indication that your control has the focus.</p>
<h4>How Constituent Controls Are Affected by CanGetFocus</h4>
<p>
If your control contains at least one constituent control that can receive the focus, the CanGetFocus property of the UserControl object must be set to True. If you attempt to set CanGetFocus to False on a UserControl that has constituent controls that can receive focus, an error will occur.</p>
<p>
Visual Basic will not allow a constituent control that can receive focus to be placed on a UserControl whose CanGetFocus property is False: Icons of controls that can receive focus are disabled in the Toolbox when the UserControl's design window is active.</p>
<h4>EnterFocus and ExitFocus</h4>
<p>
When the focus moves from outside your control to any of your control's constituent controls, the UserControl object will receive an EnterFocus event. The GotFocus event for the constituent control that receives the focus will be raised <i>after</i> the UserControl_EnterFocus event procedure.</p>
<p>
As long as the focus remains within your control, the UserControl object's focus-related events will not be raised. As the focus moves from one constituent control to another, however, the appropriate GotFocus and LostFocus events of the constituent controls will be raised.</p>
<p>
When the focus moves back outside your control, the last constituent control that had the focus will receive its LostFocus event. When the event procedure returns, the UserControl object will receive its ExitFocus event.</p>
<p>
You can use the EnterFocus event to change which constituent control receives the focus. You may wish to do this in order to restore the focus to the constituent control that last had it, rather than simply allowing the first constituent control in your UserControl's tab order to receive the focus, which is the default behavior.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If your control is complex — as for example an Address control with multiple constituent controls — you may be tempted to validate the data in the ExitFocus event. Don't. The user of your control can put code in the Validate event of the user control to handle data validation as they see fit. If it's absolutely necessary to validate data inside the control, use the Validate events in combination with the CausesValidation properties of the constituent controls. Be aware that you can't always count on the Validate event for constituent controls, as is discussed in "Handling the Validate Event" below.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Generally speaking, it's not a good idea to use MsgBox when you're debugging focus-related events, because the message box immediately grabs the focus. It's a <i>very</i> bad idea to use MsgBox in EnterFocus and ExitFocus events. Use Debug.Print instead.</p>
<h3>Receiving Focus via Access Keys</h3>
<p>
Avoid hard coding access keys for your control's constituent controls, because access keys permanently assigned to your control in this fashion will limit a user's freedom to choose access keys for her form. In addition, two instances of your control on the same form will have access key conflicts.</p>
<p>
"Allowing Developers to Set Access Keys for Your Control," later in this chapter, discusses how you can give the user of your control the ability to set access keys on instances of your control.</p>
<h4>Forwarding Focus to the Next Control in the Tab Order</h4>
<p>
If your control cannot receive the focus itself, and has no constituent controls that can receive the focus, you can give your control the same behavior displayed by Label controls. That is, when the access key for your control is pressed, the focus is forwarded to the next control in the tab order.</p>
<p>
To enable this behavior, set the ForwardFocus property of the UserControl object to True.</p>
<h4>Handling the Validate Event</h4>
<p>
The Validate event and CausesValidation property for a user control behave exactly like they do for any other control, but the behavior of Validate and CausesValidation for constituent controls may not yield the expected results. Let's review the standard behavior. When a control loses focus, its Validation event is fired before its LostFocus event — but only if the control about to receive the focus has its CausesValidation property set to True. This allows you to handle data validation before the control loses focus.</p>
<p>
A user control exposes a Validate event and, via the Extender object, exposes a CausesValidation property. Code in the Validate event is executed when the focus is shifted from the user control to any control that had its CausesValidation property set to True; setting the CausesValidation property of the user control to True will enable the Validation event for any control passing focus to the user control.</p>
<p>
The Validate event and CausesValidation property for constituent controls work as expected as long as the focus remains inside the user control. When the focus is shifted outside of the user control, the Validate event for the constituent control isn't fired. For that reason, it's best to avoid trying to handle validation within a user control.</p>
</BODY>
</HTML>
