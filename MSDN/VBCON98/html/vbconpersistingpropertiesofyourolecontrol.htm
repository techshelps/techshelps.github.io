<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Saving the Properties of Your Control</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconpersistingpropertiesofyourolecontrol"></a>Saving the Properties of Your Control</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconPersistingPropertiesOfYourOLEControlC">
</object></p>
<p>
As discussed in "Understanding Control Lifetime and Key Events," earlier in this chapter, instances of controls are continually being created and destroyed — when form designers are opened and closed, when projects are opened and closed, when projects are put into run mode, and so on.</p>
<p>
How does a property of a control instance — for example, the Caption property of a Label control — get preserved through all this destruction and re-creation? Visual Basic stores the property values of a control instance in the file belonging to the container the control instance is placed on; .frm/.frx files for forms, .dob/.dox files for UserDocument objects, .ctl/.ctx files for UserControls, and .pag/.pgx files for property pages. Figure 9.13 illustrates this.</p>
<p class=label>
<b>Figure 9.13&nbsp;&nbsp;&nbsp;An .frm file contains saved control properties</b></p>
<p>
<img src="avtcm050.gif" border=0></p>
<p>
When you author a control, you must include code to save your property values before a control instance is destroyed, and read them back in when the control instance is re-created. This is illustrated in Figure 9.14.</p>
<p class=label>
<b>Figure 9.14&nbsp;&nbsp;&nbsp;Saving and retrieving property values</b></p>
<p>
<img src="avtcm048.gif" border=0></p>
<p>
Figure 9.14 is slightly oversimplified. You don't actually have to close a form to cause the WriteProperties event procedures of control instances to be executed. Saving a form file to disk causes WriteProperties events to be raised for all controls on the form.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;This topic explains the mechanism for saving and retrieving property values in code, but you won't normally have to write all the code described here. The ActiveX Control Interface Wizard can generate most of the code to save and retrieve your property values.</p>
<p class=indent>
</p>
<h2>Saving Property Values</h2>
<p>
Use the PropertyBag object to save and retrieve property values. The PropertyBag is provided as a standard interface for saving property values, independent of the data format the container uses to save its source data.</p>
<p>
The following code example uses the Masked property, a Boolean property described in the related topic "Adding Properties to Controls."</p>
<pre><code>Private Sub UserControl_WriteProperties(PropBag As _
      PropertyBag)
   ' Save the value of the Boolean Masked property.
   PropBag.WriteProperty "Masked", Masked, False
   ' . . . more properties . . .
End Sub
</code></pre>
<p>
The WriteProperty method of the PropertyBag object takes three arguments. First is a string that identifies the property being saved, followed by value to be saved — usually supplied by accessing the property, as shown above.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If the value you're saving is contained in the default property of a constituent control, and that property is of type Variant — for example, the Text property of a text box — you must specify the property name. That is, you must use <code>Text1.Text</code> instead of just <code>Text1</code>.</p>
<p>
The last parameter is the default value for the property. In this case, the keyword False is supplied. Typically, you would create a global constant, such as PROPDEFAULT_MASKED, to contain this value, because you need to supply it in three different places, in the WriteProperties, ReadProperties, and InitProperties event procedures.</p>
<h3>The Importance of Supplying Defaults</h3>
<p>
It may seem strange, at first, to be supplying a default property value when you're <i>saving </i>the value of a property. This is a courtesy to the user of your control, because it reduces the size of the .frm, .dob, .pag, or .ctl file belonging to the container of the control.</p>
<p>
Visual Basic achieves this economy by writing out a line for the property only if the value is <i>different </i>from the default. Assuming that the default value of the Masked property is False, the WriteProperty method will write a line for the property only if the user has set it to True.</p>
<p>
You can easily see how this technique reduces the size of .frm files by opening a new Standard EXE project, adding a CommandButton to Form1, and saving Form1.frm. Use a text editor such as Notepad or Wordpad to open Form1.frm, and compare the number of properties that were written to the file for Command1 to the number of properties in the Properties window for Command1.</p>
<p>
Wherever possible, you should specify default values for the properties of your control when initializing, saving, and retrieving property values.</p>
<h2>Retrieving Property Values</h2>
<p>
Property values are retrieved in the ReadProperties event of the UserControl object, as shown below.</p>
<pre><code>Private Sub UserControl_ReadProperties(PropBag As _
      PropertyBag)
   On Error Resume Next
   ' Retrieve the value of the Masked property.
   Masked = PropBag.ReadProperty("Masked", False)
   ' . . . more properties . . .
End Sub
</code></pre>
<p>
The ReadProperty method of the PropertyBag object takes two arguments: a string containing the name of the property, and a default value.</p>
<p>
The ReadProperty method returns the saved property value, if there is one, or the default value if there is not. Assign the return value of the ReadProperty method to the property, as shown above, so that validation code in the Property Let statement is executed.</p>
<p>
If you bypass the Property Let by assigning the property value directly to the private data member or constituent control property that stores the property value while your control is running, you will have to duplicate that validation code in the ReadProperties event.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Always include error trapping in the UserControl_ReadProperties event procedure, to protect your control from invalid property values that may have been entered by users editing the .frm file with text editors.</p>
<h4>Properties that are Read-Only at Run Time</h4>
<p>
If you create a property the user can set at design time, but which is read-only at run-time, you have a small problem in the ReadProperties event. You have to set the property value <i>once</i> at run time, to the value the user selected at design time.</p>
<p>
An obvious way to solve this is to bypass the Property Let, but then you have no protection against invalid property values loaded from source files at design time. The correct solution to this problem is discussed in "Creating Design-Time-Only, Run-Time-Only, or Read-Only Run-Time Properties."</p>
<h2>Initializing Property Values</h2>
<p>
You can assign the initial value of a property in the InitProperties event of the UserControl object. InitProperties occurs only once for each control instance, when the instance is first placed on a container.</p>
<p>
Thereafter, as the control instance is destroyed and re-created for form closing and opening, project unloading and loading, running the project, and so on, the control instance will only receive ReadProperties events. This is discussed in "Understanding Control Lifetime and Key Events," earlier in this chapter.</p>
<p>
Be sure to initialize each property with the same default value you use when you save and retrieve the property value. Otherwise you will lose the benefits that defaults provide to your user, described in "The Importance of Supplying Defaults," earlier in this topic.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;The easiest way to ensure consistent use of default property values is to create global constants for them.</p>
<h2>Saving and Retrieving Binary Data</h2>
<p>
Except for standard objects, such as Picture, the ReadProperty and WriteProperty methods have only limited ability to store and retrieve binary data. Storing binary data in strings is problematic because of Unicode conversion and line length limitations in the .frm file, but the two methods will accept arrays of type Byte.</p>
<p>
If you're already keeping the data for a property in a Byte array, you can save it by passing the Byte array to the Value argument of the WriteProperty method:</p>
<pre><code>' Private storage for the Blob property.
Private mbytBlob(0 To 1023) As Byte

Private Sub UserControl_WriteProperties(PropBag As _
      PropertyBag)
   ' Save the binary data for the Blob property.
   PropBag.WriteProperty "Blob", mbytBlob
   ' . . . more properties . . .
End Sub
</code></pre>
<p>
The data will be saved in the .frx file. When retrieving the data, assign the return value from the ReadProperty method to <code>mbytBlob</code>. If <code>mbytBlob</code> is of variable length, you must save its size as a separate entry, using a name such as "BlobSize," so that you can retrieve the size and ReDim the array before retrieving the data. (You do not need to have a BlobSize property in order to do this.)</p>
<p>
You can also use this technique to store any binary property data that you can manage to copy to a Byte array.</p>
</BODY>
</HTML>
