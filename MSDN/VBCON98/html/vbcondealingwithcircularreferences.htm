<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Dealing with Circular References</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbcondealingwithcircularreferences"></a>Dealing with Circular References</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconDealingWithCircularReferencesC">
</object></p>
<p>
Containment relationships allow you to navigate through a hierarchy from a high-level object to any of the objects it contains.</p>
<p>
Object models that strictly express containment are like trees. Any given branch (object) may divide into smaller branches (dependent objects), but the smaller branches do not loop around and rejoin the trunk or lower branches.</p>
<p>
Object models with loops, or <i>circular references,</i> result when a dependent object has a property or variable that holds a reference to one of the objects that contains it.</p>
<p>
For example, an Order object might have a Contact property that contains a reference to a Contact object, representing the individual who placed the order. The Contact object might in turn have a Company property that contains a reference to a Company object.</p>
<p>
Up to this point, the hierarchy is a tree. However, if the Company object has a MostRecentOrder property that contains a reference to the Order object, a circular reference has been created.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You could avoid the circular reference in this case by making the MostRecentOrder property a text key that could be used to retrieve the Order object from the component’s Orders collection.</p>
<h2>Circular References in Visual Basic Components</h2>
<p>
Consider the simplest form of circular reference, a Parent property. The Parent property of a dependent object contains a reference to the object that contains it.</p>
<p>
For example, in the Microsoft Excel object model, a Button object is contained by a Worksheet object. If you have a reference to a Button object, you can print the name of the Worksheet that contains it using code like the following:</p>
<pre><code>' If the variable btnCurrent contains a reference to a
' Microsoft Excel Button object, the following line of
' code displays the Name property of the Worksheet
' object that contains the button.
MsgBox btnCurrent.Parent.Name
</code></pre>
<p>
Microsoft Excel is written using C++ and low level COM interfaces, and it maintains the Parent properties of its objects without creating circular references. If you implement such a relationship in Visual Basic, you have to take into account the way Visual Basic handles the creation and destruction of objects.</p>
<p>
Visual Basic destroys an object when there are no longer any references to it. If an object’s parent has a collection that contains a reference to the object, that’s enough to keep the object from being destroyed. In the same way, an object continues to exist if the parent has an object property that contains a reference to the object.</p>
<p>
When a parent object is destroyed, the variables that implement its properties go out of scope, and the object references are released. This allows the dependent objects to terminate. If a dependent object has a Parent property, however, Visual Basic cannot destroy the parent object in the first place, because the dependent object has a reference to it.</p>
<p>
The dependent object cannot be destroyed, either, because the parent has a reference to it. This situation is illustrated for an out-of-process component in Figure 6.7.</p>
<p class=label>
<b>Figure 6.7&nbsp;&nbsp;&nbsp;Circular reference prevents objects from being destroyed</b></p>
<p>
<img src="avtcm079.gif" border=0></p>
<p>
Client application B has released its reference to its Widget object. The Widget object has a reference to a Knob object, whose Parent property refers back to the Widget object, keeping both objects from terminating.</p>
<p>
A similar problem occurs if the Widget object contains a collection of Knob objects, instead of a single Knob. The Widget object keeps a reference to the Knobs collection object, which contains a reference to each Knob. The Parent property of each Knob contains a reference to the Widget, forming a loop that keeps the Widget object, Knobs collection, and Knob object alive.</p>
<p>
The objects client B was using will not be destroyed until the component closes. For example, if client A releases its Widget object, there will be no external references to the component. If the component does not have any forms loaded, and there is no code executing in any procedure, then the component will unload, and the Terminate events for all the objects will be executed. However, in the meantime, large numbers of orphaned objects may continue to exist, taking up memory.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If a circular reference exists between objects in two out-of-process components, the components will never terminate.</p>
<h3>Circular References and In-Process Components</h3>
<p>
If you implement your component as a DLL, so that it runs in the process of the client application, it’s even more important to avoid circular references. Because an in-process component shares the process space of the client application, there is no distinction between ‘external’ and ‘internal’ references to a public object. As long as there’s a reference to an object provided by the component, it stays loaded.</p>
<p>
This means that a circular reference keeps an in-process component loaded indefinitely, and the memory taken up by orphaned objects cannot be reclaimed until the client application closes.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;See "ActiveX Component Standards and Guidelines" for more information on object models.</p>
</BODY>
</HTML>
