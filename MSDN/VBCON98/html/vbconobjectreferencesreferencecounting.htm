<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Object References and Reference Counting</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconobjectreferencesreferencecounting"></a>Object References and Reference Counting</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconObjectReferencesReferenceCountingC">
</object></p>
<p>
The primary rule for object lifetime is very simple: An object is destroyed when the last reference to it is released. However, as with so much of life, simple doesn't always mean easy.</p>
<p>
As you use more objects, and keep more variables containing references to those objects, you may go through periods when it seems impossible to get your objects to go away when you want them to.</p>
<p>
At some point, it will occur to you that Visual Basic must be keeping track of object references — otherwise how could it know when the last reference to an object is released? You may start thinking that if only you could get access to Visual Basic's reference counts, debugging would be much easier.</p>
<p>
Unfortunately, that's not true. To make using objects more efficient, the Component Object Model (COM) specifies a number of complex shortcuts to its reference counting rules. The net result is that you couldn't trust the value of the reference count even if you had access to it.</p>
<p>
According to COM rules, the only information you can depend on is <i>whether or not the reference count is zero</i>. You know when the reference count reaches zero, because your object's Terminate event occurs. Beyond that, there's no reliable information to be gleaned from reference counts.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The fact that you don't have to remember the COM reference counting rules is no small thing. Managing reference counts yourself is a lot more difficult than keeping track of which object variables in your program contain references to objects.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;Declare your object variables as class types, instead of As Object. That way, if you have a Widget object that isn't terminating, the only variables you need to worry about are those declared As Widget.</p>
<p class=indent>
For collections of object references, don't use the Visual Basic Collection object by itself. Object references in a Visual Basic Collection object are stored in Variants — which, like variables declared As Object, can hold references to objects of any class. Instead create collection classes of your own that accept objects of only one class, as described in "Creating Your Own Collection Classes." That way, the only collections you need to search for your Widget object are those of type Widget.</p>
<p class=indent>
Organize your object into a hierarchy, as described in "Object Models." If all of your objects are connected, It's easy to write a procedure that walks through the whole model and reports on all the existing objects.</p>
<p class=indent>
Don't declare variables As New. They're like those birthday candles that re-ignite after you blow them out: If you use one after you've set it to Nothing, Visual Basic obligingly creates another object.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;Circular references are the most difficult kind to shut down cleanly. See "Object Models."</p>
</BODY>
</HTML>
