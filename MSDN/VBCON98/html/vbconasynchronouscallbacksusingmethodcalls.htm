<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Asynchronous Notifications Using Call-Back Methods</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconasynchronouscallbacksusingmethodcalls"></a>Asynchronous Notifications Using Call-Back Methods</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconAsynchronousCallBacksUsingMethodCallsC">
</object></p>
<p>
There are two parts to implementing asynchronous processing using call-back methods. The first part is the responsibility of the author of a component. The author must:
<ol>
<li>
Define the tasks or notifications to be performed.<br><br></li>
<li>
Provide one or more externally creatable classes to manage the tasks or notifications. This manager class may also do the work, or a worker class may be provided to do the actual processing.<br><br></li>
<li>
Create a type library containing the interface (or interfaces) that clients must implement in order to receive notifications. This interface must include all methods the component will call to notify the client.<p class=atl>
<B><b>Note</b></B> &nbsp; You can create type libraries with Visual Basic, as explained in "Creating Standard Interfaces with Visual Basic," in "General Principles of Component Design."</p></li>
<li>
Provide the manager class with methods that clients can call to initiate tasks or to request notifications.<p class=atl>
<B><b>Note</b></B> &nbsp; Each of these methods must have one argument declared as the interface type defined in step 3, so the client can pass the interface containing its implementation of the appropriate call-back method.</p></li>
<li>
Write code to start the task, or the process of watching for interesting occurrences.<br><br></li>
<li>
Write code to invoke the appropriate call-back method when the task is complete, or when the interesting occurrences are observed.</li>
</ol>
<p class=indent>
<B><b>Tip</b></B> &nbsp; If a client provides a number of asynchronous services, you may want to group closely related call-backs on separate interfaces. This is because a client class must implement all the methods on an interface, whether it uses them or not. Having one big interface with all your call-back methods on it is thus inconvenient for clients.</p>
<p>
The second part is the responsibility of the developer who uses the component. The developer must:
<ol start=7>
<li>
Create a public class that implements the interface defined by the component author.<p class=atl>
<B><b>Note</b></B> &nbsp; Use PublicNotCreatable for the Instancing property of this class. The class must be public so the component can invoke the call-back methods, but there’s no reason to let other applications create instances of the class.</p></li>
<li>
In the call-back methods the client will use, write code to handle the notifications.</li>
</ol>
<p class=indent>
<B><b>Tip</b></B> &nbsp; All the methods of an interface must be implemented, but those you don’t use can simply contain a comment.
<ol start=9>
<li>
Write code to request an instance of the component’s manager class.<br><br></li>
<li>
Write code to call the methods that initiate tasks or that request notifications.</li>
</ol>
<p>
Figure 8.13 shows how the author’s part and the developer’s part interact to enable asynchronous processing for the CoffeeReady example from the step-by-step procedures in "Creating an ActiveX EXE Component."</p>
<p class=label>
<b>Figure 8.13&nbsp;&nbsp; Asynchronous notifications using call-back methods</b></p>
<p>
<img src="avtcm105.gif" border=0></p>
<p class=indent>
<B><b>Note</b></B> &nbsp; The numbers in Figure 8.13 indicate the order in which things happen in the finished application and component. They do not correspond to the numbers in the task lists.</p>
<p class=indent>
<B><b>Tip</b></B> &nbsp; If the NotifyMe object is only going to be used once, the client doesn’t have to keep a reference to it. In this case, the client code to call <code>TellMeReady</code> could be written as follows:</p>
<pre><code>Call mcof.TellMeReady(New NotifyMe)
</code></pre>
<h4>Call-Backs to Multiple Clients</h4>
<p>
One way for the Coffee object to handle multiple clients would be for the component to interpose a Connection object between the client and the Coffee object — so that each client would have its own Connection object, and each Connection object would supply its client with a reference to one central Coffee object.</p>
<p>
The Coffee object’s TellMeReady method would have to place the ICoffeeNotify references into a collection, so the timer could enumerate the collection and call each client’s CoffeeReady method.</p>
<p>
<B><b>For More Information</b></B> &nbsp; You can see these tasks carried out in the sample applications for "Creating an ActiveX EXE Component," which demonstrate asynchronous notifications using both events and call-back methods. Implementing interfaces is discussed in "Providing Polymorphism by Implementing Interfaces," in "General Principles of Component Design." Polymorphism is introduced in "Polymorphism," in "Programming with Objects," in the <i>Visual Basic Programmer’s Guide</i>.</p>
</BODY>
</HTML>
