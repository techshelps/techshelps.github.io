<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the Communications Control</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconusingcommunicationscontrol"></a>Using the Communications Control</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconUsingCommunicationsControlC">
</object></p>
<p>
The Communications control allows you to add both simple serial port communication functionality to your application and advanced functionality to create a full-featured, event-driven communications tool.</p>
<p class=label>
<b>The Communications Control</b></p>
<p>
<img src="avtct107.gif" border=0></p>
<p>
The Communications control provides an interface to a standard set of communications commands. It allows you to establish a connection to a serial port, connect to another communication device (a modem, for instance), issue commands, exchange data, and monitor and respond to various events and errors that may be encountered during a serial connection.</p>
<h2>Possible Uses</h2>
<ul type=disc>
<li>
To dial a phone number.<br><br></li>
<li>
To monitor a serial port for incoming data.<br><br></li>
<li>
To create a full-featured terminal program.</li>
</ul>
<h2>Sample Applications: Dialer.vbp and VBTerm.vbp</h2>
<p>
The Dialer.vbp and VBTerm.vbp sample applications which are listed in the <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="DefaultTopic" value="_topic_not_found.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbsamples">
</object><a href=JavaScript:alink_2.Click()>samples</a> directory, demonstrate simple and complex (respectively) programming techniques of the Communications control.</p>
<h2>Basics of Serial Communications</h2>
<p>
Every computer comes with one or more serial ports. They are named successively: COM1, COM2, and so on. On a standard PC, the mouse is usually connected to the COM1 port. A modem may be connected to COM2, a scanner to COM3, etc. Serial ports provide a channel for the transmission of data from these external serial devices.</p>
<p>
The essential function of the serial port is to act as an interpreter between the CPU and the serial device. As data is sent through the serial port from the CPU, Byte values are converted to serial bits. When data is received, serial bits are converted to Byte values.</p>
<p>
A further layer of interpretation is needed to complete the transmission of data. On the operating system side, Windows uses a communications driver, Comm.drv, to send and receive data using standard Windows API functions. The serial device manufacturer provides a driver that connects its hardware to Windows. When you use the Communications control, you are issuing API functions, which are then interpreted by Comm.drv and passed to the device driver.</p>
<p>
As a programmer, you need only concern yourself with the Windows side of this interaction. As a Visual Basic programmer, you need only concern yourself with the interface that the Communications control provides to API functions of the Windows communications driver. In other words, you set and monitor properties and events of the Communications control.</p>
<h2>Establishing the Serial Connection</h2>
<p>
The first step in using the Communications control is establishing the connection to the serial port. The following table lists the properties that are used to establish the serial connection:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Properties</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>CommPort</td>
<td width=74%>Sets and returns the communications port number.</td>
</tr>
<tr valign=top>
<td width=26%>Settings</td>
<td width=74%>Sets and returns the baud rate, parity, data bits, and stop bits as a string.</td>
</tr>
<tr valign=top>
<td width=26%>PortOpen</td>
<td width=74%>Sets and returns the state of a communications port. Also opens and closes a port.</td>
</tr>
</table><br>
<h3>Opening the Serial Port</h3>
<p>
To open a serial port, use the CommPort, PortOpen, and Settings properties. For example:</p>
<pre><code>' Open the serial port
MSComm1.CommPort = 2
MSComm1.Settings = "9600,N,8,1"
MSComm1.PortOpen = True
</code></pre>
<p>
The CommPort property sets which serial port to open. Assuming that a modem is connected to COM2, the above example sets the value to 2 (COM2) and connects to the modem. You can set the CommPort property value to any number between 1 and 16 (the default is 1). If, however, you set this value to a COM port that does not exist for the system on which your application is run, an error will be generated.</p>
<p>
The Settings property allows you to specify the baud rate, parity, and the number of data bits and stop bits. By default, the baud rate is set at 9600. The parity setting is for data validation. It is commonly not used, and set to "N". The data bits setting specifies the number of bits that represent a chunk of data. The stop bit indicates when a chunk of data has been received.</p>
<p>
Once you’ve specified which port to open and how data communication is to be handled, you use the PortOpen property to establish the connection. It is a Boolean value, True or False. If, however, the port is not functional, if the CommPort property is set incorrectly, or if the device does not support the settings you’ve specified, an error will be generated or the external device may not work correctly. Setting the value of the PortOpen property to False closes the port.</p>
<h2>Working with a Modem</h2>
<p>
In most cases, you will use the Communications control to program your application to work with a modem. With the Communications control, you can use the standard Hayes-compatible command set to dial a phone number, or connect to and interact with another modem.</p>
<p>
Once the serial port connection has been established using the CommPort, Settings, and PortOpen properties, you use the Output property to activate and interact with the modem. The Output property is used to issue commands which control the interaction between one modem and another. For example:</p>
<pre><code>' Activate the modem and dial a phone number.
MSComm1.Output = "ATDT 555-5555" &amp; vbCr
</code></pre>
<p>
In the example above, the command "AT" initiates the connection, "D" dials the number, and "T" specifies touch tone (rather than pulse). A carriage return character (vbCr) must be specified when outputting to a terminal. You do not need to add the return character when outputting byte arrays.</p>
<p>
When a command is successfully processed, an "OK" result code will be returned. You can test for this result code to determine if a command was processed successfully.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;For a complete list of Hayes-compatible commands, check your modem documentation.</p>
<h2>Setting Receive and Transmit Buffer Properties at Design Time</h2>
<p>
When a port is opened, receive and transmit buffers are created. To manage these buffers, the Communications control provides you with a number of properties that can be set at design time using the control’s Property Pages.</p>
<p class=label>
<b>Setting buffer properties at design time</b></p>
<p>
<img src="avtct108.gif" border=0></p>
<h3>Buffer Memory Allocation</h3>
<p>
The InBufferSize and OutBufferSize properties specify how much memory is allocated to the receive and transmit buffers. Each are set by default to the values shown above. The larger you make the number, the less memory you have available to your application. If, however, your buffer is too small, you run the risk of overflowing the buffer unless you use handshaking.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Given the amount of memory available to most PCs at this time, buffer memory allocation is less crucial because you have more resources available. In other words, you can set the buffer values higher without affecting the performance of your application.</p>
<h3>The RThreshold and SThreshold Properties</h3>
<p>
The RThreshold and SThreshold properties set or return the number of characters that are received into the receive and transmit buffers before the OnComm event is fired. The OnComm event is used to monitor and respond to changes in communications states. Setting the value for each property to zero (0) prevents the OnComm event from firing. Setting the value to something other than 0 (1, for instance) causes the OnComm event to be fired every time a single character is received into either buffer.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;See "The OnComm Event and the CommEvent Property" in this topic for more information on these properties.</p>
<h3>The InputLen and EOFEnable Properties</h3>
<p>
Setting the InputLen property to 0 causes the Communications control to read the entire contents of the receive buffer when the Input property is used. When reading data from a machine whose output is formatted in fixed-length blocks of data, the value of this property can be set appropriately.</p>
<p>
The EOFEnable property is used to indicate when an End of File (EOF) character is found during data input. Setting this to True causes data input to stop and the OnComm event to fire to inform you that this condition has occurred.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;See "Managing the Receive and Transmit Buffers" and "The OnComm Event and the CommEvent Property" in this topic for more information.</p>
<h2>Managing the Receive and Transmit Buffers</h2>
<p>
As mentioned above, receive and transmit buffers are created whenever a port is opened. The receive and transmit buffers are used to store incoming data and to transmit outgoing data. The Communications control allows you to manage these buffers by providing you with a number of properties that are used to place and retrieve data, return the size of each buffer, and handle both text and binary data. Properly managing these buffers is an important part of using the Communications control.</p>
<h3>The Receive Buffer</h3>
<p>
The Input property is used to store and retrieve data from the receive buffer. For example, if you wanted to retrieve data from the receive buffer and display it in a text box, you might use the following code:</p>
<pre><code>TxtDisplay.Text = MSComm1.Input
</code></pre>
<p>
To retrieve the entire contents of the receive buffer, however, you must first set the InputLen property to 0. This can be done at design or run time.</p>
<p>
You can also receive incoming data as either text or binary data by setting the InputMode property to one of the following Visual Basic constants: comInputModeText or comInputModeBinary. The data will either be retrieved as string or as binary data in a Byte array. Use comInputModeText for data that uses the ANSI character set and comInputModeBinary for all other data, such as data that has embedded control characters, Nulls, etc.</p>
<p>
As each byte of data is received, it is moved into the receive buffer and the InBufferCount property is incremented by one. The InBufferCount property, then, can be used to retrieve the number of bytes in the receive buffer. You can also clear the receive buffer by setting the value of this property to 0.</p>
<h3>The Transmit Buffer</h3>
<p>
The Output property is used to send commands and data to the transmit buffer.</p>
<p>
Like the Input property, data can be transmitted as either text or binary data. The Output property, however, must transmit either text or binary data by specifying either a string or Byte array variant.</p>
<p>
You can send commands, text strings, or Byte array data with the Output property. For example:</p>
<pre><code>' Send an AT command
MSComm1.Output = "ATDT 555-5555"

' Send a text string
MsComm1.Output = "This is a text string"

' Send Byte array data
MSComm1.Output = Out
</code></pre>
<p>
As previously mentioned, transmit lines must end with a carriage return character (vbCr). In the last example, <code>Out</code> is a variable defined as a Byte array: <code>Dim Out() As Byte</code>. If it were a string variant, it would be defined as: <code>Dim Out() As String</code>.</p>
<p>
You can monitor the number of bytes in the transmit buffer by using the OutBufferCount property. You can clear the transmit buffer by setting this value to 0.</p>
<h2>Handshaking</h2>
<p>
An integral part of managing the receive and transmit buffers is ensuring that the back-and-forth transmission of data is successful — that the speed at which the data is being received does not overflow the buffer limits, for example.</p>
<p>
<i>Handshaking</i> refers to the internal communications protocol by which data is transferred from the hardware port to the receive buffer. When a character of data arrives at the serial port, the communications device has to move it into the receive buffer so that your program can read it. A handshaking protocol ensures that data is not lost due to a buffer overrun, where data arrives at the port too quickly for the communications device to move the data into the receive buffer.</p>
<p>
You set the Handshaking property to specify the handshaking protocol to be used by your application. By default, this value is set to none (comNone). You can, however, specify one of the other following protocols:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=30%><b>Setting</b></td>
<td class=label width=20%><b>Value</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=30%>comNone</td>
<td width=20%>0</td>
<td width=50%>No handshaking (Default).</td>
</tr>
<tr valign=top>
<td width=30%>comXOnXOff</td>
<td width=20%>1</td>
<td width=50%>XOn/XOff handshaking.</td>
</tr>
<tr valign=top>
<td width=30%>comRTS</td>
<td width=20%>2</td>
<td width=50%>RTS/CTS (Request To Send/Clear To Send) handshaking.</td>
</tr>
<tr valign=top>
<td width=30%>comRTSXOnXOff</td>
<td width=20%>3</td>
<td width=50%>Both Request To Send and XOn/XOff handshaking.</td>
</tr>
</table><br>
<p>
The protocol that you choose depends upon the device to which you’re connecting. Setting this value to comRTSXOnXOff supports both of the protocols.</p>
<p>
In many cases, the communications protocol itself handles handshaking. Therefore, setting this property to something other than comNone may result in conflicts.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;If you do set this value to either comRTS or comRTSXOnXOff, you need to set the RTSEnabled property to True. Otherwise, you will be able to connect and send, but not receive, data.</p>
<h2>The OnComm Event and the CommEvent Property</h2>
<p>
Depending upon the scope and functionality of your application, you may need to monitor and respond to any number of events or errors which may occur during the connection to another device or in the receipt or transmission of data.</p>
<p>
The OnComm event and the CommEvent property allow you to trap and check the value of communication events and errors.</p>
<p>
When a communication event or error occurs, the OnComm event is fired and the value of the CommEvent property is changed. Therefore, if necessary, you can check the value of the CommEvent property each time the OnComm event is fired. Because communications (especially over telephone lines) can be unpredictable, trapping these events and errors allows you to respond to them appropriately.</p>
<p>
The following table lists the communication events that will trigger the OnComm event. The values will then be written to the CommEvent property.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=26%><b>Constant</b></td>
<td class=label width=16%><b>Value</b></td>
<td class=label width=58%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>comEvSend</td>
<td width=16%>1</td>
<td width=58%>There are fewer than SThreshold number of characters in the transmit buffer.</td>
</tr>
<tr valign=top>
<td width=26%>comEvReceive</td>
<td width=16%>2</td>
<td width=58%>Received RThreshold number of characters. This event is generated continuously until you use the Input property to remove the data from the receive buffer.</td>
</tr>
<tr valign=top>
<td width=26%>comEvCTS</td>
<td width=16%>3</td>
<td width=58%>Change in Clear To Send line.</td>
</tr>
<tr valign=top>
<td width=26%>comEvDSR</td>
<td width=16%>4</td>
<td width=58%>Change in Data Set Ready line. This event is only fired when DSR changes from 1 to 0.</td>
</tr>
<tr valign=top>
<td width=26%>comEvCD</td>
<td width=16%>5</td>
<td width=58%>Change in Carrier Detect line.</td>
</tr>
<tr valign=top>
<td width=26%>comEvRing</td>
<td width=16%>6</td>
<td width=58%>Ring detected. Some UARTs (universal asynchronous receiver-transmitters) may not support this event.</td>
</tr>
<tr valign=top>
<td width=26%>comEvEOF</td>
<td width=16%>7</td>
<td width=58%>End Of File (ASCII character 26) character received.</td>
</tr>
</table><br>
<p>
The OnComm event is also triggered, and a value is written to the CommEvent property, when the following errors are encountered.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=29%><b>Setting</b></td>
<td class=label width=15%><b>Value</b></td>
<td class=label width=56%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%>comEventBreak</td>
<td width=15%>1001</td>
<td width=56%>A Break signal was received.</td>
</tr>
<tr valign=top>
<td width=29%>comEventFrame</td>
<td width=15%>1004</td>
<td width=56%>Framing Error. The hardware detected a framing error.</td>
</tr>
<tr valign=top>
<td width=29%>comEventOverrun</td>
<td width=15%>1006</td>
<td width=56%>Port Overrun. A character was not read from the hardware before the next character arrived and was lost.</td>
</tr>
<tr valign=top>
<td width=29%>comEventRxOver</td>
<td width=15%>1008</td>
<td width=56%>Receive Buffer Overflow. There is no room in the receive buffer.</td>
</tr>
<tr valign=top>
<td width=29%>comEventRxParity</td>
<td width=15%>1009</td>
<td width=56%>Parity Error. The hardware detected a parity error.</td>
</tr>
<tr valign=top>
<td width=29%>comEventTxFull</td>
<td width=15%>1010</td>
<td width=56%>Transmit Buffer Full. The transmit buffer was full while trying to queue a character.</td>
</tr>
<tr valign=top>
<td width=29%>comEventDCB</td>
<td width=15%>1011</td>
<td width=56%>Unexpected error retrieving Device Control Block (DCB) for the port.</td>
</tr>
</table><br>
</BODY>
</HTML>
