<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using DoEvents</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconusingdoevents"></a>Using DoEvents</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconUsingDoEventsC">
</object></p>
<p>
Although Timer events are the best tool for background processing, particularly for very long tasks, the DoEvents function provides a convenient way to allow a task to be canceled. For example, the following code shows a "Process" button that changes to a "Cancel" button when it is clicked. Clicking it again interrupts the task it is performing.</p>
<pre><code>' The original caption for this button is "Process".
Private Sub Command1_Click()
   ' Static variables are shared by all instances 
   ' of a procedure.
   Static blnProcessing As Boolean
   Dim lngCt As Long
   Dim intYieldCt As Integer
   Dim dblDummy As Double
   ' When the button is clicked, test whether it's 
    'already processing.
   If blnProcessing Then
      ' If processing is in progress, cancel it.
      blnProcessing = False
   Else
      Command1.Caption = "Cancel"
      blnProcessing = True
      lngCt = 0
      ' Perform a million floating-point 
      ' multiplications. After every
      ' thousand, check for cancellation.
      Do While blnProcessing And (lngCt &lt; 1000000)
         For intYieldCt = 1 To 1000
            lngCt = lngCt + 1
            dblDummy = lngCt * 3.14159
         Next intYieldCt
         ' The DoEvents statement allows other 
         ' events to occur, including pressing this 
         ' button a second time.
         DoEvents
      Loop
      blnProcessing = False
      Command1.Caption = "Process"
      MsgBox lngCt &amp; " multiplications were performed"
   End If
End Sub
</code></pre>
<p>
DoEvents switches control to the operating-environment kernel. Control returns to your application as soon as all other applications in the environment have had a chance to respond to pending events. This doesn't cause the current application to give up the focus, but it does enable background events to be processed.</p>
<p>
The results of this yielding may not always be what you expect. For example, the following Click-event code waits until ten seconds after the button was clicked and then displays a message. If the button is clicked while it is already waiting, the clicks will be finished in reverse order.</p>
<pre><code>Private Sub Command2_Click()
   Static intClick As Integer
   Dim intClickNumber As Integer
   Dim dblEndTime As Double
      ' Each time the button is clicked, 
      ' give it a unique number.
   intClick = intClick + 1
   intClickNumber = intClick
      ' Wait for ten seconds.
   dblEndTime = Timer + 10#
   Do While dblEndTime &gt; Timer
      ' Do nothing but allow other 
      ' applications to process
      ' their events.
      DoEvents
   Loop
   MsgBox "Click " &amp; intClickNumber &amp; " is finished"
End Sub
</code></pre>
<p>
You may want to prevent an event procedure that gives up control with DoEvents from being called again before DoEvents returns. Otherwise, the procedure might end up being called endlessly, until system resources are exhausted. You can prevent this from happening either by temporarily disabling the control or by setting a static "flag" variable, as in the earlier example.</p>
<h2>Avoiding DoEvents When Using Global Data</h2>
<p>
It may be perfectly safe for a function to be called again while it has yielded control with DoEvents. For example, this procedure tests for prime numbers and uses DoEvents to periodically enable other applications to process events:</p>
<pre><code>Function PrimeStatus (TestVal As Long) As Integer
   Dim Lim As Integer
   PrimeStatus = True
   Lim = Sqr(TestVal)
   For I = 2 To Lim
      If TestVal Mod I = 0 Then
         PrimeStatus = False
         Exit For
      End If
      If I Mod 200 = 0 Then DoEvents
   Next I
End Function
</code></pre>
<p>
This code calls the DoEvents statement once every 200 iterations. This allows the PrimeStatus procedure to continue calculations as long as needed while the rest of the environment responds to events.</p>
<p>
Consider what happens during a DoEvents call. Execution of application code is suspended while other forms and applications process events. One of these events might be a button click that launches the PrimeStatus procedure again.</p>
<p>
This causes PrimeStatus to be re-entered, but since each occurrence of the function has space on the stack for its parameters and local variables, there is no conflict. Of course, if PrimeStatus gets called too many times, an Out of Stack Space error could occur.</p>
<p>
The situation would be very different if PrimeStatus used or changed module-level variables or global data. In that case, executing another instance of PrimeStatus before DoEvents could return might result in the values of the module data or global data being different than they were before DoEvents was called. The results of PrimeStatus would then be unpredictable.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;See "DoEvents Function" and "Refresh Method" in the <i>Language Reference</i>.</p>
</BODY>
</HTML>
