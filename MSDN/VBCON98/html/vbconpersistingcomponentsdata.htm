<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Persisting a Component's Data</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconpersistingcomponentsdata"></a>Persisting a Component's Data</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconPersistingComponentsData_C">
</object></p>
<p>
Most components have properties; in most cases you'll want to establish default values for those properties in the Initialize event of the class. Those default values are frozen when you compile the component, so how do you allow a developer to change the default values to meet their own special conditions? Classes have a special property, Persistable, that allow you to store a component's values between instances.</p>
<p>
Suppose that you had an ActiveX DLL that calculates loans, with an InterestRate property used in the calculations. You could initialize the InterestRate to some arbitrary value, but since interest rates periodically go up or down, the InterestRate property would need to be modified each time the component is run. With class persistence, you can store the InterestRate value and modify it only when the interest rate changes. Each time your component is run it can retrieve the InterestRate from storage, so the component will always provide the latest rate.</p>
<p>
While ActiveX controls have always been able to persist their data; persistence for ActiveX components is slightly different. A control stores property settings inside it's .cls file, but a component can't do that. Instead, it uses a PropertyBag object that can be saved just about anywhere – in a file, a database, a cell in a spreadsheet, or even in the registry. </p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;To learn more about persisting ActiveX controls, see "Saving the Properties of a Control," in "Building an ActiveX Control"<i>.</i></p>
<h3>Setting Up Class Persistence</h3>
<p>
In order to be persistable, a class must meet two conditions: it must be public and creatable. If you think about, this makes sense – after all, persistence wouldn't be useful in a private component. If a class meets both conditions, the Persistable property appears in the Properties window.</p>
<p>
By default, the Persistable property is set to 0 (NotPersistable). By changing this value to 1 (Persistable), three new events are added to the class: ReadProperties, WriteProperties, and InitProperties. As you might guess, these events are use to read, write, and initialize the class's properties.</p>
<h4>Persisting a Property</h4>
<p>
You can mark a property as persistable by implementing the PropertyChanged method in a Property Let or Property Set procedure, as in the following example:</p>
<pre><code>Private mInterestRate As Single
Public Property Let InterestRate(newRate As Single)
   mInterestRate = newRate
   PropertyChanged "InterestRate"
End Sub
</code></pre>
<p>
Calling the PropertyChanged method marks the InterestRate property as dirty. The WriteProperties event will fire when the class is terminated if any property in the class has called PropertyChanged.</p>
<h4>The ReadProperties, WriteProperties and InitProperties Events</h4>
<p>
The WriteProperties event procedure is used when a class is terminating to write the current property values to a private storage known as a PropertyBag object. The following code is used to save a property to the built-in PropertyBag:</p>
<pre><code>Private Sub Class_WriteProperties(PropBag As PropertyBag)
   PropBag.WriteProperty "InterestRate", mInterestRate, conDefaultRate
End Sub
</code></pre>
<p>
The Property Bag's WriteProperty method in the above code takes three arguments: the name of the property to save ("InterestRate"), the value to save (mInterestRate), and a default value (DefaultRate). If the new value matches the constant conDefaultRate, the WriteProperty method doesn't have to write out the value.</p>
<p>
The ReadProperties event is fired when a class is initialized – but only if the PropertyBag has something in it. If the PropertyBag is empty, the InitProperties event will be fired instead. Code in the ReadProperties and InitProperties events is used to set the initial property values:</p>
<pre><code>Private Sub Class_ReadProperties(PropBag As PropertyBag)
   mInterestRate = PropBag.ReadProperty("InterestRate", conDefaultRate)
End Sub
Private Sub Class_InitProperties ()
   mInterestRate = conDefaultRate
End Sub
</code></pre>
<p>
Note that the constant conDefaultRate is used in both procedures to provide a default value. By using a constant to define the default values you eliminate the risk of accidentally defining different default values in different procedures.</p>
<p>
When you first create an instance of the Loan class using the New keyword, the InitProperties event will be fired; once the class has been persisted and is then recreated, the ReadProperties event will be fired instead.</p>
<h3>Using the PropertyBag Object to Persist an Object</h3>
<p>
In order to persist an ActiveX component, you need to create an instance of a PropertyBag object. This may seem redundant — after all, the class already has it's own PropertyBag. Why can't you just use that? Simple. When the object goes away, so does its PropertyBag. It only exists in memory; for persistence you need to store a copy of the object somewhere so you can retrieve it later.</p>
<p>
Think of a PropertyBag as a sack that you can fill up with stuff and stash away somewhere for safe keeping. Where you stash it is entirely up to you. The following form code demonstrates how you can persist an object to a text file:</p>
<pre><code>Private pb As PropertyBag      ' Declare a PropertyBag object.
Private LoanObject As Loan      ' Declare a Loan object.

Private Sub Form_Unload(Cancel As Integer)
   Dim varTemp as Variant

   ' Instantiate the PropertyBag object.
   Set pb = New PropertyBag
   ' Save the object to the PropertyBag using WriteProperty.
   pb.WriteProperty "MyLoanObject", LoanObject
   ' Assign the Contents of the PropertyBag to a Variant.
   varTemp = pb.Contents
   ' Save to a text file.
   Open "C:\Loandata.txt" For Binary As #1
   Put #1, , varTemp
   Close #1
End Sub
</code></pre>
<p>
The Contents property of the PropertyBag object contains the Loan object stored as an array of bytes. In order to save it to a text file, you first must convert it to a data type that a text file understands — in this case, a Variant.</p>
<h3>Depersisting An Object</h3>
<p>
Once the object is contained inside a text file (or any other type of storage), it can easily be transported to another location. Imagine that our Loan object contains not only the InterestRate, but also property values to represent all of the fields in a loan application. You could take the Loandata.txt file and send it to the central office for approval. The code for a form that would reuse the Loan object would look something like this:</p>
<pre><code>Private pb As PropertyBag      ' Declare a PropertyBag object.
Private LoanObject As Loan      ' Declare a Loan object.

Private Sub Form_Load()
   Dim varTemp As Variant
   Dim byteArr() as Byte

   ' Instantiate the PropertyBag object.
   Set pb = New PropertyBag
   ' Read the file contents into a Variant.
   Open "C:\Loandata.txt" For Binary As #1
   Get #1, , varTemp
   Close #1
   ' Assign the Variant to a Byte array.
   ByteArr = varTemp
   ' Assign to the PropertyBag Contents property.
   Pb.Contents&nbsp; = ByteArr
   ' Instantiate the object from the PropertyBag
   Set LoanObject = pb.ReadProperty("MyLoanObject")
End If
</code></pre>
<p>
You may have noticed that the object had to be assigned three times: first from the text file to a Variant, then from a Variant to a Byte array, then to the Contents property. That's because the Contents property will only accept a Byte array — if you tried to assign any other data type you would get an error.</p>
<p>
So what's going on here? Can you actually take an object created in one place and reuse it in another, complete with its data? Well, not exactly. The original object is long gone. What you are passing in a PropertyBag is an exact copy of the object, not the object itself. This ability to "clone" an object for reuse is a powerful concept, especially when it comes to designing workflow applications.</p>
</BODY>
</HTML>
