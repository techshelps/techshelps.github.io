<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic Component Shutdown Rules</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconvisualbasiccomponentshutdownrules"></a>Visual Basic Component Shutdown Rules</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconVisualBasicComponentShutdownRulesC">
</object></p>
<p>
This topic is closely related to "ActiveX Component Shutdown," which describes the correct shutdown behavior for components.</p>
<p>
The rules Visual Basic uses to determine when to shut down are different for in-process and out-of-process components.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows>
<tr valign=top>
<td class=label width=19%><b>Rule</b></td>
<td class=label width=39%><b>In-process component</b></td>
<td class=label width=42%><b>Out-of-process component</b></td>
</tr>
<tr valign=top>
<td width=19%>References</td>
<td width=39%>There are no references —internal or external — to the component’s <i>public</i> objects.</td>
<td width=42%>No out-of-process clients have references to the component’s <i>public</i> objects.</td>
</tr>
<tr valign=top>
<td width=19%>Forms</td>
<td width=39%>The component has no forms <i>visible</i>.</td>
<td width=42%>The component has no forms <i>loaded</i>.</td>
</tr>
<tr valign=top>
<td width=19%>Code</td>
<td width=39%>No code in the component’s modules is currently executing, or in the calls list waiting to be executed.</td>
<td width=42%>Same as in-process.</td>
</tr>
<tr valign=top>
<td width=19%>Startup</td>
<td width=39%>The component is not in the process of being started, in response to a client request for an object.</td>
<td width=42%>Same as in-process.</td>
</tr>
</table><br>
<h2>Rule 1: References</h2>
<p>
When determining whether to shut down a component, Visual Basic considers only the references to <i>public</i> objects. References to objects created from classes whose Instancing property is Private <i>will not count toward keeping a component running</i>.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Classes in the VB type library are also private, and references to objects of these classes <i>will not </i>keep a component loaded. Classes in the VBA type library are public. (To view the classes in each of these libraries, select the library of interest in the Project/Library box on the Object Browser.)</p>
<h3>In-Process Components</h3>
<p>
For in-process components, the References rule has additional consequences in two areas: private objects and internal references to public objects.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;A client application written in Visual Basic may not attempt to unload an in-process component immediately after the last reference is released. The frequency of attempts depends on how frequently idle time becomes available. Two minutes is a good rule of thumb.</p>
<h4>Invalid References to Private Objects May Be Fatal to In-Process Clients</h4>
<p>
Suppose your in-process component passes a client a reference to a private object, and the client subsequently releases its last reference to your public objects. Your component may unload at any point thereafter — because the reference to the private object doesn’t prevent shutdown — leaving the client with an invalid reference to the private object.</p>
<p>
If the client attempts to use this invalid reference, a program fault will occur, and the client will terminate abruptly. If the client rarely takes a code path in which it attempts to use the invalid reference, such program faults may appear random and difficult to debug.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;Private objects — that is, objects from classes in the VB library, or objects from classes whose Instancing property is Private — are usually private for a reason. If you need to pass an instance of one of your private classes to a client, you should do the work to make the object safe for public use, and then change the Instancing property of the class to PublicNotCreatable.</p>
<h4>Internal References to Public Objects Prevent DLL Unloading</h4>
<p>
For in-process components, Visual Basic has no way to distinguish between external references to public objects (that is, references held by a client) and internal references to public objects (that is, references in object variables within your in-process component).</p>
<p>
Therefore, if your in-process component is holding a reference to one of its own public objects, Visual Basic will not unload it. Any objects your component is holding references to will continue taking up memory and resources.</p>
<p>
The most common causes of such internal references are global object variables — for example, a global collection — and circular references. Circular references arise when two objects keep references to each other, as discussed in "Dealing with Circular References," in "General Principles of Component Design." The sample application for "General Principles of Component Design" explores workarounds to global collections and circular references.</p>
<h4>Multiple In-Process Components May Keep Each Other Loaded</h4>
<p>
If several in-process components are in use, and they obtain references to each other’s public objects, the object references will keep Visual Basic from shutting the components down.</p>
<h3>Out-of-Process Components</h3>
<p>
For an out-of-process component, Visual Basic keeps separate counts of external and internal references to public objects. Only external references — that is, references held by clients — will keep your component running. This is in contrast to the counting rule for in-process components.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In contrast to in-process components, Visual Basic’s marshaling rules prohibit out-of-process components from passing private object references to clients.</p>
<h4>Avoid Keeping Internal References</h4>
<p>
Internal references to public objects — global object variables, global collections, or circular references — should still be avoided. Although internal references will not keep an out-of-process component running, they may keep orphaned objects from being destroyed.</p>
<p>
For example, suppose an out-of-process component is being used by two clients, and that client A releases all of its object references before client B does. If the component is holding internal references to the objects client A was using, they will go on taking up memory and resources until the component shuts down — which will not happen until client B releases the last of its objects.</p>
<p>
If in the meantime a third client begins using objects provided by the component, orphaned objects from both client A and client B may go on taking up memory and resources.</p>
<h4>References Held by In-Process Components Don’t Count</h4>
<p>
Your out-of-process component may be using objects provided by an in-process component, running in the out-of-process component’s process space. The out-of-process component may pass references to its public objects to the in-process component, or the in-process component may independently request an object from the out-of-process component.</p>
<p>
Regardless of how they are obtained, references held by an in-process component will not keep the out-of-process component from unloading when out-of-process clients have released all their object references.</p>
<h2>Rule 2: Forms</h2>
<p>
It may seem odd that Visual Basic takes forms into account when determining whether it’s safe to close a component. To understand the logic of this, consider applications like Microsoft Excel, which can be started by the person who uses the computer, and can also provide objects to client applications.</p>
<p>
If it’s wrong to pull your component out from under client applications that are using its objects, it’s even worse to pull a user’s spreadsheet, perhaps representing hours of painstaking labor, out from under the user just because client applications have released all the objects they were using.</p>
<p>
In other words, the person using the user interface (if your component has one) is also a client.</p>
<h3>How Visual Basic Interprets the Forms Rule</h3>
<p>
In-process components depend on their clients in a different way than out-of-process components do, so Visual Basic interprets the Forms rule differently for the two cases.</p>
<p>
A visible form will keep an in-process component in memory, even if the client has released all object references; an invisible form will not.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In-process components can be kept running in this fashion only until the client application closes. At that time, all forms are forced to unload. Forms unloaded at this time do not receive QueryUnload events, and the <i>cancel</i> argument of the Unload event is ignored.</p>
<p>
By contrast, any loaded form will keep an out-of-process component running past the point at which all references have been released — even past the termination of all clients.</p>
<p>
Visual Basic makes this distinction because an out-of-process component may be a standalone desktop application, and the fact that its forms are invisible may be only a temporary state.</p>
<h3>Controlling Form Lifetime</h3>
<p>
In general, forms should be unloaded when the object that created them terminates. For example, your component may use a hidden form to hold a Timer control. You can put code to unload the form in the Terminate event procedure of the object that creates and loads the form.</p>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If multiple objects are sharing the same form, you can create a UseCount property for the form. Increment and decrement the UseCount property in the Initialize and Terminate events of the objects, and unload the form when the UseCount reaches zero.</p>
<h4>Components That Are Desktop Applications</h4>
<p>
If your component is also a standalone desktop application, its main form will keep your component running even if no client applications are using your objects. When the user chooses Exit from your File menu, or clicks the close box on your main form, you should simply unload the form, along with any hidden forms that are loaded, such as frequently used dialog boxes.</p>
<p>
As far as the user is concerned, your application has closed. However, if client applications still have references to your objects, Visual Basic keeps your component running in the background.</p>
<h4>When Client Applications Can Manipulate the User Interface</h4>
<p>
The most difficult shutdown case is for a component that provides objects that control its user interface. For example, you might create a Window class that controls the MDI child forms in your application’s main form. If the user closes your main window, should you hide the main form even though client applications have child windows visible?</p>
<p>
Questions like this keep user interface designers awake at night. You have many options. For example, the QueryUnload event of your main form has an <i>unloadmode</i> argument you can test to determine if the form is closing because the user clicked the close box, or because your program code is trying to unload it.</p>
<p>
You can unload the child forms that the user opened through your application’s menus and toolbar buttons, hide the main form, and set the Visible property of your Application object to False. Client applications can set the Visible property to True again if necessary.</p>
<p>
Alternatively, you can unload all the user’s forms, and leave the remaining child forms visible in your main window. You may want to show the user a message indicating what you’re doing, and perhaps provide the option of hiding the main window anyway, because the computer user is generally regarded as the ultimate owner of the visual interface.</p>
<p>
There are no right answers. Your best bet is to do lots of usability testing.</p>
<h2>Rule 3: Code Executing</h2>
<p>
Visual Basic will not unload your component if it is currently executing code. This includes the case where your component has called a routine in another component, a function in a DLL, or a Windows API function. While the external routine is executing, the procedure that made the call is waiting in the calls list, and Visual Basic will not close your component.</p>
<p>
There are no actions you need to take — or refrain from — in regard to this shutdown condition. Like external object references, Visual Basic manages it for you.</p>
<h2>Rule 4: Startup</h2>
<p>
The last condition is a special case that covers the awkward gap between the time your component to starts up because a client application has requested one of your objects, and the moment when your component returns the object reference. There may be moments in the startup sequence when there are no forms loaded and no code executing, and there certainly aren’t any external object references.</p>
<p>
As with the code execution condition, you don’t need to take any action because Visual Basic handles this case for you.</p>
<h2>Summary of Guidelines for Component Shutdown</h2>
<p>
The following guidelines summarize what you need to remember about component shutdown.
<ul type=disc>
<li>
A well-behaved component does not control its own lifetime.<br><br></li>
<li>
Don’t shut an out-of-process component down forcibly using the End statement.<p class=tl>
As a corollary to this, don’t implement a Quit method. Releasing a component by releasing all references to its objects is good programming practice. Educate users of your component by explaining in your Help file that this is the correct way to release your component. Don’t encourage bad programming practices by giving developers a shortcut that could disrupt other clients.</P></li>
<li>
Don’t prolong the life of your component needlessly by keeping a form loaded but hidden when there are no objects using it.<br><br></li>
<li>
Avoid circular references that artificially prolong the life of your component, such as an object that holds a reference to a form that in turn holds a reference to the object. Circular references are discussed in "Dealing with Circular References," in "General Principles of Component Design."<br><br></li>
<li>
If your component is a standalone desktop application that also provides objects, remember that the computer user is one of your clients.</li>
</ul>
<p>
Most of the work of being a good component is done for you by Visual Basic. You can go a long way by simply letting it do its job.</p>
</BODY>
</HTML>
