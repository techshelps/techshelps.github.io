<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Do I Need an Object Model?</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbcondoineedobjectmodel"></a>Do I Need an Object Model?</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconDoINeedObjectModelC">
</object></p>
<p>
You don’t have to create an elaborate object model for your component. A control component (.ocx file) might contain three UserControl objects, and no class modules at all. A code component meant to be used as a simple library of functions might have one global object with a zillion methods.</p>
<p>
Again, you might create a code component named Finance with three classes in it, each class representing a self-contained business rule. If the rules are independent of each other, there’s no reason to link them into a hierarchy. A client application that uses these rules simply creates one or more objects of each class, as needed.</p>
<p>
Each class module in such a component would have its Instancing property set to MultiUse, so that client applications could create objects from the class, and so that the component could handle multiple objects from each class. Figure 6.5 shows such an object model.</p>
<p class=label>
<b>Figure 6.5&nbsp;&nbsp;&nbsp;A flat object model with several externally creatable objects</b></p>
<p>
<img src="avtcm077.gif" border=0></p>
<h3>Object Models and Interfaces</h3>
<p>
As the functionality of an object increases, so does the complexity of its interface. This can make the object hard to use.</p>
<p>
You can reduce the complexity of an object’s default interface by factoring out groups of related functions, and defining an interface for each group. A client can work with only those interfaces that provide needed features.</p>
<p>
By defining standard interfaces in this fashion, you can implement interfaces on other objects, gaining the benefits of polymorphism. This approach to software design in discussed in "Providing Polymorphism by Implementing Interfaces," earlier in this chapter.</p>
<p>
Sometimes an object is too large even when its features are factored into separate interfaces. When an object becomes very complex, as for example the TreeView and Toolbar controls, breaking pieces of it off as separate objects may make sense.</p>
<p>
Once the whole is divided, you need a way of organizing its constituent parts. Splitting the Node object off from the TreeView control gains you nothing if you can’t show the relationship between them. Object models make it easy to provide this organization to the user of your component.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;Topics relating to object models are listed in "Organizing Objects: The Object Model." The use of multiple interfaces is covered in "Providing Polymorphism by Implementing Interfaces."</p>
</BODY>
</HTML>
