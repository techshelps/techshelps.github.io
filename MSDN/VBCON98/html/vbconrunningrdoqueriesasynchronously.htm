<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Running RDO Asynchronously</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconrunningrdoqueriesasynchronously"></a>Running RDO Asynchronously</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconRunningRDOQueriesAsynchronouslyC">
</object></p>
<p>
RDO 2.0 supports far more asynchronous operations than supported by RDO 1.0. For example, all of the following operations now permit use of the rdAsyncEnable option:
<ul type=disc>
<li>
<b>Establishing a connection.</b> When using the OpenConnection or EstablishConnection methods, this option prevents blocking while waiting for connections that can take an indeterminate time to establish.<br><br></li>
<li>
<b>Creating result sets.</b> When using the OpenResultset method, this option prevents blocking while queries are being executed.<br><br></li>
<li>
<b>Executing action queries.</b> When using the Execute method, this option prevents blocking while queries are being executed.<br><br></li>
<li>
<b>Populating result sets.</b> When using the MoveLast method, this option prevents blocking while queries are being completed and result sets are fully populated.<br><br></li>
<li>
<b>Refreshing result sets.</b> If you used the rdAsyncEnable option when the result set was created, it is also used when the result set is refreshed using the Requery method.</li>
</ul>
<p>
To better support asynchronous operations, RDO now supports two properties that can be polled to test for asynchronous operation completion:
<ul type=disc>
<li>
The StillExecuting property to test for completion of queries using the OpenResultset, Execute, or Requery methods.<br><br></li>
<li>
The StillConnecting property to test for completion of a connection attempt using the OpenConnection or EstablishConnection methods.</li>
</ul>
<p>
In addition, RDO also exposes a number of events on the rdoConnection object that are fired as the operations are completed:
<ul type=disc>
<li>
The Connect event fires when the connection attempt is complete. The event fires regardless of the success or failure of the operation. <br><br></li>
<li>
The QueryComplete event fires when the query or reposition (MoveLast) operation is complete.</li>
</ul>
<h2>Handling Asynchronous Queries</h2>
<p>
When your application submits a query to a remote server, you often have no way of determining how much time will pass before the first row is returned. Because of the way SQL Server and some other servers process result sets, your application might not be passed the results until:
<ul type=disc>
<li>
<i>All</i> rows have been processed — as in the case of a sorted result set.<br><br></li>
<li>
The server-side row buffer is filled (approximately 4K).<br><br></li>
<li>
The query completes and the server-side row buffer is flushed.</li>
</ul>
<p>
A typical query can take from milliseconds to hours or even days to complete — or it might never complete if the server or your workstation runs out of resources before the server completes the job. In some cases, the remote server begins to pass rows back fairly quickly, at which time RDO begins to populate your rdoResultset based on the type of cursor you choose. However, the remote server often stops working until your application begins to access those rows by moving forward in the result set. In many cases, rows or entire pages of data are locked on the server until the query is complete, which can only occur when you populate the last row of the rdoResultset object by using one of the Move methods, like MoveLast, or simply referencing the RowCount property.</p>
<h2>Preventing Your Application from Blocking</h2>
<p>
Because of this uncertainty, it makes sense to prevent your application from blocking while the query is taking place and to ensure your application populates the result sets as quickly as possible. Unless you enable asynchronous operation by setting the rdAsyncEnable option with the OpenResultset method, your application <i>will</i> block until the first row of the result set is returned by the ODBC driver.</p>
<p>
In addition to enabling the rdAsyncEnable option, you can also code an event handler to trap the QueryComplete event that fires when the query completes.</p>
<p>
When you use the OpenResultset method with the rdAsyncEnable option, RDO returns control to your application immediately. At this point, the rdoResultset object is instantiated, but its rowset might not be ready to use&nbsp;— and won't be until the remote server begins to pass rows back. As an indication of this state, the StillExecuting property will return True until the first row is available. Once StillExecuting returns False, the rdoResultset data is available and the QueryComplete event is fired.</p>
<h2>What to Do While Waiting for an Asynchronous Operation</h2>
<p>
When using the asynchronous operation option, your application regains control while the remote server is busy working on your query or simply populating your result set. Since this operation might take some time to complete, you need to decide what your applications should do in the meantime. The following suggestions can help you choose a viable strategy:
<ul type=disc>
<li>
Establish an event handler to trap the Connect event. This event procedure can be used to finalize the connection operation or simply test for a valid connection. For example, you might wish to submit a separate set of logon or initialization procedures unique to your application in this handler.<br><br></li>
<li>
Establish an event handler to trap the QueryComplete event. This event is fired when RDO detects that the first result set is ready for processing, or when the query has failed. This technique is preferable over polling the StillExecuting property.<br><br></li>
<li>
If you cannot create an event handler to notify your application that the asynchronous operation has completed, you can periodically poll the StillExecuting or StillConnecting properties to test for completion of the operation. This loop should include the DoEvents statement to permit other portions of your application to gain access to the processor (unless this is not possible because of other design considerations).<br><br></li>
<li>
Consider leveraging the workstation's processor to run an overlapping procedure that assumes completion of the previous operation. For example, you might do this in a situation where your application processes rows from an external file and passes these rows to a remote server as INSERT statements. During the time that a batch of INSERT statements is being processed by the remote server, your application could prepare the next batch to be sent. Once the first batch completed, the subsequent batch would be ready to process and the cycle could be repeated.</li>
</ul>
<p>
This drawing illustrates how to setup an asynchronous file import routine.</p>
<p class=label>
<b>Figure 11.2 Running overlapping procedures while waiting for an asynchronous operation</b></p>
<p>
<img src="avc33001.gif" border=0></p>
<p>
This technique leverages both the thread used to execute your query on the remote server and the thread available on the workstation.</p>
<h2>What You Can't Do While Waiting for an Asynchronous RDO Operation</h2>
<p>
As long as the asynchronous operation is still executing, you cannot reference the rdoResultset, rdoQuery, or rdoConnection object being processed — except for the properties and methods listed in the following table.</p>
<p class=label>
<b>Valid Properties and Methods During Asynchronous Operations</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows>
<tr valign=top>
<td class=label width=28%><b>Remote Data Object</b></td>
<td class=label width=72%><b>Valid Properties and Methods </b></td>
</tr>
<tr valign=top>
<td width=28%>rdoConnection</td>
<td width=72%>StillConnecting property; Cancel, Close methods</td>
</tr>
<tr valign=top>
<td width=28%>rdoQuery</td>
<td width=72%>StillExecuting property; Cancel, Close methods</td>
</tr>
<tr valign=top>
<td width=28%>rdoResultset </td>
<td width=72%>StillExecuting property; Cancel, Close methods</td>
</tr>
</table><br>
<p>
If you decide that you have waited long enough for an asynchronous operation to complete, you can choose to tell the remote processor to abandon the operation by using either the Cancel or Close methods.
<ul type=disc>
<li>
The Cancel method abandons the query operation.<br><br></li>
<li>
The Close method abandons the operation and discards the RDO object it is applied to.</li>
</ul>
<p>
Using one of these methods is not always prudent in cases where you have submitted complex multistatement or broad-scope update operations because database integrity could be compromised.</p>
</BODY>
</HTML>
