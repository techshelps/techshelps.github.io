<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Handling an Object's Events</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconhandlingobjectsevents"></a>Handling an Object's Events</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconHandlingObjectsEventsC">
</object></p>
<p>
An object that raises events is called an <i>event source. </i>To handle the events raised by an event source, you can declare a variable of the object's class using the WithEvents keyword.</p>
<p>
This topic continues the Widget object example begun in "Declaring and Raising Events." To handle the PercentDone event of a Widget, place the following code in the Declarations section of Form1:</p>
<pre><code>Option Explicit
Private WithEvents mWidget As Widget
Private mblnCancel As Boolean
</code></pre>
<p>
The WithEvents keyword specifies that the variable <code>mWidget</code> will be used to handle an object's events. You specify the kind of object by supplying the name of the class from which the object will be created.</p>
<p>
The variable <code>mWidget</code> is declared in the Declarations section of Form1 because WithEvents variables must be module-level variables. This is true regardless of the type of module you place them in.</p>
<p>
The variable <code>mblnCancel</code> will be used to cancel the LongTask method.</p>
<h4>Limitations on WithEvents Variables</h4>
<p>
You should be aware of the following limitations on the use of WithEvents variables:
<ul type=disc>
<li>
A WithEvents variable cannot be a generic object variable. That is, you cannot declare it As Object — you must specify the class name when you declare the variable.<br><br></li>
<li>
You cannot declare a WithEvents variable As New. The event source object must be explicitly created and assigned to the WithEvents variable.<br><br></li>
<li>
You cannot declare WithEvents variables in a standard module. You can declare them only in class modules, form modules, and other modules that define classes.<br><br></li>
<li>
You cannot create arrays of WithEvents variables.</li>
</ul>
<h3>Writing Code to Handle an Event</h3>
<p>
As soon as you declare a variable WithEvents, the variable name appears in the left-hand drop down of the module's code window. When you select <code>mWidget</code>, the Widget class's events will appear in the right-hand drop down, as shown in Figure 9.9.</p>
<p class=label>
<b>Figure 9.9&nbsp;&nbsp;&nbsp;An event associated with a WithEvents variable</b></p>
<p>
<img src="avp09010.gif" border=0></p>
<p>
Selecting an event will display the corresponding event procedure, with the prefix <code>mWidget_</code>. All the event procedures associated with a WithEvents variable will have the variable name as a prefix. Add the following code to the mWidget_PercentDone event procedure.</p>
<pre><code>Private Sub mWidget_PercentDone(ByVal Percent As _
Single, Cancel As Boolean)
   lblPercentDone.Caption = CInt(100 * Percent) &amp; "%"
   DoEvents
   If mblnCancel Then Cancel = True
End Sub
</code></pre>
<p>
Whenever the PercentDone event is raised, the event procedure displays the percent complete in a Label control. The DoEvents statement allows the label to repaint, and also gives the user the opportunity to click the Cancel button. Add the following code for the Click event of the button whose caption is Cancel.</p>
<pre><code>Private Sub Command2_Click()
   mblnCancel = True
End Sub
</code></pre>
<p>
If the user clicks the Cancel button while LongTask is running, the Command2_Click event will be executed as soon as the DoEvents statement allows event processing to occur. The module-level variable <code>mblnCancel</code> is set to True, and the mWidget_PercentDone event then tests it and sets the ByRef Cancel argument to True.</p>
<h3>Connecting a WithEvents Variable to an Object</h3>
<p>
Form1 is all set up to handle a Widget object's events. All that remains is to find a Widget somewhere.</p>
<p>
When you declare a variable WithEvents at design time, there is no object associated with it. A WithEvents variable is just like any other object variable. You have to create an object and assign a reference to the object to the WithEvents variable. Add the following code to the Form_Load event procedure to create the Widget.</p>
<pre><code>Private Sub Form_Load()
   Set mWidget = New Widget
End Sub
</code></pre>
<p>
When the code above is executed, Visual Basic creates a Widget and connects its events to the event procedures associated with <code>mWidget</code>. From that point on, whenever the Widget raises its PercentDone event, the mWidget_PercentDone event procedure will be executed.</p>
<p>
To call the LongTask method, add the following code to the Click event of the button whose caption is Start Task.</p>
<pre><code>' Start Task button.
Private Sub Command1_Click()
   mblnCancel = False
   lblPercentDone.Caption = "0%"
   lblPercentDone.Refresh

   Call mWidget.LongTask(14.4, 0.66)

   If Not mblnCancel Then lblPercentDone.Caption = 100
End Sub
</code></pre>
<p>
Before the LongTask method is called, the label that displays the percent complete must be initialized, and the module-level Boolean flag for canceling the method must be set to False.</p>
<p>
LongTask is called with a task duration of 14.4 seconds. The PercentDone event is to be raised once every two-thirds of a second. Each time the event is raised, the mWidget_PercentDone event procedure will be executed.</p>
<p>
When LongTask is done, <code>mblnCancel</code> is tested to see if LongTask ended normally, or if it stopped because <code>mblnCancel</code> was set to True. The percent complete is updated only for the former case.</p>
<h3>Running the Program</h3>
<p>
Press F5 to put the project in Run mode. Click the Start Task button. Each time the PercentDone event is raised, the label is updated with the percentage of the task that's complete. Click the Cancel button to stop the task. Notice that the appearance of the Cancel button doesn't change immediately when you click it. The Click event can't happen until the DoEvents statement allows event processing.</p>
<p>
You may find it instructive to run the program with F8, and step through the code a line at a time. You can clearly see how execution enters LongTask, and then re-enters Form1 briefly each time the PercentDone event is raised.</p>
<p>
What would happen if, while execution was back in Form1's code, the LongTask method was called again? Confusion, chaos, and eventually (if it happened every time the event was raised) a stack overflow.</p>
<h3>Handling Events for a Different Widget</h3>
<p>
You can cause the variable <code>mWidget</code> to handle events for a different Widget object by assigning a reference to the new Widget to <code>mWidget</code>. In fact, you can make the code in Command1 do this every time you click the button, by adding two lines of code:</p>
<pre><code>Set mWidget = New Widget      '&lt;- New line.
Call mWidget.LongTask(14.4, 0.66)
Set mWidget = Nothing         '&lt;- New line.
</code></pre>
<p>
The code above creates a new Widget each time the button is pressed. As soon as the LongTask method completes, the reference to the Widget is released by setting <code>mWidget</code> to Nothing, and the Widget is destroyed.</p>
<p>
A WithEvents variable can only contain one object reference at a time, so if you assign a different Widget object to <code>mWidget</code>, the previous Widget object's events will no longer be handled. If <code>mWidget</code> is the only object variable containing a reference to the old Widget, the object will be destroyed.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You can declare as many WithEvents variables as you need, but arrays of WithEvents variables are not supported.</p>
<h3>Terminating Event Handling for a WithEvents Variable</h3>
<p>
As long as there is a Widget object assigned to the variable <code>mWidget</code>, the event procedures associated with <code>mWidget</code> will be called whenever the Widget raises an event. To terminate event handling, you can set <code>mWidget</code> to Nothing, as shown in the following code fragment.</p>
<pre><code>' Terminate event handling for mWidget.
Set mWidget = Nothing
</code></pre>
<p>
When a WithEvents variable is set to Nothing, Visual Basic disconnects the object's events from the event procedures associated with the variable.</p>
<p class=indent>
<B><b>Important</b></B>&nbsp;&nbsp;&nbsp;A WithEvents variable contains an object reference, just like any other object variable. This object reference counts toward keeping the object alive. When you are setting all references to an object to Nothing in order to destroy it, don't forget the variables you declared WithEvents.</p>
<p>
<B><b>For More Information</b></B>&nbsp;&nbsp;&nbsp;The event procedures associated with WithEvents variables look a lot like event procedures for controls on forms. "Comparing WithEvents to Control Events on Forms" discusses the similarities and differences.</p>
</BODY>
</HTML>
