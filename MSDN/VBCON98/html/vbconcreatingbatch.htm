<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating and Changing an RDO Client Batch</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY>

<h1><a name="vbconcreatingbatch"></a>Creating and Changing an RDO Client Batch</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Font" value=",,,,underline">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="vbconCreatingBatchC">
</object></p>
<p>
If you set the CursorDriver to rdUseClientBatch, you can use the Client Batch cursor library with or without deferred batch updates. To choose the desired type of update operation, set the OpenResultset method's <b><i>LockType</i></b> argument as follows:
<ul type=disc>
<li>
rdConcurBatch to select deferred updates. In this case, the Update method simply posts changes to the current rdoResultset, but no changes are made to the underlying database tables until the BatchUpdate method is executed.<br><br></li>
<li>
Any of the other concurrency options. In this case the Update method immediately posts changes to the database on a row-by-row basis.</li>
</ul>
<h2>Dissociating the rdoResultset from its Connection</h2>
<p>
Once the rdoResultset is opened, you can begin making changes immediately. Or once you have fully populated a rdConcurBatch-style result set, you can dissociate the rdoResultset object from the current connection by setting the ActiveConnection property to Nothing. At this point you can make whatever additions, deletions, or updates on the individual rows are needed.</p>
<h2>Making Changes to the Result Set</h2>
<p>
To make these changes, simply use the Edit, Delete, and AddNew methods followed by the Update method to commit the changes. Once <i>all</i> changes have been made, use the BatchUpdate method to post the batch of changes to the database. The BatchUpdate method scans the rdoResultset, checking the Status property for each row — which is set to rdRowUnmodified for all unchanged rows. If the row has changed, as indicated by a Status <i>not</i> set to rdRowUnmodified, the Client Batch cursor library generates an SQL query to perform the changes. This query is concatenated together with all other SQL operations needed to synchronize the local result set with the data on the remote server. Once all operations are included, the batch is executed (passed to the remote server for execution).</p>
<h2>Setting the UpdateOperation Property</h2>
<p>
The UpdateOperation property determines how RDO and the client batch cursor library perform update operations on your data. Basically, you have two choices: either attempt to perform the update operation in a single step, or intentionally break up the operation into two separate operations — a delete followed by an insert.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Depending on your database triggers or other referential integrity checks, you might find it impossible to perform a separate delete operation.</p>
<p>
In many cases, update operations are handled internally by the database engine as a delete operation followed immediately by a corresponding insert — coupled as an atomic transaction. Unless your database engine is capable of "update in place" and your update operation conforms to the requirements of this type of update, the update will be executed as a delete followed by an insert.</p>
<p>
By choosing one of the following constants for the UpdateOperation property, you can determine how RDO and the Client Batch cursor library manage the update.
<ul type=disc>
<li>
<b>rdUpdate</b> (Default): Uses an UPDATE SQL statement for each modified row.<br><br></li>
<li>
<b>rdInsertDelete</b>. Uses a pair of SQL DELETE and INSERT statements for each modified row.</li>
</ul>
<p>
Even if you choose the rdInsertDelete option, the Client Batch cursor library encases the individual operations in a single transaction to ensure that if one operation fails, the entire operation is rolled back.</p>
<h2>Setting the UpdateCriteria Property </h2>
<p>
The UpdateCriteria property is used to control how the Client Batch cursor library determines if the row about to be updated has changed in the base tables. If some other user has changed the data while your code was editing the row, this property selects the technique that RDO uses to ensure that you don't inadvertently overlay other users' changes.</p>
<p>
By setting the UpdateCriteria property, you can determine how RDO builds the WHERE clause used to synchronize the local result set with the remote database tables. The BatchUpdate method creates an SQL statement for each row whose Status property is not rdRowUnmodified. Each of these statements includes a WHERE clause that uniquely identifies each row affected. By adjusting the UpdateCriteria property, you can adapt your application to deal with the update mechanism of your remote server. For example, in some servers, triggers might be fired unnecessarily if columns not affected by the changes you make are included in the SQL update.</p>
<p>
Just exactly how individual rows are identified is determined by the UpdateCriteria property as follows:
<ul type=disc>
<li>
<b>rdKey</b> (Default): Uses just the key column(s) in the WHERE clause. That is, RDO uses those columns you have designated as the primary keys — the columns that uniquely identify specific rows in the table(s).<br><br></li>
<li>
<b>rdKeyAndUpdatable.</b> Uses the key column(s) and all updated columns in the WHERE clause. In this case RDO also adds the columns that were changed to the WHERE clause to ensure that the rows have indeed changed.<br><br></li>
<li>
<b>rdKeyAndModified.</b> Uses the key column(s) and all the columns in the WHERE clause. In this case RDO includes the key and all other columns to the WHERE clause to ensure that the rows have indeed changed.<br><br></li>
<li>
<b>rdKeyAndTimestamp.</b> Uses just the TIMESTAMP column if available (will generate a run-time error if no TIMESTAMP column is in the result set). This option compares the existing TIMESTAMP column with the column in the database to determine if the value has changed.</li>
</ul>
<p class=indent>
<B><b>Tip</b></B>&nbsp;&nbsp;&nbsp;If you are using SQL Server 6.5, you can use the SQLTrace utility to observe how RDO builds the WHERE clause when making a batch update.</p>
</BODY>
</HTML>
