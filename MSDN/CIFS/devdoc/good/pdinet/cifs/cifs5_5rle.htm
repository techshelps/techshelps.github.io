<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WRITE_MPX: Write Block Multiplex</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_cifs_132"></a><i></i>WRITE_MPX: Write Block Multiplex</h2>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=50%>Client Request<br>
==================================</td>
<td width=50%>Description<br>
=================================</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR WordCount;</td>
<td width=50%>Count of parameter words = 12</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Fid;</td>
<td width=50%>File handle</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Count;</td>
<td width=50%>Total bytes, including this buffer</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Reserved;</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%>ULONG Offset;</td>
<td width=50%>Offset in file to begin write</td>
</tr>
<tr valign=top>
<td width=50%>ULONG Timeout;</td>
<td width=50%>milliseconds to wait for completion</td>
</tr>
<tr valign=top>
<td width=50%>USHORT WriteMode;</td>
<td width=50%>Write mode:</td>
</tr>
<tr valign=top>
<td width=50%></td>
<td width=50%>bit 0 - complete write to disk and send final result response</td>
</tr>
<tr valign=top>
<td width=50%></td>
<td width=50%>bit 1 - return Remaining</td>
</tr>
<tr valign=top>
<td width=50%></td>
<td width=50%>bit 7 - Connectionless mode</td>
</tr>
<tr valign=top>
<td width=50%>ULONG RequestMask;</td>
<td width=50%>Connectionless mode mask</td>
</tr>
<tr valign=top>
<td width=50%>USHORT DataLength;</td>
<td width=50%>Number of data bytes this buffer</td>
</tr>
<tr valign=top>
<td width=50%>USHORT DataOffset;</td>
<td width=50%>Offset (from header start) to data</td>
</tr>
<tr valign=top>
<td width=50%>USHORT ByteCount;</td>
<td width=50%>Count of data bytes</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR Pad[];</td>
<td width=50%>Pad to SHORT or LONG</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR Data[];</td>
<td width=50%>Data (# = DataLength)</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=50%>Server Response<br>
==================================</td>
<td width=50%>Description<br>
=================================</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR WordCount;</td>
<td width=50%>Count of parameter words = 1</td>
</tr>
<tr valign=top>
<td width=50%>ULONG ResponseMask;</td>
<td width=50%>OR of all masks received</td>
</tr>
<tr valign=top>
<td width=50%>USHORT ByteCount;</td>
<td width=50%>Count of data bytes = 0</td>
</tr>
</table><br>
<p>
SMB_COM_WRITE_MPX is used to maximize the performance of writing a large block of data from the client to the server.  The NT server supports SMB_COM_WRITE_MPX only over connectionless transports, consequently <i>bit7</i> of <i>writemode</i> in the request must be set.</p>
<p>
<i>fid</i> in the request must refer to either a file or a spooled printer.</p>
<p>
<i>mask</i> contains a bit mask indicating where in the transfer that the SMB belongs.  The  response which contains the logical OR of all of the <i>mask</i> values received and is always generated.  All in this exchange use the same SMB header <i>mid</i> value but only final message is a connectionless sequenced request (<i>sequencenumber</i> is non-zero).</p>
<p>
The server keeps a <i>responsemask</i> which is the logical or-ing of the <i>requestmask</i> value contained in each SMB_COM_WRITE_MPX received since the last sequenced SMB_COM_WRITE_MPX.  The server only responds to the final (sequenced) command, and this response contains the accumulated <i>responsemask</i>. The client uses the <i>responsemask</i> received to determine which packets, if any, must be retransmitted.  The server imposes no restrictions on the values in the mask nor upon the order or contiguity of the data being sent.  The client uses this behavior to only send the missing parts in the next write sequence when retransmitting.  The next SMB_COM_WRITE_MPX sequence sent must use a new <i>sequencenumber</i> value or the server will incorrectly respond with the mask from the previous SMB_COM_WRITE_MPX command.</p>
<p>
The flow is:</p>
<table border=1 cellspacing=4 cols=4 frame=box rules=cols>
<tr valign=top>
<td width=33%>Client<br>
<br>
=================</td>
<td width=18%>Sequence<br>
Number<br>
=========</td>
<td width=10%>&lt;-&gt;<br>
<br>
====</td>
<td width=39%>Server<br>
<br>
=====================</td>
</tr>
<tr valign=top>
<td width=33%><code>SMB_COM_WRITE_MPX</code></td>
<td width=18%><code>0</code></td>
<td width=10%><code>-&gt;</code></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%><code>SMB_COM_WRITE_MPX</code></td>
<td width=18%><code>0</code></td>
<td width=10%><code>-&gt;</code></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%><code>...</code></td>
<td width=18%></td>
<td width=10%></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%><code>SMB_COM_WRITE_MPX</code></td>
<td width=18%><code>S</code></td>
<td width=10%><code>-&gt;</code></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=18%><code>S</code></td>
<td width=10%><code>&lt;-</code></td>
<td width=39%><code>SMB_COM_WRITE_MPX OK</code></td>
</tr>
<tr valign=top>
<td width=33%><code>SMB_COM_WRITE_MPX</code></td>
<td width=18%><code>0</code></td>
<td width=10%><code>-&gt;</code></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%><code>SMB_COM_WRITE_MPX</code></td>
<td width=18%><code>0</code></td>
<td width=10%><code>-&gt;</code></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%><code>....</code></td>
<td width=18%></td>
<td width=10%></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%><code>SMB_COM_WRITE_MPX</code></td>
<td width=18%><code>S+1</code></td>
<td width=10%><code>-&gt;</code></td>
<td width=39%></td>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=18%><code>S+1</code></td>
<td width=10%><code>&lt;-</code></td>
<td width=39%><code>SMB_COM_WRITE_MPX OK</code></td>
</tr>
</table><br>
<p>
Other SMB requests can intervene during this protocol exchange.</p>
<p>
A server response will be generated only after the sequenced SMB_COM_WRITE_MPX has been received unless this SMB is received over a connection oriented transport (in which case the error response is immediately sent).</p>
<p>
At the time of the request, the client knows the number of data bytes expected to be sent and passes this information to the server in <i>count.</i>  The server can use this information to reserve buffer space, if possible.</p>
<p>
If <i>bit0</i> of <i>writemode</i> is clear, the request assumed to be a form of write behind on the part of the client.  If an error occurs while writing data to disk such as disk full, the next access of the file handle (another write, close, read, etc.) will return the fact that the error occurred.  If <i>bit0</i> of <i>writemode</i> is set, the server will collect all the data, write it to disk and then send a final response indicating the result of the write .  The total number of bytes written is also returned in this response.</p>
<p>&nbsp;</p></body>
</HTML>
