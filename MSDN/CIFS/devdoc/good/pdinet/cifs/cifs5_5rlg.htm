<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WRITE_RAW: Write Raw Bytes</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_cifs_134"></a><i></i>WRITE_RAW: Write Raw Bytes </h2>
<p>
The Write Block Raw protocol is used to maximize the performance of writing a large block of data from the client to the server.  The Write Block Raw command's scope includes files, Named Pipes, and spooled output (can be used in place COM_WRITE_PRINT_FILE ).</p>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=39%>Client Request<br>
==========================</td>
<td width=61%>Description<br>
=========================================</td>
</tr>
<tr valign=top>
<td width=39%>UCHAR WordCount;</td>
<td width=61%>Count of parameter words = 12</td>
</tr>
<tr valign=top>
<td width=39%>USHORT Fid;</td>
<td width=61%>File handle</td>
</tr>
<tr valign=top>
<td width=39%>USHORT Count;</td>
<td width=61%>Total bytes, including this buffer</td>
</tr>
<tr valign=top>
<td width=39%>USHORT Reserved;</td>
<td width=61%></td>
</tr>
<tr valign=top>
<td width=39%>ULONG Offset;</td>
<td width=61%>Offset in file to begin write</td>
</tr>
<tr valign=top>
<td width=39%>ULONG Timeout;</td>
<td width=61%></td>
</tr>
<tr valign=top>
<td width=39%>USHORT WriteMode;</td>
<td width=61%>Write mode:</td>
</tr>
<tr valign=top>
<td width=39%></td>
<td width=61%>bit 0 - complete write to disk and send final result response</td>
</tr>
<tr valign=top>
<td width=39%></td>
<td width=61%>bit 1 - return Remaining (pipe/dev)</td>
</tr>
<tr valign=top>
<td width=39%></td>
<td width=61%>(see WriteAndX for #defines)</td>
</tr>
<tr valign=top>
<td width=39%>ULONG Reserved2;</td>
<td width=61%></td>
</tr>
<tr valign=top>
<td width=39%>USHORT DataLength;</td>
<td width=61%>Number of data bytes this buffer</td>
</tr>
<tr valign=top>
<td width=39%>USHORT DataOffset;</td>
<td width=61%>Offset (from header start) to data</td>
</tr>
<tr valign=top>
<td width=39%>USHORT ByteCount;</td>
<td width=61%>Count of data bytes</td>
</tr>
<tr valign=top>
<td width=39%>UCHAR Pad[];</td>
<td width=61%>Pad to SHORT or LONG</td>
</tr>
<tr valign=top>
<td width=39%>UCHAR Data[];</td>
<td width=61%>Data (# = DataLength)</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=45%>First Server Response<br>
==============================</td>
<td width=55%>Description<br>
=====================================</td>
</tr>
<tr valign=top>
<td width=45%>UCHAR WordCount;</td>
<td width=55%>Count of parameter words = 1</td>
</tr>
<tr valign=top>
<td width=45%>USHORT Remaining;</td>
<td width=55%>Bytes remaining to be read if pipe</td>
</tr>
<tr valign=top>
<td width=45%>USHORT ByteCount;</td>
<td width=55%>Count of data bytes = 0</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=50%>Final Server Response<br>
==================================</td>
<td width=50%>Description<br>
=================================</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR Command (in SMB header)</td>
<td width=50%>SMB_COM_WRITE_COMPLETE</td>
</tr>
<tr valign=top>
<td width=50%></td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%>UCHAR WordCount;</td>
<td width=50%>Count of parameter words = 1</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Count;</td>
<td width=50%>Total number of bytes written</td>
</tr>
<tr valign=top>
<td width=50%>USHORT ByteCount;</td>
<td width=50%>Count of data bytes = 0</td>
</tr>
</table><br>
<p>
The first response format will be that of the final server response in the case where the server gets an error while writing the data sent along with the request.  Thus <i>count</i> is the number of bytes which did get written any time an error is returned.  If an error occurs after the first response has been sent allowing the client to send the remaining data, the final response should not be sent unless write through is set.  Rather the server should return this "write behind" error on the next access to the <i>fid</i>.</p>
<p>
The client must guarantee that there is (and will be) no other request on the connection for the duration of this request.  The server will reserve enough resources to receive the data and respond with a response SMB as defined above.  The client then sends the raw data in one send.  Thus the server is able to receive up to 65,535 bytes of data directly into the server buffer.  The amount of data transferred is expected to be larger than the negotiated buffer size for this protocol.</p>
<p>
The reason that no other requests can be active on the connection for the duration of the request is that if other receives are present on the connection, there is normally no way to guarantee that the data will be received into the correct server buffer, rather the data may fill one (or more) of the other buffers.  Also if the client is sending other requests on the connection, a request may land in the buffer that the server has allocated for the this SMB's data.</p>
<p>
Whether or not SMB_COM_WRITE_RAW is supported is returned in the response to SMB_COM_NEGOTIATE.  SMB_COM_WRITE_RAW is not supported for connectionless clients.</p>
<p>
When write through is not specified ((<i>writemode</i> &amp; 01) == 0) this SMB is assumed to be a form of write behind.  The transport layer guarantees delivery of all secondary requests from the client.  Thus no "got the data you sent" SMB is needed.  If an error should occur at the server end, all bytes must be received and thrown away.  If an error occurs while writing data to disk such as disk full, the next access of the file handle (another write, close, read, etc.) will return the fact that the error occurred.</p>
<p>
If write through is specified ((<i>writemode</i> &amp; 01) != 0), the server will receive the data, write it to disk and then send a final response indicating the result of the write.  The total number of bytes written is also returned in this response in the <i>count</i> field.</p>
<p>
The flow for the SMB_COM_WRITE_RAW SMB is:</p>
<pre><code>client -----&gt; SMB_COM_WRITE_RAW request (optional data) &gt;-------&gt; server
client &lt;------------------&lt; OK send (more) data &lt;---------------- server
client  ----------------------&gt; raw data &gt;----------------------&gt; server
client  &lt;---&lt; data on disk or error (write through only) &lt;------- server
</code></pre>
<p>
This protocol is set up such that the SMB_COM_WRITE_RAW request may also carry data.  This is an optimization in that up to the server's buffer size (<i>maxcount</i> from SMB_COM_NEGOTIATE response), minus the size of the SMB_COM_WRITE_RAW SMB request, may be sent along with the request.  Thus if the server is busy and unable to support the raw write of the remaining data, the data sent along with the request has been delivered and need not be sent again.  The server will write any data sent in the request (and wait for it to be on the disk or device if write through is set), prior to sending the response.</p>
<p>
The specific responses error class ERRSRV, error codes ERRusempx and ERRusestd, indicate that the server is temporarily out of the resources needed to support the raw write of the remaining data, but that any data sent along with the request has been successfully written.  The client should then write the remaining data using a different type of SMB write request, or delay and retry using SMB_COM_WRITE_RAW.  If a write error occurs writing the initial data, it will be returned and the write raw request is implicitly denied.</p>
<p>
The return field <i>remaining</i> is returned for named pipes only.  It is used to return the number of bytes currently available in the pipe.  This information can then be used by the client to know when a subsequent (non blocking) read of the pipe may return some data.  Of course when the read request is actually received by the server there may be more or less actual data in the pipe (more data has been written to the pipe / device or another reader drained it).  If the information is currently not available or the request is NOT for a pipe or the server does not support this feature, a -1 value should be returned.</p>
<p>
If the negotiated dialect is <code>NT LM 0.12</code> or later, and the response to the SMB_COM_NEGOTIATE SMB has CAP_LARGE_FILES set in the <i>capabilities</i> field, an additional request format is allowed which accommodates very large files having 64 bit offsets:</p>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=50%>Client Request<br>
==================================</td>
<td width=50%>Description<br>
=================================</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR WordCount;</td>
<td width=50%>Count of parameter words = 14</td>
</tr>
<tr valign=top>
<td width=50%> USHORT Fid;</td>
<td width=50%>File handle</td>
</tr>
<tr valign=top>
<td width=50%> USHORT Count;</td>
<td width=50%>Total bytes, including this buffer</td>
</tr>
<tr valign=top>
<td width=50%> USHORT Reserved;</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%> ULONG Offset;</td>
<td width=50%>Offset in file to begin write</td>
</tr>
<tr valign=top>
<td width=50%> ULONG Timeout;</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%> USHORT WriteMode;</td>
<td width=50%>Write mode:</td>
</tr>
<tr valign=top>
<td width=50%>  </td>
<td width=50%>bit 0 - complete write to disk and send final result response</td>
</tr>
<tr valign=top>
<td width=50%></td>
<td width=50%>bit 1 - return Remaining (pipe/dev)</td>
</tr>
<tr valign=top>
<td width=50%> ULONG Reserved2;</td>
<td width=50%></td>
</tr>
<tr valign=top>
<td width=50%> USHORT DataLength;</td>
<td width=50%>Number of data bytes this buffer</td>
</tr>
<tr valign=top>
<td width=50%> USHORT DataOffset;</td>
<td width=50%>Offset (from header start) to data</td>
</tr>
<tr valign=top>
<td width=50%> ULONG OffsetHigh;</td>
<td width=50%>Upper 32 bits of offset</td>
</tr>
<tr valign=top>
<td width=50%>USHORT ByteCount;</td>
<td width=50%>Count of data bytes</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR Pad[];</td>
<td width=50%>Pad to SHORT or LONG</td>
</tr>
<tr valign=top>
<td width=50%> UCHAR Data[];</td>
<td width=50%>Data (# = DataLength)</td>
</tr>
</table><br>
<p>
In this case the final offset in the file is formed by combining <i>offsethigh</i> and <i>offset</i>, the resulting offset must not be negative.</p>
<p>&nbsp;</p></body>
</HTML>
