<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOCKING_ANDX:  Lock or Unlock Byte Ranges</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_cifs_77"></a>LOCKING_ANDX:  Lock or Unlock Byte Ranges</h3>
<p>
SMB_COM_LOCKING_ANDX allows both locking and/or unlocking of file range(s).</p>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=50%>Client Request<br>
==================================</td>
<td width=50%>Description<br>
=================================</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR WordCount;</td>
<td width=50%>Count of parameter words = 8</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR AndXCommand;</td>
<td width=50%>Secondary (X) command;  0xFF = none</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR AndXReserved;</td>
<td width=50%>Reserved (must be 0)</td>
</tr>
<tr valign=top>
<td width=50%>USHORT AndXOffset;</td>
<td width=50%>Offset to next command WordCount</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Fid;</td>
<td width=50%>File handle</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR LockType;</td>
<td width=50%>See LockType table below</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR OplockLevel;</td>
<td width=50%>The new oplock level</td>
</tr>
<tr valign=top>
<td width=50%>ULONG Timeout;</td>
<td width=50%>Milliseconds to wait for unlock</td>
</tr>
<tr valign=top>
<td width=50%>USHORT NumberOfUnlocks;</td>
<td width=50%>Num. unlock range structs following</td>
</tr>
<tr valign=top>
<td width=50%>USHORT NumberOfLocks;</td>
<td width=50%>Num. lock range structs following</td>
</tr>
<tr valign=top>
<td width=50%>USHORT ByteCount;</td>
<td width=50%>Count of data bytes</td>
</tr>
<tr valign=top>
<td width=50%>LOCKING_ANDX_RANGE Unlocks[];</td>
<td width=50%>Unlock ranges</td>
</tr>
<tr valign=top>
<td width=50%>LOCKING_ANDX_RANGE Locks[];</td>
<td width=50%>Lock ranges</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=3 frame=box rules=cols>
<tr valign=top>
<td width=42%>LockType Flag Name<br>
============================</td>
<td width=10%>Value<br>
=====</td>
<td width=48%>Description<br>
================================</td>
</tr>
<tr valign=top>
<td width=42%><code>LOCKING_ANDX_SHARED_LOCK</code></td>
<td width=10%>0x01</td>
<td width=48%>Read-only lock</td>
</tr>
<tr valign=top>
<td width=42%><code>LOCKING_ANDX_OPLOCK_RELEASE</code></td>
<td width=10%>0x02</td>
<td width=48%>Oplock break notification</td>
</tr>
<tr valign=top>
<td width=42%><code>LOCKING_ANDX_CHANGE_LOCKTYPE</code></td>
<td width=10%>0x04</td>
<td width=48%>Change lock type</td>
</tr>
<tr valign=top>
<td width=42%><code>LOCKING_ANDX_CANCEL_LOCK</code></td>
<td width=10%>0x08</td>
<td width=48%>Cancel outstanding request</td>
</tr>
<tr valign=top>
<td width=42%><code>LOCKING_ANDX_LARGE_FILES</code></td>
<td width=10%>0x10</td>
<td width=48%>Large file locking format</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td colspan=2 width=100%>LOCKING_ANDX_RANGE Format<br>
=====================================================================</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Pid;</td>
<td width=50%>PID of process "owning" lock</td>
</tr>
<tr valign=top>
<td width=50%>ULONG Offset;</td>
<td width=50%>Offset to bytes to [un]lock</td>
</tr>
<tr valign=top>
<td width=50%>ULONG Length;</td>
<td width=50%>Number of bytes to [un]lock</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td colspan=2 width=100%>Large File LOCKING_ANDX_RANGE Format<br>
=====================================================================</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Pid;</td>
<td width=50%>PID of process "owning" lock</td>
</tr>
<tr valign=top>
<td width=50%>USHORT Pad;</td>
<td width=50%>Pad to DWORD align (mbz)</td>
</tr>
<tr valign=top>
<td width=50%>ULONG OffsetHigh;</td>
<td width=50%>Offset to bytes to [un]lock (high)</td>
</tr>
<tr valign=top>
<td width=50%>ULONG OffsetLow;</td>
<td width=50%>Offset to bytes to [un]lock (low)</td>
</tr>
<tr valign=top>
<td width=50%>ULONG LengthHigh;</td>
<td width=50%>Number of bytes to [un]lock (high)</td>
</tr>
<tr valign=top>
<td width=50%>ULONG LengthLow;</td>
<td width=50%>Number of bytes to [un]lock (low)</td>
</tr>
</table><br>
<table border=1 cellspacing=4 cols=2 frame=box rules=cols>
<tr valign=top>
<td width=50%>Server Response<br>
==================================</td>
<td width=50%>Description<br>
=================================</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR WordCount;</td>
<td width=50%>Count of parameter words = 2</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR AndXCommand;</td>
<td width=50%>Secondary (X) command;  0xFF = none</td>
</tr>
<tr valign=top>
<td width=50%>UCHAR AndXReserved;</td>
<td width=50%>Reserved (must be 0)</td>
</tr>
<tr valign=top>
<td width=50%>USHORT AndXOffset;</td>
<td width=50%>Offset to next command WordCount</td>
</tr>
<tr valign=top>
<td width=50%>USHORT ByteCount;</td>
<td width=50%>Count of data bytes = 0</td>
</tr>
</table><br>
<p>
Locking is a simple mechanism for excluding other processes read/write access to regions of a file.  The locked regions can be anywhere in the logical file.  Locking beyond end-of-file is permitted.  Any process using the <i>fid</i> specified in this request's <i>fid</i> has access to the locked bytes, other processes will be denied the locking of the same bytes.</p>
<p>
The proper method for using locks is not to rely on being denied read or write access on any of the read/write protocols but rather to attempt the locking protocol and proceed with the read/write only if the locks succeeded.</p>
<p>
Locking a range of bytes will fail if any subranges or overlapping ranges are locked.  In other words, if any of the specified bytes are already locked, the lock will fail.</p>
<p>
If <i>numberofunlocks</i> is non-zero, the <i>unlocks</i> vector contains <i>numberofunlocks</i> elements.  Each element requests that a lock at <i>offset</i> of <i>length</i> be released.  If <i>numberoflocks</i> is nonzero, the <i>locks</i> vector contains <i>numberoflocks</i> elements.  Each element requests the acquisition of a lock at <i>offset</i> of <i>length</i>.</p>
<p>
<i>timeout</i> is the maximum amount of time to wait for the byte range(s) specified to become unlocked.  A timeout value of 0 indicates that the server should fail immediately if any lock range specified is locked.  A timeout value of -1 indicates that the server should wait as long as it takes for each byte range specified to become unlocked so that it may be again locked by this protocol.  Any other value of smb_timeout specifies the maximum number of milliseconds to wait for all lock range(s) specified to become available.</p>
<p>
If any of the lock ranges timeout because of the area to be locked is already locked (or the lock fails), the other ranges in the protocol request which were successfully locked as a result of this protocol will be unlocked (either all requested ranges will be locked when this protocol returns to the client or none).</p>
<p>
If <i>locktype</i> has the <code>LOCKING_ANDX_SHARED_LOCK</code> flag set, the lock is specified as a shared lock.  Locks for both read and write (where<code> LOCKING_ANDX_SHARED_LOCK</code> is clear) should be prohibited, but other shared locks should be permitted.  If shared locks can not be supported by a server, the server should map the lock to a lock for both read and write.  Closing a file with locks still in force causes the locks to be released in no defined order.</p>
<p>
If <i>locktype</i> has the <code>LOCKING_ANDX_LARGE_FILES</code> flag set and if the negotiated protocol is <code>NT LM 0.12</code> or later, then the Locks and Unlocks vectors are in the Large File <code>LOCKING_ANDX_RANGE</code> format.  This allows specification of 64 bit offsets for very large files.</p>
<p>
If the one and only member of the <i>locks</i> vector has the <code>LOCKING_ANDX_CANCEL_LOCK</code> flag set in the <i>locktype</i> field, the client is requesting the server to cancel a previously requested, but not yet responded to, lock.</p>
<p>
If LockType has the <code>LOCKING_ANDX_CHANGE_LOCKTYPE</code> flag set, the client is requesting that the server atomically change the lock type from a shared lock to an exclusive lock or vice versa.  If the server can not do this in an atomic fashion, the server must reject this request.  NT and W95 servers do not support this capability.</p>
<p>
Oplocks are described in the "Opportunistic Locks" section elsewhere in this document.  A client requests an oplock by setting the appropriate bit in the SMB_COM_OPEN_ANDX request when the file is being opened in a mode which is not exclusive.  The server responds by setting the appropriate bit in the response SMB indicating whether or not the oplock was granted.  By granting the oplock, the server tells the client the file is currently only being used by this one client process at the current time.  The client can therefore safely do read ahead and write behind as well as local caching of file locks knowing that the file will not be accessed/changed in any way by another process while the oplock is in effect.  The client will be notified when any other process attempts to open or modify the oplocked file.</p>
<p>
When another user attempts to open or otherwise modify the file which a client has oplocked, the server delays the second attempt and notifies the client via an <code>SMB_LOCKING_ANDX SMB</code> asynchronously sent from the server to the client.  This message has the <code>LOCKING_ANDX_OPLOCK_RELEASE</code> flag set indicating to the client that the oplock is being broken. <i>oplocklevel</i> indicates the type of oplock the client now owns. If <i>oplocklevel</i> is 0, the client possesses no oplocks on the file at all, if <i>oplocklevel</i> is 1 the client possesses a Level II oplock.  The client is expected to flush any dirty buffers to the server, submit any file locks and respond to the server with either an <code>SMB_LOCKING_ANDX</code> SMB having the <code>LOCKING_ANDX_OPLOCK_RELEASE</code> flag set, or with a file close if the file is no longer in use by the client.  If the client sends an <code>SMB_LOCKING_ANDX</code> SMB with the<code> LOCKING_ANDX_OPLOCK_RELEASE</code> flag set and <i>numberoflocks</i> is zero, the server does not send a response.  Since a close being sent to the server and break oplock notification from the server could cross on the wire, if the client gets an oplock notification on a file which it does not have open, that notification should be ignored.</p>
<p>
Due to timing, the client could get an "oplock broken" notification in a user's data buffer as a result of this notification crossing on the wire with a <code>SMB_COM_READ_RAW</code> request.  The client must detect this (use length of msg, "FFSMB", MID of -1 and <i>command</i> of <code>SMB_COM_LOCKING_ANDX</code>) and honor the "oplock broken" notification as usual.  The server must also note on receipt of an <code>SMB_COM_READ_RAW</code> request that there is an outstanding (unanswered) "oplock broken" notification to the client and return a zero length response denoting failure of the read raw request.  The client should (after responding to the "oplock broken" notification), use a standard read protocol to redo the read request.  This allows a file to actually contain data matching an "oplock broken" notification and still be read correctly.</p>
<p>
The entire message sent and received including the optional second protocol must fit in the negotiated maximum transfer size.  The following are the only valid SMB commands for <i>andxcommand</i> for SMB_COM_LOCKING_ANDX:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=41%>SMB_COM_READ</td>
<td width=59%>SMB_COM_READ_ANDX</td>
</tr>
<tr valign=top>
<td width=41%>SMB_COM_WRITE</td>
<td width=59%>SMB_COM_WRITE_ANDX</td>
</tr>
<tr valign=top>
<td width=41%>SMB_COM_FLUSH</td>
<td width=59%></td>
</tr>
</table><br>
<h4>Errors</h4>
<p>
ERRDOS/ERRbadfile<br>
ERRDOS/ERRbadfid<br>
ERRDOS/ERRlock<br>
ERRDOS/ERRinvdevice<br>
ERRSRV/ERRinvid<br>
ERRSRV/ERRbaduid</p>
<p>&nbsp;</p></body>
</HTML>
