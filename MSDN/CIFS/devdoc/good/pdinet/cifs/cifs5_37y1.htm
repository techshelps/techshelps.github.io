<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Functional Description</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_cifs_59"></a>Functional Description</h3>
<p>
The <code>SMB_COM_TRANSACTION</code> command's scope includes named pipes and mailslots.  Where the resource is unidirectional (such as class 2 writes to mailslots), <i>bit1</i> of <i>Flags</i> in the request can be set indicating that no response is needed.  The other transactions accommodate <code>IOCTL</code> requests and file system requests which require the transfer of an extended attribute list.</p>
<p>
The transaction <i>Setup</i> information and/or <i>Parameters</i> define functions specific to a particular resource on a particular server.  Therefore the functions supported are not defined by the protocol, but by client and server implementations.  The transaction protocol simply provides a means of delivering them and retrieving the results.</p>
<p>
The number of bytes needed in order to perform the transaction request may be more than will fit in a single buffer.</p>
<p>
At the time of the request, the client knows the number of parameter and data bytes expected to be sent and passes this information to the server via the primary request (<i>TotalParameterCount</i> and <i>TotalDataCount</i>).  This may be reduced by lowering the total number of bytes expected (<i>TotalParameterCount</i> and <i>TotalDataCount</i>) in each (if any) secondary request.</p>
<p>
When the amount of parameter bytes received (total of each <i>ParameterCount</i>) equals the total amount of parameter bytes expected (smallest <i>TotalParameterCount</i>) received, then the server has received all the parameter bytes.</p>
<p>
Likewise, when the amount of data bytes received (total of each <i>datacount</i>) equals the total amount of data bytes expected (smallest <i>totaldatacount</i>) received, then the server has received all the data bytes.</p>
<p>
The parameter bytes should normally be sent first followed by the data bytes.  However, the server knows where each begins and ends in each buffer by the offset fields (<i>parameteroffset</i> and <i>dataoffset</i>) and the length fields (<i>parametercount</i> and <i>datacount</i>).  The displacement of the bytes (relative to start of each) is also known (<i>parameterdisplacement</i> and <i>datadisplacement</i>).  Thus the server is able to reassemble the parameter and data bytes should the individual requests be received out of sequence.</p>
<p>
If all parameter bytes and data bytes fit into a single buffer, then no interim response is expected and no secondary request is sent.</p>
<p>
The client knows the maximum amount of data bytes and parameter bytes which the server may return (from <i>maxparametercount</i> and <i>maxdatacount</i> of the request).  Thus the client initializes its bytes expected variables to these values.  The server then informs the client of the actual amounts being returned via each message of the server response (<i>totalparametercount</i> and <i>totaldatacount</i>).  The server may reduce the expected bytes by lowering the total number of bytes expected (<i>totalparametercount</i> and/or <i>totaldatacount</i>) in each (any) response.</p>
<p>
When the amount of parameter bytes received (total of each <i>parametercount</i>) equals the total amount of parameter bytes expected (smallest <i>totalparametercount</i>) received, then the client has received all the parameter bytes.</p>
<p>
Likewise, when the amount of data bytes received (total of each <i>datacount</i>) equals the total amount of data bytes expected (smallest <i>totaldatacount</i>) received, then the client has received all the data bytes.</p>
<p>
The parameter bytes should normally be returned first followed by the data bytes.  However, the client knows where each begins and ends in each buffer by the offset fields (<i>parameteroffset</i> and <i>dataoffset</i>) and the length fields (<i>parametercount</i> and <i>datacount</i>).  The displacement of the bytes (relative to start of each) is also known (<i>parameterdisplacement</i> and <i>datadisplacement</i>).  The client is able to reassemble the parameter and data bytes should the server responses be received out of sequence.</p>
<p>
If a connectionless transport is being used, the transaction requests must be properly sequenced in the <i>connectionless.sequencenumber</i> SMB header field.  The <i>mid</i> of any secondary client requests must match the <i>mid</i> of the primary client request.  The server responds to each request piece except the last one with a response indicating that the server is ready for the next piece.  The last piece is responded to with the first piece of the result data.  The client then sends an <code>SMB_COM_TRANSACTION_SECONDARY</code> SMB with <i>parameterdisplacement</i> set to the number of parameter bytes received so far and <i>datadisplacement</i> set to the number of data bytes received so far and <i>parametercount</i>, <i>parameteroffset</i>, <i>datacount</i>, and <i>dataoffset </i>set to zero (0).  The server responds with the next piece of the transaction result.  The process is repeated until all of the response information has been received.  When the transaction has been completed, the client must send another sequenced command (such as an <code>SMB_COM_ECHO</code>) to the server to allow the server to know that the final piece was received and that resources allocated to the transaction command may be released.</p>
<p>
The flow for these transactions over a connection oriented transport is:
<ol>
<li>
The client sends the primary client request identifying the total bytes (both parameters and data) which are expected to be sent and contains the set up words and as many of the parameter and data bytes as will fit in a negotiated size buffer.  This request also identifies the maximum number of bytes (setup, parameters and data) the server is to return on the transaction completion.  If all the bytes fit in the single buffer, skip to step 4.</li>
<li>
The server responds with a single interim response meaning "OK, send the remainder of the bytes" or (if error response) terminate the transaction.</li>
<li>
The client then sends another buffer full of bytes to the server.  This step is repeated until all of the bytes are sent and received.</li>
<li>
The Server sets up and performs the transaction with the information provided.</li>
<li>
Upon completion of the transaction, the server sends back (up to) the number of parameter and data bytes requested (or as many as will fit in the negotiated buffer size).  This step is repeated until all result bytes have been returned.</li>
</ol>
<p>
The flow for the transaction protocol when the request parameters and data do not all fit in a single buffer is:</p>
<table border=1 cellspacing=4 cols=3 frame=box rules=cols>
<tr valign=top>
<td width=46%>Client<br>
===============================</td>
<td width=8%>&lt;-&gt;<br>
====</td>
<td width=46%>Server<br>
==============================</td>
</tr>
<tr valign=top>
<td width=46%><code>Primary TRANSACTION request</code></td>
<td width=8%><code>-&gt;</code></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%>Interim Server Response</td>
</tr>
<tr valign=top>
<td width=46%><code>Secondary TRANSACTION request 1</code></td>
<td width=8%><code>-&gt;</code></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%><code>Secondary TRANSACTION request 2</code></td>
<td width=8%><code>-&gt;</code></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%><code>Secondary TRANSACTION request N</code></td>
<td width=8%><code>-&gt;</code></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%><code>TRANSACTION</code> response 1</td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%><code>TRANSACTION</code> response 2</td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%><code>TRANSACTION</code> response m</td>
</tr>
</table><br>
<p>
The flow for the transaction protocol when the request parameters and data does all fit in a single buffer is:</p>
<table border=1 cellspacing=4 cols=3 frame=box rules=cols>
<tr valign=top>
<td width=46%>Client<br>
===============================</td>
<td width=8%>&lt;-&gt;<br>
====</td>
<td width=46%>Server<br>
==============================</td>
</tr>
<tr valign=top>
<td width=46%><code>Primary TRANSACTION request</code></td>
<td width=8%><code>-&gt;</code></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%><code>TRANSACTION</code> response 1</td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%><code>TRANSACTION</code> response 2</td>
</tr>
<tr valign=top>
<td width=46%></td>
<td width=8%><code>&lt;-</code></td>
<td width=46%><code>TRANSACTION</code> response m</td>
</tr>
</table><br>
<p>
The flow for the transaction protocol over a connectionless transport is:
<ol>
<li>
The client sends the primary client request identifying the total bytes (both parameters and data) which are expected to be sent and contains the set up words and as many of the parameter and data bytes as will fit in a negotiated size buffer.  This request also identifies the maximum number of bytes (setup, parameters and data) the server is to return on completion.  If all the bytes fit in the single buffer, skip to step 4.</li>
<li>
The server responds with a single interim response meaning "OK, send the remainder of the bytes" or (if error response) terminate the transaction.</li>
<li>
The client then sends another buffer full of bytes to the server.  The server responds with an interim server response. This step is repeated until all of the bytes are sent and received.</li>
<li>
The Server sets up and performs the transaction with the information provided.</li>
<li>
Upon completion of the transaction, the server sends back (up to) the number of parameter and data bytes requested (or as many as will fit in the negotiated buffer size).</li>
<li>
The client responds with a transaction secondary request.  The server sends back more response data. This step is repeated until all result bytes have been returned.<ol>
<li>
The client sends a sequenced request to the server such as<code> SMB_COM_ECHO</code></li>
</ol>
</li>
</ol>
<p>
The primary transaction request through the final response make up the complete transaction exchange, thus the <i>tid</i>, <i>pid</i>, <i>uid</i> and <i>mid</i> must remain constant and can be used as appropriate by both the server and the client.  Of course, other SMB requests may intervene as well.</p>
<p>
There are (at least) three ways that actual server responses have been observed to differ from what might be expected.  First, some servers will send Pad bytes to move the DataOffset to a 2- or 4-byte boundary even if there are no data bytes; the point here is that the ByteCount must be used instead of ParameterOffset plus ParameterCount to infer the actual message length.  Second, some servers always return MaxParameterCount bytes even if the particular Transact2 has no parameter response.  Finally, in case of an error, some servers send the "traditional WordCount==0/ByteCount==0" response while others generate a Transact response format.</p>
<p>&nbsp;</p></body>
</HTML>
