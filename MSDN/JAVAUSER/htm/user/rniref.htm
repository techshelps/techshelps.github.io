<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Raw Native Interface Functions</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Raw Native Interface Functions"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1></FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="365" VALIGN="bottom"><IMG SRC="art/jnative2.gif" WIDTH="365" HEIGHT="27"  BORDER=0 ALT="Java & Native Code"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="rni.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="RNI"></A></TD></TR>
<TR>
<TD WIDTH="365" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Raw Native Interface Functions</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">RNI</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Raw Native Interface Functions</H2>
<P>This reference describes the functions defined in the native.h and nativcom.h header files (unless noted, prototype is found in native.h). 
These functions are used by the Raw Native Interface defined by the Microsoft&#174; Virtual Machine for efficiently interfacing Java code with native code. 

<P>To learn how to use the API, see the overview information in <A HREF="rni.htm">Raw Native Interface</A>.

<P>The following functions are defined in native.h and nativcom.h:
<p>
<TABLE BORDER=0>

<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_AddPathClassSource">AddPathClassSource</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Adds a path to the virtual machine's internal class path.</FONT></TD></TR>

<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_AddModuleResourceClassSource">AddModuleResourceClassSource</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Notifies the virtual machine of a WIN32 resource containing class files.</FONT></TD></TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000100">ArrayAlloc</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Creates an array of primitive type objects.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000200">ArrayCopy</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Copies an array using the <B>Java System.ArrayCopy</B> method.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_c2jhook_getexposingclass">c2jhook_getexposingclass</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the class defining the interface method.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_c2jhook_getsizeofuserdata">c2jhook_getsizeofuserdata</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Gets size of the user data in the MCCustomMethod descriptor.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_c2jhook_getuserdata">c2jhook_getuserdata</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Gets writable pointer to the user data in the MCCustomMethod descriptor.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000e00">ClassArrayAlloc</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Creates an array of objects.


</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_Class_CopyConstantPoolItem">Class_CopyConstantPoolItem</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Copies a constant pool item.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_ClassClassToClassObject">ClassClassToClassObject</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
 <FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a <b>java.lang.Class</b> object from a ClassClass pointer.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_ClassObjectToClassClass">ClassObjectToClassClass</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
 <FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a ClassClass pointer from a <b>java.lang.Class</b> object.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000300">Class_GetAttributes</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a combination of the ACC_XXX flags for a class as they appear in the Java class file.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_Class_GetConstantPoolCount">Class_GetConstantPoolCount</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Gets a constant pool count.


</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000400">Class_GetField</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a handle to a field explicitly specified by name. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000500">Class_GetFieldByIndex</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a handle to a field specified by index.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000600">Class_GetFieldCount</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the total number of fields in the class, including super and static fields.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000700">Class_GetInterface</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves an interface specified by index.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000800">Class_GetInterfaceCount</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the total number of interfaces that are implemented by the class.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000900">Class_GetMethod</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a handle to a method explicitly specified by name. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000a00">Class_GetMethodByIndex</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a handle to a method specified by index. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000b00">Class_GetMethodCount</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the total number of methods in the class, including super and static methods.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000c00">Class_GetName</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the class name.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401000d00">Class_GetSuper</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the superclass name.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_convert_IUnknown_to_Java_Object">convert_IUnknown_to_Java_Object</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns a Java callable wrapper that can be used to access the specified interface pointer.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_convert_IUnknown_to_Java_Object2">convert_IUnknown_to_Java_Object2</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns a Java callable wrapper that can be used to access the specified interface pointer.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_convert_Java_Object_to_IUnknown">convert_Java_Object_to_IUnknown</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns an interface pointer usable from the current COM context.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_convert_ptr_to_jcdw">convert_ptr_to_jcdw</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns a data wrapper object of the supplied Class type that points at the supplied data pointer.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_do_execute_java_method">do_execute_java_method</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Calls a Java method or constructor.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_do_execute_java_method64">do_execute_java_method64</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Calls a Java method or constructor and returns a 64 bit int.


</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_do_execute_java_methodV">do_execute_java_methodV</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Calls a Java method or constructor using a va_list as a parameter instead of ellipses. 

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001000">exceptionClear</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Clears any pending exceptions.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001100">exceptionDescribe</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"> Invokes <B>printStackTrace</B> on the pending exception.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001200">exceptionOccurred</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Determines if an exception has occurred in the called Java method without exiting the native code.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001300">exceptionSet</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Sets a pending exception.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001400">execute_java_constructor</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Allocates a new Java object and invokes a constructor.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001500">execute_java_constructorV</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Allocates a new Java object and invokes a constructor.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java dynamic method.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001700">execute_java_dynamic_method64</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java dynamic method and returns a 64 bit int.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001800">execute_java_dynamic_methodV</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java dynamic method using a va_list as a parameter instead of ellipses.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001900">execute_java_interface_method</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java interface method.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001a00">execute_java_interface_method64</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java interface method and returns a 64 bit int.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001b00">execute_java_interface_methodV</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java interface method using a va_list as a parameter instead of ellipses.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001c00">execute_java_static_method</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java static method.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001d00">execute_java_static_method64</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java static method and returns a 64 bit int.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001e00">execute_java_static_methodV</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Invokes a Java static method using a va_list as a parameter instead of ellipses.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401001f00">Field_GetXXX</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the value of the specified field.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002000">Field_GetOffset</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns the offset of dynamic fields in the class.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002100">Field_GetStaticPtr</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a pointer to the static data.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002200">Field_SetXXX</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Sets the value of the specified field.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves a class object pointer for a named class.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002400">FindClassEx</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves a class object pointer according to specified flags.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002500">GCDisable</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Increments the block count and disables garbage collection.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002600">GCDisableCount</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Disables the counting used by <A HREF="rniref.htm#rniref_0008010401002800">GCEnable</A> and <A HREF="rniref.htm#rniref_0008010401002500">GCDisable</A>.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002700">GCDisableMultiple</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Increments the block count a specified number of times.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002800">GCEnable</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Decrements the block count and enables garbage collection by the VM.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002900">GCEnableCompletely</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Decrements the block count to zero and enables garbage collection by the VM. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002a00">GCFramePop</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Restores the GCFrame with current values for members of the structure.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002b00">GCFramePush</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Informs the VM garbage collector of a GCFrame to track.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002c00">GCFreeHandle</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Frees a "strong pointer" originally obtained using <A HREF="rniref.htm#rniref_0008010401002f00">GCNewHandle</A>.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002d00">GCFreePtr</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Frees a pointer originally allocated using <A HREF="rniref.htm#rniref_0008010401002e00">GCGetPtr</A>.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002e00">GCGetPtr</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Allocates a "weak" pointer for an object and updates it when GC occurs.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401002f00">GCNewHandle</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Creates a "strong pointer" to an object.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003000">GCSetObjectReferenceForHandle</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">GC-safe method for updating contents of a handle.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003100">GCSetObjectReferenceForObject</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">GC-safe method for updating the fields in an object.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003200">get_methodblock</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves a pointer to a method block structure containing the class name, method name, and parameter and return types of a method.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_GetCurrentJavaTimeMillis">GetCurrentJavaTimeMillis</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns the same result as defined by <b>java.lang.System.currentTimeMillis()</b>.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003300">GetNativeMethodCallersClass</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Determines the class type of the caller.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003400">GetNativeMethodCallersMethodInfo</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Gets information about the caller's method.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003500">getPendingException</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves a pending exception.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003600">HResultFromException</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Creates an HRESULT return type from a Java exception object. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003700">is_instance_of</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Determines if an object is an instance of a specified class type.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003800">is_subclass_of</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Determines if a class is a subclass of the second specified class type.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003900">ImplementsInterface</A></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Determines if a class type implements the interface represented by the second class type.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003a00">isInstanceOf</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Determines if a specified Java object is an instance of a particular class.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_j2chook_getmethodblock">j2chook_getmethodblock</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the methodblock of the target method.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_j2chook_getsizeofuserdata">j2chook_getsizeofuserdata</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Gets size of the user data in the MCCustomMethod descriptor.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_j2chook_getuserdata">j2chook_getuserdata</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Gets writable pointer to the user data in the MCCustomMethod descriptor.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_j2chook_getvtblindex">j2chook_getvtblindex</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Gets the vtable index of the target method.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003b00">javaString2CString</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Copies the characters of the String object into a C string buffer.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003c00">javaStringLength</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the length of the Java String object.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003d00">javaStringStart</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a temporary pointer to the first character of the Java String object.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdw_java_owned">jcdw_java_owned</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns true if the virtual machine frees the non-garbage-collected heap memory that this data wrapper contains when the data wrapper is garbage collected.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdw_memory_freed_on_gc">jcdw_memory_freed_on_gc</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns true if the virtual machine allocated the non-garbage-collected heap memory contained in the data wrapper.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwClassOffsetOf">jcdwClassOffsetOf</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the byte offset within the non-garbage-collected heap memory to the specified field name from the supplied <b>java.lang.Class</b> object. 

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwClassSizeOf">jcdwClassSizeOf</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the size of the non-garbage-collected heap memory used by instances of the supplied <b>java.lang.Class</b> object. 

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwGetData">jcdwGetData</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the data pointer to the non-garbage-collected heap memory contained in the data wrapper object. 


</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwNewData">jcdwNewData</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Replaces the data pointer contained in the data wrapper with a new quantity of heap memory that is not garbage collected. 


</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwOffsetOf">jcdwOffsetOf</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the byte offset within the non-garbage-collected heap memory to the specified field name. 

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwSetData">jcdwSetData</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Replaces the data pointer that this data wrapper represents with the specified data pointer. 

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_jcdwSizeOf">jcdwSizeOf</A>
</FONT></TD><TD ALIGN=LEFT VALIGN=TOP>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Returns the size of the non-garbage-collected heap memory contained in the data wrapper object. 

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003e00">jio_snprintf</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Prints to a string with a buffer limit.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401003f00">jio_vsnprintf</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Prints to a string with a buffer limit using a va_list macro for arguments.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004000">makeJavaString</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a string formatted as a Java String object.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004100">makeJavaStringW</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Constructs a Java string from a Unicode C string.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004200">makeJavaStringFromUtf8</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Creates a new Java String object, initialized from a null-terminated, UTF8-formatted, C string.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004300">MakeByteString</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Create and return a new array of bytes initialized from the C string.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_MarshalCallToJavaThreadId">MarshalCallToJavaThreadId</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Thread marshaling helper that reexecutes the RNI method on the supplied thread ID for the supplied Java object.


</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_MarshalCallToJavaObjectHostThread">MarshalCallToJavaObjectHostThread</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Thread marshaling helper that reexecutes the RNI method on the apartment thread for the supplied thead ID for the supplied Java object.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004400">Member_GetAttributes</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Returns a combination of the ACC_XXX flags for a field or method, as they appear in the Java class file.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004500">Member_GetClass</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the name of the class that the field or method is implemented in.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004600">Member_GetName</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the member name.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004700">Member_GetSignature</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the signature of the field or method.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004800">monitorEnter</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Enters a synchronization object. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004900">monitorExit</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Exits a synchronization object. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004a00">monitorNotify</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Wakes up a single thread that is waiting on this object's monitor. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004b00">monitorNotifyAll</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Wakes up all threads that are waiting on this object's monitor. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004c00">monitorWait</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Waits to be notified by another thread of a change in this object.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004d00">Object_GetClass</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the class that the object points to.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004e00">PrepareThreadForJava</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Thread entry function for calls into the VM. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401004f00">RNIGetCompatibleVersion</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Exported by the DLL to allow the VM to check compatibility. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401005000">SignalError</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Creates a Java exception object, which is thrown once it returns from the native code.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401005100">SignalErrorHResult</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(nativcom.h) Creates a Java exception object from an <B>HRESULT</B> return type.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401005200">SignalErrorPrintf</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Creates a Java exception object and specifies format string for exception description to be printed when thrown.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="rniref.htm#rniref_0008010401005400">Thread_IsInterrupted</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Checks to see if the current thread is interrupted and optionally resets the interrupt flag.

</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA"
SIZE="2"><A HREF="rniref.htm#rniref_0008010401005300">UnprepareThreadForJava</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Thread exit function for calls into the VM.
</FONT></TD></TR></TABLE>

<H4 STYLE="color:#333366"><A NAME="rniref_AddModuleResourceClassSource">AddModuleResourceClassSource</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">__cdecl AddModuleResourceClassSource(HMODULE hMod, DWORD dwResID);
</FONT></PRE>
<P>Notifies the virtual machine of a WIN32 resource containing class files. This resource must be in the format created by JExeGen. When classes are being loaded, the resource is searched for classes as if it were a directory on the classpath.
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_AddPathClassSource">AddPathClassSource</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL __cdecl AddPathClassSource(const char *path, BOOL fAppend);
</FONT></PRE>
<P>Adds a path to the virtual machine's internal class path.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000100">ArrayAlloc</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject* __cdecl ArrayAlloc(int type, int cItems);
</FONT></PRE>
<P><P>Creates an array of primitive type objects.

<P><B>Return Value:</B> <P>Returns an allocated object array.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>type</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Primitive data type as defined in native.h. The following types are supported:
 <TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_BOOLEAN </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Boolean object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_BYTE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Byte object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_CHAR </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Character object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_CLASS </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Class object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_DOUBLE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Double object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_FLOAT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Float object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_INT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An Integer object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_LONG </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Long object 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_SHORT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Short object. 
 </FONT></TD></TR></TABLE>
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cItems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number of items in the array.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000200">ArrayCopy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl ArrayCopy(HObject *srch, long src_pos, HObject *dsth, 
        long dst_pos, long length);
</FONT></PRE>
<P><P>Copies an array using the <B>Java System.ArrayCopy</B> method.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>srch</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Source object.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>src_pos</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Starting position in the source object array to copy.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dsth</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Destination object.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dst_pos</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Position in the destination object array to copy to.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>length</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number of objects in the array to copy. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_c2jhook_getexposingclass">c2jhook_getexposingclass</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl c2jhook_getexposingclass(C2JMethodHookInfo *phookinfo);
</FONT></PRE>
<P>Returns the class defining the interface method. This is the class containing the MCCustomMethod descriptor.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_c2jhook_getsizeofuserdata">c2jhook_getsizeofuserdata</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">WORD __cdecl c2jhook_getsizeofuserdata(C2JMethodHookInfo *phookinfo);
</FONT></PRE>
<P>Gets size of user data in the MCCustomMethod descriptor.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_c2jhook_getuserdata">c2jhook_getuserdata</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">LPVOID __cdecl c2jhook_getuserdata(C2JMethodHookInfo *phookinfo);
</FONT></PRE>
<P>Gets writable pointer to the user data in the MCCustomMethod descriptor.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_Class_CopyConstantPoolItem">Class_CopyConstantPoolItem</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl Class_CopyConstantPoolItem(ClassClass *cls, unsigned index, BYTE *pbuf, int size, DWORD flags, BYTE *ptype);
</FONT></PRE>
<P><P>Copies a constant pool item. For Utf8 items, the buffer size is not the number of characters, and the copied string will be null-terminated; size includes the null-terminator. For ClassRef, FieldRef, etc., the buffer is filled in with a struct ptr.

<P><TABLE WIDTH=40% BORDER=1 CELLPADDING=0 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>CP Type</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Buffer Contents</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Utf8
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Null-terminated string. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Unicode
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(error)<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Integer
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Float
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Long
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Double
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_Class
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ClassClass*<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_String
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HObject*<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_FieldRef
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">fieldblock*<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_MethodRef
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">methodblock*<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_IntfMethod
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">methodblock*<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2>CP_NameAndType
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">(error)
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>size</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The size of <I>pbuf</I> in bytes. May be NULL to obtain only the size/type. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptype</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Type of the pool item. Returns the number of bytes copied or needed, or -1 if failed. Filled in on output.<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>flags</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">If the constant pool item has not yet been used, force its referent to be loaded or looked up. With this flag set, the method may cause garbage collection.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_Class_GetConstantPoolCount">Class_GetConstantPoolCount</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned __cdecl Class_GetConstantPoolCount(ClassClass *cls);
</FONT></PRE>
<P><P>Gets the constant pool count.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000300">Class_GetAttributes</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl Class_GetAttributes(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves a combination of the ACC_XXX flags for a class as they appear in the Java class file. 

<P><B>Return Value:</B> <P>Returns attributes flags. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>The following attributes are defined for use in a Java class file and can be retrieved using this function: 
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Flag </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Value
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_PUBLIC </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0001 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_PRIVATE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0002 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_PROTECTED </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0004 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_STATIC </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0008 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_FINAL </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0010 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_SYNCH </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0020 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_SUPER </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0020 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_THREADSAFE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0040 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_VOLATILE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0040 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_TRANSIENT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0080 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_NATIVE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0100 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_INTERFACE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0200 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">ACC_ABSTRACT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">0x0400 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000400">Class_GetField</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct fieldblock * __cdecl Class_GetField(ClassClass *cls, const char *name);
</FONT></PRE>
<P><P>Retrieves a handle to a field explicitly specified by name. This handle is needed to get any further information about the field.

<P><B>Return Value:</B> <P>Returns a pointer to the field block.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the field in the class.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000500">Class_GetFieldByIndex</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct fieldblock * __cdecl Class_GetFieldByIndex(ClassClass *cls, unsigned index);
</FONT></PRE>
<P><P>Retrieves a handle to a field specified by index. 

<P><B>Return Value:</B> <P>Returns a field block pointer.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>index</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Index value of the field in the class. The index must be between 0 and the field count (returned from <A HREF="rniref.htm#rniref_0008010401000600">Class_GetFieldCount</A>) minus 1, inclusive.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000600">Class_GetFieldCount</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned __cdecl  Class_GetFieldCount(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves the total number of fields in the class, including super and static fields.

<P><B>Return Value:</B> <P>Returns the number of fields.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This function is intended to be used with <A HREF="rniref.htm#rniref_0008010401000500">Class_GetFieldByIndex</A> to 
enumerate fields on a class.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000700">Class_GetInterface</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl   Class_GetInterface(ClassClass *cls, unsigned index);
</FONT></PRE>
<P><P>Retrieves an interface specified by index. 

<P><B>Return Value:</B> <P>Returns a pointer to a class interface object.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>index</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Index value of the interface in the class. The index must be between 0 and the interface count (returned from <A HREF="rniref.htm#rniref_0008010401000800">Class_GetInterfaceCount</A>) minus 1, inclusive.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000800">Class_GetInterfaceCount</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned __cdecl            Class_GetInterfaceCount(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves the total number of interfaces implemented by the class.

<P><B>Return Value:</B> <P>Returns the number of interfaces.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000900">Class_GetMethod</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct methodblock* __cdecl Class_GetMethod(ClassClass *cls, const char *name, const char *signature);
</FONT></PRE>
<P><P>Retrieves a handle to a method explicitly specified by name. This handle is needed to get any further information about the method.

<P><B>Return Value:</B> <P>Returns a handle to a method in the given class specified by name and signature.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method in the class.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000a00">Class_GetMethodByIndex</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct methodblock* __cdecl Class_GetMethodByIndex(ClassClass *cls, unsigned index);
</FONT></PRE>
<P><P>Retrieves a handle to a method specified by index. 

<P><B>Return Value:</B> <P>Returns a method block pointer.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>index</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Index value of the method in the class. The index must be between 0 and the method count (returned from <A HREF="rniref.htm#rniref_0008010401000b00">Class_GetMethodCount</A>) minus 1, inclusive.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000b00">Class_GetMethodCount</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned __cdecl            Class_GetMethodCount(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves the total number of methods in the class, including non-static super methods.

<P><B>Return Value:</B> <P>Returns the number of methods.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> to determine. 
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This function is intended for use with <A HREF="rniref.htm#rniref_0008010401000a00">Class_GetMethodByIndex</A> to enumerate methods in a class.

<P>This function returns the total count of all members, not just the count of those declared in the class specified. To find declared members, you must enumerate methods and call <A HREF="rniref.htm#rniref_0008010401004500">Member_GetClass</A> on each to determine where the method is implemented. </BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000c00">Class_GetName</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">const char * __cdecl        Class_GetName(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves the class name.

<P><B>Return Value:</B> <P>Returns class name. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000d00">Class_GetSuper</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl        Class_GetSuper(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves the superclass.

<P><B>Return Value:</B> <P>Returns the superclass. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000e00">ClassArrayAlloc</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject* __cdecl ClassArrayAlloc(int type, int cItems, char *szSig);
</FONT></PRE>
<P><P>Creates an array of objects.

<P><B>Return Value:</B> <P>Returns an allocated object array.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>type</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Type of objects in the array. The following types are supported:
 <TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_BOOLEAN </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Boolean object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_BYTE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Byte object.
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_CHAR </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Character object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_CLASS </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Class object (use <I>szSig</I> to specify the class). 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_DOUBLE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Double object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_FLOAT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Float object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_INT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An Integer object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_LONG </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Long object. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">T_SHORT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A Short object. 
 </FONT></TD></TR></TABLE>
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cItems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number of elements in the array to allocate.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>szSig</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Signature of the class if <I>type</I> is T_CLASS. (For example, "java/awt/Rectangle".)
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_ClassClassToClassObject">ClassClassToClassObject</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject* __cdecl ClassClassToClassObject(ClassClass *cls);
</FONT></PRE>
<P><P>Retrieves a <b>java.lang.Class</b> object for a ClassClass.</P>
<P><B>Note</B>  This method can cause a garbage collection to occur; guard 
any objects that you want to use after calling this method.</P>

<P><B>Return Value:</B> <P>Returns a <b>java.lang.Class</b> object.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A ClassClass pointer.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_ClassObjectToClassClass">ClassObjectToClassClass</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl ClassObjectToClassClass(HObject *object);
</FONT></PRE>
<P><P>Retrieves a ClassClass pointer from a <b>java.lang.Class</b> object.</P>
<P><B>Note</B>  This method can cause a garbage collection to occur; guard any objects that 
you want to use after calling this method.</P>

<P><B>Return Value:</B> <P>Returns a ClassClass pointer.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A <b>java.lang.Class</b> object.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_convert_IUnknown_to_Java_Object">convert_IUnknown_to_Java_Object</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">Hjava_lang_Object *__cdecl convert_IUnknown_to_Java_Object(IUnknown *punk, Hjava_lang_Object *phJavaClass, int fAssumeThreadSafe);
</FONT></PRE>
<P><P>Returns a Java callable wrapper that can be used to access the specified interface pointer. The virtual machine will keep a reference to this interface pointer. If <I>fAssumeThreadSafe</I> is false, the virtual machine auto-marshals all COM calls to the current COM context.
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_convert_IUnknown_to_Java_Object2">convert_IUnknown_to_Java_Object2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">Hjava_lang_Object *__cdecl convert_IUnknown_to_Java_Object(IUnknown *punk, ClassClass *pClassClass, int fFreeThreaded);
</FONT></PRE>
<P><P>Returns a Java callable wrapper that can be used to access the specified interface pointer. The virtual machine will keep a reference to this interface pointer. If <I>fAssumeThreadSafe</I> is false, the virtual machine auto-marshals all COM calls to the current COM context.
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_convert_Java_Object_to_IUnknown">convert_Java_Object_to_IUnknown</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">IUnknown *__cdecl convert_Java_Object_to_IUnknown(Hjava_lang_Object *phJavaObject, const IID *pIID);
</FONT></PRE>
<P><P>Returns an interface pointer usable from the current COM context.
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_convert_ptr_to_jcdw">convert_ptr_to_jcdw</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">Hjava_lang_Object *__cdecl convert_ptr_to_jcdw(void *pExtData, Hjava_lang_Object *phJavaClass);
</FONT></PRE>
<P><P>Returns a data wrapper object of the supplied class type that points at the supplied data pointer. The memory is not owned by the virtual machine.

</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_0008010401000f00">do_execute_java_method</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">long __cdecl do_execute_java_method(ExecEnv *ee, void *obj, char *method_name, 
        char *signature, struct methodblock *mb, bool_t isStaticCall, ...);
</FONT></PRE>
<P><P>Calls a Java method.

<P><B>Return Value:</B> <P>Returns TRUE if successful, or FALSE otherwise. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. This parameter should be set to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Object pointer.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to invoke. Set to NULL if using a method block.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. See <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A>
 for a description of signature characters. Pass NULL if using a method block. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*mb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the cached method block data structure. Use <A HREF="rniref.htm#rniref_0008010401003200">get_methodblock</A> to retrieve this. The underlying structure of the method block is not defined; it is used only to prevent accidental type misuse using the alternative, PVOID.

</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>isStaticCall</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">True if calling a static method, or false otherwise.</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This is a helper function for the <A HREF="rniref.htm#rniref_0008010401001c00">execute_java_static_method</A> and <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A> functions. It can be used when making repeated calls to a method to avoid the overhead of name lookup on each call. Note that invoking a Java method can cause garbage collections. 

<P>The following example demonstrates calling this function for repeated access to the Rectangle.move method:

<PRE><FONT FACE="Courier" SIZE="2">
struct {
    Hjava_awt_Rectangle *phRectangle;
} gc;

struct methodblock *pmb = get_methodblock(gc.phRectangle, "move", "(II)V");

for (i=0; i &lt; 10; i++)
{
  do_execute_java_method(NULL, gc.phRectangle, NULL, NULL, pmb, FALSE, x, y);
}
</FONT></PRE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_do_execute_java_method64">do_execute_java_method64</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl do_execute_java_method64(ExecEnv *ee, void *obj, const char *method_name, const char *signature, struct methodblock *mb, bool_t isStaticCall, ...);
</FONT></PRE>
<P><P>Calls a Java method or constructor and returns a 64 bit int. 

<P><B>Return Value:</B> <P>Returns TRUE if successful, or FALSE otherwise. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. This parameter should be set to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Object pointer.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to invoke. Set to NULL if using a method block.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. See <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A>
 for a description of signature characters. Pass NULL if using a method block. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*mb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the cached method block data structure. Use <A HREF="rniref.htm#rniref_0008010401003200">get_methodblock</A> to retrieve this. The underlying structure of the method block is not defined; it is used only to prevent accidental type misuse using the alternative, PVOID.

</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>isStaticCall</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">True if calling a static method, or false otherwise.</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This is a helper function for the <A HREF="rniref.htm#rniref_0008010401001c00">execute_java_static_method</A> and <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A> functions. It can be used when making repeated calls to a method to avoid the overhead of name lookup on each call. Note that invoking a Java method can cause garbage collections.
</BLOCKQUOTE> 

<H4 STYLE="color:#333366"><A NAME="rniref_do_execute_java_methodV">do_execute_java_methodV</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl do_execute_java_methodV(ExecEnv *ee, void *obj, const char *method_name, const char *signature, struct methodblock *mb, bool_t isStaticCall, va_list args);
</FONT></PRE>
<P><P>Calls a Java method or constructor and returns a 64 bit int. 

<P><B>Return Value:</B> <P>Returns TRUE if successful, or FALSE otherwise. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. This parameter should be set to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Object pointer.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to invoke. Set to NULL if using a method block.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. See <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A>
 for a description of signature characters. Pass NULL if using a method block. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*mb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the cached method block data structure. Use <A HREF="rniref.htm#rniref_0008010401003200">get_methodblock</A> to retrieve this. The underlying structure of the method block is not defined; it is used only to prevent accidental type misuse using the alternative, PVOID.

</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>isStaticCall</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">True if calling a static method, or false otherwise.
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>args</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The va_list used instead of ellipses.
</FONT></TD></TR></TABLE>

</BLOCKQUOTE> 

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001000">exceptionClear</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl exceptionClear(ExecEnv *ee);
</FONT></PRE>
<P><P>Clears any pending exceptions.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001100">exceptionDescribe</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl exceptionDescribe(ExecEnv *ee);
</FONT></PRE>
<P><P>Invokes <B>printStackTrace</B> on the pending exception.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001200">exceptionOccurred</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">bool_t __cdecl exceptionOccurred(ExecEnv *ee);
</FONT></PRE>
<P><P>Determines if an exception has occurred in the called Java method without exiting the native code.

<P><B>Return Value:</B> <P>Returns TRUE if an exception occurred, or FALSE otherwise.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001300">exceptionSet</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void exceptionSet(ExecEnv *ee, HObject *phThrowable);
</FONT></PRE>
<P><P>Sets the pending exception. Calling exceptionSet(ee, NULL) produces the same result as calling exceptionClear(ee).

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>phThrowable</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A pointer to the exception to set.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001400">execute_java_constructor</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject* __cdecl execute_java_constructor(ExecEnv *ee, char *classname, 
        ClassClass *cb, char *signature, ...);
</FONT></PRE>
<P><P>Allocates a new Java object and invokes a constructor.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. This parameter should be set to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>classname</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"> Name of the class if the <I>cb</I> parameter is NULL. Use forward slashes (/) instead of dots as
 package delimiters. (For example, "java/lang/System".)
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use NULL and provide <I>classname</I> if not known.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. See <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A> for a description of signature characters. The return type for all constructors, 'V', is automatically appended and should not be specified. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001500">execute_java_constructorV</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject* __cdecl execute_java_constructorV(ExecEnv *ee, const char *classname,
        ClassClass *cb, const char *signature, va_list args);
</FONT></PRE>
<P><P>Allocates a new Java object and invokes a constructor. This method accepts a va_list argument list as a paramenter instead of ellipses.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. This parameter should be set to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>classname</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"> Name of the class if the <I>cb</I> parameter is NULL. Use forward slashes (/) instead of dots as
 package delimiters. (For example, "java/lang/System".)
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object. Use NULL and provide <I>classname</I> if not known.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. See <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A> for a description of signature characters. The return type for all constructors, 'V', is automatically appended and should not be specified.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>args</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Additional arguments. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001600">execute_java_dynamic_method</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">long __cdecl execute_java_dynamic_method(ExecEnv *ee, HObject *obj, char 
        *method_name, char *signature, ...);
</FONT></PRE>
<P><P>Invokes a Java dynamic method.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL. 
 </FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address to the Java object containing method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters and return type of the method (see below) .
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>The <I>signature</I> parameter specifies the parameters and return type of the method by enclosing the character codes for parameter types in parentheses, followed by the character code for the return type. The following table shows the mapping of types to signature characters:

<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Character </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java Type
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">[ </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">array
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Z </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">boolean
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">B </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">C </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">D </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">F </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">I </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">J </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">L </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">object
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">V </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">void
</FONT></TD></TR></TABLE>
<P>Arrays must be followed by the array type. For example, "[C" for a character array. For multidimensional arrays, repeat "[" for the number of dimensions. For example, "[[Z" signifies a two-dimensional boolean array.

<P>For objects, the signature is followed by the object class name and ends with a semicolon (;). For example, the signature for the a Rectangle object is "Ljava/awt/Rectangle;"

<P>The following example uses this function to call the Rectangle.move method with two integer parameters to the method, <I>x</I> and <I>y</I>:
<PRE><FONT FACE="Courier" SIZE="2">
long lrval = execute_java_dynamic_method(NULL, phRectangle, "move","(II)V", x, y);
</FONT></PRE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001700">execute_java_dynamic_method64</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl execute_java_dynamic_method64(ExecEnv *ee, HObject *obj, char 
        *method_name, char *signature, ...);
</FONT></PRE>
<P><P>Invokes a Java dynamic method. This method is equivalent to the execute_java_dynamic_method except it returns a 64 bit value instead of a 32 bit long.

<P><B>Return Value:</B> <P>A 64 bit value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL. 
 </FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address to the Java object containing method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters and return type of the method.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001800">execute_java_dynamic_methodV</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl execute_java_dynamic_methodV(ExecEnv *ee, HObject *obj, const char
        *method_name, const char *signature, va_list args);
</FONT></PRE>
<P><P>Invokes a Java dynamic method. This method is equivalent to the execute_java_dynamic_method except it returns a 64 bit value instead of a 32 bit long, and accepts a va_list argument list as a parameter.

<P><B>Return Value:</B> <P>A 64 bit value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL. 
 </FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address to the Java object containing method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters and return type of the method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>args</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Additional arguments.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001900">execute_java_interface_method</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">long __cdecl execute java_interface_method(ExecEnv *ee, HObject *pobj, ClassClass j_interface,
 const char *method_name, const char *signature, ...);
</FONT></PRE>
<P><P>Invokes a Java interface method. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address to the Java object containing method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>j_interface</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A java class interface.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters and return type of the method.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001a00">execute_java_interface_method64</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl execute java_interface_method64(ExecEnv *ee, HObject *pobj, ClassClass j_interface,
 const char *method_name, const char *signature, ...);
</FONT></PRE>
<P><P>Invokes a Java interface method. This method is equivalent to the execute_java_interface_method, except it returns a 64 bit value instead of a 32 bit long.

<P><B>Return Value:</B> <P>A 64 bit value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address to the Java object containing method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>j_interface</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A java class interface.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters and return type of the method.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001b00">execute_java_interface_methodV</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl execute_java_interface_methodV(ExecEnv *ee, HObject *pobj,
        ClassClass j_interface, const char *method_name, const char *signature, va_list args);
</FONT></PRE>
<P><P>Invokes a Java interface method. This method is equivalent to the execute_java_interface_method, except it returns a 64 bit value instead of a 32 bit long and accepts a va_list argument list as a a parameter.

<P><B>Return Value:</B> <P>A 64 bit value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address to the Java object containing method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>j_interface</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A java class interface.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters and return type of the method.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>args</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Additional arguments.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001c00">execute_java_static_method</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">long __cdecl execute_java_static_method(ExecEnv *ee, ClassClass *cb, 
        char *method_name, char *signature, ...);
</FONT></PRE>
<P><P>Invokes a Java static method.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. 
 Pass NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object, obtained with the <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> function.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. For a description of signature characters, see <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A>. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001d00">execute_java_static_method64</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl execute_java_static_method64(ExecEnv *ee, ClassClass *cb, 
        char *method_name, char *signature, ...);
</FONT></PRE>
<P><P>Invokes a Java static method. This method is equivalent to the execute_java_dynamic_method, except it returns a 64 bit value instead of a 32 bit long.


<P><B>Return Value:</B> <P>A 64 bit value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Pass NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object, obtained with the <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> function.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. For a description of signature characters, see <A HREF="rniref.htm#rniref_0008010401001700">execute_java_dynamic_method64</A>. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001e00">execute_java_static_methodV</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int64_t __cdecl execute_java_static_methodV(ExecEnv *ee, ClassClass *cb,
        const char *method_name, const char *signature, va_list args);
</FONT></PRE>
<P><P>Invokes a Java static method. This method is equivalent to the execute_java_dynamic_method, except it returns a 64 bit value instead of a 32 bit long, and accepts a va_list argument list as a parameter.


<P><B>Return Value:</B> <P>A 64 bit value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. 
 Pass NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the class object, obtained with the <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> function.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to be called.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. For a description of signature characters, see <A HREF="rniref.htm#rniref_0008010401001700">execute_java_dynamic_method64</A>.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>args</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Additional arguments. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401001f00">Field_GetXXX</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">
__int32 __cdecl             Field_GetValue(HObject *obj, struct fieldblock * field);
__int64 __cdecl             Field_GetValue64(HObject *obj, struct fieldblock * field);
float __cdecl                  Field_GetFloat(HObject *obj, struct fieldblock * field);
double __cdecl              Field_GetDouble(HObject *obj, struct fieldblock * field);
#define Field_GetBoolean(obj,field)     ((bool_t)       Field_GetValue(obj,field))
#define Field_GetByte(obj,field)        ((signed char)  Field_GetValue(obj,field))
#define Field_GetChar(obj,field)        ((unicode)      Field_GetValue(obj,field))
#define Field_GetShort(obj,field)       ((short)        Field_GetValue(obj,field))
#define Field_GetInt(obj,field)                         Field_GetValue(obj,field)
#define Field_GetLong(obj,field)                        Field_GetValue64(obj,field)
#define Field_GetObject(obj,field)      ((HObject*)     Field_GetValue(obj,field))
#define Field_GetFloat(obj,field)                       Field_GetFloat(obj,field)
#define Field_GetDouble(obj,field)                      Field_GetDouble(obj,field)
</FONT></PRE>
<P><P>Retrieves the value of the specified field.

<P><B>Return Value:</B> <P>Returns a value of a type determined by the function.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the object that the field belongs to.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>field</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Field block of the field.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>These functions operate on static or non-static fields, including both of the component object model (COM) MapsTo fields and the fields in Java objects.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002000">Field_GetOffset</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned __cdecl Field_GetOffset(struct fieldblock * field);
</FONT></PRE>
<P><P>Returns the offset of dynamic fields in the class.


<P><B>Return Value:</B> <P>Returns the offset of the field relative to the object for non-static fields. Returns 0 for static fields. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>field</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Field block of the field. The underlying structure of field block is not defined;
 it is used only to prevent accidental type misuse using the alternative, PVOID.

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Note that this function accounts for the 'MSReserved' value at the top of 
structures generated by msjavah. This means you can just add this value to the base 
of the object to get to the data.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002100">Field_GetStaticPtr</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">PVOID __cdecl  Field_GetStaticPtr(struct fieldblock * field);
</FONT></PRE>
<P><P>Returns an address of the static data.

<P><B>Return Value:</B> <P>Returns an address to the data for static fields, or NULL for non-static fields.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>field</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Field block of the field. The underlying structure of field block is not defined;
 it is used only to prevent accidental type misuse using the alternative, PVOID.

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002200">Field_SetXXX</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">
void __cdecl                Field_SetValue(HObject *obj, struct fieldblock * field, __int32 value);
void __cdecl                Field_SetValue64(HObject *obj, struct fieldblock * field, __int64 value);
void __cdecl                Field_SetFloat(HObject *obj, struct fieldblock * field, float value);
void __cdecl                Field_SetDouble(HObject *obj, struct fieldblock * field, double value);
#define Field_SetBoolean(obj,field,value)               Field_SetValue(obj,field,(bool_t)(value))
#define Field_SetByte(obj,field,value)                  Field_SetValue(obj,field,(signed char)(value))
#define Field_SetChar(obj,field,value)                  Field_SetValue(obj,field,(unicode)(value))
#define Field_SetShort(obj,field,value)                 Field_SetValue(obj,field,(short)(value))
#define Field_SetInt(obj,field,value)                   Field_SetValue(obj,field,value)
#define Field_SetLong(obj,field,value)                  Field_SetValue64(obj,field,value)
#define Field_SetObject(obj,field,value)                Field_SetValue(obj,field,(__int32)(value))
#define Field_SetFloat(obj,field,value)                 Field_SetFloat(obj,field,value)
#define Field_SetDouble(obj,field,value)                Field_SetDouble(obj,field,value)
</FONT></PRE>
<P><P>Sets the value of the specified field.


<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the object that the field belongs to. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>field</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Field block of the field.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>These functions operate on static or non-static fields, including both of the COM MapsTo fields and the fields in Java objects.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002300">FindClass</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass* __cdecl FindClass(ExecEnv *ee, char *classname, bool_t resolve);
</FONT></PRE>
<P><P>Retrieves a class object pointer for a named class.

<P><B>Return Value:</B> <P>Returns a pointer to the class.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for execution environment, which is not needed by the Microsoft VM. 
 Set this parameter to NULL.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>classname</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the class to locate.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>resolve</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Ignored. Classes found will always be ignored.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Use this function to get a pointer to a class, named by <I>classname</I>. This pointer can be
used in the <A HREF="rniref.htm#rniref_0008010401001c00">execute_java_static_method</A> function to identify the class. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002400">FindClassEx</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass* __cdecl FindClassEx(char *pszClassName,DWORD dwFlags);
</FONT></PRE>
<P><P>Retrieves a class object pointer for a named class, according to the specified flags.

<P><B>Return Value:</B> <P>Returns a pointer to the class.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pszClassName</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the class to locate.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dwFlags</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">One of the following flags:
 <TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B><A NAME="rniref_0008010401002401">FINDCLASSEX_NOINIT</A></B>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">If the class is a system class, will prevent the classes static initializer from running. 
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B><A NAME="rniref_0008010401002402">FINDCLASSEX_IGNORECASE</A></B>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Will perform a case-insensitive validation of the class name, as opposed to the case-sensitive validation that normally occurs.
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B><A NAME="rniref_0008010401002403">FINDCLASSEX_SYSTEMONLY</A></B>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Will only look for the named class as a system class.
 </FONT></TD></TR></TABLE>
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This method is similar to the <A HREF="rniref.htm#rniref_0008010401002300">FindClass</A> method, but accepts arguments to control the class load operation.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002500">GCDisable</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int     __cdecl GCDisable();
</FONT></PRE>
<P><P>Increments the block count and disables garbage collection. 

<P><B>Return Value:</B> <P>Returns TRUE if successful, or FALSE otherwise.<P><B>Remarks:</B> <P>Use this function to disable garbage collection after you have enabled it using
<A HREF="rniref.htm#rniref_0008010401002800">GCEnable</A>. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002600">GCDisableCount</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int     __cdecl GCDisableCount();
</FONT></PRE>
<P><P>Disables the counting used by <A HREF="rniref.htm#rniref_0008010401002800">GCEnable</A> and <A HREF="rniref.htm#rniref_0008010401002500">GCDisable</A>.

<P><B>Return Value:</B> <P>Returns the current count.<P><B>Remarks:</B> <P>Used for diagnostic purposes. Since the use of <A HREF="rniref.htm#rniref_0008010401002800">GCEnable</A> and <A HREF="rniref.htm#rniref_0008010401002500">GCDisable</A> requires a counter, this provides a way to verify that the count is what is expected.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002700">GCDisableMultiple</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void    __cdecl GCDisableMultiple(int cDisable);
</FONT></PRE>
<P><P>Increments the block count a specified number of times. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cDisable</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number of times to increment the block count.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This function is useful when you have previously called <A HREF="rniref.htm#rniref_0008010401002900">GCEnableCompletely</A> to allow garbage collection on all referenced objects, but later want to reinstate the block count with one call. The following example shows enabling garbage collection around a sleep call.
<PRE><FONT FACE="Courier" SIZE="2">
    int nEnable = GCEnableCompletely();
    Sleep( (int) millis );
    GCDisableMultiple(nEnable);
</FONT></PRE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002800">GCEnable</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int     __cdecl GCEnable();
</FONT></PRE>
<P><P>Decrements the block count and enables garbage collection by the VM.

<P><B>Return Value:</B> <P>Returns TRUE if successful, or FALSE otherwise.<P><B>Remarks:</B> <P>When calling a native function from within Java, garbage collection is blocked by default.
If the native function call is going to take some time, you can enable garbage collection with this call.
However, you should first use the <A HREF="rniref.htm#rniref_0008010401002b00">GCFramePush</A> function to allow the garbage collector to 
track any Java objects that you care about during garbage collection. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002900">GCEnableCompletely</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int     __cdecl GCEnableCompletely();
</FONT></PRE>
<P><P>Decrements the block count to 0 and enables garbage collection by the VM. 

<P><B>Return Value:</B> <P>Returns the block count before entering this function.<P><B>Remarks:</B> <P>This function enables garbage collection, regardless of the number of calls previously made to GCDisable, incrementing the block count.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002a00">GCFramePop</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void    __cdecl GCFramePop(PVOID pGCFrame);
</FONT></PRE>
<P><P>Restores the GCFrame with current values for members of the structure.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pGCFrame</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of a garbage collection frame that references a structure with Java objects that are being tracked.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002b00">GCFramePush</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void    __cdecl GCFramePush(PVOID pGCFrame, PVOID pObjects, 
                DWORD cbObjectStructSize);
</FONT></PRE>
<P><P>Informs the VM garbage collector of a GCFrame to track.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pGCFrame</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of a garbage collection frame referencing the <I>pObjects</I> structure. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pObjects</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Structure containing the Java objects to track during garbage collection.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cbObjectStructSize</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Size of <I>pObjects</I> structure.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>The garbage collector initializes the structure referenced by <I>pObjects</I> to 
NULL.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002c00">GCFreeHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl GCFreeHandle(HObject **pphobj);
</FONT></PRE>
<P><P>Frees a strong pointer, originally obtained using <A HREF="rniref.htm#rniref_0008010401002f00">GCNewHandle</A>.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pphobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Pointer to a pointer to be freed.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002d00">GCFreePtr</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl GCFreePtr(HObject **pphobj);
</FONT></PRE>
<P><P>Frees a garbage collection pointer originally obtained using <A HREF="rniref.htm#rniref_0008010401002e00">GCGetPtr</A>. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pphobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Pointer to a pointer to be freed.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002e00">GCGetPtr</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject** __cdecl GCGetPtr(HObject *phobj);
</FONT></PRE>
<P><P>Allocates a "weak" pointer for an object, and then updates it when garbage collection occurs.

<P><B>Return Value:</B> <P>Returns an address to a pointer to a Java object handle. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>phobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of a Java object.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Given a pointer to an object, this function allocates and returns the address of that object pointer, and then updates the contained pointer when GC occurs. Note that if the object gets freed during GC, the value of the contained pointer will be NULL. A "weak" pointer is different from a "strong" pointer (as allocated by <A HREF="rniref.htm#rniref_0008010401002f00">GCNewHandle</A>). A weak pointer will not block garbage collection (removal) of the referenced object, but a strong pointer will. (Strong pointers are scanned like any other object during GC; weak pointers are updated after the GC has been completed.)
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401002f00">GCNewHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject** __cdecl GCNewHandle(HObject *phobj);
</FONT></PRE>
<P><P>Creates a "strong pointer" to an object.

<P><B>Return Value:</B> <P>Returns an address to the object pointer.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>phobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Object that is be referenced.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Using this function is similar to placing an object in a GCFrame; however, strong pointers can be stored statically across calls. A strong pointer prevents the object from being collected as garbage, whereas a weak pointer only tracks the object's movement.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003000">GCSetObjectReferenceForHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl GCSetObjectReferenceForHandle (HObject** handle, HObject* phobj);
</FONT></PRE>
<P><P>GC-safe method for updating the contents of a handle.

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>handle</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The result of calling <A HREF="rniref.htm#rniref_0008010401002e00">GCGetPtr</A> for a weak pointer or <A HREF="rniref.htm#rniref_0008010401002f00">GCNewHandle</A> for a strong handle.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>phobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new object pointer.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>If handles are not updated using a GC-safe method, the VM will fault during the next GC.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003100">GCSetObjectReferenceForObject</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl GCSetObjectReferenceForObject (HObject** location, HObject* phobj);
</FONT></PRE>
<P><P>GC-safe method for updating the fields in an object.

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>location</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Pointer to a field of an object. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>phobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new object pointer.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>The safest method to set a field in an object is to use the <B>Field_SetValue</B> method. If objects are not updated using a GC-safe method, the VM will fault during the next GC.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003200">get_methodblock</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct methodblock* __cdecl get_methodblock(HObject *pjobj, char *method_name, 
        char *signature);
</FONT></PRE>
<P><P>Retrieves a pointer to a method block structure containing the class name, method name, and parameter and return types of a method.

<P><B>Return Value:</B> <P>Returns a handle to a method in the given object specified by name and signature. This is useful for functions like <A HREF="rniref.htm#rniref_0008010401000f00">do_execute_java_method</A>,
which can use this information directly instead of having to look it up.
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pjobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the structure.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method_name</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the method to invoke. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>signature</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Types of parameters passed to the constructor. For a description of signature characters, see <A HREF="rniref.htm#rniref_0008010401001600">execute_java_dynamic_method</A>.

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_GetCurrentJavaTimeMillis">GetCurrentJavaTimeMillis</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">__int64 __cdecl GetCurrentJavaTimeMillis();
</FONT></PRE>
<P><P>Returns the same result as defined by <b>java.lang.System.currentTimeMillis()</b>.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003300">GetNativeMethodCallersClass</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl GetNativeMethodCallersClass();
</FONT></PRE>
<P><P>Determines the class type of the caller.

<P><B>Return Value:</B> <P>Returns a pointer to the class type of the caller.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003400">GetNativeMethodCallersMethodInfo</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct methodblock* __cdecl GetNativeMethodCallersMethodInfo();
</FONT></PRE>
<P><P>Retrieves information about the caller's method.

<P><B>Return Value:</B> <P>Returns a method block pointer.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003500">getPendingException</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HObject *getPendingException(ExecEnv *ee);
</FONT></PRE>
<P><P>Retrieves a pending exception. 

<P><B>Return Value:</B> <P>Returns the pending exception; if no exception is pending, NULL is returned.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. Pass NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003600">HResultFromException</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HResult __cdecl HResultFromException(OBJECT* exception_object);
</FONT></PRE>
<P><P>Creates an <B>HRESULT</B> return type from a Java exception object. This function prototype is found in the nativcom.h header file.

<P><B>Return Value:</B> <P>An <B>HRESULT</B> type.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>exception_object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The exception object to covert to an <B>HRESULT</B>.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003700">is_instance_of</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL is_instance_of(JHandle *phobj, ClassClass *dcb, ExecEnv *ee);
</FONT></PRE>
<P><P>Determines whether the specified object <I>phobj</I> can be cast to the specified class type <I>dcb</I>. 

<P><B>Return Value:</B> <P>Returns TRUE if the object can be cast to the class type; otherwise, returns false.
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>phobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A pointer to an object.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dcb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A class type.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. Pass NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003800">is_subclass_of</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL is_subclass_of(ClassClass *cb, ClassClass *dcb, ExecEnv *ee);
</FONT></PRE>
<P><P>Determines whether the class type <I>cb</I> is a subclass of type <I>dcb</I>.

<P><B>Return Value:</B> <P>Returns TRUE if the class is a subclass of <I>dcb</I>; otherwise, returns false.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class type that is being tested.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dcb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class type to test against.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. Pass NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003900">ImplementsInterface</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL ImplementsInterface(ClassClass *cb, ClassClass *icb, ExecEnv *ee);
</FONT></PRE>
<P><P>Determines whether the class type <I>cb</I> implements the interface represented by the <I>icb</I> class type.

<P><B>Return Value:</B> <P>Returns TRUE if the class implements the specified interface.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class type to test.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>icb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class type that represents an interface to test against. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for the execution environment, which is not needed by the Microsoft VM. Pass NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003a00">isInstanceOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL __cdecl isInstanceOf(JHandle *phobj, char *classname);
</FONT></PRE>
<P><P>Determines if a specified Java object is an instance of a particular class.

<P><B>Return Value:</B> <P>Returns TRUE if the handle is an instance of the class, or FALSE otherwise.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pohobj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of the Java handle.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>classname</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of the Java class.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_j2chook_getmethodblock">j2chook_getmethodblock</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">struct methodblock* __cdecl j2chook_getmethodblock(J2CMethodHookInfo *phookinfo);
</FONT></PRE>
<P><P>Returns the methodblock of the target method.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_j2chook_getsizeofuserdata">j2chook_getsizeofuserdata</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">WORD __cdecl j2chook_getsizeofuserdata(J2CMethodHookInfo *phookinfo);
</FONT></PRE>
<P><P>Gets size of user data in the MCCustomMethod descriptor.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_j2chook_getuserdata">j2chook_getuserdata</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">LPVOID __cdecl j2chook_getuserdata(J2CMethodHookInfo *phookinfo);
</FONT></PRE>
<P><P>Gets writable pointer to user data in the MCCustomMethod descriptor.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_j2chook_getvtblindex">j2chook_getvtblindex</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">WORD __cdecl j2chook_getvtblindex(J2CMethodHookInfo *phookinfo);
</FONT></PRE>
<P><P>Returns the vtable index of the target method.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003b00">javaString2CString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">char* __cdecl javaString2CString(Hjava_lang_String *s, char *buf, int buflen);
</FONT></PRE>
<P><P>Retrieves the characters of the Java String object into a C string buffer.

<P><B>Return Value:</B> <P>Returns the address of the C string.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Java String object.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>buf</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">C string buffer.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>buflen</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Length of the C string buffer.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Use this function in place of the JDK <B>makeCString</B> function which is unsupported by the Microsoft Raw Native Interface. No allocation occurs with his function.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003c00">javaStringLength</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl javaStringLength(Hjava_lang_String *s);
</FONT></PRE>
<P><P>Retrieves the length of the Java String object.

<P><B>Return Value:</B> <P>Returns the number of characters in the string.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Java String object.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003d00">javaStringStart</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unicode * __cdecl javaStringStart (HString *string);
</FONT></PRE>
<P><P>Returns a temporary pointer to the first character of the Java String object. It is important that you use this method rather than try to manipulate RNI structures that handle string types. The Microsoft virtual machine handles strings differently in certain situations, and strings may be stored with multiple objects. 

<P><B>Return Value:</B> <P>Returns a string pointer.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>string</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The String handle to reference.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Note that this pointer may change following garbage collection.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_jcdw_java_owned">jcdw_java_owned</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl jcdw_java_owned(Hjava_lang_Object *phJCDW);
</FONT></PRE>
<P><P>Returns true if the virtual machine frees the non-garbage-collected heap memory that this data wrapper contains when the data wrapper is garbage collected.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to the heap memory.
</FONT></TD></TR></TABLE></BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_jcdw_memory_freed_on_gc">jcdw_memory_freed_on_gc</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl jcdw_memory_freed_on_gc(Hjava_lang_Object *phJCDW);
</FONT></PRE>
<P><P>Returns true if the virtual machine allocated the non-garbage-collected heap memory contained by the data wrapper.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to the heap memory.
</FONT></TD></TR></TABLE></BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_jcdwClassOffsetOf">jcdwClassOffsetOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned int __cdecl jcdwClassOffsetOf(Hjava_lang_Object *phJCDWClass, const char *pFieldName);
</FONT></PRE>
<P><P>Returns the byte offset within the non-garbage-collected heap memory to the specified field name from the supplied <b>java.lang.Class</b> object.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to the heap memory.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*pFieldName</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The specified field.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_jcdwClassSizeOf">jcdwClassSizeOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned int __cdecl jcdwClassSizeOf(Hjava_lang_Object *phJavaClass);
</FONT></PRE>
<P><P>Returns the size of the non-garbage-collected heap memory used by instances of the
supplied <b>java.lang.Class</b> object.
<p>
<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJavaClass</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to the heap memory.
</FONT></TD></TR></TABLE></BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_jcdwGetData">jcdwGetData</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void* __cdecl jcdwGetData(Hjava_lang_Object *phJCDW);
</FONT></PRE>
<P><P>Returns the data pointer to the non-garbage-collected heap memory contained by the data wrapper object.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to be replaced.
</FONT></TD></TR></TABLE></BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_jcdwNewData">jcdwNewData</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void* __cdecl jcdwNewData(Hjava_lang_Object *phJCDW, unsigned int numBytes);
</FONT></PRE>
<P><P>Replaces the data pointer contained in the data wrapper with a new quantity of non-garbage-collected heap memory. The previous memory, if any, is freed if it is owned by the VM.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to be replaced.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>numBytes</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The size of the heap memory in bytes.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_jcdwOffsetOf">jcdwOffsetOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned int __cdecl jcdwOffsetOf(Hjava_lang_Object *phJCDW, const char *pFieldName);
</FONT></PRE>
<P><P>Returns the byte offset within the non-garbage-collected heap memory to the specified field name.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to the heap memory.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*pFieldName</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The specified field.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_jcdwSetData">jcdwSetData</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl jcdwSetData(Hjava_lang_Object *phJCDW, LPVOID pv);
</FONT></PRE>
<P><P>Replaces the data pointer that this data wrapper represents with the specified pointer.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to be replaced.
</FONT></TD><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pv</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The specified data pointer.</TR></TABLE></BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="rniref_jcdwSizeOf">jcdwSizeOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">unsigned int __cdecl jcdwSizeOf(Hjava_lang_Object *phJCDW);
</FONT></PRE>
<P><P>Returns the size of the non-garbage-collected heap memory contained by the data wrapper object.

<TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>*phJCDW</I>
</FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The data pointer to the heap memory.
</FONT></TD></TR></TABLE></BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003e00">jio_snprintf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl jio_snprintf(char *str, size_t count, const char *fmt, ...);
</FONT></PRE>
<P><P>Prints to a string with a buffer limit.

<P><B>Return Value:</B> <P>Returns the length of the string after printing to it.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>str</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String to print to.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>count</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Limit of the number of characters to print.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>fmt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Format string (see <B>sprintf</B>).
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401003f00">jio_vsnprintf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl jio_vsnprintf(char *str, size_t count, const char *fmt, va_list  args);
</FONT></PRE>
<P><P>Prints to a string with a buffer limit using a va_list macro for arguments.

<P><B>Return Value:</B> <P>Returns the length of the string after printing to it.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>str</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String to print to.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>count</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Limit of the number of characters to print.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>fmt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Format string (see <B>sprintf</B>).
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>args</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Argument list.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004000">makeJavaString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">Hjava_lang_String* __cdecl makeJavaString(char *str, int len);
</FONT></PRE>
<P><P>Constructs a Java string from a given ANSI C character buffer, converting it to UNICODE.

<P><B>Return Value:</B> <P>Returns a string formatted as a Java String object.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>str</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">C string to convert.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>len</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number of characters in the C string, excluding the terminating NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004100">makeJavaStringW</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">Hjava_lang_String* __cdecl makeJavaStringW( unicode *pszwSrc, int cch );
</FONT></PRE>
<P><P>Constructs a Java string from a Unicode C character buffer.

<P><B>Return Value:</B> <P>Returns a string formatted as a Java String object.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pszwSrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">C string to convert.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cch</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number of characters in the C string, excluding the terminating NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004200">makeJavaStringFromUtf8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">Hjava_lang_String* __cdecl makeJavaStringFromUtf8(const char *pszUtf8);
</FONT></PRE>
<P><P>Creates a new Java String object, initialized from a NULL-terminated, UTF8-formatted, C string.
<P><B>Return Value:</B> <P>Returns a string formatted as a Java String object.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pszUtf8</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Initialization string.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>Unlike the other RNI string conversion functions, <B>makeJavaStringFromUtf8</B> does not require a character count but does requires NULL termination of the UTF8 string.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004300">MakeByteString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HArrayOfByte* __cdecl MakeByteString(char *str, long len);
</FONT></PRE>
<P><P>Creates a new array of bytes initialized from the C string.

<P><B>Return Value:</B> <P>Returns the converted byte string.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>str</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">C string to convert.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>len</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Number characters in the string, excluding the terminating NULL character.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_MarshalCallToJavaObjectHostThread">MarshalCallToJavaObjectHostThread</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HRESULT __cdecl MarshalCallToJavaObjectHostThread(Hjava_lang_Object *phobj, int64_t *pResult);
</FONT></PRE>
<P><P>Reexecutes the RNI method on the apartment thread ID for the supplied Java object. This and <A HREF="rniref.htm#rniref_MarshalCallToJavaThreadID">MarshalCallToJavaThreadID</A> return the following sets of HRESULTs:
<p>S_OK -- The call was successfully marshaled to the target thread. The marshaled call may have generated an exception, which can be checked by calling exceptionOccurred.
<p>S_FALSE -- The call did not require marshaling to the other thread. The currently executing thread is the target thread.
<p>E_<> -- An error occurred inside the MarshalCall API, such as invalid arguments, out of memory, and so on.

<P>The typical use of these APIs is to call the appropriate MarshalCall API and if the HRESULT is S_FALSE, then execute the rest of the RNI method, otherwise return with the value contained in pResult.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_MarshalCallToJavaThreadId">MarshalCallToJavaThreadId</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">HRESULT __cdecl MarshalCallToJavaThreadId(JAVATID tid, int64_t *pResult);
</FONT></PRE>
<P><P>Reexecutes the RNI method on the supplied thread ID for the supplied Java object. This and <A HREF="rniref.htm#rniref_MarshalCallToJavaObjectHostThread">MarshalCallToJavaObjectHostThread</A> return the following sets of HRESULTs:
<p>S_OK -- The call was successfully marshaled to the target thread. The marshaled call may have generated an exception, which can be checked by calling exceptionOccurred.
<p>S_FALSE -- The call did not require marshaling to the other thread. The currently executing thread is the target thread.
<p>E_<> -- An error occurred inside the MarshalCall API, such as invalid arguments, out of memory, and so on.

<P>The typical use of these APIs is to call the appropriate MarshalCall API and if the HRESULT is S_FALSE, then execute the rest of the RNI method, otherwise return with the value contained in pResult.
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004400">Member_GetAttributes</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">int __cdecl   Member_GetAttributes(PVOID member);
</FONT></PRE>
<P><P>Retrieves a combination of the ACC_XXX flags for a field or method, 
as appears in the Java class file.

<P><B>Return Value:</B> <P>Returns attributes flags. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>member</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Method or field block of the member.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004500">Member_GetClass</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl  Member_GetClass(PVOID member);
</FONT></PRE>
<P><P>Retrieves the name of the class that the field or method is implemented in.

<P><B>Return Value:</B> <P>Returns the name of a class. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>member</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of a method or field block.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004600">Member_GetName</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">const char * __cdecl        Member_GetName(PVOID member);
</FONT></PRE>
<P><P>Retrieves the method or field name.

<P><B>Return Value:</B> <P>Returns the method or field name. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>member</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of a method or field block.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004700">Member_GetSignature</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">const char * __cdecl Member_GetSignature(PVOID member);
</FONT></PRE>
<P><P>Retrieves the signature of the field or method.

<P><B>Return Value:</B> <P>Returns a signature. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>member</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Address of a method or field block.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004800">monitorEnter</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl monitorEnter(unsigned int object);
</FONT></PRE>
<P><P>Enters a synchronization object. 

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Synchronization object (cast as an int) to enter.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <B>ObjectMonitorEnter</B> macro to automatically cast the synchronization object to an int and call this method.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004900">monitorExit</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl monitorExit(unsigned int object);
</FONT></PRE>
<P><P>Exits a synchronization object. 

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Synchronization object (cast as an int) to exit.
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <B>ObjectMonitorExit</B> macro to automatically cast the synchronization object to an int and call this method.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004a00">monitorNotify</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl monitorNotify(unsigned int object);
</FONT></PRE>
<P><P>Wakes up a single thread that is waiting on this object's monitor.

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Synchronization object (cast as an int).
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <B>ObjectMonitorNotify</B> macro to automatically cast the synchronization object to an int and call this method. This method is the native equivalent of the <B>Java.lang.Object.notify</B> method.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004b00">monitorNotifyAll</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl monitorNotifyAll(unsigned int object);
</FONT></PRE>
<P><P>Wakes up all threads that are waiting on this object's monitor.

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Synchronization object (cast as an int).
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <B>ObjectMonitorNotifyAll</B> macro to automatically cast the synchronization object to an int and call this method. This method is the native equivalent of the <B>Java.lang.Object.notifyAll</B> method.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004c00">monitorWait</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl monitorWait(unsigned int object);
</FONT></PRE>
<P><P>Waits to be notified by another thread of a change in this object.

<P><B>Return Value:</B> <P>No return value.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>object</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Synchronization object (cast as an int).
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <B>ObjectMonitorWait</B> macro to automatically cast the synchronization object to an int and call this method. This method is the native equivalent of the <B>Java.lang.Object.wait</B> method.

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004d00">Object_GetClass</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">ClassClass * __cdecl    Object_GetClass(HObject *obj);
</FONT></PRE>
<P><P>Retrieves class that the object points to.

<P><B>Return Value:</B> <P>Returns a class object pointer. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Class object to retrieve.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004e00">PrepareThreadForJava</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL __cdecl PrepareThreadForJava(PVOID pThreadEntryFrame);
</FONT></PRE>
<P><P>Thread entry function for calls into the VM. 

<P><B>Return Value:</B> <P>Returns true if successful; otherwise, returns false. <P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pThreadEntryFrame</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An instance of a thread entry frame. This pointer is maintained by the VM and the same pointer should be used in <A HREF="rniref.htm#rniref_0008010401005300">UnprepareThreadForJava</A> when exiting the VM. 
</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This method prepares a Java thread for entering the VM so that calls can be safely made from the thread to native methods. Garbage collection is disabled in between PrepareThreadForJava and UnprepareThreadForJava. An application can hang if each thread waits until it's about to exit before calling <A href="rniref.htm#rniref_0008010401005300">UnprepareThreadForJava</A>.

<P>The following code sample demonstrates the use of invocation APIs:
<PRE><FONT FACE="Courier" SIZE="2">

 Demonstrates the use of the PrepareThreadForJava and UnprepareThreadForJava
 invocation APIs.
//

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;native.h&gt;

void main(int argc, char *argv[])
{
    ThreadEntryFrame threadEntryFrame;
    ClassClass *pClass;

     Call this API before calling into the Microsoft VM to allow it
     to allocate any per-thread structures and to do any first-time
     initialization. After return from this call, Java objects may be
     accessed or RNI APIs may be called.
    if (PrepareThreadForJava(&amp;threadEntryFrame)) {

        pClass = FindClass(NULL, "TestClass", TRUE);

        if (pClass != NULL) {
            execute_java_static_method(NULL, pClass, "someMethod", "()V");
        } else {
            printf("Failed to find class!\n");
        }

         Detaches the "entry frame" from this thread.  After return from this
         call, it is no longer safe to directly touch Java objects or call
         RNI APIs.
        UnprepareThreadForJava(&amp;threadEntryFrame);

    } else {
        printf("Failed to initialize thread!\n");
    }
}
</FONT></PRE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401004f00">RNIGetCompatibleVersion</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">DWORD __declspec(dllexport) __cdecl RNIGetCompatibleVersion();
</FONT></PRE>
<P><P>Allows the VM to determine if the dynamic link library (DLL) is compatible.

<P><B>Return Value:</B> <P>Returns the version used by the DLL (defined as RNIVER in native.h).

<P><B>Remarks:</B> <P>All raw native interface DLLs must export this function to enable compatibility-checking by the VM.
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401005000">SignalError</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl SignalError(struct execenv *ee, char *ename, char *DetailMessage);
</FONT></PRE>
<P><P>Creates a Java exception object, which is thrown upon returning from the native code. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ee</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Placeholder for executive environment, which is not needed. 
 This parameter should be NULL. 
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ename</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of a valid Throwable exception class or subclass.
 </FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>DetailMessage</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Message to display with the exception. Can be set to NULL.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401005100">SignalErrorHResult</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl SignalErrorHResult(HRESULT theHRESULT);
</FONT></PRE>
<P><P>Creates a Java exception object from an <B>HRESULT</B> return type. This function prototype is found in the nativcom.h header file.

<P><B>Return Value:</B> <P>No return value.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>theHRESULT</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The standard return value that indicates whether a function call is a success. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="rniref_0008010401005200">SignalErrorPrintf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">void __cdecl SignalErrorPrintf( char *ename, char *pszFormat, ...);
</FONT></PRE>
<P><P>Creates a Java exception object and specifies a format string for exception description to be printed when thrown.

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ename</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Name of a valid Throwable exception class or subclass.
</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pszFormat</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Format string. See C <B>printf</B> function.
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401005400">Thread_IsInterrupted</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">BOOL __cdecl Thread_IsInterrupted(BOOL fResetInterruptFlag);
</FONT></PRE>
<P><P>Checks to see if the current thread is interrupted and optionally resets the interrupt flag. Used in RNI code to see if some other thread has called Thread.interrupt and wants you to stop whatever you are doing. 
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>fResetInterruptFlag</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Indicates whether to reset the interrupt flag. 
</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="rniref_0008010401005300">UnprepareThreadForJava</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">VOID __cdecl UnprepareThreadForJava(PVOID pThreadEntryFrame);
</FONT></PRE>
<P><P>Thread exit function for calls into the VM. 

<P><B>Return Value:</B> <P>Returns true if successful; otherwise, returns false.<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pThreadEntryFrame</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An instance of a thread entry frame. This pointer is maintained by the VM and is the same pointer used in <A HREF="rniref.htm#rniref_0008010401004e00">PrepareThreadForJava</A> when entering the VM. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This method should be called from any thread when exiting the VM. Garbage collection is disabled in between <A HREF="rniref.htm#rniref_0008010401004e00">PrepareThreadForJava</A> and UnprepareThreadForJava. An application can hang if each thread waits until it's about to exit before calling UnprepareThreadForJava.
</BLOCKQUOTE>
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
