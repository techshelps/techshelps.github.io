<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class SafeArray</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Packages"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="SafeArray.htm#com_000300050c010000">Constructors</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="SafeArray.htm#com_000300050c020000">Methods</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="355" VALIGN="bottom"><IMG SRC="art/package2.gif" WIDTH="355" HEIGHT="27"  BORDER=0 ALT="Packages"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom"><A HREF="LicenseMgr.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_pcom.htm"><IMG SRC="art/pkgnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="This Package"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="STATSTG.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="355" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Package com.ms.com</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">This<BR>Package</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Class SafeArray</H2>
<PRE><FONT FACE="Courier" SIZE="2">public final class SafeArray
{
  // Constructors
  public <A HREF="SafeArray.htm#com_000300050c010100">SafeArray</A>(int vt);
  public <A HREF="SafeArray.htm#com_000300050c010200">SafeArray</A>(int vt, int celems);
  public <A HREF="SafeArray.htm#com_000300050c010300">SafeArray</A>(int vt, int celems1, int celems2);
  public <A HREF="SafeArray.htm#com_000300050c010400">SafeArray</A>(int vt, int lbounds[], int celems[]);
  public <A HREF="SafeArray.htm#com_000300050c010500">SafeArray</A>(String s);
  public native int <A HREF="SafeArray.htm#com_000300050c010600">getPhysicalSafeArray</A>();

  // Methods
  public native String <A HREF="SafeArray.htm#com_000300050c020100">asString</A>();
  public Object <A HREF="SafeArray.htm#com_000300050c020200">clone</A>();
  public void <A HREF="SafeArray.htm#com_000300050c020300">destroy</A>();
  protected void <A HREF="SafeArray.htm#com_000300050c020400">finalize</A>();
  public void <A HREF="SafeArray.htm#com_000300050c020500">fromBooleanArray</A>(boolean ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020600">fromByteArray</A>(byte ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020700">fromCharArray</A>(char ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020800">fromDoubleArray</A>(double ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020900">fromFloatArray</A>(float ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020a00">fromIntArray</A>(int ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020b00">fromShortArray</A>(short ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020c00">fromStringArray</A>(String ja[]);
  public void <A HREF="SafeArray.htm#com_000300050c020d00">fromVariantArray</A>(Variant ja[]);
  public native boolean <A HREF="SafeArray.htm#com_000300050c020e00">getBoolean</A>(int sa_idx);
  public boolean <A HREF="SafeArray.htm#com_000300050c020f00">getBoolean</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c021000">getBooleans</A>(int sa_idx, int nelems, boolean ja[], int
        ja_start);
  public byte <A HREF="SafeArray.htm#com_000300050c021100">getByte</A>(int sa_idx);
  public byte <A HREF="SafeArray.htm#com_000300050c021200">getByte</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c021300">getBytes</A>(int sa_idx, int nelems, byte ja[],
        int ja_start);
  public char <A HREF="SafeArray.htm#com_000300050c021400">getChar</A>(int sa_idx);
  public char <A HREF="SafeArray.htm#com_000300050c021500">getChar</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c021600">getChars</A>(int sa_idx, int nelems, char ja[],
        int ja_start);
  public native double <A HREF="SafeArray.htm#com_000300050c021700">getDouble</A>(int sa_idx);
  public double <A HREF="SafeArray.htm#com_000300050c021800">getDouble</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c021900">getDoubles</A>(int sa_idx, int nelems, double ja[],
        int ja_start);
  public int <A HREF="SafeArray.htm#com_000300050c021a00">getElemSize</A>();
  public int <A HREF="SafeArray.htm#com_000300050c021b00">getFeatures</A>();
  public native float <A HREF="SafeArray.htm#com_000300050c021c00">getFloat</A>(int sa_idx);
  public float <A HREF="SafeArray.htm#com_000300050c021d00">getFloat</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c021e00">getFloats</A>(int sa_idx, int nelems, float ja[],
        int ja_start);
  public native int <A HREF="SafeArray.htm#com_000300050c021f00">getInt</A>(int sa_idx);
  public int <A HREF="SafeArray.htm#com_000300050c022000">getInt</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c022100">getInts</A>(int sa_idx, int nelems, int ja[],
        int ja_start);
  public int <A HREF="SafeArray.htm#com_000300050c022200">getLBound</A>();
  public int <A HREF="SafeArray.htm#com_000300050c022300">getLBound</A>(int dim);
  public int <A HREF="SafeArray.htm#com_000300050c022400">getNumDim</A>();
  public int <A HREF="SafeArray.htm#com_000300050c022500">getNumLocks</A>();
  public short <A HREF="SafeArray.htm#com_000300050c022600">getShort</A>(int sa_idx);
  public short <A HREF="SafeArray.htm#com_000300050c022700">getShort</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c022800">getShorts</A>(int sa_idx, int nelems, short ja[],
        int ja_start);
  public String <A HREF="SafeArray.htm#com_000300050c022900">getString</A>(int sa_idx);
  public String <A HREF="SafeArray.htm#com_000300050c022a00">getString</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c022b00">getStrings</A>(int sa_idx, int nelems, String ja[],
        int ja_start);
  public int <A HREF="SafeArray.htm#com_000300050c022c00">getUBound</A>();
  public int <A HREF="SafeArray.htm#com_000300050c022d00">getUBound</A>(int dim);
  public Variant <A HREF="SafeArray.htm#com_000300050c022e00">getVariant</A>(int sa_idx);
  public Variant <A HREF="SafeArray.htm#com_000300050c022f00">getVariant</A>(int sa_idx1, int sa_idx2);
  public void <A HREF="SafeArray.htm#com_000300050c023000">getVariants</A>(int sa_idx, int nelems, Variant ja[], int
        ja_start);
  public int <A HREF="SafeArray.htm#com_000300050c023100">getvt</A>();
  public void <A HREF="SafeArray.htm#com_000300050c023200">reinit</A>(SafeArray sa);
  public void <A HREF="SafeArray.htm#com_000300050c023300">reinterpretType</A>(int vt);
  public native void <A HREF="SafeArray.htm#com_000300050c023400">setBoolean</A>(int idx, boolean val);
  public void <A HREF="SafeArray.htm#com_000300050c023500">setBoolean</A>(int idx1, int idx2, boolean val);
  public void <A HREF="SafeArray.htm#com_000300050c023600">setBooleans</A>(int sa_idx, int nelems, boolean ja[], int
        ja_start);
  public void <A HREF="SafeArray.htm#com_000300050c023700">setByte</A>(int idx, byte val);
  public void <A HREF="SafeArray.htm#com_000300050c023800">setByte</A>(int idx1, int idx2, byte val);
  public void <A HREF="SafeArray.htm#com_000300050c023900">setBytes</A>(int sa_idx, int nelems, byte ja[],
        int ja_start);
  public void <A HREF="SafeArray.htm#com_000300050c023a00">setChar</A>(int idx, char val);
  public void <A HREF="SafeArray.htm#com_000300050c023b00">setChar</A>(int idx1, int idx2, char val);
  public void <A HREF="SafeArray.htm#com_000300050c023c00">setChars</A>(int sa_idx, int nelems, char ja[],
        int ja_start);
  public native void <A HREF="SafeArray.htm#com_000300050c023d00">setDouble</A>(int idx, double val);
  public void <A HREF="SafeArray.htm#com_000300050c023e00">setDouble</A>(int idx1, int idx2, double val);
  public void <A HREF="SafeArray.htm#com_000300050c023f00">setDoubles</A>(int sa_idx, int nelems, double ja[],
        int ja_start);
  public native void <A HREF="SafeArray.htm#com_000300050c024000">setFloat</A>(int idx, float val);
  public void <A HREF="SafeArray.htm#com_000300050c024100">setFloat</A>(int idx1, int idx2, float val);
  public void <A HREF="SafeArray.htm#com_000300050c024200">setFloats</A>(int sa_idx, int nelems, float ja[],
        int ja_start);
  public native void <A HREF="SafeArray.htm#com_000300050c024300">setInt</A>(int idx, int val);
  public void <A HREF="SafeArray.htm#com_000300050c024400">setInt</A>(int idx1, int idx2, int val);
  public void <A HREF="SafeArray.htm#com_000300050c024500">setInts</A>(int sa_idx, int nelems, int ja[],
        int ja_start);
  public void <A HREF="SafeArray.htm#com_000300050c024600">setShort</A>(int idx, short val);
  public void <A HREF="SafeArray.htm#com_000300050c024700">setShort</A>(int idx1, int idx2, short val);
  public void <A HREF="SafeArray.htm#com_000300050c024800">setShorts</A>(int sa_idx, int nelems, short ja[],
        int ja_start);
  public void <A HREF="SafeArray.htm#com_000300050c024900">setString</A>(int idx, String val);
  public void <A HREF="SafeArray.htm#com_000300050c024a00">setString</A>(int idx1, int idx2, String val);
  public void <A HREF="SafeArray.htm#com_000300050c024b00">setStrings</A>(int sa_idx, int nelems, String ja[],
        int ja_start);
  public void <A HREF="SafeArray.htm#com_000300050c024c00">setVariant</A>(int idx, Variant val);
  public void <A HREF="SafeArray.htm#com_000300050c024d00">setVariant</A>(int idx1, int idx2, Variant val);
  public void <A HREF="SafeArray.htm#com_000300050c024e00">setVariants</A>(int sa_idx, int nelems, Variant ja[], int
        ja_start);
  public boolean[] <A HREF="SafeArray.htm#com_000300050c024f00">toBooleanArray</A>();
  public byte[] <A HREF="SafeArray.htm#com_000300050c025000">toByteArray</A>();
  public char[] <A HREF="SafeArray.htm#com_000300050c025100">toCharArray</A>();
  public double[] <A HREF="SafeArray.htm#com_000300050c025200">toDoubleArray</A>();
  public float[] <A HREF="SafeArray.htm#com_000300050c025300">toFloatArray</A>();
  public int[] <A HREF="SafeArray.htm#com_000300050c025400">toIntArray</A>();
  public short[] <A HREF="SafeArray.htm#com_000300050c025500">toShortArray</A>();
  public String <A HREF="SafeArray.htm#com_000300050c025600">toString</A>();
  public String[] <A HREF="SafeArray.htm#com_000300050c025700">toStringArray</A>();
  public Variant[] <A HREF="SafeArray.htm#com_000300050c025800">toVariantArray</A>();
}
</FONT></PRE>
<P>This class wraps a Microsoft&#174; ActiveX&#174; Automation <B>SAFEARRAY</B> data structure. It bridges Java with the Automation object by wrapping a pointer to the native <B>SAFEARRAY</B> data structure. It does not duplicate the array data in Java form. This approach minimizes translation overhead but imposes extra rules on <B>SafeArray</B> usage. 
<P>The rules for using this class are simple, but they must be followed: 
<OL><LI>A Java method that receives a <B>SafeArray</B> object as a parameter can use that object only for the duration of the method call. If a longer-term copy is needed, either the <B>SafeArray</B> object must be converted to a Java array, or the <A HREF="SafeArray.htm#com_000300050c020200">clone</A> method must be used to create an independent copy of the object. 
<LI>If a Java method returns a <B>SafeArray</B> object, that object is owned by the caller; the Java method must no longer use that <B>SafeArray</B> instance. The simplest way to follow this rule is to have the called method construct a new <B>SafeArray</B> object each time it is called. 
</OL>
<P>In addition to maintaining a pointer to a native <B>SAFEARRAY</B> data structure, a <B>SafeArray</B> instance separately maintains the exact variant type of <B>SAFEARRAY</B> data structure elements. The variant type is determined by an argument to the <B>SafeArray</B> class constructor or is bound into the .java file by the jactivex tool. The system class <A HREF="Variant.htm">com.ms.com.Variant</A> defines public constants (<A HREF="Variant.htm">Variant</A>.VariantXXX) for all of the valid variant types. It is important to note that neither the <A HREF="Variant.htm#com_000300050e030003">VariantByref</A> nor the <A HREF="Variant.htm#com_000300050e030001">VariantArray</A> modifier should be set in the element variant type; setting either of these modifiers will cause a run-time error to occur. 
<P>The <B>SAFEARRAY</B> data structure does not have reference counts, so the process of creating and destroying <B>SAFEARRAY</B> data structures cannot be made completely transparent to the Java programmer. Therefore, the <B>SafeArray</B> class can only be loaded by a trusted applet. 
<P><B>SafeArray</B>s of type VT_UNKNOWN or VT_DISPATCH can be manipulated by using variant-typed manipulators and then extracting the COM object from the variant, as in the following example. 
<PRE><FONT FACE="Courier" SIZE="2">   SafeArray sa;
   Object elem = sa.getVariant(index).toObject();
</FONT></PRE>
<P>However, support for this technique is limited to cases where the variant was obtained from an object whose threading model is either free or both. In most other cases, a <A HREF="WrongThreadException.htm">WrongThreadException</A> is thrown. The conflicting requirements of COM's apartment threading model and Java's non-message-based model preclude an efficient representation of <B>SafeArray</B>s of <B>Object</B>s. 
<P><B>Note for JavaTLB users: </B>The JavaTLB tool (which has been superceded by the jactivex tool) emits an older class file format that does not provide the exact variant type. This means in some cases, the <B>SAFEARRAY</B> data structure will not provide enough information to determine an exact variant type. In this case, the Java runtime will choose a default variant type based on the following heuristics: 
<UL><LI><B>SAFEARRAY</B> data structures with elements of type VT_BSTR, VT_UNKNOWN, VT_DISPATCH or VT_VARIANT are explicitly flagged as such in the <B>SAFEARRAY</B> data structure; thus, these will always marshal correctly. 
<LI>If not explicitly flagged, a <B>SAFEARRAY</B> data structure whose element size is 1 is presumed to be of type VT_UI1. Similarly, if the element size is 2, the <B>SAFEARRAY</B> is presumed to be of type VT_I2. If the element size is 4, type VT_I4 is presumed, and if the element size is 8, VT_R8 is presumed. Otherwise, a <B>ClassCastException</B> is thrown. 
<LI>If a variant type other than the default is needed, the interface .java files must either be rebuilt using the jactivex tool or the <A HREF="SafeArray.htm#com_000300050c023300">reinterpretType</A> method must be used to override the default variant type. 
</UL>
<H3 STYLE="color:#333366"><A NAME="com_000300050c010000">Constructors</A></H3><H4 STYLE="color:#333366"><A NAME="com_000300050c010100">SafeArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public SafeArray(int vt);
</FONT></PRE>
<P><P>Creates a <A HREF="SafeArray.htm">SafeArray</A> instance that wraps the NULL pointer. The main purpose of this constructor is to pass NULL to Component Object Model (COM) methods that accept <B>SAFEARRAY</B>s. 
<P>The variant type of the element must be one of the <A HREF="Variant.htm">Variant</A>.VariantXXX constants. Neither the <A HREF="Variant.htm#com_000300050e030003">VariantByref</A> nor the <A HREF="Variant.htm#com_000300050e030001">VariantArray</A> modifier should be set in the element variant type; setting either of these modifiers will cause a run-time error to occur. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>vt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The variant type of the element. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c010200">SafeArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public SafeArray(int vt, int celems);
</FONT></PRE>
<P><P>Creates a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> object. Valid indices range from zero (inclusive) to <I>celems</I> (exclusive). Note that this convention follows the C language practice of indicating the number of elements rather than the Microsoft&#174; Visual Basic&#174; convention of indicating the upper bound. 
<P>The variant type of the element must be one of the <A HREF="Variant.htm">Variant</A>.VariantXXX constants. Neither the <A HREF="Variant.htm#com_000300050e030001">VariantArray</A> nor the <A HREF="Variant.htm#com_000300050e030003">VariantByref</A> modifier may be set. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>vt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The variant type of the element. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>celems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c010300">SafeArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public SafeArray(int vt, int celems1, int celems2);
</FONT></PRE>
<P><P>Creates a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> object. The constructor follows the C language practice of indicating the number of elements rather than the Microsoft&#174; Visual Basic&#174; convention of indicating the upper bound. 
<P>The expression: 
<P>
<PRE><FONT FACE="Courier" SIZE="2">new SafeArray(Variant.VariantVariant, 21, 11); </FONT></PRE>
<P>is equivalent to the Visual Basic declaration: 
<P>
<PRE><FONT FACE="Courier" SIZE="2">Option Base 0&#009;
Dim A(20, 10)</FONT></PRE>
<P>The variant type of the element must be one of the <A HREF="Variant.htm">Variant</A>.VariantXXX constants. Neither the <A HREF="Variant.htm#com_000300050e030003">VariantByref</A> nor the <A HREF="Variant.htm#com_000300050e030001">VariantArray</A> modifier should be set in the element variant type; setting either of these modifiers will cause a run-time error to occur. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>vt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The variant type of the element. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>celems1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements in the first dimension. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>celems2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements in the second dimension. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c010400">SafeArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public SafeArray(int vt, int lbounds[], int celems[]);
</FONT></PRE>
<P><P>Creates a <A HREF="SafeArray.htm">SafeArray</A> object of arbitrary shape. The <I>lbounds</I> array indicates the lower bound of each dimension. The <I>celems</I> array (which must have the same length as <I>lbounds</I>) gives the number of elements that are in each dimension. If <I>lbounds</I> is null, all the lower bound values default to zero. The variant type of the element must be one of the <A HREF="Variant.htm">Variant</A>.VariantXXX constants. Neither the <A HREF="Variant.htm#com_000300050e030001">VariantArray</A> nor <A HREF="Variant.htm#com_000300050e030003">VariantByref</A> modifier may be set. 
<P>The following Java code creates a 3-dimensional <A HREF="SafeArray.htm">SafeArray</A>: 
<P>
<PRE><FONT FACE="Courier" SIZE="2">int lbounds[] = {-1,-3, -4}; 
int celems[] = {10, 20, 30}; 
SafeArray A = new SafeArray(Variant.VariantVariant, lbounds, 
celems); 
</FONT></PRE>
<P>This Visual Basic declaration creates an array with the same shape as the <A HREF="SafeArray.htm">SafeArray</A> created above: 
<P>
<PRE><FONT FACE="Courier" SIZE="2">Dim A(-1 To 8, -3 To 16, -4 To 25) 
</FONT></PRE>
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>vt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The variant type of the element. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>lbounds</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The lower bounds of each dimension. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>celems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements in each dimension. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c010500">SafeArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public SafeArray(String s);
</FONT></PRE>
<P><P>Creates a VT_UI1 <A HREF="SafeArray.htm">SafeArray</A> object from a string. Each character of the string occupies two elements of the array to form a single Unicode character. The array is not null terminated. This constructor corresponds to the standard Automation conversion from VT_BSTR to VT_ARRAY|VT_UI1. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string used to initialize the new <A HREF="SafeArray.htm">SafeArray</A> object. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c010600">getPhysicalSafeArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native int getPhysicalSafeArray();
</FONT></PRE>
<P><P>Retrieves the linear address of the actual <B>SAFEARRAY</B> data structure, which is packaged as a Java integer. This method is provided only to aid in debugging. Other than displaying information, there are no useful operations that can be performed with this value from Java. 

<P><B>Return Value:</B> <P>Returns the linear address of the represented <B>SAFEARRAY</B>. 

</BLOCKQUOTE>
<H3 STYLE="color:#333366"><A NAME="com_000300050c020000">Methods</A></H3><H4 STYLE="color:#333366"><A NAME="com_000300050c020100">asString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native String asString();
</FONT></PRE>
<P><P>Converts a VT_UI1 <A HREF="SafeArray.htm">SafeArray</A> to a string. This method corresponds to the <B>VariantChangeType</B> conversion from VT_ARRAY|VT_UI1 to VT_BSTR. 

<P><B>Return Value:</B> <P>Returns the converted value. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020200">clone</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public Object clone();
</FONT></PRE>
<P><P>Creates an exact and independent duplicate of the <A HREF="SafeArray.htm">SafeArray</A> object. This method is a wrapper around the Microsoft&#174; Win32&#174; <B>SafeArrayCopy</B> function. 

<P><B>Return Value:</B> <P>Returns a new <A HREF="SafeArray.htm">SafeArray</A> object that contains an independent duplicate. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020300">destroy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void destroy();
</FONT></PRE>
<P><P>Forcefully invokes the Win32 function <B>SafeArrayDestroy</B>. 
<P><B>Caution</B>  This is a potentially dangerous routine that should be used with extreme caution. It is not necessary to invoke this method when following standard COM memory ownership rules. This is because the Java/COM integration subsystem and the Java garbage collector work together to ensure correct disposal of <A HREF="SafeArray.htm">SafeArray</A>s. 
<P><B>Return Value:</B> <P>No return value. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020400">finalize</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">protected void finalize();
</FONT></PRE>
<P><P>Performs cleanup tasks before garbage collection. 

<P><B>Return Value:</B> <P>No return value. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020500">fromBooleanArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromBooleanArray(boolean ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  If you are modifying a large number of elements, it may be more efficient to use <A HREF="SafeArray.htm#com_000300050c020700">fromCharArray</A> rather than <B>fromBooleanArray</B>. Since boolean <A HREF="SafeArray.htm">SafeArray</A>s use two bytes per element, the <B>fromBooleanArray</B> method cannot optimize itself to a memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020600">fromByteArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromByteArray(byte ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020700">fromCharArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromCharArray(char ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020800">fromDoubleArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromDoubleArray(double ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020900">fromFloatArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromFloatArray(float ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020a00">fromIntArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromIntArray(int ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020b00">fromShortArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromShortArray(short ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020c00">fromStringArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromStringArray(String ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020d00">fromVariantArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void fromVariantArray(Variant ja[]);
</FONT></PRE>
<P><P>Initializes <A HREF="SafeArray.htm">SafeArray</A> elements from a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is initialized from element zero of the Java array. 
<P>If the Java array is shorter than the number of <A HREF="SafeArray.htm">SafeArray</A> elements, the remaining <B>SafeArray</B> elements are left unmodified. If the Java array is longer than the number of <B>SafeArray</B> elements, the extra elements are ignored. 
<P><B>Note</B>  Although <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the element type. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020e00">getBoolean</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native boolean getBoolean(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a boolean. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>sa_idx</I> is not between the lower bound and the upper bound of the array (inclusive). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c020f00">getBoolean</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public boolean getBoolean(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a boolean. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if neither index is between the lower bound and the upper bound of the array (inclusive). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021000">getBooleans</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getBooleans(int sa_idx, int nelems, boolean ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements as booleans. If the <A HREF="SafeArray.htm">SafeArray</A> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  If you extract a large number of elements, it may be more efficient to use <A HREF="SafeArray.htm#com_000300050c021600">getChars</A> rather than <B>getBooleans</B>. Since boolean <A HREF="SafeArray.htm">SafeArray</A> objects use two bytes per element, the <B>getBooleans</B> method cannot optimize itself to a memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021100">getByte</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public byte getByte(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a byte. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>sa_idx</I> lies outside the defined range (<B>LBound()</B> to <B>UBound()</B>). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021200">getByte</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public byte getByte(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a byte. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021300">getBytes</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getBytes(int sa_idx, int nelems, byte ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements as bytes. If the <A HREF="SafeArray.htm">SafeArray</A> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Java The array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021400">getChar</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public char getChar(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a character. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>sa_idx</I> lies outside the defined range (<B>LBound()</B> to <B>UBound()</B>). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021500">getChar</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public char getChar(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional array as a character. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021600">getChars</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getChars(int sa_idx, int nelems, char ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements of a <A HREF="SafeArray.htm">SafeArray</A> as characters. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021700">getDouble</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native double getDouble(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a double. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>sa_idx</I> lies outside the defined range (<B>LBound()</B> to <B>UBound()</B>). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021800">getDouble</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public double getDouble(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a double. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021900">getDoubles</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getDoubles(int sa_idx, int nelems, double ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements of a <A HREF="SafeArray.htm">SafeArray</A> as doubles. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021a00">getElemSize</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getElemSize();
</FONT></PRE>
<P><P>Retrieves the size of a single element. 

<P><B>Return Value:</B> <P>Returns the size of a single element, measured in bytes. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021b00">getFeatures</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getFeatures();
</FONT></PRE>
<P><P>Retrieves the contents of the <B>fFeatures</B> bitmask. This bitmask (defined as part of the OLE <B>SAFEARRAY</B> data structure) provides various types of information about the <B>SAFEARRAY</B>. 

<P><B>Return Value:</B> <P>Returns the <B>fFeatures</B> field. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021c00">getFloat</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native float getFloat(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a float. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>sa_idx</I> lies outside the defined range (<B>LBound()</B>..<B>UBound()</B>). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021d00">getFloat</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public float getFloat(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a float. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021e00">getFloats</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getFloats(int sa_idx, int nelems, float ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements of a <A HREF="SafeArray.htm">SafeArray</A> as floats. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c021f00">getInt</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native int getInt(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as an integer. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type using the Win32 <B>VariantChangeType</B> function. 


<P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>sa_idx</I> lies outside the defined range (<B>LBound()</B> to <B>UBound()</B>). 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022000">getInt</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getInt(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional array as an integer. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


<P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022100">getInts</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getInts(int sa_idx, int nelems, int ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements of the <A HREF="SafeArray.htm">SafeArray</A> as integers. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022200">getLBound</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getLBound();
</FONT></PRE>
<P><P>Retrieves the smallest valid index of the array's first dimension. This method is identical to the Visual Basic <B>LBound</B> function. 

<P><B>Return Value:</B> <P>Returns the smallest valid index. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022300">getLBound</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getLBound(int dim);
</FONT></PRE>
<P><P>Retrieves the smallest valid index of an arbitrary dimension. (Dimensions are numbered, starting with 1.) This method is identical to the Visual Basic <B>LBound</B> function. 

<P><B>Return Value:</B> <P>Returns the smallest valid index. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dim</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The dimension. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022400">getNumDim</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getNumDim();
</FONT></PRE>
<P><P>Obtains the number of <A HREF="SafeArray.htm">SafeArray</A> dimensions. 

<P><B>Return Value:</B> <P>Returns the number of dimensions in the <A HREF="SafeArray.htm">SafeArray</A> (2 for two-dimensional <B>SafeArray</B>s, for example). 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022500">getNumLocks</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getNumLocks();
</FONT></PRE>
<P><P>Retrieves the number of outstanding locks on the <A HREF="SafeArray.htm">SafeArray</A> object. This value (which is usually zero) is only useful for debugging purposes. 

<P><B>Return Value:</B> <P>Returns the outstanding lock count. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022600">getShort</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public short getShort(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a short integer. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>sa_idx</I> lies outside the defined range (<B>LBound()</B> to <B>UBound()</B>). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022700">getShort</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public short getShort(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a short integer. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022800">getShorts</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getShorts(int sa_idx, int nelems, short ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements as short integers. If the <A HREF="SafeArray.htm">SafeArray</A> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022900">getString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public String getString(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a string. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>sa_idx</I> does not lie between the lower bound and the upper bound of the array (inclusive). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022a00">getString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public String getString(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a string. 

<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index does not lie between the lower bound and the upper bound of the array (inclusive). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022b00">getStrings</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getStrings(int sa_idx, int nelems, String ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements of a <A HREF="SafeArray.htm">SafeArray</A> as strings. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022c00">getUBound</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getUBound();
</FONT></PRE>
<P><P>Returns the largest valid index of the array's first dimension. This method is identical to the Microsoft&#174; Visual Basic&#174; <B>UBound</B> function. 

<P><B>Return Value:</B> <P>Returns the largest valid index. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022d00">getUBound</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getUBound(int dim);
</FONT></PRE>
<P><P>Retrieves the largest valid index of an arbitrary dimension. (Dimensions are numbered starting with 1.) This method is identical to the Visual Basic <B>UBound</B> function. 

<P><B>Return Value:</B> <P>Returns the largest valid index. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>dim</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The dimension. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022e00">getVariant</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public Variant getVariant(int sa_idx);
</FONT></PRE>
<P><P>Extracts an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a <A HREF="Variant.htm">Variant</A>. 
<P><B>Note</B>  Although the <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the <B>SafeArray</B> type rather than to extract first as a <B>Variant</B>,and then to coerce the <B>Variant</B>. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>. 
<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>sa_idx</I> does not lie between the lower bound of the array and the upper bound of the array (inclusive). 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c022f00">getVariant</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public Variant getVariant(int sa_idx1, int sa_idx2);
</FONT></PRE>
<P><P>Extracts an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A> as a <A HREF="Variant.htm">Variant</A>. 
<P><B>Note</B>  Although the <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the <B>SafeArray</B> type rather than to extract first as a <B>Variant</B>, and then to coerce the <B>Variant</B>. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>Returns the converted element value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element that is extracted, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element that is extracted, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> element cannot be converted to the correct type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023000">getVariants</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void getVariants(int sa_idx, int nelems, Variant ja[], int ja_start);
</FONT></PRE>
<P><P>Extracts multiple elements as <A HREF="Variant.htm">Variant</A> objects. If the <A HREF="SafeArray.htm">SafeArray</A> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  Although the <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the <B>SafeArray</B> type rather than to extract first as a <B>Variant</B>, and then to coerce the <B>Variant</B>. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to retrieve. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to retrieve. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that receives the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that receives a value. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023100">getvt</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int getvt();
</FONT></PRE>
<P><P>Retrieves the variant type of the <A HREF="SafeArray.htm">SafeArray</A> elements. This corresponds to a public constant, com.ms.com.VariantXXX. 
<P><B>Note</B>  If JavaTLB is used to generate the Java method information that passes a <A HREF="SafeArray.htm">SafeArray</A> from COM to Java, the variant type may be inexact. (The element size, however, will always be correct.) JavaTLB has been superceded by the jactivex tool, which binds the exact variant type into the .class file. 
<P><B>Return Value:</B> <P>Returns the variant type of the element. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023200">reinit</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void reinit(SafeArray sa);
</FONT></PRE>
<P><P>Reinitializes the <A HREF="SafeArray.htm">SafeArray</A> object. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The <A HREF="SafeArray.htm">SafeArray</A> object that is reinitialized. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023300">reinterpretType</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void reinterpretType(int vt);
</FONT></PRE>
<P><P>Forces the <A HREF="SafeArray.htm">SafeArray</A> to interpret elements as another variant type. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>vt</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new variant type of the element. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023400">setBoolean</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native void setBoolean(int idx, boolean val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from index of the lower bound to the index of the upper bound. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>idx</I> does not lie between the lower bound and the upper bound of the <A HREF="SafeArray.htm">SafeArray</A> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023500">setBoolean</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setBoolean(int idx1, int idx2, boolean val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023600">setBooleans</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setBooleans(int sa_idx, int nelems, boolean ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element to be set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  If you are modifying a large number of elements, it may be more efficient to use <A HREF="SafeArray.htm#com_000300050c023c00">setChars</A> rather than <B>setBooleans</B>. Since boolean <A HREF="SafeArray.htm">SafeArray</A>s use two bytes per element, the <B>setBooleans</B> method cannot optimize itself to a memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of first element in <I>ja</I> to use. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023700">setByte</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setByte(int idx, byte val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the element to set, which ranges from the lower bound to the upper bound of the <A HREF="SafeArray.htm">SafeArray</A>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>idx</I> does not lie between the lower bound and the upper bound of the <A HREF="SafeArray.htm">SafeArray</A> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023800">setByte</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setByte(int idx1, int idx2, byte val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023900">setBytes</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setBytes(int sa_idx, int nelems, byte ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element to be set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimize to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> to use. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023a00">setChar</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setChar(int idx, char val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the element to set, which ranges from the lower bound to the upper bound of the <A HREF="SafeArray.htm">SafeArray</A>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>idx</I> does not lie between the lower bound and the upper bound of the <B>SafeArray</B> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023b00">setChar</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setChar(int idx1, int idx2, char val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023c00">setChars</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setChars(int sa_idx, int nelems, char ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements. If the <A HREF="SafeArray.htm">SafeArray</A> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element to be set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> that is used. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023d00">setDouble</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native void setDouble(int idx, double val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the lower bound to the upper bound of the <A HREF="SafeArray.htm">SafeArray</A>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>idx</I> does not lie between the lower bound and the upper bound of the <B>SafeArray</B> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023e00">setDouble</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setDouble(int idx1, int idx2, double val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c023f00">setDoubles</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setDoubles(int sa_idx, int nelems, double ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element to be set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that provides the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to use in <I>ja</I>. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024000">setFloat</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native void setFloat(int idx, float val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from index of the lower bound to the index of the upper bound. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>idx</I> is not between the lower bound and the upper bound of the <B>SafeArray</B> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024100">setFloat</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setFloat(int idx1, int idx2, float val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional array. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024200">setFloats</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setFloats(int sa_idx, int nelems, float ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> to use. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024300">setInt</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native void setInt(int idx, int val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 is thrown if the <A HREF="SafeArray.htm">SafeArray</A> is not one-dimensional or if <I>idx</I> does not lie between the lower bound and the upper bound of the <B>SafeArray</B> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024400">setInt</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setInt(int idx1, int idx2, int val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024500">setInts</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setInts(int sa_idx, int nelems, int ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element retrieved from the <B>SafeArray</B> is retrieved from the location that is <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that provides the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I>. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024600">setShort</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setShort(int idx, short val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from index of the lower bound to the index of the upper bound. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>idx</I> is not between the lower bound and the upper bound of the <A HREF="SafeArray.htm">SafeArray</A> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024700">setShort</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setShort(int idx1, int idx2, short val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the <A HREF="SafeArray.htm">SafeArray</A> is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024800">setShorts</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setShorts(int sa_idx, int nelems, short ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element in <I>ja</I> to use. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024900">setString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setString(int idx, String val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from index of the lower bound to the index of the upper bound. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


<P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>idx</I> is not between the lower bound and the upper bound of the <A HREF="SafeArray.htm">SafeArray</A> (inclusive). 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024a00">setString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setString(int idx1, int idx2, String val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first dimension index of the element to set, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The second dimension index of the element to set, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024b00">setStrings</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setStrings(int sa_idx, int nelems, String ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element to be set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that contains the new values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to use in <I>ja</I>. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024c00">setVariant</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setVariant(int idx, Variant val);
</FONT></PRE>
<P><P>Sets an element of a one-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 
<P><B>Note</B>  Although <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the element type. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The element index, which ranges from the index of the lower bound to the index of the upper bound. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not one-dimensional or if <I>idx</I> does not lie between the lower bound and the upper bound of the <A HREF="SafeArray.htm">SafeArray</A> (inclusive). 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024d00">setVariant</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setVariant(int idx1, int idx2, Variant val);
</FONT></PRE>
<P><P>Sets an element of a two-dimensional <A HREF="SafeArray.htm">SafeArray</A>. 
<P><B>Note</B>  Although <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the element type. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx1</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first element index, which ranges from <B>LBound(1)</B> to <B>UBound(1)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>idx2</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The first element index, which ranges from <B>LBound(2)</B> to <B>UBound(2)</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new element value. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>IndexOutOfBoundsException</B>
 if the array is not two-dimensional or if either index lies outside the defined range. 


<P><B>ClassCastException</B>
 if the Java value cannot be converted to the <A HREF="SafeArray.htm">SafeArray</A> element type by using the Win32 <B>VariantChangeType</B> function. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024e00">setVariants</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public void setVariants(int sa_idx, int nelems, Variant ja[], int ja_start);
</FONT></PRE>
<P><P>Sets multiple elements of a <A HREF="SafeArray.htm">SafeArray</A>. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. The first element to be set in the <B>SafeArray</B> is located <I>sa_idx</I> elements away from index zero. 
<P><B>Note</B>  Although the <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the element type. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>sa_idx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to set. This index is always zero-based. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of elements to set. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array that provides the values. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ja_start</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The index of the first element to use in <I>ja</I>. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c024f00">toBooleanArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public boolean[] toBooleanArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  If you are extracting a large number of elements, it may be more efficient to use <A HREF="SafeArray.htm#com_000300050c025100">toCharArray</A> rather than <B>toBooleanArray</B>. Since <A HREF="SafeArray.htm">SafeArray</A> objects use two bytes per element, the <B>toBooleanArray</B> method cannot optimize itself to a memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025000">toByteArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public byte[] toByteArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025100">toCharArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public char[] toCharArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025200">toDoubleArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public double[] toDoubleArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025300">toFloatArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public float[] toFloatArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025400">toIntArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public int[] toIntArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method will optimize to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025500">toShortArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public short[] toShortArray();
</FONT></PRE>
<P><P>Converts the entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  This method attempts all the usual type conversions. To achieve optimal performance, ensure that the element size of the source and destination arrays match exactly, so that the method optimizes to a straight memory copy (<B>memcpy</B>). 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025600">toString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public String toString();
</FONT></PRE>
<P><P>Defines the printed representation of a <A HREF="SafeArray.htm">SafeArray</A> object. 

<P><B>Return Value:</B> <P>Returns the printed representation. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025700">toStringArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public String[] toStringArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter what the index of the lower bound of the <B>SafeArray</B> is, the first element is stored in element zero of the Java array. 

<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_000300050c025800">toVariantArray</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public Variant[] toVariantArray();
</FONT></PRE>
<P><P>Converts an entire <A HREF="SafeArray.htm">SafeArray</A> to a Java array. If the <B>SafeArray</B> is multidimensional, it is treated as if it were a single linear array stored in column order. No matter where in the <B>SafeArray</B> the first element is located, that location is called index zero for the purposes of this method. 
<P><B>Note</B>  Although the <A HREF="Variant.htm">Variant</A> methods can operate on any <A HREF="SafeArray.htm">SafeArray</A> type, it is usually much more efficient to use the specific method for the <B>SafeArray</B> type rather than to extract first as a <B>Variant</B>, and then coerce the <B>Variant</B>. This is true even if the <B>SafeArray</B> is a <B>SafeArray</B> of <B>Variant</B>s. 
<P><B>Return Value:</B> <P>Returns the flattened contents of the array. 

</BLOCKQUOTE>
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="upnrm.gif"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
