<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>A Simple Example</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Introduction to Using the Raw Native Interface"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1></FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="365" VALIGN="bottom"><IMG SRC="art/jnative2.gif" WIDTH="365" HEIGHT="27"  BORDER=0 ALT="Java & Native Code"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="rni_new.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="rni_introduction.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="RNI"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="rni_Accessing_Fields.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="365" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Introduction to Using the Raw Native Interface</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">RNI</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">A Simple Example</H2>
<P>Export the <A HREF="rniref.htm#rniref_0008010401004f00">RNIGetCompatibleVersion</A> method from your DLL. All RNI DLLs must export this method; otherwise, an <B>UnsatisfiedLinkError</B> exception is thrown when the method is called. This is a new requirement for the Microsoft VM for Java. Previous releases did not require this export. The following example shows how to export this method.

<PRE><FONT FACE="Courier" SIZE="2">
        #include "native.h";  // RNI declarations (part of Microsoft SDK for
                              // Java)

        __declspec(dllexport)
        DWORD __cdecl RNIGetCompatibleVersion()
        {
            return RNIVER;
        }
</FONT></PRE>
<P>Another example is a simple Java class that performs a prime-number sieve. You perform the calculation in C implemented in a DLL called SieveDemo.dll. In Java, the class might look like the following:

<PRE><FONT FACE="Courier" SIZE="2">    class Sieve
    {
        native static int CountPrimes(byte[] abFlags);

       
        static
        {
            System.loadLibrary("SieveDemo");
        }
    }
</FONT></PRE>
<P>Here, CountPrimes is declared native and the loadLibrary call is added in a static block to make sure the DLL that implements the API will be loaded.

<P>Use the Java Language Compiler from Microsoft (<A HREF="">jvc</A>) to compile this Java source into a class file with the following:

<PRE><FONT FACE="Courier" SIZE="2">    jvc Sieve.java

    Microsoft (R) Visual J++ Compiler Version 1.00.XXXX
    Copyright (C) Microsoft Corp 1996. All rights reserved.
</FONT></PRE>
<P>Next, use <B>msjavah</B> to produce a header file used by the native code:

<PRE><FONT FACE="Courier" SIZE="2">    msjavah Sieve
</FONT></PRE>
<P>Which will look like the following:

<PRE><FONT FACE="Courier" SIZE="2">&#009;/* DO NOT EDIT THIS FILE - it is machine generated */
&#009;#include &lt;native.h&gt;
&#009;/* Header for class Sieve */
&#009;
&#009;#ifndef _Included_Sieve
&#009;#define _Included_Sieve
&#009;
&#009;typedef struct ClassSieve {
&#009;#pragma pack(push,1)
&#009;    int32_t MSReserved;
&#009;    char PAD;&#009;/* ANSI C requires structures to have a least one member */
&#009;#pragma pack(pop)
&#009;} ClassSieve;
&#009;#define HSieve ClassSieve
&#009;
&#009;#ifdef __cplusplus
&#009;extern "C" {
&#009;#endif
&#009;__declspec(dllexport) long __cdecl Sieve_CountPrimes(struct HSieve *,HArrayOfByte *);
&#009;#ifdef __cplusplus
&#009;}
&#009;#endif
&#009;#endif
</FONT></PRE>
<P>This header file defines a structure ClassSieve that represents the data members of Sieve and a declaration for the native API that is implemented. Since Sieve doesn't have any data members, ClassSieve only contains some housekeeping fields. Native APIs are of the form Package_Class_Member(...) and, since Sieve is not in an explicitly named package, the API that is implemented is Sieve_CountPrimes(). The first parameter to the API is the <I>this</I> pointer, which, for static functions, will always be NULL. The second parameter is the byte array that is manipulated.


<P><B>Note</B>  One useful feature of msjavah is that primitive types (int, boolean, long, and so on) marked static and final become #defines in the resulting header file, making it much easier to share constants.
<P>Next, we implement the C we need:

<PRE><FONT FACE="Courier" SIZE="2">    #include &lt;varargs.h&gt;
    #include &lt;native.h&gt;
    #include "Sieve.h"

    long cdecl Sieve_CountPrimes(struct HSieve *phThis, HArrayOfByte *phFlags)
    {
        unsigned long count = 0;
        unsigned long i;

        for (i = 0; i &lt; obj_length(phFlags); i++)
            (phFlags-&gt;body)[i] = 1;

        for (i = 2; i &lt; obj_length(phFlags); i++)
        {
            if ((phFlags-&gt;body)[i] != 0)
            {
                unsigned long k;
                for (k = i + i; k &lt; obj_length(phFlags); k += i)
                    (phFlags-&gt;body)[k] = 0;

                count++;
            }
        }

        return count;
    }
</FONT></PRE>
<P>This is a fairly standard implementation of a sieve with several helpers from native.h to access to the data of the array (phFlags-&gt;body) and to query its length (obj_length(phFlags)).


<P>Next, a .def file to export this API is added:

<PRE><FONT FACE="Courier" SIZE="2">    LIBRARY         SieveDemo
    DESCRIPTION     'Native DLL for SieveDemo'

    EXPORTS
    &#009;Sieve_CountPrimes
    &#009;RNIGetCompatibleVersion 
</FONT></PRE>
<P>Finally, build everything, and then copy the resulting DLL to the system directory and test it.


<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
