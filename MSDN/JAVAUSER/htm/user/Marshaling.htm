<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How Data Types are Marshaled</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="JDirect"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203010000">Quick Reference</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203020000">Basic Scalar Types</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203030000">Chars</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203040000">Booleans</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203050000">Strings</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203060000">Arrays</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203070000">Structures</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203080000">Pointers</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_0007000203090000">Polymorphic&nbsp;Parameters</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Marshaling.htm#jdirect_00070002030a0000">Callbacks</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="365" VALIGN="bottom"><IMG SRC="art/jdirect2.gif" WIDTH="365" HEIGHT="27"  BORDER=0 ALT="JDirect"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="Getting_Started.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="jdirect.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="JDirect"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="Invoking_OLE_API.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="365" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>About J/Direct</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">JDirect</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">How Data Types are Marshaled</H2>
<P>The Microsoft Win32 VM for Java infers the native type of each parameter and the return value from the declared (compile-time) Java type of the parameter. For example, a parameter declared as a Java integer is passed as a 32-bit integer; a parameter declared as a Java <B>String</B> object is passed as a null-terminated string, and so forth. There are no invisible attributes that provide information about the native types. In Java, what you see is what you get.
<P>The following sections describe in detail how the Java data types map to native data types.
<P>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203010000">Quick Reference</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Provides tables that list the Java type that maps to each native type. 
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203020000">Basic Scalar Types</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Describes the mappings for int, byte, short, long, float, and double.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203030000">Chars</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains the mapping of the char data type.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203040000">Booleans</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains the mapping of the boolean data type.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203050000">Strings</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains how to pass and receive strings.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203060000">Arrays</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains how to pass arrays of scalars.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203070000">Structures</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains how to use the <B>@dll.struct</B> directive to pass and receive structures and how to use <B>@dll.structmap</B> to embed fixed-sized arrays within structures. 
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203080000">Pointers</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains how to handle DLLs that have multiple return values and how to read and write data through raw pointers.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_0007000203090000">Polymorphic&nbsp;Parameters</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains how to simulate polymorphic parameters.
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="Marshaling.htm#jdirect_00070002030a0000">Callbacks</A> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Explains how to declare and invoke a DLL function that takes a Callback parameter and how to embed a Callback inside a structure.
</FONT></TD>
</TR>
</TABLE>
<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203010000">Quick Reference</A></H3><P>The following two tables list the native type that corresponds to each Java type. The first table describes the mappings for parameters and return values, and the second table shows the mappings that are used with the <B>@dll.struct</B> directive.
<H5 STYLE="color:#333366">Parameter and Return Value Mappings</H5><P><TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Native </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Notes/Restrictions
 </B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BYTE or CHAR
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">SHORT or WORD
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">INT, UINT, LONG, ULONG, or DWORD
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">TCHAR
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">boolean </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BOOL
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">LPCTSTR </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Not allowed as return value, except in <I>ole</I> mode. In <I>ole</I> mode, <B>String</B> maps to LPWSTR. The Microsoft VM frees the string by using <B>CoTaskMemFree</B>.
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">StringBuffer </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">LPTSTR </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Not allowed as return value. Set the <B>StringBuffer</B> capacity large enough to hold the largest string that the DLL function can generate.
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BYTE*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">WORD*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">TCHAR*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">DWORD*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">boolean[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BOOL[]
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Object </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">pointer to struct </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">In <I>ole</I> mode, an <B>IUnknown</B>* is passed instead.
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Interface </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">COM interface </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Use jactivex or similar tool to generate interface file.
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">com.ms.com.SafeArray </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">SAFEARRAY* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Not allowed as return value.
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">com.ms.com._Guid </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">GUID,IID,CLSID
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">com.ms.com.Variant </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VARIANT*
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>@dll.struct</B> classes </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">pointer to struct
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">@com.struct classes </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">pointer to struct
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">void </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VOID </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">As return value only. 
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">com.ms.dll.Callback </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">function pointer </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">As parameter only.
</FONT></TD>
</TR>
</TABLE>
<P><BR><BR>
<H5 STYLE="color:#333366">Mappings Used with @dll.struct</H5><P><TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Native
 </B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BYTE or CHAR
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">TCHAR 
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">SHORT or WORD
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">INT, UINT, LONG, ULONG or DWORD
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">boolean </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BOOL[] 
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Java </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Native
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Pointer to a string, or an embedded fixed-size string
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Class marked with <B>@dll.struct</B> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested structure
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of TCHAR 
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of BYTE
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of SHORT
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of LONG
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of __int64
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of floats
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double [] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of doubles
</FONT></TD>
</TR>
</TABLE>
<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203020000">Basic Scalar Types</A></H3><P>The basic scalar types are mapped as you would expect.
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java type </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>DLL
 </B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">signed 32-bit integer
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">signed 8-bit integer
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">signed 16-bit integer
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">signed 64-bit integer
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">32-bit float
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">64-bit double
</FONT></TD>
</TR>
</TABLE>
<P>There is no direct representation of unsigned integer types in Java, except by using the signed types as a two's complement representation. For example, the integer type can be used without loss of representation for the common DWORD (unsigned 32-bit) type.

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203030000">Chars</A></H3><P>The Java char type becomes a CHAR (an 8-bit ANSI character) unless the <I>unicode</I> or <I>ole</I> modifier is in effect, in which case it becomes a WCHAR (a 16-bit Unicode character). 

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203040000">Booleans</A></H3><P>The Java boolean type maps to the Win32 BOOL type, which is a 32-bit type. As a parameter, the Java true maps to 1, and false maps to 0. As a return value, all non-zero values map to true. 
<P>Note that BOOL and VARIANT_BOOL (the internal boolean type in Microsoft&#174; Visual Basic&#174;) are not interchangeable. To pass a VARIANT_BOOL to a Visual Basic DLL, you must use the Java short type and use -1 for VARIANT_TRUE, and 0 for VARIANT_FALSE. 

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203050000">Strings</A></H3><P>This section explains how you can pass a string in ANSI or Unicode format to a DLL function. It also discusses two ways to return a string from a DLL function.
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203050100">Passing a String to a DLL Function</A></H4><P>To pass a standard null-terminated string to a DLL function, just pass a Java <B>String</B>. 
<P>For example, to change the current directory, you can access the Kernel32 function <B>CopyFile</B> function as follows.
<PRE><FONT FACE="Courier" SIZE="2">
class ShowCopyFile
{
  public static void main(String args[])
  {
    CopyFile("old.txt", "new.txt", true);
  }
  /** @dll.import("KERNEL32") */
  private native static boolean CopyFile(String existingFile, 
                                  String newFile, boolean f);
} 
</FONT></PRE>
<P><B>String</B>s are read-only in Java, so the Microsoft VM will only convert the <B>String</B> object as an input. To allow virtual machine implementations to marshal <B>String</B>s without copying the characters, <B>String</B> object parameters should not be passed to DLL functions that can modify the string. If the DLL function might modify the string, pass a <B>StringBuffer</B> object. 
<P>Strings are converted to ANSI unless the <I>unicode</I> or <I>ole</I> modifier is used, in which case the string is passed in Unicode format.
<P><B>String</B>s cannot be declared as return types of a DLL function except in <I>ole</I> mode, where the native return type is assumed to be a LPWSTR allocated using the <B>CoTaskMemAlloc</B> function.

<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203050200">Receiving a String From a DLL Function</A></H4><P>There are two common ways of passing a string back from a function: either the caller allocates a buffer that is filled in by the function, or the function allocates the string and returns it to the caller. Most Win32 functions use the first method, but OLE functions use the second method. (See <A HREF="Invoking_OLE_API.htm">Invoking OLE API Functions</A> to learn about the special support that Microsoft&#174; J/Direct&#153; provides for calling OLE functions.) One function that uses the first method is the Kernel32 function <B>GetTempPath</B>, which has the following prototype.
<PRE><FONT FACE="Courier" SIZE="2">
  DWORD GetTempPath(DWORD sizeofbuffer, LPTSTR buffer);
</FONT></PRE>
<P>This function simply returns the path of the system tempfile directory (such as "c:\tmp\"). The <I>buffer</I> argument points to a caller-allocated buffer that receives the path, and <I>sizeofbuffer</I> indicates the number of characters that can be written to the buffer. (This is different from the number of bytes in the Unicode version.) In Java, <B>String</B>s are read-only, so you cannot pass a <B>String</B> object as the buffer. Instead, you can use Java's <B>StringBuffer</B> class to create a writable <B>StringBuffer</B> object. Here is an example that invokes the <B>GetTempPath</B> function.
<PRE><FONT FACE="Courier" SIZE="2">
class ShowGetTempPath
{
  static final int MAX_PATH = 260;
  public static void main(String args[])
  {
    StringBuffer temppath = new StringBuffer(MAX_PATH);
    GetTempPath(temppath.capacity()+1, temppath);
    System.out.println("Temppath = " + temppath);
  }
&#009;
  /** @dll.import("KERNEL32") */
  private static native int GetTempPath(int sizeofbuffer,
                                        StringBuffer buffer);
}
</FONT></PRE>
<P>To understand this example, it is important to distinguish between a <B>StringBuffer</B>'s length and its capacity. The length is the number of characters logically in the string currently stored in the <B>StringBuffer</B>. The capacity is the actual amount of storage currently allocated to that <B>StringBuffer</B>. After the following statement executes,
<PRE><FONT FACE="Courier" SIZE="2">&#009;
  StringBuffer sb = new StringBuffer(259);
</FONT></PRE>
<P>the value of sb.length is zero, and the value of sb.capacity is 259. When you invoke a DLL method passing a <B>StringBuffer</B>, the Microsoft VM examines the capacity of the <B>StringBuffer</B>, adds one for the null terminator, multiplies by 2 if Unicode is the default character size, and then allocates that many bytes of memory for the buffer that is passed to the DLL function. In other words, you use the capacity, not the length, to set the size of the buffer. Be careful not to make the following mistake.
<PRE><FONT FACE="Courier" SIZE="2">
  StringBuffer sb = new StringBuffer();  //Wrong!
  GetTempPath(MAX_PATH, sb);
</FONT></PRE>
<P>Invoking the <B>StringBuffer</B> constructor with no arguments creates a <B>StringBuffer</B> object with a capacity of 16, which is probably too small. MAX_PATH was passed to the <B>GetTempPath</B> method, indicating that there was enough room in the buffer to hold 260 characters. Thus, <B>GetTempPath</B> will probably overrun the buffer. If you were planning to use <B>GetTempPath</B> extensively, you should wrap it in the following manner.
<PRE><FONT FACE="Courier" SIZE="2">
public static String GetTempPath()
{
  StringBuffer temppath = new StringBuffer(MAX_PATH-1);
  int res = GetTempPath(MAX_PATH, temppath);
  if (res == 0 || res &gt; MAX_PATH) {
    throw new RuntimeException("GetTempPath error!");
  }
  return temppath.toString(); // can't return a StringBuffer 
}
</FONT></PRE>
<P>This method offers both convenience and safety, and it maps the error return value of the function to a Java exception. Notice that you cannot return <B>StringBuffer</B> objects. 

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203060000">Arrays</A></H3><P>J/Direct automatically handles arrays of scalars. The following Java array types translate directly into native pointer types as follows.

<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Native </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B># of bytes per element
 </B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BYTE* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">1 
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">SHORT* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">2
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">DWORD* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">4
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">FLOAT* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">4 
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">DOUBLE* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">8
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">8
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">boolean[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BOOL* </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">4
</FONT></TD>
</TR>
</TABLE>
<P>The char[] array type maps to CHAR* unless the <I>unicode</I> modifier is in effect, in which case it maps to WCHAR*.

<P> All scalar array parameters can be modified by the caller (like [in,out] parameters).
<P> Array types cannot be used as return types. There is no support for arrays of objects or strings.
<P> Typically, this facility is used by OLE functions to return values. (OLE functions reserve the "function" return value to return the <B>HRESULT</B> error code.) See <A HREF="Invoking_OLE_API.htm">Invoking OLE API Functions</A> to learn how to obtain the return value for OLE functions.

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203070000">Structures</A></H3><P>The Java language does not directly support the concept of a structure. Although Java classes containing fields can be used to emulate the concept of a structure within the Java language, ordinary Java objects cannot be used to simulate structures in native DLL calls. This is because the Java language does not guarantee the layout of the fields and because the garbage collector is free to move the object around in memory.

<P>Therefore, to pass and receive structures from DLL methods, you need to use the <B>@dll.struct</B> compiler directive. When applied to a Java class definition, this directive causes all instances of the class to be allocated in a memory block that will not move during garbage collection. In addition, the layout of the fields in memory can be controlled using the <I>pack</I> modifier (see <A HREF="Marshaling.htm#jdirect_0007000203070500">Structure Packing</A>). For example, the Win32 SYSTEMTIME structure has the following definition in the C programming language.
<PRE><FONT FACE="Courier" SIZE="2">
typedef struct {
  WORD wYear;
  WORD wMonth;
  WORD wDayOfWeek;
  WORD wDay;
  WORD wHour;
  WORD wMinute;
  WORD wSecond;
  WORD wMilliseconds;
} SYSTEMTIME;
</FONT></PRE>
<P>The correct declaration of this structure in Java is as follows.
<PRE><FONT FACE="Courier" SIZE="2">
/** @dll.struct() */
class SYSTEMTIME {
  public short wYear;
  public short wMonth;
  public short wDayOfWeek;
  public short wDay;
  public short wHour;
  public short wMinute;
  public short wSecond;
  public short wMilliseconds;
} 
</FONT></PRE>
<P>The following example uses the SYSTEMTIME structure in a DLL method call.
<PRE><FONT FACE="Courier" SIZE="2">
class ShowStruct {
    /** @dll.import("KERNEL32") */
    static native void GetSystemTime(SYSTEMTIME pst);
    public static void main(String args[])
    {
      SYSTEMTIME systemtime = new SYSTEMTIME();
      GetSystemTime(systemtime);
      System.out.println("Year is " + systemtime.wYear);
      System.out.println("Month is " + systemtime.wMonth);
      // etc.
    }
} 
</FONT></PRE>
<P><B>Note:</B>  Classes declared with <B>@dll.struct</B> are considered unsafe and therefore cannot be used by untrusted applets.
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203070100">Correspondence Between Types Inside Structures</A></H4><P>The following table describes how scalar types map inside structures.
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Native
 </B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BYTE
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">TCHAR (CHAR or WCHAR depending on <B>@dll.struct</B> definition)
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">SHORT
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">LONG
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">boolean </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BOOL (32-bit boolean)
</FONT></TD>
</TR>
</TABLE>
<P>Reference types (Java objects and classes) normally map to embedded structures and arrays. 
Each supported mapping is described in the following table.
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Java </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Native
 </B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Pointer to a string, or an embedded fixed-size string
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Class marked with <B>@dll.struct</B> </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested structure
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of TCHAR (CHAR/WCHAR)
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of BYTE
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of SHORT
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of LONG
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of __int64
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of floats
 </FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double [] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Nested array of doubles
</FONT></TD>
</TR>
</TABLE>
<P>There is no direct support for pointers inside structures, due to the large number of possible ways referenced objects could be allocated and disposed of. To represent a structure with an embedded pointer, declare the pointer field as type int. You will need to make explicit DLL calls to the appropriate allocation functions and initialize the memory blocks yourself. (You could use DllLib.<A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A> to map the blocks onto <B>@dll.struct</B> classes.)

<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203070200">Nested Structures</A></H4><P>A structure can embed another structure simply by naming the other structure as the field type. For example, the Windows MSG structure embeds a POINT structure as follows.
<PRE><FONT FACE="Courier" SIZE="2">
&#009;typedef struct {
&#009;&#009;LONG x;
&#009;&#009;LONG y;
&#009;} POINT;

&#009;typedef struct {
&#009;&#009;int hwnd;
&#009;&#009;int message;
&#009;&#009;int wParam;
&#009;&#009;int lParam;
&#009;&#009;int time;
&#009;&#009;POINT pt;
&#009;} MSG;
</FONT></PRE>
<P>This translates directly into Java as follows.
<PRE><FONT FACE="Courier" SIZE="2">
&#009;/** @dll.struct() */
&#009;class POINT {
&#009;&#009;int x;
&#009;&#009;int y;
&#009;}
&#009;/** @dll.struct() */
&#009;class MSG {
&#009;&#009;public int hwnd;
&#009;&#009;public int message;
&#009;&#009;public int wParam;
&#009;&#009;public int lParam;
&#009;&#009;public int time;
&#009;&#009;public POINT pt;
&#009;}
</FONT></PRE>
<P><B>Performance tip:</B> Although embedding structures is handy, the fact remains that Java does not truly support embedded objects &#150; only embedded references to objects. The Microsoft VM must translate between these two formats each time a nested structure is passed. Therefore, in a critical code path, you can improve performance by nesting structures manually (by copying the fields of the nested structure into the containing structure). For example, the <I>pt</I> field in the MSG structure could easily be declared as two integer fields, <I>pt_x</I> and <I>pt_y</I>.

<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203070300">Fixed-size Strings Embedded within Structures</A></H4><P>Some structures have fixed size strings embedded in them. The LOGFONT structure is defined as follows. 
<PRE><FONT FACE="Courier" SIZE="2">
   typedef struct {
     LONG lfHeight;
     LONG lfWidth;
     /* &lt;many other fields deleted for brevity&gt; */
     TCHAR lfFaceName[32];
   } LOGFONT;
</FONT></PRE>
<P>This structure can be expressed in Java using an extension syntax to specify the size.
<PRE><FONT FACE="Courier" SIZE="2">
   /** @dll.struct() */
   class LOGFONT {
     int lfHeight;
     int lfWidth;
     /* &lt;many other fields deleted for brevity&gt; */
     /** @dll.structmap([type=TCHAR[32]]) */
     String&#009;lfFaceName;
   } 
</FONT></PRE>
<P>The <B>@dll.structmap</B> directive indicates the size of the fixed string as measured in characters (including space for the null terminator).

<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203070400">Fixed-size Scalar Arrays Embedded within Structures</A></H4><P>Fixed-size arrays of scalars embedded in structures can be specified using the <B>@dll.structmap</B> directive. Here is a C language structure that contains fixed-size scalar arrays.
<PRE><FONT FACE="Courier" SIZE="2">
struct EmbeddedArrays
{
  BYTE     b[4];
  CHAR     c[4];
  SHORT    s[4];
  INT      i[4];
  __int64  l[4];
  float    f[4];
  doubl    d[4];
};
</FONT></PRE>
<P>You can specify the <B>EmbeddedArrays</B> structure by using <B>@dll.structmap</B> in the following way. 
<PRE><FONT FACE="Courier" SIZE="2">
/** @dll.struct() */
class EmbeddedArrays
{
    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    byte b[];

    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    char c[];

    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    short s[];

    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    int i[];

    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    long l[];

    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    float f[];

    /** @dll.structmap([type=FIXEDARRAY, size=4]) */
    double d[];

}

</FONT></PRE>
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203070500">Structure Packing</A></H4><P>Structure fields are padded and aligned according to ANSI 3.5.2.1. The packing size can be set using the <I>pack</I> modifier.
<PRE><FONT FACE="Courier" SIZE="2">
   /** @dll.struct(pack=n) */
</FONT></PRE>
<P>where <I>n</I> can be 1, 2, 4 or 8. The default is 8. For users of the Microsoft&#174; Visual C++&#174; compilers, "pack=<I>n</I>" is equivalent to "#pragma pack(<I>n</I>)".

<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203070600">The Relationship Between @dll.struct and @com.struct</A></H4><P>The <B>@dll.struct</B> directive is very similar to the <B>@com.struct</B> directive emitted by the jactivex tool and emitted (implicitly) by the javatlb tool. (The javatlb tool has been replaced by jactivex.) The main difference is that the default type mappings are suited for Microsoft&#174; Windows&#174; function calling instead of COM object calling. Given this information, it follows that you can also generate <B>@dll.struct</B> classes by describing the structure in a type library and using jactivex to generate the Java class. However, it's usually faster to generate the classes manually.

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203080000">Pointers</A></H3><P>Java does not support a pointer data type. However, instead of passing a pointer, you can pass a one-element array. You can store pointers in Java integers, and you can read and write data from raw pointers. 
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203080100">Return Value Pointers</A></H4><P>Win32 functions that have multiple return values typically handle them by having the caller pass a pointer to a variable to be updated. For example, the <B>GetDiskFreeSpace</B> function has the following prototype.
<PRE><FONT FACE="Courier" SIZE="2">
   BOOL GetDiskFreeSpace(LPCTSTR szRootPathName, 
                         DWORD  *lpSectorsPerCluster,
                         DWORD  *lpBytesPerCluster, 
                         DWORD  *lpFreeClusters,
                         DWORD  *lpClusters);
</FONT></PRE>
<P><B>GetDiskFreeSpace</B> is typically called as follows.
<PRE><FONT FACE="Courier" SIZE="2">
DWORD sectorsPerCluster, bytesPerCluster, freeClusters, clusters;
GetDiskFreeSpace(rootname, &amp;sectorsPerCluster, 
                 &amp;bytesPerCluster, &amp;freeClusters, &amp;clusters);
</FONT></PRE>
<P>In Java, this is just a special case of passing scalar arrays where the array size is one element. The following example shows how to call the <B>GetDiskFreeSpace</B> function.
<PRE><FONT FACE="Courier" SIZE="2">
class ShowGetDiskFreeSpace 
{
  public static void main(String args[])
  {
    int sectorsPerCluster[] = {0};
    int bytesPerCluster[] = {0};
    int freeClusters[] = {0};
    int clusters[] = {0};
    GetDiskFreeSpace("c:\\", sectorsPerCluster, bytesPerCluster, 
                     freeClusters, clusters);
    System.out.println("sectors/cluster  = " + sectorsPerCluster[0]);
    System.out.println("bytes/cluster = " + bytesPerCluster[0]);
    System.out.println("free clusters = " + freeClusters[0]);
    System.out.println("clusters = " + clusters[0]);
  }

  /** @dll.import("KERNEL32") */
  private native static boolean GetDiskFreeSpace(String rootname,
                   int pSectorsPerCluster[], int pBytesPerCluster[], 
                   int pFreeClusters[], int pClusters[]);
}
</FONT></PRE>
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203080200">Raw Pointers</A></H4><P>A pointer to an unknown or particularly difficult structure can be stored in a plain Java integer. If your application only needs to store the pointer and not dereference it, this is the simplest (and most efficient) approach. You might want to use this technique to store a pointer that has been returned by a DLL function that allocates a memory block. In fact, you can use this technique to store a pointer returned by any DLL function. Needless to say, using raw pointers eliminates many of the safety advantages of Java. So, an alternative approach should be used whenever possible. However, there are situations when you might choose to use raw pointers. With that in mind, there are two ways to read and write data from raw pointers.

<H5 STYLE="color:#333366">Casting to a Reference to an @dll.struct Class</H5><P>One way to read and write data through a raw pointer is to cast the raw pointer to a reference to an <B>@dll.struct</B> class. Once this is done, you can read and write the data using normal field access syntax. For instance, suppose you have a raw pointer that you wish to access as a RECT. You can use the system method DllLib.<A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A> as follows.
<PRE><FONT FACE="Courier" SIZE="2">
  /** @dll.struct() */
  class RECT {
    int left;
    int top;
    int right;
    int bottom;
  }

  import com.ms.dll.*;

  int  rawptr = ...;
  RECT rect = (RECT)DllLib.ptrToStruct(RECT.class, rawptr);
  rect.left = 0;
  rect.top = 0;
  rect.right = 10;
  rect.bottom = 10;
</FONT></PRE>
<P>The <A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A> method wraps the raw pointer in a RECT instance. Unlike instances created by the <B>new</B> operator, this RECT instance will not attempt to free the raw pointer upon reclamation by the garbage collector because the RECT object has no way of knowing how the pointer was allocated. In addition, because the native memory was already constructed at the time <B>ptrToStruct</B> was called, the RECT class constructor is <I>not</I> called.

<H5 STYLE="color:#333366">Using the DllLib Copy Methods</H5><P>Another method for reading and writing data through a raw pointer is to use the overloaded <A HREF="DllLib.htm#com_0003000703010400">copy</A> methods in DllLib. These methods copy data between Java arrays of various types and raw pointers. If you need to treat a raw pointer as a pointer to a string (LPTSTR), you can use one of the <A HREF="DllLib.htm">DllLib</A> methods <A HREF="DllLib.htm#com_0003000703011f00">ptrToStringAnsi</A>, <A HREF="DllLib.htm#com_0003000703012000">ptrToStringUni</A>, or <A HREF="DllLib.htm#com_0003000703011e00">ptrToString</A> to parse the string and convert it into a <B>java.lang.String</B> object.
<PRE><FONT FACE="Courier" SIZE="2"> 
  import com.ms.dll.*;

  int rawptr = ...;
  String s = DllLib.ptrToStringAnsi(rawptr);
</FONT></PRE>
<P><B>Warning:</B>  All Java objects are subject to movement in memory or reclamation by the garbage collector. Therefore, you should not attempt to obtain a pointer to a Java array by calling a DLL function that does generic casting. The following example shows you an incorrect way to obtain the pointer.
<PRE><FONT FACE="Courier" SIZE="2">
  // Do not do this!
  /** @dll.import("MYDLL") */
  private native static int Cast(int javaarray[]);

&#009;
  // Inside MYDLL.DLL   
  LPVOID Cast(LPVOID ptr) 
  {
    // Do not do this!
    return ptr; // comes in as a Java array; goes out as a Java int
  } 
</FONT></PRE>
<P>The value of <I>ptr</I> is guaranteed to be valid only for the duration of the call to the <B>Cast</B> function. This is because VM implementations are allowed to implement passing of arrays by copying rather than pinning and because garbage collection may cause the physical location of the array to be different after the call to the <B>Cast</B> function returns.

<H3 STYLE="color:#333366"><A NAME="jdirect_0007000203090000">Polymorphic&nbsp;Parameters</A></H3><P>Some Win32 functions declare a parameter whose type depends on the value of another parameter. For example, the <B>WinHelp</B> function is declared as follows.
<PRE><FONT FACE="Courier" SIZE="2">
  BOOL WinHelp(int hwnd, LPCTSTR szHelpFile, UINT cmd, DWORD dwData);
</FONT></PRE>
<P>The innocent-looking <I>dwData</I> parameter can actually be any one of the following: a pointer to a string, a pointer to a MULTIKEYHELP structure, a pointer to a HELPWININFO, or a plain integer, depending on the value of the <I>cmd</I> parameter. 

<P>J/Direct offers two ways to declare such a parameter:
<UL><LI>Declare the parameter to be type <B>Object</B>.
<LI>Use overloading to declare a separate method for each possible type.
</UL>
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203090100">Declaring the Parameter as Type Object</A></H4><P>Here is how to declare <B>WinHelp</B> by declaring <I>dwData</I> as type <B>Object</B>.
<PRE><FONT FACE="Courier" SIZE="2">
  /** @dll.import("USER32") */
  static native boolean WinHelp(int hwnd, String szHelpFile, 
                                int cmd, Object dwData);
</FONT></PRE>
<P>When <B>WinHelp</B> is invoked, J/Direct will use the runtime type to determine how to translate <I>dwData</I>. The following table describes how the types are translated.
<P>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Type </B></FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Translated as 
</B></FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.Integer </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">4-byte integer
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.Boolean </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">4-byte BOOL
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.Char </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">CHAR (or WCHAR if the <I>unicode</I> or <I>ole</I> modifiers are in effect)
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.Short </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">2-byte SHORT
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.Float </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">4-byte FLOAT
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.String </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">LPCSTR (or LPCWSTR if the <I>unicode</I> or <I>ole</I> modifier is in effect)
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">java.lang.StringBuffer </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">LPSTR (or LPWSTR if the <I>unicode</I> or <I>ole</I> modifier is in effect) 
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">byte[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">BYTE*
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">char[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">CHAR* (or WCHAR* if the <I>unicode</I> or <I>ole</I> modifier is in effect)
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">short[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">SHORT*
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">int[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">INT*
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">long[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">__int64
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">float*
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double[] </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double*
</FONT></TD>
</TR>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">@dll.struct </FONT></TD>
<TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">pointer to structure 
</FONT></TD>
</TR>
</TABLE>
<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203090200">Overloading the Function</A></H4><P>Another way to declare the <B>WinHelp</B> function is to overload the function for each possible type.
<PRE><FONT FACE="Courier" SIZE="2">
/** @dll.import("USER32") */
static native boolean WinHelp(int hwnd, String szHelpFile, 
                              int cmd, int dwData);
&#009;
/** @dll.import("USER32") */
static native boolean WinHelp(int hwnd, String szHelpFile, 
                              int cmd, String dwData);&#009;

/** @dll.import("USER32") */
static native boolean WinHelp(int hwnd, String szHelpFile, 
                              int cmd, MULTIKEYHELP dwData);&#009;

/** @dll.import("USER32") */
static native boolean WinHelp(int hwnd, String szHelpFile, 
                              int cmd, HELPWININFO dwData);
</FONT></PRE>
<P>You cannot handle a polymorphic return value using overloading because Java methods cannot be overloaded on return value only. Therefore, you need to give each variant of the function a different Java name and use the <I>entrypoint</I> modifier to link them all to the same DLL method. (See <A HREF="Aliasing.htm">Aliasing (Method Renaming)</A> to learn more about renaming DLL methods.)

<H4 STYLE="color:#333366"><A NAME="jdirect_0007000203090300">Comparison Between the Two Methods</A></H4><P>In most cases (including the <B>WinHelp</B> case), overloading is the preferred approach because it offers superior run time performance as well as better type checking. In addition, overloading avoids the need to wrap integer arguments inside an <B>Integer</B> object.
<P>However, declaring the parameter as type <B>Object</B> can be useful in cases where there is more than one polymorphic parameter. You might also choose this method when you want to access a service that acts generically on a wide variety of types, such as a function that can accept any object declared with <B>@dll.struct</B>.


<H3 STYLE="color:#333366"><A NAME="jdirect_00070002030a0000">Callbacks</A></H3><P>You can write callbacks in Java by extending the system class com.ms.dll.<A HREF="Callback.htm">Callback</A>.

<H4 STYLE="color:#333366"><A NAME="jdirect_00070002030a0100">Declaring a Method that Takes a Callback</A></H4><P>To represent a callback parameter in Java, declare the Java type to be either type com.ms.dll.<A HREF="Callback.htm">Callback</A> or a class that derives from <B>Callback</B>. For example, the Microsoft&#174; Win32&#174;
 <B>EnumWindows</B> function is prototyped as follows.
<PRE><FONT FACE="Courier" SIZE="2">
  BOOL EnumWindows(WNDENUMPROC wndenumproc, LPARAM lparam);
</FONT></PRE>
<P>The corresponding Java prototype is shown in the following example.
<PRE><FONT FACE="Courier" SIZE="2">
  import com.ms.dll.Callback;
  /** @dll.import("USER32") */
  static native boolean EnumWindows(Callback wndenumproc, 
                                    int lparam);
</FONT></PRE>
<H4 STYLE="color:#333366"><A NAME="jdirect_00070002030a0200">Invoking a Function that Takes a Callback</A></H4><P>To invoke a function that takes a callback, you need to define a class that extends <A HREF="Callback.htm">Callback</A>. The derived class must expose one non-static method whose name is <B>callback</B> (all lowercase). Continuing with the <B>EnumWindows</B> previous example, the C language definition of WNDENUMPROC looks like this.
<PRE><FONT FACE="Courier" SIZE="2">
  BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lparam);
</FONT></PRE>
<P>To author an EnumWindowsProc in Java, you declare a class that extends <A HREF="Callback.htm">Callback</A> as follows.
<PRE><FONT FACE="Courier" SIZE="2">
  class EnumWindowsProc extends Callback
  {
    public boolean callback(int hwnd, int lparam)
    {
      StringBuffer text = new StringBuffer(50);
      GetWindowText(hwnd, text, text.capacity()+1);
&#009;&#009;&#009;
      if (text.length() != 0) {
        System.out.println("hwnd = " + Integer.toHexString(hwnd) +
                           "h: Text = " + text);
      } 
      return true;  // return TRUE to continue enumeration.
    }
  
  /** @dll.import("USER32") */
  private static native int GetWindowText(int hwnd, StringBuffer text, 
                                          int cch);
  }
</FONT></PRE>
<P>You can invoke <B>EnumWindows</B> with this <A HREF="Callback.htm">Callback</A> in the following way.
<PRE><FONT FACE="Courier" SIZE="2">
  boolean result = EnumWindows(new EnumWindowsProc(), 0);
</FONT></PRE>
<H4 STYLE="color:#333366"><A NAME="jdirect_00070002030a0300">Restrictions on Types Accepted by the Callback Method</A></H4><P>The return type of the <B>callback</B> method must be void, int, boolean, char, or short. The only parameter type currently allowed is the int type. Fortunately, this is not as restrictive as it sounds. You can use the <A HREF="DllLib.htm">DllLib</A> methods <A HREF="DllLib.htm#com_0003000703011f00">ptrToStringAnsi</A>, <A HREF="DllLib.htm#com_0003000703012000">ptrToStringUni</A>, and <A HREF="DllLib.htm#com_0003000703011e00">ptrToString</A> to treat a parameter as an LPTSTR. You can use the <A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A> method to treat a parameter as a pointer to an <B>@dll.struct</B> class.

<H4 STYLE="color:#333366"><A NAME="jdirect_00070002030a0400">Associating Data with a Callback</A></H4><P>Frequently, it is necessary to pass some data from the caller of the function to the callback. This explains why <B>EnumWindows</B> takes an extra <I>lparam</I> argument. Most Win32 functions that take callbacks accept one extra 32-bit parameter that is passed to the callback without interpretation. With the <B>Callback</B> mechanism, it is not necessary to pass data using the <I>lparam</I> argument. Because the <B>callback</B> method is non-static, you can store your data as fields in the <B>EnumWindowsProc</B> object.

<H4 STYLE="color:#333366"><A NAME="jdirect_00070002030a0500">The Lifetime of a Callback</A></H4><P>Some care is required to ensure that the <A HREF="Callback.htm">Callback</A> is not reclaimed by garbage collection before the native function is finished with it. If the callback is short-term (only callable for the duration of one function call), no special action is required because a <B>Callback</B> passed to a DLL function is guaranteed not to be reclaimed by garbage collection while the call is in progress.
<P>If a callback is long-term (used across function calls), you will need to protect the <A HREF="Callback.htm">Callback</A> from being reclaimed, typically by storing a reference to it in a Java data structure. You can also store references to <B>Callback</B>s within native data structures by using the com.ms.dll.<A HREF="Root.htm">Root</A> class to wrap the <B>Callback</B> inside a root handle. The root handle is a 32-bit handle that prevents the <B>Callback</B> from being reclaimed until the handle is explicitly freed. For example, a root handle to a WndProc can be stored in the application data area of an HWND structure, and then explicitly freed on the <B>WM_NCDESTROY</B> message.

<H4 STYLE="color:#333366"><A NAME="jdirect_00070002030a0600">Embedding a Callback Inside a Structure</A></H4><P>To embed a callback inside a structure, you can first call the com.ms.dll.Root.<A HREF="Root.htm#com_0003000705010100">alloc</A> method to wrap the <A HREF="Callback.htm">Callback</A> in a root handle. Then pass the root handle to the DllLib.<A HREF="DllLib.htm#com_0003000703010100">addrOf</A> method to obtain the actual (native) address of the callback. Then, store this address as an integer. 

<P>For example, the <B>WNDCLASS</B> structure can be declared in Java as follows.
<PRE><FONT FACE="Courier" SIZE="2">
  /** @dll.struct() */
  class WNDCLASS {
    int style;
    int&#009;lpfnWndProc; // CALLBACK
    ... /* &lt;other fields deleted for brevity&gt; */
  } 
</FONT></PRE>
<P>Let's assume you have extended <A HREF="Callback.htm">Callback</A> as follows.
<PRE><FONT FACE="Courier" SIZE="2">
  class WNDPROC extends Callback
  {
    public int callback(int hwnd, int msg, int wparam, int lparam)
    {&#009;
&#009;...
    }
  } 
</FONT></PRE>
<P>To store a pointer to the callback inside the <B>WNDCLASS</B> object, use the following sequence.
<PRE><FONT FACE="Courier" SIZE="2">
  import com.ms.dll.*;

  WNDCLASS wc = new WNDCLASS();
  int callbackroot = Root.alloc(new WNDPROC());
  wc.lpfnWndProc = DllLib.addrOf(callbackroot);
</FONT></PRE>
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
