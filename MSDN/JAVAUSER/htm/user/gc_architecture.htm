<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overview of the Garbage Collection Architecture</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Native Code Interface Specification"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="gc_architecture.htm#natcodei_0008010304010000">Goals</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="gc_architecture.htm#natcodei_0008010304020000">Garbage Collection Mechanism</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="365" VALIGN="bottom"><IMG SRC="art/jnative2.gif" WIDTH="365" HEIGHT="27"  BORDER=0 ALT="Java & Native Code"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="New_Native_Code.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="Native_Code_Interface.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="RNI"></A></TD></TR>
<TR>
<TD WIDTH="365" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Native Code Interface Specification</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">RNI</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Overview of the Garbage Collection Architecture</H2>
<P>These sections describe the goals and implementation details of garbage collection.

<H3 STYLE="color:#333366"><A NAME="natcodei_0008010304010000">Goals</A></H3><OL><LI>Garbage collection should be transparent for replacing malloc-based C programs.
<LI>Garbage collection overhead should be minimal (in terms of time and percentage execution) for most Java applets and applications.
</OL>
<H3 STYLE="color:#333366"><A NAME="natcodei_0008010304020000">Garbage Collection Mechanism</A></H3><P>The key to countering the overhead that occurs while determining the difference between live and dead pointers is to make memory allocation very efficient. Most modern, high performance garbage collectors start with a simple way of allocating memory. To allocate, a current block of memory exists with a part that's used and a part that's free. The new object is added on the end of the used block, and the pointer in the used block is moved. Another block is dynamically allocated when the current block becomes full. The blocks are a fixed size. If you need a larger block ("large" is dependent on tuning; this will typically be between 4K and 8K), a custom block is allocated that has only that object. All the blocks are linked together. The decision about the size of the block is the same trade-off as page size within the operating system.

<P>To distinguish live pointers from dead pointers, we start from a root set where we know there are live pointers. These pointers are followed by copying them into new blocks. Each object that these pointers point to in these roots is worked through recursively. When the end of scanning the new objects in the new copy is reached, every live object has been copied. This scheme can be fairly expensive if you always copy many objects that are very stable. This is improved by taking a snapshot of the last point that was garbage collected and the new point that is garbage collected and copy only the objects that are in between, leaving old objects alone. This is called <B>generational GC</B>, using two generations, in this case.

<P>The large blocks are not copied, they're just logically moved from the old set to the new. Further improvements may be made by considering only roots between the phases the part of memory that has been modified.

<P>Garbage collection is called on allocation of new objects. When a new object is allocated, the garbage collector detects memory threshold (a heuristic is used to decide if it needs to garbage collect and, if so, sets a flag). The VM looks at the flag and initiates the process of checking the block count. 

<P>Mark and compact are not used as a garbage collection method, because they are inherently less efficient in situations where you have lots of garbage, which will be typical in Java programs. 

<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
