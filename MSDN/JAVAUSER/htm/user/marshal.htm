<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Introduction to Java/COM Custom Marshaling for User-Defined Data Types</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Working with MS VM"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701010000">What Is Custom Marshaling and Who Uses It?</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701020000">An Example of Custom Marshaling</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701030000">How JAVA/COM Custom Marshaling Works</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701040000">Hook Class Overview</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701050000">Hook Class Implementation</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701060000">Using Template Files to Write a Hook Class</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701070000">EXAMPLE 1: FixedPtMarshaler (The Basic Hook Class)</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701080000">EXAMPLE 2: VarStrMarshaler (Embedded Resources)</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_0004000701090000">EXAMPLE 3: PointMarshaler (Mutable Java Objects)</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_00040007010a0000">EXAMPLE 4: RectMarshaler (Support for Custom Allocation)</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_00040007010b0000">EXAMPLE 5: AnsiMarshaler (Variable-sized data types)</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" href="marshal.htm#marshal_00040007010c0000">Running and Building the Sample Client</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="355" VALIGN="bottom"><IMG SRC="art/tools2.gif" WIDTH="355" HEIGHT="27"  BORDER=0 ALT="Tools"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A href="jactivex.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_tool.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Tools"></A></TD><TD ALIGN="center" VALIGN="bottom"><A href="jview.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="355" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Using Jactivex to Create a User-Defined Type for Java/COM Marshaling</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Tools</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Introduction to Java/COM Custom Marshaling for User-Defined Data Types</H2>
<P>This article explains how to implement custom marshaling of user-defined types between Java and COM. Basically, this involves writing a <I>hook class</I> to do the marshaling, and using the jactivex tool with the /javatlb command-line switch to create a Java type library information file (.jnf) that describes the custom interface. 

<P>A hook class is a special class that you write for each user-defined type you want to marshal from COM to Java. It contains the code that actually does the marshaling and translates the COM type to a Java type and the Java type to a COM type. Much of this article addresses what a hook class is and how to author one.

<P>Jactivex is a tool that can create Java libraries from existing COM interfaces. COM interfaces are based on type libraries, so a Java type library is a file that maps user-defined types in existing COM type libraries to hook classes. 


<H3 STYLE="color:#333366"><A NAME="marshal_0004000701010000">What Is Custom Marshaling and Who Uses It?</A></H3><P>Marshaling of data types is essential whenever a program spans languages, since data types are never exactly the same in any two languages. Since the Microsoft VM provides the ability to wrap COM libraries as Java classes, marshaling must occur between Java classes and COM type libraries. The Microsoft VM supports a certain level of intrinsic marshaling by default.

<P>As an example, suppose you have a COM library that uses various data types as parameters and return values for its methods. For these methods to be callable from Java, the data types need to be converted between the COM types and Java
types. For some types, like integers, floats, booleans, and strings, the
Microsoft VM for Java provides intrinsic marshaling support that automatically does the type conversion.

<P>In addition to the conversion work, the COM types must be represented as Java
types to be callable from Java. This requires a Java .class
file that contains type declarations in Java format. This class file is
usually created by running a type-conversion tool such as jactivex (Jcom or Javatlb in older versions of the SDK) on the type library of the COM server. These conversion tools generate the correct type mappings for all types that are supported by the intrinsic marshaling of the Microsoft VM. 

<P>The Microsoft VM does not, however, have intrinsic support for complex COM library data types, such as C structures. To marshal such data types requires that you create a user-defined Java type and write a hook class that does the marshaling.

<P>Since jactivex cannot automatically create type mappings that work for
user-defined types, you will need to provide jactivex with information on how to generate the Java type declarations. This is done by creating a Java type library information file (.jnf) file, which describes your custom data types, and passing it to jactivex it creates the COM library class header file. 

<P>The .jnf file has the following format:
<PRE><FONT FACE="Courier" SIZE="2">
[Custom]
&lt;TypeLib Type&gt;= &lt;Java Type&gt;, &lt;Hook Class&gt;

</FONT></PRE>
<P>Where:
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><I>TypeLib Type</I> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A user-defined type declared in the COM type library.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><I>Java Type</I> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java type to map to the COM type.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><I>Hook Class</I> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class that does the translation.
</FONT></TD></TR></TABLE>
<H3 STYLE="color:#333366"><A NAME="marshal_0004000701020000">An Example of Custom Marshaling</A></H3><P>The following is an example of how to marshal a simple structure type between a COM type library and Java. Suppose you have a simple COM library, represented by the following pseudo-ODL (Object Description Language) example file.

<PRE><FONT FACE="Courier" SIZE="2">
typedef struct POINT
  { long  x;
    long  y;
  } POINT;

interface IPlotter : IUnknown
  {
    HRESULT DrawLine([in] POINT *start, [in] POINT *end);
  }
        
coclass CPlotter
  {
    [default] interface IPlotter;
  }
</FONT></PRE>
<P>To implement or access this library with Java, you would use 
the following procedure.

<OL><LI>Write a plotter.idl or plotter.odl file for the COM library and 
 pass it to the mktyplib tool (which can be found in Microsoft Visual C++) to generate a type library file called plotter.tlb.


 <LI>Write a .jnf file that describes all the user-defined types.
 Here is what the .jnf file would look like for the 
 POINT type:

 <P>PLOTTER.JNF
<PRE><FONT FACE="Courier" SIZE="2">[Custom]
POINT = java.awt.Point, PointMarshaler
</FONT></PRE>
<P>This declaration instructs jactivex to substitute the
 Java type <B>java.awt.Point</B> when it encounters a reference
 to the type named POINT in the type library. It also tells the Microsoft VM to use the PointMarshaler class as the hook class for the POINT type.


 <P><B>Important: </B>The .idl and .odl files differ on how they expose the type
 name. For example, consider the following type definition:
 <PRE><FONT FACE="Courier" SIZE="2">
       typedef struct _Foo
       {
         ...
       } FOO;
&#009;</FONT></PRE>
<P>If you are writing an .idl file, you need to put the struct tag name ("_Foo") in the .jnf; if you are writing an .odl file, you must put the type definition name ("FOO").


 <LI>Pass the names of the type library file (.tlb) and the Java type library information file (.jnf) file to jactivex using the following command: 

<PRE><FONT FACE="Courier" SIZE="2">Jactivex /javatlb /n plotter.jnf plotter.tlb 
</FONT></PRE>
<P>(Remember that for jactivex, like its predecessor Javatlb, the default output directory is in your TrustLib directory, so you may want to use the /d switch to specify a base directory.)

<P>Jactivex will create two .java files that include special @com javadoc syntax required for the jvc compiler to generate the extra bits needed by the Microsoft VM to treat these files as Java/COM classes. For example, the name of the PointMarshaler class is part of these bits.

<P>For this example, jactivex generates two files: CPlotter.java
 (representing the coclass), and IPlotter.java (representing the
 interface). Excluding the @com javadoc syntax, 
 emitted by jactivex and used by the jvc compiler, the
 generated source for IPlotter.java looks like this:

<PRE><FONT FACE="Courier" SIZE="2">// In the actual file, you will see extra syntax that
// represents the extra bits needed for the VM Java/COM
// marshaling layer.
       
interface IPlotter
  {
     public DrawLine(java.awt.Point start, java.awt.Point end);
  }
</FONT></PRE>
<LI> Compile CPlotter.java and IPlotter.java using jvc. You must use
 jvc version 1.02.3920 or later, which interprets the extra @com syntax
 that jactivex generates. This version of jvc is included in the /BIN
 directory of the Microsoft SDK for Java version 3.0 pre-release 2.

 <LI> A Java application can now load and use an installed Plotter
 library by invoking:

<PRE><FONT FACE="Courier" SIZE="2">IPlotter plotter = (IPlotter)(new CPlotter());
plotter.DrawLine(new Point(x1,y1), new Point(x2,y2));
</FONT></PRE>
<P>A Java class can also implement the Plotter library by using IPlotter as shown in the following example:

<PRE><FONT FACE="Courier" SIZE="2">
class MyPlotterImp implements IPlotter
{
   void DrawLine(Point start, Point end)
   {
      ...
   }
}
</FONT></PRE>
</OL>
<P>The sample files for this article can be found in the SDK for Java version 3.0 pre-release 2.  The sources for a working copy of this example is under the SKD-Java.20\Samples\CustDoc\plotter subdirectory. The sources for PointMarshaler are under the \CustDoc\point subdirectory. To execute the sample, change the current directory to
the \CustDoc\prundir subdirectory, and run the go.bat file.


<H3 STYLE="color:#333366"><A NAME="marshal_0004000701030000">How JAVA/COM Custom Marshaling Works</A></H3><P>How does the Microsoft VM for Java actually marshal the call from Java to
Plotter? In the interface file IPlotter.class, there are special bits
associated with the <FONT FACE="Courier New">start</FONT> and <FONT FACE="Courier New">end</FONT> parameters that indicate that these parameters are a user-defined class and that the hook class is
PointMarshaler.class. These bits are all generated by jactivex.exe.

<P>When a Java application invokes the DrawLine method, the Microsoft VM loads the PointMarshaler class (if it hasn't already). It then looks for a
public static field named cbByValSize, the presence of which indicates that the
COM type is a fixed-size. In this example, PointMarshaler happens to expose this field. It is equal to 8, which is the size (in bytes) of a POINT structure.

<P>The Microsoft VM, therefore, allocates 8 bytes of space on the stack,
and invokes another public static method on PointMarshaler called
copyToExternal. The Microsoft VM passes the copyToExternal method a pointer to
this 8-byte space and a reference to the <FONT FACE="Courier New">end</FONT> parameter, which in this
case is <B>java.awt.Point</B>. Be aware that the pointer to the 8-byte space is passed
as an integer value.

<P>With this information, copyToExternal translates the <B>java.awt.Point</B> to
a POINT structure in that 8-byte space. The same routine is repeated for the
<FONT FACE="Courier New">end</FONT> argument. The COM DrawLine method ultimately receives a pointer
to the two stack buffers as its start and end parameters. Since both
parameters were marked [in], there is no further action for this simple
type.

<P><B>Note:</B>  The previous explanation was necessarily simplified for brevity. Much of the hook class analysis implied here is done prior to any method calls and does
not actually occur at method call time.
<H3 STYLE="color:#333366"><A NAME="marshal_0004000701040000">Hook Class Overview</A></H3><P>Aside from the extra step of writing a hook class and listing your data
types in the .jnf file, the previous procedure is no different from that of
integrating any other COM library with Java. 

<P>As previously discussed, a hook class is a collection of static methods and fields packaged as a Java class. The hook class must be installed and visible to the classpath on any system where the user-defined types are used. Otherwise, hook classes remain fairly hidden. The Microsoft VM loads
the hook class as part of loading a jactivex-created interface file that
references them, and invokes methods on the hook class to marshal
the user-defined types.

<P>All hook methods and fields are static (that is, per-class, rather than
per-instance). The Java/COM integration layer of the Microsoft VM will never create an instance of a hook class. There are approximately 10 fields and methods defined by the Hook Class Specification. All hook members, however, are
either optional or have reasonable defaults. Most hook classes will 
need only to implement a subset of the members. 

<P>The following list shows the responsibilities of a hook class:
<OL><LI>Specifying the Java type (referred to generically as JTYPE). JTYPE can be a primitive type (int, double, and so on) or a reference type (objects and arrays).

 <LI>Specifying the size, in bytes, of the COM type (referred 
 to generically as ETYPE). ETYPE can be variable-sized, in which
 case, the hook class will indicate this fact by not offering a size.

 <LI>Providing code (methods) to translate JTYPEs to ETYPEs and back.

 <LI>(Optional) Providing destructor code for ETYPEs (to release
 embedded resources).

 <LI> (Optional) Providing code to allocate and free ETYPEs.
</OL>
<P>In turn, the Microsoft VM is responsible for calling the appropriate hook
methods at the right time whenever ETYPEs are passed to or from COM
methods. Once the hook class is written, the VM automatically supports
passing ETYPEs (if ETYPE is fixed-size), ETYPE*, and ETYPE**, as well as
returning ETYPE*. The VM also implements the correct semantics for [in], 
[out], [in,out], and [out,retval] type library attributes, which jactivex passes along using the extra bits in the .class file. An [out] attribute 
or double indirection is mapped to a one-element array of JTYPE rather than
to JTYPE itself. 


<H3 STYLE="color:#333366"><A NAME="marshal_0004000701050000">Hook Class Implementation</A></H3><P>Although hook classes are packaged as Java classes, they cannot be written
in Java. Hook classes must receive and pass machine addresses (pointers).
Java methods can receive pointers by masquerading them as an int type. The
Java language offers no way, however, to dereference, allocate, destroy, or otherwise manipulate pointers. For this reason, use of the Raw Native Interface (RNI) is a necessity for authoring hook classes. RNI allows Java methods
to be implemented as C functions inside a DLL. RNI also offers a small set
of APIs that can be called from C to create, manipulate, and destroy Java
objects.




<H3 STYLE="color:#333366"><A NAME="marshal_0004000701060000">Using Template Files to Write a Hook Class</A></H3><P>The SDK for Java contains samples that show how to write hook classes to achieve custom marshaling. These samples are installed in several directories under the SDK-Java.20\Samples\CustDoc directory. All directory paths referenced here are in relationship to the CustDoc directory. 

<P>The easiest way to start is by copying the files under the template
subdirectory to a new directory. The key files in template are:
<UL><LI>TemplateMarshaler.java &#151; a skeleton hook class
 <LI>TemplateMarshaler.c &#151; contains a blank C function for each method
 <LI>lateMarshaler.def &#151; exports the C functions in template.c
</UL>
<P>To make the files compilable, you must follow the instructions in each
of the comments marked "TODO" in TemplateMarshaler.java and
TemplateMarshaler.c. This involves replacing ETYPE and JTYPE with your
particular type, and uncommenting some optional methods.

<P>The template contains C functions for eight hook methods. The comments
inside each function describe what that hook function is supposed to do.
We will go into more detail about this as we proceed through the examples.
First, a few salient points about the hook functions as a whole:
<UL><LI>Each C function starts with an unused parameter "OBJECT*x". This is
 an artifact of RNI and will always be NULL for a static method. This
 parameter can be ignored.

 <LI>Several C functions have parameters "JTYPE javaval". "JTYPE" should
 be replaced throughout by the C type that represents your Java type.
 To find out what C type to use, consult the table in TemplateMarshaler.c
 or use msjavah.

 <LI>Several C functions have parameters "PPETYPE ppetype" (a pointer to
 a pointer to an ETYPE). These parameters are represented as "int"
 in the Java method, but they are true pointers.
 <BR> 
 <B>Important </B>All pointers passed to hook methods are double-indirect ETYPE (PPETYPE).
 For many methods (such as releaseExternal), this will seem like an
 unnecessary level of indirection. The reason ETYPE is always
 double-indirected has to do with an obscure feature of hook classes
 that allows you to redefine the size and nature of A POINTER to
 ETYPE. This is a very arcane use of hook classes and will not be
 mentioned again in this primer. Just remember that you will, in
 some cases, have to deal with an extra level of indirection because
 of this.
 


 <LI>Except for the functions that return Java types, hook methods return
VOID or return a native pointer through an output buffer. To indicate
failures, hook methods should use <A HREF="rniref.htm#rniref_0008010401005000">SignalError</A> or <A HREF="rniref.htm#rniref_0008010401005200">SignalErrorPrintf</A>, which cause RNI to throw a Java exception upon the exit of the C function. Remember that <B>SignalError</B> and <B>SignalErrorPrintf</B> return to their callers, so you must arrange to exit from your C function immediately after calling these APIs.
</UL>
<H3 STYLE="color:#333366"><A NAME="marshal_0004000701070000">EXAMPLE 1: FixedPtMarshaler (The Basic Hook Class)</A></H3><P>The FixedPtMarshaler sample is about the simplest useful hook class. It exposes only two methods and one field. The JTYPE is "double", and the ETYPE is the Win32 <B>FIXED</B> structure for representing fixed point fractions, as shown here:

<PRE><FONT FACE="Courier" SIZE="2">
        struct FIXED {
            WORD   fract;
            short  //covvalue;
        } FIXED;
</FONT></PRE>
<P>The source code for FixedPtMarshaler can be found under the \fixedpt
directory. The executables (FixedPtMarshaler.class and FixedPtMarshaler.dll)
are under the \rundir directory.

<P>The members implemented by FixedPtMarshaler are as follows:

<PRE><FONT FACE="Courier" SIZE="2">
      public FixedPtMarshaler {

                                        
          public static int cbByValSize; // set of sizeof(FIXED) = 8

          public static double toJava(int ppFIXED, int flags)
          {
             // convert **ppFIXED to a double
             // return the double
          }

          public static void copyToExternal(double javaval,
                                            int    ppFIXED,
                                            int    Flags)
          {
             // convert double to a FIXED
             // copy the FIXED to **ppFIXED
          }
     

      }
</FONT></PRE>
<P>Even with only these methods, this hook class can now be used in the
following ways:


<BR><BR>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>COM Type </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Marshaled to Java As 
 </B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] FIXED) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(double)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out,retval] FIXED*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">double func()
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] FIXED*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(double)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] FIXED*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(double[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] FIXED*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(double[])
</FONT></TD></TR></TABLE>
<P>Note that when using this hook class in a .jnf file, you should preceed
the Java type double with the const modifier as in the following example:
<PRE><FONT FACE="Courier" SIZE="2">
    [Custom]
    FIXED=const double, FixedPtMarshaler
</FONT></PRE>
<P>If you do not include the const modifier, jactivex will interpret that [out] parameters are intended to pass along single values passed in by the caller (as a side-effect), rather than passing a new value out using a single-element array. That is, jactivex would map the FIXED type as follows:
<BR><BR>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>COM </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Marshaled to Java As 
 </B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] FIXED*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(double)
</FONT></TD></TR></TABLE>
<P><P>This is not what you want. Because double is immutable, this method prototype cannot possibly return a value to the caller.


<H3 STYLE="color:#333366"><A NAME="marshal_0004000701080000">EXAMPLE 2: VarStrMarshaler (Embedded Resources)</A></H3><P>The basic hook class, demonstrated by FixedPtMarshaler, assumes that ETYPE contained no embedded pointers or handles to allocated resources that need to be freed when ETYPE is no longer needed. In C++ terms, if ETYPE is a class in a basic hook class, it is assumed ETYPE does not have a destructor. Some structures, however, do need to clean up embedded resources. A well known example is the <B>VARIANT</B> structure used in ActiveX Automation. A <B>VARIANT</B> is a fixed-size structure, yet it can have allocated objects such as BSTR, SAFEARRAYS and COM objects referenced by it. The "destructor" for a <B>VARIANT</B> is the <A HREF="Variant.htm#com_000300050e025400">VariantClear</A> API, which checks the type of the variant and performs the appropriate cleanup (for example, freeing the BSTR, freeing the SAFEARRAY, calling <B>Release</B> on the COM object, and so on).

<P>Arranging for proper cleanup of embedded resources requires only
one new method: releaseByValExternal.

<P>
The VarStr marshaler example maps <B>VARIANT</B> types, confining itself to only one case: marshaling <B>BSTR</B> <B>VARIANT</B> types to Java String objects. That is, the JTYPE is String, and the ETYPE is as follows:
<PRE><FONT FACE="Courier" SIZE="2">
        struct {
            short vt;           // Always VT_BSTR for this example
            short unused;
            short unused1;
            short unused2;
            BSTR  bstrVal;      // Points to characters in BSTR
            long  unused3;      // never used in this example.

        } VARIANT;
</FONT></PRE>
<P>The source code for VarStrMarshaler can be found under the \varstr
directory. The executables VarStrMarshaler.class and VarStrMarshaler.dll 
are under the \rundir directory.

<P>The members implemented by VarStrMarshaler are as follows:
<PRE><FONT FACE="Courier" SIZE="2">
public VarStrMarshaler {
                                        
    public static int cbByValSize; // set of sizeof(VARIANT) = 16

    public static String toJava(int ppVARIANT, int flags)
    {
       // convert **ppVARIANT to a String
       // return the String
    }

    public static void copyToExternal(String javaval,
                                      int    ppVARIANT,
                                      int    Flags)
    {
       // convert String to a VARIANT
       // copy the VARIANT to **ppVARIANT
    }

    /* NEW! */
    public static void releaseByValExternal(int ppVARIANT, int Flags)
    {
       SysStringFree( (*ppVARIANT)-&gt;bstrVal );
    }
          

}
</FONT></PRE>
<P>This hook class can be used in the following ways.

<BR><BR>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>COM Type </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Marshaled to Java As 
 </B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] VARIANT) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out,retval] VARIANT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String func()
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] VARIANT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] VARIANT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] VARIANT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])

</FONT></TD></TR></TABLE>
<P>As before, String is immutable so the const modifier should be used
for it in the .jnf file.

<H3 STYLE="color:#333366"><A NAME="marshal_0004000701090000">EXAMPLE 3: PointMarshaler (Mutable Java Objects)</A></H3><P>In the examples up to this point, all JTYPEs were immutable. This is why [out] parameters could only be handled by single element arrays: that is, to deal with immutable types, a caller has to write code similar to the following:

<PRE><FONT FACE="Courier" SIZE="2">
   {
      double ad1[] = {0};
      double ad2[] = {0};

      func(ad1, ad2);

      System.out.println("func gave back: " + ad1[0] + ", " + ad1[1]);

   }
</FONT></PRE>
<P>For immutable objects, it should be clear that the function:
<PRE><FONT FACE="Courier" SIZE="2">
  HRESULT func([out] FIXED *, [out] FIXED *);
</FONT></PRE>
<P>could not be usefully mapped to:

<PRE><FONT FACE="Courier" SIZE="2">
  func(double d1, double d2);
</FONT></PRE>
<P>because func() would have no way of returning information to the caller.


<P>However, consider the java class <B>java.awt.Point</B> (which represents a
point in 2-dimensional space.) The <B>Point</B> class is mutable as its <B>x</B> and <B>y</B> fields are public and can set by anyone. Therefore, it is advantageous to use the non-array form for passing [out] parameters. To do this only requires two new methods: copyToJava and toUninitJava.

<P>The PointMarshaler class maps <B>java.awt.Point</B> to the Win32 <B>POINT</B>
structure. The source code for PointMarshaler can be found under the \point
directory. The executables PointMarshaler.class and PointMarshaler.dll 
are under the rundir directory.

<P>The members implemented by PointMarshaler are:
<PRE><FONT FACE="Courier" SIZE="2">
public PointMarshaler {
                                        
    public static int cbByValSize; // set of sizeof(POINT) = 8

    public static Point toJava(int ppPOINT, int flags)
    {
       // convert **ppPOINT to a Point
       // return the Point
    }

    public static void copyToExternal(Point javaval,
                                      int    ppPOINT,
                                      int    Flags)
    {
       // convert Point to a POINT
       // copy the POINT to **ppPOINT
    }

    /* NEW! */
    public static void copyToJava(Point javaval, int ppPOINT, int Flags)
    {
       // modify "javaval" in place so it is "equivalent" to **ppPOINT;
    }

    /* NEW! */
    public static Point toUninitJava(int ppPOINT, int flags)
    {
       // create a new Point with arbitrary x and y values.
       // the contents of **ppPOINT are completely undefined and should
       // be ignored for fixed-size hook classes.
    }
}
</FONT></PRE>
<P>This hook class can be used in the following ways.

<BR><BR>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>COM Type </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Marshaled to Java As 
 </B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] POINT) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Point)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out,retval] POINT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Point func()
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] POINT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Point)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] POINT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Point)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] POINT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Point)
</FONT></TD></TR></TABLE>
<P>This differs from the basic hook class in that [out] POINT* becomes
a single element, Point, rather than a single-element array, Point[]. To force jactivex to generate the non-array mapping, you must omit the const modifier from the Point entry in the .jnf file.



<H3 STYLE="color:#333366"><A NAME="marshal_00040007010a0000">EXAMPLE 4: RectMarshaler (Support for Custom Allocation)</A></H3><P>The hook class examples up to this point have provided no method for allocating or freeing the memory for ETYPE itself. They have relied entirely on the
VM to allocate the actual memory for ETYPE. As a result, the use of
custom data types up until now has been restricted to cases where ETYPE can
be allocated on the stack and its lifetime is bounded by the lifetime of the
call. While this is sufficient for some data types, there are cases where stack
allocation is insufficient. The first case is when there is a need to marshal
methods where an ETYPE is allocated by the callee but freed by the caller
(or the other way around, as can happen with [in,out] parameters.) The second case is if the data type is variable-sized (such as a string), in which case, the VM cannot do the stack-allocation because the size is unknown.

The first case is considered next, followed by the second case.

<P>It is the responsibility of the hook class to specify which API is used to allocate and release the memory for ETYPE. The new hook methods required
to support this are toExternal and releaseExternal.

<P>The RectMarshaler example demonstrates this by marshaling the Win32 RECT structure into java.awt.Rect objects. The source code for RectMarshaler can be found under the \rect directory. The executables RectMarshaler.class and
RectMarshaler.dll are under the \rundir directory.

<P>The members implemented by RectMarshaler are:
<PRE><FONT FACE="Courier" SIZE="2">
public RectMarshaler {

                                        
   public static int cbByValSize; // set of sizeof(RECT) = 8

   public static Rect toJava(int ppRECT, int flags)
   {
      // convert **ppRECT to a Rect
      // return the Rect
   }

   public static void copyToExternal(Rect javaval,
                                     int    ppRECT,
                                     int    Flags)
   {
      // convert Rect to a RECT
      // copy the RECT to **ppRECT
   }


   /*NEW*/
   public static void toExternal(Rect javaval, int ppRECT, int Flags)
   {
      // allocate a new RECT, initialize it using javaval,
      // store pointer in *ppRECT
   }


   /*NEW*/
   public static void releaseExternal(int ppRECT, int Flags)
   {
      // release *ppRECT. If RECT required a releaseByValExternal
      // (which it doesn't), this routine must do that work as well.
   }
          

}
</FONT></PRE>
<P>Note this example could also have implemented copyToJava and toUninitJava here since Rect is mutable (like Point). However, for the sake of clarity, this was not done.

<P><B>Important Note:</B>  Even in the presence of these new Marshaling methods, the VM will
optimize by allocating the data structure on the stack and thus override certain allocations. For example, for "[in] ETYPE*" calls, the COM method will receive
a pointer to a VM-allocated ETYPE on the stack rather than one allocated
by the toExternal method. If you want all ETYPEs to be allocated using toExternal(), you must omit the cbByValSize field. This will prevent the VM from
optimizing to stack allocations as it cannot predict how many bytes to allocate.
<P>This hook class can be used in the following ways:
<BR><BR>


<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>COM Type </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Marshaled to Java As 
 </B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] RECT) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out,retval] RECT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Rect func()
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] RECT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] RECT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] RECT*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out,retval] RECT**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Rect func()
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] RECT**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] RECT**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] RECT**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(Rect[])
</FONT></TD></TR></TABLE>
<H3 STYLE="color:#333366"><A NAME="marshal_00040007010b0000">EXAMPLE 5: AnsiMarshaler (Variable-sized data types)</A></H3><P>So far in this article, all of the ETYPE examples have been fixed-size structures. For some data structures, this is a prohibitive limitation. The classic example is a simple null-terminated string.

<P>To define a variable-sized structure, the hook class must omit the
cbByValSize field. The absence of this field marks the hook class as
variable-size. Unlike a fixed-sized hook class, a variable-size hook class
must support toExternal and releaseExternal in order to be useful (the
VM cannot allocate a variable-sized structure on the stack). In addition
certain mappings available to fixed-size hooks (in particular, those
that pass the data type by value) are not available to variable-size hooks. 

<P>More specifically, consider the simple case where ETYPE is char
(not LPSTR!), and JTYPE is <B>java.lang.String</B>. (Both types can be considered immutable for this example.) This structure can be defined by a hook class with only
three methods: toJava, toExternal and releaseExternal; the minimum useful
variable-size hook class.

<P>The AnsiMarshaler class maps Strings to the LPSTR (ANSI null-terminated
strings). The source code for AnsiMarshaler can be found under the \ansistr
directory. The executables (AnsiMarshaler.class and AnsiMarshaler.dll)
are under the rundir directory.

<P>The members implemented by AnsiMarshaler are:
<PRE><FONT FACE="Courier" SIZE="2">
public AnsiMarshaler {
                                  
   public static String toJava(int ppCHAR, int flags)
   {
      // convert **ppCHAR to a String
      // return the String
   }

   public static void toExternal(String javaval, int ppCHAR, int Flags)
   {
      // allocate a new LPSTR, initialize it using javaval,
      // store pointer in *ppCHAR
   }

   public static void releaseExternal(int ppCHAR, int Flags)
   {
      // release *ppCHAR. If LPSTR required a releaseByValExternal
      // (which it doesn't), this routine must do that work as well.
   }
          
}
</FONT></PRE>
<P>The allowed usages are as follows:
<BR><BR>


<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>COM Type </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Marshaled to Java As 

 </B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] CHAR*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String)
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] CHAR*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] CHAR*) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out,retval] CHAR**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">String func()
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in] CHAR**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([out] CHAR**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])
 </FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT func([in,out] CHAR**) </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">func(String[])
</FONT></TD></TR></TABLE>
<H3 STYLE="color:#333366"><A NAME="marshal_00040007010c0000">Running and Building the Sample Client</A></H3><P>The \client directory contains the sources for a sample Java client
and a C++ inproc COM server which exchange all the various types 
implemented by the example.

<P>To run the example, simply change the current directory to "rundir",
and type "GO".

<P>To build the sample, you will need to provide a makefile compatible with
your build environment. Here are the steps:

<OL><LI>Compile sysdata.odl to produce sysdata.tlb:
<PRE><FONT FACE="Courier" SIZE="2">mktypelib sysdata.odl.
</FONT></PRE>
<LI>Compile CustSample.odl to produce CustSample.tlb and CustSample.h
<PRE><FONT FACE="Courier" SIZE="2">mktyplib /h CustSample.h CustSample.odl
</FONT></PRE>
<LI>Compile CustSample.tlb to produce CCustSample.java and ICustSample.java
<PRE><FONT FACE="Courier" SIZE="2">jactivex /javatlb CustSample.tlb /nCustSample.jnf
</FONT></PRE>
<LI> Compile CCustSample.java to produce CCustSample.class
<PRE><FONT FACE="Courier" SIZE="2">jvc CCustSample  (You must use Jvc version 1.02.3920 or later)
</FONT></PRE>
<LI> Compile ICustSample.java to produce ICustSample.class
<PRE><FONT FACE="Courier" SIZE="2">jvc ICustSample  (You must use Jvc version 1.02.3920 or later)
</FONT></PRE>
<LI> Compile CustSample.java to produce CustSample.class and callbacks.class
<PRE><FONT FACE="Courier" SIZE="2">jvc CustSample  (You must use Jvc version 1.02.3920 or later)
</FONT></PRE>
<LI> Compile CustSample.cpp &amp; CustSample.def to produce CustSample.dll.
<PRE><FONT FACE="Courier" SIZE="2">cl + link.
</FONT></PRE>
</OL>

<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
