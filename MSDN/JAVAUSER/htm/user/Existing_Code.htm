<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Existing Native Code Interface</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Native Code Interface Specification"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Existing_Code.htm#natcodei_0008010302010000">How Object References are Stored Internally</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Existing_Code.htm#natcodei_0008010302020000">Implications for the Existing Native Code Interface</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="Existing_Code.htm#natcodei_0008010302030000">Consequences</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="365" VALIGN="bottom"><IMG SRC="art/jnative2.gif" WIDTH="365" HEIGHT="27"  BORDER=0 ALT="Java & Native Code"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="Native_Code_Interface.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="Native_Code_Interface.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="RNI"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="New_Native_Code.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="365" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Native Code Interface Specification</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">RNI</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Existing Native Code Interface</H2>
<P>Typically when writing Java applications, developers may want to use existing libraries of native code, or call out to routines written in native code for performance reasons. The following is an example (using the current native code interface provided by in the Sun Java VM) of how this is done.
<P>An example of a Java method declaration, which is implemeted in native code, is as follows.
<PRE><FONT FACE="Courier" SIZE="2">package myPackage;

class  myClass {
&#009;public static native int myMethod  (myOtherClass  myObj);
}
</FONT></PRE>
<P>This example declares a static, native method named myMethod within the class myClass in the package myPackage. The method takes myObj (an object of type myOtherClass) as its parameter.
<P>The following example shows how this method can be then be called from within the Java code by invoking (for example): 
<PRE><FONT FACE="Courier" SIZE="2">
...
int i;
myOtherClass myObj = new myOtherClass;

i = myClass.myMethod (myObj);
...
</FONT></PRE>
<P>The interfacing between Java and C is handled by a program called msjavah. It takes the previous <B>native</B> declaration and produces the following two pieces of code from it.
<OL><LI>A C header file that can be used in C code which defines an appropriate prototype method and structure declaration for the containing class.
<LI>A stub function that is placed in the same file as the implementation.
</OL>
<P>The C native code implementation of the method myMethod looks like the following example:
<PRE><FONT FACE="Courier" SIZE="2">
int myPackage_myClass_myMethod (HObject *AlwaysNull, HmyOtherClass *myObj)
{
myOtherClass *mO = unhand (myObj);

&#009;// body of the implementation of the function ...
&#009;// e.g. mO-&gt;member; 
}
</FONT></PRE>
<P>The function is defined with an initial first parameter (AlwaysNull) that is present only for historical reasons (it is always 0 in current Microsoft VM implementations). Note that in the Microsoft Native Code Interface the convention is kept for source code compatibility.
<P>The stub (which <B>msjavah</B> generates) would look like the following:
<PRE><FONT FACE="Courier" SIZE="2">
Java_myPackage_myClass_myMethod_stub (ExecEnv *, paramblock * pPB);
</FONT></PRE>
<P>When the function myMethod is called from Java, it is this stub that is called. The parameter block in that stub is unwrapped, pushed onto the stack, and then the myPackage_myClass_myMethod function is called in C. The Java code passes the parameter block from the frame, the stubs unwrap it, and then the stubs pass it on to the actual function that you're interested in calling.
<P>The final piece to calling is the <B>unhand</B> macro used in the C function previously mentioned. This macro relies on the internal object representation (a double indirection between the myObj handle and the data; see below) to provide an actual pointer to the data in C. It is necessary to use the <B>unhand</B> macro to access the object data. Microsoft recommends that <B>unhand</B> be used each time an object is accessed, since the object may have been garbage collected within Java, and a pointer reference to it obtained previously may then point to invalid data. Although existing virtual machines (VMs) other than the Microsoft VM attempt to find and ensure validity of all unhanded object references in any C code that may have been called, there are cases where this attempt may not be sufficient to prevent pointers from becoming invalid.

<H3 STYLE="color:#333366"><A NAME="natcodei_0008010302010000">How Object References are Stored Internally</A></H3><P>The following diagram describes the internal storage details of objects within the existing native code system.
<P> 
<P><IMG SRC="art/java03.gif" WIDTH="230" HEIGHT="58" ALT="" >
<P>
<P>Essentially, everywhere that a reference to an object is stored there is a pointer to the handle, which then references the object. 
<P>

<H3 STYLE="color:#333366"><A NAME="natcodei_0008010302020000">Implications for the Existing Native Code Interface</A></H3><UL><LI>An extra indirection (using the <B>unhand</B> macro) is required to get to every object referenced.
<LI>Despite the use of <B>unhand</B>, if you have an unhanded value referencing an object, that object may be moved by garbage collection, and the reference that you have could become invalid. To avoid this, when garbage collection occurs under this model, the VM suspends all the threads that were running in Java code and tries to find out where the end of the native stacks are. It then conservatively scans the entire C stack and register set of all threads for any DWORDS that might possibly point into objects. If any are found, these objects are not moved when the garbage collection heap is compacted. Unfortunately, there are cases where this attempt could fail to find all outstanding unhanded references. It is also a somewhat time-consuming process.
<LI>If there are many different pointers, it's extremely difficult for a compiler to enregister <B>unhanded</B> pointers (given restrictions on the numbers of registers in certain machine architectures). As a result, there will constantly be memory reads, which is generally less efficient.
</UL>
<P>Conservative scanning, or garbage collection, is the term used when nothing is known about the data that is being checked. It may just be characters or some other simple data type, but if it looks like it may be a pointer, it is treated as such to err on the side of caution. Since the data is not known to be a pointer, it cannot be modified to refer to a new copy of the object that it seems to point to. Instead, the object in question must be fixed in memory and made immovable.

<H3 STYLE="color:#333366"><A NAME="natcodei_0008010302030000">Consequences</A></H3><P>The main consequences are loss in performance with native code (which is one of the reasons why native code is used in the first place), and potentially non-deterministic errors when <B>unhand</B> has been used unsafely.


<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
