<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Trust-Based Security for Java</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Articles"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="trust_based_security.htm#security_000a000201010000">Overview</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="trust_based_security.htm#security_000a000201020000">Features of Trust-Based Security</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="trust_based_security.htm#security_000a000201030000">Summary</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="365" VALIGN="bottom"><IMG SRC="art/Secur2.gif" WIDTH="365" HEIGHT="27"  BORDER=0 ALT="Security"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom">&nbsp;</TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_sec.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_sec.htm"><IMG SRC="art/homenrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Security"></A></TD></TR>
<TR>
<TD WIDTH="365" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Trust-Based Security for Java</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">&nbsp;</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Security</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Trust-Based Security for Java</H2>
<H3 STYLE="color:#333366"><A NAME="security_000a000201010000">Overview</A></H3><P>Trust-based security for Java is a cross-platform security model that provides fine-grained administration of the permissions granted to Java applets and libraries. This security system provides intermediate levels of trust so that Java applications can be given some additional permissions without being offered unlimited access to every permission in the system. The following features are provided.
<UL><LI><A HREF="trust_based_security.htm#security_000a000201020100">Security Zones</A> that allow related sites (such as all sites on a company intranet) to be administered as a group. 
<LI>A <A HREF="trust_based_security.htm#security_000a000201020200">Permission Model</A> that integrates with security zones to provide parameterized control over what Java classes can do.
<LI><A HREF="trust_based_security.htm#security_000a000201020300">Permission Signing</A> that allows a signed cabinet file to specify not only the identity of the signer but also the set of permissions being requested for the signed classes.
<LI><A HREF="trust_based_security.htm#security_000a000201020400">Permission Scoping</A> that enables a developer who designs a trusted class to precisely limit the range of code for which a granted permission is enabled. 
<LI>A <A HREF="trust_based_security.htm#security_000a000201020500">Package Manager</A> that allows classes to be installed with their permissions.
<LI>A <A HREF="trust_based_security.htm#security_000a000201020600">User Interface</A> that simplifies or eliminates the decisions that end users need to make.
</UL>
<H3 STYLE="color:#333366"><A NAME="security_000a000201020000">Features of Trust-Based Security</A></H3><P>Each of the features of the trust-based security system offers benefits to end users and to administrators. To further explain these benefits, the implementation of each feature is discussed in the following sections.
<H4 STYLE="color:#333366"><A NAME="security_000a000201020100">Security Zones</A></H4><P>Security zones allow a system administrator to manage groups of sites using the same level of trust for a whole group. The idea is to be able to set nonrestrictive security options for trusted areas and, at the same time, set very safe (restrictive) security options elsewhere. Predefined zones exist for categories such as the Local Intranet and the Internet. Security zones relieve administrators from having to list every trusted applet and its permissions, and they help administrators avoid the risk of leaving too many detailed decisions up to end users.

<P>There are five default security zones defined in the trust-based security for Java implementation in Internet Explorer 4.0. These zones correspond to the most commonly used types of sites. 
<UL><LI>My Computer 
<P>This zone includes most classes stored on the local machine. Because this zone is completely trusted, few or no security restrictions apply. 
<BR><BR>
<LI>Local Intranet
<P>This zone includes content that is known to be reliable (typically located inside the firewall or obtained using a secure sockets layer [SSL] connection). 
<BR><BR> 
<LI>Trusted Sites
<P>This zone includes responsible Internet sites that are allowed to run with increased permissions, but not with the powerful permissions allowed to the Intranet zone.
<BR><BR>
<LI>Internet
<P>This zone includes all other sites, including scratch and development areas inside the firewall, and untrusted parts of local drives. This zone would typically be set to the standard applet permissions.
<BR><BR>
<LI>Restricted Sites
<P>This zone includes potentially harmful sites to which severely restricted permissions apply. For these sites, you may want to define "sandboxes" that are even more restrictive than the standard Java sandbox.
</UL>
<P>Network administrators can configure three different sets of permissions for each zone. The set that a permission is placed in determines whether or not the user will be presented with a dialog box that shows requested permissions.
<UL><LI>Permissions granted without user intervention.
<P>These permissions are granted to applets from the specified zone without querying the user. These permissions can be separately specified for signed and unsigned applets.
<BR><BR>

<LI>Permissions granted with user intervention.
<P>These permissions can be determined directly through a list of permissions to query the user about, in which case every permission not mentioned is assumed to be denied. 
<BR><BR>
 
<LI>Permissions that are prohibited.
<P>These permissions are considered too dangerous to allow under any circumstances. They are automatically denied.
<BR><BR>

</UL>
<P>If an applet uses only permissions granted without user intervention to its zone, it will run without user intervention. If it uses any explicitly denied permissions, it will automatically be prevented from running. Otherwise, the user will be presented with a single dialog box listing all of the permissions being requested and their associated risk. The user can then make one decision about whether to trust the applet that has that set of permissions.

<P>An applet that does not receive the additional permissions requested will still be permitted to run, but will be prevented from exercising those permissions by security exceptions. The applet can catch the security exceptions so that it can take alternate action, perhaps continuing to run with more limited functionality.

<P>The administrator can define a set of permissions that is assigned to all unsigned classes and scripts. This set defines the permissions of unsigned applets. 

<H4 STYLE="color:#333366"><A NAME="security_000a000201020200">The Permission Model</A></H4><P>The permission model for trust-based security supports a useful set of parameterized and non-parameterized permissions that can be individually granted or denied for a particular zone by an administrator. To reduce the number of options that administrators must specify in common cases, the administrative user interface provides several "preset" permission sets that can be applied. These predefined permission sets, called High, Medium, and Low, represent the most restrictive to the least restrictive predefined set of permissions, respectively. 

<P>Permissions can only be defined by system libraries with the highest degree of trust. This solves the problem of having to administer a potentially unlimited set of permission requests with uncertain, application-defined meanings.

<H5 STYLE="color:#333366">Defined Permissions</H5><P>The following list describes each permission defined by the permission model and lists the parameters available for limiting each permission.

<UL><LI>Client Storage Permission
<P>Determines whether applets can access scratch space. Parameters for this permission include the size of the scratch space and flags that indicate whether storage is exempt from global storage limits and whether roaming files can be created. For more information, see the <A HREF="ClientStoragePermission.htm">ClientStoragePermission</A> class. 
<BR><BR>

<LI>Execution Permission
<P>Determines which programs can be executed on the client's machine. Parameters for this permission include a pattern that indicates which applications to include or exclude from the permission. For more information, see the <A HREF="ExecutionPermission.htm">ExecutionPermission</A> class. 
 
<BR><BR>

<LI>File I/O Permission
<P>Determines whether applets can perform file operations. Parameters include the type of access (read, write, or delete), the filename or a pattern that indicates a group of files, and a flag that specifies whether the operation is denied or allowed. For more information, see the <A HREF="FileIOPermission.htm">FileIOPermission</A> class. 

<BR><BR>

<LI>Multimedia Permission
<P>Controls access to extended multimedia capability. This permission has no parameters. For more information, see the <A HREF="MultimediaPermission.htm">MultimediaPermission</A> class. 

<BR><BR>

<LI>Network I/O Permission
<P>Controls the ability to perform networking components for three types of network operations: connect, bind, and multicast. Parameters include the network operation type (connect, bind, or multicast), a flag that indicates allowing or denying the operation, a pattern that indicates which hosts or ports to include or exclude, Internet Protocol (IP) addresses, port ranges, and flags that indicate whether you can bind to a non-file:// URL codebase or to a file://URL codebase. For more information, see the <A HREF="NetIOPermission.htm">NetIOPermission</A> class.
<BR><BR>

<LI>Printing Permission
<P>Controls whether an applet is allowed to print. This permission has no parameters. For more information, see the <A HREF="PrintingPermission.htm">PrintingPermission</A> class. 

<BR><BR>

<LI>Property Permission
<P>Controls the ability to access and manipulate the global system properties. Parameters include a flag that indicates whether access to all properties is turned on or off, a pattern that indicates which properties are included or excluded, and suffixes indicating properties that could be accessed under certain conditions. For more information, see the <A HREF="PropertyPermission.htm">PropertyPermission</A> class. 

<BR><BR>

<LI>Reflection Permission
<P>Determines whether access to the <B>java.lang.reflect</B> API is permitted. Parameters include a loader type (same loader, different loader, system loader, all, or none) and an access type (public or declared). For more information, see the <A HREF="ReflectionPermission.htm">ReflectionPermission</A> class. 

<BR><BR>

<LI>Registry Permission
<P>Controls the ability to access the registry. Parameters include the type of access (read, write, open, delete, or create) and a pattern that indicates which keys/values are included or excluded from access. For more information, see the <A HREF="RegistryPermission.htm">RegistryPermission</A> class. 

<BR><BR>

<LI>Security Permission
<P>Controls access to the <B>java.lang.security</B> package. This permission has no parameters. For more information, see the <A HREF="SecurityPermission.htm">SecurityPermission</A> class. 

<BR><BR>

<LI>System Streams Permission
<P>Controls the ability to change the values of the system streams <B>java.lang.System.in</B>, <B>java.lang.System.out</B>, and <B>java.lang.System.err</B>. Parameters include flags that indicate whether <B>System.in</B>, <B>System.out</B>, and <B>System.err</B> can be set. For more information, see the <A HREF="SystemStreamsPermission.htm">SystemStreamsPermission</A> class. 

<BR><BR>

<LI>Thread Permission
<P>Controls the ability to create and manipulate threads and thread groups. Parameters include a thread or thread group object, a flag that indicates whether unrestricted thread access is allowed, and a flag that indicates whether unrestricted thread group access is allowed. For more information, see the <A HREF="ThreadPermission.htm">ThreadPermission</A> class. 
 
<BR><BR>

<LI>User File I/O Permission
<P>Determines whether user-directed file I/O can be performed. Parameters for this permission include the access type (read or write) and a file name or a pattern that indicates which files to allow access to. For more information, see the <A HREF="UserFileIOPermission.htm">UserFileIOPermission</A> class. 
 
<BR><BR>

<LI>User Interface Permission
<P>Controls the ability to create top level windows, access the system clipboard, create file dialog boxes, and access the AWT event queue. Parameters for this permission include flags that indicate access to one or more of the enhanced UI functions. For more information, see the <A HREF="UIPermission.htm">UIPermission</A> class. 

<BR><BR>

</UL>
<H5 STYLE="color:#333366">Defining Applet Permissions</H5><P>The following sets of permissions correspond to the standard Java sandbox.
<UL><LI>Thread access in the current execution context.
<LI>Network connections to the applet host.
<LI>Creation of top-level windows with warning banners.
<LI>Reflection to classes from the same loader.
<LI>Access to base system properties.
</UL>
<P>You can choose these permissions or you can set up an even more restrictive set of permissions for applets. Choosing a less restrictive set is not recommended

<H5 STYLE="color:#333366">Defining Custom Permissions</H5><P>Internet service providers or personal users might want to define custom permissions. Permission objects can be defined to protect some functionality in your code against misuse. Custom permissions can be added to the digital signature so that the user can decide (via a dialog box) whether or not to accept the risk. To add custom permissions to the digital signature, you would specify the requested permissions in an .ini file that is used by the signcode tool when signing the cabinet file. For more information about using the permission .ini file with the signcode tool, see the <A href="signcode.htm">Signing a Cabinet File with Java Permissions Using Signcode</A> article and the <A href="sampleini.htm">Sample Permissions .INI File</A>.

 

<H4 STYLE="color:#333366"><A NAME="security_000a000201020300">Permission Signing</A></H4><P>Permission signing extends the signed cabinet file functionality provided by Microsoft&#174; Internet Explorer 3.0. Under trust-based security, a signed cabinet file can securely specify not only the identity of the signer but also the set of permissions being requested for the signed classes. The security system can determine all of the permissions requested by a Java component by inspecting the digital signature. This information is used to present to the user a single dialog box that displays all of the relevant trust questions. The dialog box is presented before any code starts to run. In addition, because the set of permissions is fully defined and understood by the Microsoft Win32 VM for Java, the dialog box can accurately warn users about the risk of each requested permission. For more information on permission signing, see the article on <A href="signcode.htm">Signing a Cabinet File with Java Permissions Using Signcode</A>.

<H4 STYLE="color:#333366"><A NAME="security_000a000201020400">Permission Scoping</A></H4><P>Permission scoping prevents permissions granted to a trusted component from being misused (either inadvertently or intentionally) by a less trusted component. A trusted class can precisely limit the range of code for which a granted permission is enabled. This is an important issue because some methods that use enhanced permissions are designed to be safely called by anyone, while other methods are designed to be used internally by trusted callers only and should not expose their permissions to less trusted callers. 

<P>Trust-based security distinguishes between permissions that have been granted to a class and permissions that are actually enabled at a particular time. The granted permissions are determined by the administrative options for a class's zone and by the permissions with which the class was signed. In contrast, enabled permissions are determined by the permissions granted to other callers on the call stack and by any calls that were made to the <A HREF="PolicyEngine.htm#com_0003000d09010100">assertPermission</A>, <A HREF="PolicyEngine.htm#com_0003000d09011300">denyPermission</A>, and <A HREF="PolicyEngine.htm#com_0003000d09011900">revertPermission</A> methods. If there are any less trusted callers on the call stack, the enabled permissions can be more restrictive than the granted permissions. 

<P>When the Microsoft VM for Java implements permission scoping, two rules are followed. The first rule is that permissions are never inherited from the caller. If a class has not been directly granted a permission, it can never make use of that permission, regardless of what permissions its callers may have. This makes trust-based security invulnerable to "luring" attacks, in which an untrusted class "lures" a trusted class into calling it so that the untrusted class is allowed to make use of the expanded permissions of its caller.

<P>The second rule is that even if a class has been granted a permission, its methods must explicitly enable that permission using the <A HREF="PolicyEngine.htm#com_0003000d09010100">assertPermission</A> method whenever there is a caller on the call stack that has not been granted that permission. In other words, permission P is enabled only if either statement 1 or 2 listed below is true, and if statement 3 is true. 
<OL><LI>P is granted in all of the stack frames from the active frame up to the earliest frame on the stack.
<LI>P is granted in all of the stack frames up to a frame that has called <A HREF="PolicyEngine.htm#com_0003000d09010100">assertPermission</A> on P.
<LI>No intervening frame has called <A HREF="PolicyEngine.htm#com_0003000d09011300">denyPermission</A> on P.
</OL>
<P>The deep security checks of the <A HREF="PolicyEngine.htm">PolicyEngine</A> class perform the stack crawl that follows the above rules. The Java APIs contain calls to the <A HREF="StandardSecurityManager.htm">StandardSecurityManager</A> checkXX methods, which in turn call the PolicyEngine.<A HREF="PolicyEngine.htm#com_0003000d09010e00">checkPermission</A> methods to check for a particular permission. 

<P>The methods of the <A HREF="PolicyEngine.htm">PolicyEngine</A> class allows you to control which permissions are enabled. For example, the following code sample asserts the right to access scratch space through the <A HREF="def_ics.htm">com.ms.io.clientstorage</A> APIs, then reverts this right.
<PRE><FONT FACE="Courier" SIZE="2">
import com.ms.security.*;
import com.ms.io.clientstorage.*;

// Assert the right to access the 
// com.ms.io.clientstorage APIs.
PolicyEngine.assertPermission(PermissionID.CLIENTSTORE);

// Now open a file for writing. Because rights have been
// asserted, this check will succeed even if the callers 
// do not possess the CLIENTSTORE permission. 
OutputStream os = 
   ClientStorageManager.openWritable("Scratch1.txt");

...
// Remove the scratch space assertion.
PolicyEngine.revertPermission(PermissionID.CLIENTSTORE);
...

// Open a file for reading.
// This time the callers will be included in the 
// security check because the right to access the 
// com.ms.io.clientstorage APIs is no longer asserted.
// The security check will succeed only if all callers
// have the appropriate CLIENTSTORE permission.
InputStream is = 
   ClientStorageManager.openReadable("Scratch2.txt");
...
</FONT></PRE>
<P>For more information on asserting, denying, and reverting permissions, see the <A HREF="def_psec.htm">com.ms.security</A> overview. For more information about how the stack crawl for security checks is implemented, see the overview for the <A HREF="PolicyEngine.htm">PolicyEngine</A> class. 

<H4 STYLE="color:#333366"><A NAME="security_000a000201020500">The Package Manager</A></H4><P>The package manager allows the installation of local class libraries that are not fully trusted by using permission signing. This is especially important for components such as JavaBeans and class libraries. It is desirable to allow these components to reside locally and to have some expanded permissions, but it is often not necessary to give them unlimited power.

<P>System libraries are libraries that are shared and have all possible security permissions available to them. These libraries are the core of the Java system APIs, and they are the most privileged Java code. Most packages installed from non-system providers do not need this level of permissions. However, Java has traditionally treated all local classes on the class path as if they were system libraries. 

<P>Under trust-based security, classes from installed packages are not shared between applets or applications that use them. They carry specific system permission identifiers that are approved by either the user or the system administrator when the package is installed on the user's system. The permission identifiers determine the maximum permissions that can be used by the classes in that package. For more information on the package manager, see the <A HREF="jpm.htm">Java Package Management</A> article.

<H4 STYLE="color:#333366"><A NAME="security_000a000201020600">The User Interface</A></H4><P>The user interface (UI) defined by trust-based security for Java shields end users from complicated trust decisions and reduces the number of dialog boxes that they must respond to. The integration of permissions with zones means that users only need to make a simple yes/no decision about whether to trust an application. An administrator has already made preliminary decisions, based on the zone involved, about which permissions to leave to the discretion of the user.

<P>Permission signing allows the security system for the Microsoft VM for Java to predetermine all of the permissions required by a class. When a package is installed, the security system uses the digital signature to determine exactly which system permissions are needed. Before the code runs, a single dialog box clearly presents to the user all of the permissions required by an application. 

<H3 STYLE="color:#333366"><A NAME="security_000a000201030000">Summary</A></H3><P>Trust-based security for Java provides a flexible, easy to use security system. The permission model provides control over what a Java class can do by providing a way to associate a set of permissions with a class. Encoding the permission set in the digital signature allows the Microsoft VM for Java to present the end user with a dialog box that lists the requested permissions so that the user can decide whether to trust the applet. Because administrators can make preliminary security decisions based on predefined zones, the end user is spared from many tedious security decisions. Permission scoping prevents untrusted classes from taking advantage of the expanded permissions of trusted classes and gives developers the ability to decide which parts of their trusted code enable a particular permission. Finally, package management allows for local installation of components that are not fully trusted so that those components have expanded permissions, but not unlimited power. 
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Top"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
