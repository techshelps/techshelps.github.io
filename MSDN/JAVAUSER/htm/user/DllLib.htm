<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Class DllLib</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY BGCOLOR="White" TOPMARGIN=0 LEFTMARGIN=0 VLINK="#006699" ALINK="#006699">
<A NAME="top"></A>
<!--TOOLBAR_START-->
<!--TOOLBAR_END-->

<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH="98%">
<TR>
<TD ROWSPAN=2 WIDTH=114 ALIGN="LEFT" VALIGN="TOP">
<IMG SRC="art/title_x3.gif" WIDTH="112" HEIGHT="108"  BORDER=0 ALT="Packages"><TABLE CELLPADDING=0 CELLSPACING=0 BORDER=0 WIDTH="100%">
<TR><TD WIDTH=10>&nbsp;</TD><TD VALIGN="top"><FONT FACE="Verdana,Arial,Helvetica" SIZE=1><B STYLE="color:#006699">In this topic</B><P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="DllLib.htm#com_0003000703010000">Methods</A>
<P><IMG SRC="art/linkbull.gif" WIDTH="10" HEIGHT="8"  BORDER=0 ALT="*"><A STYLE="color: #333366;text-decoration:none" HREF="DllLib.htm#com_0003000703020000">Fields</A>
</FONT></TD></TR></TABLE>
</TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">
<P>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0">
<TR>
<TD WIDTH="355" VALIGN="bottom"><IMG SRC="art/package2.gif" WIDTH="355" HEIGHT="27"  BORDER=0 ALT="Packages"></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="bottom"><A HREF="Callback.htm"><IMG SRC="art/prevnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Previous"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="def_pdll.htm"><IMG SRC="art/pkgnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="This Package"></A></TD><TD ALIGN="center" VALIGN="bottom"><A HREF="ParameterCountMismatchError.htm"><IMG SRC="art/nextnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="Next"></A></TD></TR>
<TR>
<TD WIDTH="355" ALIGN="right" VALIGN="top"><FONT COLOR="#006699" SIZE="4" FACE="VERDANA,ARIAL,HELVETICA"><B>Package com.ms.dll</B></FONT></TD>
<TD WIDTH=20>&nbsp;</TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Previous</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">This<BR>Package</FONT></TD>
<TD ALIGN="center" VALIGN="top"><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1">Next</FONT></TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD WIDTH=20>&nbsp;</TD>
<TD>
<BR>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">
<BR><BR><H2 STYLE="color:#333366">Class DllLib</H2>
<PRE><FONT FACE="Courier" SIZE="2">public class DllLib
{
  // Fields
  public static final int <A HREF="DllLib.htm#com_0003000703020001">systemDefaultCharSize</A>;

  // Methods
  public static int <A HREF="DllLib.htm#com_0003000703010100">addrOf</A>(int root);
  public static int <A HREF="DllLib.htm#com_addrOfPinnedObject">addrOfPinnedObject</A>(int nHandleIndex);
  public static int <A HREF="DllLib.htm#com_0003000703010200">allocCoTaskMem</A>(int cb);
  public static int <A HREF="DllLib.htm#com_0003000703010300">allocHGlobal</A>(int cb);
  public static void <A HREF="DllLib.htm#com_0003000703010400">copy</A>(byte jasrc[], int elemidx, int pdst,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010500">copy</A>(char jasrc[], int elemidx, int pdst,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010600">copy</A>(short jasrc[], int elemidx, int pdst, int
        nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010700">copy</A>(int jasrc[], int elemidx, int pdst,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010800">copy</A>(long jasrc[], int elemidx, int pdst,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010900">copy</A>(float jasrc[], int elemidx, int pdst, int
        nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010a00">copy</A>(double jasrc[], int elemidx, int pdst,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010b00">copy</A>(Object jasrc, int ofs, int pdst, int cb);
  public static void <A HREF="DllLib.htm#com_0003000703010c00">copy</A>(int psrc, byte jadst[], int elemidx,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010d00">copy</A>(int psrc, char jadst[], int elemidx,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010e00">copy</A>(int psrc, short jadst[], int elemidx, int
        nelems);
  public static void <A HREF="DllLib.htm#com_0003000703010f00">copy</A>(int psrc, int jadst[], int elemidx,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703011000">copy</A>(int psrc, long jadst[], int elemidx,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703011100">copy</A>(int psrc, float jadst[], int elemidx, int
        nelems);
  public static void <A HREF="DllLib.htm#com_0003000703011200">copy</A>(int psrc, double jadst[], int elemidx,
        int nelems);
  public static void <A HREF="DllLib.htm#com_0003000703011300">copy</A>(int psrc, Object jadst, int ofs, int cb);
  public static void <A HREF="DllLib.htm#com_0003000703011400">freeCoTaskMem</A>(int ptr);
  public static void <A HREF="DllLib.htm#com_0003000703011500">freeHGlobal</A>(int hglobal);
  public static final int <A HREF="DllLib.htm#com_0003000703011600">getLastWin32Error</A>();
  public static void <A HREF="DllLib.htm#com_freePinnedHandle">freePinnedHandle</A>(int nHandleIndex);
  public static int <A HREF="DllLib.htm#com_getPinnedHandle">getPinnedHandle</A>(Object obj);
  public static Object <A HREF="DllLib.htm#com_getPinnedObject">getPinnedObject</A>(int nHandleIndex);
  public static boolean <A HREF="DllLib.htm#com_0003000703011700">isStruct</A>(Class structCls);
  public native static boolean <A HREF="DllLib.htm#com_0003000703011800">isStruct</A>(Field structField);
  public static int <A HREF="DllLib.htm#com_0003000703011900">numParamBytes</A>(Method m);
  public native static int <A HREF="DllLib.htm#com_0003000703011a00">offsetOf</A>(Field structField);
  public static int <A HREF="DllLib.htm#com_0003000703011b00">offsetOf</A>(Class structCls,
        String fieldName) throws SecurityException;
  public static native void <A HREF="DllLib.htm#com_0003000703011c00">prelink</A>(Method method);
  public static native void <A HREF="DllLib.htm#com_0003000703014800">propagateStructFields</A>(Object structObj, boolean fromNative);
  public static void <A HREF="DllLib.htm#com_0003000703011d00">prelinkAll</A>(Class cls);
  public static String <A HREF="DllLib.htm#com_0003000703011e00">ptrToString</A>(int ptr);
  public static String <A HREF="DllLib.htm#com_0003000703011f00">ptrToStringAnsi</A>(int ptr);
  public static String <A HREF="DllLib.htm#com_0003000703012000">ptrToStringUni</A>(int ptr);
  public static Object <A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A>(Class structClass, int ptr);
  public static native byte <A HREF="DllLib.htm#com_0003000703012200">read1</A>(Object ptr, int ofs);
  public static native byte <A HREF="DllLib.htm#com_0003000703012300">read1</A>(int ptr, int ofs);
  public static byte <A HREF="DllLib.htm#com_0003000703012400">read1</A>(int ptr);
  public static native short <A HREF="DllLib.htm#com_0003000703012500">read2</A>(Object ptr, int ofs);
  public static native short <A HREF="DllLib.htm#com_0003000703012600">read2</A>(int ptr, int ofs);
  public static short <A HREF="DllLib.htm#com_0003000703012700">read2</A>(int ptr);
  public static native int <A HREF="DllLib.htm#com_0003000703012800">read4</A>(Object ptr, int ofs);
  public static native int <A HREF="DllLib.htm#com_0003000703012900">read4</A>(int ptr, int ofs);
  public static int <A HREF="DllLib.htm#com_0003000703012a00">read4</A>(int ptr);
  public static native long <A HREF="DllLib.htm#com_0003000703012b00">read8</A>(Object ptr, int ofs);
  public static native long <A HREF="DllLib.htm#com_0003000703012c00">read8</A>(int ptr, int ofs);
  public static long <A HREF="DllLib.htm#com_0003000703012d00">read8</A>(int ptr);
  public static native void <A HREF="DllLib.htm#com_0003000703012e00">release</A>(Object o);
  public native static void <A HREF="DllLib.htm#com_0003000703012f00">resize</A>(Object structObj, int newsize);
  public static int <A HREF="DllLib.htm#com_0003000703013000">sizeOf</A>(Class structCls);
  public native static int <A HREF="DllLib.htm#com_0003000703013100">sizeOf</A>(Object structObj);
  public static int <A HREF="DllLib.htm#com_0003000703013200">stringToCoTaskMem</A>(String s);
  public static int <A HREF="DllLib.htm#com_0003000703013300">stringToCoTaskMemAnsi</A>(String s);
  public static int <A HREF="DllLib.htm#com_0003000703013400">stringToCoTaskMemUni</A>(String s);
  public static int <A HREF="DllLib.htm#com_0003000703013500">stringToHGlobal</A>(String s);
  public static int <A HREF="DllLib.htm#com_0003000703013600">stringToHGlobalAnsi</A>(String s);
  public static int <A HREF="DllLib.htm#com_0003000703013700">stringToHGlobalUni</A>(String s);
  public static final void <A HREF="DllLib.htm#com_0003000703013800">throwWin32Exception</A>();
  public static native void <A HREF="DllLib.htm#com_0003000703013900">write1</A>(Object ptr, int ofs, byte val);
  public static native void <A HREF="DllLib.htm#com_0003000703013a00">write1</A>(int ptr, int ofs, byte val);
  public static void <A HREF="DllLib.htm#com_0003000703013b00">write1</A>(int ptr, byte val);
  public static native void <A HREF="DllLib.htm#com_0003000703013c00">write2</A>(Object ptr, int ofs, short val);
  public static native void <A HREF="DllLib.htm#com_0003000703013d00">write2</A>(int ptr, int ofs, short val);
  public static void <A HREF="DllLib.htm#com_0003000703013e00">write2</A>(int ptr, short val);
  public static native void <A HREF="DllLib.htm#com_0003000703013f00">write2</A>(Object ptr, int ofs, char val);
  public static native void <A HREF="DllLib.htm#com_0003000703014000">write2</A>(int ptr, int ofs, char val);
  public static void <A HREF="DllLib.htm#com_0003000703014100">write2</A>(int ptr, char val);
  public static native void <A HREF="DllLib.htm#com_0003000703014200">write4</A>(Object ptr, int ofs, int val);
  public static native void <A HREF="DllLib.htm#com_0003000703014300">write4</A>(int ptr, int ofs, int val);
  public static void <A HREF="DllLib.htm#com_0003000703014400">write4</A>(int ptr, int val);
  public static native void <A HREF="DllLib.htm#com_0003000703014500">write8</A>(Object ptr, int ofs, long val);
  public static native void <A HREF="DllLib.htm#com_0003000703014600">write8</A>(int ptr, int ofs, long val);
  public static void <A HREF="DllLib.htm#com_0003000703014700">write8</A>(int ptr, long val);
}
</FONT></PRE>
<P>This class contains methods for linking to dynamic-link libraries (DLLs). All methods in the <B>DllLib</B> class are static; therefore, you do not need to instantiate this class to use its methods. The methods and fields of the <B>DllLib</B> class provide support for Microsoft&#174; J/Direct&#153; technology. 
<P>J/Direct allows you to specify the <I>auto</I> modifier with the <B>@dll.import</B> directive to call the optimal version of a DLL function, depending on the platform you are using. To find out what version is optimal for your platform, you can examine the <A HREF="DllLib.htm#com_0003000703020001">systemDefaultCharSize</A> field. This field is set to 1 for ANSI system, and 2 for Unicode systems. 
<P>There are several DllLib methods that help you read and write from raw pointers returned by DLL functions. You can use the <A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A> method, which casts a raw pointer to a structure, to cast the raw pointer to a reference to a class declared with <B>@dll.struct</B>. For an example that illustrates this technique, see the <A HREF="Marshaling.htm#jdirect_0007000203080200">Raw Pointers</A> section of the J/Direct article. 
<P>There are other situations where the <A HREF="DllLib.htm#com_0003000703012100">ptrToStruct</A> method can be helpful. Since there is no direct support for pointers inside structures, you could represent a structure with an embedded pointer by declaring the pointer field as type int and calling DLL functions to allocate the memory. Then you can call <B>ptrToStruct</B> to map the memory blocks onto <B>@dll.struct</B> classes so that you can initialize the blocks. 
<P>The DllLib methods, <A HREF="DllLib.htm#com_0003000703011f00">ptrToStringAnsi</A>, <A HREF="DllLib.htm#com_0003000703012000">ptrToStringUni</A>, and <A HREF="DllLib.htm#com_0003000703011e00">ptrToString</A>, are used to convert a string to a <B>java.lang.String</B> object when you want to treat a raw pointer as a pointer to a string. The following example shows how you can interpret a raw pointer as a pointer to a Unicode string. 
<PRE><FONT FACE="Courier" SIZE="2">
import com.ms.dll.*;

int rawPtr = ...;  // value of rawPtr is returned by a DLL function
String s = DllLib.ptrToStringUni(rawPtr);
</FONT></PRE>
<P>The <A HREF="DllLib.htm#com_0003000703010100">addrOf</A> method can be used to get the address of a callback. For instance, when you want to embed a callback inside a structure, you would call the <A HREF="Root.htm#com_0003000705010100">com.ms.dll.Root.alloc</A> method to wrap the <A HREF="Callback.htm">Callback</A> in a root handle. Next, you would pass the root handle to the <B>addrOf</B> method to obtain native address of the callback. Then, you can store the address as an integer. 
<P>The <A HREF="DllLib.htm#com_0003000703011600">getLastWin32Error</A> method helps you obtain the error code set by a DLL function. For an example that shows how to do this, see the <A HREF="ErrorCode.htm#jdirect_0007000209000000">Error Code</A> section of the J/Direct article. 
<P>The copy methods in <B>DllLib</B> allow you to copy data between various types of Java arrays and raw pointers. You could use these methods to read or write data from raw pointers returned by DLL functions. 

<H3 STYLE="color:#333366"><A NAME="com_0003000703010000">Methods</A></H3>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010100">addrOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int addrOf(int root);
</FONT></PRE>
<P><P>Returns the address of a native structure wrapped by an <B>@dll.struct</B> object. 
<P><B>Note</B>  To use this method, you must first call the <A HREF="Root.htm#com_0003000705010100">Root.alloc</A> method to wrap the object in a root handle. Then, pass the root handle to the <B>addrOf</B> method. This extra step is required because of the garbage-collected nature of Java. (If the <B>addrOf</B> method took an object directly, there would be nothing to prevent the object from being reclaimed by garbage collection before the returned address could be used.) 
<P><B>Return Value:</B> <P>Returns the address of the native structure. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>root</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A root handle obtained by calling <A HREF="Root.htm#com_0003000705010100">Root.alloc</A>. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>SecurityException</B>
 if called by an untrusted applet. 


</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_addrOfPinnedObject">addrOfPinnedObject</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int addrOfPinnedObject(int nHandleIndex);
</FONT></PRE>

<P><P>Returns the address of the object's data while an object is pinned.

<P>While an address is pinned, it will not be reclaimed by the garbage collector
and will not move in memory. You must specifically free this handle by 
calling <A HREF="DllLib.htm#com_freePinnedHandle">freePinnedHandle</A>.
For performance reasons, objects should not be pinned for long periods of time.
Generally, you will pin an array during some native I/O operation, 
and then unpin it.
<P><B>Note</B> Only single-dimension arrays of primitive types can be pinned.

<P><B>Return Value:</B> <P>Returns the address of the of the object that is encapsulated by the given pinned handle. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nHandleIndex</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A pinned handle that is obtained by calling <A href="DllLib.htm#com_getPinnedHandle">getPinnedHandle</A>. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_0003000703010200">allocCoTaskMem</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int allocCoTaskMem(int cb);
</FONT></PRE>
<P><P>Allocates a native memory block by invoking the Win32 function <B>CoTaskMemAlloc</B>. 

<P><B>Return Value:</B> <P>Returns a pointer to the allocated block. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The required size of the memory block (in bytes). 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>OutOfMemoryError</B>
 if allocation fails. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010300">allocHGlobal</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int allocHGlobal(int cb);
</FONT></PRE>
<P><P>Allocates a native memory block using <B>GlobalAlloc</B> (GMEM_FIXED). 

<P><B>Return Value:</B> <P>Returns a pointer to the allocated block. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The required size of the memory block (in bytes). 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>OutOfMemoryError</B>
 if allocation fails. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010400">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(byte jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies a number of bytes from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy bytes from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first byte to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of bytes to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010500">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(char jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies a number of characters from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the characters from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first character to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of characters to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010600">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(short jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies a number of short integers from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the short integers from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first short integer to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of short integers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010700">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies a number of integers from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the integers from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first integer to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of integers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010800">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(long jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies a number of long integers from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the long integers from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first long integer to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of long integers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010900">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(float jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies 32-bit floating-point numbers from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the floating-point numbers from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first floating-point number to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of floating-point numbers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010a00">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(double jasrc[], int elemidx, int pdst, int nelems);
</FONT></PRE>
<P><P>Copies 64-bit floating-point numbers (doubles) from a Java array to the destination indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the doubles from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first double to be copied is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of doubles to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010b00">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(Object jasrc, int ofs, int pdst, int cb);
</FONT></PRE>
<P><P>Copies a native structure to the destination indicated by a raw native pointer. The Java object that represents the native structure must have been declared using the <B>@dll.struct</B> compiler directive. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jasrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The native structure to copy from. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates where in the object the first byte to copy is located. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>pdst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the destination of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of bytes to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010c00">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, byte jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies a number of bytes to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the bytes to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first byte is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of bytes to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010d00">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, char jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies a number of characters to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the characters to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first character is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of characters to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010e00">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, short jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies a number of short integers to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the short integers to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first short integer is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of short integers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703010f00">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, int jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies a number of integers to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the integers to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first integer is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of integers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011000">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, long jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies a number of long integers to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the long integers to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first long integer is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of long integers to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011100">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, float jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies 32-bit floating-point numbers to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the floats to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first floating-point number is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of floats to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011200">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, double jadst[], int elemidx, int nelems);
</FONT></PRE>
<P><P>Copies 64-bit floating-point numbers (doubles) to a Java array from the source indicated by a raw native pointer. This copy method is range-checked. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The Java array to copy the doubles to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>elemidx</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the Java array where the first double is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nelems</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of doubles to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011300">copy</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void copy(int psrc, Object jadst, int ofs, int cb);
</FONT></PRE>
<P><P>Copies a number of bytes to a native structure from the source indicated by a raw native pointer. The Java object that represents the native structure must be declared using the <B>@dll.struct</B> compiler directive. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>psrc</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A raw pointer to the source of the copy. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>jadst</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The native structure to copy to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset that indicates the location in the object where the first byte is copied to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cb</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The number of bytes to copy. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011400">freeCoTaskMem</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void freeCoTaskMem(int ptr);
</FONT></PRE>
<P><P>Frees a native memory block by invoking the Win32 function <B>CoTaskMemFree</B>. Any global memory handle that has a zero high-order word is safely ignored. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The memory block to free. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011500">freeHGlobal</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void freeHGlobal(int hglobal);
</FONT></PRE>
<P><P>Frees a native memory block by invoking the Win32 function <B>GlobalFree</B>. Any global memory handle that has a zero high-order word is safely ignored. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>hglobal</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The global memory handle to free. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_freePinnedHandle">freePinnedHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void freePinnedHandle(int nHandleIndex);
</FONT></PRE>
<P><P>Frees a previously-allocated pinned handle. This necessarily unpins 
the object (unless it has been pinned multiple times) and invalidates the 
address (if any) returned by addrOfPinnedHandle for this handle.

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>nHandleIndex</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The handle of the pinned object to free. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011600">getLastWin32Error</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static final int getLastWin32Error();
</FONT></PRE>
<P><P>Returns the Microsoft&#174; Win32&#174; error code set by the last DLL-imported method (declared with the <I>setLastError</I> modifier) invoked on the current thread. 
<P><B>Note</B>  Only DLL methods declared with the <I>setLastError</I> modifier can set error codes. 
<P><B>Return Value:</B> <P>Returns the last saved Win32 error code. 

</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_getPinnedHandle">getPinnedHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int getPinnedHandle(Object obj);
</FONT></PRE>
<P><P>Pins an object. After pinning an object, you can legally call 
addrOfPinnedObject to obtain the address of the object's data. While an 
object is pinned, it will not be reclaimed by the garbage collector and will not move in 
memory. 
<P>You must specifically free this handle via freePinnedHandle.
For performance reasons, objects should not be pinned for long periods of 
time. Generally, you will pin an array during some native I/O operation, 
and then unpin it. 
<P><B>Note</B> Only single-dimension arrays of primitive types can be pinned.


<P><B>Return Value:</B> <P>Returns a handle to the pinned object. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object to be pinned. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_getPinnedHandle">getPinnedHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int getPinnedHandle(Object obj);
</FONT></PRE>
<P><P>Pins an object.  After pinning an object, you can legally call 
addrOfPinnedObject() to obtain the address of the object's data. While an 
object is pinned, it will not be reclaimed by the GC and will not move in 
memory. 
<P>You must specifically free this handle via freePinnedHandle().
For performance reasons, objects should not be pinned for long amounts of 
time. Generally, you will pin an array during some native I/O operation, 
and then unpin it. 
<P><B>Note</B> Only single-dimension arrays of primitive type may be pinned.


<P><B>Return Value:</B> <P>Returns a handle to the pinned object. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object to be pinned. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_getPinnedHandle">getPinnedHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int getPinnedHandle(Object obj);
</FONT></PRE>
<P><P>Pins an object.  After pinning an object, you can legally call 
addrOfPinnedObject() to obtain the address of the object's data. While an 
object is pinned, it will not be reclaimed by the GC and will not move in 
memory. 
<P>You must specifically free this handle via freePinnedHandle().
For performance reasons, objects should not be pinned for long amounts of 
time. Generally, you will pin an array during some native I/O operation, 
and then unpin it. 
<P><B>Note</B> Only single-dimension arrays of primitive type may be pinned.


<P><B>Return Value:</B> <P>Returns a handle to the pinned object. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object to be pinned. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_getPinnedHandle">getPinnedHandle</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int getPinnedHandle(Object obj);
</FONT></PRE>
<P><P>Pins an object, returning a handle.
<P>After pinning an object, you can legally call 
addrOfPinnedObject() to obtain the address of the object's data. While an 
object is pinned, it will not be reclaimed by the GC and will not move in 
memory. 
<P>You must specifically free this handle via freePinnedHandle().
For performance reasons, objects should not be pinned for long amounts of 
time. Generally, you will pin an array during some native I/O operation, 
and then unpin it. 
<P><B>Note</B> Only single-dimension arrays of primitive type may be pinned.


<P><B>Return Value:</B> <P>Returns a handle to the pinned object. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>obj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object to be pinned. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>


<H4 STYLE="color:#333366"><A NAME="com_getPinnedObject">getPinnedObject</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int getPinnedObject(int handle);
</FONT></PRE>
<P><P>Retrieves the object that is encapsulated by a pinned handle.

<P><B>Return Value:</B> <P>Returns the object that is encapsulated by a pinned handle. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>handle</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The pinned handle of the object. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_0003000703011700">isStruct</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static boolean isStruct(Class structCls);
</FONT></PRE>
<P><P>Determines whether a class represents a native structure. 

<P><B>Return Value:</B> <P>Returns true if the class represents a native structure; otherwise, returns false. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structCls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class to examine. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011800">isStruct</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native static boolean isStruct(Field structField);
</FONT></PRE>
<P><P>Determines whether a field represents a field in a native structure. 

<P><B>Return Value:</B> <P>Returns true if the field represents a field in a native structure; otherwise, returns false. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structField</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The field to examine. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011900">numParamBytes</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int numParamBytes(Method m);
</FONT></PRE>
<P><P>Prelinks the specified method and returns the number of bytes of memory required to store the method's parameters. 

<P><B>Return Value:</B> <P>Returns the number of bytes of memory required to store the method's parameters. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>m</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The method to be prelinked. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011a00">offsetOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native static int offsetOf(Field structField);
</FONT></PRE>
<P><P>Returns the offset (measured in bytes) of a member of a native structure. The class, which is represented by <I>structField</I>.<B>getClass</B>, must have been declared using the <B>@dll.struct</B> compiler directive (or <B>@com.struct</B>). 
<P><B>Note</B>  The <B>getClass</B> method is from the <B>java.lang.Object</B> class. 
<P><B>Return Value:</B> <P>Returns the size of the native structure (in bytes). 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structField</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The field to obtain the offset of. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011b00">offsetOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int offsetOf(Class structCls, String fieldName)
        throws SecurityException;
</FONT></PRE>
<P><P>Returns the offset (measured in bytes) of a member of a native structure. The class, which is represented by <I>structCls</I>, must have been declared using the <B>@dll.struct</B> compiler directive (or <B>@com.struct</B>). 

<P><B>Return Value:</B> <P>Returns the size of the native structure in bytes. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structCls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class declared by using <B>@dll.struct</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>fieldName</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The name of the field to examine. 

</FONT></TD></TR></TABLE>
<P><B>Exceptions:</B> <P><B>SecurityException</B>
 if the caller lacks permissions to use the <B>java.lang.reflect</B> API. 


</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011c00">prelink</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void prelink(Method method);
</FONT></PRE>
<P><P>Preloads the native library and performs a type analysis on an <B>@dll.import</B> method to ensure that the types are compatible with DLL calling. If this method is called multiple times on the same method (or on a method that does not link to a DLL), the call is safely ignored. 
<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>method</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The method to prelink. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>This work is normally performed on the first call to the <B>@dll.import</B> method. The <B>prelink</B> method can be used to force the type analysis to be done before the first call to the <B>@dll.import</B> method. This can help with performance tuning, debugging, or both. 
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011d00">prelinkAll</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void prelinkAll(Class cls);
</FONT></PRE>
<P><P>Calls the <A HREF="DllLib.htm#com_0003000703011c00">prelink</A> method on all methods of a class. This method is provided primarily for debugging purposes because it can expose errors in DLL-linked methods. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>cls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class to prelink. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014800">propagateStructFields</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void propagateStructFields(Object structObj, boolean fromNative);
</FONT></PRE>
<P><P>Propagates the fields from the native memory block to the Java object or from the Java object to the native memory block. The contents of some complex field types, such as arrays, are cached in GC memory, so writes or reads of these fields do not access the native memory block. By calling this method, the contents of the native memory block and the Java object are synchronized. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structObj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object declared using @dll.struct.  


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>fromNative</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The direction in which to propagate the fields.  

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_0003000703011e00">ptrToString</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static String ptrToString(int ptr);
</FONT></PRE>
<P><P>Converts a native string to a <B>java.lang.String</B> object. The native string is assumed to be in ANSI format if the auto mode is ANSI; otherwise, Unicode format is assumed. A string that has the high-order word set to zero is allowed and is converted to null. 

<P><B>Return Value:</B> <P>Returns the Java string that represents the native string. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The native string to convert. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703011f00">ptrToStringAnsi</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static String ptrToStringAnsi(int ptr);
</FONT></PRE>
<P><P>Converts a native string in ANSI format to a <B>java.lang.String</B> object. A string that has the high-order word set to zero is legal and is converted to null. 

<P><B>Return Value:</B> <P>Returns the Java string that represents the native string. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string pointer to convert. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012000">ptrToStringUni</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static String ptrToStringUni(int ptr);
</FONT></PRE>
<P><P>Converts a native string in Unicode format to a <B>java.lang.String</B> object. A string that has the high-order word set to zero is legal and is converted to null. 

<P><B>Return Value:</B> <P>Returns the Java string that represents the native string. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string pointer to convert. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012100">ptrToStruct</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static Object ptrToStruct(Class structClass, int ptr);
</FONT></PRE>
<P><P>Maps a raw pointer onto a structure. This method simulates a C-style cast of an arbitrary pointer to a structure. 

<P><B>Return Value:</B> <P>Returns an instance of <B>structClass</B>. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structClass</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The structure to map the raw pointer to. This class must have been declared using <B>@dll.struct</B>. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The raw pointer to be mapped. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012200">read1</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native byte read1(Object ptr, int ofs);
</FONT></PRE>
<P><P>Reads one byte of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the byte that is read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012300">read1</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native byte read1(int ptr, int ofs);
</FONT></PRE>
<P><P>Reads one byte of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the byte that is read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012400">read1</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static byte read1(int ptr);
</FONT></PRE>
<P><P>Reads a byte from a specified memory location. 

<P><B>Return Value:</B> <P>Returns the byte that is read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the byte to be read is located. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012500">read2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native short read2(Object ptr, int ofs);
</FONT></PRE>
<P><P>Reads two bytes of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the bytes that are read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012600">read2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native short read2(int ptr, int ofs);
</FONT></PRE>
<P><P>Reads two bytes of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the bytes that are read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012700">read2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static short read2(int ptr);
</FONT></PRE>
<P><P>Reads a short integer from a specified memory location. 

<P><B>Return Value:</B> <P>Returns the short integer that is read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the short integer to be read is located. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012800">read4</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native int read4(Object ptr, int ofs);
</FONT></PRE>
<P><P>Reads four bytes of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the bytes that are read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012900">read4</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native int read4(int ptr, int ofs);
</FONT></PRE>
<P><P>Reads four bytes of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the bytes that are read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012a00">read4</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int read4(int ptr);
</FONT></PRE>
<P><P>Reads an integer from a specified memory location. 

<P><B>Return Value:</B> <P>Returns the integer that is read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the integer to be read is located. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012b00">read8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native long read8(Object ptr, int ofs);
</FONT></PRE>
<P><P>Reads eight bytes of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the bytes that are read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012c00">read8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native long read8(int ptr, int ofs);
</FONT></PRE>
<P><P>Reads eight bytes of data from the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>Returns the bytes that are read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012d00">read8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static long read8(int ptr);
</FONT></PRE>
<P><P>Reads a long integer from a specified memory location. 

<P><B>Return Value:</B> <P>Returns the long integer that is read. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the long integer to be read is located. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012e00">release</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void release(Object o);
</FONT></PRE>
<P><P>This method frees the native memory associated with an object declared using the <B>@dll.struct</B> compiler directive, if that memory would normally have been released by garbage collection. If the object is not declared using <B>@dll.struct</B>, or if the native memory associated with the object is not owned by the garbage-collector, this method does nothing. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>o</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object to be freed. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703012f00">resize</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native static void resize(Object structObj, int newsize);
</FONT></PRE>
<P><P>Reallocates the native memory block represented by an object declared using the <B>@dll.struct</B> directive. The object must have been created by executing "new" from Java (as opposed to being created to wrap an external pointer). The new block will preserve the contents of the old block as much as possible. If the new block is larger than the old block, the remaining portion will be zero-initialized. 
<P>This method is normally invoked from a constructor and can be used to implement structures that vary in size. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structObj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The structure to resize. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>newsize</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The new size (in bytes). 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013000">sizeOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int sizeOf(Class structCls);
</FONT></PRE>
<P><P>Returns the size in bytes of the native structure represented by the specified class. The class must have been declared using the <B>@dll.struct</B> compiler directive (or <B>@com.struct</B>). 

<P><B>Return Value:</B> <P>Returns the size of the native structure (in bytes). 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structCls</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The class to examine. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013100">sizeOf</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public native static int sizeOf(Object structObj);
</FONT></PRE>
<P><P>Returns the size in bytes of an instance of a J/Direct structure. You can use this method to declare a self-describing structure that will be used in a DLL call, as in the following example. 
<PRE><FONT FACE="Courier" SIZE="2">
/** @dll.struct() &#042;/
class STARTUPINFO
{
  public int cb = DllLib.sizeOf(this);
  public int lpReserved;
  public int lpDesktop;
  ...
}

// now you can use an instance of STARTUPINFO in a DLL call
</FONT></PRE>
<P><B>Return Value:</B> <P>Returns the size of the object. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>structObj</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The object whose size is being determined. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013200">stringToCoTaskMem</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int stringToCoTaskMem(String s);
</FONT></PRE>
<P><P>Copies a string into a native memory block by using either ANSI or Unicode format depending on the auto mode setting. The memory block is allocated by using the Win32 function <B>CoTaskMemAlloc</B>. 
<P><B>Return Value:</B> <P>Returns a pointer to the block that contains the string in the specified format. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string to copy. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <A HREF="DllLib.htm#com_0003000703011400">freeCoTaskMem</A> method to release the block from Java. 

<p><B>Important Note:</B> <P>On Windows NT, if you use the <A HREF="DllLib.htm#com_0003000703013200">stringToCoTaskMem</A> method with the <B>Comctl32.ListView_InsertColumn</B> function, you may not get the results you expect. Instead, you should use the <A HREF="DllLib.htm#com_0003000703013300">stringToCoTaskMemAnsi</A> method as shown in the following example.
<PRE><FONT FACE="Courier" SIZE="2">lvc1.pszText = DllLib.stringToCoTaskMemAnsi("C Column"); // Notice the Ansi suffix 
int1 = Comctl32.ListView_InsertColumn(hWindLV1, 1, lvc1); 
</FONT></PRE>

</BLOCKQUOTE>

<H4 STYLE="color:#333366"><A NAME="com_0003000703013300">stringToCoTaskMemAnsi</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int stringToCoTaskMemAnsi(String s);
</FONT></PRE>
<P><P>Copies a string into a native memory block in ANSI format. The memory block is allocated by using the Win32 function <B>CoTaskMemAlloc</B>. 
<P><B>Return Value:</B> <P>Returns a pointer to the block that contains the specified string in ANSI format. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string to copy. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <A HREF="DllLib.htm#com_0003000703011400">freeCoTaskMem</A> method to release the block from Java. 
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013400">stringToCoTaskMemUni</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int stringToCoTaskMemUni(String s);
</FONT></PRE>
<P><P>Copies a string into a native memory block in Unicode format. The memory block is allocated by using the Win32 function <B>CoTaskMemAlloc</B>. 
<P><B>Return Value:</B> <P>Returns a pointer to the block that contains the specified string in Unicode format. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string to copy. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <A HREF="DllLib.htm#com_0003000703011400">freeCoTaskMem</A> method to release the block from Java. 
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013500">stringToHGlobal</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int stringToHGlobal(String s);
</FONT></PRE>
<P><P>Copies a string into a native memory block, using either ANSI or Unicode format, depending on the auto mode setting. The memory block is allocated by using <B>GlobalAlloc</B> (GMEM_FIXED). 
<P><B>Return Value:</B> <P>Returns a pointer to the block that contains the specified string. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string to copy. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <A HREF="DllLib.htm#com_0003000703011500">freeHGlobal</A> method to release the block from Java. 
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013600">stringToHGlobalAnsi</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int stringToHGlobalAnsi(String s);
</FONT></PRE>
<P><P>Copies a string into a native memory block in ANSI format. The memory block is allocated by using <B>GlobalAlloc</B> (GMEM_FIXED). 

<P><B>Return Value:</B> <P>Returns a pointer to the block that contains the specified string in ANSI format. 
<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string to copy. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <A HREF="DllLib.htm#com_0003000703011500">freeHGlobal</A> method to release the block from Java. 
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013700">stringToHGlobalUni</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static int stringToHGlobalUni(String s);
</FONT></PRE>
<P><P>Copies a string into a native memory block in Unicode format. The memory block is allocated by using <B>GlobalAlloc</B> (GMEM_FIXED). 
<P><B>Return Value:</B> <P>Returns a pointer to the block that contains the specified string in Unicode format. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>s</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The string to copy. 

</FONT></TD></TR></TABLE>
<P><B>Remarks:</B> <P>You can use the <A HREF="DllLib.htm#com_0003000703011500">freeHGlobal</A> method to release the block from Java. 
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013800">throwWin32Exception</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static final void throwWin32Exception();
</FONT></PRE>
<P><P>Throws a <A HREF="Win32Exception.htm">Win32Exception</A> using the error code set by the last DLL-imported method (declared with the <I>setLastError</I> modifier) that is invoked on the current thread. 
<P><B>Note</B>  Only DLL methods declared with the <I>setLastError</I> modifier can set error codes. 
<P><B>Return Value:</B> <P>No return value. 

</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013900">write1</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write1(Object ptr, int ofs, byte val);
</FONT></PRE>
<P><P>Writes one byte of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013a00">write1</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write1(int ptr, int ofs, byte val);
</FONT></PRE>
<P><P>Writes one byte of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013b00">write1</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void write1(int ptr, byte val);
</FONT></PRE>
<P><P>Writes a byte to the specified memory location. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the byte will be written. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013c00">write2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write2(Object ptr, int ofs, short val);
</FONT></PRE>
<P><P>Writes two bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013d00">write2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write2(int ptr, int ofs, short val);
</FONT></PRE>
<P><P>Writes two bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013e00">write2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void write2(int ptr, short val);
</FONT></PRE>
<P><P>Writes a short integer to the specified memory location. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the short integer will be written. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703013f00">write2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write2(Object ptr, int ofs, char val);
</FONT></PRE>
<P><P>Writes two bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014000">write2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write2(int ptr, int ofs, char val);
</FONT></PRE>
<P><P>Writes two bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014100">write2</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void write2(int ptr, char val);
</FONT></PRE>
<P><P>Writes a character to the specified memory location. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the character will be written. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014200">write4</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write4(Object ptr, int ofs, int val);
</FONT></PRE>
<P><P>Writes four bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014300">write4</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write4(int ptr, int ofs, int val);
</FONT></PRE>
<P><P>Writes four bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014400">write4</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void write4(int ptr, int val);
</FONT></PRE>
<P><P>Writes an integer to the specified memory location. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the integer will be written. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014500">write8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write8(Object ptr, int ofs, long val);
</FONT></PRE>
<P><P>Writes eight bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014600">write8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static native void write8(int ptr, int ofs, long val);
</FONT></PRE>
<P><P>Writes eight bytes of data to the memory location that is specified by a base address and an offset. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The base address to write to. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ofs</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The offset from the base address. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H4 STYLE="color:#333366"><A NAME="com_0003000703014700">write8</A></H4><BLOCKQUOTE>
<PRE><FONT FACE="Courier" SIZE="2">public static void write8(int ptr, long val);
</FONT></PRE>
<P><P>Writes a long integer to the specified memory location. 

<P><B>Return Value:</B> <P>No return value. 

<P><TABLE WIDTH=87% BORDER=1 CELLPADDING=5 CELLSPACING=0>
<TR VALIGN=TOP BGCOLOR="#DDDDDD">
<TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Parameter</B></FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><B>Description</B></FONT></TD></TR>
<TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>ptr</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The address in memory where the long integer will be written. 


</FONT></TD></TR><TR VALIGN=TOP><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE=2><I>val</I>
 </FONT></TD><TD><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The value to write. 

</FONT></TD></TR></TABLE>
</BLOCKQUOTE>
<H3 STYLE="color:#333366"><A NAME="com_0003000703020000">Fields</A></H3><DL>
<DT><B><A NAME="com_0003000703020001">systemDefaultCharSize</A></B>
</DT><DD>Contains the preferred character size of the host system (1 for ANSI, 2 for Unicode). The value of this class variable indicates the mode that a DLL-imported method will link in when the <I>auto</I> modifier is used with the <B>@dll.import</B> compiler directive. 

</DD></DL>
<P>
</FONT>
</TD>
</TR>
</TABLE>
<CENTER>
<P><TABLE WIDTH="95%"><TR><TD HEIGHT=1 BGCOLOR="RED"></TD></TR></TABLE>
<TABLE WIDTH="100%"><TR>
<TD ALIGN="left"><A HREF="#top"><IMG SRC="art/upnrm.gif" WIDTH="51" HEIGHT="38"  BORDER=0 ALT="upnrm.gif"></A></TD>
<TD ALIGN="right">
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><A HREF="cpyright.htm">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of use.</A></FONT></TD></TR></TABLE>
</CENTER>
</BODY></HTML>
