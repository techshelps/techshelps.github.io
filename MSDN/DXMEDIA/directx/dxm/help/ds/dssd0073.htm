<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Connection Model</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<META NAME="MS-HKWD" CONTENT="Connection Model">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY TOPMARGIN=0 LEFTMARGIN=0 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<A NAME="pagetop"></A><A NAME="connect"></A>

<OBJECT ID="DAControl" 
  STYLE="position:absolute; left:0; top:11;width:702;height:90"
  CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D">
</OBJECT>
<!--STYLE="width:702;height:110"-->
<SCRIPT LANGUAGE="JScript">
<!--
  // The DirectAnimation library
  m = DAControl.PixelLibrary;

  /* -- Insert your code here --*/ 

  mediaBase = "art\\";
  glowBase = m.importImage(mediaBase + "glow.gif");
  xImage = m.importImage(mediaBase + "newtransx.gif");
  xImage = xImage.Transform(m.Translate2(-303,0));
  //header1 = m.importImage(mediaBase + "header1.gif");
  //header1 = header1.Transform(m.Translate2(-301,0));

  //header2 = m.importImage(mediaBase + "hdrd3drm.gif");
  //header2 = header2.Transform(m.Translate2(-143,0));

  //header3 = m.importImage(mediaBase + "header3.gif");
  //header3 = header3.Transform(m.Translate2(157,-18));

  //background = m.Overlay(header1, m.Overlay( header2, header3));

  glowPath1 = m.Polyline( new Array( 295,26, 305,26, 305,50, 310,57, 519,57, 
    536,40, 536,17, 675,17, 675,23 ) );

  glowPath2 = m.PolyLine( new Array( 44,41, 44,25, 52,16, 84,16, 106,16 ) );

  glowPath3 = m.PolyLine( new Array( 57,55, 69,55, 78,65, 92,65, 99,58,
    99,82, 95,85, 95,93, 132,93, 132,78,
    303,78, 315,66, 549,66, 549,17, 675,17,
    675,23 ) );

  glowPath4 = m.PolyLine( new Array( 29,55, 19,55, 19,31, 38,30, 38,21,
    46,16, 106,16 ) );

  glowPath5 = m.PolyLine( new Array( 45,62, 45,81, 37,81, 41,85, 46,85,   
  51,91, 68,91, 66,81, 90,81, 90,65, 94,65, 105,47 ) );

  glow1 = glowBase.Transform( moveGlow( glowPath1, 5 ) );
  glow2 = glowBase.Transform( moveGlow( glowPath2, 2 ) );
  glow3 = glowBase.Transform( moveGlow( glowPath3, 8 ) );
  glow4 = glowBase.Transform( moveGlow( glowPath4, 2.5 ) );
  glow5 = glowBase.Transform( moveGlow( glowPath5, 2 ) );

  finalImg = m.Overlay(xImage, m.Overlay( glow5, m.Overlay( glow4, 
    m.Overlay( glow3, m.Overlay( glow2, glow1)))));


  // set the model, an image, as the model to be displayed
  DAControl.Image = finalImg;//m.Overlay(finalImg, background);
  // set the background in case of a non-windowless browser (like IE3)
  DAControl.BackgroundImage = m.SolidColorImage(m.Blue);     
     
  // start the animation       
  DAControl.Start()


  function moveGlow(path, speed)  {
    imDimX = 702;
    imDimY = 120;

    coordsXf = m.Translate2(-imDimX/2, -imDimY/2);
    path = path.Transform(coordsXf);
    return xf = m.FollowPath(path, speed).Repeat(1);
  }

//-->
</SCRIPT>
<TABLE BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="/directx/dxm/help/ds/art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Connection Model"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="/directx/dxm/help/ds/art/hdrdshow.gif" WIDTH="210" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- Connection Model"></TD><TD VALIGN="TOP" WIDTH="383"><IMG SRC="/directx/dxm/help/ds/art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="*">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="/directx/dxm/help/d3drm/art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR><TR><TD VALIGN="TOP"><PRE><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="/directx/dxm/help/ds/index.htm">Index</A>  <IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="/directx/dxm/help/ds/dssd0071.htm">Topic Contents</A>
</FONT></PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><FONT FACE="Verdana,Arial,Helvetica" SIZE="1"><IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="/directx/dxm/help/ds/dssd0072.htm">About Stream Architecture</A>
<IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="/directx/dxm/help/ds/dssd0074.htm">Plug-in Distributors</A>
</FONT></PRE></TD></TR></TABLE><BR CLEAR=ALL>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><BLOCKQUOTE STYLE="margin:15pt">
<H2>Connection Model</H2>
<BR CLEAR=ALL>
<P>This article provides an overview of the filter connection architecture in a Microsoft&#174; DirectShow&#153; filter graph by examining the behavior of the base classes that implement connection. Because filters connect to other filters using pins, the architecture describes pin connection. Consequently, the <A HREF="/directx/dxm/help/ds/dssd0208.htm#CBasePin">CBasePin</A>, <A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A>, and <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A> base classes and the <A HREF="/directx/dxm/help/ds/dssd0170.htm#IPin">IPin</A> interface are discussed. This article describes the connection process and the default functionality built into these classes.

<P><B>Contents of this article</B>:
<UL><LI><A CLASS=TCTOP HREF="/directx/dxm/help/ds/dssd0073.htm#connect_1">Connection Process</A>
<LI><A CLASS=TCTOP HREF="/directx/dxm/help/ds/dssd0073.htm#connect_2">How the Base Classes Implement Connection</A>
<UL><LI><A CLASS=TCTOP HREF="/directx/dxm/help/ds/dssd0073.htm#connect_3">The Filter Graph Manager Starts the Connection</A>
<LI><A CLASS=TCTOP HREF="/directx/dxm/help/ds/dssd0073.htm#connect_4">Negotiating Media Types with CBasePin::AgreeMediaType</A>
<LI><A CLASS=TCTOP HREF="/directx/dxm/help/ds/dssd0073.htm#connect_5">Determining a Media Type with CBasePin::TryMediaTypes</A>
</UL>
<LI><A CLASS=TCTOP HREF="/directx/dxm/help/ds/dssd0073.htm#connect_6">When a Reconnection Should Occur</A>
</UL>
<A NAME="connect_1"></A><P><B>Connection Process</B>
<P>When building a filter graph, the filter graph manager connects pins between filters. It also selects filters based on the media type in the file it has been given to render or selects a predetermined configuration for the filter graph it is assembling. The filter graph manager can be asked specifically to add a filter by using the <A HREF="/directx/dxm/help/ds/dssd0145.htm#AddFilter">IFilterGraph::AddFilter</A> method. The filter graph manager calls the <A HREF="/directx/dxm/help/ds/dssd0121.htm#JoinFilterGraph">IBaseFilter::JoinFilterGraph</A> method on the filter to notify it that it has joined the filter graph. The added filter can then be connected like any other filter. When connecting filters, the filter graph manager requests the filters to enumerate their pins and then, for each connection required, requests that an output pin connect to an input pin.

<P>The base classes handle much of the connection mechanism. However, it is important to understand the connection process when writing a filter so that you can identify what to override and what is expected of your filter. Before two connected filters are prepared to pass media between them, the following connection and negotiation processes must occur in this order.

<OL><LI>The initial pin connection occurs.
<LI>The output pin of one filter retrieves interfaces from the connected input pin.
<LI>Both pins negotiate for a common media type.
<LI>Both pins negotiate for an appropriate transport to pass the media.
</OL>
<P>In the first step, the filter graph manager informs the output pin of one filter to connect to a specified input pin of another filter. This results in an exchange of <A HREF="/directx/dxm/help/ds/dssd0170.htm#IPin">IPin</A> interface pointers. Filters should never connect to other filters by themselves. The filter graph manager must always be the agent that initiates a connection, because deadlocks can occur otherwise. A filter or an application can instruct the filter graph manager to connect two pins (through the <A HREF="/directx/dxm/help/ds/dssd0151.htm#Connect">IGraphBuilder::Connect</A> or <A HREF="/directx/dxm/help/ds/dssd0145.htm#ConnectDirect">IFilterGraph::ConnectDirect</A> method), or the filter graph manager can determine to connect filters when rendering a filter by using the <A HREF="/directx/dxm/help/ds/dssd0151.htm#Render">IGraphBuilder::Render</A> or <A HREF="/directx/dxm/help/ds/dssd0151.htm#RenderFile">IGraphBuilder::RenderFile</A> method.


<P>In the second step, the output pin may
 
request the <A HREF="/directx/dxm/help/ds/dssd0166.htm#IMemInputPin">IMemInputPin</A> interface from the connected input pin. This is in preparation for the fourth step, where the output pin will use <B>IMemInputPin</B> to retrieve a memory allocator from the input pin. If the output pin already has a memory allocator (or some other transport in the case of hardware filters), it can skip this step or can request some other interface in a proprietary design.

<P>In the third step, media types are tried until one is found that is acceptable to both pins or the pins run out of types to try (in which case the connection fails). First, the output pin asks the connected input pin to propose its list of media types. If none of these are acceptable to the output pin, the output pin proposes its own types.

<P>In the fourth step, the output pin asks the connected input pin for an allocator interface. The output pin then either accepts the allocator, or proposes its own allocator and notifies the input pin of the selection. The output pin makes the final determination. 

<A NAME="connect_2"></A><P><B>How the Base Classes Implement Connection</B>
<P>The <A HREF="/directx/dxm/help/ds/dssd0208.htm#CBasePin">CBasePin</A> class and its derived base classes, <A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A> and <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A>, implement most of the mechanism for the most common connection scenarios, much of which can be overridden by the derived filter class for more control of the process. 

<P>The connection procedure relies on the implementation of four interfaces:
<OL><LI><A HREF="/directx/dxm/help/ds/dssd0170.htm#IPin">IPin</A>, which is implemented by the <A HREF="/directx/dxm/help/ds/dssd0208.htm#CBasePin">CBasePin</A> class and inherited by the <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A> and 
<A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A> classes.

<LI><A HREF="/directx/dxm/help/ds/dssd0137.htm#IEnumMediaTypes">IEnumMediaTypes</A>, which is implemented by the <A HREF="/directx/dxm/help/ds/dssd0224.htm#CEnumMediaTypes">CEnumMediaTypes</A> class and passed out by the <A HREF="/directx/dxm/help/ds/dssd0170.htm#EnumMediaTypes">IPin::EnumMediaTypes</A> method. 
<LI><A HREF="/directx/dxm/help/ds/dssd0166.htm#IMemInputPin">IMemInputPin</A>, which is implemented by the <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A> class.
<LI><A HREF="/directx/dxm/help/ds/dssd0165.htm#IMemAllocator">IMemAllocator</A>, which is implemented by the <A HREF="/directx/dxm/help/ds/dssd0197.htm#CBaseAllocator">CBaseAllocator</A> class and passed out by the <A HREF="/directx/dxm/help/ds/dssd0166.htm#GetAllocator">IMemInputPin::GetAllocator</A> method.
</OL>
<P>The <A HREF="/directx/dxm/help/ds/dssd0166.htm#IMemInputPin">IMemInputPin</A> and <A HREF="/directx/dxm/help/ds/dssd0165.htm#IMemAllocator">IMemAllocator</A> interfaces are necessary only if the filter belonging to the connecting input pin (called the <I>downstream filter</I>) is expected to provide a shared memory allocator for transporting samples between the pins. 
However, the base class implementation in <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A> assumes this condition and implements <B>IMemInputPin</B> to provide an allocator object to a connected output pin that requests it.

<P>In the connection scenario of the default base class, the pin classes derived from <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A> and <A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A> need only to override and implement a few member functions and can let the base classes do the remaining work. Base classes 
derived from these classes, such as <A HREF="/directx/dxm/help/ds/dssd0258.htm#CTransformInputPin">CTransformInputPin</A> and <A HREF="/directx/dxm/help/ds/dssd0259.htm#CTransformOutputPin">CTransformOutputPin</A>, do much of the required implementation to provide a default connection scheme.

<P>Pin classes derived from <A HREF="/directx/dxm/help/ds/dssd0203.htm#CBaseInputPin">CBaseInputPin</A> and <A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A> need only to override the following member functions to enable pin connection.

<UL><LI><A HREF="/directx/dxm/help/ds/dssd0208.htm#CheckMediaType">CBasePin::CheckMediaType</A>, which is called for every media type proposed by the media type enumerator. The overriding member function must accept or reject the proposed media type.
<LI><A HREF="/directx/dxm/help/ds/dssd0208.htm#GetMediaType">CBasePin::GetMediaType</A>, which is called by the media type of the output pin enumerator to suggest media types already agreed on by the input pin for transform filters. This member function also presents the type of media a source filter will produce.
</UL>
<P>Additionally, the output pin derived from the <A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A> class must override the <A HREF="/directx/dxm/help/ds/dssd0207.htm#DecideBufferSize">CBaseOutputPin::DecideBufferSize</A> member function. This is called by the base classes to let the output pin inform any acquired allocator of the size and type of media samples that the output pin will provide. This is done by the output pin of the filter because the derived filter class should know the type and size of the data it will send to the input pin of the connected filter.

<P>To see the context of these overriding functions, it is helpful to step through the execution of the connection code in the class library. All connection takes place in the scope of one <A HREF="/directx/dxm/help/ds/dssd0208.htm#Connect">CBasePin::Connect</A> member function.

<A NAME="connect_3"></A><P><B>The Filter Graph Manager Starts the Connection</B>
<P>The connection starts when the filter graph manager calls the <A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">IPin::Connect</A> method on the output pin, passing it a pointer to the input pin to which it is connecting. The filter graph manager has previously retrieved pointers to the <A HREF="/directx/dxm/help/ds/dssd0170.htm#IPin">IPin</A> interfaces of both filters, for example, by calling the <A HREF="/directx/dxm/help/ds/dssd0121.htm#EnumPins">IBaseFilter::EnumPins</A> method on each connecting filter. The 
<A HREF="/directx/dxm/help/ds/dssd0121.htm#EnumPins">EnumPins</A> method creates a <A HREF="/directx/dxm/help/ds/dssd0225.htm#CEnumPins">CEnumPins</A> object to enumerate the pins, which the enumerator does by repeatedly calling the <A HREF="/directx/dxm/help/ds/dssd0202.htm#GetPin">CBaseFilter::GetPin</A> member function of the derived filter, which the derived filter must implement.

<P>The <A HREF="/directx/dxm/help/ds/dssd0208.htm#Connect">CBasePin::Connect</A> implementation of <A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">IPin::Connect</A> does much of the work in this case. It calls the following functions.
<UL><LI><A HREF="/directx/dxm/help/ds/dssd0207.htm#CheckConnect">CheckConnect</A>, which is overridden by <A HREF="/directx/dxm/help/ds/dssd0207.htm#CBaseOutputPin">CBaseOutputPin</A>.
<LI><A HREF="/directx/dxm/help/ds/dssd0208.htm#AgreeMediaType">AgreeMediaType</A>, which is implemented by <A HREF="/directx/dxm/help/ds/dssd0208.htm#CBasePin">CBasePin</A>.
</UL>
<P>The <A HREF="/directx/dxm/help/ds/dssd0208.htm#CheckConnect">CBasePin::CheckConnect</A> implementation simply determines that the pin directions are different. The overriding <A HREF="/directx/dxm/help/ds/dssd0207.htm#CheckConnect">CBaseOutputPin::CheckConnect</A> member function calls the <A HREF="/directx/dxm/help/ds/dssd0181.htm#QueryInterface">IUnknown::QueryInterface</A> method of the connected input pin to retrieve a pointer to the <A HREF="/directx/dxm/help/ds/dssd0166.htm#IMemInputPin">IMemInputPin</A> interface of that pin. This will be used later in the connection process to request an allocator from the connected input pin. (Your derived class can override <B>CBaseOutputPin::CheckConnect</B> and omit retrieving the 
<B>IMemInputPin</B> interface if the output pin already has an allocator; for example, it might want to use the allocator from an upstream filter to eliminate copying.)

<A NAME="connect_4"></A><P><B>Negotiating Media Types with CBasePin::AgreeMediaType</B>
<P>The <A HREF="/directx/dxm/help/ds/dssd0208.htm#AgreeMediaType">CBasePin::AgreeMediaType</A> member function is called next and attempts to negotiate a media type that both pins agree on. It does this by trying to find a media type presented by the connected input pin with which the output pin agrees. If that fails, 
it tries to find a media type preferred by the output pin that the connected input pin agrees with.

<P><A HREF="/directx/dxm/help/ds/dssd0208.htm#AgreeMediaType">CBasePin::AgreeMediaType</A> calls the following member functions and methods.
<UL><LI><A HREF="/directx/dxm/help/ds/dssd0170.htm#EnumMediaTypes">IPin::EnumMediaTypes</A> on the connected pin.
<LI><A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">CBasePin::TryMediaTypes</A> in the derived output pin class.
</UL>
<P>The <A HREF="/directx/dxm/help/ds/dssd0170.htm#EnumMediaTypes">IPin::EnumMediaTypes</A> method of the connected input pin is called to return a media type enumerator (<A HREF="/directx/dxm/help/ds/dssd0137.htm#IEnumMediaTypes">IEnumMediaTypes</A>). This allows the output pin to examine the list of preferred media types belonging to the input pin.

<P>The <A HREF="/directx/dxm/help/ds/dssd0137.htm#Next">IEnumMediaTypes::Next</A> method of the enumerator calls the <A HREF="/directx/dxm/help/ds/dssd0208.htm#GetMediaType">GetMediaType</A> member function of the derived input pin to retrieve each media type. If <B>GetMediaType</B> is not implemented, the base class implementation returns an error but this does not necessarily break the connection. (Pins are not required to have a preferred media type if one pin or the other can propose a type that they both accept. If neither pin can propose types, the connection will fail.)

<A NAME="connect_5"></A><P><B>Determining a Media Type with CBasePin::TryMediaTypes</B>
<P><A HREF="/directx/dxm/help/ds/dssd0208.htm#AgreeMediaType">CBasePin::AgreeMediaType</A> calls <A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">CBasePin::TryMediaTypes</A> next. The 
<A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">TryMediaTypes</A> member function cycles through the preferred media types of the connected input pin and calls the <A HREF="/directx/dxm/help/ds/dssd0208.htm#CheckMediaType">CBasePin::CheckMediaType</A> member function of the derived output pin class for each one it finds. 
<A HREF="/directx/dxm/help/ds/dssd0208.htm#CheckMediaType">CheckMediaType</A> must be implemented by your derived output pin class. If 
<B>CheckMediaType</B> accepts the media type, the <A HREF="/directx/dxm/help/ds/dssd0170.htm#ReceiveConnection">IPin::ReceiveConnection</A> method of the connected input pin is called with the media type to determine if the connected input pin accepts this media type. If so, 
<B>TryMediaTypes</B> calls the <A HREF="/directx/dxm/help/ds/dssd0207.htm#CompleteConnect">CBaseOutputPin::CompleteConnect</A> member function to finish the connection to the input pin. 

<P>If the input pin has no media types that the output type can use, <A HREF="/directx/dxm/help/ds/dssd0208.htm#AgreeMediaType">CBasePin::AgreeMediaType</A> repeats the entire process, using the enumerator for the media types of the output pin. (That is, it gets its own enumerator and calls 
<A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">TryMediaTypes</A> with each of its preferred media types.) Again, the enumerator calls 
<A HREF="/directx/dxm/help/ds/dssd0208.htm#GetMediaType">GetMediaType</A> for each media type in the list. In this case, 
<B>GetMediaType</B> should be implemented to provide a media type. If the filter is a source filter, it will have a definite media type to export. If the filter is a transform filter, the media type will be established between the filter's input pin and its connected pin; the transform filter should query for that media type or simply use the enumerator of the upstream filter (unless the transform filter changes the media type from input pin to output pin).

<P><A HREF="/directx/dxm/help/ds/dssd0208.htm#CheckMediaType">CheckMediaType</A> is called by <A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">CBasePin::TryMediaTypes</A>, even when
 <A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">TryMediaTypes</A> enumerates the list of the preferred media types of the output pin. This is because the owning filter might be a transform-inplace filter that is simply using the media type (and enumerator) of an upstream filter; this is the point at which the filter determines if the media type is compatible. The input pin of this transform filter might defer selecting a media type when it is connected, in which case it would be up to the output pin of the transform filter to ensure the media type is compatible with its transform.

<P>If a media type can be established, <A HREF="/directx/dxm/help/ds/dssd0208.htm#TryMediaTypes">TryMediaTypes</A> eventually calls the <A HREF="/directx/dxm/help/ds/dssd0207.htm#CompleteConnect">CBaseOutputPin::CompleteConnect</A> member function to negotiate a memory allocator.

<P>First, the <A HREF="/directx/dxm/help/ds/dssd0207.htm#CompleteConnect">CBaseOutputPin::CompleteConnect</A> member function calls the <A HREF="/directx/dxm/help/ds/dssd0207.htm#DecideAllocator">CBaseOutputPin::DecideAllocator</A> member function. This member function negotiates a shared memory allocator with the input pin. It does this by first calling the 
<A HREF="/directx/dxm/help/ds/dssd0166.htm#GetAllocator">IMemInputPin::GetAllocator</A> method of the connected input pin, which retrieves a pointer to an <A HREF="/directx/dxm/help/ds/dssd0165.htm#IMemAllocator">IMemAllocator</A> interface provided by the input pin. 

<P>Then, <A HREF="/directx/dxm/help/ds/dssd0207.htm#CompleteConnect">CompleteConnect</A> calls the pure virtual <A HREF="/directx/dxm/help/ds/dssd0207.htm#DecideBufferSize">CBaseOutputPin::DecideBufferSize</A> member function, which your derived output pin class must override and implement because only the derived class can determine the required buffer size for its media type.

<P>Finally, <A HREF="/directx/dxm/help/ds/dssd0207.htm#CompleteConnect">CompleteConnect</A> calls the <A HREF="/directx/dxm/help/ds/dssd0166.htm#NotifyAllocator">IMemInputPin::NotifyAllocator</A> method of the connected pin to inform the input pin of the allocator to use and to provide a pointer to it. The input pin can reject this allocator, in which case the output pin can retry with a different allocator or fail the connection. If your derived class is not using the allocator of the connected input pin, override <A HREF="/directx/dxm/help/ds/dssd0207.htm#DecideAllocator">CBaseOutputPin::DecideAllocator</A> in your derived class to call the 
<A HREF="/directx/dxm/help/ds/dssd0166.htm#NotifyAllocator">NotifyAllocator</A> member function with an allocator.

<A NAME="connect_6"></A><P><B>When a Reconnection Should Occur</B>
<P>Reconnection is always performed through the <A HREF="/directx/dxm/help/ds/dssd0145.htm#IFilterGraph">IFilterGraph</A> interface on the filter graph manager. Reconnect by calling the <A HREF="/directx/dxm/help/ds/dssd0146.htm#ReconnectEx">IFilterGraph2::ReconnectEx</A> method or the <A HREF="/directx/dxm/help/ds/dssd0145.htm#Reconnect">IFilterGraph::Reconnect</A> method, both of which pass the <A HREF="/directx/dxm/help/ds/dssd0170.htm#IPin">IPin</A> interfaces of the two pins to be reconnected. The <A HREF="/directx/dxm/help/ds/dssd0146.htm#ReconnectEx">ReconnectEx</A> method specifies a media type and thus removes the burden of remembering what type to reconnect with from the pins, which makes the reconnection more likely to succeed. 

<P>Filters are typically connected with the upstream filter first and the downstream filter second. Therefore, the filter negotiates the connection on its input pin before information is available about the filter being connected to its output pin. When the output pin of the filter 
connects, it may
 
become clear that the media type or allocator that was established for the input pin of the filter are not appropriate. In this case, the input connection can be broken and reconnected. 

<P>For example, consider the following connection scenario. An audio effects filter (for example, a reverberation effect) is inserted between an MPEG-audio decompressor filter and another audio effects filter. During the upstream connection to the decompressor filter, a media type is chosen&#151;for example, 22.05 kHz, 16-bit mono. However, in this scenario, when the reverberation filter connects its output pin, the downstream filter will accept only an 11.025 kHz, 16-bit mono media type. Therefore, after connecting with the downstream filter, the reverberation effects filter must then reconnect with the upstream filter and negotiate for an 11.025 kHz media type. 

<P>But media types are not the only reason for reconnection. In many cases, the filter is a <I>transform-inplace filter</I>; that is, a filter that does not require that it either alters the media type or copies the data. Such a filter can be designed to use an allocator of some other 
 filter (upstream or downstream), and likewise use the media type of another filter. That is, the filter is doing its transform "in place" in the buffer of another filter (for example, in the file buffer of the source filter or the video buffer of the rendering filter). 

<P>The general rule is that filters of this type should offer the allocator of the downstream filter to the upstream filter, once the allocator has been established for the output pin. This requires a reconnection of the input pin so that, when the input pin is asked for an allocator (in <A HREF="/directx/dxm/help/ds/dssd0166.htm#GetAllocator">IMemInputPin::GetAllocator</A>) by the upstream output pin, it can offer the allocator retrieved from the downstream filter by the output pin of the transform filter. Therefore, in-place transforms always reconnect.

<P>There are a couple of important rules to follow when requesting a reconnection.

<P>First, a filter must never request a reconnection unless it is certain that the reconnection will succeed. If the reconnection fails, it causes an asynchronous error in the filter graph for which there is no obvious cleanup. Any error that occurs (for example, from incompatible media types) should occur when the pins are connected the first time, when there are ample retry options available at more than one level (by the filter graph manager or the application at least). 

<P>Second, a filter should request a reconnection on the same thread as the call to <A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">IPin::Connect</A>. For example, the following scenario attempts reconnection on a separate thread and will cause problems. 
<OL><LI>The filter graph manager calls <A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">Connect</A> on a pin.
<LI>The filter pin carries out the <A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">Connect</A> method and creates a thread, which starts to determine whether everything is okay for the connection.
<LI><A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">Connect</A> returns to the filter graph manager.
<LI>The filter graph manager returns to the application.
<LI>The application calls the <A HREF="/directx/dxm/help/ds/dssd0154.htm#Run">IMediaControl::Run</A> method of the filter graph manager to start the filter graph, and the filters start running.
<LI>The thread from the initial connection calls the <A HREF="/directx/dxm/help/ds/dssd0146.htm#ReconnectEx">IFilterGraph2::ReconnectEx</A> or <A HREF="/directx/dxm/help/ds/dssd0145.htm#Reconnect">IFilterGraph::Reconnect</A> method and the filter graph manager attempts to carry out reconnection.
<LI>Failure occurs because the filters cannot reconnect while in the running state.
</OL>
<P>The filter graph has code to prevent this failure as long as the <A HREF="/directx/dxm/help/ds/dssd0146.htm#ReconnectEx">IFilterGraph2::ReconnectEx</A> or <A HREF="/directx/dxm/help/ds/dssd0145.htm#Reconnect">IFilterGraph::Reconnect</A> method takes effect while the filter graph is still processing the <A HREF="/directx/dxm/help/ds/dssd0151.htm#Connect">IGraphBuilder::Connect</A> method. Calling the filter graph to reconnect before returning from the <A HREF="/directx/dxm/help/ds/dssd0170.htm#Connect">IPin::Connect</A> method is the best way to ensure this problem does not occur. The best way to achieve this is to perform
all of this on the same thread.

<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="../cpyright.htm" TARGET="_top">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
</FONT>
<BR CLEAR=ALL><P>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="1"><A HREF="#pagetop"><IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*">Top of Page</A></FONT>
</BLOCKQUOTE><P>
</FONT><P>
</BODY></HTML>
