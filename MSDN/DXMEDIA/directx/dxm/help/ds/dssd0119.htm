<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IAsyncReader Interface</TITLE>
<STYLE>
<!--
.tctop {color: blue}
.cpslug {color: blue; text-decoration: none}
-->
</STYLE>
<META NAME="MS-HKWD" CONTENT="IAsyncReader Interface">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">
</HEAD>
<BODY TOPMARGIN=0 LEFTMARGIN=0 BGPROPERTIES="FIXED" BGCOLOR="#FFFFFF" LINK="#000000" VLINK="#808080" ALINK="#000000">
<A NAME="pagetop"></A><A NAME="IAsyncReader"></A>

<OBJECT ID="DAControl" 
  STYLE="position:absolute; left:0; top:11;width:702;height:90"
  CLASSID="CLSID:B6FFC24C-7E13-11D0-9B47-00C04FC2F51D">
</OBJECT>
<!--STYLE="width:702;height:110"-->
<SCRIPT LANGUAGE="JScript">
<!--
  // The DirectAnimation library
  m = DAControl.PixelLibrary;

  /* -- Insert your code here --*/ 

  mediaBase = "art\\";
  glowBase = m.importImage(mediaBase + "glow.gif");
  xImage = m.importImage(mediaBase + "newtransx.gif");
  xImage = xImage.Transform(m.Translate2(-303,0));
  //header1 = m.importImage(mediaBase + "header1.gif");
  //header1 = header1.Transform(m.Translate2(-301,0));

  //header2 = m.importImage(mediaBase + "hdrd3drm.gif");
  //header2 = header2.Transform(m.Translate2(-143,0));

  //header3 = m.importImage(mediaBase + "header3.gif");
  //header3 = header3.Transform(m.Translate2(157,-18));

  //background = m.Overlay(header1, m.Overlay( header2, header3));

  glowPath1 = m.Polyline( new Array( 295,26, 305,26, 305,50, 310,57, 519,57, 
    536,40, 536,17, 675,17, 675,23 ) );

  glowPath2 = m.PolyLine( new Array( 44,41, 44,25, 52,16, 84,16, 106,16 ) );

  glowPath3 = m.PolyLine( new Array( 57,55, 69,55, 78,65, 92,65, 99,58,
    99,82, 95,85, 95,93, 132,93, 132,78,
    303,78, 315,66, 549,66, 549,17, 675,17,
    675,23 ) );

  glowPath4 = m.PolyLine( new Array( 29,55, 19,55, 19,31, 38,30, 38,21,
    46,16, 106,16 ) );

  glowPath5 = m.PolyLine( new Array( 45,62, 45,81, 37,81, 41,85, 46,85,   
  51,91, 68,91, 66,81, 90,81, 90,65, 94,65, 105,47 ) );

  glow1 = glowBase.Transform( moveGlow( glowPath1, 5 ) );
  glow2 = glowBase.Transform( moveGlow( glowPath2, 2 ) );
  glow3 = glowBase.Transform( moveGlow( glowPath3, 8 ) );
  glow4 = glowBase.Transform( moveGlow( glowPath4, 2.5 ) );
  glow5 = glowBase.Transform( moveGlow( glowPath5, 2 ) );

  finalImg = m.Overlay(xImage, m.Overlay( glow5, m.Overlay( glow4, 
    m.Overlay( glow3, m.Overlay( glow2, glow1)))));


  // set the model, an image, as the model to be displayed
  DAControl.Image = finalImg;//m.Overlay(finalImg, background);
  // set the background in case of a non-windowless browser (like IE3)
  DAControl.BackgroundImage = m.SolidColorImage(m.Blue);     
     
  // start the animation       
  DAControl.Start()


  function moveGlow(path, speed)  {
    imDimX = 702;
    imDimY = 120;

    coordsXf = m.Translate2(-imDimX/2, -imDimY/2);
    path = path.Transform(coordsXf);
    return xf = m.FollowPath(path, speed).Repeat(1);
  }

//-->
</SCRIPT>
<TABLE BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="*">
<TR>
<TD ROWSPAN="3" VALIGN="TOP" WIDTH="*">
<IMG SRC="/directx/dxm/help/ds/art/header1.gif" WIDTH="107" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- IAsyncReader Interface"></TD>
<TD ROWSPAN="2" VALIGN="TOP" WIDTH="217"><IMG SRC="/directx/dxm/help/ds/art/hdrdshow.gif" WIDTH="210" HEIGHT="110" BORDER=0 ALT="DirectShow Animated Header -- IAsyncReader Interface"></TD><TD VALIGN="TOP" WIDTH="383"><IMG SRC="/directx/dxm/help/ds/art/header3.gif" WIDTH="383" HEIGHT="95" BORDER=0 ALT="*">
</TD>
<TD VALIGN="TOP" WIDTH="100%">
<IMG SRC="/directx/dxm/help/d3drm/art/spacer1.gif" WIDTH="100%" HEIGHT="94" BORDER=0 ALT="Microsoft DirectShow SDK">
</TD>
</TR><TR><TD VALIGN="TOP"><PRE><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="1"><IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="/directx/dxm/help/ds/index.htm">Index</A>  <IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black;font-weight:bold" HREF="/directx/dxm/help/ds/dssd0091.htm">Topic Contents</A>
</FONT></PRE></TD></TR>
<TR><TD COLSPAN="2" VALIGN="TOP"><PRE><FONT FACE="Verdana,Arial,Helvetica" SIZE="1"><IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="/directx/dxm/help/ds/dssd0118.htm">IAMVideoProcAmp Interface</A>
<IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="/directx/dxm/help/ds/dssd0121.htm">IBaseFilter Interface</A>
</FONT></PRE></TD></TR></TABLE><BR CLEAR=ALL>
<FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><BLOCKQUOTE STYLE="margin:15pt">
<H2>IAsyncReader Interface</H2>
<BR CLEAR=ALL>
<P>The <B>IAsyncReader</B> interface allows multiple overlapped reads from
different positions in the media stream. This interface is supported by source filters.

<P>Note that during connection an output pin supporting the <B>IAsyncReader</B>
should check whether its <A HREF="/directx/dxm/help/ds/dssd0181.htm#QueryInterface">QueryInterface</A> method is called asking for
the <B>IAsyncReader</B> interface. If it is not, then the output pin
should fail the connect unless it establishes some other transport to use
during the connection.

<A NAME="When_to_Implement"></A><P><B>When to Implement</B>
<P>Implement this interface on a pin if your filter reads data of media type
MEDIATYPE_Stream from some source.

<A NAME="When_to_Use"></A><P><B>When to Use</B>
<P>A parser, such as an Apple&#174; QuickTime&#174; parser filter, can use this interface to read from a
filter that reads from a file, the network, or memory.

<A NAME="Methods_in_Vtable_Or"></A><P><B>Methods in Vtable Order</B>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>IUnknown methods </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Description
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0181.htm#QueryInterface">QueryInterface</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves pointers to supported interfaces.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0181.htm#AddRef">AddRef</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Increments the reference count.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0181.htm#Release">Release</A> </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Decrements the reference count.
</FONT></TD></TR></TABLE>
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>IAsyncReader methods </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Description
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#RequestAllocator">RequestAllocator</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the actual allocator to be used.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#Request">Request</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Queues a request for data.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#WaitForNext">WaitForNext</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Blocks until the next sample is completed or the time-out occurs.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#SyncReadAligned">SyncReadAligned</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Performs an aligned synchronized read.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#SyncRead">SyncRead</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Performs a synchronized read.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#Length">Length</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Retrieves the total length of the stream, and the currently available length.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#BeginFlush">BeginFlush</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Causes all outstanding reads to return.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><A HREF="/directx/dxm/help/ds/dssd0119.htm#EndFlush">EndFlush</A>
 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Ends the flushing operation.
</FONT></TD></TR></TABLE>
<H3><HR COLOR="#0000FF"><A NAME="BeginFlush">IAsyncReader::BeginFlush</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Starts the flushing operation.


<P><B>HRESULT</B> <B>BeginFlush</B><B>(</B><B>void</B><B>)</B><B>;</B><BR><H5>Return Values</H5>
<P>Returns S_OK if successful, S_FALSE otherwise.


<H5>Remarks</H5>
<P>Causes all outstanding reads to return, possibly with a failure code
(<A HREF="/directx/dxm/help/ds/dssd0308.htm#VFW_E_TIMEOUT">VFW_E_TIMEOUT</A>), indicating that the outstanding reads were canceled.
Between <B>IAsyncReader::BeginFlush</B> and <A HREF="/directx/dxm/help/ds/dssd0119.htm#EndFlush">IAsyncReader::EndFlush</A> calls,
<A HREF="/directx/dxm/help/ds/dssd0119.htm#Request">IAsyncReader::Request</A> calls will fail and <A HREF="/directx/dxm/help/ds/dssd0119.htm#WaitForNext">IAsyncReader::WaitForNext</A>
calls will always complete immediately.
<H3><HR COLOR="#0000FF"><A NAME="EndFlush">IAsyncReader::EndFlush</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Completes the flushing operation.

<P><B>HRESULT</B> <B>EndFlush</B><B>(</B><B>void</B><B>)</B><B>;</B><BR><H5>Return Values</H5>
<P>Returns S_OK if successful, S_FALSE otherwise.


<H5>Remarks</H5>
<P>Between <A HREF="/directx/dxm/help/ds/dssd0119.htm#BeginFlush">IAsyncReader::BeginFlush</A> and <B>IAsyncReader::EndFlush</B> calls,
<A HREF="/directx/dxm/help/ds/dssd0119.htm#Request">IAsyncReader::Request</A> calls will fail and <A HREF="/directx/dxm/help/ds/dssd0119.htm#WaitForNext">IAsyncReader::WaitForNext</A> calls
will always complete immediately. This method is called so the source thread can wait in the
<B>IAsyncReader::WaitForNext</B> method again.
<H3><HR COLOR="#0000FF"><A NAME="Length">IAsyncReader::Length</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Retrieves the stream's total length, and the currently available length.

<P><B>HRESULT</B> <B>Length</B><B>(</B><BR>&nbsp;&nbsp;<B>LONGLONG*</B> <I>pTotal</I><B>,</B><BR>&nbsp;&nbsp;<B>LONGLONG*</B> <I>pAvailable</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pTotal</I>
 </DT><DD>Total allocated length.
</DD><DT><I>pAvailable</I>
 </DT><DD>Available length.
</DD></DL>
<H5>Return Values</H5>
<P>Returns S_OK if successful, E_UNEXPECTED if the file has not been opened.


<H5>Remarks</H5>
<P>Read operations beyond the available length but within the total length will
normally succeed, but they might block for a long period of time.
<H3><HR COLOR="#0000FF"><A NAME="Request">IAsyncReader::Request</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Queues a request for data.

<P><B>HRESULT</B> <B>Request</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample*</B> <I>pSample</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwUser</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pSample</I>
 </DT><DD>Media sample being requested.
</DD><DT><I>dwUser</I>
 </DT><DD>[in] User context.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="/directx/dxm/help/ds/dssd0308.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Value </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Meaning
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_BADALIGN </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An invalid alignment was specified. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_MEDIA_TIME_NOT_SET </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Time has not been set.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT_FROM_WIN32 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Request for data past end of file.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">NOERROR </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">No error.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_OK </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Success.
</FONT></TD></TR></TABLE>

<H5>Remarks</H5>
<P>Media sample start and stop times contain the requested absolute
byte position (start-inclusive and stop-exclusive).
This method might fail if the sample is not obtained from an agreed allocator or
if the start or stop position does not match the agreed alignment.
The samples allocated from the source pin's allocator might fail
<A HREF="/directx/dxm/help/ds/dssd0161.htm#GetPointer">IMediaSample::GetPointer</A> until after returning from
<A HREF="/directx/dxm/help/ds/dssd0119.htm#WaitForNext">IAsyncReader::WaitForNext</A>.

<P>The stop position must be aligned, which means it might exceed duration.
On completion, the stop position will be corrected to the unaligned actual data.

<P>The <I>dwUser</I> parameter is used by the caller to identify the sample
that returned from the <A HREF="/directx/dxm/help/ds/dssd0119.htm#WaitForNext">IAsyncReader::WaitForNext</A> method. It has no
meaning within <A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader</A> but could be used to track individual sample
information.
<H3><HR COLOR="#0000FF"><A NAME="RequestAllocator">IAsyncReader::RequestAllocator</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Retrieves the actual allocator to be used.

<P><B>HRESULT</B> <B>RequestAllocator</B><B>(</B><BR>&nbsp;&nbsp;<B>IMemAllocator*</B> <I>pPreferred</I><B>,</B><BR>&nbsp;&nbsp;<B>ALLOCATOR_PROPERTIES*</B> <I>pProps</I><B>,</B><BR>&nbsp;&nbsp;<B>IMemAllocator</B> <B>**</B> <I>ppActual</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pPreferred</I>
 </DT><DD>[in] Preferred allocator.
</DD><DT><I>pProps</I>
 </DT><DD>[in] Preferred allocator properties (size, count, and alignment).
</DD><DT><I>ppActual</I>
 </DT><DD>[out] Actual allocator used.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="/directx/dxm/help/ds/dssd0308.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Value </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Meaning
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">E_FAIL </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Failure to initialize an allocator.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_BADALIGN </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An invalid alignment was specified. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_OK </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Allocator was returned.
</FONT></TD></TR></TABLE>

<H5>Remarks</H5>
<P>The preferred allocator and preferred allocator properties must be passed in.
This method returns the actual allocator to be used.

<P><A HREF="/directx/dxm/help/ds/dssd0165.htm#GetProperties">IMemAllocator::GetProperties</A> should be called
on the returned allocator to learn the alignment and prefix chosen.
This allocator will not be committed and decommitted by
the asynchronous reader, only by the consumer.
This method must be called before calling <A HREF="/directx/dxm/help/ds/dssd0119.htm#Request">IAsyncReader::Request</A>.
<H3><HR COLOR="#0000FF"><A NAME="SyncRead">IAsyncReader::SyncRead</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Performs a synchronous read.

<P><B>HRESULT</B> <B>SyncRead</B><B>(</B><BR>&nbsp;&nbsp;<B>LONGLONG</B> <I>llPosition</I><B>,</B><BR>&nbsp;&nbsp;<B>LONG</B> <I>lLength</I><B>,</B><BR>&nbsp;&nbsp;<B>BYTE*</B> <I>pBuffer</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>llPosition</I>
 </DT><DD>[in] Absolute file position.
</DD><DT><I>lLength</I>
 </DT><DD>[in] Number of bytes required.
</DD><DT><I>pBuffer </I>
 </DT><DD>[out] Where the data is written.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="/directx/dxm/help/ds/dssd0308.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Value </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Meaning
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_BADALIGN </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An invalid alignment was specified. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT_FROM_WIN32 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Win32 error.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_FALSE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Size changed (probably due to end of file).
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_OK </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Success.
</FONT></TD></TR></TABLE>

<H5>Remarks</H5>
<P>The <B>SyncRead</B> method works in a stopped state as well as in a running state.
The read is not necessarily aligned. This method fails if the read is beyond the actual total length.
<H3><HR COLOR="#0000FF"><A NAME="SyncReadAligned">IAsyncReader::SyncReadAligned</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Performs a synchronous read of the data.

<P><B>HRESULT</B> <B>SyncReadAligned</B><B>(</B><BR>&nbsp;&nbsp;<B>IMediaSample*</B> <I>pSample</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>pSample</I>
 </DT><DD>Sample to read.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="/directx/dxm/help/ds/dssd0308.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Value </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Meaning
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_BADALIGN </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">An invalid alignment was specified. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">HRESULT_FROM_WIN32 </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Win32 error.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_FALSE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Size changed (probably due to end of file).
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_OK </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Success.
</FONT></TD></TR></TABLE>

<H5>Remarks</H5>
<P>The sample passed in must have been acquired from the agreed allocator.
The start and stop positions must be aligned equivalent to an
<A HREF="/directx/dxm/help/ds/dssd0119.htm#Request">IAsyncReader::Request</A>/<A HREF="/directx/dxm/help/ds/dssd0119.htm#WaitForNext">IAsyncReader::WaitForNext</A> pair,
but may avoid the need for a thread on the source filter.
<H3><HR COLOR="#0000FF"><A NAME="WaitForNext">IAsyncReader::WaitForNext</A></H3>
<A HREF="/directx/dxm/help/ds/dssd0119.htm">IAsyncReader Interface</A>
<P>Blocks until the next read requested through
<A HREF="/directx/dxm/help/ds/dssd0119.htm#Request">IAsyncReader::Request</A> completes or the time-out occurs.

<P><B>HRESULT</B> <B>WaitForNext</B><B>(</B><BR>&nbsp;&nbsp;<B>DWORD</B> <I>dwTimeout</I><B>,</B><BR>&nbsp;&nbsp;<B>IMediaSample**</B> <I>ppSample</I><B>,</B><BR>&nbsp;&nbsp;<B>DWORD</B> <B>*</B> <I>pdwUser</I><BR>&nbsp;&nbsp;<B>)</B><B>;</B><BR><H5>Parameters</H5>
<DL><DT><I>dwTimeout</I>
 </DT><DD>[in] Time-out in milliseconds; can be zero or INFINITE.
</DD><DT><I>ppSample</I>
 </DT><DD>[out] Completed sample.
</DD><DT><I>pdwUser</I>
 </DT><DD>User context.
</DD></DL>
<H5>Return Values</H5>
<P>Returns an <A HREF="/directx/dxm/help/ds/dssd0308.htm#HRESULT">HRESULT</A> value that depends on the implementation of the interface. Current DirectShow implementation return values include:
<TABLE BORDER=0>
<TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Value </B></FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2"><B>Meaning
</B></FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_TIMEOUT </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">A time-out has expired. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">VFW_E_WRONG_STATE </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">The operation could not be performed because the filter is in the wrong state. 
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">E_FAIL </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Failure.
</FONT></TD></TR><TR><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">S_OK </FONT></TD><TD ALIGN=LEFT VALIGN=TOP><FONT FACE="VERDANA,ARIAL,HELVETICA" SIZE="2">Success.
</FONT></TD></TR></TABLE>

<H5>Remarks</H5>
<P>Samples may not be returned in order. If there is a read error
of any sort, a notification will already have been sent by the source filter,
and <A HREF="/directx/dxm/help/ds/dssd0308.htm#HRESULT">HRESULT</A> will be an error. If <I>ppSample</I> is not null,
a request has been completed with the result code returned.

<P>The <I>pdwUser</I> parameter returns the caller's context <A HREF="/directx/dxm/help/ds/dssd0404.htm#DWORD">DWORD</A>
corresponding to the sample returned.
<P><P><FONT FACE="MS SANS SERIF" SIZE="1" COLOR="BLACK">
<A CLASS=cpslug HREF="../cpyright.htm" TARGET="_top">&#169; 1998 Microsoft Corporation. All rights reserved. Terms of Use.</A>
</FONT>
<BR CLEAR=ALL><P>
<FONT FACE="Verdana,Arial,Helvetica" SIZE="1"><A HREF="#pagetop"><IMG SRC="/directx/dxm/help/ds/art/yelbtn.gif" WIDTH="11" HEIGHT="11" ALIGN="MIDDLE" BORDER=0 ALT="*">Top of Page</A></FONT>
</BLOCKQUOTE><P>
</FONT><P>
</BODY></HTML>
