<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>arrays</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_arrays_1"></a>arrays</h1>
<p>
<b>typedef </b>[ <b>[</b><i>type-attr-list</i><b>]</b><i> </i>] <i>type-specifier </i>[<i>pointer-decl</i>] <i>array-declarator</i><b>;<br>
<br>
typedef </b>[ <b>[</b><i>type-attr-list</i><b>]</b><i> </i>] <b>struct</b> [ <i>tag </i>] <b>{</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;[ <b>[</b> <i>field-attribute-list </i><b>]</b> ] <i>type-specifier</i> [<i>pointer-decl</i>] <i>array-declarator</i><b>;</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>...</b><br>
<b>}<br>
typedef </b>[ <b>[</b><i>type-attr-list</i><b>]</b><i> </i>] <b>union </b>[ <i>tag </i>]<b> {<br>
&nbsp;&nbsp;&nbsp;&nbsp;[ case (</b><i>limited-expression</i><b> </b>[ <b>, ...</b><i> </i>] <b>) ]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>[ <b>[ </b><i>field_attribute-list</i><b> ] </b>]<b> </b><i>type-specifier </i>[<i>pointer-decl</i>] <i>array-declarator</i><b>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</b>[ <b>[ default ]<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>[ <b>[ </b><i>field_attribute-list</i><b> ] </b>]<b> </b><i>type-specifier </i>[<i>pointer-decl</i>] <i>array-declarator</i><b>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;</b>]<b><br>
<br>
</b>[ <b>[</b><i>function-attribute-list</i><b>] </b>] <i>type-specifier </i>[<i>pointer-decl</i>] <i>function-name</i><b>(</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;[ <b>[</b><i>param-attr-list</i><b>]</b> ] <i>type-specifier </i>[<i>pointer-decl</i>] <i>array-declarator</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;<b>, ...</b><br>
<b>);</b>
<dl>
<dt>
<i>type-attr-list</i></dt>
<dd>
Specifies zero or more attributes that apply to the type. Valid type attributes include <b>handle</b>, <b>switch_type</b>, <b>transmit_as</b>; the pointer attribute <b>ref</b>, <b>unique</b>, or <b>ptr</b>; and the usage attributes <b>context_handle</b>, <b>string</b>, and <b>ignore</b>. Separate multiple attributes with commas.</dd>
<dt>
<i>type-specifier</i></dt>
<dd>
Specifies the type identifier, base type, <b>struct</b>, <b>union</b>, or <b>enum</b> type. The type specification can include an optional storage specification.</dd>
<dt>
<i>pointer-decl</i></dt>
<dd>
Specifies zero or more pointer declarators. A pointer declarator is the same as the pointer declarator used in C, constructed from the <b>*</b> designator, modifiers such as <b>far</b>, and the qualifier <b>const</b>.</dd>
<dt>
<i>array-declarator</i></dt>
<dd>
Specifies the name of the array, followed by one of the following constructs for each dimension of the array: "<b>[ ]</b>", "<b>[*]</b>", "<b>[</b><i>const1</i><b>]</b>", or "<b>[</b><i>lower...upper</i><b>]</b>" where <i>lower</i> and <i>upper</i> are constant values that represent the lower and upper bounds. The constant <i>lower</i> must evaluate to zero. </dd>
<dt>
<i>tag</i></dt>
<dd>
Specifies an optional tag for the structure or union.</dd>
<dt>
<i>field-attribute-list</i></dt>
<dd>
Specifies zero or more field attributes that apply to the structure, union member, or function parameter. Valid field attributes include <b>first_is</b>, <b>last_is</b>, <b>length_is</b>, <b>max_is</b>, <b>size_is</b>; the usage attributes <b>string</b>, and <b>ignore</b>; the pointer attributes <b>ref</b>, <b>unique</b>, and <b>ptr</b>; and the union attribute <b>switch_type</b>. Separate multiple field attributes with commas. Note that of the attributes listed above, <b>first_is</b>, <b>last_is</b>, and <b>ignore</b> are not valid for unions.</dd>
<dt>
<i>limited-expression</i></dt>
<dd>
Specifies a C-language expression. The MIDL compiler supports conditional expressions, logical expressions, relational expressions, and arithmetic expressions. MIDL does not allow function invocations in expressions and does not allow increment and decrement operators.</dd>
<dt>
<i>function-attribute-list</i></dt>
<dd>
Specifies zero or more attributes that apply to the function. Valid function attributes are <b>callback</b>, <b>local</b>; the pointer attribute <b>ref</b>, <b>unique</b>, or <b>ptr</b>; and the usage attributes <b>string</b>, and <b>context_handle</b>.</dd>
<dt>
<i>function-name</i></dt>
<dd>
Specifies the name of the remote procedure.</dd>
<dt>
<i>param-attr-list</i></dt>
<dd>
Specifies the directional attributes and one or more optional field attributes that apply to the array parameter. Valid field attributes include <b>max_is</b>, <b>size_is</b>, <b>length_is</b>, <b>first_is</b>, and <b>last_is</b>.
</dd>
</dl>
<h4>Examples</h4>
<pre><code>/* IDL file interface body */ 
#define MAX_INDEX 10 
 
typedef char  ATYPE[MAX_INDEX]; 
typedef short BTYPE[];        // Equivalent to [*]; 
typedef long  CTYPE[*][10];   // [][10] 
typedef float DTYPE[0..10];   // Equivalent to [11] 
typedef float ETYPE[0..(MAX_INDEX)];  
 
typedef struct { 
    unsigned short size; 
    unsigned short length; 
    [size_is(size), length_is(length)] char string[*]; 
} counted_string; 
 
HRESULT MyFunction( 
     [in, out] short * pSize,  
     [in, out, string, size_is(*pSize)] char a[0..*] 
); 
 </code></pre>
<h4>Remarks</h4>
<p>
Array declarators appear in the interface body of the IDL file as part of a general declaration, as a member of a structure or union declarator, or as a parameter to a remote procedure call.</p>
<p>
The bounds of each dimension of the array are expressed inside a separate pair of square brackets. An expression that evaluates to <i>n </i>signifies a lower bound of zero and an upper bound of <i>n</i>&nbsp;–&nbsp;<i>1</i>. If the square brackets are empty or contain a single asterisk (<b>*</b>), the lower bound is zero and the upper bound is determined at run time.</p>
<p>
The array can also contain two values separated by an ellipsis that represent the lower and upper bounds of the array, as in [<i>lower...upper</i>]. Microsoft RPC requires a lower bound of zero. The MIDL compiler does not recognize constructs that specify nonzero lower bounds.</p>
<p>
Arrays can be associated with the field attributes <b>size_is</b>, <b>max_is</b>, <b>length_is</b>, <b>first_is</b>, and <b>last_is</b> to specify the size of the array or the part of the array that contains valid data. These field attributes identify the parameter, structure field, or constant that specifies the array dimension or index.</p>
<p>
The array must be associated with the identifier specified by the field attribute in this way: When the array is a parameter, the identifier must also be a parameter to the same function; when the array is a structure field, the identifier must be another structure field of that same structure.</p>
<p>
An array is called "conformant" if the upper bound of any dimension is determined at run time, and only upper bounds can be determined at run time. To determine the upper bound, the array declaration must include a <b>size_is</b> or <b>max_is</b> attribute.</p>
<p>
An array is called "varying" when its bounds are determined at compile time, but the range of transmitted elements is determined at run time. To determine the range of transmitted elements, the array declaration must include a <b>length_is</b>, <b>first_is</b>, or <b>last_is</b> attribute.</p>
<p>
A conformant varying array (also called "open") is an array whose upper bound and range of transmitted elements are determined at run time. At most, one conformant or conformant varying array can be nested in a C structure and must be the last element of the structure. Nonconformant varying arrays can occur anywhere in a structure.</p>

<h4><a name="_rpc_multidimensional_arrays"></a>Multidimensional Arrays</h4>
<p>
The user can declare types that are arrays and then declare arrays of objects of such types. The semantics of <i>m</i>-dimensional arrays of <i>n</i>-dimensional array types are the same as the semantics of <i>m+n</i>-dimensional arrays.</p>
<p>
For example, the type RECT_TYPE can be defined as a two-dimensional array and the variable <i>rect</i> can be defined as an array of RECT_TYPE. This is equivalent to the three-dimensional array <i>equivalent_rect</i>:</p>
<pre><code>typedef short int RECT_TYPE[10][20]; 
RECT_TYPE rect[15]; 
short int equivalent_rect[15][10][20];  // ~RECT_TYPE rect[15] 
 </code></pre>
<p>
Microsoft RPC is C-oriented. Following C-language conventions, only the first dimension of a multidimensional array can be determined at run time. Interoperation with DCE IDL arrays that support other languages is limited to:
<ul>
<li>
Multidimensional arrays with constant (compile-time-determined) bounds.</li>
<li>
Multidimensional arrays with all constant bounds except the first dimension. The upper bound and range of transmitted elements of the first dimension are dependent on run time.</li>
<li>
Any one-dimensional arrays with a lower bound of zero.</li>
</ul>
<p>
When the <b>string</b> attribute is used on multidimensional arrays, the attribute applies to the rightmost array.</p>

<h4><a name="_rpc_arrays_of_pointers"></a>Arrays of Pointers</h4>
<p>
Reference pointers must point to valid data. The client application must allocate all memory for an <b>in</b> or <b>in</b>, <b>out</b> array of reference pointers, especially when the array is associated with <b>in</b>, or <b>in</b>, <b>out</b> <b>length_is</b>, or <b>last_is</b> values. The client application must also initialize all array elements before the call. Before returning to the client, the server application must verify that all array elements in the transmitted range point to valid storage.</p>
<p>
On the server side, the stub allocates storage for all array elements, regardless of the <b>length_is</b> or <b>last_is</b> value at the time of the call. This feature can affect the performance of your application.</p>
<p>
No restrictions are placed on arrays of unique pointers. On both the client and the server, storage is allocated for null pointers. When pointers are non-null, data is placed in preallocated storage.</p>
<p>
An optional pointer declarator can precede the array declarator.</p>
<p>
When embedded reference pointers are <b>out</b>-only parameters, the server-manager code must assign valid values to the array of reference pointers. For example: </p>
<pre><code>typedef [ref] short * ARefPointer;
typedef ARefPointer ArrayOfRef[10];
HRESULT proc1( [out] ArrayOfRef Parameter ); 
 </code></pre>
<p>
The generated stubs allocate the array and assign NULL values to all pointers embedded in the array.</p>
<h4>See Also</h4>
<p>
<a href="mi-laref_2rzn.htm"><b>first_is</b></a>, <a href="mi-laref_49v0.htm"><b>IDL</b></a>, <a href="mi-laref_0v5f.htm"><b>last_is</b></a>, <a href="mi-laref_2njn.htm"><b>length_is</b></a>, <a href="mi-laref_5lpv.htm"><b>max_is</b></a>, <a href="mi-laref_4ws2.htm"><b>ptr</b></a>, <a href="mi-laref_52cm.htm"><b>ref</b></a>, <a href="mi-laref_3zxv.htm"><b>size_is</b></a>, <a href="mi-laref_955z.htm"><b>string</b></a>, <a href="mi-laref_9r1h.htm"><b>unique</b></a></p>
<p>&nbsp;</p></body>
</HTML>
