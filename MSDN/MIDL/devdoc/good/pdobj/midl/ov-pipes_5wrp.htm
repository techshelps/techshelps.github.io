<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Pipe Interface</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_rpc_the_pipe_interface"></a>The Pipe Interface </h1>
<p>
When you define a pipe in an IDL file, the MIDL compiler generates a pipe control structure whose members are pointers to <i>push</i>, <i>pull</i>, and <i>alloc</i> procedures and a <i>state</i> variable that coordinates these procedures. The <i>state </i>variable is local to each side — that is, the client and server each maintain their own pipe state, by which their application code and stub code communicate. </p>
<p>
The client application initializes the fields in the pipe control structure, maintains its <i>state</i> variable, and manages the data transfer with its own <i>push</i>, <i>pull</i>, and <i>alloc</i> functions, as described in the next topic. The client stub code calls these application functions in loops during data transfer. For an input pipe the client stub marshals the transfer data and transmits it to the server stub. For an output pipe, the client stub unmarshals the data into a buffer and passes a pointer to that buffer back to the client application.</p>
<p>
The server stub code initializes the fields of the pipe control structure to a <i>state</i> variable and <i>push</i>, and <i>pull</i> routines. The server stub maintains the state and manages its private storage for the transfer data. The server application calls the <i>pull</i> and <i>push </i>routines in loops during the remote procedure call as it receives and unmarshals data from the client stub, or marshals and transmits data to the client stub.</p>
<p>
In the following example, we define a pipe type LONG_PIPE, whose element size is defined as <b>long</b>. We also declare function prototypes for the remote procedure calls InPipe and OutPipe, to send and receive data, respectively.</p>
<h4>Example</h4>
<pre><code>//file: pipedemo.idl
typedef pipe long LONG_PIPE;
void InPipe( [in] LONG_PIPE pipe_data );
void OutPipe( [out] LONG_PIPE *pipe_data ); 
//end pipedemo.idl
 
//file: pipedemo.h (fragment)
typedef struct pipe_LONG_PIPE
    {
    void (__RPC_FAR * pull) (
        char __RPC_FAR * state,
        long __RPC_FAR * buf,
        unsigned long esize,
        unsigned long __RPC_FAR * ecount );
    void (__RPC_FAR * push) (
        char __RPC_FAR * state,
        long __RPC_FAR * buf,
        unsigned long ecount );
    void (__RPC_FAR * alloc) (
        char __RPC_FAR * state,
        unsigned long bsize,
        long __RPC_FAR * __RPC_FAR * buf,
        unsigned long __RPC_FAR * bcount );
    char __RPC_FAR * state;
    } LONG_PIPE;
 
void InPipe( 
    /* [in] */ LONG_PIPE pipe_data);
void OutPipe( 
    /* [out] */ LONG_PIPE __RPC_FAR *pipe_data);
//end pipedemo.h
 </code></pre>
<h4>See Also</h4>
<p>
<a href="mi-laref_3b39.htm"><b>pipe</b></a>, <a href="mi-cmdln_08bt.htm">/<b>Oi</b></a></p>
<p>&nbsp;</p></body>
</HTML>
