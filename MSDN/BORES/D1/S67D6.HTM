<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Techniques to Analyze Slow Performance</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Techniques to Analyze Slow Performance </H3><P CLASS="t">It may be tempting to address a performance problem solely by system-level, server-performance tuning—for example, how much memory, the type of file system, the number and type of processors, and so forth. The experience of Microsoft SQL Server Support indicates that most performance problems cannot be resolved this way. They must be addressed by analyzing the application, the queries the application is submitting to the database, and how these queries interact with the database schema.</P>
<H4 CLASS="h3"><A NAME="sec0"></A>Isolate the Query</H4><P CLASS="t">First, isolate the query or queries that are slow. It often appears that an entire application is slow when actually only a few of the SQL queries are slow. It is usually not possible to resolve a performance problem without breaking the problem down and isolating the slow queries.</P>
<P CLASS="t">SQL Server 6.5 includes SQL Trace, which monitors and records database activity. SQL Trace can display all server activity in real-time or create filters that focus on the actions of particular users, applications, or host servers. SQL Trace can display any SQL statement or remote procedure call (RPC) that is sent to any Microsoft SQL Server 6.5 server.</P>
<P CLASS="t">If you have a development tool that transparently generates SQL, use any available diagnostic or debug mode of this tool to capture the generated SQL. In many cases, trace features are available, but they may not be openly documented. Contact technical support for your application to determine if a trace feature exists for monitoring the SQL statements generated by the application. </P>
<P CLASS="t">For application development tools that use Embedded SQL, isolating slow queries is much easier—the SQL is openly visible.</P>
<P CLASS="t">If your development tool or end-user application does not provide a trace feature, and you are not using SQL Server 6.5, there are several alternatives: </P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Use the 4032 trace flag.
<P CLASS="lt1">This will allow capture of the SQL statements sent to the server in the SQL error log.</P></LI><LI CLASS="ULI1">Monitor the queries with a network analyzer, such as Microsoft Network Monitor, which is part of Systems Management Server (SMS).</LI><LI CLASS="ULI1">For ODBC applications, use the ODBC Administrator to select tracing of ODBC calls. For more information about ODBC Administrator, see the ODBC documentation.</LI><LI CLASS="ULI1">Use a third-party, client-side utility that intercepts the SQL at the DB-Library or ODBC layers. An example of this is SQL Inspector from Blue Lagoon Software.</LI><LI CLASS="ULI1">Use SQLEye, an analysis tool provided as an example on the Microsoft TechNet CD-ROM. (Note that SQLEye is an unsupported tool.)</LI></UL></SPAN><H4 CLASS="h3"><A NAME="sec1"></A>Test Query Performance</H4><P CLASS="t">After the slow query is isolated, perform the following steps:</P>
<P CLASS="ls">Run the suspected slow query in isolation, using a query tool such as ISQL/w, and verify that it is slow.</P>
<P CLASS="lt1">It is often best to run the query on the server computer itself by using ISQL/w and local pipes and redirect the output to a file. This helps eliminate complicating factors, such as network and screen I/O and application results buffering.</P>
<P CLASS="ls">Use SET STATISTICS IO ON to examine the I/O consumed by the query.</P>
<P CLASS="lt1">Notice the count of logical page I/Os. The optimizer's goal is to minimize I/O count. Make a record of the logical I/O count. This forms a baseline against which to measure improvement. It is often more effective to focus exclusively on the STATISTICS IO output and experiment with different query and index types than to use SET SHOWPLAN ON. Interpreting and effectively applying the output of SHOWPLAN can require some study and can consume time that can be more effectively spent on empirical tests. If your performance problem is not fixed by these simple recommendations, you can use SHOWPLAN to more thoroughly investigate optimizer behavior.</P>
<P CLASS="ls">If the query involves a view or stored procedure, extract the query from the view or stored procedure and run it separately.</P>
<P CLASS="lt1">This allows the access plan to change as you experiment with different indexes. It also helps localize the problem to the query itself, versus how the optimizer handles views or stored procedures. If the problem is not in the query itself but only occurs when it is run as part of a view or stored procedure, running the query by itself will help determine this.</P>
<P CLASS="ls">Be aware of triggers on the involved tables that can transparently generate I/O as the trigger runs.</P>
<P CLASS="lt1">You should remove any triggers involved in a slow query. This helps determine if the problem is in the query itself or the trigger or view. </P>
<P CLASS="ls">Examine the indexes of the tables used by the slow query. Use the previously listed techniques to determine if these are good indexes, and change them if necessary.</P>
<P CLASS="lt1">As a rough rule-of-thumb, try indexing each column in your WHERE or FROM clause. Performance problems are often caused simply by not having a column in the WHERE or FROM clause indexed or by not having a useful index on such a column.</P>
<P CLASS="ls">Using the queries previously mentioned, examine the data uniqueness and distribution for each column mentioned in the WHERE or FROM clause, especially for each indexed column.</P>
<P CLASS="lt1">In many cases, simple inspection of the query, table, indexes, and data will immediately show the problem cause. For example, performance problems are often caused by having an index on a key with only three or four unique values, or performing a JOIN on such a column, or returning an excessive number of rows to the client.</P>
<P CLASS="ls">Based on this study, make any needed changes to the application, query, or indexes. Run the query after making the change, and observe any change in I/O count.</P>
<P CLASS="ls">After noting the improvement, run the main application to see if overall performance is better.</P>
<H4 CLASS="h3"><A NAME="sec2"></A>Check for I/O- vs. CPU-Bound Query Behavior</H4><P CLASS="t">Check the program for I/O- or CPU-bound behavior. It is often useful to determine if a query is I/O- or CPU-bound. This helps focus your improvement efforts on the true bottleneck. For example, if a query is CPU bound, adding memory to SQL Server is not likely to improve performance because more memory only improves the cache hit ratio, which in this case, is already high.</P>
<P CLASS="proch">To examine I/O-versus CPU-bound query behavior</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Use Windows NT Performance Monitor to watch I/O versus CPU activity.</LI><LI CLASS="ULI1">Watch all instances of the % Disk Time counter of the LogicalDisk object. Also watch the % Total Processor Time counter of the System object. (To see valid disk performance information, you must have previously turned on the Windows NT DISKPERF setting by issuing <B>diskperf</B> <B>-y</B> from a command prompt and then rebooting the system. For more information, see the Windows NT documentation.)</LI><LI CLASS="ULI1">While running the query:

<UL><LI CLASS="ULI2">If the CPU graph is consistently high (say, greater than 70 percent) and the % Disk<B> </B>Time is consistently low, this indicates a CPU-bound state.</LI><LI CLASS="ULI2">If the CPU graph is consistently low (say, less than 50 percent) and the % Disk Time is consistently high, this indicates an I/O-bound state.</LI></UL></LI><LI CLASS="ULI1">Compare the CPU graph with the STATISTICS IO information.</LI></UL></SPAN></BODY></HTML>
