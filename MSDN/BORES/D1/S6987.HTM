<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Locking Behavior of Cursors</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Locking Behavior of Cursors</H2><P CLASS="t"><B><I>Transaction isolation levels and concurrency options affect the locking behavior of server cursors.</I></B></P>
<P CLASS="t">This article will clarify the effect of optimizer hints and isolation levels on the locking considerations of cursors. The nonlocking parts of optimizer hints affect the cursor behavior in the following ways:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">INDEX = <I>index_name</I>—If the given index is unique, then this index will be used as the primary keyset for the given table. If the index is not unique, then this optimizer hint will be ignored.
<P CLASS="lt1"><B>Note</B>   Use of this option may cause dynamic cursors to convert to keyset-based cursors if the index chosen does not match the "ORDER BY" columns in the cursor statement exactly.</P></LI><LI CLASS="ULI1">FASTFIRSTROW—Dynamic cursors will always use this option whenever the primary keyset values chosen are from a nonclustered index. For keyset-based cursors, this option will be honored if it is used in the cursor statement; it will not be honored if it is not given.</LI></UL></SPAN><P CLASS="t">The locking related parts of optimizer hints and isolation levels will affect cursor locking behavior as follows:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">If there is a transaction outstanding, exclusive locks and table locks (TABLOCK and TABLOCKX) taken and maintained inside a user transaction are held as long as the transaction is open, even if the cursor closes, and are released when the transaction ends. If there are no transactions outstanding, the TABLOCKX and TABLOCK options will only have read duration; that is, the table lock will be active while the rows are being read, and released as soon as the read is complete.</LI><LI CLASS="ULI1">The isolation level at the time the cursor is declared will be in effect throughout the cursor. Changes made to the isolation level after the cursor is declared will not affect the locking behavior.</LI><LI CLASS="ULI1">The PAGELOCK keyword is ignored in DECLARE CURSOR statements. </LI><LI CLASS="ULI1">If a certain optimizer locking hint is used for a given table in a cursor statement, it will override the isolation level and the cursor concurrency option for that table. For example, you can open a cursor with the LOCKCC option and specify the NOLOCK option on one of the tables participating in the cursor SELECT statement. This will cause that table to be read uncommitted, or with no locks, while other tables are protected by update locks.</LI><LI CLASS="ULI1">No data modifications, using UPDATE, DELETE, or INSERT, can be made to tables that have the NOLOCK optimizer hint.</LI><LI CLASS="ULI1">If no optimizer locking hint is used, the isolation-level locking will take effect on the cursor if the cursor is opened with OPTCC, OPTCCVAL, or READONLY concurrency options. If the cursor is opened with the LOCKCC option, this option will override isolation-level locking.</LI><LI CLASS="ULI1">OPTCC, OPTVAL, and LOCKCC concurrency options are disallowed in cursors when the isolation level is 0. Also UPDLOCK and TABLOCKX keywords are disallowed as optimizer hints when at this isolation level.</LI><LI CLASS="ULI1">If the isolation level is 0 during cursor declaration, ANSI cursors will be opened as READONLY. Extended procedure cursors will fail to open unless the READONLY option is specified.</LI></UL></SPAN><P CLASS="t">Following is a detailed table of the kinds of locks taken with various hints and isolation levels. Some of the shorthand terminology is explained below:</P>
<P CLASS="t"><B>RDL - Read locks </B>These are shared page locks that are active while the pages are being read and released when the page read is complete. </P>
<P CLASS="t"><B>SCR - Scroll locks</B> These locks are taken by the cursor fetch command on pages that the rows are returned from. These locks will remain in place as long as the last fetch command has rows fetched from these pages. They will be released either when a subsequent fetch scrolls off these pages, or the cursor is closed. These locks come in two varieties of page locks: shared SCR(sh) and update SCR(up). Only the locks on the data pages will be kept; no locks on the index pages will be taken. Furthermore, if SCROLL locking is in effect on the cursor (shared or update) and there is an outstanding transaction in effect during opening of a keyset-based cursor, shared locks will be accumulated on pages generating the keyset, and these locks will be kept until the transaction ends. </P>
<P CLASS="t"><B>XT/C Locks</B> These page locks are taken by the cursor fetch command on pages that the rows are returned from. If a transaction is outstanding, these locks will be kept within the duration of the transaction and released when the transaction commits or rolls back. If there are no transactions, these locks will be kept as long as the cursor is open, or a new transaction is started and then ended. These locks also have shared and update varieties: XT/C(sh) and XT/C(up). </P>
<P CLASS="t"><B>XT(tb) and XT(tbx)</B> Shared and exclusive table locks. These locks can only be taken inside a transaction and can only live within the life of the transaction, not the cursor.</P>
<P CLASS="t">The following table clarifies in detail what kind of locks will be taken with cursors under different locking hints and optimizer levels.</P>
<P CLASS="a"><img src="table01.gif"></P></BODY></HTML>
