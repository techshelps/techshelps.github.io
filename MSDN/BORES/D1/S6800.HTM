<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Cascading Deletes/Updates with Triggers</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Cascading Deletes/Updates with Triggers </H2><P CLASS="t">Triggers cannot be used to perform cascading updates and deletes if foreign key-to-primary key relationships, or foreign key-to-unique relationships, have been established using SQL Server's DRI. The DRI constraints are tested first; the trigger only fires if the update or delete passes all constraint restrictions. Therefore, because any update or delete that would need to be cascaded would fail the constraint checking, DRI FOREIGN KEY constraints must not exist on those relationships that need to be cascaded.</P>
<P CLASS="t">By not declaring the FOREIGN KEY (or REFERENCES) constraints, the cascading updates and deletes can be implemented using triggers. The PRIMARY KEY and UNIQUE constraints should still be used, however. </P>
<P CLASS="t">A delete trigger on the primary table either deletes the rows in the dependent table(s) or sets all corresponding foreign keys to NULL (or their default value). The cascading delete is easily performed with nested triggers, each deleting all rows in dependent tables. Cascading triggers that set null or defaults may be more problematic due to multirow considerations with triggers if the updates must be cascaded to additional levels of dependent tables. However, if the foreign keys are not part of the dependent table's primary key, they can be updated from within the trigger.</P>
<P CLASS="t">For implementing cascaded updates, an update trigger on the primary table should perform the required data modifications on the secondary table(s). Again, as long as the foreign key being updated is not part of the dependent table's primary key, it can be updated from within the trigger.</P>
<P CLASS="t">The following is an example of a cascading delete trigger on the <B>titles </B>table that deletes all rows in the <B>titleauthor</B> table with matching foreign key values. Because <B>title_id</B> is part of the primary key of <B>titleauthor</B>, this trigger assumes there are no subsequent levels of tables with foreign keys referring to <B>titleauthor</B>. This will work correctly even for multirow deletes.</P>

<PRE>CREATE TRIGGER DelCascadeTrig
    ON titles
    FOR DELETE
AS
    DELETE titleauthor
        FROM titleauthor, deleted
        WHERE titleauthor.title_id = deleted.title_id
</PRE>
<P CLASS="t">The following is an example of setting a null within a delete trigger on the <B>titles </B>table that updates all rows in the <B>titleauthor</B> table with matching foreign key values. Again, because <B>title_id </B>is part of the primary key of <B>titleauthor</B>, this trigger assumes there are no subsequent levels of tables with foreign keys referring to <B>titleauthor</B>. This also works for multirow deletes. </P>

<PRE>CREATE TRIGGER DelSetNullTrig
    ON titles
    FOR DELETE
AS
    UPDATE titleauthor
        SET titleauthor.title_id = NULL
            FROM titleauthor, deleted
            WHERE titleauthor.title_id = deleted.title_id
</PRE>
<P CLASS="t">The following is an example of a cascading update trigger on the <B>titles</B> table that updates all rows in the <B>titleauthor</B> table with matching foreign key values. Again, because <B>title_id</B> is part of the primary key of <B>titleauthor</B>, this trigger assumes there are no subsequent levels of tables with foreign keys referring to <B>titleauthor</B>. </P>

<PRE>CREATE TRIGGER UpdCascadeTrigBad
    ON titles
    FOR UPDATE
AS
    IF UPDATE(title_id)
    BEGIN
        UPDATE titleauthor
            SET titleauthor.title_id = inserted.title_id
                FROM titleauthor, deleted, inserted
                WHERE titleauthor.title_id = deleted.title_id
        END
    END
</PRE>
<P CLASS="t">This will NOT work correctly for multirow updates because there is no way to match a given row in the deleted table with its corresponding row in the inserted table without adding a second unique identifier that never changes its value. This is the same problem that arises when cascading needs to be taken to subsequent levels and the foreign key is part of the primary key in the dependent table and the primary key in the dependent table is referred to by other foreign keys. </P>
<P CLASS="t">To prevent multirow updates, the preceding trigger should be rewritten to prevent the update from affecting more than one row of the original table (<B>titles</B>, in this case). The update in the trigger may well update more than one row in <B>titleauthor</B>; however, this solution to the multirow problem might just cause the problem to reappear at the next level of the cascade.</P>

<PRE>CREATE TRIGGER UpdCascadeTrig
    ON titles
    FOR UPDATE
AS
    IF UPDATE(title_id)
    BEGIN
      IF @@ROWCOUNT = 1
        UPDATE titleauthor
            SET titleauthor.title_id = inserted.title_id
                FROM titleauthor, deleted, inserted
                WHERE titleauthor.title_id = deleted.title_id
      ELSE
        ROLLBACK TRANSACTION
        RAISERROR ('Multirow update on table "titles" not allowed.')
      END
    END
</PRE>
<P CLASS="t">For multiple levels of cascading triggers to function properly, the "nested triggers" <B>sp_configure</B> parameter must be 1. Triggers can only be nested to 16 levels.</P>

<PRE>sp_configure nested 'triggers',1
</PRE></BODY></HTML>
