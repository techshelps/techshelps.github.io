<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use Efficient Application Design</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Use Efficient Application Design </H3><P CLASS="t">The role application design plays in SQL Server performance cannot be overstated. Rather than picturing the server in the dominant role, it's more accurate to picture the client as a controlling entity and the server as a puppet of the client. SQL Server is totally under the command of the client regarding the type of query, when the query will be submitted, and how the results will be processed. This in turn has a major effect on the type and duration of locks, amount of I/O and CPU load on the server, and performance.</P>
<P CLASS="t">For this reason, it's important to make the correct decisions during the application design phase. Even if you're using a turnkey application where changes to the client application seem impossible, this doesn't change the fundamental factors that affect performance—namely, that the client plays a dominant role and that many performance problems cannot be resolved without making client changes.</P>
<P CLASS="t">With a well-designed application, SQL Server is capable of supporting thousands of concurrent users. With a poorly-designed application, even the most powerful server platform can bog down with just a few users. </P>
<P CLASS="t">The following suggestions for client application design are known to improve SQL Server performance: </P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Use small result sets.
<P CLASS="lt1">Retrieving needlessly large result sets (say, thousands of rows) for browsing on the client adds CPU and network I/O load, makes the application less capable of remote use, and can limit multiuser scalability. It's better to design the application to prompt the user for sufficient input so that only queries that generate modest result sets are submitted. Application design techniques that help ensure a small result set include exercising control over wildcards when building queries, mandating certain input fields, and disallowing ad hoc queries.</P></LI><LI CLASS="ULI1">Use <B>dbcancel()</B> correctly in DB-Library applications.
<P CLASS="lt1">All applications should allow cancellation of a query in progress. No application should force the user to reboot the client computer to cancel a query because this can lead to unresolvable performance problems. </P>

<P CLASS="lt1">When <B>dbcancel()</B> is used, proper care should be exercised regarding transaction level. The same issues apply to ODBC applications, where the ODBC <B>sqlcancel()</B> call is used. For more information, see "Causes of the Transaction Log Filling Up" in SQL Server Books Online.</P></LI><LI CLASS="ULI1">Always process all results to completion.
<P CLASS="lt1">Do not design an application or use a turnkey application that stops processing result set rows without canceling the query. Doing so will usually lead to blocking and slow performance.</P></LI><LI CLASS="ULI1">Always implement a query time-out. 
<P CLASS="lt1">Do not allow queries to run indefinitely. Make the appropriate DB-Library or ODBC calls to set a query time-out.</P>

<P CLASS="lt1">With DB-Library, this is done with <B>dbsettime()</B>; with ODBC use <B>SQLSetStmtOption()</B>.</P></LI><LI CLASS="ULI1">Do not use an application development tool that does not allow explicit control over the SQL statements sent to the server.
<P CLASS="lt1">Do not use a tool that transparently generates SQL statements based on higher-level objects if it does not provide crucial features such as query cancellation, query time-out, and complete transactional control.</P>

<P CLASS="lt1">It is often not possible to maintain good performance or to resolve a performance problem if the application independently generates "transparent SQL" because this doesn't allow explicit control over transactional and locking issues that are critical to the performance picture.</P></LI><LI CLASS="ULI1">Do not intermix decision support and online transaction processing (OLTP) queries.</LI></UL></SPAN></BODY></HTML>
