<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Investigating a Blocking Problem</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Investigating a Blocking Problem</H2><P CLASS="ls">Identify the SPID at the head of the blocking chain. Most blocking problems happen because a single process holds locks for an extended period of time. This usually causes a chain of blocked processes, similar to a slow moving automobile causing a backup on the freeway. Identify the head of the blocking chain from SQL Enterprise Manager by clicking <B>CurrentActivity</B> on the <B>Server</B> menu and observing the <B>Object Locks</B> tab. Alternatively you can use the following example query, which should return one row for each SPID at the head of a blocking chain. See also Knowledge Base article Q122485, "Identifying SPID Responsible for Lock Chain." </P>
<P>create procedure sp_blocker</P>
<P> as</P>
<P> declare @statement char(255)</P>
<P> if exists (select * from sysprocesses where spid in (select blocked from sysprocesses))</P>
<P> select spid,status,loginame=substring(suser_name(suid),1,12),</P>
<P>  hostname=substring(hostname, 1, 12), blk=convert(char(3),blocked), </P>
<P>  dbname=substring(db_name(dbid),1,10),cmd, waittype</P>
<P> from sysprocesses</P>
<P> where spid in (select blocked from sysprocesses)</P>
<P> and blocked = 0</P>
<P> else</P>
<P> select "No blocking SPIDs found!"</P>
<P></P>
<P CLASS="ls">Find what query the blocking SPID is running by running DBCC INPUTBUFFER (spid), where spid is the blocking SPID. Alternatively you can use SQL Enterprise Manager by clicking <B>Current Activity</B> on the <B>Server</B> menu and double-clicking on the SPID to show the input buffer. Save this information.</P>
<P CLASS="ls">Find the type of locks the blocking SPID is holding by running <B>sp_lock</B>, or querying <B>master..syslocks</B>. Save this information. Below is an example query. Alternatively you can use SQL Enterprise Manager.</P>
<P>select spid, syslocks.type, locktype=name, table_id=id, page</P>
<P>from syslocks, master.dbo.spt_values v</P>
<P>where syslocks.type=v.number</P>
<P>and v.type='L'</P>
<P>and (syslocks.type &amp; 256)=256</P>
<P>and spid=&lt;blocking spid number&gt;</P>
<P></P>
<P CLASS="lt1">Sometimes it's necessary to use queries instead of SQL Enterprise Manager because some types of <B>tempdb</B> blocking problems can prevent running queries that use <B>temp</B> table operations. Using direct queries gives the control necessary to avoid this. An example of a query that results in <B>temp</B> table operations is <B>sp_lock</B>, which does an ORDER BY.</P>
<P CLASS="ls">Find the transaction nesting level and process status of the blocking SPID. Save this information. This is essentially the same number as <B>@@TRANCOUNT</B>, but can be determined from outside the SPID by using the command DBCC PSS. Example syntax:</P>
<P>dbcc traceon(3604) /* return subsequent DBCC output to client rather than errorlog */</P>
<P>go</P>
<P>SELECT SUID FROM SYSPROCESSES WHERE SPID=&lt;blocking SPID number&gt;</P>
<P>go</P>
<P>DBCC PSS (suid, spid, 0) /* where suid is from above, and spid is the blocking spid number */</P>
<P>go</P>
<P CLASS="lt1"><B>Note</B>   The DBCC PSS statement and the format of the PSS structure are undocumented and unsupported. Their discussion in this article is solely intended to aid customers in diagnosing specific types of blocking problems in their existing systems. The DBCC PSS command should not be incorporated in any existing applications. Microsoft may either discontinue or alter the DBCC PSS command and the PSS structure in future versions of SQL Server.</P>
<P CLASS="lt1">In the returned information, note pxcb-&gt;xcb_xactcnt=<I>n</I>, where <I>n</I> is the <B>@@TRANCOUNT</B> value for the SPID. This shows the transaction nesting level for the blocking SPID, which in turn can explain why it is holding locks. For example, if the value is &gt; 0, then the SPID is in the midst of a transaction, in which case it's normal that it retain any exclusive locks acquired. Note also pstat=<I>n</I>, where <I>n</I> indicates the internal status of the SPID. This can indicate why the blocking SPID may itself be waiting for certain events. </P>
<P CLASS="t">You can also determine whether any long-term open transaction exists in the database by using DBCC OPENTRAN(<I>database_name</I>).</P>
<P CLASS="t">By examining the above four pieces of information, you can usually determine the cause of most blocking problems. Following is a discussion of how to use this information to identify and resolve some common blocking scenarios. See also Knowledge Base article Q125770 "Locking Behavior of Updates and Deletes in SQL Server."</P></BODY></HTML>
