<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overview of DBCC</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Overview of DBCC </H2><P CLASS="t">Most file systems and database systems provide integrity checking utilities to periodically verify data structure consistency. For example, the Rdb Management Utility (RMU) performs functions similar to DBCC on the Oracle Rdb relational database.</P>
<P CLASS="t">Integrity checking utilities generally have a long running time when used on large data sets, and DBCC is no different. However, there are several actions that can maximize the performance and minimize the impact of DBCC.</P>
<P CLASS="t">First, a review of the DBCC statements most commonly used for integrity checking: NEWALLOC, CHECKTABLE, and CHECKDB. CHECKDB<B> </B>performs the same checks as CHECKTABLE but for each table in the database in succession.</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">NEWALLOC checks the integrity of all table and index page chains and checks that each page is correctly allocated. It checks the integrity of all extent chains in the database and verifies that each chain is correctly linked. NEWALLOC also checks for object ID consistency between the page, the extent, and system indexes. In general, NEWALLOC<B> </B>checks things at a page and inter-page level. </LI><LI CLASS="ULI1">CHECKTABLE and CHECKDB, by contrast, check things at an intra-page level. In addition to checking the page chain, they check that indexes are in properly sorted order, that the data information inside each page is reasonable, that page offsets are reasonable, that the system index entries for the table are correct, and that the data row count equals the leaf row count for nonclustered indexes. </LI></UL></SPAN><P CLASS="t">DBCC NEWALLOC and CHECKDB<B> </B>perform largely complementary checks and should generally both be run to get a comprehensive check of the database. </P>
<P CLASS="t">By necessity, DBCC is I/O-intensive. For NEWALLOC, running time will be roughly proportional to the database space in use. This is because NEWALLOC<B> </B>spends most of its time doing sequential reads. Time for this will scale linearly with the size of the database. For this same reason, NEWALLOC can be significantly faster on version 6.<I>x</I> because the parallel read-ahead facility increases the scanning rate. </P>
<P CLASS="t">Running time for CHECKDB<B> </B>is more dependent on the number of indexes in the database and number of rows per table, so the time cannot be predicted by the database size alone. Version 6.<I>x</I> uses parallel threads for CHECKTABLE, one to check each index. When combined with the 6.5 read-ahead facility and computers with sufficient memory, CHECKTABLE and<B> </B>CHECKDB<B> </B>can be significantly faster on 6.5 than on 6.0 or 4.2. The amount of memory needed to ensure this would be approximately the amount required to make the SQL page cache (visible with DBCC MEMUSAGE) larger than the largest individual table in the database. On computers with less memory than this, you may want to experiment with disabling read ahead for the CHECKTABLE or CHECKDB<B> </B>session by using trace flag 653. Setting the <B>sp_configure</B> RA worker threads parameter to 0 disables both read ahead and parallel CHECKTABLE. For information about how to use trace flags, see SQL Server 6.5 Books Online. </P>
<P CLASS="t">Tests indicate that SQL Server 6.5 can run DBCC<B> </B>NEWALLOC<B> </B>on a 2 GB database in less than 30 minutes when running on a typical industry-standard, symmetric multiprocessor (SMP) platform. </P>
<P CLASS="t">As for concurrency impact of DBCC, NEWALLOC and CHECKDB<B> </B>are both online checks in that the database can be in use while they run. There is a concurrency impact, but in many cases this is acceptable. NEWALLOC<B> </B>impact is primarily the I/O and CPU load from the check. In addition to the I/O and CPU load, CHECKDB<B> </B>places a shared table lock on each table while it's being checked. While allowing SELECTs, this will prevent modification of the table until CHECKDB moves on to the next table in the database. The share lock is necessary to achieve a reliable check. </P>
<P CLASS="t">It is usually best to run NEWALLOC<B> </B>when update activity in the database is at a minimum, since there is a possibility of spurious errors caused by in-progress changes during the check.</P></BODY></HTML>
