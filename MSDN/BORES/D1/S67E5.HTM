<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Efficient Index Design</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Efficient Index Design</H3><P CLASS="t">Efficient index design is based on an understanding of the SQL Server optimizer as well as the internal index storage structures and the queries that will access the data. Therefore, the following guidelines should be applied to the design of optimal indexes.</P>
<H4 CLASS="h3"><A NAME="sec0"></A>General Guidelines</H4><P CLASS="t">Examine all queries in detail based on the query design guidelines. Base index design on the optimization characteristics of the queries. Important optimizer characteristics are as follows:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">An UPDATE will be direct, provided that a unique index exists from which the query optimizer can determine that no more than one row qualifies for the update and that the target table is the only table in the UPDATE statement. Moreover, the columns being updated must be fixed length rather than variable length. (NULLs are internally stored as variable-length data type columns.)</LI><LI CLASS="ULI1">A DELETE will be direct, provided that a unique index exists from which the query optimizer can determine that either zero or one row qualifies for the update and that the target table is the only table in the DELETE statement.</LI><LI CLASS="ULI1">An INSERT will be direct, provided that the table into which the rows are being inserted cannot be a table that is being read from in the same command. In addition, if rows are being inserted into the target table, then no columns from the target table can be used in the WHERE clause of the query.</LI><LI CLASS="ULI1">Indexes are more efficient when narrow. Narrow indexes result in more index rows per page and fewer index levels. Consequently, a greater number of index key values can be cached, which results in fewer I/Os.</LI><LI CLASS="ULI1">The SQL Server optimizer is capable of analyzing a great number of index and join possibilities. Thus, a greater number of narrow indexes provides the optimizer with more selections than only a few wide indexes. However, do not maintain unnecessary or under-used indexes because they add to storage and maintenance overhead.</LI><LI CLASS="ULI1">The SQL Server optimizer only maintains distribution statistics on the most significant columns of a compound, composite, or multicolumn index. Therefore, selectivity should be great for the first column of the index.</LI><LI CLASS="ULI1">A large number of indexes on a table will affect UPDATE, INSERT, and DELETE performance, since all indexes will be appropriately adjusted. In addition, all paging operations are logged, causing further I/O.</LI><LI CLASS="ULI1">Indexing a column that is frequently updated will severely degrade performance.</LI><LI CLASS="ULI1">Because of storage overhead and I/O considerations, a small contrived index will result in better performance than a larger index. However, there may be a significant tradeoff with respect to maintaining the contrived column.</LI><LI CLASS="ULI1">Attempt to analyze the frequency of use of each critical query because this will point to the indexes that are used the most. Accordingly, apply appropriate optimizations to these indexes first.</LI><LI CLASS="ULI1">Any column in the WHERE clause of a query is a potential index column since the optimizer is primarily focused on this clause.</LI><LI CLASS="ULI1">Indexing small tables (less than one extent (eight pages) in size) is not optimal because it is usually faster and cheaper to perform a table scan.</LI><LI CLASS="ULI1">Design indexes that will generate the fewest number of I/Os by using page reads. An effective approach is to calculate the number of index rows per page and analyze the worst case scenario with respect to the number of reads required to obtain the solution set.</LI></UL></SPAN><H4 CLASS="h3"><A NAME="sec1"></A>Clustered Indexes</H4><P CLASS="t">The following guidelines apply to the design of clustered indexes:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Use the primary key column(s) when used for the WHERE clause of queries.</LI><LI CLASS="ULI1">Examine any columns used in joins.</LI><LI CLASS="ULI1">Queries that return many rows may benefit from the use of a clustered index.</LI><LI CLASS="ULI1">A column that contains a lot of redundant data values (moderate number of unique values) is a candidate for a clustered index.</LI><LI CLASS="ULI1">Columns accessed by range are excellent candidates for clustered indexes.</LI><LI CLASS="ULI1">Clustered indexes should not be built on columns that undergo frequent change because this will result in the entire row moving. You must be especially aware of this in high-volume transaction-processing systems where data tends to be volatile.</LI><LI CLASS="ULI1">Columns used in conjunction with ORDER BY or GROUP BY clauses are candidates for clustered indexes. If such an index exists on the column(s) specified in the ORDER BY, then a worktable will not be created, since the rows are already ordered. GROUP BY always results in the creation of a worktable.</LI><LI CLASS="ULI1">Columns that are accessed sequentially are candidates for clustered indexes.</LI><LI CLASS="ULI1">Do not use clustered indexes for "covered queries." The more columns there are in an index, the greater the chance for index column change, resulting in excessive page I/O.</LI></UL></SPAN><H4 CLASS="h3"><A NAME="sec2"></A>Nonclustered Indexes</H4><P CLASS="t">The following guidelines apply to the design of nonclustered indexes:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Nonclustered indexes are exceptional for use by queries where you get an exact match.</LI><LI CLASS="ULI1">Decision support systems should take advantage of nonclustered indexes since there are few data update, insert, or delete operations. Therefore, a liberal number of nonclustered indexes can be built to aid in information retrieval. However, you may want to drop and rebuild these indexes during data refresh cycles to avoid index-manipulation overhead.</LI><LI CLASS="ULI1">Covered queries are queries in which all the fields identified in the SELECT statement are represented in the nonclustered index; therefore, SQL Server can satisfy the query without accessing the data page. Adding columns to these indexes to enable a covered query can improve performance, but this approach needs to be weighed against the increased update and storage costs of maintaining extra columns in the index.</LI></UL></SPAN></BODY></HTML>
