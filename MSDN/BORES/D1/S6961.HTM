<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Estimating Database Size</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Estimating Database Size</H2><P CLASS="t"><B><I>Estimating database size before you create a database will help you with database planning.</I></B></P>
<P CLASS="t">When you create a database, it is important to accurately specify the amount of space to allocate for it. If you allocate too much space, you waste device space that could be used by other databases. If you allocate too little space, the database may run out of storage space. Although you will be able to easily expand the room allocated to the database at a later date, as long as there is space available on one or more devices, it is recommended that you estimate your database size before you begin.</P>
<P CLASS="t"><B>Note</B>   Although you can perform detailed space calculations, there is still a chance that you will run out of space due to fragmentation, page splits, log overhead, and other factors. For example, in some situations log:data overhead can be 10:1. This means that updating 50 bytes of data can require 500 bytes of overhead. Space calculations can be very difficult to perform with accuracy, and it is recommended that you weigh the time cost of calculating space against the uncertainty of any benefit.</P>
<P CLASS="t">This section will show you how to:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Calculate the size of a table with a clustered index.</LI><LI CLASS="ULI1">Calculate the size of a table with a nonclustered index.</LI></UL></SPAN><P CLASS="t">The following examples are used:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Calculating the size of a 9,000,000-row table with a clustered index</LI><LI CLASS="ULI1">Calculating the size of a 9,000,000-row table with a nonclustered index</LI></UL></SPAN><P CLASS="t">Since the amount of overhead in tables that contain variable-length fields is greater than the overhead in tables containing fixed-length fields, two sets of formulas are presented in this example: one for fixed-length fields and one for variable-length fields.</P>
<P CLASS="proch">To calculate the size of a database </P>
<P CLASS="ls">Add the number of bytes of data and associated overhead.</P>
<P CLASS="ls">Divide that number by the number of bytes available on a data page.</P>
<P CLASS="lt1">Each 2K data page uses 32 bytes of overhead, so there are 2016 (2048 – 32) bytes available for data on each data page. For best accuracy, round down divisions that calculate the number of rows per page, and round up divisions that calculate the number of pages.</P>
<P CLASS="t">If you are using FILLFACTOR in your CREATE INDEX statement, it will change some of the equations. For more information, see "Other Factors" later in this article. If a table includes <B>text</B> or <B>image</B> data types, use 16 bytes—the size of the text pointer that is stored in the row—as indicated in the following examples, and see "Using Average Sizes for <B>text</B>/<B>image</B> Data Pages" later in this article.</P>
<P CLASS="t">The following table shows the storage sizes for SQL Server data types.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="121pt" VALIGN="TOP"><COL WIDTH="225pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P CLASS="thf">Data type</P></TD><TD VALIGN="TOP"><P CLASS="thf">Size</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P CLASS="tr"></P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>char</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">Defined size</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>varchar</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">Data size</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>binary</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">Defined size</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>varbinary</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">Data size</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>int</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">4</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>smallint</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">2</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>tinyint</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">1</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>float</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>float(b)</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">4 (for precision of 1–23), 8 (for precision 24–53)</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>double precision</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>real</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">4</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>money</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>smallmoney</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">4</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>datetime</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>smalldatetime</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">4</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>bit</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">1</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>decimal</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">2–17 bytes, depending on precision</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>numeric</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">2–17 bytes, depending on precision</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>text</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">16 bytes + 2K per initialized column, or data size + <B>text</B>/<B>image</B> overhead, whichever is larger</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>image</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">16 bytes + 2K per initialized column, or data size + <B>text</B>/<B>image</B> overhead, whichever is larger</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt"><B>timestamp</B></P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t"><B>Note</B>   Any columns defined to accept null values must be considered variable-length columns, since they involve the overhead or space savings associated with the variable-length columns and are stored as variable length.</P>
<P CLASS="t">The <B>decimal</B> and <B>numeric</B> data types have a maximum precision of 38. Based on the precision specified, a length is computed and used as the size of the array to store the data type. The following table shows the mapping from precision to size.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="121pt" VALIGN="TOP"><COL WIDTH="225pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P CLASS="thf">Precision</P></TD><TD VALIGN="TOP"><P CLASS="thf">Size</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P CLASS="tr"></P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">0–2</P></TD><TD VALIGN="TOP"><P CLASS="tt">2</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">3–4 </P></TD><TD VALIGN="TOP"><P CLASS="tt">3</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">5–7</P></TD><TD VALIGN="TOP"><P CLASS="tt">4</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">8–9</P></TD><TD VALIGN="TOP"><P CLASS="tt">5</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">10–12</P></TD><TD VALIGN="TOP"><P CLASS="tt">6</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">13–14</P></TD><TD VALIGN="TOP"><P CLASS="tt">7</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">15–16</P></TD><TD VALIGN="TOP"><P CLASS="tt">8</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">17–19</P></TD><TD VALIGN="TOP"><P CLASS="tt">9</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">20–21</P></TD><TD VALIGN="TOP"><P CLASS="tt">10</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">22–24</P></TD><TD VALIGN="TOP"><P CLASS="tt">11</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">25–26</P></TD><TD VALIGN="TOP"><P CLASS="tt">12</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">27–28</P></TD><TD VALIGN="TOP"><P CLASS="tt">13</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">29–31</P></TD><TD VALIGN="TOP"><P CLASS="tt">14</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">32–33</P></TD><TD VALIGN="TOP"><P CLASS="tt">15</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">34–36</P></TD><TD VALIGN="TOP"><P CLASS="tt">16</P></TD></TR><TR><TD VALIGN="TOP"><P CLASS="tt">37–38</P></TD><TD VALIGN="TOP"><P CLASS="tt">17</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">All calculations in the following examples are based on the maximum size for <B>varchar</B> and <B>varbinary</B> data, the defined size of the columns. They also assume that columns were defined as NOT NULL. If you want to use average values for variable-length columns, see "Using Average Sizes for Variable Fields" later in this article.</P></BODY></HTML>
