<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Efficient Query Design</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Efficient Query Design</H3><P CLASS="t">Based on the information regarding the three phases of query optimization, it is obvious that designing queries that minimize physical and logical I/O as well as balance processor and I/O time is the goal of efficient query design. In essence, this means you want to design queries that result in the use of indexes, result in the fewest disk reads and writes, and make the most efficient use of memory and CPU resources.</P>
<P CLASS="t">The following guidelines, which are derived from the optimization strategies of the SQL Server optimizer, will aid in the design of efficient queries. However, before we can discuss the query design guidelines, a few definitions are necessary.</P>
<H4 CLASS="h3"><A NAME="sec0"></A>Definitions</H4><P CLASS="t"><B>Table Scan</B>—A table scan occurs when the SQL Server optimizer can find no efficient index to satisfy a clause or when a clause is nonoptimizable. When the table scan method is used, execution begins with the first row in the table. Each row is retrieved and compared with the conditions in the WHERE clause and then returned to the client if it meets the given criteria. Regardless of how many rows qualify, every row in the table must be looked at; so for very large tables, a table scan can be costly in terms of page I/Os.</P>
<P CLASS="t"><B>Worktable</B>—For some types of queries, such as those that require the results to be ordered or displayed in groups, the SQL Server query optimizer might determine that it is necessary to create its own temporary worktable. The worktable holds the intermediate results of the query, at which time the results can be ordered or grouped, and then the final results can be selected from that worktable. When all results have been returned, the worktable is automatically dropped.</P>
<P CLASS="t">Worktables are always created in the <B>tempdb</B> database, so it is possible that the system administrator might have to increase the size of <B>tempdb</B> to accommodate queries that require very large worktables. Because the query optimizer creates these worktables for its own internal use, the names of the worktables will not be listed in the <B>tempdb..sysobjects</B> table.</P>
<H4 CLASS="h3"><A NAME="sec1"></A>Query Design Guidelines</H4><P CLASS="t">Here are the guidelines:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">WHERE clauses that direct index selection should be of the following form:</LI></UL></SPAN><P>WHERE<I> column operator constant</I> AND <I>expression<BR></I></P>
<P CLASS="lt1">Or</P>
<P>WHERE<I> constant operator column</I> AND <I>expression</I></P>
<P></P>
<P CLASS="lt1">where <I>operator</I> is =, &gt;, &gt;=, &lt;, or =&lt; and all columns are in the same table.</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">A WHERE clause with BETWEEN is treated as a closed interval in the form:</LI></UL></SPAN><P>WHERE<I> column</I> BETWEEN <I>constant</I> AND <I>constant</I></P>
<P></P>
<P CLASS="lt1">generates</P>
<P>WHERE (<I>column</I> &gt;= <I>constant</I> AND <I>column</I> &lt;= <I>constant</I>)</P>
<P></P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">A WHERE clause with LIKE and a trailing wild card is treated as a closed interval in the form:</LI></UL></SPAN><P>WHERE<I> column </I>LIKE <I>constant%</I></P>
<P></P>
<P CLASS="lt1">generates</P>
<P>WHERE (<I>column</I> &gt;= <I>constant</I> AND <I>column</I> &lt; <I>constant</I>)</P>
<P></P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Expressions or data conversions in a WHERE clause are not likely to result in an index selection by the optimizer—for example:</LI></UL></SPAN><P>paycheck * 12 &gt; 36000</P>
<P></P>
<P CLASS="lt1">Or</P>
<P>substring(city,1,1) = "C"</P>
<P></P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">WHERE clauses with the "=" operator result in the best performance if a unique index is available. Closed intervals (ranges) are next best; open intervals follow.</LI><LI CLASS="ULI1">WHERE clauses that contain disjunctions (OR or IN) do not generally result in the best performance from a data-access perspective. Therefore, the optimizer can elect to use the "OR strategy." This strategy results in the creation of a worktable that contains row IDs for each possible matching row. The optimizer considers these row IDs (page number and row number) to be a "dynamic index" pointing to a table's matching rows. Accordingly, the optimizer scans the worktable, getting each row ID, and retrieves the corresponding rows from the data table. Consequently, the cost of the "OR strategy" is the creation of the worktable.
<P CLASS="lt1">The SQL Server optimizer elects to use the "OR strategy" based on the following conditions:</P>


<UL><LI CLASS="ULI2">All columns of the OR clause must belong to the same table.</LI><LI CLASS="ULI2">If any portion of the OR clause requires a table scan (due to lack of index or poor selectivity of a given index), a table scan will be used for the entire query.</LI><LI CLASS="ULI2">If any other access plan will result in fewer I/Os (less cost), it will be used.</LI></UL></LI><LI CLASS="ULI1">A WHERE clause containing NOT, &lt;&gt;, or != is not useful to the optimizer for index selection. This is due to the exclusive, rather than inclusive, nature of such clauses. Consequently, the selectivity of the clause cannot be determined before scanning the entire underlying table.</LI><LI CLASS="ULI1">Local variables in WHERE clauses are considered to be unknown and are not considered by the optimizer. The exception to this are variables defined as the input parameters of stored procedures.</LI><LI CLASS="ULI1">Limit data conversions and string manipulations because these are resource intensive, especially when applied to large data sets.</LI><LI CLASS="ULI1">Worktables are created by the SQL Server optimizer as follows:

<UL><LI CLASS="ULI2">GROUP BY—Always requires a worktable.</LI><LI CLASS="ULI2">ORDER BY—Only if an index is not available for index ordering or the available indexes are in conflict with the SQL Server "sort order."</LI><LI CLASS="ULI2">SELECT INTO—Builds the worktable in the user database and not in <B>tempdb</B> unless instructed to do so.</LI><LI CLASS="ULI2">DISTINCT—There is no need to use DISTINCT for columns that are covered by a unique index.</LI><LI CLASS="ULI2">If no indexes that cover a join clause are found, a worktable is built to hold the rows from the smallest table in the join. A clustered index is then built on this table to accomplish an efficient join. Therefore, the cost is the generation of the worktable and the subsequent creation of the clustered index. This process is called <I>reformatting</I>.</LI></UL></LI></UL></SPAN><P CLASS="t">Therefore, attention must be paid to the size of the <B>tempdb</B> database (except for SELECT INTO) whether in RAM or on disk. In addition, if these types of operations are common, placing <B>tempdb</B> in RAM can be beneficial to performance.</P>
<H4 CLASS="h3"><A NAME="sec2"></A>Concurrency and Consistency</H4><P CLASS="t">The importance of understanding concurrency issues is paramount to the efficient execution of queries on multiuser SQL Server systems. Dealing with concurrency and consistency issues in database queries and applications is an example of needing to understand and balance conflicting objectives.</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Concurrency—An attempt to maximize the number of simultaneous transactions, or users.</LI><LI CLASS="ULI1">Consistency—The need to ensure that the operations performed by users in a multiuser environment are equivalent to the results that would be obtained if users ran their transactions serially.</LI></UL></SPAN><P CLASS="t">These are competing requirements that need to be balanced against each other. SQL Server provides the means to ensure transaction consistency, or serializability, through locking. The most important concurrency guidelines to remember when designing efficient queries are as follows:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Avoid situations in which many processes are attempting to perform updates or inserts on the same data page. This can occur in a nonindexed table because all additions are applied to the last page in the chain. Creating separate history tables that are accessed by various groups can minimize the delay in this situation. Creating a clustered index to distribute data will also help.</LI><LI CLASS="ULI1">Avoid transactions that include user interaction. Because locks are held for the duration of the transaction, a single user can degrade the entire system performance if the user does not respond in a timely manner.</LI><LI CLASS="ULI1">Keep transactions that modify data as short as possible. The longer the transaction, the longer the exclusive or update lock is held. This blocks other activity and can lead to an increased number of deadlock situations.</LI><LI CLASS="ULI1">Keep transactions in one batch. Unanticipated network problems can delay completion of transactions and releasing locks.</LI><LI CLASS="ULI1">Use HOLDLOCK only when necessary because updates can be delayed by waiting for shared locks to be released.</LI><LI CLASS="ULI1">To help diminish the chance of random updates requiring the same page, reduce the fill factor when creating an index. This is especially useful for small tables that are frequently accessed.</LI><LI CLASS="ULI1">By using the SQL Server cursor extensions to DB-Library or ODBC, optimistic concurrency control can be specified. This is ideal for applications that require a high degree of user interaction combined with high concurrency. This option ensures that update locks are obtained only when a user wants to commit a transaction.</LI><LI CLASS="ULI1">Avoid deadlocks. Deadlocks occur when user processes are competing for resources and a circular chain of dependency for locks results. SQL Server automatically detects deadlocks and ends one of the user transactions involved in the transaction. The user application must then resubmit the stopped query—a time consuming process. Some deadlocks are unavoidable, but many deadlocks can be avoided by acquiring resources in the same order.
<P CLASS="lt1">The following illustration shows how deadlocks can be unnecessarily introduced into an application when resources are not acquired in the same order.</P></LI></UL></SPAN><P CLASS="a"><img src="bok841.gif"></P>
<H4 CLASS="h3"><A NAME="sec3"></A>Stored Procedures and Views</H4><P CLASS="t">The following illustration gives a high-level overview of how stored procedures and Transact-SQL queries are handled by SQL Server.</P>
<P CLASS="a"><img src="bok842.gif"></P>
<P CLASS="t">When a stored procedure is created, the ASCII text of the stored procedure is stored in the <B>syscomments</B> table, and a normalized form of the query, called a query tree, is stored in the <B>sysprocedures</B> table. The query tree has already been parsed.</P>
<P CLASS="t">When a stored procedure is executed for the first time after SQL Server has been started, the query tree is brought into memory, passed through the query optimizer to create an access plan, and stored in the procedure cache. The access plan created on this first pass is used for all subsequent calls to this copy of the stored procedure.</P>
<P CLASS="t">Stored procedures are reusable, but not re-entrant; therefore, only one user can execute a given copy at a time. If two or more users execute a stored procedure at the same time, SQL Server loads two copies of the procedure into the procedure cache. When one user finishes, his copy of the stored procedure is available to the next user, and so on.</P>
<P CLASS="t">Since the access plan for a stored procedure is created from the first set of user data, the access plan may not be the best one for all users of the stored procedure. If the value of parameters passed to a stored procedure vary widely, and may benefit from a new access plan each time, you can create or execute the stored procedure using the WITH RECOMPILE option. Even though using WITH RECOMPILE can impact performance, there are still the benefits that accrue from enforcing consistent, modularized access.</P>
<P CLASS="t">Stored procedure input parameters that will be used in a WHERE clause should match the data type of the column against which they are being compared. The exception is a <B>char(n)</B> column, which allows NULLs. This should be represented as a <B>varchar(n)</B> column since SQL Server treats NULL columns as variable length. This will decrease the overhead of data conversion.</P>
<P CLASS="t">As with stored procedures, views are stored on disk in query tree format, which is the output of parsing and normalization. When executed, views and stored procedures must go through compilation to determine the optimal access plan to get to the data. However, unlike stored procedures, views are kept in the procedure cache only in query tree format, so they must be recompiled each time they are used.</P></BODY></HTML>
