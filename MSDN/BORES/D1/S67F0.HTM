<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQL Query Structure Analysis</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">SQL Query Structure Analysis</H3><P CLASS="t">After other performance-limiting factors have been considered, you should examine the structure of the SQL query and analyze if intelligent indexes are available for selection by the query optimizer. The following questions will help you fine-tune the query and available indexes.</P>
<P CLASS="term1"><B>Are there any unmatched data types?</B></P>
<P CLASS="dt1">Unmatched data types may indicate that a join clause is comparing values of different data types. A common problem is a join clause involving two character columns where one column is defined as <B>char</B>/not null and the other as <B>char/</B>null represented internally as <B>varchar</B>. The optimizer considers the two columns being joined as separate data types and therefore may not consider the clause an optimizable one.</P>
<P CLASS="term1"><B>Are there a lot of string operations or data conversions?</B></P>
<P CLASS="dt1">If there is a significant number of string operations or data conversions in the SQL statement, they may be more appropriate in the calling application. Extensive string manipulation and data conversions consume processor resources. On a heavily loaded SQL Server, this resource consumption may cause queries to perform slowly.</P>
<P CLASS="term1"><B>Are efficient indexes being used?</B></P>
<P CLASS="dt1">Look at the table(s) being accessed by the query being analyzed to determine if any indexes exist. You can access this information by using SQL Enterprise Manager or by executing the <B>sp_help</B> stored procedure. If indexes do exist, do they meet the index selection and efficient design criteria discussed in "Query and Index Design," earlier in this part? Remember, the index must be considered "useful" by the optimizer before it is selected.</P>
<P CLASS="term1"><B>Are the existing indexes useful?</B></P>
<P CLASS="dt1">Is the optimizer selecting any of the available indexes? To determine this, set the following Transact-SQL options ON:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI2">SET SHOWPLAN ON—Generates a description of the query execution plan for the query.</LI><LI CLASS="ULI2">SET NOEXEC ON—Compiles a query but does not execute it. This option must be turned off to execute queries.</LI></UL></SPAN><P CLASS="dt1">After the query execution plan is available for viewing, check for references to<B> </B>Using Clustered Index or Index: <I>index_name</I>; the associated clustered or nonclustered index will be used for that portion of the query. If Table Scan is displayed, the query optimizer did a row-by-row sequential scan of the table due to lack of a useful index or because such a scan is cheaper in terms of I/O processing than using an index.</P>
<P CLASS="term1"><B>Why isn't the optimizer choosing an index?</B></P>
<P CLASS="dt1">If the optimizer has indexes to choose from but does not select them, check for the following causes:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI2">The data in the table has changed significantly since the original indexes were created. Executing the UPDATE STATISTICS statement against the table(s) or index(es) will refresh the distribution statistics and result in a higher probability of index selection by the optimizer.</LI><LI CLASS="ULI2">The available indexes were no better than a table scan with respect to the amount of I/O that would be incurred. This is because the indexes either had no relationship to the SELECT list and/or the WHERE<B> </B>clause, or the subsequent reading of the index plus the reading of the data is more expensive than just reading the data sequentially—the table itself is smaller than the combination of the table and the index.</LI></UL></SPAN><P CLASS="dt1">Addressing these problems generally results in more efficient queries. Nonetheless, if the distribution statistics are current and it appears that an index was appropriate, further investigation of the optimizer selection process is warranted.</P>
<P CLASS="term1"><B>What is the optimizer thinking?</B></P>
<P CLASS="dt1">To obtain a detailed description of the index-selection criteria and join plan associated with a query, perform the following steps by using ISQL/w or SQL Enterprise Manager:</P>
<P CLASS="ls2">Execute DBCC TRACEON (-1)—Turns tracing on for all connections.</P>
<P CLASS="ls2">Execute DBCC TRACEON (3604)—Sends output to the screen.</P>
<P CLASS="ls2">Execute DBCC TRACEON (302)—Prints information about the optimizer's index selection.</P>
<P CLASS="ls2">Execute DBCC TRACEON (310)—Prints information about the optimizer's join selection.</P>
<P CLASS="ls2">Execute the query being analyzed.</P>
<P CLASS="ls2">Execute DBCC TRACEOFF (-1)—Turns tracing off for all connections.</P>
<P CLASS="dt1">The output from these steps reveals the selection criteria for indexes and joins and the number of access plans considered for the query.</P>
<P CLASS="term1"><B>What if the query is slow even with an index?</B></P>
<P CLASS="dt1">If the optimizer chooses an index but the query is still slow, the problem may be resource oriented. Use the memory-monitoring techniques discussed earlier to determine if excessive paging is occurring. If this is the case, you will need to review the size and makeup of the index. Remember, the smaller the index, the better. You may also want to change the FILLFACTOR to include more indexes on an index page. However, this can result in more frequent page splits, which decreases performance.</P></BODY></HTML>
