<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Running the Deadlock Demonstration</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Running the Deadlock Demonstration</H3><P CLASS="t">Deadlock.sql installs two tables and three procedures that easily demonstrate deadlocks when executed from separate ISQL/w sessions.</P>
<P CLASS="t">Deadlock.sql installs two tables, checking and savings, then populates them with data. Each row in the two tables has an <B>Id</B> column as the primary key.</P>
<P CLASS="t">The three procedures installed by Deadlock.sql take an <B>Id</B> and an amount as parameters. The procedures transfer the amount specified between tables for the <B>Id</B> specified.</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1"><B>xfer_to_savings</B>
<P CLASS="lt1">This procedure is installed first. It decrements the row pointed to by the <B>Id</B> parameter in the checking table, then increments the <B>Id</B> row in the savings table. This causes it to first lock a page in the checking table, then lock a page in the savings table.</P></LI><LI CLASS="ULI1"><B>xfer_to_checking_1</B>
<P CLASS="lt1">This procedure is installed second. It accesses the tables in reverse. It first decrements the savings table, then increments the checking table, so it first locks a page in savings and then locks a page in checking. Since these two procedures request locks on the tables in the reverse sequence, they can deadlock if they are both executed by separate tasks at the same time, where each task specifies the same <B>Id</B>. If this happens, Task1 will have a lock on a row in checking and be waiting for Task2 to free a lock on the page it needs in savings. Task2, meanwhile, is waiting for Task1 to free its lock on the checking table. Since both tasks are waiting for the other to free locks, they will wait forever, which is the definition of a deadlock, or fatal embrace.</P></LI><LI CLASS="ULI1"><B>xfer_to_checking_2</B>
<P CLASS="lt1">This procedure is installed third. It shows how simple it is to prevent the deadlock. Instead of first decrementing savings and then incrementing checking, <B>xfer_to_checking_2</B> does it in the same sequence used by <B>xfer_to_savings</B>. Since both procedures acquire locks in the same sequence, Task2 does not acquire the lock in the savings table that prevents Task1 from completing and freeing the lock it owns in the checking table that Task2 needs to complete its transaction. While Task2 is momentarily blocked by Task1, Task2 never blocks Task1. When Task1 completes and frees its lock, Task2 can then lock the same page and complete.</P></LI></UL></SPAN><P CLASS="proch">To run the demonstration</P>
<P CLASS="ls">Connect two separate ISQL/w sessions to SQL Server and use the database containing the deadlock demo tables and procedures.</P>
<P CLASS="ls">In the first ISQL/w session execute the command:</P>
<P>xfer_to_savings 10, 100</P>
<P></P>
<P CLASS="ls">Within 20 seconds, in the second ISQL/w session execute:</P>
<P>xfer_to_checking_1 10, 50</P>
<P></P>
<P CLASS="ls">When the 20-second interval expires, one of the tasks will fail with a deadlock error.</P>
<P CLASS="ls">In the first ISQL/w session run a new <B>xfer_to_savings</B>:</P>
<P>xfer_to_savings 55, 250</P>
<P></P>
<P CLASS="ls">In the second ISQL/w session run the following command:</P>
<P>xfer_to_checking_2 55,150</P>
<P></P>
<P CLASS="ls">When the 20-second interval expires, both tasks will complete successfully.</P></BODY></HTML>
