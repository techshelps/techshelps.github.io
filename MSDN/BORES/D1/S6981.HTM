<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Row-level vs. Page-level Locking</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Row-level vs. Page-level Locking</H3><P CLASS="t">Page-level locking effectively balances locking and deadlock detection overhead with transaction throughput for superior performance. Since all locks are managed in memory, lock acquisition is extremely fast. In the majority of business situations, page-level locking outperforms row-level locking, which is susceptible to excessive lock manager calls and frequent escalation to higher-level locks.</P>
<H4 CLASS="h3"><A NAME="sec0"></A>Superior Concurrency with High Performance</H4><P CLASS="t">The real problem is not locking, but concurrency—locking is simply a means to an end. SQL Server employs advanced database techniques to provide high levels of concurrency, while preserving the performance characteristics of page-level locking. The most important of these include:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Optimistic concurrency control (default)</LI><LI CLASS="ULI1">High granularity locking </LI><LI CLASS="ULI1">Clustered indexes</LI></UL></SPAN><H4 CLASS="h3"><A NAME="sec1"></A>Optimistic Concurrency Control </H4><P CLASS="t">Cursors are database objects which enable applications to manipulate data by rows instead of by sets. Using cursors, multiple operations can be performed row by row against a result set with or without returning to the original table.</P>
<P CLASS="t">SQL Server provides rich, scrollable, engine-based cursors with configurable concurrency modes. SQL Server's <I>optimistic concurrency </I>mode allows users to browse both forward and backward through database rows, and update data without locking any of the data being modified. Instead, SQL Server uses sophisticated methods to detect whether the rows to be changed have been modified since the original retrieval. This protects applications against conflicting updates without locking large amounts of data, so decision support functions can continue to be performed.</P>
<P CLASS="t">Optimistic concurrency control works on the assumption that other transactions usually will not have changed the data being read. Since no locks are maintained on the current row(s) in the cursor, a high degree of concurrency is supported. Other transactions can freely read or write to the data. In the optimistic case, when an application performs an update through the cursor, it proceeds normally. However, if the row has been changed, SQL Server detects this and rejects the update, automatically refreshing the row buffers at the client with the new row information. The application then has the option of reissuing the update using explicit locking. </P>
<P CLASS="t">For row-at-a-time operations, SQL Server's engine-based cursors with optimistic concurrency control provide the highest level of concurrency available for decision support and data warehousing applications.</P>
<H4 CLASS="h3"><A NAME="sec2"></A>High Granularity Locking</H4><P CLASS="t">SQL Server employs advanced strategies to improve the level of locking granularity and performance to provide greater concurrency, compared to other page-locking systems. There is now minimal extent locking during index creation or allocation of pages from an extent. Locking is eliminated entirely for databases that are in single-user mode or are defined as read-only. SQL Server employs new update locks that prevent multiple writers from trying to acquire exclusive locks at the same time. This significantly reduces deadlocks and retries, resulting in higher system throughput. Additionally, the lock manager itself has been made parallel and reentrant for better scalability on symmetric multiprocessing (SMP) platforms.</P>
<H4 CLASS="h3"><A NAME="sec3"></A>Clustered Indexes</H4><P CLASS="t"><I>Hot spotting</I> is a significant problem with traditional page-level locking designs. In database terms, a hot spot occurs when inserts become concentrated on the last page in the table, thus causing a bottleneck. This normally occurs when data is not ordered. SQL Server uses clustered indexes<I> </I>to prevent this. In SQL Server, clustered indexes store the data in index order<SPAN CLASS="Symbol">¾</SPAN>by incorporating the data pages into the B-tree structure of the index itself. Clustered indexes offer significant benefits, such as reduced disk I/O and increased performance in retrieval-intensive applications. The desired data can typically be accessed in a single disk read, where standard SQL implementations require multiple reads. Clustered indexes prevent hot spotting because row insertions are automatically spread throughout the table, overcoming a weakness of other page locking designs. To minimize page splitting during inserts, SQL Server allows the DBA to set a specific <I>fill factor</I> for a clustered index. The fill factor preserves and automatically maintains space in each page for new rows. </P></BODY></HTML>
