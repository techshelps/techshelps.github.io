<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Locking in SQL Server 6.5</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Locking in SQL Server 6.5</H2><P CLASS="t">Microsoft SQL Server continues to support customizable locking when viewing data using SELECT. The level of visibility can be specified in the SELECT statement or with the transaction isolation level option for the entire session. The transaction isolation level can be set to achieve the following:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Ignore other users' locks, potentially viewing their uncommitted changes.</LI><LI CLASS="ULI1">View only committed changes made by other users and only lock data that has changed but is not yet committed by this transaction.</LI><LI CLASS="ULI1">Use locks to prevent other users from changing data that the SQL Server transaction has viewed until the transaction completes.</LI></UL></SPAN><P CLASS="t">SQL Server further reduces contention by using <I>optimistic </I>concurrency control<I>.</I> With optimistic concurrency control, no locks are held on the rows used to populate a cursor. Transactions that are executing concurrently are not prevented from reading or updating these rows. When a change is made to a row through the cursor, SQL Server checks to see if the row has changed since it was read. The update only succeeds if the row has not been changed during the intervening period. Once updated, data is locked until committed. Optimistic concurrency control is ideal for client/server applications that allow users to browse data and make selective changes.</P>
<P CLASS="t">SQL Server uses the <I>page</I> as a unit of storage and the area protected by a lock. Page-level locks are fast when several rows are updated per page, because they use less locks and therefore less overhead. In most cases, page-level locking is adequate, although contention can occur on pages that users frequently access. Contention occasionally occurs when a particular row or group of rows is updated frequently. More often, contention occurs when rows are inserted at the end of a table. Insert row-level locking (IRL) addresses the latter by allowing multiple users to simultaneously insert new rows on the same page in the table. Microsoft plans to add row-level locking for updates and deletes in future development.</P>
<P CLASS="t">An understanding of how data and indexes are stored is required to appreciate how SQL Server implements insert row-level locking effectively.</P></BODY></HTML>
