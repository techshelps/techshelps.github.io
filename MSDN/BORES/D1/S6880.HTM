<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multitasking</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Multitasking</H2><P CLASS="t">Windows 3.<I>x</I> can run multiple applications at the same time as long as all of the programs are well behaved. Windows 3.<I>x</I> is a <I>cooperative multitasking </I>environment. Each application must tell the system that it has finished processing, before any other application can start, by calling <B>GetMessage</B>.<B> </B>If an application does not yield control, then the user will not be able to switch to another program.</P>
<P CLASS="t">How do you prevent an application from hogging the system? The two basic approaches are to use <B>PeekMessage </B>or a timer.</P>
<P CLASS="t"><B>PeekMessage</B> allows the application to continue processing until another application needs to process a message. After performing a small part of the job, your application must yield to Windows by using <B>WaitMessage</B>.<B> </B>This gives other programs a chance to use the system. When the system is available again, you can process another small part of your job.</P>
<P CLASS="t">When you use a timer, the application executes a chunk of the job whenever you receive a message from the timer.</P>
<P CLASS="t">Obviously, both of these approaches add unnecessary complexity to the application. Applications are not always made up of a series of discrete tasks. Even when an application is easily divided into discrete tasks,<B> </B>you<B> </B>must still keep track of what work has been completed and deal with any errors.</P>
<P CLASS="t">Cooperative multitasking can sometimes make it more difficult to develop client/server applications. If an application makes a synchronous call to some function that performs a lengthy process, Windows 3.<I>x</I> appears to "freeze" until that function finally returns and can yield control back to Windows 3.<I>x</I>.<B> </B>Since synchronous functions like <B>dbsqlexec</B> do not return until the specified query has<B> </B>been compiled and executed,<B> </B>complex queries against very large databases may take some time to complete.<B> </B>SQL Server provides functions that allow any application to communicate asynchronously. <B>dbsqlsend</B> sends a command batch to SQL Server but does not wait for the database processing to complete before it returns control to the caller.<B> </B>It returns it immediately. You can call <B>dbdataready </B>periodically to see when your command has finished, and then call <B>dbsqlok </B>before processing the result set. This makes it much easier to create very responsive applications on the Windows 3.<I>x </I>platform.</P>
<P CLASS="t">Windows 95 and Windows NT provide <I>preemptive multitasking</I>.<B> </B>This means that the operating system can preempt your program at any time, give the CPU to another process, and then return control back to your program's execution without your knowledge or permission. Preemptive multitasking takes the burden off the application developer and puts it on the operating system<I>—</I>where it belongs. Win32 applications do not monopolize the system. The scheduler will preempt them whenever a higher priority process is waiting.</P></BODY></HTML>
