<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Insert Row-level Locking</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Insert Row-level Locking</H3><P CLASS="t">With careful planning and a good understanding of the type and quantity of transactions that make up the database throughput, database designers can work around most major areas of contention. Now, with insert row-level locking (IRL), it is easier to achieve excellent performance for multiuser inserts. Insert row-level locking allows the individual rows on a page to be simultaneously locked by multiple transactions that insert new rows.</P>
<P CLASS="t">The lock manager has been enhanced to provide row-level locking for most INSERT operations. IRL improves performance in situations where access contention and hotspots, which are areas of unusually high access, occur.</P>
<P CLASS="t">Row-level locking is useful when a hotspot develops on tables structured as a sequential file. With SQL Server, hotspots can occur when records are inserted at the end of a table and one of the following conditions exists:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">A table does not have an index.</LI><LI CLASS="ULI1">A table has a nonclustered index, but no clustered index.</LI><LI CLASS="ULI1">A table has a clustered index with a monotonically increasing key (for example, a clustered index on an identity column).</LI></UL></SPAN><P CLASS="t">When concurrent users try to insert data into the table's last page and contend for exclusive page access, a hotspot results. To alleviate these performance bottlenecks, enhancements to the lock manager provide row-level concurrency for INSERT operations. Properly implemented IRL increases the speed of multiuser INSERT operations. For more information on IRL, see SQL Server 6.5 Books Online.</P>
<P CLASS="t"><B>Note</B>   If a clustered index exists on a table, it must be a unique clustered index to take advantage of IRL. (Typically, a unique clustered index is created by default on the column or columns that form the primary key when the primary key is defined.)</P>
<P CLASS="t">The following diagrams illustrate how the type of index used on a table affects the amount of contention that occurs when new rows are inserted.  </P>
<P CLASS="t"><B>Note</B>   In these diagrams, the padlock sign represents a row-level lock from a transaction denoted by T<I>n</I>.</P>
<P CLASS="t">Tables with nonclustered indexes on monotonically increasing keys experience contention at the leaf level of the index. The index benefits from insert-row level locking. </P>
<P CLASS="a"><img src="latch09.gif"></P>
<P CLASS="t">Tables without clustered indexes or with clustered indexes on monotonically increasing keys experience more contention on the last page, and therefore they benefit from insert row-level locking. This diagram represents a table with a clustered index on a monotonically increasing key.</P>
<P CLASS="a"><img src="latch11.gif"></P>
<P CLASS="t">The following diagram represents a table with a nonclustered index on a random key.</P>
<P CLASS="a"><img src="latch10.gif"></P>
<P CLASS="t">The following diagram represents a table with a clustered index on a random key.</P>
<P CLASS="a"><img src="latch12.gif"></P>
<P CLASS="t">Page-level locking is used for deletes and updates and is also used for inserts by default, unless insert row-level locking has been specified. When a transaction needs to update or delete a row on the page with a locked index row, the lock is escalated to an exclusive page-level lock.</P></BODY></HTML>
