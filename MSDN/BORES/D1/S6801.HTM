<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Removing Duplicate Primary Keys from a Table</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Removing Duplicate Primary Keys from a Table</H2><P CLASS="t"><B><I>SQL Server has various mechanisms for enforcing entity integrity, including indexes, UNIQUE constraints, PRIMARY KEY constraints, and triggers.</I></B></P>
<P CLASS="t">Microsoft SQL Server tables should never contain duplicate rows nor nonunique primary keys. Duplicate primary keys are a violation of entity integrity and should be disallowed in a relational system. SQL Server has various mechanisms for enforcing entity integrity, including indexes, UNIQUE constraints, PRIMARY KEY constraints, and triggers.</P>
<P CLASS="t">Despite this, under unusual circumstances, duplicate primary keys occur; when they occur, they must be eliminated. One way they can occur is if duplicate primary keys exist in nonrelational data outside SQL Server, and the data is imported while primary key uniqueness is not being enforced. Another way they can occur is through a database design error, such as not enforcing entity integrity on each table. </P>
<P CLASS="t">Duplicate primary keys are noticed when you attempt to create a unique index, which will quit if duplicate keys are found. This message is:</P>

<PRE>Msg 1505, Level 16, State 1
Create unique index aborted on duplicate key.
</PRE>
<P CLASS="t">This section discusses how to locate and remove duplicate primary keys from a table. However, you should closely examine the process that allowed the duplicates to happen and make changes to prevent its recurrence. </P>
<P CLASS="t">For this example, start ISQL/w and create a table with duplicate primary keys values in the <B>pubs</B> database. In this table, the primary key is the two-column combination <B>col1</B> and <B>col2</B>. </P>

<PRE>create table t1(col1 int, col2 int, col3 char(50))
insert into t1 values (1, 1, "data value one")
insert into t1 values (1, 1, "data value one")
insert into t1 values (1, 2, "data value two")
</PRE>
<P CLASS="t"><B>Note</B>   You cannot create a unique index or PRIMARY KEY constraint since two rows have duplicate primary keys.</P>
<P CLASS="proch">To identify and remove the duplicates </P>
<P CLASS="ls">Identify which rows have duplicate primary key values:</P>
<P>SELECT col1, col2, "num_dups"=count(*)</P>
<P>FROM t1</P>
<P>GROUP BY col1, col2</P>
<P>HAVING count(*)&gt;1</P>
<P></P>
<P CLASS="lt1">This returns one row for each set of duplicate primary key values in the table. The last column in this result set is the number of duplicates for the particular primary key value. </P>
<P>col1        col2        num_dups</P>
<P>----        ----        -------</P>
<P>1            1            2</P>
<P></P>
<P CLASS="ls">If there are only a few sets of duplicate primary key values, the best procedure is to delete these manually on an individual basis. For example: </P>
<P>set rowcount 1</P>
<P>delete from t1</P>
<P>where col1=1 and col2=1</P>
<P></P>
<P CLASS="lt1">The rowcount value should be <I>n</I>–1 where <I>n</I> is the number of duplicates for a given key value. In this example, there are two duplicates, so rowcount is set to 1. The <B>col1/col2</B> values are taken from the above GROUP BY query result. If the GROUP BY query returns multiple rows, the SET ROWCOUNT query will have to be run once for each of these rows. Each time it is run, set rowcount to <I>n</I>–1 where <I>n</I> is the number of duplicates for the particular primary key value.</P>
<P CLASS="lt1">Before deleting the rows, you should verify that the entire row has been duplicated. While unlikely, it is possible that the primary key values are duplicates, yet the row as a whole is not. An example of this would be a table with Social Security Number (SSN) as the primary key that has two different people, or rows, with the same number, each having unique attributes. In such a case, whatever malfunction caused the duplicate key may have also caused valid unique data to be placed in the row. This data should be copied out and preserved for study and possible reconciliation prior to deleting the data. </P>
<P CLASS="t">If there are many distinct sets of duplicate primary key values in the table, it may be too time-consuming to remove them individually. In this case, the following procedure can be used: </P>
<P CLASS="proch">To identify and remove many distinct sets of duplicates</P>
<P CLASS="ls">Run the above GROUP BY query to determine how many sets of duplicate primary key values exist and the count of duplicates for each set.</P>
<P CLASS="ls">Execute <B>sp_dboption</B> on the <B>pubs</B> database.</P>
<P>sp_dboption pubs, "select into/bulkcopy", true</P>
<P></P>
<P CLASS="ls">Select the duplicate key values into a holding table. For example:</P>
<P>SELECT col1, col2, "num_dups"=count(*)</P>
<P>INTO holdkey</P>
<P>FROM t1</P>
<P>GROUP BY col1, col2</P>
<P>HAVING count(*) &gt; 1</P>
<P></P>
<P CLASS="ls">Select the duplicate rows into a holding table, eliminating duplicates in the process. For example:</P>
<P>SELECT DISTINCT t1.*</P>
<P>INTO holddups</P>
<P>FROM t1, holdkey</P>
<P>WHERE t1.col1 = holdkey.col1</P>
<P>AND t1.col2 = holdkey.col2</P>
<P></P>
<P CLASS="ls">At this point, the <B>holddups</B> table should have unique primary keys; however, this will not be the case if <B>t1</B> had duplicate primary keys, yet unique rows (as in the SSN example above). Verify that each key in <B>holddups</B> is unique and that you do not have duplicate keys, yet unique rows. If this query returns any rows, you have duplicate keys only (no unique rows).</P>
<P>SELECT col1, col2, "num_dups"=count(*)</P>
<P>FROM holddups</P>
<P>GROUP BY col1, col2</P>
<P>HAVING count(*)&gt;1</P>
<P></P>
<SPAN CLASS="list"><UL><LI CLASS="ULI2">If the query returns no rows, you have no duplicate keys. Continue with step 6.</LI><LI CLASS="ULI2">If the query returns rows, you have duplicate keys, yet unique rows. Stop here and reconcile which of the rows you want to keep for a given duplicate key value. This will usually entail either discarding a row or creating a new unique key value for this row. Take one of these two steps for each such duplicate primary key in the <B>holddups</B> table.</LI></UL></SPAN><P CLASS="ls">Delete the duplicate rows from the original table. For example:</P>
<P>DELETE t1</P>
<P>FROM t1, holdkey</P>
<P>WHERE t1.col1 = holdkey.col1</P>
<P>AND t1.col2 = holdkey.col2</P>
<P></P>
<P CLASS="ls">Put the unique rows back into the original table. For example:</P>
<P>INSERT t1 SELECT * FROM holddups</P>
<P></P>
<P CLASS="t"></P></BODY></HTML>
