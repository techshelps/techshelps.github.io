<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Overview</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Overview</H2><P CLASS="t">To achieve consistent results during concurrent update activity, any database must impose isolation between transactions. Without isolation, inconsistent results may be seen under concurrent use. Most database products use locks to impose isolation. There are other isolation techniques besides locks, such as versioning (also called time-domain addressing), but each technique has its own cost and overhead. For details see <I>Transaction Processing: Concepts and Techniques</I>, by Jim Gray and Andreas Reuter, ISBN 1-55860-190-2. </P>
<P CLASS="t">Locking, as a means of implementing isolation, is well understood and highly refined in current products. All parts of the transaction must be protected with locks, or else ROLLBACK would not be reliable. Some of the actions needing locking protection may not be obvious. These include locks on system catalog tables, indexes, and allocation structures such as extents.</P>
<P CLASS="t">Locks are automatically acquired by the database server in response to certain types of queries. Locks are not typically acquired under manual programmatic control, although the current product allows this by using optimizer hints. </P>
<P CLASS="t">Locks are not generally intended for use under manual control to implement pessimistic concurrency. For example, one connection should not manually acquire a lock to indicate to other connections the page or row is "in use." Rather, the application should use an "in use" column as a flag to other connections. Alternatively, the application can use a cursor under optimistic concurrency control, which would then signal the application if another connection changed the data during the interval the first connection was browsing the data. For details on implementing cursors, see SQL Server Books Online and Knowledge Base article Q156489, "Overview of SQL Server, ODBC, and DB Library Cursors." </P>
<P CLASS="t">For the best scalability, performance, and concurrency, application and query design should emphasize keeping transaction path length short and holding locks as briefly as possible. The foundation of most concurrency problems is laid when the application and database are designed. For this reason it's critical that these issues be well understood at design time. Otherwise, a hidden performance limitation can be unintentionally engineered into the application, and this may not appear until full-scale stress testing. Stress testing should always be done at the projected full user load to ensure that concurrency at this load factor meets your requirements. Failure to do stress testing may result in concurrency, blocking, and performance problems appearing late in the design cycle or (still worse) after application deployment. Problems discovered at this stage can be very costly to correct.</P>
<P CLASS="t">Different RDBMSs handle locking and concurrency differently. If the application is being ported from one RDBMS to another, you cannot expect the two databases to behave identically. The application may require adjustments, especially if the application takes advantage of a feature or characteristic unique to one RDBMS. This is so even if the application uses only standard ANSI SQL, since locking and concurrency control issues are implementation specific.</P>
<P CLASS="t">The RDBMS designers must balance a tradeoff between locking granularity and overhead. Fine-grain locks at the row or column level can allow more concurrency but also entail greater overhead. This relationship between locking granularity and overhead has been well understood for many years in the academic community (see "Effects of Locking Granularity in a Database Management System," September 1977, and "Locking Granularity Revisited" June 1979, by Daniel Ries and Michael Stonebraker from ACM Transactions on <I>Database Systems</I>). SQL Server locks at the table, page, or (in version 6.5) row level for INSERTs. Future versions of SQL Server will have more extensive row-level locking, but this will not prevent blocking problems.</P>
<P CLASS="t">No matter how fine-grained the locks taken, if the application doesn't exercise good discipline regarding transaction path length and query management, blocking problems can develop. This is analogous to a slow moving automobile causing a backup by driving in the left lane of a freeway. The driver may think that sufficient lanes should be made available for him to drive any way he wishes. However no feasible number of highway lanes will allow drivers to disregard good lane discipline without causing traffic to slow down. Likewise, no RDBMS isolation technique can allow applications to disregard the impact they have on concurrency and scalability.</P></BODY></HTML>
