<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tables and Indexes</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Tables and Indexes</H3><P CLASS="t">Objects in a SQL Server database are stored as a collection of 2K pages. This section describes how the pages for tables and indexes are organized. </P>
<P CLASS="t">The data for each table is stored in a doubly linked list of 2K data pages. Each data page has a 32-byte header containing the table object identifier, a pointer to the previous page in the data chain, a pointer to the next page in the chain, and other internal data. Data rows make up the rest of the data page after the header.</P>
<P CLASS="a"><img src="dbin10.gif"></P>
<P CLASS="t">All of the page chains for tables and indexes are anchored by page pointers in the <B>sysindexes</B> table. Every table will have one chain of data pages, plus additional structures to implement any indexes defined for the table.</P>
<P CLASS="t">Each table and index has a row in the <B>sysusages</B> table uniquely identified by the combination of the object identifier (<B>id</B>) column and the index identifier (<B>indid</B>) column.</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">A table with no clustered index has a row in <B>sysindexes</B> with <B>indid</B> = 0. This row has page pointers to the start and end of the data page chain for that table.</LI><LI CLASS="ULI1">If a clustered index is defined for the table, the row with <B>indid</B> = 0 is replaced by a row with <B>indid</B> = 1. The row with <B>indid</B> = 1 points to both the start of the data page chain for the table and the top of the clustered index.</LI><LI CLASS="ULI1">Each nonclustered index created for the table has a row in <B>sysindexes</B> with an <B>indid</B> from 2 through 254. Each row has one pointer to the top of the index and another pointer to the start of the lowest level of the index.</LI><LI CLASS="ULI1">Each table that has one or more <B>text</B> or <B>image</B> columns also has a row in <B>sysindexes</B> with <B>indid</B> = 255.</LI></UL></SPAN><H4 CLASS="h3"><A NAME="sec0"></A>Table Without Indexes</H4><P CLASS="t">The simplest table structure is a table without indexes. This type of table has one row in <B>sysindexes</B> with <B>indid</B> = 0. The column <B>sysindexes.first</B> points to the first page in the data chain for the table. <B>sysindexes.root</B> points to the page at the end of the data chain for the table. The data chain is a doubly linked list of data pages holding the data rows for the table. The data pages and the rows within them are not stored in any specific order. All inserts simply go to the end of the data page chain.</P>
<P CLASS="a"><img src="dbin11.gif"></P>
<H4 CLASS="h3"><A NAME="sec1"></A>Clustered Index</H4><P CLASS="t">The next step in complexity is a table with a single clustered index. This table has only one row in <B>sysindexes</B>, which will have <B>indid</B> = 1. <B>sysindexes.first</B> points to the first page in the data chain. The pages in the data chain and the rows within them are ordered on the value of the clustered index key. All inserts are made at the point the key value in the inserted row fits in the ordering sequence. <B>sysindexes.root</B> points to the top of the clustered index.</P>
<P CLASS="t">SQL Server indexes are organized as binary trees. Each page in an index holds a page header followed by index rows. Each index row contains a key value and a pointer to either a page or a data row. Each page in an index is called an index node. The top node of the binary tree is called the root node. The bottom layer of nodes in the index are called the leaf nodes. In a clustered index, the data page chain makes up the leaf nodes. Any index levels between the root and the leaves are collectively known as intermediate levels.</P>
<P CLASS="t">The following illustration shows the structure of a table with a clustered index.</P>
<P CLASS="a"><img src="bokind2.gif"></P>
<P CLASS="t">Note that the data rows are stored in sequence on their key value. <B>sysindexes.first</B> points to the start of the data chain; the data chain is also the leaf level of the index. The data rows in the data chain are all ordered on the indexes key. There is one intermediate level in the index. <B>Sysindexes.root</B> points to the root of the binary tree, and from the root node the system can navigate to any node in the structure. Each index node contains index rows that indicate the starting key value and page number of each page in the next lower level.</P>
<H4 CLASS="h3"><A NAME="sec2"></A>Nonclustered Index</H4><P CLASS="t">Nonclustered indexes have the same binary tree structure, but have one significant difference from clustered indexes. This is that the data rows are not stored in order on the keys of the nonclustered index. From the point of view of the nonclustered index, the data rows appear to be randomly distributed through the data pages. Because of this, the leaf layer of a nonclustered index does not consist of the data page chain. The leaf nodes instead contain index rows consisting of key values and pointers to the row (or rows if the index is also nonunique) that have that key value. Also, <B>sysindexes.first</B> points to the first page of the leaf layer of the index, not to the start of the data pages as in the case of a clustered index.</P>
<P CLASS="a"><img src="bokind1.gif"></P>
<H4 CLASS="h3"><A NAME="sec3"></A>Distribution Pages</H4><P CLASS="t">All indexes have a distribution page that contains distribution statistics about the current key values for that index. These statistics are used by the SQL Server optimizer to determine how effectively that index would support the query being optimized. <B>sysindexes.distribution</B> points to the distribution page for the associated index.</P>
<H4 CLASS="h3"><A NAME="sec4"></A>Text and Image Pages</H4><P CLASS="t"><B>Text</B> and <B>image</B> values are not stored as part of the data row but are instead stored in separate page chains of their own. For each <B>text</B> or <B>image</B> value, all that is actually stored in the data row itself is a 16-byte page pointer. For each row, this pointer points to the start of a page chain holding the <B>text</B> or <B>image</B> pages. A row containing multiple<B> text</B> or <B>image</B> columns will have one pointer and chain combination for each <B>text</B> or <B>image</B> column in the row.</P>
<P CLASS="t">The space allocations for all the <B>text </B>and <B>image</B> columns of each table are managed from one row in <B>sysindexes</B>, which has an <B>indid</B> of 255. If a table has multiple <B>text</B> or <B>image</B> columns, it will still only have one row in <B>sysindexes</B> with an <B>indid</B> of 255.</P>
<P CLASS="t">If a row containing a <B>text</B> or <B>image</B> column is inserted with a <B>text </B>or <B>image</B> value set to NULL, then no pages are allocated for that <B>text</B> or <B>image</B> chain. As soon as the row has its <B>text</B> or <B>image</B> value updated, at least one page is allocated to hold the new data value.</P>
<P CLASS="t">In the following query, even though the user specified NULL as a data value, it will still cause the allocation of a 2K text page. </P>

<PRE>UPDATE mytable SET textcol = NULL<BR>WHERE keycol = 'somevalue'
</PRE>
<P CLASS="t">Text and image pages can each hold 1,800 bytes of data.</P>
<P CLASS="a"><img src="dbin14.gif"></P>
<H4 CLASS="h3"><A NAME="sec5"></A>Log Pages</H4><P CLASS="t">The log in a SQL Server database is stored as the <B>syslogs</B> system table. <B>syslogs </B>can be thought of as simply a table with no indexes. The log pages are the data page chain of the <B>syslogs</B> table.</P></BODY></HTML>
