<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Contention</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Contention</H3><P CLASS="t"><I>Contention</I> occurs when two or more transactions try to access data on the same page at the same time and one must wait for the other to complete before it can proceed. In a real-time transaction-processing environment, contention becomes an important issue. Contention may be particularly evident when multiple users are inserting new rows, because often all the new rows are written to the last page in the table's page chain. Similar contention problems can arise when multiple users update or delete rows on the same page. This is not a frequent problem, because many applications typically access data that is randomly distributed over many pages, with only occasional contention for a single page.</P>
<P CLASS="t">As described above, a table with a clustered index contains rows stored in the index. When new rows are inserted, new pages are added to the page chain. The position of new pages depends on the key on which the clustered index was created. Consider a clustered index of a table based on the last name of a customer: as new customers are added, these rows are inserted into the page chain, occasionally splitting pages. Given a random set of new customers, the insertions will be evenly distributed throughout the page chain. The page chain grows by inserting new rows into partially filled pages and splitting pages that are full. If a page splits, changes must be made to the index layer.</P>
<P CLASS="t">In contrast to this, consider a table that has a clustered index based on a chronological column or on a monotonically increasing key, such as an identity value that increments each time a record is added, or an index based on the date and time the record is added. As new rows are inserted, they are added to the end of the page chain, and the page chain grows in one direction. And, because new pages are added to the end of the chain, the overhead of splitting pages is avoided. In a single-user environment, inserting into a table with an index based on a monotonically increasing key is more efficient than inserting into a table with an index based on a random key. The contention problem arises in multitransaction environments where each new insert must lock the last page exclusively. Other transactions must wait their turn, which causes a bottleneck (hotspot)<I> </I>on the last page.</P></BODY></HTML>
