<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Identifying and Resolving Common Blocking Scenarios</TITLE><BODY BGCOLOR="#FFFFFF">


<H2 CLASS="h1">Identifying and Resolving Common Blocking Scenarios</H2><P CLASS="term1"><B>Blocking caused by normally running query with long execution time. </B></P>
<P CLASS="dt1">A long-running query can block other queries. For example, a bulk DELETE or UPDATE can acquire many locks, which (whether they escalate to a table lock or not) block other queries. For this reason, you generally don't want to intermix long-running decision support queries and OLTP queries on the same database. You can identify this situation by observing the blocking SPID. The INPUTBUFFER may point to a query known to have a long execution time. This often causes a steady I/O consumption, visible by running the following query several times in succession:</P>
<P>SELECT SPID, PHYSICAL_IO FROM MASTER..SYSPROCESSES</P>
<P></P>
<P CLASS="dt1">The PHYSICAL_IO value does not always reflect all the work done by a SPID because work done on its behalf by other processes (such as the read-ahead manager) is not charged back to the SPID. However, it's often an approximate indication of I/O activity. If it continuously increases, inspect the query running and determine whether it should be running at the time. Run it in isolation on a quiescent computer, and monitor the I/O activity with SET STATISTICS IO ON. If the query consumes a high amount of I/O resources, it may cause blocking when run on a busy system. The solution is to look for ways to optimize the query by changing indexes, breaking a large complex query into simpler queries, or running the query during off hours or on a separate computer.</P>
<P CLASS="dt1">This class of blocking problem may just be a performance problem and may need pursuing as such. For more information, see Knowledge Base article Q110352, "Optimizing Microsoft SQL Server Performance." One reason queries can be long running and cause blocking is inappropriate use of cursors. Cursors can be a convenient method for navigating through a result set but they may be slower than set-oriented queries. For more information, see <I>Microsoft SQL Server 6.5 Unleashed</I>, by David Solomon, Ray Rankins, et al, ISBN 0-672-30956-4.</P>
<P CLASS="term1"><B>Blocking caused by sleeping SPID that has lost track of transaction nesting level. </B></P>
<P CLASS="dt1">This can often be identified by a SPID that is sleeping, awaiting command, yet whose <B>@@TRANCOUNT</B> is &gt; 0. This can happen if the application issues the DB-Library call <B>dbcancel()</B> or the ODBC call <B>sqlcancel()</B>, without also issuing the required number of ROLLBACK/COMMIT statements. Issuing these calls cancels the query and the batch but does not automatically rollback or commit the transaction. This can be seen by issuing a simple query from ISQL/w, such as BEGIN TRAN SELECT * FROM MASTER..SYSMESSAGES, and clicking <B>Cancel</B>. After the query is canceled, SELECT <B>@@TRANCOUNT</B> indicates the transaction nesting level is 1. Had this been a DELETE or UPDATE query or had HOLDLOCK been used on the SELECT, all the locks acquired would still be held. Applications must properly manage transaction nesting levels or else they can cause blocking following query cancellation. For more information, see Knowledge Base article Q117143 "When and How to Use <B>dbcancel()</B> or <B>sqlcancel()</B>." The transaction nesting level of the SPID can be observed by using DBCC PSS.</P>
<P CLASS="term1"><B>Blocking caused by sleeping SPID whose corresponding client application did not fetch all result rows to completion. </B></P>
<P CLASS="dt1">This is just plain bad application design. After sending a query to the server, all applications must immediately fetch all result rows to completion. If the application does not fetch all result rows, locks can be left on the tables, which can block other users. If you're using an application that transparently submits SQL statements to the server, the application must fetch all result rows. If it does not (and if it cannot be configured to do so), the blocking problem may not be resolvable. A possible solution is restricting such applications to a reporting or decision-support database. This problem can often be identified by the blocking SPID being in a sleeping or awaiting-command state, with a transaction nesting level of 0. If you cannot examine <B>@@TRANCOUNT</B> within the application, it's possible to examine it externally by using DBCC PSS. Sometimes the SPID will have a waittype of 0x800 because after the client application quits fetching result rows, the server will try to write a buffer to the client and wait on the client to pull data from its end.</P>
<P CLASS="term1"><B>Blocking caused by distributed client/server deadlock. </B></P>
<P CLASS="dt1">Unlike a conventional deadlock, which is detectable by using the RDBMS lock manager, a distributed deadlock is not detectable. The blocking SPID often appears sleeping with a waittype of 0x800 (waiting on a network I/0). You cannot use the KILL statement on a SPID in this state because it is waiting on a return from a Windows NT API call. A distributed client/server deadlock can happen if the application opens more than one connection to the RDBMS and submits a query asynchronously. Below are two examples of how this can happen and possible ways the application can avoid this.</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI2">Client/server distributed deadlock with single-client thread. If the client has multiple open connections (dbprocs in DB-Library terms) and a single thread of execution, distributed deadlock can occur. For brevity, we use the term dbproc to refer to the client connection structure. In ODBC API terms, the closest analog is an hdbc.
<P CLASS="lt1">In the preceding case, a single client application thread has two open connections. It asynchronously submits an SQL operation on dbproc1. This means it doesn't wait on the call to return before proceeding. The DB-Library asynchronous call is <B>dbsqlsend()</B>. ODBC applications select asynchronous mode with <B>SQLSetStmtOption()</B> and by using the SQL_ASYNC_ENABLE parameter. The application then submits a SQL operation on dbproc2, and awaits results to start processing the returned data. When data starts coming back (from whichever dbproc first responds), it processes to completion all the data returned on that dbproc. Let's say this is dbproc1. It fetches results from dbproc1, until spid1 gets blocked on a lock held by spid2 (since the two queries are running asynchronously on the server). At this point, dbproc1 will wait indefinitely for more data. Spid2 is not blocked on a lock and tries to send data to it's client, dbproc2. However, dbproc2 is effectively blocked on dbproc1, awaiting the single thread of execution to run.</P></LI><LI CLASS="ULI2">Client/server distributed deadlock with thread per connection. Even if a separate thread exists for each connection on the client, a variation of distributed deadlock can still happen. This is similar to the first case except dbproc2/spid2 is running a SELECT with the intention of performing row-at-a-time processing and handing each row, by using a buffer, to dbproc1 for inserting in the same table. Eventually, spid1 becomes blocked on a lock held by spid2. Spid2 then writes a result row to the client dbproc2. Dbproc2 then tries to pass the row in a buffer to dbproc1 but finds that dbproc1 hasn't yet fetched the last row from the buffer (since it's blocked waiting on spid1, which is blocked on spid2).
<P CLASS="lt1">Both cases are fundamental issues that application developers must be aware of and write code for handling. There are two reliable solutions: use a query time-out or bound connections.</P></LI><LI CLASS="ULI2">Query time-out. By supplying a query time-out, distributed deadlocks are broken when the time-out happens. For more information about using a query time-out, see the DB-Library or ODBC documentation.</LI><LI CLASS="ULI2">Bound connections. This feature allows a client having multiple connections to bind the connections into a single transaction space so they don't block each other. For more information, see "Bound Connections" in SQL Server Books Online. </LI></UL></SPAN><P CLASS="term1"><B>Blocking caused by SPID that is in "golden" or rollback state.</B></P>
<P CLASS="dt1">A data modification query that is killed or canceled outside of a user-defined transaction will be rolled back. This can also occur as a side effect of the client rebooting and its network session disconnecting. Likewise, a query selected as the deadlock victim will be rolled back. A data modification query often cannot be rolled back any faster than the changes were initially applied. In the case of a DELETE, INSERT, or UPDATE that has been running for an hour, it could take at least an hour to roll back. If the server is shut down in the midst of this and then restarted, the database will be in recovery mode and inaccessible until all open transactions are processed. Startup recovery takes essentially the same time per transaction as run-time recovery; plus, the database will be inaccessible during this period. Hence, forcing the server down to fix a SPID in a rollback state will often be counterproductive. This is expected behavior since the changes made must be completely rolled back or else transactional and physical integrity in the database is compromised. Since this must happen, SQL Server will mark the SPID in a "golden" or rollback state, which means it cannot be killed or selected as a deadlock victim. This can often be identified by observing the <B>sp_who</B> output, which may indicate the command of ROLLBACK. However, the most reliable way is to inspect the DBCC PSS of the blocking SPID in question and observe the pstat value. For example, the pstat value might be:</P>
<P>pstat=0x4000, 0x800, 0x100, 0x1</P>
<P></P>
<P CLASS="dt1">The meaning of these bits is:</P>
<P>0x4000 --    Delay KILL and ATTENTION signals if inside a critical                 section</P>
<P>0x2000 --    Process is being killed</P>
<P>x800 --        Process is in backout, thus cannot be chosen as deadlock             victim</P>
<P>x100 --        We're in the middle of a single statement xact</P>
<P>0x1 --        Process has received an ATTENTION signal</P>
<P></P>
<P CLASS="dt1">The above would be a typical situation if a long-running data modification was canceled and the SPID was found to block users, yet be unkillable. This situation is normal; the transaction must be backed out. It can be identified by the above bits.</P>
<P CLASS="dt1">In addition to the pstat field of the PSS, the sysprocesses.waittype field can also give information about why the SPID may be waiting. Below are some common values:</P>
<P>0x800 --     waiting on network I/O completion</P>
<P>0x8011 --     waiting on buffer resource lock(shared) request</P>
<P>0x81 --         waiting on writelog</P>
<P>0x0020 --     waiting on buffer in I/O</P>
<P>0x0005 --     waiting on exclusive page lock</P>
<P>0x13 --         waiting on buffer resource lock(exclusive) request</P>
<P>0x8001 --     waiting on exclusive table lock</P>
<P>0x8007 --     waiting on update page lock</P>
<P>0x8005 --     waiting on exclusive page lock</P>
<P>0x6 --         waiting on shared page lock</P>
<P>0x8006 --     waiting on shared page lock</P>
<P>0x23 --         waiting on buffer being dumped</P>
<P>0x5 --         waiting on exclusive page lock</P>
<P>0x0013 --     waiting on buffer resource lock(exclusive) request</P>
<P>0x0022 --     waiting on buffer being dirtied</P>
<P></P>
<P CLASS="term1"><B>Blocking caused by version 6.5 atomic SELECT INTO behavior. </B></P>
<P CLASS="dt1">By definition, SQL Server treats each statement as a separate transaction. Beginning with SQL Server 6.5, SELECT INTO was made consistent with this standard by including the table creation and data insert phases in a single atomic operation. A side effect of this is that locks on system catalog tables are maintained for the duration of a SELECT INTO statement. This is more frequently seen in <B>tempdb</B>, since applications often select into temporary tables. Blocking caused by this can be identified by examining the locks held by the blocking SPID. The atomic SELECT INTO behavior can be disabled with trace flag 5302. For more information, see Knowledge Base article Q153441, "SELECT INTO Locking Behavior."</P>
<P CLASS="term1"><B>Blocking caused by an orphaned connection.</B></P>
<P CLASS="dt1">If the client application traps or the client workstation is rebooted, under some conditions the network session to the server is not immediately canceled. From the server's perspective, the client appears to be present, and any locks acquired can still be retained. See Knowledge Base article Q137983, "How to Troubleshoot Orphaned Connections in SQL Server."</P></BODY></HTML>
