<HTML><head><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use Efficient Query Design</TITLE><BODY BGCOLOR="#FFFFFF">


<H3 CLASS="h2">Use Efficient Query Design </H3><P CLASS="t">Some types of queries are inherently resource intensive. This is related to fundamental database and index issues common to most RDBMSs, not to SQL Server in particular. They are not inefficient because the optimizer will implement the queries in the most efficient fashion possible. However, they are resource intensive, and the set-oriented nature of SQL Server may make them appear inefficient. No degree of optimizer intelligence can eliminate the inherent resource cost of these constructs. They are intrinsically costly when compared to a more simple query. Although SQL Server will use the optimal access plan, this is limited by what is fundamentally possible.</P>
<P CLASS="t">The following conditions are typically present in resource-intensive queries:</P>
<SPAN CLASS="list"><UL><LI CLASS="ULI1">Large result sets</LI><LI CLASS="ULI1">IN, NOT IN, and OR queries</LI><LI CLASS="ULI1">Highly nonunique WHERE clauses</LI><LI CLASS="ULI1">!= (not equal) comparison operators</LI><LI CLASS="ULI1">Certain column functions, such as SUM and AVG</LI><LI CLASS="ULI1">Expressions or data conversions in WHERE and FROM clauses</LI><LI CLASS="ULI1">Local variables in WHERE and FROM clauses</LI><LI CLASS="ULI1">Complex views with GROUP BY or ORDER BY</LI></UL></SPAN><P CLASS="t">Various factors may necessitate the use of some of these query constructs. The impact of these is lessened if the optimizer can restrict the result set before applying the resource-intensive portion of the query as shown in the following table examples.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="168pt" VALIGN="TOP"><COL WIDTH="180pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P CLASS="thf">Resource intensive</P></TD><TD VALIGN="TOP"><P CLASS="th">Less resource intensive</P></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><P CLASS="tr"></P></TD></TR><TR><TD VALIGN="TOP"><PRE>SELECT SUM(SALARY) FROM TABLE</PRE></TD><TD VALIGN="TOP"><PRE>SELECT SUM(SALARY) FROM TABLE WHERE ZIP='98052'</PRE></TD></TR><TR><TD VALIGN="TOP"><PRE>SELECT * FROM TABLE WHERE
LNAME=@VAR</PRE></TD><TD VALIGN="TOP"><PRE>SELECT * FROM TABLE
WHERE LNAME=@VAR AND ZIP='98052'</PRE></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">In the first example, the SUM operation cannot be accelerated with an index. Each row must be read and summed. Assuming that there is an index on the <B>zip</B> column, the optimizer will likely use this to initially restrict the result set before applying the SUM. This can be much faster.</P>
<P CLASS="t">In the second example, the local variable is not resolved until run time. However, the optimizer cannot defer until run time the choice of access plan but must choose at compile time. Yet at compile time, when the access plan is built, the value of @VAR is not known and consequently cannot be used as input to index selection. </P>
<P CLASS="t">The illustrated technique for improvement involves restricting the result set with an AND clause. An optional technique would be to use a stored procedure and pass as a parameter to the stored procedure the value for @VAR. In some cases it's best to use a group of simple queries and use temp tables to store intermediate results rather than to use a single, complex query. </P>
<P CLASS="t">Large result sets are costly on most RDBMSs. You should try not to return a large result set to the client. It is much more efficient to restrict the size of the result set, since the database back end is much more efficient at performing this function. This also reduces network I/O and makes the application more responsive to deployment across slow, remote, communication links. It also improves concurrency-related performance as the application scales upward to more users.</P></BODY></HTML>
