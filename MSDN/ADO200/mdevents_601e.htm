<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How Event Handlers Work Together</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="mdmschoweventhandlersworktogether"></a>How Event Handlers Work Together</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mdmscHowEventHandlersWorkTogether_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:Specifics">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mdmscHowEventHandlersWorkTogether_S">
</object></p>
<p>
All the event handlers in the <b>ConnectionEvent</b> and <b>RecordsetEvent</b> families must be implemented, regardless of whether you actually use events. The amount of implementation work you have to do depends on your programming language. Some languages, like Microsoft Visual Basic, do all the work for you. Other languages, like Microsoft<sup>®</sup> Visual C++<sup>®</sup>, require you to do all the work. Microsoft<sup>®</sup> Visual J++™ with ADO/WFC takes the middle road and does much of the work for you. For more information, see <a href="mdevents_33ji.htm">ADO Event Instantiation by Language</a>.</p>
<p>
Although implementing the event handler yourself is more work, you can also do things that languages such as Visual Basic won't allow. For example, in Microsoft Visual C++ one <b>RecordsetEvent</b> handler can process notifications from operations on multiple <b>Recordset</b> objects.</p>
<p>
<b>Will</b> and <b>Complete</b> event handlers can be used in pairs or separately.</p>
<p class=label>
<b>Paired Event Handlers</b>
<ul type=disc>
<li>
First, let's examine what happens when a <b>Will</b> event succeeds. <p class=tl>
Imagine paired <b>WillChangeField</b> and <b>FieldChangeComplete</b> events for a <b>Recordset</b> object. In your application, you start to change the value of a field. The <b>WillChangeField</b> event handler is called. You return an indication that it's acceptable to change the field. The operation completes and a <b>FieldChangeComplete</b> event notifies your application that the operation has ended. The event handler status operand reports the success of the operation.</P></li>
<li>
Next, let's examine what happens when a <b>Will</b> event cancels an operation. <p class=tl>
Imagine that you change another field. The <b>WillChangeField</b> event handler is called. You decide for some reason that it is not acceptable to change the field, so you return <b>adStatusCancel</b> in the status operand. As a result, the operation does not complete.</P><p class=tl>
The <b>FieldChangeComplete</b> event notifies you that the operation has ended. The event handler status operand is set to <b>adStatusErrorsOccurred</b>; the error parameter refers to an <b>Error</b> object; and the <b>Error</b> object <b>Number</b> property is set to either an ADO or provider value indicating the operation is canceled.</P></li>
<li>
More than one <b>Will</b> and <b>Complete</b> event handler can be called for the same operation. Let's examine what happens when multiple <b>Will</b> events succeed. <p class=tl>
Imagine paired <b>WillChangeField</b>, <b>FieldChangeComplete</b>, <b>WillChangeRecord</b> and <b>RecordChangeComplete</b> events for a <b>Recordset</b> object. You start to change the value of a field; the <b>WillChangeField</b> event handler is called, and you return an indication that it's acceptable to change the field. </P><p class=tl>
Next, the <b>WillChangeRecord</b> event handler is called, and once again you indicate that the operation should complete.</P><p class=atl>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>In general, all the <b>Will</b> event handlers pertaining to a particular instance of an ADO object will be called. However, they will be called in no particular order.</p><p class=tl>
When the operation completes, the <b>FieldChangeComplete</b> and <b>RecordChangeComplete</b> event handlers are called.</P></li>
<li>
More than one <b>Will</b> and <b>Complete</b> event handler can be called for the same operation, but one may cancel the pending operation. Let's examine what happens when the last of multiple <b>Will</b> events cancels an operation. <p class=tl>
Once again, imagine paired <b>WillChangeField</b>, <b>FieldChangeComplete</b>, <b>WillChangeRecord</b> and <b>RecordChangeComplete</b> events. You start to change the value of a field; the <b>WillChangeField</b> event handler is called, and you return an indication that it's acceptable to change the field. </P><p class=tl>
Next, the <b>WillChangeRecord</b> event handler is called. Perhaps you determine the field change is alright in itself, but it will create an error in the record as a whole. You return <b>adStatusCancel</b> to indicate it is <i>not</i> acceptable to change the field. The <b>WillChangeField</b> event handler has already allowed the operation.</P><p class=tl>
The operation does not complete because it was canceled by the <b>WillChangeRecord</b> event handler. The <b>FieldChangeComplete</b> event handler is called with the status operand set to <b>adStatusErrorsOccurred</b>; the error parameter is set appropriately. </P><p class=tl>
Next, the <b>RecordChangeComplete</b> event handler is also called with the status operand set to <b>adStatusErrorsOccurred</b>. The matching <b>Complete</b> event is called for the <b>Will</b> event. </P></li>
<li>
More than one <b>Will</b> and <b>Complete</b> event handler can be called for the same operation, but one may cancel the pending operation. Let's examine what happens when an event handler other than the last of multiple <b>Will</b> events cancels an operation. <p class=tl>
Once again, imagine the same set of paired event handlers as before. You start to change the value of a field; the <b>WillChangeField</b> event handler is called, and you return <b>adStatusCancel</b> to indicate it is not acceptable to change the field. The operation does not complete; the <b>FieldChangeComplete</b> event notifies you that the operation has ended with the status and error parameters set appropriately. </P><p class=tl>
However, the <b>WillChangeRecord</b> (and thus the <b>RecordChangeComplete</b>) event handler is not called because the first <b>Will</b> event canceled the operation. In general, if a <b>Will</b> event cancels an operation, no remaining <b>Will</b> event handler will be called. </P></li>
</ul>
<p class=label>
<b>Unpaired Event Handlers</b></p>
<p>
You can turn off event notifications for any event by returning <b>adStatusUnwantedEvent</b> in the <b><i>status</i></b> parameter. For example, when your first <b>Complete</b> event handler is called, return <b>adStatusUnwantedEvent</b> and you will subsequently receive only <b>Will</b> events. </p>
<p>
Single <b>Will</b> event handlers can be useful when you want to examine the parameters that will be used in an operation. You can modify those operation parameters or cancel the operation. </p>
<p>
Alternatively, leave <b>Complete</b> event notification turned on, and when your first <b>Will</b> event handler is called, return <b>adStatusUnwantedEvent</b>. You will subsequently receive only <b>Complete</b> events. </p>
<p>
Single <b>Complete</b> event handlers can be useful for managing asynchronous operations. Each asynchronous operation has an appropriate <b>Complete</b> event. </p>
<p>
For example, it can take a long time to populate a very large <b>Recordset</b> object. If your application is appropriately written, you can start a <code>Recordset.Open(...,adAsyncExecute)</code> operation and continue with other processing. You will eventually be notified when the <b>Recordset</b> is populated by an <b>ExecuteComplete</b> event.</p>
<p class=label>
<b>Single Event Handlers and Multiple Objects</b></p>
<p>
The flexibility of a programming language like Microsoft Visual C++ enables you to have one event handler process events from multiple objects. For example, you could have one <b>Disconnect</b> event handler process events from several <b>Connection </b>objects. If one of the connections ended, the <b>Disconnect</b> event handler would be called. You could tell which connection caused the event because the event handler <b><i>object</i></b> parameter would be set to the corresponding <b>Connection </b>object.</p>
<p>
This technique cannot be used in Visual Basic because that language can correlate only one object to an event.</p>
<p class=label>
<b>Multiple Event Handlers and Single Operations</b></p>
<p>
It is possible, though less useful, to associate one ADO object and its operations to multiple sets of events. For example, you could create multiple <b>WillChangeField</b> events to each perform a particular field validation edit. If a field were about to change, one <b>Will</b> event could validate some aspect of the field value, then another <b>Will</b> event could validate a different aspect. </p>
<p>
The reason why this isn't a very useful technique is that you could simply perform or call all your edits from a single event handler. However, we mention the idea for the sake of completeness.</p>
</font></BODY>
</HTML>
