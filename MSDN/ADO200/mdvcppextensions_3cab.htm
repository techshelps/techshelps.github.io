<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using ADO VC++ Extensions</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="mdmscusingadovcextensions"></a>Using ADO VC++ Extensions</h1>
<p>
<object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:See Also">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mdmscUsingADOVCExtensions_C">
</object>&nbsp;&nbsp;&nbsp;<object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="Text" value="Text:Specifics">
<PARAM name="Flags" value=",,1">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="mdmscUsingADOVCExtensions_S">
</object></p>
<p class=label>
<b>Define Binding Entries</b></p>
<p>
The ADO VC++ Extensions map the fields of a <b>Recordset</b> object to C/C++ variables. The definition of a mapping between a field and a variable is called a <i>binding entry</i>. Preprocessor macros are provided to define binding entries for numeric, fixed-length, and variable-length variables. </p>
<p>
Bracket your binding entries between <b>BEGIN_ADO_BINDING</b> and <b>END_ADO_BINDING</b> macros. You should not terminate your binding entries by either commas or semicolons. These delimiters are specified for you within the macros.</p>
<p>
Specify one binding entry for each field to be converted to a C/C++ variable. Use the appropriate <b>ADO_FIXED_LENGTH_BINDING_ENTRY</b>, <b>ADO_NUMERIC_BINDING_ENTRY</b>, or <b>ADO_VARIABLE_LENGTH_BINDING_ENTRY</b> macros.</p>
<p>
In the parameters for the macros, the <b>Recordset</b> field to be extracted is specified by an ordinal number—zero identifies the first field, one identifies the second field, and so on. </p>
<p>
The C/C++ variable is declared with a data type. If the variable is numeric, you can also specify precision and scale. If the variable is variable-length, like a string, you must specify the maximum size of the variable in bytes. The <b>Recordset</b> field value will be coerced to this data type if necessary.</p>
<p>
Specify a temporary work buffer, which will be used to convert the field value from a VARIANT to a C/C++ variable. The buffer should be at least as large as the C/C++ variable.</p>
<p>
Set the Boolean modify parameter to TRUE to enable ADO to update the bound field, and FALSE if you merely want to examine the field but not change it. The VC++ Extension doesn't maintain state information about a field, so you must specify whether ADO should change a field's value (for example, the value of an autoincrement field maintained by the data source). Therefore, the modify parameter for such a field should be set to FALSE.</p>
<p>
The status parameter tells you whether the conversion from a <b>Recordset</b> field to a C or C++ variable was successful and whether the contents of the variable are valid. The&nbsp; two most important values for this parameter are <b>adFldOK</b>, which means the conversion was successful; and <b>adFldNull</b>, which means the field was NULL—it had no value to convert. </p>
<p>
Check this parameter first to determine if the C or C++ variable is valid. For example, if a field has valid contents for a row, status will be <b>adFldOK</b>. If you move to another row where the field is NULL, status will be <b>adFldNull</b>. However, the contents of the C or C++ variable will be unchanged—the variable will still contain the value of the field from the previous row.</p>
<p class=label>
<b>Bind the Recordset to Variables</b></p>
<p>
In your application, call the <b>BindToRecordset</b> interface method to associate (or <i>bind</i>) the <b>Recordset</b> fields to C/C++ variables. Your C/C++ variables will automatically be updated whenever the current row of the <b>Recordset</b> object changes. </p>
<p class=label>
<b>Header Files</b></p>
<p>
Include the following file in your application in order to use the VC++ Extensions:
<ul type=disc>
<li>
#include &lt;icrsint.h&gt;</li>
</ul>
<p class=label>
<b>Interface Methods</b></p>
<p>
The <b>IADORecordBinding</b> interface has methods to associate <b>Recordset</b> fields with C/C++ variables, add new rows, and perform updates. All three methods take a pointer to a class derived from <b>CADORecordBinding</b>, which defines the binding between each field and variable. </p>
<p>
The interface methods are:
<ul type=disc>
<li>
<b>BindToRecordset</b>(<i>&amp;binding</i>)</li>
</ul>
<p>
Call this method to associate fields with variables. 
<ul type=disc>
<li>
<b>AddNew</b>(&amp;<i>binding</i>)</li>
</ul>
<p>
Call this method to indirectly invoke the ADO <b>AddNew</b> method. 
<ul type=disc>
<li>
<b>Update</b>(&amp;<i>binding</i>)</li>
</ul>
<p>
Call this method to indirectly invoke the ADO <b>Update</b> method. </p>
<p class=label>
<b>Preprocessor macros</b>
<ul type=disc>
<li>
BEGIN_ADO_BINDING(<i>cls</i>)<br><br></li>
<li>
ADO_FIXED_LENGTH_BINDING_ENTRY(<i>Ordinal</i>, <i>DataType</i>, <i>Buffer</i>, <i>Status</i>, <i>Modify</i>)<br><br></li>
<li>
ADO_NUMERIC_BINDING_ENTRY(<i>Ordinal</i>, <i>DataType</i>, <i>Buffer</i>, <i>Precision</i>, <i>Scale</i>, <br>
<i>Status</i>, <i>Modify</i>)<br><br></li>
<li>
ADO_VARIABLE_LENGTH_BINDING_ENTRY(<i>Ordinal</i>, <i>DataType</i>, <i>Buffer</i>, <i>Size</i>, <br>
<i>Status</i>, <i>Modify</i>)<br><br></li>
<li>
END_ADO_BINDING() </li>
</ul>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=48%><b>Parameter</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%><i>cls</i></td>
<td width=52%>Class where the binding entries, buffer, and <b>Recordset</b> object are defined. </td>
</tr>
<tr valign=top>
<td width=48%><i>Ordinal</i></td>
<td width=52%>Ordinal field number; zero for the first field, one for the second, and so on.</td>
</tr>
<tr valign=top>
<td width=48%><i>DataType</i></td>
<td width=52%>Data type of the variable where the converted field will be stored. </td>
</tr>
<tr valign=top>
<td width=48%><i>Buffer</i></td>
<td width=52%>Buffer used to convert the field to a variable.</td>
</tr>
<tr valign=top>
<td width=48%><i>Status</i></td>
<td width=52%>Indicates the success of the field conversion.</td>
</tr>
<tr valign=top>
<td width=48%><i>Modify</i></td>
<td width=52%>A Boolean flag; if TRUE, indicates ADO can update the associated field.</td>
</tr>
<tr valign=top>
<td width=48%><i>Precision</i></td>
<td width=52%>Number of digits that can be represented in the numeric variable. </td>
</tr>
<tr valign=top>
<td width=48%><i>Scale</i></td>
<td width=52%>Number of decimal places in the numeric variable.</td>
</tr>
<tr valign=top>
<td width=48%><i>Size</i></td>
<td width=52%>Number of bytes required for a variable-length variable, such as a string.</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=48%><b><i>status</i> Parameter Values</b></td>
<td class=label width=52%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=48%><b>adFldOK</b></td>
<td width=52%>A non-NULL field value was returned.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldBadAccessor</b></td>
<td width=52%>Binding was invalid.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldCantConvertValue</b></td>
<td width=52%>Value couldn't be converted for reasons other than sign mismatch or data overflow.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldNull</b></td>
<td width=52%>A NULL was returned.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldTruncated</b></td>
<td width=52%>Variable-length data or numeric digits were truncated.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldSignMismatch</b></td>
<td width=52%>Value is signed and variable data type is unsigned.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldDataOverFlow</b></td>
<td width=52%>Value is larger than could be stored in the variable data type.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldCantCreate</b></td>
<td width=52%>Unknown column type and field already open.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldUnavailable</b></td>
<td width=52%>Field value could not be determined—for example, on a new, unassigned field with no default value.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldPermissionDenied</b></td>
<td width=52%>When updating, no permission to write data.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldIntegrityViolation</b></td>
<td width=52%>When updating, field value would violate column integrity.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldSchemaViolation</b></td>
<td width=52%>When updating, field value would violate column schema.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldBadStatus</b></td>
<td width=52%>When updating, invalid status parameter.</td>
</tr>
<tr valign=top>
<td width=48%><b>adFldDefault</b></td>
<td width=52%>When updating, a default value was used.</td>
</tr>
</table><br>
</font></BODY>
</HTML>
