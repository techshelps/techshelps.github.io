<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Managing the Device Context</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Managing the Device Context</H2><P>Windows&nbsp;NT provides a veritable sea of memory. Boy, this feels different compared to 16-bit Windows. Not only can our applications stretch their legs,  the system itself no longer has to fit inside 16-bit-addressable blocks, and we have room for lots and lots of pens and brushes and fonts. In the 16-bit Windows programming environment, it was important to conserve the use of drawing objects. In the 32-bit world we have to have richer data structures to hold this new wealth of data. And that means it takes longer to look things up.</P>
<P>The old limitations gave rise to a coding style which created, selected, used, and destroyed objects (like pens and brushes) constantly. Create, select, use, destroy; create, select, use, destroy. This limited the number of objects in the system and kept the application from bouncing into the address space walls, or worse, forcing another application into them. Because of the client-server transition, object creation and destruction are much more expensive on Windows&nbsp;NT. Because of the new capacity for large numbers of objects, selecting objects is a bit slower too. So create all your objects when you first need them. Then try to get into the pattern of select, use, use, use; select, use, use, use. Don't destroy them at all until you really are done with them. </P>
<P>Let's take an example from real life. We had someone porting to Windows&nbsp;NT complaining that their graphics were slower than before. We had them use the API logger (which we'll cover in the next chapter) to see what was wrong. We found them using the following pattern:  select(grey); patblt(...); select(black); patblt(...); select(grey); patblt(...); select(black); patblt(...). </P>
<P>We had them change this to select(grey); patblt(...); patblt(...); patblt(...); select(black); patblt(...); patblt(...); patblt(...). This solved the problem because it avoids the repeated lookups in the new data structures. This technique is applicable to pens, fonts, colors, palettes, and brushes.</P>
<P>While we're on the topic of graphical device contents (DCs), into which we've been selecting these objects, let's blow away another piece of lore. If you were a 16-bit Windows programmer, you were told to avoid the use of your own DC's because the system could only support a few. This is not true on Windows&nbsp;NT. Use the creation style CS_OWNDC as much as you can in your RegisterClass API call. This avoids repeated use of the relatively expensive GetDC and ReleaseDC calls every time you have to draw. It also preserves the selected objects in your own DC in between calls, eliminating the need to select them again after each call to GetDC. </P></FONT></BODY></HTML>
