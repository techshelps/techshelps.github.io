<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Looking Inside Your Working Set</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Looking Inside Your Working Set</H2><P>You may want to get a better understanding of the pieces inside the working set of your application. For example, you may save a lot of code space with the Working Set Tuner only to discover that the code space is only a small portion of your overall working set. In fact, this might even be something you want to do before you go to all the trouble to tune your code space. Aren't you glad you read this far?</P>
<P>We put this section here at the end anyway because you have to fuss around a bit to do the next set of measurements. You probably want to do these on a test computer, one you don't use for production activity. Choose a computer large enough to hold your entire working-set tuning test scenario in memory. (You may need to discover this size through the trial and error process we describe in this section.)</P>
<P>The tool we use for this is called Virtual Address Dump, or <B>vadump</B>. The <B>vadump</B> tool looks inside the working set of a process and determines the nature of each page. </P>
<P>The first thing to do is to link your application using the <B>-debug</B> and <B>-debugtype:coff </B>flags, so that you get the full use out of <B>vadump</B>.</P>
<P>Start your application, then start PView, which you will find on the floppy disk provided with this book. Use PView to note the Process ID of your application. You'll need to supply this to <B>vadump</B>. You should convert the Process ID from hexadecimal to decimal, since <B>vadump</B> expects it in decimal format. (You can use the Scientific View of the Windows Calculator accessory to perform this conversion, if you like.) Or you can use the <B>tlist</B> utility to get the Process ID directly in decimal form. </P>
<P>Get your application to the point just prior to the scenario whose working set you want to measure. Start Performance Monitor and leave it running, and get a command window set up so you can run <B>vadump</B>. Type the following in the command window, but don't press ENTER yet.</P>
<P><B>vadump  -o -m -p </B><I>PID</I><B> &gt;app.vad</B></P>
<P>Here <B>-o</B> tells vadump to monitor the working set in the original style, <B>-m</B> tells vadump to use the mapped symbols, and <B>-p</B> indicates the next number (<I>PID</I>) is the decimal Process ID of the process to measure. In our example command line the output is directed to the file APP.VAD.</P>
<P>But you haven't pressed enter yet, right?</P>
<P>In another window, set up <B>clearmem</B>, a utility that flushes everything from memory and the disk cache. (It is provided on the floppy disk you got with this book.) It will drive your application out of memory. </P>
<P>To be sure this happens, use Performance Monitor to chart the working set of your application. Also chart your application's Page Faults/sec. </P>
<P>Now switch to <B>clearmem</B>. Run it repeatedly (while keeping an eye on Performance Monitor) until your application has no pages in memory. Running <B>clearmem</B> once or twice typically does the trick. If your application is the type that wakes up periodically to do some housekeeping chores, it will always have some pages in memory. In this case, run <B>clearmem</B> a few times until Performance Monitor shows your application has reached as low a working set as it will attain. </P>
<P>Now switch to your application and execute the test scenario you devised earlier in this chapter for working set tuning.</P>
<P>Use Performance Monitor to note the size of your application's working set. Do this by selecting the Working Set line in the legend and reading the Last value.</P>
<P>Now switch to the <B>vadump</B> window and execute the <B>vadump</B> command set up above by pressing the Enter key. The results will be put in APP.VAD if you use the command line we showed above.</P>
<P>Take a look at Performance Monitor again and get the new size for your application's working set. This is likely to be a bit larger now than before, because <B>vadump</B> itself must bring some pages into the working set in order to scan all the page tables and working set entries for your application. </P>
<P>Run the scenario in your application again. Performance Monitor should get no page faults in your application during this run. If it does, you may not have enough memory on the system to hold your application's working set (we know, it's hard to believe, isn't it?) Add physical memory to the computer and try again. </P>
<P>The output from <B>vadump</B> shows the nature of each page in the working set of your process. See Figure 11.1. The System pages are those allocated for the page tables and for the working set list itself. As indicated above, this might be larger than your application actually needs because <B>vadump</B> needs to scan them. So use Performance Monitor as described to determine the difference. For the example in Figure 11.1, where we looked at the working set of Performance Monitor while charting, running <B>vadump</B> added 5 pages to the working set. Your mileage may vary.</P>
<P><img src="XOPK01.gif"></P>
<P>Figure 11.1    Partial vadump results of Performance Monitor charting</P>
<P>The page virtual addresses appear on the left. For each section of address space, the base is shown on the right. PRIVATE pages are dynamic data pages that are private to the process. Process Heap pages are dynamically allocated from the process heap. It can be difficult to determine who is using this space, and you may need to look at pointers within your application using the debugger to be sure. </P>
<P>If <B>coff</B> symbols are included and the module was linked with the <B>=debug</B> flag, other pages that belong to specific modules are indicated by listing which public symbols occur within the page. This helps you to understand why a particular page has been brought into memory. If the module was compiled without the correct flags you will just see the module name.</P>
<P>Any pages listed as belonging to the module "Error" are pages that did not resolve to a particular module. Frankly, we don't know to whom these belong. When you find out, please let us know.</P>
<P>You will also find some DATA pages at the upper end of the application's address space. These are for such system-related items as the Process Environment Block, the Thread Environment Blocks, the Per-Thread Data Area, and so on and so forth.</P>
<P>Pages in the range starting at 0xC0000000 are page table pages. They are listed showing the range of pages they map, how many of those are in memory (these are called <I>resident pages</I>), and the range of resident pages and their modules. </P>
<P>Finally, there is a summary of pages and who owns them. These just summarize the pages already listed, so take care not to count them again. </P>
<P>Remember that all the code pages in your working set may be shared with other processes, and will appear in their working sets as well, even though a shared code page takes up only one page frame in RAM. </P></FONT></BODY></HTML>
