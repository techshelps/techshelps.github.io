<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How the Graphics System Uses the Processor</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>How the Graphics System Uses the Processor</H3><P>We mentioned in passing that the client-server runtime subsystem, affectionately known as CSRSS, handles graphics on Windows&nbsp;NT. Actually it handles all window manipulation as well as graphics, and thus makes up an important portion of processor activity on the system. This architecture is illustrated in Figure 3.24.</P>
<P><img src="XOPZ11.gif"></P>
<P>Figure 3.24    Graphics architecture on Windows&nbsp;NT</P>
<P>The Windows&nbsp;NT SDK contains a graphical device interface demonstration program called Gdidemo. As shipped in the SDK, Gdidemo pauses between drawings. For this experiment, we modified the Gdidemo program to remove that pause so that it will spend all its time drawing. Figure 3.25 shows processor utilization for the processor, the modified Gdidemo<B> </B>program bouncing balls around the screen, and the CSRSS process. </P>
<P><img src="XOPC15.gif"></P>
<P>Figure 3.25    Processor utilization by a graphics program pumping pixels</P>
<P>The processor is 100% busy, and most of the time is in CSRSS, which makes sense because it is doing most of the work. On Windows&nbsp;NT you need to think beyond the application process itself and look at other processes in the system that the application may be using. CSRSS is a primary candidate for consuming processor cycles on behalf of an application. Usually this is pretty obvious, because the display changing rapidly is a primary clue. But some tasks that manipulate windows do not change the visible display:  they may be operating on windows that are hidden behind others. So taking a look at CSRSS is a good basic policy.</P>
<P>The graphics application communicates with CSRSS using a fast form of the local interprocess procedure call. What makes it fast is dedicating one thread in CSRSS for each application thread that communicates with CSRSS. So you'll see lots of CSRSS threads. An application sends graphics commands to CSRSS in batches to amortize the cost of the process switch over a number of graphical operations. Each such context switch<I> </I>is counted by System: Context Switches, and by Thread: Context Switches as well. You can see from the report in Figure 3.26 that the context switches between Gdidemo and a thread in CSRSS account for nearly all the context switches in the system. (Remember Heisenberg:  Performance Monitor is logging at one-second intervals here. You can see its communication with CSRSS in the two threads at the right of Figure 3.26.)</P>
<P><img src="XOPC39.gif"></P>
<P>Figure 3.26    Thread context switching during graphics processing</P>
<P>Thread 7 of CSRSS is waking up about 70 times per second to do some housekeeping, but shows no processor activity. This thread is slipping through our processor usage sampling crack. Context switches are a more positive indication of activity than processor utilization because they are always counted. Look at them if you want to know for certain whether a thread is active. We used this technique in Figure 3.11.</P></FONT></BODY></HTML>
