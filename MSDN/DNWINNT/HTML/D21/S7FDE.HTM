<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>File System Cache Overview</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>File System Cache Overview</H2><P>The file system cache<I> </I>is a buffer that holds data coming from or destined for disks, LANs, and other peripherals (such as CD-ROM drives). Windows&nbsp;NT uses a single file system cache for all cachable peripheral devices. For simplicity we'll refer primarily to the disk as the source of data, but keep in mind this is a simplification, and any time we use the word "disk" in this chapter you may substitute LAN or CD-ROM or the high speed peripheral of your choice. </P>
<P>Unless an application specifies the FILE_FLAG_NO_BUFFERING parameter in its call when opening a file, the file system cache is used when the disk is accessed. On reads from the device, the data is first placed into the cache. On writes, the data goes into the cache before going to the disk.</P>
<P>Unbuffered I/O requests have a quaint restriction; the I/O must be done in a multiple of the sector size of the disk device. Because buffering usually helps performance a lot, it is rather unusual for a file to be opened without buffering enabled. The applications that do this are typically server applications (like SQL Server, for example) that manage their own buffers. For the purposes of this chapter, we will consider all file activity to be buffered by the file system cache.</P>
<P>When Windows&nbsp;NT first opens a file, the cache maps the file into its address  space, and can then read the file as if it were an array of records in memory. When an application requests file data, the file system first looks in the cache to see if the data is there, and the cache tries to copy the record to the application's buffer. If  the page is not in the working set of the cache, a page fault occurs, as shown in Figure 6.1. </P>
<P><img src="XOPZ12.gif"></P>
<P>Figure 6.1    Cache references to absent file pages are resolved by the memory manager</P>
<P>If the page is in memory, it is mapped (not copied) into the cache's working set. This means a page table entry is validated to point to the correct page frame in memory. If the page is not in memory, the memory manager gets the page from  the correct file on the peripheral. This is how the cache manager uses the memory manager to do its input. The cache is treated much like the working set of a process. It will grow and shrink as demand dictates.</P>
<P>Let's see how this looks to Performance Monitor.</P></FONT></BODY></HTML>
