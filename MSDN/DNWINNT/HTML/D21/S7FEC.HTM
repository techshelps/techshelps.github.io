<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Monitoring NWLink Performance</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Monitoring NWLink Performance</H2><P>The NWLink protocol stack provides Windows&nbsp;NT with a method of communicating on Novell NetWare-compatible networks. Much like the NBT/TCP/UDP stack, NWLink provides analogous NWLink NetBIOS, NWLink IPX, and NWLink SPX services. The first figure shows our throughput test where the client is reading unbuffered data from the server's cache for a variety of record sizes, starting at 512, 1024, and 2048 bytes and then proceeding in 4096-byte page multiples.</P>
<P><img src="XOPG03.gif"></P>
<P>Figure 7.37    Client's throughput for unbuffered reading with NWLink NetBIOS </P>
<P>NWLink NetBios has throughput and processor overhead much like NetBEUI in the smaller record sizes, but at larger record sizes it has a lower maximum throughput than the other two protocols we have considered. </P>
<P>Let's take a look at the counters for NWLink NetBIOS. Here we have to make something of an apology, because the fact is we used the counters that were already defined by the NetBIOS protocol. The minor crime we committed here is that if you are used to using the IPX/SPX protocol in another context, the labeling of the counters will be quite strange to you. Cut us a little slack on this one. We figured providing the data was more important than getting the nomenclature just so.</P>
<P><img src="XOPG28.gif"></P>
<P>Figure 7.38    Server's NWLink NetBIOS statistics for 2048-byte reads </P>
<P>In the 2048 size transfer, the NWLink NetBios statistics are amazingly similar to the data in Figure 7.3. There is a bit more processor usage, but network throughput and record rates are virtually identical.</P>
<P>Let's generate some random NWLink IPX activity. We have a test program that uses multiple threads communicating with another computer in which a receiving process resides. These threads send and receive data simultaneously and also connect and disconnect from the other computer. This tweaks just about all the counters active from IPX, which gives the data you see in Figure 7.39.</P>
<P><img src="XOPG44.gif"></P>
<P>Figure 7.39    General IPX activity as seen by Performance Monitor</P>
<P>The processor is saturated, spending most of its time in User Mode as the application generates the workload. Since the IPX exerciser had multiple threads, sequencing has disappeared. They're sure talking a lot, although they're not moving a lot of data. Sounds like some people we know!</P>
<P>We can generate some similar NWLink SPX traffic with a WinSock utility. WASP is a little exerciser for applying a workload using the SPX protocol.</P>
<P><img src="XOPG32.gif"></P>
<P>Figure 7.40    Connection and disconnection between NWLink SPX partners </P>
<P>WASP generates a lot more network traffic. Processor usage is evenly split between User Mode and Privileged Mode. But wait a minute, the WASP program is only spending 21.629% of the time in User Mode. Yet 32.324% of the overall system time is in User Mode. Who is using the rest of those cycles? </P>
<P>The next Figure shows that most of the remaining cycles are being used by CSRSS, the Client-Server Run Time Subsystem. You may recall from an earlier chapter that this is the process that handles graphics and windows on behalf of applications running on Windows&nbsp;NT. This is client-process in the interprocess sense, not in the inter-system sense. With this clue we observe that WASP is continually updating the screen with status information during its test, and this involves the graphics process. A graphics process sapping server horsepower? Well, life's just like that sometimes: it's not always fair but it beats the alternative.</P>
<P><img src="XOPG04.gif"></P>
<P>Figure 7.41    SPX exerciser inadvertently exercises the graphical subsystem </P>
<P>So don't pass over those other innocuous counters hanging around. Look at everything; ignore nothing. Only you can determine what is important for your application environment. Just try to imagine what those programmers have done to your system! That ought to scare you. No counter is irrelevant when hunting bottlenecks. The fact that a counter is not changing can be just as important as the fact that it is. In the past few chapters we have focused on a few of the critical issues surrounding the hunting of bottlenecks. If you deal with this issue in the real world you know we have but scratched the surface. Don't oversimplify. Be patient. Be suspicious. Be fearless. Be relentless. And happy hunting!</P>
<P></P>
<P></P></FONT></BODY></HTML>
