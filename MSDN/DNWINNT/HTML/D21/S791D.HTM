<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How the DLL Interfaces with a Performance Monitor Application</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>How the DLL Interfaces with a Performance Monitor Application</H3><P>As discussed in Chapter 12 of this book, a performance monitor program retrieves performance data by specifying the HKEY_PERFORMANCE_DATA special handle in a call to the RegQueryValueEx function. If successful, RegQueryValueEx fills a buffer of the application with the requested performance data.</P>
<P>The first time an application calls RegQueryValueEx, or if the application uses the RegOpenKey function to open HKEY_PERFORMANCE_DATA, the Registry controller calls the Open function for all applications with the necessary Performance key entries. This gives each performance DLL an opportunity to initialize its performance data structures. Then, for performance DLLs whose Open function returned successfully, or for those with a Collect function but no Open function, the Registry controller calls the performance DLL's Collect function.</P>
<P>After the initial Open function calls, subsequent application calls to RegQueryValueEx only cause the Registry controller to call the Collect functions.</P>
<P>When the application has finished collecting performance data, it specifies HKEY_PERFORMANCE_DATA in a call to the RegCloseKey function. This causes the Registry controller to call the Close function for all applications. The performance DLLs will then be unloaded.</P>
<P>Note that it is possible for multiple programs to collect performance data at the same time. The Registry controller calls a performance DLL's Open and Close functions only once for each performance monitoring process. For remote measurement, the Registry controller limits access to these routines to only one thread at a time, so synchronization (for example, re-entrancy) is not a problem.</P>
<H4><B>Important</B>   For local measurement, because multiple processes may be making simultaneous calls, the program must prevent any conflicts from multiple concurrent requests for data.</P>
<H4><A NAME="sec0"></A>The Open Function</H4><P>The Registry controller calls the Open function, if one is provided, whenever a performance monitor application first connects to the Registry to collect performance data. This function performs whatever initialization is required for the application to provide performance data. Use the PM_OPEN_PROC function prototype defined in WINPERF.H:</P>
<P>|<P><BR></P>
<pre><code>PM_OPEN_PROC OpenPerformanceData;
DWORD APIENTRY OpenPerformanceData(LPWSTR <I>lpDeviceNames</I>);</code></pre>
<P>The <I>lpDeviceNames</I> argument points to a buffer containing the REG_MULTI_SZ strings stored in the Export value at the ...\Services\<I>ApplicationName</I>\Linkage key in the Registry. If this entry does not exist, <I>lpDeviceNames</I> is NULL. The strings are Unicode, separated by a UNICODE_NULL, and terminated by two UNICODE_NULL characters. The strings are the names of the devices managed by this application, and the Open function should call CreateFile to open a handle to each device named. If a CreateFile call fails, the Open function should return the error code returned by the GetLastError function; otherwise, it should return ERROR_SUCCESS. </P>
<P>The Open function initializes the data structures it returns to the performance monitor application. In particular, it examines the Registry to get the Counters and Help indexes of the objects and counters supported by the application. These indexes are then stored in the appropriate members of the PERF_OBJECT_TYPE and PERF_COUNTER_DEFINITION structures, which define the application's counter objects and counters. The example code at the end of this chapter shows the technique for using the First Counter and First Help values that the <B>lodctr</B> utility creates in the program's Performance key to determine the Counters and Help indexes of the program's counter objects and counters. </P>
<P>Other initialization tasks that might be performed by the Open function include the following:</P>
<UL><LI>     Open and map a file mapping object used by the program to store performance data.</LI><LI>     Initialize event logging, if the DLL uses event logging to report errors (it should, but not on every Collect function call).</LI><LI>     Open an internal table of handles to each device instance, to be used by the Collect function to obtain statistics.</LI><LI>     Perform other initialization tasks necessary for the Collect function to collect performance data efficiently.</LI></UL><H4><A NAME="sec1"></A>The Collect Function</H4><P>The Registry controller calls each application's Collect function whenever a performance monitor program calls the RegQueryValueEx function to collect performance data. This function returns the application's performance data in the format described in Chapter 12, "Writing a Custom Windows&nbsp;NT Performance Monitor." Use the PM_COLLECT_PROC function prototype defined in WINPERF.H:</P>
<P>|<P><BR></P>
<pre><code>PM_COLLECT_PROC CollectPerformanceData;
DWORD APIENTRY CollectPerformanceData(LPWSTR <I>lpwszValue</I>, LPVOID <I>*lppData</I>, 
               LPDWORD <I>lpcbBytes</I>, LPDWORD <I>lpcObjectTypes</I>);</code></pre>
<P>Table 13.5    Collect Function Arguments and Descriptions</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="114pt" VALIGN="TOP"><COL WIDTH="279pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Argument</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P><I>lpwszValue</I></P></TD><TD VALIGN="TOP"><P>Points to a string specified by the performance monitor program in the RegQueryValueEx call. For an example of code that parses this string, see the example at the end of this chapter. The string uses one of the following case-sensitive formats to identify the type of data being requested:</P>
<P>Global</P>
<P>Requests data for all counters on the local machine except those included in the <B>Costly</B> category.</P>
<P><I>index1 index2</I> ...</P>
<P>Requests data for the specified objects, where <I>index 1, index2</I>, and so forth, are whitespace-separated Unicode strings representing the decimal value of an object's Counters index. The Collect function needs to convert the strings to integers and then compare them to the Counters indexes of the application's counter objects. The Collect function returns data for all counters associated with the specified counter objects.</P>
<P>Foreign <I>ComputerName</I> </P>
<P>Requests data for all counters on a computer that does not support the Windows&nbsp;NT Registry calls for returning data remotely. <I>ComputerName</I> identifies the computer. If this application is a provider of foreign remote statistics, it should keep a handle that enables access to the foreign system. This avoids reconnection for each data collection. The Collect function should use the handle to get the data. </P>
<P>Foreign <I>ComputerName</I> <I>index1 index2</I> ...</P>
<P>Requests data for the specified objects on a foreign computer.</P>
<P>Costly</P>
<P>Requests data for all counters whose data is expensive to collect. It is up to the application writer to determine whether any of the application's counter objects are in this category. Windows&nbsp;NT Performance Monitor does not use this category.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>lppData</I></P></TD><TD VALIGN="TOP"><P>On input, points to a pointer to the location where the data is to be placed. On successful exit, set *<I>lppData</I> to the next byte in the buffer available for data, such as one byte past the last byte of your data. The data returned must be a multiple of a <B>DWORD</B> in length. It must conform to the PERF_OBJECT_TYPE data definition and its descendants as specified in WINPERF.H<I>,</I> unless this is a collection from a foreign computer. If foreign, any PERF_OBJECT_TYPE structures returned must be preceded by a PERF_DATA_BLOCK structure for the foreign computer. If the <B>Collect</B> function fails for any reason, leave *<I>lppData</I> unchanged.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>lpcbBytes</I></P></TD><TD VALIGN="TOP"><P>On input, points to a 32-bit value that specifies the size, in bytes, of the <I>lppData</I> buffer. On successful exit, set *<I>lpcbBytes</I> to the size, in bytes, of the data written to the <I>lppData</I> buffer. This must be a multiple of sizeof(<B>DWORD</B>) (a multiple of 4). If the <B>Collect</B> function fails for any reason, set *<I>lpcbBytes</I> to zero.</P></TD></TR><TR><TD VALIGN="TOP"><P><I>lpcObjectTypes</I></P></TD><TD VALIGN="TOP"><P>On successful exit, set *<I>lpcObjectTypes </I>to the number of object type definitions being returned. If the <B>Collect</B> function fails for any reason, it should set *<I>lpcObjectTypes </I>to zero.</P></TD></TR></TBODY></TABLE>
<P>|<P><BR></P><P>If the requested data specified by <I>lpwszValue</I> does not correspond to any of the object indexes or foreign computers supported by your program, leave *<I>lppData</I> unchanged, and set *<I>lpcbBytes</I> and *<I>lpcObjectTypes</I> both to zero. This indicates that no data is returned.</P>
<P>For foreign computer interfaces, the opening of a channel to the foreign computer must be done in the Collect function because the computer name is not provided to the Open function. The performance DLL should save a handle to the foreign computer to avoid reconnecting on each data collection call.</P>
<P>The Collect function must return one of the values shown in the following table.</P>
<P>Table 13.6    Collect Function Return Values and Descriptions</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="115pt" VALIGN="TOP"><COL WIDTH="280pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Return value</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>ERROR_MORE_DATA</P></TD><TD VALIGN="TOP"><P>Indicates that the size of the <I>lppData</I> buffer as specified by *<I>lpcbBytes</I> is not large enough to store the data to be returned. In this case, leave *<I>lppData</I> unchanged, and set *<I>lpcbBytes</I> and *<I>lpcObjectTypes</I> to zero. No attempt is made to indicate the required buffer size, because this may change before the next call.</P></TD></TR><TR><TD VALIGN="TOP"><P>ERROR_SUCCESS</P></TD><TD VALIGN="TOP"><P>Return this value in all other cases, even if no data is returned or an error occurs. To report errors other than insufficient buffer size, use the system event log, but do not flood the event log with errors on every data collection operation.</P></TD></TR></TBODY></TABLE>
<P>|<P><BR></P><H4><A NAME="sec2"></A>The Close Function</H4><P>The Registry controller calls each application's Close function when a performance monitor application calls the RegCloseKey function to close the HKEY_PERFORMANCE_DATA handle. This function performs any cleanup operations required by the application's performance data collection mechanism. For example, the function could close device handles opened by CreateFile, or close a handle to a file mapping object. Use the PM_CLOSE_PROC function prototype defined in WINPERF.H<I>:</I></P>
<P>|<P><BR></P>
<pre><code>PM_CLOSE_PROC ClosePerformanceData;
DWORD APIENTRY ClosePerformanceData();</code></pre>
<P>The function should return ERROR_SUCCESS.</P></FONT></BODY></HTML>
