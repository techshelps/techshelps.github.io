<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How Performance Monitor Sees a Computer</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>How Performance Monitor Sees a Computer</H3><P>We need to descend from this ethereal realm of generalizations into the realities of performance monitor construction. Software performance monitors are great tools, but they have certain limitations we can't ignore. They measure what they can without disturbing the system under measurement too much. And some elements cannot be measured because the current generation of hardware does not support counters or timers on those elements. </P>
<P>Here's an important example:  the processor and the cache/RAM memory hierarchy are busy during the execution of instructions. Because we don't have an inexpensive way to partition the activity among these tightly knit elements, we consider them as a unit when we think of the processor as a device doing work in the system. When we become concerned about memory being a bottleneck in the system, we usually are concerned about its size, not its speed. On single processor systems we just lump memory speed into processor speed, and we won't say much more about it. From now on when we speak of the processor being busy, we will be speaking of the group of hardware devices shown in Figure 2.3.</P>
<H4><B>Note</B>   The new Intel Pentium&trade; processor and other new processors have counters on some of these low-level items. A Performance Monitor extended object for these counters is included on the diskette or CD-ROM provided with this book. (Extended objects are explained in Chapter 13 of this book.) In particular, these new counters should help with finding memory speed bottlenecks in multiprocessor systems.</P>
<P><img src="XOPZ21.gif"></P>
<P>Figure 2.6    Performance Monitor view of personal computer hardware</P>
<P>So, what does happen when memory is too small? Then there is not enough room in memory for all the needed pages of program code and data. The system starts to spend a lot of time moving pages between disk and RAM. Bummer. What you see is loads and loads of disk utilization. By the definition of bottleneck, you might be tempted to rush out and buy a faster disk drive. Bad decision! What you really need is more memory. Although the disk is, strictly speaking, the bottleneck in the system, the reason it is the bottleneck is lack of memory. There is a Windows&nbsp;NT counter (Memory: Pages/sec) that clearly shows this to be the case, and a number of other counters to help you back it up. </P>
<P>Lack of memory is by far the most common cause of serious performance problems in computer systems. If you stop reading here, you can do better than you should just by saying "Memory!" whenever someone complains about performance. But if you have the integrity your parents raised you to have, you'll want to understand enough about how the system works to draw reasonable conclusions about what you observe. Don't worry; by the time we're done, you'll be downright dangerous.</P></FONT></BODY></HTML>
