<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Uncovering High Disk Throughput</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Uncovering High Disk Throughput</H2><P>To tell you the truth, we've been slacking. This disk is capable of much more than this level of throughput. Let's build a large file so we can simulate a more realistic load with more seek operations. We'll use <B>createfil</B> to make a 500-MB sandbox for us to play in. We'll turn on Performance Monitor while we're at it to see what <B>createfil</B> is doing.</P>
<P>Figure 4.10 was logged at five-second intervals while we created the 500 MB file. Obviously the disk was quite busy, and the processor was loafing. Must be its day off.</P>
<P><img src="XOPD06.gif"></P>
<P>Figure 4.10    Creating a 100-MB file</P>
<P>The system overview in the next figure reveals a rather surprising lack of file activity. File bytes are being written at about 51K per second. We knew from the Graph Time on the value bar in the chart represented by Figure 4.10 (value bar not shown) that it takes about 722 seconds to create this file. (We subtracted one time interval, or five seconds, from each end because the chart starts before and ends after the file is created.) Multiplying the File Write Bytes/sec times 722 seconds give us a result of only around 37 million bytes. But the file is over 524 million bytes in length. We've seen this before, right? This must be the old fast path to the cache that bypasses the file system altogether. While we can tell Response Probe to use unbuffered access, <B>createfil</B> always uses buffered file system calls. In fact this is the default, and because it is almost always faster, almost all applications use buffered file access. The principal exceptions are network server applications which do their own caching. </P>
<P><img src="XOPD17.gif"></P>
<P>Figure 4.11    System overview of creating a 100-MB file</P>
<P><img src="XOPD18.gif"></P>
<P>Figure 4.12    Cache behavior when creating a large buffered file</P>
<P>The cache statistics in Figure 4.12 show that the lazy writer is launched frequently to help clear the cache, and in addition the cache is rapidly flushing dirty pages to make room for new ones. (Lazy writes and data flushes have an interesting relationship, detailed in Chapter 6, "Detecting Cache Bottlenecks.") Multiplying the number of Lazy Write Pages/sec times the page size (4096 bytes on this machine), we see a byte rate of 746,275 bytes/sec. This is close to the disk transfer rate we see on drive D in the next figure. </P>
<P><img src="XOPD19.gif"></P>
<P>Figure 4.13    Disk behavior when creating a large buffered file</P>
<P>Now we've got a disk really pumping bytes. Compare this to the rate achieved by reading small records in Figure 4.7. The large transfer size here, 37993 bytes per write, is the key to the high efficiency the system achieved. And we can do even better than this.</P></FONT></BODY></HTML>
