<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Thread Object</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Thread Object</H2><H3><A NAME="sec0"></A>Object: Thread     Index: 232 <I>        Novice</I></H3><P>The Thread object type is the basic object that executes instructions in a processor. Every running process has at least one thread.</P>
<H3><A NAME="sec1"></A>% Privileged Time<I>     Advanced</I></H3><P>Privileged Time is the percentage of elapsed time that this thread has spent executing code in Privileged Mode. When a Windows&nbsp;NT system service is called, the service will often run in Privileged Mode in order to gain access to system-private data. Such data is protected from access by threads executing in User Mode. Calls to the system may be explicit, or they may be implicit such as when a page fault or an interrupt occurs. Unlike some early operating systems, Windows&nbsp;NT uses process boundaries for subsystem protection in addition to the traditional protection of User and Privileged modes. These subsystem processes provide additional protection. Therefore, some work done by Windows&nbsp;NT on behalf of your application may appear in other subsystem processes in addition to the Privileged Time in your process.</P>
<P>Index: 144     Default Scale: 1</P>
<P>Counter Type: PERF_100NSEC_TIMER     Counter Size: 8 bytes</P>
<H3><A NAME="sec2"></A>% Processor Time<I>     Novice</I></H3><P>Processor Time is the percentage of elapsed time that this thread used the processor to execute instructions. An instruction is the basic unit of execution in a processor, and a thread is the object that executes instructions. Code executed to handle certain hardware interrupts or trap conditions may be counted for this thread.</P>
<P>Index: 006     Default Scale: 1</P>
<P>Counter Type: PERF_100NSEC_TIMER     Counter Size: 8 bytes</P>
<H3><A NAME="sec3"></A>% User Time<I>     Advanced</I></H3><P>User Time is the percentage of elapsed time that this thread has spent executing code in User Mode. Applications execute in User Mode, as do subsystems like the window manager and the graphics engine. Code executing in User Mode cannot damage the integrity of the Windows&nbsp;NT Executive, Kernel, and device drivers. Unlike some early operating systems, Windows&nbsp;NT uses process boundaries for subsystem protection in addition to the traditional protection of User and Privileged modes. These subsystem processes provide additional protection. Therefore, some work done by Windows&nbsp;NT on behalf of your application may appear in other subsystem processes in addition to the Privileged Time in your process.</P>
<P>Index: 142     Default Scale: 1</P>
<P>Counter Type: PERF_100NSEC_TIMER     Counter Size: 8 bytes</P>
<H3><A NAME="sec4"></A>Context Switches/sec<I>     Advanced</I></H3><P>Context Switches/sec is the rate of switches from one thread to another. Thread switches can occur either inside of a single process or across processes. A thread switch may be caused either by one thread asking another for information, or by a thread being preempted by another, higher priority thread becoming ready to run. Unlike some early operating systems, Windows&nbsp;NT uses process boundaries for subsystem protection in addition to the traditional protection of User and Privileged modes. These subsystem processes provide additional protection. Therefore, some work done by Windows&nbsp;NT on behalf of an application may appear in other subsystem processes in addition to the Privileged Time in the application. Switching to the subsystem process causes one Context Switch in the application thread. Switching back causes another Context Switch in the subsystem thread.</P>
<P>Index: 146     Default Scale: 0.01</P>
<P>Counter Type: PERF_COUNTER_COUNTER     Counter Size: 4 bytes</P>
<H3><A NAME="sec5"></A>Elapsed Time<I>     Advanced</I></H3><P>The total elapsed time (in seconds) this thread has been running.</P>
<P>Index: 684     Default Scale: 0.0001</P>
<P>Counter Type: PERF_ELAPSED_TIME     Counter Size: 8 bytes</P>
<H3><A NAME="sec6"></A>ID Process<I>     Wizard</I></H3><P>ID Process is the unique identifier of this process. ID Process numbers are reused, so they only identify a process for the lifetime of that process.</P>
<P>Index: 784     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<H3><A NAME="sec7"></A>ID Thread<I>     Wizard</I></H3><P>ID Thread is the unique identifier of this thread. ID Thread numbers are reused, so they only identify a thread for the lifetime of that thread.</P>
<P>Index: 804     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<H3><A NAME="sec8"></A>Priority Base<I>     Advanced</I></H3><P>The current base priority of this thread. The system may raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.</P>
<P>Index: 682     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<H3><A NAME="sec9"></A>Priority Current<I>     Advanced</I></H3><P>The current dynamic priority of this thread. The system may raise the thread's dynamic priority above the base priority if the thread is handling user input, or lower it towards the base priority if the thread becomes compute bound.</P>
<P>Index: 694     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<H3><A NAME="sec10"></A>Start Address<I>     Wizard</I></H3><P>Starting virtual address for this thread.</P>
<P>Index: 706     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<H3><A NAME="sec11"></A>Thread State<I>     Wizard</I></H3><P>Thread State is the current state of the thread. It is 0 for Initialized, 1 for Ready, 2 for Running, 3 for Standby, 4 for Terminated, 5 for Wait, 6 for Transition, 7 for Unknown. A Running thread is using a processor; a Standby thread is about to use one. A Ready thread wants to use a processor, but is waiting for a processor because none are free. A thread in Transition is waiting for a resource in order to execute, such as waiting for its execution stack to be paged in from disk. A Waiting thread has no use for the processor because it is waiting for a peripheral operation to complete or a resource to become free.</P>
<P>Index: 046     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<H3><A NAME="sec12"></A>Thread Wait Reason<I>     Wizard</I></H3><P>Index: 336     Default Scale: 1</P>
<P>Counter Type: PERF_COUNTER_RAWCOUNT     Counter Size: 4 bytes</P>
<P>Thread Wait Reason is only applicable when the thread is in the Wait state (see Thread State). It is 0 or 7 when the thread is waiting for the Executive, 1 or 8 for a Free Page, 2 or 9 for a Page In, 3 or 10 for a Pool Allocation, 4 or 11 for an Execution Delay, 5 or 12 for a Suspended condition, 6 or 13 for a User Request, 14 for an Event Pair High, 15 for an Event Pair Low, 16 for an LPC Receive, 17 for an LPC Reply, 18 for Virtual Memory, 19 for a Page Out; 20 and higher are not assigned at the time of this writing. Event Pairs are used to communicate with protected subsystems (see Context Switches).</P></FONT></BODY></HTML>
