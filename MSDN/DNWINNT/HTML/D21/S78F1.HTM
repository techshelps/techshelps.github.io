<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Windows API Profiler</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>The Windows API Profiler</H2><P>The Windows API Profiler, affectionately known as WAP, is useful for determining which Windows 32-bit API calls are taking up time. WAP can effectively profile any number of processes and threads concurrently. You can run it on a program without having to recompile the program. WAP intercepts the calls from the application to the system and counts and times them. WAP is available in the Windows&nbsp;NT SDK.</P>
<P>WAP modifies the executable image to point to a set of measurement DLLs that sandwich themselves between the application and the system DLLs. See Figure 10.5. If your application performs a checksum on its executable, you must disable the checksum to run WAP.</P>
<P><img src="XOPZ18.gif"></P>
<P>Figure 10.5    Application interface to the system before and after running apf32cvt</P>
<P>WAP sets the client-server batch size to one before taking any measurements. This assures that the proper API call gets billed for its time. If WAP did not do this, the time for all the API calls in the batch would be counted against the last one in the batch, totally confusing the data (not to mention confusing you). Setting the batch limit to one is a good idea, but you may notice a slowdown in the operation of the application because there are many more client-server transitions. Set another plate:  Heisenberg invited himself to the party again.</P>
<P>If you are concerned about the impact of setting the batch level to one for your application, you can get an idea of the cost of a client-server transition on your computer by looking in the WAP data for a call to SetWindowLong. It's a pretty common call. If you don't see a SetWindowLong call, use WAP to find such a call in another application, such as WinHlp32.</P>
<P>The Win32 APIs are contained in the following dynamic link libraries:  KERNEL32.DLL, ADVAPI32.DLL, GDI32.DLL, USER32.DLL, and CRTDLL.DLL. The profiler is in the form of five DLL files, one for each DLL to be profiled. As shown in Figure 10.5, these DLLs sit between an application and the Win32 DLL to be profiled, intercept API calls to them, and then make and time a call to the Win32 API. The profiling DLL records the following information for each API:</P>
<UL><LI>     The number of times the API is called</LI><LI>     The total time spent executing the API during those calls</LI><LI>     The average time per call, computed by dividing the total time spent in the API by the number of times the API is called</LI><LI>     The time of the first call to the API </LI><LI>     After the first call, the maximum time spent in the API on any one call</LI><LI>     After the first call, the minimum time spent in the API on any one call</LI><LI>     The number of calls that were not timed, due to a timer overflow (timer overflows should not happen)</LI></UL><P>All result times are in microseconds.</P>
<P>The profiler determines overhead by reading the timer 2000 times upon initialization of the profiling DLL. The minimum time of these calls obtained during this process is subtracted from the time for each API call, thus eliminating the majority of timer overhead from the final results. For accurate timing, it is important that the system be inactive during the calibration process.</P></FONT></BODY></HTML>
