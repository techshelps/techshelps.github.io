<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How Working Set Tuning Can Help You</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>How Working Set Tuning Can Help You</H2><P>The counter Process: Working Set shows the number of pages in memory for the process, as we discussed at some length in Chapter 5. The working set includes both shared and private data. The shared data includes pages containing any instructions your application executes, including those in your own DLLs and those of the system. It is efficient that these pages are shared between processes, so that their working sets overlap to whatever extent sharing is possible. Still, it can amount to a whole slew of pages. </P>
<P>The Windows&nbsp;NT Working Set Tuner reduces the number of code pages that have to be in RAM for your program to execute. It reduces them by helping the linker put your executable together in a way that minimizes the number of pages you use.</P>
<P>Normally your executable image is put together in the order in which address references are resolved. This has nothing at all to do with the need for particular routines to reside together in memory, because lots of functions get called only under error conditions or other unusual situations. The references to these routines are, of course, right next to references to those routines which are used all the time. Consider the following example.</P>
<P>|<P><BR></P>
<pre><code>status = DoSomethingFirst(...);<BR>while (status == WONDERFUL) {<BR>    status = ProcessNormally(...);<BR>} else {<BR>    PressThePanicButton(...);<BR>}</code></pre>
<P>Assuming this is the first time the linker has seen these symbols, it would put DoSomethingFirst in the .EXE, followed by ProcessNormally, and then it would put in PressThePanicButton. But DoSomethingFirst is only used during initialization, and PressThePanicButton is only called when the sky is falling. It would be better if ProcessNormally were placed in the .EXE with other routines which are used frequently, DoSomethingFirst were placed with routines which were used to initialize the applications, and PressThePanicButton were placed somewhere else (and we really don't care where). If the linker sets them up that way, a page brought in when ProcessNormally is first executed would likely contain only routines which are used frequently. And the page containing DoSomethingFirst could be discarded after initialization, because it would likely be packed with initialization routines. And best of all, the page containing PressThePanicButton would come into memory only if the error condition arose.</P>
<P>The Working Set Tuner accomplishes precisely these objectives. It provides a packing list to the linker so the linker can place functions into the executable image in the order that most reduces paging. It does this by determining which functions are used together in time. The functions which are used most often are placed together in the .EXE image. This continues in order of usage until the never-referenced functions are reached. It places these at the end of the .EXE in "don't care" order. </P>
<P>In order to determine which functions are used together in time, the Working Set Tuner starts with a measurement of your application. For this utility to do a good job, you must define your scenario to include all the commonly used functions in your application. Your scenario should spend the most time on the most commonly used function, fading to those less frequently used. For example, when we performed working set tuning on Performance Monitor, our scenario included the following: </P>
<UL><LI>     Logging all objects at 3-second intervals.</LI><LI>     Charting Processor, Memory, and System counters at 5-second intervals.</LI><LI>     Reporting on the same objects at 10-second intervals.</LI><LI>     Alerting on the same objects at 15-second intervals.</LI></UL><P>The tuned working set that resulted from this set of tasks was smallest for logging, which we wanted because it is the most serious use of the tool, when we want Heisenberg in the trunk. For charting, which is quite common, we let Heisenberg sit in the back seat. And so on. </P>
<P>How good a job does the Working Set Tuner do? The results for Performance Monitor executing the scenario described above are in the next table.</P>
<P>Table 11.1    Code Working Set Tuning of Performance Monitor</P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="108pt" VALIGN="TOP"><COL WIDTH="127pt" VALIGN="TOP"><COL WIDTH="112pt" VALIGN="TOP"><COL WIDTH="7pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="3" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>Executable image pages</P></TD><TD VALIGN="TOP"><P>RAM pages before tuning</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>RAM pages after tuning</P></TD></TR><TR><TD COLSPAN="3" VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>41</P></TD><TD VALIGN="TOP"><P>30</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>11</P></TD></TR></TBODY></TABLE>
<P>|<P><BR></P><P>That's a pretty dramatic saving. Typically we see between 25% and 50% savings on code space used. You can normally expect a 30% reduction in your code space for the scenario that you measure. But the operational results of your efforts depend almost entirely on how good a job you did at devising your scenario. A quick "let's just run something" without preparation won't help. So<I> </I>think<I> </I>carefully about that test scenario.</P></FONT></BODY></HTML>
