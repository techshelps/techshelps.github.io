<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Detecting Processor Bottlenecks</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H1>Detecting Processor Bottlenecks</H1><P>If you've read the first two chapters, you should be an expert on the use of Windows&nbsp;NT Performance Monitor. It's time to go out and slay those bottleneck dragons!</P>
<P>There is never a shortage of dragons—every computer doing any work at all always has a bottleneck. You can see this if you review the definition of bottleneck presented in Chapter 2. The device for which there is the greatest demand is the bottleneck. This is the device with the greatest utilization during an activity's execution. </P>
<P>It isn't hard to see that there is frequently a second bottleneck lurking beneath the first. This is usually the device with the next lower utilization. We say "usually" here because if you remove the first bottleneck, the one to surface could change, depending on how the first one is removed. The important thing to remember is that just removing one bottleneck does not always turn the dragon's lair into a palace. You sometimes have to slay another dragon. </P>
<P>This leads us to our second rule of bottleneck detection.</P>
<P><img src="XOPY02.gif"></P></FONT></BODY></HTML>
