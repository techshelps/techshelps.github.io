<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Bottlenecks Are Moving Targets</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Bottlenecks Are Moving Targets</H2><P>The other thing to keep in mind is that during processing, the bottleneck may shift around from one piece of equipment to another. Each second of operation might yield a different bottleneck if looked at in isolation. If you want to improve the situation as a whole, you'll need to look at the big picture. And even then the situation can be tricky. Let's take a look at a real example to illustrate these points. </P>
<P>The first thing we have to do is run the <B>diskperf -y</B> command to enable disk performance counters, as discussed at the end of Chapter 2. (You did read Chapter 2, didn't you?) After running <B>diskperf</B>, you'll have to reboot the computer being monitored before the disk performance counters can be activated.</P>
<P><img src="XOPC01.gif"></P>
<P>Figure 3.1    Chart of processor and disk usage</P>
<P>In Figure 3.1 we have charted data from a Performance Monitor log file. The black line is the Logical Disk: % Disk Read Time, and the highlighted, white line is the Processor: % Processor Time. Activity is divided into two distinct phases. During the first phase, the disk is clearly the bottleneck, with the processor a somewhat distant second. During the second phase, the processor becomes the bottleneck, with the disk even less in use. The overall data is provided in Figure 3.2.</P>
<P><img src="XOPC02.gif"></P>
<P>Figure 3.2    Report of processor and disk usage</P>
<P>This disk is utilized at 52.8% and the processor at 53.3%. Because the time window is 44 seconds, this means we used 23.23 seconds of disk time (this is <I>demand[disk]</I>) and 23.45 seconds of processor time (<I>demand[processor]</I>). In the formal terms of the last chapter, the maximum throughput at which the disk can accomplish this task is 1/23.23 * 3600 = 155.0 times per hour, and for the processor 153.5 times per hour. Technically, the processor is the bottleneck. In reality, both components are nearly equally to blame. </P>
<P>One way to think of this is to imagine how much faster this task would go if either component were infinitely fast. In this case, the activity would be accomplished in half the time if either component were blindingly fast. Is there a bottleneck? Yes, it is the processor. Could you improve performance by attacking either component? Yes. But you could only improve the first phase if the disk were improved, whereas in this case a faster processor would help the second phase a lot, and the first phase a little bit. Which brings us to Rule #3 of Bottleneck Detection.</P>
<P><img src="XOPY03.gif"></P></FONT></BODY></HTML>
