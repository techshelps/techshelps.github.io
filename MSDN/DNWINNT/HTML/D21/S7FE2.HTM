<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Mapping Files Into Memory</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Mapping Files Into Memory </H2><P>There is a way for applications to access file data that is even faster than using the file system cache. By mapping a file directly into its address space, an application can access the data in the file like an array and need never call the file system at all. This avoids all the overhead associated with the file system call and the search of the cache. The next table shows our little laptop's performance while accessing the file as we did earlier in the chapter, this time adding memory mapping as an access mode. The times shown are </P>
<P>Table 6.2    Memory Mapped vs. File I/O Times in Milliseconds per Record</P>

<TABLE COLS="5" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="60pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Type of  file access</P></TD><TD VALIGN="TOP"><P> Operation</P></TD><TD VALIGN="TOP"><P>Non-cached time </P></TD><TD VALIGN="TOP"><P> Cached time </P></TD><TD VALIGN="TOP"><P> Mapped time </P></TD></TR><TR><TD VALIGN="TOP"><P>Sequential</P></TD><TD VALIGN="TOP"><P>Read</P></TD><TD VALIGN="TOP"><P>6.58</P></TD><TD VALIGN="TOP"><P>1.32</P></TD><TD VALIGN="TOP"><P>0.75</P></TD></TR><TR><TD VALIGN="TOP"><P>Sequential</P></TD><TD VALIGN="TOP"><P>Write</P></TD><TD VALIGN="TOP"><P>22.91</P></TD><TD VALIGN="TOP"><P>1.70</P></TD><TD VALIGN="TOP"><P>0.64</P></TD></TR><TR><TD VALIGN="TOP"><P>Random</P></TD><TD VALIGN="TOP"><P>Read</P></TD><TD VALIGN="TOP"><P>20.45</P></TD><TD VALIGN="TOP"><P>1.51</P></TD><TD VALIGN="TOP"><P>0.97</P></TD></TR><TR><TD VALIGN="TOP"><P>Random</P></TD><TD VALIGN="TOP"><P>Read/Write</P></TD><TD VALIGN="TOP"><P>40.66</P></TD><TD VALIGN="TOP"><P>3.16</P></TD><TD VALIGN="TOP"><P>1.31</P></TD></TR></TBODY></TABLE>
<P>|<P><BR></P><P>File activity just doesn't get any faster than that! But memory mapping of files is not always advisable. For one thing, you'd have to recode an existing application  to get rid of all those old-fashioned file system calls. Although the resulting code would be simpler, you must weigh this against taking the time and effort to recode an existing application. Another tricky tradeoff occurs when access is strictly sequential; the cache uses much less memory to read the file, as we have seen.  Also, using memory mapping means that you lose access to the file system synchronization modes such as file locking or the more exotic opportunistic locking. This means that any multiple writers of the file, whether they be threads inside a process or multiple processes sharing the file, must coordinate their access using mutexes. And if there is any possibility that the file might be remotely accessed by multiple processes which are writing to the file from different computers, you must invent an inter-process synchronization mechanism which might obviate the performance advantage you got from memory mapping in the first place.</P>
<P>In cases where you decide to map files into memory, it's a clear winner in speed. Performance Monitor uses memory mapping for accessing the log file when it is reading it for reprocessing. Because access to the file might be random, this is just the sort of task which benefits from memory mapping. Conversely, output of log files is done through the normal file system calls because the cache can detect the sequential nature of the output and can therefore use memory more efficiently writing files created in this fashion.</P>
<P>The principal difference in the behavior of the system between using mapped and unmapped files is that mapped files go directly into the working set of the process, while, as we have seen, buffered files go into the "working set" of the file system cache. When a process maps a file into its address space, it might use quite a bit of RAM to hold the file. But from the memory manager's viewpoint, it really doesn't make too much difference whether the working set of the process or the working  set of the cache gets the page that's faulted in. The real elegance of the memory management scheme on Windows&nbsp;NT is exemplified in this point, which is illustrated by the next experiment. </P>
<P>We start two processes, each accessing a file with normally distributed record access. First the distribution covers 1 MB, then 2 MB, 3 MB, and so on up to 8 MB. One process reads the file using the file system calls, and the other maps the file into its address space. The results are displayed in the next two charts. The first four trials with working sets from 1 to 4 MB are shown in Figure 6.19, and the next four trials with working sets from 5 to 8 MB are shown in Figure 6.20.</P>
<P><img src="XOPF09.gif"></P>
<P>Figure 6.19    Competing processes using mapped and file system reads</P>
<P><img src="XOPF10.gif"></P>
<P>Figure 6.20    More competing processes using mapped and file system reads</P>
<P>In the beginning, the highlighted cache has a slight size advantage, but as the working sets get larger, the process in heavy black begins to get ahead. The  thin black line shows Available Bytes declining, and the dotted line shows that Pages/sec are rising as the experiment progresses. By the time the normal distribution covers 8 MB, the paging rate on this laptop is shaking it right off  your lap. </P>
<P>These charts seem to indicate that the memory manager is favoring the process's working set over that of the cache. To some extent this is true. In general, the  code and data referenced directly by processes is more crucial to good application performance than the file data in the cache. The cache tends to get the space not needed by processes. It certainly gets any unused space, as we saw when it took pages trimmed from inactive working sets. When processes are active, however, they tend to do a bit better than the cache, as in this case. But the result is not overwhelmingly in favor of the process, as the next figure shows.</P>
<P><img src="XOPF18.gif"></P>
<P>Figure 6.21    Response time for mapped and buffered competing processes</P>
<P>Figure 6.21 shows each process's response time as measured by Response Probe during this experiment. The mapped access is faster in the beginning, as we saw in Table 6.2. Then, as the paging increases, and disk access time becomes a significant component of the response time, the two processes' performance evens up. The  fact that the working set of the process doing mapped access is a bit larger is not a significant advantage. This indicates that the policy of the memory manager is perfectly balanced.</P>
<P>In the next chapter we discuss how you tune memory manager to favor either the cache or the application in specific circumstances.</P></FONT></BODY></HTML>
