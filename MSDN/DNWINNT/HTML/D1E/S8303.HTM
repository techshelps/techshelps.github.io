<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Kernel</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Kernel</H2><P>Working very closely with the HAL is the Kernel, the heart of Windows&nbsp;NT. It schedules activities for the computer processor to perform. If the computer has multiple processors, the Kernel synchronizes activity among the processors to optimize performance.</P>
<P>The activities the Kernel schedules are called <I>threads</I>, the most basic entity in the system that can be scheduled. Threads are defined in the context of a process, (described more fully later in "Process Manager") which represents an address space, a set of <I>objects</I> visible to the process, and a set of threads that runs in the context of the process. Objects are resources that can be manipulated by the operating system. (These are discussed more fully in the "Object Manager" section.)</P>
<P>The Kernel dispatches threads in a way that ensures that the system's processors are always as busy as possible, processing the highest-priority threads first. (There are 32 priorities distributed across two priority classes — real-time and variable.) This helps make the operating system as efficient as possible.</P>
<P>Subcomponents at the Executive level, such as the I/O Manager and the Process Manager, use the Kernel to synchronize activities. They also rely on the Kernel for higher levels of abstraction, called <I>Kernel objects</I>, some of which are exported within user-level application programming interface (API) calls.</P>
<P>The Kernel manages two types of objects:</P>
<UL><LI>     <I>Dispatcher objects</I> have a signal state (either signaled or nonsignaled) and control the dispatching and synchronization of system operations. Dispatcher objects include the following:  events, mutants, mutexes, semaphores, threads, and timers.</LI><LI>     <I>Control objects</I> are used to control the operation of the Kernel but do not affect dispatching. <I>Control objects</I> include the following:  asynchronous procedure calls, interrupts, processes, and profiles.</LI></UL><P>Table 1.1 describes how the Executive uses each type of dispatcher object.</P>
<P>Table 1.1    Dispatcher Objects</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="274pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Object type</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>Event</P></TD><TD VALIGN="TOP"><P>Used to record the occurrence of an event and synchronize it with some action that is to be performed.</P></TD></TR><TR><TD VALIGN="TOP"><P>Mutant </P></TD><TD VALIGN="TOP"><P>One of two objects that the Kernel provides for controlling mutually exclusive access to a resource. This type of object is intended for use in providing a user-mode mutual exclusion mechanism that has ownership semantics. It can also be used in Kernel mode.</P></TD></TR><TR><TD VALIGN="TOP"><P>Mutex </P></TD><TD VALIGN="TOP"><P>The other of two objects that the Kernel provides for controlling mutually exclusive access to a resource. This type of object can only be used in Kernel mode and is intended to provide a deadlock-free mutual exclusion mechanism with ownership and other special system semantics.</P></TD></TR><TR><TD VALIGN="TOP"><P>Semaphore</P></TD><TD VALIGN="TOP"><P>Used to control access to a resource, but not necessarily in a mutually exclusive fashion. A semaphore object acts as a gate through which a variable number of threads may pass concurrently, up to a specified limit. The gate is open (signaled state) as long as there are resources available. When the number of resources specified by the limit are concurrently in use, the gate is closed (nonsignaled state).</P></TD></TR><TR><TD VALIGN="TOP"><P>Thread</P></TD><TD VALIGN="TOP"><P>The agent that runs program code and is dispatched to be run  by the Kernel. Each thread is associated with a process object,  which specifies the virtual address space mapping for the thread  and accumulates thread run time. Several thread objects can  be associated with a single process object, which enables the concurrent execution of multiple threads in a single address space (possibly simultaneous execution in a multiprocessor system).</P></TD></TR><TR><TD VALIGN="TOP"><P>Timer</P></TD><TD VALIGN="TOP"><P>Used to record the passage of time and to time out operations</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Table 1.2 describes how the Executive uses each type of control object.</P>
<P>Table 1.2    Control Objects</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="274pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Object type</P></TD><TD VALIGN="TOP"><P>Description</P></TD></TR><TR><TD VALIGN="TOP"><P>Asynchronous Procedure Call </P></TD><TD VALIGN="TOP"><P>Used to break into the execution of a specified thread and cause a procedure to be called in a specified processor mode.</P></TD></TR><TR><TD VALIGN="TOP"><P>Interrupt </P></TD><TD VALIGN="TOP"><P>Used to connect an interrupt source to an interrupt service routine via an entry in an Interrupt Dispatch Table (IDT). Each processor has an IDT that is used to dispatch interrupts that occur on that processor.</P></TD></TR><TR><TD VALIGN="TOP"><P>Process</P></TD><TD VALIGN="TOP"><P>Used to represent the virtual address space and control information necessary for the execution of a set of thread objects. A process object contains a pointer to an address map, a list of ready threads containing thread objects while the process is not in the balance set, a list of threads that belong to the process, the total accumulated time for all threads executing within the process, a base priority, and a default thread affinity. A process object must be initialized before any thread objects that specify the process as their parent can be initialized.</P></TD></TR><TR><TD VALIGN="TOP"><P>Profile</P></TD><TD VALIGN="TOP"><P>Used to measure the distribution of run time within a block  of code. Both user and system code may be profiled.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Generally, the Kernel does not implement any policy since this is the responsibility of the Executive. However, the Kernel does make policy decisions about when it is appropriate to remove processes from memory.</P>
<P>The Kernel runs entirely in kernel mode and is nonpageable. Software within the Kernel is not preemptible and therefore cannot be context-switched, whereas much software outside the Kernel is almost always preemptible and can be context-switched.</P>
<P>The Kernel can run simultaneously on all processors in a multiprocessor configuration, synchronizing access to critical regions as appropriate.</P>
<P>The third and most intricate module that runs in Kernel mode is the Executive. The next several pages describe the functions of the Executive and its components.</P></FONT></BODY></HTML>
