<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VDM Structure</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H3>VDM Structure</H3><P>The 16-bit Windows subsystem is implemented as a virtual MS-DOS machine (VDM) with a layer that emulates Windows 3.1 functionality. All 16-bit Windows-based applications run in the same VDM, a multithreaded Win32 process in which each application runs in its own thread. Below is a diagram of the 16-bit Windows subsystem VDM. A description of each layer follows.</P>
<P><img src="XRGO01.gif"></P>
<P>Figure 15.1  16-bit Windows Subsystem VDM</P>
<P>The 16-bit MS-DOS emulation layer contains all the information to emulate BIOS calls and tables. Some 16-bit Windows applications depend upon BIOS calls, since 16-bit Windows is built on top of MS-DOS.</P>
<P>The Windows 3.1 emulation layer provides the functionality of the Windows 3.1 kernel and 16-bit API stubs. A 16-bit application cannot call a 32-bit API routine. When an application calls a 16-bit API routine, that call is made to a stub routine, which in turn calls a 32-bit API routine. The 32-bit API routine performs the required action, and the result is transformed back into the format expected by the 16-bit API stub, which returns the result to the application. The transformation between 16-bit and 32-bit formats is known as <I>thunking</I>, and is carried out by a separate layer in the VDM.</P>
<P>16-bit Windows-based applications use the memory from 640K to 16&nbsp;MB for their own purposes.</P>
<P>Windows NT does not support 16-bit device drivers that have unrestricted access to hardware (character-mode device drivers that do not depend on special hardware are supported). A secure and robust multitasking operating system cannot let user-level applications talk directly with the hardware because they could completely bypass security and crash the system. (There are exceptions to this, however; refer to "Restrictions," at the beginning of this chapter). The VDM contains a layer of virtual device drivers (VDDs) that allow the sharing of hardware and provide the necessary functionality in a way that is consistent with the design of Windows NT.</P>
<P>The 32-bit MS-DOS emulation layer is for the DOS Protect Mode Interface (DPMI) and 32-bit memory access. This layer replaces calls made to the MS-DOS-level functions for extended and expanded memory with Windows NT memory calls. Windows NT then makes the appropriate conversions so that the 16-bit application sees segmented memory as it normally would.</P>
<P>The purpose of the 32-bit Windows thunking layer was described above.</P>
<P>For Windows NT running on a non-X86 computer, the Instruction Execution Unit emulates the Intel 80286 instruction set, which lets the computer run the binary application. The 16-bit Windows subsystem (or any other VDM) on a non-x86 computer supports only Standard mode 16-bit applications.</P>
<P>On an x86 computer the Instruction Execution Unit acts as a trap handler, capturing instructions that cause hardware traps and transferring control to the code that handles them. A VDM (such as the 16-bit Windows subsystem) on an x86 computer supports Enhanced mode applications; it does not, however, support 16-bit VXDs (virtual device drivers).</P></FONT></BODY></HTML>
