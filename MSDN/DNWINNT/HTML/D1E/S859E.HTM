<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Thunking Mechanism</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD><BODY BGCOLOR="#FFFFFF">
<FONT FACE="verdana,arial,helvetica" SIZE="2"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<H2>Win32 Thunking Mechanism</H2><P>As mentioned earlier in this document, the OS/2 subsystem provides a general mechanism to allow 16-bit OS/2 and PM applications to load and call any Win32 DLL. To take advantage of this feature, you typically need to complete the following tasks:</P>
<UL><LI>     Write a small Win32 DLL thunking layer that will be called by the 16-bit OS/2 application.
<P>This Win32 thunking layer will in turn call the real Win32 API, using the parameters passed by the 16-bit code. The need for such a thunking layer (rather than calling the real Win32 DLL directly from 16-bit) stems from the fact that the OS/2 subsystem thunking mechanism allows only for one generic pointer parameter. Most Win32 APIs require more parameters or of different type so that a small Win32 thunking layer is required to retrieve parameters via the parameter pointer. This parameter pointer points to application-defined data, which will typically be a structure with the parameters for the actual call to the real Win32 API.</P></LI><LI>     Change your 16-bit application to include calls to the Win32 thunking APIs described below.</LI></UL><P>The following 16-bit APIs are to be used by the OS/2 application code. (These APIs are defined in the same manner as OS/2 APIs. See OS/2 1.2 <I>Programmer's Reference Manual</I>.)</P>
<P><BR></P>
<pre><code>USHORT pascal far Dos32LoadModule (<BR>    PSZ DLLName,<BR>    PULONG pDllHandle);</code></pre>
<P><I>Purpose:</I>  Load a Win32 thunk DLL that will intermediate between an OS/2 application and Win32 APIs.</P>
<P><I>Returns:</I>  If NO_ERROR is returned, the value pointed to by <B>pDllHandle</B> is used for other Win32 thunk APIs as described below. It is invalid for usage with regular OS/2 APIs. If ERROR_MOD_NOT_FOUND is returned, the value pointed to by <B>pDLLHandle</B> is undefined.</P>
<P><BR></P>
<pre><code>USHORT pascal far Dos32GetProcAddr (<BR>    ULONG DllHandle,<BR>    PSZ pszProcName,<BR>    PULONG pWin32Thunk);</code></pre>
<P><I>Purpose:</I>  Get a cookie (flat pointer) to a routine in a Win32 thunk DLL, previously opened by <B>Dos32LoadModule</B>. For example, if the OS/2 application wants to call the <B>WinSocketFoo</B> API, it builds a Win32 intermediate DLL, named MYSOCK.DLL, that exports <B>MyWinSocketFoo</B>. The application calls <B>Dos32LoadModule</B> with MYSOCK.DLL and then <B>Dos32GetProcAddr</B> with <B>pszProcName</B> of value <B>MyWinSocketFoo</B>. If no error is returned, it can use the value pointed to by <B>pWin32Thunk</B> in a later call to <B>Dos32Dispatch</B>, for calling the <B>MyWinSocketFoo</B> routine, which in turn will call a real Win32 API (for example, <B>WinSocketFoo</B>).</P>
<P><I>Returns:</I> NO_ERROR if the <B>pszProcName</B> is exported by the Win32 intermediate DLL which relates to <B>DllHandle</B>. If ERROR_PROC_NOT_FOUND or ERROR_INVALID_HANDLE is returned, the value pointed to by <B>pWin32Thunk</B> is undefined.</P>
<P><BR></P>
<pre><code>USHORT pascal far Dos32Dispatch (<BR>    ULONG Win32Thunk,<BR>    PVOID   pArguments,<BR>    PULONG pRetCode);</code></pre>
<P><I>Purpose:</I>  <B>Dos32Dispatch</B> calls the 32-bit thunk routine <B>Win32Thunk</B>, previously obtained by <B>Dos32GetProcAddr</B>. It returns the error code returned by <B>Win32Thunk</B> in <B>pRetCode</B>. It translates the <B>pArguments</B> 16:16 pointer to a flat pointer and passes it to the <B>Win32Thunk</B> call. The structure pointed to by <B>pArguments</B>, and the values of <B>pRetCode</B> are application specific and are not interpreted or modified by the OS/2 subsystem.</P>
<P>On the Win32 side, i.e. in the Win32 DLL, the Win32 thunk has to be defined as follows:</P>
<P><BR></P>
<pre><code>ULONG MyWinSocketFoo (<BR>    PVOID pFlatArg);</code></pre>
<P>The return code from <B>MyWinSocketFoo</B> is application-defined and is copied by the OS/2 subsystem to <B>pRetCode</B>.</P>
<P><I>Returns:</I>  NO_ERROR if the <B>pFlatArg</B> argument is a valid pointer and no exception occurred in the call to it.</P>
<P><BR></P>
<pre><code>USHORT pascal far Dos32FreeModule (<BR>    ULONG DllHandle);</code></pre>
<P><I>Purpose:</I>  Unload a Win32 thunk DLL that intermediates between an OS/2 application and Win32 APIs.</P>
<P><I>Returns:</I>  NO_ERROR if <B>DllHandle</B> indeed corresponds to a Win32 DLL previously loaded by <B>Dos32LoadModule</B> (after the call, <B>DllHandle</B> is no longer valid). Otherwise, ERROR_INVALID_HANDLE is returned.</P>
<P><BR></P>
<pre><code>USHORT pascal far FarPtr2FlatPtr(<BR>    ULONG FarPtr,<BR>    PULONG pFlatPtr);</code></pre>
<P><I>Purpose:</I>  Translates the segmented pointer FarPtr to a flat pointer pointed to by <B>pFlatPtr</B>.</P>
<P><I>Returns:</I>  NO_ERROR if <B>FarPtr</B> is a valid 16:16 pointer: in this case, upon completion of the call <B>pFlatPtr</B> contains a valid 32-bit flat pointer to be used by Win32 code. ERROR_INVALID_PARAMETER is returned if the 16:16 pointer is not valid: in this case the value pointed to by <B>pFlatPt</B>r is undefined.</P>
<P><BR></P>
<pre><code>USHORT pascal far FlatPtr2FarPtr(<BR>    ULONG FlatPtr,<BR>    PULONG pFarPtr);</code></pre>
<P><I>Purpose:</I>  Translates the flat pointer <B>FlatPtr</B> to a far pointer which it stores into <B>pFarPtr</B>.</P>
<P><I>Returns:</I>  NO_ERROR if the 32-bit <B>FlatPtr</B> maps to a valid 16:16 pointer in the 16-bit application's context: in this case, upon completion of the call <B>pFarPtr</B> contains a valid 16:16 segmented pointer to be used by the 16-bit OS/2 code. Otherwise, i.e. if the 16:16 pointer is not a valid address in the 16-bit application's context, ERROR_INVALID_PARAMETER is returned and <B>pFarPtr</B> is undefined.</P>
<P>The following are the .H file and .DEF file that should be compiled and linked with the 16-bit OS/2 application:</P>
<H3 CLASS="h4"><A NAME="sec0"></A>The .H File</H3><P><BR></P>
<pre><code>//<BR>// Definition of WIN32 thunk APIs.<BR>//
extern USHORT pascal far<BR>Dos32LoadModule(PSZ DllName, PULONG pDllHandle);
extern USHORT pascal far<BR>Dos32GetProcAddr(ULONG Handle, PSZ pszProcName, PULONG pWin32Thunk);
extern USHORT pascal far<BR>Dos32Dispatch(ULONG Win32Thunk, PVOID pArguments, PULONG pRetCode);
extern USHORT pascal far<BR>Dos32FreeModule(ULONG DllHandle);
extern USHORT pascal far<BR>FarPtr2FlatPtr(ULONG FarPtr, PULONG pFlarPtr);
extern USHORT pascal far<BR>FlatPtr2FarPtr(ULONG FlatPtr, PULONG pFarPtr);</code></pre>
<H3 CLASS="h4"><A NAME="sec1"></A>The .DEF File</H3><P><BR></P>
<pre><code>IMPORTS<BR>DOSCALLS.DOS32LOADMODULE<BR>   DOSCALLS.DOS32GETPROCADDR<BR>   DOSCALLS.DOS32DISPATCH<BR>   DOSCALLS.DOS32FREEMODULE<BR>   DOSCALLS.FARPTR2FLATPTR<BR>   DOSCALLS.FLATPTR2FARPTR</code></pre></FONT></BODY></HTML>
