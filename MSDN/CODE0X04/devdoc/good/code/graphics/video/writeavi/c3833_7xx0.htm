<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WRITEAVI.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3834"></a>WRITEAVI.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *  WRITEAVI.C <br> * <br> *  Creates the file OUTPUT.AVI, an AVI file consisting of a rotating clock <br> *  face.  This program demonstrates using the functions in AVIFILE.DLL <br> *  to make writing AVI files simple. <br> * <br> *  This is a stripped-down example; a real application would have a user <br> *  interface and check for errors. <br> * <br> ***************************************************************************/ <br> <br> <br>#define  STRICT <br>#define  INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "writeavi.h" <br>//--------------------------------------------------------------------------- <br>// Defines <br>//--------------------------------------------------------------------------- <br>// Our movie is 160x120 and 15 frames long <br>// <br>#define BITMAP_X160 <br>#define BITMAP_Y120 <br>#define N_FRAMES15 <br> <br>#define TEXT_HEIGHT20 <br> <br>#define AVIIF_KEYFRAME0x00000010L // this frame is a key frame. <br> <br>#define BUFSIZE 260 <br> <br>#define LPLPBILPBITMAPINFOHEADER * <br> <br>//--------------------------------------------------------------------------- <br>// Function declarations <br>//--------------------------------------------------------------------------- <br>static void FreeFrames(LPLPBI) ; <br>static void MakeFrames(LPLPBI, UINT, UINT, UINT) ; <br>static HANDLE MakeDib(HBITMAP, UINT); <br> <br>//--------------------------------------------------------------------------- <br>// A quick lookup table for Sin and Cos values <br>//--------------------------------------------------------------------------- <br>// <br>static int aSin[N_FRAMES] = { <br>0,    40,    74,    95,    99, <br>86,    58,    20,    -20,    -58, <br>-86,    -99,    -95,    -74,    -40, <br>} ; <br> <br>static int aCos[N_FRAMES] = { <br>100,    91,    66,    30,    -10, <br>-49,    -80,    -97,    -97,    -80, <br>-50,    -10,    30,    66,    91, <br>} ; <br> <br>//---------------------------------------------------------------------------- <br>// <br>// We don't have a window, we just pop up a dialog <br>// box, write the file, and quit <br>// <br>int PASCAL WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR szCmdLine, <br>int sw) <br>{ <br>LPBITMAPINFOHEADER alpbi[N_FRAMES]; <br>int i; <br>AVISTREAMINFO strhdr; <br>PAVIFILE pfile = NULL; <br>PAVISTREAM ps = NULL, psCompressed = NULL, psText = NULL; <br>char szText[BUFSIZE]; <br>int iLen; <br>AVICOMPRESSOPTIONS opts; <br>AVICOMPRESSOPTIONS FAR * aopts[1] = {&amp;opts}; <br>HRESULT hr; <br>DWORD dwTextFormat; <br>WORD wVer; <br>char szTitle[BUFSIZE]; <br>char szMessage[BUFSIZE]; <br> <br>/* first let's make sure we are running on 1.1 */ <br>wVer = HIWORD(VideoForWindowsVersion()); <br>if (wVer &lt; 0x010a){ <br> /* oops, we are too old, blow out of here */ <br>LoadString(hInstance, IDS_APPERR, szTitle, BUFSIZE ); <br>LoadString(hInstance, IDS_VFWTOOOLD, szMessage, BUFSIZE ); <br>MessageBeep(MB_ICONHAND); <br>MessageBox(NULL, szMessage, szTitle, MB_OK|MB_ICONSTOP); <br>return FALSE; <br>} <br> <br>alpbi[0] = NULL; <br> <br>LoadString(hInstance, IDS_APPNAME, szTitle, BUFSIZE ); <br>LoadString(hInstance, IDS_INTRO, szMessage, BUFSIZE ); <br> <br>if (MessageBox(NULL, szMessage, szTitle, MB_OKCANCEL) == IDCANCEL) <br>return 0; <br> <br>// <br>// Set up the bitmaps for the file in an array <br>// <br>MakeFrames(alpbi, 8, BITMAP_X, BITMAP_Y); <br> <br>AVIFileInit(); <br> <br>// <br>// Open the movie file for writing.... <br>// <br>LoadString(hInstance, IDS_FILENAME, szTitle, BUFSIZE ); <br> <br>hr = AVIFileOpen(&amp;pfile,    // returned file pointer <br>       szTitle,            // file name <br>       OF_WRITE | OF_CREATE,    // mode to open file with <br>       NULL);    // use handler determined <br>    // from file extension.... <br>if (hr != AVIERR_OK) <br>goto error; <br> <br>// Fill in the header for the video stream.... <br> <br>// The video stream will run in 15ths of a second.... <br> <br>_fmemset(&amp;strhdr, 0, sizeof(strhdr)); <br>strhdr.fccType                = streamtypeVIDEO;// stream type <br>strhdr.fccHandler             = 0; <br>strhdr.dwScale                = 1; <br>strhdr.dwRate                 = 15;    // 15 fps <br>strhdr.dwSuggestedBufferSize  = alpbi[0]-&gt;biSizeImage; <br>SetRect(&amp;strhdr.rcFrame, 0, 0,    // rectangle for stream <br>    (int) alpbi[0]-&gt;biWidth, <br>    (int) alpbi[0]-&gt;biHeight); <br> <br>// And create the stream; <br>hr = AVIFileCreateStream(pfile,    // file pointer <br>         &amp;ps,    // returned stream pointer <br>         &amp;strhdr);    // stream header <br>if (hr != AVIERR_OK) { <br>goto error; <br>} <br> <br>_fmemset(&amp;opts, 0, sizeof(opts)); <br> <br>if (!AVISaveOptions(NULL, 0, 1, &amp;ps, (LPAVICOMPRESSOPTIONS FAR *) &amp;aopts)) <br>    goto error; <br> <br>hr = AVIMakeCompressedStream(&amp;psCompressed, ps, &amp;opts, NULL); <br>if (hr != AVIERR_OK) { <br>goto error; <br>} <br> <br>hr = AVIStreamSetFormat(psCompressed, 0, <br>       alpbi[0],    // stream format <br>       alpbi[0]-&gt;biSize +   // format size <br>       alpbi[0]-&gt;biClrUsed * sizeof(RGBQUAD)); <br>if (hr != AVIERR_OK) { <br>goto error; <br>} <br> <br>// Fill in the stream header for the text stream.... <br> <br>// The text stream is in 60ths of a second.... <br> <br>_fmemset(&amp;strhdr, 0, sizeof(strhdr)); <br>strhdr.fccType                = streamtypeTEXT; <br>strhdr.fccHandler             = mmioFOURCC('D', 'R', 'A', 'W'); <br>strhdr.dwScale                = 1; <br>strhdr.dwRate                 = 60; <br>strhdr.dwSuggestedBufferSize  = sizeof(szText); <br>SetRect(&amp;strhdr.rcFrame, 0, (int) alpbi[0]-&gt;biHeight, <br>    (int) alpbi[0]-&gt;biWidth, (int) alpbi[0]-&gt;biHeight + TEXT_HEIGHT); <br> <br>// ....and create the stream. <br>hr = AVIFileCreateStream(pfile, &amp;psText, &amp;strhdr); <br>if (hr != AVIERR_OK) { <br>goto error; <br>} <br> <br>dwTextFormat = sizeof(dwTextFormat); <br>hr = AVIStreamSetFormat(psText, 0, &amp;dwTextFormat, sizeof(dwTextFormat)); <br>if (hr != AVIERR_OK) { <br>goto error; <br>} <br> <br>// <br>// Now write out each video frame, along with a text label. <br>// The video frames are 2/3 of a second apart, which is 10 <br>// in the video time scale and 40 in the text stream's time scale. <br>// <br>for (i = 0; i &lt; N_FRAMES; i++) { <br>hr = AVIStreamWrite(psCompressed,// stream pointer <br>i * 10,// time of this frame <br>1,// number to write <br>(LPBYTE) alpbi[i] +// pointer to data <br>alpbi[i]-&gt;biSize + <br>alpbi[i]-&gt;biClrUsed * sizeof(RGBQUAD), <br>alpbi[i]-&gt;biSizeImage,// size of this frame <br>AVIIF_KEYFRAME, // flags.... <br>NULL, <br>NULL); <br>if (hr != AVIERR_OK) <br>break; <br> <br>// Make some text to put in the file ... <br>LoadString(hInstance, IDS_TEXTFORMAT, szMessage, BUFSIZE ); <br> <br>iLen = wsprintf(szText, szMessage, (int)(i + 1)); <br> <br>// ... and write it as well. <br>hr = AVIStreamWrite(psText, <br>i * 40, <br>1, <br>szText, <br>iLen + 1, <br>AVIIF_KEYFRAME, <br>NULL, <br>NULL); <br>if (hr != AVIERR_OK) <br>break; <br>} <br> <br>error: <br>// <br>// Now close the file <br>// <br>if (ps) <br>AVIStreamClose(ps); <br> <br>if (psCompressed) <br>AVIStreamClose(psCompressed); <br> <br>if (psText) <br>AVIStreamClose(psText); <br> <br>if (pfile) <br>AVIFileClose(pfile); <br> <br>AVIFileExit(); <br>FreeFrames(alpbi); <br> <br>if (hr != NOERROR) { <br>LoadString(hInstance, IDS_APPERR, szTitle, BUFSIZE ); <br>LoadString(hInstance, IDS_WRITEERR, szMessage, BUFSIZE ); <br> <br>MessageBox(NULL, szMessage, szTitle, MB_OK); <br>} <br>return 0; <br>} <br> <br> <br> <br> <br>// <br>// Fill an array of LPBI's with the frames for this movie <br>// <br>static void MakeFrames(LPLPBI alpbi, UINT bits, UINT wXSize,UINT wYSize ) <br>{ <br>HDC         hdc ; <br>HDC         hdcMem ; <br>HBITMAP     hbitmap,hbitmapOld ; <br>HPEN        hpen3,hpen1,hpenwhite,hpenOld ; <br>HFONT       hfont,hfontOld ; <br>HBRUSH      hbrush,hbrushOld ; <br>RECT        rc ; <br>RECT        rcFrameNo ; <br>int         wXCent,wYCent ; <br>int         cxPixInch ; <br>int         cyPixInch ; <br>int         cxPixels ; <br>int         cyPixels ; <br>int         radius ; <br>int         x0,y0,x1,y1 ; <br>int         i,j ; <br>char        szNumber[3] ; <br> <br>// <br>// Make sure our resources are freed <br>// <br>FreeFrames(alpbi); <br> <br>// <br>// Find the center of the movie <br>// <br>wXCent = wXSize/2 ; <br>wYCent = wYSize/2 ; <br> <br>hdc = GetDC(NULL) ; <br>hdcMem = CreateCompatibleDC(NULL) ; <br> <br>// <br>// We need some gray and white brushes and pens, and a bitmap <br>// <br>hpen3 = CreatePen(PS_SOLID,3,RGB(128,128,128)) ; <br>hpen1 = CreatePen(PS_SOLID,1,RGB(64,64,64)); <br>hpenwhite = CreatePen(PS_SOLID,1,RGB(255,255,255)); <br>hpenOld = SelectPen(hdcMem, hpen3); <br>hbrush = CreateSolidBrush(RGB(192,192,192)) ; <br>hbrushOld = SelectBrush(hdcMem,hbrush) ; <br>hbitmap = CreateCompatibleBitmap(hdc,wXSize,wYSize) ; <br> <br>cxPixInch = GetDeviceCaps(hdc,LOGPIXELSX) ; <br>cyPixInch = GetDeviceCaps(hdc,LOGPIXELSY) ; <br> <br>// <br>// What radius of circle can we fit in this frame?  Make sure it's round <br>// regardless of the aspect ratio <br>// <br>radius = ( wXSize &lt; wYSize ) ? wXSize : (wYSize*cxPixInch)/cyPixInch ; <br>radius = ( radius * 95 ) / 200 ; <br> <br>// <br>// Make a Rectangle in the center where the number will go <br>// <br>/* x0 = radius / sqrt(2) */ <br>x0 = (radius*100)/141 ; <br>y0 = (x0*cyPixInch)/cxPixInch ; <br>x0 = (x0*9)/10 ; <br>y0 = (y0*9)/10 ; <br>SetRect( &amp;rcFrameNo,wXCent-x0,wYCent-y0,wXCent+x0,wYCent+y0 ) ; <br> <br>// <br>// Move the rectangle in a little and make a font big enough for it <br>// <br>x0 = (x0*9)/10 ; <br>y0 = (y0*9)/10 ; <br> <br>hfont = CreateFont( <br>y0*2, <br>x0, <br>0, <br>0, <br>FW_BOLD, <br>0, <br>0, <br>0, <br>ANSI_CHARSET, <br>OUT_DEVICE_PRECIS, <br>CLIP_DEFAULT_PRECIS, <br>DEFAULT_QUALITY, <br>DEFAULT_PITCH|FF_SWISS, <br>NULL <br>); <br> <br>hfontOld = SelectFont(hdcMem, hfont); <br> <br>// <br>// Now walk through and make all the frames <br>// <br>for ( i=0; i&lt;N_FRAMES; i++ ) { <br>hbitmapOld = SelectBitmap(hdcMem, hbitmap); <br> <br>// <br>// Fill the whole frame with white <br>// <br>SetRect(&amp;rc,0,0,wXSize,wYSize) ; <br>FillRect(hdcMem,&amp;rc,GetStockBrush(WHITE_BRUSH)) ; <br> <br>// <br>// Draw the circle inside the previously calculated radius <br>// <br>cxPixels = radius ; <br>cyPixels = (cxPixels*cyPixInch)/cxPixInch ; <br> <br>SelectPen(hdcMem,hpen3) ; <br>Ellipse(hdcMem,wXCent-cxPixels,wYCent-cyPixels,wXCent+cxPixels, <br>wYCent+cyPixels) ; <br> <br>SelectPen(hdcMem,hpen1) ; <br> <br>// <br>// Draw the number in the previously calculated area <br>// <br>wsprintf(szNumber,"%02u",i+1) ; <br> <br>SetBkColor(hdcMem,RGB(192,192,192)) ; <br>SetTextColor(hdcMem,RGB(255,255,255)) ; <br>ExtTextOut( <br>hdcMem, <br>rcFrameNo.left, <br>rcFrameNo.top+(rcFrameNo.bottom-rcFrameNo.top)/20, <br>ETO_CLIPPED, <br>&amp;rcFrameNo, <br>szNumber, <br>2, <br>NULL); <br> <br>// <br>// Draw tic marks around the inside of the circle in equal divisions <br>// <br>for ( j=0; j&lt;N_FRAMES; j++ ) { <br>x0 = (radius*aSin[j])/100 ; <br>y0 = (radius*aCos[j])/100 ; <br>x1 = (((radius*aSin[j])/100)*11)/12 ; <br>y1 = (((radius*aCos[j])/100)*11)/12 ; <br> <br>y0 = -(y0*cyPixInch)/cxPixInch ; <br>y1 = -(y1*cyPixInch)/cxPixInch ; <br> <br>MoveToEx(hdcMem,wXCent+x0,wYCent+y0,NULL) ; <br>LineTo(hdcMem,wXCent+x1,wYCent+y1) ; <br>} <br> <br>// <br>// Now draw the hand of the clock in the appropriate position <br>// <br>x1 = (((radius*aSin[i])/100)*5)/8 ; <br>y1 = (((radius*aCos[i])/100)*5)/8 ; <br>y1 = -(y1*cyPixInch)/cxPixInch ; <br> <br>MoveToEx(hdcMem,wXCent,wYCent,NULL) ; <br>LineTo(hdcMem,wXCent+x1,wYCent+y1) ; <br> <br>SelectBitmap(hdcMem, hbitmapOld); <br>// <br>// Make this into a DIB and stuff it into the array <br>// <br>alpbi[i] = (LPBITMAPINFOHEADER)GlobalLock(MakeDib(hbitmap, bits)); <br> <br>// <br>// For an error, just duplicate the last frame if we can <br>// <br>if (alpbi[i] == NULL &amp;&amp; i ) <br>alpbi[i] = alpbi[i-1] ; <br>} <br> <br>// <br>// Select all the old objects back and delete resources <br>// <br>SelectPen(hdcMem, hpenOld); <br>SelectBrush(hdcMem,hbrushOld) ; <br>SelectFont(hdcMem,hfontOld) ; <br>DeletePen(hpen1) ; <br>DeletePen(hpen3) ; <br>DeletePen(hpenwhite) ; <br>DeleteBrush(hbrush) ; <br>DeleteBitmap(hbitmap) ; <br>DeleteFont(hfont) ; <br>DeleteObject(hdcMem) ; <br>ReleaseDC(NULL,hdc) ; <br>} <br> <br>// <br>// Walk through our array of LPBI's and free them <br>// <br>static void FreeFrames(LPLPBI alpbi) <br>{ <br>UINT        w ; <br> <br>if (!alpbi[0]) <br>return ; <br>// <br>// Don't free a frame if it's a duplicate of the previous one <br>// <br>for (w=0; w&lt;N_FRAMES; w++) <br>if (alpbi[w] &amp;&amp; alpbi[w] != alpbi[w-1]) <br>GlobalFreePtr(alpbi[w]); <br>for (w=0; w&lt;N_FRAMES; w++) <br>alpbi[w] = NULL; <br>} <br> <br>/* <br>** MakeDib(hbitmap) <br>** <br>** Take the given bitmap and transform it into a DIB with parameters: <br>** <br>** BitsPerPixel:    8 <br>** Colors:          palette <br>** <br>*/ <br>static HANDLE  MakeDib( HBITMAP hbitmap, UINT bits ) <br>{ <br>HANDLE              hdib ; <br>HDC                 hdc ; <br>BITMAP              bitmap ; <br>UINT                wLineLen ; <br>DWORD               dwSize ; <br>DWORD               wColSize ; <br>LPBITMAPINFOHEADER  lpbi ; <br>LPBYTE              lpBits ; <br> <br>GetObject(hbitmap,sizeof(BITMAP),&amp;bitmap) ; <br> <br>// <br>// DWORD align the width of the DIB <br>// Figure out the size of the colour table <br>// Calculate the size of the DIB <br>// <br>wLineLen = (bitmap.bmWidth*bits+31)/32 * 4; <br>wColSize = sizeof(RGBQUAD)*((bits &lt;= 8) ? 1&lt;&lt;bits : 0); <br>dwSize = sizeof(BITMAPINFOHEADER) + wColSize + <br>(DWORD)(UINT)wLineLen*(DWORD)(UINT)bitmap.bmHeight; <br> <br>// <br>// Allocate room for a DIB and set the LPBI fields <br>// <br>hdib = GlobalAlloc(GHND,dwSize); <br>if (!hdib) <br>return hdib ; <br> <br>lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib) ; <br> <br>lpbi-&gt;biSize = sizeof(BITMAPINFOHEADER) ; <br>lpbi-&gt;biWidth = bitmap.bmWidth ; <br>lpbi-&gt;biHeight = bitmap.bmHeight ; <br>lpbi-&gt;biPlanes = 1 ; <br>lpbi-&gt;biBitCount = (WORD) bits ; <br>lpbi-&gt;biCompression = BI_RGB ; <br>lpbi-&gt;biSizeImage = dwSize - sizeof(BITMAPINFOHEADER) - wColSize ; <br>lpbi-&gt;biXPelsPerMeter = 0 ; <br>lpbi-&gt;biYPelsPerMeter = 0 ; <br>lpbi-&gt;biClrUsed = (bits &lt;= 8) ? 1&lt;&lt;bits : 0; <br>lpbi-&gt;biClrImportant = 0 ; <br> <br>// <br>// Get the bits from the bitmap and stuff them after the LPBI <br>// <br>lpBits = (LPBYTE)(lpbi+1)+wColSize ; <br> <br>hdc = CreateCompatibleDC(NULL) ; <br> <br>GetDIBits(hdc,hbitmap,0,bitmap.bmHeight,lpBits,(LPBITMAPINFO)lpbi, DIB_RGB_COLORS); <br> <br>// Fix this if GetDIBits messed it up.... <br>lpbi-&gt;biClrUsed = (bits &lt;= 8) ? 1&lt;&lt;bits : 0; <br> <br>DeleteDC(hdc) ; <br>GlobalUnlock(hdib); <br> <br>return hdib ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
