<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CAPTEST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3790"></a>CAPTEST.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   captest.c: Source Code for the CapTest Sample Program <br> * <br> *   Microsoft Video for Windows Capture Class Sample Program <br> * <br> ***************************************************************************/ <br> <br> <br>#define ENABLE_ERROR_CALLBACK           1 <br>#define ENABLE_STATUS_CALLBACK          1 <br>#define ENABLE_VIDEOFRAME_CALLBACKS     0 <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;vfw.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;dos.h&gt; <br> <br>#include "captest.h" <br> <br>// <br>// Global Variables <br>// <br>TCHAR           gachAppName[]  = TEXT("CapTestApp") ; <br>TCHAR           gachIconName[] = TEXT("CapTestIcon") ; <br>TCHAR           gachMenuName[] = TEXT("CapTestMenu") ; <br>TCHAR           gachMCIDeviceName[21] = TEXT("VideoDisc") ;  // default MCI device <br>TCHAR           gachString[128] ; <br>TCHAR           gachBuffer[200] ; <br> <br>HINSTANCE      ghInstApp ; <br>HWND           ghWndMain ; <br>HWND           ghWndCap ; <br>HANDLE         ghAccel ; <br>WORD           gwDeviceIndex ; <br>WORD           gwPalFrames = DEF_PALNUMFRAMES ; <br>WORD           gwPalColors = DEF_PALNUMCOLORS ; <br>WORD           gwCapFileSize ; <br>DWORD          gdwFrameNum ; <br>DWORD          gdwVideoNum ; <br> <br>CAPSTATUS      gCapStatus ; <br>CAPDRIVERCAPS  gCapDriverCaps ; <br>CAPTUREPARMS   gCapParms ; <br> <br>LPWAVEFORMATEX glpwfex ; <br> <br>// MakeProcInstance is only required for 16-bit apps <br>#ifndef WIN32 <br> FARPROC        fpErrorCallback; <br> FARPROC        fpStatusCallback; <br> FARPROC        fpFrameCallback; <br> FARPROC        fpVideoCallback; <br>#endif <br> <br>// Function prototypes <br>// <br>LONG FAR PASCAL MainWndProc(HWND, UINT, UINT, LONG) ; <br>LRESULT FNWCALLBACK ErrorCallbackProc(HWND, int, LPTSTR) ; <br>LRESULT FNWCALLBACK StatusCallbackProc(HWND, int, LPTSTR) ; <br>LRESULT FNWCALLBACK FrameCallbackProc(HWND, LPVIDEOHDR) ; <br>LRESULT FNWCALLBACK VideoCallbackProc(HWND, LPVIDEOHDR) ; <br> <br>// <br>// WinMain: Application Entry Point Function <br>// <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>/////////////////////////////////////////////////////////////////////// <br>//  hInstance:      handle for this instance <br>//  hPrevInstance:  handle for possible previous instances <br>//  lpszCmdLine:    long pointer to exec command line <br>//  nCmdShow:       Show code for main window display <br>/////////////////////////////////////////////////////////////////////// <br> <br>    MSG          msg ; <br>    WNDCLASS     wc ; <br> <br>    ghInstApp = hInstance ; <br>    if (! hPrevInstance) { <br>        // If it's the first instance, register the window class <br>        wc.lpszClassName = gachAppName ; <br>        wc.hInstance     = hInstance ; <br>        wc.lpfnWndProc   = MainWndProc ; <br>        wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ; <br>        wc.hIcon         = LoadIcon(hInstance, gachIconName) ; <br>        wc.lpszMenuName  = gachMenuName ; <br>        wc.hbrBackground = GetStockObject(WHITE_BRUSH) ; <br>        wc.style         = CS_HREDRAW | CS_VREDRAW ; <br>        wc.cbClsExtra    = 0 ; <br>        wc.cbWndExtra    = 0 ; <br> <br>        if (! RegisterClass(&amp;wc)) { <br>            LoadString(ghInstApp, IDS_ERR_REGISTER_CLASS, gachString, sizeof(gachString)/sizeof(TCHAR)) ; <br>            MessageBox(NULL, gachString, NULL, <br>#ifdef BIDI <br>                MB_RTL_READING | <br>#endif <br> <br>            MB_ICONEXCLAMATION) ; <br>            return 0 ; <br>        } <br>    } <br> <br>    // Create Application's Main window <br>    ghWndMain = <br>#ifdef BIDI <br> <br>// <br>// unfortunately you can't just #ifdef the CreateWindow line and leave <br>// the parameters common: on Win32, CreateWindow is a macro and does not <br>// expand correctly if you ifdef only the 'CreateWindow(' line. <br>// <br>        CreateWindowEx(WS_EX_BIDI_SCROLL |  WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON, <br>                             gachAppName, <br>                             TEXT("Capture Test App"), <br>                             WS_CAPTION      | <br>                             WS_SYSMENU      | <br>                             WS_MINIMIZEBOX  | <br>                             WS_MAXIMIZEBOX  | <br>                             WS_THICKFRAME   | <br>                             WS_CLIPCHILDREN | <br>                             WS_OVERLAPPED, <br>                             CW_USEDEFAULT, 0, <br>                             320, 240, <br>                             NULL, <br>                             NULL, <br>                             ghInstApp, <br>                             NULL) ; <br>#else <br>        CreateWindow ( <br>                             gachAppName, <br>                             TEXT("Capture Test App"), <br>                             WS_CAPTION      | <br>                             WS_SYSMENU      | <br>                             WS_MINIMIZEBOX  | <br>                             WS_MAXIMIZEBOX  | <br>                             WS_THICKFRAME   | <br>                             WS_CLIPCHILDREN | <br>                             WS_OVERLAPPED, <br>                             CW_USEDEFAULT, 0, <br>                             320, 240, <br>                             NULL, <br>                             NULL, <br>                             ghInstApp, <br>                             NULL) ; <br>#endif <br> <br>    if (ghWndMain == NULL) { <br>        LoadString(ghInstApp, IDS_ERR_CREATE_WINDOW, gachString, sizeof(gachString)/sizeof(TCHAR)) ; <br>        MessageBox(NULL, gachString, NULL, <br>#ifdef BIDI <br>                MB_RTL_READING | <br>#endif <br> <br>        MB_ICONEXCLAMATION | MB_OK) ; <br>        return IDS_ERR_CREATE_WINDOW ; <br>    } <br> <br>    ShowWindow(ghWndMain, nCmdShow) ; <br>    UpdateWindow(ghWndMain) ; <br>    ghAccel = LoadAccelerators(ghInstApp, gachAppName) ; <br> <br>    // All set; get and process messages <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if (! TranslateAccelerator(ghWndMain, ghAccel, &amp;msg)) { <br>            TranslateMessage(&amp;msg) ; <br>            DispatchMessage(&amp;msg) ; <br>        } <br>    } <br> <br>    return msg.wParam ; <br>}  // End of WinMain <br> <br> <br>// <br>// ErrorCallbackProc: Error Callback Function <br>// <br>LRESULT FNWCALLBACK ErrorCallbackProc(HWND hWnd, int nErrID, LPTSTR lpErrorText) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:          Application main window handle <br>//  nErrID:        Error code for the encountered error <br>//  lpErrorText:   Error text string for the encountered error <br>//////////////////////////////////////////////////////////////////////// <br> <br>    if (!ghWndMain) <br>        return FALSE; <br> <br>    if (nErrID == 0)            // Starting a new major function <br>        return TRUE;            // Clear out old errors... <br> <br>    // Show the error ID and text <br>    wsprintf(gachBuffer, TEXT("Error# %d"), nErrID) ; <br> <br>    MessageBox(hWnd, lpErrorText, gachBuffer, <br>#ifdef BIDI <br>                MB_RTL_READING | <br>#endif <br>                MB_OK | MB_ICONEXCLAMATION) ; <br> <br>    return (LRESULT) TRUE ; <br>} <br> <br> <br>// <br>// StatusCallbackProc: Status Callback Function <br>// <br>LRESULT FNWCALLBACK StatusCallbackProc(HWND hWnd, int nID, LPTSTR lpStatusText) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:           Application main window handle <br>//  nID:            Status code for the current status <br>//  lpStatusText:   Status text string for the current status <br>//////////////////////////////////////////////////////////////////////// <br> <br>    if (!ghWndMain) <br>        return FALSE; <br> <br>    if (nID == 0) {              // Zero means clear old status messages <br>        SetWindowText(ghWndMain, (LPTSTR) gachAppName) ; <br>        return (LRESULT) TRUE ; <br>    } <br> <br>    // Show the status ID and status text... <br>    wsprintf(gachBuffer, TEXT("Status# %d: %s"), nID, lpStatusText) ; <br> <br>        SetWindowText(ghWndMain, (LPTSTR)gachBuffer) ; <br> <br>    return (LRESULT) TRUE ; <br>} <br> <br> <br>// <br>// FrameCallbackProc: Frame Callback Function <br>// Called whenever a new frame is captured but not streaming <br>// <br>LRESULT FNWCALLBACK FrameCallbackProc(HWND hWnd, LPVIDEOHDR lpVHdr) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:       Application main window handle <br>//  lpVHdr:     long pointer to VideoHdr struct containing captured <br>//              frame information <br>//////////////////////////////////////////////////////////////////////// <br> <br>    if (!ghWndMain) <br>        return FALSE; <br> <br>    wsprintf(gachBuffer, TEXT("Preview frame# %ld "), gdwFrameNum++) ; <br> <br>    SetWindowText(ghWndMain, (LPTSTR)gachBuffer) ; <br>    return (LRESULT) TRUE ; <br>} <br> <br> <br>// <br>// VideoCallbackProc: Video Stream Callback Function <br>// Called whenever a new frame is captured while streaming <br>// <br>LRESULT FNWCALLBACK VideoCallbackProc(HWND hWnd, LPVIDEOHDR lpVHdr) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:       Application main window handle <br>//  lpVHdr:     long pointer to VideoHdr struct containing captured <br>//              frame information <br>//////////////////////////////////////////////////////////////////////// <br> <br>    gdwVideoNum++;      // Testing:  just count the callbacks <br> <br>    return (LRESULT) TRUE ; <br>} <br> <br> <br>// <br>// CenterCaptureWindow: Placess Capture Window at the Center of Main Window <br>// <br>static void CenterCaptureWindow(HWND hWndM, HWND hWndC) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWndM:      Application main window handle <br>//  hWndC:      Capture window handle <br>//////////////////////////////////////////////////////////////////////// <br> <br>    RECT       MainRect ; <br>    RECT       CapRect ; <br>    WORD       wCapXPos ; <br>    WORD       wCapYPos ; <br> <br>    // Get the sizes of main and capture windows and <br>    // calculate the location for centering <br>    GetClientRect(hWndM, &amp;MainRect) ; <br>    GetClientRect(hWndC, &amp;CapRect) ; <br>    wCapXPos = max(0, (Width(MainRect) - Width(CapRect)) / 2) ; <br>    wCapYPos = max(0, (Height(MainRect) - Height(CapRect)) / 2) ; <br> <br>    // Position the capture window at the required location <br>    MoveWindow(hWndC, wCapXPos, wCapYPos, Width(CapRect), <br>               Height(CapRect), TRUE) ; <br>} <br> <br> <br>// <br>// StartNewVideoChannel: Gets Selected Driver's Caps -- Updates menu, <br>//                       Checks Image Size -- Resizes display window, <br>//                       Enables Preview (at 15 FPS rate) <br>// <br>static void StartNewVideoChannel(HWND hWndM, HWND hWndC, WORD wIndex) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWndM:      Application main window handle <br>//  hWndC:      Capture window handle <br>//  wIndex:     Selected capture driver index <br>//////////////////////////////////////////////////////////////////////// <br> <br>    HMENU       hMenu = GetMenu(hWndM) ; <br> <br>    // Get capture driver settings and update menu <br>    capDriverGetCaps(hWndC, &amp;gCapDriverCaps, sizeof(CAPDRIVERCAPS)) ; <br>    EnableMenuItem(hMenu, IDM_O_OVERLAY, MF_BYCOMMAND | <br>                gCapDriverCaps.fHasOverlay ? MF_ENABLED : MF_GRAYED) ; <br>    EnableMenuItem(hMenu, IDM_O_VIDEOFORMAT, MF_BYCOMMAND | <br>                gCapDriverCaps.fHasDlgVideoFormat ? MF_ENABLED : MF_GRAYED) ; <br>    EnableMenuItem(hMenu, IDM_O_VIDEOSOURCE, MF_BYCOMMAND | <br>                gCapDriverCaps.fHasDlgVideoSource ? MF_ENABLED : MF_GRAYED) ; <br>    EnableMenuItem(hMenu, IDM_O_VIDEODISPLAY, MF_BYCOMMAND | <br>                gCapDriverCaps.fHasDlgVideoDisplay ? MF_ENABLED : MF_GRAYED) ; <br> <br>    // Get video format and adjust capture window <br>    capGetStatus(hWndC, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>    SetWindowPos(hWndC, NULL, 0, 0, gCapStatus.uiImageWidth, <br>                 gCapStatus.uiImageHeight, SWP_NOZORDER | SWP_NOMOVE) ; <br> <br>    // Start preview by default <br>    capPreviewRate(hWndC, MS_FOR_15FPS) ; <br>    capPreview(hWndC, TRUE) ; <br> <br>    // Put check mark beside appropriate menu options <br>    CheckMenuItem(hMenu, wIndex + IDM_O_DRIVERS, MF_BYCOMMAND | MF_CHECKED) ; <br>} <br> <br> <br>// <br>// MenuProc: Processes All Menu-based Operations <br>// <br>long FAR PASCAL MenuProc(HWND hWnd, UINT wParam, LONG lParam) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:      Application main window handle <br>//  hMenu:     Application menu handle <br>//  wParam:    Menu option <br>//  lParam:    Additional info for any menu option <br>//////////////////////////////////////////////////////////////////////// <br> <br>    OPENFILENAME ofn ; <br>    DWORD        dwError ; <br>    WORD         wIndex ; <br>    BOOL         fResult ; <br>    DWORD        dwSize ; <br>    TCHAR        achBuffer[_MAX_PATH] ; <br>    TCHAR        achFileName[_MAX_PATH] ; <br>    TCHAR        *szFileFilter = TEXT("Microsoft AVI\0") <br>                                 TEXT("*.avi\0") <br>                                 TEXT("All Files\0") <br>                                 TEXT("*.*\0") ; <br> <br>    HMENU hMenu = GetMenu(hWnd) ; <br> <br>    switch (wParam) { <br>        case IDM_F_SETCAPTUREFILE: <br>        { <br>            LPTSTR p; <br> <br>            // Get current capture file name and <br>            // then try to get the new capture file name <br>            dwError = capFileGetCaptureFile(ghWndCap, achFileName, <br>                                        sizeof(achFileName)/sizeof(TCHAR)); <br>            if (dwError) { <br> <br>                // Get just the path info <br>                // Terminate the full path at the last backslash <br>                lstrcpy (achBuffer, achFileName); <br>                for (p = achBuffer + lstrlen(achBuffer); p &gt; achBuffer; p--) { <br>                    if (*p == '\\') { <br>                        *(p+1) = '\0'; <br>                        break; <br>                    } <br>                } <br> <br>                _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>                ofn.lStructSize = sizeof(OPENFILENAME) ; <br>                ofn.hwndOwner = hWnd ; <br>                ofn.lpstrFilter = szFileFilter ; <br>                ofn.nFilterIndex = 0 ; <br>                ofn.lpstrFile = achFileName ; <br>                ofn.nMaxFile = sizeof(achFileName)/sizeof(TCHAR) ; <br>                ofn.lpstrFileTitle = NULL; <br>                ofn.lpstrTitle = TEXT("Set Capture File") ; <br>                ofn.nMaxFileTitle = 0 ; <br>                ofn.lpstrInitialDir = achBuffer; <br>                ofn.Flags = <br>#ifdef BIDI <br>                OFN_BIDIDIALOG | <br>#endif <br>                OFN_HIDEREADONLY | <br>                OFN_NOREADONLYRETURN | <br>                OFN_PATHMUSTEXIST ; <br> <br>                if (GetOpenFileName(&amp;ofn)) <br>                    // If the user has hit OK then set capture file name <br>                    capFileSetCaptureFile(ghWndCap, achFileName) ; <br>            } <br>        } <br>        break; <br> <br>        case IDM_F_SAVEVIDEOAS: <br>            // Get the current capture file name and <br>            // then get the substitute file name to save video in <br>            dwError = capFileGetCaptureFile(ghWndCap, achFileName, sizeof(achFileName)/sizeof(TCHAR)); <br>            if (dwError) { <br> <br>                _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>                ofn.lStructSize = sizeof(OPENFILENAME) ; <br>                ofn.hwndOwner = hWnd ; <br>                ofn.lpstrFilter = szFileFilter ; <br>                ofn.nFilterIndex = 0 ; <br>                ofn.lpstrFile = achFileName ; <br>                ofn.nMaxFile = sizeof(achFileName)/sizeof(TCHAR) ; <br>                ofn.lpstrFileTitle = NULL ; <br>                ofn.lpstrTitle = TEXT("Save Video As...") ; <br>                ofn.nMaxFileTitle = 0 ; <br>                ofn.lpstrInitialDir = NULL ; <br>                ofn.Flags = <br>#ifdef BIDI <br>                OFN_BIDIDIALOG | <br>#endif <br>                OFN_PATHMUSTEXIST ; <br> <br>                if (GetSaveFileName(&amp;ofn)) <br>                    // If the user has hit OK then set save file name <br>                    capFileSaveAs(ghWndCap, achFileName) ; <br>            } <br>            break; <br> <br>        case IDM_F_ALLOCATESPACE: <br>            if (DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_AllocCapFileSpace), <br>                          hWnd, AllocCapFileProc)) <br>                // If user has hit OK then alloc requested capture file space <br>                if (! capFileAlloc(ghWndCap, (long) gwCapFileSize * ONEMEG)) <br>                    MessageBox(NULL, TEXT("Can't pre-allocate capture file space"), <br>                               TEXT("Error"), <br>#ifdef BIDI <br>                                MB_RTL_READING | <br>#endif <br>                                MB_OK | MB_ICONEXCLAMATION) ; <br>            break ; <br> <br>        case IDM_F_EXIT: <br>            DestroyWindow(hWnd) ; <br>            break; <br> <br>        case IDM_E_COPY: <br>            capEditCopy(ghWndCap) ; <br>            break; <br> <br>        case IDM_E_PASTEPALETTE: <br>            capPalettePaste(ghWndCap) ; <br>            break; <br> <br>        case IDM_O_PREVIEW: <br>            // Toggle Preview <br>        capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>            capPreview(ghWndCap, !gCapStatus.fLiveWindow) ; <br>            break; <br> <br>        case IDM_O_OVERLAY: <br>            // Toggle Overlay <br>        capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>            capOverlay(ghWndCap, !gCapStatus.fOverlayWindow) ; <br>            break ; <br> <br>        case IDM_O_AUDIOFORMAT: <br>#ifdef  USE_ACM <br>            { <br>                ACMFORMATCHOOSE cfmt; <br> <br>                // Ask the ACM what the largest wave format is..... <br>                acmMetrics(NULL, <br>                            ACM_METRIC_MAX_SIZE_FORMAT, <br>                            &amp;dwSize); <br> <br>                // Get the current audio format <br>                dwSize = max (dwSize, capGetAudioFormatSize (ghWndCap)); <br>                glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize) ; <br>                capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br> <br>                _fmemset (&amp;cfmt, 0, sizeof (ACMFORMATCHOOSE)); <br>                cfmt.cbStruct = sizeof (ACMFORMATCHOOSE); <br>                cfmt.fdwStyle =  ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT; <br>                cfmt.fdwEnum =   ACM_FORMATENUMF_HARDWARE | <br>                                 ACM_FORMATENUMF_INPUT; <br>                cfmt.hwndOwner = hWnd; <br>                cfmt.pwfx =     glpwfex; <br>                cfmt.cbwfx =    dwSize; <br>                if (!acmFormatChoose(&amp;cfmt)) <br>                    capSetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br> <br>                GlobalFreePtr(glpwfex) ; <br>            } <br>#else <br>            // If not using ACM, remove the reference in the link line <br>            // of makefile. <br> <br>            // Get current audio format and then find required format <br>            dwSize = capGetAudioFormatSize (ghWndCap); <br>            if(!dwSize) break; <br>            glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize) ; <br>            capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br> <br>            if (DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_AudioFormat), hWnd, AudioFormatProc)) <br>                capSetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize);  // If the user has hit OK, set the new audio format <br> <br>            GlobalFreePtr(glpwfex) ; <br>#endif <br>            break ; <br> <br>        case IDM_O_VIDEOFORMAT: <br>            if (gCapDriverCaps.fHasDlgVideoFormat) { <br>                // Only if the driver has a "Video Format" dialog box <br>                if (capDlgVideoFormat(ghWndCap)) {  // If successful, <br>                    // Get the new image dimension and center capture window <br>                    capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>                    SetWindowPos(ghWndCap, NULL, 0, 0, gCapStatus.uiImageWidth, <br>                        gCapStatus.uiImageHeight, SWP_NOZORDER | SWP_NOMOVE) ; <br>                    CenterCaptureWindow(hWnd, ghWndCap) ; <br>                } <br>            } <br>            break; <br> <br>        case IDM_O_VIDEOSOURCE: <br>            if (gCapDriverCaps.fHasDlgVideoSource) { <br>                // Only if the driver has a "Video Source" dialog box <br>                capDlgVideoSource(ghWndCap) ; <br>            } <br>            break ; <br> <br>        case IDM_O_VIDEODISPLAY: <br>            if (gCapDriverCaps.fHasDlgVideoDisplay) { <br>                // Only if the driver has a "Video Display" dialog box <br>                capDlgVideoDisplay(ghWndCap) ; <br>            } <br>            break ; <br> <br>        case IDM_O_PALETTE: <br>            if (DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_MakePalette), hWnd, MakePaletteProc)) <br>                // If the user has hit OK, capture palette with the <br>                // specified number of colors and frames <br>                capPaletteAuto(ghWndCap, gwPalFrames, gwPalColors) ; <br>            break; <br> <br>        case IDM_C_CAPTUREVIDEO: <br>            gdwVideoNum = 0 ;  // Start counting video frames <br>            // Capture video sequence <br>            fResult = capCaptureSequence(ghWndCap) ; <br>            break; <br> <br>        case IDM_C_CAPTUREFRAME: <br>            gdwFrameNum = 0 ;  // Start counting single frames <br>            // Turn off overlay / preview (gets turned off by frame capture) <br>    capPreview(ghWndCap, FALSE); <br>    capOverlay(ghWndCap, FALSE); <br> <br>            // Grab a frame <br>            fResult = capGrabFrameNoStop(ghWndCap) ; <br>            break; <br> <br>        case IDM_C_CAPTURESETTINGS: <br>            // Get the current setup for video capture <br>            capCaptureGetSetup(ghWndCap, &amp;gCapParms, sizeof(CAPTUREPARMS)) ; <br> <br>            // Invoke a Dlg box to setup all the params <br>            if (DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_CapSetUp), hWnd, CapSetUpProc)) <br>                // If the user has hit OK, set the new setup info <br>                capCaptureSetSetup(ghWndCap, &amp;gCapParms, sizeof(CAPTUREPARMS)) ; <br>            break; <br> <br>        case IDM_O_CHOOSECOMPRESSOR: <br>            capDlgVideoCompression(ghWndCap); <br>            break; <br> <br>        case IDM_H_ABOUT: <br>            DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_HelpAboutBox), hWnd, AboutProc) ; <br>            break ; <br> <br>        default: <br>            // There is a chance, a driver change has been requested <br>            if ( IsDriverIndex(wParam) ) { <br>                // If it's a valid driver index... <br>                if (wParam - IDM_O_DRIVERS != gwDeviceIndex) { <br>                    // and a different one too then we need to do the rest <br> <br>                    // Turn off preview/overlay, uncheck current driver option <br>                    capPreview(ghWndCap, FALSE) ; <br>                    capOverlay(ghWndCap, FALSE) ; <br>                    CheckMenuItem(GetMenu(hWnd), gwDeviceIndex + IDM_O_DRIVERS, <br>                                  MF_BYCOMMAND | MF_UNCHECKED) ; <br> <br>                    // Connect to requested driver <br>                    if ( capDriverConnect(ghWndCap, (wIndex = (WORD) (wParam - IDM_O_DRIVERS))) ) { <br>                        // Connect worked fine -- update menu, start new driver... <br>                        CheckMenuItem(GetMenu(hWnd), wParam, MF_BYCOMMAND | MF_CHECKED) ; <br>                        gwDeviceIndex = (WORD) (wParam - IDM_O_DRIVERS) ; <br>                        StartNewVideoChannel(hWnd, ghWndCap, gwDeviceIndex) ; <br>                        CenterCaptureWindow(hWnd, ghWndCap) ; <br>                    } <br>                    else { <br>                        // if connect failed, re-connect back to previous driver <br>                        if (! capDriverConnect(ghWndCap, gwDeviceIndex)) { <br>                            MessageBox(hWnd, TEXT("Now can't connect back to previous driver !!"), <br>                                       TEXT("Error"), <br>#ifdef BIDI <br>                            MB_RTL_READING | <br>#endif <br> <br>                            MB_OK | MB_ICONSTOP) ; <br>                            return -1L ; <br>                        } <br>                        else <br>                            // Re-start previous driver as it was before <br>                            StartNewVideoChannel(hWnd, ghWndCap, gwDeviceIndex) ; <br>                            CenterCaptureWindow(hWnd, ghWndCap) ; <br>                    } <br>                }   // end of if ( != gwDeviceIndex) <br>            }   // end of if (IsDriverIndex()) <br>            else { <br>                wsprintf(achBuffer, TEXT("How could you specify this (%u) Driver Index ?"), <br>                         wParam - IDM_O_DRIVERS) ; <br>                MessageBox(hWnd, achBuffer, TEXT("Oops!!"), <br>#ifdef BIDI <br>                MB_RTL_READING | <br>#endif <br>                MB_OK | MB_ICONEXCLAMATION) ; <br>            } <br> <br>            break ; <br>    } <br> <br>    return 0L ; <br>} <br> <br> <br>// <br>// MainWndProc: Application Main Window Procedure <br>// <br>LONG FAR PASCAL MainWndProc(HWND hWnd, UINT Message, UINT wParam, LONG lParam) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:      Application main window handle <br>//  Message:   Next message to be processed <br>//  wParam:    WORD param for the message <br>//  lParam:    LONG param for the message <br>//////////////////////////////////////////////////////////////////////// <br> <br>    switch (Message) { <br>        case WM_COMMAND: <br>            MenuProc(hWnd, wParam, lParam) ; <br>            break ; <br> <br>        case WM_CREATE: <br>        { <br>            TCHAR    achDeviceName[80] ; <br>            TCHAR    achDeviceVersion[100] ; <br>            TCHAR    achBuffer[100] ; <br>            WORD    wDriverCount = 0 ; <br>            WORD    wIndex ; <br>            DWORD   dwError ; <br>            HMENU   hMenu ; <br> <br>            // First create the capture window <br>            ghWndCap = capCreateCaptureWindow((LPTSTR)TEXT("Capture Window"), <br>                                              WS_CHILD | WS_VISIBLE, <br>                                              0, 0, 160, 120, <br>                                              (HWND) hWnd, (int) 0) ; <br> <br>            hMenu = GetSubMenu(GetMenu(hWnd), 2) ;  // 2 for "Option" <br> <br>#if ENABLE_ERROR_CALLBACK <br>  #ifdef WIN32 <br>            // Register the status and error callbacks before driver connect <br>            capSetCallbackOnError(ghWndCap, ErrorCallbackProc) ; <br>  #else <br>            fpErrorCallback = MakeProcInstance((FARPROC)ErrorCallbackProc, ghInstApp) ; <br>            capSetCallbackOnError(ghWndCap, fpErrorCallback) ; <br>  #endif <br>#endif <br> <br>#if ENABLE_STATUS_CALLBACK <br>  #ifdef WIN32 <br>            capSetCallbackOnStatus(ghWndCap, StatusCallbackProc) ; <br>  #else <br>            fpStatusCallback = MakeProcInstance((FARPROC)StatusCallbackProc, ghInstApp) ; <br>            capSetCallbackOnStatus(ghWndCap, fpStatusCallback) ; <br>  #endif <br>#endif <br> <br>#if ENABLE_VIDEOFRAME_CALLBACKS <br>  #ifdef WIN32 <br>            capSetCallbackOnVideoStream(ghWndCap, VideoCallbackProc) ; <br>            capSetCallbackOnFrame(ghWndCap, FrameCallbackProc) ; <br>  #else <br>            fpVideoCallback = MakeProcInstance((FARPROC)VideoCallbackProc, ghInstApp) ; <br>            capSetCallbackOnVideoStream(ghWndCap, fpVideoCallback) ; <br> <br>            fpFrameCallback = MakeProcInstance((FARPROC)FrameCallbackProc, ghInstApp) ; <br>            capSetCallbackOnFrame(ghWndCap, fpFrameCallback) ; <br>  #endif <br>#endif <br>            // Try to connect one of the MSVIDEO drivers <br>            for (wIndex = 0 ; wIndex &lt; MAXVIDDRIVERS ; wIndex++) { <br>                if (capGetDriverDescription(wIndex, <br>                           (LPTSTR)achDeviceName, sizeof(achDeviceName)/ sizeof(TCHAR), <br>                           (LPTSTR)achDeviceVersion, sizeof(achDeviceVersion)/sizeof(TCHAR))) { <br> <br>                    // There is such a driver in the "system.ini" file. <br>                    // Append driver name to "Options" list in menu <br>                    wsprintf(achBuffer, TEXT("&amp;%d %s"), wIndex, (LPTSTR)achDeviceName) ; <br>                    AppendMenu(hMenu, MF_ENABLED, IDM_O_DRIVERS+wIndex, achBuffer) ; <br> <br>                    if (wDriverCount++ == 0) { <br>                        // Only if no other driver is already connected <br>                        dwError = capDriverConnect(ghWndCap, wIndex); <br>                        if (dwError) { <br>                            CheckMenuItem(GetMenu(hWnd), IDM_O_DRIVERS+wIndex, MF_BYCOMMAND | MF_CHECKED) ; <br>                            gwDeviceIndex = wIndex ; <br>                        } <br>                    } <br>                } // end of if (capGetDriverDesc..()) <br>            } <br> <br>            // Now refresh menu, position capture window, start driver etc <br>            DrawMenuBar(hWnd) ; <br>            CenterCaptureWindow(hWnd, ghWndCap) ; <br>            StartNewVideoChannel(hWnd, ghWndCap, gwDeviceIndex) ; <br> <br>            break ; <br>        } <br> <br>        case WM_MOVE: <br>        case WM_SIZE: <br>            CenterCaptureWindow(hWnd, ghWndCap) ; <br>            break ; <br> <br>        case WM_PALETTECHANGED: <br>        case WM_QUERYNEWPALETTE: <br>            // Pass the buck to Capture window proc <br>            PostMessage(ghWndCap, Message, wParam, lParam) ; <br>            break ; <br> <br>        case WM_INITMENU: <br>        { <br>            BOOL          fResult ; <br> <br>            // Initially check if "Options.PastePalette" should be enabled <br>            fResult = IsClipboardFormatAvailable(CF_PALETTE) ? <br>                      MF_ENABLED : MF_GRAYED ; <br>            EnableMenuItem((HMENU) wParam, IDM_E_PASTEPALETTE, fResult) ; <br> <br>    // Check/Uncheck Preview and Overlay <br>        capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>        CheckMenuItem((HMENU)wParam, IDM_O_PREVIEW, gCapStatus.fLiveWindow <br>? MF_CHECKED : MF_UNCHECKED); </code></pre>
<p>
</p>
<pre><code>CheckMenuItem((HMENU)wParam, IDM_O_OVERLAY,gCapStatus.fOverlayWindow <br>? MF_CHECKED : MF_UNCHECKED); <br>        } <br> <br>        case WM_PAINT: <br>        { <br>            HDC           hDC ; <br>            PAINTSTRUCT   ps ; <br> <br>            hDC = BeginPaint(hWnd, &amp;ps) ; <br> <br>            // Included in case the background is not a pure color <br>            SetBkMode(hDC, TRANSPARENT) ; <br> <br>            EndPaint(hWnd, &amp;ps) ; <br>            break ; <br>        } <br> <br>        case WM_CLOSE: <br>            // Disable and free all the callbacks <br>#if ENABLE_ERROR_CALLBACK <br>            capSetCallbackOnError(ghWndCap, NULL) ; <br>  #ifndef WIN32 <br>            FreeProcInstance(fpErrorCallback) ; <br>  #endif <br>#endif <br> <br>#if ENABLE_STATUS_CALLBACK <br>            capSetCallbackOnStatus(ghWndCap, NULL) ; <br>  #ifndef WIN32 <br>            FreeProcInstance(fpStatusCallback) ; <br>  #endif <br>#endif <br> <br>#if ENABLE_VIDEOFRAME_CALLBACKS <br>            capSetCallbackOnFrame(ghWndCap, NULL) ; <br>            capSetCallbackOnVideoStream(ghWndCap, NULL) ; <br>  #ifndef WIN32 <br>            FreeProcInstance(fpFrameCallback) ; <br>            FreeProcInstance(fpVideoCallback) ; <br>  #endif <br>#endif <br>            // Destroy child windows, modeless dialogs, then this window... <br> <br>            DestroyWindow(ghWndCap) ; <br>            DestroyWindow(hWnd) ; <br>            break ; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0) ; <br>            break ; <br> <br>        default: <br>            return DefWindowProc(hWnd, Message, wParam, lParam) ; <br>    } <br> <br>    return 0L; <br>}   // End of MainWndProc <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
