<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3788"></a>DIALOGS.C</h2>
<pre><code>/**************************************************************************** <br> * <br> *   dialogs.c: Code for dialog procs of CapTest Sample Program <br> * <br> *   Microsoft Video for Windows Capture Class Test Program <br> * <br> ***************************************************************************/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;vfw.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;dos.h&gt; <br> <br>#include "captest.h" <br> <br>static long GetFreeDiskSpace(WORD) ; <br>static int  CountMCIDevices(WORD) ; <br> <br>// <br>// AboutProc: About Dialog Box Procedure <br>// <br>int FAR PASCAL AboutProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>             return TRUE ; <br> <br>        case WM_COMMAND : <br>            switch (wParam) { <br>                case IDOK : <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br>} <br> <br> <br>// <br>// AudioFormatProc: Audio Format Setting Dialog Box Procedure <br>// <br>int FAR PASCAL AudioFormatProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    static int                nChannels ; <br>    static WORD               wSample ; <br>    static DWORD              dwFrequency ; <br> <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>            nChannels = IDD_ChannelIDs + glpwfex-&gt;nChannels ; <br>            CheckRadioButton(hDlg, IDD_ChannelMono, IDD_ChannelStereo, nChannels) ; <br>            wSample = IDD_SampleIDs + glpwfex-&gt;wBitsPerSample / 8 ; <br>            CheckRadioButton(hDlg, IDD_Sample8Bit, IDD_Sample16Bit, wSample) ; <br>            dwFrequency = IDD_FreqIDs + glpwfex-&gt;nSamplesPerSec / 11025 ; <br>            CheckRadioButton(hDlg, IDD_Freq11kHz, IDD_Freq44kHz, (WORD)dwFrequency) ; <br>            return TRUE ; <br> <br>        case WM_COMMAND : <br>            switch (wParam) { <br>                case IDOK : <br>                    if (IsDlgButtonChecked(hDlg, IDD_ChannelMono)) <br>                        nChannels = 1 ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_ChannelStereo)) <br>                            nChannels = 2 ; <br>                        else { <br>                            MessageBeep(MB_ICONEXCLAMATION) ; <br>                            return FALSE ; <br>                        } <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_Sample8Bit)) <br>                        wSample = 8 ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_Sample16Bit)) <br>                            wSample = 16 ; <br>                        else { <br>                            MessageBeep(MB_ICONEXCLAMATION) ; <br>                            return FALSE ; <br>                        } <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_Freq11kHz)) <br>                        dwFrequency = 11025 ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_Freq22kHz)) <br>                            dwFrequency = 22050 ; <br>                        else <br>                            if (IsDlgButtonChecked(hDlg, IDD_Freq44kHz)) <br>                                dwFrequency = 44100 ; <br>                            else { <br>                                MessageBeep(MB_ICONEXCLAMATION) ; <br>                                return FALSE ; <br>                            } <br> <br>                    // All the entries verfied OK -- save them now <br>                    glpwfex-&gt;nChannels = nChannels ; <br>                    glpwfex-&gt;wBitsPerSample = wSample ; <br>                    glpwfex-&gt;nSamplesPerSec = dwFrequency ; <br>                    glpwfex-&gt;nBlockAlign =  glpwfex-&gt;nChannels * (glpwfex-&gt;wBitsPerSample / 8) ; <br>                    glpwfex-&gt;nAvgBytesPerSec = (long) glpwfex-&gt;nSamplesPerSec * <br>                                                      glpwfex-&gt;nBlockAlign ; <br>                    glpwfex-&gt;cbSize = 0 ; <br>                    glpwfex-&gt;wFormatTag = WAVE_FORMAT_PCM ; <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br>} <br> <br> <br>// <br>// GetFreeDiskSpaceInKB: Function to Measure Available Disk Space <br>// <br>static long GetFreeDiskSpaceInKB(LPTSTR pFile) <br>{ <br>    DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters; <br>    char RootName[MAX_PATH]; <br>    LPSTR ptmp;    //required arg <br> <br>    // need to find path for root directory on drive containing <br>    // this file. <br> <br>    GetFullPathName(pFile, sizeof(RootName)/sizeof(RootName[0]), RootName, &amp;ptmp); <br> <br>    // truncate this to the name of the root directory (god how tedious) <br>    if ((RootName[0] == TEXT('\\')) &amp;&amp; (RootName[1] == TEXT('\\'))) { <br> <br>        // path begins with  \\server\share\path so skip the first <br>        // three backslashes <br>        ptmp = &amp;RootName[2]; <br>        while (*ptmp &amp;&amp; (*ptmp != TEXT('\\'))) { <br>            ptmp++; <br>        } <br>        if (*ptmp) { <br>            // advance past the third backslash <br>            ptmp++; <br>        } <br>    } else { <br>        // path must be drv:\path <br>        ptmp = RootName; <br>    } <br> <br>    // find next backslash and put a null after it <br>    while (*ptmp &amp;&amp; (*ptmp != TEXT('\\'))) { <br>        ptmp++; <br>    } <br>    // found a backslash ? <br>    if (*ptmp) { <br>        // skip it and insert null <br>        ptmp++; <br>        *ptmp = TEXT('\0'); <br>    } <br> <br> <br> <br>    if (!GetDiskFreeSpace(RootName, <br>&amp;dwSectorsPerCluster, <br>&amp;dwBytesPerSector, <br>&amp;dwFreeClusters, <br>&amp;dwClusters)) { <br>    MessageBox(NULL, TEXT("Can't measure free disk space."), TEXT("Error"), <br>    MB_OK | MB_ICONINFORMATION); <br>    return (-1); <br>    } <br>    return(MulDiv (dwSectorsPerCluster * dwBytesPerSector, <br>   dwFreeClusters, <br>   1024)); <br>} <br> <br> <br> <br>// <br>// AllocCapFileProc: Capture file Space Allocation Dialog Box Procedure <br>// <br>int FAR PASCAL AllocCapFileProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    static int      nFreeMBs = 0 ; <br> <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>        { <br>            long             lFileSize = 0 ; <br>            long             lFreeSpaceInKB ; <br>            TCHAR     achCapFile[_MAX_PATH] ; <br>            HANDLE           hFile; <br> <br>            // Get current capture file name and measure its size <br>            capFileGetCaptureFile(ghWndCap, achCapFile, sizeof(achCapFile) / sizeof(TCHAR)) ; <br>            hFile = CreateFile( <br>                            achCapFile, <br>                            GENERIC_READ, <br>                            0, <br>                            NULL, <br>                            OPEN_EXISTING, <br>                            FILE_ATTRIBUTE_NORMAL, <br>                            NULL); <br>            if (hFile != INVALID_HANDLE_VALUE) { <br>                if ((lFileSize = GetFileSize(hFile, NULL)) == -1) { <br>                    MessageBox(NULL, TEXT("Couldn't find size of current capture file"), <br>                            TEXT("ERROR"), <br>                            MB_OK | MB_ICONEXCLAMATION); <br>                    lFileSize = 0; <br>                } <br>                CloseHandle(hFile); <br>            } <br> <br>            // Get free disk space and add current capture file size to that. <br>            // Convert the available space to MBs. <br>            if ((lFreeSpaceInKB = GetFreeDiskSpaceInKB(achCapFile)) != -1L) { <br>                lFreeSpaceInKB += lFileSize / 1024 ; <br>                nFreeMBs = lFreeSpaceInKB / 1024 ; <br>                SetDlgItemInt(hDlg, IDD_SetCapFileFree, nFreeMBs, TRUE) ; <br>            } else { <br> <br>                EnableWindow(GetDlgItem(hDlg, IDD_SetCapFileFree), FALSE); <br> <br>            } <br> <br>            gwCapFileSize = (WORD) (lFileSize / ONEMEG); <br> <br>            SetDlgItemInt(hDlg, IDD_SetCapFileSize, gwCapFileSize, TRUE) ; <br>            return TRUE ; <br>        } <br> <br>        case WM_COMMAND : <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK : <br>                { <br>                    int         iCapFileSize ; <br> <br>                    iCapFileSize = (int) GetDlgItemInt(hDlg, IDD_SetCapFileSize, NULL, TRUE) ; <br>                    if (iCapFileSize &lt;= 0 || iCapFileSize &gt; nFreeMBs) { <br>                        // You are asking for more than we have !! Sorry, ... <br>                        SetDlgItemInt(hDlg, IDD_SetCapFileSize, iCapFileSize, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_SetCapFileSize)) ; <br>                        MessageBeep(MB_ICONEXCLAMATION) ; <br>                        return FALSE ; <br>                    } <br>                    gwCapFileSize = iCapFileSize ; <br> <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br>                } <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br> <br>                case IDD_SetCapFileSize: <br>                { <br>                    long l; <br>                    BOOL bchanged; <br>                    char achBuffer[21]; <br> <br>                    // check that entered size is a valid number <br>                    GetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer, sizeof(achBuffer)); <br>                    l = atol(achBuffer); <br>                    bchanged = FALSE; <br>                    if (l &lt; 1) { <br>                        l = 1; <br>                        bchanged = TRUE; <br>                    } else if (l &gt; nFreeMBs) { <br>                        l = nFreeMBs; <br>                        bchanged = TRUE; <br>                    } else { <br>                        // make sure there are no non-digit chars <br>                        // atol() will ignore trailing non-digit characters <br>                        int c = 0; <br>                        while (achBuffer[c]) { <br>                            if (IsCharAlpha(achBuffer[c]) || <br>                                !IsCharAlphaNumeric(achBuffer[c])) { <br> <br>                                // string contains non-digit chars - reset <br>                                l = 1; <br>                                bchanged = TRUE; <br>                                break; <br>                            } <br>                            c++; <br>                        } <br>                    } <br>                    if (bchanged) { <br>                        wsprintf(achBuffer, "%ld", l); <br>                        SetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer); <br>                    } <br>                    break; <br>                } <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br> <br>} <br> <br>// <br>// MakePaletteProc: Palette Details Dialog Box Procedure <br>// <br>BOOL CALLBACK MakePaletteProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>            SetDlgItemInt(hDlg, IDD_MakePalColors, gwPalColors, FALSE) ; <br>            SetDlgItemInt(hDlg, IDD_MakePalFrames, gwPalFrames, FALSE) ; <br>            return TRUE ; <br> <br>        case WM_COMMAND : <br>            switch (wParam) { <br>                case IDOK : <br>                { <br>                    int         iColors ; <br>                    int         iFrames ; <br> <br>                    iColors = (int) GetDlgItemInt(hDlg, IDD_MakePalColors, NULL, TRUE) ; <br>                    if (! (iColors &gt; 0 &amp;&amp; iColors &lt;= 236 || iColors == 256)) { <br>                        // invalid number of palette colors <br>                        SetDlgItemInt(hDlg, IDD_MakePalColors, iColors, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_MakePalColors)) ; <br>                        MessageBeep(MB_ICONEXCLAMATION) ; <br>                        return FALSE ; <br>                    } <br>                    iFrames = (int) GetDlgItemInt(hDlg, IDD_MakePalFrames, NULL, TRUE) ; <br>                    if (iFrames &lt;= 0 || iFrames &gt; 10000) { <br>                        // no frame or way t-o-o many frames !!! <br>                        SetDlgItemInt(hDlg, IDD_MakePalFrames, iFrames, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_MakePalFrames)) ; <br>                        MessageBeep(MB_ICONEXCLAMATION) ; <br>                        return FALSE ; <br>                    } <br>                    gwPalColors = iColors ; <br>                    gwPalFrames = iFrames ; <br> <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br>                } <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br> <br>} <br> <br> <br>// <br>// CountMCIDevices: Function to Find the Number of MCI Devices of a Type <br>// <br>static int CountMCIDevices(WORD wType) <br>{ <br>    int               nTotal = 0 ; <br>    DWORD             dwCount ; <br>    MCI_SYSINFO_PARMS mciSIP ; <br> <br>    mciSIP.dwCallback = 0 ; <br>    mciSIP.lpstrReturn = (LPTSTR)(LPVOID) &amp;dwCount ; <br>    mciSIP.dwRetSize = sizeof(DWORD) ; <br>    mciSIP.wDeviceType = wType ; <br> <br>    // Use an MCI command to get the info <br>    if (! mciSendCommand(0, MCI_SYSINFO, MCI_SYSINFO_QUANTITY, <br>                         (DWORD)(LPVOID) &amp;mciSIP)) <br>        nTotal = (int) *((LPDWORD) mciSIP.lpstrReturn) ; <br> <br>    return nTotal ; <br>} <br> <br> <br>// <br>// CapSetUpProc: Capture SetUp Details Dialog Box Procedure <br>// <br>int FAR PASCAL CapSetUpProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    BOOL            fValue ; <br>    static TCHAR     achBuffer[21] ; <br> <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>        { <br>            WORD        wValue ; <br> <br>            // Convert from MicroSecPerFrame to FPS -- that's easier !! <br>            wValue = (int) (1E+6 / gCapParms.dwRequestMicroSecPerFrame + 0.5) ; <br>            SetDlgItemInt(hDlg, IDD_FrameRateData, wValue, FALSE) ; <br>            if (gCapParms.fAbortLeftMouse) <br>                wValue = IDD_AbortLeftFlag ; <br>            else <br>                if (gCapParms.fAbortRightMouse) <br>                    wValue = IDD_AbortRightFlag ; <br>                else <br>                    wValue = 0 ;  // none of the mouse-buttons !!! <br>            CheckRadioButton(hDlg, IDD_AbortLeftFlag, IDD_AbortRightFlag, wValue) ; <br> <br>            if (gCapParms.vKeyAbort == VK_ESCAPE) <br>                wValue = IDD_AbortEscFlag ; <br>            else <br>                if (gCapParms.vKeyAbort == VK_SPACE) <br>                    wValue = IDD_AbortSpaceFlag ; <br>                else <br>                    if (gCapParms.vKeyAbort == VK_F8) <br>                        wValue = IDD_AbortF8Flag ; <br>                    else <br>                        wValue = 0 ;  // none of the keys !!! <br>            CheckRadioButton(hDlg, IDD_AbortEscFlag, IDD_AbortF8Flag, wValue) ; <br> <br>            // If time limit isn't anabled, disable the time data part <br>            CheckDlgButton(hDlg, IDD_TimeLimitFlag, (fValue = gCapParms.fLimitEnabled)) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_SecondsText), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_SecondsData), fValue) ; <br>            if (fValue) <br>                SetDlgItemInt(hDlg, IDD_SecondsData, gCapParms.wTimeLimit, FALSE) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_CapAudioFlag), gCapStatus.fAudioHardware) ; <br>            CheckDlgButton(hDlg, IDD_CapAudioFlag, gCapParms.fCaptureAudio) ; <br>            CheckDlgButton(hDlg, IDD_UseDOSMemFlag, gCapParms.fUsingDOSMemory) ; <br>            CheckDlgButton(hDlg, IDD_CaptureOKFlag, gCapParms.fMakeUserHitOKToCapture) ; <br> <br>            // Find out how many MCI devices can source video <br>            if (CountMCIDevices(MCI_DEVTYPE_VCR) + <br>                CountMCIDevices(MCI_DEVTYPE_VIDEODISC) == 0) <br>                // if no VCRs or Videodiscs, disable the controls <br>                fValue = FALSE ; <br>            else <br>                fValue = TRUE ; <br> <br>            // If no MCI device or MCI Control not enabled, disable MCI <br>            // device name, start and stop time, step capture etc <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIControlFlag), fValue) ; <br>            CheckDlgButton(hDlg, IDD_MCIControlFlag, <br>                           (fValue &amp;= gCapParms.fMCIControl)) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIDeviceText), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIDeviceData), fValue) ; <br>            SetDlgItemText(hDlg, IDD_MCIDeviceData, (LPTSTR)gachMCIDeviceName) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIStartText), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIStartData), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIStopText), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIStopData), fValue) ; <br>            if (fValue) { <br>                wsprintf((LPTSTR)achBuffer, TEXT("%lu"), gCapParms.dwMCIStartTime) ; <br>                SetDlgItemText(hDlg, IDD_MCIStartData, (LPTSTR)achBuffer) ; <br>                wsprintf((LPTSTR)achBuffer, TEXT("%lu"), gCapParms.dwMCIStopTime) ; <br>                SetDlgItemText(hDlg, IDD_MCIStopData, (LPTSTR)achBuffer) ; <br>            } <br>            EnableWindow(GetDlgItem(hDlg, IDD_MCIStepCapFlag), fValue) ; <br>            CheckDlgButton(hDlg, IDD_MCIStepCapFlag, gCapParms.fStepMCIDevice) ; <br>            SetDlgItemInt(hDlg, IDD_MaxDropData, gCapParms.wPercentDropForError, FALSE) ; <br>            SetDlgItemInt(hDlg, IDD_VideoBuffData, gCapParms.wNumVideoRequested, FALSE) ; <br> <br>            return TRUE ; <br>        } <br> <br>        case WM_COMMAND : <br>            switch (wParam) { <br>                case IDD_TimeLimitFlag : <br>                    // If this flag changes, en/dis-able time limit data part <br>                    fValue = IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsText), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsData), fValue) ; <br>                    return TRUE ; <br> <br>                case IDD_MCIControlFlag : <br>                    // If this flag changes, en/dis-able MCI times data part <br>                    fValue = IsDlgButtonChecked(hDlg, IDD_MCIControlFlag) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIDeviceText), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIDeviceData), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIStartText), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIStartData), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIStopText), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIStopData), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCIStepCapFlag), fValue) ; <br>                    CheckDlgButton(hDlg, IDD_MCIStepCapFlag, <br>                            gCapParms.fStepMCIDevice | <br>                            IsDlgButtonChecked(hDlg, IDD_MCIStepCapFlag)) ; <br>                    return TRUE ; <br> <br>                case IDOK : <br>                { <br>                    int         iFrameRate ; <br>                    int         iTimeLimit ; <br>                    int         iMaxDropRate ; <br>                    int         iVideoBuffers ; <br>                    long        lMCIStart ; <br>                    long        lMCIStop ; <br> <br>                    if ((iFrameRate = (int) GetDlgItemInt(hDlg, IDD_FrameRateData, NULL, <br>                                      TRUE)) &lt;= 0 || iFrameRate &gt;= 100) { <br>                        // No frame at all or more than 100 FPS !! <br>                        SetDlgItemInt(hDlg, IDD_FrameRateData, iFrameRate, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_FrameRateData)) ; <br>                        MessageBeep(MB_ICONQUESTION) ; <br>                        return FALSE ; <br>                    } <br>                    if (IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag)) { <br>                        if ((iTimeLimit = (int) GetDlgItemInt(hDlg, IDD_SecondsData, NULL, <br>                                          TRUE)) &lt;= 0 || iTimeLimit &gt; 3600) { <br>                            // No capture or more than 1 hour !! <br>                            SetDlgItemInt(hDlg, IDD_SecondsData, iTimeLimit, TRUE) ; <br>                            SetFocus(GetDlgItem(hDlg, IDD_SecondsData)) ; <br>                            MessageBeep(MB_ICONQUESTION) ; <br>                            return FALSE ; <br>                        } <br>                    } <br>                    if (IsDlgButtonChecked(hDlg, IDD_MCIControlFlag)) { <br>                        GetDlgItemText(hDlg, IDD_MCIStartData, (LPTSTR)achBuffer, 20) ; <br>#ifdef UNICODE <br>                        lMCIStart = wcstol(achBuffer, NULL, 10); <br>#else <br>                        lMCIStart = atol(achBuffer) ; <br>#endif <br>                        if (lMCIStart &lt; 0 ||             // negative time !!! <br>                            lMCIStart &gt;= 2000000000L) {  // or too high !!! <br>                            SetDlgItemText(hDlg, IDD_MCIStartData, achBuffer) ; <br>                            SetFocus(GetDlgItem(hDlg, IDD_MCIStartData)) ; <br>                            MessageBeep(MB_ICONQUESTION) ; <br>                            return FALSE ; <br>                        } <br>                        GetDlgItemText(hDlg, IDD_MCIStopData, (LPTSTR)achBuffer, 20) ; <br>#ifdef UNICODE <br>                        lMCIStop = wcstol(achBuffer, NULL, 10); <br>#else <br>                        lMCIStop = atol(achBuffer) ; <br>#endif <br>                        if (lMCIStop &lt; 0 ||            // negative time !!! <br>                            lMCIStop &gt;= 2000000000L || // or too high !!! <br>                            lMCIStop &lt; lMCIStart) {    // or Stop before Start !!! <br>                            SetDlgItemText(hDlg, IDD_MCIStopData, achBuffer) ; <br>                            SetFocus(GetDlgItem(hDlg, IDD_MCIStopData)) ; <br>                            MessageBeep(MB_ICONQUESTION) ; <br>                            return FALSE ; <br>                        } <br>                    } <br>                    if ((iMaxDropRate = (int) GetDlgItemInt(hDlg, IDD_MaxDropData, NULL, <br>                                            TRUE)) &lt; 0 || iMaxDropRate &gt;= 100) { <br>                        // Negative drop limit or more than 100% !! <br>                        SetDlgItemInt(hDlg, IDD_MaxDropData, iMaxDropRate, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_MaxDropData)) ; <br>                        MessageBeep(0) ; <br>                        return FALSE ; <br>                    } <br>                    if ((iVideoBuffers = (int) GetDlgItemInt(hDlg, IDD_VideoBuffData, NULL, <br>                                             TRUE)) &lt;= 0 || iVideoBuffers &gt;= 32767) { <br>                        // Can't capture with too many or without video buffers <br>                        SetDlgItemInt(hDlg, IDD_VideoBuffData, iVideoBuffers, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_VideoBuffData)) ; <br>                        MessageBeep(MB_ICONQUESTION) ; <br>                        return FALSE ; <br>                    } <br> <br>                    // All the Cap params are correct. So set them now... <br>                    gCapParms.dwRequestMicroSecPerFrame = (DWORD)(1E+6 / iFrameRate + 0.5) ; <br>                    gCapParms.fLimitEnabled = IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag) ; <br>                    gCapParms.wTimeLimit = iTimeLimit ; <br>                    if (gCapParms.fMCIControl = <br>                            IsDlgButtonChecked(hDlg, IDD_MCIControlFlag)) { <br>                        gCapParms.dwMCIStartTime = lMCIStart ; <br>                        gCapParms.dwMCIStopTime  = lMCIStop ; <br>                        GetDlgItemText(hDlg, IDD_MCIDeviceData, (LPTSTR)achBuffer, 20) ; <br>                        lstrcpy(gachMCIDeviceName, achBuffer) ; <br>                        capSetMCIDeviceName(ghWndCap, gachMCIDeviceName) ; <br>                        gCapParms.fStepMCIDevice = IsDlgButtonChecked(hDlg, IDD_MCIStepCapFlag) ; <br>                    } <br>                    else { <br>                        gCapParms.dwMCIStartTime = gCapParms.dwMCIStopTime = 0 ; <br>                        gCapParms.fStepMCIDevice = FALSE ; <br>                    } <br>                    gCapParms.wPercentDropForError = iMaxDropRate ; <br>                    gCapParms.wNumVideoRequested = iVideoBuffers ; <br>                    gCapParms.fAbortLeftMouse = IsDlgButtonChecked(hDlg, IDD_AbortLeftFlag) ; <br>                    gCapParms.fAbortRightMouse = IsDlgButtonChecked(hDlg, IDD_AbortRightFlag) ; <br>                    if (IsDlgButtonChecked(hDlg, IDD_AbortEscFlag)) <br>                        gCapParms.vKeyAbort = VK_ESCAPE ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_AbortSpaceFlag)) <br>                            gCapParms.vKeyAbort = VK_SPACE ; <br>                        else <br>                            if (IsDlgButtonChecked(hDlg, IDD_AbortF8Flag)) <br>                                gCapParms.vKeyAbort = VK_F8 ; <br>                            else <br>                                gCapParms.vKeyAbort = 0 ; <br>                    gCapParms.fCaptureAudio = <br>                                IsDlgButtonChecked(hDlg, IDD_CapAudioFlag) ; <br>                    gCapParms.fUsingDOSMemory = <br>                                IsDlgButtonChecked(hDlg, IDD_UseDOSMemFlag) ; <br>                    gCapParms.fMakeUserHitOKToCapture = <br>                                IsDlgButtonChecked(hDlg, IDD_CaptureOKFlag) ; <br> <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br>                } <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
