<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLBAR.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3828"></a>TOOLBAR.H</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   toolbar.h: Toolbar include file <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br> <br>/***************************************************************************** <br>*                                                                            * <br>*  Program Description: Implements a generic toolbar.              * <br>*                                                                            * <br>*  Here's how to use it:                                                     * <br>*                                                                            * <br>*            Include the source files "toolbar.h" and "toolbar.c" in your    * <br>*  application.                                                              * <br>*                                                                            * <br>*            Include a line in your application's RC file that gives a file  * <br>*  name with a resource id eg. IDBMP_BUTTONS.  This is a .BMP file that      * <br>*  contains all of the pictures of the buttons you want on your toolbar.     * <br>*  Also, make a define for your label with a unique value.  If your app has  * <br>*  more than one toolbar, and all toolbars don't share a bitmap file, then   * <br>*  you will need several defines.                                            * <br>*                                                                            * <br>*  e.g.IDBMP_BUTTONS     BITMAP     "buttons.bmp"                   * <br>*      IDBMP_ARROWS      BITMAP     "arrows.bmp"                    * <br>*                                                                            * <br>*            This file must have the different buttons across horizontally   * <br>*  and the different states for these buttons vertically.  Change the        * <br>*  defines in this header file to match the button names and state names of  * <br>*  your buttons.  You must include the states listed here, and actually      * <br>*  you probably won't need to change them at all.  The numbers for a button  * <br>*  or state are indexes into the bitmap, so the pictures must match.         * <br>*                                                                            * <br>*  STATE DESCRIPTIONS:                                                       * <br>*                       GRAYED:  The button cannot be pressed &amp; is inactive  * <br>*                           UP:  The button is up                            * <br>*                         DOWN:  The button is down                          * <br>*                      FOCUSUP:  The button is up and is the one with focus  * <br>*                    FOCUSDOWN:  The button is down and is the one with focus* <br>*                     FULLDOWN:  A checkbox button has this additional state * <br>*                                where it is all the way down when pressed   * <br>*                                and when it is let go, it will go into      * <br>*                                either the UP or DOWN state (maybe focused) * <br>*                                                                            * <br>*  When you draw the pictures, make sure to get the right state in the right * <br>*  vertical position in the bitmap to match the #define's.                   * <br>*                                                                            * <br>*  A button can also have a type associated with it:                         * <br>*                                                                            * <br>*                 PUSH:  When pressed it goes down, when let go it bounces   * <br>*                        up.  Therefore, when you aren't currently holding   * <br>*                        the mouse button or space bar on it, it will        * <br>*                        ALWAYS be in the up position. It can be in any      * <br>*                        state except FULLDOWN, which is invalid.            * <br>*                                                                            * <br>*             CHECKBOX:  This button can be up or down.  When pushed, it     * <br>*                        toggles into the opposite state.  However, it       * <br>*                        is always in the FULLDOWN state when being held     * <br>*                        down with the mouse button or space bar, and when   * <br>*                        let go, it will go into the opposite state of what  * <br>*                        it was in before you pressed it.  E.G.  The button  * <br>*                        is up.  You press it, and it goes way down. You let * <br>*                        go, and it comes up a bit, but it's still down.  You* <br>*                        press it again, and it goes further down before     * <br>*                        popping all the way up.                             * <br>*                                                                            * <br>*                RADIO:  This is a group of buttons that can be up or down,  * <br>*                        and also have the intermediate step of being        * <br>*                        FULLDOWN when being held down.  But, when you       * <br>*                        push one of the radio buttons down, all other radio * <br>*                        buttons in its group will pop up.  Any group can    * <br>*                        have only 1 down at a time, and 1 must be down.     * <br>*                                                                            * <br>*                CUSTOM: If your application is wierd, you can have a custom * <br>*                        type button that does anything you want it to.      * <br>*                                                                            * <br>*  First, your app must call:    toolbarInit(hInst, hPrev);                  * <br>*  with the two instance parameters to register a toolbar window class.      * <br>*  Then your app is free to call CreateWindow with a class of                * <br>*  szToolBarClass   to create one or more toolbar windows anywhere it wants  * <br>*  and of any size it wants, presumably as the child window of another of the* <br>*  app's windows.  The file that creates the window must declare an          * <br>*  extern char szToolBarClass[];   All messages about activity to a toolbar  * <br>*  button will go to the parent window of the toolbar.                       * <br>*                                                                            * <br>*  Next, call:     toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp,       * <br>* POINT ptSize);      * <br>*  Pass it the resource ID (eg. IDBMP_BUTTONS) to tell the toolbar where to  * <br>*  find the pictures for the buttons.  Also pass a point with the width and  * <br>*  height of each button (eg. 24 X 22) so it knows how to find individual    * <br>*  buttons in the bitmap file.                                               * <br>*                                                                            * <br>*  Next, call:     toolbarAddTool(HWND hwnd, TOOLBUTTON tb);                 * <br>*  as many times as you want to add a button to the toolbar specified by     * <br>*  hwnd.  You fill in the "tb" struct with the following information:        * <br>*                                                                            * <br>*       tb.rc        = the rect in the toolbar window to place the button    * <br>*                      based at 0,0 and measured in pixels.                  * <br>*       tb.iButton   = the ID of the button you wish the add (which is       * <br>*                      the horizontal offset into the bitmap of buttons).    * <br>*                      Only one of each button allowed.  Use one of the      * <br>*                      defines (BTN_??????).                                 * <br>*       tb.iState    = the initial state of the button (GRAYED, UP, DOWN).   * <br>*                      If you wish, you can specify a FOCUS'ed state to give * <br>*                      any button you wish the focus.  By default, it's the  * <br>*                      one furthest left and tabbing order goes to the right.* <br>*                      This is the vertical offset into the bitmap.          * <br>*                      Use one of the defines (BTNST_?????).                 * <br>*       tb.iType     = The type of button (BTNTYPE_???).  Either pushbutton, * <br>*                      checkbox, or radio button. (or custom).  If it is a   * <br>*                      radio button, you can have many groups of radio btn's * <br>*                      on the same toolbar.  Type BTNTYPE_RADIO is one group.* <br>*                      Use BTNTYPE_RADIO+1 for another group, BTNTYPE_RADIO+2* <br>*                      for a third group, etc.  You have thousands.          * <br>*       tb.iString   = The resource ID of a string to be associated with     * <br>*                      this button (if you'd like).                          * <br>*                                                                            * <br>*                                                                            * <br>*   At any time in the app, you can call toolbarAddTool to add more buttons  * <br>*   or toolbarRemoveTool to take some away.  To take one away, identify it   * <br>*   with it's button ID (horizontal offset in the bitmap).                   * <br>*                                                                            * <br>*   You can also call toolbarRetrieveTool to get the TOOLBUTTON struct back  * <br>*   from a button that is on the toolbar.  This is the way to change a       * <br>*   button's position.  Change the tb.rc and then Remove and Add the button  * <br>*   again so that the tabbing order will be re-calculated based on the new   * <br>*   rect of the tool.                                                        * <br>*                                                                            * <br>*   Now, all buttons will automatically behave properly.  They'll go up and  * <br>*   down as you press on them, or use the keyboard, groups of radio buttons  * <br>*   will pop up as you press a different one down, etc. etc. etc.            * <br>*   You don't have to do a thing!                                            * <br>*                                                                            * <br>*   The parent of the toolbar window will get a WM_COMMAND message with      * <br>*   a wParam of IDC_TOOLBAR  whenever anything happens to a button.          * <br>*   The LOWORD of the lParam is the hwnd of the toolbar window that has the  * <br>*   button on it.  The (HIWORD &amp; 0xFF) is the button ID of the button.       * <br>*   Remember to change IDC_TOOLBAR to something unique.                      * <br>*                                                                            * <br>*   The app can then call   toolbarIndexFromButton(hwnd, buttonID)           * <br>*   to get the index of the button (used for subsequent calls).              * <br>*                                                                            * <br>*   Then call:      toolbarStateFromButton(hwnd, buttonID)                   * <br>*                                                                            * <br>*                   to get either BTNST_UP or BTNST_DOWN.  This is the       * <br>*                   NEW state of the button since the activity on the        * <br>*                   button.  It can also be BTNST_GRAYED, but you won't get  * <br>*                   any activity messages while it's grayed, unless it is a  * <br>*                   cutsom button.                                           * <br>*                                                                            * <br>*             Call  toolbarFullStateFromButton(hwnd, buttonID)               * <br>*                                                                            * <br>*                   to get more detail about the state.  It can also return  * <br>*                   BTNST_FULLDOWN as well as the above states. In the case  * <br>*                   of BTNST_FULLDOWN, you'll have to call                   * <br>*                   toolbarPrevStateFromButton(hwnd, btn ID) to get the state* <br>*                   before it went full down.                                * <br>*                                                                            * <br>*                   toolbarPrevStateFromButton(hwnd, buttonID)               * <br>*                                                                            * <br>*                   is only valid when the state is BTNST_FULLDOWN.          * <br>*                                                                            * <br>*                   toolbarActivityFromIndex(hwnd, buttonID)                 * <br>*                                                                            * <br>*                   tells you what just happened to the button.              * <br>*                   BTNACT_KEYDOWN, BTNACT_MOUSEUP, etc. are possibilities.  * <br>*                   BTNACT_MOUSEMOUSEOFF means that they pressed it down and * <br>*                   moved the mouse off of the button (  so it was re- drawn * <br>*                   in its previous state before being pressed).             * <br>*                   BTNACT_MOUSEMOUSEON  means that the above happened and   * <br>*                   then the mouse moved back on top of the button again, so * <br>*                   the button was re-drawn as if it was pushed again.       * <br>*                                                                            * <br>*                   For any of the above activities.......                   * <br>*                                                                            * <br>*   HIWORD &amp; BTN_SHIFT     is set if this activity involves the right mouse  * <br>*                          button, or else it is clear.                      * <br>*   HIWORD &amp; BTN_DBLCLICK  is set means that this mouse button down activity * <br>*                          is really a double click (if you care).           * <br>*                                                                            * <br>*           If you are a custom button, you can also receive this message... * <br>*                                                                            * <br>*   HIWORD &amp; BTN_REPEAT    is set means that the button or key is being held * <br>*                          down, and you are being sent many down messages   * <br>*                          in a row.  The first such message is sent with    * <br>*                          this flag clear, all others have this flag set.   * <br>*                          If you are a custom button, you will have to      * <br>*                          ignore messages that are repeats if you don't     * <br>*                          want to get many down messages in a row.          * <br>*                                                                            * <br>*                                                                            * <br>*                    toolbarStringFromIndex(hwnd, index)                     * <br>*                                                                            * <br>*                    will return you the string resource ID you gave when    * <br>*                    you registered this button.                             * <br>*                                                                            * <br>*                                                                            * <br>*  IMPORTANT !!!!!!!!!!!!!!!!!!!                                             * <br>*  =============================                                             * <br>*                                                                            * <br>*  When you get the state of a button, it's already been changed by the      * <br>*  activity so it's the NEW STATE!!!!!!!!!                                   * <br>*                                                                            * <br>*   EXCEPT!!!   for a custom button!  For a custom button, NOTHING WILL      * <br>*   happen, you have to do it all yourself!!!! So the state is going to be   * <br>*   the state BEFORE the activity and you have to call                       * <br>*   toolbarModifyState(hwnd, buttonID, newState) to change the state         * <br>*   yourself!!!!                                                             * <br>*                                                                            * <br>*   You also have toolbarGetNumButtons(hwnd) to tell you how many are on the * <br>*   the toolbar.                                                             * <br>*   And... you have other routines you can use if you really want.           * <br>*                                                                            * <br>*   ENJOY!!                                                                  * <br>*                                                                            * <br>*  P.S.  Don't forget to pass on WM_SYSCOLORCHANGE msgs to each toolbar.     * <br>*                                                                            * <br>*****************************************************************************/ <br> <br>#define TOOLGROW8// power of 2 <br> <br>#define IDC_TOOLBAR189// wParam sent to Parent <br> <br>/* We keep an array of these around (one for each button on the toolbar) */ <br> <br>typedef struct { <br>RECTrc;// draw it at this postion in the toolbar <br>intiButton;// it's this button <br>intiState;// in this state <br>intiPrevState;// for non-push buttons - last state <br>intiType;// type of button <br>intiActivity;// what just happened to button <br>intiString;// string resource associated with button <br>} TOOLBUTTON, FAR *LPTOOLBUTTON; <br> <br>BOOL FAR PASCAL toolbarInit(HANDLE hInst, HANDLE hPrev); <br>BOOL FAR PASCAL toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp, <br>POINT ptSize); <br>BOOL FAR PASCAL toolbarAddTool(HWND hwnd, TOOLBUTTON tb); <br>BOOL FAR PASCAL toolbarRetrieveTool(HWND hwnd, int iButton, LPTOOLBUTTON tb); <br>BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton); <br>int FAR PASCAL toolbarGetNumButtons(HWND hwnd); <br>int FAR PASCAL toolbarButtonFromIndex(HWND hwnd, int iBtnPos); <br>int FAR PASCAL toolbarIndexFromButton(HWND hwnd, int iButton); <br>int FAR PASCAL toolbarPrevStateFromButton(HWND hwnd, int iButton); <br>int FAR PASCAL toolbarActivityFromButton(HWND hwnd, int iButton); <br>int FAR PASCAL toolbarIndexFromPoint(HWND hwnd, POINT pt); <br>BOOL FAR PASCAL toolbarRectFromIndex(HWND hwnd, int iBtnPos, LPRECT lprc); <br>int FAR PASCAL toolbarStringFromIndex(HWND hwnd, int iBtnPos); <br>int FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton); <br>int FAR PASCAL toolbarFullStateFromButton(HWND hwnd, int iButton); <br>int FAR PASCAL toolbarTypeFromIndex(HWND hwnd, int iBtnPos); <br>BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int iState); <br>BOOL FAR PASCAL toolbarModifyString(HWND hwnd, int iButton, int iString); <br>BOOL FAR PASCAL toolbarModifyPrevState(HWND hwnd, int iButton, int iPrevState); <br>BOOL FAR PASCAL toolbarModifyActivity(HWND hwnd, int iButton, int iActivity); <br>BOOL FAR PASCAL toolbarExclusiveRadio(HWND hwnd, int iType, int iButton); <br>BOOL FAR PASCAL toolbarMoveFocus(HWND hwnd, BOOL fBackward); <br>BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton); <br>HBITMAP FAR PASCAL  LoadUIBitmap( <br>    HANDLE      hInstance,          // EXE file to load resource from <br>    LPCSTR      szName,             // name of bitmap resource <br>    COLORREF    rgbText,            // color to use for "Button Text" <br>    COLORREF    rgbFace,            // color to use for "Button Face" <br>    COLORREF    rgbShadow,          // color to use for "Button Shadow" <br>    COLORREF    rgbHighlight,       // color to use for "Button Hilight" <br>    COLORREF    rgbWindow,          // color to use for "Window Color" <br>    COLORREF    rgbFrame);          // color to use for "Window Frame" <br> <br> <br>/* In a bitmap file, each button is the same size, and contains <br> * the picture of a button.  Each column contains the picture of a distinct <br> * button (e.g. BTN_REWIND, BTN_REVERSE, etc.) and each row contains <br> * a specific button state (BTNST_UP, BTNST_DOWN, <br> * BTNBAR_GRAYED, etc. just as an example). <br> * <br> */ <br> <br>#define TB_FIRST-1 <br>#define TB_LAST-2 <br> <br> <br> <br>#define BTNST_GRAYED0// <br>#define BTNST_UP1// <br>#define BTNST_DOWN2// <br>#define BTNST_FOCUSUP3// <br>#define BTNST_FOCUSDOWN4// <br>#define BTNST_FULLDOWN5// <br> <br>#define BTN_REPEAT0x100// add this to button index <br>#define BTN_SHIFT0x200 <br>#define BTN_DBLCLICK0x400 <br> <br> <br>/* Types of buttons */ <br> <br>#define BTNTYPE_PUSH0 <br>#define BTNTYPE_CHECKBOX1 <br>#define BTNTYPE_CUSTOM2 <br>#define BTNTYPE_RADIO3// MUST BE LAST to reserve room for more <br>// radio groups.  (3 == one group, <br>// 4 == another group, etc.) <br> <br> <br>/* tells parent recent activity on button */ <br>#define BTNACT_MOUSEDOWN0// clicked mouse button down on tool <br>#define BTNACT_MOUSEUP1// let go of mouse button while on tool <br>#define BTNACT_MOUSEMOVEOFF2// moved mouse off tool while btn down <br>#define BTNACT_MOUSEMOVEON3// moved back on tool (btn still down) <br>#define BTNACT_MOUSEDBLCLK4// dbl clicked on tool <br>#define BTNACT_KEYDOWN5// key down on tool <br>#define BTNACT_KEYUP6// key up from tool <br> <br> <br>/* constants */ <br>#define MSEC_BUTTONREPEAT200// milliseconds for auto-repeat <br> <br>/* timers */ <br>#define TIMER_BUTTONREPEAT1// timer for button auto-repeat <br> <br> <br> <br> <br> <br>// Window words for Toolbar <br>#ifdef _WIN32 <br>#define GWL_ARRAYBUTT0/* Pointer to array of buttons  */ <br>#define GWL_NUMBUTTONS4/* Number of buttons in array   */ <br>#define GWL_PRESSED8/* Is a button currently pressed*/ <br>#define GWL_KEYPRESSED12      /* Is a key currently pressed?  */ <br>#define GWL_WHICH16          /* Which button has the focus?  */ <br>#define GWL_SHIFTED20/* Is it rt-click or shift-left?*/ <br>#define GWL_BMPHANDLE24/* handle to bmp of the buttons */ <br>#define GWL_BMPINT28/* resource int of button bmp*/ <br>#define GWL_BUTTONSIZE32/* a point (x=hi y=lo)*/ <br>#define GWL_HINST36/* hinst of the app   */ <br>#define TOOLBAR_EXTRABYTES40 <br>#else <br>#define GWW_ARRAYBUTT0/* Pointer to array of buttons  */ <br>#define GWW_NUMBUTTONS2/* Number of buttons in array   */ <br>#define GWW_PRESSED4/* Is a button currently pressed*/ <br>#define GWW_KEYPRESSED6/* Is a key currently pressed?  */ <br>#define GWW_WHICH8/* Which button has the focus?  */ <br>#define GWW_SHIFTED10/* Is it rt-click or shift-left?*/ <br>#define GWW_BMPHANDLE12/* handle to bmp of the buttons */ <br>#define GWW_BMPINT14/* resource int of button bmp*/ <br>#define GWL_BUTTONSIZE16/* a point (x=hi y=lo)*/ <br>#define GWW_HINST20/* hinst of the app   */ <br>#define TOOLBAR_EXTRABYTES22 <br>#endif <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
