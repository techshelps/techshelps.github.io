<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ARROW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3822"></a>ARROW.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   arrow.c: Arrow control window <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include &lt;stdlib.h&gt; <br> <br>#include "arrow.h" <br> <br> <br>// a few porting macros <br>#ifdef _WIN32 <br>#define SENDSCROLL(hwnd, msg, a, b, h)           \ <br>        SendMessage(hwnd, msg, (UINT)MAKELONG(a,b), (LONG)(h)) <br> <br>#define EXPORT <br> <br>#else <br>#define SENDSCROLL(hwnd, msg, a, b, h) <br>        SendMessage(hwnd, msg, a, MAKELONG(b,h))   // handle is in HIWORD <br> <br>#endif <br> <br> <br>#ifndef LONG2POINT <br>    #define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l)) <br>#endif <br>#define GWID(hwnd)      (GetDlgCtrlID(hwnd)) <br> <br> <br>#define SHIFT_TO_DOUBLE 1 <br>#define DOUBLECLICK     0 <br>#define POINTSPERARROW  3 <br>#define ARROWXAXIS      15 <br>#define ARROWYAXIS      15 <br> <br>POINT ArrowUp[POINTSPERARROW] = {7,1, 3,5, 11,5}; <br>POINT ArrowDown[POINTSPERARROW] = {7,13, 3,9, 11,9}; <br> <br>static    BOOL      bRight; <br>static    RECT      rUp, rDown; <br>static    LPRECT    lpUpDown; <br>static    FARPROC   lpArrowProc; <br>static    HANDLE    hParent; <br>BOOL      fInTimer; <br> <br> <br>#define TEMP_BUFF_SIZE    32 <br> <br>#define SCROLLMSG(hwndTo, msg, code, hwndId)                                     \ <br>                          SENDSCROLL(hwndTo, msg, code, GWID(hwndId), hwndId) <br> <br>/* <br> * @doc EXTERNAL WINCOM <br> * <br> * @api LONG | ArrowEditChange | This function is helps process the WM_VSCROLL <br> * message when using the Arrow controlled edit box. <br> * It will increment/decrement the value in the given edit box and return <br> * the new value.  Increment/decrement bounds are checked and Beep 0 is produced if <br> * the user attempts to go beyond the bounds. <br> * <br> * @parm        HWND | hwndEdit | Specifies a handle to the edit box window. <br> * <br> * @parm        UINT | wParam | Specifies the &lt;p wParam&gt; passed to the WM_VSCROLL message. <br> * <br> * @parm        LONG | lMin | Specifies the minimum value bound for decrements. <br> * <br> * @parm        LONG | lMax | Specifies the maximum value bound for increments. <br> * <br> * @rdesc       Returns the updated value of the edit box. <br> * <br> */ <br>LONG FAR PASCAL ArrowEditChange( HWND hwndEdit, UINT wParam, <br>                                 LONG lMin, LONG lMax ) <br>{ <br>    char achTemp[TEMP_BUFF_SIZE]; <br>    LONG l; <br> <br>    GetWindowText( hwndEdit, achTemp, TEMP_BUFF_SIZE ); <br>    l = atol(achTemp); <br>    if( wParam == SB_LINEUP ) { <br>        /* size kluge for now */ <br>        if( l &lt; lMax ) { <br>            l++; <br>            wsprintf( achTemp, "%ld", l ); <br>            SetWindowText( hwndEdit, achTemp ); <br>        } else { <br>        MessageBeep( 0 ); <br>        } <br>    } else if( wParam == SB_LINEDOWN ) { <br>        if( l &gt; lMin ) { <br>            l--; <br>            wsprintf( achTemp, "%ld", l ); <br>            SetWindowText( hwndEdit, achTemp ); <br>        } else { <br>            MessageBeep( 0 ); <br>        } <br>    } <br>    return( l ); <br> <br>} <br> <br> <br> <br>UINT NEAR PASCAL UpOrDown() <br>{ <br>    LONG pos; <br>    UINT retval; <br>    POINT pt; <br> <br>    pos = GetMessagePos(); <br>    LONG2POINT(pos,pt); <br>    if (PtInRect((LPRECT)&amp;rUp, pt)) <br>        retval = SB_LINEUP; <br>    else if (PtInRect((LPRECT)&amp;rDown, pt)) <br>        retval = SB_LINEDOWN; <br>    else <br>        retval = (UINT)(-1);      /* -1, because SB_LINEUP == 0 */ <br> <br>    return(retval); <br>} <br> <br> <br> <br>UINT FAR PASCAL ArrowTimerProc(hWnd, wMsg, nID, dwTime) <br>HANDLE hWnd; <br>UINT wMsg; <br>short nID; <br>DWORD dwTime; <br>{ <br>    UINT wScroll; <br> <br>    if ((wScroll = UpOrDown()) != -1) <br>    { <br>        if (bRight == WM_RBUTTONDOWN) <br>            wScroll += SB_PAGEUP - SB_LINEUP; <br>        SCROLLMSG( hParent, WM_VSCROLL, wScroll, hWnd); <br>    } <br>/* Don't need to call KillTimer(), because SetTimer will reset the right one */ <br>    SetTimer(hWnd, nID, 50, (TIMERPROC)lpArrowProc); <br>    return(0); <br>} <br> <br> <br>void InvertArrow(HANDLE hArrow, UINT wScroll) <br>{ <br>    HDC hDC; <br> <br>    lpUpDown = (wScroll == SB_LINEUP) ? &amp;rUp : &amp;rDown; <br>    hDC = GetDC(hArrow); <br>    ScreenToClient(hArrow, (LPPOINT)&amp;(lpUpDown-&gt;left)); <br>    ScreenToClient(hArrow, (LPPOINT)&amp;(lpUpDown-&gt;right)); <br>    InvertRect(hDC, lpUpDown); <br>    ClientToScreen(hArrow, (LPPOINT)&amp;(lpUpDown-&gt;left)); <br>    ClientToScreen(hArrow, (LPPOINT)&amp;(lpUpDown-&gt;right)); <br>    ReleaseDC(hArrow, hDC); <br>    ValidateRect(hArrow, lpUpDown); <br>    return; <br>} <br> <br> <br>LONG FAR PASCAL EXPORT ArrowControlProc(HWND hArrow, unsigned message, <br>                                         WPARAM wParam, LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    RECT        rArrow; <br>    HBRUSH      hbr; <br>    short       fUpDownOut; <br>    UINT        wScroll; <br> <br>    switch (message) { <br>/* <br>        case WM_CREATE: <br>            break; <br> <br>        case WM_DESTROY: <br>            break; <br>*/ <br> <br>        case WM_MOUSEMOVE: <br>            if (!bRight)  /* If not captured, don't worry about it */ <br>                break; <br> <br>            if (lpUpDown == &amp;rUp) <br>                fUpDownOut = SB_LINEUP; <br>            else if (lpUpDown == &amp;rDown) <br>                fUpDownOut = SB_LINEDOWN; <br>            else <br>                fUpDownOut = -1; <br> <br>            switch (wScroll = UpOrDown()) { <br>                case SB_LINEUP: <br>                    if (fUpDownOut == SB_LINEDOWN) <br>                        InvertArrow(hArrow, SB_LINEDOWN); <br> <br>                    if (fUpDownOut != SB_LINEUP) <br>                        InvertArrow(hArrow, wScroll); <br> <br>                    break; <br> <br>                case SB_LINEDOWN: <br>                    if (fUpDownOut == SB_LINEUP) <br>                        InvertArrow(hArrow, SB_LINEUP); <br> <br>                    if (fUpDownOut != SB_LINEDOWN) <br>                        InvertArrow(hArrow, wScroll); <br> <br>                    break; <br> <br>                default: <br>                    if (lpUpDown) { <br>                        InvertArrow(hArrow, fUpDownOut); <br>                        lpUpDown = 0; <br>                    } <br>                } <br> <br>                break; <br> <br>        case WM_RBUTTONDOWN: <br>        case WM_LBUTTONDOWN: <br>            if (bRight) <br>                break; <br> <br>            bRight = message; <br>            SetCapture(hArrow); <br>            hParent = GetParent(hArrow); <br>            GetWindowRect(hArrow, (LPRECT) &amp;rUp); <br>            CopyRect((LPRECT)&amp;rDown, (LPRECT) &amp;rUp); <br>            rUp.bottom = (rUp.top + rUp.bottom) / 2; <br>            rDown.top = rUp.bottom + 1; <br>            wScroll = UpOrDown(); <br>            InvertArrow(hArrow, wScroll); <br>#if SHIFT_TO_DOUBLE <br>            if (wParam &amp; MK_SHIFT) { <br>                if (message != WM_RBUTTONDOWN) <br>                    goto ShiftLClick; <br>                else <br>                    goto ShiftRClick; <br>            } <br>#endif <br>            if (message == WM_RBUTTONDOWN) <br>                wScroll += SB_PAGEUP - SB_LINEUP; <br> <br>            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow); <br> <br>            lpArrowProc = MakeProcInstance((FARPROC) ArrowTimerProc,ghInst); <br>            SetTimer(hArrow, GWID(hArrow), 200, (TIMERPROC)lpArrowProc); <br> <br>            break; <br> <br>        case WM_LBUTTONUP: <br>        case WM_RBUTTONUP: <br>            if ((bRight - WM_LBUTTONDOWN + WM_LBUTTONUP) == (int)message) { <br>                bRight = 0; <br>                ReleaseCapture(); <br>                if (lpUpDown) <br>                    InvertArrow(hArrow,(UINT)(lpUpDown==&amp;rUp)? <br>                                                        SB_LINEUP:SB_LINEDOWN); <br>                if (lpArrowProc) { <br>                    SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow); <br>                    KillTimer(hArrow, GWID(hArrow)); <br> <br>                    FreeProcInstance(lpArrowProc); <br>                    ReleaseCapture(); <br>                    lpArrowProc = 0; <br>                } <br>            } <br>            break; <br> <br>        case WM_LBUTTONDBLCLK: <br>ShiftLClick: <br>            wScroll = UpOrDown() + SB_TOP - SB_LINEUP; <br>            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow); <br>            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow); <br> <br>            break; <br> <br>        case WM_RBUTTONDBLCLK: <br>ShiftRClick: <br>            wScroll = UpOrDown() + SB_THUMBPOSITION - SB_LINEUP; <br>            SCROLLMSG(hParent, WM_VSCROLL, wScroll, hArrow); <br>            SCROLLMSG(hParent, WM_VSCROLL, SB_ENDSCROLL, hArrow); <br>/* <br>            hDC = GetDC(hArrow); <br>            InvertRect(hDC, (LPRECT) &amp;rArrow); <br>            ReleaseDC(hArrow, hDC); <br>            ValidateRect(hArrow, (LPRECT) &amp;rArrow); <br>*/ <br>            break; <br> <br>        case WM_PAINT: <br>            BeginPaint(hArrow, &amp;ps); <br>            GetClientRect(hArrow, (LPRECT) &amp;rArrow); <br>            hbr = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>            FillRect(ps.hdc, (LPRECT)&amp;rArrow, hbr); <br>            DeleteObject(hbr); <br>            hbr = SelectObject(ps.hdc, GetStockObject(BLACK_BRUSH)); <br>            SetTextColor(ps.hdc, GetSysColor(COLOR_WINDOWFRAME)); <br>            SetMapMode(ps.hdc, MM_ANISOTROPIC); <br> <br>            SetViewportOrgEx(ps.hdc, rArrow.left, rArrow.top, NULL); <br> <br>            SetViewportExtEx(ps.hdc, rArrow.right - rArrow.left, <br>                                                    rArrow.bottom - rArrow.top, NULL); <br>            SetWindowOrgEx(ps.hdc, 0, 0, NULL); <br>            SetWindowExtEx(ps.hdc, ARROWXAXIS, ARROWYAXIS, NULL); <br>            MoveToEx(ps.hdc, 0, (ARROWYAXIS / 2), NULL); <br>            LineTo(ps.hdc, ARROWXAXIS, (ARROWYAXIS / 2)); <br>/* <br>            Polygon(ps.hdc, (LPPOINT) Arrow, 10); <br>*/ <br>            Polygon(ps.hdc, (LPPOINT) ArrowUp, POINTSPERARROW); <br>            Polygon(ps.hdc, (LPPOINT) ArrowDown, POINTSPERARROW); <br>            SelectObject(ps.hdc, hbr); <br> <br>            EndPaint(hArrow, &amp;ps); <br> <br>            break; <br> <br>        default: <br>            return(DefWindowProc(hArrow, message, wParam, lParam)); <br> <br>            break; <br>        } <br> <br>    return(0L); <br>} <br> <br>#ifndef _WIN32 <br>#pragma alloc_text(_INIT, ArrowInit) <br>#endif <br> <br> <br>BOOL FAR PASCAL ArrowInit(HANDLE hInst) <br>{ <br>    WNDCLASS wcArrow; <br> <br>    wcArrow.lpszClassName = SPINARROW_CLASSNAME; <br>    wcArrow.hInstance     = hInst; <br>    wcArrow.lpfnWndProc   = ArrowControlProc; <br>    wcArrow.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wcArrow.hIcon         = NULL; <br>    wcArrow.lpszMenuName  = NULL; <br>    wcArrow.hbrBackground = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>    wcArrow.style         = CS_HREDRAW | CS_VREDRAW; <br>#if DOUBLECLICK <br>    wcArrow.style         |= CS_DBLCLKS; <br>#endif <br>    wcArrow.cbClsExtra    = 0; <br>    wcArrow.cbWndExtra    = 0; <br> <br>    if (!RegisterClass(&amp;wcArrow)) <br>        return FALSE; <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
