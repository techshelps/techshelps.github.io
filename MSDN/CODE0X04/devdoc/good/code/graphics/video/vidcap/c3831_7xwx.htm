<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDFRAME.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3831"></a>VIDFRAME.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   vidframe.c: Frame for the capture window <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br> <br>/* <br> * Window class that provides a frame for the AVICAP window in the <br> * VidCap capture tool. Responsible for positioning within the <br> * parent window, handling scrolling and painting a size border if <br> * there is room. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;vfw.h&gt; <br>#include "vidcap.h" <br> <br>#include "vidframe.h" <br> <br>/* <br> * pixels to move when asked to scroll one line or page <br> */ <br>#define LINE_SCROLL10 <br>#define PAGE_SCROLL50 <br> <br>// class name <br>#define VIDFRAMECLASSNAME   "vidframeClass" <br> <br> <br>/* <br> * standard brushes <br> */ <br>static HBRUSH ghbrBackground = NULL, ghbrFace, ghbrHighlight, ghbrShadow; <br>static BOOL   fhbrBackgroundIsSysObj; <br> <br> <br>/* <br> * create brushes to be used in painting <br> */ <br>void <br>vidframeCreateTools(HWND hwnd) <br>{ <br> <br>    vidframeSetBrush(hwnd, gBackColour); <br> <br>    ghbrHighlight  = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT)); <br>    ghbrShadow  = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br>    ghbrFace  = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>} <br> <br>void <br>vidframeDeleteTools(void) <br>{ <br>    if (ghbrBackground) { <br>        if (!fhbrBackgroundIsSysObj) { <br>            DeleteObject(ghbrBackground); <br>            ghbrBackground = NULL; <br>        } <br>    } <br> <br>    if (ghbrHighlight) { <br>        DeleteObject(ghbrHighlight); <br>        ghbrHighlight = NULL; <br>    } <br> <br>    if (ghbrShadow) { <br>        DeleteObject(ghbrShadow); <br>        ghbrShadow = NULL; <br>    } <br> <br>    if (ghbrFace) { <br>        DeleteObject(ghbrFace); <br>        ghbrFace = NULL; <br>    } <br>} <br> <br> <br>/* <br> * change the background fill brush to be one of- <br> *  IDD_PrefsDefBackground  - windows default background colour <br> *  IDD_PrefsLtGrey - light grey <br> *  IDD_PrefsDkGrey - dark grey <br> *  IDD_PrefsBlack - black <br> */ <br>void <br>vidframeSetBrush(HWND hwnd, int iPref) <br>{ <br>    if (ghbrBackground != NULL) { <br>        if (!fhbrBackgroundIsSysObj) { <br>            DeleteObject(ghbrBackground); <br>            ghbrBackground = NULL; <br>        } <br>    } <br> <br>    switch(iPref) { <br>    case IDD_PrefsDefBackground: <br>        ghbrBackground = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        fhbrBackgroundIsSysObj = FALSE; <br>        break; <br> <br>    case IDD_PrefsLtGrey: <br>        ghbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        fhbrBackgroundIsSysObj = TRUE; <br>        break; <br> <br>    case IDD_PrefsDkGrey: <br>        ghbrBackground = GetStockObject(DKGRAY_BRUSH); <br>        fhbrBackgroundIsSysObj = TRUE; <br>        break; <br> <br>    case IDD_PrefsBlack: <br>        ghbrBackground = GetStockObject(BLACK_BRUSH); <br>        fhbrBackgroundIsSysObj = TRUE; <br>        break; <br> <br>    default: <br>        return; <br>    } <br> <br>    if (hwnd != NULL) { <br>#ifdef _WIN32 <br>        SetClassLong(hwnd, GCL_HBRBACKGROUND, (LONG) ghbrBackground); <br>#else <br>        SetClassWord(hwnd, GCW_HBRBACKGROUND, (WORD) ghbrBackground); <br>#endif <br>        InvalidateRect(hwnd, NULL, TRUE); <br>    } <br>} <br> <br> <br> <br> <br>/* <br> * layout the window  - decide if we need scrollbars or <br> * not, and position the avicap window correctly <br> */ <br>void <br>vidframeLayout(HWND hwnd, HWND hwndCap) <br>{ <br>    RECT rc; <br>    RECT rcCap; <br>    CAPSTATUS cs; <br>    int cx, cy; <br>    POINT ptScroll; <br> <br> <br>    // get the x and y scroll pos so we can reset them <br>    ptScroll.y = GetScrollPos(hwnd, SB_VERT); <br>    ptScroll.x = GetScrollPos(hwnd, SB_HORZ); <br> <br>    GetClientRect(hwnd, &amp;rc); <br>    if (!capGetStatus(hwndCap, &amp;cs, sizeof(cs))) { <br>        // no current window? - make it 0 size <br>        cs.uiImageWidth = 0; <br>        cs.uiImageHeight = 0; <br> <br>    } <br> <br>    SetRect(&amp;rcCap, 0, 0, cs.uiImageWidth, cs.uiImageHeight); <br> <br>    /* <br>     * check which scrollbars we need - note that adding and removing <br>     * scrollbars affects the other dimension - so recheck client rect <br>     */ <br>    if (RECTWIDTH(rcCap) &lt; RECTWIDTH(rc)) { <br>        // fits horz. <br>        SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>    } else { <br>        // need horz scrollbar <br>        SetScrollRange(hwnd, SB_HORZ, 0, RECTWIDTH(rcCap) - RECTWIDTH(rc), FALSE); <br>    } <br> <br>    // get client size in case shrunk/expanded <br>    GetClientRect(hwnd, &amp;rc); <br> <br>    // check vert scrollbar <br>    if (RECTHEIGHT(rcCap) &lt; RECTHEIGHT(rc)) { <br>        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>    } else { <br>        SetScrollRange(hwnd, SB_VERT, 0, RECTHEIGHT(rcCap) - RECTHEIGHT(rc), FALSE); <br> <br>        // this may have caused the horz scrollbar to be unneeded <br>        GetClientRect(hwnd, &amp;rc); <br>        if (RECTWIDTH(rcCap) &lt; RECTWIDTH(rc)) { <br>            // fits horz. <br>            SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>        } else { <br>            // need horz scrollbar <br>            SetScrollRange(hwnd, SB_HORZ, 0, RECTWIDTH(rcCap) - RECTWIDTH(rc), FALSE); <br>        } <br>    } <br> <br>    /* <br>     * be sure we don't leave any underwear showing if we have scrolled <br>     * back or removed the scrollbars <br>     */ <br>    { <br>        int cmax, cmin; <br> <br>        GetScrollRange(hwnd, SB_HORZ, &amp;cmin, &amp;cmax); <br>        if (ptScroll.x &gt; cmax) { <br>            ptScroll.x = cmax; <br>        } <br>        GetScrollRange(hwnd, SB_VERT, &amp;cmin, &amp;cmax); <br>        if (ptScroll.y &gt; cmax) { <br>            ptScroll.y = cmax; <br>        } <br>        SetScrollPos(hwnd, SB_HORZ, ptScroll.x, TRUE); <br>        SetScrollPos(hwnd, SB_VERT, ptScroll.y, TRUE); <br>        capSetScrollPos(hwndCap, &amp;ptScroll); <br>    } <br> <br>    // centre the window if requested and if room <br>    if(gbCentre) { <br>        GetClientRect(hwnd, &amp;rc); <br>        cx = max(0, (RECTWIDTH(rc) - (int) cs.uiImageWidth)/2); <br>        cy = max(0, (RECTHEIGHT(rc) - (int) cs.uiImageHeight)/2); <br>        OffsetRect(&amp;rcCap, cx, cy); <br>    } <br> <br>    // DWORD align the capture window for optimal codec speed <br>    // during preview.   <br>    rc = rcCap; <br>    MapWindowPoints (hwnd, NULL, (LPPOINT)&amp;rc, 1); <br>    cx = rc.left - (rc.left &amp; ~3); <br>    OffsetRect(&amp;rcCap, -cx, 0); <br> <br>    MoveWindow(hwndCap, <br>            rcCap.left, rcCap.top,          <br>            RECTWIDTH(rcCap), RECTHEIGHT(rcCap), <br>            TRUE); <br> <br>    InvalidateRect(hwnd, NULL, TRUE); <br>} <br> <br>/* <br> * paint the vidframe window. The fill colour is always selected as the <br> * background brush, so all we need to do here is paint the <br> * fancy border around the inner window if room. <br> */ <br>void <br>vidframePaint(HWND hwnd, HWND hwndCap) <br>{ <br>    POINT ptInner; <br>    RECT rcCap; <br>    PAINTSTRUCT ps; <br>    HDC hdc; <br>    HBRUSH hbr; <br>    int cx, cy; <br> <br>    hdc = BeginPaint(hwnd, &amp;ps); <br> <br>    /* <br>     * first calculate the location of the upper left corner <br>     * of the avicap window in vidframe-window client co-ordinates <br>     */ <br>    ptInner.x = 0; <br>    ptInner.y = 0; <br>    MapWindowPoints(hwndCap, hwnd, &amp;ptInner, 1); <br> <br>    // width and height of cap window <br>    GetWindowRect(hwndCap, &amp;rcCap); <br>    cx = RECTWIDTH(rcCap); <br>    cy = RECTHEIGHT(rcCap); <br> <br>    // shadow lines <br>    hbr = SelectObject(hdc, ghbrShadow); <br>    PatBlt(hdc, ptInner.x-1, ptInner.y-1, cx + 1, 1, PATCOPY); <br>    PatBlt(hdc, ptInner.x-1, ptInner.y-1, 1, cy + 1, PATCOPY); <br>    PatBlt(hdc, ptInner.x + cx + 4, ptInner.y-5, 1, cy+10, PATCOPY); <br>    PatBlt(hdc, ptInner.x -5, ptInner.y+cy+4, cx+10, 1, PATCOPY); <br> <br>    // hi-light lines <br>    SelectObject(hdc, ghbrHighlight); <br>    PatBlt(hdc, ptInner.x - 5, ptInner.y - 5, 1, cy+9, PATCOPY); <br>    PatBlt(hdc, ptInner.x - 5, ptInner.y - 5, cx+9, 1, PATCOPY); <br>    PatBlt(hdc, ptInner.x+cx, ptInner.y-1, 1, cy+2, PATCOPY); <br>    PatBlt(hdc, ptInner.x-1, ptInner.y+cy, cx, 1, PATCOPY); <br> <br>    // fill bordered area with button face colour <br>    SelectObject(hdc, ghbrFace); <br>    PatBlt(hdc, ptInner.x-4, ptInner.y-4, cx+8, 3, PATCOPY); <br>    PatBlt(hdc, ptInner.x-4, ptInner.y+cy+1, cx+8, 3, PATCOPY); <br>    PatBlt(hdc, ptInner.x-4, ptInner.y-1, 3, cy+2, PATCOPY); <br>    PatBlt(hdc, ptInner.x+cx+1, ptInner.y-1, 3, cy+2, PATCOPY); <br> <br>    SelectObject(hdc, hbr); <br> <br>    EndPaint(hwnd, &amp;ps); <br> <br>} <br> <br>/* <br> * respond to a scrollbar message by moving the current scroll <br> * position horizontally <br> */ <br>void <br>vidframeHScroll(HWND hwnd, HWND hwndCap, int code, int pos) <br>{ <br>    POINT pt; <br>    int cmax, cmin; <br> <br>    pt.x = GetScrollPos(hwnd, SB_HORZ); <br>    pt.y = GetScrollPos(hwnd, SB_VERT); <br>    GetScrollRange(hwnd, SB_HORZ, &amp;cmin, &amp;cmax); <br> <br> <br>    switch(code) { <br>    case SB_LINEUP: <br>        pt.x -= LINE_SCROLL; <br>        break; <br> <br>    case SB_LINEDOWN: <br>        pt.x += LINE_SCROLL; <br>        break; <br> <br>    case SB_PAGEUP: <br>        pt.x -= PAGE_SCROLL; <br>        break; <br> <br>    case SB_PAGEDOWN: <br>        pt.x += PAGE_SCROLL; <br>        break; <br> <br>    case SB_THUMBTRACK: <br>    case SB_THUMBPOSITION: <br>        pt.x = pos; <br>        break; <br>    } <br> <br>    if (pt.x &lt; cmin) { <br>        pt.x = cmin; <br>    } else if (pt.x &gt; cmax) { <br>        pt.x = cmax; <br>    } <br>    SetScrollPos(hwnd, SB_HORZ, pt.x, TRUE); <br>    capSetScrollPos(hwndCap, &amp;pt); <br> <br>} <br> <br> <br>/* <br> * respond to a scrollbar message by moving the current scroll <br> * position vertically <br> */ <br>void <br>vidframeVScroll(HWND hwnd, HWND hwndCap, int code, int pos) <br>{ <br>    POINT pt; <br>    int cmax, cmin; <br> <br>    pt.x = GetScrollPos(hwnd, SB_HORZ); <br>    pt.y = GetScrollPos(hwnd, SB_VERT); <br>    GetScrollRange(hwnd, SB_VERT, &amp;cmin, &amp;cmax); <br> <br> <br>    switch(code) { <br>    case SB_LINEUP: <br>        pt.y -= LINE_SCROLL; <br>        break; <br> <br>    case SB_LINEDOWN: <br>        pt.y += LINE_SCROLL; <br>        break; <br> <br>    case SB_PAGEUP: <br>        pt.y -= PAGE_SCROLL; <br>        break; <br> <br>    case SB_PAGEDOWN: <br>        pt.y += PAGE_SCROLL; <br>        break; <br> <br>    case SB_THUMBTRACK: <br>    case SB_THUMBPOSITION: <br>        pt.y = pos; <br>        break; <br>    } <br> <br>    if (pt.y &lt; cmin) { <br>        pt.y = cmin; <br>    } else if (pt.y &gt; cmax) { <br>        pt.y = cmax; <br>    } <br>    SetScrollPos(hwnd, SB_VERT, pt.y, TRUE); <br>    capSetScrollPos(hwndCap, &amp;pt); <br>} <br> <br> <br> <br>LONG FAR PASCAL  <br>vidframeProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>    switch(message) { <br> <br>    case WM_MOVE: <br>    case WM_SIZE: <br>        if (ghWndCap) { <br>            vidframeLayout(hwnd, ghWndCap); <br>        } <br>        break; <br> <br>    case WM_SYSCOLORCHANGE: <br>        // re-get brushes - we will be sent a paint message <br>        vidframeDeleteTools(); <br>        vidframeCreateTools(hwnd); <br>        return(TRUE); <br> <br> <br>    case WM_PALETTECHANGED: <br>    case WM_QUERYNEWPALETTE: <br>        // allow the avicap window to handle this <br>        if (ghWndCap) { <br>            return SendMessage(ghWndCap, message, wParam, lParam) ; <br>        } <br> <br>    case WM_PAINT: <br>        if (ghWndCap) { <br>            vidframePaint(hwnd, ghWndCap); <br>        } <br>        break; <br> <br>    case WM_HSCROLL: <br>        if (ghWndCap) { <br>            vidframeHScroll(hwnd, ghWndCap, <br>                GET_WM_HSCROLL_CODE(wParam, lParam), <br>                GET_WM_HSCROLL_POS(wParam, lParam) <br>                ); <br>        } <br>        break; <br> <br>    case WM_VSCROLL: <br>        if (ghWndCap) { <br>            vidframeVScroll(hwnd, ghWndCap, <br>                GET_WM_VSCROLL_CODE(wParam, lParam), <br>                GET_WM_VSCROLL_POS(wParam, lParam) <br>                ); <br>        } <br>        break; <br> <br>    case WM_DESTROY: <br>        vidframeDeleteTools(); <br>        break; <br> <br>    default: <br>        return(DefWindowProc(hwnd, message, wParam, lParam)); <br> <br>    } <br>    return(0); <br>} <br> <br> <br> <br>/* <br> * create a frame window and child capture window at the <br> * given location. Initialise the class if this is the <br> * first time through. <br> * <br> * returns the window handle of the frame window <br> * (or NULL if failure). returns the window handle of the AVICAP window <br> * via phwndCap. <br> */ <br>HWND <br>vidframeCreate( <br>    HWND hwndParent, <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    int x, <br>    int y, <br>    int cx, <br>    int cy, <br>    HWND FAR * phwndCap <br>) <br>{ <br>    HWND hwnd, hwndCap; <br>    static BOOL bInitDone = FALSE; <br> <br>    if (!bInitDone) { <br>        WNDCLASS wc; <br> <br>        vidframeCreateTools(NULL); <br> <br>        if (!hPrevInstance) { <br>            // If it's the first instance, register the window class <br>            wc.lpszClassName = VIDFRAMECLASSNAME; <br>            wc.hInstance     = hInstance; <br>            wc.lpfnWndProc   = vidframeProc; <br>            wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ; <br>            wc.hIcon         = NULL; <br>            wc.lpszMenuName  = NULL; <br>            wc.hbrBackground = ghbrBackground; <br>            wc.style         = CS_HREDRAW | CS_VREDRAW ; <br>            wc.cbClsExtra    = 0 ; <br>            wc.cbWndExtra    = 0 ;    <br> <br>            if(!RegisterClass(&amp;wc)) { <br>                return(NULL); <br>            } <br>        } <br>        bInitDone = TRUE; <br>    } <br> <br>    hwnd = CreateWindowEx( <br>                gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0, <br>                VIDFRAMECLASSNAME, <br>                NULL, <br>                WS_CHILD|WS_VISIBLE|WS_HSCROLL|WS_VSCROLL|WS_CLIPCHILDREN, <br>                x, y, cx, cy, <br>                hwndParent, <br>                (HMENU) 0, <br>                hInstance, <br>                NULL); <br> <br>    if (hwnd == NULL) { <br>        return(NULL); <br>    } <br> <br> <br>    /* <br>     * create an AVICAP window within this window. Leave vidframeLayout <br>     * to do the layout <br>     */ <br>    hwndCap = capCreateCaptureWindow( <br>                    NULL, <br>                    WS_CHILD | WS_VISIBLE, <br>                    0, 0, 160, 120, <br>                    hwnd,               // parent window <br>                    1                   // child window id <br>              ); <br> <br> <br>    if (hwndCap == NULL) { <br>        return(NULL); <br>    } <br> <br>    *phwndCap = hwndCap; <br>    return(hwnd); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
