<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3816"></a>DIALOGS.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   dialogs.c: Dialog box processing <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;dos.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "arrow.h" <br>#include "rlmeter.h" <br>#include "vidcap.h" <br>#include "vidframe.h" <br>#include "help.h" <br> <br>static long GetFreeDiskSpaceInKB(LPTSTR) ; <br>static int  CountMCIDevices(WORD) ; <br> <br>BOOL FAR PASCAL MCISetupProc(HWND, unsigned, UINT, LONG); <br> <br> <br>//--- utility functions  --------------------------------------------------- <br> <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|   SmartWindowPosition (HWND hWndDlg, HWND hWndShow) <br>|                                                                              | <br>|   Description:                                                               | <br>|       This function attempts to position a dialog box so that it <br>|       does not obscure the hWndShow window. This function is <br>|       typically called during WM_INITDIALOG processing. <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hWndDlg         handle of the soon to be displayed dialog <br>|       hWndShow        handle of the window to keep visible <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       1 if the windows overlap and positions were adjusted <br>|       0 if the windows don't overlap <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>int SmartWindowPosition (HWND hWndDlg, HWND hWndShow) <br>{ <br>    RECT rc, rcDlg, rcShow; <br>    int iHeight, iWidth; <br>    int iScreenHeight, iScreenWidth; <br> <br>    GetWindowRect(hWndDlg, &amp;rcDlg); <br>    GetWindowRect(hWndShow, &amp;rcShow); <br> <br>    iScreenHeight = GetSystemMetrics(SM_CYSCREEN); <br>    iScreenWidth = GetSystemMetrics(SM_CXSCREEN); <br> <br>    InflateRect (&amp;rcShow, 5, 5); // allow a small border <br>    if (IntersectRect(&amp;rc, &amp;rcDlg, &amp;rcShow)){ <br>        /* the two do intersect, now figure out where to place */ <br>        /* this dialog window.  Try to go below the Show window*/ <br>        /* first and then to the right, top and left.   */ <br> <br>        /* get the size of this dialog */ <br>        iHeight = rcDlg.bottom - rcDlg.top; <br>        iWidth = rcDlg.right - rcDlg.left; <br> <br>        if ((WORD)(rcShow.bottom + iHeight + 1) &lt;  iScreenHeight){ <br>                /* will fit on bottom, go for it */ <br>                rc.top = rcShow.bottom + 1; <br>                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left) <br>            - (iWidth/2); <br>        } else if ((WORD)(rcShow.right + iWidth + 1) &lt; iScreenWidth){ <br>                /* will fit to right, go for it */ <br>                rc.left = rcShow.right + 1; <br>                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top) <br>            - (iHeight/2); <br>        } else if ((WORD)(rcShow.top - iHeight - 1) &gt; 0){ <br>                /* will fit on top, handle that */ <br>                rc.top = rcShow.top - iHeight - 1; <br>                rc.left = (((rcShow.right - rcShow.left)/2) + rcShow.left) <br>            - (iWidth/2); <br>        } else if ((WORD)(rcShow.left - iWidth - 1) &gt; 0){ <br>                /* will fit to left, do it */ <br>                rc.left = rcShow.left - iWidth - 1; <br>                rc.top = (((rcShow.bottom - rcShow.top)/2) + rcShow.top) <br>            - (iHeight/2); <br>        } else { <br>                /* we are hosed, they cannot be placed so that there is */ <br>                /* no overlap anywhere.  To minimize the damage just put*/ <br>                /* the dialog in the lower left corner of the screen    */ <br>                rc.top = (int)iScreenHeight - iHeight; <br>                rc.left = (int)iScreenWidth - iWidth; <br>        } <br> <br>        /* make any adjustments necessary to keep it on the screen */ <br>        if (rc.left &lt; 0) rc.left = 0; <br>        else if ((WORD)(rc.left + iWidth) &gt; iScreenWidth) <br>                rc.left = (int)(iScreenWidth - iWidth); <br> <br>        if (rc.top &lt; 0)  rc.top = 0; <br>        else if ((WORD)(rc.top + iHeight) &gt; iScreenHeight) <br>                rc.top = (int)iScreenHeight - iHeight; <br> <br>        SetWindowPos(hWndDlg, NULL, rc.left, rc.top, 0, 0, <br>            SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE); <br>        return 1; <br>    } // if the windows overlap by default <br> <br>    return 0; <br>} <br> <br>// <br>// GetFreeDiskSpace: Function to Measure Available Disk Space <br>// <br>static long GetFreeDiskSpaceInKB(LPTSTR pFile) <br>{ <br>    DWORD dwFreeClusters, dwBytesPerSector, dwSectorsPerCluster, dwClusters; <br>    char RootName[MAX_PATH]; <br>    LPSTR ptmp;    //required arg <br> <br>    // need to find path for root directory on drive containing <br>    // this file. <br> <br>    GetFullPathName(pFile, sizeof(RootName)/sizeof(RootName[0]), RootName, &amp;ptmp); <br> <br>    // truncate this to the name of the root directory (god how tedious) <br>    if ((RootName[0] == TEXT('\\')) &amp;&amp; (RootName[1] == TEXT('\\'))) { <br> <br>        // path begins with  \\server\share\path so skip the first <br>        // three backslashes <br>        ptmp = &amp;RootName[2]; <br>        while (*ptmp &amp;&amp; (*ptmp != TEXT('\\'))) { <br>            ptmp++; <br>        } <br>        if (*ptmp) { <br>            // advance past the third backslash <br>            ptmp++; <br>        } <br>    } else { <br>        // path must be drv:\path <br>        ptmp = RootName; <br>    } <br> <br>    // find next backslash and put a null after it <br>    while (*ptmp &amp;&amp; (*ptmp != TEXT('\\'))) { <br>        ptmp++; <br>    } <br>    // found a backslash ? <br>    if (*ptmp) { <br>        // skip it and insert null <br>        ptmp++; <br>        *ptmp = TEXT('\0'); <br>    } <br> <br> <br> <br>    if (!GetDiskFreeSpace(RootName, <br>&amp;dwSectorsPerCluster, <br>&amp;dwBytesPerSector, <br>&amp;dwFreeClusters, <br>&amp;dwClusters)) { <br>    MessageBoxID(IDS_ERR_MEASUREFREEDISK, MB_OK | MB_ICONINFORMATION); <br>    return (-1); <br>    } <br>    return(MulDiv (dwSectorsPerCluster * dwBytesPerSector, <br>   dwFreeClusters, <br>   1024)); <br>} <br> <br>// <br>// CountMCIDevices: Function to Find the Number of MCI Devices of a Type <br>// <br>static int CountMCIDevices(WORD wType) <br>{ <br>    int               nTotal = 0 ; <br>    DWORD             dwCount ; <br>    MCI_SYSINFO_PARMS mciSIP ; <br> <br>    mciSIP.dwCallback = 0 ; <br>    mciSIP.lpstrReturn = (LPSTR)(LPVOID) &amp;dwCount ; <br>    mciSIP.dwRetSize = sizeof(DWORD) ; <br>    mciSIP.wDeviceType = wType ; <br> <br>    // Use an MCI command to get the info <br>    if (! mciSendCommand(0, MCI_SYSINFO, MCI_SYSINFO_QUANTITY, <br>                         (DWORD)(LPVOID) &amp;mciSIP)) <br>        nTotal = (int) *((LPDWORD) mciSIP.lpstrReturn) ; <br> <br>    return nTotal ; <br>} <br> <br> <br> <br>/* lMicroSec = StringRateToMicroSec(szRate) <br> * <br> * Convert &lt;szRate&gt; (e.g. "3.75" representing 3.75 frames per second) <br> * to microseconds (e.g. 266667L microseconds per frame). <br> * <br> * If the rate is close to zero or negative, then 0L is returned. <br> */ <br>DWORD StringRateToMicroSec(PSTR szRate) <br>{ <br>doubledRate; <br> <br>dRate = atof(szRate); <br> <br>if (dRate &lt; 0.0001) { <br>return 0L; <br>} else { <br>return (DWORD) /*floor*/((1e6 / dRate) + 0.5); <br>        } <br>} <br> <br>/* ach = MicroSecToStringRate(achRate, lMicroSec) <br> * <br> * Convert &lt;lMicroSec&gt; (e.g. 266667L microseconds per frame) to a <br> * string rate (e.g. "3.75" representing 3.75 frames per second). <br> * Returns &lt;achRate&gt;. <br> */ <br>PSTR MicroSecToStringRate(PSTR achRate, DWORD dwMicroSec) <br>{ <br>sprintf(achRate, "%.3f", <br>(dwMicroSec == 0L) ? 0.0 : (1e6 / (double) dwMicroSec)); <br> <br>return achRate; <br>} <br> <br>/* <br> * update the text of an edit field based on a comarrow up or down change <br> * - write the text in N.NNN format (truncated to an integer) <br> */ <br>LONG FAR PASCAL <br>MilliSecVarArrowEditChange( <br>    HWND hwndEdit, <br>    UINT uCode, <br>    LONG lMin, <br>    LONG lMax, <br>    UINT uInc <br>) <br>{ <br>    char achTemp[32]; <br>    LONG l; <br> <br>    GetWindowText(hwndEdit, achTemp, sizeof(achTemp)); <br> <br>    l = atol(achTemp); <br>    if(uCode == SB_LINEUP ) { <br> <br>if(l + (long)uInc &lt;= lMax ) { <br>    l += uInc; <br>    wsprintf(achTemp, "%ld.000", l ); <br>    SetWindowText(hwndEdit, achTemp ); <br>        } else { <br>    MessageBeep( 0 ); <br>} <br>    } else if (uCode == SB_LINEDOWN ) { <br>if( l-(long)uInc &gt;= lMin ) { <br>    l -= uInc; <br>    wsprintf( achTemp, "%ld.000", l ); <br>    SetWindowText( hwndEdit, achTemp ); <br>        } else { <br>    MessageBeep( 0 ); <br>} <br>    } <br>    return( l ); <br>} <br> <br> <br>BOOL MCIGetDeviceNameAndIndex (HWND hwnd, LPINT lpnIndex, LPSTR lpName) <br>{ <br>    HWND hwndCB; <br>    char buf[160]; <br>    char *cp; <br> <br>    hwndCB = GetDlgItem( hwnd, IDD_MCI_SOURCE ); <br>    *lpnIndex = (int)SendMessage( hwndCB, CB_GETCURSEL, 0, 0L); <br>    SendMessage( hwndCB, CB_GETLBTEXT, *lpnIndex, <br>    (LONG)(LPSTR) buf ); <br>    // Point cp to the system name <br>    for (cp = buf + lstrlen(buf); cp &gt; buf; cp--) { <br>        if (*cp == ' ' &amp;&amp; *(cp-1) == ',') { <br>            cp++; <br>            break; <br>} <br>    } <br>    lstrcpy (lpName, cp); <br>    return TRUE; <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| TimeMSToHMSString() - change milliseconds into a time string   | <br>+--------------------------------------------------------------*/ <br>void FAR PASCAL TimeMSToHMSString (DWORD dwMS, LPSTR lpTime) <br>{ <br>DWORDdwTotalSecs; <br>LONGlHundredths; <br>WORDwSecs; <br>WORDwMins; <br>WORDwHours; <br> <br>/* convert to number of seconds */ <br>dwTotalSecs = dwMS / 1000; <br> <br>/* keep the remainder part */ <br>lHundredths = (dwMS - (dwTotalSecs * 1000)) / 10; <br> <br>/* break down into other components */ <br>wHours = (WORD)(dwTotalSecs / 3600);// get # Hours <br>dwTotalSecs -= (wHours * 3600); <br> <br>wMins = (WORD)(dwTotalSecs / 60);// get # Mins <br>dwTotalSecs -= (wMins * 60); <br> <br>wSecs = (WORD)dwTotalSecs;// what's left is # seconds <br> <br>/* build the string */ <br>wsprintf((char far *)lpTime, "%02u:%02u:%02u.%02lu", wHours, wMins, <br>    wSecs, lHundredths); <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| TimeHMSStringToMS() - change Time string to milliseconds     | <br>|                       returns dwMilliseconds or -1 if error  | <br>+--------------------------------------------------------------*/ <br>LONG NEAR PASCAL  TimeHMSStringToMS (LPSTR lpsz) <br>{ <br>    charachTime[12];// buffer for time string (input) <br>    DWORDdwMSecs;// total MSecs for this thing */ <br>    char*pDelim;// pointer to next delimeter <br>    char*p;// general pointer <br>    DWORDdwHours = 0;// # of hours <br>    DWORDdwMins = 0;// # of minutes <br>    DWORDdwSecs = 0;// # of seconds <br>    WORDwHundredths = 0;// # hundredths <br> <br>    _fstrncpy(achTime, lpsz, sizeof (achTime)); <br> <br>    if (achTime[0] == '\0') <br>        return -1;// bad char so error out <br>     <br>    /* rip through the whole string and look for illegal chars */ <br>    for (p = achTime; *p ; p++){ <br>        if (!isdigit(*p) &amp;&amp; *p != '.' &amp;&amp; *p != ':') <br>    return -1;// bad char so error out <br>    } <br> <br>    /* go find the hundredths portion if it exists */ <br>    pDelim = strchr(achTime, '.'); <br>    if (*pDelim){ <br>        p = strrchr(achTime, '.'); <br>        if (pDelim != p) { <br>        return -1;// string has &gt; 1 '.', return error <br>        } <br> <br>        p++;// move up past delim <br>        if (strlen(p) &gt; 2) { <br>        *(p+2) = '\0';// knock off all but hundredths <br>        } <br> <br>        wHundredths = atoi(p);// get the fractional part <br> <br>        *pDelim = '\0';// null out this terminator <br>    } <br> <br>    /* try and find seconds */ <br>    pDelim = strrchr(achTime, ':');// get last ':' <br>    if (*pDelim) { <br>        p = (pDelim+1); <br>    } else { <br>        // no colon - assume just seconds in string <br>        p = achTime; <br>    } <br>    dwSecs = atoi(p); <br> <br>    if (*pDelim) { <br>        *pDelim = '\0'; <br> <br>        /* go and get the minutes part */ <br>        pDelim = strrchr(achTime, ':'); <br>        if (*pDelim) { <br>            p = (pDelim + 1); <br>        } else { <br>            // no more colons - assume remainder is just minutes <br>            p = achTime; <br>        } <br>        dwMins = atoi(p); <br> <br>        if (*pDelim) { <br>            *pDelim = '\0'; <br> <br>            /* get the hours */ <br>            p = achTime; <br>            dwHours = atoi(p); <br>        } <br>    } <br> <br>    /* now we've got the hours, minutes, seconds and any*/ <br>    /* fractional part.  Time to build up the total time*/ <br> <br>    dwSecs += (dwHours * 3600);// add in hours worth of seconds <br>    dwSecs += (dwMins * 60);// add in minutes worth of seconds <br>    dwMSecs = (dwSecs * 1000L); <br>    dwMSecs += (wHundredths * 10L); <br> <br>    /* now we've got the total number of milliseconds */ <br>    return dwMSecs; <br>} <br> <br> <br>/* <br> *  MCIDeviceClose <br> *      This routine closes the open MCI device. <br> */ <br> <br>void MCIDeviceClose (void) <br>{ <br>    mciSendString( "close mciframes", NULL, 0, NULL ); <br>} <br> <br> <br> <br>/* <br> *  MCIDeviceOpen <br> *      This routine opens the mci device for use, and sets the <br> *      time format to milliseconds. <br> *      Return FALSE on error; <br> */ <br> <br>BOOL MCIDeviceOpen (LPSTR lpDevName) <br>{ <br>    char        ach[160]; <br>    DWORD dwMCIError; <br> <br>    wsprintf( ach, "open %s shareable wait alias mciframes", (LPSTR) lpDevName); <br>    dwMCIError = mciSendString( ach, NULL, 0, NULL ); <br>    if( dwMCIError )  { <br>        return(FALSE); <br>    } <br> <br>    dwMCIError = mciSendString( "set mciframes time format milliseconds", <br>    NULL, 0, NULL ); <br>    if( dwMCIError ) { <br>        MCIDeviceClose(); <br>        return(FALSE); <br>    } <br>    return ( TRUE ); <br> <br>} <br> <br> <br>/* <br> *  MCIDeviceGetPosition <br> *      Stores the current device position in milliseconds in lpdwPos. <br> *      Returns TRUE on success, FALSE if error. <br> */ <br>BOOL FAR PASCAL MCIDeviceGetPosition (LPDWORD lpdwPos) <br>{ <br>    char        ach[80]; <br>    DWORD dwMCIError; <br> <br>    dwMCIError = mciSendString( "status mciframes position wait", <br>    ach, sizeof(ach), NULL ); <br>    if( dwMCIError ) { <br>        *lpdwPos = 0L; <br>        return FALSE; <br>    } <br> <br>    *lpdwPos = atol( ach ); <br>    return TRUE; <br>} <br> <br>#ifndef USE_ACM <br> <br>// --- audio streaming ------------------------------------------------ <br> <br>// the ShowLevel dialog streams data in from the input and <br>// shows the current volume. <br> <br>// buffers into which sound data is recorded <br>#define NUM_LEVEL_BUFFERS   2 <br> <br>// the buffer size is calculated to be about 1/20 sec <br>#define UPDATES_PER_SEC     20 <br> <br>/* <br> * we save all our data in one of these, and write a pointer to it <br> * into the dialog DWL_USER field. <br> */ <br> <br>typedef struct _LevelStreamData { <br>    LPWAVEHDR alpWave[NUM_LEVEL_BUFFERS]; <br>    PCMWAVEFORMAT FAR * pwf; <br>    HWAVEIN hwav; <br>    int buffersize; <br>} LEVELSTREAMDATA, FAR * PLEVELSTREAMDATA; <br> <br> <br>//open the wave-device in the given format, queue all the buffers and <br>//start data streaming. Save the wavein device to the dialog DWL_USER window <br>//data area so we can close it on dialog dismissal. <br>BOOL <br>OpenStream(HWND hDlg, PCMWAVEFORMAT FAR * pwf) <br>{ <br>    PLEVELSTREAMDATA pInfo; <br>    int i; <br> <br> <br>    pInfo = (PLEVELSTREAMDATA) GlobalLock(GlobalAlloc(GHND, sizeof(LEVELSTREAMDATA))); <br> <br>    if (pInfo == NULL) { <br>        return(FALSE); <br>    } <br> <br> <br>    // complete remaining areas of wf <br>    pwf-&gt;wf.wFormatTag = WAVE_FORMAT_PCM; <br>    pwf-&gt;wf.nBlockAlign = pwf-&gt;wf.nChannels * pwf-&gt;wBitsPerSample / 8; <br>    pwf-&gt;wf.nAvgBytesPerSec = pwf-&gt;wf.nSamplesPerSec * pwf-&gt;wf.nBlockAlign; <br> <br>    // save for later use <br>    pInfo-&gt;pwf = pwf; <br> <br>    // buffer size a fixed fraction of a second <br>    pInfo-&gt;buffersize = pwf-&gt;wf.nAvgBytesPerSec/UPDATES_PER_SEC; <br> <br> <br>    pInfo-&gt;hwav = NULL; <br> <br>    if (waveInOpen( <br>        &amp;pInfo-&gt;hwav, <br>        WAVE_MAPPER, <br>        (LPWAVEFORMATEX)pwf, <br>        (DWORD) hDlg,               // callback via MM_WIM_ messages to dialogproc <br>        0, <br>        CALLBACK_WINDOW)) { <br>            SetWindowLong(hDlg, DWL_USER, 0); <br>            return(FALSE); <br>    } <br> <br>    // store the info structure in the dialog, so that even if we fail <br>    // on this routine we will clean up correctly <br>    SetWindowLong(hDlg, DWL_USER, (long) pInfo); <br> <br>    // set all the wave headers to null (for cleanup if error) <br>    for (i = 0; i &lt; NUM_LEVEL_BUFFERS; i++) { <br>        pInfo-&gt;alpWave[i] = NULL; <br>    } <br> <br>    // alloc, prepare and add all the buffers <br>    for (i = 0; i &lt; NUM_LEVEL_BUFFERS; i++) { <br> <br>        pInfo-&gt;alpWave[i] = GlobalLock(GlobalAlloc(GMEM_MOVEABLE|GMEM_SHARE, <br>                        sizeof(WAVEHDR) + pInfo-&gt;buffersize)); <br>        if (pInfo-&gt;alpWave[i] == NULL) { <br>            return(FALSE); <br>        } <br> <br>        pInfo-&gt;alpWave[i]-&gt;lpData = (LPBYTE) (pInfo-&gt;alpWave[i] + 1); <br>        pInfo-&gt;alpWave[i]-&gt;dwBufferLength = pInfo-&gt;buffersize; <br>        pInfo-&gt;alpWave[i]-&gt;dwBytesRecorded = 0; <br>        pInfo-&gt;alpWave[i]-&gt;dwUser = 0; <br>        pInfo-&gt;alpWave[i]-&gt;dwFlags = 0; <br>        pInfo-&gt;alpWave[i]-&gt;dwLoops = 0; <br> <br>        if (waveInPrepareHeader(pInfo-&gt;hwav, pInfo-&gt;alpWave[i], sizeof(WAVEHDR))) { <br>            return(FALSE); <br>        } <br> <br>        if (waveInAddBuffer(pInfo-&gt;hwav, pInfo-&gt;alpWave[i], sizeof(WAVEHDR))) { <br>            return(FALSE); <br>        } <br>    } <br> <br>    waveInStart(pInfo-&gt;hwav); <br> <br>    return(TRUE); <br>} <br> <br>// terminate the data streaming on a wavein device associated with a <br>// dialog, and clean up the buffers allocated <br>void <br>CloseStream(HWND hDlg) <br>{ <br>    PLEVELSTREAMDATA pInfo; <br>    int i; <br> <br> <br>    // pick up our info from the dialog <br>    pInfo = (PLEVELSTREAMDATA) GetWindowLong(hDlg, DWL_USER); <br>    if ((pInfo == NULL) || (pInfo-&gt;hwav == NULL)) { <br>        return; <br>    } <br> <br>    // stop streaming data <br>    waveInStop(pInfo-&gt;hwav); <br> <br>    // release all buffers <br>    waveInReset(pInfo-&gt;hwav); <br> <br>    // unlock and free buffers <br>    for (i = 0; i &lt; NUM_LEVEL_BUFFERS; i++) { <br>        if (pInfo-&gt;alpWave[i]) { <br>            waveInUnprepareHeader(pInfo-&gt;hwav, pInfo-&gt;alpWave[i], sizeof(WAVEHDR)); <br>            GlobalFree(GlobalHandle(pInfo-&gt;alpWave[i])); <br>            pInfo-&gt;alpWave[i] = NULL; <br>        } <br> <br>    } <br>    waveInClose(pInfo-&gt;hwav); <br> <br>    GlobalFree(GlobalHandle(pInfo)); <br> <br>    SetWindowLong(hDlg, DWL_USER, 0); <br> <br> <br>} <br> <br>// we have received a block of data. work out the level(s) and send to <br>// the appropriate control on the dialog, and then requeue the buffer. <br>// return FALSE if any error occurs, otherwise TRUE <br>BOOL <br>StreamData(HWND hDlg, HWAVEIN hwav, LPWAVEHDR pHdr) <br>{ <br>    PLEVELSTREAMDATA pInfo; <br>    int n = 0; <br>    int LevelLeft = 0, LevelRight = 0; <br>    int i, l; <br> <br>    // pick up our info from the dialog <br>    pInfo = (PLEVELSTREAMDATA) GetWindowLong(hDlg, DWL_USER); <br>    if ((pInfo == NULL) || (pInfo-&gt;hwav != hwav)) { <br>        return FALSE; <br>    } <br> <br>    // go through all samples in buffer looking for maximum absolute level <br>    while (n &lt; pInfo-&gt;buffersize) { <br> <br>        /* <br>         * volumes go above and below the mean level - we are <br>         * interested in the absolute volume <br>         * 8 bit samples are in the range 0..255 <br>         * 16-bit samples are in the range -32768..+32767 <br>         */ <br> <br>        // skip the first byte if 16-bit <br>        // and adjust to be in range -127..+128 <br>        if (pInfo-&gt;pwf-&gt;wBitsPerSample == 16) { <br>            n++; <br>            i = (int) (signed char) pHdr-&gt;lpData[n]; <br>        } else { <br>            i = (int) ((unsigned char) pHdr-&gt;lpData[n]) - 128; <br>        } <br> <br>        // skip past the byte we've picked up <br>        n++; <br> <br>        // take absolute volume level <br>        if (i &lt; 0) { <br>            i = -i; <br>        } <br> <br>        // convert to percentage <br>        l = (i*100) / 128; <br> <br>        // compare against current max <br>        if (LevelLeft &lt; l) { <br>            LevelLeft = l; <br>        } <br> <br> <br>        // if stereo, repeat for right channel <br>        if (pInfo-&gt;pwf-&gt;wf.nChannels == 2) { <br>            // skip the first byte if 16-bit <br>            if (pInfo-&gt;pwf-&gt;wBitsPerSample == 16) { <br>                n++; <br>                i = (int) (signed char) pHdr-&gt;lpData[n]; <br>            } else { <br>                i = (int) ((unsigned char) pHdr-&gt;lpData[n]) - 128; <br>            } <br> <br>            // skip past the byte we've picked up <br>            n++; <br> <br>            // take absolute volume level <br>            if (i &lt; 0) { <br>                i = -i; <br>            } <br> <br>            // convert to percentage <br>            l = (i*100) / 128; <br> <br>            // compare against current max <br>            if (LevelRight &lt; l) { <br>                LevelRight = l; <br>            } <br>        } <br>    } <br> <br>    // put the buffer back on the queue <br>    if (waveInAddBuffer(pInfo-&gt;hwav, pHdr, sizeof(WAVEHDR))) { <br>        return(FALSE); <br>    } <br> <br>    // send new level to dialog control <br>    SendDlgItemMessage(hDlg, IDRL_LEVEL1, WMRL_SETLEVEL, 0, LevelLeft); <br>    if (pInfo-&gt;pwf-&gt;wf.nChannels == 2) { <br>        SendDlgItemMessage(hDlg, IDRL_LEVEL2, WMRL_SETLEVEL, 0, LevelRight); <br>    } <br> <br>    return(TRUE); <br>} <br> <br>#endif  // ! USE_ACM <br> <br> <br>// --- dialog procs ----------------------------------------------------- <br> <br> <br>// <br>// AboutProc: About Dialog Box Procedure <br>// <br>int FAR PASCAL AboutProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>             return TRUE ; <br> <br>        case WM_COMMAND : <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK : <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br>} <br> <br>#ifndef USE_ACM <br> <br>/* <br> * dialog proc for IDD_RECLVLMONO and IDD_RECLVLSTEREO - show current <br> * volume level <br> */ <br>int FAR PASCAL <br>ShowLevelProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(message) { <br> <br>    case WM_INITDIALOG: <br>        if (!OpenStream(hDlg, (PCMWAVEFORMAT FAR *) lParam)) { <br>            MessageBoxID(IDS_ERR_ACCESS_SOUNDDRIVER, MB_OK|MB_ICONSTOP); <br>            EndDialog(hDlg, FALSE); <br>        } <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>        case IDCANCEL: <br> <br>            CloseStream(hDlg); <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>        } <br>        break; <br> <br>    case MM_WIM_DATA: <br>        if (!StreamData(hDlg, (HWAVEIN)wParam, (LPWAVEHDR)lParam)) { <br>            MessageBoxID(IDS_ERR_ACCESS_SOUNDDRIVER, MB_OK|MB_ICONSTOP); <br>            CloseStream(hDlg); <br>            EndDialog(hDlg, FALSE); <br>        } <br>        return(TRUE); <br> <br>    } <br>    return FALSE; <br>} <br> <br> <br> <br> <br> <br>// <br>// AudioFormatProc: Audio Format Setting Dialog Box Procedure <br>// <br>int FAR PASCAL AudioFormatProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    static int                nChannels ; <br>    static WORD               wSample ; <br>    static DWORD              dwFrequency ; <br> <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>            nChannels = IDD_ChannelIDs + glpwfex-&gt;nChannels ; <br>            CheckRadioButton(hDlg, IDD_ChannelMono, IDD_ChannelStereo, nChannels) ; <br>            wSample = IDD_SampleIDs + glpwfex-&gt;wBitsPerSample / 8 ; <br>            CheckRadioButton(hDlg, IDD_Sample8Bit, IDD_Sample16Bit, wSample) ; <br>            dwFrequency = IDD_FreqIDs + glpwfex-&gt;nSamplesPerSec / 11025 ; <br>            CheckRadioButton(hDlg, IDD_Freq11kHz, IDD_Freq44kHz, (WORD)dwFrequency) ; <br>            return TRUE ; <br> <br>        case WM_COMMAND : <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDD_SetLevel: <br>                { <br>                    // get the current data into a PCMWAVEFORMAT struct, <br>                    // and run the ShowLevel dialog <br>                    PCMWAVEFORMAT wf; <br>                    UINT dlgid; <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_ChannelMono)) { <br>                        wf.wf.nChannels = 1; <br>                        dlgid = IDD_RECLVLMONO; <br>                    } else { <br>                        wf.wf.nChannels = 2; <br>                        dlgid = IDD_RECLVLSTEREO; <br>                    } <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_Sample8Bit)) { <br>                        wf.wBitsPerSample = 8; <br>                    } else { <br>                        wf.wBitsPerSample = 16; <br>                    } <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_Freq11kHz)) { <br>                        wf.wf.nSamplesPerSec = 11025 ; <br>                    } else if (IsDlgButtonChecked(hDlg, IDD_Freq22kHz)) { <br>                        wf.wf.nSamplesPerSec = 22050 ; <br>                    } else { <br>                        wf.wf.nSamplesPerSec =  44100 ; <br>                    } <br> <br>                    DoDialog( <br>                        hDlg, <br>                        dlgid, <br>                        ShowLevelProc, <br>                        (LPARAM) &amp;wf); <br>                    break; <br>                } <br> <br>                case IDOK : <br>                    if (IsDlgButtonChecked(hDlg, IDD_ChannelMono)) <br>                        nChannels = 1 ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_ChannelStereo)) <br>                            nChannels = 2 ; <br>                        else { <br>                            MessageBeep(MB_ICONEXCLAMATION) ; <br>                            return FALSE ; <br>                        } <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_Sample8Bit)) <br>                        wSample = 8 ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_Sample16Bit)) <br>                            wSample = 16 ; <br>                        else { <br>                            MessageBeep(MB_ICONEXCLAMATION) ; <br>                            return FALSE ; <br>                        } <br> <br>                    if (IsDlgButtonChecked(hDlg, IDD_Freq11kHz)) <br>                        dwFrequency = 11025 ; <br>                    else <br>                        if (IsDlgButtonChecked(hDlg, IDD_Freq22kHz)) <br>                            dwFrequency = 22050 ; <br>                        else <br>                            if (IsDlgButtonChecked(hDlg, IDD_Freq44kHz)) <br>                                dwFrequency = 44100 ; <br>                            else { <br>                                MessageBeep(MB_ICONEXCLAMATION) ; <br>                                return FALSE ; <br>                            } <br> <br>                    // All the entries verfied OK -- save them now <br>                    glpwfex-&gt;nChannels = nChannels ; <br>                    glpwfex-&gt;wBitsPerSample = wSample ; <br>                    glpwfex-&gt;nSamplesPerSec = dwFrequency ; <br>                    glpwfex-&gt;nBlockAlign =  glpwfex-&gt;nChannels * (glpwfex-&gt;wBitsPerSample / 8) ; <br>                    glpwfex-&gt;nAvgBytesPerSec = (long) glpwfex-&gt;nSamplesPerSec * <br>                                                      glpwfex-&gt;nBlockAlign ; <br>                    glpwfex-&gt;cbSize = 0 ; <br>                    glpwfex-&gt;wFormatTag = WAVE_FORMAT_PCM ; <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br>} <br> <br>#endif // ! USE_ACM <br> <br>// <br>// AllocCapFileProc: Capture file Space Allocation Dialog Box Procedure <br>// <br>int FAR PASCAL AllocCapFileProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    static int      nFreeMBs = 0 ; <br> <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>        { <br>            int              fh ; <br>            long             lFileSize = 0 ; <br>            long             lFreeSpaceInKB ; <br>            TCHAR     achCapFile[_MAX_PATH] ; <br> <br>            // Get current capture file name and measure its size <br>            capFileGetCaptureFile(ghWndCap, achCapFile, sizeof(achCapFile) / sizeof(TCHAR)) ; <br>            if ((fh = _open(achCapFile, _O_RDONLY)) != -1) { <br>                if ((lFileSize = _lseek(fh, 0L, SEEK_END)) == -1L) { <br>                    MessageBoxID(IDS_ERR_SIZECAPFILE, <br>                    MB_OK | MB_ICONEXCLAMATION) ; <br>                    lFileSize = 0 ; <br>                } <br>                _close(fh) ; <br>            } <br> <br>            // Get free disk space and add current capture file size to that. </code></pre>
<p>
</p>
<pre><code>// Convert the available space to MBs. <br>            if ((lFreeSpaceInKB = GetFreeDiskSpaceInKB(achCapFile)) != -1L) { <br>                lFreeSpaceInKB += lFileSize / 1024 ; <br>                nFreeMBs = lFreeSpaceInKB / 1024 ; <br>                SetDlgItemInt(hDlg, IDD_SetCapFileFree, nFreeMBs, TRUE) ; <br>            } else { <br> <br>                EnableWindow(GetDlgItem(hDlg, IDD_SetCapFileFree), FALSE); <br> <br>            } <br> <br>            gwCapFileSize = (WORD) (lFileSize / ONEMEG); <br> <br>            SetDlgItemInt(hDlg, IDD_SetCapFileSize, gwCapFileSize, TRUE) ; <br>            return TRUE ; <br>        } <br> <br>        case WM_COMMAND : <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK : <br>                { <br>                    int         iCapFileSize ; <br> <br>                    iCapFileSize = (int) GetDlgItemInt(hDlg, IDD_SetCapFileSize, NULL, TRUE) ; <br>                    if (iCapFileSize &lt;= 0 || iCapFileSize &gt; nFreeMBs) { <br>                        // You are asking for more than we have !! Sorry, ... <br>                        SetDlgItemInt(hDlg, IDD_SetCapFileSize, iCapFileSize, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_SetCapFileSize)) ; <br>                        MessageBeep(MB_ICONEXCLAMATION) ; <br>                        return FALSE ; <br>                    } <br>                    gwCapFileSize = iCapFileSize ; <br> <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br>                } <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br> <br>                case IDD_SetCapFileSize: <br>                { <br>                    long l; <br>                    BOOL bchanged; <br>                    char achBuffer[21]; <br> <br>                    // check that entered size is a valid number <br>                    GetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer, sizeof(achBuffer)); <br>                    l = atol(achBuffer); <br>                    bchanged = FALSE; <br>                    if (l &lt; 1) { <br>                        l = 1; <br>                        bchanged = TRUE; <br>                    } else if (l &gt; nFreeMBs) { <br>                        l = nFreeMBs; <br>                        bchanged = TRUE; <br>                    } else { <br>                        // make sure there are no non-digit chars <br>                        // atol() will ignore trailing non-digit characters <br>                        int c = 0; <br>                        while (achBuffer[c]) { <br>                            if (IsCharAlpha(achBuffer[c]) || <br>                                !IsCharAlphaNumeric(achBuffer[c])) { <br> <br>                                // string contains non-digit chars - reset <br>                                l = 1; <br>                                bchanged = TRUE; <br>                                break; <br>                            } <br>                            c++; <br>                        } <br>                    } <br>                    if (bchanged) { <br>                        wsprintf(achBuffer, "%ld", l); <br>                        SetDlgItemText(hDlg, IDD_SetCapFileSize, achBuffer); <br>                    } <br>                    break; <br>                } <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br> <br>} <br> <br>#if 0 <br>// <br>// MakePaletteProc: Palette Details Dialog Box Procedure <br>// <br>BOOL CALLBACK MakePaletteProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>            SetDlgItemInt(hDlg, IDD_MakePalColors, gwPalColors, FALSE) ; <br>            SetDlgItemInt(hDlg, IDD_MakePalFrames, gwPalFrames, FALSE) ; <br>            return TRUE ; <br> <br>        case WM_COMMAND : <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDOK : <br>                { <br>                    int         iColors ; <br>                    int         iFrames ; <br> <br>                    iColors = (int) GetDlgItemInt(hDlg, IDD_MakePalColors, NULL, TRUE) ; <br>                    if (! (iColors &gt; 0 &amp;&amp; iColors &lt;= 236 || iColors == 256)) { <br>                        // invalid number of palette colors <br>                        SetDlgItemInt(hDlg, IDD_MakePalColors, iColors, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_MakePalColors)) ; <br>                        MessageBeep(MB_ICONEXCLAMATION) ; <br>                        return FALSE ; <br>                    } <br>                    iFrames = (int) GetDlgItemInt(hDlg, IDD_MakePalFrames, NULL, TRUE) ; <br>                    if (iFrames &lt;= 0 || iFrames &gt; 10000) { <br>                        // no frame or way t-o-o many frames !!! <br>                        SetDlgItemInt(hDlg, IDD_MakePalFrames, iFrames, TRUE) ; <br>                        SetFocus(GetDlgItem(hDlg, IDD_MakePalFrames)) ; <br>                        MessageBeep(MB_ICONEXCLAMATION) ; <br>                        return FALSE ; <br>                    } <br>                    gwPalColors = iColors ; <br>                    gwPalFrames = iFrames ; <br> <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br>                } <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br>    } <br> <br>    return FALSE ; <br> <br>} <br> <br>#endif <br> <br> <br>#define CAPPAL_TIMER    902     <br>#define CAPTIMER_DELAY  100       // get timers as fast as possible <br>// <br>// MakePaletteProc: Palette Details Dialog Box Procedure <br>// <br>static int      siNumColors = 256; <br> <br>BOOL CALLBACK MakePaletteProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    static UINT shTimer; <br>    static int  siNumFrames; <br>    UINT        w; <br>    char        ach[40]; <br>    char        achFormat[40]; <br>    int         i, k; <br> <br>    switch(msg) { <br>        case WM_INITDIALOG: <br>            siNumFrames = 0; <br>            SetDlgItemInt(hwnd, IDD_MakePalColors, siNumColors, FALSE); <br>            SmartWindowPosition (hwnd, ghWndCap); <br>            return TRUE; <br>            break; <br> <br>        case WM_VSCROLL: <br>            /* now handle the scroll */ <br>            i = GetDlgItemInt(hwnd, IDD_MakePalColors, NULL, FALSE); <br>            ArrowEditChange(GetDlgItem(hwnd, IDD_MakePalColors), <br>                GET_WM_VSCROLL_CODE(wParam, lParam), 2, 256); <br>            k = GetDlgItemInt(hwnd, IDD_MakePalColors, NULL, FALSE); <br>            // Jump over the range 237 to 255 <br>            if (k &gt; 236 &amp;&amp; k &lt; 256) { <br>                if (k &gt; i)  <br>                   w = 256; <br>                else <br>                   w = 236; <br>                SetDlgItemInt (hwnd, IDD_MakePalColors, w, TRUE); <br>            } <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDCANCEL: <br>                    if (siNumFrames) { <br>                        // The following finishes building the new palette <br>                        capPaletteManual (ghWndCap, FALSE, siNumColors); <br>                    } <br> <br>                    if (shTimer){ <br>                        KillTimer(hwnd, CAPPAL_TIMER); <br>                        shTimer = 0; <br>                    } <br>                    siNumColors = GetDlgItemInt(hwnd, IDD_MakePalColors, (BOOL FAR *)ach, FALSE); <br>                    siNumColors = max (2, min (256, siNumColors));  <br>                    EndDialog(hwnd, siNumFrames); <br>                    break; <br>                     <br>                case IDD_MakePalStart: <br>                    /* see if we are in START or STOP mode at   */ <br>                    /* this time and handle each one.           */ <br>                    SetFocus (GetDlgItem (hwnd, IDD_MakePalStart)); <br>                    if (!siNumFrames){ <br>                        /* this is the first frame, change the CANCEL */ <br>                        /* button to CLOSE                              */ <br>                        LoadString(ghInstApp, IDS_CAPPAL_CLOSE, ach, sizeof(ach)); <br>                        SetDlgItemText(hwnd, IDCANCEL, ach); <br>                    } <br>                    if (!shTimer) { <br> <br>                        shTimer = SetTimer(hwnd, CAPPAL_TIMER, CAPTIMER_DELAY, NULL); <br> <br>                        if (shTimer == 0) { <br>                            //!!!error message here. <br>                            MessageBeep(0); <br>                            return TRUE; <br>                        } <br> <br>                        /* button said START, let's set up to   */ <br>                        /* do continuous capture.  This involves*/ <br>                        /*   1 - disabling FRAME button         */ <br>                        /*   2 - turning myself to STOP button  */ <br>                        /*   3 - setting up frame timer         */ <br>                        EnableWindow(GetDlgItem(hwnd, IDD_MakePalSingleFrame), FALSE); <br>                        LoadString(ghInstApp, IDS_CAPPAL_STOP, ach, sizeof(ach)); <br>                        SetDlgItemText(hwnd, IDD_MakePalStart, ach); <br>                    } else { <br>                        /* button said STOP, turn things around */ <br>                        /* by:                                  */ <br>                        /*   1 - killing off timers             * <br>                        /*   2 - turning back into START button */ <br>                        /*   3 - re-enabling FRAME button       */ <br>                        // "&amp;Start" <br>                        LoadString(ghInstApp, IDS_CAPPAL_START, ach, sizeof(ach)); <br>                        SetDlgItemText(hwnd, IDD_MakePalStart, ach); <br>                        EnableWindow(GetDlgItem(hwnd, IDD_MakePalSingleFrame), TRUE); <br>                        KillTimer(hwnd, CAPPAL_TIMER); <br>                        shTimer = 0; <br>                    } <br>                    return TRUE; <br>                    break; <br>                     <br>                case IDD_MakePalSingleFrame: <br>                    if (!siNumFrames){ <br>                        /* this is the first frame, change the CANCEL */ <br>                        /* button to CLOSE                              */ <br>                        LoadString(ghInstApp, IDS_CAPPAL_CLOSE, ach, sizeof(ach)); <br>                        SetDlgItemText(hwnd, IDCANCEL, ach); <br>                        siNumColors = GetDlgItemInt(hwnd, IDD_MakePalColors, (BOOL FAR *)ach, FALSE); <br>                        siNumColors = max (2, min (256, siNumColors));  <br>                    } <br>                    // Get the palette for a single frame <br>                    capPaletteManual (ghWndCap, TRUE, siNumColors); <br> <br>                    siNumFrames++; <br>                    LoadString(ghInstApp, IDS_CAPPAL_STATUS, achFormat, sizeof(achFormat)); <br>                    wsprintf(ach, achFormat, siNumFrames); <br>                    SetDlgItemText(hwnd, IDD_MakePalNumFrames, ach); <br>                    return TRUE; <br>                    break; <br> <br>                case IDD_MakePalColors: <br>                    if (HIWORD (lParam) == EN_KILLFOCUS) { <br>                        w = GetDlgItemInt (hwnd, wParam, NULL, FALSE); <br>                        if ( w &lt; 2) { <br>                            MessageBeep (0); <br>                            SetDlgItemInt (hwnd, wParam, 2, FALSE); <br>                        } <br>                        else if (w &gt; 256) { <br>                            MessageBeep (0); <br>                            SetDlgItemInt (hwnd, wParam, 256, FALSE); <br>                        } <br>                    } <br>                    return TRUE; <br>                    break; <br> <br>                default: <br>                    return FALSE; <br>                     <br>            } // switch(wParam) on WM_COMMAND  <br>            break; <br>             <br>        case WM_TIMER: <br>            if (wParam == CAPPAL_TIMER){ <br>                SendMessage(hwnd, WM_COMMAND, IDD_MakePalSingleFrame, 0L); <br>            } <br>            break; <br>        default: <br>            return FALSE; <br>             <br>    } // switch(msg) <br>    return FALSE; <br>} <br> <br> <br> <br> <br>// <br>// CapSetUpProc: Capture SetUp Details Dialog Box Procedure <br>// <br>int FAR PASCAL CapSetUpProc(HWND hDlg, UINT Message, UINT wParam, LONG lParam) <br>{ <br>    static char     achBuffer[21] ; <br>    UINT fValue; <br> <br>    switch (Message) { <br>        case WM_INITDIALOG : <br>        { <br> <br>            // Convert from MicroSecPerFrame to FPS -- that's easier !! <br>            MicroSecToStringRate(achBuffer, gCapParms.dwRequestMicroSecPerFrame); <br>            SetDlgItemText(hDlg, IDD_FrameRateData, achBuffer); <br> <br> <br>            // If time limit isn't enabled, disable the time data part <br>            CheckDlgButton(hDlg, IDD_TimeLimitFlag, (fValue = gCapParms.fLimitEnabled)) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_SecondsText), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_SecondsData), fValue) ; <br>            EnableWindow(GetDlgItem(hDlg, IDD_SecondsArrow), fValue); <br> <br>            SetDlgItemInt(hDlg, IDD_SecondsData, gCapParms.wTimeLimit, FALSE) ; <br> <br> <br>            // disable audio buttons if no audio hardware <br>            { <br>                CAPSTATUS cs; <br> <br>                capGetStatus(ghWndCap, &amp;cs, sizeof(cs)); <br>                EnableWindow(GetDlgItem(hDlg, IDD_CapAudioFlag), cs.fAudioHardware); <br>                EnableWindow(GetDlgItem(hDlg, IDD_AudioConfig), cs.fAudioHardware); <br> <br>                CheckDlgButton(hDlg, IDD_CapAudioFlag, gCapParms.fCaptureAudio); <br>            } <br> <br> <br> <br>            /* <br>             * Capture To Memory means allocate as many memory buffers <br>             *  as possible. <br>             * Capture To Disk means only allocate enough buffers <br>             *  to get us through disk seeks and thermal recalibrations. <br>             */ <br> <br>            // The use of fUsingDOSMemory is now just a means of keeping <br>            // track of whether using lots of buffers.  We never actually <br>            // allocate exclusively from memory under 1Meg. <br> <br>            CheckRadioButton(hDlg, IDD_CaptureToDisk, IDD_CaptureToMemory, <br>              (gCapParms.fUsingDOSMemory)? IDD_CaptureToDisk : IDD_CaptureToMemory); <br> <br>            // Find out how many MCI devices can source video <br>            if (CountMCIDevices(MCI_DEVTYPE_VCR) + <br>                CountMCIDevices(MCI_DEVTYPE_VIDEODISC) == 0) { <br>                // if no VCRs or Videodiscs, disable the controls <br>                EnableWindow(GetDlgItem(hDlg, IDD_MCIControlFlag), FALSE); <br>                EnableWindow(GetDlgItem(hDlg, IDD_MCISetup), FALSE); <br>            } else { <br>                EnableWindow(GetDlgItem(hDlg, IDD_MCIControlFlag), TRUE); <br> <br>                // if MCI Control is selected, enable the setup button <br>                CheckDlgButton(hDlg, IDD_MCIControlFlag, <br>                    gCapParms.fMCIControl); <br>                EnableWindow(GetDlgItem(hDlg, IDD_MCISetup), gCapParms.fMCIControl); <br>            } <br> <br>            // place the dialog to avoid covering the capture window <br>            SmartWindowPosition(hDlg, ghWndCap); <br>            return TRUE ; <br>        } <br> <br>        case WM_COMMAND : <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>                case IDD_TimeLimitFlag : <br>                    // If this flag changes, en/dis-able time limit data part <br>                    fValue = IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsText), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsData), fValue) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_SecondsArrow), fValue); <br>                    return TRUE ; <br> <br>                case IDD_MCIControlFlag : <br>                    // If this flag changes, en/dis-able MCI Setup button <br>                    fValue = IsDlgButtonChecked(hDlg, IDD_MCIControlFlag) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_MCISetup), fValue) ; <br>                    return TRUE ; <br> <br>                case IDD_CapAudioFlag: <br>                    fValue = IsDlgButtonChecked(hDlg, IDD_CapAudioFlag) ; <br>                    EnableWindow(GetDlgItem(hDlg, IDD_AudioConfig), fValue) ; <br>                    return TRUE ; <br> <br> <br>                case IDD_FrameRateData: <br>                    // get the requested frame rate and check it against bounds <br>                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) { <br>                        long l, new_l; <br> <br>                        GetDlgItemText(hDlg, IDD_FrameRateData, achBuffer, sizeof(achBuffer)); <br>                        new_l = l = StringRateToMicroSec(achBuffer); <br> <br>                        // note that the MAX rate is SMALL! hence &lt;max, &gt;min <br>                        if (l == 0) { <br>                            new_l = DEF_CAPTURE_RATE; <br>                        } else if (l &lt; MAX_CAPTURE_RATE) { <br>                            new_l = MAX_CAPTURE_RATE; <br>                        } else if (l &gt; MIN_CAPTURE_RATE) { <br>                            new_l = MIN_CAPTURE_RATE; <br>                        } <br>                        if (l != new_l) { <br>                            MicroSecToStringRate(achBuffer, new_l); <br>                            SetDlgItemText(hDlg, IDD_FrameRateData, achBuffer); <br>                        } <br>                    } <br>                    break; <br> <br>                case IDD_SecondsData: <br>                { <br>                    long l, new_l; <br> <br>                    // get requested time limit and check validity <br>                    GetDlgItemText(hDlg, IDD_SecondsData, achBuffer, sizeof(achBuffer)); <br>                    new_l = l = atol(achBuffer); <br>                    if (l &lt; 1) { <br>                        new_l = 1; <br>                    } else if (l &gt; 9999) { <br>                        new_l = 9999; <br>                    } else { <br>                        // make sure there are no non-digit chars <br>                        // atol() will ignore trailing non-digit characters <br>                        int c = 0; <br>                        while (achBuffer[c]) { <br>                            if (IsCharAlpha(achBuffer[c]) || <br>                                !IsCharAlphaNumeric(achBuffer[c])) { <br> <br>                                // string contains non-digit chars - reset <br>                                new_l = 1; <br>                                break; <br>                            } <br>                            c++; <br>                        } <br>                    } <br>                    if (new_l != l) { <br>                        wsprintf(achBuffer, "%ld", new_l); <br>                        SetDlgItemText(hDlg, IDD_SecondsData, achBuffer); <br>                    } <br>                    break; <br>                } <br> <br>                // show audio format setup dialog <br>                case IDD_AudioConfig: <br> <br>                    // rather than duplicate lots of code from the <br>                    // main vidcap winproc, lets just ask it to show the dlg... <br>                    SendMessage(ghWndMain, WM_COMMAND, <br>                            GET_WM_COMMAND_MPS(IDM_O_AUDIOFORMAT, NULL, 0)); <br> <br>                    break; <br> <br> <br>                // show MCI step control dialog <br>                case IDD_MCISetup: <br>                    DoDialog(hDlg, IDD_MCISETUP, MCISetupProc, 0); <br>                    break; <br> <br>                // show video format setup dialog <br>                case IDD_VideoConfig: <br>                    // rather than duplicate lots of code from the <br>                    // main vidcap winproc, lets just ask it to show the dlg... <br>                    SendMessage(ghWndMain, WM_COMMAND, <br>                            GET_WM_COMMAND_MPS(IDM_O_VIDEOFORMAT, NULL, 0)); <br>                    break; <br> <br>                // show the compressor selector dialog <br>                case IDD_CompConfig: <br>                    capDlgVideoCompression(ghWndCap); <br>                    break; <br> <br> <br> <br>                case IDOK : <br>                { <br> <br>                    gCapParms.fCaptureAudio = <br>                                IsDlgButtonChecked(hDlg, IDD_CapAudioFlag) ; <br>                    gCapParms.fMCIControl = <br>                            IsDlgButtonChecked(hDlg, IDD_MCIControlFlag); <br>                    gCapParms.fLimitEnabled = IsDlgButtonChecked(hDlg, IDD_TimeLimitFlag) ; <br> <br>                    GetDlgItemText(hDlg, IDD_FrameRateData, achBuffer, sizeof(achBuffer)); <br>                    gCapParms.dwRequestMicroSecPerFrame = StringRateToMicroSec(achBuffer); <br>                    if (gCapParms.dwRequestMicroSecPerFrame == 0) { <br>                        gCapParms.dwRequestMicroSecPerFrame = DEF_CAPTURE_RATE; <br>                    } <br> <br>                    GetDlgItemText(hDlg, IDD_SecondsData, achBuffer, sizeof(achBuffer)); <br>                    if (gCapParms.fLimitEnabled) { <br>                         gCapParms.wTimeLimit  = (UINT) atol(achBuffer); <br>                    } <br> <br>                    // fUsingDOSMemory is archaic and is now just a flag reflecting <br>                    // the "CaptureToDisk" selection. <br>                    //  <br>                    gCapParms.fUsingDOSMemory =  <br>                                IsDlgButtonChecked(hDlg, IDD_CaptureToDisk); <br> <br>                    EndDialog(hDlg, TRUE) ; <br>                    return TRUE ; <br>                } <br> <br>                case IDCANCEL : <br>                    EndDialog(hDlg, FALSE) ; <br>                    return TRUE ; <br>            } <br>            break ; <br> <br>        case WM_VSCROLL: <br>        // message from one of the arrow spinbuttons <br>        { <br>            UINT id; <br> <br>            id = GetDlgCtrlID(GET_WM_COMMAND_HWND(wParam, lParam)); <br>            if (id == IDD_FrameRateArrow) { <br>                // format n.nnn <br>                MilliSecVarArrowEditChange( <br>                    GetDlgItem(hDlg, IDD_FrameRateData), <br>                    GET_WM_VSCROLL_CODE(wParam, lParam), <br>                    1, 100, 1); <br>            } else { <br>                // simple integer format <br>                ArrowEditChange( <br>                    GetDlgItem(hDlg, IDD_SecondsData), <br>                    GET_WM_VSCROLL_CODE(wParam, lParam), <br>                    1, 30000); <br>            } <br>            break; <br>        } <br> <br>    } <br> <br>    return FALSE ; <br>} <br> <br>/* <br> * preferences dialog - sets global options about background colour, <br> * presence of toolbar, status bar etc <br> */ <br>int FAR PASCAL <br>PrefsDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    DWORD indexsz; <br> <br>    switch(message) { <br> <br> <br>    case WM_INITDIALOG: <br>        CheckDlgButton(hDlg, IDD_PrefsStatus, gbStatusBar); <br>        CheckDlgButton(hDlg, IDD_PrefsToolbar, gbToolBar); <br>        CheckDlgButton(hDlg, IDD_PrefsCentre, gbCentre); <br>        CheckDlgButton(hDlg, IDD_PrefsSizeFrame, gbAutoSizeFrame); <br>        CheckRadioButton(hDlg, IDD_PrefsDefBackground, IDD_PrefsBlack, gBackColour); <br> <br>        CheckRadioButton(hDlg, IDD_PrefsSmallIndex, IDD_PrefsBigIndex, <br>                    (gCapParms.dwIndexSize == CAP_LARGE_INDEX) ? <br>                    IDD_PrefsBigIndex : IDD_PrefsSmallIndex); <br> <br>        CheckRadioButton(hDlg, IDD_PrefsMasterAudio, IDD_PrefsMasterNone, <br>                    gCapParms.AVStreamMaster + IDD_PrefsMasterAudio); <br> <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br> <br>        case IDOK: <br>            gbStatusBar = IsDlgButtonChecked(hDlg, IDD_PrefsStatus); <br>            gbToolBar = IsDlgButtonChecked(hDlg, IDD_PrefsToolbar); <br>            gbCentre = IsDlgButtonChecked(hDlg, IDD_PrefsCentre); <br>            gbAutoSizeFrame = IsDlgButtonChecked(hDlg, IDD_PrefsSizeFrame); <br> <br>            if (IsDlgButtonChecked(hDlg, IDD_PrefsDefBackground)) { <br>                gBackColour = IDD_PrefsDefBackground; <br>            } else if (IsDlgButtonChecked(hDlg, IDD_PrefsLtGrey)) { <br>                gBackColour = IDD_PrefsLtGrey; <br>            } else if (IsDlgButtonChecked(hDlg, IDD_PrefsDkGrey)) { <br>                gBackColour = IDD_PrefsDkGrey; <br>            } else { <br>                gBackColour = IDD_PrefsBlack; <br>            } <br> <br>            if (IsDlgButtonChecked(hDlg, IDD_PrefsSmallIndex)) { <br>                indexsz = CAP_SMALL_INDEX; <br> <br>            } else { <br>                indexsz = CAP_LARGE_INDEX; <br>            } <br>            if (indexsz != gCapParms.dwIndexSize) { <br>                gCapParms.dwIndexSize = indexsz; <br>            } <br> <br>            if (IsDlgButtonChecked(hDlg, IDD_PrefsMasterAudio)) { <br>                gCapParms.AVStreamMaster = AVSTREAMMASTER_AUDIO; <br>            } <br>            else { <br>                gCapParms.AVStreamMaster = AVSTREAMMASTER_NONE; <br>            } <br> <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br> <br>int FAR PASCAL <br>NoHardwareDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HBRUSH hbr; <br> <br>    switch(message) { <br>    case WM_INITDIALOG: <br>        // lParam contains the argument to DialogBoxParam which is the <br>        // reason text <br>        SetDlgItemText(hDlg, IDD_FailReason, (LPSTR) lParam); <br> <br>        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        return TRUE; <br> <br>    case WM_DESTROY: <br>        DeleteObject(hbr); <br> <br>#ifdef _WIN32 <br>    case WM_CTLCOLORSTATIC: <br>#else <br>    case WM_CTLCOLOR: <br>#endif <br>        if (GET_WM_CTLCOLOR_HWND(wParam, lParam, message) == GetDlgItem(hDlg, IDD_FailReason)) { <br> <br>            HDC hdc; <br> <br>            hdc = GET_WM_CTLCOLOR_HDC(wParam, lParam, message); <br> <br>            SetTextColor(hdc, RGB(0xff, 0, 0)); <br>            SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br> <br>            // in order to ensure that the text colour we have chosen for <br>            // this control is used, we need to actually return a brush. <br>            // for win31, we also need to align the brush <br>#ifndef _WIN32 <br>            { <br>                POINT pt; <br> <br>                pt.x = 0; <br>                pt.y = 0; <br>                ClientToScreen(hDlg, &amp;pt); <br>                UnrealizeObject(hbr); <br>                SetBrushOrg(hdc, pt.x, pt.y); <br>            } <br>#endif <br> <br>            return((int) hbr); <br> <br>        } <br>        break; <br> <br>    case WM_COMMAND: <br>        switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br>        case IDOK: <br>            EndDialog(hDlg, TRUE); <br>            return(TRUE); <br>        case IDCANCEL: <br>            EndDialog(hDlg, FALSE); <br>            return(TRUE); <br>        } <br>        break; <br>    } <br> <br>    return(FALSE); <br>} <br> <br> <br>//capture selected single frames <br>long <br>FAR PASCAL <br>CapFramesProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>    char ach[MAX_PATH*2]; <br>    char achName[MAX_PATH]; <br> <br>    static BOOL bFirst; <br>    static int iFrames; <br> <br>    switch(Message) { <br>    case WM_INITDIALOG: <br> <br>        // write out the prompt message including the capture file name <br>        capFileGetCaptureFile(ghWndCap, achName, sizeof(achName)); <br>        wsprintf(ach, tmpString(IDS_PROMPT_CAPFRAMES), achName); <br>        SetDlgItemText(hDlg, IDD_CapMessage, ach); <br> <br>        bFirst = TRUE; <br> <br>        //move dialog so it doesn't obscure the capture window <br>        SmartWindowPosition(hDlg, ghWndCap); <br> <br>        return(TRUE); <br> <br>    case WM_COMMAND: <br>        switch(GET_WM_COMMAND_ID(wParam, lParam)) { <br> <br>        case IDCANCEL: <br>            if (!bFirst) { <br>                capCaptureSingleFrameClose(ghWndCap); <br>                EndDialog(hDlg, TRUE); <br>            } else { <br>                EndDialog(hDlg, FALSE); <br>            } <br>            return(TRUE); <br> <br>        case IDOK: <br>            if (bFirst) { <br>                bFirst = FALSE; <br>                iFrames = 0; <br>                capCaptureSingleFrameOpen(ghWndCap); <br> <br>                SetDlgItemText(hDlg, IDCANCEL, tmpString(IDS_CAP_CLOSE)); <br> <br>            } <br>            capCaptureSingleFrame(ghWndCap); <br>            iFrames++; <br> <br>            wsprintf(ach, tmpString(IDS_STATUS_NUMFRAMES), iFrames); <br>            SetDlgItemText(hDlg, IDD_CapNumFrames, ach); <br>            return(TRUE); <br> <br>        } <br>        break; <br>    } <br>    return(FALSE); <br>} <br> <br>// enumerate all the MCI devices of a particular type and add them and <br>// their descriptions to a combo box list. <br>// <br>void <br>AddMCIDeviceNames(WORD wDeviceType, HWND hwndCB) <br>{ <br>    int   nIndex; <br>    MCI_OPEN_PARMS mciOp; <br>    MCI_INFO_PARMS mciIp; <br>    MCI_SYSINFO_PARMS mciSIP; <br>    MCI_GENERIC_PARMS mciGp; <br>    char buf[MAXPNAMELEN + 128]; // Contains eg. Name\t\tVideodisc1 <br>    char buf2 [64]; <br>    int maxdevs; <br>    DWORD dwRet; <br> <br>    // To get the user readable names of the devices, we <br>    // must open all appropriate devices, and then get info. <br> <br>    // MCI Open structure <br>    mciOp.dwCallback = 0; <br>    mciOp.lpstrElementName = NULL; <br>    mciOp.lpstrAlias = NULL; <br> <br>    // MCI Info structure <br>    mciIp.dwCallback = 0; <br>    mciIp.lpstrReturn = (LPSTR) buf; <br>    mciIp.dwRetSize = MAXPNAMELEN - 1; <br> <br>    // MCI SysInfo structure <br>    mciSIP.dwCallback = 0; <br>    mciSIP.lpstrReturn = (LPSTR) buf2; <br>    mciSIP.dwRetSize = sizeof (buf2); <br>    mciSIP.wDeviceType = wDeviceType; <br> <br>    // MCI Generic structure <br>    mciGp.dwCallback = 0; <br> <br>    // Load the combobox with the product info name, followed by <br>    // a comma, then a space, and then the mci device name. This allows a <br>    // single alphabetized list to be kept. <br> <br>    // eg. <br>    // Pioneer Laserdisc, videodisc1 <br> <br>    maxdevs = CountMCIDevices((WORD)mciSIP.wDeviceType); <br>    for (nIndex = 0; nIndex &lt; maxdevs; nIndex++) { <br> <br>       // Get the system name eg. Videodisc1 <br>       mciSIP.dwNumber = nIndex + 1; <br>       dwRet = mciSendCommand (0, MCI_SYSINFO, <br>                    MCI_SYSINFO_NAME, <br>                    (DWORD) (LPVOID) &amp;mciSIP); <br> <br>       mciOp.lpstrDeviceType = </code></pre>
<p>
</p>
<pre><code>(LPSTR) MAKELONG (wDeviceType, nIndex); <br> <br>       if (!(dwRet = mciSendCommand(0, MCI_OPEN, <br>                    MCI_WAIT | MCI_OPEN_TYPE | MCI_OPEN_TYPE_ID | <br>                    MCI_OPEN_SHAREABLE, <br>                    (DWORD) (LPVOID) &amp;mciOp))) { <br>            if (!(dwRet = mciSendCommand (mciOp.wDeviceID, MCI_INFO, <br>                            MCI_WAIT | MCI_INFO_PRODUCT, <br>                            (DWORD) (LPVOID) &amp;mciIp))) { <br>                lstrcat (buf, ", ");         // append the delimiter <br>                lstrcat (buf, buf2);         // append the system name <br>                // Whew, finally put it in the listbox <br>                SendMessage( hwndCB, CB_ADDSTRING, 0, <br>                                (LONG)(LPSTR) buf); <br>            } //endif got INFO <br>            // Close it now <br>            mciSendCommand (mciOp.wDeviceID, MCI_CLOSE, <br>                            MCI_WAIT, <br>                            (DWORD) (LPVOID) &amp;mciGp); <br>       } // endif OPEN <br>    } // endif for all devices of this type <br>} <br> <br> <br>// <br>// dialog proc to select MCI device and parameters, including start, <br>// stop times. <br>BOOL FAR PASCAL <br>MCISetupProc(HWND hwnd, unsigned msg, UINT wParam, LONG lParam) <br>{ <br>  HWND  hwndCB; <br>  DWORD dw; <br>  char buf[MAXPNAMELEN]; <br>  BOOL f; <br>  int j; <br>  static int nLastCBIndex = 0; <br>  static DWORD tdwMCIStartTime; <br>  static DWORD tdwMCIStopTime; <br> <br> <br> <br>  switch (msg) { <br>    case WM_INITDIALOG: <br> <br>      CheckRadioButton(hwnd, IDD_MCI_PLAY, IDD_MCI_STEP, <br>    gCapParms.fStepMCIDevice ? <br>                            IDD_MCI_STEP : IDD_MCI_PLAY ); <br> <br>        // enable averaging options only in step mode <br>        EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_2X), gCapParms.fStepMCIDevice); <br>        EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_FR), gCapParms.fStepMCIDevice); <br>SetDlgItemInt(hwnd, IDD_MCI_AVERAGE_FR, gCapParms.wStepCaptureAverageFrames, FALSE); <br>        CheckDlgButton (hwnd, IDD_MCI_AVERAGE_2X, gCapParms.fStepCaptureAt2x); <br> <br>        // save current dialog time settings <br>        tdwMCIStartTime = gCapParms.dwMCIStartTime; <br>        tdwMCIStopTime  = gCapParms.dwMCIStopTime; <br> <br>        TimeMSToHMSString (gCapParms.dwMCIStartTime, buf); <br>        SetDlgItemText (hwnd, IDD_MCI_STARTTIME, buf); <br>        TimeMSToHMSString (gCapParms.dwMCIStopTime, buf); <br>        SetDlgItemText (hwnd, IDD_MCI_STOPTIME, buf); <br> <br> <br>        // fill combo box with list of MCI devices <br>hwndCB = GetDlgItem( hwnd, IDD_MCI_SOURCE ); <br>        AddMCIDeviceNames(MCI_DEVTYPE_VIDEODISC, hwndCB); <br>        AddMCIDeviceNames(MCI_DEVTYPE_VCR, hwndCB); <br> <br> <br>        // set the selection to whatever he chose last time through this dlg <br>        // default is the first entry. <br>       SendMessage( hwndCB, CB_SETCURSEL, nLastCBIndex, 0L); <br>break; <br> <br>    case WM_COMMAND: <br>switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>    case IDOK: <br>                // i think the point of this is to ensure that <br>                // the KILLFOCUS processing for the edit boxes has been done <br>                // and thus the temp times are the same as the dialog text <br>                SetFocus(GET_WM_COMMAND_HWND(wParam, lParam)); <br> <br> <br>                MCIGetDeviceNameAndIndex (hwnd, &amp;nLastCBIndex, gachMCIDeviceName); <br>                capSetMCIDeviceName(ghWndCap, gachMCIDeviceName) ; <br>                gCapParms.fStepMCIDevice = IsDlgButtonChecked (hwnd, IDD_MCI_STEP); <br> <br>                // pick up the temp times - these were set on KILLFOCUS msgs <br>                // (when we did validation and string-&gt;dword conversion <br>                gCapParms.dwMCIStartTime = tdwMCIStartTime; <br>                gCapParms.dwMCIStopTime  = tdwMCIStopTime; <br> <br>                gCapParms.fStepCaptureAt2x = IsDlgButtonChecked (hwnd, IDD_MCI_AVERAGE_2X); <br>                gCapParms.wStepCaptureAverageFrames = GetDlgItemInt (hwnd, IDD_MCI_AVERAGE_FR, NULL, FALSE); <br> <br>EndDialog(hwnd, TRUE); <br>break; <br> <br>    case IDCANCEL: <br>EndDialog(hwnd, 0); <br>break; <br> <br>            case IDD_MCI_STEP: <br>            case IDD_MCI_PLAY: <br>                //averaging only enabled in play mode <br>                f = IsDlgButtonChecked (hwnd, IDD_MCI_STEP); <br>                EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_2X), f); <br>                EnableWindow (GetDlgItem (hwnd, IDD_MCI_AVERAGE_FR), f); <br>                break; <br> <br>            case IDD_MCI_AVERAGE_FR: <br>                // validate the count of frames to average 1..100 <br>                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) { <br>                    j = GetDlgItemInt(hwnd, <br>                            GET_WM_COMMAND_ID(wParam, lParam), NULL, FALSE); <br>                    // Limit frames to average between 1 and 100 <br>                    if (j &lt; 1 || j &gt; 100) { <br>                SetDlgItemInt (hwnd, <br>                            GET_WM_COMMAND_ID(wParam, lParam), 1, FALSE); <br>                    } <br>                } <br>                break; <br> <br>            case IDD_MCI_STARTSET: <br>    case IDD_MCI_STOPSET: <br>                // set the start or stop time to be the time <br>                // on the device right now. <br> <br>                // MCI devices could yield and cause us to re-enter - the <br>                // simplest answer seems to be to disable the dialog <br>                EnableWindow(hwnd, FALSE); <br> <br>                MCIGetDeviceNameAndIndex (hwnd, &amp;nLastCBIndex, buf); <br> <br>                if (MCIDeviceOpen (buf)) { <br>                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDD_MCI_STARTSET) { <br>                        if (MCIDeviceGetPosition (&amp;tdwMCIStartTime)) { <br>                           TimeMSToHMSString (tdwMCIStartTime, buf); <br>                           SetDlgItemText (hwnd, IDD_MCI_STARTTIME, buf); <br>                        } <br>                        else { <br>                            MessageBoxID(IDS_MCI_CONTROL_ERROR, <br>                                        MB_OK|MB_ICONEXCLAMATION); <br>                        } <br>                    } <br>                    else { <br>                        if (MCIDeviceGetPosition (&amp;tdwMCIStopTime)) { <br>                            TimeMSToHMSString (tdwMCIStopTime, buf); <br>                            SetDlgItemText (hwnd, IDD_MCI_STOPTIME, buf); <br>                        } <br>                        else { <br>                            MessageBoxID(IDS_MCI_CONTROL_ERROR, <br>                                        MB_OK|MB_ICONEXCLAMATION); <br>                        } <br>                    } <br>                    MCIDeviceClose (); <br> <br>                } else { <br>                    // cant open device <br>                    MessageBoxID(IDS_MCI_CONTROL_ERROR, <br>                                MB_OK|MB_ICONEXCLAMATION); <br>                } <br>                EnableWindow(hwnd, TRUE); <br>                break; <br> <br> <br>            case IDD_MCI_STARTTIME: <br>            case IDD_MCI_STOPTIME: <br>                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS) { <br>                    GetDlgItemText (hwnd, <br>                        GET_WM_COMMAND_ID(wParam, lParam), buf, sizeof (buf)); <br>                    if ((dw = TimeHMSStringToMS (buf)) == -1) { <br>                        // Error in string, reset <br>                        MessageBeep (0); <br>                        if (GET_WM_COMMAND_ID(wParam, lParam) == IDD_MCI_STARTTIME) <br>                            dw = tdwMCIStartTime; <br>                        else <br>                            dw = tdwMCIStopTime; <br>                    } <br>                    if (GET_WM_COMMAND_ID(wParam, lParam) == IDD_MCI_STARTTIME) { <br>                        tdwMCIStartTime = dw; <br>                        TimeMSToHMSString (tdwMCIStartTime, buf); <br>                        SetDlgItemText (hwnd, IDD_MCI_STARTTIME, buf); <br>                    } <br>                    else { <br>                        tdwMCIStopTime = dw; <br>                        TimeMSToHMSString (tdwMCIStopTime, buf); <br>                        SetDlgItemText (hwnd, IDD_MCI_STOPTIME, buf); <br>                    } <br>                } <br>                break; <br>} <br>break; <br> <br>  } <br>  return FALSE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
