<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RLMETER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3823"></a>RLMETER.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   rlmeter.c: Audio recording level window <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br> <br>/* <br> * This window class acts as a 'VU Meter' showing the current and peak <br> * volume. Set the volume via the WMRL_SETLEVEL message (lParam is new level). <br> * The peak level will be tracked by the control by means of a 2-second timer. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include "rlmeter.h" <br> <br>#ifdef _WIN32 <br>#ifndef EXPORT <br>#define EXPORT <br>#endif <br>#endif <br> <br>LONG FAR PASCAL EXPORT <br>RLMeterProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br> <br>/* <br> * generic window class to support a volume level display. <br> * <br> * The window has a white background, and draws a black filled <br> * rectangle to show the current volume level, and a red line at the <br> * peak. Every two seconds on a timer we lower the peak (we set the <br> * saved peak value to 0 so that at the next update we move the line to <br> * whatever is the current level. <br> * <br> * We store the pen and brush handles and the current and maximum levels <br> * as window words using SetWindowWord on win16 and SetWindowLong on win32. <br> */ <br> <br>// window data layout <br>#define WD_MAX      0                           // current max <br>#define WD_PREVMAX  (WD_MAX + sizeof(UINT))     // currently drawn max <br>#define WD_PREVLVL  (WD_PREVMAX + sizeof(UINT)) // currently drawn level <br> <br>#define WD_PEN      (WD_PREVLVL + sizeof(UINT)) // pen for max line <br> <br>#define WDBYTES     (WD_PEN + sizeof(UINT))     // window bytes to alloc <br> <br>#ifdef _WIN32 <br>#define SetWindowUINT     SetWindowLong <br>#define GetWindowUINT     GetWindowLong <br>#else <br>#define SetWindowUINT     SetWindowWord <br>#define GetWindowUINT     GetWindowWord <br>#endif <br> <br> <br>// call (if first instance) to register class <br>BOOL <br>RLMeter_Register(HINSTANCE hInstance) <br>{ <br>    WNDCLASS cls; <br> <br>    cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>    cls.hIcon          = NULL; <br>    cls.lpszMenuName   = NULL; <br>    cls.lpszClassName  = RLMETERCLASS; <br>    cls.hbrBackground  = GetStockObject(WHITE_BRUSH); <br>    cls.hInstance      = hInstance; <br>    cls.style          = CS_HREDRAW | CS_VREDRAW; <br>    cls.lpfnWndProc    = RLMeterProc; <br>    cls.cbClsExtra     = 0; <br>    cls.cbWndExtra     = WDBYTES; <br> <br>    return RegisterClass(&amp;cls); <br> <br> <br>} <br> <br> <br>LONG FAR PASCAL EXPORT <br>RLMeterProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(message) { <br>    case WM_CREATE: <br>        // init current level and max to 0 <br>        SetWindowUINT(hwnd, WD_MAX, 0); <br>        SetWindowUINT(hwnd, WD_PREVMAX, 0); <br>        SetWindowUINT(hwnd, WD_PREVLVL, 0); <br> <br>        // create a red pen for the max line and store this <br>        SetWindowUINT(hwnd, WD_PEN, <br>                (UINT) CreatePen(PS_SOLID, 2, RGB(255, 0, 0))); <br> <br>        break; <br> <br>    case WM_DESTROY: <br>        // destroy the pen we created <br>        { <br>            HPEN hpen = (HPEN) GetWindowUINT(hwnd, WD_PEN); <br>            if (hpen) { <br>                DeleteObject(hpen); <br>                SetWindowUINT(hwnd, WD_PEN, 0); <br>            } <br> <br>            // also kill the timer we created <br>            KillTimer(hwnd, 0); <br>        } <br>        break; <br> <br>    case WM_PAINT: <br>        /* <br>         * paint the entire control <br>         * <br>         * nb we must paint exactly as it is currently drawn because we <br>         * may be clipped to only part of the control. Thus we must draw <br>         * the max at WD_PREVMAX as it is currently drawn, since WD_MAX <br>         * may have been set to 0 and not yet drawn - in this case, with <br>         * some unfortunate timing and clipping, we would have two max lines. <br>         */ <br>        { <br>            PAINTSTRUCT ps; <br>            HDC hdc; <br>            RECT rc, rcFill; <br>            HPEN hpenOld, hpen; <br> <br>            hdc = BeginPaint(hwnd, &amp;ps); <br> <br>            GetClientRect(hwnd, &amp;rc); <br> <br>            // treat the level as a percentage and fill that much of the <br>            // control with black (from left) <br>            rcFill = rc; <br>            rcFill.right = (rc.right * GetWindowUINT(hwnd, WD_PREVLVL)) / 100; <br>            SetBkColor(hdc, RGB(0,0,0)); <br>            // easy way to fill without creating a brush <br>            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rcFill, NULL, 0, NULL); <br> <br>            // draw the max line <br>            rcFill.right = (rc.right * GetWindowUINT(hwnd, WD_PREVLVL)) / 100; <br>            hpen = (HPEN) GetWindowUINT(hwnd, WD_PEN); <br>            hpenOld = SelectObject(hdc, hpen); <br>            MoveToEx(hdc, rcFill.right, rcFill.top, NULL); <br>            LineTo(hdc, rcFill.right, rcFill.bottom); <br>            SelectObject(hdc, hpenOld); <br> <br>            EndPaint(hwnd, &amp;ps); <br> <br>        } <br>        break; <br> <br>    case WMRL_SETLEVEL: <br>        // set new level, and update the displayed level block and max line <br>        { <br>            RECT rc, rcFill; <br>            UINT uMax, uPrevMax, uPrevLevel, uLevel; <br>            HDC hdc; <br> <br>            // new level is lParam <br>            uLevel = (UINT) lParam; <br> <br>            // fetch other parameters <br>            uMax = GetWindowUINT(hwnd, WD_MAX); <br>            uPrevMax = GetWindowUINT(hwnd, WD_PREVMAX); <br>            uPrevLevel = GetWindowUINT(hwnd, WD_PREVLVL); <br> <br> <br>            // decay the max level. This rate works best if we are called <br>            // to update every 1/20th sec - in this case the decay will be <br>            // 64% in a second. <br>            if (uMax &gt; 0) { <br>                uMax = (uMax * 2007) / 2048;     // = 0.98 * uMax <br>            } <br> <br>            hdc = GetDC(hwnd); <br> <br>            GetClientRect(hwnd, &amp;rc); <br>            rcFill = rc; <br> <br>            // is the current level a new peak ? <br>            if (uLevel &gt; uMax) { <br>                uMax = uLevel; <br>            } <br> <br>            SetWindowUINT(hwnd, WD_MAX, uMax); <br> <br>            // if the max has moved, erase the old line <br>            if (uMax != uPrevMax) { <br>                // white out the line by filling a 2-pixel wide rect <br>                rcFill.right = ((rc.right * uPrevMax) / 100) + 1; <br>                rcFill.left = rcFill.right - 2; <br>                SetBkColor(hdc, RGB(255, 255, 255)); <br>                ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rcFill, NULL, 0, NULL); <br>            } <br> <br>            // calculate the area to update <br>            rcFill.right = (rc.right * uPrevLevel) / 100; <br>            rcFill.left = (rc.right * uLevel) / 100; <br> <br>            // are we erasing (lowering level) or drawing more black? <br>            if (rcFill.right &gt; rcFill.left) { <br> <br>                // level has dropped - so fill with white down to new level <br>                SetBkColor(hdc, RGB(255, 255, 255)); <br>            } else { <br>                // level has gone up so fill with black up to new level <br>                int t; <br> <br>                t = rcFill.right; <br>                rcFill.right = rcFill.left; <br>                rcFill.left = t; <br> <br>                SetBkColor(hdc, RGB(0, 0, 0)); <br> <br>                // fill a little extra to ensure no rounding gaps <br>                if (rcFill.left &gt; 0) { <br>                    rcFill.left -= 1; <br>                } <br>            } <br>            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &amp;rcFill, NULL, 0, NULL); <br>            SetWindowUINT(hwnd, WD_PREVLVL, uLevel); <br> <br>            // draw the new max line if needed <br>            if (uMax != uPrevMax) { <br>                HPEN hpen, hpenOld; <br> <br>                rcFill.right = (rc.right * uMax) /100; <br> <br>                hpen = (HPEN) GetWindowUINT(hwnd, WD_PEN); <br>                hpenOld = SelectObject(hdc, hpen); <br>                MoveToEx(hdc, rcFill.right, rcFill.top, NULL); <br>                LineTo(hdc, rcFill.right, rcFill.bottom); <br>                SelectObject(hdc, hpenOld); <br> <br>                SetWindowUINT(hwnd, WD_PREVMAX, uMax); <br>            } <br>            ReleaseDC(hwnd, hdc); <br>            return(0); <br>        } <br> <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
