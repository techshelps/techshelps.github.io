<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLBAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3827"></a>TOOLBAR.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   toolbar.c: Toolbar control window <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br> <br>#include &lt;string.h&gt; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>//#include &lt;win32.h&gt; <br>#include "toolbar.h"// use this for generic app <br>/************************************************************************/ <br> <br>/* work for win3.0 */ <br>#ifndef COLOR_BTNHIGHLIGHT <br>#define COLOR_BTNHIGHLIGHT 20 <br>#endif <br> <br>charszToolBarClass[] = "ToolBarClass"; <br>HBRUSHghbrToolbar;// brush for toolbar background <br> <br>// <br>// Window proc for buttons, THIS FUNCTION MUST BE EXPORTED <br>// <br>LONG FAR PASCAL toolbarWndProc(HWND, unsigned, UINT, LONG); <br> <br>typedef long (FAR PASCAL *LPWNDPROC)(); <br> <br>/* <br>Defines <br>*/ <br> <br>#ifdef _WIN32 <br> <br>#define GETARRAYBUTT(hwnd)((HANDLE)GetWindowLong(hwnd,GWL_ARRAYBUTT)) <br>#define GETNUMBUTTONS(hwnd)((int)GetWindowLong(hwnd,GWL_NUMBUTTONS)) <br>#define GETPRESSED(hwnd)((BOOL)GetWindowLong(hwnd,GWL_PRESSED)) <br>#define GETKEYPRESSED(hwnd)((BOOL)GetWindowLong(hwnd,GWL_KEYPRESSED)) <br>#define GETWHICH(hwnd)((int)GetWindowLong(hwnd,GWL_WHICH)) <br>#define GETSHIFTED(hwnd)((BOOL)GetWindowLong(hwnd,GWL_SHIFTED)) <br>#define GETBMPHANDLE(hwnd)((HANDLE)GetWindowLong(hwnd,GWL_BMPHANDLE)) <br>#define GETBMPINT(hwnd)((int)GetWindowLong(hwnd,GWL_BMPINT)) <br>#define GETBUTTONSIZE(hwnd)GetWindowLong(hwnd,GWL_BUTTONSIZE) <br>#define GETHINST(hwnd)((HANDLE)GetWindowLong(hwnd,GWL_HINST)) <br> <br> <br>#define SETARRAYBUTT(hwnd, h) SetWindowLong(hwnd, GWL_ARRAYBUTT, (UINT)h) <br>#define SETNUMBUTTONS(hwnd, wNumButtons) \ <br>SetWindowLong(hwnd, GWL_NUMBUTTONS, wNumButtons) <br>#define SETPRESSED(hwnd, f)SetWindowLong(hwnd, GWL_PRESSED, (UINT)f) <br>#define SETKEYPRESSED(hwnd, f)SetWindowLong(hwnd, GWL_KEYPRESSED, (UINT)f) <br>#define SETWHICH(hwnd, i)SetWindowLong(hwnd, GWL_WHICH, (UINT)i) <br>#define SETSHIFTED(hwnd, i)SetWindowLong(hwnd, GWL_SHIFTED, (UINT)i) <br>#define SETBMPHANDLE(hwnd, h)SetWindowLong(hwnd, GWL_BMPHANDLE, (UINT)h) <br>#define SETBMPINT(hwnd, i)SetWindowLong(hwnd, GWL_BMPINT, (UINT)i) <br>#define SETBUTTONSIZE(hwnd, l)SetWindowLong(hwnd, GWL_BUTTONSIZE, l) <br>#define SETHINST(hwnd, h)SetWindowLong(hwnd, GWL_HINST, (UINT)h) <br> <br>#else <br> <br>#define GETARRAYBUTT(hwnd)((HANDLE)GetWindowWord(hwnd,GWW_ARRAYBUTT)) <br>#define GETNUMBUTTONS(hwnd)((int)GetWindowWord(hwnd,GWW_NUMBUTTONS)) <br>#define GETPRESSED(hwnd)((BOOL)GetWindowWord(hwnd,GWW_PRESSED)) <br>#define GETKEYPRESSED(hwnd)((BOOL)GetWindowWord(hwnd,GWW_KEYPRESSED)) <br>#define GETWHICH(hwnd)((int)GetWindowWord(hwnd,GWW_WHICH)) <br>#define GETSHIFTED(hwnd)((BOOL)GetWindowWord(hwnd,GWW_SHIFTED)) <br>#define GETBMPHANDLE(hwnd)((HANDLE)GetWindowWord(hwnd,GWW_BMPHANDLE)) <br>#define GETBMPINT(hwnd)((int)GetWindowWord(hwnd,GWW_BMPINT)) <br>#define GETBUTTONSIZE(hwnd)GetWindowLong(hwnd,GWL_BUTTONSIZE) <br>#define GETHINST(hwnd)((HANDLE)GetWindowWord(hwnd,GWW_HINST)) <br> <br> <br>#define SETARRAYBUTT(hwnd, h) SetWindowWord(hwnd, GWW_ARRAYBUTT, (WORD)h) <br>#define SETNUMBUTTONS(hwnd, wNumButtons) \ <br>SetWindowWord(hwnd, GWW_NUMBUTTONS, wNumButtons) <br>#define SETPRESSED(hwnd, f)SetWindowWord(hwnd, GWW_PRESSED, (WORD)f) <br>#define SETKEYPRESSED(hwnd, f)SetWindowWord(hwnd, GWW_KEYPRESSED, (WORD)f) <br>#define SETWHICH(hwnd, i)SetWindowWord(hwnd, GWW_WHICH, (WORD)i) <br>#define SETSHIFTED(hwnd, i)SetWindowWord(hwnd, GWW_SHIFTED, (WORD)i) <br>#define SETBMPHANDLE(hwnd, h)SetWindowWord(hwnd, GWW_BMPHANDLE, (WORD)h) <br>#define SETBMPINT(hwnd, i)SetWindowWord(hwnd, GWW_BMPINT, (WORD)i) <br>#define SETBUTTONSIZE(hwnd, l)SetWindowLong(hwnd, GWL_BUTTONSIZE, l) <br>#define SETHINST(hwnd, h)SetWindowWord(hwnd, GWW_HINST, (WORD)h) <br> <br>#endif <br> <br>#define lpCreate ((LPCREATESTRUCT)lParam) <br> <br>/* Prototypes */ <br> <br>static void NEAR PASCAL NotifyParent(HWND, int); <br> <br> <br> <br>/************************************************************************** <br>toolbarInit( hInst, hPrev ) <br> <br>Call this routine to initialize the toolbar code. <br> <br>Arguments: <br>hPrevinstance handle of previous instance <br>hInstinstance handle of current instance <br> <br>Returns: <br>TRUE if successful, FALSE if not <br>***************************************************************************/ <br> <br>BOOL FAR PASCAL toolbarInit(HANDLE hInst, HANDLE hPrev) <br>{ <br>WNDCLASScls; <br> <br>/* Register the tool bar window class */ <br>if (!hPrev) { <br> <br>    cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>    cls.hIcon          = NULL; <br>    cls.lpszMenuName   = NULL; <br>    cls.lpszClassName  = (LPSTR)szToolBarClass; <br>    cls.hbrBackground  = (HBRUSH)(COLOR_BTNFACE + 1); <br>    cls.hInstance      = hInst; <br>    cls.style          = CS_DBLCLKS; <br>    cls.lpfnWndProc    = toolbarWndProc; <br>    cls.cbClsExtra     = 0; <br>    cls.cbWndExtra     = TOOLBAR_EXTRABYTES; <br>    if (!RegisterClass(&amp;cls)) <br>return FALSE; <br>} <br> <br>return TRUE; <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarSetBitmap:  takes a resource ID and associates that bitmap with  */ <br>/*                    a given toolbar.  Also takes the instance handle and */ <br>/*                    the size of the buttons on the toolbar.              */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarSetBitmap(HWND hwnd, HANDLE hInst, int ibmp, POINT ptSize) <br>{ <br>SETHINST(hwnd, hInst); <br>SETBMPHANDLE(hwnd, NULL); <br>SETBMPINT(hwnd, ibmp); <br>SETBUTTONSIZE(hwnd, MAKELONG(ptSize.y, ptSize.x)); <br>return (BOOL)SendMessage(hwnd, WM_SYSCOLORCHANGE, 0, 0L); // do the work <br>} <br> <br>/***************************************************************************/ <br>/* toolbarGetNumButtons:  return the number of buttons registered on a     */ <br>/*                        given toolbar window.                            */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarGetNumButtons(HWND hwnd) <br>{ <br>    return GETNUMBUTTONS(hwnd); <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarButtonFromIndex:  Given an index into the array of buttons on    */ <br>/*                          this toolbar, return which button is there.    */ <br>/*                          Returns -1 for an error code.                  */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarButtonFromIndex(HWND hwnd, int iBtnPos) <br>{ <br>intiButton; <br>HANDLEh; <br>TOOLBUTTONfar *lpaButtons; <br> <br>/* Get the array of buttons on this toolbar */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br> <br>/* Validate the index passed in */ <br>if (iBtnPos &gt; GETNUMBUTTONS(hwnd) || iBtnPos &lt; 0) <br>return -1; <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Read off the answer */ <br>iButton = lpaButtons[iBtnPos].iButton; <br> <br>GlobalUnlock(h); <br>return iButton; <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarIndexFromButton:  Given a button ID, return the position in the  */ <br>/*                          array that it appears at.                      */ <br>/*                          Returns -1 for an error code.                  */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarIndexFromButton(HWND hwnd, int iButton) <br>{ <br>inti, iBtnPos = -1; <br>HANDLEh; <br>TOOLBUTTONfar *lpButton; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* loop through until you find it */ <br>for(i = 0; i &lt; GETNUMBUTTONS(hwnd); i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) { <br>iBtnPos = i; <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return iBtnPos; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarPrevStateFromButton:  Given a button ID, return the state that   */ <br>/*                              the button was in before it was pressed    */ <br>/*                              all the way down (for non-push buttons).   */ <br>/*                              Return -1 for an error code.               */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarPrevStateFromButton(HWND hwnd, int iButton) <br>{ <br>inti, iPrevState = -1; <br>HANDLEh; <br>TOOLBUTTONfar *lpButton; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* look for what we need */ <br>for(i = 0; i &lt; GETNUMBUTTONS(hwnd); i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) { <br>iPrevState = lpButton-&gt;iPrevState; <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return iPrevState; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarActivityFromButton:   Given a button ID, return the most recent  */ <br>/*                              activity that happened to it. (eg DBLCLK)  */ <br>/*                              Return -1 for an error code.               */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarActivityFromButton(HWND hwnd, int iButton) <br>{ <br>inti, iActivity = -1; <br>HANDLEh; <br>TOOLBUTTONfar *lpButton; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* loop through until you find it */ <br>for(i = 0; i &lt; GETNUMBUTTONS(hwnd); i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) <br>iActivity = lpButton-&gt;iActivity; <br> <br>GlobalUnlock(h); <br>return iActivity; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarIndexFromPoint:  Given a point in the toolbar window, return the */ <br>/*                         index of the button beneath that point.         */ <br>/*                         Return -1 for an error code.                    */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarIndexFromPoint(HWND hwnd, POINT pt) <br>{ <br>inti, iBtnPos = -1; <br>HANDLEh; <br>TOOLBUTTONfar *lpButton; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* loop through until we find an intersection */ <br>for(i = 0; i &lt; GETNUMBUTTONS(hwnd); i++, lpButton++) <br>if (PtInRect(&amp;lpButton-&gt;rc, pt)) { <br>iBtnPos = i; <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return iBtnPos; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarRectFromIndex:   Given an index into our array of buttons, return*/ <br>/*                         the rect occupied by that button.               */ <br>/*                         Return a NULL rect for an error.                */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarRectFromIndex(HWND hwnd, int iBtnPos, LPRECT lprc) <br>{ <br>HANDLEh; <br>TOOLBUTTONfar *lpaButtons; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>    return FALSE; <br> <br>/* Validate the index passed in */ <br>if (iBtnPos &gt; GETNUMBUTTONS(hwnd) || iBtnPos &lt; 0) <br>    return FALSE; <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Read off the rect */ <br>*lprc = lpaButtons[iBtnPos].rc; <br> <br>GlobalUnlock(h); <br>        return TRUE; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarFullStateFromButton: Given a button in our array of buttons,     */ <br>/*                             return the state of that button.            */ <br>/*                             (including the wierd state FULLDOWN). For   */ <br>/*                             just UP or DOWN or GRAYED,                  */ <br>/*                             call toolbarStateFromButton.   */ <br>/*                             Return -1 for an error.                     */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarFullStateFromButton(HWND hwnd, int iButton) <br>{ <br>intiState, iBtnPos; <br>HANDLEh; <br>TOOLBUTTONfar *lpaButtons; <br> <br>iBtnPos = toolbarIndexFromButton(hwnd, iButton); <br>if (iBtnPos == -1) <br>return -1; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Read off the state */ <br>iState = lpaButtons[iBtnPos].iState; <br> <br>GlobalUnlock(h); <br>return iState; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarStateFromButton: This fn is called by the parent application     */ <br>/*                         to get the state of a button.  It will only     */ <br>/*                         return DOWN, or UP or GRAYED as opposed to      */ <br>/*                         toolbarFullStateFromButton which could return   */ <br>/*                         FULLDOWN.                                       */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarStateFromButton(HWND hwnd, int iButton) <br>{ <br>intiState; <br> <br>/* If a checkbox button is all the way down, it's previous state is */ <br>/* the one we want.    */ <br>if ((iState = toolbarFullStateFromButton(hwnd, iButton)) <br>== BTNST_FULLDOWN) { <br>    iState = toolbarPrevStateFromButton(hwnd, iButton); <br>    return iState; <br>} else <br>    return iState; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarStringFromIndex: Given an index into our array of buttons, return*/ <br>/*                         the string resource associated with it.         */ <br>/*                         Return -1 for an error.                         */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarStringFromIndex(HWND hwnd, int iBtnPos) <br>{ <br>intiString; <br>HANDLEh; <br>TOOLBUTTONfar *lpaButtons; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br> <br>/* Validate the index passed in */ <br>if (iBtnPos &gt; GETNUMBUTTONS(hwnd) || iBtnPos &lt; 0) <br>return -1; <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Read off the ID */ <br>iString = lpaButtons[iBtnPos].iString; <br> <br>GlobalUnlock(h); <br>return iString; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarTypeFromIndex:   Given an index into our array of buttons, return*/ <br>/*                         the type of button it is (PUSH, RADIO, etc.)    */ <br>/*                         Return -1 for an error.                         */ <br>/***************************************************************************/ <br>int FAR PASCAL toolbarTypeFromIndex(HWND hwnd, int iBtnPos) <br>{ <br>intiType; <br>HANDLEh; <br>TOOLBUTTONfar *lpaButtons; <br> <br>/* Get the Array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return -1; <br> <br>/* Validate the index passed in */ <br>if (iBtnPos &gt; GETNUMBUTTONS(hwnd) || iBtnPos &lt; 0) <br>return -1; <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Read off the type */ <br>iType = lpaButtons[iBtnPos].iType; <br> <br>GlobalUnlock(h); <br>return iType; <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarAddTool:  Add a button to this toolbar.  Sort them by leftmost   */ <br>/*                  position in the window (for tabbing order).            */ <br>/*                  Return FALSE for an error.                             */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarAddTool(HWND hwnd, TOOLBUTTON tb) <br>{ <br>HANDLEh; <br>TOOLBUTTON far  *lpaButtons; <br>intcButtons, i, j; <br>BOOLfInsert = FALSE; <br> <br>/* We better not have this button on the toolbar already */ <br>if (toolbarIndexFromButton(hwnd, tb.iButton) != -1) <br>return FALSE; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br> <br>/* How many buttons are there already? */ <br>cButtons = GETNUMBUTTONS(hwnd); <br> <br>/* If we have filled our alloced memory for this array already, we */ <br>/* need to re-alloc some more memory   */ <br>if ( ((cButtons &amp; (TOOLGROW - 1)) == 0) &amp;&amp; (cButtons &gt; 0) ) { <br> <br>/* Re-alloc it bigger */ <br>h = GlobalReAlloc(h, <br>GlobalSize(h) + TOOLGROW * sizeof(TOOLBUTTON), <br>GMEM_MOVEABLE | GMEM_SHARE); <br>if (!h) <br>    return FALSE; <br>} <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Look for the spot we need to insert this new guy at.*/ <br> /* Remember, we sort by left x positionbreaking ties   */ <br> /* with top y position.*/ <br>for (i = 0; i &lt; cButtons; i++) { <br>// Here it goes <br>     if (lpaButtons[i].rc.left &gt; tb.rc.left || <br> (lpaButtons[i].rc.left == tb.rc.left &amp;&amp; <br> lpaButtons[i].rc.top &gt; tb.rc.top)) { <br>fInsert = TRUE; <br>/* Open up a spot in the array */ <br>for (j = cButtons; j &gt; i; j--) <br>    lpaButtons[j] = lpaButtons[j-1]; <br>/* Add our new guy */ <br>lpaButtons[i] = tb;// redraw now <br>InvalidateRect(hwnd, &amp;(lpaButtons[i].rc), FALSE); <br>break; <br>    } <br>} <br> <br>/* If our loop didn't insert it, we need to add it to the end */ <br>if (!fInsert) <br>    lpaButtons[i] = tb; <br> <br>/* If we are told that this button has the focus, we better*/ <br>/* change the focus to it.  Then use the normal state.          */ <br>if (tb.iState == BTNST_FOCUSUP) { <br>    tb.iState = BTNST_UP; <br>    SETWHICH(hwnd, i); <br>} else if (tb.iState == BTNST_FOCUSDOWN || tb.iState == BTNST_FULLDOWN){ <br>    tb.iState = BTNST_DOWN;// nonsense to init to FULLDOWN <br>    SETWHICH(hwnd, i); <br>} <br> <br>cButtons++;// one more button now. <br>GlobalUnlock(h); <br> <br>SETNUMBUTTONS(hwnd, cButtons);// new count <br>SETARRAYBUTT(hwnd, h);// re-alloc might have changed it <br> <br>/* Just in case no one else makes this new button draw */ <br>InvalidateRect(hwnd, &amp;(tb.rc), FALSE); <br> <br>return TRUE; <br>} <br> <br> <br> /***************************************************************************/ <br> /* toolbarRetrieveTool:  Get the TOOLBUTTON struct for the given button.   */ <br> /*                       Return FALSE for an error.                        */ <br> /***************************************************************************/ <br> BOOL FAR PASCAL toolbarRetrieveTool(HWND hwnd, int iButton, LPTOOLBUTTON lptb) <br> { <br> inti; <br> HANDLEh; <br> TOOLBUTTONfar *lpButton; <br> BOOLfFound = FALSE; <br>  <br> /* Get the array of buttons */ <br> h = GETARRAYBUTT(hwnd); <br> if (!h) <br> return FALSE; <br> lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br> /* look for what we need */ <br> for(i = 0; i &lt; GETNUMBUTTONS(hwnd); i++, lpButton++) <br> if (lpButton-&gt;iButton == iButton) { <br> *lptb = *lpButton; <br> fFound = TRUE; <br> break; <br> } <br> <br> GlobalUnlock(h); <br> return fFound; <br> } <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarRemoveTool:  Remove this button ID from our array of buttons on  */ <br>/*                    the toolbar.  (only 1 of each button ID allowed).   */ <br>/*                     Return FALSE for an error.                          */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarRemoveTool(HWND hwnd, int iButton) <br>{ <br>HANDLEh; <br>TOOLBUTTON far  *lpaButtons; <br>intcButtons, i, j; <br>BOOLfFound = FALSE; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br> <br>/* How many buttons are on there now? */ <br>cButtons = GETNUMBUTTONS(hwnd); <br> <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Find a match, remove it, and close the array around it. */ <br>for (i = 0; i &lt; cButtons; i++) <br>if (lpaButtons[i].iButton == iButton) { <br>fFound = TRUE; <br>// redraw now <br>InvalidateRect(hwnd, &amp;(lpaButtons[i].rc), FALSE); <br>if (i != cButtons - 1)// Last button? Don't bother! <br>for (j = i; j &lt; cButtons; j++) <br>lpaButtons[j] = lpaButtons[j + 1]; <br>break; <br>} <br> <br>GlobalUnlock(h); <br> <br>/* Didn't find it! */ <br>if (!fFound) <br>    return FALSE; <br> <br>/* One less button */ <br>cButtons--; <br> <br>/* Every once in a while, re-alloc a smaller array chunk to*/ <br>/* save memory.*/ <br>if ( ((cButtons &amp; (TOOLGROW - 1)) == 0) &amp;&amp; (cButtons &gt; 0) ) { <br> <br>/* Re-alloc it smaller */ <br>h = GlobalReAlloc(h, <br>GlobalSize(h) - TOOLGROW * sizeof(TOOLBUTTON), <br>GMEM_MOVEABLE | GMEM_SHARE); <br>if (!h) <br>    return FALSE; <br>} <br> <br>SETNUMBUTTONS(hwnd, cButtons);// new count <br>SETARRAYBUTT(hwnd, h);// re-alloc could have changed it <br> <br>return TRUE; <br>} <br> <br>/***************************************************************************/ <br>/* toolbarModifyString: Given a button ID on the toolbar, change it's      */ <br>/*                      string resource associated with it.                */ <br>/*                      returns FALSE for an error or if no such button    */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarModifyString(HWND hwnd, int iButton, int iString) <br>{ <br>HANDLEh; <br>TOOLBUTTON far  *lpButton; <br>intcButtons, i; <br>BOOLfFound = FALSE; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br> <br>/* How many buttons? */ <br>cButtons = GETNUMBUTTONS(hwnd); <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Find that button, and change it's state */ <br>for (i = 0; i &lt; cButtons; i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) { <br>lpButton-&gt;iString = iString; <br>fFound = TRUE;// redraw now <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return fFound; <br>} <br> <br>/***************************************************************************/ <br>/* toolbarModifyState:  Given a button ID on the toolbar, change it's      */ <br>/*                      state.                                             */ <br>/*                      returns FALSE for an error or if no such button    */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarModifyState(HWND hwnd, int iButton, int iState) <br>{ <br>HANDLEh; <br>TOOLBUTTON far  *lpButton; <br>intcButtons, i; <br>BOOLfFound = FALSE; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br> <br>/* How many buttons? */ <br>cButtons = GETNUMBUTTONS(hwnd); <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Find that button, and change it's state */ <br>for (i = 0; i &lt; cButtons; i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) { <br>if (lpButton-&gt;iState != iState) { <br>lpButton-&gt;iState = iState; <br>InvalidateRect(hwnd, &amp;(lpButton-&gt;rc), FALSE); <br>} <br>fFound = TRUE;// redraw now <br> <br>/* if we're pushing a radio button down, bring */ <br>/* all others in its group up */ <br>if (lpButton-&gt;iType &gt;= BTNTYPE_RADIO &amp;&amp; <br>iState == BTNST_DOWN) <br>    toolbarExclusiveRadio(hwnd, lpButton-&gt;iType, <br>iButton); <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return fFound; <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarModifyPrevState: Given a button on the toolbar, change it's prev-*/ <br>/*                      ious state. Used for non-PUSH buttons to remember  */ <br>/*                      what state a button was in before pressed all the  */ <br>/*                      way down, so that when you let go, you know what   */ <br>/*                      state to set it to (the opposite of what it was).  */ <br>/*                      returns FALSE for an error (no button array)       */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarModifyPrevState(HWND hwnd, int iButton, int iPrevState) <br>{ <br>HANDLEh; <br>TOOLBUTTON far  *lpButton; <br>intcButtons, i; <br> <br>/* Get button array */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br> <br>/* How many buttons? */ <br>cButtons = GETNUMBUTTONS(hwnd); <br> <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* Find the button, change the state */ <br>for (i = 0; i &lt; cButtons; i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) { <br>lpButton-&gt;iPrevState = iPrevState; <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return TRUE; <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarModifyActivity: Given a button ID on the toolbar, change it's    */ <br>/*                        activity.  This tells the app what just happened */ <br>/*                        to the button (ie. KEYUP, MOUSEDBLCLK, etc.)     */ <br>/*                        returns FALSE for an error or if no such button  */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarModifyActivity(HWND hwnd, int iButton, int iActivity) <br>{ <br>HANDLEh; <br>TOOLBUTTON far  *lpButton; <br>intcButtons, i; <br> <br>/* Get the button array */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br> <br>/* How many buttons */ <br>cButtons = GETNUMBUTTONS(hwnd); <br> <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* loop through and change the right one */ <br>for (i = 0; i &lt; cButtons; i++, lpButton++) <br>if (lpButton-&gt;iButton == iButton) { <br>lpButton-&gt;iActivity = iActivity; <br>break; <br>} <br> <br>GlobalUnlock(h); <br>return TRUE; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarFixFocus:  SETWHICH() has been called to tell us which button    */ <br>/*                   has the focus, but the states of all the buttons are  */ <br>/*                   not updated (ie. take focus away from the old button) */ <br>/*                   This routine is called from the Paint routine to fix  */ <br>/*                   the states of all the buttons before drawing them.    */ <br>/*                   Returns FALSE for an error.                           */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarFixFocus(HWND hwnd) <br>{ <br>intiFocus; <br>HANDLEh; <br>TOOLBUTTONfar *lpaButtons; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br>lpaButtons = (TOOLBUTTON far *)GlobalLock(h); <br> <br>        /* if focus is on an illegal button, default to the first one */ <br>iFocus = GETWHICH(hwnd); <br>if (iFocus &lt; 0 || iFocus &gt;= GETNUMBUTTONS(hwnd)) <br>    SETWHICH(hwnd, 0); <br> <br>/* First of all, make sure that the focus in not on a grayed button. */ <br>/* if so, we advance focus.  If it runs out of buttons without       */ <br>/* finding a non-gray one, we start back at the beginning and start  */ <br>/* looking for a non-gray one from there.  If every button is grayed,*/ <br>/* we leave no focus anywhere.     */ <br>if (lpaButtons[GETWHICH(hwnd)].iState == BTNST_GRAYED) { <br>    if (!toolbarMoveFocus(hwnd, FALSE)) { <br>SETWHICH(hwnd, -1); <br>toolbarMoveFocus(hwnd, FALSE); <br>    } <br>} <br> <br>GlobalUnlock(h); <br>return TRUE; <br>} <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarExclusiveRadio:  For radio buttons, we need to pop all others    */ <br>/*                         in the group up when one goes down.  Pass the   */ <br>/*                         button that is going down, and its group, and   */ <br>/*                         this routine will pop all others up.            */ <br>/*                         Returns FALSE for an error.                     */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarExclusiveRadio(HWND hwnd, int iType, int iButton) <br>{ <br>inti; <br>HANDLEh; <br>TOOLBUTTONfar *lpButton; <br> <br>/* Get the array of buttons */ <br>h = GETARRAYBUTT(hwnd); <br>if (!h) <br>return FALSE; <br>lpButton = (TOOLBUTTON far *)GlobalLock(h); <br> <br>/* all buttons with this type that aren't this button come up*/ <br>/* if they are not grayed*/ <br>for(i = 0; i &lt; GETNUMBUTTONS(hwnd); i++, lpButton++) <br>    if (lpButton-&gt;iType == iType) <br>if (lpButton-&gt;iButton != iButton &amp;&amp; <br>lpButton-&gt;iState != BTNST_GRAYED) { <br>    toolbarModifyState(hwnd, lpButton-&gt;iButton,BTNST_UP); <br>} <br> <br>GlobalUnlock(h); <br>return TRUE; <br>} <br> <br> <br>/*NotifyParent()  of activity to a button  */ <br> <br>static void NEAR PASCAL NotifyParent(HWND hwnd, int iButton) <br>{ <br>#ifdef _WIN32 <br>        PostMessage( <br>            GetParent(hwnd), <br>            WM_COMMAND, <br>            GET_WM_COMMAND_MPS(GetWindowLong(hwnd, GWL_ID), hwnd, iButton)); <br>#else <br>PostMessage(GetParent(hwnd),WM_COMMAND, <br>GetWindowWord(hwnd,GWW_ID),MAKELONG(hwnd,iButton)); <br>#endif <br>} <br> <br> <br>/***************************************************************************/ <br>/* toolbarPaintControl:  Handles paint messages by blitting each bitmap    */ <br>/*                       that is on the toolbar to its rect.               */ <br>/*                       First, it fixes the states of the buttons to give */ <br>/*                       the focus to the proper button.                   */ <br>/*                       Returns FALSE for an error.                       */ <br>/***************************************************************************/ </code></pre>
<p>
</p>
<pre><code>static BOOL NEAR PASCAL toolbarPaintControl(HWND hwnd, HDC hdc) <br>{ <br>    intiBtnPos;/* 0 to toolbarGetNumButtons inclusive*/ <br>    intiButton;/* 0 to NUMBUTTONS-1 inclusive*/ <br>    intiState;/* 0 to NUMSTATES-1 inclusive*/ <br>    HDChdcBtn;/* DC onto button bitmap*/ <br> <br>    RECTrcDest; <br>    POINTpt; <br>    longl; <br>    HANDLEhbm; <br> <br>    /* Make a source HDC for the button pictures, and select the button */ <br>    /* bitmap into it.*/ <br>    hdcBtn = CreateCompatibleDC(hdc); <br>    if (!hdcBtn) <br>return FALSE; <br>    hbm = GETBMPHANDLE(hwnd); <br>    if (hbm) { <br>if (!SelectObject(hdcBtn, GETBMPHANDLE(hwnd))) { <br>    DeleteDC(hdcBtn); <br>    return FALSE; <br>} <br>    } <br> <br>    toolbarFixFocus(hwnd);// set the focus field correctly <br> <br>    /* Go through all buttons on the toolbar */ <br>    for (iBtnPos = 0; iBtnPos &lt; toolbarGetNumButtons(hwnd); iBtnPos++) { <br> <br>iButton = toolbarButtonFromIndex(hwnd, iBtnPos);// button <br>iState = toolbarFullStateFromButton(hwnd, iButton);// state <br>toolbarRectFromIndex(hwnd, iBtnPos, &amp;rcDest);// Dest Rect <br> <br>/* If we have the focus, we should draw it that way */ <br>        if (GetFocus() == hwnd &amp;&amp; GETWHICH(hwnd) == iBtnPos <br>&amp;&amp; iState == BTNST_UP) <br>    iState = BTNST_FOCUSUP; <br>        if (GetFocus() == hwnd &amp;&amp; GETWHICH(hwnd) == iBtnPos <br>&amp;&amp; iState == BTNST_DOWN) <br>    iState = BTNST_FOCUSDOWN; <br> <br>/* If we don't have the focus, we should take it away */ <br>        if ((GetFocus() != hwnd || GETWHICH(hwnd) != iBtnPos) <br>&amp;&amp; iState == BTNST_FOCUSUP) <br>    iState = BTNST_UP; <br>        if ((GetFocus() != hwnd || GETWHICH(hwnd) == iBtnPos) <br>&amp;&amp; iState == BTNST_FOCUSDOWN) <br>    iState = BTNST_DOWN; <br> <br>/* The size of each button */ <br>l = GETBUTTONSIZE(hwnd); <br>pt.x = HIWORD(l); <br>pt.y = LOWORD(l); <br> <br>/* Blit from the button picture to the toolbar window */ <br>BitBlt(hdc, rcDest.left, rcDest.top, <br>    rcDest.right - rcDest.left, rcDest.bottom - rcDest.top, <br>    hdcBtn, pt.x * iButton, pt.y * iState, <br>    SRCCOPY); <br>    } <br> <br>    DeleteDC(hdcBtn); <br> <br>    return TRUE; <br>} <br> <br> <br> <br> <br>/***************************************************************************/ <br>/* toolbarMoveFocus:  Move Focus forward or backward one button.  You give */ <br>/*                    it the direction to move the focus.  The routine will*/ <br>/*                    stop at the end of the button list without wrapping  */ <br>/*                    around.                                              */ <br>/*                    Returns TRUE if focus moved, or FALSE if it ran out  */ <br>/*                    of buttons before finding a non-grayed one.          */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarMoveFocus(HWND hwnd, BOOL fBackward) <br>{ <br>int iBtnPos, iButton, nOffset, nStopAt; <br>RECTrc; <br>int iPrevPos = GETWHICH(hwnd); /* Who used to have focus? */ <br> <br>/* Fix illegal value.  It's OK to be one less or greater than range */ <br>if (iPrevPos &lt; -1 || iPrevPos &gt; GETNUMBUTTONS(hwnd)) <br>    SETWHICH(hwnd, 0);// good a default as any <br> <br>if (fBackward) { <br>    nOffset = -1; <br>    nStopAt = -1; <br>} else { <br>    nOffset = 1; <br>    nStopAt = GETNUMBUTTONS(hwnd); <br>} <br> <br>/* look for next button that isn't grayed    */ <br>/* DON'T wrap around - future code will pass */ <br>/* the focus to another window (???)         */ <br>for (iBtnPos = GETWHICH(hwnd) + nOffset; <br>    iBtnPos != nStopAt; <br>    iBtnPos += nOffset) { <br>    iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>    if (toolbarStateFromButton(hwnd, iButton) != <br>    BTNST_GRAYED) { <br>SETWHICH(hwnd, iBtnPos);// set focus <br> <br>/* Redraw both old and new focused button */ <br>toolbarRectFromIndex(hwnd, iPrevPos, &amp;rc); <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br>toolbarRectFromIndex(hwnd, iBtnPos, &amp;rc); <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br>break; <br> <br>    } <br>} <br> <br>if (GETWHICH(hwnd) != iPrevPos) <br>    return TRUE; <br>else <br>    return FALSE; <br>} <br> <br>/***************************************************************************/ <br>/* toolbarSetFocus :  Set the focus in the toolbar to the specified button.*/ <br>/*                    If it's gray, it'll set focus to next ungrayed btn.  */ <br>/*                    Returns TRUE if focus set, or FALSE if the button    */ <br>/*                    doesn't exist or if it and all buttons after it were */ <br>/*                    grayed...       You can use TB_FIRST or TB_LAST in   */ <br>/*                    place of a button ID.  This uses the first or last   */ <br>/*                    un-grayed button.                                    */ <br>/***************************************************************************/ <br>BOOL FAR PASCAL toolbarSetFocus(HWND hwnd, int iButton) <br>{ <br>    int iBtnPos; <br>    RECT rc; <br> <br>    /* Don't move focus while a button is down */ <br>    if (GetCapture() != hwnd &amp;&amp; !GETKEYPRESSED(hwnd)) { <br> <br>/* redraw button with focus in case focus moves */ <br>toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &amp;rc); <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br> <br>if (iButton == TB_FIRST) { <br>    SETWHICH(hwnd, -1); // move forward to 1st button <br>    return toolbarMoveFocus(hwnd, FALSE); <br>} else if (iButton == TB_LAST) { <br>    SETWHICH(hwnd, GETNUMBUTTONS(hwnd)); <br>    return toolbarMoveFocus(hwnd, TRUE); <br>} else { <br>    iBtnPos = toolbarIndexFromButton(hwnd, iButton); <br>    if (iBtnPos != -1) { <br>SETWHICH(hwnd, --iBtnPos); <br>return toolbarMoveFocus(hwnd, FALSE); <br>    } else <br>return FALSE; <br>} <br>return TRUE; <br> <br>    } else <br>return FALSE; <br>} <br> <br>// <br>//  LoadUIBitmap() - load a bitmap resource <br>// <br>//      load a bitmap resource from a resource file, converting all <br>//      the standard UI colors to the current user specifed ones. <br>// <br>//      this code is designed to load bitmaps used in "gray ui" or <br>//      "toolbar" code. <br>// <br>//      the bitmap must be a 4bpp windows 3.0 DIB, with the standard <br>//      VGA 16 colors. <br>// <br>//      the bitmap must be authored with the following colors <br>// <br>//          Button Text        Black        (index 0) <br>//          Button Face        lt gray      (index 7) <br>//          Button Shadow      gray         (index 8) <br>//          Button Highlight   white        (index 15) <br>//          Window Color       yellow       (index 11) <br>//          Window Frame       green        (index 10) <br>// <br>//      Example: <br>// <br>//          hbm = LoadUIBitmap(hInstance, "TestBmp", <br>//              GetSysColor(COLOR_BTNTEXT), <br>//              GetSysColor(COLOR_BTNFACE), <br>//              GetSysColor(COLOR_BTNSHADOW), <br>//              GetSysColor(COLOR_BTNHIGHLIGHT), <br>//              GetSysColor(COLOR_WINDOW), <br>//              GetSysColor(COLOR_WINDOWFRAME)); <br>// <br>//      Author:     JimBov, ToddLa <br>// <br>// <br> <br>HBITMAP FAR PASCAL  LoadUIBitmap( <br>    HANDLE      hInstance,          // EXE file to load resource from <br>    LPCSTR      szName,             // name of bitmap resource <br>    COLORREF    rgbText,            // color to use for "Button Text" <br>    COLORREF    rgbFace,            // color to use for "Button Face" <br>    COLORREF    rgbShadow,          // color to use for "Button Shadow" <br>    COLORREF    rgbHighlight,       // color to use for "Button Hilight" <br>    COLORREF    rgbWindow,          // color to use for "Window Color" <br>    COLORREF    rgbFrame)           // color to use for "Window Frame" <br>{ <br>    LPBYTE              lpb; <br>    HBITMAP             hbm; <br>    LPBITMAPINFOHEADER  lpbi; <br>    HANDLE              h; <br>    HDC                 hdc; <br>    LPDWORD             lprgb; <br>    int isize; <br>    HANDLE hmem; <br>    LPBYTE lpCopy; <br> <br>    // convert a RGB into a RGBQ <br>    #define RGBQ(dw) RGB(GetBValue(dw),GetGValue(dw),GetRValue(dw)) <br> <br>    h = LoadResource (hInstance,FindResource(hInstance, szName, RT_BITMAP)); <br> <br>    lpbi = (LPBITMAPINFOHEADER)LockResource(h); <br> <br>    if (!lpbi) <br>        return(NULL); <br> <br>    if (lpbi-&gt;biSize != sizeof(BITMAPINFOHEADER)) <br>        return NULL; <br> <br>    if (lpbi-&gt;biBitCount != 4) <br>        return NULL; <br> <br>    /* <br>     * copy the resource since they are now loaded read-only <br>     */ <br>#ifdef _WIN32 <br>    isize = lpbi-&gt;biSize + lpbi-&gt;biSizeImage + <br>            ((int)lpbi-&gt;biClrUsed ? <br>                    (int)lpbi-&gt;biClrUsed : <br>                    (1 &lt;&lt; (int)lpbi-&gt;biBitCount)) <br>            * sizeof(RGBQUAD); <br>    hmem = GlobalAlloc(GHND, isize); <br>    lpCopy = GlobalLock(hmem); <br>    if ((hmem == NULL) || (lpCopy == NULL)) { <br>        UnlockResource(h); <br>        FreeResource(h); <br>        return(NULL); <br>    } <br> <br> <br>    CopyMemory(lpCopy, lpbi, isize); <br>    UnlockResource(h); <br>    FreeResource(h); <br> <br>    lpbi = (LPBITMAPINFOHEADER)lpCopy; <br>#endif <br> <br>    /* Calcluate the pointer to the Bits information */ <br>    /* First skip over the header structure */ <br> <br>    lprgb = (LPDWORD)((LPBYTE)(lpbi) + lpbi-&gt;biSize); <br> <br>    /* Skip the color table entries, if any */ <br>    lpb = (LPBYTE)lprgb + ((int)lpbi-&gt;biClrUsed ? (int)lpbi-&gt;biClrUsed : <br>        (1 &lt;&lt; (int)lpbi-&gt;biBitCount)) * sizeof(RGBQUAD); <br> <br>    lprgb[0]  = RGBQ(rgbText);          // Black <br>    lprgb[7]  = RGBQ(rgbFace);          // lt gray <br>    lprgb[8]  = RGBQ(rgbShadow);        // gray <br>    lprgb[15] = RGBQ(rgbHighlight);     // white <br>    lprgb[11] = RGBQ(rgbWindow);        // yellow <br>    lprgb[10] = RGBQ(rgbFrame);         // green <br> <br>    hdc = GetDC(NULL); <br> <br>    hbm = CreateDIBitmap (hdc, lpbi, CBM_INIT, (LPVOID)lpb, <br>        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS); <br> <br>    ReleaseDC(NULL, hdc); <br>    UnlockResource(h); <br>    FreeResource(h); <br> <br>    return(hbm); <br>} <br> <br>/**************************************************************************** <br>toolbarWndProc() <br> <br>Window proc for toolbar. <br> <br>Arguments: <br>Standard window proc <br>****************************************************************************/ <br> <br>LONG FAR PASCAL toolbarWndProc(HWND hwnd, unsigned message, <br>UINT wParam, LONG lParam) <br>{ <br>    PAINTSTRUCTps; <br>    POINTpt; <br>    RECTrc; <br>    intiBtnPos, iButton, ibmp; <br>    HANDLElpaButtons, hbm, hInst; <br> <br>    switch (message) { <br> <br>        case WM_CREATE:// do all initialization <br> <br>/* What do these do? */ <br>SetWindowPos(hwnd, NULL, 0, 0, 0, 0, <br>    SWP_NOZORDER | SWP_NOSIZE | <br>SWP_NOMOVE | SWP_NOACTIVATE); <br>SetWindowLong(hwnd,GWL_STYLE,lpCreate-&gt;style &amp; 0xFFFF00FF); <br> <br>/* Alloc some space for the array of buttons on this bar */ <br>lpaButtons = GlobalAlloc(GMEM_MOVEABLE | GMEM_SHARE, <br>TOOLGROW * sizeof(TOOLBUTTON)); <br> <br>SETARRAYBUTT(hwnd, lpaButtons);// list of buttons on toolbar <br>SETNUMBUTTONS(hwnd, 0);// # buttons in toolbar <br>SETPRESSED(hwnd, FALSE);// mouse button being pressed? <br>SETKEYPRESSED(hwnd, FALSE);// is a key being pressed? <br>SETWHICH(hwnd, -1);// which button has the focus? <br>SETSHIFTED(hwnd, FALSE);// shift-click or right-click? <br> <br>/* This wParam will be sent to the parent window to indentify */ <br>/* that the toolbar sent the WM_COMMAND msg.  The hwnd of the */ <br>/* toolbar that sent the msg will be in the lParam.      */ <br>#ifdef _WIN32 <br>SetWindowLong(hwnd, GWL_ID, IDC_TOOLBAR); <br>#else <br>SetWindowWord(hwnd, GWW_ID, (WORD)IDC_TOOLBAR); <br>#endif <br> <br>/* later on, someone will set the bmp handle of the buttons */ <br>SETBMPHANDLE(hwnd, NULL); <br> <br>break; <br> <br>        case WM_LBUTTONDOWN:// button goes down on a toolbar button <br>        case WM_RBUTTONDOWN: <br>        case WM_LBUTTONDBLCLK: <br>        case WM_RBUTTONDBLCLK: <br> <br>/* If we don't give ourself focus, we'll never get KEYDOWN */ <br>/* or KEYUP messages.   */ <br>/* Get the focus only if we're a TABSTOP and the app wants */ <br>/* us to take focus.   */ <br>if ( (GetWindowLong(hwnd, GWL_STYLE) &amp; WS_TABSTOP) <br>&amp;&amp; GetFocus() != hwnd) <br>    SetFocus(hwnd); <br> <br>/* ignore messages if window is disabled */ <br>if (!IsWindowEnabled(hwnd)) <br>    return 0L; <br> <br>/* ignore multiple down messages (we set Capture here) */ <br>/* also ignore if a key is down                        */ <br>if (GetCapture() == hwnd || GETPRESSED(hwnd)) <br>    return 0L; <br> <br>/* Where did the mouse go down? */ <br>                pt.x = (short)LOWORD(lParam); <br>                pt.y = (short)HIWORD(lParam); <br> <br>/* which button was pressed? */ <br>iBtnPos = toolbarIndexFromPoint(hwnd, pt); <br> <br>/* If it was a valid button... */ <br>if (iBtnPos &gt;= 0) { <br>    intiOldPos; <br>    intiState, iType, iButton; <br> <br>    /* Everything you wanted to know about this button */ <br>    iType = toolbarTypeFromIndex(hwnd, iBtnPos); <br>    iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>    iState = toolbarFullStateFromButton(hwnd, iButton); <br> <br>    /* ignore downs on a grayed button, unless it's a*/ <br>    /* custom button, then tell them anyway*/ <br>    if (iType != BTNTYPE_CUSTOM &amp;&amp; iState == BTNST_GRAYED) <br>return 0; <br> <br>    /* We better get all mouse messages from now on */ <br>    SetCapture(hwnd); <br> <br>    /* Shift key or right button indicates a SHIFT down */ <br>    SETSHIFTED(hwnd, (message == WM_RBUTTONDOWN) || <br>    (wParam &amp; MK_SHIFT)); <br> <br>    /* Yes, we've pressed the button down */ <br>    SETPRESSED(hwnd, TRUE); <br> <br>    /* Remember who used to have the focus, and we get it now */ <br>    iOldPos = GETWHICH(hwnd); <br>    SETWHICH(hwnd, iBtnPos); <br> <br>    /* For a push button, send it down */ <br>    if (iType == BTNTYPE_PUSH) <br>toolbarModifyState(hwnd, iButton, BTNST_DOWN); <br> <br>    /* for a checkbox or radio button (of any group),       */ <br>    /* remember what state it was in, and send it FULL down */ <br>    /* (with focus).    */ <br>    if (iType == BTNTYPE_CHECKBOX || iType &gt;= BTNTYPE_RADIO) { <br>toolbarModifyPrevState(hwnd, iButton, iState); <br>toolbarModifyState(hwnd,iButton,BTNST_FULLDOWN); <br>    } <br> <br>    toolbarModifyActivity(hwnd, iButton, BTNACT_MOUSEDOWN); <br> <br>    /* Set Double click flag appropriately */ <br>    if (message == WM_LBUTTONDBLCLK || <br>message == WM_RBUTTONDBLCLK) <br>NotifyParent(hwnd, (GETSHIFTED(hwnd) ? BTN_SHIFT : 0) <br> + BTN_DBLCLICK + iButton); <br>    else <br>NotifyParent(hwnd, (GETSHIFTED(hwnd) ? BTN_SHIFT : 0) <br> + iButton); <br> <br>    /* Invalidate the Rect of the button being pressed */ <br>    toolbarRectFromIndex(hwnd, iBtnPos, &amp;rc); <br>    InvalidateRect(hwnd, &amp;rc, FALSE); <br> <br>    /* Invalidate the Rect of the button losing focus */ <br>    toolbarRectFromIndex(hwnd, iOldPos, &amp;rc); <br>    InvalidateRect(hwnd, &amp;rc, FALSE); <br> <br>    /* Force re-paint now */ <br>    UpdateWindow(hwnd); <br> <br>    /* Set a timer for repeated mouse downs */ <br>    SetTimer(hwnd, TIMER_BUTTONREPEAT, <br> MSEC_BUTTONREPEAT, NULL); <br>} <br> <br>return 0L; <br> <br>        case WM_MOUSEMOVE: <br> <br>#if 0 <br>/* This should be impossible - it means that the system lost */ <br>/* a mouse up (maybe codeview is up?) We need to force a     */ <br>/* mouse up at this point.     */ <br>if (GetCapture() == hwnd &amp;&amp; <br>(wParam &amp; (MK_LBUTTON | MK_RBUTTON) == 0)) <br>    SendMessage(hwnd, WM_LBUTTONUP, 0, lParam); <br>#endif <br> <br>/* Mouse moving while pressing a button?  If not, ignore. */ <br>if (GetCapture() == hwnd) { <br>    intiPrevState, iState, iButton, iType; <br>    BOOLfPressed; <br> <br>    /* Which button is being pressed down? */ <br>    iBtnPos = GETWHICH(hwnd); <br> <br>    /* Where is mouse cursor now? */ <br>                    pt.x = (short)LOWORD(lParam); <br>                    pt.y = (short)HIWORD(lParam); <br> <br>    /* where is button being pressed? Are we still on */ <br>    /* top of that button or have we moved?      */ <br>    toolbarRectFromIndex(hwnd, iBtnPos, &amp;rc); <br>    fPressed = PtInRect(&amp;rc, pt); <br> <br>    /* Let go if we move off of the button, but don't */ <br>    /* act like it was pressed.                       */ <br>    /* Also, push it back down if we move back on top */ <br>    /* of it (while the mouse button is STILL down).  */ <br>    if (fPressed != GETPRESSED(hwnd)) { <br> <br>/* update: is this button pressed anymore? */ <br>SETPRESSED(hwnd, fPressed); <br> <br>iType = toolbarTypeFromIndex(hwnd, iBtnPos); <br>iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>iState = toolbarFullStateFromButton(hwnd, iButton); <br> <br>/* The mouse moved back onto the button while */ <br>/* the mouse button was still pressed.      */ <br>if (fPressed) { <br> <br>    /* Push the push button back down again */ <br>     if (iType == BTNTYPE_PUSH) <br>toolbarModifyState(hwnd, iButton, <br>BTNST_DOWN); <br> <br>    /* Push the radio or checkbox button ALL the */ <br>    /* way down again. */ <br>    if (iType &gt;= BTNTYPE_RADIO || <br>iType == BTNTYPE_CHECKBOX) <br>toolbarModifyState(hwnd, iButton, <br>BTNST_FULLDOWN); <br> <br>    toolbarModifyActivity(hwnd, iButton, <br>BTNACT_MOUSEMOVEON); <br>    NotifyParent(hwnd, <br>(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + <br>iButton); <br> <br>/* We moved the mouse off of the toolbar button */ <br>/* while still holding the mouse button down.   */ <br>} else { <br> <br>    /* lift the push button up */ <br>     if (iType == BTNTYPE_PUSH) <br>toolbarModifyState(hwnd, iButton, <br>BTNST_UP); <br> <br>    /* Restore radio button or checkbox button to */ <br>    /* where it was before pressed  */ <br>    if (iType &gt;= BTNTYPE_RADIO || <br>iType == BTNTYPE_CHECKBOX) { <br>iPrevState = toolbarPrevStateFromButton(hwnd, <br>iButton); <br>toolbarModifyState(hwnd, iButton, iPrevState); <br>    } <br> <br>    toolbarModifyActivity(hwnd, iButton, <br>BTNACT_MOUSEMOVEOFF); <br>    NotifyParent(hwnd, <br>(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + <br>toolbarButtonFromIndex(hwnd, iBtnPos)); <br>} <br>    } <br>} <br>return 0L; <br> <br>        case WM_LBUTTONUP: <br>        case WM_RBUTTONUP: <br> <br>/* If we don't have capture, we aren't expecting this. Ignore */ <br>if (GetCapture() == hwnd) { <br>    intiPrevState, iState, iButton, iType; <br> <br>    /* Who has the focus? */ <br>    iBtnPos = GETWHICH(hwnd); <br> <br>    /* Release the mouse */ <br>    ReleaseCapture(); <br> <br>    /* No more repeats of the mouse button downs */ <br>    KillTimer(hwnd, TIMER_BUTTONREPEAT); <br> <br>    /* Everything you wanted to know about the button */ <br>    toolbarRectFromIndex(hwnd, iBtnPos, &amp;rc); <br>    iType = toolbarTypeFromIndex(hwnd, iBtnPos); <br>    iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>    iState = toolbarFullStateFromButton(hwnd, iButton); <br> <br>    /* Don't do anything if we've moved off the button */ <br>    if (GETPRESSED(hwnd)) { <br> <br>/* No longer down */ <br>SETPRESSED(hwnd, FALSE); <br> <br>/* Bring the push button up */ <br>if (iType == BTNTYPE_PUSH) <br>    toolbarModifyState(hwnd, iButton, BTNST_UP); <br> <br>/* Bring the checkbox to the opposite state it was in */ <br>if (iType == BTNTYPE_CHECKBOX) { <br>    iPrevState = toolbarPrevStateFromButton(hwnd, <br>iButton); <br>    if (iPrevState == BTNST_DOWN) <br>toolbarModifyState(hwnd, iButton, BTNST_UP); <br>    if (iPrevState == BTNST_UP) <br>toolbarModifyState(hwnd, iButton, BTNST_DOWN); <br>} <br> <br>/* Force a radio button down, and bring all   */ <br>/* other radio buttons of this type up      */ <br>if (iType &gt;= BTNTYPE_RADIO) { <br>    toolbarModifyState(hwnd, iButton, BTNST_DOWN); <br>    toolbarExclusiveRadio(hwnd, iType, iButton); <br>} <br> <br>/* Notify the parent that the mouse button came up */ <br>/* on this button so the app can do something.     */ <br>/* Every button should notify the app, not just a  */ <br>/* custom button.   */ <br>toolbarModifyActivity(hwnd, iButton, BTNACT_MOUSEUP); <br>NotifyParent(hwnd, <br>    (GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + iButton); <br>    } <br>} <br> <br>return 0L; <br> <br> <br>case WM_TIMER: <br> <br>/* If we have a tool button down, send a repeat message */ <br>if (GETPRESSED(hwnd)) { <br>    intiButton, iType; <br> <br>    iBtnPos = GETWHICH(hwnd); <br>    iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>    iType = toolbarTypeFromIndex(hwnd, iBtnPos); <br> <br>    NotifyParent(hwnd, BTN_REPEAT + <br>(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + <br>toolbarButtonFromIndex(hwnd, iBtnPos)); <br>} <br>break; <br> <br> <br>        case WM_DESTROY: <br>if (GETBMPHANDLE(hwnd)) <br>    DeleteObject(GETBMPHANDLE(hwnd)); <br>SETBMPHANDLE(hwnd, NULL); <br>if (GETARRAYBUTT(hwnd)) <br>    GlobalFree(GETARRAYBUTT(hwnd)); <br>SETARRAYBUTT(hwnd, NULL); <br>break; <br> <br>        case WM_SETTEXT: <br>break; <br> <br>/* MANY, MANY cases deleted */ <br> <br>case WM_SETFOCUS:// focus comes to toolbar window <br>    { <br>/* Remember who had the focus and give it back.  Of course, */ <br>/* if by some wierdness that button is now grayed, give it  */ <br>/* to the next person in line.    */ <br>iBtnPos = GETWHICH(hwnd); <br>if (iBtnPos &lt; 0 || iBtnPos &gt;= toolbarGetNumButtons(hwnd)) { <br>    iBtnPos = 0; <br>    SETWHICH(hwnd, 0); <br>} <br> <br>do { <br>    iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>    if (toolbarFullStateFromButton(hwnd, iButton) <br>!= BTNST_GRAYED) <br>break;// give it here <br>    iBtnPos++; <br>    if (iBtnPos &gt;= toolbarGetNumButtons(hwnd)) <br>iBtnPos = 0;// wrap around <br>    if (iBtnPos == GETWHICH(hwnd)) <br>return 0L;// uh-oh! They're all gray! <br>} while (iBtnPos != GETWHICH(hwnd)); <br> <br>SETWHICH(hwnd, iBtnPos);// give focus here <br> <br>/* And redraw! */ <br>toolbarRectFromIndex(hwnd, iBtnPos, &amp;rc); <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br>UpdateWindow(hwnd); <br>return 0; <br>    } <br> <br>case WM_KILLFOCUS: <br> <br>/* Send a KEYUP if one is pending */ <br>if (GETKEYPRESSED(hwnd)) <br>    SendMessage(hwnd, WM_KEYUP, VK_SPACE, 0L); <br> <br>/* Redraw the focused button, because now that focus is gone */ <br>/* from our toolbar window, the focused button won't be      */ <br>/* focused anymore, although we remember which one it was.   */ <br>toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &amp;rc); <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br>UpdateWindow(hwnd); <br>return 0; <br> <br>case WM_SYSKEYDOWN: <br>/* Send a KEYUP if one is pending */ <br>if (GETKEYPRESSED(hwnd)) <br>    SendMessage(hwnd, WM_KEYUP, VK_SPACE, 0L); <br>break;// MUST LET DEFWNDPROC RUN!!! (to handle the key) <br> <br>        case WM_GETDLGCODE: <br>return DLGC_WANTARROWS | DLGC_WANTTAB; <br> <br>case WM_KEYDOWN: <br> <br>/* Window disabled or a key is already down */ <br>if (IsWindowEnabled(hwnd) &amp;&amp; !GETPRESSED(hwnd)) { <br> <br>    /* Tab forward to next button and move focus there */ <br>    if (wParam == VK_TAB &amp;&amp; GetKeyState(VK_SHIFT) &gt;= 0 ) { <br> <br>/* Move Focus forward one.  If */ <br>/* we've tabbed off of the toolbar, it's time */ <br>/* to go on to the next control. We need to invldte */ <br>/* because we might be the only control and we need */ <br>/* to repaint to show the new button with highlight */ <br>/* after it wrapped around the end of the toolbar.  */ <br>if (!toolbarMoveFocus(hwnd, FALSE)) { <br>    PostMessage(GetParent(hwnd), WM_NEXTDLGCTL, 0, 0L); <br>    toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &amp;rc); <br>    InvalidateRect(hwnd, &amp;rc, FALSE); <br>} <br> <br>return 0L; <br>    } <br>    if (wParam == VK_TAB &amp;&amp; GetKeyState(VK_SHIFT) &lt; 0 ) { <br> <br>/* Move focus backward one.  If */ <br>/* We've tabbed off of the toolbar, it's time    */ <br>/* to go on to the next control. We need to invldte */ <br>/* because we might be the only control and we need */ <br>/* to repaint to show the new button with highlight */ <br>/* after it wrapped around the end of the toolbar.  */ <br>if (!toolbarMoveFocus(hwnd, TRUE)) { <br>    PostMessage(GetParent(hwnd), WM_NEXTDLGCTL, 1, 0L); <br>    toolbarRectFromIndex(hwnd, GETWHICH(hwnd), &amp;rc); <br>    InvalidateRect(hwnd, &amp;rc, FALSE); <br>} <br> <br>return 0L; <br>    } <br>    if ((wParam == VK_SPACE) &amp;&amp; (GetCapture() != hwnd)) { <br> <br>intiButton, iType, iState; <br> <br>/* Same as mouse button down -- Press the button! */ <br>iBtnPos = GETWHICH(hwnd); <br>iType = toolbarTypeFromIndex(hwnd, iBtnPos); <br>iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>iState = toolbarFullStateFromButton(hwnd, iButton); <br> <br>/* ignore multiple key downs */ <br>if (!GETKEYPRESSED(hwnd)) { <br> <br>    SETKEYPRESSED(hwnd, TRUE);// a key is pressed <br> <br>    SETSHIFTED(hwnd, FALSE);// NEVER shifted <br>    SETPRESSED(hwnd, TRUE);// a button is pressed <br> <br>    /* Push button goes down - with focus */ <br>    if (iType == BTNTYPE_PUSH) <br>toolbarModifyState(hwnd, iButton, BTNST_DOWN); <br> <br>    /* Radio or checkbox button goes full down */ <br>    /* with focus - and remember previous state*/ <br>    if (iType &gt;= BTNTYPE_RADIO || <br>iType == BTNTYPE_CHECKBOX) { <br>toolbarModifyPrevState(hwnd, iButton, iState); <br>toolbarModifyState(hwnd, iButton, <br>BTNST_FULLDOWN); <br>    } <br> <br>    toolbarModifyActivity(hwnd, iButton, <br>BTNACT_KEYDOWN); <br>    NotifyParent(hwnd, (GETSHIFTED(hwnd) <br>? BTN_SHIFT : 0) + iButton); <br> <br>    return 0L; <br>} <br> <br>/* If this is another KEYDOWN msg, it's a REPEAT */ <br>/* Notify parent.                                */ <br>NotifyParent(hwnd, BTN_REPEAT + <br>(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + <br>toolbarButtonFromIndex(hwnd, <br>GETWHICH(hwnd))); <br>    } <br>} <br>break; <br> <br>case WM_KEYUP: <br> <br>/* A button was pressed and should come up now */ <br>if ((wParam == VK_SPACE) &amp;&amp; (GETKEYPRESSED(hwnd))) { <br>    intiButton, iState, iType, iPrevState; <br> <br>    iBtnPos = GETWHICH(hwnd);// which button? <br>    SETKEYPRESSED(hwnd, FALSE);// let go <br>    SETPRESSED(hwnd, FALSE); <br> <br>    /* Everything about this button */ <br>    toolbarRectFromIndex(hwnd, iBtnPos, &amp;rc); <br>    iType = toolbarTypeFromIndex(hwnd, iBtnPos); <br>    iButton = toolbarButtonFromIndex(hwnd, iBtnPos); <br>    iState = toolbarFullStateFromButton(hwnd, iButton); <br> <br>    /* Bring a push button up */ <br>    if (iType == BTNTYPE_PUSH) <br>toolbarModifyState(hwnd, iButton, BTNST_UP); <br> <br>    /* Bring a checkbox to the opposite state it was in */ <br>    if (iType == BTNTYPE_CHECKBOX) { <br>iPrevState = toolbarPrevStateFromButton(hwnd, iButton); <br>if (iPrevState == BTNST_DOWN) <br>    toolbarModifyState(hwnd, iButton, BTNST_UP); <br>if (iPrevState == BTNST_UP) <br>    toolbarModifyState(hwnd, iButton, BTNST_DOWN); <br>    } <br> <br>    /* Bring a radio button down, and bring all others in */ <br>    /* its group up.  */ <br>    if (iType &gt;= BTNTYPE_RADIO) { <br>toolbarModifyState(hwnd, iButton, BTNST_DOWN); <br>toolbarExclusiveRadio(hwnd, iType, iButton); <br>    } <br> <br>    toolbarModifyActivity(hwnd, iButton, BTNACT_KEYUP); <br>    NotifyParent(hwnd, toolbarButtonFromIndex(hwnd, <br>(GETSHIFTED(hwnd) ? BTN_SHIFT : 0) + <br>GETWHICH(hwnd))); <br>} <br>break; <br> <br>case WM_SYSCOLORCHANGE: <br>/* load the bitmap of what all the buttons look like */ <br>/* and change the colours to the system colours.     */ <br>hInst = GETHINST(hwnd); <br>ibmp = GETBMPINT(hwnd); <br>hbm = GETBMPHANDLE(hwnd); <br>if (hbm) <br>    DeleteObject(hbm); <br>hbm = LoadUIBitmap(hInst, MAKEINTRESOURCE(ibmp), <br>    GetSysColor(COLOR_BTNTEXT), <br>    GetSysColor(COLOR_BTNFACE), <br>    GetSysColor(COLOR_BTNSHADOW), <br>    GetSysColor(COLOR_BTNHIGHLIGHT), <br>    GetSysColor(COLOR_BTNFACE), <br>    GetSysColor(COLOR_WINDOWFRAME)); <br>SETBMPHANDLE(hwnd, hbm); <br>#ifdef _WIN32 <br>return (long) hbm; <br>#else <br>return MAKELONG(hbm, 0); <br>#endif <br> <br>        case WM_ERASEBKGND: <br>break; <br> <br> <br>        case WM_PAINT: <br> <br>/* Call our paint code */ <br>BeginPaint(hwnd, &amp;ps); <br>toolbarPaintControl(hwnd, ps.hdc); <br>EndPaint(hwnd, &amp;ps); <br> <br>return 0L; <br>    } <br> <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
