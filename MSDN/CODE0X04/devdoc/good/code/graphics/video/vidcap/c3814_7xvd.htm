<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIDCAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3829"></a>VIDCAP.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *   vidcap.c: WinMain and command processing <br> * <br> *   Vidcap32 Source code <br> * <br> ***************************************************************************/ <br>  <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;dos.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "vidcap.h" <br>#include "vidframe.h" <br>#include "profile.h" <br> <br>// generic window control classes <br>#include "toolbar.h" <br>#include "status.h" <br>#include "arrow.h" <br>#include "rlmeter.h" <br>#include "help.h" <br> <br>// the standard toolbar class 'exports' this but doesn't put it in the <br>// header file <br>extern char     szToolBarClass[];//HACK! <br> <br> <br>// height of the buttons on a toolbar - depends on the <br>// size of the bitmaps within IDBMP_TOOLBAR <br>#define BUTTONWIDTH     24 <br>#define BUTTONHEIGHT    22 <br>#define TOOLBAR_HEIGHT          BUTTONHEIGHT + 6 <br> <br> <br>// description and layout of toolbar buttons within IDBMP_TOOLBAR <br>#define APP_NUMTOOLS 8 <br> <br>#define BTN_SETFILE0 <br>#define BTN_EDITCAP1 <br>#define BTN_LIVE2 <br>#define BTN_CAPFRAME3 <br>#define BTN_CAPSEL4 <br>#define BTN_CAPAVI5 <br>#define BTN_CAPPAL6 <br>#define BTN_OVERLAY7 <br> <br>static int           aiButton[] = {BTN_SETFILE, BTN_EDITCAP, <br>                            BTN_LIVE, BTN_OVERLAY, BTN_CAPFRAME, <br>                            BTN_CAPSEL, BTN_CAPAVI, BTN_CAPPAL }; <br>static int           aiState[] = {BTNST_FOCUSUP, BTNST_UP, <br>                            BTNST_UP, BTNST_UP, BTNST_UP, <br>                            BTNST_UP, BTNST_UP, BTNST_UP}; <br>static int           aiType[] ={BTNTYPE_PUSH, BTNTYPE_PUSH, <br>                            BTNTYPE_CHECKBOX, BTNTYPE_CHECKBOX, <br>                            BTNTYPE_PUSH, <br>                            BTNTYPE_PUSH, BTNTYPE_PUSH, BTNTYPE_PUSH}; <br>static int           aiString[] = { IDC_toolbarSETFILE, <br>                            IDC_toolbarEDITCAP, IDC_toolbarLIVE, <br>                            IDC_toolbarOVERLAY, <br>                            IDC_toolbarCAPFRAME, IDC_toolbarCAPSEL, <br>                            IDC_toolbarCAPAVI, IDC_toolbarCAPPAL }; <br>static int           aPos[] = { 10, 35, 75, 100, 150, 175, 200, 225 }; <br> <br> <br> <br> <br>// <br>// Global Variables <br>// <br> <br>// preferences <br>BOOL gbCentre; <br>BOOL gbToolBar; <br>BOOL gbStatusBar; <br>BOOL gbAutoSizeFrame; <br>int gBackColour; <br> <br>BOOL gbLive, gbOverlay; <br>BOOL gfIsRTL; <br> <br>// saved window sizes <br>int gWinX, gWinY; <br>int gWinCX, gWinCY; <br>int gWinShow; <br> <br>// command line options <br>int gCmdLineDeviceID = -1; <br> <br> <br>char           gachAppName[]  = "vidcapApp" ; <br>char           gachIconName[] = "vidcapIcon" ; <br>char           gachMenuName[] = "vidcapMenu" ; <br>char           gachAppTitle[20];    //VidCap <br>char           gachCaptureFile[_MAX_PATH]; <br>char           gachMCIDeviceName[21]; <br>char           gachString[128] ; <br>char           gachBuffer[200] ; <br>char           gachLastError[256]; <br> <br> <br>HINSTANCE      ghInstApp ; <br>HWND           ghWndMain = NULL ; <br>HWND           ghWndFrame;      // child of ghWndMain  - frames and scrolls <br>HWND           ghWndCap  ;      // child of ghWndCap <br>HWND           ghWndToolBar; <br>HWND           ghWndStatus; <br> <br>HANDLE         ghAccel ; <br>WORD           gwDeviceIndex ; <br>WORD           gwPalFrames = DEF_PALNUMFRAMES ; <br>WORD           gwPalColors = DEF_PALNUMCOLORS ; <br>WORD           gwCapFileSize ; <br> <br>CAPSTATUS      gCapStatus ; <br>CAPDRIVERCAPS  gCapDriverCaps ; <br>CAPTUREPARMS   gCapParms ; <br>BOOL           gbHaveHardware; <br>UINT           gDriverCount; <br>BOOL           gbIsScrncap;  // For Scrncap.drv, we must yield <br>BOOL           gbInLayout; <br>UINT           gAVStreamMaster; <br> <br>HANDLE         ghwfex ; <br>LPWAVEFORMATEX glpwfex ; <br> <br>FARPROC        fpErrorCallback ; <br>FARPROC        fpStatusCallback ; <br>FARPROC        fpYieldCallback ; <br> <br> <br>// set to false when we capture a palette (or if we have warned him and <br>// he says its ok <br>BOOL bDefaultPalette = TRUE; <br> <br>#ifdef DEBUG <br>intnTestCount; <br>#endif <br> <br>// c-runtime cmd line <br>extern char ** __argv; <br>extern int __argc; <br> <br>#define LimitRange(Val,Low,Hi) (max(Low,(min(Val,Hi)))) <br> <br> <br>// <br>// Function prototypes <br>// <br>LONG FAR PASCAL MainWndProc(HWND, UINT, UINT, LONG) ; <br>LRESULT FAR PASCAL ErrorCallbackProc(HWND, int, LPSTR) ; <br>LRESULT FAR PASCAL StatusCallbackProc(HWND, int, LPSTR) ; <br>LRESULT FAR PASCAL YieldCallbackProc(HWND) ; <br>void vidcapSetLive(BOOL bLive); <br>void vidcapSetOverlay(BOOL bOverlay); <br>void vidcapSetCaptureFile(LPSTR pFileName); <br> <br>BOOL vidcapRegisterClasses(HINSTANCE hInstance, HINSTANCE hPrevInstance); <br>BOOL vidcapCreateWindows(HINSTANCE hInstance, HINSTANCE hPrevInstance); <br>void vidcapLayout(HWND hwnd); <br>BOOL vidcapEnumerateDrivers(HWND hwnd); <br>BOOL vidcapInitHardware(HWND hwnd, HWND hwndCap, UINT uIndex); <br>void vidcapReadProfile(void); <br>void vidcapWriteProfile(void); <br>void vidcapReadSettingsProfile(void); <br>void vidcapWriteSettingsProfile(void); <br> <br> <br>/* --- initialisation -------------------------------------------------- */ <br> <br> <br>// <br>// WinMain: Application Entry Point Function <br>// <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>/////////////////////////////////////////////////////////////////////// <br>//  hInstance:      handle for this instance <br>//  hPrevInstance:  handle for possible previous instances <br>//  lpszCmdLine:    long pointer to exec command line <br>//  nCmdShow:       Show code for main window display <br>/////////////////////////////////////////////////////////////////////// <br> <br>    MSG          msg ; <br>    BOOL bValidCmdline; <br>    BOOL fOK; <br>    int i; <br>    char ach[2]; <br> <br>    ghInstApp = hInstance ; <br>    LoadString(hInstance, IDS_CAP_RTL, ach, sizeof(ach)); <br>    gfIsRTL = ach[0] == '1'; <br>    gCmdLineDeviceID = -1; <br> <br>    // read the app title string - used in several message boxes <br>    LoadString(hInstance, IDS_APP_TITLE, gachAppTitle, sizeof(gachAppTitle)); <br> <br>    // read defaults out of the registry <br>    vidcapReadProfile(); <br> <br>    // look for cmd line options <br>    bValidCmdline = TRUE; <br> <br>    for ( i = 1; (i &lt; __argc) &amp;&amp; bValidCmdline; i++) { <br>        if ((__argv[i][0] == '/') || (__argv[i][0] == '-')) { <br> <br>            switch(__argv[i][1]) { <br>            case 'D': <br>            case 'd': <br>                if (gCmdLineDeviceID &lt; 0) { <br>                    // allow "-d0" and "-d 0" <br>                    PSTR p = &amp;__argv[i][2]; <br> <br>                    if ((*p == 0) &amp;&amp; ((i+1) &lt; __argc)) { <br>                        p = __argv[++i]; <br>                    } <br> <br> <br>                    gCmdLineDeviceID = atoi(p); <br>                } else { <br>                    bValidCmdline = FALSE; <br>                } <br>                break; <br> <br>            default: <br>                bValidCmdline = FALSE; <br>            } <br>        } else { <br>            bValidCmdline = FALSE; <br>        } <br>    } <br>     <br>    if (gCmdLineDeviceID == -1) <br>gCmdLineDeviceID = 0; <br> <br> <br>    if (!bValidCmdline) { <br>        MessageBoxID(IDS_ERR_CMDLINE, MB_OK|MB_ICONEXCLAMATION); <br>        return(0); <br>    } <br> <br>    if (!vidcapRegisterClasses(hInstance, hPrevInstance)) { <br> <br>        MessageBoxID(IDS_ERR_REGISTER_CLASS, <br>        MB_ICONEXCLAMATION) ; <br>        return 0 ; <br>    } <br> <br> <br>    if (!vidcapCreateWindows(hInstance, hPrevInstance)) { <br> <br>        MessageBoxID(IDS_ERR_CREATE_WINDOW, <br>        MB_ICONEXCLAMATION | MB_OK) ; <br>        return IDS_ERR_CREATE_WINDOW ; <br>    } <br> <br>    // Get the default setup for video capture from the AVICap window <br>    capCaptureGetSetup(ghWndCap, &amp;gCapParms, sizeof(CAPTUREPARMS)) ; <br> <br>    // Overwrite the defaults with settings we have saved in the profile <br>    vidcapReadSettingsProfile(); <br> <br>    // Show the main window before connecting the hardware as this can be <br>    // time consuming and the user should see something happening first... <br>    ShowWindow(ghWndMain, nCmdShow) ; <br>    UpdateWindow(ghWndMain) ; <br>    ghAccel = LoadAccelerators(hInstance, "VIDCAP") ; <br> <br>    // Create a list of all capture drivers and append them to the Options menu <br>    if (!(fOK = vidcapEnumerateDrivers(ghWndMain))) { <br>LoadString(ghInstApp, IDS_ERR_FIND_HARDWARE, gachLastError, sizeof(gachLastError)); <br>    } <br>    // Try to connect to a capture driver <br>    else if (fOK = vidcapInitHardware(ghWndMain, ghWndCap,  <br>       bValidCmdline ? gCmdLineDeviceID : 0)) { <br>// Hooray, we now have a capture driver connected! <br>        vidcapSetCaptureFile(gachCaptureFile); <br>    } <br>     <br>    if (!fOK) { <br>        if (!DoDialog(ghWndMain, IDD_NoCapHardware, NoHardwareDlgProc, <br>                        (LONG) (LPSTR) gachLastError)) { <br>            // The user has asked to abort, since no driver was available <br>            PostMessage(ghWndMain, WM_COMMAND, <br>                        GET_WM_COMMAND_MPS(IDM_F_EXIT, 0, 0)); <br>        } <br>    } <br>     <br>    // All set; get and process messages <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if (! TranslateAccelerator(ghWndMain, ghAccel, &amp;msg)) { <br>            TranslateMessage(&amp;msg) ; <br>            DispatchMessage(&amp;msg) ; <br>        } <br>    } <br> <br>    return msg.wParam; <br>}  // End of WinMain <br> <br> <br>BOOL <br>vidcapRegisterClasses(HINSTANCE hInstance, HINSTANCE hPrevInstance) <br>{ <br>    WNDCLASS wc; <br> <br>    if (! hPrevInstance) { <br>        // If it's the first instance, register the window class <br>        wc.lpszClassName = gachAppName ; <br>        wc.hInstance     = hInstance ; <br>        wc.lpfnWndProc   = MainWndProc ; <br>        wc.hCursor       = LoadCursor(NULL, IDC_ARROW) ; <br>        wc.hIcon         = LoadIcon(hInstance, gachIconName) ; <br>        wc.lpszMenuName  = gachMenuName ; <br>        wc.hbrBackground = GetStockObject(WHITE_BRUSH) ; <br>        wc.style         = CS_HREDRAW | CS_VREDRAW ; <br>        wc.cbClsExtra    = 0 ; <br>        wc.cbWndExtra    = 0 ; <br> <br>        if (!RegisterClass(&amp;wc)) { <br>            return(FALSE); <br>        } <br> <br>        if (!ArrowInit(hInstance)) { <br>            return(FALSE); <br>        } <br> <br>        if (!RLMeter_Register(hInstance)) { <br>            return(FALSE); <br>        } <br>    } <br> <br>    if (!toolbarInit(hInstance, hPrevInstance)) { <br>        return(FALSE); <br>    } <br> <br>    if (!statusInit(hInstance, hPrevInstance)) { <br>        return(FALSE); <br>    } <br>    return(TRUE); <br> <br>} <br> <br>BOOL <br>vidcapCreateWindows(HINSTANCE hInstance, HINSTANCE hPrevInstance) <br>{ <br> <br>    POINT pt; <br>    RECT rc; <br>    TOOLBUTTON tb; <br>    int i; <br> <br>    // Create Application's Main window <br>    ghWndMain = CreateWindowEx( <br>            gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0, <br>            gachAppName, <br>            gachAppTitle, <br>            WS_CAPTION      | <br>            WS_SYSMENU      | <br>            WS_MINIMIZEBOX  | <br>            WS_MAXIMIZEBOX  | <br>            WS_THICKFRAME   | <br>            WS_CLIPCHILDREN | <br>            WS_OVERLAPPED, <br>            gWinX, gWinY, <br>            gWinCX, gWinCY, <br>            NULL, <br>            NULL, <br>            hInstance, <br>            0) ; <br> <br>    if (ghWndMain == NULL) { <br>        return(FALSE); <br>    } <br> <br> <br>    /* <br>     * create a vidframe child window - this will create a child <br>     * AVICAP window within itself. <br>     * <br>     * Don't worry about size and position - vidcapLayout will do this <br>     * later (once we know the video format size). <br>     */ <br>    ghWndFrame = vidframeCreate( <br>                    ghWndMain, <br>                    hInstance, <br>                    hPrevInstance, <br>                    0, 0, 0, 0, <br>                    &amp;ghWndCap); <br> <br>    if ((ghWndFrame == NULL) || (ghWndCap == NULL)) { <br>        return(FALSE); <br>    } <br> <br>    // Register the status and error callbacks before driver connects <br>    // so we can get feedback about the connection process <br>    fpErrorCallback = MakeProcInstance((FARPROC)ErrorCallbackProc, ghInstApp) ; <br>    capSetCallbackOnError(ghWndCap, fpErrorCallback) ; <br> <br>    fpStatusCallback = MakeProcInstance((FARPROC)StatusCallbackProc, ghInstApp) ; <br>    capSetCallbackOnStatus(ghWndCap, fpStatusCallback) ; <br> <br>    // We'll only install a yield callback later if using Scrncap.drv <br>    fpYieldCallback = MakeProcInstance((FARPROC)YieldCallbackProc, ghInstApp) ; <br>     <br> <br>    /* <br>     * CREATE THE TOOL BAR WINDOW <br>     */ <br>    /* NOTE: let vidcapLayout() position it */ <br>    ghWndToolBar = CreateWindowEx( <br>            gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0, <br>            szToolBarClass, <br>            NULL, <br>            WS_CHILD|WS_BORDER|WS_VISIBLE|WS_TABSTOP| <br>            WS_CLIPSIBLINGS, <br>            0, 0, <br>            0, 0, <br>            ghWndMain, <br>            NULL, <br>            hInstance, <br>            NULL); <br> <br> <br>    if (ghWndToolBar == NULL) { <br>        return(FALSE); <br>    } <br> <br>    /* set the bitmap and button size to be used for this toolbar */ <br>    pt.x = BUTTONWIDTH; <br>    pt.y = BUTTONHEIGHT; <br>    toolbarSetBitmap(ghWndToolBar, hInstance, IDBMP_TOOLBAR, pt); <br> <br>    for (i = 0; i &lt; APP_NUMTOOLS; i++) { <br>rc.left = aPos[i]; <br>rc.top = 2; <br>rc.right = rc.left + pt.x; <br>rc.bottom = rc.top + pt.y; <br>tb.rc = rc; <br>tb.iButton = aiButton[i]; <br>tb.iState = aiState[i]; <br>tb.iType = aiType[i]; <br>tb.iString = aiString[i]; <br>toolbarAddTool(ghWndToolBar, tb); <br>    } <br> <br>    // create the status bar - let vidcapLayout do the positioning <br>    ghWndStatus = CreateWindowEx( <br>                    gfIsRTL ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0, <br>                    szStatusClass, <br>                    NULL, <br>                    WS_CHILD|WS_BORDER|WS_VISIBLE|WS_CLIPSIBLINGS, <br>                    0, 0, <br>                    0, 0, <br>                    ghWndMain, <br>                    NULL, <br>                    hInstance, <br>                    NULL); <br>    if (ghWndStatus == NULL) { <br>        return(FALSE); <br>    } <br> <br>    return(TRUE); <br> <br>} <br> <br>/* <br> * Enumerate the potential capture drivers and add the list to the Options <br> * menu.  This function is only called once at startup. <br> * Returns FALSE if no drivers are available. <br> */ <br>BOOL <br>vidcapEnumerateDrivers(HWND hwnd) <br>{ <br>    char    achDeviceVersion[80] ; <br>    char    achDeviceAndVersion[160] ; <br>    UINT    uIndex ; <br>    HMENU   hMenuSub; <br> <br>    gDriverCount = 0 ; <br> <br>    hMenuSub = GetSubMenu (GetMenu (hwnd), 2);  // Options menu <br> <br>    for (uIndex = 0 ; uIndex &lt; MAXVIDDRIVERS ; uIndex++) { <br>        if (capGetDriverDescription(uIndex, <br>                       (LPSTR)achDeviceAndVersion, sizeof(achDeviceAndVersion), <br>                       (LPSTR)achDeviceVersion, sizeof(achDeviceVersion))) { <br>            // Concatenate the device name and version strings <br>            lstrcat (achDeviceAndVersion, ",   "); <br>            lstrcat (achDeviceAndVersion, achDeviceVersion); <br> <br>            AppendMenu (hMenuSub,  <br>                        MF_STRING, <br>                        IDM_O_DRIVER0 + uIndex,  <br>                        achDeviceAndVersion); <br>            gDriverCount++; <br>        } <br>        else <br>            break; <br>    }  <br> <br>    // Now refresh menu, position capture window, start driver etc <br>    DrawMenuBar(ghWndMain) ; <br> <br>    return (gDriverCount); <br>} <br> <br>/* <br> * Connect the capture window to a capture driver. <br> * uIndex specifies the index of the driver to use. <br> * Returns TRUE on success, or FALSE if the driver connection failed. <br> */ <br>BOOL <br>vidcapInitHardware(HWND hwnd, HWND hwndCap, UINT uIndex) <br>{ <br>    UINT    uError ; <br>    UINT    uI; <br>    HMENU   hMenu; <br>    char    szName[MAX_PATH]; <br>    char    szVersion[MAX_PATH]; <br> <br>    // Since the driver may not provide a reliable error string <br>    // provide a default <br>    LoadString(ghInstApp, IDS_ERR_FIND_HARDWARE, gachLastError, sizeof(gachLastError)); <br> <br>    // Try connecting to the capture driver <br>    if (uError = capDriverConnect(hwndCap, uIndex)) { <br>        gbHaveHardware = TRUE; <br>        gwDeviceIndex = uIndex; <br>    } <br>    else { <br>        gbHaveHardware = FALSE; <br>        gbLive = FALSE; <br>        gbOverlay = FALSE; <br>    } <br> <br>    // Get the capabilities of the capture driver <br>    capDriverGetCaps(hwndCap, &amp;gCapDriverCaps, sizeof(CAPDRIVERCAPS)) ; <br> <br>    // Get the settings for the capture window <br>    capGetStatus(hwndCap, &amp;gCapStatus , sizeof(gCapStatus)); <br> <br>    // Modify the toolbar buttons <br>    toolbarModifyState(ghWndToolBar, BTN_CAPFRAME,  <br>        gbHaveHardware ? BTNST_UP : BTNST_GRAYED); <br>    toolbarModifyState(ghWndToolBar, BTN_CAPSEL,  <br>        gbHaveHardware ? BTNST_UP : BTNST_GRAYED); <br>    toolbarModifyState(ghWndToolBar, BTN_CAPAVI,  <br>        gbHaveHardware ? BTNST_UP : BTNST_GRAYED); <br>    toolbarModifyState(ghWndToolBar, BTN_LIVE,  <br>        gbHaveHardware ? BTNST_UP : BTNST_GRAYED); <br> <br>    // Is overlay supported? <br>    toolbarModifyState(ghWndToolBar, BTN_OVERLAY,  <br>        (gbHaveHardware &amp;&amp; gCapDriverCaps.fHasOverlay) ?  <br>        BTNST_UP : BTNST_GRAYED); <br> <br>    // Can the device create palettes? <br>    toolbarModifyState(ghWndToolBar, BTN_CAPPAL,  <br>        (gbHaveHardware &amp;&amp; gCapDriverCaps.fDriverSuppliesPalettes) ?  <br>        BTNST_UP : BTNST_GRAYED); <br> <br>    // Check the appropriate driver in the Options menu <br>    hMenu = GetMenu (hwnd); <br>    for (uI = 0; uI &lt; gDriverCount; uI++) { <br>        CheckMenuItem (hMenu, IDM_O_DRIVER0 + uI,  <br>                MF_BYCOMMAND | ((uIndex == uI) ? MF_CHECKED : MF_UNCHECKED)); <br>    }  <br> <br>    // Unlike all other capture drivers, Scrncap.drv needs to use <br>    // a Yield callback, and we don't want to abort on mouse clicks, <br>    // so determine if the current driver is Scrncap.drv <br>    capGetDriverDescription (uIndex,  <br>                szName, sizeof (szName), <br>                szVersion, sizeof (szVersion)); <br> <br>    // Set a flag if we're using Scrncap.drv <br>    gbIsScrncap = (BOOL) _fstrstr (szName, "Screen Capture"); <br> <br>    // Get video format and adjust capture window <br>    vidcapLayout(ghWndMain); <br>    InvalidateRect(ghWndMain, NULL, TRUE); <br> <br>    // set the preview rate (units are millisecs) <br>    capPreviewRate(hwndCap, gbHaveHardware ? 33 : 0);  <br> <br>    // set live/overlay to default <br>    vidcapSetLive(gbLive); <br>    vidcapSetOverlay(gbOverlay); <br> <br>    strcat (szName, ",   "); <br>    strcat (szName, szVersion); <br> <br>    statusUpdateStatus(ghWndStatus,  <br>        gbHaveHardware ? szName : gachLastError); <br> <br>    return gbHaveHardware; <br>} <br> <br> <br>/* <br> * layout the main window. Put the toolbar at the top and the status <br> * line at the bottom, and then give all the rest to vidframe, <br> *  - it will centre or scroll the AVICAP window appropriately. <br> */ <br>void <br>vidcapLayout(HWND hwnd) <br>{ <br>    RECT rc; <br>    RECT rw; <br>    int cy; <br>    int cyBorder, cxBorder; <br>    int cyTotal; <br>    int cxToolbar; <br>    int cyMenuAndToolbarAndCaption; <br> <br>    gbInLayout = TRUE;  // So that we process WM_GETMINMAXINFO normally <br> <br>    /* for both the toolbar and status bar window, <br>     * we want just one of the four borders. We do this <br>     * by setting the WS_BORDER style, and sizing and positioning <br>     * the window so that the 3 unwanted borders are outside the parent. <br>     */ <br>    cyBorder = GetSystemMetrics(SM_CYBORDER); <br>    cxBorder = GetSystemMetrics(SM_CXBORDER); <br> <br>    // Figure out the height of the menu, toolbar, and caption <br>    GetWindowRect (hwnd, &amp;rw); <br>    GetClientRect (hwnd, &amp;rc); <br> <br>    ClientToScreen (hwnd, (LPPOINT) &amp;rc); <br>    cyMenuAndToolbarAndCaption = (rc.top - rw.top) + TOOLBAR_HEIGHT; <br> <br>    cxToolbar = aPos[APP_NUMTOOLS - 1] + BUTTONWIDTH * 3; <br> <br>    if (gbAutoSizeFrame &amp;&amp; gbHaveHardware &amp;&amp; gCapStatus.uiImageWidth) { <br>        cyTotal = gCapStatus.uiImageHeight + <br>                cyMenuAndToolbarAndCaption + <br>                (gbStatusBar ? statusGetHeight() : 0) + <br>                cyBorder * 2 +  <br>                12;     // vidFrame height <br>        // Never make the frame smaller than the toolbar <br>        if (gCapStatus.uiImageWidth &gt;= (UINT) cxToolbar) { <br>            SetWindowPos( <br>                hwnd, <br>                0,// placement-order handle <br>                0,// horizontal position <br>                0,// vertical position <br>                gCapStatus.uiImageWidth + cxBorder * 24,// width <br>                cyTotal,// height <br>                SWP_NOZORDER | SWP_NOMOVE // window-positioning flags <br>                ); <br>        } else { <br>            SetWindowPos( <br>                hwnd, <br>                0,// placement-order handle <br>                0,// horizontal position <br>                0,// vertical position <br>                cxToolbar,// width <br>                cyTotal,// height <br>                SWP_NOZORDER | SWP_NOMOVE // window-positioning flags <br>                ); <br>        } <br>    } <br> <br>    GetClientRect(hwnd, &amp;rc); <br> <br>    if (gbToolBar) { <br>        // put the toolbar at the top - in fact, just off the top so as to <br>        // hide it's border <br>        MoveWindow( <br>            ghWndToolBar, <br>            -cxBorder, -cyBorder, <br>            RECTWIDTH(rc)+ (cxBorder * 2), <br>            TOOLBAR_HEIGHT, <br>            TRUE); <br>        rc.top += (TOOLBAR_HEIGHT - cyBorder); <br>    } else { <br>        MoveWindow(ghWndToolBar, 0, 0, 0, 0, TRUE); <br>    } <br> <br>    // status bar at the bottom <br>    if (gbStatusBar) { <br>        cy = statusGetHeight() + cyBorder; <br>        MoveWindow( <br>            ghWndStatus, <br>            -cxBorder, rc.bottom - cy, <br>            RECTWIDTH(rc) + (2 * cxBorder), cy + cyBorder, <br>            TRUE); <br>        rc.bottom -= cy; <br>    } else { <br>        MoveWindow(ghWndStatus, 0, 0, 0, 0, TRUE); <br>    } <br> <br>    // rest of window goes to vidframe window <br>    MoveWindow( <br>        ghWndFrame, <br>        rc.left, rc.top, <br>        RECTWIDTH(rc), RECTHEIGHT(rc), <br>        TRUE); <br> <br>    // Always layout the frame window, since it is aligned on a <br>    // DWORD boundary for maximum codec drawing efficiency <br>    vidframeLayout(ghWndFrame, ghWndCap); <br> <br>    gbInLayout = FALSE;  <br>} <br> <br>/* <br> * initialise settings from the profile used before window creation time <br> */ <br>void <br>vidcapReadProfile(void) <br>{ <br>    // read defaults out of the registry <br>    gbCentre = mmGetProfileFlag(gachAppTitle, "CenterImage", TRUE); <br>    gbToolBar = mmGetProfileFlag(gachAppTitle, "ToolBar", TRUE); <br>    gbStatusBar = mmGetProfileFlag(gachAppTitle, "StatusBar", TRUE); <br>    gbAutoSizeFrame = mmGetProfileFlag(gachAppTitle, "AutoSizeFrame", TRUE); <br>    gBackColour = mmGetProfileInt(gachAppTitle, "BackgroundColor", IDD_PrefsLtGrey); <br> <br>    gWinX = mmGetProfileInt(gachAppTitle, "WindowXPos", (UINT) CW_USEDEFAULT); <br>if (gWinX != (UINT) CW_USEDEFAULT) <br>    gWinX = LimitRange(gWinX, 0, GetSystemMetrics (SM_CXSCREEN) - 40); <br>    gWinY = mmGetProfileInt(gachAppTitle, "WindowYPos", 0); <br>    gWinY = LimitRange(gWinY, 0, GetSystemMetrics (SM_CYSCREEN) - 40); <br>    gWinCX = mmGetProfileInt(gachAppTitle, "WindowWidth", 320); <br>    gWinCX = LimitRange(gWinCX, 20, GetSystemMetrics (SM_CXSCREEN)); <br>    gWinCY = mmGetProfileInt(gachAppTitle, "WindowHeight", 240); <br>    gWinCY = LimitRange(gWinCY, 20, GetSystemMetrics (SM_CYSCREEN)); <br>    gWinShow = mmGetProfileInt(gachAppTitle, "WindowShow", SW_SHOWDEFAULT); <br>    gWinShow = LimitRange(gWinShow, SW_SHOWNORMAL, SW_SHOWDEFAULT); <br> <br>    gbOverlay = mmGetProfileInt(gachAppTitle, "OverlayWindow", FALSE); <br>    gbLive = mmGetProfileInt(gachAppTitle, "LiveWindow", TRUE); <br>} <br> <br> <br>void <br>vidcapWriteProfile(void) <br>{ <br>    mmWriteProfileFlag(gachAppTitle, "CenterImage", gbCentre, TRUE); <br>    mmWriteProfileFlag(gachAppTitle, "ToolBar", gbToolBar, TRUE); <br>    mmWriteProfileFlag(gachAppTitle, "StatusBar", gbStatusBar, TRUE); <br>    mmWriteProfileFlag(gachAppTitle, "AutoSizeFrame", gbAutoSizeFrame, TRUE); <br>    mmWriteProfileInt(gachAppTitle,  "BackgroundColor", gBackColour, IDD_PrefsLtGrey); <br> <br>    mmWriteProfileInt(gachAppTitle, "WindowXPos", gWinX, (UINT) CW_USEDEFAULT); <br>    mmWriteProfileInt(gachAppTitle, "WindowYPos", gWinY, 0); <br>    mmWriteProfileInt(gachAppTitle, "WindowWidth", gWinCX, 320); <br>    mmWriteProfileInt(gachAppTitle, "WindowHeight", gWinCY, 240); <br>    mmWriteProfileInt(gachAppTitle, "WindowShow", gWinShow, SW_SHOWDEFAULT); <br> <br>    mmWriteProfileInt(gachAppTitle, "OverlayWindow", gbOverlay, FALSE); <br>    mmWriteProfileInt(gachAppTitle, "LiveWindow", gbLive, TRUE); <br>} <br> <br>/* <br> * initialise settings from the profile used AFTER window creation time <br> */ <br>void <br>vidcapReadSettingsProfile(void) <br>{ <br>    DWORD dwSize; <br>     <br>    mmGetProfileString(gachAppTitle, "CaptureFile", "", <br>        gachCaptureFile, sizeof(gachCaptureFile)); <br> <br>    mmGetProfileString(gachAppTitle, "MCIDevice", "VideoDisc", <br>                gachMCIDeviceName, sizeof(gachMCIDeviceName)); <br> <br>    gCapParms.dwRequestMicroSecPerFrame =  <br>                mmGetProfileInt(gachAppTitle, "MicroSecPerFrame",  <br>                DEF_CAPTURE_RATE); <br> <br>    gCapParms.dwRequestMicroSecPerFrame =  <br>                mmGetProfileInt(gachAppTitle, "MicroSecPerFrame",  <br>                DEF_CAPTURE_RATE); <br> <br>    gCapParms.fCaptureAudio = mmGetProfileFlag(gachAppTitle, "CaptureAudio",  <br>                gCapStatus.fAudioHardware); <br> <br>    gCapParms.fLimitEnabled = mmGetProfileFlag(gachAppTitle, "LimitEnabled",  <br>                FALSE); <br> <br>    gCapParms.wTimeLimit =  <br>                mmGetProfileInt(gachAppTitle, "TimeLimit", 30); <br> <br>    gCapParms.fMCIControl= mmGetProfileFlag(gachAppTitle, "MCIControl", FALSE); <br> <br>    gCapParms.fStepMCIDevice= mmGetProfileFlag(gachAppTitle, "StepMCIDevice", FALSE); <br> <br>    gCapParms.dwMCIStartTime =  <br>                mmGetProfileInt(gachAppTitle, "MCIStartTime", 10000); <br> <br>    gCapParms.dwMCIStopTime =  <br>                mmGetProfileInt(gachAppTitle, "MCIStopTime", 20000); <br> <br>    gCapParms.fStepCaptureAt2x = mmGetProfileFlag(gachAppTitle, "StepCapture2x",  <br>                FALSE); <br> <br>    gCapParms.wStepCaptureAverageFrames =  <br>                mmGetProfileInt(gachAppTitle, "StepCaptureAverageFrames", 3); <br> <br>    gCapParms.AVStreamMaster = mmGetProfileInt (gachAppTitle, "AVStreamMaster", <br>                AVSTREAMMASTER_AUDIO); <br> <br>    gCapParms.fUsingDOSMemory = mmGetProfileFlag (gachAppTitle, "CaptureToDisk", <br>                TRUE); <br> <br>    gCapParms.dwIndexSize =  <br>                mmGetProfileInt(gachAppTitle, "IndexSize",  <br>                CAP_SMALL_INDEX); <br>     <br>    // Retrieve the saved audio format <br>    // Ask the ACM what the largest known wave format is <br>    acmMetrics(NULL, <br>               ACM_METRIC_MAX_SIZE_FORMAT, <br>               &amp;dwSize); <br> <br>    // If a wave format was saved in the registry, use that size <br>    dwSize = max (dwSize, mmGetProfileBinary(gachAppTitle, "WaveFormatBinary", <br>   NULL, <br>   NULL, <br>   0)); <br>   <br>    if (glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize)) { <br>capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br>mmGetProfileBinary(gachAppTitle, "WaveFormatBinary", <br>   glpwfex, <br>   glpwfex, <br>   dwSize); <br> <br>// Do some sanity checking <br>if (MMSYSERR_NOERROR == waveInOpen (NULL, WAVE_MAPPER, <br>    glpwfex, 0, 0, WAVE_FORMAT_QUERY)) { <br>    capSetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br>}  <br>GlobalFreePtr(glpwfex) ; <br>    } <br>} <br> <br> <br>void <br>vidcapWriteSettingsProfile(void) <br>{ <br>    mmWriteProfileString(gachAppTitle, "CaptureFile", gachCaptureFile); <br> <br>    mmWriteProfileString(gachAppTitle, "MCIDevice", gachMCIDeviceName); <br> <br>    mmWriteProfileInt(gachAppTitle, "MicroSecPerFrame",  <br>                gCapParms.dwRequestMicroSecPerFrame, DEF_CAPTURE_RATE); <br> <br>    mmWriteProfileFlag(gachAppTitle, "CaptureAudio",  <br>                gCapParms.fCaptureAudio, gCapStatus.fAudioHardware); <br> <br>    mmWriteProfileFlag(gachAppTitle, "LimitEnabled",  <br>                gCapParms.fLimitEnabled, FALSE); <br> <br>    mmWriteProfileInt(gachAppTitle, "TimeLimit",  <br>                gCapParms.wTimeLimit, 30); <br> <br>    mmWriteProfileFlag(gachAppTitle, "MCIControl",  <br>                gCapParms.fMCIControl, FALSE); <br> <br>    mmWriteProfileFlag(gachAppTitle, "StepMCIDevice",  <br>                gCapParms.fStepMCIDevice, FALSE); <br> <br>    mmWriteProfileInt(gachAppTitle, "MCIStartTime",  <br>                gCapParms.dwMCIStartTime, 10000); <br> <br>    mmWriteProfileInt(gachAppTitle, "MCIStopTime",  <br>                gCapParms.dwMCIStopTime, 20000); <br> <br>    mmWriteProfileFlag(gachAppTitle, "StepCapture2x",  <br>                gCapParms.fStepCaptureAt2x, FALSE); <br> <br>    mmWriteProfileInt(gachAppTitle, "StepCaptureAverageFrames",  <br>                gCapParms.wStepCaptureAverageFrames, 3); <br> <br>    mmWriteProfileInt(gachAppTitle, "AVStreamMaster",  <br>                gCapParms.AVStreamMaster, AVSTREAMMASTER_AUDIO); <br> <br>    mmWriteProfileFlag(gachAppTitle, "CaptureToDisk",  <br>                gCapParms.fUsingDOSMemory, TRUE); <br> <br>    mmWriteProfileInt(gachAppTitle, "IndexSize",  <br>                gCapParms.dwIndexSize, CAP_SMALL_INDEX); <br> <br>    // The audio format is written whenever it is changed via dlg <br>} <br> <br> <br> <br> <br>/* --- error/status functions -------------------------------------------*/ </code></pre>
<p>
</p>
<pre><code><br>/* <br> * put up a message box loading a string from the <br> * resource file <br> */ <br>int <br>MessageBoxID(UINT idString, UINT fuStyle) <br>{ <br>    char achMessage[256];   // max message length <br> <br>    LoadString(ghInstApp, idString, achMessage, sizeof(achMessage)); <br> <br>    return MessageBox(ghWndMain, achMessage, gachAppTitle, fuStyle); <br>} <br> <br> <br> <br>// <br>// ErrorCallbackProc: Error Callback Function <br>// <br>LRESULT FAR PASCAL ErrorCallbackProc(HWND hWnd, int nErrID, LPSTR lpErrorText) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:          Application main window handle <br>//  nErrID:        Error code for the encountered error <br>//  lpErrorText:   Error text string for the encountered error <br>//////////////////////////////////////////////////////////////////////// <br> <br>    if (!ghWndMain) <br>        return FALSE; <br> <br>    if (nErrID == 0)            // Starting a new major function <br>        return TRUE;            // Clear out old errors... <br> <br>    // save the error message for use in NoHardwareDlgProc <br>    lstrcpy(gachLastError, lpErrorText); <br> <br>    // Show the error ID and text <br> <br>    MessageBox(hWnd, lpErrorText, gachAppTitle, <br>                MB_OK | MB_ICONEXCLAMATION) ; <br> <br>    return (LRESULT) TRUE ; <br>} <br> <br> <br>// <br>// StatusCallbackProc: Status Callback Function <br>// <br>LRESULT FAR PASCAL StatusCallbackProc(HWND hWnd, int nID, LPSTR lpStatusText) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:           Application main window handle <br>//  nID:            Status code for the current status <br>//  lpStatusText:   Status text string for the current status <br>//////////////////////////////////////////////////////////////////////// <br> <br>    static int CurrentID; <br> <br>    if (!ghWndMain) { <br>        return FALSE; <br>    } <br> <br>    // the CAP_END message sometimes overwrites a useful <br>    // statistics message. <br>    if (nID == IDS_CAP_END) { <br>        if ((CurrentID == IDS_CAP_STAT_VIDEOAUDIO) || <br>            (CurrentID == IDS_CAP_STAT_VIDEOONLY)) { <br> <br>            return(TRUE); <br>        } <br>    } <br>    CurrentID = nID; <br> <br> <br>    statusUpdateStatus(ghWndStatus, lpStatusText); <br> <br>    return (LRESULT) TRUE ; <br>} <br> <br> <br>// <br>// YieldCallbackProc: Status Callback Function <br>// (Only used for Scrncap.drv driver) <br>// <br>LRESULT FAR PASCAL YieldCallbackProc(HWND hWnd) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:           Application main window handle <br>//////////////////////////////////////////////////////////////////////// <br> <br>    MSG msg; <br> <br>    if (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>    } <br> <br>    // Return TRUE to continue capturing <br>    return (LRESULT) TRUE; <br>} <br> <br> <br> <br>/* <br> * load a string from the string table and return <br> * a pointer to it for temporary use. Each call <br> * overwrites the previous <br> */ <br>LPSTR <br>tmpString(UINT idString) <br>{ <br>    static char ach[350]; <br> <br>    LoadString(ghInstApp, idString, ach, sizeof(ach)); <br> <br>    // ensure null terminated <br>    ach[sizeof(ach) -1] = 0; <br> <br>    return(ach); <br>} <br> <br> <br> <br> <br>/* --- connect to and init hardware ------------------------------------- */ <br> <br> <br>void <br>vidcapSetLive(BOOL bLive) <br>{ <br>    capPreview(ghWndCap, bLive); <br>    toolbarModifyState(ghWndToolBar, BTN_LIVE, bLive? BTNST_DOWN : BTNST_UP); <br>    CheckMenuItem(GetMenu(ghWndMain), IDM_O_PREVIEW, <br>        MF_BYCOMMAND | (bLive ? MF_CHECKED : MF_UNCHECKED)); <br> <br>    gbLive = bLive; <br> <br>    if (bLive == TRUE) { <br>        vidcapSetOverlay(FALSE); <br>    } <br>} <br> <br>void <br>vidcapSetOverlay(BOOL bOverlay) <br>{ <br>    if (!gCapDriverCaps.fHasOverlay) { <br>        CheckMenuItem(GetMenu(ghWndMain), IDM_O_OVERLAY, <br>            MF_BYCOMMAND | MF_UNCHECKED); <br>        gbOverlay = FALSE; <br>        return; <br>    } <br> <br>    capOverlay(ghWndCap, bOverlay); <br>    toolbarModifyState(ghWndToolBar, BTN_OVERLAY, bOverlay ? BTNST_DOWN : BTNST_UP); <br>    CheckMenuItem(GetMenu(ghWndMain), IDM_O_OVERLAY, <br>        MF_BYCOMMAND | (bOverlay ? MF_CHECKED : MF_UNCHECKED)); <br> <br>    gbOverlay = bOverlay; <br> <br>    if (bOverlay == TRUE) { <br>        vidcapSetLive(FALSE); <br>    } <br>} <br> <br>void <br>vidcapSetCaptureFile(LPSTR pFileName) <br>{ <br>    char achBuffer[_MAX_PATH]; <br> <br>    if ((pFileName != NULL) &amp;&amp; (lstrlen(pFileName)  &gt; 0)) { <br>        // record the capture filename <br>        if (lstrcmp(gachCaptureFile, pFileName)) { <br>            lstrcpy(gachCaptureFile, pFileName); <br>        } <br> <br>        // and set window title <br>        wsprintf(achBuffer, "%s - %s", gachAppTitle, pFileName); <br>    } else { <br>        gachCaptureFile[0] = 0; <br>        lstrcpy(achBuffer, gachAppTitle); <br>    } <br> <br>    capFileSetCaptureFile(ghWndCap, gachCaptureFile); <br>    SetWindowText(ghWndMain, achBuffer); <br>} <br> <br>/* --- winproc and message handling --------------------------------------- */ <br> <br>/* <br> * called from WM_COMMAND processing if the <br> * message is from the toolbar. iButton contains the <br> * button ID in the lower 8 bits, and the flags in the upper 8 bits/ <br> */ <br>LONG FAR PASCAL <br>toolbarCommand (HWND hWnd, int iButton, HWND hwndToolbar) <br>{ <br>    int iBtnPos, iState, iActivity, iString; <br> <br> <br>    // check repeat bit <br>    if (iButton &amp; BTN_REPEAT) { <br>        return(0); <br>    } <br>    iButton &amp;= 0xff; <br> <br>    iBtnPos = toolbarIndexFromButton(hwndToolbar, iButton); <br>    iState = toolbarStateFromButton(hwndToolbar, iButton); <br>    iActivity = toolbarActivityFromButton(hwndToolbar, iButton); <br>    iString = toolbarStringFromIndex(hwndToolbar, iBtnPos); <br> <br>    switch(iActivity) { <br> <br>    case BTNACT_MOUSEDOWN: <br>    case BTNACT_KEYDOWN: <br>    case BTNACT_MOUSEMOVEON: <br>        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(iString)); <br>        break; <br> <br>    case BTNACT_MOUSEMOVEOFF: <br>        statusUpdateStatus(ghWndStatus, NULL); <br>        break; <br> <br>    case BTNACT_MOUSEUP: <br>    case BTNACT_KEYUP: <br> <br>        statusUpdateStatus(ghWndStatus, NULL); <br>        switch(iButton) { <br>        case BTN_SETFILE: <br>            SendMessage(hWnd, WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_F_SETCAPTUREFILE, NULL, 0)); <br>                break; <br> <br>        case BTN_EDITCAP: <br>            // edit captured video <br>            SendMessage(hWnd, WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_F_EDITVIDEO, NULL, 0)); <br>            break; <br> <br>        case BTN_LIVE: <br>            SendMessage(hWnd,WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_O_PREVIEW, NULL, 0)); <br>            break; <br> <br>        case BTN_CAPFRAME: <br>            SendMessage(hWnd, WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_C_CAPTUREFRAME, NULL, 0)); <br>            break; <br> <br>        case BTN_CAPSEL: <br>            // capture selected frames <br>            SendMessage(hWnd, WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_C_CAPSEL, NULL, 0)); <br>            break; <br> <br>        case BTN_CAPAVI: <br>            SendMessage(hWnd,WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_C_CAPTUREVIDEO, NULL, 0)); <br>            break; <br> <br>        case BTN_CAPPAL: <br>            SendMessage(hWnd, WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_C_PALETTE, NULL, 0)); <br>            break; <br> <br>        case BTN_OVERLAY: <br>            SendMessage(hWnd, WM_COMMAND, <br>                GET_WM_COMMAND_MPS(IDM_O_OVERLAY, NULL, 0)); <br>            break; <br>        } <br>        break; <br>    } <br>    return(0); <br>} <br> <br> <br>/* <br> * Put up a dialog to allow the user to select a capture file. <br> */ <br>LONG FAR PASCAL <br>cmdSetCaptureFile(HWND hWnd) <br>{ <br>    OPENFILENAME ofn ; <br>    LPSTR p; <br>    char         achFileName[_MAX_PATH]; <br>    char         achBuffer[_MAX_PATH] ; <br>    UINT         wError ; <br>    HANDLE hFilter; <br>    int oldhelpid; <br> <br> <br>    // Get current capture file name and <br>    // then try to get the new capture file name <br>    if (wError = capFileGetCaptureFile(ghWndCap, achFileName, <br>                                sizeof(achFileName))) { <br> <br>        // Get just the path info <br>        // Terminate the full path at the last backslash <br>        lstrcpy (achBuffer, achFileName); <br>        for (p = achBuffer + lstrlen(achBuffer); p &gt; achBuffer; p--) { <br>            if (*p == '\\') { <br>                *(p+1) = '\0'; <br>                break; <br>            } <br>        } <br> <br>        _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>        ofn.lStructSize = sizeof(OPENFILENAME) ; <br>        ofn.hwndOwner = hWnd ; <br> <br>        //load filters from resource stringtable <br>        hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_AVI), RT_RCDATA); <br>        if ((hFilter = LoadResource(ghInstApp, hFilter)) == NULL) { <br>            ofn.lpstrFilter = NULL; <br>        } else { <br>            ofn.lpstrFilter = LockResource(hFilter); <br>        } <br> <br>        ofn.nFilterIndex = 0 ; <br>        ofn.lpstrFile = achFileName ; <br>        ofn.nMaxFile = sizeof(achFileName) ; <br>        ofn.lpstrFileTitle = NULL; <br>        ofn.lpstrTitle = tmpString(IDS_TITLE_SETCAPTUREFILE); <br>        ofn.nMaxFileTitle = 0 ; <br>        ofn.lpstrInitialDir = achBuffer; <br>        ofn.Flags = <br>        OFN_HIDEREADONLY | <br>        OFN_NOREADONLYRETURN | <br>        OFN_PATHMUSTEXIST ; <br> <br>        // set help context for dialog <br>        oldhelpid = SetCurrentHelpContext(IDA_SETCAPFILE); <br> <br>        if (GetOpenFileName(&amp;ofn)) { <br>            OFSTRUCT os; <br> <br>            vidcapSetCaptureFile(achFileName); <br> <br> <br>            /* <br>             * if this is a new file, then invite the user to <br>             * allocate some space <br>             */ <br>            if (OpenFile(achFileName, &amp;os, OF_EXIST) == HFILE_ERROR) { <br> <br>                /* <br>                 * show the allocate file space dialog to encourage <br>                 * the user to pre-allocate space <br>                 */ <br>                if (DoDialog(hWnd, IDD_AllocCapFileSpace, AllocCapFileProc, 0)) { <br> <br>    // ensure repaint after dismissing dialog before <br>    // possibly lengthy operation <br>    UpdateWindow(ghWndMain); <br> <br>                    // If user has hit OK then alloc requested capture file space <br>                    if (! capFileAlloc(ghWndCap, (long) gwCapFileSize * ONEMEG)) { <br>                        MessageBoxID(IDS_ERR_CANT_PREALLOC, <br>                                    MB_OK | MB_ICONEXCLAMATION) ; <br>                    } <br>                } <br>            } <br> <br>        } <br> <br>        // restore old help context <br>        SetCurrentHelpContext(oldhelpid); <br> <br>        if (hFilter) { <br>            UnlockResource(hFilter); <br>        } <br> <br>    } <br>    return(0); <br>} <br> <br>/* <br> * query the user for a filename, and then save the captured video <br> * to that file <br> */ <br>LONG FAR PASCAL <br>cmdSaveVideoAs(HWND hWnd) <br>{ <br>    OPENFILENAME ofn ; <br>    char         achFileName[_MAX_PATH]; <br>    UINT         wError ; <br>    HANDLE       hFilter; <br>    int          oldhelpid; <br> <br> <br> <br>    // Get the current capture file name and <br>    // then get the substitute file name to save video in <br>    if (wError = capFileGetCaptureFile(ghWndCap, achFileName, sizeof(achFileName))) { <br> <br>        _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>        ofn.lStructSize = sizeof(OPENFILENAME) ; <br>        ofn.hwndOwner = hWnd ; <br> <br>        //load filters from resource stringtable <br>        hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_AVI), RT_RCDATA); <br>        if ((hFilter = LoadResource(ghInstApp, hFilter)) == NULL) { <br>            ofn.lpstrFilter = NULL; <br>        } else { <br>            ofn.lpstrFilter = LockResource(hFilter); <br>        } <br> <br>        ofn.nFilterIndex = 0 ; <br>        ofn.lpstrFile = achFileName ; <br>        ofn.nMaxFile = sizeof(achFileName) ; <br>        ofn.lpstrFileTitle = NULL ; <br>        ofn.lpstrTitle = tmpString(IDS_TITLE_SAVEAS); <br>        ofn.nMaxFileTitle = 0 ; <br>        ofn.lpstrInitialDir = NULL ; <br>        ofn.Flags = <br>        OFN_OVERWRITEPROMPT |  OFN_PATHMUSTEXIST ; <br> <br> <br>        // set help context <br>        oldhelpid = SetCurrentHelpContext(IDA_SAVECAPFILE); <br> <br>        if (GetSaveFileName(&amp;ofn)) { <br>            // If the user has hit OK then set save file name <br>            capFileSaveAs(ghWndCap, achFileName) ; <br>        } <br> <br>        SetCurrentHelpContext(oldhelpid); <br> <br>        if (hFilter) { <br>            UnlockResource(hFilter); <br>        } <br>    } <br>    return(0); <br>} <br> <br> <br>/* <br> * Put up a dialog to allow the user to select a palette file and then <br> * load that palette <br> */ <br>LONG FAR PASCAL <br>cmdLoadPalette(HWND hWnd) <br>{ <br>    OPENFILENAME ofn ; <br>    char         achFileName[_MAX_PATH]; <br>    HANDLE       hFilter; <br>    int          oldhelpid; <br> <br> <br> <br>    achFileName[0] = 0; <br> <br>    _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hWnd; <br> <br>    //load filters from resource stringtable <br>    hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_PALETTE), RT_RCDATA); <br>    if ((hFilter = LoadResource(ghInstApp, hFilter)) == NULL) { <br>        ofn.lpstrFilter = NULL; <br>    } else { <br>        ofn.lpstrFilter = LockResource(hFilter); <br>    } <br> <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = achFileName; <br>    ofn.nMaxFile = sizeof(achFileName); <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.lpstrTitle = tmpString(IDS_TITLE_LOADPALETTE); <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.Flags = <br>    OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br> <br> <br>    // set help context id <br>    oldhelpid = SetCurrentHelpContext(IDA_LOADPAL); <br> <br>    if (GetOpenFileName(&amp;ofn)) { <br>        // If the user has hit OK then load palette <br>        capPaletteOpen(ghWndCap, achFileName); <br>    } <br> <br>    SetCurrentHelpContext(oldhelpid); <br> <br>    if (hFilter) { <br>        UnlockResource(hFilter); <br>    } <br>    return(0); <br>} <br> <br>/* <br> * query the user for a filename, and then save the current palette <br> * to that file <br> */ <br>LONG FAR PASCAL <br>cmdSavePalette(HWND hWnd) <br>{ <br>    OPENFILENAME ofn ; <br>    char         achFileName[_MAX_PATH]; <br>    HANDLE       hFilter; <br>    int          oldhelpid; <br> <br> <br>    achFileName[0] = 0; <br> <br>    _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>    ofn.lStructSize = sizeof(OPENFILENAME) ; <br>    ofn.hwndOwner = hWnd ; <br> <br>    //load filters from resource stringtable <br>    hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_PALETTE), RT_RCDATA); <br>    if ((hFilter = LoadResource(ghInstApp, hFilter)) == NULL) { <br>        ofn.lpstrFilter = NULL; <br>    } else { <br>        ofn.lpstrFilter = LockResource(hFilter); <br>    } <br> <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = achFileName; <br>    ofn.nMaxFile = sizeof(achFileName); <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.lpstrTitle = tmpString(IDS_TITLE_SAVEPALETTE); <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.Flags = <br>    OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT; <br> <br>    // set help context for F1 key <br>    oldhelpid = SetCurrentHelpContext(IDA_SAVEPAL); <br> <br>    if (GetSaveFileName(&amp;ofn)) { <br>        // If the user has hit OK then set save file name <br>        capPaletteSave(ghWndCap, achFileName); <br>    } <br> <br>    SetCurrentHelpContext(oldhelpid); <br> <br>    if (hFilter) { <br>        UnlockResource(hFilter); <br>    } <br> <br>    return(0); <br>} <br> <br> <br>/* <br> * query the user for a filename, and then save the current frame <br> * to that file <br> */ <br>LONG FAR PASCAL <br>cmdSaveDIB(HWND hWnd) <br>{ <br>    OPENFILENAME ofn ; <br>    char         achFileName[_MAX_PATH]; <br>    HANDLE       hFilter; <br>    int          oldhelpid; <br> <br> <br>    achFileName[0] = 0; <br> <br>    _fmemset(&amp;ofn, 0, sizeof(OPENFILENAME)) ; <br>    ofn.lStructSize = sizeof(OPENFILENAME) ; <br>    ofn.hwndOwner = hWnd ; <br> <br>    //load filters from resource stringtable <br>    hFilter = FindResource(ghInstApp, MAKEINTRESOURCE(ID_FILTER_DIB), RT_RCDATA); <br>    if ((hFilter = LoadResource(ghInstApp, hFilter)) == NULL) { <br>        ofn.lpstrFilter = NULL; <br>    } else { <br>        ofn.lpstrFilter = LockResource(hFilter); <br>    } <br> <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = achFileName; <br>    ofn.nMaxFile = sizeof(achFileName); <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.lpstrTitle = tmpString(IDS_TITLE_SAVEDIB); <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.Flags = <br>    OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; <br> <br>    // set help context for F1 handling <br>    oldhelpid = SetCurrentHelpContext(IDA_SAVEDIB); <br> <br>    if (GetSaveFileName(&amp;ofn)) { <br> <br>        // If the user has hit OK then set save file name <br>        capFileSaveDIB(ghWndCap, achFileName); <br>    } <br> <br>    SetCurrentHelpContext(oldhelpid); <br> <br>    if (hFilter) { <br>        UnlockResource(hFilter); <br>    } <br> <br>    return(0); <br>} <br> <br>// <br>// MenuProc: Processes All Menu-based Operations <br>// <br>long FAR PASCAL MenuProc(HWND hWnd, UINT wParam, LONG lParam) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:      Application main window handle <br>//  hMenu:     Application menu handle <br>//  wParam:    Menu option <br>//  lParam:    Additional info for any menu option <br>//////////////////////////////////////////////////////////////////////// <br> <br>    BOOL         fResult ; <br>    DWORD        dwSize ; <br>    int          oldhelpid; <br> <br>    HMENU hMenu = GetMenu(hWnd) ; <br> <br>    switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br> <br>case IDC_TOOLBAR: <br>            return toolbarCommand(hWnd, GET_WM_COMMAND_CMD(wParam, lParam), ghWndToolBar); <br> <br>/* --- file --- */ <br>        case IDM_F_SETCAPTUREFILE: <br>            return cmdSetCaptureFile(hWnd); <br> <br>        case IDM_F_SAVEVIDEOAS: <br>            return cmdSaveVideoAs(hWnd); <br>            break; <br> <br>        case IDM_F_ALLOCATESPACE: <br>            if (DoDialog(hWnd, IDD_AllocCapFileSpace, AllocCapFileProc, 0)) { <br> <br>// ensure repaint after dismissing dialog before <br>// possibly lengthy operation <br>UpdateWindow(ghWndMain); <br> <br> <br>                // If user has hit OK then alloc requested capture file space <br>                if (! capFileAlloc(ghWndCap, (long) gwCapFileSize * ONEMEG)) { <br>                    MessageBoxID(IDS_ERR_CANT_PREALLOC, <br>                                MB_OK | MB_ICONEXCLAMATION) ; <br>                } <br>            } <br>            break ; <br> <br>        case IDM_F_EXIT: <br>            DestroyWindow(hWnd) ; <br>            break; <br> <br>        case IDM_F_LOADPALETTE: <br>            return cmdLoadPalette(hWnd); <br> <br>        case IDM_F_SAVEPALETTE: <br>            return cmdSavePalette(hWnd); <br> <br>        case IDM_F_SAVEFRAME: <br>            return cmdSaveDIB(hWnd); <br> <br>        case IDM_F_EDITVIDEO: <br>        { <br>            charachCmdLine[256]; <br>            UINT        u; <br>            BOOLf = TRUE;/* assume the best */ <br>            HCURSOR     hOldCursor; <br> <br>            /* build up the command line "AviEdit -n filename" */ <br>            if (lstrlen(gachCaptureFile) &gt; 0) { <br>                lstrcpy(achCmdLine,"VIDEdit -n "); <br>                lstrcat(achCmdLine, gachCaptureFile); <br> <br>                hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>                u = WinExec(achCmdLine, SW_SHOWNORMAL); <br>                if (u &lt; 32){ <br>            /* report error on forking VidEdit */ <br>                    MessageBoxID(IDS_ERR_VIDEDIT, MB_OK|MB_ICONEXCLAMATION); <br>            f = FALSE; <br>                } <br> <br>                SetCursor(hOldCursor); <br>            } <br>            return f; <br> <br>        } <br> <br> <br>/* --- edit --- */ <br> <br>        case IDM_E_COPY: <br>            capEditCopy(ghWndCap) ; <br>            break; <br> <br>        case IDM_E_PASTEPALETTE: <br>            capPalettePaste(ghWndCap) ; <br>            break; <br> <br>        case IDM_E_PREFS: <br>            { <br>                if (DoDialog(hWnd, IDD_Prefs, PrefsDlgProc, 0)) { <br> <br>                        // write prefs to profile <br> <br>                        // force new brush <br>                        vidframeSetBrush(ghWndFrame, gBackColour); <br> <br>                        // re-do layout <br>                        vidcapLayout(hWnd); <br> <br>                } <br>            } <br>            break; <br> <br>/* --- options --- */ <br> <br>        case IDM_O_PREVIEW: <br>            // Toggle Preview <br>        capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>            vidcapSetLive(!gCapStatus.fLiveWindow) ; <br>            break; <br> <br>        case IDM_O_OVERLAY: <br>            // Toggle Overlay <br>        capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>            vidcapSetOverlay(!gCapStatus.fOverlayWindow); <br>            break ; <br> <br>        case IDM_O_AUDIOFORMAT: <br>#ifdef  USE_ACM <br>            { <br>                ACMFORMATCHOOSE cfmt; <br>                static BOOL fDialogUp = FALSE; <br> <br>                if (fDialogUp) <br>                    return FALSE; <br> <br>                fDialogUp = TRUE; <br>                // Ask the ACM what the largest wave format is..... <br>                acmMetrics(NULL, <br>                            ACM_METRIC_MAX_SIZE_FORMAT, <br>                            &amp;dwSize); <br> <br>                // Get the current audio format <br>                dwSize = max (dwSize, capGetAudioFormatSize (ghWndCap)); <br>                if (glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize)) { <br>                    capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br> <br>    _fmemset (&amp;cfmt, 0, sizeof (ACMFORMATCHOOSE)); <br>    cfmt.cbStruct = sizeof (ACMFORMATCHOOSE); <br>    cfmt.fdwStyle =  ACMFORMATCHOOSE_STYLEF_INITTOWFXSTRUCT; <br>    cfmt.fdwEnum =   ACM_FORMATENUMF_HARDWARE | <br>     ACM_FORMATENUMF_INPUT; <br>    cfmt.hwndOwner = hWnd; <br>    cfmt.pwfx =     glpwfex; <br>    cfmt.cbwfx =    dwSize; <br> <br>    //oldhelpid = SetCurrentHelpContext(IDA_AUDIOSETUP); <br>    if (!acmFormatChoose(&amp;cfmt)) { <br>capSetAudioFormat(ghWndCap, glpwfex, (WORD)glpwfex-&gt;cbSize + <br>  sizeof (WAVEFORMATEX)) ; <br>mmWriteProfileBinary(gachAppTitle, "WaveFormatBinary", <br>     (LPVOID) glpwfex, glpwfex-&gt;cbSize + <br>     sizeof (WAVEFORMATEX)); <br>    } <br>    //SetCurrentHelpContext(oldhelpid); <br> <br>    GlobalFreePtr(glpwfex) ; <br>} <br>                fDialogUp = FALSE; <br>            } <br>#else <br>            { <br>                // Get current audio format and then find required format <br>                dwSize = capGetAudioFormatSize (ghWndCap);   <br>                glpwfex = (LPWAVEFORMATEX) GlobalAllocPtr(GHND, dwSize) ; <br>                capGetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br> <br>                if (DoDialog(hWnd, IDD_AudioFormat, AudioFormatProc, 0)) { <br>                        // If the user has hit OK, set the new audio format <br>                        capSetAudioFormat(ghWndCap, glpwfex, (WORD)dwSize) ; <br>mmWriteProfileBinary(gachAppTitle, "WaveFormatBinary", <br> (LPVOID) glpwfex, dwSize); <br>                } <br>                GlobalFreePtr(glpwfex) ; <br>            } <br>#endif <br>            break ; <br> <br>        case IDM_O_VIDEOFORMAT: <br>            if (gCapDriverCaps.fHasDlgVideoFormat) { <br>                // Only if the driver has a "Video Format" dialog box <br>                oldhelpid = SetCurrentHelpContext(IDA_VIDFORMAT); <br>                if (capDlgVideoFormat(ghWndCap)) {  // If successful, <br>                    // Get the new image dimension and center capture window <br>                    capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>                    vidcapLayout(hWnd); <br>                } <br>                SetCurrentHelpContext(oldhelpid); <br>            } <br>            break; <br> <br>        case IDM_O_VIDEOSOURCE: <br>            if (gCapDriverCaps.fHasDlgVideoSource) { <br>                // Only if the driver has a "Video Source" dialog box <br>                oldhelpid = SetCurrentHelpContext(IDA_VIDSOURCE); <br>                capDlgVideoSource(ghWndCap) ; <br>                capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>                vidcapLayout(hWnd); <br>                SetCurrentHelpContext(oldhelpid); <br>            } <br>            break ; <br> <br>        case IDM_O_VIDEODISPLAY: <br>            if (gCapDriverCaps.fHasDlgVideoDisplay) { <br>                // Only if the driver has a "Video Display" dialog box <br>                oldhelpid = SetCurrentHelpContext(IDA_VIDDISPLAY); <br>                capDlgVideoDisplay(ghWndCap) ; <br>                capGetStatus(ghWndCap, &amp;gCapStatus, sizeof(CAPSTATUS)) ; <br>                SetCurrentHelpContext(oldhelpid); <br>            } <br>            break ; <br> <br>        case IDM_O_CHOOSECOMPRESSOR: <br>            oldhelpid = SetCurrentHelpContext(IDA_COMPRESSION); <br>            capDlgVideoCompression(ghWndCap); <br>            SetCurrentHelpContext(oldhelpid); <br>            break; <br> <br>        // Select a driver to activate <br>        case IDM_O_DRIVER0: <br>        case IDM_O_DRIVER1: <br>        case IDM_O_DRIVER2: <br>        case IDM_O_DRIVER3: <br>        case IDM_O_DRIVER4: <br>        case IDM_O_DRIVER5: <br>        case IDM_O_DRIVER6: <br>        case IDM_O_DRIVER7: <br>        case IDM_O_DRIVER8: <br>        case IDM_O_DRIVER9: <br>            vidcapInitHardware(ghWndMain, ghWndCap, wParam - IDM_O_DRIVER0); <br>            break; <br> <br>/* --- capture --- */ <br> <br> <br>        case IDM_C_PALETTE: <br>            if (DoDialog(hWnd, IDD_MakePalette, MakePaletteProc, 0)) { <br>                // Palette is created within the dialog <br>                bDefaultPalette = FALSE; <br>            } <br>            break; <br> <br>        case IDM_C_CAPTUREVIDEO: <br> <br>            // warn user if he is still using the default palette <br>            if (bDefaultPalette) { <br> <br>LPBITMAPINFOHEADER lpbi; <br>int sz; <br> <br>// fUsingDefaultPalette will be TRUE even if the <br>// current capture format is non-palettised. This is a <br>// bizarre decision of Jay's. <br> <br>sz = (int)capGetVideoFormatSize(ghWndCap); <br>lpbi = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, sz); <br> <br>if (lpbi) {    // We can warn s/he <br>    if (capGetVideoFormat(ghWndCap, lpbi, sz) &amp;&amp; <br>(lpbi-&gt;biCompression == BI_RGB) &amp;&amp; <br>(lpbi-&gt;biBitCount &lt;= 8)) { <br> <br>CAPSTATUS cs; <br> <br>// if we've warned him once, we can forget it <br>bDefaultPalette = FALSE; <br> <br>capGetStatus(ghWndCap, &amp;cs, sizeof(cs)); <br> <br>if (cs.fUsingDefaultPalette) { <br> <br>    if (MessageBoxID(IDS_WARN_DEFAULT_PALETTE, <br>            MB_OKCANCEL| MB_ICONEXCLAMATION)== IDCANCEL) { <br>break; <br>    } <br>} <br>    } <br>    LocalFree(lpbi); <br>} <br>            } <br> <br>            // Invoke a Dlg box to setup all the params <br>            if (DoDialog(hWnd, IDD_CapSetUp, CapSetUpProc, 0)) { <br> <br>                // set the defaults we won't bother the user with <br>                gCapParms.fMakeUserHitOKToCapture = !gCapParms.fMCIControl; <br>                gCapParms.wPercentDropForError = 10; <br> <br>                // fUsingDOSMemory is obsolete, but we use it here as <br>                // a flag which is TRUE if "CapturingToDisk" <br>                // The number of video buffers should be enough to get through <br>                // disk seeks and thermal recalibrations if "CapturingToDisk" <br>                // If "CapturingToMemory", get as many buffers as we can. <br> <br>                gCapParms.wNumVideoRequested =  <br>                        gCapParms.fUsingDOSMemory ? 32 : 1000; <br> <br>                // Don't abort on the left mouse anymore! <br>                gCapParms.fAbortLeftMouse = FALSE; <br>                gCapParms.fAbortRightMouse = TRUE; <br> <br>                // If the Driver is Scrncap.drv, the following values are special <br> <br>                // If wChunkGranularity is zero, the granularity will be set to the <br>                // disk sector size. <br>                gCapParms.wChunkGranularity = (gbIsScrncap ? 32 : 0); <br> <br>                // Scrncap requires a callback for the message pump <br>                capSetCallbackOnYield(ghWndCap,  <br>                        (gbIsScrncap ? fpYieldCallback : NULL)); <br> <br>                // If the user has hit OK, set the new setup info <br>                capCaptureSetSetup(ghWndCap, &amp;gCapParms, sizeof(CAPTUREPARMS)) ; <br>            } else { <br>                break; <br>            } <br> <br>            // if no capture file, get that <br>            if (lstrlen(gachCaptureFile) &lt;= 0) { <br>                cmdSetCaptureFile(hWnd); <br>                if (lstrlen(gachCaptureFile) &lt;= 0) { <br>                    break; <br>                } <br>            } <br> <br>            // Capture video sequence <br>            fResult = capCaptureSequence(ghWndCap) ; <br>            break; <br> <br>        case IDM_C_CAPTUREFRAME: <br>            // Turn off overlay / preview (gets turned off by frame capture) <br>            vidcapSetLive(FALSE); <br>            vidcapSetOverlay(FALSE); <br> <br>            // Grab a frame <br>            fResult = capGrabFrameNoStop(ghWndCap) ; <br>            break; <br> <br> <br>        case IDM_C_CAPSEL: <br>            { <br>                FARPROC fproc; <br> <br>                // if no capture file, get that <br>                if (lstrlen(gachCaptureFile) &lt;= 0) { <br>                    cmdSetCaptureFile(hWnd); <br>                    if (lstrlen(gachCaptureFile) &lt;= 0) { <br>                        break; <br>                    } <br>                } <br> <br>                fproc = MakeProcInstance(CapFramesProc, ghInstApp); <br>                DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_CAPFRAMES), hWnd, (DLGPROC) fproc); <br>                FreeProcInstance(fproc); <br>            } <br>            break; <br> <br>#ifdef DEBUG <br>        case IDM_C_TEST: <br>    nTestCount = 0; <br>    // Intentional fall through <br>     <br>        case IDM_C_TESTAGAIN: <br>            // set the defaults we won't bother the user with <br>            gCapParms.fMakeUserHitOKToCapture = FALSE; <br>            gCapParms.wPercentDropForError = 100; <br> <br>            gCapParms.wNumVideoRequested =  </code></pre>
<p>
</p>
<pre><code>gCapParms.fUsingDOSMemory ? 32 : 1000; <br> <br>            // Don't abort on the left mouse anymore! <br>            gCapParms.fAbortLeftMouse = FALSE; <br>            gCapParms.fAbortRightMouse = TRUE; <br> <br>            // If wChunkGranularity is zero, the granularity will be set to the <br>            // disk sector size. <br>            gCapParms.wChunkGranularity = (gbIsScrncap ? 32 : 0); <br> <br>            // If the user has hit OK, set the new setup info <br>            capCaptureSetSetup(ghWndCap, &amp;gCapParms, sizeof(CAPTUREPARMS)) ; <br> <br>            // if no capture file, get that <br>            if (lstrlen(gachCaptureFile) &lt;= 0) { <br>                cmdSetCaptureFile(hWnd); <br>                if (lstrlen(gachCaptureFile) &lt;= 0) { <br>                    break; <br>                } <br>            } <br>     <br>    { <br>char buf[80]; <br> <br>                gCapParms.wNumVideoRequested = 10; <br>                gCapParms.wNumAudioRequested = 5; <br>gCapParms.fLimitEnabled = TRUE; <br>if (gCapParms.wTimeLimit == 0) <br>    gCapParms.wTimeLimit = 5; <br>capCaptureSetSetup(ghWndCap, &amp;gCapParms, sizeof(CAPTUREPARMS)) ; <br> <br>// Capture video sequence <br>                fResult = capCaptureSequence(ghWndCap) ; <br> <br>wsprintf (buf, "TestCount = %d", nTestCount++); <br>statusUpdateStatus(ghWndStatus, buf); <br> <br>// Hold down the right mouse button to abort <br>if (!GetAsyncKeyState(VK_RBUTTON) &amp; 0x0001) <br>    PostMessage (hWnd, WM_COMMAND, IDM_C_TESTAGAIN, 0L); <br>            } <br>            break; <br>#endif <br>     <br>/* --- help --- */ <br>        case IDM_H_CONTENTS: <br>            HelpContents(); <br>            break; <br> <br>        case IDM_H_ABOUT: <br>            ShellAbout( <br>                hWnd, <br>                "VidCap", <br>                "Video Capture Tool", <br>                LoadIcon(ghInstApp,  gachIconName) <br>            ); <br>            //DoDialog(hWnd, IDD_HelpAboutBox, AboutProc, 0); <br>            break ; <br> <br> <br>    } <br> <br>    return 0L ; <br>} <br> <br>/* --- menu help and enable/disable handling ------------------------ */ <br> <br>// write or clear status line help text when the user brings up or cancels a <br>// menu. This depends on there being strings in the string table with <br>// the same ID as the corresponding menu item. <br>// Help text for the items along the menu bar (File, Edit etc) depends <br>// on IDM_FILE, IDM_EDIT being defined with values 100 apart in the same <br>// order as their index in the menu <br>void <br>MenuSelect(HWND hwnd, UINT cmd, UINT flags, HMENU hmenu) <br>{ <br>    if ((LOWORD(flags) == 0xffff) &amp;&amp; (hmenu == NULL)) { <br>        //menu closing - remove message <br>        statusUpdateStatus(ghWndStatus, NULL); <br>    } else if ( (flags &amp; (MF_SYSMENU|MF_POPUP)) == (MF_SYSMENU|MF_POPUP)) { <br>        // the system menu itself <br>        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(IDM_SYSMENU)); <br>    } else if ((flags &amp; MF_POPUP) == 0) { <br>        // a menu command item <br>        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(cmd)); <br>    } else { <br>        //a popup menu - we need to search to find which one. <br>        // note that the cmd item in Win16 will now have a <br>        // menu handle, whereas in Win32 it has an index. <br>        // NOTE: this code assumes that the menu items <br>        // are #defined 100 apart in the same order, starting <br>        // with IDM_FILE <br>#ifdef _WIN32 <br>        statusUpdateStatus(ghWndStatus, MAKEINTRESOURCE(IDM_FILE + (cmd * 100))); <br>#else <br>        int i,c; <br>        HMENU hmenuMain;  <br> <br>        hmenuMain = GetMenu(hWnd); <br>        c = GetMenuItemCount(hmenuMain); <br> <br>        for(i = 0; i &lt; c; i++) { <br>            if (hmenu == GetSubMenu(hmenuMain, i)) { <br>                statusUpdateStatus(MAKEINTRESOURCE(IDM_FILE + (cmd*100))); <br>                return(0); <br>            } <br>        } <br>        statusUpdateStatus(NULL); <br>#endif <br>    } <br>} <br> <br>// a popup menu is being selected - enable or disable menu items <br>int <br>InitMenuPopup( <br>    HWND hwnd, <br>    HMENU hmenu, <br>    int index <br>) <br>{ <br>    int i = MF_ENABLED; <br>    CAPSTATUS cs; <br>    BOOL bUsesPalettes; <br> <br>    capGetStatus(ghWndCap, &amp;cs, sizeof(cs)); <br> <br>    // try to see if the driver uses palettes <br>    if ((cs.hPalCurrent != NULL) || (cs.fUsingDefaultPalette)) { <br>        bUsesPalettes = TRUE; <br>    } else { <br>        bUsesPalettes = FALSE; <br>    } <br> <br> <br>    switch(index) { <br>    case 0:         // IDM_FILE <br> <br>        if (lstrlen(gachCaptureFile) &lt;= 0) { <br>            i = MF_GRAYED; <br>        } <br>        // save as enabled only if we have a capture file <br>        EnableMenuItem(hmenu, IDM_F_SAVEVIDEOAS, i); <br>        // edit video possible only if we have a capture file AND we've <br>        // captured something <br>        EnableMenuItem(hmenu, IDM_F_EDITVIDEO, <br>            (cs.dwCurrentVideoFrame &gt; 0) ? i : MF_GRAYED); <br> <br>        // allow save palette if there is one <br>        EnableMenuItem(hmenu, IDM_F_SAVEPALETTE, <br>            (cs.hPalCurrent != NULL) ? MF_ENABLED:MF_GRAYED); <br> <br>        // allow load palette if the driver uses palettes <br>        EnableMenuItem(hmenu, IDM_F_LOADPALETTE, <br>            bUsesPalettes ? MF_ENABLED : MF_GRAYED); <br> <br>        break; <br> <br>    case 1:         // IDM_EDIT <br> <br>        // paste palettes if driver uses them and there is one pastable <br>        EnableMenuItem(hmenu, IDM_E_PASTEPALETTE, <br>            (bUsesPalettes &amp;&amp; IsClipboardFormatAvailable(CF_PALETTE)) ? MF_ENABLED:MF_GRAYED); <br> <br>        break; <br> <br>    case 2:         // IDM_OPTIONS <br> <br>        EnableMenuItem(hmenu, IDM_O_AUDIOFORMAT, <br>            cs.fAudioHardware ? MF_ENABLED : MF_GRAYED); <br> <br>        EnableMenuItem(hmenu, IDM_O_OVERLAY, <br>            gCapDriverCaps.fHasOverlay ? MF_ENABLED:MF_GRAYED); <br> <br>        EnableMenuItem(hmenu, IDM_O_VIDEOFORMAT, <br>            gCapDriverCaps.fHasDlgVideoFormat ? MF_ENABLED:MF_GRAYED); <br> <br>        EnableMenuItem(hmenu, IDM_O_VIDEODISPLAY, <br>            gCapDriverCaps.fHasDlgVideoDisplay ? MF_ENABLED:MF_GRAYED); <br> <br>        EnableMenuItem(hmenu, IDM_O_VIDEOSOURCE, <br>            gCapDriverCaps.fHasDlgVideoSource ? MF_ENABLED:MF_GRAYED); <br> <br>        EnableMenuItem(hmenu, IDM_O_PREVIEW, <br>                gbHaveHardware ? MF_ENABLED:MF_GRAYED); <br> <br> <br>    case 3:     // IDM_CAPTURE <br>        if (!gbHaveHardware) { <br>            i = MF_GRAYED; <br>        } <br>        EnableMenuItem(hmenu, IDM_C_CAPSEL, i); <br>        EnableMenuItem(hmenu, IDM_C_CAPTUREFRAME, i); <br>        EnableMenuItem(hmenu, IDM_C_CAPTUREVIDEO, i); <br>        EnableMenuItem(hmenu, IDM_C_PALETTE, (gbHaveHardware &amp;&amp; <br>            gCapDriverCaps.fDriverSuppliesPalettes) ? MF_ENABLED : MF_GRAYED); <br> <br>        break; <br>    } <br>    return(0); <br>} <br> <br> <br> <br> <br>// <br>// MainWndProc: Application Main Window Procedure <br>// <br>LONG FAR PASCAL MainWndProc(HWND hWnd, UINT Message, UINT wParam, LONG lParam) <br>{ <br>//////////////////////////////////////////////////////////////////////// <br>//  hWnd:      Application main window handle <br>//  Message:   Next message to be processed <br>//  wParam:    WORD param for the message <br>//  lParam:    LONG param for the message <br>//////////////////////////////////////////////////////////////////////// <br> <br>    switch (Message) { <br> <br>        static BOOL fMinimized; <br> <br>        case WM_SYSCOMMAND: <br>    if ((wParam &amp; 0xfff0) == SC_MAXIMIZE) <br>    fMinimized = FALSE; <br>    else if ((wParam &amp; 0xfff0) == SC_RESTORE) <br>    fMinimized = FALSE; <br>    else if ((wParam &amp; 0xfff0) == SC_MINIMIZE) <br>    fMinimized = TRUE; <br>    return DefWindowProc(hWnd, Message, wParam, lParam); <br>    break; <br> <br>        case WM_COMMAND: <br>            MenuProc(hWnd, wParam, lParam) ; <br>            break ; <br> <br>        case WM_CREATE: <br>            HelpInit(ghInstApp, "vidcap.hlp", hWnd); <br>            break; <br> <br>        case WM_NCHITTEST: <br>        { <br>            DWORD dw; <br> <br>            dw = DefWindowProc(hWnd, Message, wParam, lParam); <br>            // Don't allow border resize if autosizing <br>            if (gbAutoSizeFrame) { <br>                if (dw &gt;= HTSIZEFIRST &amp;&amp; dw &lt;= HTSIZELAST) <br>                    dw = HTCAPTION; <br>            } <br>            return dw; <br>                 <br>        } <br>            break; <br> <br>        case WM_GETMINMAXINFO: <br>            // Don't allow manual sizing if window locked to the capture size <br>            if (gbHaveHardware &amp;&amp; gbAutoSizeFrame &amp;&amp; !gbInLayout) { <br>                RECT rW; <br> <br>                LPMINMAXINFO lpMMI = (LPMINMAXINFO) lParam; <br> <br>                GetWindowRect (hWnd, &amp;rW); <br>                lpMMI-&gt;ptMinTrackSize.x = rW.right - rW.left; <br>                lpMMI-&gt;ptMinTrackSize.y = rW.bottom - rW.top; <br>                lpMMI-&gt;ptMaxTrackSize = lpMMI-&gt;ptMinTrackSize; <br>            } <br>            break; <br> <br>        case WM_MOVE: <br>    if (!fMinimized) { <br>    vidcapLayout (hWnd); <br>    } <br>    break; <br> <br>        case WM_SIZE: <br>    if (!fMinimized) { <br>    vidcapLayout (hWnd); <br>    } <br>    break; <br> <br>        case WM_MENUSELECT: <br>            { <br>                UINT cmd = GET_WM_MENUSELECT_CMD(wParam, lParam); <br>                UINT flags = GET_WM_MENUSELECT_FLAGS(wParam, lParam); <br>                HMENU hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam); <br> <br>                MenuSelect(hWnd, cmd, flags, hmenu); <br>            } <br>            break; <br> <br>        case WM_INITMENUPOPUP: <br>            { <br>                BOOL bSystem = (BOOL) HIWORD(lParam); <br> <br>                if (!bSystem) { <br>                    return InitMenuPopup(hWnd, <br>                            (HMENU) wParam, (int) LOWORD(lParam)); <br>                } else { <br>                    return(DefWindowProc(hWnd, Message, wParam, lParam)); <br>                } <br>            } <br> <br> <br>        case WM_SYSCOLORCHANGE: <br>            // we don't use this ourselves, but we should pass <br>            // it on to all three children <br>            SendMessage(ghWndFrame, Message, wParam, lParam); <br>            SendMessage(ghWndToolBar, Message, wParam, lParam); <br>            SendMessage(ghWndStatus, Message, wParam, lParam); <br>            return (TRUE); <br> <br> <br>        case WM_PALETTECHANGED: <br>        case WM_QUERYNEWPALETTE: <br>            // Pass the buck to Capture window proc <br>            return SendMessage(ghWndCap, Message, wParam, lParam) ; <br>            break ; <br> <br>        case WM_SETFOCUS: <br>            // the toolbar is the only part that needs the focus <br>            SetFocus(ghWndToolBar); <br>            break; <br> <br> <br>        case WM_ACTIVATEAPP: <br>            if (wParam &amp;&amp; ghWndCap)  <br>                capPreviewRate(ghWndCap, 15); // Fast preview when active <br>            else <br>                capPreviewRate(ghWndCap, 1000); // Slow preview when inactive <br>            break; <br> <br>        case WM_NEXTDLGCTL: <br>            // if anyone is tabbing about, move the focus to the <br>            // toolbar <br>            SetFocus(ghWndToolBar); <br> <br>            // select the correct button to handle moving off one <br>            // end and back on the other end <br>            if (lParam == FALSE) { <br>                // are we moving forwards or backwards ? <br>                if (wParam == 0) { <br>                    // move to next - so select first button <br>                    toolbarSetFocus(ghWndToolBar, TB_FIRST); <br>                } else { <br>                    // move to previous - so select last <br>                    toolbarSetFocus(ghWndToolBar, TB_LAST); <br>                } <br>            } <br>            break; <br> <br>        case WM_PAINT: <br>        { <br>            HDC           hDC ; <br>            PAINTSTRUCT   ps ; <br> <br>            hDC = BeginPaint(hWnd, &amp;ps) ; <br> <br>            // Included in case the background is not a pure color <br>            SetBkMode(hDC, TRANSPARENT) ; <br> <br>            EndPaint(hWnd, &amp;ps) ; <br>            break ; <br>        } <br> <br>        case WM_CLOSE: <br>            // Disable and free all the callbacks  <br>            capSetCallbackOnError(ghWndCap, NULL) ; <br>if (fpErrorCallback) { <br>            FreeProcInstance(fpErrorCallback) ; <br>fpErrorCallback = NULL; <br>} <br> <br>            capSetCallbackOnStatus(ghWndCap, NULL) ; <br>if (fpStatusCallback) { <br>            FreeProcInstance(fpStatusCallback) ; <br>fpStatusCallback = NULL; <br>} <br> <br>            capSetCallbackOnYield(ghWndCap, NULL) ; <br>if (fpYieldCallback) { <br>            FreeProcInstance(fpYieldCallback) ; <br>fpYieldCallback = NULL; <br>} <br> <br>            // Disconnect the current capture driver <br>            capDriverDisconnect (ghWndCap); <br> <br>            // Destroy child windows, modeless dialogs, then this window... <br>            // DestroyWindow(ghWndCap) ; <br>            DestroyWindow(hWnd) ; <br>            break ; <br> <br>        case WM_DESTROY: <br>            { <br>                // remember window size and position <br>                // - this will be written to the profile <br>                WINDOWPLACEMENT wp; <br> <br>                wp.length = sizeof (WINDOWPLACEMENT); <br>                GetWindowPlacement(hWnd, &amp;wp); <br> <br>                gWinShow = wp.showCmd; <br>                gWinX = wp.rcNormalPosition.left; <br>                gWinY = wp.rcNormalPosition.top; <br>                gWinCX = RECTWIDTH(wp.rcNormalPosition); <br>                gWinCY = RECTHEIGHT(wp.rcNormalPosition); <br> <br>                // write defaults out to the registry <br>                vidcapWriteProfile(); <br>                vidcapWriteSettingsProfile(); <br> <br>                HelpShutdown(); <br> <br>            } <br> <br>            PostQuitMessage(0) ; <br>            break ; <br> <br>        default: <br>            return DefWindowProc(hWnd, Message, wParam, lParam) ; <br>    } <br> <br>    return 0L; <br>}   // End of MainWndProc </code></pre>
<p>&nbsp;</p></body>
</HTML>
