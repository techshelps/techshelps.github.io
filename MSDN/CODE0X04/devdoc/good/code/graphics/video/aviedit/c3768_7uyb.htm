<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUDIO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3773"></a>AUDIO.C</h2>
<pre><code>/**************************************************************************** <br> * <br> *  AUDIO.C <br> * <br> *  Simple routines to play audio using an AVIStream to get data. <br> * <br> *  Uses global variables, so only one instance at a time. <br> *  (Usually, there's only one sound card, so this isn't so bad. <br> * <br> **************************************************************************/ <br> <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define STRICT <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "muldiv32.h" <br>#include &lt;vfw.h&gt; <br>#include "audio.h" <br> <br>/*--------------------------------------------------------------+ <br>| ****************** AUDIO PLAYING SUPPORT ******************** | <br>+--------------------------------------------------------------*/ <br> <br>static  HWAVEOUT        shWaveOut = 0;  /* Current MCI device ID */ <br>static  LONG            slBegin; <br>static  LONG            slCurrent; <br>static  LONG            slEnd; <br>static  BOOL            sfLooping; <br>static  BOOL            sfPlaying = FALSE; <br> <br>#define MAX_AUDIO_BUFFERS       16 <br>#define MIN_AUDIO_BUFFERS       2 <br>#define AUDIO_BUFFER_SIZE       16384 <br> <br>static  WORD            swBuffers;          // total # buffers <br>static  WORD            swBuffersOut;       // buffers device has <br>static  WORD            swNextBuffer;       // next buffer to fill <br>static  LPWAVEHDR       salpAudioBuf[MAX_AUDIO_BUFFERS]; <br> <br>static  PAVISTREAM      spavi;              // stream we're playing <br>static  LONG            slSampleSize;       // size of an audio sample <br> <br>static  LONG            sdwBytesPerSec; <br>static  LONG            sdwSamplesPerSec; <br> <br>/*---------------------------------------------------------------+ <br>| aviaudioCloseDevice -- close the open audio device, if any.    | <br>+---------------------------------------------------------------*/ <br>void aviaudioCloseDevice(void) <br>{ <br>    if (shWaveOut) <br>    { <br>while (swBuffers &gt; 0) <br>{ <br>--swBuffers; <br>waveOutUnprepareHeader(shWaveOut, salpAudioBuf[swBuffers], <br>sizeof(WAVEHDR)); <br>GlobalFreePtr((LPSTR) salpAudioBuf[swBuffers]); <br>} <br>waveOutClose(shWaveOut); <br> <br>shWaveOut = NULL; <br>    } <br>} <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioOpenDevice -- get ready to play waveform data.        | <br>+--------------------------------------------------------------*/ <br>BOOL CALLBACK aviaudioOpenDevice(HWND hwnd, PAVISTREAM pavi) <br>{ <br>    MMRESULT            mmResult; <br>    LPVOID              lpFormat; <br>    LONG                cbFormat; <br>    AVISTREAMINFO       strhdr; <br> <br>    if (!pavi)          // no wave data to play <br>return FALSE; <br> <br>    if (shWaveOut)      // already something playing <br>return TRUE; <br> <br>    spavi = pavi; <br> <br>    AVIStreamInfo(pavi, &amp;strhdr, sizeof(strhdr)); <br> <br>    slSampleSize = (LONG) strhdr.dwSampleSize; <br>    if (slSampleSize &lt;= 0 || slSampleSize &gt; AUDIO_BUFFER_SIZE) <br>return FALSE; <br> <br>    AVIStreamFormatSize(pavi, 0, &amp;cbFormat); <br> <br>    lpFormat = GlobalAllocPtr(GHND, cbFormat); <br>    if (!lpFormat) <br>return FALSE; <br> <br>    AVIStreamReadFormat(pavi, 0, lpFormat, &amp;cbFormat); <br> <br>    sdwSamplesPerSec = ((LPWAVEFORMAT) lpFormat)-&gt;nSamplesPerSec; <br>    sdwBytesPerSec = ((LPWAVEFORMAT) lpFormat)-&gt;nAvgBytesPerSec; <br> <br>    mmResult = waveOutOpen(&amp;shWaveOut, (UINT)WAVE_MAPPER, lpFormat, <br>(DWORD) (UINT) hwnd, 0L, CALLBACK_WINDOW); <br>    // <br>    // Maybe we failed because someone is playing sound already. <br>    // Shut any sound off, and try once more before giving up. <br>    // <br>    if (mmResult) { <br>sndPlaySound(NULL, 0); <br>mmResult = waveOutOpen(&amp;shWaveOut, (UINT)WAVE_MAPPER, lpFormat, <br>(DWORD) (UINT)hwnd, 0L, CALLBACK_WINDOW); <br>    } <br> <br>    if (mmResult != 0) <br>    { <br>/* Show error message here? */ <br>return FALSE; <br>    } <br> <br>    for (swBuffers = 0; swBuffers &lt; MAX_AUDIO_BUFFERS; swBuffers++) <br>    { <br>if (!(salpAudioBuf[swBuffers] = <br>(LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, <br>(DWORD)(sizeof(WAVEHDR) + AUDIO_BUFFER_SIZE)))) <br>break; <br>salpAudioBuf[swBuffers]-&gt;dwFlags = WHDR_DONE; <br>salpAudioBuf[swBuffers]-&gt;lpData = (LPSTR) salpAudioBuf[swBuffers] <br>    + sizeof(WAVEHDR); <br>salpAudioBuf[swBuffers]-&gt;dwBufferLength = AUDIO_BUFFER_SIZE; <br>if (!waveOutPrepareHeader(shWaveOut, salpAudioBuf[swBuffers], <br>sizeof(WAVEHDR))) <br>continue; <br> <br>GlobalFreePtr((LPSTR) salpAudioBuf[swBuffers]); <br>break; <br>    } <br> <br>    if (swBuffers &lt; MIN_AUDIO_BUFFERS) <br>    { <br>aviaudioCloseDevice(); <br>return FALSE; <br>    } <br> <br>    swBuffersOut = 0; <br>    swNextBuffer = 0; <br> <br>    sfPlaying = FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioTime -                                                | <br>| Return the time in milliseconds corresponding to the          | <br>| currently playing audio sample, or -1 if no audio is playing. | <br>|                                                               | <br>| WARNING: Some sound cards are pretty inaccurate!              | <br>+--------------------------------------------------------------*/ <br>LONG CALLBACK aviaudioTime(void) <br>{ <br>    MMTIME      mmtime; <br> <br>    if (!sfPlaying) <br>return -1; <br> <br>    mmtime.wType = TIME_SAMPLES; <br> <br>    waveOutGetPosition(shWaveOut, &amp;mmtime, sizeof(mmtime)); <br> <br>    if (mmtime.wType == TIME_SAMPLES) <br>return AVIStreamSampleToTime(spavi, slBegin) <br>+ muldiv32(mmtime.u.sample, 1000, sdwSamplesPerSec); <br>    else if (mmtime.wType == TIME_BYTES) <br>return AVIStreamSampleToTime(spavi, slBegin) <br>+ muldiv32(mmtime.u.cb, 1000, sdwBytesPerSec); <br>    else <br>return -1; <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioiFillBuffers -                                        | <br>| Fill up any empty audio buffers and ship them out to the      | <br>| device.                                                       | <br>+--------------------------------------------------------------*/ <br>BOOL aviaudioiFillBuffers(void) <br>{ <br>    LONG                lRead; <br>MMRESULT        mmResult; <br>    LONG                lSamplesToPlay; <br> <br>    /* We're not playing, so do nothing. */ <br>    if (!sfPlaying) <br>return TRUE; <br> <br>    while (swBuffersOut &lt; swBuffers) <br>    { <br>if (slCurrent &gt;= slEnd) <br>{ <br>if (sfLooping) <br>{ <br>/* Looping, so go to the beginning. */ <br>slCurrent = slBegin; <br>} <br>    else <br>break; <br>} <br> <br>/* Figure out how much data should go in this buffer */ <br>lSamplesToPlay = slEnd - slCurrent; <br>if (lSamplesToPlay &gt; AUDIO_BUFFER_SIZE / slSampleSize) <br>    lSamplesToPlay = AUDIO_BUFFER_SIZE / slSampleSize; <br> <br>AVIStreamRead(spavi, slCurrent, lSamplesToPlay, <br>      salpAudioBuf[swNextBuffer]-&gt;lpData, <br>      AUDIO_BUFFER_SIZE, <br>      (LPVOID)&amp;salpAudioBuf[swNextBuffer]-&gt;dwBufferLength, <br>      &amp;lRead); <br> <br>if (lRead != lSamplesToPlay) <br>    return FALSE; <br> <br>slCurrent += lRead; <br> <br>mmResult = waveOutWrite(shWaveOut, salpAudioBuf[swNextBuffer],sizeof(WAVEHDR)); <br> <br>if (mmResult != 0) <br>    return FALSE; <br> <br>++swBuffersOut; <br>++swNextBuffer; <br>if (swNextBuffer &gt;= swBuffers) <br>    swNextBuffer = 0; <br>    }//while <br> <br>    if (swBuffersOut == 0 &amp;&amp; slCurrent &gt;= slEnd) <br>aviaudioStop(); <br> <br>    /* We've filled all of the buffers we can or want to. */ <br>    return TRUE; <br>} <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioPlay -- Play audio, starting at a given frame         | <br>|                                                               | <br>+--------------------------------------------------------------*/ <br>BOOL CALLBACK aviaudioPlay(HWND hwnd, PAVISTREAM pavi, LONG lStart, LONG lEnd, BOOL fWait) <br>{ <br>    if (lStart &lt; 0) <br>lStart = AVIStreamStart(pavi); <br> <br>    if (lEnd &lt; 0) <br>lEnd = AVIStreamEnd(pavi); <br> <br>    if (lStart &gt;= lEnd) <br>return FALSE; <br> <br>    if (!aviaudioOpenDevice(hwnd, pavi)) <br>return FALSE; <br> <br>    if (!sfPlaying) <br>    { <br> <br>// We're beginning play, so pause until we've filled the buffers <br>// for a seamless start <br>// <br>waveOutPause(shWaveOut); <br> <br>slBegin = lStart; <br>slCurrent = lStart; <br>slEnd = lEnd; <br>sfPlaying = TRUE; <br>    } <br>    else <br>    { <br>slEnd = lEnd; <br>    } <br> <br>    aviaudioiFillBuffers(); <br> <br>    // <br>    // Now unpause the audio and away it goes! <br>    // <br>    waveOutRestart(shWaveOut); <br> <br>    // <br>    // Caller wants us not to return until play is finished <br>    // <br>    if(fWait) <br>    { <br>while (swBuffersOut &gt; 0) <br>Yield(); <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/*--------------------------------------------------------------------------------+ <br>| aviaudioMessage                                                                 | <br>|                                                                                 | <br>| The WaveProc callback function - Handles wave messages recieved by the          | <br>| window controlling playback.                                                    | <br>+--------------------------------------------------------------------------------*/ <br>void CALLBACK aviaudioMessage(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    if (msg == MM_WOM_DONE) { <br>        --swBuffersOut; <br>        aviaudioiFillBuffers(); <br>    } <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioStop -- stop playing, close the device.               | <br>+--------------------------------------------------------------*/ <br>void CALLBACK aviaudioStop(void) <br>{ <br>MMRESULT        mmResult; <br> <br>    if (shWaveOut != 0) <br>    { <br> <br>mmResult = waveOutReset(shWaveOut); <br> <br>sfPlaying = FALSE; <br> <br>aviaudioCloseDevice(); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
