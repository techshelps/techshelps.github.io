<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AVIEDIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3770"></a>AVIEDIT.C</h2>
<pre><code>/**************************************************************************** <br> * <br> *  AVIEDIT.C <br> * <br> *  Sample program using the AVIFile read/write routines <br> * <br> **************************************************************************/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define STRICT <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include "muldiv32.h" <br>#include &lt;vfw.h&gt; <br> <br>#include "aviedit.h" <br>#include "audio.h" <br> <br>#include &lt;limits.h&gt; <br> <br>#define GlobalSizePtr(lp)   GlobalSize(GlobalPtrHandle(lp)) <br>#define LPPAVIFILE PAVIFILE * <br>typedef BYTE * HPBYTE; <br>typedef UNALIGNED short * HPSHORT; <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>static BOOL gfDefDlgEx = FALSE;         //the recursion flag for message crackers <br> <br>#define BUFSIZE 260 <br>static char gszBuffer[BUFSIZE]; <br>static char gszFileName[BUFSIZE]; <br>static char gszSaveFileName[BUFSIZE]; <br> <br>#define AVI_EDIT_CLASS  "edit" <br>static LPAVISTREAMINFO glpavisi; <br>static int gnSel; <br>int     gSelectedStream = -1;   // Highlight this text area when painting <br>RECT    grcSelectedStream;      // where to highlight <br> <br>char    gszFilter[512];     // for AVIBuildFilter - more than one string! <br>static  HINSTANCE   ghInstApp; <br>static  HWND        ghwndApp; <br>static  HACCEL      ghAccel; <br>static  WNDPROC     gOldEditProc; <br>static  HWND        ghwndEdit; <br> <br>#define SCROLLRANGE  10000 <br>#define MAXNUMSTREAMS   25 <br> <br>int                 gcpavi;                     // # of streams <br>PAVISTREAM          gapavi[MAXNUMSTREAMS];      // the current streams <br>int                 gcpaviSel;                  // num of edit streams <br>PAVISTREAM          gapaviSel[MAXNUMSTREAMS];   // edit streams to put on clipbd <br>int                 gStreamTop[MAXNUMSTREAMS+1];// y position of each stream <br>AVICOMPRESSOPTIONS  gaAVIOptions[MAXNUMSTREAMS];// compression options <br>LPAVICOMPRESSOPTIONS  galpAVIOptions[MAXNUMSTREAMS]; <br>PGETFRAME           gapgf[MAXNUMSTREAMS];       // data for decompressing video <br>HDRAWDIB            ghdd[MAXNUMSTREAMS];        // drawdib handles <br>LONG                galSelStart[MAXNUMSTREAMS]; <br>LONG                galSelLen[MAXNUMSTREAMS]; <br>int                 giFirstAudio = -1;          // 1st audio stream found <br>int                 giFirstVideo = -1;          // 1st video stream found <br> <br>#define             gfVideoFound (giFirstVideo &gt;= 0) <br>#define             gfAudioFound (giFirstAudio &gt;= 0) <br> <br>BOOL                gfPlaying;          // are we currently playing? <br>LONG                glPlayStartTime;    // When did we start playing? <br>LONG                glPlayStartPos;     // Where were we on the scrollbar? <br>LONG                timeStart;          // cached start, end, length <br>LONG                timeEnd; <br>LONG                timeLength; <br>LONG                timehscroll;        // how much arrows scroll HORZ bar <br>int                 nVertSBLen;         // vertical scroll bar <br>int                 nVertHeight; <br>DWORD               gdwMicroSecPerPixel = 1000L;        // scale for video <br>WORD                gwZoom = 2;         // one-half zoom (divide by 4) <br>HWND                ghwndMCI; <br> <br>// buffer for wave data <br>LPVOID lpAudio; <br> <br>// constants for painting <br>#define VSPACE  8       // some vertical spacing <br>#define SELECTVSPACE 4 // height of selection line <br>#define HSPACE  4       // space between frames for video stream <br>#define TSPACE  10      // space for text area about each stream <br>#define AUDIOVSPACE  64 // height of an audio stream at X1 zoom <br> <br>#define HIGHLIGHT       (GetSysColor(COLOR_HIGHLIGHT) ? GetSysColor(COLOR_HIGHLIGHT) : GetSysColor(COLOR_ACTIVECAPTION)) <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>// Macros to get and set the scroll bar to a given millisecond value in the <br>// movie.  Movie lengths can be DWORDS but we only have 16 bits of resolution. <br> <br>#define GetScrollTime(hwnd) \ <br>(timeStart + muldiv32(GetScrollPos(hwnd, SB_HORZ), timeLength, SCROLLRANGE)) <br> <br>#define SetScrollTime(hwnd, time) SetScrollPos(hwnd, SB_HORZ, \ <br>(int)muldiv32((time) - timeStart, SCROLLRANGE, timeLength), TRUE) <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>LRESULT CALLBACK AppWndProc(HWND, UINT, WPARAM, LPARAM ); <br>LRESULT CALLBACK NewEditProc(HWND, UINT, WPARAM, LPARAM ); <br>BOOL CALLBACK    AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>int  ErrMsg (LPSTR sz,...); <br> <br>BOOL MenuHandler( HWND, int ); <br> <br>void editPaste(HWND hwnd, PAVIFILE pfile); <br>void             FrameVideo(HDC hdc, RECT *rcFrame, HBRUSH hbr); <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>static int gfWait = 0; <br> <br>/*----------------------------------------------------------------------------*\ <br>|    StartWait()                                                                | <br>|    Start a wait operation... put up the hourglass if it's the first call      | <br>\*----------------------------------------------------------------------------*/ <br>void StartWait() <br>{ <br>    if (gfWait++ == 0) { <br>SetCursor(LoadCursor(NULL,IDC_WAIT)); <br>    } <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    EndWait()                                                                  | <br>|    Once every one who started a wait is finished, go back to regular cursor   | <br>\*----------------------------------------------------------------------------*/ <br>void EndWait() <br>{ <br>    if (--gfWait == 0) { <br>SetCursor(LoadCursor(NULL,IDC_ARROW)); <br>InvalidateRect(ghwndApp, NULL, TRUE); <br>    } <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    WinYield()                                                                 | <br>|    Code to yield while we're not calling GetMessage.                          | <br>|    Dispatch all messages.  Pressing ESC or closing aborts.                    | <br>\*----------------------------------------------------------------------------*/ <br> <br>BOOL WinYield(void) <br>{ <br>    MSG msg; <br>    BOOL fAbort=FALSE; <br> <br>    while(gfWait &gt; 0 &amp;&amp; PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) <br>    { <br>if (msg.message == WM_KEYDOWN &amp;&amp; msg.wParam == VK_ESCAPE) <br>    fAbort = TRUE; <br>if (msg.message == WM_SYSCOMMAND &amp;&amp; (msg.wParam &amp; 0xFFF0) == SC_CLOSE) <br>    fAbort = TRUE; <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>    } <br>    return fAbort; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    PaintVideo()                                                               | <br>|    Draw a video frame in the specified rect                                   | <br>\*----------------------------------------------------------------------------*/ <br> <br>void PaintVideo(HDC hdc, RECT rcFrame, int iStream, LPBITMAPINFOHEADER lpbi, LONG lCurSamp, LONG lPos) <br>{ <br>    int         iLen; <br>    COLORREF    nCol; <br>    char        szText[BUFSIZE]; <br>    RECT        rc; <br> <br>    // <br>    // If we have a picture, draw it <br>    // <br>    if (lpbi) <br>    { <br>// <br>// use the palette of the first video stream <br>// <br>DrawDibDraw(ghdd[iStream], hdc, <br>    rcFrame.left, rcFrame.top, <br>    rcFrame.right - rcFrame.left, <br>    rcFrame.bottom - rcFrame.top, <br>    lpbi, NULL, <br>    0, 0, -1, -1, <br>    (iStream == giFirstVideo) ? 0 :DDF_BACKGROUNDPAL); <br> <br>iLen = wsprintf(szText, "%ld %ld.%03lds", <br>lCurSamp, lPos / 1000, lPos % 1000); <br>    } <br> <br>    // <br>    // Before or after the movie (or read error) draw GRAY <br>    // <br>    else { <br>SelectObject(hdc,GetStockObject(DKGRAY_BRUSH)); <br> <br>PatBlt(hdc, <br>       rcFrame.left, rcFrame.top, <br>       rcFrame.right - rcFrame.left, <br>       rcFrame.bottom - rcFrame.top, <br>       PATCOPY); <br>iLen = 0; <br>szText[0] = '\0'; <br>    } <br> <br>    // <br>    // print something meaningful under the frame <br>    // <br>    rc.left = rcFrame.left; <br>    rc.right = rcFrame.right - 2 * HSPACE;      // don't overlap text areas <br>    rc.top = rcFrame.bottom + HSPACE; <br>    rc.bottom = rc.top + TSPACE + TSPACE;       // blank out enough space <br>    nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>    ExtTextOut(hdc, rc.left, rc.top, ETO_CLIPPED | ETO_OPAQUE, <br>       &amp;rc, szText, iLen, NULL); <br>    SetBkColor(hdc, nCol); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    PaintAudio()                                                               | <br>|    Draw some samples of audio inside the given rectangle                      | <br>\*----------------------------------------------------------------------------*/ <br> <br>void PaintAudio(HDC hdc, PRECT prc, PAVISTREAM pavi, LONG lStart, LONG lLen) <br>{ <br>    PCMWAVEFORMAT wf; <br>    int i; <br>    int x,y; <br>    int w,h; <br>    BYTE b; <br>    HBRUSH hbr; <br>    RECT rc = *prc; <br>    LONG    lBytes; <br>    LONG    l, lLenOrig = lLen; <br>    LONG    lWaveBeginTime = AVIStreamStartTime(pavi); <br>    LONG    lWaveEndTime   = AVIStreamEndTime(pavi); <br> <br>    // <br>    // We can't draw before the beginning of the stream - adjust <br>    // <br>    if (lStart &lt; lWaveBeginTime) { <br>lLen -= lWaveBeginTime - lStart; <br>lStart = lWaveBeginTime; <br>// right justify the legal samples in the rectangle - don't stretch <br>rc.left = rc.right - (int)muldiv32(rc.right - rc.left, lLen, lLenOrig); <br>    } <br> <br>    // <br>    // We can't draw past the end of the stream <br>    // <br>    if (lStart + lLen &gt; lWaveEndTime) { <br>lLenOrig = lLen; <br>lLen = max(0, lWaveEndTime - lStart);   // maybe nothing to draw! <br>// left justify the legal samples in the rectangle - don't stretch <br>rc.right = rc.left + (int)muldiv32(rc.right - rc.left, lLen, lLenOrig); <br>    } <br> <br>    // Now start working with samples, not time <br>    l = lStart; <br>    lStart = AVIStreamTimeToSample(pavi, lStart); <br>    lLen = AVIStreamTimeToSample(pavi, l + lLen) - lStart; <br> <br>    // <br>    // Get the format of the wave data <br>    // <br>    l = sizeof(wf); <br>    AVIStreamReadFormat(pavi, lStart, &amp;wf, &amp;l); <br>    if (!l) <br>return; <br> <br>    w = rc.right - rc.left; <br>    h = rc.bottom - rc.top; <br> <br>    // <br>    // We were starting before the beginning or continuing past the end. <br>    // We're not painting in the whole original rect --- use a dark background <br>    // <br>    if (rc.left &gt; prc-&gt;left) { <br>SelectObject(hdc, GetStockObject(DKGRAY_BRUSH)); <br>PatBlt(hdc, prc-&gt;left, rc.top, rc.left - prc-&gt;left, <br>       rc.bottom - rc.top, PATCOPY); <br>    } <br>    if (rc.right &lt; prc-&gt;right) { <br>SelectObject(hdc, GetStockObject(DKGRAY_BRUSH)); <br>PatBlt(hdc, rc.right, rc.top, prc-&gt;right - rc.right, <br>       rc.bottom - rc.top, PATCOPY); <br>    } <br> <br>#define BACKBRUSH  (GetSysColor(COLOR_BTNFACE))         // background <br>#define MONOBRUSH  (GetSysColor(COLOR_BTNSHADOW))       // for mono audio <br>#define LEFTBRUSH  (RGB(0,0,255))                       // left channel <br>#define RIGHTBRUSH (RGB(0,255,0))                       // right channel <br>#define HPOSBRUSH  (RGB(255,0,0))                       // current position <br> <br>    // <br>    // Paint the background <br>    // <br>    hbr = SelectObject(hdc, CreateSolidBrush(BACKBRUSH)); <br>    PatBlt(hdc, rc.left, rc.top, w, h, PATCOPY); <br>    DeleteObject(SelectObject(hdc, hbr)); <br> <br>    // <br>    // !!! we can only paint PCM data right now.  Sorry! <br>    // <br>    if (wf.wf.wFormatTag != WAVE_FORMAT_PCM) <br>return; <br> <br>    // <br>    // How many bytes are we painting? Alloc some space for them <br>    // <br>    lBytes = lLen * wf.wf.nChannels * wf.wBitsPerSample / 8; <br>    if (!lpAudio) <br>lpAudio = GlobalAllocPtr (GHND, lBytes); <br>    else if ((LONG)GlobalSizePtr(lpAudio) &lt; lBytes) <br>lpAudio = GlobalReAllocPtr(lpAudio, lBytes, GMEM_MOVEABLE); <br>    if (!lpAudio) <br>return; <br> <br>    // <br>    // Read in the wave data <br>    // <br>    AVIStreamRead(pavi, lStart, lLen, lpAudio, lBytes, NULL, &amp;l); <br>    if (l != lLen) <br>return; <br> <br>#define MulDiv(a,b,c) (UINT)((DWORD)(UINT)(a) * (DWORD)(UINT)(b) / (UINT)(c)) <br> <br>    // <br>    // !!! Flickers less painting it NOW or LATER? <br>    // First show the current position as a bar <br>    // <br>    hbr = SelectObject(hdc, CreateSolidBrush(HPOSBRUSH)); <br>    PatBlt(hdc, prc-&gt;right / 2, prc-&gt;top, 1, prc-&gt;bottom - prc-&gt;top, PATCOPY); <br>    DeleteObject(SelectObject(hdc, hbr)); <br> <br>    // <br>    // Paint monochrome wave data <br>    // <br>    if (wf.wf.nChannels == 1) { <br> <br>// <br>// Draw the x-axis <br>// <br>hbr = SelectObject(hdc, CreateSolidBrush(MONOBRUSH)); <br>y = rc.top + h/2; <br>PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>// <br>// 8 bit data is centred around 0x80 <br>// <br>if (wf.wBitsPerSample == 8) { <br>    for (x=0; x&lt;w; x++) { <br> <br>// which byte of audio data belongs at this pixel? <br>b = *((HPBYTE)lpAudio + muldiv32(x, lLen, w)); <br> <br>if (b &gt; 0x80) { <br>    i = y - MulDiv(b - 0x80, (h / 2), 128); <br>    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>} <br>else { <br>    i = y + MulDiv(0x80 - b, (h / 2), 128); <br>    PatBlt(hdc, rc.left + x, y, 1, i - y, PATCOPY); <br>} <br>    } <br>} <br> <br>// <br>// 16 bit data is centred around 0x00 <br>// <br>else if (wf.wBitsPerSample == 16) { <br>    for (x=0; x&lt;w; x++) { <br> <br>// which byte of audio data belongs at this pixel? <br>// Don't make any assumptions about INT size ! <br>i = *((HPSHORT)lpAudio + muldiv32(x,lLen,w)); <br> <br>if (i &gt; 0) { <br>    i = y - (int) ((LONG)i * (h/2) / 32768); <br>    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>} <br>else { <br>    i = (int) ((LONG)i * (h/2) / 32768); <br>    PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY); <br>} <br>    } <br>} <br>DeleteObject(SelectObject(hdc, hbr)); <br>    } // endif mono <br> <br>    // <br>    // Draw stereo waveform data <br>    // <br>    else if (wf.wf.nChannels == 2) { <br> <br>// <br>// 8 bit data is centred around 0x80 <br>// <br>if (wf.wBitsPerSample == 8) { <br> <br>    // Left channel <br>    hbr = SelectObject(hdc, CreateSolidBrush(LEFTBRUSH)); <br>    y = rc.top + h/4; <br>    PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>    for (x=0; x&lt;w; x++) { <br>b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w) * 2); <br> <br>if (b &gt; 0x80) { <br>    i = y - MulDiv(b-0x80,(h/4),128); <br>    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>} <br>else { <br>    i = y + MulDiv(0x80-b,(h/4),128); <br>    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY); <br>} <br>    } <br>    DeleteObject(SelectObject(hdc, hbr)); <br> <br>    // Right channel <br>    hbr = SelectObject(hdc, CreateSolidBrush(RIGHTBRUSH)); <br>    y = rc.top + h * 3 / 4; <br>    PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>    for (x=0; x&lt;w; x++) { <br>b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w) * 2 + 1); <br> <br>if (b &gt; 0x80) { <br>    i = y - MulDiv(b-0x80,(h/4),128); <br>    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>} <br>else { <br>    i = y + MulDiv(0x80-b,(h/4),128); <br>    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY); <br>} <br>    } <br>    DeleteObject(SelectObject(hdc, hbr)); <br>} <br> <br>// <br>// 16 bit data is centred around 0x00 <br>// <br>else if (wf.wBitsPerSample == 16) { <br> <br>    // Left channel <br>    hbr = SelectObject(hdc, CreateSolidBrush(LEFTBRUSH)); <br>    y = rc.top + h/4; <br>    PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>    for (x=0; x&lt;w; x++) { <br> <br>// Don't make any assumptions about INT size ! <br>i = *((HPSHORT)lpAudio + muldiv32(x,lLen,w) * 2); <br>if (i &gt; 0) { <br>    i = y - (int) ((LONG)i * (h/4) / 32768); <br>    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>} <br>else { <br>    i = (int) ((LONG)i * (h/4) / 32768); <br>    PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY); <br>} <br>    } <br>    DeleteObject(SelectObject(hdc, hbr)); <br> <br>    // Right channel <br>    hbr = SelectObject(hdc, CreateSolidBrush(RIGHTBRUSH)); <br>    y = rc.top + h * 3 / 4; <br>    PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>    for (x=0; x&lt;w; x++) { <br>// Don't make any assumptions about INT size ! <br>i = *((HPSHORT)lpAudio + muldiv32(x,lLen,w) * 2 + 1); <br>if (i &gt; 0) { <br>    i = y - (int) ((LONG)i * (h/4) / 32768); <br>    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>} <br>else { <br>    i = (int) ((LONG)i * (h/4) / 32768); <br>    PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY); <br>} <br>    } <br>    DeleteObject(SelectObject(hdc, hbr)); <br>} <br>    } // endif stereo <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    PaintStuff()                                                               | <br>|    Do our painting.  Return the height of everything painted so we know how   | <br>|    much room it took to set our scrollbars.  If fDrawEverything is TRUE,      | <br>|    we will not stop drawing just because we know we're drawing outside the    | <br>|    window. This is used to determine how much we would want to draw.          | <br>\*----------------------------------------------------------------------------*/ <br> <br>int PaintStuff(HDC hdc, HWND hwnd, BOOL fDrawEverything) <br>{ <br>    int         yStreamTop; <br>    char        szText[BUFSIZE]; <br>    int         iFrameWidth, iLen; <br>    LONG        lSamp, lCurSamp; <br>    int         n; <br>    int         nFrames; <br>    LPBITMAPINFOHEADER lpbi = NULL; <br>    LONG        l; <br>    LONG        lTime; <br>    LONG        lSize = 0; <br>    LONG        lAudioStart; <br>    LONG        lAudioLen; <br>    RECT        rcFrame, rcC; <br>    int         i; <br>    HBRUSH      hbr, hbrOld; <br>    RECT        rc; <br> <br>    GetClientRect(hwnd, &amp;rcC); <br> <br>    // <br>    // Look at scrollbars to find current position <br>    // <br>    lTime = GetScrollTime(hwnd); <br>    yStreamTop = -GetScrollPos(hwnd, SB_VERT); <br> <br>    // <br>    // Walk through all streams and draw something <br>    // <br>    for (i=0; i&lt;gcpavi; i++) { <br>AVISTREAMINFO   avis; <br>LONG            lEnd, lEndTime; <br>COLORREF        nCol; <br> <br>// <br>// Remember where this stream begins <br>// <br>gStreamTop[i] = yStreamTop + GetScrollPos(hwnd, SB_VERT); <br> <br>// <br>// Get some info about this stream <br>// <br>AVIStreamInfo(gapavi[i], &amp;avis, sizeof(avis)); <br> <br>// <br>// Highlight the stream name if we're supposed to <br>// <br>if (gSelectedStream == MAXNUMSTREAMS+i) { <br>    hbr = CreateSolidBrush(HIGHLIGHT); <br>    hbrOld = SelectObject(hdc, hbr); <br> <br>    PatBlt(hdc, 0, yStreamTop, rcC.right, TSPACE * 2, PATCOPY); <br>    SelectObject(hdc, hbrOld); <br>    DeleteObject(hbr); <br>} <br> <br>// First we'll print out the stream name <br>nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>TextOut(hdc, HSPACE, yStreamTop, avis.szName, strlen(avis.szName)); <br>SetBkColor(hdc, nCol); <br> <br>// Skip to the next line <br>yStreamTop += 2*TSPACE; <br> <br>if (galSelStart[i] == -1) <br>{ <br>    LoadString( ghInstApp, IDS_FORMAT_1, gszBuffer, BUFSIZE ); <br>    iLen = wsprintf(szText, <br>    gszBuffer, <br>    i, <br>    (LPSTR) &amp;avis.fccType,      // compressor FOURCC <br>    AVIStreamStart(gapavi[i]), <br>    AVIStreamLength(gapavi[i]), <br>    (AVIStreamEndTime(gapavi[i]) - <br>     AVIStreamStartTime(gapavi[i])) / 1000); <br>} <br>else <br>{ <br>    LoadString( ghInstApp, IDS_FORMAT_2, gszBuffer, BUFSIZE ); <br>    iLen = wsprintf(szText, <br>    gszBuffer, <br>    i, <br>    (LPSTR) &amp;avis.fccType,      // compressor FOURCC <br>    AVIStreamStart(gapavi[i]), <br>    AVIStreamLength(gapavi[i]), <br>    (AVIStreamEndTime(gapavi[i]) - <br>     AVIStreamStartTime(gapavi[i])) / 1000, <br>    galSelStart[i], galSelStart[i] + galSelLen[i] - 1); <br>} <br>// <br>// Highlight the stream info if we're supposed to <br>// <br>if (gSelectedStream == i) { <br>    hbr = CreateSolidBrush(HIGHLIGHT); <br>    hbrOld = SelectObject(hdc, hbr); <br> <br>    PatBlt(hdc, 0, yStreamTop, rcC.right, TSPACE * 2, PATCOPY); <br>    SelectObject(hdc, hbrOld); <br>    DeleteObject(hbr); <br>} <br> <br>nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>TextOut(hdc, HSPACE, yStreamTop, szText, iLen); <br>SetBkColor(hdc, nCol); <br> <br>yStreamTop += TSPACE; <br>// <br>// Draw a VIDEO stream <br>// <br>if (avis.fccType == streamtypeVIDEO) { <br>    if (gapgf[i] == NULL) <br>continue; <br> <br>    // <br>    // Which frame belongs at this time? <br>    // <br>    lEndTime = AVIStreamEndTime(gapavi[i]); <br>    if (lTime &lt;= lEndTime) <br>lSamp = AVIStreamTimeToSample(gapavi[i], lTime); <br>    else {      // we've scrolled past the end of this stream <br>lEnd = AVIStreamEnd(gapavi[i]); <br>lSamp = lEnd + AVIStreamTimeToSample(gapavi[i], <br>     lTime - lEndTime); <br>    } <br> <br>    // <br>    // how wide is each frame to paint? <br>    // <br>    iFrameWidth = (avis.rcFrame.right - avis.rcFrame.left) * <br>  gwZoom / 4 + HSPACE; <br> <br>    // <br>    // how many frames can we fit on each half of the screen <br>    // not counting the one we'll centre? <br>    // <br>    nFrames = (rcC.right - iFrameWidth) / (2 * iFrameWidth); <br>    if (nFrames &lt; 0) <br>nFrames = 0; <br> <br>    // <br>    // Step through all the frames we'll draw <br>    // <br>    for (n = -nFrames; n &lt;= nFrames; n++) { <br> <br>// <br>// Each video stream is drawn as a horizontal line of <br>// frames, very close together. <br>// The first video stream shows a different frame in <br>// each square. Thus the scale of time is determined <br>// by the first video stream. <br>// Every other video stream shows whatever <br>// frame belongs at the time corresponding to the mid- <br>// point of each square. <br>// <br>if (i == giFirstVideo) { <br> <br>    // <br>    // by definition, we know what frame we're drawing.. <br>    // (lSamp-n), (lSamp-(n-1)), ..., (lSamp), ..., <br>    // (lSamp+n) (lSamp is the one in the centre) <br>    // <br>    lCurSamp = lSamp + n; <br> <br>    // <br>    // what time is it at that frame? This number will <br>    // be printed underneath the frame <br>    // <br>    l = AVIStreamSampleToTime(gapavi[i], lCurSamp); <br> <br>} else {        // NOT the first video stream <br> <br>    // <br>    // What time is it at the left hand of the square <br>    // we'll draw?  That's what frame we use. <br>    // Does the rounding with MulDiv32 have better properties <br>    // than muldiv32? It appears to give _slightly_ better performance <br> <br>    l = lTime + MulDiv32(n * (iFrameWidth+HSPACE), <br> gdwMicroSecPerPixel, 1000); <br>    //if (n&lt;=0) {  // calculate the time for a frame left of centre, <br>    //             // don't forget the HSPACE offset. <br>    //    l = lTime - muldiv32(-n * (iFrameWidth + HSPACE), <br>    //                         gdwMicroSecPerPixel, 1000); <br>    // <br>    //} <br>    //else { // frame is to right of centre. <br>    //    l = lTime + muldiv32(n * (iFrameWidth +HSPACE), <br>    //                           gdwMicroSecPerPixel, 1000); <br>    // <br>    //} <br> <br>    // <br>    // What frame belongs to that time? <br>    // <br>    lCurSamp = AVIStreamTimeToSample(gapavi[i], l); <br> <br>    // <br>    // Use the exact time of that frame when printing <br>    // <br>    l = AVIStreamSampleToTime(gapavi[i], lCurSamp); <br>} <br> <br>// !!! <br>// Could actually return an LPBI for invalid frames <br>// so we better force it to NULL. <br>// <br>if (gapgf[i] &amp;&amp; lCurSamp &gt;= AVIStreamStart(gapavi[i])) // &amp;&amp; <br>    //lCurSamp &lt;= AVIStreamEnd(gapavi[i])) <br>    lpbi = AVIStreamGetFrame(gapgf[i], lCurSamp); <br>else <br>    lpbi = NULL; <br> <br>// <br>// Figure out where to draw this frame <br>// <br>rcFrame.left   = rcC.right / 2 - <br> ((avis.rcFrame.right - avis.rcFrame.left) * gwZoom / 4) <br> / 2 + (n * iFrameWidth); <br>rcFrame.top    = yStreamTop + TSPACE; <br>rcFrame.right  = rcFrame.left + <br> (avis.rcFrame.right - avis.rcFrame.left) * gwZoom / 4; <br>rcFrame.bottom = rcFrame.top + <br> (avis.rcFrame.bottom - avis.rcFrame.top) * gwZoom / 4; <br> <br>// <br>// If this frame is selected, highlight it <br>// <br>if (lCurSamp &gt;= galSelStart[i] &amp;&amp; <br>    lCurSamp &lt; galSelStart[i] + <br>    galSelLen[i]) { <br>    hbr = CreateSolidBrush(HIGHLIGHT); <br>} <br>else { //not highlighted - but need to clear area around frame <br>       // of selection <br>    hbr = CreateSolidBrush(GetBkColor(hdc)); <br>} <br> <br>FrameVideo(hdc, &amp;rcFrame, hbr); <br>DeleteObject (hbr); <br> <br>// <br>// draw a border around the centre frame. <br>// <br>if (n == 0) { <br>    hbr = CreateSolidBrush(RGB(255,0,0)); <br>    InflateRect(&amp;rcFrame, 1, 1); <br>    FrameRect(hdc, &amp;rcFrame, hbr); <br>    InflateRect(&amp;rcFrame, -1, -1); <br>    DeleteObject (hbr); <br>} <br> <br>// <br>// Now draw the video frame in the computed rectangle <br>// <br>PaintVideo(hdc, rcFrame, i, lpbi, lCurSamp, l); <br>    } <br> <br>    // <br>    // Print a description of this stream <br>    // <br>    if (lpbi) <br>AVIStreamSampleSize(gapavi[i], lSamp, &amp;lSize); <br> <br>    // <br>    // Move down to where we can draw the next stream <br>    // <br>    yStreamTop += TSPACE + <br>  (rcFrame.bottom - rcFrame.top) + <br>  TSPACE; <br>} <br> <br>// <br>// Draw an AUDIO stream <br>// <br>else if (avis.fccType == streamtypeAUDIO) { <br> <br>    // <br>    // Figure out which samples are visible <br>    // <br>    lAudioStart = lTime - muldiv32(rcC.right / 2, <br>   gdwMicroSecPerPixel, 1000); <br>    lAudioLen = 2 * (lTime - lAudioStart); <br> <br>    // clear the selection area <br> <br>    hbr = CreateSolidBrush(GetBkColor(hdc)); <br>    hbrOld = SelectObject(hdc, hbr); <br>    PatBlt(hdc, <br>0, <br>yStreamTop + TSPACE - SELECTVSPACE, <br>rcC.right, <br>SELECTVSPACE, <br>PATCOPY); <br>    PatBlt(hdc, <br>0, <br>yStreamTop + TSPACE + (AUDIOVSPACE * gwZoom/4), <br>rcC.right, <br>SELECTVSPACE, <br>PATCOPY); <br>    SelectObject(hdc, hbrOld); <br>    DeleteObject (hbr); <br> <br>    // <br>    // We have a selection... Highlight it <br>    // <br>    if (galSelStart[i] != -1) { <br>LONG lSelSt, lSelLen; <br> <br>// <br>// What time is our selection? <br>// <br>lSelSt = AVIStreamSampleToTime(gapavi[i], galSelStart[i]); <br>lSelLen = AVIStreamSampleToTime(gapavi[i], galSelLen[i]); <br> <br>// <br>// At what pixels is our selection? <br>// <br>if (lSelSt &lt; lTime) { //selecting to the left of the current position <br>    rc.left = rcC.right /2 - (int) <br>muldiv32((lTime - lSelSt) , 1000, gdwMicroSecPerPixel); <br>} <br>else { <br>    rc.left = rcC.right / 2 + (int) <br>muldiv32(lSelSt - lTime, 1000, gdwMicroSecPerPixel); <br>} <br>rc.right = rc.left + (int) <br>muldiv32(lSelLen, 1000, gdwMicroSecPerPixel); <br> <br>// Selection starts way past left side of screen <br>if (lSelSt &lt; lAudioStart) <br>    rc.left = 0; <br>// Selection is off, screen left <br>if (lSelSt + lSelLen &lt; lAudioStart) <br>    rc.right = - SELECTVSPACE; <br> <br>// Selection is off, screen right <br>if (lSelSt &gt; lAudioStart + lAudioLen) <br>    rc.left = rcC.right + SELECTVSPACE; <br> <br>// Selection ends past the right side of the screen <br>if (lSelSt + lSelLen &gt; lAudioStart + lAudioLen) <br>    rc.right = rcC.right; <br>if (rc.right == rc.left)        // draw SOMEthing. <br>    rc.right++; <br>rc.top = yStreamTop + TSPACE; <br>rc.bottom = rc.top + AUDIOVSPACE * gwZoom / 4; <br> <br>// <br>// Draw some indication <br>// <br>hbr = CreateSolidBrush(HIGHLIGHT); <br>hbrOld = SelectObject(hdc, hbr); <br>PatBlt(hdc, <br>       rc.left - SELECTVSPACE, <br>       rc.top - SELECTVSPACE, <br>       rc.right - rc.left + 2 * SELECTVSPACE, <br>       SELECTVSPACE, <br>       PATCOPY); <br>PatBlt(hdc, <br>       rc.left - SELECTVSPACE, <br>       rc.bottom, <br>       rc.right - rc.left + 2 * SELECTVSPACE, <br>       SELECTVSPACE, <br>       PATCOPY); <br>SelectObject(hdc, hbrOld); <br>DeleteObject (hbr); <br>    } <br> <br>    // <br>    // Make the rectangle to draw audio into <br>    // <br>    rc.left = rcC.left; <br>    rc.right = rcC.right; <br>    rc.top = yStreamTop + TSPACE; <br>    rc.bottom = rc.top + AUDIOVSPACE * gwZoom / 4; <br> <br>    // <br>    // Actually paint the audio <br>    // <br>    PaintAudio(hdc, &amp;rc, gapavi[i], lAudioStart, lAudioLen); <br> <br>    // <br>    // Print the time at the centre of the audio stream <br>    // <br>    iLen = wsprintf(szText, "%ld.%03lds", lTime/1000, lTime%1000); <br>    rc.left = (rc.right - rc.left) / 2 - 5 * HSPACE; <br>    rc.right = (rc.right - rc.left) / 2; <br>    rc.top = rc.bottom + HSPACE; rc.bottom = rc.top + VSPACE; <br>    nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>    ExtTextOut(hdc, rc.left, rc.top, 0, &amp;rc, szText, iLen, NULL); <br>    SetBkColor(hdc, nCol); <br> <br>    // <br>    // Move down to where we can draw the next stream <br>    // <br>    yStreamTop += TSPACE + AUDIOVSPACE * gwZoom / 4; <br> <br>} <br> <br>yStreamTop += TSPACE + TSPACE; <br> <br>// <br>// Give up once we're painting below the bottom of the window <br>// <br>if (!fDrawEverything &amp;&amp; yStreamTop &gt;= rcC.bottom) <br>    break; <br>    } <br> <br>    // The bottom of all the streams; <br>    gStreamTop[gcpavi] = yStreamTop + GetScrollPos(hwnd, SB_VERT); <br> <br>    // <br>    // How many lines did we draw? <br>    // <br>    return yStreamTop + GetScrollPos(hwnd, SB_VERT); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FixScrollBars()                                                            | <br>|    When we load a file or zoom changes, we re-set the scrollbars              | <br>\*----------------------------------------------------------------------------*/ </code></pre>
<p>
</p>
<pre><code><br>void FixScrollbars(HWND hwnd) <br>{ <br>    int                 nHeight = 0; <br>    RECT                rc; <br>    HDC                 hdc; <br> <br>    // <br>    // Determine how tall our window needs to be to display everything. <br>    // <br>    hdc = GetDC(NULL); <br>    ExcludeClipRect(hdc, 0, 0, 32767, 32767);   // don't actually draw <br>    nHeight = PaintStuff(hdc, hwnd, TRUE); <br>    ReleaseDC(NULL, hdc); <br> <br>    // <br>    // Set vertical scrollbar for scrolling the visible area <br>    // <br>    GetClientRect(hwnd, &amp;rc); <br>    nVertHeight = nHeight;      // total height in pixels of entire display <br> <br>    // <br>    // We won't fit in the window... need scrollbars <br>    // <br>    if (nHeight &gt; rc.bottom) <br>    { <br>nVertSBLen = nHeight - rc.bottom; <br>SetScrollRange(hwnd, SB_VERT, 0, nVertSBLen, TRUE); <br>SetScrollPos(hwnd, SB_VERT, 0, TRUE); <br> <br>// <br>// We will fit in the window!  No scrollbars necessary <br>// <br>    } <br>    else <br>    { <br>nVertSBLen = 0; <br>SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>    } <br>    return; <br>} <br> <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InitStreams()                                                              | <br>|    Initialize the streams of a loaded file -- the compression options, the    | <br>|    DrawDIB handles, and the scroll bars.                                      | <br>|    !!! This clears the compression options right now every time it's called!  | <br>\*----------------------------------------------------------------------------*/ <br> <br>void InitStreams(HWND hwnd) <br>{ <br>    AVISTREAMINFO     avis; <br>    LONG        lTemp; <br>    int         i; <br> <br>    // <br>    // Start with bogus times <br>    // <br>    timeStart = 0x7FFFFFFF; <br>    timeEnd   = 0; <br> <br>    // <br>    // Walk through and init all streams loaded <br>    // <br>    for (i = 0; i &lt; gcpavi; i++) { <br> <br>AVIStreamInfo(gapavi[i], &amp;avis, sizeof(avis)); <br> <br>// <br>// Save and SaveOptions code takes a pointer to our compression opts <br>// <br>galpAVIOptions[i] = &amp;gaAVIOptions[i]; <br> <br>// <br>// clear options structure to zeroes <br>// <br>_fmemset(galpAVIOptions[i], 0, sizeof(AVICOMPRESSOPTIONS)); <br> <br>// <br>// Initialize the compression options to some default stuff <br>// !!! Pick something better <br>// <br>galpAVIOptions[i]-&gt;fccType = avis.fccType; <br> <br>switch(avis.fccType) { <br> <br>    case streamtypeVIDEO: <br>galpAVIOptions[i]-&gt;dwFlags = AVICOMPRESSF_VALID | <br>AVICOMPRESSF_KEYFRAMES | AVICOMPRESSF_DATARATE; <br>galpAVIOptions[i]-&gt;fccHandler = 0; <br>galpAVIOptions[i]-&gt;dwQuality = (DWORD)ICQUALITY_DEFAULT; <br>galpAVIOptions[i]-&gt;dwKeyFrameEvery = (DWORD)-1; // Default <br>galpAVIOptions[i]-&gt;dwBytesPerSecond = 0; <br>galpAVIOptions[i]-&gt;dwInterleaveEvery = 1; <br>break; <br> <br>    case streamtypeAUDIO: <br>galpAVIOptions[i]-&gt;dwFlags |= AVICOMPRESSF_VALID; <br>galpAVIOptions[i]-&gt;dwInterleaveEvery = 1; <br>AVIStreamReadFormat(gapavi[i], <br>    AVIStreamStart(gapavi[i]), <br>    NULL, <br>    &amp;lTemp); <br>galpAVIOptions[i]-&gt;cbFormat = lTemp; <br>if (lTemp) <br>    galpAVIOptions[i]-&gt;lpFormat = GlobalAllocPtr(GHND, lTemp); <br>// Use current format as default format <br>if (galpAVIOptions[i]-&gt;lpFormat) <br>    AVIStreamReadFormat(gapavi[i], <br>AVIStreamStart(gapavi[i]), <br>galpAVIOptions[i]-&gt;lpFormat, <br>&amp;lTemp); <br>break; <br> <br>    default: <br>break; <br>} <br> <br>// <br>// We're finding the earliest and latest start and end points for <br>// our scrollbar. <br>// <br>timeStart = min(timeStart, AVIStreamStartTime(gapavi[i])); <br>timeEnd   = max(timeEnd, AVIStreamEndTime(gapavi[i])); <br> <br>// <br>// Initialize video streams for getting decompressed frames to display <br>// <br>if (avis.fccType == streamtypeVIDEO) { <br> <br>    gapgf[i] = AVIStreamGetFrameOpen(gapavi[i], NULL); <br> <br>    if (gapgf[i] == NULL) <br>continue; <br> <br>    ghdd[i] = DrawDibOpen(); <br>    // !!! DrawDibBegin? <br> <br>    if (!gfVideoFound) { <br>    DWORD        dw; <br> <br>// <br>// Remember the first video stream --- treat it specially <br>// <br>giFirstVideo = i; <br> <br>// <br>// Set the horizontal scrollbar scale to show every frame <br>// of the first video stream exactly once <br>// <br>dw = (avis.rcFrame.right - avis.rcFrame.left) * gwZoom / 4 + HSPACE; <br> <br>gdwMicroSecPerPixel = muldiv32(1000000, <br>       avis.dwScale, <br>       dw * avis.dwRate); <br>// Move one frame on the top video screen for each HSCROLL <br>timehscroll = muldiv32(1000, avis.dwScale, avis.dwRate); <br>    } <br> <br>} else if (avis.fccType == streamtypeAUDIO) { <br> <br>    // These aren't used and better be NULL! <br>    gapgf[i] = ghdd[i] = NULL; <br> <br>    // <br>    // If there are no video streams, we base everything on this <br>    // audio stream. <br>    // <br>    if (!gfAudioFound &amp;&amp; !gfVideoFound) { <br> <br>// Show one sample per pixel <br>gdwMicroSecPerPixel = muldiv32(1000000, <br>       avis.dwScale, <br>       avis.dwRate); <br>// Move one sample per HSCROLL <br>// Move at least enough to show movement <br>timehscroll = muldiv32(1000, avis.dwScale, avis.dwRate); <br>    } <br> <br>    // <br>    // Remember the first audio stream --- treat it specially <br>    // <br>    if (!gfAudioFound) <br>giFirstAudio = i; <br> <br>} <br> <br>    } <br> <br>    timeLength = timeEnd - timeStart; <br> <br>    if (timeLength == 0) <br>timeLength = 1; <br> <br>    // Make sure HSCROLL scrolls enough to be noticeable. <br>    timehscroll = max(timehscroll, timeLength / SCROLLRANGE + 2); <br> <br>    SetScrollRange(hwnd, SB_HORZ, 0, SCROLLRANGE, TRUE); <br>    SetScrollTime(hwnd, timeStart); <br> <br>    FixScrollbars(hwnd); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FixWindowTitle()                                                           | <br>|    Update the window title to reflect what's loaded                           | <br>\*----------------------------------------------------------------------------*/ <br> <br>void FixWindowTitle(HWND hwnd) <br>{ <br>    char szTitle[2*BUFSIZE]; <br> <br>    LoadString( ghInstApp, IDS_APPNAME, gszBuffer, BUFSIZE ); <br> <br>    wsprintf(szTitle, "%s %s", (LPSTR)gszBuffer, (LPSTR)gszFileName); <br> <br>    SetWindowText( hwnd, szTitle ); <br> <br>    InvalidateRect(hwnd, NULL, TRUE); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FreeDrawStuff()                                                            | <br>|    Free up the resources associated with DrawDIB.                             | <br>\*----------------------------------------------------------------------------*/ <br> <br>void FreeDrawStuff(HWND hwnd) <br>{ <br>    int i; <br> <br>    // Make sure we're not playing! <br>    aviaudioStop(); <br> <br>    for (i = 0; i &lt; gcpavi; i++) { <br>if (gapgf[i]) { <br>    AVIStreamGetFrameClose(gapgf[i]); <br>    gapgf[i] = NULL; <br>} <br>if (ghdd[i]) { <br>    DrawDibClose(ghdd[i]); <br>    ghdd[i] = 0; <br>} <br>    } <br>    SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>    giFirstVideo = giFirstAudio = -1; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    NukeAVIStream()                                                            | <br>|    Get rid of a stream in our array and compact it.                           | <br>\*----------------------------------------------------------------------------*/ <br> <br>void NukeAVIStream(int i) <br>{ <br>    int j; <br> <br>    // <br>    // Make sure it's a real stream number <br>    // <br>    if (i &lt; 0 || i &gt;=gcpavi) <br>return; <br> <br>    // <br>    // Free all the resources associated with this stream <br>    // <br>    AVIStreamRelease(gapavi[i]); <br>    if (galpAVIOptions[i]-&gt;lpFormat) { <br>GlobalFreePtr(galpAVIOptions[i]-&gt;lpFormat); <br>    } <br>    if (gapgf[i]) { <br>AVIStreamGetFrameClose(gapgf[i]); <br>gapgf[i] = NULL; <br>    } <br>    if (ghdd[i]) { <br>DrawDibClose(ghdd[i]); <br>ghdd[i] = 0; <br>    } <br> <br>    // <br>    // Compact the arrays of junk <br>    // <br>    for (j = i; j &lt; gcpavi - 1; j++) { <br>gapavi[j] = gapavi[j+1]; <br>galpAVIOptions[j] = galpAVIOptions[j+1]; <br>gapgf[j] = gapgf[j+1]; <br>ghdd[j] = ghdd[j+1]; <br>    } <br> <br>    gcpavi--; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FreeAVI()                                                                  | <br>|    Free the resources associated with an open file.                           | <br>\*----------------------------------------------------------------------------*/ <br> <br>void FreeAvi(HWND hwnd) <br>{ <br>    int i; <br> <br>    FreeDrawStuff(hwnd); <br> <br>    AVISaveOptionsFree(gcpavi, galpAVIOptions); <br> <br>    for (i = 0; i &lt; gcpavi; i++) { <br>AVIStreamRelease(gapavi[i]); <br>    } <br> <br>    // Good a place as any to make sure audio data gets freed <br>    if (lpAudio) <br>GlobalFreePtr(lpAudio); <br>    lpAudio = NULL; <br> <br>    gcpavi = 0; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InsertAVIFile()                                                            | <br>|    Put a new AVI file into our internal structures.                           | <br>\*----------------------------------------------------------------------------*/ <br> <br>void InsertAVIFile(PAVIFILE pfile, HWND hwnd, LPSTR lpszFile) <br>{ <br>    int         i; <br>    PAVISTREAM  pavi; <br> <br>    for (i = gcpavi; i &lt;= MAXNUMSTREAMS; i++) { <br>if (AVIFileGetStream(pfile, &amp;pavi, 0L, i - gcpavi) != AVIERR_OK) <br>    break; <br>if (i == MAXNUMSTREAMS) <br>{ <br>    AVIStreamRelease(pavi); <br>    LoadString( ghInstApp, IDS_MAXSTREAMS, gszBuffer, BUFSIZE ); <br>    ErrMsg(gszBuffer); <br>    break; <br>} <br>if (CreateEditableStream(&amp;gapavi[i], pavi) != AVIERR_OK) { <br>    AVIStreamRelease(pavi); <br>    break; <br>} <br>AVIStreamRelease(pavi); <br>galSelStart[i] = galSelLen[i] = -1; <br>    } <br> <br>    AVIFileRelease(pfile); <br> <br>    if (gcpavi == i &amp;&amp; i != MAXNUMSTREAMS) <br>    { <br> <br>LoadString( ghInstApp, IDS_NOOPEN, gszBuffer, BUFSIZE ); <br> <br>ErrMsg(gszBuffer, lpszFile); <br>return; <br>    } <br> <br>    FreeDrawStuff(hwnd); <br>    gcpavi = i; <br>    InitStreams(hwnd); <br>    FixWindowTitle(hwnd); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InitAVI()                                                                  | <br>|    Open up a file through the AVIFile handlers.                               | <br>\*----------------------------------------------------------------------------*/ <br> <br> <br>void InitAvi(HWND hwnd, LPSTR szFile, int nMenu) <br>{ <br>    HRESULT     hr; <br>    PAVIFILE    pfile; <br> <br>    hr = AVIFileOpen(&amp;pfile, szFile, 0, 0L); <br> <br>    if (hr != 0) <br>    { <br>LoadString( ghInstApp, IDS_NOOPEN, gszBuffer, BUFSIZE ); <br>ErrMsg(gszBuffer, szFile); <br>return; <br>    } <br> <br>    // <br>    // If we're opening something new, close other open files, otherwise <br>    // just close the draw stuff so we'll merge streams with the new file <br>    // <br>    if (nMenu == MENU_OPEN) <br>FreeAvi(hwnd); <br> <br>    InsertAVIFile(pfile, hwnd, szFile); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    DropAvi()                                                                  | <br>|    Allow a drag/drop on AVIEdit.                                              | <br>\*----------------------------------------------------------------------------*/ <br>void DropAvi(HWND hwnd, HDROP hDrop) <br>{ <br>    char        szPath[BUFSIZE]; <br>    UINT        nDropped, n; <br>    PAVIFILE    pfile; <br>    HRESULT     hr; <br> <br>    // Get number of files dropped <br>    nDropped = DragQueryFile(hDrop,0xFFFF,NULL,0); <br> <br>    if (nDropped) { <br>SetActiveWindow(hwnd); <br> <br>// If we wanted to, we could simulate a click at the position <br>// the drop took place.... <br> <br>for (n = 0; n &lt; nDropped; n++) { <br>    // Get the file that was dropped.... <br>    DragQueryFile(hDrop, n, szPath, BUFSIZE); <br> <br>    hr = AVIFileOpen(&amp;pfile, szPath, 0, 0L); <br> <br>    if (hr == 0) { <br>// ... and paste it in. <br>editPaste(hwnd, pfile); <br>    } <br>} <br>    } <br>    DragFinish(hDrop);     /* Delete structure alocated */ <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppInit( hInst, hPrev)                                                     | <br>|                                                                              | <br>|   Description:                                                               | <br>|       This is called when the application is first loaded into               | <br>|       memory.  It performs all initialization that doesn't need to be done   | <br>|       once per instance.                                                     | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hInstance       instance handle of current instance                    | <br>|       hPrev           instance handle of previous instance                   | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       TRUE if successful, FALSE if not                                       | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br> <br>BOOL AppInit(HINSTANCE hInst, HINSTANCE hPrev, int sw, LPSTR szCmdLine) <br>{ <br>    WNDCLASS cls; <br>    WORD        wVer; <br> <br>    /* first let's make sure we are running on 1.1 */ <br>    wVer = HIWORD(VideoForWindowsVersion()); <br>    if (wVer &lt; 0x010a) <br>    { <br>char szTitle[BUFSIZE]; <br>/* oops, we are too old, blow out of here */ <br>MessageBeep(MB_ICONHAND); <br>LoadString( ghInstApp, IDS_APPERR, szTitle, BUFSIZE ); <br>LoadString( ghInstApp, IDS_OLDVFW, gszBuffer, BUFSIZE ); <br> <br>MessageBox(NULL, gszBuffer, szTitle, MB_OK|MB_ICONSTOP); <br>return FALSE; <br>    } <br> <br>    // <br>    // Save instance handle for DialogBoxs <br>    // <br>    ghInstApp = hInst; <br> <br>    ghAccel = LoadAccelerators(hInst, MAKEINTATOM(ID_APP)); <br> <br>    // <br>    // Did we get passed a filename on the command line? We'll open it at create <br>    // time. <br>    // <br>    if (szCmdLine &amp;&amp; szCmdLine[0]) <br>lstrcpy(gszFileName, szCmdLine); <br>    else <br>lstrcpy( gszFileName, "" ); <br> <br>    lstrcpy( gszSaveFileName, "" ); <br> <br>    if (!hPrev) { <br>/* <br> *  Register a class for the main application window <br> */ <br>cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>cls.hIcon          = LoadIcon(hInst,MAKEINTATOM(ID_APP)); <br>cls.lpszMenuName   = MAKEINTATOM(ID_APP); <br>cls.lpszClassName  = MAKEINTATOM(ID_APP); <br>cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>cls.hInstance      = hInst; <br>cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | <br>     CS_DBLCLKS; <br>cls.lpfnWndProc    = (WNDPROC)AppWndProc; <br>cls.cbWndExtra     = 0; <br>cls.cbClsExtra     = 0; <br> <br>if (!RegisterClass(&amp;cls)) <br>    return FALSE; <br>    } <br> <br>    // <br>    // Must be called before using any of the AVIFile routines <br>    // <br>    AVIFileInit(); <br> <br>    LoadString( ghInstApp, IDS_APPNAME, gszBuffer, BUFSIZE ); <br>    // <br>    // Create our main application window <br>    // <br>    ghwndApp = CreateWindow ( <br>     MAKEINTATOM(ID_APP),    // Class name <br>     gszBuffer,             // Caption <br>     WS_OVERLAPPEDWINDOW,    // Style bits <br>     CW_USEDEFAULT, 0,       // Position <br>     320,300,                // Size <br>     (HWND)NULL,             // Parent window (no parent) <br>     (HMENU)NULL,            // use class menu <br>     hInst,                  // handle to window instance <br>     (LPSTR)NULL             // no params to pass on <br>     ); <br>    ShowWindow(ghwndApp,sw); <br> <br>    return TRUE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )                              | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The main procedure for the App.  After initializing, it just goes      | <br>|       into a message-processing loop until it gets a WM_QUIT message         | <br>|       (meaning the app was closed). If the preview is playing it adjusts     | <br>|       the scrollbar appropriately.                                           | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hInst           instance handle of this instance of the app            | <br>|       hPrev           instance handle of previous instance, NULL if first    | <br>|       szCmdLine       -&gt;null-terminated command line                         | <br>|       cmdShow         specifies how the window is initially displayed        | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       The exit code as specified in the WM_QUIT message.                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) <br>{ <br>    MSG     msg; <br> <br>    // <br>    // Call our initialization procedure <br>    // <br>    if (!AppInit(hInst, hPrev, sw, szCmdLine)) <br>return FALSE; <br> <br>    /* <br>     * Polling messages from event queue <br>     */ <br>    for (;;) <br>    { <br>while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>{ <br>    if (msg.message == WM_QUIT) <br>return msg.wParam; <br> <br>    if (TranslateAccelerator(ghwndApp, ghAccel, &amp;msg)) <br>continue; <br> <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>} <br> <br>// <br>// If we have no messages to dispatch, we do our background task... <br>// If we're playing a file, we set the scroll bar to show the video <br>// frames corresponding with the current playing audio sample <br>// <br>if (gfPlaying) { <br>    LONG    l; <br> <br>    // <br>    // Use the audio clock to tell how long we've been playing.  To <br>    // maintain sync, it's important we use this clock. <br>    // <br>    l = aviaudioTime();         // returns -1 if no audio playing <br> <br>    // <br>    // If we can't use the audio clock to tell us how long we've been <br>    // playing, calculate it ourself <br>    // <br>    if (l == -1) <br>l = timeGetTime() - glPlayStartTime + glPlayStartPos; <br> <br>    if (l != (LONG)GetScrollTime(ghwndApp)) { <br>if (l &lt; timeStart)      // make sure number isn't out of bounds <br>    l = timeStart; <br>if (l &gt; timeEnd)        // looks like we're all done! <br>    FORWARD_WM_COMMAND(ghwndApp, MENU_STOP, NULL, 0, SendMessage); <br> <br>SetScrollTime(ghwndApp, l); <br>InvalidateRect(ghwndApp, NULL, FALSE); <br>UpdateWindow(ghwndApp); <br> <br>continue; <br>    } <br>} <br> <br>WaitMessage(); <br>    } <br> <br>    /* NOT REACHED */ <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    SelectStream()                                                             | <br>|                                                                               | <br>|    Selects a portion of a stream i:                                           | <br>|                                                                               | <br>|    i == -1 means clear all selections                                         | <br>|    start == -1 means clear that individual stream's selection                 | <br>|    fAdd == TRUE means extend that stream's selection to include the new       | <br>|            range (will otherwise just replace the selection)                  | <br>|    fAll == TRUE means select this range in every stream, not just i           | <br>\*----------------------------------------------------------------------------*/ <br> <br>void SelectStream(HWND hwnd, int i, LONG start, LONG length, BOOL fAdd, BOOL fAll) <br>{ <br>    int n, j; <br>    LONG mystart, mylength; <br>    RECT rc; <br> <br>    // <br>    // Clear all selections <br>    // <br>    if (i == -1) { <br>for (n = 0; n &lt; gcpavi; n++) <br>    galSelStart[n] = galSelLen[n] = -1; <br> <br>    } else if (i &gt;= 0 &amp;&amp; i &lt; gcpavi) {  // valid stream number <br> <br>// <br>// We've been told to clear this selection <br>// <br>if (start == -1 || length == -1) <br>    galSelStart[i] = galSelLen[i] = -1; <br> <br>// <br>// Is this a valid selection range? <br>// <br>if (start &gt;=AVIStreamStart(gapavi[i]) &amp;&amp; <br>    start &lt; AVIStreamEnd(gapavi[i]) &amp;&amp; <br>    length &gt;= 1) { <br> <br>    // <br>    // Do we select the same range in every stream or just one? <br>    // <br>    for (j = (fAll ? 0 : i); j &lt; (fAll ? gcpavi : i+1); j++) { <br> <br>// <br>// Translate for each stream the equivalent region to select <br>// <br>if (j == i) { <br>    mystart = start; mylength = length; <br>} else { <br>    mystart = AVIStreamSampleToSample(gapavi[j], <br>      gapavi[i], start); <br>    mylength = max(1, AVIStreamSampleToSample(gapavi[j], <br>      gapavi[i], length));    // at least 1 <br>    // !!! Better invalidate this entire stream since we're not <br>    // sure what part needs repainting. <br>    GetClientRect(hwnd, &amp;rc); <br>    rc.top = gStreamTop[j] - GetScrollPos(hwnd, SB_VERT); <br>    rc.bottom = gStreamTop[j+1] - GetScrollPos(hwnd, SB_VERT); <br>    InvalidateRect(hwnd, &amp;rc, FALSE); <br>} <br> <br>// <br>// Verify we got good selection values <br>// <br>if (mystart &lt; AVIStreamStart(gapavi[j])) { <br>    mylength -= AVIStreamStart(gapavi[j]) - mystart; <br>    mystart = AVIStreamStart(gapavi[j]); <br>} <br>if (mystart + mylength &gt; AVIStreamEnd(gapavi[j])) <br>    mylength -= mystart + mylength - AVIStreamEnd(gapavi[j]); <br>if (mylength &lt;= 0) <br>    mystart = -1; <br>if (mystart == -1)      // nothing to select in this stream <br>    continue; <br> <br>// <br>// Reset selection to new values <br>// <br>if (!fAdd || galSelStart[j] == -1) { <br>    galSelStart[j] = mystart; <br>    galSelLen[j] = mylength; <br> <br>    // <br>    // extend selection to include this new range <br>    // <br>} else { <br>    if (mystart &lt; galSelStart[j]) { <br>galSelLen[j] += galSelStart[j] - mystart; <br>galSelStart[j] = mystart; <br>    } <br>    if (mystart + mylength &gt; galSelStart[j] + galSelLen[j]) <br>galSelLen[j] = mystart + mylength - galSelStart[j]; <br>} <br>    } <br>} <br>    } <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    EditStreamName()                                                           | <br>|                                                                               | <br>|    We need to edit the name of a stream. Create the edit box.                 | <br>\*----------------------------------------------------------------------------*/ <br> <br>void EditStreamName(HWND hwndParent) <br> <br>{ <br>    AVISTREAMINFO avis; <br> <br>    // Get the stream info so we can get the name <br>    AVIStreamInfo(gapavi[gSelectedStream-MAXNUMSTREAMS], &amp;avis, sizeof(avis)); <br> <br>    // Create the window; <br>    InflateRect(&amp;grcSelectedStream, 0, 2); <br>    ghwndEdit = CreateWindow(AVI_EDIT_CLASS, NULL, <br>     WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL, <br>     grcSelectedStream.left, <br>     grcSelectedStream.top, <br>     grcSelectedStream.right - grcSelectedStream.left, <br>     grcSelectedStream.bottom - grcSelectedStream.top, <br>     hwndParent, (HMENU)1, ghInstApp, NULL); <br> <br>    // Subclass the window so we can trap &lt;cr&gt; hits. <br>    gOldEditProc = (WNDPROC)GetWindowLong(ghwndEdit, GWL_WNDPROC); <br>    SetWindowLong(ghwndEdit, GWL_WNDPROC, (long)NewEditProc); <br> <br>    // Set the initial text of the edit window, give focus to the <br>    // window and select the text. <br>    SetWindowText(ghwndEdit, avis.szName); <br>    SetFocus(ghwndEdit); <br>    Edit_SetSel(ghwndEdit, 0, lstrlen(avis.szName)); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    EditDone()                                                                 | <br>|                                                                               | <br>|    Done with an edit. See if we take the changes.                             | <br>\*----------------------------------------------------------------------------*/ <br> <br>void EditDone(HWND hwndParent, BOOL bAcceptChange) <br>{ <br>    // Update the stream name if we're supposed to. <br>    if (bAcceptChange) { <br>char szBuff[BUFSIZE]; <br>int n; <br> <br>// Get the edited name and put into the stream header <br>n = GetWindowText(ghwndEdit, szBuff, BUFSIZE); <br>szBuff[n] = '\0'; <br>EditStreamSetName(gapavi[gSelectedStream-MAXNUMSTREAMS], szBuff); <br>    } <br> <br>    // Turn the selection off. <br>    gSelectedStream = -1; <br> <br>    // Nuke the edit window. <br>    SetWindowLong(ghwndEdit, GWL_WNDPROC, (long)gOldEditProc); <br>    DestroyWindow(ghwndEdit); <br>    ghwndEdit = NULL; <br> <br>    // Paint where window used to be. <br>    InvalidateRect(hwndParent, &amp;grcSelectedStream, TRUE); <br>    UpdateWindow(hwndParent); <br> <br>    // Give the parent the focus back. <br>    SetFocus(hwndParent); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    NewEditProc()                                                              | <br>|                                                                               | <br>|    Our own home-rolled window proc for the edit window giving                 | <br>|    notification when &lt;cr&gt; is hit.                                             | <br>|                                                                               | <br>|    We trap WM_CHAR, because WM_CHAR(wParam='\r') causes a beep, which         | <br>|    we don't want.                                                             | <br>\*----------------------------------------------------------------------------*/ <br>#define _ANSI_R    (TCHAR)'\r' <br>LRESULT CALLBACK NewEditProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam ) <br>{ <br>    switch (msg) { <br>case WM_CHAR: <br>    // Trap a keydown for &lt;cr&gt; <br>    if (wParam == _ANSI_R) { <br>// Send message to parent giving ID 2 (which doesn't <br>// exist) <br>FORWARD_WM_COMMAND(GetParent(hwnd), 2, NULL, 0, PostMessage); <br>return 0L; <br>    } <br> <br>    // Need normal handling of characters otherwise <br>    goto callDWP; <br> <br>case WM_KEYUP: <br>    // Trap a keydown for &lt;Esc&gt;. This is how we get out without <br>    // making a modification. <br>    if (wParam == VK_ESCAPE) { <br>// Send message to parent giving ID 3 (which doesn't <br>// exist) <br>FORWARD_WM_COMMAND(GetParent(hwnd), 3, NULL, 0, PostMessage); <br>return 0L; <br>    } <br> <br>    // We want to fall through so what should happen on keydown <br>    // does. <br> <br>default: <br>callDWP: <br>    // Just call the old window proc <br>    return CallWindowProc(gOldEditProc, hwnd, msg, wParam, lParam); <br>    } <br>} <br> <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_CREATE <br>// <br>// ****************************************************************************** <br> <br>BOOL App_OnCreate(HWND hwnd, LPCREATESTRUCT lpCreateStruct) <br>{ <br>    DragAcceptFiles(hwnd, TRUE); <br> <br>    if (gszFileName[0]) <br>InitAvi(hwnd, gszFileName, MENU_OPEN); <br> <br>    return TRUE; <br>} <br> <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_COMMAND <br>// <br>// ****************************************************************************** <br> <br>void App_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    if (id == 2) <br>EditDone(hwnd, TRUE); <br>// See if we are terminating editting. <br>    else if (id == 3) <br>EditDone(hwnd, FALSE); <br>    else <br>MenuHandler( hwnd, id ); <br>} <br> <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_DROPFILES <br>// <br>// ****************************************************************************** <br>// <br>void App_OnDropFiles(HWND hwnd, HDROP hdrop) <br>{ <br>    DropAvi(hwnd, hdrop); <br> <br>    return; <br>} <br> <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_INITMENU <br>// <br>// ****************************************************************************** <br>void App_OnInitMenu(HWND hwnd, HMENU hMenu) <br>{ <br>    int i; <br>    BOOL f; <br>    PAVIFILE pf; <br> <br>    f = gcpavi &gt; 0; <br>    EnableMenuItem(hMenu, MENU_SAVEAS, f ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem(hMenu, MENU_OPTIONS,f ? MF_ENABLED : MF_GRAYED); <br> <br>    EnableMenuItem(hMenu, MENU_CLOSE,  f ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem(hMenu, MENU_MERGE,  f ? MF_ENABLED : MF_GRAYED); <br> <br>    EnableMenuItem(hMenu, MENU_SETINFO,  f ? MF_ENABLED : MF_GRAYED); <br> <br>    // !!! Why not provide UNDO while I'm at it? <br>    // Enable CUT/COPY/DELETE if there's something selected in a stream <br>    f = FALSE; <br>    for (i=0; i&lt;gcpavi; i++) <br>if (galSelStart[i] != -1) <br>    f = TRUE; <br> <br>    EnableMenuItem(hMenu, MENU_COPY,   f ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem(hMenu, MENU_CUT,    f ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem(hMenu, MENU_DELETE, f ? MF_ENABLED : MF_GRAYED); <br> <br>    // If we haven't an edit window, we need to setup the "Name' <br>    // <br>    if (ghwndEdit == NULL) <br>    { <br>LoadString( ghInstApp, IDS_NAME, gszBuffer, BUFSIZE ); <br>ModifyMenu(hMenu, MENU_NAME, MF_BYCOMMAND | MF_STRING, MENU_NAME, gszBuffer); <br>EnableMenuItem(hMenu, MENU_NAME, <br>       (gSelectedStream &gt;= MAXNUMSTREAMS) ? MF_ENABLED : MF_GRAYED); <br>    } <br>    else <br>    { <br>LoadString( ghInstApp, IDS_ABORTNAME, gszBuffer, BUFSIZE ); <br>ModifyMenu(hMenu, MENU_NAME, MF_BYCOMMAND | MF_STRING,MENU_NAME, gszBuffer); <br>EnableMenuItem(hMenu, MENU_NAME,MF_ENABLED); </code></pre>
<p>
</p>
<pre><code>} <br> <br>    // See if there's anything to paste.... <br>    f = FALSE; <br>    AVIGetFromClipboard(&amp;pf); <br> <br>    if (pf) <br>    { <br>f = TRUE; <br>AVIFileRelease(pf); <br>    } <br> <br>    EnableMenuItem(hMenu, MENU_PASTE,  f ? MF_ENABLED : MF_GRAYED); <br> <br>    f = gfAudioFound | gfVideoFound; <br>    EnableMenuItem(hMenu, MENU_PREVIEW, (f &amp; !gfPlaying) ? MF_ENABLED : MF_GRAYED); <br>    EnableMenuItem(hMenu, MENU_STOP,    (f &amp; gfPlaying)  ? MF_ENABLED : MF_GRAYED); <br> <br>    CheckMenuItem(hMenu, MENU_ZOOMQUARTER, (gwZoom == 1)  ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem(hMenu, MENU_ZOOMHALF,    (gwZoom == 2)  ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem(hMenu, MENU_ZOOM1,       (gwZoom == 4)  ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem(hMenu, MENU_ZOOM2,       (gwZoom == 8)  ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem(hMenu, MENU_ZOOM4,       (gwZoom == 16) ? MF_CHECKED : MF_UNCHECKED); <br> <br> <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_SIZE <br>// <br>// ****************************************************************************** <br> <br>void App_OnSize(HWND hwnd, UINT state, int cx, int cy) <br>{ <br>    RECT rc; <br> <br>    GetClientRect(hwnd, &amp;rc); <br>    // <br>    // There is not enough vertical room to show all streams. Scrollbars <br>    // are required. <br>    // <br>    if (nVertHeight &gt; rc.bottom) <br>    { <br>nVertSBLen = nVertHeight - rc.bottom; <br>SetScrollRange(hwnd, SB_VERT, 0, nVertSBLen, TRUE); <br>    } <br>    else// Everything fits vertically. No scrollbar necessary. <br>    { <br>nVertSBLen = 0; <br>SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>    } <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_DESTROY <br>// <br>// ****************************************************************************** <br>// <br>void App_OnDestroy(HWND hwnd) <br>{ <br>    AVIClearClipboard(); <br>    FreeAvi(hwnd);      // close all open streams <br>    AVIFileExit();      // shuts down the AVIFile system <br>    PostQuitMessage(0); <br> <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_ENDSESSION <br>// <br>// ****************************************************************************** <br>// <br>void App_OnEndSession(HWND hwnd, BOOL fEnding) <br>{ <br>    if (fEnding) <br>    { <br>if (GetClipboardOwner() == hwnd) <br>{ <br>    if (OpenClipboard(hwnd)) <br>    { <br>EmptyClipboard(); <br>CloseClipboard(); <br>    } <br>} <br>FreeAvi(hwnd); <br>    } <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_PALETTECHANGED <br>// <br>// ****************************************************************************** <br>// <br>void App_OnPaletteChanged(HWND hwnd, HWND hwndPaletteChange) <br>{ <br>    // It came from us.  Ignore it <br>    if (hwndPaletteChange == hwnd) <br>return; <br> <br>    //if needed, insert any calls - such as RealizePallete - below <br> <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_KEYDOWN <br>// <br>// ****************************************************************************** <br>// <br>void App_OnKey(HWND hwnd, UINT vk, BOOL fDown, int cRepeat, UINT flags) <br>{ <br>    if(fDown) <br>    { <br>switch (vk) <br>{ <br>    case VK_UP: <br>FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEUP, 0, PostMessage); <br>break; <br>    case VK_DOWN: <br>FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEDOWN, 0, PostMessage); <br>break; <br>    case VK_PRIOR: <br>FORWARD_WM_HSCROLL(hwnd, NULL, SB_PAGEUP, 0, PostMessage); <br>break; <br>    case VK_NEXT: <br>FORWARD_WM_HSCROLL(hwnd, NULL, SB_PAGEDOWN, 0, PostMessage); <br>break; <br>    case VK_HOME: <br>FORWARD_WM_HSCROLL(hwnd, NULL, SB_THUMBPOSITION, 0, PostMessage); <br>break; <br>    case VK_END: <br>FORWARD_WM_HSCROLL(hwnd, NULL, SB_THUMBPOSITION, 0x7FFF, PostMessage); <br>break; <br>    case VK_LEFT: <br>FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEUP, 0, PostMessage); <br>break; <br>    case VK_RIGHT: <br>FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEDOWN, 0, PostMessage); <br>break; <br>} <br>    } <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_HSCROLL <br>// <br>// ****************************************************************************** <br>// <br>void App_OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos) <br>{ <br>    LONG lScrollTime; <br> <br>    lScrollTime = GetScrollTime(hwnd); <br> <br>    switch (code) <br>    { <br>case SB_LINEDOWN: <br>    lScrollTime += timehscroll; <br>    break; <br>case SB_LINEUP: <br>    lScrollTime -= timehscroll; <br>    break; <br>case SB_PAGEDOWN: <br>    lScrollTime += timeLength/10; <br>    break; <br>case SB_PAGEUP: <br>    lScrollTime -= timeLength/10; <br>    break; <br>case SB_THUMBTRACK: <br>case SB_THUMBPOSITION: <br>    lScrollTime = pos; <br>    lScrollTime = timeStart + muldiv32(lScrollTime, timeLength, SCROLLRANGE); <br>    break; <br>    } <br> <br>    if (lScrollTime &lt; timeStart) <br>lScrollTime = timeStart; <br> <br>    if (lScrollTime &gt; timeEnd) <br>lScrollTime = timeEnd; <br> <br>    if (lScrollTime == (LONG)GetScrollTime(hwnd)) <br>return; <br> <br>    SetScrollTime(hwnd, lScrollTime); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    UpdateWindow(hwnd); <br> <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_VSCROLL <br>// <br>// ****************************************************************************** <br>// <br>void App_OnVScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos) <br>{ <br>    int nScrollPos; <br>    RECT rc; <br> <br>    nScrollPos = GetScrollPos(hwnd, SB_VERT); <br> <br>    GetClientRect(hwnd, &amp;rc); <br> <br>    switch (code) <br>    { <br>case SB_LINEDOWN: <br>    nScrollPos += 10; <br>    break; <br>case SB_LINEUP: <br>    nScrollPos -= 10; <br>    break; <br>case SB_PAGEDOWN: <br>    nScrollPos += rc.bottom; <br>    break; <br>case SB_PAGEUP: <br>    nScrollPos -= rc.bottom; <br>    break; <br>case SB_THUMBTRACK: <br>case SB_THUMBPOSITION: <br>    nScrollPos = pos; <br>    break; <br>    } <br> <br>    if (nScrollPos &lt; 0) <br>nScrollPos = 0; <br> <br>    if (nScrollPos &gt; nVertSBLen) <br>nScrollPos = nVertSBLen; <br> <br>    if (nScrollPos == GetScrollPos(hwnd, SB_VERT)) <br>return; <br> <br>    SetScrollPos(hwnd, SB_VERT, nScrollPos, TRUE); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    UpdateWindow(hwnd); <br> <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_RBUTTONDOWN <br>// <br>// ****************************************************************************** <br>// <br>void App_OnRButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) <br>{ <br>    RECT rc; <br>    int i; <br>    // Invalidate any stream that has something selected.  It needs <br>    // to redraw now. <br>    if (gSelectedStream &gt;= MAXNUMSTREAMS) { <br>if (ghwndEdit) <br>    EditDone(hwnd, FALSE); <br>else { <br>    InvalidateRect(hwnd, &amp;grcSelectedStream, TRUE); // needs to erase <br>    gSelectedStream = -1; <br>} <br>    } <br>    else { <br>GetClientRect(hwnd, &amp;rc); <br>for (i = 0; i &lt; gcpavi; i++) { <br>     if (galSelStart[i] != -1) { <br>rc.top = gStreamTop[i] - GetScrollPos(hwnd, SB_VERT); <br>rc.bottom =gStreamTop[i+1] -GetScrollPos(hwnd, SB_VERT); <br>InvalidateRect(hwnd, &amp;rc, TRUE); // needs to erase <br>    } <br>} <br> <br>// Deselect everything <br>SelectStream(hwnd, -1, -1, -1, FALSE, FALSE); <br>    } <br>    return; <br>} <br>// ****************************************************************************** <br>// <br>//      Message Handler for WM_LBUTTONDOWN <br>// <br>// ****************************************************************************** <br>// <br>void App_OnLButtonDown(HWND hwnd, BOOL fDoubleClick, int x, int y, UINT keyFlags) <br>{ <br>    int yTop, yBottom = 0, iFrameWidth, nFrames; <br>    int i,j,n; <br>    AVISTREAMINFO       avis; <br>    BOOL fShift = FALSE; <br>    BOOL fCtrl = FALSE; <br>    RECT rc, rcC; <br>    LONG        l, lTime, lSamp, lCurSamp; <br> <br>    if( fDoubleClick ) { <br>// See if we get to edit a stream name <br>if (gSelectedStream &gt;= MAXNUMSTREAMS) <br>    EditStreamName(hwnd); <br> <br>return; <br>    } <br> <br>    GetClientRect(hwnd, &amp;rc); <br>    rcC = rc; <br>    yBottom = -GetScrollPos(hwnd, SB_VERT);     // offset for scrollbar <br> <br>    // If we currently have a stream name selected, we must <br>    // deselect it. <br>    if (gSelectedStream &gt;= MAXNUMSTREAMS) { <br>// Erase the select marks <br>if (ghwndEdit) <br>    EditDone(hwnd, FALSE); <br>else <br>    InvalidateRect(hwnd, &amp;grcSelectedStream, TRUE); <br> <br>// Stream no longer selected. <br>gSelectedStream = -1; <br>    } <br>    else { <br>// <br>// Otherwise, if the shift key isn't down, <br>// we deselect everything first <br>// <br>fShift = GetAsyncKeyState(VK_SHIFT) &amp; 0x8000; <br>fCtrl = GetAsyncKeyState(VK_CONTROL) &amp; 0x8000; <br>if (!fShift) { <br>    // Invalidate any stream that has something selected.  It needs <br>    // to redraw now. <br>    for (j = 0; j &lt; gcpavi; j++) { <br>if (galSelStart[j] != -1) { <br>    rc.top = gStreamTop[j] - GetScrollPos(hwnd, SB_VERT); <br>    rc.bottom =gStreamTop[j+1] -GetScrollPos(hwnd, SB_VERT); <br>    InvalidateRect(hwnd, &amp;rc, TRUE); // needs to erase <br>} <br>    } <br>    // Deselect everything <br>    SelectStream(hwnd, -1, -1, -1, FALSE, FALSE); <br>} <br>    } <br> <br> <br>    // <br>    // Walk the streams and find out where we clicked <br>    // <br>    for (i=0; i&lt;gcpavi; i++) { <br>AVIStreamInfo(gapavi[i], &amp;avis, sizeof(avis)); <br> <br>// See if they clicked on the name <br>yTop = gStreamTop[i] - GetScrollPos(hwnd, SB_VERT); <br>yBottom = yTop + (2 * TSPACE);  // !!! size of stream header <br> <br>if (y &gt;= yTop &amp;&amp; y &lt; yBottom) { <br> <br>    gSelectedStream = MAXNUMSTREAMS+i;  // which stream's header it is <br>    rc.top = yTop; <br>    rc.bottom = yBottom; <br>    grcSelectedStream = rc;     // Invalidate this on button up <br> <br>    InvalidateRect(hwnd, &amp;rc, FALSE);   // repaint whole strip <br> <br>    // No need to be here anymore <br>    return; <br>} <br> <br> <br>//******************************************************************* <br>// See if they clicked on the information Header <br>yTop = yBottom; <br>yBottom = yTop + (2 * TSPACE);  // !!! size of stream header <br> <br>// <br>// If they've clicked on the header - select the whole stream <br>// <br>if (y &gt;= yTop &amp;&amp; y &lt; yBottom) { <br> <br>    // Maybe select everything if Ctrl is held down <br>    SelectStream(hwnd, i, AVIStreamStart(gapavi[i]), <br> AVIStreamEnd(gapavi[i]), FALSE, fCtrl); <br> <br>    // Tell paint code to highlight the text area.  Invalidate <br>    // the whole stream area.  When they let go of the mouse, <br>    // redraw the text area only. <br>    gSelectedStream = i;        // which stream's header it is <br>    rc.top = yTop; <br>    rc.bottom = yBottom; <br>    grcSelectedStream = rc;     // Invalidate this on button up <br>    // Now get the area of the whole stream <br>    rc.bottom = gStreamTop[i + 1] - GetScrollPos(hwnd, SB_VERT); <br>    InvalidateRect(hwnd, &amp;rc, FALSE);   // repaint whole strip <br> <br>    // Time to go <br>    return; <br>} <br> <br>// ******************************************************************* <br> <br>// <br>// Now get the area of the stream data, and... <br>// <br>yTop = yBottom; <br>yBottom = gStreamTop[i + 1] - GetScrollPos(hwnd, SB_VERT); <br> <br>// <br>// ... see if we clicked on a video frame, or... <br>// <br>if (avis.fccType == streamtypeVIDEO) { <br>    if (gapgf[i] == NULL) <br>continue; <br> <br>    // <br>    // We're in the vertical range of the strip of video <br>    // <br>    if (y &gt;= yTop &amp;&amp; y &lt; yBottom) { <br> <br>rc.top = yTop; rc.bottom = yBottom; <br>// Time at the centre of the strip <br>lTime = GetScrollTime(hwnd); <br>// What frame should appear in the centre? Times that <br>// are too big will all return the last frame, so we <br>// need to calculate the hypothetical frame number <br>if (lTime &lt;= AVIStreamEndTime(gapavi[i])) { <br>    lSamp = AVIStreamTimeToSample(gapavi[i], lTime); <br>} <br>else { <br>    lSamp = AVIStreamEnd(gapavi[i]) + <br>    AVIStreamTimeToSample(gapavi[i], <br>  lTime - AVIStreamEndTime(gapavi[i])); <br>} <br>// How wide is each frame? <br>iFrameWidth = (avis.rcFrame.right - avis.rcFrame.left) * <br>      gwZoom / 4 + HSPACE;    // !!! hacky constant <br>// How many frames on each half of centre? <br>nFrames = (rcC.right - iFrameWidth) / (2 * iFrameWidth); <br>if (nFrames &lt; 0) <br>    nFrames = 0;        // at least show *something* <br> <br>// <br>// Walk all frames and find which one we're on top of <br>// <br>for (n = -nFrames; n &lt;= nFrames; n++) { <br> <br>    rc.left   = rcC.right / 2 - <br>(avis.rcFrame.right * gwZoom / 4) / 2 + <br>(n * iFrameWidth); <br>    rc.right = rc.left + iFrameWidth; <br> <br>    // <br>    // We're on top of this frame! <br>    // <br>    if (x &gt;= rc.left &amp;&amp; x &lt; rc.right) { <br>// <br>// For the top video stream, it's easy to tell <br>// which frame we're on... each frame is <br>// displayed in order. <br>// <br>if (i == giFirstVideo) <br>    SelectStream(hwnd, i, lSamp + n, 1, fShift, fCtrl); <br> <br> <br>// <br>// For other video streams, we need to calculate <br>// the time of the spot we're on, and see which <br>// frame is associated with it, because who <br>// knows what scale we're using for time. <br>// <br>else { <br>    l = lTime + MulDiv32(n * iFrameWidth, gdwMicroSecPerPixel, 1000); <br>    lCurSamp = AVIStreamTimeToSample( gapavi[i], l); <br>    SelectStream(hwnd, i, lCurSamp, 1, fShift, fCtrl); <br>} <br> <br>// <br>// Invalidate what we'll be highlighting. <br>// This includes the text area above.  If <br>// we're adding to a selection, invalidate the <br>// whole strip because other frames might <br>// become selected by this, and the text <br>// changes. <br>// <br>InflateRect(&amp;rc, HSPACE / 2, VSPACE / 2); <br>if (fShift) {       // could select more than this <br>    rc.left = 0; <br>    rc.right = rcC.right; <br>} <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br>// Now invalidate the text area <br>rc.bottom = rc.top; <br>rc.top -= (2 * TSPACE); // !!! text changes <br>rc.left = 0; <br>rc.right = rcC.right; <br>// If we've got selection text already, erase <br>InvalidateRect(hwnd, &amp;rc, fShift); <br>return; <br>    } <br>}//end of inner frame walk for statement <br>    } <br>} <br> <br>// ******************************************************************** <br> <br>// <br>// ... see if we clicked on an audio section <br>// <br>else if (avis.fccType == streamtypeAUDIO) { <br> <br>    // <br>    // We clicked inside the wave! <br>    // <br>    if (y &gt;= yTop &amp;&amp; y &lt; yBottom) { <br> <br>// <br>// Get the time we clicked on, and it's sample number <br>// <br>GetClientRect(hwnd, &amp;rcC); <br>lTime = GetScrollTime(hwnd); <br>if (x &lt; (rcC.right/2)) { //button down to the left of current position <br>    l = lTime - muldiv32( (rcC.right / 2) - x, gdwMicroSecPerPixel, 1000); <br>} <br>else { <br>    l = lTime + muldiv32(x - rcC.right / 2, gdwMicroSecPerPixel, 1000); <br>} <br>lCurSamp = AVIStreamTimeToSample(gapavi[i], l); <br> <br>SelectStream(hwnd, i, lCurSamp, 1, fShift, fCtrl); <br> <br>// Invalidate what we'll need to repaint to show it <br>rc.left = x - 2;        // may not be exact right pixel <br>rc.right = x + 3; <br>rc.top = yTop; <br>rc.bottom = yBottom; <br>InflateRect(&amp;rc, 0, VSPACE / 2); <br>// If we're adding to a selection, we better invalidate <br>// the whole strip. <br>if (fShift) { <br>    rc.left = 0; <br>    rc.right = rcC.right; <br>} <br>InvalidateRect(hwnd, &amp;rc, FALSE); <br>// Now invalidate the header text <br>rc.bottom = rc.top; <br>rc.top -= (2 * TSPACE); // !!! text changes <br>rc.left = 0; <br>rc.right = rcC.right; <br>// If we've got selection text already, erase <br>InvalidateRect(hwnd, &amp;rc, fShift); <br>    } <br>} <br>    }//end of stream walk for statement <br> <br> <br>    return; <br>} <br>// **************************************************************************** <br>// <br>//      Message Handler for WM_LBUTTONUP <br>// <br>// **************************************************************************** <br>// <br>void App_OnLButtonUp(HWND hwnd, int x, int y, UINT keyFlags) <br>{ <br>    // <br>    // If we're selecting a whole stream, stop highlighting the text area <br>    // <br>    if ((gSelectedStream &gt;= 0) &amp;&amp; (gSelectedStream &lt; MAXNUMSTREAMS)) <br>    { <br>InvalidateRect(hwnd, &amp;grcSelectedStream, TRUE); <br>gSelectedStream = -1; <br>    } <br>    return; <br>} <br>/*----------------------------------------------------------------------------*\ <br>|   AppWndProc( hwnd, uiMessage, wParam, lParam )                              | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The window proc for the app's main (tiled) window.  This processes all | <br>|       of the parent window's messages.                                       | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hwnd            window handle for the window                           | <br>|       uiMessage       message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       0 if processed, nonzero if ignored                                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>LRESULT CALLBACK AppWndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    BOOL        f; <br>    HDC         hdc; <br> <br>    switch (msg) { <br> <br>// <br>// If we passed a command line filename, open it <br>// <br>case WM_CREATE: <br>    return HANDLE_WM_CREATE(hwnd, wParam, lParam, App_OnCreate); <br> <br>case WM_COMMAND: <br>    HANDLE_WM_COMMAND(hwnd, wParam, lParam, App_OnCommand); <br>    break; <br> <br>case WM_DROPFILES: <br>    HANDLE_WM_DROPFILES(hwnd, wParam, lParam, App_OnDropFiles); <br>    break; <br> <br>case WM_INITMENU: <br>    HANDLE_WM_INITMENU(hwnd, wParam, lParam, App_OnInitMenu); <br>    break; <br> <br>    // <br>    // During a wait state (eg saving) don't let us choose any menus <br>    // <br>case WM_NCHITTEST: <br> <br>    if (gfWait) <br>    { <br>// Let windows tell us where the cursor is <br>lParam = DefWindowProc(hwnd,msg,wParam,lParam); <br> <br>// If it's over a menu, pretend it's in the client (force <br>// hourglass) <br>if (lParam == HTMENU) <br>    lParam = HTCLIENT; <br> <br>return lParam; <br>    } <br>    break; <br>    // <br>    // Set vertical scrollbar for scrolling streams <br>    // <br>case WM_SIZE: <br>    HANDLE_WM_SIZE(hwnd, wParam, lParam, App_OnSize); <br>    break; <br> <br>    // <br>    // During a wait state, show an hourglass over our client area <br>    // !!! Is this necessary? <br>    // <br>case WM_SETCURSOR: <br>    if (gfWait &amp;&amp; LOWORD(lParam) == HTCLIENT) <br>    { <br>SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>return TRUE; <br>    } <br>    break; <br> <br>    // <br>    // We're out of here! <br>    // <br>case WM_DESTROY: <br>    HANDLE_WM_DESTROY(hwnd, wParam, lParam, App_OnDestroy);\ <br>    break; <br> <br>case WM_ENDSESSION: <br>    HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, App_OnEndSession); <br>    break; <br> <br>    // <br>    // Don't let us close ourselves in a wait state (eg saving) <br>    // <br>case WM_CLOSE: <br>    if (gfWait) <br>return 0; <br>    break; <br> <br>    // <br>    // Block keyboard access to menus if waiting <br>    // <br>case WM_SYSCOMMAND: <br>    switch (wParam &amp; 0xFFF0) { <br>case SC_KEYMENU: <br>    if (gfWait) <br>return 0; <br>    break; <br>    } <br>    break; <br> <br>case WM_PALETTECHANGED: <br>    HANDLE_WM_PALETTECHANGED(hwnd, wParam, lParam, App_OnPaletteChanged); <br>    break; <br> <br>case WM_QUERYNEWPALETTE: <br> <br>    if (gfVideoFound) { <br>hdc = GetDC(hwnd); <br>// <br>// Realize the palette of the first video stream <br>// <br>if (f = DrawDibRealize(ghdd[giFirstVideo], hdc, FALSE)) <br>    InvalidateRect(hwnd,NULL,TRUE); <br> <br>ReleaseDC(hwnd,hdc); <br>return f; <br>    } <br>    break; <br> <br>case WM_ERASEBKGND: <br>    break; <br> <br>case WM_PAINT: <br>    hdc = BeginPaint(hwnd,&amp;ps); <br> <br>    PaintStuff(hdc, hwnd, FALSE); <br> <br>    EndPaint(hwnd,&amp;ps); <br>    break; <br> <br>// <br>// handle the keyboard interface <br>// <br>case WM_KEYDOWN: <br>    HANDLE_WM_KEYDOWN(hwnd, wParam, lParam, App_OnKey); <br>    break; <br> <br>case WM_HSCROLL: <br>    HANDLE_WM_HSCROLL(hwnd, wParam, lParam, App_OnHScroll); <br>    break; <br> <br>case WM_VSCROLL: <br>    HANDLE_WM_VSCROLL(hwnd, wParam, lParam, App_OnVScroll); <br>    break; <br> <br>// <br>// Deselect everything <br>// <br>case WM_RBUTTONDOWN: <br>    HANDLE_WM_RBUTTONDOWN(hwnd, wParam, lParam, App_OnRButtonDown); <br>    break; <br> <br>// <br>// Select something <br>// <br>case WM_LBUTTONDOWN: <br>    HANDLE_WM_LBUTTONDOWN(hwnd, wParam, lParam, App_OnLButtonDown); <br>    break; <br> <br>case WM_LBUTTONDBLCLK: <br>    HANDLE_WM_LBUTTONDBLCLK(hwnd, wParam, lParam, App_OnLButtonDown); <br>    break; <br> <br>case WM_LBUTTONUP: <br>    HANDLE_WM_LBUTTONUP(hwnd, wParam, lParam, App_OnLButtonUp); <br>    break; <br> <br>// <br>// Wave driver wants to tell us something.  Pass it on. <br>// <br>case MM_WOM_OPEN: <br>case MM_WOM_DONE: <br>case MM_WOM_CLOSE: <br>    aviaudioMessage(hwnd, msg, wParam, lParam); <br>    break; <br>    } <br>    return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    SaveCallback()                                                             | <br>|                                                                               | <br>|    Our save callback that prints our progress in our window title bar         | <br>\*----------------------------------------------------------------------------*/ <br>BOOL CALLBACK SaveCallback(int iProgress) <br>{ <br>    char    szText[3*BUFSIZE]; <br>    char    szFormat[BUFSIZE]; <br> <br>    LoadString( ghInstApp, IDS_APPNAME, gszBuffer, BUFSIZE ); <br>    LoadString( ghInstApp, IDS_SAVEFORMAT, szFormat, BUFSIZE ); <br> <br>    wsprintf(szText, szFormat, (LPSTR) gszBuffer, (LPSTR) gszSaveFileName, iProgress); <br> <br>    SetWindowText(ghwndApp, szText); <br> <br>    // <br>    // Give ourselves a chance to abort <br>    // <br>    return WinYield(); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    GetDlgItemLong()                                                           | <br>|                                                                               | <br>|    Get a long integer from a dialog item.                                     | <br>\*----------------------------------------------------------------------------*/ <br> <br>DWORD GetDlgItemLong (HWND hwnd,  int idCtl, LPINT lpfOK, BOOL fSigned) <br>{ <br>    LONG        l; <br>    char        ch; <br>    BOOL        fNegative = FALSE; <br>    char        szBuf[64]; <br>    LPSTR       pbuf = szBuf; <br>    BOOL        fOk; <br> <br> <br>    fOk = FALSE; <br>    if (lpfOK) <br>*lpfOK = FALSE; <br> <br>    if (!GetDlgItemText(hwnd, idCtl, (LPSTR)szBuf, sizeof(szBuf)-1)) <br>return(0); <br> <br>    while (*pbuf == ' ') pbuf++; <br> <br>    if (fSigned &amp;&amp; *pbuf == '-') <br>    { <br>pbuf++; <br>fNegative = TRUE; <br>    } <br> <br>    l = 0; <br>    while ((ch = *pbuf++) &gt;= '0' &amp;&amp; ch &lt;= '9') <br>    { <br>fOk = TRUE; <br>if (l &gt; (DWORD)(ULONG_MAX/10)) <br>    return(0); <br>l = (l * 10) + ch - '0'; <br>if (fSigned &amp;&amp; l &gt; (DWORD)(ULONG_MAX/2)) <br>    return(0); <br>    } <br> <br>    if (fNegative) <br>l = -l; <br> <br>    if (lpfOK) <br>*lpfOK = (ch == 0 &amp;&amp; fOk); <br> <br>    return(l); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    SetDlgItemLong()                                                           | <br>|                                                                               | <br>|    Put a long integer into a dialog item.                                     | <br>\*----------------------------------------------------------------------------*/ <br> <br>void SetDlgItemLong (HWND hwnd, int idCtl, DWORD dwValue, BOOL fSigned ) <br>{ <br>    char szBuf[64]; <br> <br>    wsprintf (szBuf, fSigned ? "%ld" : "%lu", dwValue); <br>    SetDlgItemText(hwnd, idCtl, szBuf); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    DoDataExchange()                                                           | <br>|                                                                               | <br>|    Exchange data between our internal buffer and dialog controls              | <br>|    fDir = TRUE for DialogBox-&gt;Buffer                                          | <br>|         = FALSE for Buffer-&gt;DialogBox                                         | <br>\*----------------------------------------------------------------------------*/ <br> <br>void DoDataExchange (HWND hwnd, LPAVISTREAMINFO lpinfo, BOOL fDir) <br>{ <br>    if (fDir) { <br>lpinfo-&gt;wPriority       = (WORD)GetDlgItemInt (hwnd, IDC_PRIORITY,    NULL, FALSE); <br>lpinfo-&gt;wLanguage       = (WORD)GetDlgItemInt (hwnd, IDC_LANGUAGE,    NULL, FALSE); <br>lpinfo-&gt;dwScale         = GetDlgItemLong(hwnd, IDC_SCALE,       NULL, FALSE); <br>lpinfo-&gt;dwRate          = GetDlgItemLong(hwnd, IDC_RATE,        NULL, FALSE); <br>lpinfo-&gt;dwStart         = GetDlgItemLong(hwnd, IDC_START,       NULL, FALSE); <br>lpinfo-&gt;dwQuality       = GetDlgItemLong(hwnd, IDC_QUALITY,     NULL, FALSE); <br>lpinfo-&gt;rcFrame.top     = GetDlgItemInt (hwnd, IDC_FRAMETOP,    NULL, TRUE); <br>lpinfo-&gt;rcFrame.bottom  = GetDlgItemInt (hwnd, IDC_FRAMEBOTTOM, NULL, TRUE); <br>lpinfo-&gt;rcFrame.left    = GetDlgItemInt (hwnd, IDC_FRAMELEFT,   NULL, TRUE); <br>lpinfo-&gt;rcFrame.right   = GetDlgItemInt (hwnd, IDC_FRAMERIGHT,  NULL, TRUE); <br>GetDlgItemText(hwnd, IDC_NAME, lpinfo-&gt;szName, sizeof(lpinfo-&gt;szName)-1); <br>    } <br>    else <br>    { <br>SetDlgItemInt (hwnd, IDC_PRIORITY,    lpinfo-&gt;wPriority,       FALSE); <br>SetDlgItemInt (hwnd, IDC_LANGUAGE,    lpinfo-&gt;wLanguage,       FALSE); <br>SetDlgItemLong(hwnd, IDC_SCALE,       lpinfo-&gt;dwScale,         FALSE); <br>SetDlgItemLong(hwnd, IDC_RATE,        lpinfo-&gt;dwRate,          FALSE); <br>SetDlgItemLong(hwnd, IDC_START,       lpinfo-&gt;dwStart,         FALSE); <br>SetDlgItemLong(hwnd, IDC_QUALITY,     lpinfo-&gt;dwQuality,       FALSE); <br>SetDlgItemLong(hwnd, IDC_FRAMETOP,    lpinfo-&gt;rcFrame.top,     TRUE); <br>SetDlgItemLong(hwnd, IDC_FRAMEBOTTOM, lpinfo-&gt;rcFrame.bottom,  TRUE); <br>SetDlgItemLong(hwnd, IDC_FRAMELEFT,   lpinfo-&gt;rcFrame.left,    TRUE); <br>SetDlgItemLong(hwnd, IDC_FRAMERIGHT,  lpinfo-&gt;rcFrame.right,   TRUE); <br>SetDlgItemText(hwnd, IDC_NAME, lpinfo-&gt;szName); <br>    } <br>} <br> <br>// ***************************************************************************** <br>// <br>//      FUNCTION: Dlg_DefProc(HWND, UINT, WPARAM, LPARAM) <br>// <br>//      PURPOSE:  Handles default messages for all dialog boxes <br>// <br>// <br>static LRESULT Dlg_DefProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ) <br>{ <br>    return DefDlgProcEx( hDlg, message, wParam, lParam, &amp;gfDefDlgEx ); <br>} <br>// <br>// ***************************************************************************** <br>// <br>//      FUNCTION: InfoDlg_OnInitDialog(HWND, HWND, LPARAM) <br>// <br>//      PURPOSE:  Handles initialization for dialog box <br>// <br>// <br>static BOOL InfoDlg_OnInitDialog(HWND hDlg, HWND hwndFocus, LPARAM lParam) <br>{ <br>    int i; <br>    glpavisi = (LPAVISTREAMINFO) <br>       GlobalAllocPtr (GHND, sizeof(AVISTREAMINFO)*gcpavi); <br> <br>    for ( i = 0; i &lt; gcpavi; ++i) <br>    { <br>AVIStreamInfo(gapavi[i], &amp;glpavisi[i], sizeof(AVISTREAMINFO)); <br>SendDlgItemMessage(hDlg, IDC_STREAMS, CB_ADDSTRING, 0, (LPARAM)(LPSTR)glpavisi[i].szName); <br>    } <br>    SendDlgItemMessage(hDlg, IDC_STREAMS, CB_SETCURSEL, 0, 0); <br>    gnSel = 0; <br>    DoDataExchange(hDlg, &amp;glpavisi[0], FALSE); <br> <br>    return (FALSE); <br>} <br>// <br>// ***************************************************************************** <br>// <br>//      FUNCTION: InfoDlg_OnCommand(HWND, HWND, UINT) <br>// <br>//      PURPOSE:  Handles the child controls for dialog box <br>// <br>//      DIALOGBOX ID'S <br>// <br>//              IDOK            - ok button <br>//              IDCANCEL        - cancel button <br>//      IDC_STREAMS             - the dropdown listbox <br>// <br>static void InfoDlg_OnCommand(HWND hDlg, int control_source, HWND control_handle, UINT control_action ) <br>{ <br> <br>    switch (control_source) <br>    { <br>case IDC_STREAMS: <br>{ <br>    if (control_action != CBN_SELCHANGE) <br>break; <br>    if (gnSel != CB_ERR) <br>DoDataExchange (hDlg, &amp;glpavisi[gnSel], TRUE); <br>    gnSel = (int)SendDlgItemMessage(hDlg, IDC_STREAMS, CB_GETCURSEL, 0, 0); <br>    if (gnSel != CB_ERR) <br>DoDataExchange(hDlg, &amp;glpavisi[gnSel], FALSE); <br>} <br>break; <br> <br>case IDOK: <br>case IDCANCEL: <br>{ <br>    BOOL fOk = (control_source == IDOK); <br>    int i,ix; <br> <br>    if (fOk) <br>    { <br>ix = (int)SendDlgItemMessage(hDlg, IDC_STREAMS, CB_GETCURSEL, 0, 0); <br>if (ix != CB_ERR) <br>    DoDataExchange(hDlg, &amp;glpavisi[ix], TRUE); <br> <br>for (i = 0; i &lt; gcpavi; ++i) <br>    EditStreamSetInfo(gapavi[i], &amp;glpavisi[i], sizeof(AVISTREAMINFO)); <br>    } <br>    GlobalFreePtr(glpavisi); <br>    EndDialog(hDlg, fOk); <br>} <br>break; <br> <br>    } <br>    return; <br>} <br>// <br>// ***************************************************************************** <br>// <br>//      FUNCTION: SetInfoNewDlgProc(HWND, UINT, WPARAM, LPARAM) </code></pre>
<p>
</p>
<pre><code>// <br>//      PURPOSE:  Processes messages for dialog box using message crackers <br>// <br>//      MESSAGES: <br>// <br>//              WM_INITDIALOG   - initialize dialog box <br>//              WM_COMMAND              - process user input <br>// <br>// ***************************************************************************** <br>// <br>static LRESULT SetInfoNewDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (message) <br>    { <br>HANDLE_MSG( hDlg, WM_INITDIALOG,            InfoDlg_OnInitDialog            ); <br>HANDLE_MSG( hDlg, WM_COMMAND,                       InfoDlg_OnCommand               ); <br>default: <br>    return Dlg_DefProc( hDlg, message, wParam, lParam ); <br>    } <br>} <br>// <br>// <br>// ***************************************************************************** <br>// <br>//      FUNCTION: SetInfoDlgProc(HWND, UINT, WPARAM, LPARAM) <br>// <br>//      PURPOSE:  Processes messages for info dialog box <br>// <br>// <br>BOOL CALLBACK SetInfoDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    CheckDefDlgRecursion( &amp;gfDefDlgEx ); <br>    return SetDlgMsgResult( hDlg, message, SetInfoNewDlgProc( hDlg, message, wParam, lParam ) ); <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    SetStreamInfo()                                                            | <br>|                                                                               | <br>|    Bring up the dialog to allow setting the stream info                       | <br>\*----------------------------------------------------------------------------*/ <br> <br>BOOL SetStreamInfo (HWND hwnd) <br>{ <br>    return(DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_STREAMINFO), hwnd, (DLGPROC)SetInfoDlgProc)); <br>} <br> <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>|    editPaste()                                                                | <br>|                                                                               | <br>|    PASTE the streams in this PFILE into our movie using the following logic:  | <br>|                                                                               | <br>|    Take a stream from the clipboard.  If you can find a similar type stream   | <br>|    in the app with a selection, paste it in before the selection.  If no      | <br>|    such stream exists, add it to the end.                                     | <br>\*----------------------------------------------------------------------------*/ <br> <br>void editPaste(HWND hwnd, PAVIFILE pfile) <br>{ <br>    int         i, j, nVideo = 0, nAudio = 0, nStream; <br>    LONG        l; <br>    PAVISTREAM  pavi; <br>    AVISTREAMINFO avisClip, avis; <br> <br>    FreeDrawStuff(hwnd); <br> <br>    for (i=0; i&lt;MAXNUMSTREAMS; i++) { <br>if (AVIFileGetStream(pfile, &amp;pavi, 0L, i) != AVIERR_OK) <br>    break; <br>AVIStreamInfo(pavi, &amp;avisClip, sizeof(avisClip)); <br>nStream = (avisClip.fccType == streamtypeVIDEO) ? nVideo : nAudio; <br>for (j=nStream; j&lt;gcpavi; j++) { <br>    AVIStreamInfo(gapavi[j], &amp;avis, sizeof(avis)); <br>    if (avis.fccType == avisClip.fccType &amp;&amp; galSelStart[j] != -1) { <br>l = AVIStreamLength(pavi); <br>if (EditStreamPaste(gapavi[j], &amp;galSelStart[j], &amp;l, <br>    pavi, AVIStreamStart(pavi), AVIStreamLength(pavi)) != <br>    AVIERR_OK) <br>{ <br>    LoadString( ghInstApp, IDS_NOPASTE, gszBuffer, BUFSIZE ); <br>    ErrMsg(gszBuffer); <br>} <br>galSelLen[j] = AVIStreamLength(pavi); <br>break; <br>    } <br>} <br>if (j == gcpavi) { <br>    galSelStart[j] = AVIStreamStart(pavi); <br>    galSelLen[j] = AVIStreamLength(pavi); <br>    if (CreateEditableStream(&amp;gapavi[j], pavi) != AVIERR_OK) <br>    { <br>LoadString( ghInstApp, IDS_PASTEERROR, gszBuffer, BUFSIZE ); <br>ErrMsg(gszBuffer); <br>AVIStreamRelease(pavi); <br>break; <br>    } <br>    AVIStreamRelease(pavi); <br>    gcpavi++; <br>} <br>if (avisClip.fccType == streamtypeVIDEO) <br>    nVideo = ++j; <br>else <br>    nAudio = ++j; <br>    } <br>    AVIFileRelease(pfile); <br>    InitStreams(hwnd); <br>    FixWindowTitle(hwnd); <br>} <br>/*----------------------------------------------------------------------------*\ <br>|    MenuHandler()                                                              | <br>|                                                                               | <br>|    Process all of our Menu messages.                                  | <br>\*----------------------------------------------------------------------------*/ <br>BOOL MenuHandler( HWND hwnd, int nMenuID ) <br>{ <br>    OPENFILENAME ofn; <br> <br>    switch(nMenuID) <br>    { <br>case MENU_ABOUT: <br>    // <br>    // Display an informative dialog box. <br>    // <br>    DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_ABOUT), hwnd, (DLGPROC)AboutDlgProc); <br>    break; <br>    // <br>    // We want out of here! <br>    // <br>case MENU_EXIT: <br>    PostMessage(hwnd,WM_CLOSE,0,0L); <br>    break; <br> <br>    // <br>    // Set the compression options for each stream - pass an array of <br>    // streams and an array of compression options structures <br>    // <br>case MENU_OPTIONS: <br>    AVISaveOptions(hwnd, <br>   ICMF_CHOOSE_KEYFRAME | ICMF_CHOOSE_DATARATE | <br>   ICMF_CHOOSE_PREVIEW, <br>   gcpavi, gapavi, galpAVIOptions); <br>    break; <br> <br>    // <br>    // Save all the open streams into a file <br>    // <br>case MENU_SAVEAS: <br> <br>    gszSaveFileName[0] = 0; <br> <br>    // <br>    // prompt user for file to save <br>    // <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hwnd; <br>    ofn.hInstance = NULL; <br>    AVIBuildFilter(gszFilter, sizeof(gszFilter), TRUE); <br>    ofn.lpstrFilter = gszFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0; <br>    ofn.nFilterIndex = 0; <br>    ofn.lpstrFile = gszSaveFileName; <br>    ofn.nMaxFile = sizeof(gszSaveFileName); <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrInitialDir = NULL; <br>    LoadString( ghInstApp, IDS_SAVETITLE, gszBuffer, BUFSIZE ); <br>    ofn.lpstrTitle = gszBuffer; <br>    ofn.Flags = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | <br>OFN_OVERWRITEPROMPT; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    LoadString( ghInstApp, IDS_DEFEXT, gszBuffer, BUFSIZE ); <br>    ofn.lpstrDefExt = gszBuffer; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = NULL; <br>    ofn.lpTemplateName = NULL; <br> <br>    // <br>    // If we get a filename, save it <br>    // <br>    if (GetSaveFileName(&amp;ofn)) <br>    { <br>    DWORD       fccHandler[MAXNUMSTREAMS]; <br>    int         i; <br>    HRESULT     hr; <br> <br>    StartWait(); <br> <br>    for (i = 0; i &lt; gcpavi; i++) <br>fccHandler[i] = galpAVIOptions[i]-&gt;fccHandler; <br> <br>    hr = AVISaveV(gszSaveFileName, <br>  NULL, <br>      (AVISAVECALLBACK) SaveCallback, <br>  gcpavi, <br>  gapavi, <br>  galpAVIOptions); <br>if (hr != AVIERR_OK) { <br>    switch (hr) { <br>    case AVIERR_FILEOPEN: <br>LoadString( ghInstApp, IDS_ERROVERWRITE, gszBuffer, BUFSIZE ); <br>ErrMsg(gszBuffer); <br>break; <br>    default: <br>LoadString( ghInstApp, IDS_SAVEERROR, gszBuffer, BUFSIZE ); <br>ErrMsg(gszBuffer); <br>    } <br>} <br>    // Now put the video compressors back that we stole <br>    for (i = 0; i &lt; gcpavi; i++) <br>galpAVIOptions[i]-&gt;fccHandler = fccHandler[i]; <br> <br>    EndWait(); <br>    FixWindowTitle(hwnd); <br>    } <br>    break; <br> <br>    // <br>    // Close everything <br>    // <br>case MENU_CLOSE: <br>    FreeAvi(hwnd); <br>    gszFileName[0] = '\0'; <br>    FixWindowTitle(hwnd); <br>    break; <br> <br>    // <br>    // Open a new file, or merge streams with a new file <br>    // <br>case MENU_OPEN: <br>case MENU_MERGE: <br>    gszFileName[0] = 0; <br> <br>    // <br>    // prompt user for file to open <br>    // <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hwnd; <br>    ofn.hInstance = NULL; <br>    if (nMenuID == MENU_MERGE) <br>LoadString( ghInstApp, IDS_MERGETITLE, gszBuffer, BUFSIZE ); <br>    else <br>LoadString( ghInstApp, IDS_OPENTITLE, gszBuffer, BUFSIZE ); <br>    ofn.lpstrTitle = gszBuffer; <br>    AVIBuildFilter(gszFilter, sizeof(gszFilter), FALSE); <br>    ofn.lpstrFilter = gszFilter; <br>    ofn.lpstrCustomFilter = NULL; <br>    ofn.nMaxCustFilter = 0; <br>    ofn.nFilterIndex = 0; <br>    ofn.lpstrFile = gszFileName; <br>    ofn.nMaxFile = sizeof(gszFileName); <br>    ofn.lpstrFileTitle = NULL; <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST |OFN_HIDEREADONLY; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = NULL; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = NULL; <br>    ofn.lpTemplateName = NULL; <br> <br>    // <br>    // If we've got a filename, go open it <br>    // <br>    if (GetOpenFileNamePreview(&amp;ofn)) <br>InitAvi(hwnd, gszFileName, nMenuID); <br> <br>    break; <br> <br>case MENU_ZOOMQUARTER: <br>    gwZoom = 1; <br>    FixScrollbars(hwnd); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOMHALF: <br>    gwZoom = 2; <br>    FixScrollbars(hwnd); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOM1: <br>    gwZoom = 4; <br>    FixScrollbars(hwnd); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOM2: <br>    gwZoom = 8; <br>    FixScrollbars(hwnd); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOM4: <br>    gwZoom = 16; <br>    FixScrollbars(hwnd); <br>    InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>// <br>// Simulate playing the file.  We just play the 1st audio stream and let <br>// our main message loop scroll the video by whenever it's bored. <br>// <br>case MENU_PREVIEW: <br>    if (gfAudioFound) <br>aviaudioPlay(hwnd, <br>     gapavi[giFirstAudio], <br>     AVIStreamTimeToSample(gapavi[giFirstAudio], GetScrollTime(hwnd)), <br>     AVIStreamEnd(gapavi[giFirstAudio]), <br>     FALSE); <br>    gfPlaying = TRUE; <br>    glPlayStartTime = timeGetTime(); <br>    glPlayStartPos = GetScrollTime(hwnd); <br>    break; <br> <br>    // <br>    // Stop the play preview <br>    // <br>case MENU_STOP: <br>    if (gfAudioFound) <br>aviaudioStop(); <br>    gfPlaying = FALSE; <br>    break; <br> <br>case MENU_SETINFO: <br>    if (SetStreamInfo(hwnd)) <br>    { <br>FreeDrawStuff(hwnd);        // !!! in order to call InitStreams <br>InitStreams(hwnd);          // !!! Nukes COMP options <br>InvalidateRect(hwnd, NULL, TRUE); <br>    } <br>    break; <br> <br>case MENU_CUT: <br>case MENU_COPY: <br>case MENU_DELETE: <br>{ <br>    PAVIFILE    pf; <br>    int         i; <br> <br>    // <br>    // Walk our list of selections and make streams out of each section <br>    // <br>    gcpaviSel = 0; <br>    for (i = 0; i &lt; gcpavi; i++) { <br>if (galSelStart[i] != -1) { <br>    // !!! What if the start and length change? <br>    if (nMenuID == MENU_COPY) { <br>if (EditStreamCopy(gapavi[i], &amp;galSelStart[i], <br>   &amp;galSelLen[i], &amp;gapaviSel[gcpaviSel++]) != 0) { <br>    --gcpaviSel; <br>    LoadString( ghInstApp, IDS_STRCPYERR, gszBuffer, BUFSIZE ); <br>    ErrMsg(gszBuffer); <br>} <br>    } else { <br>if (EditStreamCut(gapavi[i], &amp;galSelStart[i], <br>  &amp;galSelLen[i], &amp;gapaviSel[gcpaviSel++]) != 0) { <br>    --gcpaviSel; <br>    LoadString( ghInstApp, IDS_STRCUTERR, gszBuffer, BUFSIZE ); <br>    ErrMsg(gszBuffer); <br>} <br>    } <br>} <br>    } <br> <br> <br>    for (i = gcpavi - 1; i &gt;= 0; i--) { <br>// Check to see if any stream is entirely gone now.... <br>if (AVIStreamLength(gapavi[i]) == 0) { <br>    NukeAVIStream(i); <br>} <br>    } <br> <br>    // <br>    // Put the selected stuff up on the clipboard <br>    // <br>    if (gcpaviSel &amp;&amp; nMenuID != MENU_DELETE) { <br>PAVISTREAM          gapaviTemp[MAXNUMSTREAMS]; <br>int i; <br> <br>// <br>// Clone the edited streams, so that if the user does <br>// more editing, the thing on the clipboard won't <br>// suddenly change.... <br>// <br>for (i = 0; i &lt; gcpaviSel; i++) { <br>    gapaviTemp[i] = NULL; <br>    // !!! error check <br>    EditStreamClone(gapaviSel[i], &amp;gapaviTemp[i]); <br>} <br> <br>AVIMakeFileFromStreams(&amp;pf, gcpaviSel, gapaviTemp); <br>if (AVIPutFileOnClipboard(pf) != AVIERR_OK) <br>{ <br>    LoadString( ghInstApp, IDS_NOCLIP, gszBuffer, BUFSIZE ); <br>    ErrMsg(gszBuffer); <br>} <br>for (i = 0; i &lt; gcpaviSel; i++) { <br>    AVIStreamRelease(gapaviTemp[i]); <br>} <br> <br>AVIFileRelease(pf); <br>    } <br> <br>    for (i = 0; i &lt; gcpaviSel; i++) <br>AVIStreamRelease(gapaviSel[i]); <br> <br>    // <br>    // If we cut out the selections, then they don't exist anymore. <br>    // <br>    if (gcpaviSel &amp;&amp; (nMenuID == MENU_DELETE || nMenuID == MENU_CUT)) { <br>SelectStream(hwnd, -1, -1, -1, FALSE, FALSE); <br>    } <br> <br>    // <br>    // We just changed the world! <br>    // <br>    FreeDrawStuff(hwnd);        // !!! in order to call InitStreams <br>    InitStreams(hwnd);          // !!! Nukes COMP options <br>    InvalidateRect(hwnd, NULL, TRUE); <br> <br>    break; <br>} <br> <br>case MENU_PASTE: <br>{ <br>    PAVIFILE pf; <br> <br>    AVIGetFromClipboard(&amp;pf); <br> <br>    if (pf) { <br>editPaste(hwnd, pf); <br>    } <br>    break; <br>} <br>case MENU_NAME: <br>    if (ghwndEdit == NULL) <br>EditStreamName(hwnd); <br>    else <br>EditDone(hwnd, FALSE); <br> <br> <br>    break; <br>    } <br>    return TRUE; <br>} <br>/*----------------------------------------------------------------------------- <br> * FrameVideo() <br> * <br> * Puts a border around a video frame, the size of a selection <br> */ <br> <br>void FrameVideo(HDC hdc, RECT *rcFrame, HBRUSH hbr) <br>{ <br>   RECT rcTop,rcBottom,rcLeft,rcRight; <br>   HBRUSH hbrOld; <br> <br>   // Calculate 4 rectangles, which 'frame' rcFrame. <br>   rcTop.left = rcFrame-&gt;left - HSPACE/2; <br>   rcTop.top = rcFrame-&gt;top - SELECTVSPACE; <br>   rcTop.right = rcFrame-&gt;right + HSPACE/2; <br>   rcTop.bottom = rcFrame-&gt;top; <br>   rcLeft.left = rcFrame-&gt;left - HSPACE/2; <br>   rcLeft.top = rcFrame-&gt;top - SELECTVSPACE; <br>   rcLeft.right = rcFrame-&gt;left; <br>   rcLeft.bottom = rcFrame-&gt;bottom + SELECTVSPACE; <br>   rcRight.left = rcFrame-&gt;right; <br>   rcRight.top = rcFrame-&gt;top - SELECTVSPACE; <br>   rcRight.right = rcFrame-&gt;right + HSPACE/2; <br>   rcRight.bottom = rcFrame-&gt;bottom + SELECTVSPACE; <br>   rcBottom.left = rcFrame-&gt;left - HSPACE/2; <br>   rcBottom.top = rcFrame-&gt;bottom; <br>   rcBottom.right = rcFrame-&gt;right + HSPACE/2; <br>   rcBottom.bottom = rcFrame-&gt;bottom + SELECTVSPACE; <br> <br>   // Now put each rectangle on screen <br>   hbrOld = SelectObject(hdc, hbr); <br>   PatBlt(hdc, rcTop.left, rcTop.top, rcTop.right - rcTop.left, rcTop.bottom - rcTop.top, PATCOPY); <br>   PatBlt(hdc, rcLeft.left, rcLeft.top, rcLeft.right - rcLeft.left, rcLeft.bottom - rcLeft.top, PATCOPY); <br>   PatBlt(hdc, rcRight.left, rcRight.top, rcRight.right - rcRight.left, rcRight.bottom - rcRight.top, PATCOPY); <br>   PatBlt(hdc, rcBottom.left, rcBottom.top, rcBottom.right - rcBottom.left, rcBottom.bottom - rcBottom.top, PATCOPY); <br>   SelectObject(hdc, hbrOld); <br> <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   ErrMsg()                                                                    | <br>|                                                                               | <br>|   Opens a Message box with a error message in it.  The user can               | <br>|   select the OK button to continue                                            | <br>\*----------------------------------------------------------------------------*/ <br> <br>int ErrMsg (LPSTR sz,...) <br>{ <br>    static char szOutput[4*BUFSIZE]; <br> <br>    va_list va; <br> <br>    va_start(va, sz); <br>    wvsprintf (szOutput,sz,va);      /* Format the string */ <br>    va_end(va); <br>    MessageBox(NULL,szOutput,NULL, MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>    return FALSE; <br>} <br> <br> <br>/* AboutDlgProc() <br> * <br> * Dialog Procedure for the "about" dialog box. <br> * <br> */ <br> <br>BOOL CALLBACK AboutDlgProc( <br>  HWND  hwnd, <br>  UINT  msg, <br>  WPARAM        wParam, <br>  LPARAM        lParam) <br>{ <br>    switch (msg) { <br>case WM_COMMAND: <br>    EndDialog(hwnd, TRUE); <br>    return TRUE; <br>case WM_INITDIALOG: <br>    return TRUE; <br>    } <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
