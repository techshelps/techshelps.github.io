<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PALMAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3807"></a>PALMAP.C</h2>
<pre><code>/**************************************************************************** <br> * <br> *  PALMAP.C <br> * <br> *  Stream handler to map to a palette. <br> * <br> ***************************************************************************/ <br> <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "dibmap.h" <br>#include "palmap.h" <br>#include "palmap.rc" <br> <br>#defineINITGUID <br>#include &lt;initguid.h&gt; <br> <br>// Bring in the external GUIDs we need. Apparently compobj.lib doesn't define <br>DEFINE_OLEGUID(IID_IUnknown,0x00000000L, 0, 0); <br> <br> <br>HINSTANCEghMod; <br> <br>STDAPI AVIStreamMakePalette( <br>PAVISTREAM pavi, <br>LONG lSkip, <br>HPALETTE FAR *lphpal, <br>LPBYTE lp16to8, <br>int nColors) <br>{ <br>LPHISTOGRAM lpHist = NULL; <br>LONGl, lEnd; <br>LONGlRet = AVIERR_OK; <br>PGETFRAMEpgf = NULL; <br> <br>if (!pavi || !lphpal || nColors &lt; 2 || nColors &gt; 256) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>if (lSkip &lt; 1) <br>lSkip = 1; <br> <br>lpHist = InitHistogram(NULL); <br>if (!lpHist) <br>return ResultFromScode(AVIERR_MEMORY); <br> <br>pgf = AVIStreamGetFrameOpen(pavi, NULL); <br> <br>l = AVIStreamStart(pavi); <br>lEnd = l + AVIStreamLength(pavi); <br>for (l = AVIStreamStart(pavi), lEnd = l + AVIStreamLength(pavi); <br>l &lt; lEnd; <br>l += lSkip) { <br>LPBITMAPINFOHEADER lpbi; <br> <br>lpbi = AVIStreamGetFrame(pgf, l); <br> <br>if (!lpbi) { <br>lRet = AVIERR_INTERNAL; <br>goto error; <br>} <br> <br>DibHistogram(lpbi, NULL, 0, 0, -1, -1, lpHist); <br>} <br> <br>*lphpal = HistogramPalette(lpHist, lp16to8, nColors); <br> <br>if (!*lphpal) <br>lRet = AVIERR_MEMORY; <br> <br>error: <br>if (pgf) <br>AVIStreamGetFrameClose(pgf); <br> <br>if (lpHist) <br>FreeHistogram(lpHist); <br> <br>return ResultFromScode(lRet); <br>} <br> <br> <br> <br>typedef struct { <br>IAVIStreamVtbl FAR *lpVtbl; <br> <br>ULONGulRefCount; <br> <br>// <br>// instance data <br>// <br>PAVISTREAMpavi; <br>PGETFRAMEpgf; <br>AVISTREAMINFOsinfo; <br>HPALETTEhpal; <br>LPBYTElp16to8; <br>LONGlLastFrame; <br>LPBITMAPINFOHEADERlpdibLast; <br>} PALMAPSTREAM, FAR*PPALMAPSTREAM; <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamQueryInterface( <br>PAVISTREAM ps, <br>REFIID riid, <br>LPVOID FAR* ppvObj); <br>HRESULT STDMETHODCALLTYPE PalMapStreamCreate( <br>PAVISTREAM ps, <br>LONG lParam1, <br>LONG lParam2); <br>ULONGSTDMETHODCALLTYPE PalMapStreamAddRef( <br>PAVISTREAM ps); <br>ULONGSTDMETHODCALLTYPE PalMapStreamRelease( <br>PAVISTREAM ps); <br>HRESULT STDMETHODCALLTYPE PalMapStreamInfo( <br>PAVISTREAM ps, <br>AVISTREAMINFOW FAR * psi, <br>LONG lSize); <br>LONGSTDMETHODCALLTYPE PalMapStreamFindKeyFrame( <br>PAVISTREAM ps, <br>LONG lPos, <br>LONG lFlags); <br>HRESULT STDMETHODCALLTYPE PalMapStreamReadFormat( <br>PAVISTREAM ps, <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG FAR *lpcbFormat); <br>HRESULT STDMETHODCALLTYPE PalMapStreamSetFormat( <br>PAVISTREAM ps, <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG cbFormat); <br>HRESULT STDMETHODCALLTYPE PalMapStreamRead( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples, <br>LPVOID lpBuffer, <br>LONG cbBuffer, <br>LONG FAR * plBytes, <br>LONG FAR * plSamples); <br>HRESULT STDMETHODCALLTYPE PalMapStreamWrite( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples, <br>LPVOID lpBuffer, <br>LONG cbBuffer, <br>DWORD dwFlags, <br>LONG FAR *plSampWritten, <br>LONG FAR *plBytesWritten); <br>HRESULT STDMETHODCALLTYPE PalMapStreamDelete( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples); <br>HRESULT STDMETHODCALLTYPE PalMapStreamReadData( <br>PAVISTREAM ps, <br>DWORD fcc, <br>LPVOID lp, <br>LONG FAR *lpcb); <br>HRESULT STDMETHODCALLTYPE PalMapStreamWriteData( <br>PAVISTREAM ps, <br>DWORD fcc, <br>LPVOID lp, <br>LONG cb); <br>HRESULT STDMETHODCALLTYPE PalMapStreamSetInfo( <br>        PAVISTREAM ps, <br>        AVISTREAMINFOW FAR * psi, <br>        LONG lSize); <br> <br>IAVIStreamVtbl PalMapStreamHandler = { <br>PalMapStreamQueryInterface, <br>PalMapStreamAddRef, <br>PalMapStreamRelease, <br>PalMapStreamCreate, <br>PalMapStreamInfo, <br>PalMapStreamFindKeyFrame, <br>PalMapStreamReadFormat, <br>PalMapStreamSetFormat, <br>PalMapStreamRead, <br>PalMapStreamWrite, <br>PalMapStreamDelete, <br>PalMapStreamReadData, <br>PalMapStreamWriteData, <br>        PalMapStreamSetInfo <br>}; <br> <br>STDAPI AVICreateMappedStream(PAVISTREAM FAR *ppsMapped, <br>PAVISTREAM ps, <br>int nColors) <br>{ <br>PPALMAPSTREAMpavi; <br>HRESULThr; <br> <br>*ppsMapped = 0; <br> <br>pavi = (PPALMAPSTREAM) GlobalAllocPtr(GHND, sizeof(PALMAPSTREAM)); <br>if (pavi == NULL) <br>return ResultFromScode(AVIERR_MEMORY); <br> <br>pavi-&gt;lpVtbl = &amp;PalMapStreamHandler; <br> <br>hr = (pavi-&gt;lpVtbl-&gt;Create)((PAVISTREAM) pavi, (LONG) ps, nColors); <br> <br>if (hr != NOERROR) { <br>(pavi-&gt;lpVtbl-&gt;Release)((PAVISTREAM) pavi); <br>return hr; <br>} <br> <br>*ppsMapped = (PAVISTREAM) pavi; <br> <br>return AVIERR_OK; <br> <br> <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  PalMapStreamOpen() <br>// <br>//  open a single stream of a particular type from a AVI file. <br>// <br>//  params: <br>//      szFile      - PAVISTREAM <br>//      fccType     - must be streamtypeVIDEO <br>//      lParam    - nColors <br>// <br>//  returns: <br>//      a PAVISTREAM for the specifed stream or NULL. <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamCreate( <br>PAVISTREAM ps, <br>LONG lParam1, <br>LONG lParam2) <br>{ <br>PPALMAPSTREAMpavi = (PPALMAPSTREAM) ps; <br>TCHARachTemp[128]; <br>TCHARachTemplate[64]; <br> <br>LONGlRet = AVIERR_OK; <br> <br>pavi-&gt;ulRefCount = 1; <br> <br>AVIStreamAddRef((PAVISTREAM) lParam1); <br> <br>pavi-&gt;pavi = (PAVISTREAM) lParam1; <br> <br>AVIStreamInfo(pavi-&gt;pavi, &amp;pavi-&gt;sinfo, sizeof(pavi-&gt;sinfo)); <br> <br>if (pavi-&gt;sinfo.fccType != streamtypeVIDEO) { <br>lRet = AVIERR_INTERNAL; <br>goto error; <br>} <br> <br>pavi-&gt;pgf = AVIStreamGetFrameOpen(pavi-&gt;pavi, NULL); <br> <br>if (!pavi-&gt;pgf) { <br>lRet = AVIERR_INTERNAL; <br>goto error; <br>} <br> <br>pavi-&gt;sinfo.fccHandler = 0; <br> <br>// Fix up stream name <br>LoadString(ghMod, IDS_STREAMNAME, achTemplate, <br>sizeof(achTemplate) / sizeof(TCHAR)); <br>wsprintf(achTemp, achTemplate, pavi-&gt;sinfo.szName, lParam2); <br>lstrcpyn(pavi-&gt;sinfo.szName, achTemp, <br>sizeof(pavi-&gt;sinfo.szName) / sizeof(TCHAR)); <br>pavi-&gt;sinfo.szName[sizeof(pavi-&gt;sinfo.szName) / sizeof(TCHAR) - 1] = <br>                TEXT('\0'); <br> <br>// default to 256 colors <br>if (lParam2 &lt; 2 || lParam2 &gt; 256) <br>lParam2 = 256; <br> <br>pavi-&gt;lp16to8 = GlobalAllocPtr(GMEM_MOVEABLE, 32768L); <br>if (!pavi-&gt;lp16to8) { <br>lRet = AVIERR_MEMORY; <br>goto error; <br>} <br> <br>lRet = GetScode(AVIStreamMakePalette(pavi-&gt;pavi, <br>AVIStreamLength(pavi-&gt;pavi) / 30, <br>&amp;pavi-&gt;hpal, pavi-&gt;lp16to8, <br>(int) lParam2)); <br> <br>pavi-&gt;lLastFrame = -1; <br> <br>error: <br>return ResultFromScode(lRet); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  PalMapStreamQueryInterface() <br>// <br>//      let other people know what interfaces we support <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>HRESULT STDMETHODCALLTYPE PalMapStreamQueryInterface( <br>PAVISTREAM ps, <br>REFIID riid, <br>LPVOID FAR* ppvObj) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br> <br>if (IsEqualIID(riid, &amp;IID_IUnknown)) <br>*ppvObj = ps; <br>else if (IsEqualIID(riid, &amp;IID_IAVIStream)) <br>*ppvObj = ps; <br>else <br>return ResultFromScode(E_NOINTERFACE); <br> <br>pavi-&gt;ulRefCount++; <br>return NOERROR; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  PalMapStreamAddRef() <br>// <br>//      increase the reference count of the stream <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>ULONG STDMETHODCALLTYPE PalMapStreamAddRef( <br>PAVISTREAM ps) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br> <br>return ++pavi-&gt;ulRefCount; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>//  PalMapStreamRelease() <br>// <br>//      close a PalMapStream stream <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>ULONG STDMETHODCALLTYPE PalMapStreamRelease( <br>PAVISTREAM ps) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br> <br>if (!pavi) <br>return 0; <br> <br>if (--pavi-&gt;ulRefCount) <br>return pavi-&gt;ulRefCount; <br> <br>if (pavi-&gt;pgf) <br>AVIStreamGetFrameClose(pavi-&gt;pgf); <br>pavi-&gt;pgf = 0; <br> <br>if (pavi-&gt;pavi) <br>AVIStreamClose(pavi-&gt;pavi); <br>pavi-&gt;pavi = 0; <br> <br>if (pavi-&gt;lp16to8) { <br>GlobalFreePtr(pavi-&gt;lp16to8); <br>pavi-&gt;lp16to8 = 0; <br>} <br> <br>if (pavi-&gt;hpal) { <br>DeletePalette(pavi-&gt;hpal); <br>pavi-&gt;hpal = 0; <br>} <br> <br>if (pavi-&gt;lpdibLast) { <br>GlobalFreePtr(pavi-&gt;lpdibLast); <br>pavi-&gt;lpdibLast = 0; <br>} <br> <br>GlobalFreePtr(pavi); <br> <br>return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamReadFormat( <br>PAVISTREAM ps, <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG FAR *lpcbFormat) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br>LONGlSize; <br> <br>PalMapStreamRead(ps, lPos, 1, NULL, 0, NULL, NULL); <br> <br>if (pavi-&gt;lpdibLast == 0) <br>return ResultFromScode(AVIERR_INTERNAL); <br>lSize = pavi-&gt;lpdibLast-&gt;biSize <br>+ pavi-&gt;lpdibLast-&gt;biClrUsed * sizeof(RGBQUAD); <br> <br>if (lpFormat) <br>hmemcpy(lpFormat, pavi-&gt;lpdibLast, <br>min(*lpcbFormat, lSize)); <br> <br>*lpcbFormat = lSize; <br> <br>return 0; <br>} <br> <br>LONG STDMETHODCALLTYPE PalMapStreamFindKeyFrame( <br>PAVISTREAM ps, <br>LONG lPos, <br>LONG lFlags) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br> <br>return lPos; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamInfo( <br>PAVISTREAM ps, <br>AVISTREAMINFOW FAR * psi,        // OLE interfaces are ALWAYS UNICODE <br>LONG lSize) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br> <br>if (psi) <br>hmemcpy(psi, &amp;pavi-&gt;sinfo, min(lSize, sizeof(pavi-&gt;sinfo))); <br> <br>return 0; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamRead( <br>PAVISTREAMps, <br>LONGlStart, <br>LONGlSamples, <br>LPVOIDlpBuffer, <br>LONGcbBuffer, <br>LONG FAR *plBytes, <br>LONG FAR *plSamples) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br> <br>LPBITMAPINFOHEADERlpbi; <br>LPVOIDlp; <br> <br>if (lStart != pavi-&gt;lLastFrame) { <br>pavi-&gt;lLastFrame = -1; <br>lpbi = AVIStreamGetFrame(pavi-&gt;pgf, lStart); <br> <br>if (!lpbi) <br>goto ReadNothing; <br> <br>if (pavi-&gt;lpdibLast) { <br>GlobalFreePtr(pavi-&gt;lpdibLast); <br>pavi-&gt;lpdibLast = 0; <br>} <br> <br>pavi-&gt;lpdibLast = DibReduce(lpbi, NULL, pavi-&gt;hpal, pavi-&gt;lp16to8); <br>pavi-&gt;lLastFrame = lStart; <br>} <br> <br>lpbi = pavi-&gt;lpdibLast; <br>// <br>// a NULL buffer means return the size buffer needed to read <br>// the given sample. <br>// <br>lp = (LPBYTE) lpbi + lpbi-&gt;biSize + lpbi-&gt;biClrUsed * sizeof(RGBQUAD); <br> <br>if (plBytes) <br>*plBytes = lpbi-&gt;biSizeImage; <br> <br>if (plSamples) <br>*plSamples = 1; <br> <br>if (lpBuffer) { <br>if (cbBuffer &gt;= (LONG) lpbi-&gt;biSizeImage) <br>hmemcpy(lpBuffer, lp, lpbi-&gt;biSizeImage); <br>else <br>goto ReadNothing; <br>} <br> <br>return 0; <br> <br>ReadNothing: <br>if (plBytes) <br>*plBytes = 0; <br> <br>if (plSamples) <br>*plSamples = 0; <br> <br>return ResultFromScode(AVIERR_BUFFERTOOSMALL); <br>} <br> <br> <br> <br>// <br>// <br>// Extra unimplemented functions..... <br>// <br>// <br>// <br>HRESULT STDMETHODCALLTYPE PalMapStreamReadData( <br>PAVISTREAM ps, <br>DWORD fcc, <br>LPVOID lp, <br>LONG FAR *lpcb) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamSetFormat( <br>PAVISTREAM ps, <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG cbFormat) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamWriteData( <br>PAVISTREAM ps, <br>DWORD fcc, <br>LPVOID lp, <br>LONG cb) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamWrite( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples, <br>LPVOID lpBuffer, <br>LONG cbBuffer, <br>DWORD dwFlags, <br>LONG FAR *plSampWritten, <br>LONG FAR *plBytesWritten) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamDelete( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples) <br>{ <br>PPALMAPSTREAM pavi = (PPALMAPSTREAM) ps; <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE PalMapStreamSetInfo( <br>   PAVISTREAM ps, <br>   AVISTREAMINFOW FAR * psi, <br>   LONG lSize) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>EXTERN_C int CALLBACK WEP( <br>BOOL fSystemExit) <br>{ <br>return TRUE; <br>} <br> <br> <br>EXTERN_C BOOL APIENTRY DllMain(HANDLE, DWORD, LPVOID); <br>EXTERN_C BOOL APIENTRY DllMain( <br>HANDLE hModule, <br>DWORD dwReason, <br>LPVOID lpReserved ) <br>{ <br>switch( dwReason) <br>{ <br>case DLL_PROCESS_ATTACH: <br>if(ghMod == NULL) <br>ghMod = (HMODULE)hModule; <br>break; <br>case DLL_THREAD_ATTACH: <br>break; <br>case DLL_THREAD_DETACH: <br>break; <br>case DLL_PROCESS_DETACH: <br>break; <br>} <br>return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
