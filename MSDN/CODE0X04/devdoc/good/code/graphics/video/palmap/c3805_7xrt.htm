<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIBMAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3809"></a>DIBMAP.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include "dibmap.h" <br> <br>extern NEAR PASCAL MemCopy(LPVOID,LPVOID,DWORD); <br>extern NEAR PASCAL MemFill(LPVOID,DWORD,BYTE); <br> <br>void Histogram24(BYTE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram); <br>void Histogram16(BYTE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram); <br>void Histogram8(BYTE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors); <br>void Histogram4(BYTE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors); <br>void Histogram1(BYTE *pb, int dx, int dy, WORD WidthBytes, LPHISTOGRAM lpHistogram, LPWORD lpColors); <br> <br>void Reduce24(BYTE *pbIn, int dx, int dy, WORD cbIn, BYTE *pbOut, WORD cbOut, LPBYTE lp16to8); <br>void Reduce16(BYTE *pbIn, int dx, int dy, WORD cbIn, BYTE *pbOut, WORD cbOut, LPBYTE lp16to8); <br>void Reduce8(BYTE *pbIn, int dx, int dy, WORD cbIn, BYTE *pbOut, WORD cbOut, LPBYTE lp8to8); <br>void Reduce4(BYTE *pbIn, int dx, int dy, WORD cbIn, BYTE *pbOut, WORD cbOut, LPBYTE lp8to8); <br>void Reduce1(BYTE *pbIn, int dx, int dy, WORD cbIn, BYTE *pbOut, WORD cbOut, LPBYTE lp8to8); <br> <br>LPHISTOGRAM lpHistogram; <br> <br>// <br>// InitHistogram <br>// <br>// create a zero'ed histogram table, or initialize a existing table <br>// to all zeros. <br>// <br>LPHISTOGRAM InitHistogram( <br>LPHISTOGRAM lpHistogram) <br>{ <br>if (lpHistogram == NULL) <br>lpHistogram = (LPVOID)GlobalAllocPtr(GHND, 32768L * sizeof(DWORD)); <br> <br>return lpHistogram; <br>} <br> <br>// <br>// FreeHistogram <br>// <br>// free a histogram table <br>// <br>void FreeHistogram( <br>LPHISTOGRAM lpHistogram) <br>{ <br>GlobalFreePtr(lpHistogram); <br>} <br> <br>// <br>// DibHistogram <br>// <br>// take all colors in a dib and increment its entry in the Histogram table <br>// <br>// supports the following DIB formats: 1,4,8,16,24 <br>// <br>BOOL DibHistogram( <br>LPBITMAPINFOHEADER lpbi, <br>LPBYTE lpBits, <br>int x, <br>int y, <br>int dx, <br>int dy, <br>LPHISTOGRAM lpHistogram) <br>{ <br>inti; <br>WORDWidthBytes; <br>RGBQUAD FAR *prgbq; <br>WORDargb16[256]; <br> <br>if (lpbi == NULL || lpHistogram == NULL) <br>return FALSE; <br> <br>if (lpbi-&gt;biClrUsed == 0 &amp;&amp; lpbi-&gt;biBitCount &lt;= 8) <br>lpbi-&gt;biClrUsed = (1 &lt;&lt; (int)lpbi-&gt;biBitCount); <br> <br>if (lpBits == NULL) <br>lpBits = (LPBYTE)lpbi + (int)lpbi-&gt;biSize <br>+ (int)lpbi-&gt;biClrUsed*sizeof(RGBQUAD); <br> <br>WidthBytes = (WORD)(((LONG)lpbi-&gt;biBitCount * lpbi-&gt;biWidth + 7) / 8 + 3) &amp; ~3; <br> <br>((BYTE *)lpBits) += (DWORD)y*WidthBytes + ((x*(int)lpbi-&gt;biBitCount)/8); <br> <br>if (dx &lt; 0 || dx &gt; (int)lpbi-&gt;biWidth) <br>dx = (int)lpbi-&gt;biWidth; <br> <br>if (dy &lt; 0 || dy &gt; (int)lpbi-&gt;biHeight) <br>dy = (int)lpbi-&gt;biHeight; <br> <br>if ((int)lpbi-&gt;biBitCount &lt;= 8) <br>{ <br>prgbq = (LPVOID)((LPBYTE)lpbi + lpbi-&gt;biSize); <br> <br>for (i=0; i&lt;(int)lpbi-&gt;biClrUsed; i++) <br>{ <br>argb16[i] = (WORD) RGB16(prgbq[i].rgbRed,prgbq[i].rgbGreen,prgbq[i].rgbBlue); <br>} <br> <br>for (i=(int)lpbi-&gt;biClrUsed; i&lt;256; i++) <br>{ <br>argb16[i] = 0x0000;// just in case! <br>} <br>} <br> <br>switch ((int)lpbi-&gt;biBitCount) <br>{ <br>case 24: <br>Histogram24(lpBits, dx, dy, WidthBytes, lpHistogram); <br>break; <br> <br>case 16: <br>Histogram16(lpBits, dx, dy, WidthBytes, lpHistogram); <br>break; <br> <br>case 8: <br>Histogram8(lpBits, dx, dy, WidthBytes, lpHistogram, argb16); <br>break; <br> <br>case 4: <br>Histogram4(lpBits, dx, dy, WidthBytes, lpHistogram, argb16); <br>break; <br> <br>case 1: <br>Histogram1(lpBits, dx, dy, WidthBytes, lpHistogram, argb16); <br>break; <br>} <br>} <br> <br>// <br>// will convert the given DIB to a 8bit DIB with the specifed palette <br>// <br>LPBITMAPINFOHEADER DibReduce( <br>LPBITMAPINFOHEADER lpbiIn, <br>LPBYTE pbIn, <br>HPALETTE hpal, <br>LPBYTE lp16to8) <br>{ <br>LPBITMAPINFOHEADERlpdib; <br>WORDnPalColors;  // NOTE win32 GetObject ONLY returns <br>                                             // 2 bytes for HPALs <br>intnDibColors; <br>WORDcbOut; <br>WORDcbIn; <br>BYTExlat[256]; <br>BYTE *pbOut; <br>RGBQUAD FAR *prgb; <br>DWORDdwSize; <br>inti; <br>intdx; <br>intdy; <br>PALETTEENTRYpe; <br> <br>dx= (int)lpbiIn-&gt;biWidth; <br>dy= (int)lpbiIn-&gt;biHeight; <br>cbIn= (WORD)((((UINT)lpbiIn-&gt;biBitCount*dx+7)/8+3)&amp;~3); <br>cbOut= (WORD)((dx+3)&amp;~3); <br> <br>GetObject(hpal, sizeof(WORD), (LPVOID)&amp;nPalColors); <br>nDibColors = (int)lpbiIn-&gt;biClrUsed; <br> <br>if (nDibColors == 0 &amp;&amp; lpbiIn-&gt;biBitCount &lt;= 8) <br>nDibColors = (1 &lt;&lt; (int)lpbiIn-&gt;biBitCount); <br> <br>if (pbIn == NULL) <br>pbIn = (LPBYTE)lpbiIn + (int)lpbiIn-&gt;biSize + nDibColors*sizeof(RGBQUAD); <br> <br>dwSize = (DWORD)cbOut * dy; <br> <br>lpdib = GlobalAllocPtr(GMEM_MOVEABLE,sizeof(BITMAPINFOHEADER) <br>+ nPalColors*sizeof(RGBQUAD) + dwSize); <br> <br>if (!lpdib) <br>return NULL; <br> <br>lpdib-&gt;biSize= sizeof(BITMAPINFOHEADER); <br>lpdib-&gt;biWidth= lpbiIn-&gt;biWidth; <br>lpdib-&gt;biHeight= lpbiIn-&gt;biHeight; <br>lpdib-&gt;biPlanes= 1; <br>lpdib-&gt;biBitCount= 8; <br>lpdib-&gt;biCompression= BI_RGB; <br>lpdib-&gt;biSizeImage= dwSize; <br>lpdib-&gt;biXPelsPerMeter= 0; <br>lpdib-&gt;biYPelsPerMeter= 0; <br>lpdib-&gt;biClrUsed= (DWORD)nPalColors; <br>lpdib-&gt;biClrImportant= 0; <br> <br>pbOut= (LPBYTE)lpdib + (int)lpdib-&gt;biSize + nPalColors*sizeof(RGBQUAD); <br>prgb= (LPVOID)((LPBYTE)lpdib + (int)lpdib-&gt;biSize); <br> <br>for (i=0; i&lt;(int)nPalColors; i++) <br>{ <br>GetPaletteEntries(hpal, i, 1, &amp;pe); <br> <br>prgb[i].rgbRed= pe.peRed; <br>prgb[i].rgbGreen= pe.peGreen; <br>prgb[i].rgbBlue= pe.peBlue; <br>prgb[i].rgbReserved= 0; <br>} <br> <br>if ((int)lpbiIn-&gt;biBitCount &lt;= 8) <br>{ <br>prgb = (LPVOID)((LPBYTE)lpbiIn + lpbiIn-&gt;biSize); <br> <br>for (i=0; i&lt;nDibColors; i++) <br>xlat[i] = lp16to8[RGB16(prgb[i].rgbRed,prgb[i].rgbGreen,prgb[i].rgbBlue)]; <br> <br>for (; i&lt;256; i++) <br>xlat[i] = 0; <br>} <br> <br>switch ((int)lpbiIn-&gt;biBitCount) <br>{ <br>case 24: <br>Reduce24(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8); <br>break; <br> <br>case 16: <br>Reduce16(pbIn, dx, dy, cbIn, pbOut, cbOut, lp16to8); <br>break; <br> <br>case 8: <br>Reduce8(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat); <br>break; <br> <br>case 4: <br>Reduce4(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat); <br>break; <br> <br>case 1: <br>Reduce1(pbIn, dx, dy, cbIn, pbOut, cbOut, xlat); <br>break; <br>} <br> <br>return lpdib; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// cluster.c <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>#define IN_DEPTH5// # bits/component kept from input <br>#define IN_SIZE(1 &lt;&lt; IN_DEPTH)// max value of a color component <br> <br>typedef enum { red, green, blue } color; <br> <br>typedef struct tagCut <br>{ <br>long lvariance;// for int version <br>int cutpoint; <br>unsigned long rem;// for experimental fixed point <br>color cutaxis; <br>long w1, w2; <br>double variance; <br>} Cut; <br> <br>typedef struct tagColorBox// from cluster.c <br>{ <br>struct tagColorBox *next;/* pointer to next box */ <br>int rmin, rmax, gmin, gmax, bmin, bmax;/* bounding box */ <br>long variance, wt;/* weighted variance */ <br>long sum[3];/* sum of values */ <br>} ColorBox; <br> <br>static int InitBoxes(int nBoxes); <br>static void DeleteBoxes(void); <br>static int SplitBoxAxis(ColorBox *box, Cut cutaxis); <br>static void ShrinkBox(ColorBox *box); <br>static int ComputePalette(LPHISTOGRAM lpHistogram, LPBYTE lp16to8, LPPALETTEENTRY palette); <br>static COLORREF DetermineRepresentative(ColorBox *box, int palIndex); <br>static Cut FindSplitAxis(ColorBox *box); <br>static void SplitBox(ColorBox *box); <br>static void SortBoxes(void); <br> <br>HANDLE hBoxes; <br>ColorBox*UsedBoxes; <br>ColorBox*FreeBoxes; <br>LPBYTEglp16to8; <br> <br>//#define hist(r,g,b) ((DWORD *)glpHistogram)[(WORD)(b) | ((WORD)(g)&lt;&lt;IN_DEPTH) | ((WORD)(r)&lt;&lt;(IN_DEPTH*2))] <br>#define hist(r,g,b) GetHistogram((BYTE)(r),(BYTE)(g),(BYTE)(b)) <br> <br>#pragma optimize ("", off) <br>// <br>// set FS == lpHistogram.sel, so we can get at it quickly! <br>// <br>void NEAR PASCAL UseHistogram( <br>LPHISTOGRAM lpHistogramToSet) <br>{ <br>        lpHistogram = lpHistogramToSet; <br>} <br> <br>// <br>// get the DOWRD histogram count of a RGB <br>// <br>DWORD near _fastcall GetHistogram( <br>BYTE r, <br>BYTE g, <br>BYTE b) <br>{ <br>        return lpHistogram[((UINT)r &lt;&lt; 10 ) + ((UINT)g &lt;&lt; 5) + (UINT)b]; <br>} <br> <br>// <br>// increment the histogram count of a RGB16 <br>// <br>// <br>// #define IncHistogram(w) if (lpHistogram[(WORD)(w)] &lt; 0xFFFFFFFF) <br>//lpHistogram[(WORD)(w)]++; <br>// <br>void near _fastcall IncHistogram(WORD rgb16) <br>{ <br>    if (lpHistogram[rgb16] != (DWORD)-1) <br>        lpHistogram[rgb16]++; <br>} <br> <br>#pragma optimize ("", on) <br> <br>// !!! C8 generates a Jump into the middle of a 2 byte instruction <br>// !!! Stupid C8! <br>#pragma optimize ("", off) <br> <br>// <br>// HistogramPalette <br>// <br>// given a histogram, will reduce it to 'nColors' number of colors. <br>// returns a optimal palette.  if specifed lp16to8 will contain the <br>// translate table from RGB16 to the palette index. <br>// <br>// you can specify lpHistogram as lp16to8 <br>// <br>HPALETTE HistogramPalette( <br>LPHISTOGRAM lpHistogram, <br>LPBYTE lp16to8, <br>int nColors) <br>{ <br>struct { <br>WORDpalVersion; <br>WORDpalNumEntries; <br>PALETTEENTRY palPalEntry[256]; <br>} pal; <br> <br>WORDw; <br>DWORDdwMax; <br>COLORREFrgb; <br>ColorBox*box; <br>inti; <br> <br>// <br>// the 'C' code cant handle &gt;64k histogram counts. <br>// !!!fix this <br>// <br>for (dwMax=0,w=0; w&lt;0x8000; w++) <br>dwMax = max(dwMax,lpHistogram[w]); <br> <br>while (dwMax &gt; 0xFFFFl) <br>{ <br>for (w=0; w&lt;0x8000; w++) <br>lpHistogram[w] /= 2; <br> <br>dwMax /= 2; <br>} <br> <br>if (!InitBoxes(min(nColors, 236))) <br>return NULL; <br> <br>UseHistogram(lpHistogram); <br>glp16to8 = lp16to8; <br> <br>/* while there are free boxes left, split the largest */ <br> <br>i = 0; <br> <br>do { <br>i++; <br>SplitBox(UsedBoxes); <br>} <br>while (FreeBoxes &amp;&amp; UsedBoxes-&gt;variance); <br> <br>SortBoxes(); <br> <br>i=0; <br> <br>// <br>// add some standard colors to the histogram <br>// <br>if (nColors &gt; 236) <br>{ <br>HDC hdc; <br> <br>hdc = GetDC(NULL); <br> <br>if (GetDeviceCaps(hdc, RASTERCAPS) &amp; RC_PALETTE) <br>{ <br>GetSystemPaletteEntries(hdc, 0, <br>10, &amp;pal.palPalEntry[0]); <br>GetSystemPaletteEntries(hdc, 246, <br>10, &amp;pal.palPalEntry[246]); <br> <br>i = 10; <br>} <br> <br>ReleaseDC(NULL, hdc); <br>} <br> <br>/* Generate the representitives and the associated Palette mapping */ <br>/* NOTE:  Might loop less than nColors times.                      */ <br>for (box = UsedBoxes; box; box = box-&gt;next, i++) <br>{ <br>rgb = DetermineRepresentative(box, i); <br>pal.palPalEntry[i].peRed= GetRValue(rgb); <br>pal.palPalEntry[i].peGreen= GetGValue(rgb); <br>pal.palPalEntry[i].peBlue= GetBValue(rgb); <br>pal.palPalEntry[i].peFlags= 0; <br>} <br> <br>DeleteBoxes(); <br> <br>if (nColors &gt; 236) <br>{ <br>for (; i&lt;246; i++) <br>{ <br>pal.palPalEntry[i].peRed= 0; <br>pal.palPalEntry[i].peGreen= 0; <br>pal.palPalEntry[i].peBlue= 0; <br>pal.palPalEntry[i].peFlags= 0; <br>} <br> <br>i = 256; <br>} <br> <br>glp16to8 = NULL; <br> <br>pal.palVersion= 0x300; <br>pal.palNumEntries= (WORD)i; <br>return CreatePalette((LPLOGPALETTE)&amp;pal); <br>} <br> <br>#pragma optimize ("", on) <br> <br>static void SortBoxes(void) <br>{ <br>ColorBox *box; <br>ColorBox *newList; <br>ColorBox *insBox; <br>ColorBox *nextBox; <br> <br>newList = UsedBoxes; <br>nextBox = newList-&gt;next; <br>newList-&gt;next = NULL; <br> <br>for (box = nextBox; box; box = nextBox) { // just an insertion sort... <br>nextBox = box-&gt;next; <br>if (box-&gt;wt &gt; newList-&gt;wt) { <br>box-&gt;next = newList; <br>newList = box; <br>} else { <br>for (insBox = newList; <br>insBox-&gt;next &amp;&amp; (box-&gt;wt &lt; insBox-&gt;next-&gt;wt); <br>insBox = insBox-&gt;next) ; <br>box-&gt;next = insBox-&gt;next; <br>insBox-&gt;next = box; <br>} <br>} <br> <br>UsedBoxes = newList; <br>} <br> <br> <br>/* <br>allocate space for nBoxes boxes, set up links.  On exit UsedBoxes <br>points to one box, FreeBoxes points to remaining (nBoxes-1) boxes. <br>return 0 if successful. <br>*/ <br> <br>static BOOL InitBoxes( <br>int nBoxes) <br>{ <br>int i; <br> <br>hBoxes = LocalAlloc(LHND, nBoxes*sizeof(ColorBox)); <br>if (!hBoxes) <br>return FALSE; <br> <br>UsedBoxes = (ColorBox*)LocalLock(hBoxes); <br>FreeBoxes = UsedBoxes + 1; <br>UsedBoxes-&gt;next = NULL; <br> <br>for (i = 0; i &lt; nBoxes - 1; ++i) <br>{ <br>FreeBoxes[i].next = FreeBoxes + i + 1; <br>} <br>FreeBoxes[nBoxes-2].next = NULL; <br> <br>/* save the bounding box */ <br>UsedBoxes-&gt;rmin = UsedBoxes-&gt;gmin = UsedBoxes-&gt;bmin = 0; <br>UsedBoxes-&gt;rmax = UsedBoxes-&gt;gmax = UsedBoxes-&gt;bmax = IN_SIZE - 1; <br>UsedBoxes-&gt;variance = 9999999;/* arbitrary large # */ <br> <br>return TRUE; <br>} <br> <br>static void DeleteBoxes(void) <br>{ <br>LocalUnlock(hBoxes); <br>LocalFree(hBoxes); <br>hBoxes = NULL; <br>} <br> <br>static void SplitBox( <br>ColorBox *box) <br>{ <br>/* <br>split box into two roughly equal halves and update the data structures <br>appropriately. <br>*/ <br>Cut cutaxis; <br>ColorBox *temp, *temp2, *prev; <br> <br>cutaxis = FindSplitAxis(box); <br> <br>/* split the box along that axis.  If rc != 0 then the box contains <br>one color, and should not be split <br>*/ <br>if (SplitBoxAxis(box, cutaxis)) <br>return; <br> <br>/* shrink each of the boxes to fit the points they enclose */ <br>ShrinkBox(box); <br>ShrinkBox(FreeBoxes); <br> <br>/* move old box down in list, if necessary */ <br>if (box-&gt;next &amp;&amp; box-&gt;variance &lt; box-&gt;next-&gt;variance) <br>{ <br>UsedBoxes = box-&gt;next; <br>temp = box; <br>do { <br>prev = temp; <br>temp = temp-&gt;next; <br>} while (temp &amp;&amp; temp-&gt;variance &gt; box-&gt;variance); <br>box-&gt;next = temp; <br>prev-&gt;next = box; <br>} <br> <br>/* insert the new box in sorted order (descending), removing it <br>from the free list. <br>*/ <br>if (FreeBoxes-&gt;variance &gt;= UsedBoxes-&gt;variance) <br>{ <br>temp = FreeBoxes; <br>FreeBoxes = FreeBoxes-&gt;next; <br>temp-&gt;next = UsedBoxes; <br>UsedBoxes = temp; <br>} <br>else <br>{ <br>temp = UsedBoxes; <br>do { <br>prev = temp; <br>temp = temp-&gt;next; <br>} while (temp &amp;&amp; temp-&gt;variance &gt; FreeBoxes-&gt;variance); <br>temp2 = FreeBoxes-&gt;next; <br>FreeBoxes-&gt;next = temp; <br>prev-&gt;next = FreeBoxes; <br>FreeBoxes = temp2; <br>} <br>} <br> <br>static Cut FindSplitAxis( <br>ColorBox *box) <br>{ <br>unsigned longproj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE]; <br>unsigned longf; <br>doublecurrentMax,mean; <br>unsigned longw,w1,m,m1; <br>intr,g,b; <br>intbestCut; <br>colorbestAxis; <br>CutcutRet; <br>doubletemp1,temp2; <br> <br>for (r = 0; r &lt; IN_SIZE; r++) { <br>proj_r[r] = proj_g[r] = proj_b[r] = 0; <br>} <br> <br>w = 0; <br> <br>// Project contents of box down onto axes <br>for (r = box-&gt;rmin; r &lt;= box-&gt;rmax; r++) { <br>for (g = box-&gt;gmin; g &lt;= box-&gt;gmax; ++g) { <br>for (b = box-&gt;bmin; b &lt;= box-&gt;bmax; ++b) { <br>f = hist(r,g,b); <br>proj_r[r] += f; <br>proj_g[g] += f; <br>proj_b[b] += f; <br>} <br>} <br>w += proj_r[r]; <br>} <br> <br>currentMax = 0.0f; <br> <br>#define Check_Axis(l,color)\ <br>m = 0;\ <br>for (l = box-&gt;l##min; l &lt;= box-&gt;l##max; (l)++) {\ <br>m += l * proj_##l[l];\ <br>}\ <br>mean = ((double) m) / ((double) w);\ <br>\ <br>w1 = 0;\ <br>m1 = 0;\ <br>for (l = box-&gt;l##min; l &lt;= box-&gt;l##max; l++) {\ <br>w1 += proj_##l[l];\ <br>if (w1 == 0)\ <br>continue;\ <br>if (w1 == w)\ <br>break;\ <br>m1 += l * proj_##l[l];\ <br>temp1 = mean - (((double) m1) / ((double) w1));\ <br>temp2 = (((double) w1) / ((double) (w-w1))) * temp1 * temp1; \ <br>if (temp2 &gt; currentMax) {\ <br>bestCut = l;\ <br>bestAxis = color;\ <br>currentMax = temp2;\ <br>}\ <br>} <br> <br>Check_Axis(r,red); <br>Check_Axis(g,green); <br>Check_Axis(b,blue); <br> <br>cutRet.cutaxis = bestAxis; <br>cutRet.cutpoint = bestCut; <br> <br>return cutRet; <br>} <br> <br>static int SplitBoxAxis( <br>ColorBox *box, <br>Cut cutaxis) <br>{ <br>/* <br>Split box along splitaxis into two boxes, one of which is placed <br>back in box, the other going in the first free box (FreeBoxes) <br>If the box only contains one color, return non-zero, else return 0. <br>*/ <br>ColorBox *next; <br> <br>if ( box-&gt;variance == 0) <br>return 1; <br> <br>/* copy all non-link information to new box */ <br>next = FreeBoxes-&gt;next; <br>*FreeBoxes = *box; <br>FreeBoxes-&gt;next = next; <br> <br>switch (cutaxis.cutaxis) <br>{ <br>case red: <br>box-&gt;rmax = cutaxis.cutpoint; <br>FreeBoxes-&gt;rmin = cutaxis.cutpoint+1; <br>break; <br>case green: <br>box-&gt;gmax = cutaxis.cutpoint; <br>FreeBoxes-&gt;gmin = cutaxis.cutpoint+1; <br>break; <br>case blue: <br>box-&gt;bmax = cutaxis.cutpoint; <br>FreeBoxes-&gt;bmin = cutaxis.cutpoint+1; <br>break; <br>} <br> <br>return 0; <br>} <br> <br>static void ShrinkBox( <br>ColorBox *box) <br>{ <br>unsigned long n, sxx, sx2, var, quotient, remainder; <br>int r,g,b; <br>unsigned long f; <br>unsigned longproj_r[IN_SIZE],proj_g[IN_SIZE],proj_b[IN_SIZE]; <br> <br>n = 0; <br> <br>for (r = 0; r &lt; IN_SIZE; r++) { <br>proj_r[r] = proj_g[r] = proj_b[r] = 0; <br>} <br> <br>// Project contents of box down onto axes <br>for (r = box-&gt;rmin; r &lt;= box-&gt;rmax; r++) { <br>for (g = box-&gt;gmin; g &lt;= box-&gt;gmax; ++g) { <br>for (b = box-&gt;bmin; b &lt;= box-&gt;bmax; ++b) { <br>f = hist(r,g,b); <br>proj_r[r] += f; <br>proj_g[g] += f; <br>proj_b[b] += f; <br>} <br>} <br>n += proj_r[r]; <br>} <br> <br>box-&gt;wt = n; <br>var = 0; <br> <br>#define AddAxisVariance(c)\ <br>sxx = 0; sx2 = 0;\ <br>for (c = box-&gt;c##min; c &lt;= box-&gt;c##max; c++) {\ <br>sxx += proj_##c[c] * c * c;\ <br>sx2 += proj_##c[c] * c;\ <br>}\ <br>quotient = sx2 / n; /* This stuff avoids overflow */\ <br>remainder = sx2 % n;\ <br>var += sxx - quotient * sx2 - ((remainder * sx2)/n); <br> <br>AddAxisVariance(r); <br>AddAxisVariance(g); <br>AddAxisVariance(b); <br> <br>box-&gt;variance = var; <br>} <br> <br>static COLORREF DetermineRepresentative( <br>ColorBox *box, <br>int palIndex) <br>{ <br>/* <br>determines the rgb value to represent the pixels contained in <br>box.  nbits is the # bits/component we're allowed to return. <br>*/ <br> <br>long f; <br>long Rval, Gval, Bval; <br>unsigned long total; <br>int r, g, b; <br>int i; <br> <br>/* compute the weighted sum of the elements in the box */ <br>Rval = Gval = Bval = total = 0; <br>for (r = box-&gt;rmin; r &lt;= box-&gt;rmax; ++r) <br>{ <br>for (g = box-&gt;gmin; g &lt;= box-&gt;gmax; ++g) <br>{ <br>for (b = box-&gt;bmin; b &lt;= box-&gt;bmax; ++b) <br>{ <br>if (glp16to8) <br>{ <br>i = (b) | (g &lt;&lt; IN_DEPTH) <br>| (r &lt;&lt; (IN_DEPTH*2)); <br>glp16to8[i] = (BYTE)palIndex; <br>} <br> <br>f = hist(r,g,b); <br>if (f == 0L) <br>continue; <br> <br>Rval += f * (long) r; <br>Gval += f * (long) g; <br>Bval += f * (long) b; <br> <br>total += f; <br>} <br>} <br>} <br> <br>/* Bias the sum so that we round up at .5 */ <br>Rval += total / 2; <br>Gval += total / 2; <br>Bval += total / 2; <br> <br>return RGB(Rval*255/total/IN_SIZE, Gval*255/total/IN_SIZE, Bval*255/total/IN_SIZE); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  write this stuff in ASM! <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>void Histogram24( <br>BYTE *pb, <br>int dx, <br>int dy, <br>WORD WidthBytes, <br>LPHISTOGRAM lpHistogram) <br>{ <br>int x,y; <br>BYTE r,g,b; <br>WORD w; <br> <br>UseHistogram(lpHistogram); <br> <br>WidthBytes -= (WORD) (dx*3); <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>b = *pb++; <br>g = *pb++; <br>r = *pb++; <br>w = (WORD) RGB16(r,g,b); <br>IncHistogram(w); <br>} <br>pb += WidthBytes; <br>} <br>} <br> <br>void Histogram16( <br>BYTE *pb, <br>int dx, <br>int dy, <br>WORD WidthBytes, <br>LPHISTOGRAM lpHistogram) <br>{ <br>int x,y; <br>WORD w; <br> <br>UseHistogram(lpHistogram); <br> <br>WidthBytes -= (WORD)(dx*2); <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>w = *((WORD *)pb)++; <br>w &amp;= 0x7FFF; <br>IncHistogram(w); <br>} <br>pb += WidthBytes; <br>} <br>} <br> <br>void Histogram8( <br>BYTE *pb, <br>int dx, <br>int dy, <br>WORD WidthBytes, <br>LPHISTOGRAM lpHistogram, <br>LPWORD lpColors) <br>{ <br>int x,y; <br>WORD w; <br> <br>UseHistogram(lpHistogram); <br> <br>WidthBytes -= (WORD)dx; <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>w = lpColors[*pb++]; <br>IncHistogram(w); <br>} <br>pb += WidthBytes; <br>} <br>} <br> <br>void Histogram4( <br>BYTE *pb, <br>int dx, <br>int dy, <br>WORD WidthBytes, <br>LPHISTOGRAM lpHistogram, <br>LPWORD lpColors) <br>{ <br>int x,y; <br>BYTE b; <br>WORD w; <br> <br>UseHistogram(lpHistogram); <br> <br>WidthBytes -= (WORD)((dx+1)/2); <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;(dx+1)/2; x++) <br>{ <br>b = *pb++; <br> <br>w = lpColors[b&gt;&gt;4]; <br>IncHistogram(w); <br> <br>w = lpColors[b&amp;0x0F]; <br>IncHistogram(w); <br>} <br>pb += WidthBytes; <br>} <br>} <br> <br>void Histogram1( <br>BYTE *pb, <br>int dx, <br>int dy, <br>WORD WidthBytes, <br>LPHISTOGRAM lpHistogram, <br>LPWORD lpColors) <br>{ <br>int x,y,i; <br>BYTE b; <br>WORD w; <br> <br>UseHistogram(lpHistogram); <br> <br>WidthBytes -= (WORD)((dx+7)/8); <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;(dx+7)/8; x++) <br>{ <br>b = *pb++; <br> <br>for (i=0; i&lt;8; i++) <br>{ <br>w = lpColors[b&gt;&gt;7]; <br>IncHistogram(w); <br>b&lt;&lt;=1; <br>} <br>} <br>pb += WidthBytes; <br>} <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  write this stuff in ASM! too <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>void Reduce24( <br>BYTE *pbIn, <br>int dx, <br>int dy, <br>WORD cbIn, <br>BYTE *pbOut, <br>WORD cbOut, <br>LPBYTE lp16to8) <br>{ <br>int x,y; <br>BYTE r,g,b; <br> <br>cbOut-= (WORD)dx; <br>cbIn-= (WORD)(dx*3); <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>b = *pbIn++; <br>g = *pbIn++; <br>r = *pbIn++; <br>*pbOut++ = lp16to8[RGB16(r,g,b)]; <br>} <br>pbIn += cbIn; <br>pbOut+= cbOut; <br>} <br>} <br> <br>void Reduce16( <br>BYTE *pbIn, <br>int dx, <br>int dy, <br>WORD cbIn, <br>BYTE *pbOut, <br>WORD cbOut, <br>LPBYTE lp16to8) <br>{ <br>int x,y; <br>WORD w; <br> <br>cbOut-= (WORD)dx; <br>cbIn-= (WORD)(dx*2); <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>w = *((WORD *)pbIn)++; <br>*pbOut++ = lp16to8[w&amp;0x7FFF]; <br>} <br>pbIn += cbIn; <br>pbOut+= cbOut; <br>} <br>} <br> <br>void Reduce8( <br>BYTE *pbIn, <br>int dx, <br>int dy, <br>WORD cbIn, <br>BYTE *pbOut, <br>WORD cbOut, <br>LPBYTE lp8to8) <br>{ <br>int x,y; <br> <br>cbIn-= (WORD)dx; <br>cbOut-= (WORD)dx; <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>*pbOut++ = lp8to8[*pbIn++]; <br>} <br>pbIn+= cbIn; <br>pbOut+= cbOut; <br>} <br>} <br> <br>void Reduce4( <br>BYTE *pbIn, <br>int dx, <br>int dy, <br>WORD cbIn, <br>BYTE *pbOut, <br>WORD cbOut, <br>LPBYTE lp8to8) <br>{ <br>int x,y; <br>BYTE b; <br> <br>cbIn-= (WORD)((dx+1)/2); <br>cbOut-= (WORD)((dx+1)&amp;~1); <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;(dx+1)/2; x++) <br>{ <br>b = *pbIn++; <br>*pbOut++ = lp8to8[b&gt;&gt;4]; <br>*pbOut++ = lp8to8[b&amp;0x0F]; <br>} <br>pbIn+= cbIn; <br>pbOut+= cbOut; <br>} <br>} <br> <br>void Reduce1( <br>BYTE *pbIn, <br>int dx, <br>int dy, <br>WORD cbIn, <br>BYTE *pbOut, <br>WORD cbOut, <br>LPBYTE lp8to8) <br>{ <br>int x,y; <br>BYTE b; <br> <br>cbIn-= (WORD)((dx+7)/8); <br>cbOut-= (WORD)dx; <br> <br>for (y=0; y&lt;dy; y++) <br>{ <br>for (x=0; x&lt;dx; x++) <br>{ <br>if (x%8 == 0) <br>b = *pbIn++; <br> <br>*pbOut++ = lp8to8[b&gt;&gt;7]; <br>b&lt;&lt;=1; <br>} <br>pbIn+= cbIn; <br>pbOut+= cbOut; <br>} <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
