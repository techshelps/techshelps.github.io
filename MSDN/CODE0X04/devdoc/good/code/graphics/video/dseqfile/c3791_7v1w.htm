<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSEQF.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3794"></a>DSEQF.CPP</h2>
<pre><code>/**************************************************************************** <br> * <br> *  DSEQF.CPP <br> * <br> *  routines for reading DIB sequences <br> * <br> ***************************************************************************/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "handler.h" <br>#include "handler.rc" <br> <br> <br>static DWORD NEAR PASCAL dseqParseFileName( <br>        LPSTR lpszFileName, <br>        LPSTR lpszTemplate, <br>        DWORD FAR * lpdwMaxValue); <br> <br>#ifdef DEBUG <br>        static void CDECL dprintf(LPSTR, ...); <br>        #define DPF dprintf <br>#else <br>        #define DPF ; / ## / <br>#endif <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>UINT    uUseCount; <br>BOOL    fLocked; <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// <br>// External function called by the Class Factory to create an instance of <br>// the DIB sequence reader/writer <br>// <br>HRESULT CAVIFile::Create( <br>IUnknown FAR*   pUnknownOuter, <br>const IID FAR&amp;  riid, <br>void FAR* FAR*  ppv) <br>{ <br>        IUnknown FAR*   pUnknown; <br>        CAVIFile FAR*   pAVIFile; <br>        HRESULT hresult; <br> <br>        pAVIFile = new FAR CAVIFile(pUnknownOuter, &amp;pUnknown); <br>        if (!pAVIFile) <br>                return ResultFromScode(E_OUTOFMEMORY); <br>        hresult = pUnknown-&gt;QueryInterface(riid, ppv); <br>        if (FAILED(GetScode(hresult))) <br>                delete pAVIFile; <br>        return hresult; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// <br>// Random C++ stuff: constructors &amp; such... <br>// <br>CAVIFile::CAVIFile( <br>IUnknown FAR*   pUnknownOuter, <br>IUnknown FAR* FAR*      ppUnknown) : <br>        m_Unknown(this), <br>        m_AVIFile(this), <br>        m_Persist(this), <br>#ifdef CUSTOMMARSHAL <br>        m_Marshal(this), <br>#endif <br>        m_AVIStream(this) <br>{ <br>        if (pUnknownOuter) <br>                m_pUnknownOuter = pUnknownOuter; <br>        else <br>                m_pUnknownOuter = &amp;m_Unknown; <br>        *ppUnknown = &amp;m_Unknown; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>CAVIFile::CUnknownImpl::CUnknownImpl( <br>CAVIFile FAR*   pAVIFile) <br>{ <br>        m_pAVIFile = pAVIFile; <br>        m_refs = 0; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// <br>// This QueryInterface function allows a caller to move between the various <br>// interfaces the object presents <br>// <br>STDMETHODIMP CAVIFile::CUnknownImpl::QueryInterface( <br>const IID FAR&amp;  iid, <br>void FAR* FAR*  ppv) <br>{ <br>        if (iid == IID_IUnknown) <br>                *ppv = &amp;m_pAVIFile-&gt;m_Unknown; <br>        else if (iid == IID_IAVIFile) <br>                *ppv = &amp;m_pAVIFile-&gt;m_AVIFile; <br>        else if (iid == IID_IAVIStream) <br>                *ppv = &amp;m_pAVIFile-&gt;m_AVIStream; <br>        else if (iid == IID_IPersistFile) <br>                *ppv = &amp;m_pAVIFile-&gt;m_Persist; <br>#ifdef CUSTOMMARSHAL <br>        else if (iid == IID_IMarshal) <br>                *ppv = &amp;m_pAVIFile-&gt;m_Marshal; <br>#endif <br>        else <br>                return ResultFromScode(E_NOINTERFACE); <br>        AddRef(); <br>        return NULL; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CUnknownImpl::AddRef() <br>{ <br>        uUseCount++; <br>        return ++m_refs; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// <br>// All calls to AddRef, Release, QueryInterface for the file or stream <br>// functions are redirected to the Unknown implementation... <br>// <br>CAVIFile::CAVIFileImpl::CAVIFileImpl( <br>CAVIFile FAR*   pAVIFile) <br>{ <br>        m_pAVIFile = pAVIFile; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>CAVIFile::CAVIFileImpl::~CAVIFileImpl() <br>{ <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP CAVIFile::CAVIFileImpl::QueryInterface( <br>const IID FAR&amp;  iid, <br>void FAR* FAR*  ppv) <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;QueryInterface(iid, ppv); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CAVIFileImpl::AddRef() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;AddRef(); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CAVIFileImpl::Release() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;Release(); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>CAVIFile::CAVIStreamImpl::CAVIStreamImpl( <br>CAVIFile FAR*   pAVIFile) <br>{ <br>        m_pAVIFile = pAVIFile; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>CAVIFile::CAVIStreamImpl::~CAVIStreamImpl() <br>{ <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::QueryInterface( <br>const IID FAR&amp;  iid, <br>void FAR* FAR*  ppv) <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;QueryInterface(iid, ppv); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CAVIStreamImpl::AddRef() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;AddRef(); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CAVIStreamImpl::Release() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;Release(); <br>} <br> <br> <br>// --- IPersistFile implementation -------------------------------------- <br> <br>CAVIFile::CPersistFileImpl::CPersistFileImpl(CAVIFile FAR* pAVIFile) <br>{ <br>    m_pAVIFile = pAVIFile; <br>} <br> <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::QueryInterface(REFIID riid, LPVOID FAR* ppv) <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;QueryInterface(riid, ppv); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CAVIFile::CPersistFileImpl::AddRef() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;AddRef(); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CAVIFile::CPersistFileImpl::Release() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;Release(); <br>} <br> <br>// *** IPersist methods *** <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::GetClassID (LPCLSID lpClassID) <br>{ <br>        *lpClassID = CLSID_DIBSEQFileReader; <br> <br>        return NOERROR; <br>} <br> <br>// *** IPersistFile methods *** <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::IsDirty () <br>{ <br>    if (m_pAVIFile-&gt;fDirty) { <br>        return NOERROR; <br>    } else { <br>        return ResultFromScode(S_FALSE); <br>    } <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// <br>// This function takes the name of the first file in a DIB sequence, and <br>// returns a printf() specifier which can be used to create the names in <br>// the sequence, along with minimum and maximum values that can be used. <br>// <br>// <br>// Examples: <br>//  lpszFileName = "FOO0047.DIB" <br>//       -&gt; lpszTemplate = "FOO%04d.DIB", dwMaxValue = 9999, return = 47 <br>// <br>//  lpszFileName = "TEST01.DIB" <br>//       -&gt; lpszTemplate = "TEST%01d.DIB", dwMaxValue = 9, return = 1 <br>// <br>//  lpszFileName = "TEST1.DIB" <br>//       -&gt; lpszTemplate = "TEST%d.DIB", dwMaxValue = 9999, return = 1 <br>// <br>//  lpszFileName = "SINGLE.DIB" <br>//       -&gt; lpszTemplate = "SINGLE.DIB", dwMaxValue = 0, return = 0 <br>// <br>static DWORD NEAR PASCAL dseqParseFileName( <br>LPSTR lpszFileName, <br>LPSTR lpszTemplate, <br>DWORD FAR * lpdwMaxValue) <br>{ <br>        char    achTemp[_MAX_PATH]; <br>        DWORD   dwFirst; <br>        WORD    wFieldWidth; <br>        DWORD   dwMult; <br>        BOOL    fLeadingZero = FALSE; <br> <br>        LPSTR   lp; <br>        LPSTR   lp2; <br>        LPSTR   lpExt; <br> <br>        /* Find end of string */ <br>        lp2 = lpszFileName; <br>        lp = achTemp; <br>        while (*lp2) <br>        *lp++ = *lp2++; <br> <br>        *lp = '\0'; <br> <br>        /* Make lp2 point at last character of base filename (w/o extension) */ <br>        /* Make lpExt point at the extension (without the dot) */ <br>        for (lp2 = lp; *lp2 != '.'; lp2--) <br>        { <br>                lpExt = lp2; <br>                if ((lp2 == achTemp) || (*lp2 == '\\') <br>                        || (*lp2 == ':') || (*lp2 == '!')) <br>                { <br>                        /* There is no extension */ <br>                        lp2 = lp; <br>                        lpExt = lp; <br>                        break; <br>                } <br>        } <br> <br>        lp2--; <br> <br>        // Count the number of numeric characters here.... <br>        dwFirst = 0; <br>        wFieldWidth = 0; <br>        dwMult = 1; <br>        while (lp2 &gt;= achTemp &amp;&amp; (*lp2 &gt;= '0') &amp;&amp; (*lp2 &lt;= '9')) { <br>        fLeadingZero = (*lp2 == '0'); <br>        dwFirst += dwMult * (*(lp2--) - '0'); <br>        dwMult *= 10; <br>        wFieldWidth++; <br>        } <br> <br>        *lpdwMaxValue = dwMult - 1; <br> <br>        lp2++; <br>        *lp2 = '\0'; <br> <br>        // Make the format specifier.... <br>        if (wFieldWidth) { <br>        if (fLeadingZero) { <br>                wsprintf((LPSTR) lpszTemplate,"%s%%0%ulu.%s", <br>                        (LPSTR) achTemp, wFieldWidth,(LPSTR) lpExt); <br>        } else { <br>                wsprintf((LPSTR) lpszTemplate,"%s%%lu.%s", <br>                        (LPSTR) achTemp, (LPSTR) lpExt); <br>                *lpdwMaxValue = 999999L; <br>                // !!! This should really be based on the number of <br>                // characters left after the base name.... <br>        } <br>        } else <br>        wsprintf((LPSTR) lpszTemplate,"%s.%s", <br>                        (LPSTR) achTemp, (LPSTR) lpExt); <br>        DPF("First = %lu, Width = %u, Template = '%s'\n",dwFirst, wFieldWidth, lpszTemplate); <br> <br>        return dwFirst; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>#define SLASH(c) ((c) == '/' || (c) == '\\') <br> <br>/*--------------------------------------------------------------+ <br>| FileName  - return a pointer to the filename part of szPath   | <br>|             with no preceding path.                           | <br>+--------------------------------------------------------------*/ <br>LPSTR FAR FileName( <br>LPCSTR lszPath) <br>{ <br>        LPCSTR  lszCur; <br> <br>        for (lszCur = lszPath + lstrlen(lszPath); lszCur &gt; lszPath &amp;&amp; !SLASH(*lszCur) &amp;&amp; *lszCur != ':';) <br>                lszCur = AnsiPrev(lszPath, lszCur); <br>        if (lszCur == lszPath) <br>                return (LPSTR)lszCur; <br>        else <br>                return (LPSTR)(lszCur + 1); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// <br>// "Open" a DIB sequence, by parsing the filename and counting the number <br>// of frames actually present.... <br>// <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::Load (LPCOLESTR szFile, DWORD mode) <br>{ <br>        CAVIFile FAR    *p = m_pAVIFile; <br>        UINT            ui; <br>        char            ach[80]; <br>        char            szFileA[MAX_PATH]; <br> <br>        p-&gt;mode = mode; <br> <br>        // <br>        // Parse the filename <br>        // <br>        wsprintf(szFileA, "%ls", szFile); <br>        p-&gt;dwFirstFrame = dseqParseFileName(szFileA, <br>                                p-&gt;achFilenameTemplate, <br>                                &amp;p-&gt;dwMaxValue); <br> <br>        // <br>        // Initialize the variables that keep track of what frame is cached <br>        // <br>        p-&gt;lCurFrame = -1; <br>        p-&gt;lpFrame = NULL; <br>        p-&gt;cbFrame = 0; <br>        p-&gt;cbFrameBuffer = 0; <br>        p-&gt;lpFormat = NULL; <br>        p-&gt;cbFormat = 0; <br>        p-&gt;cbFormatBuffer = 0; <br> <br>        // <br>        // Build a stream header.... <br>        // <br>        p-&gt;sinfo.fccType = streamtypeVIDEO; <br>        p-&gt;sinfo.fccHandler = 0; <br>        p-&gt;sinfo.dwFlags = 0; <br>        p-&gt;sinfo.wPriority = 0; <br>        p-&gt;sinfo.wLanguage = 0; <br>        p-&gt;sinfo.dwInitialFrames = 0; <br>        p-&gt;sinfo.dwScale = 1; <br>        p-&gt;sinfo.dwRate = 15; <br>        p-&gt;sinfo.dwStart = 0; <br>        p-&gt;sinfo.dwLength = 0; <br>        p-&gt;sinfo.dwSuggestedBufferSize = 0; <br>        p-&gt;sinfo.dwSampleSize = 0; <br> <br>        LoadString(ghModule, IDS_STREAMNAME, ach, sizeof(ach)); <br>        { <br>            char TempFileName[80]; <br>            char TempName[80]; <br>            wsprintf(TempFileName, "%ls", szFile); <br>            wsprintf(TempName, ach, FileName(TempFileName)); <br>            wsprintfW(p-&gt;sinfo.szName, L"%hs", TempName); <br>        } <br> <br>        // <br>        // ... and a file header. <br>        // <br>        _fmemset(&amp;p-&gt;finfo, 0, sizeof(p-&gt;finfo)); <br>        p-&gt;finfo.dwRate = 15; <br>        p-&gt;finfo.dwScale = 1; <br>        p-&gt;finfo.dwStreams = 1; <br>        p-&gt;finfo.dwWidth = 0; <br>        p-&gt;finfo.dwHeight = 0; <br>        LoadString(ghModule, IDS_FILETYPE, <br>                p-&gt;finfo.szFileType, <br>                sizeof(p-&gt;finfo.szFileType)); <br> <br>        p-&gt;finfo.dwCaps = AVIFILECAPS_CANREAD | <br>                                AVIFILECAPS_CANWRITE | <br>                                AVIFILECAPS_ALLKEYFRAMES; <br> <br>        if (mode &amp; OF_CREATE) { <br>        // <br>        // They're creating a "new" sequence <br>        // <br>        p-&gt;fStreamPresent = FALSE; <br>        } else { <br>        char            ach[_MAX_PATH]; <br>        OFSTRUCT        of; <br>        DWORD           dwFrame; <br>        HRESULT         hr; <br> <br>        // <br>        // They're opening an existing sequence, so we have to actually <br>        // count how many files are present <br>        // <br>        p-&gt;fStreamPresent = TRUE; <br> <br>        ui = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br> <br>        for (dwFrame = 0; TRUE; dwFrame++) { <br>                if (dwFrame &gt; p-&gt;dwMaxValue) <br>                break; <br> <br>                wsprintf(ach,p-&gt;achFilenameTemplate, dwFrame + p-&gt;dwFirstFrame); <br> <br>                // DPF("DIBSEQ: Checking frame %lu from '%s'\n",dwFrame,(LPSTR) ach); <br> <br>/****************************************************************************/ <br>/* DOS share has a bug.  If the file we're testing for existence is open    */ <br>/* already by someone else, we have to give it the same flag for SHARE as   */ <br>/* the other person is using.  So we have to try both on and off.  Only one */ <br>/* of these will return TRUE but if one of them does, the file exists.  Also*/ <br>/* we have to turn off the system model error box for share violations.     */ <br>/****************************************************************************/ <br> <br>                if (OpenFile((LPSTR)ach, &amp;of, OF_EXIST) == HFILE_ERROR &amp;&amp; <br>                        OpenFile((LPSTR)ach, &amp;of, OF_EXIST | OF_SHARE_DENY_NONE) == <br>                        HFILE_ERROR) <br>                break; <br>        } <br> <br>        SetErrorMode(ui); <br> <br>        if (dwFrame == 0) <br>                goto error; <br> <br>        // <br>        // Fix up the length in the header structures <br>        // <br>        p-&gt;sinfo.dwLength = dwFrame; <br>        p-&gt;finfo.dwLength = dwFrame; <br> <br>        // <br>        // Load the first frame, so we'll be ready... <br>        // <br>        hr = p-&gt;LoadFrame(0); <br> <br>        if (FAILED(GetScode(hr))) <br>                return hr; <br> <br>        p-&gt;finfo.dwSuggestedBufferSize = p-&gt;cbFrame; <br>        p-&gt;sinfo.dwSuggestedBufferSize = p-&gt;cbFrame; <br> <br>        p-&gt;finfo.dwWidth = ((LPBITMAPINFOHEADER) p-&gt;lpFormat)-&gt;biWidth; <br>        p-&gt;finfo.dwHeight = ((LPBITMAPINFOHEADER) p-&gt;lpFormat)-&gt;biHeight; <br> <br>        p-&gt;sinfo.dwFlags = AVISTREAMINFO_FORMATCHANGES; <br> <br>        SetRect(&amp;p-&gt;sinfo.rcFrame, <br>                0, 0, (int) p-&gt;finfo.dwWidth, (int) p-&gt;finfo.dwHeight); <br>        } <br> <br>        // <br>        // all done return success. <br>        // <br>        return ResultFromScode(0); // success <br> <br>error: <br>        return ResultFromScode(AVIERR_FILEREAD); <br> <br> <br>} <br> <br> <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::Save (LPCOLESTR lpszFileName, BOOL fRemember) <br>{ <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::SaveCompleted (LPCOLESTR lpszFileName) <br>{ <br>        return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CAVIFile::CPersistFileImpl::GetCurFile (LPOLESTR FAR * lplpszFileName) <br>{ <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br> <br>// -------------------- IAVIFile Implementation----------------------- <br> <br> <br>// <br>// The GetStream method returns an interface pointer to the video stream, <br>// assuming one exists. <br>// <br>STDMETHODIMP CAVIFile::CAVIFileImpl::GetStream( <br>PAVISTREAM FAR * ppavi, <br>DWORD fccType, <br>LONG lParam) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br>        int             iStreamWant; <br> <br>        iStreamWant = (int)lParam; <br> <br>        if (!p-&gt;fStreamPresent) <br>        return ResultFromScode(-1); <br> <br>        // We only support one stream <br>        if (lParam != 0) <br>                return ResultFromScode(-1); <br> <br>        // We only support a video stream <br>        if (fccType &amp;&amp; fccType != streamtypeVIDEO) <br>        return ResultFromScode(-1); <br> <br>        // <br>        // Be sure to keep the reference count up to date... <br>        // <br>        AddRef(); <br> <br>        *ppavi = (PAVISTREAM) &amp;(p-&gt;m_AVIStream); <br>        return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>// <br>// If they opened the file with the OF_CREATE flag, they will use this <br>// method to create the video stream. <br>// <br>STDMETHODIMP CAVIFile::CAVIFileImpl::CreateStream( <br>PAVISTREAM FAR *ppstream, <br>AVISTREAMINFOW FAR *psi <br>) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br> <br>        // If the stream was already there, we fail. <br>        if (p-&gt;fStreamPresent) <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br> <br>        p-&gt;sinfo = *psi; <br>        p-&gt;sinfo.dwLength = 0; <br> <br>        *ppstream = (PAVISTREAM) &amp;(p-&gt;m_AVIStream); <br>        p-&gt;fStreamPresent = TRUE; <br> <br>        // Keep the reference count correct <br>        AddRef(); <br> <br>        return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>STDMETHODIMP CAVIFile::CAVIFileImpl::WriteData( <br>DWORD ckid, <br>LPVOID lpData, <br>LONG cbData) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br> <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>STDMETHODIMP CAVIFile::CAVIFileImpl::ReadData( <br>DWORD ckid, <br>LPVOID lpData, <br>LONG FAR *lpcbData) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br> <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>STDMETHODIMP CAVIFile::CAVIFileImpl::EndRecord(void) <br>{ <br>        return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>STDMETHODIMP CAVIFile::CAVIFileImpl::Info(AVIFILEINFOW FAR * pfi, LONG lSize) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br> <br>        hmemcpy(pfi, &amp;p-&gt;finfo, min(lSize,sizeof(p-&gt;finfo))); <br>        return 0; <br>} <br> <br> <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::Create( <br>LONG lParam1, <br>LONG lParam2) <br>{ <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br>// <br>// Returns where the last key frame before the given frame is. <br>// <br>// For now, we assume each DIB is a key frame. <br>// <br>STDMETHODIMP_(LONG) CAVIFile::CAVIStreamImpl::FindSample( <br>LONG lPos, <br>LONG lFlags) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        // some minimal error checking.... <br>        if (lPos &lt; 0 || lPos &gt;= (LONG) p-&gt;sinfo.dwLength) <br>        return -1; <br> <br>        // !!! Can we really assume every frame is non-empty and a key frame? <br>        // !!! Who knows where format changes are? Let's assume everywhere! <br> <br>        return lPos; <br>} <br> <br>#define WIDTHBYTES(i)           ((unsigned)((i+31)&amp;(~31))/8) /* ULONG aligned ! */ <br>#define DIBWIDTHBYTES(bi)       (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount) <br>#define BFT_BITMAP              0x4d42   /* 'BM' */ <br> <br>// <br>// Helper function to load a given frame into our cache. <br>// <br>// This is where the actual work is done; all other functions just return <br>// the current format or frame out of the cache. <br>// <br>HRESULT NEAR PASCAL CAVIFile::LoadFrame( <br>LONG lPos) <br>{ <br>        char            ach[_MAX_PATH]; <br>        HMMIO           hmmio; <br>        BITMAPFILEHEADER        bfh; <br>        BITMAPINFOHEADER        bih; <br>        SCODE           sc = 0; <br>        UINT            ui; <br> <br>        // <br>        // Check if we've already loaded this frame... <br>        // <br>        if (lPos == lCurFrame) <br>        return 0; <br> <br>        // <br>        // Build the filename by printing using our template <br>        // <br>        wsprintf(ach, achFilenameTemplate, dwFirstFrame + lPos); <br> <br>        // No system error box, please. <br>        ui = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br> <br>        // <br>        // Go try to read the frame... Because of SHARE we have to try <br>        // opening it two different ways. <br>        // <br>        hmmio = mmioOpen(ach, NULL, MMIO_READ | OF_SHARE_DENY_WRITE); <br>        if (!hmmio) { <br>                hmmio = mmioOpen(ach, NULL, MMIO_READ); <br>        if (!hmmio) <br>                return ResultFromScode(AVIERR_FILEOPEN); <br>        } <br> <br>        SetErrorMode(ui); <br> <br>        // <br>        // Read the BitmapFileHeader... <br>        // <br>        if (mmioRead(hmmio, (LPSTR) &amp;bfh, sizeof(bfh)) != sizeof(bfh)) { <br>        sc = AVIERR_FILEREAD; <br>        goto error; <br>        } <br> <br>        if (bfh.bfType != BFT_BITMAP) { <br>        sc = AVIERR_BADFORMAT; <br>        goto error; <br>        } <br> <br>        // <br>        // Read the BitmapInfoHeader... <br>        // <br>        if (mmioRead(hmmio, (LPSTR) &amp;bih, sizeof(bih)) != sizeof(bih)) { <br>        sc = AVIERR_FILEREAD; <br>        goto error; <br>        } <br> <br>        if (bih.biSize &lt; sizeof(bih)) { <br>        sc = AVIERR_BADFORMAT; <br>        goto error; <br>        } <br> <br>        // Check that the width and height match.... <br>        if ((finfo.dwWidth &amp;&amp; finfo.dwWidth != (DWORD) bih.biWidth) || <br>        (finfo.dwHeight &amp;&amp; finfo.dwHeight != (DWORD) bih.biHeight)) { <br>        sc = AVIERR_BADFORMAT; <br>        goto error; <br>        } <br> <br>        // Fix up some fields in the header... <br>        if (bih.biSizeImage == 0) { <br>        bih.biSizeImage = DIBWIDTHBYTES(bih) * bih.biHeight; <br>        } <br> <br>        if (bih.biClrUsed == 0 &amp;&amp; bih.biBitCount &lt;= 8 &amp;&amp; bih.biCompression &lt;= BI_RLE8) <br>        bih.biClrUsed = 1 &lt;&lt; bih.biBitCount; <br> <br>        cbFormat = bih.biSize + bih.biClrUsed * sizeof(RGBQUAD); <br> <br>        // Allocate space for the format <br>        if (cbFormat &gt; cbFormatBuffer) { <br>        if (lpFormat) { <br>                GlobalFreePtr(lpFormat); <br>                lpFormat = 0; <br>                cbFormatBuffer = 0; <br>        } <br> <br>        lpFormat = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_DDESHARE, cbFormat); <br>        if (!lpFormat) { <br>                sc = AVIERR_MEMORY; <br>                goto error; <br>        } <br> <br>        cbFormatBuffer = cbFormat; <br>        } <br> <br>        *((LPBITMAPINFOHEADER) lpFormat) = bih; <br> <br>        // If the format is bigger than a BITMAPINFOHEADER, read the rest.... <br>        if (cbFormat &gt; sizeof(bih)) { <br>        if (mmioRead(hmmio, (LPSTR) lpFormat + sizeof(bih), <br>                cbFormat - (LONG)sizeof(bih)) <br>                != cbFormat - (LONG)sizeof(bih)) <br>        { <br>                sc = AVIERR_FILEREAD; <br>                goto error; <br>        } <br>        } <br> <br>        // <br>        // Allocate enough space to read the frame in... <br>        // <br>        if (bih.biSizeImage &gt; (DWORD) cbFrameBuffer) { <br>        if (lpFrame) { <br>                GlobalFreePtr(lpFrame); <br>                lpFrame = 0; <br>                cbFrameBuffer = 0; <br>        } <br> <br>        lpFrame = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_DDESHARE, bih.biSizeImage); <br>        if (!lpFrame) { <br>                sc = AVIERR_MEMORY; <br>                goto error; <br>        } <br> <br>        cbFrameBuffer = bih.biSizeImage; <br>        } <br> <br>        cbFrame = bih.biSizeImage; <br> <br>        // <br>        // and actually read the frame.... <br>        // <br>        if (mmioRead(hmmio, (LPSTR) lpFrame, cbFrame) != cbFrame) { <br>        sc = AVIERR_FILEREAD; <br>        goto error; <br>        } <br> <br>        lCurFrame = lPos; <br> <br>error: <br>        mmioClose(hmmio, 0); <br> <br>        return ResultFromScode(sc); <br>} <br> <br>// <br>// The ReadFormat method returns the format of the specified frame.... <br>// <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::ReadFormat( <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG FAR *lpcbFormat) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br>        HRESULT hr; <br> <br>        // <br>        // Try to get the correct frame <br>        // <br>        hr = p-&gt;LoadFrame(lPos); <br> <br>        if (hr != 0) <br>        return hr; <br> <br>        // No buffer to fill in, this means return the size needed. <br>        if (lpFormat == NULL || *lpcbFormat == 0) { <br>                *lpcbFormat = p-&gt;cbFormat; <br>        return 0; <br>        } <br> <br>        // <br>        // and return as much of the format as will fit. <br>        // <br>        hmemcpy(lpFormat, p-&gt;lpFormat, min(*lpcbFormat, p-&gt;cbFormat)); <br>        *lpcbFormat = p-&gt;cbFormat; <br>        return 0; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::Info(AVISTREAMINFOW FAR * psi, LONG lSize) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        hmemcpy(psi,&amp;p-&gt;sinfo, min(lSize,sizeof(p-&gt;sinfo))); <br>//      return sizeof(p-&gt;sinfo); <br>        return 0; <br>} <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CUnknownImpl::Release() <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        uUseCount--; <br>        if (!--m_refs) { <br>        LONG lRet = AVIERR_OK; <br> <br>        if (p-&gt;fDirty) { <br>        } <br> <br> <br>        goto success; <br> <br>        success: <br>        if (p-&gt;lpFormat) <br>                GlobalFreePtr(p-&gt;lpFormat); <br> <br>        p-&gt;lpFormat = NULL; <br>        p-&gt;cbFormat = 0; <br> <br>        if (p-&gt;lpFrame) <br>                GlobalFreePtr(p-&gt;lpFrame); <br> <br>        p-&gt;lpFrame = NULL; <br>        p-&gt;cbFrame = 0; <br> <br>        delete this; <br>        return 0; <br>        } <br>        return m_refs; <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::Read( <br>LONG            lStart, <br>LONG            lSamples, <br>LPVOID          lpBuffer, <br>LONG            cbBuffer, <br>LONG FAR *      plBytes, <br>LONG FAR *      plSamples) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br>        HRESULT     hr; <br> <br>        if (lStart &lt; 0 || lStart &gt;= (LONG) p-&gt;sinfo.dwLength) { <br>        if (plBytes) <br>            *plBytes = 0; <br>        if (plSamples) <br>            *plSamples = 0; <br>        return 0; <br>        } <br> <br>        // We always read one frame at a time... <br>        lSamples = 1; <br> <br>        // Load it into the cache.... <br>        hr = p-&gt;LoadFrame(lStart); <br> <br>        if (hr != 0) <br>        return hr; <br> <br>        // <br>        // a NULL buffer means return the size buffer needed to read <br>        // the given sample. <br>        // <br>        if (lpBuffer == NULL || cbBuffer == 0) { <br>        if (plBytes) <br>            *plBytes =  p-&gt;cbFrame; <br>        if (plSamples) <br>            *plSamples = lSamples; <br>        return 0; <br>        } <br> <br>        // <br>        // They didn't give us enough space for the frame, so complain <br>        // <br>        if (cbBuffer &lt; p-&gt;cbFrame) { <br>        if (plBytes) <br>            *plBytes = p-&gt;cbFrame; <br> <br>        return ResultFromScode(AVIERR_BUFFERTOOSMALL); <br>        } <br> <br>        // <br>        // Copy the frame into the caller's buffer <br>        // <br>        hmemcpy(lpBuffer, p-&gt;lpFrame, p-&gt;cbFrame); <br> <br>        // <br>        // success return number of bytes and number of samples read <br>        // <br>        if (plBytes) <br>                *plBytes = p-&gt;cbFrame; <br> <br>        if (plSamples) <br>                *plSamples = lSamples; <br> <br>        return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::SetFormat( <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG cbFormat) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        // Keep track of the format.... <br>        p-&gt;cbFormat = cbFormat; <br>        p-&gt;lpFormat = (LPVOID) GlobalAllocPtr(GMEM_MOVEABLE | GMEM_DDESHARE, cbFormat); <br> <br>        if (p-&gt;lpFormat == NULL) <br>        return ResultFromScode(AVIERR_MEMORY); <br> <br>        hmemcpy(p-&gt;lpFormat, lpFormat, cbFormat); <br> <br>        p-&gt;finfo.dwWidth = ((LPBITMAPINFOHEADER) p-&gt;lpFormat)-&gt;biWidth; <br>        p-&gt;finfo.dwHeight = ((LPBITMAPINFOHEADER) p-&gt;lpFormat)-&gt;biHeight; <br> <br>        SetRect(&amp;p-&gt;sinfo.rcFrame, <br>            0, 0, (int) p-&gt;finfo.dwWidth, (int) p-&gt;finfo.dwHeight); <br> <br>        return 0L; <br>} <br> <br>// <br>// Helper function to save a single frame <br>// <br>HRESULT NEAR PASCAL CAVIFile::WriteFrame( <br>LONG lPos, <br>LPVOID lp, <br>LONG cb) <br>{ <br>        char            ach[_MAX_PATH]; <br>        HMMIO           hmmio; <br>        BITMAPFILEHEADER        bfh; <br> <br>        // <br>        // If they're overwriting the cached frame, invalidate the cache </code></pre>
<p>
</p>
<pre><code>// <br>        if (lPos == lCurFrame) <br>        lCurFrame = -1; <br> <br> <br>        // <br>        // Build the filename to write to <br>        // <br>        wsprintf(ach, achFilenameTemplate, dwFirstFrame + lPos); <br> <br>        // and write it. <br>        hmmio = mmioOpen(ach, NULL, MMIO_WRITE | MMIO_CREATE | OF_SHARE_EXCLUSIVE); <br> <br>        if (!hmmio) <br>        return ResultFromScode(AVIERR_FILEOPEN); <br> <br>        // <br>        // Write the BitmapFileHeader <br>        // <br>        bfh.bfType = BFT_BITMAP; <br>        bfh.bfOffBits = sizeof(bfh) + cbFormat; <br>        bfh.bfSize = bfh.bfOffBits + cb; <br> <br>        if (mmioWrite(hmmio, (LPSTR) &amp;bfh, sizeof(bfh)) != sizeof(bfh)) { <br>error: <br>        mmioClose(hmmio, 0); <br>        return ResultFromScode(AVIERR_FILEWRITE); <br>        } <br> <br>        ((LPBITMAPINFOHEADER) lpFormat)-&gt;biSizeImage = cb; <br> <br>        // <br>        // Write the DIB format <br>        // <br>        if (mmioWrite(hmmio, (LPSTR) lpFormat, cbFormat) != cbFormat) <br>        goto error; <br> <br>        // <br>        // Write the data <br>        // <br>        if (mmioWrite(hmmio, (LPSTR) lp, cb) != cb) <br>        goto error; <br> <br>        // <br>        // Flush things so that we can be sure everything is written out <br>        // <br>        if (mmioFlush(hmmio, 0) != 0) <br>        goto error; <br> <br>        mmioClose(hmmio, 0); <br> <br>        return 0; <br>} <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::Write( <br>LONG lStart, <br>LONG lSamples, <br>LPVOID lpData, <br>LONG cbData, <br>DWORD dwFlags, <br>LONG FAR *plSampWritten, <br>LONG FAR *plBytesWritten) <br>{ <br>        CAVIFile FAR *  p = m_pAVIFile; <br>        HRESULT     hr; <br> <br>        if ((p-&gt;mode &amp; (OF_WRITE | OF_READWRITE)) == 0) <br>        return ResultFromScode(AVIERR_READONLY); <br> <br>        if (p-&gt;lpFormat == NULL) <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br> <br>        // &lt; 0 means "at end" <br>        if (lStart &lt; 0) <br>        lStart = p-&gt;sinfo.dwStart + p-&gt;sinfo.dwLength; <br> <br>        if (lStart &gt; (LONG) (p-&gt;sinfo.dwStart + p-&gt;sinfo.dwLength)) <br>        return ResultFromScode(AVIERR_BADPARAM); <br> <br>        // !!! Die if we've reached the limit of our numbers.... <br>        if ((DWORD) lStart + p-&gt;dwFirstFrame &gt; p-&gt;dwMaxValue) <br>        return ResultFromScode(AVIERR_FILEWRITE); <br> <br>        if (lSamples != 1) <br>        return ResultFromScode(AVIERR_BADPARAM); <br> <br>        // only allow key frames! <br>        if (!(dwFlags &amp; AVIIF_KEYFRAME)) { <br>        DPF("Tried to write a non-key frame to a DIB sequence!\n"); <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>        } <br> <br>        hr = p-&gt;WriteFrame(lStart, lpData, cbData); <br> <br>        if (hr != AVIERR_OK) <br>        return hr; <br> <br>        p-&gt;fDirty = TRUE; <br> <br>        p-&gt;sinfo.dwLength = <br>                max((LONG) p-&gt;sinfo.dwLength, <br>                                  lStart + lSamples); <br> <br>        p-&gt;finfo.dwLength = p-&gt;sinfo.dwLength; <br> <br>        p-&gt;finfo.dwSuggestedBufferSize = <br>                        max(p-&gt;finfo.dwSuggestedBufferSize, (DWORD) cbData); <br>        p-&gt;sinfo.dwSuggestedBufferSize = <br>                        p-&gt;finfo.dwSuggestedBufferSize; <br> <br>        if (plSampWritten) <br>        *plSampWritten = lSamples; <br> <br>        if (plBytesWritten) <br>        *plBytesWritten = cbData; <br> <br>        return ResultFromScode(AVIERR_OK); <br>} <br> <br>// these both are for saving. we don't support saving <br> <br>STDMETHODIMP <br>CAVIFile::CAVIFileImpl::DeleteStream(DWORD fccType, LONG lParam) <br>{ <br>    return ResultFromScode(E_FAIL); <br>} <br> <br>STDMETHODIMP <br>CAVIFile::CAVIStreamImpl::SetInfo( <br>                AVISTREAMINFOW FAR * lpInfo, <br>                LONG cbInfo <br>) <br>{ <br>    return ResultFromScode(E_FAIL); <br>} <br> <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::Delete( <br>LONG lStart, <br>LONG lSamples) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br>// Should these just map to Read/WriteData? !!! <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::ReadData( <br>DWORD fcc, <br>LPVOID lp, <br>LONG FAR *lpcb) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>STDMETHODIMP CAVIFile::CAVIStreamImpl::WriteData( <br>DWORD fcc, <br>LPVOID lp, <br>LONG cb) <br>{ <br>        CAVIFile FAR * p = m_pAVIFile; <br> <br>        return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br>#ifdef CUSTOMMARSHAL <br>// The code below supports custom marshalling. <br> <br>// !!! Need good explanation here! <br> <br>CAVIFile::CMarshalImpl::CMarshalImpl( <br>CAVIFile FAR*   pAVIFile) <br>{ <br>        m_pAVIFile = pAVIFile; <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP CAVIFile::CMarshalImpl::QueryInterface( <br>const IID FAR&amp;  iid, <br>void FAR* FAR*  ppv) <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;QueryInterface(iid, ppv); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CMarshalImpl::AddRef() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;AddRef(); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>STDMETHODIMP_(ULONG) CAVIFile::CMarshalImpl::Release() <br>{ <br>        return m_pAVIFile-&gt;m_pUnknownOuter-&gt;Release(); <br>} <br> <br>// *** IMarshal methods *** <br>STDMETHODIMP CAVIFile::CMarshalImpl::GetUnmarshalClass ( <br>THIS_ REFIID riid, LPVOID pv, <br>DWORD dwDestContext, LPVOID pvDestContext, <br>DWORD mshlflags, LPCLSID pCid) <br>{ <br>        HRESULT hr = NOERROR; <br> <br>        DPF("UnMarshalClass called\n"); <br> <br>        if (dwDestContext != MSHCTX_LOCAL) { <br>        LPMARSHAL       pMarshal; <br> <br>        DPF("Marshal context is %lu: delegating...\n", dwDestContext); <br> <br>        hr = CoGetStandardMarshal(riid, NULL, dwDestContext, pvDestContext, mshlflags, <br>                        &amp;pMarshal); <br> <br>        if (hr != NOERROR) <br>                return hr; <br> <br>        hr = pMarshal-&gt;GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, <br>                        mshlflags, pCid); <br> <br>        pMarshal-&gt;Release(); <br> <br>        return hr; <br>        } <br> <br>        *pCid = CLSID_AVISimpleUnMarshal; <br> <br>        return hr; <br>} <br> <br>STDMETHODIMP CAVIFile::CMarshalImpl::GetMarshalSizeMax ( <br>THIS_ REFIID riid, LPVOID pv, <br>DWORD dwDestContext, LPVOID pvDestContext, <br>DWORD mshlflags, LPDWORD pSize) <br>{ <br>        HRESULT hr = NOERROR; <br>        IUnknown FAR * pUnk = &amp;m_pAVIFile-&gt;m_Unknown; <br> <br>        if (dwDestContext != MSHCTX_LOCAL) { <br>        LPMARSHAL       pMarshal; <br> <br>        hr = CoGetStandardMarshal(riid, NULL, dwDestContext, pvDestContext, mshlflags, <br>                &amp;pMarshal); <br> <br>        if (hr != NOERROR) <br>                return hr; <br> <br>        hr = pMarshal-&gt;GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, <br>                        mshlflags, pSize); <br> <br>        pMarshal-&gt;Release(); <br> <br>        return hr; <br>        } <br> <br>        *pSize = sizeof(pUnk); <br> <br>        return hr; <br>} <br> <br>STDMETHODIMP CAVIFile::CMarshalImpl::MarshalInterface ( <br>THIS_ LPSTREAM pStm, REFIID riid, <br>LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext, <br>DWORD mshlflags) <br>{ <br>        HRESULT hr = NOERROR; <br>        IUnknown FAR * pUnk = &amp;m_pAVIFile-&gt;m_Unknown; <br> <br>        DPF("MarshalInterface called\n"); <br> <br>        if (dwDestContext != MSHCTX_LOCAL) { <br>        LPMARSHAL pMarshal; <br> <br>        DPF("Marshal context is %lu: delegating...\n", dwDestContext); <br> <br>        hr = CoGetStandardMarshal(riid, NULL, dwDestContext, pvDestContext, mshlflags, <br>                &amp;pMarshal); <br> <br>        if (hr != NOERROR) <br>                return hr; <br> <br>        hr = pMarshal-&gt;MarshalInterface(pStm, riid, pv, dwDestContext, pvDestContext, <br>                        mshlflags); <br> <br>        pMarshal-&gt;Release(); <br> <br>        return hr; <br>        } <br> <br> <br>        if ((riid != IID_IAVIStream &amp;&amp; riid != IID_IAVIFile &amp;&amp; riid != IID_IUnknown)) <br>                return ResultFromScode(E_INVALIDARG); <br> <br>        if ((hr = pStm-&gt;Write(&amp;pUnk, sizeof(pUnk), NULL)) == NOERROR) <br>        AddRef(); <br> <br>        DPF("Returns %lx\n", (DWORD) (LPVOID) hr); <br>        return hr; <br>} <br> <br>STDMETHODIMP CAVIFile::CMarshalImpl::UnmarshalInterface ( <br>THIS_ LPSTREAM pStm, REFIID riid, <br>LPVOID FAR* ppv) <br>{ <br>        HRESULT hr = ResultFromScode(E_FAIL); <br> <br>        DPF("UnMarshalInterface called!!!\n"); <br>        return hr; <br>} <br> <br>STDMETHODIMP CAVIFile::CMarshalImpl::ReleaseMarshalData ( <br>THIS_ LPSTREAM pStm) <br>{ <br>        HRESULT hr = NOERROR; <br>        IUnknown FAR * pUnk; <br> <br>        hr = pStm-&gt;Read(&amp;pUnk,sizeof(pUnk),NULL); <br>        if (hr == NOERROR) <br>        pUnk-&gt;Release(); <br> <br>        return hr; <br>} <br> <br>STDMETHODIMP CAVIFile::CMarshalImpl::DisconnectObject ( <br>THIS_ DWORD dwReserved) <br>{ <br>        HRESULT hr = NOERROR; <br> <br>        return hr; <br>} <br>#endif <br> <br>/***************************************************************************** <br> * <br> * dprintf() is called by the DPF macro if DEBUG is defined at compile time. <br> * <br> * The messages will be send to COM1: like any debug message. To <br> * enable debug output, add the following to WIN.INI : <br> * <br> * [debug] <br> * ICSAMPLE=1 <br> * <br> ****************************************************************************/ <br> <br>#ifdef DEBUG <br> <br>#define MODNAME "DSEQFILE" <br>static BOOL fDebug = -1; <br> <br>static void cdecl dprintf( <br>LPSTR szFormat, ...) <br>{ <br>        char ach[128]; <br> <br>        va_list va; <br>        if (fDebug == -1) <br>                fDebug = GetProfileIntA("Debug",MODNAME, FALSE); <br> <br>        if (!fDebug) <br>                return; <br> <br>        va_start(va, szFormat); <br>        if (szFormat[0] == '!') <br>                ach[0]=0, szFormat++; <br>        else <br>                lstrcpyA(ach, MODNAME ": "); <br> <br>        wvsprintfA(ach+lstrlenA(ach),szFormat,(LPSTR)va); <br>        va_end(va); <br>//      lstrcatA(ach, "\r\r\n"); <br> <br>        OutputDebugStringA(ach); <br>} <br> <br>#endif <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
