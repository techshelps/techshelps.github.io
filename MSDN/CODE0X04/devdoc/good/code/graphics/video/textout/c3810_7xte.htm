<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TXTOUT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3812"></a>TXTOUT.C</h2>
<pre><code>/**************************************************************************** <br> * <br> *   TxtOut.c <br> * <br> *   TXTOUT is a sample installable compressor for AVI 1.0. <br> * <br> ***************************************************************************/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br>#include &lt;stdlib.h&gt; // for mbstowcs <br>#include &lt;memory.h&gt; // for _fmemcpy <br>#include &lt;stdarg.h&gt; // for va_list <br> <br>#include "TxtOut.h" <br> <br>/***************************************************************************** <br> * <br> * <br> ****************************************************************************/ <br> <br>#define MODNAME         "TXTOUT" <br>#define FOURCC_SAMP mmioFOURCC('D','R','A','W') <br> <br>#define VERSION_SAMP    0x00010000 // 1.00 <br> <br>extern HANDLE ghModule; <br> <br> <br>/***************************************************************************** <br> * <br> * DefaultState holds the compression options that will be used if the user <br> * compresses an image without configuring us at all first. In the case of <br> * the sample compressor, it is the pixel keep ratio. <br> * <br> ****************************************************************************/ <br> <br>ICSTATE DefaultState = {2}; <br> <br> <br>/***************************************************************************** <br> * <br> * Load() is called from the ICM_LOAD message. <br> * <br> * Tasks such as allocating global memory that is non-instance specific <br> * or initializing coprocessor hardware may be performed here. <br> * <br> * Our simple case needs none of this. <br> * <br> ****************************************************************************/ <br>BOOL NEAR PASCAL Load(void) <br>{ <br>    DPF2("Load()"); <br>    return TRUE; <br>} <br> <br>/***************************************************************************** <br> * <br> * Free() is called from the ICM_FREE message. <br> * <br> * It should totally reverse the effects of Load() in preparation for <br> * the DRV being removed from memory. <br> * <br> ****************************************************************************/ <br>void NEAR PASCAL Free(void) <br>{ <br>    DPF2("Free()"); <br>} <br> <br>/***************************************************************************** <br> * <br> * Open() is called from the ICM_OPEN message <br> * <br> * This message will be sent for a particular compress/decompress session. <br> * Our code must verify that we are indeed being called as a video <br> * compressor and create/initialize a state structure. The ICM will <br> * give us back the pointer to that structure on every message dealing <br> * with this session. <br> * <br> ****************************************************************************/ <br>INSTINFO * NEAR PASCAL Open( <br>    ICOPEN FAR * icinfo) <br>{ <br>    INSTINFO * pinst; <br> <br>    DPF2("Open('%4.4hs', '%4.4hs')", &amp;icinfo-&gt;fccType, &amp;icinfo-&gt;fccHandler); <br> <br>    // <br>    // refuse to open if we are not being opened as a Video compressor <br>    // <br>    if (icinfo-&gt;fccType != streamtypeTEXT) { <br>        DPF2("Open rejected: not TEXT"); <br>        return NULL; <br>    } <br> <br>    pinst = (INSTINFO *)LocalAlloc(LPTR, sizeof(INSTINFO)); <br> <br>    if (!pinst) { <br>        icinfo-&gt;dwError = ICERR_MEMORY; <br>        DPF2("Open rejected: no memory"); <br>        return NULL; <br>    } <br> <br>    // <br>    // init structure <br>    // <br>    pinst-&gt;dwFlags = icinfo-&gt;dwFlags; <br>    pinst-&gt;nDraw = 0; <br>    pinst-&gt;hfont = GetStockFont(ANSI_VAR_FONT); <br> <br>    // <br>    // set the default state. <br>    // <br>    SetState(pinst, NULL, 0); <br> <br>    // <br>    // return success. <br>    // <br>    icinfo-&gt;dwError = ICERR_OK; <br> <br>    DPF2("Open succeeded!"); <br>    return pinst; <br>} <br> <br>/***************************************************************************** <br> * <br> * Close() is called on the ICM_CLOSE message. <br> * <br> * This message is the complement to ICM_OPEN and marks the end <br> * of a compress/decompress session. We kill any in-progress operations <br> * (although this shouldn't be needed) and free our instance structure. <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL Close( <br>    INSTINFO * pinst) <br>{ <br>    DPF2("Close()"); <br> <br>    while (pinst-&gt;nDraw &gt; 0) <br>        DrawEnd(pinst); <br>    LocalFree((HLOCAL)pinst); <br>    return 1; <br>} <br> <br>/***************************************************************************** <br> * <br> * QueryAbout() and About() handle the ICM_ABOUT message. <br> * <br> * QueryAbout() returns TRUE to indicate we support an about box. <br> * About() displays the box. <br> * <br> ****************************************************************************/ <br>BOOL NEAR PASCAL QueryAbout( <br>    INSTINFO * pinst) <br>{ <br>    DPF2("QueryAbout()"); <br> <br>    return TRUE; <br>} <br> <br>LRESULT NEAR PASCAL About( <br>    INSTINFO * pinst, <br>    HWND hwnd) <br>{ <br>    char sztempName[50]; <br>    char sztempDesc[50]; <br> <br>    LoadString(ghModule, IDS_NAME, sztempName, sizeof sztempName); <br>    LoadString(ghModule, IDS_DESCRIPTION, sztempDesc, sizeof sztempDesc); <br>    DPF2("About()"); <br>    MessageBox(hwnd, sztempDesc, sztempName, MB_OK|MB_ICONINFORMATION); <br>    return ICERR_OK; <br>} <br> <br>/***************************************************************************** <br> * <br> * QueryConfigure() and Configure() implement the ICM_CONFIGURE message. <br> * <br> * These functions put up a dialog that allows the user, if he so <br> * chooses, to modify the configuration portion of our state info. <br> * <br> ****************************************************************************/ <br>BOOL NEAR PASCAL QueryConfigure( <br>    INSTINFO * pinst) <br>{ <br>    DPF2("QueryConfigure()"); <br>    return FALSE; <br>} <br> <br>LRESULT NEAR PASCAL Configure( <br>    INSTINFO * pinst, <br>    HWND hwnd) <br>{ <br>    DPF2("Configure()"); <br>    return DialogBoxParam(ghModule,"Configure",hwnd,ConfigureDlgProc, (LONG)(UINT)pinst); <br>} <br> <br>/***************************************************************************** <br> * <br> * GetState() implements the ICM_GETSTATE message. <br> * <br> * We copy our configuration information and return how many bytes it took. <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL GetState( <br>    INSTINFO * pinst, <br>    LPVOID pv, <br>    DWORD dwSize) <br>{ <br>    DPF2("GetState(%08lX, %ld)", pv, dwSize); <br> <br>    if (pv == NULL || dwSize == 0) <br>        return sizeof(ICSTATE); <br> <br>    if (dwSize &lt; sizeof(ICSTATE)) <br>        return 0; <br> <br>    *((ICSTATE FAR *)pv) = pinst-&gt;CurrentState; <br> <br>    // return number of bytes copied <br>    return sizeof(ICSTATE); <br>} <br> <br>/***************************************************************************** <br> * <br> * SetState() implements the ICM_SETSTATE message. <br> * <br> * The ICM is giving us configuration information saved by GetState() <br> * earlier. <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL SetState( <br>    INSTINFO * pinst, <br>    LPVOID pv, <br>    DWORD dwSize) <br>{ <br>    DPF2("SetState(%08lX, %ld)", pv, dwSize); <br> <br>    if (pv == NULL) <br>        pinst-&gt;CurrentState = DefaultState; <br>    else if (dwSize &gt;= sizeof(ICSTATE)) <br>        pinst-&gt;CurrentState = *((ICSTATE FAR *)pv); <br>    else <br>        return 0; <br> <br>    // return number of bytes copied <br>    return sizeof(ICSTATE); <br>} <br> <br>/***************************************************************************** <br> * <br> * GetInfo() implements the ICM_GETINFO message <br> * <br> * We just fill in the structure to tell the ICM what we can do. The flags <br> * (none of which this sample supports) mean the following : <br> * <br> * VIDCF_QUALITY - we support the quality variable. This means we look at <br> *                 dwQuality in the ICINFO structure when compressing and <br> *                 make a concious decision to trade quality for space. <br> *                 (higher values of dwQuality mean quality is more <br> *                 important). dwQuality is set by the ICM. <br> * <br> * VIDCF_TEMPORAL - We do interframe compression. In this algorithm, not <br> *                  every frame is a "key frame"; some frames depend on <br> *                  other frames to be generated. An example of this might <br> *                  be to store frame buffer differences until the <br> *                  differences are big enough to no longer make this <br> *                  worthwhile, then storing another complete frame and <br> *                  starting over. In this case, the complete frames that <br> *                  are stored are key frames and should be flagged as <br> *                  such. <br> * <br> * VIDCF_DRAW -     We will draw the decompressed image on our own. This is <br> *                  useful if the decompression is assisted by the video <br> *                  hardware. <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL GetInfo( <br>    INSTINFO * pinst, <br>    ICINFO FAR *icinfo, <br>    DWORD dwSize) <br>{ <br>    char sztempName[50]; <br>    char sztempDesc[50]; <br> <br>    LoadString(ghModule, IDS_NAME, sztempName, sizeof sztempName); <br>    LoadString(ghModule, IDS_DESCRIPTION, sztempDesc, sizeof sztempDesc); <br>    DPF2("GetInfo()"); <br> <br>    if (icinfo == NULL) <br>        return sizeof(ICINFO); <br> <br>    if (dwSize &lt; sizeof(ICINFO)) <br>        return 0; <br> <br>    icinfo-&gt;dwSize      = sizeof(ICINFO); <br>    icinfo-&gt;fccType     = streamtypeTEXT; <br>    icinfo-&gt;fccHandler  = FOURCC_SAMP; <br>    icinfo-&gt;dwFlags     = VIDCF_DRAW; <br> <br>                // VIDCF_QUALITY    // supports quality <br>                // VIDCF_TEMPORAL   // supports inter-frame <br>                // VIDCF_DRAW       // supports drawing <br> <br>    icinfo-&gt;dwVersion   = VERSION_SAMP; <br>    icinfo-&gt;dwVersionICM    = ICVERSION; <br>    mbstowcs(icinfo-&gt;szDescription, sztempDesc, sizeof sztempDesc); <br>    mbstowcs(icinfo-&gt;szName, sztempName, sizeof sztempName); <br> <br>    return sizeof(ICINFO); <br>} <br> <br> <br>LRESULT NEAR PASCAL DrawQuery( <br>    INSTINFO * pinst, <br>    LPVOID FAR * lpFormat) <br>{ <br>    return ICERR_OK; <br>} <br> <br>/***************************************************************************** <br> * <br> * DrawBegin() implements ICM_DRAW_BEGIN <br> * <br> * This is just like DecompressBegin() except that we also must prepare to <br> * actually draw the bitmap on the screen. ICDRAWBEGIN provides info specific <br> * to this task. <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL DrawBegin( <br>    INSTINFO * pinst, <br>    ICDRAWBEGIN FAR *icinfo, <br>    DWORD dwSize) <br>{ <br>    DPF2("DrawBegin()"); <br> <br>    if (pinst-&gt;nDraw++ &gt; 0) <br>        return ICERR_OK; <br> <br>    // <br>    // get ready to draw <br>    // <br>    pinst-&gt;db = *icinfo; <br>    SetRect(&amp;pinst-&gt;rc, icinfo-&gt;xDst, icinfo-&gt;yDst, <br>        icinfo-&gt;xDst + icinfo-&gt;dxDst, icinfo-&gt;yDst + icinfo-&gt;dyDst); <br> <br>    return ICERR_OK; <br>} <br> <br>/***************************************************************************** <br> * <br> * Draw implements ICM_DRAW <br> * <br> * Decompress and draw <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL Draw( <br>    INSTINFO * pinst, <br>    ICDRAW FAR *icinfo, <br>    DWORD dwSize) <br>{ <br>    HFONT hfont; <br> <br>    DPF2("Draw()"); <br> <br>    if (icinfo-&gt;lpData &amp;&amp; icinfo-&gt;cbData) { <br>        pinst-&gt;iLen = min((int) icinfo-&gt;cbData, <br>                (int) _fstrlen((LPSTR) icinfo-&gt;lpData)); <br>        pinst-&gt;iLen = min(pinst-&gt;iLen, BUFFER_SIZE - 1); <br>        hmemcpy(pinst-&gt;achBuffer, icinfo-&gt;lpData, pinst-&gt;iLen); <br>        pinst-&gt;achBuffer[pinst-&gt;iLen] = '\0'; <br>    } else if (!(icinfo-&gt;dwFlags &amp; ICDRAW_UPDATE)) <br>        return ICERR_OK; <br>    if (pinst-&gt;nDraw == 0) <br>        return ICERR_ERROR; <br> <br>    hfont = SelectFont(pinst-&gt;db.hdc, pinst-&gt;hfont); <br> <br>    ExtTextOut(pinst-&gt;db.hdc, <br>        pinst-&gt;db.xDst, pinst-&gt;db.yDst, <br>        ETO_OPAQUE, <br>        &amp;pinst-&gt;rc, <br>        (LPSTR) pinst-&gt;achBuffer, <br>        pinst-&gt;iLen, <br>        NULL); <br> <br>    SelectFont(pinst-&gt;db.hdc, hfont); <br> <br>    return ICERR_OK; <br>} <br> <br>/***************************************************************************** <br> * <br> * DrawEnd() implements ICM_DRAW_END <br> * <br> * See DecompressEnd() <br> * <br> ****************************************************************************/ <br>LRESULT NEAR PASCAL DrawEnd( <br>    INSTINFO * pinst) <br>{ <br>    DPF2("DrawEnd()"); <br> <br>    if (pinst-&gt;nDraw == 0) <br>        return ICERR_ERROR; <br> <br>    if (--pinst-&gt;nDraw &gt; 0) <br>        return ICERR_OK; <br> <br>    // <br>    // but if we did we would clean up here <br>    // <br> <br>    return ICERR_OK; <br>} <br> <br>/***************************************************************************** <br> * <br> * ConfigureDlgProc() is called by Configure <br> * <br> * This is a standard dialog proc which allows the user to <br> * pick config options for the driver. <br> * <br> ****************************************************************************/ <br>BOOL CALLBACK ConfigureDlgProc( <br>    HWND hdlg, <br>    UINT msg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>    case WM_COMMAND: <br>        switch LOWORD((wParam)) <br>        { <br>            case IDOK: <br>                EndDialog(hdlg,TRUE); <br>                break; <br> <br>            case IDCANCEL: <br>                EndDialog(hdlg,FALSE); <br>                break; <br>        } <br>        break; <br>    } <br>    return FALSE; <br>} <br> <br>/***************************************************************************** <br> * <br> * dprintf() is called by the DPF macro if DEBUG is defined at compile time. <br> * <br> * The messages will be send to COM1: like any debug message. To <br> * enable debug output, add the following to WIN.INI : <br> * <br> * [debug] <br> * TXTOUT=1 <br> * <br> ****************************************************************************/ <br> <br>#ifdef DEBUG <br>static int iDebug = -1; <br> <br>void FAR cdecl dprintf( <br>    LPSTR szFormat, <br>    ...) <br>{ <br>    char ach[128]; <br> <br>    if (iDebug == -1) <br>        iDebug = GetProfileInt("Debug", MODNAME, FALSE); <br> <br>    if (!iDebug) <br>        return; <br> <br>    lstrcpy(ach, MODNAME ": "); <br> <br>    { <br>        va_list va; <br> <br>        va_start(va, szFormat); <br>        wvsprintf(ach+lstrlen(ach), szFormat, va); <br>        va_end(va); <br> <br>    } <br> <br>    lstrcat(ach, "\r\n"); <br>    OutputDebugString(ach); <br>} <br> <br>void FAR cdecl dprintf2( <br>    LPSTR szFormat, <br>    ...) <br>{ <br>    char ach[128]; <br> <br>    if (iDebug == -1) <br>        iDebug = GetProfileInt("Debug", MODNAME, FALSE); <br> <br>    if (iDebug &lt; 2) <br>        return; <br> <br>    lstrcpy(ach, MODNAME ": "); <br> <br>    { <br>        va_list va; <br> <br>        va_start(va, szFormat); <br>        wvsprintf(ach+lstrlen(ach), szFormat, va); <br>        va_end(va); <br> <br>    } <br> <br>    lstrcat(ach, "\r\n"); <br> <br>    OutputDebugString(ach); <br>} <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
