<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AVIBALL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3776"></a>AVIBALL.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *  AVIBALL.C <br> * <br> *  Sample AVIStream handler for a bouncing ball.  This code demonstrates <br> *  how to write a custom stream handler so an application can deal with <br> *  your custom file/data/whatever by using the standard AVIStream functions. <br> * <br>***************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "aviball.h" <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// silly default parameters <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>#define DEFAULT_WIDTH   240 <br>#define DEFAULT_HEIGHT  120 <br>#define DEFAULT_LENGTH  100 <br>#define DEFAULT_SIZE    6 <br>#define DEFAULT_COLOR   RGB(255,0,0) <br>#define XSPEED7 <br>#define YSPEED5 <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// useful macros <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>#define ALIGNULONG(i)     ((i+3)&amp;(~3))                  /* ULONG aligned ! */ <br>#define WIDTHBYTES(i)     ((unsigned)((i+31)&amp;(~31))/8)  /* ULONG aligned ! */ <br>#define DIBWIDTHBYTES(bi) (int)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount) <br>#define DIBPTR(lpbi) ((LPBYTE)(lpbi) + \ <br>    (int)(lpbi)-&gt;biSize + \ <br>    (int)(lpbi)-&gt;biClrUsed * sizeof(RGBQUAD) ) <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// custom video stream instance structure <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct { <br> <br>    // <br>    // The Vtbl must come first <br>    // <br>    IAVIStreamVtbl * lpvtbl; <br> <br>    // <br>    //  private ball instance data <br>    // <br>    ULONGulRefCount; <br> <br>    DWORD       fccType;        // is this audio/video <br> <br>    int         width;          // size in pixels of each frame <br>    int         height; <br>    int         length;         // length in frames of the pretend AVI movie <br>    int         size; <br>    COLORREF    color;          // ball color <br> <br>} AVIBALL, * PAVIBALL; <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// custom stream methods <br>// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>HRESULT STDMETHODCALLTYPE AVIBallQueryInterface(PAVISTREAM ps, REFIID riid, LPVOID * ppvObj); <br>HRESULT STDMETHODCALLTYPE AVIBallCreate       (PAVISTREAM ps, LONG lParam1, LONG lParam2); <br>ULONG   STDMETHODCALLTYPE AVIBallAddRef       (PAVISTREAM ps); <br>ULONG   STDMETHODCALLTYPE AVIBallRelease      (PAVISTREAM ps); <br>HRESULT STDMETHODCALLTYPE AVIBallInfo         (PAVISTREAM ps, AVISTREAMINFOW * psi, LONG lSize); <br>LONG    STDMETHODCALLTYPE AVIBallFindSample (PAVISTREAM ps, LONG lPos, LONG lFlags); <br>HRESULT STDMETHODCALLTYPE AVIBallReadFormat   (PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG *lpcbFormat); <br>HRESULT STDMETHODCALLTYPE AVIBallSetFormat    (PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG cbFormat); <br>HRESULT STDMETHODCALLTYPE AVIBallRead         (PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, LONG * plBytes,LONG * plSamples); <br>HRESULT STDMETHODCALLTYPE AVIBallWrite        (PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags, LONG *plSampWritten, LONG *plBytesWritten); <br>HRESULT STDMETHODCALLTYPE AVIBallDelete       (PAVISTREAM ps, LONG lStart, LONG lSamples); <br>HRESULT STDMETHODCALLTYPE AVIBallReadData     (PAVISTREAM ps, DWORD fcc, LPVOID lp,LONG *lpcb); <br>HRESULT STDMETHODCALLTYPE AVIBallWriteData    (PAVISTREAM ps, DWORD fcc, LPVOID lp,LONG cb); <br> <br>IAVIStreamVtbl AVIBallHandler = { <br>    AVIBallQueryInterface, <br>    AVIBallAddRef, <br>    AVIBallRelease, <br>    AVIBallCreate, <br>    AVIBallInfo, <br>    AVIBallFindSample, <br>    AVIBallReadFormat, <br>    AVIBallSetFormat, <br>    AVIBallRead, <br>    AVIBallWrite, <br>    AVIBallDelete, <br>    AVIBallReadData, <br>    AVIBallWriteData <br>}; <br> <br> <br>// <br>// This is the function an application would call to create a PAVISTREAM to <br>// reference the ball.  Then the standard AVIStream function calls can be <br>// used to work with this stream. <br>// <br>PAVISTREAM WINAPI NewBall(void) <br>{ <br>    PAVIBALL pball; <br> <br>    // <br>    // Create a pointer to our private structure which will act as our <br>    // PAVISTREAM <br>    // <br>    pball = (PAVIBALL) GlobalAllocPtr(GHND, sizeof(AVIBALL)); <br> <br>    if (!pball) <br>return 0; <br> <br>    // <br>    // Fill the function table <br>    // <br>    pball-&gt;lpvtbl = &amp;AVIBallHandler; <br> <br>    // <br>    // Call our own create code to create a new instance (calls AVIBallCreate) <br>    // For now, don't use any lParams. <br>    // <br>    pball-&gt;lpvtbl-&gt;Create((PAVISTREAM) pball, 0, 0); <br> <br>    return (PAVISTREAM) pball; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// This function is called to initialize an instance of the bouncing ball. <br>// <br>// When called, we look at the information possibly passed in &lt;lParam1&gt;, <br>// if any, and use it to determine the length of movie they want. (Not <br>// supported by NewBall right now, but it could be). <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>HRESULT STDMETHODCALLTYPE AVIBallCreate(PAVISTREAM ps, LONG lParam1, LONG lParam2) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br> <br>    // <br>    // what type of data are we? (audio/video/other stream) <br>    // <br>    pball-&gt;fccType = streamtypeVIDEO; <br> <br>    // <br>    // We define lParam1 as being the length of movie they want us to pretend <br>    // to be. <br>    // <br>    if (lParam1) <br>pball-&gt;length = (int) lParam1; <br>    else <br>pball-&gt;length = DEFAULT_LENGTH; <br> <br>    switch (pball-&gt;fccType) { <br> <br>case streamtypeVIDEO: <br>    pball-&gt;color  = DEFAULT_COLOR; <br>    pball-&gt;width  = DEFAULT_WIDTH; <br>    pball-&gt;height = DEFAULT_HEIGHT; <br>    pball-&gt;size   = DEFAULT_SIZE; <br>    pball-&gt;ulRefCount = 1;// note that we are opened once <br>    return AVIERR_OK;           // success <br> <br>case streamtypeAUDIO: <br>    return ResultFromScode(AVIERR_UNSUPPORTED); // we don't do audio <br> <br>default: <br>    return ResultFromScode(AVIERR_UNSUPPORTED); // or anything else <br>    } <br>} <br> <br> <br>// <br>// Increment our reference count <br>// <br>ULONG STDMETHODCALLTYPE AVIBallAddRef(PAVISTREAM ps) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br>    return (++pball-&gt;ulRefCount); <br>} <br> <br> <br>// <br>// Decrement our reference count <br>// <br>ULONG STDMETHODCALLTYPE AVIBallRelease(PAVISTREAM ps) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br>    if (--pball-&gt;ulRefCount) <br>return pball-&gt;ulRefCount; <br> <br>    // Free any data we're keeping around - like our private structure <br>    GlobalFreePtr(pball); <br> <br>    return 0; <br>} <br> <br> <br>// <br>// Fills an AVISTREAMINFO structure <br>// <br>HRESULT STDMETHODCALLTYPE AVIBallInfo(PAVISTREAM ps, AVISTREAMINFOW * psi, LONG lSize) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br> <br>    if (lSize &lt; sizeof(AVISTREAMINFO)) <br>return ResultFromScode(AVIERR_BUFFERTOOSMALL); <br> <br>    _fmemset(psi, 0, (int)lSize); <br> <br>    // Fill out a stream header with information about us. <br>    psi-&gt;fccType                = pball-&gt;fccType; <br>    psi-&gt;fccHandler             = mmioFOURCC('B','a','l','l'); <br>    psi-&gt;dwScale                = 1; <br>    psi-&gt;dwRate                 = 15; <br>    psi-&gt;dwLength               = pball-&gt;length; <br>    psi-&gt;dwSuggestedBufferSize  = pball-&gt;height * ALIGNULONG(pball-&gt;width); <br>    psi-&gt;rcFrame.right          = pball-&gt;width; <br>    psi-&gt;rcFrame.bottom         = pball-&gt;height; <br>    CopyMemory((PVOID)psi-&gt;szName, <br>               (PVOID)L"Bouncing ball video", <br>               sizeof(L"Bouncing ball video")); <br> <br>    return AVIERR_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// AVIBallReadFormat: needs to return the format of our data. <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>HRESULT STDMETHODCALLTYPE AVIBallReadFormat   (PAVISTREAM ps, LONG lPos,LPVOID lpFormat,LONG *lpcbFormat) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br>    LPBITMAPINFO    lpbi = (LPBITMAPINFO) lpFormat; <br> <br>    if (lpFormat == NULL || *lpcbFormat == 0) { <br>*lpcbFormat = sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD); <br>return AVIERR_OK; <br>    } <br> <br>    if (*lpcbFormat &lt; sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD)) <br>return ResultFromScode(AVIERR_BUFFERTOOSMALL); <br> <br>    // This is a relatively silly example: we build up our <br>    // format from scratch every time. <br> <br>    lpbi-&gt;bmiHeader.biSize              = sizeof(BITMAPINFOHEADER); <br>    lpbi-&gt;bmiHeader.biCompression       = BI_RGB; <br>    lpbi-&gt;bmiHeader.biWidth             = pball-&gt;width; <br>    lpbi-&gt;bmiHeader.biHeight            = pball-&gt;height; <br>    lpbi-&gt;bmiHeader.biBitCount          = 8; <br>    lpbi-&gt;bmiHeader.biPlanes            = 1; <br>    lpbi-&gt;bmiHeader.biClrUsed           = 2; <br>    lpbi-&gt;bmiHeader.biSizeImage         = pball-&gt;height * DIBWIDTHBYTES(lpbi-&gt;bmiHeader); <br> <br>    lpbi-&gt;bmiColors[0].rgbRed           = 0; <br>    lpbi-&gt;bmiColors[0].rgbGreen         = 0; <br>    lpbi-&gt;bmiColors[0].rgbBlue          = 0; <br>    lpbi-&gt;bmiColors[1].rgbRed           = GetRValue(pball-&gt;color); <br>    lpbi-&gt;bmiColors[1].rgbGreen         = GetGValue(pball-&gt;color); <br>    lpbi-&gt;bmiColors[1].rgbBlue          = GetBValue(pball-&gt;color); <br> <br>    *lpcbFormat = sizeof(BITMAPINFOHEADER) + 2 * sizeof(RGBQUAD); <br> <br>    return AVIERR_OK; <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// AVIBallRead: needs to return the data for a particular frame. <br>// <br>/////////////////////////////////////////////////////////////////////////// <br>HRESULT STDMETHODCALLTYPE AVIBallRead (PAVISTREAM ps, LONG lStart,LONG lSamples,LPVOID lpBuffer,LONG cbBuffer,LONG * plBytes,LONG * plSamples) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br>    LONG   lSize = pball-&gt;height * ALIGNULONG(pball-&gt;width); // size of frame <br>     // in bytes <br>    int x, y; <br>    HPSTR hp = lpBuffer; <br>    int xPos, yPos; <br> <br>    // Reject out of range values <br>    if (lStart &lt; 0 || lStart &gt;= pball-&gt;length) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>    // Did they just want to know the size of our data? <br>    if (lpBuffer == NULL || cbBuffer == 0) <br>goto exit; <br> <br>    // Will our frame fit in the buffer passed? <br>    if (lSize &gt; cbBuffer) <br>return ResultFromScode(AVIERR_BUFFERTOOSMALL); <br> <br>    // Figure out the position of the ball. <br>    // It just bounces back and forth. <br> <br>    xPos = 5 + XSPEED * (int) lStart;    // x = x0 + vt <br>    xPos = xPos % ((pball-&gt;width - pball-&gt;size) * 2);    // limit to 2xwidth <br>    if (xPos &gt; (pball-&gt;width - pball-&gt;size))    // reflect if <br>xPos = 2 * (pball-&gt;width - pball-&gt;size) - xPos;    //   needed <br> <br>    yPos = 5 + YSPEED * (int) lStart; <br>    yPos = yPos % ((pball-&gt;height - pball-&gt;size) * 2); <br>    if (yPos &gt; (pball-&gt;height - pball-&gt;size)) <br>yPos = 2 * (pball-&gt;height - pball-&gt;size) - yPos; <br> <br>    // <br>    // Build a DIB from scratch by writing in 1's where the ball is, 0's <br>    // where it isn't. <br>    // <br>    // Notice that we just build it in the buffer we've been passed. <br>    // <br>    // This is pretty ugly, I have to admit. <br>    // <br>    for (y = 0; y &lt; pball-&gt;height; y++) <br>{ <br>if (y &gt;= yPos &amp;&amp; y &lt; yPos + pball-&gt;size) <br>{ <br>    for (x = 0; x &lt; pball-&gt;width; x++) <br>    { <br>*hp++ = (BYTE) ((x &gt;= xPos &amp;&amp; x &lt; xPos + pball-&gt;size) ? 1 : 0); <br>    } <br>} <br>else <br>{ <br>    for (x = 0; x &lt; pball-&gt;width; x++) <br>    { <br>*hp++ = 0; <br>    } <br>} <br> <br>hp += pball-&gt;width - ALIGNULONG(pball-&gt;width); <br>    } <br> <br>exit: <br>    // We always return exactly one frame <br>    if (plSamples) <br>*plSamples = 1; <br> <br>    // Return the size of our frame <br>    if (plBytes) <br>*plBytes = lSize; <br> <br>    return AVIERR_OK; <br>} <br> <br> <br>HRESULT STDMETHODCALLTYPE AVIBallQueryInterface(PAVISTREAM ps, REFIID riid, LPVOID * ppvObj) <br>{ <br>    PAVIBALL pball = (PAVIBALL) ps; <br> <br>    // We support the Unknown interface (everybody does) and our Stream <br>    // interface. <br> <br>    if (_fmemcmp(riid, &amp;IID_IUnknown, sizeof(GUID)) == 0) <br>        *ppvObj = (LPVOID)pball; <br> <br>    else if (_fmemcmp(riid, &amp;IID_IAVIStream, sizeof(GUID)) == 0) <br>        *ppvObj = (LPVOID)pball; <br> <br>    else { <br>        *ppvObj = NULL; <br>        return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>    AVIBallAddRef(ps); <br> <br>    return AVIERR_OK; <br>} <br> <br>LONG    STDMETHODCALLTYPE AVIBallFindSample (PAVISTREAM ps, LONG lPos, LONG lFlags) <br>{ <br>    // The only format change is frame 0 <br>    if ((lFlags &amp; FIND_TYPE) == FIND_FORMAT) { <br>if ((lFlags &amp; FIND_DIR) == FIND_NEXT &amp;&amp; lPos &gt; 0) <br>    return -1;// no more format changes <br>else <br>    return 0; <br> <br>    // FIND_KEY and FIND_ANY always return the same position because <br>    // every frame is non-empty and a key frame <br>    } else <br>        return lPos; <br>} <br> <br>HRESULT STDMETHODCALLTYPE AVIBallReadData     (PAVISTREAM ps, DWORD fcc, LPVOID lp, LONG *lpcb) <br>{ <br>    return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE AVIBallSetFormat    (PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG cbFormat) <br>{ <br>    return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE AVIBallWriteData    (PAVISTREAM ps, DWORD fcc, LPVOID lp, LONG cb) <br>{ <br>    return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE AVIBallWrite        (PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, DWORD dwFlags, LONG *plSampWritten, LONG *plBytesWritten) <br>{ <br>    return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>HRESULT STDMETHODCALLTYPE AVIBallDelete       (PAVISTREAM ps, LONG lStart, LONG lSamples) <br>{ <br>    return ResultFromScode(AVIERR_UNSUPPORTED); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
