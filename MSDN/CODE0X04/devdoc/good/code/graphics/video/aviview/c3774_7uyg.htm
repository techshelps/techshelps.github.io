<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AVIVIEW.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3778"></a>AVIVIEW.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "muldiv32.h" <br> <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br>#include "aviview.h" <br>#include "audplay.h" <br>#include "aviball.h" <br> <br>#define GlobalSizePtr(lp)   GlobalSize(GlobalPtrHandle(lp)) <br> <br>#define FIXCC(fcc)  if (fcc == 0)       fcc = mmioFOURCC('N', 'o', 'n', 'e'); \ <br>                    if (fcc == BI_RLE8) fcc = mmioFOURCC('R', 'l', 'e', '8'); <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>typedef LONG (PASCAL *LPWNDPROC)(HWND, UINT, WPARAM, LPARAM); // pointer to a window procedure <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>static  TCHAR   gszAppName[]=TEXT("AVIView"); <br>static  TCHARgachFilter[512] = TEXT(""); <br> <br> <br>static  HANDLEghInstApp; <br>static  HWNDghwndApp; <br>static  HACCELghAccel; <br>static  HANDLE  ghLib;                 // Handle to palmap32.dll <br>static  BOOL    gbCanPalMap = FALSE;   // Is palmap32.dll available? <br> <br>#define SCROLLRANGE  10000 <br> <br>#define MAXNUMSTREAMS   50 <br>PAVIFILE    gpfile;// the current file <br>PAVISTREAM          gapavi[MAXNUMSTREAMS];// the current streams <br>PGETFRAME    gapgf[MAXNUMSTREAMS];// data for decompressing <br>// video <br>HDRAWDIB    ghdd[MAXNUMSTREAMS];// drawdib handles <br>int    gcpavi;// # of streams <br> <br>BOOL    gfPlaying = FALSE;// Are we playing right now? <br>LONG    glPlayStartTime;// When did we start playing? <br>LONG     glPlayStartPos;// From what position? <br> <br>PAVISTREAM          gpaviAudio;                 // 1st audio stream found <br>PAVISTREAM          gpaviVideo;                 // 1st video stream found <br>int                 giFirstVideo;                // index of gapavi for 1st Video stream <br> <br>#define             gfVideoFound (gpaviVideo != NULL) <br>#define             gfAudioFound (gpaviAudio != NULL) <br> <br>LONG                timeStart;// cached start, end, length <br>LONG                timeEnd; <br>LONG                timeLength; <br>LONG    timehscroll;                // how much arrows scroll HORZ bar <br>LONG    vertSBLen; <br>LONG    vertHeight; <br> <br> <br>DWORD    gdwMicroSecPerPixel = 1000L;// scale for video <br> <br>TCHAR               gachFileName[MAX_PATH] = TEXT(""); <br>TCHAR               gachSaveFileName[MAX_PATH] = TEXT(""); <br>UINT    gwZoom = 2;// one half zoom (divide by 4) <br>AVICOMPRESSOPTIONS  gaAVIOptions[MAXNUMSTREAMS]; <br>LPAVICOMPRESSOPTIONS  galpAVIOptions[MAXNUMSTREAMS]; <br> <br>HFONT               hfontApp; <br>TEXTMETRIC          tm; <br>BYTE    abFormat[1024]; <br>LPVOID    lpAudio;// buffer for painting <br>int                 gnColours;          // No of colours to remap palette to <br> <br>                // !!! constants for painting <br>#define VSPACE  8                // some vertical spacing <br>#define HSPACE  4               // space between frames for video streams <br>#define TSPACE  20                // space for text area about each stream <br>#define AUDIOVSPACE  64                // height of an audio stream at X1 zoom <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>#define GetScrollTime(hwnd) \ <br>    (LONG)(timeStart + muldiv32(GetScrollPos(hwnd, SB_HORZ), timeLength, SCROLLRANGE)) <br> <br>#define SetScrollTime(hwnd, time) SetScrollPos(hwnd, SB_HORZ, \ <br>    (int)muldiv32((time) - timeStart, SCROLLRANGE, timeLength), TRUE) <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br>long             PaintStuff(HDC hdc, HWND hwnd, BOOL fDrawEverything); <br>LONG WINAPI      AppWndProc (HWND hwnd, UINT uiMessage, WPARAM wParam, LPARAM lParam); <br>int              ErrMsg (LPTSTR sz,...); <br>LONG PASCAL      AppCommand(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK    AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK    GetNumberOfColorsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); <br>LONG             GetNumberOfColors(PAVISTREAM ps); <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>HCURSOR hcurSave; <br>int     fWait = 0; <br> <br>/*----------------------------------------------------------------------------*\ <br>|    StartWait() <br>| <br>|    Start a wait operation... put up the hourglass if it's the first call. <br>\*----------------------------------------------------------------------------*/ <br>void StartWait() <br>{ <br>    if (fWait++ == 0) { <br>        SetCursor(LoadCursor(NULL,IDC_WAIT)); <br>    } <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    EndWait() <br>| <br>|    Once every one who started a wait is finished, go back to regular cursor. <br>\*----------------------------------------------------------------------------*/ <br>void EndWait() <br>{ <br>    if (--fWait == 0) { <br>        SetCursor(LoadCursor(NULL,IDC_ARROW)); <br>        InvalidateRect(ghwndApp, NULL, TRUE); <br>    } <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    WinYield() <br>| <br>|    Code to yield while we're not calling GetMessage. <br>|    Dispatch all messages.  Pressing ESC or closing aborts. <br>\*----------------------------------------------------------------------------*/ <br>BOOL WinYield() <br>{ <br>    MSG msg; <br>    BOOL fAbort=FALSE; <br> <br>    while(fWait &gt; 0 &amp;&amp; PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE)) <br>    { <br>if (msg.message == WM_KEYDOWN &amp;&amp; msg.wParam == VK_ESCAPE) <br>            fAbort = TRUE; <br>if (msg.message == WM_SYSCOMMAND &amp;&amp; (msg.wParam &amp; 0xFFF0) == SC_CLOSE) <br>    fAbort = TRUE; <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>    } <br>    return fAbort; <br>} <br> <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FixScrollbars() <br>| <br>|    When we load a file or zoom changes, we re-set the scrollbars. <br>\*----------------------------------------------------------------------------*/ <br>void FixScrollbars(HWND hwnd) <br>{ <br>    LONG                lHeight = 0; <br>    RECT                rc; <br>    HDC                 hdc; <br> <br>    // <br>    // Pretend we're painting and count how many lines we needed <br>    // <br>    hdc = GetDC(NULL); <br>    ExcludeClipRect(hdc, 0, 0, 32767, 32767);   // don't actually draw <br>    lHeight = PaintStuff(hdc, hwnd, TRUE); <br>    ReleaseDC(NULL, hdc); <br> <br>    // <br>    // Set vertical scrollbar for scrolling the visible area <br>    // <br>    GetClientRect(hwnd, &amp;rc); <br>    vertHeight = lHeight;// total height in pixels of entire display <br> <br>    // <br>    // We won't fit in the window... need scrollbars <br>    // <br>    if (lHeight &gt; rc.bottom) { <br>vertSBLen = lHeight - rc.bottom; <br>SetScrollRange(hwnd, SB_VERT, 0, (int)vertSBLen, TRUE); <br>SetScrollPos(hwnd, SB_VERT, 0, TRUE); <br> <br>    // <br>    // We will fit in the window!  No scrollbars necessary <br>    // <br>    } else { <br>vertSBLen = 0; <br>SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>    } <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InitStreams() <br>| <br>|    Initialize the streams of a loaded file -- the compression options, the <br>|    DrawDIB handles, and the scroll bars. <br>\*----------------------------------------------------------------------------*/ <br>void InitStreams(HWND hwnd) <br>{ <br>    AVISTREAMINFO     avis; <br>    LONGlTemp; <br>    inti; <br>    DWORDdw; <br> <br>    // <br>    // Start with bogus times <br>    // <br>    timeStart = 0x7FFFFFFF; <br>    timeEnd   = 0; <br> <br>    // <br>    // Walk through and init all streams loaded <br>    // <br>    for (i = 0; i &lt; gcpavi; i++) { <br> <br>        AVIStreamInfo(gapavi[i], &amp;avis, sizeof(avis)); <br> <br>// <br>// Save and SaveOptions code takes a pointer to our compression opts <br>// <br>galpAVIOptions[i] = &amp;gaAVIOptions[i]; <br> <br>// <br>// clear options structure to zeroes <br>// <br>_fmemset(galpAVIOptions[i], 0, sizeof(AVICOMPRESSOPTIONS)); <br> <br>// <br> // Initialize the compression options to some default stuff <br>// !!! Pick something better <br>// <br>galpAVIOptions[i]-&gt;fccType = avis.fccType; <br> <br>switch(avis.fccType) { <br> <br>    case streamtypeVIDEO: <br>galpAVIOptions[i]-&gt;dwFlags = AVICOMPRESSF_VALID | <br>AVICOMPRESSF_KEYFRAMES | AVICOMPRESSF_DATARATE; <br>galpAVIOptions[i]-&gt;fccHandler = 0; <br>galpAVIOptions[i]-&gt;dwQuality = (DWORD)ICQUALITY_DEFAULT; <br>galpAVIOptions[i]-&gt;dwKeyFrameEvery = (DWORD)-1; // Default <br>galpAVIOptions[i]-&gt;dwBytesPerSecond = 0; <br>galpAVIOptions[i]-&gt;dwInterleaveEvery = 1; <br>break; <br> <br>    case streamtypeAUDIO: <br>galpAVIOptions[i]-&gt;dwFlags |= AVICOMPRESSF_VALID; <br>galpAVIOptions[i]-&gt;dwInterleaveEvery = 1; <br>                AVIStreamReadFormat(gapavi[i], AVIStreamStart(gapavi[i]), <br>                                    NULL, &amp;lTemp); <br>                galpAVIOptions[i]-&gt;cbFormat = lTemp; <br>                if (lTemp) <br>                    galpAVIOptions[i]-&gt;lpFormat = GlobalAllocPtr(GHND, lTemp); <br>                // Use current format as default format <br>                if (galpAVIOptions[i]-&gt;lpFormat) <br>                    AVIStreamReadFormat(gapavi[i], <br>                                    AVIStreamStart(gapavi[i]), <br>    galpAVIOptions[i]-&gt;lpFormat, <br>    &amp;lTemp); <br>break; <br> <br>    default: <br>break; <br>} <br> <br>// <br>// We're finding the earliest and latest start and end points for <br>// our scrollbar. <br>// <br>        timeStart = min(timeStart, AVIStreamStartTime(gapavi[i])); <br>        timeEnd   = max(timeEnd, AVIStreamEndTime(gapavi[i])); <br> <br>// <br>// Initialize video streams for getting decompressed frames to display <br>// <br>        if (avis.fccType == streamtypeVIDEO) { <br> <br>    gapgf[i] = AVIStreamGetFrameOpen(gapavi[i], NULL); <br>    if (gapgf[i] == NULL) <br>continue; <br> <br>    ghdd[i] = DrawDibOpen(); <br>    // !!! DrawDibBegin? <br> <br>    if (gpaviVideo == NULL) { <br> <br>// <br>// Remember the first video stream --- treat it specially <br>// <br>                gpaviVideo = gapavi[i]; <br>                giFirstVideo = i; <br> <br>                // <br>                // Set the horizontal scrollbar scale to show every frame <br>                // of the first video stream exactly once <br>                // <br>                dw = (avis.rcFrame.right - avis.rcFrame.left) * gwZoom / 4 + HSPACE; <br>                gdwMicroSecPerPixel = muldiv32(1000000, <br>                                               avis.dwScale, <br>                                               dw * avis.dwRate); <br> <br>                // Move one frame on the top video screen for each HSCROLL <br>                timehscroll = muldiv32(1000, avis.dwScale, avis.dwRate); <br>            } <br> <br>        } else if (avis.fccType == streamtypeAUDIO) { <br> <br>            // <br>            // If there are no video streams, we base everything on this <br>            // audio stream. <br>            // <br>            if (gpaviAudio == NULL &amp;&amp; gpaviVideo == NULL) { <br> <br>                // Show one sample per pixel <br>                gdwMicroSecPerPixel = muldiv32(1000000, <br>                                               avis.dwScale, <br>                                               avis.dwRate); <br>                // Move one sample per HSCROLL <br>                // Move at least enough to show movement <br>                timehscroll = muldiv32(1000, avis.dwScale, avis.dwRate); <br>            } <br> <br>    // <br>    // Remember the first audio stream --- treat it specially <br>    // <br>    if (gpaviAudio == NULL) <br>        gpaviAudio = gapavi[i]; <br> <br>} <br> <br>    } <br> <br>    timeLength = timeEnd - timeStart; <br> <br>    if (timeLength == 0) <br>        timeLength = 1; <br> <br>    // Make sure HSCROLL scrolls enough to be noticeable. <br>    timehscroll = max(timehscroll, timeLength / SCROLLRANGE + 2); <br> <br>    SetScrollRange(hwnd, SB_HORZ, 0, SCROLLRANGE, TRUE); <br>    SetScrollTime(hwnd, timeStart); <br> <br>    FixScrollbars(hwnd); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FixWindowTitle() <br>| <br>|    Update the window title to reflect what's loaded. <br>\*----------------------------------------------------------------------------*/ <br>void FixWindowTitle(HWND hwnd) <br>{ <br>    TCHAR ach[80]; <br> <br>    wsprintf(ach, TEXT("%s %s"), <br>            (LPTSTR)gszAppName, <br>            (LPTSTR)gachFileName); <br> <br>    SetWindowText(hwnd, ach); <br> <br>    InvalidateRect(hwnd, NULL, TRUE); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FreeDrawStuff() <br>| <br>| Free up the resources associated with DrawDIB <br>\*----------------------------------------------------------------------------*/ <br>void FreeDrawStuff(HWND hwnd) <br>{ <br>    inti; <br> <br>    aviaudioStop(); <br> <br>    for (i = 0; i &lt; gcpavi; i++) { <br>if (gapgf[i]) { <br>    AVIStreamGetFrameClose(gapgf[i]); <br>    gapgf[i] = NULL; <br>} <br>if (ghdd[i]) { <br>    DrawDibClose(ghdd[i]); <br>    ghdd[i] = 0; <br>} <br>    } <br>    SetScrollRange(hwnd, SB_HORZ, 0, 0, TRUE); <br>    gpaviVideo = gpaviAudio = NULL; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    FreeAvi() <br>| <br>|    Free the resources associated with an open file. <br>\*----------------------------------------------------------------------------*/ <br>void FreeAvi(HWND hwnd) <br>{ <br>    inti; <br> <br>    FreeDrawStuff(hwnd); <br> <br>    AVISaveOptionsFree(gcpavi, galpAVIOptions); <br> <br>    for (i = 0; i &lt; gcpavi; i++) { <br>AVIStreamRelease(gapavi[i]); <br>    } <br> <br>    if (gpfile) <br>AVIFileRelease(gpfile); <br> <br>    gpfile = NULL; <br> <br>    // Good a place as any to make sure audio data gets freed <br>    if (lpAudio) <br>        GlobalFreePtr(lpAudio); <br>    lpAudio = NULL; <br> <br>    gcpavi = 0; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InitBall() <br>| <br>|    Open up our fake "ball" file as an installible stream hander <br>\*----------------------------------------------------------------------------*/ <br>void InitBall(HWND hwnd) <br>{ <br>    // close everything down <br>    FreeAvi(hwnd); <br> <br>    // The NewBall() function creates a PAVISTREAM we can use as if it was <br>    // an AVI file. <br>    gapavi[0] = NewBall(); <br> <br>    if (gapavi[0]) <br>gcpavi = 1; <br> <br>    lstrcpy(gachFileName, TEXT("BALL")); <br>    InitStreams(hwnd); <br>    FixWindowTitle(hwnd); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InsertAVIFile() <br>| <br>|    Does most of the work of opening an AVI file. <br>\*----------------------------------------------------------------------------*/ <br>void InsertAVIFile(PAVIFILE pfile, HWND hwnd, LPTSTR lpszFile) <br>{ <br>    inti; <br>    PAVISTREAMpavi; <br> <br>    // <br>    // Get all the streams from the new file <br>    // <br>    for (i = gcpavi; i &lt;= MAXNUMSTREAMS; i++) { <br>if (AVIFileGetStream(pfile, &amp;pavi, 0L, i - gcpavi) != AVIERR_OK) <br>    break; <br>        if (i == MAXNUMSTREAMS) { <br>            AVIStreamRelease(pavi); <br>            ErrMsg("Exceeded maximum number of streams"); <br>            break; <br>        } <br>gapavi[i] = pavi; <br>    } <br> <br>    // <br>    // Couldn't get any streams out of this file <br>    // <br>    if (gcpavi == i &amp;&amp; i != MAXNUMSTREAMS) <br>    { <br>        ErrMsg(TEXT("Unable to open %s"), lpszFile); <br>if (pfile) <br>    AVIFileRelease(pfile); <br>return; <br>    } <br> <br>    gcpavi = i; <br> <br>    if (gpfile) { <br>AVIFileRelease(pfile); <br>    } else <br>gpfile = pfile; <br> <br>    FreeDrawStuff(hwnd); <br>    InitStreams(hwnd); <br>    FixWindowTitle(hwnd); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    InitAvi() <br>| <br>|    Open up a file through the AVIFile handlers. <br>\*----------------------------------------------------------------------------*/ <br>void InitAvi(HWND hwnd, LPTSTR szFile, UINT wMenu) <br>{ <br>    HRESULThr; <br>    PAVIFILEpfile; <br> <br>    hr = AVIFileOpen(&amp;pfile, szFile, 0, 0L); <br> <br>    if (hr != 0) <br>    { <br>        ErrMsg(TEXT("Unable to open %s"), szFile); <br>        return; <br>    } <br> <br>    if (wMenu == MENU_OPEN) <br>FreeAvi(hwnd); <br> <br>    InsertAVIFile(pfile, hwnd, szFile); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppInit( hInst, hPrev)       | <br>|       | <br>|   Description:       | <br>|This is called when the application is first loaded into       | <br>|memory.  It performs all initialization that doesn't need to be done   | <br>|once per instance.       | <br>|       | <br>|   Arguments:       | <br>|hInstanceinstance handle of current instance       | <br>|hPrevinstance handle of previous instance       | <br>|       | <br>|   Returns:       | <br>|TRUE if successful, FALSE if not       | <br>|       | <br>\*----------------------------------------------------------------------------*/ <br>BOOL AppInit(HINSTANCE hInst, HINSTANCE hPrev, int sw,LPSTR szCmdLine) <br>{ <br>    WNDCLASScls; <br>    HDChdc; <br> <br>#ifdef BIDI <br>    const DWORD  dwExStyle = WS_EX_BIDI_SCROLL  | WS_EX_BIDI_MENU |WS_EX_BIDI_NOICON; <br>#else <br>    const DWORD  dwExStyle = 0; <br>#endif <br> <br>    /* Save instance handle for DialogBoxs */ <br>    ghInstApp = hInst; <br> <br>    ghAccel = LoadAccelerators(hInst, MAKEINTATOM(ID_APP)); <br> <br>    if (szCmdLine &amp;&amp; szCmdLine[0]) { <br>#ifdef UNICODE <br>// convert to unicode <br>lstrcpy(gachFileName, GetCommandLine()); <br>#else <br>    lstrcpy(gachFileName, szCmdLine); <br>#endif <br>    } <br> <br>    if (!hPrev) { <br>/* <br> *  Register a class for the main application window <br> */ <br>        cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>        cls.hIcon          = LoadIcon(hInst,MAKEINTATOM(ID_APP)); <br>        cls.lpszMenuName   = MAKEINTATOM(ID_APP); <br>        cls.lpszClassName  = MAKEINTATOM(ID_APP); <br>        cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        cls.hInstance      = hInst; <br>        cls.style          = CS_BYTEALIGNCLIENT | CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>        cls.lpfnWndProc    = (LPWNDPROC)AppWndProc; <br>        cls.cbWndExtra     = 0; <br>        cls.cbClsExtra     = 0; <br> <br>        if (!RegisterClass(&amp;cls)) <br>    return FALSE; <br>    } <br> <br>    // <br>    // Must be called before using any of the AVIFile routines <br>    // <br>    AVIFileInit(); <br> <br>    hfontApp = GetStockObject(ANSI_VAR_FONT); <br>    hdc = GetDC(NULL); <br>    SelectObject(hdc, hfontApp); <br>    GetTextMetrics(hdc, &amp;tm); <br>    ReleaseDC(NULL, hdc); <br> <br>    ghwndApp=CreateWindowEx(dwExStyle, <br>    MAKEINTATOM(ID_APP),    // Class name <br>                            gszAppName,             // Caption <br>                            WS_OVERLAPPEDWINDOW,    // Style bits <br>                            CW_USEDEFAULT, 0,       // Position <br>                            320,300,                // Size <br>                            (HWND)NULL,             // Parent window (no parent) <br>                            (HMENU)NULL,            // use class menu <br>                            (HANDLE)hInst,          // handle to window instance <br>                            (LPSTR)NULL             // no params to pass on <br>                           ); <br>    ShowWindow(ghwndApp,sw); <br> <br>    ghLib = LoadLibrary(TEXT("palmap32.dll")); <br>    if (ghLib == NULL) <br>        gbCanPalMap = FALSE; <br>    else <br>        gbCanPalMap = TRUE; <br> <br>    return TRUE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   WinMain( hInst, hPrev, lpszCmdLine, cmdShow )       | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The main procedure for the App.  After initializing, it just goes      | <br>|       into a message-processing loop until it gets a WM_QUIT message         | <br>|       (meaning the app was closed).                                          | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|hInstinstance handle of this instance of the app       | <br>|hPrevinstance handle of previous instance, NULL if first    | <br>|       szCmdLine       -&gt;null-terminated command line                         | <br>|       cmdShow         specifies how the window is initially displayed        | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       The exit code as specified in the WM_QUIT message.                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int sw) <br>{ <br>    MSG     msg; <br> <br>    /* Call initialization procedure */ <br>    if (!AppInit(hInst,hPrev,sw,szCmdLine)) <br>        return FALSE; <br> <br>    /* <br>     * Polling messages from event queue <br>     */ <br>    for (;;) <br>    { <br>        while (PeekMessage(&amp;msg, NULL, 0, 0,PM_REMOVE)) <br>        { <br>            if (msg.message == WM_QUIT) <br>                return msg.wParam; <br> <br>    if (TranslateAccelerator(ghwndApp, ghAccel, &amp;msg)) <br>continue; <br> <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br> <br>// <br>// If we have no messages to dispatch, we do our background task... <br>// If we're playing a file, we set the scroll bar to show the video <br>// frames corresponding with the current playing audio sample <br>// <br>        if (gfPlaying) { <br>    LONG    l; <br> <br>    // <br>    // Use the audio clock to tell how long we've been playing.  To <br>    // maintain sync, it's important we use this clock. <br>    // <br>    l = aviaudioTime(); // returns -1 if no audio playing <br> <br>    // <br>    // If we can't use the audio clock to tell us how long we've been <br>    // playing, calculate it ourself <br>    // <br>    if (l == -1) <br>l = timeGetTime() - glPlayStartTime + glPlayStartPos; <br> <br>    if (l != GetScrollTime(ghwndApp)) { <br>        if (l &lt; timeStart)// make sure number isn't out of bounds <br>    l = timeStart; <br>        if (l &gt; timeEnd)// looks like we're all done! <br>                    FORWARD_WM_COMMAND(ghwndApp, MENU_STOP, NULL, 0, SendMessage); <br> <br>SetScrollTime(ghwndApp, l); <br>InvalidateRect(ghwndApp, NULL, FALSE); <br>UpdateWindow(ghwndApp); <br>continue; <br>    } <br>} <br> <br>WaitMessage(); <br>    } <br> <br>    // not reached <br>    return msg.wParam; <br>} <br> <br>typedef BYTE * HPBYTE; <br>typedef UNALIGNED short * HPSHORT; <br> <br>/*----------------------------------------------------------------------------*\ <br>|    PaintVideo() <br>| <br>|    Draw a video frame in the specified rect. <br>\*----------------------------------------------------------------------------*/ <br>void PaintVideo(HDC hdc, RECT rcFrame, int iStream, LPBITMAPINFOHEADER lpbi, LONG lCurFrame, LONG lPos) <br>{ <br>    intiLen; <br>    charach[200]; <br>    RECTrc; <br>    COLORREFnCol; <br> <br>    // <br>    // If we have a picture, draw it <br>    // <br>    if (lpbi) <br>    { <br>        // <br>        // use the palette of the first video stream <br>        // <br>        DrawDibDraw(ghdd[iStream],hdc, <br>    rcFrame.left, rcFrame.top, <br>    rcFrame.right - rcFrame.left, <br>    rcFrame.bottom - rcFrame.top, <br>    lpbi, NULL, <br>    0, 0, -1, -1, <br>    gapavi[iStream] == gpaviVideo ? 0 : DDF_BACKGROUNDPAL); <br> <br>        iLen = wsprintf(ach, TEXT("%ld %ld.%03lds"), <br>    lCurFrame, lPos/1000, lPos%1000); <br>    } <br> <br>    // <br>    // Before or after the movie (or read error) draw GRAY <br>    // <br>    else { <br>        if (gapgf[iStream]) <br>    SelectObject(hdc,GetStockObject(DKGRAY_BRUSH)); <br>        else <br>    SelectObject(hdc,GetStockObject(LTGRAY_BRUSH)); <br> <br>        PatBlt(hdc, <br>    rcFrame.left, rcFrame.top, <br>    rcFrame.right - rcFrame.left, <br>    rcFrame.bottom - rcFrame.top, <br>    PATCOPY); <br>        iLen = 0; <br>        ach[0] = TEXT('\0'); <br>    } <br> <br>    // <br>    // print something meaningful under the frame <br>    // <br>    rc.left = rcFrame.left; <br>    rc.right = rcFrame.right + HSPACE; <br>    rc.top = rcFrame.bottom + VSPACE; <br>    rc.bottom = rc.top + TSPACE; <br>    nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>    ExtTextOut(hdc, rc.left, rc.top, ETO_OPAQUE, <br>       &amp;rc, ach, iLen, NULL); <br>    SetBkColor(hdc, nCol); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    PaintAudio() <br>| <br>|    Draw some samples of audio inside the given rectangle. <br>\*----------------------------------------------------------------------------*/ <br>void PaintAudio(HDC hdc, PRECT prc, PAVISTREAM pavi, LONG lStart, LONG lLen) <br>{ <br>    PCMWAVEFORMAT wf; <br>    int i; <br>    int x,y; <br>    int w,h; <br>    BYTE b; <br>    HBRUSH hbr; <br>    RECT rc = *prc; <br>    LONG    lBytes; <br>    LONG    l, lLenOrig = lLen; <br>    LONG    lWaveBeginTime = AVIStreamStartTime(pavi); <br>    LONG    lWaveEndTime   = AVIStreamEndTime(pavi); <br> <br>    // <br>    // We can't draw before the beginning of the stream - adjust <br>    // <br>    if (lStart &lt; lWaveBeginTime) { <br>lLen -= lWaveBeginTime - lStart; <br>lStart = lWaveBeginTime; <br>// right justify the legal samples in the rectange - don't stretch <br>rc.left = rc.right - (int)muldiv32(rc.right - rc.left, lLen, lLenOrig); <br>    } <br> <br>    // <br>    // We can't draw past the end of the stream <br>    // <br>    if (lStart + lLen &gt; lWaveEndTime) { <br>lLenOrig = lLen; <br>lLen = max(0, lWaveEndTime - lStart);// maybe nothing to draw! <br>// left justify the legal samples in the rectange - don't stretch <br>rc.right = rc.left + (int)muldiv32(rc.right - rc.left, lLen, lLenOrig); <br>    } <br> <br>    // Now change and work with samples, not time. <br>    l = lStart; <br>    lStart = AVIStreamTimeToSample(pavi, lStart); <br>    lLen = AVIStreamTimeToSample(pavi, l + lLen) - lStart; <br> <br>    // <br>    // Get the format of the wave data <br>    // <br>    l = sizeof(wf); <br>    AVIStreamReadFormat(pavi, lStart, &amp;wf, &amp;l); <br>    if (!l) <br>        return; <br> <br>    w = rc.right - rc.left; <br>    h = rc.bottom - rc.top; <br> <br>    // <br>    // We were starting before the beginning or continuing past the end. <br>    // We're not painting in the whole original rect --- use a dark background <br>    // <br>    if (rc.left &gt; prc-&gt;left) { <br>        SelectObject(hdc, GetStockObject(DKGRAY_BRUSH)); <br> PatBlt(hdc, prc-&gt;left, rc.top, rc.left - prc-&gt;left, <br>    rc.bottom - rc.top, PATCOPY); <br>    } <br> <br>    if (rc.right &lt; prc-&gt;right) { <br>        SelectObject(hdc, GetStockObject(DKGRAY_BRUSH)); <br> PatBlt(hdc, rc.right, rc.top, prc-&gt;right - rc.right, <br>    rc.bottom - rc.top, PATCOPY); <br>    } <br> <br>#define BACKBRUSH  (GetSysColor(COLOR_BTNFACE)) <br>#define MONOBRUSH  (GetSysColor(COLOR_BTNSHADOW)) <br>#define LEFTBRUSH  (RGB(0,0,255)) <br>#define RIGHTBRUSH (RGB(0,255,0)) <br>#define HPOSBRUSH  (RGB(255,0,0)) <br> <br>    // <br>    // Paint the background <br>    // <br>    hbr = SelectObject(hdc, CreateSolidBrush(BACKBRUSH)); <br>    PatBlt(hdc, rc.left, rc.top, w, h, PATCOPY); <br>    DeleteObject(SelectObject(hdc, hbr)); <br> <br>    // <br>    // !!! we can only paint PCM data right now.  Sorry! <br>    // <br>    if (wf.wf.wFormatTag != WAVE_FORMAT_PCM) <br>        return; <br> <br>    // <br>    // How many bytes are we painting? Alloc some space for them <br>    // <br>    lBytes = lLen * wf.wf.nChannels * wf.wBitsPerSample / 8; <br>    if (!lpAudio) <br>        lpAudio = GlobalAllocPtr (GHND, lBytes); <br>    else if ((LONG)GlobalSizePtr(lpAudio) &lt; lBytes) <br>        lpAudio = GlobalReAllocPtr(lpAudio, lBytes, GMEM_MOVEABLE); <br> <br>    if (!lpAudio) <br>        return; <br> <br>    // <br>    // Read in the wave data <br>    // <br>    AVIStreamRead(pavi, lStart, lLen, lpAudio, lBytes, NULL, &amp;l); <br> <br>    if (l != lLen) <br>return; <br> <br>    // <br>    // !!! Flickers less painting it NOW or LATER? <br>    // First show the current position as a bar <br>    // <br>    hbr = SelectObject(hdc, CreateSolidBrush(HPOSBRUSH)); <br>    PatBlt(hdc, prc-&gt;right / 2, prc-&gt;top, 1, prc-&gt;bottom - prc-&gt;top, PATCOPY); <br>    DeleteObject(SelectObject(hdc, hbr)); <br> <br>    // <br>    // Paint monochrome wave data <br>    // <br>    if (wf.wf.nChannels == 1) { <br> <br>// <br>// Draw the x-axis <br>// <br>        hbr = SelectObject(hdc, CreateSolidBrush(MONOBRUSH)); <br>        y = rc.top + h/2; <br>        PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>// <br>// 8 bit data is centred around 0x80 <br>// <br>        if (wf.wBitsPerSample == 8) { <br>            for (x=0; x&lt;w; x++) { <br> <br>// which byte of audio data belongs at this pixel? <br>                b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w)); <br> <br>                if (b &gt; 0x80) { <br>                    i = y - (int)muldiv32(b-0x80,(h/2),128); <br>                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>                } </code></pre>
<p>
</p>
<pre><code>else { <br>                    i = y + (int)muldiv32(0x80-b,(h/2),128); <br>                    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY); <br>                } <br>            } <br>        } <br> <br>// <br>// 16 bit data is centred around 0x00 <br>// <br>        else if (wf.wBitsPerSample == 16) { <br>            for (x=0; x&lt;w; x++) { <br> <br>// Don't make any assumptions about INT size ! <br>// which byte of audio data belongs at this pixel? <br>                i = *((HPSHORT)lpAudio + muldiv32(x,lLen,w)); <br>                if (i &gt; 0) { <br>                   i = y - (int) ((LONG)i * (h/2) / 32768); <br>                   PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>                } <br>                else { <br>                   i = (int) ((LONG)i * (h/2) / 32768); <br>                   PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY); <br>                } <br>            } <br>        } <br>        DeleteObject(SelectObject(hdc, hbr)); <br>    } // endif mono <br> <br>    // <br>    // Draw stereo waveform data <br>    // <br>    else if (wf.wf.nChannels == 2) { <br> <br>// <br>// 8 bit data is centred around 0x80 <br>// <br>        if (wf.wBitsPerSample == 8) { <br> <br>            // Left channel <br>            hbr = SelectObject(hdc, CreateSolidBrush(LEFTBRUSH)); <br>            y = rc.top + h/4; <br>            PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>            for (x=0; x&lt;w; x++) { <br>                b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w) * 2); <br> <br>                if (b &gt; 0x80) { <br>                    i = y - (int)muldiv32(b-0x80,(h/4),128); <br>                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>                } <br>                else { <br>                    i = y + (int)muldiv32(0x80-b,(h/4),128); <br>                    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY); <br>                } <br>            } <br>            DeleteObject(SelectObject(hdc, hbr)); <br> <br>            // Right channel <br>            hbr = SelectObject(hdc, CreateSolidBrush(RIGHTBRUSH)); <br>            y = rc.top + h * 3 / 4; <br>            PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>            for (x=0; x&lt;w; x++) { <br>                b = *((HPBYTE)lpAudio + muldiv32(x,lLen,w) * 2 + 1); <br> <br>                if (b &gt; 0x80) { <br>                    i = y - (int)muldiv32(b-0x80,(h/4),128); <br>                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>                } <br>                else { <br>                    i = y + (int)muldiv32(0x80-b,(h/4),128); <br>                    PatBlt(hdc, rc.left+x, y, 1, i-y, PATCOPY); <br>                } <br>            } <br>            DeleteObject(SelectObject(hdc, hbr)); <br>        } <br> <br>// <br>// 16 bit data is centred around 0x00 <br>// <br>        else if (wf.wBitsPerSample == 16) { <br> <br>            // Left channel <br>            hbr = SelectObject(hdc, CreateSolidBrush(LEFTBRUSH)); <br>            y = rc.top + h/4; <br>            PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>            for (x=0; x&lt;w; x++) { <br>// Don't make any assumptions about INT size ! <br>                i = *((HPSHORT)lpAudio + muldiv32(x,lLen,w) * 2); <br>                if (i &gt; 0) { <br>                    i = y - (int) ((LONG)i * (h/4) / 32768); <br>                    PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>                } <br>                else { <br>                    i = (int) ((LONG)i * (h/4) / 32768); <br>                    PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY); <br>                } <br>            } <br>            DeleteObject(SelectObject(hdc, hbr)); <br> <br>            // Right channel <br>            hbr = SelectObject(hdc, CreateSolidBrush(RIGHTBRUSH)); <br>            y = rc.top + h * 3 / 4; <br>            PatBlt(hdc, rc.left, y, w, 1, PATCOPY); <br> <br>            for (x=0; x&lt;w; x++) { <br>// Don't make any assumptions about INT size ! <br>                i = *((HPSHORT)lpAudio + muldiv32(x,lLen,w) * 2 + 1); <br>                if (i &gt; 0) { <br>                   i = y - (int) ((LONG)i * (h/4) / 32768); <br>                   PatBlt(hdc, rc.left+x, i, 1, y-i, PATCOPY); <br>                } <br>                else { <br>                   i = (int) ((LONG)i * (h/4) / 32768); <br>                   PatBlt(hdc, rc.left+x, y, 1, -i, PATCOPY); <br>                } <br>            } <br>            DeleteObject(SelectObject(hdc, hbr)); <br>        } <br>    } // endif stereo <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    PaintStuff() <br>| <br>|    Paint the screen with what we plan to show them. <br>\*----------------------------------------------------------------------------*/ <br>long PaintStuff(HDC hdc, HWND hwnd, BOOL fDrawEverything) <br>{ <br>    int         yStreamTop; <br>    TCHAR       ach[400]; <br>    int         iFrameWidth, iLen; <br>    int         n; <br>    int         nFrames; <br>    LPBITMAPINFOHEADER lpbi; <br>    LONG        lTime; <br>    LONG        lSize = 0; <br>    LONG        lAudioStart; <br>    LONG        lAudioLen; <br>    RECT        rcFrame, rcC; <br>    int         i; <br>    LONG        lFrame; <br>    LONG        lCurFrame; <br>    HBRUSH      hbr; <br>    RECT        rc; <br>    COLORREFnCol; <br> <br>    SelectObject(hdc, hfontApp); <br> <br>    #define PRINT(sz) \ <br>        (nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)), \ <br>TextOut(hdc, TSPACE, yStreamTop, sz, lstrlen(sz)), \ <br>        SetBkColor(hdc, nCol),   \ <br>yStreamTop += tm.tmHeight+1) <br> <br>    #define PF1(sz,a)                   (wsprintf(ach, sz, a), PRINT(ach)) <br>    #define PF2(sz,a,b)                 (wsprintf(ach, sz, a, b), PRINT(ach)) <br>    #define PF3(sz,a,b,c)               (wsprintf(ach, sz, a, b, c), PRINT(ach)) <br>    #define PF4(sz,a,b,c,d)             (wsprintf(ach, sz, a, b, c, d), PRINT(ach)) <br>    #define PF5(sz,a,b,c,d,e)           (wsprintf(ach, sz, a, b, c, d, e), PRINT(ach)) <br>    #define PF6(sz,a,b,c,d,e,f)         (wsprintf(ach, sz, a, b, c, d, e, f), PRINT(ach)) <br>    #define PF7(sz,a,b,c,d,e,f,g)       (wsprintf(ach, sz, a, b, c, d, e, f, g), PRINT(ach)) <br>    #define PF8(sz,a,b,c,d,e,f,g,h)     (wsprintf(ach, sz, a, b, c, d, e, f, g, h), PRINT(ach)) <br>    #define PF9(sz,a,b,c,d,e,f,g,h,i)   (wsprintf(ach, sz, a, b, c, d, e, f, g, h, i), PRINT(ach)) <br> <br>    GetClientRect(hwnd, &amp;rcC); <br> <br>    // <br>    // Look at scrollbars to find current position <br>    // <br>    lTime = GetScrollTime(hwnd); <br>    yStreamTop = -GetScrollPos(hwnd, SB_VERT); <br> <br>    // <br>    // Walk through all streams and draw something <br>    // <br>    for (i=0; i&lt;gcpavi; i++) { <br>AVISTREAMINFOavis; <br>LONGlEnd, lEndTime, lNextFmt, lPrevFmt, l; <br>LONGlPos, lNextKey, lPrevKey, lNextAny, lPrevAny; <br> <br>AVIStreamInfo(gapavi[i], &amp;avis, sizeof(avis)); <br>FIXCC(avis.fccHandler); <br>FIXCC(avis.fccType); <br> <br>l = sizeof(abFormat); <br>AVIStreamReadFormat(gapavi[i],0, &amp;abFormat, &amp;l); <br> <br>PF7(TEXT("Stream%d [%4.4hs/%4.4hs] Start: %ld Length: %ld (%ld.%03ld sec)             "), <br>    i, <br>    (LPSTR)&amp;avis.fccType, <br>    (LPSTR)&amp;avis.fccHandler, <br>    AVIStreamStart(gapavi[i]), <br>    AVIStreamLength(gapavi[i]), <br>    AVIStreamLengthTime(gapavi[i]) / 1000, <br>    AVIStreamLengthTime(gapavi[i]) % 1000); <br> <br>lPos = AVIStreamTimeToSample(gapavi[i], lTime); <br>AVIStreamSampleSize(gapavi[i], lPos, &amp;lSize); <br> <br>lPrevKey = AVIStreamFindSample(gapavi[i], lPos, FIND_PREV|FIND_KEY); <br>lPrevAny = AVIStreamFindSample(gapavi[i], lPos, FIND_PREV|FIND_ANY); <br>lPrevFmt = AVIStreamFindSample(gapavi[i], lPos, FIND_PREV|FIND_FORMAT); <br> <br>lNextKey = AVIStreamFindSample(gapavi[i], lPos, FIND_NEXT|FIND_KEY); <br>lNextAny = AVIStreamFindSample(gapavi[i], lPos, FIND_NEXT|FIND_ANY); <br>lNextFmt = AVIStreamFindSample(gapavi[i], lPos, FIND_NEXT|FIND_FORMAT); <br> <br>PF5(TEXT("Pos:%ld Time:%ld.%03ld sec Size:%ld bytes %s                                 "), <br>lPos, lTime/1000, lTime%1000, lSize, <br>(LPTSTR)(lPos == lPrevKey ? TEXT("Key") : TEXT(""))); <br> <br>PF6(TEXT("PrevKey=%ld NextKey=%ld, PrevAny=%ld NextAny=%ld, PrevFmt=%ld NextFmt=%ld                      "), <br>    lPrevKey, lNextKey, <br>    lPrevAny, lNextAny, <br>    lPrevFmt, lNextFmt); <br> <br>// <br>// Draw a VIDEO stream <br>// <br>if (avis.fccType == streamtypeVIDEO) { <br>    if (gapgf[i] == NULL) <br>continue; <br> <br>    lpbi = (LPBITMAPINFOHEADER)abFormat; <br>    FIXCC(lpbi-&gt;biCompression); <br> <br>    // <br>    // display video format <br>    // <br>    //  Video: 160x120x8 (cram) <br>    // <br>    PF4(TEXT("Format: %dx%dx%d (%4.4hs)"), <br>(int)lpbi-&gt;biWidth, <br>(int)lpbi-&gt;biHeight, <br>(int)lpbi-&gt;biBitCount, <br>(LPSTR)&amp;lpbi-&gt;biCompression); <br> <br>            // <br>    // Which frame belongs at this time? <br>    // <br>    lEndTime = AVIStreamEndTime(gapavi[i]); <br>    if (lTime &lt;= lEndTime) <br>lFrame = AVIStreamTimeToSample(gapavi[i], lTime); <br>    else {// we've scrolled past the end of this stream <br>lEnd = AVIStreamEnd(gapavi[i]); <br>lFrame = lEnd + AVIStreamTimeToSample( <br>gapavi[i], lTime - lEndTime); <br>    } <br> <br>    // <br>    // how wide is each frame to paint? <br>    // <br>    iFrameWidth = (avis.rcFrame.right - avis.rcFrame.left) * <br>gwZoom / 4 + HSPACE; <br> <br>    // <br>    // how many frames can we fit on each half of the screen? <br>    // <br>    nFrames = (rcC.right - iFrameWidth) / (2 * iFrameWidth); <br>    if (nFrames &lt; 0) <br>nFrames = 0;    // at least draw *something* <br> <br>    // <br>    // Step through all the frames we'll draw <br>    // <br>    for (n=-nFrames; n&lt;=nFrames; n++) <br>    { <br> <br>                // <br>                // Each video stream is drawn as a horizontal line of <br>                // frames, very close together. <br>                // The first video stream shows a different frame in <br>                // each square. Thus the scale of time is determined <br>                // by the first video stream. <br>                // Every other video stream shows whatever <br>                // frame belongs at the time corresponding to the mid- <br>                // point of each square. <br>                // <br>if (gapavi[i] == gpaviVideo) { <br> <br>                    // <br>                    // by definition, we know what frame we're drawing.. <br>                    // (lFrame-n), (lFrame-(n-1)), ..., (lFrame), ..., <br>                    // (lFrame+(n-1)), (lFrame+n) <br>                    // <br>    lCurFrame = lFrame + n; <br> <br>    // <br>    // what time is it at that frame?  This number will be <br>    // printed underneath the frame <br>    // <br>    l = AVIStreamSampleToTime(gapavi[i], lCurFrame); <br> <br>} else {// NOT the first video stream <br> <br>    // <br>    // What time is it at the left edge of the square <br>    // we'll draw?  That's what frame we use. <br>    // <br>                    if (n&lt;0) { <br>                        l = lTime - muldiv32(-n * iFrameWidth + HSPACE, <br>gdwMicroSecPerPixel, 1000); <br>                    } <br>                    else { <br>        l = lTime + muldiv32(n * iFrameWidth, <br>gdwMicroSecPerPixel, 1000); <br>                    } <br> <br>                    // <br>    // What frame belongs to that time? <br>    // <br>    lCurFrame = AVIStreamTimeToSample(gapavi[i], l); <br> <br>                    // <br>                    // what time is it at that frame? This number will <br>                    // be printed underneath the frame <br>                    // <br>                    l = AVIStreamSampleToTime(gapavi[i], lCurFrame); <br>} <br> <br>// !!! <br>// Could actually return an LPBI for invalid frames <br>// so we better force it to NULL. <br>// <br>if (gapgf[i] &amp;&amp; lCurFrame &gt;= AVIStreamStart(gapavi[i])) <br>    lpbi = AVIStreamGetFrame(gapgf[i], lCurFrame); <br>else <br>    lpbi = NULL; <br> <br>// <br>// Figure out where to draw this frame <br>// <br>rcFrame.left   = rcC.right / 2 - <br>    ((avis.rcFrame.right - avis.rcFrame.left) * gwZoom / 4) <br>    / 2 + (n * iFrameWidth); <br>rcFrame.top    = yStreamTop; <br>rcFrame.right  = rcFrame.left + <br>(avis.rcFrame.right - avis.rcFrame.left)*gwZoom/4; <br>rcFrame.bottom = rcFrame.top + <br>(avis.rcFrame.bottom - avis.rcFrame.top)*gwZoom/4; <br> <br>// <br>// draw a border around the current frame.  Make the <br>// one around the centre frame a special colour. <br>// <br>if (n == 0) <br>    hbr = CreateSolidBrush(RGB(255,0,0)); <br>else <br>    hbr = CreateSolidBrush(RGB(255,255,255)); <br> <br>InflateRect(&amp;rcFrame, 1, 1); <br>FrameRect(hdc, &amp;rcFrame, hbr); <br>InflateRect(&amp;rcFrame, -1, -1); <br>DeleteObject (hbr); <br> <br>// <br>// Now draw the video frame in the computed rectangle <br>// <br>PaintVideo(hdc, rcFrame, i, lpbi, lCurFrame, l); <br> <br>    } <br> <br>    // <br>    // Move down to where we can draw the next stream <br>    // <br>    yStreamTop += (rcFrame.bottom - rcFrame.top) + <br>TSPACE; <br>} <br> <br>// <br>// Draw an AUDIO stream <br>// <br>else if (avis.fccType == streamtypeAUDIO) { <br>    LPWAVEFORMAT pwf = (LPWAVEFORMAT)abFormat; <br>    TCHAR *szFmt; <br> <br>    if (pwf-&gt;wFormatTag == 1) {  // PCM <br>if (pwf-&gt;nChannels == 1) <br>    szFmt = TEXT("Format: Mono %ldHz %dbit"); <br>else <br>    szFmt = TEXT("Format: Stereo %ldHz %dbit"); <br>    } <br>    else if (pwf-&gt;wFormatTag == 2) {  // ADPCM <br>if (pwf-&gt;nChannels == 1) <br>    szFmt = TEXT("Format: ADPCM Mono %ldHz %dbit"); <br>else <br>    szFmt = TEXT("Format: ADPCM Stereo %ldHz %dbit"); <br>    } <br>    else { <br>if (pwf-&gt;nChannels == 1) <br>    szFmt = TEXT("Format: Compressed Mono %ldHz %dbit"); <br>else <br>    szFmt = TEXT("Format: Compressed Stereo %ldHz %dbit"); <br>    } <br> <br>    PF2(szFmt,(LONG)pwf-&gt;nSamplesPerSec, <br>(int)((LONG)pwf-&gt;nAvgBytesPerSec / pwf-&gt;nSamplesPerSec / <br>      pwf-&gt;nChannels) * 8); <br> <br>    // <br>    // Figure out which samples are visible <br>    // <br>    lAudioStart = lTime - muldiv32(rcC.right / 2, <br>gdwMicroSecPerPixel, 1000); <br>    lAudioLen = 2 * (lTime - lAudioStart); <br> <br>    // <br>    // Make rectangle to draw audio into <br>    // <br>    rc.left = rcC.left; <br>    rc.right = rcC.right; <br>    rc.top = yStreamTop; <br>    rc.bottom = rc.top + AUDIOVSPACE * gwZoom / 4; <br> <br>    // <br>    // Actually paint the audio <br>    // <br>    PaintAudio(hdc, &amp;rc, gapavi[i], lAudioStart, lAudioLen); <br> <br>            // <br>            // Move down to where we can draw the next stream <br>            // <br>            yStreamTop += AUDIOVSPACE * gwZoom / 4; <br> <br>} <br>else if (avis.fccType == streamtypeTEXT) { <br>    LONG    lPos; <br>    int    iLeft; <br> <br>    lPos = AVIStreamTimeToSample(gapavi[i], <br> lTime - <br> muldiv32((rcC.right - rcC.left), <br>gdwMicroSecPerPixel, <br>1000)); <br> <br>    if (lPos &lt; 0) <br>lPos = 0; <br> <br>    PatBlt(hdc, rcC.left, yStreamTop, <br>   rcC.right - rcC.left, TSPACE + TSPACE, <br>   WHITENESS); <br> <br>    while (lPos &lt; AVIStreamEnd(gapavi[i]) - 1) { <br> <br>                LONG    lStreamTime = AVIStreamSampleToTime(gapavi[i], lPos); <br> <br>                // What pixel is it at this time? <br> <br>                if (lStreamTime &lt; lTime) {              // pixel will be left of centre <br>                    iLeft = (rcC.right + rcC.left) / 2 - <br>    (int) muldiv32(lTime - lStreamTime, 1000,  gdwMicroSecPerPixel); <br>                } <br>                else {                                  // pixel is at, or right of, centre <br>                    iLeft = (rcC.right + rcC.left) / 2 + <br>    (int) muldiv32(lStreamTime - lTime, 1000,  gdwMicroSecPerPixel); <br>                } <br>if (iLeft &gt;= rcC.right) <br>    break; <br> <br>AVIStreamRead(gapavi[i], lPos, 1, ach, sizeof(ach), &amp;l, NULL); <br> <br>nCol = SetBkColor(hdc, GetSysColor(COLOR_WINDOW)); <br>if (l) <br>    TextOut(hdc, iLeft, yStreamTop, ach, (int) l - 1); <br> <br>iLen = wsprintf(ach, TEXT("%ld"), lPos); <br>TextOut(hdc, iLeft, yStreamTop + TSPACE, ach, iLen); <br>SetBkColor(hdc, nCol); <br> <br>lPos += 1; <br>    } <br> <br>    yStreamTop += TSPACE + TSPACE; <br>} <br> <br>yStreamTop += VSPACE; <br> <br>        // <br>        // Give up once we're painting below the bottom of the window <br>        // <br>        if (!fDrawEverything &amp;&amp; yStreamTop &gt;= rcC.bottom) <br>            break; <br>    } <br> <br>    // <br>    // How many lines did we draw? <br>    // <br>    return yStreamTop + GetScrollPos(hwnd, SB_VERT); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppWndProc( hwnd, uiMessage, wParam, lParam )       | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The window proc for the app's main (tiled) window.  This processes all | <br>|       of the parent window's messages.                                       | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|hwndwindow handle for the window       | <br>|       msg             message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       0 if processed, nonzero if ignored                                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>LONG WINAPI  AppWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    BOOL        f; <br>    HDChdc; <br>    RECTrc; <br>    LONGl; <br> <br>    switch (msg) { <br> <br>        // <br>        // If we passed a command line filename, open it <br>        // <br>        case WM_CREATE: <br>            if (gachFileName[0]) <br>                InitAvi(hwnd, gachFileName, MENU_OPEN); <br>    break; <br> <br>        case WM_COMMAND: <br>            return AppCommand(hwnd,msg,wParam,lParam); <br> <br>        case WM_INITMENU: <br>            f = gfVideoFound || gfAudioFound; <br>            EnableMenuItem((HMENU)wParam, MENU_OPTIONS,f ? MF_ENABLED : <br>MF_GRAYED); <br> <br>            f = gcpavi &gt; 0; <br>            EnableMenuItem((HMENU)wParam, MENU_SAVEAS, f ? MF_ENABLED : <br>MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, MENU_NEW,    f ? MF_ENABLED : <br>MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, MENU_ADD,    f ? MF_ENABLED : <br>MF_GRAYED); <br> <br>            f = (gpfile != 0) &amp;&amp; gbCanPalMap &amp;&amp; gfVideoFound; <br>            EnableMenuItem((HMENU)wParam, MENU_NEWPALETTE, f ? MF_ENABLED : <br>                        MF_GRAYED); <br> <br>    f = gfVideoFound || gfAudioFound; <br>            EnableMenuItem((HMENU)wParam, MENU_PLAY, <br>(f &amp;&amp; !gfPlaying) ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, MENU_STOP, <br>                        (f &amp;&amp; gfPlaying) ? MF_ENABLED : MF_GRAYED); <br> <br>    CheckMenuItem((HMENU)wParam, MENU_ZOOMQUARTER, <br>    (gwZoom == 1) ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem((HMENU)wParam, MENU_ZOOMHALF, <br>    (gwZoom == 2) ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem((HMENU)wParam, MENU_ZOOM1, <br>    (gwZoom == 4) ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem((HMENU)wParam, MENU_ZOOM2, <br>    (gwZoom == 8) ? MF_CHECKED : MF_UNCHECKED); <br>    CheckMenuItem((HMENU)wParam, MENU_ZOOM4, <br>    (gwZoom == 16) ? MF_CHECKED : MF_UNCHECKED); <br>     <br>            break; <br> <br>        // <br>        // During a wait state (eg saving) don't let us choose any menus <br>        // <br>case WM_NCHITTEST: <br>    if (fWait) { <br> <br>// Let windows tell us where the cursor is <br>lParam = DefWindowProc(hwnd,msg,wParam,lParam); <br> <br>// If it's over a menu, pretend it's in the client (force <br>// an hourglass) <br>if (lParam == HTMENU) <br>    lParam = HTCLIENT; <br> <br>return lParam; <br>    } <br>    break; <br> <br>// <br>// Set vertical scrollbar for scrolling streams <br>// <br>case WM_SIZE: <br>    GetClientRect(hwnd, &amp;rc); <br> <br>            // <br>            // There is not enough vertical room to show all streams. Scrollbars <br>            // are required. <br>            // <br>    if (vertHeight &gt; rc.bottom) { <br>        vertSBLen = vertHeight - rc.bottom; <br>        SetScrollRange(hwnd, SB_VERT, 0, (int)vertSBLen, TRUE); <br> <br>            // <br>            // Everything fits vertically. No scrollbar necessary. <br>            // <br>    } else { <br>        vertSBLen = 0; <br>        SetScrollRange(hwnd, SB_VERT, 0, 0, TRUE); <br>    } <br>    break; <br> <br>        // <br>        // During a wait state, show an hourglass over our client area <br>        // <br>        case WM_SETCURSOR: <br>            if (fWait &amp;&amp; LOWORD(lParam) == HTCLIENT) { <br>                SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>                return TRUE; <br>            } <br>            break; <br> <br>// <br>// We're out of here! <br>// <br>        case WM_DESTROY: <br>            FreeAvi(hwnd);// close all open streams <br>    AVIFileExit();// shuts down the AVIFile system <br>    if (ghLib) <br>                FreeLibrary(ghLib); <br>    PostQuitMessage(0); <br>    break; <br> <br>// <br>// Don't let us close ourselves in a wait state (eg saving) <br>// <br>        case WM_CLOSE: <br>    if (fWait) <br>return 0; <br>            break; <br> <br>// <br>// Block keyboard access to menus if waiting <br>// <br>case WM_SYSCOMMAND: <br>    switch (wParam &amp; 0xFFF0) { <br>case SC_KEYMENU: <br>    if (fWait) <br>return 0; <br>    break; <br>    } <br>    break; <br> <br>        case WM_PALETTECHANGED: <br>    // It came from us.  Ignore it <br>            if ((HWND)wParam == hwnd) <br>                break; <br> <br>case WM_QUERYNEWPALETTE: <br>            hdc = GetDC(hwnd); <br> <br>            // <br>            // Realize the palette of the first video stream <br>            // !!! Assumes the first stream is video <br>            // <br>            if (ghdd[0] &amp;&amp; (f = DrawDibRealize(ghdd[0], hdc, FALSE))) <br>                InvalidateRect(hwnd,NULL,TRUE); <br> <br>            ReleaseDC(hwnd,hdc); <br> <br>            return f; <br> <br>        case WM_ERASEBKGND: <br>            break; <br> <br>        case WM_PAINT: <br>            hdc = BeginPaint(hwnd,&amp;ps); <br> <br>    PaintStuff(hdc, hwnd, FALSE); <br> <br>            EndPaint(hwnd,&amp;ps); <br>            break; <br> <br>// <br>// handle the keyboard interface <br>// <br>case WM_KEYDOWN: <br>            switch (wParam) <br>            { <br>                case VK_UP:    PostMessage (hwnd,WM_VSCROLL,SB_LINEUP,0L);   break; <br>                case VK_DOWN:  PostMessage (hwnd,WM_VSCROLL,SB_LINEDOWN,0L); break; <br>                case VK_PRIOR: PostMessage (hwnd,WM_HSCROLL,SB_PAGEUP,0L);   break; <br>                case VK_NEXT:  PostMessage (hwnd,WM_HSCROLL,SB_PAGEDOWN,0L); break; <br>                case VK_HOME:  PostMessage (hwnd,WM_HSCROLL,SB_THUMBPOSITION,0L);     break; <br>                case VK_END:   PostMessage (hwnd,WM_HSCROLL,SB_THUMBPOSITION,0x7FFF); break; <br>                case VK_LEFT:  PostMessage (hwnd,WM_HSCROLL,SB_LINEUP,0L);   break; <br>                case VK_RIGHT: PostMessage (hwnd,WM_HSCROLL,SB_LINEDOWN,0L); break; <br>    } <br>    break; <br> <br>        case WM_HSCROLL: <br>            l = GetScrollTime(hwnd); <br> <br>            switch (GET_WM_HSCROLL_CODE(wParam, lParam)) { <br>                case SB_LINEDOWN:      l += timehscroll;  break; <br>                case SB_LINEUP:        l -= timehscroll;  break; <br>                case SB_PAGEDOWN:      l += timeLength/10; break; <br>                case SB_PAGEUP:        l -= timeLength/10; break; <br>                case SB_THUMBTRACK: <br>                case SB_THUMBPOSITION: <br>l = GET_WM_HSCROLL_POS(wParam, lParam); <br>l = timeStart + muldiv32(l, timeLength, SCROLLRANGE); <br>break; <br>            } <br> <br>    if (l &lt; timeStart) <br>l = timeStart; <br> <br>    if (l &gt; timeEnd) <br>l = timeEnd; <br> <br>    if (l == (LONG)GetScrollTime(hwnd)) <br>break; <br> <br>    SetScrollTime(hwnd, l); <br>            InvalidateRect(hwnd, NULL, FALSE); <br>            UpdateWindow(hwnd); <br>            break; <br> <br>        case WM_VSCROLL: <br>            l = GetScrollPos(hwnd, SB_VERT); <br>    GetClientRect(hwnd, &amp;rc); <br> <br>            switch (GET_WM_VSCROLL_CODE(wParam, lParam)) { <br>                case SB_LINEDOWN:      l += 10;  break; <br>                case SB_LINEUP:        l -= 10;  break; <br>                case SB_PAGEDOWN:      l += rc.bottom; break; <br>                case SB_PAGEUP:        l -= rc.bottom; break; <br>                case SB_THUMBTRACK: <br>                case SB_THUMBPOSITION: <br>    l = GET_WM_VSCROLL_POS(wParam, lParam); <br>    break; <br>            } <br> <br>    if (l &lt; 0) <br>l = 0; <br> <br>    if (l &gt; vertSBLen) <br>l = vertSBLen; <br> <br>    if (l == GetScrollPos(hwnd, SB_VERT)) <br>break; <br> <br>    SetScrollPos(hwnd, SB_VERT, (int)l, TRUE); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>            UpdateWindow(hwnd); <br>            break; <br> <br>// <br>// Wave driver wants to tell us something.  Pass it on. <br>// <br>case MM_WOM_OPEN: <br>case MM_WOM_DONE: <br>case MM_WOM_CLOSE: <br>    aviaudioMessage(hwnd, msg, wParam, lParam); <br>    break; <br>    } <br>    return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    SaveCallback() <br>| <br>|    Our save callback that prints our progress in our window title bar. <br>\*----------------------------------------------------------------------------*/ <br>BOOL PASCAL  SaveCallback(int iProgress) <br>{ <br>    TCHAR    ach[128]; <br> <br>    wsprintf(ach, TEXT("%s - Saving %s: %d%%"), <br>        (LPTSTR) gszAppName, (LPTSTR) gachSaveFileName, iProgress); <br> <br>    SetWindowText(ghwndApp, ach); <br> <br>    // <br>    // Give ourselves a chance to abort <br>    // <br>    return WinYield(); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|    AppCommand() <br>| <br>|    Process all of our WM_COMMAND messages. <br>\*----------------------------------------------------------------------------*/ <br>LONG PASCAL AppCommand (HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch(GET_WM_COMMAND_ID(wParam, lParam)) <br>    { <br>// <br>// Our about box <br>// <br>        case MENU_ABOUT: <br>            DialogBox(ghInstApp, MAKEINTRESOURCE(IDD_ABOUT), hwnd, AboutDlgProc); <br>            break; <br> <br>// <br>// We want out of here! <br>// <br>case MENU_EXIT: <br>    PostMessage(hwnd,WM_CLOSE,0,0L); <br>            break; <br> <br>// <br>// Set the compression options for each stream - pass an array of <br>// streams and an array of compression options structures <br>// <br>        case MENU_OPTIONS: <br>            AVISaveOptions(hwnd, ICMF_CHOOSE_KEYFRAME | ICMF_CHOOSE_DATARATE <br>| ICMF_CHOOSE_PREVIEW, <br>gcpavi, gapavi, galpAVIOptions); <br>    break; <br> <br>        // <br>        // Use palmap to set the no of colours to save with <br>        // <br>        case MENU_NEWPALETTE: <br>            { <br>       HDC      hdc; <br>               PAVISTREAM     psMappedStream; <br>               PAVISTREAM     psCurrent; <br>               AVISTREAMINFO  avis; <br>               FARPROC        lpfnAVICreateMappedStream; <br>       LPBITMAPINFOHEADER lpbi; <br>#define AVICreateMappedStream 11       //Cardinal for procedure in palmap32.dll <br> <br>               lpfnAVICreateMappedStream = GetProcAddress(ghLib,MAKEINTRESOURCE(AVICreateMappedStream)); <br>               if (lpfnAVICreateMappedStream == NULL) { <br>                   ErrMsg(TEXT("Unable to find AVICreateMappedStream in palmap32.dll")); <br>                   gbCanPalMap = FALSE; <br>               } <br> <br>               psCurrent = gapavi[giFirstVideo]; <br> <br>               AVIStreamInfo(psCurrent, &amp;avis, sizeof(avis)); <br> <br>               if (avis.fccType != streamtypeVIDEO) { <br>                   ErrMsg("Stream is not video!"); <br>                   break; <br>               } <br> <br>               if (DialogBoxParam( <br>                             ghInstApp, <br>                             MAKEINTRESOURCE(IDD_NCOLORS), <br>                             hwnd, <br>                             GetNumberOfColorsDlgProc, <br>                             (LPARAM)GetNumberOfColors(psCurrent)) <br>                   ) { <br>                      StartWait(); <br>                      // <br>                      //  Find out how many colours they want to map it to <br>                      // <br> <br>                      if (0 != (*lpfnAVICreateMappedStream)(&amp;psMappedStream, <br>                                              psCurrent, <br>                                              gnColours)) { <br>                           ErrMsg(TEXT("Can't map stream palette")); <br>                      } <br>                      else { <br>                           gapavi[giFirstVideo] = psMappedStream; <br> <br>   // We've just mapped this stream to a new palette <br>   // so we have to re-init the GetFrame stuff used <br>   // to draw this stream. <br>   // Kick start DrawDib to realize the new palette. <br>   // <br>   if (gapgf[giFirstVideo]) <br>AVIStreamGetFrameClose(gapgf[giFirstVideo]); <br>   gapgf[giFirstVideo] = <br>AVIStreamGetFrameOpen(gapavi[giFirstVideo], 0); <br>   lpbi = AVIStreamGetFrame(gapgf[giFirstVideo], 0); <br>   DrawDibBegin(ghdd[giFirstVideo], NULL, <br>lpbi-&gt;biWidth, lpbi-&gt;biHeight, <br>lpbi, lpbi-&gt;biWidth, lpbi-&gt;biHeight, 0); <br>   hdc = GetDC(hwnd); <br>   DrawDibRealize(ghdd[giFirstVideo], hdc, FALSE); <br>   ReleaseDC(hwnd, hdc); <br>                      } <br>                      EndWait(); <br>                   } <br> <br>            } <br>            break; <br> <br> <br>// <br>// Save all the open streams into a file <br>// <br>        case MENU_SAVEAS: <br>            { <br>                OPENFILENAME ofn; <br> <br>                gachSaveFileName[0] = 0; <br> <br>            // <br>                // prompt user for file to save <br>            // <br>                ofn.lStructSize = sizeof(OPENFILENAME); <br>                ofn.hwndOwner = hwnd; <br>                ofn.hInstance = NULL; <br> <br>                AVIBuildFilter(gachFilter, sizeof(gachFilter)/sizeof(TCHAR), TRUE); <br> <br>                ofn.lpstrFilter = gachFilter; <br>                ofn.lpstrCustomFilter = NULL; </code></pre>
<p>
</p>
<pre><code>ofn.nMaxCustFilter = 0; <br>                ofn.nFilterIndex = 0; <br>                ofn.lpstrFile = gachSaveFileName; <br>                ofn.nMaxFile = sizeof(gachSaveFileName)/sizeof(TCHAR); <br>                ofn.lpstrFileTitle = NULL; <br>                ofn.nMaxFileTitle = 0; <br>                ofn.lpstrInitialDir = NULL; <br>                ofn.lpstrTitle = TEXT("Save AVI File"); <br>                ofn.Flags = OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | <br>        OFN_OVERWRITEPROMPT; <br>                ofn.nFileOffset = 0; <br>                ofn.nFileExtension = 0; <br>                ofn.lpstrDefExt = TEXT("avi"); <br>                ofn.lCustData = 0; <br>                ofn.lpfnHook = NULL; <br>                ofn.lpTemplateName = NULL; <br> <br>         // <br>         // If we get a filename, save it <br>         // <br>                if (GetSaveFileName(&amp;ofn)) { <br>                    DWORD   fccHandler[MAXNUMSTREAMS]; <br>            int    i; <br>            HRESULT hr; <br>         <br>            StartWait(); <br> <br>            for (i = 0; i &lt; gcpavi; i++) <br>                fccHandler[i] = galpAVIOptions[i]-&gt;fccHandler; <br> <br>            hr = AVISaveV(gachSaveFileName, <br>                          NULL, <br>                          (AVISAVECALLBACK) SaveCallback, <br>                          gcpavi, <br>                          gapavi, <br>                          galpAVIOptions); <br>            if (hr != AVIERR_OK) { <br>                        switch (hr) { <br>                        case AVIERR_FILEOPEN: <br>                            ErrMsg(TEXT("Overwriting an open AVI file is not possible")); <br>                            break; <br>                        default: <br>                            ErrMsg(TEXT("Error saving AVI file")); <br>                        } <br>                    } <br> <br>            // Now put the video compressors back that we stole <br>            for (i = 0; i &lt; gcpavi; i++) <br>                 galpAVIOptions[i]-&gt;fccHandler = fccHandler[i]; <br>         <br>            EndWait(); <br>            FixWindowTitle(hwnd); <br>                } <br>     } <br>    break; <br> <br>// <br>// Close everything <br>// <br>case MENU_NEW: <br>    FreeAvi(hwnd); <br>    gachFileName[0] = TEXT('\0'); <br>    FixWindowTitle(hwnd); <br>    break; <br> <br>// <br>// Open a new file, or merge streams with a new file <br>// <br>        case MENU_OPEN: <br>        case MENU_ADD: <br>            { <br>                OPENFILENAME ofn; <br> <br>                gachFileName[0] = 0; <br> <br>            // <br>                // prompt user for file to open <br>            // <br>                ofn.lStructSize = sizeof(OPENFILENAME); <br>                ofn.hwndOwner   = hwnd; <br>                ofn.hInstance   = NULL; <br>            if (wParam == MENU_ADD) <br>        ofn.lpstrTitle = TEXT("Merge With"); <br>            else <br>                ofn.lpstrTitle = TEXT("Open AVI"); <br> <br>            if (gachFilter[0] == TEXT('\0')) <br>        AVIBuildFilter(gachFilter, sizeof(gachFilter)/sizeof(TCHAR), FALSE); <br>     <br>            ofn.lpstrFilter       = gachFilter; <br>                ofn.lpstrCustomFilter = NULL; <br>                ofn.nMaxCustFilter    = 0; <br>                ofn.nFilterIndex      = 0; <br>                ofn.lpstrFile         = gachFileName; <br>                ofn.nMaxFile          = sizeof(gachFileName)/sizeof(TCHAR); <br>                ofn.lpstrFileTitle    = NULL; <br>                ofn.nMaxFileTitle     = 0; <br>                ofn.lpstrInitialDir   = NULL; <br>                ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY; <br>                ofn.nFileOffset       = 0; <br>                ofn.nFileExtension    = 0; <br>                ofn.lpstrDefExt       = NULL; <br>                ofn.lCustData         = 0; <br>                ofn.lpfnHook          = NULL; <br>                ofn.lpTemplateName    = NULL; <br> <br>            // <br>            // If we've got a filename, go open it <br>            // <br>                if (GetOpenFileNamePreview(&amp;ofn)) <br>        InitAvi(hwnd, gachFileName, wParam); <br>            } <br>            break; <br> <br>// <br>// Open the "fake" ball file as our current file <br>// <br>case MENU_BALL: <br>    InitBall(hwnd); <br>    break; <br> <br>case MENU_ZOOMQUARTER: <br>    gwZoom = 1; <br>    FixScrollbars(hwnd); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOMHALF: <br>    gwZoom = 2; <br>    FixScrollbars(hwnd); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOM1: <br>    gwZoom = 4; <br>    FixScrollbars(hwnd); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOM2: <br>    gwZoom = 8; <br>    FixScrollbars(hwnd); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>    break; <br> <br>case MENU_ZOOM4: <br>    gwZoom = 16; <br>    FixScrollbars(hwnd); <br>            InvalidateRect(hwnd, NULL, TRUE); <br>            break; <br> <br>// <br>// Simulate playing the file.  We just play the 1st audio stream and let <br>// our main message loop scroll the video by whenever it's bored. <br>// <br>case MENU_PLAY: <br>    if (gfAudioFound) <br>        aviaudioPlay(hwnd, <br> gpaviAudio, <br> AVIStreamTimeToSample(gpaviAudio, GetScrollTime(hwnd)), <br> AVIStreamEnd(gpaviAudio), <br> FALSE); <br>            gfPlaying = TRUE; <br>            glPlayStartTime = timeGetTime(); <br>            glPlayStartPos = GetScrollTime(hwnd); <br>            break; <br> <br>// <br>// Stop the play preview <br>// <br>case MENU_STOP: <br>    if (gfAudioFound) <br>        aviaudioStop(); <br>    gfPlaying = FALSE; <br>    break; <br> <br>    } <br>    return 0L; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   ErrMsg - Opens a Message box with a error message in it.  The user can     | <br>|            select the OK button to continue                                  | <br>\*----------------------------------------------------------------------------*/ <br>int ErrMsg (LPTSTR sz,...) <br>{ <br>    static TCHAR ach[2000]; <br>    va_list va; <br> <br>    va_start(va, sz); <br>    wvsprintf (ach,sz, va); <br>    va_end(va); <br>    MessageBox(NULL,ach,NULL, <br>#ifdef BIDI <br>MB_RTL_READING | <br>#endif <br>    MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>    return FALSE; <br>} <br> <br> <br>// Find the number of colours present in the stream palette <br>LONG GetNumberOfColors(PAVISTREAM ps) <br>{ <br>    BITMAPINFOHEADER bmih; <br>    LONG             cbFormat = sizeof(bmih); <br> <br>    bmih.biClrUsed = 0; <br> <br>    AVIStreamReadFormat(ps, 0, (LPVOID)&amp;bmih, &amp;cbFormat); <br> <br>    return (LONG)bmih.biClrUsed; <br>} <br> <br>/* GetNumberOfColorsDlgProc() <br> * <br> * Dialog Procedure for getting the no of colours the user wants in the palette <br> * <br> */ <br> <br>BOOL CALLBACK GetNumberOfColorsDlgProc( <br>HWNDhwnd, <br>UINTmsg, <br>WPARAMwParam, <br>LPARAMlParam) <br>{ <br>        BOOL Translated; <br>switch (msg) { <br>case WM_COMMAND: <br>            switch (GET_WM_COMMAND_ID(wParam, lParam)) { <br>            case IDOK: <br>gnColours = GetDlgItemInt(hwnd, IDC_NCOLORS, &amp;Translated, FALSE); <br>                EndDialog(hwnd, TRUE); <br>                return TRUE; <br>            case IDCANCEL: <br>                EndDialog(hwnd, FALSE); <br>            } <br>            break; <br> <br>case WM_INITDIALOG: <br>            { <br>                SetDlgItemInt(hwnd, IDC_NCOLORS, lParam, FALSE); <br>return TRUE; <br>            } <br>} <br>return FALSE; <br>} <br> <br> <br>/* AboutDlgProc() <br> * <br> * Dialog Procedure for the "about" dialog box. <br> * <br> */ <br> <br>BOOL CALLBACK AboutDlgProc( <br>HWNDhwnd, <br>UINTmsg, <br>WPARAMwParam, <br>LPARAMlParam) <br>{ <br>switch (msg) { <br>case WM_COMMAND: <br>EndDialog(hwnd, TRUE); <br>return TRUE; <br>        case WM_INITDIALOG: <br>                if (gbCanPalMap)                                         // Provide the user with <br>                    ShowWindow(GetDlgItem(hwnd, IDS_PALETTE), SW_HIDE);  // some information about <br>                else                                                     // whether palmap32.dll was <br>                    ShowWindow(GetDlgItem(hwnd, IDS_PALETTE), SW_SHOW);  // found. <br>                return TRUE; <br>} <br>return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
