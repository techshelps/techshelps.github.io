<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3780"></a>CDIB.C</h2>
<pre><code>/***************************************************************************** <br> * <br> *  CrunchDIB  - shrink a DIB down by 2 with color averaging <br> * <br> *****************************************************************************/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> *  <br> **************************************************************************/ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;memory.h&gt; <br> <br>// <br>// support huge &gt;64k DIBs? <br>// <br>#ifndef WIN32 <br>#define HUGE_DIBS <br>#endif <br>#ifdef HUGE_DIBS <br>#define LPBYTE  BYTE _huge * <br>#define LPWORD  WORD _huge * <br>#undef FAR <br>#define FAR _huge <br>#endif <br> <br>/***************************************************************************** <br> * <br> *  These are the standard VGA colors, we will be stuck with until the <br> *  end of time! <br> * <br> *****************************************************************************/ <br> <br>static DWORD VGAColors[16] = { <br>     0x00000000        // 0000  black <br>    ,0x00800000        // 0001  dark red <br>    ,0x00008000        // 0010  dark green <br>    ,0x00808000        // 0011  mustard <br>    ,0x00000080        // 0100  dark blue <br>    ,0x00800080        // 0101  purple <br>    ,0x00008080        // 0110  dark turquoise <br>    ,0x00C0C0C0        // 1000  gray <br>    ,0x00808080        // 0111  dark gray <br>    ,0x00FF0000        // 1001  red <br>    ,0x0000FF00        // 1010  green <br>    ,0x00FFFF00        // 1011  yellow <br>    ,0x000000FF        // 1100  blue <br>    ,0x00FF00FF        // 1101  pink (magenta) <br>    ,0x0000FFFF        // 1110  cyan <br>    ,0x00FFFFFF        // 1111  white <br>    }; <br> <br>/***************************************************************************** <br> * <br> *  bit(b,n)   - get the Nth bit of BYTE b <br> * <br> *****************************************************************************/ <br> <br>#define bit(b,n) (BYTE)(((b) &amp; (1 &lt;&lt; (n))) &gt;&gt; (n)) <br> <br>/***************************************************************************** <br> * <br> *  SumMono <br> * <br> *     this routine taks four "mono" values and returns the average value. <br> * <br> *     ((b0) + (b1) + (b2) + (b3) &gt;= 2) <br> * <br> * <br> *****************************************************************************/ <br> <br>#define SumMono(b0,b1,b2,b3) (BYTE)(((b0) + (b1) + (b2) + (b3) + 2) / 4) <br> <br>/***************************************************************************** <br> * <br> *  MapVGA <br> * <br> *     map a rgb value to a VGA index <br> * <br> *        0000  black <br> *        0001  dark red <br> *        0010  dark green <br> *        0011  mustard <br> *        0100  dark blue <br> *        0101  purple <br> *        0110  dark turquoise <br> *        1000  gray <br> *        0111  dark gray <br> *        1001  red <br> *        1010  green <br> *        1011  yellow <br> *        1100  blue <br> *        1101  pink (magenta) <br> *        1110  cyan <br> *        1111  white <br> * <br> *****************************************************************************/ <br> <br>#define MapVGA(r,g,b) (((r&amp;~3) == (g&amp;~3) &amp;&amp; (g&amp;~3) == (b&amp;~3)) ?        \ <br>        ((r &lt; 64) ? 0 : (r &lt;= 128) ? 8 : (r &lt;= 192) ? 7 : 15) :        \ <br>        (((r&gt;192) || (g&gt;192) || (b&gt;192)) ?                             \ <br>           (((r&gt;191) ? 1:0) | ((g&gt;191) ? 2:0) | ((b&gt;191) ? 4:0) | 8) : \ <br>           (((r&gt;64) ? 1:0) | ((g&gt;64) ? 2:0) | ((b&gt;64) ? 4:0))) ) <br> <br>/***************************************************************************** <br> * <br> *  SumRGB <br> * <br> *****************************************************************************/ <br> <br>#define SumRGB(b0,b1,b2,b3) RGB(\ <br>        ((int)pal.palPalEntry[b0].peRed +        \ <br>         (int)pal.palPalEntry[b1].peRed +        \ <br>         (int)pal.palPalEntry[b2].peRed +        \ <br>         (int)pal.palPalEntry[b3].peRed) &gt;&gt; 2,   \ <br>                                                 \ <br>        ((int)pal.palPalEntry[b0].peGreen +      \ <br>         (int)pal.palPalEntry[b1].peGreen +      \ <br>         (int)pal.palPalEntry[b2].peGreen +      \ <br>         (int)pal.palPalEntry[b3].peGreen) &gt;&gt; 2, \ <br>                                                  \ <br>        ((int)pal.palPalEntry[b0].peBlue +       \ <br>         (int)pal.palPalEntry[b1].peBlue +       \ <br>         (int)pal.palPalEntry[b2].peBlue +       \ <br>         (int)pal.palPalEntry[b3].peBlue) &gt;&gt; 2) <br> <br>/***************************************************************************** <br> * <br> *  RGB16 <br> * <br> *****************************************************************************/ <br> <br>typedef struct { BYTE b,g,r; } RGB24; <br> <br>#define RGB16(r,g,b) (\ <br>            (((UINT)(r) &gt;&gt; 3) &lt;&lt; 10) |  \ <br>            (((UINT)(g) &gt;&gt; 3) &lt;&lt; 5)  |  \ <br>            (((UINT)(b) &gt;&gt; 3) &lt;&lt; 0)  ) <br> <br>#define rgb16(r,g,b) (\ <br>            ((UINT)(r) &lt;&lt; 10) |  \ <br>            ((UINT)(g) &lt;&lt; 5)  |  \ <br>            ((UINT)(b) &lt;&lt; 0)  ) <br> <br>//#define RGB16R(rgb)     ((((UINT)(rgb) &gt;&gt; 10) &amp; 0x1F) * 255u / 31u) <br>//#define RGB16G(rgb)     ((((UINT)(rgb) &gt;&gt; 5)  &amp; 0x1F) * 255u / 31u) <br>//#define RGB16B(rgb)     ((((UINT)(rgb) &gt;&gt; 0)  &amp; 0x1F) * 255u / 31u) <br> <br>#define RGB16R(rgb)     aw5to8[((UINT)(rgb) &gt;&gt; 10) &amp; 0x1F] <br>#define RGB16G(rgb)     aw5to8[((UINT)(rgb) &gt;&gt; 5)  &amp; 0x1F] <br>#define RGB16B(rgb)     aw5to8[((UINT)(rgb) &gt;&gt; 0)  &amp; 0x1F] <br>#define RGB16r(rgb)     ((BYTE)((UINT)(rgb) &gt;&gt; 10) &amp; 0x1F) <br>#define RGB16g(rgb)     ((BYTE)((UINT)(rgb) &gt;&gt; 5)  &amp; 0x1F) <br>#define RGB16b(rgb)     ((BYTE)((UINT)(rgb) &gt;&gt; 0)  &amp; 0x1F) <br> <br>/***************************************************************************** <br> * <br> *  Pel() used for 24bit Crunch <br> * <br> *****************************************************************************/ <br> <br>#define Pel(p,x) (BYTE)(BitCount == 1 ? Pel1(p,x) : \ <br>                        BitCount == 4 ? Pel4(p,x) : Pel8(p,x)) <br> <br>#define Pel1(p,x)   (BYTE)bit(((LPBYTE)(p))[(x)/8],7-((x)%8)) <br>#define Pel4(p,x)   (BYTE)((x &amp; 1) ? (((LPBYTE)(p))[(x)/2] &amp; 15) : (((LPBYTE)(p))[(x)/2] &gt;&gt; 4)) <br>#define Pel8(p,x)   (BYTE)(((LPBYTE)(p))[(x)]) <br>#define Pel16(p,x)  (((LPWORD)(p))[(x)]) <br>#define Pel24(p,x)  (((RGB24 FAR *)(p))[(x)]) <br> <br>/***************************************************************************** <br> * <br> *  CrunchDIB  - shrink a DIB down by 2 with color averaging <br> * <br> *     this routine works on 1,4 bpp DIBs <br> * <br> *     for mono DIBs it is assumed they are black and white <br> * <br> *     for 4bpp DIBs it is assumed they use the VGA colors <br> * <br> *     this routine can't be used "in place" <br> * <br> *****************************************************************************/ <br> <br>BOOL CrunchDIB( <br>    LPBITMAPINFOHEADER  lpbiSrc,    // BITMAPINFO of source <br>    LPVOID              lpSrc,      // input bits to crunch <br>    LPBITMAPINFOHEADER  lpbiDst,    // BITMAPINFO of dest <br>    LPVOID              lpDst)      // output bits to crunch <br>{ <br>    LPBYTE      pbSrc; <br>    LPBYTE      pbDst; <br>    LPBYTE      pb; <br>    LPWORD      pw; <br>    BYTE        r,g,b,b0,b1,b2,b3; <br>    WORD        w0,w1,w2,w3; <br>    RGB24       rgb0,rgb1,rgb2,rgb3; <br>    int         WidthBytesSrc; <br>    int         WidthBytesDst; <br>    UINT        x; <br>    UINT        y; <br>    UINT        dx; <br>    UINT        dy; <br>    int         i; <br>    COLORREF    rgb; <br>    int         BitCount; <br>    UINT        aw5to8[32]; <br> <br>    struct { <br>        WORD         palVersion; <br>WORD         palNumEntries; <br>PALETTEENTRY palPalEntry[256]; <br>    }   pal; <br> <br>    if (lpbiSrc-&gt;biCompression != BI_RGB) <br>        return FALSE; <br> <br>    BitCount = (int)lpbiSrc-&gt;biBitCount; <br> <br>    if (BitCount == 16) <br>        for (i=0; i&lt;32; i++) <br>            aw5to8[i] = (UINT)i * 255u / 31u; <br> <br>    dx = (int)lpbiDst-&gt;biWidth; <br>    WidthBytesDst = (((UINT)lpbiDst-&gt;biBitCount * dx + 31)&amp;~31) / 8; <br> <br>    dy = (int)lpbiSrc-&gt;biHeight; <br>    dx = (int)lpbiSrc-&gt;biWidth; <br>    WidthBytesSrc = (((UINT)lpbiSrc-&gt;biBitCount * dx + 31)&amp;~31) / 8; <br> <br>    dx &amp;= ~1; <br>    dy &amp;= ~1; <br> <br>    pbSrc = lpSrc; <br>    pbDst = lpDst; <br> <br>    if (lpbiSrc-&gt;biClrUsed == 0 &amp;&amp; lpbiSrc-&gt;biBitCount &lt;= 8) <br>        lpbiSrc-&gt;biClrUsed = (1 &lt;&lt; (int)lpbiSrc-&gt;biBitCount); <br> <br>    pal.palVersion = 0x300; <br>    pal.palNumEntries = (int)lpbiSrc-&gt;biClrUsed; <br> <br>    for (i=0; i&lt;(int)pal.palNumEntries; i++) <br>    { <br>        pal.palPalEntry[i].peRed   = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbRed; <br>        pal.palPalEntry[i].peGreen = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbGreen; <br>        pal.palPalEntry[i].peBlue  = ((LPRGBQUAD)(lpbiSrc+1))[i].rgbBlue; <br>        pal.palPalEntry[i].peFlags = 0; <br>    } <br> <br>    if (lpbiDst-&gt;biBitCount == 8) <br>        _fmemcpy(lpbiDst+1,lpbiSrc+1,(int)lpbiSrc-&gt;biClrUsed*sizeof(RGBQUAD)); <br> <br>    if (lpbiDst-&gt;biBitCount == 4) <br>        _fmemcpy(lpbiDst+1,VGAColors,sizeof(VGAColors)); <br> <br>    if ((int)lpbiDst-&gt;biBitCount == (int)lpbiSrc-&gt;biBitCount) <br>    { <br>        switch((int)lpbiSrc-&gt;biBitCount) <br>        { <br>        case 1: <br>            dx = dx / 8;    // dx is byte count <br> <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pb = pbDst; <br> <br>                for (x=0; x&lt;dx; x += 2) <br>                { <br>                    b0 = pbSrc[x]; <br>                    b1 = pbSrc[x + WidthBytesSrc]; <br> <br>                    b = (BYTE)( <br>                        (SumMono(bit(b0,7), bit(b0,6), bit(b1,7), bit(b1,6)) &lt;&lt; 7) | <br>                        (SumMono(bit(b0,5), bit(b0,4), bit(b1,5), bit(b1,4)) &lt;&lt; 6) | <br>                        (SumMono(bit(b0,3), bit(b0,2), bit(b1,3), bit(b1,2)) &lt;&lt; 5) | <br>                        (SumMono(bit(b0,1), bit(b0,0), bit(b1,1), bit(b1,0)) &lt;&lt; 4)); <br> <br>                    b0 = pbSrc[x + 1]; <br>                    b1 = pbSrc[x + 1 + WidthBytesSrc]; <br> <br>                    b |=(SumMono(bit(b0,7), bit(b0,6), bit(b1,7), bit(b1,6)) &lt;&lt; 3) | <br>                        (SumMono(bit(b0,5), bit(b0,4), bit(b1,5), bit(b1,4)) &lt;&lt; 2) | <br>                        (SumMono(bit(b0,3), bit(b0,2), bit(b1,3), bit(b1,2)) &lt;&lt; 1) | <br>                        (SumMono(bit(b0,1), bit(b0,0), bit(b1,1), bit(b1,0)) &lt;&lt; 0); <br> <br>                    *pb++ = b; <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br>            break; <br> <br>        case 4: <br>            dx = dx / 2;    // dx is byte count <br> <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pb = pbDst; <br> <br>                for (x=0; x&lt;dx; x+=2) <br>                { <br>                    b0 = pbSrc[x]; <br>                    b1 = pbSrc[x + WidthBytesSrc]; <br> <br>                    rgb = SumRGB((b0 &gt;&gt; 4),(b0 &amp; 0x0F), <br>                                 (b1 &gt;&gt; 4),(b1 &amp; 0x0F)); <br> <br>                    b = (BYTE)(MapVGA(GetRValue(rgb),GetGValue(rgb),GetBValue(rgb)) &lt;&lt; 4); <br> <br>                    b0 = pbSrc[x + 1]; <br>                    b1 = pbSrc[x + 1 + WidthBytesSrc]; <br> <br>                    rgb = SumRGB((b0 &gt;&gt; 4),(b0 &amp; 0x0F), <br>                                 (b1 &gt;&gt; 4),(b1 &amp; 0x0F)); <br> <br>                    b |= MapVGA(GetRValue(rgb),GetGValue(rgb),GetBValue(rgb)); <br> <br>                    *pb++ = b; <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br>            break; <br>#if 0 <br>        case 8: <br>            { <br>            HPALETTE hpal; <br> <br>            hpal = CreatePalette((LPLOGPALETTE)&amp;pal); <br> <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pb = pbDst; <br> <br>                for (x=0; x&lt;dx; x+=2) <br>                { <br>                    b0 = Pel8(pbSrc,x); <br>                    b1 = Pel8(pbSrc+WidthBytesSrc, x); <br>                    b2 = Pel8(pbSrc,x+1); <br>                    b3 = Pel8(pbSrc+WidthBytesSrc,x+1); <br> <br>                    *pb++ = (BYTE)GetNearestPaletteIndex(hpal, <br>                        SumRGB(b0,b1,b2,b3)); <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br> <br>            DeleteObject(hpal); <br>            } <br>            break; <br>#endif <br>        case 16: <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pw = (LPWORD)pbDst; <br> <br>for (x=0; x&lt;dx; x += 2) <br>                { <br>                    w0 = Pel16(pbSrc,x); <br>                    w1 = Pel16(pbSrc,x+1); <br>                    w2 = Pel16(pbSrc+WidthBytesSrc,x); <br>                    w3 = Pel16(pbSrc+WidthBytesSrc,x+1); <br> <br>                    r = ((BYTE)RGB16r(w0) + RGB16r(w1) + RGB16r(w2) + RGB16r(w3)) &gt;&gt; 2; <br>                    g = ((BYTE)RGB16g(w0) + RGB16g(w1) + RGB16g(w2) + RGB16g(w3)) &gt;&gt; 2; <br>                    b = ((BYTE)RGB16b(w0) + RGB16b(w1) + RGB16b(w2) + RGB16b(w3)) &gt;&gt; 2; <br> <br>                    *pw++ = rgb16(r,g,b); <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br>            break; <br> <br>        case 24: <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pb = pbDst; <br> <br>for (x=0; x&lt;dx; x += 2) <br>                { <br>                    rgb0 = Pel24(pbSrc,x); <br>                    rgb1 = Pel24(pbSrc,x+1); <br>                    rgb2 = Pel24(pbSrc+WidthBytesSrc,x); <br>                    rgb3 = Pel24(pbSrc+WidthBytesSrc,x+1); <br> <br>                    rgb = RGB( <br>                        ((UINT)rgb0.r + rgb1.r + rgb2.r + rgb3.r)/4, <br>                        ((UINT)rgb0.g + rgb1.g + rgb2.g + rgb3.g)/4, <br>                        ((UINT)rgb0.b + rgb1.b + rgb2.b + rgb3.b)/4); <br> <br>                    *pb++ = GetBValue(rgb); <br>                    *pb++ = GetGValue(rgb); <br>                    *pb++ = GetRValue(rgb); <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br>    } <br>    else if ((int)lpbiDst-&gt;biBitCount == 24) <br>    { <br>        switch((int)lpbiSrc-&gt;biBitCount) <br>        { <br>        case 1: <br>        case 4: <br>        case 8: <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pb = pbDst; <br> <br>for (x=0; x&lt;dx; x += 2) <br>                { <br>                    b0 = Pel(pbSrc,x); <br>                    b1 = Pel(pbSrc,x+1); <br>                    b2 = Pel(pbSrc+WidthBytesSrc,x); <br>                    b3 = Pel(pbSrc+WidthBytesSrc,x+1); <br> <br>                    rgb = SumRGB(b0,b1,b2,b3); <br> <br>                    *pb++ = GetBValue(rgb); <br>                    *pb++ = GetGValue(rgb); <br>                    *pb++ = GetRValue(rgb); <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br>            break; <br> <br>        case 16: <br>            for (y=0; y&lt;dy; y+=2) <br>            { <br>                pb = pbDst; <br> <br>for (x=0; x&lt;dx; x += 2) <br>                { <br>                    w0 = Pel16(pbSrc,x); <br>                    w1 = Pel16(pbSrc,x+1); <br>                    w2 = Pel16(pbSrc+WidthBytesSrc,x); <br>                    w3 = Pel16(pbSrc+WidthBytesSrc,x+1); <br> <br>                    r = (RGB16R(w0) + RGB16R(w1) + RGB16R(w2) + RGB16R(w3)) / 4; <br>                    g = (RGB16G(w0) + RGB16G(w1) + RGB16G(w2) + RGB16G(w3)) / 4; <br>                    b = (RGB16B(w0) + RGB16B(w1) + RGB16B(w2) + RGB16B(w3)) / 4; <br> <br>                    rgb = RGB(r,g,b); <br> <br>                    *pb++ = GetBValue(rgb); <br>                    *pb++ = GetGValue(rgb); <br>                    *pb++ = GetRValue(rgb); <br>                } <br> <br>                pbSrc += WidthBytesSrc*2; <br>                pbDst += WidthBytesDst; <br>            } <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br>    } <br>    else <br>    { <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
