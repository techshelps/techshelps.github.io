<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUDPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3783"></a>AUDPLAY.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>/*--------------------------------------------------------------+ <br>| audplay.c Simple routines to play audio using an AVIStream to | <br>| get data.  Uses global variables, so only one instance at a| <br>| time.  (Usually, there's only one sound card, so this isn't| <br>| so bad).| <br>+--------------------------------------------------------------*/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "audplay.h" <br>#include "muldiv32.h" <br> <br>/*--------------------------------------------------------------+ <br>| ****************** AUDIO PLAYING SUPPORT ******************** | <br>+--------------------------------------------------------------*/ <br> <br>staticHWAVEOUTshWaveOut = 0;/* Current MCI device ID */ <br>staticLONGslBegin; <br>staticLONGslCurrent; <br>staticLONGslEnd; <br>staticBOOLsfLooping; <br>staticBOOLsfPlaying = FALSE; <br> <br>#define MAX_AUDIO_BUFFERS16 <br>#define MIN_AUDIO_BUFFERS2 <br>#define AUDIO_BUFFER_SIZE16384 <br> <br>staticUINTswBuffers;    // total # buffers <br>staticUINTswBuffersOut;    // buffers device has <br>staticUINTswNextBuffer;    // next buffer to fill <br>staticLPWAVEHDRsalpAudioBuf[MAX_AUDIO_BUFFERS]; <br> <br>staticPAVISTREAMspavi;    // stream we're playing <br>staticLONGslSampleSize;    // size of an audio sample <br> <br>staticLONGsdwBytesPerSec; <br>staticLONGsdwSamplesPerSec; <br> <br>/*---------------------------------------------------------------+ <br>| aviaudioCloseDevice -- close the open audio device, if any.    | <br>+---------------------------------------------------------------*/ <br>void aviaudioCloseDevice(void) <br>{ <br>    UINTw; <br> <br>    if (shWaveOut) { <br>while (swBuffers &gt; 0) { <br>    --swBuffers; <br>    waveOutUnprepareHeader(shWaveOut, salpAudioBuf[swBuffers], <br>sizeof(WAVEHDR)); <br>    GlobalFreePtr((LPBYTE) salpAudioBuf[swBuffers]); <br>} <br> <br>w = waveOutClose(shWaveOut); <br> <br>// DPF("AudioCloseDevice: waveOutClose returns %u\n", w); <br>shWaveOut = NULL; <br>    } <br>} <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioOpenDevice -- get ready to play waveform data.| <br>+--------------------------------------------------------------*/ <br>BOOL aviaudioOpenDevice(HWND hwnd, PAVISTREAM pavi) <br>{ <br>    UINTw; <br>    LPVOIDlpFormat; <br>    LONGcbFormat; <br>    AVISTREAMINFOstrhdr; <br> <br>    if (!pavi)// no wave data to play <br>return FALSE; <br> <br>    if (shWaveOut)// already something playing <br>return TRUE; <br> <br>    spavi = pavi; <br> <br>    AVIStreamInfo(pavi, &amp;strhdr, sizeof(strhdr)); <br> <br>    slSampleSize = (LONG) strhdr.dwSampleSize; <br>    if (slSampleSize &lt;= 0 || slSampleSize &gt; AUDIO_BUFFER_SIZE) <br>return FALSE; <br> <br>    AVIStreamFormatSize(pavi, 0, &amp;cbFormat); <br> <br>    lpFormat = GlobalAllocPtr(GHND, cbFormat); <br>    if (!lpFormat) <br>return FALSE; <br> <br>    AVIStreamReadFormat(pavi, 0, lpFormat, &amp;cbFormat); <br> <br>    sdwSamplesPerSec = ((LPWAVEFORMAT) lpFormat)-&gt;nSamplesPerSec; <br>    sdwBytesPerSec = ((LPWAVEFORMAT) lpFormat)-&gt;nAvgBytesPerSec; <br> <br>    w = waveOutOpen(&amp;shWaveOut, WAVE_MAPPER, lpFormat, <br>(DWORD) (UINT) hwnd, 0L, CALLBACK_WINDOW); <br> <br>    // <br>    // Maybe we failed because someone is playing sound already. <br>    // Shut any sound off, and try once more before giving up. <br>    // <br>    if (w) { <br>sndPlaySound(NULL, 0); <br>w = waveOutOpen(&amp;shWaveOut, WAVE_MAPPER, lpFormat, <br>(DWORD) (UINT) hwnd, 0L, CALLBACK_WINDOW); <br>    } <br> <br>//    DPF("waveOutOpen returns %u, shWaveOut = %u\n", w, shWaveOut); <br> <br>    if (w != 0) { <br>/* Show error message here? */ <br> <br>return FALSE; <br>    } <br> <br>    for (swBuffers = 0; swBuffers &lt; MAX_AUDIO_BUFFERS; swBuffers++) { <br>if (!(salpAudioBuf[swBuffers] = <br>(LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, <br>(DWORD)(sizeof(WAVEHDR) + AUDIO_BUFFER_SIZE)))) <br>    break; <br>salpAudioBuf[swBuffers]-&gt;dwFlags = WHDR_DONE; <br>salpAudioBuf[swBuffers]-&gt;lpData = (LPBYTE) salpAudioBuf[swBuffers] <br>    + sizeof(WAVEHDR); <br>salpAudioBuf[swBuffers]-&gt;dwBufferLength = AUDIO_BUFFER_SIZE; <br>if (!waveOutPrepareHeader(shWaveOut, salpAudioBuf[swBuffers], <br>sizeof(WAVEHDR))) <br>    continue; <br> <br>GlobalFreePtr((LPBYTE) salpAudioBuf[swBuffers]); <br>break; <br>    } <br> <br>    // DPF("Allocated %u %lu-byte buffers.\n", swBuffers, (DWORD) AUDIO_BUFFER_SIZE); <br> <br>    if (swBuffers &lt; MIN_AUDIO_BUFFERS) { <br>aviaudioCloseDevice(); <br>return FALSE; <br>    } <br> <br>    swBuffersOut = 0; <br>    swNextBuffer = 0; <br> <br>    sfPlaying = FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>// <br>// Return the time in milliseconds corresponding to the currently playing <br>// audio sample, or -1 if no audio is playing. <br>// WARNING: Some sound cards are pretty inaccurate! <br>// <br>LONG aviaudioTime(void) <br>{ <br>    MMTIMEmmtime; <br> <br>    if (!sfPlaying) <br>return -1; <br> <br>    mmtime.wType = TIME_SAMPLES; <br> <br>    waveOutGetPosition(shWaveOut, &amp;mmtime, sizeof(mmtime)); <br> <br>    if (mmtime.wType == TIME_SAMPLES) <br>return AVIStreamSampleToTime(spavi, slBegin) <br>+ muldiv32(mmtime.u.sample, 1000, sdwSamplesPerSec); <br>    else if (mmtime.wType == TIME_BYTES) <br>return AVIStreamSampleToTime(spavi, slBegin) <br>+ muldiv32(mmtime.u.cb, 1000, sdwBytesPerSec); <br>    else <br>return -1; <br>} <br> <br> <br>// <br>// Fill up any empty audio buffers and ship them out to the device. <br>// <br>BOOL aviaudioiFillBuffers(void) <br>{ <br>    LONGlRead; <br>    UINTw; <br>    LONGlSamplesToPlay; <br> <br>    /* We're not playing, so do nothing. */ <br>    if (!sfPlaying) <br>return TRUE; <br> <br>    // DPF3("%u/%u (%lu-%lu)\n", swBuffersOut, swBuffers, slCurrent, slEnd); <br> <br>    while (swBuffersOut &lt; swBuffers) { <br>if (slCurrent &gt;= slEnd) { <br>    if (sfLooping) { <br>/* Looping, so go to the beginning. */ <br>slCurrent = slBegin; <br>    } else <br>break; <br>} <br> <br>/* Figure out how much data should go in this buffer */ <br>lSamplesToPlay = slEnd - slCurrent; <br>if (lSamplesToPlay &gt; AUDIO_BUFFER_SIZE / slSampleSize) <br>    lSamplesToPlay = AUDIO_BUFFER_SIZE / slSampleSize; <br> <br> <br>AVIStreamRead(spavi, slCurrent, lSamplesToPlay, <br>      salpAudioBuf[swNextBuffer]-&gt;lpData, <br>      AUDIO_BUFFER_SIZE, <br>      &amp;(LONG)salpAudioBuf[swNextBuffer]-&gt;dwBufferLength, <br>      &amp;lRead); <br> <br>if (lRead != lSamplesToPlay) { <br>    // DPF("Error from WAVE_READ\n"); <br>    return FALSE; <br>} <br>slCurrent += lRead; <br> <br>w = waveOutWrite(shWaveOut, salpAudioBuf[swNextBuffer],sizeof(WAVEHDR)); <br> <br>if (w != 0) { <br>    // DPF("Error from waveOutWrite\n"); <br>    return FALSE; <br>} <br> <br>++swBuffersOut; <br>++swNextBuffer; <br>if (swNextBuffer &gt;= swBuffers) <br>    swNextBuffer = 0; <br>    } <br> <br>    if (swBuffersOut == 0 &amp;&amp; slCurrent &gt;= slEnd) <br>aviaudioStop(); <br> <br>    /* We've filled all of the buffers we can or want to. */ <br>    return TRUE; <br>} <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioPlay -- Play audio, starting at a given frame| <br>|| <br>+--------------------------------------------------------------*/ <br>BOOL aviaudioPlay(HWND hwnd, PAVISTREAM pavi, LONG lStart, LONG lEnd, BOOL fWait) <br>{ <br>    if (lStart &lt; 0) <br>lStart = AVIStreamStart(pavi); <br> <br>    if (lEnd &lt; 0) <br>lEnd = AVIStreamEnd(pavi); <br> <br>    // DPF2("Audio play%s from %ld to %ld (samples)\n", ((LPSTR) (fWait ? " wait" : "")), lStart, lEnd); <br> <br>    if (lStart &gt;= lEnd) <br>return FALSE; <br> <br>    if (!aviaudioOpenDevice(hwnd, pavi)) <br>return FALSE; <br> <br>    if (!sfPlaying) { <br> <br>// <br>// We're beginning play, so pause until we've filled the buffers <br>// for a seamless start <br>// <br>waveOutPause(shWaveOut); <br> <br>slBegin = lStart; <br>slCurrent = lStart; <br>slEnd = lEnd; <br>sfPlaying = TRUE; <br>    } else { <br>if (lStart &gt; slEnd) { <br>    // DPF("Gap in wave that is supposed to be played!\n"); <br>} <br>slEnd = lEnd; <br>    } <br> <br>//    sfLooping = fLoop; <br> <br>    aviaudioiFillBuffers(); <br> <br>    // <br>    // Now unpause the audio and away it goes! <br>    // <br>    waveOutRestart(shWaveOut); <br> <br>    // <br>    // Caller wants us not to return until play is finished <br>    // <br>    if (fWait) { <br>while (swBuffersOut &gt; 0) <br>    Yield(); <br>    } <br> <br>    return TRUE; <br>} <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioMessage -- handle wave messages received by| <br>| window controlling audio playback.  When audio buffers are| <br>| done, this routine calls aviaudioiFillBuffers to fill them| <br>| up again.| <br>+--------------------------------------------------------------*/ <br>void aviaudioMessage(HWND hwnd, unsigned msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    if (msg == MM_WOM_DONE) { <br>--swBuffersOut; <br>aviaudioiFillBuffers(); <br>    } <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| aviaudioStop -- stop playing, close the device.| <br>+--------------------------------------------------------------*/ <br>void aviaudioStop(void) <br>{ <br>    UINTw; <br> <br>    if (shWaveOut != 0) { <br> <br>w = waveOutReset(shWaveOut); <br> <br>sfPlaying = FALSE; <br> <br>// DPF("AudioStop: waveOutReset() returns %u \n", w); <br> <br>aviaudioCloseDevice(); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
