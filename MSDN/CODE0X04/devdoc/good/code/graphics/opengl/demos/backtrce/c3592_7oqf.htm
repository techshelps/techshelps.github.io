<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCENE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3597"></a>SCENE.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>extern "C" { <br>#include &lt;GL/glaux.h&gt; <br>} <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/gl.h&gt; <br> <br>#ifdef GLX_MOTIF <br>#include &lt;GL/glx.h&gt; <br>#endif <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br> <br>#include "Unitdisk.hxx" <br>#include "scene.hxx" <br> <br>const GLfloat I[16] = { <br>                        1, 0, 0, 0, <br>                        0, 1, 0, 0, <br>                        0, 0, 1, 0, <br>                        0, 0, 0, 1 <br>                      }; <br> <br>Color white; <br>Color black; <br> <br>const double M_2PI      = 2.0 * M_PI; <br>const float scene_fudge = .000001; <br> <br> <br>// Lights are native to the xz plane and are rotated into position - <br>// shadows and refraction will not have to be changed if lights are <br>// just rotating about the z axis <br> <br>light lights[] = { <br>                  {{1, 0, 0, 1}, {0, 0, 0, 0}, {1, 0, 0, 0}, <br>                     {1, 0, 0, 0,  0, 1, 0, 0,   0, 0, 1, 0,   0, 0, 0, 1}, <br>                        "Red", 1}, <br>                  {{0, 1, 0, 1}, {0, 0, 0, 0}, {0, 1, 0, 0}, <br>                     {1, 0, 0, 0,  0, 1, 0, 0,   0, 0, 1, 0,   0, 0, 0, 1}, <br>                        "Green", 1}, <br>                  {{0, 0, 1, 1}, {0, 0, 0, 0}, {0, 0, 1, 0}, <br>                     {1, 0, 0, 0,  0, 1, 0, 0,   0, 0, 1, 0,   0, 0, 0, 1}, <br>                        "Blue", 1} <br>                 }; <br> <br>GLfloat light_init_position[nlights][4] = { <br>                                           {1.5, 0, 2.5, 1}, <br>                                           {1, 0, 3, 1}, <br>                                           {2, 0, 3, 1} <br>                                          }; <br> <br>GLfloat light_init_rotation[nlights] = {135, 0, 90}; <br>GLfloat light_rotation[nlights]; <br> <br>Color world_ambient(.25, .25, .25); <br> <br>GLfloat index = indices[def_refraction_index].index; <br> <br>GLfloat square_ambient[4]  = {.25, .25, .25, 1}; <br>GLfloat square_diffuse[4]  = {1, 1, 1, 1}; <br>GLfloat square_specular[4] = {0, 0, 0, 1}; <br> <br>const GLfloat fov          = 45.0; <br>GLfloat aspect             = 1.0; <br>GLfloat eyep[3]            = {-6, 0, 6}; <br>GLfloat lookp[3]           = {0, 0, 1}; <br> <br> <br>#ifdef GLX_MOTIF <br>static GLXContext glx_context; <br>#endif <br> <br>const int max_args = 20; <br> <br>static int list_square; <br>static int lists_shadows; <br>static int lists_refraction; <br>static int lists_lights    = 5; <br>static int list_sphere     = 4; <br>static int list_spheredisk = 9; <br>static int list_lights_on  = 6; <br>static int list_lights_off = 7; <br>static int list_light_draw = 8; <br> <br>int draw_square     = 1; <br>int draw_shadows    = 1; <br>int draw_refraction = 1; <br>int draw_sphere     = 1; <br>int draw_lights     = 1; <br>int draw_texture    = 0; <br> <br>int possible_divisions[] = {10, 20, 30, 40}; <br> <br>// Sphere is stored as floats - more efficient <br>GLfloat *spherepts = NULL; <br>int nspherepts     = 0; <br>int spherediv      = 0; <br>Point sphere_position = {0, 0, 1, 1}; <br>GLfloat sphere_size   = .5; <br>const GLfloat sphere_ambient[4]  = {0, 0, 0, 0}; <br>const GLfloat sphere_specular[4] = {0, 0, 0, 0}; <br>Unitdisk sphere_disk; <br>static void sphere_build(); <br>static void sphere_list_init(); <br>static void sphere_draw(); <br> <br>static void square_list_init(); <br> <br>static void lights_init_onoff(); <br>static void lights_init_position(); <br>static void lights_init_position(int i); <br>static void lights_list_init(); <br>static void lights_list_init(int n); <br> <br>static void light_draw_list_init(); <br> <br>Unitdisk disks[nlights]; <br>int diskdiv = possible_divisions[def_divisions_index]; <br>static void disk_build(); <br>static void disk_build(int disk); <br> <br> <br>Unitdisk shadows[nlights]; <br>static void shadow_list_init(); <br>static void shadow_list_init(int n); <br>static void shadow_draw(int n); <br> <br>Unitdisk refraction[nlights]; <br>static void refraction_list_init(); <br>static void refraction_list_init(int n); <br> <br>static void shadow_refraction_full_build(); <br>static void shadow_refraction_full_build(int n); <br> <br>void scene_init(); <br> <br> <br> <br>#ifdef MYDEBUG <br>void lists_init(); <br>void lights_init(); <br>int  lights_move(int light, float dr, float dphi, float dtheta, <br>       int update); <br> <br>void lights_move_update(int light, int dr, int dphi, int dtheta); <br>#else <br>static void lists_init(); <br>static void lights_init(); <br>static int lights_move(int light, float dr, float dphi, float dtheta, <br>       int update); <br>static void lights_move_update(int light, int dr, int dphi, int dtheta); <br>#endif <br> <br> <br>void scene_draw(); <br> <br>void texture_init(); <br>AUX_RGBImageRec *teximage = NULL; <br> <br>inline float sign(float a)  <br>{ <br>  // This is badly written so let's not call it too often, 'k? <br>  return (a &gt; 0) ? (float)1 : (a &lt; 0) ? (float) -1 : (float) 0; <br>} <br> <br>inline double degrees(double a) <br>{ <br>  return (a * 180.0 / M_PI); <br>} <br> <br>inline double radians(double a) <br>{ <br>  return (a * M_PI / 180.0); <br>} <br> <br>inline double degrees_clamp(double a) <br>{ <br>  while (a &lt; 0.0) a += 360.0; <br>  while (a &gt; 360.0) a -= 360.0; <br>  return a; <br>} <br> <br>inline double radians_clamp(double a) <br>{ <br>  while (a &lt; 0.0) a += M_2PI; <br>  while (a &gt; M_2PI) a -= M_2PI; <br>  return a; <br>} <br> <br>void scene_init() <br>{ <br>  int i; <br> <br>  white.c[0] = white.c[1] = white.c[2] = white.c[3] = 1; <br>  black.c[0] = black.c[1] = black.c[2] = 0; <br>  black.c[3] = 1; <br> <br>  lists_init(); <br> <br> <br>  for (i = 0; i &lt; nlights; i++) { <br>    lights[i].pos = light_init_position[i]; <br>    light_rotation[i] = light_init_rotation[i]; <br>    lights_init_position(i); <br>  } <br> <br>  divisions_change(possible_divisions[def_divisions_index]); <br> <br>  lights_init_onoff(); <br>  lights_init(); <br>  lights_init_position(); <br> <br>  texture_init(); <br> <br>  glClearStencil(0); <br> <br>  // This is for profiling <br>  // exit(0); <br>} <br> <br>static void scene_project() <br>{ <br>  glMatrixMode(GL_PROJECTION); <br>  gluPerspective(fov, aspect, 0.01, 20.0); <br>  gluLookAt(eyep[0], eyep[1], eyep[2], lookp[0], lookp[1], lookp[2], <br>            1, 0, 0); <br>} <br> <br>static void scene_rasterize() <br>{ <br>  int i; <br> <br>  glLoadName(name_square); <br>  if (draw_square) { <br>    if (draw_texture) glEnable(GL_TEXTURE_2D); <br>    glCallList(list_square); <br>    glDisable(GL_TEXTURE_2D); <br>  } <br>  if (draw_shadows)  <br>    for (i = 0; i &lt; nlights; i++)  <br>      if (lights[i].on) { <br>glPushMatrix(); <br>glRotatef(-light_rotation[i], 0, 0, 1); <br>glCallList(lists_shadows + i); <br>glPopMatrix(); <br>      } <br>  if (draw_refraction)  <br>    for (i = 0; i &lt; nlights; i++)  <br>      if (lights[i].on) { <br>glPushMatrix(); <br>glRotatef(-light_rotation[i], 0, 0, 1); <br>glCallList(lists_refraction + i); <br>glPopMatrix(); <br>      } <br> <br>  glLoadName(name_sphere); <br>  /* Drawing the sphere here makes the sphere visible through itself when we <br>   * do the refraction redraw hack -- for now, just don't draw it */ <br>  //  if (draw_sphere) glCallList(list_sphere); <br> <br>  for (i = 0; i &lt; nlights; i++)  <br>    if (draw_lights) glCallList(lists_lights + i); <br>} <br> <br>/* This draws an image of the scene seen through the sphere */ <br>static void scene_draw_refracted() <br>{ <br>  int i; <br> <br>  if (!draw_sphere) return; <br> <br> <br>  /* Draw an image of the sphere into the stencil plane  -  <br>   * must do this every time in case the lights have moved in front <br>   * of it */ <br>  glEnable(GL_STENCIL_TEST); <br>  glClearStencil(0); <br>  glClear(GL_STENCIL_BUFFER_BIT); <br>  glStencilFunc(GL_ALWAYS, 0x1, 0x1); <br>  glStencilOp(GL_REPLACE, GL_KEEP, GL_REPLACE); <br>   <br>  glColorMask(0, 0, 0, 0); <br> <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>  scene_project(); <br> <br>  glEnable(GL_DEPTH_TEST); <br>  glEnable(GL_CULL_FACE); <br>  glCallList(list_sphere); <br>  glDisable(GL_CULL_FACE); <br>  glDisable(GL_DEPTH_TEST); <br> <br>  glColorMask(1, 1, 1, 1); <br> <br> <br>  /* Set up a transform with a wider field of view  - this is inaccurate  <br>   * but I don't have time to do it right */ <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>  gluPerspective(fov * index, aspect, 0.01, 20.0); <br>  gluLookAt(eyep[0], eyep[1], eyep[2], lookp[0], lookp[1], lookp[2], <br>            1, 0, 0); <br>  glMatrixMode(GL_MODELVIEW); <br>  glLoadIdentity(); <br> <br> <br>  /* Set up the stencil stuff which will be used to draw the image */ <br>  glStencilFunc(GL_NOTEQUAL, 0x0, 0xffffffff); <br>  glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); <br> <br> <br>  /* Draw the image, gambling that we'll never see anything but the <br>   * floor through the table */ <br>  glLoadName(name_sphere); <br>  if (draw_texture) glEnable(GL_TEXTURE_2D); <br>  if (draw_square) glCallList(list_square); <br>  if (draw_shadows)      <br>    for (i = 0; i &lt; nlights; i++)  <br>      if (lights[i].on) { <br>glPushMatrix(); <br>glRotatef(-light_rotation[i], 0, 0, 1); <br>glCallList(lists_shadows + i); <br>glPopMatrix(); <br>      } <br>  if (draw_refraction)  <br>    for (i = 0; i &lt; nlights; i++)  <br>      if (lights[i].on) { <br>glPushMatrix(); <br>glRotatef(-light_rotation[i], 0, 0, 1); <br>glCallList(lists_refraction + i); <br>glPopMatrix(); <br>      } <br>  glDisable(GL_TEXTURE_2D); <br> <br> <br>  /* Draw the sphere to make it look like it <br>   * has some substance */ <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>  scene_project(); <br>  glCallList(list_spheredisk); <br> <br>  glDisable(GL_STENCIL_TEST); <br>} <br> <br> <br>void scene_draw()  <br>{ <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br> <br>  glMatrixMode(GL_MODELVIEW); <br>  glLoadIdentity(); <br> <br>  scene_project(); <br> <br>  /* Should draw an image of the square into the stencil buffer  <br>   * to make sure that refractions which are not on the square do not get <br>   * drawn, but it can wait. */ <br> <br>  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <br>  scene_rasterize(); <br> <br>  scene_draw_refracted(); <br> <br>} <br> <br>const int pick_maxz = 0xffffffff; <br> <br>int scene_pick(GLdouble x, GLdouble y) <br>{ <br>  GLuint buffer[128]; <br>  GLint vp[4], nhits, nnames; <br>  GLuint minz, hit = name_background; <br>  GLint i, j; <br>   <br>  glMatrixMode(GL_MODELVIEW); <br>  glLoadIdentity(); <br>   <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>   <br>  glGetIntegerv(GL_VIEWPORT, vp); <br>   <br>  glSelectBuffer(128, buffer); <br>  glRenderMode(GL_SELECT); <br> <br>  // Where is this supposed to go, anyway? <br>  gluPickMatrix(x, vp[3] - y, 1, 1, vp); <br>   <br>  scene_project(); <br> <br>  glMatrixMode(GL_MODELVIEW); <br> <br>  glInitNames(); <br>  glPushName(name_background); <br>  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <br>  scene_rasterize(); <br>  glFlush(); <br>  nhits = glRenderMode(GL_RENDER); <br> <br>  minz = pick_maxz; <br>  for (i = j = 0; j &lt; nhits; j++) { <br>    nnames = buffer[i]; <br>    i++; <br>    if (buffer[i] &lt; minz) { <br>      minz = buffer[i]; <br>      hit = buffer[i + 1 + nnames]; <br>    }  <br>    i++; <br>    i += nnames + 1; <br>  } <br>  if (minz == pick_maxz) return name_background; <br>  else return hit; <br>} <br> <br>void scene_reset_lights()  <br>{ <br>  int i; <br>  for (i = 0; i &lt; nlights; i++) { <br>    lights[i].pos = light_init_position[i]; <br>    light_rotation[i] = light_init_rotation[i]; <br>  } <br>  lights_init_position(); <br>  lights_list_init(); <br>} <br> <br>static void square_list_init() <br>{ <br>  GLfloat x, y, inc; <br>  int i, j;   <br>  glNewList(list_square, GL_COMPILE); <br>  glLoadName(name_square); <br>  glNormal3f(0, 0, 1); <br>  glEnable(GL_LIGHTING); <br>  glCallList(list_lights_on); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, square_ambient); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, square_diffuse); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, square_specular); <br>  inc = (GLfloat) (10.0 / diskdiv); <br>  glEnable(GL_CULL_FACE); <br> <br>  for (i = 0, y = -5.0; i &lt; diskdiv; i++, y += inc) { <br>    glBegin(GL_TRIANGLE_STRIP); <br>    for (j = 0, x = -5.0; j &lt;= diskdiv; j++, x += inc) { <br>      glTexCoord2f(x, y + inc); <br>      glVertex2f(x, y + inc); <br>      glTexCoord2f(x, y); <br>      glVertex2f(x, y); <br>    } <br>    glEnd(); <br>  } <br> <br>  glDisable(GL_CULL_FACE); <br>  glCallList(list_lights_off); <br>  glDisable(GL_LIGHTING); <br>  glEndList(); <br>} <br> <br>static void spheredisk_list_init() <br>{ <br>  glNewList(list_spheredisk, GL_COMPILE); <br>  glEnable(GL_BLEND); <br>  glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA); <br>  glEnable(GL_LIGHTING); <br>  glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE); <br>  glEnable(GL_COLOR_MATERIAL); <br>  glMaterialfv(GL_AMBIENT, GL_FRONT_AND_BACK, sphere_ambient); <br>  glMaterialfv(GL_SPECULAR, GL_FRONT_AND_BACK, sphere_specular); <br>  glCallList(list_lights_on); <br>  sphere_disk.draw(); <br>  glCallList(list_lights_off); <br>  glDisable(GL_COLOR_MATERIAL); <br>  glDisable(GL_LIGHTING); <br>  glDisable(GL_BLEND); <br>  glEndList(); <br>} <br> <br>void lights_onoff(int light, int val) <br>{ <br>  lights[light].on = val; <br>  lights_init_onoff(); <br>  lights_list_init(light); <br>  square_list_init(); <br>} <br> <br>void refraction_change(GLfloat refraction) <br>{ <br>  if (refraction == index) return; <br>  index = refraction; <br>  shadow_refraction_full_build(); <br>  refraction_list_init(); <br>} <br> <br>void divisions_change(int divisions) <br>{ <br>  Point eye, look; <br> <br>  if (divisions != spherediv) { <br>    spherediv = divisions; <br> <br>    light_draw_list_init(); <br>    lights_list_init(); <br> <br>    sphere_disk.set_divisions(spherediv, spherediv); <br>    sphere_disk.fill_points(); <br>    sphere_disk.set_colors(white); <br>    sphere_disk.scale_alpha_by_z(); <br>    eye = eyep; <br>    look = lookp; <br>    sphere_disk.face_direction((eye - look).unit()); <br>    sphere_disk.copy_normals_from_points(); <br>    sphere_disk.scale_translate(sphere_size, sphere_position); <br>    sphere_build(); <br>    sphere_list_init(); <br> <br>    diskdiv = divisions; <br>    disk_build(); <br>    shadow_refraction_full_build(); <br>    square_list_init(); <br>    spheredisk_list_init(); <br>    shadow_list_init(); <br>    refraction_list_init(); <br>  } <br>} <br> <br>int scene_move(int name, float dr, float dphi, float dtheta, int update) <br>{ <br>  switch(name) { <br>  case name_background: <br>    return 0; <br>  case name_square: <br>    return 0; <br>  case name_sphere: <br>    return 0; <br>  default: <br>    if (name &lt; name_lights || name &gt; name_lights + nlights) return 0; <br>    return lights_move(name - name_lights, dr, dphi, dtheta, update); <br>  } <br>} <br> <br>void scene_move_update(int name, int dr, int dphi, int dtheta) <br>{ <br>  switch(name) { <br>  case name_background: <br>    break; <br>  case name_square: <br>    break; <br>  case name_sphere: <br>    break; <br>  default: <br>    if (name &lt; name_lights || name &gt; name_lights + nlights) break; <br>    lights_move_update(name - name_lights, dr, dphi, dtheta); <br>    break; <br>  } <br>} <br> <br>#ifdef MYDEBUG <br>void lights_init_onoff() <br>#else <br>static void lights_init_onoff() <br>#endif <br>{ <br>  int i; <br>   <br>  glNewList(list_lights_on, GL_COMPILE); <br>  for (i = 0; i &lt; nlights; i++)  <br>    if (lights[i].on) glEnable(GL_LIGHT0 + i); <br>    else glDisable(GL_LIGHT0 + i); <br>  glEndList(); <br>   <br>  glNewList(list_lights_off, GL_COMPILE); <br>  for (i = 0; i &lt; nlights; i++) glDisable(GL_LIGHT0 + i); <br>  glEndList(); <br>} <br> <br>  <br>#ifdef MYDEBUG <br>void lights_init_position() <br>#else <br>static void lights_init_position() <br>#endif <br>{ <br>  int i; <br> <br>  for (i = 0; i &lt; nlights; i++) lights_init_position(i); <br> <br>} <br> <br>static void lights_init_position(int i)  <br>{ <br>  Point l, d; <br> <br>  glMatrixMode(GL_MODELVIEW); <br>  glLoadIdentity(); <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>   <br>  l = lights[i].pos; <br>  l.pt[0] = (GLfloat)(lights[i].pos.pt[0] * cos((double)radians(light_rotation[i]))); <br>  l.pt[1] = (GLfloat)(lights[i].pos.pt[0] * -sin((double)radians(light_rotation[i]))); <br>  d = (sphere_position - l).unit(); <br>  glLightfv(GL_LIGHT0 + i, GL_POSITION, l.pt); <br>  glLightfv(GL_LIGHT0 + i, GL_SPOT_DIRECTION, d.pt); <br>} <br> <br>static void lights_list_init() <br>{ <br>  int i; <br>  for (i = 0; i &lt; nlights; i++) lights_list_init(i); <br>} <br> <br>static void lights_list_init(int n) <br>{ <br>  Color c; <br> <br>  glNewList(lists_lights + n, GL_COMPILE); <br>  if (lights[n].on) { <br>    glLoadName(name_lights + n); <br>     <br>    glEnable(GL_DEPTH_TEST); <br>    glEnable(GL_LIGHTING); <br>    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 1); <br>    glCallList(list_lights_on); <br> <br>    c = lights[n].diffuse; <br>    glMaterialfv(GL_BACK, GL_AMBIENT, c.c); <br>    glMaterialfv(GL_BACK, GL_DIFFUSE, black.c); <br>    glMaterialfv(GL_BACK, GL_SPECULAR, black.c); <br> <br>    glMaterialfv(GL_FRONT, GL_AMBIENT, (c * .75).c); <br>    glMaterialfv(GL_FRONT, GL_DIFFUSE, white.c); <br>    glMaterialfv(GL_FRONT, GL_SPECULAR, white.c); <br> <br>    glMatrixMode(GL_MODELVIEW); <br>    glPushMatrix(); <br>    glRotatef(-light_rotation[n], 0, 0, 1); <br>    glTranslatef(lights[n].pos.pt[0], lights[n].pos.pt[1],  <br> lights[n].pos.pt[2]); <br>    glRotatef((GLfloat)-degrees(atan2((double)(lights[n].pos.pt[2] - sphere_position.pt[2]), <br>     (double)(lights[n].pos.pt[0]))), 0, 1, 0); <br>    glCallList(list_light_draw); <br>    glPopMatrix(); <br> <br>    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0); <br>    glDisable(GL_LIGHTING); <br>    glCallList(list_lights_off); <br>    glDisable(GL_DEPTH_TEST); <br>  } else { <br>    /* 5.0.1 for Elans seems to object strongly to replacing <br>     * empty display lists, so will put some stupid command <br>     * in here */ <br>    glColor3f(0, 0, 0); <br>  } <br>  glEndList(); <br>} <br> <br>static void light_draw_list_init() <br>{ <br>  float c, s; <br>  int t; <br> <br>  glNewList(list_light_draw, GL_COMPILE); <br>  glEnable(GL_NORMALIZE); <br>  glMatrixMode(GL_MODELVIEW); <br>  glPushMatrix(); <br>  glScalef(.25, .15, .15); <br>  glBegin(GL_QUAD_STRIP); <br>  for (t = 0; t &lt;= spherediv; t++) { <br>    c = (float) cos((double)(M_2PI * (float)t / (float)spherediv)); <br>    s = (float) sin((double)(M_2PI * (float)t / (float)spherediv)); <br>    glNormal3f((GLfloat).25, (GLfloat)(.968*s), (GLfloat)(.968*c)); <br>    glVertex3f((GLfloat)0, (GLfloat)s, (GLfloat)c); <br>    glVertex3f((GLfloat)1, (GLfloat)(.75*s), (GLfloat)(.75*c)); <br>  } <br>  glEnd(); <br>  glNormal3f(1, 0, 0); <br>  glBegin(GL_TRIANGLE_STRIP); <br>  for (t = 0; t &lt;= spherediv; t++) { <br>    c = (float)cos((double)(M_2PI * (float)t / (float)spherediv)); <br>    s = (float)sin((double)(M_2PI * (float)t / (float)spherediv)); <br>    glVertex3f((GLfloat)1, (GLfloat)(.75*s), (GLfloat)(.75*c)); <br>    glVertex3f(1, 0, 0); <br>  } <br>  glEnd(); <br>  glPopMatrix(); <br>  glDisable(GL_NORMALIZE); <br>  glEndList(); <br>} <br> <br> <br>#ifdef MYDEBUG <br>void lights_init() <br>#else <br>static void lights_init() <br>#endif <br>{ <br>  int i; <br> <br>  for (i = 0; i &lt; nlights; i++) { <br>    glLightfv(GL_LIGHT0 + i, GL_DIFFUSE, lights[i].diffuse); <br>    glLightfv(GL_LIGHT0 + i, GL_SPECULAR, black.c); <br>    glLightfv(GL_LIGHT0 + i, GL_AMBIENT, black.c); <br>    glLightf(GL_LIGHT0 + i, GL_SPOT_EXPONENT, 4); <br>    glLightf(GL_LIGHT0 + i, GL_SPOT_CUTOFF, 90); <br>  } <br> <br>  glLightfv(GL_LIGHT0 + nlights, GL_DIFFUSE, black.c); <br>  glLightfv(GL_LIGHT0 + nlights, GL_SPECULAR, black.c); <br>  glLightfv(GL_LIGHT0 + nlights, GL_AMBIENT, world_ambient.c); <br>  glEnable(GL_LIGHT0 + nlights); <br> <br>  /* GL_LIGHT0 + nlights + 1 willl eventually be used to draw the  <br>   * refractions - stay tuned. */ <br>  glLightfv(GL_LIGHT0 + nlights + 1, GL_DIFFUSE, black.c); <br>  glLightfv(GL_LIGHT0 + nlights + 1, GL_SPECULAR, black.c); <br>  glLightfv(GL_LIGHT0 + nlights + 1, GL_AMBIENT, white.c); <br>} <br> <br>#ifdef MYDEBUG <br>int lights_move(int light, float dr, float dphi, float dtheta, <br>#else <br>static int lights_move(int light, float dr, float dphi, float dtheta, <br> <br>#endif <br>                       int update) <br>{ <br>  float cphi, sphi, x, y; <br>  Point l, dl; <br> <br>  if (!(dr || dphi || dtheta)) return 0; <br> <br>  l = lights[light].pos - sphere_position; <br> <br>  if (dr) { <br>    dl = l + l*dr; <br>    if (dl.mag() &gt; sphere_size) l = dl; <br>  } <br>   <br>  if (dphi) { <br>    cphi = (float)cos((double)dphi); <br>    sphi = (float)sin((double)dphi); <br>    y = -l.pt[0]*sphi + l.pt[2]*cphi; <br>     <br>    /* This hack keeps with light from getting below the sphere -  <br>     * the projection sections would completely freak if this ever <br>     * happened  - sphere_size is multiplied by two as a fudge factor*/ <br>    if (y &lt; 2.0*sphere_size) { <br>      dphi = (float)atan2((double)(l.pt[2] - 2.0*sphere_size), (double)l.pt[0]); <br>      cphi = (float)cos((double)dphi); <br>      sphi = (float)sin((double)dphi); <br>       <br>    } <br>    x = l.pt[0]; <br>    l.pt[0] = x*cphi + l.pt[2]*sphi; <br>    l.pt[2] = -x*sphi + l.pt[2]*cphi; <br>  } <br> <br>  if (dtheta) { <br>    light_rotation[light] += (GLfloat)degrees((double)dtheta); <br>    light_rotation[light] =  (GLfloat)degrees_clamp((double)light_rotation[light]); <br>  } <br> <br>  lights[light].pos = l + sphere_position; <br>  lights[light].pos.pt[3] = 1; <br> <br>  lights_init_position(light); <br>  lights_list_init(light); <br> <br>  if (update) lights_move_update(light, dr ? 1 : 0, dphi ? 1 : 0,  <br> dtheta ? 1 : 0); <br>  return 1; <br>} <br> <br>#ifdef MYDEBUG <br>void lights_move_update(int light, int dr, int dphi, <br>#else <br>static void lights_move_update(int light, int dr, int dphi, <br>#endif <br>       int dtheta) <br>{ <br>  if (dr) { <br>    disk_build(light); <br>    shadow_refraction_full_build(light); <br>    shadow_list_init(light); <br>    refraction_list_init(light);   <br>  } else if (dphi) { <br>    shadow_refraction_full_build(light); <br>    shadow_list_init(light); <br>    refraction_list_init(light); <br>  } else if (dtheta) { <br>  } <br> <br>} <br> <br> <br> <br>#ifdef MYDEBUG <br>int get_lists(int size) <br>#else <br>static int get_lists(int size) <br>#endif <br>{ <br>  int i; <br>  i = glGenLists(size); <br>  if (size &amp;&amp; !i) { <br>    //fprintf(stderr, "Unable to allocate %d display lists.\n"); <br>    exit(1); <br>  } <br>  return i; <br>} <br> <br>#ifdef MYDEBUG <br>void lists_init() <br>#else <br>static void lists_init() <br>#endif <br>{ <br>  list_square = get_lists(1); <br>  lists_shadows = get_lists(nlights); <br>  lists_refraction = get_lists(nlights); <br>  lists_lights = get_lists(nlights); <br>  list_sphere = get_lists(1); <br>  list_spheredisk = get_lists(1); <br>  list_lights_on = get_lists(1); <br>  list_lights_off = get_lists(1); <br>  list_light_draw = get_lists(1); <br>//  sphere_build(); <br>} <br> <br>static inline int sphere_npoints()  <br>{ <br>  return (spherediv+1)*spherediv*3; <br>} <br> <br>void sphere_build() <br>{ <br>  int nspherepts; <br>  int r, t, index; <br>  float c, s; <br>   <br>  delete spherepts; <br>  nspherepts = sphere_npoints(); <br>  if (nspherepts == 0) return; <br>  spherepts = new GLfloat[nspherepts]; <br> <br>  index = 0; <br>  for (r = 0; r &lt;= spherediv; r++) { <br>    spherepts[index++] = (GLfloat)sin((double)(M_PI * (float)r / (float)spherediv)); <br>    spherepts[index++] = 0; <br>    spherepts[index++] = (GLfloat)-cos((double)(M_PI * (float)r / (float)spherediv)); <br>  } <br>  for (t = 1; t &lt; spherediv; t++) { <br>    c = (float)cos((double)(2.0 * M_PI * (float)t / (float)spherediv)); <br>    s = (float)sin((double)(2.0 * M_PI * (float)t / (float)spherediv)); <br>    for (r = 0; r &lt;= spherediv; r++) { <br>      spherepts[index++] = c*spherepts[r*3]; <br>      spherepts[index++] = s*spherepts[r*3]; <br>      spherepts[index++] = spherepts[r*3 + 2]; <br>    } <br>  } <br> <br>} <br> <br>void sphere_list_init() <br>{ <br>  glNewList(list_sphere, GL_COMPILE); <br>  sphere_disk.draw_by_perimeter(); <br>  glEndList(); <br>}   <br> <br>void sphere_draw() <br>{ <br>  int r, t, p1, p2; <br> <br>  for (t = 1; t &lt; spherediv; t++) { <br>    glBegin(GL_QUAD_STRIP); <br>    p1 = (t - 1) * (spherediv + 1); <br>    p2 = t * (spherediv + 1); <br>    for (r = 0; r &lt;= spherediv; r++, p1++, p2++) { <br>      glNormal3fv(&amp;spherepts[p1*3]); <br>      glVertex3fv(&amp;spherepts[p1*3]); <br>      glNormal3fv(&amp;spherepts[p2*3]); <br>      glVertex3fv(&amp;spherepts[p2*3]); <br>    } <br>    glEnd(); <br>  } <br> <br>  glBegin(GL_QUAD_STRIP);  <br>  p1 = (spherediv + 1) * (spherediv - 1); <br>  p2 = 0; <br>  for (r = 0; r &lt;= spherediv; r++, p1++, p2++) { <br>    glNormal3fv(&amp;spherepts[p1*3]); <br>    glVertex3fv(&amp;spherepts[p1*3]); <br>    glNormal3fv(&amp;spherepts[p2*3]); <br>    glVertex3fv(&amp;spherepts[p2*3]); <br>  } <br>  glEnd(); <br>} <br> <br>static void disk_build() <br>{ <br>  int i; <br>  for (i = 0; i &lt; nlights; i++) disk_build(i); <br>} <br> <br>static void disk_build(int disk) <br>{ <br>  Point light; <br>  light = lights[disk].pos; <br> <br>  disks[disk].free_points_normals(); <br>  disks[disk].free_colors(); <br> <br>  disks[disk].set_divisions(diskdiv, diskdiv); <br>  disks[disk].set_angle((float)(2.0 * <br>acos((double)(sphere_size / light.dist(sphere_position))))); <br>  disks[disk].fill_points(); <br>} <br> <br>static void shadow_list_init() <br>{ <br>  int i; <br>  for (i = 0; i &lt; nlights; i++) shadow_list_init(i); <br>} <br> <br>static void shadow_list_init(int n) <br>{ <br>  Color c(square_ambient[0], square_ambient[1], square_ambient[2]); <br> <br>  c *= world_ambient; <br> <br>  glNewList(lists_shadows + n, GL_COMPILE); <br>  glColorMask(lights[n].shadow_mask[0], lights[n].shadow_mask[1], <br>      lights[n].shadow_mask[2], lights[n].shadow_mask[3]); <br>  glDisable(GL_DEPTH_TEST); <br>  glColor3fv(c.c); <br>  shadows[n].draw_by_perimeter(0, 0, 1); <br>  glColorMask(1, 1, 1, 1); <br>  glEndList(); <br>} <br> <br>static void refraction_list_init() <br>{ <br>  int i; <br>  for (i = 0; i &lt; nlights; i++) refraction_list_init(i); <br>} <br> <br>static void refraction_list_init(int n) { <br>  /* This could be loads simpler if it weren't for the texture mapping - <br>   * that's where all this weirdness with GL_LIGHT0 + nlights + 1 comes  <br>   * in */ <br>  glNewList(lists_refraction + n, GL_COMPILE); <br> <br>  glEnable(GL_LIGHTING); <br>  glCallList(list_lights_off); <br>  /* This is white ambient light */ <br>  glEnable(GL_LIGHT0 + nlights + 1); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, black.c); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, black.c); <br>  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT); <br>  glEnable(GL_COLOR_MATERIAL); <br> <br>  glBlendFunc(GL_ONE, GL_ONE); <br>  glEnable(GL_BLEND); <br> <br>  glDisable(GL_DEPTH_TEST); <br>  refraction[n].draw(); <br> <br>  glDisable(GL_BLEND); <br> <br>  glDisable(GL_COLOR_MATERIAL); <br>  glDisable(GL_LIGHT0 + nlights + 1); <br>  glDisable(GL_LIGHTING); <br> <br>  glEndList(); <br>} <br> <br>static void shadow_refraction_full_build() <br>{ <br>  int i; <br>  for (i = 0; i &lt; nlights; i++) shadow_refraction_full_build(i); <br>} <br> <br>/* This entire function is written a bit oddly... */ <br>static void shadow_refraction_full_build(int n) <br>{ <br>  Color c; <br>  float dist_light; <br>  Point dlight, zaxis; <br> <br>  /* Make sure that we're starting over from scratch */ <br>  shadows[n].free_points_normals(); <br>  shadows[n].free_colors(); <br>  refraction[n].free_points_normals(); <br>  refraction[n].free_colors(); <br> <br>  dlight = lights[n].pos - sphere_position; <br>  dist_light = dlight.mag(); <br>  dlight.unitize(); <br>  zaxis.pt[0] = 0; <br>  zaxis.pt[1] = 0; <br>  zaxis.pt[2] = 1; <br> <br>  shadows[n].set_divisions(disks[n].get_rdivisions(),  <br>   disks[n].get_tdivisions()); <br>  refraction[n].set_divisions(disks[n].get_rdivisions(),  <br>      disks[n].get_tdivisions()); <br> <br>  shadows[n].alloc_points(); <br>  shadows[n].face_direction(dlight, disks[n]); <br>  shadows[n].scale_translate(sphere_size, sphere_position); <br> <br>  c = square_diffuse; <br>  c *= lights[n].diffuse;  <br> <br>  refraction[n].copy_points(disks[n]); <br>  refraction[n].set_colors(c); <br>  refraction[n].scale_colors_by_z(); <br> <br>  refraction[n].scale(sphere_size); <br>  refraction[n].refract_normals(zaxis * dist_light, index); <br>  refraction[n].face_direction(dlight); <br> <br>  refraction[n].project_borrow_points(shadows[n]);   <br>  refraction[n].free_normals(); <br>  shadows[n].project(lights[n].pos); <br>  if (index != 1.0) refraction[n].scale_colors_by_darea(shadows[n]); <br>} <br> <br>int scene_load_texture(char *texfile) <br>{ <br>#ifdef TEXTURE <br>  teximage = auxRGBImageLoad(texfile); <br>#else <br>  teximage = NULL; <br>#endif <br> <br>  if (teximage == NULL) return 0; <br>  else return 1; <br>} <br> <br>void texture_init() <br>{ <br>  if (teximage == NULL) return; <br> <br>  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage-&gt;sizeX, teximage-&gt;sizeY, <br>    GL_RGB, GL_UNSIGNED_BYTE, teximage-&gt;data); <br> <br>  glMatrixMode(GL_TEXTURE); <br>  glLoadIdentity(); <br>  glRotatef(90, 0, 0, 1); <br>  /* This scales the texture so that it fits on the square */ <br>  glTranslatef(.5, .5, 0); <br>  glScalef(2, 2, 1); <br>  glMatrixMode(GL_MODELVIEW); <br> <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,  <br> GL_NEAREST_MIPMAP_NEAREST); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, <br> GL_LINEAR); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
