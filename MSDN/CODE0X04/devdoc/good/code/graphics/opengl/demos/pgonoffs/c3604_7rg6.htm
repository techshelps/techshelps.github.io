<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOFFSET.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3606"></a>TOFFSET.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: toffset.c <br>* <br>* Program demonstrating the Polygon Offset call.  <br>* <br>* Draws a quadric, first normally and then with polygon offset. <br>* <br>* Copyright 1994 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993, 1994 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;gl\glaux.h&gt; <br>#include "trackbal.h" <br> <br> <br>#define PI 3.141592654 <br>#define BLACK 0 <br>#define GRAY 128 <br>#define WHITE 255 <br>#define RD 0xA40000FF <br>#define WT 0xFFFFFFFF <br>#define brickImageWidth 16 <br>#define brickImageHeight 16 <br> <br>//static void CALLBACK ErrorHandler(unsigned long which); <br>static void Init(void ); <br> <br>static void CALLBACK Key_Left(void ); <br>static void CALLBACK Key_Right(void ); <br>static void CALLBACK Key_Up(void ); <br>static void CALLBACK Key_Down(void ); <br>static void CALLBACK Key_a(void ); <br>static void CALLBACK Key_A(void ); <br>static void CALLBACK Key_b(void ); <br>static void CALLBACK Key_c(void ); <br>static void CALLBACK Key_f(void ); <br>static void CALLBACK Key_g(void ); <br>static void CALLBACK Key_G(void ); <br>static void CALLBACK Key_h(void ); <br>static void CALLBACK Key_H(void ); <br>static void CALLBACK Key_i(void ); <br>static void CALLBACK Key_j(void ); <br>static void CALLBACK Key_J(void ); <br>static void CALLBACK Key_l(void ); <br>static void CALLBACK Key_L(void ); <br>static void CALLBACK Key_k(void ); <br>static void CALLBACK Key_K(void ); <br>static void CALLBACK Key_o(void ); <br>static void CALLBACK Key_p(void ); <br>static void CALLBACK Key_s(void ); <br>static void CALLBACK Key_S(void ); <br>static void CALLBACK Key_t(void ); <br>static void CALLBACK Key_z(void ); <br>static void CALLBACK Key_Z(void ); <br>static void CALLBACK Key_0(void ); <br>static void CALLBACK Key_1(void ); <br>static void CALLBACK Key_2(void ); <br>static void CALLBACK Key_3(void ); <br> <br>static void CALLBACK Reshape(int width,int height); <br>static void CALLBACK Draw( void );  <br>static unsigned long Args(int argc,char **argv ); <br> <br>GLenum rgb, doubleBuffer; <br> <br>GLint wWidth = 300, wHeight = 300; <br> <br>GLenum doDither = GL_TRUE; <br>GLenum shade = GL_TRUE; <br>GLenum texture = GL_TRUE; <br> <br>BOOL bPolyOffset = TRUE; <br> <br> <br>float factor=-1.0f, units=0.0f; <br> <br>float inc = 1.0f; <br>int polygonMode = GL_LINE; <br>GLenum polyFace = GL_FRONT; <br>float zTrans = -2.7; <br>BOOL bCullFace = FALSE; <br>BOOL bHiddenLine; <br> <br>GLint radius1, radius2; <br>GLdouble angle1, angle2; <br>GLint slices, stacks; <br>GLint height; <br>GLint whichQuadric; <br>GLUquadricObj *quadObj; <br> <br>GLubyte brickImage[brickImageWidth*brickImageHeight] = { <br>    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, <br>    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, <br>    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, <br>    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, <br>    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, <br>    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, <br>    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, <br>    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, <br>    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, <br>    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, <br>    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, <br>    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, <br>    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, <br>    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, <br>    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, <br>    RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD <br>}; <br>char *texFileName = 0; <br> <br> <br>static void UpdateInfo() <br>{ <br>    HWND hwnd = auxGetHWND(); <br>    char buf[100]; <br> <br>    sprintf( buf, "Factor = %4.1f, Units = %4.1f", factor, units ); <br>    SendMessage( hwnd, WM_SETTEXT, 0, (LPARAM)buf ); <br>} <br> <br>static void SetMaterial( bBlack ) <br>{ <br>    static float front_mat_shininess[] = {30.0}; <br>    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0}; <br>    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0}; <br>    static float back_mat_shininess[] = {50.0}; <br>    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0}; <br>    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0}; <br>    static float black_mat_shininess[] = {0.0}; <br>    static float black_mat_specular[] = {0.0, 0.0, 0.0, 0.0}; <br>    static float black_mat_diffuse[] = {0.0, 0.0, 0.0, 0.0}; <br>    static float ambient[] = {0.1, 0.1, 0.1, 1.0}; <br>    static float no_ambient[] = {0.0, 0.0, 0.0, 0.0}; <br>    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0}; <br>    static float lmodel_no_ambient[] = {0.0, 0.0, 0.0, 0.0}; <br> <br>    if( !bBlack ) { <br>        glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess); <br>        glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular); <br>        glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse); <br>        glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess); <br>        glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular); <br>        glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse); <br>        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient); <br>        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient); <br>    } else { <br>        glMaterialfv(GL_FRONT, GL_SHININESS, black_mat_shininess); <br>        glMaterialfv(GL_FRONT, GL_SPECULAR, black_mat_specular); <br>        glMaterialfv(GL_FRONT, GL_DIFFUSE, black_mat_diffuse); <br>        glMaterialfv(GL_BACK, GL_SHININESS, black_mat_shininess); <br>        glMaterialfv(GL_BACK, GL_SPECULAR, black_mat_specular); <br>        glMaterialfv(GL_BACK, GL_DIFFUSE, black_mat_diffuse); <br>        glLightfv(GL_LIGHT0, GL_AMBIENT, no_ambient); <br>        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_no_ambient); <br>    } <br>} <br> <br>static void Init(void) <br>{ <br>    static GLint colorIndexes[3] = {0, 200, 255}; <br>    static float ambient[] = {0.1, 0.1, 0.1, 1.0}; <br>    static float diffuse[] = {0.5, 1.0, 1.0, 1.0}; <br>    static float position[] = {90.0, 90.0, 150.0, 0.0}; <br>    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0}; <br>    static float lmodel_twoside[] = {GL_TRUE}; <br>    static float decal[] = {GL_DECAL}; <br>    static float modulate[] = {GL_MODULATE}; <br>    static float repeat[] = {GL_REPEAT}; <br>    static float nearest[] = {GL_NEAREST}; <br>    AUX_RGBImageRec *image; <br> <br>    if (!rgb) { <br>        auxSetGreyRamp(); <br>    } <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br>     <br>    glDepthFunc(GL_LEQUAL); <br>    glEnable(GL_DEPTH_TEST); <br> <br>    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient); <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse); <br>    glLightfv(GL_LIGHT0, GL_POSITION, position); <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient); <br>    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside); <br>    glEnable(GL_LIGHTING); <br>    glEnable(GL_LIGHT0); <br> <br>    bHiddenLine = FALSE; <br>    SetMaterial( bHiddenLine ); <br> <br>    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest); <br>    if (texFileName) { <br>        image = auxRGBImageLoad(texFileName); <br>        glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br>        gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image-&gt;sizeX, image-&gt;sizeY, <br>              GL_RGB, GL_UNSIGNED_BYTE, image-&gt;data); <br>    } else { <br>        glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br>        glTexImage2D(GL_TEXTURE_2D, 0, 4, brickImageWidth, brickImageHeight, <br>             0, GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid *)brickImage); <br>    } <br> <br>    quadObj = gluNewQuadric(); <br> <br>    radius1 = 10; <br>    radius2 = 5; <br>    angle1 = 90; <br>    angle2 = 180; <br>    slices = 16; <br>    stacks = 10; <br>    height = 20; <br> <br>    glCullFace( GL_BACK ); <br> <br>    UpdateInfo(); <br>} <br> <br> <br>static void SetDistance( void ) <br>{ <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glFrustum(-1, 1, -1, 1, 1, 10); <br>    // This defines how far away we're looking from <br>    glTranslated( 0, 0, zTrans ); <br>} <br> <br>static void CALLBACK Reshape(int width, int height) <br>{ <br>    trackball_Resize( width, height ); <br> <br>    glViewport(0, 0, (GLint)width, (GLint)height); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glFrustum(-1, 1, -1, 1, 1, 10); <br>    // This defines how far away we're looking from <br>    glTranslated( 0, 0, zTrans ); <br>} <br> <br> <br>static void CALLBACK Key_Left (void) <br>{ <br>    units -= inc; <br>} <br> <br> <br>static void CALLBACK Key_Right (void) <br>{ <br>    units += inc; <br>} <br> <br> <br>static void CALLBACK Key_Up (void) <br>{ <br>    factor += inc; <br>} <br> <br> <br>static void CALLBACK Key_Down (void) <br>{ <br>    factor -= inc; <br>} <br> <br> <br>static void CALLBACK Key_a (void) <br>{ <br>    if (stacks &gt; 1) <br>        stacks--; <br>} <br> <br> <br>static void CALLBACK Key_A (void) <br>{ <br>    stacks++; <br>} <br> <br> <br>static void CALLBACK Key_b (void) <br>{ <br>    bHiddenLine = !bHiddenLine; <br>    SetMaterial( bHiddenLine ); <br>} <br> <br> <br>static void CALLBACK Key_c (void) <br>{ <br>    bCullFace = !bCullFace; <br>    if( bCullFace ) <br>        glEnable( GL_CULL_FACE ); <br>    else <br>        glDisable( GL_CULL_FACE ); <br>} <br> <br> <br>static void CALLBACK Key_f (void) <br>{ <br>whichQuadric = whichQuadric &gt;= 3 ? 0 : whichQuadric + 1; <br>} <br> <br> <br>static void CALLBACK Key_g (void) <br>{ <br>    if (radius1 &gt; 0) <br>        radius1 -= 1; <br>} <br> <br> <br>static void CALLBACK Key_G (void) <br>{ <br>    radius1 += 1; <br>} <br> <br> <br>static void CALLBACK Key_h (void) <br>{ <br>    if (height &gt; 0) <br>        height -= 2; <br>} <br> <br> <br>static void CALLBACK Key_H (void) <br>{ <br>    height += 2; <br>} <br> <br> <br>static void CALLBACK Key_i (void) <br>{ <br>    factor = -1.0f; <br>    units = 0.0f; <br>} <br> <br> <br>static void CALLBACK Key_j (void) <br>{ <br>    if (radius2 &gt; 0) <br>        radius2 -= 1; <br>} <br> <br> <br>static void CALLBACK Key_J (void) <br>{ <br>    radius2 += 1; <br>} <br> <br> <br>static void CALLBACK Key_k (void) <br>{ <br>angle1 -= 5; <br>} <br> <br> <br>static void CALLBACK Key_K (void) <br>{ <br>angle1 += 5; <br>} <br> <br> <br>static void CALLBACK Key_l (void) <br>{ <br>angle2 -= 5; <br>} <br> <br> <br>static void CALLBACK Key_L (void) <br>{ <br>angle2 += 5; <br>} <br> <br> <br>static void CALLBACK Key_o (void) <br>{ <br>    bPolyOffset = !bPolyOffset; <br>} <br> <br> <br>static void CALLBACK Key_p (void) <br>{ <br>switch (polyFace) { <br>  case GL_BACK: <br>    polyFace = GL_FRONT; <br>    break; <br>  case GL_FRONT: <br>    polyFace = GL_FRONT_AND_BACK; <br>    break; <br>  case GL_FRONT_AND_BACK: <br>    polyFace = GL_BACK; <br>    break; <br>} <br>} <br> <br> <br>static void CALLBACK Key_s (void) <br>{ <br>    if (slices &gt; 3) <br>        slices--; <br>} <br> <br> <br>static void CALLBACK Key_S (void) <br>{ <br>    slices++; <br>} <br> <br> <br>static void CALLBACK Key_t (void) <br>{ <br>    texture = !texture; <br>    if (texture) { <br>        gluQuadricTexture(quadObj, GL_TRUE); <br>        glEnable(GL_TEXTURE_2D); <br>    } else { <br>        gluQuadricTexture(quadObj, GL_FALSE); <br>        glDisable(GL_TEXTURE_2D); <br>    } <br>} <br> <br> <br>static void CALLBACK Key_z (void) <br>{ <br>    zTrans += 0.1f; <br>    SetDistance(); <br>} <br> <br> <br>static void CALLBACK Key_Z (void) <br>{ <br>    zTrans -= 0.1f; <br>    SetDistance(); <br>} <br> <br> <br>static void CALLBACK Key_0 (void) <br>{ <br>    shade = !shade; <br>    if (shade) { <br>        glShadeModel(GL_SMOOTH); <br>        gluQuadricNormals(quadObj, GLU_SMOOTH); <br>    } else { <br>        glShadeModel(GL_FLAT); <br>        gluQuadricNormals(quadObj, GLU_FLAT); <br>    } <br>} <br> <br> <br>static void CALLBACK Key_1 (void) <br>{ <br>    polygonMode = GL_FILL; <br>} <br> <br> <br>static void CALLBACK Key_2 (void) <br>{ <br>    polygonMode = GL_LINE; <br>} <br> <br> <br>static void CALLBACK Key_3 (void) <br>{ <br>    polygonMode = GL_POINT; <br>} <br> <br> <br>static void DrawObject( void )  <br>{ <br>    switch (whichQuadric) { <br>      case 0: <br>gluCylinder(quadObj, radius1/10.0, radius2/10.0, height/10.0,  <br>    slices, stacks); <br>break; <br>      case 1: <br>gluSphere(quadObj, radius1/10.0, slices, stacks); <br>break; <br>      case 2: <br>gluPartialDisk(quadObj, radius2/10.0, radius1/10.0, slices,  <br>       stacks, angle1, angle2); <br>break; <br>      case 3: <br>gluDisk(quadObj, radius2/10.0, radius1/10.0, slices, stacks); <br>break; <br>    } <br>} <br> <br>static void CALLBACK Draw( void )  <br>{ <br>    float matRot[4][4]; <br> <br>    UpdateInfo(); <br>    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); <br> <br>    glMatrixMode( GL_MODELVIEW ); <br>    glLoadIdentity(); <br>    trackball_CalcRotMatrix( matRot ); <br>    glMultMatrixf( &amp;(matRot[0][0]) ); <br> <br>    if( whichQuadric == 0 ) // cylinder <br>glTranslatef(0, 0, -height/20.0); <br> <br>    // Draw object normally <br> <br>    DrawObject(); <br> <br>    // Draw object again with polygon offset <br> <br>    // Set polygon mode for offset faces <br>    glPolygonMode( GL_FRONT_AND_BACK, polygonMode ); <br> <br>    if( bPolyOffset ) { <br>        switch( polygonMode ) { <br>            case GL_FILL: <br>                glEnable( GL_POLYGON_OFFSET_FILL ); <br>                break; <br>            case GL_LINE: <br>                glEnable( GL_POLYGON_OFFSET_LINE ); <br>                break; <br>            case GL_POINT: <br>                glEnable( GL_POLYGON_OFFSET_POINT ); <br>                break; <br>        } <br>    } <br> <br>    glPolygonOffset( factor, units ); <br>    glColor3f(1.0, 0.0, 0.0); <br>    glDisable( GL_LIGHTING ); <br>    DrawObject(); <br>    glEnable( GL_LIGHTING ); <br>    // restore modes <br>    glPolygonMode( GL_FRONT_AND_BACK, GL_FILL ); <br> <br>    if( bPolyOffset ) { <br>        glDisable( GL_POLYGON_OFFSET_FILL ); <br>        glDisable( GL_POLYGON_OFFSET_LINE ); <br>        glDisable( GL_POLYGON_OFFSET_POINT ); <br>    } <br> <br>    glFlush(); <br> <br>    if (doubleBuffer) { <br>auxSwapBuffers(); <br>    } <br>} <br> <br>static unsigned long Args(int argc, char **argv) <br>{ <br>    GLint i; <br> <br>    rgb = GL_TRUE; <br>    doubleBuffer = GL_TRUE; <br> <br> <br>    for (i = 1; i &lt; argc; i++) { <br>        if (strcmp(argv[i], "-ci") == 0) { <br>            rgb = GL_FALSE; <br>        } else if (strcmp(argv[i], "-rgb") == 0) { <br>            rgb = GL_TRUE; <br>        } else if (strcmp(argv[i], "-sb") == 0) { <br>            doubleBuffer = GL_FALSE; <br>        } else if (strcmp(argv[i], "-db") == 0) { <br>            doubleBuffer = GL_TRUE; <br>        } else if (strcmp(argv[i], "-f") == 0) { <br>            if (i+1 &gt;= argc || argv[i+1][0] == '-') { <br>                //printf("-f (No file name).\n"); <br>                return GL_FALSE; <br>            } else { <br>                texFileName = argv[++i]; <br>            } <br>        } else { <br>            //printf("%s (Bad option).\n", argv[i]); <br>            return GL_FALSE; <br>        } <br>    } <br>    return GL_TRUE; <br>} <br> <br>void  _CRTAPI1 main(int argc, char **argv) <br>{ <br>    GLenum type; <br> <br>    if (Args(argc, argv) == GL_FALSE) { <br>       auxQuit(); <br>    } <br> <br>    auxInitPosition(0, 0, wWidth, wHeight); <br> <br>    type = AUX_DEPTH16; <br>    type |= (rgb) ? AUX_RGB : AUX_INDEX; <br>    type |= (doubleBuffer) ? AUX_DOUBLE : AUX_SINGLE; <br> <br>    auxInitDisplayMode(type); <br> <br>    if (auxInitWindow("Polygon Offset Demo") == GL_FALSE) { <br>        auxQuit(); <br>    } <br> <br>    Init(); <br> <br>    auxExposeFunc((AUXEXPOSEPROC)Reshape); <br>    auxReshapeFunc((AUXRESHAPEPROC)Reshape); <br> <br>    auxKeyFunc( AUX_LEFT, Key_Left ); <br>    auxKeyFunc( AUX_RIGHT, Key_Right ); <br>    auxKeyFunc( AUX_UP, Key_Up ); <br>    auxKeyFunc( AUX_DOWN, Key_Down ); <br>    auxKeyFunc( AUX_a, Key_a ); <br>    auxKeyFunc( AUX_A, Key_A ); <br>    auxKeyFunc( AUX_b, Key_b ); <br>    auxKeyFunc( AUX_c, Key_c ); <br>    auxKeyFunc( AUX_f, Key_f ); <br>    auxKeyFunc( AUX_g, Key_g ); <br>    auxKeyFunc( AUX_G, Key_G ); <br>    auxKeyFunc( AUX_h, Key_h ); <br>    auxKeyFunc( AUX_H, Key_H ); <br>    auxKeyFunc( AUX_i, Key_i ); <br>    auxKeyFunc( AUX_j, Key_j ); <br>    auxKeyFunc( AUX_J, Key_J ); <br>    auxKeyFunc( AUX_k, Key_k ); <br>    auxKeyFunc( AUX_K, Key_K ); <br>    auxKeyFunc( AUX_l, Key_l ); <br>    auxKeyFunc( AUX_L, Key_L ); <br>    auxKeyFunc( AUX_o, Key_o ); <br>    auxKeyFunc( AUX_p, Key_p ); <br>    auxKeyFunc( AUX_s, Key_s ); <br>    auxKeyFunc( AUX_S, Key_S ); <br>    auxKeyFunc( AUX_t, Key_t ); <br>    auxKeyFunc( AUX_z, Key_z ); <br>    auxKeyFunc( AUX_Z, Key_Z ); <br>    auxKeyFunc( AUX_0, Key_0 ); <br>    auxKeyFunc( AUX_1, Key_1 ); <br>    auxKeyFunc( AUX_2, Key_2 ); <br>    auxKeyFunc( AUX_3, Key_3 ); <br> <br>    auxMouseFunc( AUX_LEFTBUTTON, AUX_MOUSEDOWN, trackball_MouseDown ); <br>    auxMouseFunc( AUX_LEFTBUTTON, AUX_MOUSEUP, trackball_MouseUp ); <br>     <br>    trackball_Init( wWidth, wHeight ); <br> <br>    auxIdleFunc( Draw ); <br>    auxMainLoop( Draw ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
