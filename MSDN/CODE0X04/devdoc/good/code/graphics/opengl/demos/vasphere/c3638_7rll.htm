<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VASPHERE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3639"></a>VASPHERE.C</h2>
<pre><code>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;gl\gl.h&gt; <br>#include &lt;gl\glu.h&gt; <br>#include &lt;gl\glaux.h&gt; <br> <br>#define PI ((float)3.14159265358979323846) <br> <br>#define WIDTH 512 <br>#define HEIGHT 512 <br> <br>#define COMPUTE_SPHERE_VERTICES(rings, sections) \ <br>    (((rings)+1)*(sections)+2) <br>#define COMPUTE_SPHERE_TRIANGLES(rings, sections) \ <br>    (((rings)+1)*(sections)*2) <br>#define RINGS 50 <br>#define SECTIONS 50 <br>#define SVERTICES COMPUTE_SPHERE_VERTICES(RINGS, SECTIONS) <br>#define STRIANGLES COMPUTE_SPHERE_TRIANGLES(RINGS, SECTIONS) <br> <br>#define RGB_COLOR(red, green, blue) \ <br>    (((DWORD)(BYTE)(red) &lt;&lt; 0) | \ <br>     ((DWORD)(BYTE)(green) &lt;&lt; 8) | \ <br>     ((DWORD)(BYTE)(blue) &lt;&lt; 16)) <br>     <br>#define FRANDOM(x) (((float)rand() / RAND_MAX) * (x)) <br> <br>#define DROT 10.0f <br> <br>#define NLISTS 3 <br>     <br>typedef struct <br>{ <br>    float fX, fY, fZ; <br>    float fNx, fNy, fNz; <br>    DWORD dwColor; <br>} VERTEX; <br> <br>typedef struct <br>{ <br>    int iV1; <br>    int iV2; <br>    int iV3; <br>} TRIANGLE; <br> <br>typedef struct _SPHERE <br>{ <br>    GLfloat fXr, fYr, fZr; <br>    GLfloat fDXr, fDYr, fDZr; <br>} SPHERE; <br> <br>SPHERE sphere; <br> <br>BOOL fSingle = FALSE; <br>BOOL fDisplayList = TRUE; <br> <br>int iCurrentType = 0; <br>GLint dlLists[NLISTS]; <br>char *pszListType[NLISTS] = <br>{ <br>    "Vertex Array", "Direct Triangles", "Direct Strips" <br>}; <br> <br>void DrawVertexArray(void); <br>void DrawTriangles(void); <br>void DrawStrips(void); <br>void (*pfnDraw[NLISTS])(void) = <br>{ <br>    DrawVertexArray, DrawTriangles, DrawStrips <br>}; <br> <br>VERTEX vtxSphere[SVERTICES]; <br>TRIANGLE triSphere[STRIANGLES]; <br> <br>void *Malloc(size_t cb) <br>{ <br>    void *pv; <br> <br>    pv = malloc(cb); <br>    if (pv == NULL) <br>    { <br>        printf("Unable to alloc %d bytes\n", cb); <br>        exit(1); <br>    } <br>    return pv; <br>} <br> <br>void GenerateSphere(float fRadius, int iRings, int iSections, <br>                    VERTEX *pvtx, TRIANGLE *ptri) <br>{ <br>    float fTheta, fPhi;             /* Angles used to sweep around sphere */ <br>    float fDTheta, fDPhi;           /* Angle between each section and ring */ <br>    float fX, fY, fZ, fV, fRSinTheta;  /* Temporary variables */ <br>    int   i, j, n, m;               /* counters */ <br>    int   iVert, iTri;              /* Internal vertex and triangle count */ <br> <br>    iTri = COMPUTE_SPHERE_TRIANGLES(iRings, iSections); <br>    iVert = COMPUTE_SPHERE_VERTICES(iRings, iSections); <br> <br>    /* <br>     * Generate vertices at the top and bottom points. <br>     */ <br>    pvtx[0].fX = 0.0f; <br>    pvtx[0].fY = fRadius; <br>    pvtx[0].fZ = 0.0f; <br>    pvtx[0].fNx = 0.0f; <br>    pvtx[0].fNy = 1.0f; <br>    pvtx[0].fNz = 0.0f; <br>    pvtx[0].dwColor = RGB_COLOR(0, 0, 255); <br>    pvtx[iVert - 1].fX = 0.0f; <br>    pvtx[iVert - 1].fY = -fRadius; <br>    pvtx[iVert - 1].fZ = 0.0f; <br>    pvtx[iVert - 1].fNx = 0.0f; <br>    pvtx[iVert - 1].fNy = -1.0f; <br>    pvtx[iVert - 1].fNz = 0.0f; <br>    pvtx[iVert - 1].dwColor = RGB_COLOR(0, 255, 0); <br> <br>    /* <br>     * Generate vertex points for rings <br>     */ <br>    fDTheta = PI / (float) (iRings + 2); <br>    fDPhi = 2.0f * PI / (float) iSections; <br>    n = 1; /* vertex being generated, begins at 1 to skip top point */ <br>    fTheta = fDTheta; <br> <br>    for (i = 0; i &lt;= iRings; i++) <br>    { <br>        fY = (float)(fRadius * cos(fTheta)); /* y is the same for each ring */ <br>        fV = fTheta / PI; /* v is the same for each ring */ <br>        fRSinTheta = (float)(fRadius * sin(fTheta)); <br>        fPhi = 0.0f; <br> <br>        for (j = 0; j &lt; iSections; j++) <br>        { <br>            fX = (float)(fRSinTheta * sin(fPhi)); <br>            fZ = (float)(fRSinTheta * cos(fPhi)); <br>            pvtx[n].fX = fX; <br>            pvtx[n].fZ = fZ; <br>            pvtx[n].fY = fY; <br>            pvtx[n].fNx = fX / fRadius; <br>            pvtx[n].fNy = fY / fRadius; <br>            pvtx[n].fNz = fZ / fRadius; <br>            if (n &amp; 1) <br>            { <br>                pvtx[n].dwColor = RGB_COLOR(0, 0, 255); <br>            } <br>            else <br>            { <br>                pvtx[n].dwColor = RGB_COLOR(0, 255, 0); <br>            } <br>            fPhi += fDPhi; <br>            n++; <br>        } <br> <br>        fTheta += fDTheta; <br>    } <br> <br>    /* <br>     * Generate triangles for top and bottom caps. <br>     */ <br>    for (i = 0; i &lt; iSections; i++) <br>    { <br>        ptri[i].iV1 = 0; <br>        ptri[i].iV2 = i + 1; <br>        ptri[i].iV3 = 1 + ((i + 1) % iSections); <br>        ptri[iTri - iSections + i].iV1 = iVert - 1; <br>        ptri[iTri - iSections + i].iV2 = iVert - 2 - i; <br>        ptri[iTri - iSections + i].iV3 = iVert - 2 - ((1 + i) % iSections); <br>    } <br> <br>    /* <br>     * Generate triangles for the rings <br>     */ <br>    m = 1; /* first vertex in current ring,begins at 1 to skip top point*/ <br>    n = iSections; /* triangle being generated, skip the top cap */ <br> <br>    for (i = 0; i &lt; iRings; i++) <br>    { <br>        for (j = 0; j &lt; iSections; j++) <br>        { <br>            ptri[n].iV1 = m + j; <br>            ptri[n].iV2 = m + iSections + j; <br>            ptri[n].iV3 = m + iSections + ((j + 1) % iSections); <br>            ptri[n + 1].iV1 = ptri[n].iV1; <br>            ptri[n + 1].iV2 = ptri[n].iV3; <br>            ptri[n + 1].iV3 = m + ((j + 1) % iSections); <br>            n += 2; <br>        } <br> <br>        m += iSections; <br>    } <br>} <br> <br>void InitSphere(void) <br>{ <br>    GenerateSphere(1.0f, RINGS, SECTIONS, vtxSphere, triSphere); <br>     <br>    glVertexPointer(3, GL_FLOAT, sizeof(VERTEX), &amp;vtxSphere[0].fX); <br>    glNormalPointer(GL_FLOAT, sizeof(VERTEX), &amp;vtxSphere[0].fNx); <br>    glColorPointer(3, GL_UNSIGNED_BYTE, sizeof(VERTEX), &amp;vtxSphere[0].dwColor); <br>     <br>    srand(time(NULL)); <br>    sphere.fXr = 0.0f; <br>    sphere.fYr = 0.0f; <br>    sphere.fZr = 0.0f; <br>    sphere.fDXr = DROT - FRANDOM(2 * DROT); <br>    sphere.fDYr = DROT - FRANDOM(2 * DROT); <br>    sphere.fDZr = DROT - FRANDOM(2 * DROT); <br>} <br> <br>void UpdateSphere(void) <br>{ <br>    sphere.fXr += sphere.fDXr; <br>    sphere.fYr += sphere.fDYr; <br>    sphere.fZr += sphere.fDZr; <br>} <br> <br>void DrawVertexArray(void) <br>{ <br>    glDrawElements(GL_TRIANGLES, STRIANGLES*3, GL_UNSIGNED_INT, triSphere); <br>} <br> <br>void Vertex(int iVert) <br>{ <br>    VERTEX *pvtx; <br> <br>    pvtx = &amp;vtxSphere[iVert]; <br>    glColor3ubv((GLubyte *)&amp;pvtx-&gt;dwColor); <br>    glNormal3fv(&amp;pvtx-&gt;fNx); <br>    glVertex3fv(&amp;pvtx-&gt;fX); <br>} <br> <br>void DrawTriangles(void) <br>{ <br>    int iVert, *pidx; <br>     <br>    glBegin(GL_TRIANGLES); <br>    pidx = (int *)&amp;triSphere[0]; <br>    for (iVert = 0; iVert &lt; STRIANGLES*3; iVert++) <br>    { <br>        Vertex(*pidx++); <br>    } <br>    glEnd(); <br>} <br> <br>void DrawStrips(void) <br>{ <br>    int iIdxBase; <br>    int iRing, iSection; <br> <br>    // Triangle fans for top and bottom caps <br>    glBegin(GL_TRIANGLE_FAN); <br>     <br>    Vertex(0); <br>    iIdxBase = 1; <br>    for (iSection = 0; iSection &lt;= SECTIONS; iSection++) <br>    { <br>        Vertex(iIdxBase+(iSection % SECTIONS)); <br>    } <br>     <br>    glEnd(); <br> <br>    glBegin(GL_TRIANGLE_FAN); <br> <br>    Vertex(SVERTICES-1); <br>    iIdxBase = SVERTICES-SECTIONS-1; <br>    for (iSection = SECTIONS; iSection &gt;= 0 ; iSection--) <br>    { <br>        Vertex(iIdxBase+(iSection % SECTIONS)); <br>    } <br> <br>    glEnd(); <br> <br>    // Triangle strips for each ring <br>    iIdxBase = 1; <br>    for (iRing = 0; iRing &lt; RINGS; iRing++) <br>    { <br>        glBegin(GL_TRIANGLE_STRIP); <br>         <br>        for (iSection = 0; iSection &lt;= SECTIONS; iSection++) <br>        { <br>            Vertex(iIdxBase+(iSection % SECTIONS)); <br>            Vertex(iIdxBase+(iSection % SECTIONS)+SECTIONS); <br>        } <br> <br>        glEnd(); <br> <br>        iIdxBase += SECTIONS; <br>    } <br>} <br> <br>void Init(void) <br>{ <br>    float fv4[4]; <br>    int iv1[1]; <br>    int i; <br>    GLint dlBase; <br>     <br>    InitSphere(); <br>     <br>    fv4[0] = 0.05f; <br>    fv4[1] = 0.05f; <br>    fv4[2] = 0.05f; <br>    fv4[3] = 1.0f; <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, fv4); <br>     <br>    fv4[0] = 0.0f; <br>    fv4[1] = 1.0f; <br>    fv4[2] = 1.0f; <br>    fv4[3] = 0.0f; <br>    glLightfv(GL_LIGHT0, GL_POSITION, fv4); <br>    fv4[0] = 0.9f; <br>    fv4[1] = 0.9f; <br>    fv4[2] = 0.9f; <br>    fv4[3] = 1.0f; <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, fv4); <br>    glEnable(GL_LIGHT0); <br>    glEnable(GL_LIGHTING); <br>     <br>    fv4[0] = 0.6f; <br>    fv4[1] = 0.6f; <br>    fv4[2] = 0.6f; <br>    fv4[3] = 1.0f; <br>    glMaterialfv(GL_FRONT, GL_SPECULAR, fv4); <br>    iv1[0] = 40; <br>    glMaterialiv(GL_FRONT, GL_SHININESS, iv1); <br>     <br>    glEnable(GL_CULL_FACE); <br>     <br>    glEnableClientState(GL_VERTEX_ARRAY); <br>    glEnableClientState(GL_NORMAL_ARRAY); <br>    glEnableClientState(GL_COLOR_ARRAY); <br>     <br>    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE); <br>    glEnable(GL_COLOR_MATERIAL); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluPerspective(45, 1, .01, 15); <br>    gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    dlBase = glGenLists(NLISTS); <br>    for (i = 0; i &lt; NLISTS; i++) <br>    { <br>        dlLists[i] = dlBase+i; <br>        glNewList(dlLists[i], GL_COMPILE); <br>        pfnDraw[i](); <br>        glEndList(); <br>    } <br>} <br> <br>DWORD dwTotalMillis = 0; <br>int iTotalTriangles = 0; <br> <br>void ResetTotals(void) <br>{ <br>    dwTotalMillis = 0; <br>    iTotalTriangles = 0; <br>} <br> <br>void CALLBACK Redraw(void) <br>{ <br>    DWORD dwMillis; <br>    char szMsg[80]; <br>     <br>    dwMillis = GetTickCount(); <br> <br>    glClear(GL_COLOR_BUFFER_BIT); <br> <br>    glLoadIdentity(); <br>    glRotatef(sphere.fXr, 1.0f, 0.0f, 0.0f); <br>    glRotatef(sphere.fYr, 0.0f, 1.0f, 0.0f); <br>    glRotatef(sphere.fZr, 0.0f, 0.0f, 1.0f); <br> <br>    if (fDisplayList) <br>    { <br>        glCallList(dlLists[iCurrentType]); <br>    } <br>    else <br>    { <br>        pfnDraw[iCurrentType](); <br>    } <br>     <br>    UpdateSphere(); <br> <br>    if (fSingle) <br>    { <br>        glFlush(); <br>    } <br>    else <br>    { <br>        auxSwapBuffers(); <br>    } <br>     <br>    dwMillis = GetTickCount()-dwMillis; <br> <br>    dwTotalMillis += dwMillis; <br>    iTotalTriangles += STRIANGLES; <br> <br>    if (dwTotalMillis &gt; 1000) <br>    { <br>        sprintf(szMsg, "%s%s: %.3lf tri/sec", <br>                fDisplayList ? "Display List " : "", <br>                pszListType[iCurrentType], <br>                (double)iTotalTriangles*1000.0/dwTotalMillis); <br>        SetWindowText(auxGetHWND(), szMsg); <br> <br>        ResetTotals(); <br>    } <br>} <br> <br>void CALLBACK Reshape(GLsizei w, GLsizei h) <br>{ <br>    glViewport(0, 0, w, h); <br>} <br> <br>void CALLBACK Keyd(void) <br>{ <br>    fDisplayList = !fDisplayList; <br>    ResetTotals(); <br>} <br> <br>void CALLBACK KeySPACE(void) <br>{ <br>    iCurrentType = (iCurrentType+1) % NLISTS; <br>    ResetTotals(); <br>} <br>     <br>void _CRTAPI1 main(int argc, char **argv) <br>{ <br>    GLenum eMode; <br>     <br>    while (--argc &gt; 0) <br>    { <br>        argv++; <br> <br>        if (!strcmp(*argv, "-sb")) <br>        { <br>            fSingle = TRUE; <br>        } <br>    } <br>     <br>    auxInitPosition(10, 10, WIDTH, HEIGHT); <br>    eMode = AUX_RGB; <br>    if (!fSingle) <br>    { <br>        eMode |= AUX_DOUBLE; <br>    } <br>    auxInitDisplayMode(eMode); <br>    auxInitWindow("Vertex Array/Direct Comparison"); <br> <br>    auxReshapeFunc(Reshape); <br>    auxIdleFunc(Redraw); <br> <br>    auxKeyFunc(AUX_d, Keyd); <br>    auxKeyFunc(AUX_SPACE, KeySPACE); <br> <br>    Init(); <br>    auxMainLoop(Redraw); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
