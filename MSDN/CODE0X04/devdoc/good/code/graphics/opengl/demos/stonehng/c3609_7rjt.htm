<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STONE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3629"></a>STONE.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;GL/glu.h&gt; <br> <br>#ifdef X11 <br>#include &lt;GL/glx.h&gt; <br>#endif <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#ifdef WIN32 <br>#include "stonehen.h" <br>#endif <br> <br>#include "Stone.h" <br> <br>const GLfloat root2 = 1.4142136; <br>const GLfloat root3 = sqrt(3.); <br>const GLfloat rt_half = .70710678; <br> <br>inline float radians(float a) {return M_PI * a / 180.0; } <br> <br>inline float sign(float a) {return (a &gt; 0. ? 1 : (a &lt; 0. ? -1 : 0)); } <br> <br>Stone::Stone()  <br>{ <br>  translation.set(0, 0, 0); <br>  rotation = 0; <br>  dimensions.set(1, 1, 1); <br> <br>  erosion = 0; <br> <br>  points_valid = transforms_valid = 0; <br>} <br> <br>Stone::~Stone()  <br>{ <br>} <br> <br>Stone Stone::operator=(Stone a) <br>{ <br>  int i; <br> <br>  translation = a.translation; <br>  rotation = a.rotation; <br>  dimensions = a.dimensions; <br> <br>  erosion = a.erosion; <br> <br>  if (a.points_valid &amp;&amp; a.transforms_valid) { <br>    for (i = 0; i &lt; 24; i++) points[i] = a.points[i]; <br>    points_valid = transforms_valid = 1; <br>  } else points_valid = transforms_valid = 0; <br> <br>  return *this; <br>} <br> <br>void Stone::set_dimensions(GLfloat x, GLfloat y, GLfloat z) <br>{ <br>  dimensions.set(x, y, z); <br>  points_valid = 0; <br>} <br> <br>void Stone::set_dimensions(Point p) <br>{ <br>  dimensions = p; <br>  points_valid = 0; <br>} <br> <br>void Stone::erode(float p) <br>{ <br>  erosion += p; <br>  points_valid = 0; <br>} <br> <br>void Stone::translate(GLfloat x, GLfloat y, GLfloat z) <br>{ <br>  translation.pt[0] += x; <br>  translation.pt[1] += y; <br>  translation.pt[2] += z; <br>  points_valid = 0; <br>} <br> <br>void Stone::translate(Point p) <br>{ <br>  translation += p; <br>  points_valid = 0; <br>} <br> <br>void Stone::rotate_self_aboutz(GLfloat angle) <br>{ <br>  rotation += angle; <br>  points_valid = 0; <br>} <br> <br>void Stone::draw() <br>{ <br>  compute_points(); <br> <br>  glPushMatrix(); <br>  glRotatef(rotation, 0, 0, 1); <br>  glTranslatef(translation.pt[0], translation.pt[1], translation.pt[2]); <br>  glScalef(dimensions.pt[0], dimensions.pt[1], dimensions.pt[2]); <br> <br>  draw_faces(); <br>  draw_edges(); <br>  draw_corners(); <br> <br>  glPopMatrix(); <br>} <br> <br>void Stone::compute_points() <br>{ <br>  GLfloat e = 1.0 - erosion; <br> <br>  if (points_valid) return; <br> <br>  points[0].set(1, e, e); <br>  points[1].set(e, 1, e); <br>  points[2].set(e, e, 1); <br> <br>  points[3].set(-e, e, 1); <br>  points[4].set(-e, 1, e); <br>  points[5].set(-1, e, e); <br> <br>  points[6].set(e, -e, 1); <br>  points[7].set(e, -1, e); <br>  points[8].set(1, -e, e); <br> <br>  points[9 ].set(e, e, -1); <br>  points[10].set(e, 1, -e); <br>  points[11].set(1, e, -e); <br> <br>  points[12].set(-1, -e, e); <br>  points[13].set(-e, -1, e); <br>  points[14].set(-e, -e, 1); <br> <br>  points[15].set(1, -e, -e); <br>  points[16].set(e, -1, -e); <br>  points[17].set(e, -e, -1); <br> <br>  points[18].set(-1, e, -e); <br>  points[19].set(-e, 1, -e); <br>  points[20].set(-e, e, -1); <br>   <br>  points[21].set(-e, -e, -1); <br>  points[22].set(-e, -1, -e); <br>  points[23].set(-1, -e, -e); <br> <br>  points_valid = 1; <br>  transforms_valid = 0; <br>} <br> <br>inline Point Stone::trans_rot_point(Point p, float c, float s) <br>{ <br>  Point val; <br>  val = p + translation; <br>  val = val.rotate_aboutz(c, s); <br>  return val; <br>} <br> <br>inline Point Stone::transform_point(Point p, float c, float s) <br>{ <br>  Point val; <br>  val = p.scale(dimensions); <br>  val += translation; <br>  val = val.rotate_aboutz(c, s); <br>  return val; <br>} <br> <br>void Stone::transform_points() <br>{ <br>  float c, s; <br>  int i; <br> <br>  if (points_valid &amp;&amp; transforms_valid) return; <br>  points_valid = 0; <br>  compute_points(); <br> <br>  c = cos(radians(rotation)); <br>  s = sin(radians(rotation)); <br> <br>  for (i = 0; i &lt; 24; i++) points[i] = transform_point(points[i], c, s); <br> <br>  points_valid = 0; <br>  transforms_valid = 1; <br>} <br> <br>void Stone::draw_faces(int flat) <br>{ <br>  draw_faces(points, flat); <br>} <br> <br>void Stone::draw_faces(Point *p, int flat) <br>{ <br>  glBegin(GL_QUADS); <br> <br>  glNormal3f(1, 0, 0); <br>  if (flat) glTexCoord2fv(p[15].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[15].pt); <br>  if (flat) glTexCoord2fv(p[11].pt); <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[11].pt); <br>  if (flat) glTexCoord2fv(p[0].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[0].pt); <br>  if (flat) glTexCoord2fv(p[8].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[8].pt); <br> <br>  glNormal3f(-1, 0, 0); <br>  if (flat) glTexCoord2fv(p[12].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[12].pt); <br>  if (flat) glTexCoord2fv(p[5].pt); <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[5].pt); <br>  if (flat) glTexCoord2fv(p[18].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[18].pt); <br>  if (flat) glTexCoord2fv(p[23].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[23].pt); <br> <br>  glNormal3f(0, 1, 0); <br>  if (flat) glTexCoord2fv(p[4].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[4].pt); <br>  if (flat) glTexCoord2fv(p[1].pt); <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[1].pt); <br>  if (flat) glTexCoord2fv(p[10].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[10].pt); <br>  if (flat) glTexCoord2fv(p[19].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[19].pt); <br>   <br>  glNormal3f(0, -1, 0); <br>  if (flat) glTexCoord2fv(p[22].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[22].pt); <br>  if (flat) glTexCoord2fv(p[16].pt); <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[16].pt); <br>  if (flat) glTexCoord2fv(p[7].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[7].pt); <br>  if (flat) glTexCoord2fv(p[13].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[13].pt); <br> <br>  glNormal3f(0, 0, 1); <br>  if (flat) glTexCoord2fv(p[14].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[14].pt); <br>  if (flat) glTexCoord2fv(p[6].pt);  <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[6].pt); <br>  if (flat) glTexCoord2fv(p[2].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[2].pt); <br>  if (flat) glTexCoord2fv(p[3].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[3].pt); <br> <br>  glNormal3f(0, 0, -1); <br>  if (flat) glTexCoord2fv(p[20].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[20].pt); <br>  if (flat) glTexCoord2fv(p[9].pt); <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[9].pt); <br>  if (flat) glTexCoord2fv(p[17].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[17].pt); <br>  if (flat) glTexCoord2fv(p[21].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[21].pt); <br> <br>  glEnd(); <br>} <br> <br>void Stone::draw_edges(int flat) <br>{ <br>  draw_edges(points, flat); <br>} <br> <br>void Stone::draw_edges(Point *p, int flat) <br>{ <br>  Point n1, n2; <br> <br>  glBegin(GL_QUADS); <br> <br>  n1.set(0, 1, 0); <br>  n2.set(1, 0, 0); <br>  draw_edge(n1, n2, p, 10, 1, 0, 11, flat); <br> <br>  n1.set(1, 0, 0); <br>  n2.set(0, -1, 0); <br>  draw_edge(n1, n2, p, 15, 8, 7, 16, flat); <br> <br>  n1.set(1, 0, 0); <br>  n2.set(0, 0, 1); <br>  draw_edge(n1, n2, p, 8, 0, 2, 6, flat); <br> <br>  n1.set(1, 0, 0); <br>  n2.set(0, 0, -1); <br>  draw_edge(n1, n2, p, 11, 15, 17, 9, flat); <br> <br>  n1.set(0, 1, 0); <br>  n2.set(-1, 0, 0); <br>  draw_edge(n1, n2, p, 4, 19, 18, 5, flat); <br> <br>  n1.set(-1, 0, 0); <br>  n2.set(0, -1, 0); <br>  draw_edge(n1, n2, p, 12, 23, 22, 13, flat); <br>   <br>  n1.set(-1, 0, 0); <br>  n2.set(0, 0, 1); <br>  draw_edge(n1, n2, p, 5, 12, 14, 3, flat); <br> <br>  n2.set(-1, 0, 0); <br>  n1.set(0, 0, -1); <br>  draw_edge(n1, n2, p, 20, 21, 23, 18, flat); <br>     <br>  n1.set(0, 1, 0); <br>  n2.set(0, 0, 1); <br>  draw_edge(n1, n2, p, 1, 4, 3, 2, flat); <br> <br>  n1.set(0, 1, 0); <br>  n2.set(0, 0, -1); <br>  draw_edge(n1, n2, p, 19, 10, 9, 20, flat); <br> <br>  n1.set(0, -1, 0); <br>  n2.set(0, 0, 1); <br>  draw_edge(n1, n2, p, 13, 7, 6, 14, flat); <br> <br>  n1.set(0, -1, 0); <br>  n2.set(0, 0, -1);  <br>  draw_edge(n1, n2, p, 16, 22, 21, 17, flat); <br> <br>  glEnd(); <br>} <br> <br>void Stone::draw_edge(Point n1, Point n2, Point *p,  <br>      int a, int b, int c, int d, int flat) <br>{ <br>  glNormal3fv(n1.pt); <br>  if (flat) glTexCoord2fv(p[a].pt); <br>  else glTexCoord2f(0, 0); <br>  glVertex3fv(p[a].pt); <br>  if (flat) glTexCoord2fv(p[b].pt); <br>  else glTexCoord2f(0, 1); <br>  glVertex3fv(p[b].pt); <br>  glNormal3fv(n2.pt); <br>  if (flat) glTexCoord2fv(p[c].pt); <br>  else glTexCoord2f(1, 1); <br>  glVertex3fv(p[c].pt); <br>  if (flat) glTexCoord2fv(p[d].pt); <br>  else glTexCoord2f(1, 0); <br>  glVertex3fv(p[d].pt); <br>} <br> <br>void Stone::draw_corners(Point *p, int flat) <br>{ <br>  GLfloat e = 1.0 - erosion; <br> <br>  glBegin(GL_TRIANGLES); <br> <br>  if (flat) glTexCoord2fv(p[0].pt); <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(1, 0, 0); <br>  glVertex3fv(p[0].pt); <br>  if (flat) glTexCoord2fv(p[1].pt); <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, 1, 0); <br>  glVertex3fv(p[1].pt); <br>  if (flat) glTexCoord2fv(p[2].pt); <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(0, 0, 1); <br>  glVertex3fv(p[2].pt); <br> <br>  if (flat) glTexCoord2fv(p[3].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(0, 0, 1); <br>  glVertex3fv(p[3].pt); <br>  if (flat) glTexCoord2fv(p[4].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, 1, 0); <br>  glVertex3fv(p[4].pt); <br>  if (flat) glTexCoord2fv(p[5].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(-1, 0, 0); <br>  glVertex3fv(p[5].pt); <br> <br>  if (flat) glTexCoord2fv(p[6].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(0, 0, 1); <br>  glVertex3fv(p[6].pt); <br>  if (flat) glTexCoord2fv(p[7].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, -1, 0); <br>  glVertex3fv(p[7].pt); <br>  if (flat) glTexCoord2fv(p[8].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(1, 0, 0); <br>  glVertex3fv(p[8].pt); <br> <br>  if (flat) glTexCoord2fv(p[9].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(0, 0, -1); <br>  glVertex3fv(p[9].pt); <br>  if (flat) glTexCoord2fv(p[10].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, 1, 0); <br>  glVertex3fv(p[10].pt); <br>  if (flat) glTexCoord2fv(p[11].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(1, 0, 0); <br>  glVertex3fv(p[11].pt); <br> <br>  if (flat) glTexCoord2fv(p[12].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(-1, 0, 0); <br>  glVertex3fv(p[12].pt); <br>  if (flat) glTexCoord2fv(p[13].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, -1, 0); <br>  glVertex3fv(p[13].pt); <br>  if (flat) glTexCoord2fv(p[14].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(0, 0, 1); <br>  glVertex3fv(p[14].pt); <br> <br>  if (flat) glTexCoord2fv(p[15].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(1, 0, 0); <br>  glVertex3fv(p[15].pt); <br>  if (flat) glTexCoord2fv(p[16].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, -1, 0); <br>  glVertex3fv(p[16].pt); <br>  if (flat) glTexCoord2fv(p[17].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(0, 0, -1); <br>  glVertex3fv(p[17].pt); <br> <br>  if (flat) glTexCoord2fv(p[18].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(-1, 0, 0); <br>  glVertex3fv(p[18].pt); <br>  if (flat) glTexCoord2fv(p[19].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, 1, 0); <br>  glVertex3fv(p[19].pt); <br>  if (flat) glTexCoord2fv(p[20].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(0, 0, -1); <br>  glVertex3fv(p[20].pt); <br> <br>  if (flat) glTexCoord2fv(p[21].pt);  <br>  else glTexCoord2f(0, 0); <br>  glNormal3f(0, 0, -1); <br>  glVertex3fv(p[21].pt); <br>  if (flat) glTexCoord2fv(p[22].pt);  <br>  else glTexCoord2f(1, 0); <br>  glNormal3f(0, -1, 0); <br>  glVertex3fv(p[22].pt); <br>  if (flat) glTexCoord2fv(p[23].pt);  <br>  else glTexCoord2f(.5, 1); <br>  glNormal3f(-1, 0, 0); <br>  glVertex3fv(p[23].pt); <br> <br>  glEnd(); <br>} <br> <br>void Stone::draw_shadow(Point dlight)  <br>{ <br>  Point p[24]; <br>  int i; <br> <br>  transform_points(); <br>  for (i = 0; i &lt; 24; i++) { <br>    p[i] = points[i]; <br>    if (p[i].pt[2] &lt; 0.0) p[i].pt[2] = 0.0; <br>    p[i] = p[i].project_direction(dlight); <br>  } <br>  draw_faces(p, 1); <br>  draw_edges(p, 1); <br>  draw_corners(p, 1); <br>} <br> <br>void Stone::draw_shadow(Point dlight, GLfloat blur,  <br>Color color, Color diffuse) <br>{ <br>  float b = 1.0 + blur; <br>  float c, s; <br>  Point p[8], pp[8]; <br>  Point d, n; <br>  Color colorp, diffusep; <br>  int draw[6]; <br>  int i; <br> <br>  if (blur == 0.0) { <br>    draw_shadow(dlight); <br>    return; <br>  } <br> <br>  colorp = color; <br>  color.c[3] = 1; <br>  colorp.c[3] = 0; <br>  diffusep = diffuse; <br>  diffuse.c[3] = 1; <br>  diffusep.c[3] = 0; <br> <br>  /* We're being slightly cowardly here and ignoring the erosion - it <br>   * shouldn't make a big difference */ <br>  p[0].set(-1, -1, -1); <br>  pp[0] = p[0]; <br>  p[1].set(1, -1, -1); <br>  pp[1] = p[1]; <br>  p[2].set(1, 1, -1); <br>  pp[2] = p[2]; <br>  p[3].set(-1, 1, -1); <br>  pp[3] = p[3]; <br>  p[4].set(-1, -1, 1); <br>  pp[4] = p[4]; <br>  p[5].set(1, -1, 1); <br>  pp[5] = p[5]; <br>  p[6].set(1, 1, 1); <br>  pp[6] = p[6]; <br>  p[7].set(-1, 1, 1); <br>  pp[7] = p[7]; <br> <br>  c = cos(radians(rotation)); <br>  s = sin(radians(rotation)); <br>  for (i = 0; i &lt; 8; i++) { <br>    p[i] = transform_point(p[i], c, s); <br> <br>    /* This is a complete and utter hack - the net effect is that <br>     * points which are higher are displaced further when the penumbra  <br>     * is drawn */ <br>    d = dimensions; <br>    d.pt[0] += blur * (pp[i].pt[2] + translation.pt[2]); <br>    d.pt[1] += blur * (pp[i].pt[2] + translation.pt[2]); <br>    d.pt[2] += blur * (pp[i].pt[2] + translation.pt[2]); <br>    pp[i] = pp[i].scale(d); <br>    pp[i] = trans_rot_point(pp[i], c, s); <br>    if (p[i].pt[2] &lt; 0.0) p[i].pt[2] = 0.0; <br> <br>    p[i] = p[i].project_direction(dlight); <br>    if (pp[i].pt[2] &lt; 0.0) pp[i].pt[2] = 0.0; <br>    pp[i] = pp[i].project_direction(dlight); <br>  } <br> <br>  /* Compute whether or not we should draw various parts of the shadow <br>   * based upon the normal direction */ <br>  if (dlight.pt[2] &gt; 0.0) dlight *= -1.0; <br>  n.set(0, 0, -1); <br>  n = n.rotate_aboutz(c, s); <br>  draw[0] = (dlight.dot(n) &lt; 0.0); <br>  n.set(0, -1, 0); <br>  n = n.rotate_aboutz(c, s); <br>  draw[1] = (dlight.dot(n) &lt; 0.0); <br>  n.set(1, 0, 0); <br>  n = n.rotate_aboutz(c, s); <br>  draw[2] = (dlight.dot(n) &lt; 0.0); <br>  n.set(0, 1, 0); <br>  n = n.rotate_aboutz(c, s); <br>  draw[3] = (dlight.dot(n) &lt; 0.0); <br>  n.set(-1, 0, 0); <br>  n = n.rotate_aboutz(c, s); <br>  draw[4] = (dlight.dot(n) &lt; 0.0); <br>  n.set(0, 0, 1); <br>  n = n.rotate_aboutz(c, s); <br>  draw[5] = (dlight.dot(n) &lt; 0.0); <br> <br>  /* This part draws the "real" shadow */ <br>  glColor4fv(color.c); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br> <br>  glBegin(GL_QUADS); <br> <br>  if (draw[0]) { <br>    glVertex2fv(p[0].pt); <br>    glVertex2fv(p[1].pt); <br>    glVertex2fv(p[2].pt); <br>    glVertex2fv(p[3].pt); <br>  } <br> <br>  if (draw[1]) { <br>    glVertex2fv(p[0].pt); <br>    glVertex2fv(p[1].pt); <br>    glVertex2fv(p[5].pt); <br>    glVertex2fv(p[4].pt); <br>  } <br> <br>  if (draw[2]) { <br>    glVertex2fv(p[1].pt); <br>    glVertex2fv(p[2].pt); <br>    glVertex2fv(p[6].pt); <br>    glVertex2fv(p[5].pt); <br>  } <br> <br>  if (draw[3]) { <br>    glVertex2fv(p[2].pt); <br>    glVertex2fv(p[3].pt); <br>    glVertex2fv(p[7].pt); <br>    glVertex2fv(p[6].pt); <br>  } <br> <br>  if (draw[4]) { <br>    glVertex2fv(p[3].pt); <br>    glVertex2fv(p[0].pt); <br>    glVertex2fv(p[4].pt); <br>    glVertex2fv(p[7].pt); <br>  } <br> <br>  if (draw[5]) { <br>    glVertex2fv(p[4].pt); <br>    glVertex2fv(p[5].pt); <br>    glVertex2fv(p[6].pt); <br>    glVertex2fv(p[7].pt); <br>  } <br> <br>  glEnd(); <br> <br>  /* This part draws the penumbra */ <br> <br>  glEnable(GL_BLEND); <br>  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); <br> <br>  glBegin(GL_QUADS); <br> <br>  /* Top */ <br>  if (draw[5]) { <br>    if (!draw[4]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[4].pt); <br>      glVertex2fv(p[5].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[5].pt); <br>      glVertex2fv(pp[4].pt); <br>    } <br> <br>    if (!draw[2]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[5].pt); <br>      glVertex2fv(p[6].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[6].pt); <br>      glVertex2fv(pp[5].pt); <br>    } <br> <br>    if (!draw[3]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[6].pt); <br>      glVertex2fv(p[7].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[7].pt); <br>      glVertex2fv(pp[6].pt); <br>    } <br> <br>    if (!draw[4]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[7].pt); <br>      glVertex2fv(p[4].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[4].pt); <br>      glVertex2fv(pp[7].pt); <br>    } <br>  } <br>  /* End of Top */ <br> <br>  /* Sides */ <br>  if ((draw[1] || draw[4]) &amp;&amp; !(draw[1] &amp;&amp; draw[4])) { <br>    glColor4fv(color.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>    glVertex2fv(p[0].pt); <br>    glVertex2fv(p[4].pt); <br>    glColor4fv(colorp.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>    glVertex2fv(pp[4].pt); <br>    glVertex2fv(pp[0].pt); <br>  } <br> <br>  if ((draw[1] || draw[2]) &amp;&amp; !(draw[1] &amp;&amp; draw[2])) { <br>    glColor4fv(color.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>    glVertex2fv(p[1].pt); <br>    glVertex2fv(p[5].pt); <br>    glColor4fv(colorp.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>    glVertex2fv(pp[5].pt); <br>    glVertex2fv(pp[1].pt); <br>  } <br> <br>  if ((draw[3] || draw[2]) &amp;&amp; !(draw[3] &amp;&amp; draw[2])) { <br>    glColor4fv(color.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>    glVertex2fv(p[2].pt); <br>    glVertex2fv(p[6].pt); <br>    glColor4fv(colorp.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>    glVertex2fv(pp[6].pt); <br>    glVertex2fv(pp[2].pt); <br>  } <br> <br>  if ((draw[3] || draw[4]) &amp;&amp; !(draw[3] &amp;&amp; draw[4])) { <br>    glColor4fv(color.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>    glVertex2fv(p[3].pt); <br>    glVertex2fv(p[7].pt); <br>    glColor4fv(colorp.c); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>    glVertex2fv(pp[7].pt); <br>    glVertex2fv(pp[3].pt); <br>  } <br>  /* End of Sides */ <br> <br>  /* Bottom */ <br>  if (draw[0]) { <br>    if (!draw[1]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, diffuse.c); <br>      glVertex2fv(p[0].pt); <br>      glVertex2fv(p[1].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, diffusep.c); <br>      glVertex2fv(pp[1].pt); <br>      glVertex2fv(pp[0].pt); <br>    } <br>     <br>    if (!draw[2]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[1].pt); <br>      glVertex2fv(p[2].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[2].pt); <br>      glVertex2fv(pp[1].pt); <br>    } <br> <br>    if (!draw[3]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[2].pt); <br>      glVertex2fv(p[3].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[3].pt); <br>      glVertex2fv(pp[2].pt); <br>    } <br>     <br>    if (!draw[4]) { <br>      glColor4fv(color.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c); <br>      glVertex2fv(p[3].pt); <br>      glVertex2fv(p[0].pt); <br>      glColor4fv(colorp.c); <br>      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c); <br>      glVertex2fv(pp[0].pt); <br>      glVertex2fv(pp[3].pt); <br>    } <br>  } <br>  /* End of Bottom */ <br> <br>  glEnd(); <br> <br>  glDisable(GL_BLEND); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
