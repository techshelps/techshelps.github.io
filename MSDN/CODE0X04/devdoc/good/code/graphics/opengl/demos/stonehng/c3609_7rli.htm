<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TIMEDATE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3636"></a>TIMEDATE.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1996 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;GL/glu.h&gt; <br> <br>#ifdef X11 <br>#include &lt;GL/glx.h&gt; <br>#endif <br> <br>#ifdef WIN32 <br>#include "stonehen.h" <br>#endif <br> <br>#include "TimeDate.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#ifdef X11 <br>#include &lt;sys/time.h&gt; <br>#else <br>#include &lt;time.h&gt; <br>#endif <br> <br>inline float sign(float a) {return a &gt; 0.0 ? 1. : (a &lt; 0.0 ? -1. : 0.);} <br> <br>inline float degrees(float a) {return a * 180.0 / M_PI;} <br>inline float radians(float a) {return a * M_PI / 180.0;} <br> <br>inline float arcsin(float a) {return atan2(a, sqrt( (float) 1.0-a*a));} <br> <br>/* Thirty days hath September... */ <br>const int mday[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; <br> <br>TimeDate::TimeDate(int hour, int minute, int second, long usecond) <br>{ <br>  read_time(); <br>  t.tm_hour = hour; <br>  t.tm_min = minute; <br>  t.tm_sec = second; <br>  usec = usecond; <br>} <br> <br>TimeDate TimeDate::operator=(TimeDate a) <br>{ <br>  usec = a.usec; <br>  t = a.t; <br>  return *this; <br>} <br> <br>TimeDate TimeDate::operator+(TimeDate a) <br>{ <br>  TimeDate td; <br>  td = *this + a.t; <br>  td.usec = usec + a.usec; <br>  return td; <br>} <br> <br>TimeDate TimeDate::operator+(struct tm t2) <br>{ <br>  TimeDate td; <br>  td.usec = 0; <br>  td.t.tm_sec = t.tm_sec + t2.tm_sec; <br>  td.t.tm_min = t.tm_min + t2.tm_min; <br>  td.t.tm_hour = t.tm_hour + t2.tm_hour; <br>  td.t.tm_mday = t.tm_mday + t2.tm_mday; <br>  td.t.tm_mon = t.tm_mon + t2.tm_mon; <br>  td.t.tm_year = t.tm_year + t2.tm_year; <br>  td.t.tm_wday = t.tm_wday + t2.tm_wday; <br>  td.t.tm_yday = t.tm_yday + t2.tm_yday; <br>  return td; <br>} <br> <br>TimeDate TimeDate::operator+=(TimeDate a) <br>{ <br>  /* This is slower than it needs to be */ <br>  *this = *this + a.t; <br>  return *this; <br>} <br> <br>TimeDate TimeDate::operator-(TimeDate a) <br>{ <br>  TimeDate td; <br>  td.usec = usec - a.usec; <br>  td.t.tm_sec = t.tm_sec - a.t.tm_sec; <br>  td.t.tm_min = t.tm_min - a.t.tm_min; <br>  td.t.tm_hour = t.tm_hour - a.t.tm_hour; <br>  td.t.tm_mday = t.tm_mday - a.t.tm_mday; <br>  td.t.tm_mon = t.tm_mon - a.t.tm_mon; <br>  td.t.tm_year = t.tm_year - a.t.tm_year; <br>  td.t.tm_wday = t.tm_wday - a.t.tm_wday; <br>  td.t.tm_yday = t.tm_yday - a.t.tm_yday; <br>  return td; <br>} <br> <br>TimeDate TimeDate::operator*(float f) <br>{ <br>  TimeDate td; <br>  td.usec = (long)((float)usec * f); <br>  td.t.tm_sec = (int)((float)t.tm_sec * f); <br>  td.t.tm_min = (int)((float)t.tm_min * f); <br>  td.t.tm_hour = (int)((float)t.tm_hour * f); <br>  td.t.tm_mday = (int)((float)t.tm_mday * f); <br>  td.t.tm_mon = (int)((float)t.tm_mon * f); <br>  td.t.tm_year = (int)((float)t.tm_year * f); <br>  td.t.tm_wday = (int)((float)t.tm_wday * f); <br>  td.t.tm_yday = (int)((float)t.tm_yday * f); <br>  return td; <br>} <br> <br>TimeDate TimeDate::read_time() <br>{ <br> <br>#ifdef X11 <br>  struct timeval tv; <br>#else <br>  LPSYSTEMTIME lpst; <br>#endif <br> <br>  time_t cal_time; <br>  struct tm *tmp; <br> <br>  cal_time = time(NULL); <br>  tmp = localtime(&amp;cal_time); <br> <br>#ifdef X11 <br>  gettimeofday(&amp;tv); <br>  usec = tv.tv_usec; <br>#else <br>  lpst = (LPSYSTEMTIME) malloc(sizeof(SYSTEMTIME)); <br>  GetSystemTime(lpst); <br>  usec = 1000 * lpst-&gt;wMilliseconds; <br>#endif <br> <br>  t = *tmp; <br>  return *this; <br>} <br> <br>void TimeDate::print() <br>{ <br>  puts(asctime(&amp;t)); <br>} <br> <br> <br>/* The sun_direction routine comes from an awk program by Stuart Levy <br> * (slevy@geom.umn.edu) */ <br> <br>/* Day number of March 21st, roughly the vernal equinox */ <br>const float equinox = mday[0] + mday[1] + 21; <br> <br>/* <br> *        Date     E.T. [degrees] <br> *        Jan 1    0.82 <br> *        Jan 31   3.35 <br> *        Mar 1    3.08 <br> *        Mar 31   1.02 <br> *        Apr 30  -0.71 <br> *        May 30  -0.62 <br> *        Jun 29   0.87 <br> *        Jul 29   1.60 <br> *        Aug 28   0.28 <br> *        Sep 27  -2.28 <br> *        Oct 27  -4.03 <br> *        Nov 26  -3.15 <br> *        Dec 26   0.19 <br> */ <br>const float et[] = { <br>  .82, 3.35, 3.08, 1.02, -.71, -.62, .87, <br>  1.60, .28, -2.28, -4.03, -3.15, .19, 2.02}; <br> <br>const float DEG = 180. / M_PI; <br> <br>Point TimeDate::sun_direction(float lon, float lat) <br>{ <br>  float yearday, eti, etoffset, ET, HA, LON, decl, altitude, azimuth; <br>  int etindex; <br>  Point dir; <br>  long tmp_usec; <br>  int m; <br> <br>  tmp_usec = usec; <br>  usec = 0; <br>  *this = correct_smaller(); <br> <br>  /* <br>   *   hour angle of the sun (time since local noon): <br>   *       HA = (time - noon) * 15 degrees/hour <br>   *          + (observer''s east longitude - long. of time zone''s  <br>   *       central meridian <br>   *                           POSITIVE east, NEGATIVE west) <br>   *          - (15 degrees if time above was daylight savings time, else 0) <br>   *          - "equation of time" (depends on date, correcting the  <br>   *   hour angle for <br>   *               the earth''s elliptical orbit and the slope of the ecliptic) <br>   */ <br>  yearday = (float)t.tm_mday +  <br>    ((float)t.tm_hour + (float)t.tm_min / 60.0) / 24.0; <br>  for (m = 0; m &lt; t.tm_mon; m++) yearday += mday[m]; <br> <br>  /* <br>   * Index into equation-of-time table, tabulated at 30-day intervals <br>   * We''ve added an extra entry at the end of the et table, corresponding <br>   * to January 25th of the following year, to make interpolation work <br>   * throughout the year. <br>   * Use simple linear interpolation. <br>   */ <br>  eti = (yearday - 1.) / 30.; <br>#ifdef X11 <br>  etoffset = eti - trunc(eti); <br>  etindex = (int)trunc(eti) + 1; <br>#else <br>  etoffset = eti - (int)eti; <br>  etindex = (int)eti + 1; <br>#endif <br>  ET = et[etindex - 1] + etoffset*(et[etindex+1 - 1] - et[etindex - 1]); <br>  /* The 90. puts us in the Central time zone */ <br>  HA = ((float)t.tm_hour + (float)t.tm_min/60. - 12.)*15. + <br>    lon + 90. - ET; <br> <br>  /* <br>   *    Sun''s declination: <br>   *        sun''s longitude = (date - March 21) * 360 degrees / 365.25 days <br>   *                [This ignores the earth''s elliptical orbit...] <br>   */ <br>  LON = (yearday - equinox) * 360. / 365.25; <br>  decl = DEG * arcsin( sin(LON/DEG) * sin(23.4/DEG) ); <br> <br>  /*  <br>   *    Then a spherical triangle calculation to convert the Sun''s <br>   *    hour angle and declination, and the observer''s latitude, <br>   *    to give the Sun''s altitude and azimuth (angle east from north). <br>   */ <br>  altitude = DEG * arcsin( sin(decl/DEG)*sin(lat/DEG)  <br>  + cos(decl/DEG)*cos(lat/DEG)*cos(HA/DEG) ); <br>  azimuth = DEG * atan2( -cos(decl/DEG)*sin(HA/DEG),  <br>sin(decl/DEG)*cos(lat/DEG)  <br>- cos(decl/DEG)*cos(HA/DEG)*sin(lat/DEG) ); <br> <br>  /* <br>  printf("On %d/%d at %d:%02d, lat %g, lon %g\n",  <br> t.tm_mon + 1, t.tm_mday + 1, t.tm_hour, t.tm_min, lat, lon); <br>  printf("HA %.1f ET %.1f Sun lon %.1f decl %.1f alt %.1f az %.1f\n",  <br> HA,ET,LON,decl,altitude,azimuth); <br>  */ <br>   <br>  dir.pt[2] = sin(radians(altitude)); <br>  dir.pt[0] = cos(radians(azimuth)); <br>  dir.pt[1] = sin(radians(azimuth)); <br>  dir.pt[3] = 0; <br>  dir.unitize(); <br>  // dir.print(); <br> <br>  usec = tmp_usec; <br> <br>  return dir; <br>} <br> <br>TimeDate TimeDate::correct_bigger() <br>{ <br>  TimeDate td; <br>  int days; <br> <br>  td.t = t; <br>  td.usec = usec; <br> <br>  td.t.tm_sec += (int)(td.usec / 1000000); <br>  td.usec %= 1000000; <br>  td.t.tm_min += td.t.tm_sec / 60; <br>  td.t.tm_sec %= 60; <br>  td.t.tm_hour += td.t.tm_min / 60; <br>  td.t.tm_min %= 60; <br> <br>  if (td.t.tm_hour &gt; 23) { <br>    days = td.t.tm_hour / 24; <br>    td.t.tm_hour %= 24; <br>    td.t.tm_mday += days; <br>    td.t.tm_wday = (td.t.tm_wday + days) % 7; <br>    td.t.tm_yday = (td.t.tm_yday + days) % 365; <br>    while (td.t.tm_mday &gt; mday[td.t.tm_mon]) { <br>      td.t.tm_mday -= mday[td.t.tm_mon++]; <br>      if (td.t.tm_mon &gt;= 12) { <br>td.t.tm_year += td.t.tm_mon / 12; <br>td.t.tm_mon %= 12; <br>      } <br>    } <br>  } <br>  return td; <br>} <br> <br>TimeDate TimeDate::correct_smaller() <br>{ <br>  TimeDate td; <br> <br>  td.t = t; <br>  td.usec = usec; <br> <br>  while (td.usec &lt; 0) { <br>    td.t.tm_sec--; <br>    td.usec += 1000000; <br>  } <br>  while (td.t.tm_sec &lt; 0) { <br>    td.t.tm_min--; <br>    td.t.tm_sec += 60; <br>  } <br>  while (td.t.tm_min &lt; 0) { <br>    td.t.tm_hour--; <br>    td.t.tm_min += 60; <br>  } <br>  while (td.t.tm_hour &lt; 0) { <br>    td.t.tm_mday--; <br>    if (td.t.tm_wday) td.t.tm_wday--; <br>    else td.t.tm_wday = 6; <br>    td.t.tm_yday--; <br>    td.t.tm_hour += 24; <br>  } <br>  if (td.t.tm_mon &lt; 0 || td.t.tm_year &lt; 0 || td.t.tm_yday &lt; 0)  { <br>    //fprintf(stderr, "Warning:  day &lt; 0 in TimeDate.c++.\n"); <br>    td.t.tm_mon = td.t.tm_year = td.t.tm_yday = 0; <br>  } <br>  return td.correct_bigger(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
