<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POINT.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3618"></a>POINT.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;GL/gl.h&gt; <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#ifdef WIN32 <br>#include "stonehen.h" <br>#endif <br> <br>#define POINT_EXTERN <br>#include "Point.h" <br> <br>Point Point::rotate_abouty(GLfloat c, GLfloat s) <br>{ <br>  val.pt[0] = c*pt[0] + s*pt[2]; <br>  val.pt[1] = pt[1]; <br>  val.pt[2] = -s*pt[0] + c*pt[2]; <br>  return val; <br>} <br> <br>Point Point::rotate_aboutz(GLfloat c, GLfloat s) <br>{ <br>  val.pt[0] = c*pt[0] - s*pt[1]; <br>  val.pt[1] = s*pt[0] + c*pt[1]; <br>  val.pt[2] = pt[2]; <br>  return val; <br>} <br> <br>void Point::refract_self(Point light, Point N, GLfloat I) <br>{ <br>  GLfloat t; <br>  Point dlight; <br> <br>  dlight = refract_direction(light, N, I); <br>  t = -pt[2] / dlight.pt[2];  <br>  pt[0] = pt[0] + dlight.pt[0]*t; <br>  pt[1] = pt[1] + dlight.pt[1]*t; <br>  pt[2] = 0; <br>} <br> <br>Point Point::refract_direction(Point light, Point N, GLfloat I)  <br>{ <br>  GLfloat cos1, sin1, cos2, sin2, m; <br>  GLfloat dlight[3], dN[3], axis[3]; <br>   <br>  /* dlight = (light - *this).unit() * -1.0; */  <br>  dlight[0] = pt[0] - light.pt[0];  <br>  dlight[1] = pt[1] - light.pt[1];  <br>  dlight[2] = pt[2] - light.pt[2];  <br>  m = sqrt(dlight[0]*dlight[0] + dlight[1]*dlight[1] + dlight[2]*dlight[2]); <br>  dlight[0] /= m; <br>  dlight[1] /= m; <br>  dlight[2] /= m; <br>   <br>  // dN = N * -1.0;  <br>  dN[0] = -N.pt[0];  <br>  dN[1] = -N.pt[1];  <br>  dN[2] = -N.pt[2];  <br>   <br>  // cos1 = dN.dot(dlight);  <br>  cos1 = dN[0]*dlight[0] + dN[1]*dlight[1] + dN[2]*dlight[2]; <br>   <br>  if (1.0 - cos1*cos1 &lt; point_fudge) { <br>    val = dN; <br>    return val; <br>  } <br>   <br>  // axis = ((dN * dlight) * dN).unit();  <br>  val.pt[0] = dN[1]*dlight[2] - dlight[1]*dN[2]; <br>  val.pt[1] = dN[2]*dlight[0] - dlight[2]*dN[0]; <br>  val.pt[2] = dN[0]*dlight[1] - dN[1]*dlight[0]; <br>  axis[0] = val.pt[1]*dN[2] - dN[1]*val.pt[2]; <br>  axis[1] = val.pt[2]*dN[0] - dN[2]*val.pt[0]; <br>  axis[2] = val.pt[0]*dN[1] - val.pt[1]*dN[0]; <br>  m = sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]); <br>  axis[0] /= m; <br>  axis[1] /= m; <br>  axis[2] /= m; <br>   <br>  if (axis[0]*axis[0] &gt; point_fudge)   <br>    sin1 = (dlight[0] - dN[0] * cos1) / axis[0];  <br>  else if (axis[1]*axis[1] &gt; point_fudge)   <br>    sin1 = (dlight[1] - dN[1] * cos1) / axis[1];  <br>  else sin1 = dlight[2] - dN[2] * cos1;  <br>   <br>  sin2 = sin1 / I;  <br>  cos2 = (sin1*sin1 &lt; 1.0) ? sqrt(1.0 - sin2*sin2) : 0;  <br>   <br>  dlight[0] = dN[0]*cos2 + axis[0]*sin2; <br>  dlight[1] = dN[1]*cos2 + axis[1]*sin2; <br>  dlight[2] = dN[2]*cos2 + axis[2]*sin2; <br>   <br>  /* I'm not sure this is quite legal */  <br>  if (dlight[2] &gt; 0.0) dlight[2] = -dlight[2];    <br>   <br>  val = dlight; <br> <br>  return val; <br>} <br> <br>void Point::print() <br>{ <br>  print("%f %f %f\n"); <br>} <br> <br>void Point::print(const char *format) <br>{ <br>  printf(format, this-&gt;pt[0], this-&gt;pt[1], this-&gt;pt[2], 1.0); <br>}     </code></pre>
<p>&nbsp;</p></body>
</HTML>
