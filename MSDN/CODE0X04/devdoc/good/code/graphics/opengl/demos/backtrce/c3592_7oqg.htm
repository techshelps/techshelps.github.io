<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UNITDISK.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3598"></a>UNITDISK.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;GL/glu.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br> <br>#include "Unitdisk.hxx" <br> <br>const float fudge = .000001; <br>const float M_2PI = 2.0 * M_PI; <br> <br>Unitdisk::Unitdisk() <br>{ <br>  rdivisions = 3; <br>  tdivisions = 10; <br>  points = normals = NULL; <br>  colors = NULL; <br>  points_size = normals_size = colors_size = 0; <br>  angle = M_PI; <br>  zaxis[0] = 0; <br>  zaxis[1] = 0; <br>  zaxis[2] = 1; <br> <br>  still_in_xy = 1; <br> <br>  sintable = costable = NULL; <br>} <br> <br> <br>Unitdisk::~Unitdisk() <br>{ <br>} <br> <br>void Unitdisk::draw() <br>{ <br>  if (points == NULL) return; <br>  glNormal3f(0, 0, 1); <br>  if (colors == NULL) draw_nocolors(); <br>  else if (normals == NULL) draw_colors_nonormals(); <br>  else draw_colors_normals(); <br>} <br> <br>void Unitdisk::draw_nocolors() <br>{ <br>  int r, t, p1, p2; <br>  int has_n; <br> <br>  has_n = (normals != NULL); <br> <br>  for (t = 1; t &lt; tdivisions; t++) { <br>    glBegin(GL_QUAD_STRIP); <br>    p1 = t * (rdivisions + 1); <br>    p2 = (t - 1) * (rdivisions + 1); <br>    for (r = 0; r &lt;= rdivisions; r++, p1++, p2++) { <br>      if (has_n) glNormal3fv(normals[p1].pt); <br>#ifdef TEXTURE <br>      glTexCoord2fv(points[p1].pt); <br>#endif <br>      glVertex3fv(points[p1].pt); <br>      if (has_n) glNormal3fv(normals[p2].pt); <br>#ifdef TEXTURE <br>      glTexCoord2fv(points[p2].pt); <br>#endif <br>      glVertex3fv(points[p2].pt); <br>    }  <br>    glEnd();  <br>  } <br>   <br>  glBegin(GL_QUAD_STRIP);  <br>  p1 = 0; <br>  p2 = (rdivisions + 1) * (tdivisions - 1); <br>  for (r = 0; r &lt;= rdivisions; r++, p1++, p2++) { <br>    if (has_n) glNormal3fv(normals[p1].pt); <br>#ifdef TEXTURE <br>    glTexCoord2fv(points[p1].pt); <br>#endif <br>    glVertex3fv(points[p1].pt); <br>    if (has_n) glNormal3fv(normals[p2].pt); <br>#ifdef TEXTURE <br>    glTexCoord2fv(points[p2].pt); <br>#endif <br>    glVertex3fv(points[p2].pt); <br>  } <br>  glEnd(); <br>} <br> <br>void Unitdisk::draw_colors_nonormals() <br>{   <br>  int r, t, p1, p2; <br> <br>  for (t = 1; t &lt; tdivisions; t++) { <br>    glBegin(GL_QUAD_STRIP); <br>    p1 = t * (rdivisions + 1); <br>    p2 = (t - 1) * (rdivisions + 1); <br>    for (r = 0; r &lt;= rdivisions; r++, p1++, p2++) { <br>      glColor4fv(colors[p1].c); <br>#ifdef TEXTURE <br>      glTexCoord2fv(points[p1].pt); <br>#endif <br>      glVertex3fv(points[p1].pt); <br>      glColor4fv(colors[p2].c); <br>#ifdef TEXTURE <br>      glTexCoord2fv(points[p2].pt); <br>#endif <br>      glVertex3fv(points[p2].pt); <br>    }  <br>    glEnd();  <br>  } <br>   <br>  glBegin(GL_QUAD_STRIP);  <br>  p1 = 0; <br>  p2 = (rdivisions + 1) * (tdivisions - 1); <br>  for (r = 0; r &lt;= rdivisions; r++, p1++, p2++) { <br>    glColor4fv(colors[p1].c); <br>#ifdef TEXTURE <br>    glTexCoord2fv(points[p1].pt); <br>#endif <br>    glVertex3fv(points[p1].pt); <br>    glColor4fv(colors[p2].c); <br>#ifdef TEXTURE <br>    glTexCoord2fv(points[p2].pt); <br>#endif <br>    glVertex3fv(points[p2].pt); <br>  } <br>  glEnd(); <br>} <br> <br>void Unitdisk::draw_colors_normals() <br>{ <br>  int r, t, p1, p2; <br> <br>  for (t = 1; t &lt; tdivisions; t++) { <br>    glBegin(GL_QUAD_STRIP); <br>    p1 = t * (rdivisions + 1); <br>    p2 = (t - 1) * (rdivisions + 1); <br>    for (r = 0; r &lt;= rdivisions; r++, p1++, p2++) { <br>      glColor4fv(colors[p1].c); <br>      glNormal3fv(normals[p1].pt); <br>#ifdef TEXTURE <br>      glTexCoord2fv(points[p1].pt); <br>#endif <br>      glVertex3fv(points[p1].pt); <br>      glColor4fv(colors[p2].c); <br>      glNormal3fv(normals[p2].pt); <br>#ifdef TEXTURE <br>      glTexCoord2fv(points[p2].pt); <br>#endif <br>      glVertex3fv(points[p2].pt); <br>    }  <br>    glEnd();  <br>  } <br>   <br>  glBegin(GL_QUAD_STRIP);  <br>  p1 = 0; <br>  p2 = (rdivisions + 1) * (tdivisions - 1); <br>  for (r = 0; r &lt;= rdivisions; r++, p1++, p2++) { <br>    glColor4fv(colors[p1].c); <br>    glNormal3fv(normals[p1].pt); <br>#ifdef TEXTURE <br>    glTexCoord2fv(points[p1].pt); <br>#endif <br>    glVertex3fv(points[p1].pt); <br>    glColor4fv(colors[p2].c); <br>    glNormal3fv(normals[p2].pt); <br>#ifdef TEXTURE <br>    glTexCoord2fv(points[p2].pt); <br>#endif <br>    glVertex3fv(points[p2].pt); <br>  } <br>  glEnd(); <br>} <br> <br>void Unitdisk::draw_by_perimeter(int pass_colors, int pass_norms,  <br> int pass_tex) <br>{ <br>  int i, index, r = rdivisions + 1; <br> <br>  if (points == NULL) return; <br>  if (pass_colors &amp;&amp; colors == NULL) { <br>    //fprintf(stderr, "Warning:  No colors to draw in Unitdisk.c++"); <br>    pass_colors = 0; <br>  } <br>  if (pass_norms &amp;&amp; normals == NULL) { <br>    //fprintf(stderr, "Warning:  No normals to draw in Unitdisk.c++"); <br>    pass_norms = 0; <br>  } <br>  glBegin(GL_POLYGON); <br>  for (i = 0, index = rdivisions; i &lt; tdivisions; i++, index += r) { <br>    if (pass_colors) glColor4fv(colors[index].c); <br>    if (pass_norms) glNormal3fv(normals[index].pt); <br>#ifdef TEXTURE <br>    if (pass_tex) glTexCoord2fv(points[index].pt); <br>#endif <br>    glVertex3fv(points[index].pt); <br>  } <br>  glEnd(); <br>   <br>} <br> <br>void Unitdisk::set_angle(float new_angle) <br>{ <br>  angle = new_angle; <br>} <br> <br>GLfloat Unitdisk::get_angle() <br>{ <br>  return angle; <br>} <br> <br>GLfloat Unitdisk::get_radius() <br>{ <br>  return (GLfloat)cos((double)((M_PI - angle) / 2.0)); <br>} <br> <br>void Unitdisk::set_divisions(int new_rdivisions, int new_tdivisions) <br>{ <br>  if (tdivisions != new_tdivisions) { <br>    delete sintable; <br>    delete costable; <br>    sintable = costable = NULL; <br>  } <br>  if (tdivisions != new_tdivisions || rdivisions != new_rdivisions) { <br>    rdivisions = new_rdivisions; <br>    tdivisions = new_tdivisions; <br>    free_points(); <br>    free_normals(); <br>    free_colors(); <br>  } <br>} <br>   <br>int Unitdisk::get_rdivisions() <br>{ <br>  return rdivisions; <br>} <br> <br>int Unitdisk::get_tdivisions() <br>{ <br>  return tdivisions; <br>} <br> <br>void Unitdisk::alloc_points() <br>{ <br>  int npoints = get_npoints(); <br>  if (npoints &gt; points_size) { <br>    delete points; <br>    points = new Point[npoints]; <br>    points_size = npoints; <br>  } <br>} <br> <br>void Unitdisk::alloc_normals() <br>{ <br>  int npoints = get_npoints(); <br>  if (npoints &gt; normals_size) { <br>    delete normals; <br>    normals = new Point[npoints]; <br>    normals_size = npoints; <br>  } <br>} <br> <br>void Unitdisk::alloc_points_normals() <br>{ <br>  alloc_points(); <br>  alloc_normals(); <br>} <br> <br>void Unitdisk::free_points()  <br>{ <br>  delete points; <br>  points = NULL; <br>  points_size = 0; <br>} <br> <br>void Unitdisk::free_normals() <br>{ <br>  delete normals; <br>  normals = NULL; <br>  normals_size = 0; <br>} <br> <br>void Unitdisk::free_points_normals() <br>{ <br>  free_points(); <br>  free_normals(); <br>} <br> <br>void Unitdisk::fill_points() <br>{ <br>  alloc_points(); <br>  fill_either(points); <br>} <br> <br>void Unitdisk::fill_normals() <br>{ <br>  alloc_normals(); <br>  fill_either(normals); <br>} <br> <br>void Unitdisk::fill_points_normals() <br>{ <br>  alloc_points(); <br>  alloc_normals(); <br>  fill_either(points); <br>  fill_either(normals); <br>} <br> <br>void Unitdisk::copy_points(Unitdisk src)  <br>{ <br>  set_divisions(src.rdivisions, src.tdivisions); <br>  alloc_points(); <br>  copy_either(points, src.points); <br>} <br> <br>void Unitdisk::copy_normals(Unitdisk src)  <br>{ <br>  set_divisions(src.rdivisions, src.tdivisions); <br>  alloc_normals(); <br>  copy_either(normals, src.normals); <br>} <br> <br>void Unitdisk::copy_either(Point *dpt, Point *spt) { <br>  int i, npoints; <br>  npoints = get_npoints(); <br>  for (i = 0; i &lt; npoints; i++, dpt++, spt++) { <br>    dpt-&gt;pt[0] = spt-&gt;pt[0]; <br>    dpt-&gt;pt[1] = spt-&gt;pt[1]; <br>    dpt-&gt;pt[2] = spt-&gt;pt[2]; <br>  } <br>}   <br> <br>void Unitdisk::copy_normals_from_points(Unitdisk src) { <br>  set_divisions(src.rdivisions, src.tdivisions); <br>  alloc_normals(); <br>  copy_either(normals, src.points); <br>} <br> <br>void Unitdisk::copy_normals_from_points() { <br>  copy_normals_from_points(*this); <br>} <br> <br>void Unitdisk::fill_either(Point *what) { <br>  int t, r; <br>  int i; <br> <br>  fill_either_strip1(what); <br>  if (sintable == NULL) fill_trig_tables(); <br>  i = rdivisions + 1; <br>  for (t = 1; t &lt; tdivisions; t++) { <br>    for (r = 0; r &lt;= rdivisions; r++) { <br>      what[i].pt[0] = costable[t] * what[r].pt[0]; <br>      what[i].pt[1] = sintable[t] * what[r].pt[0]; <br>      what[i].pt[2] = what[r].pt[2]; <br>      i++; <br>    } <br>  } <br>} <br> <br>void Unitdisk::fill_points_strip1() <br>{ <br>  alloc_points(); <br>  fill_either_strip1(points); <br>} <br> <br>void Unitdisk::fill_either_strip1(Point *what) { <br>  float radius, rinc; <br>  int r; <br> <br>  rinc = get_radius() / (float)rdivisions; <br>  radius = 0.0; <br>  for (r = 0; r &lt;= rdivisions; r++, radius += rinc) { <br>    what[r].pt[0] = radius; <br>    what[r].pt[1] = 0; <br>    // Round-off error avoidance hack <br>    what[r].pt[2] = (GLfloat)(1.0 - what[r].pt[0]*what[r].pt[0]); <br>    if (what[r].pt[2] &gt; 0.0) what[r].pt[2] = (GLfloat)sqrt((double)what[r].pt[2]); <br>    else what[r].pt[2] = 0.0; <br>  } <br>} <br> <br>void Unitdisk::translate(Point trans) <br>{ <br>  int i, npoints; <br>  npoints = get_npoints(); <br>  for (i = 0; i &lt; npoints; i++) { <br>    points[i].pt[0] += trans.pt[0]; <br>    points[i].pt[1] += trans.pt[1]; <br>    points[i].pt[2] += trans.pt[2]; <br>  } <br>} <br> <br>void Unitdisk::scale(float s)  <br>{ <br>  int i, npoints; <br>  npoints = get_npoints(); <br>  for (i = 0; i &lt; npoints; i++) { <br>    points[i].pt[0] *= s; <br>    points[i].pt[1] *= s; <br>    points[i].pt[2] *= s; <br>  } <br>} <br> <br>void Unitdisk::scale_translate(float s, Point trans)  <br>{ <br>  int i, npoints; <br>  npoints = get_npoints(); <br>  for (i = 0; i &lt; npoints; i++) { <br>    points[i].pt[0] = points[i].pt[0]*s + trans.pt[0]; <br>    points[i].pt[1] = points[i].pt[1]*s + trans.pt[1]; <br>    points[i].pt[2] = points[i].pt[2]*s + trans.pt[2]; <br>  } <br>} <br> <br>int Unitdisk::get_npoints()  <br>{ <br>  return (rdivisions + 1) * tdivisions; <br>} <br> <br>void Unitdisk::project() <br>{ <br>  int i, npoints; <br> <br>  if (normals == NULL) { <br>    //fprintf(stderr, "Warning:  No normals defined when project() called.\n"); <br>    fill_normals(); <br>  } <br>  if (points == NULL) fill_points(); <br>  npoints = get_npoints(); <br>  for (i = 0; i &lt; npoints; i++) { <br>    /* I'm not sure quite what the justification for this is, but it <br>     * seems to work */ <br>    if (normals[i].pt[2] &lt; 0.0) normals[i].pt[2] = -normals[i].pt[2]; <br>    points[i] = points[i].project_direction(normals[i]); <br>  } <br>} <br> <br>void Unitdisk::project(Point projpt) <br>{ <br>  int i, npoints = get_npoints(); <br>  float x, y, z; <br>  Point *pt; <br> <br>  if (points == NULL) fill_points(); <br>  x = projpt.pt[0]; <br>  y = projpt.pt[1]; <br>  z = projpt.pt[2]; <br>  pt = points; <br>  for (i = 0; i &lt; npoints; i++, pt++) pt-&gt;project_self(x, y, z); <br>} <br> <br>void Unitdisk::project_borrow_points(Unitdisk src)  <br>{ <br>  int i, npoints = get_npoints(); <br>  Point *pt, *spt, *sn; <br>  spt = src.points; <br>  sn = normals; <br>  alloc_points(); <br>  pt = points; <br>  for (i = 0; i &lt; npoints; i++, pt++, spt++, sn++) { <br>    /* I'm not sure quite what the justification for this is, but it <br>     * seems to work */ <br>    if (normals[i].pt[2] &lt; 0.0) normals[i].pt[2] = -normals[i].pt[2]; <br>    pt-&gt;compute_projected(spt-&gt;pt[0], spt-&gt;pt[1], spt-&gt;pt[2],  <br>  sn-&gt;pt[0], sn-&gt;pt[1], sn-&gt;pt[2]); <br>  } <br>} <br> <br>void Unitdisk::refract_normals(Point light, GLfloat I) <br>{ <br>  Point dlight; <br>  float cos1, sin1, cos2, sin2; <br>  int use_normals; <br>  int r, t, i; <br> <br>  if (points == NULL) { <br>    //fprintf(stderr, "Attempting to refract without points.\n"); <br>    fill_normals(); <br>  } <br> <br>  use_normals = (normals != NULL); <br>  alloc_normals(); <br> <br>  /* Do the theta = 0 diagonal */ <br>  for (r = 0; r &lt;= rdivisions; r++) { <br>    /* Find the original normal - use the unit of the points if there are <br>     * no normals */ <br>    if (!use_normals) normals[r] = points[r].unit(); <br> <br>    /* Compute the direction to the light */ <br>    dlight = (light - points[r]).unit(); <br> <br>    /* Compute the cosine and the sine of the original angle */ <br>    cos1 = dlight.dot(normals[r]); <br>    sin1 = (float)(1.0 - cos1*cos1); <br>    if (sin1 &lt;= 0.0) continue; <br>    sin1 = (float)sqrt((double)sin1); <br> <br>    /* Compute the cosine and the sine of the new angle */ <br>    sin2 = sin1 / I; <br>    cos2 = (float)sqrt((double)(1.0 - sin2*sin2)); <br> <br>    /* Rotate the normal by the new sine and cosine */ <br>    normals[r] = normals[r].rotate_abouty(cos2, -sin2); <br>  } <br> <br>  /* Copy the rest of the rows from the current row */ <br>  i = rdivisions + 1; <br>  if (sintable == NULL) fill_trig_tables(); <br>  for (t = 1; t &lt; tdivisions; t++) { <br>    for (r = 0; r &lt;= rdivisions; r++) { <br>      normals[i].pt[0] = costable[t] * normals[r].pt[0]; <br>      normals[i].pt[1] = sintable[t] * normals[r].pt[0]; <br>      normals[i].pt[2] = normals[r].pt[2]; <br>      i++; <br>    } <br>  } <br> <br>} <br> <br>void Unitdisk::face_direction(Point d) <br>{ <br>  face_direction(d, *this); <br>} <br> <br>void Unitdisk::face_direction(Point d, Unitdisk src)  <br>{ <br>  Point *spt, *dpt, *sn, *dn; <br>  float sin1, cos1; <br>  float x; <br>  int npoints, i; <br> <br>  if (d.pt[1]) { <br>    /*fprintf(stderr, <br>    "Internal error:  Can't face in direction not in xz plane.");*/ <br>    return; <br>  } <br> <br>  cos1 = d.pt[2]; <br>  sin1 = d.pt[0]; <br>   <br>  if (sin1 * sin1 &gt; fudge) { <br>    spt = src.points; <br>    dpt = points; <br>    sn = src.normals; <br>    dn = normals; <br>    /* Change this to be seperate loops for points&amp;&amp;normals, points, normals <br>     * (faster than testing every iteration */ <br>    npoints = get_npoints(); <br>    for (i = 0; i &lt; npoints; i++) { <br>      if (points != NULL) { <br>x = spt-&gt;pt[0]; <br>dpt-&gt;pt[0] = x*cos1 + spt-&gt;pt[2]*sin1; <br>dpt-&gt;pt[1] = spt-&gt;pt[1]; <br>dpt-&gt;pt[2] = -x*sin1 + spt-&gt;pt[2]*cos1; <br>spt++; dpt++; <br>      } <br>      if (normals != NULL) { <br>x = sn-&gt;pt[0]; <br>dn-&gt;pt[0] = x*cos1 + sn-&gt;pt[2]*sin1; <br>dn-&gt;pt[1] = sn-&gt;pt[1]; <br>dn-&gt;pt[2] = -x*sin1 + sn-&gt;pt[2]*cos1; <br>sn++; dn++; <br>      } <br>    } <br>  } else if (points != NULL &amp;&amp; points != src.points) { <br>    copy_points(src); <br>    if (normals != NULL) copy_normals(src); <br>  } <br>}   <br> <br>void Unitdisk::alloc_colors() <br>{ <br>  int ncolors = get_npoints(); <br>  if (ncolors &gt; colors_size) { <br>    delete colors; <br>    colors = new Color[ncolors]; <br>    colors_size = ncolors; <br>  } <br>} <br> <br>void Unitdisk::map_normals_to_colors()  <br>{ <br>  int t, r; <br>  int i; <br> <br>  if (normals == NULL) fill_normals(); <br>  alloc_colors(); <br>  i = 0; <br>  for (t = 1; t &lt;= tdivisions; t++) { <br>    for (r = 0; r &lt;= rdivisions; r++) { <br>      colors[i] *= normals[r].pt[2]; <br>      colors[i].c[3] = 1; <br>      i++; <br>    } <br>  } <br>} <br> <br>void Unitdisk::map_z_to_colors() <br>{ <br>  int i, npoints = get_npoints(); <br> <br>  if (points == NULL) { <br>    //fprintf(stderr, "Warning:  no points defined in map_z_to_colors()\n"); <br>    fill_points(); <br>  } <br> <br>  alloc_colors(); <br>  for (i = 0; i &lt; npoints; i++) { <br>    colors[i] = points[i].pt[2]; <br>    colors[i].c[3] = 1; <br>  } <br>} <br> <br>void Unitdisk::scale_alpha_by_z() <br>{ <br>  int i, npoints = get_npoints(); <br>   <br>  if (colors == NULL) alloc_colors(); <br>  if (points == NULL) { <br>    alloc_points(); <br>    fill_points(); <br>  } <br>  for (i = 0; i &lt; npoints; i++) colors[i].c[3] *= points[i].pt[2]; <br>} <br> <br>void Unitdisk::scale_colors_by_z()  <br>{ <br>  int i, npoints = get_npoints(); <br> <br>  if (colors == NULL) alloc_colors(); <br>  if (points == NULL) { <br>    alloc_points(); <br>    fill_points(); <br>  } <br>  for (i = 0; i &lt; npoints; i++) colors[i] *= points[i].pt[2]; <br>} <br> <br>void Unitdisk::scale_colors_by_normals(Point light) <br>{ <br>  scale_colors_by_normals(light, *this); <br>} <br> <br>void Unitdisk::scale_colors_by_normals(Point light, Unitdisk src_normals) <br>{ <br>  scale_colors_by_either(light, src_normals.normals); <br>} <br> <br>void Unitdisk::scale_colors_by_points(Point light, Unitdisk src_points) <br>{ <br>  scale_colors_by_either(light, src_points.points); <br>} <br> <br>void Unitdisk::scale_colors_by_either(Point light, Point *what) <br>{ <br>  int t, r; <br>  int i; <br>  if (what == NULL) { <br>    //fprintf(stderr, "Scaling colors to NULL pointer.\n"); <br>    return; <br>  } <br>  /*if (light.pt[0] || light.pt[1] || light.pt[2] &lt; 0.0) { <br>    fprintf(stderr, "Light not on z axis in scale_colors_by_normals.\n"); <br>  }*/ <br> <br>  alloc_colors(); <br>  for (r = 0; r &lt;= rdivisions; r++)  <br>    colors[r] *= what[r].dot(light); <br>  i = rdivisions + 1; <br>  for (t = 1; t &lt; tdivisions; t++) { <br>    for (r = 0; r &lt;= rdivisions; r++) { <br>      colors[i] = colors[r]; <br>      i++; <br>    } <br>  } <br>}   <br> <br>void Unitdisk::set_colors(Color c) <br>{ <br>  Color *dst; <br>  int i, npoints = get_npoints(); <br>  alloc_colors(); <br>  dst = colors; <br>  for (i = 0; i &lt; npoints; i++, dst++) { <br>    dst-&gt;c[0] = c.c[0]; <br>    dst-&gt;c[1] = c.c[1]; <br>    dst-&gt;c[2] = c.c[2]; <br>    dst-&gt;c[3] = c.c[3]; <br>  } <br>} <br> <br>void Unitdisk::add_colors(Color c) <br>{ <br>  int i, npoints = get_npoints(); <br>  alloc_colors(); <br>  for (i = 0; i &lt; npoints; i++) colors[i] += c; <br>} <br> <br>void Unitdisk::free_colors() <br>{ <br>  delete colors; <br>  colors = NULL; <br>  colors_size = 0; <br>} <br> <br>inline float Unitdisk::area_triangle(Point a, Point b, Point c) <br>{ <br>  return (float)(((a.pt[0]*b.pt[1] + b.pt[0]*c.pt[1] + c.pt[0]*a.pt[1]) - <br>   (a.pt[1]*b.pt[0] + b.pt[1]*c.pt[0] + c.pt[1]*a.pt[0])) * .5); <br>} <br> <br>inline float Unitdisk::area_triangle(GLfloat *a, GLfloat *b,  <br>     GLfloat *c)  <br>{ <br>  return (float)(((a[0]*b[1] + b[0]*c[1] + c[0]*a[1]) - <br>   (a[1]*b[0] + b[1]*c[0] + c[1]*a[0])) * .5); <br>} <br> <br>inline float Unitdisk::area_2triangle(GLfloat *a, GLfloat *b,  <br>     GLfloat *c)  <br>{ <br>  return ((a[0]*b[1] + b[0]*c[1] + c[0]*a[1]) - <br>  (a[1]*b[0] + b[1]*c[0] + c[1]*a[0])); <br>} <br> <br>void Unitdisk::scale_colors_by_darea(Unitdisk disk)  <br>{ <br>  int pt1, pt2, pt3; <br>  int t, r, i; <br>  int npoints = get_npoints(); <br>  float *rproducts1, *tproducts1, *rproducts2, *tproducts2; <br>  float area1, area2; <br> <br>  rproducts1 = new float[npoints]; <br>  tproducts1 = new float[npoints]; <br>  rproducts2 = new float[npoints]; <br>  tproducts2 = new float[npoints]; <br> <br>  /* Compute the products of the segments which make up the disk -  <br>   * these will later be used in the area calculations */ <br>  i = 0; <br>  for (t = 0; t &lt; tdivisions; t++) { <br>    for (r = 0; r &lt; rdivisions; r++) { <br>      pt1 = i; <br>      pt2 = i + 1; <br>      rproducts1[i] = (points[pt1].pt[0]*points[pt2].pt[1] - <br>       points[pt1].pt[1]*points[pt2].pt[0]); <br>      rproducts2[i] = (disk.points[pt1].pt[0]*disk.points[pt2].pt[1] -  <br>       disk.points[pt1].pt[1]*disk.points[pt2].pt[0]); <br>      pt2 = ((t+1)%tdivisions)*(rdivisions + 1) + r; <br>      tproducts1[i] = (points[pt1].pt[0]*points[pt2].pt[1] - <br>       points[pt1].pt[1]*points[pt2].pt[0]); <br>      tproducts2[i] = (disk.points[pt1].pt[0]*disk.points[pt2].pt[1] -  <br>       disk.points[pt1].pt[1]*disk.points[pt2].pt[0]); <br>      i++; <br>    } <br>    pt1 = i; <br>    pt2 = ((t+1)%tdivisions)*(rdivisions + 1) + r; <br>    tproducts1[i] = (points[pt1].pt[0]*points[pt2].pt[1] - <br>     points[pt1].pt[1]*points[pt2].pt[0]); <br>    tproducts2[i] = (disk.points[pt1].pt[0]*disk.points[pt2].pt[1] -  <br>     disk.points[pt1].pt[1]*disk.points[pt2].pt[0]); <br>    i++; <br>  } <br> <br>  /* Compute the area at the center of the disk */ <br>  area1 = area2 = 0.0; <br>  r = 1; <br>  for (t = 0; t &lt;= tdivisions; t++) { <br>    pt1 = (t%tdivisions)*(rdivisions+1) + r; <br>    area1 += tproducts1[pt1]; <br>    area2 += tproducts2[pt1]; <br>  } <br>  if (area1 != 0.0) area1 = (float)fabs((double)(area2 / area1)); <br>  for (t = 0; t &lt; tdivisions; t++) { <br>    colors[t*(rdivisions+1)] *= area1; <br>  } <br> <br>  for (t = 0; t &lt; tdivisions; t++) { <br>    for (r = 1; r &lt; rdivisions; r++) { <br>      pt1 = (t ? t-1 : tdivisions-1)*(rdivisions+1) + r - 1; <br>      pt3 = t*(rdivisions + 1) + r - 1; <br>      pt2 = ((t+1) % tdivisions)*(rdivisions+1) + r - 1; <br>      area1 = rproducts1[pt1] + rproducts1[pt1 + 1]; <br>      area1 += tproducts1[pt1 + 2] + tproducts1[pt3 + 2]; <br>      area1 -= rproducts1[pt2 + 1] + rproducts1[pt2]; <br>      area1 -= tproducts1[pt3] + tproducts1[pt1]; <br>      area2 = rproducts2[pt1] + rproducts2[pt1 + 1]; <br>      area2 += tproducts2[pt1 + 2] + tproducts2[pt3 + 2]; <br>      area2 -= rproducts2[pt2 + 1] + rproducts2[pt2]; <br>      area2 -= tproducts2[pt3] + tproducts2[pt1]; <br>      if (area1 != 0.0) area1 = (float)fabs((double)(area2 / area1)); <br>      colors[pt3 + 1] *= area1; <br>    } <br>  } <br> <br>  /* Compute the area around the outside of the disk */ <br>  r = rdivisions; <br>  for (t = 0; t &lt; tdivisions; t++) { <br>    pt1 = (t ? t-1 : tdivisions-1)*(rdivisions+1) + r - 1; <br>    pt3 = t*(rdivisions + 1) + r - 1; <br>    pt2 = ((t+1) % tdivisions)*(rdivisions+1) + r - 1; <br>    area1 = rproducts1[pt1]; <br>    area1 += tproducts1[pt1 + 1] + tproducts1[pt3 + 1]; <br>    area1 -= rproducts1[pt2]; <br>    area1 -= tproducts1[pt1] + tproducts1[pt3]; <br>    area2 = rproducts2[pt1]; <br>    area2 += tproducts2[pt1 + 1] + tproducts2[pt3 + 1]; <br>    area2 -= rproducts2[pt2]; <br>    area2 -= tproducts2[pt1] + tproducts2[pt3]; <br>    if (area1 != 0.0) area1 = (float)fabs((double)(area2 / area1)); <br>    colors[pt3 + 1] *= area1; <br>  } <br> <br> <br>  delete rproducts1; <br>  delete tproducts1; <br>  delete rproducts2; <br>  delete tproducts2; <br>} <br> <br>void Unitdisk::fill_trig_tables() <br>{ <br>  int t; <br> <br>  delete sintable; <br>  delete costable; <br>  sintable = new float[tdivisions]; <br>  costable = new float[tdivisions]; <br>  for (t = 0; t &lt; tdivisions; t++) { <br>    costable[t] = (float)cos((double)(M_2PI * (float)t / (float)tdivisions)); <br>    sintable[t] = (float)sin((double)(M_2PI * (float)t / (float)tdivisions)); <br>  } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
