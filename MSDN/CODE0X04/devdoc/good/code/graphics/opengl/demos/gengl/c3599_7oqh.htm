<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENGL.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3599"></a>GENGL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br> <br>#include "gengl.h" <br> <br>CHAR szAppName[]="OpenGLGeneric"; <br> <br>HGLRC hRC; <br> <br>extern BOOL draw_cone; <br>extern BOOL draw_pyramid; <br>extern HPALETTE ghpalOld, ghPalette; <br> <br>/* forward declarations of helper functions in this module */ <br>HWND   WINAPI InitializeWindow (HINSTANCE, int); <br>LONG   WINAPI CommandHandler (HWND, WPARAM, LPARAM); <br>LONG   WINAPI MainWndProc (HWND, UINT, WPARAM, LPARAM); <br> <br>/* entry point of this executable */ <br>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG        msg; <br>    HWND       hWnd; <br> <br>    /* previous instances do not exist in Win32 */ <br>    if (hPrevInstance) <br>        return 0; <br> <br>    if (!(hWnd = InitializeWindow (hInstance, nCmdShow))) <br>        return FALSE; <br> <br>    /* main window message loop */ <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) <br>    { <br>      TranslateMessage (&amp;msg); <br>      DispatchMessage (&amp;msg); <br>    } <br> <br>    /* return success of application */ <br>    return TRUE; <br>} <br> <br>HWND WINAPI InitializeWindow (HINSTANCE hInstance, int nCmdShow) <br>    { <br>    WNDCLASS   wc; <br>    HWND       hWnd; <br> <br>    /* Register the frame class */ <br>    wc.style         = 0; <br>    wc.lpfnWndProc   = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon         = LoadIcon (hInstance, szAppName); <br>    wc.hCursor       = LoadCursor (NULL,IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = szAppName; <br>    wc.lpszClassName = szAppName; <br> <br>    if (!RegisterClass (&amp;wc) ) <br>        return FALSE; <br> <br>    /* Create the frame */ <br>    hWnd = CreateWindow (szAppName, <br>             "Generic OpenGL Sample", <br>     WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, <br>             CW_USEDEFAULT, <br>             CW_USEDEFAULT, <br>             CW_USEDEFAULT, <br>             CW_USEDEFAULT, <br>             NULL, <br>             NULL, <br>             hInstance, <br>             NULL); <br> <br>    /* make sure window was created */ <br>    if (!hWnd) <br>        return FALSE; <br> <br>    SendMessage(hWnd, WM_INIT, 0, 0L); <br> <br>    /* show and update main window */ <br>    ShowWindow (hWnd, nCmdShow); <br> <br>    UpdateWindow (hWnd); <br> <br>    return hWnd; <br>} <br> <br> <br> <br>/* main window procedure */ <br>LONG WINAPI MainWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>    LONG    lRet = 1; <br> <br>    switch (uMsg) <br>    { <br>    case WM_CREATE: <br>        { <br>    HDC  hDC; <br> <br>            hDC = GetDC(hWnd); <br>    bSetupPixelFormat(hDC); <br> <br>            hRC = wglCreateContext( hDC ); <br>            wglMakeCurrent( hDC, hRC ); <br>} <br>break; <br> <br> <br>    case WM_PAINT: <br>        {  <br>    HDChDC; <br>    PAINTSTRUCTps; <br> <br>    hDC = BeginPaint(hWnd, &amp;ps); <br> <br>    draw_scene(hWnd); <br> <br>    EndPaint(hWnd, &amp;ps); <br>        } <br>break; <br> <br>    case WM_INIT: <br>        initialize(hWnd); <br>        break; <br> <br>    case WM_SIZE: <br>        resize(hWnd); <br>            break; <br> <br>        // The WM_QUERYNEWPALETTE message informs a window that it is about to <br>        // receive input focus. In response, the window receiving focus should <br>        // realize its palette as a foreground palette and update its client <br>        // area. If the window realizes its palette, it should return TRUE; <br>        // otherwise, it should return FALSE. <br> <br>        case WM_QUERYNEWPALETTE: <br>        { <br>            HDC     hDC; <br> <br>            if(ghPalette) <br>            { <br>                hDC = GetDC(hWnd); <br> <br>                // Select and realize the palette <br> <br>                ghpalOld = SelectPalette(hDC, ghPalette, FALSE); <br>                RealizePalette(hDC); <br> <br>                // Redraw the client area <br> <br>                InvalidateRect(hWnd, NULL, TRUE); <br>                UpdateWindow(hWnd); <br> <br>                if(ghpalOld) <br>                    SelectPalette(hDC, ghpalOld, FALSE); <br> <br>                ReleaseDC(hWnd, hDC); <br> <br>                return TRUE; <br>            } <br> <br>            return FALSE; <br>        } <br> <br>        // The WM_PALETTECHANGED message informs all windows that the window <br>        // with input focus has realized its logical palette, thereby changing  <br>        // the system palette. This message allows a window without input focus <br>        // that uses a color palette to realize its logical palettes and update <br>        // its client area. <br>        // <br>        // This message is sent to all windows, including the one that changed <br>        // the system palette and caused this message to be sent. The wParam of <br>        // this message contains the handle of the window that caused the system <br>        // palette to change. To avoid an infinite loop, care must be taken to <br>        // check that the wParam of this message does not match the window's <br>        // handle. <br> <br>        case WM_PALETTECHANGED: <br>        { <br>            HDC         hDC;  <br> <br>            // Before processing this message, make sure we <br>            // are indeed using a palette <br> <br>            if (ghPalette) <br>            { <br>                // If this application did not change the palette, select <br>                // and realize this application's palette <br> <br>                if (wParam != (WPARAM)hWnd) <br>                { <br>                    // Need the window's DC for SelectPalette/RealizePalette <br> <br>                    hDC = GetDC(hWnd); <br> <br>                    // Select and realize our palette <br> <br>                    ghpalOld = SelectPalette(hDC, ghPalette, FALSE); <br>                    RealizePalette(hDC); <br> <br>                    // WHen updating the colors for an inactive window, <br>                    // UpdateColors can be called because it is faster than <br>                    // redrawing the client area (even though the results are <br>                    // not as good) <br> <br>                    UpdateColors(hDC); <br> <br>                    // Clean up <br> <br>                    if (ghpalOld) <br>                       SelectPalette(hDC, ghpalOld, FALSE); <br> <br>                    ReleaseDC(hWnd, hDC); <br>                } <br>            } <br>            break; <br>        } <br> <br> <br>    case WM_COMMAND: <br>            lRet = CommandHandler (hWnd, wParam, lParam); <br>            break; <br> <br>       case WM_CLOSE: <br>        { <br>        HGLRC hRC; <br>        HDC  hDC; <br> <br>                /* release and free the device context and rendering context */ <br>        hRC = wglGetCurrentContext(); <br>        hDC = wglGetCurrentDC(); <br> <br>        wglMakeCurrent(NULL, NULL); <br> <br>        if (hRC) <br>        wglDeleteContext(hRC); <br>        if (hDC) <br>            ReleaseDC(hWnd, hDC); <br> <br>                /* call destroy window to cleanup and go away */ <br>                DestroyWindow (hWnd); <br>        } <br>        break; <br> <br>       case WM_DESTROY: <br>        { <br>        HGLRC hRC; <br>        HDC  hDC; <br> <br>                /* release and free the device context and rendering context */ <br>        hRC = wglGetCurrentContext(); <br>        hDC = wglGetCurrentDC(); <br> <br>        wglMakeCurrent(NULL, NULL); <br> <br>        if (hRC) <br>        wglDeleteContext(hRC); <br>        if (hDC) <br>            ReleaseDC(hWnd, hDC); <br> <br>                PostQuitMessage (0); <br>        } <br>        break; <br> <br>    default: <br>            /* pass all unhandled messages to DefWindowProc */ <br>            lRet = DefWindowProc (hWnd, uMsg, wParam, lParam); <br>        break; <br>    } <br> <br>    /* return 1 if handled message, 0 if not */ <br>    return lRet; <br>} <br> <br> <br>/* handle all WM_COMMAND messages here */ <br>LONG WINAPI CommandHandler ( <br>    HWND    hWnd, <br>    WPARAM  wParam, <br>    LPARAM  lParam) <br>{ <br>    HMENU   hMenu; <br> <br>    switch (LOWORD(wParam)) <br>    { <br>    case IDM_EXIT: <br>            /* exit application */ <br>            PostMessage (hWnd, WM_CLOSE, 0, 0L); <br>        break; <br> <br>    case IDM_CONE: <br>    hMenu = GetMenu(hWnd); <br>    draw_cone = !draw_cone; <br>    CheckMenuItem(hMenu,IDM_CONE,(draw_cone?MF_CHECKED:MF_UNCHECKED)); <br>    PostMessage (hWnd, WM_PAINT, 0, 0L); <br>break; <br> <br>    case IDM_PYRAMID: <br>    hMenu = GetMenu(hWnd); <br>    draw_pyramid = !draw_pyramid; <br>    CheckMenuItem(hMenu,IDM_PYRAMID,(draw_pyramid?MF_CHECKED:MF_UNCHECKED)); <br>    PostMessage (hWnd, WM_PAINT, 0, 0L); <br>break; <br> <br>    default: <br>            return FALSE; <br>    } <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
