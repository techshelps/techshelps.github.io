<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RENDER.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3603"></a>RENDER.C</h2>
<pre><code>#include "gengl.h" <br> <br>HPALETTE ghpalOld, ghPalette = (HPALETTE) 0; <br> <br>BOOL draw_cone = FALSE; <br>BOOL draw_pyramid = FALSE; <br> <br>GLvoid drawCone(GLvoid); <br>GLvoid drawPyramid(GLvoid); <br> <br>GLfloat radius; <br>RECToldrect; <br> <br>unsigned char threeto8[8] = { <br>    0, 0111&gt;&gt;1, 0222&gt;&gt;1, 0333&gt;&gt;1, 0444&gt;&gt;1, 0555&gt;&gt;1, 0666&gt;&gt;1, 0377 <br>}; <br> <br>unsigned char twoto8[4] = { <br>    0, 0x55, 0xaa, 0xff <br>}; <br> <br>unsigned char oneto8[2] = { <br>    0, 255 <br>}; <br> <br>static int defaultOverride[13] = { <br>    0, 3, 24, 27, 64, 67, 88, 173, 181, 236, 247, 164, 91 <br>}; <br> <br>static PALETTEENTRY defaultPalEntry[20] = { <br>    { 0,   0,   0,    0 }, <br>    { 0x80,0,   0,    0 }, <br>    { 0,   0x80,0,    0 }, <br>    { 0x80,0x80,0,    0 }, <br>    { 0,   0,   0x80, 0 }, <br>    { 0x80,0,   0x80, 0 }, <br>    { 0,   0x80,0x80, 0 }, <br>    { 0xC0,0xC0,0xC0, 0 }, <br> <br>    { 192, 220, 192,  0 }, <br>    { 166, 202, 240,  0 }, <br>    { 255, 251, 240,  0 }, <br>    { 160, 160, 164,  0 }, <br> <br>    { 0x80,0x80,0x80, 0 }, <br>    { 0xFF,0,   0,    0 }, <br>    { 0,   0xFF,0,    0 }, <br>    { 0xFF,0xFF,0,    0 }, <br>    { 0,   0,   0xFF, 0 }, <br>    { 0xFF,0,   0xFF, 0 }, <br>    { 0,   0xFF,0xFF, 0 }, <br>    { 0xFF,0xFF,0xFF, 0 } <br>}; <br> <br>unsigned char <br>ComponentFromIndex(int i, UINT nbits, UINT shift) <br>{ <br>    unsigned char val; <br> <br>    val = (unsigned char) (i &gt;&gt; shift); <br>    switch (nbits) { <br> <br>    case 1: <br>        val &amp;= 0x1; <br>        return oneto8[val]; <br> <br>    case 2: <br>        val &amp;= 0x3; <br>        return twoto8[val]; <br> <br>    case 3: <br>        val &amp;= 0x7; <br>        return threeto8[val]; <br> <br>    default: <br>        return 0; <br>    } <br>} <br> <br>void <br>CreateRGBPalette(HDC hDC) <br>{ <br>    PIXELFORMATDESCRIPTOR pfd; <br>    LOGPALETTE *pPal; <br>    int n, i; <br> <br>    n = GetPixelFormat(hDC); <br>    DescribePixelFormat(hDC, n, sizeof(PIXELFORMATDESCRIPTOR), &amp;pfd); <br> <br>    if (pfd.dwFlags &amp; PFD_NEED_PALETTE) { <br>        n = 1 &lt;&lt; pfd.cColorBits; <br>        pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>                n * sizeof(PALETTEENTRY)); <br>        pPal-&gt;palVersion = 0x300; <br>        pPal-&gt;palNumEntries = n; <br>        for (i=0; i&lt;n; i++) { <br>            pPal-&gt;palPalEntry[i].peRed = <br>                    ComponentFromIndex(i, pfd.cRedBits, pfd.cRedShift); <br>            pPal-&gt;palPalEntry[i].peGreen = <br>                    ComponentFromIndex(i, pfd.cGreenBits, pfd.cGreenShift); <br>            pPal-&gt;palPalEntry[i].peBlue = <br>                    ComponentFromIndex(i, pfd.cBlueBits, pfd.cBlueShift); <br>            pPal-&gt;palPalEntry[i].peFlags = 0; <br>        } <br> <br>        /* fix up the palette to include the default GDI palette */ <br>        if ((pfd.cColorBits == 8)                           &amp;&amp; <br>            (pfd.cRedBits   == 3) &amp;&amp; (pfd.cRedShift   == 0) &amp;&amp; <br>            (pfd.cGreenBits == 3) &amp;&amp; (pfd.cGreenShift == 3) &amp;&amp; <br>            (pfd.cBlueBits  == 2) &amp;&amp; (pfd.cBlueShift  == 6) <br>           ) { <br>            for (i = 1 ; i &lt;= 12 ; i++) <br>                pPal-&gt;palPalEntry[defaultOverride[i]] = defaultPalEntry[i]; <br>        } <br> <br>        ghPalette = CreatePalette(pPal); <br>        LocalFree(pPal); <br> <br>        ghpalOld = SelectPalette(hDC, ghPalette, FALSE); <br>        n = RealizePalette(hDC); <br>    } <br>} <br> <br>BOOL bSetupPixelFormat(HDC hDC) <br>{ <br>    static PIXELFORMATDESCRIPTOR pfd = { <br>sizeof(PIXELFORMATDESCRIPTOR),// size of this pfd <br>1,// version number <br>PFD_DRAW_TO_WINDOW |// support window <br>  PFD_SUPPORT_OPENGL |// support OpenGL <br>  PFD_DOUBLEBUFFER,// double buffered <br>PFD_TYPE_RGBA,// RGBA type <br>24,// 24-bit color depth <br>0, 0, 0, 0, 0, 0,// color bits ignored <br>0,// no alpha buffer <br>0,// shift bit ignored <br>0,// no accumulation buffer <br>0, 0, 0, 0, // accum bits ignored <br>32,// 32-bit z-buffer <br>0,// no stencil buffer <br>0,// no auxiliary buffer <br>PFD_MAIN_PLANE,// main layer <br>0,// reserved <br>0, 0, 0// layer masks ignored <br>    }; <br>    int pixelformat; <br> <br>    if ( (pixelformat = ChoosePixelFormat(hDC, &amp;pfd)) == 0 ) <br>    { <br>        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (SetPixelFormat(hDC, pixelformat, &amp;pfd) == FALSE) <br>    { <br>        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK); <br>        return FALSE; <br>    } <br> <br>    CreateRGBPalette(hDC); <br> <br>    return TRUE; <br>} <br> <br>GLvoid initialize(HWND hWnd) <br>{ <br>    GLfloatmaxObjectSize, aspect; <br>    GLdoublenear_plane, far_plane; <br> <br>    GetClientRect(hWnd, &amp;oldrect); <br> <br>    glClearColor( 0.0, 0.0, 0.0, 1.0 ); <br>    glClearDepth( 1.0 ); <br> <br>    glEnable(GL_DEPTH_TEST); <br> <br>    glMatrixMode( GL_PROJECTION ); <br>    aspect = (GLfloat) oldrect.right / oldrect.bottom;; <br>    gluPerspective( 45.0, aspect, 3.0, 7.0 ); <br>    glMatrixMode( GL_MODELVIEW ); <br> <br>    near_plane = 3.0; <br>    far_plane = 7.0; <br>    maxObjectSize = 3.0; <br>    radius = near_plane + maxObjectSize/2.0; <br>} <br> <br>GLvoid draw_scene(HWND hWnd) <br>{ <br>    HDC hDC; <br> <br>    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ); <br> <br>    glPushMatrix(); <br>    glTranslatef(0.0, 0.0, -radius); <br> <br>if(draw_cone) <br>    drawCone(); <br> <br>if(draw_pyramid) <br>    drawPyramid(); <br> <br>    glPopMatrix(); <br>    glFinish(); <br> <br>    hDC = wglGetCurrentDC(); <br>    SwapBuffers(hDC); <br>} <br> <br>GLvoid resize(HWND hWnd) <br>{ <br>    RECTrect; <br> <br>    GetClientRect(hWnd, &amp;rect); <br> <br>    glViewport(0, 0, rect.right, rect.bottom); <br> <br>    if((oldrect.right &gt; rect.right) || (oldrect.bottom &gt; rect.bottom)) <br>PostMessage (hWnd, WM_PAINT, 0, 0L); <br> <br>    oldrect.right = rect.right; <br>    oldrect.bottom = rect.bottom; <br>} <br> <br>GLvoid drawCone(GLvoid) <br>{ <br>    GLUquadricObj *quadObj; <br> <br>    glColor3f(0.0, 1.0, 0.0); <br> <br>    glPushMatrix(); <br>glTranslatef(-1.0, 0.0, 0.0); <br>        quadObj = gluNewQuadric(); <br>        gluQuadricDrawStyle(quadObj, GLU_FILL); <br>        gluQuadricNormals(quadObj, GLU_SMOOTH); <br>        gluCylinder(quadObj, 1.0, 0.0, 1.0, 20, 10); <br>        gluDeleteQuadric(quadObj); <br>    glPopMatrix(); <br> <br>} <br> <br>GLvoid drawPyramid(GLvoid) <br>{ <br> <br>    glPushMatrix(); <br>glTranslatef(1.0, 0.0, 0.0); <br>glBegin(GL_TRIANGLE_FAN); <br>    glColor3f(1.0, 0.0, 0.0); <br>    glVertex3f(0.0, 1.0, 0.0); <br>    glColor3f(0.0, 1.0, 0.0); <br>    glVertex3f(-1.0, 0.0, 0.0); <br>    glColor3f(0.0, 0.0, 1.0); <br>    glVertex3f(0.0, 0.0, 1.0); <br>    glColor3f(0.0, 1.0, 0.0); <br>    glVertex3f(1.0, 0.0, 0.0); <br>glEnd(); <br>    glPopMatrix(); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
