<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRACKBAL.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3607"></a>TRACKBAL.C</h2>
<pre><code>/* <br> * Trackball code: <br> * <br> * Implementation of a virtual trackball. <br> * Implemented by Gavin Bell, lots of ideas from Thant Tessman and <br> *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129. <br> * <br> * Vector manip code: <br> * <br> * Original code from: <br> * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli <br> * <br> * Much mucking with by: <br> * Gavin Bell <br> * <br> * Shell hacking courtesy of: <br> * Reptilian Inhaleware <br> */ <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/glaux.h&gt; <br>#include "trackbal.h" <br> <br>/*  <br> * globals <br> */ <br>static GLenum (*MouseDownFunc)(int, int, GLenum) = NULL; <br>static GLenum (*MouseUpFunc)(int, int, GLenum)   = NULL; <br>static HWND ghwnd; <br>GLint giWidth, giHeight; <br>LONG    glMouseDownX, glMouseDownY; <br>BOOL    gbLeftMouse = FALSE; <br>BOOL    gbSpinning = FALSE; <br>float   curquat[4], lastquat[4]; <br> <br>/* <br> * This size should really be based on the distance from the center of <br> * rotation to the point on the object underneath the mouse.  That <br> * point would then track the mouse as closely as possible.  This is a <br> * simple example, though, so that is left as an Exercise for the <br> * Programmer. <br> */ <br>#define TRACKBALLSIZE  (0.8f) <br> <br>/* <br> * Local function prototypes (not defined in trackball.h) <br> */ <br>static float tb_project_to_sphere(float, float, float); <br>static void normalize_quat(float [4]); <br> <br>void  <br>trackball_Init( GLint width, GLint height ) <br>{ <br>    ghwnd = auxGetHWND(); <br>    giWidth = width; <br>    giHeight = height; <br> <br>    trackball_calc_quat( curquat, 0.0f, 0.0f, 0.0f, 0.0f ); <br>} <br> <br>void <br>trackball_Resize( GLint width, GLint height ) <br>{ <br>    giWidth = width; <br>    giHeight = height; <br>} <br> <br>GLenum <br>#ifdef _USE_TK <br>trackball_MouseDown( int mouseX, int mouseY, GLenum button )  <br>#else <br>trackball_MouseDown( AUX_EVENTREC *event)  <br>#endif <br>{ <br>    SetCapture(ghwnd); <br>    glMouseDownX = event-&gt;data[AUX_MOUSEX]; <br>    glMouseDownY = event-&gt;data[AUX_MOUSEY]; <br>    gbLeftMouse = TRUE; <br>    return GL_TRUE; <br>} <br> <br> <br>GLenum <br>#ifdef _USE_TK <br>trackball_MouseUp( int mouseX, int mouseY, GLenum button )  <br>#else <br>trackball_MouseUp( AUX_EVENTREC *event )  <br>#endif <br>{ <br>    ReleaseCapture(); <br>    gbLeftMouse = FALSE; <br>    return GL_TRUE; <br>} <br> <br>/* these 4 not used yet */ <br>void <br>trackball_MouseDownEvent( int mouseX, int mouseY, GLenum button ) <br>{ <br>} <br> <br>void <br>trackball_MouseUpEvent( int mouseX, int mouseY, GLenum button ) <br>{ <br>} <br> <br>void  <br>trackball_MouseDownFunc(GLenum (*Func)(int, int, GLenum)) <br>{ <br>    MouseDownFunc = Func; <br>} <br> <br>void  <br>trackball_MouseUpFunc(GLenum (*Func)(int, int, GLenum)) <br>{ <br>    MouseUpFunc = Func; <br>} <br> <br>void <br>trackball_CalcRotMatrix( GLfloat matRot[4][4] ) <br>{ <br>    POINT pt; <br> <br>    if (gbLeftMouse) <br>    { <br>        auxGetMouseLoc( &amp;pt.x, &amp;pt.y ); <br> <br>        // If mouse has moved since button was pressed, change quaternion. <br> <br>            if (pt.x != glMouseDownX || pt.y != glMouseDownY) <br>            { <br>#if 1 <br>    /* negate all params for proper operation with glTranslate(-z) <br>     */ <br>                trackball_calc_quat(lastquat, <br>                          -(2.0f * ( giWidth - glMouseDownX ) / giWidth - 1.0f), <br>                          -(2.0f * glMouseDownY / giHeight - 1.0f), <br>                          -(2.0f * ( giWidth - pt.x ) / giWidth - 1.0f), <br>                          -(2.0f * pt.y / giHeight - 1.0f) <br>                         ); <br>#else <br>// now out-of-date <br>                trackball_calc_quat(lastquat, <br>                          2.0f * ( Width - glMouseDownX ) / Width - 1.0f, <br>                          2.0f * glMouseDownY / Height - 1.0f, <br>                          2.0f * ( Width - pt.x ) / Width - 1.0f, <br>                          2.0f * pt.y / Height - 1.0f ); <br>#endif <br> <br>                gbSpinning = TRUE; <br>            } <br>            else <br>                gbSpinning = FALSE; <br> <br>            glMouseDownX = pt.x; <br>            glMouseDownY = pt.y; <br>    } <br> <br>    if (gbSpinning) <br>        trackball_add_quats(lastquat, curquat, curquat); <br> <br>    trackball_build_rotmatrix(matRot, curquat); <br>} <br> <br>void <br>vzero(float *v) <br>{ <br>    v[0] = 0.0f; <br>    v[1] = 0.0f; <br>    v[2] = 0.0f; <br>} <br> <br>void <br>vset(float *v, float x, float y, float z) <br>{ <br>    v[0] = x; <br>    v[1] = y; <br>    v[2] = z; <br>} <br> <br>void <br>vsub(const float *src1, const float *src2, float *dst) <br>{ <br>    dst[0] = src1[0] - src2[0]; <br>    dst[1] = src1[1] - src2[1]; <br>    dst[2] = src1[2] - src2[2]; <br>} <br> <br>void <br>vcopy(const float *v1, float *v2) <br>{ <br>    register int i; <br>    for (i = 0 ; i &lt; 3 ; i++) <br>        v2[i] = v1[i]; <br>} <br> <br>void <br>vcross(const float *v1, const float *v2, float *cross) <br>{ <br>    float temp[3]; <br> <br>    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]); <br>    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]); <br>    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]); <br>    vcopy(temp, cross); <br>} <br> <br>float <br>vlength(const float *v) <br>{ <br>    return (float) sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]); <br>} <br> <br>void <br>vscale(float *v, float div) <br>{ <br>    v[0] *= div; <br>    v[1] *= div; <br>    v[2] *= div; <br>} <br> <br>void <br>vnormal(float *v) <br>{ <br>    vscale(v,1.0f/vlength(v)); <br>} <br> <br>float <br>vdot(const float *v1, const float *v2) <br>{ <br>    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]; <br>} <br> <br>void <br>vadd(const float *src1, const float *src2, float *dst) <br>{ <br>    dst[0] = src1[0] + src2[0]; <br>    dst[1] = src1[1] + src2[1]; <br>    dst[2] = src1[2] + src2[2]; <br>} <br> <br>/* <br> * Ok, simulate a track-ball.  Project the points onto the virtual <br> * trackball, then figure out the axis of rotation, which is the cross <br> * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0) <br> * Note:  This is a deformed trackball-- is a trackball in the center, <br> * but is deformed into a hyperbolic sheet of rotation away from the <br> * center.  This particular function was chosen after trying out <br> * several variations. <br> *  <br> * It is assumed that the arguments to this routine are in the range <br> * (-1.0 ... 1.0) <br> */ <br>void <br>trackball_calc_quat(float q[4], float p1x, float p1y, float p2x, float p2y) <br>{ <br>    float a[3]; /* Axis of rotation */ <br>    float phi;  /* how much to rotate about axis */ <br>    float p1[3], p2[3], d[3]; <br>    float t; <br> <br>    if (p1x == p2x &amp;&amp; p1y == p2y) { <br>/* Zero rotation */ <br>        vzero(q);  <br>q[3] = 1.0f;  <br>        return; <br>    } <br> <br>    /* <br>     * First, figure out z-coordinates for projection of P1 and P2 to <br>     * deformed sphere <br>     */ <br>    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y)); <br>    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y)); <br> <br>    /* <br>     *  Now, we want the cross product of P1 and P2 <br>     */ <br>    vcross(p2,p1,a); <br> <br>    /* <br>     *  Figure out how much to rotate around that axis. <br>     */ <br>    vsub(p1,p2,d); <br>    t = vlength(d) / (2.0f*TRACKBALLSIZE); <br> <br>    /* <br>     * Avoid problems with out-of-control values... <br>     */ <br>    if (t &gt; 1.0f) t = 1.0f; <br>    if (t &lt; -1.0f) t = -1.0f; <br>    phi = 2.0f * (float) asin(t); <br> <br>    trackball_axis_to_quat(a,phi,q); <br>} <br> <br>/* <br> *  Given an axis and angle, compute quaternion. <br> */ <br>void <br>trackball_axis_to_quat(float a[3], float phi, float q[4]) <br>{ <br>    vnormal(a); <br>    vcopy(a,q); <br>    vscale(q,(float) sin(phi/2.0f)); <br>    q[3] = (float) cos(phi/2.0f); <br>} <br> <br>/* <br> * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet <br> * if we are away from the center of the sphere. <br> */ <br>static float <br>tb_project_to_sphere(float r, float x, float y) <br>{ <br>    float d, t, z; <br> <br>    d = (float) sqrt(x*x + y*y); <br>    if (d &lt; r * 0.70710678118654752440f) {    /* Inside sphere */ <br>z = (float) sqrt(r*r - d*d); <br>    } else {           /* On hyperbola */ <br>        t = r / 1.41421356237309504880f; <br>        z = t*t / d; <br>    } <br>    return z; <br>} <br> <br>/* <br> * Given two rotations, e1 and e2, expressed as quaternion rotations, <br> * figure out the equivalent single rotation and stuff it into dest. <br> *  <br> * This routine also normalizes the result every RENORMCOUNT times it is <br> * called, to keep error from creeping in. <br> * <br> * NOTE: This routine is written so that q1 or q2 may be the same <br> * as dest (or each other). <br> */ <br> <br>#define RENORMCOUNT 97 <br> <br>void <br>trackball_add_quats(float q1[4], float q2[4], float dest[4]) <br>{ <br>    static int count=0; <br>    float t1[4], t2[4], t3[4]; <br>    float tf[4]; <br> <br>    vcopy(q1,t1);  <br>    vscale(t1,q2[3]); <br> <br>    vcopy(q2,t2);  <br>    vscale(t2,q1[3]); <br> <br>    vcross(q2,q1,t3); <br>    vadd(t1,t2,tf); <br>    vadd(t3,tf,tf); <br>    tf[3] = q1[3] * q2[3] - vdot(q1,q2); <br> <br>    dest[0] = tf[0]; <br>    dest[1] = tf[1]; <br>    dest[2] = tf[2]; <br>    dest[3] = tf[3]; <br> <br>    if (++count &gt; RENORMCOUNT) { <br>        count = 0; <br>        normalize_quat(dest); <br>    } <br>} <br> <br>/* <br> * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0 <br> * If they don't add up to 1.0, dividing by their magnitued will <br> * renormalize them. <br> * <br> * Note: See the following for more information on quaternions: <br> *  <br> * - Shoemake, K., Animating rotation with quaternion curves, Computer <br> *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985. <br> * - Pletinckx, D., Quaternion calculus as a basic tool in computer <br> *   graphics, The Visual Computer 5, 2-13, 1989. <br> */ <br>static void <br>normalize_quat(float q[4]) <br>{ <br>    int i; <br>    float mag; <br> <br>    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]); <br>    for (i = 0; i &lt; 4; i++) q[i] /= mag; <br>} <br> <br>/* <br> * Build a rotation matrix, given a quaternion rotation. <br> * <br> */ <br>void <br>trackball_build_rotmatrix(float m[4][4], float q[4]) <br>{ <br>    m[0][0] = 1.0f - 2.0f * (q[1] * q[1] + q[2] * q[2]); <br>    m[0][1] = 2.0f * (q[0] * q[1] - q[2] * q[3]); <br>    m[0][2] = 2.0f * (q[2] * q[0] + q[1] * q[3]); <br>    m[0][3] = 0.0f; <br> <br>    m[1][0] = 2.0f * (q[0] * q[1] + q[2] * q[3]); <br>    m[1][1]= 1.0f - 2.0f * (q[2] * q[2] + q[0] * q[0]); <br>    m[1][2] = 2.0f * (q[1] * q[2] - q[0] * q[3]); <br>    m[1][3] = 0.0f; <br> <br>    m[2][0] = 2.0f * (q[2] * q[0] - q[1] * q[3]); <br>    m[2][1] = 2.0f * (q[1] * q[2] + q[0] * q[3]); <br>    m[2][2] = 1.0f - 2.0f * (q[1] * q[1] + q[0] * q[0]); <br>    m[2][3] = 0.0f; <br> <br>    m[3][0] = 0.0f; <br>    m[3][1] = 0.0f; <br>    m[3][2] = 0.0f; <br>    m[3][3] = 1.0f; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
