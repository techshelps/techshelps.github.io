<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CBACKS.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3593"></a>CBACKS.CXX</h2>
<pre><code><br>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#ifdef GLX_MOTIF <br>#include &lt;X11/keysym.h&gt; <br> <br>#include &lt;X11/Intrinsic.h&gt; <br>#include &lt;Xm/Xm.h&gt; <br>#include &lt;Xm/ToggleB.h&gt; <br>#include &lt;GL/glx.h&gt; <br>#include &lt;GLwMDrawA.h&gt; <br>#include &lt;sys/time.h&gt; <br>#endif <br> <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/gl.h&gt; <br>extern "C" { <br>#include &lt;GL/glaux.h&gt; <br>} <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#include "scene.hxx" <br>#include "cbacks.hxx" <br>#include "menu.h" <br> <br>#ifdef GLX_MOTIF <br>extern Widget glw; <br>extern XtAppContext app_context; <br>GLXContext glx_con1005text; <br>#endif <br> <br>extern light lights[]; <br>extern int quick_moves; <br>extern int auto_motion; <br>static float dtheta[nlights]; <br>static float last_motion_update; <br> <br>//struct timeval starttime; <br>SYSTEMTIME starttime; <br> <br>static int button_down; <br>static int winx, winy; <br>GLint mouse_x, mouse_y; <br> <br>static int name_selected; <br> <br>#ifdef GLX_MOTIF <br>static XtWorkProcId workproc = NULL; <br>#endif <br> <br>const float time_fudge = .0001; <br> <br>inline <br>float current_time() <br>{ <br>  //struct timeval time; <br>  SYSTEMTIME time; <br> <br>  //gettimeofday(&amp;time, NULL); <br>  GetSystemTime(&amp;time); <br> <br>  //return ((double)(time.tv_sec - starttime.tv_sec) + <br>  //  (double)(time.tv_usec - starttime.tv_usec) / 1000000.0); <br> <br>  return ((float)(time.wSecond - starttime.wSecond) + <br>        (float)(time.wMilliseconds - starttime.wMilliseconds) / (float)1000.0); <br> <br>} <br> <br>inline float rand(float min, float max)  <br>{ <br>  double r; <br>  r = (double)rand() / (double)RAND_MAX; <br>  return (float)(min + r * (max - min)); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* void draw(void) <br>* <br>* History: <br>*  29-Nov-1993                      Replaced with wgl and aux calls <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK draw(void) <br>{ <br> <br>#ifdef GLX_MOTIF <br>  GLwDrawingAreaMakeCurrent(glw, glx_context); <br>//#else <br>  //wglMakeCurrent(auxGetHDC(), auxGetHGLRC()); <br>#endif <br> <br>  scene_draw(); <br> <br>#ifdef GLX_MOTIF <br>  GLwDrawingAreaSwapBuffers(glw); <br>#else <br>  // Win32's SwapBuffers takes HDC <br>  // SwapBuffers(auxGetHDC); <br>  auxSwapBuffers(); <br>#endif <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vQuickMove(void) <br>* <br>* //void intToggleCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects:  set or reset the global flag quick_moves <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vQuickMove(void) <br>{ <br>  HMENU   hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>#ifdef GLX_MOTIF <br>  int *data; <br>  XmToggleButtonCallbackStruct *ptr; <br> <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  data = (int *)client_data; <br>  *data = ptr-&gt;set; <br>#endif <br> <br>  quick_moves = quick_moves ? 0 : 1; <br> <br>  if (quick_moves) <br>    CheckMenuItem(hmenu, IDM_QUICK, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>    CheckMenuItem(hmenu, IDM_QUICK, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  // This redraw may or may not be needed - do it to be safe <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vResetLights(void) <br>* <br>* // void resetLightsCB(Widget w) <br>* <br>* Effects: <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vResetLights(void) <br>{ <br>  scene_reset_lights(); <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vAutoMotion(void) <br>* <br>* // void autoMotionCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects:  !!! turns on/off the timer? <br>*           (Re)set the global auto_moves <br>* <br>* Warnings: <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vAutoMotion(void) <br>{ <br>  int i; <br>  HMENU   hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br> <br>#ifdef GLX_MOTIF <br>  XmToggleButtonCallbackStruct *ptr; <br> <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br> <br>  auto_motion = ptr-&gt;set; <br>#endif <br> <br>  auto_motion = auto_motion ? 0 : 1; <br>  SendMessage(auxGetHWND(), WM_USER, 0L, 0L); <br> <br>  if (auto_motion) { <br>    CheckMenuItem(hmenu, IDM_AUTO, MF_BYCOMMAND | MF_CHECKED); <br> <br>    for (i = 0; i &lt; nlights; i++) <br>        dtheta[i] = rand(-1, 1); <br>    last_motion_update = current_time(); <br>  } else { <br>    CheckMenuItem(hmenu, IDM_AUTO, MF_BYCOMMAND | MF_UNCHECKED); <br>  } <br> <br>#ifdef GLX_MOTIF <br>  if (auto_motion) { <br>    workproc = XtAppAddWorkProc(app_context, drawWP, NULL); <br>    for (i = 0; i &lt; nlights; i++) dtheta[i] = rand(-1, 1); <br>    last_motion_update = current_time(); <br>  } else { <br>    XtRemoveWorkProc(workproc); <br>  } <br>#endif <br> <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vInit(void) <br>* <br>* // void initCB(Widget w) <br>* <br>* Effects: <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void vInit(void) <br>{ <br>  RECT  rect; <br>  HMENU hmenu; <br>  HWND  hWnd; <br>  int   i; <br> <br>#ifdef GLX_MOTIF <br>  Arg args[1]; <br>  XVisualInfo *vi; <br> <br>  XtSetArg(args[0], GLwNvisualInfo, &amp;vi); <br>  XtGetValues(w, args, 1); <br>  <br>  // !!! creating indirect context, make current <br>  // <br>  glx_context = glXCreateContext(XtDisplay(w), vi, 0, GL_FALSE); <br>  GLwDrawingAreaMakeCurrent(w, glx_context); <br>#endif <br> <br>#ifdef TESTTEST <br>  PIXELFORMATDESCRIPTOR pfd; <br>  HDC                   hDC; <br>  HGLRC                 hRC; <br>  INT                   iPixelFormat; <br> <br>  hDC = auxGetHDC(); <br> <br>  iPixelFormat = GetPixelFormat(hDC); <br>  DescribePixelFormat(hDC, iPixelFormat, sizeof(PIXELFORMATDESCRIPTOR), &amp;pfd); <br> <br>  if ((pfd.dwFlags &amp; PFD_SUPPORT_GDI) == 0) { <br> <br>    OutputDebugString("PFD_SUPPORT_GDI not supported!\n"); <br> <br>    pfd.dwFlags |= PFD_SUPPORT_GDI; <br> <br>  } <br> <br>  if (!SetPixelFormat(hDC, iPixelFormat, &amp;pfd)) <br>    OutputDebugString("PFD_SUPPORT_GDI still not supported!\n"); <br> <br> <br>  // <br>  // Maynot need this <br>  // <br>  hRC = wglCreateContext(hDC); <br>  if (!wglMakeCurrent(hDC, hRC)) <br>    OutputDebugString("MakeCurrentFailed!\n"); <br>#endif <br> <br> <br> <br>  scene_init();  <br> <br>  //gettimeofday(&amp;starttime, NULL); <br>  //srand(starttime.tv_usec); <br> <br>  GetSystemTime(&amp;starttime); <br>  srand(starttime.wMilliseconds); <br> <br>  hWnd = auxGetHWND(); <br>  GetClientRect(hWnd, &amp;rect); <br> <br>  glViewport(0, 0, rect.right, rect.bottom); <br>  glClear(GL_COLOR_BUFFER_BIT); <br> <br>  // <br>  // this is for initizating the menu items <br>  // <br>  hmenu = GetMenu(hWnd); <br> <br>  for (i=0; i &lt; nlights; i++) { <br>    if (lights[i].on) <br>      CheckMenuItem(hmenu, IDM_RED+i, MF_BYCOMMAND | MF_CHECKED); <br>    else <br>      CheckMenuItem(hmenu, IDM_RED+i, MF_BYCOMMAND | MF_UNCHECKED); <br>  } <br> <br>  if (draw_square) <br>    CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_CHECKED); <br>  if (draw_shadows) <br>    CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_CHECKED); <br>  if (draw_refraction) <br>    CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_CHECKED); <br>  if (draw_lights) <br>    CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_CHECKED); <br>  if (draw_sphere) <br>    CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_CHECKED); <br>  if (draw_texture) <br>    CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_CHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+def_refraction_index, MF_BYCOMMAND | MF_CHECKED); <br>  CheckMenuItem(hmenu, IDM_10+def_divisions_index, MF_BYCOMMAND | MF_CHECKED); <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vExpose <br>* <br>* // !!! void exposeCB(Widget w) <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void vExpose(int x, int y) <br>{ <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vResize <br>* <br>* // void resizeCB(Widget w, XtPointer client_data, XtPointer call) <br>* <br>* Effects:  changes globals winx, winy and aspect <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vResize(GLsizei width, GLsizei height) <br>{ <br>#ifdef GLX_MOTIF <br>  GLwDrawingAreaCallbackStruct *call_data; <br>  call_data = (GLwDrawingAreaCallbackStruct *)call; <br> <br>  GLwDrawingAreaMakeCurrent(w, glx_context); <br>  winx = call_data-&gt;width; <br>  winy = call_data-&gt;height; <br>#endif <br> <br>  winx = width; <br>  winy = height; <br> <br>  glViewport(0, 0, winx, winy); <br> <br>  aspect = (GLfloat)winx / (GLfloat)winy; <br>} <br> <br>#ifdef GLX_MOTIF <br>// <br>// !!! mouse down/up function?? <br>// <br>void inputCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>  int picked; <br>  GLwDrawingAreaCallbackStruct *call; <br> <br>  char buffer[5]; <br>  int bufsize = 5; <br>  KeySym key; <br>  XComposeStatus compose; <br> <br>  static int mousex, mousey; <br>  /* Just to confuse everybody, I've made these go from 0-1. */ <br>  float dmousex, dmousey; <br>  float r1, r2; <br> <br>  call = (GLwDrawingAreaCallbackStruct *)call_data; <br>   <br>  GLwDrawingAreaMakeCurrent(w, glx_context); <br>  switch(call-&gt;event-&gt;type) { <br>  case ButtonPress: <br>    button_down = call-&gt;event-&gt;xbutton.button; <br>    mousex = call-&gt;event-&gt;xbutton.x; <br>    mousey = call-&gt;event-&gt;xbutton.y; <br>    picked = scene_pick(mousex, mousey); <br>    if (picked &gt;= name_lights) name_selected = picked; <br>    break; <br>  case ButtonRelease: <br>    if (quick_moves)  <br>      scene_move_update(name_selected, button_down == Button2,  <br>button_down == Button3, button_down = Button1); <br>    button_down = 0;  <br>    break; <br>  case MotionNotify: <br>    if (button_down == Button1) { <br>      /* This is the "default" mouse button - moves things in theta <br>       * since this is easy and computationally cheap */ <br>      dmousex = (double)(call-&gt;event-&gt;xmotion.x - mousex) / (double)winx; <br>      scene_move(name_selected, 0, 0, dmousex, quick_moves ? 0 : 1); <br>    } else if (button_down == Button2) { <br>      /* Change the radius - figue out the component of the mouse motion <br>       * that's going toward the center of the screen */ <br>      mousex = (winx / 2) - mousex; <br>      mousey = (winy / 2) - mousey; <br>      r1 = sqrt((float)(mousex*mousex) / (float)(winx*winx) +  <br>(float)(mousey*mousey) / (float)(winy*winy)); <br>      mousex = call-&gt;event-&gt;xmotion.x; <br>      mousey = call-&gt;event-&gt;xmotion.y; <br>      mousex = (winx / 2) - mousex; <br>      mousey = (winy / 2) - mousey; <br>      r2 = sqrt((float)(mousex*mousex) / (float)(winx*winx) +  <br>(float)(mousey*mousey) / (float)(winy*winy)); <br>      scene_move(name_selected, r2 - r1, 0, 0, quick_moves ? 0 : 1); <br>    } else if (button_down == Button3) { <br>      /* Change phi - this is expensive */ <br>      dmousex = (double)(call-&gt;event-&gt;xmotion.x - mousex) / (double)winx; <br>      scene_move(name_selected, 0, dmousex, 0, quick_moves ? 0 : 1); <br>    } <br>    mousex = call-&gt;event-&gt;xmotion.x; <br>    mousey = call-&gt;event-&gt;xmotion.y; <br>    break; <br>  case KeyPress: <br>    XLookupString(&amp;(call-&gt;event-&gt;xkey), buffer, bufsize, &amp;key, &amp;compose); <br>    if (key == XK_Escape) exit(0); <br>    break;                             <br>  default: <br>    break; <br>  } <br> <br>  draw(); <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vDrawAll(void) <br>* <br>* //void drawAllCB(Widget w) <br>* <br>* Effects: <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vDrawAll(void) <br>{ <br>  HMENU hmenu; <br>  int       i; <br>  static int fAll=0; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  fAll = fAll ? 0 : 1; <br> <br>  if (fAll) { <br>    for (i=0; i &lt; 6; i++) <br>       CheckMenuItem(hmenu, IDM_SQUARE+i, MF_BYCOMMAND | MF_CHECKED); <br> <br>    CheckMenuItem(hmenu, IDM_ALL, MF_BYCOMMAND | MF_CHECKED); <br>    draw_square = 1; <br>    draw_shadows = 1; <br>    draw_refraction = 1; <br>    draw_sphere = 1; <br>    draw_lights = 1; <br> <br>  } else { <br>    CheckMenuItem(hmenu, IDM_ALL, MF_BYCOMMAND | MF_UNCHECKED); <br>  } <br> <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* //void drawSomethingCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects:  functions for auxKeyFunc can't have parameters so we have <br>*           these similar functions here. <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vDrawSquare(void) <br>{ <br>#ifdef GLX_MOTIF <br>  XmToggleButtonCallbackStruct *ptr; <br>  int *data; <br>  int i; <br> <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  data = (int *)client_data; <br>  *data = ptr-&gt;set; <br>#endif <br>  HMENU hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  draw_square = draw_square ? 0 : 1; <br>  if (draw_square) <br>      CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>      CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  draw(); <br>} <br> <br>void CALLBACK vDrawShadow(void) <br>{ <br>  HMENU hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  draw_shadows = draw_shadows ? 0 : 1; <br>  if (draw_shadows) <br>      CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>      CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_UNCHECKED); <br>  draw(); <br>} <br> <br>void CALLBACK vDrawRefraction(void) <br>{ <br>  HMENU hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  draw_refraction = draw_refraction ? 0 : 1; <br>  if (draw_refraction) <br>      CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>      CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_UNCHECKED); <br>  draw(); <br>} <br>void CALLBACK vDrawSphere(void) <br>{ <br>  HMENU hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  draw_sphere = draw_sphere ? 0 : 1; <br>  if (draw_sphere) <br>      CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>      CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_UNCHECKED); <br>  draw(); <br>} <br>void CALLBACK vDrawLight(void) <br>{ <br>  HMENU hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  draw_lights = draw_lights ? 0 : 1; <br>  if (draw_lights) <br>      CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>      CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_UNCHECKED); <br>  draw(); <br>} <br>void CALLBACK vDrawTexture(void) <br>{ <br>  HMENU hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  draw_texture = draw_texture ? 0 : 1; <br>  if (draw_texture) <br>      CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>      CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_UNCHECKED); <br>  draw(); <br>} <br> <br>void vDrawStuff(int *what) <br>{ <br>  *what = *what ? 0 : 1; <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* //void refractionCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects:  functions for auxKeyFunc can't have parameters so we have <br>*           these similar functions here. <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vRefractionAIR(void) <br>{ <br>#ifdef GLX_MOTIF <br>  XmToggleButtonCallbackStruct *ptr; <br>  GLfloat refraction; <br> <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  if (!ptr-&gt;set) return; <br>  refraction = *((GLfloat *)client_data); <br>#endif <br> <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+0, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[0].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br> <br>void CALLBACK vRefractionICE(void) <br>{ <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+1, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[1].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br> <br>void CALLBACK vRefractionWATER(void) <br>{ <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+2, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[2].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br> <br>void CALLBACK vRefractionZincGLASS(void) <br>{ <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+3, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[3].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br>void CALLBACK vRefractionLightGLASS(void) <br>{ <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+4, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[4].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br>void CALLBACK vRefractionHeavyGLASS(void) <br>{ <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+5, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[5].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br> <br>void vRefraction(int type) <br>{ <br>  GLfloat refraction; <br>  HMENU   hmenu; <br>  int         i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br>  for (i = 0; i &lt; nindices; i++) <br>    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_AIR+type, MF_BYCOMMAND | MF_CHECKED); <br>  refraction = indices[type].index; <br>  refraction_change(refraction); <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vSubdivision <br>* <br>* //void subdivisionCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects:  functions for auxKeyFunc can't have parameters so we have <br>*           these similar functions here. <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void CALLBACK vSubdivision10(void) <br>{ <br>#ifdef GLX_MOTIF <br>  XmToggleButtonCallbackStruct *ptr; <br>  int subdivisions; <br> <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  if (!ptr-&gt;set) return; <br>  subdivisions = *((int *)client_data); <br>#endif <br> <br>  HMENU hmenu; <br>  int       i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  for (i = 0; i &lt; npossible_divisions; i++) <br>    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_10, MF_BYCOMMAND | MF_CHECKED); <br>  divisions_change(possible_divisions[0]); <br> <br>  draw(); <br>} <br> <br>void CALLBACK vSubdivision20(void) <br>{ <br>  HMENU hmenu; <br>  int       i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  for (i = 0; i &lt; npossible_divisions; i++) <br>    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_20, MF_BYCOMMAND | MF_CHECKED); <br>  divisions_change(possible_divisions[1]); <br> <br>  draw(); <br>} <br> <br>void CALLBACK vSubdivision30(void) <br>{ <br>  HMENU hmenu; <br>  int       i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  for (i = 0; i &lt; npossible_divisions; i++) <br>    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_30, MF_BYCOMMAND | MF_CHECKED); <br>  divisions_change(possible_divisions[2]); <br> <br>  draw(); <br>} <br> <br>void CALLBACK vSubdivision40(void) <br>{ <br>  HMENU hmenu; <br>  int       i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  for (i = 0; i &lt; npossible_divisions; i++) <br>    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_40, MF_BYCOMMAND | MF_CHECKED); <br>  divisions_change(possible_divisions[3]); <br> <br>  draw(); <br>} <br> <br> <br>void vSubdivision(int which) <br>{ <br>  HMENU hmenu; <br>  int       i; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  for (i = 0; i &lt; npossible_divisions; i++) <br>    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  CheckMenuItem(hmenu, IDM_10+which, MF_BYCOMMAND | MF_CHECKED); <br> <br>  divisions_change(possible_divisions[which]); <br>  draw(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* v[RGB]Light_on <br>* <br>* //void light_onCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects:  functions for auxKeyFunc can't have parameters so we have <br>*           these similar functions here. <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br>#define RED_LIGHT   0 <br>#define GREEN_LIGHT 1 <br>#define BLUE_LIGHT  2 <br> <br>void CALLBACK vRLight_on(void) <br>{ <br>#ifdef GLX_MOTIF <br>  XmToggleButtonCallbackStruct *ptr; <br> <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  lights_onoff((light *)client_data - lights, ptr-&gt;set); <br>#endif <br> <br>  int fOn; <br>  HMENU   hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  fOn = lights[RED_LIGHT].on ? 0 : 1; <br>  if (fOn) <br>    CheckMenuItem(hmenu, IDM_RED, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>    CheckMenuItem(hmenu, IDM_RED, MF_BYCOMMAND | MF_UNCHECKED); <br>  lights_onoff(RED_LIGHT, fOn); <br>  draw(); <br>} <br> <br>void CALLBACK vGLight_on(void) <br>{ <br>  int fOn; <br>  HMENU   hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  fOn = lights[GREEN_LIGHT].on ? 0 : 1; <br>  if (fOn) <br>    CheckMenuItem(hmenu, IDM_GREEN, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>    CheckMenuItem(hmenu, IDM_GREEN, MF_BYCOMMAND | MF_UNCHECKED); <br>  lights_onoff(GREEN_LIGHT, fOn); <br>  draw(); <br>} <br> <br>void CALLBACK vBLight_on(void) <br>{ <br>  int fOn; <br>  HMENU   hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  fOn = lights[BLUE_LIGHT].on ? 0 : 1; <br>  if (fOn) <br>    CheckMenuItem(hmenu, IDM_BLUE, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>    CheckMenuItem(hmenu, IDM_BLUE, MF_BYCOMMAND | MF_UNCHECKED); <br>  lights_onoff(BLUE_LIGHT, fOn); <br>  draw(); <br>} <br> <br>void vLight_on(int which) <br>{ <br>  int fOn; <br>  HMENU   hmenu; <br> <br>  hmenu = GetMenu(auxGetHWND()); <br> <br>  fOn = lights[which].on ? 0 : 1; <br> <br>  if (fOn) <br>    CheckMenuItem(hmenu, IDM_RED+which, MF_BYCOMMAND | MF_CHECKED); <br>  else <br>    CheckMenuItem(hmenu, IDM_RED+which, MF_BYCOMMAND | MF_UNCHECKED); <br> <br>  lights_onoff(which, fOn); <br>  draw(); <br>} <br> <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vExit <br>* <br>* //void exitCB(Widget w, XtPointer client_data, XtPointer call_data) <br>* <br>* Effects: !!! this is redundant unless we do stuff other than auxQuit <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>void vExit(void) <br>{ <br>#ifdef GLX_MOTIF <br>  exit(0); <br>#endif <br> <br>    auxQuit(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bAutoMotion(void) <br>* <br>* // Boolean drawWP(XtPointer data) <br>* <br>* Effects:  !!! for WM_TIMER ? <br>* <br>* History: <br>*  30-Nov-1993 <br>* <br>\**************************************************************************/ <br> <br>GLboolean bAutoMotion(void) <br>{ <br>  float t, dt; <br>  int i; <br> <br>  t = current_time(); <br>  dt = t - last_motion_update; <br>  dt = (dt &lt; 0) ? -dt : dt; <br> <br>  if (dt &lt; time_fudge) { <br> <br>    //wsprintf(text, "dt = %lx\n", dt); <br>    //OutputDebugString(text); <br>    return FALSE; <br>  } <br> <br>  for (i = 0; i &lt; nlights; i++) { <br>    scene_move(name_lights + i, 0, 0, dtheta[i] * dt, 1); <br>  } <br> <br>  last_motion_update = t; <br> <br>  draw(); <br>  return FALSE; <br>} <br> <br> <br> <br>void CALLBACK vMouseDown(AUX_EVENTREC *event) <br>{ <br>  int    picked; <br> <br>  mouse_x = event-&gt;data[AUX_MOUSEX]; <br>  mouse_y = event-&gt;data[AUX_MOUSEY]; <br> <br>  picked = scene_pick(mouse_x, mouse_y); <br>  if (picked &gt;= name_lights) <br>     name_selected = picked; <br> <br>  return; <br>} <br> <br>void CALLBACK vLeftMouseUp(AUX_EVENTREC *event) <br>{ <br>  if (quick_moves) <br>    scene_move_update(name_selected, 0,     // dr <br>                     0,     // dphi <br>                                     1);    // dtheta <br> <br>  return; <br>} <br> <br>void CALLBACK vMiddleMouseUp(AUX_EVENTREC *event) <br>{ <br>  if (quick_moves) <br>    scene_move_update(name_selected, 1,     // dr <br>                     0,     // dphi <br>                                     0);    // dtheta <br> <br>  return; <br>} <br> <br>void CALLBACK vRightMouseUp(AUX_EVENTREC *event) <br>{ <br>  if (quick_moves) <br>    scene_move_update(name_selected, 0,     // dr <br>                     1,     // dphi <br>                                     0);    // dtheta <br> <br>  return; <br>} <br> <br>void CALLBACK vMouseMove(AUX_EVENTREC *event) <br>{ <br>  float dmousex; <br>  float r1, r2; <br>  GLint button = event-&gt;data[AUX_MOUSESTATUS]; <br>  GLint x = event-&gt;data[AUX_MOUSEX]; <br>  GLint y = event-&gt;data[AUX_MOUSEY]; <br>    <br> <br>  switch( button ) { <br>    case AUX_LEFTBUTTON: <br>      /* This is the "default" mouse button - moves things in theta <br>       * since this is easy and computationally cheap */ <br>      dmousex = (float)((double)(x - mouse_x) / (double)winx); <br>      scene_move(name_selected, 0, 0, dmousex, quick_moves ? 0 : 1); <br>      break; <br> <br>    case AUX_MIDDLEBUTTON: <br>      /* Change the radius - figue out the component of the mouse motion <br>       * that's going toward the center of the screen */ <br>      mouse_x = (winx / 2) - mouse_x; <br>      mouse_y = (winy / 2) - mouse_y; <br>      r1 = (float)sqrt((double)(mouse_x*mouse_x) / (double)(winx*winx) + <br>    (double)(mouse_y*mouse_y) / (double)(winy*winy)); <br>      mouse_x = x; <br>      mouse_y = y; <br>      mouse_x = (winx / 2) - mouse_x; <br>      mouse_y = (winy / 2) - mouse_y; <br>      r2 = (float)sqrt((double)(mouse_x*mouse_x) / (double)(winx*winx) + <br>  (double)(mouse_y*mouse_y) / (double)(winy*winy)); <br>      scene_move(name_selected, r2 - r1, 0, 0, quick_moves ? 0 : 1); <br>      break; <br> <br>    case AUX_RIGHTBUTTON : <br>      /* Change phi - this is expensive */ <br>      dmousex = (float)((double)(x - mouse_x) / (double)winx); <br>      scene_move(name_selected, 0, dmousex, 0, quick_moves ? 0 : 1); <br>      break; <br>    } <br> <br>    mouse_x = x; <br>    mouse_y = y; <br>} <br> <br> <br>// <br>// hack these since cfront generates these... <br>// <br>PVOID __nw(unsigned int ui) <br>{ <br>    return LocalAlloc(LMEM_FIXED, ui); <br>} <br> <br> <br>VOID __dl(PVOID pv) <br>{ <br> <br>    LocalFree(pv); <br>    return; <br>} <br> <br>PVOID __vec_new(void *p, int x, int y, void *q) <br>{ <br>    return LocalAlloc(LMEM_FIXED, x*y); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
