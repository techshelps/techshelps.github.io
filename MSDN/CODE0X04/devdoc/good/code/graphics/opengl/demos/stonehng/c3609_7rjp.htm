<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCENE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3625"></a>SCENE.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/glaux.h&gt; <br> <br>/* <br>#ifdef X11 <br>#include &lt;GL/glx.h&gt; <br>extern "C" { <br>#include &lt;tk.h&gt; <br>}; <br>#endif <br>*/ <br> <br>#ifdef WIN32 <br>#include "stonehen.h" <br>#endif <br> <br>#include "Point.h" <br>#include "Ring.h" <br>#include "Roundwal.h" <br>#include "Ellipse.h" <br>#include "Telescop.h" <br> <br>#define SCENE_EXTERN <br>#include "scene.h" <br> <br>GLfloat mat_view[16]; <br>GLfloat view_rotx = 0; <br>GLfloat fov = 45.0, aspect = 1.0; <br>static Point eyep = {0, 0, .5}; <br>static Point lookp = {0.05, 1, .25}; <br> <br>TimeDate current_time; <br> <br>static int list_ground; <br>static int list_texture_ground; <br>static int list_trees; <br>static int list_texture_trees; <br>static int list_ring; <br>static int list_ellipse; <br>static int list_texture_stones; <br>static int list_shadows; <br>static int list_telescope; <br>static int list_texture_telescope; <br>int draw_ground = 1; <br>int draw_trees = 0; <br>int draw_ring = 1; <br>int draw_ellipse = 1; <br>int draw_shadows = 0; <br> <br>int use_lighting = 1; <br>int use_textures = 0; <br>int texture_hack = 0;//HACK HACK HACK - only texture map the stone <br>int use_normal_fog = 0; <br>int use_fancy_fog = 0; <br>int use_telescope = 0; <br>int use_antialias = 0; <br> <br>static void scene_identity(); <br>static void scene_project(GLfloat f = fov, float dx = 0, float dy = 0); <br>static void scene_draw(int rend = 1); <br>static void scene_render_telescope(); <br> <br>static void draw_background(); <br> <br>Point sun_position = {0., .707, .707, 0.}; <br>Color ambient(.25, .25, .25, 1.); <br>static void lights_init(); <br> <br>static void lists_init(); <br> <br>static void ground_list_init(); <br>static void ground_draw(); <br> <br>Roundwall trees; <br>static void trees_list_init(); <br>static void trees_draw(); <br> <br>Ring ring; <br>static void ring_list_init(); <br>static void ring_draw(); <br> <br>EllipseSt ellipse; <br>static void ellipse_list_init(); <br>static void ellipse_draw(); <br> <br>static void shadows_list_init(); <br>static void shadows_draw(); <br> <br>Weather weather; <br> <br>Telescope telescope; <br>GLfloat magnif = .5; <br>static void telescope_list_init(); <br>static void telescope_draw(); <br> <br>/* Read the back buffer into the accum buffer, adding in the appropriate <br> * alpha values */ <br>static void fog_read_image(); <br>/* Add the accum buffer to the back buffer */ <br>static void fog_write_image(); <br> <br> <br>inline float clamp(float x, float min, float max) <br>{ <br>  if (x &lt; min) return min; <br>  else if (x &gt; max) return max; <br>  else return x; <br>} <br> <br>void scene_init()  <br>{ <br> <br>  scene_identity(); <br>  scene_viewer_center(); <br> <br>  glEnable(GL_CULL_FACE); <br>  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE); <br> <br> <br>  glEnable(GL_NORMALIZE); <br> <br>  /* Initial time will be four in the afternoon */ <br>  scene_set_time(TimeDate(16, 0)); <br>  scene_set_weather(weathers[def_weather_index]); <br> <br>  lights_init(); <br>  lists_init(); <br>} <br> <br> <br>inline double time_minutes(int hour, int minute, int second) <br>{ <br>  return (double)hour*60.0 + (double)minute + (double)second / 60.0; <br>} <br> <br>static void scene_time_changed() <br>{ <br>  sun_position = current_time.sun_direction(); <br>      <br>  weather.apply(sun_position); <br> <br>  lights_init(); <br>  shadows_list_init(); <br>} <br>   <br>void scene_set_time(TimeDate t) <br>{ <br>  current_time = t; <br>  scene_time_changed(); <br>} <br> <br>void scene_inc_time(TimeDate t) <br>{ <br>  current_time += t; <br>  scene_time_changed(); <br>} <br> <br>/* This is a hack -- has to be called several times to get the antialiasing <br> * to work */ <br>static void scene_inner_render(GLfloat dx = 0, GLfloat dy = 0) <br>{ <br>  /* This draws layered fog if the use_fancy_fog flag is on -- <br>   * it's going to be slow on anything but high-end stuff */ <br>  if (use_fancy_fog &amp;&amp; weather.fog_density != 0.) { <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br> <br>    glEnable(GL_FOG); <br>    draw_background(); <br>    scene_project(fov, dx, dy); <br>    glClear(GL_DEPTH_BUFFER_BIT); <br>    if (use_lighting) glEnable(GL_LIGHTING); <br>    scene_draw(); <br>    if (use_lighting) glDisable(GL_LIGHTING); <br>    fog_read_image(); <br>    glDisable(GL_FOG); <br>  } else  <br>    if (use_normal_fog &amp;&amp; weather.fog_density != 0.) glEnable(GL_FOG); <br>    else glDisable(GL_FOG); <br> <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>  glMatrixMode(GL_MODELVIEW); <br>  glLoadIdentity(); <br> <br>  /* This is the part where we actually draw the image */ <br>  glClear(GL_DEPTH_BUFFER_BIT); <br>  draw_background(); <br>  scene_project(fov, dx, dy); <br>  glClear(GL_DEPTH_BUFFER_BIT); <br>  if (use_lighting) glEnable(GL_LIGHTING); <br>  scene_draw(); <br>  if (use_lighting) glDisable(GL_LIGHTING); <br> <br>  if (use_fancy_fog &amp;&amp; weather.fog_density != 0.) { <br>    fog_write_image(); <br>  } <br> <br>  if (use_telescope) scene_render_telescope(); <br>} <br> <br>void scene_render() <br>{ <br>  GLint vp[4]; <br> <br>  scene_inner_render(); <br> <br>  if (!use_antialias) return; <br> <br>  if (use_fancy_fog) { <br>    //fprintf(stderr, "Cannot antialias while using fancy fog.\n"); <br>    return; <br>  } <br> <br> <br>  glGetIntegerv(GL_VIEWPORT, vp); <br>  glAccum(GL_LOAD, .5); <br> <br>  scene_inner_render(2. / (float)vp[2], 2. / (float)vp[3]); <br>  glAccum(GL_ACCUM, .5); <br> <br>/* <br>  scene_inner_render(-2. / (float)vp[2], -2. / (float)vp[3]); <br>  glAccum(GL_ACCUM, .25);  <br>*/ <br>  glAccum(GL_RETURN, 1); <br>/* <br>  glDrawBuffer(GL_BACK); <br>  glFlush(); <br>*/ <br>} <br> <br>static void scene_render_telescope() <br>{ <br>  telescope.draw_setup(fov, aspect); <br> <br>  /* Don't fog the telescope - moisture makes it rust. <br>   * Seriously, it's in a strange coordinate system and fog will look <br>   * bad on it. */ <br>  glPushAttrib(GL_ENABLE_BIT); <br>  glDisable(GL_FOG); <br>  if (use_textures) { <br>    glCallList(list_texture_telescope); <br>    glEnable(GL_TEXTURE_2D); <br>  } <br>  glCallList(list_telescope); <br>  glPopAttrib(); <br> <br>  if (use_lighting) glEnable(GL_LIGHTING); <br>  glEnable(GL_STENCIL_TEST); <br>  glClearStencil(0); <br>  glClear(GL_STENCIL_BUFFER_BIT); <br>  glStencilFunc(GL_ALWAYS, 0x1, 0x1); <br>  glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE);  <br> <br>  glDisable(GL_CULL_FACE); <br>  telescope.draw_lens(); <br>  glEnable(GL_CULL_FACE); <br> <br>  telescope.draw_takedown(); <br> <br>  if (use_lighting) glDisable(GL_LIGHTING); <br> <br>  glStencilFunc(GL_NOTEQUAL, 0x0, 0xffffffff); <br>  glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP); <br> <br>  scene_identity(); <br> <br>  draw_background(); <br> <br>  glMatrixMode(GL_PROJECTION); <br>  glTranslatef(telescope.xpos / magnif, -telescope.ypos / magnif, 0); <br>  scene_project(fov * magnif); <br> <br>  glClear(GL_DEPTH_BUFFER_BIT); <br> <br>  /* Pushing the lighting bit used to do really bad things, but  <br>   * hopefully they've all gone away */ <br>  glPushAttrib(GL_LIGHTING_BIT); <br>  lights_init(); <br>  if (use_lighting) glEnable(GL_LIGHTING); <br>  scene_draw(); <br>  if (use_lighting) glDisable(GL_LIGHTING); <br>  glPopAttrib(); <br> <br>  glDisable(GL_STENCIL_TEST); <br>} <br> <br>static void scene_identity() <br>{ <br>  glMatrixMode(GL_PROJECTION); <br>  glLoadIdentity(); <br>  glMatrixMode(GL_MODELVIEW); <br>  glLoadIdentity(); <br>} <br> <br>static void scene_project(GLfloat f, float dx, float dy) <br>{ <br>  glMatrixMode(GL_PROJECTION); <br>  glOrtho(-1 - dx, 1, -1 - dy, 1, 0, -1); <br>  gluPerspective(f, aspect, 0.01, 40.0); <br>  glMatrixMode(GL_MODELVIEW); <br>  glRotatef(view_rotx, 1, 0, 0); <br>  gluLookAt(eyep.pt[0], eyep.pt[1], eyep.pt[2],  <br>    lookp.pt[0], lookp.pt[1], lookp.pt[2], <br>            0, 0, 1); <br>  glMultMatrixf(mat_view); <br>lights_init(); <br>} <br> <br>/* scene_draw() just draws the geometry - it's used for rendering and <br> * picking. */ <br>static void scene_draw(int rend) <br>{ <br>  if (draw_ground) { <br>    if (rend) { <br>      if (use_textures) { <br>glCallList(list_texture_ground); <br>glEnable(GL_TEXTURE_2D); <br>      } else glEnable(GL_COLOR_MATERIAL); <br>    } <br>    glCallList(list_ground); <br> <br>    if (rend) { <br>      glDisable(GL_TEXTURE_2D); <br>      glDisable(GL_COLOR_MATERIAL); <br>    } <br>  } <br> <br>  if (draw_shadows) { <br>    if (use_textures &amp;&amp; rend &amp;&amp; !draw_ground) { <br>      glCallList(list_texture_ground); <br>      glEnable(GL_TEXTURE_2D); <br>    } <br>    glCallList(list_shadows); <br>    if (use_textures &amp;&amp; rend) glDisable(GL_TEXTURE_2D); <br>  } <br> <br>  if (draw_trees) { <br>    if (use_textures &amp;&amp; rend) { <br>      glCallList(list_texture_trees); <br>      glEnable(GL_TEXTURE_2D); <br>    } <br>    glCallList(list_trees); <br>    if (use_textures &amp;&amp; rend) glDisable(GL_TEXTURE_2D); <br>  } <br> <br>  glClear(GL_DEPTH_BUFFER_BIT); <br> <br>  if (draw_ring) { <br>    if (rend) { <br>      if (use_textures || texture_hack) { <br>glCallList(list_texture_stones); <br>glEnable(GL_TEXTURE_2D); <br>      } <br>      glEnable(GL_COLOR_MATERIAL); <br>      glColor3f(.5, .5, .5); <br>    } <br>    glCallList(list_ring); <br>    if (rend) { <br>      if (use_textures || texture_hack) glDisable(GL_TEXTURE_2D); <br>      glDisable(GL_COLOR_MATERIAL); <br>    } <br>  } <br> <br>  if (draw_ellipse) { <br>    if (use_textures &amp;&amp; rend) { <br>      // Hack to avoid doing something expensive twice in a row <br>      if (!draw_ring) glCallList(list_texture_stones); <br>      glEnable(GL_TEXTURE_2D); <br>    } <br>    glCallList(list_ellipse); <br>    if (use_textures &amp;&amp; rend) glDisable(GL_TEXTURE_2D); <br>  } <br>} <br> <br>static void draw_background() <br>{ <br>  weather.draw_sky(sun_position); <br>} <br> <br>void scene_viewer_center() <br>{ <br>  glPushMatrix(); <br>  glLoadIdentity(); <br>  glGetFloatv(GL_MODELVIEW_MATRIX, mat_view); <br>  glPopMatrix(); <br>  view_rotx = 0; <br>} <br> <br>void scene_viewer_rotate_worldz(GLfloat degrees) <br>{ <br>  glMatrixMode(GL_MODELVIEW); <br>  glPushMatrix(); <br>  glLoadIdentity(); <br>  glRotatef(degrees, 0, 0, 1); <br>  glMultMatrixf(mat_view); <br>  glGetFloatv(GL_MODELVIEW_MATRIX, mat_view); <br>  glPopMatrix(); <br>  glMatrixMode(GL_MODELVIEW); <br>} <br> <br>void scene_viewer_rotatez(GLfloat degrees) <br>{ <br>  glMatrixMode(GL_PROJECTION); <br>  glPushMatrix(); <br>  glLoadIdentity(); <br>  glRotatef(degrees, 0, 0, 1); <br>  glMultMatrixf(mat_view); <br>  glGetFloatv(GL_PROJECTION_MATRIX, mat_view); <br>  glPopMatrix(); <br>  glMatrixMode(GL_MODELVIEW); <br>} <br> <br>void scene_viewer_rotatex(GLfloat degrees) <br>{ <br>  view_rotx += degrees; <br>  view_rotx = clamp(view_rotx, -60, 60); <br>  scene_identity(); <br>  scene_project(); <br>  lights_init(); <br>} <br> <br>void scene_viewer_translate(GLfloat dist) <br>{ <br>  glMatrixMode(GL_PROJECTION); <br>  glPushMatrix(); <br>  glLoadIdentity(); <br>  glTranslatef(0, dist, 0); <br>  glMultMatrixf(mat_view); <br>  glGetFloatv(GL_PROJECTION_MATRIX, mat_view); <br>  glPopMatrix(); <br>  glMatrixMode(GL_MODELVIEW); <br>  scene_identity(); <br>  scene_project(); <br>  lights_init(); <br>} <br> <br>void scene_position_telescope(GLfloat x, GLfloat y) <br>{ <br>  telescope.xpos = x; <br>  telescope.ypos = y; <br>} <br> <br>void scene_get_position_telescope(GLfloat *x, GLfloat *y) <br>{ <br>  *x = telescope.xpos; <br>  *y = telescope.ypos; <br>} <br> <br>void scene_get_radius_telescope(GLfloat *r) <br>{ <br>  *r = telescope.get_radius(); <br>} <br> <br>void scene_set_weather(Weather w) <br>{ <br>  weather = w; <br>  weather.apply(sun_position); <br>  shadows_list_init(); <br>} <br> <br>static int get_lists(int size) <br>{ <br>  int i; <br>  i = glGenLists(size); <br>  if (size &amp;&amp; !i) { <br>    //fprintf(stderr, "Unable to allocate %d display lists.\n"); <br>    exit(1); <br>  } <br>  return i; <br>} <br> <br>static void lights_init() <br>{ <br>  glLightfv(GL_LIGHT0, GL_POSITION, sun_position.pt); <br> <br>  /* This light gives a diffuse coefficient when the sun is off -  <br>   * it's used for drawing shadows */ <br>  glLightfv(GL_LIGHT1, GL_AMBIENT, black.c); <br>  glLightfv(GL_LIGHT1, GL_DIFFUSE, black.c); <br>  glLightfv(GL_LIGHT1, GL_SPECULAR, black.c); <br>} <br> <br>#ifdef TEXTURE <br>static void textures_list_init() <br>{ <br>  AUX_RGBImageRec *teximage = NULL; <br>   <br>  teximage = auxRGBImageLoad((char *)texfile_stones); <br>  glNewList(list_texture_stones, GL_COMPILE); <br>  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage-&gt;sizeX, teximage-&gt;sizeY,  <br>    GL_RGB, GL_UNSIGNED_BYTE, teximage-&gt;data); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,  <br> GL_NEAREST_MIPMAP_NEAREST); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, <br> GL_LINEAR); <br>  glMatrixMode(GL_TEXTURE); <br>  glLoadIdentity(); <br>  glMatrixMode(GL_MODELVIEW); <br>  glDisable(GL_TEXTURE_GEN_S); <br>  glDisable(GL_TEXTURE_GEN_T); <br>  glEndList(); <br> <br>  /* tk is obnoxious and doesn't seem to provide any mechanism for this */ <br>  free(teximage-&gt;data); <br>  free(teximage); <br> <br>  teximage = auxRGBImageLoad((char *)texfile_ground); <br>  glNewList(list_texture_ground, GL_COMPILE); <br>  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage-&gt;sizeX, teximage-&gt;sizeY,  <br>    GL_RGB, GL_UNSIGNED_BYTE, teximage-&gt;data); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,  <br>  GL_NEAREST_MIPMAP_NEAREST); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, <br>  GL_LINEAR); <br>  glMatrixMode(GL_TEXTURE); <br>  glLoadIdentity(); <br>  glScalef(100, 100, 1); <br>  glMatrixMode(GL_MODELVIEW); <br>  glDisable(GL_TEXTURE_GEN_S); <br>  glDisable(GL_TEXTURE_GEN_T); <br>  glEndList(); <br> <br>  free(teximage-&gt;data); <br>  free(teximage); <br> <br>  /* Figure out some way to get an alpha component out of the tk -- <br>   * otherwise we're really hosed */ <br>  teximage = auxRGBImageLoad((char *)texfile_trees); <br>  glNewList(list_texture_trees, GL_COMPILE); <br>  /* In the final scenerio we probably won't want to mipmap this, but it's <br>   * not square and I don't feel like bothering to scale it */ <br>  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage-&gt;sizeX, teximage-&gt;sizeY, <br>    GL_RGB, GL_UNSIGNED_BYTE, teximage-&gt;data); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,  <br>  GL_NEAREST_MIPMAP_NEAREST); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, <br>  GL_LINEAR); <br>  glMatrixMode(GL_TEXTURE); <br>  glLoadIdentity(); <br>  glMatrixMode(GL_MODELVIEW); <br>  glDisable(GL_TEXTURE_GEN_S); <br>  glDisable(GL_TEXTURE_GEN_T); <br>  glEndList(); <br> <br>  free(teximage-&gt;data); <br>  free(teximage); <br> <br>  teximage = auxRGBImageLoad((char *)texfile_telescope); <br>  glNewList(list_texture_telescope, GL_COMPILE); <br>  glTexImage2D(GL_TEXTURE_2D, 0, 3, teximage-&gt;sizeX, teximage-&gt;sizeY, <br>       0, GL_RGB, GL_UNSIGNED_BYTE, teximage-&gt;data); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <br>  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <br>  glMatrixMode(GL_TEXTURE); <br>  glLoadIdentity(); <br>  glMatrixMode(GL_MODELVIEW); <br>  glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP); <br>  glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP); <br>  glEnable(GL_TEXTURE_GEN_S); <br>  glEnable(GL_TEXTURE_GEN_T); <br>  glEndList(); <br> <br>  free(teximage-&gt;data); <br>  free(teximage); <br>} <br>#endif <br> <br>static void lists_init() <br>{ <br>  list_ground = get_lists(1); <br>  list_texture_ground = get_lists(1); <br>  list_trees = get_lists(1); <br>  list_texture_trees = get_lists(1); <br>  list_ring = get_lists(1); <br>  list_ellipse = get_lists(1); <br>  list_texture_stones = get_lists(1); <br>  list_shadows = get_lists(1); <br>  list_telescope = get_lists(1); <br>  list_texture_telescope = get_lists(1); <br> <br>  ground_list_init(); <br>  trees_list_init(); <br>  shadows_list_init(); <br>  ring_list_init(); <br>  ellipse_list_init(); <br>#ifdef TEXTURE <br>  textures_list_init(); <br>#endif <br>  telescope_list_init(); <br>} <br> <br>static void ground_list_init() <br>{ <br>  glNewList(list_ground, GL_COMPILE); <br>  ground_draw(); <br>  glEndList(); <br>} <br> <br>static void ground_draw()  <br>{ <br>  glColor3f(0, .75, 0); <br> <br>  glLoadName(name_ground); <br> <br>  glNormal3f(0, 0, 1); <br> <br>  glPushMatrix(); <br>  /* Making something this big would confuse the zbuffer, but we're  <br>   * clearing that AFTER drawing this, so it's ok */ <br>  glScalef(100, 100, 1); <br>  glBegin(GL_QUADS); <br>  glTexCoord2f(0, 0); <br>  glVertex2f(-1, -1); <br>  glTexCoord2f(1, 0); <br>  glVertex2f(1, -1); <br>  glTexCoord2f(1, 1); <br>  glVertex2f(1, 1); <br>  glTexCoord2f(0, 1); <br>  glVertex2f(-1, 1); <br>  glEnd(); <br>  glPopMatrix(); <br>} <br> <br>static void trees_list_init() <br>{ <br>  glNewList(list_trees, GL_COMPILE); <br>  trees_draw(); <br>  glEndList(); <br>} <br> <br>static void trees_draw() <br>{ <br>  glEnable(GL_COLOR_MATERIAL); <br>  glColor3f(0, .5, 0); <br> <br>  glLoadName(name_trees); <br>   <br>  glEnable(GL_BLEND); <br>  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); <br>  trees.draw(); <br>  glDisable(GL_BLEND); <br> <br>  glDisable(GL_COLOR_MATERIAL); <br>} <br> <br>static void ring_list_init() <br>{ <br>  glNewList(list_ring, GL_COMPILE); <br>  ring_draw(); <br>  glEndList(); <br>} <br> <br>static void ring_draw() <br>{ <br>  glLoadName(name_ring); <br> <br>  glEnable(GL_DEPTH_TEST); <br>  ring.erode(.1); <br>  ring.draw(); <br>  glDisable(GL_DEPTH_TEST); <br>} <br> <br>static void ellipse_list_init() <br>{ <br>  glNewList(list_ellipse, GL_COMPILE); <br>  ellipse_draw(); <br>  glEndList(); <br>} <br> <br>static void ellipse_draw() <br>{ <br>  glEnable(GL_COLOR_MATERIAL); <br>  glColor3f(.5, .5, .5); <br>   <br>  glEnable(GL_DEPTH_TEST); <br> <br>  glLoadName(name_ellipse); <br> <br>  ellipse.erode(.1); <br>  ellipse.draw(); <br> <br>  glDisable(GL_DEPTH_TEST); <br> <br>  glDisable(GL_COLOR_MATERIAL); <br>} <br> <br>static void shadows_list_init() <br>{ <br>  glNewList(list_shadows, GL_COMPILE); <br>  shadows_draw(); <br>  glEndList(); <br>} <br> <br>static void shadows_draw() <br>{ <br>  Color grass(0, .75, 0); <br> <br>  glPushAttrib(GL_ENABLE_BIT); <br> <br>  /* Turn the sun off */ <br>  glDisable(GL_LIGHT0); <br>  glEnable(GL_LIGHT1); <br>  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, grass.c); <br>  glColor3fv((grass * .5).c); <br> <br>  glDisable(GL_CULL_FACE); <br>  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); <br>  glEnable(GL_BLEND); <br>  ring.draw_shadow(sun_position, weather.shadow_blur(),  <br>   grass * .5, grass); <br>  ellipse.draw_shadow(sun_position, weather.shadow_blur(),  <br>      grass * .5, grass); <br>  glPopAttrib(); <br>} <br> <br>static void telescope_list_init() <br>{ <br>  glNewList(list_telescope, GL_COMPILE); <br>  telescope_draw(); <br>  glEndList(); <br>} <br> <br>static void telescope_draw() <br>{ <br>  glLoadName(name_telescope); <br>  glEnable(GL_COLOR_MATERIAL); <br>  glDisable(GL_CULL_FACE); <br>  glClear(GL_DEPTH_BUFFER_BIT); <br>  glEnable(GL_DEPTH_TEST); <br>  telescope.draw_body(); <br>  glDisable(GL_DEPTH_TEST); <br>  glEnable(GL_CULL_FACE); <br>  glDisable(GL_COLOR_MATERIAL); <br>} <br> <br>static void fog_read_image() <br>{ <br>  glPushMatrix(); <br>  glLoadIdentity(); <br> <br>  /* This creates an alpha gradient across the image */ <br>/*  glColorMask(0, 0, 0, 1); <br>  glBegin(GL_QUADS); <br>  glColor4f(1, 1, 1, 1); <br>  glVertex2f(-1, -1); <br>  glVertex2f(1, -1); <br>  glColor4f(1, 1, 1, 0); <br>  glVertex2f(1, 1); <br>  glVertex2f(-1, 1); <br>  glEnd(); <br>  glColorMask(1, 1, 1, 1); <br>*/ <br>  glDrawBuffer(GL_BACK); <br>  glReadBuffer(GL_BACK); <br>  glAccum(GL_LOAD, 1); <br> <br>  glPopMatrix(); <br>} <br> <br>static void fog_write_image() <br>{ <br>  glDrawBuffer(GL_BACK); <br> <br>  /* Put this back in once we're done testing */ <br>//  glEnable(GL_BLEND); <br>  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); <br>  glAccum(GL_RETURN, 1);   <br>  glDisable(GL_BLEND); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
