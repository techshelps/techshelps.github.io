<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SETPIXEL.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3627"></a>SETPIXEL.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;GL/gl.h&gt; <br>#include "stonehen.h" <br>#include "setpixel.h" <br> <br>#define BLACK   PALETTERGB(0,0,0) <br>#define WHITE   PALETTERGB(255,255,255) <br>#define NUM_STATIC_COLORS   (COLOR_BTNHIGHLIGHT - COLOR_SCROLLBAR + 1) <br> <br>static COLORREF gacrSave[NUM_STATIC_COLORS]; <br> <br>static COLORREF gacrBlackAndWhite[NUM_STATIC_COLORS] = { <br>    WHITE,  // COLOR_SCROLLBAR <br>    BLACK,  // COLOR_BACKGROUND <br>    BLACK,  // COLOR_ACTIVECAPTION <br>    WHITE,  // COLOR_INACTIVECAPTION <br>    WHITE,  // COLOR_MENU <br>    WHITE,  // COLOR_WINDOW <br>    BLACK,  // COLOR_WINDOWFRAME <br>    BLACK,  // COLOR_MENUTEXT <br>    BLACK,  // COLOR_WINDOWTEXT <br>    WHITE,  // COLOR_CAPTIONTEXT <br>    WHITE,  // COLOR_ACTIVEBORDER <br>    WHITE,  // COLOR_INACTIVEBORDER <br>    WHITE,  // COLOR_APPWORKSPACE <br>    BLACK,  // COLOR_HIGHLIGHT <br>    WHITE,  // COLOR_HIGHLIGHTTEXT <br>    WHITE,  // COLOR_BTNFACE <br>    BLACK,  // COLOR_BTNSHADOW <br>    BLACK,  // COLOR_GRAYTEXT <br>    BLACK,  // COLOR_BTNTEXT <br>    BLACK,  // COLOR_INACTIVECAPTIONTEXT <br>    BLACK   // COLOR_BTNHIGHLIGHT <br>    }; <br>static INT gaiStaticIndex[NUM_STATIC_COLORS] = { <br>    COLOR_SCROLLBAR          , <br>    COLOR_BACKGROUND         , <br>    COLOR_ACTIVECAPTION      , <br>    COLOR_INACTIVECAPTION    , <br>    COLOR_MENU               , <br>    COLOR_WINDOW             , <br>    COLOR_WINDOWFRAME        , <br>    COLOR_MENUTEXT           , <br>    COLOR_WINDOWTEXT         , <br>    COLOR_CAPTIONTEXT        , <br>    COLOR_ACTIVEBORDER       , <br>    COLOR_INACTIVEBORDER     , <br>    COLOR_APPWORKSPACE       , <br>    COLOR_HIGHLIGHT          , <br>    COLOR_HIGHLIGHTTEXT      , <br>    COLOR_BTNFACE            , <br>    COLOR_BTNSHADOW          , <br>    COLOR_GRAYTEXT           , <br>    COLOR_BTNTEXT            , <br>    COLOR_INACTIVECAPTIONTEXT, <br>    COLOR_BTNHIGHLIGHT <br>    }; <br> <br> <br>HPALETTE    ghpalOld, ghPalette = (HPALETTE) 0; <br>BOOL        bUseStaticColors = FALSE; <br>BOOL        bSystemColorsInUse = FALSE; <br>BOOL        bStaticSaved = FALSE; <br> <br> <br> <br>unsigned char threeto8[8] = { <br>    0, 0111&gt;&gt;1, 0222&gt;&gt;1, 0333&gt;&gt;1, 0444&gt;&gt;1, 0555&gt;&gt;1, 0666&gt;&gt;1, 0377 <br>}; <br> <br>unsigned char twoto8[4] = { <br>    0, 0x55, 0xaa, 0xff <br>}; <br> <br>unsigned char oneto8[2] = { <br>    0, 255 <br>}; <br> <br>unsigned char <br>ComponentFromIndex(UCHAR i, UINT nbits, UINT shift) <br>{ <br>    unsigned char val; <br> <br>    val = i &gt;&gt; shift; <br>    switch (nbits) { <br> <br>    case 1: <br>        val &amp;= 0x1; <br>        return oneto8[val]; <br> <br>    case 2: <br>        val &amp;= 0x3; <br>        return twoto8[val]; <br> <br>    case 3: <br>        val &amp;= 0x7; <br>        return threeto8[val]; <br> <br>    default: <br>        return 0; <br>    } <br>} <br> <br>void <br>CreateRGBPalette(HDC hdc) <br>{ <br>    PIXELFORMATDESCRIPTOR pfd, *ppfd; <br>    LOGPALETTE *pPal; <br>    int n, i; <br> <br>    ppfd = &amp;pfd; <br>    n = GetPixelFormat(hdc); <br>    DescribePixelFormat(hdc, n, sizeof(PIXELFORMATDESCRIPTOR), ppfd); <br> <br>    if (ppfd-&gt;dwFlags &amp; PFD_NEED_PALETTE) { <br>        n = 1 &lt;&lt; ppfd-&gt;cColorBits; <br>        pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>                n * sizeof(PALETTEENTRY)); <br>        pPal-&gt;palVersion = 0x300; <br>        pPal-&gt;palNumEntries = n; <br>        for (i=0; i&lt;n; i++) { <br>            pPal-&gt;palPalEntry[i].peRed = <br>                    ComponentFromIndex(i, ppfd-&gt;cRedBits, ppfd-&gt;cRedShift); <br>            pPal-&gt;palPalEntry[i].peGreen = <br>                    ComponentFromIndex(i, ppfd-&gt;cGreenBits, ppfd-&gt;cGreenShift); <br>            pPal-&gt;palPalEntry[i].peBlue = <br>                    ComponentFromIndex(i, ppfd-&gt;cBlueBits, ppfd-&gt;cBlueShift); <br>            pPal-&gt;palPalEntry[i].peFlags = 0; <br>        } <br> <br>        if (256 == n) <br>        { <br>            if (bUseStaticColors = ppfd-&gt;dwFlags &amp; PFD_NEED_SYSTEM_PALETTE) <br>            { <br>                // Prepare to take over the system's static colors <br> <br>                for (i = 0; i &lt; n; i++) <br>                    pPal-&gt;palPalEntry[i].peFlags = PC_NOCOLLAPSE; <br>            } <br>        } <br> <br>        ghPalette = CreatePalette(pPal); <br>        LocalFree(pPal); <br> <br>        //ghpalOld = SelectPalette(hdc, ghPalette, FALSE); <br>        //n = RealizePalette(hdc); <br>        n = RealizePaletteNow(hdc, ghPalette, FALSE); <br>    } <br>} <br> <br>BOOL bSetupPixelFormat(HDC hdc) <br>{ <br>    PIXELFORMATDESCRIPTOR pfd, *ppfd; <br>    int pixelformat; <br> <br>    ppfd = &amp;pfd; <br> <br>    ppfd-&gt;nSize = sizeof(PIXELFORMATDESCRIPTOR); <br>    ppfd-&gt;nVersion = 1; <br>    ppfd-&gt;dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER; <br>    ppfd-&gt;dwLayerMask = PFD_MAIN_PLANE; <br> <br>    ppfd-&gt;iPixelType = PFD_TYPE_RGBA; <br>    ppfd-&gt;cColorBits = 24; <br> <br>    ppfd-&gt;cDepthBits = 16;//GLX_DEPTH_SIZE <br> <br> <br>    ppfd-&gt;cRedBits = 1;//GLX_RED_SIZE <br>    ppfd-&gt;cRedShift = 0; <br>    ppfd-&gt;cGreenBits = 1;//GLX_GREEN_SIZE <br>    ppfd-&gt;cGreenShift = 0; <br>    ppfd-&gt;cBlueBits = 1;//GLX_BLUE_SIZE <br>    ppfd-&gt;cBlueShift = 0; <br>    ppfd-&gt;cAlphaBits = 0; <br>    ppfd-&gt;cAlphaShift = 0; <br>    ppfd-&gt;cAccumBits = 0;//ACCUM NOT SUPPORTED <br>    ppfd-&gt;cAccumRedBits = 0; //GLX_ACCUM_RED_SIZE <br>    ppfd-&gt;cAccumGreenBits = 0;//GLX_ACCUM_GREEN_SIZE <br>    ppfd-&gt;cAccumBlueBits = 0; //GLX_ACCUM_BLUE_SIZE <br>    ppfd-&gt;cAccumAlphaBits = 0;//GLX_ACCUM_ALPHA_SIZE <br> <br>    ppfd-&gt;cStencilBits = 4;//GLX_STENCIL_SIZE <br>    ppfd-&gt;cAuxBuffers = 0; <br>    ppfd-&gt;bReserved = 0; <br>    ppfd-&gt;dwVisibleMask = <br>    ppfd-&gt;dwDamageMask = 0; <br> <br>    pixelformat = ChoosePixelFormat(hdc, ppfd); <br> <br>    if ( (pixelformat = ChoosePixelFormat(hdc, ppfd)) == 0 ) <br>    { <br>        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (SetPixelFormat(hdc, pixelformat, ppfd) == FALSE) <br>    { <br>        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK); <br>        return FALSE; <br>    } <br> <br>    CreateRGBPalette(hdc); <br> <br>    return TRUE; <br>} <br> <br>long RealizePaletteNow( HDC hdc, HPALETTE hPal, BOOL bForceBackground ) <br>{ <br>    long Result = -1; <br> <br>    // If static system color usage is set, prepare to take over the <br>    // system palette. <br> <br>    if ( bUseStaticColors ) <br>    { <br>    // If foreground, take over the static colors.  If background, release <br>    // the static colors. <br>    // <br>    // Note: even though SaveStaticEntries is always called, it only saves <br>    // the static colors if we don't currently possess them.  Once saved, <br>    // they cannot be resaved until RestoreStaticEntries is called.  This <br>    // prevents a quirk in the palette messaging that may cause us to try <br>    // to save a copy of the B&amp;W settings as the original settings. <br> <br>        SaveStaticEntries( hdc ); <br>        SetSystemPaletteUse( hdc, bForceBackground ? SYSPAL_STATIC <br>                                                  : SYSPAL_NOSTATIC ); <br> <br>    // Rerealize the palette. <br>    // <br>    // If set to TRUE, bForceBackground will force the palette to be realized <br>    // as a background palette, regardless of focus. <br> <br>        if ( UnrealizeObject( hPal ) &amp;&amp; <br>                NULL != (ghpalOld = SelectPalette( hdc, hPal, bForceBackground )) ) <br>        { <br>            Result = RealizePalette( hdc ); <br>        } <br> <br>    // If foreground, setup the B&amp;W static colors.  If background, restore <br>    // the original static colors. <br> <br>        if ( bForceBackground ) <br>            RestoreStaticEntries( hdc ); <br>        else <br>            UseStaticEntries( hdc ); <br>    } <br>    else <br>    { <br>        if ( NULL != (ghpalOld = SelectPalette( hdc, hPal, FALSE )) ) <br>            Result = RealizePalette( hdc ); <br>    } <br> <br>    return( Result ); <br>} <br> <br>static VOID SaveStaticEntries(HDC hdc) <br>{ <br>    int i; <br> <br>    if ( !bSystemColorsInUse ) <br>    { <br>        for (i = COLOR_SCROLLBAR; i &lt;= COLOR_BTNHIGHLIGHT; i++) <br>            gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i); <br> <br>        bStaticSaved = TRUE; <br>    } <br>} <br> <br>static VOID UseStaticEntries(HDC hdc) <br>{ <br>    SetSysColors(NUM_STATIC_COLORS, gaiStaticIndex, gacrBlackAndWhite); <br>    bSystemColorsInUse = TRUE; <br> <br>    PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br>} <br> <br>static VOID RestoreStaticEntries(HDC hdc) <br>{ <br>    if ( bStaticSaved ) <br>    { <br>        SetSysColors(NUM_STATIC_COLORS, gaiStaticIndex, gacrSave); <br>        bSystemColorsInUse = FALSE; <br> <br>        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
