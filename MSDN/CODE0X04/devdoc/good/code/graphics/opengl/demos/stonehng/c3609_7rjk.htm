<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RGBIMAGE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3620"></a>RGBIMAGE.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt;  <br>#include &lt;GL/gl.h&gt; <br>#include "stonehen.h" <br> <br> <br>#define IMAGIC      0x01da <br>#define IMAGIC_SWAP 0xda01 <br> <br>#define SWAP_SHORT_BYTES(x) ((((x) &amp; 0xff) &lt;&lt; 8) | (((x) &amp; 0xff00) &gt;&gt; 8)) <br>#define SWAP_LONG_BYTES(x) (((((x) &amp; 0xff) &lt;&lt; 24) | (((x) &amp; 0xff00) &lt;&lt; 8)) | \ <br>                            ((((x) &amp; 0xff0000) &gt;&gt; 8) | (((x) &amp; 0xff000000) &gt;&gt; 24))) <br> <br>typedef struct _rawImageRec { <br>    unsigned short imagic; <br>    unsigned short type; <br>    unsigned short dim; <br>    unsigned short sizeX, sizeY, sizeZ; <br>    unsigned long min, max; <br>    unsigned long wasteBytes; <br>    char name[80]; <br>    unsigned long colorMap; <br>    FILE *file; <br>    unsigned char *tmp, *tmpR, *tmpG, *tmpB; <br>    unsigned long rleEnd; <br>    unsigned long *rowStart; <br>    unsigned long *rowSize; <br>} rawImageRec; <br> <br> <br>static rawImageRec *RawImageOpen(char *fileName) <br>{ <br>    rawImageRec *raw; <br>    unsigned long *rowStart, *rowSize, ulTmp; <br>    int x; <br> <br>    raw = (rawImageRec *)malloc(sizeof(rawImageRec)); <br>    if (raw == NULL) { <br>//fprintf(stderr, "Out of memory!\n"); <br>exit(-1); <br>    } <br>    if ((raw-&gt;file = fopen(fileName, "rb")) == NULL) { <br>perror(fileName); <br>exit(-1); <br>    } <br> <br>    fread(raw, 1, 12, raw-&gt;file); <br> <br>    if (raw-&gt;imagic == IMAGIC_SWAP) { <br>        raw-&gt;type = SWAP_SHORT_BYTES(raw-&gt;type); <br>        raw-&gt;dim = SWAP_SHORT_BYTES(raw-&gt;dim); <br>        raw-&gt;sizeX = SWAP_SHORT_BYTES(raw-&gt;sizeX); <br>        raw-&gt;sizeY = SWAP_SHORT_BYTES(raw-&gt;sizeY); <br>        raw-&gt;sizeZ = SWAP_SHORT_BYTES(raw-&gt;sizeZ); <br>    } <br>    raw-&gt;tmp = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpR = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpG = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpB = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    if (raw-&gt;tmp == NULL || raw-&gt;tmpR == NULL || raw-&gt;tmpG == NULL || <br>raw-&gt;tmpB == NULL) { <br>//fprintf(stderr, "Out of memory!\n"); <br>exit(-1); <br>    } <br> <br>    if ((raw-&gt;type &amp; 0xFF00) == 0x0100) { <br>x = raw-&gt;sizeY * raw-&gt;sizeZ * sizeof(long); <br>raw-&gt;rowStart = (unsigned long *)malloc(x); <br>raw-&gt;rowSize = (unsigned long *)malloc(x); <br>if (raw-&gt;rowStart == NULL || raw-&gt;rowSize == NULL) { <br>    //fprintf(stderr, "Out of memory!\n"); <br>    exit(-1); <br>} <br>raw-&gt;rleEnd = 512 + (2 * x); <br>fseek(raw-&gt;file, 512, SEEK_SET); <br>fread(raw-&gt;rowStart, 1, x, raw-&gt;file); <br>fread(raw-&gt;rowSize, 1, x, raw-&gt;file); <br>        if (raw-&gt;imagic == IMAGIC_SWAP) { <br>            x /= sizeof(long); <br>            rowStart = raw-&gt;rowStart; <br>            rowSize = raw-&gt;rowSize; <br>            while (x--) { <br>                ulTmp = *rowStart; <br>                *rowStart++ = SWAP_LONG_BYTES(ulTmp); <br>                ulTmp = *rowSize; <br>                *rowSize++ = SWAP_LONG_BYTES(ulTmp); <br>            } <br>        } <br>    } <br>    return raw; <br>} <br> <br>static void RawImageClose(rawImageRec *raw) <br>{ <br> <br>    fclose(raw-&gt;file); <br>    free(raw-&gt;tmp); <br>    free(raw-&gt;tmpR); <br>    free(raw-&gt;tmpG); <br>    free(raw-&gt;tmpB); <br>    free(raw); <br>} <br> <br>static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z) <br>{ <br>    unsigned char *iPtr, *oPtr, pixel; <br>    int count; <br> <br>    if ((raw-&gt;type &amp; 0xFF00) == 0x0100) { <br>fseek(raw-&gt;file, raw-&gt;rowStart[y+z*raw-&gt;sizeY], SEEK_SET); <br>fread(raw-&gt;tmp, 1, (unsigned int)raw-&gt;rowSize[y+z*raw-&gt;sizeY], <br>      raw-&gt;file); <br> <br>iPtr = raw-&gt;tmp; <br>oPtr = buf; <br>while (1) { <br>    pixel = *iPtr++; <br>    count = (int)(pixel &amp; 0x7F); <br>    if (!count) { <br>return; <br>    } <br>    if (pixel &amp; 0x80) { <br>while (count--) { <br>    *oPtr++ = *iPtr++; <br>} <br>    } else { <br>pixel = *iPtr++; <br>while (count--) { <br>    *oPtr++ = pixel; <br>} <br>    } <br>} <br>    } else { <br>fseek(raw-&gt;file, 512+(y*raw-&gt;sizeX)+(z*raw-&gt;sizeX*raw-&gt;sizeY), <br>      SEEK_SET); <br>fread(buf, 1, raw-&gt;sizeX, raw-&gt;file); <br>    } <br>} <br> <br>static void RawImageGetData(rawImageRec *raw, RGBImageRec *final) <br>{ <br>    unsigned char *ptr; <br>    int i, j; <br> <br>    final-&gt;data = (unsigned char *)malloc((raw-&gt;sizeX+1)*(raw-&gt;sizeY+1)*4); <br>    if (final-&gt;data == NULL) { <br>//fprintf(stderr, "Out of memory!\n"); <br>exit(-1); <br>    } <br> <br>    ptr = final-&gt;data; <br>    for (i = 0; i &lt; raw-&gt;sizeY; i++) { <br>RawImageGetRow(raw, raw-&gt;tmpR, i, 0); <br>RawImageGetRow(raw, raw-&gt;tmpG, i, 1); <br>RawImageGetRow(raw, raw-&gt;tmpB, i, 2); <br>for (j = 0; j &lt; raw-&gt;sizeX; j++) { <br>    *ptr++ = *(raw-&gt;tmpR + j); <br>    *ptr++ = *(raw-&gt;tmpG + j); <br>    *ptr++ = *(raw-&gt;tmpB + j); <br>} <br>    } <br>} <br> <br>RGBImageRec *RGBImageLoad(char *fileName) <br>{ <br>    rawImageRec *raw; <br>    RGBImageRec *final; <br> <br>    raw = RawImageOpen(fileName); <br>    final = (RGBImageRec *)malloc(sizeof(RGBImageRec)); <br>    if (final == NULL) { <br>//fprintf(stderr, "Out of memory!\n"); <br>exit(-1); <br>    } <br>    final-&gt;sizeX = raw-&gt;sizeX; <br>    final-&gt;sizeY = raw-&gt;sizeY; <br>    RawImageGetData(raw, final); <br>    RawImageClose(raw); <br>    return final; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
