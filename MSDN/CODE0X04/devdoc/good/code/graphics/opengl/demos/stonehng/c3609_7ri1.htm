<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POINT.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3619"></a>POINT.H</h2>
<pre><code>#ifndef POINT_H <br>#define POINT_H <br> <br>#ifndef POINT_EXTERN <br>#define POINT_EXTERN extern <br>#endif  <br> <br>#include &lt;math.h&gt; <br> <br>const float point_fudge = .000001; <br> <br>class Point { <br> public: <br>  inline Point operator=(Point a); <br>  inline Point operator=(GLfloat *a); <br>  inline Point operator+(Point a); <br>  inline Point operator+=(Point a); <br>  inline Point operator-(Point a); <br>  // This takes a cross-product <br>  inline Point operator*(Point b); <br>  inline Point operator*(GLfloat b); <br>  inline Point operator*=(GLfloat b); <br>  inline Point operator/(GLfloat b); <br>  inline Point operator/=(GLfloat b); <br>  inline GLfloat&amp; operator[](int index); <br>   <br>  inline void set(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0); <br>   <br>  inline GLfloat dist(Point b); <br>  inline GLfloat dot(Point b); <br>  inline GLfloat dot(GLfloat x, GLfloat y, GLfloat z); <br>  inline GLfloat mag(); <br>  inline GLfloat magsquared(); <br>  inline Point unit(); <br>  inline void unitize(); <br>   <br>  inline Point scale(Point p); <br>   <br>  // Angle is in RADIANS <br>  inline Point rotate(Point axis, GLfloat angle); <br>  inline Point rotate(Point axis, GLfloat c, GLfloat s); <br>  inline void rotate_self(Point axis, GLfloat c, GLfloat s); <br>  Point rotate_abouty(GLfloat c, GLfloat s); <br>  Point rotate_aboutz(GLfloat c, GLfloat s); <br>   <br>  // Returns point projected through proj_pt into XY plane <br>  // Does nothing if proj_pt - *this is parallel to XY plane <br>  inline Point project(Point proj_pt); <br>  inline void project_self(Point proj_pt); <br>  inline void Point::project_self(GLfloat px, GLfloat py, GLfloat pz); <br>  inline Point project_direction(Point direction); <br>  inline Point Point::project_direction(GLfloat x, GLfloat y, GLfloat z); <br>  // This projects (px, py, pz) into this in direction (dx, dy, dz) <br>  inline void Point::compute_projected(GLfloat px, GLfloat py, GLfloat pz, <br> GLfloat x, GLfloat y, GLfloat z); <br> <br>  // Returns point projected through light and refracted into XY <br>  // plane.   <br>  // N is normal at point (ie normal at *this) <br>  // I is the index of refraction <br>  inline Point refract(Point light, Point N, GLfloat I); <br>  void refract_self(Point light, Point N, GLfloat I); <br>  Point refract_direction(Point light, Point N, GLfloat I); <br>   <br>  inline void glvertex(); <br>  inline void glnormal(); <br>   <br>  void print(); <br>  void print(const char *format); <br>   <br>  GLfloat pt[4]; <br> private: <br>}; <br> <br>POINT_EXTERN Point val; <br> <br>#define DOT(a, b) (a.pt[0]*b.pt[0] + a.pt[1]*b.pt[1] + a.pt[2]*b.pt[2]) <br>#define THIS_DOT(b) (pt[0]*b.pt[0] + pt[1]*b.pt[1] + pt[2]*b.pt[2]) <br> <br>inline Point Point::operator=(Point a) <br>{ <br>  pt[0] = a.pt[0]; <br>  pt[1] = a.pt[1]; <br>  pt[2] = a.pt[2]; <br>  pt[3] = a.pt[3]; <br>  return *this; <br>} <br> <br>inline Point Point::operator=(GLfloat *a) <br>{ <br>  pt[0] = a[0];  <br>  pt[1] = a[1];  <br>  pt[2] = a[2];  <br>  pt[3] = 1; <br>  return *this; <br>} <br> <br>inline Point Point::operator+(Point a) <br>{   <br>  val.pt[0] = pt[0] + a.pt[0]; <br>  val.pt[1] = pt[1] + a.pt[1]; <br>  val.pt[2] = pt[2] + a.pt[2];  <br>  return val;  <br>} <br> <br>inline Point Point::operator+=(Point a) <br>{ <br>  pt[0] += a.pt[0]; <br>  pt[1] += a.pt[1]; <br>  pt[2] += a.pt[2]; <br>  return *this; <br>} <br> <br>inline Point Point::operator-(Point a) <br>{ <br>  val.pt[0] = pt[0] - a.pt[0]; <br>  val.pt[1] = pt[1] - a.pt[1]; <br>  val.pt[2] = pt[2] - a.pt[2]; <br>  return val; <br>} <br>   <br>inline Point Point::operator*(Point b) <br>{ <br>  val.pt[0] = pt[1]*b.pt[2] - b.pt[1]*pt[2]; <br>  val.pt[1] = pt[2]*b.pt[0] - b.pt[2]*pt[0]; <br>  val.pt[2] = pt[0]*b.pt[1] - pt[1]*b.pt[0]; <br>  return val; <br>} <br> <br>inline Point Point::operator*(GLfloat b) <br>{ <br>  val.pt[0] = pt[0] * b; <br>  val.pt[1] = pt[1] * b; <br>  val.pt[2] = pt[2] * b; <br>  return val; <br>} <br> <br>inline Point Point::operator*=(GLfloat b) <br>{ <br>  pt[0] *= b; <br>  pt[1] *= b; <br>  pt[2] *= b; <br>  return *this; <br>} <br> <br>inline Point Point::operator/(GLfloat b) <br>{ <br>  val.pt[0] = pt[0] / b; <br>  val.pt[1] = pt[1] / b; <br>  val.pt[2] = pt[2] / b; <br>  return val; <br>} <br> <br>inline Point Point::operator/=(GLfloat b) <br>{ <br>  pt[0] /= b; <br>  pt[1] /= b; <br>  pt[2] /= b; <br>  return *this; <br>} <br> <br>inline GLfloat&amp; Point::operator[](int index) <br>{ <br>  return pt[index]; <br>} <br> <br>inline void Point::set(GLfloat x, GLfloat y, GLfloat z, GLfloat w) <br>{ <br>  pt[0] = x; <br>  pt[1] = y; <br>  pt[2] = z; <br>  pt[3] = w; <br>} <br> <br>inline GLfloat Point::dist(Point b) <br>{ <br>  return (*this - b).mag(); <br>} <br> <br>inline GLfloat Point::dot(Point b) <br>{ <br>  return pt[0]*b.pt[0] + pt[1]*b.pt[1] + pt[2]*b.pt[2]; <br>} <br> <br>inline GLfloat Point::dot(GLfloat x, GLfloat y, GLfloat z) <br>{  <br>  return pt[0]*x + pt[1]*y + pt[2]*z; <br>} <br> <br>inline GLfloat Point::mag() <br>{ <br>  return sqrt(pt[0]*pt[0] + pt[1]*pt[1] +  <br>              pt[2]*pt[2]); <br>} <br> <br>inline GLfloat Point::magsquared() <br>{ <br>  return pt[0]*pt[0] + pt[1]*pt[1] + pt[2]*pt[2]; <br>} <br> <br>inline Point Point::unit() <br>{ <br>  GLfloat m = sqrt(pt[0]*pt[0] + pt[1]*pt[1] + pt[2]*pt[2]); <br>  val.pt[0] = pt[0] / m; <br>  val.pt[1] = pt[1] / m; <br>  val.pt[2] = pt[2] / m; <br>  return val; <br>} <br> <br>inline void Point::unitize() <br>{ <br>  GLfloat m = sqrt(pt[0]*pt[0] + pt[1]*pt[1] + pt[2]*pt[2]); <br>  pt[0] /= m; <br>  pt[1] /= m; <br>  pt[2] /= m; <br>} <br> <br>inline Point Point::scale(Point p)  <br>{ <br>  val.pt[0] = pt[0] * p.pt[0]; <br>  val.pt[1] = pt[1] * p.pt[1]; <br>  val.pt[2] = pt[2] * p.pt[2]; <br>  return val; <br>} <br> <br>inline Point Point::rotate(Point axis, GLfloat angle) <br>{ <br>  return rotate(axis, cos(angle), sin(angle)); <br>} <br> <br>inline Point Point::rotate(Point axis, GLfloat c, GLfloat s) <br>{ <br>  float x = axis.pt[0], y = axis.pt[1], z = axis.pt[2], t = 1.0 - c; <br>  float tx, ty; <br>   <br>  tx = t*x; <br>  /* Taking advantage of inside info that this is a common case */ <br>  if (y == 0.0) { <br>    val.pt[0] = pt[0]*(tx*x + c) + pt[1]*(-s*z) + pt[2]*(tx*z); <br>    val.pt[1] = pt[0]*(s*z) + pt[1]*c + pt[2]*(-s*x); <br>    val.pt[2] = pt[0]*(tx*z) + pt[1]*s*x + pt[2]*(t*z*z + c); <br>  } else { <br>    ty = t*y; <br>    val.pt[0] = pt[0]*(tx*x + c) + pt[1]*(tx*y - s*z) + <br>      pt[2]*(tx*z + s*y); <br>    val.pt[1] = pt[0]*(tx*y + s*z) + pt[1]*(ty*y + c) + <br>      pt[2]*(ty*z - s*x); <br>    val.pt[2] = pt[0]*(tx*z - s*y) + pt[1]*(ty*z + s*x) + <br>      pt[2]*(t*z*z + c); <br>  } <br>  return val; <br>} <br> <br>inline void Point::rotate_self(Point axis, GLfloat c, GLfloat s) <br>{ <br>  float Px, Py, Pz; <br>  float x = axis.pt[0], y = axis.pt[1], z = axis.pt[2], t = 1.0 - c; <br>  float tx, ty; <br>   <br>  tx = t*x; <br>  Px = pt[0]; <br>  Py = pt[1]; <br>  Pz = pt[2]; <br>  /* Taking advantage of inside info that this is a common case */ <br>  if (!y) { <br>    pt[0] = Px*(tx*x + c) +Py*(-s*z) + Pz*(tx*z); <br>    pt[1] = Px*(s*z) + Py*c + Pz*(-s*x); <br>    pt[2] = Px*(tx*z) + Py*s*x + Pz*(t*z*z + c); <br>  } else { <br>    ty = t*y; <br>    pt[0] = Px*(tx*x + c) + Py*(tx*y - s*z) + <br>      Pz*(tx*z + s*y); <br>    pt[1] = Px*(tx*y + s*z) + Py*(ty*y + c) + <br>      Pz*(ty*z - s*x); <br>    pt[2] = Px*(tx*z - s*y) + Py*(ty*z + s*x) + <br>      Pz*(t*z*z + c); <br>  } <br>}   <br> <br>inline void Point::glvertex()  <br>{ <br>  glVertex3fv(pt); <br>} <br> <br>inline void Point::glnormal() <br>{ <br>  glNormal3fv(pt); <br>} <br> <br>inline Point Point::project(Point proj_pt) <br>{ <br>  GLfloat dirx = pt[0] - proj_pt.pt[0],  <br>      diry = pt[1] - proj_pt.pt[1], <br>      dirz = pt[2] - proj_pt.pt[2]; <br>  GLfloat t; <br> <br>  if (fabs(dirz) &lt; point_fudge) val = *this; <br>  else { <br>    t = -proj_pt.pt[2] / dirz; <br>    val.pt[0] = proj_pt.pt[0] + dirx*t; <br>    val.pt[1] = proj_pt.pt[1] + diry*t; <br>    val.pt[2] = 0.0; <br>  } <br>  return val; <br>} <br> <br>// This naively assumes that proj_pt[z] != this-&gt;pt[z] <br>inline void Point::project_self(Point proj_pt) <br>{ <br>  GLfloat dirx = pt[0] - proj_pt.pt[0],  <br>      diry = pt[1] - proj_pt.pt[1], <br>      dirz = pt[2] - proj_pt.pt[2]; <br>  GLfloat t; <br> <br>  t = -proj_pt.pt[2] / dirz; <br>  pt[0] = proj_pt.pt[0] + dirx*t; <br>  pt[1] = proj_pt.pt[1] + diry*t; <br>  pt[2] = 0.0; <br>} <br> <br>inline void Point::project_self(GLfloat px, GLfloat py, GLfloat pz) <br>{ <br>  GLfloat dirx = pt[0] - px,  <br>  diry = pt[1] - py, <br>  dirz = pt[2] - pz, t; <br> <br>  t = -pz / dirz; <br>  pt[0] = px + dirx*t; <br>  pt[1] = py + diry*t; <br>  pt[2] = 0.0; <br>} <br> <br>inline Point Point::project_direction(Point direction) { <br>  GLfloat t; <br> <br>  t = -pt[2] / direction.pt[2]; <br>  val.pt[0] = pt[0] + direction.pt[0]*t; <br>  val.pt[1] = pt[1] + direction.pt[1]*t; <br>  val.pt[2] = 0; <br>  return val; <br>} <br> <br>inline Point Point::project_direction(GLfloat x, GLfloat y, GLfloat z)  <br>{ <br>  GLfloat t; <br> <br>  t = -pt[2] / z; <br>  val.pt[0] = pt[0] + x*t; <br>  val.pt[1] = pt[1] + y*t; <br>  val.pt[2] = 0; <br>  return val; <br>} <br> <br>inline void Point::compute_projected(GLfloat px, GLfloat py, GLfloat pz, <br>     GLfloat dx, GLfloat dy, GLfloat dz) <br>{ <br>  GLfloat t = -pz / dz; <br>  pt[0] = px + dx*t; <br>  pt[1] = py + dy*t; <br>  pt[2] = 0; <br>} <br> <br> <br>#undef POINT_EXTERN <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
