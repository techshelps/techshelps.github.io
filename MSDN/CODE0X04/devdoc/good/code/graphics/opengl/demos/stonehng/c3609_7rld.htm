<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STONEHEN.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3631"></a>STONEHEN.CXX</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include "glos.h" <br> <br>#include &lt;GL/gl.h&gt; <br>#include &lt;GL/glu.h&gt; <br> <br>#include "stonehen.h" <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#include "atmosphe.h" <br>#include "scene.h" <br>#include "callback.h" <br>#include "setpixel.h" <br> <br>extern int use_lighting; <br>extern int draw_shadows; <br>extern int use_normal_fog; <br>extern int use_textures; <br>extern int texture_hack;// HACK HACK - only texture map stones for now <br>extern int use_telescope; <br>extern int use_antialias; <br>extern int cb_demo_mode; <br> <br>BOOL Con; <br> <br>BOOL bTimeScale[5]; <br>extern GLfloat time_scale; <br>extern HPALETTE ghPalette, ghpalOld; <br> <br>GLfloat TimeScale[] = {0, 1, 10, 100, 500}; <br> <br>char szAppName[] = "Stonehenge"; <br> <br>extern TimeDate last_update; <br> <br>int curr_weather; <br> <br>HGLRC hRC; <br> <br>int  iTimer; <br> <br>/* forward declarations of helper functions in this module */ <br>HWND   WINAPI InitializeWindow (HINSTANCE, int); <br>VOID   WINAPI InitializeMenu (HWND, HMENU); <br>LONG   WINAPI CommandHandler (HWND, UINT, LONG); <br>LONG   WINAPI MainWndProc (HWND, UINT, UINT, LONG); <br> <br>/* entry point of this executable */ <br>int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG        msg; <br>    HWND       hWnd; <br> <br>    /* previous instances do not exist in Win32 */ <br>    if (hPrevInstance) <br>    return 0; <br> <br>    if (!(hWnd = InitializeWindow (hInstance, nCmdShow))) <br>        return FALSE; <br> <br>    /* main window message loop */ <br>    while (TRUE) { <br>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>            if (msg.message == WM_QUIT) break; <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>        } else { <br>            PostMessage(hWnd, WM_PAINT, NULL, NULL); <br>        } <br>    } <br> <br>    /* return success of application */ <br>    return TRUE; <br>} <br> <br>HWND WINAPI InitializeWindow (HINSTANCE hInstance, int nCmdShow) <br>    { <br>    WNDCLASS   wc; <br>    HWND       hWnd; <br>    RECT       rect; <br> <br>    /* Register the frame class */ <br>    wc.style         = CS_OWNDC; <br>    wc.lpfnWndProc   = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = hInstance; <br>    wc.hIcon         = LoadIcon (hInstance, szAppName); <br>    wc.hCursor       = LoadCursor (NULL,IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = szAppName; <br>    wc.lpszClassName = szAppName; <br> <br>    if (!RegisterClass (&amp;wc) ) <br>    return FALSE; <br> <br>    rect.left = 100; <br>    rect.top  = 100; <br>    rect.right = 652; <br>    rect.bottom = 500; <br> <br>    AdjustWindowRect(&amp;rect, WS_OVERLAPPEDWINDOW, FALSE); <br>    /* Create the frame */ <br>    hWnd = CreateWindow (szAppName, <br>             "OpenGL Stonehenge Demo", <br>     WS_OVERLAPPEDWINDOW | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, <br>             rect.left, <br>             rect.top, <br>             WINDSIZEX(rect), <br>             WINDSIZEY(rect), <br>             NULL, <br>             NULL, <br>             hInstance, <br>             NULL); <br> <br>    /* make sure window was created */ <br>    if (!hWnd) <br>    return FALSE; <br> <br>    InitializeMenu(hWnd, (HMENU) GetMenu(hWnd)); <br> <br>    SendMessage(hWnd, WM_INIT, NULL, NULL); <br> <br>    /* show and update main window */ <br>    ShowWindow (hWnd, nCmdShow); <br> <br>    UpdateWindow (hWnd); <br> <br>    return hWnd; <br>} <br> <br> <br> <br>/* main window procedure */ <br>LONG WINAPI MainWndProc ( <br>    HWND    hWnd, <br>    UINT    uMsg, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>    LONG    lRet = 1; <br> <br>    switch (uMsg) <br>    { <br>    case WM_CREATE: <br>        { <br>    HDC    hDC; <br> <br>    /* This is equivalent to the find_visual routine */ <br>            hDC = GetDC(hWnd); <br>    bSetupPixelFormat(hDC); <br> <br>            hRC = wglCreateContext( hDC ); <br>            Con = wglMakeCurrent( hDC, hRC ); <br>     <br>    ReleaseDC(hWnd, hDC); <br> <br>    // iTimer = SetTimer(hWnd, 1, 1000, NULL); <br>} <br>break; <br> <br> <br>    case WM_PAINT: <br>        {  <br>HDChDC; <br>PAINTSTRUCTps; <br> <br>hDC = BeginPaint(hWnd, &amp;ps); <br>EndPaint(hWnd, &amp;ps); <br> <br>drawWP(hWnd); <br> <br>        } <br>break; <br> <br>    case WM_INIT: <br>{ <br>    scene_init(); <br> <br>    last_update.read_time(); <br> <br>    resetViewerCB(NULL, NULL, NULL); <br> <br>} <br>break; <br> <br>        // The WM_QUERYNEWPALETTE message informs a window that it is about to <br>        // receive input focus. In response, the window receiving focus should <br>        // realize its palette as a foreground palette and update its client <br>        // area. If the window realizes its palette, it should return TRUE; <br>        // otherwise, it should return FALSE. <br> <br>        case WM_QUERYNEWPALETTE: <br>        { <br>            HDC     hDC; <br> <br>            if(ghPalette) <br>            { <br>                hDC = GetDC(hWnd); <br> <br>                // Select and realize the palette <br> <br>                //ghpalOld = SelectPalette(hDC, ghPalette, FALSE); <br>                RealizePaletteNow(hDC, ghPalette, FALSE); <br> <br>                // Redraw the client area <br> <br>                InvalidateRect(hWnd, NULL, TRUE); <br>                UpdateWindow(hWnd); <br> <br>                if(ghpalOld) <br>                    SelectPalette(hDC, ghpalOld, FALSE); <br> <br>                ReleaseDC(hWnd, hDC); <br> <br>                return TRUE; <br>            } <br> <br>            return FALSE; <br>        } <br> <br>        // The WM_PALETTECHANGED message informs all windows that the window <br>        // with input focus has realized its logical palette, thereby changing  <br>        // the system palette. This message allows a window without input focus <br>        // that uses a color palette to realize its logical palettes and update <br>        // its client area. <br>        // <br>        // This message is sent to all windows, including the one that changed <br>        // the system palette and caused this message to be sent. The wParam of <br>        // this message contains the handle of the window that caused the system <br>        // palette to change. To avoid an infinite loop, care must be taken to <br>        // check that the wParam of this message does not match the window's <br>        // handle. <br> <br>        case WM_PALETTECHANGED: <br>        { <br>            HDC         hDC;  <br> <br>            // Before processing this message, make sure we <br>            // are indeed using a palette <br> <br>            if (ghPalette) <br>            { <br>                // If this application did not change the palette, select <br>                // and realize this application's palette <br> <br>                if (uParam != (WPARAM)hWnd) <br>                { <br>                    // Need the window's DC for SelectPalette/RealizePalette <br> <br>                    hDC = GetDC(hWnd); <br> <br>                    // Select and realize our palette <br> <br>                    //ghpalOld = SelectPalette(hDC, ghPalette, FALSE); <br>                    RealizePaletteNow(hDC, ghPalette, FALSE); <br> <br>                    // WHen updating the colors for an inactive window, <br>                    // UpdateColors can be called because it is faster than <br>                    // redrawing the client area (even though the results are <br>                    // not as good) <br> <br>                    UpdateColors(hDC); <br> <br>                    // Clean up <br> <br>                    if (ghpalOld) <br>                       SelectPalette(hDC, ghpalOld, FALSE); <br> <br>                    ReleaseDC(hWnd, hDC); <br>                } <br>            } <br>            break; <br>        } <br> <br> <br> <br>    case WM_SIZE: <br>        { <br> <br> resizeCB(hWnd, NULL, NULL); <br> <br>        } <br>        break; <br> <br>    case WM_COMMAND: <br>        /* handle all command messages in a localized function */ <br>         lRet = CommandHandler (hWnd, uParam, lParam); <br>        break; <br> <br>    case WM_LBUTTONDOWN: <br>{ <br>GLwDrawingAreaCallbackStruct *call_data; <br> <br>call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct)); <br>call_data-&gt;event = (XEvent *) LocalAlloc(0, sizeof(XEvent)); <br> <br>call_data-&gt;event-&gt;type = ButtonPress; <br>call_data-&gt;event-&gt;xbutton.button = Button1; <br>call_data-&gt;event-&gt;xbutton.x = LOWORD(lParam); <br>call_data-&gt;event-&gt;xbutton.y = HIWORD(lParam); <br> <br>inputCB(hWnd, NULL, (LPVOID)call_data); <br>LocalFree(call_data-&gt;event); <br>LocalFree(call_data); <br>} <br>break; <br> <br>    case WM_RBUTTONDOWN: <br>{ <br>GLwDrawingAreaCallbackStruct *call_data; <br> <br>call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct)); <br>call_data-&gt;event = (XEvent *) LocalAlloc(0, sizeof(XEvent)); <br> <br>call_data-&gt;event-&gt;type = ButtonPress; <br>call_data-&gt;event-&gt;xbutton.button = Button2; <br>call_data-&gt;event-&gt;xbutton.x = LOWORD(lParam); <br>call_data-&gt;event-&gt;xbutton.y = HIWORD(lParam); <br> <br>inputCB(hWnd, NULL, (LPVOID)call_data); <br>LocalFree(call_data-&gt;event); <br>LocalFree(call_data); <br>} <br>break; <br> <br>    case WM_LBUTTONUP: <br>{ <br>GLwDrawingAreaCallbackStruct *call_data; <br> <br>call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct)); <br>call_data-&gt;event = (XEvent *) LocalAlloc(0, sizeof(XEvent)); <br> <br>call_data-&gt;event-&gt;type = ButtonRelease; <br>call_data-&gt;event-&gt;xbutton.button = Button1; <br> <br>inputCB(hWnd, NULL, (LPVOID)call_data); <br>LocalFree(call_data-&gt;event); <br>LocalFree(call_data); <br>} <br>break; <br> <br>    case WM_RBUTTONUP: <br>{ <br>GLwDrawingAreaCallbackStruct *call_data; <br> <br>call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct)); <br>call_data-&gt;event = (XEvent *) LocalAlloc(0, sizeof(XEvent)); <br> <br>call_data-&gt;event-&gt;type = ButtonRelease; <br>call_data-&gt;event-&gt;xbutton.button = Button2; <br> <br>inputCB(hWnd, NULL, (LPVOID)call_data); <br>LocalFree(call_data-&gt;event); <br>LocalFree(call_data); <br>} <br>break; <br> <br>    case WM_MOUSEMOVE: <br>{ <br>GLwDrawingAreaCallbackStruct *call_data; <br> <br>call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct)); <br>call_data-&gt;event = (XEvent *) LocalAlloc(0, sizeof(XEvent)); <br> <br>call_data-&gt;event-&gt;type = MotionNotify; <br>call_data-&gt;event-&gt;xmotion.x = LOWORD(lParam); <br>call_data-&gt;event-&gt;xmotion.y = HIWORD(lParam); <br> <br>inputCB(hWnd, NULL, (LPVOID)call_data); <br>LocalFree(call_data-&gt;event); <br>LocalFree(call_data); <br>} <br>break; <br> <br>    case WM_CLOSE: <br>        { <br> <br>HGLRC hRC; <br> <br>if(hRC = wglGetCurrentContext()) <br>    wglDeleteContext(hRC); <br> <br>//KillTimer(iTimer); <br> <br>        /* call destroy window to cleanup and go away */ <br>        DestroyWindow (hWnd); <br>        } <br>        break; <br> <br>    case WM_DESTROY: <br>        { <br>wglDeleteContext(wglGetCurrentContext()); <br>        PostQuitMessage (0); <br>        } <br>        break; <br> <br>    default: <br>        /* pass all unhandled messages to DefWindowProc */ <br>        lRet = DefWindowProc (hWnd, uMsg, uParam, lParam); <br>        break; <br>    } <br> <br>    /* return 1 if handled message, 0 if not */ <br>    return lRet; <br>} <br> <br> <br>/* handle all WM_COMMAND messages here */ <br>LONG WINAPI CommandHandler ( <br>    HWND    hWnd, <br>    UINT    uParam, <br>    LONG    lParam) <br>{ <br>    int    i; <br>    HMENU   hMenu; <br> <br>    switch (LOWORD(uParam)) <br>    { <br>    case IDM_EXIT: <br>        /* exit application */ <br>        PostMessage (hWnd, WM_CLOSE, 0, 0L); <br>        break; <br> <br>    case IDM_LIGHTING: <br>hMenu = GetMenu(hWnd); <br>use_lighting = !use_lighting; <br>CheckMenuItem(hMenu,IDM_LIGHTING,(use_lighting?MF_CHECKED:MF_UNCHECKED)); <br>break; <br> <br>    case IDM_SHADOWS: <br>hMenu = GetMenu(hWnd); <br>draw_shadows = !draw_shadows; <br>CheckMenuItem(hMenu,IDM_SHADOWS,(draw_shadows?MF_CHECKED:MF_UNCHECKED)); <br>break; <br> <br>    case IDM_FOG: <br>hMenu = GetMenu(hWnd); <br>use_normal_fog = !use_normal_fog; <br>CheckMenuItem(hMenu,IDM_FOG,(use_normal_fog?MF_CHECKED:MF_UNCHECKED)); <br>break; <br> <br>#ifdef TEXTURE <br>    case IDM_TEXTUREMAP: <br>hMenu = GetMenu(hWnd); <br>/* HACK HACK HACK <br> * This would be right, but for now I only want to map the stones, nothing <br> * else, so I have a new variable - texture_hack <br>  <br>use_textures = !use_textures; <br>CheckMenuItem(hMenu,IDM_TEXTUREMAP,(use_textures?MF_CHECKED:MF_UNCHECKED)); <br> */ <br>texture_hack = !texture_hack; <br>CheckMenuItem(hMenu,IDM_TEXTUREMAP,(texture_hack?MF_CHECKED:MF_UNCHECKED)); <br>break; <br>#endif <br> <br>    case IDM_TELESCOPE: <br>hMenu = GetMenu(hWnd); <br>use_telescope = !use_telescope; <br>CheckMenuItem(hMenu,IDM_TELESCOPE,(use_telescope?MF_CHECKED:MF_UNCHECKED)); <br>break; <br> <br>    case IDM_ANTIALIAS: <br>hMenu = GetMenu(hWnd); <br>use_antialias = !use_antialias; <br>CheckMenuItem(hMenu,IDM_ANTIALIAS,(use_antialias?MF_CHECKED:MF_UNCHECKED)); <br>break; <br> <br>    case IDM_CLEAR: <br>    case IDM_FOGGY: <br>    case IDM_VERYFOGGY: <br>    case IDM_RAINY: <br>hMenu = GetMenu(hWnd); <br>/* If this value is already checked, we do nothing */ <br>if(curr_weather != (LOWORD(uParam) - IDM_CLEAR)) <br>{ <br>    CheckMenuItem(hMenu, curr_weather + IDM_CLEAR, MF_UNCHECKED); <br> <br>    CheckMenuItem(hMenu, LOWORD(uParam), MF_CHECKED); <br>    curr_weather = LOWORD(uParam) - IDM_CLEAR; <br>    scene_set_weather(weathers[curr_weather]); <br>} <br> <br>break; <br> <br>    case IDM_CURRENTTIME: <br>currentTimeCB(hWnd); <br>        checkTimeMenuItem(GetMenu(hWnd), LOWORD(uParam)); <br>break; <br> <br>    case IDM_10AM: <br>time10amCB(hWnd); <br>        checkTimeMenuItem(GetMenu(hWnd), LOWORD(uParam)); <br>break; <br> <br>    case IDM_NOON: <br>time12pmCB(hWnd); <br>        checkTimeMenuItem(GetMenu(hWnd), LOWORD(uParam)); <br>break; <br> <br>    case IDM_4PM: <br>time4pmCB(hWnd); <br>        checkTimeMenuItem(GetMenu(hWnd), LOWORD(uParam)); <br>break; <br> <br>    case IDM_HOLDTIME: <br>    case IDM_SCALE1: <br>    case IDM_SCALE10: <br>    case IDM_SCALE100: <br>    case IDM_SCALE500: <br>hMenu = GetMenu(hWnd); <br>/* If this value is already checked, we do nothing */ <br>if(!bTimeScale[LOWORD(uParam) - IDM_HOLDTIME]) <br>{ <br>    for(i=0;!bTimeScale[i];i++); <br> <br>    time_scale = TimeScale[LOWORD(uParam) - IDM_HOLDTIME]; <br> <br>    CheckMenuItem(hMenu, IDM_HOLDTIME + i, MF_UNCHECKED); <br>    bTimeScale[i] = FALSE; <br> <br>    CheckMenuItem(hMenu, LOWORD(uParam), MF_CHECKED); <br>    bTimeScale[LOWORD(uParam) - IDM_HOLDTIME] = TRUE; <br> <br>    timeSpeedCB(hWnd, NULL, NULL); <br>} <br>break; <br> <br>    case IDM_DEMOMODE: <br>hMenu = GetMenu(hWnd); <br> <br>cb_demo_mode = !cb_demo_mode; <br>CheckMenuItem(hMenu,IDM_DEMOMODE,(cb_demo_mode?MF_CHECKED:MF_UNCHECKED)); <br>demo_modeCB(hWnd, NULL, NULL); <br>break; <br> <br>    case IDM_RESET: <br>resetViewerCB(hWnd, NULL, NULL); <br>break; <br> <br>    default: <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>VOID WINAPI InitializeMenu (HWND hWnd, HMENU hMenu) <br>{ <br> <br>    curr_weather = def_weather_index; <br> <br>    CheckMenuItem(hMenu, IDM_CLEAR + curr_weather, MF_CHECKED); <br> <br>    CheckMenuItem(hMenu, IDM_LIGHTING, MF_CHECKED); <br> <br>    bTimeScale[0] = TRUE; <br>    bTimeScale[1] = FALSE; <br>    bTimeScale[2] = FALSE; <br>    bTimeScale[3] = FALSE; <br>    bTimeScale[4] = FALSE; <br> <br>    CheckMenuItem(hMenu, IDM_4PM, MF_CHECKED); <br> <br>    CheckMenuItem(hMenu, IDM_HOLDTIME, MF_CHECKED); <br> <br>    cb_demo_mode = FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
