<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRACKBAL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3608"></a>TRACKBAL.H</h2>
<pre><code>/* <br> * trackball.h <br> * A virtual trackball implementation <br> * Written by Gavin Bell for Silicon Graphics, November 1988. <br> */ <br> <br>/* <br> * Initialize trackball in win32 environment <br> */ <br>extern void <br>trackball_Init( GLint width, GLint height ); <br> <br>extern void <br>trackball_Resize( GLint width, GLint height ); <br> <br>extern GLenum  <br>trackball_MouseDown( AUX_EVENTREC *event ); <br> <br>extern GLenum  <br>trackball_MouseUp( AUX_EVENTREC *event ); <br> <br>/* These next Mouse fns are required if both the trackbal and user <br> * need mouse events.  Otherwise, can just supply above two functions <br> * to tk to call <br> */ <br> <br>/* <br> * Mouse functions called directly on events <br> */ <br>extern void <br>trackball_MouseDownEvent( int mouseX, int mouseY, GLenum button ); <br> <br>extern void <br>trackball_MouseUpEvent( int mouseX, int mouseY, GLenum button ); <br> <br>/* <br> * Functions to register mouse event callbacks <br> */ <br>extern void  <br>trackball_MouseDownFunc(GLenum (*)(int, int, GLenum)); <br> <br>extern void  <br>trackball_MouseUpFunc(GLenum (*)(int, int, GLenum)); <br> <br>/* <br> * Calculate rotation matrix based on mouse movement <br> */ <br>void <br>trackball_CalcRotMatrix( GLfloat matRot[4][4] ); <br> <br>/* <br> * Pass the x and y coordinates of the last and current positions of <br> * the mouse, scaled so they are from (-1.0 ... 1.0). <br> * <br> * if ox,oy is the window's center and sizex,sizey is its size, then <br> * the proper transformation from screen coordinates (sc) to world <br> * coordinates (wc) is: <br> * wcx = (2.0 * (scx-ox)) / (float)sizex - 1.0 <br> * wcy = (2.0 * (scy-oy)) / (float)sizey - 1.0 <br> * <br> * The resulting rotation is returned as a quaternion rotation in the <br> * first paramater. <br> */ <br>void <br>trackball_calc_quat(float q[4], float p1x, float p1y, float p2x, float p2y); <br> <br>/* <br> * Given two quaternions, add them together to get a third quaternion. <br> * Adding quaternions to get a compound rotation is analagous to adding <br> * translations to get a compound translation.  When incrementally <br> * adding rotations, the first argument here should be the new <br> * rotation, the second and third the total rotation (which will be <br> * over-written with the resulting new total rotation). <br> */ <br>void <br>trackball_add_quats(float *q1, float *q2, float *dest); <br> <br>/* <br> * A useful function, builds a rotation matrix in Matrix based on <br> * given quaternion. <br> */ <br>void <br>trackball_build_rotmatrix(float m[4][4], float q[4]); <br> <br>/* <br> * This function computes a quaternion based on an axis (defined by <br> * the given vector) and an angle about which to rotate.  The angle is <br> * expressed in radians.  The result is put into the third argument. <br> */ <br>void <br>trackball_axis_to_quat(float a[3], float phi, float q[4]); <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
