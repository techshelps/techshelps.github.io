<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CALLBACK.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3611"></a>CALLBACK.CXX</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#ifdef X11 <br>#include &lt;X11/Intrinsic.h&gt; <br>#include &lt;X11/keysym.h&gt; <br>#include &lt;Xm/Xm.h&gt; <br> <br>#include &lt;GL/glx.h&gt; <br>#include &lt;GLwMDrawA.h&gt; <br>#endif <br> <br>#include &lt;GL/glu.h&gt; <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#ifdef X11 <br>#include &lt;sys/time.h&gt; <br>#else <br>#include &lt;time.h&gt; <br>#endif <br> <br>#ifdef WIN32 <br>#include "stonehen.h" <br>#endif <br> <br>#include "atmosphe.h" <br>#include "scene.h" <br> <br>#include "callback.h" <br> <br>int cb_demo_mode = 0; <br>float demo_time; <br> <br>#ifdef X11 <br>extern Widget glw; <br>extern XtAppContext app_context; <br>GLXContext glx_context; <br>#endif <br> <br>static int needs_wp = 0; <br>#ifdef X11 <br>static XtWorkProcId workproc = NULL; <br>#else <br>static int workproc = 0; <br>#endif <br> <br>static int winx, winy; <br> <br>static int button_down = 0; <br>int mousex, mousey; <br>/* What's moving */ <br>GLint target; <br> <br>/* Location of the telescope */ <br>GLfloat tx, ty; <br> <br>/* Movements of the camera position to be applied at the next redraw */ <br>float rot_pendx = 0, rot_pendz = 0, trans_pend = 0; <br> <br>/* How fast the camera is moving */ <br>float trans_speed = 0; <br> <br>/* This is how fast demo time moves relative to real time */ <br>GLfloat time_scale = 0; <br> <br>TimeDate last_update; <br> <br>float last_time = 0; <br>const float time_fudge = 1000; <br>inline unsigned long current_time() <br>{ <br>#ifdef X11 <br>  struct timeval time; <br>  gettimeofday(&amp;time, NULL); <br>  return (time.tv_sec * 1000000 + time.tv_usec); <br>#else <br>  return (GetTickCount() * 1000); <br>#endif <br>} <br> <br>inline float clamp(float x, float min, float max) <br>{ <br>  if (x &lt; min) return min; <br>  else if (x &gt; max) return max; <br>  else return x; <br>} <br> <br>static void add_workproc(Widget w) <br>{ <br>  needs_wp++; <br>#ifdef X11 <br>  if (workproc == NULL) <br>    workproc = XtAppAddWorkProc(app_context, drawWP, NULL); <br>#endif <br>} <br> <br>static void remove_workproc(Widget w) <br>{ <br>  needs_wp--; <br>  if (needs_wp == 0) { <br>#ifdef X11 <br>    XtRemoveWorkProc(workproc); <br>    workproc = NULL; <br>#else <br>    workproc = 0; <br>#endif <br>  } else if (needs_wp &lt; 0) { <br>    //fprintf(stderr, "Internal Error:  No workproc to remove!\n"); <br>    needs_wp = 0; <br>    workproc = NULL; <br>  } <br>} <br> <br>static void reset_viewer() <br>{ <br>  scene_viewer_center(); <br>} <br> <br>#ifdef X11 <br>void intToggleCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>  int *data; <br>  XmToggleButtonCallbackStruct *ptr; <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  data = (int *)client_data; <br>  *data = ptr-&gt;set; <br>  // This redraw may or may not be needed - do it to be safe <br>  drawWP(NULL); <br>} <br> <br> <br>void initCB(Widget w) <br>{ <br>  Arg args[1]; <br>  XVisualInfo *vi; <br> <br>  glw = w; <br> <br>  XtSetArg(args[0], GLwNvisualInfo, &amp;vi); <br>  XtGetValues(w, args, 1); <br>  <br>  glx_context = glXCreateContext(XtDisplay(w), vi, 0, GL_FALSE); <br>  GLwDrawingAreaMakeCurrent(w, glx_context); <br> <br>  scene_init(); <br> <br>  last_update.read_time(); <br> <br>  resetViewerCB(NULL, NULL, NULL); <br>} <br> <br>void exposeCB(Widget w) <br>{ <br>  drawWP(NULL); <br>} <br>#endif <br> <br>void resizeCB(Widget w, XtPointer client_data, XtPointer call) <br>{ <br>#ifdef X11 <br>  GLwDrawingAreaCallbackStruct *call_data; <br> <br>  GLwDrawingAreaMakeCurrent(w, glx_context); <br> <br>  call_data = (GLwDrawingAreaCallbackStruct *)call; <br> <br>  winx = call_data-&gt;width; <br>  winy = call_data-&gt;height; <br>#else <br>  RECT rect; <br>  GetClientRect(w, &amp;rect); <br> <br>  winx = WINDSIZEX(rect); <br>  winy = WINDSIZEY(rect); <br>#endif <br>   <br>  glViewport(0, 0, winx, winy); <br>   <br>  aspect = (GLfloat)winx / (GLfloat)winy; <br>} <br> <br>void inputCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>  GLwDrawingAreaCallbackStruct *call; <br> <br>  int bufsize = 5; <br>#ifdef X11 <br>  char buffer[5]; <br>  KeySym key; <br>  XComposeStatus compose; <br>#endif <br> <br>  float dx, dy, r1, r2; <br> <br>#ifdef X11 <br>  GLwDrawingAreaMakeCurrent(w, glx_context); <br>#endif <br> <br>  call = (GLwDrawingAreaCallbackStruct *)call_data; <br> <br>  switch(call-&gt;event-&gt;type) { <br>  case ButtonPress: <br>    last_time = current_time(); <br>    button_down = call-&gt;event-&gt;xbutton.button; <br>    mousex = call-&gt;event-&gt;xbutton.x; <br>    mousey = call-&gt;event-&gt;xbutton.y; <br>    /* Determine if the target should be the camera position  <br>     * or the telescope */ <br>    if (use_telescope) { <br>      scene_get_position_telescope(&amp;tx, &amp;ty); <br>      scene_get_radius_telescope(&amp;r1); <br>      dx = (tx + .5) - ((GLfloat)(winx - mousex)/(GLfloat)winx); <br>      dy = (ty + .5) - ((GLfloat)(winy - mousey)/(GLfloat)winy); <br>      r2 = sqrt(dx*dx + dy*dy); <br>      if (r2 &lt; r1) target = name_telescope; <br>      else target = name_background; <br>    } else target = name_background; <br>    add_workproc(w); <br>    break; <br>  case ButtonRelease: <br>#ifdef X11 <br>    if (call-&gt;event-&gt;xbutton.button == Button3) { <br>      /* Use Button3 to stop */ <br>      if (trans_speed) remove_workproc(w); <br>      trans_speed = 0; <br>    } <br>#endif <br>    remove_workproc(w); <br>    button_down = 0; <br>    break; <br>  case MotionNotify: <br>    switch(button_down) { <br>    case Button1: <br>      /* Use Button1 to control the way in which the viewer is looking  <br>       * or to move the telescope around */ <br>      if (target == name_background) { <br>dx = (float)(call-&gt;event-&gt;xmotion.x - mousex) / (float)winx; <br>dy = (float)(call-&gt;event-&gt;xmotion.y - mousey) / (float)winy; <br>rot_pendx -= dy * fov; <br>rot_pendz -= dx * fov; <br>      } else { <br>dx = (float)(mousex - call-&gt;event-&gt;xmotion.x) / (float)winx; <br>dy = (float)(mousey - call-&gt;event-&gt;xmotion.y) / (float)winy; <br>tx += dx; <br>ty += dy; <br>tx = clamp(tx, -.5, .5); <br>ty = clamp(ty, -.5, .5); <br>scene_position_telescope(tx, ty); <br>      } <br>      break; <br>    case Button2: <br>      /* Use Button2 to change speed */ <br>      dx = (float)(mousex - call-&gt;event-&gt;xmotion.x) /  <br>(float)winx; <br>      if (dx &amp;&amp; !trans_speed) add_workproc(w); <br>#ifdef WIN32 <br>      else if (!dx &amp;&amp; trans_speed) remove_workproc(w); <br>#endif <br>      trans_speed += dx; <br>      break; <br>    } <br>    mousex = call-&gt;event-&gt;xmotion.x; <br>    mousey = call-&gt;event-&gt;xmotion.y; <br>    break; <br> <br>#ifdef X11 // We can handle our own keys... <br>  case KeyPress: <br>    XLookupString(&amp;(call-&gt;event-&gt;xkey), buffer, bufsize, &amp;key, &amp;compose); <br>    if (key == XK_Escape) exit(0); <br>    break;                             <br>#endif <br> <br>  default: <br>    break; <br>  } <br>} <br> <br>const float speed_t = .5; <br>const float speed_r = 15.; <br>const float speed_rx = 10.; <br>void demo_mode_update(float dt) <br>{ <br>  float t; <br>   <br>  if (!cb_demo_mode) return; <br>   <br>  dt /= 1000000; <br>  demo_time += dt; <br>   <br>  t = demo_time; <br>   <br>  if (t &lt; 10.5) { <br>    trans_speed = speed_t; <br>    return; <br>  } else t -= 10.5; <br>   <br>  if (t &lt; 1) { <br>    trans_speed = 0; <br>    rot_pendz = 0; <br>    return; <br>  } else t -= 1; <br>   <br>  if (t &lt; 3.) { <br>    trans_speed = 0.; <br>    rot_pendz = dt * speed_r; <br>    return; <br>  } else t -= 3.; <br>   <br>  if (t &lt; 2.) { <br>    rot_pendx = -dt * speed_rx; <br>    return; <br>  } else t -= 2.; <br> <br>  if (t &lt; 2.) { <br>    return; <br>  } else t -= 2.; <br> <br>  if (t &lt; 2.) { <br>    rot_pendx = dt * speed_rx; <br>    return; <br>  } else t -= 2.; <br>   <br> <br>  if (t &lt; 3.) { <br>    trans_speed = 0.; <br>    rot_pendz = dt * speed_r; <br>    return; <br>  } else t -= 3.; <br> <br>  if (t &lt; 30.) { <br>    trans_speed  = speed_t; <br>    rot_pendz = 0; <br>    return; <br>  } else t -= 30.; <br>   <br>  if (t &lt; 1.) { <br>    trans_speed = 0; <br>    return; <br>  } else t -= 1.; <br> <br>  if (t &lt; 1.3) { <br>    rot_pendz = -dt * speed_r; <br>    return; <br>  } else t -= 1.3; <br> <br>  // Pan back to see entire thing <br>  if (t &lt; 23) { <br>    trans_speed = speed_t; <br>    return; <br>  } else t -= 23; <br> <br>  // Hold before starting over <br>  if (t &lt; 20) { <br>    trans_speed = 0; <br>    return; <br>  } <br>  else t -= 20; <br> <br>  demo_time = 0.; <br>  reset_viewer(); <br>} <br> <br>Boolean drawWP(Widget w) <br>{ <br>  /* Right now, there's two completely independent time measurements: <br>   * one for the time of day in the demo and one for changing the camera <br>   * position */ <br>  TimeDate t, dt; <br>  float elapsed_time, time; <br>#ifdef WIN32 <br>  HDC hDC; <br>#endif <br> <br>  if (time_scale != 0.0) { <br>    t.read_time(); <br>    dt = (t - last_update) * time_scale; <br>    scene_inc_time(dt); <br>    last_update = t; <br>  } <br> <br>  time = current_time(); <br>  if (time - last_time &gt; time_fudge) { <br>    elapsed_time = time - last_time; <br>    demo_mode_update(elapsed_time); <br>    trans_pend = trans_speed * (elapsed_time / 1000000); <br>    last_time = time; <br>  } <br> <br>  scene_viewer_rotatex(rot_pendx); <br>  scene_viewer_rotatez(rot_pendz); <br>  scene_viewer_translate(trans_pend); <br>  rot_pendx = 0; <br>  rot_pendz = 0; <br>  trans_pend = 0; <br> <br>#ifdef X11 <br>  GLwDrawingAreaMakeCurrent(glw, glx_context); <br>  scene_render(); <br>  /* This is a total hack */ <br>//  if (!use_antialias) <br>GLwDrawingAreaSwapBuffers(glw); <br>#else <br>  hDC = GetDC(w); <br>  scene_render(); <br>  SwapBuffers(hDC); <br>  ReleaseDC(w, hDC); <br>#endif   <br> <br>  return FALSE; <br>} <br> <br>#ifdef X11 <br>void weatherCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>  Weather *data; <br>  XmToggleButtonCallbackStruct *ptr; <br>  ptr = (XmToggleButtonCallbackStruct *)call_data; <br>  if (ptr-&gt;set) scene_set_weather(*((Weather *)client_data)); <br>  drawWP(NULL); <br>} <br>#endif <br> <br>void checkTimeMenuItem(HMENU hmenu, UINT idCheckItem) <br>{ <br>    CheckMenuItem(hmenu, IDM_CURRENTTIME, MF_UNCHECKED); <br>    CheckMenuItem(hmenu, IDM_10AM, MF_UNCHECKED); <br>    CheckMenuItem(hmenu, IDM_NOON, MF_UNCHECKED); <br>    CheckMenuItem(hmenu, IDM_4PM, MF_UNCHECKED); <br>    CheckMenuItem(hmenu, idCheckItem, MF_CHECKED); <br>} <br> <br>void currentTimeCB(Widget w) <br>{ <br>  scene_set_time(TimeDate().read_time()); <br>  drawWP(w); <br>} <br> <br>void time10amCB(Widget w) <br>{ <br>  scene_set_time(TimeDate(10, 0)); <br>  drawWP(w); <br>} <br> <br>void time12pmCB(Widget w) <br>{ <br>  scene_set_time(TimeDate(12, 0)); <br>  drawWP(w); <br>} <br> <br>void time4pmCB(Widget w) <br>{ <br>  scene_set_time(TimeDate(16, 0)); <br>  drawWP(w); <br>} <br> <br>void timeSpeedCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>   <br>#ifdef X11 <br>  if (!((XmToggleButtonCallbackStruct *)call_data)-&gt;set) return; <br>  time_scale = (int)client_data; <br>#endif <br>  if (time_scale == 0.0) remove_workproc(w); <br>  else add_workproc(w); <br>  last_update.read_time(); <br>} <br> <br>void demo_modeCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>#ifdef X11 <br>  int val  = ((XmToggleButtonCallbackStruct *)call_data)-&gt;set; <br>#else <br>  int val = cb_demo_mode; <br>#endif <br>  if (!val) { <br>    remove_workproc(w); <br>    resetViewerCB(w, NULL, NULL); <br>    last_time = current_time(); <br>  } else { <br>    reset_viewer(); <br>    add_workproc(w); <br>    trans_speed = 0; <br>    demo_time = 0; <br>    rot_pendx = -5; <br>  } <br>  drawWP(w); <br>} <br> <br>void resetViewerCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>  trans_speed = 0; <br>  rot_pendx = rot_pendz = trans_pend = 0; <br>  rot_pendx = -5; <br>  reset_viewer(); <br>  return; <br>} <br>      <br> <br>void exitCB(Widget w, XtPointer client_data, XtPointer call_data) <br>{ <br>  exit(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
