<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3648"></a>TK.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> * ALL RIGHTS RESERVED <br> * Permission to use, copy, modify, and distribute this software for <br> * any purpose and without fee is hereby granted, provided that the above <br> * copyright notice appear in all copies and that both the copyright notice <br> * and this permission notice appear in supporting documentation, and that <br> * the name of Silicon Graphics, Inc. not be used in advertising <br> * or publicity pertaining to distribution of the software without specific, <br> * written prior permission. <br> * <br> * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS" <br> * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, <br> * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR <br> * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON <br> * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT, <br> * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY <br> * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION, <br> * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF <br> * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN <br> * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON <br> * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE <br> * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE. <br> * <br> * US Government Users Restricted Rights <br> * Use, duplication, or disclosure by the Government is subject to <br> * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph <br> * (c)(1)(ii) of the Rights in Technical Data and Computer Software <br> * clause at DFARS 252.227-7013 and/or in similar or successor <br> * clauses in the FAR or the DOD or NASA FAR Supplement. <br> * Unpublished-- rights reserved under the copyright laws of the <br> * United States.  Contractor/manufacturer is Silicon Graphics, <br> * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311. <br> * <br> * OpenGL(TM) is a trademark of Silicon Graphics, Inc. <br> */ <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include "tk.h" <br>#include "windows.h" <br> <br>#if(WINVER &lt; 0x0400) <br>// Ordinarily not defined for versions before 4.00. <br>#define COLOR_3DDKSHADOW        21 <br>#define COLOR_3DLIGHT           22 <br>#define COLOR_INFOTEXT          23 <br>#define COLOR_INFOBK            24 <br>#endif <br> <br>#define static <br> <br>#if defined(__cplusplus) || defined(c_plusplus) <br>#define class c_class <br>#endif <br> <br>#if DBG <br>#define TKASSERT(x)                                     \ <br>if ( !(x) ) {                                           \ <br>    PrintMessage("%s(%d) Assertion failed %s\n",        \ <br>        __FILE__, __LINE__, #x);                        \ <br>} <br>#else <br>#define TKASSERT(x) <br>#endif  /* DBG */ <br> <br>/******************************************************************************/ <br> <br>static struct _WINDOWINFO { <br>    int x, y; <br>    int width, height; <br>    GLenum type; <br>    GLenum dmPolicy; <br>    int ipfd; <br>    BOOL bDefPos; <br>} windInfo = { <br>    0, 0, 100, 100, TK_INDEX | TK_SINGLE, TK_MINIMUM_CRITERIA, 0, TRUE <br>}; <br> <br> <br>static HWND     tkhwnd     = NULL; <br>static HDC      tkhdc      = NULL; <br>static HGLRC    tkhrc      = NULL; <br>static HPALETTE tkhpalette = NULL; <br>static OSVERSIONINFO tkOSVerInfo; <br>GLboolean tkPopupEnable = TRUE; <br> <br>// Fixed palette support. <br> <br>#define BLACK   PALETTERGB(0,0,0) <br>#define WHITE   PALETTERGB(255,255,255) <br>#define MAX_STATIC_COLORS   (COLOR_INFOBK - COLOR_SCROLLBAR + 1) <br>static int tkNumStaticColors = MAX_STATIC_COLORS; <br> <br>// TRUE if app wants to take over palette <br>static BOOL tkUseStaticColors = FALSE; <br> <br>// TRUE if static system color settings have been replaced with B&amp;W settings. <br>static BOOL tkSystemColorsInUse = FALSE; <br> <br>// TRUE if original static colors saved <br>static BOOL tkStaticColorsSaved = FALSE; <br> <br>// saved system static colors (initialize with default colors) <br>static COLORREF gacrSave[MAX_STATIC_COLORS]; <br> <br>// new B&amp;W system static colors <br>static COLORREF gacrBlackAndWhite[] = { <br>    WHITE,  // COLOR_SCROLLBAR <br>    BLACK,  // COLOR_BACKGROUND <br>    BLACK,  // COLOR_ACTIVECAPTION <br>    WHITE,  // COLOR_INACTIVECAPTION <br>    WHITE,  // COLOR_MENU <br>    WHITE,  // COLOR_WINDOW <br>    BLACK,  // COLOR_WINDOWFRAME <br>    BLACK,  // COLOR_MENUTEXT <br>    BLACK,  // COLOR_WINDOWTEXT <br>    WHITE,  // COLOR_CAPTIONTEXT <br>    WHITE,  // COLOR_ACTIVEBORDER <br>    WHITE,  // COLOR_INACTIVEBORDER <br>    WHITE,  // COLOR_APPWORKSPACE <br>    BLACK,  // COLOR_HIGHLIGHT <br>    WHITE,  // COLOR_HIGHLIGHTTEXT <br>    WHITE,  // COLOR_BTNFACE <br>    BLACK,  // COLOR_BTNSHADOW <br>    BLACK,  // COLOR_GRAYTEXT <br>    BLACK,  // COLOR_BTNTEXT <br>    BLACK,  // COLOR_INACTIVECAPTIONTEXT <br>    BLACK,  // COLOR_BTNHIGHLIGHT <br>    BLACK,  // COLOR_3DDKSHADOW <br>    WHITE,  // COLOR_3DLIGHT <br>    BLACK,  // COLOR_INFOTEXT <br>    WHITE   // COLOR_INFOBK <br>    }; <br>static INT gaiStaticIndex[] = { <br>    COLOR_SCROLLBAR          , <br>    COLOR_BACKGROUND         , <br>    COLOR_ACTIVECAPTION      , <br>    COLOR_INACTIVECAPTION    , <br>    COLOR_MENU               , <br>    COLOR_WINDOW             , <br>    COLOR_WINDOWFRAME        , <br>    COLOR_MENUTEXT           , <br>    COLOR_WINDOWTEXT         , <br>    COLOR_CAPTIONTEXT        , <br>    COLOR_ACTIVEBORDER       , <br>    COLOR_INACTIVEBORDER     , <br>    COLOR_APPWORKSPACE       , <br>    COLOR_HIGHLIGHT          , <br>    COLOR_HIGHLIGHTTEXT      , <br>    COLOR_BTNFACE            , <br>    COLOR_BTNSHADOW          , <br>    COLOR_GRAYTEXT           , <br>    COLOR_BTNTEXT            , <br>    COLOR_INACTIVECAPTIONTEXT, <br>    COLOR_BTNHIGHLIGHT       , <br>    COLOR_3DDKSHADOW         , <br>    COLOR_3DLIGHT            , <br>    COLOR_INFOTEXT           , <br>    COLOR_INFOBK <br>    }; <br> <br>static BOOL GrabStaticEntries(HDC); <br>static BOOL ReleaseStaticEntries(HDC); <br> <br>#define RESTORE_FROM_REGISTRY   1 <br>#if RESTORE_FROM_REGISTRY <br>// Registry names for the system colors. <br>CHAR *gaszSysClrNames[] = { <br>    "Scrollbar",      // COLOR_SCROLLBAR              0 <br>    "Background",     // COLOR_BACKGROUND             1   (also COLOR_DESKTOP) <br>    "ActiveTitle",    // COLOR_ACTIVECAPTION          2 <br>    "InactiveTitle",  // COLOR_INACTIVECAPTION        3 <br>    "Menu",           // COLOR_MENU                   4 <br>    "Window",         // COLOR_WINDOW                 5 <br>    "WindowFrame",    // COLOR_WINDOWFRAME            6 <br>    "MenuText",       // COLOR_MENUTEXT               7 <br>    "WindowText",     // COLOR_WINDOWTEXT             8 <br>    "TitleText",      // COLOR_CAPTIONTEXT            9 <br>    "ActiveBorder",   // COLOR_ACTIVEBORDER          10 <br>    "InactiveBorder", // COLOR_INACTIVEBORDER        11 <br>    "AppWorkspace",   // COLOR_APPWORKSPACE          12 <br>    "Hilight",        // COLOR_HIGHLIGHT             13 <br>    "HilightText",    // COLOR_HIGHLIGHTTEXT         14 <br>    "ButtonFace",     // COLOR_BTNFACE               15   (also COLOR_3DFACE) <br>    "ButtonShadow",   // COLOR_BTNSHADOW             16   (also COLOR_3DSHADOW) <br>    "GrayText",       // COLOR_GRAYTEXT              17 <br>    "ButtonText",     // COLOR_BTNTEXT               18 <br>    "InactiveTitleText", // COLOR_INACTIVECAPTIONTEXT   19 <br>    "ButtonHilight",  // COLOR_BTNHIGHLIGHT          20   (also COLOR_3DHILIGHT) <br>    "ButtonDkShadow", // COLOR_3DDKSHADOW            21 <br>    "ButtonLight",    // COLOR_3DLIGHT               22 <br>    "InfoText",       // COLOR_INFOTEXT              23 <br>    "InfoWindow"      // COLOR_INFOBK                24 <br>}; <br> <br>static BOOL GetRegistrySysColors(COLORREF *, int); <br>#endif <br> <br>static void (*ExposeFunc)(int, int)              = NULL; <br>static void (*ReshapeFunc)(GLsizei, GLsizei)     = NULL; <br>static void (*DisplayFunc)(void)                 = NULL; <br>static GLenum (*KeyDownFunc)(int, GLenum)        = NULL; <br>static GLenum (*MouseDownFunc)(int, int, GLenum) = NULL; <br>static GLenum (*MouseUpFunc)(int, int, GLenum)   = NULL; <br>static GLenum (*MouseMoveFunc)(int, int, GLenum) = NULL; <br>static void (*IdleFunc)(void)                    = NULL; <br> <br>static char     *lpszClassName = "tkLibWClass"; <br>static WCHAR    *lpszClassNameW = L"tkLibWClass"; <br> <br>static long tkWndProc(HWND hWnd, UINT message, DWORD wParam, LONG lParam); <br>static unsigned char ComponentFromIndex(int i, int nbits, int shift ); <br>static void PrintMessage( const char *Format, ... ); <br>static PALETTEENTRY *FillRgbPaletteEntries( PIXELFORMATDESCRIPTOR *Pfd, PALETTEENTRY *Entries, UINT Count ); <br>static HPALETTE CreateCIPalette( HDC Dc ); <br>static HPALETTE CreateRGBPalette( HDC hdc ); <br>static void DestroyThisWindow( HWND Window ); <br>static void CleanUp( void ); <br>static void DelayPaletteRealization( void ); <br>static long RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground ); <br>static void ForceRedraw( HWND Window ); <br>static BOOL FindPixelFormat(HDC hdc, GLenum type); <br>static int FindBestPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd); <br>static int FindExactPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd); <br>static BOOL IsPixelFormatValid(HDC hdc, int ipfd, PIXELFORMATDESCRIPTOR *ppfd); <br>static int PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd ); <br>static void *AllocateMemory( size_t Size ); <br>static void *AllocateZeroedMemory( size_t Size ); <br>static void FreeMemory( void *Chunk ); <br> <br>/* <br> *  Prototypes for the debugging functions go here <br> */ <br> <br>#define DBGFUNC 0 <br>#if DBGFUNC <br> <br>static void DbgPrintf( const char *Format, ... ); <br>static void pwi( void ); <br>static void pwr(RECT *pr); <br>static void ShowPixelFormat(HDC hdc); <br> <br>#endif <br> <br>static float colorMaps[] = { <br>    0.000000F, 1.000000F, 0.000000F, 1.000000F, 0.000000F, 1.000000F, <br>    0.000000F, 1.000000F, 0.333333F, 0.776471F, 0.443137F, 0.556863F, <br>    0.443137F, 0.556863F, 0.219608F, 0.666667F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.039216F, 0.078431F, 0.117647F, 0.156863F, <br>    0.200000F, 0.239216F, 0.278431F, 0.317647F, 0.356863F, 0.400000F, <br>    0.439216F, 0.478431F, 0.517647F, 0.556863F, 0.600000F, 0.639216F, <br>    0.678431F, 0.717647F, 0.756863F, 0.800000F, 0.839216F, 0.878431F, <br>    0.917647F, 0.956863F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.000000F, 0.000000F, <br>    1.000000F, 1.000000F, 0.000000F, 0.000000F, 1.000000F, 1.000000F, <br>    0.333333F, 0.443137F, 0.776471F, 0.556863F, 0.443137F, 0.219608F, <br>    0.556863F, 0.666667F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.039216F, 0.078431F, 0.117647F, 0.156863F, 0.200000F, 0.239216F, <br>    0.278431F, 0.317647F, 0.356863F, 0.400000F, 0.439216F, 0.478431F, <br>    0.517647F, 0.556863F, 0.600000F, 0.639216F, 0.678431F, 0.717647F, <br>    0.756863F, 0.800000F, 0.839216F, 0.878431F, 0.917647F, 0.956863F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.141176F, 0.282353F, 0.427451F, <br>    0.568627F, 0.713726F, 0.854902F, 1.000000F, 0.000000F, 0.141176F, <br>    0.282353F, 0.427451F, 0.568627F, 0.713726F, 0.854902F, 1.000000F, <br>    0.000000F, 0.141176F, 0.282353F, 0.427451F, 0.568627F, 0.713726F, <br>    0.854902F, 1.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 0.333333F, 0.443137F, <br>    0.443137F, 0.219608F, 0.776471F, 0.556863F, 0.556863F, 0.666667F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.666667F, 0.333333F, <br>    0.666667F, 0.333333F, 0.666667F, 0.333333F, 0.039216F, 0.078431F, <br>    0.117647F, 0.156863F, 0.200000F, 0.239216F, 0.278431F, 0.317647F, <br>    0.356863F, 0.400000F, 0.439216F, 0.478431F, 0.517647F, 0.556863F, <br>    0.600000F, 0.639216F, 0.678431F, 0.717647F, 0.756863F, 0.800000F, <br>    0.839216F, 0.878431F, 0.917647F, 0.956863F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, 0.000000F, <br>    0.000000F, 0.000000F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, 0.247059F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.498039F, <br>    0.498039F, 0.498039F, 0.498039F, 0.498039F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, 0.749020F, <br>    0.749020F, 0.749020F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>    1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, 1.000000F, <br>}; <br> <br>/* Default Palette */ <br>float auxRGBMap[20][3] = { <br>    { 0.0F, 0.0F, 0.0F },                               /* 0: black */ <br>    { 0x80/255.0F, 0.0F, 0.0F },                        /* 1: Half red */ <br>    { 0.0F, 0x80/255.0F, 0.0F },                        /* 2: Half green */ <br>    { 0x80/255.0F, 0x80/255.0F, 0.0F },                 /* 3: Half yellow */ <br>    { 0.0F, 0.0F, 0x80/255.0F },                        /* 4: Half blue */ <br>    { 0x80/255.0F, 0.0F, 0x80/255.0F },                 /* 5: Half magenta */ <br>    { 0.0F, 0x80/255.0F, 0x80/255.0F },                 /* 6: Half cyan */ <br>    { 0xC0/255.0F, 0xC0/255.0F, 0xC0/255.0F },          /* 7: Light gray */ <br>    { 0xC0/255.0F, 0xDC/255.0F, 0xC0/255.0F },          /* 8: Green gray */ <br>    { 0xA6/255.0F, 0xCA/255.0F, 0xF0/255.0F },          /* 9: Half gray */ <br>    { 1.0F, 0xFB/255.0F, 0xF0/255.0F },                 /* 10: Pale */ <br>    { 0xA0/255.0F, 0xA0/255.0F, 0xA4/255.0F },          /* 11: Med gray */ <br>    { 0x80/255.0F, 0x80/255.0F, 0x80/255.0F },          /* 12: Dark gray */ <br>    { 1.0F, 0.0F, 0.0F },                               /* 13: red */ <br>    { 0.0F, 1.0F, 0.0F },                               /* 14: green */ <br>    { 1.0F, 1.0F, 0.0F },                               /* 15: yellow */ <br>    { 0.0F, 0.0F, 1.0F },                               /* 16: blue */ <br>    { 1.0F, 0.0F, 1.0F },                               /* 17: magenta */ <br>    { 0.0F, 1.0F, 1.0F },                               /* 18: cyan */ <br>    { 1.0F, 1.0F, 1.0F },                               /* 19: white */ <br>}; <br> <br>/*************************************************************** <br> *                                                             * <br> *  Exported Functions go here                                 * <br> *                                                             * <br> ***************************************************************/ <br> <br>void tkErrorPopups(GLboolean bEnable) <br>{ <br>    tkPopupEnable = bEnable; <br>} <br> <br>void tkCloseWindow(void) <br>{ <br>    DestroyThisWindow(tkhwnd); <br>} <br> <br> <br>void tkExec(void) <br>{ <br>    MSG Message; <br> <br>    /* <br>     *  WM_SIZE gets delivered before we get here! <br>     */ <br> <br>    if (ReshapeFunc) <br>    { <br>        RECT ClientRect; <br> <br>        GetClientRect(tkhwnd, &amp;ClientRect); <br>        (*ReshapeFunc)(ClientRect.right, ClientRect.bottom); <br>    } <br> <br>    while (GL_TRUE) <br>    { <br>        /* <br>         *  Process all pending messages <br>         */ <br> <br>        if (IdleFunc) { <br>            while (PeekMessage(&amp;Message, NULL, 0, 0, PM_NOREMOVE) == TRUE) { <br>                if (GetMessage(&amp;Message, NULL, 0, 0) ) { <br>                    TranslateMessage(&amp;Message); <br>                    DispatchMessage(&amp;Message); <br>                } else { <br>                    /* <br>                     *  Nothing else to do here, just return <br>                     */ <br> <br>                    return; <br>                } <br>            } <br> <br>            /* <br>             *  If an idle function was defined, call it <br>             */ <br> <br>            if (IdleFunc) { <br>                (*IdleFunc)(); <br>            } <br>        } else { <br>            if (GetMessage(&amp;Message, NULL, 0, 0)) { <br>                TranslateMessage(&amp;Message); <br>                DispatchMessage(&amp;Message); <br>            } else { <br>                return; <br>            } <br>        } <br>    } <br>} <br> <br>void tkExposeFunc(void (*Func)(int, int)) <br>{ <br>    ExposeFunc = Func; <br>} <br> <br>void tkReshapeFunc(void (*Func)(GLsizei, GLsizei)) <br>{ <br>    ReshapeFunc = Func; <br>} <br> <br>void tkDisplayFunc(void (*Func)(void)) <br>{ <br>    DisplayFunc = Func; <br>} <br> <br>void tkKeyDownFunc(GLenum (*Func)(int, GLenum)) <br>{ <br>    KeyDownFunc = Func; <br>} <br> <br>void tkMouseDownFunc(GLenum (*Func)(int, int, GLenum)) <br>{ <br>    MouseDownFunc = Func; <br>} <br> <br>void tkMouseUpFunc(GLenum (*Func)(int, int, GLenum)) <br>{ <br>    MouseUpFunc = Func; <br>} <br> <br>void tkMouseMoveFunc(GLenum (*Func)(int, int, GLenum)) <br>{ <br>    MouseMoveFunc = Func; <br>} <br> <br>void tkIdleFunc(void (*Func)(void)) <br>{ <br>    IdleFunc = Func; <br>} <br> <br>void tkInitPosition(int x, int y, int width, int height) <br>{ <br>    if (x == CW_USEDEFAULT) <br>    { <br>        x = 0; <br>        y = 0; <br>        windInfo.bDefPos = TRUE; <br>    } <br>    else <br>        windInfo.bDefPos = FALSE; <br> <br>    windInfo.x = x + GetSystemMetrics(SM_CXFRAME); <br>    windInfo.y = y + GetSystemMetrics(SM_CYCAPTION) <br>                 - GetSystemMetrics(SM_CYBORDER) <br>                 + GetSystemMetrics(SM_CYFRAME); <br>    windInfo.width = width; <br>    windInfo.height = height; <br>} <br> <br>void tkInitDisplayMode(GLenum type) <br>{ <br>    windInfo.type = type; <br>} <br> <br>void tkInitDisplayModePolicy(GLenum type) <br>{ <br>    windInfo.dmPolicy = type; <br>} <br> <br>GLenum tkInitDisplayModeID(GLint ipfd) <br>{ <br>    windInfo.ipfd = ipfd; <br>    return GL_TRUE; <br>} <br> <br>// Initialize a window, create a rendering context for that window <br>GLenum tkInitWindow(char *title) <br>{ <br>    TKASSERT( NULL==tkhwnd      ); <br>    TKASSERT( NULL==tkhdc       ); <br>    TKASSERT( NULL==tkhrc       ); <br>    TKASSERT( NULL==tkhpalette  ); <br> <br>    return tkInitWindowAW(title, FALSE); <br>} <br> <br>GLenum tkInitWindowAW(char *title, BOOL bUnicode) <br>{ <br>    WNDCLASS wndclass; <br>    RECT     WinRect; <br>    HANDLE   hInstance; <br>    ATOM     aRegister; <br>    GLenum   Result = GL_FALSE; <br>    BOOL     bGetVersionExRet; <br> <br>    hInstance = GetModuleHandle(NULL); <br> <br>    tkOSVerInfo.dwOSVersionInfoSize = sizeof(tkOSVerInfo); <br>    bGetVersionExRet = GetVersionEx(&amp;tkOSVerInfo); <br>    TKASSERT(bGetVersionExRet); <br>    if ( tkOSVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT &amp;&amp; <br>         tkOSVerInfo.dwMajorVersion == 3 &amp;&amp; <br>         (tkOSVerInfo.dwMinorVersion == 5 || tkOSVerInfo.dwMinorVersion == 51) ) <br>        tkNumStaticColors = COLOR_BTNHIGHLIGHT - COLOR_SCROLLBAR + 1; <br>    else <br>        tkNumStaticColors = COLOR_INFOBK - COLOR_SCROLLBAR + 1; <br> <br>    // Must not define CS_PARENTDC style. <br>    wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc   = (WNDPROC)tkWndProc; <br>    wndclass.cbClsExtra    = 0; <br>    wndclass.cbWndExtra    = 0; <br>    wndclass.hInstance     = hInstance; <br>    wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION); <br>    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wndclass.hbrBackground = GetStockObject(BLACK_BRUSH); <br>    wndclass.lpszMenuName  = NULL; <br> <br>    if (bUnicode) <br>        wndclass.lpszClassName = (LPCSTR)lpszClassNameW; <br>    else <br>        wndclass.lpszClassName = (LPCSTR)lpszClassName; <br> <br>    if (bUnicode) <br>    { <br>        aRegister = RegisterClassW((CONST WNDCLASSW *)&amp;wndclass); <br>    } <br>    else <br>    { <br>        aRegister = RegisterClass(&amp;wndclass); <br>    } <br> <br> <br>    /* <br>     *  If the window failed to register, then there's no <br>     *  need to continue further. <br>     */ <br> <br>    if(0 == aRegister) <br>    { <br>        PrintMessage("Failed to register window class\n"); <br>        return(Result); <br>    } <br> <br> <br>    /* <br>     *  Make window large enough to hold a client area as large as windInfo <br>     */ <br> <br>    WinRect.left   = windInfo.x; <br>    WinRect.right  = windInfo.x + windInfo.width; <br>    WinRect.top    = windInfo.y; <br>    WinRect.bottom = windInfo.y + windInfo.height; <br> <br>    AdjustWindowRect(&amp;WinRect, WS_OVERLAPPEDWINDOW, FALSE); <br> <br>    /* <br>     *  Must use WS_CLIPCHILDREN and WS_CLIPSIBLINGS styles. <br>     */ <br> <br>    if (bUnicode) <br>    { <br>        tkhwnd = CreateWindowW( <br>                    (LPCWSTR)lpszClassNameW, <br>                    (LPCWSTR)title, <br>                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.left, <br>                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.top, <br>                    WinRect.right - WinRect.left, <br>                    WinRect.bottom - WinRect.top, <br>                    NULL, <br>                    NULL, <br>                    hInstance, <br>                    NULL); <br>    } <br>    else <br>    { <br>        tkhwnd = CreateWindow( <br>                    lpszClassName, <br>                    title, <br>                    WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.left, <br>                    (windInfo.bDefPos) ? CW_USEDEFAULT : WinRect.top, <br>                    WinRect.right - WinRect.left, <br>                    WinRect.bottom - WinRect.top, <br>                    NULL, <br>                    NULL, <br>                    hInstance, <br>                    NULL); <br>    } <br> <br>    if ( NULL != tkhwnd ) <br>    { <br>        // If default window positioning used, find out window position and fix <br>        // up the windInfo position info. <br> <br>        if (windInfo.bDefPos) <br>        { <br>            GetWindowRect(tkhwnd, &amp;WinRect); <br>            windInfo.x = WinRect.left + GetSystemMetrics(SM_CXFRAME); <br>            windInfo.y = WinRect.top  + GetSystemMetrics(SM_CYCAPTION) <br>                         - GetSystemMetrics(SM_CYBORDER) <br>                         + GetSystemMetrics(SM_CYFRAME); <br>        } <br> <br>        tkhdc = GetDC(tkhwnd); <br> <br>        if ( NULL != tkhdc ) <br>        { <br>            ShowWindow(tkhwnd, SW_SHOWDEFAULT); <br> <br>            if ( FindPixelFormat(tkhdc, windInfo.type) ) <br>            { <br>                /* <br>                 *  Create a Rendering Context <br>                 */ <br> <br>                tkhrc = wglCreateContext(tkhdc); <br> <br>                if ( NULL != tkhrc ) <br>                { <br>                    /* <br>                     *  Make it Current <br>                     */ <br> <br>                    if ( wglMakeCurrent(tkhdc, tkhrc) ) <br>                    { <br>                        Result = GL_TRUE; <br>                    } <br>                    else <br>                    { <br>                        PrintMessage("wglMakeCurrent Failed\n"); <br>                    } <br>                } <br>                else <br>                { <br>                    PrintMessage("wglCreateContext Failed\n"); <br>                } <br>            } <br>        } <br>        else <br>        { <br>            PrintMessage("Could not get an HDC for window 0x%08lX\n", tkhwnd ); <br>        } <br>    } <br>    else <br>    { <br>        PrintMessage("create window failed\n"); <br>    } <br> <br>    if ( GL_FALSE == Result ) <br>    { <br>        DestroyThisWindow(tkhwnd);  // Something Failed, Destroy this window <br>    } <br>    return( Result ); <br>} <br> <br>/******************************************************************************/ <br> <br>/* <br> * You cannot just call DestroyWindow() here.  The programs do not expect <br> * tkQuit() to return;  DestroyWindow() just sends a WM_DESTROY message <br> */ <br> <br>void tkQuit(void) <br>{ <br>    DestroyThisWindow(tkhwnd); <br>    ExitProcess(0); <br>} <br> <br>/******************************************************************************/ <br> <br>void tkSetOneColor(int index, float r, float g, float b) <br>{ <br>    PALETTEENTRY PalEntry; <br>    HPALETTE Palette; <br> <br>    if ( NULL != (Palette = CreateCIPalette( tkhdc )) ) <br>    { <br>        if ( tkUseStaticColors &amp;&amp; ( index == 0 || index == 255 ) ) <br>            return; <br> <br>        PalEntry.peRed   = (BYTE)(r*(float)255.0 + (float)0.5); <br>        PalEntry.peGreen = (BYTE)(g*(float)255.0 + (float)0.5); <br>        PalEntry.peBlue  = (BYTE)(b*(float)255.0 + (float)0.5); <br>        PalEntry.peFlags = ( tkUseStaticColors ) ? PC_NOCOLLAPSE : 0; </code></pre>
<p>
</p>
<pre><code><br>        // This is a workaround for a GDI palette "feature".  If any of <br>        // the static colors are repeated in the palette, those colors <br>        // will map to the first occurance.  So, for our case where there <br>        // are only two static colors (black and white), if a white <br>        // color appears anywhere in the palette other than in the last <br>        // entry, the static white will remap to the first white.  This <br>        // destroys the nice one-to-one mapping we are trying to achieve. <br>        // <br>        // There are two ways to workaround this.  The first is to <br>        // simply not allow a pure white anywhere but in the last entry. <br>        // Such requests are replaced with an attenuated white of <br>        // (0xFE, 0xFE, 0xFE). <br>        // <br>        // The other way is to mark these extra whites with PC_RESERVED <br>        // which will cause GDI to skip these entries when mapping colors. <br>        // This way the app gets the actual colors requested, but can <br>        // have side effects on other apps. <br>        // <br>        // Both solutions are included below.  The PC_RESERVED solution is <br>        // the one currently enabled.  It may have side effects, but taking <br>        // over the static colors as we are is a really big side effect that <br>        // should swamp out the effects of using PC_RESERVED. <br> <br>        if ( tkUseStaticColors ) <br>        { <br>            if ( PalEntry.peRed   == 0xFF &amp;&amp; <br>                 PalEntry.peGreen == 0xFF &amp;&amp; <br>                 PalEntry.peBlue  == 0xFF ) <br>            { <br>            #define USE_PC_RESERVED_WORKAROUND  1 <br>            #if USE_PC_RESERVED_WORKAROUND <br>                PalEntry.peFlags |= PC_RESERVED; <br>            #else <br>                PalEntry.peRed   = <br>                PalEntry.peGreen = <br>                PalEntry.peBlue  = 0xFE; <br>            #endif <br>            } <br>        } <br> <br>        SetPaletteEntries( Palette, index, 1, &amp;PalEntry); <br> <br>        DelayPaletteRealization(); <br>    } <br>} <br> <br>void tkSetFogRamp(int density, int startIndex) <br>{ <br>    HPALETTE CurrentPal; <br>    PALETTEENTRY *pPalEntry; <br>    UINT n, i, j, k, intensity, fogValues, colorValues; <br> <br>    if ( NULL != (CurrentPal = CreateCIPalette(tkhdc)) ) <br>    { <br>        n = GetPaletteEntries( CurrentPal, 0, 0, NULL ); <br> <br>        pPalEntry = AllocateMemory( n * sizeof(PALETTEENTRY) ); <br> <br>        if ( NULL != pPalEntry) <br>        { <br>            fogValues = 1 &lt;&lt; density; <br>            colorValues = 1 &lt;&lt; startIndex; <br>            for (i = 0; i &lt; colorValues; i++) { <br>                for (j = 0; j &lt; fogValues; j++) { <br>                    k = i * fogValues + j; <br> <br>                    intensity = i * fogValues + j * colorValues; <br>                    //mf: not sure what they're trying to do here <br>                    //intensity = (intensity &lt;&lt; 8) | intensity; ??? <br> <br>                // This is a workaround for a GDI palette "feature".  If any of <br>                // the static colors are repeated in the palette, those colors <br>                // will map to the first occurance.  So, for our case where there <br>                // are only two static colors (black and white), if a white <br>                // color appears anywhere in the palette other than in the last <br>                // entry, the static white will remap to the first white.  This <br>                // destroys the nice one-to-one mapping we are trying to achieve. <br>                // <br>                // There are two ways to workaround this.  The first is to <br>                // simply not allow a pure white anywhere but in the last entry. <br>                // Such requests are replaced with an attenuated white of <br>                // (0xFE, 0xFE, 0xFE). <br>                // <br>                // The other way is to mark these extra whites with PC_RESERVED <br>                // which will cause GDI to skip these entries when mapping colors. <br>                // This way the app gets the actual colors requested, but can <br>                // have side effects on other apps. <br>                // <br>                // Both solutions are included below.  The PC_RESERVED solution is <br>                // the one currently enabled.  It may have side effects, but taking <br>                // over the static colors as we are is a really big side effect that <br>                // should swamp out the effects of using PC_RESERVED. <br> <br>                #if USE_PC_RESERVED_WORKAROUND <br>                    if (intensity &gt; 0xFF) <br>                        intensity = 0xFF; <br>                #else <br>                    if (intensity &gt;= 0xFF) <br>                        intensity = ( tkUseStaticColors &amp;&amp; k != 255) ? 0xFE : 0xFF; <br>                #endif <br> <br>                    pPalEntry[k].peRed = <br>                    pPalEntry[k].peGreen = <br>                    pPalEntry[k].peBlue = (BYTE) intensity; <br>                    pPalEntry[k].peFlags = ( tkUseStaticColors &amp;&amp; k != 0 &amp;&amp; k != 255 ) <br>                                           ? PC_NOCOLLAPSE : 0; <br> <br>                #if USE_PC_RESERVED_WORKAROUND <br>                    if (tkUseStaticColors &amp;&amp; intensity == 0xFF <br>                        &amp;&amp; k != 0 &amp;&amp; k!= 255) <br>                        pPalEntry[k].peFlags |= PC_RESERVED; <br>                #endif <br>                } <br>            } <br> <br>            SetPaletteEntries(CurrentPal, 0, n, pPalEntry); <br>            FreeMemory( pPalEntry ); <br> <br>            DelayPaletteRealization(); <br>        } <br>    } <br>} <br> <br>void tkSetGreyRamp(void) <br>{ <br>    HPALETTE CurrentPal; <br>    PALETTEENTRY *Entries; <br>    UINT Count, i; <br>    float intensity; <br> <br>    if ( NULL != (CurrentPal = CreateCIPalette( tkhdc )) ) <br>    { <br>        Count   = GetPaletteEntries( CurrentPal, 0, 0, NULL ); <br>        Entries = AllocateMemory( Count * sizeof(PALETTEENTRY) ); <br> <br>        if ( NULL != Entries ) <br>        { <br>            for (i = 0; i &lt; Count; i++) <br>            { <br>                intensity = (float)(((double)i / (double)(Count-1)) * (double)255.0 + (double)0.5); <br>                Entries[i].peRed = <br>                Entries[i].peGreen = <br>                Entries[i].peBlue = (BYTE) intensity; <br>                Entries[i].peFlags = ( tkUseStaticColors &amp;&amp; i != 0 &amp;&amp; i != 255 ) <br>                                     ? PC_NOCOLLAPSE : 0; <br>            } <br>            SetPaletteEntries( CurrentPal, 0, Count, Entries ); <br>            FreeMemory( Entries ); <br> <br>            DelayPaletteRealization(); <br>        } <br>    } <br>} <br> <br>void tkSetRGBMap( int Size, float *Values ) <br>{ <br>    HPALETTE CurrentPal; <br>    PIXELFORMATDESCRIPTOR Pfd, *pPfd; <br>    PALETTEENTRY *Entries; <br>    UINT Count; <br> <br>    if ( NULL != (CurrentPal = CreateCIPalette( tkhdc )) ) <br>    { <br>        pPfd = &amp;Pfd; <br> <br>        if ( PixelFormatDescriptorFromDc( tkhdc, pPfd ) ) <br>        { <br>            Count    = 1 &lt;&lt; pPfd-&gt;cColorBits; <br>            Entries  = AllocateMemory( Count * sizeof(PALETTEENTRY) ); <br> <br>            if ( NULL != Entries ) <br>            { <br>                FillRgbPaletteEntries( pPfd, Entries, Count ); <br>                SetPaletteEntries( CurrentPal, 0, Count, Entries ); <br>                FreeMemory(Entries); <br> <br>                RealizePaletteNow( tkhdc, tkhpalette, FALSE ); <br>            } <br>        } <br>    } <br>} <br> <br>/******************************************************************************/ <br> <br>void tkSwapBuffers(void) <br>{ <br>    SwapBuffers(tkhdc); <br>} <br> <br>/******************************************************************************/ <br> <br>GLint tkGetColorMapSize(void) <br>{ <br>    CreateCIPalette( tkhdc ); <br> <br>    if ( NULL == tkhpalette ) <br>        return( 0 ); <br> <br>    return( GetPaletteEntries( tkhpalette, 0, 0, NULL ) ); <br>} <br> <br>void tkGetMouseLoc(int *x, int *y) <br>{ <br>    POINT Point; <br> <br>    *x = 0; <br>    *y = 0; <br> <br>    GetCursorPos(&amp;Point); <br> <br>    /* <br>     *  GetCursorPos returns screen coordinates, <br>     *  we want window coordinates <br>     */ <br> <br>    *x = Point.x - windInfo.x; <br>    *y = Point.y - windInfo.y; <br>} <br> <br>HWND tkGetHWND(void) <br>{ <br>    return tkhwnd; <br>} <br> <br>HDC tkGetHDC(void) <br>{ <br>    return tkhdc; <br>} <br> <br>HGLRC tkGetHRC(void) <br>{ <br>    return tkhrc; <br>} <br> <br>GLenum tkGetDisplayModePolicy(void) <br>{ <br>    return windInfo.dmPolicy; <br>} <br> <br>GLint tkGetDisplayModeID(void) <br>{ <br>    return windInfo.ipfd; <br>} <br> <br>GLenum tkGetDisplayMode(void) <br>{ <br>    return windInfo.type; <br>} <br> <br> <br>/*********************************************************************** <br> *                                                                     * <br> *  The Following functions are for our own use only. (ie static)      * <br> *                                                                     * <br> ***********************************************************************/ <br> <br>static long <br>tkWndProc(HWND hWnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    int key; <br>    PAINTSTRUCT paint; <br>    HDC hdc; <br>    PIXELFORMATDESCRIPTOR pfd; <br> <br>    switch (message) { <br> <br>    case WM_USER: <br>        if ( RealizePaletteNow( tkhdc, tkhpalette, FALSE ) &gt; 0 ) <br>        { <br>            ForceRedraw( hWnd ); <br>        } <br>        return(0); <br> <br>    case WM_SIZE: <br>        windInfo.width  = LOWORD(lParam); <br>        windInfo.height = HIWORD(lParam); <br> <br>        if (ReshapeFunc) <br>        { <br>            (*ReshapeFunc)(windInfo.width, windInfo.height); <br> <br>            ForceRedraw( hWnd ); <br>        } <br>        return (0); <br> <br>    case WM_MOVE: <br>        windInfo.x = LOWORD(lParam); <br>        windInfo.y = HIWORD(lParam); <br>        return (0); <br> <br>    case WM_PAINT: <br>        /* <br>         *  Validate the region even if there are no DisplayFunc. <br>         *  Otherwise, USER will not stop sending WM_PAINT messages. <br>         */ <br> <br>        hdc = BeginPaint(tkhwnd, &amp;paint); <br> <br>        if (DisplayFunc) <br>        { <br>            (*DisplayFunc)(); <br>        } <br> <br>        EndPaint(tkhwnd, &amp;paint); <br>        return (0); <br> <br>    case WM_QUERYNEWPALETTE: <br> <br>    // We don't actually realize the palette here (we do it at WM_ACTIVATE <br>    // time), but we need the system to think that we have so that a <br>    // WM_PALETTECHANGED message is generated. <br> <br>        return (1); <br> <br>    case WM_PALETTECHANGED: <br> <br>    // Respond to this message only if the window that changed the palette <br>    // is not this app's window. <br> <br>    // We are not the foreground window, so realize palette in the <br>    // background.  We cannot call RealizePaletteNow to do this because <br>    // we should not do any of the tkUseStaticColors processing while <br>    // in background. <br> <br>        if ( hWnd != (HWND) wParam ) <br>        { <br>            if ( !tkSystemColorsInUse &amp;&amp; <br>                 NULL != tkhpalette &amp;&amp; <br>                 NULL != SelectPalette( tkhdc, tkhpalette, TRUE ) ) <br>                RealizePalette( tkhdc ); <br>        } <br> <br>        return (0); <br> <br>    case WM_SYSCOLORCHANGE: <br> <br>    // If the system colors have changed and we have a palette <br>    // for an RGB surface then we need to recompute the static <br>    // color mapping because they might have been changed in <br>    // the process of changing the system colors. <br> <br>        if (tkhdc != NULL &amp;&amp; tkhpalette != NULL &amp;&amp; <br>            PixelFormatDescriptorFromDc(tkhdc, &amp;pfd) &amp;&amp; <br>            (pfd.dwFlags &amp; PFD_NEED_PALETTE) &amp;&amp; <br>            pfd.iPixelType == PFD_TYPE_RGBA) <br>        { <br>            HPALETTE hpalTmp; <br> <br>            hpalTmp = tkhpalette; <br>            tkhpalette = NULL; <br>            if (CreateRGBPalette(tkhdc) != NULL) <br>            { <br>                DeleteObject(hpalTmp); <br>                ForceRedraw(hWnd); <br>            } <br>            else <br>            { <br>                tkhpalette = hpalTmp; <br>            } <br>        } <br>        break; <br>             <br>    case WM_ACTIVATE: <br> <br>    // If the window is going inactive, the palette must be realized to <br>    // the background.  Cannot depend on WM_PALETTECHANGED to be sent since <br>    // the window that comes to the foreground may or may not be palette <br>    // managed. <br> <br>        if ( LOWORD(wParam) == WA_INACTIVE ) <br>        { <br>            if ( NULL != tkhpalette ) <br>            { <br>            // Realize as a background palette.  Need to call <br>            // RealizePaletteNow rather than RealizePalette directly to <br>            // because it may be necessary to release usage of the static <br>            // system colors. <br> <br>                if ( RealizePaletteNow( tkhdc, tkhpalette, TRUE ) &gt; 0 ) <br>                    ForceRedraw( hWnd ); <br>            } <br>        } <br> <br>    // Window is going active.  If we are not iconized, realize palette <br>    // to the foreground.  If management of the system static colors is <br>    // needed, RealizePaletteNow will take care of it. <br> <br>        else if ( HIWORD(wParam) == 0 ) <br>        { <br>            if ( NULL != tkhpalette ) <br>            { <br>                if ( RealizePaletteNow( tkhdc, tkhpalette, FALSE ) &gt; 0 ) <br>                    ForceRedraw( hWnd ); <br> <br>                return (1); <br>            } <br>        } <br> <br>    // Allow DefWindowProc() to finish the default processing (which includes <br>    // changing the keyboard focus). <br> <br>        break; <br> <br>    case WM_MOUSEMOVE: <br> <br>        if (MouseMoveFunc) <br>        { <br>            GLenum mask; <br> <br>            mask = 0; <br>            if (wParam &amp; MK_LBUTTON) { <br>                mask |= TK_LEFTBUTTON; <br>            } <br>            if (wParam &amp; MK_MBUTTON) { <br>                mask |= TK_MIDDLEBUTTON; <br>            } <br>            if (wParam &amp; MK_RBUTTON) { <br>                mask |= TK_RIGHTBUTTON; <br>            } <br> <br>            if ((*MouseMoveFunc)( LOWORD(lParam), HIWORD(lParam), mask )) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_LBUTTONDOWN: <br> <br>        SetCapture(hWnd); <br> <br>        if (MouseDownFunc) <br>        { <br>            if ( (*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam), <br>                 TK_LEFTBUTTON) ) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_LBUTTONUP: <br> <br>        ReleaseCapture(); <br> <br>        if (MouseUpFunc) <br>        { <br>            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam), TK_LEFTBUTTON)) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_MBUTTONDOWN: <br> <br>        SetCapture(hWnd); <br> <br>        if (MouseDownFunc) <br>        { <br>            if ((*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam), <br>                    TK_MIDDLEBUTTON)) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_MBUTTONUP: <br> <br>        ReleaseCapture(); <br> <br>        if (MouseUpFunc) <br>        { <br>            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam), <br>                TK_MIDDLEBUTTON)) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_RBUTTONDOWN: <br> <br>        SetCapture(hWnd); <br> <br>        if (MouseDownFunc) <br>        { <br>            if ((*MouseDownFunc)(LOWORD(lParam), HIWORD(lParam), <br>                TK_RIGHTBUTTON)) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_RBUTTONUP: <br> <br>        ReleaseCapture(); <br> <br>        if (MouseUpFunc) <br>        { <br>            if ((*MouseUpFunc)(LOWORD(lParam), HIWORD(lParam), <br>                TK_RIGHTBUTTON)) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_KEYDOWN: <br>        switch (wParam) { <br>        case VK_SPACE:          key = TK_SPACE;         break; <br>        case VK_RETURN:         key = TK_RETURN;        break; <br>        case VK_ESCAPE:         key = TK_ESCAPE;        break; <br>        case VK_LEFT:           key = TK_LEFT;          break; <br>        case VK_UP:             key = TK_UP;            break; <br>        case VK_RIGHT:          key = TK_RIGHT;         break; <br>        case VK_DOWN:           key = TK_DOWN;          break; <br>        default:                key = GL_FALSE;         break; <br>        } <br> <br>        if (key &amp;&amp; KeyDownFunc) <br>        { <br>            GLenum mask; <br> <br>            mask = 0; <br>            if (GetKeyState(VK_CONTROL)) { <br>                mask |= TK_CONTROL; <br>            } <br> <br>            if (GetKeyState(VK_SHIFT)) { <br> <br>                mask |= TK_SHIFT; <br>            } <br> <br>            if ( (*KeyDownFunc)(key, mask) ) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_CHAR: <br>        if (('0' &lt;= wParam &amp;&amp; wParam &lt;= '9') || <br>            ('a' &lt;= wParam &amp;&amp; wParam &lt;= 'z') || <br>            ('A' &lt;= wParam &amp;&amp; wParam &lt;= 'Z')) { <br> <br>            key = wParam; <br>        } else { <br>            key = GL_FALSE; <br>        } <br> <br>        if (key &amp;&amp; KeyDownFunc) { <br>            GLenum mask; <br> <br>            mask = 0; <br> <br>            if (GetKeyState(VK_CONTROL)) { <br>                mask |= TK_CONTROL; <br>            } <br> <br>            if (GetKeyState(VK_SHIFT)) { <br>                mask |= TK_SHIFT; <br>            } <br> <br>            if ( (*KeyDownFunc)(key, mask) ) <br>            { <br>                ForceRedraw( hWnd ); <br>            } <br>        } <br>        return (0); <br> <br>    case WM_CLOSE: <br>        DestroyWindow(tkhwnd); <br>        return(0); <br> <br>    case WM_DESTROY: <br>        CleanUp(); <br>        PostQuitMessage(TRUE); <br>        return 0; <br>    } <br>    return(DefWindowProc( hWnd, message, wParam, lParam)); <br>} <br> <br>#if RESTORE_FROM_REGISTRY <br>/******************************Public*Routine******************************\ <br>* GetRegistrySysColors <br>* <br>* Reads the Control Panel's color settings from the registry and stores <br>* those values in pcr.  If we fail to get any value, then the corresponding <br>* entry in pcr is not modified. <br>* <br>* History: <br>*  12-Apr-1995 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static BOOL GetRegistrySysColors(COLORREF *pcr, int nColors) <br>{ <br>    BOOL bRet = FALSE; <br>    long lRet; <br>    HKEY hkSysColors = (HKEY) NULL; <br>    int i; <br>    DWORD dwDataType; <br>    char achColor[64]; <br>    DWORD cjColor; <br> <br>    TKASSERT(nColors &lt;= tkNumStaticColors); <br> <br>// Open the key for the system color settings. <br> <br>    lRet = RegOpenKeyExA(HKEY_CURRENT_USER, <br>                         "Control Panel\\Colors", <br>                         0, <br>                         KEY_QUERY_VALUE, <br>                         &amp;hkSysColors); <br> <br>    if ( lRet != ERROR_SUCCESS ) <br>    { <br>        goto GetRegistrySysColors_exit; <br>    } <br> <br>// Read each system color value.  The names are stored in the global <br>// array of char *, gaszSysClrNames. <br> <br>    for (i = 0; i &lt; nColors; i++) <br>    { <br>        cjColor = sizeof(achColor); <br>        lRet = RegQueryValueExA(hkSysColors, <br>                                (LPSTR) gaszSysClrNames[i], <br>                                (LPDWORD) NULL, <br>                                &amp;dwDataType, <br>                                (LPBYTE) achColor, <br>                                &amp;cjColor); <br> <br>        TKASSERT(lRet != ERROR_MORE_DATA); <br> <br>        if ( lRet == ERROR_SUCCESS &amp;&amp; dwDataType == REG_SZ ) <br>        { <br>            DWORD r, g, b; <br> <br>            sscanf(achColor, "%ld %ld %ld", &amp;r, &amp;g, &amp;b); <br>            pcr[i] = RGB(r, g, b); <br>        } <br>    } <br> <br>    bRet = TRUE; <br> <br>GetRegistrySysColors_exit: <br>    if (hkSysColors) <br>        RegCloseKey(hkSysColors); <br> <br>    return bRet; <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* GrabStaticEntries <br>* <br>* Support routine for RealizePaletteNow to manage the static system color <br>* usage. <br>* <br>* This function will save the current static system color usage state. <br>* It will fail if: <br>* <br>*   1.  TK is not in "sys color in use state but system palette is in <br>*       SYSPAL_NOSTATIC mode.  This means that another app still possesses <br>*       the static system colors.  This this happens, GrabStaticEntries <br>*       will post a message to cause TK to try again (by calling <br>*       DelayPaletteRealization). <br>* <br>* Side effect: <br>*   If system colors are changed, then WM_SYSCOLORCHANGE message is <br>*   broadcast to all top level windows. <br>* <br>*   DelayPaletteRealization may be called in case 2 above, resulting in <br>*   a WM_USER message being posted to our message queue. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise (see above). <br>* <br>* History: <br>*  26-Apr-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static BOOL GrabStaticEntries(HDC hdc) <br>{ <br>    int i; <br>    BOOL bRet = FALSE; <br> <br>// Do nothing if sys colors already in use. <br> <br>    if ( !tkSystemColorsInUse ) <br>    { <br>    // Take possession only if no other app has the static colors. <br>    // How can we tell?  If the return from SetSystemPaletteUse is <br>    // SYSPAL_STATIC, then no other app has the statics.  If it is <br>    // SYSPAL_NOSTATIC, someone else has them and we must fail. <br>    // <br>    // SetSystemPaletteUse is properly synchronized internally <br>    // so that it is atomic. <br>    // <br>    // Because we are relying on SetSystemPaletteUse to synchronize TK, <br>    // it is important to observe the following order for grabbing and <br>    // releasing: <br>    // <br>    //      Grab        call SetSystemPaletteUse and check for SYSPAL_STATIC <br>    //                  save sys color settings <br>    //                  set new sys color settings <br>    // <br>    //      Release     restore sys color settings <br>    //                  call SetSystemPaletteUse <br> <br>        if ( SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC ) == SYSPAL_STATIC ) <br>        { <br>        // Save current sys color settings. <br> <br>            for (i = COLOR_SCROLLBAR; i &lt;= COLOR_BTNHIGHLIGHT; i++) <br>                gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i); <br> <br>        // Set b&amp;w sys color settings.  Put TK in "sys colors in use" state. <br> <br>            SetSysColors(tkNumStaticColors, gaiStaticIndex, gacrBlackAndWhite); <br>            tkSystemColorsInUse = TRUE; <br> <br>        // Inform all other top-level windows of the system color change. <br> <br>            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br> <br>            bRet = TRUE; <br>        } <br> <br>    // Sleep a little and then post message to try palette realization again <br>    // later. <br> <br>        else <br>        { <br>            Sleep(0L); <br>            DelayPaletteRealization(); <br>        } <br>    } <br>    else <br>        bRet = TRUE; <br> <br>    return bRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ReleaseStaticEntries <br>* <br>* Support routine for RealizePaletteNow to manage the static system color <br>* usage. <br>* <br>* This function will reset the current static system color usage state. <br>* It will fail if: <br>* <br>*   1.  TK is not in a "sys colors in use" state.  If we are in this case, <br>*       then the static system colors do not need to be released. <br>* <br>* Side effect: <br>*   If system colors are changed, then WM_SYSCOLORCHANGE message is <br>*   broadcast to all top level windows. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise (see above). <br>* <br>* History: <br>*  21-Jul-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static BOOL ReleaseStaticEntries(HDC hdc) <br>{ <br>    BOOL bRet = FALSE; <br> <br>// Do nothing if sys colors not in use. <br> <br>    if ( tkSystemColorsInUse ) <br>    { <br>#if RESTORE_FROM_REGISTRY <br>    // Replace saved system colors with registry values.  We do it now <br>    // rather than earlier because someone may have changed registry while <br>    // TK app was running in the foreground (very unlikely, but it could <br>    // happen). <br>    // <br>    // Also, we still try to save current setting in GrabStaticEntries so <br>    // that if for some reason we fail to grab one or more of the colors <br>    // from the registry, we can still fall back on what we grabbed via <br>    // GetSysColors (even though there is a chance its the wrong color). <br> <br>        GetRegistrySysColors(gacrSave, tkNumStaticColors); <br>#endif <br> <br>    // Restore the saved system color settings. <br> <br>        SetSysColors(tkNumStaticColors, gaiStaticIndex, gacrSave); <br> <br>    // Return the system palette to SYSPAL_STATIC. <br> <br>        SetSystemPaletteUse( hdc, SYSPAL_STATIC ); <br> <br>    // Inform all other top-level windows of the system color change. <br> <br>        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br> <br>    // Reset the "sys colors in use" state and return success. <br> <br>        tkSystemColorsInUse = FALSE; <br>        bRet = TRUE; <br>    } <br> <br>    return bRet; <br>} <br> <br>// Default palette entry flags <br>#define PALETTE_FLAGS PC_NOCOLLAPSE <br> <br>// Gamma correction factor * 10 <br>#define GAMMA_CORRECTION 14 <br> <br>// Maximum color distance with 8-bit components <br>#define MAX_COL_DIST (3*256*256L) <br> <br>// Number of static colors <br>#define STATIC_COLORS 20 <br> <br>// Flags used when matching colors <br>#define EXACT_MATCH 1 <br>#define COLOR_USED 1 <br> <br>// Conversion tables for n bits to eight bits <br> <br>#if GAMMA_CORRECTION == 10 <br>// These tables are corrected for a gamma of 1.0 <br>static unsigned char abThreeToEight[8] = <br>{ <br>    0, 0111 &gt;&gt; 1, 0222 &gt;&gt; 1, 0333 &gt;&gt; 1, 0444 &gt;&gt; 1, 0555 &gt;&gt; 1, 0666 &gt;&gt; 1, 0377 <br>}; <br>static unsigned char abTwoToEight[4] = <br>{ <br>    0, 0x55, 0xaa, 0xff <br>}; <br>static unsigned char abOneToEight[2] = <br>{ <br>    0, 255 <br>}; <br>#else <br>// These tables are corrected for a gamma of 1.4 <br>static unsigned char abThreeToEight[8] = <br>{ <br>    0, 63, 104, 139, 171, 200, 229, 255 <br>}; <br>static unsigned char abTwoToEight[4] = <br>{ <br>    0, 116, 191, 255 <br>}; <br>static unsigned char abOneToEight[2] = <br>{ <br>    0, 255 <br>}; <br>#endif <br> <br>// Table which indicates which colors in a 3-3-2 palette should be <br>// replaced with the system default colors <br>#if GAMMA_CORRECTION == 10 <br>static int aiDefaultOverride[STATIC_COLORS] = <br>{ <br>    0, 4, 32, 36, 128, 132, 160, 173, 181, 245, <br>    247, 164, 156, 7, 56, 63, 192, 199, 248, 255 <br>}; <br>#else <br>static int aiDefaultOverride[STATIC_COLORS] = <br>{ <br>    0, 3, 24, 27, 64, 67, 88, 173, 181, 236, <br>    247, 164, 91, 7, 56, 63, 192, 199, 248, 255 <br>}; <br>#endif <br> <br>static unsigned char <br>ComponentFromIndex(int i, int nbits, int shift) <br>{ <br>    unsigned char val; <br> <br>    TKASSERT(nbits &gt;= 1 &amp;&amp; nbits &lt;= 3); <br>     <br>    val = i &gt;&gt; shift; <br>    switch (nbits) <br>    { <br>    case 1: <br>        return abOneToEight[val &amp; 1]; <br> <br>    case 2: <br>        return abTwoToEight[val &amp; 3]; <br> <br>    case 3: <br>        return abThreeToEight[val &amp; 7]; <br>    } <br>} <br> <br>// System default colors <br>static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] = <br>{ <br>    { 0,   0,   0,    0 }, <br>    { 0x80,0,   0,    0 }, <br>    { 0,   0x80,0,    0 }, <br>    { 0x80,0x80,0,    0 }, <br>    { 0,   0,   0x80, 0 }, <br>    { 0x80,0,   0x80, 0 }, <br>    { 0,   0x80,0x80, 0 }, <br>    { 0xC0,0xC0,0xC0, 0 }, <br> <br>    { 192, 220, 192,  0 }, <br>    { 166, 202, 240,  0 }, <br>    { 255, 251, 240,  0 }, <br>    { 160, 160, 164,  0 }, <br> <br>    { 0x80,0x80,0x80, 0 }, <br>    { 0xFF,0,   0,    0 }, <br>    { 0,   0xFF,0,    0 }, <br>    { 0xFF,0xFF,0,    0 }, <br>    { 0,   0,   0xFF, 0 }, <br>    { 0xFF,0,   0xFF, 0 }, <br>    { 0,   0xFF,0xFF, 0 }, <br>    { 0xFF,0xFF,0xFF, 0 } <br>}; <br> <br>/******************************Public*Routine******************************\ <br>* <br>* UpdateStaticMapping <br>* <br>* Computes the best match between the current system static colors <br>* and a 3-3-2 palette <br>* <br>* History: <br>*  Tue Aug 01 18:18:12 1995-by-Drew Bliss [drewb] <br>*   Created <br>* <br>\**************************************************************************/ <br> <br>static void <br>UpdateStaticMapping(PALETTEENTRY *pe332Palette) <br>{ <br>    HPALETTE hpalStock; <br>    int iStatic, i332; <br>    int iMinDist, iDist; <br>    int iDelta; <br>    int iMinEntry; <br>    PALETTEENTRY *peStatic, *pe332; <br> <br>    hpalStock = GetStockObject(DEFAULT_PALETTE); <br> <br>    // The system should always have one of these <br>    TKASSERT(hpalStock != NULL); <br>    // Make sure there's the correct number of entries <br>    TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS); <br> <br>    // Get the current static colors <br>    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry); <br> <br>    // Zero the flags in the static colors because they are used later <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        peStatic-&gt;peFlags = 0; <br>        peStatic++; <br>    } <br> <br>    // Zero the flags in the incoming palette because they are used later <br>    pe332 = pe332Palette; <br>    for (i332 = 0; i332 &lt; 256; i332++) <br>    { <br>        pe332-&gt;peFlags = 0; <br>        pe332++; <br>    } <br> <br>    // Try to match each static color exactly <br>    // This saves time by avoiding the least-squares match for each <br>    // exact match <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        pe332 = pe332Palette; <br>        for (i332 = 0; i332 &lt; 256; i332++) <br>        { <br>            if (peStatic-&gt;peRed == pe332-&gt;peRed &amp;&amp; <br>                peStatic-&gt;peGreen == pe332-&gt;peGreen &amp;&amp; <br>                peStatic-&gt;peBlue == pe332-&gt;peBlue) <br>            { <br>                TKASSERT(pe332-&gt;peFlags != COLOR_USED); <br>                 <br>                peStatic-&gt;peFlags = EXACT_MATCH; <br>                pe332-&gt;peFlags = COLOR_USED; </code></pre>
<p>
</p>
<pre><code>aiDefaultOverride[iStatic] = i332; <br>                 <br>                break; <br>            } <br> <br>            pe332++; <br>        } <br> <br>        peStatic++; <br>    } <br>     <br>    // Match each static color as closely as possible to an entry <br>    // in the 332 palette by minimized the square of the distance <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        // Skip colors already matched exactly <br>        if (peStatic-&gt;peFlags == EXACT_MATCH) <br>        { <br>            peStatic++; <br>            continue; <br>        } <br>         <br>        iMinDist = MAX_COL_DIST+1; <br>#if DBG <br>        iMinEntry = -1; <br>#endif <br> <br>        pe332 = pe332Palette; <br>        for (i332 = 0; i332 &lt; 256; i332++) <br>        { <br>            // Skip colors already used <br>            if (pe332-&gt;peFlags == COLOR_USED) <br>            { <br>                pe332++; <br>                continue; <br>            } <br>             <br>            // Compute Euclidean distance squared <br>            iDelta = pe332-&gt;peRed-peStatic-&gt;peRed; <br>            iDist = iDelta*iDelta; <br>            iDelta = pe332-&gt;peGreen-peStatic-&gt;peGreen; <br>            iDist += iDelta*iDelta; <br>            iDelta = pe332-&gt;peBlue-peStatic-&gt;peBlue; <br>            iDist += iDelta*iDelta; <br> <br>            if (iDist &lt; iMinDist) <br>            { <br>                iMinDist = iDist; <br>                iMinEntry = i332; <br>            } <br> <br>            pe332++; <br>        } <br> <br>        TKASSERT(iMinEntry != -1); <br> <br>        // Remember the best match <br>        aiDefaultOverride[iStatic] = iMinEntry; <br>        pe332Palette[iMinEntry].peFlags = COLOR_USED; <br>         <br>        peStatic++; <br>    } <br> <br>    // Zero the flags in the static colors because they may have been <br>    // set.  We want them to be zero so the colors can be remapped <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        peStatic-&gt;peFlags = 0; <br>        peStatic++; <br>    } <br> <br>    // Reset the 332 flags because we may have set them <br>    pe332 = pe332Palette; <br>    for (i332 = 0; i332 &lt; 256; i332++) <br>    { <br>        pe332-&gt;peFlags = PALETTE_FLAGS; <br>        pe332++; <br>    } <br> <br>#if 0 <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        PrintMessage("Static color %2d maps to %d\n", <br>                     iStatic, aiDefaultOverride[iStatic]); <br>    } <br>#endif <br>} <br> <br>/******************************Public*Routine******************************\ <br>* FillRgbPaletteEntries <br>* <br>* Fills a PALETTEENTRY array with values required for a logical rgb palette. <br>* If tkSetStaticColorUsage has been called with TRUE, the static system <br>* colors will be overridden.  Otherwise, the PALETTEENTRY array will be <br>* fixed up to contain the default static system colors. <br>* <br>* History: <br>*  26-Apr-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static PALETTEENTRY * <br>FillRgbPaletteEntries(  PIXELFORMATDESCRIPTOR *Pfd, <br>                        PALETTEENTRY *Entries, <br>                        UINT Count <br>                     ) <br>{ <br>    PALETTEENTRY *Entry; <br>    UINT i; <br> <br>    if ( NULL != Entries ) <br>    { <br>        for ( i = 0, Entry = Entries ; i &lt; Count ; i++, Entry++ ) <br>        { <br>            Entry-&gt;peRed   = ComponentFromIndex(i, Pfd-&gt;cRedBits, <br>                                    Pfd-&gt;cRedShift); <br>            Entry-&gt;peGreen = ComponentFromIndex(i, Pfd-&gt;cGreenBits, <br>                                    Pfd-&gt;cGreenShift); <br>            Entry-&gt;peBlue  = ComponentFromIndex(i, Pfd-&gt;cBlueBits, <br>                                    Pfd-&gt;cBlueShift); <br>            Entry-&gt;peFlags = PALETTE_FLAGS; <br>        } <br> <br>        if ( 256 == Count) <br>        { <br>        // If app set static system color usage for fixed palette support, <br>        // setup to take over the static colors.  Otherwise, fixup the <br>        // static system colors. <br> <br>            if ( tkUseStaticColors ) <br>            { <br>            // Black and white already exist as the only remaining static <br>            // colors.  Let those remap.  All others should be put into <br>            // the palette (i.e., set PC_NOCOLLAPSE). <br> <br>                Entries[0].peFlags = 0; <br>                Entries[255].peFlags = 0; <br>            } <br>            else <br>            { <br>            // The defaultOverride array is computed assuming a 332 <br>            // palette where red has zero shift, etc. <br> <br>                if ( (3 == Pfd-&gt;cRedBits)   &amp;&amp; (0 == Pfd-&gt;cRedShift)   &amp;&amp; <br>                     (3 == Pfd-&gt;cGreenBits) &amp;&amp; (3 == Pfd-&gt;cGreenShift) &amp;&amp; <br>                     (2 == Pfd-&gt;cBlueBits)  &amp;&amp; (6 == Pfd-&gt;cBlueShift) ) <br>                { <br>                    UpdateStaticMapping(Entries); <br>                     <br>                    for ( i = 0 ; i &lt; STATIC_COLORS ; i++) <br>                    { <br>                        Entries[aiDefaultOverride[i]] = apeDefaultPalEntry[i]; <br>                    } <br>                } <br>            } <br>        } <br>    } <br>    return( Entries ); <br>} <br> <br>static HPALETTE <br>CreateRGBPalette( HDC Dc ) <br>{ <br>    PIXELFORMATDESCRIPTOR Pfd, *pPfd; <br>    LOGPALETTE *LogPalette; <br>    UINT Count; <br> <br>    if ( NULL == tkhpalette ) <br>    { <br>        pPfd = &amp;Pfd; <br> <br>        if ( PixelFormatDescriptorFromDc( Dc, pPfd ) ) <br>        { <br>            /* <br>             *  Make sure we need a palette <br>             */ <br> <br>            if ( (pPfd-&gt;iPixelType == PFD_TYPE_RGBA) &amp;&amp; <br>                 (pPfd-&gt;dwFlags &amp; PFD_NEED_PALETTE) ) <br>            { <br>                /* <br>                 *  Note how palette is to be realized.  Take over the <br>                 *  system colors if either the pixel format requires it <br>                 *  or the app wants it. <br>                 */ <br>                tkUseStaticColors = ( pPfd-&gt;dwFlags &amp; PFD_NEED_SYSTEM_PALETTE ) <br>                                    || TK_USE_FIXED_332_PAL(windInfo.type); <br> <br>                Count       = 1 &lt;&lt; pPfd-&gt;cColorBits; <br>                LogPalette  = AllocateMemory( sizeof(LOGPALETTE) + <br>                                Count * sizeof(PALETTEENTRY)); <br> <br>                if ( NULL != LogPalette ) <br>                { <br>                    LogPalette-&gt;palVersion    = 0x300; <br>                    LogPalette-&gt;palNumEntries = Count; <br> <br>                    FillRgbPaletteEntries( pPfd, <br>                                           &amp;LogPalette-&gt;palPalEntry[0], <br>                                           Count ); <br> <br>                    tkhpalette = CreatePalette(LogPalette); <br>                    FreeMemory(LogPalette); <br> <br>                    RealizePaletteNow( Dc, tkhpalette, FALSE ); <br>                } <br>            } <br>        } <br>    } <br>    return( tkhpalette ); <br>} <br> <br>static HPALETTE <br>CreateCIPalette( HDC Dc ) <br>{ <br>    PIXELFORMATDESCRIPTOR Pfd; <br>    LOGPALETTE *LogicalPalette; <br>    HPALETTE StockPalette; <br>    UINT PaletteSize, StockPaletteSize, EntriesToCopy; <br> <br>    if ( (Dc != NULL) &amp;&amp; (NULL == tkhpalette) ) <br>    { <br>        if ( PixelFormatDescriptorFromDc( Dc, &amp;Pfd ) ) <br>        { <br>            if ( Pfd.iPixelType == PFD_TYPE_COLORINDEX ) <br>            { <br>                /* <br>                 *  Note how palette is to be realized (Is this the correct place to do this?) <br>                 */ <br>                tkUseStaticColors = ( Pfd.dwFlags &amp; PFD_NEED_SYSTEM_PALETTE ) <br>                                    || TK_USE_FIXED_332_PAL(windInfo.type); <br> <br>                /* <br>                 *  Limit the size of the palette to 256 colors. <br>                 *  Why? Because this is what was decided. <br>                 */ <br> <br>                PaletteSize = (Pfd.cColorBits &gt;= 8) ? 256 : (1 &lt;&lt; Pfd.cColorBits); <br> <br>                LogicalPalette = AllocateZeroedMemory( sizeof(LOGPALETTE) + <br>                                        (PaletteSize * sizeof(PALETTEENTRY)) ); <br> <br>                if ( NULL != LogicalPalette ) <br>                { <br>                    LogicalPalette-&gt;palVersion    = 0x300; <br>                    LogicalPalette-&gt;palNumEntries = PaletteSize; <br> <br>                    StockPalette     = GetStockObject(DEFAULT_PALETTE); <br>                    StockPaletteSize = GetPaletteEntries( StockPalette, 0, 0, NULL ); <br> <br>                    /* <br>                     *  start by copying default palette into new one <br>                     */ <br> <br>                    EntriesToCopy = StockPaletteSize &lt; PaletteSize ? <br>                                        StockPaletteSize : PaletteSize; <br> <br>                    GetPaletteEntries( StockPalette, 0, EntriesToCopy, <br>                                        LogicalPalette-&gt;palPalEntry ); <br> <br>                    /* <br>                     *  If we are taking possession of the system colors, <br>                     *  must guarantee that 0 and 255 are black and white <br>                     *  (respectively). <br>                     */ <br> <br>                    if ( tkUseStaticColors &amp;&amp; PaletteSize == 256 ) <br>                    { <br>                        int i; <br> <br>                        LogicalPalette-&gt;palPalEntry[0].peRed = <br>                        LogicalPalette-&gt;palPalEntry[0].peGreen = <br>                        LogicalPalette-&gt;palPalEntry[0].peBlue = 0x00; <br> <br>                        LogicalPalette-&gt;palPalEntry[255].peRed = <br>                        LogicalPalette-&gt;palPalEntry[255].peGreen = <br>                        LogicalPalette-&gt;palPalEntry[255].peBlue = 0xFF; <br> <br>                        LogicalPalette-&gt;palPalEntry[0].peFlags = <br>                        LogicalPalette-&gt;palPalEntry[255].peFlags = 0; <br> <br>                        /* <br>                         *  All other entries should be remappable, <br>                         *  so mark them as PC_NOCOLLAPSE. <br>                         */ <br>                        for ( i = 1; i &lt; 255; i++ ) <br>                            LogicalPalette-&gt;palPalEntry[i].peFlags = PC_NOCOLLAPSE; <br>                    } <br> <br>                    tkhpalette = CreatePalette(LogicalPalette); <br> <br>                    FreeMemory(LogicalPalette); <br> <br>                    RealizePaletteNow( Dc, tkhpalette, FALSE ); <br>                } <br>            } <br>        } <br>    } <br>    return( tkhpalette ); <br>} <br> <br>static BOOL <br>FindPixelFormat(HDC hdc, GLenum type) <br>{ <br>    PIXELFORMATDESCRIPTOR pfd; <br>    int PfdIndex; <br>    BOOL Result = FALSE; <br> <br>    if ( TK_MINIMUM_CRITERIA == windInfo.dmPolicy ) <br>        PfdIndex = FindBestPixelFormat(hdc, type, &amp;pfd); <br>    else if ( TK_EXACT_MATCH == windInfo.dmPolicy ) <br>        PfdIndex = FindExactPixelFormat(hdc, type, &amp;pfd); <br>    else if ( IsPixelFormatValid(hdc, windInfo.ipfd, &amp;pfd) ) <br>        PfdIndex = windInfo.ipfd; <br>    else <br>        PfdIndex = 0; <br> <br>    if ( PfdIndex ) <br>    { <br>        if ( SetPixelFormat(hdc, PfdIndex, &amp;pfd) ) <br>        { <br>            /* <br>             *  If this pixel format requires a palette do it now. <br>             *  In colorindex mode, create a logical palette only <br>             *  if the application needs to modify it. <br>             */ <br> <br>            CreateRGBPalette( hdc ); <br>            Result = TRUE; <br>        } <br>        else <br>        { <br>            PrintMessage("SetPixelFormat failed\n"); <br>        } <br>    } <br>    else <br>    { <br>        PrintMessage("Selecting a pixel format failed\n"); <br>    } <br>    return(Result); <br>} <br> <br>static int <br>FindBestPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd) <br>{ <br>    PIXELFORMATDESCRIPTOR pfd; <br> <br>    pfd.nSize       = sizeof(pfd); <br>    pfd.nVersion    = 1; <br>    pfd.dwFlags     = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL; <br> <br>    if (TK_IS_DOUBLE(type)) <br>        pfd.dwFlags |= PFD_DOUBLEBUFFER; <br> <br>    if (TK_IS_INDEX(type)) { <br>        pfd.iPixelType = PFD_TYPE_COLORINDEX; <br>        pfd.cColorBits = 8; <br>    } else { <br>        pfd.iPixelType = PFD_TYPE_RGBA; <br>        pfd.cColorBits = 24; <br>    } <br> <br>    if (TK_HAS_ALPHA(type)) <br>        pfd.cAlphaBits = 8; <br>    else <br>        pfd.cAlphaBits = 0; <br> <br>    if (TK_HAS_ACCUM(type)) <br>        pfd.cAccumBits = pfd.cColorBits + pfd.cAlphaBits; <br>    else <br>        pfd.cAccumBits = 0; <br> <br>    if (TK_HAS_DEPTH(type)) { <br>        if (TK_IS_DEPTH16(type)) <br>            pfd.cDepthBits = 16; <br>        else <br>            pfd.cDepthBits = 32; <br>    } else { <br>        pfd.cDepthBits = 0; <br>    } <br> <br>    if (TK_HAS_STENCIL(type)) <br>        pfd.cStencilBits = 4; <br>    else <br>        pfd.cStencilBits = 0; <br> <br>    pfd.cAuxBuffers = 0; <br>    pfd.iLayerType  = PFD_MAIN_PLANE; <br>    *ppfd = pfd; <br> <br>    return ( ChoosePixelFormat(hdc, &amp;pfd) ); <br>} <br> <br>static int <br>FindExactPixelFormat(HDC hdc, GLenum type, PIXELFORMATDESCRIPTOR *ppfd) <br>{ <br>    int i, MaxPFDs, Score, BestScore, BestPFD; <br>    PIXELFORMATDESCRIPTOR pfd; <br> <br>    i = 1; <br>    BestPFD = BestScore = 0; <br>    do <br>    { <br>        MaxPFDs = DescribePixelFormat(hdc, i, sizeof(pfd), &amp;pfd); <br>        if ( MaxPFDs &lt;= 0 ) <br>            return ( 0 ); <br> <br>        Score = 0; <br>        if ( !( ( pfd.dwFlags &amp; PFD_DRAW_TO_WINDOW ) &amp;&amp; <br>                ( pfd.dwFlags &amp; PFD_SUPPORT_OPENGL ) ) ) <br>            continue; <br>        if ( pfd.iLayerType != PFD_MAIN_PLANE ) <br>            continue; <br>        if ( ( pfd.iPixelType == PFD_TYPE_RGBA ) &amp;&amp; ( TK_IS_INDEX(type) ) ) <br>            continue; <br>        if ( ( pfd.iPixelType == PFD_TYPE_COLORINDEX ) &amp;&amp; ( TK_IS_RGB(type) ) ) <br>            continue; <br>        if ( ( pfd.dwFlags &amp; PFD_DOUBLEBUFFER ) &amp;&amp; ( TK_IS_SINGLE(type) ) ) <br>            continue; <br>        if ( !( pfd.dwFlags &amp; PFD_DOUBLEBUFFER ) &amp;&amp; ( TK_IS_DOUBLE(type) ) ) <br>            continue; <br> <br>/* If accum requested then accum rgb size must be &gt; 0 */ <br>/* If alpha requested then alpha size must be &gt; 0 */ <br>/* if accum &amp; alpha requested then accum alpha size must be &gt; 0 */ <br>        if ( TK_IS_RGB(type) ) <br>        { <br>            if ( TK_HAS_ACCUM(type) ) <br>            { <br>                if (  pfd.cAccumBits &lt;= 0 ) <br>                    continue; <br>            } <br>            else <br>            { <br>                if ( pfd.cAccumBits &gt; 0 ) <br>                    continue; <br>            } <br> <br>            if ( TK_HAS_ALPHA(type) ) <br>            { <br>                if ( pfd.cAlphaBits &lt;= 0 ) <br>                    continue; <br>                if ( TK_HAS_ACCUM(type) &amp;&amp; pfd.cAccumAlphaBits &lt;= 0 ) <br>                    continue; <br>            } <br>            else <br>            { <br>                if ( pfd.cAlphaBits &gt; 0 ) <br>                    continue; <br>            } <br>        } <br> <br>        if ( TK_HAS_DEPTH(type) ) <br>        { <br>            if ( pfd.cDepthBits &lt;= 0 ) <br>                continue; <br>        } <br>        else <br>        { <br>            if ( pfd.cDepthBits &gt; 0 ) <br>                continue; <br>        } <br> <br>        if ( TK_HAS_STENCIL(type) ) <br>        { <br>            if ( pfd.cStencilBits &lt;= 0 ) <br>                continue; <br>        } <br>        else <br>        { <br>            if ( pfd.cStencilBits &gt; 0 ) <br>                continue; <br>        } <br> <br>        Score = pfd.cColorBits; <br> <br>        if (Score &gt; BestScore) <br>        { <br>            BestScore = Score; <br>            BestPFD = i; <br>            *ppfd = pfd; <br>        } <br>    } while (++i &lt;= MaxPFDs); <br> <br>    return ( BestPFD ); <br>} <br> <br>static BOOL IsPixelFormatValid(HDC hdc, int ipfd, PIXELFORMATDESCRIPTOR *ppfd) <br>{ <br>    if ( ipfd &gt; 0 ) <br>    { <br>        if ( ipfd &lt;= DescribePixelFormat(hdc, ipfd, sizeof(*ppfd), ppfd) ) <br>        { <br>            if ( ( ppfd-&gt;dwFlags &amp; PFD_DRAW_TO_WINDOW ) &amp;&amp; <br>                 ( ppfd-&gt;dwFlags &amp; PFD_SUPPORT_OPENGL ) ) <br>            { <br>                return ( TRUE ); <br>            } <br>        } <br>    } <br>    return ( FALSE ); <br>} <br> <br> <br>static void <br>PrintMessage( const char *Format, ... ) <br>{ <br>    va_list ArgList; <br>    char Buffer[256]; <br> <br>    va_start(ArgList, Format); <br>    vsprintf(Buffer, Format, ArgList); <br>    va_end(ArgList); <br> <br>    MESSAGEBOX(GetFocus(), Buffer, "Error", MB_OK); <br>} <br> <br>static void <br>DelayPaletteRealization( void ) <br>{ <br>    MSG Message; <br> <br>    TKASSERT(NULL!=tkhwnd); <br> <br>    /* <br>     *  Add a WM_USER message to the queue, if there isn't one there already. <br>     */ <br> <br>    if (!PeekMessage(&amp;Message, tkhwnd, WM_USER, WM_USER, PM_NOREMOVE) ) <br>    { <br>        PostMessage( tkhwnd, WM_USER, 0, 0); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* RealizePaletteNow <br>* <br>* Select the given palette in background or foreground mode (as specified <br>* by the bForceBackground flag), and realize the palette. <br>* <br>* If static system color usage is set, the system colors are replaced. <br>* <br>* History: <br>*  26-Apr-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static long <br>RealizePaletteNow( HDC Dc, HPALETTE Palette, BOOL bForceBackground ) <br>{ <br>    long Result = -1; <br>    BOOL bHaveSysPal = TRUE; <br> <br>    TKASSERT( NULL!=Dc      ); <br>    TKASSERT( NULL!=Palette ); <br> <br>// If static system color usage is set, prepare to take over the <br>// system palette. <br> <br>    if ( tkUseStaticColors ) <br>    { <br>    // If foreground, take over the static colors.  If background, release <br>    // the static colors. <br> <br>        if ( !bForceBackground ) <br>        { <br>        // If GrabStaticEntries succeeds, then it is OK to take over the <br>        // static colors.  If not, then GrabStaticEntries will have <br>        // posted a WM_USER message for us to try again later. <br> <br>            bHaveSysPal = GrabStaticEntries( Dc ); <br>        } <br>        else <br>        { <br>        // If we are currently using the system colors (tkSystemColorsInUse) <br>        // and RealizePaletteNow was called with bForceBackground set, we <br>        // are being deactivated and must release the static system colors. <br> <br>            ReleaseStaticEntries( Dc ); <br>        } <br> <br>    // Rerealize the palette. <br>    // <br>    // If set to TRUE, bForceBackground will force the palette to be realized <br>    // as a background palette, regardless of focus.  This will happen anyway <br>    // if the TK window does not have the keyboard focus. <br> <br>        if ( (bForceBackground || bHaveSysPal) &amp;&amp; <br>             UnrealizeObject( Palette ) &amp;&amp; <br>             NULL != SelectPalette( Dc, Palette, bForceBackground ) ) <br>        { <br>            Result = RealizePalette( Dc ); <br>        } <br>    } <br>    else <br>    { <br>        if ( NULL != SelectPalette( Dc, Palette, FALSE ) ) <br>        { <br>            Result = RealizePalette( Dc ); <br>        } <br>    } <br> <br>    return( Result ); <br>} <br> <br>static void <br>ForceRedraw( HWND Window ) <br>{ <br>    MSG Message; <br> <br>    if (!PeekMessage(&amp;Message, Window, WM_PAINT, WM_PAINT, PM_NOREMOVE) ) <br>    { <br>        InvalidateRect( Window, NULL, FALSE ); <br>    } <br>} <br> <br>static int <br>PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd ) <br>{ <br>    int PfdIndex; <br> <br>    if ( 0 &lt; (PfdIndex = GetPixelFormat( Dc )) ) <br>    { <br>        if ( 0 &lt; DescribePixelFormat( Dc, PfdIndex, sizeof(*Pfd), Pfd ) ) <br>        { <br>            return(PfdIndex); <br>        } <br>        else <br>        { <br>            PrintMessage("Could not get a description of pixel format %d\n", <br>                PfdIndex ); <br>        } <br>    } <br>    else <br>    { <br>        PrintMessage("Could not get pixel format for Dc 0x%08lX\n", Dc ); <br>    } <br>    return( 0 ); <br>} <br> <br>static void <br>DestroyThisWindow( HWND Window ) <br>{ <br>    if ( NULL != Window ) <br>    { <br>        DestroyWindow( Window ); <br>    } <br>} <br> <br>/* <br> *  This Should be called in response to a WM_DESTROY message <br> */ <br> <br>static void <br>CleanUp( void ) <br>{ <br>    HPALETTE hStock; <br> <br>// Cleanup the palette. <br> <br>    if ( NULL != tkhpalette ) <br>    { <br>    // If static system color usage is set, restore the system colors. <br> <br>        if ( tkUseStaticColors ) <br>        { <br>            RealizePaletteNow( tkhdc, GetStockObject(DEFAULT_PALETTE), TRUE ); <br>        } <br>        else <br>        { <br>            if ( hStock = GetStockObject( DEFAULT_PALETTE ) ) <br>                SelectPalette( tkhdc, hStock, FALSE ); <br>        } <br> <br>        DeleteObject( tkhpalette ); <br>    } <br> <br>// Cleanup the RC. <br> <br>    if ( NULL != tkhrc ) <br>    { <br>        wglMakeCurrent( tkhdc, NULL );  // Release first... <br>        wglDeleteContext( tkhrc );      // then delete. <br>    } <br> <br>// Cleanup the DC. <br> <br>    if ( NULL != tkhdc ) <br>    { <br>        ReleaseDC( tkhwnd, tkhdc ); <br>    } <br> <br>// Be really nice and reset global values. <br> <br>    tkhwnd        = NULL; <br>    tkhdc         = NULL; <br>    tkhrc         = NULL; <br>    tkhpalette    = NULL; <br> <br>    ExposeFunc    = NULL; <br>    ReshapeFunc   = NULL; <br>    IdleFunc      = NULL; <br>    DisplayFunc   = NULL; <br>    KeyDownFunc   = NULL; <br>    MouseDownFunc = NULL; <br>    MouseUpFunc   = NULL; <br>    MouseMoveFunc = NULL; <br>} <br> <br>static void * <br>AllocateMemory( size_t Size ) <br>{ <br>    return( LocalAlloc( LMEM_FIXED, Size ) ); <br>} <br> <br>static void * <br>AllocateZeroedMemory( size_t Size ) <br>{ <br>    return( LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Size ) ); <br>} <br> <br> <br>static void <br>FreeMemory( void *Chunk ) <br>{ <br>    TKASSERT( NULL!=Chunk ); <br> <br>    LocalFree( Chunk ); <br>} <br> <br> <br>/******************************************************************* <br> *                                                                 * <br> *  Debugging functions go here                                    * <br> *                                                                 * <br> *******************************************************************/ <br> <br>#if DBGFUNC <br> <br>static void <br>DbgPrintf( const char *Format, ... ) <br>{ <br>    va_list ArgList; <br>    char Buffer[256]; <br> <br>    va_start(ArgList, Format); <br>    vsprintf(Buffer, Format, ArgList); <br>    va_end(ArgList); <br> <br>    printf("%s", Buffer ); <br>    fflush(stdout); <br>} <br> <br>static void <br>pwi( void ) <br>{ <br>    DbgPrintf("windInfo: x %d, y %d, w %d, h %d\n", windInfo.x, windInfo.y, windInfo.width, windInfo.height); <br>} <br> <br>static void <br>pwr(RECT *pr) <br>{ <br>    DbgPrintf("Rect: left %d, top %d, right %d, bottom %d\n", pr-&gt;left, pr-&gt;top, pr-&gt;right, pr-&gt;bottom); <br>} <br> <br>static void <br>ShowPixelFormat(HDC hdc) <br>{ <br>    PIXELFORMATDESCRIPTOR pfd, *ppfd; <br>    int format; <br> <br>    ppfd   = &amp;pfd; <br>    format = PixelFormatDescriptorFromDc( hdc, ppfd ); <br> <br>    DbgPrintf("Pixel format %d\n", format); <br>    DbgPrintf("  dwFlags - 0x%x", ppfd-&gt;dwFlags); <br>        if (ppfd-&gt;dwFlags &amp; PFD_DOUBLEBUFFER) DbgPrintf("PFD_DOUBLEBUFFER "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_STEREO) DbgPrintf("PFD_STEREO "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_DRAW_TO_WINDOW) DbgPrintf("PFD_DRAW_TO_WINDOW "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_DRAW_TO_BITMAP) DbgPrintf("PFD_DRAW_TO_BITMAP "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_SUPPORT_GDI) DbgPrintf("PFD_SUPPORT_GDI "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_SUPPORT_OPENGL) DbgPrintf("PFD_SUPPORT_OPENGL "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_GENERIC_FORMAT) DbgPrintf("PFD_GENERIC_FORMAT "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_NEED_PALETTE) DbgPrintf("PFD_NEED_PALETTE "); <br>        if (ppfd-&gt;dwFlags &amp; PFD_NEED_SYSTEM_PALETTE) DbgPrintf("PFD_NEED_SYSTEM_PALETTE "); <br>        DbgPrintf("\n"); <br>    DbgPrintf("  iPixelType - %d", ppfd-&gt;iPixelType); <br>        if (ppfd-&gt;iPixelType == PFD_TYPE_RGBA) DbgPrintf("PGD_TYPE_RGBA\n"); <br>        if (ppfd-&gt;iPixelType == PFD_TYPE_COLORINDEX) DbgPrintf("PGD_TYPE_COLORINDEX\n"); <br>    DbgPrintf("  cColorBits - %d\n", ppfd-&gt;cColorBits); <br>    DbgPrintf("  cRedBits - %d\n", ppfd-&gt;cRedBits); <br>    DbgPrintf("  cRedShift - %d\n", ppfd-&gt;cRedShift); <br>    DbgPrintf("  cGreenBits - %d\n", ppfd-&gt;cGreenBits); <br>    DbgPrintf("  cGreenShift - %d\n", ppfd-&gt;cGreenShift); <br>    DbgPrintf("  cBlueBits - %d\n", ppfd-&gt;cBlueBits); <br>    DbgPrintf("  cBlueShift - %d\n", ppfd-&gt;cBlueShift); <br>    DbgPrintf("  cAlphaBits - %d\n", ppfd-&gt;cAlphaBits); <br>    DbgPrintf("  cAlphaShift - 0x%x\n", ppfd-&gt;cAlphaShift); <br>    DbgPrintf("  cAccumBits - %d\n", ppfd-&gt;cAccumBits); <br>    DbgPrintf("  cAccumRedBits - %d\n", ppfd-&gt;cAccumRedBits); <br>    DbgPrintf("  cAccumGreenBits - %d\n", ppfd-&gt;cAccumGreenBits); <br>    DbgPrintf("  cAccumBlueBits - %d\n", ppfd-&gt;cAccumBlueBits); <br>    DbgPrintf("  cAccumAlphaBits - %d\n", ppfd-&gt;cAccumAlphaBits); <br>    DbgPrintf("  cDepthBits - %d\n", ppfd-&gt;cDepthBits); <br>    DbgPrintf("  cStencilBits - %d\n", ppfd-&gt;cStencilBits); <br>    DbgPrintf("  cAuxBuffers - %d\n", ppfd-&gt;cAuxBuffers); <br>    DbgPrintf("  iLayerType - %d\n", ppfd-&gt;iLayerType); <br>    DbgPrintf("  bReserved - %d\n", ppfd-&gt;bReserved); <br>    DbgPrintf("  dwLayerMask - 0x%x\n", ppfd-&gt;dwLayerMask); <br>    DbgPrintf("  dwVisibleMask - 0x%x\n", ppfd-&gt;dwVisibleMask); <br>    DbgPrintf("  dwDamageMask - 0x%x\n", ppfd-&gt;dwDamageMask); <br> <br>} <br> <br>#endif  /* DBG */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
