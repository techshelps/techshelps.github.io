<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VECT3D.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3653"></a>VECT3D.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> * ALL RIGHTS RESERVED <br> * Permission to use, copy, modify, and distribute this software for <br> * any purpose and without fee is hereby granted, provided that the above <br> * copyright notice appear in all copies and that both the copyright notice <br> * and this permission notice appear in supporting documentation, and that <br> * the name of Silicon Graphics, Inc. not be used in advertising <br> * or publicity pertaining to distribution of the software without specific, <br> * written prior permission. <br> * <br> * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS" <br> * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, <br> * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR <br> * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON <br> * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT, <br> * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY <br> * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION, <br> * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF <br> * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN <br> * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON <br> * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE <br> * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE. <br> * <br> * US Government Users Restricted Rights <br> * Use, duplication, or disclosure by the Government is subject to <br> * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph <br> * (c)(1)(ii) of the Rights in Technical Data and Computer Software <br> * clause at DFARS 252.227-7013 and/or in similar or successor <br> * clauses in the FAR or the DOD or NASA FAR Supplement. <br> * Unpublished-- rights reserved under the copyright laws of the <br> * United States.  Contractor/manufacturer is Silicon Graphics, <br> * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311. <br> * <br> * OpenGL(TM) is a trademark of Silicon Graphics, Inc. <br> */ <br>/* Routines to manipulate 3 dimensional vectors.  All these routines <br> * should work even if the input and output vectors are the same. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include "3d.h" <br>#include "tk.h" <br> <br>#define static <br> <br>void (*errfunc)(char *) = 0; <br> <br>void seterrorfunc(void (*func)(char *)) <br>{ <br>    errfunc = func; <br>} <br> <br>void error(char *s) <br>{ <br>    if (errfunc) <br>        (*errfunc)(s); <br>    else { <br>        MESSAGEBOX(GetFocus(), s, "Error", MB_OK); <br>        exit(1); <br>    } <br>} <br> <br>void diff3(GLdouble p[3], GLdouble q[3], GLdouble diff[3]) <br>{ <br>    diff[0] = p[0] - q[0]; <br>    diff[1] = p[1] - q[1]; <br>    diff[2] = p[2] - q[2]; <br>} <br> <br>void add3(GLdouble p[3], GLdouble q[3], GLdouble sum[3]) <br>{ <br>    sum[0] = p[0] + q[0]; <br>    sum[1] = p[1] + q[1]; <br>    sum[2] = p[2] + q[2]; <br>} <br> <br>void scalarmult(GLdouble s, GLdouble v[3], GLdouble vout[3]) <br>{ <br>    vout[0] = v[0]*s; <br>    vout[1] = v[1]*s; <br>    vout[2] = v[2]*s; <br>} <br> <br>GLdouble dot3(GLdouble p[3], GLdouble q[3]) <br>{ <br>    return p[0]*q[0] + p[1]*q[1] + p[2]*q[2]; <br>} <br> <br>GLdouble length3(GLdouble v[3]) <br>{ <br>    return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); <br>} <br> <br>GLdouble dist3(GLdouble p[3], GLdouble q[3]) <br>{ <br>    GLdouble d[3]; <br> <br>    diff3(p, q, d); <br>    return length3(d); <br>} <br> <br>void copy3(GLdouble old[3], GLdouble new[3]) <br>{ <br>    new[0] = old[0], new[1] = old[1], new[2] = old[2]; <br>} <br> <br>void crossprod(GLdouble v1[3], GLdouble v2[3], GLdouble prod[3]) <br>{ <br>    GLdouble p[3];      /* in case prod == v1 or v2 */ <br> <br>    p[0] = v1[1]*v2[2] - v2[1]*v1[2]; <br>    p[1] = v1[2]*v2[0] - v2[2]*v1[0]; <br>    p[2] = v1[0]*v2[1] - v2[0]*v1[1]; <br>    prod[0] = p[0]; prod[1] = p[1]; prod[2] = p[2]; <br>} <br> <br>void normalize(GLdouble v[3]) <br>{ <br>    GLdouble d; <br> <br>    d = sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); <br>    if (d == (GLdouble)0.0) { <br>        error("normalize: zero length vector"); <br>        v[0] = d = (GLdouble)1.0; <br>    } <br>    d = (GLdouble)1/d; <br>    v[0] *= d; v[1] *= d; v[2] *= d; <br>} <br> <br>void identifymat3(GLdouble m[3][3]) <br>{ <br>    int i, j; <br> <br>    for (i=0; i&lt;3; i++) <br>        for (j=0; j&lt;3; j++) <br>            m[i][j] = (i == j) ? (GLdouble)1.0 : (GLdouble)0.0; <br>} <br> <br>void copymat3(GLdouble *to, GLdouble *from) <br>{ <br>    int i; <br> <br>    for (i=0; i&lt;9; i++) { <br>        *to++ = *from++; <br>    } <br>} <br> <br>void xformvec3(GLdouble v[3], GLdouble m[3][3], GLdouble vm[3]) <br>{ <br>    GLdouble result[3]; /* in case v == vm */ <br>    int i; <br> <br>    for (i=0; i&lt;3; i++) { <br>        result[i] = v[0]*m[0][i] + v[1]*m[1][i] + v[2]*m[2][i]; <br>    } <br>    for (i=0; i&lt;3; i++) { <br>        vm[i] = result[i]; <br>    } <br>} <br> <br>long samepoint(GLdouble p1[3], GLdouble p2[3]) <br>{ <br>    if (p1[0] == p2[0] &amp;&amp; p1[1] == p2[1] &amp;&amp; p1[2] == p2[2]) <br>        return 1; <br>    return 0; <br>} <br> <br>void perpnorm(GLdouble p1[3], GLdouble p2[3], GLdouble p3[3], GLdouble n[3]) <br>{ <br>    GLdouble d1[3], d2[3]; <br> <br>    diff3(p2, p1, d1); <br>    diff3(p2, p3, d2); <br>    crossprod(d1, d2, n); <br>    normalize(n); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
