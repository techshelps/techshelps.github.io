<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TKDIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3650"></a>TKDIB.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: dib.c <br>* <br>* (Brief description) <br>* <br>* Created: 21-Feb-1994 23:12:58 <br>* Author: Gilman Wong [gilmanw] <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>* (General description of its use) <br>* <br>* Dependencies: <br>* <br>*   (#defines) <br>*   (#includes) <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt;  <br>#include "tk.h" <br> <br>#define static <br> <br>#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER <br> <br>// struct BITMAPFILEHEADER { <br>//      WORD  bfType <br>//      DWORD bfSize <br>//      WORD  bfReserved1 <br>//      WORD  bfReserved2 <br>//      DWORD bfOffBits <br>// } <br>#define OFFSET_bfType       0 <br>#define OFFSET_bfSize       2 <br>#define OFFSET_bfReserved1  6 <br>#define OFFSET_bfReserved2  8 <br>#define OFFSET_bfOffBits    10 <br>#define SIZEOF_BITMAPFILEHEADER 14 <br> <br>// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has <br>// WORD-alignment. <br>#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \ <br>                          | ((DWORD)((PWORD)(pv))[1] &lt;&lt; 16) )   \ <br> <br>// Computes the number of BYTES needed to contain n number of bits. <br>#define BITS2BYTES(n)   ( ((n) + 7) &gt;&gt; 3 ) <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibNumColors(VOID FAR * pv)                                * <br> *                                                                          * <br> *  PURPOSE    : Determines the number of colors in the DIB by looking at   * <br> *               the BitCount filed in the info block.                      * <br> *                                                                          * <br> *  RETURNS    : The number of colors in the DIB.                           * <br> *                                                                          * <br> * Stolen from SDK ShowDIB example.                                         * <br> ****************************************************************************/ <br> <br>WORD DibNumColors(VOID FAR * pv) <br>{ <br>    WORD                bits; <br>    BITMAPINFOHEADER UNALIGNED *lpbi; <br>    BITMAPCOREHEADER UNALIGNED *lpbc; <br> <br>    lpbi = ((LPBITMAPINFOHEADER)pv); <br>    lpbc = ((LPBITMAPCOREHEADER)pv); <br> <br>    /*  With the BITMAPINFO format headers, the size of the palette <br>     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it <br>     *  is dependent on the bits per pixel ( = 2 raised to the power of <br>     *  bits/pixel). <br>     * <br>     *  Because of the way we use this call, BITMAPINFOHEADER may be out <br>     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro <br>     *  to safely access DWORD fields. <br>     */ <br>    if (READDWORD(&amp;lpbi-&gt;biSize) != sizeof(BITMAPCOREHEADER)){ <br>        if (READDWORD(&amp;lpbi-&gt;biClrUsed) != 0) <br>        { <br>            return (WORD) READDWORD(&amp;lpbi-&gt;biClrUsed); <br>        } <br>        bits = lpbi-&gt;biBitCount; <br>    } <br>    else <br>        bits = lpbc-&gt;bcBitCount; <br> <br>    switch (bits){ <br>        case 1: <br>            return 2; <br>        case 4: <br>            return 16; <br>        case 8: <br>            return 256; <br>        default: <br>            /* A 24 bitcount DIB has no color table */ <br>            return 0; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* tkDIBImageLoad <br>* <br>* ANSI version stub.  Only here for orthogonality with tkRGBImageLoad. <br>* <br>* History: <br>*  22-Feb-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>TK_RGBImageRec *tkDIBImageLoadAW(char *fileName, BOOL bUnicode); <br> <br>TK_RGBImageRec *tkDIBImageLoad(char *fileName) <br>{ <br>    return tkDIBImageLoadAW(fileName, FALSE); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* tkDIBImageLoadAW <br>* <br>* Loads a DIB file (specified as either an ANSI or Unicode filename, <br>* depending on the bUnicode flag) and converts it into a TK image format. <br>* <br>* The technique used is based on CreateDIBSection and SetDIBits. <br>* CreateDIBSection is used to create a DIB with a format easily converted <br>* into the TK image format (packed 24BPP RGB).  The only conversion  <br>* required is swapping R and B in each RGB triplet (see history below) <br>* The resulting bitmap is selected into a memory DC. <br>* <br>* The DIB file is mapped into memory and SetDIBits called to initialize <br>* the memory DC bitmap.  It is during this step that GDI converts the <br>* arbitrary DIB file format to RGB format. <br>* <br>* Finally, the RGB data in the DIB section is read out and repacked <br>* as 24BPP 'BGR'. <br>* <br>* Returns: <br>*   Pointer to TK_RGBImageRec.  If an error occurs, a diagnostic error <br>*   message is put into the error stream and tkQuit() is called, <br>*   terminating the app. <br>* <br>* History: <br>*  - 22-Feb-1994 -by- Gilman Wong [gilmanw] <br>*    Wrote it. <br>* <br>*  - 01-May-1995 : [marcfo] <br>*    Don't quit if can't open DIB file - return NULL. <br>* <br>*  - 27-Jul-1995 : [marcfo] <br>*    Changed CreateDIBSection to create an RGB mapping, so this would work <br>*    on win95.  Swapping of R and B required, to generate BGR (R=low byte) <br>*    for GL.  If the GL 'BGR' (R=high byte) extension becomes part of api <br>*    in OpenGL 2.0, then we can avoid swap and do a memcpy to grab the bits. <br>* <br>\**************************************************************************/ <br> <br>TK_RGBImageRec *tkDIBImageLoadAW(char *fileName, BOOL bUnicode) <br>{ <br>    TK_RGBImageRec *final = (TK_RGBImageRec *) NULL; // Ptr to TK image struct <br>                                                     // to return.  Non-NULL <br>                                                     // only for success. <br> <br>    WORD             wNumColors;    // Number of colors in color table <br>    BITMAPFILEHEADER *pbmf;         // Ptr to file header <br>    BITMAPINFOHEADER UNALIGNED *pbmihFile; <br>    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists) <br>    PVOID            pvBitsFile;    // Ptr to bitmap bits in file <br>    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section <br>    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits <br>    PBYTE            pjSrc;         // Ptr to image file used for conversion <br>    PBYTE            pjDst;         // Ptr to TK image used for conversion <br> <br>    // These need to be cleaned up when we exit: <br>    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle <br>    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle <br>    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file <br>    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC <br>    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap <br>    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO <br>    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO <br> <br>    int i, j; <br>    int padBytes; <br> <br>// Map the DIB file into memory. <br> <br>    hFile = bUnicode ?  <br>            CreateFileW((LPWSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, <br>                        OPEN_EXISTING, 0, 0) : <br>            CreateFileA((LPSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL,  <br>                        OPEN_EXISTING, 0, 0); <br> <br>    if (hFile == INVALID_HANDLE_VALUE) <br>        goto tkDIBLoadImage_cleanup; <br> <br>    hMap = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL); <br>    if (!hMap) <br>        goto tkDIBLoadImage_cleanup; <br> <br>    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0); <br>    if (!pvFile) <br>        goto tkDIBLoadImage_cleanup; <br> <br>// Check the file header.  If the BFT_BITMAP magic number is there, <br>// then the file format is a BITMAPFILEHEADER followed immediately <br>// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap <br>// bits, in this case, are located at the offset bfOffBits from the <br>// BITMAPFILEHEADER. <br>// <br>// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER <br>// followed immediately with the color table and the bitmap bits. <br> <br>    pbmf = (BITMAPFILEHEADER *) pvFile; <br> <br>    if ( pbmf-&gt;bfType == BFT_BITMAP ) <br>    { <br>        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER); <br> <br>    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD <br>    // bfOffBits field. <br> <br>        pvBitsFile = (PVOID *) ((PBYTE) pbmf <br>                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits)); <br>    } <br>    else <br>    { <br>        pbmihFile = (BITMAPINFOHEADER *) pvFile; <br> <br>    // Determination of where the bitmaps bits are needs to wait until we <br>    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER. <br>    } <br> <br>// Determine the number of colors in the DIB palette.  This is non-zero <br>// only for 8BPP or less. <br> <br>    wNumColors = DibNumColors(pbmihFile); <br> <br>// Create a BITMAPINFO (with color table) for the DIB file.  Because the <br>// file may not have one (BITMAPCORE case) and potential alignment problems, <br>// we will create a new one in memory we allocate. <br>// <br>// We distinguish between BITMAPINFO and BITMAPCORE cases based upon <br>// BITMAPINFOHEADER.biSize. <br> <br>    pbmiSource = (BITMAPINFO *) <br>        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO) <br>                               + wNumColors * sizeof(RGBQUAD)); <br>    if (!pbmiSource) <br>    { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    // Note: need to use safe READDWORD macro because pbmihFile may <br>    // have only WORD alignment if it follows a BITMAPFILEHEADER. <br> <br>    switch (READDWORD(&amp;pbmihFile-&gt;biSize)) <br>    { <br>    case sizeof(BITMAPINFOHEADER): <br> <br>    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO. <br> <br>        pbmiSource-&gt;bmiHeader.biSize          = sizeof(BITMAPINFOHEADER); <br>        pbmiSource-&gt;bmiHeader.biWidth         = READDWORD(&amp;pbmihFile-&gt;biWidth); <br>        pbmiSource-&gt;bmiHeader.biHeight        = READDWORD(&amp;pbmihFile-&gt;biHeight); <br>        pbmiSource-&gt;bmiHeader.biPlanes        = pbmihFile-&gt;biPlanes; <br>        pbmiSource-&gt;bmiHeader.biBitCount      = pbmihFile-&gt;biBitCount; <br>        pbmiSource-&gt;bmiHeader.biCompression   =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biCompression); <br>        pbmiSource-&gt;bmiHeader.biSizeImage     =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biSizeImage); <br>        pbmiSource-&gt;bmiHeader.biXPelsPerMeter =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biXPelsPerMeter); <br>        pbmiSource-&gt;bmiHeader.biYPelsPerMeter =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biYPelsPerMeter); <br>        pbmiSource-&gt;bmiHeader.biClrUsed       =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biClrUsed); <br>        pbmiSource-&gt;bmiHeader.biClrImportant  =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biClrImportant); <br> <br>    // Copy color table.  It immediately follows the BITMAPINFOHEADER. <br> <br>        memcpy((PVOID) &amp;pbmiSource-&gt;bmiColors[0], (PVOID) (pbmihFile + 1), <br>               wNumColors * sizeof(RGBQUAD)); <br> <br>    // If we haven't already determined the position of the image bits, <br>    // we may now assume that they immediately follow the color table. <br> <br>        if (!pvBitsFile) <br>            pvBitsFile = (PVOID) ((PBYTE) (pbmihFile + 1) <br>                         + wNumColors * sizeof(RGBQUAD)); <br>        break; <br> <br>    case sizeof(BITMAPCOREHEADER): <br>        pbmchFile = (BITMAPCOREHEADER *) pbmihFile; <br> <br>    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER. <br> <br>        pbmiSource-&gt;bmiHeader.biSize          = sizeof(BITMAPINFOHEADER); <br>        pbmiSource-&gt;bmiHeader.biWidth         = (DWORD) pbmchFile-&gt;bcWidth; <br>        pbmiSource-&gt;bmiHeader.biHeight        = (DWORD) pbmchFile-&gt;bcHeight; <br>        pbmiSource-&gt;bmiHeader.biPlanes        = pbmchFile-&gt;bcPlanes; <br>        pbmiSource-&gt;bmiHeader.biBitCount      = pbmchFile-&gt;bcBitCount; <br>        pbmiSource-&gt;bmiHeader.biCompression   = BI_RGB; <br>        pbmiSource-&gt;bmiHeader.biSizeImage     = 0; <br>        pbmiSource-&gt;bmiHeader.biXPelsPerMeter = 0; <br>        pbmiSource-&gt;bmiHeader.biYPelsPerMeter = 0; <br>        pbmiSource-&gt;bmiHeader.biClrUsed       = wNumColors; <br>        pbmiSource-&gt;bmiHeader.biClrImportant  = wNumColors; <br> <br>    // Convert RGBTRIPLE color table into RGBQUAD color table. <br> <br>        { <br>            RGBQUAD *rgb4 = pbmiSource-&gt;bmiColors; <br>            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1); <br> <br>            for (i = 0; i &lt; wNumColors; i++) <br>            { <br>                rgb4-&gt;rgbRed   = rgb3-&gt;rgbtRed  ; <br>                rgb4-&gt;rgbGreen = rgb3-&gt;rgbtGreen; <br>                rgb4-&gt;rgbBlue  = rgb3-&gt;rgbtBlue ; <br>                rgb4-&gt;rgbReserved = 0; <br> <br>                rgb4++; <br>                rgb3++; <br>            } <br>        } <br> <br>    // If we haven't already determined the position of the image bits, <br>    // we may now assume that they immediately follow the color table. <br> <br>        if (!pvBitsFile) <br>            pvBitsFile = (PVOID) ((PBYTE) (pbmihFile + 1) <br>                         + wNumColors * sizeof(RGBTRIPLE)); <br>        break; <br> <br>    default: <br>        MESSAGEBOX(GetFocus(), "Unknown DIB file format.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>// Fill in default values (for fields that can have defaults). <br> <br>    if (pbmiSource-&gt;bmiHeader.biSizeImage == 0) <br>        pbmiSource-&gt;bmiHeader.biSizeImage =  <br>            BITS2BYTES( (DWORD) pbmiSource-&gt;bmiHeader.biWidth *  <br>                                pbmiSource-&gt;bmiHeader.biBitCount ) *  <br>                                pbmiSource-&gt;bmiHeader.biHeight; <br>    if (pbmiSource-&gt;bmiHeader.biClrUsed == 0) <br>        pbmiSource-&gt;bmiHeader.biClrUsed = wNumColors; <br> <br>// Create memory DC. <br> <br>    hdcMem = CreateCompatibleDC(NULL); <br>    if (!hdcMem) { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>// Create a 24BPP RGB DIB section and select it into the memory DC. <br> <br>    pbmiRGB = (BITMAPINFO *) <br>              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) ); <br>    if (!pbmiRGB) <br>    { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    pbmiRGB-&gt;bmiHeader.biSize          = sizeof(BITMAPINFOHEADER); <br>    pbmiRGB-&gt;bmiHeader.biWidth         = pbmiSource-&gt;bmiHeader.biWidth; <br>    pbmiRGB-&gt;bmiHeader.biHeight        = pbmiSource-&gt;bmiHeader.biHeight; <br>    pbmiRGB-&gt;bmiHeader.biPlanes        = 1; <br>    pbmiRGB-&gt;bmiHeader.biBitCount      = 24; <br>    pbmiRGB-&gt;bmiHeader.biCompression   = BI_RGB; <br>    pbmiRGB-&gt;bmiHeader.biSizeImage     = pbmiRGB-&gt;bmiHeader.biWidth <br>                                         * abs(pbmiRGB-&gt;bmiHeader.biHeight) * 3; <br> <br>    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS,  <br>                              (PVOID *) &amp;pjBitsRGB, NULL, 0); <br> <br>    if (!hbmRGB) <br>    { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK);  <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    if (!SelectObject(hdcMem, hbmRGB)) <br>    { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>// Slam the DIB file image into the memory DC.  GDI will do the work of <br>// translating whatever format the DIB file has into RGB format. <br> <br>    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource-&gt;bmiHeader.biHeight,  <br>                   pvBitsFile, pbmiSource, DIB_RGB_COLORS)) <br>    { <br>        MESSAGEBOX(GetFocus(), "Image file conversion error.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br>    GdiFlush();     // make sure that SetDIBits executes <br> <br>// Convert to TK image format (packed RGB format). <br>// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app <br>// can deallocate with free()). <br> <br>    pjTKBits = (PBYTE) malloc(pbmiRGB-&gt;bmiHeader.biSizeImage); <br>    if (!pjTKBits) <br>    { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    pjSrc = pjBitsRGB; <br>    pjDst = pjTKBits; <br>    // src lines end on LONG boundary - so need to skip over any padding bytes <br>    padBytes = pbmiSource-&gt;bmiHeader.biWidth % sizeof(LONG); <br>    for (i = 0; i &lt; pbmiSource-&gt;bmiHeader.biHeight; i++) <br>    { <br>        for (j = 0; j &lt; pbmiSource-&gt;bmiHeader.biWidth; j++) <br>        { <br>            // swap R and B <br>            *pjDst++ = pjSrc[2]; <br>            *pjDst++ = pjSrc[1]; <br>            *pjDst++ = pjSrc[0]; <br>            pjSrc += 3; <br>        } <br>        pjSrc += padBytes; <br>    } <br> <br>// Allocate and initialize the TK_RGBImageRec. <br>// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app <br>// can deallocate with free()). <br> <br>    final = (TK_RGBImageRec *)malloc(sizeof(TK_RGBImageRec)); <br>    if (final == NULL) { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        goto tkDIBLoadImage_cleanup; <br>    } <br>    // If we get to here, we have suceeded! <br>    final-&gt;sizeX = pbmiSource-&gt;bmiHeader.biWidth; <br>    final-&gt;sizeY = pbmiSource-&gt;bmiHeader.biHeight; <br>    final-&gt;data = pjTKBits; <br> <br>// Cleanup objects. <br> <br>tkDIBLoadImage_cleanup: <br>    { <br>        if (hdcMem) <br>            DeleteDC(hdcMem); <br> <br>        if (hbmRGB) <br>            DeleteObject(hbmRGB); <br> <br>        if (pbmiRGB) <br>            LocalFree(pbmiRGB); <br> <br>        if (pbmiSource) <br>            LocalFree(pbmiSource); <br> <br>        if (pvFile) <br>            UnmapViewOfFile(pvFile); <br> <br>        if (hMap) <br>            CloseHandle(hMap); <br> <br>        if (hFile != INVALID_HANDLE_VALUE) <br>            CloseHandle(hFile); <br>    } <br> <br>// Check for error. <br> <br>    if (!final) <br>    { <br>        if (pjTKBits) <br>            free(pjTKBits); <br> <br>        if ( (hFile == INVALID_HANDLE_VALUE) || !hMap || !pvFile ) <br>        { <br>            CHAR ach[256]; <br> <br>            bUnicode ? wsprintf(ach, "Failed to open DIB file %ws.\n", fileName) : <br>                       wsprintf(ach, "Failed to open DIB file %s.\n", fileName); <br> <br>            MESSAGEBOX(GetFocus(), ach, "Error", MB_OK); <br>        } <br>    } <br> <br>    return final; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
