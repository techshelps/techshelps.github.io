<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHAPES.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3645"></a>SHAPES.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> * ALL RIGHTS RESERVED <br> * Permission to use, copy, modify, and distribute this software for <br> * any purpose and without fee is hereby granted, provided that the above <br> * copyright notice appear in all copies and that both the copyright notice <br> * and this permission notice appear in supporting documentation, and that <br> * the name of Silicon Graphics, Inc. not be used in advertising <br> * or publicity pertaining to distribution of the software without specific, <br> * written prior permission. <br> * <br> * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS" <br> * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, <br> * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR <br> * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON <br> * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT, <br> * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY <br> * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION, <br> * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF <br> * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN <br> * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON <br> * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE <br> * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE. <br> * <br> * US Government Users Restricted Rights <br> * Use, duplication, or disclosure by the Government is subject to <br> * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph <br> * (c)(1)(ii) of the Rights in Technical Data and Computer Software <br> * clause at DFARS 252.227-7013 and/or in similar or successor <br> * clauses in the FAR or the DOD or NASA FAR Supplement. <br> * Unpublished-- rights reserved under the copyright laws of the <br> * United States.  Contractor/manufacturer is Silicon Graphics, <br> * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311. <br> * <br> * OpenGL(TM) is a trademark of Silicon Graphics, Inc. <br> */ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include &lt;GL/glu.h&gt; <br>#include &lt;gl/glaux.h&gt; <br>#include "3d.h" <br> <br>#define static <br> <br>#define SPHEREWIRE      0 <br>#define CUBEWIRE        1 <br>#define BOXWIRE         2 <br>#define TORUSWIRE       3 <br>#define CYLINDERWIRE    4 <br>#define ICOSAWIRE       5 <br>#define OCTAWIRE        6 <br>#define TETRAWIRE       7 <br>#define DODECAWIRE      8 <br>#define CONEWIRE        9 <br>#define SPHERESOLID     10 <br>#define CUBESOLID       11 <br>#define BOXSOLID        12 <br>#define TORUSSOLID      13 <br>#define CYLINDERSOLID   14 <br>#define ICOSASOLID      15 <br>#define OCTASOLID       16 <br>#define TETRASOLID      17 <br>#define DODECASOLID     18 <br>#define CONESOLID       19 <br> <br>#define PI ((GLdouble)3.1415926535897) <br> <br>/*      structure for each geometric object     */ <br>typedef struct model { <br>    GLuint list;        /*  display list to render object   */ <br>    struct model *ptr;  /*  pointer to next object      */ <br>    int numParam;       /*  # of parameters             */ <br>    GLdouble *params;   /*  array with parameters       */ <br>} MODEL, *MODELPTR; <br> <br>/*      array of linked lists--used to keep track of display lists <br> *      for each different type of geometric object. <br> */ <br>static MODELPTR lists[25] = { <br>    NULL, NULL, NULL, NULL, NULL, <br>    NULL, NULL, NULL, NULL, NULL, <br>    NULL, NULL, NULL, NULL, NULL, <br>    NULL, NULL, NULL, NULL, NULL, <br>    NULL, NULL, NULL, NULL, NULL <br>}; <br> <br>GLuint findList (int index, GLdouble *paramArray, int size); <br>int compareParams (GLdouble *oneArray, GLdouble *twoArray, int size); <br>GLuint makeModelPtr (int index, GLdouble *sizeArray, int count); <br> <br>static void drawbox(GLdouble, GLdouble, GLdouble, <br>        GLdouble, GLdouble, GLdouble, GLenum); <br>static void doughnut(GLdouble, GLdouble, GLint, GLint, GLenum); <br>static void icosahedron(GLdouble *, GLdouble, GLenum); <br>static void octahedron(GLdouble *, GLdouble, GLenum); <br>static void tetrahedron(GLdouble *, GLdouble, GLenum); <br>static void subdivide(int, GLdouble *, GLdouble *, GLdouble *, <br>        GLdouble *, GLdouble, GLenum, int); <br>static void drawtriangle(int, int, int, <br>        GLdouble *, GLdouble, GLenum, int); <br>static void recorditem(GLdouble *, GLdouble *, GLdouble *, <br>        GLdouble *, GLdouble, GLenum, int); <br>static void initdodec(void); <br>static void dodecahedron(GLdouble *, GLdouble, GLenum); <br>static void pentagon(int, int, int, int, int, GLenum); <br> <br> <br>/*  Render wire frame or solid sphere.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireSphere (GLdouble radius) <br>{ <br>    GLUquadricObj *quadObj; <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (SPHEREWIRE, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (SPHEREWIRE, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            quadObj = gluNewQuadric (); <br>            gluQuadricDrawStyle (quadObj, GLU_LINE); <br>            gluSphere (quadObj, radius, 16, 16); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidSphere (GLdouble radius) <br>{ <br>    GLUquadricObj *quadObj; <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (SPHERESOLID, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (SPHERESOLID, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            quadObj = gluNewQuadric (); <br>            gluQuadricDrawStyle (quadObj, GLU_FILL); <br>            gluQuadricNormals (quadObj, GLU_SMOOTH); <br>            gluSphere (quadObj, radius, 16, 16); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid cube.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireCube (GLdouble size) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = size; <br>    displayList = findList (CUBEWIRE, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (CUBEWIRE, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            drawbox(-size/(GLdouble)2., size/(GLdouble)2., -size/(GLdouble)2., size/(GLdouble)2., <br>                -size/(GLdouble)2., size/(GLdouble)2., GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidCube (GLdouble size) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = size; <br>    displayList = findList (CUBESOLID, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (CUBESOLID, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            drawbox(-size/(GLdouble)2., size/(GLdouble)2., -size/(GLdouble)2., size/(GLdouble)2., <br>                -size/(GLdouble)2., size/(GLdouble)2., GL_QUADS); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid cube.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireBox (GLdouble width, GLdouble height, GLdouble depth) <br>{ <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 3); <br>    tmp = sizeArray; <br>    *tmp++ = width; <br>    *tmp++ = height; <br>    *tmp++ = depth; <br>    displayList = findList (BOXWIRE, sizeArray, 3); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (BOXWIRE, sizeArray, 3), <br>            GL_COMPILE_AND_EXECUTE); <br>            drawbox(-width/(GLdouble)2., width/(GLdouble)2., -height/(GLdouble)2., height/(GLdouble)2., <br>                -depth/(GLdouble)2., depth/(GLdouble)2., GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidBox (GLdouble width, GLdouble height, GLdouble depth) <br>{ <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 3); <br>    tmp = sizeArray; <br>    *tmp++ = width; <br>    *tmp++ = height; <br>    *tmp++ = depth; <br>    displayList = findList (BOXSOLID, sizeArray, 3); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (BOXSOLID, sizeArray, 3), <br>            GL_COMPILE_AND_EXECUTE); <br>            drawbox(-width/(GLdouble)2., width/(GLdouble)2., -height/(GLdouble)2., height/(GLdouble)2., <br>                -depth/(GLdouble)2., depth/(GLdouble)2., GL_QUADS); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid tori.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireTorus (GLdouble innerRadius, GLdouble outerRadius) <br>{ <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2); <br>    tmp = sizeArray; <br>    *tmp++ = innerRadius; <br>    *tmp++ = outerRadius; <br>    displayList = findList (TORUSWIRE, sizeArray, 2); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (TORUSWIRE, sizeArray, 2), <br>            GL_COMPILE_AND_EXECUTE); <br>            doughnut(innerRadius, outerRadius, 5, 10, GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidTorus (GLdouble innerRadius, GLdouble outerRadius) <br>{ <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2); <br>    tmp = sizeArray; <br>    *tmp++ = innerRadius; <br>    *tmp++ = outerRadius; <br>    displayList = findList (TORUSSOLID, sizeArray, 2); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (TORUSSOLID, sizeArray, 2), <br>            GL_COMPILE_AND_EXECUTE); <br>            doughnut(innerRadius, outerRadius, 8, 15, GL_QUADS); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid cylinders.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireCylinder (GLdouble radius, GLdouble height) <br>{ <br>    GLUquadricObj *quadObj; <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2); <br>    tmp = sizeArray; <br>    *tmp++ = radius; <br>    *tmp++ = height; <br>    displayList = findList (CYLINDERWIRE, sizeArray, 2); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (CYLINDERWIRE, sizeArray, 2), <br>            GL_COMPILE_AND_EXECUTE); <br>            glPushMatrix (); <br>            glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0); <br>            glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0); <br>            quadObj = gluNewQuadric (); <br>            gluQuadricDrawStyle (quadObj, GLU_LINE); <br>            gluCylinder (quadObj, radius, radius, height, 12, 2); <br>            glPopMatrix (); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidCylinder (GLdouble radius, GLdouble height) <br>{ <br>    GLUquadricObj *quadObj; <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2); <br>    tmp = sizeArray; <br>    *tmp++ = radius; <br>    *tmp++ = height; <br>    displayList = findList (CYLINDERWIRE, sizeArray, 2); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (CYLINDERWIRE, sizeArray, 2), <br>            GL_COMPILE_AND_EXECUTE); <br>            glPushMatrix (); <br>            glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0); <br>            glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0); <br>            quadObj = gluNewQuadric (); <br>            gluQuadricDrawStyle (quadObj, GLU_FILL); <br>            gluQuadricNormals (quadObj, GLU_SMOOTH); <br>            gluCylinder (quadObj, radius, radius, height, 12, 2); <br>            glPopMatrix (); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid icosahedra.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireIcosahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (ICOSAWIRE, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (ICOSAWIRE, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            icosahedron (center, radius, GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidIcosahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (ICOSASOLID, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (ICOSASOLID, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            icosahedron (center, radius, GL_TRIANGLES); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid octahedra.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireOctahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (OCTAWIRE, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (OCTAWIRE, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            octahedron (center, radius, GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidOctahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (OCTASOLID, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (OCTASOLID, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            octahedron (center, radius, GL_TRIANGLES); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid tetrahedra.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireTetrahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (TETRAWIRE, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (TETRAWIRE, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            tetrahedron (center, radius, GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidTetrahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (TETRASOLID, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (TETRASOLID, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            tetrahedron (center, radius, GL_TRIANGLES); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid dodecahedra.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireDodecahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (DODECAWIRE, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (DODECAWIRE, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            dodecahedron (center, radius/(GLdouble)1.73, GL_LINE_LOOP); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidDodecahedron (GLdouble radius) <br>{ <br>    GLdouble *sizeArray; <br>    GLuint displayList; <br>    GLdouble center[3] = {(GLdouble)0.0, (GLdouble)0.0, (GLdouble)0.0}; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 1); <br>    *sizeArray = radius; <br>    displayList = findList (DODECASOLID, sizeArray, 1); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (DODECASOLID, sizeArray, 1), <br>            GL_COMPILE_AND_EXECUTE); <br>            dodecahedron (center, radius/(GLdouble)1.73, GL_POLYGON); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/*  Render wire frame or solid cones.  If no display list with <br> *  the current model size exists, create a new display list. <br> */ <br>void auxWireCone (GLdouble base, GLdouble height) <br>{ <br>    GLUquadricObj *quadObj; <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2); <br>    tmp = sizeArray; <br>    *tmp++ = base; <br>    *tmp++ = height; <br>    displayList = findList (CONEWIRE, sizeArray, 2); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (CONEWIRE, sizeArray, 2), <br>            GL_COMPILE_AND_EXECUTE); <br>            quadObj = gluNewQuadric (); <br>            gluQuadricDrawStyle (quadObj, GLU_LINE); <br>            gluCylinder (quadObj, base, (GLdouble)0.0, height, 15, 10); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>void auxSolidCone (GLdouble base, GLdouble height) <br>{ <br>    GLUquadricObj *quadObj; <br>    GLdouble *sizeArray, *tmp; <br>    GLuint displayList; <br> <br>    sizeArray = (GLdouble *) malloc (sizeof (GLdouble) * 2); <br>    tmp = sizeArray; <br>    *tmp++ = base; <br>    *tmp++ = height; <br>    displayList = findList (CONEWIRE, sizeArray, 2); <br> <br>    if (displayList == 0) { <br>        glNewList(makeModelPtr (CONEWIRE, sizeArray, 2), <br>            GL_COMPILE_AND_EXECUTE); <br>            quadObj = gluNewQuadric (); <br>            gluQuadricDrawStyle (quadObj, GLU_FILL); <br>            gluQuadricNormals (quadObj, GLU_SMOOTH); <br>            gluCylinder (quadObj, base, (GLdouble)0.0, height, 15, 10); <br>        glEndList(); <br>    } <br>    else { <br>        glCallList(displayList); <br>        free (sizeArray); <br>    } <br>} <br> <br>/* Routines to build 3 dimensional solids, including: <br> * <br> * drawbox, doughnut, icosahedron, <br> * octahedron, tetrahedron, dodecahedron. <br> */ <br> <br>/* drawbox: <br> * <br> * draws a rectangular box with the given x, y, and z ranges. <br> * The box is axis-aligned. <br> */ <br>void drawbox(GLdouble x0, GLdouble x1, GLdouble y0, GLdouble y1, <br>        GLdouble z0, GLdouble z1, GLenum type) <br>{ <br>    static GLdouble n[6][3] = { <br>        {-1.0, 0.0, 0.0}, {0.0, 1.0, 0.0}, {1.0, 0.0, 0.0}, <br>        {0.0, -1.0, 0.0}, {0.0, 0.0, 1.0}, {0.0, 0.0, -1.0} <br>    }; <br>    static GLint faces[6][4] = { <br>        { 0, 1, 2, 3 }, { 3, 2, 6, 7 }, { 7, 6, 5, 4 }, <br>        { 4, 5, 1, 0 }, { 5, 6, 2, 1 }, { 7, 4, 0, 3 } <br>    }; <br>    GLdouble v[8][3], tmp; <br>    GLint i; <br> <br>    if (x0 &gt; x1) { <br>        tmp = x0; x0 = x1; x1 = tmp; <br>    } <br>    if (y0 &gt; y1) { <br>        tmp = y0; y0 = y1; y1 = tmp; <br>    } <br>    if (z0 &gt; z1) { <br>        tmp = z0; z0 = z1; z1 = tmp; <br>    } <br>    v[0][0] = v[1][0] = v[2][0] = v[3][0] = x0; <br>    v[4][0] = v[5][0] = v[6][0] = v[7][0] = x1; <br>    v[0][1] = v[1][1] = v[4][1] = v[5][1] = y0; <br>    v[2][1] = v[3][1] = v[6][1] = v[7][1] = y1; <br>    v[0][2] = v[3][2] = v[4][2] = v[7][2] = z0; <br>    v[1][2] = v[2][2] = v[5][2] = v[6][2] = z1; <br> <br>    for (i = 0; i &lt; 6; i++) { <br>        glBegin(type); <br>        glNormal3dv(&amp;n[i][0]); <br>        glVertex3dv(&amp;v[faces[i][0]][0]); <br>        glNormal3dv(&amp;n[i][0]); <br>        glVertex3dv(&amp;v[faces[i][1]][0]); <br>        glNormal3dv(&amp;n[i][0]); <br>        glVertex3dv(&amp;v[faces[i][2]][0]); <br>        glNormal3dv(&amp;n[i][0]); <br>        glVertex3dv(&amp;v[faces[i][3]][0]); <br>        glEnd(); <br>    } <br>} <br> <br>/* doughnut: <br> * <br> * draws a doughnut, centered at (0, 0, 0) whose axis is aligned with <br> * the z-axis.  The doughnut's major radius is R, and minor radius is r. <br> */ <br> <br>void doughnut(GLdouble r, GLdouble R, GLint nsides, GLint rings, GLenum type) <br>{ <br>    int i, j; <br>    GLdouble    theta, phi, theta1, phi1; <br>    GLdouble    p0[03], p1[3], p2[3], p3[3]; <br>    GLdouble    n0[3], n1[3], n2[3], n3[3]; <br> <br>    for (i = 0; i &lt; rings; i++) { <br>        theta = (GLdouble)i*(GLdouble)2.0*PI/rings; <br>        theta1 = (GLdouble)(i+1)*(GLdouble)2.0*PI/rings; <br>        for (j = 0; j &lt; nsides; j++) { <br>            phi = (GLdouble)j*(GLdouble)2.0*PI/nsides; <br>            phi1 = (GLdouble)(j+1)*(GLdouble)2.0*PI/nsides; <br> <br>            p0[0] = cos(theta)*(R + r*cos(phi)); <br>            p0[1] = -sin(theta)*(R + r*cos(phi)); <br>            p0[2] = r*sin(phi); <br> <br>            p1[0] = cos(theta1)*(R + r*cos(phi)); <br>            p1[1] = -sin(theta1)*(R + r*cos(phi)); <br>            p1[2] = r*sin(phi); <br> <br>            p2[0] = cos(theta1)*(R + r*cos(phi1)); <br>            p2[1] = -sin(theta1)*(R + r*cos(phi1)); <br>            p2[2] = r*sin(phi1); <br> <br>            p3[0] = cos(theta)*(R + r*cos(phi1)); <br>            p3[1] = -sin(theta)*(R + r*cos(phi1)); <br>            p3[2] = r*sin(phi1); <br> <br>            n0[0] = cos(theta)*(cos(phi)); <br>            n0[1] = -sin(theta)*(cos(phi)); <br>            n0[2] = sin(phi); <br> <br>            n1[0] = cos(theta1)*(cos(phi)); <br>            n1[1] = -sin(theta1)*(cos(phi)); <br>            n1[2] = sin(phi); <br> <br>            n2[0] = cos(theta1)*(cos(phi1)); <br>            n2[1] = -sin(theta1)*(cos(phi1)); <br>            n2[2] = sin(phi1); <br> <br>            n3[0] = cos(theta)*(cos(phi1)); <br>            n3[1] = -sin(theta)*(cos(phi1)); <br>            n3[2] = sin(phi1); <br> <br>            m_xformpt(p0, p0, n0, n0); <br>            m_xformpt(p1, p1, n1, n1); <br>            m_xformpt(p2, p2, n2, n2); <br>            m_xformpt(p3, p3, n3, n3); <br> <br>            glBegin(type); <br>                glNormal3dv(n3); <br>                glVertex3dv(p3); <br>                glNormal3dv(n2); <br>                glVertex3dv(p2); <br>                glNormal3dv(n1); <br>                glVertex3dv(p1); <br>                glNormal3dv(n0); <br>                glVertex3dv(p0); <br>            glEnd(); <br>        } <br>    } <br>} <br> <br>/* octahedron data: The octahedron produced is centered <br> * at the origin and has radius 1.0 <br> */ <br>static GLdouble odata[6][3] = { <br>  {1.0, 0.0, 0.0}, <br>  {-1.0, 0.0, 0.0}, <br>  {0.0, 1.0, 0.0}, <br>  {0.0, -1.0, 0.0}, <br>  {0.0, 0.0, 1.0}, <br>  {0.0, 0.0, -1.0} <br>}; <br> <br>static int ondex[8][3] = { <br>    {0, 4, 2}, {1, 2, 4}, {0, 3, 4}, {1, 4, 3}, <br>    {0, 2, 5}, {1, 5, 2}, {0, 5, 3}, {1, 3, 5} <br>}; <br> <br>/* tetrahedron data: */ <br> <br>#define T       1.73205080756887729 <br> <br>static GLdouble tdata[4][3] = { <br>    {T, T, T}, {T, -T, -T}, {-T, T, -T}, {-T, -T, T} <br>}; <br> <br>static int tndex[4][3] = { <br>    {0, 1, 3}, {2, 1, 0}, {3, 2, 0}, {1, 2, 3} <br>}; <br> <br>/* icosahedron data: These numbers are rigged to <br> * make an icosahedron of radius 1.0 <br> */ <br> <br>#define X .525731112119133606 <br>#define Z .850650808352039932 <br> <br>static GLdouble idata[12][3] = { <br>  {-X, 0, Z}, <br>  {X, 0, Z}, <br>  {-X, 0, -Z}, <br>  {X, 0, -Z}, <br>  {0, Z, X}, <br>  {0, Z, -X}, <br>  {0, -Z, X}, <br>  {0, -Z, -X}, <br>  {Z, X, 0}, <br>  {-Z, X, 0}, <br>  {Z, -X, 0}, <br>  {-Z, -X, 0} <br>}; <br> <br>static int index[20][3] = { <br>    {0, 4, 1},    {0, 9, 4}, <br>    {9, 5, 4},    {4, 5, 8}, <br>    {4, 8, 1},    {8, 10, 1}, <br>    {8, 3, 10},    {5, 3, 8}, <br>    {5, 2, 3},    {2, 7, 3}, <br>    {7, 10, 3},    {7, 6, 10}, <br>    {7, 11, 6},    {11, 0, 6}, <br>    {0, 1, 6},    {6, 1, 10}, <br>    {9, 0, 11},    {9, 11, 2}, <br>    {9, 2, 5},    {7, 2, 11}, <br>}; <br> <br>/* icosahedron: <br> * <br> * Draws an icosahedron with center at p0 having the <br> * given radius. <br> */ <br> <br>static void icosahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 20; i++) <br>        drawtriangle(i, 0, 1, p0, radius, shadeType, 0); <br>} <br> <br>/* octahedron: <br> * <br> * Draws an octahedron with center at p0 having the <br> * given radius. <br> */ <br>static void octahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 8; i++) <br>        drawtriangle(i, 1, 1, p0, radius, shadeType, 0); <br>} <br> <br>/* tetrahedron: <br> * <br> * Draws an tetrahedron with center at p0 having the <br> * given radius. <br> */ <br> <br>static void tetrahedron(GLdouble p0[3], GLdouble radius, GLenum shadeType) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 4; i++) <br>        drawtriangle(i, 2, 1, p0, radius, shadeType, 0); <br>} <br> <br>static void subdivide(int depth, GLdouble *v0, GLdouble *v1, GLdouble *v2, <br>        GLdouble p0[3], GLdouble radius, GLenum shadeType, int avnormal) <br>{ <br>    GLdouble w0[3], w1[3], w2[3]; <br>    GLdouble l; <br>    int i, j, k, n; <br> <br>    for (i = 0; i &lt; depth; i++) <br>        for (j = 0; i + j &lt; depth; j++) { <br>            k = depth - i - j; <br>            for (n = 0; n &lt; 3; n++) { <br>                w0[n] = (i*v0[n] + j*v1[n] + k*v2[n])/depth; <br>                w1[n] = ((i+1)*v0[n] + j*v1[n] + (k-1)*v2[n])/depth; <br>                w2[n] = (i*v0[n] + (j+1)*v1[n] + (k-1)*v2[n])/depth; <br>            } <br>            l = sqrt(w0[0]*w0[0] + w0[1]*w0[1] + w0[2]*w0[2]); <br>            w0[0] /= l; w0[1] /= l; w0[2] /= l; <br>            l = sqrt(w1[0]*w1[0] + w1[1]*w1[1] + w1[2]*w1[2]); <br>            w1[0] /= l; w1[1] /= l; w1[2] /= l; <br>            l = sqrt(w2[0]*w2[0] + w2[1]*w2[1] + w2[2]*w2[2]); <br>            w2[0] /= l; w2[1] /= l; w2[2] /= l; <br>            recorditem(w1, w0, w2, p0, radius, shadeType, avnormal); <br>        } <br>    for (i = 0; i &lt; depth-1; i++) <br>        for (j = 0; i + j &lt; depth-1; j++) { <br>            k = depth - i - j; <br>            for (n = 0; n &lt; 3; n++) { <br>                w0[n] = ((i+1)*v0[n] + (j+1)*v1[n] + (k-2)*v2[n])/depth; <br>                w1[n] = ((i+1)*v0[n] + j*v1[n] + (k-1)*v2[n])/depth; <br>                w2[n] = (i*v0[n] + (j+1)*v1[n] + (k-1)*v2[n])/depth; <br>            } <br>            l = sqrt(w0[0]*w0[0] + w0[1]*w0[1] + w0[2]*w0[2]); <br>            w0[0] /= l; w0[1] /= l; w0[2] /= l; <br>            l = sqrt(w1[0]*w1[0] + w1[1]*w1[1] + w1[2]*w1[2]); <br>            w1[0] /= l; w1[1] /= l; w1[2] /= l; <br>            l = sqrt(w2[0]*w2[0] + w2[1]*w2[1] + w2[2]*w2[2]); <br>            w2[0] /= l; w2[1] /= l; w2[2] /= l; <br>            recorditem(w0, w1, w2, p0, radius, shadeType, avnormal); <br>        } <br>} <br> <br>static void drawtriangle(int i, int geomType, int depth, <br>        GLdouble p0[3], GLdouble radius, GLenum shadeType, int avnormal) <br>{ <br>    GLdouble *x0, *x1, *x2; <br> <br>    switch (geomType) { <br>        case 0: /* icosahedron */ <br>            x0 = &amp;idata[index[i][0]][0]; <br>            x1 = &amp;idata[index[i][1]][0]; <br>            x2 = &amp;idata[index[i][2]][0]; <br>            break; <br>        case 1: /* octahedron */ <br>            x0 = &amp;odata[ondex[i][0]][0]; <br>            x1 = &amp;odata[ondex[i][1]][0]; <br>            x2 = &amp;odata[ondex[i][2]][0]; <br>            break; <br>        case 2: /* tetrahedron */ <br>            x0 = &amp;tdata[tndex[i][0]][0]; <br>            x1 = &amp;tdata[tndex[i][1]][0]; <br>            x2 = &amp;tdata[tndex[i][2]][0]; <br>            break; <br>    } <br>    subdivide(depth, x0, x1, x2, p0, radius, shadeType, avnormal); <br>} <br> <br>static void recorditem(GLdouble *n1, GLdouble *n2, GLdouble *n3, <br>        GLdouble center[3], GLdouble radius, GLenum shadeType, int avnormal) <br>{ <br>    GLdouble p1[3], p2[3], p3[3], q0[3], q1[3], n11[3], n22[3], n33[3]; <br>    int i; <br> <br>    for (i = 0; i &lt; 3; i++) { <br>        p1[i] = n1[i]*radius + center[i]; <br>        p2[i] = n2[i]*radius + center[i]; <br>        p3[i] = n3[i]*radius + center[i]; <br>    } <br>    if (avnormal == 0) { <br>        diff3(p1, p2, q0); <br>        diff3(p2, p3, q1); <br>        crossprod(q0, q1, q1); <br>        normalize(q1); <br>        m_xformpt(p1, p1, q1, n11); </code></pre>
<p>
</p>
<pre><code>m_xformptonly(p2, p2); <br>        m_xformptonly(p3, p3); <br> <br>        glBegin (shadeType); <br>        glNormal3dv(n11); <br>        glVertex3dv(p1); <br>        glVertex3dv(p2); <br>        glVertex3dv(p3); <br>        glEnd(); <br>        return; <br>    } <br>    m_xformpt(p1, p1, n1, n11); <br>    m_xformpt(p2, p2, n2, n22); <br>    m_xformpt(p3, p3, n3, n33); <br> <br>    glBegin (shadeType); <br>    glNormal3dv(n11); <br>    glVertex3dv(p1); <br>    glNormal3dv(n22); <br>    glVertex3dv(p2); <br>    glNormal3dv(n33); <br>    glVertex3dv(p3); <br>    glEnd(); <br>} <br> <br>static GLdouble dodec[20][3]; <br> <br>static void initdodec() <br>{ <br>    GLdouble alpha, beta; <br> <br>    alpha = sqrt((double)2.0/((double)3.0 + sqrt((double)5.0))); <br>    beta = (double)1.0 + sqrt((double)6.0/((double)3.0 + sqrt((double)5.0)) - (double)2.0 + (double)2.0*sqrt((double)2.0/((double)3.0 + <br>                                                            sqrt((double)5.0)))); <br>    dodec[0][0] = -alpha; dodec[0][1] = 0; dodec[0][2] = beta; <br>    dodec[1][0] = alpha; dodec[1][1] = 0; dodec[1][2] = beta; <br>    dodec[2][0] = -1; dodec[2][1] = -1; dodec[2][2] = -1; <br>    dodec[3][0] = -1; dodec[3][1] = -1; dodec[3][2] = 1; <br>    dodec[4][0] = -1; dodec[4][1] = 1; dodec[4][2] = -1; <br>    dodec[5][0] = -1; dodec[5][1] = 1; dodec[5][2] = 1; <br>    dodec[6][0] = 1; dodec[6][1] = -1; dodec[6][2] = -1; <br>    dodec[7][0] = 1; dodec[7][1] = -1; dodec[7][2] = 1; <br>    dodec[8][0] = 1; dodec[8][1] = 1; dodec[8][2] = -1; <br>    dodec[9][0] = 1; dodec[9][1] = 1; dodec[9][2] = 1; <br>    dodec[10][0] = beta; dodec[10][1] = alpha; dodec[10][2] = 0; <br>    dodec[11][0] = beta; dodec[11][1] = -alpha; dodec[11][2] = 0; <br>    dodec[12][0] = -beta; dodec[12][1] = alpha; dodec[12][2] = 0; <br>    dodec[13][0] = -beta; dodec[13][1] = -alpha; dodec[13][2] = 0; <br>    dodec[14][0] = -alpha; dodec[14][1] = 0; dodec[14][2] = -beta; <br>    dodec[15][0] = alpha; dodec[15][1] = 0; dodec[15][2] = -beta; <br>    dodec[16][0] = 0; dodec[16][1] = beta; dodec[16][2] = alpha; <br>    dodec[17][0] = 0; dodec[17][1] = beta; dodec[17][2] = -alpha; <br>    dodec[18][0] = 0; dodec[18][1] = -beta; dodec[18][2] = alpha; <br>    dodec[19][0] = 0; dodec[19][1] = -beta; dodec[19][2] = -alpha; <br>} <br> <br>/* dodecahedron: <br> * <br> * Draws an dodecahedron with center at 0.0. The radius <br> * is sqrt(3). <br> */ <br>static void dodecahedron(GLdouble center[3], GLdouble sc, GLenum type) <br>{ <br>    static int inited = 0; <br> <br>    if ( inited == 0) { <br>        inited = 1; <br>        initdodec(); <br>    } <br>    m_pushmatrix(); <br>    m_translate(center[0], center[1], center[2]); <br>    m_scale(sc, sc, sc); <br>    pentagon(0, 1, 9, 16, 5, type); <br>    pentagon(1, 0, 3, 18, 7, type); <br>    pentagon(1, 7, 11, 10, 9, type); <br>    pentagon(11, 7, 18, 19, 6, type); <br>    pentagon(8, 17, 16, 9, 10, type); <br>    pentagon(2, 14, 15, 6, 19, type); <br>    pentagon(2, 13, 12, 4, 14, type); <br>    pentagon(2, 19, 18, 3, 13, type); <br>    pentagon(3, 0, 5, 12, 13, type); <br>    pentagon(6, 15, 8, 10, 11, type); <br>    pentagon(4, 17, 8, 15, 14, type); <br>    pentagon(4, 12, 5, 16, 17, type); <br>    m_popmatrix(); <br>} <br> <br>static void pentagon(int a, int b, int c, int d, int e, GLenum shadeType) <br>{ <br>    GLdouble n0[3], d1[3], d2[3], d3[3], d4[3], d5[3], nout[3]; <br> <br>    diff3(&amp;dodec[a][0], &amp;dodec[b][0], d1); <br>    diff3(&amp;dodec[b][0], &amp;dodec[c][0], d2); <br>    crossprod(d1, d2, n0); <br>    normalize(n0); <br>    m_xformpt(&amp;dodec[a][0], d1, n0, nout); <br>    m_xformptonly(&amp;dodec[b][0], d2); <br>    m_xformptonly(&amp;dodec[c][0], d3); <br>    m_xformptonly(&amp;dodec[d][0], d4); <br>    m_xformptonly(&amp;dodec[e][0], d5); <br> <br>    glBegin (shadeType); <br>    glNormal3dv(nout); <br>    glVertex3dv(d1); <br>    glVertex3dv(d2); <br>    glVertex3dv(d3); <br>    glVertex3dv(d4); <br>    glVertex3dv(d5); <br>    glEnd(); <br>} <br> <br>/*      linked lists--display lists for each different <br> *      type of geometric objects.  The linked list is <br> *      searched, until an object of the requested <br> *      size is found.  If no geometric object of that size <br> *      has been previously made, a new one is created. <br> */ <br>GLuint findList (int index, GLdouble *paramArray, int size) <br>{ <br>    MODELPTR endList; <br>    int found = 0; <br> <br>    endList = lists[index]; <br>    while (endList != NULL) { <br>        if (compareParams (endList-&gt;params, paramArray, size)) <br>            return (endList-&gt;list); <br>        endList = endList-&gt;ptr; <br>    } <br>/*  if not found, return 0 and calling routine should <br> *  make a new list <br> */ <br>    return (0); <br>} <br> <br>int compareParams (GLdouble *oneArray, GLdouble *twoArray, int size) <br>{ <br>    int i; <br>    int matches = 1; <br> <br>    for (i = 0; (i &lt; size) &amp;&amp; matches; i++) { <br>        if (*oneArray++ != *twoArray++) <br>            matches = 0; <br>    } <br>    return (matches); <br>} <br> <br>GLuint makeModelPtr (int index, GLdouble *sizeArray, int count) <br>{ <br>    MODELPTR newModel; <br> <br>    newModel = (MODELPTR) malloc (sizeof (MODEL)); <br>    newModel-&gt;list = glGenLists (1); <br>    newModel-&gt;numParam = count; <br>    newModel-&gt;params = sizeArray; <br>    newModel-&gt;ptr = lists[index]; <br>    lists[index] = newModel; <br> <br>    return (newModel-&gt;list); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
