<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TKIMAGE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3652"></a>TKIMAGE.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> * ALL RIGHTS RESERVED <br> * Permission to use, copy, modify, and distribute this software for <br> * any purpose and without fee is hereby granted, provided that the above <br> * copyright notice appear in all copies and that both the copyright notice <br> * and this permission notice appear in supporting documentation, and that <br> * the name of Silicon Graphics, Inc. not be used in advertising <br> * or publicity pertaining to distribution of the software without specific, <br> * written prior permission. <br> * <br> * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS" <br> * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE, <br> * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR <br> * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON <br> * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT, <br> * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY <br> * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION, <br> * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF <br> * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN <br> * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON <br> * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE <br> * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE. <br> * <br> * US Government Users Restricted Rights <br> * Use, duplication, or disclosure by the Government is subject to <br> * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph <br> * (c)(1)(ii) of the Rights in Technical Data and Computer Software <br> * clause at DFARS 252.227-7013 and/or in similar or successor <br> * clauses in the FAR or the DOD or NASA FAR Supplement. <br> * Unpublished-- rights reserved under the copyright laws of the <br> * United States.  Contractor/manufacturer is Silicon Graphics, <br> * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311. <br> * <br> * OpenGL(TM) is a trademark of Silicon Graphics, Inc. <br> */ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "tk.h" <br> <br>#define static <br> <br> <br>#define IMAGIC      0x01da <br>#define IMAGIC_SWAP 0xda01 <br> <br>#define SWAP_SHORT_BYTES(x) ((((x) &amp; 0xff) &lt;&lt; 8) | (((x) &amp; 0xff00) &gt;&gt; 8)) <br>#define SWAP_LONG_BYTES(x) (((((x) &amp; 0xff) &lt;&lt; 24) | (((x) &amp; 0xff00) &lt;&lt; 8)) | \ <br>                            ((((x) &amp; 0xff0000) &gt;&gt; 8) | (((x) &amp; 0xff000000) &gt;&gt; 24))) <br> <br>typedef struct _rawImageRec { <br>    unsigned short imagic; <br>    unsigned short type; <br>    unsigned short dim; <br>    unsigned short sizeX, sizeY, sizeZ; <br>    unsigned long min, max; <br>    unsigned long wasteBytes; <br>    char name[80]; <br>    unsigned long colorMap; <br>    HANDLE file; <br>    unsigned char *tmp, *tmpR, *tmpG, *tmpB; <br>    unsigned long rleEnd; <br>    unsigned long *rowStart; <br>    long *rowSize; <br>} rawImageRec; <br> <br>static void RawImageClose(rawImageRec *raw); <br> <br>static rawImageRec *RawImageOpenAW(char *fileName, BOOL bUnicode) <br>{ <br>    rawImageRec *raw; <br>    unsigned long *rowStart, *rowSize, ulTmp; <br>    int x; <br>    DWORD dwBytesRead; <br> <br>    raw = (rawImageRec *)malloc(sizeof(rawImageRec)); <br>    if (raw == NULL) { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        return NULL; <br>    } <br> <br>    raw-&gt;file = bUnicode ? CreateFileW((LPWSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0) : <br>                           CreateFileA((LPSTR) fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0); <br>    if (raw-&gt;file == INVALID_HANDLE_VALUE) { <br>        char ach[256]; <br> <br>        bUnicode ? wsprintf(ach, "Failed to open image file %ws.\n", fileName) : <br>                   wsprintf(ach, "Failed to open image file %s.\n", fileName); <br> <br>        MESSAGEBOX(GetFocus(), ach, "Error", MB_OK); <br> <br>        free( raw ); <br>        return NULL; <br>    } <br> <br>    ReadFile(raw-&gt;file, (LPVOID) raw, 12, &amp;dwBytesRead, (LPOVERLAPPED) NULL); <br> <br>    if (raw-&gt;imagic == IMAGIC_SWAP) { <br>        raw-&gt;type = SWAP_SHORT_BYTES(raw-&gt;type); <br>        raw-&gt;dim = SWAP_SHORT_BYTES(raw-&gt;dim); <br>        raw-&gt;sizeX = SWAP_SHORT_BYTES(raw-&gt;sizeX); <br>        raw-&gt;sizeY = SWAP_SHORT_BYTES(raw-&gt;sizeY); <br>        raw-&gt;sizeZ = SWAP_SHORT_BYTES(raw-&gt;sizeZ); <br>    } else if (raw-&gt;imagic != IMAGIC) { <br>        // magic number is absent - conclude file is invalid (?) <br>        MESSAGEBOX(GetFocus(), "Invalid rgb file.", "Error", MB_OK); <br>        RawImageClose( raw ); <br>        return NULL; <br>    } <br>         <br>    raw-&gt;tmp = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpR = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpG = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpB = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    if (raw-&gt;tmp == NULL || raw-&gt;tmpR == NULL || raw-&gt;tmpG == NULL || <br>        raw-&gt;tmpB == NULL) { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        RawImageClose( raw ); <br>        return NULL; <br>    } <br> <br>    if ((raw-&gt;type &amp; 0xFF00) == 0x0100) { <br>        x = raw-&gt;sizeY * raw-&gt;sizeZ * sizeof(long); <br>        raw-&gt;rowStart = (unsigned long *)malloc(x); <br>        raw-&gt;rowSize = (long *)malloc(x); <br>        if (raw-&gt;rowStart == NULL || raw-&gt;rowSize == NULL) { <br>            MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>            RawImageClose( raw ); <br>            return NULL; <br>        } <br>        raw-&gt;rleEnd = 512 + (2 * x); <br>        SetFilePointer(raw-&gt;file, 512, NULL, FILE_BEGIN); <br>        ReadFile(raw-&gt;file, (LPVOID) raw-&gt;rowStart, x, &amp;dwBytesRead, <br>                 (LPOVERLAPPED) NULL); <br>        ReadFile(raw-&gt;file, (LPVOID) raw-&gt;rowSize, x, &amp;dwBytesRead, <br>                 (LPOVERLAPPED) NULL); <br>        if (raw-&gt;imagic == IMAGIC_SWAP) { <br>            x /= sizeof(long); <br>            rowStart = raw-&gt;rowStart; <br>            rowSize = raw-&gt;rowSize; <br>            while (x--) { <br>                ulTmp = *rowStart; <br>                *rowStart++ = SWAP_LONG_BYTES(ulTmp); <br>                ulTmp = *rowSize; <br>                *rowSize++ = SWAP_LONG_BYTES(ulTmp); <br>            } <br>        } <br>    } <br>    return raw; <br>} <br> <br>static void RawImageClose(rawImageRec *raw) <br>{ <br>    if( !raw ) <br>        return; <br>    CloseHandle(raw-&gt;file); <br>    if( raw-&gt;tmp ) free(raw-&gt;tmp); <br>    if( raw-&gt;tmpR ) free(raw-&gt;tmpR); <br>    if( raw-&gt;tmpG ) free(raw-&gt;tmpG); <br>    if( raw-&gt;tmpB ) free(raw-&gt;tmpB); <br>    free(raw); <br>} <br> <br>static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z) <br>{ <br>    unsigned char *iPtr, *oPtr, pixel; <br>    int count; <br>    DWORD dwBytesRead; <br> <br>    if ((raw-&gt;type &amp; 0xFF00) == 0x0100) { <br>        SetFilePointer(raw-&gt;file, raw-&gt;rowStart[y+z*raw-&gt;sizeY], NULL, FILE_BEGIN); <br>        ReadFile(raw-&gt;file, (LPVOID) raw-&gt;tmp, <br>                 (unsigned int)raw-&gt;rowSize[y+z*raw-&gt;sizeY], &amp;dwBytesRead, <br>                 (LPOVERLAPPED) NULL); <br> <br>        iPtr = raw-&gt;tmp; <br>        oPtr = buf; <br>        while (1) { <br>            pixel = *iPtr++; <br>            count = (int)(pixel &amp; 0x7F); <br>            if (!count) { <br>                return; <br>            } <br>            if (pixel &amp; 0x80) { <br>                while (count--) { <br>                    *oPtr++ = *iPtr++; <br>                } <br>            } else { <br>                pixel = *iPtr++; <br>                while (count--) { <br>                    *oPtr++ = pixel; <br>                } <br>            } <br>        } <br>    } else { <br>        SetFilePointer(raw-&gt;file, 512+(y*raw-&gt;sizeX)+(z*raw-&gt;sizeX*raw-&gt;sizeY), <br>                       NULL, FILE_BEGIN); <br>        ReadFile(raw-&gt;file, (LPVOID) buf, raw-&gt;sizeX, &amp;dwBytesRead, <br>                 (LPOVERLAPPED) NULL); <br>    } <br>} <br> <br>static void RawImageGetData(rawImageRec *raw, TK_RGBImageRec *final) <br>{ <br>    unsigned char *ptr; <br>    int i, j; <br> <br>    final-&gt;data = (unsigned char *)malloc((raw-&gt;sizeX+1)*(raw-&gt;sizeY+1)*4); <br>    if (final-&gt;data == NULL) { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        return; <br>    } <br> <br>    ptr = final-&gt;data; <br>    for (i = 0; i &lt; raw-&gt;sizeY; i++) { <br>        RawImageGetRow(raw, raw-&gt;tmpR, i, 0); <br>        RawImageGetRow(raw, raw-&gt;tmpG, i, 1); <br>        RawImageGetRow(raw, raw-&gt;tmpB, i, 2); <br>        for (j = 0; j &lt; raw-&gt;sizeX; j++) { <br>            *ptr++ = *(raw-&gt;tmpR + j); <br>            *ptr++ = *(raw-&gt;tmpG + j); <br>            *ptr++ = *(raw-&gt;tmpB + j); <br>        } <br>    } <br>} <br> <br>TK_RGBImageRec *tkRGBImageLoad(char *fileName) <br>{ <br>    return tkRGBImageLoadAW(fileName, FALSE); <br>} <br> <br>TK_RGBImageRec *tkRGBImageLoadAW(char *fileName, BOOL bUnicode) <br>{ <br>    rawImageRec *raw; <br>    TK_RGBImageRec *final; <br> <br>    if( !(raw = RawImageOpenAW(fileName, bUnicode)) ) <br>        return NULL; <br> <br>    final = (TK_RGBImageRec *)malloc(sizeof(TK_RGBImageRec)); <br>    if (final == NULL) { <br>        MESSAGEBOX(GetFocus(), "Out of memory.", "Error", MB_OK); <br>        RawImageClose(raw); <br>        return NULL; <br>    } <br>    final-&gt;sizeX = raw-&gt;sizeX; <br>    final-&gt;sizeY = raw-&gt;sizeY; <br>    RawImageGetData(raw, final); <br>    RawImageClose(raw); <br>    return final; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
