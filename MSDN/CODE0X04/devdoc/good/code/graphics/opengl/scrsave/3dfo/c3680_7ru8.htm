<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENDROP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3680"></a>GENDROP.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: gendrop.c <br>* <br>* The Splash style of the 3D Flying Objects screen saver. <br>* <br>* Simulation of a drop of water falling into a pool of water. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br>#include "mesh.h" <br> <br>#define FLOAT_SMALL (1e-6) <br> <br>#define DROPPREC   10 <br> <br>// Remember from pre-calc: <br>//      x = r cos th <br>//      y = r sin th <br>// to convert from polar to rect, and that <br>//      x = x' cos th - y' sin th <br>//      y = x' sin th + y' cos th <br>// to rotate axes. <br>// <br>// Also, note that the equation for a lemniscate is: <br>//      r = sqrt(sin 2*th) <br>// <br> <br>static POINT3D *circle; <br>static POINT3D *drop; <br>static POINT3D *curves; <br>static MESH waterMesh; <br>static MESH waterInmesh; <br>static MESH waterOutmesh; <br>static MESH waterBorderMesh; <br>static MESH *drops; <br>static int iPrec; <br>static float fRadiusFact = 0.35f; <br> <br>static GLfloat light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f}; <br>static dropList[DROPPREC]; <br> <br>void genCurves() <br>{ <br>    int i; <br>    double angle; <br>    double step = -PI / (float)(iPrec - 1); <br>    double start = PI / 2.0; <br>    double rotSin = sin(PI / 4.0); <br>    double rotCos = cos(PI / 4.0); <br>    double aFract = 0.0; <br>    double bFract = 1.0; <br>    double fractInc = 1.0 / (double)(iPrec - 1); <br>    POINT3D *pt = curves; <br> <br>    for (i = 0, angle = start; i &lt; iPrec; i++, angle += step) { <br>        circle[i].x = (float) (0.5 * cos(angle)); <br>        circle[i].y = (float) (0.5 * sin(angle)); <br>    } <br> <br>    step = (-PI / 4.0) / (float)(iPrec - 1); <br>    start = PI / 4.0; <br> <br>    for (i = 0, angle = start; i &lt; iPrec; i++, angle += step) { <br>        double x, y, r; <br>        double xrot, yrot; <br>        double sinVal; <br> <br>        sinVal = sin(2.0 * angle); <br>        if (sinVal &lt; 0.0) <br>            sinVal = -sinVal; <br> <br>        r = 1.5 * sqrt(sinVal); <br>        x = r * cos(angle); <br>        y = r * sin(angle); <br> <br>        xrot = x * rotCos - y * rotSin; <br>        yrot = x * rotSin + y * rotCos - 1.0; <br> <br>        drop[i].x = (float) xrot; <br>        drop[i].y = (float) yrot; <br>    } <br> <br> <br>    for (i = 0; i &lt; DROPPREC; i++) { <br>        int j; <br> <br>        for (j = 0; j &lt; iPrec; j++, pt++) { <br>            pt-&gt;x = (float) (aFract * circle[j].x + <br>                             bFract * drop[j].x); <br> <br>            pt-&gt;y = (float) (aFract * circle[j].y + <br>                             bFract * drop[j].y); <br> <br>            pt-&gt;z = 0.0f; <br>        } <br>        aFract += fractInc; <br>        bFract -= fractInc; <br>    } <br>} <br> <br>#define NORMS(x, y) waterMesh.norms[((x) * iPrec) + y] <br>#define BNORMS(x, y) waterBorderMesh.norms[((x) * iPrec) + y] <br>#define INGRID(x, y)  waterInmesh.pts[((x) * iPrec) + y] <br>#define OUTGRID(x, y)  waterOutmesh.pts[((x) * iPrec) + y] <br>#define GRID(x, y)  waterMesh.pts[((x) * iPrec) + y] <br>#define BGRID(x, y)  waterBorderMesh.pts[((x) * iPrec) + y] <br> <br>void genWater(double freq, double damp, double mag, double w, double minr) <br>{ <br>    int i; <br>    int j; <br>    double r; <br>    double theta; <br>    double thetaInc = (2.0 * PI) / (float)iPrec; <br>    double posInc = 1.0 / (float)iPrec; <br>    int facecount; <br>    double xCenter = 0.0; <br>    double zCenter = 0.0; <br>    POINT3D norm; <br>    static BOOL first = TRUE; <br> <br>    if (first) { <br>        for (i = 0, r = 0.0; i &lt; iPrec; i++, r += posInc) { <br>            for (j = 0, theta = 0.0; j &lt; iPrec; j++, theta += thetaInc) { <br>                float x, z; <br>                float dx, dz; <br>                float rr; <br> <br>                x = (float) cos(theta); <br>                z = (float) sin(theta); <br> <br>                dx = x - (float) xCenter; <br>                dz = z - (float) zCenter; <br> <br>                rr = (float) sqrt((dx * dx) + (dz * dz)); <br>                dx /= rr; <br>                dz /= rr; <br>                dx *= i / (float)(iPrec - 1); <br>                dz *= i / (float)(iPrec - 1); <br>                GRID(i, j).x = dx + (float) xCenter; <br>                GRID(i, j).z = dz + (float) zCenter; <br> <br>                INGRID(i, j).y = 0.0f; <br>                OUTGRID(i, j).y = 0.0f; <br>            } <br>        } <br>    } <br> <br> <br>    for (i = (iPrec - 1), r = 1.0; i &gt;= 0; i--, r -= posInc) { <br>        float val; <br> <br>        if (i == 0) { <br>            if (minr != 0.0) <br>                val = (float) (-mag * cos(w + (r * freq)) * exp((-damp * r)/2.0)); <br>            else <br>                val =  INGRID(0, 0).y * 0.95f; <br>        } else <br>            val = OUTGRID(i - 1, 0).y * 0.95f; <br> <br>        for (j = 0; j &lt; iPrec; j++) <br>            OUTGRID(i, j).y = val; <br>    } <br> <br> <br>    for (i = 0, r = 0.0; i &lt; iPrec; i++, r += posInc) { <br>        for (j = 0; j &lt; iPrec; j++) { <br>            if (i == iPrec-1) <br>                INGRID(i, j).y = -OUTGRID(i, j).y; <br>            else <br>                INGRID(i, j).y = INGRID(i + 1, j).y * 0.95f; <br>        } <br>    } <br> <br> <br>    waterMesh.numFaces = 0; <br>    waterBorderMesh.numFaces = 0; <br> <br>    for (i = 0; i &lt; iPrec; i++) { <br>        for (j = 0; j &lt; iPrec; j++) { <br>            NORMS(i, j).x = 0.0f; <br>            NORMS(i, j).y = 0.0f; <br>            NORMS(i, j).z = 0.0f; <br>        } <br>    } <br> <br>    for (i = 0, r = 0.0; i &lt; iPrec; i++, r += posInc) { <br>        for (j = 0, theta = 0.0; j &lt; iPrec; j++, theta += thetaInc) { <br>            GRID(i, j).y = OUTGRID(i, j).y + INGRID(i, j).y; <br> <br> <br>            if (i == (iPrec - 1)) { <br>                GRID(i, j).y = 0.0f; <br> <br>                BGRID(0, j).x = GRID(i, j).x; <br>                BGRID(0, j).z = GRID(i, j).z; <br>                BGRID(0, j).y = GRID(i, j).y; <br> <br>                BGRID(1, j).x = GRID(i, j).x; <br>                BGRID(1, j).z = GRID(i, j).z; <br>                BGRID(1, j).y = -0.5f; <br>            } <br>        } <br>    } <br> <br>    for (i = 0; i &lt; 2; i++) { <br>        for (j = 0; j &lt; iPrec; j++) { <br>            BNORMS(i, j).x = 0.0f; <br>            BNORMS(i, j).y = 0.0f; <br>            BNORMS(i, j).z = 0.0f; <br>        } <br>    } <br> <br>    for (facecount = 0, i = 0; i &lt; (iPrec - 1); i++) { <br>        for (j = 0; j &lt; iPrec; j++) { <br>            int k, l; <br> <br>            k = i + 1; <br> <br>            if (j == (iPrec - 1)) <br>                l = 0; <br>            else <br>                l = j + 1; <br> <br>            ss_calcNorm(&amp;norm, &amp;GRID(k, j), &amp;GRID(i, j), &amp;GRID(i, l)); <br> <br>            if (norm.x &gt; -FLOAT_SMALL &amp;&amp; norm.x &lt; FLOAT_SMALL &amp;&amp; <br>                norm.y &gt; -FLOAT_SMALL &amp;&amp; norm.y &lt; FLOAT_SMALL &amp;&amp; <br>                norm.z &gt; -FLOAT_SMALL &amp;&amp; norm.z &lt; FLOAT_SMALL) <br>                ss_calcNorm(&amp;norm, &amp;GRID(i, l), &amp;GRID(k, l), &amp;GRID(k, j)); <br> <br> <br>            waterMesh.faces[facecount].material = 0; <br>            waterMesh.faces[facecount].norm = norm; <br> <br>            NORMS(i, j).x += norm.x; <br>            NORMS(i, j).y += norm.y; <br>            NORMS(i, j).z += norm.z; <br> <br>            NORMS(k, j).x += norm.x; <br>            NORMS(k, j).y += norm.y; <br>            NORMS(k, j).z += norm.z; <br> <br>            NORMS(i, l).x += norm.x; <br>            NORMS(i, l).y += norm.y; <br>            NORMS(i, l).z += norm.z; <br> <br>            NORMS(k, l).x += norm.x; <br>            NORMS(k, l).y += norm.y; <br>            NORMS(k, l).z += norm.z; <br> <br>            waterMesh.faces[facecount].p[0] = (k * iPrec) + j; <br>            waterMesh.faces[facecount].p[1] = (i * iPrec) + j; <br>            waterMesh.faces[facecount].p[2] = (k * iPrec) + l; <br>            waterMesh.faces[facecount].p[3] = (i * iPrec) + l; <br>            waterMesh.numFaces++; <br>            facecount++; <br>        } <br>    } <br> <br>    waterMesh.numPoints = iPrec * iPrec; <br> <br>    for (facecount = 0, i = 0; i &lt; 1; i++) { <br>        for (j = 0; j &lt; iPrec; j++) { <br>            int k, l; <br> <br>            k = i + 1; <br> <br>            if (j == (iPrec - 1)) <br>                l = 0; <br>            else <br>                l = j + 1; <br> <br>            ss_calcNorm(&amp;norm, &amp;BGRID(k, j), &amp;BGRID(i, j), &amp;BGRID(i, l)); <br> <br>            waterBorderMesh.faces[facecount].material = 0; <br>            waterBorderMesh.faces[facecount].norm = norm; <br> <br>// Setting SMOOTH_BORDER will render the border (the sides of the "pool") <br>// with smooth shading.  This effect is good at higher tesselations, but <br>// doesn't really look that good for low tesselations. <br>// <br>// A possible enhancement for later: use smooth shading if tesselation <br>// exceeds some threshold.  Should we just pick some arbitrary threshold? <br>// Make it a setup option?  Things look pretty good now, so don't bother? <br> <br>#if SMOOTH_BORDER <br>            BNORMS(i, j).x += norm.x; <br>            BNORMS(i, j).y += norm.y; <br>            BNORMS(i, j).z += norm.z; <br> <br>            if (i) { <br>                BNORMS(i-1, j).x += norm.x; <br>                BNORMS(i-1, j).y += norm.y; <br>                BNORMS(i-1, j).z += norm.z; <br>            } <br>            if (j) { <br>                BNORMS(i, j-1).x += norm.x; <br>                BNORMS(i, j-1).y += norm.y; <br>                BNORMS(i, j-1).z += norm.z; <br>            } <br> <br>            BNORMS(k, j).x += norm.x; <br>            BNORMS(k, j).y += norm.y; <br>            BNORMS(k, j).z += norm.z; <br> <br>            BNORMS(i, l).x += norm.x; <br>            BNORMS(i, l).y += norm.y; <br>            BNORMS(i, l).z += norm.z; <br>#else <br>            BNORMS(i, j) = norm; <br> <br>            if (i) <br>                BNORMS(i-1, j) = norm; <br>            if (j) <br>                BNORMS(i, j-1) = norm; <br> <br>            BNORMS(k, j) = norm; <br>            BNORMS(i, l) = norm; <br>#endif <br> <br>            waterBorderMesh.faces[facecount].p[0] = (k * iPrec) + j; <br>            waterBorderMesh.faces[facecount].p[1] = (i * iPrec) + j; <br>            waterBorderMesh.faces[facecount].p[2] = (k * iPrec) + l; <br>            waterBorderMesh.faces[facecount].p[3] = (i * iPrec) + l; <br>            waterBorderMesh.numFaces++; <br>            facecount++; <br>        } <br>    } <br>    waterBorderMesh.numPoints = 2 * iPrec; <br> <br>    ss_normalizeNorms(waterBorderMesh.norms, waterBorderMesh.numPoints); <br>    ss_normalizeNorms(waterMesh.norms, waterMesh.numPoints); <br> <br>    first = FALSE; <br>} <br> <br> <br>void initDropScene() <br>{ <br>    int i; <br> <br>    iPrec = (int)(fTesselFact * 10.5); <br>    if (iPrec &lt; 4) <br>        iPrec = 4; <br> <br>    if (fTesselFact &gt; fRadiusFact) <br>        fRadiusFact = fTesselFact; <br> <br>    circle = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D)); <br>    drop = (POINT3D *)SaverAlloc(iPrec * sizeof(POINT3D)); <br>    curves = (POINT3D *)SaverAlloc(DROPPREC * iPrec * sizeof(POINT3D)); <br>    drops = (MESH *)SaverAlloc(DROPPREC * sizeof(MESH)); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0); <br> <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br> <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br> <br>    glDisable(GL_CULL_FACE); <br> <br>    newMesh(&amp;waterInmesh, iPrec * iPrec, iPrec * iPrec + iPrec); <br>    newMesh(&amp;waterOutmesh, iPrec * iPrec, iPrec * iPrec + iPrec); <br>    newMesh(&amp;waterMesh, iPrec * iPrec, iPrec * iPrec + iPrec); <br>    newMesh(&amp;waterBorderMesh, iPrec, 2 * iPrec); <br>    genCurves(); <br> <br>    for (i = 0; i &lt; DROPPREC; i++) <br>        revolveSurface(&amp;drops[i], &amp;curves[i * iPrec], iPrec); <br>    for (i = 0; i &lt; DROPPREC; i++) { <br>        GLuint id = 0x10 + i; <br>        dropList[i] = id; <br>        MakeList(id, &amp;drops[i]); <br>    } <br>    for (i = 0; i &lt; DROPPREC; i++) { <br>        delMesh(&amp;drops[i]); <br>    } <br> <br>    SaverFree(circle); <br>    SaverFree(drop); <br>    SaverFree(curves); <br>    SaverFree(drops); <br>} <br> <br>void delDropScene() <br>{ <br>    delMesh(&amp;waterMesh); <br>    delMesh(&amp;waterInmesh); <br>    delMesh(&amp;waterOutmesh); <br>    delMesh(&amp;waterBorderMesh); <br>} <br> <br>void updateDropScene(int flags) <br>{ <br>    static double zrot = 0.0; <br>    static double yrot = 0.0; <br>    static double mxrot = 0.0; <br>    static double myrot = 0.0; <br>    static double mzrot = 0.0; <br>    static double mxrotInc = 0.0; <br>    static double myrotInc = 0.1; <br>    static double zrotInc = 3.0; <br>    static double yrotInc = 1.5; <br>    static double mzrotInc = 0.0; <br>    static double ypos = 1.0; <br>    static int dropnum = 0; <br>    static double radius = 0.3; <br>    static double damp = 1.0; <br>    static double mag = 0.0; <br>    static double w = 1.0; <br>    static double freq = 1.0; <br>    static double dist; <br>    static double minr = 0.0; <br>    static int h = 0; <br>    RGBA color; <br> <br>    glPushMatrix(); <br> <br>    zrot += zrotInc; <br>    if (zrot &gt;= 45.0) { <br>        zrot = 45.0; <br>        zrotInc = -(2.0 + ((float)rand() / (float)RAND_MAX) * 3.0); <br>    } else if (zrot &lt;= -45.0) { <br>        zrot = -45.0; <br>        zrotInc = 2.0 + ((float)rand() / (float)RAND_MAX) * 3.0; <br>    } <br> <br>    yrot += yrotInc; <br>    if (yrot &gt;= 10.0) { <br>        yrot = 10.0; <br>        yrotInc = -(1.0 + ((float)rand() / (float)RAND_MAX) * 2.0); <br>    } else if (zrot &lt;= -10.0) { <br>        yrot = -10.0; <br>        yrotInc = 1.0 + ((float)rand() / (float)RAND_MAX) * 2.0; <br>    } <br> <br>    if ((ypos + 0.5 &lt; -radius) &amp;&amp; (mag &lt; 0.05)) { <br>        radius = (float)rand() / (6.0 * (float)RAND_MAX) + 0.1; <br>        ypos = 1.0; <br>        dropnum = 0; <br>    } <br> <br>    dist = (ypos + 0.5); <br> <br>    if ((dist &gt; -radius / 2.0) &amp;&amp; (dist &lt; radius / 2.0)) { <br>        if (dist &lt;= 0.0) <br>            dist = radius / 2.0; <br>        else <br>            dist = (radius / 2.0) - dist; <br>        freq = (0.25 * PI) / dist; <br>        if (freq &lt; 0.2) <br>            freq = 0.2; <br> <br>        minr = radius; <br> <br>        damp = 20.0; <br>        mag = (0.35 / fRadiusFact) + 0.2 * dist; <br> <br>        w = 0; <br>    } else { <br>        minr -= 0.05; <br>        if (minr &lt; 0.0) <br>            minr = 0.0; <br> <br>        mag = mag * 0.95; <br>        if (minr == 0.0) { <br>            w -= (PI / 6.0); <br>            mag *= 0.75; <br>        } <br>        if (damp &gt; 0.0) <br>            damp -= 1.0; <br>    } <br> <br>    genWater(freq, damp, mag, w, minr); <br> <br>    glRotatef((GLfloat) zrot, 0.0f, 0.0f, 1.0f); <br>    glRotatef(30.0f, 1.0f, 0.0f, 0.0f); <br> <br>    glPushMatrix(); <br>    glTranslatef(0.0f, -0.5f, 0.0f); <br>    glRotatef((GLfloat) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f); <br> <br>    if (bColorCycle) { <br>        ss_HsvToRgb((float)h, 1.0f, 1.0f, &amp;color ); <br> <br>        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                     (GLfloat *) &amp;color); <br>        h++; <br>        h %= 360; <br>    } else { <br>        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                     (GLfloat *) &amp;Material[6].kd); <br>    } <br> <br>    updateObject(&amp;waterMesh, bSmoothShading); <br> <br>    if (bSmoothShading) <br>        glShadeModel(GL_FLAT); <br> <br>    if (!bColorCycle) <br>        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                     (GLfloat *) &amp;Material[2].kd); <br> <br>    updateObject2(&amp;waterBorderMesh, FALSE); <br>    glPopMatrix(); <br> <br>    if (bSmoothShading) <br>        glShadeModel(GL_SMOOTH); <br> <br>    if (dist &gt; -radius) { <br> <br>        if (!bColorCycle) <br>            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                         (GLfloat *) &amp;Material[6].kd); <br>        glTranslatef(0.0f, (GLfloat) ypos, 0.0f); <br>        glScalef((GLfloat) radius, (GLfloat) radius, (GLfloat) radius); <br>        glRotatef(180.0f, 1.0f, 0.0f, 0.0f); <br>        glEnable(GL_NORMALIZE); <br>        glCallList(dropList[dropnum]); <br>        glDisable(GL_NORMALIZE); <br> <br>    } <br> <br>    myrot += myrotInc; <br> <br>    ypos -= 0.08; <br>    dropnum = (int) ((DROPPREC - 1) - (ypos * (DROPPREC - 1))); <br>    if (dropnum &gt; (DROPPREC - 1)) <br>        dropnum = DROPPREC - 1; <br> <br>    glPopMatrix(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
