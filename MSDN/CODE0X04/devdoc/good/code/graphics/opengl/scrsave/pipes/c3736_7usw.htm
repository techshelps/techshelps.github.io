<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FPIPE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3740"></a>FPIPE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: fpipe.cxx <br>* <br>* Flex pipes <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>/* Notes: <br>     <br>    - All Draw routines start with current xc at the beginning, and create <br>      a new one at the end.  Since it is common to just have 2 xc's for <br>      each prim, xcCur holds the current xc, and xcEnd is available <br>      for the draw routine to use as the end xc. <br>        They also reset xcCur when done <br>*/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "sspipes.h" <br>#include "fpipe.h" <br>#include "eval.h" <br> <br>// defCylNotch shows the absolute notch for the default cylinder, <br>// given a direction (notch is always along +x axis) <br> <br>static GLint defCylNotch[NUM_DIRS] =  <br>        { MINUS_Z, PLUS_Z, PLUS_X, PLUS_X, PLUS_X, MINUS_X }; <br> <br>static int GetRelativeDir( int lastDir, int notchVec, int newDir ); <br> <br>/**************************************************************************\ <br>* FLEX_PIPE constructor <br>* <br>* <br>\**************************************************************************/ <br> <br>FLEX_PIPE::FLEX_PIPE( STATE *pState ) <br>: PIPE( pState ) <br>{ <br>    float circ; <br> <br>    // Create an EVAL object <br> <br>    nSlices = pState-&gt;nSlices; <br> <br>    // No XC's yet, they will be allocated at pipe Start() <br>    xcCur = xcEnd = NULL; <br> <br>    // The EVAL will be used for all pEvals in the pipe, so should be <br>    // set to hold max. possible # of pts for the pipe. <br>    pEval = new EVAL( bTexture ); <br> <br>    // Determine pipe tesselation <br>    // For now, this is based on global tesselation factor <br> <br>    // Calculate evalDivSize, a reference value for the size of a UxV division. <br>    // This is used later for calculating texture coords. <br>    circ = CIRCUMFERENCE( pState-&gt;radius ); <br>    evalDivSize = circ / (float) nSlices; <br>} <br> <br>/**************************************************************************\ <br>* ~FLEX_PIPE <br>* <br>\**************************************************************************/ <br> <br>FLEX_PIPE::~FLEX_PIPE( ) <br>{ <br>    delete pEval; <br> <br>    // delete any XC's <br>    if( xcCur != NULL ) { <br>        if( xcEnd == xcCur ) <br>            xcEnd = NULL; // xcCur and xcEnd can point to same xc ! <br>        delete xcCur; <br>        xcCur = NULL; <br>    } <br> <br>    if( xcEnd != NULL ) { <br>        delete xcEnd; <br>        xcEnd = NULL; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* REGULAR_FLEX_PIPE constructor <br>* <br>\**************************************************************************/ <br> <br>REGULAR_FLEX_PIPE::REGULAR_FLEX_PIPE( STATE *state ) <br>: FLEX_PIPE( state ) <br>{ <br>    static float turnFactorRange = 0.1f; <br>    type = TYPE_FLEX_REGULAR; <br> <br>    // figure out turning factor range (0 for min bends, 1 for max bends) <br>    float avgTurn = ss_fRand( 0.11f, 0.81f ); <br>    // set min and max turn factors, and clamp to 0..1 <br>    turnFactorMin =  <br>                SS_CLAMP_TO_RANGE( avgTurn - turnFactorRange, 0.0f, 1.0f ); <br>    turnFactorMax =  <br>                SS_CLAMP_TO_RANGE( avgTurn + turnFactorRange, 0.0f, 1.0f ); <br> <br>    // choose straight weighting <br>    // mf:for now, same as npipe - if stays same, put in pipe <br>    if( ! ss_iRand( 20 ) ) <br>        weightStraight = ss_iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT ); <br>    else <br>        weightStraight = ss_iRand( 4 ); <br>} <br> <br>/**************************************************************************\ <br>* TURNING_FLEX_PIPE constructor <br>* <br>\**************************************************************************/ <br> <br>TURNING_FLEX_PIPE::TURNING_FLEX_PIPE( STATE *state ) <br>: FLEX_PIPE( state ) <br>{ <br>    type = TYPE_FLEX_TURNING; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetTexIndex <br>* <br>* Set the texture index for this pipe, and calculate texture state dependent <br>* on texRep values <br>\**************************************************************************/ <br> <br>void <br>FLEX_PIPE::SetTexParams( TEXTURE *pTex, IPOINT2D *pTexRep ) <br>{ <br>    if( bTexture ) { <br>        GLfloat t_size; <br>        float circ; <br> <br>        t_start = (GLfloat) pTexRep-&gt;y * 1.0f; <br>        t_end = 0.0f; <br> <br>        // calc height (t_size) of one rep of texture around circumference <br>        circ = CIRCUMFERENCE( radius ); <br>        t_size = circ / pTexRep-&gt;y; <br> <br>        // now calc corresponding width of the texture using its x/y ratio <br>        s_length = t_size / pTex-&gt;origAspectRatio; <br>        s_start = s_end = 0.0f; <br>// this means we are 'standardizing' the texture size and proportions <br>// on pipe of radius 1.0 for entire program.  Might want to recalc this on <br>// a per-pipe basis ? <br>    } <br>} <br> <br>/**************************************************************************\ <br>* ChooseXCProfile <br>* <br>* Initialize extruded pipe scheme.  This uses a randomly constructed XC, but it <br>* remains constant throughout the pipe <br>* <br>\**************************************************************************/ <br> <br>void <br>FLEX_PIPE::ChooseXCProfile() <br>{ <br>    static float turnFactorRange = 0.1f; <br>    float baseRadius = pState-&gt;radius; <br> <br>    // initialize evaluator elements: <br> <br>    pEval-&gt;numSections = EVAL_XC_CIRC_SECTION_COUNT; <br>    pEval-&gt;uOrder = EVAL_ARC_ORDER; <br>//  watch this - maybe should ROUND_UP uDiv <br>    // set uDiv per section (assumed uDiv multiple of numSections) <br>    pEval-&gt;uDiv = nSlices / pEval-&gt;numSections; <br> <br>    // Setup XC's <br> <br>    // The xc profile remains constant throughout in this case, <br>    // so we only need one xc. <br> <br>    // Choose between elliptical or random cross-sections.  Since elliptical <br>    //  looks a little better, make it more likely <br>    if( ss_iRand(4) )  // 3/4 of the time <br>        xcCur = new ELLIPTICAL_XC( ss_fRand(1.2f, 2.0f) * baseRadius,  <br>                                           baseRadius ); <br>    else <br>        xcCur = new RANDOM4ARC_XC( ss_fRand(1.5f, 2.0f) * baseRadius ); <br>} <br> <br> <br>/**************************************************************************\ <br>* REGULAR_FLEX_PIPE::Start <br>* <br>* Does startup of extruded-XC pipe drawing scheme  <br>* <br>\**************************************************************************/ <br> <br>void <br>REGULAR_FLEX_PIPE::Start() <br>{ <br>    NODE_ARRAY *nodes = pState-&gt;nodes; <br>    int newDir; <br> <br>    // Set start position <br> <br>    if( !SetStartPos() ) { <br>        status = PIPE_OUT_OF_NODES; <br>        return; <br>    } <br> <br>    // set material <br> <br>    ChooseMaterial(); <br> <br>    // set XC profile <br> <br>    ChooseXCProfile(); <br> <br>    // push matrix with zTrans and scene rotation <br> <br>    glPushMatrix(); <br> <br>    // Translate to current position <br>    TranslateToCurrentPosition(); <br> <br>    // set random lastDir <br>    lastDir = ss_iRand( NUM_DIRS ); <br> <br>    // get a new node to draw to <br>    newDir = ChooseNewDirection(); <br> <br>    if( newDir == DIR_NONE ) { <br>        // draw like one of those tea-pouring thingies... <br>        status = PIPE_STUCK; <br>        DrawTeapot(); <br>        glPopMatrix(); <br>        return; <br>    } else <br>        status = PIPE_ACTIVE; <br> <br>    align_plusz( newDir ); // get us pointed in right direction <br> <br>    // draw start cap, which will end right at current node <br>    DrawCap( START_CAP ); <br> <br>    // set initial notch vector, which is just the default notch, since <br>    // we didn't have to spin the start cap around z <br>    notchVec = defCylNotch[newDir]; <br> <br>    zTrans = - pState-&gt;view.divSize;  // distance back from new node <br> <br>    UpdateCurrentPosition( newDir ); <br> <br>    lastDir = newDir; <br>} <br> <br>/**************************************************************************\ <br>* TURNING_FLEX_PIPE::Start <br>* <br>* Does startup of turning extruded-XC pipe drawing scheme  <br>* <br>\**************************************************************************/ <br> <br>void <br>TURNING_FLEX_PIPE::Start( ) <br>{ <br>    NODE_ARRAY *nodes = pState-&gt;nodes; <br> <br>    // Set start position <br> <br>    if( !SetStartPos() ) { <br>        status = PIPE_OUT_OF_NODES; <br>        return; <br>    } <br> <br>    // Set material <br> <br>    ChooseMaterial(); <br> <br>    // Set XC profile <br> <br>    ChooseXCProfile(); <br> <br>    // Push matrix with zTrans and scene rotation <br> <br>    glPushMatrix(); <br> <br>    // Translate to current position <br>    TranslateToCurrentPosition(); <br> <br>    // lastDir has to be set to something valid, in case we get stuck right <br>    // away, cuz Draw() will be called anyways on next iteration, whereupon <br>    // it finds out it really is stuck, AFTER calling ChooseNewTurnDirection, <br>    // which requires valid lastDir. (mf: fix this) <br>    lastDir = ss_iRand( NUM_DIRS ); <br> <br>    // Pick a starting direction by finding a neihgbouring empty node <br>    int newDir = nodes-&gt;FindClearestDirection( &amp;curPos ); <br>    // We don't 'choose' it, or mark it as taken, because ChooseNewDirection <br>    // will always check it anyways <br> <br> <br>    if( newDir == DIR_NONE ) { <br>        // we can't go anywhere <br>        // draw like one of those tea-pouring thingies... <br>        status = PIPE_STUCK; <br>        DrawTeapot(); <br>        glPopMatrix(); <br>        return; <br>    } else <br>        status = PIPE_ACTIVE; <br> <br>    align_plusz( newDir ); // get us pointed in right direction <br> <br>    // Draw start cap, which will end right at current node <br>    DrawCap( START_CAP ); <br> <br>    // Set initial notch vector, which is just the default notch, since <br>    // we didn't have to spin the start cap around z <br>    notchVec = defCylNotch[newDir]; <br> <br>    zTrans = 0.0f;  // right at current node <br> <br>    lastDir = newDir; <br>} <br> <br>/**************************************************************************\ <br>* REGULAR_FLEX_PIPE::Draw <br>* <br>* Draws the pipe using a constant random xc that is extruded <br>* <br>* Minimum turn radius can vary, since xc is not symmetrical across any <br>* of its axes.  Therefore here we draw using a pipe/elbow sequence, so we <br>* know what direction we're going in before drawing the elbow.  The current <br>* node is the one we will draw thru next time.  Typically, the actual end <br>* of the pipe is way back of this node, almost at the previous node, due <br>* to the variable turn radius <br>* <br>\**************************************************************************/ <br> <br>void <br>REGULAR_FLEX_PIPE::Draw( ) <br>{ <br>    float turnRadius, minTurnRadius; <br>    float pipeLen, maxPipeLen, minPipeLen; <br>    int newDir, relDir; <br>    float maxXCExtent; <br>    NODE_ARRAY *nodes = pState-&gt;nodes; <br>    float divSize = pState-&gt;view.divSize; <br> <br>    // get new direction <br> <br>    newDir = ChooseNewDirection(); <br>    if( newDir == DIR_NONE ) { <br>        status = PIPE_STUCK; <br>        DrawCap( END_CAP ); <br>        glPopMatrix(); <br>        return; <br>    } <br> <br>    // draw pipe, and if turning, joint <br> <br>    if( newDir != lastDir ) { // turning! - we have to draw joint <br> <br>        // get relative turn, to figure turn radius <br> <br>        relDir = GetRelativeDir( lastDir, notchVec, newDir ); <br>        minTurnRadius = xcCur-&gt;MinTurnRadius( relDir ); <br> <br>        // now calc maximum straight section we can draw before turning <br>        // zTrans is current pos'n of end of pipe, from current node ?? <br>        // zTrans is current pos'n of end of pipe, from last node <br> <br>        maxPipeLen = (-zTrans) - minTurnRadius; <br> <br>        // there is also a minimum requirement for the length of the straight <br>        // section, cuz if we turn too soon with a large turn radius, we <br>        // will swing up too close to the next node, and won't be able to <br>        // make one or more of the 4 possible turns from that point <br> <br>        maxXCExtent = xcCur-&gt;MaxExtent(); // in case need it again <br>        minPipeLen = maxXCExtent - (divSize + zTrans); <br>        if( minPipeLen &lt; 0.0f ) <br>            minPipeLen = 0.0f; <br> <br>        // Choose length of straight section <br>        // (we are translating from turnFactor to 'straightFactor' here) <br>        pipeLen = minPipeLen + <br>            ss_fRand( 1.0f - turnFactorMax, 1.0f - turnFactorMin ) *  <br>                        (maxPipeLen - minPipeLen); <br> <br>        // turn radius is whatever's left over: <br>        turnRadius = maxPipeLen - pipeLen + minTurnRadius; <br> <br>        // draw straight section <br>        DrawExtrudedXCObject( pipeLen ); <br>        zTrans += pipeLen; // not necessary for now, since elbow no use <br> <br>        // draw elbow <br>        // this updates axes, notchVec to position at end of elbow <br>        DrawXCElbow( newDir, turnRadius ); <br> <br>        zTrans = -(divSize - turnRadius);  // distance back from node <br>    } <br>    else {  // no turn <br>        // draw a straight pipe through the current node <br>        // length can vary according to the turnFactors (e.g. for high turn <br>        // factors draw a short pipe, so next turn can be as big as possible) <br> <br>        minPipeLen = -zTrans; // brings us just up to last node <br>        maxPipeLen = minPipeLen + divSize - xcCur-&gt;MaxExtent(); <br>        // brings us as close as possible to new node <br> <br>        pipeLen = minPipeLen + <br>            ss_fRand( 1.0f - turnFactorMax, 1.0f - turnFactorMin ) *  <br>                        (maxPipeLen - minPipeLen); <br> <br>        // draw pipe <br>        DrawExtrudedXCObject( pipeLen ); <br>        zTrans += (-divSize + pipeLen); <br>    } <br> <br>    UpdateCurrentPosition( newDir ); <br> <br>    lastDir = newDir; <br>} <br> <br>/**************************************************************************\ <br>* DrawTurningXCPipe <br>* <br>* Draws the pipe using only turns <br>* <br>* - Go straight if no turns available <br>* <br>\**************************************************************************/ <br> <br>void <br>TURNING_FLEX_PIPE::Draw() <br>{ <br>    float turnRadius; <br>    int newDir; <br>    NODE_ARRAY *nodes = pState-&gt;nodes; <br>    float divSize = pState-&gt;view.divSize; <br> <br>    // get new direction <br> <br>    // pipe may have gotten stuck on Start...(we don't check for this) <br> <br>    newDir = nodes-&gt;ChooseNewTurnDirection( &amp;curPos, lastDir ); <br>    if( newDir == DIR_NONE ) { <br>        status = PIPE_STUCK; <br>        DrawCap( END_CAP ); <br>        glPopMatrix(); <br>        return; <br>    } <br> <br>    if( newDir == DIR_STRAIGHT ) { <br>        // No turns available - draw straight section and hope for turns <br>        //  on next iteration <br>        DrawExtrudedXCObject( divSize ); <br>        UpdateCurrentPosition( lastDir ); <br>        // ! we have to mark node as taken for this case, since <br>        // ChooseNewTurnDirection doesn't know whether we're taking the <br>        // straight option or not <br>        nodes-&gt;NodeVisited( &amp;curPos ); <br>    } else { <br>        // draw turning pipe <br> <br>        // since xc is always located right at current node, turn radius <br>        // stays constant at one node division <br> <br>        turnRadius = divSize; <br> <br>        DrawXCElbow( newDir, turnRadius ); <br> <br>        // (zTrans stays at 0) <br> <br>        // need to update 2 nodes <br>        UpdateCurrentPosition( lastDir ); <br>        UpdateCurrentPosition( newDir ); <br> <br>        lastDir = newDir; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* DrawXCElbow <br>* <br>* Draw elbow from current position through new direction <br>* <br>* - Extends current xc around bend <br>* - Radius of bend is provided - this is distance from xc center to hinge <br>*   point, along newDir.  e.g. for 'normal pipes', radius=vc-&gt;radius <br>* <br>\**************************************************************************/ <br> <br>void <br>FLEX_PIPE::DrawXCElbow( int newDir, float radius ) <br>{ <br>    int relDir;  // 'relative' direction of turn <br>    float length; <br> <br>    length = (2.0f * PI * radius) / 4.0f; // average length of elbow <br> <br>    // calc vDiv, texture params based on length <br>    CalcEvalLengthParams( length ); <br> <br>    pEval-&gt;vOrder = EVAL_ARC_ORDER; <br> <br>    // convert absolute dir to relative dir <br>    relDir = GetRelativeDir( lastDir, notchVec, newDir ); <br> <br>    // draw it - call simple bend function <br> <br>    pEval-&gt;ProcessXCPrimBendSimple( xcCur, relDir, radius ); <br> <br>    // set transf. matrix to new position by translating/rotating/translating <br>    // ! Based on simple elbow <br>    glTranslatef( 0.0f, 0.0f, radius ); <br>    switch( relDir ) { <br>        case PLUS_X: <br>            glRotatef( 90.0f, 0.0f, 1.0f, 0.0f ); <br>            break; <br>        case MINUS_X: <br>            glRotatef( -90.0f, 0.0f, 1.0f, 0.0f ); <br>            break; <br>        case PLUS_Y: <br>            glRotatef( -90.0f, 1.0f, 0.0f, 0.0f ); <br>            break; <br>        case MINUS_Y: <br>            glRotatef( 90.0f, 1.0f, 0.0f, 0.0f ); <br>            break; <br>    } <br>    glTranslatef( 0.0f, 0.0f, radius ); <br>     <br>    // update notch vector using old function <br>    notchVec = notchTurn[lastDir][newDir][notchVec]; <br>} <br> <br>/**************************************************************************\ <br>* DrawExtrudedXCObject <br>* <br>* Draws object generated by extruding the current xc <br>* <br>* Object starts at xc at origin in z=0 plane, and grows along +z axis  <br>* <br>\**************************************************************************/ <br> <br>void  <br>FLEX_PIPE::DrawExtrudedXCObject( float length ) <br>{ <br>    // calc vDiv, and texture coord stuff based on length <br>    // this also calcs pEval texture ctrl pt arrray now <br>    CalcEvalLengthParams( length ); <br> <br>    // we can fill in some more stuff: <br>    pEval-&gt;vOrder = EVAL_CYLINDER_ORDER; <br> <br> <br>    // draw it <br> <br>    pEval-&gt;ProcessXCPrimLinear( xcCur, xcCur, length ); <br> <br>    // update state draw axes position <br>    glTranslatef( 0.0f, 0.0f, length ); <br>} <br> <br>/**************************************************************************\ <br>* DrawXCCap <br>* <br>* Cap the start of the pipe <br>* <br>* Needs newDir, so it can orient itself. <br>* Cap ends at current position with approppriate profile, starts a distance <br>* 'z' back along newDir. <br>* Profile is a singularity at start point. <br>* <br>\**************************************************************************/ <br> <br>void  <br>FLEX_PIPE::DrawCap( int type ) <br>{ <br>    float radius; <br>    XC *xc = xcCur; <br>    BOOL bOpening = (type == START_CAP) ? TRUE : FALSE; <br>    float length; <br> <br>    // set radius as average of the bounding box min/max's <br>    radius = ((xc-&gt;xRight - xc-&gt;xLeft) + (xc-&gt;yTop - xc-&gt;yBottom)) / 4.0f; <br> <br>    length = (2.0f * PI * radius) / 4.0f; // average length of arc <br> <br>    // calc vDiv, and texture coord stuff based on length <br>    CalcEvalLengthParams( length ); <br> <br>    // we can fill in some more stuff: <br>    pEval-&gt;vOrder = EVAL_ARC_ORDER; <br> <br>    // draw it <br> <br>    pEval-&gt;ProcessXCPrimSingularity( xc, radius, bOpening ); <br>} <br> <br>/**************************************************************************\ <br>* CalcEvalLengthParams  <br>* <br>* Calculate pEval values that depend on the length of the extruded object <br>* <br>* - calculate vDiv, s_start, s_end, and the texture control net array <br>* <br>\**************************************************************************/ <br> <br>void  <br>FLEX_PIPE::CalcEvalLengthParams( float length ) <br>{ <br>    pEval-&gt;vDiv = (int ) SS_ROUND_UP( length / evalDivSize );  <br> <br>    // calc texture start and end coords <br> <br>    if( bTexture ) { <br>        GLfloat s_delta; <br> <br>        // Don't let s_end overflow : it should stay in range (0..1.0) <br>        if( s_end &gt; 1.0f ) <br>            s_end -= (int) s_end; <br> <br>        s_start = s_end; <br>        s_delta = (length / s_length ); <br>        s_end = s_start + s_delta; <br>         <br>        // the texture ctrl point array can be calc'd here - it is always <br>        // a simple 2x2 array for each section <br>        pEval-&gt;SetTextureControlPoints( s_start, s_end, t_start, t_end ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* <br>* GetRelativeDir  <br>* <br>* Calculates relative direction of turn from lastDir, notchVec, newDir <br>* <br>* - Use look up table for now. <br>* - Relative direction is from xy-plane, and can be +x,-x,+y,-y    <br>* - In current orientation, +z is along lastDir, +x along notchVec <br>\**************************************************************************/ <br> <br>// this array tells you relative turn <br>// format: relDir[lastDir][notchVec][newDir] <br>static int relDir[NUM_DIRS][NUM_DIRS][NUM_DIRS] = { <br>//      +x      -x      +y      -y      +z      -z (newDir) <br>// lastDir = +x <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Y, MINUS_Y, <br>        iXX,    iXX,    MINUS_X,PLUS_X, MINUS_Y,PLUS_Y, <br>        iXX,    iXX,    MINUS_Y,PLUS_Y, PLUS_X, MINUS_X, <br>        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, <br>// lastDir = -x <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    PLUS_X, MINUS_X,MINUS_Y,PLUS_Y, <br>        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Y, MINUS_Y, <br>        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X, <br>        iXX,    iXX,    MINUS_Y,PLUS_Y, MINUS_X,PLUS_X, <br>// lastDir = +y <br>        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y, <br>        MINUS_X,PLUS_X, iXX,    iXX,    PLUS_Y, MINUS_Y, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_X, MINUS_X, <br>        MINUS_Y,PLUS_Y, iXX,    iXX,    MINUS_X,PLUS_X, <br>// lastDir = -y <br>        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y, <br>        MINUS_X,PLUS_X, iXX,    iXX,    MINUS_Y,PLUS_Y, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_X, MINUS_X, <br>        PLUS_Y, MINUS_Y,iXX,    iXX,    MINUS_X,PLUS_X, <br> <br>// lastDir = +z <br>        PLUS_X, MINUS_X,PLUS_Y, MINUS_Y,iXX,    iXX, <br>        MINUS_X,PLUS_X, MINUS_Y,PLUS_Y, iXX,    iXX, <br>        MINUS_Y,PLUS_Y, PLUS_X, MINUS_X,iXX,    iXX, <br>        PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>// lastDir = -z <br>        PLUS_X, MINUS_X,MINUS_Y,PLUS_Y, iXX,    iXX, <br>        MINUS_X,PLUS_X, PLUS_Y, MINUS_Y,iXX,    iXX, <br>        PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,iXX,    iXX, <br>        MINUS_Y,PLUS_Y, MINUS_X,PLUS_X, iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX <br>}; <br> <br>static int <br>GetRelativeDir( int lastDir, int notchVec, int newDir ) <br>{ <br>    return( relDir[lastDir][notchVec][newDir] ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
