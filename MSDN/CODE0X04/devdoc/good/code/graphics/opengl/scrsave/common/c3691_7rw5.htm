<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FASTDIB.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3695"></a>FASTDIB.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: fastdib.c <br>* <br>* CreateCompatibleDIB implementation. <br>* <br>* Copyright 1996 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stddef.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#include "sscommon.h" <br> <br>BOOL APIENTRY GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector); <br>static BOOL bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi); <br>static BOOL bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi); <br>static UINT MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries, <br>                                      LPPALETTEENTRY lppe); <br>static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, <br>                                        BYTE *pajVector); <br> <br>/******************************Public*Routine******************************\ <br>* CreateCompatibleDIB <br>* <br>* Create a DIB section with an optimal format w.r.t. the specified hdc. <br>* <br>* If DIB &lt;= 8bpp, then the DIB color table is initialized based on the <br>* specified palette.  If the palette handle is NULL, then the system <br>* palette is used. <br>* <br>* Note: The hdc must be a direct DC (not an info or memory DC). <br>* <br>* Note: On palettized displays, if the system palette changes the <br>*       UpdateDIBColorTable function should be called to maintain <br>*       the identity palette mapping between the DIB and the display. <br>* <br>* Returns: <br>*   Valid bitmap handle if successful, NULL if error. <br>\**************************************************************************/ <br> <br>//HBITMAP APIENTRY <br>HBITMAP <br>SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight, <br>                    PVOID *ppvBits) <br>{ <br>    HBITMAP hbmRet = (HBITMAP) NULL; <br>    BYTE aj[sizeof(BITMAPINFO) + (sizeof(RGBQUAD) * 255)]; <br>    BITMAPINFO *pbmi = (BITMAPINFO *) aj; <br> <br>    // <br>    // Validate hdc. <br>    // <br> <br>    if ( GetObjectType(hdc) != OBJ_DC ) <br>    { <br>        SS_DBGPRINT("CreateCompatibleDIB: not OBJ_DC\n"); <br>        return hbmRet; <br>    } <br> <br>    memset(aj, 0, sizeof(aj)); <br>    if ( bFillBitmapInfo(hdc, hpal, pbmi) ) <br>    { <br>        // <br>        // Change bitmap size to match specified dimensions. <br>        // <br> <br>        pbmi-&gt;bmiHeader.biWidth = ulWidth; <br>        pbmi-&gt;bmiHeader.biHeight = ulHeight; <br>        if (pbmi-&gt;bmiHeader.biCompression == BI_RGB) <br>        { <br>            pbmi-&gt;bmiHeader.biSizeImage = 0; <br>        } <br>        else <br>        { <br>            if ( pbmi-&gt;bmiHeader.biBitCount == 16 ) <br>                pbmi-&gt;bmiHeader.biSizeImage = ulWidth * ulHeight * 2; <br>            else if ( pbmi-&gt;bmiHeader.biBitCount == 32 ) <br>                pbmi-&gt;bmiHeader.biSizeImage = ulWidth * ulHeight * 4; <br>            else <br>                pbmi-&gt;bmiHeader.biSizeImage = 0; <br>        } <br>        pbmi-&gt;bmiHeader.biClrUsed = 0; <br>        pbmi-&gt;bmiHeader.biClrImportant = 0; <br> <br>        // <br>        // Create the DIB section.  Let Win32 allocate the memory and return <br>        // a pointer to the bitmap surface. <br>        // <br> <br>        hbmRet = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, ppvBits, NULL, 0); <br>        GdiFlush(); <br> <br>        if ( !hbmRet ) <br>        { <br>            SS_DBGPRINT("CreateCompatibleDIB: CreateDIBSection failed\n"); <br>        } <br>    } <br>    else <br>    { <br>        SS_DBGPRINT("CreateCompatibleDIB: bFillBitmapInfo failed\n"); <br>    } <br> <br>    return hbmRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* UpdateDIBColorTable <br>* <br>* Synchronize the DIB color table to the specified palette hpal. <br>* If hpal is NULL, then use the system palette. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>\**************************************************************************/ <br> <br>BOOL APIENTRY <br>SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal) <br>{ <br>    BOOL bRet = FALSE; <br>    HBITMAP hbm; <br>    DIBSECTION ds; <br>    BYTE aj[(sizeof(RGBQUAD) + sizeof(PALETTEENTRY)) * 256]; <br>    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj; <br>    LPRGBQUAD prgb = (LPRGBQUAD) (lppe + 256); <br>    ULONG cColors; <br> <br>    // <br>    // Validate hdc. <br>    // <br> <br>    if ( GetObjectType(hdc) != OBJ_DC ) <br>    { <br>        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_DC\n"); <br>        return bRet; <br>    } <br>    if ( GetObjectType(hdcMem) != OBJ_MEMDC ) <br>    { <br>        SS_DBGPRINT("UpdateDIBColorTable: not OBJ_MEMDC\n"); <br>        return bRet; <br>    } <br> <br>    // <br>    // Get the bitmap handle out of the memdc. <br>    // <br> <br>    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP); <br> <br>    // <br>    // Validate bitmap (must be DIB section). <br>    // <br> <br>    if ( (GetObject(hbm, sizeof(ds), &amp;ds) == sizeof(ds)) &amp;&amp; <br>         ds.dsBm.bmBits ) <br>    { <br>        // <br>        // Get palette entries from specified palette or system palette. <br>        // <br> <br>        cColors = 1 &lt;&lt; ds.dsBmih.biBitCount; <br> <br> <br>        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe) <br>                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) <br>           ) <br>        { <br>            UINT i; <br> <br>            // <br>            // Convert to RGBQUAD. <br>            // <br> <br>            for (i = 0; i &lt; cColors; i++) <br>            { <br>                prgb[i].rgbRed      = lppe[i].peRed; <br>                prgb[i].rgbGreen    = lppe[i].peGreen; <br>                prgb[i].rgbBlue     = lppe[i].peBlue; <br>                prgb[i].rgbReserved = 0; <br>            } <br> <br>            // <br>            // Set the DIB color table. <br>            // <br> <br>            bRet = (BOOL) SetDIBColorTable(hdcMem, 0, cColors, prgb); <br> <br>            if (!bRet) <br>            { <br>                SS_DBGPRINT("UpdateDIBColorTable: SetDIBColorTable failed\n"); <br>            } <br>        } <br>        else <br>        { <br>            SS_DBGPRINT("UpdateDIBColorTable: MyGetSystemPaletteEntries failed\n"); <br>        } <br>    } <br>    else <br>    { <br>        SS_DBGPRINT("UpdateDIBColorTable: GetObject failed\n"); <br>    } <br> <br>    return bRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* GetCompatibleDIBInfo <br>* <br>* Copies pointer to bitmap origin to ppvBase and bitmap stride to plStride. <br>* Win32 DIBs can be created bottom-up (the default) with the origin at the <br>* lower left corner or top-down with the origin at the upper left corner. <br>* If the bitmap is top-down, *plStride is positive; if bottom-up, *plStride <br>* us negative. <br>* <br>* Also, because of restrictions on the alignment of scan lines the width <br>* the bitmap is often not the same as the stride (stride is the number of <br>* bytes between vertically adjacent pixels). <br>* <br>* The ppvBase and plStride value returned will allow you to address any <br>* given pixel (x, y) in the bitmap as follows: <br>* <br>* PIXEL *ppix; <br>* <br>* ppix = (PIXEL *) (((BYTE *)*ppvBase) + (y * *plStride) + (x * sizeof(PIXEL))); <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>\**************************************************************************/ <br> <br>BOOL APIENTRY <br>GetCompatibleDIBInfo(HBITMAP hbm, PVOID *ppvBase, LONG *plStride) <br>{ <br>    BOOL bRet = FALSE; <br>    DIBSECTION ds; <br> <br>    // <br>    // Call GetObject to return a DIBSECTION.  If successful, the <br>    // bitmap is a DIB section and we can retrieve the pointer to <br>    // the bitmap bits and other parameters. <br>    // <br> <br>    if ( (GetObject(hbm, sizeof(ds), &amp;ds) == sizeof(ds)) <br>         &amp;&amp; ds.dsBm.bmBits ) <br>    { <br>        // For backwards compatibility with Get/SetBitmapBits, GDI does <br>        // not accurately report the bitmap pitch in bmWidthBytes.  It <br>        // always computes bmWidthBytes assuming WORD-aligned scanlines <br>        // regardless of the platform. <br>        // <br>        // Therefore, if the platform is WinNT, which uses DWORD-aligned <br>        // scanlines, adjust the bmWidthBytes value. <br> <br>        { <br>            OSVERSIONINFO osvi; <br> <br>            osvi.dwOSVersionInfoSize = sizeof(osvi); <br>            if (GetVersionEx(&amp;osvi)) <br>            { <br>                if ( osvi.dwPlatformId == VER_PLATFORM_WIN32_NT ) <br>                { <br>                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) &amp; ~3; <br>                } <br>            } <br>            else <br>            { <br>                SS_DBGPRINT1("GetCompatibleDIBInfo: GetVersionEx failed with %d\n", GetLastError()); <br>                return bRet; <br>            } <br>        } <br> <br>        // <br>        // If biHeight is positive, then the bitmap is a bottom-up DIB. <br>        // If biHeight is negative, then the bitmap is a top-down DIB. <br>        // <br> <br>        if ( ds.dsBmih.biHeight &gt; 0 ) <br>        { <br>            *ppvBase  = (PVOID) (((int) ds.dsBm.bmBits) + (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1))); <br>            *plStride = (ULONG) (-ds.dsBm.bmWidthBytes); <br>        } <br>        else <br>        { <br>            *ppvBase  = ds.dsBm.bmBits; <br>            *plStride = ds.dsBm.bmWidthBytes; <br>        } <br> <br>        bRet = TRUE; <br>    } <br>    else <br>    { <br>        SS_DBGPRINT("GetCompatibleDIBInfo: cannot get pointer to DIBSECTION bmBits\n"); <br>    } <br> <br>    return bRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* GetDIBTranslationVector <br>* <br>* Copies the translation vector that maps colors in the specified palette, <br>* hpal, to the DIB selected into the specified DC, hdcMem. <br>* <br>* Effects: <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>\**************************************************************************/ <br> <br>BOOL APIENTRY <br>GetDIBTranslationVector(HDC hdcMem, HPALETTE hpal, BYTE *pbVector) <br>{ <br>    BOOL bRet = FALSE; <br>    HBITMAP hbm; <br>    DIBSECTION ds; <br> <br>    // <br>    // Validate parameters. <br>    // <br> <br>    if ( GetObjectType(hdcMem) != OBJ_MEMDC || <br>         GetObjectType(hpal) != OBJ_PAL || <br>         !pbVector ) <br>    { <br>        SS_DBGPRINT("GetDIBTranslationVector: bad parameter\n"); <br>        return bRet; <br>    } <br> <br>    // <br>    // The function bComputeLogicalToSurfaceMap cannot handle palettes <br>    // greater than 256 entries. <br>    // <br> <br>    if ( GetPaletteEntries(hpal, 0, 1, NULL) &gt; 256 ) <br>    { <br>        SS_DBGPRINT("GetDIBTranslationVector: palette too big\n"); <br>        return bRet; <br>    } <br> <br>    // <br>    // The DIB must have a color table. <br>    // <br> <br>    hbm = GetCurrentObject(hdcMem, OBJ_BITMAP); <br>    if ( (GetObject(hbm, sizeof(ds), &amp;ds) == sizeof(ds)) <br>         &amp;&amp; (ds.dsBmih.biBitCount &lt;= 8) ) <br>    { <br>        bRet = bComputeLogicalToSurfaceMap(hdcMem, hpal, pbVector); <br>    } <br>    else <br>    { <br>        SS_DBGPRINT("GetDIBTranslationVector: not a DIB section\n"); <br>        return bRet; <br>    } <br> <br>    return bRet; <br>} <br> <br>//////////////////// Below here are internal-only routines //////////////////// <br> <br>/******************************Public*Routine******************************\ <br>* bFillBitmapInfo <br>* <br>* Fills in the fields of a BITMAPINFO so that we can create a bitmap <br>* that matches the format of the display. <br>* <br>* This is done by creating a compatible bitmap and calling GetDIBits <br>* to return the color masks.  This is done with two calls.  The first <br>* call passes in biBitCount = 0 to GetDIBits which will fill in the <br>* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing <br>* in the BITMAPINFO filled in by the first call) will return the color <br>* table or bitmasks, as appropriate. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>\**************************************************************************/ <br> <br>static BOOL <br>bFillBitmapInfo(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi) <br>{ <br>    HBITMAP hbm; <br>    BOOL    bRet = FALSE; <br> <br>    // <br>    // Create a dummy bitmap from which we can query color format info <br>    // about the device surface. <br>    // <br> <br>    if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL ) <br>    { <br>        pbmi-&gt;bmiHeader.biSize = sizeof(BITMAPINFOHEADER); <br> <br>        // <br>        // Call first time to fill in BITMAPINFO header. <br>        // <br> <br>        GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS); <br> <br>        if ( pbmi-&gt;bmiHeader.biBitCount &lt;= 8 ) <br>        { <br>            bRet = bFillColorTable(hdc, hpal, pbmi); <br>        } <br>        else <br>        { <br>            if ( pbmi-&gt;bmiHeader.biCompression == BI_BITFIELDS ) <br>            { <br>                // <br>                // Call a second time to get the color masks. <br>                // It's a GetDIBits Win32 "feature". <br>                // <br> <br>                GetDIBits(hdc, hbm, 0, pbmi-&gt;bmiHeader.biHeight, NULL, pbmi, <br>                          DIB_RGB_COLORS); <br>            } <br> <br>            bRet = TRUE; <br>        } <br> <br>        DeleteObject(hbm); <br>    } <br>    else <br>    { <br>        SS_DBGPRINT("bFillBitmapInfo: CreateCompatibleBitmap failed\n"); <br>    } <br> <br>    return bRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* bFillColorTable <br>* <br>* Initialize the color table of the BITMAPINFO pointed to by pbmi.  Colors <br>* are set to the current system palette. <br>* <br>* Note: call only valid for displays of 8bpp or less. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise. <br>\**************************************************************************/ <br> <br>static BOOL <br>bFillColorTable(HDC hdc, HPALETTE hpal, BITMAPINFO *pbmi) <br>{ <br>    BOOL bRet = FALSE; <br>    BYTE aj[sizeof(PALETTEENTRY) * 256]; <br>    LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj; <br>    RGBQUAD *prgb = (RGBQUAD *) &amp;pbmi-&gt;bmiColors[0]; <br>    ULONG cColors; <br> <br>    cColors = 1 &lt;&lt; pbmi-&gt;bmiHeader.biBitCount; <br>    if ( cColors &lt;= 256 ) <br>    { <br>        if ( hpal ? GetPaletteEntries(hpal, 0, cColors, lppe) <br>                  : MyGetSystemPaletteEntries(hdc, 0, cColors, lppe) ) <br>        { <br>            UINT i; <br> <br>            for (i = 0; i &lt; cColors; i++) <br>            { <br>                prgb[i].rgbRed      = lppe[i].peRed; <br>                prgb[i].rgbGreen    = lppe[i].peGreen; <br>                prgb[i].rgbBlue     = lppe[i].peBlue; <br>                prgb[i].rgbReserved = 0; <br>            } <br> <br>            bRet = TRUE; <br>        } <br>        else <br>        { <br>            SS_DBGPRINT("bFillColorTable: MyGetSystemPaletteEntries failed\n"); <br>        } <br>    } <br> <br>    return bRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* MyGetSystemPaletteEntries <br>* <br>* Internal version of GetSystemPaletteEntries. <br>* <br>* GetSystemPaletteEntries fails on some 4bpp devices.  This version <br>* will detect the 4bpp case and supply the hardcoded 16-color VGA palette. <br>* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries. <br>* <br>* It is expected that this call will only be called in the 4bpp and 8bpp <br>* cases as it is not necessary for OpenGL to query the system palette <br>* for &gt; 8bpp devices. <br>\**************************************************************************/ <br> <br>static PALETTEENTRY gapeVgaPalette[16] = <br>{ <br>    { 0,   0,   0,    0 }, <br>    { 0x80,0,   0,    0 }, <br>    { 0,   0x80,0,    0 }, <br>    { 0x80,0x80,0,    0 }, <br>    { 0,   0,   0x80, 0 }, <br>    { 0x80,0,   0x80, 0 }, <br>    { 0,   0x80,0x80, 0 }, <br>    { 0x80,0x80,0x80, 0 }, <br>    { 0xC0,0xC0,0xC0, 0 }, <br>    { 0xFF,0,   0,    0 }, <br>    { 0,   0xFF,0,    0 }, <br>    { 0xFF,0xFF,0,    0 }, <br>    { 0,   0,   0xFF, 0 }, <br>    { 0xFF,0,   0xFF, 0 }, <br>    { 0,   0xFF,0xFF, 0 }, <br>    { 0xFF,0xFF,0xFF, 0 } <br>}; <br> <br>static UINT <br>MyGetSystemPaletteEntries(HDC hdc, UINT iStartIndex, UINT nEntries, <br>                          LPPALETTEENTRY lppe) <br>{ <br>    int nDeviceBits; <br> <br>    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES); <br> <br>    // <br>    // Some 4bpp displays will fail the GetSystemPaletteEntries call. <br>    // So if detected, return the hardcoded table. <br>    // <br> <br>    if ( nDeviceBits == 4 ) <br>    { <br>        if ( lppe ) <br>        { <br>            nEntries = min(nEntries, (16 - iStartIndex)); <br> <br>            memcpy(lppe, &amp;gapeVgaPalette[iStartIndex], <br>                   nEntries * sizeof(PALETTEENTRY)); <br>        } <br>        else <br>            nEntries = 16; <br> <br>        return nEntries; <br>    } <br>    else <br>    { <br>        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* bComputeLogicalToSurfaceMap <br>* <br>* Copy logical palette to surface palette translation vector to the buffer <br>* pointed to by pajVector.  The logical palette is specified by hpal.  The <br>* surface is specified by hdc. <br>* <br>* Note: The hdc may identify either a direct (display) dc or a DIB memory dc. <br>* If hdc is a display dc, then the surface palette is the system palette. <br>* If hdc is a memory dc, then the surface palette is the DIB color table. <br>\**************************************************************************/ <br> <br>static BOOL bComputeLogicalToSurfaceMap(HDC hdc, HPALETTE hpal, BYTE *pajVector) <br>{ <br>    BOOL bRet = FALSE; <br>    HPALETTE hpalSurf; <br>    ULONG cEntries, cSysEntries; <br>    DWORD dwDcType = GetObjectType(hdc); <br>    LPPALETTEENTRY lppeTmp, lppeEnd; <br> <br>    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)]; <br>    LOGPALETTE *ppal = (LOGPALETTE *) aj; <br>    LPPALETTEENTRY lppeSurf = &amp;ppal-&gt;palPalEntry[0]; <br>    LPPALETTEENTRY lppe = lppeSurf + 256; <br>    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256); <br> <br>    // <br>    // Determine number of colors in each palette. <br>    // <br> <br>    cEntries = GetPaletteEntries(hpal, 0, 1, NULL); <br>    if ( dwDcType == OBJ_DC ) <br>        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, 1, NULL); <br>    else <br>        cSysEntries = 256; <br> <br>    // <br>    // Get the logical palette entries. <br>    // <br> <br>    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe); <br> <br>    // <br>    // Get the surface palette entries. <br>    // <br> <br>    if ( dwDcType == OBJ_DC ) <br>    { <br>        cSysEntries = MyGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf); <br> <br>        lppeTmp = lppeSurf; <br>        lppeEnd = lppeSurf + cSysEntries; <br> <br>        for (; lppeTmp &lt; lppeEnd; lppeTmp++) <br>            lppeTmp-&gt;peFlags = 0; <br>    } <br>    else <br>    { <br>        RGBQUAD *prgbTmp; <br> <br>        // <br>        // First get RGBQUADs from DIB color table... <br>        // <br> <br>        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb); <br> <br>        // <br>        // ...then convert RGBQUADs into PALETTEENTRIES. <br>        // <br> <br>        prgbTmp = prgb; <br>        lppeTmp = lppeSurf; <br>        lppeEnd = lppeSurf + cSysEntries; <br> <br>        while ( lppeTmp &lt; lppeEnd ) <br>        { <br>            lppeTmp-&gt;peRed   = prgbTmp-&gt;rgbRed; <br>            lppeTmp-&gt;peGreen = prgbTmp-&gt;rgbGreen; <br>            lppeTmp-&gt;peBlue  = prgbTmp-&gt;rgbBlue; <br>            lppeTmp-&gt;peFlags = 0; <br> <br>            lppeTmp++; <br>            prgbTmp++; <br> <br>        } <br>    } <br> <br>    // <br>    // Construct a translation vector by using GetNearestPaletteIndex to <br>    // map each entry in the logical palette to the surface palette. <br>    // <br> <br>    if ( cEntries &amp;&amp; cSysEntries ) <br>    { <br>        // <br>        // Create a temporary logical palette that matches the surface <br>        // palette retrieved above. <br>        // <br> <br>        ppal-&gt;palVersion = 0x300; <br>        ppal-&gt;palNumEntries = (USHORT) cSysEntries; <br> <br>        if ( hpalSurf = CreatePalette(ppal) ) <br>        { <br>            // <br>            // Translate each logical palette entry into a surface palette <br>            // index. <br>            // <br> <br>            lppeTmp = lppe; <br>            lppeEnd = lppe + cEntries; <br> <br>            for ( ; lppeTmp &lt; lppeEnd; lppeTmp++, pajVector++) <br>            { <br>                *pajVector = (BYTE) GetNearestPaletteIndex( <br>                                        hpalSurf, <br>                                        RGB(lppeTmp-&gt;peRed, <br>                                            lppeTmp-&gt;peGreen, <br>                                            lppeTmp-&gt;peBlue) <br>                                        ); <br>            } <br> <br>            bRet = TRUE; <br> <br>            DeleteObject(hpalSurf); <br>        } <br>        else <br>        { <br>            SS_DBGPRINT("bComputeLogicalToSurfaceMap: CreatePalette failed\n"); <br>        } <br>    } <br>    else <br>    { <br>        SS_DBGPRINT("bComputeLogicalToSurfaceMap: failed to get pal info\n"); <br>    } <br> <br>    return bRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
