<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MESH.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3686"></a>MESH.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: mesh.c <br>* <br>* Routines to create a mesh representation of a 3D object and to turn it <br>* into an OpenGL description. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br>#include "mesh.h" <br> <br>#define ZERO_EPS    0.00000001 <br> <br>/******************************Public*Routine******************************\ <br>* newMesh <br>* <br>* Allocate memory for the mesh structure to accomodate the specified number <br>* of points and faces. <br>* <br>\**************************************************************************/ <br> <br>void newMesh(MESH *mesh, int numFaces, int numPts) <br>{ <br>    mesh-&gt;numFaces = 0; <br>    mesh-&gt;numPoints = 0; <br> <br>    if (numPts) { <br>        mesh-&gt;pts = SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D)); <br>        mesh-&gt;norms = SaverAlloc((LONG)numPts * (LONG)sizeof(POINT3D)); <br>    } <br>    mesh-&gt;faces = SaverAlloc((LONG)numFaces * (LONG)sizeof(MFACE)); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* delMesh <br>* <br>* Delete the allocated portions of the MESH structure. <br>* <br>\**************************************************************************/ <br> <br>void delMesh(MESH *mesh) <br>{     <br>    SaverFree(mesh-&gt;pts); <br>    SaverFree(mesh-&gt;norms); <br>    SaverFree(mesh-&gt;faces); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* iPtInList <br>* <br>* Add a vertex and its normal to the mesh.  If the vertex already exists, <br>* add in the normal to the existing normal (we to accumulate the average <br>* normal at each vertex).  Normalization of the normals is the <br>* responsibility of the caller. <br>* <br>\**************************************************************************/ <br> <br>static int iPtInList(MESH *mesh, POINT3D *p, POINT3D *norm, int start) <br>{ <br>    int i; <br>    POINT3D *pts = mesh-&gt;pts + start; <br> <br>    for (i = start; i &lt; mesh-&gt;numPoints; i++, pts++) <br>    { <br>    // If the vertices are within ZERO_EPS of each other, then its the same <br>    // vertex. <br> <br>        if ( fabs(pts-&gt;x - p-&gt;x) &lt; ZERO_EPS &amp;&amp; <br>             fabs(pts-&gt;y - p-&gt;y) &lt; ZERO_EPS &amp;&amp; <br>             fabs(pts-&gt;z - p-&gt;z) &lt; ZERO_EPS ) <br>        { <br>            mesh-&gt;norms[i].x += norm-&gt;x; <br>            mesh-&gt;norms[i].y += norm-&gt;y; <br>            mesh-&gt;norms[i].z += norm-&gt;z; <br>            return i; <br>        } <br>    } <br>     <br>    mesh-&gt;pts[i] = *p; <br>    mesh-&gt;norms[i] = *norm; <br>    mesh-&gt;numPoints++; <br>    return i; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* revolveSurface <br>* <br>* Takes the set of points in curve and fills the mesh structure with a <br>* surface of revolution.  The surface consists of quads made up of the <br>* points in curve rotated about the y-axis.  The number of increments <br>* in the revolution is determined by the steps parameter. <br>* <br>\**************************************************************************/ <br> <br>#define MAXPREC 40 <br> <br>void revolveSurface(MESH *mesh, POINT3D *curve, int steps) <br>{ <br>    int i; <br>    int j; <br>    int facecount = 0; <br>    double rotation = 0.0; <br>    double rotInc; <br>    double cosVal; <br>    double sinVal; <br>    int stepsSqr; <br>    POINT3D norm; <br>    POINT3D a[MAXPREC + 1]; <br>    POINT3D b[MAXPREC + 1]; <br>     <br>    if (steps &gt; MAXPREC) <br>        steps = MAXPREC; <br>    rotInc = (2.0 * PI) / (double)(steps - 1); <br>    stepsSqr = steps * steps; <br>    newMesh(mesh, stepsSqr, 4 * stepsSqr); <br> <br>    for (j = 0; j &lt; steps; j++, rotation += rotInc) { <br>        cosVal = cos(rotation); <br>        sinVal = sin(rotation); <br>        for (i = 0; i &lt; steps; i++) { <br>            a[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal); <br>            a[i].y = (float) (curve[i].y); <br>            a[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal); <br>        } <br> <br>        cosVal = cos(rotation + rotInc); <br>        sinVal = sin(rotation + rotInc); <br>        for (i = 0; i &lt; steps; i++) { <br>            b[i].x = (float) (curve[i].x * cosVal + curve[i].z * sinVal); <br>            b[i].y = (float) (curve[i].y); <br>            b[i].z = (float) (curve[i].z * cosVal - curve[i].x * sinVal); <br>        } <br> <br>        for (i = 0; i &lt; (steps - 1); i++) { <br>            ss_calcNorm(&amp;norm, &amp;b[i + 1], &amp;b[i], &amp;a[i]); <br>            if ((norm.x * norm.x) + (norm.y * norm.y) + (norm.z * norm.z) &lt; 0.9) <br>                ss_calcNorm(&amp;norm, &amp;a[i], &amp;a[i+1], &amp;b[i + 1]); <br>            mesh-&gt;faces[facecount].material = j &amp; 7; <br>            mesh-&gt;faces[facecount].norm = norm; <br>            mesh-&gt;faces[facecount].p[0] = iPtInList(mesh, &amp;b[i], &amp;norm, 0); <br>            mesh-&gt;faces[facecount].p[1] = iPtInList(mesh, &amp;a[i], &amp;norm, 0); <br>            mesh-&gt;faces[facecount].p[2] = iPtInList(mesh, &amp;b[i + 1], &amp;norm, 0); <br>            mesh-&gt;faces[facecount].p[3] = iPtInList(mesh, &amp;a[i + 1], &amp;norm, 0);  <br>            mesh-&gt;numFaces++; <br>            facecount++; <br>        } <br>    } <br> <br>    ss_normalizeNorms(mesh-&gt;norms, mesh-&gt;numPoints); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* updateObject <br>* <br>* Takes the mesh structure and converts the data into OpenGL immediate <br>* mode commands. <br>* <br>\**************************************************************************/ <br> <br>void updateObject(MESH *mesh, BOOL bSmooth) <br>{ <br>    int i; <br>    int a, b; <br>    int aOffs, bOffs, cOffs, dOffs; <br>    MFACE *faces; <br>    POINT3D *pp; <br>    POINT3D *pn; <br>    int lastC, lastD; <br> <br>    pp = mesh-&gt;pts; <br>    pn = mesh-&gt;norms; <br> <br>    glBegin(GL_QUAD_STRIP); <br>    for (i = 0, faces = mesh-&gt;faces, lastC = faces-&gt;p[0], lastD = faces-&gt;p[1]; <br>         i &lt; mesh-&gt;numFaces; i++, faces++) { <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br> <br>        if (!bSmooth) { <br>            if ((a != lastC) || (b != lastD)) { <br>                glNormal3fv((GLfloat *)&amp;(faces - 1)-&gt;norm); <br> <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br> <br>            glNormal3fv((GLfloat *)&amp;faces-&gt;norm); <br>            glVertex3fv((GLfloat *)((char *)pp + (a &lt;&lt; 3) + (a &lt;&lt; 2))); <br>            glVertex3fv((GLfloat *)((char *)pp + (b &lt;&lt; 3) + (b &lt;&lt; 2))); <br>        } else { <br>            if ((a != lastC) || (b != lastD)) { <br>                cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>                dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>                glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>                glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br> <br>            aOffs = (a &lt;&lt; 3) + (a &lt;&lt; 2); <br>            bOffs = (b &lt;&lt; 3) + (b &lt;&lt; 2); <br> <br>            glNormal3fv((GLfloat *)((char *)pn + aOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + aOffs)); <br>            glNormal3fv((GLfloat *)((char *)pn + bOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + bOffs)); <br>        } <br> <br>        lastC = faces-&gt;p[2]; <br>        lastD = faces-&gt;p[3]; <br>    } <br> <br>    if (!bSmooth) { <br>        glNormal3fv((GLfloat *)&amp;(faces - 1)-&gt;norm); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>    } else { <br>        cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>        dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>        glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>        glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>    } <br> <br>    glEnd(); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* updateObject <br>* <br>* This is a special case that handles a mesh structure that represents <br>* a strip that is a 1 high loop. <br>* <br>* Takes the mesh structure and converts the data into OpenGL immediate <br>* mode commands. <br>* <br>\**************************************************************************/ <br> <br>void updateObject2(MESH *mesh, BOOL bSmooth) <br>{ <br>    int i; <br>    int a, b; <br>    int aOffs, bOffs, cOffs, dOffs; <br>    MFACE *faces; <br>    POINT3D *pp; <br>    POINT3D *pn; <br>    int lastC, lastD; <br> <br>    pp = mesh-&gt;pts; <br>    pn = mesh-&gt;norms; <br> <br>    glBegin(GL_QUAD_STRIP); <br>    for (i = 0, faces = mesh-&gt;faces, lastC = faces-&gt;p[0], lastD = faces-&gt;p[1]; <br>         i &lt; mesh-&gt;numFaces; i++, faces++) { <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br> <br>        if (!bSmooth) { <br>            glNormal3fv((GLfloat *)&amp;faces-&gt;norm); <br>            glVertex3fv((GLfloat *)((char *)pp + (a &lt;&lt; 3) + (a &lt;&lt; 2))); <br>            glVertex3fv((GLfloat *)((char *)pp + (b &lt;&lt; 3) + (b &lt;&lt; 2))); <br>        } else { <br>            aOffs = (a &lt;&lt; 3) + (a &lt;&lt; 2); <br>            bOffs = (b &lt;&lt; 3) + (b &lt;&lt; 2); <br> <br>            glNormal3fv((GLfloat *)((char *)pn + aOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + aOffs)); <br>            glNormal3fv((GLfloat *)((char *)pn + bOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + bOffs)); <br>        } <br> <br>        lastC = faces-&gt;p[2]; <br>        lastD = faces-&gt;p[3]; <br>    } <br> <br>    if (!bSmooth) { <br>        glNormal3fv((GLfloat *)&amp;(mesh-&gt;faces)-&gt;norm); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>    } else { <br>        cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>        dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>        glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>        glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>    } <br> <br>    glEnd(); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* MakeList <br>* <br>* Takes the mesh structure and converts the data into OpenGL display <br>* list. <br>* <br>\**************************************************************************/ <br> <br>void MakeList(GLuint listID, MESH *mesh) <br>{ <br>    int i; <br>    int a, b; <br>    int aOffs, bOffs, cOffs, dOffs; <br>    MFACE *faces; <br>    BOOL bSmooth; <br>    POINT3D *pp; <br>    POINT3D *pn; <br>    GLint shadeModel; <br>    int lastC, lastD; <br> <br>    glGetIntegerv(GL_SHADE_MODEL, &amp;shadeModel); <br> <br>    bSmooth = (shadeModel == GL_SMOOTH); <br> <br>    glNewList(listID, GL_COMPILE); <br> <br>    pp = mesh-&gt;pts; <br>    pn = mesh-&gt;norms; <br> <br>    glBegin(GL_QUAD_STRIP); <br>    for (i = 0, faces = mesh-&gt;faces, lastC = faces-&gt;p[0], lastD = faces-&gt;p[1]; <br>         i &lt; mesh-&gt;numFaces; i++, faces++) { <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br> <br>        if (!bSmooth) { <br> <br>            if ((a != lastC) || (b != lastD)) { <br>                glNormal3fv((GLfloat *)&amp;((faces - 1)-&gt;norm)); <br> <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br> <br>            glNormal3fv((GLfloat *)&amp;faces-&gt;norm); <br>            glVertex3fv((GLfloat *)((char *)pp + (a &lt;&lt; 3) + (a &lt;&lt; 2))); <br>            glVertex3fv((GLfloat *)((char *)pp + (b &lt;&lt; 3) + (b &lt;&lt; 2))); <br>        } else { <br>            if ((a != lastC) || (b != lastD)) { <br>                cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>                dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>                glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>                glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br> <br>            aOffs = (a &lt;&lt; 3) + (a &lt;&lt; 2); <br>            bOffs = (b &lt;&lt; 3) + (b &lt;&lt; 2); <br> <br>            glNormal3fv((GLfloat *)((char *)pn + aOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + aOffs)); <br>            glNormal3fv((GLfloat *)((char *)pn + bOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + bOffs)); <br>        } <br> <br>        lastC = faces-&gt;p[2]; <br>        lastD = faces-&gt;p[3]; <br>    } <br> <br>    if (!bSmooth) { <br>        glNormal3fv((GLfloat *)&amp;((faces - 1)-&gt;norm)); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>    } else { <br>        cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>        dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>        glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>        glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>    } <br> <br>    glEnd(); <br> <br>    glEndList(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
