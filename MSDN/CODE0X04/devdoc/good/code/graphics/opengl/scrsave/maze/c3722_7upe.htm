<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOG.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3722"></a>DIALOG.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: dialog.cxx <br>* <br>* Dialog box functions <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>\**************************************************************************/ <br> <br>#include "pch.c" <br>#pragma hdrstop <br> <br>#include &lt;commdlg.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include "mazedlg.h" <br> <br>#include "sscommon.hxx" <br> <br>// Global string buffers for message box. <br> <br>// local funtions <br> <br>static void updateDialogControls(HWND hDlg); <br> <br>HWND    ghDlg; // main dialog window handle <br>int     giSize; <br>int     giImageQual; <br>BOOL    gbTurboMode; <br>int     gnBitsPerPixel; <br> <br>static void DrawTexture( int surface ); <br>static void CleanUp( HWND hwnd ); <br> <br>// Texture information for each surface: used in both configure and run mode <br> <br>TEX_INFO gTexInfo[NUM_SURFACES] = {0}; <br> <br>// default surface texture cache <br>static TEXTURE gDefTex[NUM_DEF_SURFACE_TEXTURES] = {0}; <br> <br>// Per-surface texture information relevant only to configure mode <br> <br>typedef struct { <br>    TEXTURE userTex; <br>    int  iDefTex; <br>    int  defTexIDS; <br>    int  fileIDS; <br>    int  offsetIDS; <br>    int  dlgSpinTexID; <br>    int  iPalRot;  // texture palette rotation index <br>    SS_TEX_BUTTON *pTexBtn;  // GL texture drawing button thing <br>} TEX_DLG; <br> <br>static TEX_DLG gTex[NUM_SURFACES] = { <br>    {  <br>      {0}, <br>      BRICK_TEXTURE, <br>      IDS_DEF_WALL_TEXTURE,  <br>      IDS_WALL_TEXTURE_FILE,  <br>      IDS_WALL_TEXTURE_OFFSET, <br>      DLG_SPIN_WALLS, <br>      NULL <br>    }, <br>    {  <br>      {0}, <br>      WOOD_TEXTURE, <br>      IDS_DEF_FLOOR_TEXTURE,  <br>      IDS_FLOOR_TEXTURE_FILE,  <br>      IDS_FLOOR_TEXTURE_OFFSET, <br>      DLG_SPIN_FLOOR, <br>      NULL <br>    }, <br>    {  <br>      {0}, <br>      CASTLE_TEXTURE, <br>      IDS_DEF_CEILING_TEXTURE,  <br>      IDS_CEILING_TEXTURE_FILE,  <br>      IDS_CEILING_TEXTURE_OFFSET, <br>      DLG_SPIN_CEILING, <br>      NULL <br>    } <br>}; <br> <br>static UINT idTimer = 0; <br> <br>static BOOL CALLBACK TextureConfigureDialog(HWND hDlg, UINT message, <br>                            WPARAM wParam, LPARAM lParam); <br> <br>/******************************Public*Routine******************************\ <br>* getIniSettings <br>* <br>* - Get the screen saver configuration options from .INI file/registry. <br>* - Called by both dialog box and screen saver <br>* <br>\**************************************************************************/ <br> <br>void  <br>getIniSettings() <br>{ <br>    int    option; <br>    int    i; <br> <br>    // Load resources <br> <br>    LoadString(hMainInstance, IDS_GENNAME, szScreenSaver,  <br>               sizeof(szScreenSaver) / sizeof(TCHAR)); <br> <br>    // Get registry settings <br> <br>    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) ) <br>    { <br>        // get wall/floor/ceiling texture enables <br>        // For now, texturing always on <br>        for( i = 0; i &lt; NUM_SURFACES; i++ ) <br>            gTexInfo[i].bTex = TRUE; <br> <br>        option = ss_GetRegistryInt( IDS_DEFAULT_TEXTURE_ENABLE, (1 &lt;&lt; NUM_SURFACES)-1 ); <br>        for( i = 0; i &lt; NUM_SURFACES; i++, option &gt;&gt;= 1 ) <br>            gTexInfo[i].bDefTex = option &amp; 1; <br> <br>        // get default texture indices <br> <br>        for( i = 0; i &lt; NUM_SURFACES; i++ ) { <br>            gTexInfo[i].iDefTex =  <br>                    ss_GetRegistryInt( gTex[i].defTexIDS, gTex[i].iDefTex ); <br>            SS_CLAMP_TO_RANGE2( gTexInfo[i].iDefTex, 0,  <br>                                                NUM_DEF_SURFACE_TEXTURES-1 ); <br>        } <br> <br>        // get user texture files <br> <br>        for( i = 0; i &lt; NUM_SURFACES; i++ ) { <br>            ss_GetRegistryString( gTex[i].fileIDS, 0,  <br>                                  gTexInfo[i].texFile.szPathName, MAX_PATH); <br>            gTexInfo[i].texFile.nOffset = ss_GetRegistryInt( gTex[i].offsetIDS, 0 ); <br>        } <br> <br>        // get overlay <br>        maze_options.top_view = ss_GetRegistryInt( IDS_OVERLAY, 0 ); <br> <br>        // Get rat population <br>        maze_options.nrats = ss_GetRegistryInt(IDS_NRATS, 1); <br>         <br>        // get image quality <br> <br>        giImageQual = ss_GetRegistryInt( IDS_IMAGEQUAL, IMAGEQUAL_DEFAULT ); <br>        SS_CLAMP_TO_RANGE2( giImageQual, IMAGEQUAL_DEFAULT, IMAGEQUAL_HIGH ); <br> <br>        // get size <br> <br>        giSize = ss_GetRegistryInt( IDS_SIZE, 0 ); <br>        SS_CLAMP_TO_RANGE2( giSize, MIN_SLIDER, MAX_SLIDER ); <br> <br>        // get turbo mode <br>        gbTurboMode = ss_GetRegistryInt( IDS_TURBOMODE, 1 ); <br>    } <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* saveIniSettings <br>* <br>* Save the screen saver configuration option to the .INI file/registry. <br>\**************************************************************************/ <br> <br>static void  <br>saveIniSettings(HWND hDlg) <br>{ <br>    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) ) <br>    { <br>        int i, option = 0; <br> <br>        // write enables <br> <br>        for( i = NUM_SURFACES-1, option = 0; i &gt;= 0; i--, option &lt;&lt;= 1 ) <br>            option |= gTexInfo[i].bDefTex &amp; 1; <br>        ss_WriteRegistryInt( IDS_DEFAULT_TEXTURE_ENABLE, option &gt;&gt;= 1 ); <br> <br>        // Write default texture indices <br> <br>        for( i = 0; i &lt; NUM_SURFACES; i++ ) { <br>            ss_WriteRegistryInt( gTex[i].defTexIDS, gTexInfo[i].iDefTex ); <br>        } <br> <br>        // write user texture files <br> <br>        for( i = 0; i &lt; NUM_SURFACES; i++ ) { <br>            ss_WriteRegistryString( gTex[i].fileIDS, <br>                                    gTexInfo[i].texFile.szPathName ); <br>            ss_WriteRegistryInt( gTex[i].offsetIDS, gTexInfo[i].texFile.nOffset); <br>        } <br> <br>        // write size <br>        ss_WriteRegistryInt( IDS_SIZE,  <br>                    ss_GetTrackbarPos(hDlg, DLG_SLIDER_SIZE) ); <br> <br>        // write overlay enable <br>        ss_WriteRegistryInt( IDS_OVERLAY, maze_options.top_view ); <br> <br>        // Write rat population <br>        ss_WriteRegistryInt( IDS_NRATS, maze_options.nrats ); <br>         <br>        // write image quality <br>        ss_WriteRegistryInt( IDS_IMAGEQUAL, giImageQual ); <br> <br>        // turbot mod <br>        ss_WriteRegistryInt( IDS_TURBOMODE, gbTurboMode ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* setupDialogControls <br>* <br>* Do initial setup of dialog controls. <br>\**************************************************************************/ <br> <br>static void  <br>setupDialogControls(HWND hDlg) <br>{ <br>    int i; <br>    int idsImageQual; <br>    TCHAR szStr[GEN_STRING_SIZE]; <br> <br>    InitCommonControls(); <br> <br>    // setup size slider <br> <br>    ss_SetupTrackbar( hDlg, DLG_SLIDER_SIZE, MIN_SLIDER, MAX_SLIDER, 1, 9,  <br>                      giSize ); <br> <br>    // setup default texture spins <br> <br>    for( i = 0; i &lt; NUM_SURFACES; i ++ ) { <br>        SendDlgItemMessage( hDlg, gTex[i].dlgSpinTexID, UDM_SETRANGE, 0,  <br>                            MAKELONG(NUM_DEF_SURFACE_TEXTURES-1, 0) ); <br>        SendDlgItemMessage( hDlg, gTex[i].dlgSpinTexID, UDM_SETPOS, 0,  <br>                            MAKELONG(gTexInfo[i].iDefTex, 0) ); <br>    } <br> <br>    // setup image quality combo box <br> <br>    idsImageQual = IDS_IMAGEQUAL_DEFAULT; <br>    for( i = 0; i &lt; IMAGEQUAL_COUNT; i++, idsImageQual++ ) { <br>        LoadString(hMainInstance, idsImageQual, szStr,  <br>                    GEN_STRING_SIZE); <br>        SendDlgItemMessage(hDlg, DLG_COMBO_IMAGEQUAL, CB_ADDSTRING, 0, <br>                           (LPARAM) szStr); <br>    } <br>    SendDlgItemMessage(hDlg, DLG_COMBO_IMAGEQUAL, CB_SETCURSEL,  <br>                       giImageQual, 0); <br> <br>    // Disable Quality box when running on &gt; 16 bits per pixel (since it only <br>    // affects dithering) <br>    gnBitsPerPixel = GetDeviceCaps( GetDC(hDlg), BITSPIXEL ); <br>    EnableWindow( GetDlgItem(hDlg, DLG_COMBO_IMAGEQUAL), gnBitsPerPixel &lt;= 16 ); <br>    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_IMAGEQUAL), gnBitsPerPixel &lt;= 16 ); <br>         <br>    // set palette rotation index for each surface for a8 textures <br>    for( i = 0; i &lt; NUM_SURFACES; i ++ ) <br>        gTex[i].iPalRot = ss_iRand(0xff); <br> <br>    // set state of other controls <br> <br>    CheckDlgButton(hDlg, DLG_CHECK_OVERLAY, maze_options.top_view ); <br> <br>    CheckDlgButton(hDlg, DLG_CHECK_TURBOMODE, gbTurboMode ); <br> <br>    updateDialogControls(hDlg); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* updateDialogControls <br>* <br>* Updates dialog controls according to current state <br>\**************************************************************************/ <br> <br>static void  <br>updateDialogControls(HWND hDlg) <br>{ <br>    int i; <br>    BOOL bDither; <br> <br>    static int dlgSpinTexDef[NUM_SURFACES] = {  <br>        DLG_SPIN_WALLS, <br>        DLG_SPIN_FLOOR, <br>        DLG_SPIN_CEILING}; <br> <br>    for( i = 0; i &lt; NUM_SURFACES; i ++ ) { <br>        EnableWindow( GetDlgItem(hDlg, gTex[i].dlgSpinTexID), gTexInfo[i].bDefTex ); <br>    } <br> <br>    EnableWindow( GetDlgItem(hDlg, DLG_SLIDER_SIZE), !gbTurboMode ); <br>    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_SIZE), !gbTurboMode ); <br>    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_MIN), !gbTurboMode ); <br>    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_MAX), !gbTurboMode ); <br> <br>    // Dithering looks bad with turbo mode on and 8 bits/pixel <br>    bDither = (gnBitsPerPixel &lt;= 16) &amp;&amp; !gbTurboMode; <br>    EnableWindow( GetDlgItem(hDlg, DLG_COMBO_IMAGEQUAL), bDither ); <br>    EnableWindow( GetDlgItem(hDlg, IDC_STATIC_IMAGEQUAL), bDither ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* updateGLState <br>* <br>\**************************************************************************/ <br> <br>static void  <br>updateGLState() <br>{ <br>    if( giImageQual == IMAGEQUAL_DEFAULT ) <br>        glDisable( GL_DITHER ); <br>    else <br>        glEnable( GL_DITHER ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ValidateTexture <br>* <br>* <br>\**************************************************************************/ <br> <br>static TEXTURE * <br>ValidateTexture( int surface )  <br>{ <br>    TEXTURE *pTex = NULL; <br>    TEX_INFO *pTexInfo = &amp;gTexInfo[surface]; <br>    extern TEX_RES gTexResSurf[]; // from glmaze.c <br> <br>    if( !pTexInfo-&gt;bDefTex ) { <br>        // Try to draw user texture <br>        pTex = &amp;gTex[surface].userTex; <br>        if( !pTex-&gt;data ) { <br>            // Load user texture - this can fail! <br>            // If nOffset = 0, we assume user has never specified a texture, <br>            // so we silently switch to the default texture. <br>            // If the load of user texture fails, we use default texture <br>            if( (pTexInfo-&gt;texFile.nOffset == 0) ||  <br>                (! ss_LoadTextureFile( &amp;pTexInfo-&gt;texFile, pTex )) ) { <br> <br>                pTexInfo-&gt;bDefTex = TRUE;  // draw default texture resource <br> <br>                // Enable the spin control <br>                EnableWindow( GetDlgItem(ghDlg, gTex[surface].dlgSpinTexID),  <br>                              TRUE ); <br>            } <br>        } <br>    } <br> <br>    if( pTexInfo-&gt;bDefTex ) { <br>        // Draw default texture resource <br>        pTex = &amp;gDefTex[pTexInfo-&gt;iDefTex]; <br>        if( !pTex-&gt;data ) { <br>            if( !ss_LoadTextureResource( &amp;gTexResSurf[pTexInfo-&gt;iDefTex], pTex )) <br>                pTex = NULL; <br>        } <br>    } <br> <br>    return pTex; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DrawTextures <br>* <br>* Draw all the textures <br>* <br>\**************************************************************************/ <br> <br>static void  <br>DrawTextures()  <br>{ <br>    for( int i = 0; i &lt; NUM_SURFACES; i++ ) { <br>        DrawTexture( i ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DrawTexture <br>* <br>* Draw appropriate texture in supplied window (e.g. a button) <br>* - Use TEX_INFO state to determine texture <br>* - Load texture if not in cache <br>* <br>\**************************************************************************/ <br> <br>static void  <br>DrawTexture( int surface )  <br>{ <br>    TEXTURE *pTex; <br> <br>    // Make sure valid texture loaded for this surface <br>    if( ! (pTex = ValidateTexture( surface )) ) <br>        return; <br> <br>    SS_TEX_BUTTON *pTexBtn = gTex[surface].pTexBtn; <br>    // pTexBtn never NULL, else ss_ConfigInit fails <br> <br>    // If palette rotation for this texture, slam in the current rotation, <br>    // to be used by pTexBtn-&gt;Draw <br>    if( pTex-&gt;pal ) <br>        pTex-&gt;iPalRot = gTex[surface].iPalRot; <br> <br>    pTexBtn-&gt;Draw( pTex ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* RegisterDialogClasses <br>* <br>\**************************************************************************/ <br> <br>BOOL WINAPI RegisterDialogClasses(HANDLE hinst) <br>{ <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* HandlePreviewDraw <br>* <br>\**************************************************************************/ <br> <br>static BOOL <br>HandlePreviewDraw( UINT idCtl, LPDRAWITEMSTRUCT lpdis ) <br>{ <br>    int surface = DLG_PREVIEW_TO_SURFACE( idCtl ); <br> <br>    if( lpdis-&gt;itemAction == ODA_DRAWENTIRE ) { <br>        DrawTexture( surface ); <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* HandleTexButtonNewTexture <br>* <br>* - Handle when a user selects a new texture <br>* <br>* If the new texture fails to load (unlikely, since we validate a good chunk <br>* of it with the selection dialog), then the current default texture is <br>* used. <br>\**************************************************************************/ <br> <br>static void <br>HandleTexButtonNewTexture( int surface ) <br>{ <br>    TEXTURE *pTex = &amp;gTex[surface].userTex; <br> <br>    // Delete the old texture <br>    ss_DeleteTexture( pTex ); <br> <br>    // Load up the new texture <br>    if( ! ss_LoadTextureFile( &amp;gTexInfo[surface].texFile, pTex ) ) <br>        gTexInfo[surface].bDefTex = TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* MazeDlgTimerProc <br>* <br>* Runs off of WM_TIMER message.  Used for any gl animation in the dialog <br>* <br>\**************************************************************************/ <br> <br>static void <br>MazeDlgTimerProc() <br>{ <br>    extern TEX_RES gTexResSurf[]; // from glmaze.c <br> <br>    if( ss_PalettedTextureEnabled() ) { <br>        TEX_INFO *pti = gTexInfo; <br>        int i; <br> <br>        // rotate texture palettes for surfaces with a8 palettes <br> <br>        for( i = 0; i &lt; NUM_SURFACES; i++, pti++ ) { <br>            if( pti-&gt;bTex &amp;&amp; <br>                pti-&gt;bDefTex &amp;&amp; <br>                ( gTexResSurf[pti-&gt;iDefTex].type == TEX_A8 ) ) <br>            { <br>                // Increment palette rotation for this surface <br>                gTex[i].iPalRot++; <br>                // Draw texture associated with the surface <br>                DrawTexture( i ); <br>            } <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ConfigInit <br>* <br>* Do Initialization for Config mode <br>* <br>* This is the config equivalent of ss_Init <br>* <br>* Setup SS_TEX_BUTTON wrappers for each of the 3 texture preview buttons. <br>\**************************************************************************/ <br> <br>BOOL <br>ss_ConfigInit( HWND hDlg ) <br>{ <br>    SS_DBGLEVEL1( SS_LEVEL_INFO, "ConfigInit for %d\n", hDlg ); <br> <br>    // Create GL texture buttons to draw the surface previews <br> <br>    SS_TEX_BUTTON *pTexBtn; <br> <br>    for( int i = 0; i &lt; NUM_SURFACES; i++ ) { <br>        pTexBtn = new SS_TEX_BUTTON( hDlg, <br>                            GetDlgItem(hDlg, DLG_SURFACE_TO_PREVIEW(i)) ); <br>        if( !pTexBtn ) { <br>            return FALSE; <br>        } <br>        gTex[i].pTexBtn = pTexBtn; <br>    } <br> <br>    updateGLState(); <br> <br>    // Start a timer for animating texture palettes <br>    idTimer = 1; <br>    SetTimer(hDlg, idTimer, 16, 0); <br> <br>    // Note: no textures are loaded here, they are 'demand-loaded' <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ScreenSaverConfigureDialog <br>* <br>* Processes messages for the configuration dialog box. <br>* <br>\**************************************************************************/ <br> <br>BOOL ScreenSaverConfigureDialog(HWND hDlg, UINT message, <br>                                WPARAM wParam, LPARAM lParam) <br>{ <br>    int wTmp, surface; <br>    static BOOL bInited = 0; <br> <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            getIniSettings(); <br>            setupDialogControls(hDlg); <br>            // cache the window handle <br>            ghDlg = hDlg; <br>            return TRUE; <br> <br>        case WM_TIMER: <br>            MazeDlgTimerProc(); <br>            return 0; <br>            break; <br> <br>        case WM_DRAWITEM: <br>            switch( (UINT) wParam ) { <br>                case DLG_PREVIEW_WALLS: <br>                case DLG_PREVIEW_FLOOR: <br>                case DLG_PREVIEW_CEILING: <br>                    if( HandlePreviewDraw( (UINT) wParam,  <br>                                             (LPDRAWITEMSTRUCT) lParam ) ) <br>                        return TRUE; <br>                default: <br>                    break; <br>            } <br>            break; <br> <br>        case WM_VSCROLL: <br>            switch(LOWORD(wParam)) <br>            { <br>                case SB_THUMBPOSITION: <br>                    // get new value <br>                    wTmp = HIWORD(wParam); <br>                    { <br>                        int id; <br>                        HWND hwndScroll = (HWND) lParam; <br> <br>                        id = GetDlgCtrlID( hwndScroll ); <br>                        surface = DLG_SPIN_TEX_TO_SURFACE( id ); <br>                        gTexInfo[surface].iDefTex = wTmp; <br>                        DrawTexture( surface ); <br>                    } <br>                    break; <br>                default: <br>                    break; <br>            } <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                     <br>                case DLG_BUTTON_WALLS_TEX: <br>                case DLG_BUTTON_FLOOR_TEX: <br>                case DLG_BUTTON_CEILING_TEX: <br>                    surface = DLG_BUTTON_TEX_TO_SURFACE( LOWORD(wParam) ); <br>                    if( DialogBoxParam(  <br>                        hMainInstance,  <br>                        (LPTSTR) MAKEINTRESOURCE( DLG_TEXTURE_CONFIGURE ), <br>                        hDlg, (DLGPROC) TextureConfigureDialog, surface ) ) { <br>                    // If anything changed here, we have to draw it, as it <br>                    // seems when choose texture dialog box terminates, we <br>                    // don't get any DRAW_ITEM messages. <br>                    // Draw preview area <br>                        DrawTexture( surface ); <br>                    } <br>                    break; <br> <br>                case DLG_CHECK_OVERLAY: <br>                    maze_options.top_view = !maze_options.top_view; <br>                    CheckDlgButton(hDlg, DLG_CHECK_OVERLAY,  <br>                                   maze_options.top_view ); <br>                    break; <br> <br>                case DLG_CHECK_TURBOMODE: <br>                    gbTurboMode = !gbTurboMode; <br>                    CheckDlgButton(hDlg, DLG_CHECK_TURBOMODE, gbTurboMode ); <br>                    break; <br> <br>                case DLG_COMBO_IMAGEQUAL: <br>                    switch (HIWORD(wParam)) <br>                    { <br>                        case CBN_EDITCHANGE: <br>                        case CBN_SELCHANGE: <br>                          { <br>                            int oldImageQual = giImageQual;  <br>                            giImageQual =  <br>                                SendDlgItemMessage(hDlg, DLG_COMBO_IMAGEQUAL, <br>                                                      CB_GETCURSEL, 0, 0); <br>                            if( giImageQual != oldImageQual ) { <br>                                // change has occurred - redraw any gl objects <br>                                updateGLState(); <br>                                DrawTextures(); <br>                            } <br>                          } <br>                          break; <br>                        default: <br>                            return FALSE; <br>                    } <br>                    break; <br> <br>                case IDOK: <br>                    saveIniSettings(hDlg); <br>                    // fall thru... <br> <br>                case IDCANCEL: <br>                    CleanUp( hDlg ); <br>                    EndDialog(hDlg, FALSE); <br>                    break; <br> <br>                default: <br>                    return 0; <br>                    break; <br>            } <br>            updateDialogControls(hDlg); <br>            return TRUE; <br>            break; <br> <br>        default: <br>            return 0; <br>    } <br>    return 0; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* updateTextureConfigControls <br>* <br>* Updates dialog controls according to current state <br>*  <br>\**************************************************************************/ <br> <br>static void  <br>updateTextureConfigControls(HWND hDlg, BOOL bDefTex ) <br>{ <br>    CheckDlgButton(hDlg, IDC_RADIO_TEX_DEFAULT, bDefTex ); <br>    CheckDlgButton(hDlg, IDC_RADIO_TEX_CHOOSE, !bDefTex ); <br> <br>    EnableWindow(GetDlgItem(hDlg, DLG_BUTTON_TEX_CHOOSE ), !bDefTex ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* TextureConfigureDialog <br>* <br>* Processes messages for the texture configure dialog box. <br>* <br>* - Call EndDialog with TRUE if texture changed, otherwise FALSE <br>* <br>\**************************************************************************/ <br> <br>static BOOL CALLBACK  <br>TextureConfigureDialog(HWND hDlg, UINT message, <br>                            WPARAM wParam, LPARAM lParam) <br>{ <br>    // static state ok here, cuz only one of these dialogs can be active <br>    static int surface; <br>    static BOOL bDefTex; // temporary state <br> <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            // Cache some initial values <br>            surface = (int) lParam; <br>            bDefTex = gTexInfo[surface].bDefTex; <br>            updateTextureConfigControls(hDlg, bDefTex ); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                     <br>                case DLG_BUTTON_TEX_CHOOSE: <br>                    if( ss_SelectTextureFile( hDlg,  <br>                                         &amp;gTexInfo[surface].texFile ) ) { <br>                        // New user texture was selected <br>                        HandleTexButtonNewTexture( surface ); <br> <br>                        // For now, let's end the dialog right here if a <br>                        // new one chosen - otherwise we'd have to make the <br>                        // new texture discardable if user entered Cancel <br>                        EndDialog(hDlg, TRUE ); <br>                    } <br>                    break; <br> <br>                case IDC_RADIO_TEX_DEFAULT: <br>                    bDefTex = TRUE; <br>                    break; <br>                     <br>                case IDC_RADIO_TEX_CHOOSE: <br>                    bDefTex = FALSE; <br>                    break; <br>                     <br>                case IDOK: <br>                    // save state <br>                    gTexInfo[surface].bDefTex = bDefTex; <br>                    EndDialog(hDlg, TRUE); <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hDlg, FALSE); <br>                    break; <br> <br>                default: <br>                    return 0; <br>                    break; <br>            } <br>            updateTextureConfigControls(hDlg, bDefTex ); <br>            return TRUE; <br>            break; <br> <br>        default: <br>            return 0; <br>    } <br>    return 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* CleanUp <br>* <br>\**************************************************************************/ <br> <br>static void <br>CleanUp( HWND hwnd ) <br>{ <br>    int i; <br> <br>    if (idTimer) { <br>        KillTimer(hwnd, idTimer); <br>        idTimer = 0; <br>    } <br> <br>    // delete any textures and tex buttons created <br> <br>    for( i = 0; i &lt; NUM_SURFACES; i ++ ) { <br>        if( gTex[i].userTex.data ) <br>            ss_DeleteTexture( &amp;gTex[i].userTex ); <br>        if( gDefTex[i].data ) <br>            ss_DeleteTexture( &amp;gDefTex[i] ); <br>        if( gTex[i].pTexBtn ) <br>            delete gTex[i].pTexBtn; <br>    } <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
