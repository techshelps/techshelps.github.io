<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PALETTE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3701"></a>PALETTE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: palette.cxx <br>* <br>* Palette processing functions <br>* <br>* Copyright 1996 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include "ssintrnl.hxx" <br>#include "palette.hxx" <br> <br>#if(WINVER &lt; 0x0400) <br>// Ordinarily not defined for versions before 4.00. <br>#define COLOR_3DDKSHADOW        21 <br>#define COLOR_3DLIGHT           22 <br>#define COLOR_INFOTEXT          23 <br>#define COLOR_INFOBK            24 <br>#endif <br> <br>#define TKASSERT(x) SS_ASSERT( x, "palette processing failure\n" ) <br> <br>/******************************************************************************/ <br> <br>// Fixed palette support. <br> <br>#define BLACK   PALETTERGB(0,0,0) <br>#define WHITE   PALETTERGB(255,255,255) <br>#define MAX_STATIC_COLORS   (COLOR_INFOBK - COLOR_SCROLLBAR + 1) <br>static int gNumStaticColors = MAX_STATIC_COLORS; <br> <br>// TRUE if static system color settings have been replaced with B&amp;W settings. <br> <br>// TRUE if original static colors saved <br>static BOOL tkStaticColorsSaved = FALSE; <br> <br>// saved system static colors (initialize with default colors) <br>static COLORREF gacrSave[MAX_STATIC_COLORS]; <br> <br>// new B&amp;W system static colors <br>static COLORREF gacrBlackAndWhite[] = { <br>    WHITE,  // COLOR_SCROLLBAR <br>    BLACK,  // COLOR_BACKGROUND <br>    BLACK,  // COLOR_ACTIVECAPTION <br>    WHITE,  // COLOR_INACTIVECAPTION <br>    WHITE,  // COLOR_MENU <br>    WHITE,  // COLOR_WINDOW <br>    BLACK,  // COLOR_WINDOWFRAME <br>    BLACK,  // COLOR_MENUTEXT <br>    BLACK,  // COLOR_WINDOWTEXT <br>    WHITE,  // COLOR_CAPTIONTEXT <br>    WHITE,  // COLOR_ACTIVEBORDER <br>    WHITE,  // COLOR_INACTIVEBORDER <br>    WHITE,  // COLOR_APPWORKSPACE <br>    BLACK,  // COLOR_HIGHLIGHT <br>    WHITE,  // COLOR_HIGHLIGHTTEXT <br>    WHITE,  // COLOR_BTNFACE <br>    BLACK,  // COLOR_BTNSHADOW <br>    BLACK,  // COLOR_GRAYTEXT <br>    BLACK,  // COLOR_BTNTEXT <br>    BLACK,  // COLOR_INACTIVECAPTIONTEXT <br>    BLACK,  // COLOR_BTNHIGHLIGHT <br>    BLACK,  // COLOR_3DDKSHADOW <br>    WHITE,  // COLOR_3DLIGHT <br>    BLACK,  // COLOR_INFOTEXT <br>    WHITE   // COLOR_INFOBK <br>    }; <br>static INT gaiStaticIndex[] = { <br>    COLOR_SCROLLBAR          , <br>    COLOR_BACKGROUND         , <br>    COLOR_ACTIVECAPTION      , <br>    COLOR_INACTIVECAPTION    , <br>    COLOR_MENU               , <br>    COLOR_WINDOW             , <br>    COLOR_WINDOWFRAME        , <br>    COLOR_MENUTEXT           , <br>    COLOR_WINDOWTEXT         , <br>    COLOR_CAPTIONTEXT        , <br>    COLOR_ACTIVEBORDER       , <br>    COLOR_INACTIVEBORDER     , <br>    COLOR_APPWORKSPACE       , <br>    COLOR_HIGHLIGHT          , <br>    COLOR_HIGHLIGHTTEXT      , <br>    COLOR_BTNFACE            , <br>    COLOR_BTNSHADOW          , <br>    COLOR_GRAYTEXT           , <br>    COLOR_BTNTEXT            , <br>    COLOR_INACTIVECAPTIONTEXT, <br>    COLOR_BTNHIGHLIGHT       , <br>    COLOR_3DDKSHADOW         , <br>    COLOR_3DLIGHT            , <br>    COLOR_INFOTEXT           , <br>    COLOR_INFOBK <br>    }; <br> <br>#define RESTORE_FROM_REGISTRY   1 <br>#if RESTORE_FROM_REGISTRY <br>// Registry names for the system colors. <br>static CHAR *gaszSysClrNames[] = { <br>    "Scrollbar",      // COLOR_SCROLLBAR              0 <br>    "Background",     // COLOR_BACKGROUND             1   (also COLOR_DESKTOP) <br>    "ActiveTitle",    // COLOR_ACTIVECAPTION          2 <br>    "InactiveTitle",  // COLOR_INACTIVECAPTION        3 <br>    "Menu",           // COLOR_MENU                   4 <br>    "Window",         // COLOR_WINDOW                 5 <br>    "WindowFrame",    // COLOR_WINDOWFRAME            6 <br>    "MenuText",       // COLOR_MENUTEXT               7 <br>    "WindowText",     // COLOR_WINDOWTEXT             8 <br>    "TitleText",      // COLOR_CAPTIONTEXT            9 <br>    "ActiveBorder",   // COLOR_ACTIVEBORDER          10 <br>    "InactiveBorder", // COLOR_INACTIVEBORDER        11 <br>    "AppWorkspace",   // COLOR_APPWORKSPACE          12 <br>    "Hilight",        // COLOR_HIGHLIGHT             13 <br>    "HilightText",    // COLOR_HIGHLIGHTTEXT         14 <br>    "ButtonFace",     // COLOR_BTNFACE               15   (also COLOR_3DFACE) <br>    "ButtonShadow",   // COLOR_BTNSHADOW             16   (also COLOR_3DSHADOW) <br>    "GrayText",       // COLOR_GRAYTEXT              17 <br>    "ButtonText",     // COLOR_BTNTEXT               18 <br>    "InactiveTitleText", // COLOR_INACTIVECAPTIONTEXT   19 <br>    "ButtonHilight",  // COLOR_BTNHIGHLIGHT          20   (also COLOR_3DHILIGHT) <br>    "ButtonDkShadow", // COLOR_3DDKSHADOW            21 <br>    "ButtonLight",    // COLOR_3DLIGHT               22 <br>    "InfoText",       // COLOR_INFOTEXT              23 <br>    "InfoWindow"      // COLOR_INFOBK                24 <br>}; <br> <br>static BOOL GetRegistrySysColors(COLORREF *, int); <br>#endif <br> <br>unsigned char ss_ComponentFromIndex(int i, int nbits, int shift ); <br>static int ss_PixelFormatDescriptorFromDc( HDC hdc, PIXELFORMATDESCRIPTOR *Pfd ); <br> <br>/******************************************************************************/ <br> <br>#if RESTORE_FROM_REGISTRY <br>/******************************Public*Routine******************************\ <br>* GetRegistrySysColors <br>* <br>* Reads the Control Panel's color settings from the registry and stores <br>* those values in pcr.  If we fail to get any value, then the corresponding <br>* entry in pcr is not modified. <br>\**************************************************************************/ <br> <br>static BOOL GetRegistrySysColors(COLORREF *pcr, int nColors) <br>{ <br>    BOOL bRet = FALSE; <br>    long lRet; <br>    HKEY hkSysColors = (HKEY) NULL; <br>    int i; <br>    DWORD dwDataType; <br>    char achColor[64]; <br>    DWORD cjColor; <br> <br>    TKASSERT(nColors &lt;= gNumStaticColors); <br> <br>// Open the key for the system color settings. <br> <br>    lRet = RegOpenKeyExA(HKEY_CURRENT_USER, <br>                         "Control Panel\\Colors", <br>                         0, <br>                         KEY_QUERY_VALUE, <br>                         &amp;hkSysColors); <br> <br>    if ( lRet != ERROR_SUCCESS ) <br>    { <br>        goto GetRegistrySysColors_exit; <br>    } <br> <br>// Read each system color value.  The names are stored in the global <br>// array of char *, gaszSysClrNames. <br> <br>    for (i = 0; i &lt; nColors; i++) <br>    { <br>        cjColor = sizeof(achColor); <br>        lRet = RegQueryValueExA(hkSysColors, <br>                                (LPSTR) gaszSysClrNames[i], <br>                                (LPDWORD) NULL, <br>                                &amp;dwDataType, <br>                                (LPBYTE) achColor, <br>                                &amp;cjColor); <br> <br>        TKASSERT(lRet != ERROR_MORE_DATA); <br> <br>        if ( lRet == ERROR_SUCCESS &amp;&amp; dwDataType == REG_SZ ) <br>        { <br>            DWORD r, g, b; <br> <br>            sscanf(achColor, "%ld %ld %ld", &amp;r, &amp;g, &amp;b); <br>            pcr[i] = RGB(r, g, b); <br>        } <br>    } <br> <br>    bRet = TRUE; <br> <br>GetRegistrySysColors_exit: <br>    if (hkSysColors) <br>        RegCloseKey(hkSysColors); <br> <br>    return bRet; <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* GrabStaticEntries <br>* <br>* Support routine for Realize to manage the static system color <br>* usage. <br>* <br>* This function will save the current static system color usage state. <br>* It will fail if: <br>* <br>*   1.  TK is not in "sys color in use state but system palette is in <br>*       SYSPAL_NOSTATIC mode.  This means that another app still possesses <br>*       the static system colors.  If this happens &lt;TBD&gt; <br>* <br>* Side effect: <br>*   If system colors are changed, then WM_SYSCOLORCHANGE message is <br>*   broadcast to all top level windows. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise (see above). <br>\**************************************************************************/ <br> <br>BOOL  <br>SS_PAL::GrabStaticEntries() <br>{ <br>    int i; <br>    BOOL bRet = FALSE; <br> <br>    // Do nothing if sys colors already in use. <br> <br>    if ( !bSystemColorsInUse ) <br>    { <br>    // Take possession only if no other app has the static colors. <br>    // How can we tell?  If the return from SetSystemPaletteUse is <br>    // SYSPAL_STATIC, then no other app has the statics.  If it is <br>    // SYSPAL_NOSTATIC, someone else has them and we must fail. <br>    // <br>    // SetSystemPaletteUse is properly synchronized internally <br>    // so that it is atomic. <br>    // <br>    // Because we are relying on SetSystemPaletteUse to synchronize TK, <br>    // it is important to observe the following order for grabbing and <br>    // releasing: <br>    // <br>    //      Grab        call SetSystemPaletteUse and check for SYSPAL_STATIC <br>    //                  save sys color settings <br>    //                  set new sys color settings <br>    // <br>    //      Release     restore sys color settings <br>    //                  call SetSystemPaletteUse <br> <br>// potential pitfall here, if a 'bad' app has not released the static <br>// colors on deactivation. <br>        if ( SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC ) == SYSPAL_STATIC ) <br>        { <br>        // Save current sys color settings. <br> <br>            for (i = COLOR_SCROLLBAR; i &lt;= COLOR_BTNHIGHLIGHT; i++) <br>                gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i); <br> <br>            bSystemColorsInUse = TRUE; <br> <br>            // Set b&amp;w sys color settings. <br> <br>            SetSysColors(gNumStaticColors, gaiStaticIndex, gacrBlackAndWhite); <br> <br>            // Inform all other top-level windows of the system color change. <br> <br>            PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br> <br>            bRet = TRUE; <br>        } else { <br>            // handle case where can't get sys colors <br>        } <br>    } <br>    else <br>        bRet = TRUE; <br> <br>    return bRet; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ReleaseStaticEntries <br>* <br>* Support routine for Realize to manage the static system color <br>* usage. <br>* <br>* This function will reset the current static system color usage state. <br>* It will fail if: <br>* <br>*   1.  TK is not in a "sys colors in use" state.  If we are in this case, <br>*       then the static system colors do not need to be released. <br>* <br>* Side effect: <br>*   If system colors are changed, then WM_SYSCOLORCHANGE message is <br>*   broadcast to all top level windows. <br>* <br>* Returns: <br>*   TRUE if successful, FALSE otherwise (see above). <br>\**************************************************************************/ <br> <br>BOOL  <br>SS_PAL::ReleaseStaticEntries() <br>{ <br>    BOOL bRet = FALSE; <br> <br>    // Do nothing if sys colors not in use. <br> <br>    if ( bSystemColorsInUse ) <br>    { <br>#if RESTORE_FROM_REGISTRY <br>    // Replace saved system colors with registry values.  We do it now <br>    // rather than earlier because someone may have changed registry while <br>    // TK app was running in the foreground (very unlikely, but it could <br>    // happen). <br>    // <br>    // Also, we still try to save current setting in GrabStaticEntries so <br>    // that if for some reason we fail to grab one or more of the colors <br>    // from the registry, we can still fall back on what we grabbed via <br>    // GetSysColors (even though there is a chance its the wrong color). <br> <br>        GetRegistrySysColors(gacrSave, gNumStaticColors); <br>#endif <br> <br>        // Do this now, since SetSysColors() generates WM_SYSCOLORCHANGE, <br>        // which can cause this routine to be re-entered <br>        // back to here. <br>        bSystemColorsInUse = FALSE; <br> <br>        // Return the system palette to SYSPAL_STATIC. <br> <br>        SetSystemPaletteUse( hdc, SYSPAL_STATIC ); <br> <br>        // Restore the saved system color settings. <br> <br>        SetSysColors(gNumStaticColors, gaiStaticIndex, gacrSave); <br> <br>        // Inform all other top-level windows of the system color change. <br> <br>        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br> <br>        // Reset the "sys colors in use" state and return success. <br> <br>        bSystemColorsInUse = FALSE; <br>        bRet = TRUE; <br>    } <br> <br>    return bRet; <br>} <br> <br>// Gamma correction factor * 10 <br>#define GAMMA_CORRECTION 14 <br> <br>// Maximum color distance with 8-bit components <br>#define MAX_COL_DIST (3*256*256L) <br> <br>// Number of static colors <br>#define STATIC_COLORS 20 <br> <br>// Flags used when matching colors <br>#define EXACT_MATCH 1 <br>#define COLOR_USED 1 <br> <br>// Conversion tables for n bits to eight bits <br> <br>#if GAMMA_CORRECTION == 10 <br>// These tables are corrected for a gamma of 1.0 <br>static unsigned char abThreeToEight[8] = <br>{ <br>    0, 0111 &gt;&gt; 1, 0222 &gt;&gt; 1, 0333 &gt;&gt; 1, 0444 &gt;&gt; 1, 0555 &gt;&gt; 1, 0666 &gt;&gt; 1, 0377 <br>}; <br>static unsigned char abTwoToEight[4] = <br>{ <br>    0, 0x55, 0xaa, 0xff <br>}; <br>static unsigned char abOneToEight[2] = <br>{ <br>    0, 255 <br>}; <br>#else <br>// These tables are corrected for a gamma of 1.4 <br>static unsigned char abThreeToEight[8] = <br>{ <br>    0, 63, 104, 139, 171, 200, 229, 255 <br>}; <br>static unsigned char abTwoToEight[4] = <br>{ <br>    0, 116, 191, 255 <br>}; <br>static unsigned char abOneToEight[2] = <br>{ <br>    0, 255 <br>}; <br>#endif <br> <br>// Table which indicates which colors in a 3-3-2 palette should be <br>// replaced with the system default colors <br>#if GAMMA_CORRECTION == 10 <br>static int aiDefaultOverride[STATIC_COLORS] = <br>{ <br>    0, 4, 32, 36, 128, 132, 160, 173, 181, 245, <br>    247, 164, 156, 7, 56, 63, 192, 199, 248, 255 <br>}; <br>#else <br>static int aiDefaultOverride[STATIC_COLORS] = <br>{ <br>    0, 3, 24, 27, 64, 67, 88, 173, 181, 236, <br>    247, 164, 91, 7, 56, 63, 192, 199, 248, 255 <br>}; <br>#endif <br> <br>unsigned char <br>ss_ComponentFromIndex(int i, int nbits, int shift) <br>{ <br>    unsigned char val; <br> <br>    TKASSERT(nbits &gt;= 1 &amp;&amp; nbits &lt;= 3); <br>     <br>    val = i &gt;&gt; shift; <br>    switch (nbits) <br>    { <br>    case 1: <br>        return abOneToEight[val &amp; 1]; <br> <br>    case 2: <br>        return abTwoToEight[val &amp; 3]; <br> <br>    case 3: <br>        return abThreeToEight[val &amp; 7]; <br>    } <br>    return 0; <br>} <br> <br>// System default colors <br>static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] = <br>{ <br>    { 0,   0,   0,    0 }, <br>    { 0x80,0,   0,    0 }, <br>    { 0,   0x80,0,    0 }, <br>    { 0x80,0x80,0,    0 }, <br>    { 0,   0,   0x80, 0 }, <br>    { 0x80,0,   0x80, 0 }, <br>    { 0,   0x80,0x80, 0 }, <br>    { 0xC0,0xC0,0xC0, 0 }, <br> <br>    { 192, 220, 192,  0 }, <br>    { 166, 202, 240,  0 }, <br>    { 255, 251, 240,  0 }, <br>    { 160, 160, 164,  0 }, <br> <br>    { 0x80,0x80,0x80, 0 }, <br>    { 0xFF,0,   0,    0 }, <br>    { 0,   0xFF,0,    0 }, <br>    { 0xFF,0xFF,0,    0 }, <br>    { 0,   0,   0xFF, 0 }, <br>    { 0xFF,0,   0xFF, 0 }, <br>    { 0,   0xFF,0xFF, 0 }, <br>    { 0xFF,0xFF,0xFF, 0 } <br>}; <br> <br>/******************************Public*Routine******************************\ <br>* <br>* UpdateStaticMapping <br>* <br>* Computes the best match between the current system static colors <br>* and a 3-3-2 palette <br>* <br>* History: <br>*  Tue Aug 01 18:18:12 1995-by-Drew Bliss [drewb] <br>*   Created <br>* <br>\**************************************************************************/ <br> <br>static void <br>UpdateStaticMapping(PALETTEENTRY *pe332Palette) <br>{ <br>    HPALETTE hpalStock; <br>    int iStatic, i332; <br>    int iMinDist, iDist; <br>    int iDelta; <br>    int iMinEntry; <br>    PALETTEENTRY *peStatic, *pe332; <br> <br>    hpalStock = (HPALETTE) GetStockObject(DEFAULT_PALETTE); <br> <br>    // The system should always have one of these <br>    TKASSERT(hpalStock != NULL); <br>    // Make sure there's the correct number of entries <br>    TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS); <br> <br>    // Get the current static colors <br>    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry); <br> <br>    // Zero the flags in the static colors because they are used later <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        peStatic-&gt;peFlags = 0; <br>        peStatic++; <br>    } <br> <br>    // Zero the flags in the incoming palette because they are used later <br>    pe332 = pe332Palette; <br>    for (i332 = 0; i332 &lt; 256; i332++) <br>    { <br>        pe332-&gt;peFlags = 0; <br>        pe332++; <br>    } <br> <br>    // Try to match each static color exactly <br>    // This saves time by avoiding the least-squares match for each <br>    // exact match <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        pe332 = pe332Palette; <br>        for (i332 = 0; i332 &lt; 256; i332++) <br>        { <br>            if (peStatic-&gt;peRed == pe332-&gt;peRed &amp;&amp; <br>                peStatic-&gt;peGreen == pe332-&gt;peGreen &amp;&amp; <br>                peStatic-&gt;peBlue == pe332-&gt;peBlue) <br>            { <br>                TKASSERT(pe332-&gt;peFlags != COLOR_USED); <br>                 <br>                peStatic-&gt;peFlags = EXACT_MATCH; <br>                pe332-&gt;peFlags = COLOR_USED; <br>                aiDefaultOverride[iStatic] = i332; <br>                 <br>                break; <br>            } <br> <br>            pe332++; <br>        } <br> <br>        peStatic++; <br>    } <br>     <br>    // Match each static color as closely as possible to an entry <br>    // in the 332 palette by minimized the square of the distance <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        // Skip colors already matched exactly <br>        if (peStatic-&gt;peFlags == EXACT_MATCH) <br>        { <br>            peStatic++; <br>            continue; <br>        } <br>         <br>        iMinDist = MAX_COL_DIST+1; <br>#if DBG <br>        iMinEntry = -1; <br>#endif <br> <br>        pe332 = pe332Palette; <br>        for (i332 = 0; i332 &lt; 256; i332++) <br>        { <br>            // Skip colors already used <br>            if (pe332-&gt;peFlags == COLOR_USED) <br>            { <br>                pe332++; <br>                continue; <br>            } <br>             <br>            // Compute Euclidean distance squared <br>            iDelta = pe332-&gt;peRed-peStatic-&gt;peRed; <br>            iDist = iDelta*iDelta; <br>            iDelta = pe332-&gt;peGreen-peStatic-&gt;peGreen; <br>            iDist += iDelta*iDelta; <br>            iDelta = pe332-&gt;peBlue-peStatic-&gt;peBlue; <br>            iDist += iDelta*iDelta; <br> <br>            if (iDist &lt; iMinDist) <br>            { <br>                iMinDist = iDist; <br>                iMinEntry = i332; <br>            } <br> <br>            pe332++; <br>        } <br> <br>        TKASSERT(iMinEntry != -1); <br> <br>        // Remember the best match <br>        aiDefaultOverride[iStatic] = iMinEntry; <br>        pe332Palette[iMinEntry].peFlags = COLOR_USED; <br>         <br>        peStatic++; <br>    } <br> <br>    // Zero the flags in the static colors because they may have been <br>    // set.  We want them to be zero so the colors can be remapped <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        peStatic-&gt;peFlags = 0; <br>        peStatic++; <br>    } <br> <br>    // Reset the 332 flags because we may have set them <br>    pe332 = pe332Palette; <br>    for (i332 = 0; i332 &lt; 256; i332++) <br>    { <br>        pe332-&gt;peFlags = PC_NOCOLLAPSE; <br>        pe332++; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* FlushPalette <br>* <br>* Because of Win 3.1 compatibility, GDI palette mapping always starts <br>* at zero and stops at the first exact match.  So if there are duplicates, <br>* the higher colors aren't mapped to--which is often a problem if we <br>* are trying to make to any of the upper 10 static colors.  To work around <br>* this, we flush the palette to all black. <br>* <br>\**************************************************************************/ <br> <br>void <br>SS_PAL::Flush() <br>{ <br>    LOGPALETTE *pPal; <br>    HPALETTE hpalBlack, hpalOld; <br>    int i; <br> <br>    if( nEntries == 256 ) <br>    { <br>        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, <br>                         sizeof(LOGPALETTE) + nEntries * sizeof(PALETTEENTRY)); <br> <br>        if (pPal) <br>        { <br>        pPal-&gt;palVersion = 0x300; <br>        pPal-&gt;palNumEntries = nEntries; <br> <br>            // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every  <br>            // thing into the palette.  Colors are already black because  <br>            // we zero initialized during memory allocation. <br> <br>            for (i = 0; i &lt; nEntries; i++) <br>            { <br>                pPal-&gt;palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED; <br>            } <br> <br>            hpalBlack = CreatePalette(pPal); <br>            LocalFree(pPal); <br> <br>            hpalOld = SelectPalette(hdc, hpalBlack, FALSE); <br>            RealizePalette(hdc); <br> <br>            SelectPalette(hdc, hpalOld, FALSE); <br>            DeleteObject(hpalBlack); <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* Realize <br>* <br>* Select the given palette in background or foreground mode (as specified <br>* by the bForceBackground flag), and realize the palette. <br>* <br>* If static system color usage is set, the system colors are replaced. <br>\**************************************************************************/ <br> <br>long <br>SS_PAL::Realize( HWND hwndArg, HDC hdcArg, BOOL bForceBackground ) <br>{ <br>    // cache: <br>    hwnd = hwndArg; <br>    hdc = hdcArg; <br> <br>    if( bTakeOver ) { <br>        // Easy case <br>        SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC); <br>        SelectPalette(hdc, hPal, bForceBackground ); <br>        RealizePalette(hdc); <br>        return 1; <br>    } <br> <br> <br>    if( bFlush ) { <br>        Flush(); <br>        bFlush = FALSE; <br>    } <br> <br>    return Realize( bForceBackground ); <br>} <br> <br>long <br>SS_PAL::Realize( BOOL bForceBackground ) <br>{ <br>    long Result = -1; <br>    BOOL bHaveSysPal = TRUE; <br> <br>    SS_DBGLEVEL2( SS_LEVEL_INFO, "SS_PAL::Realize: %d for %d\n", bForceBackground, hwnd ); <br> <br>    // If static system color usage is set, prepare to take over the <br>    // system palette. <br> <br>    if( bUseStatic ) <br>    { <br>        // If foreground, take over the static colors.  If background, release <br>        // the static colors. <br> <br>        if ( !bForceBackground ) <br>        { <br>            // If GrabStaticEntries succeeds, then it is OK to take over the <br>            // static colors.  If not &lt;mf:TBD&gt; <br> <br>            bHaveSysPal = GrabStaticEntries(); <br>        } <br>        else <br>        { <br>            // If we are currently using the system colors (bSystemColorsInUse) <br>            // and Realize was called with bForceBackground set, we <br>            // are being deactivated and must release the static system colors. <br> <br>            ReleaseStaticEntries(); <br>        } <br> <br>        // Rerealize the palette. <br>        // <br>        // If set to TRUE, bForceBackground will force the palette to be  <br>        // realized as a background palette, regardless of focus.  This  <br>        // will happen anyway if the TK window does not have the keyboard focus. <br> <br>        if ( (bForceBackground || bHaveSysPal) &amp;&amp; <br>             UnrealizeObject( hPal ) &amp;&amp; <br>             NULL != SelectPalette( hdc, hPal, bForceBackground ) ) <br>        { <br>            Result = RealizePalette( hdc ); <br>        } <br> <br>        // If some rude app still has the system colors and we're in the <br>        // foreground, make the best of it. <br>        if( !bForceBackground &amp;&amp; !bHaveSysPal ) { <br>            if( UnrealizeObject( hPal ) &amp;&amp; <br>                NULL != SelectPalette( hdc, hPal, TRUE ) ) <br>            { <br>                Result = RealizePalette( hdc ); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        if ( NULL != SelectPalette( hdc, hPal, FALSE ) ) <br>        { <br>            Result = RealizePalette( hdc ); <br>        } <br>    } <br> <br>    return( Result ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SS_PAL constructor <br>* <br>* This creates the palette, but does not select or realize it <br>* <br>\**************************************************************************/ <br> <br>SS_PAL::SS_PAL( HDC hdcArg, PIXELFORMATDESCRIPTOR *ppfd, BOOL bTakeOverPalette ) <br>{ <br>    hwnd = 0; <br>    hPal = 0; <br>    bUseStatic = FALSE; <br>    bSystemColorsInUse = FALSE; <br>    pfd = *ppfd;  // this is for palette purposes only (other fields may not apply) <br>    hdc = hdcArg; <br>    bTakeOver = bTakeOverPalette;  // mf: for now, when this is set, it means <br>        // the screen saver is running in full screen mode - implying that <br>        // interaction with other apps not necessary <br> <br>    if( bTakeOver ) { <br>        bFlush = FALSE; <br>        bUseStatic = TRUE; <br>    } else { <br>        bFlush = TRUE; <br>        bUseStatic = ppfd-&gt;dwFlags &amp; PFD_NEED_SYSTEM_PALETTE; <br>    } <br> <br>    if( bUseStatic ) <br>        // save current static palette usage so we can restore it <br>        uiOldStaticUse = GetSystemPaletteUse( hdc ); <br> <br>    paletteManageProc = NullPaletteManageProc; <br> <br>    // Now create the palette and return <br>    hPal = MakeRGBPalette(); <br>    SS_ASSERT( hPal, "SS_PAL constructor failure\n" ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SS_PAL destructor <br> <br>\**************************************************************************/ <br> <br>SS_PAL::~SS_PAL() <br>{ <br>    if( bUseStatic ) <br>    { <br>        if( uiOldStaticUse ) <br>            SetSystemPaletteUse(hdc, uiOldStaticUse); <br> <br>        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br>    } <br>    if( hPal ) { <br>        SelectPalette( hdc, (HPALETTE) GetStockObject(DEFAULT_PALETTE), TRUE ); <br>        DeleteObject( hPal ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ReCreateRGBPalette <br>*  <br>* <br>\**************************************************************************/ <br> <br>void <br>SS_PAL::ReCreateRGBPalette() <br>{ <br>    if( bTakeOver ) <br>        return; <br> <br>    HPALETTE hPalTmp = hPal; <br>    hPal = MakeRGBPalette(); <br>    if( hPal ) { <br>        DeleteObject( hPalTmp ); <br>        bFlush = TRUE; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* MakeRGBPalette <br>* <br>* Creates an HPALETTE with values required for a logical rgb palette. <br>* If bUseStatic is TRUE, the static system <br>* colors will be overridden.  Otherwise, the PALETTEENTRY array will be <br>* fixed up to contain the default static system colors. <br>* <br>\**************************************************************************/ <br> <br>HPALETTE <br>SS_PAL::MakeRGBPalette() <br>{ <br>    LOGPALETTE *pPal; <br>    HPALETTE hpal; <br>    int count, i; <br>    PIXELFORMATDESCRIPTOR *ppfd = &amp;pfd; <br> <br>    count = 1 &lt;&lt; ppfd-&gt;cColorBits; <br>    nEntries = count; <br>    pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>            count * sizeof(PALETTEENTRY)); <br>    if( !pPal ) <br>        return (HPALETTE) 0; <br> <br>    pPal-&gt;palVersion = 0x300; <br>    pPal-&gt;palNumEntries = count; <br> <br>    PALETTEENTRY *pEntry = pPal-&gt;palPalEntry; <br> <br>    for ( i = 0; i &lt; count ; i++, pEntry++ ) <br>    { <br>        pEntry-&gt;peRed   = ss_ComponentFromIndex(i, ppfd-&gt;cRedBits, <br>                                ppfd-&gt;cRedShift); <br>        pEntry-&gt;peGreen = ss_ComponentFromIndex(i, ppfd-&gt;cGreenBits, <br>                                ppfd-&gt;cGreenShift); <br>        pEntry-&gt;peBlue  = ss_ComponentFromIndex(i, ppfd-&gt;cBlueBits, <br>                                ppfd-&gt;cBlueShift); <br>        pEntry-&gt;peFlags = PC_NOCOLLAPSE; <br>    } <br> <br>    if( count == 256 ) <br>    { <br>    // If app set static system color usage for fixed palette support, <br>    // setup to take over the static colors.  Otherwise, fixup the <br>    // static system colors. <br> <br>        if ( bUseStatic ) <br>        { <br>        // Black and white already exist as the only remaining static <br>        // colors.  Let those remap.  All others should be put into <br>        // the palette (i.e., set PC_NOCOLLAPSE). <br> <br>            pPal-&gt;palPalEntry[0].peFlags = 0; <br>            pPal-&gt;palPalEntry[255].peFlags = 0; <br>        } <br>        else <br>        { <br>        // The defaultOverride array is computed assuming a 332 <br>        // palette where red has zero shift, etc. <br> <br>            if ( (3 == ppfd-&gt;cRedBits)   &amp;&amp; (0 == ppfd-&gt;cRedShift)   &amp;&amp; <br>                 (3 == ppfd-&gt;cGreenBits) &amp;&amp; (3 == ppfd-&gt;cGreenShift) &amp;&amp; <br>                 (2 == ppfd-&gt;cBlueBits)  &amp;&amp; (6 == ppfd-&gt;cBlueShift) ) <br>            { <br>                pEntry = pPal-&gt;palPalEntry; <br>                UpdateStaticMapping( pEntry ); <br>                 <br>                for ( i = 0 ; i &lt; STATIC_COLORS ; i++) <br>                { <br>                    pEntry[aiDefaultOverride[i]] = apeDefaultPalEntry[i]; <br>                } <br>            } <br>        } <br>    } <br> <br>    hpal = CreatePalette(pPal); <br>    LocalFree(pPal); <br>    return hpal; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
