<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GLMAZE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3726"></a>GLMAZE.C</h2>
<pre><code>#include "pch.c" <br>#pragma hdrstop <br> <br>#include &lt;time.h&gt; <br>#include "mazedlg.h" <br>#include &lt;assert.h&gt; <br> <br>MazeView vw; <br>MazeSolution sol; <br> <br>MazeOptions maze_options = <br>{ <br>    FALSE,          // depth_test <br>    RENDER_FLAT,    // render mode (WALLS) <br>    RENDER_FLAT,    // render mode (FLOOR) <br>    RENDER_FLAT,    // render mode (CEILING) <br>    FALSE,           // frame_count <br>    FALSE,          // top_view <br>    TRUE,           // eye_view <br>    FALSE,          // single_step <br>    FALSE,          // all_alpha <br>    FALSE,          // bDither <br>    1               // nrats <br>}; <br> <br>float gfAspect = 1.0f;  // aspect ratio <br> <br>#define SST_NEW_MAZE    0 <br>#define SST_MAZE_GROW   1 <br>#define SST_SOLVING     2 <br>#define SST_MAZE_SHRINK 3 <br>#define SST_ROTATE      4 <br> <br>int solve_state = SST_NEW_MAZE; <br> <br>// Table of textures used.  The first entries contain 1 texture for each main <br>// surface, followed by textures used for various objects <br>TEXTURE all_textures[NUM_TEXTURES]; <br> <br>// Environment associated with the texture (repetition, palette rotation,..)  <br>// For now, have one for each of the textures in all_textures.  But, this  <br>// could be a per-object thing. <br>TEX_ENV gTexEnv[NUM_TEXTURES]; <br> <br>// texture environment mode <br>int gTexEnvMode; <br> <br>// Texture resources for the main surfaces <br>TEX_RES gTexResSurf[NUM_DEF_SURFACE_TEXTURES] = { <br>    {TEX_BMP, IDB_BRICK},       // default textures <br>    {TEX_BMP, IDB_WOOD}, <br>    {TEX_BMP, IDB_CASTLE}, <br>    {TEX_A8,  IDB_CURL4},       // mandelbrot textures <br>    {TEX_A8,  IDB_BHOLE4}, <br>    {TEX_A8,  IDB_SNOWFLAK}, <br>    {TEX_A8,  IDB_SWIRLX4} <br>}; <br>     <br>// Texture resources for objects <br>TEX_RES gTexResObject[NUM_OBJECT_TEXTURES] = { <br>    {TEX_A8,  IDB_START}, <br>    {TEX_A8,  IDB_END}, <br>    {TEX_A8,  IDB_RAT}, <br>    {TEX_A8,  IDB_AD}, <br>    {TEX_BMP, IDB_COVER} <br>}; <br>SSContext gssc; <br> <br>void maze_Init( void *data ); <br>void RotateTexturePalettes( TEX_ENV *pTexEnv, int count, int iRot ); <br> <br>enum { <br>    TIMER_START = 0, <br>    TIMER_STOP <br>}; <br> <br>void Draw(void) <br>{ <br>    GLbitfield mask; <br> <br>    mask = 0; <br>    if (maze_options.depth_test) <br>    { <br>        mask |= GL_DEPTH_BUFFER_BIT; <br>    } <br>    if (maze_options.render[FLOOR] == RENDER_NONE || <br>        maze_options.render[CEILING] == RENDER_NONE || <br>        maze_options.render[WALLS] == RENDER_NONE || <br>        maze_height &lt; 1.0f) <br>    { <br>        mask |= GL_COLOR_BUFFER_BIT; <br>    } <br>    if (mask != 0) <br>    { <br>        glClear(mask); <br>    } <br> <br>    // Rotate the palettes of any paletted texures by 1 <br>    RotateTexturePalettes( gTexEnv, NUM_TEXTURES, 1 ); <br> <br>    if (maze_options.eye_view) <br>    { <br>        DrawMaze(&amp;vw); <br>    } <br> <br>    if (maze_options.top_view) <br>    { <br>        DrawTopView(&amp;vw); <br>    } <br>     <br>    glFlush(); <br>} <br> <br>MazeGoal maze_goals[MAX_GOALS]; <br>int ngoals; <br> <br>Object special_obj[MAX_SPECIALS]; <br> <br>#define MAX_LETTERS 3 <br>Object letters_obj[MAX_LETTERS]; <br> <br>typedef struct _Rat <br>{ <br>    Object obj; <br>    MazeView vw; <br>    MazeSolution sol; <br>} Rat; <br>Rat rats[MAX_RATS]; <br> <br>void NewMazeList(void) <br>{ <br>    glNewList(maze_walls_list, GL_COMPILE); <br>    DrawMazeWalls(); <br>    glEndList(); <br>} <br> <br>void UpdateRatPosition(Rat *rat) <br>{ <br>    MoveObject(&amp;rat-&gt;obj, rat-&gt;vw.pos.x, rat-&gt;vw.pos.y); <br>    // Invert the angle because view angles move opposite to <br>    // object angles <br>    rat-&gt;obj.ang = FaAdd(0, -rat-&gt;vw.ang); <br>} <br> <br>// Simple routines to pick cells at random while guaranteeing <br>// that those cells are unoccupied <br> <br>static int rnd_cells[MAZE_CELLS]; <br>static int nrnd_cells; <br> <br>void InitRandomCells(void) <br>{ <br>    int i; <br> <br>    nrnd_cells = MAZE_CELLS; <br>    for (i = 0; i &lt; nrnd_cells; i++) <br>    { <br>        rnd_cells[i] = i; <br>    } <br>} <br> <br>void PickRandomCell(IntPt2 *pos) <br>{ <br>    int idx, t; <br> <br>#if DBG <br>    if (nrnd_cells == 0) <br>    { <br>        MessageBox(GetDesktopWindow(), TEXT("Out of random cells"), <br>                   NULL, MB_OK); <br>        pos-&gt;x = 0; <br>        pos-&gt;y = 0; <br>        return; <br>    } <br>#endif <br>     <br>    idx = rand() % nrnd_cells; <br>    nrnd_cells--; <br>    t = rnd_cells[idx]; <br>    rnd_cells[idx] = rnd_cells[nrnd_cells]; <br>    pos-&gt;x = t % MAZE_GRID; <br>    pos-&gt;y = t / MAZE_GRID; <br>} <br> <br>void RemoveRandomCell(IntPt2 *pos) <br>{ <br>    int i, idx; <br> <br>    for (i = 0; i &lt; nrnd_cells; i++) <br>    { <br>        idx = rnd_cells[i]; <br>        if ((idx % MAZE_GRID) == pos-&gt;x &amp;&amp; <br>            (idx / MAZE_GRID) == pos-&gt;y) <br>        { <br>            nrnd_cells--; <br>            rnd_cells[i] = rnd_cells[nrnd_cells]; <br>            return; <br>        } <br>    } <br>} <br> <br>void NewMaze(void) <br>{ <br>    IntPt2 cell, start_cell; <br>    int i, nspecials, nads; <br>    static BOOL firstMaze = TRUE; <br> <br>    // If not in full screen mode, move the maze window around after it's solved <br>    if( !gbTurboMode &amp;&amp; !firstMaze ) <br>        ss_RandomWindowPos(); <br> <br>    InitRandomCells(); <br>     <br>    if (!InitMaze(&amp;start_cell, maze_goals, &amp;ngoals)) <br>    { <br>        printf("InitMaze failed\n"); <br>        exit(1); <br>    } <br> <br>    RemoveRandomCell(&amp;start_cell); <br>    cell.x = maze_goals[GOAL_END].clx; <br>    cell.y = maze_goals[GOAL_END].cly; <br>    RemoveRandomCell(&amp;cell); <br> <br>    nspecials = rand() % MAX_SPECIALS; <br>    for (i = 0; i &lt; nspecials; i++) <br>    { <br>        PickRandomCell(&amp;cell); <br>        maze_goals[ngoals].clx = cell.x; <br>        maze_goals[ngoals].cly = cell.y; <br>        maze_goals[ngoals].user = &amp;special_obj[i]; <br>         <br>        special_obj[i].w = FMAZE_CELL_SIZE/4; <br>        special_obj[i].h = FxFltVal(.25); <br>        special_obj[i].z = special_obj[i].h; <br>        special_obj[i].col = 15; <br>        special_obj[i].draw_style = DRAW_SPECIAL; <br>        special_obj[i].draw_arg = rand() % SPECIAL_ARG_COUNT; <br>        special_obj[i].ang = FaDeg(0); <br>        special_obj[i].user1 = (rand() % 6)+2; <br>        special_obj[i].user2 = rand() % 5; <br>        special_obj[i].user3 = 0; <br>        PlaceObject(&amp;special_obj[i], <br>                    CellToMfx(maze_goals[ngoals].clx)+FMAZE_CELL_SIZE/2, <br>                    CellToMfx(maze_goals[ngoals].cly)+FMAZE_CELL_SIZE/2); <br>        ngoals++; <br>    } <br>    while (i &lt; MAX_SPECIALS) <br>    { <br>        special_obj[i].cell = NULL; <br>        i++; <br>    } <br> <br>    nads = (rand() % (MAX_LETTERS*2))-MAX_LETTERS+1; <br>    for (i = 0; i &lt; nads; i++) <br>    { <br>        PickRandomCell(&amp;cell); <br>         <br>        letters_obj[i].w = FMAZE_CELL_SIZE/3; <br>        letters_obj[i].h = FxFltVal(.33); <br>        letters_obj[i].z = FxFltVal(.5); <br>        letters_obj[i].col = 15; <br>        letters_obj[i].draw_style = DRAW_POLYGON; <br>        letters_obj[i].pTexEnv = &amp;gTexEnv[ TEX_AD ]; <br>        letters_obj[i].ang = FaDeg(0); <br>        PlaceObject(&amp;letters_obj[i], <br>                    CellToMfx(cell.x)+FMAZE_CELL_SIZE/2, <br>                    CellToMfx(cell.y)+FMAZE_CELL_SIZE/2); <br>    } <br>    while (i &lt; MAX_LETTERS) <br>    { <br>        letters_obj[i].cell = NULL; <br>        i++; <br>    } <br> <br>    for (i = 0; i &lt; maze_options.nrats; i++) <br>    { <br>        PickRandomCell(&amp;cell); <br>         <br>        rats[i].obj.w = FMAZE_CELL_SIZE/4; <br>        rats[i].obj.h = FxFltVal(.125); <br>        rats[i].obj.z = rats[i].obj.h; <br>        rats[i].obj.col = 16; <br>        rats[i].obj.draw_style = DRAW_POLYGON; <br>        rats[i].obj.pTexEnv = &amp;gTexEnv[ TEX_RAT ]; <br>        SolveMazeStart(&amp;rats[i].vw, &amp;maze_cells[0][0], MAZE_GRID, MAZE_GRID, <br>                       &amp;cell, SOL_DIR_LEFT, <br>                       NULL, 0, <br>                       (rand() % 1000) &gt; 500 ? SOL_TURN_LEFT : SOL_TURN_RIGHT, <br>                       &amp;rats[i].sol); <br>        // Need to force this to NULL when a new maze is generated so <br>        // that moving doesn't try to use old maze data <br>        rats[i].obj.cell = NULL; <br>        UpdateRatPosition(&amp;rats[i]); <br>    } <br>     <br>    NewMazeList(); <br>     <br>    SolveMazeStart(&amp;vw, &amp;maze_cells[0][0], MAZE_GRID, MAZE_GRID, <br>                   &amp;start_cell, SOL_DIR_RIGHT, <br>                   maze_goals, ngoals, <br>                   (rand() % 1000) &gt; 500 ? SOL_TURN_LEFT : SOL_TURN_RIGHT, <br>                   &amp;sol); <br> <br>    solve_state = SST_MAZE_GROW; <br>    firstMaze = FALSE; <br>} <br> <br>/**************************************************************************\ <br>* Step <br>* <br>* Main draw proc <br>* <br>\**************************************************************************/ <br> <br>static MazeGoal *found_goal = NULL; <br>static int rot_step; <br> <br>void Step(void *data) <br>{ <br>    int i; <br>    MazeGoal *goal; <br> <br>    switch(solve_state) <br>    { <br>    case SST_NEW_MAZE: <br>        view_rot = 0; <br>        maze_height = 0.0f; <br>        NewMaze(); <br>        break; <br> <br>    case SST_SOLVING: <br>        for (i = 0; i &lt; maze_options.nrats; i++) <br>        { <br>            SolveMazeStep(&amp;rats[i].vw, &amp;rats[i].sol); <br>            UpdateRatPosition(&amp;rats[i]); <br>        } <br>         <br>        goal = SolveMazeStep(&amp;vw, &amp;sol); <br>        if (goal == &amp;maze_goals[GOAL_END]) <br>        { <br>            solve_state = SST_MAZE_SHRINK; <br>        } <br>        else if (goal != NULL) <br>        { <br>            solve_state = SST_ROTATE; <br>            found_goal = goal; <br>            rot_step = 0; <br>        } <br>        break; <br> <br>    case SST_MAZE_GROW: <br>        maze_height += .025f; <br>        if (maze_height &gt;= 1.0f) <br>        { <br>            solve_state = SST_SOLVING; <br>        } <br>        break; <br>         <br>    case SST_MAZE_SHRINK: <br>        maze_height -= .025f; <br>        if (maze_height &lt;= 0.0f) <br>        { <br>            solve_state = SST_NEW_MAZE; <br>        } <br>        break; <br> <br>    case SST_ROTATE: <br>        view_rot += 10.0; <br>        if (++rot_step == 18) <br>        { <br>            Object *sp_obj; <br> <br>            sp_obj = (Object *)found_goal-&gt;user; <br>            RemoveObject(sp_obj); <br>             <br>            solve_state = SST_SOLVING; <br>            ngoals--; <br>            if (found_goal &lt; maze_goals+ngoals) <br>            { <br>                memmove(found_goal, found_goal+1, <br>                        sizeof(MazeGoal)*(ngoals-(found_goal-maze_goals))); <br>            } <br>            SolveMazeSetGoals(&amp;sol, maze_goals, ngoals); <br>            found_goal = NULL; <br> <br>            if (view_rot &gt;= 360.0) <br>            { <br>                view_rot = 0.0; <br>            } <br>            else <br>            { <br>                view_rot = 180.0; <br>            } <br>        } <br>        break; <br>    } <br> <br>    Draw(); <br> <br>    for (i = 0; i &lt; MAX_SPECIALS; i++) <br>    { <br>        // Increment rotations of any specials still present in the maze <br>        if (special_obj[i].cell != NULL) <br>        { <br>            special_obj[i].ang = FaAdd(special_obj[i].ang, <br>                                       FaDeg(special_obj[i].user1)); <br>            special_obj[i].user3 += special_obj[i].user2; <br>        } <br>    } <br>} <br> <br>void UpdateModes(void) <br>{ <br>    if (maze_options.depth_test) <br>    { <br>        glEnable(GL_DEPTH_TEST); <br>    } <br>    else <br>    { <br>        glDisable(GL_DEPTH_TEST); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* Reshape <br>* <br>*       - called on resize, expose                                       <br>*       - always called on app startup                                   <br>* <br>\**************************************************************************/ <br> <br>void  <br>Reshape(int width, int height, void *data ) <br>{ <br>    gfAspect = height == 0 ? 1.0f: (float) width / (float) height; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* VerifyTextureFiles <br>* <br>* Check that any user specified textures are valid <br>* - MUST be called at ss_Init, or any error msgs will not display properly <br>* <br>\**************************************************************************/ <br> <br>void VerifyTextureFiles(void) <br>{ <br>    int i; <br> <br>    ss_DisableTextureErrorMsgs(); <br> <br>    for (i = 0; i &lt; NUM_SURFACES; i++) { <br>        if( gTexInfo[i].bTex &amp;&amp; !gTexInfo[i].bDefTex ) { <br>            if( !ss_VerifyTextureFile( &amp;gTexInfo[i].texFile ) ) <br>                // use default texture <br>                gTexInfo[i].bDefTex = TRUE; <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* CalcRep <br>* <br>* Figure out repetion based on size. <br>* <br>* - Use 128 pixels as a unit repetition reference <br>* - Size is always a power of 2 <br>* <br>\**************************************************************************/ <br> <br>static int <br>CalcRep( int size ) <br>{ <br>    double pow2; <br>    int pow2ref = 8; <br>    int rep; <br> <br>    pow2 = log((double)size) / log((double)2.0); <br>    rep = 1 + pow2ref - (int)pow2; <br>    return rep;  <br>} <br> <br>// tradeoff <br>#define MAX_TEX_DIM 128 <br>//#define MAX_TEX_DIM 256 <br> <br>/******************************Public*Routine******************************\ <br>* CalcTexRep <br>* <br>* Figure out texture repetition based on texture size. <br>* <br>* - mf: ? double for walls/ceiling ? <br>* <br>\**************************************************************************/ <br> <br>static void <br>CalcTexRep( TEXTURE *pTex, IPOINT2D *pTexRep ) <br>{ <br>    if( pTex-&gt;width &gt;= MAX_TEX_DIM ) <br>        pTexRep-&gt;x = 1; <br>    else <br>        pTexRep-&gt;x = CalcRep( pTex-&gt;width ); <br> <br>    if( pTex-&gt;height &gt;= MAX_TEX_DIM ) <br>        pTexRep-&gt;y = 1; <br>    else <br>        pTexRep-&gt;y = CalcRep( pTex-&gt;height ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* LoadTextures <br>* <br>* Load textures from .bmp files or from embedded resources, using <br>* global texture info structure. <br>* <br>* For now, this also sets render modes, since if texturing is off for a <br>* surface, we always use RENDER_FLAT <br>* <br>\**************************************************************************/ <br> <br>static void  <br>LoadTextures(void) <br>{ <br>    int i; <br>    TEXTURE *pTex = all_textures; <br>    TEX_ENV *pTexEnv = gTexEnv; <br>    TEX_RES *pTexRes; <br> <br>    assert( (NUM_SURFACES + NUM_OBJECT_TEXTURES) == NUM_TEXTURES ); <br> <br>    // load surface textures (wall, floor, ceiling) <br> <br>    for (i = 0; i &lt; NUM_SURFACES; i++, pTex++, pTexEnv++) { <br>        maze_options.render[i] = RENDER_FLAT; <br>        if( gTexInfo[i].bTex ) { <br>            pTexEnv-&gt;pTex = pTex; <br>            pTexEnv-&gt;bTransp = FALSE; <br> <br>            // Load user or default texture for the surface <br> <br>            if( !gTexInfo[i].bDefTex &amp;&amp;  <br>                ss_LoadTextureFile( &amp;gTexInfo[i].texFile, pTex )) { <br>            } else <br>            { <br>                // Load default resource texture <br> <br>                pTexRes = &amp;gTexResSurf[ gTexInfo[i].iDefTex ]; <br>                if( !ss_LoadTextureResource( pTexRes, pTex ) ) <br>                    continue;  <br>     <br>                if( ss_PalettedTextureEnabled() &amp;&amp; <br>                    (pTexRes-&gt;type == TEX_A8) ) <br>                { <br>                    pTexEnv-&gt;bPalRot = TRUE; <br>                    pTexEnv-&gt;iPalRot = ss_iRand( 0xff ); <br>                } else <br>                    pTexEnv-&gt;bPalRot = FALSE; <br>            } <br> <br>            maze_options.render[i] = RENDER_TEXTURED; <br> <br>            // Figure out texture repetition <br>            CalcTexRep( pTex, &amp;pTexEnv-&gt;texRep ); <br>            // We would have to set texture parameters per object here, <br>            // but we just use default ones already set by ss_LoadTexture* <br>        } <br>    } <br> <br>    // load object textures <br> <br>    pTexRes = gTexResObject; <br>    for( i = 0; i &lt; NUM_OBJECT_TEXTURES; i++, pTex++, pTexEnv++, pTexRes++ ) { <br>        if( ss_LoadTextureResource( pTexRes, pTex ) ) <br>            pTexEnv-&gt;pTex = pTex; <br>        else <br>            pTexEnv-&gt;pTex = NULL; <br> <br>        pTexEnv-&gt;bTransp = FALSE; <br> <br>        // For now we don't do palrot's on any of the object textures <br>        pTexEnv-&gt;bPalRot = FALSE; <br>        // No repetition <br>        pTexEnv-&gt;texRep.x = pTexEnv-&gt;texRep.y = 1; <br>    } <br> <br>    // Set transparency for some of the textures <br>    ss_SetTextureTransparency( gTexEnv[TEX_START].pTex, 0.42f, FALSE ); <br>    ss_SetTextureTransparency( gTexEnv[TEX_END].pTex, 0.4f, FALSE ); <br>    ss_SetTextureTransparency( gTexEnv[TEX_AD].pTex, 0.4f, FALSE ); <br> <br>    // Enable transparency for some of the texture environments <br>    gTexEnv[TEX_START].bTransp = TRUE; <br>    gTexEnv[TEX_END].bTransp = TRUE; <br>    gTexEnv[TEX_AD].bTransp = TRUE; <br>} <br> <br>void UseTextureEnv( TEX_ENV *pTexEnv ) <br>{ <br>    static HTEXTURE hCurTex = (HTEXTURE) -1; <br>    HTEXTURE hTex = pTexEnv-&gt;pTex; <br> <br>    // We cache the current texture for 'no texture object' case <br> <br>    if( !ss_TextureObjectsEnabled() &amp;&amp; <br>        (hCurTex == hTex) ) <br>        return; // same texture, no need to send it down <br> <br>    // Make this texture current <br> <br>    ss_SetTexture( hTex ); <br> <br>    // Set texture palette if necessary <br> <br>    if( pTexEnv-&gt;bPalRot &amp;&amp; <br>        !ss_TextureObjectsEnabled() &amp;&amp;  <br>        ss_PalettedTextureEnabled() ) { <br> <br>        // We need to send down the (rotated) palette <br>        ss_SetTexturePalette( hTex, pTexEnv-&gt;iPalRot ); <br>    } <br> <br>    hCurTex = hTex; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* RotateTexturePalettes <br>* <br>* If paletted texturing is enabled, go through the supplied list of texture <br>* environments, and if any have a palette, increment its rotation by the <br>* supplied iRot value. <br>* <br>\**************************************************************************/ <br> <br>void <br>RotateTexturePalettes( TEX_ENV *pTexEnv, int count, int iRot ) <br>{ <br>    if( !ss_PalettedTextureEnabled() || !pTexEnv ) <br>        return; <br> <br> <br>    for( ; count; count--, pTexEnv++ ) { <br> <br>        if( !pTexEnv-&gt;pTex || !pTexEnv-&gt;pTex-&gt;pal ) <br>            continue; <br> <br>        if( pTexEnv-&gt;bPalRot ) { <br>            // increment palette rotation <br>            pTexEnv-&gt;iPalRot += iRot; <br>            if( pTexEnv-&gt;iPalRot &gt;= pTexEnv-&gt;pTex-&gt;pal_size ) <br>                pTexEnv-&gt;iPalRot = 0; <br>            // Only send down the new palette if texture objects are enabled, <br>            // since otherwise it will be sent down when texture is  <br>            // 'made current' <br>            if( ss_TextureObjectsEnabled() ) { <br>                ss_SetTexturePalette( pTexEnv-&gt;pTex, pTexEnv-&gt;iPalRot ); <br>            } <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* InitStretchInfo <br>* <br>\**************************************************************************/ <br> <br>static void <br>InitStretchInfo( STRETCH_INFO *pStretch ) <br>{ <br>    pStretch-&gt;baseWidth = 320; <br>    pStretch-&gt;baseHeight = 200; <br>    pStretch-&gt;bRatioMode = FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetFloaterInfo <br>* <br>* Set the size and position of the floating child window <br>* <br>\**************************************************************************/ <br> <br> <br>static void  <br>SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild ) <br>{ <br>    float hdtvAspect = 9.0f / 16.0f; <br>    ISIZE *pChildSize = &amp;pChild-&gt;size; <br> <br>    // Set width according to user-specified size <br>    // (giSize range is 0..100) <br>    // set min size as 1/3 parent width <br>    pChildSize-&gt;width =  <br>            (int) ((0.333f + 2.0f*giSize/300.0f) * pParentSize-&gt;width); <br> <br>    // Scale height for hdtv aspect ratio <br>    pChildSize-&gt;height = (int) (hdtvAspect * pChildSize-&gt;width + 0.5f); <br>    // Ensure height not too big <br>    SS_CLAMP_TO_RANGE2( pChildSize-&gt;height, 0, pParentSize-&gt;height ); <br> <br>    pChild-&gt;pos.x = (pParentSize-&gt;width - pChildSize-&gt;width) / 2; <br>    pChild-&gt;pos.y = (pParentSize-&gt;height - pChildSize-&gt;height) / 2; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_Init <br>* <br>* Initialize - called on first entry into ss. <br>* Called BEFORE gl is initialized! <br>* Just do basic stuff here, like set up callbacks, verify dialog stuff, etc. <br>* <br>* Fills global SSContext structure with required data, and returns ptr <br>* to it. <br>* <br>\**************************************************************************/ <br> <br>SSContext * <br>ss_Init( void ) <br>{ <br>    getIniSettings(); <br> <br>    VerifyTextureFiles(); <br> <br>    // Set callbacks <br> <br>    ss_InitFunc( maze_Init ); <br>    ss_UpdateFunc( Step ); <br>    ss_ReshapeFunc( Reshape ); <br> <br>    gssc.depthType = (maze_options.depth_test) ? SS_DEPTH16 : SS_DEPTH_NONE; <br> <br>    // Currently stretch and floater mutex <br>    gssc.bDoubleBuf = TRUE; // will get turned off if stretch used <br>    if( gbTurboMode ) { <br>        // We stretch out the drawing area to the full size of the main window <br>        gssc.bFloater = FALSE; <br>        gssc.bStretch = TRUE; <br>        InitStretchInfo( &amp;gssc.stretchInfo ); <br>    } else { <br>        // A static centered floating window is created in the main window <br>        FLOATER_INFO *pFloater = &amp;gssc.floaterInfo; <br> <br>        gssc.bFloater = TRUE; <br>        gssc.bStretch = FALSE; <br>        pFloater-&gt;bMotion = FALSE; <br>        pFloater-&gt;ChildSizeFunc = SetFloaterInfo; <br>    } <br> <br>    return &amp;gssc; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* maze_Init <br>* <br>* Initializes OpenGL state <br>* <br>\**************************************************************************/ <br>void <br>maze_Init( void *data ) <br>{ <br>    float fv4[4]; <br> <br>    if (!FxInitialize(FA_TABLE_SIZE, 0)) <br>    { <br>        printf("FxInit failed\n"); <br>        exit(1); <br>    } <br> <br>    glShadeModel( GL_FLAT ); <br>    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); <br> <br>    glClearDepth(1); <br>     <br>    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br>    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <br>    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); <br> <br>    if( (giImageQual == IMAGEQUAL_DEFAULT) || gbTurboMode ) { <br>        maze_options.bDither = FALSE; <br>        glDisable( GL_DITHER ); <br>    } else { <br>        maze_options.bDither = TRUE; <br>        glEnable( GL_DITHER ); <br>    } <br> <br>    // Load textures and set render modes <br>    LoadTextures(); <br>     <br>    fv4[0] = MAZE_SIZE/2.0f; <br>    fv4[1] = MAZE_SIZE/2.0f; <br>    fv4[2] = 10.0f; <br>    fv4[3] = 1.0f; <br>    glLightfv(GL_LIGHT0, GL_POSITION, fv4); <br>    glEnable(GL_LIGHT0); <br> <br>    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); <br>     <br>    // Check which texture environment function to use for objects <br>    if( ss_fOnGL11() ) <br>        gTexEnvMode = GL_REPLACE; <br>    else <br>        gTexEnvMode = GL_MODULATE;  <br> <br>    maze_walls_list = glGenLists(1); <br>     <br>    UpdateModes(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
