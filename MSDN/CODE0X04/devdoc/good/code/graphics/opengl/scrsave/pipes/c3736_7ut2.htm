<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NPIPE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3746"></a>NPIPE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: npipe.cxx <br>* <br>* Normal pipes code <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "sspipes.h" <br>#include "npipe.h" <br>#include "state.h" <br> <br> <br>static void align_notch( int newDir, int notch ); <br>static void align_plusy( int oldDir, int newDir ); <br> <br>// defCylNotch shows where the notch for the default cylinder will be, <br>//  in absolute coords, once we do an align_plusz <br> <br>static GLint defCylNotch[NUM_DIRS] =  <br>        { PLUS_Y, PLUS_Y, MINUS_Z, PLUS_Z, PLUS_Y, PLUS_Y }; <br> <br> <br>/**************************************************************************\ <br>* NORMAL_PIPE constructor <br>* <br>* <br>\**************************************************************************/ <br> <br>NORMAL_PIPE::NORMAL_PIPE( STATE *pState ) <br>: PIPE( pState ) <br>{ <br> <br>    type = TYPE_NORMAL; <br>    pNState = pState-&gt;pNState; <br> <br>    // choose weighting of going straight <br>    if( ! ss_iRand( 20 ) ) <br>        weightStraight = ss_iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT ); <br>    else <br>        weightStraight = 1 + ss_iRand( 4 ); <br>} <br> <br>/**************************************************************************\ <br>* Start <br>* <br>* Start drawing a new normal pipe <br>* <br>* - Draw a start cap and short pipe in new direction <br>* <br>\**************************************************************************/ <br> <br>void <br>NORMAL_PIPE::Start( ) <br>{ <br>    int newDir; <br> <br>    // Set start position <br> <br>    if( !SetStartPos() ) { <br>        status = PIPE_OUT_OF_NODES; <br>        return; <br>    } <br> <br>    // set a material <br> <br>    ChooseMaterial(); <br> <br>    // push matrix that has initial zTrans and rotation <br>    glPushMatrix(); <br> <br>    // Translate to current position <br>    TranslateToCurrentPosition(); <br> <br>    // Pick a random lastDir <br>    lastDir = ss_iRand( NUM_DIRS ); <br> <br>    newDir = ChooseNewDirection(); <br> <br>    if( newDir == DIR_NONE ) { <br>        // pipe is stuck at the start node, draw something <br>        status = PIPE_STUCK; <br>        DrawTeapot(); <br>        glPopMatrix(); <br>        return; <br>    } else <br>        status = PIPE_ACTIVE; <br> <br>    // set initial notch vector <br>    notchVec = defCylNotch[newDir]; <br> <br>    DrawStartCap( newDir ); <br> <br>    // move ahead 1.0*r to draw pipe <br>    glTranslatef( 0.0f, 0.0f, radius ); <br>             <br>    // draw short pipe <br>    align_notch( newDir, notchVec ); <br>    pNState-&gt;shortPipe-&gt;Draw(); <br> <br>    glPopMatrix(); <br> <br>    UpdateCurrentPosition( newDir ); <br> <br>    lastDir = newDir; <br>} <br> <br>/**************************************************************************\ <br>* Draw <br>* <br>* - if turning, draws a joint and a short cylinder, otherwise <br>*   draws a long cylinder. <br>* - the 'current node' is set as the one we draw thru the NEXT <br>*   time around. <br>* <br>\**************************************************************************/ <br> <br>void <br>NORMAL_PIPE::Draw() <br>{ <br>    int newDir; <br> <br>    newDir = ChooseNewDirection(); <br> <br>    if( newDir == DIR_NONE ) {  // no empty nodes - nowhere to go <br>        DrawEndCap(); <br>        status = PIPE_STUCK; <br>        return; <br>    } <br> <br>    // push matrix that has initial zTrans and rotation <br>    glPushMatrix(); <br> <br>    // Translate to current position <br>    TranslateToCurrentPosition(); <br> <br>    // draw joint if necessary, and pipe <br> <br>    if( newDir != lastDir ) { // turning! - we have to draw joint <br>        DrawJoint( newDir ); <br> <br>        // draw short pipe <br>        align_notch( newDir, notchVec ); <br>        pNState-&gt;shortPipe-&gt;Draw(); <br>    } <br>    else {  // no turn <br>        // draw long pipe, from point 1.0*r back <br>        align_plusz( newDir ); <br>        align_notch( newDir, notchVec ); <br>        glTranslatef( 0.0f, 0.0f, -radius ); <br>        pNState-&gt;longPipe-&gt;Draw(); <br>    } <br> <br>    glPopMatrix(); <br> <br>    UpdateCurrentPosition( newDir ); <br> <br>    lastDir = newDir; <br>} <br> <br>/**************************************************************************\ <br>* DrawStartCap <br>* <br>* Cap the start of the pipe with a ball <br>* <br>\**************************************************************************/ <br> <br>void  <br>NORMAL_PIPE::DrawStartCap( int newDir ) <br>{ <br>    if( bTexture ) { <br>        align_plusz( newDir ); <br>        pNState-&gt;ballCap-&gt;Draw(); <br>    } <br>    else { <br>        // draw big ball in default orientation <br>        pNState-&gt;bigBall-&gt;Draw(); <br>        align_plusz( newDir ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* DrawEndCap(): <br>* <br>* - Draws a ball, used to cap end of a pipe <br>* <br>\**************************************************************************/ <br> <br>void  <br>NORMAL_PIPE::DrawEndCap( ) <br>{ <br>    glPushMatrix(); <br> <br>    // Translate to current position <br>    TranslateToCurrentPosition(); <br> <br>    if( bTexture ) { <br>        glPushMatrix(); <br>        align_plusz( lastDir ); <br>        align_notch( lastDir, notchVec ); <br>        pNState-&gt;ballCap-&gt;Draw(); <br>        glPopMatrix(); <br>    } <br>    else <br>        pNState-&gt;bigBall-&gt;Draw(); <br> <br>    glPopMatrix(); <br>} <br> <br>/**************************************************************************\ <br>* ChooseElbow <br>* <br>* - Decides which elbow to draw <br>* - The beginning of each elbow is aligned along +y, and we have <br>*   to choose the one with the notch in correct position <br>* - The 'primary' start notch (elbow[0]) is in same direction as <br>*   newDir, and successive elbows rotate this notch CCW around +y <br>* <br>\**************************************************************************/ <br> <br> <br>// this array supplies the sequence of elbow notch vectors, given <br>//  oldDir and newDir  (0's are don't cares) <br>// it is also used to determine the ending notch of an elbow <br>static GLint notchElbDir[NUM_DIRS][NUM_DIRS][4] = { <br>// oldDir = +x <br>        iXX,            iXX,            iXX,            iXX, <br>        iXX,            iXX,            iXX,            iXX, <br>        PLUS_Y,         MINUS_Z,        MINUS_Y,        PLUS_Z, <br>        MINUS_Y,        PLUS_Z,         PLUS_Y,         MINUS_Z, <br>        PLUS_Z,         PLUS_Y,         MINUS_Z,        MINUS_Y, <br>        MINUS_Z,        MINUS_Y,        PLUS_Z,         PLUS_Y, <br>// oldDir = -x <br>        iXX,            iXX,            iXX,            iXX, <br>        iXX,            iXX,            iXX,            iXX, <br>        PLUS_Y,         PLUS_Z,         MINUS_Y,        MINUS_Z, <br>        MINUS_Y,        MINUS_Z,        PLUS_Y,         PLUS_Z, <br>        PLUS_Z,         MINUS_Y,        MINUS_Z,        PLUS_Y, <br>        MINUS_Z,        PLUS_Y,         PLUS_Z,         MINUS_Y, <br>// oldDir = +y <br>        PLUS_X,         PLUS_Z,         MINUS_X,        MINUS_Z, <br>        MINUS_X,        MINUS_Z,        PLUS_X,         PLUS_Z, <br>        iXX,            iXX,            iXX,            iXX, <br>        iXX,            iXX,            iXX,            iXX, <br>        PLUS_Z,         MINUS_X,        MINUS_Z,        PLUS_X, <br>        MINUS_Z,        PLUS_X,         PLUS_Z,         MINUS_X, <br>// oldDir = -y <br>        PLUS_X,         MINUS_Z,        MINUS_X,        PLUS_Z, <br>        MINUS_X,        PLUS_Z,         PLUS_X,         MINUS_Z, <br>        iXX,            iXX,            iXX,            iXX, <br>        iXX,            iXX,            iXX,            iXX, <br>        PLUS_Z,         PLUS_X,         MINUS_Z,        MINUS_X, <br>        MINUS_Z,        MINUS_X,        PLUS_Z,         PLUS_X, <br>// oldDir = +z <br>        PLUS_X,         MINUS_Y,        MINUS_X,        PLUS_Y, <br>        MINUS_X,        PLUS_Y,         PLUS_X,         MINUS_Y, <br>        PLUS_Y,         PLUS_X,         MINUS_Y,        MINUS_X, <br>        MINUS_Y,        MINUS_X,        PLUS_Y,         PLUS_X, <br>        iXX,            iXX,            iXX,            iXX, <br>        iXX,            iXX,            iXX,            iXX, <br>// oldDir = -z <br>        PLUS_X,         PLUS_Y,         MINUS_X,        MINUS_Y, <br>        MINUS_X,        MINUS_Y,        PLUS_X,         PLUS_Y, <br>        PLUS_Y,         MINUS_X,        MINUS_Y,        PLUS_X, <br>        MINUS_Y,        PLUS_X,         PLUS_Y,         MINUS_X, <br>        iXX,            iXX,            iXX,            iXX, <br>        iXX,            iXX,            iXX,            iXX <br>}; <br> <br>GLint  <br>NORMAL_PIPE::ChooseElbow( int oldDir, int newDir ) <br>{ <br>    int i; <br> <br>    // precomputed table supplies correct elbow orientation <br>    for( i = 0; i &lt; 4; i ++ ) { <br>        if( notchElbDir[oldDir][newDir][i] == notchVec ) <br>            return i; <br>    } <br>    // we shouldn't arrive here <br>    return -1; <br>} <br> <br>/**************************************************************************\ <br>* DrawJoint <br>* <br>* Draw a joint between 2 pipes <br>* <br>\**************************************************************************/ <br> <br>void <br>NORMAL_PIPE::DrawJoint( int newDir ) <br>{ <br>    int jointType; <br>    int iBend; <br> <br>    jointType = pNState-&gt;ChooseJointType(); <br>#if PIPES_DEBUG <br>    if( newDir == oppositeDir[lastDir] ) <br>        printf( "Warning: opposite dir chosen!\n" ); <br>#endif <br>         <br>    switch( jointType ) { <br>      case BALL_JOINT: <br>            if( bTexture ) { <br>                // use special texture-friendly ballJoints <br> <br>                align_plusz( newDir ); <br>                glPushMatrix(); <br> <br>                align_plusy( lastDir, newDir ); <br> <br>                // translate forward 1.0*r along +z to get set for drawing elbow <br>                glTranslatef( 0.0f, 0.0f, radius ); <br>                // decide which elbow orientation to use <br>                iBend = ChooseElbow( lastDir, newDir ); <br>                pNState-&gt;ballJoints[iBend]-&gt;Draw(); <br> <br>                glPopMatrix(); <br>            } <br>            else { <br>                // draw big ball in default orientation <br>                pNState-&gt;bigBall-&gt;Draw(); <br>                align_plusz( newDir ); <br>            } <br>            // move ahead 1.0*r to draw pipe <br>            glTranslatef( 0.0f, 0.0f, radius ); <br>        break; <br> <br>      case ELBOW_JOINT: <br>            align_plusz( newDir ); <br> <br>            // the align_plusy() here will screw up our notch calcs, so <br>            //  we push-pop <br> <br>            glPushMatrix(); <br> <br>            align_plusy( lastDir, newDir ); <br> <br>            // translate forward 1.0*r along +z to get set for drawing elbow <br>            glTranslatef( 0.0f, 0.0f, radius ); <br>            // decide which elbow orientation to use <br>            iBend = ChooseElbow( lastDir, newDir ); <br>            if( iBend == -1 ) { <br>#if PIPES_DEBUG <br>                printf( "ChooseElbow() screwed up\n" ); <br>#endif <br>                iBend = 0; // recover <br>            } <br>            pNState-&gt;elbows[iBend]-&gt;Draw(); <br> <br>            glPopMatrix(); <br> <br>            glTranslatef( 0.0f, 0.0f, radius ); <br>        break; <br> <br>      default: <br>            // Horrors! It's the teapot! <br>            DrawTeapot(); <br>            align_plusz( newDir ); <br>            // move ahead 1.0*r to draw pipe <br>            glTranslatef( 0.0f, 0.0f, radius ); <br>        } <br>             <br>        // update the current notch vector <br>        notchVec = notchTurn[lastDir][newDir][notchVec]; <br>#if PIPES_DEBUG <br>        if( notchVec == iXX ) <br>            printf( "notchTurn gave bad value\n" ); <br>#endif <br>} <br> <br> <br>/**************************************************************************\ <br>* Geometry functions <br>\**************************************************************************/ <br> <br> <br>static float RotZ[NUM_DIRS][NUM_DIRS] = { <br>          0.0f,   0.0f,  90.0f,  90.0f,  90.0f, -90.0f, <br>          0.0f,   0.0f, -90.0f, -90.0f, -90.0f,  90.0f, <br>        180.0f, 180.0f,   0.0f,   0.0f, 180.0f, 180.0f, <br>          0.0f,   0.0f,   0.0f,   0.0f,   0.0f,   0.0f, <br>        -90.0f,  90.0f,   0.0f, 180.0f,   0.0f,   0.0f, <br>         90.0f, -90.0f, 180.0f,   0.0f,   0.0f,   0.0f }; <br> <br>         <br>             <br>/*----------------------------------------------------------------------- <br>|                                                                       | <br>|    align_plusy( int lastDir, int newDir )                             | <br>|       - Assuming +z axis is already aligned with newDir, align        | <br>|         +y axis BACK along lastDir                                    | <br>|                                                                       | <br>-----------------------------------------------------------------------*/ <br> <br>static void  <br>align_plusy( int oldDir, int newDir ) <br>{ <br>    GLfloat rotz; <br> <br>    rotz = RotZ[oldDir][newDir]; <br>    glRotatef( rotz, 0.0f, 0.0f, 1.0f ); <br>} <br> <br>// given a dir, determine how much to rotate cylinder around z to match notches <br>// format is [newDir][notchVec] <br> <br>static GLfloat alignNotchRot[NUM_DIRS][NUM_DIRS] = { <br>        fXX,    fXX,    0.0f,   180.0f,  90.0f, -90.0f, <br>        fXX,    fXX,    0.0f,   180.0f,  -90.0f, 90.0f, <br>        -90.0f, 90.0f,  fXX,    fXX,    180.0f, 0.0f, <br>        -90.0f, 90.0f,  fXX,    fXX,    0.0f,   180.0f, <br>        -90.0f, 90.0f,  0.0f,   180.0f, fXX,    fXX, <br>        90.0f,  -90.0f, 0.0f,   180.0f, fXX,    fXX <br>}; <br>                 <br>                 <br>/*----------------------------------------------------------------------- <br>|                                                                       | <br>|    align_notch( int newDir )                                          | <br>|       - a cylinder is notched, and we have to line this up            | <br>|         with the previous primitive's notch which is maintained as    | <br>|         notchVec.                                                     | <br>|       - this adds a rotation around z to achieve this                 | <br>|                                                                       | <br>-----------------------------------------------------------------------*/ <br> <br>static void  <br>align_notch( int newDir, int notch ) <br>{ <br>    GLfloat rotz; <br>    GLint curNotch; <br> <br>    // figure out where notch is presently after +z alignment <br>    curNotch = defCylNotch[newDir]; <br>    // (don't need this now we have lut) <br> <br>    // look up rotation value in table <br>    rotz = alignNotchRot[newDir][notch]; <br>#if PIPES_DEBUG <br>    if( rotz == fXX ) { <br>        printf( "align_notch(): unexpected value\n" ); <br>        return; <br>    } <br>#endif <br> <br>    if( rotz != 0.0f ) <br>        glRotatef( rotz, 0.0f, 0.0f, 1.0f ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
