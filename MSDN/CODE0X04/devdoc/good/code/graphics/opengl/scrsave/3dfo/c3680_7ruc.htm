<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENTEX.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3684"></a>GENTEX.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: gentex.c <br>* <br>* The Textured Flag style of the 3D Flying Objects screen saver. <br>* <br>* Texture maps .BMP files onto a simulation of a flag waving in the breeze. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;GL\glu.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br> <br>static float winTotalwidth = (float)0.75; <br>static float winTotalheight = (float)0.75 * (float)0.75; <br> <br>#define MAX_FRAMES 20 <br> <br>// IPREC is the number of faces in the mesh that models the flag. <br> <br>#define IPREC   15 <br> <br>static int Frames = 10; <br>static MESH winMesh[MAX_FRAMES]; <br>static float sinAngle = (float)0.0; <br>static float xTrans = (float)0.0; <br>static int curMatl = 0; <br> <br>// Material properties. <br> <br>static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f}; <br>static RGBA matlDimSpecular    = {0.5f, 0.5f, 0.5f, 1.0f}; <br>static RGBA matlNoSpecular     = {0.0f, 0.0f, 0.0f, 0.0f}; <br> <br>// Lighting properties. <br> <br>static GLfloat light0Pos[] = {20.0f, 5.0f, 20.0f, 0.0f}; <br>static GLfloat light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f}; <br>static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f}; <br>static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f}; <br>static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f}; <br> <br>static RGBA flagColors[] = {{1.0f, 1.0f, 1.0f, 1.0f}, <br>                            {0.94f, 0.37f, 0.13f, 1.0f},    // red <br>                           }; <br> <br>// Default texture resource <br> <br>TEX_RES gTexRes = { TEX_BMP, IDB_DEFTEX }; <br> <br>/******************************Public*Routine******************************\ <br>* iPtInList <br>* <br>* Add a vertex and its normal to the mesh.  If the vertex already exists, <br>* add in the normal to the existing normal (we to accumulate the average <br>* normal at each vertex).  Normalization of the normals is the <br>* responsibility of the caller. <br>* <br>\**************************************************************************/ <br> <br>static int iPtInList(MESH *mesh, int start,  <br>                     POINT3D *p, POINT3D *norm, BOOL blend) <br>{ <br>    int i; <br>    POINT3D *pts = mesh-&gt;pts + start; <br> <br>    if (blend) { <br>        for (i = start; i &lt; mesh-&gt;numPoints; i++, pts++) { <br>            if ((pts-&gt;x == p-&gt;x) &amp;&amp; (pts-&gt;y == p-&gt;y) &amp;&amp; (pts-&gt;z == p-&gt;z)) { <br>                mesh-&gt;norms[i].x += norm-&gt;x; <br>                mesh-&gt;norms[i].y += norm-&gt;y; <br>                mesh-&gt;norms[i].z += norm-&gt;z; <br>                return i; <br>            } <br>        } <br>    } else { <br>        i = mesh-&gt;numPoints; <br>    } <br> <br>    mesh-&gt;pts[i] = *p; <br>    mesh-&gt;norms[i] = *norm; <br>    mesh-&gt;numPoints++; <br>    return i; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* getZpos <br>* <br>* Get the z-position (depth) of the "wavy" flag component at the given x. <br>* <br>* The function used to model the wave is: <br>* <br>*        1/2 <br>*   z = x    * sin((2*PI*x + sinAngle) / 4) <br>* <br>* The shape of the wave varies from frame to frame by changing the <br>* phase, sinAngle. <br>* <br>\**************************************************************************/ <br> <br>float getZpos(float x) <br>{ <br>    float xAbs = x - xTrans; <br>    float angle = sinAngle + ((float) (2.0 * PI) * (xAbs / winTotalwidth)); <br> <br>    xAbs = winTotalwidth - xAbs; <br>//    xAbs += (winTotalwidth / 2.0); <br> <br>    return (float)((sin((double)angle) / 4.0) * <br>                   sqrt((double)(xAbs / winTotalwidth ))); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* genTex <br>* <br>* Generate a mesh representing a frame of the flag.  The phase, sinAngle, <br>* is a global variable. <br>* <br>\**************************************************************************/ <br> <br>void genTex(MESH *winMesh) <br>{ <br>    POINT3D pos; <br>    POINT3D pts[4]; <br>    float w, h; <br>    int i; <br> <br>    newMesh(winMesh, IPREC * IPREC, IPREC * IPREC); <br> <br>// Width and height of each face <br> <br>    w = (winTotalwidth) / (float)(IPREC + 1); <br>    h = winTotalheight; <br> <br>// Generate the mesh data.  At equally spaced intervals along the x-axis, <br>// we compute the z-position of the flag surface. <br> <br>    pos.y = (float) 0.0; <br>    pos.z = (float) 0.0; <br> <br>    for (i = 0, pos.x = xTrans; i &lt; IPREC; i++, pos.x += w) { <br>        int faceCount = winMesh-&gt;numFaces; <br> <br>        pts[0].x = (float)pos.x;  <br>        pts[0].y = (float)(pos.y);    <br>        pts[0].z = getZpos(pos.x); <br> <br>        pts[1].x = (float)pos.x; <br>        pts[1].y = (float)(pos.y + h);   <br>        pts[1].z = getZpos(pos.x); <br> <br>        pts[2].x = (float)(pos.x + w);   <br>        pts[2].y = (float)(pos.y);   <br>        pts[2].z = getZpos(pos.x + w); <br> <br>        pts[3].x = (float)(pos.x + w); <br>        pts[3].y = (float)(pos.y + h); <br>        pts[3].z = getZpos(pos.x + w); <br> <br>    // Compute the face normal. <br> <br>        ss_calcNorm(&amp;winMesh-&gt;faces[faceCount].norm, pts + 2, pts + 1, pts); <br> <br>    // Add the face to the mesh. <br> <br>        winMesh-&gt;faces[faceCount].material = 0; <br>        winMesh-&gt;faces[faceCount].p[0] = iPtInList(winMesh, 0, pts, <br>            &amp;winMesh-&gt;faces[faceCount].norm, TRUE); <br>        winMesh-&gt;faces[faceCount].p[1] = iPtInList(winMesh, 0, pts + 1, <br>            &amp;winMesh-&gt;faces[faceCount].norm, TRUE); <br>        winMesh-&gt;faces[faceCount].p[2] = iPtInList(winMesh, 0, pts + 2, <br>            &amp;winMesh-&gt;faces[faceCount].norm, TRUE); <br>        winMesh-&gt;faces[faceCount].p[3] = iPtInList(winMesh, 0, pts + 3, <br>            &amp;winMesh-&gt;faces[faceCount].norm, TRUE); <br> <br>        winMesh-&gt;numFaces++; <br>    } <br> <br>// Normalize the vertex normals in the mesh. <br> <br>    ss_normalizeNorms(winMesh-&gt;norms, winMesh-&gt;numPoints); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* initTexScene <br>* <br>* Initialize the screen saver. <br>* <br>* This function is exported to the main module in ss3dfo.c. <br>* <br>\**************************************************************************/ <br> <br>void initTexScene() <br>{ <br>    int i; <br>    float angleDelta; <br>    TEXTURE tex; <br>    float aspectRatio; <br> <br>    // Initialize the transform. <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-0.25, 1.0, -0.25, 1.0, 0.0, 3.0); <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br> <br>    // Initialize and turn on lighting. <br> <br>    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos); <br> <br>    glLightfv(GL_LIGHT1, GL_AMBIENT, (GLfloat *) &amp;light1Ambient); <br>    glLightfv(GL_LIGHT1, GL_DIFFUSE, (GLfloat *) &amp;light1Diffuse); <br>    glLightfv(GL_LIGHT1, GL_SPECULAR, (GLfloat *) &amp;light1Specular); <br>    glLightfv(GL_LIGHT1, GL_POSITION, light1Pos); <br>    glEnable(GL_LIGHT1); <br>    glDisable(GL_DEPTH_TEST); <br> <br>    // Leave OpenGL in a state ready to accept the model view transform (we <br>    // are going to have the flag vary its orientation from frame to frame). <br> <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    // Define orientation of polygon faces. <br> <br>    glFrontFace(GL_CW); <br>    //    glEnable(GL_CULL_FACE); <br> <br>    Frames = (int)((float)(MAX_FRAMES / 2) * fTesselFact); <br> <br>    // Load user texture - if that fails load default texture resource <br> <br>    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br>    if( ss_LoadTextureFile( &amp;gTexFile, &amp;tex ) || <br>        ss_LoadTextureResource( &amp;gTexRes, &amp;tex) ) <br>    { <br>        glEnable(GL_TEXTURE_2D); <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); <br>        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); <br> <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <br> <br>        ss_SetTexture( &amp;tex ); <br> <br>    // Correct aspect ratio of flag to match image. <br>    // <br>    // The 1.4 is a correction factor to account for the length of the <br>    // curve that models the surface ripple of the waving flag.  This <br>    // factor is the length of the curve at zero phase.  It would be <br>    // more accurate to determine the length of the curve at each phase, <br>    // but this is a sufficient approximation for our purposes. <br> <br>        aspectRatio = ((float) tex.height / (float) tex.width) <br>                      * (float) 1.4; <br> <br>        if (aspectRatio &lt; (float) 1.0) { <br>            winTotalwidth  = (float)0.75; <br>            winTotalheight = winTotalwidth * aspectRatio; <br>        } else { <br>            winTotalheight = (float) 0.75; <br>            winTotalwidth  = winTotalheight / aspectRatio; <br>        }; <br>    } <br> <br>    if (Frames &lt; 5) <br>        Frames = 5; <br>    if (Frames &gt; MAX_FRAMES) <br>        Frames = MAX_FRAMES; <br> <br>    // Generate the geometry data (stored in the array of mesh structures), <br>    // for each frame of the animation.  The shape of the flag is varied by <br>    // changing the global variable sinAngle. <br> <br>    angleDelta = (float)(2.0 * PI) / (float)Frames; <br>    sinAngle = (float) 0.0; <br> <br>    for (i = 0; i &lt; Frames; i++) { <br>        genTex(&amp;winMesh[i]); <br>        sinAngle += angleDelta; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* delTexScene <br>* <br>* Cleanup the data associated with this screen saver. <br>* <br>* This function is exported to the main module in ss3dfo.c. <br>* <br>\**************************************************************************/ <br> <br>void delTexScene() <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; Frames; i++) <br>        delMesh(&amp;winMesh[i]); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* updateTexScene <br>* <br>* Generate a scene by taking one of the meshes and rendering it with <br>* OpenGL. <br>* <br>* This function is exported to the main module in ss3dfo.c. <br>* <br>\**************************************************************************/ <br> <br>void updateTexScene(int flags) <br>{ <br>    MESH *mesh; <br>    MFACE *faces; <br>    int i; <br>    static double mxrot = 23.0; <br>    static double myrot = 23.0; <br>    static double mzrot = 5.7; <br>    static double mxrotInc = 0.0; <br>    static double myrotInc = 3.0; <br>    static double mzrotInc = 0.0; <br>    static int h = 0; <br>    static int frameNum = 0; <br>    POINT3D *pp; <br>    POINT3D *pn; <br>    int lastC, lastD; <br>    int aOffs, bOffs, cOffs, dOffs; <br>    int a, b; <br>    GLfloat s = (GLfloat) 0.0; <br>    GLfloat ds; <br> <br>// In addition to having the flag wave (an effect acheived by switching <br>// meshes from frame to frame), the flag changes its orientation from <br>// frame to frame.  This is done by applying a model view transform. <br> <br>    glLoadIdentity(); <br>    glRotatef((float)mxrot, 1.0f, 0.0f, 0.0f); <br>    glRotatef((float)myrot, 0.0f, 1.0f, 0.0f); <br>    glRotatef((float)mzrot, 0.0f, 0.0f, 1.0f); <br>     <br>// Divide the texture into IPREC slices.  ds is the texture coordinate <br>// delta we apply as we move along the x-axis. <br> <br>    ds = (GLfloat)1.0 / (GLfloat)IPREC; <br> <br>// Setup the material property of the flag.  The material property, light <br>// properties, and polygon orientation will interact with the texture. <br> <br>    curMatl = 0; <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &amp;flagColors[0]); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (GLfloat *) &amp;matlBrightSpecular); <br>    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, (float) 60.0); <br> <br>// Pick the mesh for the current frame. <br> <br>    mesh = &amp;winMesh[frameNum]; <br> <br>// Take the geometry data is the mesh and convert it to a single OpenGL <br>// quad strip.  If smooth shading is required, use the vertex normals stored <br>// in the mesh.  Otherwise, use the face normals. <br>// <br>// As we define each vertex, we also define a corresponding vertex and <br>// texture coordinate. <br> <br>    glBegin(GL_QUAD_STRIP); <br> <br>    pp = mesh-&gt;pts; <br>    pn = mesh-&gt;norms; <br> <br>    for (i = 0, faces = mesh-&gt;faces, lastC = faces-&gt;p[0], lastD = faces-&gt;p[1]; <br>         i &lt; mesh-&gt;numFaces; i++, faces++) { <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br> <br>        if (!bSmoothShading) { <br>            // Since flag is a single quad strip, this isn't needed. <br>            // But lets keep it in case we ever change to a more <br>            // complex model (ie., one that uses more than one quad <br>            // strip). <br>            #if 0 <br>            if ((a != lastC) || (b != lastD)) { <br>                glNormal3fv((GLfloat *)&amp;(faces - 1)-&gt;norm); <br> <br>                glTexCoord2f(s, (float) 0.0); <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>                glTexCoord2f(s, (float) 1.0); <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>                s += ds; <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br>            #endif <br> <br>            if (faces-&gt;material != curMatl) { <br>                curMatl = faces-&gt;material; <br>                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, <br>                             (GLfloat *) &amp;matlNoSpecular); <br>                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE,  <br>                             (GLfloat *) &amp;flagColors[curMatl]); <br>            } <br> <br>            glNormal3fv((GLfloat *)&amp;faces-&gt;norm); <br>            glTexCoord2f(s, (float) 0.0); <br>            glVertex3fv((GLfloat *)((char *)pp + (a &lt;&lt; 3) + (a &lt;&lt; 2))); <br>            glTexCoord2f(s, (float) 1.0); <br>            glVertex3fv((GLfloat *)((char *)pp + (b &lt;&lt; 3) + (b &lt;&lt; 2))); <br>            s += ds; <br>        } else { <br>            // Since flag is a single quad strip, this isn't needed. <br>            // But lets keep it in case we ever change to a more <br>            // complex model (ie., one that uses more than one quad <br>            // strip). <br>            #if 0 <br>            if ((a != lastC) || (b != lastD)) { <br>                cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>                dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>                glTexCoord2f(s, (float) 0.0); <br>                glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>                glTexCoord2f(s, (float) 1.0); <br>                glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>                s += ds; <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br>            #endif <br> <br>            aOffs = (a &lt;&lt; 3) + (a &lt;&lt; 2); <br>            bOffs = (b &lt;&lt; 3) + (b &lt;&lt; 2); <br> <br>            if (faces-&gt;material != curMatl) { <br>                curMatl = faces-&gt;material; <br>                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, <br>                             (GLfloat *) &amp;matlNoSpecular); <br>                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE,  <br>                             (GLfloat *) &amp;flagColors[curMatl]); <br>            } <br> <br>            glTexCoord2f(s, (float) 0.0); <br>            glNormal3fv((GLfloat *)((char *)pn + aOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + aOffs)); <br>            glTexCoord2f(s, (float) 1.0); <br>            glNormal3fv((GLfloat *)((char *)pn + bOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + bOffs)); <br>            s += ds; <br>        } <br> <br>        lastC = faces-&gt;p[2]; <br>        lastD = faces-&gt;p[3]; <br>    } <br> <br>    if (!bSmoothShading) { <br>        glNormal3fv((GLfloat *)&amp;(faces - 1)-&gt;norm); <br>        glTexCoord2f(s, (float) 0.0); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>        glTexCoord2f(s, (float) 1.0); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>    } else { <br>        cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>        dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>        glTexCoord2f(s, (float) 0.0); <br>        glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>        glTexCoord2f(s, (float) 1.0); <br>        glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>    } <br> <br>    glEnd(); <br> <br>// Transfer the image to the floating OpenGL window. <br> <br>// Determine the flag orientation for the next frame. <br>// What we are doing is an oscillating rotation about the y-axis <br>// (mxrotInc and mzrotInc are currently 0). <br> <br>    mxrot += mxrotInc; <br>    myrot += myrotInc; <br>    mzrot += mzrotInc; <br> <br>    if ((myrot &lt; -65.0) || (myrot &gt; 25.0)) <br>        myrotInc = -myrotInc; <br> <br>    frameNum++; <br>    if (frameNum &gt;= Frames) <br>        frameNum = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
