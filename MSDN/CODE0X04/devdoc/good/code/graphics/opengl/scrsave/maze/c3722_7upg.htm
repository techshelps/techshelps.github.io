<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENMAZE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3724"></a>GENMAZE.C</h2>
<pre><code>#include "pch.c" <br>#pragma hdrstop <br> <br>/* <br>  Maze generation based on Kruskal's algorithm <br>   <br>  Consider all possible paths as sets of connected cells.  Initially <br>  all cells are unconnected and all walls are present.  Pick a wall <br>  at random and determine if the cells on either side of the wall are <br>  connected by any possible path.  If they are, try again.  If not, <br>  knock out the wall and union the two path sets together. <br>  */ <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#include "genmaze.h" <br> <br>typedef struct _MazeCell <br>{ <br>    /* Pointer to the head of the set of cells reachable from this one. <br>       Easily identifies an entire set for comparison */ <br>    struct _MazeCell *set; <br>    /* Pointer to the next cell in this connected set */ <br>    struct _MazeCell *next; <br>} MazeCell; <br> <br>typedef struct _MazeWall <br>{ <br>    BYTE wall; <br>    int x, y; <br>} MazeWall; <br> <br>/* <br>  Union two connection sets together by setting all elements in one <br>  to the set of the other and then appending it to the end of the <br>  set list <br>  */ <br>static void ConnectSets(MazeCell *set, MazeCell *add) <br>{ <br>    /* Locate end of set */ <br>    while (set-&gt;next != NULL) <br>    { <br>        set = set-&gt;next; <br>    } <br> <br>    /* Change to point to head of set */ <br>    add = add-&gt;set; <br>     <br>    /* Append new cells */ <br>    set-&gt;next = add; <br> <br>    /* Change new cells' set identity */ <br>    while (add != NULL) <br>    { <br>        add-&gt;set = set-&gt;set; <br>        add = add-&gt;next; <br>    } <br>} <br> <br>/* <br>  Determine whether the two cells are already connected.  With the <br>  existing data structures this is a trivial comparison of set <br>  identities <br>  */ <br>#define SetsAreConnected(a, b) \ <br>    ((a)-&gt;set == (b)-&gt;set) <br> <br>/* Locate a cell in a known array */ <br>#define CellAt(x, y) (cells+(x)+(y)*width) <br> <br>/* Locate a cell in the output array */ <br>#define MazeAt(x, y) (maze+(x)+(y)*(width+1)) <br> <br>/* <br>  Generate a maze by deleting walls at random <br>  Width and height are the counts of cells <br> <br>  Result is stored in the walls array, formatted as (width+1)*(height+1) <br>  cells with MAZE_WALL_HORZ | MAZE_WALL_VERT set appropriately. <br>  X coordinates are one byte apart, so maze is treated like <br>  maze[height+1][width+1] <br>  */ <br>BOOL GenerateMaze(int width, int height, BYTE *maze) <br>{ <br>    MazeCell *cells; <br>    MazeWall *walls; <br>    int ncells; <br>    int nwalls; <br>    int i, x, y; <br>    MazeCell *ca, *cb; <br>    MazeWall *w, wt; <br> <br>    ncells = width*height; <br>    cells = (MazeCell *)malloc(sizeof(MazeCell)*ncells); <br>    if (cells == NULL) <br>    { <br>        return FALSE; <br>    } <br> <br>    nwalls = (width-1)*height+(height-1)*width; <br>    walls = (MazeWall *)malloc(sizeof(MazeWall)*nwalls); <br>    if (walls == NULL) <br>    { <br>        free(cells); <br>        return FALSE; <br>    } <br> <br>    /* Initialize all cells to be unique sets */ <br>    ca = cells; <br>    for (i = 0; i &lt; ncells; i++) <br>    { <br>        ca-&gt;set = ca; <br>        ca-&gt;next = NULL; <br>        ca++; <br>    } <br> <br>    /* Add all internal horizontal and vertical walls. <br>       All edge walls will be present in the final maze so <br>       they aren't considered here */ <br>    w = walls; <br>    for (x = 1; x &lt; width; x++) <br>    { <br>        for (y = 0; y &lt; height; y++) <br>        { <br>            w-&gt;wall = MAZE_WALL_VERT; <br>            w-&gt;x = x; <br>            w-&gt;y = y; <br>            w++; <br>        } <br>    } <br>    for (y = 1; y &lt; height; y++) <br>    { <br>        for (x = 0; x &lt; width; x++) <br>        { <br>            w-&gt;wall = MAZE_WALL_HORZ; <br>            w-&gt;x = x; <br>            w-&gt;y = y; <br>            w++; <br>        } <br>    } <br> <br>    /* Randomize the wall array */ <br>    for (i = nwalls-1; i &gt; 0; i--) <br>    { <br>        w = walls+(rand() % i); <br>        wt = *w; <br>        *w = walls[i]; <br>        walls[i] = wt; <br>    } <br> <br>    /* Now walk the random list of walls, knocking walls out to <br>       join cells together */ <br>    w = walls; <br>    for (i = 0; i &lt; nwalls; i++) <br>    { <br>        /* Determine the two cells separated by the current wall */ <br>        ca = CellAt(w-&gt;x, w-&gt;y); <br>        if (w-&gt;wall == MAZE_WALL_HORZ) <br>        { <br>            cb = CellAt(w-&gt;x, w-&gt;y-1); <br>        } <br>        else <br>        { <br>            cb = CellAt(w-&gt;x-1, w-&gt;y); <br>        } <br> <br>        /* If the two cells aren't connected, connect them by knocking <br>           out the wall */ <br>        if (!SetsAreConnected(ca, cb)) <br>        { <br>            ConnectSets(ca, cb); <br>            w-&gt;wall = 0; <br>        } <br>         <br>        w++; <br>    } <br> <br>    /* Initialize output to empty */ <br>    memset(maze, 0, sizeof(BYTE)*(width+1)*(height+1)); <br>     <br>    /* Set all edge walls in the output */ <br>    for (x = 0; x &lt; width; x++) <br>    { <br>        *MazeAt(x, 0) |= MAZE_WALL_HORZ; <br>        *MazeAt(x, height) |= MAZE_WALL_HORZ; <br>    } <br>    for (y = 0; y &lt; height; y++) <br>    { <br>        *MazeAt(0, y) |= MAZE_WALL_VERT; <br>        *MazeAt(width, y) |= MAZE_WALL_VERT; <br>    } <br> <br>    /* Copy remaining walls into the output array */ <br>    w = walls; <br>    for (i = 0; i &lt; nwalls; i++) <br>    { <br>        *MazeAt(w-&gt;x, w-&gt;y) |= w-&gt;wall; <br>        w++; <br>    } <br> <br>    free(cells); <br>    free(walls); <br>     <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
