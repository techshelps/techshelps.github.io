<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3764"></a>FONT.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: font.c <br>* <br>* Font and text handling for the OpenGL-based 3D Text screen saver. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;float.h&gt; // for FLT_MAX <br>#include &lt;GL/gl.h&gt; <br>#include "sscommon.h" <br>#include "sstext3d.h" <br> <br>#ifndef UNICODE <br>// Support dbcs characters (this is a patch) <br>#define SS_DBCS_SUPPORT 1 <br>#endif <br> <br>static LISTENTRY* FindExtendedLUTEntry( TCHAR c, WglFontContext *pwfc ); <br>static BOOL UpdateReducedFontList( TCHAR c, LISTENTRY *ple,  <br>                                   WglFontContext *pwfc ); <br>#ifdef SS_DBCS_SUPPORT <br>static BOOL UpdateReducedFontListDBCS( DWORD c, LISTENTRY *ple,  <br>                                       WglFontContext *pwfc ); <br>#endif <br>static void DeleteExtendedLUTTableEntries( WglFontContext *pwfc ); <br>static void DeleteDirectLUTTableEntries( WglFontContext *pwfc ); <br>static void DeleteLUTEntry( LISTENTRY *ple ); <br> <br>/******************************Public*Routine******************************\ <br>* CreateWglFontContext <br>* <br>* Create a WglFontContext. <br>* <br>* Initializes the look-up-table memory for characters. <br>* The first half of this table is a direct look-up, using the char value. <br>* The second half is used for unicode chars that are &gt;256, and must be <br>* searched sequentially. <br>* <br>\**************************************************************************/ <br> <br>WglFontContext * <br>CreateWglFontContext( HDC hdc, int type, float fExtrusion,  <br>                      float fChordalDeviation ) <br>{ <br>    WglFontContext *pwfc; <br> <br>    pwfc = (WglFontContext *) LocalAlloc( LMEM_FIXED, sizeof(WglFontContext) ); <br>    if( !pwfc ) { <br>        SS_ALLOC_FAILURE( "CreateWglFontContext" ); <br>        return NULL; <br>    } <br> <br>    pwfc-&gt;hdc = hdc; <br>    pwfc-&gt;type = type; <br>    pwfc-&gt;extrusion = fExtrusion; <br>    pwfc-&gt;chordalDeviation = fChordalDeviation; <br> <br>    pwfc-&gt;listLUT = (LISTENTRY*) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,  <br>                                      SIZE_LIST_LUT * sizeof(LISTENTRY) ); <br> <br>    if( !pwfc-&gt;listLUT ) { <br>        LocalFree( pwfc ); <br>        SS_ALLOC_FAILURE( "CreateWglFontContext" ); <br>        return NULL; <br>    } <br> <br>    pwfc-&gt;LUTIndex = 0; <br> <br>    return pwfc; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DeleteWglFontContext <br>* <br>* Delete a WglFontContext. <br>* <br>\**************************************************************************/ <br> <br>void <br>DeleteWglFontContext( WglFontContext *pwfc ) <br>{ <br>    if( !pwfc ) <br>        return; <br> <br>    // Delete the extended lut table entries <br>    DeleteExtendedLUTTableEntries( pwfc ); <br> <br>    // Delete the direct lut table entries <br>    DeleteDirectLUTTableEntries( pwfc ); <br>     <br>    if( pwfc-&gt;listLUT ) <br>        LocalFree( pwfc-&gt;listLUT ); <br> <br>    LocalFree( pwfc ); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* DeleteExtendedLUTTablEntries <br>* <br>\**************************************************************************/ <br> <br>static void <br>DeleteExtendedLUTTableEntries( WglFontContext *pwfc ) <br>{ <br>    int i; <br>    LISTENTRY *ple = pwfc-&gt;listLUT + MAX_DIRECT_LUT; <br> <br>    for( i = 0; i &lt; pwfc-&gt;LUTIndex; i ++, ple++ ) <br>        DeleteLUTEntry( ple ); <br> <br>    pwfc-&gt;LUTIndex = 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DeleteDirectLUTTablEntries <br>* <br>\**************************************************************************/ <br> <br>static void <br>DeleteDirectLUTTableEntries( WglFontContext *pwfc ) <br>{ <br>    int i; <br>    LISTENTRY *ple = pwfc-&gt;listLUT; <br> <br>    for( i = 0; i &lt; MAX_DIRECT_LUT; i ++, ple++ ) <br>        DeleteLUTEntry( ple ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DeleteLUTEntry <br>* <br>\**************************************************************************/ <br> <br>static void <br>DeleteLUTEntry( LISTENTRY *ple ) <br>{ <br>    if( ple-&gt;listNum ) { <br>        glDeleteLists( ple-&gt;listNum, 1 ); <br>        ple-&gt;listNum = 0; <br>    } <br>    if( ple-&gt;lpgmf ) { <br>        LocalFree( ple-&gt;lpgmf ); <br>        ple-&gt;lpgmf = NULL; <br>    } <br>    ple-&gt;glyph = 0; <br>} <br> <br>/**************************************************************************\ <br>* ConvertStringToList <br>* <br>* - Translate the string into display list numbers <br>* - If no entry in the list table, update the table <br>* <br>\**************************************************************************/ <br>void <br>ConvertStringToList( LPTSTR pszSrc, USHORT *usDst, WglFontContext *pwfc ) <br>{ <br>    int strLen; <br>    LISTENTRY *ple; <br>    TCHAR c; <br>    TUCHAR cindex; // use unsigned TCHAR for table indexing <br>#ifdef SS_DBCS_SUPPORT <br>    BOOL bIsLeadByte; <br>#endif <br> <br>    if( !pwfc ) <br>        return; <br> <br>    /* Go thru the string, making sure every char has a display list <br>     * Copy the display list # into usDst <br>     */ <br> <br>    strLen = lstrlen( pszSrc ); <br>    if( strLen &gt; TEXT_BUF_SIZE ) <br>        strLen = TEXT_BUF_SIZE; <br> <br>    /* Check for possible overflow with the extended LUT section, and <br>     * invalidate the extended LUT if so <br>     */ <br>    if( pwfc-&gt;LUTIndex ) { <br>        int roomLeft; // spaces left in extended lut table <br> <br>        roomLeft = SIZE_LIST_LUT - (pwfc-&gt;LUTIndex + MAX_DIRECT_LUT +1); <br>        if( roomLeft &lt; strLen ) { <br>            /* If none of the characters in this string have entries in the <br>             * table, we'll run out of room.  Assume the worst, invalidate <br>             * the whole table, and start over again. <br>             */ <br>            DeleteExtendedLUTTableEntries( pwfc ); <br>        } <br>    } <br> <br>    for( ; strLen; strLen--, pszSrc++ ) { <br>        c = *pszSrc; <br>        cindex = (TUCHAR) c; <br> <br>        // see if char already has cmd list entry - if not, create it <br>#ifdef SS_DBCS_SUPPORT <br>        bIsLeadByte = IsDBCSLeadByte(cindex); <br>        if( !bIsLeadByte &amp;&amp; (cindex &lt; MAX_DIRECT_LUT) ) {  // direct LUT <br>#else <br>        if( cindex &lt; MAX_DIRECT_LUT ) {  // direct LUT entry <br>#endif <br>            ple = &amp;pwfc-&gt;listLUT[cindex]; <br>            if( !ple-&gt;listNum ) { <br>                // have to create new cmd list for this glyph <br>                if( ! UpdateReducedFontList( c, ple, pwfc ) ) { <br>                    DeleteLUTEntry( ple ); <br>                    continue; <br>                } <br>            } <br>        } else {  // extended LUT entry <br>#ifdef SS_DBCS_SUPPORT <br>            DWORD dwChar; <br>            if( bIsLeadByte ) { <br>                // Iterate over the lead byte <br>                pszSrc++; <br>                strLen--; <br>                c = *pszSrc; <br>                // Setup the double byte word so that : <br>                //   High byte is the lead byte <br>                //   Low byte is the next byte in the byte stream (this byte <br>                //   will be used to access the extended lut table) <br>                dwChar = (DWORD) ( (cindex &lt;&lt; 8) | ((TUCHAR) c)  ); <br>            } else <br>                dwChar = (DWORD) (TUCHAR) c; <br> <br>            if( !(ple = FindExtendedLUTEntry( c, pwfc )) ) { <br>                ple = &amp;pwfc-&gt;listLUT[pwfc-&gt;LUTIndex+MAX_DIRECT_LUT]; <br>                if( ! UpdateReducedFontListDBCS( dwChar, ple, pwfc ) ) { <br>                    DeleteLUTEntry( ple ); <br>                    continue; <br>                } <br>                ple-&gt;glyph = c; <br>                pwfc-&gt;LUTIndex++; <br>            } <br>#else <br>            if( !(ple = FindExtendedLUTEntry( c, pwfc )) ) { <br>                ple = &amp;pwfc-&gt;listLUT[pwfc-&gt;LUTIndex+MAX_DIRECT_LUT]; <br>                if( ! UpdateReducedFontList( c, ple, pwfc ) ) { <br>                    DeleteLUTEntry( ple ); <br>                    continue; <br>                } <br>                ple-&gt;glyph = c; <br>                pwfc-&gt;LUTIndex++; <br>            } <br>#endif <br>        } <br>        *usDst++ = ple-&gt;listNum; <br>    } <br>    // zero terminate <br>    *usDst = 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* UpdateReducedFontList <br>* <br>* Calls wglUseFontOutlines() to create a command list for the supplied <br>* character. <br>* <br>* Allocates memory for the characters glyphmetrics as well <br>* <br>\**************************************************************************/ <br>static BOOL  <br>UpdateReducedFontList( TCHAR c, LISTENTRY *ple, WglFontContext *pwfc ) <br>{ <br>    ple-&gt;lpgmf = (LPGLYPHMETRICSFLOAT) LocalAlloc( LMEM_FIXED, <br>                                                sizeof( GLYPHMETRICSFLOAT ) ); <br> <br>    if( !ple-&gt;lpgmf ) { <br>        SS_ALLOC_FAILURE( "UpdateReducedFontList" ); <br>        return FAILURE; <br>    } <br> <br>    // get next list # for this glyph. <br>    ple-&gt;listNum = (USHORT) glGenLists( 1 ); <br>    if( !ple-&gt;listNum ) { <br>        SS_WARNING( "glGenLists failed\n" ); <br>        return FAILURE; <br>    } <br> <br>    if( !wglUseFontOutlines(pwfc-&gt;hdc, (TUCHAR) c, 1, ple-&gt;listNum,  <br>               pwfc-&gt;chordalDeviation,  <br>               pwfc-&gt;extrusion,  <br>               pwfc-&gt;type, ple-&gt;lpgmf) ) { <br>        SS_WARNING( "wglUseFontOutlines failed\n" ); <br>        return FAILURE; <br>    } <br>    return SUCCESS; <br>} <br> <br>#ifdef SS_DBCS_SUPPORT <br> <br>// Modified version of UpdateReducedFontList that handles dbcs characters. <br>// This is a *patch* (as is all the SS_DBCS_SUPPORT stuff) to handle dbcs <br>// characters without jeopardizing SUR release stability.  Later, the functions <br>// can be consolidated. <br> <br>static BOOL  <br>UpdateReducedFontListDBCS( DWORD c, LISTENTRY *ple, WglFontContext *pwfc ) <br>{ <br>    ple-&gt;lpgmf = (LPGLYPHMETRICSFLOAT) LocalAlloc( LMEM_FIXED, <br>                                                sizeof( GLYPHMETRICSFLOAT ) ); <br> <br>    if( !ple-&gt;lpgmf ) { <br>        SS_ALLOC_FAILURE( "UpdateReducedFontList" ); <br>        return FAILURE; <br>    } <br> <br>    // get next list # for this glyph. <br>    ple-&gt;listNum = (USHORT) glGenLists( 1 ); <br>    if( !ple-&gt;listNum ) { <br>        SS_WARNING( "glGenLists failed\n" ); <br>        return FAILURE; <br>    } <br> <br>    if( !wglUseFontOutlines(pwfc-&gt;hdc, c, 1, ple-&gt;listNum,  <br>               pwfc-&gt;chordalDeviation,  <br>               pwfc-&gt;extrusion,  <br>               pwfc-&gt;type, ple-&gt;lpgmf) ) { <br>        SS_WARNING( "wglUseFontOutlines failed\n" ); <br>        return FAILURE; <br>    } <br>    return SUCCESS; <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* FindExtendedLUTEntry <br>* <br>* Searches through the extended character LUT, and returns ptr to the <br>* char's info if found, otherwise NULL. <br>* <br>\**************************************************************************/ <br> <br>static LISTENTRY* <br>FindExtendedLUTEntry( TCHAR c, WglFontContext *pwfc ) <br>{ <br>    int i; <br>    LISTENTRY *ple = pwfc-&gt;listLUT + MAX_DIRECT_LUT; <br> <br>    for( i = 0; i &lt; pwfc-&gt;LUTIndex; i ++, ple++ ) { <br>        if( ple-&gt;glyph == c ) <br>            return ple; <br>    } <br>    return NULL; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DrawString <br>* <br>* Draws string by calling cmd list for each char. <br>* <br>\**************************************************************************/ <br> <br>void <br>DrawString(  USHORT           *string, <br>             int              strLen, <br>             WglFontContext   *pwfc ) <br>{ <br>    if( !pwfc ) <br>        return; <br> <br>    glCallLists(strLen, GL_UNSIGNED_SHORT, (GLushort *) string); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* GetStringExtent <br>* <br>* Calculate a string's origin and extent in world coordinates.   <br>*  <br>* The origin is determined by the first character's location, and thereafter  <br>* each char's location is determined by adding the previous char's cellInc  <br>* values. <br>*  <br>* This will work for all string orientations. <br>* <br>\**************************************************************************/ <br> <br>int  <br>GetStringExtent(  LPTSTR          szString,  <br>                  POINTFLOAT      *extent, <br>                  POINTFLOAT      *origin, <br>                  WglFontContext  *pwfc ) <br>{ <br> <br>    int len, strLen; <br>    TCHAR *c; <br>    TUCHAR cindex; <br>    LPGLYPHMETRICSFLOAT lpgmf; <br>    POINTFLOAT cellOrigin = {0.0f, 0.0f}; <br>    POINTFLOAT extentOrigin = {FLT_MAX, -FLT_MAX}; <br>    POINTFLOAT extentLowerRight = {-FLT_MAX, FLT_MAX}; <br>    POINTFLOAT boxOrigin, boxLowerRight; <br>    LISTENTRY *listLUT, *ple; <br>#ifdef SS_DBCS_SUPPORT <br>    BOOL bIsLeadByte; <br>#endif <br> <br>    if( !pwfc ) <br>        return 0; <br> <br>    listLUT = pwfc-&gt;listLUT; <br> <br>    extent-&gt;x = extent-&gt;y = 0.0f; <br>    origin-&gt;x = origin-&gt;y = 0.0f; <br>    len = strLen = lstrlen( szString ); <br>    if( !len ) <br>        return 0;  // otherwise extents will be calc'd erroneously <br> <br>    c = szString; <br> <br>    for( ; strLen; strLen--, c++ ) { <br>        cindex = (TUCHAR) *c; <br>#ifdef SS_DBCS_SUPPORT <br>        if( bIsLeadByte = IsDBCSLeadByte(cindex) ) { <br>            // iterate over lead byte <br>            c++; <br>            strLen--; <br>            cindex = (TUCHAR) *c; <br>        } <br>        if( !bIsLeadByte &amp;&amp; (cindex &lt; MAX_DIRECT_LUT) ) <br>#else <br>        if( cindex &lt; MAX_DIRECT_LUT ) <br>#endif <br>            ple = &amp;listLUT[cindex]; <br>        else <br>            ple = FindExtendedLUTEntry( *c, pwfc ); <br> <br>        lpgmf = ple-&gt;lpgmf; <br> <br>        if( !lpgmf ) <br>            // Memory must be running low, but keep going <br>            continue; <br> <br>        // calc global position of this char's BlackBox (this is  <br>        //  'upper left') <br>        boxOrigin.x = cellOrigin.x + lpgmf-&gt;gmfptGlyphOrigin.x; <br>        boxOrigin.y = cellOrigin.y + lpgmf-&gt;gmfptGlyphOrigin.y; <br> <br>        // calc lower right position <br>        boxLowerRight.x = boxOrigin.x + lpgmf-&gt;gmfBlackBoxX; <br>        boxLowerRight.y = boxOrigin.y - lpgmf-&gt;gmfBlackBoxY; <br> <br>        // compare against the current bounding box <br> <br>        if( boxOrigin.x &lt; extentOrigin.x ) <br>            extentOrigin.x = boxOrigin.x; <br>        if( boxOrigin.y &gt; extentOrigin.y ) <br>            extentOrigin.y = boxOrigin.y; <br>        if( boxLowerRight.x &gt; extentLowerRight.x ) <br>            extentLowerRight.x = boxLowerRight.x; <br>        if( boxLowerRight.y &lt; extentLowerRight.y ) <br>            extentLowerRight.y = boxLowerRight.y; <br> <br>        // set global position of next cell <br>        cellOrigin.x = cellOrigin.x + lpgmf-&gt;gmfCellIncX; <br>        cellOrigin.y = cellOrigin.y + lpgmf-&gt;gmfCellIncY; <br>    } <br> <br>    // Check for possible total lack of glyphmetric info <br>    if( extentOrigin.x == FLT_MAX ) { <br>        // Can assume if this value is still maxed out that all glyphmetric <br>        // info was NULL <br>        origin-&gt;x = origin-&gt;y = 0.0f; <br>        extent-&gt;x = extent-&gt;y = 0.0f; <br>        return 0; <br>    } <br> <br>    *origin = extentOrigin; <br>    extent-&gt;x = extentLowerRight.x - extentOrigin.x; <br>    extent-&gt;y = extentOrigin.y - extentLowerRight.y; <br>    return len; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
