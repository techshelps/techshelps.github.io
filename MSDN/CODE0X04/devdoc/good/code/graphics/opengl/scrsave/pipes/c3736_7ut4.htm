<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NSTATE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3748"></a>NSTATE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: nstate.cxx <br>* <br>* NORMAL_STATE <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "sspipes.h" <br>#include "nstate.h" <br>#include "objects.h" <br>#include "dialog.h" <br> <br>/******************************Public*Routine******************************\ <br>* NORMAL_STATE constructor <br>* <br>\**************************************************************************/ <br> <br>NORMAL_STATE::NORMAL_STATE( STATE *pState ) <br>{ <br>    // init joint types from dialog settings <br> <br>    bCycleJointStyles = 0; <br> <br>    switch( ulJointType ) { <br>        case JOINT_ELBOW: <br>            jointStyle = ELBOWS; <br>            break; <br>        case JOINT_BALL: <br>            jointStyle = BALLS; <br>            break; <br>        case JOINT_MIXED: <br>            jointStyle = EITHER; <br>            break; <br>        case JOINT_CYCLE: <br>            bCycleJointStyles = 1; <br>            jointStyle = EITHER; <br>            break; <br>        default: <br>            break; <br>    } <br> <br>    // Build the objects <br> <br>    BuildObjects( pState-&gt;radius, pState-&gt;view.divSize, pState-&gt;nSlices, <br>                  pState-&gt;bTexture, &amp;pState-&gt;texRep[0] ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* NORMAL_STATE destructor <br>* <br>* Some of the objects are always created, so don't have to check if they <br>* exist. Others may be NULL. <br>\**************************************************************************/ <br> <br>NORMAL_STATE::~NORMAL_STATE( ) <br>{ <br>    delete shortPipe; <br>    delete longPipe; <br>    delete ballCap; <br> <br>    for( int i = 0; i &lt; 4; i ++ ) { <br>        delete elbows[i]; <br>        if( ballJoints[i] ) <br>            delete ballJoints[i]; <br>    } <br> <br>    if( bigBall ) <br>        delete bigBall; <br>} <br> <br> <br> <br>/**************************************************************************\ <br>* BuildObjects <br>* <br>* - Build all the pipe primitives <br>* - Different prims are built based on bTexture flag <br>* <br>\**************************************************************************/ <br>void  <br>NORMAL_STATE::BuildObjects( float radius, float divSize, int nSlices,  <br>                            BOOL bTexture, IPOINT2D *texRep ) <br>{ <br>    OBJECT_BUILD_INFO *pBuildInfo = new OBJECT_BUILD_INFO; <br>    pBuildInfo-&gt;radius = radius; <br>    pBuildInfo-&gt;divSize = divSize; <br>    pBuildInfo-&gt;nSlices = nSlices; <br>    pBuildInfo-&gt;bTexture = bTexture; <br> <br>    if( bTexture ) { <br>        pBuildInfo-&gt;texRep = texRep; <br>         <br>        // Calc s texture intersection values <br>        float s_max = (float) texRep-&gt;y; <br>        float s_trans =  s_max * 2.0f * radius / divSize; <br> <br>        // Build short and long pipes <br>        shortPipe = new PIPE_OBJECT( pBuildInfo, divSize - 2*radius, <br>                                     s_trans, s_max ); <br>        longPipe = new PIPE_OBJECT( pBuildInfo, divSize, 0.0f, s_max ); <br> <br>        // Build elbow and ball joints <br>        for( int i = 0; i &lt; 4; i ++ ) { <br>            elbows[i] = new ELBOW_OBJECT( pBuildInfo, i, 0.0f, s_trans ); <br>            ballJoints[i] = new BALLJOINT_OBJECT( pBuildInfo, i, 0.0f, s_trans ); <br>        } <br> <br>        bigBall = NULL; <br> <br>        // Build end cap <br> <br>        float s_start = - texRep-&gt;x * (ROOT_TWO - 1.0f) * radius / divSize; <br>        float s_end = texRep-&gt;x * (2.0f + (ROOT_TWO - 1.0f)) * radius / divSize; <br>        // calc compensation value, to prevent negative s coords <br>        float comp_s = (int) ( - s_start ) + 1.0f; <br>        s_start += comp_s; <br>        s_end += comp_s; <br>        ballCap = new SPHERE_OBJECT( pBuildInfo, ROOT_TWO*radius, s_start, s_end ); <br> <br>    } else { <br>        // Build pipes, elbows <br>        shortPipe = new PIPE_OBJECT( pBuildInfo, divSize - 2*radius ); <br>        longPipe = new PIPE_OBJECT( pBuildInfo, divSize ); <br>        for( int i = 0; i &lt; 4; i ++ ) { <br>            elbows[i] = new ELBOW_OBJECT( pBuildInfo, i ); <br>            ballJoints[i] = NULL; <br>        } <br> <br>        // Build just one ball joint when not texturing.  It is slightly <br>        // larger than standard ball joint, to prevent any pipe edges from <br>        // 'sticking' out of the ball. <br>        bigBall = new SPHERE_OBJECT( pBuildInfo,   <br>                     ROOT_TWO*radius / ((float) cos(PI/nSlices)) ); <br> <br>        // build end cap <br>        ballCap = new SPHERE_OBJECT( pBuildInfo, ROOT_TWO*radius ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* Reset <br>* <br>* Reset frame attributes for normal pipes. <br>* <br>\**************************************************************************/ <br> <br>void  <br>NORMAL_STATE::Reset( ) <br>{ <br>    // Set the joint style <br>    if( bCycleJointStyles ) { <br>        if( ++(jointStyle) &gt;= NUM_JOINT_STYLES ) <br>            jointStyle = 0; <br>    } <br>} <br> <br> <br>/*----------------------------------------------------------------------- <br>|                                                                       | <br>|    ChooseJointType                                                    | <br>|       - Decides which type of joint to draw                           | <br>|                                                                       | <br>-----------------------------------------------------------------------*/ <br> <br>#define BLUE_MOON 153 <br> <br>int  <br>NORMAL_STATE::ChooseJointType( ) <br>{ <br>    switch( jointStyle ) { <br>        case ELBOWS: <br>            return ELBOW_JOINT; <br>        case BALLS: <br>            return BALL_JOINT; <br>        case EITHER: <br>            // draw a teapot once in a blue moon <br>            if( ss_iRand(1000) == BLUE_MOON ) <br>                return( TEAPOT ); <br>        default: <br>            // otherwise an elbow or a ball (1/3 ball) <br>            if( !ss_iRand(3) ) <br>                return BALL_JOINT; <br>            else <br>                return ELBOW_JOINT; <br>    } <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
