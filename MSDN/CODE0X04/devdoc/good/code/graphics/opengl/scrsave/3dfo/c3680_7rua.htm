<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENLEM.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3682"></a>GENLEM.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: genlem.c <br>* <br>* The Twist style of the 3D Flying Objects screen saver. <br>* <br>* Solid model of a 3D lemniscate. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br>#include "mesh.h" <br> <br>#define ROT_PREC    10 <br>#define NORMS(x, y) lemMesh.norms[((x) * iPrec) + y] <br>#define GRID(x, y)  lemMesh.pts[((x) * iPrec) + y] <br> <br>static MESH lemMesh; <br>static POINT3D basis[ROT_PREC]; <br>static double zrot = 0.2; <br>static int iPrec = 32; <br>static double *lemX; <br>static double *lemY; <br>static double *lemXT; <br>static double *lemYT; <br> <br> <br>static void getLem(double index, double max, double *angle, double *r) <br>{     <br>    double a, sina; <br> <br>    a = (index * PI) / (max - 1.0); <br>    if (a &gt;= PI) <br>        a -= PI; <br>    if (a &gt; PI / 2.0) { <br>        *angle = (2.0 * PI) - a; <br>        sina = sin( 2.0 * *angle ); <br>        if( sina &lt; 0.0 ) <br>            sina = 0.0; // protect against sqrt fpe <br>        *r = 0.5 * sqrt(sina); <br>    } else { <br>        *angle = a; <br>        sina = sin( 2.0 * *angle ); <br>        if( sina &lt; 0.0 ) <br>            sina = 0.0; <br>        *r = 0.5 * sqrt(sina); <br>    } <br>}             <br> <br> <br>static void initLemCoords(int iMax) <br>{ <br>    int i; <br>    double max = (double)iMax; <br>    double angle; <br>    double r; <br> <br>    for (i = 0; i &lt; iMax; i++) { <br>        getLem((double)i, (double)iPrec, &amp;angle, &amp;r);         <br>        lemX[i] = r * cos(angle); <br>        lemY[i] = r * sin(angle); <br>         <br>        getLem((double)i + 0.00001, (double)iPrec, &amp;angle, &amp;r);         <br>        lemXT[i] = r * cos(angle); <br>        lemYT[i] = r * sin(angle); <br> <br>    } <br>} <br> <br> <br>void genLemniscate(void) <br>{ <br>    int i; <br>    int j; <br>    double posInc = 2.0 / (float)iPrec; <br>    int facecount = 0; <br>    int ptcount = 0; <br>    POINT3D norm; <br>    static float twistFact = 0.0f; <br>    static float twistFactAdd = 0.05f; <br>    POINT3D a[ROT_PREC]; <br>    POINT3D b[ROT_PREC]; <br>    MATRIX matrix; <br>    MESH *mesh = &amp;lemMesh; <br> <br>    mesh-&gt;numPoints = 0;    <br>    mesh-&gt;numFaces = 0;    <br>    for (i = 0; i &lt; (iPrec - 1) * (ROT_PREC - 1); i++) <br>        mesh-&gt;norms[i] = ss_ptZero; <br> <br>    for (i = 0; i &lt; (iPrec - 1); i++) { <br>        double x1, y1, x2, y2; <br>        double len; <br>        double sinAngle; <br>        double rotZ; <br>        int id[4]; <br> <br>        x1 = lemX[i]; <br>        y1 = lemY[i]; <br>        x2 = lemXT[i]; <br>        y2 = lemYT[i]; <br> <br>        x2 -= x1; <br>        y2 -= y1; <br> <br>        len = sqrt(x2 * x2 + y2 * y2); <br>        if (len &gt; 0.0) <br>            sinAngle = y2 / len; <br>        else <br>            sinAngle = 0.0; <br>        if (y2 &lt; 0.0) <br>            sinAngle = -sinAngle; <br>        rotZ = asin(sinAngle); <br>        if (x2 &lt; 0.0) <br>            rotZ = PI - rotZ; <br>        if (y2 &lt; 0.0) <br>            rotZ = -rotZ; <br>        if (rotZ &lt; 0.0) <br>            rotZ = 2.0 * PI + rotZ; <br> <br>        ss_matrixIdent(&amp;matrix); <br>        ss_matrixRotate(&amp;matrix, 0.0, 0.0, -rotZ); <br>        ss_matrixTranslate(&amp;matrix, x1, y1,  <br>                         twistFact * cos((2.0 * PI * (float)i) / ((float)iPrec - 1))); <br>         <br>        for (j = 0; j &lt; ROT_PREC; j++) <br>            ss_xformPoint(&amp;a[j], &amp;basis[j], &amp;matrix); <br> <br>        x1 = lemX[i+1]; <br>        y1 = lemY[i+1]; <br> <br>        x2 = lemXT[i+1]; <br>        y2 = lemYT[i+1]; <br> <br>        x2 -= x1; <br>        y2 -= y1; <br> <br>        len = sqrt(x2 * x2 + y2 * y2); <br> <br>        if (len &gt; 0.0) <br>            sinAngle = y2 / len; <br>        else <br>            sinAngle = 0.0; <br>        if (y2 &lt; 0.0) <br>            sinAngle = -sinAngle; <br>        rotZ = asin(sinAngle); <br>        if (x2 &lt; 0.0) <br>            rotZ = PI - rotZ; <br>        if (y2 &lt; 0.0) <br>            rotZ = -rotZ; <br>        if (rotZ &lt; 0.0) <br>            rotZ = 2.0 * PI + rotZ; <br> <br>        ss_matrixIdent(&amp;matrix); <br>        ss_matrixRotate(&amp;matrix, 0.0, 0.0, -rotZ);         <br>        ss_matrixTranslate(&amp;matrix, x1, y1,  <br>                         twistFact * cos((2.0 * PI * ((float)i + 1.0)) / ((float)iPrec - 1))); <br> <br>        for (j = 0; j &lt; ROT_PREC; j++) <br>            ss_xformPoint(&amp;b[j], &amp;basis[j], &amp;matrix); <br>             <br>        memcpy(&amp;mesh-&gt;pts[ptcount], &amp;a, sizeof(POINT3D) * (ROT_PREC - 1)); <br>        ptcount += (ROT_PREC - 1); <br>        mesh-&gt;numPoints += (ROT_PREC - 1); <br>         <br>             <br>        for (j = 0; j &lt; (ROT_PREC - 1); j++) { <br>            int k; <br>            int jj; <br>             <br>            if (j == (ROT_PREC - 2)) <br>                jj = 0; <br>            else <br>                jj = j + 1; <br> <br>            ss_calcNorm(&amp;norm, &amp;b[j + 1], &amp;b[j], &amp;a[j]); <br>             <br>            mesh-&gt;faces[facecount].material = 3; <br>            mesh-&gt;faces[facecount].norm = norm; <br>            if (i == iPrec - 2) { <br>                id[0] = mesh-&gt;faces[facecount].p[0] = j; <br>                id[1] = mesh-&gt;faces[facecount].p[1] = jj; <br>            } else { <br>                id[0] = mesh-&gt;faces[facecount].p[0] = ptcount + j; <br>                id[1] = mesh-&gt;faces[facecount].p[1] = ptcount + jj; <br>            } <br>            id[2] = mesh-&gt;faces[facecount].p[2] = ptcount - (ROT_PREC - 1) + j; <br>            id[3] = mesh-&gt;faces[facecount].p[3] = ptcount - (ROT_PREC - 1) + jj; <br>             <br>            for (k = 0; k &lt; 4; k++) { <br>                POINT3D *pn = &amp;mesh-&gt;norms[id[k]]; <br>                 <br>                pn-&gt;x += norm.x; <br>                pn-&gt;y += norm.y; <br>                pn-&gt;z += norm.z; <br>            } <br>            mesh-&gt;numFaces++; <br>            facecount++; <br>        } <br>    } <br> <br>    ss_normalizeNorms(lemMesh.norms, lemMesh.numPoints); <br>         <br>    if (twistFact &gt;= 1.0f) <br>        twistFactAdd = -0.01f; <br>    else if (twistFact &lt;= -1.0f) <br>        twistFactAdd = 0.01f; <br>    twistFact += twistFactAdd; <br>         <br>} <br> <br>void initLemScene() <br>{ <br>    int i; <br>    RGBA lightAmbient = {0.0f, 0.0f, 0.0f, 1.0f}; <br> <br>    iPrec = (int)(fTesselFact * 32.5); <br>    if (iPrec &lt; 5) <br>        iPrec = 5; <br> <br>    lemX = SaverAlloc(sizeof(double) * iPrec); <br>    lemY = SaverAlloc(sizeof(double) * iPrec); <br>    lemXT = SaverAlloc(sizeof(double) * iPrec); <br>    lemYT = SaverAlloc(sizeof(double) * iPrec); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0); <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br> <br>    newMesh(&amp;lemMesh, (ROT_PREC - 1) * (iPrec - 1) ,  <br>            (ROT_PREC - 1) * (iPrec - 1)); <br>    for (i = 0; i &lt; ROT_PREC; i++) { <br>        basis[i].x = 0.0f; <br>        basis[i].y = (float) (0.15 * cos((i * 2.0 * PI) / (ROT_PREC - 1.0))); <br>        basis[i].z = (float) (0.15 * sin((i * 2.0 * PI) / (ROT_PREC - 1.0))); <br>    } <br> <br>    initLemCoords(iPrec); <br> <br>    glFrontFace(GL_CW); <br>    glEnable(GL_CULL_FACE); <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat *) &amp;lightAmbient); <br> <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                 (GLfloat *) &amp;Material[3].kd); <br>} <br> <br>void delLemScene() <br>{ <br>    delMesh(&amp;lemMesh); <br> <br>    SaverFree(lemX); <br>    SaverFree(lemY); <br>    SaverFree(lemXT); <br>    SaverFree(lemYT); <br>} <br> <br>void updateLemScene(int flags) <br>{ <br>    static double mxrot = 0.0; <br>    static double myrot = 0.0; <br>    static double mzrot = 0.0; <br>    static double mxrotInc = 0.0; <br>    static double myrotInc = 0.1; <br>    static double zrotInc = 0.1; <br>    static double mzrotInc = 0.0; <br>    static int h = 0; <br>    RGBA color; <br>    MATRIX model; <br>     <br>    mxrot += mxrotInc; <br>    myrot += myrotInc; <br>    mzrot += mzrotInc; <br> <br>    if( gbBounce ) { <br>        // floating window bounced off an edge <br>        if (mxrotInc) { <br>            mxrotInc = 0.0; <br>            myrotInc = 0.1; <br>        } else if (myrotInc) { <br>            myrotInc = 0.0; <br>            mzrotInc = 0.1; <br>        } else if (mzrotInc) { <br>            mzrotInc = 0.0; <br>            mxrotInc = 0.1; <br>        } <br>        gbBounce = FALSE; <br>    } <br> <br>    zrot += zrotInc; <br>    if (zrot &gt;= PI / 4.0) { <br>        zrot = PI / 4.0; <br>        zrotInc = -0.03; <br>    } else if (zrot &lt;= -PI / 4.0) { <br>        zrot = -PI / 4.0; <br>        zrotInc = 0.03; <br>    } <br> <br>    genLemniscate(); <br> <br>    if (bColorCycle) { <br>        ss_HsvToRgb((float)h, 1.0f, 1.0f, &amp;color ); <br> <br>        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &amp;color); <br> <br>        h++; <br>        h %= 360; <br>    } <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-1.5, 1.5, -1.5, 1.5, 0.0, 3.0); <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br>    glRotatef((GLfloat) (zrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f); <br>    glRotatef(50.0f, 1.0f, 0.0f, 0.0f); <br>    glRotatef(50.0f, 0.0f, 0.0f, 1.0f); <br> <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br>    glTranslatef(0.0f, -0.5f, 0.0f); <br>    glRotatef((GLfloat) (mxrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f); <br>    glRotatef((GLfloat) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f); <br>    glRotatef((GLfloat) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f); <br> <br>    ss_matrixIdent(&amp;model); <br>    ss_matrixRotate(&amp;model, mxrot, myrot, mzrot); <br>    ss_matrixTranslate(&amp;model, 0.0, -0.5, 0.0); <br> <br>    updateObject(&amp;lemMesh, bSmoothShading);     <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
