<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIXED.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3723"></a>FIXED.H</h2>
<pre><code>#ifndef __FIXED_H__ <br>#define __FIXED_H__ <br> <br>#include &lt;math.h&gt; <br> <br>#ifdef __cplusplus <br>extern "C" { <br>#endif <br>     <br>#ifndef PI <br>#define PI (3.1415926535897932384626433832795028841971693993751) <br>#endif <br> <br>/* Default table size for precomputed sincos table */ <br>#define FA_TABLE_SIZE 360 <br> <br>/* <br>   Flags for initialization <br>   FA_CARTESIAN_Y       - Y axis is positive up <br> */ <br>#define FA_DEFAULT      0 <br>#define FA_CARTESIAN_Y  1 <br>     <br>#if defined(FX_DOUBLE) || defined(FX_SINGLE) <br> <br>#ifdef FX_DOUBLE <br>typedef double FxValue; <br> <br>#define FX_MAX_VALUE (1e100) <br>#define FX_MIN_VALUE (1e-10) <br>#else <br>typedef float FxValue; <br> <br>#define FX_MAX_VALUE (1e38f) <br>#define FX_MIN_VALUE (1e-7f) <br>#endif <br> <br>#define FxVal(i) ((FxValue)(i)) <br>#define FxInt(v) ((int)(v)) <br>#define FxFltVal(f) ((FxValue)(f)) <br>#define FxFlt(v) ((double)(v)) <br>#define FxPromote(v) (v) <br>#define FxDemote(v) (v) <br> <br>#define FxMul(a, b) ((a)*(b)) <br>#define FxDemotedMul(a, b) FxMul(a, b) <br>#define FxDiv(a, b) ((a)/(b)) <br>#define FxDemotedDiv(a, b) FxDiv(a, b) <br>#define FxMulToInt(a, b) FxInt((a)*(b)) <br>#define FxDivToInt(a, b) ((int)((a)/(b))) <br>#define FxMulDiv(a, m, d) (((a)*(m))/(d)) <br>#define FxSqrt(v) ((FxValue)sqrt((double)(v))) <br>#define FxDemotedSqrt(v) FxSqrt(v) <br> <br>typedef FxValue FaAngle; <br> <br>#define FaAng(a) (a) <br> <br>#define FaSin(v) ((FxValue)-sin((double)(v))) <br>#define FaCos(v) ((FxValue)cos((double)(v))) <br> <br>#define FaAdd(a, d) ((a)+(d)) <br>FaAngle FaNorm(FaAngle a); <br>#define FaDeg(da) ((da)*(FxValue)(PI/180.0)) <br>#define FaRad(ra) (ra) <br>#define FaAngVal(aa) (aa) <br>#define FaFltDegVal(a) ((a)*180.0/PI) <br>#define FaFltRadVal(a) (a) <br> <br>#define FxInitialize(table_size, flags) ((flags) == FA_DEFAULT) <br>#define FxEnd() <br> <br>#else <br> <br>/* If integer sqrt isn't interesting, define FX_PRECISE_SQRT <br>   and the floating point sqrt will be used */ <br> <br>#ifndef FX_SHIFT <br>#define FX_SHIFT 10 <br>#endif <br>#define FX_MULT (1L &lt;&lt; FX_SHIFT) <br> <br>typedef long FxValue; <br> <br>#define FX_MAX_VALUE (0x7fffffff) <br>#define FX_MIN_VALUE (1) <br> <br>#define FxVal(i) FxPromote((FxValue)(i)) <br>#define FxInt(v) ((int)FxDemote(v)) <br>#define FxFltVal(f) ((FxValue)((f)*(double)FX_MULT)) <br>#define FxFlt(v) (((double)(v))/(double)FX_MULT) <br>#define FxPromote(v) ((v) &lt;&lt; FX_SHIFT) <br>#define FxDemote(v) ((v) &gt;&gt; FX_SHIFT) <br> <br>#if FX_SHIFT != 16 <br>/* These can overflow if the shift and numbers are too large */ <br>#define FxMul(a, b) FxDemote((a)*(b)) <br>#define FxDiv(a, b) (FxPromote(a)/(b)) <br>#define FxMulToInt(a, b) FxInt(FxDemote((a)*(b))) <br>#define FxMulDiv(a, m, d) (((a)*(m))/(d)) <br>#else <br>/* For FX_SHIFT == 16 and certain platforms, assembly routines are <br>   provided which do 64-bit intermediate math, preserving accuracy <br>   There is still a danger of overflow if the results don't fit in <br>   32 bits, though */ <br>FxValue FxMul(FxValue a, FxValue b); <br>FxValue FxDiv(FxValue a, FxValue b); <br>int FxMulToInt(FxValue a, FxValue b); <br>FxValue FxMulDiv(FxValue a, FxValue m, FxValue d); <br>#endif <br> <br>#ifndef FX_PRECISE_SQRT <br>FxValue FxSqrt(FxValue v); <br>/* Computing the square root of a demoted value leaves it out of <br>   adjustment by sqrt(FX_MULT) so shift by FX_SHIFT/2 to <br>   restore fixed point <br>   FX_SHIFT should be even for this to work */ <br>#define FxDemotedSqrt(v) (FxSqrt(FxDemote(v)) &lt;&lt; (FX_SHIFT/2)) <br>#else <br>#define FxSqrt(v) FxFltVal(sqrt(FxFlt(v))) <br>#define FxDemotedSqrt(v) FxSqrt(v) <br>#endif <br> <br>#define FxDemotedMul(a, b) (FxDemote(a)*(b)) <br>#define FxDemotedDiv(a, b) FxPromote((a)/(b)) <br>#define FxDivToInt(a, b) ((int)((a)/(b))) <br> <br>/* One unit of angle is the table quantum <br>   One unit of angle equals 360/_fa_table_size degrees */  <br>typedef FxValue FaAngle; <br> <br>extern int _fa_table_size; <br> <br>extern FxValue *_fa_sines; <br>extern FxValue *_fa_cosines; <br> <br>#define FaAng(a) FxDemote(a) <br>#define FaSin(a) _fa_sines[(int)FaAng(a)] <br>#define FaCos(a) _fa_cosines[(int)FaAng(a)] <br> <br>FaAngle FaAdd(FaAngle a, FaAngle d); <br>FaAngle FaBisectingAngle(FaAngle f, FaAngle t); <br>#define FaNorm(a) FaAdd(FxVal(0), a) <br>#define FaDeg(da) \ <br>    FaNorm(FxMulDiv(FxVal(da), _fa_table_size, 360)) <br>#define FaRad(ra) FaNorm(FxFltVal((ra)*_fa_table_size/PI2)) <br>#define FaAngVal(aa) FaNorm(FxVal(aa)) <br>#define FaFltDegVal(ang) FxFltVal(FxMulDiv(ang, 360, _fa_table_size)) <br>#define FaFltRadVal(ang) (FxFltVal(ang)*PI2/_fa_table_size) <br> <br>BOOL FxInitialize(int table_size, ULONG flags); <br>void FxEnd(void); <br> <br>#endif <br> <br>typedef struct _FxPt2 <br>{ <br>    FxValue x, y; <br>} FxPt2; <br>typedef FxPt2 FxVec2; <br> <br>typedef struct _FxBox2 <br>{ <br>    FxPt2 min, max; <br>} FxBox2; <br> <br>typedef struct _FxPt3 <br>{ <br>    FxValue x, y, z; <br>} FxPt3; <br>typedef FxPt3 FxVec3; <br> <br>typedef struct _FxBox3 <br>{ <br>    FxPt3 min, max; <br>} FxBox3; <br> <br>typedef struct _FxPt4 <br>{ <br>    FxValue x, y, z, w; <br>} FxPt4; <br>typedef FxPt4 FxVec4; <br> <br>void FxBBox2Empty(FxBox2 *bb); <br>void FxBBox2AddPt(FxBox2 *bb, FxPt2 *pt); <br> <br>void FxBBox3Empty(FxBox3 *bb); <br>void FxBBox3AddPt(FxBox3 *bb, FxPt3 *pt); <br> <br>#define FxV2Set(v, xv, yv) \ <br>    ((v)-&gt;x = (xv), (v)-&gt;y = (yv)) <br>#define FxV2Add(a, b, r) \ <br>    ((r)-&gt;x = (a)-&gt;x+(b)-&gt;x, (r)-&gt;y = (a)-&gt;y+(b)-&gt;y) <br>#define FxV2Sub(a, b, r) \ <br>    ((r)-&gt;x = (a)-&gt;x-(b)-&gt;x, (r)-&gt;y = (a)-&gt;y-(b)-&gt;y) <br>#define FxV2Dot(a, b) \ <br>    (FxMul((a)-&gt;x, (b)-&gt;x)+FxMul((a)-&gt;y, (b)-&gt;y)) <br>#define FxV2Neg(v, r) \ <br>    ((r)-&gt;x = -(v)-&gt;x, (r)-&gt;y = -(v)-&gt;y) <br>#define FxV2NegV(v) FxV2Neg(v, v) <br>#define FxV2NormV(v) FxV2Norm(v, v) <br> <br>FxValue FxV2Len(FxVec2 *v); <br>FxValue FxV2Norm(FxVec2 *v, FxVec2 *r); <br> <br>#define FxvV2Set(v, xv, yv) FxV2Set(&amp;(v), xv, yv) <br>#define FxvV2Add(a, b, r) FxV2Add(&amp;(a), &amp;(b), &amp;(r)) <br>#define FxvV2Sub(a, b, r) FxV2Sub(&amp;(a), &amp;(b), &amp;(r)) <br>#define FxvV2Dot(a, b) FxV2Dot(&amp;(a), &amp;(b)) <br>#define FxvV2Neg(v, r) FxV2Neg(&amp;(v), &amp;(r)) <br>#define FxvV2NegV(v) FxV2NegV(&amp;(v)) <br>#define FxvV2Len(v) FxV2Len(&amp;(v)) <br>#define FxvV2Norm(v, r) FxV2Norm(&amp;(v), &amp;(r)) <br>#define FxvV2NormV(v) FxV2NormV(&amp;(v)) <br> <br>#define FxV3Set(v, xv, yv, zv) \ <br>    ((v)-&gt;x = (xv), (v)-&gt;y = (yv), (v)-&gt;z = (zv)) <br>#define FxV3Add(a, b, r) \ <br>    ((r)-&gt;x = (a)-&gt;x+(b)-&gt;x, (r)-&gt;y = (a)-&gt;y+(b)-&gt;y, (r)-&gt;z = (a)-&gt;z+(b)-&gt;z) <br>#define FxV3Sub(a, b, r) \ <br>    ((r)-&gt;x = (a)-&gt;x-(b)-&gt;x, (r)-&gt;y = (a)-&gt;y-(b)-&gt;y, (r)-&gt;z = (a)-&gt;z-(b)-&gt;z) <br>#define FxV3Dot(a, b) \ <br>    (FxMul((a)-&gt;x, (b)-&gt;x)+FxMul((a)-&gt;y, (b)-&gt;y)+FxMul((a)-&gt;z, (b)-&gt;z)) <br>#define FxV3Neg(v, r) \ <br>    ((r)-&gt;x = -(v)-&gt;x, (r)-&gt;y = -(v)-&gt;y, (r)-&gt;z = -(v)-&gt;z) <br>#define FxV3NegV(v) FxV3Neg(v, v) <br>#define FxV3Cross(a, b, r) \ <br>    ((r)-&gt;x = (a)-&gt;y*(b)-&gt;z-(b)-&gt;y*(a)-&gt;z,\ <br>     (r)-&gt;y = (a)-&gt;z*(b)-&gt;x-(b)-&gt;z*(a)-&gt;x,\ <br>     (r)-&gt;z = (a)-&gt;x*(b)-&gt;y-(b)-&gt;x*(a)-&gt;y) <br>#define FxV3NormV(v) FxV3Norm(v, v) <br> <br>FxValue FxV3Len(FxVec3 *v); <br>FxValue FxV3Norm(FxVec3 *v, FxVec3 *r); <br> <br>#define FxvV3Set(v, xv, yv, zv) FxV3Set(&amp;(v), xv, yv, zv) <br>#define FxvV3Add(a, b, r) FxV3Add(&amp;(a), &amp;(b), &amp;(r)) <br>#define FxvV3Sub(a, b, r) FxV3Sub(&amp;(a), &amp;(b), &amp;(r)) <br>#define FxvV3Dot(a, b) FxV3Dot(&amp;(a), &amp;(b)) <br>#define FxvV3Neg(v, r) FxV3Neg(&amp;(v), &amp;(r)) <br>#define FxvV3NegV(v) FxV3NegV(&amp;(v)) <br>#define FxvV3Cross(a, b, r) FxV3Cross(&amp;(a), &amp;(b), &amp;(r)) <br>#define FxvV3Len(v) FxV3Len(&amp;(v)) <br>#define FxvV3Norm(v, r) FxV3Norm(&amp;(v), &amp;(r)) <br>#define FxvV3NormV(v) FxV3NormV(&amp;(v)) <br> <br>typedef FxValue FxMatrix2[2][2]; <br>typedef FxValue FxMatrix3[3][3]; <br>typedef FxValue FxMatrix4[4][4]; <br> <br>typedef FxValue FxTMatrix2[2][3]; <br>typedef FxValue FxTMatrix3[3][4]; <br> <br>void FxT2Ident(FxTMatrix2 m); <br>void FxT2Mul(FxTMatrix2 a, FxTMatrix2 b, FxTMatrix2 r); <br>void FxT2Vec2(FxTMatrix2 m, int n, FxVec2 *f, FxVec2 *t); <br> <br>void FxT3Ident(FxTMatrix3 m); <br>void FxT3Mul(FxTMatrix3 a, FxTMatrix3 b, FxTMatrix3 r); <br>void FxT3Vec3(FxTMatrix3 m, int n, FxVec3 *f, FxVec3 *t); <br> <br>#ifdef __cplusplus <br>} <br>#endif <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
