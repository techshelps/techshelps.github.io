<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLGDRAW.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3694"></a>DLGDRAW.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: dlgdraw.c <br>* <br>* For gl drawing in dialog boxes <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include "ssintrnl.hxx" <br>#include "dlgdraw.hxx" <br> <br>// Define this if want each TEX_BUTTON to be a separate window.  This is <br>// necessary if the main dialog window has WS_CLIP_CHILDREN, but so far this <br>// doesn't seem to be the case. <br> <br>static void CalcGLViewport( HWND hwndParent, HWND hwndChild, IPOINT2D *pOrigin, ISIZE *pSize ); <br> <br>//materials for varying intensities <br> <br>enum{ <br>    MAT_INTENSITY_LOW = 0, <br>    MAT_INTENSITY_MID, <br>    MAT_INTENSITY_HIGH, <br>    MAT_COUNT <br>}; <br> <br>MATERIAL gMat[MAT_COUNT] = { <br>    {{0.3f, 0.3f, 0.3f}, {0.6f, 0.6f, 0.6f}, {0.2f, 0.2f, 0.2f}, 0.3f }, <br>    {{0.2f, 0.2f, 0.2f}, {0.8f, 0.8f, 0.8f}, {0.2f, 0.2f, 0.2f}, 0.3f }, <br>    {{0.2f, 0.2f, 0.2f}, {1.0f, 1.0f, 1.0f}, {0.2f, 0.2f, 0.2f}, 0.3f } <br>}; <br> <br>float colorBlack[3] = {0.0f, 0.0f, 0.0f}; <br> <br>/**************************************************************************\ <br>* SS_TEX_BUTTON constructor <br>* <br>* This allows drawing GL textures on a button <br>* <br>* For optimum performance, GL is configured on the main dialog window, and <br>* 'viewported' to the button. <br>* Defining SS_MULTIWINDOW results in the texture being drawn in the actual <br>* button window. <br>* <br>* Note: this only works for buttons on the main dialog window for now. <br>\**************************************************************************/ <br> <br>SS_TEX_BUTTON::SS_TEX_BUTTON( HWND hDlg, HWND hDlgBtn ) <br>{ <br>    PSSW psswParent = gpss-&gt;sswTable.PsswFromHwnd( hDlg ); <br>    SS_ASSERT( psswParent, "SS_TEX_BUTTON constructor: NULL psswParent\n" ); <br> <br>    // The parent needs to have an hrc context, since we will be using it <br>    // for drawing. <br> <br>    SS_GL_CONFIG GLc = { 0, 0, NULL }; <br>    if( !psswParent-&gt;ConfigureForGL( &amp;GLc ) ) { <br>        SS_WARNING( "SS_TEX_BUTTON constructor: ConfigureForGL failed\n" ); <br>        return; <br>    } <br> <br>#ifdef SS_MULTIWINDOW <br>    // Each button is a separate GL window, using its parents hrc <br>    pssw = new SSW( psswParent, hDlgBtn ); <br> <br>    SS_ASSERT( pssw, "SS_TEX_BUTTON constructor: pssw alloc failure\n" ); <br> <br>    // Configure the pssw for GL <br> <br>    GLc.pfFlags = 0; <br>    GLc.hrc = psswParent-&gt;GetHRC(); <br>    GLc.pStretch = NULL; <br> <br>    if( ! pssw-&gt;ConfigureForGL( &amp;GLc ) ) { <br>        SS_WARNING( "SS_TEX_BUTTON constructor: ConfigureForGL failed\n" ); <br>        return; <br>    } <br>#else <br>    // Make the button a 'subwindow' of the parent <br>    pssw = NULL; <br> <br>    // Calculate the viewport to draw to <br> <br>    CalcGLViewport( hDlg, hDlgBtn, &amp;origin, &amp;size ); <br>#endif <br> <br>    // Init various GL stuff <br>    InitGL(); <br> <br>    pCurTex = NULL; <br>    bEnabled = TRUE; <br>} <br> <br>/**************************************************************************\ <br>* SS_TEX_BUTTON destructor <br>* <br>\**************************************************************************/ <br> <br>SS_TEX_BUTTON::~SS_TEX_BUTTON() <br>{ <br>    if( pssw ) <br>        delete pssw; <br>} <br> <br>/**************************************************************************\ <br>* InitGL <br>* <br>\**************************************************************************/ <br> <br>void <br>SS_TEX_BUTTON::InitGL() <br>{ <br>    float ambient[] = {0.2f, 0.2f, 0.2f, 1.0f}; <br>    float diffuse[] = {0.7f, 0.7f, 0.7f, 1.0f}; <br>    float position[] = {0.0f, 0.0f, -150.0f, 1.0f}; <br>    float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f}; <br> <br>    // lighting, for intensity levels <br> <br>    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient); <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse); <br>    glLightfv(GL_LIGHT0, GL_POSITION, position); <br>    glEnable(GL_LIGHT0); <br> <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient); <br>    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE); <br> <br>    glCullFace( GL_BACK ); <br>    glEnable(GL_CULL_FACE); <br>    glFrontFace( GL_CW ); <br>    glShadeModel( GL_FLAT ); <br> <br>    glColor3f( 1.0f, 1.0f, 1.0f ); <br>    gluOrtho2D( -1.0, 1.0, -1.0, 1.0 ); <br> <br>    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <br>} <br> <br>/**************************************************************************\ <br>* SetTexture <br>* <br>* Set a current texture for the button <br>* <br>* Note this is a pointer to a texture, so any texture memory management is <br>* done by the caller. <br>\**************************************************************************/ <br> <br>void <br>SS_TEX_BUTTON::SetTexture( TEXTURE *pTex ) <br>{ <br>    pCurTex = pTex; <br>} <br> <br>/**************************************************************************\ <br>* Draw <br>* <br>\**************************************************************************/ <br> <br>void <br>SS_TEX_BUTTON::Draw( TEXTURE *pTex ) <br>{ <br>    if( pTex != NULL ) { <br>        glEnable(GL_TEXTURE_2D); <br> <br>        ss_SetTexture( pTex ); // doesn't look at iPalRot yet <br>        // Set the texture palette if it exists <br>        if( pTex-&gt;pal &amp;&amp; pTex-&gt;iPalRot ) <br>            ss_SetTexturePalette( pTex, pTex-&gt;iPalRot ); <br>    } <br>    // else white rectangle will be drawn <br> <br>    if( bEnabled ) <br>        intensity = DLG_INTENSITY_HIGH; <br>    else <br>        intensity = DLG_INTENSITY_LOW; <br> <br>    switch( intensity ) { <br>        case DLG_INTENSITY_LOW: <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); <br>            glEnable(GL_LIGHTING); <br>            glColor3f( 0.5f, 0.5f, 0.5f ); <br>            break; <br>        case DLG_INTENSITY_MID: <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); <br>            glEnable(GL_LIGHTING); <br>            glColor3f( 0.7f, 0.7f, 0.7f ); <br>            break; <br>        case DLG_INTENSITY_HIGH: <br>        default: <br>            glColor3f( 1.0f, 1.0f, 1.0f ); <br>            glDisable(GL_LIGHTING); <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL); <br>    } <br> <br>    // Set the viewport <br>#ifdef SS_MULTIWINDOW <br>    glViewport( 0, 0, pssw-&gt;size.width, pssw-&gt;size.height ); <br>#else <br>    glViewport( origin.x, origin.y, size.width, size.height ); <br>#endif <br> <br>    glBegin( GL_QUADS ); <br>        glTexCoord2f( 0.0f, 1.0f ); <br>        glVertex2f( -1.0f, 1.0f ); <br>        glTexCoord2f( 1.0f, 1.0f ); <br>        glVertex2f(  1.0f,  1.0f ); <br>        glTexCoord2f( 1.0f, 0.0f ); <br>        glVertex2f(  1.0f, -1.0f ); <br>        glTexCoord2f( 0.0f, 0.0f ); <br>        glVertex2f(  -1.0f, -1.0f ); <br>    glEnd(); <br> <br>    glDisable( GL_TEXTURE_2D); <br> <br>    glFlush(); <br>} <br> <br>void <br>SS_TEX_BUTTON::Draw() <br>{ <br>    Draw( pCurTex ); <br>} <br> <br>/**************************************************************************\ <br>* CalcGLViewport <br>* <br>* Calculate viewport for the child window <br>* <br>\**************************************************************************/ <br> <br>static void  <br>CalcGLViewport( HWND hwndParent, HWND hwndChild, IPOINT2D *pOrigin, ISIZE *pSize ) <br>{ <br>    RECT childRect, parentRect; <br> <br>    // Get size of the child window <br> <br>    GetClientRect( hwndChild, &amp;childRect ); <br>    pSize-&gt;width = childRect.right; <br>    pSize-&gt;height = childRect.bottom; <br> <br>    // Calc origin of the child window wrt its parents client area <br>    // Note that the y-coord must be inverted for GL <br> <br>    // Map the child client rect to the parent client coords <br>    MapWindowPoints( hwndChild, hwndParent, (POINT *) &amp;childRect, 2 ); <br>    pOrigin-&gt;x = childRect.left; <br>    // invert y coord <br>    GetClientRect( hwndParent, &amp;parentRect ); <br>    pOrigin-&gt;y = parentRect.bottom - childRect.bottom; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
