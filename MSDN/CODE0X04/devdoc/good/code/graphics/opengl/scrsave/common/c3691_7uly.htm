<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSDIB.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3706"></a>SSDIB.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: ssdib.c <br>* <br>* Operations on .bmp files <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt;  <br>#include "sscommon.h" <br> <br>#define BFT_BITMAP  0x4d42  // 'BM' -- indicates structure is BITMAPFILEHEADER <br> <br>#define OFFSET_bfType       0 <br>#define OFFSET_bfSize       2 <br>#define OFFSET_bfReserved1  6 <br>#define OFFSET_bfReserved2  8 <br>#define OFFSET_bfOffBits    10 <br>#define SIZEOF_BITMAPFILEHEADER 14 <br> <br>// Read a WORD-aligned DWORD.  Needed because BITMAPFILEHEADER has <br>// WORD-alignment. <br>#define READDWORD(pv)   ( (DWORD)((PWORD)(pv))[0]               \ <br>                          | ((DWORD)((PWORD)(pv))[1] &lt;&lt; 16) )   \ <br> <br>// Computes the number of BYTES needed to contain n number of bits. <br>#define BITS2BYTES(n)   ( ((n) + 7) &gt;&gt; 3 ) <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibNumColors(VOID FAR * pv)                                * <br> *                                                                          * <br> *  PURPOSE    : Determines the number of colors in the DIB by looking at   * <br> *               the BitCount filed in the info block.                      * <br> *                                                                          * <br> *  RETURNS    : The number of colors in the DIB.                           * <br> *                                                                          * <br> * Stolen from SDK ShowDIB example.                                         * <br> ****************************************************************************/ <br> <br>static WORD DibNumColors(VOID FAR * pv) <br>{ <br>    WORD                bits; <br>    BITMAPINFOHEADER UNALIGNED *lpbi; <br>    BITMAPCOREHEADER UNALIGNED *lpbc; <br> <br>    lpbi = ((LPBITMAPINFOHEADER)pv); <br>    lpbc = ((LPBITMAPCOREHEADER)pv); <br> <br>    /*  With the BITMAPINFO format headers, the size of the palette <br>     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it <br>     *  is dependent on the bits per pixel ( = 2 raised to the power of <br>     *  bits/pixel). <br>     * <br>     *  Because of the way we use this call, BITMAPINFOHEADER may be out <br>     *  of alignment if it follows a BITMAPFILEHEADER.  So use the macro <br>     *  to safely access DWORD fields. <br>     */ <br>    if (READDWORD(&amp;lpbi-&gt;biSize) != sizeof(BITMAPCOREHEADER)){ <br>        if (READDWORD(&amp;lpbi-&gt;biClrUsed) != 0) <br>        { <br>            return (WORD) READDWORD(&amp;lpbi-&gt;biClrUsed); <br>        } <br>        bits = lpbi-&gt;biBitCount; <br>    } <br>    else <br>        bits = lpbc-&gt;bcBitCount; <br> <br>    switch (bits){ <br>        case 1: <br>            return 2; <br>        case 4: <br>            return 16; <br>        case 8: <br>            return 256; <br>        default: <br>            /* A 24 bitcount DIB has no color table */ <br>            return 0; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_DIBImageLoad <br>* <br>* Hacked form of tk_DIBImageLoad(), for reading a .bmp file from a resource <br>* <br>* Loads a DIB file (specified as either an ANSI or Unicode filename, <br>* depending on the bUnicode flag) and converts it into a TK image format. <br>* <br>* The technique used is based on CreateDIBSection and SetDIBits. <br>* CreateDIBSection is used to create a DIB with a format easily converted <br>* into the TK image format (packed 24BPP RGB).  The only conversion  <br>* required is swapping R and B in each RGB triplet (see history below) <br>* The resulting bitmap is selected into a memory DC. <br>* <br>* The DIB file is mapped into memory and SetDIBits called to initialize <br>* the memory DC bitmap.  It is during this step that GDI converts the <br>* arbitrary DIB file format to RGB format. <br>* <br>* Finally, the RGB data in the DIB section is read out and repacked <br>* as 24BPP 'BGR'. <br>* <br>* Returns: <br>*   BOOL.  If an error occurs, a diagnostic error <br>*   message is put into the error stream and tkQuit() is called, <br>*   terminating the app. <br>* <br>\**************************************************************************/ <br> <br>BOOL ss_DIBImageLoad(PVOID pv, TEXTURE *ptex) <br>{ <br>    BOOL             fSuccess = FALSE; <br>    WORD             wNumColors;    // Number of colors in color table <br>    BITMAPFILEHEADER *pbmf;         // Ptr to file header <br>    BITMAPINFOHEADER UNALIGNED *pbmihFile; <br>    BITMAPCOREHEADER UNALIGNED *pbmchFile; // Ptr to file's core header (if it exists) <br>    PVOID            pvBits;    // Ptr to bitmap bits in file <br>    PBYTE            pjBitsRGB;     // Ptr to 24BPP RGB image in DIB section <br>    PBYTE            pjTKBits = (PBYTE) NULL;   // Ptr to final TK image bits <br>    PBYTE            pjSrc;         // Ptr to image file used for conversion <br>    PBYTE            pjDst;         // Ptr to TK image used for conversion <br> <br>    // These need to be cleaned up when we exit: <br>    HDC        hdcMem = (HDC) NULL;                 // 24BPP mem DC <br>    HBITMAP    hbmRGB = (HBITMAP) NULL;             // 24BPP RGB bitmap <br>    BITMAPINFO *pbmiSource = (BITMAPINFO *) NULL;   // Ptr to source BITMAPINFO <br>    BITMAPINFO *pbmiRGB = (BITMAPINFO *) NULL;      // Ptr to file's BITMAPINFO <br> <br>    int i, j; <br>    int padBytes; <br> <br>// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER <br>// followed immediately with the color table and the bitmap bits. <br> <br>    pbmf = (BITMAPFILEHEADER *) pv; <br> <br>    if ( pbmf-&gt;bfType == BFT_BITMAP ) <br>    { <br>        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER); <br> <br>    // BITMAPFILEHEADER is WORD aligned, so use safe macro to read DWORD <br>    // bfOffBits field. <br> <br>        pvBits = (PVOID *) ((PBYTE) pbmf <br>                                + READDWORD((PBYTE) pbmf + OFFSET_bfOffBits)); <br>    } <br>    else <br>    { <br>        pbmihFile = (BITMAPINFOHEADER *) pv; <br> <br>    // Determination of where the bitmaps bits are needs to wait until we <br>    // know for sure whether we have a BITMAPINFOHEADER or a BITMAPCOREHEADER. <br>    } <br> <br>// Determine the number of colors in the DIB palette.  This is non-zero <br>// only for 8BPP or less. <br> <br>    wNumColors = DibNumColors(pbmihFile); <br> <br>// Create a BITMAPINFO (with color table) for the DIB file.  Because the <br>// file may not have one (BITMAPCORE case) and potential alignment problems, <br>// we will create a new one in memory we allocate. <br>// <br>// We distinguish between BITMAPINFO and BITMAPCORE cases based upon <br>// BITMAPINFOHEADER.biSize. <br> <br>    pbmiSource = (BITMAPINFO *) <br>        LocalAlloc(LMEM_FIXED, sizeof(BITMAPINFO) <br>                               + wNumColors * sizeof(RGBQUAD)); <br>    if (!pbmiSource) <br>    { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    // Note: need to use safe READDWORD macro because pbmihFile may <br>    // have only WORD alignment if it follows a BITMAPFILEHEADER. <br> <br>    switch (READDWORD(&amp;pbmihFile-&gt;biSize)) <br>    { <br>    case sizeof(BITMAPINFOHEADER): <br> <br>    // Convert WORD-aligned BITMAPINFOHEADER to aligned BITMAPINFO. <br> <br>        pbmiSource-&gt;bmiHeader.biSize          = sizeof(BITMAPINFOHEADER); <br>        pbmiSource-&gt;bmiHeader.biWidth         = READDWORD(&amp;pbmihFile-&gt;biWidth); <br>        pbmiSource-&gt;bmiHeader.biHeight        = READDWORD(&amp;pbmihFile-&gt;biHeight); <br>        pbmiSource-&gt;bmiHeader.biPlanes        = pbmihFile-&gt;biPlanes; <br>        pbmiSource-&gt;bmiHeader.biBitCount      = pbmihFile-&gt;biBitCount; <br>        pbmiSource-&gt;bmiHeader.biCompression   =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biCompression); <br>        pbmiSource-&gt;bmiHeader.biSizeImage     =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biSizeImage); <br>        pbmiSource-&gt;bmiHeader.biXPelsPerMeter =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biXPelsPerMeter); <br>        pbmiSource-&gt;bmiHeader.biYPelsPerMeter =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biYPelsPerMeter); <br>        pbmiSource-&gt;bmiHeader.biClrUsed       =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biClrUsed); <br>        pbmiSource-&gt;bmiHeader.biClrImportant  =  <br>                                        READDWORD(&amp;pbmihFile-&gt;biClrImportant); <br> <br>    // Copy color table.  It immediately follows the BITMAPINFOHEADER. <br> <br>        memcpy((PVOID) &amp;pbmiSource-&gt;bmiColors[0], (PVOID) (pbmihFile + 1), <br>               wNumColors * sizeof(RGBQUAD)); <br> <br>    // If we haven't already determined the position of the image bits, <br>    // we may now assume that they immediately follow the color table. <br> <br>        if (!pvBits) <br>            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1) <br>                         + wNumColors * sizeof(RGBQUAD)); <br>        break; <br> <br>    case sizeof(BITMAPCOREHEADER): <br>        pbmchFile = (BITMAPCOREHEADER *) pbmihFile; <br> <br>    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER. <br> <br>        pbmiSource-&gt;bmiHeader.biSize          = sizeof(BITMAPINFOHEADER); <br>        pbmiSource-&gt;bmiHeader.biWidth         = (DWORD) pbmchFile-&gt;bcWidth; <br>        pbmiSource-&gt;bmiHeader.biHeight        = (DWORD) pbmchFile-&gt;bcHeight; <br>        pbmiSource-&gt;bmiHeader.biPlanes        = pbmchFile-&gt;bcPlanes; <br>        pbmiSource-&gt;bmiHeader.biBitCount      = pbmchFile-&gt;bcBitCount; <br>        pbmiSource-&gt;bmiHeader.biCompression   = BI_RGB; <br>        pbmiSource-&gt;bmiHeader.biSizeImage     = 0; <br>        pbmiSource-&gt;bmiHeader.biXPelsPerMeter = 0; <br>        pbmiSource-&gt;bmiHeader.biYPelsPerMeter = 0; <br>        pbmiSource-&gt;bmiHeader.biClrUsed       = wNumColors; <br>        pbmiSource-&gt;bmiHeader.biClrImportant  = wNumColors; <br> <br>    // Convert RGBTRIPLE color table into RGBQUAD color table. <br> <br>        { <br>            RGBQUAD *rgb4 = pbmiSource-&gt;bmiColors; <br>            RGBTRIPLE *rgb3 = (RGBTRIPLE *) (pbmchFile + 1); <br> <br>            for (i = 0; i &lt; wNumColors; i++) <br>            { <br>                rgb4-&gt;rgbRed   = rgb3-&gt;rgbtRed  ; <br>                rgb4-&gt;rgbGreen = rgb3-&gt;rgbtGreen; <br>                rgb4-&gt;rgbBlue  = rgb3-&gt;rgbtBlue ; <br>                rgb4-&gt;rgbReserved = 0; <br> <br>                rgb4++; <br>                rgb3++; <br>            } <br>        } <br> <br>    // If we haven't already determined the position of the image bits, <br>    // we may now assume that they immediately follow the color table. <br> <br>        if (!pvBits) <br>            pvBits = (PVOID) ((PBYTE) (pbmihFile + 1) <br>                         + wNumColors * sizeof(RGBTRIPLE)); <br>        break; <br> <br>    default: <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>// Fill in default values (for fields that can have defaults). <br> <br>    if (pbmiSource-&gt;bmiHeader.biSizeImage == 0) <br>        pbmiSource-&gt;bmiHeader.biSizeImage =  <br>            BITS2BYTES( (DWORD) pbmiSource-&gt;bmiHeader.biWidth *  <br>                                pbmiSource-&gt;bmiHeader.biBitCount ) *  <br>                                pbmiSource-&gt;bmiHeader.biHeight; <br>    if (pbmiSource-&gt;bmiHeader.biClrUsed == 0) <br>        pbmiSource-&gt;bmiHeader.biClrUsed = wNumColors; <br> <br>// Create memory DC. <br> <br>    hdcMem = CreateCompatibleDC(NULL); <br>    if (!hdcMem) { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>// Create a 24BPP RGB DIB section and select it into the memory DC. <br> <br>    pbmiRGB = (BITMAPINFO *) <br>              LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, sizeof(BITMAPINFO) ); <br>    if (!pbmiRGB) <br>    { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    pbmiRGB-&gt;bmiHeader.biSize          = sizeof(BITMAPINFOHEADER); <br>    pbmiRGB-&gt;bmiHeader.biWidth         = pbmiSource-&gt;bmiHeader.biWidth; <br>    pbmiRGB-&gt;bmiHeader.biHeight        = pbmiSource-&gt;bmiHeader.biHeight; <br>    pbmiRGB-&gt;bmiHeader.biPlanes        = 1; <br>    pbmiRGB-&gt;bmiHeader.biBitCount      = 24; <br>    pbmiRGB-&gt;bmiHeader.biCompression   = BI_RGB; <br>    pbmiRGB-&gt;bmiHeader.biSizeImage     = pbmiRGB-&gt;bmiHeader.biWidth <br>                                         * abs(pbmiRGB-&gt;bmiHeader.biHeight) * 3; <br> <br>    hbmRGB = CreateDIBSection(hdcMem, pbmiRGB, DIB_RGB_COLORS,  <br>                              (PVOID *) &amp;pjBitsRGB, NULL, 0); <br> <br>    if (!hbmRGB) <br>    { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    if (!SelectObject(hdcMem, hbmRGB)) <br>    { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>// Slam the DIB file image into the memory DC.  GDI will do the work of <br>// translating whatever format the DIB file has into RGB format. <br> <br>    if (!SetDIBits(hdcMem, hbmRGB, 0, pbmiSource-&gt;bmiHeader.biHeight,  <br>                   pvBits, pbmiSource, DIB_RGB_COLORS)) <br>    { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br>    GdiFlush();     // make sure that SetDIBits executes <br> <br>// Convert to TK image format (packed RGB format). <br>// Allocate with malloc to be consistent with tkRGBImageLoad (i.e., app <br>// can deallocate with free()). <br> <br>    pjTKBits = (PBYTE) malloc(pbmiRGB-&gt;bmiHeader.biSizeImage); <br>    if (!pjTKBits) <br>    { <br>        goto tkDIBLoadImage_cleanup; <br>    } <br> <br>    pjSrc = pjBitsRGB; <br>    pjDst = pjTKBits; <br>    // src lines end on LONG boundary - so need to skip over any padding bytes <br>    padBytes = pbmiSource-&gt;bmiHeader.biWidth % sizeof(LONG); <br>    for (i = 0; i &lt; pbmiSource-&gt;bmiHeader.biHeight; i++) <br>    { <br>        for (j = 0; j &lt; pbmiSource-&gt;bmiHeader.biWidth; j++) <br>        { <br>            // swap R and B <br>            *pjDst++ = pjSrc[2]; <br>            *pjDst++ = pjSrc[1]; <br>            *pjDst++ = pjSrc[0]; <br>            pjSrc += 3; <br>        } <br>        pjSrc += padBytes; <br>    } <br> <br>// Initialize the texture structure <br> <br>    // If we get to here, we have suceeded! <br>    ptex-&gt;width = pbmiSource-&gt;bmiHeader.biWidth; <br>    ptex-&gt;height = pbmiSource-&gt;bmiHeader.biHeight; <br>    ptex-&gt;format = GL_RGB; <br>    ptex-&gt;components = 3; <br>    ptex-&gt;data = pjTKBits; <br>    ptex-&gt;pal_size = 0; <br>    ptex-&gt;pal = NULL; <br> <br>    fSuccess = TRUE; <br>     <br>// Cleanup objects. <br> <br>tkDIBLoadImage_cleanup: <br>    { <br>        if (hdcMem) <br>            DeleteDC(hdcMem); <br> <br>        if (hbmRGB) <br>            DeleteObject(hbmRGB); <br> <br>        if (pbmiRGB) <br>            LocalFree(pbmiRGB); <br> <br>        if (pbmiSource) <br>            LocalFree(pbmiSource); <br>    } <br> <br>// Check for error. <br> <br>    if (!fSuccess) <br>    { <br>        if (pjTKBits) <br>            free(pjTKBits); <br>    } <br> <br>    return fSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bVerifyDIB <br>* <br>* Stripped down version of tkDIBImageLoadAW that verifies that a bitmap <br>* file is valid and, if so, returns the bitmap dimensions. <br>* <br>* Returns: <br>*   TRUE if valid bitmap file; otherwise, FALSE. <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>bVerifyDIB(LPTSTR pszFileName, ISIZE *pSize ) <br>{ <br>    BOOL bRet = FALSE; <br>    BITMAPFILEHEADER *pbmf;         // Ptr to file header <br>    BITMAPINFOHEADER *pbmihFile;    // Ptr to file's info header (if it exists) <br>    BITMAPCOREHEADER *pbmchFile;    // Ptr to file's core header (if it exists) <br> <br>    // These need to be cleaned up when we exit: <br>    HANDLE     hFile = INVALID_HANDLE_VALUE;        // File handle <br>    HANDLE     hMap = (HANDLE) NULL;                // Mapping object handle <br>    PVOID      pvFile = (PVOID) NULL;               // Ptr to mapped file <br> <br>// Map the DIB file into memory. <br> <br>    hFile = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, 0); <br>    if (hFile == INVALID_HANDLE_VALUE) <br>        goto bVerifyDIB_cleanup; <br> <br>    hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL); <br>    if (!hMap) <br>        goto bVerifyDIB_cleanup; <br> <br>    pvFile = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0); <br>    if (!pvFile) <br>        goto bVerifyDIB_cleanup; <br> <br>// Check the file header.  If the BFT_BITMAP magic number is there, <br>// then the file format is a BITMAPFILEHEADER followed immediately <br>// by either a BITMAPINFOHEADER or a BITMAPCOREHEADER.  The bitmap <br>// bits, in this case, are located at the offset bfOffBits from the <br>// BITMAPFILEHEADER. <br>// <br>// Otherwise, this may be a raw BITMAPINFOHEADER or BITMAPCOREHEADER <br>// followed immediately with the color table and the bitmap bits. <br> <br>    pbmf = (BITMAPFILEHEADER *) pvFile; <br> <br>    if ( pbmf-&gt;bfType == BFT_BITMAP ) <br>        pbmihFile = (BITMAPINFOHEADER *) ((PBYTE) pbmf + SIZEOF_BITMAPFILEHEADER); <br>    else <br>        pbmihFile = (BITMAPINFOHEADER *) pvFile; <br> <br>// Get the width and height from whatever header we have. <br>// <br>// We distinguish between BITMAPINFO and BITMAPCORE cases based upon <br>// BITMAPINFOHEADER.biSize. <br> <br>    // Note: need to use safe READDWORD macro because pbmihFile may <br>    // have only WORD alignment if it follows a BITMAPFILEHEADER. <br> <br>    switch (READDWORD(&amp;pbmihFile-&gt;biSize)) <br>    { <br>    case sizeof(BITMAPINFOHEADER): <br> <br>        if( pSize != NULL ) { <br>            pSize-&gt;width  = READDWORD(&amp;pbmihFile-&gt;biWidth); <br>            pSize-&gt;height = READDWORD(&amp;pbmihFile-&gt;biHeight); <br>        } <br>        bRet = TRUE; <br> <br>        break; <br> <br>    case sizeof(BITMAPCOREHEADER): <br>        pbmchFile = (BITMAPCOREHEADER *) pbmihFile; <br> <br>    // Convert BITMAPCOREHEADER to BITMAPINFOHEADER. <br> <br>        if( pSize != NULL ) { <br>            pSize-&gt;width  = (DWORD) pbmchFile-&gt;bcWidth; <br>            pSize-&gt;height = (DWORD) pbmchFile-&gt;bcHeight; <br>        } <br>        bRet = TRUE; <br> <br>        break; <br> <br>    default: <br>        break; <br>    } <br> <br>bVerifyDIB_cleanup: <br> <br>    if (pvFile) <br>        UnmapViewOfFile(pvFile); <br> <br>    if (hMap) <br>        CloseHandle(hMap); <br> <br>    if (hFile != INVALID_HANDLE_VALUE) <br>        CloseHandle(hFile); <br> <br>    return bRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
