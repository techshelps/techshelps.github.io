<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OBJECTS.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3750"></a>OBJECTS.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: objects.cxx <br>* <br>* Creates command lists for pipe primitive objects <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include "sscommon.h" <br>#include "objects.h" <br>#include "sspipes.h" <br> <br>#define ROOT_TWO 1.414213562373f <br> <br>/**************************************************************************\ <br>* OBJECT constructor <br>* <br>\**************************************************************************/ <br>OBJECT::OBJECT( ) <br>{ <br>    listNum = glGenLists(1); <br>} <br> <br>/**************************************************************************\ <br>* OBJECT destructor <br>* <br>\**************************************************************************/ <br>OBJECT::~OBJECT( ) <br>{ <br>    glDeleteLists( listNum, 1 ); <br>} <br> <br>/**************************************************************************\ <br>* Draw <br>* <br>* - Draw the object by calling its display list <br>* <br>\**************************************************************************/ <br>void <br>OBJECT::Draw( ) <br>{ <br>    glCallList( listNum ); <br>} <br> <br>/**************************************************************************\ <br>* PIPE_OBJECT constructors <br>* <br>\**************************************************************************/ <br>PIPE_OBJECT::PIPE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float len ) <br>{ <br>    Build( pBuildInfo, len, 0.0f, 0.0f ); <br>} <br> <br>PIPE_OBJECT::PIPE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float len, float s_start, float s_end ) <br>{ <br>    Build( pBuildInfo, len, s_start, s_end ); <br>} <br> <br>/**************************************************************************\ <br>* ELBOW_OBJECT constructors <br>* <br>\**************************************************************************/ <br>ELBOW_OBJECT::ELBOW_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, int notch ) <br>{ <br>    Build( pBuildInfo, notch, 0.0f, 0.0f ); <br>} <br> <br>ELBOW_OBJECT::ELBOW_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end ) <br>{ <br>    Build( pBuildInfo, notch, s_start, s_end ); <br>} <br> <br>/**************************************************************************\ <br>* BALLJOINT_OBJECT constructor <br>* <br>\**************************************************************************/ <br>BALLJOINT_OBJECT::BALLJOINT_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end ) <br>{ <br>    Build( pBuildInfo, notch, s_start, s_end ); <br>} <br> <br>/**************************************************************************\ <br>* SPHERE_OBJECT constructors <br>* <br>\**************************************************************************/ <br>SPHERE_OBJECT::SPHERE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float radius ) <br>{ <br>    Build( pBuildInfo, radius, 0.0f, 0.0f ); <br>} <br> <br>SPHERE_OBJECT::SPHERE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float radius, float s_start, float s_end ) <br>{ <br>    Build( pBuildInfo, radius, s_start, s_end ); <br>} <br> <br> <br>// rotate circle around x-axis, with edge attached to anchor <br> <br>static void TransformCircle(  <br>    float angle,  <br>    POINT3D *inPoint,  <br>    POINT3D *outPoint,  <br>    GLint num, <br>    POINT3D *anchor ) <br>{ <br>    MATRIX matrix1, matrix2, matrix3; <br>    int i; <br> <br>    // translate anchor point to origin <br>    ss_matrixIdent( &amp;matrix1 ); <br>    ss_matrixTranslate( &amp;matrix1, -anchor-&gt;x, -anchor-&gt;y, -anchor-&gt;z ); <br> <br>    // rotate by angle, cw around x-axis <br>    ss_matrixIdent( &amp;matrix2 ); <br>    ss_matrixRotate( &amp;matrix2, (double) -angle, 0.0, 0.0 ); <br> <br>    // concat these 2 <br>    ss_matrixMult( &amp;matrix3, &amp;matrix2, &amp;matrix1 ); <br> <br>    // translate back <br>    ss_matrixIdent( &amp;matrix2 ); <br>    ss_matrixTranslate( &amp;matrix2,  anchor-&gt;x,  anchor-&gt;y,  anchor-&gt;z ); <br> <br>    // concat these 2 <br>    ss_matrixMult( &amp;matrix1, &amp;matrix2, &amp;matrix3 ); <br> <br>    // transform all the points, + center <br>    for( i = 0; i &lt; num; i ++, outPoint++, inPoint++ ) { <br>        ss_xformPoint( outPoint, inPoint, &amp;matrix1 ); <br>    } <br>} <br> <br>static void CalcNormals( POINT3D *p, POINT3D *n, POINT3D *center, <br>                         int num ) <br>{ <br>    int i; <br> <br>    for( i = 0; i &lt; num; i ++, n++, p++ ) { <br>        n-&gt;x = p-&gt;x - center-&gt;x; <br>        n-&gt;y = p-&gt;y - center-&gt;y; <br>        n-&gt;z = p-&gt;z - center-&gt;z; <br>        ss_normalizeNorm( n ); <br>    } <br>} <br> <br>/*----------------------------------------------------------------------\ <br>|    MakeQuadStrip()                                                    | <br>|       - builds quadstrip between 2 rows of points. pA points to one   | <br>|         row of points, and pB to the next rotated row.  Because       | <br>|         the rotation has previously been defined CCW around the       | <br>|         x-axis, using an A-B sequence will result in CCW quads        | <br>|                                                                       | <br>\----------------------------------------------------------------------*/ <br>static void MakeQuadStrip <br>( <br>    POINT3D *pA,  <br>    POINT3D *pB,  <br>    POINT3D *nA,  <br>    POINT3D *nB,  <br>    BOOL    bTexture, <br>    GLfloat *tex_s, <br>    GLfloat *tex_t, <br>    GLint slices <br>) <br>{ <br>    GLint i; <br> <br>    glBegin( GL_QUAD_STRIP ); <br> <br>    for( i = 0; i &lt; slices; i ++ ) { <br>        glNormal3fv( (GLfloat *) nA++ ); <br>        if( bTexture ) <br>            glTexCoord2f( tex_s[0], *tex_t ); <br>        glVertex3fv( (GLfloat *) pA++ ); <br>        glNormal3fv( (GLfloat *) nB++ ); <br>        if( bTexture ) <br>            glTexCoord2f( tex_s[1], *tex_t++ ); <br>        glVertex3fv( (GLfloat *) pB++ ); <br>    } <br> <br>    glEnd(); <br>} <br> <br>#define CACHE_SIZE      100      <br> <br> <br>/*----------------------------------------------------------------------\ <br>|    BuildElbow()                                                      | <br>|       - builds elbows, by rotating a circle in the y=r plane          | <br>|         centered at (0,r,-r), CW around the x-axis at anchor pt.      | <br>|         (r = radius of the circle)                                    | <br>|       - rotation is 90.0 degrees, ending at circle in z=0 plane,      | <br>|         centered at origin.                                           | <br>|       - in order to 'mate' texture coords with the cylinders          | <br>|         generated with glu, we generate 4 elbows, each corresponding  | <br>|         to the 4 possible CW 90 degree orientations of the start point| <br>|         for each circle.                                              | <br>|       - We call this start point the 'notch'.  If we characterize     | <br>|         each notch by the axis it points down in the starting and     | <br>|         ending circles of the elbow, then we get the following axis   | <br>|         pairs for our 4 notches:                                      | <br>|               - +z,+y                                                 | <br>|               - +x,+x                                                 | <br>|               - -z,-y                                                 | <br>|               - -x,-x                                                 | <br>|         Since the start of the elbow always points down +y, the 4     | <br>|         start notches give all possible 90.0 degree orientations      | <br>|         around y-axis.                                                | <br>|       - We can keep track of the current 'notch' vector to provide    | <br>|         proper mating between primitives.                             | <br>|       - Each circle of points is described CW from the start point,   | <br>|         assuming looking down the +y axis(+y direction).              | <br>|       - texture 's' starts at 0.0, and goes to 2.0*r/divSize at       | <br>|         end of the elbow.  (Then a short pipe would start with this   | <br>|         's', and run it to 1.0).                                      | <br>|                                                                       | <br>\----------------------------------------------------------------------*/ <br>void <br>ELBOW_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end ) <br>{ <br>    GLint   stacks, slices; <br>    GLfloat angle, startAng; <br>    GLint numPoints; <br>    GLfloat s_delta; <br>    POINT3D pi[CACHE_SIZE]; // initial row of points + center <br>    POINT3D p0[CACHE_SIZE]; // 2 rows of points <br>    POINT3D p1[CACHE_SIZE]; <br>    POINT3D n0[CACHE_SIZE]; // 2 rows of normals <br>    POINT3D n1[CACHE_SIZE]; <br>    GLfloat tex_t[CACHE_SIZE];// 't' texture coords <br>    GLfloat tex_s[2];  // 's' texture coords <br>    POINT3D center;  // center of circle <br>    POINT3D anchor;  // where circle is anchored <br>    POINT3D *pA, *pB, *nA, *nB; <br>    int i; <br>    IPOINT2D *texRep = pBuildInfo-&gt;texRep; <br>    GLfloat radius = pBuildInfo-&gt;radius; <br>    BOOL    bTexture = pBuildInfo-&gt;bTexture; <br> <br>    slices = pBuildInfo-&gt;nSlices; <br>    stacks = slices / 2; <br> <br>    if (slices &gt;= CACHE_SIZE) slices = CACHE_SIZE-1; <br>    if (stacks &gt;= CACHE_SIZE) stacks = CACHE_SIZE-1; <br> <br>    s_delta = s_end - s_start; <br>  <br>    if( bTexture ) { <br>        // calculate 't' texture coords <br>        for( i = 0; i &lt;= slices; i ++ ) { <br>            tex_t[i] = (GLfloat) i * texRep-&gt;y / slices; <br>        } <br>    } <br> <br>    numPoints = slices + 1; <br> <br>        // starting angle increment 90.0 degrees each time <br>        startAng = notch * PI / 2; <br> <br>        // calc initial circle of points for circle centered at 0,r,-r <br>        // points start at (0,r,0), and rotate circle CCW <br> <br>        for( i = 0; i &lt;= slices; i ++ ) { <br>            angle = startAng + (2 * PI * i / slices); <br>            pi[i].x = radius * (float) sin(angle); <br>            pi[i].y = radius; <br>            // translate z by -r, cuz these cos calcs are for circle at origin <br>            pi[i].z = radius * (float) cos(angle) - radius; <br>        } <br> <br>        // center point, tacked onto end of circle of points <br>        pi[i].x =  0.0f; <br>        pi[i].y =  radius; <br>        pi[i].z = -radius; <br>        center = pi[i]; <br>     <br>        // anchor point <br>        anchor.x = anchor.z = 0.0f; <br>        anchor.y = radius; <br> <br>        // calculate initial normals <br>        CalcNormals( pi, n0, &amp;center, numPoints ); <br> <br>        // initial 's' texture coordinate <br>        tex_s[0] = s_start; <br> <br>        // setup pointers <br>        pA = pi; <br>        pB = p0; <br>        nA = n0; <br>        nB = n1; <br> <br>        // now iterate throught the stacks <br> <br>        glNewList(listNum, GL_COMPILE); <br> <br>        for( i = 1; i &lt;= stacks; i ++ ) { <br>            // ! this angle must be negative, for correct vertex orientation ! <br>            angle = - 0.5f * PI * i / stacks; <br> <br>            // transform to get next circle of points + center <br>            TransformCircle( angle, pi, pB, numPoints+1, &amp;anchor ); <br> <br>            // calculate normals <br>            center = pB[numPoints]; <br>            CalcNormals( pB, nB, &amp;center, numPoints ); <br> <br>            // calculate next 's' texture coord <br>            tex_s[1] = (GLfloat) s_start + s_delta * i / stacks; <br> <br>            // now we've got points and normals, ready to be quadstrip'd <br>            MakeQuadStrip( pA, pB, nA, nB, bTexture, tex_s, tex_t, numPoints ); <br> <br>            // reset pointers <br>            pA = pB; <br>            nA = nB; <br>            pB = (pB == p0) ? p1 : p0; <br>            nB = (nB == n0) ? n1 : n0; <br>            tex_s[0] = tex_s[1]; <br>        } <br> <br>        glEndList(); <br>} <br> <br>/*----------------------------------------------------------------------\ <br>|    BuildBallJoint()                                                  | <br>|       - These are very similar to the elbows, in that the starting    | <br>|         and ending positions are almost identical.   The difference   | <br>|         here is that the circles in the sweep describe a sphere as    | <br>|         they are rotated.                                             | <br>|                                                                       | <br>\----------------------------------------------------------------------*/ <br>void  <br>BALLJOINT_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch,  <br>                         float s_start, float s_end ) <br>{ <br>    GLfloat ballRadius; <br>    GLfloat angle, delta_a, startAng, theta; <br>    GLint numPoints; <br>    GLfloat s_delta; <br>    POINT3D pi0[CACHE_SIZE]; // 2 circles of untransformed points <br>    POINT3D pi1[CACHE_SIZE]; <br>    POINT3D p0[CACHE_SIZE]; // 2 rows of transformed points <br>    POINT3D p1[CACHE_SIZE]; <br>    POINT3D n0[CACHE_SIZE]; // 2 rows of normals <br>    POINT3D n1[CACHE_SIZE]; <br>    float   r[CACHE_SIZE];  // radii of the circles <br>    GLfloat tex_t[CACHE_SIZE];// 't' texture coords <br>    GLfloat tex_s[2];  // 's' texture coords <br>    POINT3D center;  // center of circle <br>    POINT3D anchor;  // where circle is anchored <br>    POINT3D *pA, *pB, *nA, *nB; <br>    int i, k; <br>    GLint   stacks, slices; <br>    IPOINT2D *texRep = pBuildInfo-&gt;texRep; <br>    GLfloat radius = pBuildInfo-&gt;radius; <br>    BOOL    bTexture = pBuildInfo-&gt;bTexture; <br> <br>    slices = pBuildInfo-&gt;nSlices; <br>    stacks = slices; <br> <br>    if (slices &gt;= CACHE_SIZE) slices = CACHE_SIZE-1; <br>    if (stacks &gt;= CACHE_SIZE) stacks = CACHE_SIZE-1; <br> <br>    // calculate the radii for each circle in the sweep, where <br>    // r[i] = y = sin(angle)/r <br> <br>    angle = PI / 4;  // first radius always at 45.0 degrees <br>    delta_a = (PI / 2.0f) / stacks; <br> <br>    ballRadius = ROOT_TWO * radius; <br>    for( i = 0; i &lt;= stacks; i ++, angle += delta_a ) { <br>        r[i] = (float) sin(angle) * ballRadius; <br>    } <br> <br>    if( bTexture ) { <br>        // calculate 't' texture coords <br>        for( i = 0; i &lt;= slices; i ++ ) { <br>            tex_t[i] = (GLfloat) i * texRep-&gt;y / slices; <br>        } <br>    } <br> <br>    s_delta = s_end - s_start; <br>  <br>    numPoints = slices + 1; <br> <br>    // unlike the elbow, the center for the ball joint is constant <br>    center.x = center.y = 0.0f; <br>    center.z = -radius; <br> <br>        // starting angle along circle, increment 90.0 degrees each time <br>        startAng = notch * PI / 2; <br> <br>        // calc initial circle of points for circle centered at 0,r,-r <br>        // points start at (0,r,0), and rotate circle CCW <br> <br>        delta_a = 2 * PI / slices; <br>        for( i = 0, theta = startAng; i &lt;= slices; i ++, theta += delta_a ) { <br>            pi0[i].x = r[0] * (float) sin(theta); <br>            pi0[i].y = radius; <br>            // translate z by -r, cuz these cos calcs are for circle at origin <br>            pi0[i].z = r[0] * (float) cos(theta) - r[0]; <br>        } <br> <br>        // anchor point <br>        anchor.x = anchor.z = 0.0f; <br>        anchor.y = radius; <br> <br>        // calculate initial normals <br>        CalcNormals( pi0, n0, &amp;center, numPoints ); <br> <br>        // initial 's' texture coordinate <br>        tex_s[0] = s_start; <br> <br>        // setup pointers <br>        pA = pi0; // circles of transformed points <br>        pB = p0; <br>        nA = n0; // circles of transformed normals <br>        nB = n1; <br> <br>        // now iterate throught the stacks <br> <br>        glNewList(listNum, GL_COMPILE); <br> <br>        for( i = 1; i &lt;= stacks; i ++ ) { <br>            // ! this angle must be negative, for correct vertex orientation ! <br>            angle = - 0.5f * PI * i / stacks; <br> <br>            // calc the next circle of untransformed points into pi1[] <br> <br>            for( k = 0, theta = startAng; k &lt;= slices; k ++, theta+=delta_a ) { <br>                pi1[k].x = r[i] * (float) sin(theta); <br>                pi1[k].y = radius; <br>                // translate z by -r, cuz calcs are for circle at origin <br>                pi1[k].z = r[i] * (float) cos(theta) - r[i]; <br>            } <br> <br>            // rotate cirle of points to next position <br>            TransformCircle( angle, pi1, pB, numPoints, &amp;anchor ); <br> <br>            // calculate normals <br>            CalcNormals( pB, nB, &amp;center, numPoints ); <br> <br>            // calculate next 's' texture coord <br>            tex_s[1] = (GLfloat) s_start + s_delta * i / stacks; <br> <br>            // now we've got points and normals, ready to be quadstrip'd <br>            MakeQuadStrip( pA, pB, nA, nB, bTexture, tex_s, tex_t, numPoints ); <br> <br>            // reset pointers <br>            pA = pB; <br>            nA = nB; <br>            pB = (pB == p0) ? p1 : p0; <br>            nB = (nB == n0) ? n1 : n0; <br>            tex_s[0] = tex_s[1]; <br>        } <br> <br>        glEndList(); <br>} <br> <br>// 'glu' routines <br> <br>#ifdef _EXTENSIONS_ <br>#define COS cosf <br>#define SIN sinf <br>#define SQRT sqrtf <br>#else <br>#define COS cos <br>#define SIN sin <br>#define SQRT sqrt <br>#endif <br> <br> <br>/**************************************************************************\ <br>* BuildCylinder <br>* <br>\**************************************************************************/ <br>void <br>PIPE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, float length, float s_start,  <br>                            float s_end ) <br>{ <br>    GLint   stacks, slices; <br>    GLint   i,j; <br>    GLfloat sinCache[CACHE_SIZE]; <br>    GLfloat cosCache[CACHE_SIZE]; <br>    GLfloat sinCache2[CACHE_SIZE]; <br>    GLfloat cosCache2[CACHE_SIZE]; <br>    GLfloat angle; <br>    GLfloat zLow, zHigh; <br>    GLfloat zNormal; <br>    GLfloat s_delta; <br>    IPOINT2D *texRep = pBuildInfo-&gt;texRep; <br>    GLfloat radius = pBuildInfo-&gt;radius; <br>    BOOL    bTexture = pBuildInfo-&gt;bTexture; <br> <br>    slices = pBuildInfo-&gt;nSlices; <br>    stacks = (int) SS_ROUND_UP( (length/pBuildInfo-&gt;divSize) * (float)slices) ; <br> <br>    if (slices &gt;= CACHE_SIZE) slices = CACHE_SIZE-1; <br>    if (stacks &gt;= CACHE_SIZE) stacks = CACHE_SIZE-1; <br> <br>    zNormal = 0.0f; <br> <br>    s_delta = s_end - s_start; <br> <br>    for (i = 0; i &lt; slices; i++) { <br>        angle = 2 * PI * i / slices; <br>        sinCache2[i] = (float) SIN(angle); <br>        cosCache2[i] = (float) COS(angle); <br>        sinCache[i] = (float) SIN(angle); <br>        cosCache[i] = (float) COS(angle); <br>    } <br> <br>    sinCache[slices] = sinCache[0]; <br>    cosCache[slices] = cosCache[0]; <br>    sinCache2[slices] = sinCache2[0]; <br>    cosCache2[slices] = cosCache2[0]; <br> <br>    glNewList(listNum, GL_COMPILE); <br> <br>        for (j = 0; j &lt; stacks; j++) { <br>            zLow = j * length / stacks; <br>            zHigh = (j + 1) * length / stacks; <br> <br>            glBegin(GL_QUAD_STRIP); <br>            for (i = 0; i &lt;= slices; i++) { <br>                    glNormal3f(sinCache2[i], cosCache2[i], zNormal); <br>                    if (bTexture) { <br>                        glTexCoord2f( (float) s_start + s_delta * j / stacks, <br>                                      (float) i * texRep-&gt;y / slices ); <br>                    } <br>                    glVertex3f(radius * sinCache[i],  <br>                            radius * cosCache[i], zLow); <br>                    if (bTexture) { <br>                        glTexCoord2f( (float) s_start + s_delta*(j+1) / stacks, <br>                                      (float) i * texRep-&gt;y / slices ); <br>                    } <br>                    glVertex3f(radius * sinCache[i],  <br>                            radius * cosCache[i], zHigh); <br>            } <br>            glEnd(); <br>        } <br> <br>    glEndList(); <br>} <br> <br> <br>/*----------------------------------------------------------------------\ <br>|    pipeSphere()                                                       | <br>|                                                                       | <br>\----------------------------------------------------------------------*/ <br>void  <br>SPHERE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, GLfloat radius,  <br>                      GLfloat s_start, GLfloat s_end) <br>{ <br>    GLint i,j; <br>    GLfloat sinCache1a[CACHE_SIZE]; <br>    GLfloat cosCache1a[CACHE_SIZE]; <br>    GLfloat sinCache2a[CACHE_SIZE]; <br>    GLfloat cosCache2a[CACHE_SIZE]; <br>    GLfloat sinCache1b[CACHE_SIZE]; <br>    GLfloat cosCache1b[CACHE_SIZE]; <br>    GLfloat sinCache2b[CACHE_SIZE]; <br>    GLfloat cosCache2b[CACHE_SIZE]; <br>    GLfloat angle; <br>    GLfloat zLow, zHigh; <br>    GLfloat sintemp1, sintemp2, sintemp3, sintemp4; <br>    GLfloat costemp3, costemp4; <br>    GLfloat s_delta; <br>    GLint start, finish; <br>    GLint   stacks, slices; <br>    BOOL    bTexture = pBuildInfo-&gt;bTexture; <br>    IPOINT2D *texRep = pBuildInfo-&gt;texRep; <br> <br>    slices = pBuildInfo-&gt;nSlices; <br>    stacks = slices; <br>    if (slices &gt;= CACHE_SIZE) slices = CACHE_SIZE-1; <br>    if (stacks &gt;= CACHE_SIZE) stacks = CACHE_SIZE-1; <br> <br>    // invert sense of s - it seems the glu sphere is not built similarly <br>    // to the glu cylinder <br>    // (this probably means stacks don't grow along +z - check it out) <br>    s_delta = s_start; <br>    s_start = s_end; <br>    s_end = s_delta;  <br> <br>    s_delta = s_end - s_start; <br> <br>    /* Cache is the vertex locations cache */ <br>    /* Cache2 is the various normals at the vertices themselves */ <br> <br>    for (i = 0; i &lt; slices; i++) { <br>        angle = 2 * PI * i / slices; <br>        sinCache1a[i] = (float) SIN(angle); <br>        cosCache1a[i] = (float) COS(angle); <br>            sinCache2a[i] = sinCache1a[i]; <br>            cosCache2a[i] = cosCache1a[i]; <br>    } <br> <br>    for (j = 0; j &lt;= stacks; j++) { <br>        angle = PI * j / stacks; <br>                sinCache2b[j] = (float) SIN(angle); <br>                cosCache2b[j] = (float) COS(angle); <br>        sinCache1b[j] = radius * (float) SIN(angle); <br>        cosCache1b[j] = radius * (float) COS(angle); <br>    } <br>    /* Make sure it comes to a point */ <br>    sinCache1b[0] = 0.0f; <br>    sinCache1b[stacks] = 0.0f; <br> <br>    sinCache1a[slices] = sinCache1a[0]; <br>    cosCache1a[slices] = cosCache1a[0]; <br>        sinCache2a[slices] = sinCache2a[0]; <br>        cosCache2a[slices] = cosCache2a[0]; <br> <br>    glNewList(listNum, GL_COMPILE); <br> <br>        /* Do ends of sphere as TRIANGLE_FAN's (if not bTexture) <br>        ** We don't do it when bTexture because we need to respecify the <br>        ** texture coordinates of the apex for every adjacent vertex (because <br>        ** it isn't a constant for that point) <br>        */ <br>        if (!bTexture) { <br>            start = 1; <br>            finish = stacks - 1; <br> <br>            /* Low end first (j == 0 iteration) */ <br>            sintemp2 = sinCache1b[1]; <br>            zHigh = cosCache1b[1]; <br>                sintemp3 = sinCache2b[1]; <br>                costemp3 = cosCache2b[1]; <br>                glNormal3f(sinCache2a[0] * sinCache2b[0], <br>                        cosCache2a[0] * sinCache2b[0], <br>                        cosCache2b[0]); <br> <br>            glBegin(GL_TRIANGLE_FAN); <br>            glVertex3f(0.0f, 0.0f, radius); <br> <br>                for (i = slices; i &gt;= 0; i--) { <br>                        glNormal3f(sinCache2a[i] * sintemp3, <br>                                cosCache2a[i] * sintemp3, <br>                                costemp3); <br>                    glVertex3f(sintemp2 * sinCache1a[i], <br>                            sintemp2 * cosCache1a[i], zHigh); <br>                } <br>            glEnd(); <br> <br>            /* High end next (j == stacks-1 iteration) */ <br>            sintemp2 = sinCache1b[stacks-1]; <br>            zHigh = cosCache1b[stacks-1]; <br>                sintemp3 = sinCache2b[stacks-1]; <br>                costemp3 = cosCache2b[stacks-1]; <br>                glNormal3f(sinCache2a[stacks] * sinCache2b[stacks], <br>                        cosCache2a[stacks] * sinCache2b[stacks], <br>                        cosCache2b[stacks]); <br>            glBegin(GL_TRIANGLE_FAN); <br>            glVertex3f(0.0f, 0.0f, -radius); <br>                for (i = 0; i &lt;= slices; i++) { <br>                        glNormal3f(sinCache2a[i] * sintemp3, <br>                                cosCache2a[i] * sintemp3, <br>                                costemp3); <br>                    glVertex3f(sintemp2 * sinCache1a[i], <br>                            sintemp2 * cosCache1a[i], zHigh); <br>                } <br>            glEnd(); <br>        } else { <br>            start = 0; <br>            finish = stacks; <br>        } <br>        for (j = start; j &lt; finish; j++) { <br>            zLow = cosCache1b[j]; <br>            zHigh = cosCache1b[j+1]; <br>            sintemp1 = sinCache1b[j]; <br>            sintemp2 = sinCache1b[j+1]; <br>                    sintemp3 = sinCache2b[j+1]; <br>                    costemp3 = cosCache2b[j+1]; <br>                    sintemp4 = sinCache2b[j]; <br>                    costemp4 = cosCache2b[j]; <br> <br>            glBegin(GL_QUAD_STRIP); <br>            for (i = 0; i &lt;= slices; i++) { <br>                    glNormal3f(sinCache2a[i] * sintemp3, <br>                            cosCache2a[i] * sintemp3, <br>                            costemp3); <br>                    if (bTexture) { <br>                        glTexCoord2f( (float) s_start + s_delta*(j+1) / stacks, <br>                                      (float) i * texRep-&gt;y / slices ); <br>                    } <br>                    glVertex3f(sintemp2 * sinCache1a[i], <br>                            sintemp2 * cosCache1a[i], zHigh); <br>                    glNormal3f(sinCache2a[i] * sintemp4, <br>                            cosCache2a[i] * sintemp4, <br>                            costemp4); <br>                    if (bTexture) { <br>                        glTexCoord2f( (float) s_start + s_delta * j / stacks, <br>                                      (float) i * texRep-&gt;y / slices ); <br>                    } <br>                    glVertex3f(sintemp1 * sinCache1a[i], <br>                            sintemp1 * cosCache1a[i], zLow); <br>            } <br>            glEnd(); <br>        } <br> <br>    glEndList(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
