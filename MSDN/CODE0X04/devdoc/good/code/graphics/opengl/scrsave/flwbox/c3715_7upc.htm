<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSFLWBOX.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3720"></a>SSFLWBOX.C</h2>
<pre><code>/**********************************Module**********************************\ <br>* <br>* ssflwbox.c <br>* <br>* 3D FlowerBox screen saver <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include "precomp.h" <br>#pragma hdrstop <br> <br>// Minimum and maximum image sizes <br>#define MINIMAGESIZE 10 <br>#define MAXIMAGESIZE 100 <br> <br>// Color tables for checkboard, per-side and single color modes <br>GLfloat base_checker_cols[MAXSIDES][NCCOLS][4] = <br>{ <br>    1.0f, 0.0f, 0.0f, 1.0f, <br>    0.0f, 1.0f, 0.0f, 1.0f, <br>    0.0f, 1.0f, 0.0f, 1.0f, <br>    0.0f, 0.0f, 1.0f, 1.0f, <br>    0.0f, 0.0f, 1.0f, 1.0f, <br>    1.0f, 0.0f, 1.0f, 1.0f, <br>    1.0f, 0.0f, 1.0f, 1.0f, <br>    0.0f, 1.0f, 1.0f, 1.0f, <br>    0.0f, 1.0f, 1.0f, 1.0f, <br>    1.0f, 1.0f, 0.0f, 1.0f, <br>    1.0f, 1.0f, 0.0f, 1.0f, <br>    0.5f, 0.5f, 1.0f, 1.0f, <br>    0.5f, 0.5f, 1.0f, 1.0f, <br>    1.0f, 0.5f, 0.5f, 1.0f, <br>    1.0f, 0.5f, 0.5f, 1.0f, <br>    1.0f, 0.0f, 0.0f, 1.0f <br>}; <br>GLfloat checker_cols[MAXSIDES][NCCOLS][4]; <br> <br>GLfloat base_side_cols[MAXSIDES][4] = <br>{ <br>    1.0f, 0.0f, 0.0f, 1.0f, <br>    0.0f, 1.0f, 0.0f, 1.0f, <br>    0.0f, 0.0f, 1.0f, 1.0f, <br>    1.0f, 0.0f, 1.0f, 1.0f, <br>    0.0f, 1.0f, 1.0f, 1.0f, <br>    1.0f, 1.0f, 0.0f, 1.0f, <br>    0.5f, 0.5f, 1.0f, 1.0f, <br>    1.0f, 0.5f, 0.5f, 1.0f <br>}; <br>GLfloat side_cols[MAXSIDES][4]; <br> <br>GLfloat base_solid_cols[4] = <br>{ <br>    1.0f, 1.0f, 1.0f, 1.0f <br>}; <br>GLfloat solid_cols[4]; <br> <br>// Current geometry <br>GEOMETRY *cur_geom; <br> <br>// Set when a rendering context is available <br>BOOL gbGlInit = FALSE; <br> <br>// Common library context <br>SSContext gssc; <br> <br>// Spin rotations <br>double xr = 0, yr = 0, zr = 0; <br>// Scale factor and increment <br>FLT sf; <br>FLT sfi; <br>// Color cycling hue phase <br>FLT phase = 0.0f; <br> <br>// Default configuration <br>CONFIG config = <br>{ <br>    TRUE, FALSE, FALSE, TRUE, TRUE, MAXSUBDIV, ID_COL_PER_SIDE, <br>    (MAXIMAGESIZE+MINIMAGESIZE)/2, GEOM_CUBE, GL_FRONT <br>}; <br> <br>// A slider range <br>typedef struct _RANGE <br>{ <br>    int min_val; <br>    int max_val; <br>    int step; <br>    int page_step; <br>} RANGE; <br> <br>RANGE complexity_range = {MINSUBDIV, MAXSUBDIV, 1, 2}; <br>RANGE image_size_range = {MINIMAGESIZE, MAXIMAGESIZE, 1, 10}; <br> <br>// True if the current OpenGL version is 1.1 <br>BOOL bOgl11; <br> <br>// True if checkered mode is on <br>BOOL bCheckerOn; <br> <br>/******************************Public*Routine******************************\ <br>* <br>* dprintf <br>* <br>* Debug output printf <br>* <br>\**************************************************************************/ <br> <br>#if DBG <br>void dprintf_out(char *fmt, ...) <br>{ <br>    va_list args; <br>    char dbg[256]; <br> <br>    va_start(args, fmt); <br>    vsprintf(dbg, fmt, args); <br>    va_end(args); <br>    OutputDebugStringA(dbg); <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* <br>* assert_failed <br>* <br>* Assertion failure handler <br>* <br>\**************************************************************************/ <br> <br>#if DBG <br>void assert_failed(char *file, int line, char *msg) <br>{ <br>    dprintf(("Assertion failed %s(%d): %s\n", file, line, msg)); <br>    DebugBreak(); <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* <br>* V3Len <br>* <br>* Vector length <br>* <br>\**************************************************************************/ <br> <br>FLT V3Len(PT3 *v) <br>{ <br>    return (FLT)sqrt(v-&gt;x*v-&gt;x+v-&gt;y*v-&gt;y+v-&gt;z*v-&gt;z); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ComputeHsvColors <br>* <br>* Compute a smooth range of colors depending on the current color mode <br>* <br>\**************************************************************************/ <br> <br>void ComputeHsvColors(void) <br>{ <br>    GLfloat *cols; <br>    int ncols; <br>    FLT ang, da; <br>    int hex; <br>    FLT fhex, frac; <br>    FLT p, q, t; <br>    FLT sat, val; <br> <br>    switch(config.color_pick) <br>    { <br>    case ID_COL_CHECKER: <br>        ncols = MAXSIDES*NCCOLS; <br>        cols = &amp;checker_cols[0][0][0]; <br>        break; <br>    case ID_COL_PER_SIDE: <br>        ncols = MAXSIDES; <br>        cols = &amp;side_cols[0][0]; <br>        break; <br>    case ID_COL_SINGLE: <br>        ncols = 1; <br>        cols = &amp;solid_cols[0]; <br>        break; <br>    } <br> <br>    ang = phase; <br>    da = (FLT)((2*PI)/ncols); <br>    val = sat = 1.0f; <br> <br>    while (ncols &gt; 0) <br>    { <br>        fhex = (FLT)(6*ang/(2*PI)); <br>        hex = (int)fhex; <br>        frac = fhex-hex; <br>        hex = hex % 6; <br>         <br>p = val*(1-sat); <br>q = val*(1-sat*frac); <br>t = val*(1-sat*(1-frac)); <br>         <br>switch(hex) <br>{ <br>case 0: <br>            cols[0] = val; <br>            cols[1] = t; <br>            cols[2] = p; <br>    break; <br>case 1: <br>            cols[0] = q; <br>            cols[1] = val; <br>            cols[2] = p; <br>    break; <br>case 2: <br>            cols[0] = p; <br>            cols[1] = val; <br>            cols[2] = t; <br>    break; <br>case 3: <br>            cols[0] = p; <br>            cols[1] = q; <br>            cols[2] = val; <br>    break; <br>case 4: <br>            cols[0] = t; <br>            cols[1] = p; <br>            cols[2] = val; <br>            break; <br>case 5: <br>            cols[0] = val; <br>            cols[1] = p; <br>            cols[2] = q; <br>    break; <br>} <br> <br>        ang += da; <br>        cols += 4; <br>        ncols--; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* Draw <br>* <br>* Draw everything <br>* <br>\**************************************************************************/ <br> <br>void Draw(void) <br>{ <br>    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <br> <br>    glLoadIdentity(); <br> <br>    glRotated(xr, 1, 0, 0); <br>    glRotated(yr, 0, 1, 0); <br>    glRotated(zr, 0, 0, 1); <br> <br>    DrawGeom(cur_geom); <br> <br>    glFlush(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* Update <br>* <br>* Update all varying values, called by the common library <br>* <br>\**************************************************************************/ <br> <br>void Update(void *data) <br>{ <br>    if (config.spin) <br>    { <br>        xr += 3; <br>        yr += 2; <br>    } <br> <br>    if (config.bloom) <br>    { <br>        sf += sfi; <br>        if (sf &gt; cur_geom-&gt;max_sf || <br>            sf &lt; cur_geom-&gt;min_sf) <br>        { <br>            sfi = -sfi; <br>        } <br>        UpdatePts(cur_geom, sf); <br>    } <br> <br>    if (config.cycle_colors) <br>    { <br>        ComputeHsvColors(); <br>        phase += (FLT)(2.5*PI/180.); <br>    } <br>     <br>    Draw(); <br>} <br> <br>// String storage <br>TCHAR geom_names[IDS_GEOM_COUNT][20]; <br> <br>/******************************Public*Routine******************************\ <br>* getIniSettings <br>* <br>* Get the screen saver configuration options from .INI file/registry. <br>* <br>\**************************************************************************/ <br> <br>static void  <br>getIniSettings() <br>{ <br>    // Get registry settings <br> <br>    if( ! ss_RegistrySetup( GetModuleHandle(NULL), IDS_INI_SECTION,  <br>                            IDS_INIFILE ) ) <br>        return; <br>     <br>    config.smooth_colors = <br>        ss_GetRegistryInt( IDS_CONFIG_SMOOTH_COLORS, config.smooth_colors ); <br>    config.triangle_colors = <br>        ss_GetRegistryInt( IDS_CONFIG_TRIANGLE_COLORS, config.triangle_colors ); <br>    config.cycle_colors = <br>        ss_GetRegistryInt( IDS_CONFIG_CYCLE_COLORS, config.cycle_colors ); <br>    config.spin = <br>        ss_GetRegistryInt( IDS_CONFIG_SPIN, config.spin ); <br>    config.bloom = <br>        ss_GetRegistryInt( IDS_CONFIG_BLOOM, config.bloom ); <br>    config.subdiv = <br>        ss_GetRegistryInt( IDS_CONFIG_SUBDIV, config.subdiv ); <br>    config.color_pick = <br>        ss_GetRegistryInt( IDS_CONFIG_COLOR_PICK, config.color_pick ); <br>    config.image_size = <br>        ss_GetRegistryInt( IDS_CONFIG_IMAGE_SIZE, config.image_size ); <br>    config.geom = <br>        ss_GetRegistryInt( IDS_CONFIG_GEOM, config.geom ); <br>    config.two_sided = <br>        ss_GetRegistryInt( IDS_CONFIG_TWO_SIDED, config.two_sided ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* saveIniSettings <br>* <br>* Save the screen saver configuration option to the .INI file/registry. <br>* <br>\**************************************************************************/ <br> <br>static void  <br>saveIniSettings() <br>{ <br>    if( ! ss_RegistrySetup( GetModuleHandle(NULL), IDS_INI_SECTION,  <br>                            IDS_INIFILE ) ) <br>        return; <br> <br>    ss_WriteRegistryInt( IDS_CONFIG_SMOOTH_COLORS, config.smooth_colors ); <br> <br>    ss_WriteRegistryInt( IDS_CONFIG_TRIANGLE_COLORS, config.triangle_colors ); <br>    ss_WriteRegistryInt( IDS_CONFIG_CYCLE_COLORS, config.cycle_colors ); <br>    ss_WriteRegistryInt( IDS_CONFIG_SPIN, config.spin ); <br>    ss_WriteRegistryInt( IDS_CONFIG_BLOOM, config.bloom ); <br>    ss_WriteRegistryInt( IDS_CONFIG_SUBDIV, config.subdiv ); <br>    ss_WriteRegistryInt( IDS_CONFIG_COLOR_PICK, config.color_pick ); <br>    ss_WriteRegistryInt( IDS_CONFIG_IMAGE_SIZE, config.image_size ); <br>    ss_WriteRegistryInt( IDS_CONFIG_GEOM, config.geom ); <br>    ss_WriteRegistryInt( IDS_CONFIG_TWO_SIDED, config.two_sided ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* NewConfig <br>* <br>* Set up a new configuration <br>* <br>\**************************************************************************/ <br> <br>void NewConfig(CONFIG *cnf) <br>{ <br>    // Set new config <br>    config = *cnf; <br> <br>    // Save to ini file <br>    saveIniSettings(); <br>     <br>    // Reset colors <br>    memcpy(checker_cols, base_checker_cols, sizeof(checker_cols)); <br>    memcpy(side_cols, base_side_cols, sizeof(side_cols)); <br>    memcpy(solid_cols, base_solid_cols, sizeof(solid_cols)); <br> <br>    // Reset geometry <br>    cur_geom = geom_table[config.geom]; <br>    cur_geom-&gt;init(cur_geom); <br>    if (bOgl11 &amp;&amp; !bCheckerOn) DrawWithVArrays (cur_geom); <br>     <br>    assert(cur_geom-&gt;total_pts &lt;= MAXPTS); <br>            <br>    InitVlen(cur_geom, cur_geom-&gt;total_pts, cur_geom-&gt;pts); <br>    sf = 0.0f; <br>    sfi = cur_geom-&gt;sf_inc; <br>    UpdatePts(cur_geom, sf); <br> <br>    // Reset OpenGL parameters according to configuration <br>    // Only done if GL has been initialized <br>    if (gbGlInit) <br>    { <br>        GLfloat fv4[4]; <br>         <br>        if (config.two_sided == GL_FRONT_AND_BACK) <br>        { <br>            glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE); <br>            glDisable(GL_CULL_FACE); <br>        } <br>        else <br>        { <br>            glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE); <br>            glEnable(GL_CULL_FACE); <br>        } <br>         <br>        fv4[0] = fv4[1] = fv4[2] = .8f; <br>        fv4[3] = 1.0f; <br>        glMaterialfv(config.two_sided, GL_SPECULAR, fv4); <br>        glMaterialf(config.two_sided, GL_SHININESS, 30.0f); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* RegisterDialogClasses <br>* <br>* Standard screensaver hook <br>* <br>\**************************************************************************/ <br> <br>BOOL WINAPI RegisterDialogClasses(HANDLE hinst) <br>{ <br>    return TRUE; <br>} <br> <br>// Temporary configuration for when the configuration dialog is active <br>// If the dialog is ok'ed then this becomes the current configuration, <br>// otherwise it is discarded <br>CONFIG temp_config; <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ScreenSaverConfigureDialog <br>* <br>* Standard screensaver hook <br>* <br>\**************************************************************************/ <br> <br>BOOL CALLBACK ScreenSaverConfigureDialog(HWND hdlg, UINT msg, <br>                                         WPARAM wpm, LPARAM lpm) <br>{ <br>    HWND hCtrl; <br>    int i; <br>     <br>    switch(msg) <br>    { <br>    case WM_INITDIALOG: <br> <br>        InitCommonControls(); <br> <br>        getIniSettings(); <br>     <br>        temp_config = config; <br>         <br>        CheckRadioButton(hdlg, ID_COL_PICK_FIRST, ID_COL_PICK_LAST, <br>                         config.color_pick); <br>        CheckDlgButton(hdlg, ID_COL_SMOOTH, config.smooth_colors); <br>        CheckDlgButton(hdlg, ID_COL_TRIANGLE, config.triangle_colors); <br>        CheckDlgButton(hdlg, ID_COL_CYCLE, config.cycle_colors); <br>        CheckDlgButton(hdlg, ID_SPIN, config.spin); <br>        CheckDlgButton(hdlg, ID_BLOOM, config.bloom); <br>        CheckDlgButton(hdlg, ID_TWO_SIDED, <br>                       config.two_sided == GL_FRONT_AND_BACK); <br>         <br>        ss_SetupTrackbar( hdlg, ID_COMPLEXITY, MINSUBDIV, MAXSUBDIV,  <br>                          complexity_range.step, <br>                          complexity_range.page_step, <br>                          config.subdiv); <br> <br>        ss_SetupTrackbar( hdlg, ID_IMAGE_SIZE, MINIMAGESIZE, MAXIMAGESIZE,  <br>                          image_size_range.step, <br>                          image_size_range.page_step, <br>                          config.image_size); <br> <br>        hCtrl = GetDlgItem(hdlg, ID_GEOM); <br>        SendMessage(hCtrl, CB_RESETCONTENT, 0, 0); <br>        for (i = 0; i &lt; IDS_GEOM_COUNT; i++) <br>        { <br>            LoadString( hMainInstance, i+IDS_GEOM_FIRST, geom_names[i], <br>                        sizeof(geom_names)/IDS_GEOM_COUNT ); <br>            SendMessage(hCtrl, CB_ADDSTRING, 0, (LPARAM)geom_names[i]); <br>        } <br>        SendMessage(hCtrl, CB_SETCURSEL, config.geom, 0); <br>         <br>        SetFocus(GetDlgItem(hdlg, ID_COMPLEXITY)); <br>        return FALSE; <br> <br>    case WM_COMMAND: <br>        switch(LOWORD(wpm)) <br>        { <br>        case ID_COL_CHECKER: <br>        case ID_COL_PER_SIDE: <br>        case ID_COL_SINGLE: <br>            temp_config.color_pick = LOWORD(wpm); <br>            break; <br> <br>        case ID_COL_SMOOTH: <br>            temp_config.smooth_colors = !temp_config.smooth_colors; <br>            break; <br>        case ID_COL_TRIANGLE: <br>            temp_config.triangle_colors = !temp_config.triangle_colors; <br>            break; <br>        case ID_COL_CYCLE: <br>            temp_config.cycle_colors = !temp_config.cycle_colors; <br>            break; <br>             <br>        case ID_SPIN: <br>            temp_config.spin = !temp_config.spin; <br>            break; <br>        case ID_BLOOM: <br>            temp_config.bloom = !temp_config.bloom; <br>            break; <br>        case ID_TWO_SIDED: <br>            temp_config.two_sided = <br>                temp_config.two_sided == GL_FRONT_AND_BACK ? GL_FRONT : <br>                GL_FRONT_AND_BACK; <br>            break; <br> <br>        case IDOK: <br>            temp_config.subdiv = <br>                ss_GetTrackbarPos(hdlg, ID_COMPLEXITY); <br>            temp_config.image_size = <br>                ss_GetTrackbarPos(hdlg, ID_IMAGE_SIZE); <br>            temp_config.geom = <br>                SendMessage(GetDlgItem(hdlg, ID_GEOM), CB_GETCURSEL, 0, 0); <br>            NewConfig(&amp;temp_config); <br>            // Fall through <br>        case IDCANCEL: <br>            EndDialog(hdlg, LOWORD(wpm)); <br>            break; <br>        } <br>        return TRUE; <br>         <br>    } <br> <br>    return FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* Init <br>* <br>* Drawing initialization, called by common library <br>* <br>\**************************************************************************/ <br> <br>void Init(void *data) <br>{ <br>    GLfloat fv4[4]; <br> <br>    gbGlInit = TRUE; <br>     <br>    bOgl11 = ss_fOnGL11(); <br> <br>    if (config.color_pick == ID_COL_CHECKER) bCheckerOn = TRUE; <br>    else bCheckerOn = FALSE; <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluPerspective(45, 1, 2, 5); // for object range -1.5 to 1.5 <br>    gluLookAt(0, 0, 3.5, 0, 0, 0, 0, 1, 0); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glEnable(GL_DEPTH_TEST); <br>    glClearDepth(1); <br> <br>    glCullFace(GL_BACK); <br>     <br>    fv4[0] = 2.0f; <br>    fv4[1] = 2.0f; <br>    fv4[2] = 10.0f; <br>    fv4[3] = 1.0f; <br>    glLightfv(GL_LIGHT0, GL_POSITION, fv4); <br>     <br>    glEnable(GL_LIGHTING); <br>    glEnable(GL_LIGHT0); <br> <br>    glEnable(GL_NORMALIZE); <br>     <br>    // Make default configuration current <br>    NewConfig(&amp;config); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetFloaterInfo <br>* <br>* Set the size and motion of the floating window <br>* <br>\**************************************************************************/ <br>void <br>SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild ) <br>{ <br>    float sizeFact; <br>    float sizeScale; <br>    int size; <br>    ISIZE *pChildSize = &amp;pChild-&gt;size; <br>    MOTION_INFO *pMotion = &amp;pChild-&gt;motionInfo; <br> <br>    sizeScale = (float)config.image_size / 100.0f; <br>    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75% <br>    size = (int) (sizeFact * ( ((float)(pParentSize-&gt;width + pParentSize-&gt;height )) / 2.0f )); <br>    SS_CLAMP_TO_RANGE2( size, 0, pParentSize-&gt;width ); <br>    SS_CLAMP_TO_RANGE2( size, 0, pParentSize-&gt;height ); <br> <br>    pChildSize-&gt;width = pChildSize-&gt;height = size; <br> <br>    // Floater motion <br>    pMotion-&gt;posInc.x = .005f * (float) size; <br>    if( pMotion-&gt;posInc.x &lt; 1.0f ) <br>        pMotion-&gt;posInc.x = 1.0f; <br>    pMotion-&gt;posInc.y = pMotion-&gt;posInc.x; <br>    pMotion-&gt;posIncVary.x = .4f * pMotion-&gt;posInc.x; <br>    pMotion-&gt;posIncVary.y = pMotion-&gt;posIncVary.x; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* FloaterFail <br>* <br>* Called when the floating window cannot be created <br>* <br>\**************************************************************************/ <br>void FloaterFail(void *data) <br>{ <br>    HINSTANCE hinst; <br>    TCHAR error_str[20]; <br>    TCHAR start_failed[80]; <br> <br>    hinst = GetModuleHandle(NULL); <br>    if (LoadString(hinst, IDS_ERROR, <br>                   error_str, sizeof(error_str)) &amp;&amp; <br>        LoadString(hinst, IDS_START_FAILED, <br>                   start_failed, sizeof(start_failed))) <br>    { <br>        MessageBox(NULL, start_failed, error_str, MB_OK); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_Init <br>* <br>* Screensaver initialization routine, called at startup by common library <br>* <br>\**************************************************************************/ <br> <br>SSContext *ss_Init(void) <br>{ <br>    getIniSettings(); <br>     <br>    ss_InitFunc(Init); <br>    ss_UpdateFunc(Update); <br> <br>    gssc.bFloater = TRUE; <br>    gssc.floaterInfo.bMotion = TRUE; <br>    gssc.floaterInfo.ChildSizeFunc = SetFloaterInfo; <br> <br>    gssc.bDoubleBuf = TRUE; <br>    gssc.depthType = SS_DEPTH16; <br> <br>    return &amp;gssc; <br>} <br> <br> <br>/**************************************************************************\ <br>* ConfigInit <br>* <br>* Dialog box version of ss_Init.  Used for setting up any gl drawing on the <br>* dialog. <br>* <br>\**************************************************************************/ <br>BOOL <br>ss_ConfigInit( HWND hDlg ) <br>{ <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
