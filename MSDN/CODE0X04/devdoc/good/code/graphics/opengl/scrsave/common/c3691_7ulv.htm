<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSA8.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3703"></a>SSA8.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: ssa8.c <br>* <br>* Operations on .a8 files <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "sscommon.h" <br> <br>#define ESCAPE 0 <br>#define ESC_ENDLINE 0 <br>#define ESC_ENDBITMAP 1 <br>#define ESC_DELTA 2 <br>#define ESC_RANDOM 3 <br>#define RANDOM_COUNT(c) ((c)-(ESC_RANDOM-1)) <br> <br>#define COUNT_SIZE 256 <br>#define MAXRUN (COUNT_SIZE-1) <br>#define MAXRND (RANDOM_COUNT(COUNT_SIZE)-1) <br> <br>typedef unsigned char *HwMem; <br>typedef unsigned long HwMemSize; <br>#define HW_UNALIGNED UNALIGNED <br> <br>static HwMemSize HwuRld(HwMem src, HwMem dest, HwMemSize stride) <br>{ <br>    unsigned short code; <br>    unsigned char run, esc; <br>    size_t len; <br>    HwMem s; <br>    HwMem f; <br> <br>    s = src; <br>    f = dest; <br>    for (;;) <br>    { <br>        code = *((unsigned short HW_UNALIGNED *)s)++; <br>        run = code &amp; 0xff; <br>        esc = code &gt;&gt; 8; <br>        if (run == ESCAPE) <br>        { <br>            if (esc == ESC_ENDBITMAP) <br>            { <br>                break; <br>            } <br>            else if (esc == ESC_DELTA) <br>            { <br>                len = *((unsigned short HW_UNALIGNED *)s)++; <br>                while (len-- &gt; 0) <br>                { <br>                    *f = 0; <br>                    f += stride; <br>                } <br>            } <br>            else if (esc &gt;= ESC_RANDOM) <br>            { <br>                len = RANDOM_COUNT(esc); <br>                while (len-- &gt; 0) <br>                { <br>                    *f = *s++; <br>                    f += stride; <br>                } <br>            } <br>        } <br>        else <br>        { <br>            while (run-- &gt; 0) <br>            { <br>                *f = esc; <br>                f += stride; <br>            } <br>        } <br>    } <br>     <br>    return s-src; <br>} <br> <br>static HwMemSize HwuRldTo32(HwMem src, HwMem dest, HwMemSize stride, <br>                            DWORD *translate) <br>{ <br>    unsigned short code; <br>    unsigned char run, esc; <br>    size_t len; <br>    HwMem s; <br>    DWORD *f, tran; <br> <br>    s = src; <br>    f = (DWORD *)dest; <br>    for (;;) <br>    { <br>        code = *((unsigned short HW_UNALIGNED *)s)++; <br>        run = code &amp; 0xff; <br>        esc = code &gt;&gt; 8; <br>        if (run == ESCAPE) <br>        { <br>            if (esc == ESC_ENDBITMAP) <br>            { <br>                break; <br>            } <br>            else if (esc == ESC_DELTA) <br>            { <br>                len = *((unsigned short HW_UNALIGNED *)s)++; <br>                while (len-- &gt; 0) <br>                { <br>                    *f = translate[0]; <br>                    f += stride; <br>                } <br>            } <br>            else if (esc &gt;= ESC_RANDOM) <br>            { <br>                len = RANDOM_COUNT(esc); <br>                while (len-- &gt; 0) <br>                { <br>                    *f = translate[*s++]; <br>                    f += stride; <br>                } <br>            } <br>        } <br>        else <br>        { <br>            tran = translate[esc]; <br>            while (run-- &gt; 0) <br>            { <br>                *f = tran; <br>                f += stride; <br>            } <br>        } <br>    } <br>     <br>    return s-src; <br>} <br> <br>#define ALPHA_SIGNATURE 0xa0a1a2a3 <br>#define COMPRESS_NONE 0 <br>#define COMPRESS_RLE  1 <br> <br>BOOL ss_A8ImageLoad(void *pvResource, TEXTURE *ptex) <br>{ <br>    DWORD compress; <br>    DWORD size; <br>    DWORD *pal; <br>    DWORD *pdwA8; <br> <br>    pdwA8 = (DWORD *)pvResource; <br> <br>    // Check data signature for alpha texture format <br>    if (*pdwA8 != ALPHA_SIGNATURE) <br>    { <br>        return FALSE; <br>    } <br>    pdwA8++; <br> <br>    ptex-&gt;width = *pdwA8++; <br>    ptex-&gt;height = *pdwA8++; <br> <br>    // Make sure depth is 8bpp <br>    if (*pdwA8 != 8) <br>    { <br>        return FALSE; <br>    } <br>    pdwA8++; <br>     <br>    size = ptex-&gt;width*ptex-&gt;height; <br> <br>    // Compression type <br>    compress = *pdwA8++; <br>    // Compressed data size only if compressed, not used <br>    pdwA8++; <br> <br>    // Remember pointer to palette data <br>    pal = pdwA8; <br>    pdwA8 += 256; <br> <br>    if (ss_PalettedTextureEnabled()) <br>    { <br>        // Allocate data for final image <br>        ptex-&gt;data = malloc(size); <br>        if (ptex-&gt;data == NULL) <br>        { <br>            return FALSE; <br>        } <br>     <br>        ptex-&gt;pal_size = 256; <br>        ptex-&gt;pal = malloc(ptex-&gt;pal_size*sizeof(RGBQUAD)); <br>        if (ptex-&gt;pal == NULL) <br>        { <br>            free(ptex-&gt;data); <br>            return FALSE; <br>        } <br>        memcpy(ptex-&gt;pal, pal, ptex-&gt;pal_size*sizeof(RGBQUAD)); <br> <br>        // Unpack 8bpp data into final image <br>        if (compress == COMPRESS_NONE) <br>        { <br>            memcpy(ptex-&gt;data, pdwA8, size); <br>        } <br>        else <br>        { <br>            HwuRld((HwMem)pdwA8, ptex-&gt;data, 1); <br>        } <br> <br>        ptex-&gt;format = GL_COLOR_INDEX; <br>        ptex-&gt;components = GL_COLOR_INDEX8_EXT; <br>    } <br>    else <br>    { <br>        // Allocate data for final image <br>        ptex-&gt;data = malloc(size*sizeof(DWORD)); <br>        if (ptex-&gt;data == NULL) <br>        { <br>            return FALSE; <br>        } <br>     <br>        ptex-&gt;pal_size = 0; <br>        ptex-&gt;pal = NULL; <br> <br>        // Unpack 8bpp data into final image <br>        if (compress == COMPRESS_NONE) <br>        { <br>            DWORD i; <br>            BYTE *src; <br>            DWORD *dst; <br> <br>            src = (BYTE *)pdwA8; <br>            dst = (DWORD *)ptex-&gt;data; <br>            for (i = 0; i &lt; size; i++) <br>            { <br>                *dst++ = pal[*src++]; <br>            } <br>        } <br>        else <br>        { <br>            HwuRldTo32((HwMem)pdwA8, ptex-&gt;data, 1, pal); <br>        } <br> <br>        ptex-&gt;format = GL_BGRA_EXT; <br>        ptex-&gt;components = 4; <br>    } <br>     <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
