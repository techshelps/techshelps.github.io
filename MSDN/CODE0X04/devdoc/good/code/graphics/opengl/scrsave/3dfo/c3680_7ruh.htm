<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SS3DFO.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3689"></a>SS3DFO.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: ss3dfo.c <br>* <br>* Dispatcher and dialog box for the OpenGL-based 3D Flying Objects screen <br>* saver. <br>* <br>* Created: 18-May-1994 14:54:59 <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;sys\timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include "ss3dfo.h" <br> <br>//#define SS_DEBUG 1 <br> <br>// Global strings. <br>#define GEN_STRING_SIZE 64 <br> <br>static SSContext gssc; <br>BOOL gbBounce = FALSE; // floating window bounce off side <br> <br>// Global message loop variables. <br>MATERIAL Material[16]; <br>#ifdef MEMDEBUG <br>ULONG totalMem = 0; <br>#endif <br> <br>// Global screen saver settings. <br> <br>void (*updateSceneFunc)(int); // current screen saver update function <br>void (*delSceneFunc)(void);         // current screen saver deletion function <br>BOOL bColorCycle = FALSE;           // color cycling flag <br>BOOL bSmoothShading = TRUE;         // smooth shading flag <br>UINT uSize = 100;                   // object size <br>float fTesselFact = 1.0f;           // object tessalation <br>int UpdateFlags = 0;                // extra data sent to update function <br>int Type = 0;                       // screen saver index (into function arrays) <br> <br>// Texture file information <br>TEXFILE gTexFile = {0}; <br> <br>// Lighting properties. <br> <br>static const RGBA lightAmbient   = {0.21f, 0.21f, 0.21f, 1.0f}; <br>static const RGBA light0Ambient  = {0.0f, 0.0f, 0.0f, 1.0f}; <br>static const RGBA light0Diffuse  = {0.7f, 0.7f, 0.7f, 1.0f}; <br>static const RGBA light0Specular = {1.0f, 1.0f, 1.0f, 1.0f}; <br>static const GLfloat light0Pos[]      = {100.0f, 100.0f, 100.0f, 0.0f}; <br> <br>// Material properties. <br> <br>static RGBA matlColors[7] = {{1.0f, 0.0f, 0.0f, 1.0f}, <br>                             {0.0f, 1.0f, 0.0f, 1.0f}, <br>                             {0.0f, 0.0f, 1.0f, 1.0f}, <br>                             {1.0f, 1.0f, 0.0f, 1.0f}, <br>                             {0.0f, 1.0f, 1.0f, 1.0f}, <br>                             {1.0f, 0.0f, 1.0f, 1.0f}, <br>                             {0.235f, 0.0f, 0.78f, 1.0f}, <br>                            }; <br> <br>extern void updateStripScene(int); <br>extern void updateDropScene(int); <br>extern void updateLemScene(int); <br>extern void updateExplodeScene(int); <br>extern void updateWinScene(int); <br>extern void updateTexScene(int); <br>extern void initStripScene(void); <br>extern void initDropScene(void); <br>extern void initLemScene(void); <br>extern void initExplodeScene(void); <br>extern void initWinScene(void); <br>extern void initTexScene(void); <br>extern void delStripScene(void); <br>extern void delDropScene(void); <br>extern void delLemScene(void); <br>extern void delExplodeScene(void); <br>extern void delWinScene(void); <br>extern void delTexScene(void); <br> <br>typedef void (*PTRUPDATE)(int); <br>typedef void (*ptrdel)(); <br>typedef void (*ptrinit)(); <br> <br>// Each screen saver style puts its hook functions into the function <br>// arrays below.  A consistent ordering of the functions is required. <br> <br>static PTRUPDATE updateFuncs[] = <br>    {updateWinScene, updateExplodeScene,updateStripScene, updateStripScene, <br>     updateDropScene, updateLemScene, updateTexScene}; <br>static ptrdel delFuncs[] = <br>    {delWinScene, delExplodeScene, delStripScene, delStripScene, <br>     delDropScene, delLemScene, delTexScene}; <br>static ptrinit initFuncs[] = <br>    {initWinScene, initExplodeScene, initStripScene, initStripScene, <br>     initDropScene, initLemScene, initTexScene}; <br>static int idsStyles[] = <br>    {IDS_LOGO, IDS_EXPLODE, IDS_RIBBON, IDS_2RIBBON, <br>     IDS_SPLASH, IDS_TWIST, IDS_FLAG}; <br> <br>#define MAX_TYPE    ( sizeof(initFuncs) / sizeof(ptrinit) - 1 ) <br> <br>// Each screen saver style can choose which dialog box controls it wants <br>// to use.  These flags enable each of the controls.  Controls not choosen <br>// will be disabled. <br> <br>#define OPT_COLOR_CYCLE     0x00000001 <br>#define OPT_SMOOTH_SHADE    0x00000002 <br>#define OPT_TESSEL          0x00000008 <br>#define OPT_SIZE            0x00000010 <br>#define OPT_TEXTURE         0x00000020 <br>#define OPT_STD             ( OPT_COLOR_CYCLE | OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE ) <br> <br>static ULONG gflConfigOpt[] = { <br>     OPT_STD,               // Windows logo <br>     OPT_STD,               // Explode <br>     OPT_STD,               // Strip <br>     OPT_STD,               // Strip <br>     OPT_STD,               // Drop <br>     OPT_STD,               // Twist (lemniscate) <br>     OPT_SMOOTH_SHADE | OPT_TESSEL | OPT_SIZE | OPT_TEXTURE  // Texture mapped flag <br>}; <br> <br>static void updateDialogControls(HWND hDlg); <br> <br>#ifdef MEMDEBUG <br>void xprintf(char *str, ...) <br>{ <br>    va_list ap; <br>    char buffer[256]; <br> <br>    va_start(ap, str); <br>    vsprintf(buffer, str, ap); <br> <br>    OutputDebugString(buffer); <br>    va_end(ap); <br>} <br>#endif <br> <br>void *SaverAlloc(ULONG size) <br>{ <br>    void *mPtr; <br> <br>    mPtr = malloc(size); <br>#ifdef MEMDEBUG <br>    totalMem += size; <br>    xprintf("malloc'd %x, size %d\n", mPtr, size); <br>#endif <br>    return mPtr; <br>} <br> <br>void SaverFree(void *pMem) <br>{ <br>#ifdef MEMDEBUG <br>    totalMem -= _msize(pMem); <br>    xprintf("free %x, size = %d, total = %d\n", pMem, _msize(pMem), totalMem); <br>#endif <br>    free(pMem); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* getIniSettings <br>* <br>* Get the screen saver configuration options from .INI file/registry. <br>* <br>* History: <br>*  10-May-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static void getIniSettings() <br>{ <br>    int    options; <br>    int    optMask = 1; <br>    TCHAR  szDefaultBitmap[MAX_PATH]; <br>    int    tessel=0; <br> <br>    LoadString(hMainInstance, IDS_GENNAME, szScreenSaver, sizeof(szScreenSaver) / sizeof(TCHAR)); <br> <br>    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) ) <br>    { <br>        options = ss_GetRegistryInt( IDS_OPTIONS, -1 ); <br>        if (options &gt;= 0) <br>        { <br>            bSmoothShading = ((options &amp; optMask) != 0); <br>            optMask &lt;&lt;= 1; <br>            bColorCycle = ((options &amp; optMask) != 0); <br>            UpdateFlags = (bColorCycle &lt;&lt; 1); <br>        } <br> <br>        Type = ss_GetRegistryInt( IDS_OBJTYPE, 0 ); <br> <br>        // Sanity check Type.  Don't want to index into function arrays <br>        // with a bad index! <br>        Type = min(Type, MAX_TYPE); <br> <br>        // Set flag so that updateStripScene will do two strips instead <br>        // of one. <br> <br>        if (Type == 3) <br>            UpdateFlags |= 0x4; <br> <br>        tessel = ss_GetRegistryInt( IDS_TESSELATION, 100 ); <br>        SS_CLAMP_TO_RANGE2( tessel, 0, 200 ); <br> <br>        if (tessel &lt;= 100) <br>            fTesselFact  = (float)tessel / 100.0f; <br>        else <br>            fTesselFact = 1.0f + (((float)tessel - 100.0f) / 100.0f); <br> <br>        uSize = ss_GetRegistryInt( IDS_SIZE, 50 ); <br>        SS_CLAMP_TO_RANGE2( uSize, 0, 100 ); <br> <br>        // Determine the default .bmp file <br> <br>        ss_GetDefaultBmpFile( szDefaultBitmap ); <br> <br>        // Is there a texture specified in the registry that overrides the <br>        // default? <br> <br> <br>        ss_GetRegistryString( IDS_TEXTURE, szDefaultBitmap, gTexFile.szPathName, <br>                              MAX_PATH); <br> <br>        gTexFile.nOffset = ss_GetRegistryInt( IDS_TEXTURE_FILE_OFFSET, 0 ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* saveIniSettings <br>* <br>* Save the screen saver configuration option to the .INI file/registry. <br>* <br>* History: <br>*  10-May-1994 -by- Gilman Wong [gilmanw] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>static void saveIniSettings(HWND hDlg) <br>{ <br>    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) ) <br>    { <br>        int pos, options; <br>        int optMask = 1; <br> <br>        bSmoothShading = IsDlgButtonChecked(hDlg, DLG_SETUP_SMOOTH); <br>        bColorCycle = IsDlgButtonChecked(hDlg, DLG_SETUP_CYCLE); <br>        options = bColorCycle; <br>        options &lt;&lt;= 1; <br>        options |= bSmoothShading; <br>        ss_WriteRegistryInt( IDS_OPTIONS, options ); <br> <br>        Type = SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_GETCURSEL, <br>                                  0, 0); <br>        ss_WriteRegistryInt( IDS_OBJTYPE, Type ); <br> <br>        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_TESSEL ); <br>        ss_WriteRegistryInt( IDS_TESSELATION, pos ); <br> <br>        pos = ss_GetTrackbarPos( hDlg, DLG_SETUP_SIZE ); <br>        ss_WriteRegistryInt( IDS_SIZE, pos ); <br> <br>        ss_WriteRegistryString( IDS_TEXTURE, gTexFile.szPathName ); <br>        ss_WriteRegistryInt( IDS_TEXTURE_FILE_OFFSET, gTexFile.nOffset ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* setupDialogControls <br>* <br>* Setup the dialog controls initially. <br>* <br>\**************************************************************************/ <br> <br>static void  <br>setupDialogControls(HWND hDlg) <br>{ <br>    int pos; <br> <br>    InitCommonControls(); <br> <br>    if ( gflConfigOpt[Type] &amp; OPT_TESSEL ) <br>    { <br>        if (fTesselFact &lt;= 1.0f) <br>            pos = (int)(fTesselFact * 100.0f); <br>        else <br>            pos = 100 + (int) ((fTesselFact - 1.0f) * 100.0f); <br> <br>        ss_SetupTrackbar( hDlg, DLG_SETUP_TESSEL, 0, 200, 1, 10, pos ); <br>    } <br> <br>    if ( gflConfigOpt[Type] &amp; OPT_SIZE ) <br>    { <br>        ss_SetupTrackbar( hDlg, DLG_SETUP_SIZE, 0, 100, 1, 10, uSize ); <br>    } <br> <br>    updateDialogControls( hDlg ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* updateDialogControls <br>* <br>* Update the dialog controls based on the current global state. <br>* <br>\**************************************************************************/ <br> <br>static void  <br>updateDialogControls(HWND hDlg) <br>{ <br>    CheckDlgButton(hDlg, DLG_SETUP_SMOOTH, bSmoothShading); <br>    CheckDlgButton(hDlg, DLG_SETUP_CYCLE, bColorCycle); <br> <br>    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SMOOTH), <br>                 gflConfigOpt[Type] &amp; OPT_SMOOTH_SHADE ); <br>    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_CYCLE), <br>                 gflConfigOpt[Type] &amp; OPT_COLOR_CYCLE ); <br> <br>    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TESSEL), <br>                 gflConfigOpt[Type] &amp; OPT_TESSEL); <br>    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS), <br>                 gflConfigOpt[Type] &amp; OPT_TESSEL); <br>    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MIN), <br>                 gflConfigOpt[Type] &amp; OPT_TESSEL); <br>    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TESS_MAX), <br>                 gflConfigOpt[Type] &amp; OPT_TESSEL); <br> <br>    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_SIZE), <br>                 gflConfigOpt[Type] &amp; OPT_SIZE); <br>    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE), <br>                 gflConfigOpt[Type] &amp; OPT_SIZE); <br>    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MIN), <br>                 gflConfigOpt[Type] &amp; OPT_SIZE); <br>    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_SIZE_MAX), <br>                 gflConfigOpt[Type] &amp; OPT_SIZE); <br> <br>    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TEXTURE), <br>                 gflConfigOpt[Type] &amp; OPT_TEXTURE); <br>} <br> <br>BOOL WINAPI RegisterDialogClasses(HANDLE hinst) <br>{ <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ScreenSaverConfigureDialog <br>* <br>* Processes messages for the configuration dialog box. <br>* <br>\**************************************************************************/ <br> <br>BOOL ScreenSaverConfigureDialog(HWND hDlg, UINT message, <br>                                WPARAM wParam, LPARAM lParam) <br>{ <br>    int wTmp; <br>    TCHAR szString[GEN_STRING_SIZE]; <br> <br>    switch (message) { <br>        case WM_INITDIALOG: <br>            getIniSettings(); <br> <br>            setupDialogControls(hDlg); <br> <br>            for (wTmp = 0; wTmp &lt;= MAX_TYPE; wTmp++) { <br>                LoadString(hMainInstance, idsStyles[wTmp], szString, GEN_STRING_SIZE); <br>                SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_ADDSTRING, 0, <br>                                   (LPARAM) szString); <br>            } <br>            SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, CB_SETCURSEL, Type, 0); <br> <br>            return TRUE; <br> <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) { <br>                case DLG_SETUP_TYPES: <br>                    switch (HIWORD(wParam)) <br>                    { <br>                        case CBN_EDITCHANGE: <br>                        case CBN_SELCHANGE: <br>                            Type = SendDlgItemMessage(hDlg, DLG_SETUP_TYPES, <br>                                                      CB_GETCURSEL, 0, 0); <br>                            updateDialogControls(hDlg); <br>                            break; <br>                        default: <br>                            break; <br>                    } <br>                    return FALSE; <br> <br>                case DLG_SETUP_TEXTURE: <br>                    ss_SelectTextureFile( hDlg, &amp;gTexFile ); <br>                    break; <br> <br>                case IDOK: <br>                    saveIniSettings(hDlg); <br>                    EndDialog(hDlg, TRUE); <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hDlg, FALSE); <br>                    break; <br> <br>                case DLG_SETUP_SMOOTH: <br>                case DLG_SETUP_CYCLE: <br>                default: <br>                    break; <br>            } <br>            return TRUE; <br>            break; <br> <br>        default: <br>            return 0; <br>    } <br>    return 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetFloaterInfo <br>* <br>* Set the size and motion of the floating window <br>* It stays square in shape <br>* <br>\**************************************************************************/ <br> <br>static void <br>SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild ) <br>{ <br>    float sizeFact; <br>    float sizeScale; <br>    int size; <br>    ISIZE *pChildSize = &amp;pChild-&gt;size; <br>    MOTION_INFO *pMotion = &amp;pChild-&gt;motionInfo; <br> <br>    sizeScale = (float)uSize / 100.0f; // 0..1 <br>    sizeFact = 0.25f + (0.30f * sizeScale); <br>    size = (int) (sizeFact * ( ((float)(pParentSize-&gt;width + pParentSize-&gt;height)) / 2.0f )); <br>    SS_CLAMP_TO_RANGE2( size, 0, pParentSize-&gt;width ); <br>    SS_CLAMP_TO_RANGE2( size, 0, pParentSize-&gt;height ); <br> <br>    pChildSize-&gt;width = pChildSize-&gt;height = size; <br> <br>    // Floater motion <br>    pMotion-&gt;posInc.x = .01f * (float) size; <br>    if( pMotion-&gt;posInc.x &lt; 1.0f ) <br>        pMotion-&gt;posInc.x = 1.0f; <br>    pMotion-&gt;posInc.y = pMotion-&gt;posInc.x; <br>    pMotion-&gt;posIncVary.x = .4f * pMotion-&gt;posInc.x; <br>    pMotion-&gt;posIncVary.y = pMotion-&gt;posIncVary.x; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* initMaterial <br>* <br>* Initialize the material properties. <br>* <br>\**************************************************************************/ <br> <br>void initMaterial(int id, float r, float g, float b, float a) <br>{ <br>    Material[id].ka.r = r; <br>    Material[id].ka.g = g; <br>    Material[id].ka.b = b; <br>    Material[id].ka.a = a; <br> <br>    Material[id].kd.r = r; <br>    Material[id].kd.g = g; <br>    Material[id].kd.b = b; <br>    Material[id].kd.a = a; <br> <br>    Material[id].ks.r = 1.0f; <br>    Material[id].ks.g = 1.0f; <br>    Material[id].ks.b = 1.0f; <br>    Material[id].ks.a = 1.0f; <br> <br>    Material[id].specExp = 128.0f; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* _3dfo_Init <br>* <br>\**************************************************************************/ <br> <br>static void <br>_3dfo_Init(void *data) <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; 7; i++) <br>        initMaterial(i, matlColors[i].r, matlColors[i].g, <br>                     matlColors[i].b, matlColors[i].a); <br> <br> <br>    // Set the OpenGL clear color to black. <br> <br>    glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <br>#ifdef SS_DEBUG <br>    glClearColor(0.2f, 0.2f, 0.2f, 0.0f); <br>#endif <br> <br>    // Enable the z-buffer. <br> <br>    glEnable(GL_DEPTH_TEST); <br> <br>    // Select the shading model. <br> <br>    if (bSmoothShading) <br>        glShadeModel(GL_SMOOTH); <br>    else <br>        glShadeModel(GL_FLAT); <br> <br>    // Setup the OpenGL matrices. <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br> <br>    // Setup the lighting. <br> <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, (GLfloat *) &amp;lightAmbient); <br>    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE); <br>    glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_FALSE); <br>    glLightfv(GL_LIGHT0, GL_AMBIENT, (GLfloat *) &amp;light0Ambient); <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, (GLfloat *) &amp;light0Diffuse); <br>    glLightfv(GL_LIGHT0, GL_SPECULAR, (GLfloat *) &amp;light0Specular); <br>    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos); <br>    glEnable(GL_LIGHTING); <br>    glEnable(GL_LIGHT0); <br> <br>    // Setup the material properties. <br> <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, (GLfloat *) &amp;Material[0].ks); <br>    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, (GLfloat *) &amp;Material[0].specExp); <br> <br>    // call specific objects init func <br>    (*initFuncs[Type])(); <br>    updateSceneFunc = updateFuncs[Type]; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* _3dfo_Draw <br>* <br>\**************************************************************************/ <br> <br>static void <br>_3dfo_Draw(void *data) <br>{ <br>    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <br>    (*updateSceneFunc)(UpdateFlags); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* _3dfo_FloaterBounce <br>* <br>\**************************************************************************/ <br> <br>static void <br>_3dfo_FloaterBounce(void *data) <br>{ <br>    gbBounce = TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_Init <br>* <br>* Screen saver entry point.  Pre-GL initialization <br>* <br>\**************************************************************************/ <br> <br>SSContext * <br>ss_Init(void) <br>{ <br>    getIniSettings(); <br> <br>    // Make sure the selected texture file is OK. <br> <br>    if ( gflConfigOpt[Type] &amp; OPT_TEXTURE ) <br>    { <br>        // Verify texture file <br>        ss_DisableTextureErrorMsgs(); <br>        ss_VerifyTextureFile( &amp;gTexFile ); <br>    } <br> <br>    // set callbacks <br> <br>    ss_InitFunc( _3dfo_Init ); <br>    ss_UpdateFunc( _3dfo_Draw ); <br> <br>    // set configuration info to return <br> <br>    gssc.bDoubleBuf = TRUE; <br>    gssc.depthType = SS_DEPTH16; <br> <br>    gssc.bFloater = TRUE; <br>    gssc.floaterInfo.bMotion = TRUE; <br>    gssc.floaterInfo.ChildSizeFunc = SetFloaterInfo; <br>    ss_FloaterBounceFunc( _3dfo_FloaterBounce ); <br> <br>    return &amp;gssc; <br>} <br> <br>/**************************************************************************\ <br>* ConfigInit <br>* <br>* Dialog box version of ss_Init.  Used for setting up any gl drawing on the <br>* dialog. <br>* <br>\**************************************************************************/ <br>BOOL <br>ss_ConfigInit( HWND hDlg ) <br>{ <br>    return TRUE; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
