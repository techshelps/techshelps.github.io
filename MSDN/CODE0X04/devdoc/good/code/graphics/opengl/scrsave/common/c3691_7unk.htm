<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSWINDOW.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3710"></a>SSWINDOW.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: sswindow.cxx <br>* <br>* Copyright 1996 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include "scrnsave.h" <br> <br>#include "glscrnsv.h" <br>#include "ssintrnl.hxx" <br>#include "sswindow.hxx" <br>#include "ssutil.hxx" <br> <br>static void (__stdcall *glAddSwapHintRect)(GLint, GLint, GLint, GLint); <br> <br>// externs from ssinit.cxx <br>extern void *gDataPtr; <br>extern void (*gReshapeFunc)(int, int, void *); <br>extern void (*gRepaintFunc)( LPRECT, void *); <br>extern void (*gUpdateFunc)( void *); <br>extern void (*gInitFunc)( void *); <br>extern void (*gFinishFunc)( void *); <br>extern void (*gFloaterBounceFunc)( void *);   <br> <br>// forwards <br>static void GetWindowSize( HWND hwnd, ISIZE *pSize ); <br>static void ss_QueryAddSwapHintRect(); <br>static void DrawGdiDeltaRect( HDC hdc, HBRUSH hbr, RECT *pRect1, RECT *pRect2 ); <br>static void DrawGLDeltaRect( GLRECT *pRect1, GLRECT *pRect2 ); <br> <br>/**************************************************************************\ <br>* SSW constructor <br>* <br>\**************************************************************************/ <br> <br>SSW::SSW( PSSW psswParentArg, ISIZE *pSize, IPOINT2D *pPos, BOOL bMotion, <br>          SSCHILDSIZEPROC ChildSizeFuncArg ) <br>{ <br>    // Basic initialization <br> <br>    Reset(); <br> <br>    // Initialization based on constructor parameters <br> <br>    psswParent = psswParentArg; <br>    ChildSizeFunc = ChildSizeFuncArg; <br> <br>    if( pSize ) <br>        size = *pSize; <br>    if( pPos ) <br>        pos = *pPos; <br>    else <br>        pos.x = pos.y = 0; <br> <br>    if( bMotion &amp;&amp; psswParent ) { <br>        // Allocate motion structure <br>        pMotion = (MOTION *)  <br>                LocalAlloc( LMEM_ZEROINIT | LMEM_FIXED, sizeof(MOTION) ); <br>        // If pMotion is NULL, then motion is disabled <br>    } <br> <br>    // Call back to the client screen saver to determine size and motion <br>    // characteristics of child based on its parent size. <br>    GetChildInfo(); // this can set pos and size <br> <br>    if( pMotion ) { <br>        if( pPos == NULL ) { <br>            // Set a random window pos <br>            pos.x = ss_iRand2( 0, (psswParent-&gt;size.width - size.width) ); <br>            pos.y = ss_iRand2( 0, (psswParent-&gt;size.height - size.height) ); <br> <br>            // Set the motion parameters <br>            ResetMotion(); <br>        } <br>        // Have to make sure parent has an hdc so it can draw background when <br>        // this child moves <br>        if( !psswParent-&gt;hdc ) <br>            psswParent-&gt;hdc = GetDC( psswParent-&gt;hwnd ); <br>    } <br> <br>    if( psswParent ) { <br>        // Need to add this pssw to its parent's list <br>        psswParent-&gt;AddChild( this ); <br>        // Default is to be subWindow of parent <br>        psswParent-&gt;iSubWindow++;  // increment reference count <br>    } <br>} <br> <br>/**************************************************************************\ <br>* SSW constructor <br>* <br>* Used when wrapping an SSW around an already existing window <br>* (as when drawing GL on dialog buttons) <br>\**************************************************************************/ <br> <br>SSW::SSW( PSSW psswParentArg, HWND hwndArg ) <br>{ <br>    Reset(); <br> <br>    psswParent = psswParentArg; <br>    if( psswParent ) <br>        // Need to add this pssw to its parent's list <br>        psswParent-&gt;AddChild( this ); <br> <br>    hwnd = hwndArg; <br>    if( !hwnd ) { <br>        SS_ERROR( "SSW::SSW : NULL hwnd\n" ); <br>        return; <br>    } <br> <br>    bOwnWindow = FALSE; <br>    // Get the window size <br>    GetWindowSize( hwnd, &amp;size ); <br> <br>    gpss-&gt;sswTable.Register( hwnd, this ); <br>} <br> <br>/**************************************************************************\ <br>* Reset <br>* <br>* Reset parameters to default init state <br>\**************************************************************************/ <br> <br>void <br>SSW::Reset() <br>{ <br>    // Basic initialization <br> <br>    bOwnWindow = TRUE; <br>    iSubWindow = 0; <br>    bValidateBg = FALSE; <br>    wFlags = 0; <br>    hwnd = 0; <br>    hdc = 0; <br>    hrc = 0; <br>    pos.x = pos.y = 0; <br>    size.width = size.height = 0; <br>    psswParent =    NULL; <br>    psswSibling =   NULL; <br>    psswChildren =  NULL; <br>    bDoubleBuf =    FALSE; <br>    pStretch =      NULL; <br>    pMotion =       NULL; <br>    pGLc =          NULL; <br> <br>    InitFunc =      NULL; <br>    UpdateFunc =    NULL; <br>    ReshapeFunc =   NULL; <br>    RepaintFunc =   NULL; <br>    FloaterBounceFunc = NULL; <br>    FinishFunc =    NULL; <br>    ChildSizeFunc = NULL; <br>    DataPtr =       NULL; <br>} <br> <br>/**************************************************************************\ <br>* SSW destructor <br>* <br>* This can be called when a window is closed, or by the ss client <br>* <br>\**************************************************************************/ <br> <br>SSW::~SSW() <br>{ <br>    // If this window has any children, they will have to be terminated too <br> <br>    if( psswChildren ) { <br>        PSSW psswChild = psswChildren; <br>        while( psswChild ) { <br>            // Delete first child in list <br>            if( psswChild-&gt;hwnd &amp;&amp; bOwnWindow ) { <br>                // We created this window, we must destroy it <br>    DestroyWindow( psswChild-&gt;hwnd ); <br>            } else { <br>                delete psswChild; <br>            } <br>            // Next child is now first child in list <br>            psswChild = psswChildren; <br>        } <br>    } <br> <br>    if( psswParent ) <br>        // Need to remove this pssw from its parent's list <br>        psswParent-&gt;RemoveChild( this ); <br> <br>    if( hwnd ) { <br>        // Remove from SSWTable <br>        gpss-&gt;sswTable.Remove( hwnd ); <br>    } else { <br>        // subWindow <br>        if( psswParent ) { <br>            SS_ASSERT1( (psswParent-&gt;iSubWindow &gt; 0),  <br>                 "Invalid subWindow reference count for pssw=0x%x\n", this ); <br>            psswParent-&gt;iSubWindow--;  // decrement subWindow reference count <br>        } <br>    } <br> <br>    // Clean up GL <br> <br>    if( hrc ) { <br>        // FinishFunc still needs gl <br>        if( FinishFunc ) <br>            (*FinishFunc)( DataPtr ); <br> <br>        wglMakeCurrent( NULL, NULL ); <br>        if( ! (wFlags &amp; SS_HRC_PROXY_BIT) ) <br>            wglDeleteContext( hrc ); <br>    } <br> <br>    // Clean up any bitmaps <br> <br>    if( pStretch ) { <br>        SS_BITMAP *pssbm = &amp;pStretch-&gt;ssbm; <br> <br>        DeleteObject(SelectObject(pssbm-&gt;hdc, pssbm-&gt;hbmOld)); <br>        DeleteDC(pssbm-&gt;hdc); <br>    } <br> <br>    //  Release the dc <br>    if( hdc ) { <br>        HWND hwndForHdc = hwnd ? hwnd : psswParent ? psswParent-&gt;hwnd : NULL; <br>        ReleaseDC(hwndForHdc, hdc); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* AddChild <br>* <br>* Add the supplied child SSW to this SSW. <br>\**************************************************************************/ <br> <br>void <br>SSW::AddChild( PSSW psswChild ) <br>{ <br>    if( !psswChildren ) { <br>        psswChildren = psswChild; <br>        return; <br>    } <br>    <br>    // Else travel along the sibling chain of psswChildren and deposit <br>    // psswChild at the end <br>     <br>    PSSW pssw = psswChildren; <br>    while( pssw-&gt;psswSibling ) <br>        pssw = pssw-&gt;psswSibling; <br>    pssw-&gt;psswSibling = psswChild; <br>} <br> <br> <br>/**************************************************************************\ <br>* RemoveChild <br>* <br>* Remove this child from the parent's list <br>* <br>* Whoever calls this needs to update SSW_TABLE too... <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::RemoveChild( PSSW psswChild ) <br>{ <br>    if( !psswChildren ) { <br>        // Something wrong - this window has no children <br>        SS_ERROR( "SSW::RemoveChild : no children\n" ); <br>        return FALSE; <br>    } <br>    <br>    PSSW psswPrev; <br>    PSSW pssw = psswChildren; <br> <br>    while( pssw != NULL ) { <br>        if( pssw == psswChild ) { <br>            // found it ! <br>            if( psswChild == psswChildren ) <br>                // The child being removed is the first in the list <br>                psswChildren = psswChild-&gt;psswSibling; <br>            else <br>                psswPrev-&gt;psswSibling = pssw-&gt;psswSibling; <br>            return TRUE; <br>        } <br>        // Move up the pointers <br>        psswPrev = pssw; <br>        pssw = psswPrev-&gt;psswSibling; <br>    } <br> <br>    SS_ERROR( "SSW::RemoveChild : child not found\n" ); <br>    return FALSE; <br>} <br> <br>/**************************************************************************\ <br>* GetWindowSize <br>* <br>\**************************************************************************/ <br> <br>static void <br>GetWindowSize( HWND hwnd, ISIZE *pSize ) <br>{ <br>    RECT clientRect; <br> <br>    GetClientRect( hwnd, &amp;clientRect ); <br> <br>    pSize-&gt;width = clientRect.right - clientRect.left + 1; <br>    pSize-&gt;height = clientRect.bottom - clientRect.top + 1; <br>} <br> <br>/**************************************************************************\ <br>* CreateSSWindow <br>* <br>* Create OpenGL floater window.  This window floats on top of the screen <br>* saver window, bouncing off each of the screen edges. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::CreateSSWindow(HINSTANCE hMainInstance,  UINT uStyle, UINT uExStyle , <br>                  LPCTSTR pszWindowTitle, WNDPROC wndProcArg, LPCTSTR pszClassName, HWND hwndParentOverride ) <br>{ <br>    IPOINT2D startPos; <br>    HWND hwndParent; <br> <br>    if( hwndParentOverride ) <br>        hwndParent = hwndParentOverride; <br>    else <br>        hwndParent =  psswParent ? psswParent-&gt;hwnd : NULL; <br>     <br> <br>    wndProc = wndProcArg; <br> <br>    if( !pMotion ) <br>        startPos = pos; <br>    else { <br>        // Initialize start position off screen to work around win95 screen <br>        // validation bug <br>        startPos.x = pos.x - psswParent-&gt;size.width; <br>        startPos.y = pos.y - psswParent-&gt;size.height; <br>    } <br> <br>    hwnd = CreateWindowEx( <br>                                 uExStyle, <br>                                 pszClassName, <br>                                 pszWindowTitle, <br>                                 uStyle, <br>                                 startPos.x, <br>                                 startPos.y, <br>                                 size.width,     // width <br>                                 size.height,    // height <br>                                 hwndParent, <br>                                 NULL,               // menu <br>                                 hMainInstance, <br>                                 (LPVOID) this <br>                                ); <br> <br>    if (!hwnd) { <br>        SS_WARNING( "SSW::CreateSSWindow : CreateWindowEx failure\n" ); <br>        return FALSE; <br>    } <br> <br>    // This window is on its own now <br>    if( psswParent ) { <br>        SS_ASSERT1( (psswParent-&gt;iSubWindow &gt; 0),  <br>                 "Invalid subWindow reference count for pssw=0x%x\n", this ); <br>        psswParent-&gt;iSubWindow--;  // decrement subWindow reference count <br>    } <br> <br>    ShowWindow(hwnd, SW_SHOW); <br> <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* GetChildInfo <br>* <br>* Call the window's ChildSizeFunc <br>\**************************************************************************/ <br> <br>void <br>SSW::GetChildInfo( ) <br>{ <br>    if( !ChildSizeFunc ) <br>        return; <br> <br>    CHILD_INFO childInfo; <br> <br>    // Call the client's SizeFunc to get required info <br> <br>    (*ChildSizeFunc)( &amp;psswParent-&gt;size, &amp;childInfo ); <br> <br>    // Pull required values into pssw and validate them <br> <br>    size = childInfo.size; <br>    ValidateChildSize(); <br> <br>    if( !pMotion ) { <br>        pos = childInfo.pos; <br>        bValidateChildPos(); <br>    } else { <br>        pMotion-&gt;posInc = childInfo.motionInfo.posInc; <br>        pMotion-&gt;posIncVary = childInfo.motionInfo.posIncVary; <br>        pMotion-&gt;posIncCur = pMotion-&gt;posInc; <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* ConfigureForGdi <br>* <br>* Creates an hdc for the window <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::ConfigureForGdi() <br>{ <br>    if( hdc ) <br>        // already configured <br>        return TRUE; <br> <br>    // Figure window to get hdc from <br>    HWND hwndForHdc = hwnd ? hwnd : psswParent ? psswParent-&gt;hwnd : NULL; <br> <br>    if( !hwndForHdc || !(hdc = GetDC(hwndForHdc)) ) { <br>        SS_WARNING( "SSW::ConfigureForGdi failed\n" ); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* ConfigureForGL <br>* <br>* Creates a GL rendering context for the specified window <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::ConfigureForGL( SS_GL_CONFIG *pGLcArg ) <br>{ <br>    pGLc = pGLcArg; <br>    return ConfigureForGL(); <br>} <br> <br>BOOL <br>SSW::ConfigureForGL() <br>{ <br>    if( hrc ) <br>        return TRUE; <br> <br>    if( ConfigureForGdi() &amp;&amp; <br>        (hrc = hrcSetupGL()) ) <br>        return TRUE; <br> <br>    SS_WARNING( "SSW::ConfigureForGL failed\n" ); <br>    return FALSE; <br>} <br> <br>/**************************************************************************\ <br>* hrcSetupGL <br>* <br>* Setup OpenGL. <br>* <br>\**************************************************************************/ <br> <br>#define NULL_RC ((HGLRC) 0) <br> <br>HGLRC  <br>SSW::hrcSetupGL() <br>{ <br>    if( !pGLc ) <br>        return NULL_RC; <br> <br>    HGLRC hrc; <br>    HDC hgldc; <br>    int pfFlags = pGLc-&gt;pfFlags; <br>    PIXELFORMATDESCRIPTOR pfd = {0}; <br> <br>    pStretch = pGLc-&gt;pStretch; <br>    if( pStretch ) { <br>        if( NeedStretchedWindow() ) { <br>            // Only need single buffered pixel format <br>            pfFlags &amp;= ~SS_DOUBLEBUF_BIT; <br>            pfFlags |= SS_BITMAP_BIT; // yup, BOTH window and bitmap need this <br>        } else <br>            // Turn off stretching <br>            pStretch = NULL; <br>    } <br> <br>    // If preview mode or config mode, don't allow pixel formats that need <br>    // the system palette, as this will create much ugliness. <br>    if( ss_fPreviewMode() || ss_fConfigMode() ) <br>        pfFlags |= SS_NO_SYSTEM_PALETTE_BIT; <br> <br>    // If config mode, force a non-accelerated pixel format, as WNDOBJ's <br>    // seem to have problems with MCD, ICD <br>    if( ss_fConfigMode() ) <br>        pfFlags |= SS_GENERIC_UNACCELERATED_BIT; <br> <br>    bDoubleBuf = SS_HAS_DOUBLEBUF( pfFlags ); <br> <br>    if( !SSU_SetupPixelFormat( hdc, pfFlags, &amp;pfd ) ) <br>        return NULL_RC; <br> <br>    // Update pGLc-&gt;pfFlags based on pfd returned <br>    // (for now, the only ones we care about are the generic/accelerated flags) <br>    if(  (pfd.dwFlags &amp; (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED)) <br> == PFD_GENERIC_FORMAT ) <br>        pGLc-&gt;pfFlags |= SS_GENERIC_UNACCELERATED_BIT; <br> <br>    if( SSU_bNeedPalette( &amp;pfd ) ) { <br>        // Note: even if bStretch, need to set up palette here so they match <br>        if( !gpss-&gt;pssPal ) { <br>            SS_PAL *pssPal; <br>            BOOL bTakeOverPalette = ss_fFullScreenMode() ? TRUE : FALSE; <br> <br>            // The global palette has not been created yet - do it <br>            // SS_PAL creation requires pixel format descriptor for color bit <br>            // information, etc. (the pfd is cached in SS_PAL, since for <br>            // palette purposes it is the same for all windows) <br>            pssPal = new SS_PAL( hdc, &amp;pfd, bTakeOverPalette ); <br>            if( !pssPal ) <br>                return NULL_RC; <br>            // Set approppriate palette manage proc <br>            if( ss_fFullScreenMode() ) <br>                pssPal-&gt;paletteManageProc = FullScreenPaletteManageProc; <br>            else <br>                // use regular palette manager proc <br>                pssPal-&gt;paletteManageProc = PaletteManageProc; <br>            gpss-&gt;pssPal = pssPal; <br>        } <br>        // Realize the global palette in this window <br>        // assume we're realizing in foreground <br>        HWND hwndPal = hwnd ? hwnd : psswParent ? psswParent-&gt;hwnd : NULL; <br>        if( hwndPal ) <br>            gpss-&gt;pssPal-&gt;Realize( hwndPal, hdc, FALSE ); <br>    } <br> <br>    if( pStretch ) { <br>        // Stretch blt mode: For every frame, we'll be doing a StretchBlt <br>        // from a DIB to the screen.  Need to set up a compatible memdc. <br>        SS_BITMAP *pssbm; <br> <br>        pssbm = &amp;pStretch-&gt;ssbm; <br> <br>        pssbm-&gt;hdc = CreateCompatibleDC(hdc); <br>        if( !pssbm-&gt;hdc ) <br>            return NULL_RC; <br>        ResizeStretch(); // this creates the DIB Section <br>        pfFlags = 0; <br>        pfFlags |= SS_BITMAP_BIT; <br>        if( !SSU_SetupPixelFormat( pssbm-&gt;hdc, pfFlags, &amp;pfd ) ) { <br>            return NULL_RC; <br>        } <br>        // this ppfd's palette bits must match the window's !! <br>        // If window needs palette, so does bitmap... <br>        if( gpss-&gt;pssPal ) { <br>            SS_PAL *pssPal = gpss-&gt;pssPal; <br>            extern void ssw_UpdateDIBColorTable( HDC, HDC ); <br> <br>            ssw_UpdateDIBColorTable( pssbm-&gt;hdc, hdc ); <br>        } <br>        hgldc = pssbm-&gt;hdc; <br>    } else { <br>        hgldc = hdc; <br>    } <br> <br>    if( pGLc-&gt;hrc ) { <br>        // Use the supplied hrc <br>        hrc = pGLc-&gt;hrc; <br>        // Set flag so we don't delete this borrowed hrc when the SSW terminates <br>        wFlags |= SS_HRC_PROXY_BIT; <br>    } else <br>        // Create a new hrc <br>        hrc = wglCreateContext(hgldc); <br> <br>    if( !hrc || !wglMakeCurrent(hgldc, hrc) ) { <br>        SS_WARNING( "SSW::hrcSetupGL : hrc context failure\n" ); <br>        return NULL_RC; <br>    } <br> <br>    if( !hwnd &amp;&amp; (bDoubleBuf || pStretch) ) { <br> <br>        // enable scissoring <br>        glEnable( GL_SCISSOR_TEST ); <br>     <br>        if( !(pGLc-&gt;pfFlags &amp; SS_GENERIC_UNACCELERATED_BIT) ) { <br>            // MCD or ICD, possible hardware implementation - we maintain <br>            // a lastRect to handle SwapBuffer issues <br>            lastRect.x = lastRect.y = lastRect.width = lastRect.height = 0; <br>        } <br>    } <br> <br>    SS_DBGLEVEL2( SS_LEVEL_INFO,  <br>        "SSW::hrcSetupGL: wglMakeCurrent( hrc=0x%x, hwnd=0x%x )\n", hrc, hwnd ); <br> <br>// Note that these queries are based on a single gl window screen saver.  In <br>// a more complicated scenario, these capabilities could be queried on a <br>// per-window basis (since support could vary with pixel formats). <br>    // Query the GL version - sets support for any new (e.g. 1.1) functionality <br>    ss_QueryGLVersion(); <br> <br>    // Query paletted texture extension <br>    ss_QueryPalettedTextureEXT(); <br> <br>    // Query the AddSwapHintRect WIN extension  <br>    ss_QueryAddSwapHintRect(); <br> <br>    // Pull in any Func's that were already defined (for compatibility with <br>    // old mechanism) <br> <br>    InitFunc = gInitFunc; <br>    UpdateFunc = gUpdateFunc; <br>    ReshapeFunc = gReshapeFunc; <br>    RepaintFunc = gRepaintFunc; <br>    FloaterBounceFunc = gFloaterBounceFunc; <br>    FinishFunc = gFinishFunc; <br>    DataPtr = gDataPtr; <br> <br>    return hrc; <br>} <br> <br>/**************************************************************************\ <br>* MakeCurrent <br>* <br>* Call wglMakeCurrent for this window's hrc.  Note: an ss client may have <br>* more than one hrc (e.g. pipes), in which case it is the client's <br>* responsibility to make current. <br>\**************************************************************************/ <br> <br>void <br>SSW::MakeCurrent() <br>{ <br>    if( ! wglMakeCurrent( hdc, hrc ) ) <br>        SS_WARNING( "SSW::MakeCurrent : wglMakeCurrent failure\n" ); <br>} <br> <br>/**************************************************************************\ <br>* InitGL <br>* <br>* Call the window's GL Init Func <br>* <br>* Priority is raised to expedite any initialization (e.g. loading and <br>* processing textures can take a while. <br>* <br>* A Reshape msg is sent to the client ss, as this is required for setting <br>* glViewport, etc. <br>\**************************************************************************/ <br> <br>void <br>SSW::InitGL() <br>{ <br>    PSSW psswChild = psswChildren; <br> <br>    // Configure the window for GL if pGLc non-NULL <br>    if( pGLc &amp;&amp; (! ConfigureForGL()) ) { <br>        // This is fatal for this window - if it is the main window, <br>        // the ss will terminate <br>        if( hwnd ) <br>            PostMessage( hwnd, WM_CLOSE, 0, 0l ); <br>        return; <br>    } <br> <br>    // If window configured for GL, hrc will have been set... <br> <br>    // Call the InitFunc <br>    if( hrc &amp;&amp; InitFunc ) { <br>        DWORD oldPriority; <br> <br>        // Bump up priority during initialization phase <br>        oldPriority = GetPriorityClass( GetCurrentProcess() ); <br>        SetPriorityClass( GetCurrentProcess(), HIGH_PRIORITY_CLASS ); <br> <br>        SS_DBGLEVEL1( SS_LEVEL_INFO,  <br>                "SSW::InitGL: Calling client GLInit for 0x%x\n", hwnd ); <br> <br>        (*InitFunc)( DataPtr ); <br> <br>        // restore original priority <br>        SetPriorityClass( GetCurrentProcess(), oldPriority ); <br>    } <br> <br>    /* Send another Reshape, since initial one triggered by window <br>     * creation would have been received before GL init'd <br>     */ <br>    Reshape(); <br> <br>    // Next, init any child windows.  This has to be done after the parent <br>    // window initialization. <br> <br>    while( psswChild ) { <br>        if( psswChild-&gt;hwnd ) <br>            SendMessage( psswChild-&gt;hwnd, SS_WM_INITGL, 0, 0 ); <br>        else <br>            // Must be a logical sub-window <br>            psswChild-&gt;InitGL(); <br>        psswChild = psswChild-&gt;psswSibling; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* ResizeStretch <br>* <br>* Resize the compatible bitmap for stretch blt mode <br>* <br>* There are 2 sizing modes.  If bRatioMode, then we set the bitmap size <br>* by dividing the window dimensions by the supplied ratios.  In this case, <br>* the base* values set a lower limit for the bitmap dimensions.  Otherwise, the <br>* base* values determine the bitmap dimensions. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::ResizeStretch() <br>{ <br>    HBITMAP hbmNew; <br>    PVOID pvBits; <br>    int width, height; <br>    int cwidth, cheight; // client area size <br>    SS_BITMAP *pssbm = &amp;pStretch-&gt;ssbm; <br> <br>    cwidth = size.width; <br>    cheight = size.height; <br> <br>    if( pStretch-&gt;bRatioMode ) { <br>        width = (int) ( (float)cwidth / pStretch-&gt;widthRatio ); <br>        height = (int) ( (float)cheight / pStretch-&gt;heightRatio ); <br>        if( width &lt; pStretch-&gt;baseWidth ) <br>            width = pStretch-&gt;baseWidth; <br>        if( height &lt; pStretch-&gt;baseHeight ) <br>            height = pStretch-&gt;baseHeight ; <br>    } else { <br>        width = pStretch-&gt;baseWidth; <br>        height = pStretch-&gt;baseHeight; <br>    } <br> <br>    // Limit width, height to window dimensions <br>    if( width &gt; cwidth ) <br>        width = cwidth; <br>    if( height &gt; cheight ) <br>        height = cheight; <br> <br>    // If same size, get out <br>    if( (width == pssbm-&gt;size.width) &amp;&amp; (height == pssbm-&gt;size.height) ) <br>        return; <br> <br>    pssbm-&gt;size.width = width; <br>    pssbm-&gt;size.height = height; <br> <br> <br>    // Use system palette <br>    hbmNew = SSDIB_CreateCompatibleDIB(hdc, NULL, width, height, &amp;pvBits); <br> <br>    if (hbmNew) <br>    { <br>        if (pssbm-&gt;hbm != (HBITMAP) 0) <br>        { <br>            SelectObject( pssbm-&gt;hdc, pssbm-&gt;hbmOld ); <br>            DeleteObject( pssbm-&gt;hbm ); <br>        } <br> <br>        pssbm-&gt;hbm = hbmNew; <br>        pssbm-&gt;hbmOld = (HBITMAP) SelectObject( pssbm-&gt;hdc, pssbm-&gt;hbm ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* Resize <br>* <br>* Resize wrapper <br>* <br>* Called in response to WM_SIZE. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::Resize( int width, int height ) <br>{ <br>    size.width  = width; <br>    size.height = height; <br> <br>    if( pStretch ) { <br>        // May have to resize associated bitmap <br>        ResizeStretch(); <br>    } <br> <br>    if( psswChildren ) { <br>        // May need to resize any children <br>        PSSW pssw = psswChildren; <br>        while( pssw ) { <br>            // Get new size/motion for the floater <br>            pssw-&gt;GetChildInfo(); <br>            pssw-&gt;SetSSWindowPos(); <br>            if( !pssw-&gt;hwnd ) { <br>                // Handle sub-window case <br>                // Need to call Reshape, since win32 system won't send WM_SIZE. <br>                pssw-&gt;Reshape(); <br>            } <br>            pssw = pssw-&gt;psswSibling; <br>        } <br>    } <br> <br>    Reshape(); <br>} <br> <br>/**************************************************************************\ <br>* Repaint <br>* <br>* Repaint wrapper <br>* <br>* Called in response to WM_PAINT. <br>* <br>\**************************************************************************/ <br> <br>#define NULL_UPDATE_RECT( pRect ) \ <br>     (  ((pRect)-&gt;left == 0) &amp;&amp; \ <br>        ((pRect)-&gt;right == 0) &amp;&amp; \ <br>        ((pRect)-&gt;top == 0) &amp;&amp; \ <br>        ((pRect)-&gt;bottom == 0) ) <br> <br>void <br>SSW::Repaint( BOOL bCheckUpdateRect ) <br>{ <br>    if( !hwnd ) <br>        return; <br> <br>    RECT rect, *pRect = NULL; <br> <br>    if( bCheckUpdateRect ) { <br>        GetUpdateRect( hwnd, &amp;rect, FALSE ); <br>        // Above supposed to return NULL if rect is all 0's,  <br>        // but this doesn't happen <br>        if( NULL_UPDATE_RECT( &amp;rect ) ) <br>            return; <br>        pRect = &amp;rect; <br>    } <br> <br>    if( RepaintFunc ) <br>        (*RepaintFunc)( pRect, DataPtr ); <br>} <br> <br>/**************************************************************************\ <br>* NeedStretchedWindow <br>* <br>* Check if stretch mode is necessary <br>*  <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::NeedStretchedWindow() <br>{ <br>    if( (pStretch-&gt;baseWidth &gt;= size.width) &amp;&amp;         <br>        (pStretch-&gt;baseHeight &gt;= size.height) ) { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* SetSSWindowPos <br>* <br>* Set new size and position for an SSW <br>* <br>\**************************************************************************/ <br> <br>void  <br>SSW::SetSSWindowPos() <br>{ <br>    SetSSWindowPos( 0 ); <br>} <br> <br>void  <br>SSW::SetSSWindowPos( int flags ) <br>{ <br>    if( hwnd ) { <br>        SetWindowPos(hwnd, 0, pos.x, pos.y,  <br>                 size.width, size.height, <br>                 SWP_NOCOPYBITS | SWP_NOZORDER | SWP_NOACTIVATE | flags ); <br>    // Note: If flags does not specify SWP_NOREDRAW, this generates a WM_PAINT  <br>    // msg for the entire window region <br>    } else if( psswParent &amp;&amp; !pStretch ) { <br>        // Set viewport for new position <br>        // (if pStretch, shouldn't need to do anything, as viewport should <br>        // have been already set to the bitmap) <br>        int posy = GLPosY(); <br>        glViewport( pos.x, posy, size.width, size.height ); <br>        glScissor( pos.x, posy, size.width, size.height ); <br>        glAddSwapHintRect( pos.x, posy, size.width, size.height ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetAspectRatio <br>* <br>* Resize a child window to conform to the supplied aspect ratio.  We do this by <br>* maintaining the existing width, and adjusting the height. <br>* <br>* Window resize seems to be executed synchronously, so gl should be able to <br>* immediately validate its buffer dimensions (we count on it). <br>* <br>* Returns TRUE if new height is different from last, else FALSE. <br>\**************************************************************************/ <br> <br>BOOL  <br>SSW::SetAspectRatio( FLOAT fAspect ) <br>{ <br>    if( !psswParent ) <br>        return FALSE; <br> <br>    int oldHeight; <br>    UINT uFlags = 0; <br> <br>    // Check for zero fAspect <br>    if( fAspect == 0.0f ) fAspect = 1.0f; <br> <br>    oldHeight = size.height; <br>    // Set the new height, based on desired aspect ratio <br>    size.height = (int) ((FLOAT) size.width / fAspect); <br>    // make sure new height not TOO big! <br>    ValidateChildSize(); <br> <br>    if( size.height == oldHeight ) <br>        // no change <br>        return FALSE; <br> <br>    // make sure current position still valid when height changes <br>    if( !bValidateChildPos() ) { <br>        // current position OK, don't need to move it <br>        uFlags |= SWP_NOMOVE; <br>    } <br>    SetSSWindowPos( uFlags ); <br> <br>    // ! remember not to call the client's ReshapeFunc here, as SetAspectRatio <br>    // may be called by the client in response to a window resize, resulting in <br>    // an infinite loop <br>    // but if there is no size change (above) we return, avoiding the <br>    // infinite loop <br>    if( !hwnd ) <br>        // Need to call Reshape, since win32 system won't send WM_SIZE.  Need <br>        // to fix to avoid possible infinite loops <br>        Reshape(); <br> <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* CalcNextWindowPos <br>* <br>* Calculate the next position for a moving window, using the pMotion data. <br>* If the new position would cause the window to bounce off the <br>* edge of its parent, return TRUE. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::CalcNextWindowPos() <br>{ <br>    POINT2D *fpos = &amp;pMotion-&gt;pos; <br>    IPOINT2D *ipos = &amp;pos; <br>    POINT2D *posInc = &amp;pMotion-&gt;posInc; <br>    POINT2D *posIncV = &amp;pMotion-&gt;posIncVary; <br>    POINT2D *posIncCur = &amp;pMotion-&gt;posIncCur; <br>    BOOL bounce = FALSE; <br> <br>    if( !psswParent ) <br>        return FALSE; <br> <br>    // Compute the next window position. <br> <br>    fpos-&gt;x += posIncCur-&gt;x; <br>    fpos-&gt;y += posIncCur-&gt;y; <br>    ipos-&gt;x = (int) fpos-&gt;x; <br>    ipos-&gt;y = (int) fpos-&gt;y; <br> <br>    if ( (ipos-&gt;x + size.width) &gt; psswParent-&gt;size.width) { <br>        // Right hit <br>        ipos-&gt;x = psswParent-&gt;size.width - size.width; </code></pre>
<p>
</p>
<pre><code>fpos-&gt;x = (float) ipos-&gt;x; <br>        posIncCur-&gt;x =  <br>            - ss_fRand( posInc-&gt;x - posIncV-&gt;x, posInc-&gt;x + posIncV-&gt;x ); <br>        if( posIncCur-&gt;x &gt; -0.5f ) posIncCur-&gt;x = -0.5f; <br>        bounce = TRUE; <br>    } else if (ipos-&gt;x &lt; 0) { <br>        // Left hit <br>        ipos-&gt;x = 0; <br>        fpos-&gt;x = 0.0f; <br>        posIncCur-&gt;x =  <br>            ss_fRand( posInc-&gt;x - posIncV-&gt;x, posInc-&gt;x + posIncV-&gt;x ); <br>        if( posIncCur-&gt;x &lt; 0.5f ) posIncCur-&gt;x = 0.5f; <br>        bounce = TRUE; <br>    } <br> <br>    if ( (ipos-&gt;y + size.height) &gt; psswParent-&gt;size.height) { <br>        // Bottom hit <br>        ipos-&gt;y = psswParent-&gt;size.height - size.height; <br>        fpos-&gt;y = (float) (ipos-&gt;y); <br>        posIncCur-&gt;y =  <br>            - ss_fRand( posInc-&gt;y - posIncV-&gt;y, posInc-&gt;y + posIncV-&gt;y ); <br>        if( posIncCur-&gt;y &gt; -0.5f ) posIncCur-&gt;y = -0.5f; <br>        bounce = TRUE; <br>    } else if (ipos-&gt;y &lt; 0) { <br>        // Top hit <br>        ipos-&gt;y = 0; <br>        fpos-&gt;y = 0.0f; <br>        posIncCur-&gt;y =  <br>            ss_fRand( posInc-&gt;y - posIncV-&gt;y, posInc-&gt;y + posIncV-&gt;y ); <br>        if( posIncCur-&gt;y &lt; 0.5f ) posIncCur-&gt;y = 0.5f; <br>        bounce = TRUE; <br>    } <br>    return bounce; <br>} <br> <br> <br>/**************************************************************************\ <br>* MoveSSWindow <br>* <br>* This is the function that moves the OpenGL window around, causing it to <br>* bounce around.  Each time the window is moved, the contents of the <br>* window are updated from the hidden (or back) buffer by SwapBuffers(). <br>*  <br>* The bRedrawBg flag determines whether the area that was covered by the old <br>* position should be updated by the parent window. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::MoveSSWindow( BOOL bRedrawBg ) <br>{  <br>    BOOL bounce; <br>    int flags = SWP_NOSIZE; <br> <br>    // Synchronize with OpenGL.  Flush OpenGL commands and wait for completion. <br> <br>    glFinish(); <br> <br>    // Move the window <br> <br>    bounce = CalcNextWindowPos(); <br> <br>    if( bounce &amp;&amp; FloaterBounceFunc ) <br>        // The window bounced off one of the sides <br>        // ! This function should *not* be used for rendering - for <br>        // for informational purposes only (.e.g. changing the spin of a <br>        // rotating object). <br>        (*FloaterBounceFunc)( DataPtr ); <br> <br>    if( !bRedrawBg ) <br>        flags |= SWP_NOREDRAW; <br>    SetSSWindowPos( flags ); <br>} <br> <br> <br>/**************************************************************************\ <br>* UpdateWindow <br>* <br>* Update the window <br>* <br>* Ccurrently this assumes all windows are being animated (i.e. not showing <br>*   a static image) <br>* <br>* Things *must* happen in the order defined here, so they work on generic as <br>* well as hardware implementations. <br>* Note: Move must happen after SwapBuf, and will cause some encroaching on <br>* the current display, as the parent window repaints after the move.  Therefore <br>* apps must take care to leave an empty border around their rendered image, <br>* equal to the maximum window move delta. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::UpdateWindow() <br>{  <br>    // update any children first <br> <br>    PSSW pssw = psswChildren; <br>    while( pssw ) { <br>        pssw-&gt;UpdateWindow(); <br>        pssw = pssw-&gt;psswSibling; <br>    } <br> <br>    // If this window is a subWindow in a non-generic implementation, the <br>    // background of the parent may be invalid (this may eventually be <br>    // useful for regular windows, which is why we don't &amp;&amp; !hwnd) <br>    if( psswParent &amp;&amp; <br>        psswParent-&gt;bValidateBg &amp;&amp; <br>        pGLc &amp;&amp;  <br>        !(pGLc-&gt;pfFlags &amp; SS_GENERIC_UNACCELERATED_BIT) ) <br>    { <br>        // Clear the entire parent window <br>        // mf: I think this is only needed for double-buffered schemes, since <br>        // the windowing system should repaint the front buffer in this case. <br>        glDisable( GL_SCISSOR_TEST ); <br>        glClear( GL_COLOR_BUFFER_BIT ); <br>        glEnable( GL_SCISSOR_TEST ); <br>        psswParent-&gt;bValidateBg = FALSE; <br>    } <br> <br>    if( !UpdateFunc ) <br>        return; <br> <br>    // bDoubleBuf and pStretch should be mutually exclusive... <br> <br>    if( bDoubleBuf || pStretch ) { <br>        UpdateDoubleBufWin(); <br>    } else { <br>        if( pMotion ) <br>            MoveSSWindow( TRUE ); <br>        (*UpdateFunc)( DataPtr ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* UpdateDoubleBufWin <br>* <br>* This is used when moving a double buffered window around.  It will <br>* work for all configurations. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::UpdateDoubleBufWin() <br>{  <br>    if( !hwnd ) { <br>        UpdateDoubleBufSubWin(); <br>        return; <br>    } <br> <br>    RECT updateRect; <br> <br>    // Move the window <br> <br>    if( pMotion ) { <br>        // Save child update rect before move <br>        GetSSWindowRect( &amp;updateRect ); <br>        // Move window, without repainting exposed area <br>        MoveSSWindow( FALSE ); <br>    } <br> <br>    // Update the back buffer <br> <br>    (*UpdateFunc)( DataPtr ); <br> <br>    if( pMotion ) { <br>        // (pMotion will be NULL if this window has no parent) <br>        if( hwnd ) { <br>            // Paint the exposed area with bg brush (the current image will <br>            // be partially erased momentarily, until the SwapBuffers() call <br>            // comes through) <br>            // (This rect should be clipped to our new window position...) <br>            DrawGdiRect( psswParent-&gt;hdc, gpss-&gt;hbrBg, &amp;updateRect ); <br>        } else { <br>// currently this path not possible, since if !hwnd, we use one of the <br>// UpdateDoubleBufSubWin* functions <br>            SS_WARNING( "SSW::UpdateDoubleBufWin: no hwnd\n" ); <br>            // sub-window case : need to do our own clipping <br>            RECT newRect; <br>            GetSSWindowRect( &amp;newRect ); <br>            DrawGdiDeltaRect( psswParent-&gt;hdc, gpss-&gt;hbrBg, &amp;updateRect, &amp;newRect );  <br>        } <br>    } <br> <br>    // Swap to the new window position <br>    SwapSSBuffers(); <br>} <br> <br> <br> <br>/**************************************************************************\ <br>* UpdateDoubleBufSubWin <br>* <br>* Used for generic double buffered gl sub-windows. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::UpdateDoubleBufSubWin() <br>{  <br>    GLRECT curRect, newRect; <br> <br>    // AddSwapHintRect for current position <br>    glAddSwapHintRect( pos.x, GLPosY(), size.width, size.height ); <br> <br>    if( pMotion ) { <br> <br>        // Save current rect <br>        curRect.x = pos.x; <br>        curRect.y = GLPosY(); <br>        curRect.width = size.width; <br>        curRect.height = size.height; <br> <br>        // Move window, without repainting exposed area <br>        MoveSSWindow( FALSE ); <br> <br>        // Get new rect <br>        newRect.x = pos.x; <br>        newRect.y = GLPosY(); <br>        newRect.width = size.width; <br>        newRect.height = size.height; <br> <br>        DrawGLDeltaRect( &amp;curRect, &amp;newRect ); <br> <br>        // Have to consider previous rect for ICD or MCD <br>        if( !(pGLc-&gt;pfFlags &amp; SS_GENERIC_UNACCELERATED_BIT) ) { <br>            DrawGLDeltaRect( &amp;lastRect, &amp;newRect ); <br>            lastRect = curRect; <br>        } <br> <br>        // Reset scissor to new rect (this *was* set by MoveSSWindow, but <br>        // DrawGLDeltaRect sets scissor to do its clearing <br>        glScissor( newRect.x, newRect.y, newRect.width, newRect.height ); <br>    } <br> <br>    // Update the back buffer <br> <br>    (*UpdateFunc)( DataPtr ); <br> <br>    // Swap to the new window position <br>    SwapSSBuffers(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* RandomWindowPos <br>* <br>* Sets a new random window position and motion <br>* <br>\**************************************************************************/ <br> <br>void  <br>SSW::RandomWindowPos() <br>{ <br>    if( psswParent ) { <br>        if( !hwnd ) { <br>            // sub-window : manually clear old window rect <br>            if( bDoubleBuf ) { <br>                glClear( GL_COLOR_BUFFER_BIT ); <br>            } else { <br>                RECT oldRect; <br>                GetSSWindowRect( &amp;oldRect ); <br>                DrawGdiRect( psswParent-&gt;hdc, gpss-&gt;hbrBg, &amp;oldRect ); <br>            } <br>        } <br> <br>        // Calc and set new position <br>        pos.x = ss_iRand2( 0, (psswParent-&gt;size.width - size.width) ); <br>        pos.y = ss_iRand2( 0, (psswParent-&gt;size.height - size.height) ); <br>        SetSSWindowPos( SWP_NOSIZE ); <br> <br>        // Reset motion <br>        if( pMotion ) <br>            ResetMotion(); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* ResetMotion <br>* <br>* Calculate a random position and motion vector for the floater window <br>* Note that a floating point position is maintained for DDA window movement <br>* <br>\**************************************************************************/ <br> <br>void  <br>SSW::ResetMotion() <br>{ <br>    if( !psswParent || !pMotion ) <br>        // Only child windows can be reset <br>        return; <br> <br>    // Set floating point pos also, for DDA <br>    pMotion-&gt;pos.x = (float) pos.x; <br>    pMotion-&gt;pos.y = (float) pos.y; <br> <br>    // also reset the window motion directions <br> <br>    if( ss_iRand(2) )  // 0 or 1 <br>        pMotion-&gt;posIncCur.x = - pMotion-&gt;posIncCur.x; <br>    if( ss_iRand(2) )  <br>        pMotion-&gt;posIncCur.y = - pMotion-&gt;posIncCur.y; <br>} <br> <br>/**************************************************************************\ <br>* ValidateChildSize <br>* <br>* Make sure it's not bigger than its parent <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::ValidateChildSize() <br>{ <br>    if( !psswParent ) <br>        return; <br> <br>    SS_CLAMP_TO_RANGE2( size.width, 0, psswParent-&gt;size.width ); <br>    SS_CLAMP_TO_RANGE2( size.height, 0, psswParent-&gt;size.height ); <br>} <br> <br>/**************************************************************************\ <br>* bValidateChildPos <br>* <br>* Make sure that with the current window position, none of the floating <br>* window extends beyond the parent window. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SSW::bValidateChildPos() <br>{ <br>    BOOL bRet = FALSE; <br> <br>    if( !psswParent ) <br>        return FALSE; <br> <br>    if ( (pos.x + size.width) &gt; psswParent-&gt;size.width) { <br>        pos.x = psswParent-&gt;size.width - size.width; <br>        bRet = TRUE; <br>    } <br> <br>    if ( (pos.y + size.height) &gt; psswParent-&gt;size.height) { <br>        pos.y = psswParent-&gt;size.height - size.height; <br>        bRet = TRUE; <br>    } <br>    return bRet; <br>} <br> <br>/**************************************************************************\ <br>* GetSSWindowRect <br>* <br>* Return window position and size in supplied RECT structure <br>* <br>* this rect is relative to the parent <br>\**************************************************************************/ <br> <br>void <br>SSW::GetSSWindowRect( LPRECT lpRect ) <br>{ <br>    lpRect-&gt;left = pos.x; <br>    lpRect-&gt;top = pos.y; <br>    lpRect-&gt;right = pos.x + size.width; <br>    lpRect-&gt;bottom = pos.y + size.height; <br>} <br> <br>/**************************************************************************\ <br>* GLPosY <br>* <br>* Return y-coord of window position in GL coordinates (a win32 window position <br>* (starts from top left, while GL starts from bottom left) <br>* <br>\**************************************************************************/ <br> <br>int <br>SSW::GLPosY() <br>{ <br>    if( !psswParent ) <br>        return 0; <br> <br>    return psswParent-&gt;size.height - size.height - pos.y; <br>} <br> <br>/**************************************************************************\ <br>* SwapStretchBuffers <br>* <br>* Swaps from the stretch buffer to the GL window, using StretchBlt <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::SwapStretchBuffers() <br>{ <br>    SS_BITMAP *pssbm = &amp;pStretch-&gt;ssbm; <br> <br>    if( (size.width == pssbm-&gt;size.width) &amp;&amp; <br>        (size.height == pssbm-&gt;size.height) ) // buffers same size <br>    { <br>        BitBlt(hdc, 0, 0, size.width, size.height, <br>               pssbm-&gt;hdc, 0, 0, SRCCOPY); <br>    }  <br>    else  <br>    { <br>        StretchBlt(hdc, 0, 0, size.width, size.height, <br>                   pssbm-&gt;hdc, 0, 0, pssbm-&gt;size.width, pssbm-&gt;size.height, <br>                   SRCCOPY); <br>    } <br>    GdiFlush(); <br>} <br> <br>/**************************************************************************\ <br>* SwapBuffers <br>* <br>* Wrapper for SwapBuffers / SwapStretchBuffers <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::SwapSSBuffers() <br>{ <br>    if( pStretch ) <br>        SwapStretchBuffers(); <br>    else if( bDoubleBuf ) <br>        SwapBuffers( hdc ); <br>} <br> <br>/**************************************************************************\ <br>* Reshape <br>* <br>* Reshape wrapper <br> <br>* Sends reshape msg to screen saver <br>* This is the size of the surface that gl renders onto, which can be a bitmap. <br>* <br>\**************************************************************************/ <br> <br>void <br>SSW::Reshape() <br>{ <br>    // Point to size of window, or bitmap if it has one <br>    ISIZE *pSize = &amp;size; <br>    if( pStretch ) <br>        pSize = &amp;pStretch-&gt;ssbm.size; <br> <br>    // If the window has an hrc, set default viewport <br> <br>    if( hrc ) { <br>        if( hwnd ) <br>            glViewport( 0, 0, pSize-&gt;width, pSize-&gt;height ); <br>        else if ( psswParent ) { <br>            // sub-window (only 1 level of sub-windowing supported) <br> <br>            // clear entire window to black <br>            glDisable( GL_SCISSOR_TEST ); <br>            glClear( GL_COLOR_BUFFER_BIT ); <br>            glEnable( GL_SCISSOR_TEST ); <br> <br>            // Convert win32 y-coord to GL <br>            glViewport( pos.x, GLPosY(), pSize-&gt;width, pSize-&gt;height ); <br>        } <br>    } <br> <br>    if( ReshapeFunc ) { <br>        (*ReshapeFunc)( pSize-&gt;width, pSize-&gt;height, DataPtr ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* GdiClear <br>* <br>* Clears window using Gdi FillRect <br>\**************************************************************************/ <br> <br>void <br>SSW::GdiClear() <br>{ <br>    if( !hdc ) <br>        return; <br> <br>    RECT rect; <br> <br>    GetSSWindowRect( &amp;rect ); <br> <br>    FillRect( hdc, &amp;rect, gpss-&gt;hbrBg ); <br>    GdiFlush(); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* MyAddSwapHintRect <br>* <br>\**************************************************************************/ <br> <br>static void _stdcall  <br>MyAddSwapHintRect(GLint xs, GLint ys, GLint xe, GLint ye) <br>{ <br>    return; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* QueryAddSwapHintRectWIN <br>* <br>\**************************************************************************/ <br> <br>static void <br>ss_QueryAddSwapHintRect() <br>{ <br>    glAddSwapHintRect = (PFNGLADDSWAPHINTRECTWINPROC) <br>        wglGetProcAddress("glAddSwapHintRectWIN"); <br>    if (glAddSwapHintRect == NULL) { <br>        glAddSwapHintRect = MyAddSwapHintRect; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DrawGdiDeltaRect <br>* <br>* Draw the exposed area by transition from rect1 to rect2 <br>\**************************************************************************/ <br> <br>static void <br>DrawGdiDeltaRect( HDC hdc, HBRUSH hbr, RECT *pRect1, RECT *pRect2 )  <br>{ <br>    if( (pRect1 == NULL) || (pRect2 == NULL) ) { <br>        SS_WARNING( "DrawGdiDeltaRect : one or both rects are NULL\n" ); <br>        return; <br>    } <br> <br>    // Draw 2 rects <br> <br>    RECT rect; <br> <br>    // Rect exposed in x-direction: <br> <br>    rect.top = pRect1-&gt;top; <br>    rect.bottom = pRect1-&gt;bottom; <br>    if( pRect2-&gt;left &gt; pRect1-&gt;left ) { <br>        // moving right <br>        rect.left = pRect1-&gt;left; <br>        rect.right = pRect2-&gt;left; <br>    } else { <br>        // moving left <br>        rect.left = pRect2-&gt;right; <br>        rect.right = pRect1-&gt;right; <br>    } <br>    FillRect( hdc, &amp;rect, hbr ); <br> <br>    // Rect exposed in y-direction: <br> <br>    rect.left = pRect1-&gt;left; <br>    rect.right = pRect1-&gt;right; <br>    if( pRect2-&gt;bottom &gt; pRect1-&gt;bottom ) { <br>        // moving down <br>        rect.top = pRect1-&gt;top; <br>        rect.bottom = pRect2-&gt;top; <br>    } else { <br>        // moving up <br>        rect.top = pRect2-&gt;bottom; <br>        rect.bottom = pRect1-&gt;bottom; <br>    } <br>    FillRect( hdc, &amp;rect, hbr ); <br> <br>    GdiFlush(); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* DrawGLDeltaRect <br>* <br>* Draw the exposed area by transition from rect1 to rect2 <br>\**************************************************************************/ <br> <br>static void <br>DrawGLDeltaRect( GLRECT *pRect1, GLRECT *pRect2 )  <br>{ <br>    if( (pRect1 == NULL) || (pRect2 == NULL) ) { <br>        SS_WARNING( "DrawGLDeltaRect : one or both rects are NULL\n" ); <br>        return; <br>    } <br> <br>    // Draw 2 rects : <br> <br>//mf: !!! this assumes rect1 and rect2 have same dimensions ! <br> <br>    GLRECT rect; <br> <br>    // Rect exposed in x-direction: <br> <br>    rect.height = pRect1-&gt;height; <br>    rect.y = pRect1-&gt;y; <br> <br>    if( pRect2-&gt;x &gt; pRect1-&gt;x ) { <br>        // moving right <br>        rect.width = pRect2-&gt;x - pRect1-&gt;x; <br>        rect.x = pRect1-&gt;x; <br>    } else { <br>        // moving left <br>        rect.width = pRect1-&gt;x - pRect2-&gt;x; <br>        rect.x = pRect2-&gt;x + pRect2-&gt;width; <br>    } <br> <br>    glScissor( rect.x, rect.y, rect.width, rect.height ); <br>    glClear( GL_COLOR_BUFFER_BIT ); <br> <br>    // Rect exposed in y-direction: <br> <br>    rect.width = pRect1-&gt;width; <br>    rect.x = pRect1-&gt;x; <br> <br>    if( pRect2-&gt;y &gt; pRect1-&gt;y ) { <br>        // moving up <br>        rect.height = pRect2-&gt;y - pRect1-&gt;y; <br>        rect.y = pRect1-&gt;y; <br>    } else { <br>        // moving down <br>        rect.height = pRect1-&gt;y - pRect2-&gt;y; <br>        rect.y = pRect2-&gt;y + pRect2-&gt;height; <br>    } <br> <br>    glScissor( rect.x, rect.y, rect.width, rect.height ); <br>    glClear( GL_COLOR_BUFFER_BIT ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
