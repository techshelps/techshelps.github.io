<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSCOMMON.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3704"></a>SSCOMMON.H</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: sscommon.h <br>* <br>* Defines and externals for screen saver common shell <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#ifndef __sscommon_h__ <br>#define __sscommon_h__ <br> <br>#include &lt;GL\gl.h&gt; <br>#include &lt;GL\glaux.h&gt; <br>#include &lt;assert.h&gt; <br>#include "matname.h"  // material names <br> <br>#ifdef __cplusplus <br>extern "C" { <br>#endif <br> <br>#include "ssdebug.h" <br> <br>#define FAILURE             0 <br>#define SUCCESS             1 <br> <br>// Maximum texture bitmap dimensions. <br> <br>#define TEX_WIDTH_MAX   1280 <br>#define TEX_HEIGHT_MAX  1024 <br> <br>#define PI 3.14159265358979323846f <br>// double version of PI <br>#define PI_D 3.14159265358979323846264338327950288419716939937510 <br>#define ONE_OVER_PI (1.0f / PI) <br>#define ROOT_TWO 1.414213562373f <br> <br>#define GEN_STRING_SIZE 64 <br> <br>// texture quality level <br>enum { <br>    TEXQUAL_DEFAULT = 0, <br>    TEXQUAL_HIGH <br>}; <br> <br>typedef struct _point2d { <br>    GLfloat x; <br>    GLfloat y; <br>} POINT2D; <br> <br>typedef struct _ipoint2d { <br>    int x; <br>    int y; <br>} IPOINT2D; <br> <br>typedef struct _point3d { <br>    GLfloat x; <br>    GLfloat y; <br>    GLfloat z; <br>} POINT3D; <br> <br>typedef struct _ipoint3d { <br>    int x; <br>    int y; <br>    int z; <br>} IPOINT3D; <br> <br>typedef struct _texpoint2d { <br>    GLfloat s; <br>    GLfloat t; <br>} TEX_POINT2D; <br> <br>typedef struct _isize { <br>    int width; <br>    int height; <br>} ISIZE; <br> <br>typedef struct _fsize { <br>    GLfloat width; <br>    GLfloat height; <br>} FSIZE; <br> <br>typedef struct _glrect { <br>    int x, y; <br>    int width, height; <br>} GLRECT; <br> <br>// texture data <br>typedef struct { <br>    int     width; <br>    int     height; <br>    GLenum  format; <br>    GLsizei components; <br>    float   origAspectRatio; // original width/height aspect ratio <br>    unsigned char *data; <br>    GLuint  texObj;          // texture object <br>    int     pal_size; <br>    int     iPalRot;         // current palette rotation (not used yet) <br>    RGBQUAD *pal; <br>} TEXTURE, *HTEXTURE; <br> <br>#ifndef GL_EXT_paletted_texture <br>#define GL_COLOR_INDEX1_EXT                   0x80E2 <br>#define GL_COLOR_INDEX2_EXT                   0x80E3 <br>#define GL_COLOR_INDEX4_EXT                   0x80E4 <br>#define GL_COLOR_INDEX8_EXT                   0x80E5 <br>#define GL_COLOR_INDEX12_EXT                  0x80E6 <br>#define GL_COLOR_INDEX16_EXT                  0x80E7 <br>typedef void (APIENTRY * PFNGLCOLORTABLEEXTPROC) <br>    (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, <br>     GLenum type, const GLvoid *data); <br>typedef void (APIENTRY * PFNGLCOLORSUBTABLEEXTPROC) <br>    (GLenum target, GLsizei start, GLsizei count, GLenum format, <br>     GLenum type, GLvoid *data); <br>#endif <br> <br>// texture resource <br> <br>#define RT_RGB          99 <br>#define RT_MYBMP        100 <br>#define RT_A8           101 <br> <br>// texture resource types <br>enum { <br>    TEX_UNKNOWN = 0, <br>    TEX_RGB, <br>    TEX_BMP, <br>    TEX_A8 <br>}; <br> <br>typedef struct { <br>    int     type; <br>    int     name; <br>} TEX_RES; <br> <br>typedef struct _MATRIX { <br>    GLfloat M[4][4]; <br>} MATRIX; <br> <br>typedef struct strRGBA { <br>    GLfloat r; <br>    GLfloat g; <br>    GLfloat b; <br>    GLfloat a; <br>} RGBA; <br> <br>typedef struct { <br>    BYTE r; <br>    BYTE g; <br>    BYTE b; <br>} RGB8; <br> <br>typedef struct { <br>    BYTE r; <br>    BYTE g; <br>    BYTE b; <br>    BYTE a; <br>} RGBA8; <br> <br>// DlgDraw <br> <br>enum { <br>    DLG_INTENSITY_LOW = 0, <br>    DLG_INTENSITY_MID, <br>    DLG_INTENSITY_HIGH, <br>}; <br> <br>// Callback function defines <br>typedef void (CALLBACK* SSINITPROC)( void *); <br>typedef void (CALLBACK* SSRESHAPEPROC)(int, int, void *); <br>typedef void (CALLBACK* SSREPAINTPROC)( LPRECT, void *); <br>typedef void (CALLBACK* SSUPDATEPROC)( void *); <br>typedef void (CALLBACK* SSFINISHPROC)( void *); <br>typedef void (CALLBACK* SSFLOATERFAILPROC)(void *); <br>typedef void (CALLBACK* SSFLOATERBOUNCEPROC)( void *); <br> <br>// Defines for pixel format (internal use) <br>#define SS_DOUBLEBUF_BIT    (1 &lt;&lt; 0) <br>#define SS_DEPTH16_BIT      (1 &lt;&lt; 1) <br>#define SS_DEPTH32_BIT      (1 &lt;&lt; 2) <br>#define SS_ALPHA_BIT        (1 &lt;&lt; 3) <br>#define SS_BITMAP_BIT       (1 &lt;&lt; 4) <br>#define SS_NO_SYSTEM_PALETTE_BIT       (1 &lt;&lt; 5) <br>#define SS_GENERIC_UNACCELERATED_BIT   (1 &lt;&lt; 6) <br> <br>#define SS_HAS_DOUBLEBUF(x) ((x) &amp; SS_DOUBLEBUF_BIT) <br>#define SS_HAS_DEPTH16(x)((x) &amp; SS_DEPTH16_BIT) <br>#define SS_HAS_DEPTH32(x)((x) &amp; SS_DEPTH32_BIT) <br>#define SS_HAS_ALPHA(x)     ((x) &amp; SS_ALPHA_BIT) <br>#define SS_HAS_BITMAP(x)    ((x) &amp; SS_BITMAP_BIT) <br> <br>// Depth types <br>enum { <br>    SS_DEPTH_NONE = 0, <br>    SS_DEPTH16, <br>    SS_DEPTH32, <br>}; <br> <br>// ss context structures <br> <br>// Note: all *_INFO structures are requests between common and client ss <br> <br>typedef struct { <br>    POINT2D    posInc;          // base position increment <br>    POINT2D    posIncVary;      // +/- variation for posInc on bounce <br>} MOTION_INFO; <br> <br>// internal motion structure <br>typedef struct { <br>    POINT2D    pos;             // position <br>    POINT2D    posInc;          // base position increment <br>    POINT2D    posIncVary;      // +/- variation for posInc on bounce <br>    POINT2D    posIncCur;       // Current position increment <br>} MOTION; <br> <br>// Size and motion attributes of the OpenGL window that floats around. <br>typedef struct { <br>    ISIZE      size; <br>    IPOINT2D    pos;             // position <br>    MOTION_INFO     motionInfo; <br>} CHILD_INFO; <br> <br>typedef void (CALLBACK* SSCHILDSIZEPROC)( ISIZE *, CHILD_INFO * ); <br> <br>// Size and motion attributes of the OpenGL window that floats around. <br>typedef struct { <br>    BOOL       bMotion;         // if floater should move or not <br>    BOOL       bSubWindow;      // If floater is logical sub-window <br>    SSCHILDSIZEPROC   ChildSizeFunc; // Callback to set size based on parent <br>} FLOATER_INFO; <br> <br> <br>// SS_BITMAP already defined in winuser.h <br>#if defined( SS_BITMAP ) <br>#undef SS_BITMAP <br>#endif <br> <br>typedef struct { <br>    HDC     hdc; <br>    ISIZE   size; <br>    HBITMAP hbm; <br>    HBITMAP hbmOld; // ? necessary ? <br>} SS_BITMAP; <br> <br> <br>// Attributes for StretchBlt mode <br>typedef struct { <br>    BOOL       bRatioMode;      // use ratio or base width <br>    float      widthRatio;      // e.g. 2 means use base of (window width / 2) <br>    float      heightRatio; <br>    int        baseWidth; <br>    int        baseHeight; <br>    SS_BITMAP  ssbm; <br>} STRETCH_INFO; <br> <br> <br>typedef struct { <br>    BOOL bFloater; <br>    FLOATER_INFO floaterInfo; <br>    BOOL bStretch; <br>    STRETCH_INFO stretchInfo; <br>    BOOL bDoubleBuf; <br>    int  depthType; <br>} SSContext, SSC, *PSSC; <br> <br>typedef struct _MATERIAL { <br>    RGBA ka; <br>    RGBA kd; <br>    RGBA ks; <br>    GLfloat specExp; <br>} MATERIAL; <br> <br>// texture file info <br> <br>typedef struct { <br>    int     nOffset;  // filename offset into pathname <br>    TCHAR   szPathName[MAX_PATH];  // texture pathname <br>} TEXFILE; <br> <br>// texture file processing messages <br> <br>typedef struct { <br>    TCHAR   szWarningMsg[MAX_PATH]; <br>    TCHAR   szBitmapSizeMsg[MAX_PATH]; <br>    TCHAR   szBitmapInvalidMsg[MAX_PATH]; <br>    TCHAR   szSelectAnotherBitmapMsg[MAX_PATH]; <br>    TCHAR   szTextureDialogTitle[GEN_STRING_SIZE]; <br>    TCHAR   szTextureFilter[2*GEN_STRING_SIZE]; <br>    TCHAR   szBmp[GEN_STRING_SIZE]; <br>    TCHAR   szDotBmp[GEN_STRING_SIZE]; <br>} TEX_STRINGS; <br> <br>// Resource constants common to all screen savers <br> <br>#define IDS_COPYRIGHT           9001 <br>#define IDS_GENNAME             9003 <br>#define IDS_INIFILE             9006 <br>#define IDS_HELPFILE            9009 <br>#define IDS_WARNING             9014 <br>#define IDS_ERROR               9015 <br>#define IDS_BITMAP_SIZE         9016 <br>#define IDS_BITMAP_INVALID      9017 <br>#define IDS_SELECT_ANOTHER_BITMAP 9018 <br>#define IDS_START_FAILED        9019 <br>#define IDS_TEXTUREFILTER       9021 <br>#define IDS_TEXTUREDIALOGTITLE  9022 <br>#define IDS_BMP                 9023 <br>#define IDS_DOTBMP              9024 <br>#define IDS_STARDOTBMP          9025 <br>#define IDS_RGB                 9030 <br>#define IDS_DOTRGB              9031 <br>#define IDS_STARDOTRGB          9032 <br>#define IDS_TEXTURE             9126 <br>#define IDS_TEXTURE_FILE_OFFSET 9127 <br>#define IDS_SIZE                9129 <br>#define IDS_TESSELATION         9130 <br> <br>// Useful macros <br> <br>#define SS_MAX( a, b ) \ <br>    ( a &gt; b ? a : b ) <br> <br>#define SS_MIN( a, b ) \ <br>    ( a &lt; b ? a : b ) <br> <br>// macro to round up floating values <br>#define SS_ROUND_UP( fval ) \ <br>    ( (((fval) - (FLOAT)(int)(fval)) &gt; 0.0f) ? (int) ((fval)+1.0f) : (int) (fval) ) <br> <br>// macros to clamp a value within a range <br>#define SS_CLAMP_TO_RANGE( a, lo, hi ) ( (a &lt; lo) ? lo : ((a &gt; hi) ? hi : a) ) <br>#define SS_CLAMP_TO_RANGE2( a, lo, hi ) \ <br>    ( a = (a &lt; lo) ? lo : ((a &gt; hi) ? hi : a) ) <br> <br>// degree&lt;-&gt;radian macros <br>#define ONE_OVER_180 (1.0f / 180.0f) <br>#define SS_DEG_TO_RAD( a ) ( (a*PI) * ONE_OVER_180 ) <br>#define SS_RAD_TO_DEG( a ) ( (a*180.0f) * ONE_OVER_PI ) <br> <br>extern MATERIAL TeaMaterial[], TexMaterial[], ss_BlackMat; <br> <br>// window handling <br> <br>extern void ss_InitFunc(SSINITPROC); <br>extern void ss_ReshapeFunc(SSRESHAPEPROC); <br>extern void ss_RepaintFunc(SSREPAINTPROC); <br>extern void ss_UpdateFunc(SSUPDATEPROC); <br>extern void ss_FinishFunc(SSFINISHPROC); <br>extern void ss_FloaterBounceFunc(SSFLOATERBOUNCEPROC); <br> <br>// This function *must* be defined by the screen saver <br>extern SSContext* ss_Init(void); <br>extern BOOL ss_ConfigInit( HWND hDlg ); <br> <br>extern void ss_DataPtr( void * ); <br> <br>extern BOOL ss_SetWindowAspectRatio( FLOAT aspect ); <br>extern void ss_RandomWindowPos( void ); <br> <br>extern HWND ss_GetHWND(); <br>extern HWND ss_GetGLHWND(); <br>extern void ss_GetScreenSize( ISIZE *size ); <br> <br>extern HBITMAP <br>SSDIB_CreateCompatibleDIB(HDC hdc, HPALETTE hpal, ULONG ulWidth, ULONG ulHeight, <br>                    PVOID *ppvBits); <br>extern BOOL APIENTRY SSDIB_UpdateColorTable(HDC hdcMem, HDC hdc, HPALETTE hpal); <br> <br>// Palette manage procs <br>extern LONG MainPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br>extern LONG PaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br>extern LONG FullScreenPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br>extern LONG NullPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br> <br>// material processing <br> <br>extern void ss_InitTeaMaterials(); <br>extern void ss_InitTexMaterials(); <br>extern void ss_InitMaterials(); <br>extern void ss_SetMaterial( MATERIAL *pMat ); <br>extern void ss_SetMaterialIndex( int index ); <br>extern MATERIAL *ss_RandomTeaMaterial( BOOL bSet ); <br>extern int  ss_RandomTeaMaterialIndex( BOOL bSet ); <br>extern MATERIAL *ss_RandomTexMaterial( BOOL bSet ); <br>extern int  ss_RandomTexMaterialIndex( BOOL bSet ); <br>extern void ss_CreateMaterialGradient( MATERIAL *matInc, MATERIAL *startMat, <br>                        MATERIAL *endMat, int transCount ); <br>extern void ss_TransitionMaterial( MATERIAL *transMat, MATERIAL *transMatInc ); <br> <br>// color <br> <br>extern void ss_HsvToRgb(float h, float s, float v, RGBA *color ); <br> <br>// clear <br> <br>extern int ss_RectWipeClear( int width, int height, int repCount ); <br>extern int ss_DigitalDissolveClear( int width, int height, int size ); <br> <br>// utility <br> <br>extern void ss_RandInit( void ); <br>extern int ss_iRand( int max ); <br>extern int ss_iRand2( int min, int max ); <br>extern FLOAT ss_fRand( FLOAT min, FLOAT max ); <br>extern BOOL ss_ChangeDisplaySettings( int width, int height, int bitDepth ); <br>extern void ss_QueryDisplaySettings( void ); <br>extern void ss_QueryOSVersion( void ); <br>extern void ss_QueryGLVersion( void ); <br>extern BOOL ss_fOnWin95( void ); <br>extern BOOL ss_fOnNT35( void ); <br>extern BOOL ss_fOnGL11( void ); <br>extern BOOL ss_fPreviewMode( void ); <br>extern BOOL ss_fFullScreenMode( void ); <br>extern BOOL ss_fWindowMode( void ); <br>extern BOOL ss_fConfigMode( void ); <br>extern BOOL ss_RedrawDesktop( void ); <br> <br>// texture file processing <br> <br>extern int  ss_LoadBMPTextureFile( LPCTSTR pszBmpfile, TEXTURE *pTex ); <br>extern int  ss_LoadTextureFile( TEXFILE *texFile, TEXTURE *pTex ); <br>extern int  ss_LoadTextureResource( TEX_RES *pTexRes, TEXTURE *pTex ); <br>extern BOOL ss_CopyTexture( TEXTURE *pTexDst, TEXTURE *pTexSrc ); <br>extern BOOL ss_SetTextureTransparency( TEXTURE *pTex, float alpha, BOOL bSet ); <br>extern void ss_DisableTextureErrorMsgs(); <br>extern void ss_SetTexture( TEXTURE *pTex ); <br>extern void ss_SetTexturePalette( TEXTURE *pTex, int index ); <br>extern void ss_DeleteTexture( TEXTURE *pTex ); <br>extern BOOL ss_LoadTextureResourceStrings(); <br>extern BOOL ss_DIBImageLoad(PVOID pvFile, TEXTURE *ptex); <br>extern BOOL ss_RGBImageLoad(PVOID pvFile, TEXTURE *ptex); <br>extern BOOL ss_A8ImageLoad(PVOID pvFile, TEXTURE *ptex); <br>extern BOOL ss_VerifyTextureFile( TEXFILE *ptf ); <br>extern BOOL ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf ); <br>extern void ss_GetDefaultBmpFile( LPTSTR pszBmpFile ); <br>extern void ss_InitAutoTexture( TEX_POINT2D *pTexRep ); <br> <br>// texture objects <br> <br>extern BOOL ss_TextureObjectsEnabled( void ); <br> <br>// Paletted texture support <br>extern BOOL ss_PalettedTextureEnabled(void); <br>extern BOOL ss_QueryPalettedTextureEXT(void); <br> <br>// math functions <br> <br>extern POINT3D ss_ptZero; <br>extern void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *); <br>extern void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *); <br>extern void ss_matrixIdent(MATRIX *); <br>extern void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta); <br>extern void ss_matrixTranslate(MATRIX *, double xTrans, double yTrans, double zTrans); <br>extern void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 ); <br>extern void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3); <br>extern void ss_normalizeNorm(POINT3D *); <br>extern void ss_normalizeNorms(POINT3D *, ULONG); <br> <br>// registry functions <br> <br>extern BOOL ss_RegistrySetup( HINSTANCE hinst, int section, int file ); <br>extern int  ss_GetRegistryInt( int name, int iDefault ); <br>extern void ss_GetRegistryString( int name, LPTSTR lpDefault, LPTSTR lpDest, int bufSize ); <br>extern void ss_WriteRegistryInt( int name, int iVal ); <br>extern void ss_WriteRegistryString( int name, LPTSTR lpString ); <br> <br>// dialog helper functions <br> <br>extern int ss_GetTrackbarPos( HWND hDlg, int item ); <br>extern void ss_SetupTrackbar( HWND hDlg, int item, int lo, int hi, int lineSize, int pageSize, int pos ); <br> <br>extern BOOL gbTextureObjects; // from texture.c <br> <br>#ifdef __cplusplus <br>} <br>#endif <br> <br>#endif // __sscommon_h__ </code></pre>
<p>&nbsp;</p></body>
</HTML>
