<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSTEXT3D.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3766"></a>SSTEXT3D.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: sstext3d.c <br>* <br>* Core code for text3D screen saver <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;fcntl.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/glaux.h&gt; <br> <br>#include "sscommon.h" <br>#include "sstext3d.h" <br> <br>#define FMAX_CHORDAL_DEVIATION   0.008f <br> <br>#define FMIN_DEPTH           0.15f <br>#define FMAX_DEPTH           0.6f <br> <br>#define FMIN_VIEW_ANGLE      90.0f <br>#define FMAX_VIEW_ANGLE     130.0f <br> <br>#define FMIN_RANDOM_ANGLE    45.0f <br>#define FMAX_RANDOM_ANGLE    89.0f <br> <br>#define FMIN_SEESAW_ANGLE    63.0f <br>#define FMAX_SEESAW_ANGLE    88.0f <br> <br>#define FMIN_WOBBLE_ANGLE    30.0f <br>#define FMAX_WOBBLE_ANGLE    55.0f <br>#define FMIN_WOBBLE_ANGLE2   40.0f <br>#define FMAX_WOBBLE_ANGLE2   80.0f <br> <br>#define MIN_ROT_STEP          1 <br>#define MAX_ROT_STEP         20 <br> <br>#define FMAX_ZOOM             5.0f <br> <br>// globals <br> <br>static FLOAT gfMinCycleTime = 10.0f; <br>static POINTFLOAT gTrig[360];  // pre-calculated table of sines and cosines <br>static POINTFLOAT gSawTooth[360]; // sawtooth table <br>static POINTFLOAT gInvTrig[360];  // pseudo-inverse trig table <br>static POINT gTrigDif[360];   // table for converting trig-&gt;invtrig <br>static POINT gInvTrigDif[360];   // table for converting invtrig-&gt;trig <br> <br>AttrContext gac; <br> <br>// Default texture resource <br>TEX_RES gTexRes = { TEX_BMP, IDB_DEFTEX }; <br> <br>typedef struct _LIST *PLIST; <br>typedef struct _LIST { <br>    PLIST pnext; <br>    PLIST plistComplete; <br>    LPTSTR pszStr; <br>} LIST; <br> <br>PLIST gplistComplete = NULL; <br>PLIST gplist = NULL; <br>static void DeleteNameList(); <br> <br>void text3d_Init( void *data  ); <br>void text3d_Reset(void *data ); <br>void text3d_Draw(void *data ); <br>void text3d_Reshape(int width, int height, void *data ); <br>void text3d_Finish( void *data ); <br>static void CalcViewParams( AttrContext *pac ); <br>static BOOL InitFont( AttrContext *pac ); <br>static void InitLighting( AttrContext *pac ); <br>static void InitTexture( AttrContext *pac ); <br>static void InitMaterials( AttrContext *pac ); <br>static void InitView( AttrContext *pac ); <br>static FLOAT MapValue( FLOAT fInVal, <br>                       FLOAT fIn1, FLOAT fIn2, <br>                       FLOAT fOut1, FLOAT fOut2 ); <br>static int  MapValueI( int inVal, int in1, int in2, int out1, int out2 ); <br>static FLOAT CalcChordalDeviation( HDC hdc, AttrContext *pac ); <br>static void (*BoundingBoxProc)( AttrContext *pac); <br>static void CalcBoundingBox( AttrContext *pac ); <br>static void CalcBoundingBoxFromSphere( AttrContext *pac ); <br>static void CalcBoundingBoxFromSpherePlus( AttrContext *pac, FLOAT zmax ); <br>static void CalcBoundingBoxGeneric( AttrContext *pac ); <br>static void CalcBoundingBoxFromExtents( AttrContext *pac, POINT3D *box ); <br>static void CalcBoundingExtent( FLOAT rot, FLOAT x, FLOAT y, <br>                                POINTFLOAT *extent ); <br>static void SortBoxes( POINT3D *box, FLOAT *boxvp, int numBox ); <br>static void (*GetNextRotProc)( AttrContext *pac ); <br>static void GetNextRotNone( AttrContext *pac ); <br>static void GetNextRotRandom( AttrContext *pac ); <br>static void GetNextRotWobble( AttrContext *pac ); <br>static void InitTrigTable(); <br>static void text3d_UpdateTime( AttrContext *pac, BOOL bCheckBounds ); <br>static void text3d_UpdateString( AttrContext *pac, BOOL bCheckBounds ); <br>static BOOL VerifyString( AttrContext *pac ); <br>static BOOL CheckKeyStrings( LPTSTR testString, PSZ psz ); <br>static void ConvertStringAsciiToUnicode( PSZ psz, PWSTR pwstr, int len ); <br>static void InvertBitsA( char *s, int len ); <br>static void ReadNameList(); <br>static PSZ ReadStringFileA( char *file ); <br>static void CreateRandomList(); <br>static void ResetRotationLimits( AttrContext *pac, int *reset ); <br>static int FrameCalibration( AttrContext *pac, struct _timeb *pBaseTime, int framesPerCycle, <br>                             int nCycle ); <br>static void SetTransitionPoints( AttrContext *pac, int framesPerCycle, <br>                                int *trans1, int *trans2, FLOAT *zTrans ); <br>static void <br>AdjustRotationStep( AttrContext *pac, int *reset, POINTFLOAT *oldTrig ); <br> <br>/******************************Public*Routine******************************\ <br>* SetFloaterInfo <br>* <br>* Set the size and motion of the floating window <br>* <br>* ss_SetWindowAspectRatio may be called after this, to finely crop the <br>* window to the text being displayed.  But we can't call it here, since this <br>* function is called by common when creating the floating window, before the <br>* text string size has been determined. <br>\**************************************************************************/ <br> <br>static void <br>SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild ) <br>{ <br>    float sizeFact; <br>    float sizeScale; <br>    int size; <br>    ISIZE *pChildSize = &amp;pChild-&gt;size; <br>    MOTION_INFO *pMotion = &amp;pChild-&gt;motionInfo; <br>    AttrContext *pac = &amp;gac; <br> <br>    sizeScale = (float)pac-&gt;uSize / 100.0f;  // range 0..1 <br>    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75% <br>    size = (int) (sizeFact *  <br>            ( ((float)(pParentSize-&gt;width + pParentSize-&gt;height)) / 2.0f )); <br>    SS_CLAMP_TO_RANGE2( size, 0, pParentSize-&gt;width ); <br>    SS_CLAMP_TO_RANGE2( size, 0, pParentSize-&gt;height ); <br> <br>    pChildSize-&gt;width = pChildSize-&gt;height = size; <br>    pMotion-&gt;posInc.x = .01f * (float) size; <br>    if( pMotion-&gt;posInc.x &lt; 1.0f ) <br>        pMotion-&gt;posInc.x = 1.0f; <br>    pMotion-&gt;posInc.y = pMotion-&gt;posInc.x; <br>    pMotion-&gt;posIncVary.x = .4f * pMotion-&gt;posInc.x; <br>    pMotion-&gt;posIncVary.y = pMotion-&gt;posIncVary.x; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* Init <br>* <br>* Initialize - called on first entry into ss. <br>* Called BEFORE gl is initialized! <br>* Just do basic stuff here, like set up callbacks, verify dialog stuff, etc. <br>* <br>* Fills global SSContext structure with required data, and returns ptr <br>* to it. <br>* <br>\**************************************************************************/ <br> <br>SSContext * <br>ss_Init( void ) <br>{ <br>    // validate some initial dialog settings <br>    getIniSettings();  // also called on dialog init <br> <br>    // must verify textures here, before GL floater windows are created <br>    if( gac.surfStyle == SURFSTYLE_TEX ) { <br>        ss_DisableTextureErrorMsgs(); <br>        ss_VerifyTextureFile( &amp;gac.texFile ); <br>    } <br> <br>    // set Init callback <br>    ss_InitFunc( text3d_Init ); <br> <br>    // set data ptr to be sent with callbacks <br>    ss_DataPtr( &amp;gac ); <br> <br>    // set configuration info to return <br> <br>    gac.ssc.bFloater = TRUE; <br>    gac.ssc.floaterInfo.bMotion = TRUE; <br>    gac.ssc.floaterInfo.ChildSizeFunc = SetFloaterInfo; <br> <br>    gac.ssc.bDoubleBuf = TRUE; <br>    gac.ssc.depthType = SS_DEPTH16; <br> <br>    return &amp;gac.ssc; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* text3d_Init <br>* <br>* Initializes OpenGL state for text3d screen saver <br>* <br>\**************************************************************************/ <br>void <br>text3d_Init( void *data ) <br>{ <br>    AttrContext *pac = (AttrContext *) data; <br> <br>    // Set any callbacks that require GL <br>    ss_UpdateFunc( text3d_Draw ); <br>    ss_ReshapeFunc( text3d_Reshape ); <br>    ss_FinishFunc( text3d_Finish ); <br> <br>#ifdef SS_DEBUG <br>    glClearColor( 0.2f, 0.2f, 0.2f, 0.0f ); <br>#else <br>    glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <br>#endif <br> <br>    glDepthFunc(GL_LEQUAL); <br>    glEnable(GL_DEPTH_TEST); <br> <br>    // this sequence must be maintained <br> <br>    InitLighting( pac ); <br> <br>    InitFont( pac ); <br> <br>    InitView( pac ); <br> <br>    InitTexture( pac ); <br> <br>    InitMaterials( pac ); <br>} <br> <br>/**************************************************************************\ <br>* InitLighting <br>* <br>* Initialize lighting, and back face culling. <br>* <br>\**************************************************************************/ <br>static void <br>InitLighting( AttrContext *pac ) <br>{ <br>    float ambient1[] = {0.2f, 0.2f, 0.2f, 1.0f}; <br>    float ambient2[] = {0.1f, 0.1f, 0.1f, 1.0f}; <br>    float diffuse1[] = {0.7f, 0.7f, 0.7f, 1.0f}; <br>    float diffuse2[] = {0.7f, 0.7f, 0.7f, 1.0f}; <br>    float position1[] = {0.0f, 50.0f, 150.0f, 0.0f}; <br>    float position2[] = {25.0f, 150.0f, 50.0f, 0.0f}; <br>    float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f}; <br> <br>    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient1); <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse1); <br>    glLightfv(GL_LIGHT0, GL_POSITION, position1); <br>    glEnable(GL_LIGHT0); <br> <br>    glLightfv(GL_LIGHT1, GL_AMBIENT, ambient2); <br>    glLightfv(GL_LIGHT1, GL_DIFFUSE, diffuse2); <br>    glLightfv(GL_LIGHT1, GL_POSITION, position2); <br>    glEnable(GL_LIGHT1); <br> <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient); <br>    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE); <br>    glCullFace( GL_BACK ); <br>    glEnable(GL_CULL_FACE); <br>    glEnable(GL_LIGHTING); <br>} <br> <br>/**************************************************************************\ <br>* TestFont <br>* <br>* Test that GetOutlineTextMetrics works.  If not, wglUseFontOutlines will fail. <br>* <br>* If the font tests bad, delete it and select in the previous one. <br>* <br>\**************************************************************************/ <br> <br>static BOOL <br>TestFont( HFONT hfont ) <br>{ <br>    OUTLINETEXTMETRIC otm; <br>    HFONT hfontOld; <br>    HDC hdc = wglGetCurrentDC(); <br> <br>    hfontOld = SelectObject(hdc, hfont); <br> <br>    if( GetOutlineTextMetrics( hdc, sizeof(otm), &amp;otm) &lt;= 0 ) { <br>        SS_DBGPRINT( "sstext3d Init: GetOutlineTextMetrics failure\n" ); <br>        SelectObject(hdc, hfontOld); <br>        DeleteObject( hfont ); <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* CreateFont <br>* <br>* Create a true type font and test it <br>* <br>\**************************************************************************/ <br> <br>static HFONT <br>text3d_CreateFont( LOGFONT *plf ) <br>{ <br>    HFONT hfont; <br> <br>    // Create font from LOGFONT data <br>    hfont = CreateFontIndirect(plf); <br> <br>    if( hfont ) { <br>        // Test the font <br>        if( ! TestFont( hfont ) ) <br>            hfont = (HFONT) 0; <br>    } <br>    return hfont; <br>} <br> <br>/**************************************************************************\ <br>* InitFont <br>* <br>* <br>\**************************************************************************/ <br>static BOOL <br>InitFont( AttrContext *pac ) <br>{ <br>    LOGFONT lf; <br>    HFONT hfont; <br>    int type; <br>    float fChordalDeviation; <br>    HDC hdc = wglGetCurrentDC(); <br> <br>    // Set up the LOGFONT structure <br> <br>    memset(&amp;lf, 0, sizeof(LOGFONT)); <br>    lstrcpy( lf.lfFaceName, pac-&gt;szFontName ); <br>    lf.lfWeight = (pac-&gt;bBold) ? FW_BOLD : FW_NORMAL; <br>    lf.lfItalic = (pac-&gt;bItalic) ? (BYTE) 1 : 0; <br> <br>    lf.lfHeight = 0; // shouldn't matter <br>    lf.lfCharSet = pac-&gt;charSet; <br>    lf.lfOutPrecision = OUT_TT_ONLY_PRECIS; <br> <br>    // Create the font <br> <br>    if( ! (hfont = text3d_CreateFont( &amp;lf )) ) { <br>        // Couldn't create a true type font with supplied data <br>        SS_DBGPRINT( "initial text3d_CreateFont failed: \n" ); <br>    } <br> <br>    if( !hfont &amp;&amp; ss_fOnWin95() ) { <br>    // the font mapper didn't give us anything useful <br>    // For some reason GetOutlineTextMetrics fails for some fonts (Symbol) <br>    // when using lfHeight = 0 (default height value). <br>        lf.lfHeight = -10; <br>        if( ! (hfont = text3d_CreateFont( &amp;lf )) ) { <br>            SS_DBGPRINT( "text3d_CreateFont with lfHeight != 0 failed: \n" ); <br>        } <br>    } <br> <br>    if( hfont == NULL ) { <br>        /* The requested font cannot be loaded.  Try to get the system to <br>         * load any TrueType font <br>         */ <br>        hfont = CreateFont( 100, 100, 0, 0, lf.lfWeight, lf.lfItalic, <br>                             0, 0, 0, OUT_TT_ONLY_PRECIS, CLIP_DEFAULT_PRECIS, <br>                             DEFAULT_QUALITY, DEFAULT_PITCH, NULL ); <br>        // If hfont is still null, nothing will be displayed. <br>        if( !hfont || !TestFont(hfont) ) { <br>            SS_DBGPRINT( "text3d_InitFont failure\n" ); <br>            return FALSE; <br>        } <br>    } <br> <br>    // We have a valid font <br> <br>    SelectObject(hdc, hfont); <br> <br>    // Set extrusion, chordal deviation, and font type <br> <br>#ifdef _PPC_ <br>    // !!! Work around for PPC compiler bug <br> <br>    // calculate chordalDeviation from input attribute fTesselFact <br>    fChordalDeviation = CalcChordalDeviation( hdc, pac ); <br> <br>    pac-&gt;fDepth = ss_fRand( FMIN_DEPTH, FMAX_DEPTH ); <br>#else <br>    pac-&gt;fDepth = ss_fRand( FMIN_DEPTH, FMAX_DEPTH ); <br> <br>    // calculate chordalDeviation from input attribute fTesselFact <br>    fChordalDeviation = CalcChordalDeviation( hdc, pac ); <br>#endif <br> <br>    type = pac-&gt;surfStyle == SURFSTYLE_WIREFRAME ? WGL_FONT_LINES : <br>                                                   WGL_FONT_POLYGONS; <br> <br>    // Create a wgl font context <br> <br>    if( !(pac-&gt;pWglFontC =  <br>            CreateWglFontContext( hdc, type, pac-&gt;fDepth, fChordalDeviation )) ) <br>        return FALSE; <br> <br>    // intialize the text that will be displayed <br> <br>    if( pac-&gt;demoType == DEMO_CLOCK ) { <br>        text3d_UpdateTime( pac, FALSE );  // sets pac-&gt;textXXX params as well <br>    } else if( pac-&gt;demoType == DEMO_STRING ) { <br>        if( !VerifyString( pac ) ) { <br>            ConvertStringToList( pac-&gt;szText, pac-&gt;usText, pac-&gt;pWglFontC ); <br>            pac-&gt;textLen = GetStringExtent( pac-&gt;szText, &amp;pac-&gt;pfTextExtent, <br>                                         &amp;pac-&gt;pfTextOrigin, <br>                                         pac-&gt;pWglFontC ); <br>        } <br>    } <br>    return SUCCESS; <br>} <br> <br> <br>/**************************************************************************\ <br>* InitView <br>* <br>* <br>\**************************************************************************/ <br>static void <br>InitView( AttrContext *pac ) <br>{ <br>    int numRots=0, axis; <br>    FLOAT *p3dRotMax = (FLOAT *) &amp;pac-&gt;p3dRotMax; <br>    FLOAT *p3dRotMin = (FLOAT *) &amp;pac-&gt;p3dRotMin; <br>    int *ip3dRotStep = (int *) &amp;pac-&gt;ip3dRotStep; <br>    POINT3D p3d_zero = {0.0f, 0.0f, 0.0f}; <br>    int stepRange = 2; // default step range <br>    int reset[NUM_AXIS] = {1, 1, 1}; <br> <br>    // text is either xmajor or ymajor <br>    pac-&gt;bXMajor = pac-&gt;pfTextExtent.x &gt;= pac-&gt;pfTextExtent.y ? TRUE : FALSE; <br> <br> <br>    /* At this point, the initial string extents will have been <br>     * calculated, and we can use this to determine rotational <br>     * characteristics <br>     */ <br> <br>    // default proc to get next rotation <br>    GetNextRotProc = GetNextRotRandom; <br> <br>    /* convert the slider speed values to rotation steps, with <br>     * a steeper slope at the beginning of the scale <br>     */ <br>    pac-&gt;iRotStep = MapValueI( pac-&gt;iSpeed, <br>                               MIN_SLIDER, MAX_SLIDER,  // slider range <br>                               MIN_ROT_STEP, MAX_ROT_STEP ); // step range <br> <br>    // initialize rotation min/max to 0 <br>    *( (POINT3D*)p3dRotMin ) = p3d_zero; <br>    *( (POINT3D*)p3dRotMax ) = p3d_zero; <br>    pac-&gt;p3dRot = p3d_zero; <br> <br>    /* Set the MAXIMUM rotation limits.  This is required initially, in <br>     * order to set the bounding box <br>     */ <br>    switch( pac-&gt;rotStyle ) { <br>        case ROTSTYLE_NONE: <br>            GetNextRotProc = GetNextRotNone; <br>            break; <br> <br>        case ROTSTYLE_SEESAW: <br>            // rotate minor axis <br>            if( pac-&gt;demoType == DEMO_VSTRING ) <br>                // always rotate around y-axis <br>                axis = Y_AXIS; <br>            else <br>                axis = pac-&gt;bXMajor ? Y_AXIS : X_AXIS; <br>            p3dRotMin[axis] = FMIN_SEESAW_ANGLE; <br>            p3dRotMax[axis] = FMAX_SEESAW_ANGLE; <br>            break; <br> <br>        case ROTSTYLE_WOBBLE: <br>            GetNextRotProc = GetNextRotWobble; <br>            if( pac-&gt;demoType == DEMO_VSTRING ) { <br>                axis = Y_AXIS; <br>            } <br>            else { <br>                stepRange = 1; <br>                axis = pac-&gt;bXMajor ? Y_AXIS : X_AXIS; <br>            } <br>            p3dRotMin[Z_AXIS] = FMAX_WOBBLE_ANGLE; <br>            p3dRotMax[Z_AXIS] = FMAX_WOBBLE_ANGLE; <br>            p3dRotMin[axis] = FMIN_WOBBLE_ANGLE2; <br>            p3dRotMax[axis] = FMAX_WOBBLE_ANGLE2; <br>            break; <br> <br>        case ROTSTYLE_RANDOM: <br>            // adjust stepRange based on speed <br>            stepRange = MapValueI( pac-&gt;iSpeed, <br>                               MIN_SLIDER, (MAX_SLIDER-MIN_SLIDER)/2, <br>                               2, 6 ); // step range <br>            for( axis = X_AXIS; axis &lt; NUM_AXIS; axis++ ) { <br>                p3dRotMin[axis] = FMIN_RANDOM_ANGLE; <br>                p3dRotMax[axis] = FMAX_RANDOM_ANGLE; <br>            } <br>            break; <br>    } <br> <br>    // set min and max steps <br>    pac-&gt;iRotMinStep = pac-&gt;iRotStep &gt;= (MIN_ROT_STEP + stepRange) ? <br>              pac-&gt;iRotStep - stepRange : MIN_ROT_STEP; <br>    pac-&gt;iRotMaxStep = pac-&gt;iRotStep + stepRange; // don't limit upper end <br> <br>    for( axis = X_AXIS; axis &lt; NUM_AXIS; axis++ ) { <br>        ip3dRotStep[axis] = p3dRotMax[axis] != 0.0f ? <br>                ss_iRand2( pac-&gt;iRotMinStep, pac-&gt;iRotMaxStep ) : 0; <br>    } <br> <br>    // initialize the step iteration <br>    pac-&gt;ip3dRoti.x = pac-&gt;ip3dRoti.y = pac-&gt;ip3dRoti.z = 0; <br> <br>    // initialize the trig table, for fast rotation calculations <br>    InitTrigTable(); <br> <br>    // set the current rotation limits <br>    pac-&gt;p3dRotLimit = *( (POINT3D *)p3dRotMax ); <br>    ResetRotationLimits( pac, reset ); <br> <br>    // set view angle <br>    pac-&gt;fFovy = ss_fRand( FMIN_VIEW_ANGLE, FMAX_VIEW_ANGLE ); <br> <br>    for( axis = X_AXIS; axis &lt; NUM_AXIS; axis++ ) { <br>        if( p3dRotMax[axis] != 0.0f ) <br>            numRots++; <br>    } <br> <br>    // set BoundingBoxProc dependent on which axis are being rotated <br>    if( numRots &lt;= 1 ) <br>        BoundingBoxProc = CalcBoundingBox; <br>    else <br>        BoundingBoxProc = CalcBoundingBoxGeneric; <br> <br>    (*BoundingBoxProc)( pac ); <br>    if( pac-&gt;p3dBoundingBox.y == 0.0f ) <br>        pac-&gt;p3dBoundingBox.y = 1.0f; <br>} <br> <br>/**************************************************************************\ <br>* InitMaterials <br>* <br>* <br>\**************************************************************************/ <br>static void <br>InitMaterials( AttrContext *pac ) <br>{ <br>    if( pac-&gt;bTexture ) { <br>        ss_InitTexMaterials(); <br>        pac-&gt;bMaterialCycle = FALSE; <br>        pac-&gt;pMat = ss_RandomTexMaterial( TRUE ); <br>    } else { <br>        ss_InitTeaMaterials(); <br>        pac-&gt;bMaterialCycle = TRUE; <br>        pac-&gt;pMat = ss_RandomTeaMaterial( TRUE ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* InitTexture <br>* <br>\**************************************************************************/ <br>static void <br>InitTexture( AttrContext *pac ) <br>{ <br>    if( pac-&gt;surfStyle != SURFSTYLE_TEX ) <br>        return; <br> <br>    // No choice for texture quality in dialog - set to HIGH <br>    pac-&gt;texQual = TEXQUAL_HIGH; <br> <br>    // Try to load the texture file or default texture resource <br> <br>    if( ss_LoadTextureFile( &amp;pac-&gt;texFile, &amp;pac-&gt;texture ) || <br>        ss_LoadTextureResource( &amp;gTexRes, &amp;pac-&gt;texture ) )  <br>    { <br>        pac-&gt;bTexture = 1; <br> <br>        glEnable(GL_TEXTURE_2D); <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); <br>        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); <br> <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <br>        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <br> <br>        ss_SetTexture( &amp;pac-&gt;texture ); <br> <br>        // set auto texture coord generation <br>        ss_InitAutoTexture( NULL ); <br>    } <br>    else {  // couldn't open .bmp file <br>        pac-&gt;bTexture = 0; <br>    } <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* text3d_Finish <br>* <br>* Handles any cleanup on program termination <br>* <br>\**************************************************************************/ <br>void <br>text3d_Finish( void *data ) <br>{ <br>    AttrContext *pac = (AttrContext *) data; <br> <br>    if( pac ) <br>        DeleteWglFontContext( pac-&gt;pWglFontC ); <br> <br>    // delete any name list <br>    DeleteNameList(); <br>} <br> <br>/**************************************************************************\ <br>* text3d_Reshape <br>* <br>*       - called on resize, expose <br>*       - always called on app startup <br>* <br>\**************************************************************************/ <br> <br>void <br>text3d_Reshape(int width, int height, void *data ) <br>{ <br>    AttrContext *pac = (AttrContext *) data; <br> <br>    glViewport( 0, 0, width, height ); <br> <br>    // calculate new aspect ratio <br>    pac-&gt;fAspect = height == 0 ? 1.0f : (FLOAT) width / (FLOAT) height; <br> <br>    CalcViewParams( pac ); <br>    ss_SetWindowAspectRatio( pac-&gt;p3dBoundingBox.x / pac-&gt;p3dBoundingBox.y ); <br>} <br> <br> <br>/**************************************************************************\ <br>* CalcViewParams <br>* <br>*   Calculate viewing parameters, based on window size, bounding box, etc. <br>* <br>\**************************************************************************/ <br> <br>static void <br>CalcViewParams( AttrContext *pac ) <br>{ <br>    GLdouble zNear, zFar; <br>    FLOAT aspectBound, viewDist; <br>    FLOAT vHeight; <br>    FLOAT fovy; <br> <br>    // calculate viewing distance so that front of bounding box within view <br> <br>    aspectBound = pac-&gt;p3dBoundingBox.x / pac-&gt;p3dBoundingBox.y; <br> <br>    // this is distance to FRONT of bounding box: <br>    viewDist = pac-&gt;p3dBoundingBox.y / <br>               ( (FLOAT) tan( deg_to_rad(pac-&gt;fFovy/2.0f) ) ); <br> <br>    // NOTE: these are half-widths and heights <br>    if( aspectBound &lt;= pac-&gt;fAspect ) { <br>        // we are bound by the window's height <br>        fovy = pac-&gt;fFovy; <br>    } else { <br>        // we are bound by window's width <br>        // adjust fovy, so fovx remains the same <br>        vHeight = pac-&gt;p3dBoundingBox.x / pac-&gt;fAspect; <br>        fovy = rad_to_deg( 2.0f * (FLOAT) atan( vHeight / viewDist ) ); <br>    } <br> <br>    /* Could just use rotation sphere dimensions here, but for now <br>     * set clipping planes 10% beyond bounding box. <br>     */ <br> <br>    zNear = 0.9f * viewDist; <br>    zFar = 1.1f * (viewDist + 2.0f*pac-&gt;p3dBoundingBox.z); <br> <br>    if( pac-&gt;demoType == DEMO_VSTRING ) <br>        zFar *= FMAX_ZOOM; <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br> <br>    gluPerspective( fovy, pac-&gt;fAspect, zNear, zFar ); <br> <br>    // set viewing distance so that front of bounding box within view <br>    viewDist *= 1.01f; // pull back 1% further to be sure not off by a pixel.. <br>    pac-&gt;fZtrans = -(viewDist + pac-&gt;p3dBoundingBox.z); <br> <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br>    glTranslatef( 0.0f, 0.0f, pac-&gt;fZtrans ); <br> <br>} <br> <br> <br>// number of calibration cycles <br>#define MAX_CALIBRATE 2 <br> <br>/**************************************************************************\ <br>* text3d_Draw <br>* <br>* Draw a frame. <br>* <br>\**************************************************************************/ <br>void <br>text3d_Draw( void *data ) <br>{ <br>    AttrContext *pac = (AttrContext *) data; <br>    POINT3D *rot = &amp;pac-&gt;p3dRot; <br>    static BOOL bCalibrated = FALSE; <br>    static int nCycle = 0; // cycle count <br>    static int frameCount = 0, maxCount; <br>    static int matTransCount, matTransCount2 = 0; <br>    static MATERIAL transMat, transMatInc; <br>    static FLOAT zTrans, zTransInc; <br>    static MATERIAL *pNewMat; <br>    static struct _timeb baseTime; <br>    static BOOL bInit = FALSE; <br>    static int reset[NUM_AXIS] = {1,1,1}; <br> <br>    if( !bInit ) { <br> <br>        // Do first time init stuff <br> <br>        // Start the calibration timer <br>        _ftime( &amp;baseTime ); <br> <br>        // set default transition points, until calibration done <br>        maxCount = 60; <br>        SetTransitionPoints( pac, maxCount, &amp;matTransCount, <br>                             &amp;matTransCount2, &amp;zTrans ); <br>        bInit = TRUE; <br>    } <br> <br>    // take action based on frameCount <br> <br>    if( frameCount &gt;= matTransCount ) { <br> <br>        // we are in the transition zone <br> <br>        if( frameCount == matTransCount ) { <br> <br>            // first transition point... <br> <br>            // select new material <br>            if( pac-&gt;bTexture ) <br>                pNewMat = ss_RandomTexMaterial( FALSE ); <br>            else <br>                pNewMat = ss_RandomTeaMaterial( FALSE ); <br> <br>            // set material transition, zTrans transition <br>            if( pac-&gt;demoType == DEMO_VSTRING ) { <br>                // transition current material to black <br>                ss_CreateMaterialGradient( &amp;transMatInc, <br>                                          pac-&gt;pMat, <br>                                          &amp;ss_BlackMat, <br>                                          matTransCount2 - matTransCount ); <br>                zTransInc = ((FMAX_ZOOM-1) * pac-&gt;fZtrans) / <br>                                        (matTransCount2 - matTransCount); <br>            } else { <br>                ss_CreateMaterialGradient( &amp;transMatInc, <br>                                           pac-&gt;pMat, <br>                                           pNewMat, <br>                                           maxCount - matTransCount ); <br>            } <br>            // initialize transition values to current settings <br>            zTrans = pac-&gt;fZtrans; <br>            transMat = *(pac-&gt;pMat); <br>            // begin transition on NEXT frame. <br> <br>        } else { <br> <br>            // past first transition... <br> <br>            if( matTransCount2 &amp;&amp; (frameCount == (matTransCount2+1)) ) { <br> <br>                // optional second transition point...(only for vstrings) <br> <br>                // transition from black to new material <br>                ss_CreateMaterialGradient( &amp;transMatInc, <br>                                           &amp;ss_BlackMat, <br>                                           pNewMat, <br>                                           maxCount - matTransCount2 ); <br>                // init transition material to black <br>                transMat = ss_BlackMat; <br> <br>                /* At this point, screen is black, so we can change strings <br>                 * and resize the floater without any problems. <br>                 */ <br> <br>                if( pac-&gt;demoType == DEMO_VSTRING ) <br>                    text3d_UpdateString( pac, TRUE ); // can cause resize <br>                // set zTrans to furthest distance <br>                zTrans = (FMAX_ZOOM * pac-&gt;fZtrans); <br>                zTransInc = (pac-&gt;fZtrans - zTrans) / <br>                                            (maxCount - matTransCount2); <br>                // change this while string invisible <br>                ResetRotationLimits( pac, reset ); <br>            } <br>            // set the transition material (updates transMat each time) <br> <br>            ss_TransitionMaterial( &amp;transMat, &amp;transMatInc ); <br>            zTrans += zTransInc; <br> <br>            if( frameCount &gt;= maxCount ) { <br> <br>                // End of cycle <br>                nCycle++;  // 1-based <br> <br>                // Calibrate on MAX_CALIBRATE cycles <br>                if( !bCalibrated &amp;&amp; (nCycle &gt;= MAX_CALIBRATE) ) { <br>                    maxCount = FrameCalibration( pac, &amp;baseTime, maxCount, nCycle ); <br> <br>                    SetTransitionPoints( pac, maxCount, &amp;matTransCount, <br>                                         &amp;matTransCount2, &amp;zTrans ); <br>                    bCalibrated = TRUE; <br>                } <br> <br>                // set, reset stuff <br>                pac-&gt;pMat = pNewMat; <br>                ss_SetMaterial( pNewMat ); <br>                zTrans = pac-&gt;fZtrans; <br>                frameCount = 0; <br>            } <br>        } <br>    } <br> <br>    if( pac-&gt;demoType == DEMO_CLOCK ) { <br>        // have to update the draw string with current time <br>        text3d_UpdateTime( pac, TRUE ); <br>    } <br> <br>    // ok, the string's setup - draw it <br> <br>    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); <br> <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br>    if( pac-&gt;demoType == DEMO_VSTRING ) <br>        // use zooming zTrans <br>        glTranslatef( 0.0f, 0.0f, zTrans ); <br>    else <br>        // use fixed zTrans <br>        glTranslatef( 0.0f, 0.0f, pac-&gt;fZtrans ); <br> <br>    /* <br>     * GetNextRotProc provides sinusoidal rotations <br>     */ <br>    (*GetNextRotProc)( pac );  // sets pac-&gt;p3dRot, or rot <br> <br>    if( pac-&gt;p3dRotMax.z != 0.0f ) { <br>        glRotatef( rot-&gt;z, 0.0f, 0.0f, 1.0f ); <br>    } <br>    if( pac-&gt;p3dRotMax.y != 0.0f ) { <br>        glRotatef( rot-&gt;y, 0.0f, 1.0f, 0.0f ); <br>    } <br>    if( pac-&gt;p3dRotMax.x != 0.0f ) { <br>        glRotatef( rot-&gt;x, 1.0f, 0.0f, 0.0f ); <br>    } <br> <br>    glTranslatef( -pac-&gt;pfTextOrigin.x - pac-&gt;pfTextExtent.x/2.0f, <br>                  -pac-&gt;pfTextOrigin.y + pac-&gt;pfTextExtent.y/2.0f, <br>                  pac-&gt;fDepth / 2.0f ); <br> <br>    DrawString( pac-&gt;usText, pac-&gt;textLen, pac-&gt;pWglFontC ); <br> <br>    glFlush(); <br>    frameCount++; <br>} <br> <br>/**************************************************************************\ <br>* SetTransitionPoints <br>* <br>* Calculate draw transition points, as frame count values. <br>* <br>* If doing variable string (VSTRING), first transition point is where we <br>* start fading to black, and 2nd is from black to next material.  Also <br>* transition the z translation distance (zTrans). <br>* Note that trans2 indicates the frame number where the image should be <br>* black.  The actual transitioning may occur at trans2+1 (see text3d_draw <br>* above). <br>* <br>* For all other cases, set one transition point for fade to next material. </code></pre>
<p>
</p>
<pre><code>* <br>\**************************************************************************/ <br>static void <br>SetTransitionPoints( AttrContext *pac, int framesPerCycle, int *trans1, <br>                     int *trans2, FLOAT *zTrans ) <br>{ <br>    *trans1 = (int) (0.5f * (FLOAT) framesPerCycle + 0.5f); <br> <br>    if( pac-&gt;demoType == DEMO_VSTRING ) { <br>        *trans2 = *trans1 + <br>                  (int) (0.5f * (FLOAT) (framesPerCycle - *trans1) + 0.5f); <br>        *zTrans = pac-&gt;fZtrans; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* text3d_UpdateTime <br>* <br>* Put new time string into the attribute context <br>* <br>\**************************************************************************/ <br>static void <br>text3d_UpdateTime( AttrContext *pac, BOOL bCheckBounds ) <br>{ <br>    int oldLen; <br>    POINTFLOAT textExtent, textOrigin; <br>    POINTFLOAT textLowerRight, currentLowerRight; <br>    LPTSTR pszLastTime = pac-&gt;szText; <br>    static TCHAR szNewTime[TEXT_BUF_SIZE] = {0}; <br> <br>    GetLocalTime( &amp;(pac-&gt;stTime) ); <br>    GetTimeFormat( GetSystemDefaultLCID(), // locale id <br>                    0,                      // flags <br>                    &amp;(pac-&gt;stTime),         // time struct <br>                    NULL,                   // format string <br>                    szNewTime,               // buffer <br>                    TEXT_BUF_SIZE );        // buffer size <br> <br>    // Compare new time string with last one <br> <br>    if( !lstrcmp( pszLastTime, szNewTime ) ) <br>        // time string has not changed, return <br>        return; <br> <br>    // translate the new time string into display lists in pac-&gt;usText <br> <br>    ConvertStringToList( szNewTime, pac-&gt;usText, pac-&gt;pWglFontC ); <br>    lstrcpy( pac-&gt;szText, szNewTime ); <br> <br>    // Check extents of new string <br> <br>    // save current values <br>    oldLen = pac-&gt;textLen; <br>    textExtent = pac-&gt;pfTextExtent; <br>    textOrigin = pac-&gt;pfTextOrigin; <br> <br>    pac-&gt;textLen = GetStringExtent( pac-&gt;szText, <br>                                     &amp;textExtent, <br>                                     &amp;textOrigin, <br>                                     pac-&gt;pWglFontC ); <br> <br>    if( !bCheckBounds ) { <br>        // just set new extents and return <br>        pac-&gt;pfTextExtent = textExtent; <br>        pac-&gt;pfTextOrigin = textOrigin; <br>        return; <br>    } <br> <br>    /* only update bounding box if new extents are larger, or the number <br>     * of chars changes <br>     */ <br>    bCheckBounds = FALSE; <br> <br>    if( pac-&gt;textLen != oldLen ) { <br> <br>        // recalculate everything <br> <br>        bCheckBounds = TRUE; <br>        pac-&gt;pfTextExtent = textExtent; <br>        pac-&gt;pfTextOrigin = textOrigin; <br>    } <br>    else { <br> <br>        // accumulate maximum bounding box in pac <br> <br>        // calc current lower right limits <br>        textLowerRight.x = textOrigin.x + textExtent.x; <br>        textLowerRight.y = textOrigin.y - textExtent.y; <br>        currentLowerRight.x = pac-&gt;pfTextOrigin.x + pac-&gt;pfTextExtent.x; <br>        currentLowerRight.y = pac-&gt;pfTextOrigin.y - pac-&gt;pfTextExtent.y; <br> <br>        // if new text extents extend beyond current, update <br> <br>        if( textOrigin.x &lt; pac-&gt;pfTextOrigin.x ) { <br>            pac-&gt;pfTextOrigin.x = textOrigin.x; <br>            bCheckBounds = TRUE; <br>        } <br>        if( textOrigin.y &gt; pac-&gt;pfTextOrigin.y ) { <br>            pac-&gt;pfTextOrigin.y = textOrigin.y; <br>            bCheckBounds = TRUE; <br>        } <br>        if( textLowerRight.x &gt; currentLowerRight.x ) { <br>            pac-&gt;pfTextExtent.x = textLowerRight.x - pac-&gt;pfTextOrigin.x; <br>            bCheckBounds = TRUE; <br>        } <br>        if( textLowerRight.y &lt; currentLowerRight.y ) { <br>            pac-&gt;pfTextExtent.y = pac-&gt;pfTextOrigin.y - textLowerRight.y; <br>            bCheckBounds = TRUE; <br>        } <br>    } <br>    if( bCheckBounds ) { <br>        // string size has changed - recalc box and view params <br>        (*BoundingBoxProc)( pac ); <br>        CalcViewParams( pac ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* text3d_UpdateString <br>* <br>* Select new string to display. <br>* If bCheckBounds, calculate new bounds as well. <br>* <br>\**************************************************************************/ <br>static void <br>text3d_UpdateString( AttrContext *pac, BOOL bCheckBounds ) <br>{ <br>    static int index = 0; <br> <br>    // get next string to display <br> <br>    if( gplist == NULL ) <br>        CreateRandomList(); <br> <br>    lstrcpy( pac-&gt;szText, gplist-&gt;pszStr ); <br>    ConvertStringToList( pac-&gt;szText, pac-&gt;usText, pac-&gt;pWglFontC ); <br>    gplist = gplist-&gt;pnext; <br> <br>    // get new extents <br>    pac-&gt;textLen = GetStringExtent( pac-&gt;szText, <br>                                     &amp;pac-&gt;pfTextExtent, <br>                                     &amp;pac-&gt;pfTextOrigin, <br>                                     pac-&gt;pWglFontC ); <br> <br>    if( !bCheckBounds ) <br>        return; <br> <br>    // calculate bounding box <br>    (*BoundingBoxProc)( pac ); <br>    if( pac-&gt;p3dBoundingBox.y == 0.0f ) <br>        // avoid /0 <br>        pac-&gt;p3dBoundingBox.y = 1.0f; <br> <br>    // Make window's aspect ratio dependent on bounding box <br> <br>    /* mf: could clear buffer here, so don't get incorrect results on <br>     *  synchronous resize, but not necessary since we're fading <br>     */ <br>    ss_SetWindowAspectRatio( pac-&gt;p3dBoundingBox.x / pac-&gt;p3dBoundingBox.y ); <br>    CalcViewParams( pac ); <br> <br>    // move window to new random position <br>    ss_RandomWindowPos(); <br>} <br> <br>/**************************************************************************\ <br>* GetNextRotWobble <br>* <br>*   Calculate next rotation. <br>*   - 'step' controls amount of rotation <br>*   - rotation values are scaled from -1 to 1 (trig values), and  inscribe <br>*     circle with r=1 in the zy plane for the ends of the string <br>*   - steps for both minor and major rotation axis remain in sync <br>* <br>\**************************************************************************/ <br>static void <br>GetNextRotWobble( AttrContext *pac ) <br>{ <br>    int *step = (int *) &amp;pac-&gt;ip3dRoti;  // use step-&gt;x <br>    int *rotStep = (int *) &amp;pac-&gt;ip3dRotStep.z; <br>    FLOAT *rotMax = (FLOAT *) &amp;pac-&gt;p3dRotMax; <br>    POINTFLOAT *pTrig = pac-&gt;pTrig; <br>    static int resetPoint[NUM_AXIS] = {90,90,0}; // 0 amplitude points <br>    int reset[NUM_AXIS] = {0}; // which axis to be reset <br>    int axis; <br> <br>    pac-&gt;p3dRot.z = pac-&gt;p3dRotLimit.z * pTrig[ *step ].y;  // sin <br>    pac-&gt;p3dRot.y = pac-&gt;p3dRotLimit.y * pTrig[ *step ].x;  // cos <br>    pac-&gt;p3dRot.x = pac-&gt;p3dRotLimit.x * pTrig[ *step ].x;  // cos <br> <br>    // check for 0 amplitude point for non-vstrings <br>    for( axis = X_AXIS; axis &lt; NUM_AXIS; axis++ ) { <br>        if( rotMax[axis] != 0.0f ) { <br>            if( (pac-&gt;demoType != DEMO_VSTRING) &amp;&amp; <br>                (*step == resetPoint[axis]) ) <br>            { <br>                reset[axis] = 1; <br>                ResetRotationLimits( pac, reset ); <br>                reset[axis] = 0; <br>            } <br>        } <br>    } <br> <br>    // increment step <br>    if( (*step += *rotStep) &gt;= 360 ) { <br>        // make the step variable <br>        *rotStep = ss_iRand2( pac-&gt;iRotMinStep, pac-&gt;iRotMaxStep ); <br>        // start step at variable index <br>        *step = ss_iRand( *rotStep ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* GetNextRotRandom <br>* <br>* Same as above, but steps for each axis are not kept in sync <br>* <br>\**************************************************************************/ <br>static void <br>GetNextRotRandom( AttrContext *pac ) <br>{ <br>    int *step = (int *) &amp;pac-&gt;ip3dRoti; <br>    int *rotStep = (int *) &amp;pac-&gt;ip3dRotStep; <br>    FLOAT *rotMax = (FLOAT *) &amp;pac-&gt;p3dRotMax; <br>    POINTFLOAT *pTrig = pac-&gt;pTrig; <br>    static int resetPoint[NUM_AXIS] = {90,90,0}; // 0 amplitude points <br>    int reset[NUM_AXIS] = {0}; // which axis to be reset <br>    int axis; <br> <br>    // set new rotation <br>    pac-&gt;p3dRot.z = pac-&gt;p3dRotLimit.z * pTrig[ step[Z_AXIS] ].y;  // sin <br>    pac-&gt;p3dRot.y = pac-&gt;p3dRotLimit.y * pTrig[ step[Y_AXIS] ].x;  // cos <br>    pac-&gt;p3dRot.x = pac-&gt;p3dRotLimit.x * pTrig[ step[X_AXIS] ].x;  // cos <br> <br>    // for each rotation axis... <br> <br>    for( axis = X_AXIS; axis &lt; NUM_AXIS; axis++ ) { <br>        if( rotMax[axis] != 0.0f ) { <br>            // check for 0 amplitude point for non-vstrings <br>            if( (pac-&gt;demoType != DEMO_VSTRING) &amp;&amp; <br>                (step[axis] == resetPoint[axis]) ) { <br>                reset[axis] = 1; <br>                ResetRotationLimits( pac, reset ); <br>                reset[axis] = 0; <br>            } <br> <br>            // increment rotation step and check for end of cycle <br>            if( (step[axis] += rotStep[axis]) &gt;= 360 ) { <br>                // make the step variable <br>                rotStep[axis] = ss_iRand2( pac-&gt;iRotMinStep, pac-&gt;iRotMaxStep ); <br>                // start step at variable index <br>                step[axis] = ss_iRand( rotStep[axis] ); <br>            } <br>        } <br>    } <br>} <br> <br>/**************************************************************************\ <br>* GetNextRotNone <br>* <br>* Null rot proc <br>* <br>\**************************************************************************/ <br>static void <br>GetNextRotNone( AttrContext *pac ) <br>{ <br>} <br> <br>/**************************************************************************\ <br>* ResetRotationLimits <br>* <br>* Reset the maximum axis rotations.  So there won't be too much of a 'jump' <br>* when altering the rotation, this routine should only be called when the <br>* rotation of the specified axis is at zero amplitude. <br>* <br>* Also, change the rotation table if applicable.  This affects how the <br>* rotation 'steps' around the axis. <br>* <br>\**************************************************************************/ <br> <br>static void <br>ResetRotationLimits( AttrContext *pac, int *reset ) <br>{ <br>    FLOAT *p3dRot    =  (FLOAT *) &amp;pac-&gt;p3dRot;       // current rotation <br>    FLOAT *p3dRotL   =  (FLOAT *) &amp;pac-&gt;p3dRotLimit;  // new rot limit <br>    FLOAT *p3dRotMin =  (FLOAT *) &amp;pac-&gt;p3dRotMin;    // max rotation <br>    FLOAT *p3dRotMax =  (FLOAT *) &amp;pac-&gt;p3dRotMax;    // max rotation <br>    POINT3D p3dOldRotL = pac-&gt;p3dRotLimit; // save last rot limit <br>    POINTFLOAT *oldTrig; <br>    int i; <br> <br>    // change rotation limits <br> <br>    for( i = 0; i &lt; NUM_AXIS; i++ ) { <br>        if( p3dRotMax[i] &amp;&amp; reset[i] ) { <br>            p3dRotL[i] = ss_fRand( p3dRotMin[i], p3dRotMax[i] ); <br>            // grossly modify amplitute sometimes for random <br>            if( pac-&gt;rotStyle == ROTSTYLE_RANDOM ) { <br>                if( ss_iRand(10) == 2 ) <br>                    p3dRotL[i] = ss_fRand( 0.0f, 10.0f ); <br>                else if( ss_iRand(10) == 2 ) <br>                    p3dRotL[i] = ss_fRand( 90.0f, 135.0f ); <br>            } <br>        } <br>    } <br> <br>    // change rotation table <br> <br>    // use i to set a frequency for choosing gInvTrig table <br>    i = 10; <br> <br>    oldTrig = pac-&gt;pTrig; <br> <br>    switch( pac-&gt;rotStyle ) { <br>        case ROTSTYLE_RANDOM: <br>            if( pac-&gt;demoType == DEMO_VSTRING ) <br>                i = 7; <br>            // fall thru... <br>        case ROTSTYLE_SEESAW: <br>            // Use InvTrig table every now and then <br>            if( ss_iRand(i) == 2 ) { <br>                pac-&gt;pTrig = gInvTrig; <br>            } <br>            else <br>                pac-&gt;pTrig = gTrig; <br>            break; <br>        default: <br>            // Always use regular trig table <br>            pac-&gt;pTrig = gTrig; <br>    } <br> <br>    // if trig table changed, need to adjust steps of non-zero axis rotations <br>    // (otherwise get 'twitch' in rotation) <br> <br>    if( pac-&gt;pTrig != oldTrig ) { <br>        // only deal with axis which didn't have amplitudes modified <br>        for( i = 0; i &lt; NUM_AXIS; i++ ) <br>            reset[i] = ! reset[i]; <br>        AdjustRotationStep( pac, reset, oldTrig ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* AdjustRotationStep <br>* <br>* If trig table is changed in ResetRotationLimits, then axis with non-zero <br>* rotations will appear to jump.  This routine modifies the current step <br>* so this will not be apparent. <br>* <br>\**************************************************************************/ <br> <br>static void <br>AdjustRotationStep( AttrContext *pac, int *reset, POINTFLOAT *oldTrig ) <br>{ <br>    int *step = (int *) &amp;pac-&gt;ip3dRoti; <br>    FLOAT *p3dRotMax =  (FLOAT *) &amp;pac-&gt;p3dRotMax; <br>    int axis; <br>    POINT *trigDif; <br> <br>    if( pac-&gt;demoType == DEMO_VSTRING ) <br>        // for now doesn't matter, string is invisible at this point <br>        return; <br> <br>    // choose diff table to use for modifying step <br>    trigDif = (oldTrig == gTrig) ? gTrigDif : gInvTrigDif; <br> <br>    for( axis = 0; axis &lt; NUM_AXIS; axis++ ) { <br>        if( p3dRotMax[axis] &amp;&amp; reset[axis] ) { <br>            if( axis != Z_AXIS ) <br>                step[axis] += trigDif[ step[axis] ].x; <br>            else <br>                step[axis] += trigDif[ step[axis] ].y; <br> <br>            // check for wrap or out of bounds <br>            if( (step[axis] &gt;= 360) || (step[axis] &lt; 0) ) <br>                step[axis] = 0; <br>        } <br>    } <br>} <br> <br>/**************************************************************************\ <br>* FindInvStep <br>* <br>* Finds step in invTrig table with same value as trig table at i <br>* <br>\**************************************************************************/ <br> <br>static int <br>FindInvStep( int i ) <br>{ <br>    FLOAT val, diff, minDiff; <br>    int invStep = i; <br> <br>    val = gTrig[i].y; <br> <br>    invStep = i; <br>    minDiff = val - gInvTrig[i].y; <br> <br>    while( ++i &lt;= 90 ) { <br>        diff = val - gInvTrig[i].y; <br>        if( (FLOAT) fabs(diff) &lt; minDiff ) { <br>            minDiff = (FLOAT) fabs(diff); <br>            invStep = i; <br>        } <br>        if( diff &lt; 0.0f ) <br>            break; <br>    } <br> <br>    return invStep; <br>} <br> <br> <br>/**************************************************************************\ <br>* FindStep <br>* <br>* Finds step in trig table with same value as invTrig table at i <br>* <br>\**************************************************************************/ <br> <br>static int <br>FindStep( int i ) <br>{ <br>    FLOAT val, diff, minDiff; <br>    int step = i; <br> <br>    val = gInvTrig[i].y; <br> <br>    step = i; <br>    minDiff = gTrig[i].y - val; <br> <br>    while( --i &gt;= 0 ) { <br>        diff = val - gTrig[i].y; <br>        if( (FLOAT) fabs(diff) &lt; minDiff ) { <br>            minDiff = (FLOAT) fabs(diff); <br>            step = i; <br>        } <br>        if( diff &gt; 0.0f ) <br>            break; <br>    } <br> <br>    return step; <br>} <br> <br>/**************************************************************************\ <br>* InitTrigTable <br>* <br>* Initialize trig look-up tables <br>* <br>\**************************************************************************/ <br>static void <br>InitTrigTable() <br>{ <br>    int i; <br>    static int num = 360; <br>    FLOAT inc = (2.0f*PI)/((FLOAT)num);  // 360 degree range <br>    FLOAT angle = 0.0f; <br>    int newStep; <br> <br>    // calc standard trig table <br> <br>    for( i = 0; i &lt; num; i ++ ) { <br>        gTrig[i].x = (FLOAT) cos(angle); <br>        gTrig[i].y = (FLOAT) sin(angle); <br>        angle += inc; <br>    } <br> <br>    // Calc sawtooth and pseudo-inverse trig table, as well as a diff <br>    // table to convert between trig and invTrig. <br> <br>    // do y, or sin values first <br> <br>    for( i = 0; i &lt;= 90; i ++ ) { <br>        gSawTooth[i].y = (int) i / 90.0f; <br>        gInvTrig[i].y = 2*gSawTooth[i].y - gTrig[i].y; <br>    } <br> <br>    // Create tables to convert trig steps to invTrig steps, and vice-versa <br>    for( i = 0; i &lt;= 90; i ++ ) { <br>        newStep = FindInvStep( i ); <br>        gTrigDif[i].y = newStep - i; <br>        newStep = FindStep( i ); <br>        gInvTrigDif[i].y = newStep - i; // - <br>    } <br> <br>    // reflect 0-90 to get 90-180 <br>    for( i = 1; i &lt;= 90; i ++ ) { <br>        gSawTooth[90+i].y = gSawTooth[90-i].y; <br>        gInvTrig[90+i].y = gInvTrig[90-i].y; <br>        gTrigDif[90+i].y = -gTrigDif[90-i].y; <br>        gInvTrigDif[90+i].y = -gInvTrigDif[90-i].y; <br>    } <br>    // invert 0-180 to get 180-360 <br>    for( i = 1; i &lt; 180; i ++ ) { <br>        gSawTooth[180+i].y = -gSawTooth[i].y; <br>        gInvTrig[180+i].y = -gInvTrig[i].y; <br>        gTrigDif[180+i].y = gTrigDif[i].y; <br>        gInvTrigDif[180+i].y = gInvTrigDif[i].y; <br>    } <br> <br>    // calc x, or cos, by phase-shifting y <br> <br>    for( i = 0; i &lt; 270; i ++ ) { <br>        gSawTooth[i].x = gSawTooth[i+90].y; <br>        gInvTrig[i].x = gInvTrig[i+90].y; <br>        gTrigDif[i].x = gTrigDif[i+90].y; <br>        gInvTrigDif[i].x = gInvTrigDif[i+90].y; <br>    } <br>    for( i = 0; i &lt; 90; i ++ ) { <br>        gSawTooth[i+270].x = gSawTooth[i].y; <br>        gInvTrig[i+270].x = gInvTrig[i].y; <br>        gTrigDif[i+270].x = gTrigDif[i].y; <br>        gInvTrigDif[i+270].x = gInvTrigDif[i].y; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* CalcChordalDeviation <br>* <br>* <br>\**************************************************************************/ <br>static FLOAT <br>CalcChordalDeviation( HDC hdc, AttrContext *pac ) <br>{ <br>    OUTLINETEXTMETRIC otm; <br>    FLOAT       cd, mincd;  // chordal deviations <br> <br>    // Query font metrics <br> <br>    if( GetOutlineTextMetrics( hdc, sizeof(otm), &amp;otm) &lt;= 0 ) <br>        // cmd failed, or buffer size=0 <br>        return 1.0f; <br> <br>    // minimum chordal deviation is limited by design space <br>    mincd = 1.0f / (FLOAT) otm.otmEMSquare; <br> <br>    // now map fTesselFact to chordalDeviation <br>    cd = MapValue( pac-&gt;fTesselFact, <br>                   0.0f, 1.0f,  // fTesselFact range <br>                   FMAX_CHORDAL_DEVIATION, mincd );  // chordalDeviation range <br>    if( pac-&gt;fTesselFact == 0.0f ) <br>        // make sure get lowest resolution <br>        cd = 1.0f; <br>    return cd; <br>} <br> <br>/**************************************************************************\ <br>* CalcBoundingBox <br>* <br>\**************************************************************************/ <br>static void <br>CalcBoundingBox( AttrContext *pac ) <br>{ <br>    POINT3D box[3];  // for each axis rotation <br>    FLOAT viewAngle, critAngle, critAngleC, rectAngle; <br>    FLOAT r, rot, x, y, z, ymax, zCrit; <br>    FLOAT viewDist, viewDistO, xAngle[3]; <br>    FLOAT boxvpo[3];  // viewpoint to origin distance along z for the boxes <br>    int n = 0; <br>    POINT3D pt; <br> <br>    /* One thing to remember here is that box[n].z is constrained to be <br>     * the near clipping plane.  The boxe's x and y represent the frustum <br>     * cross-section at that point. <br>     */ <br>    viewAngle = deg_to_rad( pac-&gt;fFovy )  / 2.0f; <br> <br>    // x,y,z represent half-extents <br>    x = pac-&gt;pfTextExtent.x/2.0f; <br>    y = pac-&gt;pfTextExtent.y/2.0f; <br>    z = pac-&gt;fDepth/2.0f; <br>    // initialize box[0] with current extents <br>    box[0].x = x; <br>    box[0].y = y; <br>    box[0].z = z; <br>    boxvpo[0] = 0.0f; <br> <br>    // handle rotation around x-axis <br> <br>    if( pac-&gt;p3dRotMax.x != 0.0f ) { <br> <br>        box[n].x = x; <br> <br>        // need to determine y and z <br> <br>        rot = deg_to_rad( pac-&gt;p3dRotMax.x ); <br>        r = (FLOAT) sqrt( y*y + z*z ); <br> <br>        // calc incursion along z <br> <br>        rectAngle = (z == 0.0f) ? PI_OVER_2 : (FLOAT) atan( y/z ); <br>        if( rot &gt;= rectAngle ) { <br>            // easy, use maximum possible extent <br>            box[n].z = r; <br>        } else { <br>            // rotate lower right corner of box by rot to get extent <br>            box[n].z = z * (FLOAT) cos( rot ) + y * (FLOAT) sin( rot ); <br>        } <br> <br>        /* figure out critical angle, where rotated rectangle would <br>         * be perpendicular to viewing frustum.  This indicates the max. <br>         * y-incursion into the frustum. <br>         */ <br>        critAngle = PI_OVER_2 - viewAngle; <br>        ymax = r * (FLOAT) sin(critAngle); <br> <br>        if( y &gt; z ) { <br>            rectAngle = PI_OVER_2 - rectAngle; <br>            critAngleC = PI_OVER_2 - critAngle; <br>        } else <br>            critAngleC = critAngle; <br> <br>        if( (rectAngle + rot) &gt;= critAngleC ) { <br>            // no view reduction possible in y, use max view <br>            // need to calc y at box.z <br>            viewDistO = r / (FLOAT) cos( critAngle ); <br>            boxvpo[n] = viewDistO; <br>            box[n].y = (viewDistO - box[n].z) * <br>                                        (FLOAT) tan( PI_OVER_2 - critAngle); <br>        } else { <br>            // we can sonic reduce it <br>            if( y &gt; z ) <br>                rot = -rot; <br>            // rotate front-top point by rot to get ymax, z <br>            ymax = z * (FLOAT) sin( rot ) + y * (FLOAT) cos( rot ); <br>            zCrit = z * (FLOAT) cos( rot ) - y * (FLOAT) sin( rot ); <br>            // not usin viewDistO properly here... <br>            viewDistO = ymax * (FLOAT) tan( viewAngle); <br>            boxvpo[n] = viewDistO + zCrit; <br>            viewDist = boxvpo[n] - box[n].z; <br>            box[n].y = viewDist * (FLOAT) tan( viewAngle ); <br>        } <br>        n++; <br>    } <br> <br>    if( pac-&gt;p3dRotMax.y != 0.0f ) { <br> <br>        box[n].y = y; <br> <br>        // need to determine x and z <br>        rot = deg_to_rad( pac-&gt;p3dRotMax.y ); <br>        r = (FLOAT) sqrt( x*x + z*z ); <br>        rectAngle = (z == 0.0f) ? PI_OVER_2 : (FLOAT) atan( x/z ); <br> <br>        // calc incursion along z <br> <br>        if( rot &gt;= rectAngle ) { <br>            // easy, use maximum possible extent <br>            box[n].z = r; <br>        } else { <br>            // rotate lower right corner of box by rot to get extent <br>            box[n].z = z * (FLOAT) cos( rot ) + x * (FLOAT) sin( rot ); <br>        } <br> <br>        // view distance to largest z <br>        viewDist = y / (FLOAT) tan(viewAngle); <br>        // make viewDist represent distance to origin <br>        viewDistO = viewDist + box[n].z; <br>        boxvpo[n] = viewDistO; <br> <br>        // now minimize angle between viewpoint and rotated rect <br> <br>        if( viewDistO &gt; r ) { <br>            /* calc crit angle where view is maximized (line from viewpoint <br>             * tangent to rotation circle) <br>             * critAngle is between z-axis and radial line <br>             */ <br>            critAngle = (FLOAT) acos( r / viewDistO ); <br> <br>            // critAngleC is for Comparing <br>            if( x &gt; z ) { <br>                rectAngle = PI_OVER_2 - rectAngle; <br>                critAngleC = PI_OVER_2 - critAngle; <br>            } else <br>                critAngleC = critAngle; <br>        } <br> <br>        if( (viewDistO &gt; r) &amp;&amp; // vp OUTSIDE circle <br>            ((rectAngle + rot) &gt;= critAngleC) ) { <br> <br>            /* no view reduction possible in x, use x along the max-view line <br>             */ <br>            box[n].x = viewDist * (FLOAT) tan( PI_OVER_2 - critAngle ); <br>        } else { <br>            // we can sonic reduce it <br>            if( x &gt; z ) <br>                rot = -rot; <br>            // rotate front-top point by rot to get x,z <br>            // pt.z not needed <br>            //pt.z = z * (FLOAT) cos( rot ) - x * (FLOAT) sin( rot ); <br>            pt.x = z * (FLOAT) sin( rot ) + x * (FLOAT) cos( rot ); <br>            box[n].x = pt.x; <br>        } <br>        n++; <br>    } <br> <br>    if( pac-&gt;p3dRotMax.z != 0.0f ) { <br> <br>        CalcBoundingExtent( deg_to_rad(pac-&gt;p3dRotMax.z), <br>                            x, y, <br>                            (POINTFLOAT *) &amp;box[n] ); <br>        box[n].z = z; <br>        // calc viewing distance from front of box <br>        viewDist = box[n].y / (FLOAT) tan(viewAngle); <br>        // calc view distance to origin; <br>        boxvpo[n] = box[n].z + viewDist; <br>        n++; <br>    } <br> <br>    /* Now we've got 3 rectangles in x-y plane at various depths, and <br>     * need to pick the shortest viewing distance that will encompass <br>     * all of them.  Or, don't actually have to pick the view distance <br>     * yet, since might want to wait for the viewport size in Reshape before <br>     * we do this - but in that case need to pick the rectangle that 'sticks <br>     * out the most', so it can be used as the bounding box. <br>     */ <br>    /* The box with the furthest viewpoint will work for y. <br>     * But then have to check <br>     * this against the x's of the others.  If any stick out of the frustum, <br>     * then it will have to be made larger in x.  By making x larger, we <br>     * do not affect fovy <br>     */ <br>    SortBoxes( box, boxvpo, n ); // put largest viewpoint box in box[0] <br> <br>    // figure view dist to first box <br>    // (could maintain these as they are calculated) <br>    viewDist = boxvpo[0] - box[0].z; <br> <br>    // compare x angles of boxes <br> <br>    switch( n ) { <br>        FLOAT den; <br> <br>        case 3: <br>            den = viewDist + (box[0].z - box[2].z); <br>            xAngle[2] = den == 0.0f ? PI_OVER_2 : (FLOAT)atan( box[2].x / den); <br>        case 2: <br>            den = viewDist + (box[0].z - box[1].z); <br>            xAngle[1] = den == 0.0f ? PI_OVER_2 : (FLOAT)atan( box[1].x / den); <br>        case 1: <br>            xAngle[0] = viewDist == 0.0f ? PI_OVER_2 : <br>                                            (FLOAT)atan( box[0].x / viewDist ); <br>    } <br> <br>    // here, just call Sort again, with list of xAngles <br>    SortBoxes( box, xAngle, n ); // put largest xangle box in box[0] <br> <br>    // now box[0] should contain half extents of the Bounding box <br> <br>    pac-&gt;p3dBoundingBox = box[0]; <br>} <br> <br>/**************************************************************************\ <br>* CalcBoundingBoxFromSphere <br>* <br>* Calculates the bounding box from a sphere with r = diagonal of the box <br>* <br>\**************************************************************************/ <br>static void <br>CalcBoundingBoxFromSphere( AttrContext *pac ) <br>{ <br>    FLOAT x, y, z, r; <br>    FLOAT viewAngle, viewDist, viewDistO; <br>    POINT3D box; <br> <br>    // x,y,z represent half-extents <br>    x = pac-&gt;pfTextExtent.x/2.0f; <br>    y = pac-&gt;pfTextExtent.y/2.0f; <br>    z = pac-&gt;fDepth/2.0f; <br> <br>    r = (FLOAT) sqrt( x*x + y*y +z*z ); <br>    box.z = r; <br>    viewAngle = deg_to_rad( pac-&gt;fFovy )  / 2.0f; <br>    viewDistO = r / (FLOAT) sin( viewAngle ); <br>    viewDist = viewDistO - r; <br>    box.y = viewDist * (FLOAT) tan( viewAngle ); <br>    box.x = box.y; <br> <br>    pac-&gt;p3dBoundingBox = box; <br>} <br> <br>/**************************************************************************\ <br>* <br>* CalcBoundingBoxFromSpherePlus <br>* <br>* Same as above, but tries to optimize for case when z exent is small <br>* <br>\**************************************************************************/ <br>static void <br>CalcBoundingBoxFromSpherePlus( AttrContext *pac, FLOAT zmax ) <br>{ <br>    FLOAT x, y, z, r; <br>    FLOAT viewAngle, viewDist, viewDistO; <br>    POINT3D box; <br> <br>    // x,y,z represent half-extents <br>    x = pac-&gt;pfTextExtent.x/2.0f; <br>    y = pac-&gt;pfTextExtent.y/2.0f; <br>    z = pac-&gt;fDepth/2.0f; <br> <br>    r = (FLOAT) sqrt( x*x + y*y +z*z ); <br>    viewAngle = deg_to_rad( pac-&gt;fFovy )  / 2.0f; <br> <br>    if( zmax &lt; r ) { <br>        // we can get closer ! <br>        box.z = zmax; <br>        viewDistO = r / (FLOAT) sin( viewAngle ); <br>        viewDist = viewDistO - zmax; <br> <br>        // we want to move the clipping plane closer by (r-zmax) <br>        if( (r-zmax) &gt; viewDist ) { <br>#ifdef SS_DEBUG <br>            glClearColor( 1.0f, 0.0f, 0.0f, 0.0f ); <br>#endif <br>            // we are moving the vp inside the sphere <br>            box.y = (FLOAT) sqrt( r*r - box.z*box.z ); <br>            box.x = box.y; <br>        } else { <br>            FLOAT zt; // z-point where view frustum tangent to sphere <br> <br>            // vp outside sphere: can only optimize if zmax &lt; ztangent <br>            zt = r * (FLOAT) cos( PI_OVER_2 - viewAngle); <br>            if( zmax &lt; zt ) { <br>#ifdef SS_DEBUG <br>                // GREEN ZONE !!! <br>                glClearColor( 0.0f, 1.0f, 0.0f, 0.0f ); <br>#endif <br>                box.y = (FLOAT) sqrt( r*r - zmax*zmax ); <br>            } else <br>                // this is the same as below, but with better clipping <br>                box.y = (viewDist + (r-zmax)) * (FLOAT) tan( viewAngle ); <br>            box.x = box.y; <br>        } <br>    } else { <br>        box.z = r; <br>        viewDistO = r / (FLOAT) sin( viewAngle ); <br>        viewDist = viewDistO - r; <br>        box.y = viewDist * (FLOAT) tan( viewAngle ); <br>        box.x = box.y; <br>    } <br>    pac-&gt;p3dBoundingBox = box; <br>} <br> <br>/**************************************************************************\ <br>* CalcBoundingBoxFromExtents <br>* <br>* Calculate bounding box for text, assuming text centered at origin, and <br>* using maximum possible spin angles. <br>* <br>* Rotation around any one axis will affect bounding areas in the other <br>* 2 directions (e.g. z-rotation affects x and y bounding values). <br>* <br>* We need to find the maxima of the rotated 2d area, while staying within <br>* the max spin angles. <br>* <br>\**************************************************************************/ <br>static void <br>CalcBoundingBoxFromExtents( AttrContext *pac, POINT3D *box ) <br>{ <br>    POINTFLOAT extent; <br> <br>    box-&gt;x = pac-&gt;pfTextExtent.x / 2.0f; <br>    box-&gt;y = pac-&gt;pfTextExtent.y / 2.0f; <br>    box-&gt;z = pac-&gt;fDepth / 2.0f; <br> <br>    // split the 3d problem into 3 2d problems in 'x-y' plane <br> <br>    if( pac-&gt;p3dRotMax.x != 0.0f ) { <br> <br>        CalcBoundingExtent( deg_to_rad(pac-&gt;p3dRotMax.x), <br>                            box-&gt;z, box-&gt;y, &amp;extent ); <br>        box-&gt;z = max( box-&gt;z, extent.x ); <br>        box-&gt;y = max( box-&gt;y, extent.y ); <br>    } <br> <br>    if( pac-&gt;p3dRotMax.y != 0.0f ) { <br> <br>        CalcBoundingExtent( deg_to_rad(pac-&gt;p3dRotMax.y), <br>                            box-&gt;x, box-&gt;z, &amp;extent ); <br>        box-&gt;x = max( box-&gt;x, extent.x ); <br>        box-&gt;z = max( box-&gt;z, extent.y ); <br>    } <br> <br>    if( pac-&gt;p3dRotMax.z != 0.0f ) { <br> <br>        CalcBoundingExtent( deg_to_rad(pac-&gt;p3dRotMax.z), <br>                            box-&gt;x, box-&gt;y, &amp;extent ); <br>        box-&gt;x = max( box-&gt;x, extent.x ); <br>        box-&gt;y = max( box-&gt;y, extent.y ); <br>    } <br>} <br> <br>/**************************************************************************\ </code></pre>
<p>
</p>
<pre><code>* CalcBoundingBoxGeneric <br>* <br>* Combines the bounding sphere with the bounding extents <br>* Each of these alone will guarantee no clipping.  But we can <br>* optimize by combining them. <br>* <br>\**************************************************************************/ <br>static void <br>CalcBoundingBoxGeneric( AttrContext *pac ) <br>{ <br>    POINT3D extentBox; <br>    FLOAT x, y, z, r, d, zt, fovx; <br>    FLOAT viewAngle, viewDist, viewDistO; <br>    BOOL xIn, yIn; <br> <br>    // x,y,z represent half-extents <br>    x = pac-&gt;pfTextExtent.x/2.0f; <br>    y = pac-&gt;pfTextExtent.y/2.0f; <br>    z = pac-&gt;fDepth/2.0f; <br> <br> <br>    // get the max extent box <br> <br>    /*!!! wait, this alone doesn't guarantee no clipping?  It only <br>     * checks each axis-rotation separately, without combining them. This <br>     * is no better than calling old CalcBoundingBox ... ??  Well, I <br>     * can't prove why theoretically, but it works <br>     */ <br>    CalcBoundingBoxFromExtents( pac, &amp;extentBox ); <br> <br>    // determine whether x and y extents inside/outside bounding sphere <br> <br>    r = (FLOAT) sqrt( x*x + y*y +z*z ); <br>    // check y <br>    d = (FLOAT) sqrt( extentBox.y*extentBox.y + extentBox.z*extentBox.z ); <br>    yIn = d &lt;= r ? TRUE : FALSE; <br>    // check x <br>    d = (FLOAT) sqrt( extentBox.x*extentBox.x + extentBox.z*extentBox.z ); <br>    xIn = d &lt;= r ? TRUE : FALSE; <br> <br>    // handle easy cases <br> <br>    if( yIn &amp;&amp; xIn ) { <br>        pac-&gt;p3dBoundingBox = extentBox; <br>        return; <br>    } <br>    if( !yIn &amp;&amp; !xIn ) { <br>        CalcBoundingBoxFromSpherePlus( pac, extentBox.z ); <br>        return; <br>    } <br> <br>    // harder cases <br> <br>    viewAngle = deg_to_rad( pac-&gt;fFovy )  / 2.0f; <br> <br>    if( yIn ) { <br>        // figure out x <br>        viewDist = extentBox.y / (FLOAT) tan(viewAngle); <br>        /* viewDist can be inside or outside of the sphere <br>         * If inside - no optimization possible <br>         * If outside, can draw line from viewpoint tangent to sphere, <br>         * and use this point for x <br>         */ <br>        viewDistO = extentBox.z + viewDist; <br>        if( viewDistO &lt;= r ) { <br>            // vp inside sphere <br>            // set x to the point where z intersects sphere <br>            // this becomes a Pythagorous theorem problem: <br>            extentBox.x = (FLOAT) sqrt( r*r - extentBox.z*extentBox.z ); <br>        } else { <br>            // vp outside sphere <br>            /* - figure out zt, where line tangent to circle for viewAngle <br>             */ <br>            fovx = (FLOAT) asin( r / viewDistO ); <br>            zt = r * (FLOAT) acos( PI_OVER_2 - viewAngle); <br>            if( extentBox.z &lt; zt ) { <br>                // use x where extentBox.z intersects sphere <br>                extentBox.x = (FLOAT) sqrt( r*r - extentBox.z*extentBox.z ); <br>            } else { <br>                // use x at tangent point <br>                extentBox.x = (FLOAT) sqrt( r*r - zt*zt ); <br>            } <br>        } <br>    } else {// y out, x in <br>        // have to figure out whether vp inside/outside of sphere. <br>        /* !We can cheat a bit here.  It IS possible, with view angles &gt; 90, <br>         * that the vp be inside sphere.  But since we always use 90 for <br>         * this app, it is safe to assume vp &gt; r  (Fix later for general case) <br>         */ <br>        // XXX: wait, if y out, isn't vp always outside sphere ? <br>        /* So we solve it this way: <br>         * - figure out line tangent to circle for viewAngle <br>         * - y will be where this line intersects the z=extentBox.z line <br>         */ <br>        viewDistO = r / (FLOAT) sin( viewAngle ); <br>        extentBox.y = (viewDistO - extentBox.z) * (FLOAT) tan( viewAngle ); <br>    } <br>    pac-&gt;p3dBoundingBox = extentBox; <br>} <br> <br>/**************************************************************************\ <br>* <br>* Calculate the extents in x and y from rotating a rectangle in a 2d plane <br>* <br>\**************************************************************************/ <br>static void <br>CalcBoundingExtent( FLOAT rot, FLOAT x, FLOAT y, POINTFLOAT *extent ) <br>{ <br>    FLOAT r, angleCrit; <br> <br>    r = (FLOAT) sqrt( x*x + y*y ); <br>    angleCrit = (x == 0.0f) ? PI_OVER_2 : (FLOAT) atan( y/x ); <br> <br>    // calc incursion in x <br> <br>    if( rot &gt;= angleCrit ) { <br>        // easy, use maximum possible extent <br>        extent-&gt;x = r; <br>    } else { <br>        // rotate lower right corner of box by rot to get extent <br>        extent-&gt;x = x * (FLOAT) cos( rot ) + y * (FLOAT) sin( rot ); <br>    } <br> <br>    // calc incursion in y <br> <br>    angleCrit = PI/2.0f - angleCrit; <br> <br>    if( rot &gt;= angleCrit ) { <br>        // easy, use maximum possible extent <br>        extent-&gt;y = r; <br>    } else { <br>        // rotate upper right corner of box by rot to get extent <br>        extent-&gt;y = x * (FLOAT) sin( rot ) + y * (FLOAT) cos( rot ); <br>    } <br> <br>} <br> <br>/**************************************************************************\ <br>* <br>* Sorts in descending order, based on values in val array (bubble sort) <br>* <br>\**************************************************************************/ <br>static void <br>SortBoxes( POINT3D *box, FLOAT *val, int numBox ) <br>{ <br>    int i, j, t; <br>    POINT3D temp; <br> <br>    j = numBox; <br>    while( j ) { <br>        t = 0; <br>        for( i = 0; i &lt; j-1; i++ ) { <br>            if( val[i] &lt; val[i+1] ) { <br>                // swap'em <br>                temp = box[i]; <br>                box[i] = box[i+1]; <br>                box[i+1] = temp; <br>                t = i; <br>            } <br>        } <br>        j = t; <br>    } <br>} <br> <br>#define FILE_BUF_SIZE 180 <br> <br>/**************************************************************************\ <br>* VerifyString <br>* <br>* Validate the string <br>* <br>* A string can be checked against a list of 'key strings' in an ascii file. <br>* If there is a match between the user inputted string and one of these key <br>* strings, then the display mode is enhanced to show a random list of 'item <br>* strings' that follow the key string in the file.  To point the screen saver <br>* at such a file, put the filename in the registry key entry "magic", under <br>* the registry setting group for the text3d screen saver.  The file format is <br>* as follows: <br>* <br>* -key0 <br>* item0 <br>* item1 <br>*  ... <br>* itemn <br>* -key1 <br>*  ... <br>* <br>* For example: <br>* -color <br>* red <br>* green <br>* -animal <br>* dog <br>* cat <br>* <br>\**************************************************************************/ <br>static BOOL <br>VerifyString( AttrContext *pac ) <br>{ <br>    HMODULE ghmodule; <br>    HRSRC hr; <br>    HGLOBAL hg; <br>    PSZ psz, pszFile = NULL; <br>    CHAR szSectName[30], szFileName[FILE_BUF_SIZE], szFname[30]; <br>    BOOL bMatch = FALSE; <br> <br>    // Check for string file in registry <br>    if (LoadStringA(hMainInstance, IDS_SAVERNAME, szSectName, 30) &amp;&amp; <br>        LoadStringA(hMainInstance, IDS_INIFILE, szFname, 30)) <br>    { <br>        if( GetPrivateProfileStringA(szSectName, "magic", NULL, <br>                                     szFileName, FILE_BUF_SIZE, szFname) ) <br>            pszFile = ReadStringFileA( szFileName ); <br>    } <br> <br>    // Check for key strings <br>    if( pszFile ) <br>        bMatch = CheckKeyStrings( pac-&gt;szText, pszFile ); <br> <br>    if( !bMatch ) { <br>        if( (ghmodule = GetModuleHandle(NULL)) &amp;&amp; <br>            (hr = FindResource(ghmodule, MAKEINTRESOURCE(1),  <br>                                                    MAKEINTRESOURCE(99))) &amp;&amp; <br>            (hg = LoadResource(ghmodule, hr)) &amp;&amp; <br>            (psz = (PSZ)LockResource(hg)) ) <br>        bMatch = CheckKeyStrings( pac-&gt;szText, psz ); <br>    } <br> <br>    if( bMatch ) { <br>        // put first string in pac-&gt;szText <br>        pac-&gt;demoType = DEMO_VSTRING; <br>        // for now, initialize strings here <br>        text3d_UpdateString( pac, FALSE ); <br> <br>        // adjust cycle time based on rotStyle <br>        switch( pac-&gt;rotStyle ) { <br>            case ROTSTYLE_NONE: <br>                gfMinCycleTime = 4.0f; <br>                break; <br>            case ROTSTYLE_SEESAW: <br>                gfMinCycleTime = 8.0f; <br>                break; <br>            case ROTSTYLE_RANDOM: <br>                gfMinCycleTime = 10.0f; <br>                break; <br>            default: <br>                gfMinCycleTime = 9.0f; <br>        } <br>    } <br>    if( pszFile ) <br>        free( pszFile );  // allocated by ReadStringFile <br>    return bMatch; <br>} <br> <br>/**************************************************************************\ <br>* CheckKeyStrings <br>* <br>* Test for match between string and any keystrings <br>* 'string' is user-inputted, and limited to TEXT_LIMIT chars. <br>* <br>\**************************************************************************/ <br> <br>static BOOL <br>CheckKeyStrings( LPTSTR string, PSZ psz ) <br>{ <br>    TCHAR szKey[TEXT_LIMIT+1], testString[TEXT_LIMIT+1] = {0}; <br>    BOOL bMatch = FALSE; <br>    int nMatch = 0; <br>    int len; <br> <br>    // make copy of test string and convert to upper case <br>    lstrcpy( testString, string ); <br>#ifdef UNICODE <br>    _wcsupr( testString ); <br>#else <br>    _strupr( testString ); <br>#endif <br> <br>    while( psz[0] != '\n' ) { // iterate keyword/data sets <br>        while( psz[0] != '\n' ) {  // iterate keywords <br>            len = strlen( psz ); // ! could be &gt; TEXT_LIMIT if from file <br>            // invert keyword bits and convert to uppercase <br>#ifdef UNICODE <br>            // convert ascii keyword to unicode in szKey (inverts at same time) <br>            ConvertStringAsciiToUnicode( psz, szKey, <br>                                         len &gt; TEXT_LIMIT ? TEXT_LIMIT : len ); <br>            _wcsupr( szKey ); <br>#else <br>            // just copy keyword to szKey, without going over TEXT_LIMIT <br>            strncpy( szKey, psz, TEXT_LIMIT ); <br>            InvertBitsA( szKey, len &gt; TEXT_LIMIT ? TEXT_LIMIT : len ); <br>            szKey[TEXT_LIMIT] = '\0';  // in case len &gt; TEXT_LIMIT <br>            _strupr( szKey ); <br>#endif <br> <br>            if( !lstrcmp( szKey, testString ) ) { <br>                // keyword match ! <br>                bMatch = TRUE; <br>                nMatch++; <br>            } <br>            psz += len + 1;  // skip over NULL as well <br>        } <br>        psz++;  // skip over '\n' at end of keywords <br>        if( bMatch ) <br>            ReadNameList( psz ); <br> <br>        // skip over data to get to next keyword group <br>        while( *psz != '\n' ) <br>            psz++; <br>        psz++;  // skip over '\n' at end of data <br>        bMatch = FALSE; // keep searching for keyword matches <br>    } <br>    return nMatch; <br>} <br> <br>/**************************************************************************\ <br>* Various functions to process vstrings <br>* <br>\**************************************************************************/ <br> <br>static void <br>InvertBitsA( char *s, int len ) <br>{ <br>    while( len-- ) { <br>        *s++ = ~(*s); <br>    } <br>} <br> <br>static PSZ <br>ReadStringFileA( LPSTR szFile ) <br>{ <br>    char lineBuf[180]; <br>    PSZ buf, pBuf; <br>    int size, length, fdi; <br>    char *ps; <br>    char ctrl_n = '\n'; <br>    FILE *fIn; <br>    BOOL bKey; <br> <br>    // create buffer to hold entire file <br>    // mf: ! must be better way of getting file length! <br>    fdi = _open(szFile, O_RDONLY | O_BINARY); <br>    if( fdi &lt; 0 ) <br>        return NULL; <br>    size = _filelength( fdi ); <br>    _close(fdi); <br>    buf= (char *) malloc( size ); <br>    if( !buf) <br>        return NULL; <br> <br>    // open file for ascii text reading <br>    fIn = fopen( szFile, "r" ); <br>    if( !fIn ) <br>        return NULL; <br> <br>    // Read in keyword/data sequences <br> <br>    bKey = TRUE;  // so '\n' not appended to file when hit first keyword <br>    pBuf = buf; <br>    while( fgets( lineBuf, 180, fIn) ) { <br>        ps = lineBuf; <br>        if( *ps == '-' ) { <br>            // keyword <br>            if( !bKey ) { <br>                // first key in group, append '\n' to data <br>                *pBuf++ = ctrl_n; <br>            } <br>            bKey = TRUE; <br>            ps++; // skip '-' <br>        } else { <br>            // data <br>            if( bKey ) { <br>                // first data in group, append '\n' to keywords <br>                *pBuf++ = ctrl_n; <br>            } <br>            bKey = FALSE; <br>        } <br>        length = strlen( ps ); <br>        InvertBitsA( ps, length ); <br>        *(ps+length-1) = '\0'; // convert '\n' to null <br>        lstrcpyA( pBuf, ps ); <br>        pBuf += length; <br>    } <br>    fclose( fIn ); <br> <br>    // put 2 '\n' at end, for end condition <br>    *pBuf++ = ctrl_n; <br>    *pBuf++ = ctrl_n; <br>    return( buf ); <br>} <br> <br>static void <br>CreateRandomList() <br>{ <br>   PLIST plist = gplistComplete; <br>   PLIST *pplist; <br>   int i = 0; <br>   int n; <br> <br>   while (plist != NULL) { <br>       n = ss_iRand( i+1 ); <br>       pplist = &amp;gplist; <br> <br>       while (n &gt; 0) { <br>           pplist = &amp;((*pplist)-&gt;pnext); <br>           n--; <br>       } <br> <br>       plist-&gt;pnext = *pplist; <br>       *pplist = plist; <br> <br>       plist = plist-&gt;plistComplete; <br>       i++; <br>   } <br>} <br> <br>static void <br>AddName( <br>    LPTSTR pszStr) <br>{ <br>    PLIST plist = (PLIST)LocalAlloc(LPTR, sizeof(LIST)); <br>    if( !plist ) <br>        return; <br>    plist-&gt;pszStr = pszStr; <br>    plist-&gt;pnext = NULL; <br>    plist-&gt;plistComplete = gplistComplete; <br>    gplistComplete = plist; <br>} <br> <br>static void <br>ReadNameList( PSZ psz ) <br>{ <br>    int length; <br>    LPTSTR pszNew; <br> <br>    while (psz[0] != '\n') { <br>        length = 0; <br>        while (psz[length] != 0) { <br>            length++; <br>        } <br>        length; <br>        pszNew = (LPTSTR)LocalAlloc( LPTR, (length + 1)*sizeof(TCHAR) ); <br>        if( !pszNew ) <br>            return; <br>#ifdef UNICODE <br>        ConvertStringAsciiToUnicode( psz, (PWSTR) pszNew, length ); <br>#else <br>        strncpy( pszNew, psz, length ); <br>        InvertBitsA( pszNew, length ); <br>#endif <br>        AddName(pszNew); <br> <br>        psz += length + 1; <br>    } <br>} <br> <br>static void <br>DeleteNameList() <br>{ <br>    PLIST plist = gplistComplete, plistLast; <br> <br>    while( plist != NULL ) { <br>        LocalFree( plist-&gt;pszStr ); <br>        plistLast = plist; <br>        plist = plist-&gt;plistComplete; <br>        LocalFree( plistLast ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* ConvertStringAsciiToUnicorn <br>* <br>\**************************************************************************/ <br>static void <br>ConvertStringAsciiToUnicode( PSZ psz, PWSTR pwstr, int len ) <br>{ <br>    while( len-- ) <br>         *pwstr++ = ~(*psz++) &amp; 0xFF; <br>    *pwstr = 0; // null terminate <br>} <br> <br>/**************************************************************************\ <br>* FrameCalibration <br>* <br>* Adjusts the number of frames in a cycle to conform to desired cycle time <br>* <br>\**************************************************************************/ <br>static int <br>FrameCalibration( AttrContext *pac, struct _timeb *pBaseTime, int framesPerCycle, int nCycle ) <br>{ <br>    struct _timeb thisTime; <br>    FLOAT cycleTime; <br> <br>    _ftime( &amp;thisTime ); <br>    cycleTime = thisTime.time - pBaseTime-&gt;time + <br>           (thisTime.millitm - pBaseTime-&gt;millitm)/1000.0f; <br>    cycleTime /= (FLOAT) nCycle; <br> <br>    if( cycleTime &lt; gfMinCycleTime ) { <br>        // need to add more frames to cycle <br>        if( cycleTime == 0.0f ) // very unlikely <br>            framesPerCycle = 800; <br>        else <br>            framesPerCycle = (int)( (FLOAT)framesPerCycle * <br>                            (gfMinCycleTime/cycleTime) ); <br>    } else { <br>        // for vstrings, subtract frames from cycle <br>        if( pac-&gt;demoType == DEMO_VSTRING ) { <br>            framesPerCycle = (int)( (FLOAT)framesPerCycle * <br>                            (gfMinCycleTime/cycleTime) ); <br>        } <br>    } <br>#define MIN_FRAMES 16 <br>    // make sure it's not too small <br>    if( framesPerCycle &lt; MIN_FRAMES ) <br>        framesPerCycle = MIN_FRAMES; <br> <br>    return framesPerCycle; <br>} <br> <br>/**************************************************************************\ <br>* MapValue <br>* <br>* Maps the value along an input range, to a proportional one along an <br>* output range.  Each range must be monotonically increasing or decreasing. <br>* <br>* NO boundary conditions checked - responsibility of caller. <br>* <br>\**************************************************************************/ <br>FLOAT <br>MapValue( FLOAT fInVal, <br>          FLOAT fIn1, FLOAT fIn2,       // input range <br>          FLOAT fOut1, FLOAT fOut2 )    // output range <br>{ <br>    FLOAT fDist, fOutVal; <br> <br>    // how far along the input range is fInVal?, in % <br>    fDist = (fInVal - fIn1) / (fIn2 - fIn1); <br> <br>    // use this distance to interpolate into output range <br>    fOutVal = fDist * (fOut2 - fOut1) + fOut1; <br> <br>    return fOutVal; <br>} <br> <br>/**************************************************************************\ <br>* MapValueI <br>* <br>* Similar to above, but maps integer values <br>* <br>* Currently, only works for increasing ranges <br>* <br>\**************************************************************************/ <br>int <br>MapValueI( int inVal, <br>          int in1, int in2,       // input range <br>          int out1, int out2 )    // output range <br>{ <br>    int inDiv; <br>    int outVal; <br>    FLOAT fScale, fComp; <br> <br>    if( inVal &gt;= in2 ) <br>        return out2; <br>    if( inVal &lt;= in1 ) <br>        return out1; <br> <br>    inDiv = abs(in2 - in1) + 1; <br>    fScale = (FLOAT) (inDiv-1) / (FLOAT) inDiv; <br>    fComp = 1.0f + (1.0f / inDiv); <br> <br>    outVal = (int) MapValue( (FLOAT) inVal * fComp, <br>                       (FLOAT) in1, (FLOAT) in2 + 0.999f, <br>                       (FLOAT) out1, (FLOAT) out2 + 0.999f ); <br>    return outVal; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
