<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLEAR.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3691"></a>CLEAR.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: clear.cxx <br>* <br>* Window clearing functions <br>* <br>* Copyright 1996 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;math.h&gt; <br>#include "ssintrnl.hxx" <br>#include "util.hxx" <br>#include "clear.hxx" <br> <br>#define SS_CLEAR_BASE_DIV 32 <br>#define SS_CLEAR_BASE_SIZE 16 <br> <br> <br>/******************************Public*Routine******************************\ <br>* ss_RectWipeClear <br>* <br>* Clears by drawing top, bottom, left, right rectangles that shrink in size <br>* towards the center. <br>* <br>* Calibration is used to try to maintain an ideal clear time. <br>* <br>\**************************************************************************/ <br> <br>int <br>ss_RectWipeClear( int width, int height, int repCount ) <br>{ <br>    int i, j, xinc, yinc, numDivs; <br>    int xmin, xmax, ymin, ymax; <br>    int w, h; <br>    BOOL bCalibrate = FALSE; <br>    double elapsed; <br>    static double idealTime = 0.7; <br>    SS_TIMER timer; <br> <br>    xinc = 1; <br>    yinc = 1; <br>    numDivs = height; // assumes height &lt;= width <br> <br>    xmin = ymin = 0; <br>    xmax = width-1; <br>    ymax = height-1; <br> <br>    glClearColor( 0.0f, 0.0f, 0.0f, 0.0f ); <br> <br>    glEnable( GL_SCISSOR_TEST ); <br> <br>    if( repCount == 0 ) { <br>        bCalibrate = TRUE; <br>        repCount = 1; <br>        timer.Start(); <br>    } <br> <br>    for( i = 0; i &lt; (numDivs/2); i ++ ) { <br>      w = xmax - xmin + 1; <br>      h = ymax - ymin + 1; <br> <br>      for( j = 0; j &lt; repCount; j ++ ) { <br>        // bottom <br>        glScissor( xmin, ymin, w, 1 ); <br>        glClear( GL_COLOR_BUFFER_BIT ); <br> <br>        // left <br>        glScissor( xmin, ymin, 1, h ); <br>        glClear( GL_COLOR_BUFFER_BIT ); <br> <br>        // right <br>        glScissor( xmax, ymin, 1, h ); <br>        glClear( GL_COLOR_BUFFER_BIT ); <br> <br>        // top <br>        glScissor( xmin, ymax, w, 1 ); <br>        glClear( GL_COLOR_BUFFER_BIT ); <br> <br>        glFlush(); // to eliminate 'bursts' <br>      } <br> <br>      xmin += xinc; <br>      xmax -= xinc; <br>      ymin += yinc; <br>      ymax -= yinc; <br>    } <br> <br>    if( bCalibrate ) { <br>        elapsed = timer.Stop(); <br> <br>        // try to maintain ideal clear time <br>        if( elapsed &lt; idealTime ) { <br>            // increase repCount to slow down the clear <br>            if( elapsed == 0.0 ) <br>                repCount = 10;  // just in case <br>            else <br>                repCount = (int) ((idealTime / elapsed) + 0.5); <br>        } <br>    } <br> <br>    glDisable( GL_SCISSOR_TEST ); <br> <br>    return repCount; <br>} <br> <br>#define SS_CLEAR_BASE_DIV 32 <br> <br>/******************************Public*Routine******************************\ <br>* <br>* SS_DIGITAL_DISSOLVE_CLEAR constructor <br>* <br>\**************************************************************************/ <br> <br>SS_DIGITAL_DISSOLVE_CLEAR:: <br>SS_DIGITAL_DISSOLVE_CLEAR() <br>{ <br>    rectBuf = NULL; <br>    rectBufSize = 0; <br>    rectSize = SS_CLEAR_BASE_SIZE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* SS_DIGITAL_DISSOLVE_CLEAR destructor <br>* <br>\**************************************************************************/ <br> <br>SS_DIGITAL_DISSOLVE_CLEAR:: <br>~SS_DIGITAL_DISSOLVE_CLEAR() <br>{ <br>    if( rectBuf ) <br>        LocalFree( rectBuf ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* CalibrateClear <br>* <br>* Try to calibrate the clear so it takes the specified time <br>\**************************************************************************/ <br> <br> <br>int SS_DIGITAL_DISSOLVE_CLEAR:: <br>CalibrateClear( int width, int height, float fClearTime ) <br>{ <br>    float factor; <br>    int idealNRects; <br>    int nRects; <br>    int baseSize; <br>    SS_TIMER timer; <br>    float elapsed; <br> <br>    baseSize = (width &lt; height ? width : height) / SS_CLEAR_BASE_DIV; <br>    if( baseSize == 0 ) <br>        baseSize = 1; <br> <br>    timer.Start(); <br> <br>#ifdef AUTO_CALIBRATE <br>    // Clear a small region (quarter-screen) and extrapolate <br>    Clear( width &gt;&gt; 1, height &gt;&gt; 1, baseSize ); <br>#else <br>    Clear( width, height, baseSize ); <br>#endif <br> <br>    elapsed = timer.Stop(); <br>#ifdef AUTO_CALIBRATE <br>    // extrapolate to full screen time <br>    // this approximation resulted in clears being somewhat less than ideal <br>    elapsed *= 4.0f; <br>#endif <br> <br>    // Adjust size of rects for ideal clear time <br> <br>    if( elapsed &lt;= 0.0f ) { <br>        rectSize = 1; <br>        return rectSize; <br>    } <br> <br>    nRects = RectangleCount( width, height, baseSize ); <br>    factor = fClearTime / elapsed; <br>    idealNRects = (int) (factor * (float)nRects); <br>    rectSize = (int) (sqrt( (double)(width*height) / (double)idealNRects ) + 0.5); <br>    if( rectSize == 0 ) <br>        rectSize = 1; <br> <br>    return rectSize; <br>} <br> <br>/******************************Public*Routine******************************\ <br>*  <br>* SS_DIGITAL_DISSOLVE_CLEAR::Clear <br>* <br>* Clears by drawing random rectangles <br>* <br>\**************************************************************************/ <br> <br> <br>BOOL SS_DIGITAL_DISSOLVE_CLEAR:: <br>Clear( int width, int height ) <br>{ <br>    return Clear( width, height, rectSize ); <br>} <br> <br>BOOL SS_DIGITAL_DISSOLVE_CLEAR:: <br>Clear( int width, int height, int size ) <br>{ <br>    BOOL *pRect; <br>    BOOL bCalibrate = FALSE; <br>    int count, nRects; <br>    int i, xdim, ydim; <br>    static float idealTime = 2.0f; <br> <br>    if( (size &lt;= 0) || !width || !height ) <br>        return FALSE; <br> <br>    // determine xdim, ydim from size <br>    xdim = SS_ROUND_UP( (float)width / (float)size ); <br>    ydim = SS_ROUND_UP( (float)height / (float) size ); <br> <br>    // figure out how many rects needed <br>    count = nRects = xdim * ydim; <br> <br>    // make sure enough room <br>    if( !ValidateBufSize( nRects ) ) <br>        return FALSE; <br> <br>    // reset the rect array to uncleared <br> <br>    pRect = rectBuf; <br>    for( i = 0; i &lt; count; i ++, pRect++ ) <br>        *pRect = FALSE; <br> <br>    // Clear random rectangles <br> <br>    glEnable( GL_SCISSOR_TEST ); <br> <br>    while( count ) { <br>        // pick a random rect <br>        i = ss_iRand( nRects ); <br> <br>        if( rectBuf[i] ) { <br>            // This rect has already been cleared - find an empty one <br>            // Scan up and down from x,y, looking at the array linearly <br> <br>            int up, down; <br>            BOOL searchUp; <br> <br>            up = down = i; <br> <br>            pRect = rectBuf; <br>            while( *(pRect + i) ) { <br>                if( searchUp ) { <br>                    // search up side <br>                    if( up &lt; (nRects-1) ) { <br>                        up++; <br>                    } <br>                    i = up; <br>                } else { <br>                    // search down side <br>                    if( down &gt; 0 ) { <br>                        down--; <br>                    } <br>                    i = down; <br>                } <br>                searchUp = !searchUp; <br>            } <br>        } <br> <br>        // clear the x,y rect <br>        glScissor( (i % xdim)*size, (i / xdim)*size, size, size ); <br>        glClear( GL_COLOR_BUFFER_BIT ); <br>        glFlush(); <br> <br>        rectBuf[i] = TRUE; // mark as taken <br>        count--; <br>    } <br> <br>    glDisable( GL_SCISSOR_TEST ); <br> <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* RectangleCount <br>* <br>\**************************************************************************/ <br> <br>int SS_DIGITAL_DISSOLVE_CLEAR:: <br>RectangleCount( int width, int height, int size ) <br>{ <br>    return  SS_ROUND_UP( (float)width / (float)size ) * <br>            SS_ROUND_UP( (float)height / (float) size ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ValidateBufSize <br>* <br>\**************************************************************************/ <br> <br>BOOL SS_DIGITAL_DISSOLVE_CLEAR:: <br>ValidateBufSize( int nRects ) <br>{ <br>    if( nRects &gt; rectBufSize ) { <br>        // need a bigger rect buf <br>        BOOL *r = (BOOL *) LocalAlloc( LMEM_FIXED, sizeof(BOOL) * nRects ); <br>        if( !r ) <br>            return FALSE; <br>        if( rectBuf ) <br>            LocalFree( rectBuf ); <br>        rectBuf = r; <br>        rectBufSize = nRects; <br>    } <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* DrawGdiRect <br>* <br>* Clears the rect with the brush <br>\**************************************************************************/ <br> <br>void <br>DrawGdiRect( HDC hdc, HBRUSH hbr, RECT *pRect )  <br>{ <br>    if( pRect == NULL ) <br>        return; <br> <br>    FillRect( hdc, pRect, hbr ); <br>    GdiFlush(); <br>} <br> <br>#ifdef SS_INITIAL_CLEAR <br>/*----------------------------------------------------------------------- <br>|                                                                        <br>|    RectWipeClear(width, height):   <br>|       - Does a rectangular wipe (or clear) by drawing in a sequence    <br>|         of rectangles using Gdi                                        <br>|       MOD: add calibrator capability to adjust speed for different <br>|            architectures <br>|       MOD: this can be further optimized by caching the brush <br>| <br>-----------------------------------------------------------------------*/ <br>void  <br>ss_GdiRectWipeClear( HWND hwnd, int width, int height ) <br>{ <br>    HDC hdc; <br>    HBRUSH hbr; <br>    RECT rect; <br>    int i, j, xinc, yinc, numDivs = 500; <br>    int xmin, xmax, ymin, ymax; <br>    int repCount = 10; <br> <br>    xinc = 1; <br>    yinc = 1; <br>    numDivs = height; <br>    xmin = ymin = 0; <br>    xmax = width; <br>    ymax = height; <br> <br>    hdc = GetDC( hwnd ); <br> <br>    hbr = CreateSolidBrush( RGB( 0, 0, 0 ) ); <br> <br>    for( i = 0; i &lt; (numDivs/2 - 1); i ++ ) { <br>      for( j = 0; j &lt; repCount; j ++ ) { <br>        rect.left = xmin; rect.top = ymin; <br>        rect.right = xmax; rect.bottom = ymin + yinc; <br>        FillRect( hdc, &amp;rect, hbr ); <br>        rect.top = ymax - yinc; <br>        rect.bottom = ymax; <br>        FillRect( hdc, &amp;rect, hbr ); <br>        rect.top = ymin + yinc; <br>        rect.right = xmin + xinc; rect.bottom = ymax - yinc; <br>        FillRect( hdc, &amp;rect, hbr ); <br>        rect.left = xmax - xinc; rect.top = ymin + yinc; <br>        rect.right = xmax; rect.bottom = ymax - yinc; <br>        FillRect( hdc, &amp;rect, hbr ); <br>      } <br> <br>      xmin += xinc; <br>      xmax -= xinc; <br>      ymin += yinc; <br>      ymax -= yinc; <br>    } <br> <br>    // clear last square in middle <br> <br>    rect.left = xmin; rect.top = ymin; <br>    rect.right = xmax; rect.bottom = ymax; <br>    FillRect( hdc, &amp;rect, hbr ); <br> <br>    DeleteObject( hbr ); <br> <br>    ReleaseDC( hwnd, hdc ); <br> <br>    GdiFlush(); <br>} <br>#endif // SS_INITIAL_CLEAR </code></pre>
<p>&nbsp;</p></body>
</HTML>
