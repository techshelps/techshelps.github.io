<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PIPE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3752"></a>PIPE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: pipe.cxx <br>* <br>* - Pipe base class stuff <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "sspipes.h" <br>#include "state.h" <br>#include "pipe.h" <br> <br>/******************************Public*Routine******************************\ <br>* PIPE constructor <br>\**************************************************************************/ <br> <br>PIPE::PIPE( STATE *state ) <br>{ <br>    pState = state; <br>    bTexture = pState-&gt;bTexture; <br>    radius = pState-&gt;radius; <br>    // default direction choosing is random <br>    chooseDirMethod = CHOOSE_DIR_RANDOM_WEIGHTED; <br>    chooseStartPosMethod = CHOOSE_STARTPOS_RANDOM; <br>    weightStraight = 1; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ChooseMaterial <br>* <br>\**************************************************************************/ <br> <br>void  <br>PIPE::ChooseMaterial( ) <br>{ <br>    if( bTexture ) <br>        ss_RandomTexMaterial( TRUE ); <br>    else <br>        ss_RandomTeaMaterial( TRUE ); <br>} <br> <br>/**************************************************************************\ <br>* <br>* DrawTeapot <br>* <br>\**************************************************************************/ <br> <br>extern void ResetEvaluator( BOOL bTexture ); <br> <br>void  <br>PIPE::DrawTeapot( ) <br>{ <br>    glFrontFace( GL_CW ); <br>    glEnable( GL_NORMALIZE ); <br>    auxSolidTeapot(2.5 * radius); <br>    glDisable( GL_NORMALIZE ); <br>    glFrontFace( GL_CCW ); <br>    if( type != TYPE_NORMAL ) { <br>        // Re-init flex's evaluator state (teapot uses evaluators as well, <br>        //  and messes up the state). <br>        ResetEvaluator( bTexture ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetChooseDirectionMethod <br>\**************************************************************************/ <br> <br>void <br>PIPE::SetChooseDirectionMethod( int method ) <br>{ <br>    chooseDirMethod = method; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* ChooseNewDirection <br>* <br>* Call direction-finding function based on current method <br>* This is a generic entry point that is used by some pipe types <br>* <br>\**************************************************************************/ <br> <br>int  <br>PIPE::ChooseNewDirection() <br>{ <br>    NODE_ARRAY *nodes = pState-&gt;nodes; <br>    int bestDirs[NUM_DIRS], nBestDirs; <br> <br>    // figger out which fn to call <br>    switch( chooseDirMethod ) { <br>        case CHOOSE_DIR_CHASE: <br>            if( nBestDirs = GetBestDirsForChase( bestDirs ) ) <br>                return nodes-&gt;ChoosePreferredDirection( &amp;curPos, lastDir,  <br>                                                        bestDirs, nBestDirs ); <br>            // else lead pipe must have died, so fall thru: <br>        case CHOOSE_DIR_RANDOM_WEIGHTED : <br>        default: <br>            return nodes-&gt;ChooseRandomDirection( &amp;curPos, lastDir, weightStraight ); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* <br>* GetBestDirsForChase <br>* <br>* Find the best directions to take to close in on the lead pipe in chase mode. <br>* <br>\**************************************************************************/ <br> <br>int <br>PIPE::GetBestDirsForChase( int *bestDirs ) <br>{ <br>    // Figure out best dirs to close in on leadPos <br> <br>    //mf: will have to 'protect' leadPos with GetLeadPos() for multi-threading <br>    IPOINT3D *leadPos = &amp;pState-&gt;pLeadPipe-&gt;curPos; <br>    IPOINT3D delta; <br>    int numDirs = 0; <br> <br>    delta.x = leadPos-&gt;x - curPos.x; <br>    delta.y = leadPos-&gt;y - curPos.y; <br>    delta.z = leadPos-&gt;z - curPos.z; <br> <br>    if( delta.x ) { <br>        numDirs++; <br>        *bestDirs++ = delta.x &gt; 0 ? PLUS_X : MINUS_X; <br>    } <br>    if( delta.y ) { <br>        numDirs++; <br>        *bestDirs++ = delta.y &gt; 0 ? PLUS_Y : MINUS_Y; <br>    } <br>    if( delta.z ) { <br>        numDirs++; <br>        *bestDirs++ = delta.z &gt; 0 ? PLUS_Z : MINUS_Z; <br>    } <br>    // It should be impossible for numDirs = 0 (all deltas = 0), as this <br>    // means curPos = leadPos <br>    return numDirs; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SetChooseStartPosMethod <br>\**************************************************************************/ <br> <br>void <br>PIPE::SetChooseStartPosMethod( int method ) <br>{ <br>    chooseStartPosMethod = method; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* PIPE::SetStartPos <br>* <br>* - Find an empty node to start the pipe on <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>PIPE::SetStartPos() <br>{ <br>    NODE_ARRAY *nodes = pState-&gt;nodes; <br> <br>    switch( chooseStartPosMethod ) { <br> <br>        case CHOOSE_STARTPOS_RANDOM: <br>        default: <br>            if( !nodes-&gt;FindRandomEmptyNode( &amp;curPos ) ) { <br>                return FALSE; <br>            } <br>            return TRUE; <br>         <br>        case CHOOSE_STARTPOS_FURTHEST: <br>            // find node furthest away from curPos <br>            IPOINT3D refPos, numNodes; <br>            nodes-&gt;GetNodeCount( &amp;numNodes ); <br>            refPos.x = (curPos.x &gt;= (numNodes.x / 2)) ? 0 : numNodes.x - 1; <br>            refPos.y = (curPos.y &gt;= (numNodes.y / 2)) ? 0 : numNodes.y - 1; <br>            refPos.z = (curPos.z &gt;= (numNodes.z / 2)) ? 0 : numNodes.z - 1; <br> <br>            if( !nodes-&gt;TakeClosestEmptyNode( &amp;curPos, &amp;refPos ) ) { <br>                return FALSE; <br>            } <br>            return TRUE; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* PIPE::IsStuck <br>\**************************************************************************/ <br> <br>BOOL <br>PIPE::IsStuck() <br>{ <br>    return status == PIPE_STUCK; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* PIPE::TranslateToCurrentPosition <br>* <br>\**************************************************************************/ <br> <br>void <br>PIPE::TranslateToCurrentPosition() <br>{ <br>    IPOINT3D numNodes; <br> <br>    float divSize = pState-&gt;view.divSize; <br>    // this requires knowing the size of the node array <br>    pState-&gt;nodes-&gt;GetNodeCount( &amp;numNodes ); <br>    glTranslatef( (curPos.x - (numNodes.x - 1)/2.0f )*divSize, <br>                  (curPos.y - (numNodes.y - 1)/2.0f )*divSize, <br>                  (curPos.z - (numNodes.z - 1)/2.0f )*divSize ); <br>} <br> <br>/**************************************************************************\ <br>* <br>* UpdateCurrentPosition <br>*  <br>* Increment current position according to direction taken <br>\**************************************************************************/ <br> <br>void  <br>PIPE::UpdateCurrentPosition( int newDir ) <br>{ <br>    switch( newDir ) { <br>        case PLUS_X: <br>            curPos.x += 1; <br>            break; <br>        case MINUS_X: <br>            curPos.x -= 1; <br>            break; <br>        case PLUS_Y: <br>            curPos.y += 1; <br>            break; <br>        case MINUS_Y: <br>            curPos.y -= 1; <br>            break; <br>        case PLUS_Z: <br>            curPos.z += 1; <br>            break; <br>        case MINUS_Z: <br>            curPos.z -= 1; <br>            break; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* align_plusz <br>* <br>* - Aligns the z axis along specified direction <br>* - Used for all types of pipes <br>* <br>\**************************************************************************/ <br> <br> <br>void align_plusz( int newDir ) <br>{ <br>    // align +z along new direction <br>    switch( newDir ) { <br>        case PLUS_X: <br>            glRotatef( 90.0f, 0.0f, 1.0f, 0.0f); <br>            break; <br>        case MINUS_X: <br>            glRotatef( -90.0f, 0.0f, 1.0f, 0.0f); <br>            break; <br>        case PLUS_Y: <br>            glRotatef( -90.0f, 1.0f, 0.0f, 0.0f); <br>            break; <br>        case MINUS_Y: <br>            glRotatef( 90.0f, 1.0f, 0.0f, 0.0f); <br>            break; <br>        case PLUS_Z: <br>            glRotatef( 0.0f, 0.0f, 1.0f, 0.0f); <br>            break; <br>        case MINUS_Z: <br>            glRotatef( 180.0f, 0.0f, 1.0f, 0.0f); <br>            break; <br>    } <br> <br>} <br> <br>/**************************************************************************\ <br>* this array tells you which way the notch will be once you make <br>* a turn <br>* format: notchTurn[oldDir][newDir][notchVec]  <br>* <br>\**************************************************************************/ <br> <br>GLint notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS] = { <br>// oldDir = +x <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z, <br>        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z, <br>        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, <br>        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X, <br>// oldDir = -x <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z, <br>        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z, <br>        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X, <br>        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X, <br>// oldDir = +y <br>        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z, <br>        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y, <br>        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y, <br>// oldDir = -y <br>        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z, <br>        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y, <br>        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y, <br>// oldDir = +z <br>        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX, <br>        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX, <br>        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX, <br>        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>// oldDir = -z <br>        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX, <br>        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX, <br>        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX, <br>        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX, <br>        iXX,    iXX,    iXX,    iXX,    iXX,    iXX <br>}; </code></pre>
<p>&nbsp;</p></body>
</HTML>
