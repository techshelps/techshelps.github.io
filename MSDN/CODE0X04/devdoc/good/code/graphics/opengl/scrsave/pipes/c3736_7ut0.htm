<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NODE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3744"></a>NODE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: node.cxx <br>* <br>* Pipes node array <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "sspipes.h" <br>#include "node.h" <br> <br> <br>/**************************************************************************\ <br>* <br>* NODE_ARRAY constructor <br>* <br>\**************************************************************************/ <br> <br>NODE_ARRAY::NODE_ARRAY() <br>{ <br>    nodes = NULL; // allocated on Resize <br> <br>    numNodes.x = 0; <br>    numNodes.y = 0; <br>    numNodes.z = 0; <br>} <br> <br>/**************************************************************************\ <br>* <br>* NODE_ARRAY destructor <br>* <br>\**************************************************************************/ <br> <br>NODE_ARRAY::~NODE_ARRAY( ) <br>{ <br>    if( nodes ) <br>        delete nodes; <br>} <br> <br>/**************************************************************************\ <br>* <br>* Resize <br>* <br>\**************************************************************************/ <br> <br>void <br>NODE_ARRAY::Resize( IPOINT3D *pNewSize ) <br>{ <br>    if( (numNodes.x == pNewSize-&gt;x) &amp;&amp; <br>        (numNodes.y == pNewSize-&gt;y) &amp;&amp; <br>        (numNodes.z == pNewSize-&gt;z) ) <br>        return; <br> <br>    numNodes = *pNewSize; <br> <br>    int elemCount = numNodes.x * numNodes.y * numNodes.z ; <br> <br>    if( nodes ) <br>        delete nodes; <br> <br>    nodes = new Node[elemCount]; <br> <br>    SS_ASSERT( nodes, "NODE_ARRAY::Resize : can't alloc nodes\n" ); <br> <br>    // Reset the node states to empty <br> <br>    int i; <br>    Node *pNode = nodes; <br>    for( i = 0; i &lt; elemCount; i++, pNode++ ) <br>        pNode-&gt;MarkAsEmpty(); <br> <br>    // precalculate direction offsets between nodes for speed <br>    nodeDirInc[PLUS_X] = 1; <br>    nodeDirInc[MINUS_X] = -1; <br>    nodeDirInc[PLUS_Y] = numNodes.x; <br>    nodeDirInc[MINUS_Y] = - nodeDirInc[PLUS_Y]; <br>    nodeDirInc[PLUS_Z] = numNodes.x * numNodes.y; <br>    nodeDirInc[MINUS_Z] = - nodeDirInc[PLUS_Z]; <br>} <br> <br>/**************************************************************************\ <br>* <br>* Reset <br>* <br>\**************************************************************************/ <br> <br>void <br>NODE_ARRAY::Reset( ) <br>{ <br>    int i; <br>    Node *pNode = nodes; <br> <br>    // Reset the node states to empty <br>    for( i = 0; i &lt; (numNodes.x)*(numNodes.y)*(numNodes.z); i++, pNode++ ) <br>        pNode-&gt;MarkAsEmpty(); <br>} <br> <br>/**************************************************************************\ <br>* <br>* GetNodeCount <br>* <br>\**************************************************************************/ <br> <br>void <br>NODE_ARRAY::GetNodeCount( IPOINT3D *count ) <br>{ <br>    *count = numNodes; <br>} <br> <br>/**************************************************************************\ <br>* <br>* ChooseRandomDirection <br>* <br>* Choose randomnly among the possible directions.  The likelyhood of going <br>* straight is controlled by weighting it. <br>* <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::ChooseRandomDirection( IPOINT3D *pos, int dir, int weightStraight ) <br>{ <br>    Node *nNode[NUM_DIRS]; <br>    int numEmpty, newDir; <br>    int choice; <br>    Node *straightNode = NULL; <br>    int emptyDirs[NUM_DIRS]; <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::ChooseRandomDirection: invalid dir\n" ); <br> <br>    // Get the neigbouring nodes <br>    GetNeighbours( pos, nNode ); <br> <br>    // Get node in straight direction if necessary <br>    if( weightStraight &amp;&amp; nNode[dir] &amp;&amp; nNode[dir]-&gt;IsEmpty() ) { <br>        straightNode = nNode[dir]; <br>        // if maximum weight, choose and return <br>        if( weightStraight == MAX_WEIGHT_STRAIGHT ) { <br>            straightNode-&gt;MarkAsTaken(); <br>            return dir; <br>        } <br>    } else <br>        weightStraight = 0; <br> <br>    // Get directions of possible turns <br>    numEmpty = GetEmptyTurnNeighbours( nNode, emptyDirs, dir ); <br> <br>    // Make a random choice <br>    if( (choice = (weightStraight + numEmpty)) == 0 ) <br>        return DIR_NONE; <br>    choice = ss_iRand( choice ); <br> <br>    if( choice &lt; weightStraight ) { <br>        straightNode-&gt;MarkAsTaken(); <br>        return dir; <br>    } else { <br>        // choose one of the turns <br>        newDir = emptyDirs[choice - weightStraight]; <br>        nNode[newDir]-&gt;MarkAsTaken(); <br>        return newDir; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* <br>* ChoosePreferredDirection <br>* <br>* Choose randomnly from one of the supplied preferred directions.  If none <br>* of these are available, then try and choose any empty direction <br>* <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs, <br>                                      int nPrefDirs ) <br>{ <br>    Node *nNode[NUM_DIRS]; <br>    int numEmpty, newDir; <br>    int emptyDirs[NUM_DIRS]; <br>    int *pEmptyPrefDirs; <br>    int i, j; <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::ChoosePreferredDirection : invalid dir\n" ); <br> <br>    // Get the neigbouring nodes <br>    GetNeighbours( pos, nNode ); <br> <br>    // Create list of directions that are both preferred and empty <br> <br>    pEmptyPrefDirs = emptyDirs; <br>    numEmpty = 0; <br> <br>    for( i = 0, j = 0; (i &lt; NUM_DIRS) &amp;&amp; (j &lt; nPrefDirs); i++ ) { <br>        if( i == *prefDirs ) { <br>            prefDirs++; <br>            j++; <br>            if( nNode[i] &amp;&amp; nNode[i]-&gt;IsEmpty() ) { <br>                // add it to list <br>                *pEmptyPrefDirs++ = i; <br>                numEmpty++; <br>            } <br>        } <br>    } <br> <br>    // if no empty preferred dirs, then any empty dirs become preferred <br>     <br>    if( !numEmpty ) { <br>        numEmpty = GetEmptyNeighbours( nNode, emptyDirs ); <br>        if( numEmpty == 0 ) <br>            return DIR_NONE; <br>    } <br>                 <br>    // Pick a random dir from the empty set <br> <br>    newDir = emptyDirs[ss_iRand( numEmpty )]; <br>    nNode[newDir]-&gt;MarkAsTaken(); <br>    return newDir; <br>} <br> <br>/**************************************************************************\ <br>* <br>* FindClearestDirection <br>* <br>* Finds the direction with the most empty nodes in a line 'searchRadius' <br>* long.  Does not mark any nodes as taken. <br>* <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::FindClearestDirection( IPOINT3D *pos ) <br>{ <br>    static Node *neighbNode[NUM_DIRS]; <br>    static int emptyDirs[NUM_DIRS]; <br>    int nEmpty, newDir; <br>    int maxEmpty = 0; <br>    int searchRadius = 3; <br>    int count = 0; <br>    int i; <br> <br>    // Get ptrs to neighbour nodes <br> <br>    GetNeighbours( pos, neighbNode ); <br> <br>    // find empty nodes in each direction <br> <br>    for( i = 0; i &lt; NUM_DIRS; i ++ ) { <br>        if( neighbNode[i] &amp;&amp; neighbNode[i]-&gt;IsEmpty() ) <br>        { <br>            // find number of contiguous empty nodes along this direction <br>            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius ); <br>            if( nEmpty &gt; maxEmpty ) { <br>                // we have a new winner <br>                count = 0; <br>                maxEmpty = nEmpty; <br>                emptyDirs[count++] = i; <br>            } <br>            else if( nEmpty == maxEmpty ) { <br>                // tied with current max <br>                emptyDirs[count++] = i; <br>            } <br>        } <br>    } <br> <br>    if( count == 0 ) <br>        return DIR_NONE; <br> <br>    // randomnly choose a direction <br>    newDir = emptyDirs[ss_iRand( count )]; <br> <br>    return newDir; <br>} <br>/**************************************************************************\ <br>* <br>* ChooseNewTurnDirection <br>* <br>* Choose a direction to turn <br>* <br>* This requires finding a pair of nodes to turn through.  The first node <br>* is in the direction of the turn from the current node, and the second node <br>* is at right angles to this at the end position.  The prim will not draw <br>* through the first node, but may sweep close to it, so we have to mark it <br>* as taken. <br>* <br>* - if next node is free, but there are no turns available, return <br>*   DIR_STRAIGHT, so the caller can decide what to do in this case <br>* - The turn possibilities are based on the orientation of the current xc, with <br>*   4 relative directions to seek turns in. <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::ChooseNewTurnDirection( IPOINT3D *pos, int dir ) <br>{ <br>    int turns[NUM_DIRS], nTurns; <br>    IPOINT3D nextPos; <br>    int newDir; <br>    Node *nextNode; <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::ChooseNewTurnDirection : invalid dir\n" ); <br> <br> <br>    // First, check if next node along current dir is empty <br> <br>    if( ! GetNextNodePos( pos, &amp;nextPos, dir ) ) <br>        return DIR_NONE; // node out of bounds or not empty <br> <br>    // Ok, the next node is free - check the 4 possible turns from here <br> <br>    nTurns = GetBestPossibleTurns( &amp;nextPos, dir, turns ); <br>    if( nTurns == 0 ) <br>        return DIR_STRAIGHT; // nowhere to turn, but could go straight <br> <br>    // randomnly choose one of the possible turns <br>    newDir = turns[ ss_iRand( nTurns ) ]; <br> <br>    SS_ASSERT( (newDir &gt;= 0) &amp;&amp; (newDir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::ChooseNewTurnDirection : invalid newDir\n" ); <br> <br>    // mark taken nodes <br> <br>    nextNode = GetNode( &amp;nextPos ); <br>    nextNode-&gt;MarkAsTaken(); <br> <br>    nextNode = GetNextNode( &amp;nextPos, newDir ); <br>    nextNode-&gt;MarkAsTaken(); <br> <br>    return newDir; <br>} <br> <br>/**************************************************************************\ <br>* <br>* GetBestPossibleTurns <br>* <br>* From supplied direction and position, figure out which of 4 possible  <br>* directions are best to turn in. <br>* <br>* Turns that have the greatest number of empty nodes after the turn are the <br>* best, since a pipe is less likely to hit a dead end in this case. <br>* - We only check as far as 'searchRadius' nodes along each dir. <br>* - Return direction indices of best possible turns in turnDirs, and return  <br>*   count of these turns in fuction return value. <br>* <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs ) <br>{ <br>    Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes <br>    int i, count = 0; <br>    BOOL check[NUM_DIRS] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE}; <br>    int nEmpty, maxEmpty = 0; <br>    int searchRadius = 2; <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::GetBestPossibleTurns : invalid dir\n" ); <br> <br>    GetNeighbours( pos, neighbNode ); <br> <br>    switch( dir ) { <br>        case PLUS_X:     <br>        case MINUS_X: <br>            check[PLUS_X] = FALSE; <br>            check[MINUS_X] = FALSE; <br>            break; <br>        case PLUS_Y:     <br>        case MINUS_Y: <br>            check[PLUS_Y] = FALSE; <br>            check[MINUS_Y] = FALSE; <br>            break; <br>        case PLUS_Z:     <br>        case MINUS_Z: <br>            check[PLUS_Z] = FALSE; <br>            check[MINUS_Z] = FALSE; <br>            break; <br>    } <br> <br>    // check approppriate directions <br>    for( i = 0; i &lt; NUM_DIRS; i ++ ) { <br>        if( check[i] &amp;&amp; neighbNode[i] &amp;&amp; neighbNode[i]-&gt;IsEmpty() ) <br>        { <br>            // find number of contiguous empty nodes along this direction <br>            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius ); <br>            if( nEmpty &gt; maxEmpty ) { <br>                // we have a new winner <br>                count = 0; <br>                maxEmpty = nEmpty; <br>                turnDirs[count++] = i; <br>            } <br>            else if( nEmpty == maxEmpty ) { <br>                // tied with current max <br>                turnDirs[count++] = i; <br>            } <br>        } <br>    } <br> <br>    return count; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* GetNeighbours <br>* <br>* Get neigbour nodes relative to supplied position <br>* <br>*       - get addresses of the neigbour nodes, <br>*         and put them in supplied matrix <br>*       - boundary hits are returned as NULL <br>* <br>\**************************************************************************/ <br> <br>void  <br>NODE_ARRAY::GetNeighbours( IPOINT3D *pos, Node **nNode ) <br>{ <br>    Node *centerNode = GetNode( pos ); <br> <br>    nNode[PLUS_X]  = pos-&gt;x == (numNodes.x - 1) ? NULL :  <br>                                            centerNode + nodeDirInc[PLUS_X]; <br>    nNode[PLUS_Y]  = pos-&gt;y == (numNodes.y - 1) ? NULL : <br>                                            centerNode + nodeDirInc[PLUS_Y]; <br>    nNode[PLUS_Z]  = pos-&gt;z == (numNodes.z - 1) ? NULL :  <br>                                            centerNode + nodeDirInc[PLUS_Z]; <br> <br>    nNode[MINUS_X] = pos-&gt;x == 0 ? NULL : centerNode + nodeDirInc[MINUS_X]; <br>    nNode[MINUS_Y] = pos-&gt;y == 0 ? NULL : centerNode + nodeDirInc[MINUS_Y]; <br>    nNode[MINUS_Z] = pos-&gt;z == 0 ? NULL : centerNode + nodeDirInc[MINUS_Z]; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* NodeVisited <br>*  <br>* Mark the node as non-empty <br>*  <br>\**************************************************************************/ <br> <br>void  <br>NODE_ARRAY::NodeVisited( IPOINT3D *pos ) <br>{ <br>    (GetNode( pos ))-&gt;MarkAsTaken(); <br>} <br> <br>/**************************************************************************\ <br>* <br>* GetNode <br>* <br>* Get ptr to node from position <br>* <br>\**************************************************************************/ <br> <br>Node * <br>NODE_ARRAY::GetNode( IPOINT3D *pos ) <br>{ <br>    return nodes + <br>           pos-&gt;x + <br>           pos-&gt;y * numNodes.x + <br>           pos-&gt;z * numNodes.x * numNodes.y; <br>} <br> <br>/**************************************************************************\ <br>* <br>* GetNextNode <br>* <br>* Get ptr to next node from pos and dir <br>* <br>\**************************************************************************/ <br> <br>Node * <br>NODE_ARRAY::GetNextNode( IPOINT3D *pos, int dir ) <br>{ <br>    Node *curNode = GetNode( pos ); <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::GetNextNode : invalid dir\n" ); <br> <br>    switch( dir ) { <br>        case PLUS_X: <br>            return( pos-&gt;x == (numNodes.x - 1) ? NULL :  <br>                              curNode + nodeDirInc[PLUS_X]); <br>            break; <br>        case MINUS_X: <br>            return( pos-&gt;x == 0 ? NULL :  <br>                              curNode + nodeDirInc[MINUS_X]); <br>            break; <br>        case PLUS_Y: <br>            return( pos-&gt;y == (numNodes.y - 1) ? NULL :  <br>                              curNode + nodeDirInc[PLUS_Y]); <br>            break; <br>        case MINUS_Y: <br>            return( pos-&gt;y == 0 ? NULL :  <br>                              curNode + nodeDirInc[MINUS_Y]); <br>            break; <br>        case PLUS_Z: <br>            return( pos-&gt;z == (numNodes.z - 1) ? NULL :  <br>                              curNode + nodeDirInc[PLUS_Z]); <br>            break; <br>        case MINUS_Z: <br>            return( pos-&gt;z == 0 ? NULL :  <br>                              curNode + nodeDirInc[MINUS_Z]); <br>            break; <br>        default: <br>            return NULL; <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* GetNextNodePos <br>* <br>* Get position of next node from curPos and lastDir <br>* <br>* Returns FALSE if boundary hit or node empty <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>NODE_ARRAY::GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir ) <br>{ <br>    static Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::GetNextNodePos : invalid dir\n" ); <br> <br>// don't need to get all neighbours, just one in next direction <br>    GetNeighbours( curPos, neighbNode ); <br> <br>    *nextPos = *curPos; <br> <br>    // bail if boundary hit or node not empty <br>    if( (neighbNode[dir] == NULL) || !neighbNode[dir]-&gt;IsEmpty() ) <br>        return FALSE; <br> <br>    switch( dir ) { <br>        case PLUS_X: <br>            nextPos-&gt;x = curPos-&gt;x + 1; <br>            break; <br> <br>        case MINUS_X: <br>            nextPos-&gt;x = curPos-&gt;x - 1; <br>            break; <br> <br>        case PLUS_Y: <br>            nextPos-&gt;y = curPos-&gt;y + 1; <br>            break; <br> <br>        case MINUS_Y: <br>            nextPos-&gt;y = curPos-&gt;y - 1; <br>            break; <br> <br>        case PLUS_Z: <br>            nextPos-&gt;z = curPos-&gt;z + 1; <br>            break; <br> <br>        case MINUS_Z: <br>            nextPos-&gt;z = curPos-&gt;z - 1; <br>            break; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br>/**************************************************************************\ <br>*              <br>*    GetEmptyNeighbours() <br>*       - get list of direction indices of empty node neighbours, <br>*         and put them in supplied matrix <br>*       - return number of empty node neighbours <br>* <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::GetEmptyNeighbours( Node **nNode, int *nEmpty ) <br>{ <br>    int i, count = 0; <br> <br>    for( i = 0; i &lt; NUM_DIRS; i ++ ) { <br>        if( nNode[i] &amp;&amp; nNode[i]-&gt;IsEmpty() ) <br>            nEmpty[count++] = i; <br>    } <br>    return count; <br>} <br> <br>/**************************************************************************\ <br>*              <br>*    GetEmptyTurnNeighbours() <br>*       - get list of direction indices of empty node neighbours, <br>*         and put them in supplied matrix <br>*       - don't include going straight <br>*       - return number of empty node neighbours <br>* <br>\**************************************************************************/ <br> <br>int  <br>NODE_ARRAY::GetEmptyTurnNeighbours( Node **nNode, int *nEmpty, int lastDir ) <br>{ <br>    int i, count = 0; <br> <br>    for( i = 0; i &lt; NUM_DIRS; i ++ ) { <br>        if( nNode[i] &amp;&amp; nNode[i]-&gt;IsEmpty() ) { <br>            if( i == lastDir ) <br>                continue; <br>            nEmpty[count++] = i; <br>        } <br>    } <br>    return count; <br>} <br> <br>/**************************************************************************\ <br>* GetEmptyNeighboursAlongDir <br>* <br>* Sort of like above, but just gets one neigbour according to supplied dir <br>* <br>* Given a position and direction, find out how many contiguous empty nodes  <br>* there are in that direction. <br>* - Can limit search with searchRadius parameter <br>* - Return contiguous empty node count <br>\**************************************************************************/ <br> <br>int <br>NODE_ARRAY::GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir, <br>                            int searchRadius ) <br>{ <br>    Node *curNode = GetNode( pos ); <br>    int nodeStride; <br>    int maxSearch; <br>    int count = 0; <br> <br>    SS_ASSERT( (dir &gt;= 0) &amp;&amp; (dir &lt; NUM_DIRS),  <br>            "NODE_ARRAY::GetEmptyNeighboursAlongDir : invalid dir\n" ); <br> <br>    nodeStride = nodeDirInc[dir]; <br> <br>    switch( dir ) { <br>        case PLUS_X:     <br>            maxSearch = numNodes.x - pos-&gt;x - 1; <br>            break; <br>        case MINUS_X: <br>            maxSearch = pos-&gt;x; <br>            break; <br>        case PLUS_Y:     <br>            maxSearch = numNodes.y - pos-&gt;y - 1; <br>            break; <br>        case MINUS_Y: <br>            maxSearch = pos-&gt;y; <br>            break; <br>        case PLUS_Z:     <br>            maxSearch = numNodes.z - pos-&gt;z - 1; <br>            break; <br>        case MINUS_Z: <br>            maxSearch = pos-&gt;z; <br>            break; <br>    } <br>     <br>    if( searchRadius &gt; maxSearch ) <br>        searchRadius = maxSearch; <br> <br>    if( !searchRadius ) <br>        return 0; <br> <br>    while( searchRadius-- ) { <br>        curNode += nodeStride; <br>        if( ! curNode-&gt;IsEmpty() ) <br>            return count; <br>        count++; <br>    } <br>    return count; <br>} <br> <br>/**************************************************************************\ <br>* FindRandomEmptyNode <br>* <br>* - Search for an empty node to start drawing <br>* - Return position of empty node in supplied pos ptr <br>* - Returns FALSE if couldn't find a node <br>* - Marks node as taken (mf: renam fn to ChooseEmptyNode ? <br>* <br>\**************************************************************************/ <br> <br>// If random search takes longer than twice the total number <br>// of nodes, give up the random search.  There may not be any <br>// empty nodes. <br> <br>#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE) <br> <br>BOOL <br>NODE_ARRAY::FindRandomEmptyNode( IPOINT3D *pos ) <br>{ <br>    int infLoopDetect = 0; <br> <br>    while( TRUE ) { <br> <br>        // Pick a random node. <br> <br>        pos-&gt;x = ss_iRand( numNodes.x ); <br>        pos-&gt;y = ss_iRand( numNodes.y ); <br>        pos-&gt;z = ss_iRand( numNodes.z ); <br> <br>        // If its empty, we're done. <br> <br>        if( GetNode(pos)-&gt;IsEmpty() ) { <br>            NodeVisited( pos ); <br>            return TRUE; <br>        } else { <br>            // Watch out for infinite loops!  After trying for <br>            // awhile, give up on the random search and look <br>            // for the first empty node. <br> <br>            if ( infLoopDetect++ &gt; INFINITE_LOOP ) { <br> <br>                // Search for first empty node. <br> <br>                for ( pos-&gt;x = 0; pos-&gt;x &lt; numNodes.x; pos-&gt;x++ ) <br>                    for ( pos-&gt;y = 0; pos-&gt;y &lt; numNodes.y; pos-&gt;y++ ) <br>                        for ( pos-&gt;z = 0; pos-&gt;z &lt; numNodes.z; pos-&gt;z++ ) <br>                            if( GetNode(pos)-&gt;IsEmpty() ) { <br>                                NodeVisited( pos ); <br>                                return TRUE; <br>                            } <br> <br>                // There are no more empty nodes. <br>                // Reset the pipes and exit. <br> <br>                return FALSE; <br>            } <br>        } <br>    } <br>} <br> <br>/**************************************************************************\ <br>* FindRandomEmptyNode2D <br>* <br>* - Like FindRandomEmptyNode, but limits search to a 2d plane of the supplied <br>*   box. <br>* <br>\**************************************************************************/ <br> <br>#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE) <br>#define MIN_VAL 1 <br>#define MAX_VAL 0 <br> <br>BOOL <br>NODE_ARRAY::FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box ) <br>{ <br>    int *newx, *newy; <br>    int *xDim, *yDim; <br> <br>    switch( plane ) { <br>        case PLUS_X: <br>        case MINUS_X: <br>            pos-&gt;x = box[plane]; <br>            newx = &amp;pos-&gt;z; <br>            newy = &amp;pos-&gt;y; <br>            xDim = &amp;box[PLUS_Z];  <br>            yDim = &amp;box[PLUS_Y];  <br>            break; <br>        case PLUS_Y: <br>        case MINUS_Y: <br>            pos-&gt;y = box[plane]; <br>            newx = &amp;pos-&gt;x; <br>            newy = &amp;pos-&gt;z; <br>            xDim = &amp;box[PLUS_X];  <br>            yDim = &amp;box[PLUS_Z];  <br>            break; <br>        case PLUS_Z: <br>        case MINUS_Z: <br>            newx = &amp;pos-&gt;x; <br>            newy = &amp;pos-&gt;y; <br>            pos-&gt;z = box[plane]; <br>            xDim = &amp;box[PLUS_X];  <br>            yDim = &amp;box[PLUS_Y];  <br>            break; <br>    } <br> <br>    int infLoop = 2 * (xDim[MAX_VAL] - xDim[MIN_VAL] + 1) * <br>                      (yDim[MAX_VAL] - yDim[MIN_VAL] + 1); <br>    int infLoopDetect = 0; <br> <br>    while( TRUE ) { <br> <br>        // Pick a random node. <br> <br>        *newx = ss_iRand2( xDim[MIN_VAL], xDim[MAX_VAL] ); <br>        *newy = ss_iRand2( yDim[MIN_VAL], yDim[MAX_VAL] ); <br> <br>        // If its empty, we're done. <br> <br>        if( GetNode(pos)-&gt;IsEmpty() ) { <br>            NodeVisited( pos ); <br>            return TRUE; <br>        } else { <br>            // Watch out for infinite loops!  After trying for <br>            // awhile, give up on the random search and look <br>            // for the first empty node. <br> <br>            if ( ++infLoopDetect &gt; infLoop ) { <br> <br>                // Do linear search for first empty node. <br> <br>                for ( *newx = xDim[MIN_VAL]; *newx &lt;= xDim[MAX_VAL]; (*newx)++ ) <br>                    for ( *newy = yDim[MIN_VAL]; *newy &lt;= yDim[MAX_VAL]; (*newy)++ ) <br>                        if( GetNode(pos)-&gt;IsEmpty() ) { <br>                            NodeVisited( pos ); <br>                            return TRUE; <br>                        } <br> <br>                // There are no empty nodes in this plane. <br>                return FALSE; <br>            } <br>        } <br>    } <br>} <br> <br>/**************************************************************************\ <br>* TakeClosestEmptyNode <br>* <br>* - Search for an empty node closest to supplied node position <br>* - Returns FALSE if couldn't find a node <br>* - Marks node as taken <br>* - not completely opimized - if when dilating the box, a side gets <br>*   clamped against the node array, this side will continue to be searched <br>* <br>\**************************************************************************/ <br> <br>static void <br>DilateBox( int *box, IPOINT3D *bounds ); <br> <br>BOOL <br>NODE_ARRAY::TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos ) <br>{ <br>    static int searchRadius = SS_MAX( numNodes.x, numNodes.y ) / 3; <br> <br>    // easy out <br>    if( GetNode(pos)-&gt;IsEmpty() ) { <br>        NodeVisited( pos ); <br>        *newPos = *pos; <br>        return TRUE; <br>    } <br> <br>    int box[NUM_DIRS] = {pos-&gt;x, pos-&gt;x, pos-&gt;y, pos-&gt;y, pos-&gt;z, pos-&gt;z}; <br>    int clip[NUM_DIRS] = {0}; <br> <br>    // do a random search on successively larger search boxes <br>    for( int i = 0; i &lt; searchRadius; i++ ) { <br>        // Increase box size <br>        DilateBox( box, &amp;numNodes ); <br>        // start looking in random 2D face of the box <br>        int dir = ss_iRand( NUM_DIRS ); <br>        for( int j = 0; j &lt; NUM_DIRS; j++, dir = (++dir == NUM_DIRS) ? 0 : dir ) { <br>            if( FindRandomEmptyNode2D( newPos, dir, box ) ) <br>                return TRUE; <br>        } <br>    } <br> <br>    // nothing nearby - grab a random one <br>    return FindRandomEmptyNode( newPos ); <br>} <br> <br>/**************************************************************************\ <br>* DilateBox <br>* <br>* - Increase box radius without exceeding bounds <br>* <br>\**************************************************************************/ <br> <br>static void <br>DilateBox( int *box, IPOINT3D *bounds ) <br>{ <br>    int *min = (int *) &amp;box[MINUS_X]; <br>    int *max = (int *) &amp;box[PLUS_X]; <br>    int *boundMax = (int *) bounds; <br>    // boundMin always 0 <br> <br>    for( int i = 0; i &lt; 3; i ++, min+=2, max+=2, boundMax++ ) { <br>        if( *min &gt; 0 ) <br>            (*min)--; <br>        if( *max &lt; (*boundMax - 1) ) <br>            (*max)++; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
