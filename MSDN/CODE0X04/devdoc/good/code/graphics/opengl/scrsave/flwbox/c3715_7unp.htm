<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GEOM.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3715"></a>GEOM.C</h2>
<pre><code>/**********************************Module**********************************\ <br>* <br>* geom.c <br>* <br>* 3D FlowerBox screen saver <br>* Geometry routines <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include "precomp.h" <br>#pragma hdrstop <br> <br>// Sphere radius <br>#define RADIUS 1 <br> <br>// Values to map a 2D point onto a 3D plane <br>// Base point and axes to map X and Y coordinates onto <br>typedef struct _PLANE_MAP <br>{ <br>    PT3 base, x_axis, y_axis; <br>} PLANE_MAP; <br> <br>// Data area used by the current geometry <br>// Base points and generated points <br>PT3 pts[MAXPTS], npts[MAXPTS]; <br>// Scaling factor for spherical projection <br>FLT vlen[MAXPTS]; <br>// Normals <br>PT3 normals[MAXPTS]; <br>// Vertex data indices <br>int index[MAXPTS*2]; <br>// Triangle strip sizes <br>int strip_size[MAXSIDES*MAXSUBDIV]; <br> <br>void InitCube(GEOMETRY *geom); <br>void InitTetra(GEOMETRY *geom); <br>void InitPyramids(GEOMETRY *geom); <br>void InitCylinder(GEOMETRY *geom); <br>void InitSpring(GEOMETRY *geom); <br> <br>GEOMETRY cube_geom = {InitCube}; <br>GEOMETRY tetra_geom = {InitTetra}; <br>GEOMETRY pyramids_geom = {InitPyramids}; <br>GEOMETRY cylinder_geom = {InitCylinder}; <br>GEOMETRY spring_geom = {InitSpring}; <br> <br>GEOMETRY *geom_table[] = <br>{ <br>    &amp;cube_geom, <br>    &amp;tetra_geom, <br>    &amp;pyramids_geom, <br>    &amp;cylinder_geom, <br>    &amp;spring_geom <br>}; <br> <br>extern BOOL bOgl11; <br>extern BOOL bCheckerOn; <br> <br>/******************************Public*Routine******************************\ <br>* <br>* InitVlen <br>* <br>* Precomputes scaling factor for spherical projection <br>* <br>\**************************************************************************/ <br> <br>void InitVlen(GEOMETRY *geom, int npts, PT3 *pts) <br>{ <br>    FLT d; <br>    FLT *vl; <br> <br>    vl = vlen; <br>    while (npts-- &gt; 0) <br>    { <br>        d = V3Len(pts); <br> <br>        // Don't allow really close points because this leads to <br>        // numeric instability and really large objects <br>        assert(d &gt; 0.01f); <br> <br>        // Geometries are created with size one, filling the area <br>        // from -.5 to .5.  This leads to distances generally less <br>        // than one, which leaves off half of the interesting morphing <br>        // effects due to the projection <br>        // Scaling up the scaling factor allows the values to <br>        // be both above and below one <br>        d *= geom-&gt;init_sf; <br>         <br>        assert(d &gt; 0.0001f); <br>         <br>        *vl++ = (RADIUS-d)/d; <br>         <br>#if 0 <br>        dprintf(("Distance is %f, vl %f\n", d, *(vl-1))); <br>#endif <br> <br>        pts++; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* MapToSide <br>* <br>* Takes x,y coordinates in the range 0-1 and maps them onto the given <br>* side plane for the current geometry <br>* <br>\**************************************************************************/ <br> <br>void MapToSide(PLANE_MAP *map, FLT x, FLT y, PT3 *pt) <br>{ <br>    pt-&gt;x = x*map-&gt;x_axis.x+y*map-&gt;y_axis.x+map-&gt;base.x; <br>    pt-&gt;y = x*map-&gt;x_axis.y+y*map-&gt;y_axis.y+map-&gt;base.y; <br>    pt-&gt;z = x*map-&gt;x_axis.z+y*map-&gt;y_axis.z+map-&gt;base.z; <br> <br>} <br> <br>void DrawWithVArrays (GEOMETRY *geom) <br>{ <br>    int side, ss, idc, k; <br>    unsigned int *idx; <br> <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) { <br>        geom-&gt;sides[side].dBuf = (GLuint *) LocalAlloc (LMEM_FIXED,  <br>                                                        sizeof (GLuint) *  <br>                                                        3 * MAXPTS * 2); <br>        k = 0; <br>        idx = geom-&gt;sides[side].strip_index; <br>        for (ss = 0; ss &lt; geom-&gt;sides[side].nstrips; ss++) { <br>            if (geom-&gt;sides[side].strip_size[ss] &lt; 3) continue; <br>            for (idc = 2; idc &lt; geom-&gt;sides[side].strip_size[ss]; idc++) { <br>                if (!(idc % 2)) { //even <br>                    geom-&gt;sides[side].dBuf[k++] = *(idx+idc-2);  <br>                    geom-&gt;sides[side].dBuf[k++] = *(idx+idc-1);  <br>                } else { <br>                    geom-&gt;sides[side].dBuf[k++] = *(idx+idc-1);  <br>                    geom-&gt;sides[side].dBuf[k++] = *(idx+idc-2);  <br>                } <br>                geom-&gt;sides[side].dBuf[k++] = *(idx+idc);  <br>            } <br>            idx += geom-&gt;sides[side].strip_size[ss]; <br>        } <br>        geom-&gt;sides[side].num_eles = k; <br>    } <br>    glNormalPointer (GL_FLOAT, sizeof (PT3),  <br>                     (GLfloat *)&amp;(geom-&gt;normals[0].x)); <br>    glVertexPointer (3, GL_FLOAT, sizeof (PT3),  <br>                     (GLfloat *)&amp;(geom-&gt;npts[0].x)); <br>    glEnableClientState (GL_VERTEX_ARRAY); <br>    glEnableClientState (GL_NORMAL_ARRAY); <br>     <br>    glDisableClientState (GL_COLOR_ARRAY); <br>    glDisableClientState (GL_INDEX_ARRAY); <br>    glDisableClientState (GL_EDGE_FLAG_ARRAY); <br>    glDisableClientState (GL_TEXTURE_COORD_ARRAY); <br>} <br>/******************************Public*Routine******************************\ <br>* <br>* InitCube <br>* <br>* Initialize the cube's geometry <br>* <br>\**************************************************************************/ <br> <br>#define CUBE_SIDES 6 <br> <br>PLANE_MAP cube_planes[CUBE_SIDES] = <br>{ <br>    -0.5f, -0.5f,  0.5f,  1.0f,  0.0f, 0.0f, 0.0f, 1.0f, 0.0f, <br>     0.5f, -0.5f, -0.5f, -1.0f,  0.0f, 0.0f, 0.0f, 1.0f, 0.0f, <br>     0.5f,  0.5f, -0.5f, -1.0f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f, <br>    -0.5f, -0.5f, -0.5f,  1.0f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f, <br>     0.5f, -0.5f, -0.5f,  0.0f,  1.0f, 0.0f, 0.0f, 0.0f, 1.0f, <br>    -0.5f,  0.5f, -0.5f,  0.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f <br>}; <br> <br>#define CUBE_IDX(side, x, y) ((side)*side_pts+(x)*(config.subdiv+1)+(y)) <br> <br>void InitCube(GEOMETRY *geom) <br>{ <br>    int side, x, y; <br>    PT3 *pt; <br>    unsigned int *sz, *idx; <br>    int side_pts; <br> <br>    side_pts = (config.subdiv+1)*(config.subdiv+1); <br>     <br>    geom-&gt;nsides = CUBE_SIDES; <br>    geom-&gt;pts = &amp;pts[0]; <br>    geom-&gt;npts = &amp;npts[0]; <br>    geom-&gt;normals = &amp;normals[0]; <br> <br>    geom-&gt;min_sf = -1.1f; <br>    geom-&gt;max_sf = 5.1f; <br>    geom-&gt;sf_inc = 0.05f; <br>    geom-&gt;init_sf = 2.0f; <br>     <br>    // Generate triangle strip data <br>    sz = &amp;strip_size[0]; <br>    idx = &amp;index[0]; <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) <br>    { <br>        geom-&gt;sides[side].nstrips = config.subdiv; <br>        geom-&gt;sides[side].strip_size = sz; <br>        geom-&gt;sides[side].strip_index = idx; <br>         <br>        for (x = 0; x &lt; config.subdiv; x++) <br>        { <br>            *sz++ = (config.subdiv+1)*2; <br> <br>            for (y = 0; y &lt; config.subdiv+1; y++) <br>            { <br>                *idx++ = CUBE_IDX(side, x, y); <br>                *idx++ = CUBE_IDX(side, x+1, y); <br>            } <br>        } <br>    } <br> <br>    assert(sz-strip_size &lt;= DIMA(strip_size)); <br>    assert(idx-index &lt;= DIMA(index)); <br> <br>    <br>    // Generate base vertices <br>    pt = geom-&gt;pts; <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) <br>    { <br>        for (x = 0; x &lt; config.subdiv+1; x++) <br>        { <br>            for (y = 0; y &lt; config.subdiv+1; y++) <br>            { <br>                MapToSide(&amp;cube_planes[side], <br>                          (FLT)x/config.subdiv, (FLT)y/config.subdiv, <br>                          pt); <br>                pt++; <br>            } <br>        } <br>    } <br> <br>    assert(pt-pts &lt;= DIMA(pts)); <br> <br>    geom-&gt;total_pts = geom-&gt;nsides*side_pts; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* InitTetra <br>* <br>* Initialize the tetrahedron's geometry <br>* <br>\**************************************************************************/ <br> <br>#define TETRA_SIDES 4 <br> <br>#define SQRT3 1.73205f <br>#define SQRT3_2 (SQRT3/2.0f) <br>#define SQRT3_3 (SQRT3/3.0f) <br>#define SQRT3_6 (SQRT3/6.0f) <br>#define SQRT3_12 (SQRT3/12.0f) <br> <br>#define TETRA_BASE (-SQRT3/8.0f) <br> <br>PLANE_MAP tetra_planes[TETRA_SIDES] = <br>{ <br>    -0.5f, TETRA_BASE, SQRT3_6, <br>    1.0f, 0.0f, 0.0f, 0.0f, SQRT3_2, -SQRT3_6, <br>     <br>    0.0f, TETRA_BASE, -SQRT3_3, <br>    -0.5f, 0.0f, SQRT3_2, 0.25f, SQRT3_2, SQRT3_12, <br>     <br>    0.5f, TETRA_BASE, SQRT3_6, <br>    -0.5f, 0.0f, -SQRT3_2, -0.25f, SQRT3_2, SQRT3_12, <br>     <br>    0.5f, TETRA_BASE, SQRT3_6, <br>    -1.0f, 0.0f, 0.0f, 0.0f, 0.0f, -SQRT3_2 <br>}; <br> <br>void InitTetra(GEOMETRY *geom) <br>{ <br>    int side, x, y; <br>    PT3 *pt; <br>    int *sz, *idx; <br>    int side_pts; <br>    int base_pt; <br>    int row_pts; <br>    FLT fx; <br> <br>    side_pts = (config.subdiv+2)*(config.subdiv+1)/2; <br>     <br>    geom-&gt;nsides = TETRA_SIDES; <br>    geom-&gt;pts = &amp;pts[0]; <br>    geom-&gt;npts = &amp;npts[0]; <br>    geom-&gt;normals = &amp;normals[0]; <br> <br>    geom-&gt;min_sf = -1.1f; <br>    geom-&gt;max_sf = 5.2f; <br>    geom-&gt;sf_inc = 0.05f; <br>    geom-&gt;init_sf = 3.75f; <br> <br>    // Generate triangle strip data <br>    sz = &amp;strip_size[0]; <br>    idx = &amp;index[0]; <br>    base_pt = 0; <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) <br>    { <br>        geom-&gt;sides[side].nstrips = config.subdiv; <br>        geom-&gt;sides[side].strip_size = sz; <br>        geom-&gt;sides[side].strip_index = idx; <br> <br>        for (x = 0; x &lt; config.subdiv; x++) <br>        { <br>            row_pts = config.subdiv-x+1; <br>            *sz++ = row_pts*2-1; <br> <br>            *idx++ = base_pt; <br>            for (y = 0; y &lt; row_pts-1; y++) <br>            { <br>                *idx++ = base_pt+row_pts+y; <br>                *idx++ = base_pt+1+y; <br>            } <br> <br>            base_pt += row_pts; <br>        } <br> <br>        base_pt++; <br>    } <br> <br>    assert(sz-strip_size &lt;= DIMA(strip_size)); <br>    assert(idx-index &lt;= DIMA(index)); <br> <br>    // Generate base vertices <br>    pt = geom-&gt;pts; <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) <br>    { <br>        for (x = 0; x &lt; config.subdiv+1; x++) <br>        { <br>            fx = (FLT)x/config.subdiv; <br>            for (y = 0; y &lt; config.subdiv-x+1; y++) <br>            { <br>                MapToSide(&amp;tetra_planes[side], <br>                          fx+(FLT)y/(config.subdiv*2), <br>                          (FLT)y/config.subdiv, <br>                          pt); <br>                pt++; <br>            } <br>        } <br>    } <br> <br>    assert(pt-pts &lt;= DIMA(pts)); <br> <br>    geom-&gt;total_pts = geom-&gt;nsides*side_pts; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* InitPyramids <br>* <br>* Initializes double pyramid geometry <br>* <br>\**************************************************************************/ <br> <br>#define PYRAMIDS_SIDES 8 <br> <br>PLANE_MAP pyramids_planes[PYRAMIDS_SIDES] = <br>{ <br>    -0.5f, 0.0f,  0.5f,  1.0f, 0.0f,  0.0f,  0.0f,  0.5f, -0.5f, <br>     0.5f, 0.0f,  0.5f, -1.0f, 0.0f,  0.0f,  0.0f, -0.5f, -0.5f, <br>     0.5f, 0.0f,  0.5f,  0.0f, 0.0f, -1.0f, -0.5f,  0.5f,  0.0f, <br>     0.5f, 0.0f, -0.5f,  0.0f, 0.0f,  1.0f, -0.5f, -0.5f,  0.0f, <br>     0.5f, 0.0f, -0.5f, -1.0f, 0.0f,  0.0f,  0.0f,  0.5f,  0.5f, <br>    -0.5f, 0.0f, -0.5f,  1.0f, 0.0f,  0.0f,  0.0f, -0.5f,  0.5f, <br>    -0.5f, 0.0f, -0.5f,  0.0f, 0.0f,  1.0f,  0.5f,  0.5f,  0.0f, <br>    -0.5f, 0.0f,  0.5f,  0.0f, 0.0f, -1.0f,  0.5f, -0.5f,  0.0f <br>}; <br> <br>void InitPyramids(GEOMETRY *geom) <br>{ <br>    int side, x, y; <br>    PT3 *pt; <br>    int *sz, *idx; <br>    int side_pts; <br>    int base_pt; <br>    int row_pts; <br>    FLT fx; <br> <br>    side_pts = (config.subdiv+2)*(config.subdiv+1)/2; <br>     <br>    geom-&gt;nsides = PYRAMIDS_SIDES; <br>    geom-&gt;pts = &amp;pts[0]; <br>    geom-&gt;npts = &amp;npts[0]; <br>    geom-&gt;normals = &amp;normals[0]; <br> <br>    geom-&gt;min_sf = -1.1f; <br>    geom-&gt;max_sf = 5.2f; <br>    geom-&gt;sf_inc = 0.05f; <br>    geom-&gt;init_sf = 3.0f; <br> <br>    // Generate triangle strip data <br>    sz = &amp;strip_size[0]; <br>    idx = &amp;index[0]; <br>    base_pt = 0; <br> <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) { <br>        geom-&gt;sides[side].nstrips = config.subdiv; <br>        geom-&gt;sides[side].strip_size = sz; <br>        geom-&gt;sides[side].strip_index = idx; <br>             <br>        for (x = 0; x &lt; config.subdiv; x++) { <br>            row_pts = config.subdiv-x+1; <br>            *sz++ = row_pts*2-1; <br> <br>            *idx++ = base_pt; <br>            for (y = 0; y &lt; row_pts-1; y++) { <br>                *idx++ = base_pt+row_pts+y; <br>                *idx++ = base_pt+1+y; <br>            } <br> <br>            base_pt += row_pts; <br>        } <br>             <br>        base_pt++; <br>    } <br> <br>    assert(sz-strip_size &lt;= DIMA(strip_size)); <br>    assert(idx-index &lt;= DIMA(index)); <br> <br>    // Generate base vertices <br>    pt = geom-&gt;pts; <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) <br>    { <br>        for (x = 0; x &lt; config.subdiv+1; x++) <br>        { <br>            fx = (FLT)x/config.subdiv; <br>            for (y = 0; y &lt; config.subdiv-x+1; y++) <br>            { <br>                MapToSide(&amp;pyramids_planes[side], <br>                          fx+(FLT)y/(config.subdiv*2), <br>                          (FLT)y/config.subdiv, <br>                          pt); <br>                pt++; <br>            } <br>        } <br>    } <br> <br>    assert(pt-pts &lt;= DIMA(pts)); <br> <br>    geom-&gt;total_pts = geom-&gt;nsides*side_pts; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* InitCylinder <br>* <br>* Initializes the cylinder geometry <br>* <br>\**************************************************************************/ <br> <br>void InitCylinder(GEOMETRY *geom) <br>{ <br>    int side, x, y; <br>    PT3 *pt; <br>    int *sz, *idx; <br>    int base_pt; <br>    int row_pts; <br>    FLT fx, fz; <br>    double ang; <br> <br>    geom-&gt;nsides = 1; <br>    geom-&gt;pts = &amp;pts[0]; <br>    geom-&gt;npts = &amp;npts[0]; <br>    geom-&gt;normals = &amp;normals[0]; <br> <br>    geom-&gt;min_sf = -2.5f; <br>    geom-&gt;max_sf = 8.5f; <br>    geom-&gt;sf_inc = 0.05f; <br>    geom-&gt;init_sf = 2.1f; <br> <br>    // Generate triangle strip data <br>    // If version 1.1 then allocate the index buffer for glDrawElements <br>    sz = &amp;strip_size[0]; <br>    idx = &amp;index[0]; <br>    side = 0; <br>    geom-&gt;sides[side].nstrips = config.subdiv; <br>    geom-&gt;sides[side].strip_size = sz; <br>    geom-&gt;sides[side].strip_index = idx; <br>     <br>    row_pts = config.subdiv+1; <br>    base_pt = 0; <br>    for (x = 0; x &lt; config.subdiv; x++) { <br>        *sz++ = row_pts*2; <br>         <br>        for (y = 0; y &lt; row_pts; y++) { <br>            // Wrap around at the edge so the cylinder normals <br>            // are properly averaged <br>            if (x == config.subdiv-1) { <br>                *idx++ = y; <br>            } <br>            else { <br>                *idx++ = base_pt+row_pts+y; <br>            } <br>            *idx++ = base_pt+y; <br>        } <br> <br>        base_pt += row_pts; <br>    } <br>     <br>    assert(sz-strip_size &lt;= DIMA(strip_size)); <br>    assert(idx-index &lt;= DIMA(index)); <br> <br>    // Generate base vertices <br>    pt = geom-&gt;pts; <br>    ang = 0; <br>    for (x = 0; x &lt; config.subdiv; x++) <br>    { <br>        fx = (FLT)cos(ang)*0.5f; <br>        fz = (FLT)sin(ang)*0.5f; <br>        for (y = 0; y &lt; config.subdiv+1; y++) <br>        { <br>            pt-&gt;x = fx; <br>            pt-&gt;y = (FLT)y/config.subdiv-0.5f; <br>            pt-&gt;z = fz; <br>            pt++; <br>        } <br>        ang += (2*PI)/config.subdiv; <br>    } <br> <br>    assert(pt-pts &lt;= DIMA(pts)); <br> <br>    geom-&gt;total_pts = geom-&gt;nsides*(config.subdiv+1)*config.subdiv; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* InitSpring <br>* <br>* Initializes the spring geometry <br>* <br>\**************************************************************************/ <br> <br>#define SPRING_RADIUS 0.1f <br>#define SPRING_CENTER (0.5f-SPRING_RADIUS) <br> <br>void InitSpring(GEOMETRY *geom) <br>{ <br>    int side, x, y; <br>    PT3 *pt; <br>    int *sz, *idx; <br>    double ang_center, ang_surf; <br>    FLT cs, sn; <br>    FLT rad; <br>    PLANE_MAP plane; <br>    int spin_pts; <br>    int row_pts; <br> <br>    geom-&gt;nsides = 1; <br>    geom-&gt;pts = &amp;pts[0]; <br>    geom-&gt;npts = &amp;npts[0]; <br>    geom-&gt;normals = &amp;normals[0]; <br> <br>    geom-&gt;min_sf = -2.2f; <br>    geom-&gt;max_sf = 0.2f; <br>    geom-&gt;sf_inc = 0.05f; <br>    geom-&gt;init_sf = 1.0f; <br> <br>    // Generate triangle strip data <br>    // If version 1.1 then allocate the index buffer for glDrawElements <br>    sz = &amp;strip_size[0]; <br>    idx = &amp;index[0]; <br>    side = 0; <br>    geom-&gt;sides[side].nstrips = config.subdiv; <br>    geom-&gt;sides[side].strip_size = sz; <br>    geom-&gt;sides[side].strip_index = idx; <br>     <br>    row_pts = config.subdiv; <br>    spin_pts = 4*config.subdiv+1; <br>    for (x = 0; x &lt; config.subdiv; x++) { <br>        *sz++ = spin_pts*2; <br> <br>        for (y = 0; y &lt; spin_pts; y++) { <br>            *idx++ = x+row_pts*y; <br>            // Wrap around at the edge so the cylindrical surface <br>            // of the tube is seamless.  Without this the normal <br>            // averaging would be incorrect and a seam would be visible <br>            if (x == config.subdiv-1) { <br>                *idx++ = row_pts*y; <br>            } <br>            else { <br>                *idx++ = x+row_pts*y+1; <br>            } <br>        } <br>    } <br>     <br>    assert(sz-strip_size &lt;= DIMA(strip_size)); <br>    assert(idx-index &lt;= DIMA(index)); <br> <br>    // Generate base vertices <br>    pt = geom-&gt;pts; <br>    ang_center = 0; <br>    plane.y_axis.x = 0.0f; <br>    plane.y_axis.y = SPRING_RADIUS; <br>    plane.y_axis.z = 0.0f; <br>    plane.x_axis.y = 0.0f; <br>    for (x = 0; x &lt; spin_pts; x++) <br>    { <br>        cs = (FLT)cos(ang_center); <br>        sn = (FLT)sin(ang_center); <br>        rad = 0.5f-(FLT)x/(spin_pts-1)*(SPRING_CENTER/2); <br>        plane.base.x = cs*rad; <br>        plane.base.y = -0.5f+(FLT)x/(spin_pts-1); <br>        plane.base.z = sn*rad; <br>        plane.x_axis.x = cs*SPRING_RADIUS; <br>        plane.x_axis.z = sn*SPRING_RADIUS; <br> <br>        ang_surf = 0; <br>        for (y = 0; y &lt; config.subdiv; y++) <br>        { <br>            MapToSide(&amp;plane, <br>                      (FLT)cos(ang_surf), (FLT)sin(ang_surf), <br>                      pt); <br>            pt++; <br>            ang_surf += (2*PI)/config.subdiv; <br>        } <br>         <br>        ang_center += (4*PI)/(spin_pts-1); <br>    } <br> <br>    assert(pt-pts &lt;= DIMA(pts)); <br> <br>    geom-&gt;total_pts = geom-&gt;nsides*spin_pts*config.subdiv; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* DrawGeom <br>* <br>* Draw the current geometry <br>* <br>\**************************************************************************/ <br> <br>void DrawGeom(GEOMETRY *geom) <br>{ <br>    int side, strip, k; <br>    int *idx, idc, idxv; <br> <br>    if (config.smooth_colors) <br>    { <br>        glShadeModel(GL_SMOOTH); <br>    } <br>    else <br>    { <br>        glShadeModel(GL_FLAT); <br>    } <br> <br>    if (config.color_pick == ID_COL_SINGLE) <br>    { <br>        glMaterialfv(config.two_sided, GL_DIFFUSE, solid_cols); <br>    } <br> <br>    if (!(bOgl11 &amp;&amp; !bCheckerOn)) { <br>        for (side = 0; side &lt; geom-&gt;nsides; side++) { <br>            if (config.color_pick == ID_COL_PER_SIDE) { <br>                glMaterialfv(config.two_sided, GL_DIFFUSE, side_cols[side]); <br>            } <br> <br>            idx = geom-&gt;sides[side].strip_index; <br>            for (strip = 0; strip &lt; geom-&gt;sides[side].nstrips; strip++) { <br>                glBegin(GL_TRIANGLE_STRIP); <br> <br>                for (idc = 0; idc &lt; geom-&gt;sides[side].strip_size[strip];  <br>                     idc++) { <br>                    idxv = *idx++; <br> <br>                    assert(idxv &gt;=0 &amp;&amp; idxv &lt; geom-&gt;total_pts); <br> <br>                    if (config.color_pick == ID_COL_CHECKER) { <br>                        if (config.triangle_colors) { <br>                            glMaterialfv(config.two_sided, GL_DIFFUSE, <br>                                         checker_cols[side][(idc+1)/2+strip &amp; <br>                                                           1]); <br>                        } <br>                        else { <br>                            glMaterialfv(config.two_sided, GL_DIFFUSE, <br>                                         checker_cols[side][idc/2+strip &amp; 1]); <br>                        } <br>                    } <br>                 <br>                    glNormal3fv((GLfloat *)&amp;geom-&gt;normals[idxv]); <br>                    glVertex3fv((GLfloat *)&amp;geom-&gt;npts[idxv]); <br>                } <br> <br>                glEnd(); <br>            } <br>        } <br>    } else { <br>        k = 0; <br>        for (side = 0; side &lt; geom-&gt;nsides; side++) { <br>            if (config.color_pick == ID_COL_PER_SIDE) <br>                glMaterialfv(config.two_sided, GL_DIFFUSE, side_cols[side]); <br> <br>            glDrawElements (GL_TRIANGLES, geom-&gt;sides[side].num_eles,  <br>                            GL_UNSIGNED_INT, &amp;(geom-&gt;sides[side].dBuf[0])); <br>            k += geom-&gt;sides[side].num_eles; <br>        } <br>    }     <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ComputeAveragedNormals <br>* <br>* Compute face-averaged normals for each vertex <br>* <br>\**************************************************************************/ <br> <br>void ComputeAveragedNormals(GEOMETRY *geom) <br>{ <br>    int side, strip; <br>    int *sz; <br>    int *idx, idx1, idx2, idx3; <br>    int tc, idc; <br>    PT3 v1, v2, n1; <br>     <br>    memset(geom-&gt;normals, 0, sizeof(PT3)*geom-&gt;total_pts); <br>     <br>    for (side = 0; side &lt; geom-&gt;nsides; side++) <br>    { <br>        idx = geom-&gt;sides[side].strip_index; <br>        sz = geom-&gt;sides[side].strip_size; <br>        for (strip = 0; strip &lt; geom-&gt;sides[side].nstrips; strip++) <br>        { <br>            idx1 = *idx++; <br>            idx2 = *idx++; <br> <br>            assert(idx1 &gt;= 0 &amp;&amp; idx1 &lt; geom-&gt;total_pts &amp;&amp; <br>                   idx2 &gt;= 0 &amp;&amp; idx2 &lt; geom-&gt;total_pts); <br>             <br>            tc = (*sz++)-2; <br>            for (idc = 0; idc &lt; tc; idc++) <br>            { <br>                idx3 = *idx++; <br> <br>                assert(idx3 &gt;= 0 &amp;&amp; idx3 &lt; geom-&gt;total_pts); <br>                 <br>                V3Sub(&amp;geom-&gt;npts[idx3], &amp;geom-&gt;npts[idx1], &amp;v1); <br>                V3Sub(&amp;geom-&gt;npts[idx2], &amp;geom-&gt;npts[idx1], &amp;v2); <br>                V3Cross(&amp;v1, &amp;v2, &amp;n1); <br>                // Triangle strip ordering causes half of the triangles <br>                // to be oriented oppositely from the others <br>                // Those triangles need to have their normals flipped <br>                // so the whole triangle strip has consistent normals <br>                if ((idc &amp; 1) == 0) <br>                { <br>                    n1.x = -n1.x; <br>                    n1.y = -n1.y; <br>                    n1.z = -n1.z; <br>                } <br>                 <br>                V3Add(&amp;geom-&gt;normals[idx1], &amp;n1, &amp;geom-&gt;normals[idx1]); <br>                V3Add(&amp;geom-&gt;normals[idx2], &amp;n1, &amp;geom-&gt;normals[idx2]); <br>                V3Add(&amp;geom-&gt;normals[idx3], &amp;n1, &amp;geom-&gt;normals[idx3]); <br> <br>                idx1 = idx2; <br>                idx2 = idx3; <br>            } <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* UpdatePts <br>* <br>* Project the point array through a sphere according to the given scale factor <br>* <br>\**************************************************************************/ <br> <br>void UpdatePts(GEOMETRY *geom, FLT sf) <br>{ <br>    int pt; <br>    FLT f, *vl; <br>    PT3 *v; <br>    PT3 *p; <br> <br>    vl = vlen; <br>    p = &amp;geom-&gt;pts[0]; <br>    v = &amp;geom-&gt;npts[0]; <br>    for (pt = 0; pt &lt; geom-&gt;total_pts; pt++) <br>    { <br>        f = (*vl++)*sf+1; <br>        v-&gt;x = p-&gt;x*f; <br>        v-&gt;y = p-&gt;y*f; <br>        v-&gt;z = p-&gt;z*f; <br>        p++; <br>        v++; <br>    } <br> <br>    ComputeAveragedNormals(geom); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
