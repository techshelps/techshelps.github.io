<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSMAZE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3735"></a>SSMAZE.C</h2>
<pre><code>#include "pch.c" <br>#pragma hdrstop <br>#include "maze_std.h" <br> <br>#define VIEW_ANG 90 <br> <br>float maze_height; <br>double view_rot; <br>int maze_walls_list; <br> <br>extern TEX_ENV gTexEnv[]; <br> <br>typedef struct _FxRay2 <br>{ <br>    FxPt2 p; <br>    FxVec2 d; <br>} FxRay2; <br> <br>BYTE maze_desc[MAZE_ARRAY][MAZE_ARRAY]; <br> <br>Cell maze_cells[MAZE_GRID][MAZE_GRID]; <br>#define CellAt(x, y) (&amp;maze_cells[y][x]) <br> <br>typedef struct _Wall <br>{ <br>    FxPt2 f, t; <br>    int col; <br>    TEX_ENV *pTexEnv;  // points to texture environment <br>} Wall; <br>     <br>FxPt2 fmaze_pts[N_MAZE_PTS]; <br>Wall maze[N_MAZE_WALLS]; <br>int nwalls; <br> <br>typedef struct _WallHit <br>{ <br>    Cell *cell; <br>    int cx, cy; <br>    WallFlags flag; <br>} WallHit; <br> <br>void AddObject(Object *obj, Cell *cell) <br>{ <br>    obj-&gt;next = cell-&gt;contents; <br>    cell-&gt;contents = obj; <br>    obj-&gt;cell = cell; <br>} <br> <br>void PlaceObject(Object *obj, FxValue x, FxValue y) <br>{ <br>    Cell *cell; <br>    int cx, cy; <br> <br>    cx = MfxToCell(x); <br>    cy = MfxToCell(y); <br>    cell = CellAt(cx, cy); <br>     <br>    obj-&gt;p.x = x; <br>    obj-&gt;p.y = y; <br> <br>    AddObject(obj, cell); <br>} <br> <br>void RemoveObject(Object *obj) <br>{ <br>    Object *o, *op; <br>         <br>    if (obj-&gt;cell != NULL) <br>    { <br>        op = NULL; <br>        for (o = obj-&gt;cell-&gt;contents; o != obj; o = o-&gt;next) <br>        { <br>            op = o; <br>        } <br> <br>        if (op == NULL) <br>        { <br>            obj-&gt;cell-&gt;contents = obj-&gt;next; <br>        } <br>        else <br>        { <br>            op-&gt;next = obj-&gt;next; <br>        } <br> <br>        obj-&gt;cell = NULL; <br>    } <br>} <br> <br>void MoveObject(Object *obj, FxValue x, FxValue y) <br>{ <br>    int cx, cy; <br>    Cell *cell; <br>     <br>    obj-&gt;p.x = x; <br>    obj-&gt;p.y = y; <br>     <br>    cx = MfxToCell(x); <br>    cy = MfxToCell(y); <br>    cell = CellAt(cx, cy); <br>     <br>    if (cell == obj-&gt;cell) <br>    { <br>        return; <br>    } <br>     <br>    RemoveObject(obj); <br>    AddObject(obj, cell); <br>} <br> <br>Object start_obj, end_obj; <br> <br>BOOL InitMaze(IntPt2 *start_cell, MazeGoal *goals, int *ngoals) <br>{ <br>    int i, j, n; <br>    FxPt2 p; <br> <br>    if (!GenerateMaze(MAZE_GRID, MAZE_GRID, &amp;maze_desc[0][0])) <br>    { <br>        return FALSE; <br>    } <br>     <br>    p.y = FxVal(0); <br>    n = 0; <br>    for (i = 0; i &lt; MAZE_ARRAY; i++) <br>    { <br>        p.x = FxVal(0); <br>        for (j = 0; j &lt; MAZE_ARRAY; j++) <br>        { <br>            fmaze_pts[n].x = p.x; <br>            fmaze_pts[n++].y = p.y; <br>            p.x += FMAZE_CELL_SIZE; <br>        } <br>        p.y += FMAZE_CELL_SIZE; <br>    } <br> <br>    nwalls = 0; <br>    for (i = 0; i &lt; MAZE_ARRAY; i++) <br>    { <br>        for (j = 0; j &lt; MAZE_ARRAY; j++) <br>        { <br>            if (i &lt; MAZE_ARRAY-1 &amp;&amp; j &lt; MAZE_ARRAY-1) <br>            { <br>                maze_cells[i][j].can_see = 0; <br>                maze_cells[i][j].contents = NULL; <br>                memset(maze_cells[i][j].walls, 0, 4*sizeof(Wall *)); <br>            } <br>                 <br>            if (maze_desc[i][j] &amp; MAZE_WALL_HORZ) <br>            { <br>                if (j == MAZE_ARRAY-1) <br>                { <br>                    printf("MAZE_WALL_HORZ at right edge\n"); <br>                    return FALSE; <br>                } <br>                 <br>                maze[nwalls].f = fmaze_pts[i*MAZE_ARRAY+j]; <br>                maze[nwalls].t = fmaze_pts[i*MAZE_ARRAY+j+1]; <br>                maze[nwalls].col = (i+j+1) &amp; 1; <br>                maze[nwalls].pTexEnv = &amp;gTexEnv[TEX_WALL]; <br>                 <br>                if (i &gt; 0) <br>                { <br>                    maze_cells[i-1][j].can_see |= MAZE_WALL_DOWN; <br>                    maze_cells[i-1][j].walls[WIDX_DOWN] = &amp;maze[nwalls]; <br>                } <br>                if (i &lt; MAZE_ARRAY-1) <br>                { <br>                    maze_cells[i][j].can_see |= MAZE_WALL_UP; <br>                    maze_cells[i][j].walls[WIDX_UP] = &amp;maze[nwalls]; <br>                } <br>                 <br>                nwalls++; <br>            } <br>             <br>            if (maze_desc[i][j] &amp; MAZE_WALL_VERT) <br>            { <br>                if (i == MAZE_ARRAY-1) <br>                { <br>                    printf("MAZE_WALL_VERT at bottom edge\n"); <br>                    return FALSE; <br>                } <br> <br>                maze[nwalls].f = fmaze_pts[i*MAZE_ARRAY+j]; <br>                maze[nwalls].t = fmaze_pts[(i+1)*MAZE_ARRAY+j]; <br>                maze[nwalls].col = (i+j) &amp; 1; <br>                maze[nwalls].pTexEnv = &amp;gTexEnv[TEX_WALL]; <br>             <br>                if (j &gt; 0) <br>                { <br>                    maze_cells[i][j-1].can_see |= MAZE_WALL_RIGHT; <br>                    maze_cells[i][j-1].walls[WIDX_RIGHT] = &amp;maze[nwalls]; <br>                } <br>                if (j &lt; MAZE_ARRAY-1) <br>                { <br>                    maze_cells[i][j].can_see |= MAZE_WALL_LEFT; <br>                    maze_cells[i][j].walls[WIDX_LEFT] = &amp;maze[nwalls]; <br>                } <br>                 <br>                nwalls++; <br>            } <br>        } <br>    } <br> <br>    // Always place the start on the left and <br>    // the end on the right.  This guarantees that there'll be <br>    // some traversing of the maze for the solution <br>    // Since the maze generator guarantees that the entire maze is <br>    // fully connected, the solution can always be found <br>     <br>    start_cell-&gt;x = 0; <br>    start_cell-&gt;y = rand() % MAZE_GRID; <br> <br>    *ngoals = 1; <br>    goals[0].clx = MAZE_GRID-1; <br>    goals[0].cly = rand() % MAZE_GRID; <br>     <br>    start_obj.w = FMAZE_CELL_SIZE/6; <br>    start_obj.h = FxFltVal(.166); <br>    start_obj.z = FxFltVal(.5); <br>    start_obj.col = 12; <br>    start_obj.draw_style = DRAW_POLYGON; <br>    start_obj.pTexEnv = &amp;gTexEnv[ TEX_START ]; <br>    start_obj.ang = FaDeg(0); <br>    PlaceObject(&amp;start_obj, <br>                CellToMfx(start_cell-&gt;x)+FMAZE_CELL_SIZE/2, <br>                CellToMfx(start_cell-&gt;y)+FMAZE_CELL_SIZE/2); <br>     <br>    end_obj.w = FMAZE_CELL_SIZE/6; <br>    end_obj.h = FxFltVal(.166); <br>    end_obj.z = FxFltVal(.5); <br>    end_obj.col = 10; <br>    end_obj.draw_style = DRAW_POLYGON; <br>    end_obj.pTexEnv = &amp;gTexEnv[ TEX_END ]; <br>    end_obj.ang = FaDeg(0); <br>    PlaceObject(&amp;end_obj, <br>                CellToMfx(goals[0].clx)+FMAZE_CELL_SIZE/2, <br>                CellToMfx(goals[0].cly)+FMAZE_CELL_SIZE/2); <br> <br>    // Reset some of the walls' textures to the OpenGL cover <br>    // for some variety <br>    i = (rand() % 5)+1; <br>    while (i-- &gt; 0) <br>    { <br>        j = rand() % nwalls; <br>        maze[j].pTexEnv = &amp;gTexEnv[TEX_COVER]; <br>    } <br> <br>    return TRUE; <br>} <br> <br>#define PO_WALL 0 <br>#define PO_PARTIAL 1 <br>#define PO_COUNT 2 <br> <br>typedef struct _PaintWall <br>{ <br>    Wall *wall; <br>} PaintWall; <br> <br>typedef struct _PaintPartial <br>{ <br>    Object *obj; <br>} PaintPartial; <br> <br>typedef struct _PaintObject <br>{ <br>    int type; <br>    union <br>    { <br>        PaintWall wall; <br>        PaintPartial partial; <br>    } u; <br>    FxValue depth; <br>    struct _PaintObject *closer; <br>} PaintObject; <br> <br>#define N_PAINT_OBJECTS (4*MAZE_CELLS) <br>PaintObject paint[N_PAINT_OBJECTS]; <br>int npaint; <br> <br>void WallCoords(int x, int y, WallFlags flag, FxPt2 *f, FxPt2 *t) <br>{ <br>    t-&gt;x = f-&gt;x = CellToMfx(x); <br>    t-&gt;y = f-&gt;y = CellToMfx(y); <br>    if (flag &amp; MAZE_WALL_LEFT) <br>    { <br>        t-&gt;y += FMAZE_CELL_SIZE; <br>    } <br>    else if (flag &amp; MAZE_WALL_UP) <br>    { <br>        t-&gt;x += FMAZE_CELL_SIZE; <br>    } <br>    else if (flag &amp; MAZE_WALL_RIGHT) <br>    { <br>        f-&gt;x += FMAZE_CELL_SIZE; <br>        t-&gt;x = f-&gt;x; <br>        t-&gt;y += FMAZE_CELL_SIZE; <br>    } <br>    else if (flag &amp; MAZE_WALL_DOWN) <br>    { <br>        f-&gt;y += FMAZE_CELL_SIZE; <br>        t-&gt;y = f-&gt;y; <br>        t-&gt;x += FMAZE_CELL_SIZE; <br>    } <br>} <br> <br>void AddPaintWall(Cell *cell, int widx) <br>{ <br>    PaintWall *pw; <br>     <br>    if (npaint == N_PAINT_OBJECTS) <br>    { <br>        printf("Paint list full\n"); <br>        return; <br>    } <br>     <br>    pw = &amp;paint[npaint].u.wall; <br>    paint[npaint].type = PO_WALL; <br>    npaint++; <br> <br>    pw-&gt;wall = cell-&gt;walls[widx]; <br>} <br> <br>void AddPaintWalls(Cell *cell, WallFlags wf) <br>{ <br>    if (wf &amp; MAZE_WALL_LEFT) <br>    { <br>        AddPaintWall(cell, WIDX_LEFT); <br>    } <br>    if (wf &amp; MAZE_WALL_RIGHT) <br>    { <br>        AddPaintWall(cell, WIDX_RIGHT); <br>    } <br>    if (wf &amp; MAZE_WALL_DOWN) <br>    { <br>        AddPaintWall(cell, WIDX_DOWN); <br>    } <br>    if (wf &amp; MAZE_WALL_UP) <br>    { <br>        AddPaintWall(cell, WIDX_UP); <br>    } <br>} <br> <br>void AddPaintPartial(Object *obj) <br>{ <br>    PaintPartial *pp; <br>     <br>    if (npaint == N_PAINT_OBJECTS) <br>    { <br>        printf("Paint list full\n"); <br>        return; <br>    } <br>     <br>    pp = &amp;paint[npaint].u.partial; <br>    paint[npaint].type = PO_PARTIAL; <br>    npaint++; <br> <br>    pp-&gt;obj = obj; <br>} <br> <br>void AddCell(int x, int y, WallFlags wf) <br>{ <br>    Cell *cell; <br>    Object *obj; <br> <br>    wf |= MAZE_CONTENTS; <br>    cell = CellAt(x, y); <br>    if ((cell-&gt;unseen &amp; wf) == 0) <br>    { <br>        return; <br>    } <br>     <br>    AddPaintWalls(cell, (WallFlags)(wf &amp; cell-&gt;unseen)); <br> <br>    if (cell-&gt;unseen &amp; MAZE_CONTENTS) <br>    { <br>        for (obj = cell-&gt;contents; obj; obj = obj-&gt;next) <br>        { <br>            AddPaintPartial(obj); <br>        } <br>    } <br>     <br>    cell-&gt;unseen &amp;= ~wf; <br>} <br> <br>void TraceCells(FxPt2 *ip, FxVec2 *dp, WallHit *hit) <br>{ <br>    int cx, cy; <br>    int sgnx, sgny; <br>    FxVec2 dg, dst; <br>    FxPt2 fp, g; <br>    WallFlags xwf, ywf, iwf, xpf, ypf; <br>    FxValue sx, sy; <br> <br>    cx = MfxToCell(ip-&gt;x); <br>    cy = MfxToCell(ip-&gt;y); <br> <br>    fp = *ip; <br>     <br>#ifdef TRACEDEB <br>    printf("pt %ld,%ld dp %ld,%ld\n", fp.x, fp.y, dp.x, dp.y); <br>#endif <br>     <br>    if (dp-&gt;x &lt; 0) <br>    { <br>        g.x = CellToMfx(cx)-FX_MIN_VALUE; <br>        dg.x = -FMAZE_CELL_SIZE; <br>        sgnx = -1; <br>        xwf = MAZE_WALL_LEFT; <br>        xpf = MAZE_WALL_LEFT_PARTIAL; <br>    } <br>    else <br>    { <br>        g.x = CellToMfx(cx+1); <br>        dg.x = FMAZE_CELL_SIZE; <br>        sgnx = 1; <br>        xwf = MAZE_WALL_RIGHT; <br>        xpf = MAZE_WALL_RIGHT_PARTIAL; <br>        if (dp-&gt;x == 0) <br>        { <br>            xwf |= MAZE_WALL_LEFT; <br>            xpf |= MAZE_WALL_LEFT_PARTIAL; <br>        } <br>    } <br>    if (dp-&gt;y &lt; 0) <br>    { <br>        g.y = CellToMfx(cy)-FX_MIN_VALUE; <br>        dg.y = -FMAZE_CELL_SIZE; <br>        sgny = -1; <br>        ywf = MAZE_WALL_UP; <br>        ypf = MAZE_WALL_UP_PARTIAL; <br>    } <br>    else <br>    { <br>        g.y = CellToMfx(cy+1); <br>        dg.y = FMAZE_CELL_SIZE; <br>        sgny = 1; <br>        ywf = MAZE_WALL_DOWN; <br>        ypf = MAZE_WALL_DOWN_PARTIAL; <br>        if (dp-&gt;y == 0) <br>        { <br>            ywf |= MAZE_WALL_UP; <br>            ypf |= MAZE_WALL_UP_PARTIAL; <br>        } <br>    } <br> <br>    for (;;) <br>    { <br>        AddCell(cx, cy, (WallFlags)(xwf | ywf)); <br> <br>        dst.x = (g.x-fp.x)*sgnx; <br>        dst.y = (g.y-fp.y)*sgny; <br>        sx = FxMul(dst.x, dp-&gt;y); <br>        if (sx &lt; 0) <br>        { <br>            sx = -sx; <br>        } <br>        sy = FxMul(dst.y, dp-&gt;x); <br>        if (sy &lt; 0) <br>        { <br>            sy = -sy; <br>        } <br>         <br>#ifdef TRACEDEB <br>        printf("dx %ld, sx %ld, dy %ld, sy %ld\n", dst.x, sx, dst.y, sy); <br>#endif <br>         <br>        if (sx &lt;= sy) <br>        { <br>            if ((maze_cells[cy][cx].can_see &amp; xwf) &amp;&amp; <br>                (maze_cells[cy][cx].can_see &amp; xpf) == 0) <br>            { <br>                iwf = xwf; <br>                break; <br>            } <br>             <br>            fp.x = g.x; <br>            fp.y += FxDiv(sx, dp-&gt;x)*sgnx*sgny; <br>            if (fp.y == g.y) <br>            { <br>                if ((maze_cells[cy][cx].can_see &amp; ywf) &amp;&amp; <br>                    (maze_cells[cy][cx].can_see &amp; ypf) == 0) <br>                { <br>                    iwf = ywf; <br>                    break; <br>                } <br>                cy += sgny; <br>                g.y += dg.y; <br>            } <br>            cx += sgnx; <br>            g.x += dg.x; <br>        } <br>        else <br>        { <br>            if ((maze_cells[cy][cx].can_see &amp; ywf) &amp;&amp; <br>                (maze_cells[cy][cx].can_see &amp; ypf) == 0) <br>            { <br>                iwf = ywf; <br>                break; <br>            } <br> <br>            fp.y = g.y; <br>            fp.x += FxDiv(sy, dp-&gt;y)*sgnx*sgny; <br>            if (fp.x == g.x) <br>            { <br>                if ((maze_cells[cy][cx].can_see &amp; xwf) &amp;&amp; <br>                    (maze_cells[cy][cx].can_see &amp; xpf) == 0) <br>                { <br>                    iwf = xwf; <br>                    break; <br>                } <br>                cx += sgnx; <br>                g.x += dg.x; <br>            } <br>            cy += sgny; <br>            g.y += dg.y; <br>        } <br>    } <br>    hit-&gt;cell = CellAt(cx, cy); <br>    hit-&gt;cx = cx; <br>    hit-&gt;cy = cy; <br>    hit-&gt;flag = iwf; <br>} <br> <br>void TraceView(MazeView *vw) <br>{ <br>    FaAngle acc; <br>    FxVec2 vcc; <br>    WallHit hit; <br>    int rc; <br> <br>    acc = FaAdd(vw-&gt;ang, FaDeg(VIEW_ANG)/2); <br>     <br>    for (rc = 0; rc &lt; VIEW_ANG; rc++) <br>    { <br>        vcc.x = FaCos(acc); <br>        vcc.y = FaSin(acc); <br>         <br>        TraceCells(&amp;vw-&gt;pos, &amp;vcc, &amp;hit); <br> <br>        acc = FaAdd(acc, -FaDeg(1)); <br>    } <br>} <br> <br>static void WallCompute(PaintObject *po, MazeView *vw, <br>                        FxValue cs, FxValue sn) <br>{ <br>    FxPt2 mid; <br>    Wall *wall; <br>     <br>    wall = po-&gt;u.wall.wall; <br> <br>    // Compute depth at midpoint of wall <br>    // Eye coordinate depth increases along the X so <br>    // we only need to transform it <br>     <br>    mid.x = (wall-&gt;f.x+wall-&gt;t.x)/2-vw-&gt;pos.x; <br>    mid.y = (wall-&gt;f.y+wall-&gt;t.y)/2-vw-&gt;pos.y; <br>     <br>    po-&gt;depth = FxMul(mid.x, cs)+FxMul(mid.y, sn); <br>} <br> <br>static void PartialCompute(PaintObject *po, MazeView *vw, <br>                           FxValue cs, FxValue sn) <br>{ <br>    PaintPartial *pp; <br>    FxPt2 c; <br> <br>    pp = &amp;po-&gt;u.partial; <br> <br>    // Compute depth at center of partial <br>     <br>    c.x = pp-&gt;obj-&gt;p.x-vw-&gt;pos.x; <br>    c.y = pp-&gt;obj-&gt;p.y-vw-&gt;pos.y; <br>     <br>    po-&gt;depth = FxMul(c.x, cs)+FxMul(c.y, sn); <br>} <br> <br>typedef void (*PoComputeFn)(PaintObject *po, MazeView *vw, <br>                            FxValue cs, FxValue sn); <br>static PoComputeFn PoCompute[PO_COUNT] = <br>{ <br>    WallCompute, <br>    PartialCompute <br>}; <br> <br>static float colors[17][3] = <br>{ <br>    0.0f, 0.0f, 0.0f, <br>    0.0f, 0.0f, 0.5f, <br>    0.0f, 0.5f, 0.0f, <br>    0.0f, 0.5f, 0.5f, <br>    0.5f, 0.0f, 0.0f, <br>    0.5f, 0.0f, 0.5f, <br>    0.5f, 0.5f, 0.0f, <br>    0.5f, 0.5f, 0.5f, <br>    0.75f, 0.75f, 0.75f, <br>    0.0f, 0.0f, 1.0f, <br>    0.0f, 1.0f, 0.0f, <br>    0.0f, 1.0f, 1.0f, <br>    1.0f, 0.0f, 0.0f, <br>    1.0f, 0.0f, 1.0f, <br>    1.0f, 1.0f, 0.0f, <br>    1.0f, 1.0f, 1.0f, <br>    0.75f, 0.39f, 0.0f <br>}; <br> <br>#define WALL_SET 0 <br>#define FLOOR_SET 1 <br>#define CEILING_SET 2 <br> <br>static float *smooth_sets[3][2][4] = <br>{ <br>    &amp;colors[1][0], &amp;colors[2][0], &amp;colors[4][0], &amp;colors[7][0], <br>    &amp;colors[2][0], &amp;colors[1][0], &amp;colors[7][0], &amp;colors[4][0], <br>    &amp;colors[10][0], &amp;colors[2][0], &amp;colors[4][0], &amp;colors[6][0], <br>    &amp;colors[10][0], &amp;colors[2][0], &amp;colors[4][0], &amp;colors[6][0], <br>    &amp;colors[9][0], &amp;colors[1][0], &amp;colors[2][0], &amp;colors[3][0], <br>    &amp;colors[9][0], &amp;colors[1][0], &amp;colors[2][0], &amp;colors[3][0] <br>}; <br> <br>static float *flat_sets[3][2][4] = <br>{ <br>    &amp;colors[8][0], &amp;colors[8][0], &amp;colors[8][0], &amp;colors[8][0], <br>    &amp;colors[15][0], &amp;colors[15][0], &amp;colors[15][0], &amp;colors[15][0], <br>    &amp;colors[2][0], &amp;colors[2][0], &amp;colors[2][0], &amp;colors[2][0], <br>    &amp;colors[2][0], &amp;colors[2][0], &amp;colors[2][0], &amp;colors[2][0], <br>    &amp;colors[9][0], &amp;colors[9][0], &amp;colors[9][0], &amp;colors[9][0], <br>    &amp;colors[9][0], &amp;colors[9][0], &amp;colors[9][0], &amp;colors[9][0] <br>}; <br> <br>void SetAlphaCol(GLfloat *fv3) <br>{ <br>    if (maze_options.all_alpha) <br>    { <br>        GLfloat fv4[4]; <br> <br>        fv4[0] = fv3[0]; <br>        fv4[1] = fv3[1]; <br>        fv4[2] = fv3[2]; <br>        fv4[3] = 0.5f; <br>        glColor4fv(fv4); <br>    } <br>    else <br>    { <br>        glColor3fv(fv3); <br>    } <br>} <br> <br>static void WallDraw(PaintObject *po, MazeView *vw) <br>{ <br>    Wall *wall; <br>    float fx, fy, tx, ty, cx, cy, nx, ny; <br>    float **col_set; <br>    int reps; <br>    int rept; <br>    GLenum old_env; <br> <br>    wall = po-&gt;u.wall.wall; <br>    reps = wall-&gt;pTexEnv-&gt;texRep.x; <br>    rept = wall-&gt;pTexEnv-&gt;texRep.y; <br>     <br>    fx = (float)FxFlt(wall-&gt;f.x); <br>    fy = (float)FxFlt(wall-&gt;f.y); <br>    tx = (float)FxFlt(wall-&gt;t.x); <br>    ty = (float)FxFlt(wall-&gt;t.y); <br>    nx = -(ty-fy); <br>    ny = (tx-fx); <br>    cx = (float)FxFlt(vw-&gt;pos.x); <br>    cy = (float)FxFlt(vw-&gt;pos.y); <br> <br>    col_set = &amp;flat_sets[WALL_SET][wall-&gt;col][0]; <br>    switch(maze_options.render[WALLS]) <br>    { <br>    case RENDER_NONE: <br>        return; <br>    case RENDER_SMOOTH: <br>        col_set = &amp;smooth_sets[WALL_SET][wall-&gt;col][0]; <br>        break; <br>    case RENDER_FLAT: <br>    case RENDER_TEXTURED: <br>        break; <br>    } <br> <br>    // Compute dot product with wall normal to determine <br>    // wall direction.  We need to know the wall direction <br>    // in order to ensure that the wall texture faces the <br>    // correct direction <br>    UseTextureEnv(wall-&gt;pTexEnv); <br> <br>    if (wall-&gt;pTexEnv-&gt;bTransp) <br>    { <br>        if (!maze_options.all_alpha) <br>        { <br>            glGetTexEnviv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &amp;old_env); <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, gTexEnvMode); <br>            glEnable(GL_BLEND); <br>        } <br>    } <br> <br>    glBegin(GL_POLYGON); <br>    if ((fx-cx)*nx+(fy-cy)*ny &gt; 0) <br>    { <br>        glTexCoord2d(0, 0); <br>        SetAlphaCol(col_set[0]); <br>        glVertex3f(fx, fy, 0.0f); <br>        glTexCoord2d(reps, 0); <br>        SetAlphaCol(col_set[1]); <br>        glVertex3f(tx, ty, 0.0f); <br>        glTexCoord2d(reps, rept); <br>        SetAlphaCol(col_set[2]); <br>        glVertex3f(tx, ty, maze_height); <br>        glTexCoord2d(0, rept); <br>        SetAlphaCol(col_set[3]); <br>        glVertex3f(fx, fy, maze_height); <br>    } <br>    else <br>    { <br>        glTexCoord2d(reps, 0); <br>        SetAlphaCol(col_set[0]); <br>        glVertex3f(fx, fy, 0.0f); <br>        glTexCoord2d(0, 0); <br>        SetAlphaCol(col_set[1]); <br>        glVertex3f(tx, ty, 0.0f); <br>        glTexCoord2d(0, rept); <br>        SetAlphaCol(col_set[2]); <br>        glVertex3f(tx, ty, maze_height); <br>        glTexCoord2d(reps, rept); <br>        SetAlphaCol(col_set[3]); <br>        glVertex3f(fx, fy, maze_height); <br>    } <br>    glEnd(); <br> <br>    if (wall-&gt;pTexEnv-&gt;bTransp) <br>    { <br>        if (!maze_options.all_alpha) <br>        { <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, old_env); <br>            glDisable(GL_BLEND); <br>        } <br>    } <br>} <br> <br>void (APIENTRY *convex_solids[SPECIAL_ARG_COUNT])(GLdouble radius) = <br>{ <br>    auxSolidIcosahedron, <br>    auxSolidOctahedron, <br>    auxSolidDodecahedron, <br>    auxSolidTetrahedron <br>}; <br> <br>static void PartialDraw(PaintObject *po, MazeView *vw) <br>{ <br>    PaintPartial *pp; <br>    float w, h, cx, cy, cz, vx, vy, fx, fy, fz, tx, ty, tz; <br>    float cs, sn; <br>    GLenum old_env; <br> <br>    pp = &amp;po-&gt;u.partial; <br>     <br>    w = (float)FxFlt(pp-&gt;obj-&gt;w); <br>    h = (float)FxFlt(pp-&gt;obj-&gt;h); <br> <br>    // Partials are billboarded so we want it to always be <br>    // perpendicular to the view direction <br> <br>    cs = (float)FxFlt(FaCos(vw-&gt;ang)); <br>    sn = (float)FxFlt(FaSin(vw-&gt;ang)); <br>    vx = -sn*w; <br>    vy = cs*w; <br>     <br>    cx = (float)FxFlt(pp-&gt;obj-&gt;p.x); <br>    cy = (float)FxFlt(pp-&gt;obj-&gt;p.y); <br>    cz = (float)FxFlt(pp-&gt;obj-&gt;z); <br> <br>    fx = cx-vx; <br>    fy = cy-vy; <br>    fz = (cz-h)*maze_height; <br>    tx = cx+vx; <br>    ty = cy+vy; <br>    tz = (cz+h)*maze_height; <br> <br>    if (maze_options.render[WALLS] == RENDER_TEXTURED) <br>    { <br>        glDisable(GL_TEXTURE_2D); <br>    } <br> <br>    switch(pp-&gt;obj-&gt;draw_style) <br>    { <br>    case DRAW_POLYGON: <br>        glEnable(GL_TEXTURE_2D); <br>        if (!maze_options.all_alpha) <br>        { <br>            glGetTexEnviv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &amp;old_env); <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, gTexEnvMode); <br>            glEnable(GL_BLEND); <br>        } <br>        UseTextureEnv( pp-&gt;obj-&gt;pTexEnv ); <br>        SetAlphaCol(colors[15]); <br>        glBegin(GL_POLYGON); <br>        glNormal3f(cs, sn, 0.0f); <br>        glTexCoord2f(1.0f, 0.0f); <br>        glVertex3f(fx, fy, fz); <br>        glTexCoord2f(0.0f, 0.0f); <br>        glVertex3f(tx, ty, fz); <br>        glTexCoord2f(0.0f, 1.0f); <br>        glVertex3f(tx, ty, tz); <br>        glTexCoord2f(1.0f, 1.0f); <br>        glVertex3f(fx, fy, tz); <br>        glEnd(); <br>        glDisable(GL_TEXTURE_2D); <br>        if (!maze_options.all_alpha) <br>        { <br>            glDisable(GL_BLEND); <br>            glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, old_env); <br>        } <br>        break; <br> <br>    case DRAW_SPECIAL: <br>        SetAlphaCol(colors[pp-&gt;obj-&gt;col]); <br>     <br>        glEnable(GL_AUTO_NORMAL); <br>        glEnable(GL_NORMALIZE); <br>        glEnable(GL_LIGHTING); <br>        glEnable(GL_CULL_FACE); <br>        glEnable(GL_DITHER); <br>        glPushMatrix(); <br>         <br>        glTranslated(cx, cy, cz*maze_height); <br>        glScaled(1.0, 1.0, maze_height); <br>        glRotated(FaFltDegVal(pp-&gt;obj-&gt;ang), 0, 0, 1); <br>        glRotated(pp-&gt;obj-&gt;user3, 0, 1, 0); <br>        // Must use convex objects since depth testing can be off <br>        convex_solids[pp-&gt;obj-&gt;draw_arg](w); <br>         <br>        glPopMatrix(); <br>        if( !maze_options.bDither ) <br>            glDisable(GL_DITHER); <br>        glDisable(GL_CULL_FACE); <br>        glDisable(GL_LIGHTING); <br>        glDisable(GL_AUTO_NORMAL); <br>        glDisable(GL_NORMALIZE); <br>        break; <br>    } <br>     <br>    if (maze_options.render[WALLS] == RENDER_TEXTURED) <br>    { <br>        glEnable(GL_TEXTURE_2D); <br>    } <br>} <br> <br>typedef void (*PoDrawFn)(PaintObject *po, MazeView *vw); <br>static PoDrawFn PoDraw[PO_COUNT] = <br>{ <br>    WallDraw, <br>    PartialDraw <br>}; <br> <br> <br>void RenderZPlane(int render, TEX_ENV *pTexEnv, int set, float zval) <br>{ <br>    float **col_set; <br>    int reps = pTexEnv-&gt;texRep.x;  <br>    int rept = pTexEnv-&gt;texRep.y;  <br>     <br>    switch(render) <br>    { <br>    case RENDER_NONE: <br>        break; <br>    case RENDER_TEXTURED: <br>        UseTextureEnv(pTexEnv); <br>        glEnable(GL_TEXTURE_2D); <br>        // Fall through <br>    case RENDER_FLAT: <br>    case RENDER_SMOOTH: <br>        col_set = &amp;flat_sets[set][0][0]; <br>        if (render == RENDER_SMOOTH) <br>        { <br>            col_set = &amp;smooth_sets[set][0][0]; <br>        } <br>         <br>        glBegin(GL_POLYGON); <br> <br>        // Switch texture orientation dependent on surface type <br>        if( set == CEILING_SET ) { <br>            glTexCoord2f((float)reps*MAZE_SIZE, 0.0f); <br>            glColor3fv(col_set[0]); <br>            glVertex3f(0.0f, 0.0f, zval); <br>            glTexCoord2f(0.0f, 0.0f); <br>            glColor3fv(col_set[1]); <br>            glVertex3f((float)MAZE_SIZE, 0.0f, zval); <br>            glTexCoord2f(0.0f, (float)rept*MAZE_SIZE); <br>            glColor3fv(col_set[2]); <br>            glVertex3f((float)MAZE_SIZE, (float)MAZE_SIZE, zval); <br>            glTexCoord2f((float)reps*MAZE_SIZE, (float)rept*MAZE_SIZE); <br>            glColor3fv(col_set[3]); <br>            glVertex3f(0.0f, (float)MAZE_SIZE, zval); <br>        } else { <br>            glTexCoord2f(0.0f, 0.0f); <br>            glColor3fv(col_set[0]); <br>            glVertex3f(0.0f, 0.0f, zval); <br>            glTexCoord2f((float)reps*MAZE_SIZE, 0.0f); <br>            glColor3fv(col_set[1]); <br>            glVertex3f((float)MAZE_SIZE, 0.0f, zval); <br>            glTexCoord2f((float)reps*MAZE_SIZE, (float)rept*MAZE_SIZE); <br>            glColor3fv(col_set[2]); <br>            glVertex3f((float)MAZE_SIZE, (float)MAZE_SIZE, zval); <br>            glTexCoord2f(0.0f, (float)rept*MAZE_SIZE); <br>            glColor3fv(col_set[3]); <br>            glVertex3f(0.0f, (float)MAZE_SIZE, zval); <br>        } <br> <br>        glEnd(); <br> <br>        if (render == RENDER_TEXTURED) <br>        { <br>            glDisable(GL_TEXTURE_2D); <br>        } <br>        break; <br>    } <br>} <br> <br>void Render(MazeView *vw) <br>{ <br>    FxValue cs, sn; <br>    PaintObject *sorted, *so, *pso; <br>    PaintObject *po; <br>    int i; <br>    FxPt2 at; <br>    BOOL special; <br>    float viewHeight; <br> <br>    cs = FaCos(vw-&gt;ang); <br>    sn = FaSin(vw-&gt;ang); <br>     <br>    at.x = vw-&gt;pos.x+cs; <br>    at.y = vw-&gt;pos.y+sn; <br>     <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glRotated(view_rot, 0, 0, 1); <br>    gluPerspective(VIEW_ANG, 1, .01, 100); <br>    viewHeight = 0.5f; <br>    gluLookAt(FxFlt(vw-&gt;pos.x), FxFlt(vw-&gt;pos.y), viewHeight, <br>              FxFlt(at.x), FxFlt(at.y), viewHeight, <br>              0, 0, 1); <br>    glMatrixMode(GL_MODELVIEW); <br>    glLoadIdentity(); <br> <br>    RenderZPlane(maze_options.render[FLOOR], &amp;gTexEnv[TEX_FLOOR], FLOOR_SET, 0.0f); <br>    RenderZPlane(maze_options.render[CEILING], &amp;gTexEnv[TEX_CEILING], CEILING_SET, 1.0f); <br>         <br>    sorted = NULL; <br>    special = FALSE; <br>    for (i = 0, po = paint; i &lt; npaint; i++, po++) <br>    { <br>        if (po-&gt;type == PO_PARTIAL &amp;&amp; <br>            po-&gt;u.partial.obj-&gt;draw_style == DRAW_SPECIAL) <br>        { <br>            special = TRUE; <br>        } <br>         <br>        PoCompute[po-&gt;type](po, vw, cs, sn); <br>         <br>        for (so = sorted, pso = NULL; so; pso = so, so = so-&gt;closer) <br>        { <br>            if (so-&gt;depth &lt;= po-&gt;depth) <br>            { <br>                break; <br>            } <br>        } <br>        if (pso == NULL) <br>        { <br>            sorted = po; <br>        } <br>        else <br>        { <br>            pso-&gt;closer = po; <br>        } <br>        po-&gt;closer = so; <br>    } <br> <br>    if (maze_options.render[WALLS] == RENDER_TEXTURED) <br>    { <br>        glEnable(GL_TEXTURE_2D); <br>    } <br>     <br>    for (so = sorted; so; so = so-&gt;closer) <br>    { <br>        PoDraw[so-&gt;type](so, vw); <br>    } <br> <br>    if (maze_options.render[WALLS] == RENDER_TEXTURED) <br>    { <br>        glDisable(GL_TEXTURE_2D); <br>    } <br>} <br> <br>void InitPaint(void) <br>{ <br>    int i, j; <br> <br>    npaint = 0; <br>    for (i = 0; i &lt; MAZE_GRID; i++) <br>    { <br>        for (j = 0; j &lt; MAZE_GRID; j++) <br>        { <br>            maze_cells[i][j].unseen = maze_cells[i][j].can_see | MAZE_CONTENTS; <br>        } <br>    } <br>} <br> <br>void DrawMaze(MazeView *vw) <br>{ <br>    InitPaint(); <br>    TraceView(vw); <br>    Render(vw); <br>} <br> <br>void DrawMazeWalls(void) <br>{ <br>    int w; <br>    Wall *wall; <br>     <br>    wall = maze; <br>     <br>    glColor3f(1.0f, 1.0f, 1.0f); <br> <br>    glBegin(GL_LINES); <br>    for (w = 0; w &lt; nwalls; w++) <br>    { <br>        glVertex2f((float)FxFltVal(wall-&gt;f.x), (float)FxFltVal(wall-&gt;f.y)); <br>        glVertex2f((float)FxFltVal(wall-&gt;t.x), (float)FxFltVal(wall-&gt;t.y)); <br>        wall++; <br>    } <br>    glEnd(); <br>} <br> <br>#define SQRT2_2 0.707107f <br> <br>void DrawTopView(MazeView *vw) <br>{ <br>    int c; <br>    Cell *cell; <br>    Object *obj; <br>    float vx, vy, cx, cy, width, ang; <br>    extern float gfAspect; <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluOrtho2D( -MAZE_SIZE/2.0, MAZE_SIZE/2.0, <br>            -MAZE_SIZE/2.0/gfAspect, MAZE_SIZE/2.0/gfAspect ); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glPushMatrix(); <br> <br>    ang = (float)FaFltDegVal(vw-&gt;ang)+90.0f; <br>    glRotatef(ang, 0.0f, 0.0f, 1.0f); <br>    vx = (float)FxFltVal(vw-&gt;pos.x); <br>    vy = (float)FxFltVal(vw-&gt;pos.y); <br>    glTranslatef(-vx, -vy, 0.0f); <br>     <br>#define AA_LINES 1 <br>#ifdef AA_LINES <br>    // Turn on antialiased lines <br>    glEnable( GL_BLEND ); <br>    glEnable( GL_LINE_SMOOTH ); <br>    glHint( GL_LINE_SMOOTH_HINT, GL_NICEST ); <br>#endif <br> <br>    glCallList(maze_walls_list); <br> <br>#ifdef AA_LINES <br>    glDisable( GL_BLEND ); <br>    glDisable( GL_LINE_SMOOTH ); <br>#endif <br> <br>    // Objects aren't put in the walls display list so that they <br>    // can move around <br>     <br>    cell = &amp;maze_cells[0][0]; <br>    for (c = 0; c &lt; MAZE_CELLS; c++) <br>    { <br>        for (obj = cell-&gt;contents; obj != NULL; obj = obj-&gt;next) <br>        { <br>            cx = (float)FxFltVal(obj-&gt;p.x); <br>            cy = (float)FxFltVal(obj-&gt;p.y); <br>            width = (float)FxFltVal(obj-&gt;w); <br> <br>            glColor3fv(colors[obj-&gt;col]); <br> <br>            glPushMatrix(); <br>            glTranslatef(cx, cy, 0.0f); <br>            glRotated(FaFltDegVal(obj-&gt;ang), 0, 0, 1); <br>            glBegin(GL_POLYGON); <br>            glVertex2f(width, 0.0f); <br>            glVertex2f(-width*SQRT2_2, width*0.5f); <br>            glVertex2f(-width*SQRT2_2, -width*0.5f); <br>            glEnd(); <br>            glPopMatrix(); <br>        } <br> <br>        cell++; <br>    } <br>     <br>    glPopMatrix(); <br>     <br>    // Draw self <br>    glColor3f(0.0f, 0.0f, 1.0f); <br>    width = MAZE_CELL_SIZE/4.0f; <br>    glBegin(GL_POLYGON); <br>    glVertex2f(0.0f, width); <br>    glVertex2f(width*0.5f, -width*SQRT2_2); <br>    glVertex2f(-width*0.5f, -width*SQRT2_2); <br>    glEnd(); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
