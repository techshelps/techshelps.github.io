<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEXTURE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3712"></a>TEXTURE.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: texture.c <br>* <br>* Texture handling functions <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;GL/gl.h&gt; <br> <br>#include "scrnsave.h"  // for hMainInstance <br>#include "sscommon.h" <br>#include "texture.h" <br> <br>static int ProcessTexture( TEXTURE *pTex ); <br>static int ProcessTkTexture( AUX_RGBImageRec *image, TEXTURE *pTex ); <br>static int VerifyTextureFile( TEXFILE *pTexFile ); <br>static int GetTexFileType( TEXFILE *pTexFile ); <br> <br>static TEX_STRINGS gts = {0}; <br>BOOL gbTextureObjects = FALSE; <br>static BOOL gbPalettedTexture = FALSE; <br>static PFNGLCOLORTABLEEXTPROC pfnColorTableEXT; <br>static PFNGLCOLORSUBTABLEEXTPROC pfnColorSubTableEXT; <br> <br>static BOOL gbEnableErrorMsgs = FALSE; <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_LoadTextureResourceStrings <br>* <br>* Load various messages and strings that are used in processing textures, <br>* into global TEX_STRINGS structure <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_LoadTextureResourceStrings() <br>{ <br>    LPTSTR pszStr; <br> <br>    // title for choose texture File dialog <br>    LoadString(hMainInstance, IDS_TEXTUREDIALOGTITLE, gts.szTextureDialogTitle,  <br>                GEN_STRING_SIZE); <br>    LoadString(hMainInstance, IDS_BMP, gts.szBmp, GEN_STRING_SIZE); <br>    LoadString(hMainInstance, IDS_DOTBMP, gts.szDotBmp, GEN_STRING_SIZE); <br>    LoadString(hMainInstance, IDS_TEXTUREFILTER, gts.szTextureFilter,  <br>                GEN_STRING_SIZE); <br>    pszStr = &amp;gts.szTextureFilter[lstrlen(gts.szTextureFilter)+1]; <br>    LoadString(hMainInstance, IDS_STARDOTBMP, pszStr, GEN_STRING_SIZE); <br>    pszStr += lstrlen(pszStr); <br>    *pszStr++ = TEXT(';'); <br>    LoadString(hMainInstance, IDS_STARDOTRGB, pszStr, GEN_STRING_SIZE); <br>    pszStr += lstrlen(pszStr); <br>    pszStr++; <br>    *pszStr = TEXT('\0'); <br> <br>    LoadString(hMainInstance, IDS_WARNING, gts.szWarningMsg, MAX_PATH); <br>    LoadString(hMainInstance, IDS_SELECT_ANOTHER_BITMAP,  <br>                gts.szSelectAnotherBitmapMsg, MAX_PATH ); <br> <br>    LoadString(hMainInstance, IDS_BITMAP_INVALID,  <br>                gts.szBitmapInvalidMsg, MAX_PATH ); <br>    LoadString(hMainInstance, IDS_BITMAP_SIZE,  <br>                gts.szBitmapSizeMsg, MAX_PATH ); <br> <br>    // assumed here that all above calls loaded properly <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* <br>\**************************************************************************/ <br> <br>void <br>ss_DisableTextureErrorMsgs() <br>{ <br>    gbEnableErrorMsgs = FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_LoadBMPTextureFile <br>* <br>* Loads a BMP file and prepares it for GL usage <br>* <br>\**************************************************************************/ <br> <br>int  <br>ss_LoadBMPTextureFile( LPCTSTR pszBmpfile, TEXTURE *pTex ) <br>{ <br>    AUX_RGBImageRec *image = (AUX_RGBImageRec *) NULL; <br> <br>#ifdef UNICODE <br>    image = auxDIBImageLoad( (LPCWSTR) pszBmpfile); <br>#else <br>    image = auxDIBImageLoad( (LPCSTR) pszBmpfile); <br>#endif <br> <br>    if( !image )  { <br>        return 0; <br>    } <br>    return ProcessTkTexture( image, pTex ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_LoadTextureFile <br>* <br>* Loads a BMP file and prepares it for GL usage <br>* <br>\**************************************************************************/ <br> <br>int  <br>ss_LoadTextureFile( TEXFILE *pTexFile, TEXTURE *pTex ) <br>{ <br>    AUX_RGBImageRec *image = (AUX_RGBImageRec *) NULL; <br>    LPTSTR pszBmpfile = pTexFile-&gt;szPathName; <br>    int type; <br> <br>    // Verify file / set type <br>     <br>    if( !(type = VerifyTextureFile( pTexFile )) ) <br>        return 0; <br> <br>    if( type == TEX_BMP ) { <br>#ifdef UNICODE <br>        image = auxDIBImageLoad( (LPCWSTR) pszBmpfile); <br>#else <br>        image = auxDIBImageLoad( (LPCSTR) pszBmpfile); <br>#endif <br>    } else { <br>#ifdef UNICODE <br>        image = auxRGBImageLoad( (LPCWSTR) pszBmpfile); <br>#else <br>        image = auxRGBImageLoad( (LPCSTR) pszBmpfile); <br>#endif <br>    } <br> <br>    if( !image )  { <br>        return 0; <br>    } <br>    return ProcessTkTexture( image, pTex ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_LoadTextureResource <br>* <br>* Loads a BMP or RGB texture resource and prepares it for GL usage <br>* <br>\**************************************************************************/ <br> <br>int  <br>ss_LoadTextureResource( TEX_RES *pTexRes, TEXTURE *pTex ) <br>{ <br>    HMODULE ghmodule; <br>    HRSRC hr; <br>    HGLOBAL hg; <br>    LPVOID pv; <br>    LPCTSTR lpType; <br>    BOOL fLoaded = FALSE; <br> <br>    ghmodule = GetModuleHandle(NULL); <br>    switch(pTexRes-&gt;type) <br>    { <br>    case TEX_RGB: <br>        lpType = MAKEINTRESOURCE(RT_RGB); <br>        break; <br>    case TEX_BMP: <br>        lpType = MAKEINTRESOURCE(RT_MYBMP); <br>        break; <br>    case TEX_A8: <br>        lpType = MAKEINTRESOURCE(RT_A8); <br>        break; <br>    } <br> <br>    hr = FindResource(ghmodule, MAKEINTRESOURCE(pTexRes-&gt;name), lpType); <br>    if (hr == NULL) <br>    { <br>        goto EH_NotFound; <br>    } <br>    hg = LoadResource(ghmodule, hr); <br>    if (hg == NULL) <br>    { <br>        goto EH_FreeResource; <br>    } <br>    pv = (PSZ)LockResource(hg); <br>    if (pv == NULL) <br>    { <br>        goto EH_FreeResource; <br>    } <br> <br>    switch(pTexRes-&gt;type) <br>    { <br>    case TEX_RGB: <br>        fLoaded = ss_RGBImageLoad( pv, pTex ); <br>        break; <br>    case TEX_BMP: <br>        fLoaded = ss_DIBImageLoad( pv, pTex ); <br>        break; <br>    case TEX_A8: <br>        fLoaded = ss_A8ImageLoad( pv, pTex ); <br>        break; <br>    } <br> <br> EH_FreeResource: <br>    FreeResource(hr); <br> EH_NotFound: <br>     <br>    if( !fLoaded )  { <br>        return 0; <br>    } <br> <br>    return ProcessTexture( pTex ); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ValidateTextureSize <br>*  <br>* - Scales the texture to powers of 2 <br>* <br>\**************************************************************************/ <br> <br>static BOOL <br>ValidateTextureSize( TEXTURE *pTex ) <br>{ <br>    double xPow2, yPow2; <br>    int ixPow2, iyPow2; <br>    int xSize2, ySize2; <br>    GLint glMaxTexDim; <br> <br>    if( (pTex-&gt;width &lt;= 0) || (pTex-&gt;height &lt;= 0) ) { <br>        SS_WARNING( "ValidateTextureSize : invalid texture dimensions\n" ); <br>        return FALSE; <br>    } <br> <br>    pTex-&gt;origAspectRatio = (float) pTex-&gt;height / (float) pTex-&gt;width; <br> <br>    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;glMaxTexDim); <br>    if( glMaxTexDim &lt;= 0 ) <br>        return FALSE; <br> <br>    if( pTex-&gt;format != GL_COLOR_INDEX ) { <br> <br>        // We limit the max dimension here for performance reasons <br>        glMaxTexDim = min(256, glMaxTexDim); <br> <br>        if (pTex-&gt;width &lt;= glMaxTexDim) <br>            xPow2 = log((double)pTex-&gt;width) / log((double)2.0); <br>        else <br>            xPow2 = log((double)glMaxTexDim) / log((double)2.0); <br> <br>        if (pTex-&gt;height &lt;= glMaxTexDim) <br>            yPow2 = log((double)pTex-&gt;height) / log((double)2.0); <br>        else <br>            yPow2 = log((double)glMaxTexDim) / log((double)2.0); <br> <br>        ixPow2 = (int)xPow2; <br>        iyPow2 = (int)yPow2; <br> <br>        // Always scale to higher nearest power <br>        if (xPow2 != (double)ixPow2) <br>            ixPow2++; <br>        if (yPow2 != (double)iyPow2) <br>            iyPow2++; <br> <br>        xSize2 = 1 &lt;&lt; ixPow2; <br>        ySize2 = 1 &lt;&lt; iyPow2; <br> <br>        if (xSize2 != pTex-&gt;width || <br>            ySize2 != pTex-&gt;height) <br>        { <br>            BYTE *pData; <br> <br>            pData = (BYTE *) malloc(xSize2 * ySize2 * pTex-&gt;components * sizeof(BYTE)); <br>            if (!pData) { <br>                SS_WARNING( "ValidateTextureSize : can't alloc pData\n" ); <br>                return FALSE; <br>            } <br> <br>            glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br> <br>            if( gluScaleImage(pTex-&gt;format, pTex-&gt;width, pTex-&gt;height, <br>                      GL_UNSIGNED_BYTE, pTex-&gt;data, <br>                      xSize2, ySize2, GL_UNSIGNED_BYTE, <br>                      pData) ) <br>            { <br>                // glu failure <br>                SS_WARNING( "ValidateTextureSize : gluScaleImage failure\n" ); <br>                return FALSE; <br>            } <br>         <br>            // set the new width,height,data <br>            pTex-&gt;width = xSize2; <br>            pTex-&gt;height = ySize2; <br>            free(pTex-&gt;data); <br>            pTex-&gt;data = pData; <br>        } <br>    } else {  // paletted texture case <br>        // paletted texture: must be power of 2 - but might need to enforce <br>        // here if not done in a8 load.  Also have to check against <br>        // GL_MAX_TEXTURE_SIZE.  Could then clip it to power of 2 size <br>    } <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* SetDefaultTextureParams <br>* <br>\**************************************************************************/ <br> <br>static void <br>SetDefaultTextureParams() <br>{ <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ProcessTexture <br>* <br>* - Verifies texture size <br>* - Fills out TEXTURE structure with required data <br>* - Creates a texture object if extension exists <br>* <br>\**************************************************************************/ <br> <br>static int  <br>ProcessTexture( TEXTURE *pTex ) <br>{ <br>    // Enforce proper texture size (power of 2, etc.) <br> <br>    if( !ValidateTextureSize( pTex ) ) <br>        return 0; <br> <br>    // if texturing objects available, init the object <br>    if( gbTextureObjects ) { <br>        glGenTextures( 1, &amp;pTex-&gt;texObj ); <br>        glBindTexture( GL_TEXTURE_2D, pTex-&gt;texObj ); <br> <br>        // Default attributes for texObj <br>        SetDefaultTextureParams(); <br> <br>        glTexImage2D( GL_TEXTURE_2D, 0, pTex-&gt;components, <br>                      pTex-&gt;width, pTex-&gt;height, 0, pTex-&gt;format, <br>                      GL_UNSIGNED_BYTE, pTex-&gt;data ); <br>         <br>        if (gbPalettedTexture &amp;&amp; pTex-&gt;pal != NULL) <br>        { <br>            pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTex-&gt;pal_size, <br>                             GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTex-&gt;pal); <br>        } <br>    } else <br>        pTex-&gt;texObj = 0; <br> <br>    return 1; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ProcessTkTexture <br>* <br>* Simple wrapper for ProcessTexture which fills out a TEXTURE <br>* from a AUX_RGBImageRec <br>* <br>* Frees the ImageRec if ProcessTexture succeeds <br>* <br>\**************************************************************************/ <br> <br>static int <br>ProcessTkTexture( AUX_RGBImageRec *image, TEXTURE *pTex ) <br>{ <br> <br>    pTex-&gt;width = image-&gt;sizeX; <br>    pTex-&gt;height = image-&gt;sizeY; <br>    pTex-&gt;format = GL_RGB; <br>    pTex-&gt;components = 3; <br>    pTex-&gt;data = image-&gt;data; <br>    pTex-&gt;pal_size = 0; <br>    pTex-&gt;pal = NULL; <br> <br>    if( ProcessTexture( pTex ) ) <br>    { <br>        free(image); <br>        return 1; <br>    } <br>    else <br>    { <br>        return 0; <br>    } <br>} <br>     <br>/******************************Public*Routine******************************\ <br>* <br>* ss_SetTexture <br>* <br>\**************************************************************************/ <br> <br>void <br>ss_SetTexture( TEXTURE *pTex ) <br>{ <br>    if( pTex == NULL ) <br>        return; <br> <br>    if( gbTextureObjects &amp;&amp; pTex-&gt;texObj ) { <br>        glBindTexture( GL_TEXTURE_2D, pTex-&gt;texObj ); <br>        return; <br>    } <br>     <br>    glTexImage2D( GL_TEXTURE_2D, 0, pTex-&gt;components, <br>                  pTex-&gt;width, pTex-&gt;height, 0, pTex-&gt;format, <br>                  GL_UNSIGNED_BYTE, pTex-&gt;data ); <br>         <br>    if (gbPalettedTexture &amp;&amp; pTex-&gt;pal != NULL) <br>    { <br>        pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTex-&gt;pal_size, <br>                         GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTex-&gt;pal); <br>    } <br>} <br> <br>     <br>/******************************Public*Routine******************************\ <br>* <br>* ss_CopyTexture <br>* <br>* Make a copy of a texture. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_CopyTexture( TEXTURE *pTexDst, TEXTURE *pTexSrc ) <br>{ <br>    int size; <br> <br>    if( (pTexDst == NULL) || (pTexSrc == NULL) ) <br>        return FALSE; <br> <br>    *pTexDst = *pTexSrc; <br> <br>    if( gbTextureObjects &amp;&amp; pTexSrc-&gt;texObj ) { <br>        glGenTextures( 1, &amp;pTexDst-&gt;texObj ); <br>    } <br>     <br>    // copy image data <br> <br>    size = pTexSrc-&gt;width * pTexSrc-&gt;height; <br>    if( pTexSrc-&gt;components != GL_COLOR_INDEX8_EXT ) <br>        size *= pTexSrc-&gt;components; // since data format always UNSIGNED_BYTE <br> <br>    pTexDst-&gt;data = (unsigned char *) malloc( size ); <br>    if( pTexDst-&gt;pal == NULL ) <br>        return FALSE; <br>    memcpy( pTexDst-&gt;data, pTexSrc-&gt;data, size ); <br> <br>    // copy palette data <br> <br>    if( gbPalettedTexture &amp;&amp; pTexSrc-&gt;pal != NULL ) <br>    { <br>        size = pTexSrc-&gt;pal_size*sizeof(RGBQUAD); <br>        pTexDst-&gt;pal = (RGBQUAD *) malloc(size); <br>        if( pTexDst-&gt;pal == NULL ) <br>        { <br>            free(pTexDst-&gt;data); <br>            return FALSE; <br>        } <br>        memcpy( pTexDst-&gt;pal, pTexSrc-&gt;pal, size ); <br>    } <br>     <br>    if( gbTextureObjects ) { <br>        glBindTexture( GL_TEXTURE_2D, pTexDst-&gt;texObj ); <br> <br>        // Default attributes for texObj <br>        SetDefaultTextureParams(); <br> <br>        glTexImage2D( GL_TEXTURE_2D, 0, pTexDst-&gt;components, <br>                      pTexDst-&gt;width, pTexDst-&gt;height, 0, pTexDst-&gt;format, <br>                      GL_UNSIGNED_BYTE, pTexDst-&gt;data ); <br>         <br>        if( gbPalettedTexture &amp;&amp; (pTexDst-&gt;pal != NULL) ) <br>        { <br>            pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTexDst-&gt;pal_size, <br>                             GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTexDst-&gt;pal); <br>        } <br>    } <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_SetTexturePalette <br>* <br>* Set a texture's palette according to the supplied index. This index <br>* indicates the start of the palette, which then wraps around if necessary. <br>* Of course this only works on paletted textures. <br>* <br>\**************************************************************************/ <br> <br>void <br>ss_SetTexturePalette( TEXTURE *pTex, int index ) <br>{ <br>    if( pTex == NULL ) <br>        return; <br> <br>    if( gbTextureObjects ) <br>        ss_SetTexture( pTex ); <br> <br>    if( gbPalettedTexture &amp;&amp; pTex-&gt;pal != NULL ) <br>    { <br>        int start, count; <br> <br>        start = index &amp; (pTex-&gt;pal_size - 1); <br>        count = pTex-&gt;pal_size - start; <br>        pfnColorSubTableEXT(GL_TEXTURE_2D, 0, count, GL_BGRA_EXT, <br>                            GL_UNSIGNED_BYTE, pTex-&gt;pal + start); <br>        if (start != 0) <br>        { <br>            pfnColorSubTableEXT(GL_TEXTURE_2D, count, start, GL_BGRA_EXT, <br>                                GL_UNSIGNED_BYTE, pTex-&gt;pal); <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* SetTextureAlpha <br>* <br>* Set a constant alpha value for the texture <br>* Again, don't overwrite any existing 0 alpha values, as explained in <br>* ss_SetTextureTransparency <br>* <br>\**************************************************************************/ <br> <br>static void <br>SetTextureAlpha( TEXTURE *pTex, float fAlpha ) <br>{ <br>    int i; <br>    unsigned char *pData = pTex-&gt;data; <br>    RGBA8 *pColor = (RGBA8 *) pTex-&gt;data; <br>    BYTE bAlpha = (BYTE) (fAlpha * 255.0f); <br> <br>    if( pTex-&gt;components != 4 ) <br>        return; <br> <br>    for( i = 0; i &lt; pTex-&gt;width*pTex-&gt;height; i ++, pColor++ ) { <br>        if( pColor-&gt;a != 0 )  <br>            pColor-&gt;a = bAlpha; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ConvertTextureToRGBA <br>* <br>* Convert RGB texture to RGBA <br>* <br>\**************************************************************************/ <br> <br>static void <br>ConvertTextureToRGBA( TEXTURE *pTex, float fAlpha ) <br>{ <br>    unsigned char *pNewData; <br>    int count = pTex-&gt;width * pTex-&gt;height; <br>    unsigned char *src, *dst; <br>    BYTE bAlpha = (BYTE) (fAlpha * 255.0f); <br>    int i; <br> <br>    pNewData = (unsigned char *) LocalAlloc(LMEM_FIXED, count * sizeof(RGBA8)); <br>    if( !pNewData ) <br>        return; <br> <br>    src = pTex-&gt;data; <br>    dst = pNewData; <br>    // Note: the color ordering is ABGR, where R is lsb <br>    for( i = 0; i &lt; count; i ++ ) { <br>        *((RGB8 *)dst) = *((RGB8 *)src); <br>        dst += sizeof(RGB8); <br>        src += sizeof(RGB8); <br>        *dst++ = bAlpha; <br>    } <br>    LocalFree( pTex-&gt;data ); <br>    pTex-&gt;data = pNewData; <br>    pTex-&gt;components = 4; <br>    pTex-&gt;format = GL_RGBA; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_SetTextureTransparency <br>* <br>* Set transparency for a texture by adding or modifying the alpha data.   <br>* Transparency value must be between 0.0 (opaque) and 1.0 (fully transparent) <br>* If the texture data previously had no alpha, add it in. <br>* If bSet is TRUE, make this the current texture. <br>* <br>* Note: Currently fully transparent pixels (alpha=0) will not be altered, since <br>* it is assumed these should be permanently transparent (could make this an <br>* option? - bPreserveTransparentPixels ) <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_SetTextureTransparency( TEXTURE *pTex, float fTransp, BOOL bSet ) <br>{ <br>    int i; <br>    float fAlpha; <br> <br>    if( pTex == NULL ) <br>        return FALSE; <br> <br>    SS_CLAMP_TO_RANGE2( fTransp, 0.0f, 1.0f ); <br>    fAlpha = 1 - fTransp; <br> <br>    if( pTex-&gt;format == GL_COLOR_INDEX ) <br>    { <br>        // just need to modify the palette <br>            RGBQUAD *pPal = pTex-&gt;pal; <br>            BYTE bAlpha = (BYTE) (fAlpha * 255.0f); <br> <br>            if( !pPal ) <br>                return FALSE; <br> <br>            for( i = 0; i &lt; pTex-&gt;pal_size; i ++, pPal++ ) { <br>                if( pPal-&gt;rgbReserved != 0 ) <br>                    pPal-&gt;rgbReserved = bAlpha; <br>            } <br>         <br>            // need to send down the new palette for texture objects <br>            if( gbTextureObjects &amp;&amp; gbPalettedTexture ) <br>            { <br>                glBindTexture( GL_TEXTURE_2D, pTex-&gt;texObj ); <br>                pfnColorTableEXT(GL_TEXTURE_2D, GL_RGBA, pTex-&gt;pal_size, <br>                                 GL_BGRA_EXT, GL_UNSIGNED_BYTE, pTex-&gt;pal); <br>            } <br>    } <br>    else { <br>        // Need to setup new texture data <br>        if( pTex-&gt;components != 4 ) { <br>            // Make room for alpha component <br>            ConvertTextureToRGBA( pTex, fAlpha ); <br>        } else { <br>            // Set alpha component <br>            SetTextureAlpha( pTex, fAlpha ); <br>        } <br>        // Send down new data if texture objects <br>        if( gbTextureObjects ) <br>        { <br>            glBindTexture( GL_TEXTURE_2D, pTex-&gt;texObj ); <br>            glTexImage2D( GL_TEXTURE_2D, 0, pTex-&gt;components, <br>                          pTex-&gt;width, pTex-&gt;height, 0, pTex-&gt;format, <br>                          GL_UNSIGNED_BYTE, pTex-&gt;data ); <br>        } <br>    } <br> <br>    if( bSet ) <br>        ss_SetTexture( pTex ); <br> <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_DeleteTexture <br>* <br>\**************************************************************************/ <br> <br>void <br>ss_DeleteTexture( TEXTURE *pTex ) <br>{ <br>    if( pTex == NULL ) <br>        return; <br> <br>    if( gbTextureObjects &amp;&amp; pTex-&gt;texObj ) { <br>        glDeleteTextures( 1, &amp;pTex-&gt;texObj ); <br>        pTex-&gt;texObj = 0; <br>    } <br>    if (pTex-&gt;pal != NULL) <br>    { <br>        free(pTex-&gt;pal); <br>    } <br>    if( pTex-&gt;data ) <br>        free( pTex-&gt;data ); <br>} <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_TextureObjectsEnabled <br>* <br>* Returns BOOL set by ss_QueryGLVersion (Texture Objects only supported on <br>* GL v.1.1 or greater) <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_TextureObjectsEnabled( void ) <br>{ <br>    return gbTextureObjects; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_PalettedTextureEnabled <br>* <br>* Returns result from ss_QueryPalettedTextureEXT <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_PalettedTextureEnabled( void ) <br>{ <br>    return gbPalettedTexture; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_QueryPalettedTextureEXT <br>* <br>* Queries the OpenGL implementation to see if paletted texture is supported <br>* Typically called once at app startup. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_QueryPalettedTextureEXT( void ) <br>{ <br>    PFNGLGETCOLORTABLEPARAMETERIVEXTPROC pfnGetColorTableParameterivEXT; <br>    int size; <br> <br>    pfnColorTableEXT = (PFNGLCOLORTABLEEXTPROC) <br>        wglGetProcAddress("glColorTableEXT"); <br>    if (pfnColorTableEXT == NULL) <br>        return FALSE; <br>    pfnColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC) <br>        wglGetProcAddress("glColorSubTableEXT"); <br>    if (pfnColorSubTableEXT == NULL) <br>        return FALSE; <br> <br>    // Check color table size <br>    pfnGetColorTableParameterivEXT = (PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) <br>        wglGetProcAddress("glGetColorTableParameterivEXT"); <br>    if (pfnGetColorTableParameterivEXT == NULL) <br>        return FALSE; <br>    // For now, the only paletted textures supported in this lib are TEX_A8, <br>    // with 256 color table entries.  Make sure the device supports this. <br>    pfnColorTableEXT(GL_PROXY_TEXTURE_2D, GL_RGBA, 256, <br>                     GL_BGRA_EXT, GL_UNSIGNED_BYTE, NULL ); <br>    pfnGetColorTableParameterivEXT( GL_PROXY_TEXTURE_2D, <br>                                    GL_COLOR_TABLE_WIDTH_EXT, &amp;size ); <br>    if( size != 256 ) <br>        // The device does not support a color table size of 256, so we don't <br>        // enable paletted textures in general. <br>        return FALSE; <br> <br>    return gbPalettedTexture=TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_VerifyTextureFile <br>* <br>* Validates texture bmp or rgb file, by checking for valid pathname and <br>* correct format. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_VerifyTextureFile( TEXFILE *ptf ) <br>{ <br>    // Make sure the selected texture file is OK. <br> <br>    TCHAR szFileName[MAX_PATH]; <br>    PTSTR pszString; <br>    TCHAR szString[MAX_PATH]; <br> <br>    lstrcpy(szFileName, ptf-&gt;szPathName); <br> <br>    if ( SearchPath(NULL, szFileName, NULL, MAX_PATH, <br>                     ptf-&gt;szPathName, &amp;pszString) <br>       ) <br>    { <br>        ptf-&gt;nOffset = pszString - ptf-&gt;szPathName; <br>        return TRUE; <br>    } <br>    else <br>    { <br>        lstrcpy(ptf-&gt;szPathName, szFileName);    // restore <br> <br>        if( !ss_fOnWin95() &amp;&amp; gbEnableErrorMsgs ) <br>        { <br>            wsprintf(szString, gts.szSelectAnotherBitmapMsg, ptf-&gt;szPathName); <br>            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK); <br>        } <br>        return FALSE; <br>    } <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_SelectTextureFile <br>* <br>* Use the common dialog GetOpenFileName to get the name of a bitmap file <br>* for use as a texture.  This function will not return until the user <br>* either selects a valid bitmap or cancels.  If a valid bitmap is selected <br>* by the user, the global array szPathName will have the full path <br>* to the bitmap file and the global value nOffset will have the <br>* offset from the beginning of szPathName to the pathless file name. <br>* <br>* If the user cancels, szPathName and nOffset will remain <br>* unchanged. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_SelectTextureFile( HWND hDlg, TEXFILE *ptf ) <br>{ <br>    OPENFILENAME ofn; <br>    TCHAR dirName[MAX_PATH]; <br>    TEXFILE newTexFile; <br>    LPTSTR pszFileName = newTexFile.szPathName; <br>    TCHAR origPathName[MAX_PATH]; <br>    PTSTR pszString; <br>    BOOL bTryAgain, bFileSelected; <br> <br>    gbEnableErrorMsgs = TRUE; <br> <br>    // Make a copy of the original file path name, so we can tell if <br>    // it changed or not <br>    lstrcpy( origPathName, ptf-&gt;szPathName ); <br> <br>    // Make dialog look nice by parsing out the initial path and <br>    // file name from the full pathname.  If this isn't done, then <br>    // dialog has a long ugly name in the file combo box and <br>    // directory will end up with the default current directory. <br> <br>    if (ptf-&gt;nOffset) { <br>    // Separate the directory and file names. <br> <br>        lstrcpy(dirName, ptf-&gt;szPathName); <br>        dirName[ptf-&gt;nOffset-1] = L'\0'; <br>        lstrcpy(pszFileName, &amp;ptf-&gt;szPathName[ptf-&gt;nOffset]); <br>    } <br>    else { <br>    // If nOffset is zero, then szPathName is not a full path. <br>    // Attempt to make it a full path by calling SearchPath. <br> <br>        if ( SearchPath(NULL, ptf-&gt;szPathName, NULL, MAX_PATH, <br>                         dirName, &amp;pszString) ) <br>        { <br>        // Successful.  Go ahead a change szPathName to the full path <br>        // and compute the filename offset. <br> <br>            lstrcpy(ptf-&gt;szPathName, dirName); <br>            ptf-&gt;nOffset = pszString - dirName; <br> <br>        // Break the filename and directory paths apart. <br> <br>            dirName[ptf-&gt;nOffset-1] = TEXT('\0'); <br>            lstrcpy(pszFileName, pszString); <br>        } <br> <br>    // Give up and use the Windows system directory. <br> <br>        else <br>        { <br>            GetWindowsDirectory(dirName, MAX_PATH); <br>            lstrcpy(pszFileName, ptf-&gt;szPathName); <br>        } <br>    } <br> <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hDlg; <br>    ofn.hInstance = NULL; <br>    ofn.lpstrFilter = gts.szTextureFilter; <br>    ofn.lpstrCustomFilter = (LPTSTR) NULL; <br>    ofn.nMaxCustFilter = 0; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = pszFileName; <br>    ofn.nMaxFile = MAX_PATH; <br>    ofn.lpstrFileTitle = (LPTSTR) NULL; <br>    ofn.nMaxFileTitle = 0; <br>    ofn.lpstrInitialDir = dirName; <br>    ofn.lpstrTitle = gts.szTextureDialogTitle; <br>    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = gts.szBmp; <br>    ofn.lCustData = 0; <br>    ofn.lpfnHook = (LPOFNHOOKPROC) NULL; <br>    ofn.lpTemplateName = (LPTSTR) NULL; <br> <br>    do { <br>    // Invoke the common file dialog.  If it succeeds, then validate <br>    // the bitmap file.  If not valid, make user try again until either <br>    // they pick a good one or cancel the dialog. <br> <br>        bTryAgain = FALSE; <br> <br>        if ( bFileSelected = GetOpenFileName(&amp;ofn) ) { <br> <br>            newTexFile.nOffset = ofn.nFileOffset; <br>            if( VerifyTextureFile( &amp;newTexFile ) ) { <br>                // copy in new file and offset <br>                *ptf = newTexFile; <br>            } <br>            else { <br>                bTryAgain = TRUE; <br>            } <br>        } <br> <br>    // If need to try again, recompute dir and file name so dialog <br>    // still looks nice. <br> <br>        if (bTryAgain &amp;&amp; ofn.nFileOffset) { <br>            lstrcpy(dirName, pszFileName); <br>            dirName[ofn.nFileOffset-1] = L'\0'; <br>            lstrcpy(pszFileName, &amp;pszFileName[ofn.nFileOffset]); <br>        } <br> <br>    } while (bTryAgain); <br> <br>    gbEnableErrorMsgs = FALSE; <br> <br>    if( bFileSelected ) { <br>        if( lstrcmpi( origPathName, ptf-&gt;szPathName ) ) <br>            // a different file was selected <br>            return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_GetDefaultBmpFile <br>* <br>* Determine a default bitmap file to use for texturing, if none <br>* exists yet in the registry.   <br>* <br>* Put default in BmpFile parameter.   DotBmp parameter is the bitmap <br>* extension (usually .bmp). <br>* <br>* We have to synthesise the name from the ProductType registry entry. <br>* Currently, this can be WinNT, LanmanNT, or Server.  If it is <br>* WinNT, the bitmap is winnt.bmp.  If it is LanmanNT or Server, <br>* the bitmap is lanmannt.bmp. <br>* <br>\**************************************************************************/ <br> <br>void <br>ss_GetDefaultBmpFile( LPTSTR pszBmpFile ) <br>{ <br>    HKEY   hkey; <br>    LONG   cjDefaultBitmap = MAX_PATH; <br> <br>    if( ss_fOnWin95() ) <br>        // There is no 'nice' bmp file on standard win95 installations <br>        lstrcpy( pszBmpFile, TEXT("") ); <br>    else { <br>        if ( RegOpenKeyEx(HKEY_LOCAL_MACHINE, <br>                 (LPCTSTR) TEXT("System\\CurrentControlSet\\Control\\ProductOptions"), <br>                 0, <br>                 KEY_QUERY_VALUE, <br>                 &amp;hkey) == ERROR_SUCCESS ) <br>        { <br> <br>            if ( RegQueryValueEx(hkey, <br>                                  TEXT("ProductType"), <br>                                  (LPDWORD) NULL, </code></pre>
<p>
</p>
<pre><code>(LPDWORD) NULL, <br>                                  (LPBYTE) pszBmpFile, <br>                                  (LPDWORD) &amp;cjDefaultBitmap) == ERROR_SUCCESS <br>                 &amp;&amp; (cjDefaultBitmap / sizeof(TCHAR) + 4) &lt;= MAX_PATH ) <br>                lstrcat( pszBmpFile, gts.szDotBmp ); <br>            else <br>                lstrcpy( pszBmpFile, TEXT("winnt.bmp") ); <br> <br>            RegCloseKey(hkey); <br>        } <br>        else <br>            lstrcpy( pszBmpFile, TEXT("winnt.bmp") ); <br> <br>    // If its not winnt.bmp, then its lanmannt.bmp.  (This would be a lot <br>    // cleaner both in the screen savers and for usersrv desktop bitmap <br>    // initialization if the desktop bitmap name were stored in the <br>    // registry). <br> <br>        if ( lstrcmpi( pszBmpFile, TEXT("winnt.bmp") ) != 0 ) <br>            lstrcpy( pszBmpFile, TEXT("lanmannt.bmp") ); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* VerifyTextureFile <br>* <br>* Verify that a bitmap or rgb file is valid <br>* <br>* Returns: <br>*   File type (RGB or BMP) if valid file; otherwise, 0. <br>* <br>\**************************************************************************/ <br> <br>static int <br>VerifyTextureFile( TEXFILE *pTexFile ) <br>{ <br>    int type; <br>    ISIZE size; <br>    BOOL bValid; <br>    TCHAR szString[2 * MAX_PATH]; // May contain a pathname <br> <br>    // check for 0 offset and null strings <br>    if( (pTexFile-&gt;nOffset == 0) || (*pTexFile-&gt;szPathName == 0) ) <br>        return 0; <br> <br>    type = GetTexFileType( pTexFile ); <br> <br>    switch( type ) { <br>        case TEX_BMP: <br>            bValid = bVerifyDIB( pTexFile-&gt;szPathName, &amp;size ); <br>            break; <br>        case TEX_RGB: <br>            bValid = bVerifyRGB( pTexFile-&gt;szPathName, &amp;size ); <br>            break; <br>        case TEX_UNKNOWN: <br>        default: <br>            bValid = FALSE; <br>    } <br> <br>    if( !bValid ) { <br>        if( gbEnableErrorMsgs ) { <br>            wsprintf(szString, gts.szSelectAnotherBitmapMsg, pTexFile-&gt;szPathName); <br>            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK); <br>        } <br>        return 0; <br>    } <br> <br>    // Check size ? <br> <br>    if ( (size.width &gt; TEX_WIDTH_MAX)     ||  <br>         (size.height &gt; TEX_HEIGHT_MAX) ) <br>    { <br>        if( gbEnableErrorMsgs ) <br>        { <br>            wsprintf(szString, gts.szBitmapSizeMsg,  <br>                      TEX_WIDTH_MAX, TEX_HEIGHT_MAX); <br>            MessageBox(NULL, szString, gts.szWarningMsg, MB_OK); <br>        } <br>        return 0; <br>    } <br> <br>    return type; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ss_InitAutoTexture <br>* <br>* Generate texture coordinates automatically. <br>* If pTexRep is not NULL, use it to set the repetition of the generated <br>* texture. <br>* <br>\**************************************************************************/ <br> <br>void <br>ss_InitAutoTexture( TEX_POINT2D *pTexRep ) <br>{ <br>    GLfloat sgenparams[] = {1.0f, 0.0f, 0.0f, 0.0f}; <br>    GLfloat tgenparams[] = {0.0f, 1.0f, 0.0f, 0.0f}; <br> <br>    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR ); <br>    if( pTexRep ) <br>        sgenparams[0] = pTexRep-&gt;s; <br>    glTexGenfv(GL_S, GL_OBJECT_PLANE, sgenparams ); <br> <br>    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR ); <br>    if( pTexRep ) <br>        tgenparams[0] = pTexRep-&gt;t; <br>    glTexGenfv(GL_T, GL_OBJECT_PLANE, tgenparams ); <br> <br>    glEnable(GL_TEXTURE_GEN_S); <br>    glEnable(GL_TEXTURE_GEN_T); <br>    glEnable( GL_TEXTURE_2D ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* GetTexFileType <br>* <br>* Determine if a texture file is rgb or bmp, based on extension.  This is <br>* good enough, as the open texture dialog only shows files with these <br>* extensions. <br>* <br>\**************************************************************************/ <br> <br>static int <br>GetTexFileType( TEXFILE *pTexFile ) <br>{ <br>    LPTSTR pszStr; <br> <br>#ifdef UNICODE <br>    pszStr = wcsrchr( pTexFile-&gt;szPathName + pTexFile-&gt;nOffset,  <br>             (USHORT) L'.' ); <br>#else <br>    pszStr = strrchr( pTexFile-&gt;szPathName + pTexFile-&gt;nOffset,  <br>             (USHORT) L'.' ); <br>#endif <br>    if( !pszStr || (lstrlen(++pszStr) == 0) ) <br>        return TEX_UNKNOWN; <br> <br>    if( !lstrcmpi( pszStr, TEXT("bmp") ) ) <br>        return TEX_BMP; <br>    else if( !lstrcmpi( pszStr, TEXT("rgb") ) ) <br>        return TEX_RGB; <br>    else <br>        return TEX_UNKNOWN; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
