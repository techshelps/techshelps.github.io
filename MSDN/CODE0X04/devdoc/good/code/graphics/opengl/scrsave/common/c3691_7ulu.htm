<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SCRNSAVE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3702"></a>SCRNSAVE.CXX</h2>
<pre><code>//---------------------------------------------------------------------------- <br>// <br>// SCRNSAVE.C      --    skeleton for screen saver application <br>// <br>//---------------------------------------------------------------------------- <br> <br>#define GL_SCRNSAVE 1 <br> <br>#define WIN31 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include "scrnsave.h" <br>#include &lt;regstr.h&gt; <br>#include    &lt;imm.h&gt; <br>#ifdef GL_SCRNSAVE <br>#include "glscrnsv.h" <br>#endif <br> <br>#define DBG_MSGS    0 <br> <br>const TCHAR szScreenSaverKey[] = REGSTR_PATH_SCREENSAVE; <br>TCHAR szPasswordActiveValue[] = REGSTR_VALUE_USESCRPASSWORD; <br>const TCHAR szPasswordValue[] = REGSTR_VALUE_SCRPASSWORD; <br>TCHAR szPwdDLL[] = TEXT("PASSWORD.CPL"); <br>CHAR szFnName[] = "VerifyScreenSavePwd";        // Proc name, must be ANSI <br>TCHAR szImmDLL[] = TEXT("IMM32.DLL"); <br>CHAR szImmFnc[] = "ImmAssociateContext";        // Proc name, must be ANSI <br> <br>typedef BOOL (FAR PASCAL * VERIFYPWDPROC) (HWND); <br>typedef BOOL (FAR PASCAL * IMMASSOCPROC) (HWND,HIMC); <br> <br> <br>//---------------------------------------------------------------------------- <br>// variables declared in SCRNSAVE.H <br>HINSTANCE hMainInstance = 0; <br>HWND hMainWindow = 0; <br>BOOL fChildPreview = FALSE; <br> <br> <br> <br>//---------------------------------------------------------------------------- <br>// other globals <br>POINT ptMouse; <br>BOOL fClosing = FALSE; <br>BOOL fCheckingPassword = FALSE; <br>HINSTANCE hInstPwdDLL = NULL; <br>VERIFYPWDPROC VerifyPassword = NULL; <br>static BOOL preview_like_fullscreen = FALSE; <br>HINSTANCE hInstImm = NULL; <br>IMMASSOCPROC ImmFnc = NULL; <br>HIMC hPrevImc = (HIMC)0L; <br> <br> <br>static BOOL fOnWin95 = FALSE;  //TRUE if on Chicago, FALSE if on Cairo <br> <br>//---------------------------------------------------------------------------- <br>DWORD dwWakeThreshold = 4;  //default to slight movement <br>DWORD dwPasswordDelay = 0; <br>DWORD dwBlankTime = 0; <br>#define MAX_PASSWORD_DELAY_IN_SECONDS (60) <br> <br>//---------------------------------------------------------------------------- <br>// forward declarations of internal fns <br>#ifndef GL_SCRNSAVE <br>// These are hooked out to glscrnsv.cxx <br>static int DoScreenSave( HWND hParent ); <br>static int DoConfigBox( HWND hParent ); <br>#endif <br>static int DoSaverPreview( LPCTSTR szUINTHandle ); <br>static int DoChangePw( LPCTSTR szUINTHandle ); <br>static BOOL DoPasswordCheck( HWND hParent ); <br>VOID LoadPwdDLL(VOID); <br>VOID UnloadPwdDLL(VOID); <br> <br> <br>//---------------------------------------------------------------------------- <br>// helper for time <br>static DWORD <br>GetElapsedTime(DWORD from, DWORD to) <br>{ <br>    return (to &gt;= from)? (to - from) : (1 + to + (((DWORD)-1) - from)); <br>} <br> <br>//---------------------------------------------------------------------------- <br>// helper to convert text to unsigned int <br>static UINT <br>atoui( LPCTSTR szUINT ) <br>{ <br>   UINT uValue = 0; <br> <br>   while( ( *szUINT &gt;= TEXT('0') ) &amp;&amp; ( *szUINT &lt;= TEXT('9') ) ) <br>      uValue = ( ( uValue * 10 ) + ( *szUINT++ - TEXT('0') ) ); <br> <br>   return uValue; <br>} <br> <br> <br>//---------------------------------------------------------------------------- <br>// Local reboot and hotkey control (on Win95) <br>static void <br>HogMachine( BOOL value ) <br>{ <br>    BOOL dummy; <br> <br>    // <br>    // NT is always secure, therefore we don't need to call this on Cairo/NT <br>    // <br>    if (fOnWin95) { <br>        SystemParametersInfo( SPI_SCREENSAVERRUNNING, value, &amp;dummy, 0 ); <br>    } <br>} <br> <br> <br>//---------------------------------------------------------------------------- <br>// entry point  <br>int PASCAL <br>WinMainN( HINSTANCE hInst, HINSTANCE hPrev, LPTSTR szCmdLine, int nCmdShow ) <br>{ <br>   LPCTSTR pch = szCmdLine; <br>   HWND hParent = 0; <br>   OSVERSIONINFO osvi; <br> <br>   hMainInstance = hInst; <br> <br>   osvi.dwOSVersionInfoSize = sizeof(osvi); <br>   fOnWin95 = (GetVersionEx(&amp;osvi) &amp;&amp; <br>                osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS); <br> <br>   _try <br>   { <br>      for(;;) switch( *pch ) <br>      { <br>          case TEXT('S'): <br>          case TEXT('s'): <br>              return DoScreenSave( NULL ); <br> <br>#ifdef GL_SCRNSAVE <br>          case TEXT('W'): <br>          case TEXT('w'): <br>              do pch++; while( *pch == TEXT(' ') );  // size parameters <br>              return DoWindowedScreenSave( pch ); <br>#endif <br> <br>          case TEXT('L'): <br>          case TEXT('l'): <br>              // special switch for tests such as WinBench <br>              // this is NOT a hack to make bechmarks look good <br>              // it's a hack to allow you to benchmark a screen saver <br>              // many bechmarking apps require the whole screen in foreground <br>              // which makes it hard to measure how a screensaver adds CPU load <br>              // you must provide a parent window (just like preview mode) <br>              preview_like_fullscreen = TRUE; <br>          case TEXT('P'): <br>          case TEXT('p'): <br>              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff <br>              return DoSaverPreview( pch ); <br> <br>          case TEXT('A'): <br>          case TEXT('a'): <br>              if (!fOnWin95) <br>                  return -1; <br>              do pch++; while( *pch == TEXT(' ') );  // skip to the good stuff <br>              return DoChangePw( pch ); <br> <br>          case TEXT('C'): <br>          case TEXT('c'): <br>              return DoConfigBox( GetForegroundWindow() ); <br> <br>          case TEXT('\0'): <br>              return DoConfigBox( NULL ); <br> <br>          case TEXT(' '): <br>          case TEXT('-'): <br>          case TEXT('/'): <br>              pch++;   // skip spaces and common switch prefixes <br>              break; <br> <br>          default: <br>              return -1; <br>      } <br>   } <br>   _except(UnhandledExceptionFilter(GetExceptionInformation())) <br>   { <br>      // don't leave local reboot and hotkeys disabled on Win95 <br>      HogMachine( FALSE ); <br>   } <br> <br>} <br> <br> <br>//---------------------------------------------------------------------------- <br>// default screen-saver proc, declared in SCRNSAVE.H <br>// intended to be called by the consumer's ScreenSaverProc where <br>// DefWindowProc would normally be called <br>LRESULT WINAPI <br>DefScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) <br>{ <br>#if DBG_MSGS <br>    TCHAR szBuff[80]; <br> <br>    wsprintf( szBuff, TEXT("*** DefSSP received:\t0x%04lx 0x%08lx 0x%08lx\n"), uMsg, wParam, lParam ); <br>    OutputDebugString(szBuff); <br>#endif <br> <br>   if( !fChildPreview &amp;&amp; !fClosing ) <br>   { <br>      switch( uMsg ) <br>      { <br>         case WM_CLOSE: <br>            // <br>            // Only do password check if on Windows 95.  WinNT (Cairo) has <br>            // the password check built into the security desktop for <br>            // C2 compliance. <br>            // <br>            if (fOnWin95) { <br>                if( !DoPasswordCheck( hWnd ) ) <br>                { <br>                    GetCursorPos( &amp;ptMouse );  // re-establish <br>                    return FALSE; <br>                } <br>            } <br>#ifdef GL_SCRNSAVE <br>            // We need to know when we're being terminated, so we can do <br>            // various clean-up stuff <br>            SendMessage( hWnd, SS_WM_CLOSING, 0, 0 ); <br>#endif <br>            break; <br> <br>         case SCRM_VERIFYPW: <br>            if (fOnWin95) <br>                return ( VerifyPassword? (LRESULT)VerifyPassword( hWnd ) : 1L ); <br>            break; <br> <br>         default: <br>         { <br>            POINT ptMove, ptCheck; <br> <br>            if( fCheckingPassword ) <br>                break; <br> <br>            switch( uMsg ) <br>            { <br>                case WM_SHOWWINDOW: <br>                    if( (BOOL)wParam ) <br>                    SetCursor( NULL ); <br>                    break; <br> <br>                case WM_SETCURSOR: <br>                    SetCursor( NULL ); <br>                    return TRUE; <br> <br>                case WM_MOUSEMOVE: <br>                    GetCursorPos( &amp;ptCheck ); <br>                    if( ( ptMove.x = ptCheck.x - ptMouse.x ) &amp;&amp; ( ptMove.x &lt; 0 ) ) <br>                        ptMove.x *= -1; <br>                    if( ( ptMove.y = ptCheck.y - ptMouse.y ) &amp;&amp; ( ptMove.y &lt; 0 ) ) <br>                        ptMove.y *= -1; <br>                    if( ((DWORD)ptMove.x + (DWORD)ptMove.y) &gt; dwWakeThreshold ) <br>                    { <br>                        PostMessage( hWnd, WM_CLOSE, 0, 0l ); <br>                        ptMouse = ptCheck; <br>                    } <br>                    break; <br> <br>                case WM_ACTIVATEAPP: <br>                    if( wParam ) break; <br>                case WM_LBUTTONDOWN: <br>                case WM_MBUTTONDOWN: <br>                case WM_RBUTTONDOWN: <br>                case WM_KEYDOWN: <br>                case WM_SYSKEYDOWN: <br>                    PostMessage( hWnd, WM_CLOSE, 0, 0l ); <br>                    break; <br>            } <br>         } <br>      } <br>   } <br> <br>   return DefWindowProc( hWnd, uMsg, wParam, lParam ); <br>} <br> <br>//---------------------------------------------------------------------------- <br>// This window procedure takes care of important stuff before calling the <br>// consumer's ScreenSaverProc.  <br>LRESULT WINAPI <br>RealScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) <br>{ <br>   switch( uMsg ) <br>   { <br>      case WM_CREATE: <br>         // screen saver does not need the IME <br>         if ((hInstImm = GetModuleHandle(szImmDLL)) &amp;&amp; <br>             (ImmFnc = (IMMASSOCPROC)GetProcAddress(hInstImm,szImmFnc))) <br>             hPrevImc = ImmFnc(hWnd, (HIMC)NULL); <br> <br>         // establish the mouse position <br>         GetCursorPos( &amp;ptMouse ); <br> <br>         if( !fChildPreview ) <br>            SetCursor( NULL ); <br> <br>         break; <br> <br>      case WM_DESTROY: <br>         // screen saver does not need the IME <br>         if( hInstImm &amp;&amp; ImmFnc &amp;&amp; hPrevImc ) <br>            ImmFnc(hWnd, hPrevImc); <br> <br>         PostQuitMessage( 0 ); <br>         break; <br> <br>      case WM_SETTEXT: <br>         // we need to be able to use FindWindow() to find running instances <br>         // of full-screen windows screen savers <br>         // NOTE: USER slams our title in during WM_NCCREATE by calling the <br>         // defproc for WM_SETTEXT directly, so the initial title will get <br>         // there.  If this ever changes, we can simply set a bypass flag <br>         // during WM_NCCREATE processing. <br>         return FALSE; <br> <br>      case WM_SYSCOMMAND: <br>         if (!fChildPreview) <br>         { <br>            switch (wParam) <br>            { <br>               case SC_NEXTWINDOW:       // no Alt-tabs <br>               case SC_PREVWINDOW:       // no shift-alt-tabs <br>               case SC_SCREENSAVE:       // no more screensavers <br>                  return FALSE; <br>            } <br>         } <br>         break; <br> <br>      case WM_HELP: <br>      case WM_CONTEXTMENU: <br>         if( fChildPreview ) <br>         { <br>            // if we're in preview mode, pump the help stuff to our owner <br>            HWND hParent = GetParent( hWnd ); <br> <br>            if( hParent &amp;&amp; IsWindow( hParent ) ) <br>               PostMessage( hParent, uMsg, (WPARAM)hParent, lParam ); <br>               return TRUE; <br>         } <br>         break; <br> <br>      case WM_TIMER: <br>         if( fClosing ) <br>            return FALSE; <br>         Sleep( 0 ); <br>         break; <br> <br>      case WM_MOUSEMOVE: <br>      case WM_LBUTTONDOWN: <br>      case WM_MBUTTONDOWN: <br>      case WM_RBUTTONDOWN: <br>      case WM_KEYDOWN: <br>      case WM_SYSKEYDOWN: <br>         if( fClosing ) <br>            return DefWindowProc( hWnd, uMsg, wParam, lParam ); <br>         break; <br> <br>      case WM_PAINT: <br>         if( fClosing ) <br>            return DefWindowProc( hWnd, uMsg, wParam, lParam ); <br>         if( !fChildPreview ) <br>            SetCursor( NULL ); <br>         break; <br>   } <br> <br>   return ScreenSaverProc( hWnd, uMsg, wParam, lParam ); <br>} <br> <br>#ifdef GL_SCRNSAVE <br>void <br>#else <br>static void <br>#endif <br>InitRealScreenSave() <br>{ <br> <br>   LoadPwdDLL(); <br>} <br> <br>//---------------------------------------------------------------------------- <br> <br>#ifndef GL_SCRNSAVE <br> <br>static int <br>DoScreenSave( HWND hParent ) <br>{ <br>   LPCTSTR pszWindowClass = TEXT("WindowsScreenSaverClass"); <br>   LPCTSTR pszWindowTitle; <br> <br>   WNDCLASS cls; <br>   MSG      msg; <br>   UINT     uStyle; <br>   UINT     uExStyle; <br>   int      nCx, nCy; <br> <br>   cls.hCursor        = NULL; <br>   cls.hIcon          = LoadIcon( hMainInstance, MAKEINTATOM( ID_APP ) ); <br>   cls.lpszMenuName   = NULL; <br>   cls.lpszClassName  = pszWindowClass; <br>   cls.hbrBackground  = GetStockObject( BLACK_BRUSH ); <br>   cls.hInstance      = hMainInstance; <br>   cls.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC; <br>   cls.lpfnWndProc    = RealScreenSaverProc; <br>   cls.cbWndExtra     = 0; <br>   cls.cbClsExtra     = 0; <br> <br>   if( hParent ) <br>   { <br>      RECT rcParent; <br>      GetClientRect( hParent, &amp;rcParent ); <br>      nCx = rcParent.right; <br>      nCy = rcParent.bottom; <br>      uStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN; <br>      uExStyle = 0; <br> <br>      fChildPreview = TRUE; <br>      pszWindowTitle = TEXT("Preview");      // MUST differ from full screen <br>   } <br>   else <br>   { <br>      HWND hOther; <br> <br>      nCx = GetSystemMetrics( SM_CXSCREEN ); <br>      nCy = GetSystemMetrics( SM_CYSCREEN ); <br>      uStyle = WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS; <br>      uExStyle = WS_EX_TOPMOST; <br> <br>      pszWindowTitle = TEXT("Screen Saver"); // MUST differ from preview <br> <br>      // if there is another NORMAL screen save instance, switch to it <br>      hOther = FindWindow( pszWindowClass, pszWindowTitle ); <br> <br>      if( hOther &amp;&amp; IsWindow( hOther ) ) <br>      { <br>         SetForegroundWindow( hOther ); <br>         return 0; <br>      } <br> <br>      InitRealScreenSave(); <br>   } <br> <br>   if( RegisterClass( &amp;cls ) ) <br>   { <br>      hMainWindow = CreateWindowEx( uExStyle, pszWindowClass, pszWindowTitle, <br>                        uStyle, 0, 0, nCx, nCy, hParent, (HMENU)NULL, <br>                        hMainInstance, (LPVOID)NULL ); <br>   } <br> <br>   if( hMainWindow ) <br>   { <br>      if( !fChildPreview ) <br>         SetForegroundWindow( hMainWindow ); <br> <br>      while( GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>      { <br>         TranslateMessage( &amp;msg ); <br>         DispatchMessage( &amp;msg ); <br>      } <br>   } <br> <br>   // free password-handling DLL if loaded <br>   UnloadPwdDLL(); <br> <br>   return msg.wParam; <br>} <br>#endif <br> <br> <br>//---------------------------------------------------------------------------- <br> <br>static int <br>DoSaverPreview( LPCTSTR szUINTHandle ) <br>{ <br>   // get parent handle from string <br>   HWND hParent = (HWND)atoui( szUINTHandle ); <br> <br>   // only preview on a valid parent window (NOT full screen) <br>   return ( (hParent &amp;&amp; IsWindow( hParent ))? DoScreenSave( hParent ) : -1 ); <br>} <br> <br> <br>//---------------------------------------------------------------------------- <br> <br>#ifndef GL_SCRNSAVE <br> <br>static int <br>DoConfigBox( HWND hParent ) <br>{ <br>   // let the consumer register any special controls for the dialog <br>   if( !RegisterDialogClasses( hMainInstance ) ) <br>      return FALSE; <br> <br>   return DialogBox( hMainInstance, MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ), <br>                     hParent, (DLGPROC)ScreenSaverConfigureDialog ); <br>} <br>#endif <br> <br> <br>//---------------------------------------------------------------------------- <br> <br>static int <br>DoChangePw( LPCTSTR szUINTHandle ) <br>{ <br>   // get parent handle from string <br>   HWND hParent = (HWND)atoui( szUINTHandle ); <br> <br>   if( !hParent || !IsWindow( hParent ) ) <br>      hParent = GetForegroundWindow(); <br> <br>   // allow the library to be hooked <br>   ScreenSaverChangePassword( hParent ); <br>   return 0; <br>} <br> <br>static const TCHAR szMprDll[] = TEXT("MPR.DLL");       // not to be localized <br>static const TCHAR szProviderName[] = TEXT("SCRSAVE"); // not to be localized <br> <br>#ifdef UNICODE <br>static const CHAR szPwdChangePW[] = "PwdChangePasswordW"; // not to be localized <br>#else <br>static const CHAR szPwdChangePW[] = "PwdChangePasswordA"; // not to be localized <br>#endif <br> <br>// bogus prototype <br>typedef DWORD (FAR PASCAL *PWCHGPROC)( LPCTSTR, HWND, DWORD, LPVOID ); <br> <br>void WINAPI <br>ScreenSaverChangePassword( HWND hParent ) <br>{ <br>   HINSTANCE mpr = LoadLibrary( szMprDll ); <br> <br>   if( mpr ) <br>   { <br>      PWCHGPROC pwd = (PWCHGPROC)GetProcAddress( mpr, szPwdChangePW ); <br> <br>      if( pwd ) <br>         pwd( szProviderName, hParent, 0, NULL ); <br> <br>      FreeLibrary( mpr ); <br>   } <br>} <br> <br> <br>//---------------------------------------------------------------------------- <br> <br>static BOOL <br>DoPasswordCheck( HWND hParent ) <br>{ <br>   // don't reenter and don't check when we've already decided <br>   if( fCheckingPassword || fClosing ) <br>      return FALSE; <br> <br>   if( VerifyPassword ) <br>   { <br>      static DWORD lastcheck = (DWORD)-1; <br>      DWORD curtime = GetTickCount(); <br>      MSG msg; <br> <br>      if (dwPasswordDelay &amp;&amp; <br>         (GetElapsedTime(dwBlankTime, curtime) &lt; dwPasswordDelay)) <br>      { <br>         fClosing = TRUE; <br>         goto _didcheck; <br>      } <br> <br>      // no rapid checking... <br>      if ((lastcheck != (DWORD)-1) &amp;&amp; <br>         (GetElapsedTime(lastcheck, curtime) &lt; 200)) <br>      { <br>         goto _didcheck; <br>      } <br> <br>      // do the check <br>      fCheckingPassword = TRUE; <br> <br>#ifdef GL_SCRNSAVE <br>      // Put ss in idle mode during password dialog processing <br>      SendMessage( hParent, SS_WM_IDLE, SS_IDLE_ON, 0L ); <br>#endif <br> <br>      // flush WM_TIMER messages before putting up the dialog <br>      PeekMessage( &amp;msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD ); <br>      PeekMessage( &amp;msg, hParent, WM_TIMER, WM_TIMER, PM_REMOVE | PM_NOYIELD ); <br> <br>      // call the password verify proc <br>      fClosing = (BOOL)SendMessage( hParent, SCRM_VERIFYPW, 0, 0L ); <br> <br>      fCheckingPassword = FALSE; <br> <br>#ifdef GL_SCRNSAVE <br>      // Restore normal display mode <br>      SendMessage( hParent, SS_WM_IDLE, SS_IDLE_OFF, 0L ); <br>#endif <br> <br>      if (!fClosing) <br>         SetCursor(NULL); <br> <br>      // curtime may be outdated by now <br>      lastcheck = GetTickCount(); <br>   } <br>   else <br>   { <br>      // passwords disabled or unable to load handler DLL, always allow exit <br>      fClosing = TRUE; <br>   } <br> <br>_didcheck: <br>   return fClosing; <br>} <br> <br>//---------------------------------------------------------------------------- <br> <br>int _stdcall <br>DummyEntry( void ) <br>{ <br>    int i; <br>    STARTUPINFO si; <br>    LPTSTR pszCmdLine = GetCommandLine(); <br> <br>    if ( *pszCmdLine == TEXT('\"')) { <br>        /* <br>         * Scan, and skip over, subsequent characters until <br>         * another double-quote or a null is encountered. <br>         */ <br>        while (*(pszCmdLine = CharNext(pszCmdLine)) &amp;&amp; <br>              (*pszCmdLine != TEXT('\"')) ); <br>        /* <br>         * If we stopped on a double-quote (usual case), skip <br>         * over it. <br>         */ <br>        if ( *pszCmdLine == TEXT('\"') ) <br>            pszCmdLine++; <br>    } <br>    else { <br>        while ((UINT)*pszCmdLine &gt; (UINT)TEXT(' ')) <br>            pszCmdLine = CharNext(pszCmdLine); <br>    } <br> <br>    /* <br>     * Skip past any white space preceeding the second token. <br>     */ <br>    while (*pszCmdLine &amp;&amp; ((UINT)*pszCmdLine &lt;= (UINT)TEXT(' '))) { <br>        pszCmdLine = CharNext(pszCmdLine); <br>    } <br> <br>    si.dwFlags = 0; <br>    GetStartupInfo(&amp;si); <br> <br>    i = WinMainN(GetModuleHandle(NULL), NULL, pszCmdLine, <br>        si.dwFlags &amp; STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT); <br> <br>    ExitProcess(i); <br>    return i;   // We never comes here. <br>} <br> <br>//---------------------------------------------------------------------------- <br>// main() entry point to satisfy old NT screen savers <br>void _cdecl main( int argc, char *argv[] ) { <br>    DummyEntry(); <br>} <br> <br>//---------------------------------------------------------------------------- <br>// WinMain() entry point to satisfy old NT screen savers <br>int PASCAL WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR szCmdLine, int nCmdShow ) { <br>    DummyEntry(); <br>    return 0; <br> <br>    // reference unreferenced parameters <br>    (void)hInst; <br>    (void)hPrev; <br>    (void)szCmdLine; <br>    (void)nCmdShow; <br>} <br> <br> <br>VOID LoadPwdDLL(VOID) <br>{ <br>    HKEY hKey; <br> <br>    if (!fOnWin95) <br>        return; <br> <br>    if (hInstPwdDLL) <br>        UnloadPwdDLL(); <br> <br>    // look in registry to see if password turned on, otherwise don't <br>    // bother to load password handler DLL <br>    if (RegOpenKey(HKEY_CURRENT_USER,szScreenSaverKey,&amp;hKey) == <br>        ERROR_SUCCESS) <br>    { <br>        DWORD dwVal,dwSize=sizeof(dwVal); <br> <br>        if ((RegQueryValueEx(hKey,szPasswordActiveValue, <br>            NULL,NULL,(BYTE *) &amp;dwVal,&amp;dwSize) == ERROR_SUCCESS) <br>            &amp;&amp; dwVal) <br>        { <br> <br>            // try to load the DLL that contains password proc. <br>            hInstPwdDLL = LoadLibrary(szPwdDLL); <br>            if (hInstPwdDLL) <br>            { <br>                VerifyPassword = (VERIFYPWDPROC) GetProcAddress(hInstPwdDLL, <br>                    szFnName); <br> <br>                if( VerifyPassword ) <br>                    HogMachine( TRUE ); <br>                else <br>                    UnloadPwdDLL(); <br>            } <br>        } <br> <br>        RegCloseKey(hKey); <br>    } <br> <br>} <br> <br>VOID UnloadPwdDLL(VOID) <br>{ <br>    if (!fOnWin95) <br>        return; <br> <br>    if (hInstPwdDLL) <br>    { <br>        FreeLibrary(hInstPwdDLL); <br>        hInstPwdDLL = NULL; <br> <br>        if( VerifyPassword ) <br>        { <br>            VerifyPassword = NULL; <br>            HogMachine( FALSE ); <br>        } <br>    } <br>} <br> <br>//---------------------------------------------------------------------------- <br>// compatbility stuff  (to make porting easier) <br>TCHAR szAppName[ APPNAMEBUFFERLEN ]; <br>TCHAR szName[ TITLEBARNAMELEN ]; <br>TCHAR szIniFile[ MAXFILELEN ]; <br>TCHAR szScreenSaver[ 22 ]; <br>TCHAR szHelpFile[ MAXFILELEN ]; <br>TCHAR szNoHelpMemory[ BUFFLEN ]; <br> <br>// Quick fix for old screen savers that don't know about context <br>// sensitive help <br>UINT  MyHelpMessage = WM_HELP; </code></pre>
<p>&nbsp;</p></body>
</HTML>
