<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SLVMAZE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3733"></a>SLVMAZE.C</h2>
<pre><code>#include "pch.c" <br>#pragma hdrstop <br> <br>static int left_turn[SOL_DIRS] = <br>{ <br>    SOL_DIR_DOWN, SOL_DIR_LEFT, SOL_DIR_UP, SOL_DIR_RIGHT <br>}; <br> <br>static int right_turn[SOL_DIRS] = <br>{ <br>    SOL_DIR_UP, SOL_DIR_RIGHT, SOL_DIR_DOWN, SOL_DIR_LEFT <br>}; <br> <br>static BYTE dir_wall[SOL_DIRS] = <br>{ <br>    MAZE_WALL_LEFT, MAZE_WALL_UP, MAZE_WALL_RIGHT, MAZE_WALL_DOWN <br>}; <br> <br>static int dir_cloff[SOL_DIRS][2] = <br>{ <br>    -1,0, 0,-1, 1,0, 0,1 <br>}; <br> <br>static FaAngle dir_ang[SOL_DIRS]; <br>static FxPt2 dir_off[SOL_DIRS]; <br> <br>/* We want to traverse one quarter of a circle in the given number of <br>   steps.  The distance is the arc length which is r*pi/2.  Divide that <br>   by the number of steps to get the distance each step should travel */ <br>#define ARC_STEP 5 <br>#define ARC_STEPS (90/ARC_STEP) <br> <br>#define REVERSE_STEP (2*ARC_STEP) <br>#define REVERSE_STEPS (180/REVERSE_STEP) <br> <br>static void SetView(MazeSolution *sol, MazeView *vw) <br>{ <br>    vw-&gt;ang = dir_ang[sol-&gt;dir]; <br>    vw-&gt;pos.x = CellToMfx(sol-&gt;clx)+dir_off[sol-&gt;dir].x; <br>    vw-&gt;pos.y = CellToMfx(sol-&gt;cly)+dir_off[sol-&gt;dir].y; <br>} <br> <br>void SolveMazeSetGoals(MazeSolution *sol, MazeGoal *goals, int ngoals) <br>{ <br>    sol-&gt;goals = goals; <br>    sol-&gt;ngoals = ngoals; <br>} <br> <br>void SolveMazeStart(MazeView *vw, <br>                    Cell *maze, int w, int h, <br>                    IntPt2 *start, int start_dir, <br>                    MazeGoal *goals, int ngoals, <br>                    int turn_to, <br>                    MazeSolution *sol) <br>{ <br>    dir_ang[SOL_DIR_LEFT] = FaDeg(180); <br>    dir_ang[SOL_DIR_UP] = FaDeg(90); <br>    dir_ang[SOL_DIR_RIGHT] = FaDeg(0); <br>    dir_ang[SOL_DIR_DOWN] = FaDeg(270); <br> <br>    dir_off[SOL_DIR_LEFT].x = CellToMfx(1)-FX_MIN_VALUE; <br>    dir_off[SOL_DIR_LEFT].y = CellToMfx(1)/2; <br>    dir_off[SOL_DIR_UP].x = CellToMfx(1)/2; <br>    dir_off[SOL_DIR_UP].y = CellToMfx(1)-FX_MIN_VALUE; <br>    dir_off[SOL_DIR_RIGHT].x = FxVal(0); <br>    dir_off[SOL_DIR_RIGHT].y = CellToMfx(1)/2; <br>    dir_off[SOL_DIR_DOWN].x = CellToMfx(1)/2; <br>    dir_off[SOL_DIR_DOWN].y = FxVal(0); <br>     <br>    sol-&gt;clx = start-&gt;x; <br>    sol-&gt;cly = start-&gt;y; <br>    sol-&gt;dir = start_dir; <br>    sol-&gt;maze = maze; <br>    sol-&gt;w = w; <br>    sol-&gt;h = h; <br>    sol-&gt;ani_state = ANI_STATE_NONE; <br> <br>    switch(turn_to) <br>    { <br>    case SOL_TURN_RIGHT: <br>        sol-&gt;turn_to = left_turn; <br>        sol-&gt;turn_away = right_turn; <br>        sol-&gt;dir_sign = 1; <br>        break; <br> <br>    case SOL_TURN_LEFT: <br>        sol-&gt;turn_to = right_turn; <br>        sol-&gt;turn_away = left_turn; <br>        sol-&gt;dir_sign = -1; <br>        break; <br>    } <br> <br>    SolveMazeSetGoals(sol, goals, ngoals); <br>     <br>    SetView(sol, vw); <br>} <br> <br>#define MazeAt(x, y) (sol-&gt;maze+(x)+(y)*(sol-&gt;w)) <br> <br>MazeGoal *SolveMazeStep(MazeView *vw, MazeSolution *sol) <br>{ <br>    Cell *cell; <br>    int i, dir, turn_to; <br> <br>    if (sol-&gt;ani_state != ANI_STATE_NONE) <br>    { <br>        if (--sol-&gt;ani_count == 0) <br>        { <br>            sol-&gt;ani_state = ANI_STATE_NONE; <br>            SetView(sol, vw); <br>        } <br>    } <br>     <br>    switch(sol-&gt;ani_state) <br>    { <br>    case ANI_STATE_TURN_TO: <br>        vw-&gt;pos.x += FxMulDiv(FaCos(vw-&gt;ang), <br>                              FxFltVal(PI*MAZE_CELL_SIZE/2), <br>                              FxVal(ARC_STEPS*2)); <br>        vw-&gt;pos.y += FxMulDiv(FaSin(vw-&gt;ang), <br>                              FxFltVal(PI*MAZE_CELL_SIZE/2), <br>                              FxVal(ARC_STEPS*2)); <br>        vw-&gt;ang = FaAdd(vw-&gt;ang, sol-&gt;dir_sign*FaDeg(ARC_STEP)); <br>        return NULL; <br> <br>    case ANI_STATE_TURN_AWAY: <br>        vw-&gt;pos.x += FxMulDiv(FaCos(vw-&gt;ang), <br>                              FxFltVal(PI*MAZE_CELL_SIZE/2), <br>                              FxVal(ARC_STEPS*2)); <br>        vw-&gt;pos.y += FxMulDiv(FaSin(vw-&gt;ang), <br>                              FxFltVal(PI*MAZE_CELL_SIZE/2), <br>                              FxVal(ARC_STEPS*2)); <br>        vw-&gt;ang = FaAdd(vw-&gt;ang, sol-&gt;dir_sign * -FaDeg(ARC_STEP)); <br>        return NULL; <br> <br>    case ANI_STATE_FORWARD: <br>        vw-&gt;pos.x += FxMulDiv(FaCos(vw-&gt;ang), MAZE_CELL_SIZE, ARC_STEPS); <br>        vw-&gt;pos.y += FxMulDiv(FaSin(vw-&gt;ang), MAZE_CELL_SIZE, ARC_STEPS); <br>        return NULL; <br>         <br>    case ANI_STATE_REVERSE: <br>        vw-&gt;ang = FaAdd(vw-&gt;ang, sol-&gt;dir_sign*FaDeg(REVERSE_STEP)); <br>        return NULL; <br>    } <br> <br>    for (i = 0; i &lt; sol-&gt;ngoals; i++) <br>    { <br>        if (sol-&gt;clx == sol-&gt;goals[i].clx &amp;&amp; <br>            sol-&gt;cly == sol-&gt;goals[i].cly) <br>        { <br>            return &amp;sol-&gt;goals[i]; <br>        } <br>    } <br> <br>    cell = MazeAt(sol-&gt;clx, sol-&gt;cly); <br> <br>    dir = sol-&gt;dir; <br>    for (i = 0; i &lt; SOL_DIRS-1; i++) <br>    { <br>        turn_to = sol-&gt;turn_to[dir]; <br>        if ((dir_wall[turn_to] &amp; cell-&gt;can_see) == 0) <br>        { <br>            /* No wall present when turned, so turn that way */ <br>            sol-&gt;clx += dir_cloff[turn_to][0]; <br>            sol-&gt;cly += dir_cloff[turn_to][1]; <br>            sol-&gt;dir = turn_to; <br> <br>            sol-&gt;ani_count = ARC_STEPS; <br>            switch(i) <br>            { <br>            case 0: <br>                sol-&gt;ani_state = ANI_STATE_TURN_TO; <br>                break; <br> <br>            case 1: <br>                sol-&gt;ani_state = ANI_STATE_FORWARD; <br>                break; <br> <br>            case 2: <br>                sol-&gt;ani_state = ANI_STATE_TURN_AWAY; <br>                break; <br>            } <br>            break; <br>        } <br>        else <br>        { <br>            /* Wall present, turn away and check again */ <br>            dir = sol-&gt;turn_away[dir]; <br>        } <br>    } <br> <br>    if (i == SOL_DIRS-1) <br>    { <br>        /* Dead end.  Turn around */ <br>        dir = sol-&gt;turn_to[sol-&gt;turn_to[sol-&gt;dir]]; <br>        sol-&gt;clx += dir_cloff[dir][0]; <br>        sol-&gt;cly += dir_cloff[dir][1]; <br>        sol-&gt;dir = dir; <br> <br>        sol-&gt;ani_state = ANI_STATE_REVERSE; <br>        sol-&gt;ani_count = REVERSE_STEPS; <br>    } <br> <br>    return NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
