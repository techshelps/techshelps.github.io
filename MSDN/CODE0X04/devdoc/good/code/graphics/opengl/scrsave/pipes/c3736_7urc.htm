<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EVAL.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3738"></a>EVAL.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: eval.cxx <br>* <br>* Evaluator stuff <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/glaux.h&gt; <br> <br>#include "sscommon.h" <br>#include "sspipes.h" <br>#include "eval.h" <br> <br>//#define EVAL_DBG 1 <br> <br>typedef enum { <br>    X_PLANE = 0, <br>    Y_PLANE, <br>    Z_PLANE <br>}; <br> <br>#define EVAL_VSIZE 3  // vertex size in floats <br> <br>#define TMAJOR_ORDER 2 <br>#define TMINOR_ORDER 2 <br> <br>#define VDIM 3 <br>#define TDIM 2 <br> <br>//forwards <br>#if EVAL_DBG <br>static void DrawPoints( int num, POINT3D *pts ); <br>#endif <br>static void RotatePointSet( POINT3D *inPts, int numPts, float angle, int dir,  <br>                      float radius, POINT3D *outPts ); <br>static void ExtrudePointSetDir( POINT3D *inPts, int numPts, float *acPts,  <br>                      int dir, POINT3D *outPts ); <br> <br> <br>/**************************************************************************\ <br>* EVAL <br>* <br>* Evaluator constructor <br>*  <br>\**************************************************************************/ <br> <br>EVAL::EVAL( BOOL bTex ) <br>{ <br>    bTexture = bTex;  <br> <br>    // Allocate points buffer <br> <br>// might want to use less than max in some cases <br>    int size = MAX_USECTIONS * MAX_UORDER * MAX_VORDER * sizeof(POINT3D); <br>    pts = (POINT3D *) LocalAlloc( LMEM_FIXED, size ); <br>    SS_ASSERT( pts != NULL, "EVAL constructor\n" ); <br>     <br>    // Alloc texture points buffer <br> <br>    if( bTexture ) { <br>        size = MAX_USECTIONS * TEX_ORDER * TEX_ORDER * sizeof(TEX_POINT2D); <br>        texPts = (TEX_POINT2D *) LocalAlloc( LMEM_FIXED, size ); <br>        SS_ASSERT( texPts != NULL, "EVAL constructor\n" ); <br>    } <br>     <br>    ResetEvaluator( bTexture ); <br>} <br> <br>/**************************************************************************\ <br>* ~EVAL <br>* <br>* Evaluator destructor <br>* <br>* Frees up memory <br>* <br>\**************************************************************************/ <br> <br>EVAL::~EVAL( ) <br>{ <br>    LocalFree( pts ); <br>    if( bTexture ) <br>        LocalFree( texPts ); <br>} <br> <br>/**************************************************************************\ <br>* Reset <br>* <br>* Reset evaluator to generate 3d vertices and vertex normals <br>* <br>\**************************************************************************/ <br> <br>void <br>ResetEvaluator( BOOL bTexture ) <br>{ <br>    if( bTexture ) { <br>        glEnable( GL_MAP2_TEXTURE_COORD_2 ); <br>    } <br>    glEnable( GL_MAP2_VERTEX_3 ); <br>    glEnable( GL_AUTO_NORMAL ); <br>    glFrontFace( GL_CW ); // cuz <br>// if mixing Normal and Flex, have to watch out for this, cuz normal <br>// needs CCW <br>} <br> <br>/**************************************************************************\ <br>* SetTextureControlPoints <br>* <br>* Set texture control point net <br>* <br>* This sets up 'numSections' sets of texture coordinate control points, based <br>* on starting and ending s and t values. <br>* <br>* s coords run along pipe direction, t coords run around circumference <br>* <br>\**************************************************************************/ <br> <br>void <br>EVAL::SetTextureControlPoints( float s_start, float s_end,  <br>                              float t_start, float t_end ) <br>{ <br>    int i; <br>    TEX_POINT2D *ptexPts = texPts; <br>    GLfloat t_delta = (t_end - t_start) / numSections; <br>    GLfloat t = t_start; <br> <br>    // calc ctrl pts for each quadrant <br>    for( i = 0; i &lt; numSections; i++, ptexPts += (TDIM*TDIM) ) { <br>        // s, t coords <br>        ptexPts[0].t = ptexPts[2].t = t; <br>        t += t_delta; <br>        ptexPts[1].t = ptexPts[3].t = t; <br>        ptexPts[0].s = ptexPts[1].s = s_start; <br>        ptexPts[2].s = ptexPts[3].s = s_end; <br>    }  <br>} <br> <br>/**************************************************************************\ <br>* SetVertexCtrlPtsXCTranslate <br>* <br>* Builds 3D control eval control net from 2 xcObjs displaced along the <br>* z-axis by 'length'. <br>*  <br>* First xc used to generate points in z=0 plane. <br>* Second xc generates points in z=length plane. <br>* ! Replicates the last point around each u. <br>* <br>\**************************************************************************/ <br> <br>void  <br>EVAL::SetVertexCtrlPtsXCTranslate( POINT3D *pts, float length,  <br>                             XC *xcStart, XC *xcEnd ) <br>{ <br>    int i; <br>    POINT2D *ptsStart, *ptsEnd; <br>    POINT3D *pts1, *pts2; <br>    int     numPts = xcStart-&gt;numPts; <br> <br>    numPts++;  // due to last point replication <br> <br>    ptsStart = xcStart-&gt;pts; <br>    ptsEnd   = xcEnd-&gt;pts; <br>    pts1     = pts; <br>    pts2     = pts + numPts; <br> <br>    for( i = 0; i &lt; (numPts-1); i++, pts1++, pts2++ ) { <br>        // copy over x,y from each xc <br>        *( (POINT2D *) pts1) = *ptsStart++; <br>        *( (POINT2D *) pts2) = *ptsEnd++; <br>        // set z for each <br>        pts1-&gt;z = 0.0f; <br>        pts2-&gt;z = length; <br>    } <br> <br>    // Replicate last point in each u-band <br>    *pts1 = *pts; <br>    *pts2 = *(pts + numPts); <br>} <br> <br>/**************************************************************************\ <br>* ProcessXCPrimLinear <br>* <br>* Processes a prim according to evaluator data <br>* <br>* - Only valid for colinear xc's (along z) <br>* - XC's may be identical (extrusion).  If not identical, may have <br>*   discontinuities at each end. <br>* - Converts 2D XC pts to 3D pts <br>* <br>\**************************************************************************/ <br> <br>void  <br>EVAL::ProcessXCPrimLinear( XC *xcStart, XC *xcEnd, float length ) <br>{ <br>    if( length &lt;= 0.0f ) <br>        // nuttin' to do <br>        return; <br> <br>    // Build a vertex control net from 2 xcObj's a distance 'length' apart <br>    // this will displace the end xcObj a distance 'length' down the z-axis <br>    SetVertexCtrlPtsXCTranslate( pts, length, xcStart, xcEnd ); <br> <br>    Evaluate( ); <br>} <br> <br>/**************************************************************************\ <br>* ProcessXCPrimBendSimple <br>* <br>* Processes a prim by bending along dir from xcCur <br>* <br>* - dir is relative from xc in x-y plane <br>* - adds C2 continuity at ends <br>* <br>\**************************************************************************/ <br> <br>void  <br>EVAL::ProcessXCPrimBendSimple( XC *xcCur, int dir, float radius ) <br>{ <br>    POINT3D *ptsSrc, *ptsDst; <br>    static float acPts[MAX_XC_PTS+1]; <br>    int ptSetStride = xcCur-&gt;numPts + 1; // pt stride for output pts buffer <br> <br>    // We will be creating 4 cross-sectional control point sets here. <br> <br>    // Convert 2D pts in xcCur to 3D pts at z=0 for 1st point set <br>    xcCur-&gt;ConvertPtsZ( pts, 0.0f ); <br> <br>    // Calc 4th point set by rotating 1st set as per dir <br>    ptsDst = pts + 3*ptSetStride; <br>    RotatePointSet( pts, ptSetStride, 90.0f, dir, radius, ptsDst ); <br> <br>    // angles != 90, hard, cuz not easy to extrude 3rd set from 4th <br> <br>    // Next, have to figure out ac values.  Need to extend each xc's points <br>    // into bend to generate ac net.  For circular bend (and later for general <br>    // case elliptical bend), need to know ac distance from xc for each point. <br>    // This is based on the point's turn radius - a function of its distance <br>    // from the 'hinge' of the turn. <br> <br>    // Can take advantage of symmetry here.  Figure for one xc, good for 2nd. <br>    // This assumes 90 deg turn.  (also,last point replicated) <br>    xcCur-&gt;CalcArcACValues90( dir, radius, acPts ); <br>     <br>    // 2) extrude each point's ac from xcCur (extrusion in +z) <br>    // apply values to 1st to get 2nd <br>    // MINUS_Z, cuz subtracts *back* from dir <br>    ExtrudePointSetDir( pts, ptSetStride, acPts, MINUS_Z,  <br>                                                    pts + ptSetStride ); <br> <br>    // 3) extrude each point's ac from xcEnd (extrusion in -dir) <br>    ptsSrc = pts + 3*ptSetStride; <br>    ptsDst = pts + 2*ptSetStride; <br>    ExtrudePointSetDir( ptsSrc, ptSetStride, acPts, dir, ptsDst ); <br> <br>    Evaluate(); <br>} <br> <br>/**************************************************************************\ <br>* eval_ProcessXCPrimSingularity <br>* <br>* Processes a prim by joining singularity to an xc <br>* <br>* - Used for closing or opening the pipe <br>* - If bOpening is true, starts with singularity, otherwise ends with one <br>* - the xc side is always in z=0 plane <br>* - singularity side is radius on either side of xc <br>* - adds C2 continuity at ends (perpendicular to +z at singularity end) <br>* <br>\**************************************************************************/ <br> <br>void  <br>EVAL::ProcessXCPrimSingularity( XC *xcCur, float length, BOOL bOpening ) <br>{ <br>    POINT3D *ptsSing, *ptsXC; <br>    static float acPts[MAX_XC_PTS+1]; <br>    float zSing; // z-value at singularity <br>    int ptSetStride = xcCur-&gt;numPts + 1; // pt stride for output pts buffer <br>    int i; <br>    XC xcSing(xcCur); <br> <br>    // create singularity xc - which is an extremely scaled-down version <br>    //  of xcCur (this prevents any end-artifacts, unless of course we were <br>    //  to zoom it ultra-large). <br> <br>    xcSing.Scale( .0005f ); <br> <br>    // We will be creating 4 cross-sectional control point sets here. <br> <br>    if( bOpening ) { <br>        ptsSing = pts; <br>        ptsXC = pts + 3*ptSetStride; <br>    } else { <br>        ptsSing = pts + 3*ptSetStride; <br>        ptsXC = pts; <br>    } <br> <br>    // Convert 2D pts in xcCur to 3D pts at 'xc' point set <br>    xcCur-&gt;ConvertPtsZ( ptsXC, 0.0f ); <br> <br>    // Set z-value for singularity point set <br>    zSing = bOpening ? -length : length; <br>    xcSing.ConvertPtsZ( ptsSing, zSing ); <br> <br>    // The arc control for each point is based on a radius value that is <br>    //  each xc point's distance from the xc center <br>    xcCur-&gt;CalcArcACValuesByDistance( acPts ); <br> <br>    // Calculate point set near xc <br>    if( bOpening ) <br>        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, PLUS_Z,  <br>                                                    ptsXC - ptSetStride ); <br>    else <br>        ExtrudePointSetDir( ptsXC, ptSetStride, acPts, MINUS_Z,  <br>                                                    ptsXC + ptSetStride ); <br> <br>    // Point set near singularity is harder, as the points must generate <br>    // a curve between the singularity and each xc point <br>    // No, easier, just scale each point by universal arc controller ! <br>    POINT3D *ptsDst = pts; <br>    ptsDst = bOpening ? ptsSing + ptSetStride : ptsSing - ptSetStride; <br>    for( i = 0; i &lt; ptSetStride; i ++, ptsDst++ ) { <br>        ptsDst-&gt;x = EVAL_CIRC_ARC_CONTROL * ptsXC[i].x; <br>        ptsDst-&gt;y = EVAL_CIRC_ARC_CONTROL * ptsXC[i].y; <br>        ptsDst-&gt;z = zSing; <br>    } <br> <br>    Evaluate(); <br>} <br> <br>/**************************************************************************\ <br>* Evaluate <br>* <br>* Evaluates the EVAL object <br>* <br>* - There may be 1 or more lengthwise sections around an xc <br>* - u is minor, v major <br>* - u,t run around circumference, v,s lengthwise <br>* - Texture maps are 2x2 for each section <br>* - ! uDiv is per section ! <br>* <br>\**************************************************************************/ <br> <br>void  <br>EVAL::Evaluate( ) <br>{ <br>    int i; <br>    POINT3D *ppts = pts;  <br>    TEX_POINT2D *ptexPts = texPts; <br>    // total # pts in cross-section: <br>    int xcPointCount = (uOrder-1)*numSections + 1; <br> <br>    for( i = 0; i &lt; numSections; i ++,  <br>                                       ppts += (uOrder-1), <br>                                       ptexPts += (TEX_ORDER*TEX_ORDER) ) { <br> <br>        // map texture coords <br> <br>        if( bTexture ) { <br>            glMap2f(GL_MAP2_TEXTURE_COORD_2,  <br>                    0.0f, 1.0f, TDIM, TEX_ORDER,  <br>                    0.0f, 1.0f, TEX_ORDER*TDIM, TEX_ORDER,  <br>                    (GLfloat *) ptexPts ); <br>        } <br> <br>        // map vertices <br> <br>        glMap2f(GL_MAP2_VERTEX_3,  <br>               0.0f, 1.0f, VDIM, uOrder,  <br>               0.0f, 1.0f, xcPointCount*VDIM, vOrder, <br>               (GLfloat *) ppts ); <br> <br>        // evaluate <br> <br>        glMapGrid2f(uDiv, 0.0f, 1.0f, vDiv, 0.0f, 1.0f); <br>        glEvalMesh2( GL_FILL, 0, uDiv, 0, vDiv); <br>    } <br>} <br> <br>#if EVAL_DBG <br>/**************************************************************************\ <br>* DrawPoints <br>* <br>* draw control points <br>* <br>\**************************************************************************/ <br>static  <br>void DrawPoints( int num, POINT3D *pts ) <br>{ <br>    GLint i; <br> <br>    // draw green pts for now <br>    glColor3f(0.0f, 1.0f, 0.0f); <br>    glPointSize(2); <br> <br>    glBegin(GL_POINTS); <br>        for (i = 0; i &lt; num; i++, pts++) { <br>            glVertex3fv( (GLfloat *) pts ); <br>        } <br>    glEnd(); <br>} <br>#endif <br> <br>/**************************************************************************\ <br>* ExtrudePointSetDir <br>* <br>* Extrude a point set back from the current direction <br>* <br>* Generates C2 continuity at the supplied point set xc, by generating another <br>* point set back of the first, using supplied subtraction values. <br>* <br>\**************************************************************************/ <br> <br>static void <br>ExtrudePointSetDir( POINT3D *inPts, int numPts, float *acPts, int dir,  <br>                    POINT3D *outPts ) <br>{ <br>    int i; <br>    float sign; <br>    int offset; <br> <br>    switch( dir ) { <br>        case PLUS_X: <br>            offset = 0; <br>            sign = -1.0f; <br>            break; <br>        case MINUS_X: <br>            offset = 0; <br>            sign =  1.0f; <br>            break; <br>        case PLUS_Y: <br>            offset = 1; <br>            sign = -1.0f; <br>            break; <br>        case MINUS_Y: <br>            offset = 1; <br>            sign =  1.0f; <br>            break; <br>        case PLUS_Z: <br>            offset = 2; <br>            sign = -1.0f; <br>            break; <br>        case MINUS_Z: <br>            offset = 2; <br>            sign =  1.0f; <br>            break; <br>    } <br> <br>    for( i = 0; i &lt; numPts; i++, inPts++, outPts++, acPts++ ) { <br>        *outPts = *inPts; <br>        ((float *)outPts)[offset] = ((float *)inPts)[offset] + (sign * (*acPts)); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* RotatePointSet <br>* <br>* Rotate point set by angle, according to dir and radius <br>* <br>* - Put points in supplied outPts buffer <br>* <br>\**************************************************************************/ <br> <br>static void  <br>RotatePointSet( POINT3D *inPts, int numPts, float angle, int dir,  <br>                      float radius, POINT3D *outPts ) <br>{ <br>    MATRIX matrix1, matrix2, matrix3; <br>    int i; <br>    POINT3D rot = {0.0f}; <br>    POINT3D anchor = {0.0f}; <br> <br>    /* dir      rot <br>       +x       90 y <br>       -x       -90 y <br>       +y       -90 x <br>       -y       90 x <br>    */ <br> <br>    // convert angle to radians <br>    //mf: as noted in objects.c, we have to take negative angle to make <br>    // it work in familiar 'CCW rotation is positive' mode.  The ss_* rotate <br>    // routines must work in the 'CW is +'ve' mode, as axis pointing at you. <br>    angle = SS_DEG_TO_RAD(-angle); <br> <br>    // set axis rotation and anchor point <br> <br>    switch( dir ) { <br>        case PLUS_X: <br>            rot.y = angle; <br>            anchor.x = radius; <br>            break; <br>        case MINUS_X: <br>            rot.y = -angle; <br>            anchor.x = -radius; <br>            break; <br>        case PLUS_Y: <br>            rot.x = -angle; <br>            anchor.y = radius; <br>            break; <br>        case MINUS_Y: <br>            rot.x = angle; <br>            anchor.y = -radius; <br>            break; <br>    } <br> <br>    // translate anchor point to origin <br>    ss_matrixIdent( &amp;matrix1 ); <br>    ss_matrixTranslate( &amp;matrix1, -anchor.x, -anchor.y, -anchor.z ); <br> <br>    // rotate  <br>    ss_matrixIdent( &amp;matrix2 ); <br>    ss_matrixRotate( &amp;matrix2, (double) rot.x, rot.y, rot.z ); <br> <br>    // concat these 2 <br>    ss_matrixMult( &amp;matrix3, &amp;matrix2, &amp;matrix1 ); <br> <br>    // translate back <br>    ss_matrixIdent( &amp;matrix2 ); <br>    ss_matrixTranslate( &amp;matrix2,  anchor.x,  anchor.y,  anchor.z ); <br> <br>    // concat these 2 <br>    ss_matrixMult( &amp;matrix1, &amp;matrix2, &amp;matrix3 ); <br> <br>    for( i = 0; i &lt; numPts; i ++, outPts++, inPts++ ) { <br>        ss_xformPoint( outPts, inPts, &amp;matrix1 ); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
