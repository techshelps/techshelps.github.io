<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GLSCRNSV.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3696"></a>GLSCRNSV.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: glscrnsv.c <br>* <br>* Companion file to scrnsave.c.  Hooks out any changes in functionality <br>* defined as GL_SCRNSAVE in scrnsave.c, and does general intialization. <br>* <br>* Copyright 1996 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "scrnsave.h" <br> <br>#include "glscrnsv.h" <br>#include "ssintrnl.hxx" <br>#include "sswindow.hxx" <br>#include "glscrnsv.hxx" <br>#include "sswproc.hxx" <br> <br>static UINT (*KeyDownFunc)(int)        = NULL; <br> <br>// Global ptr to screen saver instance <br>SCRNSAVE *gpss = NULL; <br> <br>// Global strings. <br>#define GEN_STRING_SIZE 64 <br>TCHAR szScreenSaverTitle[GEN_STRING_SIZE]; <br>extern TCHAR szClassName[];  // from sswindow.cxx <br>LPCTSTR pszWindowClass = TEXT("WindowsScreenSaverClass");  // main class name <br>TCHAR szClassName[] = TEXT("ScreenSaverClass"); // child class name <br> <br>// forward declarations of internal fns <br>static BOOL RegisterMainClass( WNDPROC wndProc, HBRUSH hbrBg, HCURSOR hCursor ); <br>static BOOL RegisterChildClass(); <br>static BOOL AttemptResolutionSwitch( int width, int height, ISIZE *pNewSize ); <br> <br>// externs <br>extern void InitRealScreenSave(); // scrnsave.cxx <br>extern LRESULT WINAPI <br>    RealScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam ); <br>extern VOID UnloadPwdDLL(VOID);  <br>extern BOOL GLScreenSaverConfigureDialog( HWND hDlg, UINT msg, WPARAM wParam, <br>                              LPARAM lParam ); // sswproc.cxx <br> <br>#ifdef SS_INITIAL_CLEAR <br>static void InitialClear( PSSW *pssw ); <br>#endif <br> <br>#ifdef SS_WIN95 <br>#define SS_WIN95_MULTIWINDOW_WORKAROUND 1 <br>#define SS_WIN95_DESKTOP_REDRAW_FIX 1 <br>static BOOL bPowerSaveEnabled(); <br>#endif <br> <br>/**************************************************************************\ <br>* GLDoScreenSave <br>* <br>* Runs the screen saver in the specified mode <br>* <br>* GL version of DoScreenSave in scrnsave.c <br>* <br>* Does basic init, creates initial set of windows, and starts the message <br>* loop, which runs until terminated by some event. <br>* <br>\**************************************************************************/ <br> <br>static int <br>GLDoScreenSave( int winType, LPARAM lParam ) <br>{ <br>    MSG msg; <br> <br>    // Create screen saver instance - this calls ss_Init() <br>    SCRNSAVE ss( winType, lParam ); <br> <br>    // Setup all the windows and start the message loop <br> <br>    if( ss.SetupInitialWindows() ) <br>    { <br>        // Send message to main window to start the drawing timer <br>#ifdef SS_DELAYED_START_KLUGE <br>        // Kluge to work around 'window-not-ready' problem in child <br>        // preview mode - trigger off of WM_PAINT instead <br>        if( ! SS_DELAY_START(winType) ) <br>            SendMessage( ss.psswMain-&gt;hwnd, SS_WM_START, 0, 0 ); <br>#else <br>        SendMessage( ss.psswMain-&gt;hwnd, SS_WM_START, 0, 0 ); <br>#endif <br> <br>        while( GetMessage( &amp;msg, NULL, 0, 0 ) ) <br>        { <br>            TranslateMessage( &amp;msg ); <br>            DispatchMessage( &amp;msg ); <br>        } <br>    } <br> <br>    // We're done - screen saver exiting. <br> <br>    // free password-handling DLL if loaded <br>    UnloadPwdDLL(); <br> <br>    return msg.wParam; <br>} <br> <br>/**************************************************************************\ <br>* SCRNSAVE constructors <br>* <br>\**************************************************************************/ <br> <br>SCRNSAVE::SCRNSAVE( int typeArg, LPARAM lParam ) <br>{ <br>    type = typeArg; <br>    initParam = lParam; <br>    Init(); <br>} <br> <br>SCRNSAVE::SCRNSAVE( int typeArg ) <br>{ <br>    type = typeArg; <br>    initParam = 0; <br>    Init(); <br>} <br> <br>void <br>SCRNSAVE::Init() <br>{ <br>    psswMain    = NULL; <br>    psswGL      = NULL; <br>    bResSwitch  = FALSE; <br>    pssc        = NULL; <br>    pssPal      = NULL; <br>    flags       = 0; <br>#ifdef SS_DEBUG <br>    bDoTiming   = type == SS_TYPE_NORMAL ? TRUE : FALSE; <br>#endif <br> <br>    // Global ptr to the screen saver instance <br>    gpss = this; <br> <br>    // Platform detections <br> <br>    ss_QueryOSVersion(); <br> <br>    // Initialize randomizer <br> <br>    ss_RandInit(); <br> <br>    // Create multi-purpose black bg brush <br> <br>    hbrBg = (HBRUSH) GetStockObject( BLACK_BRUSH ); <br> <br>    // Call client ss's init function, to get ptr to its configuration <br>    // request <br> <br>    if( type == SS_TYPE_CONFIG ) { <br>        // This case handled differently <br>        return; <br>    } <br> <br>    pssc = ss_Init(); <br>    SS_ASSERT( pssc, "SCRNSAVE constructor failure\n" ); <br> <br>    // Set GL config structure from pssc <br>     <br>    GLc.pfFlags = 0; <br>    GLc.hrc = 0; <br>    GLc.pStretch = NULL; <br>    switch( pssc-&gt;depthType ) { <br>        case SS_DEPTH16 : <br>            GLc.pfFlags |= SS_DEPTH16_BIT; <br>            break; <br>        case SS_DEPTH32 : <br>            GLc.pfFlags |= SS_DEPTH32_BIT; <br>            break; <br>    } <br>    if( pssc-&gt;bDoubleBuf ) <br>        GLc.pfFlags |= SS_DOUBLEBUF_BIT; <br>    if( pssc-&gt;bStretch ) <br>        GLc.pStretch = &amp;pssc-&gt;stretchInfo; <br> <br>} <br> <br>/**************************************************************************\ <br>* SetupInitialWindows <br>* <br>* Create / Configure all required windows. <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>SCRNSAVE::SetupInitialWindows() <br>{ <br>    // Create the windows <br> <br>    if( ! CreateInitialWindows() ) { <br>        SS_WARNING( "SCRNSAVE:: Couldn't create windows\n" ); <br>        return FALSE; <br>    } <br> <br>    // Initial window clear <br> <br>#ifdef SS_INITIAL_MAIN_WINDOW_CLEAR <br>    if( type == SS_TYPE_PREVIEW ) { <br>    // Make sure the screen is cleared to black before we start drawing <br>    // anything, as sometimes the background WM_PAINT doesn't get to us right <br>    // away.  This is only a problem in preview mode <br>       psswMain-&gt;GdiClear(); <br>    } <br>#endif <br> <br>    // Configure and Init the windows, if applicable <br> <br>#ifdef SS_DELAYED_START_KLUGE <br>    // delay start for some configurations <br>    if( ! SS_DELAY_START(type) ) { <br>        SendMessage( psswMain-&gt;hwnd, SS_WM_INITGL, 0, 0 ); <br>    } <br>#else <br>    SendMessage( psswMain-&gt;hwnd, SS_WM_INITGL, 0, 0 ); <br>#endif // SS_DELAYED_START_KLUGE <br> <br>    return TRUE; <br>} <br> <br> <br> <br>/**************************************************************************\ <br>* CreateInitialWindows <br>* <br>* Create the intitial set of windows. <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>SCRNSAVE::CreateInitialWindows() <br>{ <br>    PSSW    pssw; <br> <br>    if( !pssc ) <br>        return FALSE; <br> <br>    // Handle any request for resolution change <br> <br>#define SS_RESOLUTION_SWITCH 1 <br>#ifdef SS_RESOLUTION_SWITCH <br>    if( pssc-&gt;bStretch &amp;&amp; (type == SS_TYPE_FULLSCREEN)  <br>        &amp;&amp; ss_fOnWin95() ) { <br> <br>        STRETCH_INFO *pStretch = &amp;pssc-&gt;stretchInfo; <br>        ISIZE newSize; <br> <br>        // Try and change screen resolution to match stretch size <br>        bResSwitch = AttemptResolutionSwitch( pStretch-&gt;baseWidth,  <br>                                               pStretch-&gt;baseHeight, &amp;newSize );  <br>        // Is stretching still necessary if resolution changed ? <br>        if( bResSwitch ) { <br>            if( (newSize.width == pStretch-&gt;baseWidth) &amp;&amp; <br>                (newSize.height == pStretch-&gt;baseHeight) )  <br>                // exact match, no stretching now necessary <br>                pssc-&gt;bStretch = FALSE; <br>        } <br>    } <br>#endif <br> <br>    // Currently the bitmaps used in stretch mode don't support palette <br>    // messages, so disable any stretching when in PREVIEW mode (where we <br>    // need to support palette interaction). <br>    // actually this is only a consideration in 8-bit mode... <br> <br>    if( (type == SS_TYPE_PREVIEW) &amp;&amp; pssc-&gt;bStretch ) <br>        pssc-&gt;bStretch = FALSE; <br> <br>    // Create the main ss window <br> <br>    if( ! CreateMainWindow() ) <br>        return FALSE; <br> <br>#ifdef SS_INITIAL_CLEAR <br>    // If main window is transparent, can do an initial clear here before <br>    // any other windows are created or palettes modified <br>    // This is bogus on NT, as system switches to secure desktop when screen <br>    // saver kicks in automatically. <br>    InitialClear( pssw ); <br>#endif <br> <br>    // For now, simple window environment is described by pssc, so things <br>    // like bFloater and bStretch are mutually exclusive. <br> <br>    SS_GL_CONFIG *pGLc = &amp;gpss-&gt;GLc; <br> <br>    if( pssc-&gt;bFloater ) { <br> <br>        if( !(pssw = CreateChildWindow( &amp;pssc-&gt;floaterInfo )) ) <br>            return FALSE; <br> <br>        pssw-&gt;pGLc = pGLc; <br>        psswGL = pssw; // support old-style <br>    } else { <br>        psswMain-&gt;pGLc = pGLc; <br>        psswGL = psswMain; // support old-style <br>    } <br> <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* NormalWindowScreenSaverProc <br>* <br>* Highest level window proc, used only in normal window (/w) mode. <br>* <br>\**************************************************************************/ <br> <br>LRESULT WINAPI <br>NormalWindowScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam ) <br>{ <br>   switch( uMsg ) <br>   { <br>      case WM_SETTEXT: <br>         // RealScreenSaverProc won't allow this - bypass it <br>         return ScreenSaverProc( hWnd, uMsg, wParam, lParam ); <br> <br>      case WM_CHAR: <br>            if( KeyDownFunc ) { <br>                int key = wParam; <br>                (*KeyDownFunc)(key); <br>            } <br>            break; <br>                     <br>      case WM_KEYDOWN: <br>            if( wParam == VK_ESCAPE ) { <br>                PostMessage( hWnd, WM_CLOSE, 0, 0l ); <br>                break; <br>            } else if( KeyDownFunc ) { <br>                (*KeyDownFunc)(wParam); <br>                return 0; <br>            } <br>            return 0; // ?? <br> <br>      default: <br>         break; <br>   } <br> <br>   return RealScreenSaverProc( hWnd, uMsg, wParam, lParam ); <br>} <br> <br>/**************************************************************************\ <br>* DoScreenSave <br>* <br>* Hooked out version of DoScreenSave in standard scrnsave.c <br>* <br>\**************************************************************************/ <br> <br>int <br>DoScreenSave( HWND hwndParent ) <br>{ <br>    return GLDoScreenSave( hwndParent ? SS_TYPE_PREVIEW : SS_TYPE_FULLSCREEN,  <br>                           (LPARAM) hwndParent ); <br>} <br> <br>/**************************************************************************\ <br>* DoWindowedScreenSave <br>* <br>* Called when screen saver invoked with /w (window mode) parameter <br>* <br>\**************************************************************************/ <br> <br>int <br>DoWindowedScreenSave( LPCTSTR szArgs ) <br>{ <br>    return GLDoScreenSave( SS_TYPE_NORMAL, (LPARAM) szArgs ); <br>} <br> <br>/**************************************************************************\ <br>* DoConfigBox <br>* <br>* Hooked out version of DoConfigBox in standard scrnsave.c <br>* <br>\**************************************************************************/ <br> <br>int <br>DoConfigBox( HWND hwndParent ) <br>{ <br>    // let the consumer register any special controls for the dialog <br>    if( !RegisterDialogClasses( hMainInstance ) ) <br>        return FALSE; <br> <br>    // Create screen saver instance <br>    SCRNSAVE ss( SS_TYPE_CONFIG ); <br> <br>    int retVal = DialogBox( hMainInstance,  <br>                           MAKEINTRESOURCE( DLG_SCRNSAVECONFIGURE ), <br>                           hwndParent, (DLGPROC)GLScreenSaverConfigureDialog ); <br> <br>    return retVal; <br>} <br> <br>/**************************************************************************\ <br>* CreateMainWindow <br>* <br>* Creates main screen saver window based on the window type <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SCRNSAVE::CreateMainWindow() <br>{ <br>    WNDPROC  wndProc; <br>    int      nCx, nCy; <br>    ISIZE    size; <br>    UINT     uStyle = 0; <br>    UINT     uExStyle = 0; <br>    IPOINT2D pos; <br>    LPCTSTR  pszWindowTitle; <br>    HCURSOR  hCursor = NULL; <br>    HBRUSH   hbrBgMain; <br>    PSSW     pssw; <br>    HWND    hwndParent = NULL; <br>    <br>    wndProc = RealScreenSaverProc; <br> <br>    switch( type ) { <br>        case SS_TYPE_FULLSCREEN: <br>          { <br>            HWND hOther; <br> <br>            nCx = GetSystemMetrics( SM_CXSCREEN ); <br>            nCy = GetSystemMetrics( SM_CYSCREEN ); <br>#ifdef SS_DEBUG <br>//#define SS_FULLSCREEN_DEBUG 1 <br>#ifdef SS_FULLSCREEN_DEBUG <br>            // Reduce window size so we can see debugger <br>            nCx /= 2; <br>            nCy /= 2; <br>#endif <br>#endif <br>            uStyle = WS_POPUP | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS; <br>            uExStyle = WS_EX_TOPMOST; <br> <br>            pszWindowTitle = TEXT("Screen Saver"); // MUST differ from preview <br> <br>            // if there is another NORMAL screen save instance, switch to it <br>            hOther = FindWindow( szClassName, pszWindowTitle ); <br> <br>            if( hOther &amp;&amp; IsWindow( hOther ) ) <br>            { <br>               SetForegroundWindow( hOther ); <br>               return FALSE; <br>            } <br> <br>            InitRealScreenSave(); <br>          } <br>          break; <br> <br>        case SS_TYPE_PREVIEW: <br>          { <br>            RECT rcParent; <br> <br>            hwndParent = (HWND) initParam; <br> <br>            GetClientRect( hwndParent, &amp;rcParent ); <br>     <br>            fChildPreview = TRUE; <br>            nCx = rcParent.right; <br>            nCy = rcParent.bottom; <br>            uStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN; <br> <br>            pszWindowTitle = TEXT("Preview");   // MUST differ from full screen <br>          } <br>          break; <br> <br>        case SS_TYPE_NORMAL: <br> <br>          { <br>            // We set fChildPreview even when we're running in a normal window, <br>            // as this flag is used in scrnsave.c to differentiate from full <br>            // screen. <br>            fChildPreview = TRUE; <br> <br>            // init size to half screen by default <br>            nCx = GetSystemMetrics( SM_CXSCREEN ) &gt;&gt; 1; <br>            nCy = GetSystemMetrics( SM_CYSCREEN ) &gt;&gt; 1; <br> <br>            if( initParam ) { <br>                // get size of window from args <br>                LPCTSTR szArgs = (LPCTSTR) initParam; <br>            } <br>                 <br>            LoadString(hMainInstance, IDS_DESCRIPTION, szScreenSaverTitle,  <br>               sizeof(szScreenSaverTitle) / sizeof(TCHAR)); <br>            pszWindowTitle = szScreenSaverTitle; // MUST differ from preview <br> <br>            uStyle = WS_VISIBLE | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN |  <br>                   WS_CLIPSIBLINGS; <br> <br>            hCursor = LoadCursor( NULL, IDC_ARROW ); <br> <br>            // Wrap RealScreenSaverProc <br>            wndProc = NormalWindowScreenSaverProc; <br>          } <br>          break; <br> <br>        default: <br>          break; <br>    } <br> <br>    size.width = nCx; <br>    size.height = nCy; <br>#ifdef SS_INITIAL_CLEAR <br>    hbrBgMain = NULL; <br>#else <br>    hbrBgMain = hbrBg; <br>#endif <br> <br>    pos.x = pos.y = 0; <br> <br>    // Create SSW window wrapper <br> <br>    pssw = new SSW( NULL,       // parent <br>                    &amp;size,  <br>                    &amp;pos,  <br>                    FALSE,      // bMotion <br>                    NULL       // ChildSizeFunc <br>                  ); <br>    if( !pssw ) <br>        return FALSE; <br> <br>    // Initialize the window class and create the window <br> <br>    if( !RegisterMainClass <br>        ( <br>            wndProc,  <br>            hbrBgMain,  <br>            hCursor <br>        ) || <br> <br>        !pssw-&gt;CreateSSWindow <br>        (    <br>            hMainInstance,  <br>            uStyle,  <br>            uExStyle,  <br>            szScreenSaverTitle, <br>            wndProc, <br>            pszWindowClass, <br>            hwndParent     // mf: ! hwndParentOverride <br>        ) ) <br>    { <br>        delete pssw; <br>        return FALSE; <br>    } <br> <br>    if( type != SS_TYPE_PREVIEW ) <br>#ifndef SS_DEBUG <br>        SetForegroundWindow( pssw-&gt;hwnd ); <br>#else <br>    { <br>        if( !SetForegroundWindow( pssw-&gt;hwnd ) ) <br>            SS_DBGPRINT( "Main_Proc: SetForegroundWindow failed\n" ); <br>    } <br>#endif <br> <br>    // Always configure the main window for gdi <br>    pssw-&gt;ConfigureForGdi(); <br> <br>    psswMain = pssw; <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* CreateChildWindow <br>* <br>* Creates a child window of the parent window <br>* <br>* This is a kind of wrapper-constructor <br>\**************************************************************************/ <br> <br>PSSW <br>SCRNSAVE::CreateChildWindow( FLOATER_INFO *pFloater ) <br>{ <br>    pFloater-&gt;bSubWindow = FALSE; // default is no logical subwin's <br> <br>#ifdef SS_WIN95_MULTIWINDOW_WORKAROUND <br>    if( ss_fOnWin95() &amp;&amp; ss_fFullScreenMode() &amp;&amp; bPowerSaveEnabled() ) { <br>        // Make the floater a logical sub-window of the main window, not a <br>        // separate window.  This works around a USER bug where the power  <br>        // save feature was not getting activated for multi-windowed screen <br>        // savers <br>        SS_DBGINFO( "SCRNSAVE::CreateChildWindow : Using logical sub-windows\n" ); <br>        pFloater-&gt;bSubWindow = TRUE; <br>    } <br>#endif // SS_WIN95_MULTIWINDOW_WORKAROUND <br> <br>    // Register child window class <br>    // This only has to be done once, since so far, all child window <br>    // classes are the same <br>    if( !pFloater-&gt;bSubWindow &amp;&amp; !RegisterChildClass() ) <br>        return NULL; <br> <br>    return CreateChildWindow( psswMain, pFloater ); <br>} <br> <br>PSSW <br>SCRNSAVE::CreateChildWindow( PSSW psswParent, FLOATER_INFO *pFloater ) <br>{ <br>    UINT     uStyle = 0; <br>    UINT     uExStyle = 0; <br>    PSSW     pssw; <br> <br>    uStyle = WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS; <br> <br>    // Size and position are NULL here, as the SSW will call the size <br>    // function callback in pFloater to get these and other values <br> <br>    // Create the SSW window wrapper <br> <br>    pssw = new SSW( psswParent,      // parent <br>                    NULL,            // size <br>                    NULL,            // position <br>                    pFloater-&gt;bMotion, <br>                    pFloater-&gt;ChildSizeFunc <br>                  ); <br>    if( !pssw ) <br>        return NULL; <br> <br>    if( pFloater-&gt;bSubWindow ) <br>        // Don't need to create win32 window <br>        return pssw; <br> <br>    // Create a window <br> <br>    if( !pssw-&gt;CreateSSWindow <br>        ( <br>            hMainInstance,  <br>            uStyle, <br>            0,                      // uExStyle  <br>            szScreenSaverTitle , <br>            SS_ScreenSaverProc, <br>            szClassName, <br>            NULL                    // hwndParentOverride <br>        ) ) <br>    { <br>        delete pssw; <br>        return NULL; <br>    } <br> <br>    return pssw; <br>} <br> <br> <br>/**************************************************************************\ <br>* RegisterMainClass <br>* <br>* Registers class of the main SS window <br>\**************************************************************************/ <br> <br>static BOOL  <br>RegisterMainClass( WNDPROC wndProc, HBRUSH hbrBg, HCURSOR hCursor ) <br>{ <br>    WNDCLASS cls; <br> <br>    cls.style = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC; <br>    cls.lpfnWndProc = wndProc; <br>    cls.cbClsExtra = 0; <br>    cls.cbWndExtra = 0; <br>    cls.hInstance = hMainInstance; <br>    cls.hIcon = LoadIcon( hMainInstance, MAKEINTATOM( ID_APP ) ); <br>    cls.hCursor = hCursor; <br>    cls.hbrBackground = hbrBg; <br>    cls.lpszMenuName = (LPTSTR)NULL; <br>    cls.lpszClassName = (LPTSTR)pszWindowClass; <br>    return RegisterClass(&amp;cls); <br>} <br> <br>/**************************************************************************\ <br>* RegisterChildClass <br>* <br>* Registers class of a standard child window <br>\**************************************************************************/ <br> <br>static BOOL  <br>RegisterChildClass() <br>{ <br>    static BOOL bRegistered = FALSE; <br> <br>    if( bRegistered ) <br>        return TRUE; <br> <br>    WNDCLASS cls; <br> <br>    cls.style = CS_VREDRAW | CS_HREDRAW; <br>    cls.lpfnWndProc = SS_ScreenSaverProc; <br>    cls.cbClsExtra = 0; <br>    cls.cbWndExtra = 0; <br>    cls.hInstance = hMainInstance; <br>    cls.hIcon = NULL; <br>    cls.hCursor = NULL; <br>    cls.hbrBackground = NULL; <br>    cls.lpszMenuName = (LPTSTR)NULL; <br>    cls.lpszClassName = (LPTSTR)szClassName; <br> <br>    if( !RegisterClass(&amp;cls) ) <br>        return FALSE; <br> <br>    // success <br>    bRegistered = TRUE; <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* AttemptResolutionSwitch <br>* <br>* Try doing resolution switching to match or get close to the desired size. <br>* <br>\**************************************************************************/ <br> <br>static BOOL <br>AttemptResolutionSwitch( int width, int height, ISIZE *pNewSize )  <br>{ <br>    BOOL bChanged = FALSE; <br> <br>    // Try doing resolution switching to match or get close to the <br>    // desired width and height <br> <br>    // Try switching to requested size <br>    if( 0 ) { <br>        // for now force failure of user request and try standard 640x480 <br>        bChanged = TRUE; <br>    } else { <br>        // Can't switch to requested size, try for best match <br>        width = 640;  <br>        height = 480; <br>        // If screen already this size or less, leave be <br>        if( (GetSystemMetrics( SM_CXSCREEN ) &lt;= width) &amp;&amp; <br>            (GetSystemMetrics( SM_CYSCREEN ) &lt;= height) ) <br>            return FALSE; <br> <br>        // use this when trying for best match <br>        // ss_QueryDisplaySettings(); <br> <br>        if( ss_ChangeDisplaySettings( width, height, 0 ) ) <br>            bChanged = TRUE; <br>    } <br> <br>    if( bChanged ) { <br>        pNewSize-&gt;width = width; <br>        pNewSize-&gt;height = height; <br>    } <br>    return bChanged; <br>} <br> <br>#ifdef SS_INITIAL_CLEAR <br>static void <br>InitialClear( PSSW *pssw ) <br>{ <br>    ss_GdiRectWipeClear( pssw-&gt;hwnd, pssw-&gt;size.width, pssw-&gt;size.height ); <br>} <br>#endif // SS_INITIAL_CLEAR <br> <br>/**************************************************************************\ <br>* CloseWindows <br>* <br>* Close down any open windows. <br>* <br>* This sends a WM_CLOSE message to the top-level window if it is still open.  If <br>* the window has any children, they are also closed.  For each window, the <br>* SSW destructor is called. <br>\**************************************************************************/ <br> <br>void <br>SCRNSAVE::CloseWindows() <br>{ <br>    if( psswMain ) { <br>        if( psswMain-&gt;bOwnWindow ) <br>            DestroyWindow( psswMain-&gt;hwnd ); <br>        else <br>            delete psswMain; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* SCRNSAVE destructor <br>* <br>\**************************************************************************/ <br> <br>SCRNSAVE::~SCRNSAVE() <br>{ <br>    // Close any open windows (there might be some open if errors occurred) <br>    CloseWindows(); <br> <br>#ifdef SS_WIN95_DESKTOP_REDRAW_FIX <br>    // On win95, sometimes the desktop is drawn incorrectly after we have <br>    // taken over the palette <br>    if( flags &amp; SS_PALETTE_TAKEOVER ) { <br>        SS_DBGINFO( "SCRNSAVE destructor: Redrawing desktop\n" ); <br>        ss_RedrawDesktop(); <br>    } <br>#endif <br> <br>    if( bResSwitch ) { <br>        // Restore previous display settings <br>        ChangeDisplaySettings(NULL, CDS_FULLSCREEN); <br>    } <br> <br>    gpss = NULL; <br>} <br> <br> <br>#ifdef SS_WIN95_MULTIWINDOW_WORKAROUND <br> <br>// Macro to convert string to integer <br>#ifdef UNICODE <br>#define sztoi( pszStr ) _wtoi( (wchar_t *) (pszStr) ) <br>#else <br>#define sztoi( pszStr ) atoi( (char *) (pszStr) ) <br>#endif <br> <br>/**************************************************************************\ <br>* GetRegValueBool <br>* <br>* Get registry value and convert to BOOL <br>\**************************************************************************/ <br> <br>#define SS_REG_BUF_SIZE 30 <br> <br>static BOOL <br>bGetRegValueBool( HKEY hKey, LPTSTR szValue, BOOL *pbEnabled ) <br>{ <br>    TCHAR szBuf[SS_REG_BUF_SIZE]; <br>    DWORD dataSize = SS_REG_BUF_SIZE; <br>    DWORD dwType; <br> <br>    // Get the value <br> <br>    if( ! ( RegQueryValueEx(  <br>              hKey,  <br>              szValue, <br>              (LPDWORD) NULL, <br>              (LPDWORD) &amp;dwType, <br>              (LPBYTE) szBuf, <br>              (LPDWORD) &amp;dataSize ) == ERROR_SUCCESS <br>          )  <br>      ) <br>        return FALSE; <br> <br>    // Convert value to BOOL (the expected type is REG_SZ) <br> <br>    switch( dwType ) { <br>        case REG_SZ : <br>            // Convert string to BOOL <br>            *pbEnabled = (BOOL) sztoi( szBuf ); <br>            break; <br>     <br>        case REG_DWORD : <br>            // Handle numerical value <br>            *pbEnabled = (BOOL) *( (LPDWORD) szBuf ); <br>            break; <br> <br>        default: <br>            SS_WARNING( "GetRegValueBool : Unexpected type\n" ); <br>            return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* bPowerSaveEnabled <br>*  <br>* Detect if power saving is enabled by checking registry values. <br>* <br>\**************************************************************************/ <br> <br>static BOOL <br>bPowerSaveEnabled() <br>{ <br>    BOOL bLowPowerActive; <br>    BOOL bPowerOffActive; <br>    HKEY hKey; <br> <br>    // Open desktop key <br> <br>    if( ! ( RegOpenKeyEx(  <br>              HKEY_CURRENT_USER,  <br>              (LPCTSTR) TEXT( "Control Panel\\desktop"), <br>              0,  <br>              KEY_QUERY_VALUE,  <br>              &amp;hKey  ) == ERROR_SUCCESS  <br>          ) <br>      )  <br>    { <br>        return FALSE;  // Can't open desktop key <br>    } <br> <br>    // Check values - power saving is enabled if either ScreenSaveLowPowerActive <br>    // or ScreenSavePowerOffActive is enabled. <br> <br>    if( ( <br>          bGetRegValueBool(  <br>            hKey, <br>            (LPTSTR) TEXT("ScreenSaveLowPowerActive"),  <br>            &amp;bLowPowerActive )  <br>          &amp;&amp; <br>          bLowPowerActive <br>        )  <br>        || <br>        ( <br>          bGetRegValueBool( <br>            hKey, <br>            (LPTSTR) TEXT("ScreenSavePowerOffActive"),  <br>            &amp;bPowerOffActive )  <br>          &amp;&amp; <br>          bPowerOffActive <br>        )  <br>      )  <br>    { <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br>#endif // SS_WIN95_MULTIWINDOW_WORKAROUND </code></pre>
<p>&nbsp;</p></body>
</HTML>
