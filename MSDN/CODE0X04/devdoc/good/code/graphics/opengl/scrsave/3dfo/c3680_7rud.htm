<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENWIN.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3685"></a>GENWIN.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: genwin.c <br>* <br>* The Windows Logo style of the 3D Flying Objects screen saver. <br>* <br>* Animated 3D model of the Microsoft (R) Windows NT (TM) flag logo. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br> <br>#define WIN_TOP_BORDER      (float)0.1 <br>#define WIN_RIGHT_BORDER    WIN_TOP_BORDER <br>#define WIN_CROSSBAR        (0.6522f * WIN_TOP_BORDER) <br>#define WIN_NUMPIECES       7 <br>#define WIN_NUMCOLUMNS      6 <br>#define WIN_GAP             (WIN_TOP_BORDER / 8.0f) <br>#define WIN_GAP_X           (2.0f * WIN_GAP) <br>#define WIN_HEIGHT          ((WIN_GAP * 6.0f) + \ <br>                                (WIN_NUMPIECES * WIN_TOP_BORDER)) <br>#define WIN_WIDTH           (0.7024f * WIN_HEIGHT) <br>#define WIN_THICKNESS       WIN_CROSSBAR <br> <br>#define WIN_TOTALWIDTH      (WIN_TOP_BORDER * 1.1f * (float)WIN_NUMCOLUMNS + \ <br>                             WIN_WIDTH) <br> <br>#define BLOCK_TOP            0x0001 <br>#define BLOCK_BOTTOM         0x0002 <br>#define BLOCK_LEFT           0x0004 <br>#define BLOCK_RIGHT          0x0008 <br>#define BLOCK_FRONT          0x0010 <br>#define BLOCK_BACK           0x0020 <br>#define BLOCK_ALL            0x003f <br>#define DELTA_BLEND          0x2000 <br>#define NO_BLEND             0x1000 <br> <br>#define CUBE_FACES          6 <br>#define CUBE_POINTS         8 <br> <br>#define MAX_FRAMES 20 <br> <br>#define MAXPREC 15 <br>#define S_IPREC 3 <br> <br>static int Frames = 10; <br>static MESH winMesh[MAX_FRAMES]; <br>static MESH winStreamer[MAX_FRAMES]; <br>static float sinAngle = 0.0f; <br>static float xTrans = 0.2f; <br>static int curMatl = 0; <br>static int iPrec = 10; <br> <br>static RGBA matlBrightSpecular = {1.0f, 1.0f, 1.0f, 1.0f}; <br>static RGBA matlDimSpecular = {0.5f, 0.5f, 0.5f, 1.0f}; <br>static RGBA matlNoSpecular = {0.0f, 0.0f, 0.0f, 0.0f}; <br>static GLfloat light0Pos[] = {20.0f, -10.0f, 20.0f, 0.0f}; <br> <br>static RGBA light1Ambient  = {0.0f, 0.0f, 0.0f, 0.0f}; <br>static RGBA light1Diffuse  = {0.4f, 0.4f, 0.4f, 1.0f}; <br>static RGBA light1Specular = {0.0f, 0.0f, 0.0f, 0.0f}; <br>static GLfloat light1Pos[] = {-20.0f, 5.0f, 0.0f, 0.0f}; <br> <br>static RGBA winColors[] = {{0.3f, 0.3f, 0.3f, 1.0f}, <br>                           {0.94f, 0.37f, 0.13f, 1.0f},    // red <br>                           {0.22f, 0.42f, 0.78f, 1.0f},    // blue <br>                           {0.35f, 0.71f, 0.35f, 1.0f},    // green <br>                           {0.95f, 0.82f, 0.12f, 1.0f}};   // yellow <br> <br>static int iPtInList(MESH *mesh, int start,  <br>                     POINT3D *p, POINT3D *norm, BOOL blend) <br>{ <br>    int i; <br>    POINT3D *pts = mesh-&gt;pts + start; <br> <br>    if (blend) { <br>        for (i = start; i &lt; mesh-&gt;numPoints; i++, pts++) { <br>            if ((pts-&gt;x == p-&gt;x) &amp;&amp; (pts-&gt;y == p-&gt;y) &amp;&amp; (pts-&gt;z == p-&gt;z)) { <br>                mesh-&gt;norms[i].x += norm-&gt;x; <br>                mesh-&gt;norms[i].y += norm-&gt;y; <br>                mesh-&gt;norms[i].z += norm-&gt;z; <br>                return i; <br>            } <br>        } <br>    } else { <br>        i = mesh-&gt;numPoints; <br>    } <br>     <br>    mesh-&gt;pts[i] = *p; <br>    mesh-&gt;norms[i] = *norm; <br>    mesh-&gt;numPoints++; <br>    return i; <br>} <br> <br>float getZPos(float x) <br>{ <br>    float xAbs = x - xTrans; <br>    float angle = (float) (sinAngle + ((2.0 * PI) * (xAbs / WIN_TOTALWIDTH))); <br> <br>    xAbs += (WIN_TOTALWIDTH / 2.0f); <br>    xAbs = WIN_TOTALWIDTH - xAbs; <br> <br>    return (float)((sin((double)angle) / 4.0) *  <br>                   sqrt((double)(xAbs / WIN_TOTALWIDTH ))); <br>} <br> <br>void AddFace(MESH *mesh, int startBlend, POINT3D *pos, float w, float h) <br>{ <br>#define FACE_VERTEX(i) \ <br>    iPtInList(mesh, startBlend, pts + i, &amp;mesh-&gt;faces[faceCount].norm, TRUE) <br> <br>    int faceCount = mesh-&gt;numFaces;      <br>    int numPts = mesh-&gt;numPoints; <br>    POINT3D *pts = mesh-&gt;pts + numPts; <br>    float zLeft = getZPos(pos-&gt;x); <br>    float zRight = getZPos(pos-&gt;x + w); <br> <br> <br>    pts-&gt;x = (float)pos-&gt;x;  <br>    pts-&gt;y = (float)pos-&gt;y;    <br>    pts-&gt;z = zLeft;  <br>    pts++; <br> <br>    pts-&gt;x = (float)pos-&gt;x; <br>    pts-&gt;y = (float)(pos-&gt;y + h);   <br>    pts-&gt;z = zLeft;   <br>    pts++; <br> <br>    pts-&gt;x = (float)(pos-&gt;x + w);   <br>    pts-&gt;y = (float)(pos-&gt;y + h);   <br>    pts-&gt;z = zRight;   <br>    pts++; <br> <br>    pts-&gt;x = (float)(pos-&gt;x + w); <br>    pts-&gt;y = (float)pos-&gt;y;   <br>    pts-&gt;z = zRight; <br> <br>    pts -= 3; <br> <br>    mesh-&gt;faces[faceCount].material = curMatl; <br>    ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, pts + 2, pts + 1, pts); <br>    mesh-&gt;faces[faceCount].p[3] = FACE_VERTEX(0); <br>    mesh-&gt;faces[faceCount].p[2] = FACE_VERTEX(1); <br>    mesh-&gt;faces[faceCount].p[1] = FACE_VERTEX(2); <br>    mesh-&gt;faces[faceCount].p[0] = FACE_VERTEX(3); <br>    mesh-&gt;numFaces++; <br>} <br> <br>#define BLOCK_VERTEX(face, i)\ <br>{\ <br>    if (flags &amp; DELTA_BLEND) {\ <br>        mesh-&gt;faces[faceCount].p[face] = \ <br>            iPtInList(mesh, blendStart, &amp;pts[i], &amp;norms[((i &amp; 0x2) &gt;&gt; 1)],\ <br>                      bBlend);\ <br>    } else\ <br>        mesh-&gt;faces[faceCount].p[face] = \ <br>            iPtInList(mesh, blendStart, &amp;pts[i],\ <br>                      &amp;mesh-&gt;faces[faceCount].norm, bBlend);\ <br>} <br> <br>#define DELTA_FACT  (float)10.0 <br> <br>void AddBlock(MESH *mesh, int blendStart, POINT3D *pos,  <br>              float w, float h, float d, ULONG flags) <br>{ <br> <br>    POINT3D pts[8]; <br>    POINT3D ptsL[8]; <br>    POINT3D ptsR[8]; <br>    POINT3D norms[2]; <br>    POINT3D posPrev; <br>    float zLeft = getZPos(pos-&gt;x); <br>    float zRight = getZPos(pos-&gt;x + w); <br>    int faceCount = mesh-&gt;numFaces;      <br>    BOOL bBlend = ((flags &amp; NO_BLEND) == 0); <br> <br>    flags |= DELTA_BLEND; <br> <br>    pts[0].x = (float)pos-&gt;x;  <br>    pts[0].y = (float)(pos-&gt;y + h);    <br>    pts[0].z = zLeft; <br> <br>    pts[1].x = (float)pos-&gt;x; <br>    pts[1].y = (float)(pos-&gt;y + h);   <br>    pts[1].z = zLeft + d;   <br> <br>    pts[2].x = (float)(pos-&gt;x + w);   <br>    pts[2].y = (float)(pos-&gt;y + h);   <br>    pts[2].z = zRight + d;   <br> <br>    pts[3].x = (float)(pos-&gt;x + w); <br>    pts[3].y = (float)(pos-&gt;y + h); <br>    pts[3].z = zRight; <br> <br>    pts[4].x = (float)pos-&gt;x; <br>    pts[4].y = (float)pos-&gt;y; <br>    pts[4].z = zLeft; <br> <br>    pts[5].x = (float)pos-&gt;x; <br>    pts[5].y = (float)pos-&gt;y; <br>    pts[5].z = zLeft + d;   <br> <br>    pts[6].x = (float)(pos-&gt;x + w);   <br>    pts[6].y = (float)pos-&gt;y; <br>    pts[6].z = zRight + d;   <br> <br>    pts[7].x = (float)(pos-&gt;x + w);   <br>    pts[7].y = (float)pos-&gt;y; <br>    pts[7].z = zRight; <br> <br>    if (flags &amp; DELTA_BLEND) { <br>float prevW = w; <br>        posPrev = *pos; <br> <br>        w /= DELTA_FACT; <br>        zRight = getZPos(pos-&gt;x + w); <br> <br>        ptsL[0].x = (float)pos-&gt;x;  <br>        ptsL[0].y = (float)(pos-&gt;y + h);    <br>        ptsL[0].z = zLeft; <br> <br>        ptsL[1].x = (float)pos-&gt;x; <br>        ptsL[1].y = (float)(pos-&gt;y + h);   <br>        ptsL[1].z = zLeft + d;   <br> <br>        ptsL[2].x = (float)(pos-&gt;x + w);   <br>        ptsL[2].y = (float)(pos-&gt;y + h);   <br>        ptsL[2].z = zRight + d;   <br> <br>        ptsL[3].x = (float)(pos-&gt;x + w); <br>        ptsL[3].y = (float)(pos-&gt;y + h); <br>        ptsL[3].z = zRight; <br> <br>        ptsL[4].x = (float)pos-&gt;x; <br>        ptsL[4].y = (float)pos-&gt;y; <br>        ptsL[4].z = zLeft; <br> <br>        ptsL[5].x = (float)pos-&gt;x; <br>        ptsL[5].y = (float)pos-&gt;y; <br>        ptsL[5].z = zLeft + d;   <br> <br>        ptsL[6].x = (float)(pos-&gt;x + w);   <br>        ptsL[6].y = (float)pos-&gt;y; <br>        ptsL[6].z = zRight + d;   <br> <br>        ptsL[7].x = (float)(pos-&gt;x + w);   <br>        ptsL[7].y = (float)pos-&gt;y; <br>        ptsL[7].z = zRight; <br> <br>        pos-&gt;x += (prevW - w); <br>        zLeft = getZPos(pos-&gt;x); <br>        zRight = getZPos(pos-&gt;x + w); <br> <br>        ptsR[0].x = (float)pos-&gt;x;  <br>        ptsR[0].y = (float)(pos-&gt;y + h);    <br>        ptsR[0].z = zLeft; <br> <br>        ptsR[1].x = (float)pos-&gt;x; <br>        ptsR[1].y = (float)(pos-&gt;y + h);   <br>        ptsR[1].z = zLeft + d;   <br> <br>        ptsR[2].x = (float)(pos-&gt;x + w);   <br>        ptsR[2].y = (float)(pos-&gt;y + h);   <br>        ptsR[2].z = zRight + d;   <br> <br>        ptsR[3].x = (float)(pos-&gt;x + w); <br>        ptsR[3].y = (float)(pos-&gt;y + h); <br>        ptsR[3].z = zRight; <br> <br>        ptsR[4].x = (float)pos-&gt;x; <br>        ptsR[4].y = (float)pos-&gt;y; <br>        ptsR[4].z = zLeft; <br> <br>        ptsR[5].x = (float)pos-&gt;x; <br>        ptsR[5].y = (float)pos-&gt;y; <br>        ptsR[5].z = zLeft + d;   <br> <br>        ptsR[6].x = (float)(pos-&gt;x + w);   <br>        ptsR[6].y = (float)pos-&gt;y; <br>        ptsR[6].z = zRight + d;   <br> <br>        ptsR[7].x = (float)(pos-&gt;x + w);   <br>        ptsR[7].y = (float)pos-&gt;y; <br>        ptsR[7].z = zRight; <br> <br>        *pos = posPrev; <br> <br>    } <br> <br>    if (flags &amp; BLOCK_TOP) { <br>        mesh-&gt;faces[faceCount].material = curMatl; <br>        ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, &amp;pts[0], &amp;pts[1], &amp;pts[2]); <br>        if (flags &amp; DELTA_BLEND) { <br>            ss_calcNorm(&amp;norms[0], &amp;ptsL[0], &amp;ptsL[1], &amp;ptsL[2]); <br>            ss_calcNorm(&amp;norms[1], &amp;ptsR[0], &amp;ptsR[1], &amp;ptsR[2]); <br>        } <br>        BLOCK_VERTEX(0, 0); <br>        BLOCK_VERTEX(1, 1); <br>        BLOCK_VERTEX(2, 2); <br>        BLOCK_VERTEX(3, 3); <br>        faceCount++; <br>        mesh-&gt;numFaces++; <br>    } <br> <br>    if (flags &amp; BLOCK_BOTTOM) { <br>        mesh-&gt;faces[faceCount].material = curMatl; <br>        ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, &amp;pts[4], &amp;pts[7], &amp;pts[6]); <br>        if (flags &amp; DELTA_BLEND) { <br>            ss_calcNorm(&amp;norms[0], &amp;ptsL[4], &amp;ptsL[7], &amp;ptsL[6]); <br>            ss_calcNorm(&amp;norms[1], &amp;ptsR[4], &amp;ptsR[7], &amp;ptsR[6]); <br>        } <br>        BLOCK_VERTEX(0, 4); <br>        BLOCK_VERTEX(1, 7); <br>        BLOCK_VERTEX(2, 6); <br>        BLOCK_VERTEX(3, 5); <br>        faceCount++; <br>        mesh-&gt;numFaces++; <br>    } <br> <br>    if (flags &amp; BLOCK_LEFT) { <br>        mesh-&gt;faces[faceCount].material = curMatl; <br>        ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, &amp;pts[1], &amp;pts[0], &amp;pts[4]); <br>        if (flags &amp; DELTA_BLEND) { <br>            ss_calcNorm(&amp;norms[0], &amp;ptsL[1], &amp;ptsL[0], &amp;ptsL[4]); <br>            ss_calcNorm(&amp;norms[1], &amp;ptsR[1], &amp;ptsR[0], &amp;ptsR[4]); <br>        } <br>        BLOCK_VERTEX(0, 1); <br>        BLOCK_VERTEX(1, 0); <br>        BLOCK_VERTEX(2, 4); <br>        BLOCK_VERTEX(3, 5); <br>        faceCount++; <br>        mesh-&gt;numFaces++; <br>    } <br> <br>    if (flags &amp; BLOCK_RIGHT) { <br>        mesh-&gt;faces[faceCount].material = curMatl; <br>        ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, &amp;pts[3], &amp;pts[2], &amp;pts[6]); <br>        if (flags &amp; DELTA_BLEND) { <br>            ss_calcNorm(&amp;norms[0], &amp;ptsL[3], &amp;ptsL[2], &amp;ptsL[6]); <br>            ss_calcNorm(&amp;norms[1], &amp;ptsR[3], &amp;ptsR[2], &amp;ptsR[6]); <br>        } <br>        BLOCK_VERTEX(0, 3); <br>        BLOCK_VERTEX(1, 2); <br>        BLOCK_VERTEX(2, 6); <br>        BLOCK_VERTEX(3, 7); <br>        faceCount++; <br>        mesh-&gt;numFaces++; <br>    } <br> <br>    if (flags &amp; BLOCK_FRONT) { <br>        mesh-&gt;faces[faceCount].material = curMatl; <br>        ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, &amp;pts[0], &amp;pts[3], &amp;pts[7]); <br>        if (flags &amp; DELTA_BLEND) { <br>            ss_calcNorm(&amp;norms[0], &amp;ptsL[0], &amp;ptsL[3], &amp;ptsL[7]); <br>            ss_calcNorm(&amp;norms[1], &amp;ptsR[0], &amp;ptsR[3], &amp;ptsR[7]); <br>        } <br>        BLOCK_VERTEX(0, 0); <br>        BLOCK_VERTEX(1, 3); <br>        BLOCK_VERTEX(2, 7); <br>        BLOCK_VERTEX(3, 4); <br>        faceCount++; <br>        mesh-&gt;numFaces++; <br>    } <br> <br>    if (flags &amp; BLOCK_BACK) { <br>        mesh-&gt;faces[faceCount].material = curMatl; <br>        ss_calcNorm(&amp;mesh-&gt;faces[faceCount].norm, &amp;pts[1], &amp;pts[5], &amp;pts[6]); <br>        if (flags &amp; DELTA_BLEND) { <br>            ss_calcNorm(&amp;norms[0], &amp;ptsL[1], &amp;ptsL[5], &amp;ptsL[6]); <br>            ss_calcNorm(&amp;norms[1], &amp;ptsR[1], &amp;ptsR[5], &amp;ptsR[6]); <br>        } <br>        BLOCK_VERTEX(0, 1); <br>        BLOCK_VERTEX(1, 5); <br>        BLOCK_VERTEX(2, 6); <br>        BLOCK_VERTEX(3, 2); <br>        mesh-&gt;numFaces++; <br>    } <br> <br>} <br> <br>void genWin(MESH *winMesh, MESH *winStreamer) <br>{ <br>    POINT3D pos, posCenter; <br>    float w, h, d; <br>    float wMax, hMax; <br>    float xpos; <br>    int i, j, prec; <br>    int startBlend; <br> <br>    newMesh(winMesh, CUBE_FACES * iPrec * 20, CUBE_POINTS * iPrec * 20); <br> <br>    // <br>    // create window frame <br>    // <br> <br>    w = (WIN_WIDTH - WIN_TOP_BORDER) / (float)iPrec; <br>    h = (float)WIN_TOP_BORDER; <br>    d = (float)WIN_THICKNESS; <br> <br>    // draw top and bottom portions <br> <br>    pos.y = 0.0f; <br>    pos.z = 0.0f; <br> <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_TOP); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BOTTOM); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints;  <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_FRONT); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BACK); <br>    pos.x = xTrans; <br>    AddBlock(winMesh, 0, &amp;pos, w, h, d, BLOCK_LEFT | NO_BLEND); <br> <br>    pos.y = WIN_HEIGHT - WIN_TOP_BORDER; <br>    pos.z = 0.0f; <br> <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_TOP); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BOTTOM); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_FRONT); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; iPrec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BACK); <br>    pos.x = xTrans; <br>    AddBlock(winMesh, 0, &amp;pos, w, h, d, BLOCK_LEFT | NO_BLEND); <br>     <br>    // draw middle horizontal portions <br> <br>    prec = (iPrec / 2); <br>    w = (WIN_WIDTH - WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f; <br>    w /= (float)prec; <br>    h = WIN_CROSSBAR; <br>    pos.y = (WIN_HEIGHT - WIN_CROSSBAR) / 2.0f; <br>    pos.z = 0.0f; <br> <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_TOP); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BOTTOM); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_FRONT); <br>    for (i = 0, pos.x = xTrans, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BACK); <br> <br>    xpos = pos.x + WIN_CROSSBAR; <br> <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_TOP); <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BOTTOM); <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_FRONT); <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; prec; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BACK); <br> <br>    pos.x = xTrans; <br>    AddBlock(winMesh, 0, &amp;pos, w, h, d, BLOCK_LEFT | NO_BLEND); <br> <br> <br>    // Draw thick right-hand edge of frame <br> <br>    pos.x = xpos = xTrans + WIN_WIDTH - WIN_RIGHT_BORDER; <br>    pos.y = 0.0f; <br>    pos.z = 0.0f; <br>    w = WIN_RIGHT_BORDER / (float)S_IPREC; <br>    h = WIN_HEIGHT; <br> <br>    AddBlock(winMesh, winMesh-&gt;numPoints, &amp;pos, w, h, d, BLOCK_LEFT); <br> <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; S_IPREC; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_FRONT); <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; S_IPREC; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BACK); <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; S_IPREC; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_TOP); <br>    pos.y = WIN_HEIGHT; <br>    for (i = 0, pos.x = xpos, startBlend = winMesh-&gt;numPoints; <br>         i &lt; S_IPREC; i++, pos.x += w) <br>        AddBlock(winMesh, startBlend, &amp;pos, w, h, d, BLOCK_BOTTOM); <br> <br>    pos.y = 0.0f; <br>    pos.x = xTrans + WIN_WIDTH - w; <br>    AddBlock(winMesh, winMesh-&gt;numPoints, &amp;pos, w, h, d, BLOCK_RIGHT); <br> <br>    // draw middle-vertical portion of frame <br> <br>    pos.x = xTrans + (WIN_WIDTH - WIN_RIGHT_BORDER) / 2.0f - (WIN_CROSSBAR / 2.0f); <br>    pos.y = WIN_TOP_BORDER; <br>    pos.z = 0.0f; <br>    w = WIN_CROSSBAR; <br>    h = WIN_HEIGHT - 2.0f * WIN_TOP_BORDER; <br>    AddBlock(winMesh, 0, &amp;pos, w, h, d, BLOCK_ALL | NO_BLEND); <br> <br>    // <br>    // add the panels <br>    // <br> <br>    w = (WIN_WIDTH - WIN_RIGHT_BORDER - WIN_CROSSBAR) / 2.0f; <br>    h = (WIN_HEIGHT - 2.0f * WIN_TOP_BORDER - WIN_CROSSBAR) / 2.0f; <br> <br>    w /= (float)(iPrec / 2); <br> <br>    curMatl = 2; <br>    pos.x = xTrans; <br>    pos.y = WIN_TOP_BORDER; <br>    for (i = 0, startBlend = winMesh-&gt;numPoints; i &lt; iPrec / 2; i++) { <br>        AddFace(winMesh, startBlend, &amp;pos, w, h); <br>        pos.x += w; <br>    } <br>    curMatl = 4; <br>    pos.x += WIN_CROSSBAR; <br>    for (i = 0, startBlend = winMesh-&gt;numPoints; i &lt; iPrec / 2; i++) { <br>        AddFace(winMesh, startBlend, &amp;pos, w, h); <br>        pos.x += w; <br>    } <br> <br>    curMatl = 1; <br>    pos.x = xTrans; <br>    pos.y = WIN_TOP_BORDER + h + WIN_CROSSBAR; <br>    for (i = 0, startBlend = winMesh-&gt;numPoints; i &lt; iPrec / 2; i++) { <br>        AddFace(winMesh, startBlend, &amp;pos, w, h); <br>        pos.x += w; <br>    } <br>    curMatl = 3; <br>    pos.x += WIN_CROSSBAR; <br>    for (i = 0, startBlend = winMesh-&gt;numPoints; i &lt; iPrec / 2; i++) { <br>        AddFace(winMesh, startBlend, &amp;pos, w, h); <br>        pos.x += w; <br>    } <br> <br>    ss_normalizeNorms(winMesh-&gt;norms, winMesh-&gt;numPoints); <br> <br>    newMesh(winStreamer, CUBE_FACES * WIN_NUMPIECES * WIN_NUMCOLUMNS, <br>            CUBE_POINTS * WIN_NUMPIECES * WIN_NUMCOLUMNS); <br> <br>    h = hMax = WIN_TOP_BORDER; <br>    w = wMax = WIN_TOP_BORDER * 1.1f; <br> <br>    posCenter.x = pos.x = xTrans - wMax - WIN_GAP_X; <br>    posCenter.y = pos.y = 0.0f; <br> <br>    for (i = 0; i &lt; WIN_NUMCOLUMNS; i++) { <br>        for (j = 0; j &lt; WIN_NUMPIECES; j++) { <br>            if (((j % 3) == 0) || (i == 0)) <br>                curMatl = 0; <br>            else if (j &lt; 3) <br>                curMatl = 2; <br>            else <br>                curMatl = 1; <br>            AddBlock(winStreamer, 0, &amp;pos, w, h, d, BLOCK_ALL); <br>            pos.y += (hMax + WIN_GAP); <br>        } <br> <br>        posCenter.x -= (wMax + WIN_GAP_X); <br>        posCenter.y = 0.0f; <br> <br>        h = h * 0.8f; <br>        w = w * 0.8f; <br> <br>        pos.x = posCenter.x; <br>        pos.y = posCenter.y; <br> <br>        pos.x += (wMax - w) / 2.0f; <br>        pos.y += (hMax - h) / 2.0f; <br>    }     <br>    ss_normalizeNorms(winStreamer-&gt;norms, winStreamer-&gt;numPoints); <br>} <br> <br>void initWinScene() <br>{ <br>    int i; <br>    float angleDelta; <br> <br>    iPrec = (int)(fTesselFact * 10.5); <br>    if (iPrec &lt; 5) <br>        iPrec = 5; <br>    if (iPrec &gt; MAXPREC) <br>        iPrec = MAXPREC; <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-1.0, 1.0, -0.75, 1.25, 0.0, 3.0); <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br>    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos); <br> <br>    glLightfv(GL_LIGHT1, GL_AMBIENT, (GLfloat *) &amp;light1Ambient); <br>    glLightfv(GL_LIGHT1, GL_DIFFUSE, (GLfloat *) &amp;light1Diffuse); <br>    glLightfv(GL_LIGHT1, GL_SPECULAR, (GLfloat *) &amp;light1Specular); <br>    glLightfv(GL_LIGHT1, GL_POSITION, light1Pos); <br>    glEnable(GL_LIGHT1); <br> <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glFrontFace(GL_CCW); <br>    glEnable(GL_CULL_FACE); <br> <br>    Frames = (int)((float)(MAX_FRAMES / 2) * fTesselFact); <br> <br>    if (Frames &lt; 5) <br>        Frames = 5; <br>    if (Frames &gt; MAX_FRAMES) <br>        Frames = MAX_FRAMES; <br> <br>    angleDelta = (float) ((2.0 * PI) / Frames); <br>    sinAngle = 0.0f; <br> <br>    for (i = 0; i &lt; Frames; i++) { <br>        genWin(&amp;winMesh[i], &amp;winStreamer[i]); <br>        sinAngle += angleDelta; <br>    } <br>} <br> <br>void delWinScene() <br>{ <br>    int i; <br> <br>    for (i = 0; i &lt; Frames; i++) { <br>        delMesh(&amp;winMesh[i]); <br>        delMesh(&amp;winStreamer[i]); <br>    } <br>} <br> <br>void updateWinScene(int flags) <br>{ <br>    MESH *mesh; <br>    MFACE *faces; <br>    int i; <br>    static double mxrot = 23.0; <br>    static double myrot = 23.0; <br>    static double mzrot = 5.7; <br>    static double mxrotInc = 0.0; <br>    static double myrotInc = 3.0; <br>    static double mzrotInc = 0.0; <br>    static int h = 0; <br>    static int frameNum = 0; <br>    POINT3D *pp; <br>    POINT3D *pn; <br>    int lastC, lastD; <br>    int aOffs, bOffs, cOffs, dOffs; <br>    int a, b; <br> <br>    if (bColorCycle) { <br>        ss_HsvToRgb((float)h, 1.0f, 1.0f, &amp;winColors[0] ); <br> <br>        h++; <br>        h %= 360; <br>    } <br> <br>    glLoadIdentity(); <br>    glRotatef((GLfloat) mxrot, 1.0f, 0.0f, 0.0f); <br>    glRotatef((GLfloat) myrot, 0.0f, 1.0f, 0.0f); <br>    glRotatef((GLfloat) mzrot, 0.0f, 0.0f, 1.0f); <br> <br>    curMatl = 0; <br>    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &amp;winColors[0]); <br>    glMaterialfv(GL_FRONT, GL_SPECULAR, (GLfloat *) &amp;matlBrightSpecular); <br>    glMaterialf(GL_FRONT, GL_SHININESS, 60.0f); <br> <br>    mesh = &amp;winMesh[frameNum]; <br> <br>    glBegin(GL_QUAD_STRIP); <br> <br>    pp = mesh-&gt;pts; <br>    pn = mesh-&gt;norms; <br> <br>    for (i = 0, faces = mesh-&gt;faces, lastC = faces-&gt;p[0], lastD = faces-&gt;p[1]; <br>         i &lt; mesh-&gt;numFaces; i++, faces++) { <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br> <br>if (!bSmoothShading) { <br>            if ((a != lastC) || (b != lastD)) { <br>                glNormal3fv((GLfloat *)&amp;(faces - 1)-&gt;norm); <br> <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>                glVertex3fv((GLfloat *)((char *)pp +  <br>                            (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br> <br>            if (faces-&gt;material != curMatl) { <br>                curMatl = faces-&gt;material; <br>                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, <br>                             (GLfloat *) &amp;matlNoSpecular); <br>                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE,  <br>                             (GLfloat *) &amp;winColors[curMatl]); <br>            } <br> <br>            glNormal3fv((GLfloat *)&amp;faces-&gt;norm); <br>            glVertex3fv((GLfloat *)((char *)pp + (a &lt;&lt; 3) + (a &lt;&lt; 2))); <br>            glVertex3fv((GLfloat *)((char *)pp + (b &lt;&lt; 3) + (b &lt;&lt; 2))); <br>        } else { <br>            if ((a != lastC) || (b != lastD)) { <br>                cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>                dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>                glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>                glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>                glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>                glEnd(); <br>                glBegin(GL_QUAD_STRIP); <br>            } <br> <br>            aOffs = (a &lt;&lt; 3) + (a &lt;&lt; 2); <br>            bOffs = (b &lt;&lt; 3) + (b &lt;&lt; 2); <br> <br>            if (faces-&gt;material != curMatl) { <br>                curMatl = faces-&gt;material; <br>                glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, <br>                             (GLfloat *) &amp;matlNoSpecular); <br>                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE,  <br>                             (GLfloat *) &amp;winColors[curMatl]); <br>            } <br> <br>            glNormal3fv((GLfloat *)((char *)pn + aOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + aOffs)); <br>            glNormal3fv((GLfloat *)((char *)pn + bOffs)); <br>            glVertex3fv((GLfloat *)((char *)pp + bOffs)); <br>        } <br> <br>        lastC = faces-&gt;p[3]; <br>        lastD = faces-&gt;p[2]; <br>    } <br> <br>    if (!bSmoothShading) { <br>        glNormal3fv((GLfloat *)&amp;(faces - 1)-&gt;norm); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2))); <br>        glVertex3fv((GLfloat *)((char *)pp + (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2))); <br>    } else { <br>        cOffs = (lastC &lt;&lt; 3) + (lastC &lt;&lt; 2); <br>        dOffs = (lastD &lt;&lt; 3) + (lastD &lt;&lt; 2); <br> <br>        glNormal3fv((GLfloat *)((char *)pn + cOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + cOffs)); <br>        glNormal3fv((GLfloat *)((char *)pn + dOffs)); <br>        glVertex3fv((GLfloat *)((char *)pp + dOffs)); <br>    } <br> <br>    glEnd(); <br> <br>    glMaterialfv(GL_FRONT, GL_SPECULAR, (GLfloat *) &amp;matlDimSpecular); <br> <br>    glBegin(GL_QUADS); <br> <br>    mesh = &amp;winStreamer[frameNum]; <br> <br>    for (i = 0, faces = mesh-&gt;faces;  <br>         i &lt; mesh-&gt;numFaces; i++, faces++) { <br>        int a, b, c, d; <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br>        c = faces-&gt;p[2]; <br>        d = faces-&gt;p[3]; <br> <br>        if (faces-&gt;material != curMatl) { <br>            curMatl = faces-&gt;material; <br>            glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE,  <br>                         (GLfloat *)&amp;winColors[curMatl]); <br>        } <br> <br>        glNormal3fv((GLfloat *)&amp;faces-&gt;norm); <br>        glVertex3fv((GLfloat *)(mesh-&gt;pts + a)); <br>        glVertex3fv((GLfloat *)(mesh-&gt;pts + b)); <br>        glVertex3fv((GLfloat *)(mesh-&gt;pts + c)); <br>        glVertex3fv((GLfloat *)(mesh-&gt;pts + d)); <br>    } <br> <br>    glEnd(); <br> <br>    mxrot += mxrotInc; <br>    myrot += myrotInc; <br>    mzrot += mzrotInc; <br> <br>    if ((myrot &lt; -45.0) || (myrot &gt; 45.0)) <br>        myrotInc = -myrotInc; <br> <br>    frameNum++; <br>    if (frameNum &gt;= Frames) <br>        frameNum = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
