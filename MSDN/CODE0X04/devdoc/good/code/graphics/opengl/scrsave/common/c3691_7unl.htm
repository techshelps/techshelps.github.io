<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSWPROC.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3711"></a>SSWPROC.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: sswproc.cxx <br>* <br>* Window procedure functions. <br>* <br>* Copyright 1996 - 1998 Microsoft Corporation <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;time.h&gt; <br> <br>#include "ssintrnl.hxx" <br>#include "sswproc.hxx" <br>#include "palette.hxx" <br>#include "clear.hxx" <br> <br>// forward declarations of internal functions <br> <br>static void ss_TimerProc(); <br>LONG SS_ScreenSaverProc(HWND, UINT, WPARAM, LPARAM); <br> <br>LONG  <br>FullScreenPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br> <br>static void  <br>ssw_RelayMessageToChildren( PSSW pssw, UINT msg, WPARAM wParam, LPARAM lParam); <br> <br>static void ssw_RealizePalette( PSSW pssw, BOOL bBackground ); <br>static void ssw_DeletePalette( PSSW pssw ); <br> <br>/**************************************************************************\ <br>* ScreenSaverProc <br>* <br>* Processes messages for the top level screen saver window. <br>* <br>* Unhandled msgs are sent to DefScreenSaverProc <br>\**************************************************************************/ <br> <br>LONG  <br>ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static BOOL bInited = FALSE; <br>    static UINT idTimer = 0; <br>    // Draw timer time-out interval <br>#ifdef SS_DEBUG   <br>    static UINT uiTimeOut = 2;  // Let it rip ! <br>#else <br>    static UINT uiTimeOut = 16; // Cap at ~60 fps <br>#endif <br>    static BOOL bSuspend = FALSE; <br>#ifdef SS_WIN95_TIMER_HACK <br>    static BOOL bIdle = FALSE; <br>#endif <br>    PSSW pssw; <br> <br>    switch (message) <br>    { <br>        case WM_CREATE: <br>        case WM_ERASEBKGND: <br>        case SS_WM_INITGL: <br>            return SS_ScreenSaverProc( hwnd, message, wParam, lParam); <br> <br>        case WM_ACTIVATE: <br>            if ( LOWORD(wParam) == WA_INACTIVE ) { <br>                SS_DBGMSG( "Main_Proc: WM_ACTIVATE inactive\n" ); <br>                gpss-&gt;bInForeground = FALSE; <br>            } else { <br>                SS_DBGMSG( "Main_Proc: WM_ACTIVATE active\n" ); <br>                gpss-&gt;bInForeground = TRUE; <br>            } <br> <br>            // fall thru <br> <br>        case WM_QUERYNEWPALETTE: <br>        case WM_PALETTECHANGED: <br>        case WM_SYSCOLORCHANGE: <br>        case SS_WM_PALETTE: <br>            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) ); <br> <br>        case SS_WM_START: <br>            SS_DBGMSG( "Main_Proc: SS_WM_START\n" ); <br>            // This is the main GL startup point. The global animation timer <br>            // is started, and SS_WM_START is relayed to the window chain. <br> <br>// for 'delayed background paint' problem in preview mode - in <br>// floater type ss's, the main window gets this delayed bg paint thing that <br>// makes the floater obvious.  By relenquishing our time slice here, the <br>// problem goes away... <br>            if( gpss-&gt;type == SS_TYPE_PREVIEW ) { <br>                Sleep(0); <br>            } <br> <br>            // Initialize the animation timer - it should start up once we <br>            // return from here <br> <br>            idTimer = 1; <br>            SetTimer(hwnd, idTimer, uiTimeOut, 0); <br> <br>#ifdef SS_DEBUG <br>            // Start timer for calculating update rate <br>            gpss-&gt;timer.Start(); <br>#endif <br>            if( !bInited ) <br>                bInited = TRUE; <br> <br>            // Process SS_WM_START for the window chain <br>            return SS_ScreenSaverProc( hwnd, message, wParam, lParam); <br> <br>#ifdef SS_WIN95_TIMER_HACK <br>        case SS_WM_IDLE : <br>            if( wParam == SS_IDLE_ON ) <br>                bIdle = TRUE; <br>            else if( wParam == SS_IDLE_OFF ) <br>                bIdle = FALSE; <br>            break; <br>#endif <br> <br>        case WM_DESTROY: <br>            if (idTimer) { <br>                KillTimer(hwnd, idTimer); <br>                idTimer = 0; <br>            } <br> <br>            // Destroy any children of the top level window <br> <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br> <br>            PSSW psswChild; <br>            psswChild = pssw-&gt;psswChildren; <br> <br>            while( psswChild ) { <br>                if( psswChild-&gt;hwnd ) <br>                    DestroyWindow( psswChild-&gt;hwnd ); <br>                psswChild = pssw-&gt;psswSibling; <br>            } <br> <br>            // Handle any palette stuff <br> <br>// Before deleting this top level window, we need to use its <br>// still-valid dc to things like restore SystemPaletteUse mode.  Ideally this <br>// should be done after ~SSW has dumped GL, but ~SSW also releases the DC. <br>// If this is a problem, we can create a new function SSW::DeleteGL that just <br>// gets rid of the GL part <br> <br>            if( gpss-&gt;pssPal ) <br>                ssw_DeletePalette( pssw ); <br> <br>            // Dump the main pssw <br>            delete pssw; <br> <br>            // All pssw's have now been deleted - remove global ptr to top of <br>            // window chain. <br>            gpss-&gt;psswMain = NULL; <br> <br>            PostQuitMessage(0); <br>            return 0; <br> <br>        case SS_WM_CLOSING: <br>            // This message is sent when the screen saver receives a WM_CLOSE <br>            // msg, *after* any password protection routines. <br>            // For now, only sent in /s mode <br>            SS_DBGMSG( "Main_Proc: SS_WM_CLOSING\n" ); <br> <br>            if( gpss-&gt;bResSwitch ) { <br>                // pssw-&gt;GdiClear(); <br>                // mf: untested for child window case <br>                // Restore previous display settings <br>                // Note that this is also checked for in ~SCRNSAVE, in <br>                // case this message is not hit. <br>                ChangeDisplaySettings(NULL, CDS_FULLSCREEN); <br>                gpss-&gt;bResSwitch = FALSE; <br>            } <br>            return 0; <br> <br>        case WM_SETFOCUS: <br>            SS_DBGMSG( "Main_Proc: WM_FOCUS\n" ); <br>            // this catches some of the win95 passwd dialog problems, where <br>            // we don't get repaint msgs when dialogs end <br>            if( ss_fOnWin95() &amp;&amp; ss_fFullScreenMode() ) { <br>                pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>                pssw-&gt;Repaint( FALSE ); <br>            } <br>            break; <br> <br>#if DBG <br>        case WM_SHOWWINDOW: <br>            SS_DBGMSG( "Main_Proc: WM_SHOWWINDOW\n" ); <br>            break; <br>#endif <br> <br>        case WM_PAINT: <br>            SS_DBGMSG( "Main_Proc: WM_PAINT\n" ); <br> <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>            pssw-&gt;Repaint( TRUE ); <br> <br>#ifdef SS_DO_PAINT <br>            // We do the painting rather than letting the system do it <br>            hdc = BeginPaint(hwnd, &amp;ps); <br> <br>            // This is case where bg brush is NULL and we have to do repaint <br>            // We only do it after bInited, as this will avoid the first <br>            // WM_PAINT for the entire window. <br>            if( bInited ) <br>                DrawGdiRect( hdc, gpss-&gt;hbrBg, &amp;ps.rcPaint ); <br>            EndPaint(hwnd, &amp;ps); <br>#endif // SS_DO_PAINT <br> <br>#ifdef SS_DELAYED_START_KLUGE <br>            if( !bInited &amp;&amp; SS_DELAY_START(gpss-&gt;type) ) { <br>                bInited = TRUE; <br> <br>                // Do initial GL configuration <br>                PostMessage( hwnd, SS_WM_INITGL, 0, 0 ); <br>                // Start drawing <br>                PostMessage( hwnd, SS_WM_START, 0, 0 ); <br>            } <br>#endif // SS_DELAYED_START_KLUGE <br> <br>            if( pssw-&gt;iSubWindow ) { <br>                // If this window has sub windows, mark the bg for validation, <br>                // since for hardware double buffered schemes, Swapbuffers <br>                // may swap in ugly garbage. <br>                pssw-&gt;bValidateBg = TRUE; <br>            } <br> <br>#ifdef SS_DO_PAINT <br>            return 0; // painting has been handled by us <br>#endif // SS_DO_PAINT <br> <br>            break; <br> <br>        case WM_SIZE: <br>            // Suspend drawing if minimized <br>            if( wParam == SIZE_MINIMIZED ) <br>                bSuspend = TRUE; <br>            else  // either SIZE_RESTORED or SIZE_MAXIMIZED <br>                bSuspend = FALSE; <br> <br>            return SS_ScreenSaverProc( hwnd, message, wParam, lParam); <br> <br>        case WM_MOVE: <br>            SS_DBGMSG( "Main_Proc: WM_MOVE\n" ); <br>            // See note for WM_PAINT for subWindows <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br> <br>            //mf: kluge for non-floater workaround : see above <br>            if( pssw-&gt;iSubWindow )  <br>                pssw-&gt;bValidateBg = TRUE; <br> <br>            break; <br> <br>        case WM_TIMER: <br>            if( bSuspend ) <br>                return 0; <br> <br>#ifdef SS_WIN95_TIMER_HACK <br>            if( bIdle ) { <br>                // We are in an idle state, and don't want to flood the queue <br>                // with WM_TIMER mesages.  So we kill the timer, do our <br>                // drawing, then start another timer. <br> <br>                // Kill current timer <br>                if (idTimer) <br>                    KillTimer(hwnd, idTimer); <br>                else <br>                    // unlikely, but what the hay <br>                    return 0; <br>            } <br>#endif <br> <br>            ss_TimerProc(); <br> <br>#ifdef SS_WIN95_TIMER_HACK <br>            if( bIdle ) { <br>                // Start another animation timer after we've done drawing <br>                SetTimer(hwnd, idTimer, uiTimeOut, 0); <br>            } <br>#endif <br>            return 0; <br>    } <br> <br>    return DefScreenSaverProc(hwnd, message, wParam, lParam); <br>} <br> <br>/**************************************************************************\ <br>* SS_ScreenSaverProc <br>* <br>* Wndproc for child windows, and some messages from top-level window <br>* <br>* Unhandled msgs are sent to DefWindowProc <br>\**************************************************************************/ <br> <br>LONG  <br>SS_ScreenSaverProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    HDC hdc; <br>    PAINTSTRUCT ps; <br>    PSSW pssw; <br> <br>    switch (message) <br>    { <br>        case WM_CREATE: <br>            SS_DBGMSG1( "SS_Proc: WM_CREATE for 0x%x\n", hwnd ); <br> <br>            pssw = (PSSW) ( ((LPCREATESTRUCT)lParam)-&gt;lpCreateParams );  <br>            gpss-&gt;sswTable.Register( hwnd, pssw ); <br>   <br>            pssw-&gt;size.width  = ((LPCREATESTRUCT)lParam)-&gt;cx; <br>            pssw-&gt;size.height = ((LPCREATESTRUCT)lParam)-&gt;cy; <br>            pssw-&gt;hwnd = hwnd; <br>            break; <br> <br>        case SS_WM_INITGL: <br>            SS_DBGMSG1( "SS_Proc: SS_WM_INITGL for 0x%x\n", hwnd ); <br> <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>            pssw-&gt;InitGL(); <br> <br>            break; <br> <br>#ifdef SS_MULTI_WINDOW_TIMERS <br>// Enable this section and fill it in if windows start their own animation <br>// timers.  For now, there is just one timer on the main window. <br>        case SS_WM_START: <br>            SS_DBGMSG1( "SS_Proc: SS_WM_START for 0x%x\n", hwnd ); <br> <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br> <br>            // Send SS_WM_START to any children of this window <br>            ssw_RelayMessageToChildren( pssw, SS_WM_START, 0, 0 );  <br> <br>            // Nothing really to do here yet... <br> <br>            break; <br>#endif <br> <br>        case SS_WM_PALETTE: <br>            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) ); <br> <br>        case WM_DESTROY: <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br> <br>            SS_DBGMSG1( "SS_Proc: WM_DESTROY for 0x%x\n", hwnd ); <br>            // Kill off any children of this window first <br> <br>            PSSW psswChild; <br>            psswChild = pssw-&gt;psswChildren; <br> <br>            while( psswChild ) { <br>                if( psswChild-&gt;hwnd ) <br>                    DestroyWindow( psswChild-&gt;hwnd ); <br>                else <br>                    delete psswChild; <br>                psswChild = pssw-&gt;psswSibling; <br>            } <br>            // Delete the pssw - this does all necessary cleanup <br> <br>            delete pssw; <br>            break; <br> <br>        case WM_ERASEBKGND: <br>            SS_DBGMSG1( "SS_Proc: WM_ERASEBKGRND for 0x%x\n", hwnd ); <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>            pssw-&gt;Repaint( FALSE ); <br>            // Don't process this message <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br> <br>        case WM_PAINT: <br>            // We get this msg every time window moves, since SWP_NOCOPYBITS is <br>            // specified with the window move. <br>            hdc = BeginPaint(hwnd, &amp;ps); <br>            EndPaint(hwnd, &amp;ps); <br>            break; <br> <br>        case WM_SIZE: <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>            pssw-&gt;Resize( LOWORD(lParam), HIWORD(lParam) ); <br>            break; <br> <br>        // these msg's are never received by the child window ? <br>        case WM_ACTIVATE: <br>        case WM_QUERYNEWPALETTE: <br>        case WM_PALETTECHANGED: <br>            return( MainPaletteManageProc( hwnd, message, wParam, lParam ) ); <br> <br> <br>        case WM_SYSCOMMAND: <br>        case WM_SETCURSOR: <br>        case WM_ACTIVATEAPP: <br>        case WM_MOUSEMOVE: <br>        case WM_LBUTTONDOWN: <br>        case WM_MBUTTONDOWN: <br>        case WM_RBUTTONDOWN: <br>        case WM_KEYDOWN: <br>        case WM_SYSKEYDOWN: <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>            return DefScreenSaverProc(pssw-&gt;psswParent-&gt;hwnd, message, wParam, lParam); <br> <br>        default:  <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br>    } <br>    return 0; <br>} <br> <br>#ifdef SS_DEBUG <br>/**************************************************************************\ <br>* PrintUpdateRate <br>* <br>* Print number of updates per second in the title bar <br>* <br>\**************************************************************************/ <br> <br>static void <br>PrintUpdateRate( double elapsed, long updateCount ) <br>{ <br>    char buf[100]; <br>    double updateRate; <br> <br>    if( elapsed == 0.0 ) <br>        updateRate = 0.0; <br>    else <br>        updateRate = updateCount / elapsed; <br> <br>    sprintf( buf, "Updates per second = %4.1f", updateRate ); <br>    SendMessage(gpss-&gt;psswMain-&gt;hwnd, WM_SETTEXT, 0, (LPARAM)buf); <br>} <br>#endif <br> <br> <br>/**************************************************************************\ <br>* ss_TimerProc <br>* <br>* Every time a timer event fires off, update all active windows <br>* <br>\**************************************************************************/ <br> <br>static void  <br>ss_TimerProc() <br>{ <br>    static int busy = FALSE; <br>#ifdef SS_DEBUG <br>    static long updateCount = 0; <br>    static double updateInterval = 2.0; <br>    SS_TIMER *pTimer = &amp;gpss-&gt;timer; <br>#endif <br> <br>    if (busy) <br>        return; <br>    busy = TRUE; <br> <br>    gpss-&gt;psswMain-&gt;UpdateWindow(); <br> <br>#ifdef SS_DEBUG <br>    updateCount++; <br>    if( gpss-&gt;bDoTiming &amp;&amp;  <br>        (( (double) pTimer-&gt;ElapsedTime() ) &gt;= updateInterval) )  <br>    { <br>        double elapsed = pTimer-&gt;Stop(); <br>        PrintUpdateRate( elapsed, updateCount ); <br>        updateCount = 0; <br>        pTimer-&gt;Start(); <br>    } <br>#endif <br> <br>    busy = FALSE; <br>} <br> <br>/**************************************************************************\ <br>* RelayMessageToChildren <br>* <br>* Pass along the message to any child windows <br>\**************************************************************************/ <br> <br>static void <br>ssw_RelayMessageToChildren( PSSW pssw, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    PSSW psswChild = pssw-&gt;psswChildren; <br> <br>    while( psswChild ) { <br>        if( psswChild-&gt;hwnd ) <br>            SendMessage( psswChild-&gt;hwnd, msg, wParam, lParam ); <br>        psswChild = psswChild-&gt;psswSibling; <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* UpdateDIBColorTable <br>* <br>* Wrapper for SSDIB_UpdateColorTable.   <br>* <br>* This controls the hPal parameter for SSDIB_UpdateColorTable. <br>* <br>\**************************************************************************/ <br> <br>void <br>ssw_UpdateDIBColorTable( HDC hdcbm, HDC hdcwin ) <br>{ <br>    SS_PAL *pssPal = gpss-&gt;pssPal; <br> <br>    if( !pssPal ) <br>        return; <br>    HPALETTE hpal =  pssPal-&gt;hPal; <br> <br>    SSDIB_UpdateColorTable( hdcbm, hdcwin, hpal ); <br>} <br> <br> <br>/**************************************************************************\ <br>* RealizePalette <br>* <br>\**************************************************************************/ <br> <br>static void <br>ssw_RealizePalette( PSSW pssw, BOOL bBackground ) <br>{ <br>    // assumed pssPal valid if get here <br>    SS_PAL *pssPal = gpss-&gt;pssPal; <br> <br>    if( !pssw-&gt;hrc ) { <br>        // Can assume this window doesn't need to worry about palettes, but <br>        // if any of its children are subWindows, it will have to take care <br>        // of it *for* them. <br>        if( ! pssw-&gt;iSubWindow ) <br>            return; // no hrc and no subWindow children <br>    } <br>    pssPal-&gt;Realize( pssw-&gt;hwnd, pssw-&gt;hdc, bBackground ); <br> <br>    if( pssw-&gt;pStretch &amp;&amp; pssw-&gt;pStretch-&gt;ssbm.hdc ) { <br>        SS_BITMAP *pssbm = &amp;pssw-&gt;pStretch-&gt;ssbm; <br>        ssw_UpdateDIBColorTable( pssbm-&gt;hdc, pssw-&gt;hdc ); <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* ssw_DeletePalette <br>* <br>\**************************************************************************/ <br> <br>static void <br>ssw_DeletePalette( PSSW pssw ) <br>{ <br>    SS_PAL *pssPal = gpss-&gt;pssPal; <br> <br>    if( pssPal-&gt;bTakeOver ) { <br>        // We took over the system palette - make a note of this <br>        // for any special ss termination conditions. <br>        gpss-&gt;flags |= SS_PALETTE_TAKEOVER; <br>    } <br>    pssPal-&gt;SetDC( pssw-&gt;hdc ); <br>    delete pssPal; <br>    gpss-&gt;pssPal = NULL; <br>} <br> <br>/**************************************************************************\ <br>* PaletteManage Procs <br>\**************************************************************************/ <br> <br>/* palette related msgs's: <br>    - WM_ACTIVATE: <br>        The WM_ACTIVATE message is sent when a window is being activated or  <br>        deactivated. This message is sent first to the window procedure of  <br>        the top-level window being deactivated; it is then sent to the  <br>        window procedure of the top-level window being activated.  <br> <br>    - WM_QUERYNEWPALETTE: <br>        The WM_QUERYNEWPALETTE message informs a window that it is about  <br>        to receive the keyboard focus, giving the window the opportunity  <br>        to realize its logical palette when it receives the focus.  <br> <br>        If the window realizes its logical palette, it must return TRUE;  <br>        otherwise, it must return FALSE.  <br> <br>    - WM_PALETTECHANGED: <br>        The WM_PALETTECHANGED message is sent to all top-level and overlapped  <br>        windows after the window with the keyboard focus has realized its  <br>        logical palette, thereby changing the system palette. This message  <br>        enables a window that uses a color palette but does not have the  <br>        keyboard focus to realize its logical palette and update its client  <br>        area.  <br> <br>        This message must be sent to all top-level and overlapped windows,  <br>        including the one that changed the system palette. If any child  <br>        windows use a color palette, this message must be passed on to them  <br>        as well.  <br>        To avoid creating an infinite loop, a window that receives this  <br>        message must not realize its palette, unless it determines that  <br>        wParam does not contain its own window handle.  <br> <br>    - WM_SYSCOLORCHANGE: <br>        The WM_SYSCOLORCHANGE message is sent to all top-level windows when  <br>        a change is made to a system color setting.  <br> <br>    - SS_WM_PALETTE: <br>        Internal msg.  Uses: <br>        - In fullscreen mode, we send this from Main wndproc to main  <br>          window's children on WM_ACTIVATE. <br>        - When this is received in SS_ScreenSaverProc, if fullscreen, <br>          it does: <br>                    UnrealizeObject( pssPal-&gt;hPal ); <br>                    RealizePalette( hdc ); <br>          otherwise, it is passed to PaletteManageProc, where <br>          Realize is called (for 'floater' windows to realize  <br>          their palettes). <br>        - It is also sent by DelayPaletteRealization() when it can't get <br>          the system palette. <br> <br>*/ <br> <br> <br>/**************************************************************************\ <br>* MainPaletteManageProc <br>* <br>* Top-level palette management proc. <br> <br>* Returns immediately if no palette set - otherwise calls through <br>* paletteManageProc function pointer <br>* <br>\**************************************************************************/ <br> <br>LONG  <br>MainPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    if( !gpss-&gt;pssPal ) <br>        // No palette management required <br>        return 0; <br> <br>    // else call approppriate palette manage proc <br>    return (*gpss-&gt;pssPal-&gt;paletteManageProc)(hwnd, message, wParam, lParam); <br>} <br> <br>LONG  <br>NullPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    return 0; <br>} <br> <br>/**************************************************************************\ <br>* FullScreenPaletteManageProc <br>* <br>* Processes messages relating to palette management in full screen mode. <br>* <br>\**************************************************************************/ <br> <br>LONG  <br>FullScreenPaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    SS_PAL *pssPal; <br>    PSSW pssw; <br> <br>    switch (message) <br>    { <br>        case WM_ACTIVATE: <br> <br>#if SS_DEBUG <br>            if ( LOWORD(wParam) == WA_INACTIVE ) <br>                SS_DBGMSG1( "FullScreen_PMProc: WM_ACTIVATE : inactive for 0x%x\n", <br>                           hwnd ); <br>            else <br>                SS_DBGMSG1( "FullScreen_PMProc: WM_ACTIVATE : active for 0x%x\n", <br>                           hwnd ); <br>#endif <br> <br>            // !! This msg is only sent to main top level window <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br> <br>            pssPal = gpss-&gt;pssPal; <br>            if ( pssPal-&gt;bUseStatic ) { <br>                HDC hdc = pssw-&gt;hdc; // hdc *always* valid for top-level pssw <br>                // Note: wParam = 0 when window going *inactive* <br>                SetSystemPaletteUse( hdc, wParam ? SYSPAL_NOSTATIC <br>                                                : pssPal-&gt;uiOldStaticUse); <br>            } <br> <br>            // Send SS_WM_PALETTE msg to main window <br>            SendMessage( hwnd, SS_WM_PALETTE, wParam, 0); <br>            break; <br> <br>        case SS_WM_PALETTE: <br> <br>            SS_DBGMSG1( "FullScreen_PMProc: SS_WM_PALETTE for 0x%x\n", hwnd ); <br> <br>            pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br> <br>            ssw_RelayMessageToChildren( pssw, SS_WM_PALETTE, wParam, 0 ); <br> <br>            HDC hdc; <br>            if( hdc = pssw-&gt;hdc ) <br>            { <br>                pssPal = gpss-&gt;pssPal; <br> <br>// this should call thru ssw_RealizePalette for bitmap case ? (for now <br>// don't need to, since we take over palette...) <br>                // This resets the logical palette, causing remapping of <br>                // logical palette to system palette <br>                UnrealizeObject( pssPal-&gt;hPal ); <br>                RealizePalette( hdc ); <br>            } <br>            break; <br>    } <br>    return 0; <br>} <br> <br>/**************************************************************************\ <br>* PaletteManageProc <br>* <br>* Processes messages relating to palette management for the general case. <br>* <br>* Note: this msg handling strategy is based loosely on the tk, so any changes  <br>* there should be reflected here <br>\**************************************************************************/ <br> <br>LONG  <br>PaletteManageProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    // One global palette for all windows <br>    if( !gpss-&gt;pssPal ) <br>        return 0; <br> <br>    switch (message) <br>    { <br>      case WM_ACTIVATE: <br> <br>        SendMessage( hwnd, SS_WM_PALETTE, gpss-&gt;bInBackground(), 0); <br> <br>        // Allow DefWindowProc() to finish the default processing (which  <br>        // includes changing the keyboard focus). <br> <br>        break; <br> <br>      case WM_QUERYNEWPALETTE: <br> <br>        SS_DBGMSG1( "Palette_Proc: WM_QUERYNEWPALETTE for 0x%x\n", hwnd ); <br>        // We don't actually realize palette here (we do it at WM_ACTIVATE <br>        // time), but we need the system to think that we have so that a <br>        // WM_PALETTECHANGED message is generated. <br> <br>        // This is the only msg preview mode gets wrt palettes ! <br>        if( !ss_fPreviewMode() ) <br>            return (1); <br> <br>        // We are in preview mode - realize the palette <br>        SendMessage( hwnd, SS_WM_PALETTE, gpss-&gt;bInBackground(), 0); <br>        break; <br> <br>      case WM_PALETTECHANGED: <br> <br>        SS_DBGMSG1( "Palette_Proc: WM_PALETTECHANGED for 0x%x\n", hwnd ); <br>        // Respond to this message only if the window that changed the palette <br>        // is not this app's window. <br> <br>        // We are not the foreground window, so realize palette in the <br>        // background.  We cannot call Realize to do this because <br>        // we should not do any of the gbUseStaticColors processing while <br>        // in background. <br> <br>        // Actually, we *can* be the fg window, so don't realize if <br>        // we're in foreground <br> <br>        if( (hwnd != (HWND) wParam) &amp;&amp; gpss-&gt;bInBackground() ) <br>            SendMessage( hwnd, SS_WM_PALETTE, TRUE, 0); <br> <br>        break; <br> <br>      case WM_SYSCOLORCHANGE: <br> <br>        // If the system colors have changed and we have a palette <br>        // for an RGB surface then we need to recompute the static <br>        // color mapping because they might have been changed in <br>        // the process of changing the system colors. <br> <br>          SS_DBGMSG1( "Palette_Proc: WM_SYSCOLORCHANGE for 0x%x\n", hwnd ); <br>          gpss-&gt;pssPal-&gt;ReCreateRGBPalette(); <br>          SendMessage( hwnd, SS_WM_PALETTE, gpss-&gt;bInBackground(), 0); <br>          break; <br>             <br>      case SS_WM_PALETTE: <br> <br>          SS_DBGMSG2( "Palette_Proc: SS_WM_PALETTE for 0x%x, bg = %d\n",  <br>                          hwnd, wParam ); <br> <br> <br>          // Realize palette for this window and its children <br>          // wParam = TRUE if realize as bg <br> <br>          PSSW pssw = gpss-&gt;sswTable.PsswFromHwnd( hwnd ); <br>          ssw_RelayMessageToChildren( pssw, message, wParam, lParam );  <br>          ssw_RealizePalette( pssw, wParam ); <br>          break; <br>    } <br>    return 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* GLScreenSaverConfigureDialog <br>* <br>* This is a wrapper for ScreenSaverConfigureDialog, which is the main dialog <br>* proc for all the GL screen savers in config mode. <br>*  <br>* We call the client's ss_ConfigInit() routine on the first WM_PAINT, since <br>* the dialog will have focus at this point (can realize palette) and all <br>* buttons should have been created. <br>\**************************************************************************/ <br> <br>BOOL <br>GLScreenSaverConfigureDialog( HWND hDlg, UINT msg, WPARAM wParam, <br>                              LPARAM lParam ) <br>{ <br>    static BOOL bInited = 0; <br> <br>    switch( msg ) { <br>        case WM_INITDIALOG : <br>          { <br>            SS_DBGMSG( "GLScreenSaverConfigureDialog: WM_INITDIALOG\n" ); <br>            // Create wrapper pssw for the dialog box <br> <br>            PSSW pssw; <br>            pssw = new SSW( NULL,       // ssw parent <br>                            hDlg <br>                          ); <br>            SS_ASSERT( pssw, "GLScreenSaverConfigureDialog : alloc failure for psswMain\n" ); <br> <br>            gpss-&gt;psswMain = pssw; <br> <br>            // Load any resource strings common to all the dialogs <br>            BOOL bStringsLoaded = ss_LoadTextureResourceStrings(); <br>            // If this doesn't work, things are seriously wrong and we <br>            // shouldn't continue <br>            SS_ASSERT( bStringsLoaded, "GLScreenSaverConfigureDialog : failure loading common resource strings\n" ); <br>          } <br>          break; <br> <br>        case WM_PAINT: <br> <br>            if( !bInited ) { <br>                // Call client's ss_ConfigInit() <br>                if( !ss_ConfigInit( hDlg ) ) { <br>                    SS_WARNING( "ConfigInit failed\n" ); <br>                    // Send WM_CLOSE to the dialog - this will enable any <br>                    // cleanup code to be called by the client <br>                    SendMessage( hDlg, WM_CLOSE, 0, 0l ); <br>                } <br>                bInited = TRUE; <br>            } <br>            break; <br> <br>        case WM_ACTIVATE: <br>        case WM_QUERYNEWPALETTE: <br>        case WM_PALETTECHANGED: <br>        case SS_WM_PALETTE: <br>            return( MainPaletteManageProc( hDlg, msg, wParam, lParam ) ); <br> <br>    } <br>    return ScreenSaverConfigureDialog( hDlg, msg, wParam, lParam ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SSW_TABLE constructor <br>* <br>\**************************************************************************/ <br> <br>SSW_TABLE::SSW_TABLE() <br>{ <br>    nEntries = 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* Register <br>* <br>* Register a HWND/PSSW pair. <br>\**************************************************************************/ <br> <br>void <br>SSW_TABLE::Register( HWND hwnd, PSSW pssw ) <br>{ <br>    SSW_TABLE_ENTRY *pEntry; <br> <br>    // Check if already in table <br>    if( PsswFromHwnd( hwnd ) ) <br>        return; <br> <br>    // put hwnd/pssw pair in the table <br>    pEntry = &amp;sswTable[nEntries]; <br>    pEntry-&gt;hwnd = hwnd; <br>    pEntry-&gt;pssw = pssw; <br>    nEntries++; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* PsswFromHwnd <br>* <br>* Return PSSW for the HWND </code></pre>
<p>
</p>
<pre><code>\**************************************************************************/ <br> <br>PSSW <br>SSW_TABLE::PsswFromHwnd( HWND hwnd ) <br>{ <br>    int count = nEntries; <br>    SSW_TABLE_ENTRY *pEntry = sswTable; <br> <br>    while( count-- ) { <br>        if( pEntry-&gt;hwnd == hwnd ) <br>            return pEntry-&gt;pssw; <br>        pEntry++; <br>    } <br>    return NULL; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* Remove <br>* <br>* Remove HWND/PSSW entry from table <br>\**************************************************************************/ <br> <br>BOOL <br>SSW_TABLE::Remove( HWND hwnd ) <br>{ <br>    SSW_TABLE_ENTRY *pEntry = sswTable; <br> <br>    // Locate the hwnd/pssw pair <br> <br>    for( int count = 0 ; count &lt; nEntries ; count++, pEntry++ ) { <br>        if( pEntry-&gt;hwnd == hwnd ) <br>            break; <br>    } <br> <br>    if( count == nEntries ) <br>        // couldn't find it in the table <br>        return FALSE; <br> <br>    // Remove entry / shuffle up other entries <br>    for( int i = count; i &lt; nEntries-1; i ++ ) { <br>        sswTable[i] = sswTable[i+1]; <br>    } <br> <br>    nEntries--; <br>    return TRUE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
