<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENSTRIP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3683"></a>GENSTRIP.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: genstrip.c <br>* <br>* The Ribbon and 2 Ribbon styles of the 3D Flying Objects screen saver. <br>* <br>* Animation of 1 or 2 quad strips floating about. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br>#include "mesh.h" <br> <br>static MESH stripMesh; <br>static int iPrec = 40; <br> <br>void genStrip() <br>{ <br>    static int counter = 0; <br>    int i; <br>    int facecount; <br>    // Use Hermite basis, pg 488, FVD <br>    static float M[4][4] = {{2.0f, -2.0f, 1.0f, 1.0f}, <br>                            {-3.0f, 3.0f, -2.0f, -1.0f}, <br>                            {0.0f, 0.0f, 1.0f, 0.0f}, <br>                            {1.0f, 0.0f, 0.0f, 0.0f}}; <br>    float xx[4], yy[4], zz[4]; <br>    float cx[4], cy[4], cz[4]; <br>    float d = 1.0f / (float) iPrec; <br>    float t = 0.0f; <br>    float t2, t3; <br>    POINT3D p1 = {-0.5f, 0.0f, 0.0f}; <br>    POINT3D p2 = {0.5f, 0.0f, 0.0f}; <br>    POINT3D v1 = {1.5f, 1.5f, 0.0f}; <br>    POINT3D v2 = {0.0f, 3.0f, 0.0f}; <br>    POINT3D norm; <br>    float sinVal; <br>    float angle; <br>    float angleStep = (float) (PI / iPrec); <br>    static float rotA = 0.0f; <br>    static float rotB = (float) (PI / 2.0); <br>    static float sideSin = 0.0f; <br>    float rotStepA = (float) (PI / (2.0 * iPrec)); <br>    float rotStepB = (float) (PI / (4.0 * iPrec)); <br>    MESH *mesh = &amp;stripMesh; <br> <br>#define NORMS(x, y) stripMesh.norms[((x) * iPrec) + y] <br>#define GRID(x, y)  stripMesh.pts[((x) * iPrec) + y] <br>     <br>    v1.x = (float) (4.0 * cos(rotA)); <br>    v1.y = (float) (4.0 * sin(rotA)); <br> <br>    p2.x = (float) (0.5 * sin(rotB)); <br>//    p2.y = (float) (0.5 * sin(rotB)); <br>     <br>    rotA += rotStepA; <br>    rotB += rotStepB; <br>    counter++; <br>    if (counter &gt;= (2 * iPrec)) { <br>        rotStepA = -rotStepA; <br>        counter = 0; <br>    } <br> <br>    angle = sideSin; <br>    sideSin += (float) (PI / 80.0); <br>     <br>    xx[0] = p1.x; <br>    xx[1] = p2.x; <br>    xx[2] = v1.x; <br>    xx[3] = v2.x; <br> <br>    yy[0] = p1.y; <br>    yy[1] = p2.y; <br>    yy[2] = v1.y; <br>    yy[3] = v2.y; <br> <br>    zz[0] = p1.z; <br>    zz[1] = p2.z; <br>    zz[2] = v1.z; <br>    zz[3] = v2.z; <br>     <br>    for (i = 0; i &lt; 4; i++) { <br>        cx[i] = xx[0] * M[i][0] + xx[1] * M[i][1] + <br>                xx[2] * M[i][2] + xx[3] * M[i][3]; <br>        cy[i] = yy[0] * M[i][0] + yy[1] * M[i][1] + <br>                yy[2] * M[i][2] + yy[3] * M[i][3]; <br>        cz[i] = zz[0] * M[i][0] + zz[1] * M[i][1] + <br>                zz[2] * M[i][2] + zz[3] * M[i][3]; <br>    } <br> <br>    for (i = 0; i &lt; iPrec; i++) { <br>        float x, y; <br>             <br>        t += d; <br>        t2 = t * t; <br>        t3 = t2 * t; <br>         <br>        x = cx[0] * t3 + cx[1] * t2 + cx[2] * t + cx[3]; <br>        y = cy[0] * t3 + cy[1] * t2 + cy[2] * t + cy[3]; <br>         <br>        sinVal = (float) (sin(angle) / 5.0); <br>        if (sinVal &lt; 0.0) <br>            sinVal = -sinVal; <br>        angle += angleStep; <br>        <br>        GRID(0, i).x = x; <br>        GRID(0, i).z = y; <br>        GRID(0, i).y = 0.25f;    // extrusion // + sinVal; <br>        GRID(1, i).x = x; <br>        GRID(1, i).z = y; <br>        GRID(1, i).y = -0.25f;   // - sinVal; <br>    } <br> <br>    stripMesh.numFaces = 0; <br>     <br>    for (i = 0; i &lt; 2 * iPrec; i++) <br>        mesh-&gt;norms[i] = ss_ptZero; <br> <br>    for (facecount = 0, i = 0; i &lt; (iPrec - 1); i++) { <br>         <br>        ss_calcNorm(&amp;norm, &amp;GRID(0, i + 1), &amp;GRID(0, i), &amp;GRID(1, i)); <br>        stripMesh.faces[facecount].material = 0; <br>        stripMesh.faces[facecount].norm = norm; <br>             <br>        NORMS(0, i).x += norm.x; <br>        NORMS(0, i).y += norm.y; <br>        NORMS(0, i).z += norm.z; <br>        NORMS(1, i).x += norm.x; <br>        NORMS(1, i).y += norm.y; <br>        NORMS(1, i).z += norm.z; <br> <br>        if (i != (iPrec - 1)) { <br>            NORMS(0, i+1).x += norm.x; <br>            NORMS(0, i+1).y += norm.y; <br>            NORMS(0, i+1).z += norm.z; <br>            NORMS(1, i+1).x += norm.x; <br>            NORMS(1, i+1).y += norm.y; <br>            NORMS(1, i+1).z += norm.z; <br>        } <br> <br>        stripMesh.faces[facecount].p[0] = i; <br>        stripMesh.faces[facecount].p[1] = iPrec + i; <br>        stripMesh.faces[facecount].p[2] = i + 1; <br>        stripMesh.faces[facecount].p[3] = iPrec + i + 1; <br>        stripMesh.numFaces++; <br>        facecount++; <br>    } <br> <br>    stripMesh.numPoints = 2 * iPrec; <br> <br>    ss_normalizeNorms(stripMesh.norms, stripMesh.numPoints); <br>} <br> <br>void initStripScene() <br>{ <br>    iPrec = (int)(fTesselFact * 40.5); <br>    if (iPrec &lt; 4) <br>        iPrec = 4; <br> <br>    newMesh(&amp;stripMesh, iPrec, 2 * iPrec); <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-1.1, 1.1, -1.1, 1.1, 0.0, 3.0); <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br>    glRotatef(50.0f, 1.0f, 0.0f, 0.0f); <br>    glRotatef(50.0f, 0.0f, 1.0f, 0.0f); <br>    glRotatef(12.0f, 0.0f, 0.0f, 1.0f); <br>    glMatrixMode(GL_MODELVIEW); <br>} <br> <br>void delStripScene() <br>{ <br>    delMesh(&amp;stripMesh); <br>} <br> <br>void updateStripScene(int flags) <br>{ <br>    static double mxrot = 0.0; <br>    static double myrot = 0.0; <br>    static double mzrot = 0.0; <br>    static double mxrotInc = 0.0; <br>    static double myrotInc = 0.1; <br>    static double mzrotInc = 0.0; <br>    static int h = 0; <br>    RGBA color; <br> <br>    if( gbBounce ) { <br>        // floating window bounced off an edge <br>        if (mxrotInc) { <br>            mxrotInc = 0.0; <br>            myrotInc = 0.1; <br>        } else if (myrotInc) { <br>            myrotInc = 0.0; <br>            mzrotInc = 0.1; <br>        } else if (mzrotInc) { <br>            mzrotInc = 0.0; <br>            mxrotInc = 0.1; <br>        } <br>        gbBounce = FALSE; <br>    } <br> <br>    glLoadIdentity(); <br>    glRotatef((GLfloat) (mxrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f); <br>    glRotatef((GLfloat) (myrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f); <br>    glRotatef((GLfloat) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f); <br>     <br>    genStrip(); <br> <br>    if (bColorCycle) { <br>        ss_HsvToRgb((float)h, 1.0f, 1.0f, &amp;color ); <br> <br>        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                     (GLfloat *) &amp;color); <br>     <br>        h++; <br>        h %= 360; <br>    } else { <br>        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,  <br>                     (GLfloat *) &amp;Material[1].kd); <br>    } <br> <br>    updateObject(&amp;stripMesh, bSmoothShading); <br> <br>    if (flags &amp; 0x4) { <br>        glLoadIdentity(); <br>        glTranslatef(0.05f, 0.0f, 0.0f); <br>        glRotatef((GLfloat) (myrot * (180.0 / PI)), 1.0f, 0.0f, 0.0f); <br>        glRotatef((GLfloat) (mxrot * (180.0 / PI)), 0.0f, 1.0f, 0.0f); <br>        glRotatef((GLfloat) (mzrot * (180.0 / PI)), 0.0f, 0.0f, 1.0f); <br> <br>        if (bColorCycle) { <br>            color.r = 1.0f - color.r; <br>            color.g = 1.0f - color.g; <br>            color.b = 1.0f - color.b; <br> <br>            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, <br>                         (GLfloat *) &amp;color); <br>        } else { <br>            glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE,  <br>                         (GLfloat *) &amp;Material[2].kd); <br>        } <br> <br>        updateObject(&amp;stripMesh, bSmoothShading); <br>    } <br> <br>    mxrot += mxrotInc; <br>    myrot += myrotInc; <br>    mzrot += mzrotInc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
