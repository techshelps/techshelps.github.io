<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XC.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3761"></a>XC.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: xc.cxx <br>* <br>* Cross-section (xc) object stuff <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;GL/gl.h&gt; <br>#include &lt;GL/glu.h&gt; <br>#include &lt;GL/glaux.h&gt; <br>#include &lt;float.h&gt; <br> <br>#include "sscommon.h" <br>#include "sspipes.h" <br>#include "eval.h" <br>#include "xc.h" <br> <br>/**************************************************************************\ <br>* XC::CalcArcACValues90 <br>* <br>* Calculate arc control points for a 90 degree rotation of an xc <br>* <br>* Arc is a quarter-circle <br>* - 90 degree is much easier, so we special case it <br>* - radius is distance from xc-origin to hinge of turn <br>* <br>\**************************************************************************/ <br> <br>void <br>XC::CalcArcACValues90( int dir, float radius, float *acPts ) <br>{ <br>    int i; <br>    float sign; <br>    int offset; <br>    float *ppts = (float *) pts; <br> <br>    // 1) calc 'r' values for each point (4 turn possibilities/point).  From <br>    //  this can determine ac, which is extrusion of point from xc face <br> <br>    switch( dir ) { <br>        case PLUS_X: <br>            offset = 0; <br>            sign = -1.0f; <br>            break; <br>        case MINUS_X: <br>            offset = 0; <br>            sign =  1.0f; <br>            break; <br>        case PLUS_Y: <br>            offset = 1; <br>            sign = -1.0f; <br>            break; <br>        case MINUS_Y: <br>            offset = 1; <br>            sign =  1.0f; <br>            break; <br>    } <br> <br>    for( i = 0; i &lt; numPts; i++, ppts+=2, acPts++ ) { <br>        *acPts = EVAL_CIRC_ARC_CONTROL * (radius + (sign * ppts[offset])); <br>    } <br>    // replicate ! <br>    *acPts = *(acPts - numPts); <br>} <br> <br>/**************************************************************************\ <br>* XC::CalcArcACValuesByDistance <br>* <br>* Use the distance of each xc point from the xc origin, as the radius for <br>* an arc control value. <br>* <br>\**************************************************************************/ <br> <br>void <br>XC::CalcArcACValuesByDistance( float *acPts ) <br>{ <br>    int i; <br>    float r; <br>    POINT2D *ppts =  pts; <br> <br>    for( i = 0; i &lt; numPts; i++, ppts++ ) { <br>        r = (float) sqrt( ppts-&gt;x*ppts-&gt;x + ppts-&gt;y*ppts-&gt;y ); <br>        *acPts++ = EVAL_CIRC_ARC_CONTROL * r; <br>    } <br>    // replicate ! <br>    *acPts = *(acPts - numPts); <br>} <br> <br>/**************************************************************************\ <br>* ELLIPTICAL_XC::SetControlPoints <br>* <br>* Set the 12 control points for a circle at origin in z=0 plane <br>* <br>* Points go CCW from +x <br>* <br>\**************************************************************************/ <br> <br>void  <br>ELLIPTICAL_XC::SetControlPoints( GLfloat r1, GLfloat r2 ) <br>{ <br>    GLfloat ac1, ac2;  <br> <br>    ac1 = EVAL_CIRC_ARC_CONTROL * r2; <br>    ac2 = EVAL_CIRC_ARC_CONTROL * r1; <br> <br>    // create 12-pt. set CCW from +x <br> <br>    // last 2 points of right triplet <br>    pts[0].x = r1; <br>    pts[0].y = 0.0f; <br>    pts[1].x = r1; <br>    pts[1].y = ac1; <br> <br>    // top triplet <br>    pts[2].x = ac2; <br>    pts[2].y = r2; <br>    pts[3].x = 0.0f; <br>    pts[3].y = r2; <br>    pts[4].x = -ac2; <br>    pts[4].y = r2; <br> <br>    // left triplet <br>    pts[5].x = -r1; <br>    pts[5].y = ac1; <br>    pts[6].x = -r1; <br>    pts[6].y = 0.0f; <br>    pts[7].x = -r1; <br>    pts[7].y = -ac1; <br> <br>    // bottom triplet <br>    pts[8].x = -ac2; <br>    pts[8].y = -r2; <br>    pts[9].x = 0.0f; <br>    pts[9].y = -r2; <br>    pts[10].x = ac2; <br>    pts[10].y = -r2; <br> <br>    // first point of first triplet <br>    pts[11].x = r1; <br>    pts[11].y = -ac1; <br>} <br> <br>/**************************************************************************\ <br>* RANDOM4ARC_XC::SetControlPoints <br>* <br>* Set random control points for xc <br>* Points go CCW from +x <br>* <br>\**************************************************************************/ <br> <br>void  <br>RANDOM4ARC_XC::SetControlPoints( float radius ) <br>{ <br>    int i; <br>    GLfloat r[4]; <br>    float rMin = 0.5f * radius; <br>    float distx, disty; <br> <br>    // figure the radius of each side first <br> <br>    for( i = 0; i &lt; 4; i ++ ) <br>        r[i] = ss_fRand( rMin, radius ); <br> <br>    // The 4 r's now describe a box around the origin - this restricts stuff <br> <br>    // Now need to select a point along each edge of the box as the joining <br>    // points for each arc (join points are at indices 0,3,6,9) <br> <br>    pts[0].x = r[RIGHT]; <br>    pts[3].y = r[TOP]; <br>    pts[6].x = -r[LEFT]; <br>    pts[9].y = -r[BOTTOM]; <br> <br>    // quarter of distance between edges <br>    disty = (r[TOP] - -r[BOTTOM]) / 4.0f; <br>    distx = (r[RIGHT] - -r[LEFT]) / 4.0f; <br>     <br>    // uh, put'em somwhere in the middle half of each side <br>    pts[0].y = ss_fRand( -r[BOTTOM] + disty, r[TOP] - disty ); <br>    pts[6].y = ss_fRand( -r[BOTTOM] + disty, r[TOP] - disty ); <br>    pts[3].x = ss_fRand( -r[LEFT] + distx, r[RIGHT] - distx ); <br>    pts[9].x = ss_fRand( -r[LEFT] + distx, r[RIGHT] - distx ); <br> <br>    // now can calc ac's <br>    // easy part first: <br>    pts[1].x = pts[11].x = pts[0].x; <br>    pts[2].y = pts[4].y = pts[3].y; <br>    pts[5].x = pts[7].x = pts[6].x; <br>    pts[8].y = pts[10].y = pts[9].y; <br> <br>    // right side ac's <br>    disty = (r[TOP] - pts[0].y) / 4.0f; <br>    pts[1].y = ss_fRand( pts[0].y + disty, r[TOP] ); <br>    disty = (pts[0].y - -r[BOTTOM]) / 4.0f; <br>    pts[11].y = ss_fRand( -r[BOTTOM], pts[0].y - disty ); <br> <br>    // left side ac's <br>    disty = (r[TOP] - pts[6].y) / 4.0f; <br>    pts[5].y = ss_fRand( pts[6].y + disty, r[TOP]); <br>    disty = (pts[6].y - -r[BOTTOM]) / 4.0f; <br>    pts[7].y = ss_fRand( -r[BOTTOM], pts[6].y - disty ); <br> <br>    // top ac's <br>    distx = (r[RIGHT] - pts[3].x) / 4.0f; <br>    pts[2].x = ss_fRand( pts[3].x + distx, r[RIGHT] ); <br>    distx = (pts[3].x - -r[LEFT]) / 4.0f; <br>    pts[4].x = ss_fRand( -r[LEFT],  pts[3].x - distx ); <br> <br>    // bottom ac's <br>    distx = (r[RIGHT] - pts[9].x) / 4.0f; <br>    pts[10].x = ss_fRand( pts[9].x + distx, r[RIGHT] ); <br>    distx = (pts[9].x - -r[LEFT]) / 4.0f; <br>    pts[8].x = ss_fRand( -r[LEFT], pts[9].x - distx ); <br>} <br> <br> <br>/**************************************************************************\ <br>* ConvertPtsZ <br>* <br>* Convert the 2D pts in an xc, to 3D pts in point buffer, with z. <br>* <br>* Also replicate the last point. <br>\**************************************************************************/ <br> <br>void <br>XC::ConvertPtsZ( POINT3D *newpts, float z ) <br>{ <br>    int i; <br>    POINT2D *xcPts = pts; <br> <br>    for( i = 0; i &lt; numPts; i++, newpts++ ) { <br>        *( (POINT2D *) newpts ) = *xcPts++; <br>        newpts-&gt;z = z; <br>    } <br>    *newpts = *(newpts - numPts); <br>} <br> <br>/**************************************************************************\ <br>* XC::CalcBoundingBox <br>*  <br>* Calculate bounding box in x/y plane for xc <br>\**************************************************************************/ <br> <br> <br>void  <br>XC::CalcBoundingBox( ) <br>{ <br>    POINT2D *ppts = pts; <br>    int i; <br>    float xMin, xMax, yMax, yMin; <br> <br>    // initialize to really insane numbers <br>    xMax = yMax = -FLT_MAX; <br>    xMin = yMin = FLT_MAX; <br> <br>    // compare with rest of points <br>    for( i = 0; i &lt; numPts; i ++, ppts++ ) { <br>        if( ppts-&gt;x &lt; xMin ) <br>            xMin = ppts-&gt;x; <br>        else if( ppts-&gt;x &gt; xMax ) <br>            xMax = ppts-&gt;x; <br>        if( ppts-&gt;y &lt; yMin ) <br>            yMin = ppts-&gt;y; <br>        else if( ppts-&gt;y &gt; yMax ) <br>            yMax = ppts-&gt;y; <br>    } <br>    xLeft = xMin; <br>    xRight = xMax; <br>    yBottom = yMin; <br>    yTop = yMax; <br>} <br> <br>/**************************************************************************\ <br>* <br>* MinTurnRadius <br>* <br>* Get minimum radius for the xc to turn in given direction.  <br>* <br>* If the turn radius is less than this minimum, then primitive will 'fold' <br>* over itself at the inside of the turn, creating ugliness. <br>* <br>\**************************************************************************/ <br> <br>float <br>XC::MinTurnRadius( int relDir ) <br>{ <br>// for now, assume xRight, yTop positive, xLeft, yBottom negative <br>// otherwise, might want to consider 'negative'radius <br>    switch( relDir ) { <br>        case PLUS_X: <br>            return( xRight ); <br>        case MINUS_X: <br>            return( - xLeft ); <br>        case PLUS_Y: <br>            return( yTop ); <br>        case MINUS_Y: <br>            return( - yBottom ); <br>        default: <br>            return(0.0f); <br>    } <br>} <br>/**************************************************************************\ <br>* <br>* XC::MaxExtent <br>* <br>* Get maximum extent of the xc in x and y <br>* <br>\**************************************************************************/ <br> <br>float <br>XC::MaxExtent( ) <br>{ <br>    float max; <br> <br>    max = xRight; <br> <br>    if( yTop &gt; max ) <br>        max = yTop; <br>    if( -xLeft &gt; max ) <br>        max = -xLeft; <br>    if( -yBottom &gt; max ) <br>        max = -yBottom; <br> <br>    return max; <br>} <br> <br>/**************************************************************************\ <br>*  <br>* XC::Scale <br>*  <br>* Scale an XC's points and extents by supplied scale value <br>* <br>\**************************************************************************/ <br> <br>void <br>XC::Scale( float scale ) <br>{ <br>    int i; <br>    POINT2D *ppts = pts; <br> <br>    for( i = 0; i &lt; numPts; i ++, ppts++ ) { <br>        ppts-&gt;x *= scale; <br>        ppts-&gt;y *= scale; <br>    } <br> <br>    xLeft *= scale; <br>    xRight *= scale; <br>    yBottom *= scale; <br>    yTop *= scale; <br>} <br> <br>/**************************************************************************\ <br>* ~XC::XC <br>* <br>* Destructor <br>* <br>\**************************************************************************/ <br> <br>XC::~XC() <br>{ <br>    if( pts ) <br>        LocalFree( pts ); <br>} <br> <br>/**************************************************************************\ <br>* XC::XC <br>* <br>* Constructor <br>* <br>* - Allocates point buffer for the xc <br>* <br>\**************************************************************************/ <br> <br>XC::XC( int nPts ) <br>{ <br>    numPts = nPts; <br>    pts = (POINT2D *)  LocalAlloc( LMEM_FIXED, numPts * sizeof(POINT2D) ); <br>    SS_ASSERT( pts != 0, "XC constructor\n" ); <br>} <br> <br> <br>XC::XC( XC *xc ) <br>{ <br>    numPts = xc-&gt;numPts; <br>    pts = (POINT2D *)  LocalAlloc( LMEM_FIXED, numPts * sizeof(POINT2D) ); <br>    SS_ASSERT( pts != 0, "XC constructor\n" ); <br>    RtlCopyMemory( pts, xc-&gt;pts, numPts * sizeof(POINT2D) ); <br> <br>    xLeft = xc-&gt;xLeft; <br>    xRight = xc-&gt;xRight; <br>    yBottom = xc-&gt;yBottom; <br>    yTop = xc-&gt;yTop; <br>} <br> <br>/**************************************************************************\ <br>* <br>* ELLIPTICAL_XC::ELLIPTICALXC <br>* <br>* Elliptical XC constructor <br> <br>* These have 4 sections of 4 pts each, with pts shared between sections. <br>* <br>\**************************************************************************/ <br> <br>ELLIPTICAL_XC::ELLIPTICAL_XC( float r1, float r2 ) <br>    // initialize base XC with numPts <br>    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1)) <br>{ <br>    SetControlPoints( r1, r2 ); <br>    CalcBoundingBox( ); <br>} <br> <br>/**************************************************************************\ <br>* <br>* RANDOM4ARC_XC::RANDOM4ARC_XC <br>* <br>* Random 4-arc XC constructor <br> <br>* The bounding box is 2*r each side <br>* These have 4 sections of 4 pts each, with pts shared between sections. <br>* <br>\**************************************************************************/ <br>RANDOM4ARC_XC::RANDOM4ARC_XC( float r ) <br>    // initialize base XC with numPts <br>    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1)) <br>{ <br>    SetControlPoints( r ); <br>    CalcBoundingBox( ); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
