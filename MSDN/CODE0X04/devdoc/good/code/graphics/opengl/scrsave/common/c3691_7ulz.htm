<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSIMAGE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3707"></a>SSIMAGE.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: ssimage.c <br>* <br>* Operations on .rgb files <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "sscommon.h" <br> <br>#define IMAGIC      0x01da <br>#define IMAGIC_SWAP 0xda01 <br> <br>#define SWAP_SHORT_BYTES(x) ((((x) &amp; 0xff) &lt;&lt; 8) | (((x) &amp; 0xff00) &gt;&gt; 8)) <br>#define SWAP_LONG_BYTES(x) (((((x) &amp; 0xff) &lt;&lt; 24) | (((x) &amp; 0xff00) &lt;&lt; 8)) | \ <br>                            ((((x) &amp; 0xff0000) &gt;&gt; 8) | (((x) &amp; 0xff000000) &gt;&gt; 24))) <br> <br>typedef struct _rawImageRec { <br>    unsigned short imagic; <br>    unsigned short type; <br>    unsigned short dim; <br>    unsigned short sizeX, sizeY, sizeZ; <br>    unsigned long min, max; <br>    unsigned long wasteBytes; <br>    char name[80]; <br>    unsigned long colorMap; <br>    HANDLE file; <br>    unsigned char *tmp, *tmpR, *tmpG, *tmpB; <br>    unsigned long rleEnd; <br>    unsigned long *rowStart; <br>    long *rowSize; <br>    // !!! Hack to stick in a pointer to the resource data - shouldn't be <br>    // a problem, since rgb files always have 512 byte header <br>    unsigned char *data; <br>} rawImageRec; <br> <br>static void RawImageClose(rawImageRec *raw); <br> <br>/**************************************************************************\ <br>* <br>* Hacked form of tk_RGBImageLoad(), for reading a .rgb file from a resource <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>static rawImageRec *RawImageOpen( PVOID pv ) <br>{ <br>    rawImageRec *raw; <br>    unsigned long *rowStart, *rowSize, ulTmp; <br>    int x; <br> <br>    raw = (rawImageRec *)malloc(sizeof(rawImageRec)); <br>    if (raw == NULL) { <br>        return 0; <br>    } <br> <br>    // Make a copy of the resource header, since we may be doing some byte <br>    // swapping, and resources are read-only <br>    *raw = *((rawImageRec *) pv); <br> <br>    if (raw-&gt;imagic == IMAGIC_SWAP) { <br>        raw-&gt;type = SWAP_SHORT_BYTES(raw-&gt;type); <br>        raw-&gt;dim = SWAP_SHORT_BYTES(raw-&gt;dim); <br>        raw-&gt;sizeX = SWAP_SHORT_BYTES(raw-&gt;sizeX); <br>        raw-&gt;sizeY = SWAP_SHORT_BYTES(raw-&gt;sizeY); <br>        raw-&gt;sizeZ = SWAP_SHORT_BYTES(raw-&gt;sizeZ); <br>    } <br> <br>    raw-&gt;tmp = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpR = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpG = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    raw-&gt;tmpB = (unsigned char *)malloc(raw-&gt;sizeX*256); <br>    if (raw-&gt;tmp == NULL || raw-&gt;tmpR == NULL || raw-&gt;tmpG == NULL || <br>        raw-&gt;tmpB == NULL) { <br>        RawImageClose(raw); <br>        return 0; <br>    } <br> <br>    if ((raw-&gt;type &amp; 0xFF00) == 0x0100) { <br>        x = raw-&gt;sizeY * raw-&gt;sizeZ * sizeof(long); <br>        raw-&gt;rowStart = (unsigned long *)malloc(x); <br>        raw-&gt;rowSize = (long *)malloc(x); <br>        if (raw-&gt;rowStart == NULL || raw-&gt;rowSize == NULL) { <br>            RawImageClose(raw); <br>            return 0; <br>        } <br>        raw-&gt;rleEnd = 512 + (2 * x); <br> <br>        raw-&gt;data = ((unsigned char *) pv); <br>        RtlCopyMemory( raw-&gt;rowStart, raw-&gt;data + 512, x ); <br>        RtlCopyMemory( raw-&gt;rowSize, raw-&gt;data + 512 + x, x ); <br> <br>        if (raw-&gt;imagic == IMAGIC_SWAP) { <br>            x /= sizeof(long); <br>            rowStart = raw-&gt;rowStart; <br>            rowSize = (unsigned long *) raw-&gt;rowSize; <br>            while (x--) { <br>                ulTmp = *rowStart; <br>                *rowStart++ = SWAP_LONG_BYTES(ulTmp); <br>                ulTmp = *rowSize; <br>                *rowSize++ = SWAP_LONG_BYTES(ulTmp); <br>            } <br>        } <br>    } <br>    return raw; <br>} <br> <br>static void RawImageClose(rawImageRec *raw) <br>{ <br>    if( !raw ) <br>        return; <br>    if( raw-&gt;tmp ) free(raw-&gt;tmp); <br>    if( raw-&gt;tmpR ) free(raw-&gt;tmpR); <br>    if( raw-&gt;tmpG ) free(raw-&gt;tmpG); <br>    if( raw-&gt;tmpB ) free(raw-&gt;tmpB); <br>    free(raw); <br>} <br> <br>static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z) <br>{ <br>    unsigned char *iPtr, *oPtr, pixel; <br>    int count; <br> <br>    if ((raw-&gt;type &amp; 0xFF00) == 0x0100) { <br>        RtlCopyMemory(raw-&gt;tmp, raw-&gt;data + raw-&gt;rowStart[y+z*raw-&gt;sizeY], <br>                 (unsigned int)raw-&gt;rowSize[y+z*raw-&gt;sizeY] ); <br>        iPtr = raw-&gt;tmp; <br>        oPtr = buf; <br>        while (1) { <br>            pixel = *iPtr++; <br>            count = (int)(pixel &amp; 0x7F); <br>            if (!count) { <br>                return; <br>            } <br>            if (pixel &amp; 0x80) { <br>                while (count--) { <br>                    *oPtr++ = *iPtr++; <br>                } <br>            } else { <br>                pixel = *iPtr++; <br>                while (count--) { <br>                    *oPtr++ = pixel; <br>                } <br>            } <br>        } <br>    } else { <br>        iPtr = raw-&gt;data + 512 + (y*raw-&gt;sizeX)+(z*raw-&gt;sizeX*raw-&gt;sizeY); <br>        RtlCopyMemory( buf, iPtr, raw-&gt;sizeX ); <br>    } <br>} <br> <br>static void RawImageGetData(rawImageRec *raw, TEXTURE *ptex) <br>{ <br>    unsigned char *ptr; <br>    int i, j; <br> <br>    ptex-&gt;data = (unsigned char *)malloc((raw-&gt;sizeX+1)*(raw-&gt;sizeY+1)*4); <br>    if (ptex-&gt;data == NULL) { <br>        return; <br>    } <br> <br>    ptr = ptex-&gt;data; <br>    for (i = 0; i &lt; raw-&gt;sizeY; i++) { <br>        RawImageGetRow(raw, raw-&gt;tmpR, i, 0); <br>        RawImageGetRow(raw, raw-&gt;tmpG, i, 1); <br>        RawImageGetRow(raw, raw-&gt;tmpB, i, 2); <br>        for (j = 0; j &lt; raw-&gt;sizeX; j++) { <br>            *ptr++ = *(raw-&gt;tmpR + j); <br>            *ptr++ = *(raw-&gt;tmpG + j); <br>            *ptr++ = *(raw-&gt;tmpB + j); <br>        } <br>    } <br>} <br> <br>BOOL ss_RGBImageLoad( PVOID pv, TEXTURE *ptex ) <br>{ <br>    rawImageRec *raw; <br> <br>    if( !(raw = RawImageOpen( pv )) ) <br>        return FALSE; <br>     <br>    ptex-&gt;width = raw-&gt;sizeX; <br>    ptex-&gt;height = raw-&gt;sizeY; <br>    ptex-&gt;format = GL_RGB; <br>    ptex-&gt;components = 3; <br>    ptex-&gt;pal_size = 0; <br>    ptex-&gt;pal = NULL; <br>    RawImageGetData(raw, ptex); <br>    RawImageClose(raw); <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bVerifyRGB <br>* <br>* Stripped down version of tkRGBImageLoadAW that verifies that an rgb <br>* file is valid and, if so, returns the bitmap dimensions. <br>* <br>* Returns: <br>*   TRUE if valid rgb file; otherwise, FALSE. <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>bVerifyRGB(LPTSTR pszFileName, ISIZE *pSize ) <br>{ <br>    rawImageRec *raw; <br>    DWORD dwBytesRead; <br>    BOOL bRet = FALSE; <br> <br>    raw = (rawImageRec *)  <br>          LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof(rawImageRec) ); <br> <br>    if (raw == NULL) { <br>        goto bVerifyRGB_cleanup; <br>    } <br> <br>    raw-&gt;file = CreateFile((LPTSTR) pszFileName, GENERIC_READ, FILE_SHARE_READ, <br>                            NULL, OPEN_EXISTING, 0, 0); <br> <br>    if (raw-&gt;file == INVALID_HANDLE_VALUE) { <br>        goto bVerifyRGB_cleanup; <br>    } <br> <br>    ReadFile(raw-&gt;file, (LPVOID) raw, 12, &amp;dwBytesRead, (LPOVERLAPPED) NULL); <br> <br>    if( raw-&gt;imagic == IMAGIC_SWAP ) { <br>        raw-&gt;sizeX = SWAP_SHORT_BYTES(raw-&gt;sizeX); <br>        raw-&gt;sizeY = SWAP_SHORT_BYTES(raw-&gt;sizeY); <br>        bRet = TRUE; <br>    } else if( raw-&gt;imagic == IMAGIC) <br>        bRet = TRUE; <br> <br>bVerifyRGB_cleanup: <br> <br>    if( bRet &amp;&amp; pSize ) { <br>        pSize-&gt;width = raw-&gt;sizeX; <br>        pSize-&gt;height = raw-&gt;sizeY; <br>    } <br>         <br>    if( raw-&gt;file ) <br>        CloseHandle( raw-&gt;file ); <br> <br>    if( raw ) <br>        LocalFree( raw ); <br> <br>    return bRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
