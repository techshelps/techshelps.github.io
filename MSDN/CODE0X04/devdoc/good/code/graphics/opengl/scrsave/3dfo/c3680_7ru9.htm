<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENEXPLD.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3681"></a>GENEXPLD.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: genexpld.c <br>* <br>* The Explode style of the 3D Flying Objects screen saver. <br>* <br>* Simulation of a sphere that occasionally explodes. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include "ss3dfo.h" <br> <br>#define RADIUS         0.3 <br>#define STEPS    30 <br>#define MAXPREC20 <br> <br>static MATRIX *faceMat; <br>static float *xstep; <br>static float *ystep; <br>static float *zstep; <br>static float *xrot; <br>static float *yrot; <br>static float *zrot; <br>static MESH explodeMesh; <br>static int iPrec = 10; <br> <br>static BOOL bOpenGL11; <br> <br>// Data type accepted by glInterleavedArrays <br>typedef struct _POINT_N3F_V3F { <br>    POINT3D normal; <br>    POINT3D vertex; <br>} POINT_N3F_V3F; <br> <br>static POINT_N3F_V3F *pN3V3; <br> <br>static GLfloat matl1Diffuse[] = {1.0f, 0.8f, 0.0f, 1.0f}; <br>static GLfloat matl2Diffuse[] = {0.8f, 0.8f, 0.8f, 1.0f}; <br>static GLfloat matlSpecular[] = {1.0f, 1.0f, 1.0f, 1.0f}; <br>static GLfloat light0Pos[] = {100.0f, 100.0f, 100.0f, 0.0f}; <br> <br>void genExplode() <br>{ <br>    int i; <br>    POINT3D circle[MAXPREC+1]; <br>    double angle; <br>    double step = -PI / (float)(iPrec - 1); <br>    double start = PI / 2.0; <br>     <br>    for (i = 0, angle = start; i &lt; iPrec; i++, angle += step) { <br>        circle[i].x = (float) (RADIUS * cos(angle)); <br>        circle[i].y = (float) (RADIUS * sin(angle)); <br>        circle[i].z = 0.0f; <br>    } <br> <br>    revolveSurface(&amp;explodeMesh, circle, iPrec); <br> <br>    for (i = 0; i &lt; explodeMesh.numFaces; i++) { <br>        ss_matrixIdent(&amp;faceMat[i]); <br>        xstep[i] = (float)(((float)(rand() &amp; 0x3) * PI) / ((float)STEPS + 1.0)); <br>        ystep[i] = (float)(((float)(rand() &amp; 0x3) * PI) / ((float)STEPS + 1.0)); <br>        zstep[i] = (float)(((float)(rand() &amp; 0x3) * PI) / ((float)STEPS + 1.0)); <br>        xrot[i] = 0.0f; <br>        yrot[i] = 0.0f; <br>        zrot[i] = 0.0f; <br>    } <br>} <br> <br>void initExplodeScene() <br>{ <br>    iPrec = (int)(fTesselFact * 10.5); <br>    if (iPrec &lt; 5) <br>        iPrec = 5; <br>    if (iPrec &gt; MAXPREC) <br>        iPrec = MAXPREC; <br> <br>    faceMat = (MATRIX *)SaverAlloc((iPrec * iPrec) *  <br>     (4 * 4 * sizeof(float))); <br>    xstep = SaverAlloc(iPrec * iPrec * sizeof(float)); <br>    ystep = SaverAlloc(iPrec * iPrec * sizeof(float)); <br>    zstep = SaverAlloc(iPrec * iPrec * sizeof(float)); <br>    xrot = SaverAlloc(iPrec * iPrec * sizeof(float)); <br>    yrot = SaverAlloc(iPrec * iPrec * sizeof(float)); <br>    zrot = SaverAlloc(iPrec * iPrec * sizeof(float)); <br>     <br>    genExplode(); <br> <br>    // Find out the OpenGL version that we are running on. <br>    bOpenGL11 = ss_fOnGL11(); <br> <br>    // Setup the data arrays. <br>    pN3V3 = SaverAlloc(explodeMesh.numFaces * 4 * sizeof(POINT_N3F_V3F)); <br> <br>    // If we are running on OpenGL 1.1, use the new vertex array functions. <br>    if (bOpenGL11) { <br>        glInterleavedArrays(GL_N3F_V3F, 0, pN3V3); <br>    } <br> <br>    glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, matl1Diffuse); <br>    glMaterialfv(GL_FRONT, GL_SPECULAR, matlSpecular); <br>    glMaterialf(GL_FRONT, GL_SHININESS, 100.0f); <br> <br>    glMaterialfv(GL_BACK, GL_AMBIENT_AND_DIFFUSE, matl2Diffuse); <br>    glMaterialfv(GL_BACK, GL_SPECULAR, matlSpecular); <br>    glMaterialf(GL_BACK, GL_SHININESS, 60.0f); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glFrustum(-0.33, 0.33, -0.33, 0.33, 0.3, 3.0); <br> <br>    glTranslatef(0.0f, 0.0f, -1.5f); <br>} <br> <br> <br>void delExplodeScene() <br>{ <br>    delMesh(&amp;explodeMesh); <br>     <br>    SaverFree(faceMat); <br>    SaverFree(xstep); <br>    SaverFree(ystep); <br>    SaverFree(zstep); <br>    SaverFree(xrot); <br>    SaverFree(yrot); <br>    SaverFree(zrot); <br>    SaverFree(pN3V3); <br>} <br> <br>void updateExplodeScene(int flags) <br>{ <br>    static double mxrot = 0.0; <br>    static double myrot = 0.0; <br>    static double mzrot = 0.0; <br>    static double mxrotInc = 0.0; <br>    static double myrotInc = 0.1; <br>    static double mzrotInc = 0.0; <br>    static float maxR; <br>    static float r = 0.0f; <br>    static float rotZ = 0.0f; <br>    static int count = 0; <br>    static int direction = 1; <br>    static int restCount = 0; <br>    static float lightSpin = 0.0f; <br>    static float spinDelta = 5.0f; <br>    static int h = 0; <br>    static RGBA color; <br>    int i; <br>    MFACE *faces; <br>    POINT_N3F_V3F *pn3v3; <br> <br> <br>    if( gbBounce ) { <br>        // floating window bounced off an edge <br>        if (mxrotInc) { <br>            mxrotInc = 0.0; <br>            myrotInc = 0.1; <br>        } else if (myrotInc) { <br>            myrotInc = 0.0; <br>            mzrotInc = 0.1; <br>        } else if (mzrotInc) { <br>            mzrotInc = 0.0; <br>            mxrotInc = 0.1; <br>        } <br>        gbBounce = FALSE; <br>    } <br> <br>    mxrot += mxrotInc; <br>    myrot += myrotInc; <br>    mzrot += mzrotInc; <br> <br>    if (bColorCycle || h == 0) { <br>        ss_HsvToRgb((float)h, 1.0f, 1.0f, &amp;color); <br> <br>        glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, (GLfloat *) &amp;color); <br> <br>        h++; <br>        h %= 360; <br>    } <br> <br>    glMatrixMode(GL_MODELVIEW); <br>    glPushMatrix(); <br>    glRotatef(-lightSpin, 0.0f, 1.0f, 0.0f); <br>    glLightfv(GL_LIGHT0, GL_POSITION, light0Pos); <br>    lightSpin += spinDelta; <br>    if ((lightSpin &gt; 90.0) || (lightSpin &lt; 0.0)) <br>        spinDelta = -spinDelta; <br>    glPopMatrix(); <br> <br>    if (!bOpenGL11) { <br>        glBegin(GL_QUADS); <br>    } <br> <br>    for( <br>        i = 0, faces = explodeMesh.faces, pn3v3 = pN3V3; <br>        i &lt; explodeMesh.numFaces; <br>i++, faces++, pn3v3 += 4 <br>       ) { <br>        int a, b, c, d; <br>        int j; <br>        POINT3D vector; <br>         <br>        ss_matrixIdent(&amp;faceMat[i]); <br>        ss_matrixRotate(&amp;faceMat[i], xrot[i], yrot[i], zrot[i]); <br> <br>        if (restCount) <br>            ; <br>        else { <br>            xrot[i] += (xstep[i]); <br>            yrot[i] += (ystep[i]); <br>            zrot[i] += (zstep[i]); <br>        }  <br> <br>        a = faces-&gt;p[0]; <br>        b = faces-&gt;p[1]; <br>        c = faces-&gt;p[3]; <br>        d = faces-&gt;p[2]; <br>         <br>        memcpy(&amp;pn3v3[0].vertex, (explodeMesh.pts + a), sizeof(POINT3D)); <br>        memcpy(&amp;pn3v3[1].vertex, (explodeMesh.pts + b), sizeof(POINT3D)); <br>        memcpy(&amp;pn3v3[2].vertex, (explodeMesh.pts + c), sizeof(POINT3D)); <br>        memcpy(&amp;pn3v3[3].vertex, (explodeMesh.pts + d), sizeof(POINT3D)); <br> <br>        vector.x = pn3v3[0].vertex.x; <br>        vector.y = pn3v3[0].vertex.y; <br>        vector.z = pn3v3[0].vertex.z; <br> <br>        for (j = 0; j &lt; 4; j++) { <br>            pn3v3[j].vertex.x -= vector.x; <br>            pn3v3[j].vertex.y -= vector.y; <br>            pn3v3[j].vertex.z -= vector.z; <br>            ss_xformPoint((POINT3D *)&amp;pn3v3[j].vertex, (POINT3D *)&amp;pn3v3[j].vertex, &amp;faceMat[i]); <br>            pn3v3[j].vertex.x += vector.x + (vector.x * r); <br>            pn3v3[j].vertex.y += vector.y + (vector.y * r); <br>            pn3v3[j].vertex.z += vector.z + (vector.z * r); <br>        } <br>        if (bSmoothShading) { <br>            memcpy(&amp;pn3v3[0].normal, (explodeMesh.norms + a), sizeof(POINT3D)); <br>            memcpy(&amp;pn3v3[1].normal, (explodeMesh.norms + b), sizeof(POINT3D)); <br>            memcpy(&amp;pn3v3[2].normal, (explodeMesh.norms + c), sizeof(POINT3D)); <br>            memcpy(&amp;pn3v3[3].normal, (explodeMesh.norms + d), sizeof(POINT3D)); <br>            <br>            for (j = 0; j &lt; 4; j++) <br>                ss_xformNorm((POINT3D *)&amp;pn3v3[j].normal, (POINT3D *)&amp;pn3v3[j].normal, &amp;faceMat[i]); <br>        } else {             <br>            memcpy(&amp;pn3v3[0].normal, &amp;faces-&gt;norm, sizeof(POINT3D)); <br>            ss_xformNorm((POINT3D *)&amp;pn3v3[0].normal, (POINT3D *)&amp;pn3v3[0].normal, &amp;faceMat[i]); <br>            memcpy(&amp;pn3v3[1].normal, &amp;pn3v3[0].normal, sizeof(POINT3D)); <br>            memcpy(&amp;pn3v3[2].normal, &amp;pn3v3[0].normal, sizeof(POINT3D)); <br>            memcpy(&amp;pn3v3[3].normal, &amp;pn3v3[0].normal, sizeof(POINT3D)); <br>        } <br> <br>        if (!bOpenGL11) { <br>            if (bSmoothShading) { <br>                glNormal3fv((GLfloat *)&amp;pn3v3[0].normal); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[0].vertex); <br>                glNormal3fv((GLfloat *)&amp;pn3v3[1].normal); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[1].vertex); <br>                glNormal3fv((GLfloat *)&amp;pn3v3[2].normal); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[2].vertex); <br>                glNormal3fv((GLfloat *)&amp;pn3v3[3].normal); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[3].vertex); <br>            } else { <br>                glNormal3fv((GLfloat *)&amp;pn3v3[0].normal); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[0].vertex); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[1].vertex); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[2].vertex); <br>                glVertex3fv((GLfloat *)&amp;pn3v3[3].vertex); <br>            } <br>        } <br>    } <br> <br>    if (bOpenGL11) { <br>        glDrawArrays(GL_QUADS, 0, explodeMesh.numFaces * 4); <br>    } else { <br>        glEnd(); <br>    } <br> <br>    if (restCount) { <br>        restCount--; <br>        goto resting; <br>    } <br> <br>    if (direction) { <br>        maxR = r; <br>        r += (float) (0.3 * pow((double)(STEPS - count) / (double)STEPS, 4.0)); <br>    } else { <br>        r -= (float) (maxR / (double)(STEPS)); <br>    } <br> <br>    count++; <br>    if (count &gt; STEPS) { <br>        direction ^= 1; <br>        count = 0; <br> <br>        if (direction == 1) { <br>            restCount = 10; <br>            r = 0.0f; <br> <br>            for (i = 0; i &lt; explodeMesh.numFaces; i++) { <br>                ss_matrixIdent(&amp;faceMat[i]); <br>                xstep[i] = (float) (((float)(rand() &amp; 0x3) * PI) / ((float)STEPS + 1.0)); <br>                ystep[i] = (float) (((float)(rand() &amp; 0x3) * PI) / ((float)STEPS + 1.0)); <br>                zstep[i] = (float) (((float)(rand() &amp; 0x3) * PI) / ((float)STEPS + 1.0)); <br>                 <br>                xrot[i] = 0.0f; <br>                yrot[i] = 0.0f; <br>                zrot[i] = 0.0f; <br>            } <br>        } <br>    } <br> <br>resting: <br>    ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
