<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSUTIL.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3709"></a>SSUTIL.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: ssutil.cxx <br>* <br>* Screen-saver utility functions <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;scrnsave.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;time.h&gt; <br>#include "ssintrnl.hxx" <br> <br>#include "ssutil.hxx" <br> <br>static OSVERSIONINFO gosvi = {0}; <br>static BOOL gbGLv1_1 = FALSE;  // GL version 1.1 boolean <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* SSU_ChoosePixelFormat <br>* <br>* Local implementation of ChoosePixelFormat <br>* <br>* Choose pixel format based on flags. <br>* This allows us a little a more control than just calling ChoosePixelFormat <br>\**************************************************************************/ <br> <br>static int <br>SSU_ChoosePixelFormat( HDC hdc, int flags ) <br>{ <br>    int MaxPFDs; <br>    int iBest = 0; <br>    PIXELFORMATDESCRIPTOR pfd; <br> <br>    // Always choose native pixel depth <br>    int cColorBits =  <br>                GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES); <br> <br>    BOOL bDoubleBuf = flags &amp; SS_DOUBLEBUF_BIT; <br> <br>    int cDepthBits = 0; <br>    if( SS_HAS_DEPTH16(flags) ) <br>        cDepthBits = 16; <br>    else if( SS_HAS_DEPTH32(flags) ) <br>        cDepthBits = 32; <br> <br>    int i = 1; <br>    do <br>    { <br>        MaxPFDs = DescribePixelFormat(hdc, i, sizeof(pfd), &amp;pfd); <br>        if ( MaxPFDs &lt;= 0 ) <br>            return 0; <br> <br>        if( ! (pfd.dwFlags &amp; PFD_SUPPORT_OPENGL) ) <br>            continue; <br> <br>        if( flags &amp; SS_BITMAP_BIT ) { <br>            // need bitmap pixel format <br>            if( ! (pfd.dwFlags &amp; PFD_DRAW_TO_BITMAP) ) <br>                continue; <br>        } else { <br>            // need window pixel format <br>            if( ! (pfd.dwFlags &amp; PFD_DRAW_TO_WINDOW) ) <br>                continue; <br>            // a window can be double buffered... <br>            if( ( bDoubleBuf &amp;&amp; !(pfd.dwFlags &amp; PFD_DOUBLEBUFFER) ) || <br>                ( !bDoubleBuf &amp;&amp; (pfd.dwFlags &amp; PFD_DOUBLEBUFFER) ) ) <br>                continue; <br>        } <br> <br>        if ( pfd.iPixelType != PFD_TYPE_RGBA ) <br>            continue; <br>        if( pfd.cColorBits != cColorBits ) <br>            continue; <br> <br>        if( (flags &amp; SS_GENERIC_UNACCELERATED_BIT) &amp;&amp; <br>            ((pfd.dwFlags &amp; (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED)) <br>    != PFD_GENERIC_FORMAT) ) <br>            continue; <br> <br>        if( (flags &amp; SS_NO_SYSTEM_PALETTE_BIT) &amp;&amp; <br>            (pfd.dwFlags &amp; PFD_NEED_SYSTEM_PALETTE) ) <br>            continue; <br> <br>        if( cDepthBits ) { <br>            if( pfd.cDepthBits &lt; cDepthBits ) <br>                continue; <br>        } else { <br>            // No depth buffer required, but use it if nothing better <br>            if( pfd.cDepthBits ) { <br>                iBest = i; <br>                continue; <br>            } <br>        } <br> <br>        // We have found something useful <br>        return i; <br> <br>    } while (++i &lt;= MaxPFDs); <br>     <br>    if( iBest ) <br>        // not an exact match, but good enough <br>        return iBest; <br> <br>    // If we reach here, we have failed to find a suitable pixel format. <br>    // See if the system can find us one. <br> <br>    memset( &amp;pfd, 0, sizeof( PIXELFORMATDESCRIPTOR ) ); <br>    pfd.nSize = sizeof( PIXELFORMATDESCRIPTOR ); <br>    pfd.cColorBits = cColorBits; <br>    pfd.cDepthBits = cDepthBits; <br>    pfd.iPixelType = PFD_TYPE_RGBA; <br>    pfd.dwFlags = PFD_SUPPORT_OPENGL; <br>    if( bDoubleBuf ) <br>        pfd.dwFlags |= PFD_DOUBLEBUFFER; <br>    if( flags &amp; SS_BITMAP_BIT ) <br>        pfd.dwFlags |= PFD_DRAW_TO_BITMAP; <br>    else <br>        pfd.dwFlags |= PFD_DRAW_TO_WINDOW; <br> <br>    if( (flags &amp; SS_GENERIC_UNACCELERATED_BIT) || <br>        (flags &amp; SS_NO_SYSTEM_PALETTE_BIT) ) <br>        // If either of these flags are set, we should be safe specifying a <br>        // 'slow' pixel format that supports bitmap drawing <br>        pfd.dwFlags |= PFD_DRAW_TO_BITMAP; <br>     <br>    SS_WARNING( "SSU_ChoosePixelFormat failed, calling ChoosePIxelFormat\n" ); <br> <br>    return ChoosePixelFormat( hdc, &amp;pfd ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SSU_SetupPixelFormat <br>* <br>* Choose pixel format according to supplied flags.  If ppfd is non-NULL, <br>* call DescribePixelFormat with it. <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>SSU_SetupPixelFormat(HDC hdc, int flags, PIXELFORMATDESCRIPTOR *ppfd ) <br>{ <br>    int pixelFormat; <br>    int nTryAgain = 4; <br> <br>    do{ <br>        if( (pixelFormat = SSU_ChoosePixelFormat(hdc, flags)) &amp;&amp; <br>            SetPixelFormat(hdc, pixelFormat, NULL) ) { <br>            SS_DBGLEVEL1( SS_LEVEL_INFO,  <br>               "SSU_SetupPixelFormat: Setting pixel format %d\n", pixelFormat ); <br>            if( ppfd ) <br>                DescribePixelFormat(hdc, pixelFormat,  <br>                                sizeof(PIXELFORMATDESCRIPTOR), ppfd); <br>            return TRUE; // Success <br>        } <br>        // Failed to set pixel format.  Try again after waiting a bit (win95 <br>        // bug with full screen dos box) <br>        Sleep( 1000 ); // Wait a second between attempts <br>    } while( nTryAgain-- ); <br> <br>    return FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* SSU_bNeedPalette <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>SSU_bNeedPalette( PIXELFORMATDESCRIPTOR *ppfd ) <br>{ <br>    if (ppfd-&gt;dwFlags &amp; PFD_NEED_PALETTE) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* SSU_PixelFormatDescriptorFromDc <br>* <br>\**************************************************************************/ <br> <br>int <br>SSU_PixelFormatDescriptorFromDc( HDC hdc, PIXELFORMATDESCRIPTOR *Pfd ) <br>{ <br>    int PfdIndex; <br> <br>    if ( 0 &lt; (PfdIndex = GetPixelFormat( hdc )) ) <br>    { <br>        if ( 0 &lt; DescribePixelFormat( hdc, PfdIndex, sizeof(*Pfd), Pfd ) ) <br>        { <br>            return(PfdIndex); <br>        } <br>    } <br>    return 0; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_ChangeDisplaySettings <br>* <br>* Try changing display settings. <br>* If bitDepth is 0, use current bit depth <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_ChangeDisplaySettings( int width, int height, int bitDepth ) <br>{ <br>    int change; <br>    DEVMODE dm = {0}; <br> <br>dm.dmSize       = sizeof(dm); <br>    dm.dmFields     = DM_PELSWIDTH | DM_PELSHEIGHT; <br>dm.dmPelsWidth  = width; <br>dm.dmPelsHeight = height; <br> <br>    if( bitDepth != 0 ) { <br>    dm.dmFields |= DM_BITSPERPEL; <br>    dm.dmBitsPerPel = bitDepth; <br>    } <br> <br>//    change = ChangeDisplaySettings(&amp;dm, CDS_TEST); <br>    change = ChangeDisplaySettings(&amp;dm, CDS_FULLSCREEN); <br> <br>    if( change == DISP_CHANGE_SUCCESSFUL ) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_QueryDisplaySettings <br>* <br>* Find out what diplay resolutions are available. <br>* <br>\**************************************************************************/ <br> <br>void  <br>ss_QueryDisplaySettings( void ) <br>{ <br>    int i = 0; <br>    DEVMODE devMode = {0}; <br> <br>    while( EnumDisplaySettings( NULL, i, &amp;devMode ) ) { <br>        i++; <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_QueryGLVersion <br>* <br>* Find out what GL version is being loaded.  If it's 1.1, set various <br>* global capabilities. <br>* <br>\**************************************************************************/ <br> <br>void  <br>ss_QueryGLVersion( void ) <br>{ <br>    // Get GL version <br> <br>    if( strstr( (char *) glGetString(GL_VERSION), "1.1") ) { <br>        gbGLv1_1 = TRUE; <br>        gbTextureObjects = TRUE; <br>    } else { <br>        gbGLv1_1 = FALSE; <br>        gbTextureObjects = FALSE; <br>    } <br>#ifdef SS_DEBUG <br>    if( !gbTextureObjects ) <br>        DbgPrint( "ss_QueryGLVersion: Texture Objects disabled\n" ); <br>#endif <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_fOnGL11 <br>* <br>* True if running on OpenGL v.1.1x <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>ss_fOnGL11( void ) <br>{ <br>    return gbGLv1_1; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_QueryOSVersion <br>* <br>* Query the OS version <br>* <br>\**************************************************************************/ <br> <br>void  <br>ss_QueryOSVersion( void ) <br>{ <br>    gosvi.dwOSVersionInfoSize = sizeof(gosvi); <br>    GetVersionEx(&amp;gosvi); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_fOnNT35 <br>* <br>* True if running on NT version 3.51 or less <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>ss_fOnNT35( void ) <br>{ <br>    static fOnNT35; <br>    static bInited = FALSE; <br> <br>    if( !bInited ) { <br>        if( !gosvi.dwOSVersionInfoSize )  <br>            ss_QueryOSVersion(); <br>        fOnNT35 =  <br>        (  <br>            (gosvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &amp;&amp;  <br>            (gosvi.dwMajorVersion == 3 &amp;&amp; gosvi.dwMinorVersion &lt;= 51) <br>        ); <br>        bInited = TRUE; <br>    } <br>    return fOnNT35; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_fOnWin95 <br>* <br>* True if running on Windows 95 <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>ss_fOnWin95( void ) <br>{ <br>    static fOnWin95; <br>    static bInited = FALSE; <br> <br>    if( !bInited ) { <br>        if( !gosvi.dwOSVersionInfoSize )  <br>            ss_QueryOSVersion(); <br>        fOnWin95 = ( gosvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ); <br>        bInited = TRUE; <br>    } <br>    return fOnWin95; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_fPreviewMode <br>* <br>* True if running in Display setting's child preview window <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>ss_fPreviewMode( void ) <br>{ <br>    return gpss-&gt;type == SS_TYPE_PREVIEW; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_fFullScreenMode <br>* <br>* True if running full screen (/s option) <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>ss_fFullScreenMode( void ) <br>{ <br>    return gpss-&gt;type == SS_TYPE_FULLSCREEN; <br>} <br> <br>BOOL  <br>ss_fConfigMode( void ) <br>{ <br>    return gpss-&gt;type == SS_TYPE_CONFIG; <br>} <br> <br>BOOL  <br>ss_fWindowMode( void ) <br>{ <br>    return gpss-&gt;type == SS_TYPE_NORMAL; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* ss_RedrawDesktop <br>* <br>* Causes the entire desktop to be redrawn <br>* <br>\**************************************************************************/ <br> <br>BOOL  <br>ss_RedrawDesktop( void ) <br>{ <br>    return RedrawWindow( NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE |  <br>                            RDW_ERASENOW | RDW_UPDATENOW | RDW_ALLCHILDREN ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
