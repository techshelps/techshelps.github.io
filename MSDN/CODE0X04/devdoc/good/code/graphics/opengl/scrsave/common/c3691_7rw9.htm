<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MATH.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3699"></a>MATH.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: math.c <br>* <br>* Misc. useful math utility functions. <br>* <br>* Copyright (c) 1994 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;GL\gl.h&gt; <br>#include &lt;math.h&gt; <br>#include "sscommon.h" <br> <br>#define ZERO_EPS    0.00000001 <br> <br>POINT3D ss_ptZero = {0.0f, 0.0f, 0.0f}; <br> <br> <br>void ss_xformPoint(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat) <br>{ <br>    double x, y, z; <br> <br>    x = (ptIn-&gt;x * mat-&gt;M[0][0]) + (ptIn-&gt;y * mat-&gt;M[0][1]) + <br>        (ptIn-&gt;z * mat-&gt;M[0][2]) + mat-&gt;M[0][3]; <br> <br>    y = (ptIn-&gt;x * mat-&gt;M[1][0]) + (ptIn-&gt;y * mat-&gt;M[1][1]) + <br>        (ptIn-&gt;z * mat-&gt;M[1][2]) + mat-&gt;M[1][3]; <br> <br>    z = (ptIn-&gt;x * mat-&gt;M[2][0]) + (ptIn-&gt;y * mat-&gt;M[2][1]) + <br>        (ptIn-&gt;z * mat-&gt;M[2][2]) + mat-&gt;M[2][3]; <br> <br>    ptOut-&gt;x = (float) x; <br>    ptOut-&gt;y = (float) y; <br>    ptOut-&gt;z = (float) z; <br>} <br> <br>void ss_xformNorm(POINT3D *ptOut, POINT3D *ptIn, MATRIX *mat) <br>{ <br>    double x, y, z; <br>    double len; <br> <br>    x = (ptIn-&gt;x * mat-&gt;M[0][0]) + (ptIn-&gt;y * mat-&gt;M[0][1]) + <br>        (ptIn-&gt;z * mat-&gt;M[0][2]); <br> <br>    y = (ptIn-&gt;x * mat-&gt;M[1][0]) + (ptIn-&gt;y * mat-&gt;M[1][1]) + <br>        (ptIn-&gt;z * mat-&gt;M[1][2]); <br> <br>    z = (ptIn-&gt;x * mat-&gt;M[2][0]) + (ptIn-&gt;y * mat-&gt;M[2][1]) + <br>        (ptIn-&gt;z * mat-&gt;M[2][2]); <br> <br>    len = (x * x) + (y * y) + (z * z); <br>    if (len &gt;= ZERO_EPS) <br>        len = 1.0 / sqrt(len); <br>    else <br>        len = 1.0; <br> <br>    ptOut-&gt;x = (float) (x * len); <br>    ptOut-&gt;y = (float) (y * len); <br>    ptOut-&gt;z = (float) (z * len); <br>    return; <br>} <br> <br>void ss_matrixIdent(MATRIX *mat) <br>{ <br>    mat-&gt;M[0][0] = 1.0f; mat-&gt;M[0][1] = 0.0f; <br>    mat-&gt;M[0][2] = 0.0f; mat-&gt;M[0][3] = 0.0f; <br> <br>    mat-&gt;M[1][0] = 0.0f; mat-&gt;M[1][1] = 1.0f; <br>    mat-&gt;M[1][2] = 0.0f; mat-&gt;M[1][3] = 0.0f; <br> <br>    mat-&gt;M[2][0] = 0.0f; mat-&gt;M[2][1] = 0.0f; <br>    mat-&gt;M[2][2] = 1.0f; mat-&gt;M[2][3] = 0.0f; <br> <br>    mat-&gt;M[3][0] = 0.0f; mat-&gt;M[3][1] = 0.0f; <br>    mat-&gt;M[3][2] = 0.0f; mat-&gt;M[3][3] = 1.0f; <br>} <br> <br>void ss_matrixRotate(MATRIX *m, double xTheta, double yTheta, double zTheta) <br>{ <br>    float xScale, yScale, zScale; <br>    float sinX, cosX; <br>    float sinY, cosY; <br>    float sinZ, cosZ; <br> <br>    xScale = m-&gt;M[0][0]; <br>    yScale = m-&gt;M[1][1]; <br>    zScale = m-&gt;M[2][2]; <br>    sinX = (float) sin(xTheta); <br>    cosX = (float) cos(xTheta); <br>    sinY = (float) sin(yTheta); <br>    cosY = (float) cos(yTheta); <br>    sinZ = (float) sin(zTheta); <br>    cosZ = (float) cos(zTheta); <br> <br>    m-&gt;M[0][0] = (float) ((cosZ * cosY) * xScale); <br>    m-&gt;M[0][1] = (float) ((cosZ * -sinY * -sinX + sinZ * cosX) * yScale); <br>    m-&gt;M[0][2] = (float) ((cosZ * -sinY * cosX + sinZ * sinX) * zScale); <br> <br>    m-&gt;M[1][0] = (float) (-sinZ * cosY * xScale); <br>    m-&gt;M[1][1] = (float) ((-sinZ * -sinY * -sinX + cosZ * cosX) * yScale); <br>    m-&gt;M[1][2] = (float) ((-sinZ * -sinY * cosX + cosZ * sinX) * zScale); <br> <br>    m-&gt;M[2][0] = (float) (sinY * xScale); <br>    m-&gt;M[2][1] = (float) (cosY * -sinX * yScale); <br>    m-&gt;M[2][2] = (float) (cosY * cosX * zScale); <br>} <br> <br>void ss_matrixTranslate(MATRIX *m, double xTrans, double yTrans, <br>                     double zTrans) <br>{ <br>    m-&gt;M[0][3] = (float) xTrans; <br>    m-&gt;M[1][3] = (float) yTrans; <br>    m-&gt;M[2][3] = (float) zTrans; <br>} <br> <br> <br>void ss_matrixMult( MATRIX *m1, MATRIX *m2, MATRIX *m3 ) <br>{ <br>    int i, j; <br> <br>    for( j = 0; j &lt; 4; j ++ ) { <br>    for( i = 0; i &lt; 4; i ++ ) { <br>    m1-&gt;M[j][i] = m2-&gt;M[j][0] * m3-&gt;M[0][i] + <br>  m2-&gt;M[j][1] * m3-&gt;M[1][i] + <br>  m2-&gt;M[j][2] * m3-&gt;M[2][i] + <br>  m2-&gt;M[j][3] * m3-&gt;M[3][i]; <br>} <br>    } <br>} <br> <br>void ss_calcNorm(POINT3D *norm, POINT3D *p1, POINT3D *p2, POINT3D *p3) <br>{ <br>    float crossX, crossY, crossZ; <br>    float abX, abY, abZ; <br>    float acX, acY, acZ; <br>    float sqrLength; <br>    float invLength; <br> <br>    abX = p2-&gt;x - p1-&gt;x;       // calculate p2 - p1 <br>    abY = p2-&gt;y - p1-&gt;y; <br>    abZ = p2-&gt;z - p1-&gt;z; <br> <br>    acX = p3-&gt;x - p1-&gt;x;       // calculate p3 - p1 <br>    acY = p3-&gt;y - p1-&gt;y; <br>    acZ = p3-&gt;z - p1-&gt;z; <br> <br>    crossX = (abY * acZ) - (abZ * acY);    // get cross product <br>    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1) <br>    crossZ = (abX * acY) - (abY * acX); <br> <br>    sqrLength = (crossX * crossX) + (crossY * crossY) + <br>                 (crossZ * crossZ); <br> <br>    if (sqrLength &gt; ZERO_EPS) <br>        invLength = (float) (1.0 / sqrt(sqrLength)); <br>    else <br>        invLength = 1.0f; <br> <br>    norm-&gt;x = crossX * invLength; <br>    norm-&gt;y = crossY * invLength; <br>    norm-&gt;z = crossZ * invLength; <br>} <br> <br> <br>void ss_normalizeNorm( POINT3D *n )  <br>{ <br>    float len; <br> <br>    len = (n-&gt;x * n-&gt;x) + (n-&gt;y * n-&gt;y) + (n-&gt;z * n-&gt;z); <br>    if (len &gt; ZERO_EPS) <br>        len = (float) (1.0 / sqrt(len)); <br>    else <br>        len = 1.0f; <br> <br>    n-&gt;x *= len; <br>    n-&gt;y *= len; <br>    n-&gt;z *= len; <br>} <br> <br>void ss_normalizeNorms(POINT3D *p, ULONG cPts) <br>{ <br>    float len; <br>    ULONG i; <br> <br>    for (i = 0; i &lt; cPts; i++, p++) { <br>        len = (p-&gt;x * p-&gt;x) + (p-&gt;y * p-&gt;y) + (p-&gt;z * p-&gt;z); <br>        if (len &gt; ZERO_EPS) <br>            len = (float) (1.0 / sqrt(len)); <br>        else <br>            len = 1.0f; <br> <br>        p-&gt;x *= len; <br>        p-&gt;y *= len; <br>        p-&gt;z *= len; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
