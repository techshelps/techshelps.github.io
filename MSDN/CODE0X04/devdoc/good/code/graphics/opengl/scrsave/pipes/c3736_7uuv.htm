<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATE.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3757"></a>STATE.CXX</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: state.cxx <br>* <br>* STATE <br>* <br>* Copyright 1995 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;sys/types.h&gt; <br>#include &lt;sys/timeb.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;windows.h&gt; <br> <br>#include "sspipes.h" <br>#include "dialog.h" <br>#include "state.h" <br>#include "pipe.h" <br>#include "npipe.h" <br>#include "fpipe.h" <br>#include "eval.h" <br> <br>// default texture resource(s) <br> <br>#define DEF_TEX_COUNT 1 <br>TEX_RES gTexRes[DEF_TEX_COUNT] = {  <br>    { TEX_BMP, IDB_DEFTEX } <br>}; <br> <br>static void InitTexParams(); <br> <br>/******************************Public*Routine******************************\ <br>* STATE constructor <br>* <br>* - global state init <br>* - translates variables set from the dialog boxes <br>* <br>\**************************************************************************/ <br> <br>STATE::STATE( BOOL bFlexMode, BOOL bMultiPipes ) <br>{ <br>    // various state values <br>    resetStatus = RESET_STARTUP_BIT; <br> <br>    // Put initial hglrc in drawThreads[0] <br>    // This RC is also used for dlists and texture objects that are shared <br>    // by other RC's <br> <br>    shareRC = wglGetCurrentContext(); <br>    drawThreads[0].SetRCDC( shareRC, wglGetCurrentDC() ); <br> <br>    bTexture = FALSE; <br>    if( ulSurfStyle == SURFSTYLE_TEX ) { <br>        if( LoadTextureFiles( gTexFile, gnTextures, &amp;gTexRes[0] ) ) <br>            bTexture = TRUE; <br>    } <br>    else if( ulSurfStyle == SURFSTYLE_WIREFRAME ) { <br>        glPolygonMode( GL_FRONT_AND_BACK, GL_LINE ); <br>    } <br>    <br>    // Initialize GL state for the initial RC (sets texture state, so <br>    // (must come after LoadTextureFiles()) <br> <br>    GLInit(); <br> <br>    // set 'reference' radius value <br> <br>    radius = 1.0f; <br> <br>    // convert tesselation from fTesselFact(0.0-2.0) to tessLevel(0-MAX_TESS) <br> <br>    int tessLevel = (int) (fTesselFact * (MAX_TESS+1) / 2.0001f); <br>    nSlices = (tessLevel+2) * 4; <br> <br>    // Allocate basic NODE_ARRAY <br>    // NODE_ARRAY size is determined in Reshape (based on window size) <br>    nodes = new NODE_ARRAY; <br> <br>    // Set drawing mode, and initialize accordingly.  For now, either all normal <br>    // or all flex pipes are drawn, but they could be combined later. <br>    // Can assume here that if there's any possibility that normal pipes <br>    // will be drawn, NORMAL_STATE will be initialized so that dlists are <br>    // built <br>     <br>    // Again, since have either NORMAL or FLEX, set maxPipesPerFrame, <br>    // maxDrawThreads <br>    if( bMultiPipes ) <br>        maxDrawThreads = MAX_DRAW_THREADS; <br>    else <br>        maxDrawThreads = 1; <br>    nDrawThreads = 0; // no active threads yet <br>    nPipesDrawn = 0; <br>    // maxPipesPerFrame is set in Reset() <br> <br>    if( bFlexMode ) { <br>        drawMode = DRAW_FLEX; <br>        pFState = new FLEX_STATE( this ); <br>        pNState = NULL; <br>    } else { <br>        drawMode = DRAW_NORMAL; <br>        pNState = new NORMAL_STATE( this ); <br>        pFState = NULL; <br>    } <br> <br>    // initialize materials <br> <br>    if( bTexture ) <br>        ss_InitTexMaterials(); <br>    else <br>        ss_InitTeaMaterials(); <br> <br>    // default draw scheme <br>    drawScheme = FRAME_SCHEME_RANDOM; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* STATE destructor <br>* <br>\**************************************************************************/ <br> <br>STATE::~STATE( ) <br>{ <br>    if( pNState ) <br>        delete pNState; <br>    if( pFState ) <br>        delete pFState; <br>    if( nodes ) <br>        delete nodes; <br>    if( bTexture ) { <br>        for( int i = 0; i &lt; nTextures; i ++ ) { <br>            ss_DeleteTexture( &amp;texture[i] ); <br>        } <br>    } <br> <br>    // Delete any RC's - should be done by ~THREAD, but since common lib <br>    // deletes shareRC, have to do it here <br> <br>    DRAW_THREAD *pdt = &amp;drawThreads[0]; <br>    for( int i = 0; i &lt; MAX_DRAW_THREADS; i ++, pdt++ ) { <br>        if( pdt-&gt;hglrc &amp;&amp; (pdt-&gt;hglrc != shareRC) ) { <br>            wglDeleteContext( pdt-&gt;hglrc ); <br>        } <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* CalcTexRepFactors  <br>* <br>\**************************************************************************/ <br> <br>void <br>STATE::CalcTexRepFactors() <br>{ <br>    ISIZE winSize; <br>    POINT2D texFact; <br> <br>    ss_GetScreenSize( &amp;winSize ); <br> <br>    // Figure out repetition factor of texture, based on bitmap size and <br>    // screen size. <br>    // <br>    // We arbitrarily decide to repeat textures that are smaller than <br>    // 1/8th of screen width or height. <br> <br>    for( int i = 0; i &lt; nTextures; i++ ) { <br>        texRep[i].x = texRep[i].y = 1; <br> <br>        if( (texFact.x = winSize.width / texture[i].width / 8.0f) &gt;= 1.0f) <br>            texRep[i].x = (int) (texFact.x+0.5f); <br> <br>        if( (texFact.y = winSize.height / texture[i].height / 8.0f) &gt;= 1.0f) <br>            texRep[i].y = (int) (texFact.y+0.5f); <br>    } <br>     <br>    // ! If display list based normal pipes, texture repetition is embedded <br>    // in the dlists and can't be changed. So use the smallest rep factors. <br>     <br>    if( pNState ) { <br>        //put smallest rep factors in texRep[0]; (mf:this is ok for now, as <br>        // flex pipes and normal pipes don't coexist) <br>     <br>        for( i = 1; i &lt; nTextures; i++ ) { <br>            if( texRep[i].x &lt; texRep[0].x ) <br>                texRep[0].x = texRep[i].x; <br>            if( texRep[i].y &lt; texRep[0].y ) <br>                texRep[0].y = texRep[i].y; <br>        } <br>    }  <br>} <br> <br>/******************************Public*Routine******************************\ <br>* LoadTextureFiles <br>* <br>* - Load user texture files.  If texturing on but no user textures, or <br>*   problems loading them, load default texture resource <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>STATE::LoadTextureFiles( TEXFILE *pTexFile, int nTexFiles, TEX_RES *pTexRes ) <br>{ <br>    // Set pixel store state <br> <br>    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br> <br>    // Try to load the bmp or rgb file <br> <br>    // i counts successfully loaded textures <br>    for( int i = 0; nTexFiles; nTexFiles-- ) { <br>        if( ss_LoadTextureFile( &amp;pTexFile[i], &amp;texture[i] ) )  { <br>            // If texture object extension, set tex params here for each object <br>            if( ss_TextureObjectsEnabled() ) <br>                InitTexParams(); <br>            i++; // count another valid texture <br>        } <br>    } <br> <br>    // set number of valid textures in state <br>    nTextures = i; <br> <br>    if( nTextures == 0 ) { <br>        // No user textures, or none loaded successfully <br>        // Load default resource texture(s) <br>        nTextures = DEF_TEX_COUNT; <br>        for( i = 0; i &lt; nTextures; i++, pTexRes++ ) { <br>            if( !ss_LoadTextureResource( pTexRes, &amp;texture[i] ) ) { <br>                // shouldn't happen <br>                return FALSE; <br>            } <br>        } <br>    } <br> <br>    CalcTexRepFactors(); <br> <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* GLInit <br>* <br>* - Sets up GL state <br>* - Called once for every context (rc) <br>* <br>\**************************************************************************/ <br> <br>void  <br>STATE::GLInit() <br>{ <br>    static float ambient[] = {0.1f, 0.1f, 0.1f, 1.0f}; <br>    static float diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f}; <br>    static float position[] = {90.0f, 90.0f, 150.0f, 0.0f}; <br>    static float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f}; <br>    static float lmodel_ambientTex[] = {0.6f, 0.6f, 0.6f, 0.0f}; <br>    static float back_mat_diffuse[] = {0.0f, 0.0f, 1.0f}; <br> <br>    glClearColor(0.0f, 0.0f, 0.0f, 0.0f); <br> <br>    glFrontFace(GL_CCW); <br> <br>    glDepthFunc(GL_LEQUAL); <br>    glEnable(GL_DEPTH_TEST); <br> <br>    glEnable( GL_AUTO_NORMAL ); // needed for GL_MAP2_VERTEX (tea) <br> <br>    if( bTexture ) <br>        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambientTex); <br>    else <br>        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient); <br> <br>    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient); <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse); <br>    glLightfv(GL_LIGHT0, GL_POSITION, position); <br>    glEnable(GL_LIGHT0); <br>    glEnable(GL_LIGHTING); <br> <br>    glCullFace(GL_BACK); <br>    glEnable(GL_CULL_FACE); <br>     <br>    // Set texture modes <br>    if( bTexture ) { <br>        glEnable(GL_TEXTURE_2D); <br>        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE); <br>        InitTexParams(); <br>    } <br>} <br> <br>/**************************************************************************\ <br>* InitTexParams <br>* <br>* Set texture parameters, globally, or per object if texture object extension <br>* <br>\**************************************************************************/ <br> <br>static void <br>InitTexParams() <br>{ <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); <br> <br>    switch( ulTexQuality ) { <br>       case TEXQUAL_HIGH: <br>          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); <br>          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); <br>            break; <br>       case TEXQUAL_DEFAULT: <br>       default: <br>          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); <br>          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <br>            break; <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* Repaint <br>* <br>* This is called when a WM_PAINT msg has been sent to the window.   The paint <br>* will overwrite the frame buffer, screwing up the scene if pipes is in single <br>* buffer mode.  We set resetStatus accordingly to clear things up on next <br>* draw.  <br>* <br>\**************************************************************************/ <br> <br>void <br>STATE::Repaint( LPRECT pRect, void *data) <br>{ <br>    resetStatus |= RESET_REPAINT_BIT; <br>} <br> <br>/**************************************************************************\ <br>* Reshape <br>*   - called on resize, expose <br>*   - always called on app startup <br>*   - set new window size for VIEW object, and set resetStatus for validation <br>*     at draw time <br>* <br>\**************************************************************************/ <br> <br>void <br>STATE::Reshape(int width, int height, void *data) <br>{ <br>    if( view.SetWinSize( width, height ) ) <br>        resetStatus |= RESET_RESIZE_BIT; <br>} <br> <br>/**************************************************************************\ <br>* ResetView <br>* <br>* Called on FrameReset resulting from change in viewing paramters (e.g. from <br>* a Resize event). <br>\**************************************************************************/ <br> <br>void <br>STATE::ResetView() <br>{ <br>    IPOINT3D numNodes; <br> <br>    // Have VIEW calculate the node array size based on view params <br>    view.CalcNodeArraySize( &amp;numNodes ); <br> <br>    // Resize the node array <br>    nodes-&gt;Resize( &amp;numNodes ); <br> <br>    // Set GL viewing parameters for each active RC <br> <br>    DRAW_THREAD *pThread = drawThreads; <br> <br>    for( int i = 0; i &lt; MAX_DRAW_THREADS; i ++, pThread++ ) { <br>        if( pThread-&gt;HasRC() ) { <br>            pThread-&gt;MakeRCCurrent(); <br>            view.SetGLView(); <br>        } <br>    } <br>} <br> <br>/**************************************************************************\ <br>* FrameReset <br>* <br>* Start a new frame of pipes <br>* <br>* The resetStatus parameter indicates what triggered the Reset. <br>* <br>\**************************************************************************/ <br> <br>static int PickRandomTexture( int i, int nTextures ); <br> <br>void  <br>STATE::FrameReset() <br>{     <br>    int i; <br>    float xRot, zRot; <br>    PIPE *pNewPipe; <br> <br>#ifdef DO_TIMING <br>    Timer( TIMER_STOP ); <br>#endif <br> <br>    SS_DBGINFO( "Pipes STATE::FrameReset:\n" ); <br> <br>    // Kill off any active pipes ! (so they can shut down ok) <br> <br>    DRAW_THREAD *pThread = drawThreads; <br>    for( i = 0; i &lt; nDrawThreads; i ++, pThread++ ) { <br>        pThread-&gt;KillPipe(); <br>    } <br>    nDrawThreads = 0; <br>     <br>    // Clear the screen <br>    Clear(); <br> <br>    // Check for window resize status <br>    if( resetStatus &amp; RESET_RESIZE_BIT ) { <br>        ResetView(); <br>    } <br> <br>    // Reset the node states to empty <br>    nodes-&gt;Reset(); <br> <br>    // Call any pipe-specific state resets, and get any recommended <br>    // pipesPerFrame counts <br> <br>    if( pNState ) { <br>        pNState-&gt;Reset(); <br>    } <br>    if( pFState ) { <br>        pFState-&gt;Reset(); <br>        xRot = ss_fRand(-5.0f, 5.0f); <br>        zRot = ss_fRand(-5.0f, 5.0f); <br>    } <br>    maxPipesPerFrame = CalcMaxPipesPerFrame(); <br> <br>    // Set new number of drawing threads <br> <br>    if( maxDrawThreads &gt; 1 ) { <br>        // Set maximum # of pipes per frame <br>        maxPipesPerFrame = (int) (maxPipesPerFrame * 1.5); <br> <br>        // Set # of draw threads <br>        nDrawThreads = SS_MIN( maxPipesPerFrame, ss_iRand2( 2, maxDrawThreads ) ); <br>        // Set chase mode if applicable, every now and then <br>        BOOL bUseChase = pNState || (pFState &amp;&amp; pFState-&gt;OKToUseChase()); <br>        if( bUseChase &amp;&amp; (!ss_iRand(5)) ) { <br>            drawScheme = FRAME_SCHEME_CHASE; <br>        } <br>    } else { <br>        nDrawThreads = 1; <br>    } <br>    nPipesDrawn = 0; <br> <br>    // for now, either all NORMAL or all FLEX for each frame <br> <br>    pThread = drawThreads; <br> <br>    for( i = 0; i &lt; nDrawThreads; i ++, pThread++ ) { <br> <br>        // Create hglrc if necessary, and init it <br> <br>        if( !pThread-&gt;HasRC() ) { <br>            HDC hdc = wglGetCurrentDC(); <br>            pThread-&gt;SetRCDC( wglCreateContext( hdc ), hdc ); <br>            // also need to init each RC <br>            pThread-&gt;MakeRCCurrent(); <br>            // Do GL Init for this new RC <br>            GLInit(); <br> <br>            // Set viewing params <br>            view.SetGLView(); <br>             <br>            // Give this rc access to any dlists <br>            wglShareLists( shareRC, pThread-&gt;GetRC() ); <br>        } <br>        else <br>            pThread-&gt;MakeRCCurrent(); <br>         <br>        // Set up the modeling view <br> <br>        glLoadIdentity(); <br>        glTranslatef(0.0f, 0.0f, view.zTrans); <br> <br>        // Rotate Scene <br>        glRotatef( view.yRot, 0.0f, 1.0f, 0.0f ); <br> <br>        // create approppriate pipe for this thread slot <br> <br>        switch( drawMode ) { <br>            case DRAW_NORMAL: <br>                pNewPipe = (PIPE *) new NORMAL_PIPE(this); <br>                break; <br>            case DRAW_FLEX: <br>                // There are several kinds of FLEX pipes - have FLEX_STATE <br>                // decide which one to create <br>                pNewPipe = pFState-&gt;NewPipe( this ); <br>                // rotate a bit around x and z as well <br>                // If combining NORMAL and FLEX, same rotations must be  <br>                // applied to both <br>                glRotatef( xRot, 1.0f, 0.0f, 0.0f ); <br>                glRotatef( zRot, 0.0f, 0.0f, 1.0f );  <br>                break; <br>        } <br>        pThread-&gt;SetPipe( pNewPipe ); <br> <br>        if( drawScheme == FRAME_SCHEME_CHASE ) { <br>            if( i == 0 ) { <br>                // this will be the lead pipe <br>                pLeadPipe = pNewPipe; <br>                pNewPipe-&gt;SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED ); <br>            } else { <br>                pNewPipe-&gt;SetChooseDirectionMethod( CHOOSE_DIR_CHASE ); <br>            } <br>        } <br> <br>        // If texturing, pick a random texture for this thread <br> <br>        if( bTexture ) { <br>            int index = PickRandomTexture( i, nTextures ); <br>            pThread-&gt;SetTexture( &amp;texture[index] ); <br> <br>            // Flex pipes need to be informed of the texture, so they  <br>            // can dynamically calculate various texture params <br>            if( pFState ) <br>                ((FLEX_PIPE *) pNewPipe)-&gt;SetTexParams( &amp;texture[index],  <br>                                                        &amp;texRep[index] ); <br>        } <br> <br>        // Launch the pipe (assumed: always more nodes than pipes starting, so <br>        // StartPipe cannot fail) <br> <br>        // ! All pipe setup needs to be done before we call StartPipe, as this <br>        // is where the pipe starts drawing <br> <br>        pThread-&gt;StartPipe(); <br> <br>        if( (i == 0) &amp;&amp; (drawScheme == FRAME_SCHEME_CHASE) ) <br>            pNewPipe-&gt;SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST ); <br> <br>        nPipesDrawn++; <br>    } <br> <br>    // Increment scene rotation for normal reset case <br>    if( resetStatus &amp; RESET_NORMAL_BIT ) <br>        view.IncrementSceneRotation(); <br> <br>    // clear reset status <br>    resetStatus = 0; <br> <br>#ifdef DO_TIMING <br>    Timer( TIMER_START ); <br>#endif <br>} <br> <br> <br>/**************************************************************************\ <br>* CalcMaxPipesPerFrame <br>* <br>\**************************************************************************/ <br> <br>int <br>STATE::CalcMaxPipesPerFrame() <br>{ <br>    int nCount=0, fCount=0; <br> <br>    if( pFState ) <br>        fCount = pFState-&gt;GetMaxPipesPerFrame(); <br>    if( pNState ) <br>        nCount = bTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT; <br>    return SS_MAX( nCount, fCount ); <br>} <br> <br>/**************************************************************************\ <br>* PickRandomTexture <br>* <br>* Pick a random texture index from a list.  Remove entry from list as it <br>* is picked.  Once all have been picked, or starting a new frame, reset. <br>* <br>* ! Routine not reentrant, should only be called by the main thread <br>* dispatcher (FrameReset) <br>\**************************************************************************/ <br> <br>static int <br>PickRandomTexture( int iThread, int nTextures ) <br>{ <br>    if( nTextures == 0 ) <br>        return 0; <br> <br>    static int pickSet[MAX_TEXTURES] = {0}; <br>    static int nPicked = 0; <br>    int i, index; <br> <br>    if( iThread == 0 ) <br>        // new frame - force reset <br>        nPicked = nTextures; <br> <br>    // reset condition <br>    if( ++nPicked &gt; nTextures ) { <br>        for( i = 0; i &lt; nTextures; i ++ ) pickSet[i] = 0; <br>        nPicked = 1; // cuz <br>    } <br> <br>    // Pick a random texture index <br>    index = ss_iRand( nTextures ); <br>    while( pickSet[index] ) { <br>        // this index has alread been taken, try the next one <br>        if( ++index &gt;= nTextures ) <br>            index = 0; <br>    } <br>    // Hopefully, the above loop will exit :).  This means that we have <br>    // found a texIndex that is available <br>    pickSet[index] = 1; // mark as taken <br>    return index; <br>} <br> <br>/**************************************************************************\ <br>* Clear <br>* <br>* Clear the screen.  Depending on resetStatus, use normal clear or <br>* fancy transitional clear. <br>\**************************************************************************/ <br> <br>void  <br>STATE::Clear() <br>{ <br>    // clear the screen - any rc will do <br> <br>    glClear(GL_DEPTH_BUFFER_BIT); <br> <br>    if( resetStatus &amp; RESET_RESIZE_BIT ) { <br>        // new window size - recalibrate the transitional clear <br> <br>        // Calibration is set after a window resize, so window is already black <br>        ddClear.CalibrateClear( view.winSize.width, view.winSize.height, 2.0f ); <br>    } else if( resetStatus &amp; RESET_NORMAL_BIT ) <br>        // do the normal transitional clear <br>        ddClear.Clear( view.winSize.width, view.winSize.height ); <br>    else { <br>        // do a fast one-shot clear <br>        glClear( GL_COLOR_BUFFER_BIT ); <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* DrawValidate <br>* <br>* Validation done before every Draw <br>* <br>* For now, this just involves checking resetStatus <br>* <br>\**************************************************************************/ <br> <br>void  <br>STATE::DrawValidate() <br>{     <br>    if( ! resetStatus ) <br>        return; <br> <br>    FrameReset(); <br>} <br> <br>/**************************************************************************\ <br>* Draw <br>* <br>* - Top-level pipe drawing routine <br>* - Each pipe thread keeps drawing new pipes until we reach maximum number <br>*   of pipes per frame - then each thread gets killed as soon as it gets <br>*   stuck.  Once number of drawing threads reaches 0, we start a new <br>*   frame <br>* <br>\**************************************************************************/ <br> <br>void  <br>STATE::Draw(void *data) <br>{ <br>    int nKilledThreads = 0; <br>    BOOL bChooseNewLead = FALSE; <br> <br>    // Validate the draw state <br> <br>    DrawValidate(); <br> <br>    // Check each pipe's status <br> <br>    DRAW_THREAD *pThread = drawThreads; <br> <br>    for( int i = 0; i &lt; nDrawThreads; i++, pThread++  ) { <br>        if( pThread-&gt;pPipe-&gt;IsStuck() ) { <br>            if( ++nPipesDrawn &gt; maxPipesPerFrame ) { <br>                // Reaching pipe saturation - kill this pipe thread <br> <br>                if( (drawScheme == FRAME_SCHEME_CHASE) &amp;&amp; <br>                    (pThread-&gt;pPipe == pLeadPipe) )  <br>                    bChooseNewLead = TRUE; <br> <br>                pThread-&gt;KillPipe(); <br>                nKilledThreads++; <br> <br>            } else { <br>                // Start up another pipe <br>                if( ! pThread-&gt;StartPipe() ) <br>                    // we won't be able to draw any more pipes this frame <br>                    // (probably out of nodes) <br>                    maxPipesPerFrame = nPipesDrawn; <br>            } <br>        } <br>    } <br> <br>    // Whenever one or more pipes are killed, compact the thread list <br>    if( nKilledThreads ) { <br>        CompactThreadList(); <br>        nDrawThreads -= nKilledThreads; <br>    } <br> <br>    if( nDrawThreads == 0 ) { <br>        // This frame is finished - mark for reset on next Draw <br>        resetStatus |= RESET_NORMAL_BIT; <br>        return; <br>    } <br> <br>    if( bChooseNewLead ) { <br>        // We're in 'chase mode' and need to pick a new lead pipe <br>        ChooseNewLeadPipe(); <br>    } <br> <br>    // Draw each pipe <br> <br>    for( i = 0, pThread = drawThreads; i &lt; nDrawThreads; i++, pThread++ ) { <br>        pThread-&gt;DrawPipe(); <br>#ifdef DO_TIMING <br>        pipeCount++; <br>#endif <br>    } <br> <br>    glFlush(); <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* CompactThreadList <br>* <br>* - Compact the thread list according to number of pipe threads killed <br>* - The pipes have been killed, but the RC's in each slot are still valid <br>*   and reusable.  So we swap up entries with valid pipes. This means that <br>*   the ordering of the RC's in the thread list will change during the life <br>*   of the program.  This should be OK. <br>* <br>\**************************************************************************/ <br> <br>#define SWAP_SLOT( a, b ) \ <br>    DRAW_THREAD pTemp; \ <br>    pTemp = *(a); \ <br>    *(a) = *(b); \ <br>    *(b) = pTemp; <br>     <br>void <br>STATE::CompactThreadList() <br>{ <br>    if( nDrawThreads &lt;= 1 ) <br>        // If only one active thread, it must be in slot 0 from previous <br>        // compactions - so nothing to do <br>        return; <br> <br>    int iEmpty = 0; <br>    DRAW_THREAD *pThread = drawThreads; <br> <br>    for( int i = 0; i &lt; nDrawThreads; i ++, pThread++ ) { <br>        if( pThread-&gt;pPipe ) { <br>            if( iEmpty &lt; i ) { <br>                // swap active pipe thread and empty slot <br>                SWAP_SLOT( &amp;(drawThreads[iEmpty]), pThread ); <br>            } <br>            iEmpty++; <br>        } <br>    } <br>} <br> <br>/**************************************************************************\ <br>* <br>* ChooseNewLeadPipe <br>* <br>* Choose a new lead pipe for chase mode. <br>* <br>\**************************************************************************/ <br> <br>void <br>STATE::ChooseNewLeadPipe() <br>{ <br>    // Pick one of the active pipes at random to become the new lead <br> <br>    int iLead = ss_iRand( nDrawThreads ); <br>    pLeadPipe = drawThreads[iLead].pPipe; <br>    pLeadPipe-&gt;SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST ); <br>    pLeadPipe-&gt;SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED ); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* Finish <br>* <br>* - Called when GL window being closed <br>* <br>\**************************************************************************/ <br>void  <br>STATE::Finish( void *data ) <br>{ <br>    delete (STATE *) data; <br>} <br> <br>/**************************************************************************\ <br>* DRAW_THREAD constructor <br>* <br>\**************************************************************************/ <br> <br>DRAW_THREAD::DRAW_THREAD() <br>{ <br>    hdc = 0; <br>    hglrc = 0; <br>    pPipe = NULL; <br>    htex = (HTEXTURE) -1; <br>} <br> <br>/**************************************************************************\ <br>* DRAW_THREAD destructor <br>* <br>* Delete any GL contexts <br>* <br>* - can't Delete shareRC, as this is done by common lib, so had to move <br>*   this up to ~STATE <br>* <br>\**************************************************************************/ <br> <br>DRAW_THREAD::~DRAW_THREAD() <br>{ <br>} <br> <br>/**************************************************************************\ <br>* MakeRCCurrent <br>* <br>\**************************************************************************/ <br> <br>void  <br>DRAW_THREAD::MakeRCCurrent() <br>{ <br>    if( hglrc != wglGetCurrentContext() ) <br>        wglMakeCurrent( hdc, hglrc ); <br>} <br> <br>/**************************************************************************\ <br>* SetRCDC <br>* <br>\**************************************************************************/ <br> <br>void  <br>DRAW_THREAD::SetRCDC( HGLRC rc, HDC Hdc ) <br>{ <br>    hglrc = rc; <br>    hdc = Hdc; <br>} <br> <br>/**************************************************************************\ <br>* SetPipe <br>* <br>\**************************************************************************/ <br> <br>void  <br>DRAW_THREAD::SetPipe( PIPE *pipe ) <br>{ <br>    pPipe = pipe; <br>} <br> <br>/**************************************************************************\ <br>* HasRC <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>DRAW_THREAD::HasRC() <br>{ <br>    return( hglrc != 0 ); <br>} <br> <br>/**************************************************************************\ <br>* GetRC <br>* <br>\**************************************************************************/ <br> <br>HGLRC <br>DRAW_THREAD::GetRC() <br>{ <br>    return hglrc; <br>} <br> <br>/**************************************************************************\ <br>* SetTexture <br>* <br>* - Set a texture for a thread <br>* - Cache the texture index for performance <br>\**************************************************************************/ <br> <br>void  <br>DRAW_THREAD::SetTexture( HTEXTURE hnewtex ) <br>{ <br>    if( hnewtex != htex ) <br>    { <br>        htex = hnewtex; <br>        ss_SetTexture( htex ); <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* DrawPipe <br>* <br>* - Draw pipe in thread slot, according to its type <br>* <br>\**************************************************************************/ <br> <br>void  <br>DRAW_THREAD::DrawPipe() <br>{ <br>    MakeRCCurrent(); <br> <br>    switch( pPipe-&gt;type ) { <br>        case TYPE_NORMAL: <br>            ( (NORMAL_PIPE *) pPipe )-&gt;Draw(); <br>            break; <br>        case TYPE_FLEX_REGULAR: <br>            ( (REGULAR_FLEX_PIPE *) pPipe )-&gt;Draw(); <br>            break; <br>        case TYPE_FLEX_TURNING: <br>            ( (TURNING_FLEX_PIPE *) pPipe )-&gt;Draw(); <br>            break; <br>    } <br>    glFlush(); <br>} <br>/**************************************************************************\ <br>* StartPipe <br>* <br>* Starts up pipe of the approppriate type.  If can't find an empty node <br>* for the pipe to start on, returns FALSE; <br>* <br>\**************************************************************************/ <br> <br>BOOL <br>DRAW_THREAD::StartPipe() <br>{ <br>    MakeRCCurrent(); <br> <br>    // call pipe-type specific Start function <br> <br>    switch( pPipe-&gt;type ) { <br>        case TYPE_NORMAL: <br>            ( (NORMAL_PIPE *) pPipe )-&gt;Start(); <br>            break; <br>        case TYPE_FLEX_REGULAR: <br>            ( (REGULAR_FLEX_PIPE *) pPipe )-&gt;Start(); <br>            break; <br>        case TYPE_FLEX_TURNING: <br>            ( (TURNING_FLEX_PIPE *) pPipe )-&gt;Start(); <br>            break; <br>    } <br>    glFlush(); <br> <br>    // check status <br>    if( pPipe-&gt;NowhereToRun() ) <br>        return FALSE; <br>    else <br>        return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* KillPipe <br>* <br>\**************************************************************************/ <br> <br>void  <br>DRAW_THREAD::KillPipe() <br>{ <br>    switch( pPipe-&gt;type ) { <br>        case TYPE_NORMAL: <br>            delete (NORMAL_PIPE *) pPipe; <br>            break; <br>        case TYPE_FLEX_REGULAR: <br>            delete (REGULAR_FLEX_PIPE *) pPipe; <br>            break; <br>        case TYPE_FLEX_TURNING: <br>            delete (TURNING_FLEX_PIPE *) pPipe; <br>            break; <br>    } <br>    pPipe = NULL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
