<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEVAL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3662"></a>TEVAL.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;gl\glaux.h&gt; <br> <br> <br>#define VORDER 10 <br>#define CORDER 10 <br>#define TORDER 3 <br> <br>#define VMAJOR_ORDER 2 <br>#define VMINOR_ORDER 3 <br> <br>#define CMAJOR_ORDER 2 <br>#define CMINOR_ORDER 2 <br> <br>#define TMAJOR_ORDER 2 <br>#define TMINOR_ORDER 2 <br> <br>#define VDIM 4 <br>#define CDIM 4 <br>#define TDIM 2 <br> <br>#define ONE_D 1 <br>#define TWO_D 2 <br> <br>#define EVAL 3 <br>#define MESH 4 <br> <br>static void Init(void ); <br>static void DrawPoints1(void ); <br>static void DrawPoints2(void ); <br>static void DrawMapEval1(float du); <br>static void DrawMapEval2(float du,float dv); <br>static void RenderEval(void ); <br>static void CALLBACK Reshape(int width,int height); <br>static void CALLBACK Key_left(void ); <br>static void CALLBACK Key_right(void ); <br>static void CALLBACK Key_up(void ); <br>static void CALLBACK Key_down(void ); <br>static void CALLBACK Key_1(void ); <br>static void CALLBACK Key_2(void ); <br>static void CALLBACK Key_e(void ); <br>static void CALLBACK Key_m(void ); <br>static void CALLBACK Key_f(void ); <br>static void CALLBACK Key_p(void ); <br>static void CALLBACK Key_c(void ); <br>static void CALLBACK Key_t(void ); <br>static void CALLBACK Key_l(void ); <br>static void CALLBACK Draw(void ); <br>static GLenum Args(int argc,char **argv ); <br> <br>GLenum doubleBuffer; <br> <br>float rotX = 0.0, rotY = 0.0, translateZ = -1.0; <br> <br>GLenum arrayType = ONE_D; <br>GLenum colorType = GL_FALSE; <br>GLenum textureType = GL_FALSE; <br>GLenum polygonFilled = GL_FALSE; <br>GLenum lighting = GL_FALSE; <br>GLenum mapPoint = GL_FALSE; <br>GLenum mapType = EVAL; <br> <br>double point1[10*4] = { <br>    -0.5, 0.0, 0.0, 1.0, <br>    -0.4, 0.5, 0.0, 1.0, <br>    -0.3,-0.5, 0.0, 1.0, <br>    -0.2, 0.5, 0.0, 1.0, <br>    -0.1,-0.5, 0.0, 1.0, <br>    0.0, 0.5, 0.0, 1.0, <br>    0.1,-0.5, 0.0, 1.0, <br>    0.2, 0.5, 0.0, 1.0, <br>    0.3,-0.5, 0.0, 1.0, <br>    0.4, 0.0, 0.0, 1.0, <br>}; <br>double cpoint1[10*4] = { <br>    0.0, 0.0, 1.0, 1.0, <br>    0.3, 0.0, 0.7, 1.0, <br>    0.6, 0.0, 0.3, 1.0, <br>    1.0, 0.0, 0.0, 1.0, <br>    1.0, 0.3, 0.0, 1.0, <br>    1.0, 0.6, 0.0, 1.0, <br>    1.0, 1.0, 0.0, 1.0, <br>    1.0, 1.0, 0.5, 1.0, <br>    1.0, 1.0, 1.0, 1.0, <br>}; <br>double tpoint1[11*4] = { <br>    0.0, 0.0, 0.0, 1.0, <br>    0.0, 0.1, 0.0, 1.0, <br>    0.0, 0.2, 0.0, 1.0, <br>    0.0, 0.3, 0.0, 1.0, <br>    0.0, 0.4, 0.0, 1.0, <br>    0.0, 0.5, 0.0, 1.0, <br>    0.0, 0.6, 0.0, 1.0, <br>    0.0, 0.7, 0.0, 1.0, <br>    0.0, 0.8, 0.0, 1.0, <br>    0.0, 0.9, 0.0, 1.0, <br>}; <br>double point2[2*3*4] = { <br>    -0.5, -0.5,  0.5, 1.0,  <br>     0.0,  1.0,  0.5, 1.0,  <br>     0.5, -0.5,  0.5, 1.0, <br>    -0.5,  0.5, -0.5, 1.0,  <br>     0.0, -1.0, -0.5, 1.0,  <br>     0.5,  0.5, -0.5, 1.0, <br>}; <br>double cpoint2[2*2*4] = { <br>    0.0, 0.0, 0.0, 1.0, <br>    0.0, 0.0, 1.0, 1.0, <br>    0.0, 1.0, 0.0, 1.0, <br>    1.0, 1.0, 1.0, 1.0, <br>}; <br>double tpoint2[2*2*2] = { <br>    0.0, 0.0, 0.0, 1.0, <br>    1.0, 0.0, 1.0, 1.0,  <br>}; <br>float textureImage[4*2*4] =  { <br>    1.0, 1.0, 1.0, 1.0, <br>    1.0, 0.0, 0.0, 1.0, <br>    1.0, 0.0, 0.0, 1.0, <br>    1.0, 1.0, 1.0, 1.0,  <br>    1.0, 1.0, 1.0, 1.0, <br>    1.0, 0.0, 0.0, 1.0, <br>    1.0, 0.0, 0.0, 1.0, <br>    1.0, 1.0, 1.0, 1.0,  <br>}; <br> <br> <br>static void Init(void) <br>{ <br>    static float ambient[] = {0.1, 0.1, 0.1, 1.0}; <br>    static float diffuse[] = {1.0, 1.0, 1.0, 1.0}; <br>    static float position[] = {0.0, 0.0, -150.0, 0.0}; <br>    static float front_mat_shininess[] = {30.0}; <br>    static float front_mat_specular[] = {0.7, 0.7, 0.7, 1.0}; <br>    static float front_mat_diffuse[] = {1.0, 0.2, 1.0, 1.0}; <br>    static float back_mat_shininess[] = {50.0}; <br>    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0}; <br>    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0}; <br>    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0}; <br>    static float lmodel_twoside[] = {GL_TRUE}; <br>    static float decal[] = {GL_DECAL}; <br>    static float modulate[] = {GL_MODULATE}; <br>    static float repeat[] = {GL_REPEAT}; <br>    static float clamp[] = {GL_CLAMP}; <br>    static float nr[] = {GL_NEAREST}; <br>    static float ln[] = {GL_LINEAR}; <br> <br>    glFrontFace(GL_CCW); <br> <br>    glEnable(GL_DEPTH_TEST); <br>    glDepthFunc(GL_LEQUAL); <br> <br>    glMap1d(GL_MAP1_VERTEX_4, 0.0, 1.0, VDIM, VORDER, point1); <br>    glMap1d(GL_MAP1_COLOR_4, 0.0, 1.0, CDIM, CORDER, cpoint1); <br> <br>    glMap2d(GL_MAP2_VERTEX_4, 0.0, 1.0, VMINOR_ORDER*VDIM, VMAJOR_ORDER, 0.0, <br>        1.0, VDIM, VMINOR_ORDER, point2); <br>    glMap2d(GL_MAP2_COLOR_4, 0.0, 1.0, CMINOR_ORDER*CDIM, CMAJOR_ORDER, 0.0, <br>        1.0, CDIM, CMINOR_ORDER, cpoint2); <br>    glMap2d(GL_MAP2_TEXTURE_COORD_2, 0.0, 1.0, TMINOR_ORDER*TDIM, <br>        TMAJOR_ORDER, 0.0, 1.0, TDIM, TMINOR_ORDER, tpoint2); <br> <br>    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient); <br>    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse); <br>    glLightfv(GL_LIGHT0, GL_POSITION, position); <br>     <br>    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse); <br>    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse); <br> <br>    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient); <br>    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside); <br> <br>    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nr); <br>    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nr); <br>    glTexImage2D(GL_TEXTURE_2D, 0, 4, 2, 4, 0, GL_RGBA, GL_FLOAT, <br>         (GLvoid *)textureImage); <br>} <br> <br>static void DrawPoints1(void) <br>{ <br>    GLint i; <br> <br>    glColor3f(0.0, 1.0, 0.0); <br>    glPointSize(2); <br>    glBegin(GL_POINTS); <br>    for (i = 0; i &lt; VORDER; i++) { <br>        glVertex4dv(&amp;point1[i*4]); <br>    } <br>    glEnd(); <br>} <br> <br>static void DrawPoints2(void) <br>{ <br>    GLint i, j; <br> <br>    glColor3f(1.0, 0.0, 1.0); <br>    glPointSize(2); <br>    glBegin(GL_POINTS); <br>    for (i = 0; i &lt; VMAJOR_ORDER; i++) { <br>        for (j = 0; j &lt; VMINOR_ORDER; j++) { <br>        glVertex4dv(&amp;point2[i*4*VMINOR_ORDER+j*4]); <br>        } <br>    } <br>    glEnd(); <br>} <br> <br>static void DrawMapEval1(float du) <br>{ <br>    float u; <br> <br>    glColor3f(1.0, 0.0, 0.0); <br>    glBegin(GL_LINE_STRIP); <br>    for (u = 0.0; u &lt; 1.0; u += du) { <br>        glEvalCoord1d(u); <br>    } <br>    glEvalCoord1d(1.0); <br>    glEnd(); <br>} <br> <br>static void DrawMapEval2(float du, float dv) <br>{ <br>    float u, v, tmp; <br> <br>    glColor3f(1.0, 0.0, 0.0); <br>    for (v = 0.0; v &lt; 1.0; v += dv) { <br>    glBegin(GL_QUAD_STRIP); <br>        for (u = 0.0; u &lt;= 1.0; u += du) { <br>        glEvalCoord2d(u,v); <br>        tmp = (v + dv &lt; 1.0) ? (v + dv) : 1.0; <br>        glEvalCoord2d(u, tmp); <br>        } <br>        glEvalCoord2d(1.0, v); <br>        glEvalCoord2d(1.0, v+dv); <br>    glEnd(); <br>    } <br>} <br> <br>static void RenderEval(void) <br>{ <br> <br>    if (colorType) { <br>    glEnable(GL_MAP1_COLOR_4); <br>    glEnable(GL_MAP2_COLOR_4); <br>    } else { <br>    glDisable(GL_MAP1_COLOR_4); <br>    glDisable(GL_MAP2_COLOR_4); <br>    } <br> <br>    if (textureType) { <br>    glEnable(GL_TEXTURE_2D); <br>    glEnable(GL_MAP2_TEXTURE_COORD_2); <br>    } else { <br>    glDisable(GL_TEXTURE_2D); <br>    glDisable(GL_MAP2_TEXTURE_COORD_2); <br>    } <br> <br>    if (polygonFilled) { <br>    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); <br>    } else { <br>    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); <br>    } <br> <br>    glShadeModel(GL_SMOOTH); <br> <br>    switch (mapType) { <br>      case EVAL: <br>    switch (arrayType) { <br>      case ONE_D: <br>        glDisable(GL_MAP2_VERTEX_4); <br>        glEnable(GL_MAP1_VERTEX_4); <br>        DrawPoints1(); <br>        DrawMapEval1(0.1/VORDER); <br>        break; <br>      case TWO_D: <br>        glDisable(GL_MAP1_VERTEX_4); <br>        glEnable(GL_MAP2_VERTEX_4); <br>        DrawPoints2(); <br>        DrawMapEval2(0.1/VMAJOR_ORDER,0.1/VMINOR_ORDER); <br>        break; <br>    } <br>    break; <br>      case MESH: <br>    switch (arrayType) { <br>      case ONE_D: <br>        DrawPoints1(); <br>        glDisable(GL_MAP2_VERTEX_4); <br>        glEnable (GL_MAP1_VERTEX_4); <br>        glColor3f(0.0, 0.0, 1.0); <br>        glMapGrid1d(40, 0.0, 1.0); <br>        if (mapPoint) { <br>        glPointSize(2); <br>        glEvalMesh1(GL_POINT, 0, 40); <br>        } else { <br>        glEvalMesh1(GL_LINE, 0, 40); <br>        } <br>        break; <br>      case TWO_D: <br>        DrawPoints2(); <br>        glDisable(GL_MAP1_VERTEX_4); <br>        glEnable(GL_MAP2_VERTEX_4); <br>        glColor3f(0.0, 0.0, 1.0); <br>        glMapGrid2d(20, 0.0, 1.0, 20, 0.0, 1.0); <br>        if (mapPoint) { <br>        glPointSize(2); <br>        glEvalMesh2(GL_POINT, 0, 20, 0, 20); <br>        } else if (polygonFilled) { <br>        glEvalMesh2(GL_FILL, 0, 20, 0, 20); <br>        } else { <br>        glEvalMesh2(GL_LINE, 0, 20, 0, 20); <br>        } <br>        break; <br>    } <br>    break; <br>    } <br>} <br> <br>static void CALLBACK Reshape(int width, int height) <br>{ <br> <br>    glViewport(0, 0, (GLint)width, (GLint)height); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    glOrtho(-1.0, 1.0, -1.0, 1.0, -0.5, 10.0); <br>    glMatrixMode(GL_MODELVIEW); <br>} <br> <br>static void CALLBACK Key_left(void) <br>{ <br>    rotY -= 30; <br>} <br> <br>static void CALLBACK Key_right(void) <br>{ <br>    rotY += 30; <br>} <br> <br>static void CALLBACK Key_up(void) <br>{ <br>    rotX -= 30; <br>} <br> <br>static void CALLBACK Key_down(void) <br>{ <br>    rotX += 30; <br>} <br> <br>static void CALLBACK Key_1(void) <br>{ <br>    arrayType = ONE_D; <br>} <br> <br>static void CALLBACK Key_2(void) <br>{ <br>    arrayType = TWO_D; <br>} <br> <br>static void CALLBACK Key_e(void) <br>{ <br>    mapType = EVAL; <br>} <br> <br>static void CALLBACK Key_m(void) <br>{ <br>    mapType = MESH; <br>} <br> <br>static void CALLBACK Key_f(void) <br>{ <br>    polygonFilled = !polygonFilled; <br>} <br> <br>static void CALLBACK Key_p(void) <br>{ <br>    mapPoint = !mapPoint; <br>} <br> <br>static void CALLBACK Key_c(void) <br>{ <br>    colorType = !colorType; <br>} <br> <br>static void CALLBACK Key_t(void) <br>{ <br>    textureType = !textureType; <br>} <br> <br>static void CALLBACK Key_l(void) <br>{ <br>    lighting =! lighting; <br>    if (lighting) { <br>        glEnable(GL_LIGHTING); <br>        glEnable(GL_LIGHT0); <br>        glEnable(GL_AUTO_NORMAL); <br>    } else { <br>        glDisable(GL_LIGHTING); <br>        glDisable(GL_LIGHT0); <br>        glDisable(GL_AUTO_NORMAL); <br>    } <br>} <br> <br>static void CALLBACK Draw(void) <br>{ <br> <br>    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT); <br> <br>    glPushMatrix(); <br> <br>    glTranslatef(0.0, 0.0 , translateZ); <br>    glRotatef(rotX, 1, 0, 0); <br>    glRotatef(rotY, 0, 1, 0); <br>    RenderEval(); <br> <br>    glPopMatrix(); <br> <br>    glFlush(); <br> <br>    if (doubleBuffer) { <br>    auxSwapBuffers(); <br>    } <br>} <br> <br>static GLenum Args(int argc, char **argv) <br>{ <br>    GLint i; <br> <br>    doubleBuffer = GL_FALSE; <br> <br> <br>    for (i = 1; i &lt; argc; i++) { <br>    if (strcmp(argv[i], "-sb") == 0) { <br>        doubleBuffer = GL_FALSE; <br>    } else if (strcmp(argv[i], "-db") == 0) { <br>        doubleBuffer = GL_TRUE; <br>    } else { <br>        //printf("%s (Bad option).\n", argv[i]); <br>        return GL_FALSE; <br>    } <br>    } <br>    return GL_TRUE; <br>} <br> <br>void main(int argc, char **argv) <br>{ <br>    GLenum type; <br> <br>    if (Args(argc, argv) == GL_FALSE) { <br>    auxQuit(); <br>    } <br> <br>    auxInitPosition(0, 0, 300, 300); <br> <br>    type = AUX_RGB | AUX_DEPTH16; <br>    type |= (doubleBuffer) ? AUX_DOUBLE : AUX_SINGLE; <br> <br>    auxInitDisplayMode(type); <br> <br>    if (auxInitWindow("Evaluator Test") == GL_FALSE) { <br>    auxQuit(); <br>    } <br> <br>    Init(); <br> <br>    auxExposeFunc((AUXEXPOSEPROC)Reshape); <br>    auxReshapeFunc((AUXRESHAPEPROC)Reshape); <br>    auxKeyFunc(AUX_LEFT, Key_left); <br>    auxKeyFunc(AUX_RIGHT, Key_right); <br>    auxKeyFunc(AUX_UP, Key_up); <br>    auxKeyFunc(AUX_DOWN, Key_down); <br>    auxKeyFunc(AUX_1, Key_1); <br>    auxKeyFunc(AUX_2, Key_2); <br>    auxKeyFunc(AUX_e, Key_e); <br>    auxKeyFunc(AUX_m, Key_m); <br>    auxKeyFunc(AUX_f, Key_f); <br>    auxKeyFunc(AUX_p, Key_p); <br>    auxKeyFunc(AUX_c, Key_c); <br>    auxKeyFunc(AUX_t, Key_t); <br>    auxKeyFunc(AUX_l, Key_l); <br>    auxMainLoop(Draw); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
