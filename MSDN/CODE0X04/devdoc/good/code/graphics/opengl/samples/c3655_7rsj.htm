<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TSTAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3673"></a>TSTAR.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;time.h&gt; <br>#include "GL/gl.h" <br>#include "GL/glu.h" <br>#include &lt;gl\glaux.h&gt; <br> <br>#define PI 3.141592657 <br> <br>extern float Sin(float angle); <br>extern float Cos(float angle); <br>extern void NewStar(GLint n, GLint d); <br>extern void RotatePoint(float *x,float *y,float rotation); <br>extern void MoveStars(void ); <br>extern GLenum StarPoint(GLint n); <br>extern void ShowStars(void ); <br>static void Init(void ); <br>extern void CALLBACK Reshape(int width,int height); <br>static void CALLBACK Key_SPACE(void ); <br>static void CALLBACK Key_t(void ); <br>extern void CALLBACK Idle(void ); <br>static GLenum Args(int argc,char **argv ); <br> <br>enum { <br>    NORMAL = 0, <br>    WEIRD = 1 <br>}; <br> <br>enum { <br>    STREAK = 0, <br>    CIRCLE = 1 <br>}; <br> <br>#define MAXSTARS 400 <br>#define MAXPOS 10000 <br>#define MAXWARP 10 <br>#define MAXANGLES 6000 <br> <br> <br>typedef struct _starRec { <br>    GLint type; <br>    float x[2], y[2], z[2]; <br>    float offsetX, offsetY, offsetR, rotation; <br>} starRec; <br> <br> <br>GLenum doubleBuffer; <br>GLint windW, windH; <br> <br>GLenum flag = NORMAL; <br>GLint starCount = MAXSTARS / 2; <br>float speed = 1.0; <br>GLint nitro = 0; <br>starRec stars[MAXSTARS]; <br>float sinTable[MAXANGLES]; <br> <br> <br>float Sin(float angle) <br>{ <br> <br>    return (sinTable[(GLint)angle % MAXANGLES]); <br>} <br> <br>float Cos(float angle) <br>{ <br> <br>    return (sinTable[((GLint)angle+(MAXANGLES/4))%MAXANGLES]); <br>} <br> <br>void NewStar(GLint n, GLint d) <br>{ <br> <br>    if (rand()%4 == 0) { <br>    stars[n].type = CIRCLE; <br>    } else { <br>    stars[n].type = STREAK; <br>    } <br>    stars[n].x[0] = (float)(rand() % MAXPOS - MAXPOS / 2); <br>    stars[n].y[0] = (float)(rand() % MAXPOS - MAXPOS / 2); <br>    stars[n].z[0] = (float)(rand() % MAXPOS + d); <br>    if (rand()%4 == 0 &amp;&amp; flag == WEIRD) { <br>    stars[n].offsetX = (float)(rand() % 100 - 100 / 2); <br>    stars[n].offsetY = (float)(rand() % 100 - 100 / 2); <br>    stars[n].offsetR = (float)(rand() % 25 - 25 / 2); <br>    } else { <br>    stars[n].offsetX = 0.0; <br>    stars[n].offsetY = 0.0; <br>    stars[n].offsetR = 0.0; <br>    } <br>    stars[n].rotation = 0.0; <br>} <br> <br>void RotatePoint(float *x, float *y, float rotation) <br>{ <br>    float tmpX, tmpY; <br> <br>    tmpX = *x * Cos(rotation) - *y * Sin(rotation); <br>    tmpY = *y * Cos(rotation) + *x * Sin(rotation); <br>    *x = tmpX; <br>    *y = tmpY; <br>} <br> <br>void MoveStars(void) <br>{ <br>    float offset; <br>    GLint n; <br> <br>    offset = speed * 60.0; <br> <br>    for (n = 0; n &lt; starCount; n++) { <br>        stars[n].x[1] = stars[n].x[0]; <br>        stars[n].y[1] = stars[n].y[0]; <br>        stars[n].z[1] = stars[n].z[0]; <br>        stars[n].x[0] += stars[n].offsetX; <br>        stars[n].y[0] += stars[n].offsetY; <br>        stars[n].z[0] -= offset; <br>        stars[n].rotation += stars[n].offsetR; <br>        if (stars[n].rotation &gt; MAXANGLES) { <br>            stars[n].rotation = 0.0; <br>        } else if (stars[n].rotation &lt; 0.0) { <br>            stars[n].rotation = (float)MAXANGLES; <br>        } <br>    } <br>} <br> <br>GLenum StarPoint(GLint n) <br>{ <br>    float x0, y0, x1, y1, width; <br>    GLint i; <br> <br>    x0 = stars[n].x[0] * windW / stars[n].z[0]; <br>    y0 = stars[n].y[0] * windH / stars[n].z[0]; <br>    RotatePoint(&amp;x0, &amp;y0, stars[n].rotation); <br>    x0 += windW / 2.0; <br>    y0 += windH / 2.0; <br> <br>    if (x0 &gt;= 0.0 &amp;&amp; x0 &lt; windW &amp;&amp; y0 &gt;= 0.0 &amp;&amp; y0 &lt; windH) { <br>    if (stars[n].type == STREAK) { <br>        x1 = stars[n].x[1] * windW / stars[n].z[1]; <br>        y1 = stars[n].y[1] * windH / stars[n].z[1]; <br>        RotatePoint(&amp;x1, &amp;y1, stars[n].rotation); <br>        x1 += windW / 2.0; <br>        y1 += windH / 2.0; <br> <br>        glLineWidth(MAXPOS/100.0/stars[n].z[0]+1.0); <br>        glColor3f(1.0, (MAXWARP-speed)/MAXWARP, (MAXWARP-speed)/MAXWARP); <br>        if (fabs(x0-x1) &lt; 1.0 &amp;&amp; fabs(y0-y1) &lt; 1.0) { <br>        glBegin(GL_POINTS); <br>            glVertex2f(x0, y0); <br>        glEnd(); <br>        } else { <br>        glBegin(GL_LINES); <br>            glVertex2f(x0, y0); <br>            glVertex2f(x1, y1); <br>        glEnd(); <br>        } <br>    } else { <br>        width = MAXPOS / 10.0 / stars[n].z[0] + 1.0; <br>        glColor3f(1.0, 0.0, 0.0); <br>        glBegin(GL_POLYGON); <br>        for (i = 0; i &lt; 8; i++) { <br>            float x = x0 + width * Cos((float)i*MAXANGLES/8.0); <br>            float y = y0 + width * Sin((float)i*MAXANGLES/8.0); <br>            glVertex2f(x, y); <br>        }; <br>        glEnd(); <br>    } <br>    return GL_TRUE; <br>    } else { <br>    return GL_FALSE; <br>    } <br>} <br> <br>void ShowStars(void) <br>{ <br>    GLint n; <br> <br>    glClear(GL_COLOR_BUFFER_BIT); <br> <br>    for (n = 0; n &lt; starCount; n++) { <br>    if (stars[n].z[0] &gt; speed || (stars[n].z[0] &gt; 0.0 &amp;&amp; speed &lt; MAXWARP)) { <br>        if (StarPoint(n) == GL_FALSE) { <br>        NewStar(n, MAXPOS); <br>        } <br>    } else { <br>        NewStar(n, MAXPOS); <br>    } <br>    } <br>} <br> <br>static void Init(void) <br>{ <br>    float angle; <br>    GLint n; <br> <br>    srand((unsigned int)time(NULL)); <br> <br>    for (n = 0; n &lt; MAXSTARS; n++) { <br>    NewStar(n, 100); <br>    } <br> <br>    angle = 0.0; <br>    for (n = 0; n &lt; MAXANGLES ; n++) { <br>    sinTable[n] = sin(angle); <br>        angle += PI / (MAXANGLES / 2.0); <br>    } <br> <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br> <br>    glDisable(GL_DITHER); <br>} <br> <br>void CALLBACK Reshape(int width, int height) <br>{ <br> <br>    windW = (GLint)width; <br>    windH = (GLint)height; <br> <br>    glViewport(0, 0, windW, windH); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluOrtho2D(-0.5, windW+0.5, -0.5, windH+0.5); <br>    glMatrixMode(GL_MODELVIEW); <br>} <br> <br>static void CALLBACK Key_SPACE(void) <br>{ <br>    flag = (flag == NORMAL) ? WEIRD : NORMAL; <br>} <br> <br>static void CALLBACK Key_t(void) <br>{ <br>    nitro = 1; <br>} <br> <br>void CALLBACK Idle(void) <br>{ <br> <br>    MoveStars(); <br>    ShowStars(); <br>    if (nitro &gt; 0) { <br>    speed = (float)(nitro / 10) + 1.0; <br>    if (speed &gt; MAXWARP) { <br>        speed = MAXWARP; <br>    } <br>    if (++nitro &gt; MAXWARP*10) { <br>        nitro = -nitro; <br>    } <br>    } else if (nitro &lt; 0) { <br>    nitro++; <br>    speed = (float)(-nitro / 10) + 1.0; <br>    if (speed &gt; MAXWARP) { <br>        speed = MAXWARP; <br>    } <br>    } <br> <br>    glFlush(); <br>    if (doubleBuffer) { <br>    auxSwapBuffers(); <br>    } <br>} <br> <br>static GLenum Args(int argc, char **argv) <br>{ <br>    GLint i; <br> <br>    doubleBuffer = GL_FALSE; <br> <br> <br>    for (i = 1; i &lt; argc; i++) { <br>    if (strcmp(argv[i], "-sb") == 0) { <br>        doubleBuffer = GL_FALSE; <br>    } else if (strcmp(argv[i], "-db") == 0) { <br>        doubleBuffer = GL_TRUE; <br>    } <br>    } <br>    return GL_TRUE; <br>} <br> <br>void main(int argc, char **argv) <br>{ <br>    GLenum type; <br> <br>    if (Args(argc, argv) == GL_FALSE) { <br>    auxQuit(); <br>    } <br> <br>    windW = 300; <br>    windH = 300; <br>    auxInitPosition(0, 0, 300, 300); <br> <br>    type = AUX_RGB; <br>    type |= (doubleBuffer) ? AUX_DOUBLE : AUX_SINGLE; <br> <br>    auxInitDisplayMode(type); <br> <br>    if (auxInitWindow("Stars") == GL_FALSE) { <br>    auxQuit(); <br>    } <br> <br>    Init(); <br> <br>    auxExposeFunc((AUXEXPOSEPROC)Reshape); <br>    auxReshapeFunc((AUXRESHAPEPROC)Reshape); <br>    auxKeyFunc(AUX_SPACE, Key_SPACE); <br>    auxKeyFunc(AUX_t, Key_t); <br>    auxIdleFunc(Idle); <br>    auxMainLoop(NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
