<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TSTRETCH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3675"></a>TSTRETCH.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;gl\glaux.h&gt; <br> <br>#define STEPCOUNT 40 <br>#define FALSE 0 <br>#define TRUE 1 <br>#define MAX(a, b) (((a) &gt; (b)) ? (a) : (b)) <br>#define MIN(a, b) (((a) &lt; (b)) ? (a) : (b)) <br> <br>enum { <br>    OP_NOOP = 0, <br>    OP_STRETCH, <br>    OP_DRAWPOINT, <br>    OP_DRAWIMAGE <br>}; <br> <br> <br>typedef struct _cRec { <br>    float x, y; <br>} cRec; <br> <br>typedef struct _vertexRec { <br>    float x, y; <br>    float dX, dY; <br>    float tX, tY; <br>} vertexRec; <br> <br>extern void DrawImage(void ); <br>extern void DrawPoint(void ); <br>extern void InitVList(void ); <br>extern void ScaleImage(int sizeX,int sizeY); <br>extern void SetPoint(int x,int y); <br>extern void Stretch(void ); <br>static void CALLBACK Key_SPACE(void ); <br>static GLenum CALLBACK Mouse_left(struct _AUX_EVENTREC *event); <br>extern void CALLBACK Animate(void ); <br>static GLenum Args(int argc,char **argv ); <br> <br>GLenum doubleBuffer; <br>int imageSizeX, imageSizeY; <br>char *fileName = 0; <br>AUX_RGBImageRec *image; <br>cRec cList[50]; <br>vertexRec vList[5]; <br>int cCount, cIndex[2], cStep; <br>GLenum op = OP_NOOP; <br> <br> <br>void DrawImage(void) <br>{ <br> <br>    glRasterPos2i(0, 0); <br>    glDrawPixels(image-&gt;sizeX, image-&gt;sizeY, GL_RGB, GL_UNSIGNED_BYTE, <br>         image-&gt;data); <br> <br>    auxSwapBuffers(); <br> <br>    glRasterPos2i(0, 0); <br>    glDrawPixels(image-&gt;sizeX, image-&gt;sizeY, GL_RGB, GL_UNSIGNED_BYTE, <br>         image-&gt;data); <br>} <br> <br>void DrawPoint(void) <br>{ <br>    int i; <br> <br>    glColor3f(1.0, 0.0, 1.0); <br>    glPointSize(3.0); <br>    glBegin(GL_POINTS); <br>    for (i = 0; i &lt; cCount; i++) { <br>        glVertex2f(cList[i].x, cList[i].y); <br>    } <br>    glEnd(); <br> <br>    auxSwapBuffers(); <br>} <br> <br>void InitVList(void) <br>{ <br> <br>    vList[0].x = 0.0; <br>    vList[0].y = 0.0; <br>    vList[0].dX = 0.0; <br>    vList[0].dY = 0.0; <br>    vList[0].tX = 0.0; <br>    vList[0].tY = 0.0; <br> <br>    vList[1].x = (float)imageSizeX; <br>    vList[1].y = 0.0; <br>    vList[1].dX = 0.0; <br>    vList[1].dY = 0.0; <br>    vList[1].tX = 1.0; <br>    vList[1].tY = 0.0; <br> <br>    vList[2].x = (float)imageSizeX; <br>    vList[2].y = (float)imageSizeY; <br>    vList[2].dX = 0.0; <br>    vList[2].dY = 0.0; <br>    vList[2].tX = 1.0; <br>    vList[2].tY = 1.0; <br> <br>    vList[3].x = 0.0; <br>    vList[3].y = (float)imageSizeY; <br>    vList[3].dX = 0.0; <br>    vList[3].dY = 0.0; <br>    vList[3].tX = 0.0; <br>    vList[3].tY = 1.0; <br> <br>    vList[4].x = cList[0].x; <br>    vList[4].y = cList[0].y; <br>    vList[4].dX = (cList[1].x - cList[0].x) / STEPCOUNT; <br>    vList[4].dY = (cList[1].y - cList[0].y) / STEPCOUNT; <br>    vList[4].tX = cList[0].x / (float)imageSizeX; <br>    vList[4].tY = cList[0].y / (float)imageSizeY; <br>} <br> <br>void ScaleImage(int sizeX, int sizeY) <br>{ <br>    GLubyte *buf; <br> <br>    buf = (GLubyte *)malloc(3*sizeX*sizeY); <br>    gluScaleImage(GL_RGB, image-&gt;sizeX, image-&gt;sizeY, GL_UNSIGNED_BYTE, <br>                  image-&gt;data, sizeX, sizeY, GL_UNSIGNED_BYTE, buf); <br>    free(image-&gt;data); <br>    image-&gt;data = buf; <br>    image-&gt;sizeX = sizeX; <br>    image-&gt;sizeY = sizeY; <br>} <br> <br>void SetPoint(int x, int y) <br>{ <br> <br>    cList[cCount].x = (float)x; <br>    cList[cCount].y = (float)y; <br>    cCount++; <br>} <br> <br>void Stretch(void) <br>{ <br> <br>    glBegin(GL_TRIANGLES); <br>    glTexCoord2f(vList[0].tX, vList[0].tY); <br>    glVertex2f(vList[0].x, vList[0].y); <br>    glTexCoord2f(vList[1].tX, vList[1].tY); <br>    glVertex2f(vList[1].x, vList[1].y); <br>    glTexCoord2f(vList[4].tX, vList[4].tY); <br>    glVertex2f(vList[4].x, vList[4].y); <br>    glEnd(); <br> <br>    glBegin(GL_TRIANGLES); <br>    glTexCoord2f(vList[1].tX, vList[1].tY); <br>    glVertex2f(vList[1].x, vList[1].y); <br>    glTexCoord2f(vList[2].tX, vList[2].tY); <br>    glVertex2f(vList[2].x, vList[2].y); <br>    glTexCoord2f(vList[4].tX, vList[4].tY); <br>    glVertex2f(vList[4].x, vList[4].y); <br>    glEnd(); <br> <br>    glBegin(GL_TRIANGLES); <br>    glTexCoord2f(vList[2].tX, vList[2].tY); <br>    glVertex2f(vList[2].x, vList[2].y); <br>    glTexCoord2f(vList[3].tX, vList[3].tY); <br>    glVertex2f(vList[3].x, vList[3].y); <br>    glTexCoord2f(vList[4].tX, vList[4].tY); <br>    glVertex2f(vList[4].x, vList[4].y); <br>    glEnd(); <br> <br>    glBegin(GL_TRIANGLES); <br>    glTexCoord2f(vList[3].tX, vList[3].tY); <br>    glVertex2f(vList[3].x, vList[3].y); <br>    glTexCoord2f(vList[0].tX, vList[0].tY); <br>    glVertex2f(vList[0].x, vList[0].y); <br>    glTexCoord2f(vList[4].tX, vList[4].tY); <br>    glVertex2f(vList[4].x, vList[4].y); <br>    glEnd(); <br> <br>    auxSwapBuffers(); <br> <br>    if (++cStep &lt; STEPCOUNT) { <br>    vList[4].x += vList[4].dX; <br>    vList[4].y += vList[4].dY; <br>    } else { <br>    cIndex[0] = cIndex[1]; <br>    cIndex[1] = cIndex[1] + 1; <br>    if (cIndex[1] == cCount) { <br>        cIndex[1] = 0; <br>    } <br>    vList[4].dX = (cList[cIndex[1]].x - cList[cIndex[0]].x) / STEPCOUNT; <br>    vList[4].dY = (cList[cIndex[1]].y - cList[cIndex[0]].y) / STEPCOUNT; <br>    cStep = 0; <br>    } <br>} <br> <br>static void CALLBACK Key_SPACE(void) <br>{ <br>    if (cCount &gt; 1) { <br>        InitVList(); <br>        cIndex[0] = 0; <br>        cIndex[1] = 1; <br>        cStep = 0; <br>        glEnable(GL_TEXTURE_2D); <br>        op = OP_STRETCH; <br>    } <br>} <br> <br>static GLenum CALLBACK Mouse_left(AUX_EVENTREC *event) <br>{ <br>    GLint mouseX; <br>    GLint mouseY; <br> <br>    mouseX = event-&gt;data[AUX_MOUSEX]; <br>    mouseY = event-&gt;data[AUX_MOUSEY]; <br>    if (op == OP_STRETCH) { <br>    glDisable(GL_TEXTURE_2D); <br>    cCount = 0; <br>    op = OP_DRAWIMAGE; <br>    } else { <br>    SetPoint(mouseX, imageSizeY-mouseY); <br>    op = OP_DRAWPOINT; <br>    } <br>    return GL_TRUE; <br>} <br> <br>void CALLBACK Animate(void) <br>{ <br> <br>    switch (op) { <br>      case OP_STRETCH: <br>    Stretch(); <br>    break; <br>      case OP_DRAWPOINT: <br>    DrawPoint(); <br>    break; <br>      case OP_DRAWIMAGE: <br>    DrawImage(); <br>    break; <br>    } <br>} <br> <br>static GLenum Args(int argc, char **argv) <br>{ <br>    GLint i; <br> <br>    doubleBuffer = GL_FALSE; <br> <br> <br>    for (i = 1; i &lt; argc; i++) { <br>    if (strcmp(argv[i], "-sb") == 0) { <br>        doubleBuffer = GL_FALSE; <br>    } else if (strcmp(argv[i], "-db") == 0) { <br>        doubleBuffer = GL_TRUE; <br>    } else if (strcmp(argv[i], "-f") == 0) { <br>        if (i+1 &gt;= argc || argv[i+1][0] == '-') { <br>        //printf("-f (No file name).\n"); <br>        return GL_FALSE; <br>        } else { <br>        fileName = argv[++i]; <br>        } <br>    } else { <br>        //printf("%s (Bad option).\n", argv[i]); <br>        return GL_FALSE; <br>    } <br>    } <br>    return GL_TRUE; <br>} <br> <br>void main(int argc, char **argv) <br>{ <br>    GLenum type; <br> <br>    if (Args(argc, argv) == GL_FALSE) { <br>    auxQuit(); <br>    } <br> <br>    if (fileName == 0) { <br>    //printf("No image file.\n"); <br>    auxQuit(); <br>    } <br> <br>    image = auxRGBImageLoad(fileName); <br> <br>    imageSizeX = (int)pow(2.0, (float)((int)(log(image-&gt;sizeX)/log(2.0)))); <br>    imageSizeY = (int)pow(2.0, (float)((int)(log(image-&gt;sizeY)/log(2.0)))); <br> <br>    auxInitPosition(0, 0, imageSizeX, imageSizeY); <br> <br>    type = AUX_RGB; <br>    type |= (doubleBuffer) ? AUX_DOUBLE : AUX_SINGLE; <br> <br>    auxInitDisplayMode(type); <br> <br>    if (auxInitWindow("Stretch") == GL_FALSE) { <br>        auxQuit(); <br>    } <br> <br>    glViewport(0, 0, imageSizeX, imageSizeY); <br>    gluOrtho2D(0, imageSizeX, 0, imageSizeY); <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br> <br>    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); <br>    glPixelStorei(GL_PACK_ALIGNMENT, 1); <br> <br>    ScaleImage(imageSizeX, imageSizeY); <br> <br>    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); <br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); <br>    glTexImage2D(GL_TEXTURE_2D, 0, 3, image-&gt;sizeX, image-&gt;sizeY, 0, <br>                 GL_RGB, GL_UNSIGNED_BYTE, (unsigned char *)image-&gt;data); <br> <br>    cCount = 0; <br>    cIndex[0] = 0; <br>    cIndex[1] = 0; <br>    cStep = 0; <br>    op = OP_DRAWIMAGE; <br> <br>    auxKeyFunc(AUX_SPACE, Key_SPACE); <br>    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, Mouse_left); <br>    auxIdleFunc(Animate); <br>    auxMainLoop(NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
