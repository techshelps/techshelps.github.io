<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TSELECT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3670"></a>TSELECT.C</h2>
<pre><code>/* <br> * (c) Copyright 1993, Silicon Graphics, Inc. <br> *               1993-1995 Microsoft Corporation <br> * <br> * ALL RIGHTS RESERVED <br> * <br> * Please refer to OpenGL/readme.txt for additional information <br> * <br> */ <br> <br>#include "glos.h" <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br>#include &lt;gl\glaux.h&gt; <br> <br> <br>#define MAXOBJS 10000 <br>#define MAXSELECT 100 <br>#define MAXFEED 300 <br>#define SOLID 1 <br>#define LINE 2 <br>#define POINT 3 <br> <br>static void InitObjects(GLint num); <br>static void Init(void ); <br>static void CALLBACK Reshape(int width,int height); <br>static void Render(GLenum mode); <br>static GLint DoSelect(GLint x, GLint y); <br>static void RecolorTri(GLint h); <br>static void DeleteTri(GLint h); <br>static void GrowTri(GLint h); <br>static GLenum CALLBACK Mouse_left(struct _AUX_EVENTREC *event); <br>static GLenum CALLBACK Mouse_middle(struct _AUX_EVENTREC *event); <br>static GLenum CALLBACK Mouse_right(struct _AUX_EVENTREC *event); <br>static void CALLBACK Draw(void ); <br>static void DrawZoom(GLint x, GLint y); <br>static void DumpFeedbackVert(GLint *i, GLint n); <br>static void DrawFeedback(GLint n); <br>static void DoFeedback(void ); <br>static void CALLBACK Key_LEFT(void ); <br>static void CALLBACK Key_RIGHT(void ); <br>static void CALLBACK Key_Z(void ); <br>static void CALLBACK Key_z(void ); <br>static void CALLBACK Key_f(void ); <br>static void CALLBACK Key_d(void ); <br>static void CALLBACK Key_l(void ); <br> <br>GLint windW, windH; <br> <br>GLuint selectBuf[MAXSELECT]; <br>GLfloat feedBuf[MAXFEED]; <br>GLint vp[4]; <br>float zRotation = 90.0; <br>float zoom = 1.0; <br>GLint objectCount; <br>GLint numObjects; <br>struct object { <br>    float v1[2]; <br>    float v2[2]; <br>    float v3[2]; <br>    float color[3]; <br>} objects[MAXOBJS]; <br>GLenum linePoly = GL_FALSE; <br> <br> <br>static void InitObjects(GLint num) <br>{ <br>    GLint i; <br>    float x, y; <br> <br>    if (num &gt; MAXOBJS) { <br>    num = MAXOBJS; <br>    } <br>    if (num &lt; 1) { <br>    num = 1; <br>    } <br>    objectCount = num; <br> <br>    srand((unsigned int)time(NULL)); <br>    for (i = 0; i &lt; num; i++) { <br>    x = (rand() % 300) - 150; <br>    y = (rand() % 300) - 150; <br> <br>    objects[i].v1[0] = x + (rand() % 50) - 25; <br>    objects[i].v2[0] = x + (rand() % 50) - 25; <br>    objects[i].v3[0] = x + (rand() % 50) - 25; <br>    objects[i].v1[1] = y + (rand() % 50) - 25; <br>    objects[i].v2[1] = y + (rand() % 50) - 25; <br>    objects[i].v3[1] = y + (rand() % 50) - 25; <br>    objects[i].color[0] = ((rand() % 100) + 50) / 150.0; <br>    objects[i].color[1] = ((rand() % 100) + 50) / 150.0; <br>    objects[i].color[2] = ((rand() % 100) + 50) / 150.0; <br>    } <br>} <br> <br>static void Init(void) <br>{ <br> <br>    numObjects = 10; <br>    InitObjects(numObjects); <br>    glGetIntegerv(GL_VIEWPORT, vp); <br>} <br> <br>static void CALLBACK Reshape(int width, int height) <br>{ <br> <br>    windW = (GLint)width; <br>    windH = (GLint)height; <br>} <br> <br>static void Render(GLenum mode) <br>{ <br>    GLint i; <br> <br>    for (i = 0; i &lt; objectCount; i++) { <br>    if (mode == GL_SELECT) { <br>        glLoadName(i); <br>    } <br>    glColor3fv(objects[i].color); <br>    glBegin(GL_POLYGON); <br>        glVertex2fv(objects[i].v1); <br>        glVertex2fv(objects[i].v2); <br>        glVertex2fv(objects[i].v3); <br>    glEnd(); <br>    } <br>} <br> <br>static GLint DoSelect(GLint x, GLint y) <br>{ <br>    GLint hits; <br> <br>    glSelectBuffer(MAXSELECT, selectBuf); <br>    (void)glRenderMode(GL_SELECT); <br>    glInitNames(); <br>    glPushName((GLuint)~0); <br> <br>    glPushMatrix(); <br> <br>    glViewport(0, 0, windW, windH); <br>    glGetIntegerv(GL_VIEWPORT, vp); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluPickMatrix(x, windH-y, 4, 4, vp); <br>    gluOrtho2D(-175, 175, -175, 175); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br>    glClear(GL_COLOR_BUFFER_BIT); <br> <br>    glScalef(zoom, zoom, zoom); <br>    glRotatef(zRotation, 0, 0, 1); <br> <br>    Render(GL_SELECT); <br> <br>    glPopMatrix(); <br>     <br>    hits = glRenderMode(GL_RENDER);  <br>    if (hits &lt;= 0) { <br>    return -1; <br>    } <br> <br>    return selectBuf[(hits-1)*4+3]; <br>} <br> <br>static void RecolorTri(GLint h) <br>{ <br> <br>    objects[h].color[0] = ((rand() % 100) + 50) / 150.0; <br>    objects[h].color[1] = ((rand() % 100) + 50) / 150.0; <br>    objects[h].color[2] = ((rand() % 100) + 50) / 150.0; <br>} <br> <br>static void DeleteTri(GLint h) <br>{ <br> <br>    objects[h] = objects[objectCount-1]; <br>    objectCount--; <br>} <br> <br>static void GrowTri(GLint h) <br>{ <br>    float v[2]; <br>    float *oldV; <br>    GLint i; <br> <br>    v[0] = objects[h].v1[0] + objects[h].v2[0] + objects[h].v3[0]; <br>    v[1] = objects[h].v1[1] + objects[h].v2[1] + objects[h].v3[1]; <br>    v[0] /= 3; <br>    v[1] /= 3; <br> <br>    for (i = 0; i &lt; 3; i++) { <br>    switch (i) { <br>      case 0: <br>        oldV = objects[h].v1; <br>        break; <br>      case 1: <br>        oldV = objects[h].v2; <br>        break; <br>      case 2: <br>        oldV = objects[h].v3; <br>        break; <br>    } <br>    oldV[0] = 1.5 * (oldV[0] - v[0]) + v[0]; <br>    oldV[1] = 1.5 * (oldV[1] - v[1]) + v[1]; <br>    } <br>} <br> <br>static GLenum CALLBACK Mouse_left(AUX_EVENTREC *event) <br>{ <br>    GLint mouseX, mouseY; <br>    GLint hit; <br> <br>    mouseX = event-&gt;data[AUX_MOUSEX]; <br>    mouseY = event-&gt;data[AUX_MOUSEY]; <br>    hit = DoSelect((GLint)mouseX, (GLint)mouseY); <br>    if (hit != -1) { <br>        RecolorTri(hit); <br>    } <br>    return GL_FALSE; <br>} <br> <br>static GLenum CALLBACK Mouse_middle(AUX_EVENTREC *event) <br>{ <br>    GLint mouseX, mouseY; <br>    GLint hit; <br> <br>    mouseX = event-&gt;data[AUX_MOUSEX]; <br>    mouseY = event-&gt;data[AUX_MOUSEY]; <br>    hit = DoSelect((GLint)mouseX, (GLint)mouseY); <br>    if (hit != -1) { <br>        GrowTri(hit); <br>    } <br>    return GL_FALSE; <br>} <br> <br>static GLenum CALLBACK Mouse_right(AUX_EVENTREC *event) <br>{ <br>    GLint mouseX, mouseY; <br>    GLint hit; <br> <br>    mouseX = event-&gt;data[AUX_MOUSEX]; <br>    mouseY = event-&gt;data[AUX_MOUSEY]; <br>    hit = DoSelect((GLint)mouseX, (GLint)mouseY); <br>    if (hit != -1) { <br>        DeleteTri(hit); <br>    } <br>    return GL_FALSE; <br>} <br> <br>static void CALLBACK Draw(void) <br>{ <br> <br>    glPushMatrix(); <br> <br>    glViewport(0, 0, windW, windH); <br>    glGetIntegerv(GL_VIEWPORT, vp); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluOrtho2D(-175, 175, -175, 175); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br>    glClear(GL_COLOR_BUFFER_BIT); <br> <br>    glScalef(zoom, zoom, zoom); <br>    glRotatef(zRotation, 0, 0, 1); <br> <br>    Render(GL_RENDER); <br> <br>    glPopMatrix(); <br> <br>    glFlush(); <br>} <br> <br>static void DrawZoom(GLint x, GLint y) <br>{ <br> <br>    glPushMatrix(); <br> <br>    glViewport(0, 0, windW, windH); <br>    glGetIntegerv(GL_VIEWPORT, vp); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluPickMatrix(x, windH-y, 4, 4, vp); <br>    gluOrtho2D(-175, 175, -175, 175); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br>    glClear(GL_COLOR_BUFFER_BIT); <br> <br>    glScalef(zoom, zoom, zoom); <br>    glRotatef(zRotation, 0, 0, 1); <br> <br>    Render(GL_RENDER); <br> <br>    glPopMatrix(); <br>} <br> <br>static void DumpFeedbackVert(GLint *i, GLint n) <br>{ <br>    GLint index; <br> <br>    index = *i; <br>    if (index+7 &gt; n) { <br>    *i = n; <br>    //printf("  ???\n"); <br>    return; <br>    } <br>/* <br>    printf("  (%g %g %g), color = (%4.2f %4.2f %4.2f)\n", <br>       feedBuf[index], <br>       feedBuf[index+1], <br>       feedBuf[index+2], <br>       feedBuf[index+3], <br>       feedBuf[index+4], <br>       feedBuf[index+5]); <br>*/ <br>    index += 7; <br>    *i = index; <br>} <br> <br>static void DrawFeedback(GLint n) <br>{ <br>    GLint i; <br>    GLint verts; <br> <br>    //printf("Feedback results (%d floats):\n", n); <br>    for (i = 0; i &lt; n; i++) { <br>    switch ((GLint)feedBuf[i]) { <br>      case GL_POLYGON_TOKEN: <br>        //printf("Polygon"); <br>        i++; <br>        if (i &lt; n) { <br>        verts = (GLint)feedBuf[i]; <br>        i++; <br>        //printf(": %d vertices", verts); <br>        } else { <br>        verts = 0; <br>        } <br>        //printf("\n"); <br>        while (verts) { <br>        DumpFeedbackVert(&amp;i, n); <br>        verts--; <br>        } <br>        i--; <br>        break; <br>      case GL_LINE_TOKEN: <br>        //printf("Line:\n"); <br>        i++; <br>        DumpFeedbackVert(&amp;i, n); <br>        DumpFeedbackVert(&amp;i, n); <br>        i--; <br>        break; <br>      case GL_LINE_RESET_TOKEN: <br>        //printf("Line Reset:\n"); <br>        i++; <br>        DumpFeedbackVert(&amp;i, n); <br>        DumpFeedbackVert(&amp;i, n); <br>        i--; <br>        break; <br>      default: <br>        //printf("%9.2f\n", feedBuf[i]); <br>        break; <br>    } <br>    } <br>/* <br>    if (i == MAXFEED) { <br>    printf("...\n"); <br>    } <br>    printf("\n"); <br>*/ <br>} <br> <br>static void DoFeedback(void)  <br>{ <br>    GLint x; <br> <br>    glFeedbackBuffer(MAXFEED, GL_3D_COLOR, feedBuf); <br>    (void)glRenderMode(GL_FEEDBACK); <br> <br>    glPushMatrix(); <br> <br>    glViewport(0, 0, windW, windH); <br>    glGetIntegerv(GL_VIEWPORT, vp); <br> <br>    glMatrixMode(GL_PROJECTION); <br>    glLoadIdentity(); <br>    gluOrtho2D(-175, 175, -175, 175); <br>    glMatrixMode(GL_MODELVIEW); <br> <br>    glClearColor(0.0, 0.0, 0.0, 0.0); <br>    glClear(GL_COLOR_BUFFER_BIT); <br> <br>    glScalef(zoom, zoom, zoom); <br>    glRotatef(zRotation, 0, 0, 1); <br> <br>    Render(GL_FEEDBACK); <br> <br>    glPopMatrix(); <br>     <br>    x = glRenderMode(GL_RENDER);  <br>    if (x == -1) { <br>    x = MAXFEED; <br>    } <br> <br>    DrawFeedback((GLint)x); <br>} <br> <br>static void CALLBACK Key_LEFT(void) <br>{ <br>    zRotation += 0.5; <br>} <br> <br>static void CALLBACK Key_RIGHT(void) <br>{ <br>    zRotation -= 0.5; <br>} <br> <br>static void CALLBACK Key_Z(void) <br>{ <br>    zoom /= 0.75; <br>} <br> <br>static void CALLBACK Key_z(void) <br>{ <br>    zoom *= 0.75; <br>} <br> <br>static void CALLBACK Key_f(void) <br>{ <br>    DoFeedback(); <br>} <br> <br>static void CALLBACK Key_d(void) <br>{ <br>    GLint mouseX, mouseY; <br> <br>    auxGetMouseLoc(&amp;mouseX, &amp;mouseY); <br>    DrawZoom((GLint)mouseX, (GLint)mouseY); <br>} <br> <br>static void CALLBACK Key_l(void) <br>{ <br>    linePoly = !linePoly; <br>    if (linePoly) { <br>        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); <br>    } else { <br>        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); <br>    } <br>} <br> <br> <br>void main(int argc, char **argv) <br>{ <br>    GLenum type; <br> <br> <br>    windW = 300; <br>    windH = 300; <br>    auxInitPosition(0, 0, windW, windH); <br> <br>    type = AUX_RGB | AUX_SINGLE; <br> <br>    auxInitDisplayMode(type); <br> <br>    if (auxInitWindow("Select Test") == GL_FALSE) { <br>    auxQuit(); <br>    } <br> <br>    Init(); <br> <br>    auxExposeFunc((AUXEXPOSEPROC)Reshape); <br>    auxReshapeFunc((AUXRESHAPEPROC)Reshape); <br>    auxKeyFunc(AUX_LEFT, Key_LEFT); <br>    auxKeyFunc(AUX_RIGHT, Key_RIGHT); <br>    auxKeyFunc(AUX_Z, Key_Z); <br>    auxKeyFunc(AUX_z, Key_z); <br>    auxKeyFunc(AUX_f, Key_f); <br>    auxKeyFunc(AUX_d, Key_d); <br>    auxKeyFunc(AUX_l, Key_l); <br>    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, Mouse_left); <br>    auxMouseFunc(AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, Mouse_middle); <br>    auxMouseFunc(AUX_RIGHTBUTTON, AUX_MOUSEDOWN, Mouse_right); <br>    auxMainLoop(Draw); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
