<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFEDIT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3425"></a>MFEDIT.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: mfedit.c <br>* <br>* Main module for the Enhanced Metafile Editor <br>*       contains everything <br>* <br>* Copyright 1992 - 1998 Microsoft Corporation <br>* <br>* The Enhanced Metafile Editor serves to demonstrate the enhanced metafile <br>* APIs in Windows NT. <br>* <br>* The Editor provides the following functions: <br>*       1.  Playback and recording of GDI calls <br>*       2.  Embedding bitmap and enhanced metafile into another enhanced <br>*           metafile with transformation <br>*       3.  Hit-testing against enhanced metafile records <br>*       4.  Random access playback <br>*       5.  Playback metafile records one-by-one <br>*       6.  Selective recording of existing enhanced metafile records into <br>*           a new enhanced metafile <br>*       7.  drawing with pen, text, bezier, line, ellipse, rectangle and <br>*           embedding bitmap and enhanced metafile tools <br>* <br>* <br>\**************************************************************************/ <br>#include "precomp.h" <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* FUNCTION:  PolyDraw95(HDC, LPPOINT, LPBYTE, int) <br>* <br>* PURPOSE:   Draws the points returned from a call to GetPath() <br>*            to an HDC <br>* <br>* NOTES:     This function is similar to the Windows NT PolyDraw <br>*            function, which draws a set of line segments and Bezier <br>*            curves. Because PolyDraw is not supported in Windows 95 <br>*            this PolyDraw95 function is used instead. <br>* <br>\**************************************************************************/ <br> <br>BOOL PolyDraw95(HDC  hdc,               // handle of a device context <br>                CONST LPPOINT lppt,     // array of points <br>                CONST LPBYTE lpbTypes,  // line and curve identifiers <br>                int  cCount)            // count of points <br>{ <br>  int i; <br> <br>  for (i=0; i&lt;cCount; i++) <br>    switch (lpbTypes[i]) { <br>      case PT_MOVETO : <br>         MoveToEx(hdc, lppt[i].x, lppt[i].y, NULL); <br>         break; <br> <br>      case PT_LINETO | PT_CLOSEFIGURE: <br>      case PT_LINETO : <br>         LineTo(hdc, lppt[i].x, lppt[i].y); <br>         break; <br> <br>      case PT_BEZIERTO | PT_CLOSEFIGURE: <br>      case PT_BEZIERTO : <br>        PolyBezierTo(hdc, &amp;lppt[i], 3); <br>       i+=2; <br>         break; <br>    } <br> <br>   return TRUE; <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* vErrOut <br>* <br>* Effects:  Put up a message box with the error string and error code <br>*           returned. <br>* <br>\**************************************************************************/ <br> <br>void vErrOut(char errstring[MAX_ERR_STRING]) <br>{ <br>    DWORD   dwError, dwThrdId; <br>    char    str[MAX_ERR_STRING]; <br> <br> <br>    if (gbDebug) { <br>        dwError = GetLastError(); <br>        dwThrdId = GetCurrentThreadId(); <br>        wsprintf((LPSTR) str, "%s, tid = %lx, Error code = %d\n", <br>                 errstring, dwThrdId, dwError); <br>        OutputDebugString((LPCTSTR)str); <br>        //MessageBox(GetFocus(), (LPSTR)str, "MfEdit Error", MB_OK); <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* FlushPalette <br>* <br>\**************************************************************************/ <br> <br>static void <br>FlushPalette(HDC hdc, int nColors) <br>{ <br>    LOGPALETTE *pPal; <br>    HPALETTE hpal, hpalOld; <br>    int i; <br> <br>    if (nColors == 256) <br>    { <br>        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT, <br>                                         sizeof(LOGPALETTE) + (nColors-1) * sizeof(PALETTEENTRY)); <br> <br>        if (pPal) <br>        { <br>    pPal-&gt;palVersion = 0x300; <br>    pPal-&gt;palNumEntries = nColors; <br> <br>        // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every thing <br>        // into the palette.  Colors are already black because we zero initialized <br>        // during memory allocation. <br> <br>            for (i = 0; i &lt; nColors; i++) <br>            { <br>                pPal-&gt;palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED; <br>            } <br> <br>            hpal = CreatePalette(pPal); <br>            LocalFree(pPal); <br> <br>            hpalOld = SelectPalette(hdc, hpal, FALSE); <br>            RealizePalette(hdc); <br> <br>            SelectPalette(hdc, hpalOld, FALSE); <br>            DeleteObject(hpal); <br>        } <br>    } <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* UpdateStaticMapping <br>* <br>\**************************************************************************/ <br> <br>static void <br>UpdateStaticMapping(PALETTEENTRY *pe332Palette) <br>{ <br>    HPALETTE hpalStock; <br>    int iStatic, i332; <br>    int iMinDist, iDist; <br>    int iDelta; <br>    int iMinEntry; <br>    PALETTEENTRY *peStatic, *pe332; <br> <br>    hpalStock = GetStockObject(DEFAULT_PALETTE); <br> <br>    // The system should always have one of these <br>    //TKASSERT(hpalStock != NULL); <br>    // Make sure there's the correct number of entries <br>    //TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS); <br> <br>    // Get the current static colors <br>    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry); <br> <br>    // Zero the flags in the static colors because they are used later <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        peStatic-&gt;peFlags = 0; <br>        peStatic++; <br>    } <br> <br>    // Zero the flags in the incoming palette because they are used later <br>    pe332 = pe332Palette; <br>    for (i332 = 0; i332 &lt; 256; i332++) <br>    { <br>        pe332-&gt;peFlags = 0; <br>        pe332++; <br>    } <br> <br>    // Try to match each static color exactly <br>    // This saves time by avoiding the least-squares match for each <br>    // exact match <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        pe332 = pe332Palette; <br>        for (i332 = 0; i332 &lt; 256; i332++) <br>        { <br>            if (peStatic-&gt;peRed == pe332-&gt;peRed &amp;&amp; <br>                peStatic-&gt;peGreen == pe332-&gt;peGreen &amp;&amp; <br>                peStatic-&gt;peBlue == pe332-&gt;peBlue) <br>            { <br>                //TKASSERT(pe332-&gt;peFlags != COLOR_USED); <br>                 <br>                peStatic-&gt;peFlags = EXACT_MATCH; <br>                pe332-&gt;peFlags = COLOR_USED; <br>                aiDefaultOverride[iStatic] = i332; <br>                 <br>                break; <br>            } <br> <br>            pe332++; <br>        } <br> <br>        peStatic++; <br>    } <br>     <br>    // Match each static color as closely as possible to an entry <br>    // in the 332 palette by minimized the square of the distance <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        // Skip colors already matched exactly <br>        if (peStatic-&gt;peFlags == EXACT_MATCH) <br>        { <br>            peStatic++; <br>            continue; <br>        } <br>         <br>        iMinDist = MAX_COL_DIST+1; <br>#if DBG <br>        iMinEntry = -1; <br>#endif <br> <br>        pe332 = pe332Palette; <br>        for (i332 = 0; i332 &lt; 256; i332++) <br>        { <br>            // Skip colors already used <br>            if (pe332-&gt;peFlags == COLOR_USED) <br>            { <br>                pe332++; <br>                continue; <br>            } <br>             <br>            // Compute Euclidean distance squared <br>            iDelta = pe332-&gt;peRed-peStatic-&gt;peRed; <br>            iDist = iDelta*iDelta; <br>            iDelta = pe332-&gt;peGreen-peStatic-&gt;peGreen; <br>            iDist += iDelta*iDelta; <br>            iDelta = pe332-&gt;peBlue-peStatic-&gt;peBlue; <br>            iDist += iDelta*iDelta; <br> <br>            if (iDist &lt; iMinDist) <br>            { <br>                iMinDist = iDist; <br>                iMinEntry = i332; <br>            } <br> <br>            pe332++; <br>        } <br> <br>        //TKASSERT(iMinEntry != -1); <br> <br>        // Remember the best match <br>        aiDefaultOverride[iStatic] = iMinEntry; <br>        pe332Palette[iMinEntry].peFlags = COLOR_USED; <br>         <br>        peStatic++; <br>    } <br> <br>    // Zero the flags in the static colors because they may have been <br>    // set.  We want them to be zero so the colors can be remapped <br>    peStatic = apeDefaultPalEntry; <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        peStatic-&gt;peFlags = 0; <br>        peStatic++; <br>    } <br> <br>    // Reset the 332 flags because we may have set them <br>    pe332 = pe332Palette; <br>    for (i332 = 0; i332 &lt; 256; i332++) <br>    { <br>        pe332-&gt;peFlags = PC_NOCOLLAPSE; <br>        pe332++; <br>    } <br> <br>#if 0 <br>    for (iStatic = 0; iStatic &lt; STATIC_COLORS; iStatic++) <br>    { <br>        PrintMessage("Static color %2d maps to %d\n", <br>                     iStatic, aiDefaultOverride[iStatic]); <br>    } <br>#endif <br>} <br> <br>#define SwapPalE(i,j) { \ <br>    PALETTEENTRY palE; \ <br>    palE = pPal-&gt;palPalEntry[i]; \ <br>    pPal-&gt;palPalEntry[i] = pPal-&gt;palPalEntry[j]; \ <br>    pPal-&gt;palPalEntry[j] = palE; } <br> <br> <br>/**************************************************************************\ <br>* <br>* SaveStaticEntries <br>* <br>\**************************************************************************/ <br> <br>VOID SaveStaticEntries(HDC hDC) <br>{ <br>    int i; <br> <br>    if (gbSystemColorsInUse) { <br>        for (i = COLOR_SCROLLBAR; i &lt;= COLOR_BTNHIGHLIGHT; i++) <br>            gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i); <br> <br>        gbStaticSaved = TRUE; <br>    } <br>} <br> <br>/**************************************************************************\ <br>* <br>* UseStaticEntries <br>* <br>\**************************************************************************/ <br> <br>static VOID UseStaticEntries(HDC hdc) <br>{ <br>    SetSysColors(NUM_STATIC_COLORS, gaiStaticIndex, gacrBlackAndWhite); <br>    gbSystemColorsInUse = TRUE; <br> <br>    PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0); <br>} <br> <br>/**************************************************************************\ <br>* <br>* hCreateRGBPalette <br>* <br>\**************************************************************************/ <br> <br>HPALETTE hCreateRGBPalette(HDC hDC, int index) <br>{ <br>    PIXELFORMATDESCRIPTOR   pfd; <br>    PLOGPALETTE             pLogPal, pPal; <br>    int                     nClr, i, n; <br>    HPALETTE                hPal; <br>    BOOL                    bUseStaticClr; <br> <br> <br>    if (DescribePixelFormat(hDC, index, sizeof(PIXELFORMATDESCRIPTOR), &amp;pfd) == 0) { <br>        return (HPALETTE)NULL; <br>    } <br> <br>    bUseStaticClr = pfd.dwFlags &amp; PFD_NEED_SYSTEM_PALETTE; <br> <br>    if (pfd.dwFlags &amp; PFD_NEED_PALETTE) { <br>        nClr = 1 &lt;&lt; pfd.cColorBits; <br> <br>        if ((pLogPal = (PLOGPALETTE) LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>                        (nClr-1) * sizeof(PALETTEENTRY))) != NULL) { <br> <br>            pLogPal-&gt;palVersion = 0x300; <br>            pLogPal-&gt;palNumEntries = nClr; <br> <br>            for (i = 0; i &lt; nClr; i++) { <br>                pLogPal-&gt;palPalEntry[i].peRed   = <br>    ComponentFromIndex(i, pfd.cRedBits, pfd.cRedShift); <br>                pLogPal-&gt;palPalEntry[i].peGreen = <br>    ComponentFromIndex(i, pfd.cGreenBits, pfd.cGreenShift); <br>                pLogPal-&gt;palPalEntry[i].peBlue  = <br>    ComponentFromIndex(i, pfd.cBlueBits, pfd.cBlueShift); <br>                pLogPal-&gt;palPalEntry[i].peFlags = PC_NOCOLLAPSE; <br>            } <br> <br>            if ( nClr == 256) { <br>                if (bUseStaticClr) { <br>                    pLogPal-&gt;palPalEntry[0].peFlags = 0; <br>                    pLogPal-&gt;palPalEntry[255].peFlags = 0; <br> <br>                    SaveStaticEntries(hDC); <br>                    SetSystemPaletteUse(hDC, SYSPAL_NOSTATIC); <br>                } else { <br>                    if ((pfd.cRedBits   == 3) &amp;&amp; (pfd.cRedShift   == 0) &amp;&amp; <br>                        (pfd.cGreenBits == 3) &amp;&amp; (pfd.cGreenShift == 3) &amp;&amp; <br>                        (pfd.cBlueBits  == 2) &amp;&amp; (pfd.cBlueShift  == 6)) { <br>                        UpdateStaticMapping(pLogPal-&gt;palPalEntry); <br> <br>                        for (i = 0; i &lt; 20; i++) { <br>                            pLogPal-&gt;palPalEntry[aiDefaultOverride[i]] = <br>                                apeDefaultPalEntry[i]; <br>                        } <br> <br>                    } <br>                } <br>            } <br> <br>            FlushPalette(hDC, nClr); <br> <br>            hPal = CreatePalette(pLogPal); <br>            LocalFree(pLogPal); <br>            SelectPalette(hDC, hPal, FALSE); <br>            RealizePalette(hDC); <br> <br> <br>            if (bUseStaticClr) <br>                UseStaticEntries(hDC); <br> <br>        } <br>    } <br>    // set up logical indices for CI mode <br>    else if( pfd.iPixelType == PFD_TYPE_COLORINDEX ) { <br>        if (pfd.cColorBits == 4) { <br> <br>            // for 4-bit, create a logical palette with 16 entries <br> <br>            n = 16; <br>            pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>                    (n-1) * sizeof(PALETTEENTRY)); <br>            pPal-&gt;palVersion = 0x300; <br>            pPal-&gt;palNumEntries = n; <br> <br>            for( i = 0; i &lt; 8; i ++) { <br>                pPal-&gt;palPalEntry[i] = apeDefaultPalEntry[i]; <br>            } <br>            for (i = 8; i &lt; 16; i++) { <br>                pPal-&gt;palPalEntry[i] = apeDefaultPalEntry[i+4]; <br>            } <br> <br>            // conform expects indices 0..3 to be BLACK,RED,GREEN,BLUE, so <br>            //  we rearrange the table for now. <br> <br>            SwapPalE(1,9) <br>            SwapPalE(2,10) <br>            SwapPalE(3,12) <br> <br>        } else if (pfd.cColorBits == 8) { <br> <br>            // for 8-bit, create a logical palette with 256 entries, making <br>            // sure that the 20 system colors exist in the palette <br> <br>            n = 256; <br>            pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>                    (n-1) * sizeof(PALETTEENTRY)); <br>            pPal-&gt;palVersion = 0x300; <br>            pPal-&gt;palNumEntries = n; <br> <br>            hPal = GetStockObject (DEFAULT_PALETTE); <br> <br>            // start by copying default palette into new one <br> <br>            GetPaletteEntries( hPal, 0, 20, pPal-&gt;palPalEntry); <br> <br>            // conform expects indices 0..3 to be BLACK,RED,GREEN,BLUE, so <br>            // we rearrange the table for now. <br> <br>            SwapPalE(1,13) <br>            SwapPalE(2,14) <br>            SwapPalE(3,16) <br> <br>            for( i = 20; i &lt; n; i ++) { <br>                pPal-&gt;palPalEntry[i].peRed   = (BYTE) (i - 1); <br>                pPal-&gt;palPalEntry[i].peGreen = (BYTE) (i - 2); <br>                pPal-&gt;palPalEntry[i].peBlue  = (BYTE) (i - 3); <br>                pPal-&gt;palPalEntry[i].peFlags = (BYTE) 0; <br>            } <br> <br> <br>            // If we are taking possession of the system colors, <br>            // must guarantee that 0 and 255 are black and white <br>            // (respectively), so that they can remap to the <br>            // remaining two static colors.  All other entries must <br>            // be marked as PC_NOCOLLAPSE. <br> <br>            if ( gbUseStaticColors ) <br>            { <br>                pPal-&gt;palPalEntry[0].peRed = <br>                pPal-&gt;palPalEntry[0].peGreen = <br>                pPal-&gt;palPalEntry[0].peBlue = 0x00; <br> <br>                pPal-&gt;palPalEntry[255].peRed = <br>                pPal-&gt;palPalEntry[255].peGreen = <br>                pPal-&gt;palPalEntry[255].peBlue = 0xFF; <br> <br>                pPal-&gt;palPalEntry[0].peFlags = <br>                pPal-&gt;palPalEntry[255].peFlags = 0; <br> <br>                for ( i = 1 ; i &lt; 255 ; i++ ) <br>                { <br>                    pPal-&gt;palPalEntry[i].peFlags = PC_NOCOLLAPSE; <br> <br>                // This is a workaround for a GDI palette "feature".  If <br>                // any of the static colors are repeated in the palette, <br>                // those colors will map to the first occurance.  So, for <br>                // our case where there are only two static colors (black <br>                // and white), if a white color appears anywhere in the <br>                // palette other than in the last  entry, the static white <br>                // will remap to the first white.  This destroys the nice <br>                // one-to-one mapping we are trying to achieve. <br>                // <br>                // There are two ways to workaround this.  The first is to <br>                // simply not allow a pure white anywhere but in the last <br>                // entry.  Such requests are replaced with an attenuated <br>                // white of (0xFE, 0xFE, 0xFE). <br>                // <br>                // The other way is to mark these extra whites with <br>                // PC_RESERVED which will cause GDI to skip these entries <br>                // when mapping colors.  This way the app gets the actual <br>                // colors requested, but can have side effects on other <br>                // apps. <br> <br>                    if ( pPal-&gt;palPalEntry[i].peRed   == 0xFF &amp;&amp; <br>                         pPal-&gt;palPalEntry[i].peGreen == 0xFF &amp;&amp; <br>                         pPal-&gt;palPalEntry[i].peBlue  == 0xFF ) <br>                    { <br>                        pPal-&gt;palPalEntry[i].peFlags |= PC_RESERVED; <br>                    } <br>                } <br> <br>                SaveStaticEntries(hDC); <br>                SetSystemPaletteUse(hDC, SYSPAL_NOSTATIC); <br>            } <br> <br>        } else { <br>            // for pixel formats &gt; 8 bits deep, create a logical palette with <br>            // 4096 entries <br> <br>            n = 4096; <br>            pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) + <br>                    (n-1) * sizeof(PALETTEENTRY)); <br>            pPal-&gt;palVersion = 0x300; <br>            pPal-&gt;palNumEntries = n; <br> <br>            for( i = 0; i &lt; n; i ++) { <br>                pPal-&gt;palPalEntry[i].peRed   = (BYTE) ((i &amp; 0x000f) &lt;&lt; 4); <br>                pPal-&gt;palPalEntry[i].peGreen = (BYTE) (i &amp; 0x00f0); <br>                pPal-&gt;palPalEntry[i].peBlue  = (BYTE) ((i &amp; 0x0f00) &gt;&gt; 4); <br>                pPal-&gt;palPalEntry[i].peFlags = (BYTE) 0; <br>            } <br> <br>            // conform expects indices 0..3 to be BLACK,RED,GREEN,BLUE, so <br>            //  we rearrange the table for now. <br> <br>            SwapPalE(1,0xf) <br>            SwapPalE(2,0xf0) <br>            SwapPalE(3,0xf00) <br>        } <br> <br>        hPal = CreatePalette(pPal); <br>        LocalFree(pPal); <br> <br> <br>        FlushPalette(hDC, n); <br> <br>        SelectPalette(hDC, hPal, FALSE); <br>        n = RealizePalette(hDC); <br> <br>        if ( gbUseStaticColors ) <br>            UseStaticEntries(hDC); <br>    } <br> <br>    return hPal; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bSetupRC <br>* <br>* Effects: Sets up the OpenGL rendering context <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>#ifdef OPENGL_EMF <br>BOOL bSetupRC(HDC hDC, PIXELFORMATDESCRIPTOR *ppfdIn) <br>{ <br>    PIXELFORMATDESCRIPTOR   pfd, *ppfd; <br>    INT                     iPfmt; <br>    BOOL                    bRet=FALSE; <br>    HPALETTE                hPal=(HPALETTE)NULL; <br>    HGLRC                   hRC; <br>    char                    text[128]; <br> <br>    if ((ppfdIn != (PIXELFORMATDESCRIPTOR*)NULL) &amp;&amp; gbUseMfPFD) { <br>        ppfd = ppfdIn; <br>    } else { <br>        ppfd = &amp;pfd; <br>        pfd.nSize   = sizeof(PIXELFORMATDESCRIPTOR); <br>        pfd.nVersion= 1; <br>        pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL; <br>        pfd.iPixelType  = PFD_TYPE_RGBA; <br>        pfd.cColorBits  = 24; <br>        pfd.cRedBits    = <br>        pfd.cRedShift   = <br>        pfd.cGreenBits  = <br>        pfd.cGreenShift = <br>        pfd.cBlueBits   = <br>        pfd.cBlueShift  = <br>        pfd.cAlphaBits  = <br>        pfd.cAlphaShift = 0; <br>        pfd.cAccumBits  = 24; <br>        pfd.cAccumRedBits   = <br>        pfd.cAccumGreenBits = <br>        pfd.cAccumBlueBits  = <br>        pfd.cAccumAlphaBits = 0; <br>        pfd.cDepthBits  = 24; <br>        pfd.cStencilBits = 24; <br>        pfd.cAuxBuffers = <br>        pfd.iLayerType  = <br>        pfd.bReserved   = 0; <br>        pfd.dwLayerMask = PFD_MAIN_PLANE; <br>        pfd.dwVisibleMask = 0; <br>        pfd.dwDamageMask = 0; <br>    } <br> <br>    if ((iPfmt = ChoosePixelFormat(hDC, ppfd)) != 0) { <br>        bRet = SetPixelFormat(hDC, iPfmt, ppfd); <br> <br>        gbDB = (ppfd-&gt;dwFlags &amp; PFD_DOUBLEBUFFER) ? TRUE : FALSE; <br> <br>        if ((hPal = hCreateRGBPalette(hDC, iPfmt)) != (HPALETTE)NULL) { <br>            SelectPalette(hDC, hPal, FALSE); <br>            RealizePalette(hDC); <br>            bRet = bRet &amp;&amp; TRUE; <br>        } else { <br>            bRet = FALSE; <br>        } <br> <br>        hRC = wglCreateContext(hDC); <br>        wglMakeCurrent(hDC, hRC); <br> <br>        wsprintf(text, "bSetupRC: hDC=%lx, hRC=%lx", hDC, hRC); <br>        vErrOut(text); <br> <br>    } <br>    return bRet; <br>} <br> <br>/**************************************************************************\ <br>* <br>* bSetRC2MatchEmfRC <br>* <br>* Effects:  If the bOpenGL flag is not set in the metafile header, <br>*           return FALSE. <br>* <br>*           If the bOpenGL flag is set, retrieve the pfd from the enhanced <br>*           metafile, if exists.  Set the pixel format with the retrieved <br>*           pfd on the hDC.  If the pfd is not recorded, let bSetupRC pick <br>*           the pfd. <br>* <br>*           If ppfd is not null, copy the pfd in the metafile record, <br>*           to the ppfd.  If ppfd-&gt;nSize == 0, that means the pfd is not <br>*           found in the metafile record. <br>* <br>* Warnings: <br>* <br>* History: <br>*  05-May-1996 <br>* Wrote it. <br>\**************************************************************************/ <br> <br>BOOL bSetRC2MatchEmfRC(HDC                      hDC, <br>                       ENHMETAHEADER            EnhMetaHdr, <br>                       HENHMETAFILE             hEnhMf, <br>                       PIXELFORMATDESCRIPTOR    *ppfdIn) <br>{ <br>    BOOL                    bHasPFD = FALSE, bRCSet = FALSE; <br>    char                    text[128]; <br>    PIXELFORMATDESCRIPTOR   pfd; <br> <br>    if (EnhMetaHdr.bOpenGL) { <br> <br>        if (gpfnGetEnhMetaFilePixelFormat != (PROC)NULL) { <br> <br>            bHasPFD = ((gpfnGetEnhMetaFilePixelFormat)(hEnhMf, <br>                                      sizeof(PIXELFORMATDESCRIPTOR), <br>                                      &amp;pfd) == 0) ? FALSE : TRUE; <br> <br>            bRCSet = bSetupRC(hDC, (bHasPFD ? &amp;pfd : NULL)); <br> <br>            wsprintf(text, <br>                     "bSetRC2MatchEmfRC: bRCSet=%ld, bHasPFD=%ld", <br>                     bRCSet, bHasPFD); <br>            vErrOut(text); <br> <br>        } else { <br>            vErrOut("bSetRC2MatchEmfRC: gpfnGetEnhMetaFilePixelFormat is NULL"); <br>        } <br> <br>    } else { <br>        vErrOut("bSetRC2MatchEmfRC: EnhMetaHdr.bOpenGL is FALSE"); <br>    } <br> <br>    if (ppfdIn != (PIXELFORMATDESCRIPTOR*)NULL) { <br>        if (bHasPFD) { <br>            memcpy(ppfdIn, &amp;pfd, sizeof(PIXELFORMATDESCRIPTOR)); <br>        } else { <br>            ppfdIn-&gt;nSize = 0; <br>        } <br>    } <br> <br>    return bRCSet; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bCleanUpRC <br>* <br>* Effects:  Cleans up the OpenGL rendering context <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bCleanUpRC(VOID) <br>{ <br>    HGLRC       hRC; <br>    HDC         hDC; <br>    char        text[128]; <br> <br>    hRC = wglGetCurrentContext(); <br>    hDC = wglGetCurrentDC(); <br> <br>    wsprintf(text, "bCleanUpRC: hDC=%lx, hRC=%lx", hDC, hRC); <br>    vErrOut(text); <br> <br>    wglMakeCurrent(hDC, NULL); <br>    wglDeleteContext(hRC); <br>    return TRUE; <br> <br>} <br> <br>#else <br>BOOL bSetupRC(HDC hDC, PIXELFORMATDESCRIPTOR *ppfdIn) <br>{ <br>    return TRUE; <br>} <br> <br>BOOL bSetRC2MatchEmfRC(HDC                      hDC, <br>                       ENHMETAHEADER            EnhMetaHdr, <br>                       HENHMETAFILE             hEnhMf, <br>                       PIXELFORMATDESCRIPTOR    *ppfd) <br>{ <br>    return TRUE; <br>} <br> <br>BOOL bCleanUpRC(VOID) <br>{ <br>    return TRUE; <br>} <br>#endif <br> <br>/**************************************************************************\ <br>* <br>* WinMain <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>* History: <br>*  06-May-1996  Retrieve the proc addr for GetEnhMetaFilePixelFormat. <br>* Wrote it. <br>\**************************************************************************/ <br> <br>int WINAPI WinMain( <br>           HINSTANCE hInstance, <br>           HINSTANCE hPrevInstance, <br>           LPSTR lpCmdLine, <br>           int nShowCmd) <br>{ <br>    MSG      msg; <br>    HANDLE   hAccel; <br>    HMODULE  hMod; <br> <br>    ghModule = GetModuleHandle(NULL); <br> <br>// <br>// GDI32 may not support the OpenGL enhanced metafile (Win95 doesn't), in <br>// which case, the entry point doesn't exist, so we will do a GetProcAddress <br>// instead. <br>// <br>    hMod = LoadLibrary("GDI32.DLL"); <br>    if (hMod != (HMODULE)NULL) { <br> <br>        gpfnGetEnhMetaFilePixelFormat = <br>                GetProcAddress(hMod, "GetEnhMetaFilePixelFormat"); <br> <br>        if (gpfnGetEnhMetaFilePixelFormat == (PROC)NULL) <br>            vErrOut("Main: GetProcAddress(GetEnhMetaFilePixelFormat) failed"); <br> <br>    } else { <br>        vErrOut("Main: LoadLibrary(GDI32) failed"); <br>    } <br> <br>    if (!InitializeApp()) { <br>        MessageBox(ghwndMain, <br>            GetStringRes(IDS_INITAPPFAIL), GetStringRes(IDS_ERROR), MB_OK); <br>        return 0; <br>    } <br> <br>    if (!(hAccel = LoadAccelerators (ghModule, MAKEINTRESOURCE(ACCEL_ID)))) <br>        MessageBox(ghwndMain, <br>            GetStringRes(IDS_LOADACCFAIL), GetStringRes(IDS_ERROR), MB_OK); <br> <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>        if (!TranslateAccelerator( ghwndMain, hAccel, &amp;msg) ) { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    return 1; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br>    UNREFERENCED_PARAMETER(nShowCmd); <br>    UNREFERENCED_PARAMETER(hInstance); <br>    UNREFERENCED_PARAMETER(hPrevInstance); <br>} <br> <br> <br>/***************************************************************************\ <br>* InitializeApp <br>* <br>\***************************************************************************/ <br> <br>BOOL InitializeApp(void) <br>{ <br>    WNDCLASS wc; <br>    int index; <br>    HDC hDC; <br> <br>    wc.style            = CS_DBLCLKS; <br>    wc.lpfnWndProc      = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra= sizeof(DWORD); <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(APP_ICON)); <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground= (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wc.lpszMenuName     = "MainMenu"; <br>    wc.lpszClassName= "MetafDemoClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>return FALSE; <br> <br>    wc.style            = CS_OWNDC | CS_SAVEBITS; <br>    wc.lpfnWndProc      = (WNDPROC)DrawSurfWndProc; <br>    wc.hIcon            = NULL; <br>    wc.hCursor          = NULL; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "DrawSurfClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>return FALSE; <br> <br>    wc.style= CS_OWNDC | CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc= (WNDPROC)TextWndProc; <br>    wc.hIcon= NULL; <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground= (HBRUSH)(COLOR_BTNFACE + 1); <br>    wc.lpszMenuName= NULL; <br>    wc.lpszClassName= "Text"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br> <br> <br> <br>    hMenu= LoadMenu(ghModule, "MainMenu"); <br> <br>    for (index = 0; index &lt; OD_BTN_CNT; index++) { <br>        ghBmpDn[index] = (PVOID)LoadBitmap(ghModule, (LPCSTR)MAKEINTRESOURCE(BMID_BASED+index)); <br>        ghBmpUp[index] = (PVOID)LoadBitmap(ghModule, (LPCSTR)MAKEINTRESOURCE(BMID_BASEU+index)); <br>    } <br>    for (index = 0; index &lt; OD_TOOL_CNT; index++) { <br>        ghToolBmpDn[index] = (PVOID)LoadBitmap(ghModule, (LPCSTR)MAKEINTRESOURCE(BMID_TOOLBASED+index)); <br>        ghToolBmpUp[index] = (PVOID)LoadBitmap(ghModule, (LPCSTR)MAKEINTRESOURCE(BMID_TOOLBASEU+index)); <br> <br>    } <br> <br>    ghwndMain = CreateWindowEx(0L, <br>            GetStringRes(IDS_MFDEMOCL), GetStringRes2(IDS_EMF), <br>    WS_OVERLAPPED   | WS_CAPTION     | WS_BORDER       | <br>    WS_THICKFRAME   | WS_MAXIMIZEBOX | WS_MINIMIZEBOX  | <br>    WS_CLIPCHILDREN | WS_VISIBLE     | WS_SYSMENU, <br>            80, 70, 600, 300, <br>    NULL, hMenu, ghModule, NULL); <br> <br>    if (ghwndMain == NULL) <br>return FALSE; <br> <br>    SetWindowLong(ghwndMain, GWL_USERDATA, 0L); <br>    ghwndNext = SetClipboardViewer(ghwndMain); <br> <br>    if (gbFit2Wnd) <br>        CheckMenuItem(hMenu, MM_FIT2WND, MF_CHECKED); <br>    else <br>        CheckMenuItem(hMenu, MM_FIT2WND, MF_UNCHECKED); <br> <br>    if (gbImport3X) <br>        CheckMenuItem(hMenu, MM_IMPORT_3X, MF_CHECKED); <br>    else <br>        CheckMenuItem(hMenu, MM_IMPORT_3X, MF_UNCHECKED); <br> <br>    if (gbExport3X) <br>        CheckMenuItem(hMenu, MM_EXPORT_3X, MF_CHECKED); <br>    else <br>        CheckMenuItem(hMenu, MM_EXPORT_3X, MF_UNCHECKED); <br> <br>    SetFocus(ghwndMain);    /* set initial focus */ <br> <br>    gDib.ulFiles = gDib.ulFrames = 0; <br>    hDC = GetDC(NULL); <br>    ghHT = CreateHalftonePalette(hDC); <br>    ReleaseDC(NULL, hDC); <br> <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessWmCreate <br>* <br>* Effects:  process WM_CREATE message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessWmCreate(HWND hWnd) <br>{ <br>    SetWindowLong(hWnd, 0, (LONG)NULL); <br>    ghDCMem = CreateCompatibleDC(NULL); <br> <br>    ghwndCtrlPanel = CreateDialog(ghModule, <br>                                    (LPCSTR)MAKEINTRESOURCE(DID_CTRLPANEL), <br>                                    hWnd, <br>                                    (DLGPROC) CtrlPanelDlgProc); <br> <br>    ghwndDrawSurf = CreateWindow("DrawSurfClass", <br>                                    NULL, </code></pre>
<p>
</p>
<pre><code>WS_BORDER | WS_CHILD | WS_VISIBLE, <br>                                    0, 0, 0, 0, <br>                                    hWnd, <br>                                    NULL, <br>                                    ghModule, <br>                                    NULL); <br> <br>    ghTextWnd = CreateWindow("Text", <br>                                NULL, <br>                                WS_BORDER | SS_LEFT | WS_CHILD | WS_VISIBLE, <br>                                0, 0, 0, 0, <br>                                hWnd, <br>                                NULL,               //(HMENU) 2, <br>                                ghModule, <br>                                NULL); <br> <br>    ghbrRed     = CreateSolidBrush(RGB(255, 0, 0)); <br>    ghbrAppBkgd = CreateSolidBrush(GetSysColor(COLOR_BACKGROUND)); <br>    ghpnWide    = CreatePen(PS_SOLID, 5, RGB(0, 0, 0)); <br>    return 0L; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessWmDrawClip <br>* <br>* Effects:  process the WM_DRAWCLIPBOARD message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessWmDrawClip(UINT message, DWORD wParam, LONG lParam) <br>{ <br>    if ((IsClipboardFormatAvailable(CF_METAFILEPICT)) || <br>        (IsClipboardFormatAvailable(CF_ENHMETAFILE)) ) <br>        EnableMenuItem(hMenu, MM_PASTE, MF_ENABLED); <br>    else <br>        EnableMenuItem(hMenu, MM_PASTE,  MF_GRAYED); <br> <br>    if (ghwndNext) <br>        SendMessage(ghwndNext, message, wParam, lParam); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessWmSize <br>* <br>* Effects:  process the WM_SIZE message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LRESULT lProcessWmSize(HWND hWnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    RECT        rc; <br>    LONG        lcyCtrlPanel, lcyDrawSurf; <br> <br>    GetWindowRect(ghwndCtrlPanel, &amp;rc); <br>    lcyCtrlPanel = rc.bottom-rc.top; <br>    lcyDrawSurf = HIWORD(lParam) - lcyCtrlPanel - glcyStatus; <br> <br>    // <br>    // CR!! Alternatively, this window can be created with cy <br>    //      equals to cy of the screen and saving this call <br>    //      altogether. <br>    // <br>    MoveWindow(ghwndCtrlPanel, <br>               0, 0, LOWORD(lParam), lcyCtrlPanel, TRUE); <br> <br>    // <br>    // This ordering guarantees the text window paints correctly <br>    // <br>    MoveWindow(ghTextWnd, <br>               0, lcyCtrlPanel + lcyDrawSurf, <br>               LOWORD(lParam),                    // cx of hwnd <br>               glcyStatus, TRUE); <br> <br>    MoveWindow(ghwndDrawSurf, <br>               0, lcyCtrlPanel, <br>               LOWORD(lParam),                    // cx of hwnd <br>               lcyDrawSurf, TRUE); <br> <br>    return DefWindowProc(hWnd, message, wParam, lParam); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessWmDestroy <br>* <br>* Effects:  process the WM_DESTROY message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessWmDestroy(VOID) <br>{ <br>    if (ghDCMem != (HDC)NULL) <br>        DeleteDC(ghDCMem); <br>    if (ghMetaf != (HENHMETAFILE)NULL) <br>        DeleteEnhMetaFile(ghMetaf); <br>    DestroyWindow(ghwndCtrlPanel); <br>    DeleteObject(ghbrRed); <br>    DeleteObject(ghbrCur); <br>    DeleteObject(ghpnCur); <br>    DeleteObject(ghbrAppBkgd); <br>    DeleteObject(ghpnWide); <br>    if (ghHT) <br>        DeleteObject(ghHT); <br>    ChangeClipboardChain(ghwndMain, ghwndNext); <br>    bFreeDibFile(&amp;gDib); <br>    PostQuitMessage(0); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDPlayStep <br>* <br>* Effects:  process the WM_COMMAND DID_X messages <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDPlayStep(DWORD wParam, INT *piPlus) <br>{ <br>    HDC           hDCDrawSurf; <br>    ENHMETAHEADER EnhMetaHdr; <br>    RECT          rcClientDS; <br>    int           iRecord; <br>    PLAYINFO      PlayInfo; <br>    BOOL          bRCSet = FALSE; <br> <br>    if (ghMetaf == 0) <br>        return 0L; <br> <br>    GetEnhMetaFileHeader(ghMetaf, sizeof(EnhMetaHdr), &amp;EnhMetaHdr); <br>    iRecord = LOWORD(wParam) - DID_ZERO + *piPlus; <br>    SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, iRecord, FALSE); <br>    PlayInfo.iRecord = iRecord; <br>    PlayInfo.bPlayContinuous = FALSE; <br>    *piPlus = 0; <br> <br>    if ((EnhMetaHdr.nRecords &gt; 1) &amp;&amp; (iRecord &gt; 0) &amp;&amp; <br>        (iRecord &lt;= (INT) EnhMetaHdr.nRecords)) { <br>        hDCDrawSurf = GetDC(ghwndDrawSurf); <br> <br>        bRCSet = bSetRC2MatchEmfRC(hDCDrawSurf, EnhMetaHdr, ghMetaf, NULL); <br>        if (!bRCSet) { <br>            vErrOut("lProcessDIDPlayStep failed"); <br>        } <br> <br>        if (gbFit2Wnd) { <br>            GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br>            EnumEnhMetaFile(hDCDrawSurf, ghMetaf, (ENHMFENUMPROC)bPlayRecord, (LPVOID) &amp;PlayInfo, &amp;rcClientDS); <br>        } else { <br>            EnumEnhMetaFile(hDCDrawSurf, ghMetaf, (ENHMFENUMPROC)bPlayRecord, (LPVOID) &amp;PlayInfo, (LPRECT)&amp;EnhMetaHdr.rclBounds); <br>        } <br>        // <br>        // Enabling the user to record a metafile record selectively <br>        // <br> <br>        if ((gbRecording) &amp;&amp; (ghDCMetaf != NULL)) { <br>            EnumEnhMetaFile(ghDCMetaf, ghMetaf, (ENHMFENUMPROC)bPlayRecord, (LPVOID) &amp;PlayInfo, (LPRECT)&amp;EnhMetaHdr.rclBounds); <br>        } <br> <br>        if (bRCSet) { <br>            bCleanUpRC(); <br>        } <br> <br>        ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDPlayTenPlus <br>* <br>* Effects:  process the WM_COMMAND DID_TEN_PLUS message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDPlayTenPlus(INT *piPlus) <br>{ <br>    if (ghMetaf == 0) <br>        return 0L; <br> <br>    *piPlus += 10; <br>    SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, *piPlus, FALSE); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMCopy <br>* <br>* Effects:  process the WM_COMMAND MM_COPY message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMCopy(VOID) <br>{ <br>    if ((ghMetaf == 0) &amp;&amp; (ghmf == 0)) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_NOMFFORCPY)); <br>        return 0L; <br>    } <br> <br>    OpenClipboard(ghwndMain); <br>    EmptyClipboard(); <br> <br>    if (gbExport3X) <br>    { <br>        HGLOBAL         hmem; <br>        LPMETAFILEPICT  lpmfp; <br>        RECT            rcClientDS; <br>        DWORD           x, y, mm; <br>        HDC             hDCDrawSurf; <br>        LPBYTE          pjData; <br>        UINT            uiSize; <br> <br>        hDCDrawSurf = GetDC(ghwndDrawSurf); <br> <br>        if (ghmf == 0) { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_CNVEMFTO3X)); <br> <br>            if (!(uiSize = GetWinMetaFileBits(ghMetaf, 0, NULL, MM_ANISOTROPIC, hDCDrawSurf))) { <br>                MessageBox(ghwndMain, GetStringRes(IDS_GETWMFBTSFAIL), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>                goto COPY_3X_EXIT; <br>            } <br> <br>            if ((pjData = (LPBYTE) LocalAlloc(LMEM_FIXED, uiSize)) == NULL) { <br>                MessageBox(ghwndMain, GetStringRes(IDS_MALLOCFAIL), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>                goto COPY_3X_EXIT; <br>            } <br> <br>            if (!(uiSize = GetWinMetaFileBits(ghMetaf, uiSize, pjData, MM_ANISOTROPIC, hDCDrawSurf))) { <br>                MessageBox(ghwndMain, GetStringRes(IDS_GETWMFBTSFAIL2), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>                LocalFree(pjData); <br>                goto COPY_3X_EXIT; <br>            } <br> <br>            ghmf = SetMetaFileBitsEx(uiSize, (LPBYTE) pjData); <br>            LocalFree(pjData); <br>        } <br> <br>        if ((hmem = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE | GMEM_DDESHARE, <br>                            sizeof(METAFILEPICT))) == NULL) { <br> <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_MALLOCFAIL2)); <br>            goto COPY_3X_EXIT; <br> <br>        } <br> <br>        lpmfp = (LPMETAFILEPICT)GlobalLock(hmem); <br>        lpmfp-&gt;mm = mm = MM_ANISOTROPIC; <br> <br>        GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br>        x = rcClientDS.right - rcClientDS.left; <br>        x *= 2540; <br>        x /= GetDeviceCaps(hDCDrawSurf, LOGPIXELSX); <br>        lpmfp-&gt;xExt = x;                                // ie. in 0.01mm <br> <br>        y = rcClientDS.bottom - rcClientDS.top; <br>        y *= 2540; <br>        y /= GetDeviceCaps(hDCDrawSurf, LOGPIXELSY); <br>        lpmfp-&gt;yExt = y;                                // ie. in 0.01mm <br> <br>        lpmfp-&gt;hMF = CopyMetaFile(ghmf, NULL); <br> <br>        GlobalUnlock(hmem); <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_CPY3XMFTOCLP)); <br>        SetClipboardData(CF_METAFILEPICT, hmem); <br> <br>COPY_3X_EXIT: <br>        ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br>        goto COPY_EXIT; <br> <br>    } <br> <br>    // <br>    // gbExport3X == FALSE <br>    // <br>    if (ghMetaf == 0)           // requires conversion <br>    { <br>        UINT            uiSize; <br>        LPVOID          pvData; <br>        HDC             hDCDrawSurf; <br> <br>        SetWindowText(ghTextWnd, "Converting 3X Metafile to Enhanced Metafile format"); <br>        if (!(uiSize = GetMetaFileBitsEx(ghmf, 0, NULL))) { <br>            MessageBox(ghwndMain, GetStringRes(IDS_GETMFBTSXFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_CNVFAIL)); <br>            goto COPY_EXIT; <br>        } <br> <br>        if ((pvData = (LPVOID) LocalAlloc(LMEM_FIXED, uiSize)) == NULL) { <br>            MessageBox(ghwndMain, GetStringRes(IDS_MALLOCFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_CNVFAIL)); <br>            goto COPY_EXIT; <br>        } <br> <br>        if (!(uiSize = GetMetaFileBitsEx(ghmf, uiSize, pvData))) { <br>            MessageBox(ghwndMain, GetStringRes(IDS_GETWMFBTSFAIL2X), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            goto COPY_ENH_EXIT; <br>        } <br> <br>        hDCDrawSurf = GetDC(ghwndDrawSurf); <br> <br>        // !!! provide the correct picture extents in the METAFILEPICT structure <br>        // where possible <br>        ghMetaf = SetWinMetaFileBits(uiSize, (LPBYTE)pvData, hDCDrawSurf, NULL); <br> <br>COPY_ENH_EXIT: <br>        LocalFree(pvData); <br>        ReleaseDC(ghwndDrawSurf ,hDCDrawSurf); <br> <br>        if (ghMetaf == 0) { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_CNVFAIL)); <br>            goto COPY_EXIT; <br>        } <br> <br>    } <br> <br>    // <br>    // No Conversion required <br>    // <br>    { <br> <br>        HENHMETAFILE hEmfTmp; <br> <br>        hEmfTmp = CopyEnhMetaFile(ghMetaf, NULL); <br> <br>        if (hEmfTmp) { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_CPYEMFTOCLP)); <br>            SetClipboardData(CF_ENHMETAFILE, hEmfTmp); <br>            DeleteEnhMetaFile(hEmfTmp); <br>        } <br> <br>    } <br> <br>COPY_EXIT: <br> <br>    CloseClipboard(); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMPaste <br>* <br>* Effects:  process the WM_COMMAND MM_PASTE message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMPaste(HWND hwnd, BOOL *pbReset) <br>{ <br> <br>    OpenClipboard(ghwndMain); <br> <br>    if (gbImport3X) <br>    { <br>        HANDLE      hmem; <br>        DWORD       dwXSugExt, dwYSugExt, dwMM; <br>        HDC         hDCDrawSurf; <br>        RECT        rc; <br>        INT         iSavedDC; <br> <br> <br>        hmem = GetClipboardData(CF_METAFILEPICT); <br> <br>        if (hmem) <br>        { <br>            LPMETAFILEPICT lpmfp; <br> <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_PST3XMF)); <br>            lpmfp = (LPMETAFILEPICT)GlobalLock(hmem); <br>            ghmf  = lpmfp-&gt;hMF; <br>            dwMM  = lpmfp-&gt;mm; <br>            dwXSugExt = lpmfp-&gt;xExt;        // in 0.01 mm <br>            dwYSugExt = lpmfp-&gt;yExt; <br>            GlobalUnlock(hmem); <br> <br>            hDCDrawSurf = GetDC(ghwndDrawSurf); <br> <br>            iSavedDC = SaveDC(hDCDrawSurf); <br> <br>            GetClientRect(ghwndDrawSurf, &amp;rc); <br> <br>            SetMapMode(hDCDrawSurf, dwMM); <br>            if ((dwXSugExt &gt; 0 )&amp;&amp; (dwYSugExt &gt; 0)) <br>            {                               // suggested width &amp; height of image <br>                DWORD x; <br>                DWORD y; <br> <br>                // no. of pixels in x and y <br>                x = dwXSugExt; <br>                x *= GetDeviceCaps(hDCDrawSurf,LOGPIXELSX); <br>                x /= 2540; <br> <br>                y = dwYSugExt; <br>                y *= GetDeviceCaps(hDCDrawSurf,LOGPIXELSY); <br>                y /= 2540; <br> <br>                SetWindowExtEx(hDCDrawSurf, x, y, NULL); <br> <br>                if (gbFit2Wnd) <br>                    SetViewportExtEx(hDCDrawSurf, rc.right, rc.bottom, NULL); <br>                else <br>                    SetViewportExtEx(hDCDrawSurf, x, y, NULL); <br> <br>            } else { <br>                SetWindowText(ghTextWnd, GetStringRes(IDS_NOINFO3XMFX)); <br>                SetWindowExtEx(hDCDrawSurf, rc.right, rc.bottom, NULL); <br>                SetViewportExtEx(hDCDrawSurf, rc.right, rc.bottom, NULL); <br>            } <br> <br>            SetViewportOrgEx(hDCDrawSurf, 0, 0, NULL); <br>            SetWindowOrgEx(hDCDrawSurf, 0, 0, NULL); <br> <br>            SetBoundsRect(hDCDrawSurf, NULL, DCB_ENABLE | DCB_SET); <br>            PlayMetaFile(hDCDrawSurf, ghmf); <br>            { <br>            UINT    uiRC; <br>            char    text[128]; <br> <br>            wsprintf(text, "dwMM = %d\n", dwMM); <br>            OutputDebugString(text); <br>            wsprintf(text, "dwXSugExt = %d\n", dwXSugExt); <br>            OutputDebugString(text); <br>            wsprintf(text, "dwYSugExt = %d\n", dwYSugExt); <br>            OutputDebugString(text); <br> <br>            uiRC = GetBoundsRect(hDCDrawSurf, &amp;rc, DCB_RESET); // in logical coordinates <br>            wsprintf(text, "GetBoundsRect = %d\n", uiRC); <br>            OutputDebugString(text); <br>            wsprintf(text, "left     = %d\n", rc.left); <br>            OutputDebugString(text); <br>            wsprintf(text, "right    = %d\n", rc.right); <br>            OutputDebugString(text); <br>            wsprintf(text, "top      = %d\n", rc.top); <br>            OutputDebugString(text); <br>            wsprintf(text, "bottom   = %d\n", rc.bottom); <br>            OutputDebugString(text); <br>            } <br> <br>// !!! <br>// saving the wmf as an Aldus mf <br>// <br>{ <br>OPENFILENAME    ofn; <br>char            szFile[256], szFileTitle[256]; <br>static char     *szFilter; <br>UINT            uiSize; <br>HANDLE          hFile, hMapFile; <br>LPVOID          pMapFile; <br>DWORD           dwHigh, dwLow; <br> <br>BuildFilterStrs(-1); <br>szFilter = BuildFilterStrs(IDS_FT_WMF); <br> <br>strcpy(szFile, "*.wmf\0"); <br>ofn.lStructSize = sizeof(OPENFILENAME); <br>ofn.hwndOwner = hwnd; <br>ofn.lpstrFilter = szFilter; <br>ofn.lpstrCustomFilter = (LPSTR) NULL; <br>ofn.nMaxCustFilter = 0L; <br>ofn.nFilterIndex = 1; <br>ofn.lpstrFile = szFile; <br>ofn.nMaxFile = sizeof(szFile); <br>ofn.lpstrFileTitle = szFileTitle; <br>ofn.nMaxFileTitle = sizeof(szFileTitle); <br>ofn.lpstrInitialDir = NULL; <br>ofn.lpstrTitle = GetStringRes(IDS_SAVEMF); <br>ofn.Flags = 0L; <br>ofn.nFileOffset = 0; <br>ofn.nFileExtension = 0; <br>ofn.lpstrDefExt = "WMF"; <br> <br>if (!GetOpenFileName(&amp;ofn)) <br>    return 0L; <br> <br>uiSize = GetMetaFileBitsEx(ghmf, 0, NULL); <br>dwHigh = 0; <br>dwLow  = uiSize; <br> <br>if ((hFile = CreateFile(szFile, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, <br>        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == (HANDLE)-1) { <br>    MessageBox(ghwndMain, GetStringRes(IDS_FILEOPNFAIL), <br>        GetStringRes(IDS_ERROR), MB_OK); <br>    return 0L; <br>} <br> <br>// <br>// Create a map file of the opened file <br>// <br>if ((hMapFile = CreateFileMapping(hFile, NULL, <br>                         PAGE_READWRITE, dwHigh, dwLow, "MapF")) == NULL) { <br>    MessageBox(ghwndMain, GetStringRes(IDS_MAPFCREFAIL), <br>        GetStringRes(IDS_ERROR), MB_OK); <br>    goto ErrorExit1; <br>} <br> <br>// <br>// Map a view of the whole file <br>// <br>if ((pMapFile = MapViewOfFile(hMapFile, FILE_MAP_WRITE, 0, 0, uiSize)) == NULL) { <br>    MessageBox(ghwndMain, GetStringRes(IDS_MAPVWMAPFOFAIL), <br>        GetStringRes(IDS_ERROR), MB_OK); <br>    goto ErrorExit2; <br>} <br> <br>if (uiSize) { <br>    APMFILEHEADER   AldHdr; <br>    PAPMFILEHEADER  pAldHdr; <br>    PBYTE           pjTmp; <br>    INT             iSize; <br>    char            text[128]; <br> <br>    AldHdr.key = ALDUS_ID; <br>    AldHdr.hmf = 0;                                 // Unused; must be zero <br>    AldHdr.bbox.Left   = 0;                         // in metafile units <br>    AldHdr.bbox.Top    = 0; <br>    //AldHdr.bbox.Right  = rc.right - rc.left;        // in logical coordinates <br>    //AldHdr.bbox.Bottom = rc.bottom - rc.top; <br> <br>    switch (dwMM) { <br>        case MM_HIENGLISH: <br>            AldHdr.inch = 1000; <br>            AldHdr.bbox.Right  = (SHORT)dwXSugExt; <br>            AldHdr.bbox.Bottom = (SHORT)dwYSugExt; <br>            break; <br>        case MM_HIMETRIC: <br>            AldHdr.inch = 1440; <br>            AldHdr.bbox.Right  = (SHORT)(dwXSugExt / 2540 * 1440); <br>            AldHdr.bbox.Bottom = (SHORT)(dwYSugExt / 2540 * 1440); <br>            break; <br>        case MM_LOENGLISH: <br>            AldHdr.inch = 100; <br>            AldHdr.bbox.Right  = (SHORT)dwXSugExt; <br>            AldHdr.bbox.Bottom = (SHORT)dwYSugExt; <br>            break; <br>        case MM_LOMETRIC: <br>            AldHdr.inch = 254; <br>            AldHdr.bbox.Right  = (SHORT)dwXSugExt; <br>            AldHdr.bbox.Bottom = (SHORT)dwYSugExt; <br>            break; <br>        case MM_TEXT: <br>            AldHdr.inch = (WORD) (GetDeviceCaps(hDCDrawSurf, HORZRES) * 25.4 / <br>                          GetDeviceCaps(hDCDrawSurf, HORZSIZE)); <br>            AldHdr.bbox.Right  = (SHORT)dwXSugExt; <br>            AldHdr.bbox.Bottom = (SHORT)dwYSugExt; <br>            break; <br>        case MM_TWIPS: <br>            AldHdr.inch = 1440; <br>            AldHdr.bbox.Right  = (SHORT)dwXSugExt; <br>            AldHdr.bbox.Bottom = (SHORT)dwYSugExt; <br>            break; <br>        default: <br>            AldHdr.inch = 1440; <br>            AldHdr.bbox.Right  = (SHORT)(dwXSugExt / 2540 * 1440); <br>            AldHdr.bbox.Bottom = (SHORT)(dwYSugExt / 2540 * 1440); <br>            break; <br>    } <br> <br>    wsprintf(text, "MM           = %d\n", dwMM); <br>    OutputDebugString(text); <br>    wsprintf(text, "AldHdr.inch  = %d\n", AldHdr.inch); <br>    OutputDebugString(text); <br> <br>    AldHdr.reserved = 0; <br>    AldHdr.checksum = 0; <br>    { <br>    WORD    *p; <br> <br>    for (p = (WORD *)&amp;AldHdr, AldHdr.checksum = 0; <br>            p &lt; (WORD *)&amp;(AldHdr.checksum); ++p) <br>        AldHdr.checksum ^= *p; <br>    } <br> <br>    pAldHdr = &amp;AldHdr; <br>    pjTmp = (PBYTE)pMapFile; <br> <br>    iSize = 22; <br> <br>    //!!! use memcpy... <br>    while (iSize--) { <br>        *(((PBYTE)pjTmp)++) = *(((PBYTE)pAldHdr)++); <br>    } <br> <br>    pMapFile = (PBYTE)pMapFile + 22; <br>    GetMetaFileBitsEx(ghmf, uiSize, pMapFile); <br>} <br> <br> <br>UnmapViewOfFile(pMapFile); <br> <br>ErrorExit2: <br>  CloseHandle(hMapFile); <br>ErrorExit1: <br>  CloseHandle(hFile); <br>} <br> <br>            RestoreDC(hDCDrawSurf, iSavedDC); <br>            ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br> <br>        } else { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_GET3XFRMCLPFAIL)); <br>        } <br> <br>        goto PASTE_EXIT; <br> <br>    } <br> <br>    // <br>    // gbImport3X == FALSE <br>    // <br>    { <br>        HENHMETAFILE hEmfTmp; <br>        ENHMETAHEADER EnhMetaHdr; <br> <br>        hEmfTmp = GetClipboardData(CF_ENHMETAFILE); <br>        if (hEmfTmp) { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_PSTEMF)); <br>            if (ghMetaf != (HENHMETAFILE)NULL) <br>                DeleteEnhMetaFile(ghMetaf); <br>            ghMetaf = CopyEnhMetaFile(hEmfTmp, NULL); <br>            DeleteEnhMetaFile(hEmfTmp); <br>            GetEnhMetaFileHeader(ghMetaf, sizeof(EnhMetaHdr), &amp;EnhMetaHdr); <br>            SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, EnhMetaHdr.nRecords, FALSE); <br>            *pbReset = TRUE; <br>        } else { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_GETEMFFROMCLPFAIL)); <br>        } <br>    } <br>PASTE_EXIT: <br> <br>    CloseClipboard(); <br>    EnableMenuItem(hMenu, MM_COPY,  MF_ENABLED); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMDel <br>* <br>* Effects:  process the WM_COMMAND MM_DEL message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMDel(VOID) <br>{ <br>    OpenClipboard(ghwndMain); <br>    EmptyClipboard(); <br>    CloseClipboard(); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMPen <br>* <br>* Effects:  process the WM_COMMAND MM_PEN message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMPen(HWND hwnd) <br>{ <br>    HDC     hDC; <br>    DWORD   dwRGB; <br> <br>    if (bChooseNewColor(hwnd, &amp;dwRGB)) { <br>        hDC = GetDC(ghwndDrawSurf); <br>        if (ghpnCur != NULL) <br>            DeleteObject(ghpnCur); <br>        ghpnCur = CreatePen(PS_SOLID, 1, dwRGB); <br>        SelectObject(hDC, ghpnCur); <br>        if (ghDCMetaf != NULL) <br>            SelectObject(ghDCMetaf, ghpnCur); <br>        ReleaseDC(ghwndDrawSurf, hDC); <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMBrush <br>* <br>* Effects:  process the WM_COMMAND MM_BRUSH message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMBrush(HWND hwnd) <br>{ <br>    HDC     hDC; <br>    static DWORD   dwRGB=RGB(255, 255, 255); <br> <br>    if (bChooseNewColor(hwnd, &amp;dwRGB)) { <br>        hDC = GetDC(ghwndDrawSurf); <br>        if (ghbrCur != NULL) <br>            DeleteObject(ghbrCur); <br>        ghbrCur = hBrCreateBrush(hDC, dwRGB); <br>        SelectObject(hDC, ghbrCur); <br>        if (ghDCMetaf != NULL) <br>            SelectObject(ghDCMetaf, ghbrCur); <br>        ReleaseDC(ghwndDrawSurf, hDC); <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMFont <br>* <br>* Effects:  process the WM_COMMAND MM_FONT message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMFont(VOID) <br>{ <br>    HDC     hDC; <br>    char    text[128]; <br> <br>    if (bChooseNewFont(ghwndMain, &amp;glf, &amp;gCrText)) { <br>        ghCurFont = CreateFontIndirect(&amp;glf); <br> <br>        hDC = GetDC(ghwndDrawSurf); <br>        EnumFonts(hDC, glf.lfFaceName, (FONTENUMPROC)iTT, (LPARAM)&amp;gbTT); <br>        wsprintf(text, "gbTT = %d\n", gbTT); <br>        //OutputDebugString(text); <br>        ReleaseDC(ghwndDrawSurf, hDC); <br> <br>        if (ghDCMetaf != NULL) <br>            SelectObject(ghDCMetaf, ghCurFont); <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMStrokeFill <br>* <br>* Effects:  process the WM_COMMAND MM_TTOUTLN_STROKEFILL message <br>* <br>* Warnings: <br>* <br>* History: <br>*  03-Jan-1996 -by- Petrus Wong [PetrusW] <br>* Wrote it. <br>\**************************************************************************/ <br> <br>LONG lProcessMMStrokeFill(VOID) <br>{ <br>    gbSFOutln = (gbSFOutln ? FALSE : TRUE); <br>    if (gbSFOutln) { <br>        CheckMenuItem(hMenu, MM_TTOUTLN_STROKEFILL, MF_CHECKED); <br>        CheckMenuItem(hMenu, MM_TTOUTLN_POLYDRAW, MF_UNCHECKED); <br>        gbPDOutln = FALSE; <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMPolyDraw <br>* <br>* Effects:  process the WM_COMMAND MM_TTOUTLN_POLYDRAW message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMPolyDraw(VOID) <br>{ <br>    gbPDOutln = (gbPDOutln ? FALSE : TRUE); <br>    if (gbPDOutln) { <br>        CheckMenuItem(hMenu, MM_TTOUTLN_STROKEFILL, MF_UNCHECKED); <br>        CheckMenuItem(hMenu, MM_TTOUTLN_POLYDRAW, MF_CHECKED); <br>        gbSFOutln = FALSE; <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMMltfmts <br>* <br>* Effects:  process the WM_COMMAND MM_C_MLTFMTS message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMMltfmts(VOID) <br>{ <br>    CMTMLTFMT *pMfmt; <br> <br>    if ((gbRecording) &amp;&amp; (ghDCMetaf != NULL)) { <br>if ((pMfmt = pLoadMltFmtFile()) != NULL) { <br>    GdiComment(ghDCMetaf, <br>       sizeof(CMTMLTFMT)+pMfmt-&gt;aemrformat[0].cbData, <br>       (CONST BYTE *) pMfmt); <br>    Free(pMfmt); <br>} <br>else <br>    MessageBox(ghwndMain, <br>                       GetStringRes(IDS_LDMFMTFILEFAIL), <br>       GetStringRes(IDS_ERROR), <br>       MB_OK); <br>    } <br> <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMHittest <br>* <br>* Effects:  process the WM_COMMAND MM_HITTEST message <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMHittest(VOID) <br>{ <br>    static BOOL bHitTest=FALSE; <br>    HWNDhwndRecBtn; <br> <br>    bHitTest = (bHitTest ? FALSE : TRUE); <br>    hwndRecBtn = GetDlgItem(ghwndCtrlPanel, DID_RECORD); <br>    if (bHitTest) { <br>CheckMenuItem(hMenu, MM_HITTEST, MF_CHECKED); <br>EnableMenuItem(hMenu, MM_RECORD, MF_GRAYED); <br>EnableWindow(hwndRecBtn, FALSE); <br>gbHitTest = TRUE; <br>    } else { <br>CheckMenuItem(hMenu, MM_HITTEST, MF_UNCHECKED); <br>EnableMenuItem(hMenu, MM_RECORD, MF_ENABLED); <br>EnableWindow(hwndRecBtn, TRUE); <br>gbHitTest = FALSE; <br>return 0L; <br>    } <br> <br>    if (ghMetaf == 0) { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_NOMFLDFORHTST)); <br>return 0L; <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMLEAbout <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMLEAbout(VOID) <br>{ <br>    if (DialogBox(ghModule, (LPCSTR)"AboutBox", ghwndMain, (DLGPROC)About) == -1) <br>MessageBox(ghwndMain, GetStringRes(IDS_DLGABOUTCREFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMAbout <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMAbout(VOID) <br>{ <br>    if (DialogBox(ghModule, "AboutBox", ghwndMain, (DLGPROC)About) == -1) <br>       MessageBox(ghwndMain, GetStringRes(IDS_DLGABOUTCREFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMLoadMaskBmp <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMLoadMaskBmp(HWND hwnd) <br>{ <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_LDMSKBM)); <br>    bGetBMP(hwnd, TRUE); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMLoadBmp <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMLoadBmp(HWND hwnd) <br>{ <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_LDBM)); <br>    bGetBMP(hwnd, FALSE); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMSaveBmp <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMSaveBmp(VOID) <br>{ <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_SVDRAWSFASBM)); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDOpen <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDOpen(HWND hwnd, CHAR *szLoadedMetaf, BOOL *pbReset) <br>{ <br>    ENHMETAHEADER EnhMetaHdr; <br>    HENHMETAFILE  hEmfTmp; <br> <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_LDMF)); <br>    // <br>    // If user hit cancel, we still have the original metafile <br>    // <br>    //DeleteEnhMetaFile(ghMetaf); <br>    //ghMetaf = hemfLoadMetafile(hwnd); <br>    hEmfTmp = hemfLoadMetafile(hwnd); <br>    if (hEmfTmp != 0) { <br>char szDesc[256]; <br> <br>if (ghMetaf != (HENHMETAFILE)NULL) <br>            DeleteEnhMetaFile(ghMetaf); <br>ghMetaf = CopyEnhMetaFile(hEmfTmp, NULL); <br>GetEnhMetaFileHeader(ghMetaf, sizeof(EnhMetaHdr), &amp;EnhMetaHdr); <br>SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, EnhMetaHdr.nRecords, FALSE); <br>DeleteEnhMetaFile(hEmfTmp); <br>EnableMenuItem(hMenu, MM_COPY,MF_ENABLED); <br>if (GetEnhMetaFileDescription(ghMetaf, 256, szDesc) != 0) { <br>    char    szText[256]; <br>    char    *szTmp, szSource[256]; <br> <br>    szTmp = (char *)strtok(szDesc, "\\0"); <br>    strcpy(szSource, szTmp); <br>    szTmp = (char *)strtok(NULL, "\\0\\0"); <br>    wsprintf(szText, "Source: %s  Title: %s", szSource, szTmp); <br>    SetWindowText(ghTextWnd, szText); <br>    strcpy(szLoadedMetaf, szTmp); <br>} else { <br>    strcpy(szLoadedMetaf, ""); </code></pre>
<p>
</p>
<pre><code>} <br>    //} else { <br>    //  SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, 0, FALSE); <br>    } <br>    *pbReset = TRUE; <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMRec <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMRec(HWND hwnd, CHAR *szFilename) <br>{ <br>    if (gbHitTest) { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_MUSTESCHTSTMD)); <br>return 0L; <br>    } <br> <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_REC)); <br>    if (!gbRecording) { <br>ghDCMetaf = hDCRecordMetafileAs(hwnd, szFilename); <br>    } <br> <br>    if (ghDCMetaf == NULL) { <br>       SetWindowText(ghTextWnd, GetStringRes(IDS_CREMFDCFAIL)); <br>       return 0L; <br>    } <br> <br>    // Parse the szFilename for the title and GdiComment the metafile with it. <br>    { <br>charszComment[256]; <br>char*szTmp, szTmp2[256]; <br> <br>szTmp = (char *)strtok(szFilename, "\\"); <br>strcpy(szTmp2, szTmp); <br>while (szTmp != NULL) { <br>    szTmp = (char *)strtok(NULL, "\\"); <br>    if (szTmp != NULL) { <br>strcpy(szTmp2, szTmp); <br>    } <br>} <br>szTmp = (char *)strtok(szTmp2, "."); <br>wsprintf((LPSTR) szComment, "MfEdit:\\0%s\\0\\0", szTmp); <br>#if 0 <br>if (!GdiComment(ghDCMetaf, 256, szComment)) { <br>    MessageBox(ghwndMain, GetStringRes(IDS_ADDCMNTFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>} <br>#endif <br>    } <br> <br>    gbRecording = TRUE; <br> <br>    if (ghpnCur != NULL) <br>SelectObject(ghDCMetaf, ghpnCur); <br> <br>    if (ghbrCur != NULL) <br>SelectObject(ghDCMetaf, ghbrCur); <br> <br>    if (ghCurFont != NULL) <br>SelectObject(ghDCMetaf, ghCurFont); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDRec <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDRec(HWND hwnd, INT *piMetafCnt, char *szFilename) <br>{ <br>    int  iWidthMM, iHeightMM, iWidthPels, iHeightPels, iMMPerPelX, iMMPerPelY; <br>    char szComment[256]; <br>    char szTitle[256]; <br>    RECT rc; <br>    HDC  hDC; <br> <br> <br>    if (gbHitTest) { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_MUSTESCHTSTMD)); <br>return 0L; <br>    } <br> <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_REC)); <br>    if (!gbRecording) { <br> <br>hDC = GetDC(hwnd); <br>iWidthMM    = GetDeviceCaps(hDC, HORZSIZE); <br>iHeightMM   = GetDeviceCaps(hDC, VERTSIZE); <br>iWidthPels  = GetDeviceCaps(hDC, HORZRES); <br>iHeightPels = GetDeviceCaps(hDC, VERTRES); <br>ReleaseDC(hwnd, hDC); <br>iMMPerPelX  = (iWidthMM * 100)/iWidthPels; <br>iMMPerPelY  = (iHeightMM * 100)/iHeightPels; <br>GetClientRect(ghwndDrawSurf, &amp;rc); <br>rc.left   = rc.left * iMMPerPelX; <br>rc.top  = rc.top * iMMPerPelY; <br>rc.right  = rc.right * iMMPerPelX; <br>rc.bottom = rc.bottom * iMMPerPelY; <br> <br>{ <br>   char szFilenameWithExt[256]; <br>   char suffix[20]; <br>   char szDesc[256]; <br>   char *szTmp, szTmp2[256]; <br> <br>   // <br>   // assemble a new metafile name with the emf extension from <br>   // the generic szFilename <br>   // <br>   wsprintf((LPSTR) suffix, "%d.emf", *piMetafCnt); <br>   *piMetafCnt++; <br>   strcpy(szFilenameWithExt, szFilename); <br>   strcat(szFilenameWithExt, suffix); <br> <br>   // <br>   // parse szFilename for the title for description <br>   // <br>   szTmp = (char *)strtok(szFilename, "\\"); <br>   strcpy(szTmp2, szTmp); <br>   while (szTmp != NULL) { <br>       szTmp = (char *)strtok(NULL, "\\"); <br>       if (szTmp != NULL) { <br>   strcpy(szTmp2, szTmp); <br>       } <br>   } <br>   szTmp = (char *)strtok(szTmp2, "."); <br>   strcpy(szTitle, szTmp); <br>   wsprintf(szDesc, "SDK Enhanced Metafile Editor\\0%s\\0\\0", szTitle); <br>   ghDCMetaf = CreateEnhMetaFile((HDC)NULL, szFilenameWithExt, (LPRECT)&amp;rc, (LPSTR)szDesc); <br>           if (gb3D) <br>                bSetupRC(ghDCMetaf, NULL); <br>} <br> <br>        bSetAdvancedGraphics(ghDCMetaf); <br>    } <br> <br>    if (ghDCMetaf == NULL) { <br>       SetWindowText(ghTextWnd, GetStringRes(IDS_CREMFDCFAIL)); <br>       return 0L; <br>    } <br>    wsprintf((LPSTR) szComment, "MfEdit:\\0%s\\0\\0", szTitle); <br>#if 0 <br>    if (!GdiComment(ghDCMetaf, 256, szComment)) { <br>MessageBox(ghwndMain, GetStringRes(IDS_ADDCMNTFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>    } <br>#endif <br>    gbRecording = TRUE; <br> <br>    if (ghpnCur != NULL) <br>SelectObject(ghDCMetaf, ghpnCur); <br> <br>    if (ghbrCur != NULL) <br>SelectObject(ghDCMetaf, ghbrCur); <br> <br>    if (ghCurFont != NULL) <br>SelectObject(ghDCMetaf, ghCurFont); <br> <br>    return 0L; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDStop <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDStop(VOID) <br>{ <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_STOP)); <br>    if (gbRecording) { <br>        if (gb3D &amp;&amp; gbRCSet) <br>            bCleanUpRC(); <br>ghMetaf = CloseEnhMetaFile(ghDCMetaf); <br>gbRecording = FALSE; <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDPlay <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDPlay(char *szLoadedMetaf) <br>{ <br>    HDC                     hDCDrawSurf; <br>    ENHMETAHEADER           EnhMetaHdr; <br>    RECT                    rcClientDS; <br>    int                     iEntries; <br>    PLOGPALETTE             plogPal; <br>    PBYTE                   pjTmp; <br>    HPALETTE                hPal; <br>    char                    szTmp[256]; <br>    BOOL    bRCSet = FALSE; <br>#ifdef OPENGL_EMF <br>    PIXELFORMATDESCRIPTOR   pfd; <br>#endif <br>    BOOL                    bHasPFD = TRUE; <br> <br> <br>    wsprintf(szTmp, GetStringRes(IDS_FMT_PLAYMF), szLoadedMetaf); <br>    SetWindowText(ghTextWnd, szTmp); <br>    if (ghMetaf != NULL) { <br>hDCDrawSurf = GetDC(ghwndDrawSurf); <br>GetEnhMetaFileHeader(ghMetaf, sizeof(ENHMETAHEADER), &amp;EnhMetaHdr); <br> <br>iEntries = GetEnhMetaFilePaletteEntries(ghMetaf, 0, NULL); <br> <br>if (iEntries) { <br>    if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>    sizeof(DWORD) + sizeof(PALETTEENTRY)*iEntries )) == NULL) { <br>MessageBox(ghwndMain, GetStringRes(IDS_CREPALFAIL), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>    } <br> <br>    plogPal-&gt;palVersion = 0x300; <br>    plogPal-&gt;palNumEntries = (WORD) iEntries; <br>    pjTmp = (PBYTE) plogPal; <br>    pjTmp += 4; <br> <br>    GetEnhMetaFilePaletteEntries(ghMetaf, iEntries, (PPALETTEENTRY)pjTmp); <br>    hPal = CreatePalette(plogPal); <br>    GlobalFree(plogPal); <br> <br>    SelectPalette(hDCDrawSurf, hPal, FALSE); <br>    RealizePalette(hDCDrawSurf); <br>} <br> <br>#ifdef OPENGL_EMF <br>        bRCSet = bSetRC2MatchEmfRC(hDCDrawSurf, EnhMetaHdr, ghMetaf, &amp;pfd); <br>        bHasPFD = (pfd.nSize != 0) ? TRUE : FALSE; <br>        if (!bRCSet) { <br>            vErrOut("lProcessDIDPlay (DspDC) failed"); <br>        } <br>#endif <br>if (gbFit2Wnd) { <br>    GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br>    if (!PlayEnhMetaFile( hDCDrawSurf, ghMetaf, (LPRECT) &amp;rcClientDS)) { <br>chartext[128]; <br> <br>wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>OutputDebugString(text); <br>    } else { <br>                if (gbDB) <br>                   SwapBuffers(hDCDrawSurf); <br>            } <br>} else { <br>    RECT rc; <br> <br>    rc.top = rc.left = 0; <br>    rc.right = EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left; <br>    rc.bottom = EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top; <br>    if (!PlayEnhMetaFile( hDCDrawSurf, ghMetaf, (LPRECT) &amp;rc)) { <br>chartext[128]; <br> <br>wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>OutputDebugString(text); <br>    } else { <br>                if (gbDB) <br>                   SwapBuffers(hDCDrawSurf); <br>            } <br>} <br> <br>        if (bRCSet) { <br>            bCleanUpRC(); <br>            bRCSet = FALSE; <br>        } <br> <br>// <br>// Enabling the user to embed another metafile <br>// <br>if ((gbRecording) &amp;&amp; (ghDCMetaf != NULL)) { <br>    if (hPal != (HPALETTE)NULL) { <br>SelectPalette(ghDCMetaf, hPal, FALSE); <br>RealizePalette(ghDCMetaf); <br>    } <br> <br>#ifdef OPENGL_EMF <br>            if (EnhMetaHdr.bOpenGL &amp;&amp; !gbRCSet) { <br>                char        text[128]; <br> <br>                bRCSet = bSetupRC(ghDCMetaf, (bHasPFD ? &amp;pfd : NULL)); <br>                wsprintf(text, <br>                         "lProcessDIDPlay: (MetaDC) bRCSet=%ld, bHasPFD=%ld", <br>                         bRCSet, bHasPFD); <br>                vErrOut(text); <br>            } <br>#endif <br>    { <br>    RECT rc; <br> <br>    rc.top = rc.left = 0; <br>    rc.right = EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left; <br>    rc.bottom = EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top; <br>    if (!PlayEnhMetaFile( ghDCMetaf, ghMetaf, (LPRECT) &amp;rc)) { <br>chartext[128]; <br> <br>wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>OutputDebugString(text); <br>    } else { <br>                if (gbDB) <br>                   SwapBuffers(ghDCMetaf); <br>            } <br> <br> <br>            if (bRCSet) { <br>                bCleanUpRC(); <br>            } <br> <br>    } <br>} <br> <br>ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br>    } else { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_NOMFFORPLAY)); <br>    } <br> <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDFf <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDFf(BOOL *pbReset) <br>{ <br>    HDC     hDCDrawSurf; <br>    ENHMETAHEADER   EnhMetaHdr; <br>    RECT    rcClientDS; <br>    static int    iRecord = 0; <br>    PLAYINFO    PlayInfo; <br>    int     iEntries; <br>    PLOGPALETTE     plogPal; <br>    PBYTE    pjTmp; <br>    HPALETTE    hPal; <br>    static BOOL     bInitRC = FALSE; <br>    static BOOL     bRCSet = FALSE; <br>    BOOL    bHasPFD = FALSE; <br> <br>    if (ghMetaf == 0) <br>return 0L; <br> <br>    PlayInfo.iRecord = ++iRecord; <br>    PlayInfo.bPlayContinuous = TRUE; <br> <br>    GetEnhMetaFileHeader(ghMetaf, sizeof(EnhMetaHdr), &amp;EnhMetaHdr); <br>    SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, iRecord, FALSE); <br>    if ((EnhMetaHdr.nRecords &gt; 1) &amp;&amp; (iRecord &lt;= (INT)EnhMetaHdr.nRecords)) { <br>hDCDrawSurf = GetDC(ghwndDrawSurf); <br> <br>iEntries = GetEnhMetaFilePaletteEntries(ghMetaf, 0, NULL); <br> <br>if (iEntries) { <br>    if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>    sizeof(DWORD) + sizeof(PALETTEENTRY)*iEntries )) == NULL) { <br>MessageBox(ghwndMain, GetStringRes(IDS_CREPALFAIL), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>    } <br> <br>    plogPal-&gt;palVersion = 0x300; <br>    plogPal-&gt;palNumEntries = (WORD) iEntries; <br>    pjTmp = (PBYTE) plogPal; <br>    pjTmp += 4; <br> <br>    GetEnhMetaFilePaletteEntries(ghMetaf, iEntries, (PPALETTEENTRY)pjTmp); <br>    hPal = CreatePalette(plogPal); <br>    GlobalFree(plogPal); <br> <br>    SelectPalette(hDCDrawSurf, hPal, FALSE); <br>    RealizePalette(hDCDrawSurf); <br>} <br> <br>        if (!bInitRC) { <br>            bRCSet = bSetRC2MatchEmfRC(hDCDrawSurf, EnhMetaHdr, ghMetaf, NULL); <br>            bInitRC = TRUE; <br>            if (!bRCSet) { <br>                vErrOut("lProcessDIDFf failed"); <br>            } <br>        } <br> <br>if (gbFit2Wnd) { <br>    GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br>    EnumEnhMetaFile(hDCDrawSurf, ghMetaf, (ENHMFENUMPROC)bPlayRecord, (LPVOID) &amp;PlayInfo, (LPRECT) &amp;rcClientDS); <br>} else { <br>    EnumEnhMetaFile(hDCDrawSurf, ghMetaf, (ENHMFENUMPROC)bPlayRecord, (LPVOID) &amp;PlayInfo, (LPRECT) &amp;EnhMetaHdr.rclBounds); <br>} <br>// <br>// Enabling the user to record a metafile records selectively <br>// <br>if ((gbRecording) &amp;&amp; (ghDCMetaf != NULL)) { <br>    SelectPalette(ghDCMetaf, hPal, FALSE); <br>    RealizePalette(ghDCMetaf); <br>    EnumEnhMetaFile(ghDCMetaf, ghMetaf, (ENHMFENUMPROC)bPlayRecord, (LPVOID) &amp;PlayInfo, (LPRECT)&amp;EnhMetaHdr.rclBounds); <br>} <br> <br>ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br>    } <br> <br>    if ((iRecord == (INT) EnhMetaHdr.nRecords) || *pbReset) { <br>iRecord = 0; <br>if (*pbReset) <br>    SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, 0, FALSE); <br>*pbReset = FALSE; <br> <br>        if (bRCSet) { <br>            bCleanUpRC(); <br>            bRCSet = FALSE; <br>        } <br> <br>        bInitRC = FALSE; <br>    } <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessDIDClear <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessDIDClear(VOID) <br>{ <br>    HDC     hDCDrawSurf; <br>    HGDIOBJ hObjOld; <br>    RECT    rcDrawSurf; <br> <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_DRAWSFCLR)); <br>    hDCDrawSurf = GetDC(ghwndDrawSurf); <br>    ghbrAppBkgd = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>    hObjOld = SelectObject(hDCDrawSurf, ghbrAppBkgd); <br>    GetClientRect(ghwndDrawSurf, &amp;rcDrawSurf); <br>    PatBlt(hDCDrawSurf, 0, 0, rcDrawSurf.right, rcDrawSurf.bottom, PATCOPY); <br>    ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br>    SelectObject(hDCDrawSurf, hObjOld); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMImport3X <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMImport3X(VOID) <br>{ <br>    gbImport3X = (gbImport3X ? FALSE : TRUE); <br> <br>    if (gbImport3X) <br>CheckMenuItem(hMenu, MM_IMPORT_3X, MF_CHECKED); <br>    else <br>CheckMenuItem(hMenu, MM_IMPORT_3X, MF_UNCHECKED); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMExport3X <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMExport3X(VOID) <br>{ <br>    gbExport3X = (gbExport3X ? FALSE : TRUE); <br> <br>    if (gbExport3X) <br>CheckMenuItem(hMenu, MM_EXPORT_3X, MF_CHECKED); <br>    else <br>CheckMenuItem(hMenu, MM_EXPORT_3X, MF_UNCHECKED); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMFit2Wnd <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMFit2Wnd(VOID) <br>{ <br>    gbFit2Wnd = (gbFit2Wnd ? FALSE : TRUE); <br> <br>    if (gbFit2Wnd) <br>CheckMenuItem(hMenu, MM_FIT2WND, MF_CHECKED); <br>    else <br>CheckMenuItem(hMenu, MM_FIT2WND, MF_UNCHECKED); <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessMMPrint <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessMMPrint(VOID) <br>{ <br>    DWORD   dwThrdID; <br>    HANDLE  hThrd; <br>    PPRTDATA pPrtData; <br> <br>    if (ghMetaf == 0) { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_NOMFFORPRT)); <br>return 0L; <br>    } <br> <br>    // <br>    // bPrintMf is supposed to free up the memory when done. <br>    // <br>    if ((pPrtData = (PPRTDATA) GlobalAlloc(GPTR, sizeof(PRTDATA))) == NULL) { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_MALLOCFAIL2)); <br>return 0L; <br>    } <br> <br>    pPrtData-&gt;hMetaf = ghMetaf; <br>    pPrtData-&gt;bFit2Wnd = gbFit2Wnd; <br> <br>    hThrd = CreateThread(NULL, 0, <br> (LPTHREAD_START_ROUTINE)bPrintMf, <br> pPrtData, STANDARD_RIGHTS_REQUIRED, <br> &amp;dwThrdID); <br> <br>    // <br>    // Free the memory if CreateThread fails... <br>    // <br>    if (hThrd == NULL) { <br>SetWindowText(ghTextWnd, GetStringRes(IDS_CREPRTTHRDFAIL)); <br>GlobalFree(pPrtData); <br>    } <br> <br>    return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lProcessWmCommand <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG lProcessWmCommand(HWND     hwnd, <br>                       UINT     message, <br>                       DWORD    wParam, <br>                       LONG     lParam, <br>                       INT      *piMetafCnt, <br>                       BOOL     *pbReset, <br>                       char     *szFilename, <br>                       char     *szLoadedMetaf) <br>{ <br>    static int     iPlus=0; <br> <br>    switch (LOWORD(wParam)) { <br>        case DID_ZERO: <br>        case DID_ONE: <br>        case DID_TWO: <br>        case DID_THREE: <br>        case DID_FOUR: <br>        case DID_FIVE: <br>        case DID_SIX: <br>        case DID_SEVEN: <br>        case DID_EIGHT: <br>        case DID_NINE: <br>            return lProcessDIDPlayStep(wParam, &amp;iPlus); <br> <br>        case DID_TEN_PLUS: <br>            return lProcessDIDPlayTenPlus(&amp;iPlus); <br> <br>        case MM_PAGESETUP: <br>        case MM_CUT: <br>            return 0L; <br> <br>        case MM_COPY: <br>            return lProcessMMCopy(); <br> <br>        case MM_PASTE: <br>            return lProcessMMPaste(hwnd, pbReset); <br> <br>        case MM_DEL: <br>            return lProcessMMDel(); <br> <br>        case MM_PEN: <br>            return lProcessMMPen(hwnd); <br> <br>        case MM_BRUSH: <br>            return lProcessMMBrush(hwnd); <br> <br>        case MM_FONT: <br>            return lProcessMMFont(); <br> <br>        case MM_TTOUTLN_STROKEFILL: <br>            return lProcessMMStrokeFill(); <br> <br>        case MM_TTOUTLN_POLYDRAW: <br>            return lProcessMMPolyDraw(); <br> <br>        case MM_C_WND_MF: <br>    return 0L; <br> <br>        case MM_C_BEGIN_GP: <br>        case MM_C_END_GP: <br>    return 0L; <br> <br>case MM_C_MLTFMTS: <br>    return lProcessMMMltfmts(); <br> <br>case MM_HITTEST: <br>    return lProcessMMHittest(); <br> <br>case MM_LEABOUT: <br>    return lProcessMMLEAbout(); <br> <br>case MM_ABOUT: <br>    return lProcessMMAbout(); <br> <br>case MM_LOAD_MASKBMP: <br>    return lProcessMMLoadMaskBmp(hwnd); <br> <br>case MM_LOAD_BMP: <br>    return lProcessMMLoadBmp(hwnd); <br> <br>case MM_SAVE_BMP: <br>    return lProcessMMSaveBmp(); <br> <br>        case MM_LOAD: <br>case DID_OPEN: <br>    return lProcessDIDOpen(hwnd, szLoadedMetaf, pbReset); <br> <br>case MM_RECORD: <br>    return lProcessMMRec(hwnd, szFilename); <br> <br>case DID_RECORD: <br>    return lProcessDIDRec(hwnd, piMetafCnt, szFilename); <br> <br>case DID_STOP: <br>    return lProcessDIDStop(); <br> <br>case DID_PLAY: <br>    return lProcessDIDPlay(szLoadedMetaf); <br> <br>case DID_FF: <br>    return lProcessDIDFf(pbReset); <br> <br>case DID_CLEAR: <br>    return lProcessDIDClear(); <br> <br>        case DID_PEN: <br>            SetWindowText(ghTextWnd, "Pen"); <br>            return 0L; <br>        case DID_TEXT: <br>            SetWindowText(ghTextWnd, "Text"); <br>            return 0L; <br>        case DID_RECT: <br>            SetWindowText(ghTextWnd, "Rectangle"); <br>            return 0L; <br>        case DID_FILLRECT: <br>            SetWindowText(ghTextWnd, "Filled Rectangle"); <br>            return 0L; <br>        case DID_ELLIPSE: <br>            SetWindowText(ghTextWnd, "Ellipse"); <br>            return 0L; <br>        case DID_FILLELLIPSE: <br>            SetWindowText(ghTextWnd, "Filled Ellipse"); <br>            return 0L; <br>        case DID_LINE: <br>            SetWindowText(ghTextWnd, "Line"); <br>            return 0L; <br>        case DID_BEZIER: <br>            SetWindowText(ghTextWnd, <br>                "Bezier: Click with Left button for placing control points"); <br>            return 0L; <br>        case DID_BMPOBJ: <br>            SetWindowText(ghTextWnd, <br>                "Bitmap: Click three points for the destination of the bitmap"); <br>            return 0L; <br>        case DID_METAF: <br>            SetWindowText(ghTextWnd, <br>                "External Metafile: Click three points for the destination of the Metafile"); <br>            return 0L; <br>case MM_IMPORT_3X: <br>    return lProcessMMImport3X(); <br> <br>case MM_EXPORT_3X: <br>    return lProcessMMExport3X(); <br> <br>case MM_FIT2WND: <br>    return lProcessMMFit2Wnd(); <br> <br>case MM_PRINT: <br>    return lProcessMMPrint(); <br> <br>default: <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br>    } <br>} <br> <br>/***************************************************************************\ <br>* MainWndProc <br>* <br>\***************************************************************************/ <br> <br>long APIENTRY MainWndProc( <br>    HWND hwnd, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    static int         iMetafCnt=0; <br>    static char        szFilename[256] = "c:\\metaf"; <br>    static BOOL        bReset=FALSE; <br>    static char        szLoadedMetaf[256] = " "; <br> <br>    switch (message) { <br> <br>      case WM_CREATE: { <br>        return lProcessWmCreate(hwnd); <br>      } <br>      case WM_DRAWCLIPBOARD: { <br>        return lProcessWmDrawClip(message, wParam, lParam); <br>      } <br>      case WM_SIZE: { <br>        return lProcessWmSize(hwnd, message, wParam, lParam); <br>      } <br> <br>      case WM_DESTROY: { <br>        return lProcessWmDestroy(); <br>      } <br>      case WM_COMMAND: { <br>        return lProcessWmCommand(hwnd, <br>                                 message, <br>                                 wParam, <br>                                 lParam, <br>                                 &amp;iMetafCnt, <br>                                 &amp;bReset, <br>                                 szFilename, <br>                                 szLoadedMetaf); <br>      } <br>      default: <br>        return DefWindowProc(hwnd, message, wParam, lParam); <br>    } <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* DrawSurfWndProc <br>*       Drawing surface window procedure <br>* <br>* Effects:  Trapping all mouse messages and call the DrawStuff appropriately <br>*           for drawing to the drawing surface DC and metafile DC as needed. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>long APIENTRY DrawSurfWndProc( <br>    HWND hwnd, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    static BOOL    bTrack = FALSE; <br>    static int     OrgX, OrgY; <br>    static int     PrevX, PrevY; <br>    static HDC     hDC; <br>    static HCURSOR hCurArrow, hCurHT; <br>    static BOOL    b3DSetup = FALSE; <br> <br>    switch (message) { <br>case WM_CREATE: { <br>    RECT                    rect; <br> <br>    hDC = GetDC(hwnd); <br> <br>            { <br>            char text[128]; <br> <br>            wsprintf(text, "DrawSurfWndProc: hDC=%lx", hDC); <br>            vErrOut(text); <br>            } <br> <br>            bSetAdvancedGraphics(hDC); <br> <br>            if (gb3D) <br>                b3DSetup = bSetupRC(hDC, NULL); <br> <br>    ReleaseDC(hwnd, hDC); <br> <br>    GetClientRect(GetParent(hwnd), &amp;rect); <br> <br>    SetWindowPos(hwnd, NULL, <br>    0, <br>    30, <br>    rect.right-rect.left, <br>    rect.bottom-rect.top-30, <br>    SWP_NOZORDER | SWP_NOMOVE); <br>            CreateCaret(hwnd, NULL, 1, CARET_HEIGHT); <br>#if 0 <br>    //CreateCaret(hwnd, NULL, 1, 12); <br>    //hbmp = LoadBitmap(ghModule, (LPCSTR)MAKEINTRESOURCE(BMID_TOOLBASED)); <br> <br>    hPal = CreatePalette((LOGPALETTE *)&amp;LogPal); <br>    hDC = GetDC(hwnd); <br>    hOldPal = SelectPalette(hDC, hPal, FALSE); <br>    RealizePalette(hDC); <br> <br>    hbmp = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)&amp;DIBHdr, CBM_CREATEDIB, &amp;dib, (LPBITMAPINFO)&amp;DIBHdr, DIB_PAL_COLORS); <br>    CreateCaret(hwnd, hbmp, 1, 12); <br> <br>    ReleaseDC(hwnd, hDC); <br>#endif <br> <br>    ghCurFont = GetStockObject(SYSTEM_FONT); <br>    GetObject(ghCurFont, sizeof(LOGFONT), &amp;glf); <br>    hCurArrow = LoadCursor(NULL, IDC_ARROW); <br>    hCurHT = LoadCursor(NULL, IDC_CROSS); <br>    break; <br>} <br> <br>case WM_LBUTTONDOWN: { <br>    int    x, y; <br> <br>    x = (int) LOWORD(lParam); <br>    y = (int) HIWORD(lParam); <br> <br>    if (gbHitTest) { <br>hDC = GetDC(hwnd); <br>bHitTest(hDC, x, y); <br>ReleaseDC(hwnd, hDC); <br>break; <br>    } <br> <br>    bTrack = TRUE; <br>    OrgX = PrevX = x; <br>    OrgY = PrevY = y; <br> <br>    hDC = GetDC(hwnd); <br>    SetCapture(hwnd); <br>    break; <br>} <br> <br>case WM_MOUSEMOVE: { <br>    RECT rectClient; <br>    int NextX; <br>    int NextY; <br> <br>    if (gbHitTest) { <br>SetCursor(hCurHT); <br>    } else { <br>SetCursor(hCurArrow); <br>    } <br> <br>    // Update the selection region <br>    if (bTrack) { <br>NextX = (SHORT) LOWORD(lParam); <br>NextY = (SHORT) HIWORD(lParam); <br> <br>// Do not draw outside the window's client area <br> <br>GetClientRect (hwnd, &amp;rectClient); <br>if (NextX &lt; rectClient.left) { <br>    NextX = rectClient.left; <br>} else if (NextX &gt;= rectClient.right) { <br>    NextX = rectClient.right - 1; <br>} <br>if (NextY &lt; rectClient.top) { <br>    NextY = rectClient.top; <br>} else if (NextY &gt;= rectClient.bottom) { <br>    NextY = rectClient.bottom - 1; <br>} <br>if ((NextX != PrevX) || (NextY != PrevY)) { <br>   SetROP2(hDC, R2_NOT);   // Erases the previous box <br>   bDrawStuff(hDC, OrgX, OrgY, PrevX, PrevY, TRUE, TRUE, FALSE, NULL); <br> <br>   // <br>   // Optimization.  Do not record in metafile DC if it is going <br>   // to be erased.  So only call bDrawStuff with the PEN tool. <br>   // <br>   if (gbRecording &amp;&amp; (ghDCMetaf != NULL) &amp;&amp; (gdwCurTool == DID_PEN)) { <br>       bDrawStuff(ghDCMetaf, OrgX, OrgY, PrevX, PrevY, TRUE, TRUE, FALSE, NULL); <br>   } <br> <br> <br>// Get the current mouse position <br>   PrevX = NextX; <br>   PrevY = NextY; <br> <br>   // <br>   // SetROP2(hDC, R2_COPYPEN); <br>   //This is commented out because we don't want to erase <br>   //the background as it sweeps. <br>   // <br>   bDrawStuff(hDC, OrgX, OrgY, PrevX, PrevY, FALSE, TRUE, FALSE, NULL); <br> <br>   if (gbRecording &amp;&amp; (ghDCMetaf != NULL) &amp;&amp; (gdwCurTool == DID_PEN)) { <br>       bDrawStuff(ghDCMetaf, OrgX, OrgY, PrevX, PrevY, FALSE, TRUE, FALSE, NULL); <br>   } <br> <br>} <br>    } <br>    break; <br> <br>} <br> <br>      case WM_LBUTTONUP: { <br>        int NextX; <br>        int NextY; <br> <br>        if (!bTrack) <br>           break; <br> <br>        // End the selection <br>           ReleaseCapture(); <br>           bTrack = FALSE; <br> <br>        // Erases the box <br>           // <br>           // SetROP2(hDC, R2_NOT); <br>           //   This is assumed to be R2_NOT, thus unnecessary <br>           // <br>           bDrawStuff(hDC, OrgX, OrgY, PrevX, PrevY, TRUE, FALSE, FALSE, NULL); <br> <br>           if (gbRecording &amp;&amp; (ghDCMetaf != NULL) &amp;&amp; (gdwCurTool == DID_PEN)) { <br>               bDrawStuff(ghDCMetaf, OrgX, OrgY, PrevX, PrevY, TRUE, FALSE, FALSE, NULL); <br>           } <br> <br>           // <br>           // Apparently, at buttonup time, the mouse location is not clamped to <br>           // the client area.  So, the final ellipse or rectangle will be extended <br>           // outside the client area. <br>           // <br>           // NextX = (SHORT) LOWORD(lParam); <br>           // NextY = (SHORT) HIWORD(lParam); <br>           NextX = PrevX; <br>           NextY = PrevY; <br> <br>        // Draws the new box <br>           SetROP2(hDC, R2_COPYPEN); <br>           bDrawStuff(hDC, OrgX, OrgY, NextX, NextY, FALSE, FALSE, TRUE, NULL); <br> <br>           ReleaseDC(hwnd, hDC); <br> <br>           if (gbRecording &amp;&amp; (ghDCMetaf != NULL)) { <br>                bDrawStuff(ghDCMetaf, OrgX, OrgY, NextX, NextY, FALSE, FALSE, FALSE, NULL); <br>           } <br> <br>        break; <br>      } // case WM_LBUTTONUP <br> <br>#ifdef JAPAN <br>      case WM_IME_REPORT: <br>        if (IR_STRING == wParam) { <br>            LPSTR   lpsz, lpszMeta; <br> <br>            if (!(lpsz = lpszMeta = GlobalLock((HANDLE)lParam))) { <br>                return FALSE; <br>            } <br>            hDC = GetDC(hwnd); <br>    while(*lpsz) { // Draw all characters in the string <br>bDrawStuff(hDC, 0, 0, 0, 0, TRUE, FALSE, FALSE, lpsz); <br>IsDBCSLeadByte((BYTE)*lpsz) ? lpsz += 2 : ++lpsz; <br>    } <br>            ReleaseDC(hwnd, hDC); <br>            if (gbRecording &amp;&amp; (ghDCMetaf != NULL)) { <br>while(*lpszMeta) { // Draw all characters in the string <br>    bDrawStuff(ghDCMetaf, 0, 0, 0, 0, TRUE, FALSE, FALSE, lpszMeta); <br>    IsDBCSLeadByte((BYTE)*lpszMeta) ? lpszMeta += 2 : ++lpszMeta; <br>} <br>            } <br>            GlobalUnlock((HANDLE)lParam); <br>            return TRUE; <br>        } <br>return DefWindowProc(hwnd, message, wParam, lParam); <br>        break; <br>#endif <br> <br>      case WM_CHAR: { <br> <br>        if (gdwCurTool != DID_TEXT) <br>            break; <br> <br>        hDC = GetDC(hwnd); <br>        bDrawStuff(hDC, 0, 0, 0, 0, TRUE, FALSE, FALSE, (LPSTR)&amp;wParam); <br>        ReleaseDC(hwnd, hDC); <br> <br>        if (gbRecording &amp;&amp; (ghDCMetaf != NULL)) { <br>            bDrawStuff(ghDCMetaf, 0, 0, 0, 0, TRUE, FALSE, FALSE, (LPSTR)&amp;wParam); <br>        } <br> <br>        break; <br>      } <br> <br>      case WM_DESTROY: { <br>        HDC         hDC; <br>        HPALETTE    hPal; <br> <br>        DestroyCaret(); <br>        DeleteObject(ghCurFont); <br> <br>        if (gb3D &amp;&amp; b3DSetup) { <br>            bCleanUpRC(); <br>        } <br> <br>        hDC = GetDC(hwnd); <br>        hPal = SelectObject(hDC, GetStockObject(DEFAULT_PALETTE)); <br>        DeleteObject(hPal); <br>        ReleaseDC(hwnd, hDC); <br> <br>PostQuitMessage(0); <br>return 0L; <br>      } <br> <br>      default: <br>return DefWindowProc(hwnd, message, wParam, lParam); <br>    } <br>} <br> <br> <br>/***************************************************************************\ <br>* About <br>* <br>* About dialog proc. <br>* <br>\***************************************************************************/ <br> <br>BOOL CALLBACK About ( <br>    HWND hDlg, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    switch (message) { <br>    case WM_INITDIALOG: <br>        return TRUE; <br> <br>    case WM_COMMAND: <br>        if (wParam == IDOK) </code></pre>
<p>
</p>
<pre><code>EndDialog(hDlg, wParam); <br>        break; <br>    } <br> <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br>/***************************************************************************\ <br>* <br>* TextWndProc <br>* <br>* Text Window procedure for displaying miscellaneous messages to user. <br>* <br>\***************************************************************************/ <br> <br>LONG APIENTRY TextWndProc (HWND hwnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    static HFONT hFont = (HFONT) NULL; <br> <br>    switch (message) <br>    { <br>    case WM_CREATE: <br>        { <br>    LOGFONT    lf; <br>    HDC        hDC; <br>    HFONT      hOldFont; <br>            TEXTMETRIC tm; <br>    //RECT       rect; <br> <br>            SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (PVOID) &amp;lf, (UINT)FALSE); <br> <br>    hDC = GetDC(hwnd); <br>    // this is the height for 8 point size font in pixels <br>    lf.lfHeight = 8 * GetDeviceCaps(hDC, LOGPIXELSY) / 72; <br> <br>    hFont = CreateFontIndirect(&amp;lf); <br>    hOldFont = SelectObject(hDC, hFont); <br>    GetTextMetrics(hDC, &amp;tm); <br> <br>    // base the height of the window on size of text <br>    glcyStatus = tm.tmHeight+6*GetSystemMetrics(SM_CYBORDER)+2; <br>            ReleaseDC(hwnd, hDC); <br>            break; <br>        } <br> <br>    case WM_DESTROY: <br>    if (hFont) <br>DeleteObject(hFont); <br>    break; <br> <br>    case WM_SETTEXT: <br>            DefWindowProc(hwnd, message, wParam, lParam); <br>            InvalidateRect(hwnd,NULL,FALSE); <br>            UpdateWindow(hwnd); <br>            return 0L; <br> <br>    case WM_PAINT: <br>        { <br>            PAINTSTRUCT ps; <br>            RECT   rc; <br>            char   ach[128]; <br>            int    len, nxBorder, nyBorder; <br>            HFONT  hOldFont = NULL; <br> <br>            BeginPaint(hwnd, &amp;ps); <br> <br>            GetClientRect(hwnd,&amp;rc); <br> <br>            nxBorder = GetSystemMetrics(SM_CXBORDER); <br>    rc.left  += 9*nxBorder; <br>            rc.right -= 9*nxBorder; <br> <br>            nyBorder = GetSystemMetrics(SM_CYBORDER); <br>    rc.top    += 3*nyBorder; <br>    rc.bottom -= 3*nyBorder; <br> <br>    // 3D Text <br>            len = GetWindowText(hwnd, ach, sizeof(ach)); <br>    SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE)); <br> <br>    SetBkMode(ps.hdc, TRANSPARENT); <br>    SetTextColor(ps.hdc, RGB(64,96,96)); <br>    if (hFont) <br>hOldFont = SelectObject(ps.hdc, hFont); <br>    ExtTextOut(ps.hdc, rc.left+2*nxBorder+2, rc.top+2, ETO_OPAQUE | ETO_CLIPPED, <br>                &amp;rc, ach, len, NULL); <br> <br>    SetTextColor(ps.hdc, RGB(128,128,128)); <br>      if (hFont) <br>hOldFont = SelectObject(ps.hdc, hFont); <br>    ExtTextOut(ps.hdc, rc.left+2*nxBorder+1, rc.top+1, ETO_CLIPPED, <br>&amp;rc, ach, len, NULL); <br> <br>    SetTextColor(ps.hdc, RGB(255,255,255)); <br>    if (hFont) <br>hOldFont = SelectObject(ps.hdc, hFont); <br>    ExtTextOut(ps.hdc, rc.left+2*nxBorder, rc.top, ETO_CLIPPED, <br>&amp;rc, ach, len, NULL); <br> <br>    SetBkMode(ps.hdc, OPAQUE); <br> <br>    if (hOldFont) <br>SelectObject(ps.hdc, hOldFont); <br> <br>            EndPaint(hwnd, &amp;ps); <br>            return 0L; <br>        } <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* CtrlPanelDlgProc <br>*       The Control Panel dialog procedure <br>* <br>* Effects:  Responsible for drawing the owner draw buttons.  Notifying <br>*           parent of user's action. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG APIENTRY CtrlPanelDlgProc(HWND hwnd, UINT msg, DWORD dwParam, LONG lParam) <br>{ <br>    switch (msg) { <br>        case WM_INITDIALOG: { <br>            int index; <br> <br>            for (index = 0; index &lt; OD_BTN_CNT; index++) { <br>                grHwndCtrlBtn[index] = (PVOID)GetDlgItem(hwnd, (INT)(ID_OD_BTN_BASE+index)); <br>            } <br>            for (index = 0; index &lt; OD_TOOL_CNT; index++) { <br>                grHwndToolBtn[index] = (PVOID)GetDlgItem(hwnd, (INT)(ID_OD_TOOL_BASE+index)); <br>            } <br>            return TRUE; <br>        } <br> <br>        case WM_DRAWITEM: { <br>            PDRAWITEMSTRUCT pDIS = (PDRAWITEMSTRUCT) lParam; <br>            HBITMAP hBmpOld; <br>            BITMAP  bm; <br>            HANDLE  hCtl; <br>            HDC     hDCCtl; <br> <br>            if (pDIS-&gt;CtlID == gdwCurCtrl) { <br>                GetObject((HBITMAP) ghBmpDn[pDIS-&gt;CtlID - ID_OD_BTN_BASE], sizeof(BITMAP), (LPSTR)&amp;bm); <br>                hBmpOld = SelectObject(ghDCMem, (HBITMAP) ghBmpDn[pDIS-&gt;CtlID - ID_OD_BTN_BASE]); <br>            } <br> <br>            if (pDIS-&gt;CtlID == gdwCurTool) { <br>                GetObject((HBITMAP)ghToolBmpDn[pDIS-&gt;CtlID - ID_OD_TOOL_BASE], sizeof(BITMAP), (LPSTR)&amp;bm); <br>                hBmpOld = SelectObject(ghDCMem, (HBITMAP)ghToolBmpDn[pDIS-&gt;CtlID - ID_OD_TOOL_BASE]); <br>            } <br> <br>            if ((pDIS-&gt;CtlID &lt; ID_OD_TOOL_BASE) &amp;&amp; (pDIS-&gt;CtlID != gdwCurCtrl)) { <br>                GetObject((HBITMAP)ghBmpUp[pDIS-&gt;CtlID - ID_OD_BTN_BASE], sizeof(BITMAP), (LPSTR)&amp;bm); <br>                hBmpOld = SelectObject(ghDCMem, (HBITMAP)ghBmpUp[pDIS-&gt;CtlID - ID_OD_BTN_BASE]); <br>            } <br> <br>            if ((pDIS-&gt;CtlID &gt;= ID_OD_TOOL_BASE) &amp;&amp; (pDIS-&gt;CtlID != gdwCurTool)) { <br>                GetObject((HBITMAP)ghToolBmpUp[pDIS-&gt;CtlID - ID_OD_TOOL_BASE], sizeof(BITMAP), (LPSTR)&amp;bm); <br>                hBmpOld = SelectObject(ghDCMem, (HBITMAP)ghToolBmpUp[pDIS-&gt;CtlID - ID_OD_TOOL_BASE]); <br>            } <br> <br>            // <br>            // pDIS-&gt;hDC is clipped to the update region but unfortunately <br>            // that doesn't work well with StretchBlt.  StretchBlt is used <br>            // because I don't have to make sure that the bitmap size is <br>            // exactly the same as the size of the button. <br>            // <br>            hCtl   = GetDlgItem(hwnd, pDIS-&gt;CtlID); <br>            hDCCtl = GetDC(hCtl); <br>            StretchBlt(hDCCtl,                                //pDIS-&gt;hDC, <br>                   pDIS-&gt;rcItem.left, pDIS-&gt;rcItem.top, <br>                   pDIS-&gt;rcItem.right - pDIS-&gt;rcItem.left, <br>                   pDIS-&gt;rcItem.bottom - pDIS-&gt;rcItem.top, <br>                   ghDCMem, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY); <br>            ReleaseDC(hCtl, hDCCtl); <br>            SelectObject(ghDCMem, hBmpOld); <br>            break; <br>        } <br> <br>        case WM_COMMAND: { <br>            DWORD dwOldCtrl = gdwCurCtrl; <br>            DWORD dwOldTool = gdwCurTool; <br> <br>            switch (dwParam) { <br>                case DID_ONE: <br>                case DID_TWO: <br>                case DID_THREE: <br>                case DID_FOUR: <br>                case DID_FIVE: <br>                case DID_SIX: <br>                case DID_SEVEN: <br>                case DID_EIGHT: <br>                case DID_NINE: <br>                case DID_ZERO: <br>                case DID_TEN_PLUS: <br>                    //SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, dwParam - DID_ZERO, FALSE); <br>                    SendMessage(ghwndMain, WM_COMMAND, dwParam, lParam); <br>                    break; <br>                case DID_OPEN: <br>                case DID_RECORD: <br>                case DID_STOP: <br>                case DID_PLAY: <br>                case DID_FF: <br>                    SendMessage(ghwndMain, WM_COMMAND, dwParam, lParam); <br>                    gdwCurCtrl = dwParam; <br>                    InvalidateRect((HWND)grHwndCtrlBtn[dwOldCtrl - ID_OD_BTN_BASE], NULL, FALSE); <br>                    InvalidateRect((HWND)grHwndCtrlBtn[gdwCurCtrl - ID_OD_BTN_BASE], NULL, FALSE); <br>                    break; <br>                case DID_CLEAR: <br>                    SendMessage(ghwndMain, WM_COMMAND, dwParam, lParam); <br>                    break; <br>                case DID_TEXT: <br>                case DID_PEN: <br>                case DID_RECT: <br>                case DID_FILLRECT: <br>                case DID_ELLIPSE: <br>                case DID_FILLELLIPSE: <br>                case DID_LINE: <br>                case DID_BEZIER: <br>                case DID_BMPOBJ: <br>                case DID_METAF: <br>                    SendMessage(ghwndMain, WM_COMMAND, dwParam, lParam); <br>                    gdwCurTool = dwParam; <br>                    InvalidateRect((HWND)grHwndToolBtn[dwOldTool - ID_OD_TOOL_BASE], NULL, FALSE); <br>                    InvalidateRect((HWND)grHwndToolBtn[gdwCurTool - ID_OD_TOOL_BASE], NULL, FALSE); <br>                    break; <br>            } <br>            break; <br>        } <br> <br> <br>        case WM_PAINT: <br>            { <br>                HDC hdc; <br>                RECT rc, rcDlg; <br>                PAINTSTRUCT ps; <br>                HPEN hpenWindowFrame, hpenDarkGray; <br>                int  icyDlg; <br>                int  icyBorder; <br> <br>                icyBorder = GetSystemMetrics(SM_CYBORDER); <br> <br>                GetWindowRect(hwnd, &amp;rcDlg); <br>                icyDlg = rcDlg.right - rcDlg.left; <br> <br>                /* <br>                 * Draw our border lines. <br>                 */ <br>                GetClientRect(hwnd, &amp;rc); <br>                hdc = BeginPaint(hwnd, &amp;ps); <br> <br>                SelectObject(hdc, GetStockObject(WHITE_PEN)); <br>                MoveToEx(hdc, rc.left, rc.top, NULL); <br>                LineTo(hdc, rc.right, rc.top); <br> <br>                hpenDarkGray = CreatePen(PS_SOLID, 1, DARKGRAY); <br>                SelectObject(hdc, hpenDarkGray); <br>                MoveToEx(hdc, rc.left, (rc.top + icyDlg) - icyBorder - 1, NULL); <br>                LineTo(hdc, rc.right, (rc.top + icyDlg) - icyBorder - 1); <br> <br>                hpenWindowFrame = CreatePen(PS_SOLID, icyBorder, <br>                        GetSysColor(COLOR_WINDOWFRAME)); <br>                SelectObject(hdc, hpenWindowFrame); <br>                MoveToEx(hdc, rc.left, (rc.top + icyDlg) - icyBorder, NULL); <br>                LineTo(hdc, rc.right, (rc.top + icyDlg) - icyBorder); <br> <br>                EndPaint(hwnd, &amp;ps); <br>                DeleteObject(hpenWindowFrame); <br>                DeleteObject(hpenDarkGray); <br>            } <br> <br>            break; <br> <br> <br>        //case WM_CTLCOLOR: <br>        case WM_CTLCOLORDLG: <br>        //case WM_CTLCOLORLISTBOX: <br>        case WM_CTLCOLORSTATIC: <br>            switch (GET_WM_CTLCOLOR_TYPE(dwParam, lParam, msg)) { <br>                case CTLCOLOR_DLG: <br>                //case CTLCOLOR_LISTBOX: <br>                    return (BOOL)GetStockObject(LTGRAY_BRUSH); <br> <br>                case CTLCOLOR_STATIC: <br>                    SetBkMode(GET_WM_CTLCOLOR_HDC(dwParam, lParam, msg), <br>                              TRANSPARENT); <br>                //    SetTextColor(GET_WM_CTLCOLOR_HDC(dwParam, lParam, msg), <br>                //              RGB(255,0,0)); <br>                //    SetBkColor(GET_WM_CTLCOLOR_HDC(dwParam, lParam, msg), <br>                //            LIGHTGRAY); <br>                //              RGB(255, 255,0)); <br>                    return (BOOL)GetStockObject(DKGRAY_BRUSH); <br>            } <br>            //return (BOOL)NULL; <br>            return (BOOL)GetStockObject(LTGRAY_BRUSH); <br> <br>        default: <br>            return FALSE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bDrawStuff <br>* <br>* Effects:  The drawing routines are localized here. <br>*           bErase is TRUE if this fcn is called for erasing previous object. <br>*           (as in tracking objects.)  It is FALSE, otherwise. <br>* <br>*           bMove is TRUE if this fcn is called inside the WM_MOUSEMOVE (as <br>*           in tracking objects.)  It is FALSE, otherwise. <br>* <br>*           bCntPt is TRUE if this fcn is to increment either the iCnt or <br>*           iCntMF counter (used only in processing metafile or bezier.) <br>*           It is FALSE, otherwise. <br>* <br>*           lpstr contains the character to be drawn by TextOut when it is <br>*           not NULL. <br>* <br>* Warnings: Metafile and Bezier assume that the caller is calling this fcn <br>*           to draw in the screen DC first. Then draw it to the metafile DC. <br>*           Thus, when it is called to draw on the metafile DC, the points <br>*           would have been set already. <br>* <br>\**************************************************************************/ <br> <br>BOOL bDrawStuff(HDC hDC, INT OrgX, INT OrgY, <br>                         INT NextX, INT NextY, <br>                         BOOL bErase, <br>                         BOOL bMove, <br>                         BOOL bCntPt, <br>                         LPSTR lpstr) { <br>    BOOL bSuccess; <br>    HGDIOBJ hObjOld; <br>    static POINT rgPts[MAX_POINTS], rgPtsMF[MAX_POINTS_MF], rgPtsBMP[MAX_POINTS_BMP]; <br>    static int   iCnt=0, iCntMF=0, iCntBMP=0; <br>    static BOOL  bCaretShown=FALSE; <br> <br>    bSuccess = TRUE; <br>    if (bCaretShown) { <br>        HideCaret(ghwndDrawSurf); <br>        bCaretShown = FALSE; <br>    } <br> <br>    switch (gdwCurTool) { <br>        case DID_PEN: <br>            if (bErase) { <br>                MoveToEx(hDC, NextX, NextY, NULL); <br>            } else { <br>                // <br>                // Override the ROP2 st. the pen won't erase its track <br>                // <br>                SetROP2(hDC, R2_COPYPEN); <br>                LineTo(hDC, NextX, NextY); <br>            } <br>            break; <br>        case DID_TEXT: { <br>            POINT   Pt; <br>#if 0 <br>    HDC hDCMem; <br>#endif <br> <br>            if (lpstr == NULL) { <br>                ShowCaret(ghwndDrawSurf); <br>                bCaretShown = TRUE; <br>                SetCaretPos(NextX, NextY-CARET_HEIGHT); <br>                MoveToEx(hDC, NextX, NextY, NULL); <br> <br>#if 0 <br>StretchDIBits(hDC, 20, 20+120, 64, 64, 0, 64, 64, -64, &amp;dib, <br>(LPBITMAPINFO)&amp;DIBHdr, DIB_PAL_COLORS, SRCCOPY); <br> <br>hDCMem = CreateCompatibleDC(hDC); <br>SelectPalette(hDCMem, hPal, FALSE); <br>RealizePalette(hDCMem); <br>SelectObject(hDCMem, hbmp); <br>BitBlt(hDC, 0,0,64,64,hDCMem, 0,0,SRCCOPY); <br>DeleteDC(hDCMem); <br>#endif <br> <br>    SetFocus(ghwndDrawSurf); <br>    break; <br>            } <br> <br>            SetTextAlign(hDC, TA_BASELINE | TA_LEFT | TA_UPDATECP); <br>            hObjOld = SelectObject(hDC, ghCurFont); <br>            SetTextColor(hDC, gCrText); <br> <br>            if ((gbSFOutln || gbPDOutln) &amp;&amp; gbTT) { <br>                // get rid of the char box <br>                SetBkMode(hDC, TRANSPARENT); <br>                BeginPath(hDC); <br>                TextOut(hDC, NextX, NextY, lpstr, IsDBCSLeadByte((BYTE)*lpstr) ? 2 : 1); <br>                EndPath(hDC); <br> <br>                if (gbSFOutln) { <br>                    StrokeAndFillPath(hDC); <br>                    goto DT_UPDATE; <br>                } <br> <br>                // <br>                // Get path and polydraw <br>                // <br>                { <br>                int     iNumPt; <br>                PBYTE   pjTypes; <br>                PPOINT  pPts; <br> <br>                if (iNumPt = GetPath(hDC, NULL, NULL, 0)) { <br>                    if ((pPts = (PPOINT)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>                                                sizeof(POINT)*iNumPt )) == NULL) { <br>                        MessageBox(ghwndMain, GetStringRes(IDS_CREPNTFAIL), <br>                            GetStringRes(IDS_ERROR), MB_OK); <br>                        break; <br>                    } <br> <br>                    if ((pjTypes = (PBYTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>                                                sizeof(BYTE)*iNumPt )) == NULL) { <br>                        MessageBox(ghwndMain, GetStringRes(IDS_CREPBYTEFAIL), <br>                            GetStringRes(IDS_ERROR), MB_OK); <br>                        goto GP_EXIT1; <br>                    } <br> <br>                    GetPath(hDC, pPts, pjTypes, iNumPt); <br>                } <br>                PolyDraw95(hDC, pPts, pjTypes, iNumPt); <br>                LocalFree(pjTypes); <br> <br>GP_EXIT1: <br>                LocalFree(pPts); <br> <br>                } <br> <br>            } else { <br>                TextOut(hDC, NextX, NextY, lpstr, IsDBCSLeadByte((BYTE)*lpstr) ? 2 : 1); <br>            } <br>DT_UPDATE: <br>            // <br>            // Updating current position <br>            // <br>            { <br>            LONG    lHeight; <br>            LONG    lWidth; <br>            TEXTMETRIC     tm; <br> <br>                if (GetTextMetrics(hDC, &amp;tm)) { <br>                    lHeight = tm.tmHeight; <br>                    lWidth  = tm.tmMaxCharWidth; <br>                } <br> <br>                GetCurrentPositionEx(hDC, (LPPOINT) &amp;Pt); <br>                SetCaretPos(Pt.x, Pt.y-CARET_HEIGHT); <br> <br>            } <br>            ShowCaret(ghwndDrawSurf); <br>            bCaretShown = TRUE; <br> <br>            break; <br> <br>#if 0 <br> <br>#define PT_LINECLOSE     (PT_LINETO | PT_CLOSEFIGURE) <br>#define PT_BEZIERCLOSE (PT_BEZIERTO | PT_CLOSEFIGURE) <br> <br>            hpnRed = CreatePen(PS_SOLID, 0, RGB(255,0,0)); <br>            SelectObject(hDC, hpnRed); <br> <br>            while (iNumPt--) { <br>                static POINT pPnt[3]; <br>                static int   iCnt=0; <br> <br>                switch (*pjTypes++) { <br>                    case PT_MOVETO: { <br>                        MoveToEx(hDC, pPts-&gt;x, pPts-&gt;y, NULL); <br>                        pPts++; <br>                        break; <br>                    } <br>                    case PT_LINETO: { <br>                        LineTo(hDC, pPts-&gt;x, pPts-&gt;y); <br>                        pPts++; <br>                        break; <br> <br>                    } <br>                    case PT_LINECLOSE: { <br>                        LineTo(hDC, pPts-&gt;x, pPts-&gt;y); <br>                        pPts++; <br>                        goto GP_EXIT2; <br>                    } <br>                    case PT_BEZIERTO: { <br>                        pPnt[iCnt].x = pPts-&gt;x; <br>                        pPnt[iCnt].y = pPts-&gt;y; <br>                        pPts++; <br> <br>                        if (iCnt &lt; 2) { <br>                            iCnt++; <br>                        } else { <br>                            PolyBezierTo(hDC, pPnt, 3); <br>                            iCnt = 0; <br>                        } <br>                        break; <br>                    } <br>                    case PT_BEZIERCLOSE: { <br>                        pPnt[iCnt].x = pPts-&gt;x; <br>                        pPnt[iCnt].y = pPts-&gt;y; <br>                        pPts++; <br> <br>                        if (iCnt &lt; 2) { <br>                            iCnt++; <br>                        } else { <br>                            PolyBezierTo(hDC, pPnt, 3); <br>                            iCnt = 0; <br>                        } <br>                        goto GP_EXIT2; <br>                    } <br> <br>                    default: <br>                        break; <br>                } <br> <br>            } <br> <br>#endif <br>        } <br>        case DID_RECT: <br>            hObjOld = SelectObject(hDC, GetStockObject(NULL_BRUSH)); <br>            Rectangle(hDC, OrgX, OrgY, NextX, NextY); <br>            SelectObject(hDC, hObjOld); <br>            break; <br>        case DID_FILLRECT: <br>            Rectangle(hDC, OrgX, OrgY, NextX, NextY); <br>            break; <br>        case DID_ELLIPSE: <br>            hObjOld = SelectObject(hDC, GetStockObject(NULL_BRUSH)); <br>            Ellipse(hDC, OrgX, OrgY, NextX, NextY); <br>            SelectObject(hDC, hObjOld); <br>            break; <br>        case DID_FILLELLIPSE: <br>            Ellipse(hDC, OrgX, OrgY, NextX, NextY); <br>            break; <br>        case DID_LINE: <br>            MoveToEx(hDC, OrgX, OrgY, NULL); <br>            LineTo(hDC, NextX, NextY); <br>            break; <br>        case DID_BEZIER: <br>            if (bErase || bMove) <br>                return bSuccess; <br> <br>            if (bCntPt) { <br>                rgPts[iCnt].x = NextX; <br>                rgPts[iCnt].y = NextY; <br>                iCnt++; <br> <br>                if (iCnt == MAX_POINTS - 1) <br>                    iCnt = 0; <br>            } <br> <br>            if ((iCnt % 3) == 1) {              // (iCnt + 1) % 3 == 1 <br>                // <br>                // Override the ROP2 st. the pen won't erase its track <br>                // <br>                SetROP2(hDC, R2_COPYPEN); <br>                PolyBezier(hDC, (LPPOINT)&amp;rgPts, (DWORD) iCnt); <br>            } <br>            return bSuccess; <br> <br>        case DID_BMPOBJ: { <br>            static BOOL          bBltReady = FALSE; <br> <br>            if (bErase || bMove) <br>                return bSuccess; <br> <br>            if (ghBmp == NULL) { <br>                SetWindowText(ghTextWnd, GetStringRes(IDS_NOBMFOREMBED)); <br>                return bSuccess; <br>            } <br> <br>            if (bCntPt) { <br>                bBltReady = FALSE; <br>                rgPtsBMP[iCntBMP].x = NextX; <br>                rgPtsBMP[iCntBMP].y = NextY; <br>                iCntBMP++; <br> <br>                if (iCntBMP &lt; MAX_POINTS_BMP) { <br>                    return bSuccess; <br>                } <br>            } else { <br>                // <br>                // Caller don't want to increment counter, so must be doing <br>                // recording, so we just Blt again... <br>                // <br>                // But, if the Blt data is no good, bail out... <br>                // <br>                if (!bBltReady) { <br>                    return bSuccess; <br>                } <br>                bPlgBlt(hDC, rgPtsBMP); <br>                return bSuccess; <br>            } <br>            bBltReady = TRUE; <br> <br>            bPlgBlt(hDC, rgPtsBMP); <br>            iCntBMP = 0;                         // reset <br>            return bSuccess; <br>        } <br> <br>        case DID_METAF: { <br>            ENHMETAHEADER EnhMetaHdr; <br>            RECT          rcClientDS; <br>            static XFORM         xform; <br>            static BOOL          bXformReady = FALSE; <br>            int           iEntries; <br>            PLOGPALETTE     plogPal; <br>            PBYTE           pjTmp; <br>            HPALETTE        hPal; <br>            static BOOL     bRCSet = FALSE; <br> <br> <br>            if (bErase || bMove) <br>                return bSuccess; <br> <br>            if (ghMetaf == NULL) { <br>                SetWindowText(ghTextWnd, GetStringRes(IDS_NOMFFOREMBED)); <br>                return bSuccess; <br>            } <br> <br>            if (bCntPt) { <br>                bXformReady = FALSE; <br>                rgPtsMF[iCntMF].x = NextX; <br>                rgPtsMF[iCntMF].y = NextY; <br>                iCntMF++; <br> <br>                if (iCntMF &lt; MAX_POINTS_MF) { <br>                    return bSuccess; <br>                } <br>            } else { <br>                // <br>                // Caller don't want to increment counter, so must be doing <br>                // recording, so we just set xform and play it again... <br>                // <br>                // But, if the xform data is no good, bail out... <br>                // <br>                if (!bXformReady) { <br>                    return bSuccess; <br>                } <br> <br>                GetEnhMetaFileHeader(ghMetaf, sizeof(ENHMETAHEADER), &amp;EnhMetaHdr); <br>                SetWorldTransform(hDC, &amp;xform); <br>                GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br> <br>                iEntries = GetEnhMetaFilePaletteEntries(ghMetaf, 0, NULL); <br> <br>                if (iEntries) { <br>                    if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>                            sizeof(DWORD) + sizeof(PALETTEENTRY)*iEntries )) == NULL) { <br>                        MessageBox(ghwndMain, GetStringRes(IDS_CREPALFAIL), <br>                            GetStringRes(IDS_ERROR), MB_OK); <br>                    } <br> <br>                    plogPal-&gt;palVersion = 0x300; <br>                    plogPal-&gt;palNumEntries = (WORD) iEntries; <br>                    pjTmp = (PBYTE) plogPal; <br>                    pjTmp += 4; <br> <br>                    GetEnhMetaFilePaletteEntries(ghMetaf, iEntries, (PPALETTEENTRY)pjTmp); <br>                    hPal = CreatePalette(plogPal); <br>                    GlobalFree(plogPal); <br> <br>                    SelectPalette(hDC, hPal, FALSE); <br>                    RealizePalette(hDC); <br>                } <br> <br>                bRCSet = bSetRC2MatchEmfRC(hDC, EnhMetaHdr, ghMetaf, NULL); <br>                if (!bRCSet) { <br>                    vErrOut("DID_METAF failed"); <br>                } <br> <br>                //PlayEnhMetaFile(hDC, ghMetaf, (LPRECT) &amp;rcClientDS); <br>                { <br>                RECT rc; <br> <br>                rc.top = rc.left = 0; <br>                rc.right = EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left; <br>                rc.bottom = EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top; <br>                if (!PlayEnhMetaFile(hDC, ghMetaf, (LPRECT) &amp;rc)) { <br>                    char    text[128]; <br> <br>                    wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>                    OutputDebugString(text); <br>                } else { <br>                    if (gbDB) <br>                       SwapBuffers(hDC); <br>                } <br> <br>                } <br>                ModifyWorldTransform(hDC, NULL, MWT_IDENTITY); <br> <br>                if (bRCSet) { <br>                    bCleanUpRC(); <br>                    bRCSet = FALSE; <br>                } <br> <br>                return bSuccess; <br>            } <br> <br>            GetEnhMetaFileHeader(ghMetaf, sizeof(ENHMETAHEADER), &amp;EnhMetaHdr); <br>            // <br>            // Based on the three points, top-left, top-right and bottom-left <br>            // (in this order), of the destination, solve equations for the <br>            // elements of the transformation matrix. <br>            // <br>            xform.eDx = (float) rgPtsMF[0].x; <br>            xform.eDy = (float) rgPtsMF[0].y; <br>            xform.eM11 = (rgPtsMF[1].x - xform.eDx)/(EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left); <br>            xform.eM12 = (rgPtsMF[1].y - xform.eDy)/(EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left); <br>            xform.eM21 = (rgPtsMF[2].x - xform.eDx)/(EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top); <br>            xform.eM22 = (rgPtsMF[2].y - xform.eDy)/(EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top); <br> <br>            bXformReady = TRUE; <br>            SetWorldTransform(hDC, &amp;xform); <br>            GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br> <br>            iEntries = GetEnhMetaFilePaletteEntries(ghMetaf, 0, NULL); <br> <br>            if (iEntries) { <br>                if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>                        sizeof(DWORD) + sizeof(PALETTEENTRY)*iEntries )) == NULL) { <br>                    MessageBox(ghwndMain, GetStringRes(IDS_CREPALFAIL), <br>                        GetStringRes(IDS_ERROR), MB_OK); <br>                } <br> <br>                plogPal-&gt;palVersion = 0x300; <br>                plogPal-&gt;palNumEntries = (WORD) iEntries; <br>                pjTmp = (PBYTE) plogPal; <br>                pjTmp += 4; <br> <br>                GetEnhMetaFilePaletteEntries(ghMetaf, iEntries, (PPALETTEENTRY)pjTmp); <br>                hPal = CreatePalette(plogPal); <br>                GlobalFree(plogPal); <br> <br>                SelectPalette(hDC, hPal, FALSE); <br>                RealizePalette(hDC); <br>            } <br> <br>            if (!bRCSet) { <br>                bRCSet = bSetRC2MatchEmfRC(hDC, EnhMetaHdr, ghMetaf, NULL); <br>                if (!bRCSet) { <br>                    vErrOut("DID_METAF failed"); <br>                } <br>            } <br> <br>            //PlayEnhMetaFile(hDC, ghMetaf, (LPRECT) &amp;rcClientDS); <br>            { <br>            RECT rc; <br> <br>            rc.top = rc.left = 0; <br>            rc.right = EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left; <br>            rc.bottom = EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top; <br>            if (!PlayEnhMetaFile(hDC, ghMetaf, (LPRECT) &amp;rc)) { <br>                 char    text[128]; <br> <br>                 wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>                 OutputDebugString(text); <br>            } else { <br>                if (gbDB) <br>                   SwapBuffers(hDC); <br>            } <br> <br>            } <br>            ModifyWorldTransform(hDC, NULL, MWT_IDENTITY); <br>            iCntMF = 0;                         // reset <br>            if (bRCSet) { <br>                bCleanUpRC(); <br>                bRCSet = FALSE; <br>            } <br>            return bSuccess; <br>        } <br>        default: <br>            break; <br>    } <br>    // <br>    // Reset counter, user has selected other tools. <br>    // <br>    iCnt = 0; <br>    iCntMF = 0; <br>    iCntBMP = 0; <br>    return bSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* hemfLoadMetafile <br>* <br>* Effects:   Brings up the Open file common dialog <br>*            Get the enhanced metafile spec'd by user <br>*            returns the handle to the enhanced metafile if successfull <br>*               otherwise, returns 0. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>HENHMETAFILE hemfLoadMetafile(HWND hwnd) { <br>    OPENFILENAME    ofn; <br>    char            szFile[256], szFileTitle[256]; <br>    static char     *szFilter; <br> <br>    HMETAFILE       hmf; <br>    UINT            uiSize; <br>    LPVOID          pvData; <br>    HDC             hDCDrawSurf; <br>    HENHMETAFILE    hemf; <br> <br>    HANDLE                  hFile, hMapFile; <br>    LPVOID                  pMapFile; <br>    LPENHMETAHEADER         pemh; <br> <br>    BOOL        bSuccess; <br>    char            text[128]; <br> <br> <br>    bSuccess = TRUE; <br> <br>    BuildFilterStrs(-1); <br>    BuildFilterStrs(IDS_FT_EMF); <br>  szFilter = BuildFilterStrs(IDS_FT_WMF); <br> <br>    strcpy(szFile, "*.emf\0"); <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hwnd; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = (LPSTR) NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = szFile; <br>    ofn.nMaxFile = sizeof(szFile); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = GetStringRes(IDS_LDMF); <br>    ofn.Flags = 0L; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = "EMF"; <br> <br>    if (!GetOpenFileName(&amp;ofn)) </code></pre>
<p>
</p>
<pre><code>return 0L; <br> <br>    if ((hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, <br>            OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL)) == (HANDLE)-1) { <br>        wsprintf(text, GetStringRes(IDS_FMT_FILEOPNFAIL), GetLastError()); <br>        MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>        return 0L; <br>    } <br> <br>    // <br>    // Create a map file of the opened file <br>    // <br>    if ((hMapFile = CreateFileMapping(hFile, NULL, <br>                             PAGE_READONLY, 0, 0, "MapF")) == NULL) { <br>        wsprintf(text, GetStringRes(IDS_FMT_CREMAPFILEFAIL), GetLastError()); <br>        MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>        bSuccess = FALSE; <br>        goto ErrorExit1; <br>    } <br> <br>    // <br>    // Map a view of the whole file <br>    // <br>    if ((pMapFile = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0)) == NULL) { <br>        wsprintf(text, GetStringRes(IDS_FMT_MAPVWMAPFOFAIL), GetLastError()); <br>        MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>        bSuccess = FALSE; <br>        goto ErrorExit2; <br>    } <br> <br>    // <br>    // First check that if it is an enhanced metafile <br>    // <br>    pemh = (LPENHMETAHEADER) pMapFile; <br>    if (pemh-&gt;dSignature == META32_SIGNATURE) { <br>        hemf = GetEnhMetaFile(szFile); <br>        goto HLM_EXIT; <br>    } <br> <br>    // <br>    // If it has an ALDUS header skip it <br>    // Notice: APMSIZE is used because the HANDLE and RECT of the structure <br>    //         depends on the environment <br>    // <br>    if (*((LPDWORD)pemh) == ALDUS_ID) { <br>        //METAFILEPICT    mfp; <br> <br>        MessageBox(ghwndMain, GetStringRes(IDS_ALDUSMF), "Hey!", MB_OK); <br>        uiSize = *((LPDWORD) ((PBYTE)pMapFile + APMSIZE + 6)); <br>        hDCDrawSurf = GetDC(ghwndDrawSurf); <br> <br>        // Notice: mtSize is size of the file in word. <br>        // if LPMETAFILEPICT is NULL <br>        //    MM_ANISOTROPIC mode and default device size will be used. <br>        hemf = SetWinMetaFileBits(uiSize*2L, (PBYTE)pMapFile + APMSIZE, hDCDrawSurf, NULL); <br>#if 0 <br>        switch ( ((PAPMFILEHEADER) pMapFile)-&gt;inch ) { <br>            // !!! End up in an upside down image <br>            // <br>            case 1440: <br>                mfp.mm = MM_TWIPS; <br>                OutputDebugString("MM_TWIPS\n"); <br>                break; <br>            case 2540: <br>                OutputDebugString("MM_HIMETRIC\n"); <br>                mfp.mm = MM_HIMETRIC; <br>                break; <br>            case 254: <br>                OutputDebugString("MM_LOMETRIC\n"); <br>                mfp.mm = MM_LOMETRIC; <br>                break; <br>            case 1000: <br>                OutputDebugString("MM_HIENGLISH\n"); <br>                mfp.mm = MM_HIENGLISH; <br>                break; <br>            case 100: <br>                OutputDebugString("MM_LOENGLISH\n"); <br>                mfp.mm = MM_LOENGLISH; <br>                break; <br>            default: <br>                // !!! In addition, text is too small <br>                // <br>                OutputDebugString("MM_ANISOTROPIC\n"); <br>                mfp.mm = MM_ANISOTROPIC; <br>                mfp.xExt = (((PAPMFILEHEADER) pMapFile)-&gt;bbox.Right - ((PAPMFILEHEADER) pMapFile)-&gt;bbox.Left) <br>                           * ((PAPMFILEHEADER) pMapFile)-&gt;inch * 2560; <br>                mfp.yExt = (((PAPMFILEHEADER) pMapFile)-&gt;bbox.Bottom - ((PAPMFILEHEADER) pMapFile)-&gt;bbox.Top) <br>                           * ((PAPMFILEHEADER) pMapFile)-&gt;inch * 2560; <br>                break; <br>        } <br>        mfp.hMF = 0; <br>        hemf = SetWinMetaFileBits(uiSize*2L, (PBYTE)pMapFile + APMSIZE, hDCDrawSurf, &amp;mfp); <br>#endif <br> <br>        if (!hemf) { <br>            char text[256]; <br> <br>            wsprintf(text, GetStringRes(IDS_FMT_SETWMFBTSFAIL), GetLastError()); <br>            MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>        } <br> <br>        ghmf = SetMetaFileBitsEx(uiSize*2L, (PBYTE)pMapFile + APMSIZE); <br>        if (!ghmf) { <br>            char text[256]; <br> <br>            wsprintf(text, GetStringRes(IDS_FMT_SETWMFBTSXFAIL), GetLastError()); <br>            MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>        } <br> <br>// !!! Displaying the Windows format metafile <br>//if (!PlayMetaFile(hDCDrawSurf, ghmf)) { <br>//    wsprintf(text, GetStringRes(IDS_FMT_PLAYMFFAIL), GetLastError()); <br>//    MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>//} <br>        ReleaseDC(ghwndDrawSurf, hDCDrawSurf); <br>        goto HLM_EXIT; <br>    } <br> <br> <br>    // <br>    // It is a Windows 3x format metafile (hopefully) <br>    // <br>    if (!(hmf = GetMetaFile((LPCSTR)szFile))) { <br>        char text[256]; <br> <br>        wsprintf(text, GetStringRes(IDS_FMT_GETMFFAIL), GetLastError()); <br>        MessageBox(ghwndMain, text, GetStringRes(IDS_ERROR), MB_OK); <br>        bSuccess = FALSE; <br>        goto ErrorExit3; <br>    } <br> <br>    if (!(uiSize = GetMetaFileBitsEx(hmf, 0, NULL))) { <br>        MessageBox(ghwndMain, GetStringRes(IDS_GETMFBTSXFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        return NULL; <br>    } <br> <br>    if ((pvData = (LPVOID) LocalAlloc(LMEM_FIXED, uiSize)) == NULL) { <br>        MessageBox(ghwndMain, GetStringRes(IDS_MALLOCFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        bSuccess = FALSE; <br>        goto ErrorExit3; <br>    } <br> <br>    if (!(uiSize = GetMetaFileBitsEx(hmf, uiSize, pvData))) { <br>        MessageBox(ghwndMain, GetStringRes(IDS_GETMFBTSXFAIL2), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        bSuccess = FALSE; <br>        goto ErrorExit3; <br>    } <br> <br>    DeleteMetaFile(hmf); <br> <br>    hDCDrawSurf = GetDC(ghwndDrawSurf); <br>    hemf = SetWinMetaFileBits(uiSize, (LPBYTE)pvData, hDCDrawSurf, NULL); <br>    ghmf = SetMetaFileBitsEx(uiSize, (LPBYTE) pvData); <br> <br>    LocalFree(pvData); <br> <br>    ReleaseDC(ghwndDrawSurf ,hDCDrawSurf); <br> <br>HLM_EXIT: <br>ErrorExit3: <br>    UnmapViewOfFile(pMapFile); <br> <br>ErrorExit2: <br>    CloseHandle(hMapFile); <br>ErrorExit1: <br>    CloseHandle(hFile); <br> <br>    if (bSuccess) <br>        return hemf; <br>    else <br>        return 0L; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* hDCRecordMetafileAs <br>* <br>* Effects:   Brings up the SaveAs common dialog <br>*            Creates the enhanced metafile with the filename spec'd by user <br>*            Modifies the second arg to reflect the new default filename <br>*            less extension <br>*            returns the created metafile DC if successful, otherwise, 0 <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>HDC hDCRecordMetafileAs(HWND hwnd, LPSTR szFilename) { <br>    OPENFILENAME ofn; <br>    char szFile[256], szFileTitle[256]; <br>    static char *szFilter; <br>    char *szTmp, szTmp2[256]; <br>    HDC  hDCMeta; <br> <br>    int iWidthMM, iHeightMM, iWidthPels, iHeightPels, iMMPerPelX, iMMPerPelY; <br>    RECT rc; <br>    HDC hDC; <br> <br>    BuildFilterStrs(-1); <br>    szFilter = BuildFilterStrs(IDS_FT_EMF); <br>    strcpy(szFile, "*.emf\0"); <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hwnd; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = (LPSTR) NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 0L; <br>    ofn.lpstrFile = szFile; <br>    ofn.nMaxFile = sizeof(szFile); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = GetStringRes(IDS_SAVEMFAS); <br>    ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = (LPSTR)NULL; <br> <br>    if (!GetSaveFileName(&amp;ofn)) { <br>        return 0L; <br>    } <br> <br> <br>    hDC = GetDC(hwnd); <br>    iWidthMM = GetDeviceCaps(hDC, HORZSIZE); <br>    iHeightMM = GetDeviceCaps(hDC, VERTSIZE); <br>    iWidthPels = GetDeviceCaps(hDC, HORZRES); <br>    iHeightPels = GetDeviceCaps(hDC, VERTRES); <br>    ReleaseDC(hwnd, hDC); <br>    iMMPerPelX = (iWidthMM * 100)/iWidthPels; <br>    iMMPerPelY = (iHeightMM * 100)/iHeightPels; <br>    GetClientRect(ghwndDrawSurf, &amp;rc); <br>    rc.left = rc.left * iMMPerPelX; <br>    rc.top = rc.top * iMMPerPelY; <br>    rc.right = rc.right * iMMPerPelX; <br>    rc.bottom = rc.bottom * iMMPerPelY; <br> <br> <br>    //hDCMeta = CreateEnhMetaFile((HDC)NULL, szFile, (LPRECT)NULL, (LPSTR)NULL); <br>    { <br>        CHAR    szDesc[256]; <br> <br>        wsprintf(szDesc, "SDK Enhanced Metafile Editor\\0%s\\0\\0", szFileTitle); <br>        hDCMeta = CreateEnhMetaFile((HDC)NULL, szFile, (LPRECT)&amp;rc, (LPSTR)szDesc); <br> <br>        if (gb3D) <br>            gbRCSet = bSetupRC(hDCMeta, NULL); <br> <br>        bSetAdvancedGraphics(hDCMeta); <br>    } <br> <br>    // <br>    // parses the new filename, removes the extension and copy it into <br>    // szFilename <br>    // <br>    strcpy(szFilename, ""); <br>    szTmp = (char *)My_mbstok(szFile, "\\"); <br>    strcpy(szTmp2, szTmp); <br>    while (szTmp != NULL) { <br>        szTmp = (char *)My_mbstok(NULL, "\\"); <br>        if (szTmp != NULL) { <br>            strcat(szFilename, szTmp2); <br>            strcpy(szTmp2, szTmp); <br>            strcat(szFilename, "\\"); <br>        } <br>    } <br>    szTmp = (char *)My_mbstok(szTmp2, "."); <br>    strcat(szFilename, szTmp); <br> <br>    return hDCMeta; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPlayRecord <br>* <br>* Effects:  Play metafile <br>*           if PlayInfo.bPlayContinuous is TRUE <br>*               play metafile from 1st record up to the PlayInfo.iRecord th <br>*                   record <br>*           else only play the PlayInfo.iRecord th record and those preceding <br>*               records that are relevant like MoveTo, etc. <br>*           Terminates enumeration after playing up to the <br>*               PlayInfo.iRecord th record <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL APIENTRY bPlayRecord(HDC hDC, LPHANDLETABLE lpHandleTable, <br>                                   LPENHMETARECORD lpEnhMetaRecord, <br>                                   UINT nHandles, <br>                                   LPVOID lpData) { <br>    BOOL bSuccess; <br>    static int  iCnt=0; <br>    int         i; <br>    char        ach[128]; <br>    char        achTmp[128]; <br>    LONG        lNumDword; <br> <br>    bSuccess = TRUE; <br> <br>    lNumDword = (lpEnhMetaRecord-&gt;nSize-8) / 4; <br> <br>    iCnt++; <br>    if (((PLAYINFO *) lpData)-&gt;bPlayContinuous) { <br>        bSuccess = PlayEnhMetaFileRecord(hDC, lpHandleTable, <br>                                             lpEnhMetaRecord, nHandles); <br>        if (iCnt == ((PLAYINFO *) lpData)-&gt;iRecord) { <br>            wsprintf((LPSTR) ach, "%s", rgMetaName[lpEnhMetaRecord-&gt;iType]); <br>            for (i=0; i &lt; lNumDword; i++) { <br>                wsprintf((LPSTR) achTmp, "%ld ", lpEnhMetaRecord-&gt;dParm[i]); <br>                if ((strlen(ach)+strlen(achTmp))/sizeof(char) &gt;= 128) <br>                    break; <br>                strcat(ach, achTmp); <br>            } <br>        SetWindowText(ghTextWnd, ach); <br>        } <br>    } else { <br> <br>        switch (lpEnhMetaRecord-&gt;iType) { <br>            case EMR_SETWINDOWEXTEX: <br>            case EMR_SETWINDOWORGEX: <br>            case EMR_SETVIEWPORTEXTEX: <br>            case EMR_SETVIEWPORTORGEX: <br>            case EMR_SETBRUSHORGEX: <br>            case EMR_SETMAPMODE: <br>            case EMR_SETBKMODE: <br>            case EMR_SETPOLYFILLMODE: <br>            case EMR_SETROP2: <br>            case EMR_SETSTRETCHBLTMODE: <br>            case EMR_SETTEXTALIGN: <br>            case EMR_SETTEXTCOLOR: <br>            case EMR_SETBKCOLOR: <br>            case EMR_OFFSETCLIPRGN: <br>            case EMR_MOVETOEX: <br>            case EMR_SETMETARGN: <br>            case EMR_EXCLUDECLIPRECT: <br>            case EMR_INTERSECTCLIPRECT: <br>            case EMR_SCALEVIEWPORTEXTEX: <br>            case EMR_SCALEWINDOWEXTEX: <br>            case EMR_SAVEDC: <br>            case EMR_RESTOREDC: <br>            case EMR_SETWORLDTRANSFORM: <br>            case EMR_MODIFYWORLDTRANSFORM: <br>            case EMR_SELECTOBJECT: <br>            case EMR_CREATEPEN: <br>            case EMR_CREATEBRUSHINDIRECT: <br>            case EMR_DELETEOBJECT: <br>            case EMR_SELECTPALETTE: <br>            case EMR_CREATEPALETTE: <br>            case EMR_SETPALETTEENTRIES: <br>            case EMR_RESIZEPALETTE: <br>            case EMR_REALIZEPALETTE: <br>            case EMR_SETARCDIRECTION: <br>            case EMR_SETMITERLIMIT: <br>            case EMR_BEGINPATH: <br>            case EMR_ENDPATH: <br>            case EMR_CLOSEFIGURE: <br>            case EMR_SELECTCLIPPATH: <br>            case EMR_ABORTPATH: <br>            case EMR_EXTCREATEFONTINDIRECTW: <br>            case EMR_CREATEMONOBRUSH: <br>            case EMR_CREATEDIBPATTERNBRUSHPT: <br>            case EMR_EXTCREATEPEN: <br>                goto PlayRec; <br>            default: <br>                break; <br>        } //switch <br> <br>        if (iCnt == ((PLAYINFO *) lpData)-&gt;iRecord) { <br>PlayRec: <br>            bSuccess = PlayEnhMetaFileRecord(hDC, lpHandleTable, <br>                                             lpEnhMetaRecord, nHandles); <br>            wsprintf((LPSTR) ach, "%s", rgMetaName[lpEnhMetaRecord-&gt;iType]); <br>            for (i=0; i &lt; lNumDword; i++) { <br>                wsprintf((LPSTR) achTmp, "%ld ", lpEnhMetaRecord-&gt;dParm[i]); <br>                if ((strlen(ach)+strlen(achTmp))/sizeof(char) &gt;= 128) <br>                    break; <br>                strcat(ach, achTmp); <br>            } <br>            SetWindowText(ghTextWnd, ach); <br>        } <br>    } <br> <br>    if (iCnt == ((PLAYINFO *) lpData)-&gt;iRecord) { <br>        iCnt = 0; <br> <br>        if (gbDB) <br>            SwapBuffers(hDC); <br> <br>        return FALSE; <br>    } <br>    return bSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* LoadBitmapFile <br>* <br>* Effects:  Loads the bitmap from file and return the bitmap <br>* <br>* Warnings: pszFileName contains the full path <br>* <br>\**************************************************************************/ <br> <br>HBITMAP hBmpLoadBitmapFile(HDC hDC, PSTR pszFileName) <br>{ <br>    HANDLE              hFile, hMapFile; <br>    LPVOID              pMapFile, pMapFileTmp; <br>    LPBITMAPINFOHEADER  pbmh; <br>    LPBITMAPINFO        pbmi; <br>    PBYTE               pjTmp; <br>    ULONG               sizBMI; <br>    HBITMAP             hBitmap; <br>    INT                 iNumClr; <br>    BOOL                bCoreHdr; <br>    WORD                wBitCount; <br>    PFILEINFO           pFileInfo; <br> <br>    hBitmap = NULL; <br> <br>    if ((hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, <br>            OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL)) == (HANDLE)-1) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_FILEOPNFAIL)); <br>        goto ErrExit1; <br>    } <br> <br>    // <br>    // Create a map file of the opened file <br>    // <br>    if ((hMapFile = CreateFileMapping(hFile, NULL, <br>                             PAGE_READONLY, 0, 0, NULL)) == (HANDLE)-1) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_CREMAPFILEFAIL)); <br>        goto ErrExit2; <br> <br>    } <br> <br>    // <br>    // Map a view of the whole file <br>    // <br>    if ((pMapFile = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0)) == NULL) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_MAPVWOFMAPFOFAIL)); <br>        goto ErrExit3; <br>    } <br> <br>    pMapFileTmp = pMapFile; <br> <br>    // <br>    // First check that it is a bitmap file <br>    // <br>    if (*((PWORD)pMapFile) != 0x4d42) {              // 'BM' <br>        MessageBox(ghwndMain, GetStringRes(IDS_NOTDIBBMFILE), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        goto ErrExit3; <br>    } <br> <br>    // <br>    // The file header doesn't end on DWORD boundary... <br>    // <br>    pbmh = (LPBITMAPINFOHEADER)((PBYTE)pMapFile + sizeof(BITMAPFILEHEADER)); <br> <br>    { <br>        BITMAPCOREHEADER bmch, *pbmch; <br>        BITMAPINFOHEADER bmih, *pbmih; <br>        PBYTE            pjTmp; <br>        ULONG            ulSiz; <br> <br>        pbmch = &amp;bmch; <br>        pbmih = &amp;bmih; <br> <br>        pjTmp = (PBYTE)pbmh; <br>        ulSiz = sizeof(BITMAPCOREHEADER); <br>        while (ulSiz--) { <br>            *(((PBYTE)pbmch)++) = *(((PBYTE)pjTmp)++); <br>        } <br> <br>        pjTmp = (PBYTE)pbmh; <br>        ulSiz = sizeof(BITMAPINFOHEADER); <br>        while (ulSiz--) { <br>            *(((PBYTE)pbmih)++) = *(((PBYTE)pjTmp)++); <br>        } <br> <br>        // <br>        // Use the size to determine if it is a BitmapCoreHeader or <br>        // BitmapInfoHeader <br>        // <br>        // Does PM supports 16 and 32 bpp? How? <br>        // <br>        if (bmch.bcSize == sizeof(BITMAPCOREHEADER)) <br>        { <br>            wBitCount = bmch.bcBitCount; <br>            iNumClr = ((wBitCount == 24) ? 0 : (1 &lt;&lt; wBitCount)); <br>            sizBMI = sizeof(BITMAPCOREHEADER)+sizeof(RGBTRIPLE)*iNumClr; <br>            bCoreHdr = TRUE; <br>        } <br>        else            // BITMAPINFOHEADER <br>        { <br>            wBitCount = bmih.biBitCount; <br>            switch (wBitCount) { <br>                case 16: <br>                case 32: <br>                    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(DWORD)*3; <br>                    break; <br>                case 24: <br>                    sizBMI = sizeof(BITMAPINFOHEADER); <br>                    break; <br>                default: <br>                    iNumClr = (1 &lt;&lt; wBitCount); <br>                    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*iNumClr; <br>                    break; <br>            } <br>            bCoreHdr = FALSE; <br>        } <br>    } <br> <br>    if ((pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED,sizBMI)) == NULL) { <br>        MessageBox(ghwndMain, GetStringRes(IDS_MALLOCFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        goto ErrExit3; <br>    } <br> <br>    // <br>    // Make sure we pass in a DWORD aligned BitmapInfo to CreateDIBitmap <br>    // Otherwise, exception on the MIPS platform <br>    // CR!!!  Equivalent to memcpy <br>    // <br>    pjTmp = (PBYTE)pbmi; <br> <br>    while(sizBMI--) <br>    { <br>        *(((PBYTE)pjTmp)++) = *(((PBYTE)pbmh)++); <br>    } <br> <br>    pMapFile = (PBYTE)pMapFile + ((BITMAPFILEHEADER *)pMapFile)-&gt;bfOffBits; <br> <br>// !!! Use CreateBitmap for monochrome bitmap? <br> <br>    // <br>    // Select the palette into the DC first before CreateDIBitmap() <br>    // <br>    bSelectDIBPal(hDC, pbmi, bCoreHdr); <br> <br>// !!! We always pass a screen DC to this routine. <br>// !!! Maybe we should pass a metafile DC to this routine too. <br>// !!! The bitmap handle created for the screen DC won't give correct <br>// !!! color for the metafile DC.  So now, we always use the original <br>// !!! DIB info. <br>    if ((hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)pbmi, <br>                        CBM_INIT, pMapFile, pbmi, DIB_RGB_COLORS)) == NULL) { <br>        SetWindowText(ghTextWnd, "Fail in creating DIB bitmap from file!"); <br>        goto ErrExit4; <br>    } <br> <br>    // reset gbUseDIB flag, now that we have opened up a new DIB <br>    gbUseDIB = FALSE; <br> <br>// !!! Always use the DIB info o.w. metafile DC don't get the right color. <br>#if 0 <br>    if (GetDeviceCaps(hDC, BITSPIXEL) &lt; wBitCount) { <br>#endif <br>        gbUseDIB = TRUE; <br>        bFreeDibFile(&amp;gDib); <br>        pFileInfo = &amp;(gDib.rgFileInfo[0]); <br>        pFileInfo-&gt;hFile        = hFile; <br>        pFileInfo-&gt;hMapFile     = hMapFile; <br>        pFileInfo-&gt;lpvMapView   = pMapFileTmp; <br> <br>        gDib.rgpjFrame[0]       = pMapFile; <br>        gDib.rgpbmi[0]          = pbmi; <br>        gDib.rgbCoreHdr[0]      = bCoreHdr; <br>        gDib.ulFrames           = <br>        gDib.ulFiles            = 1; <br>        return (hBitmap); <br>#if 0 <br>    } <br>#endif <br> <br>ErrExit4: <br>    LocalFree(pbmi); <br>ErrExit3: <br>    CloseHandle(hMapFile); <br>ErrExit2: <br>    CloseHandle(hFile); <br>ErrExit1: <br> <br>    return (hBitmap); <br> <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bFreeDibFile <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bFreeDibFile(PDIBDATA pDibData) <br>{ <br>    ULONG               ulFiles; <br>    ULONG               ulFrames; <br>    ULONG               i; <br>    PFILEINFO           pFileInfo; <br> <br>    ulFiles = pDibData-&gt;ulFiles; <br>    ulFrames = pDibData-&gt;ulFrames; <br> <br>    for (i = 0; i &lt; ulFrames; i++) { <br>        LocalFree(pDibData-&gt;rgpjFrame[i]); <br>        LocalFree(pDibData-&gt;rgpbmi[i]); <br>    } <br> <br>    for (i = 0; i &lt; ulFiles; i++) { <br>        pFileInfo = &amp;(pDibData-&gt;rgFileInfo[i]); <br>        CloseHandle(pFileInfo-&gt;hFile); <br>        CloseHandle(pFileInfo-&gt;hMapFile); <br>        UnmapViewOfFile(pFileInfo-&gt;lpvMapView); <br>    } <br> <br>    pDibData-&gt;ulFiles = 0; <br>    pDibData-&gt;ulFrames = 0; <br>    return TRUE; <br>} <br> <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bGetBMP <br>* <br>* Effects: call common dialog and pass the filename to hBmpLoadBitmapFile <br>*          return TRUE if successful, FALSE otherwise <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bGetBMP(HWND hwnd, BOOL bMask) { <br>    OPENFILENAME    ofn; <br>    char            szFile[256], szFileTitle[256]; <br>    static char     *szFilter; <br>    BOOL            bSuccess; <br>    HDC             hDC; <br> <br>    bSuccess = FALSE; <br> <br>    BuildFilterStrs(-1); <br>    BuildFilterStrs(IDS_FT_DIB); <br>    szFilter = BuildFilterStrs(IDS_FT_RLE); <br> <br>    strcpy(szFile, "*.bmp\0"); <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = hwnd; <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = (LPSTR) NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = szFile; <br>    ofn.nMaxFile = sizeof(szFile); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = NULL; <br>    ofn.lpstrTitle = (bMask ? GetStringRes(IDS_LDMSK) : "Load Bitmap"); <br>    ofn.Flags = 0L; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = "BMP"; <br> <br>    if (!GetOpenFileName(&amp;ofn)) <br>        return 0L; <br> <br>    hDC = GetDC(ghwndDrawSurf); <br>    if (bMask) { <br>        ghBmpMask = hBmpLoadBitmapFile(hDC, szFile); <br>        if (ghBmpMask != NULL) <br>            bSuccess = TRUE; <br>    } else { <br>        ghBmp = hBmpLoadBitmapFile(hDC, szFile); <br>        if (ghBmp != NULL) <br>            bSuccess = TRUE; <br>    } <br>    ReleaseDC(ghwndDrawSurf, hDC); <br> <br>    return bSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bHitTest <br>* <br>* Effects:  Enumerates metafile records <br>*           Calling bDoHitTest to process each record found. <br>*               The mouse position is passed to the bDoHitTest <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bHitTest(HDC hDC, INT x, INT y) { <br>    BOOL          bSuccess; <br>    ENHMETAHEADER EnhMetaHdr; <br>    RECT          rcClientDS; <br>    HTDATA        htData; <br>    static        HCURSOR hCurHT, hCurWait; <br> <br>    bSuccess = TRUE; <br> <br>    if (ghMetaf == 0) <br>        return 0L; <br> <br>    hCurHT = LoadCursor(NULL, IDC_CROSS); <br>    hCurWait = LoadCursor(NULL, IDC_WAIT); <br> <br>    GetEnhMetaFileHeader(ghMetaf, sizeof(EnhMetaHdr), &amp;EnhMetaHdr); <br> <br>    htData.point.x = x; <br>    htData.point.y = y; <br>    htData.iRecord = EnhMetaHdr.nRecords; <br> <br>    SetCursor(hCurWait); <br>    if (gbFit2Wnd) { <br>        GetClientRect(ghwndDrawSurf, &amp;rcClientDS); <br>        EnumEnhMetaFile(hDC, ghMetaf, (ENHMFENUMPROC)bDoHitTest, (LPVOID) &amp;htData, (LPRECT)&amp;rcClientDS); <br>    } else { <br>        RECT rc; <br> <br>        rc.top = rc.left = 0; <br>        rc.right = EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left; <br>        rc.bottom = EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top; <br>        EnumEnhMetaFile(hDC, ghMetaf, (ENHMFENUMPROC)bDoHitTest, (LPVOID) &amp;htData, (LPRECT)&amp;rc); <br>    } <br>    SetCursor(hCurHT); <br> <br>    return bSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bDoHitTest <br>* <br>* Effects:      Play all records related to transformation <br>*               Remember new mouse position if the record is a MoveTo <br>*               Convert rectangle, ellipse, lineto and bezier to path <br>*               Widen the path and convert it to region. <br>*               Test if the mouse position is inside the region. <br>* <br>* Warnings:     Only handle rectangle, ellipse, line and polybezier <br>* <br>\**************************************************************************/ <br> <br>BOOL APIENTRY bDoHitTest(HDC hDC, LPHANDLETABLE lpHandleTable, <br>                                  LPENHMETARECORD lpEnhMetaRecord, <br>                                  UINT nHandles, <br>                                  LPVOID lpData) { <br>    BOOL            bSuccess; <br>    char            ach[128]; <br>    char            achTmp[128]; <br>    POINT           PtOrg; <br>    LONG            lNumDword; <br>    XFORM           xfSave; <br>    SIZE            SizeWndEx, SizeViewEx; <br>    POINT           ptWndOrgin, ptViewOrgin; <br>    int             i, iMode; <br>    HRGN            hRgn; <br>    PPOINT          pPt, pPtTmp; <br>    static HGDIOBJ  hObjOld=NULL; <br>    static LONG     lCurX=0; <br>    static LONG     lCurY=0; <br>    static BOOL     bXform=FALSE; <br>    static int      iCnt=0; <br> <br>    iCnt++; <br> <br>    // <br>    // select a wide pen for widen path later on <br>    // <br>    hObjOld = SelectObject(hDC, ghpnWide); <br> <br>    // <br>    // save the mouse hit position, this was passed in as a POINT structure <br>    // <br>    PtOrg.x = (((HTDATA *)lpData)-&gt;point).x; <br>    PtOrg.y = (((HTDATA *)lpData)-&gt;point).y; <br> <br>    // <br>    // save the number of parameters for the GDI fcn concerned in DWORD. <br>    // This is the total size of metafile record in question less the <br>    // size of the GDI function <br>    // <br>    lNumDword = (lpEnhMetaRecord-&gt;nSize-8) / 4; <br> <br>    switch (lpEnhMetaRecord-&gt;iType) { <br>    case EMR_SETWINDOWEXTEX: <br>    case EMR_SETWINDOWORGEX: <br>    case EMR_SETVIEWPORTEXTEX: <br>    case EMR_SETVIEWPORTORGEX: <br>    case EMR_SETMAPMODE: <br>    case EMR_SCALEVIEWPORTEXTEX: <br>    case EMR_SCALEWINDOWEXTEX: <br>    case EMR_SETMETARGN: <br>    case EMR_SAVEDC: <br>    case EMR_RESTOREDC: <br>    case EMR_SETWORLDTRANSFORM: <br>    case EMR_MODIFYWORLDTRANSFORM: { <br>        // <br>        // play all records related to transformation &amp; font <br>        // <br>        PlayEnhMetaFileRecord(hDC, lpHandleTable, <br>                                   lpEnhMetaRecord, nHandles); <br>        bXform = TRUE; <br>        return TRUE; <br>    } <br>    // <br>    // convert the following GDI calls to path for hit testing <br>    // <br>    case EMR_RECTANGLE: { <br>        BeginPath(hDC); <br>        Rectangle(hDC, lpEnhMetaRecord-&gt;dParm[0], lpEnhMetaRecord-&gt;dParm[1], <br>                       lpEnhMetaRecord-&gt;dParm[2], lpEnhMetaRecord-&gt;dParm[3]); <br>        EndPath(hDC); <br>        break; <br>    } <br>    case EMR_ELLIPSE: { <br>        BeginPath(hDC); <br>        Ellipse(hDC, lpEnhMetaRecord-&gt;dParm[0], lpEnhMetaRecord-&gt;dParm[1], <br>                     lpEnhMetaRecord-&gt;dParm[2], lpEnhMetaRecord-&gt;dParm[3]); <br>        EndPath(hDC); <br>        break; <br>    } <br>    case EMR_MOVETOEX: { <br>        // <br>        // Remember our current position <br>        // <br>        lCurX = lpEnhMetaRecord-&gt;dParm[0]; <br>        lCurY = lpEnhMetaRecord-&gt;dParm[1]; <br>        return TRUE; <br>    } <br>    case EMR_LINETO: { <br>        BeginPath(hDC); <br>        MoveToEx(hDC, lCurX, lCurY, NULL); <br>        LineTo(hDC, lpEnhMetaRecord-&gt;dParm[0], lpEnhMetaRecord-&gt;dParm[1]); <br>        EndPath(hDC); <br>        break; <br>    } <br>    case EMR_POLYBEZIER16: { <br>        int         i; <br>        LONG        lSize; <br>        LONG        lPtCnt; <br> <br>        lPtCnt = lpEnhMetaRecord-&gt;dParm[4]; <br>        lSize = lPtCnt * sizeof(POINTL); <br> <br>        if ((pPt = (PPOINT) LocalAlloc(LMEM_FIXED, lSize)) == NULL) { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_MALLOCFAILNOHIT)); <br>            return TRUE; <br>        } <br> <br>        pPtTmp = pPt; <br> <br>        for (i=0; i &lt; (INT) lPtCnt; i++, pPtTmp++) { <br>            pPtTmp-&gt;x = (LONG)(LOWORD(lpEnhMetaRecord-&gt;dParm[i+5])); <br>            pPtTmp-&gt;y = (LONG)(HIWORD(lpEnhMetaRecord-&gt;dParm[i+5])); <br>        } <br> <br>        BeginPath(hDC); <br>        PolyBezier(hDC, (LPPOINT)pPt, (DWORD) lPtCnt); <br>        EndPath(hDC); <br>        LocalFree(pPt); <br>        break; <br>    } <br>    default: <br>        wsprintf((LPSTR) ach, GetStringRes(IDS_FMT_NOHTST), rgMetaName[lpEnhMetaRecord-&gt;iType]); <br>        SetWindowText(ghTextWnd, ach); <br>        return TRUE; <br>    }   //switch <br> <br>    if (bXform) { <br>        // <br>        // Set World transform to identity temporarily so that pen width <br>        // is not affected by world to page transformation <br>        // <br>        GetWorldTransform(hDC, &amp;xfSave); <br>        ModifyWorldTransform(hDC, NULL, MWT_IDENTITY); <br> <br>        // <br>        // Set Page transform to identity temporarily so that pen width <br>        // is not affected by page to device transformation <br>        // <br>        iMode = GetMapMode(hDC); <br> <br>        if ((iMode == MM_ISOTROPIC) || (iMode == MM_ANISOTROPIC)) { <br>            GetWindowOrgEx(hDC, &amp;ptWndOrgin); <br>            GetWindowExtEx(hDC, &amp;SizeWndEx); <br>            GetViewportExtEx(hDC, &amp;SizeViewEx); <br>            GetViewportOrgEx(hDC, &amp;ptViewOrgin); <br>        } <br> <br>        SetMapMode(hDC, MM_TEXT); <br>    } <br> <br>    WidenPath(hDC); <br> <br>    hRgn = PathToRegion(hDC); <br> <br>    if (hRgn == 0) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_NULLRGNHTSTFAIL)); <br>        DeleteObject(hRgn); <br>        return TRUE; <br>    } <br>    //DPtoLP(hDC, &amp;PtOrg, 1); <br>    //SetPixel(hDC, PtOrg.x, PtOrg.y, RGB(0, 255, 0)); <br>    // <br>    // test if mouse hit position is in region <br>    // <br>    bSuccess = PtInRegion(hRgn, PtOrg.x, PtOrg.y); <br>    //Temporily comment this out <br>    FillRgn(hDC, hRgn, ghbrRed); <br>    DeleteObject(hRgn); <br>    // </code></pre>
<p>
</p>
<pre><code>// Set transform back. <br>    // <br>    if (bXform) { <br>        SetWorldTransform(hDC, &amp;xfSave); <br>        SetMapMode(hDC, iMode); <br> <br>        if ((iMode == MM_ISOTROPIC) || (iMode == MM_ANISOTROPIC)) { <br>            SetWindowOrgEx(hDC, ptWndOrgin.x, ptWndOrgin.y, NULL); <br>            SetWindowExtEx(hDC, SizeWndEx.cx, SizeWndEx.cy, NULL); <br>            SetViewportExtEx(hDC, SizeViewEx.cx, SizeViewEx.cy, NULL); <br>            SetViewportOrgEx(hDC, ptViewOrgin.x, ptViewOrgin.y, NULL); <br>        } <br>    } <br> <br>    if (bSuccess) { <br>        Beep(440, 500); <br>        // <br>        // Reporting the metafile record number.  Then reset counter. <br>        // <br>        SetDlgItemInt(ghwndCtrlPanel, DID_COUNTER, iCnt, FALSE); <br>        iCnt=0; <br>        wsprintf((LPSTR) ach, GetStringRes(IDS_FMT_HIT), rgMetaName[lpEnhMetaRecord-&gt;iType]); <br> <br>        for (i=0; i &lt; lNumDword; i++) { <br>            wsprintf((LPSTR) achTmp, "%ld ", lpEnhMetaRecord-&gt;dParm[i]); <br>            if ((strlen(ach)+strlen(achTmp))/sizeof(char) &gt;= 128) <br>                break; <br>            strcat(ach, achTmp); <br>        } <br> <br>        SetWindowText(ghTextWnd, ach); <br>        SelectObject(hDC, hObjOld); <br>        bXform = FALSE; <br>        return FALSE; <br>    } <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_NOHIT)); <br>    if (iCnt &gt;= ((HTDATA *)lpData)-&gt;iRecord) <br>        iCnt = 0; <br>    return TRUE; <br> <br>    UNREFERENCED_PARAMETER(lpHandleTable); <br>    UNREFERENCED_PARAMETER(nHandles); <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bChooseNewFont <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bChooseNewFont(HWND hwnd, PLOGFONT plf, COLORREF *pClrRef) { <br>   HDC                  hDC; <br>   static CHOOSEFONT    chf; <br>   static BOOL          bInit=TRUE; <br> <br> <br>   if (bInit) { <br>        bInit = FALSE; <br> <br>        hDC = GetDC( hwnd ); <br>        chf.hDC = CreateCompatibleDC( hDC ); <br>        ReleaseDC( hwnd, hDC ); <br> <br>        chf.lStructSize = sizeof(CHOOSEFONT); <br>        chf.hwndOwner = hwnd; <br>        chf.lpLogFont = plf; <br>        chf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT; <br>        chf.rgbColors = *pClrRef; <br>        chf.lCustData = 0; <br>        chf.hInstance = (HANDLE)NULL; <br>        chf.lpszStyle = (LPSTR)NULL; <br>        chf.nFontType = SCREEN_FONTTYPE; <br>        chf.nSizeMin = 0; <br>        chf.nSizeMax = 0; <br>        chf.lpfnHook = (LPCFHOOKPROC)NULL; <br>        chf.lpTemplateName = (LPSTR)NULL; <br>   } <br> <br>   if (ChooseFont( &amp;chf ) == FALSE ) { <br>        DeleteDC( hDC ); <br>return FALSE; <br>   } <br> <br>   *pClrRef = chf.rgbColors; <br> <br>   DeleteDC( hDC ); <br>   return (TRUE); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bChooseNewColor <br>* <br>* Effects:  Returns TRUE if successful; lpdwRGB points the color selected. <br>*           Otherwise, FALSE. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bChooseNewColor(HWND hwnd, LPDWORD lpdwRGB) { <br>    static DWORD argbCust[16] = { <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255), <br>        RGB(255, 255, 255), RGB(255, 255, 255) <br>    }; <br>    CHOOSECOLOR cc; <br>    BOOL bResult; <br> <br>    cc.lStructSize = sizeof(CHOOSECOLOR); <br>    cc.hwndOwner = hwnd; <br>    cc.hInstance = ghModule; <br>    cc.rgbResult = *lpdwRGB; <br>    cc.lpCustColors = argbCust; <br>    cc.Flags = CC_RGBINIT | CC_SHOWHELP; <br>    cc.lCustData = 0; <br>    cc.lpfnHook = NULL; <br>    cc.lpTemplateName = NULL; <br> <br>    bResult = ChooseColor(&amp;cc); <br> <br>    if (bResult) { <br>        *lpdwRGB = cc.rgbResult; <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* hBrCreateBrush <br>* <br>* Effects: Creates a brush with the specified RGB <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>HBRUSH hBrCreateBrush(HDC hDC, DWORD dwRGB) <br>{ <br>    HDC hdcMem; <br>    HBRUSH hbr; <br>    HBRUSH hbrOld; <br>    HBITMAP hbmPat; <br>    HBITMAP hbmOld; <br> <br>    hbr = CreateSolidBrush(dwRGB); <br>    hdcMem = CreateCompatibleDC(hDC); <br> <br>    // <br>    // Minimum size for a bitmap to be used in a fill pattern is 8x8 <br>    // <br>    hbmPat = CreateCompatibleBitmap(hDC, 8, 8); <br> <br>    hbmOld = SelectObject(hdcMem, hbmPat); <br>    hbrOld = SelectObject(hdcMem, hbr); <br>    PatBlt(hdcMem, 0, 0, 8, 8, PATCOPY); <br> <br>    // <br>    // Deselect hbmPat and hbr <br>    // <br>    SelectObject(hdcMem, hbmOld); <br>    SelectObject(hdcMem, hbrOld); <br> <br>    DeleteDC(hdcMem); <br>    DeleteObject(hbr); <br> <br>    hbr = CreatePatternBrush(hbmPat); <br> <br>    DeleteObject(hbmPat); <br> <br>    return hbr; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPrintMf  Brings up the print dialog for printer setup and then <br>*           starts printing the enhanced metafile. <br>* <br>*           pPD     Points to a PRTDATA structure that contains the <br>*                   the handle for the Enh. Metafile for printing. <br>* <br>* Effects:  Returns TRUE if sucessful.  Otherwise, it is FALSE. <br>*           GlobalFree pPD when exits. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bPrintMf(PPRTDATA pPD) { <br>    DOCINFO         DocInfo; <br>    HDC             hDCPrinter; <br>    ENHMETAHEADER   EnhMetaHdr; <br>    HENHMETAFILE    hEnhMf; <br>    TCHAR           buf[128]; <br>    PRINTDLG        pd; <br>    BOOL            bSuccess; <br>    int             iEntries; <br>    PLOGPALETTE     plogPal; <br>    PBYTE           pjTmp; <br>    HPALETTE        hPal; <br>    BOOL            bRCSet = FALSE; <br> <br> <br>    bSuccess = TRUE; <br> <br>    if (pPD-&gt;hMetaf == 0) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_NOMFTOPRT)); <br>        goto PMF_EXIT; <br>        bSuccess = FALSE; <br>    } <br> <br>    hEnhMf = CopyEnhMetaFile(pPD-&gt;hMetaf, NULL); <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize = sizeof(PRINTDLG); <br>    pd.hwndOwner   = ghwndMain; <br>    pd.Flags       = PD_RETURNDC; <br>    pd.hInstance   = ghModule; <br> <br>    if (!PrintDlg(&amp;pd)) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_ESCPRT)); <br>        goto PMF_EXIT; <br>        bSuccess = FALSE; <br>    } <br> <br>    if (pd.hDC == NULL) { <br>        SetWindowText(ghTextWnd, GetStringRes(IDS_CREPRTDCFAIL)); <br>        goto PMF_EXIT; <br>        bSuccess = FALSE; <br>    } <br> <br>    hDCPrinter = pd.hDC; <br>    if (GetEnhMetaFileDescription(hEnhMf, 128, (LPTSTR)buf) == 0) { <br>        strcpy(buf, "No Title"); <br>    } <br> <br>    memset(&amp;DocInfo, 0, sizeof(DOCINFO)); <br>    DocInfo.cbSize      = sizeof(DOCINFO); <br>    DocInfo.lpszDocName = (LPTSTR) buf; <br>    DocInfo.lpszOutput  = NULL; <br>    StartDoc(hDCPrinter, &amp;DocInfo); <br>    StartPage(hDCPrinter); <br> <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_PRT)); <br> <br>    iEntries = GetEnhMetaFilePaletteEntries(hEnhMf, 0, NULL); <br> <br>    if (iEntries) { <br>        if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>                sizeof(DWORD) + sizeof(PALETTEENTRY)*iEntries )) == NULL) { <br>            MessageBox(ghwndMain, GetStringRes(IDS_CREPALFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>        } <br> <br>        plogPal-&gt;palVersion = 0x300; <br>        plogPal-&gt;palNumEntries = (WORD) iEntries; <br>        pjTmp = (PBYTE) plogPal; <br>        pjTmp += 4; <br> <br>        GetEnhMetaFilePaletteEntries(hEnhMf, iEntries, (PPALETTEENTRY)pjTmp); <br>        hPal = CreatePalette(plogPal); <br>        GlobalFree(plogPal); <br> <br>        SelectPalette(hDCPrinter, hPal, FALSE); <br>        RealizePalette(hDCPrinter); <br>    } <br> <br>    GetEnhMetaFileHeader(hEnhMf, sizeof(ENHMETAHEADER), &amp;EnhMetaHdr); <br> <br> <br>    bRCSet = bSetRC2MatchEmfRC(hDCPrinter, EnhMetaHdr, hEnhMf, NULL); <br>    if (!bRCSet) { <br>        vErrOut("bPrintMF: failed"); <br>    } <br> <br>    if (pPD-&gt;bFit2Wnd) { <br>        int     iWidth, iHeight; <br>        RECT    rc; <br> <br>        iWidth = GetDeviceCaps(hDCPrinter, HORZRES); <br>        iHeight = GetDeviceCaps(hDCPrinter, VERTRES); <br>        rc.left = rc.top = 0; <br>        rc.right = iWidth; <br>        rc.bottom = iHeight; <br>        bSuccess = PlayEnhMetaFile(hDCPrinter, hEnhMf, (LPRECT) &amp;rc); <br>        if (!bSuccess) { <br>            char    text[128]; <br> <br>            wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>            OutputDebugString(text); <br>        } <br> <br> <br>    } else { <br>        RECT rc; <br> <br>        rc.top = rc.left = 0; <br>        rc.right = EnhMetaHdr.rclBounds.right - EnhMetaHdr.rclBounds.left; <br>        rc.bottom = EnhMetaHdr.rclBounds.bottom - EnhMetaHdr.rclBounds.top; <br>        bSuccess = PlayEnhMetaFile(hDCPrinter, hEnhMf, (LPRECT) &amp;rc); <br>        if (!bSuccess) { <br>            char    text[128]; <br> <br>            wsprintf(text, GetStringRes(IDS_FMT_PLAYEMFFAIL), GetLastError()); <br>            OutputDebugString(text); <br>        } <br>    } <br> <br>//    if (gbDB &amp;&amp; bSuccess) <br>//       SwapBuffers(hDCPrinter); <br> <br>    EndPage(hDCPrinter); <br>    EndDoc(hDCPrinter); <br>    SetWindowText(ghTextWnd, GetStringRes(IDS_PRTTHRDDONE)); <br> <br>    if (bRCSet) { <br>        bCleanUpRC(); <br>    } <br> <br> <br>PMF_EXIT: <br> <br>    ExitThread(0); <br>    return bSuccess; <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bSelectDIBPal <br>* <br>* Effects: Creates a logical palette from the DIB and select it into the DC <br>*          and realize the palette. Saving the hPal in the ghPal <br>* <br>* Warnings: Based on Windows NT DIB support.  If PM support 16,24,32 bpp <br>*           we need to modify this routine. <br>*           Global alert! ghPal is changed here... <br>* <br>\**************************************************************************/ <br> <br>BOOL bSelectDIBPal(HDC hDC, LPBITMAPINFO pbmi, BOOL bCoreHdr) <br>{ <br>  LOGPALETTE    *plogPal; <br>  UINT          uiSizPal; <br>  INT           i, iNumClr; <br>  WORD          wBitCount; <br> <br>  if (bCoreHdr) { <br>    wBitCount = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcBitCount; <br>  } else { <br>    wBitCount = pbmi-&gt;bmiHeader.biBitCount; <br>  } <br> <br>  switch (wBitCount) { <br>    case 16: <br>    case 24: <br>    case 32:                            // Does PM supports these? <br>        return FALSE; <br>    default: <br>        iNumClr = (1 &lt;&lt; wBitCount); <br>        break; <br>  } <br> <br>  uiSizPal = sizeof(WORD)*2 + sizeof(PALETTEENTRY)*iNumClr; <br>  if ((plogPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED,uiSizPal)) == NULL) { <br>      MessageBox(ghwndMain, GetStringRes(IDS_ALLOCPALFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>      ghPal = NULL; <br>      return FALSE; <br>  } <br> <br>  plogPal-&gt;palVersion = 0x300; <br>  plogPal-&gt;palNumEntries = (WORD) iNumClr; <br> <br>  if (bCoreHdr) { <br>    for (i=0; i&lt;iNumClr; i++) { <br>        plogPal-&gt;palPalEntry[i].peRed   = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciColors[i].rgbtRed; <br>        plogPal-&gt;palPalEntry[i].peGreen = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciColors[i].rgbtGreen; <br>        plogPal-&gt;palPalEntry[i].peBlue  = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciColors[i].rgbtBlue; <br>        plogPal-&gt;palPalEntry[i].peFlags = PC_RESERVED; <br>    } <br>  } else { <br>    for (i=0; i&lt;iNumClr; i++) { <br>        plogPal-&gt;palPalEntry[i].peRed   = pbmi-&gt;bmiColors[i].rgbRed; <br>        plogPal-&gt;palPalEntry[i].peGreen = pbmi-&gt;bmiColors[i].rgbGreen; <br>        plogPal-&gt;palPalEntry[i].peBlue  = pbmi-&gt;bmiColors[i].rgbBlue; <br>        plogPal-&gt;palPalEntry[i].peFlags = PC_RESERVED; <br>    } <br>  } <br> <br>  DeleteObject(ghPal); <br>  ghPal = CreatePalette((LPLOGPALETTE)plogPal); <br>  if ((ghPal) == NULL) { <br>      MessageBox(ghwndMain, GetStringRes(IDS_CREPALFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>      return FALSE; <br>  } <br> <br>  if ((GetDeviceCaps(hDC, RASTERCAPS)) &amp; RC_PALETTE) { <br>    SelectPalette(hDC, ghPal, FALSE); <br>    RealizePalette(hDC); <br>  } <br> <br>  GlobalFree(plogPal); <br> <br>  return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPlgBlt <br>* <br>* Effects:  If Source DIB bpp &gt; Destination DC's <br>*           use Halftone for PlgBlt. <br>* <br>* Warnings: Global Alert! <br>*           gbUseDIB is always TRUE now. <br>* <br>\**************************************************************************/ <br> <br>BOOL bPlgBlt(HDC hDC, LPPOINT rgPtsBMP) <br>{ <br>    HDC                  hDCRef; <br>    HDC                  hDCSrn;                // hDC can be metaf DC <br>    HGDIOBJ              hObjOld, hBmpMem; <br>    BITMAP               bm; <br>    INT                  iBpp; <br>    WORD                 wBitCnt; <br> <br> <br>    hDCSrn = GetDC(ghwndDrawSurf); <br>    hDCRef = CreateCompatibleDC(hDC); <br> <br>    if (gbUseDIB) { <br>        int         cx, cy, dx, dy; <br>        PBITMAPINFO pbmi; <br> <br>        pbmi = (gDib.rgpbmi[0]); <br>        dx = rgPtsBMP[0].x - rgPtsBMP[1].x; <br>        dy = rgPtsBMP[0].y - rgPtsBMP[1].y; <br>        cx = (INT) sqrt( dx * dx + dy * dy ); <br> <br>        dx = rgPtsBMP[0].x - rgPtsBMP[2].x; <br>        dy = rgPtsBMP[0].y - rgPtsBMP[2].y; <br>        cy = (INT) sqrt( dx * dx + dy * dy ); <br> <br>        iBpp = GetDeviceCaps(hDC, BITSPIXEL); <br> <br>        if (gDib.rgbCoreHdr[0]) { <br>            wBitCnt = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcBitCount; <br>        } else { <br>            wBitCnt = pbmi-&gt;bmiHeader.biBitCount; <br>        } <br> <br>        if (iBpp &lt; wBitCnt) {   // Do Halftone <br>            SetStretchBltMode(hDCRef, HALFTONE); <br>            if (ghHT) { <br>                SelectPalette(hDCRef, ghHT, FALSE); <br>                SelectPalette(hDC, ghHT, FALSE); <br>                SelectPalette(hDCSrn, ghHT, FALSE); // hDC can be metaf DC <br>                RealizePalette(hDCSrn);             // always realize the srn DC <br> <br>                // Don't have to realize the palette in hDCRef <br>                // RealizePalette(hDCRef); <br> <br>                // has to be compatible with screen DC, cannot be hDCRef <br>                // memory DC has no bitmap by default? <br>                // hDC may be a metafile DC, so use hDCSrn <br>                hBmpMem = CreateCompatibleBitmap(hDCSrn, cx, cy); <br>                SelectObject(hDCRef, hBmpMem); <br>            } else { <br>                MessageBox(ghwndMain, GetStringRes(IDS_HFTONEPALNULL), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>            } <br>        } else { <br>            SetStretchBltMode(hDCRef, COLORONCOLOR); <br>            if (ghPal) { <br>                if (ghDCMetaf == hDC) <br>                    CopyPalette(ghPal); <br>                SelectPalette(hDCRef, ghPal, FALSE); <br>                SelectPalette(hDC, ghPal, FALSE); <br>                SelectPalette(hDCSrn, ghPal, FALSE); // hDC can be metaf DC <br>                RealizePalette(hDCSrn);             // always realize the srn DC <br> <br>                // Don't have to realize the palette in hDCRef <br>                // RealizePalette(hDCRef); <br> <br>                // has to be compatible with screen DC, cannot be hDCRef <br>                // memory DC has no bitmap by default? <br>                // hDC may be a metafile DC, so use hDCSrn <br>                hBmpMem = CreateCompatibleBitmap(hDCSrn, cx, cy); <br>                SelectObject(hDCRef, hBmpMem); <br>            } else { <br>                MessageBox(ghwndMain, GetStringRes(IDS_PALNULL), <br>                    GetStringRes(IDS_ERROR), MB_OK); <br>            } <br>        } <br> <br>        if (gDib.rgbCoreHdr[0]) { <br>            StretchDIBits(hDCRef, 0,0, cx, cy, <br>                          0,0, ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcWidth, ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcHeight, <br>                          gDib.rgpjFrame[0], pbmi, DIB_RGB_COLORS, SRCCOPY); <br>        } else { <br>            StretchDIBits(hDCRef, 0,0, cx, cy, <br>                          0,0, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight, <br>                          gDib.rgpjFrame[0], pbmi, DIB_RGB_COLORS, SRCCOPY); <br>        } <br> <br>        PlgBlt(hDC, rgPtsBMP, hDCRef, 0, 0, cx, cy, <br>               ghBmpMask, 0, 0); <br> <br>        DeleteObject(hBmpMem); <br> <br>    } else { <br>        hObjOld = SelectObject(hDCRef, ghBmp); <br> <br>        GetObject(ghBmpMask, sizeof(BITMAP), (LPSTR)&amp;bm); <br>        if (bm.bmBitsPixel != 1) { <br>            SetWindowText(ghTextWnd, GetStringRes(IDS_MUSTMSKMCHROMEBM)); <br>            ghBmpMask = NULL; <br>        } <br> <br>        GetObject(ghBmp, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>        if (ghPal) { <br>            SelectPalette(hDC, ghPal, FALSE); <br>            RealizePalette(hDC); <br>            SetStretchBltMode(hDC, COLORONCOLOR); <br>        } <br>        PlgBlt(hDC, rgPtsBMP, hDCRef, 0, 0, bm.bmWidth, bm.bmHeight, <br>               ghBmpMask, 0, 0); <br> <br>        SelectObject(hDCRef, hObjOld); <br>    } <br> <br>    DeleteDC(hDCRef); <br>    ReleaseDC(ghwndDrawSurf, hDCSrn); <br>    return TRUE; <br> <br>} <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* HPALETTE CopyPalette <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>HPALETTE CopyPalette(HPALETTE hPalSrc) <br>{ <br>    PLOGPALETTE     plogPal; <br>    PBYTE           pjTmp; <br>    int             iNumEntries=0; <br>    HPALETTE        hPal; <br> <br>    if ((iNumEntries = GetPaletteEntries(hPalSrc, 0, iNumEntries, NULL)) == 0) { <br>        MessageBox(ghwndMain, GetStringRes(IDS_NOPALENTRYFORCPY), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        return (HPALETTE) NULL; <br>    } <br> <br>    if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>            sizeof(DWORD) + sizeof(PALETTEENTRY)*iNumEntries )) == NULL) { <br>        MessageBox(ghwndMain, GetStringRes(IDS_CPYPALFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        return (HPALETTE) NULL; <br>    } <br> <br>    plogPal-&gt;palVersion = 0x300; <br>    plogPal-&gt;palNumEntries = (WORD) iNumEntries; <br>    pjTmp = (PBYTE) plogPal; <br>    pjTmp += 4; <br>    GetPaletteEntries(hPalSrc, 0, iNumEntries, (PPALETTEENTRY)pjTmp); <br>    hPal = CreatePalette(plogPal); <br> <br>    GlobalFree(plogPal); <br> <br>    return hPal; <br>} <br> <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* iTT <br>* <br>* Effects: set the global variable gbTT if the family is true type <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>int CALLBACK iTT( <br>    LPLOGFONT    lpLF, <br>    LPTEXTMETRIC lpTM, <br>    DWORD        dwFontType, <br>    LPARAM       lpData) <br>{ <br> <br>    if (lpTM-&gt;tmPitchAndFamily &amp; TMPF_TRUETYPE) { <br>        //OutputDebugString("TRUETYPE\n"); <br>        *((BOOL *)lpData) = TRUE; <br>    } else { <br>        //OutputDebugString("NON-TRUETYPE\n"); <br>        *((BOOL *)lpData) = FALSE; <br>    } <br> <br>#if 0 <br>    // <br>    // that's equivalent <br>    // <br>    if (dwFontType &amp; TRUETYPE_FONTTYPE) { <br>        //OutputDebugString("TRUETYPE\n"); <br>        *((BOOL *)lpData) = TRUE; <br>    } else { <br>        //OutputDebugString("NON-TRUETYPE\n"); <br>        *((BOOL *)lpData) = FALSE; <br>    } <br>#endif <br>    return 0; <br> <br>    UNREFERENCED_PARAMETER (lpLF); <br>    //UNREFERENCED_PARAMETER (lpTM); <br>    UNREFERENCED_PARAMETER (dwFontType); <br> <br>} <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* CMTMLTFMT *pLoadMltFmtFile(VOID) <br>* <br>* Effects:  Load either EPS or enh mf <br>* <br>* Warnings: CR! change this to load multiple def of picture <br>* <br>\**************************************************************************/ <br> <br>CMTMLTFMT *pLoadMltFmtFile(VOID) <br>{ <br>    OPENFILENAME    ofn; <br>    char            szDirName[256]; <br>    char            szFile[256], szFileTitle[256]; <br>    static char     *szFilter; <br>    HANDLE          hFile, hMapFile; <br>    LPVOID          pMapFile; <br>    DWORD           dwFileSizeLow, dwFileSizeHigh; <br>    CMTMLTFMT       *pMfmt; <br> <br>    pMfmt = (CMTMLTFMT*)NULL; <br> <br>    BuildFilterStrs(-1); <br>    BuildFilterStrs(IDS_FT_EPS); <br>    szFilter = BuildFilterStrs(IDS_FT_EMF); <br> <br>    GetSystemDirectory((LPSTR) szDirName, 256); <br>    strcpy(szFile, "*.eps\0"); <br>    ofn.lStructSize = sizeof(OPENFILENAME); <br>    ofn.hwndOwner = GetFocus(); <br>    ofn.lpstrFilter = szFilter; <br>    ofn.lpstrCustomFilter = (LPSTR) NULL; <br>    ofn.nMaxCustFilter = 0L; <br>    ofn.nFilterIndex = 1; <br>    ofn.lpstrFile = szFile; <br>    ofn.nMaxFile = sizeof(szFile); <br>    ofn.lpstrFileTitle = szFileTitle; <br>    ofn.nMaxFileTitle = sizeof(szFileTitle); <br>    ofn.lpstrInitialDir = szDirName; <br>    ofn.lpstrTitle = (LPSTR) NULL; <br>    ofn.Flags = 0L; <br>    ofn.nFileOffset = 0; <br>    ofn.nFileExtension = 0; <br>    ofn.lpstrDefExt = "EPS"; <br> <br>    if (!GetOpenFileName(&amp;ofn)) { <br>        goto EXIT; <br>    } <br> <br>    if ((hFile = CreateFile(szFile, GENERIC_READ, FILE_SHARE_READ, NULL, <br>            OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL)) == (HANDLE)-1) { <br>        goto EXIT; <br>    } <br> <br>    dwFileSizeLow = GetFileSize(hFile, &amp;dwFileSizeHigh); <br>    if ((dwFileSizeLow == 0xFFFFFFFF) &amp;&amp; (GetLastError() != NO_ERROR)) { <br>        goto EXIT; <br>    } <br> <br>    // <br>    // Create a map file of the opened file <br>    // <br>    if ((hMapFile = CreateFileMapping(hFile, NULL, <br>                             PAGE_READONLY, 0, 0, NULL)) == (HANDLE)-1) { <br>        goto EXIT2; <br>    } <br> <br>    // <br>    // Map a view of the whole file <br>    // <br>    if ((pMapFile = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0)) == NULL) { <br>        goto EXIT3; <br>    } <br> <br>// <br>// CR!! In future, change this to load different def of the picture... <br>// <br>  { <br>    ULONG       ulSize; <br>    PBYTE       pjTmp; <br>    RECTL       rectl; <br> <br>    ulSize = dwFileSizeLow+sizeof(CMTMLTFMT); <br>    if ((pMfmt = (CMTMLTFMT *) LocalAlloc(LMEM_FIXED, ulSize)) == NULL) { <br>        MessageBox(GetFocus(), GetStringRes(IDS_MALLOCFAIL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        goto EXIT3; <br>    } <br> <br>    pMfmt-&gt;ident = GDICOMMENT_IDENTIFIER; <br>    pMfmt-&gt;iComment = GDICOMMENT_MULTIFORMATS; <br>    pMfmt-&gt;nFormats = 1; <br>    pMfmt-&gt;aemrformat[0].cbData = dwFileSizeLow; <br>    pMfmt-&gt;aemrformat[0].offData = 11*sizeof(DWORD); <br> <br>    // parse for %!PS-Adobe-3.0 EPSF keyword <br>    //           Enhanced Metafile signature <br>    // set EMRFORMAT.dSignature appropiately <br> <br>    if (((ENHMETAHEADER *) pMapFile)-&gt;dSignature == ENHMETA_SIGNATURE) { <br> <br>        pMfmt-&gt;aemrformat[0].dSignature = ENHMETA_SIGNATURE; <br>        pMfmt-&gt;aemrformat[0].nVersion = 0;                    // not for emf <br>        pMfmt-&gt;rclOutput.left   = ((ENHMETAHEADER *) pMapFile)-&gt;rclBounds.left; <br>        pMfmt-&gt;rclOutput.top    = ((ENHMETAHEADER *) pMapFile)-&gt;rclBounds.top; <br>        pMfmt-&gt;rclOutput.right  = ((ENHMETAHEADER *) pMapFile)-&gt;rclBounds.right; <br>        pMfmt-&gt;rclOutput.bottom = ((ENHMETAHEADER *) pMapFile)-&gt;rclBounds.bottom; <br>    } <br>    else    //assume it is Adobe EPS <br>    if (bGetEPSBounds(pMapFile, &amp;rectl)) { <br> <br>        char text[128]; <br> <br> <br>        pMfmt-&gt;aemrformat[0].dSignature = 0x46535045; <br>        pMfmt-&gt;aemrformat[0].nVersion = 1; <br>        pMfmt-&gt;rclOutput.left   = rectl.left; <br>        pMfmt-&gt;rclOutput.top    = rectl.top; <br>        pMfmt-&gt;rclOutput.right  = rectl.right; <br>        pMfmt-&gt;rclOutput.bottom = rectl.bottom; <br> <br>        wsprintf(text, "Bounds = %d %d %d %d", <br>                 rectl.left, rectl.top, rectl.right, rectl.bottom); <br>        MessageBox(GetFocus(), text, "Bounds", MB_OK); <br> <br>    } <br>    else { <br>        // unknown file type <br>        Free(pMfmt); <br>        pMfmt = NULL; <br>        goto EXIT3; <br>    } <br> <br>    pjTmp = (PBYTE)(((DWORD *)pMfmt-&gt;aemrformat)+4); <br>    while (dwFileSizeLow--) { <br>        *(((PBYTE)pjTmp)++) = *(((PBYTE)pMapFile)++); <br>    } <br> <br>  } <br> <br> <br>EXIT3: <br>    CloseHandle(hMapFile); <br>EXIT2: <br>    CloseHandle(hFile); <br>EXIT: <br> <br>    return pMfmt; <br>} <br> <br> <br>HLOCAL Free(CMTMLTFMT *pMfmt) { <br>    return LocalFree(pMfmt); <br>} <br> <br>#define MYDBG 0 <br> <br>BOOL bIsAdobe(char *szStr) <br>{ <br>    if (strcmp(szStr, "%!PS-Adobe-3.0") == 0) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br>BOOL bIsEPS(char *szStr) <br>{ <br>    if ((strcmp(szStr, "EPSF-3.0") == 0) || <br>        (strcmp(szStr, "EPSF-2.0") == 0)) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br>BOOL bIsBndBox(char *szStr) <br>{ <br>    if (strcmp(szStr, "%%BoundingBox:") == 0) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br>BOOL bIsEOF(char *szStr) <br>{ <br>    if (strcmp(szStr, "%%EOF") == 0) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br> <br>BOOL bGetEPSBounds(LPVOID lpData, RECTL *prctl) <br>{ <br>    char szKeyWord[128], szValue[128]; <br>    int  index; <br> <br> <br>    if (lpData == NULL) { <br>#if MYDBG <br>        MessageBox(GetFocus(), GetStringRes(IDS_NULLPTR), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>#endif <br>        return FALSE; <br>    } <br> <br>    index = 0; <br> <br>    if (!bGetWord(lpData, szKeyWord, &amp;index)) <br>        return FALSE; <br> <br>    if (!bIsAdobe(szKeyWord)) { <br>        MessageBox(GetFocus(), GetStringRes(IDS_NOTADOBE), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!bGetWord(lpData, szValue, &amp;index)) <br>        return FALSE; <br> <br>    if (!bIsEPS(szValue)) { <br>        MessageBox(GetFocus(), "Not EPS!", <br>            GetStringRes(IDS_ERROR), MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!bGoNextLine(lpData, &amp;index)) <br>        return FALSE; <br> <br>    while ((bGetWord(lpData, szKeyWord, &amp;index)) &amp;&amp; <br>           (!bIsBndBox(szKeyWord))) { <br>#if MYDBG <br>        MessageBox(GetFocus(), GetStringRes(IDS_SKPTOEOL), <br>            GetStringRes(IDS_ERROR), MB_OK); <br>#endif <br>        if (!bGoNextLine(lpData, &amp;index)) { <br>            MessageBox(GetFocus(), GetStringRes(IDS_MUSTNOTEOF), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            return FALSE; <br>        } <br>    } <br> <br>    if (bIsBndBox(szKeyWord)) { <br>        if (bGetWord(lpData, szValue, &amp;index)) <br>            prctl-&gt;left    = atol(szValue); <br>        else { <br>            MessageBox(GetFocus(), GetStringRes(IDS_GETBNDLFTFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            return FALSE; <br>        } <br> <br>        if (bGetWord(lpData, szValue, &amp;index)) <br>            prctl-&gt;top     = atol(szValue); <br>        else { <br>            MessageBox(GetFocus(), GetStringRes(IDS_GETBNDTOPFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            return FALSE; <br>        } <br> <br>        if (bGetWord(lpData, szValue, &amp;index)) <br>            prctl-&gt;right   = atol(szValue); <br>        else { <br>            MessageBox(GetFocus(), GetStringRes(IDS_GETBNDRGTFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            return FALSE; <br>        } <br> <br>        if (bGetWord(lpData, szValue, &amp;index)) <br>            prctl-&gt;bottom  = atol(szValue); <br>        else { <br>            MessageBox(GetFocus(), GetStringRes(IDS_GETBNDBOTFAIL), <br>                GetStringRes(IDS_ERROR), MB_OK); <br>            return FALSE; <br>        } <br>    } <br> <br>    return TRUE; <br> <br>} <br> <br> <br>BOOL bGetWord(LPVOID lpData, char *str, int* pi) <br>{ <br>    char *pstr; <br> <br>    pstr = str; <br> <br>    while (((char *)lpData)[*pi] == ' ') <br>        (*pi)++; <br> <br>    while ((((char *)lpData)[*pi] != ' ') &amp;&amp; <br>           (((char *)lpData)[*pi] != '\n') &amp;&amp; <br>           (((char *)lpData)[*pi] != '\r')) { <br>        *str++ = ((char *)lpData)[(*pi)++]; <br>    } <br>    *str++ = '\0'; <br> <br>#if MYDBG <br>    { <br>    char text[128]; <br> <br>    wsprintf(text, "bGetWord gets %s", pstr); <br>    MessageBox(GetFocus(), text, "Info", MB_OK); <br>    } <br>#endif <br> <br>    return TRUE; <br>} <br> <br> <br>BOOL bGoNextLine(LPVOID lpData, int* pi) <br>{ <br>    char tmp[128]; <br>    int  q; <br> <br>    while ((((char *)lpData)[*pi] != '\n') &amp;&amp; <br>           (((char *)lpData)[*pi] != '\r')) <br>        (*pi)++; <br> <br>    // <br>    // skip them <br>    // <br>    *pi += 2; <br> <br>    q = *pi; <br> <br>    if ((bGetWord(lpData, tmp, &amp;q)) &amp;&amp; (bIsEOF(tmp)) ) <br>        return FALSE; <br> <br>    return TRUE; <br>} <br> <br> <br>/***************************************************************************\ <br>* bSetAdvancedGraphics <br>* <br>* Set the HDC to advanced graphics mode to get world transforms, and other <br>*  features...  However, only do this if we are running on Windows NT, as <br>*  the other platforms don't support GM_ADVANCED. <br>* <br>\***************************************************************************/ <br>BOOL bSetAdvancedGraphics(HDC hdc) <br>{ <br>    OSVERSIONINFO osvi; <br>    osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); <br> <br>    GetVersionEx (&amp;osvi); <br>    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) <br> <br>      if ((SetGraphicsMode(hdc, GM_ADVANCED)) == 0) { <br> MessageBox(ghwndMain, GetStringRes(IDS_SETADVGRPHMDFAIL), NULL, MB_OK); <br>      } <br>    return TRUE; <br>} <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>
</p>
<pre><code><br>LPTSTR   GetStringRes2 (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    BuildFilterStrs (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Construct a filter string by a series of LoadString calls. The <br>*resulting string is as follows: "%OldStr%\0%IDStr%\0%(ID+1)Str%\0\0". <br>*Note that each consecutive function call appends the new filter <br>*string on to the end of a static buffer. Call the function with <br>*id = -1 to reinitialize the buffer. <br>* <br>\******************************************************************************/ <br> <br>LPTSTRBuildFilterStrs(int id) <br>{ <br>  static TCHAR buffer[1024]; <br>  static TCHAR *pBuf; <br> <br>  if (id == -1) <br>  { <br>pBuf = buffer; <br>  } <br>  else <br>  { <br>LoadString(GetModuleHandle (NULL), id, pBuf, 1024 - (pBuf-buffer)); <br>pBuf += strlen(pBuf) + 1; <br>LoadString(GetModuleHandle (NULL), id + 1, pBuf, 1024 - (pBuf-buffer)); <br>pBuf += strlen(pBuf) + 1; <br>  } <br> <br>  *pBuf = 0; <br>  *(pBuf+1) = 0; <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
