<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MYPAL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3429"></a>MYPAL.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*************************************************************************** <br> *                                                                         * <br> *  PROGRAM     : MyPal.c                                                  * <br> *                                                                         * <br> *  PURPOSE     : Sets up a bar representation of the current physical     * <br> *                palette and displays useful information regarding        * <br> *                pixel colors and palette indices.                        * <br> *                                                                         * <br> *  FUNCTIONS   : WinMain() - calls initialization function,               * <br> *                            processes message loop                       * <br> *                                                                         * <br> *                WndProc() - Window function for app. Processes           * <br> *                            window messages.                             * <br> *                                                                         * <br> *              ShowColor() - Displays a little box on each side of the    * <br> *                            caption bar displaying the pixel color at the* <br> *                            mouse position.                              * <br> ***************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "mypal.h" <br> <br>HANDLE          hPal;          /* Handle to the application's logical palette */ <br>static INT      nSizeX;        /* Width of the application window             */ <br>static INT      nSizeY;        /* Height of the application window            */ <br>NPLOGPALETTE    pLogPal;       /* Pointer to program's logical palette        */ <br>INT             nXBorder;      /* Width of window border                      */ <br>INT             nXTitle;       /* Width of title bar                          */ <br>INT             nYTitle;       /* Height of title bar                         */ <br>BOOL            bCaptureOn;    /* Indicates if mouse capture is on            */ <br>INT             iIndex;        /* Last index selected in palette              */ <br>CHAR            szTitlebuf[90];/* Buffer for pixel and palette info. text     */ <br>HDC             hDCGlobal;     /* The Screen DC                               */ <br>INT             iNumColors;    /* Number of colors supported by device        */ <br>INT             iRasterCaps;   /* Raster capabilities                         */ <br>RECT            rClientRect;   /* Client rectangle coordinates                */ <br>DWORD    dwPal[PALETTESIZE];   /* Stores palette entries for later lookup     */ <br>INT             iGlobalXOffset; <br>INT             iGlobalYOffset; <br>INT             iYMiddle; <br> <br>LONG APIENTRY WndProc(HWND hWnd, UINT iMessage, UINT wParam, LONG lParam); <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : void ShowColor(HWND hWnd, HDC hDC)                         * <br> *                                                                          * <br> *  PURPOSE    : Displays a little box on each side of the caption bar      * <br> *               displaying the pixel color at the mouse position.          * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID ShowColor ( <br>        HWND  hWnd, <br>        HDC   hDC) <br>{ <br>     HBRUSH  hBrush, hOldBrush; <br> <br>     hBrush    = CreateSolidBrush ( PALETTEINDEX(iIndex) ); <br>     hOldBrush = SelectObject (hDC,hBrush) ; <br> <br>     GetWindowRect (hWnd, (LPRECT)&amp;rClientRect); <br> <br>     PatBlt ( hDC, <br>              rClientRect.left + nXTitle + nXBorder + 1, <br>              rClientRect.top + nXBorder, <br>              nXTitle, <br>              nYTitle, <br>              PATCOPY); <br> <br>     PatBlt(hDC, <br>            rClientRect.right - ( 3 * nXTitle + nXBorder + 2), <br>            rClientRect.top + nXBorder, <br>            nXTitle, <br>            nYTitle, <br>            PATCOPY); <br>     SelectObject (hDC, hOldBrush); <br>     DeleteObject (hBrush) ; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WinMain(HANDLE, HANDLE, LPSTR, int)                        * <br> *                                                                          * <br> *  PURPOSE    : Creates the app. window and processes the message loop.    * <br> *                                                                          * <br> ****************************************************************************/ <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br>     static CHAR szAppName [] = "MyPal"; <br>     HWND        hWnd; <br>     WNDCLASS    wndclass; <br>     MSG         msg ; <br>     INT         xScreen; <br>     INT         yScreen; <br> <br>     UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br>     if (!hPrevInstance){ <br>         wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>         wndclass.lpfnWndProc   = (WNDPROC) WndProc; <br>         wndclass.cbClsExtra    = 0; <br>         wndclass.cbWndExtra    = 0; <br>         wndclass.hInstance     = hInstance; <br>         wndclass.hIcon         = LoadIcon(hInstance, szAppName); <br>         wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>         wndclass.hbrBackground = GetStockObject (BLACK_BRUSH); <br>         wndclass.lpszMenuName  = szAppName; <br>         wndclass.lpszClassName = szAppName; <br> <br>         if (!RegisterClass (&amp;wndclass)) <br>             return FALSE ; <br>     } <br> <br>     /* Do some global initializations */ <br>     xScreen     = GetSystemMetrics (SM_CXSCREEN); <br>     yScreen     = GetSystemMetrics (SM_CYSCREEN); <br>     nXBorder    = (INT)GetSystemMetrics (SM_CXFRAME); <br>     nXTitle     = (INT)GetSystemMetrics (SM_CXSIZE); <br>     nYTitle     = (INT)GetSystemMetrics (SM_CYSIZE); <br>     iIndex      = 0; <br>     bCaptureOn  = FALSE; <br> <br>     hDCGlobal   = GetDC (NULL); <br>     iRasterCaps = GetDeviceCaps(hDCGlobal, RASTERCAPS); <br>     iRasterCaps = (iRasterCaps &amp; RC_PALETTE) ? TRUE : FALSE; <br> <br>     if (iRasterCaps) <br>         iNumColors = GetDeviceCaps(hDCGlobal, SIZEPALETTE); <br>     else <br>         iNumColors = GetDeviceCaps( hDCGlobal, NUMCOLORS); <br>     ReleaseDC (NULL,hDCGlobal); <br> <br>     nSizeX = ((xScreen - 2*nXBorder) / PALETTESIZE) * PALETTESIZE; <br> <br>     /* create the app. window */ <br>     hWnd = CreateWindow (szAppName, <br>                          "My Physical Palette ", <br>                          WS_OVERLAPPEDWINDOW, <br>                          (xScreen-nSizeX) / 2 - nXBorder, <br>                          yScreen - ( 4 * GetSystemMetrics (SM_CYCAPTION)), <br>                          nSizeX + 2 * nXBorder, <br>                          4 * GetSystemMetrics (SM_CYCAPTION), <br>                          NULL, <br>                          NULL, <br>                          hInstance, <br>                          NULL); <br>     ShowWindow (hWnd, nCmdShow); <br>     UpdateWindow (hWnd); <br> <br>     while (GetMessage (&amp;msg, NULL, 0, 0)){ <br>           TranslateMessage (&amp;msg) ; <br>           DispatchMessage (&amp;msg) ; <br>     } <br> <br>     return msg.wParam ; <br>} <br> <br>/****************************************************************************** <br> *                                                                            * <br> *  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)                             * <br> *                                                                            * <br> *  PURPOSE:  Processes window messages and sets up a 256 bar representation  * <br> *            of the current physical palette. Specifically, in response to:  * <br> *                                                                            * <br> *               WM_CREATE  -Allocates for and sets up a LOGPALETTE           * <br> *                           structure, creates a logical palette the same    * <br> *                           size as the physical palette and obtains a       * <br> *                           handle to the logical palette.                   * <br> *                                                                            * <br> *               WM_DESTROY -Destroys the logical palette and shuts down app. * <br> *                                                                            * <br> *               WM_PAINT   -Resizes client area to hold as many vertical     * <br> *                           color bars as there are physical palette entries.* <br> *                           Also realises the current logical palette and    * <br> *                           draws one color bar corresponding to each        * <br> *                           palette entry                                    * <br> *                                                                            * <br> *           WM_RBUTTONDOWN -Captures the mouse and initiates the below       * <br> *                           process:                                         * <br> *                                                                            * <br> *           WM_MOUSEMOVE   -Following a WM_RBUTTONDOWN, if the right mouse   * <br> *                           key is depressed, displays info about the        * <br> *                           pixel RGB value and palette index of the mouse   * <br> *                           coordinates.                                     * <br> *                                                                            * <br> *           WM_RBUTTONUP   -Release mouse capture and terminates the above   * <br> *                           process                                          * <br> *                                                                            * <br> *           WM_LBUTTONDOWN -Determines and displays the palette index and    * <br> *                           RGB value of the bar under the mouse.            * <br> *                                                                            * <br> *           WM_KEYDOWN     -Allows use of the arrow keys in stepping thro'   * <br> *                           palette entries.                                 * <br> *                                                                            * <br> *****************************************************************************/ <br>LONG APIENTRY WndProc ( <br>    HWND         hWnd, <br>    UINT     iMessage, <br>    UINT         wParam, <br>    LONG         lParam) <br>{ <br>    HDC           hDC; <br>    PAINTSTRUCT   ps; <br>    INT           iLoop; <br>    INT           nStart; <br>    HBRUSH        hBrush; <br>    HBRUSH        hOldBrush; <br> <br>    MPOINT        pt; <br>    static INT    nIncr; <br>    static DWORD  dwColor; <br>    static DWORD  dwLastColor; <br>    static INT    i, x; <br> <br>    switch (iMessage) { <br>         case WM_DESTROY: <br>              /* delete the handle to the logical palette if it has any <br>               * color entries and quit. <br>               */ <br>              if (pLogPal-&gt;palNumEntries) <br>                  DeleteObject (hPal); <br>              PostQuitMessage (0) ; <br>              break ; <br> <br>         case WM_CREATE: <br>              /* Allocate enough memory for a logical palette with <br>               * PALETTESIZE entries and set the size and version fields <br>               * of the logical palette structure. <br>               */ <br>              pLogPal = (NPLOGPALETTE) LocalAlloc (LMEM_FIXED, <br>                                                  (sizeof (LOGPALETTE) + <br>                                                  (sizeof (PALETTEENTRY) * (PALETTESIZE)))); <br> <br>          if(!pLogPal){ <br>            MessageBox(hWnd, "&lt;WM_CREATE&gt; Not enough memory for palette.", NULL, MB_OK | MB_ICONHAND); <br>                PostQuitMessage (0) ; <br>            break; <br>          } <br> <br>              pLogPal-&gt;palVersion    = 0x300; <br>              pLogPal-&gt;palNumEntries = PALETTESIZE; <br> <br>              /* fill in intensities for all palette entry colors */ <br>              for (iLoop = 0; iLoop &lt; PALETTESIZE; iLoop++) { <br>                  *((WORD *) (&amp;pLogPal-&gt;palPalEntry[iLoop].peRed)) = (WORD)iLoop; <br>                  pLogPal-&gt;palPalEntry[iLoop].peBlue  = 0; <br>                  pLogPal-&gt;palPalEntry[iLoop].peFlags = PC_EXPLICIT; <br>              } <br> <br>              /*  create a logical color palette according the information <br>               *  in the LOGPALETTE structure. <br>               */ <br>              hPal = CreatePalette ((LPLOGPALETTE) pLogPal) ; <br>              break; <br> <br>         case WM_GETMINMAXINFO: <br> <br>              ((LPRGPT)lParam)-&gt;iInfo[6] = nXBorder * 2 + PALETTESIZE; <br>              ((LPRGPT)lParam)-&gt;iInfo[7] = nXBorder * 2 + nYTitle*3; <br> <br>              return DefWindowProc (hWnd, iMessage, wParam, lParam) ; <br>              break; <br> <br>         case WM_PAINT: <br> <br>              /* Divide client width into equal-sized parts, one per palette <br>               * entry, and re-calculate client width so that it will display <br>               * exactly as many vertical bars as there are palette entries. <br>               */ <br>               GetClientRect(hWnd,(LPRECT) &amp;rClientRect); <br>               nSizeX = (rClientRect.right - rClientRect.left); <br>               nSizeX = (nSizeX/iNumColors) * iNumColors; <br> <br>               nSizeY = rClientRect.bottom - rClientRect.top; <br>               GetWindowRect(hWnd,(LPRECT) &amp;rClientRect); <br> <br>              /* Adjust window width so that it can display exactly <br>               * as many vertical bars( of equal width) as there are palette <br>               * colors. <br>               */ <br> <br>              SetWindowPos( hWnd, <br>                            (HWND)NULL, <br>                            0, <br>                            0, <br>                            nSizeX + 2*nXBorder, <br>                            rClientRect.bottom - rClientRect.top, <br>                            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>              hDC = BeginPaint(hWnd, &amp;ps); <br> <br>              /* Select the palette into the window device context and <br>               * make the Palette Manager map the logical palette to the <br>               * system palette (realize it). <br>               */ <br>              SelectPalette (hDC, hPal, 1); <br>              RealizePalette (hDC); <br> <br>              /* Calculate width of each color bar to be displayed */ <br>              nIncr = nSizeX / iNumColors; <br> <br>              /* Paint the individual bars separately on the app. window */ <br>              for (nStart = iLoop = 0; iLoop &lt; iNumColors; iLoop++){ <br> <br>                  /* Since this app. uses a logical palette, use the <br>                   * PALETTEINDEX macro to specify the palette entry <br>                   * index instead of using an explicit RGB value. <br>                   */ <br>                  hBrush       = CreateSolidBrush (PALETTEINDEX (iLoop)); <br>                  dwPal[iLoop] = GetNearestColor (hDC, PALETTEINDEX (iLoop) ); <br>                  hOldBrush    = SelectObject (hDC,hBrush) ; <br>                  PatBlt (hDC, nStart, 0, nIncr, nSizeY, PATCOPY); <br>                  nStart       += nIncr; <br>                  SelectObject (hDC, hOldBrush); <br>                  DeleteObject (hBrush) ; <br>              } <br>              wsprintf (szTitlebuf, "MyPal Colors= %d", iNumColors); <br>              SetWindowText (hWnd, (LPSTR)szTitlebuf); <br> <br>              EndPaint(hWnd,&amp;ps); <br> <br>              break ; <br> <br>         case WM_MOUSEMOVE: <br> <br>              if (wParam &amp; MK_RBUTTON) { <br> <br>          POINT pt; <br>                   <br>#ifdef WIN16 <br>                  /* Convert mouse position to screen coordinates */ <br>                  pt.x = LOWORD(lParam); <br>                  pt.y = HIWORD(lParam); <br>#else <br>                  LONG2POINT(lParam, pt);        <br>#endif <br>                  ClientToScreen(hWnd, &amp;pt); <br> <br>                  /* Get RGB value (color) of pixel under mouse coordinate */ <br>                  dwColor = GetPixel(hDCGlobal, pt.x, pt.y); <br> <br>                  /* If color value already exists in palette lookup table, <br>                   * obtain it's index. <br>                   */ <br>                  for (i=0 ; i &lt; iNumColors ; i++) <br>                      if ( dwColor == dwPal[i] ) <br>                          break; <br>                  iIndex = i; <br> <br>                  /* If previous color value was not identical to current one, <br>                   * display color boxes on either side of title bar, <br>                   * the R, G, B values and palette index of current color. <br>                   */ <br>                  if (dwColor != dwLastColor) { <br>                      wsprintf ( szTitlebuf, <br>                                 "MyPal Colors=%d  Index=%d  R=%3u G=%3u B=%3u", <br>                                 iNumColors, <br>                                 iIndex, <br>                                 (WORD)(BYTE) GetRValue (dwColor), <br>                                 (WORD)(BYTE) GetGValue (dwColor), <br>                                 (WORD)(BYTE) GetBValue (dwColor)); <br>                      SetWindowText (hWnd, (LPSTR)szTitlebuf); <br>                      ShowColor (hWnd, hDCGlobal); <br>                      dwLastColor = dwColor; <br>                  } <br>              } <br>              break; <br> <br>         case WM_RBUTTONDOWN: <br> <br>              /* Determine number of color bar under mouse, thus the index <br>               * of color in palette. <br>               */ <br>              x = LOWORD(lParam); <br>              iIndex = (x / nIncr ); <br> <br>              wsprintf ( szTitlebuf, <br>                         "MyPal Colors=%d  Index=%d  PalSize=%d RasterCaps:%d", <br>                         iNumColors, <br>                         iIndex, <br>                         iNumColors, <br>                         iRasterCaps ); <br> <br>              SetWindowText (hWnd, (LPSTR)szTitlebuf); <br> <br>              /* Set mouse capture so that subsequent WM_MOUSEMOVEs <br>               * (with right mouse button depressed) will allow MyPal <br>               * to display RGB info anywhere on the screen without losing <br>               * the focus. <br>               */ <br>              SetCapture (hWnd); <br>              bCaptureOn = TRUE; <br>              hDCGlobal = GetDC(NULL); <br>              if (hPal) { <br>                  SelectPalette (hDCGlobal, hPal, FALSE); <br>                  RealizePalette (hDCGlobal); <br>              } <br>              break; <br> <br>         case WM_RBUTTONUP: <br>              /* Stops displaying RGB and palette info and releases mouse <br>               * capture <br>               */ <br>              ReleaseDC (NULL, hDCGlobal); <br>              bCaptureOn = FALSE; <br>              ReleaseCapture (); <br>              break; <br> <br>         case WM_MOVE: <br>              /* If you have a wide column, this adds 1/2 so X is centered */ <br>              iGlobalXOffset  = LOWORD (lParam); <br>              iGlobalYOffset  = HIWORD (lParam) + nXBorder; <br>              break; <br> <br>         case WM_SIZE: <br>              iYMiddle = (HIWORD (lParam)/2); <br>              break; <br> <br>         case WM_LBUTTONDOWN: <br>         case WM_KEYDOWN: <br> <br>             if (iMessage == WM_LBUTTONDOWN){ <br>                 /* determine which column was hit by the mouse */ <br>                 x = LOWORD(lParam); <br>                 iIndex = (x / nIncr ); <br>             } <br>             else{ <br>                 /* Use arrow keys to step thro' the palette entries */ <br>                 switch (wParam) { <br>                     case VK_RIGHT: <br>                     case VK_UP: <br>                                  /* go to next (higher) palette entry */ <br>                                  iIndex++; <br>                                  break; <br>                     case VK_LEFT: <br>                     case VK_DOWN: <br>                                  /* go to previous (lower) palette entry */ <br>                                  iIndex--; <br>                                  break; <br>                     case VK_NEXT: <br>                                  iIndex += 10; <br>                                  break; <br>                     case VK_PRIOR: <br>                                  iIndex -= 10; <br>                                  break; <br>                     case VK_HOME: <br>                                  /* go to first palette entry */ <br>                                  iIndex = 0; <br>                                  break; <br>                     case VK_END: <br>                                  /* go to last palette entry */ <br>                                  iIndex = iNumColors-1; <br>                                  break; <br>                     default: <br>                                  return 0L; <br>                                  break; <br>                 } <br>                 /* Make sure the palette index is within range else <br>                  * set it to the limiting values and give a warning beep. <br>                  */ <br>                 if (iIndex &lt; 0) { <br>                     iIndex = 0; <br>                     MessageBeep(1); <br>                 } <br>                 else{ <br>                     if (iIndex &gt; iNumColors-1) { <br>                         iIndex = iNumColors-1; <br>                         MessageBeep(1); <br>                      } <br>                 } <br> <br>                 pt.x = (SHORT)((iIndex * nIncr) + <br>                        iGlobalXOffset   + <br>                        ((nIncr &gt; 1) ? (nIncr / 2) : 1)); <br>                 pt.y = (SHORT)(iYMiddle + iGlobalYOffset); <br> <br>                 SetCursorPos (pt.x, pt.y); <br>             } <br> <br>             if (TRUE == bCaptureOn) { <br>                 MessageBeep(1); <br>                 break; <br>             } <br> <br>             /* Select &amp; realize the palette or the colors &gt; 0x7 <br>              * will not match up. <br>              */ <br>             hDC = GetDC(NULL); <br>             SelectPalette  (hDC, hPal, 1); <br>             RealizePalette (hDC) ; <br> <br>             dwColor = GetNearestColor (hDC, PALETTEINDEX (iIndex)); <br> <br>             wsprintf ( szTitlebuf, <br>                        "MyPal Colors=%d  Index=%d  R=%3u G=%3u B=%3u", <br>                        iNumColors, <br>                        iIndex, <br>                        (WORD)(BYTE)GetRValue (dwColor), <br>                        (WORD)(BYTE)GetGValue (dwColor), <br>                        (WORD)(BYTE)GetBValue (dwColor) <br>                     ); <br> <br>             SetWindowText (hWnd, (LPSTR)szTitlebuf); <br>             ShowColor (hWnd,hDC); <br>             ReleaseDC(NULL, hDC); <br>             break; <br> <br>         default: <br>              return DefWindowProc (hWnd, iMessage, wParam, lParam) ; <br> <br>    } <br>    return 0L ; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
