<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3444"></a>REV.C</h2>
<pre><code>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>//  PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  PROGRAM: Rev.c <br>// <br>//  PURPOSE: Helper functions for Reversi Sample Game <br>// <br>//  FUNCTIONS: <br>//  finalscore() - Calculate final score <br>//  legalcheck() - Return 1 if move legal, else return 0 <br>//  makemove() - Capture enemy pieces <br>//  score() - Calculate the value of board <br>//  minmax() - Play human move then recursively play computer move <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "reversi.h" <br> <br>// declarations of function in reversi.c <br>VOID NEAR PASCAL paintmove(BYTE b[BoardSize], INT move, INT friendly, <br>    INT enemy); <br> <br>// variable declarations <br>extern INT     moves[61]; <br>extern INT     BestMove[max_depth+2]; <br>extern HWND    hWin; <br>extern HDC     hDisp; <br>extern INT     depth; <br>extern INT     direc[]; <br> <br> <br>//  Indexes for computing scores and whether or not a player has <br>//  any pieces on the board.  Very order dependant. <br> <br>BYTE PieceFlags[] = {   0x00 ,      // Ignore sides <br>            0x00 ,      // Ignore blanks <br>            0x01 ,      // Human has a piece <br>            0x02 ,      // Computer has a piece <br>            }; <br> <br>             <br>// <br>//  The scoring tables are used to evaluate the board <br>//  position.  The corners of the board change value <br>//  according to whether a given square is occupied or <br>//  not.  This can be done dynamically, saving ~ 1K <br>//  worth of data space but costing an as of yet <br>//  undetermined performance hit. <br>// <br> <br>#define B11     11    // Offsets to particular squares <br>#define B18     18  <br>#define B81     81  <br>#define B88     88  <br> <br>#define maskb11     0x08    // Masks used for indexing into Scoring tables. <br>#define maskb18     0x04 <br>#define maskb81     0x02 <br>#define maskb88     0x01 <br> <br> <br>// <br>//  FUNCTION: finalscore() <br>// <br>//  PURPOSE:  Calculate final score <br>// <br> <br>INT NEAR PASCAL finalscore( <br>BYTE b[], <br>BYTE friendly, <br>BYTE enemy) <br>{ <br>    INT i; <br>    INT count=0; <br> <br>    for (i=11 ; i&lt;=88 ; i++) { <br>        if (b[i] == friendly) <br>            count++; <br>        else <br>            if (b[i] == enemy) <br>                count--; <br>    } <br>    if (count &gt; 0) <br>        return(win + count); <br>    else <br>        if (count &lt; 0) <br>            return(loss + count); <br>        else <br>            return(0); <br>} <br> <br> <br>// <br>//  FUNCTION: legalcheck() <br>// <br>//  PURPOSE:  Return 1 if move legal, else return 0 <br>// <br> <br>INT NEAR PASCAL legalcheck( <br>BYTE b[], <br>INT move, <br>BYTE friendly, <br>BYTE enemy) <br>{ <br>   INT sq,d; <br>   INT *p; <br> <br>   if (b[move] == empty) { <br>      p=direc; <br>      while ((d = *p++) != 0) { <br>          sq=move; <br>          if (b[sq += d] == enemy) { <br>             while(b[sq += d] == enemy) <br>            ; <br>             if (b[sq] == friendly) return(1); <br>          } <br>      } <br>   } <br>   return(0); <br>} <br> <br> <br>// <br>//  FUNCTION: makemove() <br>// <br>//  PURPOSE:  Capture enemy pieces <br>// <br> <br>VOID NEAR PASCAL makemove( <br>BYTE b[], <br>INT move, <br>BYTE friendly, <br>BYTE enemy) <br>{ <br>   INT sq,d; <br>   INT *p; <br> <br>   if (move != PASS) { <br>      p=direc; <br>      while ((d = *p++) != 0) { <br>          sq=move; <br>          if (b[sq += d] == enemy) { <br>            while(b[sq += d] == enemy) <br>            ; <br>            if (b[sq] == friendly) <br>                while(b[sq -= d] == enemy) <br>                   b[sq]=friendly; <br>          } <br>      } <br>      b[move]=friendly; <br>   } <br>} <br> <br> <br>// <br>//  FUNCTION: score() <br>// <br>//  PURPOSE:  Calculate the value of board <br>// <br> <br>INT NEAR PASCAL score( <br>BYTE b[], <br>BYTE friendly, <br>BYTE enemy) <br>{ <br>    INT *pvalue; <br>    BYTE *pb; <br>    INT fpoints=0; <br>    INT epoints=0; <br>    INT ecount=0; <br>    BYTE bv; <br>    INT v,b11,b18,b81,b88; <br> <br>    static INT value[79] = {     99, -8,  8,  6,  6,  8, -8, 99,000, <br>                000, -8,-24, -4, -3, -3, -4,-24, -8,000, <br>                000,  8, -4,  7,  4,  4,  7, -4,  8,000, <br>                000,  6, -3,  4,  0,  0,  4, -3,  6,000, <br>                000,  6, -3,  4,  0,  0,  4, -3,  6,000, <br>                000,  8, -4,  7,  4,  4,  7, -4,  8,000, <br>                000, -8,-24, -4, -3, -3, -4,-24, -8,000, <br>                000, 99, -8,  8,  6,  6,  8, -8, 99,infin}; <br> <br>    static INT value2[79]= {     99, -8,  8,  6,  6,  8, -8, 99,000, <br>                000, -8,-24,  0,  1,  1,  0,-24, -8,000, <br>                000,  8,  0,  7,  4,  4,  7,  0,  8,000, <br>                000,  6,  1,  4,  1,  1,  4,  1,  6,000, <br>                000,  6,  1,  4,  1,  1,  4,  1,  6,000, <br>                000,  8,  0,  7,  4,  4,  7,  0,  8,000, <br>                000, -8,-24,  0,  1,  1,  1,-24, -8,000, <br>                000, 99, -8,  8,  6,  6,  8, -8, 99,infin}; <br> <br>    pb = &amp;b[11]; <br>    b11 = *pb; <br>    b18 = b[18]; <br>    b81 = b[81]; <br>    b88 = b[88]; <br> <br>    if ((b11 != empty) || (b18 != empty) || (b81 != empty) || (b88 != empty)) { <br>    pvalue = value2; <br> <br>    if (b11 == empty) { <br>        value2[12-11] = -8;  value2[21-11] = -8;  value2[22-11] = -24; <br>    } else { <br>        value2[12-11] = 12;  value2[21-11] = 12;  value2[22-11] = 8; <br>    } <br> <br>    if (b18 == empty) { <br>        value2[17-11] = -8;  value2[28-11] = -8;  value2[27-11] = -24; <br>    } else { <br>        value2[17-11] = 12;  value2[28-11] = 12;  value2[27-11] = 8; <br>    } <br> <br>    if (b81 == empty) { <br>        value2[82-11] = -8;  value2[71-11] = -8;  value2[72-11] = -24; <br>    } else { <br>        value2[82-11] = 12;  value2[71-11] = 12;  value2[72-11] = 8; <br>    } <br> <br>    if (b88 == empty) { <br>        value2[87-11] = -8;  value2[78-11] = -8;  value2[77-11] = -24; <br>    } else { <br>        value2[87-11] = 12;  value2[78-11] = 12;  value2[77-11] = 8; <br>    } <br>    } else { <br>    pvalue = value; <br>    } <br> <br>    while((v=*pvalue++) != infin) { <br>       bv = *pb++; <br>       if (bv == friendly) <br>       fpoints += v; <br>       else if (bv == enemy) { <br>           epoints += v; <br>       ecount++; <br>       } <br> <br>    } <br>    if (!ecount)          // any enemy pieces on the board? <br>       return(win);       // if not, we just won! <br>    else <br>       return(fpoints-epoints); <br>} <br> <br> <br>// <br>//  FUNCTION: minmax() <br>// <br>//  PURPOSE:  Play human move then recursively play computer move  <br>// <br> <br>INT NEAR PASCAL minmax( <br>BYTE b[max_depth + 2][100], <br>INT move, <br>BYTE friendly, <br>BYTE enemy, <br>INT ply, <br>INT vmin, <br>INT vmax) <br>{ <br>    BYTE *pCurrent, *pPrevious, *pSource, *pDest; <br>    INT *pMoves; <br>    INT *pBestMove; <br>    INT i; <br>    INT sq, value, cur_move; <br>    INT count=0;    // not used ! <br> <br>    pPrevious = &amp;b[ply][0]; <br>    pCurrent =  &amp;b[ply+1][0]; <br> <br>    pSource = &amp;b[ply][11]; <br>    pDest =   &amp;b[ply+1][11]; <br>    for (i=11 ; i&lt;=88 ; i++) *pDest++=*pSource++; <br> <br>    pBestMove = &amp;BestMove[ply]; <br>    if (move == PASS) { <br>        if (ply == depth) { <br>            pMoves = moves; <br>            while((sq = *pMoves++) != 0) { <br>                if (legalcheck(pCurrent,sq,enemy,friendly)) <br>                    return(score(pCurrent,friendly,enemy)); <br>            } <br>            return(finalscore(pCurrent,friendly,enemy)); <br>        } <br>    } <br>    else { <br>        if (ply == 0) { <br>            hDisp = GetDC(hWin); <br>            paintmove(pCurrent,move,friendly,enemy); <br>            ReleaseDC(hWin, hDisp); <br>        } <br>        else { <br>            makemove(pCurrent,move,friendly,enemy); <br>            if (ply == depth) return(score(pCurrent,friendly,enemy)); <br>        } <br>    } <br>    pMoves = moves; <br>    cur_move = PASS; <br>    *pBestMove = PASS; <br>    while((sq = *pMoves++) != 0) { <br>        if (legalcheck(pCurrent,sq,enemy,friendly)) { <br>           cur_move = sq; <br>           value = minmax(b,cur_move,enemy,friendly,ply+1,-vmax,-vmin); <br>           if (value &gt; vmin) { <br>              vmin = value; <br>              *pBestMove = cur_move; <br>              if (value &gt;= vmax) goto cutoff;   // alpha-beta cutoff <br>           } <br>        } <br>    } <br>    if (cur_move == PASS) { <br>        if (move == PASS)        // two passes in a row mean game is over <br>            return(finalscore(pCurrent,friendly,enemy)); <br>        else { <br>            value = minmax(b,PASS,enemy,friendly,ply+1,-vmax,-vmin); <br>            if (value &gt; vmin) vmin = value; <br>        } <br>    } <br>cutoff: <br>    return(-vmin); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
