<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REVERSI.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3445"></a>REVERSI.C</h2>
<pre><code>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>//  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>//  PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//  PROGRAM: Reversi.c <br>// <br>//  PURPOSE: Reversi Sample Game <br>// <br>//  FUNCTIONS: <br>//  UpdateCursor() - Update the cursor position <br>//  checkdepth() - Update Skill menu items <br>//  clearboard() - Clear board and set starting pieces <br>//  RevCreate() - Called on WM_CREATE messages <br>//  printboard() - Draws game pieces on board <br>//  ClearMessageTop() - Clears message bar <br>//  ShowMessageTop() - Displays string in message bar <br>//  drawboard() - Draws game board <br>//  RevPaint() - Called on WM_PAINT messages <br>//  FlashMessageTop() - Sets up system timer for callback procedure <br>//  RevMessage() - Outputs flashing message at top of window <br>//  flashsqr() - Flashes game piece <br>//  RevMouseMove() - Update cursor to show legality of move <br>//  ShowBestMove() - Update cursor and mouse position to show best move <br>//  gameover() - Find a human reply to the computers move <br>//  paintmove() - Make a move and show the results <br>//  RevMenu() - Called on WM_COMMAND messages <br>//  RevInit() - Initializes window data and registers window <br>//  RevMouseClick() - Handle mouse click or keyboard space or CR <br>//  Next() - Find next square <br>//  Previous() - Find previous square <br>//  ShowNextMove() - Show next legal move <br>//  RevChar() - Called on WM_KEYDOWN messages <br>//  InverseMessage() - Callback - inverts message bitmap or kills timer <br>//  ReversiWndProc() - Processes messages for "Reversi" window <br>//  AboutDlgProc() - processes messages for "About" dialog box <br>//  WinMain() - calls initialization function, processes message loop <br>// <br>//  SPECIAL INSTRUCTIONS: N/A <br>// <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "reversi.h" <br> <br>// Exported procedures called from other modules <br>LONG APIENTRY ReversiWndProc(HWND, UINT, WPARAM, LONG); <br>LONG APIENTRY InverseMessage(HWND, UINT, WPARAM, LONG); <br> <br>// Global variables <br>PSTR    pDisplayMessage; <br>HBRUSH  hbrBlack; <br>HBRUSH  hbrPat; <br>HBRUSH  hbrWhite; <br>HBRUSH  hbrRed; <br>HBRUSH  hbrGreen; <br>HBRUSH  hbrBlue; <br>HBRUSH  hbrHuman; <br>HBRUSH  hbrComputer; <br>WNDPROC lpprocInverseMessage; <br>HANDLE  hInst; <br>HANDLE  curIllegal; <br>HANDLE  curLegal; <br>HANDLE  curThink; <br>HANDLE  curBlank; <br>BOOL    fThinking = FALSE; <br>BOOL    fCheated = FALSE; <br>INT     direc[9] = {9, 10, 11, 1, -1, -9, -10, -11, 0}; <br>WORD     prevCheck; <br>BYTE    board[max_depth+2][BoardSize]; <br>INT     fPass; <br>INT     flashtimes; <br>INT     count; <br>INT     MessageOn; <br>INT     charheight; <br>INT     charwidth; <br>INT     xscr; <br>CHAR    strBuf[80]; <br>BOOL    bMouseDownInReversi = FALSE; <br>INT     xExt; <br>INT     yExt; <br>INT     Bx; <br>INT     By; <br>INT     ASPECT; <br>INT     COLOR; <br>INT     TXMIN; <br>INT     TYMIN = 45; <br>INT     dimension; <br>BOOL    ffirstmove; <br> <br>CHAR    szReversi[20]; <br>CHAR    szReversiPractice[40]; <br>CHAR    szPass[30]; <br>CHAR    szMustPass[30]; <br>CHAR    szTie[30]; <br>CHAR    szLoss[30]; <br>CHAR    szWon[30]; <br>CHAR    szWonPost[30]; <br>CHAR    szLossPost[30]; <br>CHAR    szAbout[20]; <br>CHAR    szIllegal[70]; <br>CHAR    szNoPass[70]; <br>CHAR    szHelpFile[15]; <br> <br>HANDLE  hAccel; <br> <br>POINT   MousePos; <br>FARPROC lpprocAbout; <br> <br>INT     depth; <br>INT     BestMove[max_depth+2]; <br>HDC     hDisp; <br>HWND    hWin; <br>INT     moves[61] = {11,18,81,88, 13,31,16,61, <br>                     38,83,68,86, 14,41,15,51, <br>                     48,84,58,85, 33,36,63,66, <br>                     34,35,43,46, 53,56,64,65, <br>                     24,25,42,47, 52,57,74,75, <br>                     23,26,32,37, 62,67,73,76, <br>                     12,17,21,28, 71,78,82,87, <br>                     22,27,72,77, <br>              0}; <br> <br>// declarations of functions in rev.c <br>INT NEAR PASCAL minmax(BYTE b[max_depth + 2][100], INT move, INT friendly, <br>    INT enemy, INT ply, INT vmin, INT vmax); <br>VOID NEAR PASCAL makemove(BYTE b[], INT move, INT friendly, INT enemy); <br>INT NEAR PASCAL legalcheck(BYTE b[], INT move, INT friendly, INT enemy); <br> <br>#define LONG2POINT(l, pt)               ((pt).x = (SHORT)LOWORD(l), (pt).y = (SHORT)HIWORD(l)) <br> <br>// <br>//  FUNCTION: UpdateCursor() <br>// <br>//  PURPOSE:  Update the cursor position <br>// <br>//  COMMENTS: <br>// <br>//      To use UpdateCursor,  set the global var MousePos.x and MousePos.y <br>//      and make the call.  The cursor will appear at the new position <br>// <br> <br>VOID NEAR PASCAL UpdateCursor( <br>HWND    hwnd) <br>{ <br>  POINT curpoint; <br> <br>  curpoint.x = MousePos.x; <br>  curpoint.y = MousePos.y; <br>  ClientToScreen(hwnd, (LPPOINT)&amp;curpoint); <br>  SetCursorPos(curpoint.x, curpoint.y); <br>} <br> <br> <br>// <br>//  FUNCTION: checkdepth() <br>// <br>//  PURPOSE:  Update Skill menu items <br>// <br> <br>VOID NEAR PASCAL checkdepth( <br>HWND hWindow, <br>WORD  d) <br>{ <br>  HMENU hMenu; <br> <br>  hMenu = GetMenu(hWindow); <br>  CheckMenuItem(hMenu, prevCheck, MF_UNCHECKED); <br>  CheckMenuItem(hMenu, d, MF_CHECKED); <br>  prevCheck = d; <br>} <br> <br> <br>// <br>//  FUNCTION: clearboard() <br>// <br>//  PURPOSE:  Clear board and set starting pieces <br>// <br> <br>VOID NEAR PASCAL clearboard( <br>BYTE b[max_depth+2][BoardSize]) <br>{ <br>  register INT  i,j; <br>  INT           k; <br> <br>  for (i=0; i&lt;=max_depth ; i++) <br>      for (j=0 ; j&lt;=99 ; j++) <br>          b[i][j] = edge; <br> <br>    for (i=0 ; i&lt;=max_depth ; i++) <br>      { <br>        for (j=11 ; j&lt;=81 ; j=j+10) <br>            for (k=j ; k&lt;j+8 ; k++) <br>                b[i][k] = empty; <br> <br>        b[i][45]=computer; <br>        b[i][54]=computer; <br>        b[i][44]=human; <br>        b[i][55]=human; <br>      } <br>} <br> <br> <br>// <br>//  FUNCTION: RevCreate() <br>// <br>//  PURPOSE:  Called on WM_CREATE messages <br>// <br> <br>VOID NEAR PASCAL RevCreate( <br>register HWND   hWindow) <br> <br>{ <br>  register HDC  hDC; <br>  TEXTMETRIC    charsize;           // characteristics of the characters <br> <br>  MessageOn   = FALSE; <br>  hDC = GetDC(hWindow); <br>  GetTextMetrics(hDC, (LPTEXTMETRIC)&amp;charsize); <br> <br>  charheight = charsize.tmHeight; <br>  charwidth = charsize.tmAveCharWidth; <br> <br>  ReleaseDC(hWindow, hDC); <br> <br>  if (COLOR == TRUE) <br>    { <br>      hbrComputer = hbrBlue; <br>      hbrHuman = hbrRed; <br>    } <br>  else <br>    { <br>      hbrComputer = hbrBlack; <br>      hbrHuman = hbrWhite; <br>    } <br> <br>  TXMIN = 45 * ASPECT; <br> <br>  clearboard(board); <br> <br>  fPass = PASS;   // Okay to pass on first move <br>  depth = 1; <br>  prevCheck = EASY; <br>  ffirstmove = TRUE; <br>  checkdepth(hWindow, prevCheck); <br>} <br> <br> <br>// <br>//  FUNCTION: printboard() <br>// <br>//  PURPOSE:  Draws game pieces on board <br>// <br> <br>VOID NEAR PASCAL printboard( <br>BYTE b[max_depth+2][BoardSize]) <br> <br>{ <br>  register INT  i,j; <br>  INT sq; <br> <br>  for (i=0; i &lt; 8; i++) <br>    { <br>      for (j=0; j &lt; 8; j++) <br>        { <br>          if ((sq = (INT)b[0][i*10+j+11]) != empty) <br>            { <br>              if (sq == computer) <br>                  SelectObject(hDisp, hbrComputer); <br>              else <br>                  SelectObject(hDisp, hbrHuman); <br> <br>              Ellipse(hDisp, <br>                      Bx+2*ASPECT+i*xExt, <br>                      By+2+j*yExt, <br>                      Bx+2*ASPECT + i*xExt + xExt-4*ASPECT, <br>                      By+2+j*yExt + yExt-4); <br>            } <br>        } <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: ClearMessageTop() <br>// <br>//  PURPOSE:  Clears message bar <br>// <br> <br>VOID NEAR PASCAL ClearMessageTop( <br>HDC     hDC) <br> <br>{ <br>  if (MessageOn == TRUE) <br>    { <br>      flashtimes = count + 1; <br>      SelectObject(hDC, (COLOR) ? hbrGreen : hbrWhite); <br>      PatBlt(hDC, 0, 0, xscr, charheight, PATCOPY); <br>      MessageOn = FALSE; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: ShowMessageTop() <br>// <br>//  PURPOSE:  Displays string in message bar <br>// <br> <br>VOID NEAR PASCAL ShowMessageTop( <br>HDC     hDC, <br>PSTR    string) <br> <br>{ <br>#if defined (WIN16)  <br>  INT   dx; <br>  INT   sizeRet; <br>  #define WIDTH(x)  sizeRet <br>#else <br>  LONG  dx; <br>  SIZE  sizeRet;         <br>  #define WIDTH(x)  sizeRet.cx <br>#endif <br>   <br>  pDisplayMessage = string; <br>  ClearMessageTop(hDC); <br>  SelectObject(hDC, hbrWhite); <br>  PatBlt(hDC, 0, 0, xscr, charheight, PATCOPY); <br>  SetBkMode(hDC, TRANSPARENT); <br>  GetTextExtentPoint(hDC, (LPSTR)string, lstrlen(string), &amp;sizeRet); <br>  dx = WIDTH(x); <br>  TextOut(hDC, (INT)(xscr - dx)/2, 0, (LPSTR)string, lstrlen(string)); <br>  MessageOn = TRUE; <br>  SetBkMode(hDC, OPAQUE); <br>} <br> <br> <br>// <br>//  FUNCTION: drawboard() <br>// <br>//  PURPOSE:  Draws game board <br>// <br> <br>VOID NEAR PASCAL drawboard( <br>BYTE b[max_depth+2][BoardSize]) <br>{ <br>  register INT  i; <br>  INT           lcx,lcy; <br>  register INT  xdimension; <br>  INT           xLineExt,yLineExt; <br> <br>  yLineExt = 8 * yExt; <br>  xLineExt = 8 * xExt; <br>  xdimension = dimension * ASPECT; <br> <br>  SelectObject(hDisp, hbrBlack); <br>  PatBlt(hDisp, Bx+2*xdimension, By+2*dimension, xLineExt, yLineExt, PATCOPY); <br>  //MUnrealizeObject(hbrPat); <br>  SelectObject(hDisp, hbrPat); <br>  PatBlt(hDisp, Bx, By, xLineExt, yLineExt, PATCOPY); <br> <br>  SelectObject(hDisp, hbrBlack); <br>  for (i=Bx; i &lt;= Bx + xLineExt; i += xExt) <br>      PatBlt(hDisp, i, By, ASPECT, yLineExt, PATCOPY); <br> <br>  for (i=By; i &lt;= By + yLineExt; i += yExt) <br>      PatBlt(hDisp, Bx, i, xLineExt, 1, PATCOPY); <br> <br>  lcx = Bx+xLineExt; <br>  lcy = By+yLineExt; <br> <br>  //MUnrealizeObject(hbrPat); <br>  SelectObject(hDisp, hbrPat); <br> <br>  for (i=1; i &lt; xdimension; ++i) <br>      PatBlt(hDisp, lcx+i, By+i/ASPECT, 1, yLineExt, PATCOPY); <br> <br>   <br>  for (i=1; i &lt; dimension; ++i)   // Fill in bottom edge of puzzle. <br>      PatBlt(hDisp, Bx+i*ASPECT, lcy+i, xLineExt, 1, PATCOPY); <br> <br>  SelectObject(hDisp, hbrBlack); <br> <br>  MoveToEx(hDisp, lcx, By, NULL); <br>  LineTo(hDisp, lcx+xdimension, By+dimension); <br>  LineTo(hDisp, lcx+xdimension, lcy+dimension); <br>  LineTo(hDisp, Bx+xdimension, lcy+dimension); <br>  LineTo(hDisp, Bx, lcy); <br>  MoveToEx(hDisp, lcx+xdimension, lcy+dimension, NULL); <br>  LineTo(hDisp, lcx, lcy); <br> <br>  printboard(b); <br>} <br> <br> <br>// <br>//  FUNCTION: RevPaint() <br>// <br>//  PURPOSE:  Called on WM_PAINT messages <br>// <br> <br>VOID NEAR PASCAL RevPaint( <br>HWND    hWindow, <br>HDC     hDC) <br> <br>{ <br>  register INT  Tx, Ty; <br>  INT           xLineExt, yLineExt; <br>  RECT          lpSize; <br> <br>  hDisp = hDC;    // Since it is easy to resize we'll do it on every repaint <br>  hWin  = hWindow; <br>  SetBkMode(hDisp, OPAQUE); <br>  GetClientRect(hWindow, (LPRECT)&amp;lpSize); <br>  xscr = Tx = lpSize.right - lpSize.left; <br>  Ty = lpSize.bottom - lpSize.top; <br> <br>  if (Tx &lt; Ty*ASPECT)    // Dont go below minimum size <br>    { <br>      if (Tx &lt; TXMIN) <br>          Tx = TXMIN; <br>      xExt = Tx / (9 + 1); <br>      yExt = xExt / ASPECT; <br>    } <br>  else <br>    { <br>      if (Ty &lt; TYMIN) <br>          Ty = TYMIN; <br>      yExt = Ty / (9 + 1); <br>      xExt = yExt * ASPECT; <br>    } <br>  yLineExt = 8 * yExt; <br>  xLineExt = 8 * xExt; <br>  dimension = yLineExt/30; <br> <br>  Bx = (Tx &gt; xLineExt) ? (Tx - xLineExt) / 2 : 0; <br>  By = (Ty &gt; yLineExt) ? (Ty - yLineExt) / 2 : 0; <br> <br>  drawboard(board); <br> <br>  if (MessageOn) <br>    { <br>      ShowMessageTop(hDisp, pDisplayMessage); <br>      PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT); <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: FlashMessageTop() <br>// <br>//  PURPOSE:  Sets up system timer for callback procedure <br>// <br> <br>VOID NEAR PASCAL FlashMessageTop( <br>HWND    hWindow) <br>{ <br>  flashtimes = 0; <br>  count = 4; <br>  SetTimer(hWindow, 666, 200, (WNDPROC)lpprocInverseMessage);    /* Timer ID is 666 */ <br>} <br> <br> <br>// <br>//  FUNCTION: RevMessage() <br>// <br>//  PURPOSE:  Outputs flashing message at top of window <br>// <br> <br>VOID NEAR PASCAL RevMessage( <br>HWND            hWindow, <br>HDC             hDC, <br>register CHAR   *pS, <br>INT             n, <br>CHAR            *pchPostStr) <br>{ <br>  register CHAR *pch; <br> <br>  pch = strBuf; <br>  while (*pS) <br>      *pch++ = *pS++; <br> <br>  if (n) <br>    { <br>      if (n / 10) <br>          *pch++ = (CHAR)(n / 10 + '0'); <br>      *pch++ = (CHAR)(n % 10 + '0'); <br>    } <br> <br>  if (pchPostStr) <br>    { <br>      while (*pchPostStr) <br>          *pch++ = *pchPostStr++; <br>    } <br>  *pch = '\0'; <br> <br>  ShowMessageTop(hDC, strBuf); <br>  FlashMessageTop(hWindow); <br>} <br> <br> <br>// <br>//  FUNCTION: flashsqr() <br>// <br>//  PURPOSE:  Flashes game piece <br>// <br> <br>VOID NEAR PASCAL flashsqr( <br>register HDC    hDC, <br>INT             x1, <br>INT             y1, <br>INT             Ex, <br>INT             Ey, <br>INT             color, <br>BOOL            fBlankSquare, <br>INT             n) <br> <br>{ <br>  register INT  i; <br> <br>  if (fBlankSquare) <br>      SelectObject(hDC, GetStockObject(NULL_PEN)); <br> <br>  SetCursor(curBlank); <br> <br>  for (i=0; i &lt; n; ++i) <br>    { <br>      if (color == 1) <br>          color = 2; <br>      else <br>          color = 1; <br> <br>      if (color == 1) <br>          SelectObject(hDC,hbrComputer); <br>      else <br>          SelectObject(hDC, hbrHuman); <br> <br>      SetBkMode(hDC, OPAQUE); <br>      Ellipse(hDC, x1, y1, x1+Ex, y1+Ey); <br>    } <br> <br>  if (fBlankSquare) <br>    { <br>      //MUnrealizeObject(hbrPat); <br>      SelectObject(hDC, hbrPat); <br>      Ellipse(hDC, x1, y1, x1+Ex, y1+Ey); <br>    } <br>  else <br>      SetCursor(curThink); <br>} <br> <br> <br>// <br>//  FUNCTION: RevMouseMove() <br>// <br>//  PURPOSE:  Update cursor to show legality of move <br>// <br> <br>VOID NEAR PASCAL RevMouseMove( <br>POINT   point) <br> <br>{ <br>  INT     move; <br>  INT     Si, Sj; <br>  INT     yLineExt = 8 * yExt; <br>  INT     xLineExt = 8 * xExt; <br>  HANDLE  cur; <br> <br>  MousePos.x = point.x; <br>  MousePos.y = point.y; <br> <br>  if(xExt ==0 || yExt == 0) <br>      return; <br> <br>  cur = curIllegal; <br> <br>  if ((point.x &gt; Bx) &amp;&amp; (point.x &lt; (Bx+xLineExt)) &amp;&amp; (point.y &gt; By) &amp;&amp; (point.y &lt; (By+yLineExt))) <br>    { <br>      Si = (point.x - Bx) / xExt; <br>      Sj = (point.y - By) / yExt; <br>      move = Si * 10 + Sj + 11; <br>      if (legalcheck(board[0], move, human, computer)) <br>          cur = curLegal; <br>    } <br>  SetCursor(cur); <br>} <br> <br> <br>// <br>//  FUNCTION: ShowBestMove() <br>// <br>//  PURPOSE:  Update cursor and mouse position to show best move <br>// <br> <br>VOID NEAR PASCAL ShowBestMove( <br>HWND hwnd) <br> <br>{ <br>  HDC           hdc; <br>  INT           sq; <br>  register INT  x, y; <br>  INT           *pMoves; <br>  BOOL          bDone; <br> <br>  if (fPass == PASS &amp;&amp; !ffirstmove) <br>      return; <br> <br>  if (!fCheated) <br>      SetWindowText(hwnd, (LPSTR)szReversiPractice); <br> <br>  fCheated = TRUE; <br>  SetCursor(curThink); <br>  fThinking = TRUE; <br> <br>  if (ffirstmove) <br>    { <br>      x = 4;    // HACK: Hardcode the first move hint. <br>      y = 2; <br>    } <br>  else <br>    { <br>      if (depth == 1) <br>        { <br>          bDone = FALSE; <br>          pMoves = moves; <br>          sq = *pMoves; <br>          while (!bDone) <br>            { <br>              sq = *pMoves; <br>              if (legalcheck(board[0], sq, human, computer)) <br>                  bDone = TRUE; <br>              else <br>                  pMoves++; <br>            } <br>          y = (sq - 11) % 10; <br>          x = (sq - 11) / 10; <br>        } <br>      else <br>        { <br>          minmax(board, BestMove[0],  computer, human, 1, -infin, infin); <br>          y = (BestMove[1] - 11) % 10; <br>          x = (BestMove[1] - 11) / 10; <br>        } <br>    } <br> <br>  MousePos.x = (x * xExt) + Bx + xExt/2; <br>  MousePos.y = (y * yExt) + By + yExt/2; <br> <br>  UpdateCursor(hwnd); <br> <br>  hdc = GetDC(hwnd); <br> <br>  x = x * xExt + Bx + 2 * ASPECT; <br>  y = y * yExt + By + 2; <br> <br>  flashsqr(hdc, x, y, xExt - 4 * ASPECT, yExt - 4, computer, TRUE, 3); <br> <br>  fThinking = FALSE; <br> <br>  ReleaseDC(hwnd, hdc); <br> <br>  RevMouseMove(MousePos); <br>} <br> <br> <br>// <br>//  FUNCTION: gameover() <br>// <br>//  PURPOSE:  Find a human reply to the computers move <br>// <br>//  COMMENTS: <br>// <br>//      As a side effect set flag fPass if the human <br>//      has a legal move. <br>// <br> <br>VOID NEAR PASCAL gameover( <br>register HWND   hWindow, <br>HDC             hDC, <br>BYTE            b[max_depth + 2][BoardSize], <br>INT             r) <br> <br>{ <br>  register INT  i; <br>  INT           cc; <br>  INT           hc; <br>  INT           sq; <br>  INT           reply2; <br>  INT           *pMoves; <br> <br>  pMoves = moves; <br>  fPass = PASS; <br>  reply2 = PASS; <br>  while ((sq = *pMoves++) != 0) <br>    { <br>      if (legalcheck(b[0], sq, human, computer)) <br>          fPass = sq; <br>      else if (legalcheck(b[0], sq, computer, human)) <br>          reply2 = sq; <br>    } <br> <br>  if (fPass == PASS) <br>    { <br>      if ((r == PASS) || (reply2 == PASS)) <br>        { <br>          hc = 0; <br>          cc = 0; <br>          for (i=11; i &lt;= 88; i++) <br>            { <br>              if (b[0][i] == human) <br>                  hc++; <br>              else if (b[0][i] == computer) <br>                  cc++; <br>            } <br> <br>          if (hc &gt; cc) <br>              RevMessage(hWindow, hDC, szWon, hc-cc, szWonPost); <br>          else if (hc &lt; cc) <br>              RevMessage(hWindow, hDC, szLoss, cc-hc, szLossPost); <br>          else <br>              RevMessage(hWindow, hDC, szTie, 0, NULL); <br>        } <br>      else <br>        { <br>          RevMessage(hWindow, hDC, szMustPass, 0, NULL); <br>        } <br>    } <br>  else if (r == PASS) <br>    { <br>      RevMessage(hWindow, hDC, szPass, 0, NULL); <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: paintmove() <br>// <br>//  PURPOSE:  Make a move and show the results <br>// <br> <br>VOID NEAR PASCAL paintmove( <br>BYTE    b[BoardSize], <br>INT     move, <br>BYTE    friendly, <br>BYTE    enemy) <br>{ <br>  INT           d; <br>  INT           sq; <br>  INT           *p; <br>  register INT  i,j; <br>  INT           color; <br> <br>  if (move != PASS) <br>    { <br>      if (friendly == computer) <br>        { <br>          SelectObject(hDisp, hbrComputer); <br>          color = 1; <br>        } <br>      else <br>        { <br>          SelectObject(hDisp, hbrHuman); <br>          color = 2; <br>        } <br> <br>      i = ((move - 11) / 10) * xExt + Bx + 2 * ASPECT; <br>      j = ((move - 11) % 10) * yExt + By + 2; <br>      Ellipse(hDisp, i, j, i + xExt - 4 * ASPECT, j + yExt - 4); <br>      flashsqr(hDisp, i, j, xExt - 4 * ASPECT, yExt - 4, color, FALSE, 4); <br> <br>      p = direc; <br>      while ((d = *p++) != 0) <br>        { <br>          sq=move; <br>          if (b[sq += d] == enemy) <br>           { <br>             while(b[sq += d] == enemy) <br>                ; <br>             if (b[sq] == (BYTE)friendly) <br>               { <br>                 while(b[sq -= d] == enemy) <br>                   { <br>                     board[0][sq] = b[sq] = friendly; <br>                     i = ((sq - 11)/10)*xExt+Bx+2*ASPECT; <br>                     j = ((sq - 11)%10)*yExt+By+2; <br>                     Ellipse(hDisp, i, j, i + xExt-4*ASPECT, j + yExt-4); <br>                   } <br>               } <br>           } <br>        } <br>      b[move]=friendly; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: RevMenu() <br>// <br>//  PURPOSE:  Called on WM_COMMAND messages <br>// <br> <br>VOID NEAR PASCAL RevMenu( <br>register HWND   hWindow, <br>INT             idval) <br> <br>{ <br>  HDC           hDC; <br>  register INT  cmd; <br> <br>  if (fThinking) <br>      return; <br> <br>  hWin = hWindow; <br> <br>  switch (idval) <br>    { <br>      case EXIT: <br>          PostMessage(hWindow, WM_CLOSE, 0, 0L); <br>          break; <br> <br>      case MN_HELP_ABOUT: <br>          DialogBox(hInst, MAKEINTRESOURCE(3), hWindow, (WNDPROC)lpprocAbout); <br>          break; <br> <br>      case MN_HELP_INDEX: <br>          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_INDEX, 0L); <br>          break; <br> <br>      case MN_HELP_USINGHELP: <br>          //TEMPFIX WinHelp(hWindow, (LPSTR)NULL, HELP_HELPONHELP, 0L); <br>          break; <br> <br>      case MN_HELP_KEYBOARD: <br>          cmd = 0x1e; <br>          goto HelpCommon; <br> <br>      case MN_HELP_COMMANDS: <br>          cmd = 0x20; <br>          goto HelpCommon; <br> <br>      case MN_HELP_PLAYING: <br>          cmd = 0x21; <br>          goto HelpCommon; <br> <br>      case MN_HELP_RULES: <br>          cmd = 0x22; <br>HelpCommon: <br>          //TEMPFIX WinHelp(hWindow, (LPSTR)szHelpFile, HELP_CONTEXT, (DWORD)cmd); <br>          break; <br> <br>      case HINT: <br>          ShowBestMove(hWindow); <br>          return; <br>          break; <br> <br>      case NEW: <br>          SetWindowText(hWindow , (LPSTR)szReversi); <br>          ffirstmove = TRUE; <br>          hDisp = hDC = GetDC(hWindow); <br>          fCheated = FALSE; <br>          SetBkMode(hDisp, OPAQUE); <br>          ClearMessageTop(hDC); <br>          fPass = PASS; <br>          clearboard(board); <br>          drawboard(board); <br>          ReleaseDC(hWindow, hDC); <br>          hDisp = 0; <br>          break; <br> <br>      case EASY: <br>          depth = 1;                      // MUST BE AT LEAST 1. <br>          checkdepth(hWindow, EASY);      // KEEP HANDS OFF! <br>          break; <br> <br>      case MEDIUM: <br>          depth = 2; <br>          checkdepth(hWindow, MEDIUM); <br>          break; <br> <br>      case HARD: <br>          depth = 4; <br>          checkdepth(hWindow, HARD); <br>          break; <br> <br>      case VHARD: <br>          depth = 6; <br>          checkdepth(hWindow, VHARD); <br>          break; <br> <br>      case PASS: <br>          if (fPass == PASS) <br>            { <br>              hDisp = hDC = GetDC(hWindow); <br>              SetBkMode(hDisp, OPAQUE); <br>              fThinking = TRUE; <br>              ClearMessageTop(hDC); <br>              SetCursor(curThink); <br>              ReleaseDC(hWindow, hDC); <br>              hDisp = 0; <br>              minmax(board, PASS, human, computer, 0, -infin, infin); <br>              hDisp = hDC = GetDC(hWindow); <br>              paintmove(board[0], BestMove[0], (BYTE)computer, (BYTE)human); <br>              gameover(hWindow, hDC, board, BestMove[0]); <br>              SetCursor(curIllegal); <br>              fThinking = FALSE; <br>              ReleaseDC(hWindow, hDC); <br>              hDisp = 0; <br>            } <br>          else <br>              MessageBox(hWindow, (LPSTR)szNoPass, (LPSTR)szReversi, MB_OK | MB_ICONASTERISK); <br>          break; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: RevInit() <br>// <br>//  PURPOSE:  Initializes window data and registers window  <br>// <br> <br>BOOL NEAR PASCAL RevInit( <br>HANDLE hInstance) <br> <br>{ <br>  register PWNDCLASS    pRevClass; <br>  HDC                   hdc; <br> <br>  hbrWhite = GetStockObject(WHITE_BRUSH); <br>  hbrBlack = GetStockObject(BLACK_BRUSH); <br>  hbrPat   = GetStockObject(LTGRAY_BRUSH); <br> <br>  if (!hbrPat) <br>      return(FALSE); <br>  ffirstmove = TRUE; <br>  hdc = GetDC((HWND)NULL); <br> <br>  COLOR = GetDeviceCaps(hdc, BITSPIXEL) &gt; 1; <br> <br>  if (GetDeviceCaps(hdc, VERTRES) == 200) <br>      ASPECT = 2; <br>  else <br>      ASPECT = 1; <br>  ReleaseDC((HWND)NULL, hdc); <br> <br>  hbrRed        = (HBRUSH)CreateSolidBrush(RGB(0xFF,0,0)); <br>  hbrGreen      = (HBRUSH)CreateSolidBrush(RGB(0,0xFF,0)); <br>  hbrBlue       = (HBRUSH)CreateSolidBrush(RGB(0,0,0xFF)); <br> <br>  if (!hbrRed || !hbrGreen || !hbrBlue) <br>      return(FALSE); <br> <br>  LoadString(hInstance, 3,  (LPSTR)szReversi, 20); <br>  LoadString(hInstance, 4,  (LPSTR)szReversiPractice, 40); <br>  LoadString(hInstance, 5,  (LPSTR)szPass, 30); <br>  LoadString(hInstance, 6,  (LPSTR)szMustPass, 30); <br>  LoadString(hInstance, 7,  (LPSTR)szTie, 30); <br>  LoadString(hInstance, 8,  (LPSTR)szLoss, 30); <br>  LoadString(hInstance, 9,  (LPSTR)szWon, 30); <br>  LoadString(hInstance, 10, (LPSTR)szAbout, 20); <br>  LoadString(hInstance, 11, (LPSTR)szLossPost, 30); <br>  LoadString(hInstance, 12, (LPSTR)szWonPost, 30); <br>  LoadString(hInstance, 13, (LPSTR)szIllegal, 70); <br>  LoadString(hInstance, 14, (LPSTR)szNoPass, 70); <br>  LoadString(hInstance, 15, (LPSTR)szHelpFile, 15); <br> <br>  hAccel = LoadAccelerators(hInstance, (LPSTR)"MAINACC"); <br>  pRevClass = (PWNDCLASS)((CHAR *)LocalAlloc(LMEM_ZEROINIT, sizeof(WNDCLASS))); <br>  if (!pRevClass) <br>      return(FALSE); <br> <br>  curLegal   = LoadCursor(NULL, IDC_CROSS); <br>  curIllegal = LoadCursor(NULL, IDC_ARROW); <br>  curThink   = LoadCursor(NULL, IDC_WAIT); <br>  curBlank   = LoadCursor(hInstance, MAKEINTRESOURCE(1)); <br>  if (!curLegal || !curIllegal || !curThink || !curBlank) <br>      return(FALSE); <br>  pRevClass-&gt;hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(3)); <br> <br>  pRevClass-&gt;lpszClassName = (LPSTR)"Reversi"; <br>  pRevClass-&gt;hbrBackground = ((COLOR) ? hbrGreen : hbrWhite); <br>  pRevClass-&gt;lpfnWndProc   = ReversiWndProc; <br>  pRevClass-&gt;lpszMenuName  = MAKEINTRESOURCE(1); <br>  pRevClass-&gt;hInstance    = hInstance; <br>  pRevClass-&gt;style         = CS_VREDRAW | CS_HREDRAW | CS_BYTEALIGNCLIENT; <br> <br>  if (!RegisterClass((LPWNDCLASS)pRevClass)) <br>    { <br>      LocalFree((HANDLE)pRevClass); <br>      return(FALSE); <br>    } <br>  LocalFree((HANDLE)pRevClass); <br> <br>  return(TRUE); <br>} <br> <br> <br>// <br>//  FUNCTION: RevMouseClick() <br>// <br>//  PURPOSE:  Handle mouse click or keyboard space or CR  <br>// <br> <br>VOID NEAR PASCAL RevMouseClick( <br>HWND  hWnd, <br>POINT point) <br>{ <br>  INT     move; <br>  INT     Si, Sj; <br>  INT     yLineExt = 8 * yExt; <br>  INT     xLineExt = 8 * xExt; <br>  HDC     hDC; <br> <br>  MousePos.x = point.x; <br>  MousePos.y = point.y; <br> <br>  if (xExt == 0 || yExt == 0) <br>      return; <br> <br>  if ((point.x &gt; Bx) &amp;&amp; (point.x &lt; (Bx+xLineExt)) &amp;&amp; (point.y &gt; By) &amp;&amp; (point.y &lt; (By+yLineExt))) <br>    { <br>      Si = (point.x - Bx) / xExt; <br>      Sj = (point.y - By) / yExt; <br>      move = Si * 10 + Sj + 11; <br>      if (legalcheck(board[0], move, human, computer)) <br>        { <br>          board[0][move] = human; <br>          ffirstmove = FALSE; <br>          fThinking = TRUE; <br>          SetCursor(curThink); <br> <br>          hDisp = hDC = GetDC(hWnd); <br>          ClearMessageTop(hDC); <br> <br>          minmax(board, move, human, computer, 0, -infin, infin); <br>          makemove(board[0], move, human, computer); <br> <br>          hDisp = hDC; <br> <br>          paintmove(board[0], BestMove[0], computer, human); <br>          gameover(hWnd, hDC, board, BestMove[0]); <br> <br>          ReleaseDC(hWnd, hDC); <br>          hDisp = 0; <br> <br>          SetCursor(curIllegal); <br>          fThinking = FALSE; <br>        } <br>      else <br>          MessageBox(hWnd, (LPSTR)szIllegal, (LPSTR)szReversi, MB_OK | MB_ICONASTERISK); <br>   } <br>} <br> <br> <br>// <br>//  FUNCTION: Next() <br>// <br>//  PURPOSE:  Find next square  <br>// <br> <br>VOID NEAR PASCAL Next( <br>register INT *px, <br>register INT *py) <br> <br>{ <br>  (*px)++; <br>  if (*px &gt; 7) <br>    { <br>      *px = 0; <br>      (*py)++; <br>      if (*py &gt; 7) <br>          *py = 0; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: Previous() <br>// <br>//  PURPOSE:  Find previous square  <br>// <br> <br>VOID NEAR PASCAL Previous( <br>register INT *px, <br>register INT *py) <br>{ <br>  (*px)--; <br>  if (*px &lt; 0) <br>    { <br>      *px = 7; <br>      (*py)--; <br>      if (*py &lt; 0) <br>          *py = 7; <br>    } <br>} <br> <br> <br>// <br>//  FUNCTION: ShowNextMove() <br>// <br>//  PURPOSE:  Show next legal move  <br>// <br> <br>VOID NEAR PASCAL ShowNextMove( <br>HWND    hwnd, <br>BOOL    fforward) <br>{ <br>  INT       x, y; <br>  INT       potentialmove; <br>  BOOL      done; <br> <br>  if (fPass == PASS &amp;&amp; !ffirstmove)   // Watch out for infinite loops <br>      return; <br> <br>  x = (MousePos.x - Bx) / xExt; <br>  y = (MousePos.y - By) / yExt; <br> <br>  done = FALSE; <br>  while (!done) <br>    { <br>      do <br>        { <br>          if (fforward) <br>              Next(&amp;x, &amp;y); <br>          else <br>              Previous(&amp;x, &amp;y); <br>        } <br>      while ((board[0][potentialmove = (x * 10 + y + 11)]) != empty); <br> <br>      fThinking = TRUE; <br>      if (legalcheck(board[0], potentialmove, human, computer)) <br>          done = TRUE; <br> <br>      fThinking = FALSE; <br>    } <br> <br>  MousePos.x = x * xExt + Bx + xExt / 2; <br>  MousePos.y = y * yExt + By + yExt / 2; <br> <br>  UpdateCursor(hwnd); <br>  RevMouseMove(MousePos); <br>} <br> <br> <br>// <br>//  FUNCTION: RevChar() <br>// <br>//  PURPOSE:  Called on WM_KEYDOWN messages  <br>// <br> <br>VOID NEAR PASCAL RevChar( <br>HWND            hwnd, <br>register WORD   code) <br>{ <br>  INT   a; <br>  POINT curpoint; <br> <br>  curpoint.x = curpoint.y = 1; <br>  switch (code) <br>    { <br>      case 0x27: <br>          MousePos.x += xExt; <br>          break; <br> <br>      case 0x28: <br>          MousePos.y += yExt; <br>          break; <br> <br>      case 0x25: <br>          curpoint.x = (MousePos.x - Bx)/xExt; <br>          MousePos.x -= xExt; <br>          break; <br> <br>      case 0x26: <br>          curpoint.y = (MousePos.y - By)/yExt; <br>          MousePos.y -= yExt; <br>          break; <br> <br>      case 0x24: <br>          curpoint.y = (MousePos.y - By)/yExt; <br>          curpoint.x = (MousePos.x - Bx)/xExt; <br>          MousePos.y -= yExt; <br>          MousePos.x -= xExt; <br>          break; <br> <br>      case 0x21: <br>          curpoint.y = (MousePos.y - By)/yExt; <br>          MousePos.y -= yExt; <br>          MousePos.x += xExt; <br>          break; <br> <br>      case 0x23: <br>          curpoint.x = (MousePos.x - Bx)/xExt; <br>          MousePos.y += yExt; <br>          MousePos.x -= xExt; <br>          break; <br> <br>      case 0x22: <br>          MousePos.y += yExt; <br>          MousePos.x += xExt; <br>          break; <br> <br>      case 0x0020: <br>      case 0x000D: <br>          if (!fThinking) <br>              RevMouseClick(hwnd, MousePos); <br>          return; <br> <br>      case 0x0009: <br>          if (fThinking) <br>              break; <br>          if (GetKeyState(VK_SHIFT) &lt; 0) <br>              ShowNextMove(hwnd, FALSE);    // look backwards <br>          else <br>              ShowNextMove(hwnd, TRUE);     // look forwards <br>          return; <br> <br>      default: <br>          return; <br>    } <br> <br>  if (((a = ((MousePos.x - Bx) / xExt)) &gt;7) || a &lt;= 0) <br>      MousePos.x = Bx + xExt / 2;             /* wrap around horizontally */ <br> <br>  if (a &gt; 8 || (curpoint.x == 0 &amp;&amp; a == 0)) </code></pre>
<p>
</p>
<pre><code>MousePos.x = (7*xExt) + Bx + xExt / 2 ; <br> <br>  if ( ((a = ((MousePos.y - By) / yExt)) &gt;7) || a &lt;= 0) <br>      MousePos.y = By + yExt / 2; <br> <br>  if ( a &gt; 8 || (curpoint.y == 0 &amp;&amp; a == 0)) <br>      MousePos.y = (7*yExt) + By + yExt / 2; <br> <br>  MousePos.x = ((MousePos.x - Bx) / xExt) * xExt + Bx + xExt / 2; <br>  MousePos.y = ((MousePos.y - By) / yExt) * yExt + By + yExt / 2; <br>  UpdateCursor(hwnd); <br>  RevMouseMove(MousePos); <br>} <br> <br> <br>// <br>//  FUNCTION: InverseMessage() <br>// <br>//  PURPOSE:  Callback - inverts message bitmap or kills timer  <br>// <br> <br>LONG APIENTRY InverseMessage( <br>register HWND   hWindow, <br>UINT            message, <br>WPARAM          wParam, <br>LONG            lParam) <br>{ <br>  HDC   hDC; <br> <br>  message; <br>  wParam; <br>  lParam; <br> <br>  if (flashtimes &lt;= count) <br>    { <br>      hDC = GetDC(hWindow); <br>      PatBlt(hDC, 0, 0, xscr, charheight, DSTINVERT); <br>      flashtimes++; <br>      ReleaseDC(hWindow, hDC); <br>    } <br>  else <br>      KillTimer(hWindow, 666); <br>  return(0L); <br>} <br> <br> <br>// <br>//  FUNCTION: ReversiWndProc() <br>// <br>//  PURPOSE:  Processes messages for "Reversi" window   <br>// <br> <br>LONG APIENTRY ReversiWndProc( <br>HWND            hWnd, <br>register UINT   message, <br>WPARAM          wParam, <br>LONG            lParam) <br>{ <br>  HMENU         hm; <br>  PAINTSTRUCT   ps; <br>  POINT         curpoint; <br> <br>  switch (message) <br>    { <br>      case WM_COMMAND: <br>          RevMenu(hWnd, GET_WM_COMMAND_ID(wParam, lParam)); <br>          break; <br> <br>      case WM_INITMENU:                 // disable the menu if thinking <br>          hm = GetMenu(hWnd); <br>          if (fThinking) <br>            { <br>              EnableMenuItem(hm, 0, MF_DISABLED | MF_BYPOSITION); <br>              EnableMenuItem(hm, 1, MF_DISABLED | MF_BYPOSITION); <br>            } <br>          else <br>            { <br>              EnableMenuItem(hm, 0, MF_ENABLED | MF_BYPOSITION); <br>              EnableMenuItem(hm, 1, MF_ENABLED | MF_BYPOSITION); <br>            } <br>          break; <br> <br>      case WM_CREATE: <br>          RevCreate(hWnd); <br>          hWin = hWnd; <br>          break; <br> <br>      case WM_CLOSE: <br>          return(DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>      case WM_DESTROY: <br>          //if (MGetModuleUsage(hInst) == 1) <br>            { <br>              // check this because the green brush is used as the class <br>              // background brush if we are on a color system in which <br>              // case we don't handle the brush deletion, Windows does <br>              if (!COLOR) <br>                DeleteObject(hbrGreen); <br> <br>              DeleteObject(hbrRed); <br>              DeleteObject(hbrBlue); <br>            } <br> <br>          // In case WinHelp keys off hWindow, we need to do the HELP_QUIT <br>          // here instead of when there is just one instance of help... <br>          // <br>          //TEMPFIX WinHelp(hWnd, (LPSTR)szHelpFile, HELP_QUIT, 0L); <br> <br>          PostQuitMessage(0); <br>          break; <br> <br>      case WM_KEYDOWN: <br>          if (IsIconic(hWnd)) <br>              return 0L; <br>          RevChar(hWnd, (WORD)wParam); <br>          break; <br> <br>      case WM_ACTIVATE: <br>          if (!GetSystemMetrics(SM_MOUSEPRESENT)) <br>            { <br>              if (GET_WM_ACTIVATE_STATE(wParam, lParam)) <br>                { <br>                  if (GET_WM_ACTIVATE_HWND(wParam, lParam) != hWnd) <br>                    { <br>                      curpoint.x = MousePos.x; <br>                      curpoint.y = MousePos.y; <br>                      ClientToScreen(hWnd, (LPPOINT)&amp;curpoint); <br>                      SetCursorPos(curpoint.x, curpoint.y); <br>                      RevMouseMove(MousePos); <br>                      ShowCursor(GET_WM_ACTIVATE_STATE(wParam, lParam)); <br>                    } <br>                } <br>              else <br>                  ShowCursor(wParam); <br>            } <br>          if (wParam &amp;&amp; (!HIWORD(lParam))) <br>              SetFocus(hWnd); <br>          break; <br> <br>      case WM_PAINT: <br>          BeginPaint(hWnd, (LPPAINTSTRUCT)&amp;ps); <br>          RevPaint(hWnd, ps.hdc); <br>          EndPaint(hWnd, (LPPAINTSTRUCT)&amp;ps); <br>          break; <br> <br>      case WM_MOUSEMOVE: <br>          { <br>          POINT pt; <br> <br>          LONG2POINT(lParam, pt);  // convert LONG lParam to POINT structure <br>          if (!fThinking) <br>#ifdef ORGCODE       <br>              RevMouseMove(MAKEPOINT(lParam)); <br>#else <br>              RevMouseMove(pt); <br>#endif <br>          else <br>              SetCursor(curThink); <br>          break; <br>          } <br>      case WM_LBUTTONDOWN: <br>          SetCapture(hWnd); <br>          bMouseDownInReversi = TRUE; <br>          break; <br> <br>      case WM_LBUTTONUP: <br>          { <br>          POINT pt; <br> <br>          LONG2POINT(lParam, pt);  // convert LONG lParam to POINT structure <br> <br>          ReleaseCapture(); <br>          if (!fThinking &amp;&amp; bMouseDownInReversi) <br>#ifdef ORGCODE <br>              RevMouseClick(hWnd, MAKEMPOINT(lParam)); <br>#else <br>              RevMouseClick(hWnd, pt); <br>#endif <br>          bMouseDownInReversi = FALSE; <br>          break; <br>          } <br>      case WM_TIMER: <br>          // This should never be called. <br>          break; <br> <br>      case WM_VSCROLL: <br>      case WM_HSCROLL: <br>              break; <br> <br>      default: <br>          return(DefWindowProc(hWnd, message, wParam, lParam)); <br>          break; <br>      } <br>  return(0L); <br>} <br> <br>// <br>//  FUNCTION: AboutDlgProc(HWND, WORD, WORD, LONG) <br>// <br>//  PURPOSE:  Processes messages for "About" dialog box <br>// <br>//  MESSAGES: <br>// <br>//      WM_INITDIALOG - initialize dialog box <br>//      WM_COMMAND    - Input received <br>// <br> <br>BOOL APIENTRY AboutDlgProc( <br>HWND        hDlg, <br>WORD        message, <br>WORD        wParam, <br>LONG        lParam) <br> <br>{ <br>  if (message == WM_COMMAND) <br>    { <br>      EndDialog(hDlg, TRUE); <br>      return(TRUE); <br>    } <br>  if (message == WM_INITDIALOG) <br>      return(TRUE); <br>  else <br>      return(FALSE); <br>  UNREFERENCED_PARAMETER(wParam);    <br>  UNREFERENCED_PARAMETER(lParam);    <br>} <br> <br> <br>// <br>//  FUNCTION: WinMain <br>// <br>//  PURPOSE: calls initialization function, processes message loop <br>// <br> <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrev, <br>    LPSTR     lpCmdLine, <br>    int       cmdShow <br>) { <br>  HWND hWnd; <br>  MSG   msg; <br> <br>  hInst = hInstance; <br>  if (!hPrev) <br>    { <br>      if (!RevInit(hInstance)) <br>          return(FALSE); <br>    } <br>  else <br>    { <br>      if (fThinking) <br>          return FALSE; <br>#ifdef WIN16 <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrBlack,           sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrPat,             sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrWhite,           sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrRed,             sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrBlue,            sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrGreen,           sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrComputer,        sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hbrHuman,           sizeof(HBRUSH)); <br>      GetInstanceData(hPrev, (PSTR)&amp;curIllegal,         sizeof(HCURSOR)); <br>      GetInstanceData(hPrev, (PSTR)&amp;curLegal,           sizeof(HCURSOR)); <br>      GetInstanceData(hPrev, (PSTR)&amp;curThink,           sizeof(HCURSOR)); <br>      GetInstanceData(hPrev, (PSTR)&amp;curBlank,           sizeof(HCURSOR)); <br>      GetInstanceData(hPrev, (PSTR)&amp;prevCheck,          sizeof(prevCheck)); <br>      GetInstanceData(hPrev, (PSTR)&amp;depth,              sizeof(depth)); <br>      GetInstanceData(hPrev, (PSTR)direc,               sizeof(direc)); <br>      GetInstanceData(hPrev, (PSTR)moves,               sizeof(moves)); <br>      GetInstanceData(hPrev, (PSTR)szReversi,           20); <br>      GetInstanceData(hPrev, (PSTR)szReversiPractice,   40); <br>      GetInstanceData(hPrev, (PSTR)szPass,              10); <br>      GetInstanceData(hPrev, (PSTR)szMustPass,          20); <br>      GetInstanceData(hPrev, (PSTR)szTie,               15); <br>      GetInstanceData(hPrev, (PSTR)szLoss,              15); <br>      GetInstanceData(hPrev, (PSTR)szWon,               15); <br>      GetInstanceData(hPrev, (PSTR)szAbout,             20); <br>      GetInstanceData(hPrev, (PSTR)&amp;COLOR,              sizeof(INT)); <br>      GetInstanceData(hPrev, (PSTR)&amp;ASPECT,             sizeof(INT)); <br>      GetInstanceData(hPrev, (PSTR)&amp;hAccel,             2); <br>      GetInstanceData(hPrev, (PSTR)szIllegal,           70); <br>      GetInstanceData(hPrev, (PSTR)szNoPass,            70); <br>      GetInstanceData(hPrev, (PSTR)szHelpFile,          15); <br>#endif // WIN16      <br>    } <br>  lpprocInverseMessage = (WNDPROC)MakeProcInstance((FARPROC)(LPVOID)InverseMessage, hInstance); <br> <br>  TYMIN = 45; <br>  fThinking = FALSE; <br> <br>  lpprocAbout = MakeProcInstance((FARPROC)AboutDlgProc, hInstance); <br>  hWnd = CreateWindow((LPSTR) "Reversi", <br>                fCheated ? (LPSTR)szReversiPractice : (LPSTR)szReversi, <br>                WS_TILEDWINDOW, <br>                CW_USEDEFAULT, <br>                0, <br>                (GetSystemMetrics(SM_CXSCREEN) &gt;&gt; 1), <br>                (GetSystemMetrics(SM_CYSCREEN) * 4 / 5), <br>                (HANDLE)NULL, <br>                (HANDLE)NULL, <br>                (HANDLE)hInstance, <br>                NULL); <br> <br>  if (!hWnd) <br>      return(FALSE); <br> <br>  ShowWindow(hWnd, cmdShow); <br>  UpdateWindow(hWnd); <br> <br>  // Messaging Loop <br>  while (GetMessage((LPMSG)&amp;msg, NULL, 0, 0)) <br>    { <br>      if (!TranslateAccelerator(msg.hwnd, hAccel, (LPMSG)&amp;msg)) <br>        { <br>          TranslateMessage((LPMSG)&amp;msg); <br>          DispatchMessage((LPMSG)&amp;msg); <br>        } <br>    } <br>  return(0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
