<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRINT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3478"></a>PRINT.C</h2>
<pre><code>//******************************************************************** <br>// <br>//  print.c <br>// <br>//  Source file for Device-Independent Bitmap (DIB) API.  Provides <br>//  the following functions: <br>// <br>//  PrintWindow()       - Prints all or part of a window <br>//  PrintScreen()       - Prints the entire screen <br>//  PrintDIB()          - Prints the specified DIB <br>// <br>// Written by Microsoft Product Support Services, Developer Support. <br>// Copyright 1991-1998 Microsoft Corporation. All rights reserved. <br>//******************************************************************** <br> <br>#define     STRICT      // enable strict type checking <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "dibdll.h"     // Header for printing dialog &amp; DLL instance handle <br>#include "dibapi.h"     // Header for DIB functions <br>#include "dibutil.h"    // Auxiliary functions <br> <br> <br>extern HANDLE   ghDLLInst;      // Global handle to DLL's instance <br> <br>/*************************************************************** <br> * Typedefs <br> **************************************************************/ <br> <br>// Structure used for Banding <br> <br>typedef struct <br>{ <br>   BOOL bGraphics; <br>   BOOL bText; <br>   RECT GraphicsRect; <br>} BANDINFOSTRUCT; <br> <br> <br>/**************************************************************** <br> * Variables <br> ***************************************************************/ <br> <br>HWND hDlgAbort;                    // Handle to Abort Dialog <br>char szPrintDlg[] = "PRINTING";    // Name of Print dialog from .RC <br>BOOL bAbort = FALSE;               // Abort a print operation? <br>char gszDevice[50];                // Keeps track out device (e.g. "HP LaserJet") <br>char gszOutput[50];                // Output device (e.g. "LPT1:") <br> <br>/*************************************************************** <br> * Function prototypes for functions local to this module <br> **************************************************************/ <br> <br>BOOL CALLBACK PrintAbortProc(HDC, int); <br>int CALLBACK PrintAbortDlg(HWND, UINT, WPARAM, LPARAM); <br>WORD PrintBand(HDC, LPRECT, LPRECT, BOOL, BOOL, LPBITMAPINFOHEADER, LPSTR); <br>HDC GetPrinterDC(void); <br>void CalculatePrintRect(HDC, LPRECT, WORD, DWORD, DWORD); <br> <br> <br>/********************************************************************** <br> * <br> * PrintWindow() <br> * <br> * <br> * Description: <br> * <br> * This function prints the specified window on the default <br> * printer. <br> * <br> * Parameters: <br> * <br> * HWND hWnd       - Specifies the window to print.  The window must <br> *                   not be iconic and must be topmost on the display. <br> * <br> * WORD fPrintArea - Specifies the area of the window to print.  Must be <br> *                   one of PW_ALL, PW_CLIENT, PW_CAPTION,  or PW_MENUBAR <br> * <br> * WORD fPrintOpt  - Print options (one of PW_BESTFIT, PW_STRETCHTOPAGE, or <br> *                   PW_SCALE) <br> * <br> * WORD wXScale, wYScale - X and Y scaling factors if PW_SCALE is specified <br> * <br> * LPSTR szJobName - Name that you would like to give to this print job (this <br> *                   name shows up in the Print Manager as well as the <br> *                   "Now Printing..." dialog box). <br> * Return Value: <br> *      ERR_DIBFUNCTION or any return value from PrintDIB <br> * <br> **********************************************************************/ <br> <br> <br>WORD PrintWindow(HWND hWnd, WORD fPrintArea, WORD fPrintOpt, WORD wXScale, <br>        WORD wYScale, LPSTR szJobName) <br>{ <br>    HDIB    hDib;          // Handle to the DIB <br>    WORD    wReturn;       // our return value <br> <br>    // Parameter validation <br> <br>    if (!hWnd) <br>        return ERR_INVALIDHANDLE;  // Invalid Window <br> <br>    // Copy the Window to a DIB and print it. <br> <br>    hDib = CopyWindowToDIB(hWnd, fPrintArea); <br>    if (!hDib) <br>        return ERR_DIBFUNCTION; // CopyWindowToDIB failed! <br> <br>    wReturn = PrintDIB(hDib, fPrintOpt, wXScale, wYScale, szJobName); <br> <br>    // Call DestroyDIB to free the memory the dib takes up. <br> <br>    DestroyDIB(hDib); <br>    return wReturn;   // return the value from PrintDIB <br>} <br> <br> <br>/********************************************************************** <br> * <br> * PrintScreen() <br> * <br> * <br> * Description: <br> * <br> * This function prints the specified portion of the display screen on the <br> * default printer using the print options specified.  The print <br> * options are listed in dibapi.h. <br> * <br> * Parameters: <br> * <br> * LPRECT rRegion  - Specifies the region of the screen (in screen <br> *                   coordinates) to print <br> * <br> * WORD fPrintOpt  - Print options  (PW_BESTFIT, PW_STRETCHTOPAGE, or PW_SCALE) <br> * <br> * WORD wXScale, wYScale - X and Y scaling factors if PW_SCALE is specified <br> * <br> * LPSTR szJobName - Name that you would like to give to this print job (this <br> *                   name shows up in the Print Manager as well as the <br> *                   "Now Printing..." dialog box). <br> * <br> * Return Value: <br> *      ERR_DIBFUNCTION or any return value from PrintDIB <br> * <br> **********************************************************************/ <br> <br>WORD PrintScreen(LPRECT rRegion, WORD fPrintOpt, WORD wXScale, WORD wYScale, <br>        LPSTR szJobName) <br>{ <br>    HDIB     hDib;          // A Handle to our DIB <br>    WORD     wReturn;       // Return value <br> <br>    // Copy the screen contained in the specified rectangle to a DIB <br> <br>    hDib = CopyScreenToDIB(rRegion); <br> <br>    if (!hDib) <br>        return ERR_DIBFUNCTION;   // CopyScreenToDIB failed! <br> <br>    wReturn = PrintDIB(hDib, fPrintOpt, wXScale, wYScale, szJobName); <br>    DestroyDIB(hDib); <br>    return wReturn; // Return the value that PrintDIB returned <br>} <br> <br> <br>/********************************************************************** <br> * <br> * PrintDIB() <br> * <br> * Description: <br> * <br> * This routine prints the specified DIB.  The actual printing is done <br> * in the PrintBand() routine (see below), this procedure drives the <br> * printing operation.  PrintDIB() has the code to handle both banding <br> * and non-banding printers.  A banding printer can be distinguished by <br> * the GetDeviceCaps() API (see the code below).  On banding devices, <br> * must repeatedly call the NEXTBAND escape to get the next banding <br> * rectangle to print into.  If the device supports the BANDINFO escape, <br> * it should be used to determine whether the band "wants" text or <br> * graphics (or both).  On non-banding devices, we can ignore all this <br> * and call PrintBand() on the entire page. <br> * <br> * Parameters: <br> * <br> * HDIB hDib       - Handle to dib to be printed <br> * <br> * WORD fPrintOpt  - tells which print option to use (PW_BESTFIT, <br> *                   PW_STRETCHTOPAGE, OR PW_SCALE) <br> * <br> * WORD wXScale, wYScale - X and Y scaling factors (integers) for <br> *                   printed output if the PW_SCALE option is used. <br> * <br> * LPSTR szJobName - Name that you would like to give to this print job (this <br> *                   name shows up in the Print Manager as well as the <br> *                   "Now Printing..." dialog box). <br> * <br> * Return Value:  (see errors.h for description) <br> * <br> * One of: ERR_INVALIDHANDLE <br> *         ERR_LOCK <br> *         ERR_SETABORTPROC <br> *         ERR_STARTDOC <br> *         ERR_NEWFRAME <br> *         ERR_ENDDOC <br> *         ERR_GETDC <br> *         ERR_STRETCHDIBITS <br> * <br> ********************************************************************/ <br> <br>WORD PrintDIB(HDIB hDib, WORD fPrintOpt, WORD wXScale, WORD wYScale, <br>        LPSTR szJobName) <br>{ <br>    HDC                 hPrnDC;         // DC to the printer <br>    RECT                rect;           // Rect structure used for banding <br>    LPSTR               lpBits;         // pointer to the DIB bits <br>    LPBITMAPINFOHEADER  lpDIBHdr;       // Pointer to DIB header <br>    int                 nBandCount = 0; // used for print dialog box to count bands <br>    WORD                wErrorCode = 0; // Error code to return <br>    RECT                rPrintRect;     // specifies the area on the printer <br>                                        // (in printer coordinates) which we <br>                                        // want the DIB to go to <br>    char                szBuffer[70];   // Buffer to hold message for "Printing" dlg box <br>    char                szJobNameTrunc[35];     // szJobName truncated to 31 <br>                                        // characters, since STARTDOC can't <br>                                        // accept a string longer than 31 <br>    DOCINFO             DocInfo;        // structure for StartDoc <br>    int                 nTemp;          // used to check banding capability <br>    CHAR                lpBuffer[128];  // Buffer for strings retrieved from resources <br> <br> <br>    // Paramter validation <br> <br>    if (!hDib) <br>        return ERR_INVALIDHANDLE; <br> <br>    // Get pointer to DIB header <br> <br>    lpDIBHdr = (LPBITMAPINFOHEADER)GlobalLock(hDib); <br>    if (!lpDIBHdr) // Check that we have a valid pointer <br>        return ERR_LOCK; <br>    lpBits = FindDIBBits((LPSTR)lpDIBHdr); // Find pointer to DIB bits <br> <br>    if (hPrnDC = GetPrinterDC()) <br>    { <br>        SetStretchBltMode(hPrnDC, COLORONCOLOR); <br> <br>        // Determine rPrintRect (printer area to print to) from the <br>        // fPrintOpt.  Fill in rPrintRect.left and .top from wXScale and <br>        // wYScale just in case we use PW_SCALE (see the function <br>        // CalculatePrintRect). <br> <br>        rPrintRect.left = wXScale; <br>        rPrintRect.top = wYScale; <br>        CalculatePrintRect(hPrnDC, &amp;rPrintRect, fPrintOpt, lpDIBHdr-&gt;biWidth, <br>                         lpDIBHdr-&gt;biHeight); <br> <br>        // Initialize the abort procedure. <br> <br>        hDlgAbort = CreateDialog(ghDLLInst, szPrintDlg, GetFocus(), <br>                (DLGPROC)PrintAbortDlg); <br> <br>        // ISet the text inside the dialog to the name of our print job <br> <br>        lstrcpy(szJobNameTrunc, szJobName); <br>        szJobNameTrunc[31] = '\0';           // Truncate string to 31 chars <br>        LoadString(ghDLLInst, IDS_PRINTMSG, lpBuffer, sizeof(lpBuffer)); <br>        wsprintf(szBuffer, lpBuffer, (LPSTR)szJobNameTrunc); <br>        SetDlgItemText(hDlgAbort, IDC_PRINTTEXT1, (LPSTR)szBuffer); <br> <br>        // Set global variable bAbort to FALSE.  This will get set to TRUE <br>        // in our PrintAbortDlg() procedure if the user selects the <br>        // CANCEL button in our dialog box <br> <br>        bAbort = FALSE; <br> <br>        // set up the Abort Procedure <br> <br>        if (SetAbortProc(hPrnDC, (ABORTPROC)PrintAbortProc) &lt; 0) <br>                return ERR_SETABORTPROC; <br> <br>        // start print job <br> <br>        ZeroMemory(&amp;DocInfo, sizeof(DOCINFO)); <br>        DocInfo.cbSize = sizeof(DOCINFO); <br>        DocInfo.lpszDocName = (LPTSTR)szJobNameTrunc; <br>        DocInfo.lpszOutput = NULL; <br> <br>        if (StartDoc(hPrnDC, &amp;DocInfo) &lt;= 0) <br>        { <br>            // Oops, something happened, let's clean up here and return <br> <br>             DestroyWindow(hDlgAbort);   // Remove abort dialog box <br>             DeleteDC(hPrnDC); <br>             GlobalUnlock(hDib); <br>             return ERR_STARTDOC; <br>        } <br> <br>// Note: the following banding code applies to Windows 3.1.  With the new <br>//       printing architecture of Win32, send out both the graphics and <br>//       text in one band (like a non-banding device).  This code is used <br>//       for Win32s since Win32s depends on Windows 3.1 printing architecture. <br>// <br>        // Check if need to do banding.  If we do, loop through <br>        // each band in the page, calling NEXTBAND and BANDINFO <br>        // (if supported) calling PrintBand() on the band.  Else, <br>        // call PrintBand() with the entire page as our clipping <br>        // rectangle! <br> <br>        // If Wincap32 is running on Win32s, then use banding <br> <br>        nTemp = NEXTBAND; <br>        if (Escape(hPrnDC, QUERYESCSUPPORT, sizeof(int), (LPSTR)&amp;nTemp, NULL) &amp;&amp; <br>                (GetVersion() &amp; 0x80000000) &amp;&amp; (LOWORD(GetVersion()) == 3)) <br>        { <br>            BOOL                bBandInfoDevice; <br>            BANDINFOSTRUCT      biBandInfo;         // Used for banding <br> <br>            // Fill in initial values for our BandInfo Structure to <br>            // tell driver we can want to do graphics and text, and <br>            // also which area we want the graphics to go in. <br> <br>            biBandInfo.bGraphics = TRUE; <br>            biBandInfo.bText = TRUE; <br>            biBandInfo.GraphicsRect = rPrintRect; <br> <br>            // Check if device supports the BANDINFO escape. <br> <br>            nTemp = BANDINFO; <br>            bBandInfoDevice = Escape(hPrnDC, QUERYESCSUPPORT, sizeof(int), <br>                    (LPSTR)&amp;nTemp, NULL); <br> <br>            // Do each band -- Call Escape() with NEXTBAND, then the <br>            // rect structure returned is the area where we are to <br>            // print in.  This loop exits when the rect area is empty. <br> <br>            while (Escape(hPrnDC, NEXTBAND, 0, NULL, (LPSTR)&amp;rect) &amp;&amp; ! <br>                IsRectEmpty(&amp;rect)) <br>            { <br>                char szTmpBuf[100]; <br> <br> <br>                // Do the BANDINFO, if needed. <br> <br>                if (bBandInfoDevice) <br>                    Escape(hPrnDC, BANDINFO, sizeof(BANDINFOSTRUCT), (LPSTR)&amp; <br>                            biBandInfo, (LPSTR)&amp;biBandInfo); <br>                LoadString(ghDLLInst, IDS_BANDNMBR, lpBuffer, sizeof(lpBuffer)); <br>                wsprintf(szTmpBuf, lpBuffer, ++nBandCount); <br>                SetDlgItemText(hDlgAbort, IDC_PERCENTAGE, (LPSTR)szTmpBuf); <br> <br>                // Call PrintBand() to do actual output into band. <br>                // Pass in our band-info flags to tell what sort <br>                // of data to output into the band.  Note that on <br>                // non-banding devices, we pass in the default bandinfo <br>                // stuff set above (i.e. bText=TRUE, bGraphics=TRUE). <br> <br>                wErrorCode = PrintBand(hPrnDC, &amp;rPrintRect, &amp;rect, <br>                        biBandInfo.bText, biBandInfo.bGraphics, lpDIBHdr, <br>                        lpBits); <br>            } <br>        } <br>        else <br>        { <br>            // Print the whole page -- non-banding device. <br> <br>            if (StartPage(hPrnDC) &lt;= 0) <br>                return ERR_STARTPAGE; <br> <br>            rect = rPrintRect; <br>            LoadString(ghDLLInst, IDS_SENDINGBAND, lpBuffer, sizeof(lpBuffer)); <br>            SetDlgItemText(hDlgAbort, IDC_PERCENTAGE, lpBuffer); <br>            wErrorCode = PrintBand(hPrnDC, &amp;rPrintRect, &amp;rect, TRUE, TRUE, <br>                    lpDIBHdr, lpBits); <br> <br>            // Non-banding devices need a NEWFRAME <br> <br>            if (EndPage(hPrnDC) &lt;= 0) <br>                return ERR_ENDPAGE; <br>        } <br> <br> <br>        // End the print operation.  Only send the ENDDOC if <br>        //  we didn't abort or error. <br> <br>        if (!bAbort) <br>        { <br>            // We errored out on ENDDOC, but don't return here - we still <br>            // need to close the dialog box, free proc instances, etc. <br> <br>            if (EndDoc(hPrnDC) &lt;= 0) <br>                wErrorCode = ERR_ENDDOC; <br> <br>            DestroyWindow(hDlgAbort); <br>        } <br> <br>        // All done, clean up. <br> <br>        DeleteDC(hPrnDC); <br>    } <br>    else <br>        wErrorCode = ERR_GETDC;   // Couldn't get Printer DC! <br> <br>    GlobalUnlock(hDib); <br>    return wErrorCode; <br>} <br> <br> <br> <br> <br>// ******************************************************************* <br>// Auxiliary Functions <br>//     -- Local to this module only <br>// ******************************************************************* <br> <br> <br>/********************************************************************* <br> * <br> * CalculatePrintRect() <br> * <br> * Given fPrintOpt and a size of the DIB, return the area on the <br> * printer where the image should go (in printer coordinates).  If <br> * fPrintOpt is PW_SCALE, then lpPrintRect.left and .top should <br> * contain WORDs which specify the scaling factor for the X and <br> * Y directions, respecively. <br> * <br> ********************************************************************/ <br> <br>void CalculatePrintRect(HDC hDC, LPRECT lpPrintRect, WORD fPrintOpt, <br>        DWORD cxDIB, DWORD cyDIB) <br>{ <br>    int  cxPage, cyPage, cxInch, cyInch; <br> <br>    if (!hDC) <br>        return; <br> <br>    // Get some info from printer driver <br> <br>    cxPage = GetDeviceCaps(hDC, HORZRES);   // Width of printr page - pixels <br>    cyPage = GetDeviceCaps(hDC, VERTRES);   // Height of printr page - pixels <br>    cxInch = GetDeviceCaps(hDC, LOGPIXELSX);// Printer pixels per inch - X <br>    cyInch = GetDeviceCaps(hDC, LOGPIXELSY);// Printer pixels per inch - Y <br> <br>    switch (fPrintOpt) <br>    { <br> <br>        // Best Fit case -- create a rectangle which preserves <br>        // the DIB's aspect ratio, and fills the page horizontally. <br> <br>        // The formula in the "-&gt;bottom" field below calculates the Y <br>        // position of the printed bitmap, based on the size of the <br>        // bitmap, the width of the page, and the relative size of <br>        // a printed pixel (cyInch / cxInch). <br> <br>        case PW_BESTFIT: <br>            lpPrintRect-&gt;top = 0; <br>            lpPrintRect-&gt;left = 0; <br>            lpPrintRect-&gt;bottom = (int)(((double)cyDIB * cxPage * cyInch) / <br>                    ((double)cxDIB * cxInch)); <br>            lpPrintRect-&gt;right = cxPage; <br>            break; <br> <br>        // Scaling option -- lpPrintRect's top/left contain <br>        // multipliers to multiply the DIB's height/width by. <br> <br>        case PW_SCALE: <br>        { <br>            int     cxMult, cyMult; <br> <br>            cxMult = lpPrintRect-&gt;left; <br>            cyMult = lpPrintRect-&gt;top; <br>            lpPrintRect-&gt;top = 0; <br>            lpPrintRect-&gt;left = 0; <br>            lpPrintRect-&gt;bottom = (int)(cyDIB * cyMult); <br>            lpPrintRect-&gt;right = (int)(cxDIB * cxMult); <br>            break; <br>        } <br> <br>        // Stretch To Page case -- create a rectangle <br>        // which covers the entire printing page (note that this <br>        // is also the default). <br> <br>        case PW_STRETCHTOPAGE: <br> <br>        default: <br>            lpPrintRect-&gt;top = 0; <br>            lpPrintRect-&gt;left = 0; <br>            lpPrintRect-&gt;bottom = cyPage; <br>            lpPrintRect-&gt;right = cxPage; <br>            break; <br>    } <br>} <br> <br> <br>/********************************************************************* <br> * <br> * PrintBand() <br> * <br> * This routine does ALL output to the printer.  It is called from <br> * the PrintDIB() routine.  It is called for both banding and non- <br> * banding printing devices.  lpRectClip contains the rectangular <br> * area we should do our output into (i.e. we should clip our output <br> * to this area).  The flags fDoText and fDoGraphics should be set <br> * appropriately (if we want any text output to the rectangle, set <br> * fDoText to true).  Normally these flags are returned on banding <br> * devices which support the BANDINFO escape. <br> * <br> ********************************************************************/ <br> <br>WORD PrintBand(HDC hDC, LPRECT lpRectOut, LPRECT lpRectClip, BOOL fDoText, <br>        BOOL fDoGraphics, LPBITMAPINFOHEADER lpDIBHdr, LPSTR lpDIBBits) <br>{ <br>    RECT    rect;           // Temporary rectangle <br>    double  dblXScaling,    // X and Y scaling factors <br>            dblYScaling; <br>    WORD    wReturn = 0;    // Return code <br> <br>    if (fDoGraphics) <br>    { <br>        dblXScaling = ((double)lpRectOut-&gt;right - lpRectOut-&gt;left) / (double) <br>                lpDIBHdr-&gt;biWidth; <br>        dblYScaling = ((double)lpRectOut-&gt;bottom - lpRectOut-&gt;top) / (double) <br>                lpDIBHdr-&gt;biHeight; <br> <br>        // Now we set up a temporary rectangle -- this rectangle <br>        // holds the coordinates on the paper where our bitmap <br>        // WILL be output.  We can intersect this rectangle with <br>        // the lpClipRect to see what we NEED to output to this <br>        // band.  Then, we determine the coordinates in the DIB <br>        // to which this rectangle corresponds (using dbl?Scaling). <br> <br>        IntersectRect(&amp;rect, lpRectOut, lpRectClip); <br>        if (!IsRectEmpty(&amp;rect)) <br>        { <br>            RECT    rectIn; <br> <br>            rectIn.left = (int)((rect.left - lpRectOut-&gt;left) / dblXScaling + <br>                    0.5 <br>                       ); <br>            rectIn.top = (int)((rect.top - lpRectOut-&gt;top) / dblYScaling + 0.5); <br>            rectIn.right = (int)(rectIn.left + (rect.right - rect.left) / <br>                    dblXScaling + 0.5); <br>            rectIn.bottom = (int)(rectIn.top + (rect.bottom - rect.top) / <br>                    dblYScaling + 0.5); <br>            if (!StretchDIBits(hDC, rect.left, rect.top, <br>                    rect.right - rect.left, rect.bottom - rect.top, <br>                    rectIn.left, (int)(lpDIBHdr-&gt;biHeight) - <br>                    rectIn.top - (rectIn.bottom - rectIn.top), <br>                    rectIn.right - rectIn.left, rectIn.bottom - rectIn.top, <br>                    lpDIBBits, (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS, <br>                    SRCCOPY)) <br>                wReturn = ERR_STRETCHDIBITS; // StretchDIBits() failed! <br>        } <br>    } <br> <br>    return wReturn; <br>} <br> <br> <br>/*********************************************************************** <br> * <br> * GetPrinterDC() <br> * <br> * Uses PrinDlg common dialog for printer selection and creates a dc. <br> * Returns NULL on error. <br> * <br> ***********************************************************************/ <br> <br>HDC GetPrinterDC() { <br> <br>    PRINTDLG pd; <br> <br>    ZeroMemory(&amp;pd, sizeof(pd)); <br> <br>    pd.lStructSize = sizeof(PRINTDLG); <br>    pd.Flags = PD_RETURNDC; <br> <br>    if (PrintDlg(&amp;pd) == TRUE) <br>    { <br>        DEVNAMES    *pDevNames = GlobalLock(pd.hDevNames); <br> <br>        lstrcpy((LPSTR)gszDevice, <br>                (LPSTR)((char *)pDevNames+pDevNames-&gt;wDeviceOffset)); <br> <br>        if(!lstrcmpi((LPSTR)((char *)pDevNames+pDevNames-&gt;wDeviceOffset), <br>                (LPSTR)((char *)pDevNames+pDevNames-&gt;wOutputOffset))) <br>            lstrcpy((LPSTR)gszOutput, "net:"); <br>        else <br>            lstrcpy((LPSTR)gszOutput, <br>                    (LPSTR)((char *)pDevNames+pDevNames-&gt;wOutputOffset)); <br> <br>        GlobalUnlock(pd.hDevNames); <br>        return pd.hDC; <br>    } <br> <br>    else <br>        return NULL; <br>} <br> <br> <br>/********************************************************************** <br> * PrintAbortProc() <br> * <br> * Abort procedure - contains the message loop while printing is <br> * in progress.  By using a PeekMessage() loop, multitasking <br> * can occur during printing. <br> * <br> **********************************************************************/ <br> <br>BOOL CALLBACK PrintAbortProc(HDC hDC, int code) <br>{ <br>    MSG  msg; <br> <br>    while (!bAbort &amp;&amp; PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) <br>        if (!IsDialogMessage(hDlgAbort, &amp;msg)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br> <br>    return !bAbort; <br>} <br> <br>/*********************************************************************** <br> * <br> * PrintAbortDlg() <br> * <br> * <br> * This is the Dialog Procedure which will handle the "Now Printing" <br> * dialog box.  When the user presses the "Cancel" button, the <br> * global variable bAbort is set to TRUE, which causes the <br> * PrintAbortProc to exit, which in turn causes the printing <br> * operation to terminate. <br> * <br> ***********************************************************************/ <br> <br>int CALLBACK PrintAbortDlg(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (msg) <br>    { <br>        case WM_INITDIALOG: <br>        { <br>            char szBuffer[100]; <br>            CHAR msgBuffer[128]; <br> <br> <br>            // Fill in the text which specifies where this bitmap <br>            // is going ("on HP LaserJet on LPT1", for example) <br>            LoadString(ghDLLInst, IDS_ABORTSTRING, msgBuffer, sizeof(msgBuffer)); <br>            wsprintf(szBuffer, msgBuffer, (LPSTR)gszDevice, <br>                    (LPSTR)gszOutput); <br>            SetDlgItemText(hWnd, IDC_PRINTTEXT2, (LPSTR)szBuffer); <br>            SetFocus(GetDlgItem(hWnd, IDCANCEL)); <br>            return TRUE;     // Return TRUE because we called SetFocus() <br>        } <br> <br>        case WM_COMMAND: <br>            bAbort = TRUE; <br>            DestroyWindow(hWnd); <br>            return TRUE; <br>            break; <br>    } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
