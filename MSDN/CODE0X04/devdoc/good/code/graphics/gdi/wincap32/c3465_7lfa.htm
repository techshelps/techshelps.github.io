<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COPY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3466"></a>COPY.C</h2>
<pre><code>//********************************************************************** <br>// <br>//  copy.c <br>// <br>//  Source file for Device-Independent Bitmap (DIB) API.  Provides <br>//  the following functions: <br>// <br>//  CopyWindowToDIB()   - Copies a window to a DIB <br>//  CopyScreenToDIB()   - Copies entire screen to a DIB <br>//  CopyWindowToBitmap()- Copies a window to a standard Bitmap <br>//  CopyScreenToBitmap()- Copies entire screen to a standard Bitmap <br>//  PaintDIB()          - Displays DIB in the specified DC <br>//  PaintBitmap()       - Displays bitmap in the specified DC <br>// <br>//  The following functions are called from DIBUTIL.C: <br>// <br>//  DIBToBitmap()       - Creates a bitmap from a DIB <br>//  BitmapToDIB()       - Creates a DIB from a bitmap <br>//  DIBWidth()          - Gets the width of the DIB <br>//  DIBHeight()         - Gets the height of the DIB <br>//  CreateDIBPalette()  - Gets the DIB's palette <br>//  GetSystemPalette()  - Gets the current palette <br>// <br>// Written by Microsoft Product Support Services, Developer Support. <br>// Copyright 1991-1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#define     STRICT      // enable strict type checking <br> <br>#include &lt;WINDOWS.H&gt; <br>#include "DIBUTIL.H" <br>#include "DIBAPI.H" <br> <br>/************************************************************************* <br> * <br> * CopyWindowToDIB() <br> * <br> * Parameters: <br> * <br> * HWND hWnd        - specifies the window <br> * <br> * WORD fPrintArea  - specifies the window area to copy into the device- <br> *                    independent bitmap <br> * <br> * Return Value: <br> * <br> * HDIB             - identifies the device-independent bitmap <br> * <br> * Description: <br> * <br> * This function copies the specified part(s) of the window to a device- <br> * independent bitmap. <br> * <br> ************************************************************************/ <br> <br> <br>HDIB CopyWindowToDIB(HWND hWnd, WORD fPrintArea) <br>{ <br>   HDIB     hDIB = NULL;  // handle to DIB <br> <br>   // check for a valid window handle <br> <br>    if (!hWnd) <br>        return NULL; <br> <br>    switch (fPrintArea) <br>    { <br>        case PW_WINDOW: // copy entire window <br>        { <br>            RECT    rectWnd; <br> <br>            // get the window rectangle <br> <br>            GetWindowRect(hWnd, &amp;rectWnd); <br> <br>            // get the DIB of the window by calling <br>            // CopyScreenToDIB and passing it the window rect <br>             <br>            hDIB = CopyScreenToDIB(&amp;rectWnd); <br>            break; <br>        } <br>       <br>        case PW_CLIENT: // copy client area <br>        { <br>            RECT    rectClient; <br>            POINT   pt1, pt2; <br> <br>            // get the client area dimensions <br> <br>            GetClientRect(hWnd, &amp;rectClient); <br> <br>            // convert client coords to screen coords <br> <br>            pt1.x = rectClient.left; <br>            pt1.y = rectClient.top; <br>            pt2.x = rectClient.right; <br>            pt2.y = rectClient.bottom; <br>            ClientToScreen(hWnd, &amp;pt1); <br>            ClientToScreen(hWnd, &amp;pt2); <br>            rectClient.left = pt1.x; <br>            rectClient.top = pt1.y; <br>            rectClient.right = pt2.x; <br>            rectClient.bottom = pt2.y; <br> <br>            // get the DIB of the client area by calling <br>            // CopyScreenToDIB and passing it the client rect <br> <br>            hDIB = CopyScreenToDIB(&amp;rectClient); <br>            break; <br>        } <br>       <br>        default:    // invalid print area <br>            return NULL; <br>    } <br> <br>   // return the handle to the DIB <br> <br>   return hDIB; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * CopyScreenToDIB() <br> * <br> * Parameter: <br> * <br> * LPRECT lpRect    - specifies the window <br> * <br> * Return Value: <br> * <br> * HDIB             - identifies the device-independent bitmap <br> * <br> * Description: <br> * <br> * This function copies the specified part of the screen to a device- <br> * independent bitmap. <br> * <br> ************************************************************************/ <br> <br>HDIB CopyScreenToDIB(LPRECT lpRect) <br>{ <br>    HBITMAP     hBitmap;        // handle to device-dependent bitmap <br>    HPALETTE    hPalette;       // handle to palette <br>    HDIB        hDIB = NULL;    // handle to DIB <br> <br>    // get the device-dependent bitmap in lpRect by calling <br>    //  CopyScreenToBitmap and passing it the rectangle to grab <br> <br>    hBitmap = CopyScreenToBitmap(lpRect); <br> <br>    // check for a valid bitmap handle <br> <br>    if (!hBitmap) <br>      return NULL; <br> <br>    // get the current palette <br> <br>    hPalette = GetSystemPalette(); <br> <br>    // convert the bitmap to a DIB <br> <br>    hDIB = BitmapToDIB(hBitmap, hPalette); <br> <br>    // clean up  <br> <br>    DeleteObject(hPalette); <br>    DeleteObject(hBitmap); <br> <br>    // return handle to the packed-DIB <br>    return hDIB; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * CopyWindowToBitmap() <br> * <br> * Parameters: <br> * <br> * HWND hWnd        - specifies the window <br> * <br> * WORD fPrintArea  - specifies the window area to copy into the device- <br> *                    dependent bitmap <br> * <br> * Return Value: <br> * <br> * HDIB         - identifies the device-dependent bitmap <br> * <br> * Description: <br> * <br> * This function copies the specified part(s) of the window to a device- <br> * dependent bitmap. <br> * <br> * <br> ************************************************************************/ <br> <br>HBITMAP CopyWindowToBitmap(HWND hWnd, WORD fPrintArea) <br>{ <br>    HBITMAP     hBitmap = NULL;  // handle to device-dependent bitmap <br> <br>    // check for a valid window handle <br> <br>    if (!hWnd) <br>        return NULL; <br> <br>    switch (fPrintArea) <br>    { <br>        case PW_WINDOW: // copy entire window <br>        { <br>            RECT    rectWnd; <br> <br>            // get the window rectangle <br> <br>            GetWindowRect(hWnd, &amp;rectWnd); <br> <br>            // get the bitmap of that window by calling <br>            // CopyScreenToBitmap and passing it the window rect <br>        <br>            hBitmap = CopyScreenToBitmap(&amp;rectWnd); <br>            break; <br>        } <br>         <br> <br>        case PW_CLIENT: // copy client area <br>        { <br>            RECT rectClient; <br>            POINT pt1, pt2; <br> <br>            // get client dimensions <br> <br>            GetClientRect(hWnd, &amp;rectClient); <br> <br>            // convert client coords to screen coords <br> <br>            pt1.x = rectClient.left; <br>            pt1.y = rectClient.top; <br>            pt2.x = rectClient.right; <br>            pt2.y = rectClient.bottom; <br>            ClientToScreen(hWnd, &amp;pt1); <br>            ClientToScreen(hWnd, &amp;pt2); <br>            rectClient.left = pt1.x; <br>            rectClient.top = pt1.y; <br>            rectClient.right = pt2.x; <br>            rectClient.bottom = pt2.y; <br> <br>            // get the bitmap of the client area by calling <br>            // CopyScreenToBitmap and passing it the client rect <br>             <br>            hBitmap = CopyScreenToBitmap(&amp;rectClient); <br>            break; <br>        } <br>     <br>        default:    // invalid print area <br>            return NULL; <br>    } <br> <br>    // return handle to the bitmap <br> <br>   return hBitmap; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * CopyScreenToBitmap() <br> * <br> * Parameter: <br> * <br> * LPRECT lpRect    - specifies the window <br> * <br> * Return Value: <br> * <br> * HDIB             - identifies the device-dependent bitmap <br> * <br> * Description: <br> * <br> * This function copies the specified part of the screen to a device- <br> * dependent bitmap. <br> * <br> * <br> ************************************************************************/ <br> <br>HBITMAP CopyScreenToBitmap(LPRECT lpRect) <br>{ <br>    HDC         hScrDC, hMemDC;         // screen DC and memory DC <br>    HBITMAP     hBitmap, hOldBitmap;    // handles to deice-dependent bitmaps <br>    int         nX, nY, nX2, nY2;       // coordinates of rectangle to grab <br>    int         nWidth, nHeight;        // DIB width and height <br>    int         xScrn, yScrn;           // screen resolution <br> <br>    // check for an empty rectangle <br> <br>    if (IsRectEmpty(lpRect)) <br>      return NULL; <br> <br>    // create a DC for the screen and create <br>    // a memory DC compatible to screen DC <br>     <br>    hScrDC = CreateDC("DISPLAY", NULL, NULL, NULL); <br>    hMemDC = CreateCompatibleDC(hScrDC); <br> <br>    // get points of rectangle to grab <br> <br>    nX = lpRect-&gt;left; <br>    nY = lpRect-&gt;top; <br>    nX2 = lpRect-&gt;right; <br>    nY2 = lpRect-&gt;bottom; <br> <br>    // get screen resolution <br> <br>    xScrn = GetDeviceCaps(hScrDC, HORZRES); <br>    yScrn = GetDeviceCaps(hScrDC, VERTRES); <br> <br>    //make sure bitmap rectangle is visible <br> <br>    if (nX &lt; 0) <br>        nX = 0; <br>    if (nY &lt; 0) <br>        nY = 0; <br>    if (nX2 &gt; xScrn) <br>        nX2 = xScrn; <br>    if (nY2 &gt; yScrn) <br>        nY2 = yScrn; <br> <br>    nWidth = nX2 - nX; <br>    nHeight = nY2 - nY; <br> <br>    // create a bitmap compatible with the screen DC <br>    hBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight); <br> <br>    // select new bitmap into memory DC <br>    hOldBitmap = SelectObject(hMemDC, hBitmap); <br> <br>    // bitblt screen DC to memory DC <br>    BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY); <br> <br>    // select old bitmap back into memory DC and get handle to <br>    // bitmap of the screen <br>     <br>    hBitmap = SelectObject(hMemDC, hOldBitmap); <br> <br>    // clean up <br> <br>    DeleteDC(hScrDC); <br>    DeleteDC(hMemDC); <br> <br>    // return handle to the bitmap <br> <br>    return hBitmap; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * PaintDIB() <br> * <br> * Parameters: <br> * <br> * HDC hDC          - DC to do output to <br> * <br> * LPRECT lpDCRect  - rectangle on DC to do output to <br> * <br> * HDIB hDIB        - handle to global memory with a DIB spec <br> *                    in it followed by the DIB bits <br> * <br> * LPRECT lpDIBRect - rectangle of DIB to output into lpDCRect <br> * <br> * Return Value: <br> * <br> * BOOL             - TRUE if DIB was drawn, FALSE otherwise <br> * <br> * Description: <br> *   Painting routine for a DIB.  Calls StretchDIBits() or <br> *   SetDIBitsToDevice() to paint the DIB.  The DIB is <br> *   output to the specified DC, at the coordinates given <br> *   in lpDCRect.  The area of the DIB to be output is <br> *   given by lpDIBRect. <br> * <br> * NOTE: This function always selects the palette as background. Before <br> * calling this function, be sure your palette is selected to desired <br> * priority (foreground or background). <br> * <br> * <br> ************************************************************************/ <br> <br>BOOL PaintDIB(HDC hDC, LPRECT lpDCRect, HDIB hDIB, LPRECT lpDIBRect, <br>        HPALETTE hPal) <br>{ <br>    LPSTR        lpDIBHdr;           // Pointer to BITMAPINFOHEADER <br>    LPSTR        lpDIBBits;          // Pointer to DIB bits <br>    BOOL         bSuccess=FALSE;     // Success/fail flag <br>    HPALETTE     hOldPal=NULL;       // Previous palette <br> <br>    // Check for valid DIB handle <br> <br>    if (!hDIB) <br>        return FALSE; <br> <br>    // Lock down the DIB, and get a pointer to the beginning of the bit <br>    // buffer <br>     <br>    lpDIBHdr  = GlobalLock(hDIB); <br>    lpDIBBits = FindDIBBits(lpDIBHdr); <br> <br>    // Select and realize our palette as background <br> <br>    if (hPal) <br>    { <br>        hOldPal = SelectPalette(hDC, hPal, TRUE); <br>        RealizePalette(hDC); <br>    } <br> <br>    // Make sure to use the stretching mode best for color pictures <br> <br>    SetStretchBltMode(hDC, COLORONCOLOR); <br> <br>    // Determine whether to call StretchDIBits() or SetDIBitsToDevice() <br> <br>    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) &amp;&amp; <br>            (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect))) <br>    { <br>        bSuccess = SetDIBitsToDevice(hDC, lpDCRect-&gt;left, lpDCRect-&gt;top, <br>                RECTWIDTH(lpDCRect), RECTHEIGHT(lpDCRect), lpDIBRect-&gt;left, <br>                (int)DIBHeight(lpDIBHdr) - lpDIBRect-&gt;top - <br>                RECTHEIGHT(lpDIBRect), 0, DIBHeight(lpDIBHdr), lpDIBBits, <br>                (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS); <br>    } <br>    else  <br>        bSuccess = StretchDIBits(hDC, lpDCRect-&gt;left, lpDCRect-&gt;top, <br>                RECTWIDTH(lpDCRect), RECTHEIGHT(lpDCRect), lpDIBRect-&gt;left, <br>                lpDIBRect-&gt;top, RECTWIDTH(lpDIBRect), RECTHEIGHT(lpDIBRect), <br>                lpDIBBits, (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS, SRCCOPY); <br> <br>    // Unlock the memory block <br> <br>    GlobalUnlock(hDIB); <br> <br>    // Reselect old palette <br> <br>    if (hOldPal) <br>     SelectPalette(hDC, hOldPal, FALSE); <br> <br>    // Return with success/fail flag <br>    return bSuccess; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * PaintBitmap() <br> * <br> * Parameters: <br> * <br> * HDC hDC          - DC to do output to <br> * <br> * LPRECT lpDCRect  - rectangle on DC to do output to <br> * <br> * HBITMAP hDDB     - handle to device-dependent bitmap (DDB) <br> * <br> * LPRECT lpDDBRect - rectangle of DDB to output into lpDCRect <br> * <br> * HPALETTE hPalette - handle to the palette to use with hDDB <br> * <br> * Return Value: <br> * <br> * BOOL             - TRUE if bitmap was drawn, FLASE otherwise <br> * <br> * Description: <br> * <br> * Painting routine for a DDB.  Calls BitBlt() or <br> * StretchBlt() to paint the DDB.  The DDB is <br> * output to the specified DC, at the coordinates given <br> * in lpDCRect.  The area of the DDB to be output is <br> * given by lpDDBRect.  The specified palette is used. <br> * <br> * NOTE: This function always selects the palette as background. Before <br> * calling this function, be sure your palette is selected to desired <br> * priority (foreground or background). <br> * <br> ************************************************************************/ <br> <br>BOOL PaintBitmap(HDC hDC, LPRECT lpDCRect, HBITMAP hDDB,  LPRECT lpDDBRect,  <br>        HPALETTE hPal) <br>{ <br>    HDC         hMemDC;            // Handle to memory DC <br>    HBITMAP     hOldBitmap;        // Handle to previous bitmap <br>    HPALETTE    hOldPal1 = NULL;   // Handle to previous palette <br>    HPALETTE    hOldPal2 = NULL;   // Handle to previous palette <br>    BOOL        bSuccess = FALSE;  // Success/fail flag <br> <br>    // Create a memory DC <br> <br>    hMemDC = CreateCompatibleDC (hDC); <br> <br>    // If this failed, return FALSE <br> <br>    if (!hMemDC) <br>        return FALSE; <br> <br>    // If we have a palette, select and realize it <br> <br>    if (hPal) <br>    { <br>        hOldPal1 = SelectPalette(hMemDC, hPal, TRUE); <br>        hOldPal2 = SelectPalette(hDC, hPal, TRUE); <br>        RealizePalette(hDC); <br>    } <br> <br>    // Select bitmap into the memory DC <br> <br>    hOldBitmap = SelectObject (hMemDC, hDDB); <br> <br>    // Make sure to use the stretching mode best for color pictures <br> <br>    SetStretchBltMode (hDC, COLORONCOLOR); <br> <br>    // Determine whether to call StretchBlt() or BitBlt() <br>    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDDBRect)) &amp;&amp; <br>            (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDDBRect))) <br>        bSuccess = BitBlt(hDC, lpDCRect-&gt;left, lpDCRect-&gt;top, <br>                lpDCRect-&gt;right - lpDCRect-&gt;left, <br>                lpDCRect-&gt;bottom - lpDCRect-&gt;top, hMemDC, lpDDBRect-&gt;left, <br>                lpDDBRect-&gt;top, SRCCOPY); <br>    else <br>        bSuccess = StretchBlt(hDC, lpDCRect-&gt;left,  lpDCRect-&gt;top,  <br>                lpDCRect-&gt;right - lpDCRect-&gt;left, <br>                lpDCRect-&gt;bottom - lpDCRect-&gt;top, hMemDC, lpDDBRect-&gt;left,  <br>                lpDDBRect-&gt;top,  lpDDBRect-&gt;right - lpDDBRect-&gt;left, <br>                lpDDBRect-&gt;bottom - lpDDBRect-&gt;top, SRCCOPY); <br> <br>    // Clean up <br> <br>    SelectObject(hMemDC, hOldBitmap); <br> <br>    if (hOldPal1) <br>        SelectPalette (hMemDC, hOldPal1, FALSE); <br> <br>    if (hOldPal2) <br>        SelectPalette (hDC, hOldPal2, FALSE); <br> <br>    DeleteDC (hMemDC); <br> <br>    // Return with success/fail flag <br> <br>    return bSuccess; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
