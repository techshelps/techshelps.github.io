<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINCAP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3481"></a>WINCAP.C</h2>
<pre><code>//*********************************************************************** <br>// <br>// Wincap.c <br>// <br>// Windows Screen Capture Utility <br>// Version 3.20 <br>// <br>// Description: <br>// ------------ <br>// <br>// Captures portions of the screen, specific windows, or the entire screen <br>// and saves it to a file or prints it.  Uses DIBAPI functions to do most <br>// of the capture/printing/saving work.  See the file DIBAPI.TXT for a <br>// description of the DIB api functions. <br>// <br>// Changes from first version: <br>// <br>// - Updated to use 3.1 Common Dialogs and 3.1 hook functions <br>// - New user interface displays window which was captured in client <br>//      area of Wincap, complete with scroll bars <br>// - Hot new hotkeys allow more versatile capturing of windows (e.g. you <br>//      can now capture windows with menu items pulled down) <br>// - New APIs to draw bitmaps and DIBs on the screen <br>// - Nifty startup bitmap <br>// - All DIB API functions are now in a DLL, which can be used <br>//      by any application <br>// <br>// Changes from version 3.1 to 3.2: <br>// - Window selection changed due to how SetCapture works under Win32 <br>// - The window to be selected for capture is highlighted as the cursor is moved <br>// - Option to copy DIB, DDB, and Palette to the clipboard <br>// <br>// Written by Microsoft Product Support Services, Developer Support. <br>// Copyright 1991-1998 Microsoft Corporation. All rights reserved. <br>//*********************************************************************** <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "commdlg.h" <br>#include "wincap.h" <br>#include "resource.h" <br>#include "dialogs.h" <br>#include "dibapi.h" <br> <br>char szAppName[20];     // Name of application - used in dialog boxes <br> <br>// Global variables <br> <br>HINSTANCE   ghInst;             // Handle to instance <br>HWND        ghWndMain;          // Handle to main window <br> <br>HOOKPROC    lpfnKeyHook;        // Used in keyboard hook <br>HOOKPROC    lpfnOldHook;        // Used for keyboard hook <br>HWND        hModelessDlg;       // Handle to modeless "Saving to file..." <br>                                // dialog box <br> <br>BOOL        bStartup=TRUE;      // Startup flag for WM_PAINT/logo <br>BOOL        bViewFull=FALSE;    // Full view flag <br>HBITMAP     ghbmLogo;           // Handle to logo bitmap <br>HBITMAP     ghBitmap=NULL;      // Handle to captured bitmap <br>HPALETTE    ghPal=NULL;         // Handle to our bitmap's palette <br>char        gszWindowText[100]; // Text which tells what we captured <br> <br>BOOL        gbLButtonDown=FALSE; <br>BOOL        gbSave = FALSE; <br>HWND        ghWndCapture=NULL; <br>BOOL        gbNowCapturing = FALSE; <br>BOOL        gbCaptRect = FALSE; <br>HWND        hSelectDlg;         // help dialog for window selection <br>HWND        hRectangleDlg;      // help dialog for rectangle selection <br>UINT        guiFileOKMsg;       // for common dialog FILEOKSTRING <br> <br>#define WM_DOCAPTURE WM_USER+101 // Used for screen capture messages <br> <br>// Macro to swap two values <br> <br>#define SWAP(x,y)   ((x)^=(y)^=(x)^=(y)) <br>#define SCROLL_RATIO    4 <br> <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent); <br> <br>//************************************************************************ <br>// <br>// WinMain() <br>// <br>// Entry point of the Application. <br>// <br>//************************************************************************ <br> <br>int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, <br>        int nCmdShow) <br>{ <br>    MSG msg; <br>    WNDCLASS wndclass; <br>    HWND hWnd; <br>CHAR lpBuffer[256]; <br> <br>    strcpy(szAppName, "WinCap");     // Name of our App <br>    hModelessDlg = NULL;             // Set handle to modeless dialog to NULL <br>                                     // because we haven't created it yet <br> <br>    hSelectDlg = hRectangleDlg = NULL; <br> <br>LoadString(ghInst, IDS_MAINWINDOWTITLE, lpBuffer, sizeof(lpBuffer)); <br>    if (!FindWindow(szAppName, lpBuffer)) <br>    { <br>        wndclass.style = 0; <br>        wndclass.lpfnWndProc = (WNDPROC)WndProc; <br>        wndclass.cbClsExtra = 0; <br>        wndclass.cbWndExtra = 0; <br>        wndclass.hInstance = hInstance; <br>        wndclass.hIcon = LoadIcon(hInstance, "WINCAP"); <br>        wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); <br> <br>        // Use black for background for better contrast <br> <br>        wndclass.hbrBackground = GetStockObject(GRAY_BRUSH); <br> <br>        wndclass.lpszMenuName = (LPSTR)"MAINMENU"; <br>        wndclass.lpszClassName = (LPSTR)szAppName; <br> <br>        if (!RegisterClass(&amp;wndclass)) <br>            return FALSE; <br> <br>        ghInst = hInstance;  // Set Global variable <br> <br>        // Create a main window for this application instance. <br> <br>        hWnd = CreateWindow(szAppName, lpBuffer, WS_OVERLAPPEDWINDOW, <br>                CW_USEDEFAULT, CW_USEDEFAULT, 450, 345, NULL, NULL, hInstance,            // This instance owns this window <br>                NULL); <br> <br>        ghWndMain = hWnd;      // Set global variable <br> <br>        ShowWindow(hWnd, nCmdShow); <br>        UpdateWindow(hWnd); <br> <br>        // Set up the Keyboard hook for our hotkeys <br> <br>        InstallHook(hWnd, TRUE);  // Function resides in DIBAPI32.DLL <br> <br>        // Create our full-screen view class <br> <br>        wndclass.style = 0; <br>        wndclass.lpfnWndProc = (WNDPROC)FullViewWndProc; <br>        wndclass.cbClsExtra = 0; <br>        wndclass.cbWndExtra = 0; <br>        wndclass.hInstance = hInstance; <br>        wndclass.hIcon = NULL; <br>        wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wndclass.hbrBackground = GetStockObject(GRAY_BRUSH); <br>        wndclass.lpszMenuName = (LPSTR)NULL; <br>        wndclass.lpszClassName = (LPSTR)"ViewClass"; <br> <br>        if (!RegisterClass(&amp;wndclass)) <br>            return FALSE; <br> <br>    } <br> <br>    // Let's make this a single-instance app -- we can get into hotkey <br>    // conflicts (e.g. windows won't know which instance of WINCAP to  <br>    // send the message to).   <br>     <br>    else <br>    { <br>        LoadString(ghInst, IDS_WINCAPRUNNING, lpBuffer, sizeof(lpBuffer)); <br>MessageBeep(0); <br>        MessageBox(NULL, lpBuffer, szAppName, MB_OK | MB_ICONHAND); <br>        return FALSE; <br>    } <br> <br>    // Polling messages from event queue -- we have a modeless dialog <br>    // box, so we have to take care of the messages here also <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>        if (hModelessDlg == NULL || !IsDialogMessage(hModelessDlg, &amp;msg) || <br>                hSelectDlg || !IsDialogMessage(hSelectDlg, &amp;msg) || <br>                hRectangleDlg || !IsDialogMessage(hRectangleDlg, &amp;msg)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br>    return msg.wParam; <br>} <br> <br> <br> <br>//********************************************************************** <br>// <br>// WndProc() <br>// <br>// This is our main window procedure.  It receives all the messages destined <br>// for our application's main window. <br>// <br>// When we capture a window, we capture it into a Device-Dependent bitmap, <br>// and at the same time, we get a copy of the current system palette.  This <br>// makes displaying the bitmap on the screen very fast.  And when we want <br>// to print or save the captured window, we need to use this palette to <br>// convert the DDB to a DIB. <br>// <br>//********************************************************************* <br> <br>long WINAPI WndProc(HWND hWnd, UINT wMessage, WPARAM wParam, LPARAM lParam) <br>{ <br>     <br>    // The gbNowCapturing variable is set to TRUE if we are in the middle of <br>    // printing.  This takes care of the case when the user presses the hotkey <br>    // during capturing <br>     <br>    static BOOL     bCapturedYet = FALSE;  // TRUE if window contains captured screen <br>    HWND            hViewWnd;              // Handle to our view window <br>    static WORD     wCaptureCommand; <br>    static HCURSOR  hOldCursor; <br>    static HWND     hBrowseWnd; <br>    CHAR            lpBuffer[128]; <br>    CHAR            lpBuffer2[128]; <br> <br> <br>    switch (wMessage) <br>    { <br> <br>        case WM_CREATE: <br>            if (!hSelectDlg) <br>                hSelectDlg = CreateDialog(ghInst, "Select", hWnd, <br>                        SelectDlgProc); <br> <br>            if (!hRectangleDlg) <br>                hRectangleDlg = CreateDialog(ghInst, "Rectangle", hWnd, <br>                        RectangleDlgProc); <br> <br> <br>            ghbmLogo = LoadBitmap(ghInst, "STARTBMP"); <br>            guiFileOKMsg = RegisterWindowMessage( (LPCSTR)FILEOKSTRING ); <br>            break; <br> <br>        // Gray out menu items if we haven't captured anything yet. <br> <br>        case WM_INITMENU: <br>            EnableMenuItem(GetMenu(hWnd), IDM_SAVE, MF_BYCOMMAND | <br>                    (bCapturedYet ? MF_ENABLED : MF_DISABLED | MF_GRAYED)); <br>            EnableMenuItem(GetMenu(hWnd), IDM_PRINT, MF_BYCOMMAND | <br>                    (bCapturedYet ? MF_ENABLED : MF_DISABLED | MF_GRAYED)); <br>            EnableMenuItem(GetMenu(hWnd), IDM_EDITCOPY, MF_BYCOMMAND | <br>                    (bCapturedYet ? MF_ENABLED : MF_DISABLED | MF_GRAYED)); <br>            return 0; <br> <br> <br>        // The WM_PALETTECHANGED message informs all windows that the window <br>        // with input focus has realized its logical palette, thereby changing  <br>        // the system palette. This message allows a window without input focus <br>        // that uses a color palette to realize its logical palettes and update <br>        // its client area. <br>        // <br>        // This message is sent to all windows, including the one that changed <br>        // the system palette and caused this message to be sent. The wParam of <br>        // this message contains the handle of the window that caused the system <br>        // palette to change. To avoid an infinite loop, care must be taken to <br>        // check that the wParam of this message does not match the window's <br>        // handle. <br> <br>        case WM_PALETTECHANGED: <br>        { <br>            HDC         hDC;      // Handle to device context <br>            HPALETTE    hOldPal;  // Handle to previous logical palette <br> <br>            // Before processing this message, make sure we <br>            // are indeed using a palette <br> <br>            if (ghPal) <br>            { <br>                // If this application did not change the palette, select <br>                // and realize this application's palette <br> <br>                if (wParam != (WPARAM)hWnd) <br>                { <br>                    // Need the window's DC for SelectPalette/RealizePalette <br> <br>                    hDC = GetDC(hWnd); <br> <br>                    // Select and realize our palette <br> <br>                    hOldPal = SelectPalette(hDC, ghPal, FALSE); <br>                    RealizePalette(hDC); <br> <br>                    // WHen updating the colors for an inactive window, <br>                    // UpdateColors can be called because it is faster than <br>                    // redrawing the client area (even though the results are <br>                    // not as good) <br> <br>                    UpdateColors(hDC); <br> <br>                    // Clean up <br> <br>                    if (hOldPal) <br>                       SelectPalette(hDC, hOldPal, FALSE); <br> <br>                    ReleaseDC(hWnd, hDC); <br>                } <br>            } <br>            break; <br>        } <br> <br> <br>        // The WM_QUERYNEWPALETTE message informs a window that it is about to <br>        // receive input focus. In response, the window receiving focus should <br>        // realize its palette as a foreground palette and update its client <br>        // area. If the window realizes its palette, it should return TRUE; <br>        // otherwise, it should return FALSE. <br> <br>        case WM_QUERYNEWPALETTE: <br>        { <br>            HDC         hDC;      // Handle to device context <br>            HPALETTE    hOldPal;  // Handle to previous logical palette <br> <br>            // Before processing this message, make sure we <br>            // are indeed using a palette <br> <br>            if (ghPal) <br>            { <br>                 // Need the window's DC for SelectPalette/RealizePalette <br> <br>                 hDC = GetDC(hWnd); <br> <br>                 // Select and realize our palette <br> <br>                 hOldPal = SelectPalette(hDC, ghPal, FALSE); <br>                 RealizePalette(hDC); <br> <br>                 // Redraw the entire client area <br> <br>                 InvalidateRect(hWnd, NULL, TRUE); <br>                 UpdateWindow(hWnd); <br> <br>                 // Clean up <br> <br>                 if (hOldPal) <br>                    SelectPalette(hDC, hOldPal, FALSE); <br> <br>                 ReleaseDC(hWnd, hDC); <br> <br>                 // Message processed, return TRUE <br> <br>                 return TRUE; <br>             } <br> <br>            // Message not processed, return FALSE <br> <br>            return FALSE; <br>        } <br> <br> <br> <br>        case WM_MOVE: <br>        { <br>            if (gbNowCapturing) <br>            { <br>                if (gbCaptRect) <br>                    CenterWindow(hRectangleDlg, hWnd); <br>                else <br>                    CenterWindow(hSelectDlg, hWnd); <br>            } <br> <br>            return 0; <br>        } <br> <br>        case WM_SIZE: <br>        { <br>            static BOOL     bSizing=FALSE; <br> <br>            if (gbNowCapturing) <br>            { <br>                if (gbCaptRect) <br>                    CenterWindow(hRectangleDlg, hWnd); <br>                else <br>                    CenterWindow(hSelectDlg, hWnd); <br>            } <br> <br>            // Check if we are already sizing <br> <br>            if (bSizing) <br>                return 0l; <br> <br>            bSizing = TRUE; <br>            DoSize(hWnd); <br>            bSizing = FALSE; <br>            break; <br>        } <br> <br>        case WM_HSCROLL: <br>        case WM_VSCROLL: <br>            DoScroll(hWnd, wMessage, (int)HIWORD(wParam), (int)LOWORD(wParam)); <br>            break; <br> <br>        case WM_PAINT: <br>            DoPaint(hWnd); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>            { <br>                case IDM_ABOUT: <br>                    DialogBox(ghInst, (LPSTR)"About", hWnd, AboutDlgProc); <br>                    break; <br> <br>                case IDM_SAVE: <br>                    SaveMe(); <br>                    break; <br> <br>                case IDM_PRINT: <br>                    PrintMe(); <br>                    break; <br> <br>                case IDM_VIEWFULL: <br>                    if (!bViewFull &amp;&amp; (ghBitmap || bStartup)) <br>                    { <br>                        HDC     hDC; <br>                        int ScreenX, ScreenY; <br> <br>                        hDC = CreateDC("DISPLAY", NULL, NULL, NULL); <br> <br>                        ScreenX = GetDeviceCaps(hDC, HORZRES); <br> <br>                        ScreenY = GetDeviceCaps(hDC, VERTRES); <br>                        DeleteDC(hDC); <br> <br>                        hViewWnd = CreateWindow((LPSTR)"ViewClass", (LPSTR)NULL, <br>                                WS_POPUP | WS_VISIBLE, 0, 0, ScreenX, ScreenY, <br>                                hWnd, NULL, ghInst, NULL); <br> <br>                        ShowWindow(hViewWnd, SW_SHOW); <br>                        UpdateWindow(hViewWnd); <br>                    } <br>                    else {    <br>                        LoadString(ghInst, IDS_NOIMAGE, lpBuffer, sizeof(lpBuffer)); <br>                        LoadString(ghInst, IDS_VWFULLSCRN, lpBuffer2, sizeof(lpBuffer2)); <br>                        MessageBox(hWnd, lpBuffer, lpBuffer2, MB_OK); <br>                    } <br>                    break; <br>             <br>                case IDM_EDITCOPY: // Copy DIB, bitmap, &amp; palette to clipboard         <br>                    if (OpenClipboard(hWnd)) <br>                    { <br>                        HDIB        hDib; <br>                        HBITMAP     hBitmap; <br>                        HPALETTE    hPal; <br> <br>                        EmptyClipboard(); <br> <br>                        if (ghBitmap) <br>                        { <br>                            // Once these are added to the clipboard, the <br>                            // clipboard owns the data. <br> <br>                            if (hDib = BitmapToDIB(ghBitmap, ghPal)) <br>                                SetClipboardData(CF_DIB, hDib); <br> <br>                            // Make a copy of the bitmap so the clipboard can <br>                            // own it. <br> <br>                            if (hBitmap = DIBToBitmap(hDib, ghPal)) <br>                                SetClipboardData(CF_BITMAP, hBitmap); <br> <br>                            // Make a copy of the palette so the clipboard can <br>                            // own it. <br> <br>                            if (hPal = GetStockObject(DEFAULT_PALETTE)) <br>                                SetClipboardData(CF_PALETTE, hPal); <br>                        } <br> <br>                        CloseClipboard(); <br>                    } <br>                    break; <br> <br>                case IDM_VIEWCLEAR: <br>                { <br>                    WORD        wRet; <br> <br>                    if (gbSave) <br>                    { <br>                        LoadString(ghInst, IDS_SAVEBMP, lpBuffer, sizeof(lpBuffer)); <br>                        wRet = MessageBox(hWnd, lpBuffer, <br>                                szAppName, MB_ICONEXCLAMATION | MB_YESNOCANCEL); <br> <br>                        if (wRet == IDYES) <br>                            SaveMe(); <br>                        else if( wRet == IDCANCEL) <br>                            break; <br>                    } <br> <br> <br>                    gbSave = FALSE; <br> <br>                    // If we are just displaying logo, don't <br>                    // display it anymore <br> <br>                    if (bStartup) <br>                        bStartup = FALSE; <br> <br>                    // Delete captured bitmap if we have one <br> <br>                    if (ghBitmap) <br>                    { <br>                        DeleteObject(ghBitmap); <br>                        ghBitmap = NULL; <br>                    } <br> <br>                    // Delete our captured bitmap's palette if we have one <br> <br>                    if (ghPal) <br>                    { <br>                        DeleteObject(ghPal); <br>                        ghPal = NULL; <br>                    } <br> <br>                    // Now update display to reflect fact that we <br>                    // nuked the captured bitmap or don't want to <br>                    // look at the cool logo <br> <br>                    InvalidateRect(hWnd, NULL, TRUE); <br>                    UpdateWindow(hWnd); <br> <br>                    bCapturedYet = FALSE;  // Gray out "File.Save" menu item <br>                    break; <br>                } <br>                 <br> <br>                case IDM_CAPTRECT: <br>                    gbCaptRect = TRUE; <br> <br>                case IDM_CAPTWINDOW:  // make sure lParam == IDM_CURSORSELECT <br>                case IDM_CAPTCLIENT:  // make sure lParam == IDM_CURSORSELECT <br>                    lParam = IDM_CURSORSELECT; <br> <br>                case IDM_ACTIVEWINDOW: <br>                case IDM_DESKTOP: <br> <br>          <br>                // User selected one of the window capture items <br> <br>                // Check to see that we aren't already in the middle of  <br>                // capturing.  This could happen if the user presses our hotkey <br>                // in the middle of one of our dialog boxes. <br> <br>                if (gbNowCapturing) <br>                { <br>                    LoadString(ghInst, IDS_CAPTEDALREADY, lpBuffer, sizeof(lpBuffer)); <br>                    MessageBox(NULL, lpBuffer, <br>                            szAppName, MB_OK | MB_ICONEXCLAMATION); <br>                } <br>                else <br>                { <br>                    // User wants to capture screen.  One problem we may <br>                    // run into here is that we might have a popup menu pulled <br>                    // down in our own application when we get to this point <br>                    // (because of the hotkey feature of this app). <br>                    // <br>                    // Normally, we'd just enter a message loop after calling <br>                    // ShowWindow(SW_HIDE) to take care of any menu messages <br>                    // which may have been posted as we hide our application's <br>                    // window, and *then* call our screen capture routine. <br>                    // But unfortunately, we can't do that here and be 100% safe. <br>                    // <br>                    // If we *have* been sent here on a hotkey, and a menu of <br>                    // our own app is currently down, then we are currently running <br>                    // inside of a PeekMessage() loop in the Windows Menu <br>                    // manager. We should *not* enter another PeekMessage loop, <br>                    // but should return from this message case right away. <br>                    // The Windows Menu manager code relies on checking messages <br>                    // in it's queue via it's own PeekMessage loop, and if we <br>                    // entered one, it would confuse the menu manager. <br>                    // <br>                    // So what we do instead is just post ourselves a private <br>                    // message, and when we get this message (see below), then <br>                    // do the screen capture. <br>                    // <br> <br>                    // Commence screen capture! <br> <br>                    gbNowCapturing = TRUE; <br> <br>                    if (wParam == IDM_DESKTOP) <br>                        ShowWindow(hWnd, SW_HIDE); <br> <br>                    // Allow this message case to return right away.  We'll <br>                    // capture screen down below. <br> <br>                    if (lParam != IDM_CURSORSELECT) <br>                        PostMessage(hWnd, WM_DOCAPTURE, wParam, 0L); <br>                    else if (gbCaptRect) <br>                    { <br>                        CenterWindow(hRectangleDlg, hWnd); <br>                        ShowWindow(hRectangleDlg, SW_SHOW); <br>                    } <br>                    else <br>                    { <br>                        CenterWindow(hSelectDlg, hWnd); <br>                        ShowWindow(hSelectDlg, SW_SHOW); <br>                    } <br> <br>                    wCaptureCommand = (WORD)wParam; <br>                } <br>                break; <br> <br>                case IDM_EXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br> <br>                default: <br>                    return DefWindowProc(hWnd, wMessage, wParam, lParam); <br>                    break; <br>            } //switch (LOWORD(wParam)) <br> <br>            break; // case WM_COMMAND: <br> <br> <br>        // Message case for doing screen capture.  This message is posted <br>        // to us from the IDM_CAPT* code above.  wParam should be equal to <br>        // the ID of the message which we got sent here for (it is used in <br>        // the call to DoCapture()). <br> <br>        case WM_DOCAPTURE: <br>        { <br>            // We're going to capture a new screen, get rid of <br>            // previous captured image <br> <br>            if (ghBitmap) <br>            { <br>                DeleteObject(ghBitmap); <br>                ghBitmap = NULL; <br>            } <br> <br>            if (ghPal) <br>            { <br>                DeleteObject(ghPal); <br>                ghPal = NULL; <br>            } <br> <br>            SetForegroundWindow(ghWndCapture); <br> <br>            // Save captured screen as bitmap <br> <br>            DoCapture(hWnd, (WORD)wParam); <br> <br>            SetForegroundWindow(hWnd); <br> <br>            // Un-hide Window <br> <br>            ShowWindow(hWnd, SW_SHOW); <br> <br>            if (IsIconic(hWnd)) <br>                PostMessage(hWnd, WM_SYSCOMMAND, SC_RESTORE,  0L); <br> <br>            if (!gbCaptRect) <br>                gbNowCapturing = FALSE; <br> <br>            bCapturedYet = TRUE; // Enable "File.Save" menu item <br>            gbSave = TRUE; <br>            break; <br>        } <br> <br>        case WM_LBUTTONDOWN: <br>        { <br> <br>            if (!gbNowCapturing) <br>                break; <br>             <br>            ShowWindow(hWnd, SW_HIDE);  // Hide main app's window <br>            if (gbCaptRect) <br>                ShowWindow(hRectangleDlg, SW_HIDE); <br>            else <br>                ShowWindow(hSelectDlg, SW_HIDE); <br>            if (gbCaptRect) <br>            { <br>                hOldCursor = SetCursor(LoadCursor(NULL, IDC_CROSS)); <br>                PostMessage(hWnd, WM_DOCAPTURE, wCaptureCommand, 0L); <br>            } <br>            else <br>                hOldCursor = SetCursor(LoadCursor(ghInst, "SELECT")); <br>            gbLButtonDown = TRUE; <br>            SetCapture(ghWndMain); <br>            break; <br>        } <br> <br> <br>        case WM_LBUTTONUP: <br>        { <br>            POINTS      pts; <br>            POINT       pt; <br> <br>            if (!(gbNowCapturing &amp;&amp; gbLButtonDown)) <br>                break; <br>             <br>            ReleaseCapture(); <br>            gbLButtonDown = FALSE; <br>            SetCursor(hOldCursor); <br> <br>            if (gbCaptRect) <br>            { <br>                gbCaptRect = FALSE; <br>                gbNowCapturing = FALSE; <br>                break; <br>            } <br> <br>            FrameWindow(hBrowseWnd); <br>            hBrowseWnd = NULL; <br> <br>            pts = MAKEPOINTS(lParam); <br>            pt.x = pts.x; <br>            pt.y = pts.y; <br> <br>            // Convert to screen coordinates <br>             <br>            ClientToScreen(ghWndMain, &amp;pt); <br>             <br>            // Get Window that we clicked on <br>             <br>            ghWndCapture = WindowFromPoint(pt); <br> <br>            // If it's not a valid window, just return NULL <br>             <br>            if (!ghWndCapture) <br>            { <br>               SetCursor(hOldCursor); <br>               gbLButtonDown = gbNowCapturing = FALSE; <br>               break; <br>            } <br> <br>            PostMessage(hWnd, WM_DOCAPTURE, wCaptureCommand, 0L); <br>            break; <br> <br>        } <br> <br>        case WM_MOUSEMOVE: <br>        { <br>            POINT       pt; <br>            HWND        hWndCurrent; <br> <br>            if (!(gbNowCapturing &amp;&amp; gbLButtonDown)) <br>                break; <br> <br>            if (gbCaptRect) <br>                break; <br> <br>            // get the current mouse position <br> <br>            GetCursorPos(&amp;pt); <br>             <br>            // Get Window that we clicked on <br>              <br>            hWndCurrent = WindowFromPoint(pt); <br> <br>            // if the cursor is still moving in the current window, no need <br>            // to highlight it again <br> <br>            if (hWndCurrent != hBrowseWnd) <br>            { <br>                FrameWindow(hBrowseWnd);                 <br>                FrameWindow(hWndCurrent); <br>                hBrowseWnd = hWndCurrent; <br>                if (hWndCurrent) <br>                    UpdateWindow(hWndCurrent); <br>            } <br> <br>            break; <br>        } <br> <br>        case WM_CLOSE: <br>        { <br>            WORD        wRet; <br> <br>            if (gbSave) <br>            { <br>                LoadString(ghInst, IDS_SAVEBMP, lpBuffer, sizeof(lpBuffer)); <br>                wRet = MessageBox(hWnd, lpBuffer, <br>                        szAppName, MB_ICONEXCLAMATION | MB_YESNOCANCEL); <br> <br>                if (wRet == IDYES) <br>                    SaveMe(); <br>                else if( wRet == IDCANCEL) <br>                    break; <br>            } <br> <br>            if (IsWindow(hSelectDlg)) <br>                DestroyWindow(hSelectDlg); <br>            if (IsWindow(hRectangleDlg)) <br>                DestroyWindow(hRectangleDlg); <br> <br>            return DefWindowProc(hWnd, wMessage, wParam, lParam); <br>        } <br> <br>        case WM_DESTROY:  // Clean up <br>            InstallHook(hWnd, FALSE);  // Remove keyboard hook <br>            DeleteObject(ghbmLogo); <br> <br>            if (ghBitmap) <br>                DeleteObject(ghBitmap); <br>            if (ghPal) <br>                DeleteObject(ghPal); <br> <br> <br>            PostQuitMessage(0); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, wMessage, wParam, lParam); <br>    } <br>    return 0L; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// FullViewWndProc() <br>// <br>// This is our full-screen popup window procedure. It is used to display an <br>// image using the entire screen. Clicking the left mouse button restores <br>// to the main app window. <br>// <br>// <br>//********************************************************************* <br> <br> <br>long APIENTRY FullViewWndProc(HWND hWnd, UINT wMessage, WPARAM wParam, <br>        LPARAM  lParam) <br>{ <br>    switch (wMessage) <br>    { <br>        case WM_PAINT: <br>        { <br>            PAINTSTRUCT     ps; <br>            HDC             hMemDC; <br>            BITMAP          bm; <br>            HBITMAP         hOldBm; <br>            RECT            rect, rectClient; <br>            int             x, y; <br> <br>            BeginPaint(hWnd, &amp;ps); <br> <br>            // Check to see if we are displaying a bitmap <br> <br>            if (!ghBitmap) <br>            { <br> <br>                // No bitmap yet, are we in start mode? <br> <br>                if (bStartup) <br>                { <br>                    GetClientRect(hWnd, &amp;rectClient); <br> <br>                    hMemDC = CreateCompatibleDC(ps.hdc); <br> <br>                    // Select our logo bitmap <br> <br>                    hOldBm = SelectObject(hMemDC, ghbmLogo); <br>                    GetObject(ghbmLogo, sizeof(BITMAP), (VOID *)&amp;bm); <br> <br>                    x = (rectClient.right - bm.bmWidth) / 2; <br>                    y = (rectClient.bottom - bm.bmHeight) / 2; <br> <br>                    // Now bitblt our logo to client area <br>                    BitBlt(ps.hdc, x, y, bm.bmWidth, bm.bmHeight, <br>                          hMemDC, 0, 0, SRCCOPY); <br> <br>                    // Clean up <br>                    SelectObject(hMemDC,hOldBm); <br>                    DeleteDC(hMemDC); <br>                } <br>            } <br>            else <br>            { <br>                // Get info for captured bitmap <br> <br>                GetObject(ghBitmap, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>                // Fill in src/dest rectangle with width and height </code></pre>
<p>
</p>
<pre><code>// of captured bitmap <br>                 <br>                rect.left = 0; <br>                rect.top = 0; <br>                rect.right = bm.bmWidth; <br>                rect.bottom = bm.bmHeight; <br> <br>                // Paint the captured bitmap in the client area <br> <br>                PaintBitmap(ps.hdc, &amp;rect, ghBitmap, &amp;rect, ghPal); <br>            } <br> <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br>         } <br> <br>        case WM_KEYDOWN: <br>        case WM_LBUTTONDOWN: <br>            DestroyWindow(hWnd); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, wMessage, wParam, lParam); <br>    } <br>} <br> <br> <br>//********************************************************************** <br>// <br>// SaveMe() <br>// <br>// This procedure calls up the common dialog "File.Save" box, then  <br>// saves the current hBitmap as a DIB in the specified file, in the <br>// file format specified by the user in the dialog. <br>// <br>//********************************************************************* <br> <br>void SaveMe() <br>{ <br>    char    szFileBuf[255];     // Buffer to hold returned file name <br>    DWORD   dwFlags;            // used to pass in / get out file type <br>    HDC     hDC;                // HDC for getting info <br>    int     iBits;              // Bits per pixel of the display adapter <br>    DWORD   dCompression;       // Compression that the user specifies <br>    WORD    wBitCount;          // Bits per pixel that the user specifies <br>    WORD    wCompression;       // Compression <br>    HDIB    hDIB;               // A handle to our dib <br>    BOOL    bResult;            // Result of dialog box - TRUE if OK was pressed <br>    CHAR    lpBuffer[128];      // Buffer to hold string message retrieved from resources <br>    CHAR    lpBuffer2[128];     // Buffer to hold string message retrieved from resources <br> <br>    // Set up default compression to display in dialog box <br> <br>    wCompression = IDD_RGB; <br> <br>    // Depending on bits/pixel type for current display, <br>    // set the appropriate bit in the fFileOptions flag <br>    // <br>    // NOTE that we don't just assign wBitCount to iBits.  The reason <br>    // for this is some displays aren't 1,4,8 or 24 bits.  Some are <br>    // 15 bits, which isn't valid for a DIB, so in this case, we would <br>    // set the bits to 24.  <br> <br>    hDC = CreateDC("DISPLAY",NULL,NULL,NULL); <br>    iBits = GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES); <br>    DeleteDC(hDC); <br> <br>    if (iBits &lt;= 1) <br>        wBitCount = 1; <br> <br>    else if (iBits &lt;= 4) <br>        wBitCount = 4; <br> <br>    else if (iBits &lt;= 8) <br>        wBitCount = 8; <br> <br>    else if (iBits &lt;= 24) <br>        wBitCount = 24; <br> <br>    // Our dwFlags parameter to GetFileName is made up of the <br>    // bits per pixel in the HIWORD (1, 2, 4, or 24), and the compression <br>    // type in the LOWORD (IDD_RGB, IDD_RLE4, or IDD_RLE8). <br> <br>    dwFlags = MAKELONG(wCompression, wBitCount); <br> <br> <br>    // Bring up File/Save... dialog and get info. about filename, <br>    // compression, and bits/pix. of DIB to be written. <br> <br>    bResult = GetFileName(ghWndMain, (LPSTR)szFileBuf, &amp;dwFlags); <br> <br>    // Extract DIB specs and save to file (if the user did not  <br>    // press cancel) <br> <br>    if (bResult) <br>    { <br>        switch(LOWORD(dwFlags)) <br>        { <br>            case IDD_RLE4: <br>                dCompression = BI_RLE4; <br>                break; <br> <br>            case IDD_RLE8: <br>                dCompression = BI_RLE8; <br>                break; <br> <br>            case IDD_RGB: <br>            default: <br>                dCompression = BI_RGB; <br>                break; <br>        } <br> <br>        // First, call up a modeless dialog box which tells that we are <br>        // saving this to a file... <br> <br>        if (!hModelessDlg) <br>        { <br>            hModelessDlg = CreateDialogParam(ghInst, (LPSTR)"Saving", <br>                    ghWndMain,SavingDlgProc, (DWORD)(LPSTR)szFileBuf); <br>        } <br> <br>        // Now, write out the DIB in the proper format.  The following <br>        // API ChangeBitmapFormat() will convert the specified bitmap <br>        // to a DIB with the specified Bit Count, Compression and <br>        // Palette.  Remember that the HIWORD of dwFlags specifies the <br>        // bits per pixel. <br> <br>        hDIB = ChangeBitmapFormat(ghBitmap, HIWORD(dwFlags),  <br>                dCompression, ghPal); <br> <br>        if (hDIB) <br>        { <br>            if (SaveDIB(hDIB, szFileBuf)) <br>            { <br>                LoadString(ghInst, IDS_CANTSAVE, lpBuffer, sizeof(lpBuffer)); <br>                LoadString(ghInst, IDS_SAVEERROR, lpBuffer2, sizeof(lpBuffer2)); <br>                MessageBox(NULL, lpBuffer, lpBuffer2, MB_ICONEXCLAMATION); <br>                gbSave = TRUE; <br>            } <br>            else <br>                gbSave = FALSE; <br> <br>            DestroyDIB(hDIB); <br>        } <br> <br>        DestroyWindow(hModelessDlg); <br>        hModelessDlg = NULL; <br>    } <br> <br>} <br> <br>//********************************************************************* <br>// <br>// PrintMe() <br>// <br>// This procedure calls up the "File.Print" dialog, then prints the <br>// current hBitmap as a DIB on the default printer. <br>// <br>//********************************************************************* <br> <br>void PrintMe() <br>{ <br>    static OPTIONSTRUCT opts; <br>    int                 iReturn; <br>    HDIB                hDIB; <br>    WORD                wReturn; <br> <br>   <br>    // Display "Print Options" Box <br>    <br> <br>    iReturn = DialogBoxParam(ghInst, (LPSTR)"Print", ghWndMain, PrintDlgProc, <br>            (LONG)(LPSTR)&amp;opts); <br> <br>    if (iReturn) <br>    { <br>        // User pressed "OK" -- do the printing <br> <br>        hDIB = BitmapToDIB(ghBitmap, ghPal); <br> <br>        if (hDIB) <br>        { <br> <br>            // Print the dib using PrintDIB() API <br> <br>            if (opts.iOption == IDC_STRETCHTOPAGE) <br>                wReturn = PrintDIB(hDIB, PW_STRETCHTOPAGE, 0, 0, <br>                        (LPSTR)gszWindowText); <br> <br>            else if (opts.iOption == IDC_SCALE) <br>                wReturn = PrintDIB(hDIB, (WORD)PW_SCALE, (WORD)opts.iXScale, <br>                        (WORD)opts.iYScale, (LPSTR)gszWindowText); <br>            else <br>                wReturn = PrintDIB(hDIB, PW_BESTFIT, 0, 0, <br>                        (LPSTR)gszWindowText); <br> <br>            if (wReturn) <br>                DIBError(wReturn); <br> <br>            DestroyDIB(hDIB); <br>        } <br>    } <br>} <br> <br> <br> <br>//********************************************************************* <br>// <br>// DoCapture() <br>// <br>// This procedure gets called when the user wants to capture the <br>// screen.  The wCommand parameter tells us which capture operation <br>// we want to perform. <br>// <br>//********************************************************************* <br> <br> <br>void DoCapture(HWND hWnd, WORD wCommand) <br>{ <br>    HBITMAP     hBitmap;        // Handle to our temporary bitmap <br>    HPALETTE    hPal;           // Handle to our palette <br>    CHAR        lpBuffer[128];  // Buffer for string retrieved from resources <br> <br> <br>    switch (wCommand) <br>    { <br>        // Copy Entire screen to DIB <br> <br>        case IDM_DESKTOP: <br>        { <br>            RECT rScreen;       // Rect containing entire screen coordinates <br>            HDC hDC;            // DC to screen <br>            MSG msg;            // Message for the PeekMessage() <br>            CHAR lpBuffer[128]; // Buffer for string retrieved from resources <br> <br>            hDC = CreateDC("DISPLAY", NULL, NULL, NULL); <br>            rScreen.left = rScreen.top = 0; <br>            rScreen.right = GetDeviceCaps(hDC, HORZRES); <br>            rScreen.bottom = GetDeviceCaps(hDC, VERTRES); <br> <br>            // Delete our DC <br> <br>            DeleteDC(hDC); <br> <br>            LoadString(ghInst, IDS_ENTIRESCRN, lpBuffer, sizeof(lpBuffer)); <br>            strcpy(gszWindowText, lpBuffer); <br> <br>            // Wait until everybody repaints themselves <br> <br>            while (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE) != 0) <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br> <br> <br>            hBitmap = CopyScreenToBitmap(&amp;rScreen); <br> <br>            if (hBitmap) <br>                hPal = GetSystemPalette(); <br>            else <br>                hPal = NULL; <br>        } <br>        break; <br> <br> <br>        // copy user-selected portion of screen to DIB <br> <br>        case IDM_CAPTRECT: <br>        { <br>            RECT rRubberBand;       // Region to capture (screen coordinates) <br> <br>            // Allow user to "rubberband" a section of the screen for <br>            // us to capture <br> <br>            RubberBandScreen(&amp;rRubberBand); <br>            LoadString(ghInst, IDS_USERSELECT, lpBuffer, sizeof(lpBuffer)); <br>            strcpy(gszWindowText, lpBuffer); <br> <br>            hBitmap = CopyScreenToBitmap(&amp;rRubberBand); <br> <br>            if (hBitmap) <br>                hPal = GetSystemPalette(); <br>            else <br>                hPal = NULL; <br>        } <br>        break; <br> <br> <br> <br>        case IDM_CAPTWINDOW: <br>        case IDM_CAPTCLIENT: <br>        case IDM_ACTIVEWINDOW: <br>        { <br>            HWND    hWndSelect;       // The current active window <br>            HWND    hWndDesktop;      // Window to desktop <br>            MSG     msg;              // For our peekmessage loop <br> <br>            // Just capture the current active window, whatever it is <br> <br>            if (wCommand == IDM_ACTIVEWINDOW) <br>                hWndSelect = GetForegroundWindow(); <br> <br>            // Allow the user to click on a single window to capture <br> <br>            else     <br>                hWndSelect = ghWndCapture; <br> <br>            // If they try to capture the desktop window, then just <br>            // capture the entire screen. <br> <br>            hWndDesktop = GetDesktopWindow(); <br> <br>            if (hWndSelect == hWndDesktop) <br>            { <br>                RECT    rScreen;    // contains entire screen coordinates <br>                HDC     hDC;        // DC to screen <br>                MSG     msg;        // Message for the PeekMessage() <br> <br>                hDC = CreateDC("DISPLAY", NULL, NULL, NULL); <br>                rScreen.left = rScreen.top = 0; <br>                rScreen.right = GetDeviceCaps(hDC, HORZRES); <br>                rScreen.bottom = GetDeviceCaps(hDC, VERTRES); <br> <br>                /* Delete our DC */ <br>                DeleteDC(hDC); <br> <br>                LoadString(ghInst, IDS_ENTIRESCRN, lpBuffer, sizeof(lpBuffer)); <br>                strcpy(gszWindowText, lpBuffer); <br> <br>                // Wait until everybody repaints themselves <br> <br>                while (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE) != 0) <br>                { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br> <br>                ghBitmap = CopyScreenToBitmap(&amp;rScreen); <br> <br>                if (ghBitmap) <br>                    ghPal = GetSystemPalette(); <br>                else <br>                    ghPal = NULL; <br> <br>                ghWndCapture = NULL; <br>                return; <br>            } <br> <br>            // Check to see that the hWnd is not NULL <br> <br>            if (!hWndSelect) <br>            { <br>                LoadString(ghInst, IDS_CANTCAPWNDW, lpBuffer, sizeof(lpBuffer)); <br>                MessageBox(NULL, lpBuffer, szAppName, <br>                        MB_ICONEXCLAMATION | MB_OK); <br> <br>                hBitmap = NULL; <br>                hPal = NULL; <br>                break; <br>            } <br> <br>            // Make sure it's not a hidden window.  Hmm, capturing a hidden <br>            // window would certainly be a cool trick, wouldn't it? <br> <br>            if (!IsWindowVisible(hWndSelect)) <br>            { <br>                LoadString(ghInst, IDS_WNDWNOTVIS, lpBuffer, sizeof(lpBuffer)); <br>                MessageBox(NULL, lpBuffer, <br>                        szAppName, MB_ICONEXCLAMATION | MB_OK); <br> <br>                ghWndCapture = NULL; <br>                hBitmap = NULL; <br>                hPal = NULL; <br>                break; <br>            } <br> <br>            // Move window which was selected to top of Z-order for <br>            // the capture, and make it redraw itself <br> <br>            SetWindowPos(hWndSelect, NULL, 0, 0, 0, 0, <br>                    SWP_DRAWFRAME | SWP_NOSIZE | SWP_NOMOVE); <br> <br>            UpdateWindow(hWndSelect); <br> <br>            // Wait until everybody repaints themselves <br> <br>            while (PeekMessage(&amp;msg,NULL,0,0,PM_REMOVE) != 0) <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br> <br>            // Get the caption <br> <br>            GetWindowText(hWndSelect, gszWindowText, 100); <br> <br>            // Capture the screen -- if we selected CLIENT only capture, then <br>            // select that open when calling our API.  Otherwise, get the <br>            // entire window. <br> <br>            hBitmap = CopyWindowToBitmap(hWndSelect, <br>                    (WORD)((wCommand == IDM_CAPTCLIENT) ? (PW_CLIENT) : <br>                    (PW_WINDOW))); <br> <br>            if (hBitmap) <br>                hPal = GetSystemPalette(); <br>            else <br>                hPal = NULL; <br> <br>            break; <br>        } <br> <br>        //Oops, something went wrong <br> <br>        default: <br>            LoadString(ghInst, IDS_INTERROR, lpBuffer, sizeof(lpBuffer)); <br>            MessageBox(NULL, lpBuffer, szAppName, <br>                    MB_ICONHAND | MB_OK); <br>            break; <br>    } <br> <br>    if (hBitmap) <br>    { <br>        ghBitmap = hBitmap; <br>        hBitmap = NULL; <br>    } <br>    if (hPal) <br>    { <br>        ghPal = hPal; <br>        hPal = NULL; <br>    } <br> <br>    // Now, paint our bitmap in the client area <br> <br>    if (bStartup) <br>        bStartup = FALSE; <br> <br>    InvalidateRect(hWnd, NULL, FALSE); <br>    UpdateWindow(hWnd); <br>    ghWndCapture = NULL; <br>} <br> <br> <br> <br>//********************************************************************** <br>// <br>// RubberBandScreen() <br>// <br>// This function allows the user to rubber-band a portion of the screen. <br>// When the left button is released, the rect that the user selected <br>// (in screen coordinates) is returned in lpRect. <br>// <br>//********************************************************************* <br> <br>void RubberBandScreen(LPRECT lpRect) <br>{ <br>    POINT   pt;                 // Temporary POINT <br>    MSG     msg;                // Used in our PeekMessage() loop <br>    POINT   ptOrigin;           // Point where the user pressed left mouse button down <br>    RECT    rcClip;             // Current selection <br>    HDC     hScreenDC;          // DC to the screen (so we can draw on it) <br>    BOOL    bCapturing = FALSE; // TRUE if we are rubber-banding <br>    POINTS  pts; <br>    BOOL    bLButtonUp = FALSE; <br> <br>    hScreenDC = CreateDC("DISPLAY", NULL, NULL, NULL); <br> <br>    // Eat mouse messages until a WM_LBUTTONUP is encountered. Meanwhile <br>    // continue to draw a rubberbanding rectangle and display it's dimensions <br> <br>    for (;;) <br>    { <br>        WaitMessage(); <br>        if (PeekMessage(&amp;msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)) <br>        { <br>            // If the message is a WM_LBUTTONDOWN, begin drawing the <br>            // rubber-band box. <br>           <br>            if (msg.message == WM_RBUTTONDOWN) <br>            { <br>                // User pressed left button, initialize selection <br>                // Set origin to current mouse position (in window coords) <br> <br>                pts = MAKEPOINTS(msg.lParam); <br> <br>                ptOrigin.x = pts.x; <br>                ptOrigin.y = pts.y; <br> <br>                // Convert to screen coordinates <br>              <br>                ClientToScreen(ghWndMain, &amp;ptOrigin); <br> <br>             <br>                // rcClip is the current rectangle that the user <br>                // has selected.  Since user just pressed left button down, <br>                // initialize this rect very small <br>              <br>                rcClip.left = rcClip.right = ptOrigin.x; <br>                rcClip.top = rcClip.bottom = ptOrigin.y; <br>                NormalizeRect(&amp;rcClip);     // Make sure it is a normal rect <br>                DrawSelect(hScreenDC, TRUE, &amp;rcClip); // Draw the rubber-band box <br>                bCapturing = TRUE; <br>            } <br> <br>            else if (msg.message == WM_LBUTTONUP) <br>            { <br>                if (!bCapturing) <br>                    break; <br>                else <br>                { <br>                    bLButtonUp = TRUE; <br>                    PostMessage(ghWndMain, WM_RBUTTONUP, msg.wParam, msg.lParam); <br>                } <br>            } <br> <br>            // Any messages that make it into the next statement are mouse <br>            // messages, and we are capturing, so let's update the rubber-band <br>            // box <br>           <br>            if (bCapturing) <br>            { <br>                DrawSelect(hScreenDC, FALSE, &amp;rcClip);  // erase old rubber-band <br>                rcClip.left = ptOrigin.x;   // Update rect with new mouse info <br>                rcClip.top = ptOrigin.y; <br> <br>                pts = MAKEPOINTS(msg.lParam); <br> <br>                pt.x = pts.x; <br>                pt.y = pts.y; <br> <br>                // Convert to screen coordinates <br>                 <br>                ClientToScreen(ghWndMain, &amp;pt); <br>                rcClip.right = pt.x; <br>                rcClip.bottom = pt.y; <br>                NormalizeRect(&amp;rcClip); <br>                DrawSelect(hScreenDC, TRUE, &amp;rcClip); // new rubber-band <br>            } <br> <br>            // If the message is WM_LBUTTONUP, then we stop the selection <br>            // process. <br> <br>            if (msg.message == WM_RBUTTONUP) <br>            { <br>                DrawSelect(hScreenDC, FALSE, &amp;rcClip);    // erase rubber-band <br>                if (bLButtonUp) <br>                    PostMessage(ghWndMain, WM_LBUTTONUP, msg.wParam, msg.lParam); <br>                break; <br>            } <br>        } <br>        else <br>            continue; <br>    } <br>    DeleteDC(hScreenDC); <br> <br>    // Assign rect user selected to lpRect parameter <br>     <br>    if (!IsRectEmpty(&amp;rcClip)) <br>        CopyRect(lpRect, &amp;rcClip); <br> <br>    PostMessage(ghWndMain, WM_LBUTTONUP, msg.wParam, msg.lParam); <br>} <br> <br> <br>//*************************************************************************** <br>// <br>// DrawSelect <br>// <br>// Draws the selected clip rectangle with its dimensions on the DC <br>// <br>//*************************************************************************** <br> <br> <br>void DrawSelect(HDC hdc, BOOL fDraw, LPRECT lprClip) <br>{ <br>    char sz[80]; <br>    DWORD dw; <br>    int x, y, len, dx, dy; <br>    HDC hdcBits; <br>    HBITMAP hbm; <br>    RECT rcClip; <br>    SIZE sExtent; <br> <br>    rcClip = *lprClip; <br>    if (!IsRectEmpty(&amp;rcClip)) <br>    { <br> <br>        // If a rectangular clip region has been selected, draw it <br> <br>        PatBlt(hdc, rcClip.left, rcClip.top, rcClip.right - rcClip.left, 1, <br>                DSTINVERT); <br>        PatBlt(hdc, rcClip.left, rcClip.bottom, 1, -(rcClip.bottom-rcClip.top), <br>                DSTINVERT); <br>        PatBlt(hdc, rcClip.right - 1, rcClip.top, 1, rcClip.bottom - rcClip.top, <br>                DSTINVERT); <br>        PatBlt(hdc, rcClip.right, rcClip.bottom - 1, -(rcClip.right - <br>                rcClip.left), 1, DSTINVERT); <br> <br>        // Format the dimensions string ... <br> <br>        wsprintf(sz, "%dx%d", rcClip.right - rcClip.left, rcClip.bottom - <br>               rcClip.top); <br>        len = lstrlen(sz); <br> <br>        // ... and center it in the rectangle <br> <br>        dw = GetTextExtentPoint(hdc, sz, len, &amp;sExtent); <br>        dx = sExtent.cx; <br>        dy = sExtent.cy; <br>        x = (rcClip.right + rcClip.left - dx) / 2; <br>        y = (rcClip.bottom + rcClip.top - dy) / 2; <br>        hdcBits = CreateCompatibleDC(hdc); <br>        SetTextColor(hdcBits, 0xFFFFFFL); <br>        SetBkColor(hdcBits, 0x000000L); <br> <br>        // Output the text to the DC <br> <br>        if (hbm = CreateBitmap(dx, dy, 1, 1, NULL)) <br>        { <br>            hbm = SelectObject(hdcBits, hbm); <br>            ExtTextOut(hdcBits, 0, 0, 0, NULL, sz, len, NULL); <br>            BitBlt(hdc, x, y, dx, dy, hdcBits, 0, 0, SRCINVERT); <br>            hbm = SelectObject(hdcBits, hbm); <br>            DeleteObject(hbm); <br>        } <br>        DeleteDC(hdcBits); <br>    } <br>} <br> <br> <br>//************************************************************************* <br>// <br>//  FUNCTION   : NormalizeRect(RECT *prc) <br>// <br>//  PURPOSE    : If the rectangle coordinates are reversed, swaps them. <br>//               This is used to make sure that the first coordinate of <br>//               our rect is the upper left, and the second is lower right. <br>// <br>//************************************************************************* <br> <br>void WINAPI NormalizeRect(LPRECT prc) <br>{ <br>    if (prc-&gt;right  &lt; prc-&gt;left) SWAP(prc-&gt;right,  prc-&gt;left); <br>    if (prc-&gt;bottom &lt; prc-&gt;top)  SWAP(prc-&gt;bottom, prc-&gt;top); <br>} <br> <br> <br>//*************************************************************************** <br>// <br>// Function: DoSize <br>// <br>// Purpose:  Called by WndProc() on WM_SIZE <br>// <br>//           When the window is sized -- set up the scroll bars. <br>// <br>//           The window will be repainted if the new size, combined <br>//           with the current scroll bar positions would create blank <br>//           space at the left or bottom of the window. <br>// <br>//*************************************************************************** <br> <br>void DoSize(HWND hWnd) <br>{ <br>    BITMAP      bm;                     // Bitmap info structure <br>    int         cxBitmap=0, cyBitmap=0; // Bitmap width and height <br>    int         cxScroll, cyScroll;     // Scroll positions <br>    RECT        rect;                   // Client rectangle <br> <br>    // repaint if displaying bitmap <br> <br>    if (ghBitmap) <br>    { <br>        // Get info about bitmap <br> <br>        GetObject(ghBitmap, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>        // Get the width and height of the bitmap <br> <br>        cxBitmap = bm.bmWidth; <br>        cyBitmap = bm.bmHeight; <br> <br>        // Find out the dimensions of the window, and the current thumb <br>        // positions <br> <br>        GetClientRect(hWnd, &amp;rect); <br> <br>        cxScroll = GetScrollPos (hWnd, SB_HORZ); <br>        cyScroll = GetScrollPos (hWnd, SB_VERT); <br> <br>        // If current thumb positions would cause blank space <br>        // at right or bottom of client area, repaint <br> <br>        if (cxScroll + rect.right &gt; cxBitmap || <br>                cyScroll + rect.bottom &gt; cyBitmap) <br>            InvalidateRect(hWnd, NULL, FALSE); <br> <br>        // Make sure scroll bars are updated <br> <br>        SetupScrollBars(hWnd, (WORD)cxBitmap, (WORD)cyBitmap); <br>    } <br>    else if (bStartup) <br>        InvalidateRect(hWnd, NULL, TRUE); <br>} <br> <br> <br>//*************************************************************************** <br>// <br>// Function: ReallyGetClientRect <br>// <br>// Purpose:  Gets the rectangular area of the client rect including <br>//           the area underneath visible scroll bars.  Stolen from <br>//           ShowDIB. <br>// <br>//*************************************************************************** <br> <br>void ReallyGetClientRect(HWND hWnd, LPRECT lpRect) <br>{ <br>    DWORD   dwWinStyle; <br> <br>    dwWinStyle = GetWindowLong (hWnd, GWL_STYLE); <br> <br>    GetClientRect (hWnd, lpRect); <br> <br>    if (dwWinStyle &amp; WS_HSCROLL) <br>        lpRect-&gt;bottom += (GetSystemMetrics (SM_CYHSCROLL) - 1); <br> <br>    if (dwWinStyle &amp; WS_VSCROLL) <br>        lpRect-&gt;right  += (GetSystemMetrics (SM_CXVSCROLL) - 1); <br>} <br> <br> <br>//*************************************************************************** <br>// <br>// Function: SetupScrollBars <br>// <br>// Purpose:  Sets up scroll bars. <br>// <br>//*************************************************************************** <br> <br>void SetupScrollBars(HWND hWnd, WORD cxBitmap, WORD cyBitmap) <br>{ <br>    RECT        rect;                       // Client Rectangle <br>    BOOL        bNeedScrollBars=FALSE;      // Need Scroll bars? <br>    unsigned    cxWindow, cyWindow;         // Width and height of client area <br>    int         cxRange=0, cyRange=0;       // Range needed for horz and vert <br> <br>    // Do some initialization <br> <br>    ReallyGetClientRect(hWnd, &amp;rect); <br> <br>    cxWindow = rect.right - rect.left; <br>    cyWindow = rect.bottom - rect.top; <br> <br>    // Now determine if we need the scroll bars <br> <br>    if ((cxWindow &lt; (unsigned)cxBitmap) || (cyWindow &lt; (unsigned)cyBitmap)) <br>        bNeedScrollBars = TRUE; <br> <br> <br>    // Setup the scroll bar ranges.  We want to be able to <br>    // scroll the window so that all the bitmap can appear <br>    // within the client area.  Take into account that <br>    // if the opposite scroll bar is activated, it eats <br>    // up some client area. <br> <br>    if (bNeedScrollBars) <br>    { <br>        cyRange = (unsigned)cyBitmap - cyWindow - 1 + <br>                GetSystemMetrics (SM_CYHSCROLL); <br>        cxRange = (unsigned)cxBitmap - cxWindow - 1 + <br>                GetSystemMetrics (SM_CXVSCROLL); <br>    } <br> <br>    // Set the ranges we've calculated (0 to 0 means invisible scrollbar) <br> <br>    SetScrollRange(hWnd, SB_VERT, 0, cyRange, TRUE); <br>    SetScrollRange(hWnd, SB_HORZ, 0, cxRange, TRUE); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// Function:   DoScroll() <br>// <br>// Purpose:    Called by ChildWndProc() on WM_HSCROLL and WM_VSCROLL. <br>//             Window needs to be scrolled (user has clicked on one <br>//             of the scroll bars. <br>// <br>//             Does scrolling in both horiziontal and vertical directions. <br>//             Note that the variables are all named as if we were <br>//             doing a horizontal scroll.  However, if we're doing a <br>//             vertical scroll, they are initialized to the appropriate <br>//             values for a vertical scroll. <br>// <br>//             If we scroll by one (i.e. user clicks on one of the <br>//             scrolling arrows), we scroll the window by 1/SCROLL_RATIO <br>//             of the client area.  In other words, if SCROLL_RATION==4, <br>//             then we move the client area over a 1/4 of the width/height <br>//             of the screen. <br>// <br>//             If the user is paging up/down we move a full client area's <br>//             worth. <br>// <br>//             If the user moves the thumb to an absolute position, we <br>//             just move there. <br>// <br>//             ScrollWindow/re-painting do the actual work of scrolling. <br>// <br>//********************************************************************** <br> <br>void DoScroll(HWND hWnd, int message, int wPos, int wScrollType) <br>{ <br>    int  xBar;          // Where scrollbar is now. <br>    int  nMin;          // Minumum scroll bar value. <br>    int  nMax;          // Maximum scroll bar value. <br>    int  dx;            // How much to move. <br>    int  nOneUnit;      // # of pixels for LINEUP/LINEDOWN <br>    int  cxClient;      // Width of client area. <br>    int  nHorzOrVert;   // Doing the horizontal or vertical? <br>    RECT rect;          // Client area. <br> <br>    GetClientRect (hWnd, &amp;rect); <br> <br>    if (message == WM_HSCROLL) <br>    { <br>        nHorzOrVert = SB_HORZ; <br>        cxClient    = rect.right - rect.left; <br>    } <br>    else <br>    { <br>        nHorzOrVert = SB_VERT; <br>        cxClient    = rect.bottom - rect.top; <br>    } <br> <br>    // On a SB_LINEUP/SB_LINEDOWN we will move the DIB by <br>    //  1/SCROLL_RATIO of the client area (i.e. if SCROLL_RATIO <br>    //  is 4, it will scroll the DIB a quarter of the client <br>    //  area's height or width. <br> <br>    nOneUnit = cxClient / SCROLL_RATIO; <br>    if (!nOneUnit) <br>        nOneUnit = 1; <br> <br>    xBar = GetScrollPos (hWnd, nHorzOrVert); <br>    GetScrollRange (hWnd, nHorzOrVert, &amp;nMin, &amp;nMax); <br> <br>    switch (wScrollType) <br>    { <br>        case SB_LINEDOWN:             // One line right. <br>            dx = nOneUnit; <br>            break; <br> <br>        case SB_LINEUP:               // One line left. <br>            dx = -nOneUnit; <br>            break; <br> <br>        case SB_PAGEDOWN:             // One page right. <br>            dx = cxClient; <br>            break; <br> <br>        case SB_PAGEUP:               // One page left. <br>            dx = -cxClient; <br>            break; <br> <br>        case SB_THUMBPOSITION:        // Absolute position. <br>            dx = wPos - xBar; <br>            break; <br> <br>        default:                      // No change. <br>            dx = 0; <br>            break; <br>    } <br> <br>    if (dx) <br>    { <br>        xBar += dx; <br> <br>        if (xBar &lt; nMin) <br>        { <br>            dx  -= xBar - nMin; <br>            xBar = nMin; <br>        } <br> <br>        if (xBar &gt; nMax) <br>        { <br>            dx  -= xBar - nMax; <br>            xBar = nMax; <br>        } <br> <br>        if (dx) <br>        { <br>            SetScrollPos (hWnd, nHorzOrVert, xBar, TRUE); <br> <br>            if (nHorzOrVert == SB_HORZ) <br>                ScrollWindow (hWnd, -dx, 0, NULL, NULL); <br>            else <br>                ScrollWindow (hWnd, 0, -dx, NULL, NULL); <br> <br>            UpdateWindow (hWnd); <br>        } <br>    } <br>} <br> <br>//**************************************************************************** <br>// <br>// Function: DoPaint() <br>// <br>// Purpose:  Called by WndProc. Does painting for client area. <br>// <br>// <br>//*************************************************************************** <br> <br>void DoPaint(HWND hWnd) <br>{ <br>    HDC             hDC, hMemDC;         // Handle to DC, memory DC <br>    PAINTSTRUCT     ps;                  // Painting structure <br>    BITMAP          bm;                  // BITMAP structure <br>    HBITMAP         hOldBm;              // Handle to previous bitmap <br>    RECT            rectClient, rectDDB; // Client and bitmap rectangles <br>    int             xScroll, yScroll;    // Scroll positions <br>    int             x, y;                // Logo origin <br> <br> <br>    // Begin painting <br> <br>    hDC = BeginPaint(hWnd, &amp;ps); <br> <br>    // Check to see if we are displaying a bitmap <br>     <br>    if (!ghBitmap) <br>    { <br>        // No bitmap yet, are we in start mode? </code></pre>
<p>
</p>
<pre><code><br>        if (bStartup) <br>        { <br>            GetClientRect(hWnd, &amp;rectClient); <br> <br>            hMemDC = CreateCompatibleDC(ps.hdc); <br> <br>            // Select our logo bitmap <br> <br>            hOldBm = SelectObject(hMemDC, ghbmLogo); <br> <br>            GetObject(ghbmLogo, sizeof(BITMAP), (VOID *)&amp;bm); <br> <br>            x = (rectClient.right - bm.bmWidth) / 2; <br>            y = (rectClient.bottom - bm.bmHeight) / 2; <br> <br>            // Now bitblt our logo to client area <br> <br>            BitBlt(ps.hdc, x, y, bm.bmWidth, bm.bmHeight, hMemDC, 0, 0, <br>                    SRCCOPY); <br> <br>            // Clean up <br>            SelectObject(hMemDC,hOldBm); <br>            DeleteDC(hMemDC); <br>        } <br>        else <br>        { <br>            // Turn off scroll bars in case they were on <br> <br>                SetScrollRange (hWnd, SB_VERT, 0, 0, TRUE); <br>            SetScrollRange (hWnd, SB_HORZ, 0, 0, TRUE); <br>        } <br>    } <br>    else // We are displaying a bitmap <br>    { <br>        // Get bitmap info <br> <br>        GetObject(ghBitmap, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>        // Get scroll bar positions <br> <br>        xScroll  = GetScrollPos  (hWnd, SB_HORZ); <br>        yScroll  = GetScrollPos  (hWnd, SB_VERT); <br> <br>        // Set up the scroll bars appropriately. <br> <br>        SetupScrollBars(hWnd, (WORD)bm.bmWidth, (WORD)bm.bmHeight); <br> <br>        // Set up the necessary rectangles -- i.e. the rectangle <br>        //  we're rendering into, and the rectangle in the bitmap <br> <br>        GetClientRect (hWnd, &amp;rectClient); <br> <br>        rectDDB.left   = xScroll; <br>        rectDDB.top    = yScroll; <br>        rectDDB.right  = xScroll + rectClient.right - rectClient.left; <br>        rectDDB.bottom = yScroll + rectClient.bottom - rectClient.top; <br> <br>        if (rectDDB.right &gt; bm.bmWidth) <br>        { <br>            int dx; <br> <br>            dx = bm.bmWidth - rectDDB.right; <br> <br>            rectDDB.right     += dx; <br>            rectClient.right  += dx; <br>        } <br> <br>        if (rectDDB.bottom &gt; bm.bmHeight) <br>        { <br>            int dy; <br> <br>            dy = bm.bmHeight - rectDDB.bottom; <br> <br>            rectDDB.bottom    += dy; <br>            rectClient.bottom += dy; <br>        } <br> <br>        // Go do the actual painting. <br> <br>        PaintBitmap(hDC, &amp;rectClient, ghBitmap, &amp;rectDDB, ghPal); <br>    } <br> <br>    EndPaint(hWnd, &amp;ps); <br>} <br> <br> <br>//**************************************************************************** <br>// <br>// Function: FrameWindow() <br>// <br>// Purpose:  Highlight the window frame <br>// <br>// <br>//*************************************************************************** <br> <br>void FrameWindow(HWND hWnd) <br>{ <br>    HDC     hdc; <br>    RECT    rc; <br> <br>#define DINV    3 <br>     <br>    if (!IsWindow(hWnd)) <br>        return; <br> <br>    hdc = GetWindowDC(hWnd); <br>    GetWindowRect(hWnd, &amp;rc); <br>    OffsetRect(&amp;rc, -rc.left, -rc.top); <br> <br>    if (!IsRectEmpty(&amp;rc)) <br>    { <br>        PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, DINV, DSTINVERT); <br>        PatBlt(hdc, rc.left, rc.bottom-DINV, DINV, -(rc.bottom-rc.top-2*DINV), <br>                DSTINVERT); <br>        PatBlt(hdc, rc.right-DINV, rc.top+DINV, DINV, rc.bottom-rc.top-2*DINV, <br>                DSTINVERT); <br>        PatBlt(hdc, rc.right, rc.bottom-DINV, -(rc.right-rc.left), DINV, <br>                DSTINVERT); <br>    } <br> <br>    ReleaseDC(hWnd, hdc); <br>} <br> <br>//**************************************************************************** <br>// <br>// FUNCTION: CenterWindow (HWND, HWND) <br>// <br>// PURPOSE:  Center one window over another <br>// <br>// COMMENTS: <br>// <br>//      Dialog boxes take on the screen position that they were designed at, <br>//      which is not always appropriate. Centering the dialog over a particular <br>//      window usually results in a better position. <br>// <br>//*************************************************************************** <br> <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rChild, rParent; <br>    int     wChild, hChild, wParent, hParent; <br>    int     wScreen, hScreen, xNew, yNew; <br>    HDC     hdc; <br> <br>    // Get the Height and Width of the child window <br>    GetWindowRect (hwndChild, &amp;rChild); <br>    wChild = rChild.right - rChild.left; <br>    hChild = rChild.bottom - rChild.top; <br> <br>    // Get the Height and Width of the parent window <br>    GetWindowRect (hwndParent, &amp;rParent); <br>    wParent = rParent.right - rParent.left; <br>    hParent = rParent.bottom - rParent.top; <br> <br>    // Get the display limits <br>    hdc = GetDC (hwndChild); <br>    wScreen = GetDeviceCaps (hdc, HORZRES); <br>    hScreen = GetDeviceCaps (hdc, VERTRES); <br>    ReleaseDC (hwndChild, hdc); <br> <br>    // Calculate new X position, then adjust for screen <br>    xNew = rParent.left + ((wParent - wChild) /2); <br>    if (xNew &lt; 0) <br>        xNew = 0; <br>    else if ((xNew+wChild) &gt; wScreen) <br>        xNew = wScreen - wChild; <br> <br>    // Calculate new Y position, then adjust for screen <br>    yNew = rParent.top  + ((hParent - hChild) /2); <br>    if (yNew &lt; 0) <br>        yNew = 0; <br>    else if ((yNew+hChild) &gt; hScreen) <br>        yNew = hScreen - hChild; <br> <br>    // Set it, and return <br>    return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, <br>            SWP_NOSIZE | SWP_NOZORDER); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
