<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3476"></a>FILE.C</h2>
<pre><code>//******************************************************************* <br>// <br>//  file.c <br>// <br>//  Source file for Device-Independent Bitmap (DIB) API.  Provides <br>//  the following functions: <br>// <br>//  SaveDIB()           - Saves the specified dib in a file <br>//  LoadDIB()           - Loads a DIB from a file <br>//  DestroyDIB()        - Deletes DIB when finished using it <br>// <br>// Written by Microsoft Product Support Services, Developer Support. <br>// Copyright 1991-1998 Microsoft Corporation. All rights reserved. <br>//******************************************************************* <br> <br>#define     STRICT      // enable strict type checking <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;direct.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "dibutil.h" <br>#include "dibapi.h" <br> <br> <br>// Dib Header Marker - used in writing DIBs to files <br> <br>#define DIB_HEADER_MARKER   ((WORD) ('M' &lt;&lt; 8) | 'B') <br> <br> <br>/********************************************************************* <br> * <br> * Local Function Prototypes <br> * <br> *********************************************************************/ <br> <br> <br>HANDLE ReadDIBFile(HANDLE); <br>BOOL SaveDIBFile(void); <br>BOOL WriteDIB(LPSTR, HANDLE); <br> <br>/************************************************************************* <br> * <br> * LoadDIB() <br> * <br> * Loads the specified DIB from a file, allocates memory for it, <br> * and reads the disk file into the memory. <br> * <br> * <br> * Parameters: <br> * <br> * LPSTR lpFileName - specifies the file to load a DIB from <br> * <br> * Returns: A handle to a DIB, or NULL if unsuccessful. <br> * <br> * NOTE: The DIB API were not written to handle OS/2 DIBs; This <br> * function will reject any file that is not a Windows DIB. <br> * <br> *************************************************************************/ <br> <br>HDIB LoadDIB(LPSTR lpFileName) <br>{ <br>    HDIB        hDIB; <br>    HANDLE      hFile; <br> <br>    // Set the cursor to a hourglass, in case the loading operation <br>    // takes more than a sec, the user will know what's going on. <br> <br>    SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>    if ((hFile = CreateFile(lpFileName, GENERIC_READ, FILE_SHARE_READ, NULL, <br>            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, <br>            NULL)) != INVALID_HANDLE_VALUE) <br>    { <br>        hDIB = ReadDIBFile(hFile); <br>        CloseHandle(hFile); <br>        SetCursor(LoadCursor(NULL, IDC_ARROW)); <br>        return hDIB; <br>    } <br>    else <br>    { <br>        DIBError(ERR_FILENOTFOUND); <br>        SetCursor(LoadCursor(NULL, IDC_ARROW)); <br>        return NULL; <br>    } <br>} <br> <br> <br>/************************************************************************* <br> * <br> * SaveDIB() <br> * <br> * Saves the specified DIB into the specified file name on disk.  No <br> * error checking is done, so if the file already exists, it will be <br> * written over. <br> * <br> * Parameters: <br> * <br> * HDIB hDib - Handle to the dib to save <br> * <br> * LPSTR lpFileName - pointer to full pathname to save DIB under <br> * <br> * Return value: 0 if successful, or one of: <br> *        ERR_INVALIDHANDLE <br> *        ERR_OPEN <br> *        ERR_LOCK <br> * <br> *************************************************************************/ <br> <br>WORD SaveDIB(HDIB hDib, LPSTR lpFileName) <br>{ <br>    BITMAPFILEHEADER    bmfHdr;     // Header for Bitmap file <br>    LPBITMAPINFOHEADER  lpBI;       // Pointer to DIB info structure <br>    HANDLE              fh;         // file handle for opened file <br>    DWORD               dwDIBSize; <br>    DWORD               dwWritten; <br> <br>    if (!hDib) <br>        return ERR_INVALIDHANDLE; <br> <br>    fh = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, <br>            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); <br> <br>    if (fh == INVALID_HANDLE_VALUE) <br>        return ERR_OPEN; <br> <br>    // Get a pointer to the DIB memory, the first of which contains <br>    // a BITMAPINFO structure <br> <br>    lpBI = (LPBITMAPINFOHEADER)GlobalLock(hDib); <br>    if (!lpBI) <br>    { <br>        CloseHandle(fh); <br>        return ERR_LOCK; <br>    } <br> <br>    // Check to see if we're dealing with an OS/2 DIB.  If so, don't <br>    // save it because our functions aren't written to deal with these <br>    // DIBs. <br> <br>    if (lpBI-&gt;biSize != sizeof(BITMAPINFOHEADER)) <br>    { <br>        GlobalUnlock(hDib); <br>        CloseHandle(fh); <br>        return ERR_NOT_DIB; <br>    } <br> <br>    // Fill in the fields of the file header <br> <br>    // Fill in file type (first 2 bytes must be "BM" for a bitmap) <br> <br>    bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM" <br> <br>    // Calculating the size of the DIB is a bit tricky (if we want to <br>    // do it right).  The easiest way to do this is to call GlobalSize() <br>    // on our global handle, but since the size of our global memory may have <br>    // been padded a few bytes, we may end up writing out a few too <br>    // many bytes to the file (which may cause problems with some apps, <br>    // like HC 3.0). <br>    // <br>    // So, instead let's calculate the size manually. <br>    // <br>    // To do this, find size of header plus size of color table.  Since the <br>    // first DWORD in both BITMAPINFOHEADER and BITMAPCOREHEADER conains <br>    // the size of the structure, let's use this. <br> <br>    // Partial Calculation <br> <br>    dwDIBSize = *(LPDWORD)lpBI + PaletteSize((LPSTR)lpBI);   <br> <br>    // Now calculate the size of the image <br> <br>    // It's an RLE bitmap, we can't calculate size, so trust the biSizeImage <br>    // field <br> <br>    if ((lpBI-&gt;biCompression == BI_RLE8) || (lpBI-&gt;biCompression == BI_RLE4)) <br>        dwDIBSize += lpBI-&gt;biSizeImage; <br>    else <br>    { <br>        DWORD dwBmBitsSize;  // Size of Bitmap Bits only <br> <br>        // It's not RLE, so size is Width (DWORD aligned) * Height <br> <br>        dwBmBitsSize = WIDTHBYTES((lpBI-&gt;biWidth)*((DWORD)lpBI-&gt;biBitCount)) * <br>                lpBI-&gt;biHeight; <br> <br>        dwDIBSize += dwBmBitsSize; <br> <br>        // Now, since we have calculated the correct size, why don't we <br>        // fill in the biSizeImage field (this will fix any .BMP files which  <br>        // have this field incorrect). <br> <br>        lpBI-&gt;biSizeImage = dwBmBitsSize; <br>    } <br> <br> <br>    // Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER) <br>                    <br>    bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER); <br>    bmfHdr.bfReserved1 = 0; <br>    bmfHdr.bfReserved2 = 0; <br> <br>    // Now, calculate the offset the actual bitmap bits will be in <br>    // the file -- It's the Bitmap file header plus the DIB header, <br>    // plus the size of the color table. <br>     <br>    bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI-&gt;biSize + <br>            PaletteSize((LPSTR)lpBI); <br> <br>    // Write the file header <br> <br>    WriteFile(fh, (LPSTR)&amp;bmfHdr, sizeof(BITMAPFILEHEADER), &amp;dwWritten, NULL); <br> <br>    // Write the DIB header and the bits -- use local version of <br>    // MyWrite, so we can write more than 32767 bytes of data <br>     <br>    WriteFile(fh, (LPSTR)lpBI, dwDIBSize, &amp;dwWritten, NULL); <br> <br>    GlobalUnlock(hDib); <br>    CloseHandle(fh); <br> <br>    if (dwWritten == 0) <br>        return ERR_OPEN; // oops, something happened in the write <br>    else <br>        return 0; // Success code <br>} <br> <br> <br>/************************************************************************* <br> * <br> * DestroyDIB () <br> * <br> * Purpose:  Frees memory associated with a DIB <br> * <br> * Returns:  Nothing <br> * <br> *************************************************************************/ <br> <br>WORD DestroyDIB(HDIB hDib) <br>{ <br>    GlobalFree(hDib); <br>    return 0; <br>} <br> <br> <br>//************************************************************************ <br>// <br>// Auxiliary Functions which the above procedures use <br>// <br>//************************************************************************ <br> <br> <br>/************************************************************************* <br> * <br> * Function:  ReadDIBFile (int) <br> * <br> *  Purpose:  Reads in the specified DIB file into a global chunk of <br> *            memory. <br> * <br> *  Returns:  A handle to a dib (hDIB) if successful. <br> *            NULL if an error occurs. <br> * <br> * Comments:  BITMAPFILEHEADER is stripped off of the DIB.  Everything <br> *            from the end of the BITMAPFILEHEADER structure on is <br> *            returned in the global memory handle. <br> * <br> * <br> * NOTE: The DIB API were not written to handle OS/2 DIBs, so this <br> * function will reject any file that is not a Windows DIB. <br> * <br> *************************************************************************/ <br> <br>HANDLE ReadDIBFile(HANDLE hFile) <br>{ <br>    BITMAPFILEHEADER    bmfHeader; <br>    DWORD               dwBitsSize; <br>    UINT                nNumColors;   // Number of colors in table <br>    HANDLE              hDIB;         <br>    HANDLE              hDIBtmp;      // Used for GlobalRealloc() //MPB <br>    LPBITMAPINFOHEADER  lpbi; <br>    DWORD               offBits; <br>    DWORD               dwRead; <br> <br>    // get length of DIB in bytes for use when reading <br> <br>    dwBitsSize = GetFileSize(hFile, NULL); <br> <br>    // Allocate memory for header &amp; color table. We'll enlarge this <br>    // memory as needed. <br> <br>    hDIB = GlobalAlloc(GMEM_MOVEABLE, (DWORD)(sizeof(BITMAPINFOHEADER) + <br>            256 * sizeof(RGBQUAD))); <br> <br>    if (!hDIB) <br>        return NULL; <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>    if (!lpbi)  <br>    { <br>        GlobalFree(hDIB); <br>        return NULL; <br>    } <br> <br>    // read the BITMAPFILEHEADER from our file <br> <br>    if (!ReadFile(hFile, (LPSTR)&amp;bmfHeader, sizeof (BITMAPFILEHEADER), <br>            &amp;dwRead, NULL)) <br>        goto ErrExit; <br> <br>    if (sizeof (BITMAPFILEHEADER) != dwRead) <br>        goto ErrExit; <br> <br>    if (bmfHeader.bfType != 0x4d42)  // 'BM' <br>        goto ErrExit; <br> <br>    // read the BITMAPINFOHEADER <br> <br>    if (!ReadFile(hFile, (LPSTR)lpbi, sizeof(BITMAPINFOHEADER), &amp;dwRead, <br>            NULL)) <br>        goto ErrExit; <br> <br>    if (sizeof(BITMAPINFOHEADER) != dwRead) <br>        goto ErrExit; <br> <br>    // Check to see that it's a Windows DIB -- an OS/2 DIB would cause <br>    // strange problems with the rest of the DIB API since the fields <br>    // in the header are different and the color table entries are <br>    // smaller. <br>    // <br>    // If it's not a Windows DIB (e.g. if biSize is wrong), return NULL. <br> <br>    if (lpbi-&gt;biSize == sizeof(BITMAPCOREHEADER)) <br>        goto ErrExit; <br> <br>    // Now determine the size of the color table and read it.  Since the <br>    // bitmap bits are offset in the file by bfOffBits, we need to do some <br>    // special processing here to make sure the bits directly follow <br>    // the color table (because that's the format we are susposed to pass <br>    // back) <br> <br>    if (!(nNumColors = (UINT)lpbi-&gt;biClrUsed)) <br>    { <br>        // no color table for 24-bit, default size otherwise <br> <br>        if (lpbi-&gt;biBitCount != 24) <br>            nNumColors = 1 &lt;&lt; lpbi-&gt;biBitCount; // standard size table <br>    } <br> <br>    // fill in some default values if they are zero <br> <br>    if (lpbi-&gt;biClrUsed == 0) <br>        lpbi-&gt;biClrUsed = nNumColors; <br> <br>    if (lpbi-&gt;biSizeImage == 0) <br>    { <br>        lpbi-&gt;biSizeImage = ((((lpbi-&gt;biWidth * (DWORD)lpbi-&gt;biBitCount) + <br>                31) &amp; ~31) &gt;&gt; 3) * lpbi-&gt;biHeight; <br>    } <br> <br>    // get a proper-sized buffer for header, color table and bits <br> <br>    GlobalUnlock(hDIB); <br>    hDIBtmp = GlobalReAlloc(hDIB, lpbi-&gt;biSize + nNumColors * <br>            sizeof(RGBQUAD) + lpbi-&gt;biSizeImage, 0); <br> <br>    if (!hDIBtmp) // can't resize buffer for loading <br>        goto ErrExitNoUnlock; //MPB <br>    else <br>        hDIB = hDIBtmp; <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>    // read the color table <br> <br>    ReadFile (hFile, (LPSTR)(lpbi) + lpbi-&gt;biSize, <br>            nNumColors * sizeof(RGBQUAD), &amp;dwRead, NULL); <br> <br>    // offset to the bits from start of DIB header <br> <br>    offBits = lpbi-&gt;biSize + nNumColors * sizeof(RGBQUAD); <br> <br>    // If the bfOffBits field is non-zero, then the bits might *not* be <br>    // directly following the color table in the file.  Use the value in <br>    // bfOffBits to seek the bits. <br> <br>    if (bmfHeader.bfOffBits != 0L) <br>        SetFilePointer(hFile, bmfHeader.bfOffBits, NULL, FILE_BEGIN); <br> <br>    if (ReadFile(hFile, (LPSTR)lpbi + offBits, lpbi-&gt;biSizeImage, &amp;dwRead, <br>            NULL)) <br>        goto OKExit; <br> <br> <br>ErrExit: <br>    GlobalUnlock(hDIB);     <br> <br>ErrExitNoUnlock:     <br>    GlobalFree(hDIB); <br>    return NULL; <br> <br>OKExit: <br>    GlobalUnlock(hDIB); <br>    return hDIB; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
