<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIBUTIL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3471"></a>DIBUTIL.C</h2>
<pre><code>//********************************************************************** <br>// <br>//  dibutil.c <br>// <br>//  Source file for Device-Independent Bitmap (DIB) API.  Provides <br>//  the following functions: <br>// <br>//  CreateDIB()         - Creates new DIB <br>//  FindDIBBits()       - Sets pointer to the DIB bits <br>//  DIBWidth()          - Gets the width of the DIB <br>//  DIBHeight()         - Gets the height of the DIB <br>//  PaletteSize()       - Calculates the buffer size required by a palette <br>//  DIBNumColors()      - Calculates number of colors in the DIB's color table <br>//  CreateDIBPalette()  - Creates a palette from a DIB <br>//  DIBToBitmap()       - Creates a bitmap from a DIB <br>//  BitmapToDIB()       - Creates a DIB from a bitmap <br>//  PalEntriesOnDevice()- Gets the number of palette entries of a device <br>//  GetSystemPalette()  - Returns a handle to the current system palette <br>//  AllocRoomForDIB()   - Allocates memory for a DIB <br>//  ChangeDIBFormat()   - Changes a DIB's BPP and/or compression format <br>//  ChangeBitmapFormat()- Changes a bitmap to a DIB with specified BPP and <br>//                        compression format <br>// <br>// Written by Microsoft Product Support Services, Developer Support. <br>// Copyright 1991-1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#define     STRICT      // enable strict type checking <br> <br>#include &lt;windows.h&gt; <br>#include &lt;assert.h&gt; <br>#include "dibapi.h" <br>#include "dibutil.h" <br>#include &lt;stdio.h&gt; <br> <br> <br>/************************************************************************* <br> * <br> * CreateDIB() <br> * <br> * Parameters: <br> * <br> * DWORD dwWidth    - Width for new bitmap, in pixels <br> * DWORD dwHeight   - Height for new bitmap  <br> * WORD  wBitCount  - Bit Count for new DIB (1, 4, 8, or 24) <br> * <br> * Return Value: <br> * <br> * HDIB             - Handle to new DIB <br> * <br> * Description: <br> * <br> * This function allocates memory for and initializes a new DIB by <br> * filling in the BITMAPINFOHEADER, allocating memory for the color <br> * table, and allocating memory for the bitmap bits.  As with all <br> * HDIBs, the header, colortable and bits are all in one contiguous <br> * memory block.  This function is similar to the CreateBitmap()  <br> * Windows API. <br> * <br> * The colortable and bitmap bits are left uninitialized (zeroed) in the <br> * returned HDIB. <br> * <br> * <br> ************************************************************************/ <br> <br>HDIB CreateDIB(DWORD dwWidth, DWORD dwHeight, WORD wBitCount) <br>{ <br>    BITMAPINFOHEADER    bi;             // bitmap header <br>    LPBITMAPINFOHEADER  lpbi;           // pointer to BITMAPINFOHEADER <br>    DWORD               dwLen;          // size of memory block <br>    HDIB                hDIB; <br>    DWORD               dwBytesPerLine; // Number of bytes per scanline <br> <br> <br>    // Make sure bits per pixel is valid <br> <br>    if (wBitCount &lt;= 1) <br>        wBitCount = 1; <br>    else if (wBitCount &lt;= 4) <br>        wBitCount = 4; <br>    else if (wBitCount &lt;= 8) <br>        wBitCount = 8; <br>    else if (wBitCount &lt;= 24) <br>        wBitCount = 24; <br>    else <br>        wBitCount = 4;  // set default value to 4 if parameter is bogus <br> <br>    // initialize BITMAPINFOHEADER <br> <br>    bi.biSize = sizeof(BITMAPINFOHEADER); <br>    bi.biWidth = dwWidth;         // fill in width from parameter <br>    bi.biHeight = dwHeight;       // fill in height from parameter <br>    bi.biPlanes = 1;              // must be 1 <br>    bi.biBitCount = wBitCount;    // from parameter <br>    bi.biCompression = BI_RGB;     <br>    bi.biSizeImage = 0;           // 0's here mean "default" <br>    bi.biXPelsPerMeter = 0; <br>    bi.biYPelsPerMeter = 0; <br>    bi.biClrUsed = 0; <br>    bi.biClrImportant = 0; <br> <br>    // calculate size of memory block required to store the DIB.  This <br>    // block should be big enough to hold the BITMAPINFOHEADER, the color <br>    // table, and the bits <br> <br>    dwBytesPerLine = WIDTHBYTES(wBitCount * dwWidth); <br>    dwLen = bi.biSize + PaletteSize((LPSTR)&amp;bi) + (dwBytesPerLine * dwHeight); <br> <br>    // alloc memory block to store our bitmap <br> <br>    hDIB = GlobalAlloc(GHND, dwLen); <br> <br>    // major bummer if we couldn't get memory block <br> <br>    if (!hDIB) <br>        return NULL; <br> <br>    // lock memory and get pointer to it <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>    // use our bitmap info structure to fill in first part of <br>    // our DIB with the BITMAPINFOHEADER <br> <br>    *lpbi = bi; <br> <br>    // Since we don't know what the colortable and bits should contain, <br>    // just leave these blank.  Unlock the DIB and return the HDIB. <br> <br>    GlobalUnlock(hDIB); <br> <br>    //return handle to the DIB <br> <br>    return hDIB; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * FindDIBBits() <br> * <br> * Parameter: <br> * <br> * LPSTR lpDIB      - pointer to packed-DIB memory block <br> * <br> * Return Value: <br> * <br> * LPSTR            - pointer to the DIB bits <br> * <br> * Description: <br> * <br> * This function calculates the address of the DIB's bits and returns a <br> * pointer to the DIB bits. <br> * <br> ************************************************************************/ <br> <br>LPSTR FindDIBBits(LPSTR lpDIB) <br>{ <br>   return (lpDIB + *(LPDWORD)lpDIB + PaletteSize(lpDIB)); <br>} <br> <br> <br>/************************************************************************* <br> * <br> * DIBWidth() <br> * <br> * Parameter: <br> * <br> * LPSTR lpDIB      - pointer to packed-DIB memory block <br> * <br> * Return Value: <br> * <br> * DWORD            - width of the DIB <br> * <br> * Description: <br> * <br> * This function gets the width of the DIB from the BITMAPINFOHEADER <br> * width field if it is a Windows 3.0-style DIB or from the BITMAPCOREHEADER <br> * width field if it is an OS/2-style DIB. <br> * <br> ************************************************************************/ <br> <br> <br>DWORD DIBWidth(LPSTR lpDIB) <br>{ <br>    LPBITMAPINFOHEADER   lpbmi;  // pointer to a Win 3.0-style DIB <br>    LPBITMAPCOREHEADER   lpbmc;  // pointer to an OS/2-style DIB <br> <br>    // point to the header (whether Win 3.0 and OS/2) <br> <br>    lpbmi = (LPBITMAPINFOHEADER)lpDIB; <br>    lpbmc = (LPBITMAPCOREHEADER)lpDIB; <br> <br>    // return the DIB width if it is a Win 3.0 DIB <br> <br>    if (lpbmi-&gt;biSize == sizeof(BITMAPINFOHEADER)) <br>        return lpbmi-&gt;biWidth; <br>    else  // it is an OS/2 DIB, so return its width <br>        return (DWORD)lpbmc-&gt;bcWidth; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * DIBHeight() <br> * <br> * Parameter: <br> * <br> * LPSTR lpDIB      - pointer to packed-DIB memory block <br> * <br> * Return Value: <br> * <br> * DWORD            - height of the DIB <br> * <br> * Description: <br> * <br> * This function gets the height of the DIB from the BITMAPINFOHEADER <br> * height field if it is a Windows 3.0-style DIB or from the BITMAPCOREHEADER <br> * height field if it is an OS/2-style DIB. <br> * <br> ************************************************************************/ <br> <br>DWORD DIBHeight(LPSTR lpDIB) <br>{ <br>   LPBITMAPINFOHEADER   lpbmi;  // pointer to a Win 3.0-style DIB <br>   LPBITMAPCOREHEADER   lpbmc;  // pointer to an OS/2-style DIB <br> <br>   // point to the header (whether OS/2 or Win 3.0 <br> <br>   lpbmi = (LPBITMAPINFOHEADER)lpDIB; <br>   lpbmc = (LPBITMAPCOREHEADER)lpDIB; <br> <br>    // return the DIB height if it is a Win 3.0 DIB <br>    if (lpbmi-&gt;biSize == sizeof(BITMAPINFOHEADER)) <br>        return lpbmi-&gt;biHeight; <br>    else  // it is an OS/2 DIB, so return its height <br>        return (DWORD)lpbmc-&gt;bcHeight; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * PaletteSize() <br> * <br> * Parameter: <br> * <br> * LPSTR lpDIB      - pointer to packed-DIB memory block <br> * <br> * Return Value: <br> * <br> * WORD             - size of the color palette of the DIB <br> * <br> * Description: <br> * <br> * This function gets the size required to store the DIB's palette by <br> * multiplying the number of colors by the size of an RGBQUAD (for a <br> * Windows 3.0-style DIB) or by the size of an RGBTRIPLE (for an OS/2- <br> * style DIB). <br> * <br> ************************************************************************/ <br> <br>WORD PaletteSize(LPSTR lpDIB) <br>{ <br>    // calculate the size required by the palette <br>    if (IS_WIN30_DIB (lpDIB)) <br>        return (DIBNumColors(lpDIB) * sizeof(RGBQUAD)); <br>    else <br>        return (DIBNumColors(lpDIB) * sizeof(RGBTRIPLE)); <br>} <br> <br> <br>/************************************************************************* <br> * <br> * DIBNumColors() <br> * <br> * Parameter: <br> * <br> * LPSTR lpDIB      - pointer to packed-DIB memory block <br> * <br> * Return Value: <br> * <br> * WORD             - number of colors in the color table <br> * <br> * Description: <br> * <br> * This function calculates the number of colors in the DIB's color table <br> * by finding the bits per pixel for the DIB (whether Win3.0 or OS/2-style <br> * DIB). If bits per pixel is 1: colors=2, if 4: colors=16, if 8: colors=256, <br> * if 24, no colors in color table. <br> * <br> ************************************************************************/ <br> <br>WORD DIBNumColors(LPSTR lpDIB) <br>{ <br>    WORD wBitCount;  // DIB bit count <br> <br>    // If this is a Windows-style DIB, the number of colors in the <br>    // color table can be less than the number of bits per pixel <br>    // allows for (i.e. lpbi-&gt;biClrUsed can be set to some value). <br>    // If this is the case, return the appropriate value. <br>     <br> <br>    if (IS_WIN30_DIB(lpDIB)) <br>    { <br>        DWORD dwClrUsed; <br> <br>        dwClrUsed = ((LPBITMAPINFOHEADER)lpDIB)-&gt;biClrUsed; <br>        if (dwClrUsed) <br> <br>        return (WORD)dwClrUsed; <br>    } <br> <br>    // Calculate the number of colors in the color table based on <br>    // the number of bits per pixel for the DIB. <br>     <br>    if (IS_WIN30_DIB(lpDIB)) <br>        wBitCount = ((LPBITMAPINFOHEADER)lpDIB)-&gt;biBitCount; <br>    else <br>        wBitCount = ((LPBITMAPCOREHEADER)lpDIB)-&gt;bcBitCount; <br> <br>    // return number of colors based on bits per pixel <br> <br>    switch (wBitCount) <br>    { <br>        case 1: <br>            return 2; <br> <br>        case 4: <br>            return 16; <br> <br>        case 8: <br>            return 256; <br> <br>        default: <br>            return 0; <br>    } <br>} <br> <br> <br>/************************************************************************* <br> * <br> * CreateDIBPalette() <br> * <br> * Parameter: <br> * <br> * HDIB hDIB        - specifies the DIB <br> * <br> * Return Value: <br> * <br> * HPALETTE         - specifies the palette <br> * <br> * Description: <br> * <br> * This function creates a palette from a DIB by allocating memory for the <br> * logical palette, reading and storing the colors from the DIB's color table <br> * into the logical palette, creating a palette from this logical palette, <br> * and then returning the palette's handle. This allows the DIB to be <br> * displayed using the best possible colors (important for DIBs with 256 or <br> * more colors). <br> * <br> ************************************************************************/ <br> <br>HPALETTE CreateDIBPalette(HDIB hDIB) <br>{ <br>    LPLOGPALETTE        lpPal;          // pointer to a logical palette <br>    HANDLE              hLogPal;        // handle to a logical palette <br>    HPALETTE            hPal = NULL;    // handle to a palette <br>    int                 i, wNumColors;  // loop index, number of colors in color table <br>    LPSTR               lpbi;           // pointer to packed-DIB <br>    LPBITMAPINFO        lpbmi;          // pointer to BITMAPINFO structure (Win3.0) <br>    LPBITMAPCOREINFO    lpbmc;          // pointer to BITMAPCOREINFO structure (OS/2) <br>    BOOL                bWinStyleDIB;   // Win3.0 DIB? <br> <br>    // if handle to DIB is invalid, return NULL <br> <br>    if (!hDIB) <br>        return NULL; <br> <br>    // lock DIB memory block and get a pointer to it <br> <br>    lpbi = GlobalLock(hDIB); <br> <br>    // get pointer to BITMAPINFO (Win 3.0) <br> <br>    lpbmi = (LPBITMAPINFO)lpbi; <br> <br>    // get pointer to BITMAPCOREINFO (OS/2 1.x) <br> <br>    lpbmc = (LPBITMAPCOREINFO)lpbi; <br> <br>    // get the number of colors in the DIB  <br> <br>    wNumColors = DIBNumColors(lpbi); <br> <br>    // is this a Win 3.0 DIB? <br> <br>    bWinStyleDIB = IS_WIN30_DIB(lpbi); <br>    if (wNumColors) <br>    { <br>        // allocate memory block for logical palette <br> <br>        hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) + <br>                sizeof(PALETTEENTRY) * wNumColors); <br> <br>        // if not enough memory, clean up and return NULL <br> <br>        if (!hLogPal) <br>        { <br>            GlobalUnlock(hDIB); <br>            return NULL; <br>        } <br> <br>        // lock memory block and get pointer to it <br> <br>        lpPal = (LPLOGPALETTE)GlobalLock(hLogPal); <br> <br>        // set version and number of palette entries <br> <br>        lpPal-&gt;palVersion = PALVERSION; <br>        lpPal-&gt;palNumEntries = wNumColors; <br> <br>        // store RGB triples (if Win 3.0 DIB) or RGB quads (if OS/2 DIB) <br>        // into palette <br>         <br>        for (i = 0; i &lt; wNumColors; i++) <br>        { <br>            if (bWinStyleDIB) <br>            { <br>                lpPal-&gt;palPalEntry[i].peRed = lpbmi-&gt;bmiColors[i].rgbRed; <br>                lpPal-&gt;palPalEntry[i].peGreen = lpbmi-&gt;bmiColors[i].rgbGreen; <br>                lpPal-&gt;palPalEntry[i].peBlue = lpbmi-&gt;bmiColors[i].rgbBlue; <br>                lpPal-&gt;palPalEntry[i].peFlags = 0; <br>            } <br>            else <br>            { <br>                lpPal-&gt;palPalEntry[i].peRed = lpbmc-&gt;bmciColors[i].rgbtRed; <br>                lpPal-&gt;palPalEntry[i].peGreen = lpbmc-&gt;bmciColors[i].rgbtGreen; <br>                lpPal-&gt;palPalEntry[i].peBlue = lpbmc-&gt;bmciColors[i].rgbtBlue; <br>                lpPal-&gt;palPalEntry[i].peFlags = 0; <br>            } <br>        } <br> <br>        // create the palette and get handle to it <br> <br>        hPal = CreatePalette(lpPal); <br> <br>        // if error getting handle to palette, clean up and return NULL <br> <br>        if (!hPal) <br>        { <br>            GlobalUnlock(hLogPal); <br>            GlobalFree(hLogPal); <br>            return NULL; <br>        } <br>    } <br> <br>    // clean up  <br> <br>    GlobalUnlock(hLogPal); <br>    GlobalFree(hLogPal); <br>    GlobalUnlock(hDIB); <br> <br>    // return handle to DIB's palette <br>    return hPal; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * DIBToBitmap() <br> * <br> * Parameters: <br> * <br> * HDIB hDIB        - specifies the DIB to convert <br> * <br> * HPALETTE hPal    - specifies the palette to use with the bitmap <br> * <br> * Return Value: <br> * <br> * HBITMAP          - identifies the device-dependent bitmap <br> * <br> * Description: <br> * <br> * This function creates a bitmap from a DIB using the specified palette. <br> * If no palette is specified, default is used. <br> * <br> * NOTE: <br> * <br> * The bitmap returned from this funciton is always a bitmap compatible <br> * with the screen (e.g. same bits/pixel and color planes) rather than <br> * a bitmap with the same attributes as the DIB.  This behavior is by <br> * design, and occurs because this function calls CreateDIBitmap to <br> * do its work, and CreateDIBitmap always creates a bitmap compatible <br> * with the hDC parameter passed in (because it in turn calls <br> * CreateCompatibleBitmap). <br> * <br> * So for instance, if your DIB is a monochrome DIB and you call this <br> * function, you will not get back a monochrome HBITMAP -- you will <br> * get an HBITMAP compatible with the screen DC, but with only 2 <br> * colors used in the bitmap. <br> * <br> * If your application requires a monochrome HBITMAP returned for a <br> * monochrome DIB, use the function SetDIBits(). <br> * <br> * Also, the DIBpassed in to the function is not destroyed on exit. This <br> * must be done later, once it is no longer needed. <br> * <br> ************************************************************************/ <br> <br>HBITMAP DIBToBitmap(HDIB hDIB, HPALETTE hPal) <br>{ <br>    LPSTR       lpDIBHdr, lpDIBBits;  // pointer to DIB header, pointer to DIB bits <br>    HBITMAP     hBitmap;            // handle to device-dependent bitmap <br>    HDC         hDC;                    // handle to DC <br>    HPALETTE    hOldPal = NULL;    // handle to a palette <br> <br>    // if invalid handle, return NULL  <br> <br>    if (!hDIB) <br>        return NULL; <br> <br>    // lock memory block and get a pointer to it <br> <br>    lpDIBHdr = GlobalLock(hDIB); <br> <br>    // get a pointer to the DIB bits <br> <br>    lpDIBBits = FindDIBBits(lpDIBHdr); <br> <br>    // get a DC  <br> <br>    hDC = GetDC(NULL); <br>    if (!hDC) <br>    { <br>        // clean up and return NULL <br> <br>        GlobalUnlock(hDIB); <br>        return NULL; <br>    } <br> <br>    // select and realize palette <br> <br>    if (hPal) <br>        hOldPal = SelectPalette(hDC, hPal, FALSE); <br> <br>    RealizePalette(hDC); <br> <br>    // create bitmap from DIB info. and bits <br>    hBitmap = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)lpDIBHdr, CBM_INIT, <br>            lpDIBBits, (LPBITMAPINFO)lpDIBHdr, DIB_RGB_COLORS); <br> <br>    // restore previous palette <br>    if (hOldPal) <br>        SelectPalette(hDC, hOldPal, FALSE); <br> <br>    // clean up <br>    ReleaseDC(NULL, hDC); <br>    GlobalUnlock(hDIB); <br> <br>    // return handle to the bitmap <br>    return hBitmap; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * BitmapToDIB() <br> * <br> * Parameters: <br> * <br> * HBITMAP hBitmap  - specifies the bitmap to convert <br> * <br> * HPALETTE hPal    - specifies the palette to use with the bitmap <br> * <br> * Return Value: <br> * <br> * HDIB             - identifies the device-dependent bitmap <br> * <br> * Description: <br> * <br> * This function creates a DIB from a bitmap using the specified palette. <br> * <br> ************************************************************************/ <br> <br>HDIB BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal) <br>{ <br>    BITMAP              bm;         // bitmap structure <br>    BITMAPINFOHEADER    bi;         // bitmap header <br>    LPBITMAPINFOHEADER  lpbi;       // pointer to BITMAPINFOHEADER <br>    DWORD               dwLen;      // size of memory block <br>    HANDLE              hDIB, h;    // handle to DIB, temp handle <br>    HDC                 hDC;        // handle to DC <br>    WORD                biBits;     // bits per pixel <br> <br>    // check if bitmap handle is valid <br> <br>    if (!hBitmap) <br>        return NULL; <br> <br>    // fill in BITMAP structure, return NULL if it didn't work <br> <br>    if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&amp;bm)) <br>        return NULL; <br> <br>    // if no palette is specified, use default palette <br> <br>    if (hPal == NULL) <br>        hPal = GetStockObject(DEFAULT_PALETTE); <br> <br>    // calculate bits per pixel <br> <br>    biBits = bm.bmPlanes * bm.bmBitsPixel; <br> <br>    // make sure bits per pixel is valid <br> <br>    if (biBits &lt;= 1) <br>        biBits = 1; <br>    else if (biBits &lt;= 4) <br>        biBits = 4; <br>    else if (biBits &lt;= 8) <br>        biBits = 8; <br>    else // if greater than 8-bit, force to 24-bit <br>        biBits = 24; <br> <br>    // initialize BITMAPINFOHEADER <br> <br>    bi.biSize = sizeof(BITMAPINFOHEADER); <br>    bi.biWidth = bm.bmWidth; <br>    bi.biHeight = bm.bmHeight; <br>    bi.biPlanes = 1; <br>    bi.biBitCount = biBits; <br>    bi.biCompression = BI_RGB; <br>    bi.biSizeImage = 0; <br>    bi.biXPelsPerMeter = 0; <br>    bi.biYPelsPerMeter = 0; <br>    bi.biClrUsed = 0; <br>    bi.biClrImportant = 0; <br> <br>    // calculate size of memory block required to store BITMAPINFO <br> <br>    dwLen = bi.biSize + PaletteSize((LPSTR)&amp;bi); <br> <br>    // get a DC <br> <br>    hDC = GetDC(NULL); <br> <br>    // select and realize our palette <br> <br>    hPal = SelectPalette(hDC, hPal, FALSE); <br>    RealizePalette(hDC); <br> <br>    // alloc memory block to store our bitmap <br> <br>    hDIB = GlobalAlloc(GHND, dwLen); <br> <br>    // if we couldn't get memory block <br> <br>    if (!hDIB) <br>    { <br>      // clean up and return NULL <br> <br>      SelectPalette(hDC, hPal, TRUE); <br>      RealizePalette(hDC); <br>      ReleaseDC(NULL, hDC); <br>      return NULL; <br>    } <br> <br>    // lock memory and get pointer to it <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>    /// use our bitmap info. to fill BITMAPINFOHEADER <br> <br>    *lpbi = bi; <br> <br>    // call GetDIBits with a NULL lpBits param, so it will calculate the <br>    // biSizeImage field for us     <br> <br>    GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, NULL, (LPBITMAPINFO)lpbi, <br>        DIB_RGB_COLORS); <br> <br>    // get the info. returned by GetDIBits and unlock memory block <br> <br>    bi = *lpbi; <br>    GlobalUnlock(hDIB); <br> <br>    // if the driver did not fill in the biSizeImage field, make one up  <br>    if (bi.biSizeImage == 0) <br>        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight; <br> <br>    // realloc the buffer big enough to hold all the bits <br> <br>    dwLen = bi.biSize + PaletteSize((LPSTR)&amp;bi) + bi.biSizeImage; <br> <br>    if (h = GlobalReAlloc(hDIB, dwLen, 0)) <br>        hDIB = h; <br>    else <br>    { <br>        // clean up and return NULL <br> <br>        GlobalFree(hDIB); <br>        hDIB = NULL; <br>        SelectPalette(hDC, hPal, TRUE); <br>        RealizePalette(hDC); <br>        ReleaseDC(NULL, hDC); <br>        return NULL; <br>    } <br> <br>    // lock memory block and get pointer to it */ <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br> <br>    // call GetDIBits with a NON-NULL lpBits param, and actualy get the <br>    // bits this time <br> <br>    if (GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, (LPSTR)lpbi + <br>            (WORD)lpbi-&gt;biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi, <br>            DIB_RGB_COLORS) == 0) <br>    { <br>        // clean up and return NULL <br> <br>        GlobalUnlock(hDIB); <br>        hDIB = NULL; <br>        SelectPalette(hDC, hPal, TRUE); <br>        RealizePalette(hDC); <br>        ReleaseDC(NULL, hDC); <br>        return NULL; <br>    } <br> <br>    bi = *lpbi; <br> <br>    // clean up  <br>    GlobalUnlock(hDIB); <br>    SelectPalette(hDC, hPal, TRUE); <br>    RealizePalette(hDC); <br>    ReleaseDC(NULL, hDC); <br> <br>    // return handle to the DIB <br>    return hDIB; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * PalEntriesOnDevice() <br> * <br> * Parameter: <br> * <br> * HDC hDC          - device context <br> * <br> * Return Value: <br> * <br> * int              - number of palette entries on device <br> * <br> * Description: <br> * <br> * This function gets the number of palette entries on the specified device <br> * <br> ************************************************************************/ <br> <br>int PalEntriesOnDevice(HDC hDC) <br>{ <br>    int nColors;  // number of colors <br> <br>    // Find out the number of colors on this device. <br>     <br>    nColors = (1 &lt;&lt; (GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES))); <br> <br>    assert(nColors); <br>    return nColors; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * GetSystemPalette() <br> * <br> * Parameters: <br> * <br> * None <br> * <br> * Return Value: <br> * <br> * HPALETTE         - handle to a copy of the current system palette <br> * <br> * Description: <br> * <br> * This function returns a handle to a palette which represents the system <br> * palette.  The system RGB values are copied into our logical palette using <br> * the GetSystemPaletteEntries function.   <br> * <br> ************************************************************************/ <br> <br>HPALETTE GetSystemPalette(void) <br>{ <br>    HDC hDC;                // handle to a DC <br>    static HPALETTE hPal = NULL;   // handle to a palette <br>    HANDLE hLogPal;         // handle to a logical palette <br>    LPLOGPALETTE lpLogPal;  // pointer to a logical palette <br>    int nColors;            // number of colors <br> <br>    // Find out how many palette entries we want. <br> <br>    hDC = GetDC(NULL); <br> <br>    if (!hDC) <br>        return NULL; <br> <br>    nColors = PalEntriesOnDevice(hDC);   // Number of palette entries <br> <br>    // Allocate room for the palette and lock it. <br> <br>    hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) + nColors * <br>            sizeof(PALETTEENTRY)); <br> <br>    // if we didn't get a logical palette, return NULL <br> <br>    if (!hLogPal) <br>        return NULL; <br> <br>    // get a pointer to the logical palette <br> <br>    lpLogPal = (LPLOGPALETTE)GlobalLock(hLogPal); <br> <br>    // set some important fields <br> <br>    lpLogPal-&gt;palVersion = PALVERSION; <br>    lpLogPal-&gt;palNumEntries = nColors; <br> <br>    // Copy the current system palette into our logical palette <br> <br>    GetSystemPaletteEntries(hDC, 0, nColors, <br>            (LPPALETTEENTRY)(lpLogPal-&gt;palPalEntry)); <br> <br>    // Go ahead and create the palette.  Once it's created, <br>    // we no longer need the LOGPALETTE, so free it.     <br> <br>    hPal = CreatePalette(lpLogPal); <br> <br>    // clean up <br> <br>    GlobalUnlock(hLogPal); <br>    GlobalFree(hLogPal); <br>    ReleaseDC(NULL, hDC); <br> <br>    return hPal; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * AllocRoomForDIB() <br> * <br> * Parameters: <br> * <br> * BITMAPINFOHEADER - bitmap info header stucture <br> * <br> * HBITMAP          - handle to the bitmap <br> * <br> * Return Value: <br> * <br> * HDIB             - handle to memory block <br> * <br> * Description: <br> * <br> *  This routine takes a BITMAPINOHEADER, and returns a handle to global <br> *  memory which can contain a DIB with that header.  It also initializes <br> *  the header portion of the global memory.  GetDIBits() is used to determine <br> *  the amount of room for the DIB's bits.  The total amount of memory <br> *  needed = sizeof(BITMAPINFOHEADER) + size of color table + size of bits. <br> * <br> ************************************************************************/ <br> <br>HANDLE AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap) <br>{ <br>    DWORD               dwLen; <br>    HANDLE              hDIB; <br>    HDC                 hDC; <br>    LPBITMAPINFOHEADER  lpbi; <br>    HANDLE              hTemp; <br> <br>    // Figure out the size needed to hold the BITMAPINFO structure <br>    // (which includes the BITMAPINFOHEADER and the color table). <br> <br>    dwLen = bi.biSize + PaletteSize((LPSTR) &amp;bi); <br>    hDIB  = GlobalAlloc(GHND,dwLen); <br> <br>    // Check that DIB handle is valid <br> <br>    if (!hDIB) <br>        return NULL; <br> <br>    // Set up the BITMAPINFOHEADER in the newly allocated global memory, <br>    // then call GetDIBits() with lpBits = NULL to have it fill in the <br>    // biSizeImage field for us. <br> <br>    lpbi  = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br>    *lpbi = bi; <br> <br>    hDC   = GetDC(NULL); <br> <br>    GetDIBits(hDC, hBitmap, 0, (UINT) bi.biHeight, NULL, (LPBITMAPINFO)lpbi, <br>            DIB_RGB_COLORS); <br>    ReleaseDC(NULL, hDC); <br> <br>    // If the driver did not fill in the biSizeImage field, <br>    // fill it in -- NOTE: this is a bug in the driver! <br>     <br>    if (lpbi-&gt;biSizeImage == 0) <br>        lpbi-&gt;biSizeImage = WIDTHBYTES((DWORD)lpbi-&gt;biWidth * <br>                lpbi-&gt;biBitCount) * lpbi-&gt;biHeight; <br> <br>    // Get the size of the memory block we need <br> <br>    dwLen = lpbi-&gt;biSize + PaletteSize((LPSTR) &amp;bi) + lpbi-&gt;biSizeImage; <br> <br>    // Unlock the memory block <br> <br>    GlobalUnlock(hDIB); <br> <br>    // ReAlloc the buffer big enough to hold all the bits  <br> <br>    if (hTemp = GlobalReAlloc(hDIB,dwLen,0)) <br>        return hTemp; <br>    else <br>    { <br>        // Else free memory block and return failure <br> <br>        GlobalFree(hDIB); <br>        return NULL; <br>    } <br>} <br> <br> <br>/************************************************************************* <br> * <br> * ChangeDIBFormat() <br> * <br> * Parameter: <br> * <br> * HDIB             - handle to packed-DIB in memory <br> * <br> * WORD             - desired bits per pixel <br> * <br> * DWORD            - desired compression format <br> * <br> * Return Value: <br> * <br> * HDIB             - handle to the new DIB if successful, else NULL <br> * <br> * Description: <br> * <br> * This function will convert the bits per pixel and/or the compression <br> * format of the specified DIB. Note: If the conversion was unsuccessful, <br> * we return NULL. The original DIB is left alone. Don't use code like the <br> * following: <br> * <br> *    hMyDIB = ChangeDIBFormat(hMyDIB, 8, BI_RLE4); <br> * <br> * The conversion will fail, but hMyDIB will now be NULL and the original <br> * DIB will now hang around in memory. We could have returned the old <br> * DIB, but we wanted to allow the programmer to check whether this <br> * conversion succeeded or failed. <br> * <br> ************************************************************************/ <br> <br>HDIB ChangeDIBFormat(HDIB hDIB, WORD wBitCount, DWORD dwCompression) <br>{ <br>    HDC                hDC;             // Handle to DC <br>    HBITMAP            hBitmap;         // Handle to bitmap <br>    BITMAP             Bitmap;          // BITMAP data structure <br>    BITMAPINFOHEADER   bi;              // Bitmap info header <br>    LPBITMAPINFOHEADER lpbi;            // Pointer to bitmap info <br>    HDIB               hNewDIB = NULL;  // Handle to new DIB <br>    HPALETTE           hPal, hOldPal;   // Handle to palette, prev pal <br>    WORD               DIBBPP, NewBPP;  // DIB bits per pixel, new bpp <br>    DWORD              DIBComp, NewComp;// DIB compression, new compression <br> <br>    // Check for a valid DIB handle <br> <br>    if (!hDIB) <br>        return NULL; <br> <br>    // Get the old DIB's bits per pixel and compression format <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); <br>    DIBBPP = ((LPBITMAPINFOHEADER)lpbi)-&gt;biBitCount; <br>    DIBComp = ((LPBITMAPINFOHEADER)lpbi)-&gt;biCompression; <br>    GlobalUnlock(hDIB); <br> <br>    // Validate wBitCount and dwCompression <br>    // They must match correctly (i.e., BI_RLE4 and 4 BPP or <br>    // BI_RLE8 and 8BPP, etc.) or we return failure <br>    if (wBitCount == 0) <br>    { <br>        NewBPP = DIBBPP; <br>        if ((dwCompression == BI_RLE4 &amp;&amp; NewBPP == 4) || <br>                (dwCompression == BI_RLE8 &amp;&amp; NewBPP == 8) || <br>                (dwCompression == BI_RGB)) <br>            NewComp = dwCompression; <br>        else <br>            return NULL; <br>    } <br>    else if (wBitCount == 1 &amp;&amp; dwCompression == BI_RGB) <br>    { <br>        NewBPP = wBitCount; </code></pre>
<p>
</p>
<pre><code>NewComp = BI_RGB; <br>    } <br>    else if (wBitCount == 4) <br>    { <br>        NewBPP = wBitCount; <br>        if (dwCompression == BI_RGB || dwCompression == BI_RLE4) <br>            NewComp = dwCompression; <br>        else <br>            return NULL; <br>    } <br>    else if (wBitCount == 8) <br>    { <br>        NewBPP = wBitCount; <br>        if (dwCompression == BI_RGB || dwCompression == BI_RLE8) <br>            NewComp = dwCompression; <br>        else <br>            return NULL; <br>    } <br>    else if (wBitCount == 24 &amp;&amp; dwCompression == BI_RGB) <br>    { <br>        NewBPP = wBitCount; <br>        NewComp = BI_RGB; <br>    } <br>    else <br>        return NULL; <br> <br>    // Save the old DIB's palette <br> <br>    hPal = CreateDIBPalette(hDIB); <br>    if (!hPal) <br>        return NULL; <br> <br>    // Convert old DIB to a bitmap <br> <br>    hBitmap = DIBToBitmap(hDIB, hPal); <br>    if (!hBitmap) <br>    { <br>        DeleteObject(hPal); <br>        return NULL; <br>    } <br> <br>    // Get info about the bitmap <br>    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&amp;Bitmap); <br> <br>    // Fill in the BITMAPINFOHEADER appropriately <br> <br>    bi.biSize               = sizeof(BITMAPINFOHEADER); <br>    bi.biWidth              = Bitmap.bmWidth; <br>    bi.biHeight             = Bitmap.bmHeight; <br>    bi.biPlanes             = 1; <br>    bi.biBitCount           = NewBPP; <br>    bi.biCompression        = NewComp; <br>    bi.biSizeImage          = 0; <br>    bi.biXPelsPerMeter      = 0; <br>    bi.biYPelsPerMeter      = 0; <br>    bi.biClrUsed            = 0; <br>    bi.biClrImportant       = 0; <br> <br>    // Go allocate room for the new DIB <br> <br>    hNewDIB = AllocRoomForDIB(bi, hBitmap); <br>    if (!hNewDIB) <br>        return NULL; <br> <br>    // Get a pointer to the new DIB <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB); <br> <br>    // Get a DC and select/realize our palette in it <br> <br>    hDC  = GetDC(NULL); <br>    hOldPal = SelectPalette(hDC, hPal, FALSE); <br>    RealizePalette(hDC); <br> <br>    // Call GetDIBits and get the new DIB bits <br> <br>    if (!GetDIBits(hDC, hBitmap, 0, (UINT) lpbi-&gt;biHeight, <br>            (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize((LPSTR)lpbi), <br>            (LPBITMAPINFO)lpbi, DIB_RGB_COLORS)) <br>    { <br>        GlobalUnlock(hNewDIB); <br>        GlobalFree(hNewDIB); <br>        hNewDIB = NULL; <br>    } <br> <br>    // Clean up and return <br> <br>    SelectPalette(hDC, hOldPal, TRUE); <br>    RealizePalette(hDC); <br>    ReleaseDC(NULL, hDC); <br> <br>    // Unlock the new DIB's memory block <br>    if (hNewDIB) <br>        GlobalUnlock(hNewDIB); <br> <br>    DeleteObject(hBitmap); <br>    DeleteObject(hPal); <br> <br>    return hNewDIB; <br>} <br> <br> <br>/************************************************************************* <br> * <br> * ChangeBitmapFormat() <br> * <br> * Parameter: <br> * <br> * HBITMAP          - handle to a bitmap <br> * <br> * WORD             - desired bits per pixel <br> * <br> * DWORD            - desired compression format <br> * <br> * HPALETTE         - handle to palette <br> * <br> * Return Value: <br> * <br> * HDIB             - handle to the new DIB if successful, else NULL <br> * <br> * Description: <br> * <br> * This function will convert a bitmap to the specified bits per pixel <br> * and compression format. The bitmap and it's palette will remain <br> * after calling this function. <br> * <br> ************************************************************************/ <br> <br>HDIB ChangeBitmapFormat(HBITMAP hBitmap, WORD wBitCount, DWORD dwCompression, <br>        HPALETTE hPal) <br>{ <br>    HDC                hDC;          // Screen DC <br>    HDIB               hNewDIB=NULL; // Handle to new DIB <br>    BITMAP             Bitmap;       // BITMAP data structure <br>    BITMAPINFOHEADER   bi;           // Bitmap info. header <br>    LPBITMAPINFOHEADER lpbi;         // Pointer to bitmap header <br>    HPALETTE           hOldPal=NULL; // Handle to palette <br>    WORD               NewBPP;       // New bits per pixel <br>    DWORD              NewComp;      // New compression format <br> <br>    // Check for a valid bitmap handle <br> <br>    if (!hBitmap) <br>        return NULL; <br> <br>    // Validate wBitCount and dwCompression <br>    // They must match correctly (i.e., BI_RLE4 and 4 BPP or <br>    // BI_RLE8 and 8BPP, etc.) or we return failure <br>     <br>    if (wBitCount == 0) <br>    { <br>        NewComp = dwCompression; <br>        if (NewComp == BI_RLE4) <br>            NewBPP = 4; <br>        else if (NewComp == BI_RLE8) <br>            NewBPP = 8; <br>        else // Not enough info */ <br>            return NULL; <br>    } <br>    else if (wBitCount == 1 &amp;&amp; dwCompression == BI_RGB) <br>    { <br>        NewBPP = wBitCount; <br>        NewComp = BI_RGB; <br>    } <br>    else if (wBitCount == 4) <br>    { <br>        NewBPP = wBitCount; <br>        if (dwCompression == BI_RGB || dwCompression == BI_RLE4) <br>            NewComp = dwCompression; <br>        else <br>            return NULL; <br>    } <br>    else if (wBitCount == 8) <br>    { <br>        NewBPP = wBitCount; <br>        if (dwCompression == BI_RGB || dwCompression == BI_RLE8) <br>            NewComp = dwCompression; <br>        else <br>            return NULL; <br>    } <br>    else if (wBitCount == 24 &amp;&amp; dwCompression == BI_RGB) <br>    { <br>        NewBPP = wBitCount; <br>        NewComp = BI_RGB; <br>    } <br>    else <br>        return NULL; <br> <br>    // Get info about the bitmap <br> <br>    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&amp;Bitmap); <br> <br>    // Fill in the BITMAPINFOHEADER appropriately <br> <br>    bi.biSize               = sizeof(BITMAPINFOHEADER); <br>    bi.biWidth              = Bitmap.bmWidth; <br>    bi.biHeight             = Bitmap.bmHeight; <br>    bi.biPlanes             = 1; <br>    bi.biBitCount           = NewBPP; <br>    bi.biCompression        = NewComp; <br>    bi.biSizeImage          = 0; <br>    bi.biXPelsPerMeter      = 0; <br>    bi.biYPelsPerMeter      = 0; <br>    bi.biClrUsed            = 0; <br>    bi.biClrImportant       = 0; <br> <br>    // Go allocate room for the new DIB <br> <br>    hNewDIB = AllocRoomForDIB(bi, hBitmap); <br>    if (!hNewDIB) <br>        return NULL; <br> <br>    // Get a pointer to the new DIB <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB); <br> <br>    // If we have a palette, get a DC and select/realize it <br> <br>    if (hPal) <br>    { <br>        hDC  = GetDC(NULL); <br>        hOldPal = SelectPalette(hDC, hPal, FALSE); <br>        RealizePalette(hDC); <br>    } <br> <br>    // Call GetDIBits and get the new DIB bits <br> <br>    if (!GetDIBits(hDC, hBitmap, 0, (UINT) lpbi-&gt;biHeight, (LPSTR)lpbi + <br>            (WORD)lpbi-&gt;biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi, <br>            DIB_RGB_COLORS)) <br>    { <br>        GlobalUnlock(hNewDIB); <br>        GlobalFree(hNewDIB); <br>        hNewDIB = NULL; <br>    } <br> <br>    // Clean up and return <br> <br>    if (hOldPal) <br>    { <br>        SelectPalette(hDC, hOldPal, TRUE); <br>        RealizePalette(hDC); <br>        ReleaseDC(NULL, hDC); <br>    } <br> <br>    // Unlock the new DIB's memory block <br> <br>    if (hNewDIB) <br>        GlobalUnlock(hNewDIB); <br> <br>    return hNewDIB; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
