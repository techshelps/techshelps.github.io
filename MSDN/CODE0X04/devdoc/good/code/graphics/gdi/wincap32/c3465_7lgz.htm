<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLGOPEN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3473"></a>DLGOPEN.C</h2>
<pre><code>//************************************************************************** <br>// <br>// MODULE  : DLGOPEN.C  <br>// <br>// Routine to display a standard COMMDLG File/Save dialog box. <br>// <br>// Defines the following functions: <br>//  <br>// GetFileName()     - Calls up common dialog file/save, and returns <br>//                     selected file <br>// <br>// Written by Microsoft Product Support Services, Developer Support. <br>// Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>//**************************************************************************/ <br> <br>#define     STRICT      // enable strict type checking <br> <br>#include &lt;windows.h&gt; <br>#include "wincap.h" <br>#include "dialogs.h" <br>#include "resource.h" <br>#include "commdlg.h"  // For common dialogs <br>#include "dlgs.h"     // For common dialog hook proc <br> <br>#define MAXFILENAMELEN 144 <br> <br>extern HANDLE ghInst; <br>extern UINT   guiFileOKMsg;       // for common dialog FILEOKSTRING <br> <br>BOOL APIENTRY FileSaveHookProc (HWND hDlg, WORD msg, WORD wParam, LONG lParam); <br> <br>//************************************************************************ <br>// Function:  GetFileName (HWND, LPSTR, LPDWORD) <br>// <br>//   Purpose:  Prompts user for a filename through the use of a Windows 3.1 <br>//             FileOpen common dialog box. <br>// <br>//Parameters:  HWND hWndOwner      Owner who is calling this funciton <br>// <br>//             LPSTR szFileName    Buffer where selected filename will <br>//                                 be placed.  Must be at least MAXFILENAMELEN <br>//                                 characters large <br>// <br>//             LPDWORD dwFlags     HIWORD is the bits per pixel, LOWORD <br>//                                 is compression type. <br>// <br>//   Returns:  TRUE if a filename is selected. <br>//             FALSE if no filename is selected. <br>// <br>//  Comments:  Filename is put into the string passed to the routine. <br>//             If a filename is not selected, NULL is returned. <br>// <br>//************************************************************************/ <br> <br>BOOL GetFileName (HWND hWndOwner, LPSTR szFileName, LPDWORD dwFlags) <br>{ <br>    OPENFILENAME   of; <br>    DWORD          flags; <br>    static char    szTitle[50];         // Dialog Box title <br>    static char    szFile[MAXFILENAMELEN];         // File name <br>    DWORD          dw = 0;               // Local copy of flags for validation <br>    BOOL           bReturn;             // Return code <br>    DWORD          dwLocalOpt; <br>    CHAR           lpBuffer[128];       // Holds strings retrieved from resources <br> <br>    // Parameter validation -- try to recover gracefully if LPWORD <br>    // is NULL, so we don't die when we try to do a *wFlags = x below <br> <br>    if (dwFlags == NULL) <br>        dwFlags = &amp;dw; <br> <br>    dwLocalOpt = *dwFlags;  // Make local copy of options <br> <br>    // Initialize the OPENFILENAME members <br> <br>    lstrcpy(szFile, "*.BMP"); <br> <br>    LoadString(ghInst, IDS_SAVEASTITLE, (LPSTR)szTitle, 50); <br>    LoadString(ghInst, IDS_SAVEFILTER, lpBuffer, sizeof(lpBuffer)); <br>    flags = OFN_ENABLEHOOK | OFN_ENABLETEMPLATE | OFN_HIDEREADONLY | <br>            OFN_OVERWRITEPROMPT; <br> <br>    of.lStructSize       = sizeof (OPENFILENAME); <br>    of.hwndOwner         = hWndOwner; <br>    of.hInstance         = ghInst; <br>    of.lpstrFilter       = lpBuffer; <br>    of.lpstrCustomFilter = NULL; <br>    of.nMaxCustFilter    = 0L; <br>    of.nFilterIndex      = 1L; <br>    of.lpstrFile         = (LPSTR)szFile; <br>    of.nMaxFile          = MAXFILENAMELEN; <br>    of.lpstrFileTitle    = NULL; <br>    of.nMaxFileTitle     = 0; <br>    of.lpstrInitialDir   = NULL; <br>    of.lpstrTitle        = szTitle; <br>    of.Flags             = flags; <br>    of.nFileOffset       = 0; <br>    of.nFileExtension    = 0; <br>    of.lpstrDefExt       = "bmp"; <br>    of.lpfnHook          = (LPOFNHOOKPROC)FileSaveHookProc; <br>    of.lpTemplateName    = (LPSTR)"FILESAVE"; <br> <br>    // Place our flags in the lCustData parameter <br> <br>    of.lCustData         = dwLocalOpt; <br> <br>    // Call the GetSaveFilename function <br> <br>    if (GetSaveFileName (&amp;of)) <br>    { <br>        // User pressed OK, continue on <br> <br>        bReturn = TRUE; <br> <br>        // Copy filename out <br> <br>        lstrcpy (szFileName, of.lpstrFile); <br> <br>        // Copy flags out <br> <br>        *dwFlags = of.lCustData; <br> <br>    } <br>    else <br>    { <br>        bReturn = FALSE; <br>        szFileName[0] = '\0'; <br>        *dwFlags = 0; <br>    } <br> <br>    return bReturn; <br>} <br> <br> <br>/************************************************************************* <br> <br>  Function:  FileSaveHookProc (HWND, WORD, WORD, LONG) <br> <br>   Purpose:  Hook procedure for FileSave common dialog box. <br> <br>   Returns:  TRUE if message was processed. <br>             FALSE if the system needs to process the message. <br> <br>  Comments: <br> <br>*************************************************************************/ <br> <br>BOOL APIENTRY FileSaveHookProc (HWND hDlg, WORD msg, WORD wParam, LONG lParam) <br>{ <br>    HWND                    hGroup; <br>    RECT                    rect, DlgRect; <br>    static LPOPENFILENAME   lpOpenFn; <br>    static DWORD            dwFlags; <br> <br>    if (wParam == guiFileOKMsg) <br>    { <br>        WORD    biStyle, biBits; <br> <br>        if (SendDlgItemMessage (hDlg, IDD_RGB, BM_GETCHECK, 0, 0L)) <br>            biStyle = IDD_RGB; <br> <br>        else if (SendDlgItemMessage (hDlg, IDD_RLE4, BM_GETCHECK, 0, 0L)) <br>            biStyle = IDD_RLE4; <br> <br>        else  <br>            biStyle = IDD_RLE8; <br> <br>        if (SendDlgItemMessage (hDlg, IDD_1, BM_GETCHECK, 0, 0L)) <br>            biBits = 1; <br> <br>        else if (SendDlgItemMessage (hDlg, IDD_4, BM_GETCHECK, 0, 0L)) <br>            biBits = 4; <br> <br>        else if (SendDlgItemMessage (hDlg, IDD_8, BM_GETCHECK, 0, 0L)) <br>            biBits = 8; <br> <br>        else <br>            biBits = 24; <br> <br>        // Copy result of user input to our lCustData field, which <br>        // will pass it back to the calling function. <br> <br>        lpOpenFn-&gt;lCustData = MAKELONG(biStyle, biBits); <br>        return FALSE; <br>    } <br> <br>    switch (msg) <br>    { <br>        case WM_INITDIALOG: <br> <br>            //  Get the memory handle stored in the extra words. <br>            //  From this, insert the filename, and the file format <br> <br>            // Retrieve flags which we passed in in lCustData <br> <br>            lpOpenFn = (LPOPENFILENAME)lParam; <br>            dwFlags = lpOpenFn-&gt;lCustData;  <br> <br>            // Our dwFlags field contains the following: <br>            // <br>            // HIWORD: Bits per pixel specification.  Should be set to <br>            //    one of the following: 1, 4, 8, or 24 <br>            // <br>            // LOWORD: Compression specification:  Should be set to one of <br>            //    the following:   IDD_RGB, IDD_RLE4, IDD_RLE8 <br> <br>            switch (LOWORD(dwFlags)) <br>            { <br>                case IDD_RGB: <br>                    SendDlgItemMessage (hDlg, IDD_RGB,  BM_SETCHECK, 1, 0L); <br>                    SendMessage (hDlg, WM_COMMAND, IDD_RGB, 0L); <br>                    break; <br> <br>                case IDD_RLE4: <br>                    SendDlgItemMessage (hDlg, IDD_RLE4, BM_SETCHECK, 1, 0L); <br>                    SendMessage (hDlg, WM_COMMAND, IDD_RLE4, 0L); <br>                    break; <br> <br>                case IDD_RLE8: <br> <br>                default: <br>                    SendDlgItemMessage (hDlg, IDD_RLE8, BM_SETCHECK, 1, 0L); <br>                    SendMessage (hDlg, WM_COMMAND, IDD_RLE8, 0L); <br>                    break; <br>            } <br> <br>            switch (HIWORD(dwFlags)) <br>            { <br>                case 4: <br>                    SendDlgItemMessage (hDlg, IDD_4,   BM_SETCHECK, 1, 0L); <br>                    break; <br> <br>                case 8: <br>                    SendDlgItemMessage (hDlg, IDD_8,   BM_SETCHECK, 1, 0L); <br>                    break; <br> <br>                case 24: <br>                    SendDlgItemMessage (hDlg, IDD_24,  BM_SETCHECK, 1, 0L); <br>                    break; <br> <br>                case 1: <br> <br>                default: <br>                    SendDlgItemMessage (hDlg, IDD_1,   BM_SETCHECK, 1, 0L); <br>                    break; <br>            } <br> <br>            // Return 1 so Windows sets focus on a control in our dialog. <br> <br>            return 1; <br> <br>        case WM_COMMAND: <br>            switch (wParam) <br>            { <br>             <br>            case IDD_FILETYPE: <br>                hGroup = GetDlgItem (hDlg, IDD_FILETYPEGROUP); <br>                GetWindowRect (hGroup, &amp;rect); <br>                GetWindowRect (hDlg, &amp;DlgRect); <br>                SetWindowPos (hDlg,0, DlgRect.left, DlgRect.top, <br>                        (DlgRect.right-DlgRect.left), <br>                        (rect.bottom+(rect.left-DlgRect.left)-DlgRect.top), <br>                        SWP_NOMOVE | SWP_NOZORDER); <br>                EnableWindow (GetDlgItem (hDlg, IDD_FILETYPE), 0); <br>                SetFocus (hGroup); <br>                break; <br> <br>            case IDD_RLE4: <br>                if (SendDlgItemMessage (hDlg, IDD_1, BM_GETCHECK, 0, 0L)) <br>                    SendDlgItemMessage (hDlg, IDD_1, BM_SETCHECK, 0,0L); <br>                if (SendDlgItemMessage (hDlg, IDD_8, BM_GETCHECK, 0, 0L)) <br>                    SendDlgItemMessage (hDlg, IDD_8, BM_SETCHECK, 0,0L); <br>                if (SendDlgItemMessage (hDlg, IDD_24, BM_GETCHECK, 0, 0L)) <br>                    SendDlgItemMessage (hDlg, IDD_24, BM_SETCHECK, 0,0L); <br> <br>                EnableWindow (GetDlgItem(hDlg, IDD_4), 1); <br>                SendDlgItemMessage (hDlg, IDD_4, BM_SETCHECK, 1, 0L); <br>                EnableWindow (GetDlgItem(hDlg, IDD_1), 0); <br>                EnableWindow (GetDlgItem(hDlg, IDD_8), 0); <br>                EnableWindow (GetDlgItem(hDlg, IDD_24), 0); <br>                break; <br> <br>            case IDD_RLE8: <br>                if (SendDlgItemMessage (hDlg, IDD_1, BM_GETCHECK, 0, 0L)) <br>                    SendDlgItemMessage (hDlg, IDD_1, BM_SETCHECK, 0,0L); <br>                if (SendDlgItemMessage (hDlg, IDD_4, BM_GETCHECK, 0, 0L)) <br>                    SendDlgItemMessage (hDlg, IDD_4, BM_SETCHECK, 0,0L); <br>                if (SendDlgItemMessage (hDlg, IDD_24, BM_GETCHECK, 0, 0L)) <br>                    SendDlgItemMessage (hDlg, IDD_24, BM_SETCHECK, 0,0L); <br> <br>                EnableWindow (GetDlgItem(hDlg, IDD_8), 1); <br>                SendDlgItemMessage (hDlg, IDD_8, BM_SETCHECK, 1, 0L); <br>                EnableWindow (GetDlgItem(hDlg, IDD_1), 0); <br>                EnableWindow (GetDlgItem(hDlg, IDD_4), 0); <br>                EnableWindow (GetDlgItem(hDlg, IDD_24), 0); <br>                break; <br> <br>            case IDD_RGB: <br>                EnableWindow (GetDlgItem(hDlg, IDD_1), 1); <br>                EnableWindow (GetDlgItem(hDlg, IDD_4), 2); <br>                EnableWindow (GetDlgItem(hDlg, IDD_8), 3); <br>                EnableWindow (GetDlgItem(hDlg, IDD_24), 1); <br>                break; <br> <br>            break; <br>        } <br>         <br>        default: <br>            break; <br>    } <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
