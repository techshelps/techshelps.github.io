<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TRACK.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3488"></a>TRACK.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  track.c -- support for direct manipulation of parallelogram object. <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;math.h&gt; <br>#include "track.h" <br> <br>#define EPSILON  (float) 0.0001 <br>#define RECTSIZE  60 <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  doTrackObject() <br>* <br>*  input parameters: <br>*   pto -  pointer to a track object. <br>*   msg -  message selecting what action to take.  Values may include WM_*'s <br>*           (see case statements below for more information.) <br>*   hwnd - Window handle for the window the track object exists within. <br>*   lParam - Usually fourth param to window proc. varies based on msg. <br>* <br>*  global variables:  none. <br>* <br>*  coordinate spaces:  There are three coordinate spaces of interest here, <br>*   and this routine is frequently switching between them... <br>* <br>*           WORLD                   DEVICE                  SCREEN <br>* <br>*      object coordinates       input mouse pos       used w/ SetCursorPos() <br>*         (pto-&gt;rect)          (lParam for WM_*) <br>* <br>*             -----&gt;  LPtoDP() ----&gt;    ----&gt; ClientToScreen() --&gt; <br>*             &lt;-----  DPtoLP() &lt;----    &lt;---- ScreenToClient() &lt;-- <br>* <br>*   in addition, the HDC has an offset origin.  Device coordinates for the <br>*   mouse (lParam) never take this into account, but it is necessary to <br>*   translate them in order to get direct manipulation right. <br>* <br>\**************************************************************************/ <br>PTrackObject doTrackObject(PTrackObject pto, int msg, HWND hwnd, LONG lParam) <br>{ <br>  if ((pto == NULL) &amp;&amp; (msg != TROB_NEW))  return NULL; <br> <br>  switch (msg) { <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_NEW <br>    * <br>    * Allocate new PTrackObject structure.  Fill in default values <br>    *  for the fields of the structure.  Set up the HDC correctly. <br>    * return - pointer to the new object. <br>    \**********************************************************************/ <br>    case  TROB_NEW: { <br>        PTrackObject  pto; <br> <br>        /* with LPTR returned value is a pointer. */ <br>        pto = (PTrackObject) LocalAlloc (LPTR, sizeof (TrackObject)); <br> <br>        /* initialize the HDC and other fields. */ <br>        pto-&gt;hdc = GetDC (hwnd); <br>        SetGraphicsMode (pto-&gt;hdc, GM_ADVANCED); <br>        SetROP2(pto-&gt;hdc, R2_NOT); <br>        SelectObject (pto-&gt;hdc, GetStockObject (NULL_BRUSH)); <br>        pto-&gt;Mode = TMNONE; <br>        pto-&gt;allowedModes = TMMOVE | TMSIZEXY; <br> <br>        GetWorldTransform (pto-&gt;hdc, &amp;(pto-&gt;xfmChange)); <br> <br>        /* initialize the size. */ <br>        pto-&gt;rect.top = pto-&gt;rect.left = 0; <br>        pto-&gt;rect.bottom = pto-&gt;rect.right = RECTSIZE; <br> <br>        return (pto); <br>    } <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_DELETE <br>    * <br>    * Complement of TROB_NEW.  Free up the memory allocated for the object. <br>    \**********************************************************************/ <br>    case  TROB_DELETE: <br>        doTrackObject (pto, TROB_PAINT, hwnd, lParam); <br>        ReleaseDC (hwnd, pto-&gt;hdc); <br>        LocalFree (LocalHandle ((LPSTR)pto)); <br>    return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_PAINT <br>    * <br>    * Paint the object into its hdc.  Called half the time to erase <br>    *  the object, and half the time to redraw it. <br>    \**********************************************************************/ <br>    case TROB_PAINT: { <br>        MoveToEx (pto-&gt;hdc, pto-&gt;rect.right, pto-&gt;rect.top, NULL); <br>        LineTo (pto-&gt;hdc,  pto-&gt;rect.left, pto-&gt;rect.top); <br>        LineTo (pto-&gt;hdc,  pto-&gt;rect.left, pto-&gt;rect.bottom); <br> <br>        if (pto-&gt;allowedModes &amp; TMSIZEXY) { <br>          LineTo (pto-&gt;hdc,  pto-&gt;rect.right, pto-&gt;rect.bottom); <br>          LineTo (pto-&gt;hdc,  pto-&gt;rect.right, pto-&gt;rect.top); <br>        } <br> <br>        if (pto-&gt;allowedModes &amp; TMROTATE) { <br>          MoveToEx (pto-&gt;hdc, pto-&gt;rect.left, pto-&gt;rect.bottom/ 4, NULL); <br>          AngleArc (pto-&gt;hdc, pto-&gt;rect.left, pto-&gt;rect.top, <br>                 (DWORD) pto-&gt;rect.bottom/ 4, (float) 270.0, (float) 90.0); <br>        } <br> <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_HITTEST <br>    * <br>    * Check the point sent in in the lParam to see if it lays within <br>    *  the bounds of the objects defining rectangle. <br>    * return - pointer to the object iff the point is in rectangle, <br>    *  otherwise return NULL. <br>    \**********************************************************************/ <br>    case TROB_HITTEST:{ <br>        POINT  mouWorld; <br>        mouWorld.x = LOWORD(lParam); <br>        mouWorld.y = HIWORD(lParam); <br> <br>        DPtoLP (pto-&gt;hdc, &amp;mouWorld, 1); <br> <br>        if (PtInRect (&amp;pto-&gt;rect, mouWorld))  return pto; <br>        else  return NULL; <br>    } <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONDOWN &amp;  WM_RBUTTONDOWN <br>    * <br>    * Capture the mouse, set the tracking mode depending on the mouse <br>    *  location in world coordinates, reset the mouse position. <br>    * <br>    \**********************************************************************/ <br>    case WM_LBUTTONDOWN: <br>    case WM_RBUTTONDOWN: { <br>      POINT  newmouScreen; <br>      POINT  mouWorld; <br> <br>      mouWorld.x = LOWORD(lParam); <br>      mouWorld.y = HIWORD(lParam); <br>      DPtoLP (pto-&gt;hdc, &amp;mouWorld, 1); <br> <br>      /* upper left hand corner. right button is no-op. */ <br>      if ((mouWorld.x &lt;= (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &lt;= (pto-&gt;rect.bottom / 2))) { <br>          if (msg == WM_RBUTTONDOWN) return NULL; <br>          pto-&gt;Mode = TMMOVE; <br>          newmouScreen.x = pto-&gt;rect.left; <br>          newmouScreen.y = pto-&gt;rect.top; <br> <br>      /* lower left hand corner */ <br>      } else if ((mouWorld.x &lt;= (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &gt; (pto-&gt;rect.bottom / 2))) { <br> <br>          pto-&gt;Mode = (msg == WM_RBUTTONDOWN) ? TMSHEARY : TMSIZEY; <br>          newmouScreen.x = pto-&gt;rect.left; <br>          newmouScreen.y = pto-&gt;rect.bottom; <br> <br>      /* upper right hand corner */ <br>      } else if ((mouWorld.x &gt; (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &lt;= (pto-&gt;rect.bottom / 2))) { <br> <br>          pto-&gt;Mode = (msg == WM_RBUTTONDOWN) ? TMSHEARX : TMSIZEX; <br>          newmouScreen.x = pto-&gt;rect.right; <br>          newmouScreen.y = pto-&gt;rect.top; <br> <br>      /* lower right hand corner */ <br>      } else if ((mouWorld.x &gt; (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &gt; (pto-&gt;rect.bottom / 2))) { <br> <br>          pto-&gt;Mode = (msg == WM_RBUTTONDOWN) ? TMROTATE : TMSIZEXY; <br>          newmouScreen.x = pto-&gt;rect.right; <br>          newmouScreen.y = pto-&gt;rect.bottom; <br>      } <br> <br>      if (! (pto-&gt;Mode &amp; pto-&gt;allowedModes)) { <br>        pto-&gt;Mode = TMNONE; <br>        return NULL; <br>      } <br> <br>      SetCapture(hwnd); <br>      LPtoDP (pto-&gt;hdc, &amp;newmouScreen, 1); <br>      ClientToScreen (hwnd, &amp;newmouScreen); <br>      SetCursorPos (newmouScreen.x,newmouScreen.y); <br> <br>      GetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmDown); <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_MOUSEMOVE <br>    * <br>    * this is where almost all of the interesting calculation is done. <br>    *  First clip the mouse location to be in rectClip, then <br>    *  call MouseMove() to handle the different tracking modes. <br>    \**********************************************************************/ <br>    case WM_MOUSEMOVE: { <br>      if ((short) LOWORD(lParam) &lt; (short)pto-&gt;rectClip.left) <br>        lParam = MAKELONG ((WORD)pto-&gt;rectClip.left, HIWORD(lParam)); <br> <br>      if (LOWORD(lParam) &gt; (WORD)pto-&gt;rectClip.right) <br>        lParam = MAKELONG ((WORD)pto-&gt;rectClip.right, HIWORD(lParam)); <br> <br>      if ((short) HIWORD(lParam) &lt; (short)pto-&gt;rectClip.top) <br>        lParam = MAKELONG (LOWORD(lParam), (WORD)pto-&gt;rectClip.top); <br> <br>      if (HIWORD(lParam) &gt; (WORD)pto-&gt;rectClip.bottom) <br>        lParam = MAKELONG (LOWORD(lParam),(WORD)pto-&gt;rectClip.bottom); <br> <br>      MouseMove (pto, msg, hwnd, lParam); <br> <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_RBUTTONUP &amp; WM_LBUTTONUP <br>    * <br>    * simply release the mouse capture, and set the mode to TMNONE. <br>    \**********************************************************************/ <br>    case WM_RBUTTONUP: <br>    case WM_LBUTTONUP: { <br>      if (pto-&gt;Mode) { <br>         ReleaseCapture(); <br>         pto-&gt;Mode = TMNONE; <br>      } <br>    } return NULL; <br> <br>  }  /* end switch(msg) */ <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  MouseMove() <br>* <br>*  input parameters: <br>*   pto -  pointer to a track object. <br>*   msg -  not used. <br>*   hwnd - Window handle for the window the track object exists within. <br>*   lParam - Usually fourth param to window proc. varies based on msg. <br>* <br>*  The tracking behavior which the user observers when moving the mouse <br>*   is based on the current tracking mode of the object.  This is usually <br>*   determined on the mouse down event (c.f. TM*).  First erase the old <br>*   object, then figure out the change to the transform matrix, finally <br>*   change the world transform matrix and redraw the object. <br>* <br>*  Tranform: <br>*    (    eM11        eM12        0   ) <br>*    (    eM21        eM22        0   ) <br>*    (    eDx         eDy         1   ) <br>* <br>*   xDevice = (xWorld * eM11) + (yWorld * eM21) + eDx <br>*   yDevice = (xWorld * eM12) + (yWorld * eM22) + eDy <br>* <br>*   In this routine the Device (mouse location) and World (rectangle corner) <br>*   points are known.  Therefore, the two equations above are solved for <br>*   the desired matrix entry value (e.g. eM11, 1M12, ... eDy).  The tracking <br>*   mode determines which one of these entries may be changed.  E.g. scaling <br>*   in X modifies eM11 while shearing in X modifies eM12.  So rather than <br>*   using the world transform to map from world to device points, we are <br>*   back-computing the proper contents of the world transform. <br>* <br>\**************************************************************************/ <br>VOID MouseMove(PTrackObject pto, int msg, HWND hwnd, LONG lParam) <br>{ <br>POINT  mouWorld, mouDevice, orgDevice; <br> <br>    UNREFERENCED_PARAMETER(msg); <br> <br>    doTrackObject(pto, TROB_PAINT, hwnd, lParam); <br>    mouDevice.x = mouWorld.x = LOWORD(lParam); <br>    mouDevice.y = mouWorld.y = HIWORD(lParam); <br> <br>    SetWorldTransform(pto-&gt;hdc, &amp;pto-&gt;xfmDown); <br>    DPtoLP (pto-&gt;hdc, &amp;mouWorld, 1); <br> <br>    /* offset the mouse device point for the viewport's origin. */ <br>    GetViewportOrgEx (pto-&gt;hdc, &amp;orgDevice); <br>    mouDevice.x -= orgDevice.x; <br>    mouDevice.y -= orgDevice.y; <br> <br>    GetWorldTransform(pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br> <br>    switch (pto-&gt;Mode) { <br>      /*******************************************************\ <br>      *    (     1         xShear       0   ) <br>      *    (     0           1          0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * xWorld = rect.left == 0; <br>      \*******************************************************/ <br>      case TMSHEARX: { <br>        pto-&gt;xfmChange.eM12 = (float) mouDevice.y; <br>        pto-&gt;xfmChange.eM12 -=pto-&gt;xfmChange.eDy; <br>        pto-&gt;xfmChange.eM12 /=(float) pto-&gt;rect.right ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (     1           0          0   ) <br>      *    (   yShear        1          0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * yWorld = rect.top == 0; <br>      \*******************************************************/ <br>      case TMSHEARY: { <br>        pto-&gt;xfmChange.eM21 = (float) mouDevice.x; <br>        pto-&gt;xfmChange.eM21 -=pto-&gt;xfmChange.eDx; <br>        pto-&gt;xfmChange.eM21 /=(float) pto-&gt;rect.bottom ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br> <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (   cos(a)      -sin(a)      0   ) <br>      *    (   sin(a)       cos(a)      0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * a == rotation angle.  Since mouse in in lower right, <br>      *  we need to shift this back 45 degrees (assuming that <br>      *  straight down is 0 degrees).  Thus we actually compute <br>      *  cos(a) = cos(b - 45) = cos(b)sin(45) + cos(45)sin(45) <br>      *  where b is angle from the origin to the mouse (x,y) <br>      *  cos(45) = sin(45) ~= 0.707107 <br>      *  cos(b) = y/r    sin(b) = x/r <br>      * <br>      \*******************************************************/ <br>      case TMROTATE: { <br>        float r; <br> <br>        /* translate back to the origin. */ <br>        pto-&gt;xfmChange.eDx = pto-&gt;xfmChange.eDy = (float)0.0; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br> <br>        /* rotate about the origin. */ <br>        r = (float) sqrt( (double)(mouWorld.x * mouWorld.x) + <br>                          (double)(mouWorld.y * mouWorld.y)); <br> <br>        pto-&gt;xfmChange.eM11 = (float) mouWorld.y / r; <br>        pto-&gt;xfmChange.eM11 += (float) mouWorld.x / r; <br>        pto-&gt;xfmChange.eM11 *= (float) 0.707107; <br>        pto-&gt;xfmChange.eM22 = pto-&gt;xfmChange.eM11; <br> <br>        pto-&gt;xfmChange.eM12 = (float) mouWorld.y / r; <br>        pto-&gt;xfmChange.eM12 -= (float) mouWorld.x / r; <br>        pto-&gt;xfmChange.eM12 *= (float) 0.707107; <br>        pto-&gt;xfmChange.eM21 = -pto-&gt;xfmChange.eM12; <br> <br>        pto-&gt;xfmChange.eDx = pto-&gt;xfmChange.eDy = (float)0.0; <br> <br>        ModifyWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange, MWT_RIGHTMULTIPLY); <br> <br>        /* translate back to the original offset. */ <br>        pto-&gt;xfmChange.eM11 = <br>        pto-&gt;xfmChange.eM22 = (float) 1.0; <br>        pto-&gt;xfmChange.eM12 = <br>        pto-&gt;xfmChange.eM21 = (float) 0.0; <br> <br>        pto-&gt;xfmChange.eDx = pto-&gt;xfmDown.eDx; <br>        pto-&gt;xfmChange.eDy = pto-&gt;xfmDown.eDy; <br>        ModifyWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange, MWT_RIGHTMULTIPLY); <br>        GetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (  Size X         0          0   ) <br>      *    (     0        Size Y        0   ) <br>      *    (     0           0          1   ) <br>      * <br>      \*******************************************************/ <br>      case TMSIZEXY: { <br>        pto-&gt;xfmChange.eM11 = (float) mouDevice.x; <br>        pto-&gt;xfmChange.eM11 -=pto-&gt;xfmChange.eDx; <br>        pto-&gt;xfmChange.eM11 -=((float) pto-&gt;rect.bottom*pto-&gt;xfmChange.eM21); <br>        pto-&gt;xfmChange.eM11 /=(float) pto-&gt;rect.right ; <br>        if (fabs(pto-&gt;xfmChange.eM11) &lt; EPSILON)  // HACK.  system bug ? <br>           pto-&gt;xfmChange.eM11 = EPSILON; <br> <br>        pto-&gt;xfmChange.eM22 = (float) mouDevice.y; <br>        pto-&gt;xfmChange.eM22 -=pto-&gt;xfmChange.eDy; <br>        pto-&gt;xfmChange.eM22 -=((float) pto-&gt;rect.right*pto-&gt;xfmChange.eM12); <br>        pto-&gt;xfmChange.eM22 /=(float) pto-&gt;rect.bottom ; <br>        if (fabs(pto-&gt;xfmChange.eM22) &lt; EPSILON)  // HACK.  system bug ? <br>           pto-&gt;xfmChange.eM22 = EPSILON; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (  Size X         0          0   ) <br>      *    (     0           1          0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * yWorld = rect.top == 0; <br>      \*******************************************************/ <br>      case TMSIZEX: { <br>        pto-&gt;xfmChange.eM11 = (float) mouDevice.x; <br>        pto-&gt;xfmChange.eM11 -=pto-&gt;xfmChange.eDx; <br>        pto-&gt;xfmChange.eM11 /=(float) pto-&gt;rect.right ; <br>        if (fabs(pto-&gt;xfmChange.eM11) &lt; EPSILON)  // HACK.  system bug ? <br>           pto-&gt;xfmChange.eM11 = EPSILON; <br> <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (     1           0          0   ) <br>      *    (     0        Size Y        0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * xWorld = rect.left == 0; <br>      \*******************************************************/ <br>      case TMSIZEY: { <br>        pto-&gt;xfmChange.eM22 = (float) mouDevice.y; <br>        pto-&gt;xfmChange.eM22 -=pto-&gt;xfmChange.eDy; <br>        pto-&gt;xfmChange.eM22 /=(float) pto-&gt;rect.bottom ; <br>        if (fabs(pto-&gt;xfmChange.eM22) &lt; EPSILON)  // HACK.  system bug ? <br>           pto-&gt;xfmChange.eM22 = EPSILON; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (     1           0          0   ) <br>      *    (     0           1          0   ) <br>      *    (   Move x      Move y       1   ) <br>      * <br>      * xWorld = rect.left == 0; <br>      * yWorld = rect.top == 0; <br>      \*******************************************************/ <br>      case TMMOVE: { <br>        pto-&gt;xfmChange.eDx = (float) mouDevice.x ; <br>        pto-&gt;xfmChange.eDy = (float) mouDevice.y ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br>    } /* end switch */ <br> <br>    doTrackObject(pto, TROB_PAINT, hwnd, lParam); <br> <br>    return; <br> } </code></pre>
<p>&nbsp;</p></body>
</HTML>
