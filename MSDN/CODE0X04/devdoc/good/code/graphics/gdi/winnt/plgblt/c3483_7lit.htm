<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PLGBLT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3485"></a>PLGBLT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  plgblt.c -- sample program demonstrating the new PlgBlt() API. <br>* <br>*  design:  There is one main window with one dialog box stretched to fill <br>*   the top of it.  The parameters for the plgblt painted into the main <br>*   window are stored in the entry fields of this dialog box.  The user <br>*   may change these values and see the effect on the blt. <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "plgblt.h" <br>#include "track.h" <br>#include "bitmap.h" <br> <br> <br> <br>/* global variables. */ <br>PTrackObject ptoDest, ptoSrc, ptoMask = NULL; <br>HDC          hdcDest, hdcSrc, hdcMask; <br>HBITMAP               hbmSrc, hbmMask = NULL; <br> <br>HANDLE hInst; <br>HWND   hwndMain, hwndDlg; <br> <br>int nSpin; <br> <br> <br>#define  BACKGROUNDBRUSH GetStockObject(LTGRAY_BRUSH) <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  WinMain() <br>* <br>*  input parameters:  c.f. generic sample <br>* <br>\**************************************************************************/ <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                     LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG   msg; <br>    RECT rect; <br>    HANDLE haccel; <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br> <br>    // <br>    // Detect platform and exit gracefully if not Windows NT. <br>    // <br> <br>    { <br>      OSVERSIONINFO osvi; <br>      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); <br> <br>      GetVersionEx (&amp;osvi); <br>      if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) { <br>        MessageBox (NULL, <br>          GetStringRes (IDS_NTONLY), <br>          "PlgBlt", MB_OK | MB_ICONSTOP); <br>        return 0; <br>      } <br>    } <br> <br> <br>    /* Check for previous instance.  If none, then register class. */ <br>    if (!hPrevInstance) { <br>        WNDCLASS  wc; <br> <br>        wc.style = 0; <br>        wc.lpfnWndProc = (WNDPROC)MainWndProc; <br> <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = hInstance; <br>        wc.hIcon = LoadIcon(hInstance, "plgbltIcon"); <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = BACKGROUNDBRUSH; <br>        wc.lpszMenuName =  "plgbltMenu"; <br>        wc.lpszClassName = "plgblt"; <br> <br>        if (!RegisterClass(&amp;wc)) return (FALSE); <br>    }  /* class registered o.k. */ <br> <br> <br>    /* Create the main window.  Return false if CreateWindow() fails */ <br>    hInst = hInstance; <br> <br>    hwndMain = CreateWindow( <br>        "plgblt", <br>        GetStringRes (IDS_WINDOWTITLE), <br>        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL); <br> <br>    if (!hwndMain) return (FALSE); <br> <br> <br>    /* create the top dialog as a child of the main window. */ <br>    hwndDlg = CreateDialog (hInst, "plgbltDlg", hwndMain, (DLGPROC)DlgProc); <br> <br>    /* Send main window a WM_SIZE message so that it will size the top <br>     *  dialog correctly. <br>     */ <br>    GetClientRect (hwndMain, &amp;rect); <br>    SendMessage (hwndMain, WM_SIZE, 0, (rect.right - rect.left)); <br>    ShowWindow (hwndDlg, SW_SHOW); <br>    ShowWindow(hwndMain, nCmdShow); <br> <br> <br>    /* get global handle to the menu */ <br> <br>    /* Load the accelerator table that provides clipboard support. */ <br>    haccel = LoadAccelerators (hInst, "bltAccel"); <br> <br> <br> <br>    /* Loop getting messages and dispatching them. */ <br>    while (GetMessage(&amp;msg,NULL, 0,0)) { <br>      if (!TranslateAccelerator(hwndMain, haccel, &amp;msg)) <br>      if (!IsDialogMessage (hwndDlg, &amp;msg)){ <br>        DispatchMessage(&amp;msg); <br>      } <br> <br>      /* if no messages, and we are spinning, then post spin message. */ <br>      if (!PeekMessage (&amp;msg, hwndMain, 0,0, PM_NOREMOVE) &amp;&amp; nSpin) <br>        PostMessage (hwndMain, WM_SPIN, 0,0); <br>    } <br> <br>    /* Return the value from PostQuitMessage */ <br>    return (msg.wParam); <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  MainWndProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  There are 6 different HDCs used for the main window (in addition to the <br>*   temporary one returned from BeginPaint).  There are two for each of the <br>*   three thirds of the window.  The first one contains the bitmap.  The <br>*   second one is for the track object and is stored in the TRACKOBJECT <br>*   structure. <br>* <br>*  global variables: <br>*   hwndDlg - dialog with entry fields containing parameters. <br>*   ptoDest, ptoSrc, ptoMask - pointers to the direct manipulation objects <br>*   hdcDest, hdcSrc, hdcMask - HDCs for the 3 sub regions of the window. <br>*   hbmSrc, hbmMask          - bitmap handles for source and mask. <br>\**************************************************************************/ <br>LRESULT CALLBACK MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>static int miniWidth; <br>static RECT rect; <br>static HANDLE hPenGrid, hPenSeparator; <br> <br>  switch (message) { <br> <br>    /**********************************************************************\ <br>    *  WM_CREATE <br>    * <br>    * Get three new HDCs, then create three new track objects. <br>    *  Each track object has different allowed tracking modes. <br>    *  Finally create two pens for drawing later on. <br>    \**********************************************************************/ <br>    case WM_CREATE: <br>        hdcSrc  = GetDC (hwnd); <br>        hdcDest = GetDC (hwnd); <br>        hdcMask = GetDC (hwnd); <br> <br>        ptoDest = doTrackObject (NULL, TROB_NEW, hwnd,0); <br>        ptoDest-&gt;allowedModes = TMALL; <br>        ptoSrc  = doTrackObject (NULL, TROB_NEW, hwnd,0); <br>        ptoSrc-&gt;allowedModes = TMMOVE | TMSIZEXY; <br>        ptoMask = doTrackObject (NULL, TROB_NEW, hwnd,0); <br>        ptoMask-&gt;allowedModes = TMMOVE; <br> <br>        hPenGrid      = CreatePen (PS_SOLID, 1, GRIDCOLOR); <br>        hPenSeparator = CreatePen (PS_SOLID, 2*SEPARATORWIDTH, (COLORREF) 0x01000000); <br> <br>        { HMENU hMenu; <br>        hMenu = GetMenu (hwnd); <br>        CheckMenuItem(hMenu, IDM_SPINTOPLEFT, MF_CHECKED); <br>        CheckMenuItem(hMenu, IDM_SPINOFF    , MF_CHECKED); <br>        nSpin = FALSE; <br>        } <br> <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_DESTROY <br>    * <br>    * Complement of WM_CREATE.  Free up all of the HDCs, send all of the <br>    *  track objects their delete messages, delete the pens, <br>    *  then call PostQuitMessage. <br>    \**********************************************************************/ <br>    case WM_DESTROY: <br>        ReleaseDC (hwnd, hdcSrc ); <br>        ReleaseDC (hwnd, hdcDest); <br>        ReleaseDC (hwnd, hdcMask); <br>        doTrackObject (ptoDest, TROB_DELETE, hwnd,0); <br>        doTrackObject (ptoSrc , TROB_DELETE, hwnd,0); <br>        doTrackObject (ptoMask, TROB_DELETE, hwnd,0); <br> <br>        DeleteObject(hPenGrid); <br>        DeleteObject(hPenSeparator); <br> <br>        PostQuitMessage(0); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_SIZE <br>    * <br>    * Stretch the top dialog to fill the width of the main window. <br>    * Adjust the viewport origins of the 6 HDCs. <br>    * Set the clip regions of the 6 HDCs. <br>    \**********************************************************************/ <br>    case WM_SIZE: { <br>        HRGN hrgn; <br> <br>        SetWindowPos (hwndDlg, NULL, 0,0, LOWORD(lParam), DIALOGHEIGHT, 0); <br> <br>        GetClientRect (hwndMain, &amp;rect); <br>        miniWidth = rect.right/3; <br> <br>        SetViewportOrgEx (hdcDest,      0,           DIALOGHEIGHT, NULL); <br>        SetViewportOrgEx (ptoDest-&gt;hdc, 0,           DIALOGHEIGHT, NULL); <br>        SetViewportOrgEx (hdcSrc,       miniWidth,   DIALOGHEIGHT, NULL); <br>        SetViewportOrgEx (ptoSrc-&gt;hdc,  miniWidth,   DIALOGHEIGHT, NULL); <br>        SetViewportOrgEx (hdcMask,      2*miniWidth, DIALOGHEIGHT, NULL); <br>        SetViewportOrgEx (ptoMask-&gt;hdc, 2*miniWidth, DIALOGHEIGHT, NULL); <br> <br>        ptoDest-&gt;rectClip.left    = 0; <br>        ptoDest-&gt;rectClip.top     = DIALOGHEIGHT; <br>        ptoDest-&gt;rectClip.right   = miniWidth-2*SEPARATORWIDTH; <br>        ptoDest-&gt;rectClip.bottom  = rect.bottom; <br>        hrgn = CreateRectRgnIndirect (&amp;ptoDest-&gt;rectClip); <br>        SelectClipRgn (hdcDest,      hrgn); <br>        SelectClipRgn (ptoDest-&gt;hdc, hrgn); <br>        DeleteObject (hrgn); <br> <br>        ptoSrc-&gt;rectClip.left    = miniWidth; <br>        ptoSrc-&gt;rectClip.top     = DIALOGHEIGHT; <br>        ptoSrc-&gt;rectClip.right   = 2*miniWidth-2*SEPARATORWIDTH; <br>        ptoSrc-&gt;rectClip.bottom  = rect.bottom; <br>        hrgn = CreateRectRgnIndirect (&amp;ptoSrc-&gt;rectClip); <br>        SelectClipRgn (hdcSrc,       hrgn); <br>        SelectClipRgn (ptoSrc-&gt;hdc,  hrgn); <br>        DeleteObject (hrgn); <br> <br>        ptoMask-&gt;rectClip.left    = 2*miniWidth; <br>        ptoMask-&gt;rectClip.top     = DIALOGHEIGHT; <br>        ptoMask-&gt;rectClip.right   = 3*miniWidth; <br>        ptoMask-&gt;rectClip.bottom  = rect.bottom; <br>        hrgn = CreateRectRgnIndirect (&amp;ptoMask-&gt;rectClip); <br>        SelectClipRgn (hdcMask,      hrgn); <br>        SelectClipRgn (ptoMask-&gt;hdc, hrgn); <br>        DeleteObject (hrgn); <br> <br>        SendMessage (hwndDlg, WM_PUTUPLPOINTS, (DWORD)hdcDest, (LONG)ptoDest); <br>        SendMessage (hwndDlg, WM_PUTUPSRCRECT, (DWORD)hdcSrc,  (LONG)ptoSrc); <br>        SendMessage (hwndDlg, WM_PUTUPMASKPT,  (DWORD)hdcMask, (LONG)ptoMask); <br> <br>        /* repaint the whole window. */ <br>        InvalidateRect (hwnd, NULL, TRUE); <br>    } break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PAINT <br>    * <br>    * miniWidth, rect -- set by WM_SIZE message. <br>    * <br>    * First shift the viewport origin down so that 0,0 is the top left <br>    *  most visible point (out from underneath the top dialog).  Second, <br>    *  draw the grid with wider lines on the axes.  Finally, read the <br>    *  values out of the top dialog, do elementary validation, and then <br>    *  try to call plgblt() with the values. <br>    \**********************************************************************/ <br>     case WM_PAINT: { <br>        HDC hdc; <br>        PAINTSTRUCT ps; <br> <br>        hdc = BeginPaint(hwnd, &amp;ps); <br> <br>        /* Draw Separator lines for the three miniareas */ <br>        SelectObject(hdc, hPenSeparator); <br>        MoveToEx (hdc,   miniWidth-SEPARATORWIDTH,0, NULL); <br>        LineTo   (hdc,   miniWidth-SEPARATORWIDTH, rect.bottom); <br>        MoveToEx (hdc, 2*miniWidth-SEPARATORWIDTH,0, NULL); <br>        LineTo   (hdc, 2*miniWidth-SEPARATORWIDTH, rect.bottom); <br> <br>        /* Grid the HDCs */ <br>        SelectObject(hdcSrc, hPenGrid); <br>        DrawGrids (hdcSrc, miniWidth, rect.bottom); <br>        SelectObject(hdcMask, hPenGrid); <br>        DrawGrids (hdcMask, miniWidth, rect.bottom); <br> <br>        /* Draw bitmaps if any, then draw track objects over them. */ <br>        if (hbmSrc)  DrawBitmap (hdcSrc, hbmSrc); <br>        if (hbmMask) DrawBitmap (hdcMask, hbmMask); <br>        doTrackObject (ptoSrc , TROB_PAINT, hwnd, 0); <br>        doTrackObject (ptoMask, TROB_PAINT, hwnd, 0); <br> <br>        /* paint the left third of the window. */ <br>        SendMessage (hwnd, WM_PLGBLT, 0,0); <br> <br>        EndPaint (hwnd, &amp;ps); <br>    } return FALSE; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PLGBLT <br>    * <br>    * WM_USER message.  This paints the left third of the window.  It <br>    *  is called on the WM_PAINT message.  It is separated out here because <br>    *  it is common for just the plgblt() to need to be called and not the <br>    *  whole window painted. <br>    \**********************************************************************/ <br>    case WM_PLGBLT: { <br>        POINT lpPoint[3]; <br>        int XSrc, YSrc, nWidth, nHeight, XMask, YMask; <br>        BOOL success; <br>        RECT cliprect; <br> <br>        doTrackObject (ptoSrc , TROB_PAINT, hwnd, 0); <br>        doTrackObject (ptoMask, TROB_PAINT, hwnd, 0); <br> <br>        GetClipBox (hdcDest, &amp;cliprect); <br>        FillRect (hdcDest, &amp;cliprect, <br>                  (HBRUSH) GetClassLong (hwnd, GCL_HBRBACKGROUND)); <br>        SelectObject(hdcDest, hPenGrid); <br> <br>        DrawGrids (hdcDest, miniWidth, rect.bottom); <br>        if (IsWindow(hwndDlg)) { <br> <br>          /* Grab points out of the dialog entry fields. */ <br>          lpPoint[0].x = GetDlgItemInt(hwndDlg, DID_P1X, &amp;success, TRUE); <br>          lpPoint[0].y = GetDlgItemInt(hwndDlg, DID_P1Y, &amp;success, TRUE); <br>          lpPoint[1].x = GetDlgItemInt(hwndDlg, DID_P2X, &amp;success, TRUE); <br>          lpPoint[1].y = GetDlgItemInt(hwndDlg, DID_P2Y, &amp;success, TRUE); <br>          lpPoint[2].x = GetDlgItemInt(hwndDlg, DID_P3X, &amp;success, TRUE); <br>          lpPoint[2].y = GetDlgItemInt(hwndDlg, DID_P3Y, &amp;success, TRUE); <br>          XSrc = GetDlgItemInt(hwndDlg, DID_XSRC, &amp;success, TRUE); <br>          YSrc = GetDlgItemInt(hwndDlg, DID_YSRC, &amp;success, TRUE); <br>          nWidth = GetDlgItemInt(hwndDlg, DID_WIDTH, &amp;success, TRUE); <br>          nHeight = GetDlgItemInt(hwndDlg, DID_HEIGHT, &amp;success, TRUE); <br>          XMask = GetDlgItemInt(hwndDlg, DID_XMASK, &amp;success, TRUE); <br>          YMask = GetDlgItemInt(hwndDlg, DID_YMASK, &amp;success, TRUE); <br> <br> <br>          /**********************************************************/ <br>          /**********************************************************/ <br>          PlgBlt (hdcDest, lpPoint, <br>                  hdcSrc, XSrc, YSrc, nWidth, nHeight, <br>                  hbmMask, XMask, YMask); <br>          /**********************************************************/ <br>          /**********************************************************/ <br>        } <br>        doTrackObject (ptoSrc , TROB_PAINT, hwnd, 0); <br>        doTrackObject (ptoMask, TROB_PAINT, hwnd, 0); <br>    } break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONDOWN &amp; WM_RBUTTONDOWN <br>    * On button down messages, hittest on the track object, and if <br>    *  it returns true, then send these messages to the track object. <br>    \**********************************************************************/ <br>    case WM_RBUTTONDOWN: <br>    case WM_LBUTTONDOWN: <br>      if (doTrackObject(ptoDest, TROB_HITTEST, hwnd, lParam)) <br>         doTrackObject(ptoDest, message, hwnd, lParam); <br>      else if (doTrackObject(ptoSrc, TROB_HITTEST, hwnd, lParam)) <br>         doTrackObject(ptoSrc, message, hwnd, lParam); <br>      else if (doTrackObject(ptoMask, TROB_HITTEST, hwnd, lParam)) <br>         doTrackObject(ptoMask, message, hwnd, lParam); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONUP &amp; WM_RBUTTONDOWN &amp; MW_MOUSEMOVE <br>    * If the track object is in a "tracking mode" then send it these messages. <br>    *  If the transform dialog is not minimized, fill it with numbers. <br>    *  If the mouse dialog is not minimized, fill it with numbers. <br>    \**********************************************************************/ <br>    case WM_RBUTTONUP: <br>    case WM_LBUTTONUP: <br>      /* user action complete.  Force plgblt() update. */ <br>      PostMessage (hwndMain, WM_PLGBLT, 0,0); <br>    case WM_MOUSEMOVE: <br>      if (ptoDest-&gt;Mode) { <br>        doTrackObject(ptoDest, message, hwnd, lParam); <br>        SendMessage (hwndDlg, WM_PUTUPLPOINTS, (DWORD) hdcDest, (LONG) ptoDest); <br>      } <br>      if (ptoSrc-&gt;Mode) { <br>        doTrackObject(ptoSrc, message, hwnd, lParam); <br>        SendMessage (hwndDlg, WM_PUTUPSRCRECT, (DWORD) hdcSrc, (LONG) ptoSrc); <br>      } <br> <br>      if (ptoMask-&gt;Mode) { <br>        doTrackObject(ptoMask, message, hwnd, lParam); <br>        SendMessage (hwndDlg, WM_PUTUPMASKPT, (DWORD) hdcMask, (LONG) ptoMask); <br>      } <br> <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_SETFOCUS <br>    * <br>    * The main window should never have the focus.  Set it back <br>    *  to the top dialog. <br>    \**********************************************************************/ <br>    case WM_SETFOCUS: SetFocus (hwndDlg); <br>        return 0; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  Menu item support. <br>    * <br>    \**********************************************************************/ <br>    case WM_COMMAND: <br>      switch (LOWORD(wParam)) { <br>        HBITMAP hbmCompat, hbmOld; <br>        HDC hdcCompat; <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_COPY <br>        * <br>        * Create a new bitmap, copy the destination HDC bits into it, <br>        *  and send the new bitmap to the clipboard. <br>        \******************************************************************/ <br>        case IDM_COPY: { <br>          int X[4],Y[4]; <br>          int nWidth, nHeight; <br>          int Xmin, Ymin, Xmax, Ymax; <br>          BOOL success; <br>          int i; <br> <br>          for (i = 0; i&lt;3 ; i++) { <br>            X[i] = GetDlgItemInt(hwndDlg, DID_P1X + 2*i, &amp;success, TRUE); <br>            Y[i] = GetDlgItemInt(hwndDlg, DID_P1Y + 2*i, &amp;success, TRUE); <br>          } <br> <br>          X[3] = (X[1] - X[0]) + X[2]; <br>          Y[3] = (Y[2] - Y[0]) + Y[1]; <br> <br>          Xmin = Xmax = X[0]; <br>          Ymin = Ymax = Y[0]; <br> <br>          for (i = 1; i&lt;4 ; i++) { <br>            Xmin = (X[i] &lt; Xmin) ? X[i] : Xmin; <br>            Ymin = (Y[i] &lt; Ymin) ? Y[i] : Ymin; <br>            Xmax = (X[i] &gt; Xmax) ? X[i] : Xmax; <br>            Ymax = (Y[i] &gt; Ymax) ? Y[i] : Ymax; <br>          } <br> <br>          nWidth = Xmax - Xmin; <br>          nHeight = Ymax - Ymin; <br> <br>          hdcCompat = CreateCompatibleDC(hdcDest); <br>          hbmCompat = CreateCompatibleBitmap (hdcDest, nWidth, nHeight); <br>          hbmOld = SelectObject(hdcCompat,hbmCompat); <br> <br>          BitBlt (hdcCompat, 0,0,nWidth, nHeight, hdcDest, Xmin,Ymin, SRCCOPY ); <br> <br>          SelectObject(hdcCompat,hbmOld); <br>          DeleteDC(hdcCompat); <br> <br>          OpenClipboard (hwnd); <br>          SetClipboardData (CF_BITMAP,hbmCompat); <br>          CloseClipboard (); <br> <br>          DeleteObject (hbmCompat); <br> <br>        } break; <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_PASTE <br>        * <br>        * Get bitmap handle from clipboard, create a new bitmap, draw <br>        *  the clipboard bitmap into the new one, and store the new <br>        *  handle in the global hbmSrc. <br>        \******************************************************************/ <br>        case IDM_PASTE: { <br>          HBITMAP hbm; <br>          BITMAP bm; <br> <br>          OpenClipboard (hwnd); <br>          if ( hbm = GetClipboardData (CF_BITMAP)) { <br>            DeleteObject (hbmSrc); <br> <br>            GetObject (hbm, sizeof(BITMAP), &amp;bm); <br> <br>            hdcCompat = CreateCompatibleDC(hdcDest); <br>            hbmCompat = CreateCompatibleBitmap (hdcDest, bm.bmWidth, bm.bmHeight); <br>            hbmOld = SelectObject(hdcCompat,hbmCompat); <br> <br>            DrawBitmap (hdcCompat, hbm); <br> <br>            SelectObject(hdcCompat,hbmOld); <br>            DeleteDC(hdcCompat); <br> <br>            hbmSrc = hbmCompat; <br> <br>            InvalidateRect (hwnd, &amp;ptoSrc-&gt;rectClip, TRUE); <br>            InvalidateRect (hwnd, &amp;ptoDest-&gt;rectClip, TRUE); <br>          } <br>          CloseClipboard (); <br>        } break; <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_BOTH <br>        * <br>        * Post a COPY and PASTE command message to this window so that with <br>        *  one key stroke the user can copy the DEST image into the clipboard, <br>        *  paste it down into the SRC hdc and cause the blt. <br>        \******************************************************************/ <br>        case IDM_BOTH: <br> <br>          PostMessage (hwnd, WM_COMMAND, MAKELONG (IDM_COPY , 1), 0); <br>          PostMessage (hwnd, WM_COMMAND, MAKELONG (IDM_PASTE, 1), 0); <br> <br>        break; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_MODE_* <br>        * <br>        * manage mutually exclusive menu. <br>        *  call SetStretchBltMode() for the global destination hdc. <br>        \******************************************************************/ <br>        case IDM_MODE_BLACKONWHITE: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_MODE_BLACKONWHITE, MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_COLORONCOLOR, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_WHITEONBLACK, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_HALFTONE    , MF_UNCHECKED); <br> <br>          SetStretchBltMode (hdcDest,BLACKONWHITE); <br>          SendMessage (hwndMain, WM_PLGBLT, 0,0); <br> <br>          } return 0; <br> <br>        case IDM_MODE_COLORONCOLOR: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_MODE_BLACKONWHITE, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_COLORONCOLOR, MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_WHITEONBLACK, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_HALFTONE    , MF_UNCHECKED); <br> <br>          SetStretchBltMode (hdcDest,COLORONCOLOR); <br>          SendMessage (hwndMain, WM_PLGBLT, 0,0); <br> <br>          } return 0; <br> <br>        case IDM_MODE_WHITEONBLACK: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_MODE_BLACKONWHITE, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_COLORONCOLOR, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_WHITEONBLACK, MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_HALFTONE    , MF_UNCHECKED); <br> <br>          SetStretchBltMode (hdcDest,WHITEONBLACK); <br>          SendMessage (hwndMain, WM_PLGBLT, 0,0); <br> <br>          } return 0; <br> <br>        case IDM_MODE_HALFTONE    : <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_MODE_BLACKONWHITE, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_COLORONCOLOR, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_WHITEONBLACK, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_MODE_HALFTONE    , MF_CHECKED); <br> <br>          SetStretchBltMode (hdcDest,HALFTONE); <br>          SendMessage (hwndMain, WM_PLGBLT, 0,0); <br> <br>          } return 0; <br> <br> <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_SPIN* <br>        * <br>        * manage mutually exclusive menu. <br>        * <br>        \******************************************************************/ <br>        case IDM_SPINOFF: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINOFF, MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN5  , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN10 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN30 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN60 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN90 , MF_UNCHECKED); <br> <br>          nSpin = FALSE; <br>          SendMessage (hwndMain, WM_PLGBLT, 0,0); <br> <br>          } return 0; <br> <br>        case IDM_SPIN5 : <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINOFF, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN5  , MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN10 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN30 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN60 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN90 , MF_UNCHECKED); <br> <br>          nSpin = 5; <br> <br>          } return 0; <br> <br>        case IDM_SPIN10: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINOFF, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN5  , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN10 , MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN30 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN60 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN90 , MF_UNCHECKED); <br> <br>          nSpin = 10; <br> <br>          } return 0; <br> <br>        case IDM_SPIN30: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINOFF, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN5  , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN10 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN30 , MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN60 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN90 , MF_UNCHECKED); <br> <br>          nSpin = 30; <br> <br>          } return 0; <br> <br>        case IDM_SPIN60: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINOFF, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN5  , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN10 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN30 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN60 , MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN90 , MF_UNCHECKED); <br> <br>          nSpin = 60; <br> <br>          } return 0; <br> <br>        case IDM_SPIN90: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINOFF, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN5  , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN10 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN30 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN60 , MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPIN90 , MF_CHECKED); <br> <br>          nSpin = 90; <br> <br>          } return 0; <br> <br> <br>        case IDM_FLIPONCE: <br>          nSpin = 90; <br>          SendMessage (hwndMain, WM_SPIN, 0,0); <br>          nSpin = FALSE; <br>          return 0; <br> <br> <br> <br>        case IDM_SPINTOPLEFT: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINTOPLEFT, MF_CHECKED); <br>          CheckMenuItem(hMenu, IDM_SPINCENTER , MF_UNCHECKED); <br> <br>          } return 0; <br> <br>        case IDM_SPINCENTER: <br>          { HMENU hMenu; <br>          hMenu = GetMenu (hwnd); <br> <br>          CheckMenuItem(hMenu, IDM_SPINTOPLEFT, MF_UNCHECKED); <br>          CheckMenuItem(hMenu, IDM_SPINCENTER , MF_CHECKED); <br> <br>          } return 0; <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, DID_NEW* <br>        * <br>        * menu equivalents for buttons on top dialog.  Just pass along <br>        *  WM_COMMAND messages to the dialog. <br>        * <br>        \******************************************************************/ <br>        case DID_NEWSRC: <br>        case DID_NEWMASK: <br>          SendMessage (hwndDlg, message, wParam, lParam); <br>        return 0; <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_ABOUT <br>        * <br>        \******************************************************************/ <br>        case IDM_ABOUT: <br>          DialogBox (hInst, "aboutBox", hwnd, (DLGPROC)About); <br>        return 0; <br> <br> <br> <br> <br>      }  /* end switch */ <br> <br>    break;  /* end wm_command */ <br> <br> <br> <br>    /******************************************************************\ <br>    *  WM_SPIN <br>    * <br>    * Set up a transform to modify the destination points. <br>    *  (Note that the transform in hdcDest remains the identity.) <br>    *  Loop through, reblitting to the transformed points. <br>    *  Erase behind the old bitmap by keeping track of the region uncovered. <br>    * <br>    \******************************************************************/ <br>    case WM_SPIN: { <br> <br>      XFORM  x; <br>      HDC hdc; <br>      float M11, M12, M21, M22; <br>      int nSteps, i; <br> <br>      POINT pivot; <br>      POINT lpPoint[3]; <br>      POINT lpRgnErase[4], lpRgnBmp[4]; <br>      HRGN hrgnErase, hrgnBmp; <br>      HMENU hMenu; <br>      int XSrc, YSrc, nWidth, nHeight, XMask, YMask; <br>      BOOL success; <br> <br>      /* validate the dialog on top with the parameters in it. */ <br>      if (!IsWindow(hwndDlg)) return 0; <br> <br>      /* Grab points out of the dialog entry fields. */ <br>      lpPoint[0].x = GetDlgItemInt(hwndDlg, DID_P1X, &amp;success, TRUE); <br>      lpPoint[0].y = GetDlgItemInt(hwndDlg, DID_P1Y, &amp;success, TRUE); <br>      lpPoint[1].x = GetDlgItemInt(hwndDlg, DID_P2X, &amp;success, TRUE); <br>      lpPoint[1].y = GetDlgItemInt(hwndDlg, DID_P2Y, &amp;success, TRUE); <br>      lpPoint[2].x = GetDlgItemInt(hwndDlg, DID_P3X, &amp;success, TRUE); <br>      lpPoint[2].y = GetDlgItemInt(hwndDlg, DID_P3Y, &amp;success, TRUE); <br>      XSrc = GetDlgItemInt(hwndDlg, DID_XSRC, &amp;success, TRUE); <br>      YSrc = GetDlgItemInt(hwndDlg, DID_YSRC, &amp;success, TRUE); <br>      nWidth = GetDlgItemInt(hwndDlg, DID_WIDTH, &amp;success, TRUE); <br>      nHeight = GetDlgItemInt(hwndDlg, DID_HEIGHT, &amp;success, TRUE); <br>      XMask = GetDlgItemInt(hwndDlg, DID_XMASK, &amp;success, TRUE); <br>      YMask = GetDlgItemInt(hwndDlg, DID_YMASK, &amp;success, TRUE); <br> <br> <br>      /* get an HDC we can use to play with transforms. */ <br>      hdc = GetDC (hwnd); <br>      SetGraphicsMode (hdc, GM_ADVANCED); <br> <br> <br> <br>      /* check menu check to pivot on top-left corner, or pivot on center. */ </code></pre>
<p>
</p>
<pre><code>hMenu = GetMenu (hwnd); <br> <br>      if (GetMenuState(hMenu, IDM_SPINCENTER, MF_BYCOMMAND) &amp; MF_CHECKED) { <br>        pivot.x = (lpPoint[1].x +lpPoint[2].x)/2; <br>        pivot.y = (lpPoint[1].y +lpPoint[2].y)/2; <br>      } else { <br>        pivot.x = lpPoint[0].x; <br>        pivot.y = lpPoint[0].y; <br>      } <br> <br>      /* nSpin contains values reflecting the number of degrees per step. <br>       *  fill in the number of steps required (360 / nSpin), and fill in <br>       *  the precomputed transformation matrices. <br>       */ <br>      switch (nSpin) { <br> <br>        case 5: <br>          nSteps = 72; <br>          M11 =                   M22 = (float)0.9961946980917; <br>          M12 = (float)-0.08715574274766; M21 = (float)0.08715574274766; <br>          break; <br>        case 10: <br>          nSteps = 36; <br>          M11 =                   M22 = (float)0.984808; <br>          M12 = (float)-0.173648; M21 = (float)0.173648; <br>          break; <br>        case 30: <br>          nSteps = 12; <br>          M11 =                   M22 = (float)0.866025; <br>          M12 = (float)-0.5     ; M21 = (float)0.5; <br>          break; <br>        case 60: <br>          nSteps = 6; <br>          M11 =                   M22 = (float)0.5     ; <br>          M12 = (float)-0.866025; M21 = (float)0.866025; <br>          break; <br>        case 90: <br>          nSteps = 4; <br>          M11 =                   M22 = (float)0.0; <br>          M12 = (float)-1.0     ; M21 = (float)1.0; <br>          break; <br>        default: <br>          MessageBox (hwnd, <br>                      GetStringRes (IDS_INVALID), <br>                      NULL, MB_ICONHAND); <br>          return 0; <br> <br>      } /* end switch nSpin */ <br> <br> <br> <br> <br>      /* translate objects from pivot point to origin. */ <br>      x.eM11 = (float)1.0; <br>      x.eM12 = (float)0.0; <br>      x.eM21 = (float)0.0; <br>      x.eM22 = (float)1.0; <br>      x.eDx = (float)-pivot.x; <br>      x.eDy = (float)-pivot.y; <br>      ModifyWorldTransform (hdc, &amp;x, MWT_RIGHTMULTIPLY); <br> <br>      /* rotate object about origin. */ <br>      x.eM11 = M11; <br>      x.eM12 = M12; <br>      x.eM21 = M21; <br>      x.eM22 = M22; <br>      x.eDx = (float)0.0; <br>      x.eDy = (float)0.0; <br>      ModifyWorldTransform (hdc, &amp;x, MWT_RIGHTMULTIPLY); <br> <br>      /* translate objects back to pivot point. */ <br>      x.eM11 = (float)1.0; <br>      x.eM12 = (float)0.0; <br>      x.eM21 = (float)0.0; <br>      x.eM22 = (float)1.0; <br>      x.eDx = (float)pivot.x; <br>      x.eDy = (float)pivot.y; <br>      ModifyWorldTransform (hdc, &amp;x, MWT_RIGHTMULTIPLY); <br> <br> <br> <br>      /* fill in initial region for erasure... the region containing bmp */ <br>      lpRgnErase[0] = lpPoint[0]; <br>      lpRgnErase[1] = lpPoint[1]; <br>      lpRgnErase[3] = lpPoint[2]; <br>      lpRgnErase[2].x =  lpPoint[1].x - lpPoint[0].x; <br>      lpRgnErase[2].x += lpPoint[2].x - lpPoint[0].x; <br>      lpRgnErase[2].x += lpPoint[0].x; <br>      lpRgnErase[2].y =  lpPoint[1].y - lpPoint[0].y; <br>      lpRgnErase[2].y += lpPoint[2].y - lpPoint[0].y; <br>      lpRgnErase[2].y += lpPoint[0].y; <br> <br> <br> <br>      /* loop through transforming the points on each step. */ <br>      for (i= 0; i&lt;nSteps; i++) { <br> <br> <br>        hrgnErase = CreatePolygonRgn (lpRgnErase, 4, ALTERNATE); <br> <br>        /* TRANSFORM the lpPoint[] destination extent points */ <br>        LPtoDP (hdc, lpPoint, 3); <br> <br>        /* create a region containing the new bitmap extents */ <br>        lpRgnBmp[0] = lpPoint[0]; <br>        lpRgnBmp[1] = lpPoint[1]; <br>        lpRgnBmp[3] = lpPoint[2]; <br>        lpRgnBmp[2].x =  lpPoint[1].x - lpPoint[0].x; <br>        lpRgnBmp[2].x += lpPoint[2].x - lpPoint[0].x; <br>        lpRgnBmp[2].x += lpPoint[0].x; <br>        lpRgnBmp[2].y =  lpPoint[1].y - lpPoint[0].y; <br>        lpRgnBmp[2].y += lpPoint[2].y - lpPoint[0].y; <br>        lpRgnBmp[2].y += lpPoint[0].y; <br>        hrgnBmp = CreatePolygonRgn (lpRgnBmp, 4, ALTERNATE); <br> <br>        /* subtract the new bitmap extents region from the erasure region. */ <br>        CombineRgn (hrgnErase, hrgnErase, hrgnBmp, RGN_DIFF); <br> <br> <br> <br>        /* while we are here, get points ready for the next loop erasure */ <br>        lpRgnErase[0] = lpPoint[0]; <br>        lpRgnErase[1] = lpPoint[1]; <br>        lpRgnErase[3] = lpPoint[2]; <br>        lpRgnErase[2].x =  lpPoint[1].x - lpPoint[0].x; <br>        lpRgnErase[2].x += lpPoint[2].x - lpPoint[0].x; <br>        lpRgnErase[2].x += lpPoint[0].x; <br>        lpRgnErase[2].y =  lpPoint[1].y - lpPoint[0].y; <br>        lpRgnErase[2].y += lpPoint[2].y - lpPoint[0].y; <br>        lpRgnErase[2].y += lpPoint[0].y; <br> <br> <br> <br>        /**********************************************************/ <br>        PlgBlt (hdcDest, lpPoint, <br>                hdcSrc, XSrc, YSrc, nWidth, nHeight, <br>                hbmMask, XMask, YMask); <br>        /**********************************************************/ <br> <br>        /* need to flush graphics buffer, or regions are erased <br>         *  before the bitmap is drawn. <br>         */ <br>        GdiFlush(); <br> <br>        /* erase the newly uncovered region. */ <br>        FillRgn (hdcDest, hrgnErase, BACKGROUNDBRUSH ); <br>        DeleteObject (hrgnErase); <br>        DeleteObject (hrgnBmp); <br>      } /* end for loop */ <br> <br> <br>      /* because of roundoff error, the 'nSteps'th rotation will not <br>       *  always bring the parallelogram around to the 0th position. <br>       *  So we special case the last position, and do one more erase. <br>       *  Try commenting this out, and see the little glitches left <br>       *  on the screen if this comment is unclear. <br>       */ <br>      lpRgnErase[0] = lpPoint[0]; <br>      lpRgnErase[1] = lpPoint[1]; <br>      lpRgnErase[3] = lpPoint[2]; <br>      lpRgnErase[2].x =  lpPoint[1].x - lpPoint[0].x; <br>      lpRgnErase[2].x += lpPoint[2].x - lpPoint[0].x; <br>      lpRgnErase[2].x += lpPoint[0].x; <br>      lpRgnErase[2].y =  lpPoint[1].y - lpPoint[0].y; <br>      lpRgnErase[2].y += lpPoint[2].y - lpPoint[0].y; <br>      lpRgnErase[2].y += lpPoint[0].y; <br>      hrgnErase = CreatePolygonRgn (lpRgnErase, 4, ALTERNATE); <br>      lpPoint[0].x = GetDlgItemInt(hwndDlg, DID_P1X, &amp;success, TRUE); <br>      lpPoint[0].y = GetDlgItemInt(hwndDlg, DID_P1Y, &amp;success, TRUE); <br>      lpPoint[1].x = GetDlgItemInt(hwndDlg, DID_P2X, &amp;success, TRUE); <br>      lpPoint[1].y = GetDlgItemInt(hwndDlg, DID_P2Y, &amp;success, TRUE); <br>      lpPoint[2].x = GetDlgItemInt(hwndDlg, DID_P3X, &amp;success, TRUE); <br>      lpPoint[2].y = GetDlgItemInt(hwndDlg, DID_P3Y, &amp;success, TRUE); <br>      lpRgnBmp[0] = lpPoint[0]; <br>      lpRgnBmp[1] = lpPoint[1]; <br>      lpRgnBmp[3] = lpPoint[2]; <br>      lpRgnBmp[2].x =  lpPoint[1].x - lpPoint[0].x; <br>      lpRgnBmp[2].x += lpPoint[2].x - lpPoint[0].x; <br>      lpRgnBmp[2].x += lpPoint[0].x; <br>      lpRgnBmp[2].y =  lpPoint[1].y - lpPoint[0].y; <br>      lpRgnBmp[2].y += lpPoint[2].y - lpPoint[0].y; <br>      lpRgnBmp[2].y += lpPoint[0].y; <br>      hrgnBmp = CreatePolygonRgn (lpRgnBmp, 4, ALTERNATE); <br>      CombineRgn (hrgnErase, hrgnErase, hrgnBmp, RGN_DIFF); <br>      FillRgn (hdcDest, hrgnErase, BACKGROUNDBRUSH ); <br>      DeleteObject (hrgnErase); <br>      DeleteObject (hrgnBmp); <br> <br> <br> <br> <br> <br> <br> <br>      ReleaseDC (hwnd, hdc); <br> <br> <br>    } return 0; /* end WM_SPIN message */ <br> <br> <br>  } /* end switch */ <br>  return (DefWindowProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  DlgProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  Respond to user button presses by getting new bitmaps or by sending <br>*   the main window a WM_PLGBLT message.  Also handle special user messages <br>*   for updating the entry fields with the contents of the direct manipulation <br>*   objects. <br>* <br>*  global variables: <br>*   hwndMain - the main window.  also the parent of this dialog <br>*   ptoDest, ptoSrc, ptoMask - pointers to the direct manipulation objects <br>*   hdcDest, hdcSrc, hdcMask - HDCs for the 3 sub regions of the window. <br>*   hbmSrc, hbmMask          - bitmap handles for source and mask. <br>\**************************************************************************/ <br>LRESULT CALLBACK DlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br> <br>  switch (message) { <br>    /**********************************************************************\ <br>    *  WM_INITDIALOG <br>    * <br>    * Fill the entry fields with sensible original values. <br>    \**********************************************************************/ <br>    case WM_INITDIALOG: <br>        SetDlgItemText(hwnd, DID_P1X     , "0"); <br>        SetDlgItemText(hwnd, DID_P1Y     , "0"); <br>        SetDlgItemText(hwnd, DID_P2X     , "0"); <br>        SetDlgItemText(hwnd, DID_P2Y     , "0"); <br>        SetDlgItemText(hwnd, DID_P3X     , "0"); <br>        SetDlgItemText(hwnd, DID_P3Y     , "0"); <br>        SetDlgItemText(hwnd, DID_XSRC    , "0"); <br>        SetDlgItemText(hwnd, DID_YSRC    , "0"); <br>        SetDlgItemText(hwnd, DID_WIDTH   , "0"); <br>        SetDlgItemText(hwnd, DID_HEIGHT  , "0"); <br>        SetDlgItemText(hwnd, DID_XMASK   , "0"); <br>        SetDlgItemText(hwnd, DID_YMASK   , "0"); <br>    return TRUE; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PUTUPLPOINTS <br>    * <br>    * wParam -  HDC with the needed world transform. <br>    * lParam -  Pointer to the track object. <br>    * <br>    * Fill the entry fields for the array of 3 dest parallelogram points. <br>    *  Conditionally change the first point depending on tracking mode. <br>    \**********************************************************************/ <br>    case WM_PUTUPLPOINTS: { <br>        POINT p, origin; <br>        PTrackObject pto; <br>        HDC hdc; <br> <br>        hdc = (HDC) wParam; <br>        pto = (PTrackObject) lParam; <br>        GetViewportOrgEx (hdc, &amp;origin); <br> <br>        if (pto-&gt;Mode &amp; TMMOVE) { <br>          p.x = pto-&gt;rect.left; <br>          p.y = pto-&gt;rect.top; <br>          LPtoDP (pto-&gt;hdc, &amp;p, 1); <br>          p.x -= origin.x; p.y -= origin.y; <br> <br>          SetDlgItemInt(hwnd, DID_P1X, p.x, TRUE); <br>          SetDlgItemInt(hwnd, DID_P1Y, p.y, TRUE); <br> <br>        } <br> <br>        p.x = pto-&gt;rect.right; <br>        p.y = pto-&gt;rect.top; <br>        LPtoDP (pto-&gt;hdc, &amp;p, 1); <br>        p.x -= origin.x; p.y -= origin.y; <br> <br>        SetDlgItemInt(hwnd, DID_P2X, p.x, TRUE); <br>        SetDlgItemInt(hwnd, DID_P2Y, p.y, TRUE); <br> <br>        p.x = pto-&gt;rect.left; <br>        p.y = pto-&gt;rect.bottom; <br>        LPtoDP (pto-&gt;hdc, &amp;p, 1); <br>        p.x -= origin.x; p.y -= origin.y; <br>        SetDlgItemInt(hwnd, DID_P3X, p.x, TRUE); <br>        SetDlgItemInt(hwnd, DID_P3Y, p.y, TRUE); <br> <br>    } return FALSE; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PUTUPSRCRECT <br>    * <br>    * wParam -  HDC with the needed world transform. <br>    * lParam -  Pointer to the track object. <br>    * <br>    * Fill the entry fields for the source rectangle points. <br>    *  Conditionally change &lt;x,y&gt; or &lt;width,height&gt; depending on tracking mode. <br>    \**********************************************************************/ <br>    case WM_PUTUPSRCRECT: { <br>        POINT p1,p2, origin; <br>        PTrackObject pto; <br>        HDC hdc; <br> <br>        hdc = (HDC) wParam; <br>        pto = (PTrackObject) lParam; <br>        GetViewportOrgEx (hdc, &amp;origin); <br> <br>        p1.x = pto-&gt;rect.left; <br>        p1.y = pto-&gt;rect.top; <br>        LPtoDP (pto-&gt;hdc, &amp;p1, 1); <br> <br>        p2.x = pto-&gt;rect.right; <br>        p2.y = pto-&gt;rect.bottom; <br>        LPtoDP (pto-&gt;hdc, &amp;p2, 1); <br>        p2.x -= p1.x; p2.y -= p1.y; <br> <br>        p1.x -= origin.x; p1.y -= origin.y; <br> <br>        if (!(pto-&gt;Mode &amp; TMSIZEXY)) { <br>          SetDlgItemInt(hwnd, DID_XSRC, p1.x, TRUE); <br>          SetDlgItemInt(hwnd, DID_YSRC, p1.y, TRUE); <br>        } <br> <br>        if (!(pto-&gt;Mode &amp; TMMOVE)) { <br>          SetDlgItemInt(hwnd, DID_WIDTH,  p2.x, TRUE); <br>          SetDlgItemInt(hwnd, DID_HEIGHT, p2.y, TRUE); <br>        } <br>    } return FALSE; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PUTUPMASKPT <br>    * <br>    * wParam -  HDC with the needed world transform. <br>    * lParam -  Pointer to the track object. <br>    * <br>    * Fill the entry fields for the mask location point. <br>    \**********************************************************************/ <br>    case WM_PUTUPMASKPT: { <br>        POINT p1, origin; <br>        PTrackObject pto; <br>        HDC hdc; <br> <br>        hdc = (HDC) wParam; <br>        pto = (PTrackObject) lParam; <br>        GetViewportOrgEx (hdc, &amp;origin); <br> <br>        p1.x = pto-&gt;rect.left; <br>        p1.y = pto-&gt;rect.top; <br>        LPtoDP (pto-&gt;hdc, &amp;p1, 1); <br>        p1.x -= origin.x; p1.y -= origin.y; <br> <br>        SetDlgItemInt(hwnd, DID_XMASK, p1.x, TRUE); <br>        SetDlgItemInt(hwnd, DID_YMASK, p1.y, TRUE); <br> <br>    } return FALSE; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_COMMAND, DID_DRAW <br>    * <br>    * Draw button hit - send main window message to call PlgBlt(). <br>    \**********************************************************************/ <br>    case WM_COMMAND: { <br>      HBITMAP hbm; <br> <br>      if (LOWORD(wParam) == DID_DRAW) { <br>          SendMessage (hwndMain, WM_PLGBLT, 0,0); <br> <br> <br>    /**********************************************************************\ <br>    *  WM_COMMAND, DID_NEWSRC <br>    * <br>    * Try to get a new source bitmap.  Then <br>    *  invalidate two sub windows so that we force a repaint. <br>    \**********************************************************************/ <br>      } else if (LOWORD(wParam) == DID_NEWSRC) { <br>        if ( hbm = GetBitmap (hdcSrc, hInst, FALSE)) { <br>          DeleteObject (hbmSrc); <br>          hbmSrc = hbm; <br>          InvalidateRect (hwndMain, &amp;ptoSrc-&gt;rectClip, TRUE); <br>          InvalidateRect (hwndMain, &amp;ptoDest-&gt;rectClip, TRUE); <br>        } <br> <br>    /**********************************************************************\ <br>    *  WM_COMMAND, DID_Mask <br>    * <br>    * Try to get a new mask bitmap.  Then <br>    *  invalidate two sub windows so that we force a repaint. <br>    \**********************************************************************/ <br>      } else if (LOWORD(wParam) == DID_NEWMASK) { <br>        if ( hbm = GetBitmap (hdcMask,  hInst, TRUE)) { <br>          DeleteObject (hbmMask); <br>          hbmMask = hbm; <br>          InvalidateRect (hwndMain, &amp;ptoMask-&gt;rectClip, TRUE); <br>          InvalidateRect (hwndMain, &amp;ptoDest-&gt;rectClip, TRUE); <br>        } <br>      } <br> <br>    } return FALSE; /* end WM_COMMAND */ <br> <br> <br>  } /* end switch */ <br>  return 0; <br>} <br> <br> <br> <br>#define TICKSPACE     20 <br> <br>/**************************************************************************\ <br>* <br>*  function:  DrawGrids() <br>* <br>*  input parameters: <br>*   hdc - Device context to draw into. <br>*   width, height - size of the rectangle to fill with grids. <br>* <br>*  global variables:  none. <br>* <br>\**************************************************************************/ <br>VOID DrawGrids (HDC hdc, int width, int height) <br>{ <br>int i; <br> <br>    /* Draw vertical lines. Double at the axis */ <br>    for (i = 0; i&lt;= width; i+=TICKSPACE){ <br>      MoveToEx (hdc, i, 0, NULL); <br>      LineTo (hdc, i, height); <br>    } <br>    MoveToEx (hdc, 1, 0, NULL); <br>    LineTo (hdc, 1, height); <br> <br>    /* Draw horizontal lines. Double at the axis */ <br>    for (i = 0; i&lt;= height; i+=TICKSPACE){ <br>      MoveToEx (hdc, 0,i, NULL); <br>      LineTo (hdc, width,i); <br>    } <br>    MoveToEx (hdc, 0, 1, NULL); <br>    LineTo (hdc, width,1); <br> <br>  return; <br>} <br> <br> <br> <br> <br>/**************************************************************************** <br>    FUNCTION: About <br>****************************************************************************/ <br>LRESULT CALLBACK About(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>  if ((message == WM_COMMAND) &amp;&amp; (LOWORD(wParam) == IDOK)) { <br>    EndDialog (hwnd, TRUE); <br>    return TRUE; <br>  } <br>  if ((message == WM_SYSCOMMAND) &amp;&amp; (wParam == SC_CLOSE)) { <br>    EndDialog (hwnd, TRUE); <br>    return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br> <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
