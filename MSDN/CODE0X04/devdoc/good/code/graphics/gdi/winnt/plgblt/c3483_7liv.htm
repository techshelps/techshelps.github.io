<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BITMAP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3487"></a>BITMAP.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  bitmap.c -- support for reading in and drawing bitmaps. <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include "plgblt.h" <br> <br>/**************************************************************************\ <br>* <br>*  function:  DrawBitmap() <br>* <br>*  input parameters:  HDC, HBITMAP <br>* <br>*  Draw the bitmap into the hdc.  Source rectangle computed to include the <br>*   whole bitmap.  Destination location is 0,0. <br>* <br>*  global variables: none. <br>* <br>\**************************************************************************/ <br>VOID DrawBitmap (HDC hdc, HBITMAP hbm) <br>{ <br>    BOOL f; <br>    HDC hdcBits; <br>    BITMAP bm; <br> <br>    hdcBits = CreateCompatibleDC(hdc); <br>    GetObject (hbm, sizeof(BITMAP), &amp;bm); <br>    SelectObject(hdcBits,hbm); <br>    f = BitBlt(hdc,0,0,bm.bmWidth, bm.bmHeight,hdcBits,0,0,SRCCOPY); <br>    DeleteDC(hdcBits); <br>} <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  GetBitmap() <br>* <br>*  input parameters: <br>*   hdc - hdc to make the bitmap compatible with. <br>*   hInst - instance handle <br>* <br>*  Put up a common dialog box to open a new *.BMP file. <br>*   Once this is complete, open the file, read in the information, <br>*   and create a compatible bitmap. <br>* <br>*  returns:  handle to the bitmap iff successful.  NULL otherwise. <br>* <br>\**************************************************************************/ <br>HBITMAP GetBitmap (HDC hdc, HANDLE hInst, BOOL monochrome) <br>{ <br>    HBITMAP hbm; <br>    PBITMAPFILEHEADER pbmfh; <br>    PBITMAPINFOHEADER pbmih; <br>    PBYTE             pBits; <br>    int fh; <br>    int bfOffBits; <br>    int nbytes; <br>    OPENFILENAME  of; <br>    char buffer [MAX_PATH]; <br> <br>    buffer[0] = 0; <br> <br>    /* set up the OPENFILE structure, <br>     *  then use the appropriate common dialog <br>     */ <br>    of.lStructSize       = sizeof (OPENFILENAME); <br>    of.hwndOwner         = NULL; <br>    of.hInstance         = hInst; <br>    of.lpstrCustomFilter = NULL; <br>    of.nMaxCustFilter    = 0; <br>    of.nFilterIndex      = 0; <br>    of.lpstrFile         = buffer; <br>    of.nMaxFile          = MAX_PATH; <br>    of.lpstrFileTitle    = NULL; <br>    of.nMaxFileTitle     = 0; <br>    of.lpstrInitialDir   = "c:\\nt\\windows"; <br>    of.lpstrTitle        = NULL; <br>    of.Flags             = OFN_HIDEREADONLY; <br>    of.nFileOffset       = 0; <br>    of.nFileExtension    = 0; <br>    of.lpstrDefExt       = NULL; <br>    of.lCustData         = 0; <br>    of.lpfnHook          = NULL; <br>    of.lpTemplateName    = NULL; <br> <br>    if (PRIMARYLANGID(GetUserDefaultLangID ()) == LANG_JAPANESE) <br>      of.lpstrFilter       = "        (*.bmp)\000 *.BMP\000\000"; <br>    else <br>      of.lpstrFilter       = "Bitmaps\000 *.BMP\000\000"; <br> <br>    if (!GetOpenFileName (&amp;of)) return NULL; <br> <br>    /* Try to open the file.  If successful, then allocate space for it, <br>     *  and read in all of the bytes. <br>     */ <br>    fh = _lopen (buffer, OF_READ); <br>    if (fh == -1) return NULL; <br>    nbytes = GetFileSize ((HANDLE) fh, NULL); <br> <br>    /* The contents of the file are read in here in three parts.  First <br>     *  the bitmap file header is read, then the bitmap header along with <br>     *  the color table, then finally the actual bit data.  I.e. from <br>     *  a total of nbytes... <br>     *    1.  sizeof (BITMAPFILEHEADER) <br>     *    2.  bfOffBits- sizeof (BITMAPFILEHEADER) <br>     *    3.  (nbytes - bfOffBits) <br>     */ <br> <br>    /* read in the bitmap file header.  save the offset to bits. */ <br>    if (!(pbmfh = (PBITMAPFILEHEADER)LocalAlloc (LPTR, sizeof (BITMAPFILEHEADER)))) <br>        return NULL; <br>    _lread (fh, (LPSTR)pbmfh, sizeof (BITMAPFILEHEADER)); <br>    bfOffBits=pbmfh-&gt;bfOffBits; <br> <br>    /* read in the bitmap info header and the color table right after it. <br>     * both BITMAPINFOHEADER and BITMAPINFO needed for CreateDIBitmap() <br>     */ <br>    if (!(pbmih = (PBITMAPINFOHEADER)LocalAlloc (LPTR, bfOffBits- sizeof (BITMAPFILEHEADER)))) <br>        return NULL; <br>    _lread (fh, (LPSTR)pbmih, bfOffBits- sizeof (BITMAPFILEHEADER)); <br> <br>    /* finally read in the bit data. */ <br>    if (!(pBits = (PBYTE)LocalAlloc (LPTR, (nbytes - bfOffBits)))) return NULL; <br>    _lread (fh, (LPSTR)pBits, (nbytes - bfOffBits)); <br> <br> <br>    /* in the case of desiring a monochrome bitmap (input parameter), <br>     *  verify that is what we got.  If it is, then use CreateBitmap, <br>     *  else use a device independent bitmap. <br>     */ <br>    if (monochrome) { <br>      if (pbmih-&gt;biBitCount != 1) { <br>        MessageBox (NULL, <br>          GetStringRes (IDS_MONOCHROME), <br>          NULL, MB_APPLMODAL | MB_ICONSTOP | MB_OK); <br>        hbm = NULL; <br>      } else { <br>BITMAP bmpInf; <br>memset( &amp;bmpInf, 0, sizeof(bmpInf) ); <br>bmpInf.bmWidth = pbmih-&gt;biWidth; <br>bmpInf.bmHeight = pbmih-&gt;biHeight; <br>bmpInf.bmWidthBytes = ((pbmih-&gt;biWidth+31)&amp;(~31))/8; <br>bmpInf.bmPlanes = pbmih-&gt;biPlanes; <br>bmpInf.bmBitsPixel = pbmih-&gt;biBitCount; <br>bmpInf.bmBits = pBits; <br> <br>        hbm = CreateBitmapIndirect ( &amp;bmpInf ); <br>      } <br>    } else  /* bitmap is NOT monochrome, use DIB. */ <br>      hbm = CreateDIBitmap (hdc, pbmih, CBM_INIT, <br>                          pBits, (PBITMAPINFO) pbmih, DIB_RGB_COLORS); <br> <br> <br>    /* hbm is set... free up memory, and return */ <br>    LocalFree (LocalHandle ((LPSTR)pBits)); <br>    LocalFree (LocalHandle ((LPSTR)pbmih)); <br>    LocalFree (LocalHandle ((LPSTR)pbmfh)); <br>    _lclose (fh); <br> <br>    return hbm; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
