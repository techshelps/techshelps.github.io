<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WXFORM.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3491"></a>WXFORM.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  wxform.c -- sample program demonstrating the new "World Transform." <br>* <br>*  design:  There are a few global handles or pointers in this application, <br>*   and different routines to operate on them.  The obvious case of this <br>*   is the three window handles and their associated window procedures. <br>*   There is also a unique pointer to a track object and a routine to <br>*   operate on it (i.e. doTrackObject).  All communication is accomplished <br>*   by sending messages between these procedures.  Each window procedure, <br>*   and the track object procedure, operate on some set of messages which <br>*   include some of the standard Windows messages, and also miscellaneous <br>*   "WM_USER" messages (c.f. wxform.h). <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;limits.h&gt; <br>#include "wxform.h" <br> <br> <br>// <br>// function prototype for looking up string resources <br>// <br> <br>LPTSTR GetStringRes (int); <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  WinMain() <br>* <br>*  input parameters:  c.f. generic sample <br>* <br>\**************************************************************************/ <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                     LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG   msg; <br>    HICON hicon; <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br> <br> <br>    // <br>    // Detect platform and exit gracefully if not Windows NT. <br>    // <br> <br>    { <br>      OSVERSIONINFO osvi; <br>      osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO); <br> <br>      GetVersionEx (&amp;osvi); <br>      if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) { <br>        MessageBox (NULL, <br>          GetStringRes (IDS_NTONLY), <br>          "wxform", MB_OK | MB_ICONSTOP); <br>        return 0; <br>      } <br>    } <br> <br> <br>    /* Check for previous instance.  If none, then register class. */ <br>    if (!hPrevInstance) { <br>        WNDCLASS  wc; <br> <br>        wc.style = 0; <br>        wc.lpfnWndProc = (WNDPROC)MainWndProc; <br> <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = hInstance; <br>        wc.hIcon = LoadIcon(hInstance, "TransformIcon"); <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = GetStockObject(LTGRAY_BRUSH); <br>        wc.lpszMenuName =  NULL; <br>        wc.lpszClassName = "wxform"; <br> <br>        if (!RegisterClass(&amp;wc)) return (FALSE); <br>    }  /* class registered o.k. */ <br> <br> <br>    /* Create the main window.  Return false if CreateWindow() fails */ <br>    hInst = hInstance; <br> <br>    hwndMain = CreateWindow( <br>        "wxform", <br>        GetStringRes (IDS_WINDOWTITLE), <br>        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance, <br>        NULL); <br> <br>    if (!hwndMain) return (FALSE); <br>    ShowWindow(hwndMain, nCmdShow); <br>    UpdateWindow(hwndMain); <br> <br> <br>    /* create a new track object and paint it for the first time. */ <br>    ptoRect = doTrackObject(NULL, TROB_NEW, hwndMain, 0); <br>    doTrackObject(ptoRect, TROB_PAINT, hwndMain, 0); <br> <br> <br>    /* load and display dialog for the world transform matrix. <br>     *  then fill its entry fields.  Also, get the HICON from the <br>     *  main window and fill it into the dialog's class structure <br>     *  for this application. <br>     */ <br>    hwndTransform = CreateDialog(hInst, "TransformDlg", <br>                                 hwndMain, (DLGPROC)TransformDlgProc); <br>    hicon = (HICON) GetClassLong (hwndMain, GCL_HICON); <br>    SetClassLong (hwndTransform, GCL_HICON, (LONG)hicon); <br>    showTransform = TRUE; <br>    SendMessage (hwndTransform, WM_PUTUPFLOATS, 0, (LONG) &amp;ptoRect-&gt;xfmChange); <br> <br>    /* load and display the dialog for the mouse position. <br>     *  minimize it initially. <br>     */ <br>    hwndMouse = CreateDialog(hInst, "MouseDlg", <br>                             hwndMain, (DLGPROC)MouseDlgProc); <br>    ShowWindow (hwndMouse, SW_SHOWMINIMIZED); <br>    showMouse = FALSE; <br> <br> <br>    /* load and display the dialog with the direct manipulation help. <br>     *  minimize it initially.   (Don't need a unique window procedure.) <br>     */ <br>    hwndHelp = CreateDialog(hInst, "helpDlg", hwndMain, NULL); <br>    ShowWindow (hwndHelp, SW_SHOWMINIMIZED); <br> <br> <br> <br>    /* Loop getting messages and dispatching them. */ <br>    while (GetMessage(&amp;msg,NULL, 0,0)) { <br>      if (!IsDialogMessage (hwndTransform, &amp;msg)) <br>      if (!IsDialogMessage (hwndMouse, &amp;msg)) <br>      if (!IsDialogMessage (hwndHelp, &amp;msg)){ <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>      } <br>    } <br>    return (msg.wParam); <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  MainWndProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  global variables: <br>*   hwndTransform, <br>*   hwndMouse - information dialog box window handles. <br>*   showTransform, <br>*   showMouse - Booleans recording the retore/minimize state of the dialogs. <br>*   ptoRect   - pointer to track object in middle of screen. <br>* <br>\**************************************************************************/ <br>LRESULT CALLBACK MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>static HANDLE hPenGrid; <br> <br>  switch (message) { <br> <br>    /**********************************************************************\ <br>    *  WM_CREATE <br>    * <br>    * create a pen for later use. <br>    \**********************************************************************/ <br>    case WM_CREATE: <br>      hPenGrid  = CreatePen (PS_SOLID, 1, GRIDCOLOR); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_DESTROY <br>    * <br>    * Complement of WM_CREATE.  send the track object the delete messages, <br>    *  then call PostQuitMessage. <br>    \**********************************************************************/ <br>    case WM_DESTROY: <br>      DeleteObject(hPenGrid); <br>      doTrackObject(ptoRect, TROB_DELETE, hwnd, lParam); <br>      PostQuitMessage(0); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_SIZE <br>    * <br>    * Invalidate the whole window because we reset the origin on paint <br>    *  messages according to the size.  Also, send the track object a <br>    *  message so that it will also change its HDC's viewport origin. <br>    \**********************************************************************/ <br>    case WM_SIZE: <br>        InvalidateRect (hwnd, NULL, TRUE); <br>        doTrackObject (ptoRect, TROB_CENTER, hwnd, lParam); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PAINT <br>    * <br>    * First invalidate the whole window (forces the object to be painted <br>    *  fresh, and thus it won't XOR its old self out).  Then draw the <br>    *  grid and finally draw the object. <br>    \**********************************************************************/ <br>    case WM_PAINT : { <br>      PAINTSTRUCT ps; <br>      HDC hdc; <br>      RECT  rect; <br>      POINT point; <br>      int i; <br> <br>      InvalidateRect (hwnd, NULL, TRUE); <br> <br>      hdc = BeginPaint(hwnd, &amp;ps); <br> <br>      CenterOrigin (hwnd, hdc); <br>      GetClientRect (hwnd, &amp;rect); <br>      GetViewportOrgEx(hdc, &amp;point); <br>      OffsetRect(&amp;rect, -point.x, -point.y ); <br> <br> <br>      /* Draw vertical lines.  Draw three at the origin. */ <br>      SelectObject(hdc, hPenGrid); <br>      for (i = 0; i&lt;= rect.right; i+=TICKSPACE){ <br>        MoveToEx (hdc, i, rect.top, NULL); <br>        LineTo (hdc, i, rect.bottom); <br>        MoveToEx (hdc, -i, rect.top, NULL); <br>        LineTo (hdc, -i, rect.bottom); <br>      } <br>      MoveToEx (hdc, -1, rect.top, NULL); <br>      LineTo (hdc, -1, rect.bottom); <br>      MoveToEx (hdc, 1, rect.top, NULL); <br>      LineTo (hdc, 1, rect.bottom); <br> <br> <br>      /* Draw horizontal lines.  Draw three at the origin. */ <br>      for (i = 0; i&lt;= rect.bottom; i+=TICKSPACE){ <br>        MoveToEx (hdc, rect.left, i, NULL); <br>        LineTo (hdc, rect.right, i); <br>        MoveToEx (hdc, rect.left, -i, NULL); <br>        LineTo (hdc, rect.right, -i); <br>      } <br>      MoveToEx (hdc, rect.left, -1, NULL); <br>      LineTo (hdc, rect.right, -1); <br>      MoveToEx (hdc, rect.left, 1, NULL); <br>      LineTo (hdc, rect.right, 1); <br> <br>      doTrackObject(ptoRect, TROB_PAINT, hwnd, lParam); <br> <br>      EndPaint (hwnd, &amp;ps); <br>    } break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONDOWN &amp; WM_RBUTTONDOWN <br>    * On button down messages, hittest on the track object, and if <br>    *  it returns true, then send these messages to the track object. <br>    \**********************************************************************/ <br>    case WM_RBUTTONDOWN: <br>    case WM_LBUTTONDOWN: <br>      if (doTrackObject(ptoRect, TROB_HITTEST, hwnd, lParam)) <br>         doTrackObject(ptoRect, message, hwnd, lParam); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONUP &amp; WM_RBUTTONDOWN &amp; MW_MOUSEMOVE <br>    * If the track object is in a "tracking mode" then send it these messages. <br>    *  If the transform dialog is not minimized, fill it with numbers. <br>    *  If the mouse dialog is not minimized, fill it with numbers. <br>    \**********************************************************************/ <br>    case WM_RBUTTONUP: <br>    case WM_LBUTTONUP: <br>    case WM_MOUSEMOVE: <br>      if (ptoRect-&gt;Mode) { <br>        doTrackObject(ptoRect, message, hwnd, lParam); <br>        if (showTransform) <br>          SendMessage (hwndTransform, WM_PUTUPFLOATS, 0, <br>                       (LONG) &amp;ptoRect-&gt;xfmChange); <br>      } <br> <br>      if (showMouse) <br>        SendMessage (hwndMouse, WM_PUTUPFLOATS, (DWORD) hwnd, lParam); <br> <br>    break; <br> <br> <br>  } /* end switch */ <br>  return (DefWindowProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  TransformDlgProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  global variables: <br>*   showTransform  - TRUE if window is restored, FALSE if minimized. <br>*       maintain the value in this routine for other windows' use. <br>*   ptoRect - pointer to the track object. <br>*   showMouse, hwndMain. <br>* <br>*  nonstandard messages: <br>*   WM_PUTUPFLOATS - fill the entry fields with the contents of an XFORM. <br>\**************************************************************************/ <br>LRESULT CALLBACK TransformDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>XFORM  xform; <br>char buffer[MAXCHARS]; <br> <br> <br>  switch (message) { <br> <br> <br>    /**********************************************************************\ <br>    *  WM_INITDIALOG <br>    * <br>    * Fill the entry fields with sensible original values. <br>    \**********************************************************************/ <br>    case WM_INITDIALOG: <br>      SetDlgItemText(hwnd, IDD_13, "0"); <br>      SetDlgItemText(hwnd, IDD_23, "0"); <br>      SetDlgItemText(hwnd, IDD_33, "1"); <br>    return TRUE; <br> <br> <br>    /******************************************************************\ <br>    *  WM_PUTUPFLOATS <br>    * <br>    *  lParam - pointer to an XFORM structure. <br>    *   fill the entry fields with the XFORM values. <br>    \******************************************************************/ <br>    case WM_PUTUPFLOATS: { <br>      PXFORM pxform; <br>      pxform = (PXFORM) lParam; <br> <br>      sprintf (buffer, FORMATFLOAT,pxform-&gt;eM11); <br>      SetDlgItemText(hwnd, IDD_EM11, buffer); <br>      sprintf (buffer, FORMATFLOAT,pxform-&gt;eM12); <br>      SetDlgItemText(hwnd, IDD_EM12, buffer); <br>      sprintf (buffer, FORMATFLOAT,pxform-&gt;eDx); <br>      SetDlgItemText(hwnd, IDD_EDX, buffer); <br> <br>      sprintf (buffer, FORMATFLOAT,pxform-&gt;eM21); <br>      SetDlgItemText(hwnd, IDD_EM21, buffer); <br>      sprintf (buffer, FORMATFLOAT,pxform-&gt;eM22); <br>      SetDlgItemText(hwnd, IDD_EM22, buffer); <br>      sprintf (buffer, FORMATFLOAT,pxform-&gt;eDy); <br>      SetDlgItemText(hwnd, IDD_EDY, buffer); <br> <br>    } return FALSE; <br> <br> <br> <br>    /******************************************************************\ <br>    *  WM_SIZE <br>    * <br>    *  toggle the global variable keeping track of the iconized state <br>    *   of this window. <br>    \******************************************************************/ <br>    case WM_SIZE : <br>      if (wParam == SIZEICONIC) <br>        showTransform = FALSE; <br>      else { <br>        showTransform = TRUE; <br>        SendMessage (hwnd, WM_PUTUPFLOATS, 0, (LONG) &amp;ptoRect-&gt;xfmChange); <br>      } <br>    return FALSE; <br> <br> <br>    case WM_COMMAND: <br>      /******************************************************************\ <br>      *  WM_COMMAND,  IDD_SETXFORM <br>      * <br>      *  take the values from the entry field, fill them into an XFORM <br>      *   structure and then send the track object the message to use <br>      *   these values.  Finally, reformat and repaint the entry fields. <br>      \******************************************************************/ <br>      if (LOWORD(wParam) == IDD_SETXFORM) { <br>        GetDlgItemText(hwnd, IDD_EM11, buffer, MAXCHARS); <br>        xform.eM11 = (float) atof (buffer); <br>        GetDlgItemText(hwnd, IDD_EM12, buffer, MAXCHARS); <br>        xform.eM12 = (float) atof (buffer); <br>        GetDlgItemText(hwnd, IDD_EDX, buffer, MAXCHARS); <br>        xform.eDx = (float) atof (buffer); <br> <br>        GetDlgItemText(hwnd, IDD_EM21, buffer, MAXCHARS); <br>        xform.eM21 = (float) atof (buffer); <br>        GetDlgItemText(hwnd, IDD_EM22, buffer, MAXCHARS); <br>        xform.eM22 = (float) atof (buffer); <br>        GetDlgItemText(hwnd, IDD_EDY, buffer, MAXCHARS); <br>        xform.eDy = (float) atof (buffer); <br> <br>        // HACK.  The WM_SIZE here is used to flush the GDI buffer in order <br>        //  to eliminate a very strange bug whereby DPtoLP() doesn't work. <br>        if (showMouse) SendMessage (hwndMain, WM_SIZE, 0,0); <br> <br> <br>        doTrackObject (ptoRect, TROB_SETXFORM, hwnd, (LONG) &amp;xform); <br>        SendMessage (hwnd, WM_PUTUPFLOATS, 0, (LONG) &amp;xform); <br> <br> <br>      /******************************************************************\ <br>      *  WM_COMMAND,  IDD_IDENTITY <br>      * <br>      *  fill a local XFORM structure with the identity matrix.  Now <br>      *   send the track object the message to use these values. <br>      *   Finally, reformat and repaint the entry fields. <br>      \******************************************************************/ <br>      } else if (LOWORD(wParam) == IDD_IDENTITY) { <br>        xform.eM11 = <br>        xform.eM22 =  (float) 1.0; <br>        xform.eDx  = <br>        xform.eDy  = <br>        xform.eM12 = <br>        xform.eM21 =  (float) 0.0; <br> <br>        // HACK.  The WM_SIZE here is used to flush the GDI buffer in order <br>        //  to eliminate a very strange bug whereby DPtoLP() doesn't work. <br>        if (showMouse) SendMessage (hwndMain, WM_SIZE, 0,0); <br> <br>        doTrackObject (ptoRect, TROB_SETXFORM, hwnd, (LONG) &amp;xform); <br>        SendMessage (hwnd, WM_PUTUPFLOATS, 0, (LONG) &amp;xform); <br>      } /* end WM_COMMAND */ <br>    return FALSE; <br> <br> <br>  } /* end switch */ <br>  return FALSE; <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  MouseDlgProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  global variables: <br>*   showMouse  -- TRUE if window is restored, FALSE if minimized. <br>*       maintain the value in this routine for other windows' use. <br>*   ptoRect - pointer to the track object.  Needed for DPtoLP() <br>* <br>*  nonstandard messages: <br>*   WM_PUTUPFLOATS - fill the entry fields with the mouse position. <br>* <br>\**************************************************************************/ <br>LRESULT CALLBACK MouseDlgProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>char buffer[MAXCHARS]; <br> <br>  switch (message) { <br> <br>    /******************************************************************\ <br>    *  WM_PUTUPFLOATS <br>    * <br>    *  wParam - contains the hwnd for the main window. <br>    *  lParam - contains the mouse position in device coordinates. <br>    *           (c.f. WM_MOUSEMOVE) <br>    \******************************************************************/ <br>    case WM_PUTUPFLOATS: { <br>      POINT pScreen, pWorld; <br>      HWND hwndMain; <br> <br>      hwndMain = (HWND) wParam; <br>      pScreen.x = pWorld.x = LOWORD(lParam); <br>      pScreen.y = pWorld.y  = HIWORD(lParam); <br> <br>      sprintf (buffer, "%d", pScreen.x); <br>      SetDlgItemText(hwnd, IDD_DEVICEX, buffer); <br>      sprintf (buffer, "%d", pScreen.y); <br>      SetDlgItemText(hwnd, IDD_DEVICEY, buffer); <br> <br>      ClientToScreen (hwndMain, &amp;pScreen); <br>      sprintf (buffer, "%d", pScreen.x); <br>      SetDlgItemText(hwnd, IDD_SCREENX, buffer); <br>      sprintf (buffer, "%d", pScreen.y); <br>      SetDlgItemText(hwnd, IDD_SCREENY, buffer); <br> <br>      DPtoLP (ptoRect-&gt;hdc, &amp;pWorld, 1); <br>      sprintf (buffer, FORMATFLOAT, (float) pWorld.x); <br>      SetDlgItemText(hwnd, IDD_WORLDX , buffer); <br>      sprintf (buffer, FORMATFLOAT, (float) pWorld.y); <br>      SetDlgItemText(hwnd, IDD_WORLDY , buffer); <br> <br>    } return FALSE; <br> <br> <br> <br>    /******************************************************************\ <br>    *  WM_SIZE <br>    * <br>    *  toggle the global variable keeping track of the iconized state <br>    *   of this window. <br>    \******************************************************************/ <br>    case WM_SIZE : <br>      if (wParam == SIZEICONIC) <br>        showMouse = FALSE; <br>      else <br>        showMouse = TRUE; <br>    return FALSE; <br> <br>  } <br>  return FALSE; <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  CenterOrigin() <br>* <br>*  input parameters: <br>*   hwnd - window with client we want the center of. <br>*   hdc - device context which we set the Viewport origin of. <br>* <br>\**************************************************************************/ <br>VOID CenterOrigin (HWND hwnd, HDC hdc) <br>{ <br>RECT  rect; <br>POINT center; <br> <br>    GetClientRect (hwnd, &amp;rect); <br>    center.x = rect.right / 2; <br>    center.y = rect.bottom /2; <br> <br>    SetViewportOrgEx (hdc, center.x, center.y, NULL); <br>    return; <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  doTrackObject() <br>* <br>*  input parameters: <br>*   pto -  pointer to a track object. <br>*   msg -  message selecting what action to take.  Values may include WM_*'s <br>*           (see case statements below for more information.) <br>*   hwnd - Window handle for the window the track object exists within. <br>*   lParam - Usually fourth param to window proc. varies based on msg. <br>* <br>*  global variables:  none. <br>* <br>*  coordinate spaces:  There are three coordinate spaces of interest here, <br>*   and this routine is frequently switching between them... <br>* <br>*           WORLD                   DEVICE                  SCREEN <br>* <br>*      object coordinates       input mouse pos       used w/ SetCursorPos() <br>*         (pto-&gt;rect)          (lParam for WM_*) <br>* <br>*             -----&gt;  LPtoDP() ----&gt;    ----&gt; ClientToScreen() --&gt; <br>*             &lt;-----  DPtoLP() &lt;----    &lt;---- ScreenToClient() &lt;-- <br>* <br>*   in addition, the HDC has an offset origin.  Device coordinates for the <br>*   mouse (lParam) never take this into account, but it is necessary to <br>*   translate them in order to get direct manipulation right. <br>* <br>\**************************************************************************/ <br>PTrackObject doTrackObject(PTrackObject pto, int msg, HWND hwnd, LONG lParam) <br>{ <br>  if ((pto == NULL) &amp;&amp; (msg != TROB_NEW))  return NULL; <br> <br>  switch (msg) { <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_NEW <br>    * <br>    * Allocate new PTrackObject structure.  Fill in default values <br>    *  for the fields of the structure.  Set up the HDC correctly. <br>    * return - pointer to the new object. <br>    \**********************************************************************/ <br>    case  TROB_NEW: { <br>        PTrackObject  pto; <br> <br>        /* with LPTR returned value is a pointer. */ <br>        pto = (PTrackObject) LocalAlloc (LPTR, sizeof (TrackObject)); <br> <br>        /* initialize the HDC and other fields. */ <br>        pto-&gt;hdc = GetDC(hwnd); <br>        SetGraphicsMode (pto-&gt;hdc, GM_ADVANCED); <br>        SetROP2(pto-&gt;hdc, R2_NOT); <br>        SelectObject (pto-&gt;hdc, GetStockObject (NULL_BRUSH)); <br>        SelectObject(pto-&gt;hdc, CreatePen (PS_SOLID, 2, (COLORREF) 0x01000009)); <br>        pto-&gt;Mode = TMNONE; <br>        doTrackObject (pto, TROB_CENTER, hwnd, lParam); <br>        GetWorldTransform (pto-&gt;hdc, &amp;(pto-&gt;xfmChange)); <br> <br>        /* initialize the size. */ <br>        pto-&gt;rect.top = pto-&gt;rect.left = 0; <br>        pto-&gt;rect.bottom = pto-&gt;rect.right = TICKSPACE*5; <br> <br>        return (pto); <br>    } <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_DELETE <br>    * <br>    * Delete the pen that we created, release the DC, <br>    *  free up the memory allocated for the object. <br>    \**********************************************************************/ <br>    case  TROB_DELETE: <br>        DeleteObject (SelectObject (pto-&gt;hdc, GetStockObject (BLACK_PEN))); <br>        doTrackObject (pto, TROB_PAINT, hwnd, lParam); <br>        ReleaseDC (hwnd, pto-&gt;hdc); <br>        LocalFree (LocalHandle ((LPSTR)pto)); <br>    return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_CENTER <br>    * <br>    * Called in order to reset the view port origin in the track objects <br>    *  hdc whenever the client window changes size.  This hdc is thus kept <br>    *  synchronized with the hdc that the axes are painted into. <br>    \**********************************************************************/ <br>    case TROB_CENTER: { <br>        CenterOrigin (hwnd, pto-&gt;hdc); <br>        return (pto); <br>    } <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_PAINT <br>    * <br>    * Paint the object into its hdc.  Called half the time to erase <br>    *  the object, and half the time to redraw it. <br>    \**********************************************************************/ <br>    case TROB_PAINT: { <br>        Rectangle (pto-&gt;hdc, pto-&gt;rect.left+1, pto-&gt;rect.top+1, <br>                             pto-&gt;rect.left+INC, pto-&gt;rect.top+INC); <br> <br>        Rectangle (pto-&gt;hdc, pto-&gt;rect.left, pto-&gt;rect.top, <br>                             pto-&gt;rect.right, pto-&gt;rect.bottom); <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_SETXFORM <br>    * <br>    * lParam - pointer to the new transform. <br>    *  set the new transform into the HDC, then update xfmChange. <br>    \**********************************************************************/ <br>    case TROB_SETXFORM: { <br>        doTrackObject (pto, TROB_PAINT, hwnd, lParam); <br>        SetWorldTransform(pto-&gt;hdc, (PXFORM) lParam); <br>        GetWorldTransform(pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>        doTrackObject (pto, TROB_PAINT, hwnd, lParam); <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  TROB_HITTEST <br>    * <br>    * Check the point sent in in the lParam to see if it lays within <br>    *  the bounds of the objects defining rectangle. <br>    * return - pointer to the object iff the point is in rectangle, <br>    *  otherwise return NULL. <br>    \**********************************************************************/ <br>    case TROB_HITTEST:{ <br>        POINT  mouWorld; <br>        mouWorld.x = LOWORD(lParam); <br>        mouWorld.y = HIWORD(lParam); <br> <br>        DPtoLP (pto-&gt;hdc, &amp;mouWorld, 1); <br> <br>        if (PtInRect (&amp;pto-&gt;rect, mouWorld))  return pto; <br>        else  return NULL; <br>    } <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONDOWN &amp;  WM_RBUTTONDOWN <br>    * <br>    * Capture the mouse, set the tracking mode depending on the mouse <br>    *  location in world coordinates, reset the mouse position. <br>    * <br>    \**********************************************************************/ <br>    case WM_LBUTTONDOWN: <br>    case WM_RBUTTONDOWN: { <br>      POINT  newmouScreen; <br>      POINT  mouWorld; <br> <br>      mouWorld.x = LOWORD(lParam); <br>      mouWorld.y = HIWORD(lParam); <br>      DPtoLP (pto-&gt;hdc, &amp;mouWorld, 1); <br> <br>      /* upper left hand corner. right button is no-op. */ <br>      if ((mouWorld.x &lt;= (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &lt;= (pto-&gt;rect.bottom / 2))) { <br>          if (msg == WM_RBUTTONDOWN) return NULL; <br>          pto-&gt;Mode = TMMOVE; <br>          newmouScreen.x = pto-&gt;rect.left; <br>          newmouScreen.y = pto-&gt;rect.top; <br> <br>      /* lower left hand corner */ <br>      } else if ((mouWorld.x &lt;= (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &gt; (pto-&gt;rect.bottom / 2))) { <br> <br>          pto-&gt;Mode = (msg == WM_RBUTTONDOWN) ? TMSHEARY : TMSIZEY; <br>          newmouScreen.x = pto-&gt;rect.left; <br>          newmouScreen.y = pto-&gt;rect.bottom; <br> <br>      /* upper right hand corner */ <br>      } else if ((mouWorld.x &gt; (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &lt;= (pto-&gt;rect.bottom / 2))) { <br> <br>          pto-&gt;Mode = (msg == WM_RBUTTONDOWN) ? TMSHEARX : TMSIZEX; <br>          newmouScreen.x = pto-&gt;rect.right; <br>          newmouScreen.y = pto-&gt;rect.top; <br> <br>      /* lower right hand corner */ <br>      } else if ((mouWorld.x &gt; (pto-&gt;rect.right  / 2)) &amp;&amp; <br>          (mouWorld.y &gt; (pto-&gt;rect.bottom / 2))) { <br> <br>          pto-&gt;Mode = (msg == WM_RBUTTONDOWN) ? TMROTATE : TMSIZEXY; <br>          newmouScreen.x = pto-&gt;rect.right; <br>          newmouScreen.y = pto-&gt;rect.bottom; <br>      } <br> <br>      SetCapture(hwnd); <br>      LPtoDP (pto-&gt;hdc, &amp;newmouScreen, 1); <br>      ClientToScreen (hwnd, &amp;newmouScreen); <br>      SetCursorPos (newmouScreen.x,newmouScreen.y); <br> <br>      GetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmDown); <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_MOUSEMOVE <br>    * <br>    * this is where almost all of the interesting calculation is done. <br>    *  First clip the mouse location to be in client rectangle, then <br>    *  call MouseMove() to handle the different tracking modes. <br>    \**********************************************************************/ <br>    case WM_MOUSEMOVE: { <br>      RECT  rect; <br>      GetClientRect (hwnd, &amp;rect); <br> <br>      if ((short) LOWORD(lParam) &lt; (short)rect.left) <br>        lParam = MAKELONG ((WORD)rect.left, HIWORD(lParam)); <br> <br>      if (LOWORD(lParam) &gt; (WORD)rect.right) <br>        lParam = MAKELONG ((WORD)rect.right, HIWORD(lParam)); <br> <br>      if ((short) HIWORD(lParam) &lt; (short)rect.top) <br>        lParam = MAKELONG (LOWORD(lParam), (WORD)rect.top); <br> <br>      if (HIWORD(lParam) &gt; (WORD)rect.bottom) <br>        lParam = MAKELONG (LOWORD(lParam),(WORD)rect.bottom); <br> <br>      MouseMove (pto, msg, hwnd, lParam); <br> <br>    } return NULL; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_RBUTTONUP &amp; WM_LBUTTONUP <br>    * <br>    * simply release the mouse capture, and set the mode to TMNONE. <br>    \**********************************************************************/ <br>    case WM_RBUTTONUP: <br>    case WM_LBUTTONUP: { <br>      if (pto-&gt;Mode) { <br>         ReleaseCapture(); <br>         pto-&gt;Mode = TMNONE; <br>      } <br>    } return NULL; <br> <br>  }  /* end switch(msg) */ <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  MouseMove() <br>* <br>*  input parameters: <br>*   pto -  pointer to a track object. <br>*   msg -  not used. <br>*   hwnd - Window handle for the window the track object exists within. <br>*   lParam - Usually fourth param to window proc. varies based on msg. <br>* <br>*  The tracking behavior which the user observers when moving the mouse <br>*   is based on the current tracking mode of the object.  This is usually <br>*   determined on the mouse down event (c.f. TM*).  First erase the old <br>*   object, then figure out the change to the transform matrix, finally <br>*   change the world transform matrix and redraw the object. <br>* <br>*  Tranform: <br>*    (    eM11        eM12        0   ) <br>*    (    eM21        eM22        0   ) <br>*    (    eDx         eDy         1   ) <br>* <br>*   xDevice = (xWorld * eM11) + (yWorld * eM21) + eDx <br>*   yDevice = (xWorld * eM12) + (yWorld * eM22) + eDy <br>* <br>*   In this routine the Device (mouse location) and World (rectangle corner) <br>*   points are known.  Therefore, the two equations above are solved for <br>*   the desired matrix entry value (e.g. eM11, 1M12, ... eDy).  The tracking <br>*   mode determines which one of these entries may be changed.  E.g. scaling <br>*   in X modifies eM11 while shearing in X modifies eM12.  So rather than <br>*   using the world transform to map from world to device points, we are <br>*   back-computing the proper contents of the world transform. </code></pre>
<p>
</p>
<pre><code>* <br>\**************************************************************************/ <br>VOID MouseMove(PTrackObject pto, int msg, HWND hwnd, LONG lParam) <br>{ <br>POINT  mouWorld, mouDevice, orgDevice; <br> <br>    UNREFERENCED_PARAMETER(msg); <br> <br>    doTrackObject(pto, TROB_PAINT, hwnd, lParam); <br>    mouDevice.x = mouWorld.x = LOWORD(lParam); <br>    mouDevice.y = mouWorld.y = HIWORD(lParam); <br> <br>    SetWorldTransform(pto-&gt;hdc, &amp;pto-&gt;xfmDown); <br>    DPtoLP (pto-&gt;hdc, &amp;mouWorld, 1); <br> <br>    /* offset the mouse device point for the viewport's origin. */ <br>    GetViewportOrgEx (pto-&gt;hdc, &amp;orgDevice); <br>    mouDevice.x -= orgDevice.x; <br>    mouDevice.y -= orgDevice.y; <br> <br>    GetWorldTransform(pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br> <br>    switch (pto-&gt;Mode) { <br>      /*******************************************************\ <br>      *    (     1         xShear       0   ) <br>      *    (     0           1          0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * xWorld = rect.left == 0; <br>      \*******************************************************/ <br>      case TMSHEARX: { <br>        pto-&gt;xfmChange.eM12 = (float) mouDevice.y; <br>        pto-&gt;xfmChange.eM12 -=pto-&gt;xfmChange.eDy; <br>        pto-&gt;xfmChange.eM12 /=(float) pto-&gt;rect.right ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (     1           0          0   ) <br>      *    (   yShear        1          0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * yWorld = rect.top == 0; <br>      \*******************************************************/ <br>      case TMSHEARY: { <br>        pto-&gt;xfmChange.eM21 = (float) mouDevice.x; <br>        pto-&gt;xfmChange.eM21 -=pto-&gt;xfmChange.eDx; <br>        pto-&gt;xfmChange.eM21 /=(float) pto-&gt;rect.bottom ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br> <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (   cos(a)      -sin(a)      0   ) <br>      *    (   sin(a)       cos(a)      0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * a == rotation angle.  Since mouse in in lower right, <br>      *  we need to shift this back 45 degrees (assuming that <br>      *  straight down is 0 degrees).  Thus we actually compute <br>      *  cos(a) = cos(b - 45) = cos(b)sin(45) + cos(45)sin(45) <br>      *  where b is angle from the origin to the mouse (x,y) <br>      *  cos(45) = sin(45) ~= 0.707107 <br>      *  cos(b) = y/r    sin(b) = x/r <br>      * <br>      \*******************************************************/ <br>      case TMROTATE: { <br>        float r; <br> <br>        /* translate back to the origin. */ <br>        pto-&gt;xfmChange.eDx = pto-&gt;xfmChange.eDy = (float)0.0; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br> <br>        /* rotate about the origin. */ <br>        r = (float) sqrt( (double)(mouWorld.x * mouWorld.x) + <br>                          (double)(mouWorld.y * mouWorld.y)); <br> <br>        pto-&gt;xfmChange.eM11 = (float) mouWorld.y / r; <br>        pto-&gt;xfmChange.eM11 += (float) mouWorld.x / r; <br>        pto-&gt;xfmChange.eM11 *= (float) 0.707107; <br>        pto-&gt;xfmChange.eM22 = pto-&gt;xfmChange.eM11; <br> <br>        pto-&gt;xfmChange.eM12 = (float) mouWorld.y / r; <br>        pto-&gt;xfmChange.eM12 -= (float) mouWorld.x / r; <br>        pto-&gt;xfmChange.eM12 *= (float) 0.707107; <br>        pto-&gt;xfmChange.eM21 = -pto-&gt;xfmChange.eM12; <br> <br>        pto-&gt;xfmChange.eDx = pto-&gt;xfmChange.eDy = (float)0.0; <br> <br>        ModifyWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange, MWT_RIGHTMULTIPLY); <br> <br>        /* translate back to the original offset. */ <br>        pto-&gt;xfmChange.eM11 = <br>        pto-&gt;xfmChange.eM22 = (float) 1.0; <br>        pto-&gt;xfmChange.eM12 = <br>        pto-&gt;xfmChange.eM21 = (float) 0.0; <br> <br>        pto-&gt;xfmChange.eDx = pto-&gt;xfmDown.eDx; <br>        pto-&gt;xfmChange.eDy = pto-&gt;xfmDown.eDy; <br>        ModifyWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange, MWT_RIGHTMULTIPLY); <br>        GetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (  Size X         0          0   ) <br>      *    (     0        Size Y        0   ) <br>      *    (     0           0          1   ) <br>      * <br>      \*******************************************************/ <br>      case TMSIZEXY: { <br>        pto-&gt;xfmChange.eM11 = (float) mouDevice.x; <br>        pto-&gt;xfmChange.eM11 -=pto-&gt;xfmChange.eDx; <br>        pto-&gt;xfmChange.eM11 -=((float) pto-&gt;rect.bottom * pto-&gt;xfmChange.eM21); <br>        pto-&gt;xfmChange.eM11 /=(float) pto-&gt;rect.right ; <br> <br>        pto-&gt;xfmChange.eM22 = (float) mouDevice.y; <br>        pto-&gt;xfmChange.eM22 -=pto-&gt;xfmChange.eDy; <br>        pto-&gt;xfmChange.eM22 -=((float) pto-&gt;rect.right  * pto-&gt;xfmChange.eM12); <br>        pto-&gt;xfmChange.eM22 /=(float) pto-&gt;rect.bottom ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (  Size X         0          0   ) <br>      *    (     0           1          0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * yWorld = rect.top == 0; <br>      \*******************************************************/ <br>      case TMSIZEX: { <br>        pto-&gt;xfmChange.eM11 = (float) mouDevice.x; <br>        pto-&gt;xfmChange.eM11 -=pto-&gt;xfmChange.eDx; <br>        pto-&gt;xfmChange.eM11 /=(float) pto-&gt;rect.right ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (     1           0          0   ) <br>      *    (     0        Size Y        0   ) <br>      *    (     0           0          1   ) <br>      * <br>      * xWorld = rect.left == 0; <br>      \*******************************************************/ <br>      case TMSIZEY: { <br>        pto-&gt;xfmChange.eM22 = (float) mouDevice.y; <br>        pto-&gt;xfmChange.eM22 -=pto-&gt;xfmChange.eDy; <br>        pto-&gt;xfmChange.eM22 /=(float) pto-&gt;rect.bottom ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br> <br> <br>      /*******************************************************\ <br>      *    (     1           0          0   ) <br>      *    (     0           1          0   ) <br>      *    (   Move x      Move y       1   ) <br>      * <br>      * xWorld = rect.left == 0; <br>      * yWorld = rect.top == 0; <br>      \*******************************************************/ <br>      case TMMOVE: { <br>        pto-&gt;xfmChange.eDx = (float) mouDevice.x ; <br>        pto-&gt;xfmChange.eDy = (float) mouDevice.y ; <br>        SetWorldTransform (pto-&gt;hdc, &amp;pto-&gt;xfmChange); <br>      } break; <br>    } /* end switch */ <br> <br>    doTrackObject(pto, TROB_PAINT, hwnd, lParam); <br> <br>    return; <br> } <br> <br> <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
