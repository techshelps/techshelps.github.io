<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CSTEXT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3371"></a>CSTEXT.C</h2>
<pre><code>//////////////////////////////////////////////////////////////////////// <br>// <br>// CSTEXT <br>// A sample application that shows how to display complex scripts such <br>// as Arabic, Hebrew, Thai, or Indic scripts. <br>// <br>// This sample works best if executed on a platform enabled for complex  <br>// scripts, such as Arabic, Hebrew, or Thai Windows NT 4.0 or Windows 95, <br>// or Windows NT 5.0 with the appropriate locale installed. <br>// <br>// The WndProc function puts out text typed by the user to the client area <br>// in two ways: 1) using ExtTextOut to put out each character as it  <br>// is typed by the user, and 2) saving each character typed in a  <br>// buffer and putting out the whole buffer using ExtTextOut. <br>// <br>// If you run the program on a system that supports complex scripts, such as <br>// Arabic, Hebrew, or Thai Windows NT, and switch the keyboard to one of  <br>// those languages, you will see different results in the two output lines. <br>// For example, on Arabic Windows NT, the line of characters displayed one  <br>// by one will show only the stand-alone Arabic characters, without joining,  <br>// and without the proper bidirectional layout. The line displayed using  <br>// the whole buffer will be shown correctly <br>// <br>// Choose the help menu for guidelines on programming for complex scripts. <br>// <br>// Written by F. Avery Bishop, with advice from David C. W. Brown. <br>// <br>// Copyright (c) 1997, Microsoft Corporation. All rights reserved. <br>// <br>///////////////////////////////////////////////////////////////////////// <br> <br>#include "cstext.h" <br>#include &lt;stdarg.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;tchar.h&gt; <br>#include "resource.h" <br> <br>#ifndef UNICODE <br>#pragma message("Warning: This sample works best as a Unicode application") <br>#endif <br> <br>// Global variables <br>int         g_xStartOneChar = XSTART ;  // X position to display next character <br>HINSTANCE   g_hInstance ; <br>TCHAR       g_szTitle[MAX_MESSAGE] ;    // Title bar text <br> <br>// Function Prototypes, in the order defined <br>LRESULT CALLBACK WndProc         (HWND , UINT , WPARAM , LPARAM) ; <br>BOOL CALLBACK    EditDialogProc  (HWND , UINT , WPARAM , LPARAM) ; <br>BOOL CALLBACK    HelpDialogProc  (HWND , UINT , WPARAM , LPARAM) ; <br>void             InitializeFont  (HWND , LONG, LPCHOOSEFONT , LPLOGFONT) ; <br>BOOL             InitApplication (HINSTANCE , LPTSTR) ; <br>BOOL             InitInstance    (HINSTANCE , LPTSTR , int) ; <br>int              RcMessageBox    (HWND , int , int , ...) ; <br> <br>// <br>//   FUNCTION: WndProc (HWND, UINT, WPARAM, LPARAM) <br>// <br>//   PURPOSE: Window Procedure <br>// <br>//   COMMENTS: <br>//          This function puts out text typed by the user to the client area <br>//          in two ways: 1) using ExtTextOut to put out each character as it  <br>//          is typed by the user, and 2) saving each character typed in a  <br>//          buffer and putting out the whole buffer using ExtTextOut.  <br>// <br>LRESULT CALLBACK WndProc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HFONT    hTextFont ;        // Font for text typed by user <br>    static TCHAR    szOutputBuffer[BUFFER_SIZE] ; // Buffer of characters typed <br>    static int      nChars = 0 ;       // Current size of buffer <br>    static RECT     rcBufferLine = {0,0,0,0} ;// Rectangle for the text to be displayed <br>    static UINT     uiAlign = TA_LEFT ;// Alignment and reading order flag <br>    static CHOOSEFONT cf ;             // This is static to keep last values as defaults <br>    static LOGFONT  lf ;               // Same for this. <br>     <br>    PAINTSTRUCT     ps ;               // Standard paint structure <br>    HDC             hDc ;              // HDC used in two ways. See WM_CHAR and WM_PAINT below <br>    SIZE            sOneChar ;         // Used in GetTextExtentPoint32. <br>    // Normally these should be in resources so they can be localized. <br>    TCHAR           szCharLabel[]  <br>                    = TEXT("Characters displayed one by one, as typed:") ; <br>    TCHAR           szBuffLabel[]  <br>                    = TEXT("All text in the line displayed in one call to ExtTextOut:") ; <br>    TEXTMETRIC      tm ; <br>     <br>    int nxStartBuffer, nyStartBuffer ;  // x and y positions to display text. <br>    int cCharWidths ;                   // Count of character widths, used in GetCharWidth32 <br>     <br>    switch (message) <br>    { <br>    case WM_CREATE : <br>         <br>        InitializeFont (hWnd, 20, &amp;cf, &amp;lf) ; // Routine defined below <br>        hTextFont = CreateFontIndirect (&amp;lf) ; <br>         <br>        if (NULL == hTextFont) { <br>            RcMessageBox (hWnd, IDS_CHOOSEFONT_FAILED, MB_ICONEXCLAMATION | MB_OK); <br>            break ; <br>        } ; <br>         <br>        return 0 ; <br>         <br>    case WM_CHAR :  // Process keyboard input <br>         <br>        switch ((TCHAR) wParam) <br>        { <br>        case VK_BACK : <br>             <br>            if (nChars &gt; 0){ <br>                nChars-- ; <br>                 <br>                // Reset starting point for next character output <br>                hDc = GetDC(hWnd) ; <br>                SelectObject(hDc, hTextFont) ; <br>                GetTextExtentPoint32(hDc, szOutputBuffer, nChars, &amp;sOneChar) ; <br>                ReleaseDC(hWnd, hDc) ; <br>                g_xStartOneChar = sOneChar.cx + XSTART; <br>                 <br>                InvalidateRect (hWnd, NULL, TRUE) ; <br>            } <br>            break ; <br>             <br>        case VK_RETURN :     <br>             <br>            // This sample ignores return. Most apps will add CR/LF or exit. <br>            break ; <br>             <br>        case VK_ESCAPE : <br>        case VK_END : <br>        case VK_HOME : <br>             <br>            // Processing other non-printable characters is left as an exercise <br>            break ; <br>             <br>        default: <br>             <br>            // Process all normal characters <br>             <br>        // First use the old (incorrect) method to display only the last <br>        // character typed <br>         <br>            // NOTE: This is an example of what *not* to do, because <br>            // characters that should join or otherwise interact  <br>            // typographically will show as separate, stand alone characters. <br>            hDc = GetDC (hWnd) ; <br>            SelectObject (hDc, hTextFont) ; <br>            SetBkMode (hDc, TRANSPARENT) ; <br>            ExtTextOut (hDc, g_xStartOneChar, YSTART, 0, <br>                NULL, (LPCTSTR) &amp;wParam, 1, NULL) ; <br>             <br>            // Get the next character position <br>            GetCharWidth (hDc, (UINT) wParam, (UINT) wParam, &amp;cCharWidths) ; <br>            // This assumes left to right scripts, so it will break on <br>            // Arabic and Hebrew! <br>            g_xStartOneChar += cCharWidths ;  <br> <br>            ReleaseDC (hWnd, hDc) ; <br>             <br>        // Next, display the whole buffer of all characters typed in so far <br> <br>            szOutputBuffer[nChars] = (TCHAR) wParam ; <br>            if (nChars &lt; BUFFER_SIZE-1) { <br>                nChars++ ; <br>            } <br>            // This will generate a WM_PAINT message. In the processing  <br>            // of WM_PAINT below, we display the text buffer in the  <br>            // rectangle rcBufferLine. This is the recommended approach. <br>            InvalidateRect (hWnd, &amp;rcBufferLine, TRUE) ; <br>        } <br>         <br>        return 0 ; <br>     <br>    case WM_PAINT : <br>         <br>        hDc = BeginPaint (hWnd, &amp;ps) ; <br>         <br>        SelectObject (hDc, hTextFont) ; <br>         <br>        // Get line positions for the current font <br>        GetTextMetrics (hDc, &amp;tm) ; <br>         <br>        nyStartBuffer = YSTART + 3*tm.tmHeight ; <br>         <br>        GetClientRect (hWnd, &amp;rcBufferLine) ; <br>         <br>        rcBufferLine.top = nyStartBuffer ; <br>        rcBufferLine.bottom = nyStartBuffer + tm.tmHeight ; <br>         <br>        // Set the x position for right or left aligned text <br>        if (uiAlign &amp; TA_RIGHT) { <br>            nxStartBuffer = rcBufferLine.right - XSTART ; <br>        } else { <br>            nxStartBuffer = XSTART ; <br>        } <br>         <br>        SetTextAlign (hDc, uiAlign) ; <br>         <br>        // Write the whole text buffer in the "character by character" rectangle <br>        // Note how the complex script comes out right this time. <br>        // This only happens when the whole client area is invalidated, i.e.,  <br>        // when the user types backspace, clears the buffer, or changes the  <br>        // font, or when the window is covered and uncovered. <br>        ExtTextOut (hDc, nxStartBuffer, YSTART, ETO_OPAQUE,  <br>            NULL, szOutputBuffer, nChars, NULL) ; <br>         <br>        // Write the whole text buffer in the line buffer rectangle <br>        // This happens every time the user enters a character, which  <br>        // is why this line always looks right, even for complex scripts. <br>        ExtTextOut (hDc, nxStartBuffer, nyStartBuffer, ETO_OPAQUE,  <br>            &amp;rcBufferLine, szOutputBuffer, nChars, NULL) ; <br>         <br>        // Write out labels describing the text <br>        SelectObject(hDc, GetStockObject(ANSI_VAR_FONT)) ; <br>        SetTextAlign(hDc, TA_LEFT) ; <br>        GetTextMetrics (hDc, &amp;tm) ; <br>         <br>        ExtTextOut (hDc, XSTART, YSTART-tm.tmHeight, ETO_OPAQUE,  <br>            NULL, szCharLabel, lstrlen(szCharLabel), NULL) ; <br> <br>        ExtTextOut (hDc, XSTART, nyStartBuffer-tm.tmHeight, ETO_OPAQUE,  <br>            NULL, szBuffLabel, lstrlen(szBuffLabel), NULL) ; <br>         <br>        EndPaint (hWnd, &amp;ps) ; <br>         <br>        return 0 ; <br>         <br>    case WM_COMMAND : <br>         <br>        switch (LOWORD(wParam))  <br>        { <br>        case IDM_EDIT_CLEAR : <br>            // Clear the character buffer <br>            nChars = 0 ; <br>             <br>            // Reset starting point for next character output <br>            g_xStartOneChar = XSTART ; <br>            InvalidateRect (hWnd, NULL, TRUE) ; <br>             <br>            break ; <br>             <br>        case IDM_EDITCONTROL : <br>            // Use an edit control to enter and display text. <br>            // This is the recommended approach, because all <br>            // complex script processing is handled by the system. <br>            // Complex script support is also available in the  <br>            // Richedit control (not shown here). <br>            DialogBox (g_hInstance, MAKEINTRESOURCE(IDD_CSSAMPLE), NULL, EditDialogProc) ; <br>             <br>            break ; <br>             <br>        case IDM_EDIT_TOGGLEALIGN : <br>            // This aligns the text to the left or right <br>            // edge of the client area. It is NOT the same <br>            // as reading order. <br>            if (uiAlign &amp; TA_RIGHT){ <br>                uiAlign = uiAlign &amp; ~TA_RIGHT ; <br>            } else { <br>                uiAlign = uiAlign | TA_RIGHT &amp; ~TA_LEFT ; <br>            } <br>             <br>            InvalidateRect (hWnd, NULL, TRUE) ; <br>             <br>            break ; <br>             <br>        case IDM_EDIT_TOGGLEREADING : <br>            // This will set the reading order as LTR, as is used <br>            // for European and Asian scripts, or RTL, the most common <br>            // reading area in Middle Eastern scripts such as Arabic <br>            // and Hebrew. <br>            uiAlign ^= TA_RTLREADING ; <br>            InvalidateRect (hWnd, NULL, TRUE) ; <br>             <br>            break ; <br>             <br>        case IDM_EDIT_SETFONT : <br>            // Let the user change font. <br>            ChooseFont (&amp;cf) ; <br>            if (hTextFont){ <br>                DeleteObject (hTextFont) ; <br>            } <br>             <br>            hTextFont = CreateFontIndirect (&amp;lf) ; <br>             <br>            if (NULL == hTextFont) { <br>                RcMessageBox (hWnd, IDS_CHOOSEFONT_FAILED, MB_ICONEXCLAMATION | MB_OK) ; <br>                break ; <br>            } <br>             <br>            RcMessageBox(hWnd, IDS_FONTCHANGED , MB_OK, lf.lfFaceName) ; <br>             <br>            // Reset starting point for next character output <br>            hDc = GetDC(hWnd) ; <br>            SelectObject(hDc, hTextFont) ; <br>            GetTextExtentPoint32(hDc, szOutputBuffer, nChars, &amp;sOneChar) ; <br>            ReleaseDC(hWnd, hDc) ; <br>            g_xStartOneChar = sOneChar.cx + XSTART ; <br>             <br>            InvalidateRect (hWnd, NULL, TRUE) ; <br>             <br>            break ; <br>             <br>        case IDM_ABOUT_HELP : <br>             <br>            DialogBox (g_hInstance, MAKEINTRESOURCE(IDD_HELP), NULL, HelpDialogProc) ; <br>             <br>            break; <br>             <br>        case IDM_ABOUT_ABOUT : <br>             <br>            DialogBox (g_hInstance, MAKEINTRESOURCE(IDD_ABOUT), NULL, HelpDialogProc); <br>             <br>            break ; <br>             <br>        case IDM_EXIT : <br>             <br>            DestroyWindow (hWnd) ; <br>             <br>            break ; <br>             <br>        default : <br>             <br>            return 0 ;   <br>        } <br>         <br>        return 0 ; <br>         <br>        case WM_DESTROY : <br>             <br>            PostQuitMessage (0) ; <br>             <br>            return 0 ; <br>             <br>        default :  <br>            return (DefWindowProc(hWnd, message, wParam, lParam)) ; <br>   } <br>} <br> <br>// <br>//   FUNCTION: BOOL CALLBACK EditDialogProc (HWND , UINT , WPARAM , LPARAM) <br>// <br>//   PURPOSE: Dialog procedure for the edit control dialog box. <br>// <br>//   COMMENTS: <br>//        This is standard processing for edit controls. <br>// <br>BOOL CALLBACK EditDialogProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    static HFONT        hEditFont ; <br>    static CHOOSEFONT   cf ;  <br>    static LOGFONT      lf ; <br> <br>    HWND                hWndEdit ; <br>     <br>    switch (uMsg) <br>    { <br>    case WM_INITDIALOG : <br>         <br>        InitializeFont (hDlg, 24, &amp;cf, &amp;lf) ; <br>        hEditFont = CreateFontIndirect (&amp;lf) ; <br>         <br>        // Set font of edit control <br>        SendDlgItemMessage (hDlg, ID_EDITCONTROL, WM_SETFONT,  <br>            (WPARAM) hEditFont,  MAKELPARAM(TRUE, 0)) ; <br>         <br>        return TRUE ; <br>         <br>    case WM_CLOSE : <br>         <br>        EndDialog (hDlg, wParam) ;  <br>         <br>        return 0 ; <br>         <br>    case WM_COMMAND : <br>         <br>        switch (wParam) <br>        { <br>        case IDE_EDIT_FONT : <br>             <br>            if (hEditFont) { <br>                DeleteObject (hEditFont) ; <br>            } <br>             <br>            ChooseFont (&amp;cf) ; <br>            hEditFont = CreateFontIndirect (&amp;lf) ; <br>             <br>            SendDlgItemMessage (hDlg, ID_EDITCONTROL, WM_SETFONT,  <br>                (WPARAM) hEditFont,  MAKELPARAM(TRUE, 0)) ; <br>             <br>            break ; <br>             <br>        case IDE_CLEAR : <br>             <br>            hWndEdit = GetDlgItem (hDlg, ID_EDITCONTROL) ; <br>            SetWindowText (hWndEdit, TEXT("")) ; <br>             <br>            break ; <br>             <br>        case IDE_CLOSE : <br>             <br>            DeleteObject (hEditFont) ; <br>            EndDialog (hDlg, wParam) ;  <br>        } <br>    } <br>     <br>    return FALSE ; <br>} <br> <br>// <br>//   FUNCTION: BOOL CALLBACK HelpDialogProc (HWND , UINT , WPARAM , LPARAM) <br>// <br>//   PURPOSE: Dialog procedure for the Help dialog box. <br>// <br>//   COMMENTS: <br>//        This does nothing but close the dialog box. <br>// <br>BOOL CALLBACK HelpDialogProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>    case WM_CLOSE : <br>         <br>        EndDialog (hDlg, wParam) ;  <br>        return 0 ; <br>         <br>    case WM_COMMAND : <br>         <br>        switch (wParam) <br>        { <br>        case IDOK : <br>             <br>            EndDialog (hDlg, wParam) ;  <br>        } <br>    } <br>     <br>    return FALSE ; <br>} <br> <br>// <br>//   FUNCTION: _tWinMain (HINSTANCE , HINSTANCE , LPTSTR , int) <br>// <br>//   PURPOSE: Standard WinMain function <br>// <br>//   COMMENTS: <br>//        The prototype is _tWinMain, so it can be compiled either as <br>//        a Unicode or an ANSI application.  <br>// <br>int WINAPI _tWinMain (HINSTANCE hInstance, HINSTANCE hPrev,  <br>                      LPSTR pszCmdLine, int nCmdShow)  <br>{ <br>    TCHAR szAppName[] = TEXT("Complex Script Display") ; <br>    MSG msg ; <br>    HANDLE hAccelTable ; <br>     <br>    // Perform application initialization: <br>    if (!InitApplication (hInstance, szAppName)) { <br>        return FALSE ; <br>    } <br>    // Perform instance initialization: <br>    if (!InitInstance (hInstance, szAppName, nCmdShow)) { <br>        return FALSE ; <br>    } <br>     <br>    hAccelTable = LoadAccelerators (hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1)) ; <br>     <br>    if (!hAccelTable) { <br>        return 0 ; <br>    } <br>     <br>    // Main message loop: <br>    while (GetMessage (&amp;msg, NULL, 0, 0))  <br>    { <br>        if (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg)) { <br>            TranslateMessage (&amp;msg) ; <br>            DispatchMessage (&amp;msg) ; <br>        } <br>    } <br>    return 0 ; <br>}  <br> <br>// <br>//   FUNCTION: InitializeFont (HWND , LONG , LPCHOOSEFONT , LPLOGFONT) <br>// <br>//   PURPOSE:  Fills in font structures with initial values.  <br>// <br>//   REMARKS:  Since it contains only assignment statements, this function does no <br>//             error checking, has no return value.. <br>// <br>void InitializeFont (HWND hWnd, LONG lHeight, LPCHOOSEFONT lpCf, LPLOGFONT lpLf) <br>{ <br>    lpCf-&gt;lStructSize   = sizeof (CHOOSEFONT) ; <br>    lpCf-&gt;hwndOwner     = hWnd ; <br>    lpCf-&gt;hDC           = NULL ; <br>    lpCf-&gt;lpLogFont     = lpLf; <br>    lpCf-&gt;iPointSize    = 10; <br>    lpCf-&gt;Flags         = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT <br>        | CF_NOSIZESEL ; <br>    lpCf-&gt;rgbColors     = RGB (0,0,0); <br>    lpCf-&gt;lCustData     = 0; <br>    lpCf-&gt;lpfnHook      = NULL; <br>    lpCf-&gt;lpTemplateName= NULL; <br>    lpCf-&gt;hInstance     = g_hInstance; <br>    lpCf-&gt;lpszStyle     = NULL; <br>    lpCf-&gt;nFontType     = SIMULATED_FONTTYPE; <br>    lpCf-&gt;nSizeMin      = 0; <br>    lpCf-&gt;nSizeMax      = 0; <br>     <br>    lpLf-&gt;lfHeight      = lHeight ;  <br>    lpLf-&gt;lfWidth       = 0 ;  <br>    lpLf-&gt;lfEscapement  = 0 ;  <br>    lpLf-&gt;lfOrientation = 0 ;  <br>    lpLf-&gt;lfWeight      = FW_NORMAL ;  <br>    lpLf-&gt;lfItalic      = FALSE ;  <br>    lpLf-&gt;lfUnderline   = FALSE ;  <br>    lpLf-&gt;lfStrikeOut   = FALSE ;  <br>    lpLf-&gt;lfCharSet     = DEFAULT_CHARSET ;  <br>    lpLf-&gt;lfOutPrecision= OUT_DEFAULT_PRECIS ;  <br>    lpLf-&gt;lfClipPrecision = CLIP_DEFAULT_PRECIS ;  <br>    lpLf-&gt;lfQuality     = DEFAULT_QUALITY ;  <br>    lpLf-&gt;lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE ;  <br>    lstrcpy(lpLf-&gt;lfFaceName, TEXT("Arial")) ; <br>    lpLf-&gt;lfFaceName[LF_FACESIZE] = 0 ;  <br>} <br> <br>// <br>//   FUNCTION: InitApplication(HINSTANCE, LPTSTR) <br>// <br>//   PURPOSE:  Fills in window class structure with parameters that describe <br>//   the main window, and registers the window. <br>// <br>BOOL InitApplication (HINSTANCE hInstance, LPTSTR szAppName) <br>{ <br>     <br>    WNDCLASS  wc ;  <br>     <br>    wc.style         = CS_HREDRAW | CS_VREDRAW ; <br>    wc.lpfnWndProc   = (WNDPROC) WndProc ; <br>    wc.cbClsExtra    = 0 ; <br>    wc.cbWndExtra    = 0 ; <br>    wc.hInstance     = hInstance ; <br>    wc.hIcon         = LoadIcon  (NULL, IDI_APPLICATION) ;  <br>    wc.hCursor       = LoadCursor  (NULL, IDC_ARROW) ; <br>    wc.hbrBackground =  (HBRUSH) (COLOR_WINDOW+1) ; <br>    wc.lpszMenuName  = MAKEINTRESOURCE (IDR_MENU1) ; <br>    wc.lpszClassName = szAppName ; <br>     <br>    return  (RegisterClass(&amp;wc)) ; <br>} <br> <br>// <br>//   FUNCTION: InitInstance (HANDLE, LPTSTR, int) <br>// <br>//   PURPOSE: Saves instance handle and creates main window <br>// <br>//   COMMENTS: <br>// <br>//        This function saved the instance handle in a global variable and <br>//        created and displays the main program window. <br>// <br> <br>BOOL InitInstance (HINSTANCE hInstance, LPTSTR szAppName, int nCmdShow) <br>{ <br>    HWND hWnd ; <br>     <br>    g_hInstance = hInstance ; // Store instance handle in global variable <br>     <br>    LoadString (hInstance, IDS_TITLE, g_szTitle, MAX_MESSAGE) ; <br>     <br>    hWnd = CreateWindow (szAppName, g_szTitle, WS_OVERLAPPEDWINDOW, <br>        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, <br>        NULL, NULL, hInstance, NULL) ; <br>     <br>    if (!hWnd) { <br>        return FALSE ; <br>    } <br>     <br>    ShowWindow (hWnd, nCmdShow) ; <br>    UpdateWindow (hWnd) ; <br>     <br>    return TRUE ; <br>} <br>// <br>//  Function RcMessageBox (HWND, INT, INT, ...) <br>// <br>//  Purpose: Display a message box with formated output similar to sprintf <br>// <br>//  Remarks: <br>//      This function loads the string identified by nMessageID from the  <br>//      resource segment, uses vsprintf to format it using the variable <br>//      parameters, and displays it to the user in a message box using the <br>//      icon specified by nIcons. <br>// <br> <br>int RcMessageBox (HWND hWnd, int nMessageID, int nIcons, ...) <br>{ <br>    // This can be changed to get the current lang id. <br>    WORD wCurrentLang = MAKELANGID (LANG_ENGLISH, SUBLANG_ENGLISH_US) ; <br>    TCHAR szLoadBuff[MAX_MESSAGE], szOutPutBuff[3*MAX_MESSAGE] ; <br>    va_list valArgs ; <br>     <br>    va_start (valArgs, nIcons) ; <br>     <br>    LoadString (g_hInstance, nMessageID, szLoadBuff, MAX_MESSAGE) ; <br>     <br>    wvsprintf (szOutPutBuff, szLoadBuff, valArgs) ; <br>     <br>    va_end (valArgs) ; <br>     <br>    return (MessageBoxEx (hWnd, szOutPutBuff, g_szTitle, nIcons, wCurrentLang)) ; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
