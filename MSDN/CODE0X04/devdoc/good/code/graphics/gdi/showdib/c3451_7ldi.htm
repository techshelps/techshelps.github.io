<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SHOWDIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3456"></a>SHOWDIB.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************* <br> *                                                                             * <br> *  PROGRAM     : ShowDIB.c                                                    * <br> *                                                                             * <br> *  PURPOSE     : Application to illustrate the use of the GDI                 * <br> *                DIB (Device Independent Bitmap) and Palette manager          * <br> *                functions.                                                   * <br> *                                                                             * <br> *  FUNCTIONS   : WinMain ()             -  Creates the app. window and enters * <br> *                                          the message loop.                  * <br> *                                                                             * <br> *                WndProc()              -  Processes app. window messages.    * <br> *                                                                             * <br> *                MenuCommand()          -  Processes menu commands.           * <br> *                                                                             * <br> *                FreeDIB()              -  Frees currently active objects.    * <br> *                                                                             * <br> *                InitDIB()              -  Reads DIB from a file and loads it.* <br> *                                                                             * <br> *******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "showdib.h" <br>#include &lt;commdlg.h&gt; <br> <br>DIBPARAMS      DIBParams;                  /* params for the SETSCALING escape */ <br>CHAR           achFileName[128]; <br>DWORD          dwOffset; <br>NPLOGPALETTE   pLogPal; <br>HPALETTE       hpalSave = NULL; <br>HINSTANCE      hInst ; <br>RECT           rcClip; <br>static         HCURSOR hcurSave; <br> <br>BOOL    fPalColors  = FALSE;          /* TRUE if the current DIB's color table   */ <br>                                      /* contains palette indexes not rgb values */ <br>UINT    nAnimating  = 0;              /* Palette animation count                 */ <br>WORD    UpdateCount = 0; <br> <br>BOOL    bUpdateColors = TRUE;  /* Directly update screen colors                */ <br>BOOL    bDIBToDevice  = FALSE; /* Use SetDIBitsToDevice() to BLT data.         */ <br>BOOL    bNoUgly       = FALSE; /* Make window black on a WM_PALETTEISCHANGING  */ <br>BOOL    bLegitDraw    = FALSE; /* We have a valid bitmap to draw               */ <br> <br>CHAR    szBitmapExt[] = "*.BMP; *.DIB; *.RLE";     /* possible file extensions */ <br>WORD    wTransparent  = TRANSPARENT;               /* Mode of DC               */ <br>CHAR    szAppName[]   = "ShowDIB" ;                /* App. name                */ <br> <br>HPALETTE hpalCurrent   = NULL;         /* Handle to current palette            */ <br>HANDLE   hdibCurrent   = NULL;         /* Handle to current memory DIB         */ <br>HBITMAP  hbmCurrent    = NULL;         /* Handle to current memory BITMAP      */ <br>HANDLE   hbiCurrent    = NULL;         /* Handle to current bitmap info struct */ <br>HWND     hWndApp;                      /* Handle to app. window                */ <br> <br>/* Styles of app. window */ <br>DWORD          dwStyle = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | <br>                         WS_MAXIMIZEBOX | WS_MINIMIZEBOX | WS_THICKFRAME; <br> <br>VOID PrintDIB (HWND hWnd, HDC hDC, INT x, INT y, INT dx, INT dy); <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WinMain(HANDLE, HANDLE, LPSTR, int)                        * <br> *                                                                          * <br> *  PURPOSE    : Creates the app. window and enters the message loop.       * <br> *                                                                          * <br> ****************************************************************************/ <br>int APIENTRY WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow <br>    ) <br>{ <br>     HWND        hWnd ; <br>     WNDCLASS    wndclass ; <br>     MSG         msg ; <br>     int         xScreen, yScreen ; <br>     CHAR        ach[40]; <br> <br>     hInst = hInstance ; <br> <br>     /* Initialize clip rectangle */ <br>     SetRectEmpty(&amp;rcClip); <br> <br>     if (!hPrevInstance) { <br>         wndclass.style         = CS_DBLCLKS; <br>         wndclass.lpfnWndProc   = (WNDPROC) WndProc ; <br>         wndclass.cbClsExtra    = 0 ; <br>         wndclass.cbWndExtra    = 0 ; <br>         wndclass.hInstance     = hInstance ; <br>         wndclass.hIcon         = LoadIcon(hInst, "SHOWICON"); <br>         wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ; <br>         wndclass.hbrBackground = GetStockObject (BLACK_BRUSH) ; <br>         wndclass.lpszMenuName  = szAppName ; <br>         wndclass.lpszClassName = szAppName ; <br> <br>         if (!RegisterClass (&amp;wndclass)) <br>                 return FALSE ; <br>     } <br> <br>     if (!GetProfileString("extensions", "bmp", "", ach, sizeof(ach))) <br>             WriteProfileString("extensions", "bmp", "showdib.exe ^.bmp"); <br>     if (!GetProfileString("extensions", "dib", "", ach, sizeof(ach))) <br>             WriteProfileString("extensions", "dib", "showdib.exe ^.dib"); <br> <br>     /* Save the pointer to the command line */ <br>     lstrcpy(achFileName, lpCmdLine); <br> <br>     xScreen = GetSystemMetrics (SM_CXSCREEN) ; <br>     yScreen = GetSystemMetrics (SM_CYSCREEN) ; <br> <br>     /* Create the app. window */ <br>     hWnd = CreateWindow( szAppName, <br>                          szAppName, <br>                          dwStyle, <br>                          CW_USEDEFAULT, <br>                          0, <br>                          xScreen / 2, <br>                          yScreen / 2, <br>                          NULL, <br>                          NULL, <br>                          hInstance, <br>                          NULL) ; <br> <br>     ShowWindow (hWndApp = hWnd, nCmdShow) ; <br> <br>     /* Enter message loop */ <br>     while (GetMessage (&amp;msg, NULL, 0, 0)) { <br>         TranslateMessage (&amp;msg) ; <br>         DispatchMessage (&amp;msg) ; <br>     } <br> <br>     return msg.wParam ; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WndProc (hWnd, iMessage, wParam, lParam)                   * <br> *                                                                          * <br> *  PURPOSE    : Processes window messages.                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG    APIENTRY WndProc ( <br>    HWND     hWnd , <br>    UINT     iMessage , <br>    UINT     wParam , <br>    LONG     lParam ) <br> <br>{ <br>    PAINTSTRUCT      ps; <br>    HDC              hDC; <br>    HANDLE           h; <br>    INT              i; <br>    INT              iMax; <br>    INT              iMin; <br>    INT              iPos; <br>    INT              dn; <br>    RECT             rc,Rect; <br>    HPALETTE         hOldPal; <br>    HMENU            hMenu; <br>    CHAR             lpBuffer[128]; <br> <br>    switch (iMessage) { <br>        case WM_DESTROY: <br>                /* Clean up and quit */ <br>                FreeDib(); <br>                PostQuitMessage(0); <br>                break ; <br> <br>        case WM_CREATE: <br>                /* Allocate space for our logical palette */ <br>                pLogPal = (NPLOGPALETTE) LocalAlloc( LMEM_FIXED, <br>                                                     (sizeof(LOGPALETTE) + <br>                                                     (sizeof(PALETTEENTRY)*(MAXPALETTE)))); <br>        if(!pLogPal){ <br>            LoadString(hInst, IDS_MEMLOW, lpBuffer, sizeof(lpBuffer)); <br>            MessageBox(hWnd, lpBuffer, NULL, MB_OK | MB_ICONHAND); <br>            PostQuitMessage(0); <br>            break; <br>        } <br> <br>// Temporary workaround.  lpCmdLine points to exe name, not first parameter <br>                /* If DIB initialization fails, quit */ <br>//              if (achFileName[0] &amp;&amp; !InitDIB(hWnd)) <br>//                      PostQuitMessage (3) ; <br> <br>                /* fall through */ <br> <br>        case WM_WININICHANGE: <br> <br>              hMenu = GetMenu(hWnd); <br>              if ( hDC = GetPrinterDC1() ) { <br>                    EnableMenuItem( hMenu, <br>                                    IDM_PRINT, <br>                                    (RC_DIBTODEV &amp; <br>                                     GetDeviceCaps(hDC, RASTERCAPS)) ? <br>                                     MF_ENABLED : <br>                                     MF_GRAYED | MF_DISABLED); <br>                  DeleteDC(hDC); <br>              } <br>                break; <br> <br>        case WM_PALETTEISCHANGING: <br>                /* if SHOWDIB was not responsible for palette change and if <br>                 * ok to hide changes, paint app. window black. <br>                 */ <br>                if (wParam != (UINT)(hWnd &amp;&amp; bNoUgly)) { <br>                    GetClientRect(hWnd, &amp;Rect); <br> <br>                    hDC = GetDC(hWnd); <br>                    FillRect( hDC, (LPRECT) &amp;Rect, GetStockObject(BLACK_BRUSH)); <br>                    ReleaseDC(hWnd, hDC); <br>                } <br>                break; <br> <br>        case WM_ACTIVATE: <br>                if (!GET_WM_ACTIVATE_STATE(wParam, lParam))  /* app. is being de-activated */ <br>                   break; <br>                /* If the app. is moving to the foreground, fall through and <br>                 * redraw full client area with the newly realized palette, <br>                 * if the palette has changed. <br>                 */ <br> <br>        case WM_QUERYNEWPALETTE: <br>                /* If palette realization causes a palette change, <br>                 * we need to do a full redraw. <br>                 */ <br>                if (bLegitDraw) { <br>                    hDC = GetDC (hWnd); <br>                    hOldPal = SelectPalette (hDC, hpalCurrent, 0); <br> <br>                    i = RealizePalette(hDC); <br> <br>                    SelectPalette (hDC, hOldPal, 0); <br>                    ReleaseDC (hWnd, hDC); <br> <br>                    if (i) { <br>                        InvalidateRect (hWnd, (LPRECT) (NULL), 1); <br>                        UpdateCount = 0; <br>                        return 1; <br>                    } else <br>                        return FALSE; <br>                } <br>                else <br>                    return FALSE; <br>                break; <br> <br>        case WM_PALETTECHANGED: <br>                /* if SHOWDIB was not responsible for palette change and if <br>                 * palette realization causes a palette change, do a redraw. <br>                 */ <br>                 if ((HWND)wParam != hWnd){ <br>                    if (bLegitDraw){ <br>                        hDC = GetDC (hWnd); <br>                        hOldPal = SelectPalette (hDC, hpalCurrent, 0); <br> <br>                        i = RealizePalette (hDC); <br> <br>                        if (i){ <br>                            if (bUpdateColors){ <br>                                UpdateColors (hDC); <br>                                UpdateCount++; <br>                            } <br>                            else <br>                                InvalidateRect (hWnd, (LPRECT) (NULL), 1); <br>                        } <br> <br>                        SelectPalette (hDC, hOldPal, 0); <br>                        ReleaseDC (hWnd, hDC); <br>                    } <br>                } <br>                break; <br> <br>        case WM_RENDERALLFORMATS: <br>                /* Ensure that clipboard data can be rendered even tho' <br>                 * app. is being destroyed. <br>                 */ <br>                SendMessage(hWnd,WM_RENDERFORMAT,CF_DIB,0L); <br>                SendMessage(hWnd,WM_RENDERFORMAT,CF_BITMAP,0L); <br>                SendMessage(hWnd,WM_RENDERFORMAT,CF_PALETTE,0L); <br>                break; <br> <br>        case WM_RENDERFORMAT: <br>                /* Format data in manner specified and pass the data <br>                 * handle to clipboard. <br>                 */ <br>                if (h = RenderFormat(wParam)) <br>                    SetClipboardData((WORD)wParam,h); <br>                break; <br> <br>        case WM_COMMAND: <br>                /* Process menu commands */ <br>                return MenuCommand(hWnd, LOWORD(wParam)); <br>                break; <br> <br>        case WM_TIMER: <br>                /* Signal for palette animation */ <br>                hDC = GetDC(hWnd); <br>                hOldPal = SelectPalette(hDC, hpalCurrent, 0); <br>                { <br>                    PALETTEENTRY peTemp; <br> <br>                    /* Shift all palette entries left by one position and wrap <br>                     * around the first entry <br>                     */ <br>                    peTemp = pLogPal-&gt;palPalEntry[0]; <br>                    for (i = 0; i &lt; (pLogPal-&gt;palNumEntries - 1); i++) <br>                         pLogPal-&gt;palPalEntry[i] = pLogPal-&gt;palPalEntry[i+1]; <br>                    pLogPal-&gt;palPalEntry[i] = peTemp; <br>                } <br>                /* Replace entries in logical palette with new entries*/ <br>                AnimatePalette(hpalCurrent, 0, pLogPal-&gt;palNumEntries, pLogPal-&gt;palPalEntry); <br> <br>                SelectPalette(hDC, hOldPal, 0); <br>                ReleaseDC(hWnd, hDC); <br> <br>                /* Decrement animation count and terminate animation <br>                 * if it reaches zero <br>                 */ <br>                if (!(--nAnimating)) <br>                    PostMessage(hWnd,WM_COMMAND,IDM_ANIMATE0,0L); <br>                break; <br> <br>        case WM_PAINT: <br>                /* If we have updated more than once, the rest of our <br>                 * window is not in some level of degradation worse than <br>                 * our redraw...  we need to redraw the whole area <br>                 */ <br>                if (UpdateCount &gt; 1) { <br>                    BeginPaint(hWnd, &amp;ps); <br>                    EndPaint(hWnd, &amp;ps); <br>                    UpdateCount = 0; <br>                    InvalidateRect(hWnd, (LPRECT) (NULL), 1); <br>                    break; <br>                } <br> <br>                hDC = BeginPaint(hWnd, &amp;ps); <br>                AppPaint(hWnd, <br>                         hDC, <br>                         GetScrollPos(hWnd,SB_HORZ), <br>                         GetScrollPos(hWnd,SB_VERT) ); <br>                EndPaint(hWnd, &amp;ps); <br>                break ; <br> <br>        case WM_SIZE: <br>            SetScrollRanges(hWnd); <br>            break; <br> <br>        case WM_KEYDOWN: <br>            /* Translate keyboard messages to scroll commands */ <br>            switch (wParam) { <br>                case VK_UP: <br>                    PostMessage (hWnd, WM_VSCROLL, SB_LINEUP,   0L); <br>                    break; <br> <br>                case VK_DOWN: <br>                    PostMessage (hWnd, WM_VSCROLL, SB_LINEDOWN, 0L); <br>                    break; <br> <br>                case VK_PRIOR: <br>                    PostMessage (hWnd, WM_VSCROLL, SB_PAGEUP,   0L); <br>                    break; <br> <br>                case VK_NEXT: <br>                    PostMessage (hWnd, WM_VSCROLL, SB_PAGEDOWN, 0L); <br>                    break; <br> <br>                case VK_HOME: <br>                    PostMessage (hWnd, WM_HSCROLL, SB_PAGEUP,   0L); <br>                    break; <br> <br>                case VK_END: <br>                    PostMessage (hWnd, WM_HSCROLL, SB_PAGEDOWN, 0L); <br>                    break; <br> <br>                case VK_LEFT: <br>                    PostMessage (hWnd, WM_HSCROLL, SB_LINEUP,   0L); <br>                    break; <br> <br>                case VK_RIGHT: <br>                    PostMessage (hWnd, WM_HSCROLL, SB_LINEDOWN, 0L); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_KEYUP: <br>            switch (wParam) { <br>               case VK_UP: <br>               case VK_DOWN: <br>               case VK_PRIOR: <br>               case VK_NEXT: <br>                  PostMessage (hWnd, WM_VSCROLL, SB_ENDSCROLL, 0L); <br>                  break; <br> <br>               case VK_HOME: <br>               case VK_END: <br>               case VK_LEFT: <br>               case VK_RIGHT: <br>                  PostMessage (hWnd, WM_HSCROLL, SB_ENDSCROLL, 0L); <br>                  break; <br>            } <br>            break; <br> <br>        case WM_VSCROLL: <br>            /* Calculate new vertical scroll position */ <br>            GetScrollRange (hWnd, SB_VERT, &amp;iMin, &amp;iMax); <br>            iPos = GetScrollPos (hWnd, SB_VERT); <br>            GetClientRect (hWnd, &amp;rc); <br> <br>            switch (GET_WM_VSCROLL_CODE(wParam, lParam)) { <br>                case SB_LINEDOWN: <br>                    dn =  rc.bottom / 16 + 1; <br>                    break; <br> <br>                case SB_LINEUP: <br>                    dn = -rc.bottom / 16 + 1; <br>                    break; <br> <br>                case SB_PAGEDOWN: <br>                    dn =  rc.bottom / 2  + 1; <br>                    break; <br> <br>                case SB_PAGEUP: <br>                    dn = -rc.bottom / 2  + 1; <br>                    break; <br> <br>                case SB_THUMBTRACK: <br>                case SB_THUMBPOSITION: <br>                    dn = GET_WM_VSCROLL_POS(wParam, lParam)-iPos; <br>                    break; <br> <br>                default: <br>                    dn = 0; <br>                    break; <br>            } <br>            /* Limit scrolling to current scroll range */ <br>            if (dn = BOUND (iPos + dn, iMin, iMax) - iPos) { <br>                ScrollWindow (hWnd, 0, -dn, NULL, NULL); <br>                SetScrollPos (hWnd, SB_VERT, iPos + dn, TRUE); <br>            } <br>            break; <br> <br>        case WM_HSCROLL: <br>            /* Calculate new horizontal scroll position */ <br>            GetScrollRange (hWnd, SB_HORZ, &amp;iMin, &amp;iMax); <br>            iPos = GetScrollPos (hWnd, SB_HORZ); <br>            GetClientRect (hWnd, &amp;rc); <br> <br>            switch (GET_WM_HSCROLL_CODE(wParam, lParam)) { <br>                case SB_LINEDOWN: <br>                    dn =  rc.right / 16 + 1; <br>                    break; <br> <br>                case SB_LINEUP: <br>                    dn = -rc.right / 16 + 1; <br>                    break; <br> <br>                case SB_PAGEDOWN: <br>                    dn =  rc.right / 2  + 1; <br>                    break; <br> <br>                case SB_PAGEUP: <br>                    dn = -rc.right / 2  + 1; <br>                    break; <br> <br>                case SB_THUMBTRACK: <br>                case SB_THUMBPOSITION: <br>                    dn = GET_WM_HSCROLL_POS(wParam, lParam)-iPos; <br>                    break; <br> <br>                default: <br>                    dn = 0; <br>                    break; <br>            } <br>            /* Limit scrolling to current scroll range */ <br>            if (dn = BOUND (iPos + dn, iMin, iMax) - iPos) { <br>                ScrollWindow (hWnd, -dn, 0, NULL, NULL); <br>                SetScrollPos (hWnd, SB_HORZ, iPos + dn, TRUE); <br>            } <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            /* Start rubberbanding a rect. and track it's dimensions. <br>             * set the clip rectangle to it's dimensions. <br>             */ <br>            TrackMouse (hWnd, MAKEMPOINT(lParam)); <br>            break; <br> <br>        case WM_LBUTTONDBLCLK: <br>            break; <br> <br>        case WM_INITMENU: <br>            /* check/uncheck menu items depending on state  of related <br>             * flags <br>             */ <br> <br>            CheckMenuItem((HMENU)wParam, IDM_UPDATECOL, <br>                (bUpdateColors ? MF_CHECKED : MF_UNCHECKED)); <br>            CheckMenuItem((HMENU)wParam, IDM_TRANSPARENT, <br>                (wTransparent == TRANSPARENT ? MF_CHECKED : MF_UNCHECKED)); <br>            CheckMenuItem((HMENU)wParam, IDM_DIBSCREEN, <br>                (bDIBToDevice ? MF_CHECKED : MF_UNCHECKED)); <br>            CheckMenuItem((HMENU)wParam, IDM_NOUGLY, <br>                (bNoUgly ? MF_CHECKED : MF_UNCHECKED)); <br>            CheckMenuItem((HMENU)wParam, IDM_MEMORYDIB, MF_CHECKED); <br>            EnableMenuItem((HMENU)wParam, IDM_PASTEDIB, <br>                IsClipboardFormatAvailable(CF_DIB)?MF_ENABLED:MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_PASTEDDB, <br>                IsClipboardFormatAvailable(CF_BITMAP)?MF_ENABLED:MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_PASTEPAL, <br>                IsClipboardFormatAvailable(CF_PALETTE)?MF_ENABLED:MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_PRINT, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_SAVE, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_COPY, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br> <br>            EnableMenuItem((HMENU)wParam, IDM_ANIMATE0, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_ANIMATE5, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_ANIMATE50, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_ANIMATE100, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_ANIMATE200, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_ANIMATE201, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem((HMENU)wParam, IDM_STEALCOL, <br>                bLegitDraw ? MF_ENABLED : MF_GRAYED); <br>            break; <br> <br>        default: <br>            return DefWindowProc (hWnd, iMessage, wParam, lParam) ; <br> <br>    } <br>    return 0L ; <br> <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : MenuCommand ( HWND hWnd, WPARAM wParam)                            * <br> *                                                                          * <br> *  PURPOSE    : Processes menu commands.                                   * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if command could be processed.                     * <br> *               FALSE - otherwise                                          * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL MenuCommand ( <br>    HWND hWnd, <br>    UINT id) <br> <br>{ <br>    BITMAPINFOHEADER bi; <br>    HDC              hDC; <br>    HANDLE           h; <br>    HBITMAP          hbm; <br>    HPALETTE         hpal; <br>    WORD             i; <br>    CHAR             Name[40]; <br>    BOOL             bSave; <br>    INT              xSize, ySize, xRes, yRes, dx, dy; <br>    RECT             Rect; <br>    HFILE            fh; <br>    WORD             fFileOptions; <br>    CHAR             lpBuffer[128]; <br> <br>    switch (id) { <br>        case IDM_ABOUT: <br>                /* Show About .. box */ <br>                fDialog ((INT)ABOUTBOX, hWnd,(FARPROC)AppAbout); <br>                break; <br> <br>        case IDM_COPY: <br>                if (!bLegitDraw) <br>                    return 0L; <br> <br>                /* Clean clipboard of contents */ <br>                if (OpenClipboard(hWnd)) { <br>                    EmptyClipboard (); <br>                    SetClipboardData (CF_DIB     ,NULL); <br>                    SetClipboardData (CF_BITMAP  ,NULL); <br>                    SetClipboardData (CF_PALETTE ,NULL); <br>                    CloseClipboard (); <br>                } <br>                break; <br> <br>        case IDM_PASTEPAL: <br>                if (OpenClipboard (hWnd)) { <br>                    if (h = GetClipboardData (CF_PALETTE)) { <br>                        /* Delete current palette and get the CF_PALETTE data <br>                         * from the clipboard <br>                         */ <br>                        if (hpalCurrent) <br>                            DeleteObject (hpalCurrent); <br> <br>                        hpalCurrent = CopyPalette (h); <br> <br>                        /* <br>                         * If we have a bitmap realized against the old palette <br>                         * delete the bitmap and rebuild it using the new palette. <br>                         */ <br>                        if (hbmCurrent){ <br>                            DeleteObject (hbmCurrent); <br>                            hbmCurrent = NULL; <br> <br>                            if (hdibCurrent) <br>                                hbmCurrent = BitmapFromDib (hdibCurrent, hpalCurrent); <br>                        } <br>                    } <br>                    CloseClipboard(); <br>                } <br>                break; <br> <br>        case IDM_PASTEDIB: <br>                if (OpenClipboard (hWnd)) { <br>                    if (h = GetClipboardData (CF_DIB)) { <br>                        /* Delete current DIB and get CF_DIB and <br>                         * CF_PALETTE format data from the clipboard <br>                         */ <br>                        hpal = GetClipboardData (CF_PALETTE); <br> <br>                        FreeDib(); <br>                        hdibCurrent = CopyHandle (h); <br>                        if (hdibCurrent) { <br>                            bLegitDraw = TRUE; <br>                            lstrcpy(achFileName,"&lt;Clipboard&gt;"); <br>                            hbiCurrent = hdibCurrent; <br> <br>                            /* If there is a CF_PALETTE object in the <br>                             * clipboard, this is the palette to assume <br>                             * the DIB should be realized against, otherwise <br>                             * create a palette for it. <br>                             */ <br>                            if (hpal) <br>                                hpalCurrent = CopyPalette (hpal); <br>                            else <br>                                hpalCurrent = CreateDibPalette (hdibCurrent); <br> <br>                            SizeWindow(hWnd); <br>                        } <br>                        else { <br>                            bLegitDraw = FALSE; <br>                            LoadString(hInst, IDS_NOMEM, lpBuffer, sizeof(lpBuffer)); <br>                            ErrMsg(lpBuffer); <br>                        } <br>                    } <br>                    CloseClipboard(); <br>                } <br>                break; <br> <br>        case IDM_PASTEDDB: <br>                if (OpenClipboard (hWnd)) { <br>                    if (hbm = GetClipboardData(CF_BITMAP)) { <br>                        hpal = GetClipboardData(CF_PALETTE); <br>                        FreeDib(); <br> <br>                        /* <br>                         * If there is a CF_PALETTE object in the <br>                         * clipboard, this is the palette to assume <br>                         * the bitmap is realized against. <br>                         */ <br>                        if (hpal) <br>                            hpalCurrent = CopyPalette(hpal); <br>                        else <br>                            hpalCurrent = GetStockObject(DEFAULT_PALETTE); <br> <br>                        hdibCurrent = DibFromBitmap(hbm,BI_RGB,0,hpalCurrent); <br> <br>                        if (hdibCurrent) { <br>                            bLegitDraw = TRUE; <br>                            lstrcpy(achFileName,"&lt;Clipboard&gt;"); <br>                            hbiCurrent = hdibCurrent; <br> <br>                            hbmCurrent = BitmapFromDib(hdibCurrent,hpalCurrent); <br> <br>                            SizeWindow(hWnd); <br>                        } <br>                        else { <br>                            bLegitDraw = FALSE; <br>                            LoadString(hInst, IDS_NOMEM, lpBuffer, sizeof(lpBuffer)); <br>                            ErrMsg(lpBuffer); <br>                        } <br>                    } <br>                    CloseClipboard (); <br>                } <br>                break; <br> <br>        case IDM_PRINT: <br>                GetWindowText(hWnd, Name, sizeof(Name)); <br> <br>                DibInfo(hbiCurrent, &amp;bi); <br> <br>                if (!IsRectEmpty(&amp;rcClip)) <br>                { <br>                    bi.biWidth  = rcClip.right  - rcClip.left; <br>                    bi.biHeight = rcClip.bottom - rcClip.top; <br>                } <br> <br>                /* Initialise printer stuff */ <br>                if (!(hDC = GetPrinterDC())) <br>                        break; <br> <br>                xSize = GetDeviceCaps(hDC, HORZRES); <br>                ySize = GetDeviceCaps(hDC, VERTRES); <br>                xRes  = GetDeviceCaps(hDC, LOGPIXELSX); <br>                yRes  = GetDeviceCaps(hDC, LOGPIXELSY); <br> <br>                /* Use half inch margins on left and right <br>                 * and one inch on top. Maintain the same aspect ratio. <br>                 */ <br> <br>                dx = xSize - xRes; <br>                dy = (INT)((LONG)dx * bi.biHeight/bi.biWidth); <br> <br>                /* Fix bounding rectangle for the picture .. */ <br>                Rect.top    = yRes; <br>                Rect.left   = xRes / 2; <br>                Rect.bottom = yRes + dy; <br>                Rect.right  = xRes / 2 + dx; <br> <br>                /* ... and inform the driver */ <br>                Escape(hDC, SET_BOUNDS, sizeof(RECT), (LPSTR)&amp;Rect, NULL); <br> <br>                bSave = TRUE; <br> <br>                // <br>                // Use new Windows NT printing APIs...Petrus Wong 12-May-1993 <br>                // <br>                if (InitPrinting(hDC, hWnd, hInst, Name)) { <br> <br>                        StartPage(hDC); <br>                        PrintDIB(hWnd, hDC, xRes/2, yRes, dx, dy); </code></pre>
<p>
</p>
<pre><code><br>                        /* Signal to the driver to begin translating the drawing <br>                         * commands to printer output... <br>                         */ <br>                        EndPage(hDC); <br>                        TermPrinting(hDC); <br>                } <br> <br>                DeleteDC(hDC); <br>                break; <br> <br>        case IDM_OPEN: <br>                { <br> <br>                /* Bring up File/Open ... dialog */ <br>                LoadString(hInst, IDS_OPENDIBPROMPT, lpBuffer, sizeof(lpBuffer)); <br>                fh = DlgOpenFile (hWnd, <br>                                  lpBuffer, <br>                                  (LONG)OF_EXIST | OF_MUSTEXIST | OF_NOOPTIONS, <br>                                  szBitmapExt, <br>                                  achFileName, <br>                                  NULL <br>                                  ); <br>                /*  Load up the DIB if the user did not press cancel */ <br>                if (fh &gt; 0) { <br>                   StartWait(); <br>                   if (InitDIB (hWnd)) <br>                       InvalidateRect (hWnd, NULL, FALSE); <br>                   else <br>                       bLegitDraw = FALSE; <br>                   EndWait(); <br>                } <br>                break; <br>                } <br>        case IDM_SAVE: <br>                DibInfo(hbiCurrent,&amp;bi); <br>                fFileOptions = 0; <br> <br>                /* Depending on compression type for current DIB, <br>                 * set the appropriate bit in the fFileOptions flag <br>                 */ <br>                if (bi.biCompression == BI_RGB) <br>                    fFileOptions |= F_RGB; <br>                else if (bi.biCompression == BI_RLE4) <br>                    fFileOptions |= F_RLE4; <br>                else if (bi.biCompression == BI_RLE8) <br>                    fFileOptions |= F_RLE8; <br> <br>                /* Depending on bits/pixel type for current DIB, <br>                 * set the appropriate bit in the fFileOptions flag <br>                 */ <br>                switch (bi.biBitCount){ <br>                    case  1: <br>                        fFileOptions |= F_1BPP; <br>                        break; <br> <br>                    case  4: <br>                        fFileOptions |= F_4BPP; <br>                        break; <br> <br>                    case  8: <br>                        fFileOptions |= F_8BPP; <br>                        break; <br> <br>                    case 24: <br>                        fFileOptions |= F_24BPP; <br>                } <br> <br>                /* Bring up File/Save... dialog and get info. about filename, <br>                 * compression, and bits/pix. of DIB to be written. <br>                 */ <br>                LoadString(hInst, IDS_SAVEDIBPROMPT, lpBuffer, sizeof(lpBuffer)); <br>                fh = DlgOpenFile (hWnd, <br>                                  lpBuffer, <br>                                  (LONG)OF_EXIST | OF_SAVE | OF_NOSHOWSPEC, <br>                                  szBitmapExt, <br>                                  achFileName, <br>                                  &amp;fFileOptions); <br> <br>                /* Extract DIB specs. if the user did not press cancel */ <br>                if (fh != 0){ <br>                    if (fFileOptions &amp; F_RGB) <br>                        bi.biCompression = BI_RGB; <br> <br>                    if (fFileOptions &amp; F_RLE4) <br>                        bi.biCompression = BI_RLE4; <br> <br>                    if (fFileOptions &amp; F_RLE8) <br>                        bi.biCompression = BI_RLE8; <br> <br>                    if (fFileOptions &amp; F_1BPP) <br>                        bi.biBitCount = 1; <br> <br>                    if (fFileOptions &amp; F_4BPP) <br>                        bi.biBitCount = 4; <br> <br>                    if (fFileOptions &amp; F_8BPP) <br>                        bi.biBitCount = 8; <br> <br>                    if (fFileOptions &amp; F_24BPP) <br>                        bi.biBitCount = 24; <br> <br>                    /* Realize a DIB in the specified format and obtain a <br>                     * handle to it. <br>                     */ <br>                    hdibCurrent = RealizeDibFormat(bi.biCompression,bi.biBitCount); <br>                    if (!hdibCurrent){ <br>                        LoadString(hInst, IDS_CANTSAVEFILE, lpBuffer, sizeof(lpBuffer)); <br>                        ErrMsg(lpBuffer); <br>                        return 0L; <br>                    } <br> <br>                    /* Write the DIB */ <br>                    StartWait(); <br>                    if (!WriteDIB(achFileName,hdibCurrent)) { <br>                        LoadString(hInst, IDS_CANTSAVEFILE, lpBuffer, sizeof(lpBuffer)); <br>                        ErrMsg(lpBuffer); <br>                    } <br>                    EndWait(); <br>                } <br>                break; <br> <br>        case IDM_EXIT: <br>                PostMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L); <br>                break; <br> <br>        case IDM_UPDATECOL: <br>                /* Toggle state of "update screen colors" flag. If it is <br>                 * off, clear the "hide changes" flag <br>                 */ <br>                bUpdateColors = !bUpdateColors; <br>                if (bUpdateColors) <br>                    bNoUgly = 0; <br>                break; <br> <br>        case IDM_DIBSCREEN: <br>                bDIBToDevice = !bDIBToDevice; <br>                InvalidateRect(hWnd, (LPRECT) (NULL), 1); <br>                break; <br> <br>        case IDM_MEMORYDIB: <br>                break; <br> <br>        case IDM_NOUGLY: <br>                /* Toggle state of "hide changes" flag. If it is off, clear <br>                 * the "update screen colors" flag. This will tell SHOWDIB <br>                 * to paint itself black while the palette is changing. <br>                 */ <br>                bNoUgly = !bNoUgly; <br>                if (bNoUgly) <br>                    bUpdateColors = 0; <br>                break; <br> <br>        case IDM_TRANSPARENT: <br>                /* Toggle DC mode */ <br>                wTransparent = (WORD) (wTransparent == TRANSPARENT ? <br>                    OPAQUE : TRANSPARENT); <br>                break; <br> <br>        case IDM_ANIMATE0: <br>                if (!hpalSave) <br>                    break; <br> <br>                /* Reset animation count and stop timer */ <br>                KillTimer(hWnd, 1); <br>                nAnimating = 0; <br> <br>                /* Restore palette which existed before animation started */ <br>                DeleteObject(hpalCurrent); <br>                hpalCurrent = hpalSave; <br> <br>                /* Rebuild bitmap based on newly realized information */ <br>                hDC = GetDC (hWnd); <br>                SelectPalette (hDC, hpalCurrent, 0); <br>                RealizePalette (hDC); <br>                ReleaseDC (hWnd, hDC); <br> <br>                if (hbmCurrent){ <br>                    DeleteObject (hbmCurrent); <br>                    hbmCurrent = NULL; <br> <br>                    if (hdibCurrent) <br>                       hbmCurrent = BitmapFromDib (hdibCurrent, hpalCurrent); <br>                } <br>                hpalSave = NULL; <br> <br>                /* Force redraw with new palette for everyone */ <br>                InvalidateRect(hWnd, NULL, TRUE); <br>                break; <br> <br>        case IDM_STEALCOL: <br>        case IDM_ANIMATE5: <br>        case IDM_ANIMATE20: <br>        case IDM_ANIMATE50: <br>        case IDM_ANIMATE100: <br>        case IDM_ANIMATE200: <br>        case IDM_ANIMATE201: <br>                /* Set animation count i.e number of times animation is to <br>                 * take place. <br>                 */ <br>                nAnimating = id; <br>                if (id == IDM_STEALCOL) <br>                        nAnimating = 0; <br> <br>                /* Save current palette */ <br>                hpalSave = CopyPalette(hpalCurrent); <br> <br>                GetObject(hpalCurrent, sizeof(INT), (LPSTR)&amp;pLogPal-&gt;palNumEntries); <br>                GetPaletteEntries(hpalCurrent, 0, pLogPal-&gt;palNumEntries, pLogPal-&gt;palPalEntry); <br> <br>                /* Reserve all entries in the palette otherwise AnimatePalette() <br>                 * will not modify them <br>                 */ <br>                for (i = 0; i &lt; pLogPal-&gt;palNumEntries; i++) { <br>                     pLogPal-&gt;palPalEntry[i].peFlags = (BYTE)PC_RESERVED; <br>                } <br> <br>                SetPaletteEntries(hpalCurrent, 0, pLogPal-&gt;palNumEntries, pLogPal-&gt;palPalEntry); <br> <br>                /* Rebuild bitmap based on newly realized information */ <br>                if (hbmCurrent){ <br>                    DeleteObject (hbmCurrent); <br>                    hbmCurrent = NULL; <br> <br>                    if (hdibCurrent) <br>                       hbmCurrent = BitmapFromDib (hdibCurrent, hpalCurrent); <br>                } <br> <br>                /* Force redraw with new palette for everyone */ <br>                InvalidateRect(hWnd, NULL, TRUE); <br> <br>                /* Initiate the timer so that palette can be animated in <br>                 * response to a WM_TIMER message <br>                 */ <br>                if (nAnimating &amp;&amp; !SetTimer(hWnd, 1, 250, (TIMERPROC)(LPSTR) NULL)) <br>                        nAnimating = 0; <br> <br>        default: <br>                break; <br>    } <br> <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : InitDIB(hWnd)                                              * <br> *                                                                          * <br> *  PURPOSE    : Reads a DIB from a file, obtains a handle to it's          * <br> *               BITMAPINFO struct., sets up the palette and loads the DIB. * <br> *                                                                          * <br> *  RETURNS    : TRUE  - DIB loads ok                                       * <br> *               FALSE - otherwise                                          * <br> *                                                                          * <br> ****************************************************************************/ <br>INT InitDIB(HWND hWnd) <br>{ <br>    HFILE              fh; <br>    LPBITMAPINFOHEADER lpbi; <br>    WORD FAR *         pw; <br>    INT                i; <br>    BITMAPINFOHEADER   bi; <br>    OFSTRUCT           of; <br>    CHAR               lpBuffer[128]; <br> <br>    FreeDib(); <br> <br>    /* Open the file and get a handle to it's BITMAPINFO */ <br> <br>    fh = OpenFile(achFileName, (LPOFSTRUCT)&amp;of, (UINT)OF_READ); <br>    if (fh == -1) { <br>        LoadString(hInst, IDS_CANTOPENFILE, lpBuffer, sizeof(lpBuffer)); <br>        ErrMsg(lpBuffer, (LPSTR)achFileName); <br>        return FALSE; <br>    } <br>    hbiCurrent = ReadDibBitmapInfo(fh); <br> <br>    dwOffset = _llseek(fh, 0L, (UINT)SEEK_CUR); <br>    _lclose(fh); <br> <br>    if (hbiCurrent == NULL) { <br>        LoadString(hInst, IDS_BADDIBFILE, lpBuffer, sizeof(lpBuffer)); <br>        ErrMsg(lpBuffer, (LPSTR)achFileName); <br>        return FALSE; <br>    } <br>    DibInfo(hbiCurrent,&amp;bi); <br> <br>    /* Set up the palette */ <br>    hpalCurrent = CreateDibPalette(hbiCurrent); <br>    if (hpalCurrent == NULL) { <br>        LoadString(hInst, IDS_CREATEPALFAIL, lpBuffer, sizeof(lpBuffer)); <br>        ErrMsg(lpBuffer); <br>        return FALSE; <br>    } <br> <br>    /*  Convert the DIB color table to palette relative indexes, so <br>     *  SetDIBits() and SetDIBitsToDevice() can avoid color matching. <br>     *  We can do this because the palette we realize is identical <br>     *  to the color table of the bitmap, ie the indexes match 1 to 1 <br>     * <br>     *  Now that the DIB color table is palette indexes not RGB values <br>     *  we must use DIB_PAL_COLORS as the wUsage parameter to SetDIBits() <br>     */ <br>    lpbi = (VOID FAR *)GlobalLock(hbiCurrent); <br>    if (lpbi-&gt;biBitCount != 24) { <br>        fPalColors = TRUE; <br> <br>        pw = (WORD FAR *)((LPSTR)lpbi + lpbi-&gt;biSize); <br> <br>        for (i=0; i&lt;(INT)lpbi-&gt;biClrUsed; i++) <br>            *pw++ = (WORD)i; <br>    } <br>    GlobalUnlock(hbiCurrent); <br>    bLegitDraw = TRUE; <br> <br>    /*  If the input bitmap is not in RGB FORMAT the banding code will <br>     *  not work!  we need to load the DIB bits into memory. <br>     *  if memory DIB, load it all NOW!  This will avoid calling the <br>     *  banding code. <br>     */ <br>    hdibCurrent = OpenDIB(achFileName); <br> <br>    /*  If the RLE could not be loaded all at once, exit gracefully NOW, <br>     *  to avoid calling the banding code <br>     */ <br>    if ((bi.biCompression != BI_RGB) &amp;&amp; !hdibCurrent){ <br>        LoadString(hInst, IDS_CANTLOADRLE, lpBuffer, sizeof(lpBuffer)); <br>        ErrMsg (lpBuffer); <br>        FreeDib(); <br>        return FALSE; <br>    } <br> <br>    if (hdibCurrent &amp;&amp; !bDIBToDevice){ <br>        hbmCurrent = BitmapFromDib(hdibCurrent,hpalCurrent); <br>        if (!hbmCurrent){ <br>            LoadString(hInst, IDS_CANTCREATEBMP, lpBuffer, sizeof(lpBuffer)); <br>            ErrMsg (lpBuffer); <br>            FreeDib(); <br>            return FALSE; <br>        } <br>    } <br> <br>    SizeWindow(hWnd); <br> <br>    return TRUE; <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : FreeDib(void)                                              * <br> *                                                                          * <br> *  PURPOSE    : Frees all currently active bitmap, DIB and palette objects * <br> *               and initializes their handles.                             * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID FreeDib() <br>{ <br>    if (hpalCurrent) <br>        DeleteObject(hpalCurrent); <br> <br>    if (hbmCurrent) <br>        DeleteObject(hbmCurrent); <br> <br>    if (hdibCurrent) <br>        GlobalFree(hdibCurrent); <br> <br>    if (hbiCurrent &amp;&amp; hbiCurrent != hdibCurrent) <br>        GlobalFree(hbiCurrent); <br> <br>    fPalColors  = FALSE; <br>    bLegitDraw  = FALSE; <br>    hpalCurrent = NULL; <br>    hdibCurrent = NULL; <br>    hbmCurrent  = NULL; <br>    hbiCurrent  = NULL; <br>    SetRectEmpty (&amp;rcClip); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
