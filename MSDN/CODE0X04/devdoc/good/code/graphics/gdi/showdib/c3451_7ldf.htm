<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DLGOPEN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3453"></a>DLGOPEN.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************* <br> *                                                                             * <br> *  MODULE      : DLGOPEN.C                                                    * <br> *                                                                             * <br> *  DESCRIPTION : Routines to display a standard File/Open and File/Save       * <br> *                dialog boxes.                                                * <br> *                                                                             * <br> *  FUNCTIONS   : DlgOpenFile() - Displays a dialog box for opening or saving a* <br> *                                file.                                        * <br> *                                                                             * <br> *                DlgfnOpen()   - Dialog function for the above dialog.        * <br> *                                                                             * <br> *                AddExt()      - Adds an extension to a filename if not       * <br> *                                already present.                             * <br> *                                                                             * <br> *                FSearchSpec() - Checks if given string contains a wildcard   * <br> *                                character.                                   * <br> *                                                                             * <br> *                FillListBox() - Fills listbox with files that match specs.   * <br> *                                                                             * <br> *                DlgCheckOkEnable() - Enables &lt;OK&gt; button iff there's text in * <br> *                                     the edit control.                       * <br> *                                                                             * <br> *                NOTE : These routines require that the app. be running       * <br> *                       SS = DS since they use near pointers into the stack.  * <br> *                                                                             * <br> *******************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "showdib.h" <br> <br>static PSTR         szExt; <br>static PSTR         szFileName; <br>static PSTR         szTitle; <br>static DWORD        flags; <br>static WORD         fOpt; <br> <br>/* Forward declarations of helper functions */ <br> <br>static VOID  NEAR DlgCheckOkEnable(HWND hwnd, INT idEdit, UINT message); <br>static CHAR *NEAR FillListBox (HWND,CHAR*, UINT); <br>static BOOL  NEAR FSearchSpec (CHAR*); <br>static VOID  NEAR AddExt (CHAR*,CHAR*); <br> <br>#define DLGOPEN_UNUSED   0 <br> <br>/* Mask to eliminate bogus style and bitcount combinations ... <br> * RLE formats, if chosen should be matched with the bitcounts: <br> *   RLE4 scheme should be used only for 4 bitcount DIBs. <br> *   RLE8   "      "     "   "   "    "  8   "       " <br> * <br> * BITCOUNTMASK is indexed by DLGOPEN_RLE4 &gt;&gt; 4, DLGOPEN_RLE8 &gt;&gt; 4 <br> * and DLGOPEN_RLE8 &gt;&gt; 4 <br> */ <br> <br>static WORD BITCOUNTMASK[] = { DLGOPEN_UNUSED, <br>                               DLGOPEN_1BPP | DLGOPEN_8BPP | DLGOPEN_24BPP, <br>                               DLGOPEN_1BPP | DLGOPEN_4BPP | DLGOPEN_24BPP, <br>                               DLGOPEN_UNUSED, <br>                               0 }; <br> <br> <br>/******************************************************************************* <br> *                                                                             * <br> *  FUNCTION   :DlgOpen(LPSTR szFile)                                          * <br> *                                                                             * <br> *  PURPOSE    :Display dialog box for opening files. Allow user to interact   * <br> *              with dialogbox, change directories as necessary, and try to    * <br> *              open file if user selects one. Automatically append            * <br> *              extension to filename if necessary.                            * <br> *              This routine correctly parses filenames containing KANJI       * <br> *              characters.                                                    * <br> *                                                                             * <br> *  RETURNS    :  - Handle to the opened file if legal filename.               * <br> *                - 0 if user presses &lt;cancel&gt;                                 * <br> *                - 1 if filename entered is illegal                           * <br> *                                                                             * <br> *******************************************************************************/ <br>HFILE APIENTRY DlgOpenFile ( <br>    HWND          hwndParent, <br>    CHAR          *szTitleIn, <br>    DWORD         flagsIn, <br>    CHAR          *szExtIn, <br>    CHAR          *szFileNameIn, <br>    WORD          *pfOpt) <br>{ <br>    INT      fh; <br>    FARPROC  lpProc; <br>    CHAR     achFile[128]; <br>    CHAR     achExt[128]; <br>    HANDLE   hInstance; <br>    WORD     w; <br> <br>    if (pfOpt == NULL) <br>        pfOpt = &amp;w; <br> <br>    flags    = flagsIn; <br>    fOpt     = *pfOpt; <br> <br>    lstrcpy (szFileName = achFile, szFileNameIn); <br>    lstrcpy (szExt = achExt, szExtIn); <br>    szTitle = szTitleIn; <br> <br>    hInstance = (HANDLE)GetWindowLong (hwndParent, GWL_HINSTANCE); <br> <br>    /* Show the dialog box */ <br>    lpProc = MakeProcInstance ((FARPROC)DlgfnOpen, hInstance); <br>    fh = DialogBox (hInstance, "DlgOpenBox", hwndParent, (DLGPROC)lpProc); <br>    FreeProcInstance (lpProc); <br> <br>    if (fh != 0){ <br>        lstrcpy (szFileNameIn, szFileName); <br>        *pfOpt = fOpt; <br>    } <br>    return fh; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :DlgfnOpen (hwnd, msg, wParam, lParam)                       * <br> *                                                                          * <br> *  PURPOSE    :Dialog function for File/Open dialog.                       * <br> *                                                                          * <br> ****************************************************************************/ <br>LONG APIENTRY DlgfnOpen ( <br>    HWND hwnd, <br>    UINT msg, <br>    UINT wParam, <br>    LONG lParam) <br>{ <br>    INT      result = -1;    /* Assume illegal filename initially */ <br>    int      w; <br>    LPSTR    lpsz; <br>    WORD     f; <br>    OFSTRUCT of; <br>    RECT     rc, rcCtl; <br>    HWND     hwndT; <br>    BOOL     fEnable; <br>    CHAR     lpBuffer[128]; <br> <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            if (szTitle &amp;&amp; *szTitle) <br>                SetWindowText (hwnd, szTitle); <br> <br>            /* Set text on &lt;OK&gt; button according to mode (File/Open or File/Save) */ <br>            if (flags &amp; OF_SAVE) { <br>                LoadString(hInst, IDS_SAVESTR, lpBuffer, sizeof(lpBuffer)); <br>                SetDlgItemText(hwnd, IDOK, lpBuffer); <br>            } <br>            if (flags &amp; OF_OPEN) { <br>                LoadString(hInst, IDS_OPENSTR, lpBuffer, sizeof(lpBuffer)); <br>                SetDlgItemText(hwnd, IDOK, lpBuffer); <br>            } <br>            if ((flags &amp; OF_NOOPTIONS) &amp;&amp; <br>                (hwndT = GetDlgItem(hwnd,DLGOPEN_FOLDOUT))) <br>                EnableWindow (hwndT,FALSE); <br> <br>            if (hwndT = GetDlgItem (hwnd, DLGOPEN_SMALL)) { <br>                GetWindowRect (hwnd,&amp;rc); <br>                GetWindowRect (GetDlgItem(hwnd,DLGOPEN_SMALL),&amp;rcCtl); <br> <br>                SetWindowPos (hwnd, <br>                              NULL, <br>                              0, <br>                              0, <br>                              rcCtl.left - rc.left, <br>                              rc.bottom - rc.top, <br>                              SWP_NOZORDER | SWP_NOMOVE); <br>            } <br>            /* fill list box with filenames that match specifications, and <br>             * fill static field with path name. <br>             */ <br>            FillListBox(hwnd,szExt, WM_INITDIALOG); <br> <br>            /* If in Save mode, set the edit control with default (current) <br>             * file name,and select the corresponding entry in the listbox. <br>             */ <br>            if ((flags &amp; OF_SAVE) &amp;&amp; *szFileName) { <br>                        SetDlgItemText (hwnd, DLGOPEN_EDIT, szFileName); <br>                        SendDlgItemMessage (hwnd, <br>                                    DLGOPEN_FILE_LISTBOX, <br>                                    LB_SELECTSTRING, <br>                                    0, <br>                                    (LONG)(LPSTR)szFileName); <br>            } <br>            else { <br>                /*  Set the edit field with the default extensions... */ <br>                if (flags &amp; OF_NOSHOWSPEC) <br>                    SetDlgItemText (hwnd, DLGOPEN_EDIT, ""); <br>                else <br>                    SetDlgItemText (hwnd, DLGOPEN_EDIT, szExt); <br>            } <br>            /*  ...and select all text in the edit field */ <br>                /* JAP added HWND cast*/ <br>            SendMessage((HWND)GetDlgItem(hwnd, DLGOPEN_EDIT), EM_SETSEL, GET_EM_SETSEL_MPS(0, 0x7fff)); <br> <br>            /*  check all options that are set */ <br>            for ( f = DLGOPEN_1BPP; f; f&lt;&lt;=1) <br>                CheckDlgButton(hwnd, (INT)FID(f), (WORD) (fOpt &amp; f)); <br> <br>            break; <br> <br>        case WM_COMMAND: <br>    switch (LOWORD(wParam)) { <br>                case IDOK: <br>                    if (IsWindowEnabled (GetDlgItem(hwnd, IDOK))) { <br>                        /* Get contents of edit field and add search spec. if it <br>                         * does not contain one. <br>                         */ <br>                        GetDlgItemText (hwnd, DLGOPEN_EDIT, (LPSTR)szFileName, 128); <br> <br>            lpsz = CharPrev(szFileName, szFileName + lstrlen(szFileName)); <br>            switch (*lpsz) { <br>                            case '\\': <br>                            case '/': <br>                                *lpsz = 0; <br>                            break; <br>                        } <br>                        if (SetCurrentDirectory ((LPSTR)szFileName)) <br>                            lstrcpy (szFileName,szExt); <br> <br>                        /*  Try to open path.  If successful, fill listbox with <br>                         *  contents of new directory.  Otherwise, open datafile. <br>                         */ <br>                        if (FSearchSpec(szFileName)) { <br>                            lstrcpy (szExt, FillListBox (hwnd, szFileName, WM_COMMAND)); <br>                            if (flags &amp; OF_NOSHOWSPEC) { <br>                                SetDlgItemText (hwnd, DLGOPEN_EDIT, ""); <br>                            } else { <br>                                SetDlgItemText (hwnd, DLGOPEN_EDIT, szExt); <br>                            } <br>                            break; <br>                        } <br> <br>                        /*  Make filename upper case and if it's a legal DOS <br>                         *  name, try to open the file. <br>                         */ <br>                        CharUpper(szFileName); <br>                        AddExt(szFileName,szExt); <br>                        result = (INT)OpenFile(szFileName, &amp;of, (WORD)flags); <br> <br>                        if (result != -1) { <br>                            lstrcpy(szFileName,of.szPathName); <br>                        } <br>                        else if (flags &amp; OF_MUSTEXIST) { <br>                            MessageBeep(0); <br>                            return 0L; <br>                        } <br> <br>                        /*  Get the state of all checked options */ <br>                        for (f = DLGOPEN_1BPP; f; f &lt;&lt;= 1){ <br>                            if (IsDlgButtonChecked (hwnd, FID (f))) <br>                                fOpt |= f; <br>                            else <br>                                fOpt &amp;= ~f; <br>                        } <br> <br>                        EndDialog (hwnd, result); <br>                    } <br>                    break; <br> <br>                case DLGOPEN_OPTION + DLGOPEN_RLE4: <br>                case DLGOPEN_OPTION + DLGOPEN_RLE8: <br>                case DLGOPEN_OPTION + DLGOPEN_RGB: <br>                    /* Mask out incompatible bitcount options and gray the <br>                     * appropriate radiobuttons. <br>                     */ <br>                    for (f = DLGOPEN_1BPP; f &lt;= DLGOPEN_24BPP; f &lt;&lt;= 1){ <br>                        fEnable = !(f &amp; BITCOUNTMASK [IDF(w) &gt;&gt; 4 ]); <br>                        EnableWindow (GetDlgItem (hwnd, FID(f)), fEnable); <br> <br>                        /* If the radiobutton is being grayed, uncheck it and <br>                         * and check an "allowed" option so the bitcount group <br>                         * is still accessible via the keyboard <br>                         */ <br>                        if (!fEnable &amp;&amp; IsDlgButtonChecked (hwnd, FID (f))){ <br>                            CheckDlgButton(hwnd, FID(f), FALSE); <br>                            CheckDlgButton(hwnd, FID(IDF(w) &gt;&gt; 3), TRUE); <br>                        } <br>                    } <br>                    break; <br> <br>                case IDCANCEL: <br>                    /* User pressed cancel.  Just take down dialog box. */ <br>                    EndDialog (hwnd, 0); <br>                    break; <br> <br>                /*  User single clicked or doubled clicked in listbox - <br>                 *  Single click means fill edit box with selection. <br>                 *  Double click means go ahead and open the selection. <br>                 */ <br>                case DLGOPEN_FILE_LISTBOX: <br>                case DLGOPEN_DIR_LISTBOX: <br>                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) { <br>                        /* Single click case */ <br>                        case LBN_SELCHANGE: <br>                            /* Get selection, which may be either a prefix to a <br>                             * new search path or a filename. DlgDirSelectEx parses <br>                             * selection, and appends a backslash if selection <br>                             * is a prefix <br>                             */ <br>                            DlgDirSelectEx(hwnd, szFileName, 128, LOWORD(wParam)); <br>            lpsz = CharPrev(szFileName, szFileName + lstrlen(szFileName)); <br>                switch (*lpsz) { <br>                                case ':': <br>                                    lstrcat (szFileName,"."); <br>                                    break; <br>                                case '\\': <br>                                case '/': <br>                                    *lpsz = 0; <br>                                    break; <br>                            } <br>                            SetDlgItemText(hwnd, DLGOPEN_EDIT, szFileName); <br>                            break; <br>                        /* Double click case - first click has already been <br>                         * processed as single click <br>                         */ <br>                        case LBN_DBLCLK: <br>                            PostMessage (hwnd,WM_COMMAND,IDOK,0L); <br>                            break; <br>                    } <br>                    break; <br> <br>                case DLGOPEN_EDIT: <br>                    DlgCheckOkEnable(hwnd, DLGOPEN_EDIT, HIWORD(lParam)); <br>                    break; <br> <br>                case DLGOPEN_FOLDOUT: <br>                    GetWindowRect(hwnd,&amp;rc); <br>                    GetWindowRect(GetDlgItem(hwnd,DLGOPEN_BIG),&amp;rcCtl); <br> <br>                    if ((rcCtl.left &lt;= rc.right) &amp;&amp; (rcCtl.top &lt;= rc.bottom)) <br>                         GetWindowRect (GetDlgItem (hwnd, DLGOPEN_SMALL), &amp;rcCtl); <br> <br>                    SetWindowPos (hwnd, <br>                                  NULL, <br>                                  0, <br>                                  0, <br>                                  rcCtl.left - rc.left, <br>                                  rc.bottom - rc.top, <br>                                  SWP_NOZORDER | SWP_NOMOVE); <br>                    break; <br>            } <br>        default: <br>            return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : static void NEAR DlgCheckOkEnable(hwnd, idEdit, message)   * <br> *                                                                          * <br> *  PURPOSE    : Enables the &lt;OK&gt; button in a dialog box iff the edit item  * <br> *               contains text.                                             * <br> *                                                                          * <br> ****************************************************************************/ <br>static VOID NEAR DlgCheckOkEnable( <br>    HWND        hwnd, <br>    INT idEdit, <br>    UINT message) <br>{ <br>    if (message == EN_CHANGE) { <br>        EnableWindow ( GetDlgItem (hwnd, IDOK), <br>                       (BOOL)SendMessage (GetDlgItem (hwnd, idEdit), <br>                                          WM_GETTEXTLENGTH, <br>                                          0, 0L)); <br>    } <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : AddExt (pch, ext)                                          * <br> *                                                                          * <br> *  PURPOSE    : Add an extension to a filename if none is already specified* <br> *                                                                          * <br> ****************************************************************************/ <br>static VOID NEAR AddExt ( <br>    CHAR *pch,    /* File name    */ <br>    CHAR *ext)    /* Extension to add */ <br>{ <br>    CHAR acExt[20]; <br>    CHAR *pext = acExt; <br> <br>    while (*ext &amp;&amp; *ext != '.') { <br>        ext = CharNext(ext); <br>    } <br>    while (*ext &amp;&amp; *ext != ';') { <br>        if (IsDBCSLeadByte(*ext)) { <br>            *pext++ = *ext++; <br>        } <br>        *pext++ = *ext++; <br>    } <br>    *pext = 0; <br>    pext = acExt; <br> <br>    while (*pch == '.') { <br>        pch++; <br>        if ((*pch == '.') &amp;&amp; pch[1] == '\\') <br>            pch += 2;                       /* ..\ */ <br>        if (*pch == '\\') <br>            pch++;                         /* .\ */ <br>    } <br>    while (*pch != '\0') { <br>if (*pch == '.') <br>    return; <br>pch = CharNext(pch); <br>    } <br> <br>    // *pch++ = '.'; <br>    do <br>        *pch++ = *pext; <br>    while (*pext++ != '\0'); <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : FSearchSpec (sz)                                           * <br> *                                                                          * <br> *  PURPOSE    : Checks to see if NULL-terminated strings contains a "*" or * <br> *               a "?".                                                     * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if the above characters are found in the string    * <br> *               FALSE - otherwise.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>static BOOL NEAR FSearchSpec(CHAR       *sz) <br>{ <br>    for (; *sz ;sz = CharNext(sz)) { <br>        if (*sz == '*' || *sz == '?') <br>            return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : static char * NEAR FillListBox (hDlg,pFile, cmd)                   * <br> *                                                                          * <br> *  PURPOSE    : Fill list box with filenames that match specifications, and* <br> *               fills the static field with the path name.                 * <br> *                                                                          * <br> *  RETURNS    : A pointer to the pathname.                                                           * <br> *                                                                          * <br> ****************************************************************************/ <br>static CHAR * NEAR FillListBox ( <br>    HWND  hDlg, <br>    CHAR  *pFile,  /* [path]{list of file wild cards, separated by ';'} */ <br>    UINT cmd)    /* if initdialog, or WM_COMMAND*/ <br>{ <br>    CHAR  ach[128]; <br>    CHAR  *pch; <br>    CHAR  *pDir;   /* Directory name or path */ <br>    CHAR  pCurDir[256]; <br> <br>    pch  = pFile; <br>    pDir = ach; <br>    if(cmd == WM_INITDIALOG){ <br>    while (*pch &amp;&amp; *pch != ';') <br>        pch = CharNext(pch); <br>    while ((pch &gt; pFile) &amp;&amp; (*pch != '/') &amp;&amp; (*pch != '\\')) <br>        pch = CharPrev(pFile, pch); <br>    if (pch &gt; pFile) { <br>       *pch = 0; <br>       lstrcpy (pDir, pFile); <br>       pFile = pch + 1; <br>    } <br>    else { <br>       lstrcpy (pDir,"."); <br>    } <br>    } <br>    else{ <br>        /* since SetCurrentDirectory was called already, I'll use GetCurrentDirectory*/ <br>        /* to get pDir*/ <br>        GetCurrentDirectory(256, pCurDir); <br>        strcpy(pDir, pCurDir); <br>    } <br>    DlgDirList (hDlg, pDir, (INT)DLGOPEN_DIR_LISTBOX, (INT)DLGOPEN_PATH,(WORD)ATTRDIRLIST); <br>    SendDlgItemMessage (hDlg, DLGOPEN_FILE_LISTBOX, LB_RESETCONTENT, 0, 0L); <br>    SendDlgItemMessage (hDlg, DLGOPEN_FILE_LISTBOX, WM_SETREDRAW, FALSE, 0L); <br>    pDir = pFile;            /* save pFile to return */ <br>    while (*pFile) { <br>        pch = ach; <br>        while (*pFile==' ') <br>            pFile++; <br>        while (*pFile &amp;&amp; *pFile != ';') { <br>        if (IsDBCSLeadByte(*pFile)) { <br>        *pch++ = *pFile++; <br>        } <br>        *pch++ = *pFile++; <br>    } <br>        *pch = 0; <br>        if (*pFile) <br>            pFile++; <br>        SendDlgItemMessage (hDlg, <br>                            DLGOPEN_FILE_LISTBOX, <br>                            LB_DIR,ATTRFILELIST, <br>                            (LONG)(LPSTR)ach); <br>    } <br>    SendDlgItemMessage (hDlg, DLGOPEN_FILE_LISTBOX, WM_SETREDRAW, TRUE, 0L); <br>    InvalidateRect (GetDlgItem (hDlg, DLGOPEN_FILE_LISTBOX), NULL, TRUE); <br> <br>    return pDir; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
