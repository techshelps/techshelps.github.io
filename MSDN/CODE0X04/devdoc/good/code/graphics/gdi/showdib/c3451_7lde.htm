<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3452"></a>DIB.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************* <br> *                                                                             * <br> *  MODULE      : DIB.C                                                        * <br> *                                                                             * <br> *  DESCRIPTION : Routines for dealing with Device Independent Bitmaps.        * <br> *                                                                             * <br> *  FUNCTIONS   : OpenDIB()           - Opens DIB file and creates a memory DIB* <br> *                                                                             * <br> *                WriteDIB()          - Writes a global handle in CF_DIB format* <br> *                                      to a file.                             * <br> *                                                                             * <br> *                DibInfo()           - Retrieves the info. block associated   * <br> *                                      with a CF_DIB format memory block.     * <br> *                                                                             * <br> *                CreateBIPalette()   - Creates a GDI palette given a pointer  * <br> *                                      to a BITMAPINFO structure.             * <br> *                                                                             * <br> *                CreateDibPalette()  - Creates a GDI palette given a HANDLE   * <br> *                                      to a BITMAPINFO structure.             * <br> *                                                                             * <br> *                ReadDibBitmapInfo() - Reads a file in DIB format and returns * <br> *                                      a global handle to it's BITMAPINFO     * <br> *                                                                             * <br> *                PaletteSize()       - Calculates the palette size in bytes   * <br> *                                      of given DIB                           * <br> *                                                                             * <br> *                DibNumColors()      - Determines the number of colors in DIB * <br> *                                                                             * <br> *                BitmapFromDib()     - Creates a DDB given a global handle to * <br> *                                      a block in CF_DIB format.              * <br> *                                                                             * <br> *                DibFromBitmap()     - Creates a DIB repr. the DDB passed in. * <br> *                                                                             * <br> *                DrawBitmap()        - Draws a bitmap at specified position   * <br> *                                      in the DC.                             * <br> *                                                                             * <br> *                DibBlt()            - Draws a bitmap in CIF_DIB format using * <br> *                                      SetDIBitsToDevice()                    * <br> *                                                                             * <br> *                StretchDibBlt()     - Draws a bitmap in CIF_DIB format using * <br> *                                      StretchDIBits()                        * <br> *                                                                             * <br> *                lread()             - Private routine to read more than 64k  * <br> *                                                                             * <br> *                lwrite()            - Private routine to write more than 64k * <br> *                                                                             * <br> *******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "showdib.h" <br>static   HCURSOR hcurSave; <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :OpenDIB(LPSTR szFile)                                       * <br> *                                                                          * <br> *  PURPOSE    :Open a DIB file and create a MEMORY DIB, a memory handle    * <br> *              containing BITMAPINFO, palette data and the bits.           * <br> *                                                                          * <br> *  RETURNS    :A handle to the DIB.                                        * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE OpenDIB (LPSTR szFile) <br>{ <br>    HFILE               fh; <br>    BITMAPINFOHEADER    bi; <br>    LPBITMAPINFOHEADER  lpbi; <br>    DWORD               dwLen = 0; <br>    DWORD               dwBits; <br>    HANDLE              hdib; <br>    HANDLE              h; <br>    OFSTRUCT            of; <br> <br>    /* Open the file and read the DIB information */ <br>    fh = OpenFile(szFile, &amp;of, (UINT)OF_READ); <br>    if (fh == -1) <br>        return NULL; <br> <br>    hdib = ReadDibBitmapInfo(fh); <br>    if (!hdib) <br>        return NULL; <br>    DibInfo(hdib,&amp;bi); <br> <br>    /* Calculate the memory needed to hold the DIB */ <br>    dwBits = bi.biSizeImage; <br>    dwLen  = bi.biSize + (DWORD)PaletteSize (&amp;bi) + dwBits; <br> <br>    /* Try to increase the size of the bitmap info. buffer to hold the DIB */ <br>    h = GlobalReAlloc(hdib, dwLen, GHND); <br>    if (!h){ <br>        GlobalFree(hdib); <br>        hdib = NULL; <br>    } <br>    else <br>        hdib = h; <br> <br>    /* Read in the bits */ <br>    if (hdib){ <br> <br>        lpbi = (VOID FAR *)GlobalLock(hdib); <br>        lread(fh, (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi), dwBits); <br>        GlobalUnlock(hdib); <br>    } <br>    _lclose(fh); <br> <br>    return hdib; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WriteDIB(LPSTR szFile,HANDLE hdib)                         * <br> *                                                                          * <br> *  PURPOSE    : Write a global handle in CF_DIB format to a file.          * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if successful.                                     * <br> *               FALSE - otherwise                                          * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL WriteDIB ( <br>    LPSTR szFile, <br>    HANDLE hdib) <br>{ <br>    BITMAPFILEHEADER    hdr; <br>    LPBITMAPINFOHEADER  lpbi; <br>    HFILE               fh; <br>    OFSTRUCT            of; <br> <br>    if (!hdib) <br>        return FALSE; <br> <br>    fh = OpenFile(szFile, &amp;of, (UINT)OF_CREATE|OF_READWRITE); <br>    if (fh == -1) <br>        return FALSE; <br> <br>    lpbi = (VOID FAR *)GlobalLock (hdib); <br> <br>    /* Fill in the fields of the file header */ <br>    hdr.bfType          = BFT_BITMAP; <br>    hdr.bfSize          = GlobalSize (hdib) + SIZEOF_BITMAPFILEHEADER_PACKED; <br>    hdr.bfReserved1     = 0; <br>    hdr.bfReserved2     = 0; <br>    hdr.bfOffBits       = (DWORD) (SIZEOF_BITMAPFILEHEADER_PACKED + lpbi-&gt;biSize + <br>                          PaletteSize(lpbi)); <br> <br>    /* Write the file header */ <br>#ifdef  FIXDWORDALIGNMENT <br>    _lwrite(fh, (LPSTR)&amp;hdr, (UINT)(SIZEOF_BITMAPFILEHEADER_PACKED)); <br>#else <br>        WriteMapFileHeaderandConvertFromDwordAlignToPacked(fh, &amp;hdr); <br>#endif <br> <br>        /* this struct already DWORD aligned!*/ <br>    /* Write the DIB header and the bits */ <br>    lwrite (fh, (LPSTR)lpbi, GlobalSize (hdib)); <br> <br>    GlobalUnlock (hdib); <br>    _lclose(fh); <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi)                * <br> *                                                                          * <br> *  PURPOSE    : Retrieves the DIB info associated with a CF_DIB            * <br> *               format memory block.                                       * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if successful.                                     * <br> *               FALSE - otherwise                                          * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL DibInfo ( <br>    HANDLE hbi, <br>    LPBITMAPINFOHEADER lpbi) <br>{ <br>    if (hbi){ <br>        *lpbi = *(LPBITMAPINFOHEADER)GlobalLock (hbi); <br> <br>        /* fill in the default fields */ <br>        if (lpbi-&gt;biSize != sizeof (BITMAPCOREHEADER)){ <br>            if (lpbi-&gt;biSizeImage == 0L) <br>                                lpbi-&gt;biSizeImage = WIDTHBYTES(lpbi-&gt;biWidth*lpbi-&gt;biBitCount) * lpbi-&gt;biHeight; <br> <br>            if (lpbi-&gt;biClrUsed == 0L) <br>                                lpbi-&gt;biClrUsed = DibNumColors (lpbi); <br>    } <br>        GlobalUnlock (hbi); <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CreateBIPalette(LPBITMAPINFOHEADER lpbi)                   * <br> *                                                                          * <br> *  PURPOSE    : Given a Pointer to a BITMAPINFO struct will create a       * <br> *               a GDI palette object from the color table.                 * <br> *                                                                          * <br> *  RETURNS    : A handle to the palette.                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>HPALETTE CreateBIPalette (LPBITMAPINFOHEADER lpbi) <br>{ <br>    LOGPALETTE          *pPal; <br>    HPALETTE            hpal = NULL; <br>    WORD                nNumColors; <br>    BYTE                red; <br>    BYTE                green; <br>    BYTE                blue; <br>    WORD                i; <br>    RGBQUAD        FAR *pRgb; <br> <br>    if (!lpbi) <br>        return NULL; <br> <br>    if (lpbi-&gt;biSize != sizeof(BITMAPINFOHEADER)) <br>        return NULL; <br> <br>    /* Get a pointer to the color table and the number of colors in it */ <br>    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi-&gt;biSize); <br>    nNumColors = DibNumColors(lpbi); <br> <br>    if (nNumColors){ <br>        /* Allocate for the logical palette structure */ <br>        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY)); <br>        if (!pPal) <br>            return NULL; <br> <br>        pPal-&gt;palNumEntries = nNumColors; <br>        pPal-&gt;palVersion    = PALVERSION; <br> <br>        /* Fill in the palette entries from the DIB color table and <br>         * create a logical color palette. <br>         */ <br>        for (i = 0; i &lt; nNumColors; i++){ <br>            pPal-&gt;palPalEntry[i].peRed   = pRgb[i].rgbRed; <br>            pPal-&gt;palPalEntry[i].peGreen = pRgb[i].rgbGreen; <br>            pPal-&gt;palPalEntry[i].peBlue  = pRgb[i].rgbBlue; <br>            pPal-&gt;palPalEntry[i].peFlags = (BYTE)0; <br>        } <br>        hpal = CreatePalette(pPal); <br>        LocalFree((HANDLE)pPal); <br>    } <br>    else if (lpbi-&gt;biBitCount == 24){ <br>        /* A 24 bitcount DIB has no color table entries so, set the number of <br>         * to the maximum value (256). <br>         */ <br>        nNumColors = MAXPALETTE; <br>        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY)); <br>        if (!pPal) <br>            return NULL; <br> <br>        pPal-&gt;palNumEntries = nNumColors; <br>        pPal-&gt;palVersion    = PALVERSION; <br> <br>        red = green = blue = 0; <br> <br>        /* Generate 256 (= 8*8*4) RGB combinations to fill the palette <br>         * entries. <br>         */ <br>        for (i = 0; i &lt; pPal-&gt;palNumEntries; i++){ <br>            pPal-&gt;palPalEntry[i].peRed   = red; <br>            pPal-&gt;palPalEntry[i].peGreen = green; <br>            pPal-&gt;palPalEntry[i].peBlue  = blue; <br>            pPal-&gt;palPalEntry[i].peFlags = (BYTE)0; <br> <br>            if (!(red += 32)) <br>                if (!(green += 32)) <br>                    blue += 64; <br>        } <br>        hpal = CreatePalette(pPal); <br>        LocalFree((HANDLE)pPal); <br>    } <br>    return hpal; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CreateDibPalette(HANDLE hbi)                               * <br> *                                                                          * <br> *  PURPOSE    : Given a Global HANDLE to a BITMAPINFO Struct               * <br> *               will create a GDI palette object from the color table.     * <br> *               (BITMAPINFOHEADER format DIBs only)                                     * <br> *                                                                          * <br> *  RETURNS    : A handle to the palette.                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>HPALETTE CreateDibPalette (HANDLE hbi) <br>{ <br>    HPALETTE hpal; <br> <br>    if (!hbi) <br>        return NULL; <br>    hpal = CreateBIPalette((LPBITMAPINFOHEADER)GlobalLock(hbi)); <br>    GlobalUnlock(hbi); <br>    return hpal; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ReadDibBitmapInfo(int fh)                                  * <br> *                                                                          * <br> *  PURPOSE    : Will read a file in DIB format and return a global HANDLE  * <br> *               to it's BITMAPINFO.  This function will work with both     * <br> *               "old" (BITMAPCOREHEADER) and "new" (BITMAPINFOHEADER)      * <br> *               bitmap formats, but will always return a "new" BITMAPINFO  * <br> *                                                                          * <br> *  RETURNS    : A handle to the BITMAPINFO of the DIB in the file.         * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE ReadDibBitmapInfo (INT fh) <br>{ <br>    DWORD     off; <br>    HANDLE    hbi = NULL; <br>    INT       size; <br>    INT       i; <br>    WORD      nNumColors; <br> <br>    RGBQUAD FAR       *pRgb; <br>    BITMAPINFOHEADER   bi; <br>    BITMAPCOREHEADER   bc; <br>    LPBITMAPINFOHEADER lpbi; <br>    BITMAPFILEHEADER   bf; <br>    DWORD              dwWidth = 0; <br>    DWORD              dwHeight = 0; <br>    WORD               wPlanes, wBitCount; <br> <br>    if (fh == -1) <br>        return NULL; <br>#ifdef FIXDWORDALIGNMENT <br>    /* Reset file pointer and read file header */ <br>    off = _llseek(fh, 0L, (UINT)SEEK_CUR); <br>    if ((SIZEOF_BITMAPFILEHEADER_PACKED)  != _lread(fh, (LPSTR)&amp;bf, (UINT)sizeof (SIZEOF_BITMAPFILEHEADER_PACKED))) <br>        return FALSE; <br>#else <br>        ReadBitMapFileHeaderandConvertToDwordAlign(fh, &amp;bf, &amp;off); <br>        /* at this point we have read the file into bf*/ <br>#endif <br> <br>    /* Do we have a RC HEADER? */ <br>    if (!ISDIB (bf.bfType)) {     <br>        bf.bfOffBits = 0L;                <br>                _llseek(fh, off, (UINT)SEEK_SET); /*seek back to beginning of file*/ <br>    } <br>    if (sizeof (bi) != _lread(fh, (LPSTR)&amp;bi, (UINT)sizeof(bi))) <br>        return FALSE; <br> <br>    nNumColors = DibNumColors (&amp;bi); <br> <br>    /* Check the nature (BITMAPINFO or BITMAPCORE) of the info. block <br>     * and extract the field information accordingly. If a BITMAPCOREHEADER, <br>     * transfer it's field information to a BITMAPINFOHEADER-style block <br>     */ <br>    switch (size = (INT)bi.biSize){ <br>        case sizeof (BITMAPINFOHEADER): <br>            break; <br> <br>        case sizeof (BITMAPCOREHEADER): <br> <br>            bc = *(BITMAPCOREHEADER*)&amp;bi; <br> <br>            dwWidth   = (DWORD)bc.bcWidth; <br>            dwHeight  = (DWORD)bc.bcHeight; <br>            wPlanes   = bc.bcPlanes; <br>            wBitCount = bc.bcBitCount; <br> <br>        bi.biSize           = sizeof(BITMAPINFOHEADER); <br>            bi.biWidth              = dwWidth; <br>            bi.biHeight             = dwHeight; <br>            bi.biPlanes             = wPlanes; <br>            bi.biBitCount           = wBitCount; <br> <br>            bi.biCompression        = BI_RGB; <br>            bi.biSizeImage          = 0; <br>            bi.biXPelsPerMeter      = 0; <br>            bi.biYPelsPerMeter      = 0; <br>            bi.biClrUsed            = nNumColors; <br>            bi.biClrImportant       = nNumColors; <br> <br>            _llseek(fh, (LONG)sizeof (BITMAPCOREHEADER) - sizeof (BITMAPINFOHEADER), (UINT)SEEK_CUR); <br>            break; <br> <br>        default: <br>            /* Not a DIB! */ <br>            return NULL; <br>    } <br> <br>    /*  Fill in some default values if they are zero */ <br>    if (bi.biSizeImage == 0){ <br>        bi.biSizeImage = WIDTHBYTES ((DWORD)bi.biWidth * bi.biBitCount) <br>                         * bi.biHeight; <br>    } <br>    if (bi.biClrUsed == 0) <br>        bi.biClrUsed = DibNumColors(&amp;bi); <br> <br>    /* Allocate for the BITMAPINFO structure and the color table. */ <br>    hbi = GlobalAlloc (GHND, (LONG)bi.biSize + nNumColors * sizeof(RGBQUAD)); <br>    if (!hbi) <br>        return NULL; <br>    lpbi = (VOID FAR *)GlobalLock (hbi); <br>    *lpbi = bi; <br> <br>    /* Get a pointer to the color table */ <br>    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize); <br>    if (nNumColors){ <br>        if (size == sizeof(BITMAPCOREHEADER)){ <br>            /* Convert a old color table (3 byte RGBTRIPLEs) to a new <br>             * color table (4 byte RGBQUADs) <br>             */ <br>            _lread(fh, (LPSTR)pRgb, (UINT)nNumColors * sizeof(RGBTRIPLE)); <br> <br>            for (i = nNumColors - 1; i &gt;= 0; i--){ <br>                RGBQUAD rgb; <br> <br>                rgb.rgbRed      = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed; <br>                rgb.rgbBlue     = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue; <br>                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen; <br>                rgb.rgbReserved = (BYTE)0; <br> <br>                pRgb[i] = rgb; <br>            } <br>        } <br>        else <br>            _lread(fh, (LPSTR)pRgb, (UINT)nNumColors * sizeof(RGBQUAD)); <br>    } <br> <br>    if (bf.bfOffBits != 0L){ <br>        _llseek(fh, off + bf.bfOffBits, (UINT)SEEK_SET); <br>        } <br>    GlobalUnlock(hbi); <br>    return hbi; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  PaletteSize(VOID FAR * pv)                                * <br> *                                                                          * <br> *  PURPOSE    :  Calculates the palette size in bytes. If the info. block  * <br> *                is of the BITMAPCOREHEADER type, the number of colors is  * <br> *                multiplied by 3 to give the palette size, otherwise the   * <br> *                number of colors is multiplied by 4.                                                          * <br> *                                                                          * <br> *  RETURNS    :  Palette size in number of bytes.                          * <br> *                                                                          * <br> ****************************************************************************/ <br>WORD PaletteSize (VOID FAR * pv) <br>{ <br>    LPBITMAPINFOHEADER lpbi; <br>    WORD               NumColors; <br> <br>    lpbi      = (LPBITMAPINFOHEADER)pv; <br>    NumColors = DibNumColors(lpbi); <br> <br>    if (lpbi-&gt;biSize == sizeof(BITMAPCOREHEADER)) <br>        return (WORD)(NumColors * sizeof(RGBTRIPLE)); <br>    else <br>        return (WORD)(NumColors * sizeof(RGBQUAD)); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibNumColors(VOID FAR * pv)                                * <br> *                                                                          * <br> *  PURPOSE    : Determines the number of colors in the DIB by looking at   * <br> *               the BitCount filed in the info block.                      * <br> *                                                                          * <br> *  RETURNS    : The number of colors in the DIB.                           * <br> *                                                                          * <br> ****************************************************************************/ <br>WORD DibNumColors (VOID FAR * pv) <br>{ <br>    INT                 bits; <br>    LPBITMAPINFOHEADER  lpbi; <br>    LPBITMAPCOREHEADER  lpbc; <br> <br>    lpbi = ((LPBITMAPINFOHEADER)pv); <br>    lpbc = ((LPBITMAPCOREHEADER)pv); <br> <br>    /*  With the BITMAPINFO format headers, the size of the palette <br>     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it <br>     *  is dependent on the bits per pixel ( = 2 raised to the power of <br>     *  bits/pixel). <br>     */ <br>    if (lpbi-&gt;biSize != sizeof(BITMAPCOREHEADER)){ <br>        if (lpbi-&gt;biClrUsed != 0) <br>            return (WORD)lpbi-&gt;biClrUsed; <br>        bits = lpbi-&gt;biBitCount; <br>    } <br>    else <br>        bits = lpbc-&gt;bcBitCount; <br> <br>    switch (bits){ <br>        case 1: <br>                return 2; <br>        case 4: <br>                return 16; <br>        case 8: <br>                return 256; <br>        default: <br>                /* A 24 bitcount DIB has no color table */ <br>                return 0; <br>    } <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibFromBitmap()                                            * <br> *                                                                          * <br> *  PURPOSE    : Will create a global memory block in DIB format that       * <br> *               represents the Device-dependent bitmap (DDB) passed in.    * <br> *                                                                          * <br> *  RETURNS    : A handle to the DIB                                        * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE DibFromBitmap ( <br>    HBITMAP      hbm, <br>    DWORD            biStyle, <br>    WORD             biBits, <br>    HPALETTE     hpal) <br>{ <br>    BITMAP               bm; <br>    BITMAPINFOHEADER     bi; <br>    BITMAPINFOHEADER FAR *lpbi; <br>    DWORD                dwLen; <br>    HANDLE               hdib; <br>    HANDLE               h; <br>    HDC                  hdc; <br> <br>    if (!hbm) <br>        return NULL; <br> <br>    if (hpal == NULL) <br>        hpal = GetStockObject(DEFAULT_PALETTE); <br> <br>    GetObject(hbm,sizeof(bm),(LPSTR)&amp;bm); <br> <br>    if (biBits == 0) <br>        biBits =  bm.bmPlanes * bm.bmBitsPixel; <br> <br>    bi.biSize               = sizeof(BITMAPINFOHEADER); <br>    bi.biWidth              = bm.bmWidth; <br>    bi.biHeight             = bm.bmHeight; <br>    bi.biPlanes             = 1; <br>    bi.biBitCount           = biBits; <br>    bi.biCompression        = biStyle; <br>    bi.biSizeImage          = 0; <br>    bi.biXPelsPerMeter      = 0; <br>    bi.biYPelsPerMeter      = 0; <br>    bi.biClrUsed            = 0; <br>    bi.biClrImportant       = 0; <br> <br>    dwLen  = bi.biSize + PaletteSize(&amp;bi); <br> <br>    hdc = GetDC(NULL); <br>    hpal = SelectPalette(hdc,hpal,FALSE); <br>         RealizePalette(hdc); <br> <br>    hdib = GlobalAlloc(GHND,dwLen); <br> <br>    if (!hdib){ <br>        SelectPalette(hdc,hpal,FALSE); <br>        ReleaseDC(NULL,hdc); <br>        return NULL; <br>    } <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    *lpbi = bi; <br> <br>    /*  call GetDIBits with a NULL lpBits param, so it will calculate the <br>     *  biSizeImage field for us <br>     */ <br>    GetDIBits(hdc, hbm, 0L, (DWORD)bi.biHeight, <br>        (LPBYTE)NULL, (LPBITMAPINFO)lpbi, (DWORD)DIB_RGB_COLORS); <br> <br>    bi = *lpbi; <br>    GlobalUnlock(hdib); <br> <br>    /* If the driver did not fill in the biSizeImage field, make one up */ <br>    if (bi.biSizeImage == 0){ <br>        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight; <br> <br>        if (biStyle != BI_RGB) <br>            bi.biSizeImage = (bi.biSizeImage * 3) / 2; <br>    } <br> <br>    /*  realloc the buffer big enough to hold all the bits */ <br>    dwLen = bi.biSize + PaletteSize(&amp;bi) + bi.biSizeImage; <br>    if (h = GlobalReAlloc(hdib,dwLen,0)) <br>        hdib = h; <br>    else{ <br>        GlobalFree(hdib); <br>        hdib = NULL; <br> <br>        SelectPalette(hdc,hpal,FALSE); <br>        ReleaseDC(NULL,hdc); <br>        return hdib; <br>    } <br> <br>    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the <br>     *  bits this time <br>     */ <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (GetDIBits( hdc, <br>                   hbm, <br>                   0L, <br>                   (DWORD)bi.biHeight, <br>                   (LPBYTE)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi), <br>                   (LPBITMAPINFO)lpbi, (DWORD)DIB_RGB_COLORS) == 0){ <br>         GlobalUnlock(hdib); <br>         hdib = NULL; <br>         SelectPalette(hdc,hpal,FALSE); <br>         ReleaseDC(NULL,hdc); <br>         return NULL; <br>    } <br> <br>    bi = *lpbi; <br>    GlobalUnlock(hdib); <br> <br>    SelectPalette(hdc,hpal,FALSE); <br>    ReleaseDC(NULL,hdc); <br>    return hdib; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)                  * <br> *                                                                          * <br> *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global * <br> *               handle to a memory block in CF_DIB format                  * <br> *                                                                          * <br> *  RETURNS    : A handle to the DDB.                                       * <br> *                                                                          * <br> ****************************************************************************/ <br>HBITMAP BitmapFromDib ( <br>    HANDLE         hdib, <br>    HPALETTE   hpal) <br>{ <br>    LPBITMAPINFOHEADER  lpbi; <br>    HPALETTE            hpalT; <br>    HDC                 hdc; <br>    HBITMAP             hbm; <br> <br>    StartWait(); <br> <br>    if (!hdib) <br>        return NULL; <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (!lpbi) <br>        return NULL; <br> <br>    hdc = GetDC(NULL); <br> <br>    if (hpal){ <br>        hpalT = SelectPalette(hdc,hpal,FALSE); <br>        RealizePalette(hdc);     // GDI Bug...???? <br>    } <br> <br>    hbm = CreateDIBitmap(hdc, <br>                (LPBITMAPINFOHEADER)lpbi, <br>                (LONG)CBM_INIT, <br>                (LPSTR)lpbi + lpbi-&gt;biSize + PaletteSize(lpbi), <br>                (LPBITMAPINFO)lpbi, <br>                DIB_RGB_COLORS ); <br> <br>    if (hpal) <br>        SelectPalette(hdc,hpalT,FALSE); <br> <br>    ReleaseDC(NULL,hdc); <br>    GlobalUnlock(hdib); <br> <br>    EndWait(); <br> <br>    return hbm; <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)  * <br> *                                                                          * <br> *  PURPOSE    : Draws bitmap &lt;hbm&gt; at the specifed position in DC &lt;hdc&gt;    * <br> *                                                                          * <br> *  RETURNS    : Return value of BitBlt()                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL DrawBitmap ( <br>    HDC    hdc, <br>    INT    x, <br>    INT    y, <br>    HBITMAP    hbm, <br>    DWORD          rop) <br>{ <br>    HDC       hdcBits; <br>    BITMAP    bm; <br>//    HPALETTE  hpalT;   <br>    BOOL      f; <br> <br>    if (!hdc || !hbm) <br>        return FALSE; <br> <br>    hdcBits = CreateCompatibleDC(hdc); <br>    GetObject(hbm,sizeof(BITMAP),(LPSTR)&amp;bm); <br>    SelectObject(hdcBits,hbm); <br>    f = BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop); <br>    DeleteDC(hdcBits); <br> <br>    return f; <br>        UNREFERENCED_PARAMETER(y); <br>        UNREFERENCED_PARAMETER(x); <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibBlt( HDC hdc,                                           * <br> *                       int x0, int y0,                                    * <br> *                       int dx, int dy,                                    * <br> *                       HANDLE hdib,                                       * <br> *                       int x1, int y1,                                    * <br> *                       LONG rop)                                          * <br> *                                                                          * </code></pre>
<p>
</p>
<pre><code>*  PURPOSE    : Draws a bitmap in CF_DIB format, using SetDIBits to device.* <br> *               taking the same parameters as BitBlt().                    * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if function succeeds.                              * <br> *               FALSE - otherwise.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL DibBlt ( <br>    HDC    hdc, <br>    INT    x0, <br>    INT    y0, <br>    INT    dx, <br>    INT    dy, <br>    HANDLE hdib, <br>    INT    x1, <br>    INT    y1, <br>    LONG   rop) <br>{ <br>    LPBITMAPINFOHEADER   lpbi; <br>//    HPALETTE           hpal,hpalT; <br>    LPSTR                pBuf; <br>//    HDC                hdcMem; <br>//    HBITMAP            hbm,hbmT; <br> <br>    if (!hdib) <br>        return PatBlt(hdc,x0,y0,dx,dy,rop); <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (!lpbi) <br>        return FALSE; <br> <br>    pBuf = (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi); <br>    SetDIBitsToDevice (hdc, x0, y0, dx, dy, <br>                       x1,y1, <br>                       x1, <br>                       dy, <br>                       pBuf, (LPBITMAPINFO)lpbi, <br>                       DIB_RGB_COLORS ); <br> <br>    GlobalUnlock(hdib); <br>    return TRUE; <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : StretchDibBlt( HDC hdc,                                    * <br> *                              int x, int y,                               * <br> *                              int dx, int dy,                             * <br> *                              HANDLE hdib,                                * <br> *                              int x0, int y0,                             * <br> *                              int dx0, int dy0,                           * <br> *                              LONG rop)                                   * <br> *                                                                          * <br> *  PURPOSE    : Draws a bitmap in CF_DIB format, using StretchDIBits()     * <br> *               taking the same parameters as StretchBlt().                * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if function succeeds.                              * <br> *               FALSE - otherwise.                                         * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL StretchDibBlt ( <br>    HDC hdc, <br>    INT x, <br>    INT y, <br>    INT dx, <br>    INT dy, <br>    HANDLE hdib, <br>    INT x0, <br>    INT y0, <br>    INT dx0, <br>    INT dy0, <br>    LONG rop) <br> <br>{ <br>    LPBITMAPINFOHEADER lpbi; <br>    LPSTR        pBuf; <br>    BOOL         f; <br> <br>    if (!hdib) <br>        return PatBlt(hdc,x,y,dx,dy,rop); <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (!lpbi) <br>        return FALSE; <br> <br>    pBuf = (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi); <br> <br>    f = StretchDIBits ( hdc, <br>                        x, y, <br>                        dx, dy, <br>                        x0, y0, <br>                        dx0, dy0, <br>                        pBuf, (LPBITMAPINFO)lpbi, <br>                        DIB_RGB_COLORS, <br>                        rop); <br> <br>    GlobalUnlock(hdib); <br>    return f; <br>} <br> <br> /************* PRIVATE ROUTINES TO READ/WRITE MORE THAN 64K ***************/ <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : lread(int fh, VOID FAR *pv, DWORD ul)                      * <br> *                                                                          * <br> *  PURPOSE    : Reads data in steps of 32k till all the data has been read.* <br> *                                                                          * <br> *  RETURNS    : 0 - If read did not proceed correctly.                     * <br> *               number of bytes read otherwise.                            * <br> *                                                                          * <br> ****************************************************************************/ <br>DWORD PASCAL lread ( <br>    INT       fh, <br>    VOID FAR      *pv, <br>    DWORD             ul) <br>{ <br>    DWORD     ulT = ul; <br>    BYTE *hp = pv; <br> <br>    while (ul &gt; (DWORD)MAXREAD) { <br>        if (_lread(fh, (LPSTR)hp, (UINT)MAXREAD) != MAXREAD) <br>                return 0; <br>        ul -= MAXREAD; <br>        hp += MAXREAD; <br>    } <br>    if (_lread(fh, (LPSTR)hp, (UINT)ul) != (UINT)ul) <br>        return 0; <br>    return ulT; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : lwrite(int fh, VOID FAR *pv, DWORD ul)                     * <br> *                                                                          * <br> *  PURPOSE    : Writes data in steps of 32k till all the data is written.  * <br> *                                                                          * <br> *  RETURNS    : 0 - If write did not proceed correctly.                    * <br> *               number of bytes written otherwise.                         * <br> *                                                                          * <br> ****************************************************************************/ <br>DWORD PASCAL lwrite ( <br>    INT      fh, <br>    VOID FAR     *pv, <br>    DWORD            ul) <br>{ <br>    DWORD     ulT = ul; <br>    BYTE *hp = pv; <br> <br>    while (ul &gt; MAXREAD) { <br>        if (_lwrite(fh, (LPSTR)hp, (UINT)MAXREAD) != MAXREAD) <br>                return 0; <br>        ul -= MAXREAD; <br>        hp += MAXREAD; <br>    } <br>    if (_lwrite(fh, (LPSTR)hp, (UINT)ul) != (UINT)ul) <br>        return 0;                  <br> <br>    return ulT; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ReadBitMapFileHeaderandConvertToDwordAlign(HFILE fh, LPBITMAPFILEHEADER pbf) <br> *                                                                          * <br> *  PURPOSE    : read file header (which is packed) and convert into unpacked BITMAPFILEHEADER strucutre <br> *                                                                          * <br> *  RETURNS    : VOID <br> *                                                                          * <br> ****************************************************************************/ <br> <br>VOID ReadBitMapFileHeaderandConvertToDwordAlign(HFILE fh, LPBITMAPFILEHEADER pbf, LPDWORD lpdwoff) <br>{ <br>        DWORD off; <br> <br>        off = _llseek(fh, 0L, (UINT) SEEK_CUR); <br>        *lpdwoff = off; <br> <br>/*              BITMAPFILEHEADER STRUCUTURE is as follows  <br> *              BITMAPFILEHEADER <br> *              WORD    bfType  <br> &gt;          ....                  &lt;     add WORD if packed here! <br> *              DWORD   bfSize  <br> *              WORD    bfReserved1 <br> *              WORD    bfReserved2 <br> *              DWORD   bfOffBits  <br> *                      This is the packed format, unpacked adds a WORD after bfType <br> */ <br> <br>        /* read in bfType*/ <br>        _lread(fh, (LPSTR) &amp;pbf-&gt;bfType, sizeof(WORD)); <br>        /* read in last 3 dwords*/ <br>        _lread(fh, (LPSTR) &amp;pbf-&gt;bfSize, sizeof(DWORD) * 3); <br> <br>} <br> <br> <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WriteMapFileHeaderandConvertFromDwordAlignToPacked(HFILE fh, LPBITMAPFILEHEADER pbf) <br> *                                                                          * <br> *  PURPOSE    : write header structure (which NOT packed) and write it PACKED <br> *                                                                          * <br> *  RETURNS    : VOID <br> *                                                                          * <br> ****************************************************************************/ <br> <br>VOID WriteMapFileHeaderandConvertFromDwordAlignToPacked(HFILE fh, LPBITMAPFILEHEADER pbf) <br>{ <br> <br>        /* write bfType*/ <br>    _lwrite(fh, (LPSTR)&amp;pbf-&gt;bfType, (UINT)sizeof (WORD)); <br>        /* now pass over extra word, and only write next 3 DWORDS!*/ <br>        _lwrite(fh, (LPSTR)&amp;pbf-&gt;bfSize, sizeof(DWORD) * 3); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
