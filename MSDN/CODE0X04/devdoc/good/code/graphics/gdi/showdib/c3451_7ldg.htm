<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAWDIB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3454"></a>DRAWDIB.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************* <br> *                                                                             * <br> *  MODULE      : DrawDIB.c                                                    * <br> *                                                                             * <br> *  PURPOSE     : Handles most of the SHOWDIB's DIB drawing and clipboard      * <br> *                operations.                                                  * <br> *                                                                             * <br> *  FUNCTIONS   :                                                              * <br> *                PrintDIB()             -  Sets the current DIB bits to the   * <br> *                                          printer DC.                        * <br> *                                                                             * <br> *                AppPaint()             -  Sets the DIB/bitmap bits on the    * <br> *                                          screen or the given device.        * <br> *                                                                             * <br> *                DrawSelect()           -  Draws selected clip rectangle on   * <br> *                                          the DC/screen.                     * <br> *                                                                             * <br> *                NormalizeRect()        -  Swaps reversed rectangle coords.   * <br> *                                                                             * <br> *                TrackMouse()           -  Draws rubberbanding rectangle and  * <br> *                                          displays it's dimensions.          * <br> *                                                                             * <br> *                BandDIB()              -  Outputs DIB in bands to device.    * <br> *                                                                             * <br> *                SizeWindow()           -  Sizes app. window based on client  * <br> *                                          dimensions and style.              * <br> *                                                                             * <br> *                GetRealClientRect()    -  Calculates client rectangle dimen- * <br> *                                          sions if scrollbars are present.   * <br> *                                                                             * <br> *                SetScrollRanges()      -  Sets global scroll ranges.         * <br> *                                                                             * <br> *                CopyHandle()           -  Makes a copy of memory block.      * <br> *                                                                             * <br> *                CopyPalette()          -  Makes a copy of the GDI logical    * <br> *                                          palette.                           * <br> *                                                                             * <br> *                CopyBitmap()           -  Copies given bitmap to another.    * <br> *                                                                             * <br> *                CropBitmap()           -  Crops a bitmap to the given size.  * <br> *                                                                             * <br> *                RenderFormat()         -  renders currently displayed DIB    * <br> *                                          in CF_BITMAP or CF_DIB format.     * <br> *                                                                             * <br> *                RealizeDibFormat()     -  Realizes the DIB in given format.  * <br> *                                                                             * <br> *                ErrMsg()               -  Pops an error message to user.     * <br> *                                                                             * <br> *                fDialog()              -  Displays a dialog box.             * <br> *                                                                             * <br> *                AppAbout()             -  Shows the About.. dialog box.      * <br> *                                                                             * <br> *******************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;io.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "showdib.h" <br> <br>MPOINT                ptSize;       /* Stores DIB dimensions                   */ <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  PrintDIB(HWND hWnd, HDC hDC, int x, int y, int dx, int dy)* <br> *                                                                          * <br> *  PURPOSE    :  Set the DIB bits to the printer DC.                       * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID PrintDIB ( <br>    HWND hWnd, <br>    HDC hDC, <br>    INT x, <br>    INT y, <br>    INT dx, <br>    INT dy) <br> <br>{ <br>    BITMAPINFOHEADER bi; <br>    INT dibX,  dibY; <br>    INT dibDX, dibDY; <br> <br>    if (!bLegitDraw) <br>        return; <br> <br>    DibInfo (hbiCurrent, &amp;bi); <br> <br>    if (IsRectEmpty (&amp;rcClip)){ <br>        dibX  = 0; <br>        dibY  = 0; <br>        dibDX = (INT)bi.biWidth; <br>        dibDY = (INT)bi.biHeight; <br>    } <br>    else{ <br>        dibX  = rcClip.left; <br>        dibY  = (INT)bi.biHeight - 1 - rcClip.bottom; <br>        dibDX = rcClip.right  - rcClip.left; <br>        dibDY = rcClip.bottom - rcClip.top; <br>    } <br> <br>    if (hdibCurrent){ <br>        /* Stretch the DIB to printer DC */ <br>        StretchDibBlt ( hDC, <br>                        x, <br>                        y, <br>                        dx, <br>                        dy, <br>                        hdibCurrent, <br>                        dibX, <br>                        dibY, <br>                        dibDX, <br>                        dibDY, <br>                        SRCCOPY); <br>    } <br>    else if (achFileName[0]) { <br> <br>        SetMapMode (hDC, MM_ANISOTROPIC); <br>        (VOID)SetViewportOrgEx (hDC, x, y, NULL); <br>        (VOID)SetViewportExtEx (hDC, dx, dy, NULL); <br> <br>        BandDIB (hWnd, hDC, 0, 0); <br>    } <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  AppPaint(HWND hWnd, HDC hDC, int x, int y)                * <br> *                                                                          * <br> *  PURPOSE    :  Sets the DIB/bitmap bits on the screen or the given device* <br> *                                                                          * <br> ****************************************************************************/ <br>VOID AppPaint ( <br>    HWND hWnd, <br>    HDC hDC, <br>    INT x, <br>    INT y) <br>{ <br>    HPALETTE hpalT; <br>    BITMAPINFOHEADER bi; <br>//    LPBITMAPINFOHEADER lpbi; <br> <br>    (VOID)SetWindowOrgEx (hDC, x, y, NULL); <br>    SetBkMode (hDC, wTransparent); <br> <br>    if (bLegitDraw) { <br>                hpalT = SelectPalette (hDC, hpalCurrent, FALSE); <br>                RealizePalette (hDC); <br> <br>        if (hbmCurrent &amp;&amp; !bDIBToDevice) { <br>            DrawBitmap (hDC, 0, 0, hbmCurrent, SRCCOPY); <br>        } <br>        else if (hdibCurrent) { <br>            DibInfo (hdibCurrent, &amp;bi); <br>            DibBlt (hDC, <br>                    0, <br>                    0, <br>                    (INT)bi.biWidth, <br>                    (INT)bi.biHeight, <br>                    hdibCurrent, <br>                    0, <br>                    0, <br>                    SRCCOPY); <br>        } <br>        else if (achFileName[0]) { <br>            BandDIB (hWnd, hDC, 0, 0); <br>        } <br> <br>        SelectPalette(hDC,hpalT,FALSE); <br>    } <br> <br>    DrawSelect(hDC, TRUE); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  DrawSelect(HDC hdc, BOOL fDraw)                           * <br> *                                                                          * <br> *  PURPOSE    :  Draws the selected clip rectangle with its dimensions on  * <br> *                the DC/screen                                             * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID DrawSelect( <br>    HDC hdc, <br>    BOOL fDraw) <br>{ <br>    CHAR  sz[80]; <br>    INT   x,y,len,dx,dy; <br>    HDC   hdcBits; <br>    HBITMAP hbm; <br> <br>    if (!IsRectEmpty (&amp;rcClip)) { <br> <br>        /* If a rectangular clip region has been selected, draw it */ <br>        PatBlt(hdc, rcClip.left,    rcClip.top,        rcClip.right-rcClip.left, 1,  DSTINVERT); <br>        PatBlt(hdc, rcClip.left,    rcClip.bottom, 1, -(rcClip.bottom-rcClip.top),   DSTINVERT); <br>        PatBlt(hdc, rcClip.right-1, rcClip.top, 1,   rcClip.bottom-rcClip.top,   DSTINVERT); <br>        PatBlt(hdc, rcClip.right,   rcClip.bottom-1, -(rcClip.right-rcClip.left), 1, DSTINVERT); <br> <br>        /* Format the dimensions string ...*/ <br>        sprintf( sz, <br>                  "%dx%d", <br>                  rcClip.right  - rcClip.left, <br>                  rcClip.bottom - rcClip.top ); <br>     len = lstrlen(sz); <br> <br>        /* ... and center it in the rectangle */ <br>        { SIZE size; <br>        (VOID)GetTextExtentPoint(hdc, sz, len, &amp;size); <br>        dx = size.cx; dy = size.cy; <br>        } <br>        x  =  (rcClip.right  + rcClip.left - dx) / 2; <br>        y  =  (rcClip.bottom + rcClip.top  - dy) / 2; <br> <br>        hdcBits = CreateCompatibleDC (hdc); <br>        SetTextColor (hdcBits, 0xFFFFFFL); <br>        SetBkColor (hdcBits, 0x000000L); <br> <br>        /* Output the text to the DC */ <br>        /*if (hbm = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++ (dx, dy, 1, 1, NULL)){*/ <br>        if (hbm = CreateBitmap(dx, dy, 1, 1, NULL)){ <br>            hbm = SelectObject (hdcBits, hbm); <br>            ExtTextOut (hdcBits, 0, 0, 0, NULL, sz, len, NULL); <br>            BitBlt (hdc, x, y, dx, dy, hdcBits, 0, 0, SRCINVERT); <br>            hbm = SelectObject (hdcBits, hbm); <br>            DeleteObject (hbm); <br>        } <br>        DeleteDC (hdcBits); <br>        UNREFERENCED_PARAMETER(fDraw); <br>    } <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : NormalizeRect(RECT *prc)                                   * <br> *                                                                          * <br> *  PURPOSE    : If the rectangle coordinates are reversed, swaps them      * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID PASCAL NormalizeRect (RECT *prc) <br>{ <br>    if (prc-&gt;right &lt; prc-&gt;left) <br>        SWAP(prc-&gt;right,prc-&gt;left); <br>    if (prc-&gt;bottom &lt; prc-&gt;top) <br>        SWAP(prc-&gt;bottom,prc-&gt;top); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : TrackMouse(HWND hwnd, POINT pt)                            * <br> *                                                                          * <br> *  PURPOSE    : Draws a rubberbanding rectangle and displays it's          * <br> *               dimensions till the mouse button is released               * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID TrackMouse ( <br>    HWND hwnd, <br>    MPOINT pt) <br>{ <br>//    MPOINT ptBase; <br>    HDC   hdc; <br>    MSG   msg; <br>    MPOINT ptOrigin; <br>    RECT  rcClient; <br> <br>    hdc = GetDC(hwnd); <br>    SetCapture(hwnd); <br> <br>    GetClientRect(hwnd,&amp;rcClient); <br> <br>    /* Get mouse coordinates relative to origin of DIB */ <br>    ptOrigin.x = (short int)GetScrollPos(hwnd,SB_HORZ); <br>    ptOrigin.y = (short int)GetScrollPos(hwnd,SB_VERT); <br> <br>    pt.x += ptOrigin.x; <br>    pt.y += ptOrigin.y; <br> <br>    /* Display the coordinates */ <br>    (VOID)SetWindowOrgEx(hdc, ptOrigin.x, ptOrigin.y, NULL); <br>    DrawSelect(hdc,FALSE); <br> <br>    /* Initialize clip rectangle to the point */ <br>    rcClip.left   = pt.x; <br>    rcClip.top    = pt.y; <br>    rcClip.right  = pt.x; <br>    rcClip.bottom = pt.y; <br> <br>    /* Eat mouse messages until a WM_LBUTTONUP is encountered. Meanwhile <br>     * continue to draw a rubberbanding rectangle and display it's dimensions <br>     */ <br>    for (;;){ <br>        WaitMessage(); <br>        if (PeekMessage(&amp;msg,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE)){ <br>            DrawSelect(hdc,FALSE); <br> <br>            rcClip.left   = pt.x; <br>            rcClip.top    = pt.y; <br>            rcClip.right  = LOWORD(msg.lParam) + ptOrigin.x; <br>            rcClip.bottom = HIWORD(msg.lParam) + ptOrigin.y; <br> <br>            NormalizeRect(&amp;rcClip); <br>            DrawSelect(hdc,TRUE); <br> <br>            if (msg.message == WM_LBUTTONUP) <br>                break; <br>        } <br>        else <br>            continue; <br>    } <br> <br>    ReleaseCapture(); <br>    ReleaseDC(hwnd,hdc); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : BandDIB(HWND hWnd, HDC hDC, int x, int y)                  * <br> *                                                                          * <br> *  PURPOSE    : Outputs the DIB in bands to a device or the screen, using  * <br> *               the maximum possible band size.                            * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID BandDIB ( <br>    HWND hWnd, <br>    HDC hDC, <br>    INT x, <br>    INT y) <br>{ <br>    HBITMAP            hBitmap, hOld ; <br>    HDC                hMemDC ; <br>    LPSTR              pBuf; <br>    LPBITMAPINFOHEADER lpbi; <br>    WORD               wRead, wActualPosition, wScansLeft  ; <br>    DWORD              dwMapSize; <br>    DWORD              dwScans; <br>    WORD               wBitmapHeight; <br>    RECT               Rect; <br>    HANDLE             hBuf; <br>    BOOL               bSuccess = FALSE; <br>    INT                nBandSize; <br>    HPALETTE           hOldMemPal; <br>    HPALETTE           hOldPal; <br>    HFILE              fh; <br>    OFSTRUCT           of; <br>    CHAR               lpBuffer[128]; <br> <br>    /* Open the map file and get the information out */ <br>    fh = OpenFile(achFileName, (LPOFSTRUCT)&amp;of, (UINT)OF_READ); <br> <br>    if (fh == -1) <br>        return; <br>    lpbi = (VOID FAR *)GlobalLock(hbiCurrent); <br>    if (!lpbi){ <br>        _lclose(fh); <br>        return; <br>    } <br> <br>    /* Compute scan size in bytes */ <br>    dwScans = WIDTHBYTES((DWORD)lpbi-&gt;biWidth * lpbi-&gt;biBitCount); <br> <br>    wBitmapHeight = (WORD)lpbi-&gt;biHeight ; <br>    wScansLeft    = (WORD)lpbi-&gt;biHeight ; <br> <br>    hMemDC = NULL; <br>    for ( nBandSize = wScansLeft; <br>          (WORD)nBandSize &gt;= MINBAND || (WORD)nBandSize == wScansLeft; <br>          nBandSize -= BANDINCREMENT) { <br> <br>        /* Attempt to maximize band size by trying to allocate a buffer <br>         * for the given band size. If allocation fails, try again with the <br>         * smaller band size. <br>         */ <br>        hBuf = GlobalAlloc (GMEM_FIXED | GMEM_ZEROINIT, dwScans * nBandSize) ; <br>        if (!hBuf) <br>            continue; <br> <br>        /* Show success and exit loop if we're going to set bits to device. */ <br>        if (bDIBToDevice) { <br>            (int)hMemDC = 1; <br>            break; <br>        } <br>        else { <br>            /* Create a device-dependent bitmap to hold the bits */ <br>            hBitmap = CreateCompatibleBitmap (hDC, <br>                                              (WORD)lpbi-&gt;biWidth, <br>                                              nBandSize); <br>            if (!hBitmap) { <br>                /* Try again for the next smaller band size */ <br>                GlobalFree (hBuf); <br>                continue; <br>            } <br> <br>            /* Create a memory context for the bitmap */ <br>            if (!(hMemDC = CreateCompatibleDC (hDC))) { <br>                GlobalFree (hBuf); <br>                DeleteObject (hBitmap); <br>                continue; <br>            } else <br>                /* Success in creating a DC */ <br>                break; <br>        } <br>    } <br>    if (!hMemDC) { <br> <br>        /* We failed allocation , so give error message and quit */ <br>        if (GetFocus () == hWnd) { <br>            LoadString(hInst, IDS_NOMEM, lpBuffer, sizeof(lpBuffer)); <br>            ErrMsg (lpBuffer); <br>            ValidateRect (hWnd, (LPRECT) (NULL)); <br>        } else <br>            MessageBeep(0); <br> <br>        GlobalUnlock(hbiCurrent); <br>        _lclose(fh); <br>        return; <br>    } <br>    pBuf = GlobalLock (hBuf); <br> <br>    /* Calculate number of bytes to be transferred */ <br>    dwMapSize = dwScans * nBandSize ; <br> <br>    /* Manipulate palette appropriately */ <br>    if (!bDIBToDevice) <br>        hOldMemPal = SelectPalette (hMemDC, hpalCurrent, 0) ; <br> <br>    /* Now get to the start of the map in the file */ <br>    _llseek(fh, dwOffset, (UINT)SEEK_SET); <br> <br>    /* we are now all set to start off */ <br>    wActualPosition = wScansLeft ; <br> <br>    Rect.left  = 0; <br>    Rect.right = (WORD)lpbi-&gt;biWidth; <br> <br>    hOldPal = SelectPalette(hDC, hpalCurrent, 0); <br>    RealizePalette(hDC); <br> <br>    do { <br>        /* Read in nBandSize scans or whatever is left */ <br>        if (wScansLeft &gt; (WORD)nBandSize) <br>            wRead = (WORD)nBandSize ; <br>        else <br>            wRead = wScansLeft ; <br> <br>        Rect.bottom = wActualPosition; <br>        wActualPosition -= wRead ; <br>        Rect.top = wActualPosition; <br> <br>        dwMapSize = ((DWORD) wRead) * dwScans ; <br> <br>        /* Now read in the map to the global buffer */ <br>        if (RectVisible (hDC, &amp;Rect)) { <br>            lread(fh, (LPSTR)pBuf, dwMapSize); <br> <br>            if (bDIBToDevice) { <br>                if (wRead != (WORD)SetDIBitsToDevice (hDC, x, y, <br>                                                (WORD)lpbi-&gt;biWidth, <br>                                                wBitmapHeight, <br>                                                0, <br>                                                0, <br>                                                wBitmapHeight - wScansLeft, <br>                                                wRead, <br>                                                pBuf, <br>                                                (LPBITMAPINFO)lpbi, <br>                                                fPalColors ? <br>                                                DIB_PAL_COLORS : <br>                                                DIB_RGB_COLORS)){ <br>                    LoadString(hInst, IDS_CANTDRAWSCANS, lpBuffer, sizeof(lpBuffer)); <br>                    ErrMsg(lpBuffer); <br>                    GlobalUnlock(hBuf); <br>                    GlobalFree(hBuf); <br>                    GlobalUnlock(hbiCurrent); <br>                    _lclose(fh); <br>                    return; <br>                } <br>            } else { <br>                lpbi-&gt;biHeight = wRead ; <br> <br>                /* Set the DIB bits to a device-dependent format */ <br>                if (lpbi-&gt;biHeight != (int)SetDIBits (hMemDC, <br>                                                       hBitmap, <br>                                                       0, <br>                                                       (WORD)lpbi-&gt;biHeight, <br>                                                       pBuf, <br>                                                       (LPBITMAPINFO)lpbi, <br>                                                       (DWORD) (fPalColors ? <br>                                                       DIB_PAL_COLORS : <br>                                                       DIB_RGB_COLORS))){ <br>                    LoadString(hInst, IDS_CANTDRAWSCANS, lpBuffer, sizeof(lpBuffer)); <br>                    ErrMsg(lpBuffer); <br>                    GlobalUnlock (hBuf); <br>                    GlobalFree (hBuf); <br>                    GlobalUnlock(hbiCurrent); <br>                    _lclose(fh); <br>                    return; <br>                } <br> <br>                /* Blt own map onto the screen, remembering the point to start */ <br>                hOld = SelectObject (hMemDC, hBitmap) ; <br>                if (!BitBlt (hDC, 0, wActualPosition, <br>                             (WORD)lpbi-&gt;biWidth, <br>                             (WORD)lpbi-&gt;biHeight, <br>                             hMemDC, 0, 0, SRCCOPY)){ <br>                    LoadString(hInst, IDS_CANTDRAWMAP, lpBuffer, sizeof(lpBuffer)); <br>                    ErrMsg (lpBuffer); <br>                    GlobalUnlock (hBuf); <br>                    GlobalFree (hBuf); <br>                    GlobalUnlock(hbiCurrent); <br>                    _lclose(fh); <br>                    return; <br>                } <br>                SelectObject (hMemDC, hOld) ; <br> <br>                /* Restore the value of bitmap height */ <br>                lpbi-&gt;biHeight = wBitmapHeight ; <br>            } <br>        } <br>        else { <br>            /* This chunk is not visible, seek over the data in the file */ <br>            _llseek(fh, dwMapSize, (UINT)SEEK_CUR); <br>        } <br>        wScansLeft -= wRead ; <br>    } while (wScansLeft &gt; 0 ) ; <br> <br>    /* Delete the objects just created above */ <br>    GlobalUnlock (hBuf); <br>    GlobalFree (hBuf); <br>    SelectPalette (hDC, hOldPal, 0); <br> <br>    /* Set success flag */ <br>    bSuccess = TRUE; <br> <br>    if (!bDIBToDevice) { <br>        SelectPalette (hMemDC, hOldMemPal, 0); <br>        DeleteDC (hMemDC) ; <br>        DeleteObject (hBitmap) ; <br>    } <br>    GlobalUnlock(hbiCurrent); <br> <br>    /* Close the file */ <br>    _lclose(fh); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : SizeWindow(HWND hWnd)                                      * <br> *                                                                          * <br> *  PURPOSE    : Sizes the app. window based on client dimensions (DIB      * <br> *               dimensions) and style. Sets the caption text.              * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID SizeWindow (HWND hWnd) <br>{ <br>    CHAR  *pstr; <br>    CHAR  Name[60]; <br>    RECT  Rectangle; <br>    RECT  rectClient; <br>//    INT   dx,dy; <br>//    MPOINT pt; <br>    BITMAPINFOHEADER bi; <br> <br>    /* Get information about current DIB */ <br>    DibInfo(hbiCurrent,&amp;bi); <br> <br>    /* Extract the filename from the full pathname */ <br>    pstr = achFileName + lstrlen(achFileName); <br>    while ( (pstr &gt; achFileName) &amp;&amp; (*pstr != '\\') &amp;&amp; (*pstr != ':') ) <br>    pstr = CharPrev(achFileName, pstr); <br> <br>    if(pstr != achFileName) <br>            pstr++; <br> <br>    /* Format filename along with the DIB attributes */ <br>    sprintf (Name, <br>              "%s (%s %dx%dx%d%s)", <br>              szAppName, <br>              pstr, <br>              (WORD)bi.biWidth, <br>              (WORD)bi.biHeight, <br>              (WORD)bi.biBitCount, <br>              bi.biCompression == BI_RGB  ? " RGB" : <br>              bi.biCompression == BI_RLE8 ? " RLE8" : " RLE4" ); <br> <br>    /* Show formatted text in the caption bar */ <br>    SetWindowText (hWnd, Name); <br> <br>    /* Store the size in ptSize, so the scroll bars will work. */ <br>    ptSize.x = (WORD)bi.biWidth; <br>    ptSize.y = (WORD)bi.biHeight; <br> <br>    if (IsZoomed (hWnd)) <br>        SetScrollRanges (hWnd); <br>    else { <br>        Rectangle.left   = 0; <br>        Rectangle.top    = 0; <br>        Rectangle.right  = (WORD)bi.biWidth; <br>        Rectangle.bottom = (WORD)bi.biHeight; <br> <br>        /* Compute the size of the window rectangle based on the given <br>         * client rectangle size and the window style, then size the <br>         * window. <br>         */ <br>        AdjustWindowRect (&amp;Rectangle, dwStyle, TRUE); <br>        SetWindowPos (hWnd, (HWND)NULL, 0, 0, <br>                      Rectangle.right  - Rectangle.left + 1, <br>                      Rectangle.bottom - Rectangle.top + 1, <br>                      SWP_NOMOVE | SWP_NOZORDER); <br>        GetClientRect( hWnd, &amp;rectClient ); <br>        // Correct for small bitmap that causes multiline menu <br>        if (rectClient.bottom &lt; Rectangle.bottom) { <br>            Rectangle.bottom += (Rectangle.bottom - rectClient.bottom); <br>            SetWindowPos (hWnd, (HWND)NULL, 0, 0, <br>                      Rectangle.right  - Rectangle.left + 1, <br>                      Rectangle.bottom - Rectangle.top + 1, <br>                      SWP_NOMOVE | SWP_NOZORDER); <br>        } <br>    } <br> <br>    InvalidateRect(hWnd,NULL,TRUE); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : GetRealClientRect(HWND hwnd, LPRECT lprc)                  * <br> *                                                                          * <br> *  PURPOSE    : Calculates the client rectangle taking scrollbars into     * <br> *               consideration.                                             * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID GetRealClientRect ( <br>    HWND hwnd, <br>    PRECT lprc) <br>{ <br>    DWORD dwStyle; <br> <br>    dwStyle = GetWindowLong (hwnd, GWL_STYLE); <br>    GetClientRect (hwnd,lprc); <br> <br>    if (dwStyle &amp; WS_HSCROLL) <br>        lprc-&gt;bottom += GetSystemMetrics (SM_CYHSCROLL); <br> <br>    if (dwStyle &amp; WS_VSCROLL) <br>        lprc-&gt;right  += GetSystemMetrics (SM_CXVSCROLL); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : SetScrollRanges(hwnd)                                      * <br> *                                                                          * <br> *  PURPOSE    :                                                            * <br> *                                                                          * <br> ****************************************************************************/ <br>VOID SetScrollRanges(HWND hwnd) <br>{ <br>    RECT       rc; <br>    INT        iRangeH, iRangeV, i; <br>    static INT iSem = 0; <br> <br>    if (!iSem){ <br>        iSem++; <br>        GetRealClientRect (hwnd, &amp;rc); <br> <br>        for (i = 0; i &lt; 2; i++){ <br>            iRangeV = ptSize.y - rc.bottom; <br>            iRangeH = ptSize.x - rc.right; <br> <br>            if (iRangeH &lt; 0) iRangeH = 0; <br>            if (iRangeV &lt; 0) iRangeV = 0; <br> <br>            if (GetScrollPos ( hwnd, <br>                               SB_VERT) &gt; iRangeV || <br>                               GetScrollPos (hwnd, SB_HORZ) &gt; iRangeH) <br>                InvalidateRect (hwnd, NULL, TRUE); <br> <br>            SetScrollRange (hwnd, SB_VERT, 0, iRangeV, TRUE); <br>            SetScrollRange (hwnd, SB_HORZ, 0, iRangeH, TRUE); <br> <br>            GetClientRect (hwnd, &amp;rc); <br>        } <br>        iSem--; <br>    } <br>} <br> <br>/*********** THE FOLLOWING FUNCTIONS ARE FOR CLIPBOARD SUPPORT **************/ <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CopyHandle (HANDLE h)                                      * <br> *                                                                          * <br> *  PURPOSE    : Makes a copy of the given global memory block.             * <br> *                                                                          * <br> *  RETURNS    : A handle to the new block.                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE CopyHandle (HANDLE h) <br>{ <br>    BYTE *lpCopy; <br>    BYTE *lp; <br>    HANDLE hCopy; <br>    DWORD  dwLen; <br> <br>    dwLen = GlobalSize (h); <br>    if (hCopy = GlobalAlloc (GHND, dwLen)) { <br> <br>        lpCopy = (BYTE *)GlobalLock (hCopy); <br>        lp     = (BYTE *)GlobalLock (h); <br>        while (dwLen--) *lpCopy++ = *lp++; <br>        GlobalUnlock (hCopy); <br>        GlobalUnlock (h); <br>    } <br>    return hCopy; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CopyPalette(HPALETTE hpal)                                 * <br> *                                                                          * <br> *  PURPOSE    : Makes a copy of a GDI logical palette                      * <br> *                                                                          * <br> *  RETURNS    : A handle to the new palette.                               * <br> *                                                                          * <br> ****************************************************************************/ <br>HPALETTE CopyPalette (HPALETTE hpal) <br>{ <br>    PLOGPALETTE ppal; <br>    WORD        nNumEntries; <br> <br>    if (!hpal) <br>        return NULL; <br> <br>    GetObject(hpal,sizeof(INT),(LPSTR)&amp;nNumEntries); <br> <br>    if (nNumEntries == 0) </code></pre>
<p>
</p>
<pre><code>return NULL; <br> <br>    ppal = (PLOGPALETTE)LocalAlloc(LPTR,sizeof(LOGPALETTE) + <br>                nNumEntries * sizeof(PALETTEENTRY)); <br> <br>    if (!ppal) <br>        return NULL; <br> <br>    ppal-&gt;palVersion    = PALVERSION; <br>    ppal-&gt;palNumEntries = nNumEntries; <br> <br>    GetPaletteEntries(hpal,0,nNumEntries,(LPPALETTEENTRY)ppal-&gt;palPalEntry); <br> <br>    hpal = CreatePalette(ppal); <br> <br>    LocalFree((HANDLE)ppal); <br>    return hpal; <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CopyBitmap (HBITMAP hbm)                                   * <br> *                                                                          * <br> *  PURPOSE    : Copies the given bitmap to another.                        * <br> *                                                                          * <br> *  RETURNS    : A handle to the new bitmap.                                * <br> *                                                                          * <br> ****************************************************************************/ <br>HBITMAP CopyBitmap (HBITMAP hbm) <br>{ <br>    BITMAP  bm; <br>    RECT    rc; <br> <br>    if (!hbm) <br>         return NULL; <br> <br>    GetObject (hbm, sizeof(BITMAP), (LPSTR)&amp;bm); <br>    rc.left   = 0; <br>    rc.top    = 0; <br>    rc.right  = bm.bmWidth; <br>    rc.bottom = bm.bmHeight; <br> <br>    return CropBitmap (hbm, &amp;rc); <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  CropBitmap (hbm,lprect)                                   * <br> *                                                                          * <br> *  PURPOSE    :  Crops a bitmap to a new size specified by the lprect      * <br> *                parameter.                                                * <br> *                                                                          * <br> *  RETURNS    :  A handle to the new bitmap.                               * <br> *                                                                          * <br> ****************************************************************************/ <br>HBITMAP CropBitmap ( <br>    HBITMAP hbm, <br>    PRECT prc) <br>{ <br>    HDC     hMemDCsrc; <br>    HDC     hMemDCdst; <br>    HDC     hdc; <br>    HBITMAP hNewBm; <br>    BITMAP  bm; <br>    INT     dx,dy; <br> <br>    if (!hbm) <br>         return NULL; <br> <br>    hdc = GetDC (NULL); <br>    hMemDCsrc = CreateCompatibleDC (hdc); <br>    hMemDCdst = CreateCompatibleDC (hdc); <br> <br>    GetObject (hbm, sizeof(BITMAP), (LPSTR)&amp;bm); <br>    dx = prc-&gt;right  - prc-&gt;left; <br>    dy = prc-&gt;bottom - prc-&gt;top; <br> <br>    /*hNewBm = +++CreateBitmap - Not Recommended(use CreateDIBitmap)+++ (dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL);*/ <br>    hNewBm = CreateBitmap(dx, dy, bm.bmPlanes, bm.bmBitsPixel, NULL); <br>    if (hNewBm){ <br>        SelectObject (hMemDCsrc, hbm); <br>        SelectObject (hMemDCdst, hNewBm); <br> <br>        BitBlt (hMemDCdst, <br>                0, <br>                0, <br>                dx, <br>                dy, <br>                hMemDCsrc, <br>                prc-&gt;left, <br>                prc-&gt;top, <br>                SRCCOPY); <br>    } <br> <br>    ReleaseDC (NULL,hdc); <br>    DeleteDC (hMemDCsrc); <br>    DeleteDC (hMemDCdst); <br>    return hNewBm; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : RenderFormat(int cf)                                       * <br> *                                                                          * <br> *  PURPOSE    : Renders the currently displayed DIB in CF_DIB or           * <br> *               CF_BITMAP format.The bitmap is clipped to the current      * <br> *               rcClip.                                                    * <br> *                                                                          * <br> *  RETURNS    : A handle to the DIB                                        * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE RenderFormat (INT cf) <br>{ <br>    HANDLE  h = NULL; <br>    HBITMAP hbm; <br> <br>    if (!bLegitDraw) <br>        return NULL; <br> <br>    switch (cf){ <br>        case CF_BITMAP: <br>            if (hbmCurrent &amp;&amp; !IsRectEmpty (&amp;rcClip)) <br>                h = CropBitmap (hbmCurrent, &amp;rcClip); <br>            else{ <br>                if (hbmCurrent) <br>                    h = CopyBitmap (hbmCurrent); <br>                else if (hdibCurrent) <br>                    h = BitmapFromDib (hdibCurrent, hpalCurrent); <br>                else if (achFileName[0] &amp;&amp; (hdibCurrent = OpenDIB (achFileName))) <br>                    h = BitmapFromDib (hdibCurrent, hpalCurrent); <br>                else <br>                    h = NULL; <br> <br>                if (h &amp;&amp; !IsRectEmpty (&amp;rcClip)){ <br>                    hbm = CropBitmap (h,&amp;rcClip); <br>                    DeleteObject (h); <br>                    h = hbm; <br>                } <br>            } <br>            break; <br> <br>        case CF_DIB: <br>            if (!IsRectEmpty (&amp;rcClip)){ <br>                if (hbm = RenderFormat (CF_BITMAP)){ <br>                    h = DibFromBitmap (hbm, BI_RGB, 0, hpalCurrent); <br>                    DeleteObject (hbm); <br>                } <br>            } <br>            else{ <br>                if (!hdibCurrent &amp;&amp; hbmCurrent) <br>                    h = DibFromBitmap (hbmCurrent, BI_RGB, 0, hpalCurrent); <br>                else if (hdibCurrent) <br>                    h = CopyHandle (hdibCurrent); <br>                else if (achFileName[0]) <br>                    h = OpenDIB (achFileName); <br>                else <br>                    h = NULL; <br>            } <br>            break; <br> <br>        case CF_PALETTE: <br>            if (hpalCurrent) <br>                h = CopyPalette (hpalCurrent); <br>            break; <br>    } <br>    return h; <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  RealizeDibFormat(DWORD biStyle, WORD biBits)              * <br> *                                                                          * <br> *  PURPOSE    :  Realize the current DIB in the specifed format            * <br> *                This function is used to get a specific format of CF_DIB  * <br> *                                                                          * <br> *                    biStyle     DIB format      RGB or RLE                * <br> *                    biBits      Bits per pixel  1,4,8,24                  * <br> *                                                                          * <br> *  RETURNS    :  A handle to the created DIB.                              * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE RealizeDibFormat ( <br>    DWORD biStyle, <br>    WORD biBits) <br>{ <br>    BITMAPINFOHEADER bi; <br> <br>    if (!bLegitDraw) <br>        return NULL; <br> <br>    DibInfo (hbiCurrent, &amp;bi); <br> <br>    /*  Do we have the requested format already? */ <br>    if (bi.biCompression == biStyle &amp;&amp; bi.biBitCount == biBits){ <br>        if (!hdibCurrent) <br>            hdibCurrent = RenderFormat (CF_DIB); <br>    } <br>    else{ <br>        if (!hbmCurrent) <br>            hbmCurrent = RenderFormat (CF_BITMAP); <br> <br>        if (hbmCurrent){ <br>            if (hdibCurrent) <br>                GlobalFree (hdibCurrent); <br> <br>            hdibCurrent = DibFromBitmap (hbmCurrent, biStyle, biBits, hpalCurrent); <br>        } <br>    } <br> <br>    return hdibCurrent; <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ErrMsg (PSTR sz,...)                                       * <br> *                                                                          * <br> *  PURPOSE    : Opens a Message box with a error message in it.The user can* <br> *               select the OK button to continue                           * <br> *                                                                          * <br> *  RETURNS    : FALSE to indicate an error has occured.                    * <br> *                                                                          * <br> ****************************************************************************/ <br>INT ErrMsg (PSTR sz,...) <br>{ <br>    CHAR ach[128]; <br>    va_list args;  <br> <br>    va_start(args, sz);  <br> <br>    wvsprintf (ach, sz, args);   /* Format the string */ <br>    MessageBox (NULL, ach, NULL, MB_OK|MB_ICONEXCLAMATION|MB_APPLMODAL); <br>    return FALSE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : fDialog(int id,HWND hwnd,FARPROC fpfn)                     * <br> *                                                                          * <br> *  PURPOSE    : This function displays a dialog box                        * <br> *                                                                          * <br> *  RETURNS    : The exit code.                                             * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL fDialog ( <br>    INT id, <br>    HWND hwnd, <br>    FARPROC fpfn) <br>{ <br>    BOOL        f; <br>    HANDLE      hInst; <br> <br>    hInst = (HANDLE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>    fpfn  = MakeProcInstance (fpfn, hInst); <br>    f = DialogBox (hInst, MAKEINTRESOURCE(id), hwnd, (DLGPROC)fpfn); <br>    FreeProcInstance (fpfn); <br>    return f; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : AppAbout( hDlg, uiMessage, wParam, lParam )                * <br> *                                                                          * <br> *  PURPOSE    : Dialog function for the About... dialog box                * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL APIENTRY AppAbout( <br>    HWND         hDlg, <br>    UINT         uiMessage, <br>    UINT         wParam, <br>    LONG         lParam) <br>{ <br>    switch (uiMessage) { <br>        case WM_COMMAND: <br>            if (LOWORD(wParam) == IDOK) <br>                EndDialog (hDlg, TRUE); <br>            break; <br> <br>        case WM_INITDIALOG: <br>            return TRUE; <br>    } <br>    return FALSE; <br>        UNREFERENCED_PARAMETER(lParam); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
