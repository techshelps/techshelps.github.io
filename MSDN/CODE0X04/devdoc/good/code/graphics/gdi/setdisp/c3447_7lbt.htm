<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SETDISP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3449"></a>SETDISP.C</h2>
<pre><code>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br>/******************************************************************************\ <br>*                                                               <br>*   Implementation file for SetDisp                            <br>*                                                               <br>*   SetDisp creates a tray Notification Icon                   <br>*   that you can use to dynamically change your srceen          <br>*   resolution. The core APIs used are:                         <br>*                                                               <br>*   Shell_NotifyIcon -- to create and maintain the tray icon    <br>*   TrackPopupMenu   -- to implement the icon resolution        <br>*                       context menu                            <br>*   ChangeDisplaySettings -- to test and set the display        <br>*                       settings dynamically and to update      <br>*                       the registry with these setttings       <br>*   EnumDisplaySettings -- to get the display settings that are <br>*                       supported by the video driver           <br>* <br>*   KNOWN ISSUES:  On Windows 95 one cannot use the EnunDisplaySettings <br>*   to get the current settings.  This causes the check mark to not <br>*   be displayed and the current setting to not be bolded.  This  <br>*   information could be obtained from the registry. Also on Windows 95 <br>*   color depth changes require a reboot.  None of the possible returns <br>*   from ChangeDisplaySettings are currently handled execpt for  <br>*   success and a message is displayed indicated the sample does not <br>*   support a reboot. If your driver has many resolutions, the menu <br>*   may not fit on some resolutions.  This could be resolved with  <br>*   the use of sub menus for different settings such as color depth <br>*   or frequencies. <br>*                                                                  <br>\******************************************************************************/ <br> <br>#if DBG <br> <br>#define TRC(_x) OutputDebugString(TEXT(_x)) <br> <br>#else <br> <br>#define TRC(_x) <br> <br>#endif <br> <br>#include "setdisp.h" <br>#include &lt;windowsx.h&gt; <br>#include &lt;winuser.h&gt; <br>#include "resource.h" <br> <br> <br>/**************************************************************\ <br>*                                                              *  <br>*  Tray Icon Structure taken from Win32\TrayNot sample         * <br>*                                                              *  <br>\**************************************************************/ <br> <br>struct _DLGITEMS <br>{ <br>DWORD dwStart; <br>UINT uNotify; <br>UINT uDelayID; <br>UINT uState1; <br>UINT uTip1; <br>UINT uState2; <br>UINT uTip2; <br>} g_sDlgItems [] = <br> <br>// <br>// Data for one tray icon <br>// <br> <br>{ <br>{ <br>0, IDC_NOTIFY1, IDC_DELAY1, IDC_STATE11, IDC_TIP11, IDC_STATE12, IDC_TIP12, <br>}, <br>} ; <br> <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : WinMain (HINSTANCE hInstance,  HINSTANCE hPrevInstance,  <br> *                        LPSTR lpCmdLine, int nCmdShow ) <br> *                                                                           <br> *  PURPOSE    : Creates a dialog box which implements the tray icon <br> *               and which handles the resolution changes <br> *                                                                           <br> \****************************************************************************/ <br> <br>int WINAPI WinMain ( <br> <br>  HINSTANCE hInstance,  <br>  HINSTANCE hPrevInstance,  <br>  LPSTR lpCmdLine,  <br>  int nCmdShow ) <br>{ <br> <br>    g_hinst = hInstance; <br> <br>    DialogBox(hInstance, MAKEINTRESOURCE(IDD_SETDISP), NULL, SetDispDlgProc); <br> <br>    if (gpDevModes) <br>    { <br>        free(gpDevModes); <br>    } <br> <br>    return(FALSE); <br> <br>} <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : SetDispDlgProc (HWND hDlg, UINT uMsg, <br> *                                WPARAM wParam, LPARAM lParam) <br> *                                                                           <br> *  PURPOSE    : Dialog box callback which manages the tray icon <br> *               and which handles the resolution changes <br> *                                                                           <br> \****************************************************************************/ <br> <br>BOOL CALLBACK SetDispDlgProc ( <br>   <br>   HWND hDlg,  <br>   UINT uMsg,  <br>   WPARAM wParam,  <br>   LPARAM lParam) <br>{ <br> <br>    switch (uMsg) <br>    { <br> <br>    case WM_INITDIALOG: <br>    { <br>BOOL bRet; <br> <br>// <br>//Get DEVMODES <br>// <br> <br>bRet = GetDevModes (hDlg); <br> <br>        if (bRet == FALSE) <br>        { <br>            // <br>            // Failed to get DEVMODES so end the dialog <br>            // <br>         <br>    EndDialog(hDlg, TRUE); <br> <br>    break; <br>        } <br>         <br>// <br>// Initialize Menu with Resolutions <br>// <br> <br>SetResolutionMenu (hDlg); <br>         <br>// <br>// Add Tray Notify Icon <br>// <br> <br>NotifyAdd(hDlg, 0); <br>         <br>// <br>// Update Tip to current settings <br>// <br>{ <br>         <br>    char szTip[50]; <br> <br>    // <br>    // Set the menu text <br>    // <br> <br>    if (IsNT()) <br>            { <br>                wsprintf(szTip,"%d x %d, %d bit color at %d hz", <br>                         gpCurrentMode-&gt;dmPelsWidth, <br>                         gpCurrentMode-&gt;dmPelsHeight, <br>                         gpCurrentMode-&gt;dmBitsPerPel, <br>                         gpCurrentMode-&gt;dmDisplayFrequency); <br>            } <br>            else <br>            { <br>                szTip[0] = '\0'; <br>            } <br>         <br>    // <br>    // For the current mode, set the tool tip <br>            // <br> <br>    TrayMessage(hDlg, NIM_MODIFY, g_sDlgItems[0].uNotify, <br>                        LoadImage(g_hinst, MAKEINTRESOURCE(IDI_SETDISP), <br>                        IMAGE_ICON, 16, 16, 0), szTip); <br>} <br>  <br>SetForegroundWindow (hDlg); <br> <br>break; <br>     <br>    }// WM_INITDIALOG: <br> <br>    case WM_DESTROY:NotifyDelete(hDlg, 0); <br>break; <br> <br>    case WM_COMMAND: <br>    { <br>switch (GET_WM_COMMAND_ID(wParam, lParam)) <br>{ <br>    case IDCANCEL:   EndDialog(hDlg, TRUE); <br>     break; <br> <br>    case IDABORT:    ShowWindow(hDlg, SW_HIDE); <br>     break; <br>         <br>    case IDM_ABOUT: <br>  DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ABOUT), <br>    hDlg, (DLGPROC)About); <br>  break; <br> <br>    default: <br>         <br>    // <br>    // handle MYWM_NOTIFYICON + 10 + i for diffent devmodes <br>    // <br> <br>            if ( MYWM_NOTIFYICON + 10  &lt;= GET_WM_COMMAND_ID(wParam, lParam) &amp;&amp; <br> MYWM_NOTIFYICON + 11 + gnModes &gt;= GET_WM_COMMAND_ID(wParam, lParam)) <br>    { <br>UINT nNewMode; <br>                 <br>                nNewMode = GET_WM_COMMAND_ID(wParam, lParam) - (MYWM_NOTIFYICON + 10); <br>                 <br>// <br>// Only update if the chose a new setting <br>// <br> <br>                if (gnCurrentMode != nNewMode) <br>                {             <br>   ChangeResolution (nNewMode, hDlg); <br>} <br> <br>break; <br>             <br>            } <br> <br> <br>} //WM_COMMAN switch <br> <br>    } //WM_COMMAND <br> <br>    case MYWM_NOTIFYICON: <br>    { <br>switch (lParam) <br>{ <br> <br>    case WM_LBUTTONDOWN: <br>         <br> // <br> // Handle popup here when user right mouse clicks tray icon <br> // <br> { <br>             <br>     // <br>     // Handle popup here <br>     // <br> <br>     POINT point; <br>  <br>     GetCursorPos (&amp;point); <br> <br>     HandlePopupMenu (hDlg, point); <br>             <br>     break; <br>     <br> } <br>     <br> <br>    case WM_RBUTTONDOWN: <br> switch (wParam) <br> { <br>             <br>    // <br>    // Diplay the dialog box on Left mouse click <br>    // this is how the user gets the dialog back if it is hidden <br>    // <br> <br>    case IDC_NOTIFY1:  ShowWindow (hDlg, SW_RESTORE); <br>       SetForegroundWindow (hDlg); <br>       break; <br> <br>    default: <br> break; <br> <br>  } <br> <br>        <br>    default: <br> break; <br> <br>}  // lParam switch <br> <br>    }// MYWM_NOTIFYICON <br> <br>    default: <br> return(FALSE); <br>     <br>    }  // switch (uMsg) <br> <br>    return(TRUE); <br> <br>} <br> <br>/**************************************************************************** <br>*                                                                           <br>*  FUNCTION   : GetDevModes (hwnd) <br>*                                                                           <br>*  PURPOSE    : Get the display modes supported by the current driver <br>* <br>\****************************************************************************/ <br>BOOL GetDevModes ( <br>                   <br>  HWND hwnd) <br>{ <br> <br>    BOOL bRet = TRUE; <br>    BOOL bAddDM; <br>    UINT iModeNum = 0; <br>    DEVMODE CurrentDM, WorkingDM; <br>    INT i; <br>    UINT nlist; <br>    LPDEVMODE pDM; <br> <br>    // <br>    // setting param 1 to NULL (lpszDeviceName) uses current device on NT <br>    // and NULL is required on Win95 <br>    // <br> <br>    if (IsNT()) <br>    { <br>// <br>// NT specific; returns current devmode when param 2 set to ENUM_CURRENT_SETTINGS, <br>// <br> <br>EnumDisplaySettings (NULL, ENUM_CURRENT_SETTINGS, &amp;CurrentDM); <br>    } <br> <br>    // <br>    // Determine how much memory we need <br>    // <br> <br>    for (iModeNum = 0, gnModes = -1; <br>         bRet &amp;&amp; (gnModes &lt;= MAX_MODES);  <br>         iModeNum++) <br>    { <br>        bRet = EnumDisplaySettings  <br>                     (NULL,            // use default device <br>                     iModeNum,         // DEVMODEs start at 0 <br>                     &amp;WorkingDM);      // if successful the system <br>                                       // fills in the DEVMODE <br>                                       // structure <br> <br>        // <br>        // For some reason my driver supports 1 hz display frequency <br>        // So filter out settings we do not want to display <br>        // <br>         <br>        if ( bRet &amp;  <br>     WorkingDM.dmPelsWidth  &gt;= MIN_WIDTH &amp;&amp; <br>            (WorkingDM.dmDisplayFrequency &gt;= MIN_FREQUENCY  || <br>     WorkingDM.dmDisplayFrequency == 0) ) <br> <br>    // <br>    // Accept 0 frequency since windows 95 does return frequency <br>    // <br>        { <br>            // <br>            // Increment to use next DEVMODE <br>            // <br> <br>            gnModes++; <br>} <br> <br>    } // for loop <br>     <br>    if(-1 == gnModes) <br>    { <br>        MessageBox(hwnd, "No Display modes available.", "SetDisp Error", IDOK); <br>        return (FALSE); <br>    } <br> <br>    // <br>    // We need gnModes worth of DEVMODE Structures <br>    // <br>     <br>    gpDevModes = (PDEVMODE) malloc ((size_t) (gnModes + 1) * sizeof(DEVMODE)); <br> <br>    if (gpDevModes == NULL) <br>    { <br>        return (FALSE); <br>    } <br> <br>    // <br>    // Loop through EnumDisplaySetting to get each supported DEVMODE <br>    // When returns false we have them all <br>    // <br>     <br>    for (iModeNum = 0, i = 0, bRet = TRUE;  <br>         bRet &amp;&amp; i &lt;= gnModes;  <br>         iModeNum++) <br>    { <br>        bRet = EnumDisplaySettings  <br>                     (NULL,            // use default device <br>                     iModeNum,         // DEVMODEs start at 0 <br>                     &amp;WorkingDM);      // if successful the system <br>                                       // fills in the DEVMODE <br>                                       // structure <br> <br>        // <br>        // Miniport drivers support 1 hz display frequency representing the default <br>        // and older drivers support 0 hz display frequency representing the default <br>        // So filter out settings we do not want to display <br>        // <br>         <br>        if ( bRet &amp;&amp;  <br>             WorkingDM.dmPelsWidth        &gt;= MIN_WIDTH      &amp;&amp;  <br>            (WorkingDM.dmDisplayFrequency &gt;= MIN_FREQUENCY  || <br>             WorkingDM.dmDisplayFrequency == 0              || <br>             WorkingDM.dmDisplayFrequency == 1)) <br>             // Accept 0 or 1 frequency which represent default frequencies <br>        { <br>            bAddDM = TRUE; <br> <br>            // <br>            // We will take this one unless another default has already been  <br>            // added at these settings <br>            // <br> <br>            if (WorkingDM.dmDisplayFrequency == 0 ||  <br>                WorkingDM.dmDisplayFrequency == 1) <br>            { <br>                for (nlist = 0; nlist &lt;= gnCurrentMode; nlist++) <br>                { <br>                      pDM = gpDevModes + nlist; <br> <br>                      if (pDM-&gt;dmPelsWidth  == WorkingDM.dmPelsWidth   &amp;&amp; <br>                          pDM-&gt;dmPelsHeight == WorkingDM.dmPelsHeight  &amp;&amp; <br>                          pDM-&gt;dmBitsPerPel == WorkingDM.dmBitsPerPel) <br>                      { <br>                          // <br>                          // If everything else is the same do not add another default <br>                          // <br> <br>                          bAddDM = FALSE; <br>                      } <br>                } // end for nlist <br> <br>            } // end if default <br> <br>            if (bAddDM) <br>            { <br>                // <br>                // Increment to use next DEVMODE <br>                // <br> <br>                if (i == 0) <br>                { <br>                    gpCurrentMode = gpDevModes; <br>                } <br>                else <br>                { <br>                    gpCurrentMode += 1; <br>                } <br> <br>                EnumDisplaySettings (NULL, iModeNum, gpCurrentMode); <br>                i++; <br> <br>            } // end if bAddDM <br> <br>        } // end bRet and hz if <br> <br>    } // end for EnumDisplaySettings <br> <br> <br>    // <br>    // Sort the array for display; default sort <br>    // A different compare routine could sort by different attributes <br>    // <br>     <br>    qsort((void *) gpDevModes,  <br>          (size_t) gnModes + 1,  // add one since gnModes is zero based  <br>          (size_t) sizeof(DEVMODE),  <br>          ( int (_cdecl*)(const void*,const void*) )CompareDevModes); <br>      <br>    // <br>    // Set gCurrentMode to CurrentDM <br>    // <br>    if (IsNT()) <br>    { <br>        for (i =0; i &lt;= gnModes; i++) <br>        { <br>             <br>            if (i == 0) <br>            { <br>                gpCurrentMode = gpDevModes; <br>            } <br>            else <br>            { <br>                gpCurrentMode += 1; <br>            } <br> <br>            if (0 == CompareDevModes (&amp;CurrentDM, gpCurrentMode)) <br>            { <br>                gnCurrentMode = i; <br>                break; <br>            } <br>        } <br>    } <br>    else <br>    { <br>        // <br>        // Default to the first one <br>        // since we error out if there is not even this one <br>        // <br> <br>        gnCurrentMode = 0; <br>    } <br> <br>    // <br>    // TODO: What if some of the DEVMODES are not supported on  <br>    //       the physical Device? <br>    // <br>     <br>    return (TRUE); <br> <br>}  //GetDevModes scope <br> <br> <br>/**************************************************************************** <br>*                                                 <br>*  FUNCTION   : ChangeResolution (UINT nNewMode, HWND hwnd) <br>*                                                 <br>*  PURPOSE    : Change the resolution to the nNewMode index DEVMODE                <br>*                                                                           <br>\****************************************************************************/ <br>BOOL ChangeResolution ( <br>    UINT nNewMode,  <br>    HWND hwnd ) <br>{ <br>   <br>    LONG lResult;       //Result of ChangeDisplaySettings <br>    INT nUserResponse;//Return from VerifyRes Dlg <br>    UINT nOldMode; <br> <br>   /* <br>    ChangeDisplaySettings can set <br>dmBitsPerPel    Bits per pixel <br>dmPelsWidth    Pixel width <br>dmPelsHeight    Pixel height <br>dmDisplayFlags    Mode flags <br>dmDisplayFrequency  Mode frequency <br>         <br>        but one of thes must be set in the DEVMODE dmFields <br>        DM_BITSPERPEL    Use the dmBitsPerPel value. <br>        DM_PELSWIDTH    Use the dmPelsWidth value. <br>        DM_PELSHEIGHT    Use the dmPelsHeight value. <br>        DM_DISPLAYFLAGS    Use the dmDisplayFlags value. <br>DM_DISPLAYFREQENCY  Use the dmDisplayFrequency value. <br> <br>    */ <br> <br>    // <br>    // First select a DevMode to use <br>    // to start, just cycling through them <br>    // <br> <br>    nOldMode = gnCurrentMode; <br>    gnCurrentMode = nNewMode; <br>     <br>    // <br>    // Increment ptr to the new mode <br>    // <br> <br>    gpCurrentMode = gpDevModes; <br>    gpCurrentMode += nNewMode; <br>     <br>    // <br>    // Verify that the DEVMODE select will change something <br>    // <br> <br>    if (!(DM_BITSPERPEL     &amp; gpCurrentMode-&gt;dmFields || <br>          DM_PELSWIDTH     &amp; gpCurrentMode-&gt;dmFields || <br>          DM_PELSHEIGHT     &amp; gpCurrentMode-&gt;dmFields || <br>          DM_DISPLAYFLAGS &amp; gpCurrentMode-&gt;dmFields || <br>          DM_DISPLAYFREQUENCY &amp; gpCurrentMode-&gt;dmFields ) ) <br>     <br>    { <br>     <br>// <br>        // Note our DEVMODE returned from EnumDisplaySettings <br>// So we should never enter here <br>// <br> <br>        gnCurrentMode = nOldMode; <br>         <br>        gpCurrentMode = gpDevModes; <br>        gpCurrentMode += gnCurrentMode; <br> <br>        return (FALSE); <br>    } <br> <br> <br>    /************************************************************\ <br>    *                                                            * <br>    *   Possible Flags for param 2 of ChangeDisplay Settings     * <br>    *    0        The graphics mode for the current            * <br>    *                screen will be changed dynamically.         * <br>    *    CDS_UPDATEREGISTRYThe graphics mode for the            * <br>    *                current screen will be changed dynamically  * <br>    *                and the graphics mode will be updated in    * <br>    *                the registry. The mode information is       * <br>    *                stored in the USER profile.                 * <br>    *    CDS_TESTThe system tests if the requested            * <br>    *                graphics mode could be set.                 * <br>    *                                                            * <br>    \************************************************************/ <br>     <br>    // <br>    // First have the system test if we can set it <br>    // <br> <br>    // <br>    // Param 1 is the new DEVMODE <br>    // Param 2 is Test Flag,  <br>    // which asks the operating system if this is a valid setting  <br>    // to change to -- wedon't want to make the system unusable <br>    // <br> <br>    lResult = ChangeDisplaySettings <br>                ( gpCurrentMode,  <br>                  CDS_TEST );                <br>                                       <br>     <br>    if (lResult == DISP_CHANGE_RESTART) <br>    { <br>        MessageBox(hwnd, "This mode requires a reboot which\n"  \ <br>                         "is not supported in this sample.",  <br> "SetDisp Message", IDOK); <br>         <br>        gnCurrentMode = nOldMode; <br>        gpCurrentMode = gpDevModes; <br>        gpCurrentMode += gnCurrentMode; <br> <br>        return FALSE; <br>    } <br> <br>    if (DISP_CHANGE_SUCCESSFUL ==lResult) <br>    { <br>     <br> // <br> // Param 2 is 0 to change dynamically <br> // hence the app name SetDisp! <br> // <br> <br>         lResult = ChangeDisplaySettings <br>                     ( gpCurrentMode, <br>                       0 );   <br>    } <br>     <br> <br> <br>    switch (lResult) <br>    { <br> <br>    case DISP_CHANGE_SUCCESSFUL:  //The settings change was successful. <br> TRC("DISP_CHANGE_SUCCESSFUL\n"); <br> break; <br> <br>    case DISP_CHANGE_RESTART:  //The computer must be restarted in order  <br>                                  //  for the graphics mode to work. <br>         TRC("DISP_CHANGE_RESTART\n"); <br>         break; <br> <br>    case DISP_CHANGE_BADFLAGS:  //An invalid set of flags was passed in. <br>         TRC("DISP_CHANGE_BADFLAGS\n"); <br>         break; <br> <br>    case DISP_CHANGE_FAILED:  //The display driver failed the specified  <br>                                  //  graphics mode. <br>         TRC("DISP_CHANGE_FAILED\n"); <br>         break; <br> <br>    case DISP_CHANGE_BADMODE:  //The graphics mode is not supported. <br>         TRC("DISP_CHANGE_BADMODE\n"); <br>         break; <br> <br>    case DISP_CHANGE_NOTUPDATED:  //Windows NT only: Unable to write settings  <br>                                  //  to the registry.                         <br>         TRC("DISP_CHANGE_NOTUPDATED\n"); <br>         break; <br>    default: <br> TRC("Undocumented return value!!!!\n"); <br> break; <br>    } <br> <br> <br>    // <br>    // Set a timer to only give the user so much <br>    // time to dedice incase the screen is garbled <br>    // <br> <br>    SetTimer(hwnd,VERIFY_RESCHANGE, VERIFY_TIMEOUT, VerifyTimerProc); <br> <br>    // <br>    // Have the user verify the new resolution and depth <br>    // <br> <br>    nUserResponse = DialogBox(g_hinst,// handle this application  <br>                              MAKEINTRESOURCE(IDD_VERIFYRES),// identifies dialog box template <br>                              NULL,               // handle to owner window <br>                              VerifyDlgProc);  // the dialog box procedure <br> <br> <br>    // <br>    // The verification is over, kill the timer <br>    // <br> <br>    KillTimer(hwnd,VERIFY_RESCHANGE); <br>     <br>    if (IDYES == nUserResponse) <br>    { <br>     <br>// <br>// Keep resolution and update registry <br>// <br> <br>        char szTip[50]; <br> <br>// <br>// TODO: give them three choices: <br>        //       Dynamic only, Registry too, or Abort <br>// <br> <br>        lResult = ChangeDisplaySettings <br>                    ( gpCurrentMode, <br>                      CDS_UPDATEREGISTRY );  //  Flag to update registry <br>         <br>        switch (lResult) <br>         <br>        { <br>         <br>        case DISP_CHANGE_SUCCESSFUL:  <br>             <br>    // <br>    // The settings change was successful. <br>    // <br> <br>            TRC("DISP_CHANGE_SUCCESSFUL - reg\n"); <br>             <br>            wsprintf(szTip,"%d x %d, %d bit color at %d hz",  <br>                 gpCurrentMode-&gt;dmPelsWidth, <br>                 gpCurrentMode-&gt;dmPelsHeight, <br>                 gpCurrentMode-&gt;dmBitsPerPel, <br>                 gpCurrentMode-&gt;dmDisplayFrequency); <br> <br>             { <br> <br> // <br> // Update the Menu informtion, just a check mark for now <br> // <br> <br>                 HMENU hMenu, hMenu2; <br>                  <br>                 hMenu = GetMenu(hwnd); <br>                  <br>                 hMenu2 = GetSubMenu (hMenu, 0); <br> <br> // <br> // Uncheck the old <br> // <br> <br>                 CheckMenuItem (hMenu2, nOldMode, MF_BYPOSITION | MF_UNCHECKED); <br>                  <br> // <br> // Check the new <br> // <br> <br> CheckMenuItem (hMenu2, gnCurrentMode, MF_BYPOSITION | MF_CHECKED); <br>              <br>             } <br> <br>     // <br>     // Update the Notify_Icon quick tip <br>     // <br> <br>             TrayMessage(hwnd, NIM_MODIFY, g_sDlgItems[0].uNotify, <br>                    LoadImage(g_hinst, MAKEINTRESOURCE(IDI_SETDISP), <br>                    IMAGE_ICON, 16, 16, 0), szTip); <br> <br>             break; <br> <br>        case DISP_CHANGE_RESTART:  //The computer must be restarted in order  <br>                                      //  for the graphics mode to work. <br>             TRC("DISP_CHANGE_RESTART - reg\n"); <br>             break; <br> <br>        case DISP_CHANGE_BADFLAGS:  //An invalid set of flags was passed in. <br>             TRC("DISP_CHANGE_BADFLAGS - reg\n"); <br>             break; <br> <br>        case DISP_CHANGE_FAILED:  //The display driver failed the specified  <br>                                      //  graphics mode. <br>             TRC("DISP_CHANGE_FAILED - reg\n"); <br>             break; <br> <br>        case DISP_CHANGE_BADMODE:  //The graphics mode is not supported. <br>             TRC("DISP_CHANGE_BADMODE - reg\n"); <br>             break; <br> <br>        case DISP_CHANGE_NOTUPDATED:  //Windows NT only: Unable to write settings  <br>                                      //  to the registry.                         <br>             TRC("DISP_CHANGE_NOTUPDATED - reg\n"); <br>             break; <br>        default: <br>              TRC("Undocumented return value!!!! - reg\n"); <br>              break; <br>        } <br>     <br>    } <br>     <br>    else <br>     <br>    { <br>// <br>// The user chose to not keep the setting orwe timed out <br>        // so they may not have seen the dialog box to choose <br>        // <br>        // Change resolution back by calling <br>        // ChangeDisplaySettings  <br>        // with a NULL DEVMODE which returns us to the current <br>        // registry settings <br>// <br> <br>        lResult = ChangeDisplaySettings <br>                    ( NULL,  <br>                      0 );  // 0 to change dynamically <br>         <br>        gnCurrentMode = nOldMode; <br>         <br>        gpCurrentMode = gpDevModes; <br>        gpCurrentMode += gnCurrentMode; <br>     <br>    } <br> <br>    return (TRUE); <br> <br>} <br> <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : SetResolutionMenu (hwnd)                               <br> *                                                                           <br> *  PURPOSE    : Create a context menu with all of the resolutions <br> *               that are in the devmodes we obtained from the drive <br> *                                                                           <br> \****************************************************************************/ <br>BOOL SetResolutionMenu (  <br>    HWND hwnd) <br>{ <br>   <br>    HMENU hMenu, hWndMenu; //hMenuTrackPopup; <br>    INT i; <br>    BOOL bRet; <br>    PDEVMODE pDevMode; <br>     <br>    // <br>    // Create new Resolutions menu from the DevModes collected <br>    // <br> <br>    hMenu = CreateMenu();  <br>     <br>    if (!hMenu) <br>    { <br>       return (FALSE); <br>    } <br> <br>    // <br>    // For each devmode add an menu item <br>    // TODO: make the description on BitPerPel better <br>    // <br> <br>    for(i=0; i&lt;= gnModes; i++) <br>    { <br>     <br>        char szRes[50]; <br> <br>     <br>        if (i == 0) <br>        { <br>            pDevMode = gpDevModes; <br>        } <br>        else <br>        { <br>            pDevMode += 1; <br>} <br> <br>        // <br>// Set the menu text <br>// <br> <br>        if (pDevMode-&gt;dmDisplayFrequency == 0 || <br>            pDevMode-&gt;dmDisplayFrequency == 1) <br>{ <br>    wsprintf(szRes,"%d x %d, %d bit color, default frequency", <br>                 pDevMode-&gt;dmPelsWidth, <br>                 pDevMode-&gt;dmPelsHeight, <br>                 pDevMode-&gt;dmBitsPerPel); <br>} <br>else <br>{ <br>    wsprintf(szRes,"%d x %d, %d bit color at %d hz", <br>                 pDevMode-&gt;dmPelsWidth, <br>                 pDevMode-&gt;dmPelsHeight, <br>                 pDevMode-&gt;dmBitsPerPel, <br>                 pDevMode-&gt;dmDisplayFrequency); <br>} <br>         <br>        bRet = AppendMenu (hMenu, MF_STRING, MYWM_NOTIFYICON + 10 + i, szRes); <br>         <br>        SetMenuItemBitmaps( <br>  hMenu, // handle of menu <br>  gnCurrentMode, // menu item to receive new bitmaps <br>                  MF_BYPOSITION, // menu item flags <br>                  NULL,         // handle of unchecked bitmap <br>  NULL); // handle of checked bitmap <br>                                 // if last two are NULL the default  <br>                                 // bitmap is used <br> <br>     <br>    } // for loop to set menu <br>     <br>    if (!bRet) <br>    { <br>    <br>        // <br>        // if the last one worked they all likely worked <br>        // otherwise let's clean up <br>        // <br> <br>        DestroyMenu(hMenu); <br>         <br>        return(FALSE); <br>     <br>    } <br>    else <br>    { <br> <br>        if (IsNT()) <br>        { <br>            // <br>            // Check the Current one <br>            // <br> <br>            CheckMenuItem (hMenu, gnCurrentMode, MF_BYPOSITION | MF_CHECKED); <br>     <br>            // <br>            // Set it as the default so it is easy to go back to <br>            // <br> <br>    SetMenuDefaultItem(hMenu, gnCurrentMode, TRUE ); //TRUE if for by Position <br> <br>        } <br> <br>        hWndMenu = GetMenu (hwnd); <br>         <br>        InsertMenu (hWndMenu, 0, MF_POPUP|MF_BYPOSITION, (DWORD)hMenu, "&amp;Resolutions"); <br>         <br>        return(TRUE); <br>     <br>    } <br>     <br>} <br> <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : TrayMessage (HWND hDlg, DWORD dwMessage, UINT uID,  <br> *                            HICON hIcon, PSTR pszTip ) <br> *                                                                           <br> *  PURPOSE    : Creates, Modifies or deletes the tray icon  <br> *               If pszTip is not null, it uses that for the tip <br> *               otherwise it sets a default tip <br> *                                                                           <br> \****************************************************************************/ <br> <br>BOOL TrayMessage ( <br>                   <br>  HWND hDlg,  <br>  DWORD dwMessage,  <br>  UINT uID,  <br>  HICON hIcon,  <br>  PSTR pszTip ) <br> <br>{ <br>    BOOL res; <br>    NOTIFYICONDATA tnd; <br> <br>    // <br>    // Get the Tray Icon <br>    // <br> <br>    hIcon = (HICON)LoadImage(g_hinst, MAKEINTRESOURCE(IDI_SETDISP), IMAGE_ICON, <br>     16, 16, 0); <br>     <br>    tnd.cbSize= sizeof(NOTIFYICONDATA); <br>    tnd.hWnd= hDlg; <br>    tnd.uID= uID; <br>    tnd.uFlags= NIF_MESSAGE|NIF_ICON|NIF_TIP; <br>    tnd.uCallbackMessage= MYWM_NOTIFYICON; </code></pre>
<p>
</p>
<pre><code>tnd.hIcon= hIcon; <br> <br>    // <br>    // If there is a specific tip, set it <br>    // otherwise use SetDisp as the default <br>    // <br> <br>    if (pszTip) <br>    { <br>lstrcpyn(tnd.szTip, pszTip, sizeof(tnd.szTip)); <br>    } <br>    else <br>    { <br>lstrcpyn(tnd.szTip, "SetDisp", sizeof("SetDisp"));; <br>    } <br> <br> <br>    // <br>    //Use the Shell_NotifyIcon API to setup the tray icon <br>    // <br> <br>    res = Shell_NotifyIcon(dwMessage, &amp;tnd); <br> <br>    if (hIcon) <br>    { <br> DestroyIcon(hIcon); <br>    } <br> <br> <br>    return res; <br> <br>} <br> <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : NotifyDelete (HWND hDlg, UINT uIndex) <br> *                                                                           <br> *  PURPOSE    : Deletes a tray icon based on the uIndex . <br> *               In this SetDisp sample, it is only used for a single icon <br> *                                                                           <br> \****************************************************************************/ <br> <br>void NotifyDelete ( <br>                    <br>  HWND hDlg,  <br>  UINT uIndex ) <br> <br>{ <br> <br>    TrayMessage(hDlg, NIM_DELETE, g_sDlgItems[uIndex].uNotify, NULL, NULL); <br> <br>} <br> <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : NotifyAdd (HWND hDlg, UINT uIndex) <br> *                                                                           <br> *  PURPOSE    : Creates tray icons based on the uIndex . <br> *               In this SetDisp sample, it is only used for a single icon <br> *                                                                           <br> \****************************************************************************/ <br> <br>void NotifyAdd ( <br>                <br>  HWND hDlg,  <br>  UINT uIndex ) <br> <br>{ <br> <br>    TrayMessage(hDlg, NIM_ADD, g_sDlgItems[uIndex].uNotify, NULL, NULL); <br> <br>} <br> <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : VerifyTimerProc (HWND hwnd, UINT uMsg,  <br> *                                UINT idEvent, DWORD dwTime ) <br> *                                                                           <br> *  PURPOSE    : Simply sends an IDNO to the Verify Dialog <br> *               This is setup to give the user a limited amount of time <br> *               to approve <br> *                                                                           <br> \****************************************************************************/ <br> <br>VOID CALLBACK VerifyTimerProc ( <br>                                <br>  HWND hwnd,  <br>  UINT uMsg,  <br>  UINT idEvent, <br>  DWORD dwTime ) <br>{ <br> <br>    SendMessage(ghVerifyDlg, WM_COMMAND, IDNO, 0); <br> <br>} <br> <br> /**************************************************************************** <br> *                                                                           <br> *  FUNCTION   : VerifyTimerProc (HWND hDlg, UINT uMsg, <br> *                                WPARAM wParam, LPARAM lParam) <br> * <br> *                                                                           <br> *  PURPOSE    : Ask the user if they want to keep the new resolution <br> *                                                                           <br> \****************************************************************************/ <br> <br>BOOL CALLBACK VerifyDlgProc( <br>    HWND hDlg, <br>    UINT uMsg, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch(uMsg) <br>    { <br>case WM_INITDIALOG:ghVerifyDlg = hDlg; <br>return(TRUE); <br>     <br>case WM_COMMAND: <br>     <br>     // <br>     // LOWORD added for portability <br>     // <br>         <br>     switch (LOWORD(wParam)) <br>     { <br>         <br> case IDNO: <br> case IDCANCEL:ghVerifyDlg = NULL; <br>EndDialog(hDlg, IDNO); <br>return 0; <br>         <br> <br> case IDYES:ghVerifyDlg = NULL; <br>EndDialog(hDlg, IDYES); <br>return 0; <br>      } <br>        <br>default: <br>     break; <br>    <br>    } <br>    <br>    return(FALSE); <br> <br>    UNREFERENCED_PARAMETER(lParam); <br> <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : HandlePopupMenu (hwnd, point)                              * <br> *                                                                          * <br> *  PURPOSE    : Handles the display of the "floating" popup that appears   * <br> *               on a mouse click in the app's client area.                 * <br> *                                                                          * <br> ****************************************************************************/ <br> <br>VOID APIENTRY HandlePopupMenu ( <br>    HWND  hwnd, <br>    POINT point) <br>{ <br>     <br>    HMENU hMenu; <br>    HMENU hMenuTrackPopup; <br> <br>    // <br>    // Get the menu for the windows <br>    // <br> <br>    hMenu = GetMenu(hwnd); <br> <br>    if (!hMenu) <br>    { <br>return; <br>    } <br> <br>    // <br>    // Get the first menu in it which we will use for the call to <br>    // TrackPopup(). This could also have been created on the fly using <br>    // CreatePopupMenu and then we could have used InsertMenu() or <br>    // AppendMenu. <br>    // <br>     <br>    hMenuTrackPopup = GetSubMenu (hMenu, 0); <br> <br>    // <br>    // Draw and track the "floating" popup <br>    // <br> <br>    if (point.x &lt; (long) (gpCurrentMode-&gt;dmPelsWidth - 50)) <br>        point.x = (long) (gpCurrentMode-&gt;dmPelsWidth - 50); <br> <br>    if (point.y &lt; (long) (gpCurrentMode-&gt;dmPelsHeight - 50)) <br>        point.y = (long) (gpCurrentMode-&gt;dmPelsHeight - 50); <br>     <br>     <br>    // <br>    // This is required when using a notify icon -- see KB article <br>    // PRB: Menus for Notification Icons Don't Work Correctly <br>    // <br> <br>    SetForegroundWindow (hwnd); <br>     <br>    TrackPopupMenu (hMenuTrackPopup, TPM_LEFTBUTTON | TPM_RIGHTBUTTON, <br>                    point.x, point.y, 0, hwnd, NULL); <br> <br>    // <br>    // This is required when using a notify icon -- see KB article <br>    // PRB: Menus for Notification Icons Don't Work Correctly <br>    // <br> <br>    PostMessage (hwnd, WM_USER, 0, 0); <br> <br>} <br> <br> <br>/****************************************************************************\ <br>*                                                                           <br>*  FUNCTION   : CompareDevModes (DEVMODE *leftDM, DEVMODE *rightDM)                               <br>*                                                                           <br>*  PURPOSE    : Handles the display of the "floating" popup that appears    <br>*               on a mouse click in the app's client area.                  <br>*                                                                           <br>\****************************************************************************/ <br>int CompareDevModes ( <br> <br>    DEVMODE *leftDM, <br>    DEVMODE *rightDM) <br>{ <br> <br>    // <br>    // Return 1  if left is bigger <br>    //        0  if equal <br>    //        -1 if right is bigger <br>    // <br>    // Comparison order is Width then Height then Bits then Frequency <br>    // This is an arbitrary order of importance. Often BitPerPels is <br>    // on considered the most important measure of a display setting <br>    // <br>    // return on the first one that is larger between left and right <br>    // <br> <br>    if (leftDM-&gt;dmPelsWidth  &gt; rightDM-&gt;dmPelsWidth) <br>    { <br>        return 1; <br>    } <br>    else if (leftDM-&gt;dmPelsWidth  &lt; rightDM-&gt;dmPelsWidth) <br>    { <br>        return -1; <br>    } <br> <br> <br>    if (leftDM-&gt;dmPelsHeight &gt; rightDM-&gt;dmPelsHeight) <br>    { <br>        return 1; <br>    } <br>    else if (leftDM-&gt;dmPelsHeight &lt; rightDM-&gt;dmPelsHeight) <br>    { <br>        return -1; <br>    } <br> <br> <br>    if (leftDM-&gt;dmBitsPerPel &gt; rightDM-&gt;dmBitsPerPel) <br>    { <br>        return 1; <br>    } <br>    else if (leftDM-&gt;dmBitsPerPel &lt; rightDM-&gt;dmBitsPerPel) <br>    { <br>        return -1; <br>    } <br>     <br> <br>    if (leftDM-&gt;dmDisplayFrequency &gt; rightDM-&gt;dmDisplayFrequency) <br>    { <br>        return 1; <br>    } <br>    else if (leftDM-&gt;dmDisplayFrequency &lt; rightDM-&gt;dmDisplayFrequency) <br>    { <br>        return -1; <br>    } <br> <br>    // <br>    // All are equal <br>    // <br> <br>    return 0; <br> <br>} <br> <br>/****************************************************************************\ <br>*                                                                           <br>*  FUNCTION: About(HWND, UINT, UINT, LONG) <br>* <br>*  PURPOSE:  Processes messages for the "About" dialog box  <br>* <br>\****************************************************************************/ <br>BOOL APIENTRY About( <br>    HWND hDlg, <br>    UINT message, <br>    UINT wParam, <br>    LONG lParam) <br>{ <br>switch (message) <br>{ <br>   case WM_INITDIALOG: <br>  return TRUE; <br> <br>   case WM_COMMAND:               <br> if (LOWORD(wParam) == IDOK) <br> { <br>  EndDialog(hDlg, TRUE); <br>  return TRUE; <br> } <br> <br> break; <br> <br>   default: <br> <br>return FALSE; <br> <br>} <br> <br>} <br> <br>BOOL IsNT() <br>{ <br>    OSVERSIONINFO          osvi; <br>     <br>    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO); <br>     <br>    GetVersionEx(&amp;osvi); <br> <br>    if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)  <br>    { <br>        return TRUE; <br>    } <br>    else <br>    { <br>        return FALSE; <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
