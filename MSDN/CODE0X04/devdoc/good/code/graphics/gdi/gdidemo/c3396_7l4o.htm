<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BOUNCE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3408"></a>BOUNCE.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCING BALL MODULE <br>\*---------------------------------------------------------------------------*/ <br> <br>#include &lt;windows.h&gt; <br>#include "gdidemo.h" <br>#include "bounce.h" <br> <br> <br>VOID XFormClear(PMYXFORM); <br>VOID XFormScale(PMYXFORM,int,int); <br>VOID XFormTrans(PMYXFORM,int,int); <br>VOID XFormPoint(PMYXFORM,LPPOINT); <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| CREATE BOUNCE WINDOW PROCEDURE <br>| <br>\*---------------------------------------------------------------------------*/ <br>HWND FAR CreateBounceWindow(HWND hWndClient, int nItem) <br>{ <br>    HANDLE          hInstance; <br>    MDICREATESTRUCT mcs; <br>    static char buffer[256]; <br> <br> <br>    hInstance = GETINSTANCE(hWndClient); <br>    LoadString (hInstance, BOUNCETITLE, buffer, 256); <br> <br>    /* <br>    ** Initialize the MDI create struct for creation of the <br>    ** test window. <br>    */ <br>    mcs.szClass = BOUNCECLASS; <br>    mcs.szTitle = buffer; <br>    mcs.hOwner  = hInstance; <br>    mcs.x       = CW_USEDEFAULT; <br>    mcs.y       = CW_USEDEFAULT; <br>    mcs.cx      = CW_USEDEFAULT; <br>    mcs.cy      = CW_USEDEFAULT; <br>    mcs.style   = 0l; <br>    mcs.lParam  = (LONG)nItem; <br> <br>    return((HWND)SendMessage(hWndClient,WM_MDICREATE,0,(LONG)(LPMDICREATESTRUCT)&amp;mcs)); <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCE WINDOW PROCEDURE <br>| <br>\*---------------------------------------------------------------------------*/ <br>LONG APIENTRY BounceProc(HWND hWnd, UINT wMsg, WPARAM wParam, LONG lParam) <br>{ <br>    switch(wMsg) <br>    { <br>        case WM_CREATE: <br>            BounceCreateProc(hWnd); <br>            break; <br> <br>        case WM_MOVE: <br>            BounceRefresh(hWnd); <br>            break; <br> <br>        case WM_COMMAND: <br>            BounceCommandProc(hWnd,wParam,lParam); <br>            break; <br> <br>        case WM_TIMER: <br>            BounceObjects(hWnd); <br>            break; <br> <br>        case WM_PAINT: <br>            BouncePaintProc(hWnd); <br>            break; <br> <br>        case WM_DESTROY: <br>            BounceDestroyProc(hWnd); <br>            break; <br> <br> <br>        default: <br>            return(DefMDIChildProc(hWnd,wMsg,wParam,lParam)); <br>    } <br>    return(0l); <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCE CREATE PROCEDURE <br>| <br>\*---------------------------------------------------------------------------*/ <br>BOOL BounceCreateProc(HWND hWnd) <br>{ <br>    PBOUNCEDATA pbd; <br> <br> <br>    if(AllocWindowInfo(hWnd,sizeof(BOUNCEDATA))) <br>    { <br>        if(pbd = (PBOUNCEDATA)LockWindowInfo(hWnd)) <br>        { <br>            pbd-&gt;hBall1 = ballCreate(hWnd,20,20,RGB(255,0,0)); <br>            pbd-&gt;hBall2 = ballCreate(hWnd,20,20,RGB(0,0,255)); <br>            pbd-&gt;hBall3 = ballCreate(hWnd,20,20,RGB(0,255,0)); <br>            pbd-&gt;hBall4 = ballCreate(hWnd,20,20,RGB(255,0,255)); <br> <br>            UnlockWindowInfo(hWnd); <br> <br>            SetTimer(hWnd,1,50,NULL); <br>            return(TRUE); <br>        } <br>        FreeWindowInfo(hWnd); <br>    } <br>    return(FALSE); <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCE COMMAND PROCEDURE <br>| <br>\*---------------------------------------------------------------------------*/ <br>BOOL BounceCommandProc(HWND hWnd, WPARAM wParam, LONG lParam) <br>{ <br>    hWnd   = hWnd; <br>    wParam = wParam; <br>    lParam = lParam; <br> <br>    return(TRUE); <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCE PAINT PROCEDURE <br>| <br>\*---------------------------------------------------------------------------*/ <br>VOID BouncePaintProc(HWND hWnd) <br>{ <br>    HDC         hDC; <br>    PAINTSTRUCT ps; <br> <br> <br>    if(hDC = BeginPaint(hWnd,&amp;ps)) <br>        EndPaint(hWnd,&amp;ps); <br> <br>    BounceRefresh(hWnd); <br> <br>    return; <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCE DESTROY PROCEDURE <br>| <br>\*---------------------------------------------------------------------------*/ <br>VOID BounceDestroyProc(HWND hWnd) <br>{ <br>    PBOUNCEDATA pbd; <br> <br> <br>    KillTimer(hWnd,1); <br>    if(pbd = (PBOUNCEDATA)LockWindowInfo(hWnd)) <br>    { <br>        ballDestroy(pbd-&gt;hBall1); <br>        ballDestroy(pbd-&gt;hBall2); <br>        ballDestroy(pbd-&gt;hBall3); <br>        ballDestroy(pbd-&gt;hBall4); <br> <br>        UnlockWindowInfo(hWnd); <br>    } <br>    FreeWindowInfo(hWnd); <br>    return; <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| BOUNCE REFRESH <br>| <br>\*---------------------------------------------------------------------------*/ <br>VOID BounceRefresh(HWND hWnd) <br>{ <br>    PBOUNCEDATA pbd; <br>    RECT        rect; <br>    HDC         hDC; <br>    POINT       pDimensions; <br>    int         xDirection,yDirection; <br> <br> <br>    if(pbd = (PBOUNCEDATA)LockWindowInfo(hWnd)) <br>    { <br>        if(hDC = GetDC(hWnd)) <br>        { <br>            GetClientRect(hWnd,&amp;rect); <br>            FillRect(hDC,&amp;rect,GETCLASSBRUSH(hWnd)); <br> <br>            xDirection = ((lRandom() % 5)+5); <br>            yDirection = ((lRandom() % 5)+5); <br>            ballSetPosition(pbd-&gt;hBall1,0,0); <br>            ballSetDirection(pbd-&gt;hBall1,xDirection,yDirection); <br> <br> <br>            ballGetDimensions(pbd-&gt;hBall2,&amp;pDimensions); <br>            ballSetPosition(pbd-&gt;hBall2,rect.right-pDimensions.x,0); <br>            xDirection = -(((int)lRandom() % 5)+5); <br>            yDirection =  ((lRandom() % 5)+5); <br>            ballSetDirection(pbd-&gt;hBall2,xDirection,yDirection); <br> <br> <br>            ballGetDimensions(pbd-&gt;hBall3,&amp;pDimensions); <br>            ballSetPosition(pbd-&gt;hBall3,0,rect.bottom-pDimensions.y); <br>            xDirection =  ((lRandom() % 5)+5); <br>            yDirection = -((int)(lRandom() % 5)+5); <br>            ballSetDirection(pbd-&gt;hBall3,xDirection,yDirection); <br> <br> <br>            ballGetDimensions(pbd-&gt;hBall4,&amp;pDimensions); <br>            ballSetPosition(pbd-&gt;hBall4,rect.right-pDimensions.x,rect.bottom-pDimensions.y); <br>            xDirection = -((int)(lRandom() % 5)+5); <br>            yDirection = -((int)(lRandom() % 5)+5); <br>            ballSetDirection(pbd-&gt;hBall4,xDirection,yDirection); <br> <br> <br>            ballBounce(pbd-&gt;hBall1); <br>            ballBounce(pbd-&gt;hBall2); <br>            ballBounce(pbd-&gt;hBall3); <br>            ballBounce(pbd-&gt;hBall4); <br> <br>            ReleaseDC(hWnd,hDC); <br>        } <br>        UnlockWindowInfo(hWnd); <br>    } <br>    return; <br>} <br> <br> <br> <br>VOID BounceObjects(HWND hWnd) <br>{ <br>    PBOUNCEDATA pbd; <br> <br> <br>    if(pbd = (PBOUNCEDATA)LockWindowInfo(hWnd)) <br>    { <br>        /* <br>        ** Determine if the balls hit any of the edges of the display.  If <br>        ** they do, then these functions reset their position to something <br>        ** more desireable and re-do their direction. <br>        */ <br>        CheckEdgePosition(hWnd,pbd-&gt;hBall1); <br>        CheckEdgePosition(hWnd,pbd-&gt;hBall2); <br>        CheckEdgePosition(hWnd,pbd-&gt;hBall3); <br>        CheckEdgePosition(hWnd,pbd-&gt;hBall4); <br> <br>        ballBounce(pbd-&gt;hBall1); <br>        ballBounce(pbd-&gt;hBall2); <br>        ballBounce(pbd-&gt;hBall3); <br>        ballBounce(pbd-&gt;hBall4); <br> <br> <br>        UnlockWindowInfo(hWnd); <br>    } <br>    return; <br>} <br> <br> <br>VOID CheckEdgePosition(HWND hWnd, HANDLE hBall) <br>{ <br>    POINT pPos,pDir,pDim; <br>    int   xNewPos,yNewPos,xNewDir,yNewDir; <br>    RECT  rect; <br> <br> <br> <br>    ballGetPosition(hBall,&amp;pPos); <br>    ballGetDirection(hBall,&amp;pDir); <br>    ballGetDimensions(hBall,&amp;pDim); <br> <br>    GetClientRect(hWnd,&amp;rect); <br> <br> <br>    /* <br>    ** Check each edge of the client rectagle.  If the ball goes past the <br>    ** boundries, reset the position and give it a new direction. <br>    */ <br>    xNewDir = pDir.x; <br>    yNewDir = pDir.y; <br>    xNewPos = pPos.x+pDir.x; <br>    yNewPos = pPos.y+pDir.y; <br> <br>    if(xNewPos &lt; rect.left) <br>    { <br>        xNewDir = ((lRandom() % 5)+5); <br>        ballSetPosition(hBall,rect.left,pPos.y); <br>    } <br>    if((xNewPos+pDim.x) &gt; rect.right) <br>    { <br>        xNewDir = -(((int)lRandom() % 5)+5); <br>        ballSetPosition(hBall,rect.right-pDim.x,pPos.y); <br>    } <br>    if(yNewPos &lt; rect.top) <br>    { <br>        yNewDir = ((lRandom() % 5)+5); <br>        ballSetPosition(hBall,pPos.x,rect.top); <br>    } <br>    if((yNewPos+pDim.y) &gt; rect.bottom) <br>    { <br>        yNewDir = -(((int)lRandom() % 5)+5); <br>        ballSetPosition(hBall,pPos.x,rect.bottom-pDim.y); <br>    } <br>    ballSetDirection(hBall,xNewDir,yNewDir); <br> <br>    return; <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| CLEAR XFORM <br>| <br>\*---------------------------------------------------------------------------*/ <br>VOID XFormClear(PMYXFORM pXForm) <br>{ <br>    int Row,Col; <br> <br> <br>    for(Row=0; Row &lt; 3; Row++) <br>        for(Col=0; Col &lt; 3; Col++) <br>            if(Row == Col) <br>                pXForm-&gt;xForm[Row][Col] = 1; <br>            else <br>                pXForm-&gt;xForm[Row][Col] = 0; <br>    return; <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| XFORM SCALE <br>| <br>\*---------------------------------------------------------------------------*/ <br>VOID XFormScale(PMYXFORM pXForm, int xScale, int yScale) <br>{ <br>    int idx; <br> <br> <br>    for(idx=0; idx &lt; 3; idx++) <br>    { <br>        pXForm-&gt;xForm[idx][0] = pXForm-&gt;xForm[idx][0] * xScale; <br>        pXForm-&gt;xForm[idx][1] = pXForm-&gt;xForm[idx][1] * yScale; <br>    } <br>    return; <br>} <br> <br> <br> <br>VOID XFormTrans(PMYXFORM pXForm, int xTrans, int yTrans) <br>{ <br>    pXForm-&gt;xForm[2][0] = pXForm-&gt;xForm[2][0] + xTrans; <br>    pXForm-&gt;xForm[2][1] = pXForm-&gt;xForm[2][1] + yTrans; <br> <br>    return; <br>} <br> <br> <br> <br>VOID XFormPoint(PMYXFORM pXForm, LPPOINT pPoint) <br>{ <br>    int x,y; <br> <br> <br>    x = (pXForm-&gt;xForm[0][0] * pPoint-&gt;x) + (pXForm-&gt;xForm[1][0] * pPoint-&gt;y) + pXForm-&gt;xForm[2][0]; <br>    y = (pXForm-&gt;xForm[0][1] * pPoint-&gt;x) + (pXForm-&gt;xForm[1][1] * pPoint-&gt;y) + pXForm-&gt;xForm[2][1]; <br> <br>    pPoint-&gt;x = x; <br>    pPoint-&gt;y = y; <br> <br>    return; <br>} <br> <br> <br>/* <br>** ------------------------------- <br>** ------------------------------- <br>** ------------------------------- <br>*/ <br> <br>HANDLE ballCreate(HWND hWnd, int nWidth, int nHeight, COLORREF crColor) <br>{ <br>    HANDLE    hBall; <br>    PBALLDATA pbd; <br> <br>    if(hBall = LocalAlloc(LHND,sizeof(BALLDATA))) <br>    { <br>        if(pbd = (PBALLDATA)LocalLock(hBall)) <br>        { <br>            pbd-&gt;hWnd         = hWnd; <br>            pbd-&gt;nWidth       = nWidth; <br>            pbd-&gt;nHeight      = nHeight; <br>            pbd-&gt;xDirection   = 0; <br>            pbd-&gt;yDirection   = 0; <br>            pbd-&gt;bNewPosition = FALSE; <br>            pbd-&gt;xPosition    = 0; <br>            pbd-&gt;yPosition    = 0; <br>            pbd-&gt;crColor      = crColor; <br>            XFormClear(&amp;pbd-&gt;xForm); <br> <br>            LocalUnlock(hBall); <br>            return(hBall); <br>        } <br>        LocalFree(hBall); <br>    } <br>    return(NULL); <br>} <br> <br> <br>BOOL ballDestroy(HANDLE hBall) <br>{ <br>    if(LocalFree(hBall)) <br>        return(FALSE); <br>    return(TRUE); <br>} <br> <br> <br>VOID ballBounce(HANDLE hBall) <br>{ <br>    PBALLDATA pbd; <br>    HDC       hDC; <br>    HBRUSH    hBrush; <br>    POINT     pOrg,pExt; <br>    HRGN      hTmp,hOld,hNew; <br> <br> <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        /* <br>        ** Create old ball object. <br>        */ <br>        pOrg.x = 0; <br>        pOrg.y = 0; <br>        pExt.x = pbd-&gt;nWidth; <br>        pExt.y = pbd-&gt;nHeight; <br>        XFormPoint(&amp;pbd-&gt;xForm,&amp;pOrg); <br>        XFormPoint(&amp;pbd-&gt;xForm,&amp;pExt); <br>        hOld = CreateEllipticRgn(pOrg.x,pOrg.y,pExt.x,pExt.y); <br> <br> <br>        /* <br>        ** Create new ball object. <br>        */ <br>        if(pbd-&gt;bNewPosition) <br>        { <br>            pbd-&gt;bNewPosition = FALSE; <br>            XFormClear(&amp;pbd-&gt;xForm); <br>            XFormTrans(&amp;pbd-&gt;xForm,pbd-&gt;xPosition,pbd-&gt;yPosition); <br>        } <br>        else <br>            XFormTrans(&amp;pbd-&gt;xForm,pbd-&gt;xDirection,pbd-&gt;yDirection); <br>        pOrg.x = 0; <br>        pOrg.y = 0; <br>        pExt.x = pbd-&gt;nWidth; <br>        pExt.y = pbd-&gt;nHeight; <br>        XFormPoint(&amp;pbd-&gt;xForm,&amp;pOrg); <br>        XFormPoint(&amp;pbd-&gt;xForm,&amp;pExt); <br>        hNew = CreateEllipticRgn(pOrg.x,pOrg.y,pExt.x,pExt.y); <br> <br> <br> <br>        if(hDC = GetDC(pbd-&gt;hWnd)) <br>        { <br>            hTmp = CreateRectRgn(1,1,2,2); <br>            CombineRgn(hTmp,hOld,hNew,RGN_DIFF); <br>            FillRgn(hDC,hTmp,GETCLASSBRUSH(pbd-&gt;hWnd)); <br> <br>            hBrush = CreateSolidBrush(pbd-&gt;crColor); <br>            FillRgn(hDC,hNew,hBrush); <br>            DeleteObject(hBrush); <br> <br>            ReleaseDC(pbd-&gt;hWnd,hDC); <br> <br>            DeleteObject(hTmp); <br>        } <br> <br>        DeleteObject(hOld); <br>        DeleteObject(hNew); <br> <br>        LocalUnlock(hBall); <br>    } <br>    return; <br>} <br> <br> <br>BOOL ballGetDimensions(HANDLE hBall, LPPOINT pDimension) <br>{ <br>    PBALLDATA pbd; <br>    BOOL      bOK; <br> <br> <br>    bOK = FALSE; <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        pDimension-&gt;x = pbd-&gt;nWidth; <br>        pDimension-&gt;y = pbd-&gt;nHeight; <br> <br>        bOK = TRUE; <br>        LocalUnlock(hBall); <br>    } <br>    return(bOK); <br>} <br> <br> <br>BOOL ballSetDimensions(HANDLE hBall, int nWidth, int nHeight) <br>{ <br>    PBALLDATA pbd; <br>    BOOL      bOK; <br> <br> <br>    bOK = FALSE; <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        pbd-&gt;nWidth  = nWidth; <br>        pbd-&gt;nHeight = nHeight; <br> <br>        bOK = TRUE; <br>        LocalUnlock(hBall); <br>    } <br>    return(bOK); <br>} <br> <br> <br>BOOL ballGetDirection(HANDLE hBall, LPPOINT pDirection) <br>{ <br>    PBALLDATA pbd; <br>    BOOL      bOK; <br> <br> <br>    bOK = FALSE; <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        pDirection-&gt;x = pbd-&gt;xDirection; <br>        pDirection-&gt;y = pbd-&gt;yDirection; <br> <br>        bOK = TRUE; <br>        LocalUnlock(hBall); <br>    } <br>    return(bOK); <br>} <br> <br> <br>BOOL ballSetDirection(HANDLE hBall, int xDirection, int yDirection) <br>{ <br>    PBALLDATA pbd; <br>    BOOL      bOK; <br> <br> <br>    bOK = FALSE; <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        pbd-&gt;xDirection = xDirection; <br>        pbd-&gt;yDirection = yDirection; <br> <br>        bOK = TRUE; <br>        LocalUnlock(hBall); <br>    } <br>    return(bOK); <br>} <br> <br> <br>BOOL ballGetPosition(HANDLE hBall, LPPOINT pPosition) <br>{ <br>    PBALLDATA pbd; <br>    BOOL      bOK; <br>    POINT     pOrg; <br> <br> <br>    bOK = FALSE; <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        pOrg.x = 0; <br>        pOrg.y = 0; <br>        XFormPoint(&amp;pbd-&gt;xForm,&amp;pOrg); <br> <br>        pPosition-&gt;x = pOrg.x; <br>        pPosition-&gt;y = pOrg.y; <br> <br>        bOK = TRUE; <br>        LocalUnlock(hBall); <br>    } <br>    return(bOK); <br>} <br> <br> <br>BOOL ballSetPosition(HANDLE hBall, int x, int y) <br>{ <br>    PBALLDATA pbd; <br>    BOOL      bOK; <br> <br> <br>    bOK = FALSE; <br>    if(pbd = (PBALLDATA)LocalLock(hBall)) <br>    { <br>        pbd-&gt;bNewPosition = TRUE; <br>        pbd-&gt;xPosition    = x; <br>        pbd-&gt;yPosition    = y; <br> <br>        bOK = TRUE; <br>        LocalUnlock(hBall); <br>    } <br>    return(bOK); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
