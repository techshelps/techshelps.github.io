<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOG.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3398"></a>DIALOG.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/*---------------------------------------------------------------------------*\ <br>| DIALOG MODULE <br>|   This module contains the dialogbox routines for this application. <br>\*---------------------------------------------------------------------------*/ <br> <br>#include &lt;windows.h&gt; <br>#include "gdidemo.h" <br> <br>/*---------------------------------------------------------------------------*\ <br>| DISPLAY DIALOG BOX <br>|   This is a routine to display a generic modal-dialog box. <br>| <br>\*---------------------------------------------------------------------------*/ <br>int FAR DisplayDialogBox(HWND hWnd, LPSTR lpszTemplate, WNDPROC lpfFunction, LONG lExtra) <br>{ <br>    HANDLE  hInstance; <br>    WNDPROC lpfDlg; <br>    int     nRet; <br> <br> <br>    nRet = -1; <br>    if(hInstance = GETINSTANCE(hWnd)) <br>    { <br>        if(lpfDlg = MakeProcInstance(lpfFunction,hInstance)) <br>        { <br>            nRet = DialogBoxParam(hInstance,lpszTemplate,hWnd,(DLGPROC)lpfDlg,lExtra); <br>            FreeProcInstance(lpfDlg); <br>        } <br>    } <br>    return(nRet); <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| ABOUT DIALOG PROCEDURE <br>|   This is the main dialog box routine for the HELPABOUT template. <br>| <br>\*---------------------------------------------------------------------------*/ <br>BOOL APIENTRY AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LONG lParam) <br>{ <br>    lParam = lParam; <br> <br>    switch(wMsg) <br>    { <br>        /* <br>        ** Set the focus to the OK button. <br>        */ <br>        case WM_INITDIALOG: <br>            SetFocus(GetDlgItem(hDlg,IDOK)); <br>            break; <br> <br> <br>        /* <br>        ** Look for an ESC or RETURN event. <br>        */ <br>        case WM_COMMAND: <br>            switch(wParam) <br>            { <br>                case IDOK: <br>                case IDCANCEL: <br>                    EndDialog(hDlg,TRUE); <br>                    break; <br> <br>                default: <br>                    return(FALSE); <br>            } <br>            break; <br> <br> <br>        /* <br>        ** Wash the background of the aboutbox to give it a nice blue-scaling <br>        ** effect.  Invalidate the OK button to force it to the top.  This <br>        ** seems to be necessary since the OK button gets overwritten during <br>        ** the washing. <br>        */ <br>        case WM_PAINT: <br>            PaintWindow(hDlg,COLOR_SCALE_BLUE); <br>            InvalidateRect(GetDlgItem(hDlg,IDOK),NULL,TRUE); <br> <br> <br>        /* <br>        ** Default handler. <br>        */ <br>        default: <br>            return(FALSE); <br>    } <br>    return(TRUE); <br>} <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| PAINT WND BACKGROUND <br>|   This routine is used to wash the background of a window. <br>| <br>\*---------------------------------------------------------------------------*/ <br>VOID PaintWindow(HWND hWnd, int nColor) <br>{ <br>    HDC         hDC; <br>    int         nMapMode,idx,nSize,nReserved,nLoop; <br>    RECT        rect; <br>    HBRUSH      hBrush; <br>    PAINTSTRUCT ps; <br>    HPALETTE    hPal; <br> <br> <br>    if(hDC = BeginPaint(hWnd,&amp;ps)) <br>    { <br>        GetClientRect(hWnd,&amp;rect); <br>        nMapMode = SetMapMode(hDC,MM_ANISOTROPIC); <br> <br> <br>        if(GetDeviceCaps(hDC,RASTERCAPS) &amp; RC_PALETTE) <br>        { <br>            nReserved = GetDeviceCaps(hDC,NUMRESERVED); <br>            nSize     = GetDeviceCaps(hDC,SIZEPALETTE) - nReserved; <br> <br>            if(hPal = CreateColorScalePalette(hDC,nColor)) <br>            { <br>                hPal = SelectPalette(hDC,hPal,FALSE); <br>                RealizePalette(hDC); <br> <br> <br>#ifdef WIN16 <br>                SetWindowExtEx(hDC,nSize,nSize); <br>                SetViewportExtEx(hDC,rect.right,-rect.bottom); <br>                SetViewportOrgEx(hDC,0,rect.bottom); <br>#else <br> <br>                SetWindowExtEx(hDC,nSize,nSize,NULL); <br>                SetViewportExtEx(hDC,rect.right,-rect.bottom,NULL); <br>                SetViewportOrgEx(hDC,0,rect.bottom,NULL); <br> <br>#endif <br> <br>                nLoop = nSize &gt;&gt; 1; <br>                for(idx=0; idx &lt; nLoop; idx++) <br>                { <br>                    hBrush = CreateSolidBrush(PALETTEINDEX(idx+nLoop)); <br>                    SetRect(&amp;rect,idx,idx,nSize-idx,nSize-idx); <br>                    FillRect(hDC,&amp;rect,hBrush); <br>                    DeleteObject(hBrush); <br>                } <br>                DeleteObject(SelectPalette(hDC,hPal,FALSE)); <br>                RealizePalette(hDC); <br>            } <br>        } <br>        else <br>        { <br> <br>#ifdef WIN16 <br> <br>            SetWindowExtEx(hDC,512,512); <br>            SetViewportExtEx(hDC,rect.right,-rect.bottom); <br>            SetViewportOrgEx(hDC,0,rect.bottom); <br> <br>#else <br> <br>            SetWindowExtEx(hDC,512,512,NULL); <br>            SetViewportExtEx(hDC,rect.right,-rect.bottom,NULL); <br>            SetViewportOrgEx(hDC,0,rect.bottom,NULL); <br> <br>#endif <br> <br>            for(idx=0; idx &lt; 256; idx++) <br>            { <br>                hBrush = CreateSolidBrush(RGB(0,0,idx)); <br>                SetRect(&amp;rect,idx,idx,512-idx,512-idx); <br>                FillRect(hDC,&amp;rect,hBrush); <br>                DeleteObject(hBrush); <br>            } <br>        } <br> <br>        SetMapMode(hDC,nMapMode); <br> <br>        EndPaint(hWnd,&amp;ps); <br>    } <br>    return; <br>} <br> <br> <br> <br> <br> <br> <br>/*---------------------------------------------------------------------------*\ <br>| CREATE COLOR SCALE PALETTE <br>|   This routine creates a palette representing the scale values of a <br>|   particular RGB color.  A gray-scale palette can also be created. <br>| <br>\*---------------------------------------------------------------------------*/ <br>HPALETTE CreateColorScalePalette(HDC hDC, int nColor) <br>{ <br>    HPALETTE     hPalette; <br>    GLOBALHANDLE hMem; <br>    LPLOGPALETTE lpMem; <br>    int          idx,nReserved,nSize; <br> <br> <br>    hPalette = NULL; <br>    if(GetDeviceCaps(hDC,RASTERCAPS) &amp; RC_PALETTE) <br>    { <br>        nReserved = GetDeviceCaps(hDC,NUMRESERVED); <br>        nSize     = GetDeviceCaps(hDC,SIZEPALETTE) - nReserved; <br> <br>        if(hMem = GlobalAlloc(GHND,(DWORD)sizeof(LOGPALETTE)+(sizeof(PALETTEENTRY)*nSize))) <br>        { <br>            if(lpMem = (LPLOGPALETTE)GlobalLock(hMem)) <br>            { <br>                lpMem-&gt;palNumEntries = (WORD)nSize; <br>                lpMem-&gt;palVersion    = (WORD)0x0300; <br> <br>                switch(nColor) <br>                { <br>                    case COLOR_SCALE_RED: <br>                        for(idx=0; idx &lt; nSize; idx++) <br>                        { <br>                            lpMem-&gt;palPalEntry[idx].peRed   = (BYTE)idx; <br>                            lpMem-&gt;palPalEntry[idx].peGreen = 0; <br>                            lpMem-&gt;palPalEntry[idx].peBlue  = 0; <br>                            lpMem-&gt;palPalEntry[idx].peFlags = PC_RESERVED; <br>                        } <br>                        break; <br> <br>                    case COLOR_SCALE_GREEN: <br>                        for(idx=0; idx &lt; nSize; idx++) <br>                        { <br>                            lpMem-&gt;palPalEntry[idx].peRed   = 0; <br>                            lpMem-&gt;palPalEntry[idx].peGreen = (BYTE)idx; <br>                            lpMem-&gt;palPalEntry[idx].peBlue  = 0; <br>                            lpMem-&gt;palPalEntry[idx].peFlags = PC_RESERVED; <br>                        } <br>                        break; <br> <br>                    case COLOR_SCALE_BLUE: <br>                        for(idx=0; idx &lt; nSize; idx++) <br>                        { <br>                            lpMem-&gt;palPalEntry[idx].peRed   = 0; <br>                            lpMem-&gt;palPalEntry[idx].peGreen = 0; <br>                            lpMem-&gt;palPalEntry[idx].peBlue  = (BYTE)idx; <br>                            lpMem-&gt;palPalEntry[idx].peFlags = PC_RESERVED; <br>                        } <br>                        break; <br> <br>                    default: <br>                    case COLOR_SCALE_GRAY: <br>                        for(idx=0; idx &lt; nSize; idx++) <br>                        { <br>                            lpMem-&gt;palPalEntry[idx].peRed   = (BYTE)idx; <br>                            lpMem-&gt;palPalEntry[idx].peGreen = (BYTE)idx; <br>                            lpMem-&gt;palPalEntry[idx].peBlue  = (BYTE)idx; <br>                            lpMem-&gt;palPalEntry[idx].peFlags = PC_RESERVED; <br>                        } <br>                        break; <br>                } <br> <br>                hPalette = CreatePalette(lpMem); <br> <br>                GlobalUnlock(hMem); <br>            } <br>            GlobalFree(hMem); <br>        } <br>    } <br>    return(hPalette); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
