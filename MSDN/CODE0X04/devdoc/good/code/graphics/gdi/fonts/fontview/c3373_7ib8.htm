<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3374"></a>DISPLAY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;math.h&gt; <br> <br>#if defined (WIN32) <br>#define _MoveTo(hdc,x,y) MoveToEx(hdc,x,y,NULL) <br>#else <br>#define _MoveTo(hdc,x,y) MoveTo(hdc,x,y) <br>#endif <br> <br>// These are the 'exported' functions from this file: <br>void DrawAscii (HDC hdc, RECT *pRect, WORD direction); <br>void DrawGlyph (HDC hdc, RECT *pRect, BYTE glyph, HFONT hfont); <br>BYTE FindChar (HDC hdc, RECT *pRect, int x, int y); <br> <br>#pragma warning(4 : 4309) <br>// A data structure that DrawAscii will use: <br>char ascii[]= <br>    { <br>    // Low Ascii: <br> <br>    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, <br>    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, <br> <br>    // Standard Ascii: <br> <br>    ' ', '!', '"', '#', '$', '%', '&amp;', '\'', '(', ')', '*', '+', ',', <br>    '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', <br>    ':', ';', '&lt;', '=', '&gt;', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', <br>    'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', <br>    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', <br>    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', <br>    'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', <br>    '{', '|', '}', '~', ' ', <br> <br>    // High Ascii: <br> <br>    '\200', '\201', '\202', '\203', '\204', '\205', '\206', '\207', <br>    '\210', '\211', '\212', '\213', '\214', '\215', '\216', '\217', <br>    '\220', '\221', '\222', '\223', '\224', '\225', '\226', '\227', <br>    '\230', '\231', '\232', '\233', '\234', '\235', '\236', '\237', <br>    '\240', '\241', '\242', '\243', '\244', '\245', '\246', '\247', <br>    '\250', '\251', '\252', '\253', '\254', '\255', '\256', '\257', <br>    '\260', '\261', '\262', '\263', '\264', '\265', '\266', '\267', <br>    '\270', '\271', '\272', '\273', '\274', '\275', '\276', '\277', <br> <br>    '\300', '\301', '\302', '\303', '\304', '\305', '\306', '\307', <br>    '\310', '\311', '\312', '\313', '\314', '\315', '\316', '\317', <br>    '\320', '\321', '\322', '\323', '\324', '\325', '\326', '\327', <br>    '\330', '\331', '\332', '\333', '\334', '\335', '\336', '\337', <br>    '\340', '\341', '\342', '\343', '\344', '\345', '\346', '\347', <br>    '\350', '\351', '\352', '\353', '\354', '\355', '\356', '\357', <br>    '\360', '\361', '\362', '\363', '\364', '\365', '\366', '\367', <br>    '\370', '\371', '\372', '\373', '\374', '\375', '\376', '\377', <br> <br> <br>    // End of the list: <br> <br>    000, 000}; <br>#pragma warning(3 : 4309) <br> <br>/* A function that the CharSet window will use to display the text */ <br>void DrawAscii (HDC hdc, RECT *pRect, WORD direction) <br>{ <br>    BYTE *pch; <br>    int h, w, incx, incy, width; <br>    unsigned int  wDisplay; <br>    POINT pt; <br>    TEXTMETRIC tm; <br>    BOOL bLineMode = FALSE; <br> <br> <br>    GetTextMetrics (hdc, &amp;tm); <br>    h = tm.tmHeight; <br>    w = tm.tmMaxCharWidth; <br> <br>    incx = 0; <br>    incy = h; <br>    pt.x = 0; <br>    pt.y = 0; <br> <br>    // <br>    pt.y = tm.tmAscent + tm.tmExternalLeading; <br>    // <br> <br>    pch = &amp;(ascii[tm.tmFirstChar]); <br>    wDisplay = pRect-&gt;right -pRect-&gt;left; <br> <br>    // <br>    SetTextAlign (hdc, TA_BASELINE | TA_CENTER); <br>    SetBkMode (hdc, TRANSPARENT); <br>    // <br> <br>    while (pch[0] &amp;&amp; (pch[0]&lt;=tm.tmLastChar)) { <br>#if defined (WIN32) <br>        SIZE size; <br>        GetTextExtentPoint (hdc, pch, 1, &amp;size); <br>        width = size.cx; <br>#else <br>        width = LOWORD (GetTextExtent (hdc, pch, 1)); <br>#endif <br>        if ((unsigned)(pt.x + width) &gt; wDisplay) { <br>            pt.x = 0; <br>            pt.y += incy; <br>        } <br>        TextOut (hdc, pt.x + (width/2), pt.y, pch, 1); <br>        pt.x += width; <br>        pch++; <br>    } <br>    return; <br> <br>    direction; <br>} <br> <br>// Return the character that was drawn at the provided location <br>// This allows us to 'click' on a character, and determined what <br>// it was we actually clicked on. <br>BYTE FindChar (HDC hdc, RECT *pRect, int x, int y) <br>{ <br>    BYTE *pch; <br>    int h, w, incx, incy, width; <br>    unsigned int wDisplay; <br>    POINT pt; <br>    TEXTMETRIC tm; <br>    BOOL bLineMode = FALSE; <br> <br> <br>    GetTextMetrics (hdc, &amp;tm); <br>    h = tm.tmHeight; <br>    w = tm.tmMaxCharWidth; <br> <br>    incx = 0; <br>    incy = h; <br>    pt.x = 0; <br>    pt.y = 0; <br> <br>    pch = &amp;(ascii[tm.tmFirstChar]); <br>    wDisplay = pRect-&gt;right -pRect-&gt;left; <br> <br>    while (pch[0] &amp;&amp; (pch[0]&lt;=tm.tmLastChar)) { <br>#if defined (WIN32) <br>        SIZE size; <br>        GetTextExtentPoint (hdc, pch, 1, &amp;size); <br>        width = size.cx; <br>#else <br>        width = LOWORD (GetTextExtent (hdc, pch, 1)); <br>#endif <br>        if ((unsigned)(pt.x + width) &gt; wDisplay) { <br>            pt.x = 0; <br>            pt.y += incy; <br>        } <br>        if ((x&gt;=pt.x) &amp;&amp; (x &lt;=(pt.x+width)) &amp;&amp; (y&gt;=pt.y) &amp;&amp; (y&lt;=pt.y+incy)) return pch[0]; <br>        pt.x += width; <br>        pch++; <br>    } <br>    return 0; <br>} <br> <br>// Essentially, a StretchBlt, but draws cicular pels. <br>BOOL CircleBlt (HDC hdcDest, int xDst, int yDst, int iWidthDst, int iHeightDst, HDC hdcSrc, int xSrc, int ySrc, int iWidthSrc, int iHeightSrc, DWORD dwROP) <br>{ <br>    int x, y, x1, y1, x2, y2; <br>    DWORD rgb; <br>    float fXUnit, fYUnit; <br>    HBRUSH hbrush, hbrushOld; <br> <br>    if (iWidthSrc != 0){ <br>        fXUnit = (float)iWidthDst / (float)iWidthSrc; <br>    } else { <br>        fXUnit = (float)iWidthDst; <br>    } <br>    if (iHeightSrc != 0) { <br>        fYUnit = (float)iHeightDst / (float)iHeightSrc; <br>    } else { <br>        fYUnit = (float)iHeightDst; <br>    } <br> <br>    for (y=ySrc; y&lt;(ySrc+iHeightSrc); y++) { <br>        for (x=xSrc; x&lt;(xSrc+iWidthSrc); x++) { <br> <br>            rgb = GetPixel (hdcSrc, x, y); <br>            if (rgb != -1 &amp;&amp; rgb != 0x00FFFFFF) { <br>                hbrush = CreateSolidBrush (rgb); <br>                hbrushOld = SelectObject (hdcDest, hbrush); <br>                x1 = xDst + (int)((x-xSrc)*fXUnit); <br>                y1 = yDst + (int)((y-ySrc)*fYUnit); <br>                x2 = xDst + (int)(((x-xSrc)+1)*fXUnit)+1; <br>                y2 = yDst + (int)(((y-ySrc)+1)*fYUnit)+1; <br>                Ellipse (hdcDest, x1, y1, x2, y2); <br>                DeleteObject(SelectObject(hdcDest, hbrushOld)); <br>            } <br>        } <br>    } <br> <br>    return TRUE; <br> <br>    dwROP; <br>} <br> <br>double Radian(double ang) <br>{ <br>        return ang * (double)3.1415926535 / (double)180.0; <br>} <br> <br>void CalcRot (double x, double y, double ang, double* x1, double* y1) <br>{ <br>        ang = Radian(-ang); <br>        *x1 = (x * cos(ang)) - (y * sin(ang)); <br>        *y1 = (x * sin(ang)) + (y * cos(ang)); <br>} <br> <br>void DrawGlyph (HDC hdc, RECT *pRect, BYTE glyph, HFONT hfont) <br>{ <br>    TEXTMETRIC tm; <br>    LOGFONT lf; <br>    int wChar, h1, h2, w1, w2, x, y; <br>    double xTL, yTL, xTR, yTR, xBL, yBL, xBR, yBR, xML, yML, xMR, yMR; <br>    int cWidth, cExtentW, cExtentH; <br>    int unit, margin; <br>    RECT rect, rectChar; <br>    HDC hdcMem; <br>    HBITMAP hbitmap, hbitmapOld; <br>    HFONT hfontOld, hfontTmp; <br>    char szText[80]; <br>    double fAng, fWa, fWb, fHa, fHb, fHeight, fWidth; <br>    BOOL bRotateable; <br>    double fxOff, fyOff; <br>#if defined(TT_AVAILABLE) <br>    ABC abc; <br>#endif <br> <br>    GetTextMetrics (hdc, &amp;tm); <br>    hfontTmp = SelectObject (hdc, GetStockObject(SYSTEM_FONT)); <br>    GetObject (hfontTmp, sizeof(LOGFONT), &amp;lf); <br> <br>// Some fields of 'lf' need to be whacked out depending on the type of <br>// font involved. For instance, lfEscapement should only be non-zero for <br>// rotatable fonts. <br>        bRotateable = FALSE; <br>#if defined (TMPF_VECTOR) <br>        bRotateable = (tm.tmPitchAndFamily &amp; TMPF_VECTOR); <br>#endif <br>#if defined (TMPF_TRUETYPE) <br>        bRotateable |= (tm.tmPitchAndFamily &amp; TMPF_TRUETYPE); <br>#endif <br>        if (!bRotateable) { <br>                lf.lfEscapement = 0; <br>        } <br> <br>    SelectObject (hdc, hfontTmp); <br>    GetCharWidth (hdc, glyph, glyph, &amp;cWidth); <br> <br>#if defined (WIN32) <br>    { <br>        SIZE size; <br>        GetTextExtentPoint (hdc, (LPSTR)&amp;glyph, 1, &amp;size); <br>        cExtentW = size.cx; <br>        cExtentH = size.cy; <br>    } <br>#else <br>    cExtentW = LOWORD (GetTextExtent (hdc, (LPSTR)&amp;glyph, 1)); <br>    cExtentH = HIWORD (GetTextExtent (hdc, (LPSTR)&amp;glyph, 1)); <br>#endif <br> <br>    wChar = max(cWidth, cExtentW); <br> <br>#if defined(TT_AVAILABLE) <br>    if (GetCharABCWidths (hdc, (UINT)glyph, (UINT)glyph, &amp;abc)) { <br>        wChar = abc.abcA + abc.abcB + abc.abcC; <br>        wChar = max(abc.abcA,0) + max (abc.abcB,0) + max (abc.abcC,0); <br>    } else { <br>        abc.abcA = 0; <br>        abc.abcB = wChar; <br>        abc.abcC = 0; <br>    } <br>#endif <br> <br>// **** <br>        // Lets figure out how large of a bitmap we need to draw this character into. <br>        // This will take lfEscapement into account. <br> <br>        // Turn the 'escapement' value into a valid angle <br>    fAng = 90.0 - ((double)lf.lfEscapement/10.0); <br> <br>    // We now need to calculate two values for height and width. These <br>    // represent the bases of the triangles that are formed as the <br>    // character cell rotates. Thus fWa+fWb is the 'width' of the space <br>    // required by the given character at the current rotation. <br>    // At 0, 90, 180, 270 and 360, one of the two values will be '0'. <br>    fWa = (double)cExtentW * sin(Radian(fAng)); <br>    fHa = (double)cExtentW * sin(Radian((double)lf.lfEscapement/10.0)); <br>    fHb = (double)cExtentH * sin(Radian(fAng)); <br>    fWb = (double)cExtentH * sin(Radian((double)lf.lfEscapement/10.0)); <br> <br>    // This gives us a width/height of: <br>    fHeight = fabs(fHa) + fabs(fHb); <br>    fWidth = fabs(fWa) + fabs(fWb); <br>// **** <br> <br>    h1 = pRect-&gt;bottom - pRect-&gt;top; <br>    h2 = tm.tmHeight + tm.tmExternalLeading; <br>    h2 = (int)fHeight; <br>    if (h2 == 0) { <br>        MessageBeep (0); <br>        h2 = 10; <br>    } <br> <br>    w1 = pRect-&gt;right - pRect-&gt;left; <br>    w2 = (int)fWidth; <br> <br>    unit = (h1 / h2); <br> <br>    margin = (h1 - (unit * h2)) / 2; <br>    margin = 0; <br>    // Define a rectangle that will enclose our drawing area <br>    SetRect (&amp;rect, 0, 0, wChar*unit, (tm.tmHeight*unit) + (tm.tmExternalLeading*unit)); <br>    OffsetRect (&amp;rect, margin, margin); <br>    // Define a rectangle that will define the bounding box of the character <br>    SetRect (&amp;rectChar, 0, 0, wChar*unit, tm.tmHeight*unit); <br>    OffsetRect (&amp;rectChar, margin, margin + (tm.tmExternalLeading*unit)); <br> <br> <br>// **** <br>    // These are floating point values. <br>    SetRect (&amp;rect, 0, 0, (int)(fWidth)*unit, ((int)(fHeight)*unit) + (tm.tmExternalLeading*unit)); <br>    OffsetRect (&amp;rect, margin, margin); <br>    // Define a rectangle that will define the bounding box of the character <br>    SetRect (&amp;rectChar, 0, 0, (int)(fWidth)*unit, ((int)(fHeight)*unit)); <br>    OffsetRect (&amp;rectChar, margin, margin + (tm.tmExternalLeading*unit)); <br> <br>    // Calculate the points of the 'character cell'. This will take full <br>    // rotation into consideration. <br>        CalcRot (0, 0, (double)lf.lfEscapement/10.0, &amp;xTL, &amp;yTL); <br>        CalcRot ((double)cExtentW, 0, (double)lf.lfEscapement/10.0, &amp;xTR, &amp;yTR); <br>        CalcRot (0, (double)cExtentH, (double)lf.lfEscapement/10.0, &amp;xBL, &amp;yBL); <br>        CalcRot ((double)cExtentW, (double)cExtentH, (double)lf.lfEscapement/10.0, &amp;xBR, &amp;yBR); <br>        CalcRot (0, (double)tm.tmAscent, (double)lf.lfEscapement/10.0, &amp;xML, &amp;yML); <br>        CalcRot ((double)cExtentW, (double)tm.tmAscent, (double)lf.lfEscapement/10.0, &amp;xMR, &amp;yMR); <br> <br>        fxOff = min(xTL, min(xTR, min(xBL, xBR))); <br>        fyOff = min(yTL, min(yTR, min(yBL, yBR))); <br> <br>// Draw a rectangle around the drawing limits of the character. <br>    _MoveTo (hdc, (int)((xTL-fxOff)*(double)unit), (int)((yTL-fyOff)*(double)unit)); <br>    LineTo (hdc, (int)((xTR-fxOff)*(double)unit), (int)((yTR-fyOff)*(double)unit)); <br>    LineTo (hdc, (int)((xBR-fxOff)*(double)unit), (int)((yBR-fyOff)*(double)unit)); <br>    LineTo (hdc, (int)((xBL-fxOff)*(double)unit), (int)((yBL-fyOff)*(double)unit)); <br>    LineTo (hdc, (int)((xTL-fxOff)*(double)unit), (int)((yTL-fyOff)*(double)unit)); <br> <br>// Draw the baseline, which indicates the advance width of the character <br>    _MoveTo (hdc, (int)((xML-fxOff)*(double)unit), (int)((yML-fyOff)*(double)unit)); <br>    LineTo (hdc, (int)((xMR-fxOff)*(double)unit), (int)((yMR-fyOff)*(double)unit)); <br> <br>    hdcMem = CreateCompatibleDC (hdc); <br>    if (hdcMem) { <br>        hbitmap = CreateCompatibleBitmap (hdc, (int)(fWidth), (int)(fHeight)); <br>        if (hbitmap) { <br>            hbitmapOld = SelectObject (hdcMem, hbitmap); <br>            BitBlt (hdcMem, 0, 0, (int)(fWidth), (int)(fHeight), NULL, 0, 0, WHITENESS); <br>            hfontOld = SelectObject (hdcMem, hfont); <br> <br>            SetTextAlign (hdcMem, TA_LEFT | TA_BASELINE); <br>            if (TextOut (hdcMem, (int)(xML-fxOff), (int)(yML-fyOff), (LPSTR)&amp;glyph, 1)) { <br> <br> <br>                                /* <br>                // Just for debugging, lets mark some special pixels <br>                        SetPixel (hdcMem, (int)(xML-fxOff), (int)(yML-fyOff), 0x808080); // Base Lft <br>                        SetPixel (hdcMem, (int)(xTL-fxOff), (int)(yTL-fyOff), 0x808080); // Top Left <br>                        SetPixel (hdcMem, (int)(xTR-fxOff), (int)(yTR-fyOff), 0x808080); // Top Right <br>                        SetPixel (hdcMem, (int)(xBL-fxOff), (int)(yBL-fyOff), 0x808080); // Btm Left <br>                        SetPixel (hdcMem, (int)(xBR-fxOff), (int)(yBR-fyOff), 0x808080); // Btm Right <br>                        SetPixel (hdcMem, (int)(xML-fxOff), (int)(yML-fyOff), 0x808080); // Base Lft <br>                        SetPixel (hdcMem, (int)(xMR-fxOff), (int)(yMR-fyOff), 0x808080); // Base Rt <br>                */ <br> <br>                CircleBlt(hdc, margin, margin, <br>                    rectChar.right-rectChar.left, rectChar.bottom-rectChar.top, <br>                    hdcMem, 0, 0, (int)(fWidth), (int)(fHeight), SRCPAINT); <br> <br>            } else { <br>                MessageBox (GetFocus(), <br>                        "Unable to perform TextOut", "DisplayGlyph", MB_OK); <br>            } <br>            SelectObject (hdcMem, hbitmapOld); <br>            SelectObject (hdcMem, hfontOld); <br>            DeleteObject (hbitmap); <br>        } else { <br>            MessageBox (GetFocus(), "Unable To create Bitmap", "DisplayGlyph", MB_OK); <br>        } <br>        DeleteDC (hdcMem); <br>    } else { <br>        MessageBox (GetFocus(), "Unable to create DC", "DisplayGlyph", MB_OK); <br>    } <br> <br>    hfontTmp = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, VARIABLE_PITCH | FF_SWISS, ""); <br> <br>    if (hfontTmp) { <br>        hfontOld = SelectObject (hdc, hfontTmp); <br>        x = rect.right + 10; <br>        GetTextMetrics (hdc, &amp;tm); <br> <br>        y = tm.tmHeight + tm.tmExternalLeading; <br> <br>        y += tm.tmHeight + tm.tmExternalLeading; <br>        wsprintf (szText, "Character = '%c' %u (0x%X)", (char)glyph, (int)glyph, (int)glyph); <br>        TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        y += tm.tmHeight + tm.tmExternalLeading; <br>        wsprintf (szText, "CharWidth = %i", cWidth); <br>        TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>                // ABC Width - Eventually, I want to 'draw' this into the character <br>                // cell, but for now, this at least makes the information easily <br>                // available: <br>#if defined (TT_AVAILABLE) <br>        y += tm.tmHeight + tm.tmExternalLeading; <br>        wsprintf (szText, "A|B|C = %i | %u | %i", abc.abcA, abc.abcB, abc.abcC); <br>        TextOut (hdc, x, y, szText, lstrlen(szText)); <br>#endif <br> <br>        y += tm.tmHeight + tm.tmExternalLeading; <br>        wsprintf (szText, "CharExtentW = %i", cExtentW); <br>        TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        y += tm.tmHeight + tm.tmExternalLeading; <br>        wsprintf (szText, "CharExtentH = %i", cExtentH); <br>        TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>                // These are for some values I was using to debug the character <br>                // cell rotation calculation: <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "(%i,%i) : (%i,%i) [%i]", (int)xTL, (int)yTL, (int)xTR, (int)yTR,(int)(((double)lf.lfEscapement/10.0)*10)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "(%i,%i) : (%i,%i)", (int)xML, (int)yML, (int)xMR, (int)yMR); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "(%i,%i) : (%i,%i)", (int)xBL, (int)yBL, (int)xBR, (int)yBR); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fAng = %i", (int)(fAng)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fHa = %i", (int)(fHa)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fHb = %i", (int)(fHb)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fWa = %i", (int)(fWa)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fWb = %i", (int)(fWb)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fWd = %i", (int)(fWd)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fHd = %i", (int)(fHd)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fHeight = %i", (int)(fHeight)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        //y += tm.tmHeight + tm.tmExternalLeading; <br>        //wsprintf (szText, "fWidth = %i", (int)(fWidth)); <br>        //TextOut (hdc, x, y, szText, lstrlen(szText)); <br> <br>        SelectObject (hdc, hfontOld); <br>        DeleteObject (hfontTmp); <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
