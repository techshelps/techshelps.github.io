<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GRID.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3385"></a>GRID.CXX</h2>
<pre><code>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;string.h&gt; <br>#include "app.h" <br> <br>#include "grid.hxx" <br> <br>// These are global variables set by CFontRange::SetFontRange() <br>// and used by CTextGrid::SetCharTable(). This is safe as only <br>// one font is selected at a given time by the program. <br> <br>int             vSegCount; <br>USHORT *        vStartCount; <br>USHORT *        vEndCount; <br> <br>CSet   * vpCSet; <br> <br>//+-------------------------------------------------------- <br>// Class:       CFontSelect <br>// <br>// Purpose:     Select/Deselect a font <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>// pure inline <br> <br>//+-------------------------------------------------------- <br>// Class:       CGridIt <br>// <br>// Purpose:     Iterate over a grid <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>// pure inline <br> <br>//+-------------------------------------------------------- <br>// Class:       CLineGrid <br>// <br>// Purpose:     Create an n x m Grid of lines <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>CLineGrid::CLineGrid(UINT cCol, UINT cRow, SIZE size )  <br>{ <br>    _size = size; <br>    _cCol = cCol; <br>    _cRow = cRow; <br>    SetStyle(); <br>    SetWeight(); <br>} <br> <br>void CLineGrid::SetStyle(int iStyle) <br>{ <br>    _iStyle = iStyle; <br>} <br> <br>void CLineGrid::SetWeight(int nWeight) <br>{ <br>    _nWeight = nWeight*20;  // internal twips, API is points <br>} <br> <br>void CLineGrid::Paint(CCanvas&amp; canvas, RECT rc, POINT pt) <br>{ <br>    int cx, cy; <br>    UINT i; <br> <br>    // set up pen <br>    CBlackPen pen(canvas, _iStyle, _nWeight); <br> <br>    // Draw the grid <br>    for(cx = pt.x, i=0; i&lt;=_cCol; i++, cx+=_size.cx ) <br>    { <br>        if( cx &gt;= rc.left &amp;&amp; cx &lt;= rc.right ) <br>        { <br>            canvas.Line(cx, pt.y, <br>                        cx, pt.y+_cRow*_size.cy); <br>        } <br>    } <br>    for(cy = pt.y, i=0; i&lt;=_cRow; i++, cy+=_size.cy ) <br>    { <br>        if( cy &gt;= rc.top &amp;&amp; cy &lt;= rc.bottom ) <br>        { <br>            canvas.Line(pt.x,                cy, <br>                        pt.x+_cCol*_size.cx, cy); <br>        } <br>    } <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CTextGrid <br>// <br>// Purpose:     Create an n x m grid of textual elements <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>void CTextGrid::SetFont(HFONT hfont) <br>{ <br>    _font = hfont; <br>} <br> <br>void CTextGrid :: Paint(CCanvas&amp; canvas, RECT rc, POINT pt) <br>{ <br>    // Choose text alignment <br>    SetTextAlign(HDC(canvas), TA_BASELINE|TA_CENTER); <br> <br>    CFontSelect fs(canvas, _font); <br> <br>    for( CGridIt It( _cCol, _cRow, _size, pt ); !It.Done(); ++It) <br>    { <br>        if( It.Cx()+_size.cx &gt; rc.left &amp;&amp; It.Cx() &lt; rc.right &amp;&amp; <br>                It.Cy()+_size.cy &gt; rc.top &amp;&amp; It.Cy() &lt; rc.bottom ) <br>        { <br>            DrawElement(canvas, It.Cx()+_ptOrg.x, It.Cy()+_ptOrg.y,  <br>                                It.Col(), It.Row()); <br>        } <br>    } <br>} <br> <br>UINT CTextGrid::Hittest(POINT pt, POINT ptTest) <br>{ <br>    for( CGridIt It( _cCol, _cRow, _size, pt ); !It.Done(); ++It) <br>    { <br>        if( It.Cx() &lt;= ptTest.x &amp;&amp; It.Cy() &lt;= ptTest.y  &amp;&amp; <br>            It.Cx()+_size.cx &gt; ptTest.x &amp;&amp; It.Cy() +_size.cy &gt; ptTest.y) <br>            { <br>                return   _cRow* It.Col()+ It.Row() + _iEltOffset; <br>            } <br>    } <br>    return 0xFFFF; <br>} <br> <br>void CTextGrid::SetCharTable() <br>{ <br>     USHORT i; <br> UINT imin = _iEltOffset; <br> UINT imax = imin + _cCol*_cRow - 1; <br> <br> // Make sure the block is used by the font <br> if (_pCharUsed != NULL) <br>     LocalFree (LocalHandle(_pCharUsed)); <br> // Allocate buffer and make it not used (LPTR put zero in memory) <br> if ((_pCharUsed = (USHORT *)LocalAlloc(LPTR, _cCol*_cRow*sizeof(USHORT))) == NULL) <br>     return; <br> if (imin &gt; vEndCount[vSegCount-1] || imax &lt; vStartCount[0]) <br>     return; <br> for (i = 0; i &lt; vSegCount; i++) <br>     { <br>     if (imax &lt; vStartCount[i]) // no more useful cmap ranges <br>         break; <br>     if (imin &lt;= vEndCount[i] &amp;&amp; imax &gt;= vStartCount[i]) // check for include <br>     { <br>         UINT icur = imin; <br>         while (icur++ &lt; vStartCount[i]);  // scan until reaching vStartCount <br> icur--; <br> while (icur &lt;= imax &amp;&amp; icur &lt;= vEndCount[i]) <br> _pCharUsed[icur++ - imin] = TRUE; <br> } <br>  } <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CCharGrid <br>// <br>// Purpose:     Create an n x m Grid of single characters <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>CCharGrid :: CCharGrid(UINT cCol, UINT cRow, SIZE size, UINT iEltOffset)  <br>{ <br>    _size  = size; <br>    _cCol  = cCol; <br>    _cRow  = cRow; <br>    _iEltOffset = iEltOffset; <br>    SetTextOrg(); <br>} <br> <br>#define NBSP 0x00A0// no break space <br> <br>void CCharGrid::DrawElement(CCanvas&amp; canvas, COORD x, COORD y, UINT i, UINT j) <br>{ <br>WORD iChar = _cRow*i+j+_iEltOffset; <br>#ifdef UNICODE <br>static CCTypeSet Combining(0,0,C3_NONSPACING || C3_DIACRITIC || C3_VOWELMARK); <br>static CCTypeSet Alpha(C1_ALPHA, 0, 0); <br>#endif <br> <br>if ( vpCSet &amp;&amp; vpCSet-&gt;In(iChar) ) <br>{ <br>    SetTextColor(canvas, RGB(128,0,128)); <br>} <br>    if (_pCharUsed == NULL || _pCharUsed[_cRow*i+j]) // if char exists draw it <br>{ <br>#ifdef UNICODE <br>if( Combining.In(iChar) &amp;&amp; !Alpha.In(iChar) ) <br>{ <br>TCHAR pch[2] = { iChar,0 }; <br>CFontSelect fs(canvas, _font); <br>//SIZE size; <br>    //GetTextExtentPoint(canvas, pch, 2, &amp;size); <br>//canvas.Text(x, y, pch, 2 ); <br>canvas.Char(x+_size.cx/4/*+size.cx/2*/,y, iChar); <br> <br>    // set up pen <br>    CBlackPen pen(canvas, PS_DOT, 0); <br>CBrush brush(canvas); <br> <br>// draw dotted circle <br>int r = 7*_size.cx/16;  <br>canvas.Circle(x, y-r/2, r); <br>} <br>else <br>{ <br>        canvas.Char(x, y, iChar); <br>} <br>#else <br>canvas.Char(x, y, iChar); <br>#endif <br>} <br>    SetTextColor(canvas, RGB(0,0,0)); <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CCodeGrid <br>// <br>// Purpose:     Create an n x m Grid, numbered in sequence <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>CCodeGrid :: CCodeGrid(UINT cCol, UINT cRow, SIZE size, UINT iEltOffset)  <br>{ <br>    _size  = size; <br>    _cCol  = cCol; <br>    _cRow  = cRow; <br>    _iEltOffset = iEltOffset; <br>    SetTextOrg(); <br>    SetFormat(); <br>} <br> <br>void CCodeGrid :: SetFormat(UINT fuFormat, UINT cDigits) <br>{ <br>    _cDigits = cDigits; <br> <br>    _szFormat[0]='%'; <br>    if( fuFormat == DECIMAL ) <br>    { <br>        _cDigits = 4;       // Constraint: <br>                            // This format for Decimal <br>        _szFormat[1]='3';   // really only works with _cDigits == 4 <br>        _szFormat[2]='d';   //  <br>        _szFormat[3]=' ';   // (blank padding for better positioning) <br>    }  <br>    else //  <br>    { <br>        _szFormat[1]='0'; <br>        _szFormat[2]=_cDigits%10+'0'; <br>        _szFormat[3]='X'; <br>    } <br>    _szFormat[4]='\0'; <br>} <br> <br>void CCodeGrid::DrawElement(CCanvas &amp;canvas, COORD x, COORD y, UINT i, UINT j) <br>{ <br>     TCHAR sz[10]; <br> if (_pCharUsed == NULL || _pCharUsed[_cRow*i+j]) // if char exists draw it <br>         { <br>         wsprintf( sz,_szFormat, (_cRow*i+j+_iEltOffset)); <br>         canvas.Text(x, y, sz, _cDigits); <br> } <br>} <br> <br> <br>//+-------------------------------------------------------- <br>// Class:       CCharBlock <br>// <br>// Purpose:     Create an n x m lined block of characters and codes <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>CCharBlock::CCharBlock(UINT cCol, UINT cRow, UINT iBlockOffset, const CBlockFormat &amp;bf) : <br>     _Line(cCol, cRow, bf._size), <br>     _Char(cCol, cRow, bf._size, iBlockOffset), <br>     _Code(cCol, cRow, bf._size, iBlockOffset) <br>{ <br>     // LINE GRID <br>     _Line.SetStyle(PS_SOLID); <br> <br>     // LARGE CHARACTER each cell <br>     _Char.SetFont(bf._fontChar);  <br> <br>     // CODE POINT label each cell <br>     _Code.SetTextOrg(bf._size.cx/2, 9*bf._size.cy/10); <br>     _Code.SetFont(bf._fontCode); <br>     _Code.SetFormat(HEXADECIMAL,4); <br>} <br> <br>void CCharBlock::Paint(CCanvas&amp; canvas, RECT rc, POINT pt) <br>{ <br>    _Line.Paint(canvas, rc, pt); <br>#ifdef UNICODE             <br>    _Char.SetCharTable(); <br>    _Code.SetCharTable(); <br>#endif             <br>    _Char.Paint(canvas, rc, pt); <br>    _Code.Paint(canvas, rc, pt); <br>} <br> <br>UINT CCharBlock::Hittest(POINT pt, POINT ptTest) <br>{ <br>    return _Code.Hittest(pt, ptTest); <br>} <br> <br>void CCharBlock :: SetFormat(UINT fuFormat) <br>{ <br>    _Code.SetFormat(fuFormat&amp;DECIMAL,4); <br>} <br> <br>void CCharBlock::SetFont(HFONT font) <br>{ <br>    _Char.SetFont(font); <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CBlockFrame <br>// <br>// Purpose:     Create an n x m frame around a block of characters <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>CBlockFrame::CBlockFrame(UINT cCol, UINT cRow, POINT pt, UINT iBlockOffset,  <br>                                TCHAR * szHeader, const CFrameFormat &amp;ff): <br>     CCharBlock(cCol, cRow, iBlockOffset, ff ), <br>     _size(ff._size), <br>     _Cols(cCol,    1, ff._size, iBlockOffset/16), <br>     _cRow(cRow), <br>     _cCol(cCol) <br>{ <br> <br>     // COLUMN label above first row <br>     _Cols.SetFormat(HEXADECIMAL,3); <br>     _Cols.SetFont(ff._fontLabel);       <br> <br> <br>     // if not first block on page, suppress row labels <br>     if( iBlockOffset % 0x100 ) <br>     { <br>        _pRows = NULL; <br>     } <br>     else <br>     { <br>        // ROW label to left of first column <br>        _pRows = new CCodeGrid(1, cRow,  ff._size); <br>        _pRows-&gt;SetFont(ff._fontLabel);  <br>     } <br> <br>     // BLOCK HEADER <br>     _szHeader = new TCHAR[lstrlen(szHeader)+sizeof(TCHAR)]; <br>     lstrcpy(_szHeader, szHeader); <br>     _fontHeader = ff._fontHeader; <br> <br>} <br> <br>CBlockFrame::~CBlockFrame() <br>{ <br>    delete _pRows; <br>    delete _szHeader; <br>} <br> <br> <br>void CBlockFrame::Paint(CCanvas&amp; canvas, RECT rc, POINT pt) <br>{ <br>    Draw(canvas, pt); <br>    { <br>        POINT ptCols = {pt.x, pt.y-_size.cy}; <br>        _Cols.Paint(canvas, rc, ptCols);   <br>    }  <br>    CCharBlock::Paint(canvas, rc, pt);   <br>     <br>    // these two are optional. Test first, then draw <br>    if(_pRows ) <br>    {    <br>        POINT ptRows = {pt.x-_size.cx, pt.y}; <br>        _pRows-&gt;Paint(canvas, rc, ptRows); <br>    }    <br>} <br> <br>void CBlockFrame::Draw(CCanvas&amp; canvas, POINT pt) <br>{ <br>    UINT dy = 3*_size.cy/2;     // height of short uprights <br>    UINT cx = _cCol*_size.cx;    <br>    UINT cy = _cRow*_size.cy; <br>RECT rc; <br>         <br>    // set up pen <br>    CBlackPen pen(canvas, PS_SOLID, 40);    // Solid Black 40/20 points <br> <br>    //Draw block divider lines <br>     <br>    canvas.Line(pt.x,    pt.y-dy, pt.x,    pt.y+cy);  // left edge <br>    canvas.Line(pt.x+cx, pt.y-dy, pt.x+cx, pt.y+cy);  // right edge <br>    canvas.Line(pt.x,    pt.y,    pt.x+cx, pt.y);     // top edge <br>    canvas.Line(pt.x,    pt.y+cy, pt.x+cx, pt.y+cy);  // bottom <br>     <br>    CFontSelect fs(canvas, _fontHeader); <br> <br>    SetTextAlign(canvas, TA_BASELINE|TA_LEFT); <br>rc.left = pt.x + _size.cx/12; <br>rc.top = pt.y - 6*_size.cy/5; <br>rc.right = pt.x + cx - _size.cx/12; <br>rc.bottom = pt.y; <br>    canvas.RCText(&amp;rc, <br>      _szHeader, <br>                 lstrlen(_szHeader)); <br>} <br> <br>// The following Array contains the widhts of the Unicode blocks in <br>// columns. Each Block has a corresponding entry in the stringtable <br>// giving its block header. "Unassigned" blocks can span page boun- <br>// daries.  <br> <br>static UINT aBlockWidth[]= <br>{ <br>    2,6,2,6,   // 0000 <br>    8,8,       // 0100 <br>    5,6,5,     // 0200 <br>    7,6,3,     // 0300 <br>    16,        // 0400 <br>    3,6,7,     // 0500 <br>    16,        // 0600 <br>    32,        // 0700 - 08FF  <br>    8,8,       // 0900 <br>    8,8,       // 0A00 <br>    8,8,       // 0B00 <br>    8,8,       // 0C00 <br>    8,8,       // 0D00 <br>    8,8,       // 0E00 <br>    16,        // 0F00 <br>    10,6,     // 1000 <br>16,   // 1100 <br>    192,       // 1200 - 1DFF <br>16,   // 1E00 <br>16,   // 1F00 <br>    7,3,3,3,   // 2000 <br>    5,4,7,     // 2100 <br>    16,        // 2200 <br>    16,        // 2300 <br>    4,2,10,    // 2400 <br>    8,2,6,     // 2500 <br>    16,        // 2600 <br>    12,4,      // 2700 <br>    128,       // 2800 - 2FFF  <br>    4,6,6,     // 3000 <br>    3,6,1,6,   // 3100 <br>    16,        // 3200 <br>    16,        // 3300 <br>    144,       // 3400 - 3CFF <br>    3,13,      // 3D00 <br>    96,        // 3E00 - 43FF <br>16,   // 4400 <br>144,   // 4500 - 4DFF <br>    82*16,     // 4E00 - 9FFF <br>    64*16,     // A000 - DFFF <br>    25*16,     // E000 - F8FF <br>    32,        // F900 - FAFF <br>5,11,   // FB00  <br>    32,        // FC00 - FDFF  <br>    2,5,9,     // FE00 <br>    15,1,      // FF00 <br>    200        // Sentinel <br>}; <br> <br>//+-------------------------------------------------------- <br>// Class:       CBlockFormat <br>// <br>// Purpose:     Block formatting <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>CBlockFormat::CBlockFormat() : <br>    _fontCode    (TEXT("Arial Narrow"), -6), <br>#ifdef UNICODE <br>    _fontChar    (TEXT("Lucida Sans Unicode"), -16, TRUE) <br>#else <br>    _fontChar    (TEXT("Lucida Sans"), -16, TRUE) <br>#endif <br>{ <br>}; <br> <br>//+-------------------------------------------------------- <br>// Class:       CFrameFormat <br>// <br>// Purpose:     Frame formatting <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>CFrameFormat::CFrameFormat() : <br>    _fontHeader  (TEXT("Arial"), -12, TRUE), <br>    _fontLabel   (TEXT("Arial"), -10, TRUE) <br>{ <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CPageFormat <br>// <br>// Purpose:     Page formatting <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>CPageFormat::CPageFormat(UINT fuFormat) : <br>    _fontPageNum (TEXT("Times New Roman"), -10, FALSE) <br>{ <br>    _size.cx =  4*INCH2/5; <br>    _size.cy =  INCH2; <br> <br>    SetFormat(fuFormat); <br>} <br> <br>void CPageFormat::SetFormat(UINT fuFormat) <br>{ <br>    _fuFormat = fuFormat; <br> <br>    if( fuFormat &amp; PAGEPRINT ) <br>    { <br>        _pt.x=     INCH2+(INCH2*7)/10; <br>        _pt.y=     INCH1+(INCH1*7)/10; <br>    }  <br>    else <br>    { <br>        _pt.x=     INCH2; <br>        _pt.y=     INCH1; <br>    } <br> <br>    // locations of headers / footers <br>    _ptPE[0].x = _pt.x-_size.cx;  <br>    _ptPE[0].y = _size.cy/2; <br>    _ptPE[1].x = _pt.x+_size.cx*16;  <br>    _ptPE[1].y = _size.cy/2; <br>    _ptPE[2].x = _pt.x+(_size.cx*15)/2; <br>    _ptPE[2].y = _pt.y+(_size.cy*33)/2; <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CPage <br>// <br>// Purpose:     One or more blocks <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>CPage::CPage(HINSTANCE hInst, CPageFormat &amp;pf, UINT nPage) : <br>    _cBlock(0), <br>    _pf(pf), <br>    _hInst(hInst), <br>    _PageHeadL (1, 1, pf._size,nPage*256      ), <br>    _PageHeadR (1, 1, pf._size,(nPage+1)*256-1), <br>    _PageNums  (1, 1, pf._size,nPage+1        )         <br>                                // page numbers are 1 based on output <br>{ <br>    // Set up page elementss <br> <br>    _PageHeadL.SetFont(pf._fontLabel); <br>    _PageHeadR.SetFont(pf._fontLabel); <br>    _PageNums.SetFont(pf._fontPageNum); <br> <br>    InitPage( nPage); <br>    SetFormat(_pf._fuFormat); <br>} <br> <br>CPage::~CPage() <br>{ <br>    while( _cBlock ) <br>    { <br>        delete _apBlock[--_cBlock]; <br>    }    <br>} <br> <br> <br> <br>void CPage::SetFormat(UINT fuFormat) <br>{ <br>    // set it <br>    _pf.SetFormat(fuFormat); <br> <br>    // apply it <br>    for( UINT i = 0; i &lt; _cBlock ; ++i ) <br>    { <br>        _apBlock[i]-&gt;SetFormat(fuFormat&amp;MASKROOT); <br>    } <br> <br>    _PageHeadL.SetFormat(HEXADECIMAL, 4); <br>    _PageHeadR.SetFormat(HEXADECIMAL, 4); <br>    _PageNums.SetFormat(DECIMAL); <br>} <br> <br> <br>void CPage::Paint(CCanvas&amp; canvas, RECT rc) <br>{ <br>    for( UINT i = 0; i &lt; _cBlock; ++i ) <br>    { <br>        _apBlock[i]-&gt;Paint(canvas, rc, _aptBlock[i]); <br>    } <br> <br>    if( _pf._fuFormat &amp; PAGEELEMS ) <br>    { <br>        _PageHeadL.Paint(canvas, rc, _pf._ptPE[0]); <br>        _PageHeadR.Paint(canvas, rc, _pf._ptPE[1]); <br>        _PageNums.Paint (canvas, rc, _pf._ptPE[2]); <br>    }    <br>} <br> <br>UINT CPage::Hittest(POINT ptTest) <br>{ <br>    UINT uHit = 0xFFFF; <br> <br>    for( UINT i = 0; i &lt; _cBlock &amp;&amp; uHit ==0xFFFF ; ++i ) <br>    { <br>        uHit = _apBlock[i]-&gt;Hittest(_aptBlock[i], ptTest); <br>    } <br>    return uHit; <br>} <br> <br>//-- protected member functions... <br> <br>UINT CPage::InitPage(UINT nPage) <br>{ <br>    UINT iEnd = 0; <br>    TCHAR szBlockHeader[40]; <br>    UINT i; <br>    POINT ptBlock=_pf._pt; <br> <br>    // Set up blocks <br> <br>    for( i=0; i &lt; sizeof(aBlockWidth)/sizeof(UINT); i++ ) <br>    { <br>        if( nPage*16 &lt; (iEnd+=aBlockWidth[i]) ) <br>        { <br>            break; <br>        } <br>    } <br>    UINT iStart = max(nPage*16, iEnd-aBlockWidth[i]); <br> <br>    do <br>    { <br>        LoadString(_hInst, i, szBlockHeader, 40); <br>        _apBlock[_cBlock]= new CBlockFrame( <br>                  min( aBlockWidth[i],      // grid width in columns <br>                       (nPage+1)*16-iStart),// (but at most to end of page) <br>                  16,                       // cRow always 16 <br>                  ptBlock,                  // grid origin <br>                  iStart*16,                // first char offset <br>                  szBlockHeader,            // header string <br>                  _pf);                     // common formatting <br> <br>        _aptBlock[_cBlock] = ptBlock; <br>        _cBlock++; <br> <br>        ptBlock.x+=_pf._size.cx*aBlockWidth[i]; <br>        iStart=iEnd; <br>    }  <br>    while( <br>            (i++ &lt; sizeof(aBlockWidth)/sizeof(UINT)) <br>                &amp;&amp; <br>            ((nPage+1)*16 &gt;= (iEnd+=aBlockWidth[i])) <br>                &amp;&amp; <br>            (_cBlock &lt; 4)   <br>         ); <br> <br> <br>    return _cBlock; <br>} <br> <br> <br>void CPage::SetFont(HFONT hfont) <br>{ <br>    for( UINT i = 0; i &lt; _cBlock ; ++i ) <br>    { <br>        _apBlock[i]-&gt;SetFont(hfont); <br>    } <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CModel   <br>// <br>// Purpose:     Iterator over pages <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>CModel::CModel(HINSTANCE hInst, HWND hwnd, UINT fuFormat, UINT fPageMode) : <br>    _iPage(0), <br>#ifdef UNICODE <br>    _macPage(0x100), <br>#else <br>    _macPage(1), <br>#endif <br>    _pf(fuFormat), <br>    _hInst(hInst), <br>    _fPageMode(fPageMode) <br>{ <br>    _pPage = new CPage(hInst, _pf, _iPage); <br>    _fr.SetFontRange(hwnd, _pf._fontChar); <br>} <br> <br>CModel::~CModel() <br>{ <br>    delete _pPage;       <br>} <br> <br>void CModel::NextPage() <br>{ <br> <br>    if (_fPageMode == ALLPAGES) <br>        SetPage(_iPage+=(_iPage+1&lt;_macPage? 1 : 0)); <br>else <br>    { <br>   int iNewPage = _iPage; <br>        while (!_fr.IsPageUsed(++iNewPage) &amp;&amp; iNewPage &lt; (int)_macPage);// scan until first found <br>if (iNewPage &lt; (int)_macPage)   // change only if under boundary <br>    SetPage(_iPage = (UINT)iNewPage); <br>} <br>} <br> <br>void CModel::PrevPage() <br>{ <br>    if (_fPageMode == ALLPAGES) <br>        SetPage(_iPage-=(_iPage? 1 : 0)); <br>else <br>    { <br>   int iNewPage = _iPage; <br>        while (!_fr.IsPageUsed(--iNewPage) &amp;&amp; iNewPage &gt;= 0); // scan until first found <br>if (iNewPage &gt;= 0)                                // change only if above boundary <br>    SetPage(_iPage = (UINT)iNewPage); <br>} <br>} <br> <br>void CModel::NextSection() <br>{ <br>_iPage+=(_iPage+16&lt;_macPage? 16 : 0); // increment by 16 pages <br>    if (_fPageMode == ALLPAGES || _fr.IsPageUsed(_iPage)) // if in USEDONLY mode and <br>        SetPage(_iPage); // the page is not used <br>else <br>NextPage(); <br>} // we skip to the next <br> <br>void CModel::PrevSection() <br>{ <br>    _iPage-=(_iPage &gt;= 16 ? 16 : 0); <br>    if (_fPageMode == ALLPAGES || _fr.IsPageUsed(_iPage)) // if in USEDONLY mode and <br>        SetPage(_iPage); // the page is not used <br>else <br>PrevPage(); // we skip to the previous <br>} <br> <br>void CModel::SetPage(UINT nPage) <br>{ <br>    delete _pPage; <br>    _pPage = new CPage(_hInst, _pf, nPage);      <br>} <br> <br>void CModel::GetFormat(UINT &amp;fuFormat)  <br>{ <br>    fuFormat=_pf._fuFormat;  <br>} <br> <br>void CModel::SetFormat(UINT fuFormat)  <br>{ <br>    _pPage-&gt;SetFormat(fuFormat); <br>} <br> <br>HFONT CModel::GetFont() <br>{ <br>    return _pf._fontChar; <br>} <br> <br>BOOL CModel::CreateFont(LOGFONT &amp;lf) <br>{ <br>    if(_pf._fontChar.Create(lf)) <br>    { <br>         _pPage-&gt;SetFont(_pf._fontChar); <br>         return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>BOOL CModel::ChooseFont(HWND hwnd) <br>{ <br>    if(_pf._fontChar.Choose(hwnd)) <br>    { <br> _fr.SetFontRange(hwnd, _pf._fontChar); <br>         _pPage-&gt;SetFont(_pf._fontChar); <br>         return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>UINT CModel::Hittest( POINT pt) <br>{ <br>    return _pPage-&gt;Hittest( pt); <br>} <br> <br>void CModel::GetPageMode(UINT &amp;fPageMode)  <br>{ <br>    fPageMode = _fPageMode;  <br>} <br> <br>void CModel::SetPageMode(UINT fPageMode)  <br>{ <br>    _fPageMode = fPageMode; <br>if (fPageMode == USEDONLY &amp;&amp; !_fr.IsPageUsed(_iPage))//if the current page is empty <br>    { <br>UINT iCurrentPage = _iPage; <br>NextPage();//we skip to next <br>if (iCurrentPage == _iPage)//if there is no next page <br>    PrevPage();//we go to prev (has to be one) <br>} <br>} <br> <br>void CModel :: SetCSet(CSet * pCSet) <br>{ <br>vpCSet = pCSet; <br>} <br> <br>//+---------------------------------------------------------------------- <br>// ClassCFontRange <br>// <br>// Purpose:Set character coverage of the target font <br>// <br>// History:6-Dec-1993michelsu created <br>//----------------------------------------------------------------------- <br>void CFontRange::SetFontRange(HWND hwnd, HFONT hfont) <br>{ <br>    CScreenCanvas scanvas(hwnd);     // provide the DC <br>    CFontSelect fs(scanvas, hfont); <br> <br>    USHORT   i; <br>  <br>    for (i=0;i&lt;256;i++) <br>        _fPageUsed[i]=FALSE;         // assume no page used <br>#ifdef UNICODE <br>    if (CountUCSegments(scanvas))    // set page used flag for relevant pages <br>        for (i=0;i&lt;vSegCount;i++) _fPageUsed[(vStartCount[i] &amp; 0xFF00) &gt;&gt; 8] = TRUE; <br>    else                             // if the font is not TrueType, set only the 1st page <br>        _fPageUsed[0] =TRUE; <br>#else <br>    _fPageUsed[0] =TRUE; <br>#endif <br>} <br> <br>CFontRange::~CFontRange() <br>{ <br>    if (vStartCount != NULL) <br>        LocalFree (LocalHandle (vStartCount)); <br>    if (vEndCount != NULL) <br>        LocalFree (LocalHandle (vEndCount)); <br>} <br>//+---------------------------------------------------------------------- <br>// ClassCFontRange <br>// <br>// Purpose:Get character coverage of the target font (_pf._fontChar) <br>// <br>// History:6-Dec-1993michelsu created (borrowed in large from TTFONTS) <br>//----------------------------------------------------------------------- <br>BOOL CFontRange::CountUCSegments(HDC hdc) <br>{ <br>#define CMAPHEX0x70616d63 // = "cmap" (reversed) <br>#define NBYTES   256 <br>#define OFFSETERROR 0 <br>#define MBERROR TEXT("Application Error.") <br>#define MBERRORFLAGS MB_OK | MB_ICONHAND <br> <br>typedef struct tagTABLE{ <br>    USHORT platformID; <br>    USHORT encodingID; <br>    ULONG  offset; <br>} TABLE, *PTABLE; <br> <br>typedef struct tagSUBTABLE{ <br>    USHORT format; <br>    USHORT length; <br>    USHORT version; <br>    USHORT segCountX2; <br>    USHORT searchRange; <br>    USHORT entrySelector; <br>    USHORT rangeShift; <br>} SUBTABLE, *PSUBTABLE; <br> <br>    DWORD       cbData; <br>    USHORT      aShort[2]; <br>    DWORD       nBytes; <br>    USHORT      i, nTables; <br>    PTABLE      pTable; <br>    PSUBTABLE   pSubTable; <br>    ULONG       offset,offsetFormat4; <br>    BYTE        buffer[NBYTES]; <br> <br>    // find number of encoding tables, second long in cmap <br>    nBytes = GetFontData(hdc, CMAPHEX, 0, aShort, 4); <br>    if (nBytes == GDI_ERROR || nBytes == 0)//GDI error or no cmap table <br>        return FALSE; <br>    nTables = aShort[1]; <br>    SwapShort (&amp;nTables); <br> <br>    // limit ourself to 32 encoding tables (largely enough) <br>    cbData = nTables * sizeof(TABLE); <br>    if (cbData &gt;NBYTES) <br>    { <br>    MessageBox (NULL, TEXT("cbData &gt;NBYTES"),MBERROR , MBERRORFLAGS); <br>    return FALSE; <br>    } <br> <br>    // get array of encoding tables. <br>    // Check each one for PlatformId = 3, Encoding ID = 1. <br>    nBytes=GetFontData (hdc, CMAPHEX, 4, buffer, cbData); <br>    pTable = (PTABLE)buffer; <br>    offsetFormat4 = OFFSETERROR; <br>    for (i = 0; i&lt; nTables; i++) <br>    { <br>        SwapShort (&amp;(pTable-&gt;encodingID)); <br>        SwapShort (&amp;(pTable-&gt;platformID)); <br>        if ((pTable-&gt;platformID == 3)&amp;&amp;(pTable-&gt;encodingID == 1)) <br>            { <br>            offsetFormat4 = pTable-&gt;offset; <br>            SwapULong (&amp;offsetFormat4); <br>            break; <br>            } <br>        pTable++; <br>        } <br>    if (offsetFormat4 == OFFSETERROR) //Can not find 3,1 subtable  <br>        return FALSE; <br> <br>    /* Get the beginning of the subtable, especially the segment count */ <br>    nBytes=GetFontData (hdc, CMAPHEX, offsetFormat4, buffer, sizeof(SUBTABLE)); <br>    pSubTable = (PSUBTABLE) buffer; <br>    SwapShort (&amp;(pSubTable-&gt;format)); <br>    SwapShort (&amp;(pSubTable-&gt;segCountX2)); <br>    if (pSubTable-&gt;format != 4) <br>        { <br>        MessageBox (NULL, TEXT("format !=4"), MBERROR, MBERRORFLAGS); <br>        return FALSE; <br>        } <br>    vSegCount = pSubTable-&gt;segCountX2 / 2; <br> <br>    /* Now that we know how many segments that the font contains, <br>     *  free up the old memory, and realloc. the two global arrays. <br>     */ <br>    if (vStartCount != NULL) <br>        LocalFree (LocalHandle (vStartCount)); <br>    if (vEndCount != NULL) <br>        LocalFree (LocalHandle (vEndCount)); <br>    vStartCount = (USHORT *)LocalAlloc (LPTR, vSegCount * sizeof(USHORT)); <br>    vEndCount = (USHORT *)LocalAlloc (LPTR, vSegCount * sizeof(USHORT)); <br>    if ((vStartCount == NULL) || (vEndCount == NULL)) <br>        { <br>        MessageBox (NULL, TEXT("LocalAlloc failed"), MBERROR, MBERRORFLAGS); <br>        return FALSE; <br>        } <br> <br>    /* read in the array of endCount values */ <br>    offset = offsetFormat4 <br>           + (7 * sizeof (USHORT));  /* skip constant # bytes in subtable */ <br>    cbData = vSegCount * sizeof (USHORT); <br>    nBytes=GetFontData (hdc, CMAPHEX, offset, vEndCount, cbData ); <br>    for (i = 0; i&lt;vSegCount; i++) <br>        SwapShort (&amp; (vEndCount[i])); <br> <br>    /* read in the array of startCount values */ <br>    offset = offsetFormat4 <br>           + (7 * sizeof (USHORT))   /* skip constant # bytes in subtable */ <br>           + (vSegCount * sizeof (USHORT)) /* skip endCount array */ <br>           + sizeof (USHORT);             /* skip reservedPad */ <br>    cbData = vSegCount * sizeof (USHORT); <br>    nBytes=GetFontData (hdc, CMAPHEX, offset, vStartCount, cbData ); <br>    for (i = 0; i&lt;vSegCount; i++) <br>        SwapShort (&amp; (vStartCount[i])); <br> <br>    return TRUE; <br>} <br> <br> <br>void CFontRange::SwapShort (PUSHORT p) <br>{ <br>SHORT temp; <br> <br>    temp =(SHORT)( HIBYTE (*p) + (LOBYTE(*p) &lt;&lt; 8)); <br>    *p = temp; <br>} <br> <br> <br> <br>void CFontRange::SwapULong (PULONG p) <br>{ <br>ULONG temp; <br> <br>    temp = (LONG) ((BYTE) *p); <br>    temp &lt;&lt;= 8; <br>    *p &gt;&gt;=8; <br> <br>    temp += (LONG) ((BYTE) *p); <br>    temp &lt;&lt;= 8; <br>    *p &gt;&gt;=8; <br> <br>    temp += (LONG) ((BYTE) *p); <br>    temp &lt;&lt;= 8; <br>    *p &gt;&gt;=8; <br> <br>    temp += (LONG) ((BYTE) *p); <br>    *p = temp; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
