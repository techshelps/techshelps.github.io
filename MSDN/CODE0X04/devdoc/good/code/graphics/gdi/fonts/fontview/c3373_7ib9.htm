<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FONTVIEW.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3375"></a>FONTVIEW.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#define NOMINMAX <br>#include &lt;windows.h&gt; <br> <br>#include "FontView.H" <br> <br>#include &lt;math.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;time.h&gt; <br> <br>#if !defined (WIN32) <br>#define APIENTRY FAR PASCAL <br>typedef unsigned int UINT; <br>#define WNDPROC FARPROC <br>#define DLGPROC FARPROC <br>#endif <br> <br> <br>char szAppName[] = "FontView"; <br>char szAppTitle[] = "FontView - A Font Examination Utility"; <br> <br>BOOL bZoomed = FALSE; <br> <br>HWND    hwndMain, hwndClient; <br>HWND    hwndMenuField, hwndTimeField; <br>HWND    hwndLabel1, hwndCreateParam, hwndCreateValue, hwndZoom; <br> <br>LOGFONT lf = {0,0,0,0,0,0,0,0,0,0,0,0,0,""}; <br> <br>HMENU   hSysMenuMain = (HMENU)NULL; <br>HMENU   hFileMenu    = (HMENU)NULL; <br>HMENU   hEditMenu    = (HMENU)NULL; <br>HMENU   hViewMenu    = (HMENU)NULL; <br>HMENU   hMetricsMenu = (HMENU)NULL; <br>HMENU   hHelpMenu    = (HMENU)NULL; <br>HMENU   hSysMenuAdv  = (HMENU)NULL; <br>HMENU   hMenu        = (HMENU)NULL; <br> <br>LONG APIENTRY WndProc         (HWND, UINT, UINT, LONG); <br>LONG APIENTRY ClientProc      (HWND, UINT, UINT, LONG); <br>LONG APIENTRY ClientCharSetProc      (HWND, UINT, UINT, LONG); <br>LONG APIENTRY ClientGlyphProc      (HWND, UINT, UINT, LONG); <br> <br>BOOL FillInParam (HWND, int); <br>BOOL FillInValue (HWND, int); <br>int FAR PASCAL EnumFontNames (LPLOGFONT, LPTEXTMETRIC, short, LPINT); <br> <br>WNDPROC fpCharSetProc = 0; <br>WNDPROC fpGlyphProc = 0; <br> <br>/* Dialogs.C Prototypes */ <br>BOOL APIENTRY SimpleDlgProc   (HWND, UINT, UINT, LONG); <br>BOOL APIENTRY CreateDlgProc   (HWND, UINT, UINT, LONG); <br>BOOL APIENTRY MetricsDlgProc   (HWND, UINT, UINT, LONG); <br>BOOL APIENTRY EnumDlgProc   (HWND, UINT, UINT, LONG); <br> <br>/* Display.C Prototypes */ <br>void DrawAscii (HDC hdc, RECT *pRect, WORD direction); <br>BYTE FindChar (HDC hdc, RECT *pRect, int x, int y); <br>void DrawGlyph (HDC hdc, RECT *pRect, BYTE glyph, HFONT hfont); <br> <br>/* ToolBar.C Prototypes */ <br>BOOL InitToolBar (HANDLE); <br>BOOL CreateToolBar (HWND, HANDLE, int); <br>BOOL AdjustToolBar (HWND); <br>HWND AddToolLabel (HANDLE , int, LPSTR, int, DWORD); <br>HWND AddToolCombo (HANDLE, int, int, DWORD); <br>HWND AddToolButton (HANDLE, int, LPSTR, int, int, DWORD); <br>BOOL AddToolSpace (int, int); <br>int ToolBarHeight (HWND); <br> <br>/* StatusBar.C Prototypes */ <br>BOOL InitStatusBar (HANDLE); <br>BOOL CreateStatusBar (HWND, HANDLE, int); <br>BOOL AdjustStatusBar (HWND); <br>HWND AddStatusField (HANDLE, int, int, int, BOOL); <br>int StatusBarHeight (HWND); <br> <br> <br>int APIENTRY WinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpCmdLine, int nCmdShow) <br>{ <br> <br>    MSG         msg; <br>    WNDCLASS    wndclass; <br>    HANDLE      hAccelTable; <br> <br>    if (!hPrevInst) { <br>        wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>#if defined(WIN32) <br>        wndclass.lpfnWndProc   = (WNDPROC)WndProc; <br>#else <br>        wndclass.lpfnWndProc   = WndProc; <br>#endif <br>        wndclass.cbClsExtra    = 0; <br>        wndclass.cbWndExtra    = 0; <br>        wndclass.hInstance     = hInst; <br>        wndclass.hIcon         = LoadIcon (hInst, szAppName); <br>        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>        wndclass.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE+1); <br>        wndclass.lpszMenuName  = szAppName; <br>        wndclass.lpszClassName = szAppName; <br> <br>        if (!RegisterClass (&amp;wndclass)) { <br>            return FALSE; <br>        } <br> <br>        wndclass.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; <br>#if defined(WIN32) <br>        wndclass.lpfnWndProc   = (WNDPROC)ClientProc; <br>#else <br>        wndclass.lpfnWndProc   = ClientProc; <br>#endif <br>        wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>        wndclass.lpszMenuName  = NULL; <br>        wndclass.lpszClassName = "FontClient"; <br> <br>        if (!RegisterClass (&amp;wndclass)) { <br>            return FALSE; <br>        } <br> <br>        fpCharSetProc = MakeProcInstance ((WNDPROC)ClientCharSetProc, hInst); <br>        fpGlyphProc   = MakeProcInstance ((WNDPROC)ClientGlyphProc, hInst); <br> <br>        if (!InitToolBar (hInst)) { <br>            return FALSE; <br>        } <br> <br>        if (!InitStatusBar (hInst)) { <br>            return FALSE; <br>        } <br>    } <br> <br> <br>    hwndMain = CreateWindow (szAppName, szAppName, <br>        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>        CW_USEDEFAULT, 0, <br>        CW_USEDEFAULT, 0, <br>        NULL, NULL, hInst, NULL); <br> <br>    if (!hwndMain) { <br>        return FALSE; <br>    } <br>    /* Get handles to the various menus. Some of these we will use later */ <br>    /* to display menu descriptions in the status bar */ <br>        hSysMenuMain = GetSystemMenu(hwndMain,FALSE); <br>    hMenu = GetMenu(hwndMain); <br>    if (hMenu) { <br>        hFileMenu = GetSubMenu(hMenu,0); <br>        hEditMenu = GetSubMenu(hMenu,1); <br>        hViewMenu = GetSubMenu(hMenu, 2); <br>        hMetricsMenu = GetSubMenu(hMenu,3); <br>        hHelpMenu = GetSubMenu(hMenu,4); <br>    } <br> <br>    if (CreateToolBar (hwndMain, hInst, ID_TOOLBAR)) { <br>        hwndLabel1 = AddToolLabel (hInst, 0, "CreateFont:", 0, SS_RIGHT); <br>        AddToolSpace (6, 0); <br>        hwndCreateParam = AddToolCombo (hInst, ID_CREATEPARAM, -25, CBS_DROPDOWN | WS_VSCROLL); <br>        FillInParam (hwndCreateParam, 0); <br> <br>        AddToolSpace (10, 0); <br>        hwndCreateValue = AddToolCombo (hInst, ID_CREATEVALUE, -30, CBS_DROPDOWN | WS_VSCROLL); <br>        FillInValue (hwndCreateValue, CFP_BASE+0); <br> <br>        AddToolSpace (10, 0); <br>        hwndZoom = AddToolButton (hInst, ID_ZOOM, "ZOOM", 24, 0, BS_OWNERDRAW); <br> <br>    } else { <br>        return FALSE; <br>    } <br> <br> <br>    if (CreateStatusBar (hwndMain, hInst, ID_STATUSBAR)) { <br>        hwndMenuField = AddStatusField (hInst, ID_MENUFIELD, 100, 0, FALSE); <br>        hwndTimeField = AddStatusField (hInst, ID_TIMEFIELD, -13, -13, TRUE); <br>        if (hwndTimeField) { <br>            SetTimer (hwndMain, 1, 1000, NULL); <br>        } <br>    } else { <br>        return FALSE; <br>    } <br> <br>    hwndClient = CreateWindow ("FontClient", "FontClient", <br>        WS_CHILD | WS_CLIPSIBLINGS | WS_BORDER | WS_VISIBLE, <br>        0, 0, 0, 0, <br>        hwndMain,(HMENU)666, hInst, NULL); <br> <br>    SetWindowLong (hwndClient, GWL_WNDPROC, (DWORD)fpCharSetProc); <br>    bZoomed = FALSE; <br> <br>    if (!hwndMain) { <br>        return FALSE; <br>    } <br> <br>    ShowWindow (hwndMain, nCmdShow); <br>    InvalidateRect (hwndZoom, NULL, TRUE); <br> <br>    hAccelTable = LoadAccelerators (hInst, szAppName); <br> <br>    while (GetMessage (&amp;msg, NULL, 0, 0)) { <br>        if (!TranslateAccelerator (hwndMain, hAccelTable, &amp;msg)) { <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>        } <br>    } <br> <br> <br>    return msg.wParam; <br> <br>    lpCmdLine; // Just to resolve reference <br>} <br> <br> <br>/* ================================================================================================ *\ <br>    Fill in the first combo box with all the different 'CreateFont' parameters that we can change <br>\* ================================================================================================ */ <br>BOOL FillInParam (HWND hwnd, int focus) <br>{ <br>    int index; <br> <br>    index = 0; <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"nHeight"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_HEIGHT); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"nWidth"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_WIDTH); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"nEscapement"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_ESCAPEMENT); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"nOrientation"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_ORIENTATION); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"nWeight"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_WEIGHT); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cItalic"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_ITALIC); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cUnderline"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_UNDERLINE); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cStrikeOut"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_STRIKEOUT); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cCharSet"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_CHARSET); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cOutputPrecision"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_OUTPUTPRECISION); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cClipPrecision"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_CLIPPRECISION); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cQuality"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_QUALITY); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"cPitch..."); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_PITCH); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"c...Family"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_FAMILY); <br>    SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"lpFacename"); <br>    SendMessage (hwnd, CB_SETITEMDATA, index++, CFP_FACENAME); <br>    SendMessage (hwnd, CB_SETCURSEL, focus, 0); <br>    return TRUE; <br>} <br> <br>/* ================================================================================================ *\ <br>    Fill in the second combo box with valid values, based on the current setting in the first combo <br>\* ================================================================================================ */ <br>BOOL FillInValue (HWND hwnd, int param) <br>{ <br>    int i, index, focus; <br>    long data; <br>    char szTmp[80]; <br>    ATOM atom; <br>    HDC  hdc; <br>    FARPROC lpEnumFonts; <br>    HINSTANCE hInst; <br> <br>    SendMessage (hwnd, CB_RESETCONTENT, 0, 0); <br>    focus = -1; <br>    index = 0; <br> <br>    // Each of the following cases will contain two different 'loops', the first one will fill the <br>    // combo box with values, the second will locate the current setting in the combobox and set <br>    // the focus to it. If the value is not currently in the combobox, then it will be inserted at <br>    // the proper location. <br> <br>    switch (param) { <br>        case CFP_HEIGHT: <br>            // Lets just toss in a range of heights, from -72 to 72, by twos <br>            // If the user wants to enter in a custom value, they need to use <br>            // the 'CreateFont' dialog for now. <br>            for (i=-72; i&lt;72; i+=2) { <br>                if (i &lt; 0) { <br>                    wsprintf (szTmp, "%d = cell height = %u", i, abs(i)); <br>                } else if (i == 0) { <br>                    wsprintf (szTmp, "%u = default", i); <br>                } else { <br>                    wsprintf (szTmp, "%u = character height", i); <br>                } <br>                SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)szTmp); <br>                SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)i); <br>            } <br> <br>            for (i=0; i&lt;index; i++) { <br>                data = (long)SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == lf.lfHeight) { <br>                    focus = i; <br>                    break; <br>                } else if (data &gt; lf.lfHeight) { <br>                    wsprintf (szTmp, "%u", lf.lfHeight); <br>                    SendMessage (hwnd, CB_INSERTSTRING, i, (DWORD)(LPSTR)szTmp); <br>                    SendMessage (hwnd, CB_SETITEMDATA, i, (DWORD)lf.lfHeight); <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            if (focus == -1) { <br>                wsprintf (szTmp, "%u", lf.lfHeight); <br>                focus = (int)SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)szTmp); <br>                SendMessage (hwnd, CB_SETITEMDATA, focus, (DWORD)lf.lfHeight); <br>            } <br> <br>            break; <br> <br>        case CFP_WIDTH: <br>            // Lets just toss in a range of widths, from 0 to 72, by twos <br>            // If the user wants to enter in a custom value, they need to use <br>            // the 'CreateFont' dialog for now. <br>            for (i=0; i&lt;72; i+=2) { <br>                if (i==0) { <br>                    wsprintf (szTmp, "%u = default aspect", i); <br>                } else { <br>                    wsprintf (szTmp, "%u", i); <br>                } <br>                SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)szTmp); <br>                SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)i); <br>            } <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == lf.lfWidth) { <br>                    focus = i; <br>                    break; <br>                } else if (data &gt; lf.lfWidth) { <br>                    wsprintf (szTmp, "%u", lf.lfWidth); <br>                    SendMessage (hwnd, CB_INSERTSTRING, i, (DWORD)(LPSTR)szTmp); <br>                    SendMessage (hwnd, CB_SETITEMDATA, i, (DWORD)lf.lfWidth); <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_ESCAPEMENT: <br>            for (i=0; i&lt;4500; i+=10) { <br>                wsprintf (szTmp, "%u = (%u/10 degrees)", i, i); <br>                SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)szTmp); <br>                SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)i); <br>            } <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == lf.lfEscapement) { <br>                    focus = i; <br>                    break; <br>                } else if (data &gt; lf.lfEscapement) { <br>                    wsprintf (szTmp, "%u = (%u/10 degrees)", lf.lfWidth); <br>                    SendMessage (hwnd, CB_INSERTSTRING, i, (DWORD)(LPSTR)szTmp); <br>                    SendMessage (hwnd, CB_SETITEMDATA, i, (DWORD)lf.lfEscapement); <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_ORIENTATION: <br>            for (i=0; i&lt;4500; i+=10) { <br>                wsprintf (szTmp, "%u = (%u/10 degrees)", i, i); <br>                SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)szTmp); <br>                SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)i); <br>            } <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == lf.lfOrientation) { <br>                    focus = i; <br>                    break; <br>                } else if (data &gt; lf.lfOrientation) { <br>                    wsprintf (szTmp, "%u = (%u/10 degrees)", lf.lfWidth); <br>                    SendMessage (hwnd, CB_INSERTSTRING, i, (DWORD)(LPSTR)szTmp); <br>                    SendMessage (hwnd, CB_SETITEMDATA, i, (DWORD)lf.lfOrientation); <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_WEIGHT: <br>            index = 0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = FW_DONTCARE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 0); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"100 = FW_THIN"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 100); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"200 = FW_EXTRALIGHT"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 200); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"300 = FW_LIGHT"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 300); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"400 = FW_NORMAL"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 400); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"500 = FW_MEDIUM"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 500); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"600 = FW_SEMIBOLD"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 600); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"700 = FW_BOLD"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 700); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"800 = FW_EXTRABOLD"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 800); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"900 = FW_HEAVY"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, 900); <br> <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == lf.lfWeight) { <br>                    focus = i; <br>                    break; <br>                } else if (data &gt; lf.lfWeight) { <br>                    wsprintf (szTmp, "%u", lf.lfWeight); <br>                    SendMessage (hwnd, CB_INSERTSTRING, i, (DWORD)(LPSTR)szTmp); <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_ITALIC: <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FALSE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, 0, (DWORD)FALSE); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"TRUE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, 1, (DWORD)TRUE); <br>            focus = (lf.lfItalic?1:0); <br>            break; <br> <br>        case CFP_UNDERLINE: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FALSE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FALSE); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"TRUE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)TRUE); <br>            focus = (lf.lfUnderline?1:0); <br>            break; <br> <br>        case CFP_STRIKEOUT: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FALSE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FALSE); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"TRUE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)TRUE);  \ <br>            focus = (lf.lfStrikeOut?1:0); <br>            break; <br> <br>        case CFP_CHARSET: <br>            index = 0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = ANSI_CHARSET"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)ANSI_CHARSET); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"SYMBOL_CHARSET"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)SYMBOL_CHARSET); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"SHIFTJIS_CHARSET"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)SHIFTJIS_CHARSET); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"OEM_CHARSET"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)OEM_CHARSET); <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == (long)lf.lfCharSet) { <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>            break; <br> <br>        case CFP_OUTPUTPRECISION: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = OUT_DEFAULT_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)OUT_DEFAULT_PRECIS); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"OUT_STRING_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)OUT_STRING_PRECIS); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"OUT_CHARACTER_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)OUT_CHARACTER_PRECIS); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"OUT_STROKE_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)OUT_STROKE_PRECIS); <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == (long)lf.lfOutPrecision) { <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_CLIPPRECISION: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = CLIP_DEFAULT_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)CLIP_DEFAULT_PRECIS); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"CLIP_CHARACTER_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)CLIP_CHARACTER_PRECIS); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"CLIP_STROKE_PRECIS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)CLIP_STROKE_PRECIS); <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == (long)lf.lfClipPrecision) { <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_QUALITY: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = DEFAULT_QUALITY"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)DEFAULT_QUALITY); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"DRAFT_QUALITY"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)DRAFT_QUALITY); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"PROOF_QUALITY"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)PROOF_QUALITY); <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == (long)lf.lfQuality) { <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_PITCH: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = DEFAULT_PITCH"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)DEFAULT_PITCH); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FIXED_PITCH"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FIXED_PITCH); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"VARIABLE_PITCH"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)VARIABLE_PITCH); <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == (long)(0x03&amp;lf.lfPitchAndFamily)) { <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_FAMILY: <br>            index=0; <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"0 = FF_DONTCARE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FF_DONTCARE); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FF_ROMAN"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FF_ROMAN); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FF_SWISS"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FF_SWISS); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FF_MODERN"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FF_MODERN); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FF_SCRIPT"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FF_SCRIPT); <br>            SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"FF_DECORATIVE"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index++, (DWORD)FF_DECORATIVE); <br>            for (i=0; i&lt;index; i++) { <br>                data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                if (data == (long)(0xFC&amp;lf.lfPitchAndFamily)) { <br>                    focus = i; <br>                    break; <br>                } <br>            } <br>            break; <br> <br>        case CFP_FACENAME: <br>            index = (int)SendMessage (hwnd, CB_ADDSTRING, 0, (DWORD)(LPSTR)"(none)"); <br>            SendMessage (hwnd, CB_SETITEMDATA, index, 0); <br>            if (lstrcmp(lf.lfFaceName, "(none)") == 0) { <br>                lf.lfFaceName[0] = 0; <br>            } <br>            hdc = GetDC (hwnd); <br> <br>#if defined (WIN32) <br>            hInst = (HINSTANCE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#else <br>            hInst = (HINSTANCE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br>            lpEnumFonts = MakeProcInstance ((FARPROC)EnumFontNames, hInst); <br>            EnumFonts (hdc, NULL, (FONTENUMPROC)lpEnumFonts, (LPARAM)&amp;hwnd); <br>            FreeProcInstance (lpEnumFonts); <br>            ReleaseDC (hwnd, hdc); <br>            atom = GlobalFindAtom ((LPSTR)lf.lfFaceName); <br>            if (atom == (ATOM)0 &amp;&amp; (lstrlen (lf.lfFaceName)&gt;0)) { <br>                index = (int)SendMessage (hwnd, CB_ADDSTRING, 0, (LONG)(LPSTR)lf.lfFaceName); <br>                focus = index; <br>            } else if (lstrlen(lf.lfFaceName)==0) { <br>                index = (int)SendMessage (hwnd, CB_FINDSTRING, (UINT)-1, (LONG)(LPSTR)"(none)"); <br>                focus = index; <br>            } else { <br>                index = (int)SendMessage (hwnd, CB_GETCOUNT, 0, 0); <br>                for (i=0; i&lt;index; i++) { <br>                    data = SendMessage (hwnd, CB_GETITEMDATA, i, 0); <br>                    if ((DWORD)data == (DWORD)atom) { <br>                        focus = i; <br>                        break; <br>                    } <br>                } <br>            } <br>            break; <br>    } <br>    if (focus &gt;= 0) { <br>        SendMessage (hwnd, CB_SETCURSEL, focus, 0); <br>    } else { <br>        SendMessage (hwnd, CB_SETCURSEL, 0, 0); <br>    } <br>    return TRUE; <br>} <br> <br> <br>// Font enumeration callback. This adds the font name to the atom list. <br>int FAR PASCAL EnumFontNames (LPLOGFONT lpLogFont, LPTEXTMETRIC lpTextMetric, short nFontType, LPINT lpData) <br>{ <br>    HWND hwnd; <br>    FARPROC lpFontEnumProc; <br>    HDC  hdc; <br>    ATOM atom; <br>    HWND hwndCombo; <br>    int  index; <br> <br>    hwnd = GetFocus(); <br>    hdc  = GetDC(hwnd); <br>    hwndCombo = (HWND)*lpData; <br> <br>    atom = GlobalFindAtom ((LPSTR)lpLogFont-&gt;lfFaceName); <br>    if (atom == (ATOM)0) { <br>        atom = GlobalAddAtom (lpLogFont-&gt;lfFaceName); <br>    } <br>    if (index = SendMessage(hwndCombo, CB_FINDSTRING, (UINT)-1, (LONG)(LPSTR)lpLogFont-&gt;lfFaceName) == CB_ERR) { <br>        index = (int)SendMessage (hwndCombo, CB_ADDSTRING, 0, (LONG)(LPSTR)lpLogFont-&gt;lfFaceName); <br>        SendMessage (hwndCombo, CB_SETITEMDATA, index, atom); <br>    } <br> <br>    ReleaseDC(hwnd, hdc); <br> <br>    return TRUE; <br> <br>    lpTextMetric;   // unreferenced formal paramater <br>    nFontType;      // unreferenced formal parameter <br>    lpFontEnumProc; // unreferenced formal parameter <br>} <br> <br> <br>// A quick little routine that will center one window over another, handy for dialog boxes. <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>    RECT    rChild, rParent; <br>    int     wChild, hChild, wParent, hParent; <br>    int     wScreen, hScreen, xNew, yNew; <br>    HDC     hdc; <br> <br>    GetWindowRect (hwndChild, &amp;rChild); <br>    wChild = rChild.right - rChild.left; <br>    hChild = rChild.bottom - rChild.top; <br> <br>    GetWindowRect (hwndParent, &amp;rParent); <br>    wParent = rParent.right - rParent.left; <br>    hParent = rParent.bottom - rParent.top; <br> <br>    hdc = GetDC (hwndChild); <br>    wScreen = GetDeviceCaps (hdc, HORZRES); <br>    hScreen = GetDeviceCaps (hdc, VERTRES); <br>    ReleaseDC (hwndChild, hdc); <br> <br>    xNew = rParent.left + ((wParent - wChild) /2); <br>    if (xNew &lt; 0) { <br>        xNew = 0; <br>    } else if ((xNew+wChild) &gt; wScreen) { <br>        xNew = wScreen - wChild; <br>    } <br> <br>    yNew = rParent.top  + ((hParent - hChild) /2); <br>    if (yNew &lt; 0) { <br>        yNew = 0; <br>    } else if ((yNew+hChild) &gt; hScreen) { <br>        yNew = hScreen - hChild; <br>    } <br> <br>    return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br>LONG APIENTRY WndProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    HINSTANCE hInst; <br>    HDC hdc; <br>    PAINTSTRUCT ps; <br>    FARPROC lpDlgFunc; <br>    char    szMsg [80]; <br>    time_t  lTime; <br>    struct tm *datetime; <br> <br>#define HOUR (datetime-&gt;tm_hour) <br>#define MIN (datetime-&gt;tm_min) <br>#define SEC (datetime-&gt;tm_sec) <br> <br>    char    szTime [20]; <br>    int     index; <br>    RECT rect; <br> <br>static int  idMenuSelect; <br>    int     tmp, wmEvent, wmId; <br>    HWND    wmhWnd; <br>    POINT   point; <br>    BOOL bRedraw; <br>    int wmMenuCmd, wmFlags; <br>    HMENU wmhMenu; <br> <br>        if (hwnd) { <br>#if defined (WIN32) <br>        hInst = (HINSTANCE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#else <br>        hInst = (HINSTANCE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br>        } <br> <br>    switch (msg) { <br>    case WM_CREATE: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>            break; <br> <br>        case WM_TIMER: <br>            time (&amp;lTime); <br>            datetime = localtime (&amp;lTime); <br>            wsprintf (szTime, "%02d:%02d:%02d %s", <br>            (HOUR%12?HOUR%12:12), MIN, SEC, (LPSTR)(HOUR/12?"PM":"AM")); <br>            SetWindowText (hwndTimeField, szTime); <br>            break; <br> <br>        case WM_SIZE: <br>            AdjustToolBar (hwnd); <br>            AdjustStatusBar (hwnd); <br>            GetClientRect (hwnd, &amp;rect); <br>            rect.top += ToolBarHeight (hwnd); <br>            rect.bottom -= StatusBarHeight (hwnd); <br>            SetWindowPos (hwndClient, NULL, rect.left, rect.top, rect.right-rect.left, rect.bottom-rect.top, SWP_NOZORDER); <br>            break; <br> <br>        case WM_CHAR: <br>            switch (wParam) { </code></pre>
<p>
</p>
<pre><code>case VK_F10: <br>                    wParam = VK_MENU; <br>                    return DefWindowProc (hwnd, msg, wParam, lParam); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_PARENTNOTIFY: <br>#if defined (WIN32) <br>            wmEvent = wParam; // Same as Win16, but only on (x,y) msgs <br>#else <br>            wmEvent = wParam; <br>#endif <br>            point.x = (int)LOWORD(lParam); <br>            point.y = (int)HIWORD(lParam); <br> <br>            ClientToScreen (hwnd, &amp;point); <br>            wmhWnd  = WindowFromPoint(point); <br>            if (wmhWnd) { <br>#if defined (WIN32) <br>                wmId = GetWindowLong (wmhWnd, GWL_ID); <br>#else <br>                wmId = GetWindowWord (wmhWnd, GWW_ID); <br>#endif <br>                        } else { <br>                                break; <br>                        } <br>            switch (wmEvent) { <br>                case WM_LBUTTONDOWN: <br>                case WM_MBUTTONDOWN: <br>                case WM_RBUTTONDOWN: <br>                    if (!LoadString (hInst, (UINT)wmId, szMsg, sizeof(szMsg))) { <br>                        wsprintf ((LPSTR)szMsg, "Unable to load ParentNotify string #%u", wmId); <br>                    } <br>                    SetWindowText (hwndMenuField, szMsg); <br>                    break; <br>            } <br>            break; <br> <br>        case WM_COMMAND: <br>#if defined (WIN32) <br>            wmId = LOWORD(wParam); <br>            wmEvent = HIWORD(wParam); <br>#else <br>            wmId = wParam; <br>            wmEvent = HIWORD(lParam); <br>#endif <br> <br>            switch (wmId) { <br>                case ID_CREATEPARAM: <br> <br>                    switch (wmEvent) { <br>                        case CBN_SETFOCUS: //Indicates that the combo box has received input focus. <br>                        case CBN_DROPDOWN: //Informs the owner of the combo box that its list box is about to be dropped down. <br>                            if (!LoadString (hInst, wmId, szMsg, sizeof(szMsg))) { <br>                                wsprintf ((LPSTR)szMsg, "Unable to load FontName string #%u", wmId); <br>                            } <br>                            SetWindowText (hwndMenuField, szMsg); <br>                            break; <br> <br>                        case CBN_SELCHANGE: //Sent when the selection has been changed. <br>                            index = (int)SendMessage (hwndCreateParam, CB_GETCURSEL, 0, 0); <br>                            if (index != CB_ERR) { <br>                                SendMessage (hwndCreateParam, CB_GETLBTEXT, index, (LONG)(LPSTR)szMsg); <br>                                FillInValue (hwndCreateValue, CFP_BASE+index); <br>                            } else { <br>                                wsprintf (szMsg, "FontName: CB_ERR while retrieving text"); <br>                            } <br>                            SetWindowText (hwndMenuField, szMsg); <br>                            break; <br>                    } <br>                    break; <br> <br>                case ID_CREATEVALUE: <br>                    switch (wmEvent){ <br>                        int iCreateParam; <br>                        int iParamValue; <br> <br>                        case CBN_SETFOCUS: //Indicates that the combo box has received input focus. <br>                        case CBN_DROPDOWN: //Informs the owner of the combo box that its list box is about to be dropped down. <br>                            if (!LoadString (hInst, wmId, szMsg, sizeof(szMsg))) { <br>                                wsprintf (szMsg, "Unable to load FontSize string #%u", wmId); <br>                            } <br>                            break; <br> <br>                        case CBN_SELCHANGE: //Sent when the selection has been changed. <br>                            index = (int)SendMessage (hwndCreateValue, CB_GETCURSEL, 0, 0); <br>                            bRedraw = FALSE; <br>                            if (index != CB_ERR) { <br>                                SendMessage (hwndCreateValue, CB_GETLBTEXT, index, (LONG)(LPSTR)szMsg); <br>                                iCreateParam = <br>                                    (int)SendMessage (hwndCreateParam, CB_GETITEMDATA, <br>                                        (WORD)SendMessage (hwndCreateParam, CB_GETCURSEL, 0, (DWORD)0), <br>                                    (DWORD)0); <br>                                iParamValue = (int)SendMessage (hwndCreateValue, CB_GETITEMDATA, index, 0); <br> <br>                                switch (iCreateParam) { <br>                                    BYTE tmpByte; <br> <br>                                    case CFP_HEIGHT: <br>                                        if (lf.lfHeight != iParamValue) { <br>                                            lf.lfHeight = iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_WIDTH: <br>                                        if (lf.lfWidth != iParamValue) { <br>                                            lf.lfWidth = iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_ESCAPEMENT: <br>                                        if (lf.lfEscapement != iParamValue) { <br>                                            lf.lfEscapement= iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_ORIENTATION: <br>                                        if (lf.lfOrientation!= iParamValue) { <br>                                            lf.lfOrientation= iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_WEIGHT: <br>                                        if (lf.lfWeight != iParamValue) { <br>                                            lf.lfWeight= iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_ITALIC: <br>                                        if ((int)lf.lfItalic != iParamValue) { <br>                                            lf.lfItalic = (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_UNDERLINE: <br>                                        if (lf.lfUnderline != (BYTE)iParamValue) { <br>                                            lf.lfUnderline= (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_STRIKEOUT: <br>                                        if (lf.lfStrikeOut != (BYTE)iParamValue) { <br>                                            lf.lfStrikeOut= (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_CHARSET: <br>                                        if (lf.lfCharSet != (BYTE)iParamValue) { <br>                                            lf.lfCharSet= (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_OUTPUTPRECISION: <br>                                        if (lf.lfOutPrecision != (BYTE)iParamValue) { <br>                                            lf.lfOutPrecision = (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_CLIPPRECISION: <br>                                        if (lf.lfClipPrecision != (BYTE)iParamValue) { <br>                                            lf.lfClipPrecision = (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_QUALITY: <br>                                        if (lf.lfQuality != (BYTE)iParamValue) { <br>                                            lf.lfQuality = (BYTE)iParamValue; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_PITCH: <br>                                        tmpByte = lf.lfPitchAndFamily; <br>                                        tmpByte &amp;= 0xFC; <br>                                        tmpByte |= iParamValue; <br>                                        if (tmpByte != lf.lfPitchAndFamily) { <br>                                            lf.lfPitchAndFamily = tmpByte; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_FAMILY: <br>                                        tmpByte = lf.lfPitchAndFamily; <br>                                        tmpByte &amp;= 0x03; <br>                                        tmpByte |= iParamValue; <br>                                        if (tmpByte != lf.lfPitchAndFamily) { <br>                                            lf.lfPitchAndFamily = tmpByte; <br>                                            bRedraw = TRUE; <br>                                        } <br>                                        break; <br> <br>                                    case CFP_FACENAME: <br>                                        if (lstrcmp (lf.lfFaceName, szMsg)!=0) { <br>                                            if (lstrcmp(lf.lfFaceName, "(none)") == 0) { <br>                                                lf.lfFaceName[0] = 0; <br>                                            } else { <br>                                                wsprintf (lf.lfFaceName, "%s",(LPSTR)szMsg); <br>                                                bRedraw = TRUE; <br>                                            } <br>                                        } <br>                                        break; <br>                                } <br>                            } else { <br>                                wsprintf (szMsg, "CreateValue: CB_ERR while retrieving text"); <br>                            } <br>                            if (bRedraw) { <br>                                InvalidateRect (hwndClient, NULL, TRUE); <br>                            } <br>                            SetWindowText (hwndMenuField, szMsg); <br>                            break; <br>                    } <br>                    break; <br> <br>                // The Menu Selections <br>                case IDM_NEW: <br>                case IDM_OPEN: <br>                case IDM_CLOSE: <br>                case IDM_SAVE: <br>                case IDM_SAVEAS: <br>                case IDM_PRINT: <br>                case IDM_PRINTSET: <br>                    SetWindowText (hwndMenuField, "This command is not yet implemented."); <br>                    break; <br> <br>                case IDM_EXIT: <br>                    DestroyWindow(hwnd); <br>                    break; <br> <br>                case IDM_UNDO: <br>                case IDM_CUT: <br>                case IDM_COPY: <br>                case IDM_PASTE: <br>                case IDM_DELETE: <br>                case IDM_FIND: <br>                case IDM_REPLACE: <br>                    SetWindowText (hwndMenuField, "This command is not yet implemented."); <br>                    break; <br> <br> <br>                                case ID_ZOOM: <br>                                        if (bZoomed) { <br>                        SetWindowLong (hwndClient, GWL_WNDPROC, (LONG)fpCharSetProc); <br>                        bZoomed = FALSE; <br>                    } else { <br>                        SetWindowLong (hwndClient, GWL_WNDPROC, (LONG)fpGlyphProc); <br>                        bZoomed = TRUE; <br>                    } <br>                    InvalidateRect (hwndClient, NULL, TRUE); <br>                    break; <br> <br>                case IDM_CHARSET: // Display the full characater set <br>                    SetWindowLong (hwndClient, GWL_WNDPROC, (LONG)fpCharSetProc); <br>                    InvalidateRect (hwndClient, NULL, TRUE); <br>                    bZoomed = FALSE; <br>                    break; <br> <br>                case IDM_GLYPH: // Display a single glyph from the font <br>                    SetWindowLong (hwndClient, GWL_WNDPROC, (LONG)fpGlyphProc); <br>                    InvalidateRect (hwndClient, NULL, TRUE); <br>                    bZoomed = TRUE; <br>                    break; <br> <br>                    break; <br> <br>                case IDM_TOOLBAR: // This would hide the tool bar <br>                    SetWindowText (hwndMenuField, "This command is not yet implemented."); <br>                    break; <br> <br>                case IDM_STATUSBAR: // This would hide the status bar <br>                    SetWindowText (hwndMenuField, "This command is not yet implemented."); <br>                    break; <br> <br>                case IDM_CREATEFONT: <br>                    lpDlgFunc = MakeProcInstance((FARPROC) CreateDlgProc, hInst); <br>                    DialogBoxParam(hInst, "CreateFont", hwnd, (DLGPROC)lpDlgFunc, (DWORD)(LPLOGFONT)&amp;lf); <br>                    FreeProcInstance(lpDlgFunc); <br>                    index = (int)SendMessage (hwndCreateParam, CB_GETCURSEL, 0, 0); <br>                    if (index != CB_ERR) { <br>                        FillInValue (hwndCreateValue, CFP_BASE+index); <br>                    } else { <br>                        wsprintf (szMsg, "CreateFont: CB_ERR while setting values"); <br>                    } <br>                    InvalidateRect (hwndClient, NULL, TRUE); <br> <br>                    break; <br> <br>                case IDM_TEXTMETRIC: <br>                    lpDlgFunc = MakeProcInstance((FARPROC) MetricsDlgProc, hInst); <br>                    DialogBoxParam(hInst, "TextMetric", hwnd, (DLGPROC)lpDlgFunc, (DWORD)(LPLOGFONT)&amp;lf); <br>                    FreeProcInstance(lpDlgFunc); <br>                    index = (int)SendMessage (hwndCreateParam, CB_GETCURSEL, 0, 0); <br>                    if (index != CB_ERR) { <br>                        FillInValue (hwndCreateValue, CFP_BASE+index); <br>                    } else { <br>                        wsprintf (szMsg, "CreateFont: CB_ERR while setting values"); <br>                    } <br>                    InvalidateRect (hwndClient, NULL, TRUE); <br>                    break; <br> <br>                case IDM_ENUMFONTS: <br>                    lpDlgFunc = MakeProcInstance((FARPROC) EnumDlgProc, hInst); <br>                    DialogBoxParam(hInst, "EnumFonts", hwnd, (DLGPROC)lpDlgFunc, (DWORD)(LPLOGFONT)&amp;lf); <br>                    FreeProcInstance(lpDlgFunc); <br>                    index = (int)SendMessage (hwndCreateParam, CB_GETCURSEL, 0, 0); <br>                    if (index != CB_ERR) { <br>                        FillInValue (hwndCreateValue, CFP_BASE+index); <br>                    } else { <br>                        wsprintf (szMsg, "CreateFont: CB_ERR while setting values"); <br>                    } <br>                    InvalidateRect (hwndClient, NULL, TRUE); <br>                    break; <br> <br>                case IDM_OUTLINEMETRICS: <br>                    SetWindowText (hwndMenuField, "This command is not yet implemented."); <br>                    break; <br> <br>                case IDM_HELP_CONTENTS: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"CONTENTS"); <br>                    break; <br>                case IDM_HELP_INDEX: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"INDEX"); <br>                    break; <br>                case IDM_HELP_OVERVIEW: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"OVERVIEW"); <br>                    break; <br>                case IDM_HELP_GLOSSARY: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"GLOSSARY"); <br>                    break; <br>                case IDM_HELP_TUTORIAL: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"TUTORIAL"); <br>                    break; <br>                case IDM_HELP_DEMO: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"DEMO"); <br>                    break; <br>                case IDM_HELP_HELP: <br>                    WinHelp (hwnd, "FontView.HLP", HELP_KEY, (DWORD)(LPSTR)"HELP"); <br>                    break; <br> <br>                case IDM_ABOUT: <br>                    lpDlgFunc = MakeProcInstance((FARPROC) SimpleDlgProc, hInst); <br>                    DialogBox(hInst, <br>                        (wmId==IDM_ABOUT)?"FONTVIEW":"UsageBox", <br>                        hwnd, <br>                        (DLGPROC)lpDlgFunc); <br>                    FreeProcInstance(lpDlgFunc); <br>                    break; <br> <br> <br> <br>            } <br>            break; <br> <br>    case WM_PAINT: <br>        hdc = BeginPaint (hwnd, &amp;ps); <br>        EndPaint (hwnd, &amp;ps); <br>        break; <br> <br>    case WM_MENUSELECT: <br>        /* A menu item is hilited, get description text for status bar */ <br>        tmp = idMenuSelect; <br> <br>#if defined (WIN32) <br>        wmMenuCmd = LOWORD(wParam); <br>        wmFlags = HIWORD(wParam); <br>        wmhMenu = (HMENU)lParam; <br>#else <br>        wmMenuCmd =  wParam; <br>        wmFlags = LOWORD(lParam); <br>        wmhMenu = (HMENU)HIWORD(lParam); <br>#endif <br> <br>        if((wmhMenu == 0) &amp;&amp; (wmFlags = -1)) { <br>                tmp = idMenuSelect = 0; <br>                SetWindowText(hwndMenuField, "Ready..."); <br>        } else if(wmhMenu == 0) { <br>            /* don't do anything for this */ <br>        } else if(wmFlags &amp; MF_POPUP) { <br>            if((HMENU)wmMenuCmd == hSysMenuMain) <br>                    idMenuSelect = IDM_SYSMENU; <br>            else if((HMENU)wmMenuCmd == hFileMenu) <br>                    idMenuSelect = IDM_FILE; <br>            else if((HMENU)wmMenuCmd == hEditMenu) <br>                    idMenuSelect = IDM_EDIT; <br>            else if((HMENU)wmMenuCmd == hViewMenu) <br>                    idMenuSelect = IDM_VIEW; <br>            else if((HMENU)wmMenuCmd == hMetricsMenu) <br>                    idMenuSelect = IDM_DIALOG; <br>            else if((HMENU)wmMenuCmd == hHelpMenu) <br>                    idMenuSelect = IDM_HELP; <br>        } else { <br>            if(wmMenuCmd != 0) {            /* separators have wparam of 0 */ <br>                idMenuSelect = wmMenuCmd; <br>            } <br>        } <br> <br>        if (idMenuSelect != tmp) { <br>            if (!LoadString ( hInst, (int)idMenuSelect, szMsg, sizeof(szMsg))) { <br>                wsprintf ((LPSTR)szMsg, "Unable to load menu string #%u", idMenuSelect); <br>            } <br>            SetWindowText (hwndMenuField, szMsg); <br>        } <br>        break; <br> <br>        case WM_QUERYENDSESSION: <br>            return (MessageBox (GetFocus(), "Exit Application?", szAppTitle, <br>                MB_ICONQUESTION | MB_YESNO) == IDYES); <br> <br>        case WM_DESTROY: <br>            if (hwnd == hwndMain) { <br>                PostQuitMessage (0); <br>            } <br>            break; <br> <br>        default: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>    } <br>    return 0L; <br>} <br> <br>LONG APIENTRY ClientProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    switch (msg) { <br>        default: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>    } <br>    return 0L; <br>} <br> <br> <br>LONG APIENTRY ClientCharSetProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    HINSTANCE hInst; <br>    PAINTSTRUCT ps; <br>    HFONT hfont, hfontPrev; <br>    RECT rect; <br>    HDC hdc; <br>    int x, y; <br>    BYTE glyph; <br> <br>        if (hwnd) { <br>#if defined (WIN32) <br>        hInst = (HINSTANCE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#else <br>        hInst = (HINSTANCE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br>        } <br>    switch (msg) { <br>        case WM_PAINT: <br>            hdc = BeginPaint (hwnd, &amp;ps); <br>            hfont = CreateFontIndirect (&amp;lf); <br>            hfontPrev = SelectObject (hdc, hfont); <br>            GetClientRect (hwnd, &amp;rect); <br>            DrawAscii (hdc, &amp;rect, 0); <br>            SelectObject (hdc, hfontPrev); <br>            DeleteObject (hfont); <br>            EndPaint (hwnd, &amp;ps); <br>            break; <br> <br>        case WM_LBUTTONDBLCLK: <br>            x = LOWORD(lParam); <br>            y = HIWORD(lParam); <br>            //OutputDebugString ("WM_LBUTTONDOWN\n\r"); <br>            hdc = GetWindowDC (hwnd); <br>            hfont = CreateFontIndirect (&amp;lf); <br>            hfontPrev = SelectObject (hdc, hfont); <br>            GetClientRect (hwnd, &amp;rect); <br> <br>            glyph = FindChar (hdc, &amp;rect, x, y); <br>            if (glyph) { <br>                SetWindowLong (hwndClient, GWL_WNDPROC, (LONG)fpGlyphProc); <br>                bZoomed = TRUE; <br>                SendMessage (hwndClient, WM_USER, (UINT)glyph, 0); <br>                InvalidateRect (hwndClient, NULL, TRUE); <br>            } <br> <br>            SelectObject (hdc, hfontPrev); <br>            DeleteObject (hfont); <br>            ReleaseDC (hwnd, hdc); <br>            break; <br> <br> <br>        default: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>    } <br>    return 0L; <br>} <br> <br>LONG APIENTRY ClientGlyphProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    HINSTANCE hInst; <br>    PAINTSTRUCT ps; <br>    HFONT hfont, hfontPrev; <br>    RECT rect; <br>    HDC hdc; <br>    TEXTMETRIC tm; <br>    static BYTE glyph = 'A'; <br> <br>        if (hwnd) { <br>#if defined (WIN32) <br>        hInst = (HINSTANCE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#else <br>        hInst = (HINSTANCE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br>        } <br> <br>    switch (msg) { <br>        case WM_LBUTTONDBLCLK: <br>        case WM_LBUTTONDOWN: <br>            glyph--; <br>            InvalidateRect (hwnd, NULL, TRUE); <br>            break; <br> <br>        case WM_RBUTTONDBLCLK: <br>        case WM_RBUTTONDOWN: <br>            glyph++; <br>            InvalidateRect (hwnd, NULL, TRUE); <br>            break; <br> <br>        case WM_USER: <br>            glyph = (BYTE)wParam; <br>            break; <br> <br>        case WM_PAINT: <br>            hdc = BeginPaint (hwnd, &amp;ps); <br>            hfont = CreateFontIndirect (&amp;lf); <br>            hfontPrev = SelectObject (hdc, hfont); <br>            GetClientRect (hwnd, &amp;rect); <br> <br>            GetTextMetrics (hdc, &amp;tm); <br>            if (glyph &lt; tm.tmFirstChar) { <br>                MessageBeep (0); <br>                glyph = tm.tmFirstChar; <br>            } <br>            if (glyph &gt; tm.tmLastChar) { <br>                MessageBeep(0); <br>                glyph = tm.tmLastChar; <br>            } <br> <br>            DrawGlyph (hdc, &amp;rect, glyph, hfont); <br>            SelectObject (hdc, hfontPrev); <br>            DeleteObject (hfont); <br>            EndPaint (hwnd, &amp;ps); <br>            break; <br> <br>        default: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>    } <br>    return 0L; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
