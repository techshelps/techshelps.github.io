<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TOOLS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3379"></a>TOOLS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#define NOMINMAX <br>#include &lt;windows.h&gt; <br> <br>#include &lt;stdlib.h&gt; // For 'abs' <br> <br>#if !defined (APIENTRY) <br>#define APIENTRY FAR PASCAL <br>#endif <br> <br>HWND    hwndTools, hwndToolText, hwndToolCombo, hwndToolButton, hwndMain; <br>HFONT   hfontTools=0; <br>TEXTMETRIC tmToolFont; <br>int     dyTools = 0, cxToolBorder, cyToolBorder, cntToolCtrls = 0, dyCombo; <br>int     xCurrent = 10; <br>HBRUSH  hbrBtnFace=0, hbrWindow=0; <br>HANDLE  hInst=0; <br> <br>#define MAXCTRLS 25 <br>#define TC_SPACE 0 <br>#define TC_LABEL 1 <br>#define TC_COMBO 2 <br>#define TC_BUTTON 3 <br>typedef struct _tagTools { <br>                        HWND    hwnd; <br>                        WORD    wType; <br>                        int     iWidth, iHeight; <br>                        HICON   hIcon; <br>                } Tools; <br>Tools  toolCtrl[MAXCTRLS]; <br> <br>LONG APIENTRY ToolsProc       (HWND, UINT, UINT, LONG); <br>LONG APIENTRY MyComboProc     (HWND, UINT, UINT, LONG); <br> <br>BOOL InitToolBar (HANDLE hInstance) <br>{ <br>        WNDCLASS    wndclass; <br> <br>        hbrBtnFace = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>        hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br> <br>        wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>        wndclass.lpfnWndProc   = (WNDPROC)ToolsProc; <br>        wndclass.cbClsExtra    = 0; <br>        wndclass.cbWndExtra    = 0; <br>        wndclass.hInstance      = hInstance; <br>        wndclass.hIcon     = NULL; <br>        wndclass.hbrBackground = hbrBtnFace; <br>        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>        wndclass.lpszMenuName  = NULL; <br>        wndclass.lpszClassName = "SamplerTools"; <br> <br>        if (!RegisterClass (&amp;wndclass)) <br>                return FALSE; <br>} <br> <br>BOOL CreateToolBar (HWND hwnd, HANDLE hInstance, int iId) <br>{ <br>        HWND hwndTmp; <br>        RECT rect; <br> <br>#if defined (WIN32) <br>        hInst = (HANDLE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#else <br>        hInst = GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br> <br>        if (hbrBtnFace==0) { <br>                hbrBtnFace = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>        } <br>        if (hbrWindow==0) { <br>                hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        } <br> <br> <br>        cxToolBorder = GetSystemMetrics (SM_CXBORDER); <br>        cyToolBorder = GetSystemMetrics (SM_CYBORDER); <br> <br>        hwndTools = CreateWindow ("SamplerTools", "SamplerTools", <br>                WS_CHILD | WS_CLIPSIBLINGS | WS_BORDER | WS_VISIBLE, <br>                0, 0, 0, 0, <br>        hwnd, (HMENU)iId, hInst, NULL); <br>        if (!hwndTools) { <br>                return FALSE; <br>        } <br> <br>        /* Lets find out how big a combo box is... */ <br>        hwndTmp = CreateWindow ("COMBOBOX", "Combo", <br>                        WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST, <br>                        0, 0, 0, 0, <br>                        hwndTools, NULL, hInst, NULL); <br>        if (hwndTmp) { <br>                SendMessage (hwndTmp, WM_SETFONT, (UINT)hfontTools, MAKELONG (TRUE, 0)); <br>                GetClientRect (hwndTmp, &amp;rect); <br>                dyCombo = rect.bottom - rect.top; <br>                DestroyWindow (hwndTmp); <br>        } else { <br>                dyCombo = 30; // Just for a default value <br>        } <br> <br>        hwndMain = hwnd; // So we can pass WM_CONTROL messages back to the master parent <br> <br>        return TRUE; <br> <br>        hInstance; // unreferenced formal parameter <br>} <br> <br>int ToolBarHeight (HWND hwnd) <br>{ <br>        RECT rect; <br>        GetClientRect (hwndTools, &amp;rect); <br>        return rect.bottom-rect.top; <br> <br>        hwnd; //unreferenced formal parameter <br>} <br> <br>BOOL AdjustToolBar (HWND hwnd) <br>{ <br>        RECT rect; <br> <br>        GetClientRect (hwnd, &amp;rect); <br>        MoveWindow (hwndTools, <br>                rect.left-cxToolBorder, <br>                rect.top - cyToolBorder, <br>                rect.right - rect.left + (cxToolBorder*2), <br>                dyTools, <br>                TRUE); <br>        return TRUE; <br>} <br> <br>void UpdatePositions (void) <br>{ <br>        int i, x, y, dx, dy, cnt; <br> <br>        x = 10; <br>        for (i=0; i&lt;cntToolCtrls; i++) { <br>                switch (toolCtrl[i].wType) { <br>                        case TC_SPACE: <br>                                dx = toolCtrl[i].iWidth; <br>                                break; <br>                        case TC_LABEL: <br>                                dy = toolCtrl[i].iHeight; <br>                                y = (dyTools/2) - (dy/2) - 1; <br>                                dx = toolCtrl[i].iWidth; <br>                                break; <br>                        case TC_COMBO: <br>                                dy = toolCtrl[i].iHeight; <br>                                y = (dyTools/2) - (dy/2) - 1; <br>                                dx = toolCtrl[i].iWidth; <br>                                cnt = (int)SendMessage (toolCtrl[i].hwnd, CB_GETCOUNT, (UINT)0, (LONG)0); <br>                                if (cnt &gt; 5) cnt = 5; <br>                                dy = dy * cnt; <br>                                break; <br>                        case TC_BUTTON: <br>                                dy = toolCtrl[i].iHeight; <br>                                y = (dyTools/2) - (dy/2) - 1; <br>                                dx = toolCtrl[i].iWidth; <br>                                break; <br>                        default: <br>                                dy = toolCtrl[i].iHeight; <br>                                y = (dyTools/2) - (dy/2) - 1; <br>                                dx = toolCtrl[i].iWidth; <br>                                break; <br>                } <br>                if (toolCtrl[i].wType != TC_SPACE) { <br>                        MoveWindow (toolCtrl[i].hwnd, x, y, dx, dy, FALSE); <br>                } <br>                x += dx; <br>        } <br>        if (hwndTools) { <br>                UpdateWindow (hwndTools); <br>        } <br>} <br> <br>BOOL AddToolSpace (int iWidth, int iHeight) <br>{ <br>        if (cntToolCtrls &gt;= MAXCTRLS) return FALSE; <br>        toolCtrl[cntToolCtrls].hwnd = 0; <br>        toolCtrl[cntToolCtrls].wType = TC_SPACE; <br>        toolCtrl[cntToolCtrls].iWidth = iWidth; <br>        toolCtrl[cntToolCtrls].iHeight = iHeight; <br>        if ((toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)) &gt; dyTools) { <br>                dyTools = (toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)); <br>        } <br>        UpdatePositions(); <br>        cntToolCtrls++; <br>        return TRUE; <br>} <br> <br>HWND AddToolLabel (HANDLE hInst, int iId, LPSTR szLabel, int iWidth, DWORD dwStyle) <br>{ <br>        HDC hdc; <br> <br>        if (cntToolCtrls &gt;= MAXCTRLS) return (HWND)0; // No room left in our fixed array <br> <br>        toolCtrl[cntToolCtrls].hwnd = CreateWindow ("STATIC", szLabel, <br>                WS_CHILD | WS_VISIBLE | dwStyle, <br>                0, 0, 0, 0, <br>                hwndTools, (HMENU)iId, hInst, NULL); <br> <br>        if (!toolCtrl[cntToolCtrls].hwnd) return (HWND)0; // CreateWindow failed for some reason <br> <br>        SendMessage (toolCtrl[cntToolCtrls].hwnd, WM_SETFONT, (UINT)hfontTools, MAKELONG (TRUE, 0)); <br>        toolCtrl[cntToolCtrls].wType = TC_LABEL; <br> <br>        hdc = GetDC (hwndTools); <br>        if (iWidth &lt; 0) { <br>                toolCtrl[cntToolCtrls].iWidth = tmToolFont.tmAveCharWidth * abs(iWidth); <br>        } else if (iWidth == 0) { <br>#if defined (WIN32) <br>                SIZE size; <br>                GetTextExtentPoint (hdc, szLabel, lstrlen(szLabel), &amp;size); <br>                toolCtrl[cntToolCtrls].iWidth = size.cx; <br>#else <br>                toolCtrl[cntToolCtrls].iWidth = LOWORD(GetTextExtent (hdc, szLabel, lstrlen(szLabel))); <br>#endif <br>        } else { <br>                toolCtrl[cntToolCtrls].iWidth = iWidth; <br>        } <br>        toolCtrl[cntToolCtrls].iHeight = tmToolFont.tmHeight; <br> <br>        if ((toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)) &gt; dyTools) { <br>                dyTools = (toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)); <br>        } <br> <br>        ReleaseDC (hwndTools, hdc); <br>        UpdatePositions(); <br>        return toolCtrl[cntToolCtrls++].hwnd; <br>} <br> <br>HWND AddToolCombo (HANDLE hInst, int iId, int iWidth, DWORD dwStyle) <br>{ <br> <br>        if (cntToolCtrls &gt;= MAXCTRLS) return (HWND)0; // No room left in our fixed array <br> <br>        if (dwStyle==0) dwStyle = CBS_DROPDOWNLIST; <br>        toolCtrl[cntToolCtrls].hwnd = CreateWindow ("COMBOBOX", "", <br>                WS_CHILD | WS_VISIBLE | dwStyle, <br>                0, 0, 0, 0, <br>                hwndTools, (HMENU)iId, hInst, NULL); <br> <br>        if (!toolCtrl[cntToolCtrls].hwnd) return (HWND)0; // CreateWindow failed for some reason <br> <br>        SendMessage (toolCtrl[cntToolCtrls].hwnd, WM_SETFONT, (UINT)hfontTools, MAKELONG (TRUE, 0)); <br>        toolCtrl[cntToolCtrls].wType = TC_COMBO; <br> <br>        if (iWidth &lt; 0) { <br>                toolCtrl[cntToolCtrls].iWidth = tmToolFont.tmAveCharWidth * abs(iWidth); <br>        } else if (iWidth == 0) { <br>                toolCtrl[cntToolCtrls].iWidth = tmToolFont.tmAveCharWidth * 15; // just a default width <br>        } else { <br>                toolCtrl[cntToolCtrls].iWidth = iWidth; <br>        } <br>        toolCtrl[cntToolCtrls].iHeight = dyCombo; <br> <br>        if ((toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)) &gt; dyTools) { <br>                dyTools = (toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)); <br>        } <br> <br>        UpdatePositions(); <br>        return toolCtrl[cntToolCtrls++].hwnd; <br>} <br> <br> <br>HWND AddToolButton (HANDLE hInst, int iId, LPSTR szLabel, int iWidth, int iHeight, DWORD dwStyle) <br>{ <br>        HDC hdc; <br> <br>        if (cntToolCtrls &gt;= MAXCTRLS) return (HWND)0; // No room left in our fixed array <br> <br>        if (dwStyle == 0) dwStyle = BS_PUSHBUTTON; <br>        toolCtrl[cntToolCtrls].hwnd = CreateWindow ("BUTTON", szLabel, <br>                WS_CHILD | WS_VISIBLE | dwStyle, <br>                0, 0, 0, 0, <br>                hwndTools, (HMENU)iId, hInst, NULL); <br> <br>        if (!toolCtrl[cntToolCtrls].hwnd) return (HWND)0; // CreateWindow failed for some reason <br> <br>        SendMessage (toolCtrl[cntToolCtrls].hwnd, WM_SETFONT, (UINT)hfontTools, MAKELONG (TRUE, 0)); <br>        toolCtrl[cntToolCtrls].wType = TC_BUTTON; <br> <br>        hdc = GetDC (hwndTools); <br>        SelectObject (hdc, hfontTools); <br>        if (iWidth &lt; 0) { <br>                toolCtrl[cntToolCtrls].iWidth = tmToolFont.tmAveCharWidth * abs(iWidth); <br>                toolCtrl[cntToolCtrls].iWidth += (6*cxToolBorder); <br>        } else if (iWidth == 0) { <br>#if defined (WIN32) <br>                SIZE size; <br>                GetTextExtentPoint (hdc, szLabel, lstrlen(szLabel), &amp;size); <br>                toolCtrl[cntToolCtrls].iWidth = size.cx; <br>#else <br>                toolCtrl[cntToolCtrls].iWidth = LOWORD(GetTextExtent (hdc, szLabel, lstrlen(szLabel))); <br>#endif <br>                toolCtrl[cntToolCtrls].iWidth += (6*cxToolBorder); <br>        } else { <br>                toolCtrl[cntToolCtrls].iWidth = iWidth; <br>        } <br>        if (iHeight &lt; 0) { <br>                toolCtrl[cntToolCtrls].iHeight = tmToolFont.tmHeight; <br>                toolCtrl[cntToolCtrls].iHeight += (6*cyToolBorder); <br>        } else if (iHeight==0) { <br>                toolCtrl[cntToolCtrls].iHeight = dyTools - (6*cyToolBorder); <br>        } else { <br>                toolCtrl[cntToolCtrls].iHeight = iHeight; <br>        } <br> <br>        if ((toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)) &gt; dyTools) { <br>                dyTools = (toolCtrl[cntToolCtrls].iHeight + (6*cyToolBorder)); <br>        } <br> <br>        if (dwStyle &amp; BS_OWNERDRAW) { <br>                toolCtrl[cntToolCtrls].hIcon = LoadIcon (hInst, szLabel); <br>        } else { <br>                toolCtrl[cntToolCtrls].hIcon = NULL; <br>        } <br> <br>        ReleaseDC (hwndTools, hdc); <br>        UpdatePositions(); <br>        return toolCtrl[cntToolCtrls++].hwnd; <br>} <br> <br> <br>BOOL DestroyToolBar (void) <br>{ <br>        return DeleteObject (hbrBtnFace); <br>} <br> <br>void DrawButton (HDC hdc, RECT rect, BOOL bDown, HICON hIcon) <br>{ <br>        HBRUSH  hBrush, hbrFrame, hbrFace, hbrHilite, hbrShadow; <br>        RECT    border; <br>        int     i; <br> <br>        hbrFrame = CreateSolidBrush(GetSysColor(COLOR_WINDOWFRAME)); <br>        hbrFace = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>        hbrHilite = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>        hbrShadow = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br> <br>        FillRect (hdc, &amp;rect, hbrFace); <br> <br>        if (hIcon) { <br>                if (bDown) { <br>                        DrawIcon (hdc, rect.left + (4*cyToolBorder), rect.top + (4*cyToolBorder), hIcon); <br>                } else { <br>                        DrawIcon (hdc, rect.left + (3*cyToolBorder), rect.top + (3*cyToolBorder), hIcon); <br>                } <br>        } <br> <br>        hBrush = hbrFrame; <br>        border = rect; border.bottom = border.top + cyToolBorder; <br>        FillRect (hdc, &amp;border, hBrush); <br>        border = rect; border.right = border.left + cxToolBorder; <br>        FillRect (hdc, &amp;border, hBrush); <br>        border = rect; border.top = border.bottom - cyToolBorder; <br>        FillRect (hdc, &amp;border, hBrush); <br>        border = rect; border.left = border.right - cxToolBorder; <br>        FillRect (hdc, &amp;border, hBrush); <br> <br>        for (i= 0; i&lt;2; i++) { <br>                InflateRect (&amp;rect, -cxToolBorder, -cyToolBorder); <br>                hBrush = (bDown?hbrShadow:hbrHilite); <br>                border = rect; border.bottom = border.top + cyToolBorder; <br>                FillRect (hdc, &amp;border, hBrush); <br>                border = rect; border.right = border.left + cxToolBorder; <br>                FillRect (hdc, &amp;border, hBrush); <br>                if (!bDown) { <br>                        hBrush = hbrShadow; <br>                        border = rect; border.top = border.bottom - cyToolBorder; <br>                        FillRect (hdc, &amp;border, hBrush); <br>                        border = rect; border.left = border.right - cxToolBorder; <br>                        FillRect (hdc, &amp;border, hBrush); <br>                } <br>        } <br> <br>        DeleteObject (hbrFrame); <br>        DeleteObject (hbrFace); <br>        DeleteObject (hbrHilite); <br>        DeleteObject (hbrShadow); <br> <br>} <br> <br> <br>LONG APIENTRY ToolsProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>        HDC          hdc; <br>        PAINTSTRUCT      ps; <br>        int          iType, idCtrl, msgCtrl, i; <br>        RECT         rect, border; <br>        COLORREF         clrColor; <br>        HWND         hwndCtl; <br>        LONG         lStyle; <br>        HBRUSH       hBrush; <br>        LPDRAWITEMSTRUCT lpdi; <br>        HICON        hIcon; <br>        LOGFONT     lfTmp ={0,0,0,0,0,0,0,0,0,0,0,0,0,0}; <br> <br>        switch (msg) { <br>                case WM_CREATE: <br>                        lfTmp.lfHeight = 14; <br>                        lfTmp.lfPitchAndFamily = VARIABLE_PITCH | FF_SWISS; <br>                        hfontTools = CreateFontIndirect (&amp;lfTmp); <br>                        if (!hfontTools) { <br>                                MessageBox (GetFocus(), <br>                                        "Unable to get an unnamed variable pitch swiss font",  <br>                                        "Tool Bar CreateFont Error", <br>                                         MB_OK); <br>                                hfontTools = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, <br>                                        0, 0, 0, 0, <br>                                        VARIABLE_PITCH | FF_SWISS, "Arial"); <br>                        } <br> <br>                        if (!hfontTools) { <br>                                MessageBox (GetFocus(), "Failed To Create Font", "StatusProc", MB_OK); <br>                        } <br>                        hdc = GetDC (hwnd); <br>                        SelectObject (hdc, hfontTools); <br>                        GetTextMetrics (hdc, &amp;tmToolFont); <br>                        ReleaseDC (hwnd, hdc); <br>                        return DefWindowProc (hwnd, msg, wParam, lParam); <br> <br>                case WM_DESTROY: <br>                        if (hfontTools) { <br>                                DeleteObject (hfontTools); <br>                        } <br>                        break; <br> <br>                case WM_SIZE: <br>                        UpdatePositions(); <br>                        break; <br> <br>#if defined (WIN32) <br>                case WM_CTLCOLORLISTBOX: <br>                case WM_CTLCOLOREDIT: <br>                case WM_CTLCOLORSTATIC: <br>                case WM_CTLCOLORBTN: <br>                case WM_CTLCOLORDLG: <br>                case WM_CTLCOLORMSGBOX: <br>                case WM_CTLCOLORSCROLLBAR: <br>                        iType   = msg - WM_CTLCOLORMSGBOX; <br>                        hdc     = (HDC)wParam; <br>                        hwndCtl = (HWND)lParam; <br>#else <br>                case WM_CTLCOLOR: <br>                        hdc = wParam; <br>                        hwndCtl = LOWORD(lParam); <br>                        iType = HIWORD (lParam); <br>#endif <br>                        switch (iType) { <br>                                case CTLCOLOR_EDIT: //Edit control <br>                                        clrColor = GetSysColor (COLOR_BTNFACE); <br>                                        hBrush = hbrWindow; <br>                                        break; <br> <br>                                case CTLCOLOR_LISTBOX: //List-box control <br>                                        lStyle = GetWindowLong (hwndCtl, GWL_STYLE); <br>                                        if (lStyle &amp; CBS_SIMPLE) { <br>                                                clrColor = GetSysColor (COLOR_WINDOW); <br>                                                hBrush = hbrWindow; <br>                                        } else { <br>                                                clrColor = GetSysColor (COLOR_BTNFACE); <br>                                                hBrush = hbrBtnFace; <br>                                        } <br>                                        break; <br> <br>                                case CTLCOLOR_STATIC: <br>                                        clrColor = GetSysColor (COLOR_BTNFACE); <br>                                        hBrush = hbrBtnFace; <br>                                        break; <br> <br>                                case CTLCOLOR_BTN: <br>                                        clrColor = GetSysColor (COLOR_BTNFACE); <br>                                        hBrush = hbrBtnFace; <br>                                        break; <br> <br>                                case CTLCOLOR_SCROLLBAR: <br>                                case CTLCOLOR_DLG: <br>                                case CTLCOLOR_MSGBOX: <br>                                default: <br>                                        return DefWindowProc (hwnd, msg, wParam, lParam); <br>                        } <br>                        SetBkColor(hdc, clrColor); <br>                return (LONG)hBrush; <br> <br>                case WM_PAINT: <br>                        hdc = BeginPaint (hwnd, &amp;ps); <br>                        GetClientRect (hwnd, &amp;rect); <br> <br>                        /* Shade the top of the bar white */ <br>                        hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>                        border = rect; <br>                        border.bottom = border.top + cyToolBorder; <br>                        FillRect (hdc, &amp;border, hBrush); <br>                        DeleteObject (hBrush); <br> <br>                        /* Shade the bottom of the bar dark gray */ <br>                        hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br>                        border = rect; <br>                        border.top = border.bottom - cyToolBorder; <br>                        FillRect (hdc, &amp;border, hBrush); <br>                        DeleteObject (hBrush); <br> <br>                        EndPaint (hwnd, &amp;ps); <br> <br>                        return DefWindowProc (hwnd, msg, wParam, lParam); <br> <br>                case WM_DRAWITEM: // Indicates that an owner-draw control needs to be redrawn. <br>                        lpdi = (LPDRAWITEMSTRUCT)lParam; <br> <br>                        switch (lpdi-&gt;itemAction) { <br>                                // handle normal drawing of button, but check if its selected or focus <br>                                case ODA_SELECT: <br>                                case ODA_DRAWENTIRE: <br>                                        // handle button pressed down select state -- button down bitmap <br>                                        //   text is right &amp; down 2 pixels <br>                                                                                hIcon = NULL; <br>                                        for (i=0; i&lt; cntToolCtrls; i++) { <br>                                                if (toolCtrl[i].hwnd == lpdi-&gt;hwndItem) { <br>                                                        hIcon = toolCtrl[i].hIcon; <br>                                                } <br>                                        } <br>                                        if (lpdi-&gt;itemState &amp; ODS_SELECTED) { <br>                                                DrawButton (lpdi-&gt;hDC,lpdi-&gt;rcItem, TRUE, hIcon); <br>                                        } else { // not selected -- button up; text is in normal position <br>                                                DrawButton (lpdi-&gt;hDC,lpdi-&gt;rcItem, FALSE, hIcon); <br>                                        } <br>                                        return TRUE; <br>                        } <br>                        break; <br> <br>                case WM_COMMAND: <br>#if defined (WIN32) <br>                        idCtrl = LOWORD(wParam); <br>                        msgCtrl = HIWORD(wParam); <br>                        hwndCtl = (HWND)lParam; <br>#else <br>                        idCtrl = wParam; <br>                        msgCtrl = HIWORD (lParam); <br>                        hwndCtl = LOWORD (lParam); <br>#endif <br> <br>                        if (GetWindowLong (hwndCtl, GWL_STYLE) &amp; BS_OWNERDRAW) { <br>                                if (msgCtrl == BN_DOUBLECLICKED) { <br>                                        PostMessage (hwndCtl, WM_LBUTTONDOWN, 0, 0); <br>                                        return TRUE; <br>                                } <br>                        } <br>                        PostMessage (hwndMain, msg, wParam, lParam); <br>                        return DefWindowProc (hwnd, msg, wParam, lParam); <br> <br> <br>                default: <br>                        return DefWindowProc (hwnd, msg, wParam, lParam); <br>        } <br>        return 0L; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
