<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3377"></a>DIALOGS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#define NOMINMAX <br>#include &lt;windows.h&gt; <br>#include "FontView.h" <br> <br>#include &lt;stdlib.h&gt; <br> <br>#if !defined (APIENTRY) <br>#define APIENTRY FAR PASCAL <br>#endif <br> <br>BOOL CenterWindow (HWND, HWND); <br> <br> <br>typedef struct FONTENUM { <br>    short       ft; <br>    TEXTMETRIC  tm; <br>    LOGFONT     lf; <br>} FONTSTRUCT; <br>typedef FONTSTRUCT      *PFONTSTRUCT; <br>typedef FONTSTRUCT NEAR *NPFONTSTRUCT; <br>typedef FONTSTRUCT FAR  *LPFONTSTRUCT; <br> <br>typedef struct FONTLIST { <br>    int     count; <br>    HANDLE  hList; <br>} FONTLIST; <br>typedef FONTLIST        *PFONTLIST; <br>typedef FONTLIST NEAR   *NPFONTLIST; <br>typedef FONTLIST FAR    *LPFONTLIST; <br> <br> <br>void SetDlgItemValue (HWND hDlg, int nIDDlgItem, int wValue, BOOL bSigned, int nBase) <br>{ <br>    char szValue[20]; <br> <br>    switch (nBase) { <br>        case 8: <br>            wsprintf (szValue, "0o%o", wValue); <br>            SetDlgItemText (hDlg, nIDDlgItem, szValue); <br>            break; <br>        case 16: <br>            wsprintf (szValue, "0x%x", wValue); <br>            SetDlgItemText (hDlg, nIDDlgItem, szValue); <br>            break; <br>        default: <br>            SetDlgItemInt (hDlg, nIDDlgItem, wValue, bSigned); <br>            break; <br>    } <br>} <br> <br>int FAR PASCAL DlgEnumFontSizes (lpLogFont, lpTextMetric, nFontType, lpData) <br>    LPLOGFONT lpLogFont; <br>    LPTEXTMETRIC lpTextMetric; <br>    short nFontType; <br>    LPHANDLE lpData; <br>{ <br>    HANDLE hFonts; <br>    LPFONTSTRUCT pFS; <br>    LPFONTLIST pFL; <br> <br>    /* <br>        This function will lock down the incoming handle, properly alloc, and realloc the <br>        handle within it to hold the data of the fonts enumerated, then unlock the handle. <br>    */ <br>    hFonts = *lpData; <br>    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>    if (!pFL) { <br>        return FALSE; <br>    } else if (pFL-&gt;count == 0) { <br>        pFL-&gt;hList = GlobalAlloc (GHND, sizeof(FONTSTRUCT)); <br>    } else { <br>        pFL-&gt;hList = GlobalReAlloc (pFL-&gt;hList, sizeof(FONTSTRUCT)*(1+pFL-&gt;count), GMEM_MOVEABLE); <br>    } <br> <br>    if (pFL-&gt;hList) { <br>        pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>        if (pFS) { <br>            pFS[pFL-&gt;count].ft = nFontType; <br>            pFS[pFL-&gt;count].tm = *lpTextMetric; <br>            pFS[pFL-&gt;count].lf = *lpLogFont; <br>            GlobalUnlock (pFL-&gt;hList); <br>            pFL-&gt;count++; <br>        } <br>        GlobalUnlock (hFonts); <br> <br>    } else { <br>        GlobalUnlock (hFonts); <br>        return FALSE; <br>    } <br> <br>    return TRUE; <br>} <br> <br>int FAR PASCAL DlgEnumFontNames (lpLogFont, lpTextMetric, nFontType, lpData) <br>    LPLOGFONT lpLogFont; <br>    LPTEXTMETRIC lpTextMetric; <br>    short nFontType; <br>    LPHANDLE lpData; <br>{ <br>    HDC  hdc; <br>    HWND hwnd; <br>    HANDLE hInst; <br>    FARPROC lpFontEnumProc; <br> <br>/* <br>   This function is just a pass through. For each face encountered, it will in turn enumerate all <br>   sizes available. the lpData, which is a FAR * to a FONTSTRUCT structure will simply be passed <br>   on to the second enumeration procedure which will fill it in. <br> */ <br>    hwnd = GetFocus(); <br>#if defined (WIN32) <br>    hInst = (HANDLE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#elif defined (WIN16) <br>    hInst = (HANDLE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br> <br>    lpFontEnumProc = MakeProcInstance((FARPROC)DlgEnumFontSizes, hInst); <br>    if (lpFontEnumProc) { <br>        hdc  = GetDC(hwnd); <br>        EnumFonts (hdc, lpLogFont-&gt;lfFaceName, (FONTENUMPROC)lpFontEnumProc, (LPARAM)lpData); <br>        ReleaseDC(hwnd, hdc); <br>        FreeProcInstance (lpFontEnumProc); <br>    } else { <br>        MessageBox (GetFocus(), "Couldn't create a proc instance", "FontView", MB_OK); <br>        return FALSE; <br>    } <br>    return TRUE; <br> <br>    lpTextMetric;  // unreferenced formal parameter <br>    nFontType;     // unreferenced formal parameter <br>} <br> <br> <br> <br>BOOL APIENTRY SimpleDlgProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    int wmId; <br>    static HBITMAP hbmFontView; <br>    static BITMAP bmFontView; <br>    RECT rect; <br>    HDC hdc, hdcSrc; <br>    HBITMAP hbmOld; <br>    PAINTSTRUCT ps; <br>    HANDLE hInst; <br> <br>#if defined (WIN32) <br>    hInst = (HANDLE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#elif defined (WIN16) <br>    hInst = (HANDLE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br> <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            CenterWindow (hwnd, GetWindow (hwnd, GW_OWNER)); <br>            hbmFontView = LoadBitmap (hInst, "FONTVIEW"); <br>            GetObject (hbmFontView,sizeof(BITMAP), &amp;bmFontView); <br>            if (!hbmFontView) MessageBeep(0); <br>            return (TRUE); <br> <br>        case WM_DESTROY: <br>            DeleteObject (hbmFontView); <br>            break; <br> <br>        case WM_PAINT: <br>            hdc = BeginPaint (hwnd, &amp;ps); <br>            GetWindowRect (hwnd, &amp;rect); <br>            ScreenToClient (hwnd, (LPPOINT)&amp;rect.left); <br>            ScreenToClient (hwnd, (LPPOINT)&amp;rect.right); <br>            hdc = GetDC (hwnd); <br>            hdcSrc = CreateCompatibleDC (hdc); <br>            hbmOld = SelectObject (hdcSrc, hbmFontView); <br>            if (!BitBlt (hdc, 0, 0, bmFontView.bmWidth, bmFontView.bmHeight, hdcSrc, 0, 0, SRCCOPY)) { <br>                MessageBeep(0); <br>            } <br>            SelectObject (hdcSrc, hbmOld); <br>            DeleteDC (hdcSrc); <br>            EndPaint (hwnd, &amp;ps); <br>            break; <br> <br>        case WM_COMMAND: <br>#if defined (WIN32) <br>            wmId = LOWORD(wParam); <br>#elif defined (WIN16) <br>            wmId = wParam; <br>#endif <br>            switch (wmId) { <br> <br>                case IDOK: <br>                    EndDialog(hwnd, TRUE); <br>                    return (TRUE); <br> <br>                case IDCANCEL: <br>                    EndDialog(hwnd, TRUE); <br>                    return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE); <br> <br>    lParam; // unreferenced formal parameter <br>} <br> <br> <br>/* <br>    This dialog will present edit controls for all the parameters of a CreateFont call. <br>    The user can put any value in any of the fields, no validation is done. These parameters <br>    are then used to create a font with, and that will be the font that will be displayed. <br> */ <br>BOOL APIENTRY CreateDlgProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    int wmId, i; <br>    BOOL bDone; <br>static LOGFONT lfDlg; <br>static LPLOGFONT lplf; <br> <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            CenterWindow (hwnd, GetWindow (hwnd, GW_OWNER)); <br>            lplf = (LOGFONT *)lParam; <br>            lfDlg = *lplf; <br>            SetDlgItemInt (hwnd, CFD_HEIGHT, (int)lfDlg.lfHeight, TRUE); <br>            SetDlgItemInt (hwnd, CFD_WIDTH, (int)lfDlg.lfWidth, TRUE); <br>            SetDlgItemInt (hwnd, CFD_ESCAPEMENT, (int)lfDlg.lfEscapement, TRUE); <br>            SetDlgItemInt (hwnd, CFD_ORIENTATION, (int)lfDlg.lfOrientation, TRUE); <br>            SetDlgItemInt (hwnd, CFD_WEIGHT, (int)lfDlg.lfWeight, FALSE); <br>            SetDlgItemInt (hwnd, CFD_ITALIC, (int)lfDlg.lfItalic, FALSE); <br>            SetDlgItemInt (hwnd, CFD_UNDERLINE, (int)lfDlg.lfUnderline, FALSE); <br>            SetDlgItemInt (hwnd, CFD_STRIKEOUT, (int)lfDlg.lfStrikeOut, FALSE); <br>            SetDlgItemInt (hwnd, CFD_CHARSET, (int)lfDlg.lfCharSet, FALSE); <br>            SetDlgItemInt (hwnd, CFD_OUTPUTPRECISION, (int)lfDlg.lfOutPrecision, FALSE); <br>            SetDlgItemInt (hwnd, CFD_CLIPPRECISION, (int)lfDlg.lfClipPrecision, FALSE); <br>            SetDlgItemInt (hwnd, CFD_QUALITY, (int)lfDlg.lfQuality, FALSE); <br>            SetDlgItemInt (hwnd, CFD_PITCHANDFAMILY, (int)lfDlg.lfPitchAndFamily, FALSE); <br>            SetDlgItemText(hwnd, CFD_FACENAME, lfDlg.lfFaceName); <br> <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>#if defined (WIN32) <br>            wmId = LOWORD(wParam); <br>#elif defined (WIN16) <br>            wmId = wParam; <br>#endif <br>            switch (wmId) { <br>                case CFD_DEFAULT: <br>                    // Set all elements to ZERO. This will give us a 'default' font <br>                    for (i=CFD_BASE; i&lt;=CFD_PITCHANDFAMILY; i++) { <br>                        SetDlgItemInt (hwnd, i, 0, FALSE); <br>                    } <br>                    SetDlgItemText (hwnd, CFD_FACENAME, ""); <br>                    break; <br> <br>                case IDOK: <br>                    // Get the data from the edit control, we will then use this for a 'CreatFont' call <br>                    lfDlg.lfHeight = GetDlgItemInt (hwnd, CFD_HEIGHT, &amp;bDone, TRUE); <br>                    lfDlg.lfWidth = GetDlgItemInt (hwnd, CFD_WIDTH, &amp;bDone, TRUE); <br>                    lfDlg.lfEscapement = GetDlgItemInt (hwnd, CFD_ESCAPEMENT, &amp;bDone, TRUE); <br>                    lfDlg.lfOrientation = GetDlgItemInt (hwnd, CFD_ORIENTATION, &amp;bDone, TRUE); <br>                    lfDlg.lfWeight = GetDlgItemInt (hwnd, CFD_WEIGHT, &amp;bDone, FALSE); <br>                    lfDlg.lfItalic = (BYTE)GetDlgItemInt (hwnd, CFD_ITALIC, &amp;bDone, FALSE); <br>                    lfDlg.lfUnderline = (BYTE)GetDlgItemInt (hwnd, CFD_UNDERLINE, &amp;bDone, FALSE); <br>                    lfDlg.lfStrikeOut = (BYTE)GetDlgItemInt (hwnd, CFD_STRIKEOUT, &amp;bDone, FALSE); <br>                    lfDlg.lfCharSet = (BYTE)GetDlgItemInt (hwnd, CFD_CHARSET, &amp;bDone, FALSE); <br>                    lfDlg.lfOutPrecision = (BYTE)GetDlgItemInt (hwnd, CFD_OUTPUTPRECISION, &amp;bDone, FALSE); <br>                    lfDlg.lfClipPrecision = (BYTE)GetDlgItemInt (hwnd, CFD_CLIPPRECISION, &amp;bDone, FALSE); <br>                    lfDlg.lfQuality = (BYTE)GetDlgItemInt (hwnd, CFD_QUALITY, &amp;bDone, FALSE); <br>                    lfDlg.lfPitchAndFamily = (BYTE)GetDlgItemInt (hwnd, CFD_PITCHANDFAMILY, &amp;bDone, FALSE); <br>                    GetDlgItemText(hwnd, CFD_FACENAME, lfDlg.lfFaceName,20); <br>                    // and copy the data into our external structure <br>                    *lplf = lfDlg; <br>                    EndDialog(hwnd, TRUE); <br>                    return (TRUE); <br> <br>                case IDCANCEL: <br>                    // Exit without changing anything <br>                    EndDialog(hwnd, TRUE); <br>                    return (TRUE); <br> <br>            } <br>            break; <br>    } <br>    return (FALSE); <br> <br>    lParam; //unreferenced formal paramter <br>} <br> <br>/* <br> This dialog will display the TEXTMETRIC data that is retrieved from a 'GetTextMetric' call. <br> If the 'Select' button is clicked, then the current CreateFont data will be replaced with <br> as much data from TEXTMETRIC as possible. <br>*/ <br>BOOL APIENTRY MetricsDlgProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>static LOGFONT lfDlg; <br>static LPLOGFONT lplf; <br>static TEXTMETRIC tm; <br>static char szFacename[LF_FACESIZE]; <br>    int wmId; <br>    BOOL bDone; <br>    TEXTMETRIC tmTmp; <br>    HFONT hfont, hfontPrev; <br>    HDC   hdc; <br>    char szBuffer[LF_FACESIZE+15]; <br> <br> <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            CenterWindow (hwnd, GetWindow (hwnd, GW_OWNER)); <br>            lplf = (LOGFONT *)lParam; <br>            lfDlg = *lplf; <br> <br>            hfont = CreateFontIndirect (&amp;lfDlg); <br>            hdc = GetDC (hwnd); <br>            hfontPrev = SelectObject (hdc, hfont); <br>            GetTextMetrics (hdc, &amp;tm); <br>            GetTextFace    (hdc, sizeof(szFacename), szFacename); <br>            SelectObject (hdc, hfontPrev); <br>            DeleteObject (hfont); <br>            ReleaseDC (hwnd, hdc); <br> <br>            wsprintf (szBuffer, "TextMetrics: %s", (LPSTR)szFacename); <br>            SetWindowText (hwnd, szBuffer); <br> <br>            SetDlgItemInt (hwnd, TMD_HEIGHT, (int)tm.tmHeight, TRUE); <br>            SetDlgItemInt (hwnd, TMD_ASCENT, (int)tm.tmAscent, TRUE); <br>            SetDlgItemInt (hwnd, TMD_DESCENT, (int)tm.tmDescent, TRUE); <br>            SetDlgItemInt (hwnd, TMD_INTERNAL, (int)tm.tmInternalLeading, TRUE); <br>            SetDlgItemInt (hwnd, TMD_EXTERNAL, (int)tm.tmExternalLeading, TRUE); <br>            SetDlgItemInt (hwnd, TMD_AVEWIDTH, (int)tm.tmAveCharWidth, TRUE); <br>            SetDlgItemInt (hwnd, TMD_MAXWIDTH, (int)tm.tmMaxCharWidth, TRUE); <br>            SetDlgItemInt (hwnd, TMD_WEIGHT, (int)tm.tmWeight, TRUE); <br>            SetDlgItemInt (hwnd, TMD_ITALIC, (int)tm.tmItalic, FALSE); <br>            SetDlgItemInt (hwnd, TMD_UNDERLINE, (int)tm.tmUnderlined, FALSE); <br>            SetDlgItemInt (hwnd, TMD_STRUCKOUT, (int)tm.tmStruckOut, FALSE); <br>            SetDlgItemInt (hwnd, TMD_FIRSTCHAR, (int)tm.tmFirstChar, FALSE); <br>            SetDlgItemInt (hwnd, TMD_LASTCHAR, (int)tm.tmLastChar, FALSE); <br>            SetDlgItemInt (hwnd, TMD_DEFAULTCHAR, (int)tm.tmDefaultChar, FALSE); <br>            SetDlgItemInt (hwnd, TMD_BREAKCHAR, (int)tm.tmBreakChar, FALSE); <br>            SetDlgItemInt (hwnd, TMD_PITCHANDFAMILY, (int)tm.tmPitchAndFamily, FALSE); <br>            SetDlgItemInt (hwnd, TMD_CHARSET, (int)tm.tmCharSet, FALSE); <br>            SetDlgItemInt (hwnd, TMD_OVERHANG, (int)tm.tmOverhang, TRUE); <br>            SetDlgItemInt (hwnd, TMD_DIGITIZEDASPECTX, (int)tm.tmDigitizedAspectX, TRUE); <br>            SetDlgItemInt (hwnd, TMD_DIGITIZEDASPECTY, (int)tm.tmDigitizedAspectY, TRUE); <br> <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>#if defined (WIN32) <br>            wmId = LOWORD(wParam); <br>#elif defined (WIN16) <br>            wmId = wParam; <br>#endif <br>            switch (wmId) { <br>                case IDOK: <br>                    // Lets pull in as much data from the TEXTMETRIC structure as possible... <br>                    lfDlg.lfHeight         = tm.tmHeight; <br>                    lfDlg.lfWidth          = tm.tmAveCharWidth; <br>                    //lfDlg.lfEscapement - No Use <br>                    //lfDlg.lfOrientation - No Use <br>                    lfDlg.lfWeight         = tm.tmWeight; <br>                    lfDlg.lfItalic         = tm.tmItalic; <br>                    lfDlg.lfUnderline      = tm.tmUnderlined; <br>                    lfDlg.lfStrikeOut      = tm.tmStruckOut; <br>                    lfDlg.lfCharSet        = tm.tmCharSet; <br>                    //lfDlg.lfOutPrecision - No Use <br>                    //lfDlg.lfClipPrecision - No Use <br>                    //lfDlg.lfQuality - No Use <br>                    lfDlg.lfPitchAndFamily = tm.tmPitchAndFamily; <br>                    lstrcpy(lfDlg.lfFaceName, szFacename); <br> <br>                    // Lets create a font with this new data <br>                    hfont = CreateFontIndirect (&amp;lfDlg); <br>                    hdc = GetDC (hwnd); <br>                    hfontPrev = SelectObject (hdc, hfont); <br>                    GetTextMetrics (hdc, &amp;tmTmp); <br>                    // Get the face name <br>                    GetTextFace    (hdc, sizeof(szBuffer), szBuffer); <br>                    SelectObject (hdc, hfontPrev); <br>                    DeleteObject (hfont); <br>                    ReleaseDC (hwnd, hdc); <br> <br>                    // And verify that we did indeed get the same font. <br>                    bDone = TRUE; <br>                    bDone = bDone &amp;&amp; (tm.tmHeight==tmTmp.tmHeight); <br>                    bDone = bDone &amp;&amp; (tm.tmAscent==tmTmp.tmAscent); <br>                    bDone = bDone &amp;&amp; (tm.tmDescent==tmTmp.tmDescent); <br>                    bDone = bDone &amp;&amp; (tm.tmInternalLeading==tmTmp.tmInternalLeading); <br>                    bDone = bDone &amp;&amp; (tm.tmExternalLeading==tmTmp.tmExternalLeading); <br>                    bDone = bDone &amp;&amp; (tm.tmAveCharWidth==tmTmp.tmAveCharWidth); <br>                    bDone = bDone &amp;&amp; (tm.tmMaxCharWidth==tmTmp.tmMaxCharWidth); <br>                    bDone = bDone &amp;&amp; (tm.tmWeight==tmTmp.tmWeight); <br>                    bDone = bDone &amp;&amp; (tm.tmItalic==tmTmp.tmItalic); <br>                    bDone = bDone &amp;&amp; (tm.tmUnderlined==tmTmp.tmUnderlined); <br>                    bDone = bDone &amp;&amp; (tm.tmStruckOut==tmTmp.tmStruckOut); <br>                    bDone = bDone &amp;&amp; (tm.tmFirstChar==tmTmp.tmFirstChar); <br>                    bDone = bDone &amp;&amp; (tm.tmLastChar==tmTmp.tmLastChar); <br>                    bDone = bDone &amp;&amp; (tm.tmDefaultChar==tmTmp.tmDefaultChar); <br>                    bDone = bDone &amp;&amp; (tm.tmBreakChar==tmTmp.tmBreakChar); <br>                    bDone = bDone &amp;&amp; (tm.tmPitchAndFamily==tmTmp.tmPitchAndFamily); <br>                    bDone = bDone &amp;&amp; (tm.tmCharSet==tmTmp.tmCharSet); <br>                    // Did it work? <br>                    if (bDone) { <br>                        *lplf = lfDlg; <br>                        EndDialog(hwnd, TRUE); <br>                        return (TRUE); <br>                    } else { <br>                        // We need to take a close look at the font verification <br>                        // code. Currently, it sometimes will report that the <br>                        // font didn't get properly selected, even if it did. <br>                        *lplf = lfDlg; <br>                        EndDialog(hwnd, TRUE); <br>                        return (TRUE); <br> <br>                        // This is what we want to do once we beef up the font <br>                        // verification code: <br>                        lfDlg = *lplf; <br>                        MessageBox (GetFocus(), <br>                            "Unable to re-create font from TextMetrics", <br>                            "FontView", MB_OK); <br>                    } <br>                    break; <br> <br>                case IDCANCEL: <br>                    EndDialog(hwnd, TRUE); <br>                    return (TRUE); <br> <br>            } <br>            break; <br>    } <br>    return (FALSE); <br> <br>    /* Just For Reference */ <br>    lParam; <br>} <br> <br> <br>BOOL FillEnumFields (HWND hwnd, int iType, LPTEXTMETRIC ptm, LPLOGFONT plf, int nBase) <br>{ <br>            SetDlgItemValue (hwnd, TMD_HEIGHT, (int)ptm-&gt;tmHeight, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_ASCENT, (int)ptm-&gt;tmAscent, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_DESCENT, (int)ptm-&gt;tmDescent, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_INTERNAL, (int)ptm-&gt;tmInternalLeading, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_EXTERNAL, (int)ptm-&gt;tmExternalLeading, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_AVEWIDTH, (int)ptm-&gt;tmAveCharWidth, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_MAXWIDTH, (int)ptm-&gt;tmMaxCharWidth, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_WEIGHT, (int)ptm-&gt;tmWeight, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_ITALIC, (int)ptm-&gt;tmItalic, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_UNDERLINE, (int)ptm-&gt;tmUnderlined, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_STRUCKOUT, (int)ptm-&gt;tmStruckOut, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_FIRSTCHAR, (int)ptm-&gt;tmFirstChar, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_LASTCHAR, (int)ptm-&gt;tmLastChar, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_DEFAULTCHAR, (int)ptm-&gt;tmDefaultChar, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_BREAKCHAR, (int)ptm-&gt;tmBreakChar, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_PITCHANDFAMILY, (int)ptm-&gt;tmPitchAndFamily, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_CHARSET, (int)ptm-&gt;tmCharSet, FALSE, nBase); <br>            SetDlgItemValue (hwnd, TMD_OVERHANG, (int)ptm-&gt;tmOverhang, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_DIGITIZEDASPECTX, (int)ptm-&gt;tmDigitizedAspectX, TRUE, nBase); <br>            SetDlgItemValue (hwnd, TMD_DIGITIZEDASPECTY, (int)ptm-&gt;tmDigitizedAspectY, TRUE, nBase); <br> <br>            SetDlgItemValue (hwnd, CFD_HEIGHT, (int)plf-&gt;lfHeight, TRUE, nBase); <br>            SetDlgItemValue (hwnd, CFD_WIDTH, (int)plf-&gt;lfWidth, TRUE, nBase); <br>            SetDlgItemValue (hwnd, CFD_ESCAPEMENT, (int)plf-&gt;lfEscapement, TRUE, nBase); <br>            SetDlgItemValue (hwnd, CFD_ORIENTATION, (int)plf-&gt;lfOrientation, TRUE, nBase); <br>            SetDlgItemValue (hwnd, CFD_WEIGHT, (int)plf-&gt;lfWeight, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_ITALIC, (int)plf-&gt;lfItalic, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_UNDERLINE, (int)plf-&gt;lfUnderline, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_STRIKEOUT, (int)plf-&gt;lfStrikeOut, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_CHARSET, (int)plf-&gt;lfCharSet, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_OUTPUTPRECISION, (int)plf-&gt;lfOutPrecision, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_CLIPPRECISION, (int)plf-&gt;lfClipPrecision, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_QUALITY, (int)plf-&gt;lfQuality, FALSE, nBase); <br>            SetDlgItemValue (hwnd, CFD_PITCHANDFAMILY, (int)plf-&gt;lfPitchAndFamily, FALSE, nBase); <br>            SetDlgItemText(hwnd, CFD_FACENAME, plf-&gt;lfFaceName); <br> <br>            SetDlgItemValue (hwnd, ED_TYPE, (int)iType, FALSE, nBase); <br> <br>            return TRUE; <br>} <br> <br> <br>BOOL DrawSample (HWND hwnd, LPLOGFONT plf) <br>{ <br>    HFONT   hfont, hfontPrev; <br>    HDC     hdc; <br>    RECT    r; <br> <br>    hfont = CreateFontIndirect (plf); <br>    hdc = GetDC (hwnd); <br>    hfontPrev = SelectObject (hdc, hfont); <br>    GetWindowRect (hwnd, &amp;r); <br>    ScreenToClient (hwnd, (LPPOINT)&amp;r.left); <br>    ScreenToClient (hwnd, (LPPOINT)&amp;r.right); <br> <br>    Rectangle (hdc, r.left, r.top, r.right, r.bottom); <br> <br>    InflateRect (&amp;r, -1, -1); <br>    SetTextAlign (hdc, TA_BOTTOM | TA_CENTER); <br>    ExtTextOut (hdc, r.left + ((r.right-r.left)/2), r.bottom, ETO_CLIPPED, &amp;r,"AaBbCcDdEe 012345", 17, NULL); <br> <br>    SelectObject (hdc, hfontPrev); <br>    DeleteObject (hfont); <br>    ReleaseDC (hwnd, hdc); <br>    return TRUE; <br>} <br> <br> <br>/* <br>    Display a dialog that the user can use to enumerate through all of the fonts in the system. <br>    Show him not only all of the metrics for the font, but a sample of the font as well. <br>    If the user picks the 'Select' button, then the Metrics of this font will be used for <br>    the CreateFont call. <br>*/ <br>BOOL APIENTRY EnumDlgProc(HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    static HANDLE /*TO FONTLIST*/ hFonts; <br>    static int iLoc=0; <br>    static int count=0; <br>    static BOOL bHex = FALSE; <br>    static LOGFONT *lplf; <br>    static LOGFONT lfDlg; <br>    int wmId, i, j; <br>    HANDLE hInst; <br>    HWND   hwndItem; <br>    HDC hdc; <br>    FARPROC lpEnumFonts; <br>    LPFONTLIST    pFL; <br>    LPFONTSTRUCT  pFS; <br>    char szTmp[80]; <br>    HFONT hfont, hfontPrev; <br>    BOOL bDone; <br>    TEXTMETRIC tmTmp; <br> <br> <br>    switch (msg) { <br>        case WM_INITDIALOG: <br>            lplf = (LOGFONT *)lParam; <br>            lfDlg = *lplf; <br>            iLoc = 0; <br>            count = 0; <br>            bHex = FALSE; <br>            /* First, lets enumerate ALL fonts, and store them in our list */ <br>            hFonts = GlobalAlloc (GHND, sizeof(FONTLIST)); <br>            if (hFonts) { <br> <br>#if defined (WIN32) <br>    hInst = (HANDLE)GetWindowLong (hwnd, GWL_HINSTANCE); <br>#elif defined (WIN16) <br>    hInst = (HANDLE)GetWindowWord (hwnd, GWW_HINSTANCE); <br>#endif <br> <br>                lpEnumFonts = MakeProcInstance((FARPROC)DlgEnumFontNames, hInst); <br>                if (lpEnumFonts) { <br>                    hdc  = GetDC(hwnd); <br>                    // The enumeration function will lock down the handle <br>                    EnumFonts (hdc, NULL, (FONTENUMPROC)lpEnumFonts, (LPARAM)&amp;hFonts); <br>                    // The handle will come back to us properly unlocked <br>                    ReleaseDC(hwnd, hdc); <br>                    FreeProcInstance (lpEnumFonts); <br> <br>                 } <br>            } <br>            pFL = (LPFONTLIST)GlobalLock (hFonts); <br>            if (pFL) { <br>                pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>                if (pFS) { <br>                    iLoc = 0; <br>                    j = 100; <br>                    for (i=0; i&lt;pFL-&gt;count; i++) { <br>                        if (lstrcmp(lfDlg.lfFaceName, pFS[i].lf.lfFaceName) == 0) { <br>                            if (abs(lfDlg.lfHeight-pFS[i].lf.lfHeight) &lt; j) { <br>                                j = abs(lfDlg.lfHeight-pFS[i].lf.lfHeight); <br>                                iLoc = i; <br>                            } <br>                        } <br>                    } <br>                    FillEnumFields (hwnd, pFS[iLoc].ft, &amp;pFS[iLoc].tm, &amp;pFS[iLoc].lf, (bHex?16:10)); <br>                    hwndItem = GetDlgItem (hwnd, ED_SAMPLE); <br>                    DrawSample (hwndItem, &amp;pFS[iLoc].lf); <br>                    GlobalUnlock (pFL-&gt;hList); <br> <br>                } <br>                count = pFL-&gt;count; <br>                GlobalUnlock (hFonts); <br> <br>            } <br>            /* now fill in the dialog values */ <br>            wsprintf (szTmp, "EnumFonts %d of %d", iLoc+1, count); <br>            SetWindowText (hwnd, szTmp); <br>            CenterWindow (hwnd, GetWindow (hwnd, GW_OWNER)); <br> <br>            return TRUE; <br> <br>        case WM_PAINT: <br>            pFL = (LPFONTLIST)GlobalLock (hFonts); <br>            if (pFL) { <br>                pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>                if (pFS) { <br>                    FillEnumFields (hwnd, pFS[iLoc].ft, &amp;pFS[iLoc].tm, &amp;pFS[iLoc].lf, (bHex?16:10)); <br>                    hwndItem = GetDlgItem (hwnd, ED_SAMPLE); <br>                    DrawSample (hwndItem, &amp;pFS[iLoc].lf); <br>                    GlobalUnlock (pFL-&gt;hList); <br>                } <br>                GlobalUnlock (hFonts); <br>            } <br>            return 0; <br> <br>        case WM_COMMAND: <br>#if defined (WIN32) <br>            wmId = LOWORD(wParam); <br>#elif defined (WIN16) <br>            wmId = wParam; <br>#endif <br>            switch (wmId) { <br> <br>                case ED_HEX: <br>                    // Display the data in either Hex mode or Dec mode. <br>                    bHex = !bHex; <br>                    CheckDlgButton (hwnd, wmId, bHex); <br>                    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>                    if (pFL) { <br>                        pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>                        if (pFS) { <br>                            FillEnumFields (hwnd, pFS[iLoc].ft, &amp;pFS[iLoc].tm, &amp;pFS[iLoc].lf, (bHex?16:10)); <br>                            if (GlobalUnlock (pFL-&gt;hList)) { <br>                                MessageBox (GetFocus(), "In HEX", "Unlock pFL-&gt;hList", MB_OK); <br>                            } <br>                        } <br>                        if (GlobalUnlock (hFonts)) { <br>                            MessageBox (GetFocus(), "In HEX", "Unlock hFonts", MB_OK); <br>                        } <br> <br>                    } <br>                    break; <br> <br>                case ED_PREV: <br>                    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>                    if (pFL) { <br>                        if (iLoc &gt; 0) { <br>                            iLoc--; <br>                            pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>                            if (pFS) { <br>                                FillEnumFields (hwnd, pFS[iLoc].ft, &amp;pFS[iLoc].tm, &amp;pFS[iLoc].lf, (bHex?16:10)); <br>                                hwndItem = GetDlgItem (hwnd, ED_SAMPLE); <br>                                DrawSample (hwndItem, &amp;pFS[iLoc].lf); <br>                                GlobalUnlock (pFL-&gt;hList); <br>                            } <br>                        } <br>                        GlobalUnlock (hFonts); <br>                    } <br>                    wsprintf (szTmp, "EnumFonts %d of %d", iLoc+1, count); <br>                    SetWindowText (hwnd, szTmp); <br>                    break; <br> <br>                case ED_NEXT: <br>                    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>                    if (pFL) { <br>                        if ((pFL-&gt;count-1) &gt; iLoc) { <br>                            iLoc++; <br>                            pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>                            if (pFS) { <br>                                FillEnumFields (hwnd, pFS[iLoc].ft, &amp;pFS[iLoc].tm, &amp;pFS[iLoc].lf, (bHex?16:10)); <br>                                hwndItem = GetDlgItem (hwnd, ED_SAMPLE); <br>                                DrawSample (hwndItem, &amp;pFS[iLoc].lf); <br>                                GlobalUnlock (pFL-&gt;hList); <br>                            } <br> <br>                        } <br>                        GlobalUnlock (hFonts); <br>                    } <br>                    wsprintf (szTmp, "EnumFonts %d of %d", iLoc+1, count); <br>                    SetWindowText (hwnd, szTmp); <br>                    break; <br> <br>                case IDOK: <br>                    // Copy the LOGFONT structure from the enumeration list, into our private LF <br>                    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>                    bDone = FALSE; <br>                    if (pFL) { <br>                        if ((pFL-&gt;count-1) &gt;= iLoc) { <br>                            pFS = (LPFONTSTRUCT)GlobalLock (pFL-&gt;hList); <br>                            if (pFS) { <br>                                lfDlg = pFS[iLoc].lf; <br> <br>                    // Lets create a font with this new data <br>                    hfont = CreateFontIndirect (&amp;lfDlg); <br>                    hdc = GetDC (hwnd); <br>                    hfontPrev = SelectObject (hdc, hfont); <br>                    GetTextMetrics (hdc, &amp;tmTmp); <br>                    // Get the face name <br>                    GetTextFace    (hdc, sizeof(szTmp), szTmp); <br>                    SelectObject (hdc, hfontPrev); <br>                    DeleteObject (hfont); <br>                    ReleaseDC (hwnd, hdc); <br> <br>                    // And verify that we did indeed get the same font. <br>                    bDone = TRUE; <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmHeight==tmTmp.tmHeight); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmAscent==tmTmp.tmAscent); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmDescent==tmTmp.tmDescent); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmInternalLeading==tmTmp.tmInternalLeading); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmExternalLeading==tmTmp.tmExternalLeading); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmAveCharWidth==tmTmp.tmAveCharWidth); </code></pre>
<p>
</p>
<pre><code>bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmMaxCharWidth==tmTmp.tmMaxCharWidth); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmWeight==tmTmp.tmWeight); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmItalic==tmTmp.tmItalic); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmUnderlined==tmTmp.tmUnderlined); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmStruckOut==tmTmp.tmStruckOut); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmFirstChar==tmTmp.tmFirstChar); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmLastChar==tmTmp.tmLastChar); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmDefaultChar==tmTmp.tmDefaultChar); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmBreakChar==tmTmp.tmBreakChar); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmPitchAndFamily==tmTmp.tmPitchAndFamily); <br>                    bDone = bDone &amp;&amp; (pFS[iLoc].tm.tmCharSet==tmTmp.tmCharSet); <br>                    // Did it work? <br>                    if (bDone) { <br>                        *lplf = lfDlg; <br>                        //EndDialog(hwnd, TRUE); <br>                        //return (TRUE); <br>                    } else { <br>                        // Again, font verification code is'nt quite up to <br>                        // snuff yet, so just Select the font anyway: <br>                        *lplf = lfDlg; <br> <br>                        // ...and this is what we want to do once we fix the <br>                        // font verification code: <br>                        //lfDlg = *lplf; <br>                        //MessageBox (GetFocus(), <br>                        //    "Unable to re-create font from TextMetrics", <br>                        //    "FontView", MB_OK); <br>                    } <br> <br> <br>                                GlobalUnlock (pFL-&gt;hList); <br>                            } <br>                        } <br>                        GlobalUnlock (hFonts); <br>                    } <br> <br> <br>                    // Now set our master lf to this value. This way, we 'could' verify that the <br>                    // LOGFONT structure will in fact select this particular font, we just aren't yet <br>                    // *lplf = lfDlg; <br> <br>                    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>                    if (pFL) { <br>                        if (GlobalFree (pFL-&gt;hList)) { <br>                            MessageBox (GetFocus(), "Failed To Free", "pFL-&gt;hList", MB_OK); <br>                        } else { <br>                            GlobalUnlock (hFonts); <br>                            if (GlobalFree (hFonts)) { <br>                                MessageBox (GetFocus(), "Failed To Free", "hFonts", MB_OK); <br>                            } <br>                        } <br>                    } <br>                    EndDialog(hwnd, TRUE); <br>                    return (bDone); <br> <br>                case IDCANCEL: <br>                    pFL = (LPFONTLIST)GlobalLock (hFonts); <br>                    if (pFL) { <br>                        if (GlobalFree (pFL-&gt;hList)) { <br>                            MessageBox (GetFocus(), "Failed To Free", "pFL-&gt;hList", MB_OK); <br>                        } else { <br>                            GlobalUnlock (hFonts); <br>                            if (GlobalFree (hFonts)) { <br>                                MessageBox (GetFocus(), "Failed To Free", "hFonts", MB_OK); <br>                            } <br>                        } <br>                    } <br>                    EndDialog(hwnd, TRUE); <br>                    return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE); <br> <br>    lParam; // unreferenced formal parameter <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
