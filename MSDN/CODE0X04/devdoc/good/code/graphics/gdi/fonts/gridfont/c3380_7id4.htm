<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VIEW.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3388"></a>VIEW.CXX</h2>
<pre><code>//-------------------------------------------------------------------- <br>// File: View.Cxx <br>// <br>// Classes:  <br>//      CClientCanvas - Device context for client area <br>//      CPrintCanvas  - Device context for printing <br>// <br>//      CView          - Base class for Views  <br>//      CScrollaleView - Scrollable View <br>//      CFullPageView  - NonScrollable FullPage View <br>// <br>// History: 22-Jan-1993 Asmusf  Created <br>// <br>// Copyright 1993 - 1998 Microsoft Corp. All Rights reserved <br>// <br>//-------------------------------------------------------------------- <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include "app.h" <br>#include "view.hxx" <br>#include "grid.hxx" <br> <br>//+-------------------------------------------------------- <br>// Class:       CView <br>// <br>// Purpose:     Standard fixed View for printing, or base class <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>CView::CView(int cx, int cy) <br>{ <br>        _iScale = 100;        // percentage magnification <br>        _ptOrg.x = 0;         // 0..(PAGEWIDTH - widht of window)  <br>        _ptOrg.y = 0;         // 0..(PAGEHEIGHT - height of window) <br>        _ptScroll.x = 0;      // 0..PAGEWIDTH <br>        _ptScroll.y = 0;      // 0..PAGEHEIGHT <br>        _size.cx = cx;        // width of window (dev. coord) <br>        _size.cy = cy;        // widht of window (dev. coord) <br>} <br> <br>void CView::SetSize( int cx, int cy) <br>{ <br>        _size.cx = cx; <br>        _size.cy = cy; <br>} <br> <br>void CView::Invalidate(HWND hwnd, LPRECT lpRect) <br>{ <br>        InvalidateRect(hwnd, lpRect, TRUE);              <br>} <br> <br>BOOL CView::Paint(CCanvas&amp; canvas, CModel * _pModel, RECT rc) <br>{ <br>        // Scale using MapMode = logical TWIPS <br>        canvas.Scale(_iScale); <br>         <br>        // Client rect in logical coordinates <br>        _ptClient.x=_size.cx; <br>        _ptClient.y=_size.cy; <br>        canvas.DPtoLP(&amp;_ptClient); <br> <br>        // Adjust GDIwindow origin, set _ptOrg <br>        Scroll(canvas); <br> <br>        // ClipRectangle in logical coordinates <br>        POINT pt; <br>        pt.x = rc.left; pt.y = rc.top; <br>        canvas.DPtoLP(&amp;pt); <br>        rc.left = pt.x; rc.top = pt.y; <br> <br>        pt.x = rc.right; pt.y = rc.bottom; <br>        canvas.DPtoLP(&amp;pt); <br>        rc.right = pt.x; rc.bottom = pt.y; <br> <br> <br>        // Paint <br>        _pModel-&gt;Paint(canvas, rc); <br> <br>        return TRUE;  // screen Paints don't fail <br>} <br> <br>UINT CView::Hittest(CCanvas&amp; canvas, POINT ptTest, CModel * _pModel) <br>{ <br>        // Scale using MapMode = logical TWIPS <br>        canvas.Scale(_iScale); <br>         <br>        // Client rect in logical coordinates <br>        _ptClient.x=_size.cx; <br>        _ptClient.y=_size.cy; <br>        canvas.DPtoLP(&amp;_ptClient); <br> <br>        // Adjust GDIwindow origin, set _ptOrg <br>        Scroll(canvas); <br> <br>        // Hittest <br> <br>        canvas.DPtoLP(&amp;ptTest); <br>        return _pModel-&gt;Hittest( ptTest); <br>} <br> <br>void CView::Scroll(CCanvas &amp;canvas) <br>{ <br>        int dx=MulDiv(_ptClient.x,_ptScroll.x,PAGEWIDTH); <br>        int dy=MulDiv(_ptClient.y,_ptScroll.y,PAGEHEIGHT); <br> <br>        // Adjust GDIwindow origin, set _ptOrg <br>        _ptOrg.x = _ptScroll.x-dx; <br>        _ptOrg.y = _ptScroll.y-dy; <br>         <br>        canvas.Scroll(_ptOrg.x, _ptOrg.y); <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CScrollableView <br>// <br>// Purpose:     View for scrollable window <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>void CScrollableView::SetHScrollPos(HWND hwnd, WPARAM wParam, LPARAM lParam, CModel * pModel) <br>{ <br>    CScreenCanvas canvas(hwnd); <br>    int nScrollPos = GetScrollPos( hwnd, SB_HORZ ); <br>    canvas.Scale(_iScale); <br> <br> <br>    SIZE size; <br>    pModel-&gt;GetLineSize(&amp;size); <br> <br>    // scroll position relative to page dimension <br>    switch (wParam) <br>    { <br>    case SB_LINEUP: <br>         nScrollPos -= 2 * size.cx; <br>         break; <br>    case SB_LINEDOWN: <br>         nScrollPos += 2 * size.cx; <br>         break; <br> <br>    case SB_PAGEUP: <br>         nScrollPos -= _ptClient.x; // size of Window in log coord <br>         break; <br> <br>    case SB_PAGEDOWN: <br>         nScrollPos += _ptClient.x; <br>         break; <br> <br>    case SB_THUMBPOSITION: <br>         nScrollPos = LOWORD(lParam); <br>         break; <br> <br>    default: <br>         break; <br>    } <br>                       <br>    nScrollPos = max( 0, min (nScrollPos, PAGEWIDTH)); <br>     <br>    POINT pt; <br>    pt.x =  GetScrollPos( hwnd, SB_HORZ ) - nScrollPos; <br>    if( pt.x ) <br>    { <br>        SetScrollPos(hwnd, SB_HORZ, nScrollPos, TRUE ); <br> <br>        pt.y = 0; <br>        canvas.LPtoDP(&amp;pt); <br> <br>        pt.x -= MulDiv( _ptClient.x, pt.x, PAGEWIDTH); <br>        ScrollWindow(hwnd, pt.x, pt.y, NULL, NULL );     <br>    } <br>    _ptScroll.x = nScrollPos; <br>} <br> <br>void CScrollableView::SetVScrollPos(HWND hwnd, WPARAM wParam, LPARAM lParam, CModel * pModel) <br>{ <br>    CScreenCanvas canvas(hwnd); <br>    int nScrollPos = GetScrollPos( hwnd, SB_VERT ); <br>    canvas.Scale(_iScale); <br> <br> <br>    SIZE size; <br>    pModel-&gt;GetLineSize(&amp;size); <br> <br>    // scroll position relative to page dimension <br>    switch (wParam) <br>    { <br>    case SB_LINEUP: <br>         nScrollPos -= 2 * size.cy; <br>         break; <br>    case SB_LINEDOWN: <br>         nScrollPos += 2 * size.cy; <br>         break; <br> <br>    case SB_PAGEUP: <br>         nScrollPos -= _ptClient.y; // size of Window in log coord <br>         break; <br> <br>    case SB_PAGEDOWN: <br>         nScrollPos += _ptClient.y; <br>         break; <br> <br>    case SB_THUMBPOSITION: <br>         nScrollPos = LOWORD(lParam); <br>         break; <br> <br>    default: <br>         break; <br>    } <br>                       <br>    nScrollPos = max( 0, min (nScrollPos, PAGEHEIGHT)); <br>     <br>    POINT pt; <br>    pt.y =  GetScrollPos( hwnd, SB_VERT ) - nScrollPos; <br>    if( pt.y ) <br>    { <br>        SetScrollPos(hwnd, SB_VERT, nScrollPos, TRUE ); <br> <br>        pt.x = 0; <br>        canvas.LPtoDP(&amp;pt); <br> <br>        pt.y -= MulDiv( _ptClient.y, pt.y, PAGEHEIGHT); <br>        ScrollWindow(hwnd, pt.x, pt.y, NULL, NULL );     <br>    } <br>    _ptScroll.y = nScrollPos; <br>} <br> <br>//+-------------------------------------------------------- <br>// Class:       CPrintCanvas <br>// <br>// Purpose:     Device Context for Printing <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br> <br>// fully inline // <br> <br>//+-------------------------------------------------------- <br>// Class:       CPrintRequest <br>// <br>// Purpose:     Print Job selection and parameters <br>// <br>// History:     22-Jan-1993     asmusf  created <br>//---------------------------------------------------------- <br>CPrintAux PrGlobal;     // global flags for printing control <br> <br>CPrintRequest::CPrintRequest(HWND hwnd, UINT nMinPage, UINT nMaxPage ) : <br>        _hwnd(hwnd), <br>        _hdc(0), <br>        _hDevNames(0) <br>{ <br>    PRINTDLG pd; <br> <br>    pd.lStructSize= sizeof(PRINTDLG); <br>    pd.hwndOwner=NULL; <br>    pd.hDevMode=NULL; <br>    pd.hDevNames=NULL; <br>    pd.hDC; <br>    pd.nFromPage = 0xFFFF; // cause initial blank field <br>    pd.nToPage   = 0xFFFF; // in dialog <br>    pd.nMinPage=nMinPage; <br>    pd.nMaxPage=nMaxPage; <br>    pd.nCopies=1; <br>    pd.hInstance=NULL; <br>    pd.lCustData=0L; <br>    pd.lpfnPrintHook=NULL; <br>    pd.lpfnSetupHook=NULL; <br>    pd.lpPrintTemplateName=NULL; <br>    pd.lpSetupTemplateName=NULL; <br>    pd.hPrintTemplate=NULL; <br>    pd.hSetupTemplate=NULL; <br> <br>    pd.Flags = PD_RETURNDEFAULT; <br>     <br>    if( PrintDlg(&amp;pd) ) <br>    { <br>        pd.Flags = PD_SELECTION | PD_HIDEPRINTTOFILE | PD_RETURNDC; <br>        if( PrintDlg( &amp;pd ) ) <br>        { <br>             if(pd.Flags &amp; PD_PAGENUMS) <br>             { <br>                 _nFromPage = pd.nFromPage; <br>                 _nToPage = pd.nToPage; <br>             } <br>             else if (pd.Flags &amp; PD_SELECTION ) <br>             { <br>                 _nFromPage = _nToPage = 0xFFFF; <br>             } <br>             else   // all non empty pages <br>             { <br>                 _nFromPage = nMinPage; <br>                 _nToPage = nMaxPage; <br>             } <br>             _hdc = pd.hDC; <br>             _hDevNames = pd.hDevNames; <br> <br>             if( pd.hDevMode ) <br>             { <br>                GlobalFree (pd.hDevMode); <br>             } <br>             _status = PREQ_SUCCESS; <br>             return; <br>        } <br>        else <br>        { <br>            _status = PREQ_ERROR; <br>            return; <br>        } <br>    }  <br> <br>    _status = PREQ_CANCEL; <br>} <br> <br>CPrintRequest:: ~CPrintRequest() <br>{ <br>    if( _hDevNames ) <br>    { <br>        GlobalFree( _hDevNames ); <br>    } <br>     <br>    if( _hdc ) <br>    { <br>        DeleteDC(_hdc ); <br>    } <br>} <br> <br>UINT CPrintRequest::Print(HINSTANCE hInst, CCanvas &amp;canvas, CModel *pModel) <br>{ <br>     // needs to become app &amp; font name.... <br>     static TCHAR szMessage [] = TEXT("Grid: Printing") ; <br> <br>     TCHAR szCaption[30]; <br>      <br>     BOOL       fError = PREQ_SUCCESS ; <br>     ABORTPROC  lpfnAbortProc; <br>     DLGPROC    lpfnPrintDlgProc ; <br>     short      cxPage, cyPage ; <br> <br>     cxPage = GetDeviceCaps (canvas, HORZRES) ; <br>     cyPage = GetDeviceCaps (canvas, VERTRES) ; <br> <br>     // disable user input to main window <br>     EnableWindow (_hwnd, FALSE) ; <br> <br>     lpfnPrintDlgProc = (DLGPROC) MakeProcInstance ((FARPROC) PrintDlgProc, hInst) ; <br>      <br>     LoadString(hInst, IDS_MSGCAPTION, szCaption, 30); <br>     PrGlobal._bUserAbort = FALSE ; <br>     PrGlobal._hDlgPrint =  <br>                CreateDialogParam (hInst, TEXT("PrintDlgBox"), _hwnd,  <br>                                lpfnPrintDlgProc, (LONG)(LPSTR) szCaption) ; <br> <br>     lpfnAbortProc = (ABORTPROC) MakeProcInstance ((FARPROC) AbortProc, hInst) ; <br> <br>     SetAbortProc(canvas, lpfnAbortProc); <br> <br>     DOCINFO docinfo; <br>     docinfo.cbSize = sizeof(DOCINFO); <br>     docinfo.lpszDocName = szMessage; <br>     docinfo.lpszOutput = NULL; <br> <br>     if (Escape (canvas, STARTDOC, sizeof szMessage - 1, (LPCSTR)szMessage, NULL) &gt; 0) <br>     //if (StartDoc(canvas, &amp;docinfo) &gt; 0) <br>     { <br>          UINT fuFormat; <br>          pModel-&gt;GetFormat(fuFormat); <br>          pModel-&gt;SetFormat(fuFormat | PAGEPRINT|PAGEELEMS); <br>          UINT iSavePage = pModel-&gt;GetPage(); <br>           <br> <br>          // create printer view to  <br>          CView  View(cxPage, cyPage); <br> <br> <br>          if( _nToPage == 0xFFFF || _nFromPage == 0xFFFF ) <br>          {      <br>                _nToPage =   pModel-&gt;GetPage()+1; <br>                _nFromPage = pModel-&gt;GetPage()+1; <br>          } <br> <br>          for( ; _nFromPage &lt;= _nToPage &amp;&amp; ! fError; _nFromPage++ ) <br>          { <br>             if (pModel-&gt;IsModelPageUsed(_nFromPage-1)) <br>                { <br>                if( StartPage(canvas) &lt; 0 ) <br>                    { <br>                    fError = PREQ_ERRSTARTPAGE ; <br>                    break; <br>                    }     <br>                pModel-&gt;SetPage(_nFromPage-1);  // &lt;- pages are 0 based in Model <br>                RECT rc; <br>                rc.left = rc.top = 0; <br>                rc.right= cxPage; <br>                rc.bottom = cyPage; <br>                View.Paint (canvas, pModel, rc) ; <br>                 <br>                if ( EndPage(canvas) &lt; 0) <br>                    { <br>                    fError = PREQ_ERRENDPAGE ; <br>                    } <br>} <br>          } <br>          if( !fError ) <br>          { <br>               EndDoc(canvas); <br>          } <br>          // restore screen format <br>          pModel-&gt;SetPage(iSavePage); <br>          pModel-&gt;SetFormat(fuFormat); <br>     } <br>     else <br>     { <br>          fError = PREQ_ERRSTARTDOC ; <br>     } <br> <br>     if (!PrGlobal._bUserAbort) <br>     { <br>          EnableWindow (_hwnd, TRUE) ; <br>          DestroyWindow (PrGlobal._hDlgPrint) ; <br>     } <br> <br>     FreeProcInstance ((FARPROC)lpfnPrintDlgProc) ; <br>     FreeProcInstance ((FARPROC)lpfnAbortProc) ; <br> <br>     if( PrGlobal._bUserAbort ) <br>     { <br>        fError |= PREQ_USERABORT; <br>     } <br> <br>     return fError ; <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
