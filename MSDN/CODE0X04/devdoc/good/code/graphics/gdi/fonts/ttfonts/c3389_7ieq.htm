<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ALLFONT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3392"></a>ALLFONT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  allfont.c -- module to display the result of enumerating all fonts. <br>*   Includes the window procedure and an initialization routine. <br>* <br>*  There are actually two windows serviced by this module.  One for the <br>*   display fonts, one for the printer fonts. <br>* <br>* <br>*  Data structure: <br>*   Since we keep a modest amount of data for each possible font, and <br>*   since the amount of this information is known only at run time, <br>*   the main data structure used here is all allocated dynamically. <br>*   parFonts points to an array of ARFONT structures.  These structures <br>*   store two int's and then three pointers to arrays of LOGFONT, <br>*   TEXTMETRIC, and int's respectively. <br>* <br>*   parFonts--&gt; |--------------------|  |--------------------| <br>*               |  nFonts (Family0)  |  |  nFonts (Family1)  | <br>*               |       cySpace      |  |       cySpace      | ... <br>*               |        hdc         |  |        hdc         | <br>*               |--------------------|  |--------------------| <br>*               | lf  |  tm |  Type  |  | lf  |  tm |  Type  | <br>*               |--------------------|  |--------------------| <br>*                 |       |       |       |       |       | <br>*                 |       |       |       |       |       | <br>*                 V       V       V       V       V       V <br>*               |----| |------| |----|  |----| |------| |----| <br>*               |LOG | |TEXT  | |Type|  |LOG | |TEXT  | |Type| <br>*               |FONT| |METRIC| |    |  |FONT| |METRIC| |    | <br>*               |0,0 | |0,0   | |0,0 |  |1,0 | |1,0   | |1,0 | <br>*               |----| |------| |----|  |----| |------| |----| <br>*               |LOG | |TEXT  | |Type|  |LOG | |TEXT  | |Type| <br>*               |FONT| |METRIC| |    |  |FONT| |METRIC| |    | <br>*               |0,1 | |0,1   | |0,1 |  |1,1 | |1,1   | |1,1 | <br>*               |----| |------| |----|  |----| |------| |----| <br>* <br>*                ...    ...      ...     ...    ...      ... <br>* <br>*               |----| |------| |----| <br>*               |LOG | |TEXT  | |Type| <br>*               |FONT| |METRIC| |    |  |----| |------| |----| <br>*               |0,  | |0,    | |0,  |  |LOG | |TEXT  | |Type| <br>*               |nFon| |nFonts| |nFon|  |FONT| |METRIC| |    | <br>*               |----| |------| |----|  |1,  | |1,    | |1,  | <br>*                                       |nFon| |nFonts| |nFon| <br>*                                       |----| |------| |----| <br>* <br>* <br>*   So, to get the FontType of the 4th font within the 2nd family use: <br>*    parFonts[1].Type[3] <br>* <br>*   There is one final ARFONT structure which has no linked lists atttached, <br>*    but has a blank HDC as padding on the far right of the window. <br>* <br>*   The pointer to the array of ARFONT structures is stored in the <br>*    GWL_PARFONTS extra bytes for each window.  The number of face names <br>*    for each window is stored in the GWLU_NFACES extra bytes. <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "ttfonts.h" <br> <br> <br>typedef struct tagArFonts{ <br>  int        nFonts; <br>  int        cySpace; <br>  HDC        hdc; <br>  LOGFONT    *lf; <br>  TEXTMETRIC *tm; <br>  int        *Type; <br>} ARFONTS, *PARFONTS; <br> <br> <br>#define ALLFONTBORDER  10 <br>#define CXDEF         130 <br>#define BMSIZE         14 <br> <br> <br>#define GWLU_PARFONTS 0 <br>#define GWLU_NFACES   4 <br> <br>/* forward declare function prototypes. */ <br>VOID     DrawBitmapXY (HDC, HBITMAP, int, int); <br> <br>PARFONTS BuildFontList(HDC, LPINT); <br>VOID     BuildBitmapStrips (HWND, LPRECT, PARFONTS, int); <br> <br>int APIENTRY MyEnumFaces(LPLOGFONT, LPTEXTMETRIC, DWORD, LPVOID); <br>int APIENTRY MyEnumCopy (LPLOGFONT, LPTEXTMETRIC, DWORD, LPVOID); <br>int APIENTRY MyEnumCount(LPLOGFONT, LPTEXTMETRIC, DWORD, LPINT); <br> <br> <br> <br>int initAllFont(HWND hwndParent) <br>{ <br>WNDCLASS  wc; <br>HDC       hdc; <br> <br>  wc.style = 0; <br>  wc.lpfnWndProc = (WNDPROC)AllFontsWndProc; <br>  wc.cbClsExtra = 0; <br>  wc.cbWndExtra = 8; <br>  wc.hInstance = hInst; <br>  wc.hIcon = LoadIcon(hInst, TEXT("ttfontsIcon")); <br>  wc.hCursor = LoadCursor(NULL, IDC_CROSS); <br>  wc.hbrBackground = GetStockObject(WHITE_BRUSH); <br>  wc.lpszMenuName = NULL; <br>  wc.lpszClassName = TEXT("AllFonts"); <br> <br>  if (!RegisterClass(&amp;wc)) return (FALSE); <br> <br> <br>  /* create a window to show all of the display fonts, and send it <br>   *  the proper WMU_CREATE message with an HDC for the display. <br>   */ <br>  hwndDisplayFonts = CreateMDIWindow( <br>      TEXT("AllFonts"), <br>      TEXT("EnumFonts (display)"), <br>      WS_CHILD | WS_CLIPSIBLINGS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | <br>      WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_HSCROLL, <br>      0,0, <br>      GetSystemMetrics (SM_CXFULLSCREEN), <br>      GetSystemMetrics (SM_CYFULLSCREEN) - GetSystemMetrics (SM_CYMENU), <br>      hwndParent, hInst, 0); <br> <br>  ShowWindow (hwndDisplayFonts, SW_HIDE); <br>  hdc = GetDC (hwndDisplayFonts); <br>  SendMessage (hwndDisplayFonts, WMU_CREATE, (DWORD)hdc, 0); <br>  ReleaseDC (hwndDisplayFonts, hdc); <br>  ShowWindow (hwndDisplayFonts, SW_SHOWMINIMIZED); <br> <br>  if (!hwndDisplayFonts) return (FALSE); <br> <br> <br>  /* create a window to show all of the printer fonts, and send it <br>   *  the proper WMU_CREATE message with an HDC for the printer. <br>   */ <br> <br>  hwndPrinterFonts = CreateMDIWindow( <br>      TEXT("AllFonts"), <br>      TEXT("EnumFonts (printer)"), <br>      WS_CHILD | WS_CLIPSIBLINGS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | <br>      WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_HSCROLL, <br>      0,0, <br>      GetSystemMetrics (SM_CXFULLSCREEN), <br>      GetSystemMetrics (SM_CYFULLSCREEN) - GetSystemMetrics (SM_CYMENU), <br>      hwndParent, hInst, 0); <br>  if (!hwndPrinterFonts) return (FALSE); <br> <br>  ShowWindow (hwndPrinterFonts, SW_HIDE); <br>  hdc = GetPrinterDC (); <br>  if (hdc == NULL) { <br>    SetWindowLong (hwndPrinterFonts, GWLU_PARFONTS, (LONG) NULL); <br>    DestroyWindow (hwndPrinterFonts); <br>    SendMessage (hwndMain, WM_COMMAND, IDU_NOPRINTER, 0); <br>  } else { <br>    SendMessage (hwndPrinterFonts, WMU_CREATE, (DWORD)hdc, 0); <br>    DeleteDC (hdc); <br>    ShowWindow (hwndPrinterFonts, SW_SHOWMINIMIZED); <br>  } <br> <br>  return TRUE; <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  GetPrinterDC <br>* <br>*  input parameters:  none. <br>* <br>* Simply return an HDC for the default printer. <br>*  Note that this HDC should be deleted later (DeleteDC). <br>* <br>* <br>\**************************************************************************/ <br>HDC GetPrinterDC () <br>{ <br>  PRINTER_INFO_2  *pi2; <br>  DWORD  dwNeeded, dwReturned; <br>  HDC hdc; <br> <br>  /* Figure out how much memory we need and alloc it. */ <br>  EnumPrinters (PRINTER_ENUM_DEFAULT | PRINTER_ENUM_LOCAL, <br>                 NULL, 2, <br>                 NULL, 0, <br>                 &amp;dwNeeded, &amp;dwReturned); <br> <br>  /* Watch for case of no default printer... return NULL. */ <br>  if (dwNeeded == 0) return NULL; <br> <br>  pi2 = LocalAlloc (LPTR, dwNeeded); <br> <br>  /* Now actually get the information, and create an HDC if successful. */ <br>  if (EnumPrinters (PRINTER_ENUM_DEFAULT | PRINTER_ENUM_LOCAL, <br>                 NULL, 2, <br>                 (LPBYTE) pi2, dwNeeded, <br>                 &amp;dwNeeded, &amp;dwReturned)) { <br> <br>    hdc = CreateDC (pi2-&gt;pDriverName, pi2-&gt;pPrinterName, pi2-&gt;pPortName, NULL); <br>  } else { <br>    MessageBox (NULL, szEnumPrinterR, szMBERROR,MBERRORFLAGS); <br>    hdc = NULL; <br>  } <br> <br>  /* Free memory */ <br>  LocalFree (LocalHandle (pi2)); <br> <br>  return hdc; <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  AllFontsWndProc <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  global variables: <br>*   hwndMain - Main window.  place to return focus. <br>* <br>* Create array of structures which contain, among other things, bitmap <br>*  strips containing the face names of fonts.  These strips are later <br>*  scrolled back and forth as well as selected with the mouse. <br>* <br>\**************************************************************************/ <br>LRESULT CALLBACK AllFontsWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>RECT rectClient; <br>int i,j; <br>int thumbpos; <br>int nStrips; <br>PARFONTS parFonts; <br>int nFaces; <br> <br> <br>  /* Get the pointer out of the userdata extra bytes.  */ <br>  parFonts = (PARFONTS) GetWindowLong (hwnd, GWLU_PARFONTS); <br>  nFaces   =            GetWindowLong (hwnd, GWLU_NFACES); <br> <br>  if ((parFonts == NULL) &amp;&amp; (message != WMU_CREATE)) <br>    return (DefMDIChildProc(hwnd, message, wParam, lParam)); <br> <br>  switch (message) { <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_CREATE <br>    * <br>    * USER create message (sent after the window is created, before it <br>    *  is shown for the first time).  Use this rather than WM_CREATE because <br>    *  we want to have control over the message parameters. <br>    * <br>    * wParam - HDC which we build the font list for. <br>    * <br>    * First build the 2d variable arrays of fonts (c.f. BuildFontList), then <br>    *  create the bitmap strips (stored in HDCs in ARFONT structures), <br>    *  Set the parFonts pointer into the extra bytes for use by other messages. <br>    \**********************************************************************/ <br>    case WMU_CREATE: { <br>      int rightPos; <br>      HDC hdc; <br> <br>      hdc = (HDC) wParam; <br> <br>      GetClientRect (hwnd, &amp;rectClient); <br>      InflateRect (&amp;rectClient, 0, -ALLFONTBORDER); <br> <br>      parFonts = BuildFontList (hdc, &amp;nFaces); <br> <br>      BuildBitmapStrips (hwnd, &amp;rectClient, parFonts, nFaces); <br> <br>      SetWindowLong (hwnd, GWLU_PARFONTS, (LONG) parFonts); <br>      SetWindowLong (hwnd, GWLU_NFACES,   nFaces); <br> <br>      /* Compute the number of bitmap strips visible in the window. <br>       * set the scroll bar range, <br>       * or make it invisible if there are not enough fonts to justify. <br>       */ <br>      nStrips = (rectClient.right - rectClient.left) /CXDEF + 1; <br>      if (nFaces &gt; nStrips) { <br>        rightPos = nFaces - nStrips + 1; <br>        SetScrollRange (hwnd, SB_HORZ, 0, rightPos, FALSE); <br>      } else { <br>        SetScrollRange (hwnd, SB_HORZ, 0, 0, FALSE); <br>      } <br> <br>    } break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_DESTROY <br>    * <br>    * Free up the memory allocated at create time.  Notice that parFonts <br>    *  is allocated in BuildFontList, as are its subarrays. <br>    \**********************************************************************/ <br>    case WM_DESTROY: <br>      for (i= 0; i&lt;nFaces; i++) { <br>        LocalFree ( LocalHandle ((LPVOID)parFonts[i].lf   )); <br>        LocalFree ( LocalHandle ((LPVOID)parFonts[i].tm   )); <br>        LocalFree ( LocalHandle ((LPVOID)parFonts[i].Type )); <br>        DeleteDC (parFonts[i].hdc); <br>      } <br>      /* also get the final, blank one */ <br>      DeleteDC (parFonts[nFaces].hdc); <br> <br>      LocalFree ( LocalHandle ((LPVOID)parFonts)); <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_HSCROLL <br>    * <br>    * Slide the contents of the window back and forth.  Notice that the <br>    *  scroll bar thumb position is important for painting and hit testing. <br>    \**********************************************************************/ <br>    case WM_HSCROLL: <br>      /* compute number of strips for page scrolling. */ <br>      GetClientRect (hwnd, &amp;rectClient); <br>      nStrips = (rectClient.right - rectClient.left) /CXDEF + 1; <br> <br>      switch (LOWORD(wParam)){ <br>        int OldPos, NewPos; <br> <br>        case SB_LINEDOWN: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          SetScrollPos (hwnd, SB_HORZ, (OldPos+1), TRUE); <br>          NewPos = GetScrollPos (hwnd, SB_HORZ); <br>          ScrollWindow (hwnd, (OldPos-NewPos)*CXDEF, 0, NULL, NULL); <br>        break; <br> <br>        case SB_PAGEDOWN: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          SetScrollPos (hwnd, SB_HORZ, (OldPos+(nStrips-1)), TRUE); <br>          NewPos = GetScrollPos (hwnd, SB_HORZ); <br>          ScrollWindow (hwnd, (OldPos-NewPos)*CXDEF, 0, NULL, NULL); <br>        break; <br> <br>        case SB_LINEUP: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          SetScrollPos (hwnd, SB_HORZ, (OldPos-1), TRUE); <br>          NewPos = GetScrollPos (hwnd, SB_HORZ); <br>          ScrollWindow (hwnd, (OldPos-NewPos)*CXDEF, 0, NULL, NULL); <br>        break; <br> <br>        case SB_PAGEUP: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          SetScrollPos (hwnd, SB_HORZ, (OldPos-(nStrips-1)), TRUE); <br>          NewPos = GetScrollPos (hwnd, SB_HORZ); <br>          ScrollWindow (hwnd, (OldPos-NewPos)*CXDEF, 0, NULL, NULL); <br>        break; <br> <br>        case SB_THUMBPOSITION: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          NewPos = HIWORD (wParam); <br>          SetScrollPos (hwnd, SB_HORZ, NewPos, TRUE); <br>          ScrollWindow (hwnd, (OldPos-NewPos)*CXDEF, 0, NULL, NULL); <br>        break; <br> <br>      } <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_LBUTTONDOWN <br>    * <br>    * Hittest based on the mouse position.  When finished, hide the window. <br>    \**********************************************************************/ <br>    case WM_LBUTTONDOWN: { <br>      POINT mousePt; <br> <br>      mousePt.x = LOWORD(lParam); <br>      mousePt.y = HIWORD(lParam); <br> <br>      mousePt.x -= 0; <br>      mousePt.y -= ALLFONTBORDER; <br> <br>      i = mousePt.x / CXDEF; <br>      i += GetScrollPos (hwnd, SB_HORZ); <br>      if (i &lt; 0) i = 0; <br>      if (i &gt;= nFaces) i = (nFaces-1); <br> <br>      j = mousePt.y / parFonts[i].cySpace; <br>      if (j &lt; 0) j = 0; <br>      if (j &gt;= parFonts[i].nFonts) j = (parFonts[i].nFonts-1); <br> <br>      ShowWindow(hwnd, SW_MINIMIZE); <br>      UpdateWindow(hwndMain); <br>      flyWinWin(hwndMain,  hwnd, hwndDlgLF, 40); <br>      SendMessage (hwndDlgLF, WMU_DEMOTOLF, 0,(LONG) &amp;(parFonts[i].lf[j])); <br> <br>      flyWinWin(hwndMain,  hwnd, hwndDlgTM, 40); <br>      SendMessage (hwndDlgTM, WMU_DEMOTOTM, 0,(LONG) &amp;(parFonts[i].tm[j])); <br>      SetFocus (hwndMain); <br> <br>    }break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_RBUTTONDOWN, WM_CHAR <br>    * <br>    * Put the window away without changing the LOGFONT or TEXTMETRIC dlgs. <br>    \**********************************************************************/ <br>    case WM_RBUTTONDOWN: <br>    case WM_CHAR       : <br>      ShowWindow(hwnd, SW_MINIMIZE); <br>      SetFocus (hwndMain); <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PAINT <br>    * <br>    * Using the HDCs stored in the parFonts array, blt enough strips of <br>    *  font family names to cover the window. <br>    \**********************************************************************/ <br>    case WM_PAINT : { <br>      PAINTSTRUCT ps; <br>      HDC hdc; <br>      int iStrip; <br> <br>      if (parFonts == NULL)  break; <br> <br>      GetClientRect (hwnd, &amp;rectClient); <br>      hdc = BeginPaint(hwnd, &amp;ps); <br> <br>      thumbpos = GetScrollPos (hwnd, SB_HORZ); <br> <br>      nStrips = (rectClient.right - rectClient.left) /CXDEF + 1; <br> <br>      for (iStrip= 0; iStrip&lt;nStrips; iStrip++) <br>          BitBlt (hdc, iStrip*CXDEF,0, <br>                  CXDEF, <br>                  (rectClient.bottom - rectClient.top), <br>                  parFonts[iStrip+thumbpos].hdc, 0,0, SRCCOPY); <br> <br> <br>      EndPaint (hwnd, &amp;ps); <br>    } break; <br> <br> <br>    default: break; <br>    } /* end switch */ <br> <br>  return (DefMDIChildProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  DrawBitmapXY() <br>* <br>*  input parameters:  HDC, HBITMAP, <br>*   X, Y - destination position.  (get width and height from hbitmap) <br>* <br>*  Draw the bitmap into the hdc.  Source rectangle computed to include the <br>*   whole bitmap. <br>* <br>*  global variables: none. <br>* <br>\**************************************************************************/ <br>VOID DrawBitmapXY (HDC hdc, HBITMAP hbm, int x, int y) <br>{ <br>    BOOL f; <br>    HDC hdcBits; <br>    BITMAP bm; <br> <br>    hdcBits = CreateCompatibleDC(hdc); <br>    GetObject (hbm, sizeof(BITMAP), &amp;bm); <br>    SelectObject(hdcBits,hbm); <br>    f = BitBlt(hdc,x,y,bm.bmWidth, bm.bmHeight,hdcBits,0,0,SRCCOPY); <br>    DeleteDC(hdcBits); <br>} <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  BuildBitmapStrips <br>* <br>*  input parameters: <br>*   hwnd - window this will all be painted on some day, needed for GetDC <br>*   lprectClient - Pointer to client window rect, bitmap strips are this high <br>*   parFonts - array with all the font information. <br>*   nFaces - number of face names (array size of parFonts). <br>* <br>* Once the fonts have all been queried, create bitmaps and HDCs for them, and <br>*  draw the different fonts into the different bitmap strips. <br>\**************************************************************************/ <br>VOID BuildBitmapStrips (HWND hwnd, LPRECT lprectClient, <br>                        PARFONTS parFonts, int nFaces) <br>{ <br>int     i,j; <br>HFONT   hNewFont; <br>HBITMAP hbm; <br>HBITMAP hbmtt, hbmdevice; <br>RECT    rectClip, rectStrip; <br>HDC     hdc; <br>int     height; <br>int     rightshift; <br> <br>  /* load 2 bitmaps used to "tag" true type and printer fonts. */ <br>  hbmtt =     LoadBitmap (hInst, TEXT("bmtt")); <br>  hbmdevice = LoadBitmap (hInst, TEXT("bmdevice")); <br> <br>  /* establish bounds of vertical strip that all fonts are drawn into. */ <br>  hdc              = GetDC (hwnd); <br>  rectStrip.left   = rectStrip.top =0; <br>  rectStrip.right  = CXDEF; <br>  rectStrip.bottom = (lprectClient-&gt;bottom - lprectClient-&gt;top); <br> <br> <br>  /* step through all of the face names.  For each one, compute the cySpace- <br>   *  i.e. number of pixels per entry.  also create a memory DC that we can <br>   *  draw the font into.  This DC provides the STRIP later blt'ed out at <br>   *  paint time. <br>   */ <br>  for (i= 0; i&lt;nFaces; i++) { <br>    parFonts[i].cySpace = rectStrip.bottom / parFonts[i].nFonts; <br>    parFonts[i].hdc     = CreateCompatibleDC (hdc); <br> <br>    /* When there is only one font, then make a small bitmap.  If there <br>     * is more than one, then make a bitmap the whole height of the window. <br>     */ <br>    height = (parFonts[i].nFonts == 1) ? <br>      parFonts[i].lf[0].lfHeight + ALLFONTBORDER : <br>      rectStrip.bottom; <br>    hbm = CreateCompatibleBitmap (hdc, rectStrip.right,height); <br> <br>    SelectObject (parFonts[i].hdc, hbm); <br>    FillRect (parFonts[i].hdc, &amp;rectStrip, GetStockObject(WHITE_BRUSH)); <br>    SelectObject (parFonts[i].hdc, GetStockObject(NULL_BRUSH)); <br> <br>    /* step through each font for the face name.  Establish a bounding <br>     *  rectangle for the name, write the name and mark with bitmaps if apropos <br>     */ <br>    for (j = 0; j&lt;parFonts[i].nFonts; j++) { <br>      rectClip.left   = 0; <br>      rectClip.right  = rectClip.left + CXDEF - 5; <br>      rectClip.top    = j*parFonts[i].cySpace+ALLFONTBORDER; <br>      rectClip.bottom = rectClip.top+ parFonts[i].lf[j].lfHeight; <br>      rightshift = 0; <br> <br> <br>      /* for true type fonts, add special bitmap on left, top */ <br>      if (parFonts[i].Type[j] &amp; TRUETYPE_FONTTYPE) { <br>        DrawBitmapXY (parFonts[i].hdc, hbmtt,rectClip.left,rectClip.top); <br>        rightshift = BMSIZE; <br>      } <br> <br> <br>      /* for printer fonts, add printer bitmap on left, shifted down <br>       */ <br>      if (parFonts[i].Type[j] &amp; DEVICE_FONTTYPE) { <br>        DrawBitmapXY (parFonts[i].hdc, hbmdevice,rectClip.left,rectClip.top+ BMSIZE); <br>        rightshift = BMSIZE; <br>      } <br> <br>      /* Create a logical font to draw the face name with */ <br>      hNewFont = CreateFontIndirect (&amp;(parFonts[i].lf[j])); <br>      SelectObject (parFonts[i].hdc, hNewFont); <br> <br>      /* iff bitmap drawn, shift text over to the right. */ <br>      rectClip.left+=rightshift; <br> <br>      /* draw the face name in the rectangle allotted. */ <br>      ExtTextOut (parFonts[i].hdc, <br>                       rectClip.left, rectClip.top, ETO_CLIPPED, <br>                       &amp;rectClip, <br>                       parFonts[i].lf[j].lfFaceName, <br>                       lstrlen(parFonts[i].lf[j].lfFaceName), <br>                       NULL ); <br> <br> <br>      SelectObject (parFonts[i].hdc, GetStockObject (SYSTEM_FONT)); <br>      DeleteObject (hNewFont); <br>    } <br>  } <br> <br>  /* make one final strip on the far right side as a white space buffer */ <br>  hbm = CreateCompatibleBitmap (hdc, rectStrip.right, rectStrip.bottom); <br>  SelectObject (parFonts[nFaces].hdc, hbm); <br>  FillRect (parFonts[nFaces].hdc, &amp;rectStrip, GetStockObject(WHITE_BRUSH)); <br> <br>  ReleaseDC (hwnd, hdc); <br>  DeleteObject (hbmtt); <br>  DeleteObject (hbmdevice); <br>} <br> <br> <br> <br> <br> <br>/* In the callback functions from the enumerations, there is a limited <br> *  ability to pass in parameters.  For that reason, declare the following <br> *  global variables to be used by any of the call back functions. <br> */ <br>HDC      hdcGlobal; <br>PARFONTS parFontsGlobal; <br>int      iFace,jFont; <br>int      nFaces; <br> <br>/* General call structure: <br> * <br> *  BuildFontList() <br> *      EnumFonts <br> *          MyEnumCount() <br> *      LocalAlloc <br> *      EnumFonts <br> *          MyEnumFaces() <br> *              EnumFonts <br> *                  MyEnumCount() <br> *              LocalAlloc <br> *              LocalAlloc <br> *              LocalAlloc <br> *              EnumFonts <br> *                  MyEnumCopy() <br> */ <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  BuildFontList <br>* <br>*  input parameters: <br>*   hdcIn - hdc to query the fonts for. <br>*   retnFaces - (OUT) pointer to nFaces value <br>* <br>* Enumerate all of the fonts for this DC allocating and filling up the <br>*  parFonts structure as needed. <br>\**************************************************************************/ <br>PARFONTS BuildFontList(HDC hdcIn, LPINT retnFaces) <br>{ <br> <br>  nFaces = 0; <br> <br>  /* hdcGlobal is global variable also used by the callback functions. */ <br>  hdcGlobal = hdcIn; <br> <br>  /* count the total number of face names. */ <br>  EnumFonts (hdcGlobal, NULL, (FONTENUMPROC)MyEnumCount, (LPARAM)&amp;nFaces); <br> <br> <br>  /* allocate the pointer to the array of PArFont structures. */ <br>  parFontsGlobal = (PARFONTS)LocalAlloc (LPTR, sizeof(ARFONTS) * (nFaces+1)); <br> <br>  /* step through all fonts again.  For each one fill a LOGFONT and <br>   * a TEXTMETRIC stucture. <br>   */ <br>  iFace = 0; <br>  EnumFonts (hdcGlobal, NULL, (FONTENUMPROC)MyEnumFaces, (LPARAM)NULL); <br> <br>  *retnFaces = nFaces; <br>  return parFontsGlobal; <br>} <br> <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  MyEnumFaces <br>* <br>*  input parameters:  c.f. EnumFonts <br>* <br>* Count the number of fonts for this particular face name.  Allocate the <br>*  LOGFONT and TEXTMETRIC arrays large enough to hold all of them.  Then <br>*  enumerate the fonts once again to fill in these arrays. <br>\**************************************************************************/ <br>int APIENTRY MyEnumFaces( <br>       LPLOGFONT  lpLogFont, <br>       LPTEXTMETRIC lpTEXTMETRICs, <br>       DWORD  fFontType, <br>       LPVOID  lpData) <br>{ <br>int nFonts; <br> <br> <br>  UNREFERENCED_PARAMETER (lpTEXTMETRICs); <br>  UNREFERENCED_PARAMETER (fFontType); <br>  UNREFERENCED_PARAMETER (lpData); <br> <br> <br>  nFonts = 0; <br>  EnumFonts (hdcGlobal, lpLogFont-&gt;lfFaceName, (FONTENUMPROC)MyEnumCount, (LPARAM)&amp;nFonts); <br> <br> <br>  parFontsGlobal[iFace].lf   = (LPLOGFONT)LocalAlloc (LPTR, sizeof(LOGFONT)    * nFonts); <br>  parFontsGlobal[iFace].tm   = (LPTEXTMETRIC)LocalAlloc (LPTR, sizeof(TEXTMETRIC) * nFonts); <br>  parFontsGlobal[iFace].Type = (LPINT)LocalAlloc (LPTR, sizeof(int)        * nFonts); <br> <br>  if ((parFontsGlobal[iFace].lf   == NULL) || <br>      (parFontsGlobal[iFace].tm   == NULL) || <br>      (parFontsGlobal[iFace].Type == NULL)) { <br>    MessageBox (hwndMain, szAllocFailed, szMBERROR,MBERRORFLAGS); <br>    return FALSE; <br>  } <br> <br>  parFontsGlobal[iFace].nFonts = nFonts; <br> <br>  jFont = 0; <br>  EnumFonts (hdcGlobal, lpLogFont-&gt;lfFaceName, (FONTENUMPROC)MyEnumCopy, (LPARAM)NULL); <br> <br>  iFace++; <br> <br>  return TRUE; <br>} <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  MyEnumCopy <br>* <br>*  input parameters:  c.f. EnumFonts <br>* <br>* Each time that this function is called, copy the LOGFONT and TEXTMETRIC <br>*  structures into the proper place in the global arrays.  Incr jFont. <br>\**************************************************************************/ <br>int APIENTRY MyEnumCopy( <br>       LPLOGFONT  lpLogFont, <br>       LPTEXTMETRIC lpTEXTMETRICs, <br>       DWORD  fFontType, <br>       LPVOID  lpData) <br>{ <br>LOGFONT    *lplf; <br>TEXTMETRIC *lptm; <br>int        *pType; <br> <br>  UNREFERENCED_PARAMETER (lpData); <br> <br>  lplf  = parFontsGlobal[iFace].lf; <br>  lptm  = parFontsGlobal[iFace].tm; <br>  pType = parFontsGlobal[iFace].Type; <br> <br>  lplf[jFont]  = *lpLogFont; <br>  lptm[jFont]  = *lpTEXTMETRICs; <br>  pType[jFont] = fFontType; <br> <br>  jFont++; <br>  return TRUE; <br>} <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  MyEnumCount <br>* <br>*  input parameters:  c.f. EnumFonts <br>* <br>* Simply increment the variable that lpData points to. <br>\**************************************************************************/ <br>int APIENTRY MyEnumCount( <br>       LPLOGFONT  lpLogFont, <br>       LPTEXTMETRIC lpTEXTMETRICs, <br>       DWORD  fFontType, <br>       LPINT  lpData) <br>{ <br>    UNREFERENCED_PARAMETER (lpLogFont); <br>    UNREFERENCED_PARAMETER (lpTEXTMETRICs); <br>    UNREFERENCED_PARAMETER (fFontType); <br> <br>    (*lpData)++; <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
