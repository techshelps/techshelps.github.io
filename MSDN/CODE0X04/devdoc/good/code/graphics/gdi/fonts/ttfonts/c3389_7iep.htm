<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3391"></a>DISPLAY.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  display.c -- module for the window with the test font. <br>*   Includes the window procedure and an initialization routine. <br>* <br>* store the handle to the test font in the extra bytes of this window. <br>* <br>* <br>* HORZ_SCROLL used to step through UC ranges when in "all glyphs" mode. <br>* VERT_SCROLL: <br>*   scroll bar range is the total number of lines needed for all glyphs <br>*    minus the number which may be shown in the window. <br>*   scroll bar position is then the first line which is to be drawn. <br>* <br>* <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "ttfonts.h" <br> <br>/* defines for the gridding pattern in background of window */ <br>#define GRIDCOLOR  PALETTEINDEX (3) <br>#define TICKSPACE  10 <br> <br> <br>/* global variables store the start and end codepoints for UC ranges. */ <br>USHORT *endCount= NULL; <br>USHORT *startCount= NULL; <br> <br>int CountUCSegments (HDC); <br>/* error return value from CountUCSegments */ <br>#define SEGMENTERROR -1 <br> <br>HWND   hwndFaceBanner; <br>TCHAR szHello[] = TEXT("Hello"); <br> <br>VOID BlamGlyphs (HDC, PTEXTMETRIC, USHORT, USHORT, PRECT, BOOL); <br> <br> <br> <br>int initDisplay(HWND hwndParent) <br>{ <br>WNDCLASS  wc; <br> <br>  wc.style = CS_VREDRAW | CS_HREDRAW; <br>  wc.lpfnWndProc = (WNDPROC)DisplayWndProc; <br>  wc.cbClsExtra = 0; <br>  wc.cbWndExtra = 0; <br>  wc.hInstance = hInst; <br>  wc.hIcon = LoadIcon(hInst, TEXT("ttfontsIcon")); <br>  wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>  wc.hbrBackground = NULL; <br>  wc.lpszMenuName = NULL; <br>  wc.lpszClassName = TEXT("display"); <br> <br>  if (!RegisterClass(&amp;wc)) return (FALSE); <br> <br>  hwndDisplay = CreateMDIWindow( <br>      TEXT("display"), <br>      TEXT("Display"), <br>      WS_CHILD | WS_CLIPSIBLINGS | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_VISIBLE | <br>                 WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_VSCROLL | WS_HSCROLL, <br>      CHILDLEFT(2), <br>      CHILDTOP, <br>      GetSystemMetrics (SM_CXFULLSCREEN)/3 - 10, <br>      GetSystemMetrics (SM_CYFULLSCREEN)/3, <br>      hwndParent, hInst, 0); <br> <br>  /* create child window to display face name */ <br>  hwndFaceBanner = CreateWindow( <br>        TEXT("STATIC"), TEXT(""), <br>        WS_CHILD | WS_VISIBLE | WS_BORDER, <br>        -1,0, <br>        GetSystemMetrics (SM_CXFULLSCREEN), <br>        GetSystemMetrics (SM_CYMENU), <br>        hwndDisplay, NULL, hInst, NULL); <br> <br>  if (!hwndDisplay) return (FALSE); <br> <br> <br>  return TRUE; <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  DisplayWndProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  global variables: <br>*   gDisplaymode - menu state <br>\**************************************************************************/ <br>LRESULT CALLBACK DisplayWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>static HANDLE hPenGrid; <br>static LPLOGFONT     lplf; <br>static LPTEXTMETRIC  lptm; <br>static HFONT  hfont; <br>static HDC    hdcStatic;  /* Sent to other window procedures. */ <br> <br>static HDC hdc; <br>static RECT rect; <br>static int min, max; <br>static TEXTMETRIC tm; <br>static int iSeg; <br>static TCHAR buffer[100]; <br> <br>static int nCharPerLine, nTotalGlyphs, lineHeight; <br>static int nLinesTotal, nLinesWindow, nLinesDifference; <br>static int scrollRangeHigh, topLineShowing; <br>int i; <br> <br> <br>  switch (message) { <br> <br> <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMOTOLF <br>    * <br>    *  lParam - pointer to LOGFONT structure. <br>    * <br>    * User message.  Fill up the display LOGFONT from the HFONT <br>    *  in the extra bytes. <br>    \**********************************************************************/ <br>    case WMU_DEMOTOLF: { <br>      lplf = (LPLOGFONT) lParam; <br> <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      GetObject (hfont, sizeof(LOGFONT), lplf); <br>    } return 0; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMOTOTM <br>    * <br>    *  lParam - pointer to TEXTMETRIC structure. <br>    * <br>    * User message.  Fill up the TEXTMETRIC from the HFONT <br>    *  in the extra bytes. <br>    \**********************************************************************/ <br>    case WMU_DEMOTOTM: { <br>      lptm = (LPTEXTMETRIC) lParam; <br> <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br> <br>      hdc = GetDC (hwnd); <br>      SelectObject (hdc,hfont); <br>      GetTextMetrics (hdc, lptm); <br>      ReleaseDC (hwnd, hdc); <br>    } return 0; <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMOGETDC <br>    * <br>    * User message.  Return an HDC. <br>    \**********************************************************************/ <br>    case WMU_DEMOGETDC: { <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br> <br>      hdcStatic = GetDC (hwnd); <br>      SelectObject (hdcStatic,hfont); <br>      return (LRESULT)hdcStatic; <br>    } break; <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMORELEASEDC <br>    * <br>    *  lParam - the same HDC returned by WMU_DEMOGETDC <br>    * <br>    * User message.  Release the HDC. <br>    \**********************************************************************/ <br>    case WMU_DEMORELEASEDC: { <br>      hdcStatic = (HDC) lParam; <br>      ReleaseDC (hwnd, hdcStatic); <br>    } return 0; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_HFONTTODEMO <br>    * <br>    *  lParam - hFont <br>    * <br>    * User message.  Use the input HFONT to set a new <br>    *  font for this window.  Store the new font in the HFONT extra bytes. <br>    \**********************************************************************/ <br>    case WMU_HFONTTODEMO: { <br>      /* Get and delete the last font placed in this window. */ <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      DeleteObject (hfont); <br> <br>      hfont = (HFONT) lParam; <br>      SetWindowLong (hwnd, GWL_USERDATA, (LONG) hfont); <br> <br>      /* make sure that scroll metrics are ok */ <br>      switch (gDisplaymode) { <br>        case IDM_MODEHELLO:   SendMessage (hwnd, WMU_NEWMODEHELLO, 0,0); <br>          break; <br>        case IDM_MODETMRANGE: SendMessage (hwnd, WMU_NEWMODETMRANGE, 0,0); <br>          break; <br>        case IDM_MODEALL: <br>          if (!SendMessage (hwndDisplay, WMU_NEWMODEALL, 0,0)) { <br>            MessageBox (NULL, szResetDisplay, szMBERROR, MBERRORFLAGS); <br>            SendMessage (hwndMain, WM_COMMAND, IDM_MODEHELLO, 0); <br>            return 0; <br>          } <br>          break; <br>      } /* end switch */ <br> <br>      InvalidateRect (hwnd, NULL, TRUE); <br>    } return 0; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_NEWFONT <br>    * <br>    *  lParam - pointer to LOGFONT structure. <br>    * <br>    * User message.  Use the input LOGFONT structure to create a new <br>    *  font for this window.  Send a WMU_HFONTTODEMO message to set the <br>    *  font into the extra bytes for the window. <br>    \**********************************************************************/ <br>    case WMU_NEWFONT: { <br>      lplf = (LPLOGFONT) lParam; <br> <br>      /* Create a new logical font and set it into the windows extra bytes. */ <br>      hfont = CreateFontIndirect (lplf); <br> <br>      SendMessage (hwnd, WMU_HFONTTODEMO, 0, (LPARAM) hfont); <br>    } return 0; <br> <br> <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_CREATE <br>    * <br>    * Create pens for drawing with later. <br>    \**********************************************************************/ <br>    case WM_CREATE: <br>      hPenGrid   = CreatePen (PS_SOLID, 1, GRIDCOLOR); <br>      SetWindowLong (hwnd, GWL_USERDATA, (LONG) GetStockObject (SYSTEM_FONT)); <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_DESTROY <br>    * <br>    * Complement of the WM_CREATE message.  Delete the pens that were <br>    *  created, free startCount, endCount arrays. <br>    * <br>    \**********************************************************************/ <br>    case WM_DESTROY: <br>      DeleteObject (hPenGrid); <br>      if (startCount != NULL) LocalFree (LocalHandle (startCount)); <br>      if (endCount != NULL) LocalFree (LocalHandle (endCount)); <br>    break; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_ERASEBKGND <br>    * <br>    * Offset the origin conditional on gDisplaymode.  Grid the window. <br>    \**********************************************************************/ <br>    case WM_ERASEBKGND: { <br>      HDC hdc; <br>      RECT rect; <br>      int i; <br> <br>      hdc = (HDC)wParam; <br> <br>      GetClientRect (hwnd, &amp;rect); <br>      FillRect (hdc, &amp;rect, GetStockObject (LTGRAY_BRUSH)); <br> <br>      if (gDisplaymode == IDM_MODEHELLO) { <br>        SetViewportOrgEx (hdc, rect.right /2, rect.bottom/2, NULL); <br>        OffsetRect (&amp;rect, -rect.right/2, -rect.bottom/2); <br> <br>        SelectObject(hdc, hPenGrid); <br>        /* Draw vertical lines.  */ <br>        for (i = 0; i&lt;= rect.right; i+=TICKSPACE){ <br>          MoveToEx (hdc, i, rect.top, NULL); <br>          LineTo (hdc, i, rect.bottom); <br>          MoveToEx (hdc, -i, rect.top, NULL); <br>          LineTo (hdc, -i, rect.bottom); <br>        } <br>        MoveToEx (hdc, 1, rect.top, NULL); <br>        LineTo (hdc, 1, rect.bottom); <br> <br>        /* Draw horizontal lines.  */ <br>        for (i = 0; i&lt;= rect.bottom; i+=TICKSPACE){ <br>          MoveToEx (hdc, rect.left,i, NULL); <br>          LineTo (hdc, rect.right,i); <br>          MoveToEx (hdc, rect.left,-i, NULL); <br>          LineTo (hdc, rect.right,-i); <br>        } <br>        MoveToEx (hdc, rect.left, 1, NULL); <br>        LineTo (hdc, rect.right,1); <br> <br>      } <br> <br> <br>    } return TRUE; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_VSCROLL <br>    * <br>    * Slide the contents of the window up and down.  Notice that the <br>    *  scroll bar thumb position is important for painting. <br>    \**********************************************************************/ <br>    case WM_VSCROLL: <br> <br>      switch (LOWORD(wParam)){ <br>        int OldPos, NewPos; <br> <br>        case SB_PAGEDOWN: <br>        case SB_LINEDOWN: <br>          OldPos = GetScrollPos (hwnd, SB_VERT); <br>          SetScrollPos (hwnd, SB_VERT, (OldPos+1), TRUE); <br>          NewPos = GetScrollPos (hwnd, SB_VERT); <br>          ScrollWindow (hwnd, 0,(OldPos-NewPos)*lineHeight, NULL, NULL); <br>        break; <br> <br>        case SB_PAGEUP: <br>        case SB_LINEUP: <br>          OldPos = GetScrollPos (hwnd, SB_VERT); <br>          SetScrollPos (hwnd, SB_VERT, (OldPos-1), TRUE); <br>          NewPos = GetScrollPos (hwnd, SB_VERT); <br>          ScrollWindow (hwnd, 0,(OldPos-NewPos)*lineHeight, NULL, NULL); <br>        break; <br> <br>        case SB_THUMBPOSITION: <br>          OldPos = GetScrollPos (hwnd, SB_VERT); <br>          NewPos = HIWORD (wParam); <br>          SetScrollPos (hwnd, SB_VERT, NewPos, TRUE); <br>          ScrollWindow (hwnd, 0, (OldPos-NewPos)*lineHeight, NULL, NULL); <br>        break; <br> <br>      } <br>    break; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_HSCROLL <br>    * <br>    * The horz scroll should only be present when in MODEALL. <br>    * Step through the allglyphs ranges. <br>    * In every case, inform the window the range has changed, <br>    *  and invalidate it to force a repaint. <br>    \**********************************************************************/ <br>    case WM_HSCROLL: <br> <br>      switch (LOWORD(wParam)){ <br>        int OldPos, NewPos; <br> <br>        case SB_PAGEDOWN: <br>        case SB_LINEDOWN: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          SetScrollPos (hwnd, SB_HORZ, (OldPos+1), TRUE); <br>          SendMessage (hwnd,WMU_NEWMODE_NEWSEG, 0,0); <br>          InvalidateRect (hwnd, NULL, TRUE); <br>        break; <br> <br>        case SB_PAGEUP: <br>        case SB_LINEUP: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          SetScrollPos (hwnd, SB_HORZ, (OldPos-1), TRUE); <br>          SendMessage (hwnd,WMU_NEWMODE_NEWSEG, 0,0); <br>          InvalidateRect (hwnd, NULL, TRUE); <br>        break; <br> <br>        case SB_THUMBPOSITION: <br>          OldPos = GetScrollPos (hwnd, SB_HORZ); <br>          NewPos = HIWORD (wParam); <br>          SetScrollPos (hwnd, SB_HORZ, NewPos, TRUE); <br>          SendMessage (hwnd,WMU_NEWMODE_NEWSEG, 0,0); <br>          InvalidateRect (hwnd, NULL, TRUE); <br>        break; <br> <br>      } <br> <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    * WMU_NEWMODEALL <br>    * <br>    *   returns - TRUE if a scalable font file. <br>    *             FALSE if GetFontData fails. <br>    * <br>    * This message is sent one time when the user checks "Show all glyphs." <br>    *  Here we set up the horizontal scroll bar, and the start/endCount arrays. <br>    \**********************************************************************/ <br>    case WMU_NEWMODEALL: { <br>      HDC hdc; <br>      int nSegments; <br> <br>      SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>      hdc = GetDC(hwnd); <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      SelectObject (hdc,hfont); <br>      nSegments = CountUCSegments (hdc); /* slow computation */ <br>      ReleaseDC (hwnd, hdc); <br>      SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br>      if (nSegments == SEGMENTERROR) return FALSE; <br> <br>      gDisplaymode =IDM_MODEALL; <br>      ShowWindow (hwndFaceBanner, SW_HIDE); <br> <br>      SetScrollRange (hwnd, SB_HORZ, 0, (nSegments-1), TRUE); <br>      SetScrollPos (hwnd, SB_HORZ, 0, TRUE); <br> <br>      SendMessage (hwndDisplay, WMU_NEWMODE_NEWSEG, 0,0); <br>      return TRUE; <br> <br>    } break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_NEWMODEHELLO <br>    *  WMU_NEWMODETMRANGE <br>    *  WMU_NEWMODE_NEWSEG <br>    * <br>    * <br>    * Sent every time an event occurs which will change the layout of <br>    *  the display glyphs.  I.e. <br>    *       window resized. <br>    *       display mode switch <br>    *       allglyph display mode, next range <br>    * <br>    * Be careful because the SetScrollRange() may cause a new WM_SIZE <br>    *  which in turn will cause this message to be resent. <br>    * <br>    \**********************************************************************/ <br>    case WMU_NEWMODEHELLO: <br>      /* Set the window title text. */ <br>      SetWindowText (hwnd, TEXT("Display")); <br> <br>      gDisplaymode =IDM_MODEHELLO; <br>      ShowWindow (hwndFaceBanner, SW_SHOW); <br> <br>      SetScrollRange (hwnd, SB_HORZ, 0, 0, TRUE); <br>      SetScrollRange (hwnd, SB_VERT, 0, 0, TRUE); <br>    break; <br> <br> <br>    case WMU_NEWMODETMRANGE: { <br>      /* Set the window title text. */ <br>      SetWindowText (hwnd, TEXT("Display [tmFirstChar, tmLastChar]")); <br> <br>      gDisplaymode =IDM_MODETMRANGE; <br>      ShowWindow (hwndFaceBanner, SW_HIDE); <br> <br>      SetScrollRange (hwnd, SB_HORZ, 0, 0, TRUE); <br> <br>      hdc = GetDC(hwnd); <br>      GetClientRect (hwnd, &amp;rect); <br> <br>      /* subtract off the scroll width if it is NOT there. <br>       *  (if it is, it will be automatically excluded by GetClientRect) <br>       *  if it is not there, it may be added, and we want space for it. <br>       */ <br>      GetScrollRange (hwnd, SB_VERT, &amp;min, &amp;max); <br>      if (min == max) rect.right -= GetSystemMetrics (SM_CXVSCROLL); <br> <br>      /* select the font into the window to get text metrics for. */ <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      SelectObject (hdc,hfont); <br>      GetTextMetrics (hdc, &amp;tm); <br> <br>      nCharPerLine = rect.right / tm.tmAveCharWidth; <br>      nTotalGlyphs = tm.tmLastChar-tm.tmFirstChar; <br>      lineHeight = tm.tmHeight + tm.tmExternalLeading; <br>      nLinesTotal = nTotalGlyphs / nCharPerLine; <br>      nLinesWindow = rect.bottom / lineHeight; <br>      nLinesDifference = nLinesTotal - nLinesWindow; <br>      scrollRangeHigh = nLinesTotal - nLinesWindow; <br> <br>      /* reset the scroll bar range.  If there is no need for one, <br>       *  then set the position to 0, and the range to 0,0 and it <br>       *  will not be visisble. <br>       */ <br>      if (nLinesDifference &gt;0) { <br>        SetScrollRange (hwnd, SB_VERT, 0, (nLinesDifference +1), TRUE); <br>      } else { <br>        SetScrollPos (hwnd, SB_VERT, 0, TRUE); <br>        SetScrollRange (hwnd, SB_VERT, 0, 0, TRUE); <br>      } <br> <br>      ReleaseDC (hwnd, hdc); <br>    } return FALSE; <br> <br> <br> <br>    case WMU_NEWMODE_NEWSEG: { <br>      gDisplaymode =IDM_MODEALL; <br>      SetScrollPos (hwnd, SB_VERT, 0, TRUE); <br> <br>      hdc = GetDC(hwnd); <br>      GetClientRect (hwnd, &amp;rect); <br> <br>      /* subtract off the scroll width if it is NOT there. <br>       *  (if it is, it will be automatically excluded by GetClientRect) <br>       *  if it is not there, it may be added, and we want space for it. <br>       */ <br>      GetScrollRange (hwnd, SB_VERT, &amp;min, &amp;max); <br>      if (min == max) rect.right -= GetSystemMetrics (SM_CXVSCROLL); <br> <br> <br>      /* select the font into the window to get text metrics for. */ <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      SelectObject (hdc,hfont); <br>      GetTextMetrics (hdc, &amp;tm); <br> <br> <br>      iSeg = GetScrollPos (hwnd, SB_HORZ); <br> <br>      /* Set the window title text to show display range. */ <br>      wsprintf (buffer, TEXT("Display [%04x, %04x]"), <br>                                  (int)startCount[iSeg], <br>                                  (int)endCount[iSeg]); <br>      SetWindowText (hwnd, buffer); <br> <br> <br> <br> <br>      nTotalGlyphs = endCount[iSeg] - startCount[iSeg]; <br> <br>      nCharPerLine = rect.right / tm.tmAveCharWidth; <br>      nLinesTotal = nTotalGlyphs / nCharPerLine; <br> <br>      lineHeight = tm.tmHeight + tm.tmExternalLeading; <br>      nLinesWindow = rect.bottom / lineHeight; <br>      nLinesDifference = nLinesTotal - nLinesWindow; <br>      scrollRangeHigh = nLinesTotal - nLinesWindow; <br> <br>      /* reset the scroll bar range.  If there is no need for one, <br>       *  then set the position to 0, and the range to 0,0 and it <br>       *  will not be visisble. <br>       */ <br>      if (nLinesDifference &gt;0) { <br>        SetScrollRange (hwnd, SB_VERT, 0, (nLinesDifference +1), FALSE); <br>      } else { <br>        SetScrollPos (hwnd, SB_VERT, 0, TRUE); <br>        SetScrollRange (hwnd, SB_VERT, 0, 0, TRUE); <br>      } <br> <br>      ReleaseDC (hwnd, hdc); <br>    } return FALSE; <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_SIZE <br>    * <br>    \**********************************************************************/ <br>    case WM_SIZE: <br>      /* make sure that scroll metrics are ok */ <br>      switch (gDisplaymode) { <br>        case IDM_MODEHELLO:   SendMessage (hwnd, WMU_NEWMODEHELLO, 0,0); <br>          break; <br>        case IDM_MODETMRANGE: SendMessage (hwnd, WMU_NEWMODETMRANGE, 0,0); <br>          break; <br>        case IDM_MODEALL:     SendMessage (hwnd, WMU_NEWMODE_NEWSEG, 0,0); <br>          break; <br>      } /* end switch */ <br> <br>    break;  /* fall through to MDIChildProc */ <br> <br> <br>    /**********************************************************************\ <br>    *  WM_PAINT <br>    * <br>    * Offset the origin conditional on gDisplaymode.  Write the "Hello" <br>    *  string, or step though all of the glyphs (from TEXTMETRIC.tmFirstChar <br>    *  to TEXTMETRIC.tmLastChar), or paint all of the glyphs in the UC segment. <br>    \**********************************************************************/ <br>    case WM_PAINT: { <br>      HDC hdc; <br>      PAINTSTRUCT ps; <br>      RECT rect; <br> <br>      hdc = BeginPaint(hwnd, &amp;ps); <br> <br> <br>      GetClientRect (hwnd, &amp;rect); <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      SelectObject (hdc,hfont); <br>      SetBkMode (hdc, TRANSPARENT); <br>      SetTextAlign (hdc, TA_LEFT | TA_TOP | TA_UPDATECP); <br>      GetTextMetrics (hdc, &amp;tm); <br>      MoveToEx (hdc, 0,0, NULL); <br> <br> <br>      switch (gDisplaymode) { <br>        case IDM_MODEHELLO: { <br>          TCHAR szFace[LF_FACESIZE+2]; <br>          TCHAR szBuffer[LF_FACESIZE+100]; <br>          SIZE  ExtentSize; <br> <br>          SetViewportOrgEx (hdc, rect.right /2, rect.bottom/2, NULL); <br>          TextOut (hdc, 0, 0, szHello, lstrlen (szHello)); <br>          GetTextFace (hdc, LF_FACESIZE+2, szFace); <br>          GetTextExtentPoint (hdc, szHello, lstrlen (szHello), &amp;ExtentSize); <br>          wsprintf (szBuffer, <br>                    TEXT("GetTextFace: \"%s\",  GetTextExtentPoint: (%d, %d)"), <br>                    szFace, ExtentSize.cx, ExtentSize.cy); <br> <br>          SetWindowText (hwndFaceBanner, szBuffer); <br>        } break; <br> <br>        case IDM_MODETMRANGE: { <br>          USHORT start, end; <br> <br>          topLineShowing= GetScrollPos (hwnd, SB_VERT); <br>          start = tm.tmFirstChar; <br>          start += (topLineShowing * nCharPerLine); <br>          end = tm.tmLastChar; <br>          BlamGlyphs (hdc, &amp;tm, start, end, &amp;rect, FALSE); <br> <br>        } break; <br> <br>        case IDM_MODEALL: { <br>          USHORT start, end; <br> <br>          iSeg= GetScrollPos (hwnd, SB_HORZ); <br>          topLineShowing = GetScrollPos (hwnd, SB_VERT); <br>          start = startCount[iSeg]; <br>          start += (topLineShowing * nCharPerLine); <br>          end = endCount[iSeg]; <br> <br>          BlamGlyphs (hdc, &amp;tm, start, end, &amp;rect, FALSE); <br>        } break; <br> <br>      } /* end switch */ <br> <br> <br> <br> <br>      EndPaint (hwnd, &amp;ps); <br> <br>    } return FALSE; /* end WM_PAINT */ <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_PRINT <br>    * <br>    * user message.  Get an HDC for the printer, send it formatted <br>    *  output based on the mode of the display window. <br>    \**********************************************************************/ <br>    case WMU_PRINT: { <br>      HDC hdc; <br>      RECT rect; <br>      POINT point; <br>      int nchar; <br>      int ScrollMin, ScrollMax; <br>      UINT cbData; <br>      DOCINFO di; <br>      di.cbSize      = sizeof(DOCINFO); <br>      di.lpszDocName = TEXT("ttfonts"); <br>      di.lpszOutput  = NULL; <br> <br> <br>      SetCursor (LoadCursor (NULL, IDC_WAIT)); <br> <br>      hdc = GetPrinterDC(); <br>      if (hdc == NULL) return 0; <br>      StartDoc  (hdc, &amp;di); <br>      StartPage (hdc); <br> <br> <br>      hfont = (HFONT) GetWindowLong (hwnd, GWL_USERDATA); <br>      SelectObject (hdc,hfont); <br>      rect.top = rect.left = 0; <br>      rect.right = GetDeviceCaps (hdc, HORZRES); <br>      rect.bottom = GetDeviceCaps (hdc, VERTRES); <br>      SetBkMode (hdc, TRANSPARENT); <br>      SetTextAlign (hdc, TA_LEFT | TA_TOP | TA_UPDATECP); <br>      GetTextMetrics (hdc, &amp;tm); <br> <br>      /* write a little banner at the top */ <br>      MoveToEx (hdc, 0,0, NULL); <br>      TextOut (hdc, 0,0,TEXT ("ttfonts -- "), 11); <br> <br>      cbData = GetOutlineTextMetrics (hdc, 0, NULL); <br>      if (cbData == 0) { <br>        TextOut (hdc, 0,0, szFontDataErr, <br>                lstrlen(szFontDataErr)); <br>      } else { <br>        LPOUTLINETEXTMETRIC lpoltm; <br>        LPBYTE lptStr; <br> <br>        lpoltm = (LPOUTLINETEXTMETRIC)LocalAlloc (LPTR, cbData); <br>        GetOutlineTextMetrics (hdc, cbData, lpoltm); <br> <br>        lptStr = (LPBYTE)lpoltm; <br>        lptStr += (UINT) (PBYTE) lpoltm-&gt;otmpFamilyName; <br>        TextOut (hdc, 0,0, (LPCTSTR) lptStr, lstrlen((LPCTSTR)lptStr)); <br>        LocalFree (LocalHandle (lpoltm)); <br>      } <br> <br>      /* Draw a thick line, and leave the cursor in the right place. */ <br>      GetCurrentPositionEx (hdc, &amp;point);  /* fill point */ <br>      point.x = rect.right; <br>      point.y += tm.tmHeight; <br>      for (i = 0; i&lt;5; i++) { <br>        MoveToEx (hdc, point.x, point.y, NULL); <br>        LineTo (hdc, 0, point.y); <br>        point.y++; <br>      } <br> <br> <br>      switch (gDisplaymode) { <br>        case IDM_MODEHELLO: <br>          SetViewportOrgEx (hdc, rect.right /2, rect.bottom/2, NULL); <br>          TextOut (hdc, 0, 0, szHello, lstrlen (szHello)); <br>        break; <br> <br> <br>        case IDM_MODETMRANGE: <br>          BlamGlyphs (hdc, &amp;tm, tm.tmFirstChar, tm.tmLastChar, &amp;rect, TRUE); <br>        break; <br> <br>        case IDM_MODEALL: <br>          /* the horz scroll bar has the number of segments stored as <br>           *  the scroll bar range, query and use it. <br>           */ <br>          GetScrollRange (hwnd, SB_HORZ, &amp;ScrollMin, &amp;ScrollMax); <br> <br>          for (i = 0; i&lt;= ScrollMax; i++) { <br>            MoveToEx (hdc,rect.right, point.y, NULL); <br>            LineTo (hdc, rect.left, point.y); <br> <br>            SelectObject (hdc,GetStockObject (DEVICE_DEFAULT_FONT)); <br>            nchar = wsprintf (buffer, TEXT("[%04x, %04x]"), (int)startCount[i], <br>                                                      (int)endCount[i]); <br>            TextOut (hdc, 0,0,buffer, nchar); <br>            SelectObject (hdc,hfont); <br> <br> <br>            BlamGlyphs (hdc, &amp;tm, startCount[i], endCount[i], &amp;rect, TRUE); <br> <br>            GetCurrentPositionEx (hdc, &amp;point); <br>            point.x = 0; <br>            point.y += (tm.tmHeight + tm.tmExternalLeading); <br>            MoveToEx (hdc, point.x, point.y, NULL); <br>            if ((point.y+tm.tmHeight+tm.tmExternalLeading) &gt; rect.bottom) { <br>              point.x = point.y = 0; <br>              EndPage   (hdc); <br>              StartPage (hdc); <br>              MoveToEx (hdc, point.x, point.y, NULL); <br>            } <br>          } <br>        break;  /* end IDM_MODEALL */ <br>      } /* end switch */ <br> <br>      EndPage   (hdc); <br>      EndDoc    (hdc); <br> <br>      DeleteDC (hdc); <br>      SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br>    } return TRUE; <br> <br>  } /* end switch */ <br> <br>  return (DefMDIChildProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  BlamGlyphs <br>* <br>*  input parameters: <br>*   hdc with font selected into it. <br>*   pointer to a text metric structure. <br>*   start and end of code point range to print <br>*   pointer to rectangle which serves as bounds. <br>* <br>*  Starting at the current point, write one glyph after the other, starting <br>*   with the "Start" parameter, and ending with the "End" parameter.  If <br>*   the next character will overrun on the right, start again on a new line. <br>*  Special case Start = 0xfff which happens because the start/endCount <br>*   arrays always end with this value. <br>* <br>* <br>  // UNICODE NOTICE <br>  //  This function is held as unicode because it needs to display <br>  //  wide characters (i.e. need TextOutW). <br>* <br>* <br>\**************************************************************************/ <br>VOID BlamGlyphs (HDC hdc, PTEXTMETRIC ptm, USHORT Start, USHORT End, PRECT prect, BOOL printing) <br>{ <br>USHORT i; <br>POINT point; <br>WCHAR outChar; <br> <br>  if (Start == 0xffff) return; <br> <br>  for (i = Start; i&lt;=End; i++) { <br> <br>    /* special case the non-spacing diacritic marks. U+0300 -&gt; U+036F <br>     *  Write a space first, for them to 'modify.' <br>     */ <br>    if ( (0x0300 &lt;= i) &amp;&amp; (i &lt;= 0x036F) ) { <br>      outChar = (WCHAR) 0x0020; <br>      TextOutW (hdc, 0,0, &amp;outChar, 1); <br>    } <br> <br> <br>    outChar = (WCHAR) i; <br>    TextOutW (hdc, 0,0, &amp;outChar, 1); <br> <br>    /* Watch for overflow in x */ <br>    GetCurrentPositionEx (hdc, &amp;point); <br>    if (point.x &gt; (prect-&gt;right - ptm-&gt;tmAveCharWidth)) { <br>      point.x = 0; <br>      point.y += (ptm-&gt;tmHeight + ptm-&gt;tmExternalLeading); <br>      MoveToEx (hdc, point.x, point.y, NULL); <br>    } <br> <br>    /* Watch for overflow in y */ <br>    if (printing) { <br>      if (point.y &gt; (prect-&gt;bottom-(ptm-&gt;tmHeight+ptm-&gt;tmExternalLeading))) { <br>        EndPage   (hdc); <br>        StartPage (hdc); <br>        point.x = point.y = 0; <br>        MoveToEx (hdc, point.x, point.y, NULL); <br>      } <br>    } else { <br>      if (point.y &gt; prect-&gt;bottom) { <br>        return; <br>      } <br>    } <br>  } /* end for (i= Start; i&lt;=End ... */ <br>} <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>* All of the code below is used for parsing "font data."  It will only <br>*  make sense if you have a copy of the True Type font spec.  In short, <br>*  we grab the 'cmap' table, look through it for a subtable, and then <br>*  get two parallel arrays from the subtable.  Complications arise because <br>*  the true type data is "BIG ENDIAN" and NT is being run "little endian." <br>*  For this reason, once we locate the short or long, we call Swap* to <br>*  change the byte ordering. <br>* <br>\**************************************************************************/ <br> <br> <br>VOID SwapShort (PUSHORT); <br>VOID SwapULong  (PULONG); <br> <br> <br> <br>typedef struct tagTABLE{ <br>    USHORT platformID; <br>    USHORT encodingID; <br>    ULONG  offset; <br>} TABLE, *PTABLE; <br> <br>typedef struct tagSUBTABLE{ <br>    USHORT format; <br>    USHORT length; <br>    USHORT version; <br>    USHORT segCountX2; <br>    USHORT searchRange; <br>    USHORT entrySelector; <br>    USHORT rangeShift; <br>} SUBTABLE, *PSUBTABLE; <br> <br> <br>/* 'cmap' is passed in by value in a DWORD */ <br>#define CMAPHEX  0x70616d63 <br>#define NBYTES   256 <br>#define OFFSETERROR  0 <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  CountUCSegments() <br>* <br>*  input parameters: <br>*   hdc - with the logical font set into it. <br>*   prect - pointer to client rectangle. </code></pre>
<p>
</p>
<pre><code>* <br>*  Global variables: <br>*   startCount <br>*   endCount <br>* <br>*  returns: <br>*   number of UC segments or <br>*   SEGMENTERROR if there is some kind of error. <br>* <br>*  essential side effect: <br>*   Fills in global startCount, endCount arrays. <br>\**************************************************************************/ <br>int CountUCSegments (HDC hdc) <br>{ <br>DWORD       cbData; <br>USHORT      aShort[2]; <br>DWORD       nBytes; <br>USHORT      i, nTables; <br>PTABLE      pTable; <br>PSUBTABLE   pSubTable; <br>ULONG       offset,offsetFormat4; <br>USHORT      segCount; <br>BYTE        buffer[NBYTES]; <br> <br> <br> <br> <br>    /* find number of "subtables", second long in cmap */ <br>    nBytes=GetFontData (hdc, CMAPHEX, 0, aShort, 4); <br>    if (nBytes == GDI_ERROR) { <br>      MessageBox (NULL, szFontDataErr, szMBERROR , MBERRORFLAGS); <br>      return SEGMENTERROR; <br>    } <br>    if (nBytes == 0) { <br>      MessageBox (NULL, szNoCMAPTable, szMBERROR , MBERRORFLAGS); <br>      return SEGMENTERROR; <br>    } <br>    nTables = aShort[1]; <br>    SwapShort (&amp;nTables); <br> <br> <br>    cbData = nTables * sizeof(TABLE); <br>    if (cbData &gt;NBYTES) { <br>      MessageBox (NULL, szCBDataTooBig, szMBERROR , MBERRORFLAGS); <br>      return SEGMENTERROR; <br>    } <br> <br>    /* get array of subtables information.  Check each one for 3,1*/ <br>    nBytes=GetFontData (hdc, CMAPHEX, 4, buffer, cbData); <br>    pTable = (PTABLE)buffer; <br>    offsetFormat4 = OFFSETERROR; <br>    for (i = 0; i&lt; nTables; i++) { <br> <br>        SwapShort (&amp;(pTable-&gt;encodingID)); <br>        SwapShort (&amp;(pTable-&gt;platformID)); <br> <br>        if ((pTable-&gt;platformID == 3)&amp;&amp;(pTable-&gt;encodingID == 1)) { <br>          offsetFormat4 = pTable-&gt;offset; <br>          SwapULong (&amp;offsetFormat4); <br>          break; <br>        } <br>        pTable++; <br>    } <br> <br>    /* verify that we got the correct offset to the FORMAT 4 subtable */ <br>    if (offsetFormat4 == OFFSETERROR){ <br>      MessageBox (NULL, szNoTable, szMBERROR , MBERRORFLAGS); <br>      return SEGMENTERROR; <br>    } <br> <br>    /* Get the beginning of the subtable, especially the segment count */ <br>    nBytes=GetFontData (hdc, CMAPHEX, offsetFormat4, buffer, sizeof(SUBTABLE)); <br>    pSubTable = (PSUBTABLE) buffer; <br>    SwapShort (&amp;(pSubTable-&gt;format)); <br>    SwapShort (&amp;(pSubTable-&gt;segCountX2)); <br> <br>    if (pSubTable-&gt;format != 4){ <br>      MessageBox (NULL, szFormatNot4, szMBERROR, MBERRORFLAGS); <br>      return SEGMENTERROR; <br>    } <br> <br>    segCount = pSubTable-&gt;segCountX2 / 2; <br> <br>    /* Now that we know how many segments that the font contains, <br>     *  free up the old memory, and realloc. the two global arrays. <br>     */ <br>    if (startCount != NULL) LocalFree (LocalHandle (startCount)); <br>    if (endCount != NULL) LocalFree (LocalHandle (endCount)); <br>    startCount = LocalAlloc (LPTR, segCount * sizeof(USHORT)); <br>    endCount = LocalAlloc (LPTR, segCount * sizeof(USHORT)); <br> <br>    if ((startCount == NULL) || (endCount == NULL)) { <br>      MessageBox (NULL, szAllocFailed, szMBERROR, MBERRORFLAGS); <br>      return SEGMENTERROR; <br>    } <br> <br>    /* read in the array of endCount values */ <br>    offset = offsetFormat4 <br>           + (7 * sizeof (USHORT));  /* skip constant # bytes in subtable */ <br>    cbData = segCount * sizeof (USHORT); <br>    nBytes=GetFontData (hdc, CMAPHEX, offset, endCount, cbData ); <br>    for (i = 0; i&lt;segCount; i++) <br>        SwapShort (&amp; (endCount[i])); <br> <br>    /* read in the array of startCount values */ <br>    offset = offsetFormat4 <br>           + (7 * sizeof (USHORT))   /* skip constant # bytes in subtable */ <br>           + (segCount * sizeof (USHORT)) /* skip endCount array */ <br>           + sizeof (USHORT);             /* skip reservedPad */ <br>    cbData = segCount * sizeof (USHORT); <br>    nBytes=GetFontData (hdc, CMAPHEX, offset, startCount, cbData ); <br>    for (i = 0; i&lt;segCount; i++) <br>        SwapShort (&amp; (startCount[i])); <br> <br> <br>    return segCount; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>VOID SwapShort (PUSHORT p) <br>{ <br>SHORT temp; <br> <br>    temp =(SHORT)( HIBYTE (*p) + (LOBYTE(*p) &lt;&lt; 8)); <br>    *p = temp; <br>} <br> <br> <br> <br>VOID SwapULong (PULONG p) <br>{ <br>ULONG temp; <br> <br>    temp = (LONG) ((BYTE) *p); <br>    temp &lt;&lt;= 8; <br>    *p &gt;&gt;=8; <br> <br>    temp += (LONG) ((BYTE) *p); <br>    temp &lt;&lt;= 8; <br>    *p &gt;&gt;=8; <br> <br>    temp += (LONG) ((BYTE) *p); <br>    temp &lt;&lt;= 8; <br>    *p &gt;&gt;=8; <br> <br>    temp += (LONG) ((BYTE) *p); <br>    *p = temp; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
