<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3390"></a>DIALOGS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  dialogs.c -- module for the two dialogs (LOGFONT &amp; TEXTMETRIC) <br>*   Includes the window procedure and an initialization routine. <br>*  the LogFontWndProc is actually used for multiple dialogs. <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "ttfonts.h" <br> <br> <br> <br>int initDlg(HWND hwndMain) <br>{ <br>  /*  load three dialogs and position them. Set the minimize icon for <br>   *   this CLASS and it affects all dialog windows. <br>   */ <br> <br>  hwndDlgLF = CreateDialog (hInst, TEXT("logfontDlg"), hwndMain, <br>                (DLGPROC)LogFontWndProc); <br>  if (hwndDlgLF == NULL) return FALSE; <br> <br>  SetWindowPos (hwndDlgLF, NULL, <br>                CHILDLEFT(1), CHILDTOP, <br>                0,0, SWP_NOZORDER | SWP_NOSIZE); <br> <br> <br>  hwndDlgTM = CreateDialog (hInst, TEXT("textmetricDlg"), hwndMain, <br>                (DLGPROC)LogFontWndProc); <br>  if (hwndDlgTM == NULL) return FALSE; <br> <br>  SetWindowPos (hwndDlgTM, NULL, <br>                CHILDLEFT(0), CHILDTOP, <br>                0,0, SWP_NOZORDER | SWP_NOSIZE); <br> <br> <br> <br>  hwndDlgOLTM = CreateDialog (hInst, TEXT("oltextmetricDlg"), hwndMain, <br>                (DLGPROC)LogFontWndProc); <br>  if (hwndDlgOLTM == NULL) return FALSE; <br>  ShowWindow (hwndDlgOLTM, SW_MINIMIZE); <br> <br> <br> <br> <br>  hwndDlgFD = CreateDialog (hInst, TEXT("getfontdataDlg"), hwndMain, <br>                (DLGPROC)FontDataWndProc); <br>  if (hwndDlgFD == NULL) return FALSE; <br>  ShowWindow (hwndDlgFD, SW_MINIMIZE); <br>  SetWindowPos (hwndDlgFD, HWND_TOP, <br>                0, 0, <br>                0,0, SWP_NOSIZE ); <br> <br> <br> <br>  SetClassLong (hwndDlgLF, GCL_HICON, (LONG)LoadIcon(hInst, TEXT("ttfontsIcon"))); <br> <br> <br>  return TRUE; <br>} <br> <br> <br>/* first and last string IDs from string table in RC file */ <br>#define FIRSTSTRING 1 <br>#define LASTSTRING  20 <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  FontDataWndProc <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>*  Allow the user to select a table, an offset, and a byte count. <br>*   on command message, post self a user message (allows the user <br>*   message to come in from other sources too).  On the user message, <br>*   just call GetFontData and display the results. <br>* <br>* <br>  // UNICODE NOTICE <br>  //  Parts of this are held as ANSI because the dwTable <br>  //  in the fontdata is stored with four 8 bit chars. <br>  //  And because there is not yet a wide char version of sscanf(). <br>* <br>* <br>\**************************************************************************/ <br>LRESULT CALLBACK FontDataWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>#define NCHAR 255 <br>TCHAR buffer[NCHAR]; <br>HDC hdc; <br>int nBytes, nStrings, i; <br> <br> <br>  switch (message) { <br> <br>    /* fill combo box w/ table names, and <br>     *  entry fields w/ meaningful initial values. <br>     */ <br>    case WM_INITDIALOG: <br>      SetDlgItemInt (hwnd, DID_DWOFFSET, 0, TRUE); <br>      SetDlgItemInt (hwnd, DID_CBDATA, 50, TRUE); <br>      for (i = FIRSTSTRING; i&lt;= LASTSTRING; i++) { <br>        LoadString (GetModuleHandle (NULL), i, buffer, NCHAR); <br>        SendDlgItemMessage (hwnd, DID_DWTABLE, CB_ADDSTRING, 0, (LPARAM)buffer); <br>      } <br> <br>    return TRUE; <br> <br>    /* If the user hits the DOIT button, post message back to the <br>     *  main window.  It will get an HDC and then post us the proper <br>     *  user message. <br>     */ <br>    case WM_COMMAND: <br>      if (wParam == DID_DOIT) <br>        PostMessage (hwndMain, WM_COMMAND, TBID_GETFONTDATA, 0); <br>    break;  /* end WM_COMMAND */ <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_GETFONTDATA <br>    * <br>    *  lParam - HDC. <br>    * <br>    * User message.  Parse the contents of the entry fields, and make the <br>    *  GetFontData() call.  Put results in the listbox. <br>    \**********************************************************************/ <br>    case WMU_GETFONTDATA: { <br>        DWORD dwTable, dwOffset, cbData; <br>        LPBYTE   lpDataBuffer; <br>        DWORD dwNBytes; <br> <br>        hdc = (HDC) lParam; <br>        SendDlgItemMessage (hwnd, DID_LISTBOX, LB_RESETCONTENT, 0, 0); <br> <br> <br>        { <br>          // UNICODE NOTICE.  GetDlgItemTextA returns ANSI strings. <br>          //  we are doing manipulation on a byte by byte basis <br> <br>          CHAR  fourbytes[5]; <br>          CHAR  sbBuffer[NCHAR]; <br> <br>          nBytes = GetDlgItemTextA (hwnd, DID_DWTABLE, fourbytes, 5); <br>          if (nBytes == 0) { <br>            dwTable = 0; <br>          } else { <br>            dwTable = (DWORD) ((fourbytes[3] &lt;&lt; 24) <br>                            +  (fourbytes[2] &lt;&lt; 16) <br>                            +  (fourbytes[1] &lt;&lt;  8) <br>                            +  (fourbytes[0])); <br>          } <br> <br> <br>          // UNICODE NOTICE.  GetDlgItemTextA returns ANSI strings. <br>          //  sscanf expects single byte strings. <br> <br>          GetDlgItemTextA (hwnd, DID_DWOFFSET, sbBuffer, NCHAR); <br>          sscanf (sbBuffer, "%x", &amp;dwOffset); <br>          GetDlgItemTextA (hwnd, DID_CBDATA  , sbBuffer, NCHAR); <br>          sscanf (sbBuffer, "%x", &amp;cbData); <br>        } <br> <br> <br>        lpDataBuffer = (LPBYTE) LocalAlloc (LPTR, cbData); <br>        if (lpDataBuffer == NULL) { <br>          MessageBox (NULL, szAllocFailed, szMBERROR, MBERRORFLAGS); <br>          return 0; <br>        } <br> <br>        dwNBytes = GetFontData (hdc, dwTable, dwOffset, (LPVOID) lpDataBuffer, cbData); <br> <br>        if (dwNBytes == -1) { <br>          MessageBox (NULL, szFontDataErr, szMBERROR, MBERRORFLAGS); <br>        } else { <br> <br>          nStrings = dwNBytes / 16; <br>          for (i = 0; i&lt; nStrings; i++) { <br>            wsprintf (buffer, <br>                      TEXT("%02x%02x %02x%02x  %02x%02x %02x%02x  %02x%02x %02x%02x  %02x%02x %02x%02x"), <br>                      (int)lpDataBuffer[i*16+0], <br>                      (int)lpDataBuffer[i*16+1], <br>                      (int)lpDataBuffer[i*16+2], <br>                      (int)lpDataBuffer[i*16+3], <br>                      (int)lpDataBuffer[i*16+4], <br>                      (int)lpDataBuffer[i*16+5], <br>                      (int)lpDataBuffer[i*16+6], <br>                      (int)lpDataBuffer[i*16+7], <br>                      (int)lpDataBuffer[i*16+8], <br>                      (int)lpDataBuffer[i*16+9], <br>                      (int)lpDataBuffer[i*16+10], <br>                      (int)lpDataBuffer[i*16+11], <br>                      (int)lpDataBuffer[i*16+12], <br>                      (int)lpDataBuffer[i*16+13], <br>                      (int)lpDataBuffer[i*16+14], <br>                      (int)lpDataBuffer[i*16+15]); <br>            SendDlgItemMessage (hwnd, DID_LISTBOX, LB_ADDSTRING, 0, (LONG) buffer); <br>          } <br>        } <br> <br>        LocalFree ( LocalHandle ((LPVOID)lpDataBuffer)); <br>    } return TRUE;  /* end WMU_GETFONTDATA */ <br> <br>  } /* end switch */ <br>  return 0; <br>} <br> <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  LogFontWndProc <br>* <br>*  input parameters:  normal window procedure parameters. <br>*  global variables: <br>* <br>* This window procedure is used for two completely different dialog boxes. <br>\**************************************************************************/ <br>LRESULT CALLBACK LogFontWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>static LPLOGFONT    lplf; <br>static LPTEXTMETRIC lptm; <br> <br>  switch (message) { <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMOTOLF <br>    * <br>    *  lParam - pointer to LOGFONT structure. <br>    * <br>    * User message.  Take the input LOGFONT and fill the edit fields of the <br>    *  dialog box. <br>    \**********************************************************************/ <br>    case WMU_DEMOTOLF: { <br>      lplf = (LPLOGFONT) lParam; <br> <br>      SetDlgItemInt (hwnd, DIDHEIGHT , lplf-&gt;lfHeight,        TRUE); <br>      SetDlgItemInt (hwnd, DIDWIDTH  , lplf-&gt;lfWidth,         TRUE); <br>      SetDlgItemInt (hwnd, DIDESCAPE , lplf-&gt;lfEscapement,    TRUE); <br>      SetDlgItemInt (hwnd, DIDORIENT , lplf-&gt;lfOrientation,   TRUE); <br>      SetDlgItemInt (hwnd, DIDWEIGHT , lplf-&gt;lfWeight,        TRUE); <br>      SetDlgItemInt (hwnd, DIDITALIC , lplf-&gt;lfItalic,        FALSE); <br>      SetDlgItemInt (hwnd, DIDUNDERL , lplf-&gt;lfUnderline,     FALSE); <br>      SetDlgItemInt (hwnd, DIDSTRIKE , lplf-&gt;lfStrikeOut,     FALSE); <br>      SetDlgItemInt (hwnd, DIDCHARSE , lplf-&gt;lfCharSet,       FALSE); <br>      SetDlgItemInt (hwnd, DIDOUTPRE , lplf-&gt;lfOutPrecision,  FALSE); <br>      SetDlgItemInt (hwnd, DIDCLIPPR , lplf-&gt;lfClipPrecision, FALSE); <br>      SetDlgItemInt (hwnd, DIDQUALIT , lplf-&gt;lfQuality,       FALSE); <br>      SetDlgItemInt (hwnd, DIDPITCHA , lplf-&gt;lfPitchAndFamily,FALSE); <br>      SetDlgItemText (hwnd, DIDFACENA, lplf-&gt;lfFaceName); <br> <br>    } break; <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_LFTODEMO <br>    * <br>    *  lParam - pointer to LOGFONT structure. <br>    * <br>    * User message.  Fill the input LOGFONT with the contents of the <br>    *  edit fields of dialog box. <br>    \**********************************************************************/ <br>    case WMU_LFTODEMO: { <br>      BOOL  success; <br>      lplf = (LPLOGFONT) lParam; <br> <br> <br>      lplf-&gt;lfHeight =        GetDlgItemInt (hwnd, DIDHEIGHT, &amp;success , TRUE); <br>      lplf-&gt;lfWidth  =        GetDlgItemInt (hwnd, DIDWIDTH , &amp;success , TRUE); <br>      lplf-&gt;lfEscapement =    GetDlgItemInt (hwnd, DIDESCAPE, &amp;success , TRUE); <br>      lplf-&gt;lfOrientation =   GetDlgItemInt (hwnd, DIDORIENT, &amp;success , TRUE); <br>      lplf-&gt;lfWeight =        GetDlgItemInt (hwnd, DIDWEIGHT, &amp;success , TRUE); <br>      lplf-&gt;lfItalic =        (BYTE) GetDlgItemInt (hwnd, DIDITALIC, &amp;success , FALSE); <br>      lplf-&gt;lfUnderline =     (BYTE) GetDlgItemInt (hwnd, DIDUNDERL, &amp;success , FALSE); <br>      lplf-&gt;lfStrikeOut =     (BYTE) GetDlgItemInt (hwnd, DIDSTRIKE, &amp;success , FALSE); <br>      lplf-&gt;lfCharSet =       (BYTE) GetDlgItemInt (hwnd, DIDCHARSE, &amp;success , FALSE); <br>      lplf-&gt;lfOutPrecision =  (BYTE) GetDlgItemInt (hwnd, DIDOUTPRE, &amp;success , FALSE); <br>      lplf-&gt;lfClipPrecision = (BYTE) GetDlgItemInt (hwnd, DIDCLIPPR, &amp;success , FALSE); <br>      lplf-&gt;lfQuality =       (BYTE) GetDlgItemInt (hwnd, DIDQUALIT, &amp;success , FALSE); <br>      lplf-&gt;lfPitchAndFamily =(BYTE) GetDlgItemInt (hwnd, DIDPITCHA, &amp;success , FALSE); <br>      GetDlgItemText (hwnd, DIDFACENA, lplf-&gt;lfFaceName, LF_FACESIZE); <br> <br>    } break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMOTOTM <br>    * <br>    *  lParam - pointer to TEXTMETRIC structure. <br>    * <br>    * User message.  Take the input LOGFONT and fill the list box with <br>    *  strings.  Turn off update before hand, then reenable when complete. <br>    \**********************************************************************/ <br>    case WMU_DEMOTOTM: { <br>      TCHAR buffer[100]; <br> <br>      lptm = (LPTEXTMETRIC) lParam; <br> <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, WM_SETREDRAW, FALSE, 0); <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, LB_RESETCONTENT, 0, 0); <br> <br>#define LBPUT SendDlgItemMessage (hwnd, DID_LISTBOX, LB_ADDSTRING, 0, (LONG) buffer); <br> <br>      wsprintf (buffer, TEXT("tmHeight        \t%d")  ,(int) lptm-&gt;tmHeight           ); LBPUT <br>      wsprintf (buffer, TEXT("tmAscent        \t%d")  ,(int) lptm-&gt;tmAscent           ); LBPUT <br>      wsprintf (buffer, TEXT("tmDescent       \t%d")  ,(int) lptm-&gt;tmDescent          ); LBPUT <br>      wsprintf (buffer, TEXT("tmInternalLeading\t%d") ,(int) lptm-&gt;tmInternalLeading  ); LBPUT <br>      wsprintf (buffer, TEXT("tmExternalLeading\t%d") ,(int) lptm-&gt;tmExternalLeading  ); LBPUT <br>      wsprintf (buffer, TEXT("tmAveCharWidth  \t%d")  ,(int) lptm-&gt;tmAveCharWidth     ); LBPUT <br>      wsprintf (buffer, TEXT("tmMaxCharWidth  \t%d")  ,(int) lptm-&gt;tmMaxCharWidth     ); LBPUT <br>      wsprintf (buffer, TEXT("tmWeight        \t%d")  ,(int) lptm-&gt;tmWeight           ); LBPUT <br>      wsprintf (buffer, TEXT("tmOverhang      \t%d")  ,(int) lptm-&gt;tmOverhang         ); LBPUT <br>      wsprintf (buffer, TEXT("tmDigitizedAspectX\t%d"),(int) lptm-&gt;tmDigitizedAspectX ); LBPUT <br>      wsprintf (buffer, TEXT("tmDigitizedAspectY\t%d"),(int) lptm-&gt;tmDigitizedAspectY ); LBPUT <br>      wsprintf (buffer, TEXT("tmItalic        \t%d")  ,(int) lptm-&gt;tmItalic           ); LBPUT <br>      wsprintf (buffer, TEXT("tmUnderlined    \t%d")  ,(int) lptm-&gt;tmUnderlined       ); LBPUT <br>      wsprintf (buffer, TEXT("tmStruckOut     \t%d")  ,(int) lptm-&gt;tmStruckOut        ); LBPUT <br>      wsprintf (buffer, TEXT("tmFirstChar     \t%d")  ,(int) lptm-&gt;tmFirstChar        ); LBPUT <br>      wsprintf (buffer, TEXT("tmLastChar      \t%d")  ,(int) lptm-&gt;tmLastChar         ); LBPUT <br>      wsprintf (buffer, TEXT("tmDefaultChar   \t%d")  ,(int) lptm-&gt;tmDefaultChar      ); LBPUT <br>      wsprintf (buffer, TEXT("tmBreakChar     \t%d")  ,(int) lptm-&gt;tmBreakChar        ); LBPUT <br>      wsprintf (buffer, TEXT("tmPitchAndFamily\t%d")  ,(int) lptm-&gt;tmPitchAndFamily   ); LBPUT <br>      wsprintf (buffer, TEXT("tmCharSet       \t%d")  ,(int) lptm-&gt;tmCharSet          ); LBPUT <br> <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, WM_SETREDRAW, TRUE, 0); <br>      InvalidateRect (hwnd, NULL, TRUE); <br>      UpdateWindow (hwnd); <br> <br>    } break; <br> <br> <br>    /**********************************************************************\ <br>    *  WMU_DEMOTOOLTM <br>    * <br>    *  lParam - HDC. <br>    * <br>    * User message.  With the input HDC, allocate space for OUTLINETEXTMETRIC <br>    *  structure, query it from the HDC, and fill the listbox.  (Allocate the <br>    *  OUTLINETEXTMETRIC structure dynamically since it is variable size.) <br>    \**********************************************************************/ <br>    case WMU_DEMOTOOLTM: { <br>      HDC hdc; <br>      TCHAR buffer[100]; <br>      UINT cbData; <br>      LPOUTLINETEXTMETRIC lpoltm; <br>      LPBYTE lptStr; <br> <br>      hdc = (HDC) lParam; <br> <br> <br>      /* figure out how large the structure is, alloc, and re-query <br>       *  unless cbData ==0, then post no-op string and exit. <br>       */ <br>      cbData = GetOutlineTextMetrics (hdc, 0, NULL); <br>      if (cbData == 0) { <br>        SendDlgItemMessage (hwnd, DID_LISTBOX, LB_RESETCONTENT, 0, 0); <br>        wsprintf (buffer, TEXT("cbData == 0")); LBPUT <br>        return 0; <br>      } <br>      lpoltm = (LPOUTLINETEXTMETRIC)LocalAlloc (LPTR, cbData); <br>      GetOutlineTextMetrics (hdc, cbData, lpoltm); <br> <br> <br>      /* freeze redraw of listbox, and clear contents. */ <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, WM_SETREDRAW, FALSE, 0); <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, LB_RESETCONTENT, 0, 0); <br> <br> <br>      wsprintf (buffer, TEXT("otmSize                \t%d"),(int) lpoltm-&gt;otmSize               );            LBPUT <br>      wsprintf (buffer, TEXT("otmTextMetrics { }"));                                                      LBPUT <br>      wsprintf (buffer, TEXT("otmFiller              \t%d"),(int)(BYTE) lpoltm-&gt;otmFiller             );      LBPUT <br> <br>      wsprintf (buffer, TEXT("otmPanoseNumber           "));                                                  LBPUT <br>// removed for beta 2.      wsprintf (buffer, TEXT("\t ulCulture        \t%d"),   (int) lpoltm-&gt;otmPanoseNumber.ulCulture        ); LBPUT <br>      wsprintf (buffer, TEXT("\t bFamilyType      \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bFamilyType      ); LBPUT <br>      wsprintf (buffer, TEXT("\t bSerifStyle      \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bSerifStyle      ); LBPUT <br>      wsprintf (buffer, TEXT("\t bWeight          \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bWeight          ); LBPUT <br>      wsprintf (buffer, TEXT("\t bProportion      \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bProportion      ); LBPUT <br>      wsprintf (buffer, TEXT("\t bContrast        \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bContrast        ); LBPUT <br>      wsprintf (buffer, TEXT("\t bStrokeVariation \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bStrokeVariation ); LBPUT <br>      wsprintf (buffer, TEXT("\t bArmStyle        \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bArmStyle        ); LBPUT <br>      wsprintf (buffer, TEXT("\t bLetterform      \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bLetterform      ); LBPUT <br>      wsprintf (buffer, TEXT("\t bMidline         \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bMidline         ); LBPUT <br>      wsprintf (buffer, TEXT("\t bXHeight         \t0x%lx"),(int) lpoltm-&gt;otmPanoseNumber.bXHeight         ); LBPUT <br> <br> <br>      wsprintf (buffer, TEXT("otmfsSelection         \t%d"),(UINT) lpoltm-&gt;otmfsSelection        ); LBPUT <br>      wsprintf (buffer, TEXT("otmfsType              \t%d"),(UINT) lpoltm-&gt;otmfsType             ); LBPUT <br>      wsprintf (buffer, TEXT("otmsCharSlopeRise      \t%d"),(UINT) lpoltm-&gt;otmsCharSlopeRise     ); LBPUT <br>      wsprintf (buffer, TEXT("otmsCharSlopeRun       \t%d"),(UINT) lpoltm-&gt;otmsCharSlopeRun      ); LBPUT <br>      wsprintf (buffer, TEXT("otmItalicAngle         \t%d"),(UINT) lpoltm-&gt;otmItalicAngle        ); LBPUT <br>      wsprintf (buffer, TEXT("otmEMSquare            \t%d"),(UINT) lpoltm-&gt;otmEMSquare           ); LBPUT <br>      wsprintf (buffer, TEXT("otmAscent              \t%d"),(UINT) lpoltm-&gt;otmAscent             ); LBPUT <br>      wsprintf (buffer, TEXT("otmDescent             \t%d"),(int) lpoltm-&gt;otmDescent             ); LBPUT <br>      wsprintf (buffer, TEXT("otmLineGap             \t%d"),(int) lpoltm-&gt;otmLineGap             ); LBPUT <br>      wsprintf (buffer, TEXT("otmsCapEmHeight        \t%d"),(UINT) lpoltm-&gt;otmsCapEmHeight        ); LBPUT <br>      wsprintf (buffer, TEXT("otmsXHeight            \t%d"),(UINT) lpoltm-&gt;otmsXHeight            ); LBPUT <br>      wsprintf (buffer, TEXT("otmrcFontBox           \t (%d, %d, %d, %d)"), <br>                                                      (int) lpoltm-&gt;otmrcFontBox.left, <br>                                                      (int) lpoltm-&gt;otmrcFontBox.top, <br>                                                      (int) lpoltm-&gt;otmrcFontBox.right, <br>                                                      (int) lpoltm-&gt;otmrcFontBox.bottom   ); LBPUT <br>      wsprintf (buffer, TEXT("otmMacAscent           \t%d"),(int) lpoltm-&gt;otmMacAscent          ); LBPUT <br>      wsprintf (buffer, TEXT("otmMacDescent          \t%d"),(int) lpoltm-&gt;otmMacDescent         ); LBPUT <br>      wsprintf (buffer, TEXT("otmMacLineGap          \t%d"),(UINT) lpoltm-&gt;otmMacLineGap         ); LBPUT <br>      wsprintf (buffer, TEXT("otmusMinimumPPEM       \t%d"),(UINT) lpoltm-&gt;otmusMinimumPPEM      ); LBPUT <br> <br>      wsprintf (buffer, TEXT("otmptSubscriptSize     \t(%d, %d)"), <br>                                                      (int) lpoltm-&gt;otmptSubscriptSize.x, <br>                                                      (int) lpoltm-&gt;otmptSubscriptSize.y    ); LBPUT <br>      wsprintf (buffer, TEXT("otmptSubscriptOffset   \t(%d, %d)"), <br>                                                      (int) lpoltm-&gt;otmptSubscriptOffset.x, <br>                                                      (int) lpoltm-&gt;otmptSubscriptOffset.y  ); LBPUT <br>      wsprintf (buffer, TEXT("otmptSuperscriptSize   \t(%d, %d)"), <br>                                                      (int) lpoltm-&gt;otmptSuperscriptSize.x, <br>                                                      (int) lpoltm-&gt;otmptSuperscriptSize.y  ); LBPUT <br>      wsprintf (buffer, TEXT("otmptSuperscriptOffset \t(%d, %d)"), <br>                                                      (int) lpoltm-&gt;otmptSuperscriptOffset.x, <br>                                                      (int) lpoltm-&gt;otmptSuperscriptOffset.y); LBPUT <br> <br>      wsprintf (buffer, TEXT("otmsStrikeoutSize      \t%d"),(UINT) lpoltm-&gt;otmsStrikeoutSize     ); LBPUT <br>      wsprintf (buffer, TEXT("otmsStrikeoutPosition  \t%d"),(int) lpoltm-&gt;otmsStrikeoutPosition );  LBPUT <br>      wsprintf (buffer, TEXT("otmsUnderscoreSize     \t%d"),(int) lpoltm-&gt;otmsUnderscoreSize    );  LBPUT <br>      wsprintf (buffer, TEXT("otmsUnderscorePosition \t%d"),(UINT) lpoltm-&gt;otmsUnderscorePosition); LBPUT <br> <br>      /* the last 4 fields are incorrectly typed as PSTR, <br>       *  they are in fact offsets from the top of the <br>       *  OUTLINETEXTMETRIC structure, to the location of the string. <br>       */ <br>      lptStr = (LPBYTE)lpoltm; <br>      lptStr += (UINT) (PBYTE) lpoltm-&gt;otmpFamilyName; <br>      wsprintf (buffer, TEXT("otmpFamilyName:   %s"),lptStr); LBPUT <br> <br>      lptStr = (LPBYTE)lpoltm; <br>      lptStr += (UINT) (PBYTE) lpoltm-&gt;otmpFaceName; <br>      wsprintf (buffer, TEXT("otmpFaceName:   %s"),lptStr);   LBPUT <br> <br>      lptStr = (LPBYTE)lpoltm; <br>      lptStr += (UINT) (PBYTE) lpoltm-&gt;otmpStyleName; <br>      wsprintf (buffer, TEXT("otmpStyleName:   %s"),lptStr);  LBPUT <br> <br>      wsprintf (buffer, TEXT("otmpFullName:"));               LBPUT <br>      lptStr = (LPBYTE)lpoltm; <br>      lptStr += (UINT) (PBYTE) lpoltm-&gt;otmpFullName; <br>      wsprintf (buffer, TEXT("  %s"),lptStr);                 LBPUT <br> <br> <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, WM_SETREDRAW, TRUE, 0); <br>      InvalidateRect (hwnd, NULL, TRUE); <br>      UpdateWindow (hwnd); <br> <br>      /* balance LocalAlloc(), release memory. */ <br>      LocalFree (LocalHandle (lpoltm)); <br> <br>    } break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_CHILDACTIVATE <br>    * <br>    *  In order for these MDI child windows (dialogs) to be activated <br>    *   correctly, the dialog procedure here must call the Win32 API <br>    *   DefMDIChildProc (). <br>    \**********************************************************************/ <br>    case WM_CHILDACTIVATE: <br>      DefMDIChildProc(hwnd, message, wParam, lParam); <br>      return TRUE; <br>    break; <br> <br>  } /* end switch */ <br>  return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
