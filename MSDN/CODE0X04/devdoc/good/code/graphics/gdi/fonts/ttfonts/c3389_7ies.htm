<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TTFONTS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3394"></a>TTFONTS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/**************************************************************************\ <br>*  ttfonts.c -- Font enumeration and manipulation program for Win32/NT. <br>* <br>* design:  There is a main frame window (hwndMain) with a child toolbar, <br>*  two child dialogs, and a child demonstration window.  All window handles <br>*  are global and are accesible to all modules.  There is a module for each <br>*  of the classes of windows.  Each module contains an initialization routine <br>*  to register the class and create the window(s).  Each module also contains <br>*  a window procedure for that class.  The two windows which list all of the <br>*  fonts are also children of the main window, and they are hidden and shown <br>*  as needed. <br>* <br>*  Communication between windows is via message passing.  The toolbar passes <br>*  all of its command messages back to the main window.  Other windows pass <br>*  information back and forth with the following USER defined messages: <br>*  WMU_LFTODEMO, WMU_DEMOTOLF, WMU_DEMOTOTM...  Rectangles fly on the screen <br>*  (c.f. flyWinWin) to mirror message trafic, i.e. data flow. <br>* <br>\**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "ttfonts.h" <br> <br> <br>/* Misc. defines for size, color, and appearance of drawing. */ <br>#define GRIDCOLOR  PALETTEINDEX (6) <br>#define TICKSPACE  20 <br>#define FWW_STEPS  40 <br> <br> <br> <br>TCHAR szMBERROR     [MAX_PATH]; <br>TCHAR szInitString  [MAX_PATH]; <br>TCHAR szAllocFailed [MAX_PATH]; <br>TCHAR szResetDisplay[MAX_PATH]; <br>TCHAR szNoCMAPTable [MAX_PATH]; <br>TCHAR szFontDataErr [MAX_PATH]; <br>TCHAR szCBDataTooBig[MAX_PATH]; <br>TCHAR szNoTable     [MAX_PATH]; <br>TCHAR szFormatNot4  [MAX_PATH]; <br>TCHAR szEnumPrinterR[MAX_PATH]; <br>TCHAR szHelpPathName[] = TEXT("ttfonts.HLP"); <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  WinMain() <br>* <br>*  input parameters:  c.f. generic sample <br>* <br>\**************************************************************************/ <br>int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                     LPSTR lpCmdLine, int nCmdShow) <br>{ <br>    MSG    msg; <br>    HWND   hwndInfo; <br>    CLIENTCREATESTRUCT clientcreate; <br>    RECT   clientRect; <br>    HANDLE haccel; <br> <br> <br>    UNREFERENCED_PARAMETER( lpCmdLine ); <br>    UNREFERENCED_PARAMETER(  nCmdShow ); <br>    hInst = hInstance; <br> <br> <br>    /* Check for previous instance.  If none, then register class. */ <br>    if (!hPrevInstance) { <br>      WNDCLASS  wc; <br> <br>      wc.style = 0; <br>      wc.lpfnWndProc = (WNDPROC)MainWndProc; <br> <br>      wc.cbClsExtra = 0; <br>      wc.cbWndExtra = 0; <br>      wc.hInstance = hInstance; <br>      wc.hIcon = LoadIcon(hInstance, TEXT("ttfontsIcon")); <br>      wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>      wc.hbrBackground = NULL; <br>      wc.lpszMenuName =  TEXT("ttfontsMenu"); <br>      wc.lpszClassName = TEXT("ttfonts"); <br> <br>      if (!RegisterClass(&amp;wc)) return (FALSE); <br> <br>    }  /* class registered o.k. */ <br> <br> <br>    /* Create the main window.  Return false if CreateWindow() fails */ <br>    hwndMain = CreateWindow( <br>        TEXT("ttfonts"), <br>        TEXT("TTFonts"), <br>        WS_OVERLAPPEDWINDOW, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, NULL, hInst, NULL); <br> <br>    if (!hwndMain) return (FALSE); <br> <br>    /* Initialize global strings that are used later */ <br>    LoadString (hInst, IDS_MBERROR,      szMBERROR,      MAX_PATH); <br>    LoadString (hInst, IDS_INITSTRING,   szInitString,   MAX_PATH); <br>    LoadString (hInst, IDS_ALLOCFAILED,  szAllocFailed,  MAX_PATH); <br>    LoadString (hInst, IDS_RESETDISPLAY, szResetDisplay, MAX_PATH); <br>    LoadString (hInst, IDS_NOCMAPTABLE,  szNoCMAPTable,  MAX_PATH); <br>    LoadString (hInst, IDS_CBDATATOOBIG, szCBDataTooBig, MAX_PATH); <br>    LoadString (hInst, IDS_NOTABLE,      szNoTable,      MAX_PATH); <br>    LoadString (hInst, IDS_FORMATNOT4,   szFormatNot4,   MAX_PATH); <br>    LoadString (hInst, IDS_FONTDATAERR,  szFontDataErr,  MAX_PATH); <br>    LoadString (hInst, IDS_ENUMPRINTERR, szEnumPrinterR,  MAX_PATH); <br> <br> <br>    /* create temporary window to display while initialization completes */ <br>    hwndInfo = CreateWindow( <br>        TEXT("EDIT"), <br>        szInitString, <br>        WS_CHILD | WS_VISIBLE | ES_READONLY | ES_MULTILINE | ES_CENTER, <br>        0,0, <br>        GetSystemMetrics (SM_CXFULLSCREEN), <br>        GetSystemMetrics (SM_CYFULLSCREEN), <br>        hwndMain, NULL, hInst, NULL); <br> <br>    ShowWindow(hwndMain, SW_SHOWMAXIMIZED); <br>    UpdateWindow(hwndInfo); <br> <br>    /* create the MDI "client" window. Invisible initially. */ <br>    clientcreate.hWindowMenu  = NULL;  /* don't add window names to menu */ <br>    clientcreate.idFirstChild = 1; <br>    GetClientRect (hwndMain, &amp;clientRect); <br>    clientRect.top += TOOLBARHEIGHT; <br>    hwndClient = CreateWindow( <br>        TEXT("MDICLIENT"), <br>        NULL, <br>        WS_CHILD | WS_CLIPCHILDREN | MDIS_ALLCHILDSTYLES, <br>        0, clientRect.top, <br>        clientRect.right, clientRect.bottom - clientRect.top, <br>        hwndMain, NULL, hInst, (LPVOID)&amp;clientcreate); <br>    if (!hwndClient) return (FALSE); <br> <br> <br> <br>    /* perform initialization for other windows...allfont is SLOW */ <br>    if (!initTB(hwndMain))         return FALSE; <br>    if (!initDisplay(hwndClient))     return FALSE; <br>    if (!initDlg(hwndClient))      return FALSE; <br>    if (!initAllFont(hwndClient))  return FALSE; <br> <br> <br>    SendMessage (hwndMain, WM_COMMAND, IDM_ARRANGE,0); <br> <br>    /* Load the accelerator table that provides clipboard support. */ <br>    haccel = LoadAccelerators (hInst, TEXT("ttfontsAccel")); <br> <br>    /* get rid of the temporary "please wait..." window. */ <br>    DestroyWindow (hwndInfo); <br>    ShowWindow(hwndClient, SW_SHOW); <br> <br>    /* Loop getting messages and dispatching them. */ <br>    while (GetMessage(&amp;msg,NULL, 0,0)) { <br>      if (!TranslateAccelerator(hwndMain, haccel, &amp;msg)) <br>      if (!IsDialogMessage (hwndDlgTM, &amp;msg)) <br>      if (!IsDialogMessage (hwndDlgOLTM, &amp;msg)) <br>      if (!IsDialogMessage (hwndDlgLF, &amp;msg)) <br>      if (!IsDialogMessage (hwndDlgFD, &amp;msg)){ <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>      } <br>    } <br> <br>    return (msg.wParam); <br>} <br> <br> <br> <br>/**************************************************************************\ <br>* <br>*  function:  MainWndProc() <br>* <br>*  input parameters:  normal window procedure parameters. <br>* <br>\**************************************************************************/ <br>LRESULT CALLBACK MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>static HANDLE     hPenGrid; <br>static LOGFONT    lf; <br>static TEXTMETRIC tm; <br> <br>  switch (message) { <br> <br> <br>    /**********************************************************************\ <br>    *  WM_COMMAND <br>    * <br>    * The WM_COMMAND messages here are passed up from the toolbar. <br>    *  Take whatever action is necesarry for the various buttons. <br>    *  (Either showing/hiding enumeration windows, or moving information <br>    *  in structures between different windows.) <br>    \**********************************************************************/ <br>    case WM_COMMAND: { <br> <br>      switch (LOWORD(wParam)) { <br>        HDC hdcDemo; <br> <br>        case TBID_ENUM: <br>          ShowWindow(hwndDisplayFonts, SW_SHOWMAXIMIZED); <br>        break; <br> <br>        case TBID_PRINT: <br>          ShowWindow(hwndPrinterFonts, SW_SHOWMAXIMIZED); <br>        break; <br> <br>        /* Send the LOGFONT dialog a message to fill in a LOGFONT structure, <br>         *  then pass that structure along to the DEMO window. <br>         */ <br>        case TBID_CREATE: <br>          SendMessage (hwndDlgLF, WMU_LFTODEMO, 0, (LONG) &amp;lf); <br>          flyWinWin (hwndMain, hwndDlgLF, hwndDisplay, FWW_STEPS); <br>          SendMessage (hwndDisplay , WMU_NEWFONT, 0, (LONG) &amp;lf); <br>        break; <br> <br> <br>        /* Same exchange as LOGFONT for the TEXTMETRIC structure. <br>         *  However, for the OUTLINETEXTMETRIC stucture, <br>         *  send the DEMO window a message asking for an HDC with the <br>         *  current font selected into it.  Pass that HDC along to the <br>         *  OUTLINETEXTMETRIC dialog so that it can query the structure, <br>         *  and display the values. <br>         */ <br>        case TBID_GETTM: <br> <br>          SendMessage (hwndDisplay , WMU_DEMOTOTM, 0, (LONG) &amp;tm); <br>          flyWinWin (hwndMain, hwndDisplay, hwndDlgTM, FWW_STEPS); <br>          SendMessage (hwndDlgTM, WMU_DEMOTOTM, 0, (LONG) &amp;tm); <br> <br>          hdcDemo = (HDC) SendMessage (hwndDisplay , WMU_DEMOGETDC, 0, 0); <br>          flyWinWin (hwndMain, hwndDisplay, hwndDlgOLTM, FWW_STEPS); <br>          SendMessage (hwndDlgOLTM, WMU_DEMOTOOLTM, 0, (LPARAM) hdcDemo); <br>          SendMessage (hwndDisplay , WMU_DEMORELEASEDC, 0, (LPARAM) hdcDemo); <br> <br>        break; <br> <br> <br>        /* Send message down to hwndDlgFD w/ HDC from hwndDisplay. <br>         *  hwndDlgFD will parse its params, and call GetFontData(). <br>         */ <br>        case TBID_GETFONTDATA: <br> <br>          hdcDemo = (HDC) SendMessage (hwndDisplay , WMU_DEMOGETDC, 0, 0); <br>          flyWinWin (hwndMain, hwndDisplay, hwndDlgFD, FWW_STEPS); <br>          SendMessage (hwndDlgFD, WMU_GETFONTDATA, 0, (LPARAM) hdcDemo); <br>          SendMessage (hwndDisplay , WMU_DEMORELEASEDC, 0, (LPARAM) hdcDemo); <br> <br>        break; <br> <br> <br>        /* Send message to display window to fill in LOGFONT, then <br>         *  send that LOGFONT data back to the logfont dialog. <br>         */ <br>        case IDM_GETOBJECT: <br>          flyWinWin (hwndMain, hwndDisplay, hwndDlgLF, FWW_STEPS); <br>          SendMessage (hwndDisplay , WMU_DEMOTOLF, 0, (LPARAM) &amp;lf); <br>          SendMessage (hwndDlgLF , WMU_DEMOTOLF, 0, (LPARAM) &amp;lf); <br>        break; <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_*_FONT <br>        * <br>        * Send the display window the proper message for it to use one <br>        *  of the GetStockObject() fonts.  Then send this window a message <br>        *  to "getobject" so that the logfont will be copied from the <br>        *  display window to the logfont dialog. <br>        \******************************************************************/ <br>        case IDM_ANSI_FIXED_FONT    : <br>          SendMessage (hwndDisplay , WMU_HFONTTODEMO, 0, <br>                       (LPARAM) GetStockObject(ANSI_FIXED_FONT)); <br>          SendMessage (hwnd, WM_COMMAND, IDM_GETOBJECT, 0); <br>        break; <br>        case IDM_ANSI_VAR_FONT      : <br>          SendMessage (hwndDisplay , WMU_HFONTTODEMO, 0, <br>                       (LPARAM) GetStockObject(ANSI_VAR_FONT)); <br>          SendMessage (hwnd, WM_COMMAND, IDM_GETOBJECT, 0); <br>        break; <br>        case IDM_DEVICE_DEFAULT_FONT: <br>          SendMessage (hwndDisplay , WMU_HFONTTODEMO, 0, <br>                       (LPARAM) GetStockObject(DEVICE_DEFAULT_FONT)); <br>          SendMessage (hwnd, WM_COMMAND, IDM_GETOBJECT, 0); <br>        break; <br>        case IDM_OEM_FIXED_FONT     : <br>          SendMessage (hwndDisplay , WMU_HFONTTODEMO, 0, <br>                       (LPARAM) GetStockObject(OEM_FIXED_FONT)); <br>          SendMessage (hwnd, WM_COMMAND, IDM_GETOBJECT, 0); <br>        break; <br>        case IDM_SYSTEM_FIXED_FONT  : <br>          SendMessage (hwndDisplay , WMU_HFONTTODEMO, 0, <br>                       (LPARAM) GetStockObject(SYSTEM_FIXED_FONT)); <br>          SendMessage (hwnd, WM_COMMAND, IDM_GETOBJECT, 0); <br>        break; <br>        case IDM_SYSTEM_FONT        : <br>          SendMessage (hwndDisplay , WMU_HFONTTODEMO, 0, <br>                       (LPARAM) GetStockObject(SYSTEM_FONT)); <br>          SendMessage (hwnd, WM_COMMAND, IDM_GETOBJECT, 0); <br>        break; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_CHOOSEFONT <br>        * <br>        * Get the LOGFONT from the dialog, initialize the CHOOSEFONT struct, <br>        *  put up the ChooseFont() dialog, take the resulting LOGFONT and put <br>        *  it back in the dialog.  Force a createfont message. <br>        \******************************************************************/ <br>        case IDM_CHOOSEFONT: { <br>          CHOOSEFONT   chf; <br> <br>          /* fill a log font ahead of time to init the common dialog */ <br>          SendMessage (hwndDlgLF , WMU_LFTODEMO, 0, (LPARAM) &amp;lf); <br> <br>          chf.lStructSize = sizeof(CHOOSEFONT); <br>          chf.hwndOwner = hwnd; <br>          chf.hDC = NULL; <br>          chf.lpLogFont = &amp;lf; <br>          chf.iPointSize = 0; <br>          chf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT; <br>          // chf.Flags |= CF_EFFECTS; // no support for COLOR yet in TTFONTS. <br>          chf.rgbColors = RGB(0,0,0); <br>          chf.lCustData = 0; <br>          chf.lpfnHook = NULL; <br>          chf.lpTemplateName = NULL; <br>          chf.hInstance = hInst; <br>          chf.lpszStyle = NULL; <br>          chf.nFontType = SIMULATED_FONTTYPE; <br>          chf.nSizeMin = 0; <br>          chf.nSizeMax = 0; <br> <br>          if( ChooseFont( &amp;chf ) != FALSE ) { <br>            /* flyWinWin from client to dlgLF since we don't have hwnd <br>             *  for the common dialog, and since it is not a child window. <br>             */ <br>            flyWinWin (hwndMain, hwndClient, hwndDlgLF, FWW_STEPS); <br>            SendMessage (hwndDlgLF , WMU_DEMOTOLF, 0, (LPARAM) chf.lpLogFont); <br>            SendMessage (hwnd, WM_COMMAND, TBID_CREATE, 0); <br>          } <br>        } break; <br> <br> <br> <br> <br>        /* Simply send message to display window, and it does all work. */ <br>        case IDM_PRINT: <br>          SendMessage (hwndDisplay , WMU_PRINT, 0, 0); <br>        break; <br> <br> <br>        /* No printer, disable menu and button. */ <br>        case IDU_NOPRINTER: <br>          EnableMenuItem (GetMenu(hwnd), TBID_PRINT, MF_GRAYED); <br>          EnableMenuItem (GetMenu(hwnd), IDM_PRINT , MF_GRAYED); <br>          SendMessage (hwndTB , WM_COMMAND, IDU_NOPRINTER, 0); <br>        break; <br> <br> <br>        case IDM_HELP: <br>          WinHelp( hwnd, szHelpPathName, HELP_INDEX, (DWORD) NULL ); <br>        break; <br> <br> <br>        case IDM_ABOUT: <br>          DialogBox (hInst, TEXT("aboutBox"), hwnd, (DLGPROC) About); <br>        break; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_FLYWINWIN <br>        * <br>        * Check menu on and off.  Query state in FlyWinWin() function. <br>        \******************************************************************/ <br>        case IDM_FLYWINWIN: <br>          if (GetMenuState (GetMenu (hwnd),IDM_FLYWINWIN, MF_BYCOMMAND) <br>                == MF_CHECKED) { <br>            CheckMenuItem(GetMenu (hwnd), LOWORD(wParam) , MF_UNCHECKED); <br>          } else { <br>            CheckMenuItem(GetMenu (hwnd), LOWORD(wParam) , MF_CHECKED); <br>          } <br>        break; <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_MODE* <br>        * <br>        * manage mutually exclusive menu. <br>        *  inform the window that it has a new mode. <br>        *  invalidate window to force repaint. <br>        *  Special case MODEALL to check that it is o.k. first. <br>        \******************************************************************/ <br>        case IDM_MODEALL    : <br>          if (!SendMessage (hwndDisplay, WMU_NEWMODEALL, 0,0)) { <br>            return 0; <br>          } <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODEHELLO  , MF_UNCHECKED); <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODETMRANGE, MF_UNCHECKED); <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODEALL    , MF_CHECKED); <br>          InvalidateRect (hwndDisplay, NULL, TRUE); <br>        return 0; <br> <br>        case IDM_MODEHELLO  : <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODEHELLO  , MF_CHECKED); <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODETMRANGE, MF_UNCHECKED); <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODEALL    , MF_UNCHECKED); <br>          SendMessage (hwndDisplay, WMU_NEWMODEHELLO, 0,0); <br>          InvalidateRect (hwndDisplay, NULL, TRUE); <br>        return 0; <br> <br>        case IDM_MODETMRANGE: <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODEHELLO  , MF_UNCHECKED); <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODETMRANGE, MF_CHECKED); <br>          CheckMenuItem(GetMenu (hwnd), IDM_MODEALL    , MF_UNCHECKED); <br>          SendMessage (hwndDisplay, WMU_NEWMODETMRANGE, 0,0); <br>          InvalidateRect (hwndDisplay, NULL, TRUE); <br>        return 0; <br> <br> <br> <br>        /******************************************************************\ <br>        *  WM_COMMAND, IDM_* <br>        * <br>        * misc. MDI responsibilities.  hwndClient does real work. <br>        \******************************************************************/ <br>        case IDM_CASCADE: SendMessage (hwndClient, WM_MDICASCADE, 0,0); break; <br>        case IDM_TILE:    SendMessage (hwndClient, WM_MDITILE, 0,0); break; <br>        case IDM_ARRANGE: <br>          ShowWindow(hwndDisplayFonts, SW_SHOWMINIMIZED); <br>          ShowWindow(hwndPrinterFonts, SW_SHOWMINIMIZED); <br>          ShowWindow(hwndDlgOLTM, SW_SHOWMINIMIZED); <br>          ShowWindow(hwndDlgFD, SW_SHOWMINIMIZED); <br>          ShowWindow(hwndDlgTM, SW_RESTORE); <br>          SetWindowPos (hwndDlgTM, HWND_TOP, <br>              CHILDLEFT(0), CHILDTOP, 0,0, SWP_NOSIZE); <br>          ShowWindow(hwndDlgLF, SW_RESTORE); <br>          SetWindowPos (hwndDlgLF, HWND_TOP, <br>              CHILDLEFT(1), CHILDTOP, 0,0, SWP_NOSIZE); <br>          ShowWindow(hwndDisplay, SW_RESTORE); <br>          SetWindowPos (hwndDisplay, HWND_TOP, <br>              CHILDLEFT(2), CHILDTOP, <br>              GetSystemMetrics (SM_CXFULLSCREEN)/3 - 10, <br>              GetSystemMetrics (SM_CYFULLSCREEN)/3, 0); <br>          SendMessage (hwndClient, WM_MDIICONARRANGE, 0,0); <br>        break; <br> <br> <br> <br> <br>      } /* end switch */ <br>    } break;  /* end WM_COMMAND */ <br> <br> <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_CREATE <br>    * <br>    * Create pens for drawing with later. <br>    \**********************************************************************/ <br>    case WM_CREATE: <br>      hPenGrid   = CreatePen (PS_SOLID, 1, GRIDCOLOR); <br>      CheckMenuItem (GetMenu (hwnd), IDM_FLYWINWIN, MF_BYCOMMAND | MF_CHECKED); <br>      CheckMenuItem (GetMenu (hwnd), IDM_MODEHELLO, MF_BYCOMMAND | MF_CHECKED); <br>      gDisplaymode = IDM_MODEHELLO; <br>    break; <br> <br> <br>    /**********************************************************************\ <br>    *  WM_DESTROY <br>    * <br>    * Complement of the WM_CREATE message.  Delete the pens that were <br>    *  created and then call postquitmessage. <br>    \**********************************************************************/ <br>    case WM_DESTROY: <br>      DeleteObject (hPenGrid); <br>      WinHelp( hwnd, szHelpPathName, (UINT) HELP_QUIT, (DWORD) NULL ); <br>      PostQuitMessage(0); <br>    break; <br> <br> <br> <br>    /**********************************************************************\ <br>    *  WM_SIZE <br>    * <br>    * When the frame is sized, then change the size of the MDI client. <br>    \**********************************************************************/ <br>    case WM_SIZE: { <br> <br>      RECT r; <br>      GetClientRect (hwnd, &amp;r); <br>      r.top += TOOLBARHEIGHT; <br>      SetWindowPos (hwndClient, HWND_BOTTOM, <br>                    r.left, r.top, r.right, r.bottom - r.top, 0); <br>      return TRUE; <br> <br>    } break; <br> <br> <br>    default: break; <br>    } /* end switch */ <br> <br>  return (DefFrameProc(hwnd, hwndClient, message, wParam, lParam)); <br>} <br> <br> <br> <br>/***************************************************************************\ <br>*    FUNCTION: About <br>\***************************************************************************/ <br>LRESULT CALLBACK About(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>  if ((message == WM_COMMAND) &amp;&amp; (LOWORD(wParam) == IDOK)) { <br>    EndDialog (hwnd, TRUE); <br>    return TRUE; <br>  } <br>  if ((message == WM_SYSCOMMAND) &amp;&amp; (wParam == SC_CLOSE)) { <br>    EndDialog (hwnd, TRUE); <br>    return TRUE; <br>  } <br>  return FALSE; <br>} <br> <br> <br> <br> <br> <br>/**************************************************************************\ <br>*  function:  flyWinWin <br>* <br>* Send rectangles flying on the screen to indicate data flow. <br>* <br>*  input parameters: <br>*   handParent - parent window in which other two exist (grandchildren o.k.) <br>*   hwndFrom - rectangles originate here. <br>*   hwndTo   - and travel here. <br>*   steps    - number of steps to take.  Fewer is faster. <br>* <br>\**************************************************************************/ <br>VOID flyWinWin(HWND handParent, HWND hwndFrom, HWND hwndTo, int steps) <br>{ <br>RECT rectFrom, rectTo; <br>RECT rectI; <br>HDC hdc; <br>int i, iLeft, iTop, iRight, iBottom; <br> <br>    /* The menu bar contains a checked/unchecked item which stores the <br>     *  state of the user's preference on whether this "information flow" <br>     *  should be done or not.  If unchecked, then return before doing <br>     *  anything. <br>     */ <br>    if (GetMenuState (GetMenu (hwndMain),IDM_FLYWINWIN, MF_BYCOMMAND) <br>                != MF_CHECKED) return; <br> <br> <br>    /* retrieve the window rects in screen coordinates. */ <br>    GetWindowRect (hwndFrom, &amp;rectFrom); <br>    GetWindowRect (hwndTo, &amp;rectTo); <br> <br>    /* convert them to be relative to the parent window. */ <br>    ScreenToClient (handParent,(LPPOINT)&amp;rectFrom.left); <br>    ScreenToClient (handParent,(LPPOINT)&amp;rectFrom.right); <br>    ScreenToClient (handParent,(LPPOINT)&amp;rectTo.left); <br>    ScreenToClient (handParent,(LPPOINT)&amp;rectTo.right); <br> <br>    /* Get an HDC, set the ROP so that painting twice will restore to the <br>     *  same state.  Then select in the NULL brush so that the Rectangle() <br>     *  call will not fill in the interior. <br>     */ <br>    hdc = GetDC (handParent); <br>    SetROP2(hdc, R2_NOT); <br>    SelectObject (hdc, GetStockObject (NULL_BRUSH)); <br> <br>    /* Compute the increment to change on each step.  Notice that round <br>     *  off loss will cause the target window (hwndTo) to be "missed" if <br>     *  the windows nearly allign on some edge, and there are a large number <br>     *  of steps. <br>     */ <br>    iLeft =   (rectTo.left   - rectFrom.left)   /steps; <br>    iTop =    (rectTo.top    - rectFrom.top)    /steps; <br>    iRight =  (rectTo.right  - rectFrom.right)  /steps; <br>    iBottom = (rectTo.bottom - rectFrom.bottom) /steps; <br> <br>    /* Draw the series of rectangles the first time. */ <br>    rectI = rectFrom; <br>    for (i= 0; i&lt;steps; i++) { <br>      rectI.left += iLeft; <br>      rectI.top += iTop; <br>      rectI.right += iRight; <br>      rectI.bottom += iBottom; <br> <br>      Rectangle (hdc, rectI.left, rectI.top , rectI.right, rectI.bottom); <br>    } <br> <br>    /* start from the same place, and draw them again... this time erases. */ <br>    rectI = rectFrom; <br>    for (i= 0; i&lt; steps; i++) { <br>      rectI.left += iLeft; <br>      rectI.top += iTop; <br>      rectI.right += iRight; <br>      rectI.bottom += iBottom; <br> <br>      Rectangle (hdc, rectI.left, rectI.top , rectI.right, rectI.bottom); <br>    } <br> <br>    ReleaseDC (handParent,hdc); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
