<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATUS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3378"></a>STATUS.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>#define NOMINMAX <br>#include &lt;windows.h&gt; <br> <br>#include &lt;stdlib.h&gt; // For 'abs' <br> <br>#if !defined (APIENTRY) <br>#define APIENTRY FAR PASCAL <br>#endif <br> <br>#define MAXSTATUS 10 <br>typedef struct _tagStatus { <br>    HWND    hwnd; <br>    int     iMaxWidth, iMinWidth, iGiveWidth; <br>} Status; <br>Status  statusField[MAXSTATUS]; <br> <br>HWND    hwndStatus; <br>int    cntStatusField = 0; <br>int    dyStatus, cxStatusBorder, cyStatusBorder, cxFrame, cyFrame, dyField; <br>HFONT   hfontStatus; <br>TEXTMETRIC tmStatusFont; <br>HBRUSH hbrBtnFace; <br> <br>LONG APIENTRY StatusProc      (HWND, UINT, UINT, LONG); <br>LONG APIENTRY StatusFieldProc (HWND, UINT, UINT, LONG); <br> <br>BOOL InitStatusBar (HANDLE hInstance) <br>{ <br>    WNDCLASS    wndclass; <br> <br>    hbrBtnFace = CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br> <br>    wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc   = (WNDPROC)StatusProc; <br>    wndclass.cbClsExtra    = 0; <br>    wndclass.cbWndExtra    = 0; <br>    wndclass.hInstance      = hInstance; <br>    wndclass.hIcon     = NULL; <br>    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>    wndclass.hbrBackground = hbrBtnFace; <br>    wndclass.lpszMenuName  = NULL; <br>    wndclass.lpszClassName = "SamplerStatus"; <br> <br>    if (!RegisterClass (&amp;wndclass)) <br>        return FALSE; <br> <br>    wndclass.style         = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc   = (WNDPROC)StatusFieldProc; <br>    wndclass.cbClsExtra    = 0; <br>    wndclass.cbWndExtra    = 0; <br>    wndclass.hInstance      = hInstance; <br>    wndclass.hIcon     = NULL; <br>    wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>    wndclass.hbrBackground = hbrBtnFace; <br>    wndclass.lpszMenuName  = NULL; <br>    wndclass.lpszClassName = "StatusField"; <br> <br>    if (!RegisterClass (&amp;wndclass)) <br>        return FALSE; <br> <br>} <br> <br>BOOL CreateStatusBar (HWND hwnd, HANDLE hInst, int iId) <br>{ <br>    cxStatusBorder = GetSystemMetrics (SM_CXBORDER); <br>    cyStatusBorder = GetSystemMetrics (SM_CYBORDER); <br> <br>    hwndStatus = CreateWindow ("SamplerStatus", "SamplerStatus", <br>        WS_CHILD | WS_BORDER | WS_VISIBLE, <br>        0, 0, 0, 0, <br>        hwnd, (HMENU)iId, hInst, NULL); <br> <br>    if (!hwndStatus) { <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br>int StatusBarHeight (HWND hwnd) <br>{ <br>    RECT rect; <br>    GetClientRect (hwndStatus, &amp;rect); <br>    return rect.bottom-rect.top; <br> <br>    hwnd; // unreferenced formal parameter <br>} <br> <br>BOOL AdjustStatusBar (HWND hwnd) <br>{ <br>    RECT rect; <br>    GetClientRect (hwnd, &amp;rect); <br>    MoveWindow (hwndStatus, <br>        rect.left-cxStatusBorder, <br>        rect.bottom - dyStatus + cyStatusBorder, <br>        rect.right - rect.left + (cxStatusBorder*2), <br>        dyStatus, <br>    TRUE); <br>    return TRUE; <br>} <br> <br>HWND AddStatusField (HANDLE hInst, int iId, int iMin, int iMax, BOOL bNewGroup) <br>{ <br>    LONG lStyle; <br> <br>    if (cntStatusField &gt;= MAXSTATUS) return (HWND)0; // No room left in our fixed array <br> <br>    statusField[cntStatusField].hwnd = CreateWindow ("StatusField", "", <br>        WS_CHILD | WS_VISIBLE, <br>        0, 0, 0, 0, <br>        hwndStatus, (HMENU)iId, hInst, NULL); <br> <br>    if (!statusField[cntStatusField].hwnd) return (HWND)0; // CreateWindow failed for some reason <br> <br>    if (iMin &lt; 0) { <br>    statusField[cntStatusField].iMinWidth = tmStatusFont.tmAveCharWidth*abs(iMin); <br>    } else { <br>    statusField[cntStatusField].iMinWidth = iMin; <br>    } <br> <br>    if (iMax &lt; 0) { <br>    statusField[cntStatusField].iMaxWidth = tmStatusFont.tmAveCharWidth*abs(iMax); <br>    } else { <br>    statusField[cntStatusField].iMaxWidth = iMax; <br>    } <br> <br>    if (bNewGroup) { <br>        lStyle = GetWindowLong (statusField[cntStatusField].hwnd, GWL_STYLE); <br>        lStyle |= WS_GROUP; <br>        SetWindowLong (statusField[cntStatusField].hwnd, GWL_STYLE, lStyle); <br>    } <br> <br>    return statusField[cntStatusField++].hwnd; <br>} <br> <br>BOOL DestroyStatusBar (void) <br>{ <br>    return DeleteObject (hbrBtnFace); <br>} <br> <br>LONG APIENTRY StatusProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    HDC hdc; <br>    PAINTSTRUCT ps; <br>    int x, y, i; <br>    int wAvailWidth, wFlexWidth, cntFlexWidth, wNeedWidth, cntNeedWidth; <br>    RECT    rect, border; <br>    HBRUSH  hBrush; <br>    LOGFONT lfTmp; <br> <br>    switch (msg) { <br>        case WM_CREATE: <br>            hfontStatus = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, <br>                0, 0, 0, 0, <br>                VARIABLE_PITCH | FF_SWISS, ""); <br> <br>                        if (GetObject (hfontStatus, sizeof(LOGFONT), &amp;lfTmp)) { <br>                                if ((lfTmp.lfPitchAndFamily &amp; VARIABLE_PITCH) &amp;&amp; <br>                                   (lfTmp.lfPitchAndFamily &amp; FF_SWISS)) { <br>                                } else { <br>                                        MessageBox (GetFocus(), <br>"Unable to get an unnamed variable pitch swiss font", "Status Bar CreateFont Error", <br>                                                MB_OK); <br>                hfontStatus = CreateFont(14, 0, 0, 0, 0, 0, 0, 0, <br>                        0, 0, 0, 0, <br>                        VARIABLE_PITCH | FF_SWISS, "Arial"); <br>                                } <br>                        } <br> <br> <br>            if (!hfontStatus) { <br>                MessageBox (GetFocus(), "Failed To Create Font", "StatusProc", MB_OK); <br>            } <br>            hdc = GetDC (hwnd); <br>            SelectObject (hdc, hfontStatus); <br>            GetTextMetrics (hdc, &amp;tmStatusFont); <br>            cxStatusBorder = GetSystemMetrics (SM_CXBORDER); <br>            cyStatusBorder = GetSystemMetrics (SM_CYBORDER); <br>            cxFrame = 3*cxStatusBorder; <br>            cyFrame = 3*cyStatusBorder; <br>            dyField = tmStatusFont.tmHeight + (2*cyStatusBorder); <br>            dyStatus = dyField + (2*cyFrame); <br>            ReleaseDC (hwnd, hdc); <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br> <br>        case WM_DESTROY: <br>            if (hfontStatus) { <br>                DeleteObject (hfontStatus); <br>            } <br>            break; <br> <br>        case WM_SIZE: <br>        if (cntStatusField) { <br>                GetClientRect (hwnd, &amp;rect); <br>                wAvailWidth = rect.right - rect.left - (cxStatusBorder*8); <br>                wNeedWidth = 0; <br>                cntNeedWidth = 0; <br>                cntFlexWidth = 0; <br> <br>                /* First Pass: Dole out to fields that have a minimum need */ <br>                for (i=0; i&lt;cntStatusField; i++) { <br>                    statusField[i].iGiveWidth = 0; // Make sure all are initialized to 0 <br>                    if (statusField[i].iMinWidth) { <br>                        /* (n, ?) */ <br>                        statusField[i].iGiveWidth = statusField[i].iMinWidth; <br>                        wAvailWidth -= (statusField[i].iGiveWidth + cxStatusBorder*2); <br>                        if (GetWindowLong(statusField[i].hwnd, GWL_STYLE) &amp; WS_GROUP) { <br>                            wAvailWidth -= cxStatusBorder*4; <br>                        } <br>                    } else { <br>                        /* They didn't specify a minimum... don't give them anything yet */ <br>                        /* (0, ?) */ <br>                        statusField[i].iGiveWidth = 0; <br>                    } <br> <br>                    /* For those that have a minimum, but can grow to be as large as possible...*/ <br>                    /* (n, 0) */ <br>                    if ((statusField[i].iMinWidth &gt;0) &amp;&amp; (statusField[i].iMaxWidth ==0)) { <br>                        ++cntFlexWidth; <br>                    } <br> <br>                    /* For those that have a max that is greater then their min... */ <br>                    /* Includes (0,n) and (n,&gt;n) */ <br>                    if (statusField[i].iMaxWidth &gt; statusField[i].iGiveWidth) { <br>                        wNeedWidth += (statusField[i].iMaxWidth - statusField[i].iGiveWidth); <br>                        ++cntNeedWidth; <br>                    } <br>                } <br> <br>                /* Second Pass: Dole out to fields that have a stated maximum need */ <br>                /* This will also hit those who had no minimum, but did have a maximum */ <br>                /* It will still not give anything to those with no min, no max */ <br>                if ((cntNeedWidth &gt; 0) &amp;&amp; (wAvailWidth &gt; 0)) { <br>                    if (wNeedWidth &gt; wAvailWidth) { <br>                        wNeedWidth = wAvailWidth; <br>                    } <br>                    wNeedWidth = wNeedWidth / cntNeedWidth; <br>                    for (i=0; i&lt;cntStatusField; i++) { <br>                        if (statusField[i].iMaxWidth &gt; statusField[i].iGiveWidth) { <br>                            statusField[i].iGiveWidth += wNeedWidth; <br>                            wAvailWidth -= (statusField[i].iGiveWidth + cxStatusBorder*2); <br>                            if (GetWindowLong(statusField[i].hwnd, GWL_STYLE) &amp; WS_GROUP) { <br>                                wAvailWidth -= cxStatusBorder*4; <br>                            } <br>                        } <br>                    } <br>                } <br> <br>                /* Third Pass: Dole out the remaining to fields that want all they can get */ <br>                /* This includes those who had a minimum, but no maximum */ <br>                if ((cntFlexWidth &gt; 0) &amp;&amp; (wAvailWidth &gt; 0)) { <br>                    wFlexWidth = wAvailWidth / cntFlexWidth; <br>                    for (i=0; i&lt;cntStatusField; i++) { <br>                        if (statusField[i].iMaxWidth==0) { <br>                            statusField[i].iGiveWidth += wFlexWidth; <br>                            wAvailWidth -= ((wFlexWidth - statusField[i].iMinWidth) + cxStatusBorder*2); <br>                            if (GetWindowLong(statusField[i].hwnd, GWL_STYLE) &amp; WS_GROUP) { <br>                                wAvailWidth -= cxStatusBorder*4; <br>                            } <br>                        } <br>                    } <br>                } <br> <br>                x = cxStatusBorder*4; <br>                y = rect.top + (2*cyStatusBorder); <br>                for (i=0; i&lt;cntStatusField; i++) { <br>                    if (GetWindowLong (statusField[i].hwnd, GWL_STYLE) &amp; WS_GROUP) { <br>                        x += (cxStatusBorder*4); <br>                    } <br>                    MoveWindow (statusField[i].hwnd, x, y, statusField[i].iGiveWidth, dyField, TRUE); <br>                    x += statusField[i].iGiveWidth + (cxStatusBorder*2); <br>                } <br>            } <br>            break; <br> <br>        case WM_PAINT: <br>            hdc = BeginPaint (hwnd, &amp;ps); <br>            GetClientRect (hwnd, &amp;rect); <br> <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>            border = rect; <br>            border.bottom = border.top + cyStatusBorder; <br>            FillRect (hdc, &amp;border, hBrush); <br>            DeleteObject (hBrush); <br> <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br>            border = rect; <br>            border.top = border.bottom - cyStatusBorder; <br>            FillRect (hdc, &amp;border, hBrush); <br>            DeleteObject (hBrush); <br> <br>            EndPaint (hwnd, &amp;ps); <br> <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br> <br>        default: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>    } <br>    return 0L; <br>} <br> <br> <br> <br>LONG APIENTRY StatusFieldProc (HWND hwnd, UINT msg, UINT wParam, LONG lParam) <br>{ <br>    HDC     hdc; <br>    PAINTSTRUCT ps; <br>    RECT    rect, border; <br>    HBRUSH  hBrush; <br>    WORD    edge = 1; <br>    HFONT   hTmp; <br>    char szText[80]; <br>    int len; <br> <br>    switch (msg) { <br>        case WM_PAINT: <br>            hdc = BeginPaint (hwnd, &amp;ps); <br>            GetClientRect (hwnd, &amp;rect); <br> <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW)); <br>            border = rect; <br>            border.bottom = border.top + cyStatusBorder; <br>            FillRect (hdc, &amp;border, hBrush); <br>            border = rect; <br>            border.right = border.left + cxStatusBorder; <br>            FillRect (hdc, &amp;border, hBrush); <br>            DeleteObject (hBrush); <br> <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>            border = rect; <br>            border.top = border.bottom - cyStatusBorder; <br>            FillRect (hdc, &amp;border, hBrush); <br>            border = rect; <br>            border.left = border.right - cxStatusBorder; <br>            FillRect (hdc, &amp;border, hBrush); <br>            DeleteObject (hBrush); <br> <br>            if (len = GetWindowText(hwnd, szText, sizeof (szText))) { <br>                hTmp = SelectObject(hdc, hfontStatus); <br> <br>                SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT)); <br>                SetBkColor(hdc, GetSysColor(COLOR_BTNFACE)); <br> <br>                InflateRect (&amp;rect, -(cxStatusBorder*2), -cyStatusBorder); <br>                ExtTextOut(hdc, rect.left, rect.top, <br>                    ETO_OPAQUE | ETO_CLIPPED, <br>                    &amp;rect, <br>                    (LPSTR)szText, <br>                    len, NULL); <br> <br>                SelectObject (hdc, hTmp); <br>            } <br> <br>            EndPaint (hwnd, &amp;ps); <br>            break; <br> <br>        case WM_SETTEXT: <br>            InvalidateRect (hwnd, NULL, TRUE); <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br> <br>        default: <br>            return DefWindowProc (hwnd, msg, wParam, lParam); <br>    } <br>    return 0L; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
