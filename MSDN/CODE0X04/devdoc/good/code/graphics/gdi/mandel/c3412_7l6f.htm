<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>JULIA.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3417"></a>JULIA.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: julia.c <br>* <br>* Main module for the Mandelbrot Dream <br>*       contains almost everything; windows procedure + misc stuff <br>* <br>* Created: 24-Oct-1991 18:34:08 <br>* <br>* Copyright 1993 - 1998 Microsoft Corporation <br>* <br>* The Mandelbrot Dream serves to demonstrate the GDI and USER <br>* functionalities in the setting of fractals. <br>* <br>* The Mandelbrot Dream provides the following functions: <br>*       1.  Drawing the Mandelbrot set and the corresponding julia set <br>*       2.  Zooming into any of the set <br>*       3.  MDI fractal drawing windows <br>*       4.  Floating Point Math/Fix Point Math <br>*       5.  Shifting color table entries <br>*       6.  Changing palette entries and animating palatte aka color cycling <br>*       7.  Loading/Saving bitmap created with special effect <br>*       8.  Changing bitmap color with flood fill <br>*       9.  Boundary tracing and creating a clip region out of it for <br>*           creating special effect <br>*      10.  Enumerate printers for printing <br>*      11.  Load RLE (or convert .bmp files to RLE) for playing in viewer <br>*      12.  Save the RLE in memory to disk. <br>* <br>* Note: Users can now draw and saves the julia sets on disk as bmps in <br>*       the Julia windows.  These bitmaps can then be read into the memory <br>*       (and converted to RLE format) one by one for displaying in sequence <br>*       in the viewer window.  Eg Load the julia.rle in the viewer window <br>*       and select the play or play continuously menu item.     02-Jan-1993 <br>* <br>* Note2: The fix point math in this sample makes use of the LargeInteger <br>*        64 bit math library. <br>* <br>* Dependencies: <br>* <br>*       none <br>* <br>\**************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;math.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include "julia.h" <br> <br>// <br>// For T1 to create all pens in advance.  This is not a good approach <br>// because pens are per thread basis.  The drawing threads won't be able <br>// to use them if they are not created in their threads.    18-Sep-1992 <br>// <br>//#define THRDONE <br> <br>#define CYCLETHRD <br> <br>#define PRTTHRD <br>#define NEWPRTAPI <br> <br>#ifndef DEBUG <br>   #undef OutputDebugString <br>   #define OutputDebugString(LPCSTR) <br>#endif <br> <br>// <br>// Forward declarations. <br>// <br>BOOL InitializeApp            (INT*); <br>LONG APIENTRY MainWndProc     (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY ChildWndProc    (HWND, UINT, DWORD, LONG); <br>BOOL CALLBACK About           (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY TextWndProc     (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY JuliaWndProc    (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY ViewerWndProc   (HWND, UINT, DWORD, LONG); <br>LONG APIENTRY ViewSurfWndProc (HWND, UINT, DWORD, LONG); <br>BOOL APIENTRY SuspendDrawThrd (HWND, LONG); <br>BOOL APIENTRY ResumeDrawThrd  (HWND, LONG); <br>BOOL StartDraw       (PINFO); <br>BOOL StartDrawFix    (PINFO); <br>BOOL StartDraw2      (PINFO); <br>BOOL StartMandelbrot (PINFO); <br>BOOL StartMandelbrotFix (PINFO); <br>HBITMAP SaveBitmap   (HWND, HPALETTE); <br>void DrawBitmap      (HDC, PINFO, int, int, int, int); <br>BOOL bDrawDIB        (HDC, PINFO, int, int, int, int); <br>LONG lMul(LONG, LONG); <br>LONG lDiv(LONG, LONG); <br>PINFO pGetInfoData(HWND); <br>BOOL bReleaseInfoData(HWND); <br>BOOL bCheckMutexMenuItem(PINFO, HMENU, UINT); <br>VOID vChkMenuItem(PINFO, HMENU, UINT); <br>BOOL bInitInfo(PINFO); <br>BOOL bResetGlobal(VOID); <br>HBRUSH hBrCreateBrush(HDC, DWORD); <br>BOOL bPrintBmp(PPRTDATA); <br>BOOL bStoreRleFile(HDC, PINFO, PSTR); <br>BOOL bFreeRleFile(PINFO); <br>BOOL bPlayRle(PINFO); <br>BOOL bSaveRleFile(HDC, PINFO, PSTR); <br>BOOL bPlayRleCont2(PINFO); <br>BOOL bSelectDIBPal(HDC, PINFO, LPBITMAPINFO, BOOL); <br>HBITMAP DIBfromDDB(HDC, HBITMAP, PINFO); <br> <br> <br>// <br>// Global variable declarations. <br>// <br> <br>HPEN   hpnRed; <br>HPEN   hpnBlack; <br>HPEN   hpnGreen; <br>INT    giPen = 0; <br> <br>HANDLE ghModule; <br>HWND   ghwndMain = NULL; <br>HWND   ghwndClient = NULL; <br>HANDLE ghAccel; <br> <br>HMENU  hMenu, hChildMenu, hViewMenu; <br>HMENU  hViewSubOne, hSubMenuOne, hSubMenuThree; <br>HMENU  hPrinterMenu; <br> <br>CHAR   gszFile[20]; <br>CHAR   gszMapName[20]; <br>char   gtext[256]; <br> <br>BOOL   gFloat = TRUE; <br>LONG   gStep = 1; <br>LONG   gIteration = 500; <br>BOOL   gbStretch = TRUE; <br>INT    giStretchMode = COLORONCOLOR; <br>INT    giDmOrient = DMORIENT_PORTRAIT; <br>INT    giNPrinters = 0; <br> <br>HPALETTE        ghPal, ghPalOld; <br> <br>double xFrom, xTo, yFrom, yTo, c1, c2; <br>LONG   lxFrom, lxTo, lyFrom, lyTo, lc1, lc2; <br> <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* WinMain <br>* <br>\**************************************************************************/ <br> <br>int WINAPI WinMain( <br>    HINSTANCE hInstance, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nShowCmd) <br>{ <br>    MSG    msg; <br> <br>    ghModule = GetModuleHandle(NULL); <br>    if (!InitializeApp(&amp;giPen))  <br>{ <br>OutputDebugString("memory: InitializeApp failure!"); <br>return 0; <br>    } <br> <br>    if (!(ghAccel = LoadAccelerators (ghModule, MAKEINTRESOURCE(ACCEL_ID)))) <br>OutputDebugString("memory: Load Accel failure!"); <br> <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0))  <br>{ <br>if (!TranslateAccelerator( ghwndMain, ghAccel, &amp;msg) &amp;&amp; <br>    !TranslateMDISysAccel( ghwndClient, &amp;msg))  <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>} <br>    } <br> <br> <br>    DeleteObject(ghPal); <br> <br>    return 1; <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); <br>    UNREFERENCED_PARAMETER(nShowCmd); <br>    UNREFERENCED_PARAMETER(hInstance); <br>    UNREFERENCED_PARAMETER(hPrevInstance); <br>} <br> <br> <br>/***************************************************************************\ <br>* InitializeApp <br>* <br>\***************************************************************************/ <br> <br>BOOL InitializeApp(INT *piPen) <br>{ <br>    WNDCLASS wc; <br>    HDC      hDC; <br> <br>#ifdef THRDONE <br>    INT      iNumClr; <br>#endif <br> <br>    wc.style            = CS_OWNDC; <br>    wc.lpfnWndProc      = (WNDPROC)MainWndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra       = sizeof(LONG); <br>    wc.hInstance        = ghModule; <br>    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(APPICON)); <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE); <br>    wc.lpszMenuName     = "MainMenu"; <br>    wc.lpszClassName    = "MandelClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>return FALSE; <br> <br>    wc.lpfnWndProc      = (WNDPROC)ChildWndProc; <br>    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(APPICON)); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "ChildClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>return FALSE; <br> <br>    wc.lpfnWndProc      = (WNDPROC)ViewerWndProc; <br>    wc.hIcon            = LoadIcon(ghModule, MAKEINTRESOURCE(VIEWICON)); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "ViewerClass"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>return FALSE; <br> <br>    wc.style            = CS_OWNDC | CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc      = (WNDPROC)TextWndProc; <br>    wc.hIcon            = NULL; <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BTNSHADOW); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "Text"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>    return FALSE; <br> <br>    wc.style            = CS_OWNDC | CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc      = (WNDPROC)JuliaWndProc; <br>    wc.hIcon            = NULL; <br> <br>    // <br>    // Nope.  Can't have this, screw up my Paint Can cursor <br>    // <br>    //wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br> <br>    wc.hCursor          = NULL; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BACKGROUND); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "Julia"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>    return FALSE; <br> <br>    wc.style            = CS_OWNDC | CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc      = (WNDPROC)ViewSurfWndProc; <br>    wc.hIcon            = NULL; <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground    = (HBRUSH)(COLOR_BACKGROUND); <br>    wc.lpszMenuName     = NULL; <br>    wc.lpszClassName    = "View"; <br> <br>    if (!RegisterClass(&amp;wc)) <br>    return FALSE; <br> <br> <br>    // <br>    // Notice, submenu is zero-based <br>    // <br>    hMenu       = LoadMenu(ghModule, "MainMenu"); <br>    hChildMenu  = LoadMenu(ghModule, "ChildMenu"); <br>    hViewMenu   = LoadMenu(ghModule, "ViewMenu"); <br>    hViewSubOne = GetSubMenu(hViewMenu, 1); <br>    hSubMenuOne = GetSubMenu(hMenu, 1); <br>    hSubMenuThree = GetSubMenu(hChildMenu, 8); <br>    hPrinterMenu = GetSubMenu(hChildMenu, 7); <br> <br>    // <br>    // Disable color-cycling for display devices that does not support <br>    // palette like the VGA.  As as 29-May-1992, the MIPS display driver <br>    // is the only one that supports palette <br>    // <br>    hDC = GetDC(NULL); <br>    if (!((GetDeviceCaps(hDC, RASTERCAPS)) &amp; RC_PALETTE)) { <br>EnableMenuItem(hChildMenu, MM_CYCLE, MF_GRAYED); <br>    } <br> <br>#ifdef THRDONE <br> <br>    if ((iNumClr = iCreatePenFrPal(hDC, NULL, 0, &amp;ghPal)) != 0)  <br>{ <br>sprintf( gtext,"iNumClr = %d\n", iNumClr); <br>OutputDebugString( gtext); <br> <br>if ((pInfo-&gt;prghPen = (PVOID*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(HPEN)*iNumClr)) == NULL)  <br>    OutputDebugString ("Failed in Memory Allocation for pInfo-&gt;prghPen!"); <br>else  <br>if ((*piPen = iCreatePenFrPal(hDC, pInfo-&gt;prghPen, 0, &amp;ghPal)) == 0) <br>OutputDebugString("Failed in creating pen!"); <br>    } <br> <br>#endif <br>    ReleaseDC(NULL, hDC); <br> <br>    ghwndMain = CreateWindowEx(0L, "MandelClass",  <br>   GetStringRes (IDS_MANDEL_DREAM), <br> <br>    WS_OVERLAPPED   | WS_CAPTION     | WS_BORDER       | <br>    WS_THICKFRAME   | WS_MAXIMIZEBOX | WS_MINIMIZEBOX  | <br>    WS_CLIPCHILDREN | WS_VISIBLE     | WS_SYSMENU, <br>    80, 70, 550, 400 /* 550 */, <br>    NULL, hMenu, ghModule, NULL); <br> <br>    if (ghwndMain == NULL) <br>return FALSE; <br> <br>    bInitPrinter(ghwndMain); <br> <br>    SetWindowLong(ghwndMain, GWL_USERDATA, 0L); <br> <br>    SetFocus(ghwndMain);    /* set initial focus */ <br> <br>    PostMessage(ghwndMain, WM_COMMAND, MM_MANDEL, 0L); <br>    PostMessage(ghwndMain, WM_COMMAND, MM_CREATE_MANDEL_THREAD, 0L); <br> <br>    return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* MainWndProc <br>* <br>\**************************************************************************/ <br> <br>long APIENTRY MainWndProc( <br>    HWND hwnd, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    static int         iJuliaCount=1; <br>    static int         iMandelCount=1; <br>    static int         iViewerCount=1; <br>    CLIENTCREATESTRUCT clientcreate; <br>    HWND               hwndChildWindow; <br>    static FARPROC     lpfnSuspendThrd, lpfnResumeThrd; <br> <br> <br>    switch (message) { <br> <br>      case WM_CREATE: <br>SetWindowLong(hwnd, 0, (LONG)NULL); <br> <br>clientcreate.hWindowMenu  = hSubMenuOne; <br>clientcreate.idFirstChild = 1; <br> <br>ghwndClient = CreateWindow("MDICLIENT", NULL, <br>    WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE, <br>    0,0,0,0, <br>    hwnd, NULL, ghModule, (LPVOID)&amp;clientcreate); <br>lpfnSuspendThrd = (FARPROC)MakeProcInstance (SuspendDrawThrd, ghModule); <br>lpfnResumeThrd  = (FARPROC)MakeProcInstance (ResumeDrawThrd, ghModule); <br> <br>return 0L; <br> <br>      case WM_DESTROY: { <br>bCleanupPrinter(); <br>PostQuitMessage(0); <br>return 0L; <br>      } <br> <br>      // <br>      // Wait! User is going to zero out our app's visible region.  This <br>      // is going to mess up our drawing (we are not keeping any shadow <br>      // bitmap in this version yet.) So, let's suspend our drawing thread <br>      // first before user does that.  We will resume after user is done. <br>      // <br>      case WM_SYSCOMMAND: { <br>LONG        lResult; <br> <br>// <br>// We'll enumerate our children and suspend their drawing thread. <br>// <br>EnumChildWindows(ghwndClient, (WNDENUMPROC)lpfnSuspendThrd, lParam); <br> <br>// <br>// Now, let user does it supposed to do <br>// <br>lResult = DefFrameProc(hwnd,  ghwndClient, message, wParam, lParam); <br> <br>// <br>// User's done, we'll resume the suspended threads in our children <br>// <br>EnumChildWindows(ghwndClient, (WNDENUMPROC)lpfnResumeThrd, lParam); <br> <br>return lResult; <br>break; <br>      } <br>#if 0 <br>      // <br>      // Our window's size is going to change, we'll make sure the new <br>      // window is a square. <br>      // <br>      case WM_WINDOWPOSCHANGING: { <br>    PWINDOWPOS pWndPos; <br>    RECT       rect; <br>    LONG       lcx, lcy; <br> <br>    GetWindowRect(hwnd, &amp;rect); <br>    lcx = rect.right-rect.left; <br>    lcy = rect.bottom-rect.top; <br>    pWndPos = (PWINDOWPOS)lParam; <br>    if ((pWndPos-&gt;cy &gt; lcy) || (pWndPos-&gt;cx &gt; lcx)) <br>pWndPos-&gt;cx =  pWndPos-&gt;cy = <br>   ((pWndPos-&gt;cx &gt; pWndPos-&gt;cy) ? pWndPos-&gt;cy : pWndPos-&gt;cx); <br>    else if ((pWndPos-&gt;cy &lt; lcy) || (pWndPos-&gt;cx &lt; lcx)) <br>     pWndPos-&gt;cx =  pWndPos-&gt;cy = <br>((pWndPos-&gt;cx &gt; pWndPos-&gt;cy) ? pWndPos-&gt;cy : pWndPos-&gt;cx); <br>    break; <br>      } <br>#endif <br> <br>      case WM_COMMAND: <br> <br>switch (LOWORD(wParam)) { <br>    case IDM_TILE: <br>SendMessage(ghwndClient, WM_MDITILE, 0L, 0L); <br>return 0L; <br>    case IDM_CASCADE: <br>SendMessage(ghwndClient, WM_MDICASCADE, 0L, 0L); <br>return 0L; <br>    case IDM_ARRANGE: <br>SendMessage(ghwndClient, WM_MDIICONARRANGE, 0L, 0L); <br>return 0L; <br> <br>    // <br>    // Create Julia or Mandelbrot set <br>    // <br>    case MM_JULIA: <br>    case MM_MANDEL: { <br>HANDLE hInfo; <br>PINFO  pInfo; <br>MDICREATESTRUCT mdicreate; <br> <br>hInfo = LocalAlloc(LHND, (WORD) sizeof(INFO)); <br>if (hInfo == NULL)  <br>{ <br>    OutputDebugString("Failed to Allocate Info!"); <br>    return 0L; <br>} <br>if ((pInfo = (PINFO)LocalLock(hInfo)) == NULL)  <br>{ <br>    OutputDebugString("Failed in LocalLock, hInfo"); <br>    return 0L; <br>} <br> <br>bInitInfo(pInfo); <br>wsprintf((LPSTR) &amp;(pInfo-&gt;CaptionBarText), <br> (LOWORD(wParam) == MM_JULIA) ?  <br> GetStringRes (IDS_JULIA):  <br> GetStringRes (IDS_MANDELBROT), <br> (LOWORD(wParam) == MM_JULIA) ? iJuliaCount : iMandelCount); <br>if (LOWORD(wParam) == MM_JULIA) { <br>    c1 = 0.360284; <br>    c2 = 0.100376; <br>    lc1 = 738;          //.3603515 <br>    lc2 = 206;          //.1005859 <br>    pInfo-&gt;bMandel = FALSE; <br>} else { <br>    pInfo-&gt;bMandel = TRUE; <br>} <br> <br>// <br>// Fill in the MDICREATE structure for MDI child creation <br>// <br>mdicreate.szClass = "ChildClass"; <br>mdicreate.szTitle = (LPTSTR)&amp;(pInfo-&gt;CaptionBarText); <br>mdicreate.hOwner  = ghModule; <br>mdicreate.x       = <br>mdicreate.y       = CW_USEDEFAULT; <br>mdicreate.cx      = 300; <br>mdicreate.cy      = 300; <br>mdicreate.style   = 0L; <br>mdicreate.lParam  = (LONG) hInfo; <br> <br>/*Create Child Window*/ <br>hwndChildWindow = <br>    (HANDLE) SendMessage(ghwndClient, WM_MDICREATE, <br>0L, <br>(LONG)(LPMDICREATESTRUCT)&amp;mdicreate); <br> <br>if (hwndChildWindow == NULL)  <br>{ <br>    OutputDebugString ("Failed in Creating Child Window"); <br>    return 0L; <br>} <br> <br>(LOWORD(wParam) == MM_JULIA) ? iJuliaCount++ : iMandelCount++ ; <br>LocalUnlock(hInfo); <br>return ((LONG)hwndChildWindow); <br>    } <br> <br>    case MM_RLEVIEWER: { <br>HANDLE hInfo; <br>PINFO  pInfo; <br>MDICREATESTRUCT mdicreate; <br> <br>hInfo = LocalAlloc(LHND, (WORD) sizeof(INFO)); <br>if (hInfo == NULL)  <br>{ <br>    OutputDebugString ("Failed to Allocate Info!"); <br>    return 0L; <br>} <br>if ((pInfo = (PINFO)LocalLock(hInfo)) == NULL)  <br>{ <br>    OutputDebugString ("Failed in LocalLock, hInfo"); <br>    return 0L; <br>} <br> <br>bInitInfo(pInfo); <br>wsprintf((LPSTR) &amp;(pInfo-&gt;CaptionBarText), GetStringRes (IDS_VIEWER), iViewerCount ); <br> <br>// <br>// Fill in the MDICREATE structure for MDI child creation <br>// <br>mdicreate.szClass = "ViewerClass"; <br>mdicreate.szTitle = (LPTSTR)&amp;(pInfo-&gt;CaptionBarText); <br>mdicreate.hOwner  = ghModule; <br>mdicreate.x       = <br>mdicreate.y       = CW_USEDEFAULT; <br>mdicreate.cx      = 300; <br>mdicreate.cy      = 300; <br>mdicreate.style   = 0L; <br>mdicreate.lParam  = (LONG) hInfo; <br> <br>/*Create Child Window*/ <br>hwndChildWindow = <br>    (HANDLE) SendMessage(ghwndClient, WM_MDICREATE, <br>0L, <br>(LONG)(LPMDICREATESTRUCT)&amp;mdicreate); <br> <br>if (hwndChildWindow == NULL)  <br>{ <br>    OutputDebugString ("Failed in Creating Child Window"); <br>    return 0L; <br>} <br> <br>iViewerCount++ ; <br>LocalUnlock(hInfo); <br>return ((LONG)hwndChildWindow); <br> <br>    } <br> <br>    case MM_ABOUT: <br>if (DialogBox(ghModule, "AboutBox", ghwndMain, (DLGPROC)About) == -1) <br>   OutputDebugString ("DEMO: About Dialog Creation Error!"); <br>return 0L; <br> <br>    // <br>    // Only my children know how to deal with these messages, so <br>    // pass these to children for processing <br>    // <br>    case MM_CREATE_JULIA_THREAD: <br>    case MM_SET_XFORM_ATTR: <br>    case MM_CREATE_MANDEL_THREAD: <br>    case MM_OPT_4:              // currently not used <br>    case MM_DRAW_SET: <br>    case MM_SETDIB2DEVICE: <br>    case MM_BW: <br>    case MM_SHIFT: <br>    case MM_CUSTOM: <br>    case MM_CYCLE: <br>    case MM_TP_IDLE: <br>    case MM_TP_LOW: <br>    case MM_TP_BELOW_NORMAL: <br>    case MM_TP_NORMAL: <br>    case MM_TP_ABOVE_NORMAL: <br>    case MM_TP_HIGH: <br>    case MM_TP_TIME_CRITICAL: <br>    case MM_FLOAT: <br>    case MM_FIX: <br>    case MM_ITERATION_100: <br>    case MM_ITERATION_500: <br>    case MM_ITERATION_1000: <br>    case MM_ITERATION_5000: <br>    case MM_ITERATION_DOUBLE: <br>    case MM_STEP_ONE: <br>    case MM_STEP_TWO: <br>    case MM_STEP_THREE: <br>    case MM_SAVE: <br>    case MM_SAVE_MONO: <br>    case MM_LOAD: <br>    case MM_STRETCHBLT: <br>    case MM_BITBLT: <br>    case MM_BLACKONWHITE: <br>    case MM_COLORONCOLOR: <br>    case MM_WHITEONBLACK: <br>    case MM_HALFTONE: <br>    case MM_CLIP: <br>    case MM_RM_CLIP: <br>    case MM_SELCLIPRGN: <br>    case MM_ERASE: <br>    case MM_PORTRAIT: <br>    case MM_LANDSCAPE: <br>    case MM_PRINTER: <br>    case MM_PRINTER + 1: <br>    case MM_PRINTER + 2: <br>    case MM_PRINTER + 3: <br>    case MM_PRINTER + 4: <br>    case MM_PRINTER + 5: <br>    case MM_PRINTER + 6: <br>    case MM_PRINTER + 7: <br>    case MM_PRINTER + 8: <br>    case MM_PRINTER + 9: <br>    case MM_RLELOAD_DEMO: <br>    case MM_RLEPLAYCONT: <br>    case MM_RLELOAD: <br>    case MM_RLESAVE: <br>    case MM_CLEAR: <br>    case MM_RLEPLAY: <br>    { <br>HWND hActiveChild; <br> <br>hActiveChild = (HANDLE) SendMessage(ghwndClient, WM_MDIGETACTIVE, 0L, 0L); <br>if (hActiveChild) <br>    SendMessage(hActiveChild, WM_COMMAND, wParam, lParam); <br>return 0L; <br>    } <br> <br>    default: <br>return DefFrameProc(hwnd,  ghwndClient, message, wParam, lParam); <br>} <br>    default: <br> <br>return DefFrameProc(hwnd,  ghwndClient, message, wParam, lParam); <br>    } <br>} <br> <br>/***************************************************************************\ <br>* ChildWndProc <br>* <br>\***************************************************************************/ <br> <br>long APIENTRY ChildWndProc( <br>    HWND hwnd, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    static FARPROC     lpfnSuspendThrd, lpfnResumeThrd; <br>    static BOOL        bDIB2Device = FALSE; <br> <br>    sprintf( gtext,"message = %lx\n", message); <br>    OutputDebugString( gtext); <br> <br>    switch (message) { <br>case WM_COMMAND: { <br>  PINFO       pInfo; <br>  HWND        hTextWnd; <br> <br>  switch (LOWORD(wParam)) { <br>    // <br>    // Create a Julia drawing thread <br>    // <br>    case MM_CREATE_JULIA_THREAD: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext,"(%g, %g) &lt;-&gt; (%g, %g)", pInfo-&gt;xFrom, pInfo-&gt;yFrom, pInfo-&gt;xTo, pInfo-&gt;yTo); <br>SetWindowText(hTextWnd, gtext); <br>sprintf( gtext,"(c1 = %g, c2 = %g)\n\n", pInfo-&gt;c1, pInfo-&gt;c2); <br>OutputDebugString( gtext ); <br> <br>if (pInfo-&gt;hThrd) <br>    CloseHandle(pInfo-&gt;hThrd); <br> <br>pInfo-&gt;hThrd = CreateThread(NULL, 0, <br> (gFloat ? (LPTHREAD_START_ROUTINE)StartDraw : (LPTHREAD_START_ROUTINE)StartDrawFix), <br> pInfo, <br> STANDARD_RIGHTS_REQUIRED, <br> &amp;pInfo-&gt;dwThreadId ); <br> <br>       if (pInfo-&gt;hThrd &amp;&amp; pInfo-&gt;bDrawing)  <br>   { <br>   if (!SetThreadPriority(pInfo-&gt;hThrd, pInfo-&gt;iPriority)) <br>     OutputDebugString ("Can't set Priority!"); <br>       } <br> <br>       bReleaseInfoData(hwnd); <br>       return 0L; <br>    } <br> <br>    // <br>    // Reset pInfo reflecting new transformation <br>    // <br>    case MM_SET_XFORM_ATTR: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>SetWindowText(hTextWnd, GetStringRes (IDS_CLICK_HERE_VIEW)); <br> <br>pInfo-&gt;xFrom      = xFrom; <br>pInfo-&gt;xTo        = xTo; <br>pInfo-&gt;yFrom      = yFrom; <br>pInfo-&gt;yTo        = yTo; <br>pInfo-&gt;c1         = c1; <br>pInfo-&gt;c2         = c2; <br>pInfo-&gt;lxFrom      = lxFrom; <br>pInfo-&gt;lxTo        = lxTo; <br>pInfo-&gt;lyFrom      = lyFrom; <br>pInfo-&gt;lyTo        = lyTo; <br>pInfo-&gt;lc1         = lc1; <br>pInfo-&gt;lc2         = lc2; <br> <br>       bReleaseInfoData(hwnd); <br>       return 0L; <br>    } <br> <br>    // <br>    // Create a Mandelbrot drawing thread <br>    // <br>    case MM_CREATE_MANDEL_THREAD: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext,"(%g, %g) &lt;-&gt; (%g, %g)", pInfo-&gt;xFrom, pInfo-&gt;yFrom, pInfo-&gt;xTo, pInfo-&gt;yTo); <br>SetWindowText(hTextWnd, gtext); <br>sprintf( gtext,"(c1 = %g, c2 = %g)\n\n", pInfo-&gt;c1, pInfo-&gt;c2); <br>OutputDebugString( gtext ); <br> <br>if (pInfo-&gt;hThrd) <br>    CloseHandle(pInfo-&gt;hThrd); <br> <br>pInfo-&gt;hThrd = CreateThread(NULL, 0, <br> (gFloat ? (LPTHREAD_START_ROUTINE)StartMandelbrot : (LPTHREAD_START_ROUTINE)StartMandelbrotFix), <br> pInfo, <br> STANDARD_RIGHTS_REQUIRED, <br> &amp;pInfo-&gt;dwThreadId ); <br> <br>       if (pInfo-&gt;hThrd &amp;&amp; pInfo-&gt;bDrawing)  <br>   { <br>  if (!SetThreadPriority(pInfo-&gt;hThrd, pInfo-&gt;iPriority)) <br>     OutputDebugString ("Can't set Priority!"); <br>       } <br> <br> <br>       bReleaseInfoData(hwnd); <br>       return 0L; <br>    } <br> <br>    // <br>    // Create a Julia drawing thread using algorithm StartDraw2 <br>    // Currently not used <br>    // <br>    case MM_OPT_4: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>SetWindowText(hTextWnd, "MM_OPT_4"); <br> <br>sprintf( gtext,"xFrom = %g, xTo = %g, yFrom = %g, yTo = %g\n", pInfo-&gt;xFrom, pInfo-&gt;xTo, pInfo-&gt;yFrom, pInfo-&gt;yTo); <br>OutputDebugString( gtext ); <br> <br>if (pInfo-&gt;hThrd) <br>    CloseHandle(pInfo-&gt;hThrd); <br> <br>pInfo-&gt;hThrd = CreateThread(NULL, 0, <br> (LPTHREAD_START_ROUTINE)StartDraw2, <br> pInfo, <br> STANDARD_RIGHTS_REQUIRED, <br> &amp;pInfo-&gt;dwThreadId ); <br> <br>       if (pInfo-&gt;hThrd &amp;&amp; pInfo-&gt;bDrawing)  <br>   { <br>      if (!SetThreadPriority(pInfo-&gt;hThrd, pInfo-&gt;iPriority)) <br>     OutputDebugString ("Can't set Priority!"); <br>       } <br> <br>       bReleaseInfoData(hwnd); <br>       return 0L; <br>    } <br> <br>    case MM_DRAW_SET: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>PostMessage(hwnd, WM_COMMAND, <br>    pInfo-&gt;bMandel ? (DWORD)((WORD)MM_CREATE_MANDEL_THREAD) : (DWORD)((WORD)MM_CREATE_JULIA_THREAD), <br>    (LONG)0L); <br> <br>       bReleaseInfoData(hwnd); <br>       return 0L; <br>    } <br> <br>    { <br>    int     iPriority; <br> <br>case MM_TP_IDLE: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_IDLE; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_IDLE); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    goto CWP_SET_PRIORITY; <br> <br>case MM_TP_LOW: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_LOWEST; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_LOW); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    goto CWP_SET_PRIORITY; <br> <br>case MM_TP_BELOW_NORMAL: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_BELOW_NORMAL; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_BELOW_NORMAL); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    goto CWP_SET_PRIORITY; <br> <br>case MM_TP_NORMAL: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_NORMAL; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_NORMAL); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    goto CWP_SET_PRIORITY; <br> <br>case MM_TP_ABOVE_NORMAL: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_ABOVE_NORMAL; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_ABOVE_NORMAL); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    goto CWP_SET_PRIORITY; <br> <br>case MM_TP_HIGH: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_HIGHEST; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_HIGH); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    goto CWP_SET_PRIORITY; <br> <br>case MM_TP_TIME_CRITICAL: <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    iPriority = THREAD_PRIORITY_TIME_CRITICAL; <br>    bCheckMutexMenuItem(pInfo, hChildMenu, MM_TP_TIME_CRITICAL); <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br> <br>CWP_SET_PRIORITY: <br>    { <br>       HANDLE       hThrd; <br> <br>       hThrd = pInfo-&gt;hThrd; <br>       pInfo-&gt;iPriority = iPriority; <br> <br>       if (hThrd &amp;&amp; pInfo-&gt;bDrawing)  <br>   { <br>      if (!SetThreadPriority(hThrd, iPriority)) <br>     OutputDebugString ("Can't set Priority!"); <br>       } <br> <br>    } <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br> <br>    } <br> <br>    case MM_FLOAT: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_FLOAT); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gFloat = TRUE; <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_FIX: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_FIX); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gFloat = FALSE; <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_ITERATION_100: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_ITERATION_100); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gIteration = 100; <br>pInfo-&gt;iIteration = 100; <br>SetWindowText(pInfo-&gt;hTextWnd, GetStringRes (IDS_ITER_100)); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_ITERATION_500: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL){ <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_ITERATION_500); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gIteration = 500; <br> <br>pInfo-&gt;iIteration = 500; <br>SetWindowText(pInfo-&gt;hTextWnd, GetStringRes (IDS_ITER_500)); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_ITERATION_1000: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_ITERATION_1000); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gIteration = 1000; <br>pInfo-&gt;iIteration = 1000; <br>SetWindowText(pInfo-&gt;hTextWnd, GetStringRes (IDS_ITER_1000)); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_ITERATION_5000: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_ITERATION_5000); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gIteration = 5000; <br>pInfo-&gt;iIteration = 5000; <br>SetWindowText(pInfo-&gt;hTextWnd, GetStringRes (IDS_ITER_5000)); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_ITERATION_DOUBLE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_ITERATION_DOUBLE); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gIteration *= 2; <br>pInfo-&gt;iIteration = gIteration; <br>sprintf( gtext, GetStringRes (IDS_ITERATION), pInfo-&gt;iIteration); <br>SetWindowText(pInfo-&gt;hTextWnd, gtext); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_STEP_ONE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_STEP_ONE); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gStep = 1; <br>pInfo-&gt;iStep = 1; <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_STEP_TWO:  { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL){ <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_STEP_TWO); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gStep = 2; <br>pInfo-&gt;iStep = 2; <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_STEP_THREE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_STEP_THREE); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>gStep = 3; <br>pInfo-&gt;iStep = 3; <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br> <br>    case MM_LOAD: { <br>HDC hDC; <br>OPENFILENAME ofn; <br>char szDirName[256]; <br>char szFile[256], szFileTitle[256]; <br>static char *szFilter; <br>RECT    rc; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL){ <br>    return 0L; <br>} <br> <br>szFilter = GetStringRes (IDS_FILE_LIST1); <br> <br>GetSystemDirectory((LPSTR) szDirName, 256); <br>strcpy(szFile, "*.bmp\0"); </code></pre>
<p>
</p>
<pre><code>ofn.lStructSize = sizeof(OPENFILENAME); <br>ofn.hwndOwner = pInfo-&gt;hwnd; <br>ofn.lpstrFilter = szFilter; <br>ofn.lpstrCustomFilter = (LPSTR) NULL; <br>ofn.nMaxCustFilter = 0L; <br>ofn.nFilterIndex = 1; <br>ofn.lpstrFile = szFile; <br>ofn.nMaxFile = sizeof(szFile); <br>ofn.lpstrFileTitle = szFileTitle; <br>ofn.nMaxFileTitle = sizeof(szFileTitle); <br>ofn.lpstrInitialDir = szDirName; <br>ofn.lpstrTitle = (LPSTR) NULL; <br>ofn.Flags = 0L; <br>ofn.nFileOffset = 0; <br>ofn.nFileExtension = 0; <br>ofn.lpstrDefExt = "BMP"; <br> <br>if (!GetOpenFileName(&amp;ofn)) <br>    return 0L; <br> <br>GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>hDC = GetDC(pInfo-&gt;hwnd); <br>if (LoadBitmapFile(hDC, pInfo, szFile)) <br>  bDrawDIB(hDC, pInfo, 0, 0, rc.right, rc.bottom); <br>ReleaseDC(hwnd, hDC); <br> <br>bReleaseInfoData(hwnd); <br> <br>return 0L; <br>    } <br> <br>    case MM_SAVE: { <br>HDC hDC; <br>OPENFILENAME ofn; <br>char szDirName[256]; <br>char szFile[256], szFileTitle[256]; <br>static char *szFilter; <br> <br>szFilter = GetStringRes (IDS_FILE_LIST2); <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>hDC = GetDC(pInfo-&gt;hwnd); <br>#if 0 <br>{ <br>HPALETTE hPalTmp; <br> <br>hPalTmp = CopyPalette(pInfo-&gt;hPal); <br>DeleteObject(pInfo-&gt;hPal); <br>pInfo-&gt;hPal = hPalTmp; <br>} <br>#endif <br>// <br>// saving special effects user might have created in window <br>// <br>if (pInfo-&gt;hBmpSaved) <br>    DeleteObject(pInfo-&gt;hBmpSaved); <br>pInfo-&gt;hBmpSaved = SaveBitmap(pInfo-&gt;hwnd, pInfo-&gt;hPal); <br>pInfo-&gt;bUseDIB = FALSE; <br> <br>GetSystemDirectory((LPSTR) szDirName, 256); <br>strcpy(szFile, "*.bmp\0"); <br>ofn.lStructSize = sizeof(OPENFILENAME); <br>ofn.hwndOwner = pInfo-&gt;hwnd; <br>ofn.lpstrFilter = szFilter; <br>ofn.lpstrCustomFilter = (LPSTR) NULL; <br>ofn.nMaxCustFilter = 0L; <br>ofn.nFilterIndex = 0L; <br>ofn.lpstrFile = szFile; <br>ofn.nMaxFile = sizeof(szFile); <br>ofn.lpstrFileTitle = szFileTitle; <br>ofn.nMaxFileTitle = sizeof(szFileTitle); <br>ofn.lpstrInitialDir = szDirName; <br>ofn.lpstrTitle = (LPSTR) NULL; <br>ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT; <br>ofn.nFileOffset = 0; <br>ofn.nFileExtension = 0; <br>ofn.lpstrDefExt = (LPSTR)NULL; <br> <br>if (!GetSaveFileName(&amp;ofn)) { <br>    ReleaseDC(pInfo-&gt;hwnd, hDC); <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br> <br>SelectPalette(hDC, <br>   ((pInfo-&gt;iStretchMode == HALFTONE) ? pInfo-&gt;hHTPal : pInfo-&gt;hPal), <br>   FALSE); <br>RealizePalette(hDC); <br>UpdateColors(hDC); <br> <br>// <br>// test <br>// <br>ghPal = pInfo-&gt;hPal; <br> <br>SaveBitmapFile(hDC, pInfo-&gt;hBmpSaved, szFile); <br> <br>ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_SAVE_MONO: { <br>HDC hDC; <br>OPENFILENAME ofn; <br>char szDirName[256]; <br>char szFile[256], szFileTitle[256]; <br>static char *szFilter; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL){ <br>    return 0L; <br>} <br> <br>szFilter = GetStringRes (IDS_FILE_LIST2); <br> <br>GetSystemDirectory((LPSTR) szDirName, 256); <br>strcpy(szFile, "*.bmp\0"); <br>ofn.lStructSize = sizeof(OPENFILENAME); <br>ofn.hwndOwner = pInfo-&gt;hwnd; <br>ofn.lpstrFilter = szFilter; <br>ofn.lpstrCustomFilter = (LPSTR) NULL; <br>ofn.nMaxCustFilter = 0L; <br>ofn.nFilterIndex = 0L; <br>ofn.lpstrFile = szFile; <br>ofn.nMaxFile = sizeof(szFile); <br>ofn.lpstrFileTitle = szFileTitle; <br>ofn.nMaxFileTitle = sizeof(szFileTitle); <br>ofn.lpstrInitialDir = szDirName; <br>ofn.lpstrTitle = GetStringRes (IDS_SAVING_MONO_BITMAP); <br>ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT; <br>ofn.nFileOffset = 0; <br>ofn.nFileExtension = 0; <br>ofn.lpstrDefExt = (LPSTR)NULL; <br> <br>if (!GetSaveFileName(&amp;ofn)) <br>    return 0L; <br> <br>hDC = GetDC(pInfo-&gt;hwnd); <br> <br>SaveBitmapFile(hDC, pInfo-&gt;hBmpMono, szFile); <br>ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_STRETCHBLT: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL){ <br>    return 0L; <br>} <br>gbStretch = TRUE; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_STRETCHBLT); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>pInfo-&gt;bStretch = gbStretch; <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br>    case MM_BITBLT: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>gbStretch = FALSE; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_BITBLT); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>pInfo-&gt;bStretch = gbStretch; <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br>    case MM_BLACKONWHITE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>giStretchMode = BLACKONWHITE; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_BLACKONWHITE); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>pInfo-&gt;iStretchMode = giStretchMode; <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br>    case MM_COLORONCOLOR: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>giStretchMode = COLORONCOLOR; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_COLORONCOLOR); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>pInfo-&gt;iStretchMode = giStretchMode; <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br>    case MM_WHITEONBLACK: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>giStretchMode = WHITEONBLACK; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_WHITEONBLACK); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>pInfo-&gt;iStretchMode = giStretchMode; <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br>    case MM_HALFTONE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>giStretchMode = HALFTONE; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_HALFTONE); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>pInfo-&gt;iStretchMode = giStretchMode; <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_SETDIB2DEVICE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>bDIB2Device = (bDIB2Device ? FALSE : TRUE); <br>pInfo-&gt;bSetDIBsToDevice = bDIB2Device; <br>CheckMenuItem(hChildMenu, MM_SETDIB2DEVICE, (bDIB2Device ? MF_CHECKED : MF_UNCHECKED)); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_BW: { <br>HDC hDC; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>hDC = GetDC(pInfo-&gt;hwnd); <br>bChangeDIBColor(hDC, pInfo, MM_BW); <br>ReleaseDC(hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_SHIFT: { <br>HDC hDC; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>hDC = GetDC(pInfo-&gt;hwnd); <br>bChangeDIBColor(hDC, pInfo, MM_SHIFT); <br>ReleaseDC(hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_CUSTOM: { <br>static DWORD argbCust[16] = { <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255), <br>    RGB(255, 255, 255), RGB(255, 255, 255) <br>}; <br>CHOOSECOLOR cc; <br>BOOL bResult; <br>DWORD rgbOld; <br>HBRUSH hBrush; <br>HDC hDC; <br> <br>rgbOld = RGB(255, 255, 255); <br>cc.lStructSize = sizeof(CHOOSECOLOR); <br>cc.hwndOwner = ghwndMain; <br>cc.hInstance = ghModule; <br>cc.rgbResult = rgbOld; <br>cc.lpCustColors = argbCust; <br>cc.Flags = CC_RGBINIT | CC_SHOWHELP; <br>cc.lCustData = 0; <br>cc.lpfnHook = NULL; <br>cc.lpTemplateName = NULL; <br> <br>bResult = ChooseColor(&amp;cc); <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>if (bResult) { <br>    hDC = GetDC(pInfo-&gt;hwnd); <br>    hBrush = hBrCreateBrush(hDC, cc.rgbResult); <br>    ReleaseDC(pInfo-&gt;hwnd, hDC); <br>    if (pInfo-&gt;hBrush) <br>DeleteObject(pInfo-&gt;hBrush); <br>    pInfo-&gt;hBrush = hBrush; <br>    pInfo-&gt;bFill = TRUE; <br>} <br>bReleaseInfoData(hwnd); <br>return 0L; <br>} <br> <br>#ifndef CYCLETHRD <br>    case MM_CYCLE: { <br>HDC hDC; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>hDC = GetDC(pInfo-&gt;hwnd); <br> <br>if (pInfo-&gt;bClrCycle) { <br>    CheckMenuItem(hChildMenu, MM_CYCLE, MF_UNCHECKED); <br>    pInfo-&gt;bClrCycle = FALSE; <br>} else { <br>    CheckMenuItem(hChildMenu, MM_CYCLE, MF_CHECKED); <br>    pInfo-&gt;bClrCycle = TRUE; <br>    bChangeDIBColor(hDC, pInfo, MM_CYCLE); <br>} <br> <br>ReleaseDC(hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>#else <br> <br>    case MM_CYCLE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if (pInfo-&gt;bFirstTime)  <br>{ <br>    if (!SetEvent(pInfo-&gt;hQuitEvent))  <br>{ <br>OutputDebugString ("Can't set Quit Event!"); <br>return 0L; <br>    } <br> <br>    if (pInfo-&gt;hCycleThrd) <br>CloseHandle(pInfo-&gt;hCycleThrd); <br> <br>    pInfo-&gt;hCycleThrd = CreateThread(NULL, 0, <br>     (LPTHREAD_START_ROUTINE)bCycle, <br>     (LPVOID)hwnd, <br>     STANDARD_RIGHTS_REQUIRED, <br>     &amp;pInfo-&gt;dwCycleThrdID ); <br>    pInfo-&gt;bClrCycle = TRUE; <br>    pInfo-&gt;bFirstTime = FALSE; <br>    CheckMenuItem(hChildMenu, MM_CYCLE, MF_CHECKED); <br>} else { <br>    if (pInfo-&gt;bClrCycle) { <br>CheckMenuItem(hChildMenu, MM_CYCLE, MF_UNCHECKED); <br>pInfo-&gt;bClrCycle = FALSE; <br>pInfo-&gt;dwSuspend = SuspendThread(pInfo-&gt;hCycleThrd); <br>    } else { <br>CheckMenuItem(hChildMenu, MM_CYCLE, MF_CHECKED); <br>pInfo-&gt;bClrCycle = TRUE; <br>pInfo-&gt;dwSuspend = ResumeThread(pInfo-&gt;hCycleThrd); <br>    } <br>    if (pInfo-&gt;dwSuspend == -1) { <br>(pInfo-&gt;bClrCycle ? <br> sprintf( gtext,"Error in resuming thread\n") : <br> sprintf( gtext,"Error in suspending thread\n")  ); <br>OutputDebugString( gtext ); <br>    } <br>} <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>#endif <br>    case MM_CLIP: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext,"(%g, %g) &lt;-&gt; (%g, %g)", pInfo-&gt;xFrom, pInfo-&gt;yFrom, pInfo-&gt;xTo, pInfo-&gt;yTo); <br>SetWindowText(hTextWnd, gtext); <br>sprintf( gtext,"(c1 = %g, c2 = %g)\n\n", pInfo-&gt;c1, pInfo-&gt;c2); <br>OutputDebugString( gtext ); <br>if (!pInfo-&gt;bMandel)  <br>{ <br>    MessageBox(ghwndMain,  <br>   GetStringRes (IDS_BOUNDARY), <br>   NULL, MB_OK); <br>    return 0L; <br>} <br> <br>if (pInfo-&gt;hThrd) <br>    CloseHandle(pInfo-&gt;hThrd); <br> <br>pInfo-&gt;hThrd = CreateThread(NULL, 0, <br> (gFloat ? (LPTHREAD_START_ROUTINE)bBoundaryScanFix : (LPTHREAD_START_ROUTINE)bBoundaryScanFix), <br> pInfo, <br> STANDARD_RIGHTS_REQUIRED, <br> &amp;pInfo-&gt;dwThreadId ); <br> <br>       bReleaseInfoData(hwnd); <br>       return 0L; <br>    } <br>    case MM_RM_CLIP: { <br>HDC     hDC; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hDC = GetDC(pInfo-&gt;hwnd); <br>SelectClipRgn(hDC, (HRGN) NULL); <br>ReleaseDC(pInfo-&gt;hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br>return 0L; <br> <br>    } <br>    case MM_SELCLIPRGN: { <br>HDC     hDC; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>hDC = GetDC(pInfo-&gt;hwnd); <br> <br>if (pInfo-&gt;hRgnPath != (HRGN) NULL) { <br>    SelectClipRgn(hDC, pInfo-&gt;hRgnPath); <br>} <br> <br>ReleaseDC(pInfo-&gt;hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_ERASE: { <br>HDC     hDC; <br>RECT    rc; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br>hDC = GetDC(pInfo-&gt;hwnd); <br>if (pInfo-&gt;hRgnPath != (HRGN) NULL) { <br>    SelectClipRgn(hDC, pInfo-&gt;hRgnPath); <br>} <br>SelectObject(hDC, GetStockObject(WHITE_BRUSH)); <br>GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>PatBlt(hDC, 0, 0, rc.right, rc.bottom, PATCOPY); <br>ReleaseDC(pInfo-&gt;hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_PORTRAIT: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>giDmOrient = DMORIENT_PORTRAIT; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_PORTRAIT); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_LANDSCAPE: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>giDmOrient = DMORIENT_LANDSCAPE; <br>bCheckMutexMenuItem(pInfo, hChildMenu, MM_LANDSCAPE); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br>    case MM_PRINTER: <br>    case MM_PRINTER + 1: <br>    case MM_PRINTER + 2: <br>    case MM_PRINTER + 3: <br>    case MM_PRINTER + 4: <br>    case MM_PRINTER + 5: <br>    case MM_PRINTER + 6: <br>    case MM_PRINTER + 7: <br>    case MM_PRINTER + 8: <br> <br>#ifdef PRTTHRD <br>    case MM_PRINTER + 9: { <br>PINFO       pInfo; <br>PRTDATA     PrtData, *pPrtData; <br>ULONG       sizINFO; <br>PBYTE       pjTmpInfo, pjTmp; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if (pInfo-&gt;hBmpSaved == NULL)  <br>{ <br>    MessageBox(ghwndMain,  <br>       GetStringRes (IDS_NO_SAVED_BITMAP), <br>   NULL, MB_OK); <br>    return 0L; <br>} <br> <br>// <br>// Copy the info structure to PrtData <br>// <br>pPrtData = &amp;PrtData; <br>pjTmp    = (PBYTE)&amp;(pPrtData-&gt;info); <br>pjTmpInfo = (PBYTE)pInfo; <br>sizINFO = sizeof(INFO); <br> <br>while(sizINFO--) <br>{ <br>    *(((PBYTE)pjTmp)++) = *((pjTmpInfo)++); <br>} <br> <br>PrtData.index = LOWORD(wParam) - MM_PRINTER; <br> <br>if (giDmOrient == DMORIENT_PORTRAIT) { <br>    PrtData.bUseDefault = TRUE; <br>} else { <br>    PrtData.bUseDefault = FALSE; <br>    PrtData.DevMode.dmSize = sizeof(DEVMODE); <br>    PrtData.DevMode.dmDriverExtra = 0; <br>    PrtData.DevMode.dmOrientation = DMORIENT_LANDSCAPE; <br>    PrtData.DevMode.dmFields = DM_ORIENTATION; <br>} <br> <br>if (pInfo-&gt;hPrtThrd) <br>    CloseHandle(pInfo-&gt;hPrtThrd); <br> <br>pInfo-&gt;hPrtThrd = CreateThread(NULL, 0, <br> (LPTHREAD_START_ROUTINE)bPrintBmp, <br> &amp;PrtData, <br> STANDARD_RIGHTS_REQUIRED, <br> &amp;pInfo-&gt;dwPrtThrdID ); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br> <br>#else <br>    case MM_PRINTER + 9: { <br>HDC         hdcPrinter, hDC; <br>int         index; <br>DEVMODE     devmode; <br>DEVMODE     *pdevmode; <br>PINFO       pInfo; <br>int         iWidth, iHeight; <br> <br> <br>index = LOWORD(wParam) - MM_PRINTER; <br> <br>if (giDmOrient == DMORIENT_PORTRAIT) <br>    pdevmode = NULL; <br>else { <br>    pdevmode = &amp;devmode; <br>    devmode.dmSize = sizeof(DEVMODE); <br>    devmode.dmDriverExtra = 0; <br>    devmode.dmOrientation = DMORIENT_LANDSCAPE; <br>    devmode.dmFields = DM_ORIENTATION; <br>} <br> <br>if (!(hdcPrinter = CreateDC( "", gpszPrinterNames[index], <br>     "", pdevmode))) <br>{ <br>    return(0L); <br>} <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>iWidth = GetDeviceCaps(hdcPrinter, HORZRES); <br>iHeight = GetDeviceCaps(hdcPrinter, VERTRES); <br> <br>// !!! Why is it necessary to save the image over again?  May not want to <br>//     do this because user may want to print the nice HT bitmap. So, <br>//     use the DIB src. <br>#if 0 <br>if (pInfo-&gt;hBmpSaved) <br>    DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>pInfo-&gt;hBmpSaved = SaveBitmap(pInfo-&gt;hwnd, pInfo-&gt;hPal); <br>#endif <br>Escape(hdcPrinter, STARTDOC, 20, "Mandelbrot", NULL); <br>bDrawDIB(hdcPrinter, pInfo, 0, 0, iWidth, iHeight); <br>Escape(hdcPrinter, NEWFRAME, 0, NULL, NULL); <br>Escape(hdcPrinter, ENDDOC, 0, NULL, NULL); <br>ReleaseDC(pInfo-&gt;hwnd, hDC); <br>bReleaseInfoData(hwnd); <br>DeleteDC(hdcPrinter); <br>return 0L; <br>    } <br>#endif <br>    default: <br>       return 0L; <br> <br>  } <br> <br>} <br>case WM_SETFOCUS: <br>    break; <br> <br>case WM_MDIACTIVATE: { <br>    PINFO       pInfo; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    if ((HWND) lParam == hwnd) {                // being activated <br>SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>    (DWORD)  hChildMenu, <br>    (LONG)   hSubMenuThree) ; <br> <br>(pInfo-&gt;bClrCycle ? <br>    CheckMenuItem(hChildMenu, MM_CYCLE, MF_CHECKED) : <br>    CheckMenuItem(hChildMenu, MM_CYCLE, MF_UNCHECKED) ); <br> <br>vChkMenuItem(pInfo, hChildMenu, MF_CHECKED); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>goto MDI_ACT_EXIT; <br>    } <br> <br>    if ((HWND) wParam == hwnd) {                // being deactivated <br> <br>vChkMenuItem(pInfo, hChildMenu, MF_UNCHECKED); <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    } <br>MDI_ACT_EXIT: <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br> <br>case WM_QUERYNEWPALETTE: <br>case WM_PALETTECHANGED: { <br>    PINFO       pInfo; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    SendMessage(pInfo-&gt;hwnd, message, wParam, lParam); <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br> <br>#if 0 <br>case WM_WINDOWPOSCHANGING: { <br>    PWINDOWPOS  pWndPos; <br>    PINFO       pInfo; <br>    HWND        hTextWnd; <br>    int         iCyText, iCxBorder, iCyBorder, iCyCaption; <br>    RECT        rect, rcl; <br>    LONG        lcx, lcy; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>break; <br>    } <br> <br>    hTextWnd = pInfo-&gt;hTextWnd; <br> <br>    bReleaseInfoData(hwnd); <br> <br>    iCyText = GetWindowLong(hTextWnd, GWL_USERDATA); <br>    iCxBorder = GetSystemMetrics(SM_CXBORDER); <br>    iCyBorder = GetSystemMetrics(SM_CYBORDER); <br>    iCyCaption = GetSystemMetrics(SM_CYCAPTION) - iCyBorder; <br>    GetClientRect(GetParent(hwnd), &amp;rcl); <br>    GetWindowRect(hwnd, &amp;rect); <br>    lcx = rect.right-rect.left; <br>    lcy = rect.bottom-rect.top; <br>    pWndPos = (PWINDOWPOS)lParam; <br>    if ((pWndPos-&gt;cy &gt; lcy) || (pWndPos-&gt;cx &gt; lcx)) { <br>pWndPos-&gt;cx = <br>   ((pWndPos-&gt;cx &gt; pWndPos-&gt;cy) ? pWndPos-&gt;cy-iCyText : pWndPos-&gt;cx); <br>pWndPos-&gt;cy = pWndPos-&gt;cx + iCyText; <br>    } else { if ((pWndPos-&gt;cy &lt; lcy) || (pWndPos-&gt;cx &lt; lcx)) { <br>     pWndPos-&gt;cx = <br>((pWndPos-&gt;cx &gt; pWndPos-&gt;cy) ? pWndPos-&gt;cy-iCyText : pWndPos-&gt;cx); <br>     pWndPos-&gt;cy = pWndPos-&gt;cx + iCyText; <br>   } <br>    } <br>    break; <br>} <br>#endif <br>case WM_SIZE: { <br>    HANDLE      hThrd; <br>    PINFO       pInfo; <br>    HWND        hTextWnd, hJulia; <br>    BOOL        bMandel; <br>    WORD        wCx; <br>    int         iCyText; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>break; <br>    } <br> <br>    hTextWnd = pInfo-&gt;hTextWnd; <br>    hJulia   = pInfo-&gt;hwnd; <br>    hThrd    = pInfo-&gt;hThrd; <br>    bMandel  = pInfo-&gt;bMandel; <br>    bReleaseInfoData(hwnd); <br>    iCyText = GetWindowLong(hTextWnd, GWL_USERDATA); <br>    wCx = (WORD) (HIWORD(lParam) - iCyText); <br> <br>    MoveWindow(hJulia, 0, 0, <br>   LOWORD(lParam), <br>   wCx, <br>   TRUE); <br> <br>    MoveWindow(hTextWnd, <br>       0, <br>       wCx, <br>       LOWORD(lParam), <br>       iCyText, <br>       TRUE); <br> <br>    if (hThrd) { <br>TerminateThread(hThrd, (DWORD)0L); <br>/* <br>PostMessage(hwnd, WM_COMMAND, <br>    bMandel ? (DWORD)((WORD)MM_CREATE_MANDEL_THREAD) : (DWORD)((WORD)MM_CREATE_JULIA_THREAD), <br>    (LONG)0L); <br>  */ <br>    } <br> <br>    break; <br>} <br> <br>// <br>// display info in the status window <br>// <br>case WM_USER+0xa: { <br>    PINFO       pInfo; <br>    static ULONG ulClick = 0; <br>    HWND        hTextWnd; <br> <br>    ulClick++; <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    hTextWnd = pInfo-&gt;hTextWnd; <br>    switch (ulClick % 6) { <br>case 0: sprintf( gtext,"%g &lt;= x &lt;= %g, %g &lt;= y &lt;= %g", pInfo-&gt;xFrom, pInfo-&gt;xTo, pInfo-&gt;yTo, pInfo-&gt;yFrom); <br>break; <br>case 1: sprintf( gtext,"c1 = %g, c2 = %g", pInfo-&gt;c1, pInfo-&gt;c2); <br>break; <br>case 2: sprintf( gtext, <br>     GetStringRes (IDS_ELAPSED_TIME), <br> (ULONG) pInfo-&gt;dwElapsed); <br>break; <br>case 3: sprintf( gtext, <br>     GetStringRes (IDS_ITERATION), <br> pInfo-&gt;iIteration); <br>break; <br>case 4:sprintf( gtext, <br> GetStringRes (IDS_STEP), <br> pInfo-&gt;iStep); <br>break; <br>case 5:  <br>(gFloat ? sprintf( gtext, GetStringRes (IDS_FLOATING_PT)) <br>        : sprintf( gtext, GetStringRes (IDS_FIXED_PT))) ; <br>break; <br> <br>default: break; <br>    } <br>    SetWindowText(hTextWnd, gtext); <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br> <br>case WM_SYSCOMMAND: { <br>    LONG        lResult; <br> <br>    EnumChildWindows(ghwndClient, (WNDENUMPROC)lpfnSuspendThrd, lParam); <br> <br>    lResult = DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>    EnumChildWindows(ghwndClient, (WNDENUMPROC)lpfnResumeThrd, lParam); <br> <br>    return lResult; <br>    break; <br>} <br> <br>case WM_CREATE: { <br>    PINFO           pInfo; <br>    HANDLE          hInfo; <br>    HWND            hTextWnd, hJulia; <br>    RECT            rcl; <br> <br>    // <br>    // CR! MakeProcInstance is noop! <br>    // <br>    lpfnSuspendThrd = (FARPROC)MakeProcInstance (SuspendDrawThrd, ghModule); <br>    lpfnResumeThrd  = (FARPROC)MakeProcInstance (ResumeDrawThrd, ghModule); <br> <br>    hTextWnd = CreateWindow("Text", NULL, <br>    WS_BORDER | SS_LEFT | WS_CHILD | WS_VISIBLE, <br>    0, 0, 0, 0, <br>    hwnd, <br>    (HMENU) 2, <br>    ghModule, <br>    NULL); <br> <br>    GetClientRect(hwnd, &amp;rcl); <br>    hJulia = CreateWindow("Julia", (LPSTR) NULL, <br>  WS_CHILD      | WS_VISIBLE     | <br>  WS_BORDER, <br>  0,0, rcl.right-rcl.left, <br>  rcl.bottom-rcl.top-GetWindowLong(hTextWnd, GWL_USERDATA), <br>  hwnd, (HMENU)1, ghModule, (LPVOID)NULL); <br> <br>    SetWindowText(hTextWnd, GetStringRes (IDS_SELECT_DRAW_SET)); <br> <br>    hInfo = (HANDLE) ((LPMDICREATESTRUCT) ((LPCREATESTRUCT) lParam)-&gt;lpCreateParams)-&gt;lParam ; <br>    if (hInfo) { <br>if ((pInfo = (PINFO)LocalLock(hInfo)) == NULL)  <br>{ <br>    OutputDebugString ("Failed in LocalLock, hNode"); <br>    break; <br>}  <br>else  <br>{ <br>    HDC hDC; <br> <br>    if (!GetClientRect(hwnd, &amp;pInfo-&gt;rcClient)) <br>OutputDebugString ("Failed in GetClientRect!"); <br> <br>    pInfo-&gt;hTextWnd = hTextWnd; <br>    pInfo-&gt;hwnd = hJulia; <br>    hDC = GetDC(hJulia); <br>    pInfo-&gt;hHTPal = CreateHalftonePalette(hDC); <br>    ReleaseDC(hJulia, hDC); <br>#ifdef CYCLETHRD <br>    // <br>    // Creating a signal quit color cycling event <br>    // <br>    if ((pInfo-&gt;hQuitEvent = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) <br>OutputDebugString ("Failed in creating Quit Event!"); <br>#endif <br>    SetWindowLong(hwnd, 0, (LONG) hInfo); <br>    LocalUnlock(hInfo); <br>} <br>    }  <br>else  <br>{ <br>OutputDebugString ("Can't allocate hInfo!"); <br>    } <br> <br>#if 0 <br>    // <br>    // Initialize printers here will detect printers availiability <br>    // more often, but kind of overkill. <br>    // <br>    bInitPrinter(hwnd); <br>#endif <br>    break; <br>} <br> <br>case WM_CLOSE: { <br>    SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>    (DWORD) hMenu, <br>    (LONG)  hSubMenuOne) ; <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    break; <br>} <br> <br>case WM_DESTROY: { <br>    PINFO            pInfo; <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>break; <br>    } <br> <br>    if (pInfo-&gt;hThrd) { <br>TerminateThread(pInfo-&gt;hThrd, (DWORD)0L); <br>CloseHandle(pInfo-&gt;hThrd); <br>    } <br>    if (pInfo-&gt;hPrtThrd) { <br>TerminateThread(pInfo-&gt;hPrtThrd, (DWORD)0L); <br>CloseHandle(pInfo-&gt;hPrtThrd); <br>    } <br>    if (pInfo-&gt;hCycleThrd) { <br>TerminateThread(pInfo-&gt;hCycleThrd, (DWORD)0L); <br>CloseHandle(pInfo-&gt;hCycleThrd); <br>    } <br> <br> <br>#ifdef CYCLETHRD <br>    // <br>    // Cleanup color cycling <br>    // <br>    if (!ResetEvent(pInfo-&gt;hQuitEvent)) <br>OutputDebugString ("Failed in reseting quit event!"); <br>#endif <br>    if (pInfo-&gt;hBmpMono) <br>DeleteObject(pInfo-&gt;hBmpMono); <br> <br>    if (pInfo-&gt;hBmpSaved) <br>DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>    if (pInfo-&gt;hBrush) <br>DeleteObject(pInfo-&gt;hBrush); <br> <br>    bReleaseInfoData(hwnd); <br>    LocalFree((HANDLE) GetWindowLong(hwnd, 0)); <br>    break; <br>} <br> <br>default: <br>    return DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>    } //switch <br>    return DefMDIChildProc(hwnd, message, wParam, lParam); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ViewerWndProc <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG APIENTRY ViewerWndProc( <br>    HWND hwnd, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    static FARPROC     lpfnSuspendThrd, lpfnResumeThrd; <br> <br>    switch (message) { <br>case WM_COMMAND: { <br>  PINFO       pInfo; <br>  HWND        hTextWnd; <br> <br>  switch (LOWORD(wParam)) { <br>    case MM_RLELOAD_DEMO: { <br>HDC             hDC; <br>char            szDirName[256]; <br>char            szFile[400]; <br>HWND            hViewSurf; <br> <br>GetCurrentDirectory(256, (LPTSTR) szDirName); <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if ((hViewSurf = pInfo-&gt;hwnd) == NULL) <br>    return 0L; <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext,"Loading bitmap(s) into memory"); <br>SetWindowText(hTextWnd, gtext); <br> <br>hDC = GetDC(hViewSurf); <br>strcpy(szFile, szDirName); <br>strcat(szFile, "\\rsc\\julia.rle"); <br> <br>if (bStoreRleFile(hDC, pInfo, szFile)) { <br>    pInfo-&gt;RleData.ulFiles++; <br>    PostMessage(ghwndMain, WM_COMMAND, MM_RLEPLAYCONT, 0L); <br>} <br> <br>ReleaseDC(hViewSurf, hDC); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br> <br> <br>    case MM_RLELOAD: { <br>HDC             hDC; <br>OPENFILENAME    ofn; <br>char            szDirName[256]; <br>char            szFile[256], szFileTitle[256]; <br>static char     *szFilter; <br>RECT            rc; <br>HWND            hViewSurf; <br> <br>szFilter = GetStringRes (IDS_FILE_LIST1); <br> <br>GetSystemDirectory((LPSTR) szDirName, 256); <br>strcpy(szFile, "*.bmp\0"); <br>ofn.lStructSize = sizeof(OPENFILENAME); <br>ofn.hwndOwner = hwnd; <br>ofn.lpstrFilter = szFilter; <br>ofn.lpstrCustomFilter = (LPSTR) NULL; <br>ofn.nMaxCustFilter = 0L; <br>ofn.nFilterIndex = 1; <br>ofn.lpstrFile = szFile; <br>ofn.nMaxFile = sizeof(szFile); <br>ofn.lpstrFileTitle = szFileTitle; <br>ofn.nMaxFileTitle = sizeof(szFileTitle); <br>ofn.lpstrInitialDir = szDirName; <br>ofn.lpstrTitle = (LPSTR) NULL; <br>ofn.Flags = 0L; <br>ofn.nFileOffset = 0; <br>ofn.nFileExtension = 0; <br>ofn.lpstrDefExt = "BMP"; <br> <br>if (!GetOpenFileName(&amp;ofn)) <br>    return 0L; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if ((hViewSurf = pInfo-&gt;hwnd) == NULL) <br>    return 0L; <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext, GetStringRes (IDS_LOADING_BITMAPS)); <br>SetWindowText(hTextWnd, gtext); <br> <br>GetClientRect(hwnd, &amp;rc); <br>hDC = GetDC(hViewSurf); <br>if (bStoreRleFile(hDC, pInfo, szFile)) <br>    pInfo-&gt;RleData.ulFiles++; <br>ReleaseDC(hViewSurf, hDC); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br> <br>    } <br> <br>    case MM_RLESAVE: { <br>HDC             hDC; <br>OPENFILENAME    ofn; <br>char            szDirName[256]; <br>char            szFile[256], szFileTitle[256]; <br>static char     *szFilter; <br>HWND            hViewSurf; <br> <br>szFilter = GetStringRes (IDS_FILE_LIST3); <br> <br>GetSystemDirectory((LPSTR) szDirName, 256); <br>strcpy(szFile, "*.rle\0"); <br>ofn.lStructSize = sizeof(OPENFILENAME); <br>ofn.hwndOwner = hwnd; <br>ofn.lpstrFilter = szFilter; <br>ofn.lpstrCustomFilter = (LPSTR) NULL; <br>ofn.nMaxCustFilter = 0L; <br>ofn.nFilterIndex = 0L; <br>ofn.lpstrFile = szFile; <br>ofn.nMaxFile = sizeof(szFile); <br>ofn.lpstrFileTitle = szFileTitle; <br>ofn.nMaxFileTitle = sizeof(szFileTitle); <br>ofn.lpstrInitialDir = szDirName; <br>ofn.lpstrTitle = GetStringRes(IDS_SAVING_MEMORY_RLE);  <br>ofn.Flags = OFN_SHOWHELP | OFN_OVERWRITEPROMPT; <br>ofn.nFileOffset = 0; <br>ofn.nFileExtension = 0; <br>ofn.lpstrDefExt = (LPSTR)NULL; <br> <br>if (!GetSaveFileName(&amp;ofn)) <br>    return 0L; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if ((hViewSurf = pInfo-&gt;hwnd) == NULL) <br>    return 0L; <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext, GetStringRes (IDS_SAVING_LOADED_BMP));  <br>SetWindowText(hTextWnd, gtext); <br> <br>hDC = GetDC(hViewSurf); <br>bSaveRleFile(hDC, pInfo, szFile); <br>ReleaseDC(hViewSurf, hDC); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br> <br>    case MM_CLEAR: { <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext,GetStringRes (IDS_DISCARD_LOADED_BMP)); <br>SetWindowText(hTextWnd, gtext); <br> <br>bFreeRleFile(pInfo); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br> <br>    case MM_RLEPLAY: { <br>HDC     hDC; <br>HWND    hViewSurf; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if ((hViewSurf = pInfo-&gt;hwnd) == NULL) <br>    return 0L; <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext, GetStringRes (IDS_PLAY_LOADED_BMP));  <br>SetWindowText(hTextWnd, gtext); <br> <br>hDC = GetDC(hViewSurf); <br>EnableMenuItem(hViewSubOne, MM_CLEAR, MF_GRAYED); <br> <br>if (pInfo-&gt;hThrd0) <br>    CloseHandle(pInfo-&gt;hThrd0); <br> <br>pInfo-&gt;hThrd0 = CreateThread(NULL, 0, <br>     (LPTHREAD_START_ROUTINE)bPlayRle, <br>     pInfo, <br>     STANDARD_RIGHTS_REQUIRED, <br>     &amp;pInfo-&gt;dwThreadId ); <br> <br>if (pInfo-&gt;hThrd0)  <br>{ <br>    if (!SetThreadPriority(pInfo-&gt;hThrd0, THREAD_PRIORITY_BELOW_NORMAL)) </code></pre>
<p>
</p>
<pre><code>OutputDebugString ("Can't set Priority!"); <br>} <br> <br>//bPlayRle(hDC, pInfo); <br>EnableMenuItem(hViewSubOne, MM_CLEAR, MF_ENABLED); <br>ReleaseDC(hViewSurf, hDC); <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br> <br>    case MM_RLEPLAYCONT: { <br>HWND    hViewSurf; <br> <br>if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>    return 0L; <br>} <br> <br>if ((hViewSurf = pInfo-&gt;hwnd) == NULL) <br>    return 0L; <br> <br>hTextWnd = pInfo-&gt;hTextWnd; <br>sprintf( gtext, GetStringRes (IDS_PLAY_BMP_CONT)); <br>SetWindowText(hTextWnd, gtext); <br> <br>if (pInfo-&gt;bFirstTime)  <br>{ <br>    if (!SetEvent(pInfo-&gt;hQuitEvent))  <br>{ <br>OutputDebugString ("Can't set Quit Event!"); <br>    return 0L; <br>    } <br> <br>    EnableMenuItem(hViewSubOne, MM_CLEAR, MF_GRAYED); <br> <br>    if (pInfo-&gt;hThrd) <br>CloseHandle(pInfo-&gt;hThrd); <br> <br>    pInfo-&gt;hThrd = CreateThread(NULL, 0, <br> (LPTHREAD_START_ROUTINE)bPlayRleCont2, <br> pInfo, <br> STANDARD_RIGHTS_REQUIRED, <br> &amp;pInfo-&gt;dwThreadId ); <br> <br>    if (pInfo-&gt;hThrd) { <br>if (!SetThreadPriority(pInfo-&gt;hThrd, THREAD_PRIORITY_BELOW_NORMAL)) <br>     OutputDebugString ("Can't set Priority!"); <br>    } <br> <br>    pInfo-&gt;bPlayRleCont = TRUE; <br>    pInfo-&gt;bFirstTime = FALSE; <br>    CheckMenuItem(hViewMenu, MM_RLEPLAYCONT, MF_CHECKED); <br>}  <br>else  <br>{ <br>    if (pInfo-&gt;bPlayRleCont) { <br>EnableMenuItem(hViewSubOne, MM_CLEAR, MF_ENABLED); <br>CheckMenuItem(hViewMenu, MM_RLEPLAYCONT, MF_UNCHECKED); <br>pInfo-&gt;bPlayRleCont = FALSE; <br>pInfo-&gt;dwSuspend = SuspendThread(pInfo-&gt;hThrd); <br>    } else { <br>EnableMenuItem(hViewSubOne, MM_CLEAR, MF_GRAYED); <br>CheckMenuItem(hViewMenu, MM_RLEPLAYCONT, MF_CHECKED); <br>pInfo-&gt;bPlayRleCont = TRUE; <br>pInfo-&gt;dwSuspend = ResumeThread(pInfo-&gt;hThrd); <br>    } <br>    if (pInfo-&gt;dwSuspend == -1) { <br>(pInfo-&gt;bPlayRleCont ? <br> sprintf( gtext,"Error in resuming thread\n") : <br> sprintf( gtext,"Error in suspending thread\n")  ); <br>OutputDebugString( gtext ); <br>    } <br>} <br> <br>bReleaseInfoData(hwnd); <br>return 0L; <br>    } <br> <br>    default: <br>       return 0L; <br> <br>  } //switch <br> <br>} // WM_COMMAND <br>case WM_SETFOCUS: <br>    break; <br> <br>case WM_MDIACTIVATE: { <br>    PINFO       pInfo; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    if ((HWND) lParam == hwnd) { <br>SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>    (WPARAM)  hViewMenu, <br>    (LPARAM)  NULL) ; <br>DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    } <br> <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br>case WM_QUERYNEWPALETTE: <br>case WM_PALETTECHANGED: { <br>    PINFO       pInfo; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    SendMessage(pInfo-&gt;hwnd, message, wParam, lParam); <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br> <br>case WM_SIZE: { <br>    PINFO       pInfo; <br>    HWND        hTextWnd, hView; <br>    WORD        wCx; <br>    int         iCyText; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>break; <br>    } <br> <br>    hTextWnd = pInfo-&gt;hTextWnd; <br>    hView    = pInfo-&gt;hwnd; <br>    bReleaseInfoData(hwnd); <br>    iCyText = GetWindowLong(hTextWnd, GWL_USERDATA); <br>    wCx = (WORD) (HIWORD(lParam) - iCyText); <br> <br>    MoveWindow(hView, 0, 0, <br>   LOWORD(lParam), <br>   wCx, <br>   TRUE); <br> <br>    MoveWindow(hTextWnd, <br>       0, <br>       wCx, <br>       LOWORD(lParam), <br>       iCyText, <br>       TRUE); <br> <br>    break; <br>} <br> <br>// <br>// display info in the status window <br>// <br>case WM_USER+0xa: { <br>    PINFO       pInfo; <br>    static ULONG ulClick = 0; <br>    HWND        hTextWnd; <br> <br>    ulClick++; <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>return 0L; <br>    } <br> <br>    hTextWnd = pInfo-&gt;hTextWnd; <br>    switch (ulClick % 4) { <br>case 0:  <br>sprintf( gtext, GetStringRes (IDS_FRAMES));  <br>break; <br>case 1:  <br>sprintf( gtext, GetStringRes (IDS_FRAMES)); <br>break; <br>case 2: sprintf( gtext, (pInfo-&gt;bPlayRleCont ?  <br>               GetStringRes (IDS_CONT_PLAY) : <br>                       GetStringRes (IDS_SINGLE_PLAY))); <br>break; <br>case 3: sprintf( gtext,""); <br>break; <br>default: break; <br>    } <br>    SetWindowText(hTextWnd, gtext); <br>    bReleaseInfoData(hwnd); <br>    return 0L; <br>} <br> <br>case WM_SYSCOMMAND: { <br>    LONG        lResult; <br> <br>    EnumChildWindows(ghwndClient, (WNDENUMPROC)lpfnSuspendThrd, lParam); <br> <br>    lResult = DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>    EnumChildWindows(ghwndClient, (WNDENUMPROC)lpfnResumeThrd, lParam); <br> <br>    return lResult; <br>    break; <br>} <br> <br>case WM_CREATE: { <br>    PINFO           pInfo; <br>    HANDLE          hInfo; <br>    HWND            hTextWnd, hView; <br>    RECT            rcl; <br> <br>    // <br>    // CR! MakeProcInstance is noop! <br>    // <br>    lpfnSuspendThrd = (FARPROC)MakeProcInstance (SuspendDrawThrd, ghModule); <br>    lpfnResumeThrd  = (FARPROC)MakeProcInstance (ResumeDrawThrd, ghModule); <br> <br>    hTextWnd = CreateWindow("Text", NULL, <br>    WS_BORDER | SS_LEFT | WS_CHILD | WS_VISIBLE, <br>    0, 0, 0, 0, <br>    hwnd, <br>    (HMENU) 2, <br>    ghModule, <br>    NULL); <br> <br>    GetClientRect(hwnd, &amp;rcl); <br>    hView = CreateWindow("View", (LPSTR) NULL, <br>  WS_CHILD      | WS_VISIBLE     | <br>  WS_BORDER, <br>  0,0, rcl.right-rcl.left, <br>  rcl.bottom-rcl.top-GetWindowLong(hTextWnd, GWL_USERDATA), <br>  hwnd, (HMENU)1, ghModule, (LPVOID)NULL); <br> <br>    SetWindowText(hTextWnd, GetStringRes (IDS_SELECT_DRAW_SET)); <br>    hInfo = (HANDLE) ((LPMDICREATESTRUCT) ((LPCREATESTRUCT) lParam)-&gt;lpCreateParams)-&gt;lParam ; <br>    if (hInfo) { <br>if ((pInfo = (PINFO)LocalLock(hInfo)) == NULL)  <br>{ <br>    OutputDebugString ("Failed in LocalLock, hNode"); <br>    break; <br>}  <br>else  <br>{ <br>    HDC hDC; <br> <br>    if (!GetClientRect(hwnd, &amp;pInfo-&gt;rcClient)) <br>OutputDebugString ("Failed in GetClientRect!"); <br> <br>    pInfo-&gt;hTextWnd = hTextWnd; <br>    pInfo-&gt;hwnd = hView; <br> <br>    hDC = GetDC(hView); <br>    pInfo-&gt;hHTPal = CreateHalftonePalette(hDC); <br>    ReleaseDC(hView, hDC); <br> <br>    // <br>    // Creating a signal quit play continuous event <br>    // <br>    if ((pInfo-&gt;hQuitEvent = CreateEvent(NULL, TRUE, TRUE, NULL)) == NULL) <br>OutputDebugString ("Failed in creating Quit Event!"); <br> <br>    SetWindowLong(hwnd, 0, (LONG) hInfo); <br>    LocalUnlock(hInfo); <br>} <br>    }  <br>else  <br>{ <br>OutputDebugString ("Can't allocate hInfo!"); <br>    } <br> <br>    break; <br>} <br> <br>case WM_CLOSE: { <br>    SendMessage(GetParent(hwnd), WM_MDISETMENU, <br>    (DWORD) hMenu, <br>    (LONG)  hSubMenuOne) ; <br>    DrawMenuBar(GetParent(GetParent(hwnd))) ; <br>    break; <br>} <br> <br>case WM_DESTROY: { <br>    PINFO            pInfo; <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>break; <br>    } <br> <br>    TerminateThread(pInfo-&gt;hThrd, (DWORD)0L); <br>    CloseHandle(pInfo-&gt;hThrd); <br> <br>    // <br>    // Cleanup continuous play <br>    // <br>    if (!ResetEvent(pInfo-&gt;hQuitEvent)) <br>OutputDebugString ("Failed in reseting quit event!"); <br> <br>    bFreeRleFile(pInfo); <br>    bReleaseInfoData(hwnd); <br>    LocalFree((HANDLE) GetWindowLong(hwnd, 0)); <br>    break; <br>} <br> <br>default: <br>    return DefMDIChildProc(hwnd, message, wParam, lParam); <br> <br>    } //switch <br>    return DefMDIChildProc(hwnd, message, wParam, lParam); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ViewSurfWndProc <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>LONG APIENTRY ViewSurfWndProc (HWND hwnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    switch (message) <br>    { <br>       case WM_CREATE: { <br>    break; <br>       } <br> <br>       case WM_DESTROY: { <br>    break; <br>       } <br> <br>       case WM_QUERYNEWPALETTE: { <br>     HWND        hParent; <br>     PINFO       pInfo; <br>     HDC         hDC; <br>     UINT        i; <br>     HPALETTE    hOldPal; <br> <br>     if ((hParent=GetParent(hwnd)) == NULL)  <br> { <br>OutputDebugString ("Can't get hParent!"); <br>return 0L; <br>     } <br>     if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>  return 0L; <br>     } <br> <br>     // If palette realization causes a palette change, <br>     // we need to do a full redraw. <br> <br>     hDC = GetDC (hwnd); <br> <br>     hOldPal = SelectPalette (hDC, <br>       pInfo-&gt;RleData.hPal, <br>       0); <br> <br>     i = RealizePalette(hDC); <br> <br>     SelectPalette (hDC, hOldPal, 0); <br>     ReleaseDC (hwnd, hDC); <br>     bReleaseInfoData(hParent); <br> <br>     if (i) { <br> InvalidateRect (hwnd, (LPRECT) (NULL), TRUE); <br> return TRUE; <br>     } else <br> return FALSE; <br> <br>       } <br>       case WM_PALETTECHANGED: { <br>     HWND        hParent; <br>     PINFO       pInfo; <br>     HDC         hDC; <br>     UINT        i; <br>     HPALETTE    hOldPal; <br> <br>     if ((hParent=GetParent(hwnd)) == NULL) { <br> MessageBox(ghwndMain, "Can't get hParent!", "Error", MB_OK); <br> return 0L; <br>     } <br>     if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>  return 0L; <br>     } <br> <br>     // if we were not responsible for palette change and if <br>     // palette realization causes a palette change, do a redraw. <br> <br>     if ((HWND)wParam != hwnd){ <br>hDC = GetDC (hwnd); <br> <br>hOldPal = SelectPalette (hDC, <br>pInfo-&gt;RleData.hPal, <br>0); <br> <br>i = RealizePalette (hDC); <br> <br>if (i){ <br>    UpdateColors (hDC); <br>} <br>SelectPalette (hDC, hOldPal, 0); <br>ReleaseDC (hwnd, hDC); <br>    } <br>    bReleaseInfoData(hParent); <br>    break; <br>       } <br> <br>       case WM_PAINT: <br> { <br>     PAINTSTRUCT ps; <br>     HDC         hDC; <br>     RECT        rc; <br> <br>     GetClientRect(hwnd,&amp;rc); <br>     hDC = BeginPaint(hwnd, &amp;ps); <br>     EndPaint(hwnd, &amp;ps); <br>     return 0L; <br> } <br> <br>    } // switch <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br>/***************************************************************************\ <br>* About <br>* <br>* About dialog proc. <br>* <br>\***************************************************************************/ <br> <br>BOOL CALLBACK About( <br>    HWND hDlg, <br>    UINT message, <br>    DWORD wParam, <br>    LONG lParam) <br>{ <br>    switch (message) { <br>    case WM_INITDIALOG: <br>return TRUE; <br> <br>    case WM_COMMAND: <br>if (wParam == IDOK) <br>    EndDialog(hDlg, wParam); <br>break; <br>    } <br> <br>    return FALSE; <br> <br>    UNREFERENCED_PARAMETER(lParam); <br>    UNREFERENCED_PARAMETER(hDlg); <br>} <br> <br>/************************************************************************* <br>* <br>* TextWndProc <br>* <br>* Text Window proc. <br>* <br>\***************************************************************************/ <br> <br>LONG APIENTRY TextWndProc (HWND hwnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    static HFONT hFont = (HFONT) NULL; <br> <br>    switch (message) <br>    { <br>    case WM_CREATE: <br>{ <br>    LOGFONT    lf; <br>    HDC        hDC; <br>    HFONT      hOldFont; <br>    TEXTMETRIC tm; <br>    RECT       rect; <br>    LONG       lHeight; <br> <br>    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), (PVOID) &amp;lf, FALSE); <br> <br>    hDC = GetDC(hwnd); <br>    // this is the height for 8 point size font in pixels <br>    lf.lfHeight = 8 * GetDeviceCaps(hDC, LOGPIXELSY) / 72; <br> <br>    hFont = CreateFontIndirect(&amp;lf); <br>    hOldFont = SelectObject(hDC, hFont); <br>    GetTextMetrics(hDC, &amp;tm); <br>    GetClientRect(GetParent(hwnd), &amp;rect); <br> <br>    // base the height of the window on size of text <br>    lHeight = tm.tmHeight+6*GetSystemMetrics(SM_CYBORDER)+2; <br>    // saved the height for later reference <br>    SetWindowLong(hwnd, GWL_USERDATA, lHeight); <br>    SetWindowPos(hwnd, NULL, <br>    0, <br>    rect.bottom-lHeight, <br>    rect.right-rect.left, <br>    lHeight, <br>    SWP_NOZORDER | SWP_NOMOVE); <br> <br>    ReleaseDC(hwnd, hDC); <br>    break; <br>} <br> <br>    case WM_LBUTTONDOWN: { <br>PostMessage(GetParent(hwnd), WM_USER+0xa, (DWORD)0L, (LONG)0L); <br>break; <br>    } <br> <br>    case WM_DESTROY: <br>    if (hFont) <br>DeleteObject(hFont); <br>    break; <br> <br>    case WM_SETTEXT: <br>    DefWindowProc(hwnd, message, wParam, lParam); <br>    InvalidateRect(hwnd,NULL,TRUE); <br>    UpdateWindow(hwnd); <br>    return 0L; <br> <br>    case WM_PAINT: <br>{ <br>    PAINTSTRUCT ps; <br>    RECT   rc; <br>    char   ach[128]; <br>    int    len, nxBorder, nyBorder; <br>    HFONT  hOldFont = NULL; <br> <br>    BeginPaint(hwnd, &amp;ps); <br> <br>    GetClientRect(hwnd,&amp;rc); <br> <br>    nxBorder = GetSystemMetrics(SM_CXBORDER); <br>    rc.left  += 9*nxBorder; <br>    rc.right -= 9*nxBorder; <br> <br>    nyBorder = GetSystemMetrics(SM_CYBORDER); <br>    rc.top    += 3*nyBorder; <br>    rc.bottom -= 3*nyBorder; <br> <br>    // 3D Text <br>    len = GetWindowText(hwnd, ach, sizeof(ach)); <br>    SetBkColor(ps.hdc, GetSysColor(COLOR_BTNFACE)); <br> <br>    SetBkMode(ps.hdc, TRANSPARENT); <br>    SetTextColor(ps.hdc, RGB(64,96,96)); <br>    if (hFont) <br>hOldFont = SelectObject(ps.hdc, hFont); <br>    ExtTextOut(ps.hdc, rc.left+2*nxBorder+2, rc.top+2, ETO_OPAQUE | ETO_CLIPPED, <br>&amp;rc, ach, len, NULL); <br> <br>    SetTextColor(ps.hdc, RGB(128,128,128)); <br>    if (hFont) <br>hOldFont = SelectObject(ps.hdc, hFont); <br>    ExtTextOut(ps.hdc, rc.left+2*nxBorder+1, rc.top+1, ETO_CLIPPED, <br>&amp;rc, ach, len, NULL); <br> <br>    SetTextColor(ps.hdc, RGB(255,255,255)); <br>    if (hFont) <br>hOldFont = SelectObject(ps.hdc, hFont); <br>    ExtTextOut(ps.hdc, rc.left+2*nxBorder, rc.top, ETO_CLIPPED, <br>&amp;rc, ach, len, NULL); <br> <br>    SetBkMode(ps.hdc, OPAQUE); <br> <br>    if (hOldFont) <br>SelectObject(ps.hdc, hOldFont); <br> <br>    EndPaint(hwnd, &amp;ps); <br>    return 0L; <br>} <br>    } <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* JuliaWndProc <br>* <br>\**************************************************************************/ <br> <br>LONG APIENTRY JuliaWndProc (HWND hwnd, UINT message, DWORD wParam, LONG lParam) <br>{ <br>    // <br>    // These statics are shared by all the Julia windows.  But, this is <br>    // fine because only one Julia window is tracking at any one time. <br>    // Ideally, we should place this in the per-window INFO data structure. <br>    // But, this is not necessary. <br>    // <br>    static BOOL    bTrack = FALSE; <br>    static int     OrgX, OrgY; <br>    static int     PrevX, PrevY; <br>    static HDC     hDC; <br>    static HCURSOR hCurArrow, hCurPaintCan; <br> <br>    switch (message) <br>    { <br>       case WM_CREATE: { <br> <br>    hpnRed     = CreatePen(PS_SOLID, 0, RGB(0xFF, 0,    0)); <br>    hpnGreen   = CreatePen(PS_SOLID, 0, RGB(0,    0xFF, 0)); <br>    hpnBlack   = CreatePen(PS_SOLID, 0, RGB(0,    0,    0)); <br> <br>    hCurPaintCan = LoadCursor(ghModule, MAKEINTRESOURCE(PAINTCURSOR)); <br>    hCurArrow = LoadCursor(NULL, IDC_ARROW); <br>    break; <br>       } <br> <br>       case WM_DESTROY: { <br>    HWND        hParent; <br>    PINFO       pInfo; <br> <br>    DeleteObject(hpnRed); <br>    DeleteObject(hpnGreen); <br>    DeleteObject(hpnBlack); <br> <br>    if ((hParent=GetParent(hwnd)) == NULL)  <br>{ <br>OutputDebugString ("Can't get hParent!"); <br>break; <br>    } <br>    if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>break; <br>    } <br> <br>    // we might have open resource if we ever load bitmap in this wnd. <br>    bFreeRleFile(pInfo); <br>    bReleaseInfoData(hParent); <br>    break; <br>       } <br> <br>       case WM_QUERYNEWPALETTE: { <br>     HWND        hParent; <br>     PINFO       pInfo; <br>     HDC         hDC; <br>     UINT        i; <br>     HPALETTE    hOldPal; <br> <br>     if ((hParent=GetParent(hwnd)) == NULL)  <br> { <br>OutputDebugString ("Can't get hParent!"); <br>return 0L; <br>     } <br>     if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>  return 0L; <br>     } <br> <br>     // If palette realization causes a palette change, <br>     // we need to do a full redraw. <br> <br>     hDC = GetDC (hwnd); <br> <br>     hOldPal = SelectPalette (hDC, <br>       ((pInfo-&gt;iStretchMode == HALFTONE) ? pInfo-&gt;hHTPal : pInfo-&gt;hPal), <br>       0); <br> <br>     i = RealizePalette(hDC); <br>     SelectPalette (hDC, hOldPal, 0); <br>     ReleaseDC (hwnd, hDC); <br>     bReleaseInfoData(hParent); <br> <br>     if (i) { <br> InvalidateRect (hwnd, (LPRECT) (NULL), TRUE); <br> return TRUE; <br>     } else <br> return FALSE; <br> <br>       } <br>       case WM_PALETTECHANGED: { <br>     HWND        hParent; <br>     PINFO       pInfo; <br>     HDC         hDC; <br>     UINT        i; <br>     HPALETTE    hOldPal; <br> <br>     if ((hParent=GetParent(hwnd)) == NULL) { <br>OutputDebugString ("Can't get hParent!"); <br>return 0L; <br>     } <br>     if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>  return 0L; <br>     } <br> <br>     // if we were not responsible for palette change and if <br>     // palette realization causes a palette change, do a redraw. <br> <br>     if ((HWND)wParam != hwnd){ <br>hDC = GetDC (hwnd); <br> <br>hOldPal = SelectPalette (hDC, <br>       ((pInfo-&gt;iStretchMode == HALFTONE) ? pInfo-&gt;hHTPal : pInfo-&gt;hPal), <br>0); <br> <br>i = RealizePalette (hDC); <br> <br>if (i){ <br>    UpdateColors (hDC); <br>} <br>SelectPalette (hDC, hOldPal, 0); <br>ReleaseDC (hwnd, hDC); <br>    } <br>    bReleaseInfoData(hParent); <br>    break; <br>       } <br> <br>       case WM_PAINT: <br> { <br>     PAINTSTRUCT ps; <br>     HWND        hParent; <br>     PINFO       pInfo; <br>     HDC         hDC; <br>     RECT        rc; <br> <br>     GetClientRect(hwnd,&amp;rc); <br>     hDC = BeginPaint(hwnd, &amp;ps); <br>     EndPaint(hwnd, &amp;ps); <br>     if ((hParent=GetParent(hwnd)) == NULL) { <br>OutputDebugString ("Can't get hParent!"); <br>return 0L; <br>     } <br>     if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>  return 0L; <br>} <br> <br>     if (pInfo-&gt;hBmpSaved) { <br>hDC = GetDC(hwnd); <br>bDrawDIB(hDC, pInfo, 0, 0, rc.right, rc.bottom); <br>ReleaseDC(hwnd, hDC); <br>     } <br>     bReleaseInfoData(hParent); <br> <br>     //EndPaint(hwnd, &amp;ps); <br>     return 0L; <br> } <br> <br>       case WM_RBUTTONDOWN: { <br> RECT   rc; <br> HANDLE hParent; <br> PINFO  pInfo; <br> int    x, y; <br> HWND   hJulia; <br> HANDLE hTextWnd; <br> <br> x = (int) LOWORD(lParam); <br> y = (int) HIWORD(lParam); <br> if ((hParent=GetParent(hwnd)) == NULL) { <br>     OutputDebugString ("Can't get hParent!"); <br>     break; <br> } <br> <br> if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>     break; <br> } <br> <br> hTextWnd = pInfo-&gt;hTextWnd; <br> <br> if (GetWindowLong(GetParent(hwnd), GWL_STYLE) &amp; WS_MAXIMIZE) { <br>     GetClientRect(ghwndMain, &amp;rc); <br>     rc.bottom -= GetWindowLong(hTextWnd,GWL_USERDATA); <br> } else { <br>     GetClientRect(hwnd, &amp;rc); <br> } <br> <br> if (pInfo-&gt;bMandel) { <br> <br>     hJulia = (HWND) SendMessage(ghwndMain, WM_COMMAND, <br> (DWORD)((WORD)MM_JULIA), 0L); <br>     if (hJulia) { <br> //GetClientRect(hwnd, &amp;rc); <br> // <br> // calculate the c value corresponding to the point <br> // <br> c1 = Xform((double) x, 0.0, (double) rc.right, pInfo-&gt;xFrom, pInfo-&gt;xTo); <br> c2 = Xform((double) y, 0.0, (double) rc.bottom, pInfo-&gt;yFrom, pInfo-&gt;yTo); <br> lc1 = XformFix(x, 0, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br> lc2 = XformFix(y, 0, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>sprintf( gtext,"(c1 = %g, c2 = %g)\n", c1, c2); <br>OutputDebugString( gtext ); <br> <br> // <br> // Reset globals to default values for creating Julia set <br> // (Entire set, not zoom in) <br> // <br> bResetGlobal(); <br> PostMessage(hJulia, WM_COMMAND, (DWORD)((WORD) MM_SET_XFORM_ATTR), 0L); <br>     } else { <br> OutputDebugString ("Can't create hJulia!"); <br>     } <br> } <br> bReleaseInfoData(hParent); <br> break; <br>       } <br>       case WM_LBUTTONDOWN: { <br> HANDLE hParent; <br> PINFO  pInfo; <br> int    x, y; <br> DWORD  dwRGB; <br> HBRUSH hBrOld; <br> <br> x = (int) LOWORD(lParam); <br> y = (int) HIWORD(lParam); <br> if ((hParent=GetParent(hwnd)) == NULL) { <br>     OutputDebugString ("Can't get hParent!"); <br>     break; <br> } <br> <br> if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>     break; <br> } <br> <br> if (pInfo-&gt;bFill) { <br>    hDC = GetDC(hwnd); <br>    hBrOld = SelectObject(hDC, pInfo-&gt;hBrush); <br> <br>    dwRGB = GetPixel(hDC, x, y); <br> <br>    ExtFloodFill(hDC, x, y, (COLORREF)dwRGB, FLOODFILLSURFACE); <br>    SelectObject(hDC, hBrOld); <br>    ReleaseDC(hwnd, hDC); <br>    pInfo-&gt;bFill = FALSE; <br> <br>    if (pInfo-&gt;hBmpSaved) <br>DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>    pInfo-&gt;hBmpSaved = SaveBitmap(hwnd, pInfo-&gt;hPal); <br>    pInfo-&gt;bUseDIB = FALSE; <br> <br> <br>    SetCursor(hCurArrow); <br> } else { <br>    bTrack = TRUE; <br>    OrgX = PrevX = x = LOWORD(lParam); <br>    OrgY = PrevY = y = HIWORD(lParam); <br> <br>    hDC = GetDC(hwnd); <br>    SetCapture(hwnd); <br> } <br> bReleaseInfoData(hParent); <br> break; <br>       } <br>       case WM_MOUSEMOVE: { <br> RECT rectClient; <br> int NextX; <br> int NextY; <br> HANDLE hParent; <br> PINFO  pInfo; <br> <br> if ((hParent=GetParent(hwnd)) == NULL) { <br>     OutputDebugString ("Can't get hParent!"); <br>     break; <br> } <br> <br> if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>     break; <br> } <br> <br> if (pInfo-&gt;bFill) { <br> SetCursor(hCurPaintCan); <br> } else { <br> SetCursor(hCurArrow); <br> } <br> <br> bReleaseInfoData(hParent); <br> <br> // Update the selection region <br> if (bTrack) { <br>     NextX = (SHORT) LOWORD(lParam); <br>     NextY = (SHORT) HIWORD(lParam); <br> <br>     // Do not draw outside the window's client area <br> <br>     GetClientRect (hwnd, &amp;rectClient); <br>     if (NextX &lt; rectClient.left) { <br> NextX = rectClient.left; <br>     } else if (NextX &gt;= rectClient.right) { <br> NextX = rectClient.right - 1; <br>     } <br>     if (NextY &lt; rectClient.top) { <br> NextY = rectClient.top; <br>     } else if (NextY &gt;= rectClient.bottom) { <br> NextY = rectClient.bottom - 1; <br>     } <br>     if ((NextX != PrevX) || (NextY != PrevY)) { <br>SetROP2(hDC, R2_NOT);           // Erases the previous box <br> <br>MoveToEx(hDC, OrgX, OrgY, NULL); <br>LineTo(hDC, OrgX, PrevY); <br>LineTo(hDC, PrevX, PrevY); <br>LineTo(hDC, PrevX, OrgY); <br>LineTo(hDC, OrgX, OrgY); <br>     // Get the current mouse position <br> <br>PrevX = NextX; <br>PrevY = NextY; <br>MoveToEx(hDC, OrgX, OrgY, NULL);   // Draws the new box <br>LineTo(hDC, OrgX, PrevY); <br>LineTo(hDC, PrevX, PrevY); <br>LineTo(hDC, PrevX, OrgY); <br>LineTo(hDC, OrgX, OrgY); <br>     } <br> } <br> break; <br> <br>       } <br> <br>       case WM_LBUTTONUP: { <br> RECT rc; <br> HANDLE hParent; <br> PINFO  pInfo; <br> int NextX; <br> int NextY; <br> int iDistX, iDistY, iAbsDstX, iAbsDstY; <br> HWND hZoom; <br> HANDLE hTextWnd; <br> <br> if (!bTrack) <br>    break; <br> <br> // End the selection <br>    ReleaseCapture(); <br>    bTrack = FALSE; <br> <br>    MoveToEx(hDC, OrgX, OrgY, NULL);   // Erases the box <br>    LineTo(hDC, OrgX, PrevY); <br>    LineTo(hDC, PrevX, PrevY); <br>    LineTo(hDC, PrevX, OrgY); <br>    LineTo(hDC, OrgX, OrgY); <br> <br>    NextX = LOWORD(lParam); <br>    NextY = HIWORD(lParam); <br> <br>    iDistX = NextX - OrgX; <br>    iDistY = NextY - OrgY; <br>    iAbsDstX = (iDistX &gt; 0 ? iDistX : -iDistX); <br>    iAbsDstY = (iDistY &gt; 0 ? iDistY : -iDistY); <br>    if (iAbsDstX &gt; iAbsDstY) { <br>NextY = OrgY + (iDistY &gt; 0 ? iAbsDstX : -iAbsDstX); <br>    } else if (iAbsDstX &lt; iAbsDstY) { <br>NextX = OrgX + (iDistX &gt; 0 ? iAbsDstY : -iAbsDstY); <br>    } <br> <br>    MoveToEx(hDC, OrgX, OrgY, NULL);   // Draws the new box <br>    LineTo(hDC, OrgX, NextY); <br>    LineTo(hDC, NextX, NextY); <br>    LineTo(hDC, NextX, OrgY); <br>    LineTo(hDC, OrgX, OrgY); <br> <br>    SetROP2(hDC, R2_COPYPEN); <br> <br>    ReleaseDC(hwnd, hDC); <br>    if ((hParent=GetParent(hwnd)) == NULL) { <br>OutputDebugString ("Can't get hParent!"); <br>break; <br>    } <br> <br>    if ((pInfo = pGetInfoData(hParent)) == NULL) { <br>break; <br>    } <br> <br>    hTextWnd = pInfo-&gt;hTextWnd; <br>    sprintf(gtext, GetStringRes (IDS_MOUSE), OrgX, OrgY, NextX, NextY); <br> <br>    //SetWindowText(hTextWnd, gtext); <br>    OutputDebugString(gtext); <br> <br> <br>    if (GetWindowLong(GetParent(hwnd), GWL_STYLE) &amp; WS_MAXIMIZE) { <br> <br>GetClientRect(ghwndMain, &amp;rc); <br>rc.bottom -= GetWindowLong(hTextWnd,GWL_USERDATA); <br>sprintf(gtext, "(%d, %d), (%d, %d)\n", rc.left, rc.top, rc.right, rc.bottom); <br>//SetWindowText(hTextWnd, gtext); <br>OutputDebugString(gtext); <br> <br>    } else { <br>GetClientRect(hwnd, &amp;rc); <br>    } <br> <br>    if ((OrgX == NextX) &amp;&amp; (OrgY == NextY)) { <br>bReleaseInfoData(hParent); <br>break; <br>    } <br> <br>    hZoom = (HWND) SendMessage(ghwndMain, WM_COMMAND, <br>       pInfo-&gt;bMandel ? (DWORD)((WORD)MM_MANDEL) : (DWORD)((WORD)MM_JULIA), <br>       0L); <br>    if (hZoom) { <br>//GetClientRect(hwnd, &amp;rc); <br>xFrom = Xform((double) OrgX, 0.0, (double) rc.right, pInfo-&gt;xFrom, pInfo-&gt;xTo); <br>xTo   = Xform((double) NextX, 0.0, (double) rc.right, pInfo-&gt;xFrom, pInfo-&gt;xTo); <br>yFrom = Xform((double) OrgY, 0.0, (double) rc.bottom, pInfo-&gt;yFrom, pInfo-&gt;yTo); <br>yTo   = Xform((double) NextY, 0.0, (double) rc.bottom, pInfo-&gt;yFrom, pInfo-&gt;yTo); <br>lxFrom = XformFix(OrgX, 0, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>lxTo   = XformFix(NextX, 0, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>lyFrom = XformFix(OrgY, 0, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br>lyTo   = XformFix(NextY, 0, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br>if (!pInfo-&gt;bMandel) { <br>    c1 = pInfo-&gt;c1; <br>    c2 = pInfo-&gt;c2; <br>    lc1 = pInfo-&gt;lc1; <br>    lc2 = pInfo-&gt;lc2; <br>} <br>PostMessage(hZoom, WM_COMMAND, (DWORD)((WORD) MM_SET_XFORM_ATTR), 0L); <br>    } else { <br>OutputDebugString ("Can't create hZoom!"); <br>    } <br> bReleaseInfoData(hParent); <br> break; <br>       } // case WM_LBUTTONUP <br>    } // switch <br>    return DefWindowProc(hwnd, message, wParam, lParam); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* SuspendDrawThrd <br>* <br>* Effects: Enumerates all the MDI children.  Suspending the drawing thread <br>*          in those windows, if any. <br>* <br>* Warnings: assumes the MDI children has class name "ChildClass." <br>* <br>\**************************************************************************/ <br> <br> <br>BOOL APIENTRY SuspendDrawThrd (HWND hwnd, LONG lParam) { <br>   HANDLE      hThrd; <br>   PINFO       pInfo; <br>   DWORD       dwSuspend; <br>   BOOL        bDrawing; <br>   char        sz[30]; <br> <br>   GetClassName(hwnd, sz, 15); <br>   if (strcmp(sz, "ChildClass") != 0) <br>return 1L; <br>       if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>   return 1L; <br>       } <br> <br>       bDrawing = pInfo-&gt;bDrawing; <br>       hThrd    = pInfo-&gt;hThrd; <br>       bReleaseInfoData(hwnd); <br> <br>       if (hThrd &amp;&amp; bDrawing) { <br>   dwSuspend = SuspendThread(hThrd); <br>   sprintf( gtext,"\nSuspend: dwSuspend = %d, dwSuspend = %g\n", dwSuspend, dwSuspend); <br>   OutputDebugString( gtext ); <br> <br>   if (dwSuspend == -1) { <br>       sprintf( gtext,"Error in suspending thread\n"); <br>       OutputDebugString( gtext ); <br>   } <br>       } <br>   return 1L; <br>   UNREFERENCED_PARAMETER(lParam); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* ResumeDrawThrd <br>* <br>* Effects: Enumerates all the MDI children.  Resuming the drawing thread <br>*          in those windows, if any. <br>* <br>* Warnings: Assumes the MDI children has class name "ChildClass." Also, <br>*           assumes the drawing has been suspended by SuspendDrawThrd. <br>* <br>\**************************************************************************/ <br> <br> <br>BOOL APIENTRY ResumeDrawThrd  (HWND hwnd, LONG lParam) { <br>   HANDLE      hThrd; <br>   PINFO       pInfo; <br>   DWORD       dwSuspend; <br>   BOOL        bDrawing; <br>   char        sz[30]; <br> <br>   GetClassName(hwnd, sz, 15); <br>   if (strcmp(sz, "ChildClass") != 0) <br>return 1L; <br>      if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>  return 1L; <br>      } <br> <br>      bDrawing = pInfo-&gt;bDrawing; <br>      hThrd    = pInfo-&gt;hThrd; <br>      bReleaseInfoData(hwnd); <br> <br>      if (hThrd &amp;&amp; bDrawing) { <br>  dwSuspend = ResumeThread(hThrd); <br>  sprintf( gtext,"Resume: dwSuspend = %d, dwSuspend = %g\n", dwSuspend, dwSuspend); <br>  OutputDebugString( gtext ); <br> <br>  if (dwSuspend == -1) { <br>      sprintf( gtext,"Error in resuming thread\n"); <br>      OutputDebugString( gtext ); <br>  } <br>      } <br>   return 1L; <br>   UNREFERENCED_PARAMETER(lParam); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lMul <br>* <br>* Effects: Fix point multiplication <br>* <br>* Warnings: 9.23 fix point representation used. This is only good for <br>*           multiplication in a limited range.  Will overflow. <br>*           CR! Will be implemented as macros in the future <br>* <br>\**************************************************************************/ <br> <br>LONG lMul(LONG l1, LONG l2) <br>{ <br>    LONGLONG   lliTmp; <br>    LONG       lReturn; <br> <br>    lliTmp = l1; <br>    lliTmp *= l2; <br>    lReturn = (LONG)(lliTmp &gt;&gt; 23); <br> <br>    return(lReturn); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* lDiv <br>* <br>* Effects: fix point division <br>* <br>* Warnings: 9.23 fix point representation used. This is only good for <br>*           division in a limited range.  Will overflow. <br>*           CR! Will be implemented as macros in the future <br>* <br>\**************************************************************************/ <br> <br>LONG lDiv(long l1, long l2) <br>{ <br>    LONGLONG   lliTmp; <br>    LONG       lReturn; <br> <br> <br> <br>    lliTmp  = (LONGLONG)l1; <br>    lliTmp  &lt;&lt;= 23; <br> <br>    lReturn = (LONG)(lliTmp / (LONGLONG)l2); </code></pre>
<p>
</p>
<pre><code>return (lReturn); <br>} <br> <br> <br>/**************************************************************************\ <br>* <br>* StartDrawFix <br>*                                            2 <br>* Effects: Draw'g the Julia Set for Q (z) = z  + c, where z, c are complex <br>*                                    c <br>*          Fact:   |Q (0)| = |c| &gt; 2, the orbit of 0 escapes immediately <br>*                    c <br>*          claim:  |z| &gt;= |c| = 2 + l, l &gt; 0 escapes under Q <br>*                                                           c <br>*          The Julia Set: Basin Boundaries algorithm. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br>BOOL StartDrawFix(PINFO pInfo) <br>{ <br>   DWORD       dwTick1; <br>   HDC         hDC; <br>   RECT        rc; <br> <br>   int m, n, i, iPrev; <br>   int xCurr, yCurr; <br>   int iPen; <br> <br>   LONG c1, c2; <br>   LONG x0, y0, x1, y1, x, y, z; <br> <br>   int  iBand=1; <br>   int  iScan=0; <br>   int  iDiff=0; <br> <br>#ifndef THRDONE <br>   INT      iNumClr; <br>#endif <br> <br>   HDC          hDCMem; <br>   HBITMAP      hBitmap, hOldBitmap; <br> <br>   iPen = pInfo-&gt;iPen + 1; <br>   iPrev = FIRST_PIXEL;    // a big value to signal the first pixel <br>   //iPrev = pInfo-&gt;iIteration + FIRST_PIXEL; <br>   c1 = pInfo-&gt;lc1; <br>   c2 = pInfo-&gt;lc2; <br> <br>   pInfo-&gt;bMandel = FALSE; <br>   pInfo-&gt;bDrawing = TRUE; <br>   hDC = GetDC(pInfo-&gt;hwnd); <br> <br>#ifndef THRDONE <br>    if ((iNumClr = iCreatePenFrPal(hDC, NULL, 0, &amp;(pInfo-&gt;hPal))) != 0) { <br>sprintf( gtext,"iNumClr = %d\n", iNumClr); <br>OutputDebugString( gtext); <br> <br>if ((pInfo-&gt;prghPen = (PVOID*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(HPEN)*iNumClr)) == NULL) { <br>    OutputDebugString ("Failed in Memory Allocation for pInfo-&gt;prghPen!"); <br>} else { <br>    if ((pInfo-&gt;iPen = iCreatePenFrPal(hDC, pInfo-&gt;prghPen, 0, &amp;(pInfo-&gt;hPal))) == 0) <br>OutputDebugString ("Failed in creating pen!"); <br>} <br>    } <br> <br>   hDCMem = CreateCompatibleDC(hDC); <br> <br>   SelectPalette(hDCMem, pInfo-&gt;hPal, FALSE); <br>   SelectPalette(hDC,    pInfo-&gt;hPal, FALSE); <br>   RealizePalette(hDC); <br>   iPen = pInfo-&gt;iPen + 1; <br>#endif <br> <br>   GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>   hBitmap = CreateCompatibleBitmap(hDC, (int)rc.right, (int)rc.bottom); <br>   hOldBitmap = SelectObject(hDCMem, hBitmap); <br>   yCurr = rc.top; <br> <br>   dwTick1 = GetTickCount(); <br>   iScan = (((iScan = BATCH / rc.right) == 0) ? 1 : iScan); <br> <br>   for (n=rc.top; n&lt;=rc.bottom; n+=pInfo-&gt;iStep, yCurr+=pInfo-&gt;iStep, iPrev = FIRST_PIXEL) { <br>       xCurr = rc.left;               // since LineTo excludes last point <br>       MoveToEx(hDCMem, 0, yCurr, NULL); <br>       y0 = XformFix(n, rc.top, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>       for (m=rc.left; m&lt;=rc.right; m++, xCurr++) { <br>   x0 = XformFix(m, rc.left, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>   x = x0; <br>   y = y0; <br> <br>   for (i=1; i&lt;=pInfo-&gt;iIteration; i++) { <br>       x1 = lMul(x - y, x + y) + c1;    // Z = x1 + i x2 <br> <br>       y1 = (lMul(x, y) * 2) + c2; <br>       x = x1; <br>       y = y1;                          //    2       2     2 1/2     2 <br>       z = lMul(x, x) + lMul(y, y);     // |Z|  = ((x1  + x2 )   ) &gt; 2 <br> <br>       if (z &gt; 33554432) <br>    break; <br>   } <br> <br>   if (i != iPrev) <br>   { <br>      if (iPrev != FIRST_PIXEL) <br>      { <br>switch(iPrev) <br>{ <br>   case 1: <br>   if (pInfo-&gt;prghPen) <br>  SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>   break; <br>   default: <br> <br>       if (iPrev &gt;= pInfo-&gt;iIteration)  <br>   { <br>       SelectObject(hDCMem, hpnBlack); <br>       break; <br>       } <br>   if (pInfo-&gt;prghPen) <br>   SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[iPrev % iPen]); <br>       break; <br>} <br>iPrev = i; <br>LineTo(hDCMem,xCurr,yCurr); <br>      } <br>      else <br> iPrev = i;     // remember the color for the first pixel <br>   } <br>       } <br>       switch(i) { <br>   case 1: <br>  if (pInfo-&gt;prghPen) <br>  SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>  break; <br>   default: <br>      if (iPrev &gt;= pInfo-&gt;iIteration) { <br>      SelectObject(hDCMem, hpnBlack); <br>      break; <br>      } <br>  if (pInfo-&gt;prghPen) <br> SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[i % iPen]); <br>      break; <br>       } <br> <br>       LineTo(hDCMem,xCurr,yCurr); <br> <br>       sprintf(gtext, GetStringRes (IDS_DRAWING), ((FLOAT)n/(FLOAT)rc.bottom)*100); <br> <br>       SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>       if (n &gt;= iScan * iBand) { <br>    BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>    iBand++; <br>       } <br>   } <br> <br>   if ((iDiff = iScan * iBand - rc.bottom) != 0) { <br>BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan-iDiff, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>   } <br> <br>   sprintf(gtext, GetStringRes (IDS_DRAWING_DONE)); <br> <br>   SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>   ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>   pInfo-&gt;dwElapsed = GetTickCount() - dwTick1; <br> <br>   if (pInfo-&gt;hBmpSaved) <br>       DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>   pInfo-&gt;hBmpSaved = SelectObject(hDCMem, hOldBitmap); <br>   pInfo-&gt;bDrawing = FALSE; <br>#ifndef THRDONE <br>   if (pInfo-&gt;prghPen != NULL) { <br>       for (i = 0; i &lt;= pInfo-&gt;iPen; i++) { <br>   DeleteObject((HPEN) (pInfo-&gt;prghPen)[i]); <br>       } <br>       GlobalFree(pInfo-&gt;prghPen); <br>   } <br>#endif <br>   DeleteDC(hDCMem); <br>   ExitThread(0); <br>   return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* <br>* StartDraw <br>*                                            2 <br>* Effects: Draw'g the Julia Set for Q (z) = z  + c, where z, c are complex <br>*                                    c <br>*          Fact:   |Q (0)| = |c| &gt; 2, the orbit of 0 escapes immediately <br>*                    c <br>*          claim:  |z| &gt;= |c| = 2 + l, l &gt; 0 escapes under Q <br>*                                                           c <br>*          The Julia Set: Basin Boundaries algorithm. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br>BOOL StartDraw(PINFO pInfo) <br>{ <br>   DWORD       dwTick1; <br>   HDC         hDC; <br>   RECT        rc; <br> <br>   int m, n, i, iPrev; <br>   int xCurr, yCurr; <br>   int iPen; <br> <br>   double c1, c2; <br>   double x0, y0, x1, y1, x, y, z; <br> <br>   int  iBand=1; <br>   int  iScan=0; <br>   int  iDiff=0; <br> <br> <br>   HDC          hDCMem; <br>   HBITMAP      hBitmap, hOldBitmap; <br> <br>#ifndef THRDONE <br>   INT      iNumClr; <br>#endif <br> <br>   iPen = pInfo-&gt;iPen + 1; <br>   iPrev = FIRST_PIXEL;    // a big value to signal the first pixel <br>   //iPrev = pInfo-&gt;iIteration + FIRST_PIXEL; <br>   c1 = pInfo-&gt;c1; <br>   c2 = pInfo-&gt;c2; <br> <br>   pInfo-&gt;bMandel = FALSE; <br>   pInfo-&gt;bDrawing = TRUE; <br>   hDC = GetDC(pInfo-&gt;hwnd); <br> <br>#ifndef THRDONE <br>    if ((iNumClr = iCreatePenFrPal(hDC, NULL, 0, &amp;(pInfo-&gt;hPal))) != 0) { <br>sprintf( gtext,"iNumClr = %d\n", iNumClr); <br>OutputDebugString( gtext); <br> <br>if ((pInfo-&gt;prghPen = (PVOID*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(HPEN)*iNumClr)) == NULL) { <br>    OutputDebugString ("Failed in Memory Allocation for pInfo-&gt;prghPen!"); <br>} else { <br>    if ((pInfo-&gt;iPen = iCreatePenFrPal(hDC, pInfo-&gt;prghPen, 0, &amp;(pInfo-&gt;hPal))) == 0) <br>   OutputDebugString ("Failed in creating pen!"); <br>} <br>    } <br> <br>   hDCMem = CreateCompatibleDC(hDC); <br> <br>   SelectPalette(hDCMem, pInfo-&gt;hPal, FALSE); <br>   SelectPalette(hDC,    pInfo-&gt;hPal, FALSE); <br>   RealizePalette(hDC); <br>   iPen = pInfo-&gt;iPen + 1; <br>#endif <br> <br>   GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>   hBitmap = CreateCompatibleBitmap(hDC, (int)rc.right, (int)rc.bottom); <br>   hOldBitmap = SelectObject(hDCMem, hBitmap); <br>   yCurr = rc.top; <br> <br>   dwTick1 = GetTickCount(); <br> <br>   iScan = (((iScan = BATCH / rc.right) == 0) ? 1 : iScan); <br> <br>   for (n=rc.top; n&lt;=rc.bottom; n+=pInfo-&gt;iStep, yCurr+=pInfo-&gt;iStep, iPrev = FIRST_PIXEL) { <br>       xCurr = rc.left;               // since LineTo excludes last point <br>       MoveToEx(hDCMem, 0, yCurr, NULL); <br>       y0 = Xform((double) n, 0.0, (double) rc.bottom, pInfo-&gt;yFrom, pInfo-&gt;yTo); <br> <br>       for (m=rc.left; m&lt;=rc.right; m++, xCurr++) { <br>   x0 = Xform((double) m, 0.0, (double) rc.right, pInfo-&gt;xFrom, pInfo-&gt;xTo); <br>   x = x0; <br>   y = y0; <br> <br>   for (i=1; i&lt;=pInfo-&gt;iIteration; i++) { <br>       x1 = (x - y) * (x + y) + c1;     // Z = x1 + i x2 <br> <br>       y1 = 2 * x * y + c2; <br>       x = x1; <br>       y = y1;                          //    2       2     2 1/2     2 <br>       z = x * x + y * y;               // |Z|  = ((x1  + x2 )   ) &gt; 2 <br> <br>       if (z &gt; 4.0) <br>    break; <br>   } <br> <br>   if (i != iPrev) <br>   { <br>      if (iPrev != FIRST_PIXEL) <br>      { <br>switch(iPrev) <br>{ <br>   case 1: <br>   if (pInfo-&gt;prghPen) <br>  SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>   break; <br>   default: <br> <br>       if (iPrev &gt;= pInfo-&gt;iIteration) { <br>       SelectObject(hDCMem, hpnBlack); <br>       break; <br>       } <br>   if(pInfo-&gt;prghPen) <br>           SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[iPrev % iPen]); <br>       break; <br>} <br>iPrev = i; <br>LineTo(hDCMem,xCurr,yCurr); <br>      } <br>      else <br> iPrev = i;     // remember the color for the first pixel <br>   } <br>       } <br>       switch(i) { <br>  case 1: <br>  SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>  break; <br>  default: <br>      if (iPrev &gt;= pInfo-&gt;iIteration) { <br>     SelectObject(hDCMem, hpnBlack); <br>     break; <br>      } <br>  if (pInfo-&gt;prghPen) <br>          SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[i % iPen]); <br>      break; <br>       } <br> <br>       LineTo(hDCMem,xCurr,yCurr); <br> <br>       sprintf(gtext, GetStringRes (IDS_DRAWING), ((FLOAT)n/(FLOAT)rc.bottom)*100); <br>       SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>       if (n &gt;= iScan * iBand) { <br>    BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>    iBand++; <br>       } <br>   } <br> <br>   if ((iDiff = iScan * iBand - rc.bottom) != 0) { <br>BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan-iDiff, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>   } <br> <br>   sprintf(gtext, GetStringRes(IDS_DRAWING_DONE)); <br> <br>   SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>   ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>   pInfo-&gt;dwElapsed = GetTickCount() - dwTick1; <br> <br>   if (pInfo-&gt;hBmpSaved) <br>       DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>   pInfo-&gt;hBmpSaved = SelectObject(hDCMem, hOldBitmap); <br>   pInfo-&gt;bDrawing = FALSE; <br>#ifndef THRDONE <br>   if (pInfo-&gt;prghPen != NULL) { <br>       for (i = 0; i &lt;= pInfo-&gt;iPen; i++) { <br>   DeleteObject((HPEN) (pInfo-&gt;prghPen)[i]); <br>       } <br>       GlobalFree(pInfo-&gt;prghPen); <br>   } <br>#endif <br>   DeleteDC(hDCMem); <br> <br>   ExitThread(0); <br>   return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* <br>* StartDraw2 <br>*                                            2 <br>* Effects: Draw'g the Julia Set for Q (z) = z  + c, where z, c are complex <br>* <br>*          The Julia Set: Backward iteration algorithm. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL StartDraw2(PINFO pInfo) <br>{ <br>   HDC         hDC; <br>   RECT        rc; <br>   int         m, n, i; <br>   double      c1, c2; <br>   double      x0, y0, w0, w1, pi, theta, r; <br> <br>   pi = 22.0/7.0; <br>   c1 = 0.360284; <br>   c2 = 0.100376; <br>   x0 = 1.5; <br>   y0 = 1.5; <br> <br>   hDC = GetDC(pInfo-&gt;hwnd); <br> <br>   GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>   for (i=0; i&lt;=15000; i++) { <br>    w0 = x0 - c1; <br>    w1 = y0 - c2; <br>    sprintf( gtext,"w(%g, %g) xy(%g, %g)\n", w0, w1, x0, y0); <br>    OutputDebugString( gtext ); <br> <br>    if (w0 == 0.0) { <br>theta = pi/2; <br>sprintf( gtext,"(w0 == 0.0) theta = %g\n\n", theta); <br>OutputDebugString( gtext ); <br> <br>    } else { <br>if (w0 &gt; 0.0) { <br>    theta = atan(w1/w0); <br>    sprintf( gtext,"(w0 &gt; 0.0) theta = %g\n\n", theta); <br>    OutputDebugString( gtext ); <br> <br>} else { // w0 &lt; 0.0 <br>    theta = pi + atan(w1/w0); <br>    sprintf( gtext,"(w0 &lt; 0.0) theta = %g\n\n", theta); <br>    OutputDebugString( gtext ); <br>} <br>    } <br>    r = sqrt(w0 * w0 + w1 + w1); <br>    //theta = theta/2.0 + ((int) ((2.0*rand()/(RAND_MAX+1.0)))*pi); <br>    //theta = theta/2.0 + ((2.0*rand()/((double)RAND_MAX+1.0))*pi); <br>    r = sqrt(r); <br>    x0 = r*cos(theta); <br>    y0 = r*sin(theta); <br>    if (i &gt; 50) { <br>m = Xform2(x0, pInfo-&gt;xFrom, pInfo-&gt;xTo, 0.0, (double) rc.right); <br>n = Xform2(y0, pInfo-&gt;yFrom, pInfo-&gt;yTo, 0.0, (double) rc.bottom); <br>SetPixel(hDC, m, n, 0x000000ff); <br>    } <br>   } <br> <br>   ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>   ExitThread(0); <br>   return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* <br>* StartMandelbrotFix <br>*                                            2 <br>* Effects: Draw'g the Mandelbrot Set for Q (z) = z  + c, where z, c complex <br>* <br>* Warnings: <br>\**************************************************************************/ <br>BOOL StartMandelbrotFix(PINFO pInfo) <br>{ <br>   DWORD       dwTick1; <br>   HDC         hDC; <br>   RECT        rc; <br>   int         m, n, i, iPrev; <br>   int         xCurr, yCurr; <br>   int         iPen; <br> <br>   LONG c1, c2; <br>   LONG x1, y1, x, y, r; <br>#ifndef THRDONE <br>   INT      iNumClr; <br>#endif <br> <br>   HDC          hDCMem; <br>   HBITMAP      hBitmap, hOldBitmap; <br> <br>   int  iBand=1; <br>   int  iScan=0; <br>   int  iDiff=0; <br> <br>   iPen = pInfo-&gt;iPen + 1; <br>   pInfo-&gt;bMandel = TRUE; <br>   pInfo-&gt;bDrawing = TRUE; <br>   hDC = GetDC(pInfo-&gt;hwnd); <br> <br>#ifndef THRDONE <br>    if ((iNumClr = iCreatePenFrPal(hDC, NULL, 0, &amp;(pInfo-&gt;hPal))) != 0) { <br>sprintf( gtext,"iNumClr = %d\n", iNumClr); <br>OutputDebugString( gtext); <br> <br>if ((pInfo-&gt;prghPen = (PVOID*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(HPEN)*iNumClr)) == NULL) { <br>    OutputDebugString ("Failed in Memory Allocation for pInfo-&gt;prghPen!"); <br>} else { <br>    if ((pInfo-&gt;iPen = iCreatePenFrPal(hDC, pInfo-&gt;prghPen, 0, &amp;(pInfo-&gt;hPal))) == 0) <br>OutputDebugString ("Failed in creating pen!"); <br>} <br>    } <br> <br>   hDCMem = CreateCompatibleDC(hDC); <br> <br>   SelectPalette(hDCMem, pInfo-&gt;hPal, FALSE); <br>   SelectPalette(hDC,    pInfo-&gt;hPal, FALSE); <br>   RealizePalette(hDC); <br>   iPen = pInfo-&gt;iPen + 1; <br>#endif <br> <br>   GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br> <br>   hBitmap = CreateCompatibleBitmap(hDC, (int)rc.right, (int)rc.bottom); <br>   hOldBitmap = SelectObject(hDCMem, hBitmap); <br> <br>   dwTick1 = GetTickCount(); <br>   yCurr = rc.top; <br> <br>   iScan = (((iScan = BATCH / rc.right) == 0) ? 1 : iScan); <br> <br>   for (n=rc.top; n&lt;=rc.bottom; n+=pInfo-&gt;iStep, yCurr+=pInfo-&gt;iStep, iPrev = FIRST_PIXEL) { <br>       xCurr = rc.left;                   // since LineTo excludes last point <br>       MoveToEx(hDCMem, 0, yCurr, NULL); <br>       c2 = XformFix(n, rc.top, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>       for (m=rc.left; m&lt;=rc.right; m++, xCurr++) { <br>   c1 = XformFix(m, rc.left, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>   x = c1; <br>   y = c2; <br> <br>   for (i=1; i&lt;=pInfo-&gt;iIteration; i++) { <br>       x1 = lMul(x - y, x + y) + c1; <br>       y1 = (lMul(x, y) * 2) + c2; <br>       r = lMul(x1, x1) + lMul(y1, y1); <br>       x = x1; <br>       y = y1; <br>       if (r &gt; 33554432) { <br>   break; <br>       } <br>   } <br> <br>   if (i != iPrev) { <br>       if (iPrev != FIRST_PIXEL) { <br> switch(iPrev) { <br>   case 1: <br>   SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); break; <br>   default: <br>       if (iPrev &gt;= pInfo-&gt;iIteration) { <br>    SelectObject(hDCMem, hpnBlack); <br>    break; <br>       } <br>       SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[iPrev % iPen]); <br>       break; <br> } <br> iPrev = i; <br> LineTo(hDCMem, xCurr, yCurr); <br>       } <br>       else <br>  iPrev = i;    // remember the color for the first pixel <br>   } <br>       } <br> <br>       switch(i) { <br>   case 1: <br>       SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>       break; <br>   default: <br>       if (i &gt;= pInfo-&gt;iIteration) { <br>    SelectObject(hDCMem, hpnBlack); <br>    break; <br>       } <br>       SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[i % iPen]); <br>       break; <br>       } <br>       LineTo(hDCMem,xCurr,yCurr); <br> <br>       sprintf(gtext, GetStringRes (IDS_DRAWING), ((FLOAT)n/(FLOAT)rc.bottom)*100); <br> <br>       SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>       if (n &gt;= iScan * iBand) { <br>    BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>    iBand++; <br>       } <br> <br>   } <br> <br>   if ((iDiff = iScan * iBand - rc.bottom) != 0) { <br>BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan-iDiff, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>   } <br> <br>   sprintf(gtext, GetStringRes (IDS_DRAWING_DONE)); <br> <br>   SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>   ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>   pInfo-&gt;dwElapsed = GetTickCount() - dwTick1; <br> <br>   if (pInfo-&gt;hBmpSaved) <br>       DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>   pInfo-&gt;hBmpSaved = SelectObject(hDCMem, hOldBitmap); <br>   pInfo-&gt;bDrawing = FALSE; <br> <br>#ifndef THRDONE <br>   if (pInfo-&gt;prghPen != NULL) { <br>       for (i = 0; i &lt;= pInfo-&gt;iPen; i++) { <br>   DeleteObject((HPEN) (pInfo-&gt;prghPen)[i]); <br>       } <br>       GlobalFree(pInfo-&gt;prghPen); <br>   } <br>#endif <br> <br>   DeleteDC(hDCMem); <br> <br>   ExitThread(0); <br>   return TRUE; <br>} <br> <br>/**************************************************************************\ <br>* <br>* StartMandelbrot <br>*                                            2 <br>* Effects: Draw'g the Mandelbrot Set for Q (z) = z  + c, where z, c complex <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br>BOOL StartMandelbrot(PINFO pInfo) <br>{ <br>   DWORD       dwTick1; <br>   HDC         hDC; <br>   RECT        rc; <br>   int         m, n, i, iPrev; <br>   int         xCurr, yCurr; <br>   int         iPen; <br> <br>#ifndef THRDONE <br>   INT      iNumClr; <br>   char     text[256]; <br>#endif <br> <br>   double c1, c2; <br>   double x1, y1, x, y, r; <br> <br>   HDC          hDCMem; <br>   HBITMAP      hBitmap, hOldBitmap; <br> <br>   int  iBand=1; <br>   int  iScan=0; <br>   int  iDiff=0; <br> <br>   iPrev = 0; <br>   iPen = pInfo-&gt;iPen + 1; <br>   pInfo-&gt;bMandel = TRUE; <br>   pInfo-&gt;bDrawing = TRUE; <br>   hDC = GetDC(pInfo-&gt;hwnd); <br> <br>#ifndef THRDONE <br>    if ((iNumClr = iCreatePenFrPal(hDC, NULL, 0, &amp;(pInfo-&gt;hPal))) != 0) { <br>sprintf( gtext,"iNumClr = %d\n", iNumClr); <br>OutputDebugString( gtext); <br> <br>if ((pInfo-&gt;prghPen = (PVOID*) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(HPEN)*iNumClr)) == NULL) { <br>    OutputDebugString ("Failed in Memory Allocation for pInfo-&gt;prghPen!"); <br>} else { <br>    if ((pInfo-&gt;iPen = iCreatePenFrPal(hDC, pInfo-&gt;prghPen, 1, &amp;(pInfo-&gt;hPal))) == 0) <br>OutputDebugString ("Failed in creating pen!"); <br>} <br>    } <br> <br>   hDCMem = CreateCompatibleDC(hDC); <br> <br>   SelectPalette(hDCMem, pInfo-&gt;hPal, FALSE); <br>   SelectPalette(hDC,    pInfo-&gt;hPal, FALSE); <br>   RealizePalette(hDC); <br>   iPen = pInfo-&gt;iPen + 1; <br>   wsprintf(text, "iPen = %d\n", iPen); <br>   //MessageBox(ghwndMain, text, "Error", MB_OK); <br>#endif <br> <br>   GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br> <br>   hBitmap = CreateCompatibleBitmap(hDC, (int)rc.right, (int)rc.bottom); <br>   hOldBitmap = SelectObject(hDCMem, hBitmap); <br> <br>#if 0 <br> { <br>   int iWidth, i, j; <br> <br>   iWidth = rc.right/iNumClr; <br> <br>   for (i = 0; i &lt; iNumClr; i++) { <br>       SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[i % iNumClr]); <br>       for (j = 0; j &lt; iWidth; j++) { <br>    MoveToEx(hDCMem, i*iWidth+j, 0, NULL); <br>    LineTo(hDCMem, i*iWidth+j, rc.bottom); <br>       } <br> <br>   } <br> } <br>#endif <br> <br>   dwTick1 = GetTickCount(); <br> <br>   iScan = (((iScan = BATCH / rc.right) == 0) ? 1 : iScan); <br> <br>   yCurr = rc.top; <br>   for (n=rc.top; n&lt;=rc.bottom; n+=pInfo-&gt;iStep, yCurr+=pInfo-&gt;iStep, iPrev = FIRST_PIXEL) { <br>       xCurr = rc.left;                   // since LineTo excludes last point <br>       MoveToEx(hDCMem, 0, yCurr, NULL); <br>       c2 = Xform((double) n, 0.0, (double) rc.bottom, pInfo-&gt;yFrom, pInfo-&gt;yTo); <br> <br>       for (m=rc.left; m&lt;=rc.right; m++, xCurr++) { <br>   c1 = Xform((double) m, 0.0, (double) rc.right, pInfo-&gt;xFrom, pInfo-&gt;xTo); <br>   x = c1; <br>   y = c2; <br> <br>   for (i=1; i&lt;=pInfo-&gt;iIteration; i++) { <br>       x1 = (x - y) * (x + y) + c1; <br>       y1 = 2 * x * y + c2; <br>       r = x1 * x1 + y1 * y1; <br>       x = x1; <br>       y = y1; <br>       if (r &gt; 4.0) { <br>   break; <br>       } <br>   } <br> <br>   if (i != iPrev) { <br>       if (iPrev != FIRST_PIXEL) { <br> switch(iPrev) { <br>   case 1: <br>   SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>    break; <br>   default: <br>       if (iPrev &gt;= pInfo-&gt;iIteration) { <br>    SelectObject(hDCMem, hpnBlack); <br>    break; <br>       } <br>       SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[iPrev % iPen]); <br>       break; <br> } <br> iPrev = i; <br> LineTo(hDCMem, xCurr, yCurr); <br>       } <br>       else <br>  iPrev = i;    // remember the color for the first pixel <br>   } <br>       } <br> <br>       switch(i) { <br>      case 1: <br>      SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[0]); <br>       break; <br>      default: <br>  if (i &gt;= pInfo-&gt;iIteration) { <br>       SelectObject(hDCMem, hpnBlack); <br>       break; <br>  } <br>  SelectObject(hDCMem, (HPEN)(pInfo-&gt;prghPen)[i % iPen]); <br>  break; <br>       } <br> <br>       LineTo(hDCMem,xCurr,yCurr); <br> <br>       sprintf(gtext, GetStringRes (IDS_DRAWING), ((FLOAT)n/(FLOAT)rc.bottom)*100); <br> <br>       SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>       if (n &gt;= iScan * iBand) { <br>    BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>    iBand++; <br>       } <br>   } <br> <br>   if ((iDiff = iScan * iBand - rc.bottom) != 0) { <br>BitBlt(hDC, 0, iScan * (iBand-1), rc.right, iScan-iDiff, hDCMem, 0, iScan * (iBand-1), SRCCOPY); <br>   } <br> <br>   sprintf(gtext, GetStringRes (IDS_DRAWING_DONE)); <br> <br>   SetWindowText(pInfo-&gt;hTextWnd, gtext); <br> <br>   ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>   pInfo-&gt;dwElapsed = GetTickCount() - dwTick1; <br> <br>   if (pInfo-&gt;hBmpSaved) <br>       DeleteObject(pInfo-&gt;hBmpSaved); <br> <br>   pInfo-&gt;hBmpSaved = SelectObject(hDCMem, hOldBitmap); <br>   pInfo-&gt;bDrawing = FALSE; <br>#ifndef THRDONE <br>   if (pInfo-&gt;prghPen != NULL) { <br>       for (i = 0; i &lt;= pInfo-&gt;iPen; i++) { <br>   DeleteObject((HPEN) (pInfo-&gt;prghPen)[i]); <br>       } <br>       GlobalFree(pInfo-&gt;prghPen); <br>   } <br>#endif <br> <br>   DeleteDC(hDCMem); <br> <br>   ExitThread(0); <br>   return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* Xform <br>* <br>* Effects: Given m, find x. <br>* <br>*          Xform(Pt) : Src |--&gt; Dest <br>* eg. <br>*          Src |----|--------|      |--&gt;   Dest |----|--------| <br>*              -2   x        2                  0    m       320 <br>* <br>*          x = (m - 0)/(320 - 0) * (2 - -2) + -2 <br>* <br>* Warnings: 1. This will become a macro in the future for speed.  For now, <br>*              it is here for debugging purposes. <br>* <br>\**************************************************************************/ <br>#if 0 <br>double Xform( <br>   double Pt, <br>   double SrcFrom, <br>   double SrcTo, <br>   double DestFrom, <br>   double DestTo) <br>{ <br> //sprintf( gtext,"%g = Xform(%g, %g, %g, %g, %g)\n", ((Pt-SrcFrom)/(SrcTo-SrcFrom)*(DestTo-DestFrom))+DestFrom, Pt, SrcFrom, SrcTo, DestFrom, DestTo); <br> //OutputDebugString( gtext ); <br> return(((Pt-SrcFrom)/(SrcTo-SrcFrom)*(DestTo-DestFrom))+DestFrom); <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* <br>* Xform2 <br>* <br>* Effects: Given x, find m. <br>* <br>*          Xform(Pt) : Src |--&gt; Dest <br>* eg. <br>*          Src |----|--------|      |--&gt;   Dest |----|--------| <br>*              -2   x        2                  0    m       320 <br>* <br>*          m = (x - -2)/(2 - -2) * 320 <br>* <br>* Warnings: 1. This will become a macro in the future for speed.  For now, <br>*              it is here for debugging purposes. <br>* <br>\**************************************************************************/ <br>#if 0 <br>int Xform2( <br>   double Pt, <br>   double SrcFrom, <br>   double SrcTo, <br>   double DestFrom, <br>   double DestTo) <br>{ <br> //sprintf( gtext,"%g = Xform(%g, %g, %g, %g, %g)\n", ((Pt-SrcFrom)/(SrcTo-SrcFrom)*(DestTo-DestFrom))+DestFrom, Pt, SrcFrom, SrcTo, DestFrom, DestTo); <br> //OutputDebugString( gtext ); <br> return((int) ((Pt-SrcFrom)/(SrcTo-SrcFrom)*(DestTo-DestFrom)+DestFrom)); <br>} <br>#endif <br> <br>/******************************Public*Routine******************************\ <br>* <br>* SaveBitmap <br>* <br>* Effects:  Returns the handle of a bitmap corresponding to the window. <br>*           using utilizing BitBlt. <br>* <br>* Warnings: <br>*   // should we set the dirty flag here? <br>* <br>* <br>\**************************************************************************/ <br> <br>HBITMAP SaveBitmap(HWND hWnd, HPALETTE hPal) { <br>    HDC     hdcMem, hDC; <br>    HBITMAP hBitmap, hOldBitmap; <br>    RECT    rc; <br>    HPALETTE hPalOld, hPalMemOld; <br>    int     ii; <br> <br>    hDC = GetDC(hWnd); <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    if (hPal) { <br> <br>hPalOld = SelectPalette(hDC, hPal, FALSE); <br>ii=RealizePalette(hDC); <br>if (ii){ <br>    UpdateColors (hDC); <br>} <br> <br>    } <br> <br>    hdcMem = CreateCompatibleDC(hDC); <br> <br>    if (hPal) { <br> <br>hPalMemOld = SelectPalette(hdcMem, hPal, FALSE); <br>RealizePalette(hdcMem); <br>    } <br> <br>    hBitmap = CreateCompatibleBitmap(hDC, (int)rc.right-rc.left, (int)rc.bottom-rc.top); <br> <br>    hOldBitmap = SelectObject(hdcMem, hBitmap); <br> <br> <br>    BitBlt(hdcMem, 0, 0, (int)rc.right-rc.left, (int)rc.bottom-rc.top, hDC, 0, 0, SRCCOPY); <br>    hBitmap = SelectObject(hdcMem, hOldBitmap); <br> <br>    DeleteDC(hdcMem); <br>    ReleaseDC(hWnd, hDC); <br> <br>    return(hBitmap); <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* DrawBitmap <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>void DrawBitmap(HDC hdc, PINFO pInfo, int xStart, int yStart, int cx, int cy) { <br>    BITMAP bm; <br>    HDC    hdcMem; <br>    POINT  ptSize, ptOrg; <br>    HPALETTE hPalOld, hPalMemOld; <br>    char    text[128]; <br> <br>    if ((pInfo-&gt;hPal) &amp;&amp; !(pInfo-&gt;bUseMono)) { <br> <br>hPalOld = SelectPalette(hdc, <br>     ((pInfo-&gt;iStretchMode == HALFTONE) ? pInfo-&gt;hHTPal : pInfo-&gt;hPal), <br>     FALSE); <br>//RealizePalette(hdc); <br> <br>wsprintf(text, "Realized Palette = %d", RealizePalette(hdc)); <br> <br>OutputDebugString (text); <br> <br> <br>UpdateColors (hdc); <br>    } <br> <br>    hdcMem = CreateCompatibleDC(hdc); <br> <br>    if ((pInfo-&gt;hPal) &amp;&amp; !(pInfo-&gt;bUseMono)) { <br> <br>hPalMemOld = SelectPalette(hdcMem, <br>     ((pInfo-&gt;iStretchMode == HALFTONE) ? pInfo-&gt;hHTPal : pInfo-&gt;hPal), <br>      FALSE); <br>//RealizePalette(hdcMem); <br>wsprintf(text, "Realized Palette = %d", RealizePalette(hdcMem)); <br>OutputDebugString (text); <br> <br> <br>UpdateColors (hdcMem); <br> <br> <br> <br>    } <br> <br>    SelectObject(hdcMem, (pInfo-&gt;bUseMono ? pInfo-&gt;hBmpMono : pInfo-&gt;hBmpSaved)); <br>    SetMapMode(hdcMem, GetMapMode(hdc)); <br> <br>    GetObject((pInfo-&gt;bUseMono ? pInfo-&gt;hBmpMono : pInfo-&gt;hBmpSaved), sizeof(BITMAP), (LPSTR)&amp;bm); <br>    ptSize.x = bm.bmWidth; <br>    ptSize.y = bm.bmHeight; <br>    DPtoLP(hdc, &amp;ptSize, 1); <br> <br>    ptOrg.x = 0; <br>    ptOrg.y = 0; <br>    DPtoLP(hdcMem, &amp;ptOrg, 1); <br> <br>    if (pInfo-&gt;bStretch) { <br>SetStretchBltMode(hdc, pInfo-&gt;iStretchMode); <br>// cx+1 and cy+1: temporary work around for a bug! <br>StretchBlt(hdc, xStart, yStart, cx+1, cy+1, <br>       hdcMem, ptOrg.x, ptOrg.y, ptSize.x, ptSize.y,SRCCOPY); <br>    } else { <br>BitBlt(hdc, xStart, yStart, ptSize.x, ptSize.y, <br>       hdcMem, xStart, yStart, SRCCOPY); <br>    } <br> <br>    if (pInfo-&gt;bUseMono) <br>pInfo-&gt;bUseMono = FALSE; <br> <br>    DeleteDC(hdcMem); <br>    UNREFERENCED_PARAMETER(cx); <br>    UNREFERENCED_PARAMETER(cy); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bDrawDIB <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bDrawDIB(HDC hDC, PINFO pInfo, int xStart, int yStart, int cx, int cy) <br>{ <br>    HBITMAP     hBmpOld, hBmp; <br>    BOOL        bSuccess; <br>    PBITMAPINFO pbmi; <br>    HDC         hdcMem; <br>    BITMAP      bm; <br> <br>    bSuccess = TRUE; <br>    if (pInfo-&gt;bUseMono) { <br>DrawBitmap(hDC, pInfo, xStart, yStart, cx, cy); <br>return bSuccess; <br>    } <br> <br>    if ((hBmp = pInfo-&gt;hBmpSaved) == NULL) { <br> <br>MessageBox(ghwndMain, GetStringRes (IDS_NO_BITMAP_TO_DRAW),  <br>       NULL, MB_OK); <br>return FALSE; <br>    } <br> <br>    if (pInfo-&gt;bStretch) { <br>SetStretchBltMode(hDC, pInfo-&gt;iStretchMode); <br> <br>if (pInfo-&gt;bUseDIB) { // this'll give a src for halftone... <br>    pbmi = (PBITMAPINFO) (pInfo-&gt;RleData.rgpbmi[0]); <br> <br>    // Select and realize the appropriate palette to destination DC <br>    if ((pInfo-&gt;iStretchMode == HALFTONE) &amp;&amp; (pInfo-&gt;hHTPal)) { <br>SelectPalette(hDC, pInfo-&gt;hHTPal, FALSE); <br>RealizePalette(hDC); <br>    } else { <br>if ((pInfo-&gt;iStretchMode != HALFTONE) &amp;&amp; (pInfo-&gt;hPal)) { <br>    SelectPalette(hDC, pInfo-&gt;hPal, FALSE); <br>    RealizePalette(hDC); <br>} <br>    } <br>    if (pInfo-&gt;bCoreHdr) { <br>StretchDIBits(hDC, xStart, yStart, cx, cy, <br>  0, 0, ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcWidth, <br>((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcHeight, <br>  (LPSTR)pInfo-&gt;RleData.rgpjFrame[0], pbmi, DIB_RGB_COLORS, SRCCOPY); <br>    } else { <br>StretchDIBits(hDC, xStart, yStart, cx, cy, <br>  0, 0, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight, <br>  (LPSTR)pInfo-&gt;RleData.rgpjFrame[0], pbmi, DIB_RGB_COLORS, SRCCOPY); <br>    } <br>} else { // image is dirty or created on this device <br> <br>    HBITMAP     hDIB; <br> <br>    // <br>    // Get the source DIB info from the DDB for halftoning </code></pre>
<p>
</p>
<pre><code>// <br>    hDIB = DIBfromDDB(hDC, hBmp, pInfo); <br> <br>    hdcMem = CreateCompatibleDC(hDC); <br>    hBmpOld = SelectObject(hdcMem, hDIB); <br> <br>    if ((pInfo-&gt;iStretchMode == HALFTONE) &amp;&amp; (pInfo-&gt;hHTPal)) { <br>SelectPalette(hDC, pInfo-&gt;hHTPal, FALSE); <br>RealizePalette(hDC); <br>    } else { <br>if ((pInfo-&gt;iStretchMode != HALFTONE) &amp;&amp; (pInfo-&gt;hPal)) { <br>    SelectPalette(hDC, pInfo-&gt;hPal, FALSE); <br>    RealizePalette(hDC); <br>} <br>    } <br> <br>    // <br>    // Use StretchBlt here instead of StretchDIBits just for <br>    // demonstrating using the API with halftone <br>    // <br>    GetObject(hDIB, sizeof(BITMAP), (LPSTR)&amp;bm); <br>    StretchBlt(hDC, xStart, yStart, cx, cy, hdcMem, <br>  0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY); <br> <br>    DeleteDC(hdcMem); <br> <br>} <br>return bSuccess; <br>    } <br> <br>    // <br>    // Not stretching...No halftone <br>    // <br> <br>    GetObject(hBmp, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>    // Select and realize the appropriate palette to destination DC <br>    if (pInfo-&gt;hPal) { <br>SelectPalette(hDC, pInfo-&gt;hPal, FALSE); <br>RealizePalette(hDC); <br>    } <br> <br>    if (pInfo-&gt;bUseDIB) { // this'll give a src <br>pbmi = (PBITMAPINFO) (pInfo-&gt;RleData.rgpbmi[0]); <br> <br>// default to use SetDIBitsToDevice <br>SetDIBitsToDevice(hDC, xStart, yStart, bm.bmWidth, bm.bmHeight, <br>      0, 0, 0, bm.bmHeight, pInfo-&gt;RleData.rgpjFrame[0], <br>      pbmi, DIB_RGB_COLORS); <br>    } else { // image is dirty or created on this device <br> <br>hdcMem = CreateCompatibleDC(hDC); <br>hBmpOld = SelectObject(hdcMem, hBmp); <br> <br>BitBlt(hDC, xStart, yStart, bm.bmWidth, bm.bmHeight, <br>       hdcMem, 0, 0, SRCCOPY); <br> <br>DeleteDC(hdcMem); <br>    } <br> <br>    return bSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* pGetInfoData(HWND hwnd) <br>* <br>* Effects:  calls LocalLock, returning pointer to Info structure. <br>*           assumes hwnd contains handle to Info structure at index 0. <br>*           should call bReleaseInfoData when done. <br>*           Global alert: ghwndMain used. <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>PINFO pGetInfoData(HWND hwnd) <br>{ <br>    HANDLE hInfo; <br>    PINFO  pInfo; <br> <br>    hInfo = (HANDLE) GetWindowLong(hwnd, 0); <br>    if (hInfo == NULL) { <br>OutputDebugString ("Null Info handle retrieved - GetInfo"); <br>return NULL; <br>    } <br> <br>    if ((pInfo = (PINFO)LocalLock(hInfo)) == NULL) { <br>return NULL; <br>    } <br> <br>    return pInfo; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bReleaseInfoData(HWND hwnd) <br>* <br>* Effects: calls LocalUnlock.  Returns whatever LocalUnlock returns. <br>* <br>* Warnings: assumes LocalLock was called previously. <br>*           assumes hwnd contains handle to Info structure at index 0. <br>*           Global alert: ghwndMain used. <br>* <br>\**************************************************************************/ <br> <br>BOOL bReleaseInfoData(HWND hwnd) <br>{ <br>    HANDLE hInfo; <br> <br>    hInfo = (HANDLE) GetWindowLong(hwnd, 0); <br>    if (hInfo == NULL) { <br>OutputDebugString ("Null Info handle retrieved - ReleaseInfo"); <br>return FALSE; <br>    } <br> <br>    return (LocalUnlock(hInfo)); <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bCheckMutexMenuItem <br>* <br>* Effects: Put a check mark on uiCheckItem in the hMenu.  Remove previous <br>*          check mark, if any, on items in the same group.  Returns TRUE <br>*          if successful, FALSE otherwise (item not exists). <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bCheckMutexMenuItem(PINFO pInfo, HMENU hMenu, UINT uiCheckItem) <br>{ <br> <br>    switch(uiCheckItem) { <br>case MM_TP_IDLE: <br>case MM_TP_LOW: <br>case MM_TP_BELOW_NORMAL: <br>case MM_TP_NORMAL: <br>case MM_TP_ABOVE_NORMAL: <br>case MM_TP_HIGH: <br>case MM_TP_TIME_CRITICAL: <br>    switch (pInfo-&gt;iPriority) { <br>case THREAD_PRIORITY_IDLE: <br>    CheckMenuItem(hMenu, MM_TP_IDLE, MF_UNCHECKED); <br>    break; <br>case THREAD_PRIORITY_LOWEST: <br>    CheckMenuItem(hMenu, MM_TP_LOW, MF_UNCHECKED); <br>    break; <br>case THREAD_PRIORITY_BELOW_NORMAL: <br>    CheckMenuItem(hMenu, MM_TP_BELOW_NORMAL, MF_UNCHECKED); <br>    break; <br>case THREAD_PRIORITY_NORMAL: <br>    CheckMenuItem(hMenu, MM_TP_NORMAL, MF_UNCHECKED); <br>    break; <br>case THREAD_PRIORITY_ABOVE_NORMAL: <br>    CheckMenuItem(hMenu, MM_TP_ABOVE_NORMAL, MF_UNCHECKED); <br>    break; <br>case THREAD_PRIORITY_HIGHEST: <br>    CheckMenuItem(hMenu, MM_TP_HIGH, MF_UNCHECKED); <br>    break; <br>case THREAD_PRIORITY_TIME_CRITICAL: <br>    CheckMenuItem(hMenu, MM_TP_TIME_CRITICAL, MF_UNCHECKED); <br>    break; <br>default: <br>    break; <br>    } <br>    break; <br>case MM_FLOAT: <br>case MM_FIX: <br>    CheckMenuItem(hMenu, MM_FLOAT, MF_UNCHECKED); <br>    CheckMenuItem(hMenu, MM_FIX,   MF_UNCHECKED); <br>    break; <br>case MM_ITERATION_100: <br>case MM_ITERATION_500: <br>case MM_ITERATION_1000: <br>case MM_ITERATION_5000: <br>case MM_ITERATION_DOUBLE: <br>    switch (pInfo-&gt;iIteration) { <br>case 100: <br>    CheckMenuItem(hMenu, MM_ITERATION_100, MF_UNCHECKED); <br>    break; <br>case 500: <br>    CheckMenuItem(hMenu, MM_ITERATION_500, MF_UNCHECKED); <br>    break; <br>case 1000: <br>    CheckMenuItem(hMenu, MM_ITERATION_1000, MF_UNCHECKED); <br>    break; <br>case 5000: <br>    CheckMenuItem(hMenu, MM_ITERATION_5000, MF_UNCHECKED); <br>    break; <br>default: <br>    CheckMenuItem(hMenu, MM_ITERATION_DOUBLE, MF_UNCHECKED); <br>    break; <br>    } <br>    break; <br>case MM_STEP_ONE: <br>case MM_STEP_TWO: <br>case MM_STEP_THREE: <br>    switch (pInfo-&gt;iStep) { <br>case 1: <br>    CheckMenuItem(hMenu, MM_STEP_ONE, MF_UNCHECKED); <br>    break; <br>case 2: <br>    CheckMenuItem(hMenu, MM_STEP_TWO, MF_UNCHECKED); <br>    break; <br>default: <br>    CheckMenuItem(hMenu, MM_STEP_THREE, MF_UNCHECKED); <br>    break; <br>    } <br>    break; <br>case MM_STRETCHBLT: <br>case MM_BITBLT: <br>CheckMenuItem(hMenu, MM_STRETCHBLT,   MF_UNCHECKED); <br>CheckMenuItem(hMenu, MM_BITBLT,       MF_UNCHECKED); <br>    break; <br>case MM_BLACKONWHITE: <br>case MM_COLORONCOLOR: <br>case MM_WHITEONBLACK: <br>case MM_HALFTONE: <br>    switch (pInfo-&gt;iStretchMode) { <br>case BLACKONWHITE: <br>    CheckMenuItem(hMenu, MM_BLACKONWHITE, MF_UNCHECKED); <br>    break; <br>case COLORONCOLOR: <br>    CheckMenuItem(hMenu, MM_COLORONCOLOR, MF_UNCHECKED); <br>    break; <br>case WHITEONBLACK: <br>    CheckMenuItem(hMenu, MM_WHITEONBLACK, MF_UNCHECKED); <br>    break; <br>case HALFTONE: <br>    CheckMenuItem(hMenu, MM_HALFTONE, MF_UNCHECKED); <br>    break; <br>default: <br>    break; <br>    } <br>    break; <br>case MM_PORTRAIT: <br>case MM_LANDSCAPE: <br>CheckMenuItem(hMenu, MM_PORTRAIT,   MF_UNCHECKED); <br>CheckMenuItem(hMenu, MM_LANDSCAPE,  MF_UNCHECKED); <br>    break; <br>default: <br>    return FALSE; <br>    } <br>    CheckMenuItem(hMenu, uiCheckItem, MF_CHECKED); <br>    return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* vChkMenuItem <br>* <br>* Effects:  Helper function for checking or unchecking menu items based on <br>*           values set in the pInfo.  Gets called when processing <br>*           WM_MDIACTIVATE <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>VOID vChkMenuItem(PINFO pInfo, HMENU hMenu, UINT uiFlag) <br>{ <br>    (pInfo-&gt;bStretch ? <br>CheckMenuItem(hMenu, MM_STRETCHBLT, uiFlag) : <br>CheckMenuItem(hMenu, MM_BITBLT, uiFlag) ); <br> <br>    switch (pInfo-&gt;iPriority) { <br>case THREAD_PRIORITY_IDLE: <br>    CheckMenuItem(hMenu, MM_TP_IDLE, uiFlag); <br>    break; <br>case THREAD_PRIORITY_LOWEST: <br>    CheckMenuItem(hMenu, MM_TP_LOW, uiFlag); <br>    break; <br>case THREAD_PRIORITY_BELOW_NORMAL: <br>    CheckMenuItem(hMenu, MM_TP_BELOW_NORMAL, uiFlag); <br>    break; <br>case THREAD_PRIORITY_NORMAL: <br>    CheckMenuItem(hMenu, MM_TP_NORMAL, uiFlag); <br>    break; <br>case THREAD_PRIORITY_ABOVE_NORMAL: <br>    CheckMenuItem(hMenu, MM_TP_ABOVE_NORMAL, uiFlag); <br>    break; <br>case THREAD_PRIORITY_HIGHEST: <br>    CheckMenuItem(hMenu, MM_TP_HIGH, uiFlag); <br>    break; <br>case THREAD_PRIORITY_TIME_CRITICAL: <br>    CheckMenuItem(hMenu, MM_TP_TIME_CRITICAL, uiFlag); <br>    break; <br>default: <br>    break; <br>    } <br> <br>    switch (pInfo-&gt;iStretchMode) { <br>case BLACKONWHITE: <br>    CheckMenuItem(hMenu, MM_BLACKONWHITE, uiFlag); <br>    break; <br>case COLORONCOLOR: <br>    CheckMenuItem(hMenu, MM_COLORONCOLOR, uiFlag); <br>    break; <br>case WHITEONBLACK: <br>    CheckMenuItem(hMenu, MM_WHITEONBLACK, uiFlag); <br>    break; <br>case HALFTONE: <br>    CheckMenuItem(hMenu, MM_HALFTONE, uiFlag); <br>    break; <br>default: <br>    break; <br>    } <br> <br>    switch (pInfo-&gt;iStep) { <br>case 1: <br>    CheckMenuItem(hMenu, MM_STEP_ONE, uiFlag); <br>    break; <br>case 2: <br>    CheckMenuItem(hMenu, MM_STEP_TWO, uiFlag); <br>    break; <br>default: <br>    CheckMenuItem(hMenu, MM_STEP_THREE, uiFlag); <br>    break; <br>    } <br> <br>    switch (pInfo-&gt;iIteration) { <br>case 100: <br>    CheckMenuItem(hMenu, MM_ITERATION_100, uiFlag); <br>    break; <br>case 500: <br>    CheckMenuItem(hMenu, MM_ITERATION_500, uiFlag); <br>    break; <br>case 1000: <br>    CheckMenuItem(hMenu, MM_ITERATION_1000, uiFlag); <br>    break; <br>case 5000: <br>    CheckMenuItem(hMenu, MM_ITERATION_5000, uiFlag); <br>    break; <br>default: <br>    CheckMenuItem(hMenu, MM_ITERATION_DOUBLE, uiFlag); <br>    break; <br>    } <br>    return; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bInitInfo <br>* <br>* Effects: Initialize the Info data structure <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bInitInfo(PINFO pInfo) <br>{ <br>    pInfo-&gt;hParent      = ghwndClient; <br>    pInfo-&gt;xFrom        = -2.0; <br>    pInfo-&gt;xTo          = 1.0; <br>    pInfo-&gt;yFrom        = 1.5; <br>    pInfo-&gt;yTo          = -1.5; <br>    pInfo-&gt;lxFrom       = -16777216;                 // 9.23 fix point <br>    pInfo-&gt;lxTo         =  8388608;                  // representation of <br>    pInfo-&gt;lyFrom       =  12582912;                 // -2, 1.0, 1.5, and -1.5 <br>    pInfo-&gt;lyTo         = -12582912;                 // <br>    pInfo-&gt;iIteration   = gIteration; <br>    pInfo-&gt;iStep        = gStep; <br>    pInfo-&gt;bStretch     = gbStretch; <br>    pInfo-&gt;iStretchMode = giStretchMode; <br>    wsprintf((LPSTR) &amp;(pInfo-&gt;CaptionBarText), ""); <br>    pInfo-&gt;hwnd         = NULL; <br>    pInfo-&gt;hTextWnd     = NULL; <br>    pInfo-&gt;rcClient.top    = 0; <br>    pInfo-&gt;rcClient.left   = 0; <br>    pInfo-&gt;rcClient.bottom = 0; <br>    pInfo-&gt;rcClient.right  = 0; <br>    pInfo-&gt;hdcClient    = NULL; <br>    pInfo-&gt;hRgnPath     = NULL; <br>    pInfo-&gt;hThrd0       = NULL; <br>    pInfo-&gt;hThrd        = NULL; <br>    pInfo-&gt;bDrawing     = FALSE; <br>    pInfo-&gt;dwThreadId   = 0; <br>    pInfo-&gt;dwElapsed    = 0L; <br>    pInfo-&gt;c1           = 0.0; <br>    pInfo-&gt;c2           = 0.0; <br>    pInfo-&gt;lc1          = 0L; <br>    pInfo-&gt;lc2          = 0L; <br>    pInfo-&gt;hBmpSaved    = NULL; <br>    pInfo-&gt;bSizeChng    = FALSE; <br>    pInfo-&gt;bMandel      = TRUE; <br>    pInfo-&gt;bSetDIBsToDevice = FALSE; <br>    pInfo-&gt;bFill        = FALSE; <br>    pInfo-&gt;hBrush       = NULL; <br>    pInfo-&gt;hQuitEvent   = NULL; <br>    pInfo-&gt;hCycleThrd   = NULL; <br>    pInfo-&gt;dwCycleThrdID = 0; <br>    pInfo-&gt;bClrCycle    = FALSE; <br>    pInfo-&gt;bFirstTime   = TRUE; <br>    pInfo-&gt;dwSuspend    = 0; <br>    pInfo-&gt;hBmpMono     = NULL; <br>    pInfo-&gt;bUseMono     = FALSE; <br>    pInfo-&gt;hPrtThrd     = NULL; <br>    pInfo-&gt;dwPrtThrdID  = 0; <br>    pInfo-&gt;hPal         = NULL; <br>    pInfo-&gt;hCyclePal    = NULL; <br>    pInfo-&gt;RleData.ulFiles  = 0; <br>    pInfo-&gt;RleData.ulFrames = 0; <br>    pInfo-&gt;bPlayRleCont = FALSE; <br>    pInfo-&gt;prghPen      = NULL; <br>    pInfo-&gt;iPen         = 0; <br>    pInfo-&gt;iPriority    = THREAD_PRIORITY_NORMAL; <br>    pInfo-&gt;bUseDIB      = FALSE; <br>    pInfo-&gt;bCoreHdr     = FALSE; <br> <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bResetGlobal <br>* <br>* Effects: Set (l) x/y From/To to their default values <br>*          Used for Julia set <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bResetGlobal(VOID) <br>{ <br>    xFrom  =  -2.0; <br>    xTo    =   2.0; <br>    yFrom  =   2.0; <br>    yTo    =  -2.0; <br>    lxFrom =  -16777216; <br>    lxTo   =   16777216; <br>    lyFrom =   16777216; <br>    lyTo   =  -16777216; <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* hBrCreateBrush <br>* <br>* Effects: Creates a brush with the specified RGB <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>HBRUSH hBrCreateBrush(HDC hDC, DWORD dwRGB) <br>{ <br>    HDC hdcMem; <br>    HBRUSH hbr; <br>    HBRUSH hbrOld; <br>    HBITMAP hbmPat; <br>    HBITMAP hbmOld; <br> <br>    hbr = CreateSolidBrush(dwRGB); <br>    hdcMem = CreateCompatibleDC(hDC); <br> <br>    // <br>    // Minimum size for a bitmap to be used in a fill pattern is 8x8 <br>    // <br>    hbmPat = CreateCompatibleBitmap(hDC, 8, 8); <br> <br>    hbmOld = SelectObject(hdcMem, hbmPat); <br>    hbrOld = SelectObject(hdcMem, hbr); <br>    PatBlt(hdcMem, 0, 0, 8, 8, PATCOPY); <br> <br>    // <br>    // Deselect hbmPat and hbr <br>    // <br>    SelectObject(hdcMem, hbmOld); <br>    SelectObject(hdcMem, hbrOld); <br> <br>    DeleteDC(hdcMem); <br>    DeleteObject(hbr); <br> <br>    hbr = CreatePatternBrush(hbmPat); <br> <br>    DeleteObject(hbmPat); <br> <br>    return hbr; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPrintBmp <br>* <br>* Effects: A Thread routine for printing bitmap <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bPrintBmp(PPRTDATA pPrtData) { <br>    HDC         hdcPrinter; <br>    int         iWidth, iHeight; <br> <br>#ifdef NEWPRTAPI <br>    DOCINFO     DocInfo; <br>#endif <br> <br>    if (pPrtData-&gt;bUseDefault) { <br>  hdcPrinter = CreateDC( "", gpszPrinterNames[pPrtData-&gt;index], <br> "", NULL); <br>    } else { <br>  hdcPrinter = CreateDC( "", gpszPrinterNames[pPrtData-&gt;index], <br> "", &amp;(pPrtData-&gt;DevMode)); <br>    } <br> <br>    if (!hdcPrinter) <br>    { <br>ExitThread(0); <br>return(FALSE); <br>    } <br> <br>    iWidth = GetDeviceCaps(hdcPrinter, HORZRES); <br>    iHeight = GetDeviceCaps(hdcPrinter, VERTRES); <br> <br>#ifdef NEWPRTAPI <br> <br>    memset(&amp;DocInfo, 0, sizeof(DOCINFO)); <br>    DocInfo.cbSize      = sizeof(DOCINFO); <br>    DocInfo.lpszDocName = pPrtData-&gt;info.CaptionBarText; <br>    DocInfo.lpszOutput   = NULL; <br>    StartDoc(hdcPrinter, &amp;DocInfo); <br>    StartPage(hdcPrinter); <br>    bDrawDIB(hdcPrinter, &amp;(pPrtData-&gt;info), 0, 0, iWidth, iHeight); <br>    EndPage(hdcPrinter); <br>    EndDoc(hdcPrinter); <br> <br>#else <br> <br>    Escape(hdcPrinter, STARTDOC, 20, "Mandelbrot", NULL); <br>    bDrawDIB(hdcPrinter, &amp;(pPrtData-&gt;info), 0, 0, iWidth, iHeight); <br>    Escape(hdcPrinter, NEWFRAME, 0, NULL, NULL); <br>    Escape(hdcPrinter, ENDDOC, 0, NULL, NULL); <br> <br>#endif <br> <br>    DeleteDC(hdcPrinter); <br>    ExitThread(0); <br>    return(TRUE); <br> <br>} <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* StoreRleFile <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bStoreRleFile(HDC hDC, PINFO pInfo, PSTR pszFileName) <br>{ <br>  BOOL                bSuccess; <br>  HANDLE              hFile, hMapFile; <br>  LPVOID              pMapFile; <br>  LPBITMAPINFOHEADER  pbmh; <br>  LPBITMAPINFO        pbmi; <br>  PBYTE               pjTmp, pjDIBits, pjRleBits; <br>  ULONG               sizBMI, sizImage, ulfSize; <br>  DWORD               dwOffBits; <br>  LONG                lScan; <br>  INT                 iNumClr; <br>  ULONG               ulFrames, ulFiles, ulOffset; <br>  PFILEINFO           pFileInfo; <br>  DWORD               dwFileSizeLow, dwFileSizeHigh; <br>  WORD                wBitCount; <br>  BOOL                bCoreHdr; <br> <br>  bSuccess = TRUE; <br> <br>  if ((hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, <br>  OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL)) == (HANDLE)-1) { <br>      bSuccess = FALSE; <br>      goto ErrExit1; <br>  } <br> <br>  dwFileSizeLow = GetFileSize(hFile, &amp;dwFileSizeHigh); <br>  if ((dwFileSizeLow == 0xFFFFFFFF) &amp;&amp; (GetLastError() != NO_ERROR)) { <br>      bSuccess = FALSE; <br>      goto ErrExit2; <br>  } <br> <br>  // <br>  // Create a map file of the opened file <br>  // <br>  if ((hMapFile = CreateFileMapping(hFile, NULL, <br>   PAGE_READONLY, 0, 0, NULL)) == (HANDLE)-1) { <br>      bSuccess = FALSE; <br>      goto ErrExit2; <br>  } <br> <br>  // <br>  // Map a view of the whole file <br>  // <br>  if ((pMapFile = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0)) == NULL) { <br>      bSuccess = FALSE; <br>      goto ErrExit3; <br>  } <br> <br>  ulFiles = pInfo-&gt;RleData.ulFiles; <br>  pFileInfo = &amp;(pInfo-&gt;RleData.rgFileInfo[ulFiles]); <br>  pFileInfo-&gt;hFile = hFile; <br>  pFileInfo-&gt;hMapFile = hMapFile; <br>  pFileInfo-&gt;lpvMapView = pMapFile; <br> <br>  ulFrames = pInfo-&gt;RleData.ulFrames; <br>  ulOffset = 0; <br> <br>  while (TRUE) { <br>    // <br>    // First check that it is a bitmap file <br>    // <br>    if (*((PWORD)pMapFile) != 0x4d42) {              // 'BM' <br>OutputDebugString ("This is not a DIB bitmap file!"); <br>bSuccess = FALSE; <br>goto ErrExit3; <br>    } <br>#ifdef DEBUG <br>    { <br>    static ULONG ulCnt=0; <br>    char buf[128]; <br> <br>    ulCnt++; <br>    wsprintf(buf, "ulCnt = %ld", ulCnt); <br>    OutputDebugString (buf); <br>    } <br>#endif <br>    // <br>    // Saving the bfSize field in the BITMAPFILEHEADER for incrementing to the <br>    // next frame.  bfSize does not start at DWORD boundary... <br>    // <br>    { <br>      PBYTE   pjTmp; <br>      FILEHDR fHdr, *pfHdr; <br>      ULONG   ulSiz; <br> <br>      pjTmp = (PBYTE)pMapFile+2; <br>      pfHdr = &amp;fHdr; <br> <br>      ulSiz = sizeof(FILEHDR); <br>      while (ulSiz--) { <br>  *(((PBYTE)pfHdr)++) = *(((PBYTE)pjTmp)++); <br>      } <br>      ulfSize = fHdr.bfSize; <br>      dwOffBits = fHdr.bfOffbits; <br>    } <br> <br>    // <br>    // advance pMapFile to point pass BITMAPFILEHEADER <br>    // <br>    //pMapFile = (PBYTE)pMapFile + sizeof(BITMAPFILEHEADER); <br> <br>    // <br>    // Since the file header doesn't end on DWORD boundary... <br>    // <br>    pbmh = (LPBITMAPINFOHEADER)((PBYTE)pMapFile + sizeof(BITMAPFILEHEADER)); <br> <br>    { <br>BITMAPCOREHEADER bmch, *pbmch; <br>BITMAPINFOHEADER bmih, *pbmih; <br>PBYTE            pjTmp; <br>ULONG            ulSiz; <br> <br>pbmch = &amp;bmch; <br>pbmih = &amp;bmih; <br> <br>pjTmp = (PBYTE)pbmh; <br>ulSiz = sizeof(BITMAPCOREHEADER); <br>while (ulSiz--) { <br>    *(((PBYTE)pbmch)++) = *(((PBYTE)pjTmp)++); <br>} <br> <br>pjTmp = (PBYTE)pbmh; <br>ulSiz = sizeof(BITMAPINFOHEADER); <br>while (ulSiz--) { <br>    *(((PBYTE)pbmih)++) = *(((PBYTE)pjTmp)++); <br>} <br> <br>// <br>// Use the size to determine if it is a BitmapCoreHeader or <br>// BitmapInfoHeader <br>// <br>if (bmch.bcSize == sizeof(BITMAPCOREHEADER)) <br>{ <br>    wBitCount = bmch.bcBitCount; <br>    iNumClr = ((wBitCount == 24) ? 0 : (1 &lt;&lt; wBitCount)); <br>    sizBMI = sizeof(BITMAPCOREHEADER)+sizeof(RGBTRIPLE)*iNumClr; <br>    bCoreHdr = TRUE; <br>} <br>else            // BITMAPINFOHEADER <br>{ <br>    wBitCount = bmih.biBitCount; <br>    switch (wBitCount) { <br>case 16: <br>case 32: <br>    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(DWORD)*3; <br>    break; <br>case 24: <br>    sizBMI = sizeof(BITMAPINFOHEADER); <br>    break; <br>default: <br>    iNumClr = (1 &lt;&lt; wBitCount); <br>    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*iNumClr; <br>    break; <br>    } <br>    bCoreHdr = FALSE; <br>} <br>    } <br> <br>    if ((pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED,sizBMI)) == NULL) { <br>bSuccess = FALSE; <br>goto ErrExit3; <br>    } <br> <br>    // <br>    // Make sure we pass in a DWORD aligned BitmapInfo to CreateDIBitmap <br>    // Otherwise, exception on the MIPS platform <br>    // CR!!!  Equivalent to memcpy <br>    // <br>    pjTmp = (PBYTE)pbmi; <br> <br>    while(sizBMI--) <br>    { <br>*(((PBYTE)pjTmp)++) = *(((PBYTE)pbmh)++); <br>    } <br> <br>    // <br>    // assuming CreateDIBitmap() is doing a byte fetch... <br>    // <br>    pjDIBits = (PBYTE)pMapFile + dwOffBits; <br> <br>    if (pbmi-&gt;bmiHeader.biCompression == BI_RGB) <br>    { <br>    // <br>    // Converting to RLE bits... <br>    // <br> <br>OutputDebugString ("Converting to RLE format!"); <br>lScan = pbmi-&gt;bmiHeader.biHeight; <br>sizImage = pbmi-&gt;bmiHeader.biSizeImage; <br> <br>// <br>// select the palette into the DC first... <br>// <br>bSelectDIBPal(hDC, pInfo, pbmi, bCoreHdr); <br>if ((pInfo-&gt;hBmpSaved = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)pbmi, <br>    CBM_INIT, pjDIBits, pbmi, DIB_RGB_COLORS)) == NULL) { <br>    bSuccess = FALSE; <br>    goto ErrExit4; <br>} <br> <br>// We want to retrieve the RLE format... <br>pbmi-&gt;bmiHeader.biCompression = ((wBitCount==4) ? BI_RLE4 : BI_RLE8); <br> <br>pbmi-&gt;bmiHeader.biSizeImage = 0; <br>pbmi-&gt;bmiHeader.biXPelsPerMeter = 0; <br>pbmi-&gt;bmiHeader.biYPelsPerMeter = 0; <br>pbmi-&gt;bmiHeader.biClrUsed = 0; <br>pbmi-&gt;bmiHeader.biClrImportant = 0; <br> <br>if (GetDIBits(hDC, pInfo-&gt;hBmpSaved, 0, lScan, NULL, pbmi, <br>    DIB_RGB_COLORS) == 0) { <br>     OutputDebugString ("Not all scans are converted!"); <br>     bSuccess = FALSE; <br>     goto ErrExit4; <br>} <br> <br>if (pbmi-&gt;bmiHeader.biSizeImage == 0) { <br>    if (sizImage == 0) { <br>OutputDebugString ("biSizeImage == 0!"); <br>bSuccess = FALSE; <br>goto ErrExit4; <br>    } <br>    OutputDebugString ("Engine returns zero image size, making one up!"); <br>    sizImage = (sizImage *3)/2; <br>} else { <br>    sizImage = pbmi-&gt;bmiHeader.biSizeImage; <br>} <br> <br>if ((pjRleBits = (PBYTE) LocalAlloc(LMEM_FIXED, sizImage)) == NULL) { <br>     bSuccess = FALSE; <br>     goto ErrExit4; <br>} <br> <br>pbmi-&gt;bmiHeader.biSizeImage = sizImage; <br>if (GetDIBits(hDC, pInfo-&gt;hBmpSaved, 0, lScan, pjRleBits, pbmi, <br>    DIB_RGB_COLORS) &lt; lScan) { <br>     bSuccess = FALSE; <br>     goto ErrExit5; <br>} <br> <br>SetDIBitsToDevice(hDC, 0, 0, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight, <br>      0, 0, 0, lScan, pjRleBits, pbmi, DIB_RGB_COLORS); <br> <br>pInfo-&gt;RleData.rgpjFrame[ulFrames] = pjRleBits; <br>    } else { <br>bSelectDIBPal(hDC, pInfo, pbmi, bCoreHdr); <br>lScan = pbmi-&gt;bmiHeader.biHeight; <br>if (bCoreHdr) { <br>   lScan = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcHeight; <br>   SetDIBitsToDevice(hDC, 0, 0, ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcWidth, ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcHeight, <br>      0, 0, 0, lScan, pjDIBits, pbmi, DIB_RGB_COLORS); <br>} else { <br>   lScan = pbmi-&gt;bmiHeader.biHeight; <br>   SetDIBitsToDevice(hDC, 0, 0, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight, <br>      0, 0, 0, lScan, pjDIBits, pbmi, DIB_RGB_COLORS); <br>} <br>pInfo-&gt;RleData.rgpjFrame[ulFrames] = pjDIBits; <br>    } <br> <br>    pInfo-&gt;RleData.ulSize[ulFrames] = sizImage; <br>    pInfo-&gt;RleData.rgpbmi[ulFrames] = pbmi; <br> <br>    // <br>    // Go to next frame <br>    // <br>    pMapFile = (PBYTE)pMapFile + ulfSize; <br>    ulOffset += ulfSize; <br>    ulFrames++; <br> <br>    // <br>    // end condition <br>    // <br>    if (ulOffset &gt;= dwFileSizeLow) { <br>break; <br>    } <br> <br>  } <br> <br>    // <br>    // set pbmi to the very first bmi <br>    // <br>    pInfo-&gt;RleData.pbmi = pInfo-&gt;RleData.rgpbmi[0]; <br> <br>    pInfo-&gt;RleData.hPal = pInfo-&gt;hPal; <br>    pInfo-&gt;RleData.ulFrames = ulFrames; <br>    return (bSuccess); <br> <br>ErrExit5: <br>    LocalFree(pjRleBits); <br>ErrExit4: <br>    LocalFree(pbmi); <br>ErrExit3: <br>    CloseHandle(pFileInfo-&gt;hMapFile); <br>ErrExit2: <br>    CloseHandle(pFileInfo-&gt;hFile); <br>ErrExit1: <br>    return (bSuccess); <br> <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bSelectDIBPal <br>* <br>* Effects: Creates a logical palette from the DIB and select it into the DC <br>*          and realize the palette. Saving the hPal in the pInfo-&gt;hPal <br>* <br>* Warnings: Based on Windows NT DIB support.  If PM support 16,24,32 bpp <br>*           we need to modify this routine. <br>* <br>\**************************************************************************/ <br> <br>BOOL bSelectDIBPal(HDC hDC, PINFO pInfo, LPBITMAPINFO pbmi, BOOL bCoreHdr) <br>{ <br>  LOGPALETTE    *plogPal; <br>  UINT          uiSizPal; <br>  INT           i, iNumClr; <br>  WORD          wBitCount; <br> <br>  if (bCoreHdr) { <br>    wBitCount = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciHeader.bcBitCount; <br>  } else { <br>    wBitCount = pbmi-&gt;bmiHeader.biBitCount; <br>  } <br> <br>  switch (wBitCount) { <br>    case 16: <br>    case 24: <br>    case 32:                            // Does PM supports these? <br>return FALSE; <br>    default: <br>iNumClr = (1 &lt;&lt; wBitCount); <br>break; <br>  } <br> <br>  uiSizPal = sizeof(WORD)*2 + sizeof(PALETTEENTRY)*iNumClr; <br>  if ((plogPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED,uiSizPal)) == NULL) { <br>      pInfo-&gt;hPal = NULL; <br>      return FALSE; <br>  } <br> <br>  plogPal-&gt;palVersion = 0x300; <br>  plogPal-&gt;palNumEntries = (WORD) iNumClr; <br> <br>  if (bCoreHdr) { <br>    for (i=0; i&lt;iNumClr; i++) { <br>plogPal-&gt;palPalEntry[i].peRed   = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciColors[i].rgbtRed; <br>plogPal-&gt;palPalEntry[i].peGreen = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciColors[i].rgbtGreen; <br>plogPal-&gt;palPalEntry[i].peBlue  = ((LPBITMAPCOREINFO)pbmi)-&gt;bmciColors[i].rgbtBlue; <br>plogPal-&gt;palPalEntry[i].peFlags = PC_RESERVED; <br>    } <br>  } else { <br>    for (i=0; i&lt;iNumClr; i++) { <br>plogPal-&gt;palPalEntry[i].peRed   = pbmi-&gt;bmiColors[i].rgbRed; <br>plogPal-&gt;palPalEntry[i].peGreen = pbmi-&gt;bmiColors[i].rgbGreen; <br>plogPal-&gt;palPalEntry[i].peBlue  = pbmi-&gt;bmiColors[i].rgbBlue; <br>plogPal-&gt;palPalEntry[i].peFlags = PC_RESERVED; <br>    } <br>  } <br> <br>  DeleteObject(pInfo-&gt;hPal); <br>  pInfo-&gt;hPal = CreatePalette((LPLOGPALETTE)plogPal); <br>  if ((pInfo-&gt;hPal) == NULL) { <br>      return FALSE; <br>  } <br> <br>  if ((GetDeviceCaps(hDC, RASTERCAPS)) &amp; RC_PALETTE) { <br>    SelectPalette(hDC, pInfo-&gt;hPal, FALSE); <br>    RealizePalette(hDC); <br>  } <br> <br>  GlobalFree(plogPal); <br> <br>  return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bFreeRleFile <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bFreeRleFile(PINFO pInfo) <br>{ <br>    ULONG               ulFiles; <br>    ULONG               ulFrames; <br>    ULONG               i; <br>    PFILEINFO           pFileInfo; <br> <br>    ulFiles = pInfo-&gt;RleData.ulFiles; <br>    ulFrames = pInfo-&gt;RleData.ulFrames; <br> <br>    for (i = 0; i &lt; ulFrames; i++) { <br>LocalFree(pInfo-&gt;RleData.rgpjFrame[i]); <br>LocalFree(pInfo-&gt;RleData.rgpbmi[i]); <br>    } <br> <br>    for (i = 0; i &lt; ulFiles; i++) { <br>pFileInfo = &amp;(pInfo-&gt;RleData.rgFileInfo[i]); <br>CloseHandle(pFileInfo-&gt;hFile); <br>CloseHandle(pFileInfo-&gt;hMapFile); <br>UnmapViewOfFile(pFileInfo-&gt;lpvMapView); <br>    } <br> <br>    pInfo-&gt;RleData.ulFiles = 0; <br>    pInfo-&gt;RleData.ulFrames = 0; <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPlayRle <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bPlayRle(PINFO pInfo) <br>{ <br>    ULONG               ulFrames; <br>    ULONG               i; <br>    LPBITMAPINFO        pbmi; <br>    HDC                 hDC; <br>    HWND                hViewSurf; <br>    int                 ii; <br> <br>//    RECT                rc; <br> <br>    hDC = GetDC(hViewSurf=pInfo-&gt;hwnd); <br> <br>    SelectPalette(hDC, pInfo-&gt;RleData.hPal, FALSE); <br>    ii=RealizePalette(hDC); <br>    if (ii){ <br>UpdateColors (hDC); <br>    } <br> <br>    ulFrames = pInfo-&gt;RleData.ulFrames; <br> <br>    for (i = 0; i &lt; ulFrames; i++) { <br>pbmi = pInfo-&gt;RleData.rgpbmi[i]; <br>SetDIBitsToDevice(hDC, <br>  0, 0, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight, <br>  0, 0, 0, pbmi-&gt;bmiHeader.biHeight, <br>  pInfo-&gt;RleData.rgpjFrame[i], pbmi, DIB_RGB_COLORS); <br> <br>#if 0 <br>GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>StretchDIBits(hDC, <br>       0, 0, rc.right, rc.bottom, <br>       0, 0, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight, <br>       (LPSTR)pInfo-&gt;RleData.rgpjFrame[i], pbmi, DIB_RGB_COLORS, <br>       SRCCOPY); <br>#endif <br>    } <br> <br>    ReleaseDC(hViewSurf, hDC); <br> <br>    return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bSaveRleFile <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bSaveRleFile(HDC hDC, PINFO pInfo, PSTR pszFileName) <br>{ <br>    int                 hFile; <br>    OFSTRUCT            ofReOpenBuff; <br>    BOOL                bSuccess; <br>    BITMAPFILEHEADER    bfh; <br>    ULONG               ulFrames; <br>    ULONG               i; <br>    LPBITMAPINFO        pbmi; <br>    ULONG               ulNumClr; <br>    ULONG               ulSize; <br> <br>    bSuccess = TRUE; <br>    ulFrames = pInfo-&gt;RleData.ulFrames; <br> <br>    if (ulFrames == 0) { <br>MessageBox(GetFocus(), GetStringRes (IDS_NO_RLE_TO_SAVE), <br>           NULL, MB_OK); <br>return FALSE; <br>    } <br> <br>    // Let's open the file and get ready for writing <br>    if ((hFile = OpenFile(pszFileName, (LPOFSTRUCT)&amp;ofReOpenBuff, <br> OF_CREATE | OF_WRITE)) == -1) { <br>OutputDebugString ("Failed in OpenFile!"); <br>return FALSE; <br>    } <br> <br>    for (i = 0; i &lt; ulFrames; i++) { <br> <br>pbmi = pInfo-&gt;RleData.rgpbmi[i]; <br> <br>switch(pbmi-&gt;bmiHeader.biBitCount) { <br>    case 24: <br>ulSize = 0; <br>break; <br>    case 16: <br>    case 32: <br>ulSize = sizeof(DWORD)*3; <br>break; <br>    default: <br>ulNumClr = 1&lt;&lt;pbmi-&gt;bmiHeader.biBitCount; <br>ulSize = sizeof(RGBQUAD)*ulNumClr; <br>break; <br>} <br>#if 0 <br>ulNumClr = ((pbmi-&gt;bmiHeader.biBitCount == 24) <br>       ? 0 <br>       : (1&lt;&lt;pbmi-&gt;bmiHeader.biBitCount)); </code></pre>
<p>
</p>
<pre><code>#endif <br>// fill in the info for the BitmapFileHeader <br>bfh.bfType    = 0x4D42;                            // 'BM' <br>bfh.bfOffBits = sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+ <br>ulSize; <br>//sizeof(RGBQUAD)*ulNumClr; <br>bfh.bfSize    = bfh.bfOffBits + pbmi-&gt;bmiHeader.biSizeImage; <br>bfh.bfReserved1 = <br>bfh.bfReserved2 = 0; <br> <br>// Write out the file header now <br>if (_lwrite(hFile, (LPSTR)&amp;bfh, sizeof(BITMAPFILEHEADER)) == -1) { <br>    bSuccess = FALSE; <br>    goto ErrExit1; <br>} <br> <br>// Now write out the BitmapInfoHeader and color table, if any <br>if (_lwrite(hFile, (LPSTR)pbmi, sizeof(BITMAPINFOHEADER) + <br>ulSize) == -1) { <br>//sizeof(RGBQUAD)*ulNumClr) == -1) { <br>    bSuccess = FALSE; <br>    goto ErrExit1; <br>} <br> <br>// write the bits also <br>if (_lwrite(hFile, (LPSTR)pInfo-&gt;RleData.rgpjFrame[i], <br>   pbmi-&gt;bmiHeader.biSizeImage) == -1) { <br>    bSuccess = FALSE; <br>    goto ErrExit1; <br>} <br> <br>    } <br> <br>ErrExit1: <br>    _lclose(hFile); <br>    return bSuccess; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPlayRleCont <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bPlayRleCont(HDC hDC, PINFO pInfo) <br>{ <br>    BOOL    bQuit; <br>    MSG     msg; <br>    int     ii; <br> <br>    bQuit = FALSE; <br> <br>    SelectPalette(hDC, pInfo-&gt;RleData.hPal, FALSE); <br>    ii=RealizePalette(hDC); <br>    if (ii){ <br>UpdateColors (hDC); <br>    } <br> <br>    while (TRUE &amp;&amp; !bQuit) { <br> <br>if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br> <br>    if ((msg.message == WM_QUIT) || (msg.message == WM_CLOSE) || <br>((msg.message == WM_SYSCOMMAND) &amp;&amp; (msg.wParam == SC_CLOSE))) { <br>bQuit = TRUE; <br>PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam); <br>    } else { <br>if (!TranslateAccelerator(msg.hwnd, ghAccel, &amp;msg)) { <br>    TranslateMessage(&amp;msg); <br>    DispatchMessage(&amp;msg); <br>} <br>   } <br>} <br> <br>if (!pInfo-&gt;bPlayRleCont) { <br>    bQuit = TRUE; <br>} <br> <br>if (!bQuit) { <br>    bPlayRle(pInfo); <br>} <br> <br>    } <br>    return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bPlayRleCont2 <br>* <br>* Effects: <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>BOOL bPlayRleCont2(PINFO pInfo) <br>{ <br>    HDC             hDC; <br>    HWND            hViewSurf; <br>    DWORD           dwWait; <br>    BOOL            bQuit; <br>    int             ii; <br> <br>    hDC = GetDC(hViewSurf=pInfo-&gt;hwnd); <br> <br>    SelectPalette(hDC, pInfo-&gt;RleData.hPal, FALSE); <br>    ii=RealizePalette(hDC); <br>    if (ii){ <br>UpdateColors (hDC); <br>    } <br> <br>    bQuit = FALSE; <br>    while (TRUE) { <br>// <br>// If parent gets a WM_CLOSE, we will return <br>// <br>dwWait = WaitForSingleObject(pInfo-&gt;hQuitEvent, 0); <br>if (dwWait == WAIT_TIMEOUT) { <br>MessageBox(ghwndMain, <br>           GetStringRes (IDS_PLAY_THREAD_END), <br>           GetStringRes (IDS_PLAY_THREAD), <br>           MB_OK); <br>    break; <br>} <br> <br>if (!pInfo-&gt;bPlayRleCont) { <br>    bQuit = TRUE; <br>} <br> <br>if (!bQuit) <br>    bPlayRle(pInfo); <br>    } <br> <br>    ReleaseDC(hViewSurf, hDC); <br> <br>    ExitThread(0); <br>    return TRUE; <br> <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* DIBfromDDB <br>* <br>* Effects:  Call GetDIBits to retrieve the DIB info from DDB <br>* <br>* Warnings: <br>* <br>\**************************************************************************/ <br> <br>HBITMAP DIBfromDDB(HDC hDC, HBITMAP hBmp, PINFO pInfo) <br>{ <br>    LPBITMAPINFO        pbmi; <br>    HBITMAP             hDIB; <br>    INT                 iBitCount, iNumClr; <br>    BITMAP              bm; <br>    DWORD               sizImage; <br>    PBYTE               pjBits; <br>    ULONG               sizBMI; <br>    LONG                lScan; <br> <br>    iBitCount = GetDeviceCaps(hDC, BITSPIXEL); <br>    switch (iBitCount) { <br>case 16: <br>case 32: <br>    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(DWORD)*3; <br>    break; <br>case 24: <br>    sizBMI = sizeof(BITMAPINFOHEADER); <br>    break; <br>default: <br>    iNumClr = (1 &lt;&lt; iBitCount); <br>    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*iNumClr; <br>    break; <br>    } <br> <br>    if ((pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED,sizBMI)) == NULL) { <br>goto ErrExit1; <br>    } <br> <br>    pbmi-&gt;bmiHeader.biSize = 0x28;              // GDI need this to work <br>    pbmi-&gt;bmiHeader.biBitCount = 0;             // don't get the color table <br>    pbmi-&gt;bmiHeader.biCompression = BI_RGB; <br>    pbmi-&gt;bmiHeader.biSizeImage = 0; <br>    pbmi-&gt;bmiHeader.biXPelsPerMeter = 0; <br>    pbmi-&gt;bmiHeader.biYPelsPerMeter = 0; <br>    pbmi-&gt;bmiHeader.biClrUsed = 0; <br>    pbmi-&gt;bmiHeader.biClrImportant = 0; <br> <br>    GetObject(hBmp, sizeof(BITMAP), &amp;bm); <br> <br>    // <br>    // Important!  Select the correct palette corresponding to the DDB <br>    // <br>    SelectPalette(hDC, pInfo-&gt;hPal, FALSE); <br>    if (GetDIBits(hDC, hBmp, 0, bm.bmHeight, NULL, pbmi, <br>DIB_RGB_COLORS) == 0) { <br> goto ErrExit2; <br>    } <br> <br>    sizImage = pbmi-&gt;bmiHeader.biSizeImage; <br>    if (sizImage == 0) { <br>goto ErrExit2; <br>    } <br> <br>    if ((pjBits = (PBYTE) LocalAlloc(LMEM_FIXED, sizImage)) == NULL) { <br> goto ErrExit2; <br>    } <br> <br>    lScan = pbmi-&gt;bmiHeader.biHeight; <br> <br>    if (GetDIBits(hDC, pInfo-&gt;hBmpSaved, 0, lScan, pjBits, pbmi, <br>DIB_RGB_COLORS) &lt; lScan) { <br> goto ErrExit3; <br>    } <br> <br>    // <br>    // Saving the DIB...free memory when the windows is closed. <br>    // <br>    pInfo-&gt;RleData.rgpjFrame[0] = pjBits; <br>    pInfo-&gt;RleData.rgpbmi[0]    = pbmi; <br>    pInfo-&gt;RleData.pbmi         = (PBITMAPINFO) &amp;(pInfo-&gt;RleData.rgpbmi[0]); <br>    pInfo-&gt;RleData.ulFrames     = 1; <br>    pInfo-&gt;RleData.ulFiles      = 1; <br> <br>    // set flag to use original DIB as source for blting so HT can be done <br>    pInfo-&gt;bUseDIB = TRUE; <br> <br>    pInfo-&gt;bCoreHdr = FALSE; <br> <br>    // hDIB = CreateDIBitmap(hDC, NULL, CBM_INIT, pjBits, pbmi, DIB_RGB_COLORS); <br>    hDIB = CreateDIBSection(hDC, pbmi, DIB_RGB_COLORS, &amp;pjBits, NULL, 0); <br> <br>    return hDIB; <br> <br>ErrExit3: <br>    LocalFree(pjBits); <br>ErrExit2: <br>    LocalFree(pbmi); <br>ErrExit1: <br>    return ((HBITMAP)NULL); <br>} <br> <br> <br>//--------------------------------------------------------------------------- <br>// <br>// FUNCTION:    GetStringRes (int id INPUT ONLY) <br>// <br>// COMMENTS:    Load the resource string with the ID given, and return a <br>//              pointer to it.  Notice that the buffer is common memory so <br>//              the string must be used before this call is made a second time. <br>// <br>//--------------------------------------------------------------------------- <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
