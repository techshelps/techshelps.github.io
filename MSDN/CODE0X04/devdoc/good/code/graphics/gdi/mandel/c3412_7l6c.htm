<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIBMP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3414"></a>DIBMP.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: dibmp.c <br>* <br>* Contains functions that manipulate the DIB color <br>* <br>* Copyright 1993 - 1998 Microsoft Corporation <br>* <br>* These functions will be called from the ChildWndProc() as it processes <br>* the corresponding WM_COMMAND message for changing the color of the bitmap. <br>* <br>* iCreatePenFrPal() is called by InitializeApp() for creating pens based on <br>* either system or custom palette. <br>* <br>* Dependencies: <br>*       none <br>* <br>\**************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "julia.h" <br>#include "dibmp.h" <br> <br>#define CYCLETHRD <br> <br>//#define DEBUG <br> <br>#ifndef DEBUG <br>   #undef OutputDebugString <br>   #define OutputDebugString(LPCSTR) <br>#endif <br> <br>extern HPALETTE        ghPal, ghPalOld; <br>extern HWND ghwndMain; <br>extern HWND ghwndClient; <br>extern HANDLE hQuitEvent; <br>extern char   gtext[256]; <br>extern HANDLE ghAccel; <br>BOOL bValidMode(INT); <br>BOOL bColor2BW(PBITMAPINFO); <br>BOOL bChangeDIBColor(HDC, PINFO, INT); <br>BOOL bColorShift(PBITMAPINFO); <br>BOOL bColorReplace(PBITMAPINFO); <br>BOOL bColorCycle(HDC, RECT, PBYTE, PBITMAPINFO, PINFO); <br>BOOL bCycle(HWND); <br>BOOL bColor2Mono(HDC, PINFO, PBITMAPINFO); <br>INT  iCreatePenFrPal(HDC, PVOID *, INT, HPALETTE *); <br>HPALETTE CopyPalette(HPALETTE); <br>extern PINFO pGetInfoData(HWND); <br>extern BOOL bReleaseInfoData(HWND); <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bChangeDIBColor <br>* <br>* Effects: Main entry point for the color changing operations.  It <br>*          1. validates the operation <br>*          2. retrieves the bitmap info from the graphics engine <br>*          3. dispatches the call to the right function <br>*          4. saves the resulting bitmap <br>*          5. updates the screen <br>\**************************************************************************/ <br>BOOL bChangeDIBColor(HDC hDC, PINFO pInfo, INT iMode) <br>{ <br>    BOOL                 bSuccess; <br>    HBITMAP              hTmpBmp, hBmpOld; <br>    PBITMAPINFO          pbmi; <br>    PBYTE                pBits; <br>    BITMAPINFO           bmi; <br>    PBYTE                pjTmp, pjTmpBmi; <br>    ULONG                sizBMI; <br>    RECT                 rc; <br>    BOOL                 bCycle; <br> <br> <br>    bSuccess = TRUE; <br>    if (!pInfo-&gt;hBmpSaved)  <br>{ <br>        MessageBox(ghwndMain, GetStringRes(IDS_NO_BITMAP), NULL, MB_OK); <br>        return FALSE; <br>    } <br> <br>    if (!bValidMode(iMode))  <br>{ <br>        OutputDebugString ("bChangeDIBColor: invalid mode!"); <br>        return FALSE; <br>    } <br> <br>    if (pInfo-&gt;hPal) { <br>        HPALETTE hPalOld; <br>        int     ii; <br> <br>        hPalOld = SelectPalette(hDC, pInfo-&gt;hPal, FALSE); <br>        ii = RealizePalette(hDC); <br> <br>        if (ii){ <br>            UpdateColors (hDC); <br>        } <br> <br>    } <br> <br>    // <br>    // Let the graphics engine to retrieve the dimension of the bitmap for us <br>    // GetDIBits uses the size to determine if it's BITMAPCOREINFO or BITMAPINFO <br>    // if BitCount != 0, color table will be retrieved <br>    // <br>    bmi.bmiHeader.biSize = 0x28;              // GDI need this to work <br>    bmi.bmiHeader.biBitCount = 0;             // don't get the color table <br>    if ((GetDIBits(hDC, pInfo-&gt;hBmpSaved, 0, 0, (LPSTR)NULL, &amp;bmi, DIB_RGB_COLORS)) == 0)  <br>{ <br>        OutputDebugString ("GetDIBits failed!"); <br>        return FALSE; <br>    } <br> <br>    // <br>    // Now that we know the size of the image, alloc enough memory to retrieve <br>    // the actual bits <br>    // <br>    if ((pBits = (PBYTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>                bmi.bmiHeader.biSizeImage)) == NULL)  <br>{ <br>        return FALSE; <br>    } <br> <br>    // <br>    // Note: 24 bits per pixel has no color table.  So, we don't have to <br>    // allocate memory for retrieving that.  Otherwise, we do. <br>    // <br>    pbmi = &amp;bmi;                                      // assume no color table <br>    if (bmi.bmiHeader.biBitCount != 24) {             // has color table <br>        sizBMI = sizeof(BITMAPINFO)+sizeof(RGBQUAD)*(1&lt;&lt;bmi.bmiHeader.biBitCount); <br>        // <br>        // I need more memory for the color table <br>        // <br>        if ((pbmi = (PBITMAPINFO)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizBMI )) == NULL)  <br>{ <br>            bSuccess = FALSE; <br>            goto ErrExit1; <br>        } <br> <br>        // <br>        // Now that we've a bigger chunk of memory, let's copy the Bitmap <br>        // info header data over <br>        // <br>        pjTmp = (PBYTE)pbmi; <br>        pjTmpBmi = (PBYTE)&amp;bmi; <br>        sizBMI = sizeof(BITMAPINFOHEADER); <br> <br>        while(sizBMI--) <br>        { <br>            *(((PBYTE)pjTmp)++) = *((pjTmpBmi)++); <br>        } <br> <br>    } <br> <br>    // <br>    // Bitmap can't be selected into a DC when calling GetDIBits <br>    // Assume that the hDC is the DC where the bitmap would have been selected <br>    // if indeed it has been selected <br>    // <br>    if (hTmpBmp = CreateCompatibleBitmap(hDC, pbmi-&gt;bmiHeader.biWidth, pbmi-&gt;bmiHeader.biHeight)) { <br>        hBmpOld = SelectObject(hDC, hTmpBmp); <br>        if ((GetDIBits(hDC, pInfo-&gt;hBmpSaved, 0, pbmi-&gt;bmiHeader.biHeight, (LPSTR)pBits, pbmi, DIB_RGB_COLORS))==0) <br>{ <br>            bSuccess = FALSE; <br>            goto ErrExit4; <br>        } <br>    } else  <br>{ <br>        OutputDebugString ("Failed in creating bitmap!"); <br>        bSuccess = FALSE; <br>        goto ErrExit3; <br>    } <br> <br>    bCycle = FALSE; <br>    switch (iMode) { <br>        case MM_BW: <br>            if ((!bColor2Mono(hDC, pInfo, pbmi)) || <br>                (pInfo-&gt;hBmpMono == NULL))  <br>{ <br>                OutputDebugString ("Failed in Color2Mono!"); <br>                bSuccess = FALSE; <br>                goto ErrExit4; <br>            } <br>            pInfo-&gt;bUseMono = TRUE; <br>            break; <br>        case MM_SHIFT: <br> <br>            if (!bColorShift(pbmi))  <br>{ <br>                OutputDebugString ("Failed in ColorShift!"); <br>                bSuccess = FALSE; <br>                goto ErrExit4; <br>            } <br>            break; <br>        case MM_CUSTOM: <br>            bColorReplace(pbmi); <br>            break; <br> <br>        case MM_CYCLE: <br>            bCycle = TRUE; <br>            break; <br> <br>        default: <br>            bSuccess = FALSE; <br>            break; <br>    } <br> <br>    if (SetDIBits(hDC, pInfo-&gt;hBmpSaved, 0, pbmi-&gt;bmiHeader.biHeight, (LPSTR)pBits, <br>            pbmi, DIB_RGB_COLORS) == 0)  <br>{ <br>        bSuccess = FALSE; <br>        goto ErrExit4; <br>    } <br> <br>    if (bCycle) <br>        pInfo-&gt;bSetDIBsToDevice = TRUE; <br> <br>#if 0 <br>    if (pInfo-&gt;bSetDIBsToDevice &amp;&amp; !pInfo-&gt;bUseMono) { <br>        //GetWindowRect(pInfo-&gt;hwnd, &amp;rc); <br>        GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>        //SetMapMode(hDC, MM_TEXT); <br> <br>        //if (SetDIBitsToDevice(hDC, 0, 0, rc.right-rc.left, rc.bottom-rc.top, <br>        //     0, 0, 0, pbmi-&gt;bmiHeader.biHeight, (LPSTR)pBits, pbmi, DIB_RGB_COLORS) == 0) { <br>        //    MessageBox(ghwndMain, "Failed in SetDIBitsToDevice!", "Error", MB_OK); <br>//    MessageBox(ghwndMain, "SetDIBitsToDevice    G   [              !", " G   [", MB_OK); <br>        //    bSuccess = FALSE; <br>        //    goto ErrExit4; <br>        //} <br>    } else  <br>{ <br>#endif <br>        InvalidateRect(pInfo-&gt;hwnd, NULL, FALSE); <br>//  } <br> <br>    if (bCycle) { <br>        // <br>        // This is commented out because I don't want the system colors <br>        // be affected by color cycling <br>        // <br>        //SetSystemPaletteUse(hDC, SYSPAL_NOSTATIC); <br>        bColorCycle(hDC, rc, pBits, pbmi, pInfo); <br>        //SetSystemPaletteUse(hDC, SYSPAL_STATIC); <br>    } <br> <br>ErrExit4: <br>    SelectObject(hDC, hBmpOld); <br>    DeleteObject(hTmpBmp); <br>ErrExit3: <br>    GlobalFree(pbmi); <br>ErrExit1: <br>    GlobalFree(pBits); <br>    return bSuccess; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bValidMode <br>* <br>* Effects: validates the change mode for ChangeDIBColor function <br>*          returns TRUE if mode is valid.  Otherwise, FALSE <br>\**************************************************************************/ <br>BOOL bValidMode(INT iMode) <br>{ <br>    if ((iMode == MM_BW)     || (iMode == MM_SHIFT) || <br>        (iMode == MM_CUSTOM) || (iMode == MM_CYCLE)) <br>        return TRUE; <br>    else <br>        return FALSE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bColor2BW <br>* <br>* Effects: changes the color table in the bitmapinfo to black and white <br>* <br>* Warnings: doesn't check if pbmi is valid or not <br>\**************************************************************************/ <br>BOOL bColor2BW(PBITMAPINFO pbmi) <br>{ <br>    INT iEntry; <br> <br>    // <br>    // CR! What's the right behavior?  Maybe I should convert this to a <br>    // monochrome bitmap.  This will be very useful in MaskBlt(). <br>    // <br>    iEntry = 1&lt;&lt;pbmi-&gt;bmiHeader.biBitCount; <br>    while (--iEntry &gt;= 0) { <br>        if (iEntry &lt;= iEntry / 2) { <br>                pbmi-&gt;bmiColors[iEntry].rgbBlue     = 0x00; <br>                pbmi-&gt;bmiColors[iEntry].rgbGreen    = 0x00; <br>                pbmi-&gt;bmiColors[iEntry].rgbRed      = 0x00; <br>                pbmi-&gt;bmiColors[iEntry].rgbReserved = 0x00; <br>         } else { <br>                pbmi-&gt;bmiColors[iEntry].rgbBlue     = 0xFF; <br>                pbmi-&gt;bmiColors[iEntry].rgbGreen    = 0xFF; <br>                pbmi-&gt;bmiColors[iEntry].rgbRed      = 0xFF; <br>                pbmi-&gt;bmiColors[iEntry].rgbReserved = 0x00; <br>        } <br>    } <br>    return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bColorShift <br>* <br>* Effects: Shifting entries of the color table <br>* <br>\**************************************************************************/ <br> <br>BOOL bColorShift(PBITMAPINFO pbmi) <br>{ <br>    INT iEntry; <br>    RGBQUAD     Tmp; <br> <br>    iEntry = 1&lt;&lt;pbmi-&gt;bmiHeader.biBitCount; <br> <br>    Tmp.rgbBlue     = pbmi-&gt;bmiColors[iEntry-1].rgbBlue; <br>    Tmp.rgbGreen    = pbmi-&gt;bmiColors[iEntry-1].rgbGreen; <br>    Tmp.rgbRed      = pbmi-&gt;bmiColors[iEntry-1].rgbRed; <br>    Tmp.rgbReserved = pbmi-&gt;bmiColors[iEntry-1].rgbReserved; <br> <br>    while (--iEntry &gt; 0) { <br>         pbmi-&gt;bmiColors[iEntry].rgbBlue     = <br>            pbmi-&gt;bmiColors[iEntry-1].rgbBlue; <br>         pbmi-&gt;bmiColors[iEntry].rgbGreen    = <br>            pbmi-&gt;bmiColors[iEntry-1].rgbGreen; <br>         pbmi-&gt;bmiColors[iEntry].rgbRed      = <br>            pbmi-&gt;bmiColors[iEntry-1].rgbRed; <br>         pbmi-&gt;bmiColors[iEntry].rgbReserved = <br>            pbmi-&gt;bmiColors[iEntry-1].rgbReserved; <br>    } <br>    pbmi-&gt;bmiColors[0].rgbBlue     = Tmp.rgbBlue; <br>    pbmi-&gt;bmiColors[0].rgbGreen    = Tmp.rgbGreen; <br>    pbmi-&gt;bmiColors[0].rgbRed      = Tmp.rgbRed; <br>    pbmi-&gt;bmiColors[0].rgbReserved = Tmp.rgbReserved; <br>    return TRUE; <br> <br>} <br> <br>BOOL bColorReplace(PBITMAPINFO pbmi) <br>{ <br>    return FALSE; <br>    UNREFERENCED_PARAMETER(pbmi); <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bColorCycle <br>* <br>* Effects:  Create a logical palette with a good spread of color <br>*           Animate the palette, shift the palette entries and animate <br>*           again for 256 times altogether. <br>*           This creates the color cycling effect. <br>* <br>* Warnings: Only works in device that support palette. <br>\**************************************************************************/ <br> <br>BOOL bColorCycle(HDC hDC, RECT rc, PBYTE pBits, PBITMAPINFO pbmi, PINFO pInfo) <br>{ <br>    INT             iEntry, i, iNumClr; <br>    PLOGPALETTE     plogPat; <br>    ULONG           ulSize; <br>    BOOL            bSuccess; <br>    HPALETTE        hPal, hPalOld; <br>    PALETTEENTRY    peTemp; <br> <br>#ifdef CYCLETHRD <br>    DWORD           dwWait; <br>#else <br>    MSG             msg; <br>#endif <br>    BOOL            bQuit; <br> <br>//UINT uRC; <br> <br>    bSuccess = TRUE; <br>    iEntry = 1&lt;&lt;pbmi-&gt;bmiHeader.biBitCount; <br> <br>    iNumClr = 236;          // 256 minus 20 reserved colors <br>    ulSize = sizeof(LOGPALETTE)+sizeof(PALETTEENTRY)*256; <br> <br>    if ((plogPat = (PLOGPALETTE) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, ulSize)) == NULL)  <br>{ <br>        bSuccess = FALSE; <br>        goto ErrExit1; <br>    } <br> <br>    plogPat-&gt;palVersion = 0x300; <br>    plogPat-&gt;palNumEntries = (WORD) 256; <br> <br>    { <br>    int     iFirst, iSecond, iInc; <br> <br>        iFirst = iNumClr/3; <br>        iSecond = iFirst * 2; <br>        iInc = (iNumClr &lt;= 256) ? 3 : 1; <br> <br>        for (i = 0; i &lt; iNumClr; i++) { <br>            if (i &lt; iFirst) { <br>                plogPat-&gt;palPalEntry[i+10].peBlue   = 255-(i+1)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peGreen  = 0; <br>                plogPat-&gt;palPalEntry[i+10].peRed    = (i+1)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peFlags  = PC_RESERVED; <br>                continue; <br>            } <br>            if (i &lt; iSecond) { <br>                plogPat-&gt;palPalEntry[i+10].peBlue   = 0; <br>                plogPat-&gt;palPalEntry[i+10].peGreen  = (i+1-iFirst)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peRed    = 255-(i+1-iFirst)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peFlags  = PC_RESERVED; <br>                continue; <br>            } <br>            plogPat-&gt;palPalEntry[i+10].peBlue   = (i+1-iSecond)*iInc; <br>            plogPat-&gt;palPalEntry[i+10].peGreen  = 255-(i+1-iSecond)*iInc; <br>            plogPat-&gt;palPalEntry[i+10].peRed    = 0; <br>            plogPat-&gt;palPalEntry[i+10].peFlags  = PC_RESERVED; <br>        } <br>    } <br> <br>    if ((hPal = CreatePalette(plogPat)) == (HPALETTE) NULL)  <br>{ <br>        bSuccess = FALSE; <br>        goto ErrExit2; <br>    } <br> <br>    pInfo-&gt;hCyclePal = hPal; <br> <br>    hPalOld = SelectPalette(hDC, hPal, FALSE); <br>    RealizePalette(hDC); <br> <br> <br>#ifndef CYCLETHRD <br> <br>    bQuit = FALSE; <br>    while (TRUE &amp;&amp; !bQuit) { <br> <br>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>            //sprintf( gtext,"msg = %lx\n", msg.message); <br>            //OutputDebugString( gtext ); <br> <br>            if ((msg.message == WM_QUIT) || (msg.message == WM_CLOSE) || <br>                ((msg.message == WM_SYSCOMMAND) &amp;&amp; (msg.wParam == SC_CLOSE))) { <br>                sprintf( gtext,"msg = %lx, wPram = %lx\n", msg.message, msg.wParam); <br>                OutputDebugString( gtext ); <br>                bQuit = TRUE; <br>                PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam); <br>            } else { <br>                if (!TranslateAccelerator( ghwndMain, ghAccel, &amp;msg) &amp;&amp; <br>                    !TranslateMDISysAccel(  ghwndClient, &amp;msg)          ) { <br>                    TranslateMessage(&amp;msg); <br>                    DispatchMessage(&amp;msg); <br>                } <br>           } <br>        } <br> <br>#else <br>    bQuit = FALSE; <br>    while (TRUE) { <br>        // <br>        // If parent gets a WM_CLOSE, we will return <br>        // <br>        dwWait = WaitForSingleObject(pInfo-&gt;hQuitEvent, 0); <br>        if (dwWait == WAIT_TIMEOUT)  <br>{ <br>            MessageBox(ghwndMain,  <br>       GetStringRes(IDS_CYCLE_THREAD_QUIT), <br>   GetStringRes (IDS_CYCLE_THREAD), MB_OK); <br>            break; <br>        } <br>#endif <br>        if (!pInfo-&gt;bClrCycle) { <br>            sprintf( gtext,"NOT to animate palette\n"); <br>            OutputDebugString( gtext ); <br>            bQuit = TRUE; <br>        } <br> <br>        if (!bQuit) { <br>            sprintf( gtext,"About to animate palette\n"); <br>            OutputDebugString( gtext ); <br> <br>            peTemp = plogPat-&gt;palPalEntry[10]; <br>            for (i = 0; i &lt; iNumClr; i++) { <br>                plogPat-&gt;palPalEntry[i+10] = plogPat-&gt;palPalEntry[i+10+1]; <br>            } <br>            plogPat-&gt;palPalEntry[i-1+10] = peTemp; <br> <br>            if (!AnimatePalette(hPal, 0, 256, plogPat-&gt;palPalEntry)) { <br>                sprintf( gtext,"Anmiate palette failed\n"); <br>                OutputDebugString( gtext ); <br>            } <br>            Sleep(50); <br> <br>// <br>// This is not needed anymore starting from build 475 14-Jun-1993 <br>// <br>#if 0 <br>            // <br>            // Not realizing stops color-cycling after moving back into <br>            // foreground <br>            // <br>            if ((uRC = RealizePalette(hDC)) == GDI_ERROR) { <br>                sprintf( gtext,"Realize palette failed\n"); <br>                OutputDebugString( gtext ); <br>            } <br> <br>            if (!UpdateColors(hDC)) { <br>                sprintf( gtext,"Update Colors failed\n"); <br>                OutputDebugString( gtext ); <br>            } <br>#endif <br>        } <br> <br>    } <br> <br>    SelectPalette(hDC, hPalOld, 0); <br>    DeleteObject(hPal); <br>ErrExit2: <br>    GlobalFree(plogPat); <br>ErrExit1: <br>    return bSuccess; <br> <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bCycle <br>* <br>* Effects: Wrapper for doing color cycling in a separate thread <br>*          Called from MM_CYCLE <br>* <br>* Warnings: presents problem when the MDI child is closed if this thread <br>*           is not done yet.  We will have to wait until DeleteDC is <br>*           fully functional. <br>\**************************************************************************/ <br>BOOL bCycle(HWND hwnd) <br>{ <br>    HDC     hDC; <br>    PINFO   pInfo; <br> <br>    if ((pInfo = pGetInfoData(hwnd)) == NULL) { <br>        return 0L; <br>    } <br> <br>    hDC = GetDC(pInfo-&gt;hwnd); <br>    bChangeDIBColor(hDC, pInfo, MM_CYCLE); <br>    ReleaseDC(pInfo-&gt;hwnd, hDC); <br> <br>    bReleaseInfoData(hwnd); <br> <br>    ExitThread(0); <br>    return TRUE; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bColor2Mono <br>* <br>* Effects: Create a monochrome bitmap out of the colored one <br>*          Using a different a source background clr every time it is called <br>*          Saving the Monochrome bitmap in pInfo <br>* <br>* Warnings: It's more straight forward to use GetDIBits than this but <br>*           that means some big changes to the bChangeDIBColor. <br>* <br>\**************************************************************************/ <br> <br>BOOL bColor2Mono(HDC hDC, PINFO pInfo, PBITMAPINFO pbmi) { <br>    HDC     hDCMemDest, hDCMemSrc; <br>    HBITMAP hOldBmpDest, hOldBmpSrc; <br>    INT     iWidth, iHeight, iEntry; <br>    static INT iCount=0; <br> <br> <br>    iWidth = pbmi-&gt;bmiHeader.biWidth; <br>    iHeight = pbmi-&gt;bmiHeader.biHeight; <br> <br>    if (pInfo-&gt;hBmpMono) <br>        DeleteObject(pInfo-&gt;hBmpMono); <br> <br>    pInfo-&gt;hBmpMono = CreateBitmap(iWidth, iHeight, pbmi-&gt;bmiHeader.biPlanes, 1, NULL); <br>    if (pInfo-&gt;hBmpMono == NULL) { <br>        return(FALSE); <br>    } <br> <br>    hDCMemDest = CreateCompatibleDC(hDC); <br>    hDCMemSrc  = CreateCompatibleDC(hDC); <br> <br>    if (pInfo-&gt;hPal) { <br>        SelectPalette(hDCMemSrc, pInfo-&gt;hPal, FALSE); <br>        RealizePalette(hDCMemSrc); <br>    } <br> <br>    iEntry = 1&lt;&lt;pbmi-&gt;bmiHeader.biBitCount; <br>    SetBkColor(hDCMemSrc, RGB( pbmi-&gt;bmiColors[iCount].rgbRed, <br>                               pbmi-&gt;bmiColors[iCount].rgbGreen, <br>                               pbmi-&gt;bmiColors[iCount].rgbBlue) ); <br>    //SetBkColor(hDCMemDest, RGB( 0, 0, 0)); <br>    //SetTextColor(hDCMemDest, RGB( 255, 255, 255)); <br> <br>    iCount++; <br>    if (iCount &gt;= iEntry) <br>        iCount = 0; <br> <br>    hOldBmpDest = SelectObject(hDCMemDest, pInfo-&gt;hBmpMono); <br>    hOldBmpSrc  = SelectObject(hDCMemSrc,  pInfo-&gt;hBmpSaved); <br>    BitBlt(hDCMemDest, 0, 0, iWidth, iHeight, hDCMemSrc, 0, 0, SRCCOPY); <br> <br>    pInfo-&gt;hBmpMono = SelectObject(hDCMemDest, hOldBmpDest); <br>    SelectObject(hDCMemSrc, hOldBmpSrc); <br> <br>    DeleteDC(hDCMemDest); <br>    DeleteDC(hDCMemSrc); <br> <br>    return(TRUE); <br> <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* iCreatePenFrPal <br>* <br>* Effects: Create an array of pens from palette. <br>*          If device supports palette, then first creates a logical palette <br>*          with a good spread of color. Then select the logical palette into <br>*          the DC. Create pen that corresponds to each palette entry. <br>*          If system does not support palette, then use the system palette. <br>* <br>*          prghPen pointer to an array of hPen <br>*                  If this is NULL, the required size of the array is <br>*                  returned. If this is not NULL, the array will be filled <br>*                  with hPens. <br>* <br>*          returns the number of hPens created. <br>* <br>\**************************************************************************/ <br>INT iCreatePenFrPal(HDC hDC, PVOID *prghPen, INT iWidth, HPALETTE *phPal) <br>{ <br>    INT             iNumClr, iResult, i, iEntry; <br>    PLOGPALETTE     plogPat; <br>    ULONG           ulSize; <br> <br>    iResult = 0; <br> <br>    if (!((GetDeviceCaps(hDC, RASTERCAPS)) &amp; RC_PALETTE)) { <br> <br>        if (iNumClr = GetSystemPaletteEntries(hDC, 0, 0, NULL)) { <br>            if (prghPen == NULL) { <br>                return (iNumClr); <br>            } <br> <br>            if (iWidth &lt; 0)  <br>{ <br>                MessageBox(GetFocus(), GetStringRes (IDS_IVALID_PEN_WIDTH), <br>   NULL, MB_OK); <br>                return 0L; <br>            } <br> <br>            for (i = 0; i &lt; iNumClr; i++) { <br>                prghPen[i] = <br>                     (PVOID) CreatePen(PS_SOLID, iWidth, PALETTEINDEX(i)); <br>                iResult = i; <br>#if 0 <br>                SelectObject(hDC, (HPEN)prghPen[i]); <br>                MoveToEx(hDC, i*iWidth, 0, NULL); <br>                LineTo(hDC, i*iWidth, 300); <br>#endif <br>            } <br>            return iResult; <br>        } <br> <br>        // GetPaletteEntries returns 0 <br>        iNumClr = 1 &lt;&lt; GetDeviceCaps(hDC, BITSPIXEL); <br> <br>        if (iNumClr &lt;= 16) { <br>            sprintf( gtext,"Assertion failed: iCreatePenFrPal() \n"); <br>            OutputDebugString( gtext); <br>            sprintf( gtext,"iNumClr &lt;= 16! iNumClr = %d\n", iNumClr); <br>            OutputDebugString( gtext); <br>            return (iNumClr); <br>        } <br> <br>        // Assuming at least 16 bit device <br>        // <br>        iNumClr = 768;      // COLORREF format: 0x00bbggrr r,g,b=[0,255] <br> <br>        if (prghPen == NULL) { <br>            return (iNumClr); <br>        } <br> <br>        if (iWidth &lt; 0)  <br>{ <br>            MessageBox(GetFocus(), GetStringRes(IDS_IVALID_PEN_WIDTH), <br>   NULL, MB_OK); <br>            return 0L; <br>        } <br> <br>        for (i = 0; i &lt; iNumClr; i++) { <br>            if (i &lt; 256) { <br>                prghPen[i] = <br>                    (PVOID) CreatePen(PS_SOLID, iWidth, RGB(i,0,255-i)); <br>                iResult = i; <br>#if 0 <br>                SelectObject(hDC, (HPEN)prghPen[i]); <br>                MoveToEx(hDC, i*iWidth, 0, NULL); <br>                LineTo(hDC, i*iWidth, 300); <br>#endif <br>                continue; <br>            } <br> <br>            if (i &lt; 512) { <br>                prghPen[i] = <br>                    (PVOID) CreatePen(PS_SOLID, iWidth, RGB(511-i,i-256,0)); <br>                iResult = i; <br>#if 0 <br>                SelectObject(hDC, (HPEN)prghPen[i]); <br>                MoveToEx(hDC, i*iWidth, 0, NULL); <br>                LineTo(hDC, i*iWidth, 300); <br>#endif <br>                continue; <br>            } <br> <br> <br>            prghPen[i] = <br>                (PVOID) CreatePen(PS_SOLID, iWidth, RGB(0,767-i,i-512)); <br>            iResult = i; <br>#if 0 <br>            SelectObject(hDC, (HPEN)prghPen[i]); <br>            MoveToEx(hDC, i*iWidth, 0, NULL); <br>            LineTo(hDC, i*iWidth, 300); <br>#endif <br>        } <br> <br>        return iResult; <br>    } <br> <br>    // <br>    // Palette managed device <br>    // <br>    iEntry = iNumClr = 1 &lt;&lt; GetDeviceCaps(hDC, BITSPIXEL); <br> <br>    if (iNumClr &gt; 256) { <br>        sprintf( gtext,"Assertion failed: iCreatePenFrPal() \n"); <br>        OutputDebugString( gtext); <br>        sprintf( gtext,"iNumClr &gt; 256! iNumClr = %d\n", iNumClr); <br>        OutputDebugString( gtext); <br>        iEntry=iNumClr = 256; <br>    } <br> <br>    ulSize = sizeof(LOGPALETTE)+sizeof(PALETTEENTRY)*iNumClr; <br> <br>    iNumClr -= GetDeviceCaps(hDC, NUMRESERVED); <br> <br>    if (prghPen == NULL) <br>        return iNumClr; <br> <br>    if ((plogPat = (PLOGPALETTE) GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, ulSize)) == NULL)  <br>{ <br>        goto ErrExit1; <br>    } <br> <br>    plogPat-&gt;palVersion = 0x300; <br>    plogPat-&gt;palNumEntries = (WORD) iEntry; <br> <br>    { <br>    int     iFirst, iSecond, iInc; <br> <br>        iFirst = iNumClr/3; <br>        iSecond = iFirst * 2; <br>        iInc = (iNumClr &lt;= 256) ? 3 : 1; <br> <br>        for (i = 0; i &lt; iNumClr; i++) { <br>            if (i &lt; iFirst) { <br>                plogPat-&gt;palPalEntry[i+10].peBlue   = 255-(i+1)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peGreen  = 0; <br>                plogPat-&gt;palPalEntry[i+10].peRed    = (i+1)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peFlags  = PC_RESERVED; <br>                continue; <br>            } <br>            if (i &lt; iSecond) { <br>                plogPat-&gt;palPalEntry[i+10].peBlue   = 0; <br>                plogPat-&gt;palPalEntry[i+10].peGreen  = (i+1-iFirst)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peRed    = 255-(i+1-iFirst)*iInc; <br>                plogPat-&gt;palPalEntry[i+10].peFlags  = PC_RESERVED; <br>                continue; <br>            } <br>            plogPat-&gt;palPalEntry[i+10].peBlue   = (i+1-iSecond)*iInc; <br>            plogPat-&gt;palPalEntry[i+10].peGreen  = 255-(i+1-iSecond)*iInc; <br>            plogPat-&gt;palPalEntry[i+10].peRed    = 0; <br>            plogPat-&gt;palPalEntry[i+10].peFlags  = PC_RESERVED; <br>        } <br>    } <br> <br>    DeleteObject(*phPal); <br> <br>    if ((*phPal = CreatePalette(plogPat)) == (HPALETTE) NULL)  <br>{ <br>        goto ErrExit2; <br>    } <br>    if (*phPal) { <br>       SelectPalette(hDC, *phPal, FALSE); <br>       RealizePalette(hDC); <br>    } <br> <br>    for (i = 0; i &lt; iNumClr; i++) { <br>        HPEN    hPen; <br> <br>        hPen = CreatePen(PS_SOLID, iWidth, PALETTEINDEX(i+10)); <br>        prghPen[i] = (PVOID) hPen; <br>        iResult = i; <br>#if 0 <br>        SelectObject(hDC, hPen); <br>        MoveToEx(hDC, i*iWidth, 0, NULL); <br>        LineTo(hDC, i*iWidth, 300); <br>#endif <br>    } <br> <br>ErrExit2: <br>    GlobalFree(plogPat); <br>ErrExit1: <br>    return iResult; <br> <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* HPALETTE CopyPalette <br>* <br>\**************************************************************************/ <br> <br>HPALETTE CopyPalette(HPALETTE hPalSrc) <br>{ <br>    PLOGPALETTE     plogPal; <br>    PBYTE           pjTmp; <br>    int             iNumEntries=0; <br>    HPALETTE        hPal; <br> <br>    if ((iNumEntries = GetPaletteEntries(hPalSrc, 0, iNumEntries, NULL)) == 0)  <br>{ <br>        OutputDebugString ("No entry in palette to copy!"); <br>        return (HPALETTE) NULL; <br>    } <br> <br>    if ((plogPal = (PLOGPALETTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, <br>            sizeof(DWORD) + sizeof(PALETTEENTRY)*iNumEntries )) == NULL)  <br>{ <br>        return (HPALETTE) NULL; <br>    } <br> <br>    plogPal-&gt;palVersion = 0x300; <br>    plogPal-&gt;palNumEntries = (WORD) iNumEntries; <br>    pjTmp = (PBYTE) plogPal; <br>    pjTmp += 8; <br>    GetPaletteEntries(hPalSrc, 0, iNumEntries, (PPALETTEENTRY)pjTmp); <br>    hPal = CreatePalette(plogPal); <br> <br>    GlobalFree(plogPal); <br> <br>    return hPal; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
