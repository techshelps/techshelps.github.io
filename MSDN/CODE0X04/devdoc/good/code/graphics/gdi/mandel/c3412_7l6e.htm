<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>JTYPES.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3416"></a>JTYPES.H</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: jtypes.h <br>* <br>* Contains the INFO structure and handy macros <br>* <br>* Created: 10-Jan-1992 13:21:01 <br>* Author: Petrus Wong <br>* <br>* Copyright 1993 - 1998 Microsoft Corporation <br>* <br>* The INFO structure is allocated dynmamically when the MDI child is <br>* created and freed when the window is about to be destroyed.  The pointer <br>* to this data structure is stored in the LONG user data window structure. <br>* This data structure stores the per-window's info. <br>* <br>* Dependencies: <br>* <br>*   #include windows.h <br>* <br>\**************************************************************************/ <br>// <br>// Handy macros for the transformations used in fractal generations <br>// <br>#define Xform(Pt, SrcFrom, SrcTo, DestFrom, DestTo) \ <br>         (((Pt-SrcFrom)/(SrcTo-SrcFrom)*(DestTo-DestFrom))+DestFrom) <br>#define Xform2(Pt, SrcFrom, SrcTo, DestFrom, DestTo) \ <br>         ((int) ((Pt-SrcFrom)/(SrcTo-SrcFrom)*(DestTo-DestFrom)+DestFrom)) <br>#define XformFix(Pt, SrcFrom, SrcTo, DestFrom, DestTo) \ <br>         (lMul(lDiv(Pt-SrcFrom,SrcTo-SrcFrom), DestTo-DestFrom)+DestFrom) <br> <br>#define SIZEOFCAPTIONTEXT20 <br>#define MAX_FRAME           800 <br>#define MAX_FILE            800 <br> <br>typedef struct _FileInfo{ <br>    HANDLE      hFile; <br>    HANDLE      hMapFile; <br>    LPVOID      lpvMapView; <br>} FILEINFO, *PFILEINFO; <br> <br>typedef struct _RLEDATA{ <br>    ULONG           ulFiles; <br>    ULONG           ulFrames; <br>    HPALETTE        hPal; <br>    LPBITMAPINFO    pbmi; <br>    FILEINFO        rgFileInfo[MAX_FILE]; <br>    PBYTE           rgpjFrame[MAX_FRAME]; <br>    ULONG           ulSize[MAX_FRAME]; <br>    PBITMAPINFO     rgpbmi[MAX_FRAME]; <br>} RLEDATA, *PRLEDATA; <br> <br>typedef struct _PerWndInfo { <br>    char    CaptionBarText[SIZEOFCAPTIONTEXT]; <br>    HWND    hwnd;               // hJulia or hView, the drawing surface <br>    HWND    hParent;            // ghwndClient, the client area of main frame <br>    HWND    hTextWnd;           // hTextWnd, the status window <br>    RECT    rcClient;           // hJulia &amp; hTextWnd's parent rc <br>    HDC     hdcClient;          // DC handle of client area of main frame <br>    HRGN    hRgnPath;           // Region handle for the drawing surface <br>    HANDLE  hThrd;              // handle to drawing thread or play thread <br>    HANDLE  hThrd0; <br>    BOOL    bDrawing;           // curently drawing? <br>    DWORD   dwThreadId;         // drawing thread or play thread ID <br>    DWORD   dwElapsed;          // elapsed time for the drawing operation <br>    double  xFrom;              // drawing range in floating points <br>    double  xTo;                // <br>    double  yFrom;              //         Floating Points <br>    double  yTo;                // <br>    double  c1;                 // C = c1 + i c2 where c1, c2 are reals <br>    double  c2;                 // the C value corresponding to the Julia set <br>    LONG    lxFrom;             // drawing range in fix points <br>    LONG    lxTo;               // <br>    LONG    lyFrom;             //         Fix Points <br>    LONG    lyTo;               // <br>    LONG    lc1;                // C = c1 + i c2 where c1, c2 are reals <br>    LONG    lc2;                // the C value corresponding to the Julia set <br>    HBITMAP hBmpSaved;          // saved bitmap for the drawing <br>    BOOL    bSizeChng;          //        not used <br>    BOOL    bMandel;            // Drawing is a Mandelbrot or Julia set? <br>    int     iIteration;         // number of computations done on each pixel <br>    int     iStep;              // drawn on every one, two or three line(s)? <br>    BOOL    bStretch;           // stretching bitmaps <br>    int     iStretchMode;       // stretching mode to use <br>    BOOL    bSetDIBsToDevice;   // SetDIBsToDevice reather than BitBlt? <br>    BOOL    bFill;              // FloodFill mode presently? <br>    HBRUSH  hBrush;             // handle to brush <br>    HANDLE  hQuitEvent;         // Event for quiting color cycling thread <br>    HANDLE  hCycleThrd;         // Color cycling thread <br>    DWORD   dwCycleThrdID;      // Color cycling thread ID <br>    BOOL    bClrCycle;          // For suspending and resuming color cycle thrd <br>    BOOL    bFirstTime;         // Creating color cycling thrd only once <br>    DWORD   dwSuspend;          // Store return result of suspend/resume cycle thrd <br>    HBITMAP hBmpMono;           // Monochrome bitmap <br>    BOOL    bUseMono;           // Display monochrome bitmap instead <br>    HANDLE  hPrtThrd;           // Print thread <br>    DWORD   dwPrtThrdID;        // Print thread ID <br>    HPALETTE    hPal;           // The palette used for the drawing <br>    HPALETTE    hHTPal;         // The halftone palette used for the drawing <br>    HPALETTE    hCyclePal; <br>    RLEDATA RleData;            // RLE data for RLE viewer <br>    BOOL    bPlayRleCont;       // Playing RLE continuously <br>    PVOID   *prghPen;           // Pointer to array of hPen <br>    INT     iPen;               // number of Pens <br>    INT     iPriority;          // thread priority <br>    BOOL    bUseDIB;            // Should we use the DIB for stretch? <br>    BOOL    bCoreHdr;           // used in bDrawDIB <br>} INFO, *PINFO; <br> <br>typedef struct _PrtData{ <br>    INFO        info; <br>    int         index; <br>    BOOL        bUseDefault; <br>    DEVMODE     DevMode; <br>} PRTDATA, *PPRTDATA; <br> <br>typedef struct _FileHdr{ <br>    DWORD       bfSize; <br>    WORD        bfReserved1; <br>    WORD        bfReserved2; <br>    DWORD       bfOffbits; <br>} FILEHDR; </code></pre>
<p>&nbsp;</p></body>
</HTML>
