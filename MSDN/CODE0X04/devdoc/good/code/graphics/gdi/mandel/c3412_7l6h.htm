<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOADBMP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3419"></a>LOADBMP.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: loadbmp.c <br>* <br>* Contains function that loads a bitmap file <br>* <br>* Created: 08-Jan-1992 11:06:37 <br>* <br>* Copyright 1993 - 1998 Microsoft Corporation <br>* <br>* Contains the main routine for loading a DI bitmap file. <br>* <br>* Dependencies: <br>* <br>*   (#defines) <br>*   (#includes) <br>*       #include &lt;windows.h&gt; <br>*       #include "jtypes.h" <br>* <br>\**************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include "julia.h" <br> <br>extern HWND ghwndMain; <br>BOOL bSelectDIBPal(HDC, PINFO, LPBITMAPINFO, BOOL); <br>BOOL bFreeRleFile(PINFO); <br>BOOL LoadBitmapFile(HDC, PINFO, PSTR); <br> <br>/******************************Public*Routine******************************\ <br>* <br>* LoadBitmapFile <br>* <br>* Effects:  Loads the bitmap from file and put into pInfo-&gt;hBmpSaved <br>* <br>* Warnings: pszFileName contains the full path <br>* <br>\**************************************************************************/ <br> <br>BOOL LoadBitmapFile(HDC hDC, PINFO pInfo, PSTR pszFileName) <br>{ <br>    BOOL            bSuccess; <br>    HANDLE          hFile, hMapFile; <br>    LPVOID          pMapFile; <br>    LPBITMAPINFOHEADER pbmh; <br>    LPBITMAPINFO    pbmi; <br>    PBYTE           pjTmp; <br>    ULONG           sizBMI; <br>    INT             iNumClr; <br>    BOOL            bCoreHdr; <br>    PFILEINFO       pFileInfo; <br> <br> <br>    bSuccess = TRUE; <br> <br>    if ((hFile = CreateFile(pszFileName, GENERIC_READ, FILE_SHARE_READ, NULL, <br>            OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL)) == (HANDLE)-1)  <br>{ <br>        OutputDebugString("Fail in file open"); <br>        bSuccess = FALSE; <br>        goto ErrExit1; <br>    } <br> <br>    // <br>    // Create a map file of the opened file <br>    // <br>    if ((hMapFile = CreateFileMapping(hFile, NULL, <br>                             PAGE_READONLY, 0, 0, NULL)) == (HANDLE)-1)  <br>{ <br>        OutputDebugString("Fail in creating map file"); <br>        bSuccess = FALSE; <br>        goto ErrExit2; <br> <br>    } <br> <br>    // <br>    // Map a view of the whole file <br>    // <br>    if ((pMapFile = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0)) == NULL)  <br>{ <br>        OutputDebugString("Fail in mapping view of the Map File object"); <br>        bSuccess = FALSE; <br>        goto ErrExit3; <br>    } <br> <br>    // <br>    // Saving the DIB file handle, etc in pInfo... <br>    // freeing existing objects, if any <br>    // <br>    bFreeRleFile(pInfo); <br>    pFileInfo = &amp;(pInfo-&gt;RleData.rgFileInfo[0]); <br>    pFileInfo-&gt;hFile      = hFile; <br>    pFileInfo-&gt;hMapFile   = hMapFile; <br>    pFileInfo-&gt;lpvMapView = pMapFile; <br> <br>    // <br>    // First check that it is a bitmap file <br>    // <br>    if (*((PWORD)pMapFile) != 0x4d42)  // 'BM' <br>{               <br>        MessageBox(ghwndMain,  <br>       GetStringRes (IDS_ERR_NOT_A_DIB), <br>   NULL, MB_OK); <br>        bSuccess = FALSE; <br>        goto ErrExit3; <br>    } <br> <br>    // <br>    // The file header doesn't end on DWORD boundary... <br>    // <br>    pbmh = (LPBITMAPINFOHEADER)((PBYTE)pMapFile + sizeof(BITMAPFILEHEADER)); <br> <br>    { <br>        BITMAPCOREHEADER bmch, *pbmch; <br>        BITMAPINFOHEADER bmih, *pbmih; <br>        PBYTE            pjTmp; <br>        ULONG            ulSiz; <br> <br>        pbmch = &amp;bmch; <br>        pbmih = &amp;bmih; <br> <br>        pjTmp = (PBYTE)pbmh; <br>        ulSiz = sizeof(BITMAPCOREHEADER); <br>        while (ulSiz--) { <br>            *(((PBYTE)pbmch)++) = *(((PBYTE)pjTmp)++); <br>        } <br> <br>        pjTmp = (PBYTE)pbmh; <br>        ulSiz = sizeof(BITMAPINFOHEADER); <br>        while (ulSiz--) { <br>            *(((PBYTE)pbmih)++) = *(((PBYTE)pjTmp)++); <br>        } <br> <br>        // <br>        // Use the size to determine if it is a BitmapCoreHeader or <br>        // BitmapInfoHeader <br>        // <br>        // Does PM supports 16 and 32 bpp? How? <br>        // <br>        if (bmch.bcSize == sizeof(BITMAPCOREHEADER)) <br>        { <br>            WORD wBitCount; <br> <br>            wBitCount = bmch.bcBitCount; <br>            iNumClr = ((wBitCount == 24) ? 0 : (1 &lt;&lt; wBitCount)); <br>            sizBMI = sizeof(BITMAPCOREHEADER)+sizeof(RGBTRIPLE)*iNumClr; <br>            bCoreHdr = TRUE; <br>        } <br>        else            // BITMAPINFOHEADER <br>        { <br>            WORD wBitCount; <br> <br>            wBitCount = bmih.biBitCount; <br>            switch (wBitCount) { <br>                case 16: <br>                case 32: <br>                    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(DWORD)*3; <br>                    break; <br>                case 24: <br>                    sizBMI = sizeof(BITMAPINFOHEADER); <br>                    break; <br>                default: <br>                    iNumClr = (1 &lt;&lt; wBitCount); <br>                    sizBMI = sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*iNumClr; <br>                    break; <br>            } <br>            bCoreHdr = FALSE; <br>        } <br> <br>    } <br> <br>    if ((pbmi = (LPBITMAPINFO) LocalAlloc(LMEM_FIXED,sizBMI)) == NULL)  <br>{ <br>        bSuccess = FALSE; <br>        goto ErrExit3; <br>    } <br> <br>    // <br>    // Make sure we pass in a DWORD aligned BitmapInfo to CreateDIBitmap <br>    // Otherwise, exception on the MIPS platform <br>    // CR!!!  Equivalent to memcpy <br>    // <br>    pjTmp = (PBYTE)pbmi; <br> <br>    while(sizBMI--) <br>    { <br>        *(((PBYTE)pjTmp)++) = *(((PBYTE)pbmh)++); <br>    } <br> <br>    // <br>    // assuming CreateDIBitmap() is doing a byte fetch... <br>    // <br>    pMapFile = (PBYTE)pMapFile + ((BITMAPFILEHEADER *)pMapFile)-&gt;bfOffBits; <br> <br>    // <br>    // Select the palette into the DC first before CreateDIBitmap() <br>    // <br>    bSelectDIBPal(hDC, pInfo, pbmi, bCoreHdr); <br>    if ((pInfo-&gt;hBmpSaved = CreateDIBitmap(hDC, (LPBITMAPINFOHEADER)pbmi, <br>                        CBM_INIT, pMapFile, pbmi, DIB_RGB_COLORS)) == NULL)  <br>{ <br>        OutputDebugString("Fail in creating DIB bitmap from file!"); <br>        bSuccess = FALSE; <br>        goto ErrExit4; <br>    } <br> <br>    // <br>    // Saving the DIB...free memory when the windows is closed. <br>    // <br>    pInfo-&gt;RleData.rgpjFrame[0] = pMapFile; <br>    pInfo-&gt;RleData.rgpbmi[0]    = pbmi; <br>    pInfo-&gt;RleData.pbmi         = (PBITMAPINFO) &amp;(pInfo-&gt;RleData.rgpbmi[0]); <br>    pInfo-&gt;RleData.ulFrames     = 1; <br>    pInfo-&gt;RleData.ulFiles      = 1; <br> <br>    // set flag to use original DIB as source for blting so HT can be done <br>    pInfo-&gt;bUseDIB = TRUE; <br> <br>    pInfo-&gt;bCoreHdr = bCoreHdr; <br> <br>    return (bSuccess); <br> <br>ErrExit4: <br>    LocalFree(pbmi); <br>ErrExit3: <br>    CloseHandle(hMapFile); <br>ErrExit2: <br>    CloseHandle(hFile); <br>ErrExit1: <br> <br>    return (bSuccess); <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
