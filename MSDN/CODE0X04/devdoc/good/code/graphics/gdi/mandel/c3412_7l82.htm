<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BNDSCAN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3422"></a>BNDSCAN.C</h2>
<pre><code>/******************************Module*Header*******************************\ <br>* Module Name: bndscan.c <br>* <br>* Contains the boundary scaning functions <br>* <br>* Created: 14-Apr-1992 10:59:52 <br>* <br>* Copyright 1993 - 1998 Microsoft Corporation <br>* <br>\**************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "jtypes.h" <br>#include "bndscan.h" <br> <br>BOOLbBoundaryScanFix(PINFO); <br>LPPOINT pptTrace(LONG, LONG, PINFO, INT *, HDC); <br>DWORDdwGetNextBoundaryPoint(DWORD, POINT, LPPOINT, PINFO); <br>BOOLbEscape(POINT, LONG, LONG, LONG, LONG, int, RECT); <br>BOOLbDirToPt(DWORD, POINT, LPPOINT); <br>DWORD   dwShift(DWORD, int, int); <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bBoundaryScanFix <br>* <br>* Effects:  Traces the outline of the mandelbrot set.  Currently, <br>*           1. Uses the old method to set the color of each pixel <br>*           2. Remember the first pixel from top that doesn't escape <br>*              st we can do boundary trace later. <br>*           3. When the whole set is done, do boundary trace. <br>*           4. Store the boundary points in an array. Then build a path. <br>*           5. Converts the path to region and then select the region as <br>*              current clip region. <br>* <br>* Warnings: Only traces the first non-singular pixel island from top. <br>\**************************************************************************/ <br> <br>BOOL bBoundaryScanFix(PINFO pInfo) <br>{ <br>    DWORD       dwTick1; <br>    int         m, n, o, p; <br>    HDC         hDC; <br>    RECT        rc; <br>    LONG        c1, c2; <br>    LONG        x0, y0; <br>    int         iIteration; <br>    LPPOINT     lpPt; <br>    int iCount; <br>    POINTPt; <br>    BOOL        bFirstPtSet; <br> <br>    pInfo-&gt;bMandel = TRUE; <br>    pInfo-&gt;bDrawing = TRUE; <br>    bFirstPtSet = FALSE; <br>    iIteration = pInfo-&gt;iIteration; <br>    hDC = GetDC(pInfo-&gt;hwnd); <br>    GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br> <br>    dwTick1 = GetTickCount(); <br>    for (n=rc.bottom/2; n&lt;=rc.bottom; n++) { <br>c2 = y0 = XformFix(n, rc.top, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>        for (m=rc.left; m&lt;=rc.right; m++) { <br>    c1 = x0 = XformFix(m, rc.left, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>    Pt.x = m; <br>    Pt.y = n; <br>    if (bEscape(Pt, x0, y0, c1, c2, iIteration, rc)) { <br>                //SetPixel(hDC, m, n, 0x000000ff); <br>            } else { <br> <br>                if (!bFirstPtSet) <br>                { <br>                    o = m; <br>                    p = n; <br>                    bFirstPtSet = TRUE; <br>                } <br>                goto BOUNDTRACE; <br>            } <br>        } <br>    } <br> <br>BOUNDTRACE: <br> <br>    SelectObject(hDC, hpnBlack); <br>    if ((lpPt = pptTrace(o, p, pInfo, &amp;iCount, hDC)) == NULL) <br>    { <br>        m = o+1; <br> <br>        for (n=p; n&lt;=rc.bottom; n++) { <br>    c2 = y0 = XformFix(n, rc.top, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>            while (m &lt;= rc.right) <br>            { <br>        c1 = x0 = XformFix(m, rc.left, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>        Pt.x = m; <br>        Pt.y = n; <br> <br>        if (!bEscape(Pt, x0, y0, c1, c2, iIteration, rc)) <br>                { <br>                    o = m; <br>                    p = n; <br>                    goto BOUNDTRACE; <br>                } <br> <br>                m++; <br>            } <br>            m = rc.left; <br>        } <br>    } <br> <br>    if (!BeginPath(hDC)) { <br>        sprintf( gtext,"Failing in BeginPath!\n"); <br>        OutputDebugString( gtext ); <br>    } <br> <br>    MoveToEx(hDC, m, n, NULL); <br>    Polyline(hDC, lpPt, iCount); <br> <br>    if (EndPath(hDC)) { <br>        StrokePath(hDC); <br>    } <br> <br>    // <br>    // Stroking discards the path <br>    // <br>    if (!BeginPath(hDC)) { <br>        sprintf( gtext,"Failing in BeginPath!\n"); <br>        OutputDebugString( gtext ); <br>    } <br> <br>    MoveToEx(hDC, m, n, NULL); <br>    Polyline(hDC, lpPt, iCount); <br> <br>    if (EndPath(hDC)) { <br>        // <br>        // Convert the path to region <br>        // <br>        pInfo-&gt;hRgnPath = PathToRegion(hDC); <br> <br>#if 0 <br>        // <br>        // Can't use SelectClipPath to set the clipping region here <br>        // because we are on a different thread.  This is only a cached DC. <br>        // <br>        if (SelectClipPath(hDC, RGN_COPY)) { <br> <br>            // Testing if the clip region is effective or not <br>            // <br>            //MoveToEx(hDC, 0, 0, NULL); <br>            //GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>            //LineTo(hDC, rc.right, rc.bottom); <br>        } <br>#endif <br>    } <br> <br>    if (pInfo-&gt;hRgnPath != (HRGN) NULL) { <br>        // <br>        // let the main thread who owns the DC to set the clipping region. <br>        // <br>        SendMessage(ghwndMain, WM_COMMAND, MM_SELCLIPRGN, 0L); <br>    } <br> <br>    pInfo-&gt;dwElapsed = GetTickCount() - dwTick1; <br>    pInfo-&gt;hBmpSaved = SaveBitmap(pInfo-&gt;hwnd, pInfo-&gt;hPal); <br>    pInfo-&gt;bDrawing = FALSE; <br> <br>    ReleaseDC(pInfo-&gt;hwnd, hDC); <br>    // <br>    // GlobalAlloc was called in pptTrace for storing the boundary points <br>    // <br>    GlobalFree((HANDLE) lpPt); <br>    ExitThread(0); <br>    return TRUE; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* pptTrace <br>* <br>* Effects:  Given a boundary point, traces the whole boundary of the <br>*           set by calling dwGetNextBoundaryPoint() repeatedly.  Returns <br>*           a pointer to an array of boundary points and also the count <br>*           of boundary points in the array, if successful.  Otherwise, <br>*           returns null. <br>*           m, n is the x, y coordinates of the pixel of the initial <br>*           boundary point. <br>* <br>* Warnings: <br>* <br>* History: <br>*  20-Feb-1992 -by- Petrus Wong <br>* Wrote it. <br>\**************************************************************************/ <br> <br>LPPOINT pptTrace(LONG m, LONG n, PINFO pInfo, INT * piCount, HDC hDC) <br>{ <br>    DWORD        dwFace; <br>    LPPOINT      lpPt, lpTmpPt; <br>    POINT        Init; <br>    int          iNumPt; <br> <br>    // <br>    // MAXPOINT points should be enough for storing the boundary for now.  If <br>    // it's not enough, it is more likely that it is an error. <br>    // <br>    if ((lpPt = (PPOINT) GlobalAlloc(GMEM_FIXED, MAXPOINT * sizeof(POINT))) == NULL)  <br>{ <br>        return (LPPOINT) NULL; <br>    } <br>    lpTmpPt = lpPt; <br>    lpPt-&gt;x = Init.x = m; <br>    lpPt-&gt;y = Init.y = n; <br>    lpPt++; <br>    iNumPt = 1; <br>    dwFace = dwGetNextBoundaryPoint(EAST, Init, lpPt, pInfo); <br>    // <br>    // If can't find next boundary point, return null <br>    // <br>    if (dwFace == 0) <br>        return((LPPOINT)NULL); <br>//#if 0 <br>    // <br>    // remove the ifdef if we wanted to see the boundary as we trace <br>    // <br>    MoveToEx(hDC, Init.x, Init.y, NULL); <br>    LineTo(hDC, lpPt-&gt;x, lpPt-&gt;y); <br>//#endif <br>    // <br>    // Keep looking for next boundary point until I get back to where I <br>    // started or exceeding MAXPOINT points <br>    // <br>    while ((iNumPt &lt; MAXPOINT) &amp;&amp; <br>           ((lpPt-&gt;x != lpTmpPt-&gt;x) || (lpPt-&gt;y != lpTmpPt-&gt;y))) { <br>        Init.x = lpPt-&gt;x; <br>        Init.y = lpPt-&gt;y; <br>        lpPt++; <br>        iNumPt++; <br>dwFace = dwGetNextBoundaryPoint(dwFace, Init, lpPt, pInfo); <br>        // <br>        // If can't find next boundary point, return null <br>        // <br>        if (dwFace == 0) <br>            return((LPPOINT)NULL); <br>//#if 0 <br>        // <br>        // remove the ifdef if we wanted to see the boundary as we trace <br>        // <br>        MoveToEx(hDC, Init.x, Init.y, NULL); <br>        LineTo(hDC, lpPt-&gt;x, lpPt-&gt;y); <br>//#endif <br> <br>    } <br>    // <br>    // It is more likely that it is an error of the algorithm, if ever happens. <br>    // <br>    if (iNumPt &gt;= MAXPOINT)  <br>{ <br>OutputDebugString ("Not enough memory!!"); <br>    } <br>    *piCount = iNumPt; <br>    return (LPPOINT) lpTmpPt; <br>} <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* dwGetNextBoundaryPoint <br>* <br>* Effects:  Start checking the 8 neighbors in clockwise direction.  Returns <br>*           the first neighbor that does not escape. <br>*           dwFace      where we face <br>*           InitPt      where we are right now in pixel coordinates <br>* <br>* Warnings: assumes that we start at a boundary point.  Does not trace into <br>*           a bay if the entrance closed. Ie, it cuts cycle. <br>* <br>* History: <br>*  12-Feb-1992 -by- Petrus Wong <br>* Wrote it. <br>\**************************************************************************/ <br> <br>DWORD dwGetNextBoundaryPoint(DWORD dwFace, POINT InitPt, LPPOINT lpPt, PINFO pInfo) <br>{ <br>    BOOL    bEsc; <br>    DWORD   dwExplore; <br>    DWORD   dwEnd; <br>    int     i; <br>    NODE    arg[8]; <br>    POINT   BndPt; <br>    LONG    lx, c1, ly, c2; <br>    RECT    rc; <br> <br>    GetClientRect(pInfo-&gt;hwnd, &amp;rc); <br>    // <br>    // Start exploring clockwise, ending at where we came from <br>    // <br>    dwExplore = dwShift(dwFace, RIGHT, 3); <br>    dwEnd = dwShift(dwFace, LEFT, 4); <br>    i = 0; <br>    bDirToPt(dwExplore, InitPt, &amp;BndPt); <br>    c1 = lx = XformFix(BndPt.x, rc.left, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>    c2 = ly = XformFix(BndPt.y, rc.top, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>    while (bEsc = bEscape(BndPt, lx, ly, c1, c2, pInfo-&gt;iIteration, rc)) { <br>        arg[i].dwDirection = dwExplore; <br>        arg[i].bEscape     = TRUE; <br> <br>        i++; <br> <br>        if (dwExplore == dwEnd) <br>            break; <br> <br>        dwExplore = dwShift(dwExplore, LEFT, 1); <br>bDirToPt(dwExplore, InitPt, &amp;BndPt); <br>c1 = lx = XformFix(BndPt.x, rc.left, rc.right, pInfo-&gt;lxFrom, pInfo-&gt;lxTo); <br>c2 = ly = XformFix(BndPt.y, rc.top, rc.bottom, pInfo-&gt;lyFrom, pInfo-&gt;lyTo); <br> <br>    } <br> <br>    if (bEsc) { <br>        return 0L; <br>    } <br> <br>    arg[i].dwDirection = dwExplore; <br>    arg[i].bEscape     = FALSE; <br> <br>    bDirToPt(arg[i].dwDirection, InitPt, lpPt); <br> <br>    return arg[i].dwDirection; <br>} <br> <br> <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bEscape <br>* <br>* Effects: Test if the point excapes based on the number of iterations <br>* <br>* Warnings: <br>* <br>* History: <br>*  16-Feb-1993      Petrus Wong     9.23 fix <br>*  20-Feb-1992 -by- Petrus Wong <br>* Wrote it. <br>\**************************************************************************/ <br> <br>BOOL bEscape(POINT Pt, LONG x, LONG y, LONG c1, LONG c2, int iIteration, RECT rc) <br>{ <br>    LONG x1, y1, z; <br>    BOOL bEscape; <br>    int i; <br> <br>    bEscape = FALSE; <br> <br>    // <br>    // Treat points outside of client rect as escaping <br>    // <br>    if ((Pt.x &lt; rc.left)   || (Pt.x &gt; rc.right-1) || <br>        (Pt.y &gt; rc.bottom-1) || (Pt.y &lt; rc.top))     { <br>        return TRUE; <br>    } <br>    for (i=1; i&lt;=iIteration; i++) { <br>        x1 = lMul(x - y, x + y) + c1; <br>        y1 = (lMul(x, y) * 2) + c2; <br>        x = x1; <br>        y = y1;                             //    2       2     2 1/2     2 <br>        z = lMul(x, x) + lMul(y, y);        // |Z|  = ((x1  + x2 )   ) &gt; 2 <br> <br>        if (z &gt; 33554432) { <br>            bEscape = TRUE; <br>            break; <br>        } <br>    } <br>    return bEscape; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* bDirToPt <br>* <br>* Effects: Returns the pixel coordinates based the direction we are facing <br>*          and our current position <br>* <br>* Warnings: <br>* <br>* History: <br>*  20-Feb-1992 <br>* Wrote it. <br>\**************************************************************************/ <br> <br>BOOL bDirToPt(DWORD dwDirection, POINT InitPt, LPPOINT lpPt) <br>{ <br>    BOOL bSuccess; <br> <br>    bSuccess = TRUE; <br>    switch ((LONG)dwDirection) { <br>        case EAST: <br>            lpPt-&gt;x = InitPt.x+1; <br>            lpPt-&gt;y = InitPt.y; <br>            break; <br>        case SOUTHEAST: <br>            lpPt-&gt;x = InitPt.x+1; <br>            lpPt-&gt;y = InitPt.y+1; <br>            break; <br>        case SOUTH: <br>            lpPt-&gt;x = InitPt.x; <br>            lpPt-&gt;y = InitPt.y+1; <br>            break; <br>        case SOUTHWEST: <br>            lpPt-&gt;x = InitPt.x-1; <br>            lpPt-&gt;y = InitPt.y+1; <br>            break; <br>        case WEST: <br>            lpPt-&gt;x = InitPt.x-1; <br>            lpPt-&gt;y = InitPt.y; <br>            break; <br>        case NORTHWEST: <br>            lpPt-&gt;x = InitPt.x-1; <br>            lpPt-&gt;y = InitPt.y-1; <br>            break; <br>        case NORTH: <br>            lpPt-&gt;x = InitPt.x; <br>            lpPt-&gt;y = InitPt.y-1; <br>            break; <br>        case NORTHEAST: <br>            lpPt-&gt;x = InitPt.x+1; <br>            lpPt-&gt;y = InitPt.y-1; <br>            break; <br>        default: <br>            bSuccess = FALSE; <br>            break; <br>    } <br>    return bSuccess; <br>} <br> <br>/******************************Public*Routine******************************\ <br>* <br>* dwShift <br>*                                     NORTH <br>*                           NW        0x0040        NE <br>*                               0x0020      0x0080 <br>* Effects:      WEST    0x0010          *           0x0001  EAST <br>*                               0x0008      0x0002 <br>*                           SW        0x0004        SE <br>*                                     SOUTH <br>* <br>*               Shift dwOpnd left or right by iNum. <br>*               dwOpnd contains the above values. The shift operation is <br>*               closed. <br>* <br>\**************************************************************************/ <br> <br>DWORD dwShift(DWORD dwOpnd, int iDir, int iNum) <br>{ <br>    DWORD dwTmp; <br> <br>    dwTmp = ((dwOpnd &lt;&lt; 8) | dwOpnd); <br>    switch ((LONG)iDir) { <br>case LEFT: <br>            dwTmp = dwTmp &lt;&lt; iNum; <br>    dwTmp = dwTmp &amp; 0x0ff00; <br>            dwTmp = dwTmp &gt;&gt; 8; <br>            break; <br>case RIGHT: <br>            dwTmp = dwTmp &gt;&gt; iNum; <br>            dwTmp = dwTmp &amp; 0x0ff; <br>            break; <br>default: <br>            dwTmp = 0L; <br>    break; <br>    } <br>    return dwTmp; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
