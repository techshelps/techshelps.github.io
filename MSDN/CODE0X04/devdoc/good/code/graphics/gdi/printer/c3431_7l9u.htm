<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMPRT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3432"></a>ENUMPRT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************\ <br>* <br>*  PROGRAM:     ENUMPRT.C <br>* <br>*  PURPOSE:     Handles display of information returned by calls to <br>*               EnumPrinters, EnumPrinterDrivers. Info formatted and <br>*               displayed in a dialog box. <br>* <br>* <br>*  FUNTIONS:    EnumPrintersDlgProc      - handles messages for dialog <br>*               DisplayEnumPrintersInfo  - retrieves printer info <br>*               SetEnumPrintersDlgFields - formats &amp; displays printer info <br>*               ComplexEnumPrintersLine  - formats bitfield printer info <br>*               EnumPrinterDriversDlgProc- handles messages for dialog <br>*               DisplayPrinterDriversInfo- retrieves, formats, &amp; displays <br>*                                            printer info <br>* <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;drivinit.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;winspool.h&gt; <br>#include "common.h" <br>#include "enumprt.h" <br>#include "resource.h" <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    EnumPrintersDlgProc (standard dialog procedure INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Processes messages for EnumPrinters dialog box <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK EnumPrintersDlgProc (HWND   hwnd, UINT msg, WPARAM wParam, <br>                                      LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG: <br>    { <br>      BOOL bReturn; <br> <br>      // <br>      // prompt user for EnumPrinters flags... <br>      // <br> <br>      if (DialogBox (GetModuleHandle (NULL), (LPCTSTR) "EnumPrtOpt", <br>                     NULL, (DLGPROC) EnumPrintersOptionsDlgProc)) <br>      { <br>        // <br>        // shove all the enum printer info in the list box <br>        // <br> <br>        SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>        bReturn = DisplayEnumPrintersInfo (hwnd); <br>        SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br>        if (!bReturn) <br> <br>          EndDialog (hwnd, TRUE); <br> <br>        else <br> <br>          SetWindowText (hwnd, (LPCTSTR)"EnumPrinters"); <br>      } <br>      else <br> <br>          EndDialog (hwnd, TRUE); <br> <br>      break; <br>    } <br> <br>    case WM_COMMAND: <br> <br>      switch (LOWORD (wParam)) <br>      { <br>        case DID_OK: <br> <br>          EndDialog (hwnd, TRUE); <br>          break; <br>      } <br>      break; <br>  } <br>  return 0; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    EnumPrintersOptionsDlgProc (standard dlg proc INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Processes messages for EnumPrtOpt dialog box <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK EnumPrintersOptionsDlgProc (HWND   hwnd,   UINT msg, <br>                                             WPARAM wParam, LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG: <br> <br>      gdwEnumFlags = 0; <br>      gszEnumName[0] = 0; <br>      break; <br> <br>    case WM_COMMAND: <br> <br>      switch (LOWORD (wParam)) <br>      { <br>        case DID_OK: <br> <br>          if (gdwEnumFlags) <br>          { <br>            if (gdwEnumFlags &amp; PRINTER_ENUM_NAME) <br>            { <br>              GetDlgItemText (hwnd, DID_EDITTEXT, (LPTSTR)gszEnumName, <br>                              BUFSIZE); <br> <br>#ifdef FORCE_VALID_NAME <br>              if (!strlen (gszEnumName)) <br>              { <br>                MessageBox (hwnd, <br>                            (LPCTSTR) GetStringRes(IDS_ASKDOMSRVNM), <br>                            (LPCTSTR) "", MB_OK); <br>                SetFocus (GetDlgItem (hwnd, DID_EDITTEXT)); <br>                break; <br>              } <br>#endif <br> <br>            } <br> <br>            EndDialog (hwnd, TRUE); <br>          } <br> <br>          else <br> <br>            EndDialog (hwnd, FALSE); <br> <br>          break; <br> <br>        case DID_CANCEL: <br> <br>          EndDialog (hwnd, FALSE); <br>          break; <br> <br>        default: <br> <br>          if (HIWORD(wParam) == BN_CLICKED) <br>          { <br>            DWORD dwControlId = (DWORD) LOWORD (wParam); <br> <br>            if (gdwEnumFlags &amp; dwControlId) <br>            { <br>              // <br>              // remove that flag, if PRINTER_ENUM_NAME disable edittext <br>              // <br> <br>              gdwEnumFlags &amp;= ~dwControlId; <br> <br>              if (dwControlId &amp; PRINTER_ENUM_NAME) <br>              { <br>                SetDlgItemText (hwnd, DID_EDITTEXT, (LPCTSTR)""); <br>                EnableWindow   (GetDlgItem (hwnd, DID_EDITTEXT), FALSE); <br>              } <br>            } <br> <br>            else <br>            { <br>              // <br>              // add that flag, if PRINTER_ENUM_NAME enable edittext <br>              // <br> <br>              gdwEnumFlags |= dwControlId; <br> <br>              if (dwControlId &amp; PRINTER_ENUM_NAME) <br> <br>                EnableWindow (GetDlgItem (hwnd, DID_EDITTEXT), TRUE); <br>            } <br>          } <br>          break; <br>      } <br>  } <br>  return 0; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    DisplayEnumPrintersInfo <br>* <br>*  INPUTS:      hwnd - handle of the EnumPrinters dialog box <br>* <br>*  RETURNS:     TRUE if successful, <br>*               FALSE otherwise <br>* <br>\******************************************************************************/ <br> <br>BOOL DisplayEnumPrintersInfo (HWND hwnd) <br>{ <br>    DWORD  dwBytesNeeded; <br>    DWORD  dwPrtRet1, dwPrtRet2; <br>    DWORD  dwMaxPrt; <br>    LPTSTR lpName = gdwEnumFlags &amp; PRINTER_ENUM_NAME ? gszEnumName : NULL; <br>     <br>    LPPRINTER_INFO_1 pPrtInfo1 = NULL; <br>    LPPRINTER_INFO_2 pPrtInfo2 = NULL; <br>     <br>    BOOL   bReturn = TRUE; <br>     <br>    // <br>    // get byte count needed for buffer, alloc buffer, the enum the printers <br>    // <br>    EnumPrinters (gdwEnumFlags,   // types of printer objects to enumerate           <br>                  lpName,         // name of printer object                          <br>                  1,              // specifies type of printer info structure        <br>                  NULL,           // use NULL to get buffer size                     <br>                  0,              // size, in bytes, of array                        <br>                  &amp;dwBytesNeeded, // pointer to variable with no. of bytes           <br>                                  // copied (or required)                            <br>                  &amp;dwPrtRet1);    // pointer to variable with no. of printer         <br>                                  // info. structures copied                         <br>    // <br>    // (simple error checking, if these work assume rest will too) <br>    // <br>     <br>    // Allocate enough room for the returned data <br>    if (!(pPrtInfo1 = (LPPRINTER_INFO_1) LocalAlloc (LPTR, dwBytesNeeded))) <br>    { <br>        ErrMsgBox (GetStringRes(IDS_ENUMPRTLALLOCFAIL), GetStringRes2(ERR_MOD_NAME)); <br>         <br>        return FALSE;  // Bail <br>    } <br>     <br>    if (!EnumPrinters(gdwEnumFlags,      // types of printer objects to enumerate        <br>                      lpName,            // name of printer object                       <br>                      1,                 // specifies type of printer info structure     <br>                      (LPBYTE)pPrtInfo1, // pointer to buffer to receive printer info    <br>                                         // structures                                   <br>                      dwBytesNeeded,     // size, in bytes, of array                     <br>                      &amp;dwBytesNeeded,    // pointer to variable with no. of bytes        <br>                                         // copied (or required)                         <br>                      &amp;dwPrtRet1))       // pointer to variable with no. of printer      <br>                                         // info. structures copied                      <br>    { <br>        TCHAR  tcBuffer[256]; <br>         <br>        // Create and display our error message <br>        wsprintf (tcBuffer, "%s, 1, GetLastError: %d", GetStringRes2(ERR_MOD_NAME), GetLastError()); <br>        ErrMsgBox (GetStringRes(IDS_ENUMPRT1FAIL), tcBuffer); <br>         <br>        // Free the buffer we allocated <br>        LocalFree(pPrtInfo1); <br> <br>        return FALSE;  // Bail <br>    } <br>     <br>    // <br>    // If we don't get any printers from the Level == 1 call, there is <br>    //  no point in continuing... report it, free memory, and return. <br>    // <br>    if (dwPrtRet1 == 0) { <br>         <br>        MessageBox (ghwndMain, <br>            (LPCTSTR) "EnumPrinters (Level == 1) returned 0 printers", <br>            GetStringRes2(ERR_MOD_NAME), <br>            MB_OK); <br> <br>        // Free the buffer we allocated <br>        LocalFree(pPrtInfo1); <br> <br>        return FALSE;  // Bail <br>    } <br>     <br>     <br>    // <br>    // Call EnumPrinters again, this time with Level == 2. <br>    // <br>    // get byte count needed for buffer, alloc buffer, the enum the printers <br>    // <br>    EnumPrinters (gdwEnumFlags,     // types of printer objects to enumerate        <br>                  lpName,           // name of printer object                       <br>                  2,                // specifies type of printer info structure     <br>                  NULL,             // use NULL to get buffer size                  <br>                  0,                // size, in bytes, of array                     <br>                  &amp;dwBytesNeeded,   // pointer to variable with no. of bytes        <br>                                    // copied (or required)                         <br>                  &amp;dwPrtRet2);      // pointer to variable with no. of printer      <br>                                    // info. structures copied                      <br> <br>    // Allocate enough room for the returned data <br>    if (!(pPrtInfo2 = (LPPRINTER_INFO_2) LocalAlloc (LPTR, dwBytesNeeded))){ <br>        ErrMsgBox (GetStringRes(IDS_ENUMPRTLALLOCFAIL), GetStringRes2(ERR_MOD_NAME)); <br>    } else { <br>   <br>if (!EnumPrinters (gdwEnumFlags,      // types of printer objects to enumerate     <br>   lpName,            // name of printer object                    <br>   2,                 // specifies type of printer info structure  <br>   (LPBYTE)pPrtInfo2, // pointer to buffer to receive printer info <br>  // structures                                <br>   dwBytesNeeded,     // size, in bytes, of array                  <br>   &amp;dwBytesNeeded,    // pointer to variable with no. of bytes     <br>  // copied (or required)                      <br>   &amp;dwPrtRet2))       // pointer to variable with no. of printer   <br>  // info. structures copied                   <br>    dwPrtRet2 = 0; <br>    } <br>     <br>    // <br>    //  Calling EnumPrinters with Level == 2 frequently returns 0 printers. <br>    //  If so display only the PRINTER_INFO_1 structures we got before. <br>    // <br>     <br>    if (dwPrtRet2 == 0) <br>    { <br>        dwMaxPrt = dwPrtRet1; <br>        LocalFree (pPrtInfo2); <br>        pPrtInfo2 = NULL; <br>    } else { <br>        dwMaxPrt = dwPrtRet1 &gt; dwPrtRet2 ? dwPrtRet2 : dwPrtRet1; <br>    } <br>     <br>     <br>    SetEnumPrintersDlgFields (hwnd, dwMaxPrt, pPrtInfo1, pPrtInfo2); <br>     <br>    if (pPrtInfo2) <br>        LocalFree (pPrtInfo2); <br> <br>if (pPrtInfo1) <br>        LocalFree (pPrtInfo1); <br>     <br>    return TRUE; <br>} <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    SetEnumPrintersDlgFields <br>* <br>*  INPUTS:      hwnd      - handle of the EnumPrinters dialog box <br>*               dwMaxPrt  - number of elements in the following two arrays <br>*               pdisplay_prts_info1 - ptr to an array of PRINTER_INFO_1 structs <br>*               pdisplay_prts_info2 - ptr to an array of PRINTER_INFO_2 structs <br>* <br>*  COMMENTS:    This function formats the info returned by EnumPrinters() <br>*               into readable strings and inserts them in the listbox. <br>* <br>\******************************************************************************/ <br> <br>void SetEnumPrintersDlgFields (HWND hwnd, DWORD dwMaxPrt, <br>                               LPPRINTER_INFO_1 pPrtInfo1, <br>                               LPPRINTER_INFO_2 pPrtInfo2) <br>{ <br>char  buf[256]; <br>WORD  i; <br>DWORD j; <br> <br>SendDlgItemMessage (hwnd, DID_LISTBOX, LB_RESETCONTENT, 0, 0); <br>SendDlgItemMessage (hwnd, DID_LISTBOX, WM_SETFONT, (WPARAM)GetStockObject(ANSI_FIXED_FONT), (LPARAM)0); <br> <br>for (j = 0; j &lt; dwMaxPrt; j++) { <br>// <br>// Stick PRINTER_INFO_1  data in listbox <br>// <br> <br>SendDlgItemMessage (hwnd, DID_LISTBOX, LB_INSERTSTRING, (UINT)-1, <br>(LONG) gaEnumPrt[0]); <br> <br>outstr (gaEnumPrt[1], (pPrtInfo1 + j)-&gt;pDescription); <br>outstr (gaEnumPrt[2], (pPrtInfo1 + j)-&gt;pName); <br>outstr (gaEnumPrt[3], (pPrtInfo1 + j)-&gt;pComment); <br> <br>// <br>// Stick PRINTER_INFO_2  data in listbox <br>// <br> <br>if (pPrtInfo2 != NULL) { <br> <br>SendDlgItemMessage (hwnd, DID_LISTBOX, LB_INSERTSTRING, (UINT)-1, <br>(LONG) gaEnumPrt[4]); <br> <br>outstr (gaEnumPrt[5],  (pPrtInfo2 + j)-&gt;pServerName); <br>outstr (gaEnumPrt[6],  (pPrtInfo2 + j)-&gt;pPrinterName); <br>outstr (gaEnumPrt[7],  (pPrtInfo2 + j)-&gt;pShareName); <br>outstr (gaEnumPrt[8],  (pPrtInfo2 + j)-&gt;pPortName); <br>outstr (gaEnumPrt[9],  (pPrtInfo2 + j)-&gt;pDriverName); <br>outstr (gaEnumPrt[10], (pPrtInfo2 + j)-&gt;pComment); <br>outstr (gaEnumPrt[11], (pPrtInfo2 + j)-&gt;pLocation); <br> <br>if ((pPrtInfo2 + j)-&gt;pDevMode) <br>{ <br>DWORD dwFields; <br> <br>outstr (gaEnumPrt[12], ""); <br>outstr (gaEnumPrt[13], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmDeviceName); <br>outnum (gaEnumPrt[14], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmSpecVersion); <br>outnum (gaEnumPrt[15], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmDriverVersion); <br>outnum (gaEnumPrt[16], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmSize); <br>outnum (gaEnumPrt[17], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmDriverExtra); <br> <br>dwFields = (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmFields; <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[18], gaFields,  <br> MAX_FIELDS, <br> dwFields); <br> <br>if (dwFields &amp; DM_ORIENTATION) { <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[19], gaOrientation, <br> MAX_ORIENTATION, <br> (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmOrientation); <br>} <br> <br>if (dwFields &amp; DM_PAPERSIZE) { <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[20], gaPaperSize, <br> MAX_PAPERSIZE, <br> (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmPaperSize); <br>} <br> <br>if (dwFields &amp; DM_PAPERLENGTH) <br>outnum (gaEnumPrt[21], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmPaperLength); <br> <br>if (dwFields &amp; DM_PAPERWIDTH) <br>outnum (gaEnumPrt[22], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmPaperWidth); <br> <br>if (dwFields &amp; DM_SCALE) <br>outnum (gaEnumPrt[23], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmScale); <br> <br>if (dwFields &amp; DM_COPIES) <br>outnum (gaEnumPrt[24], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmCopies); <br> <br>if (dwFields &amp; DM_DEFAULTSOURCE) { <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[25], gaDefaultSource, <br> MAX_DEFAULTSOURCE, <br> (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmDefaultSource); <br>} <br> <br>if (dwFields &amp; DM_PRINTQUALITY) { <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[26], gaPrintQuality, <br> MAX_PRINTQUALITY, <br> (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmPrintQuality); <br>} <br> <br>if (dwFields &amp; DM_COLOR) { <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[27], gaColor, <br> MAX_COLOR, <br> (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmColor); <br>} <br> <br>if (dwFields &amp; DM_DUPLEX) { <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[28], gaDuplex, <br> MAX_DUPLEX, <br> (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmDuplex); <br>} <br> <br>if (dwFields &amp; DM_YRESOLUTION) <br>outnum (gaEnumPrt[29], (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmYResolution); <br> <br>if (dwFields &amp; DM_TTOPTION) <br>outnum (gaEnumPrt[30], (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmTTOption); <br> <br>if (dwFields &amp; DM_COLLATE) <br>outnum (gaEnumPrt[31], (DWORD)(pPrtInfo2 + j)-&gt;pDevMode-&gt;dmCollate); <br> <br>if (dwFields &amp; DM_FORMNAME) <br>outstr (gaEnumPrt[32], (pPrtInfo2 + j)-&gt;pDevMode-&gt;dmFormName); <br>} <br>else <br>{ <br>outstr (gaEnumPrt[12], NULL); <br>} <br> <br>outstr (gaEnumPrt[33], (pPrtInfo2 + j)-&gt;pSepFile); <br>outstr (gaEnumPrt[34], (pPrtInfo2 + j)-&gt;pPrintProcessor); <br>outstr (gaEnumPrt[35], (pPrtInfo2 + j)-&gt;pDatatype); <br>outstr (gaEnumPrt[36], (pPrtInfo2 + j)-&gt;pParameters); <br> <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[37], gaAttributes, <br> MAX_ATTRIBUTES, <br> (DWORD)(pPrtInfo2 + j)-&gt;Attributes); <br> <br>for (i = 0; i &lt; MAX_PRIORITIES; i++) { <br>if ((pPrtInfo2 + j)-&gt;Priority &amp; gaPriorities[i].dwValue) { <br>outstr (gaEnumPrt[38], gaPriorities[i].szValue); <br>break; <br>} <br>} <br> <br>if (i == MAX_PRIORITIES) { <br>outnum (gaEnumPrt[39], (pPrtInfo2 + j)-&gt;Priority); <br>} <br> <br>outnum (gaEnumPrt[40], (pPrtInfo2 + j)-&gt;DefaultPriority); <br>outnum (gaEnumPrt[41], (pPrtInfo2 + j)-&gt;StartTime); <br>outnum (gaEnumPrt[42], (pPrtInfo2 + j)-&gt;UntilTime); <br> <br>ComplexEnumPrintersLine (hwnd, gaEnumPrt[43], gaStatus,  <br> MAX_STATUS, <br> (DWORD)(pPrtInfo2 + j)-&gt;Status); <br> <br>outnum (gaEnumPrt[44], (pPrtInfo2 + j)-&gt;cJobs); <br>outnum (gaEnumPrt[45], (pPrtInfo2 + j)-&gt;AveragePPM); <br>        } <br>    } <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    ComplexEnumPrintersLine <br>* <br>*  INPUTS:      hwnd        - handle of the EnumPrinters dialog box <br>*               pbuf        - pointer to buffer containing a cap-type <br>*                              string <br>*               pLkUp       - pointer to a CAPSLOOKUP table <br>*               iMaxEntries - # of enries in table pointed at by pLkUp <br>*               iValue      - an integer containing 1+ bit-value flags. <br>* <br>*  COMMENTS:    This function is used to expand an int containing <br>*               multiple bit-values into a set of strings which are <br>*               inserted into the DevCapsDlg listbox. The iValue <br>*               parameter is checked against each iIndex entry in the <br>*               CAPSLOOKUP table pointed at by pLkUp, and when matches <br>*               are found the corresponding (lpszValue) string is <br>*               inserted. <br>* <br>*               The buffer pointed to by pbuf will be destroyed. <br>* <br>\******************************************************************************/ <br> <br>void ComplexEnumPrintersLine (HWND hwnd, char  *pstr, ENUMPRTLOOKUP *pLkUp, <br>                              int iMaxEntries, DWORD  dwValue) <br>{ <br>  char buf [BUFSIZE]; <br>  int  i; <br>  BOOL bNewLine = FALSE; <br> <br>  strcpy (buf, pstr); <br> <br>  for (i = 0; i &lt; iMaxEntries; i++) <br> <br>    if (dwValue &amp; (pLkUp + i)-&gt;dwValue) <br>    { <br>      if (bNewLine) <br>      { <br>        // <br>        // Keep the first symbolic constant on the same line as the <br>        //   cap type, eg:  "TECHNOLOGY:     DT_RASDISPLAY". <br>        // <br> <br>        strcpy (buf, BLANKS); <br>        strcat (buf, (pLkUp + i)-&gt;szValue); <br>      } <br>      else <br>      { <br>        // <br>        // Put symbolic constant on new line, eg: <br>        //                  "                DT_RASPRINTER". <br>        // <br> <br>        strcat (buf, (pLkUp + i)-&gt;szValue); <br>        bNewLine = TRUE; <br>      } <br>      SendDlgItemMessage (hwnd, DID_LISTBOX, LB_INSERTSTRING, <br>                          (UINT)-1, (LONG) buf); <br>   } <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    EnumPrinterDriversDlgProc (standard dlg proc INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Processes messages for EnumPrinterDrivers dialog box <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK EnumPrinterDriversDlgProc (HWND   hwnd,   UINT   msg, <br>                                            WPARAM wParam, LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG: <br>    { <br>      BOOL bReturn; <br> <br>      SetCursor (LoadCursor (NULL, IDC_WAIT)); <br>      bReturn = DisplayPrinterDriversInfo (hwnd); <br>      SetCursor (LoadCursor (NULL, IDC_ARROW)); <br> <br>      if (!bReturn) <br> <br>        EndDialog (hwnd, TRUE); <br> <br>      else <br> <br>        SetWindowText (hwnd, (LPCTSTR) "EnumPrinterDrivers"); <br> <br>      break; <br>    } <br> <br>    case WM_COMMAND: <br> <br>      switch (LOWORD (wParam)) <br>      { <br>        case DID_OK: <br> <br>          EndDialog (hwnd, TRUE); <br> <br>          return 1; <br>      } <br>      break; <br>  } <br>  return 0; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    DisplayPrinterDriversInfo <br>* <br>*  INPUTS:      hwnd - handle of the EnumPrinterDrivers dialog box <br>* <br>*  RETURNS:     TRUE if successful, <br>*               FALSE otherwise <br>* <br>*  COMMENTS:    Retrieves EnumPrinterDrivers info, formats, &amp; inserts <br>*               in listbox. <br>* <br>\******************************************************************************/ <br> <br>BOOL DisplayPrinterDriversInfo (HWND hwnd) <br>{ <br>  DWORD         dwBytesNeeded, dwDrvRet, i; <br>  DRIVER_INFO_1 *pDriverInfo1; <br>  DRIVER_INFO_2 *pDriverInfo2; <br>  char          buf[BUFSIZE]; <br>  BOOL          bReturn = TRUE; <br> <br>  // <br>  // get byte count needed for buffer, alloc buffer, the enum the drivers <br>  // <br> <br>  EnumPrinterDrivers ((LPTSTR) NULL, (LPTSTR) NULL, 1, NULL, <br>                      0, &amp;dwBytesNeeded, &amp;dwDrvRet); <br> <br>  // <br>  // simple error checking, if these work assume rest will too <br>  // <br> <br>  if (!(pDriverInfo1 = (DRIVER_INFO_1 *) LocalAlloc (LPTR, dwBytesNeeded))) <br>  { <br>    ErrMsgBox (GetStringRes(IDS_LALLOCFAIL), GetStringRes2(ERR_MOD_NAME)); <br>    bReturn = FALSE; <br>    goto display_prt_drvs_info_done1; <br>  } <br> <br>  if (!EnumPrinterDrivers ((LPTSTR) NULL, (LPTSTR) NULL, 1, <br>                           (LPBYTE) pDriverInfo1, dwBytesNeeded, &amp;dwBytesNeeded, <br>                           &amp;dwDrvRet)) <br>  { <br>    ErrMsgBox (GetStringRes(IDS_ENUMPRTDRVRET0), GetStringRes2(ERR_MOD_NAME)); <br>    bReturn = FALSE; <br>    goto display_prt_drvs_info_done2; <br>  } <br> <br>  EnumPrinterDrivers ((LPTSTR) NULL,(LPTSTR) NULL, 2, NULL, <br>                      0, &amp;dwBytesNeeded, &amp;dwDrvRet); <br> <br>  pDriverInfo2 = (DRIVER_INFO_2 *) LocalAlloc (LPTR, dwBytesNeeded); <br> <br>  EnumPrinterDrivers ((LPTSTR) NULL, (LPTSTR) NULL, 2, <br>                      (LPBYTE) pDriverInfo2, dwBytesNeeded, &amp;dwBytesNeeded, <br>                      &amp;dwDrvRet); <br> <br>  if (!dwDrvRet) <br>  { <br>    ErrMsgBox (GetStringRes(IDS_ENUMPRTDRVRET0), ""); <br>    bReturn = FALSE; <br>    goto display_prt_drvs_info_done3; <br>  } <br> <br>  // <br>  // insert formatted info into listbox <br>  // <br> <br>  for (i = 0; i &lt; dwDrvRet; i++) <br>  { <br>    sprintf (buf, gaDriverInfo[0]); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[1], (pDriverInfo1 + i)-&gt;pName); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[2]); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[3], (pDriverInfo2 + i)-&gt;cVersion); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[4], (pDriverInfo2 + i)-&gt;pName); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[5], (pDriverInfo2 + i)-&gt;pEnvironment); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[6], (pDriverInfo2 + i)-&gt;pDriverPath); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[7], (pDriverInfo2 + i)-&gt;pDataFile); <br>    outstr3(); <br> <br>    sprintf (buf, gaDriverInfo[8], (pDriverInfo2 + i)-&gt;pConfigFile); <br>    outstr3(); <br> <br>  } <br> <br>display_prt_drvs_info_done3: <br> <br>  LocalFree (LocalHandle (pDriverInfo2)); <br> <br>display_prt_drvs_info_done2: <br> <br>  LocalFree (LocalHandle (pDriverInfo1)); <br> <br>display_prt_drvs_info_done1: <br> <br>  return bReturn; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
