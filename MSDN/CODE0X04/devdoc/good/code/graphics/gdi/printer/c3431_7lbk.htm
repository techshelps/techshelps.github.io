<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRINTER.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3440"></a>PRINTER.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************\ <br>* <br>*  PROGRAM:     PRINTER.C <br>* <br>*  PURPOSE:     This is a sample application demostrating some of the new <br>*               printing functionality in Windows NT. This app allows the <br>*               user to select between various GDI graphics primitives, <br>*               to choose pen &amp; brush colors, styles, and sizes, and to <br>*               the print these graphics to a printer. Also, the app <br>*               provides the user the ability to query information (reso- <br>*               lution, etc.) about the various printers &amp; drivers by <br>*               making calls to GetDeviceCaps, etc. <br>* <br>*               Functionality for PRINTER is split into six different <br>*               modules as follows: <br>* <br>*                 printer.c - main event loop <br>*                             main window procedure <br>*                             about &amp; abort dialog procedures <br>*                             printing thread <br>* <br>*                 paint.c   - handles all painting printers &amp; most painting <br>*                             to window <br>* <br>*                 enumprt.c - manages the display of information returned <br>*                             from calling EnumPrinters, EnumPrinterDrivers <br>* <br>*                 devcapsx.c- manages the display of information returned <br>*                             from calling DeviceCapabilitiesEx <br>* <br>*                 getpdriv.c- manages the display of information returned <br>*                             from calling GetPrinterDriver <br>* <br>*                 getcaps.c - manages the display of information returned <br>*                             from calling GetDeviceCaps <br>* <br>*  FUNCTIONS:   WinMain               - initialization, create window, msg loop <br>*               MainWndProc           - processes main window msgs <br>*               AboutDlgProc          - processes About dlg msgs <br>*               InvalidateClient      - invalidates graphics part of client wnd <br>*               RefreshPrinterCombobox- updates list of printers <br>*               PrintThread           - printing done here <br>*               AbortProc             - msg loop for abort <br>*               AbortDlgProc          - processes abort dialog messages <br>* <br>\******************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; // for _mbstrlen <br>#include &lt;winspool.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include "common.h" <br>#include "resource.h" <br>#include "printer.h" <br> <br>// for internationalization <br>#define My_mbslen _mbstrlen <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    WinMain (standard WinMain INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Register &amp; create main window, loop for messages <br>* <br>\******************************************************************************/ <br> <br>int WINAPI WinMain (HINSTANCE ghInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, <br>                    int    nCmdShow) <br>{ <br>  MSG msg; <br> <br>  ghInst = ghInstance; <br> <br>  if (!hPrevInstance) <br>  { <br>    WNDCLASS wc; <br> <br>    wc.style         = MAIN_CLASS_STYLE; <br>    wc.lpfnWndProc   = (WNDPROC) MainWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = ghInst; <br>    wc.hIcon         = LoadIcon (ghInst, MAKEINTRESOURCE(MAIN_ICON)); <br>    wc.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>    wc.hbrBackground = NULL; <br>    wc.lpszMenuName  = (LPCSTR) MAIN_MENU_NAME; <br>    wc.lpszClassName = (LPCSTR) MAIN_CLASS_NAME; <br> <br>    if (!RegisterClass (&amp;wc)) <br>    { <br>      MessageBox (NULL, "WinMain(): RegisterClass() failed", <br>                  GetStringRes2(ERR_MOD_NAME), MB_OK | MB_ICONHAND); <br> <br>      return FALSE; <br>    } <br>  } <br> <br>  if (!(ghwndMain = CreateWindow ((LPCSTR) MAIN_CLASS_NAME, <br>                                  (LPCSTR) GetStringRes(MAIN_WND_TITLE), <br>                                  MAIN_WND_STYLE, <br>                                  CW_USEDEFAULT, CW_USEDEFAULT, <br>                                  CW_USEDEFAULT, CW_USEDEFAULT, <br>                                  NULL, NULL, ghInst, NULL))) <br>    return FALSE; <br> <br>  ShowWindow (ghwndMain, nCmdShow); <br> <br>  while (GetMessage (&amp;msg, NULL, 0, 0)) <br>  { <br>    TranslateMessage (&amp;msg); <br>    DispatchMessage  (&amp;msg); <br>  } <br> <br>  return msg.wParam; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    MainWndProc (standard window procedure INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Handles main app window msg processing <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>  static HMENU hMappingModesSubMenu; <br>  static HMENU hGraphicsSubMenu; <br>  static HMENU hPenWidthSubMenu; <br>  static HMENU hPenStyleSubMenu; <br>  static HMENU hBrushStyleSubMenu; <br>  static HWND  hwndCombobox; <br>  static int   iComboboxWidth; <br>  static LONG  lTextHeight; <br> <br>  int i; <br> <br>  switch (msg) <br>  { <br>    case WM_COMMAND: <br> <br>      switch (LOWORD (wParam)) <br>      { <br>        case IDM_PRINT: <br>        case IDM_PRINTDLG: <br>        { <br>          DWORD  threadId; <br>  HANDLE hThread; <br> <br>          if (!(hThread = CreateThread (NULL, 0,  <br>                 (LPTHREAD_START_ROUTINE) PrintThread, <br>                             (LPVOID) wParam, 0, &amp;threadId))) <br>            MessageBox (hwnd, <br>                        "MainWndProc(): Error creating print thread", <br>                        GetStringRes2(ERR_MOD_NAME), MB_OK | MB_ICONHAND); <br>  else <br>  CloseHandle(hThread); <br>          break; <br>        } <br> <br>        case IDM_GETDEVICECAPS: <br> <br>          DialogBox (ghInst, (LPCTSTR) "List", hwnd, <br>                     (DLGPROC) GetDeviceCapsDlgProc); <br>          break; <br> <br>        case IDM_ENUMPRINTERS: <br> <br>          DialogBox (ghInst, (LPCTSTR) "List", hwnd, <br>                     (DLGPROC) EnumPrintersDlgProc); <br>          break; <br> <br>        case IDM_GETPRINTERDRIVER: <br> <br>          if (strcmp (gszDeviceName, "Display")) <br> <br>            DialogBox (ghInst, (LPCTSTR) "List", hwnd, <br>                       (DLGPROC) GetPrinterDriverDlgProc); <br>          else <br> <br>            MessageBox (hwnd, (LPCTSTR) GetStringRes(IDS_ASKSELPRT), <br>                        (LPCTSTR) "PRINTER.EXE:", MB_OK); <br> <br>          break; <br> <br>        case IDM_ENUMPRINTERDRIVERS: <br> <br>          DialogBox (ghInst, (LPCTSTR) "List", hwnd, <br>                     (DLGPROC) EnumPrinterDriversDlgProc); <br>          break; <br> <br>        case IDM_REFRESH: <br> <br>          RefreshPrinterCombobox (hwndCombobox); <br>          break; <br> <br>        case IDM_ABOUT: <br> <br>          DialogBox (ghInst, (LPCTSTR) "About", hwnd, (DLGPROC) AboutDlgProc); <br>          break; <br> <br>case IDM_EXIT: <br>DestroyWindow (hwnd); <br>break; <br> <br>        case IDM_HIENGLISH: <br>        case IDM_HIMETRIC: <br>        case IDM_LOENGLISH: <br>        case IDM_LOMETRIC: <br>        case IDM_TWIPS: <br>        case IDM_ISOTROPIC: <br>        case IDM_ANISOTROPIC: <br>        case IDM_TEXT: <br> <br>          // <br>          // Uncheck the last map mode menuitem, check the new map mode <br>          //   menuitem, set iMappingMode according to menu id, cause a <br>          //   repaint <br>          // <br> <br>          for (i = 0; i &lt; MAX_MAP_MODES; i++) <br> <br>            if (giMapMode == gaMMLookup[i].iMapMode) <br>            { <br>              CheckMenuItem (hMappingModesSubMenu, gaMMLookup[i].wMenuItem, <br>                             MF_UNCHECKED | MF_BYCOMMAND); <br>              break; <br>            } <br> <br>          CheckMenuItem (hMappingModesSubMenu, LOWORD (wParam), <br>                         MF_CHECKED | MF_BYCOMMAND); <br> <br>          for (i = 0; i &lt; MAX_MAP_MODES; i++) <br> <br>            if (LOWORD (wParam) == gaMMLookup[i].wMenuItem) <br>            { <br>              giMapMode = gaMMLookup[i].iMapMode; <br>              break; <br>            } <br> <br>          // <br>          // invalidate the entire client so toolbar text gets updated <br>          // <br> <br>          InvalidateRect (hwnd, NULL, TRUE); <br>          break; <br> <br>        case IDM_ARC: <br>        case IDM_ELLIPSE: <br>        case IDM_LINETO: <br>        case IDM_PIE: <br>        case IDM_PLGBLT: <br>        case IDM_POLYBEZIER: <br>        case IDM_POLYGON: <br>        case IDM_POLYLINE: <br>        case IDM_POLYPOLYGON: <br>        case IDM_RECTANGLE: <br>        case IDM_ROUNDRECT: <br>        case IDM_STRETCHBLT: <br>        { <br>          // <br>          // Retrieve the DWORD flag value for the particular menuitem, <br>          //   toggle (un/check) the menuitem, set/clear the flag in <br>          //   gdwGraphicsOptions, cause a repaint <br>          // <br> <br>          DWORD dwGraphic; <br> <br>          for (i = 0; i &lt; MAX_GRAPHICS; i++) <br> <br>            if (LOWORD (wParam) == gaGraphicLookup[i].wMenuItem) <br>            { <br>              dwGraphic = gaGraphicLookup[i].dwGraphic; <br>              break; <br>            } <br> <br>          if (GetMenuState (hGraphicsSubMenu, LOWORD(wParam), MF_BYCOMMAND) <br>              &amp; MF_CHECKED) <br> <br>          { <br>            gdwGraphicsOptions &amp;= ~dwGraphic; <br>            CheckMenuItem (hGraphicsSubMenu, LOWORD(wParam), <br>                            MF_UNCHECKED | MF_BYCOMMAND); <br>          } <br>          else <br>          { <br>            // <br>            // Clear/uncheck the ENUMFONTS flag/menuitem <br>            // <br> <br>            gdwGraphicsOptions &amp;= ~ENUMFONTS; <br>            CheckMenuItem (hGraphicsSubMenu, IDM_ENUMFONTS, <br>                           MF_UNCHECKED | MF_BYCOMMAND); <br> <br>            gdwGraphicsOptions |= dwGraphic; <br>            CheckMenuItem (hGraphicsSubMenu, LOWORD(wParam), <br>                            MF_CHECKED | MF_BYCOMMAND); <br>          } <br>          InvalidateClient (); <br>          break; <br>        } <br> <br>        case IDM_ALLGRAPHICS: <br> <br>          // <br>          // Clear/uncheck the ENUMFONTS flag/menuitem, set/check all <br>          //   other graphics flags/menuitems, cause a repaint <br>          // <br> <br>          CheckMenuItem (hGraphicsSubMenu, IDM_ENUMFONTS, <br>                          MF_UNCHECKED | MF_BYCOMMAND); <br> <br>          for (i = 0; i &lt; MAX_GRAPHICS; i++) <br> <br>            CheckMenuItem (hGraphicsSubMenu, IDM_ARC + i, <br>                           MF_CHECKED | MF_BYCOMMAND); <br> <br>          gdwGraphicsOptions = ALLGRAPHICS | (gdwGraphicsOptions &amp; DRAWAXIS); <br> <br>          InvalidateClient (); <br>          break; <br> <br>        case IDM_NOGRAPHICS: <br> <br>          // <br>          // Clear/uncheck all graphics flags/menuitems, cause a repaint <br>          // <br> <br>          for (i = 0; i &lt; MAX_GRAPHICS; i++) <br> <br>            CheckMenuItem (hGraphicsSubMenu, IDM_ARC + i, <br>                           MF_UNCHECKED | MF_BYCOMMAND); <br> <br>          gdwGraphicsOptions &amp;= (DRAWAXIS | ENUMFONTS); <br> <br>          InvalidateClient (); <br>          break; <br> <br>        case IDM_ENUMFONTS: <br> <br>          // <br>          // Set/clear ENUMFONTS flag, toggle (un/check) menuitem, if <br>          //   checking IDM_ENUMFONTS then uncheck all other items, <br>          //   cause a repaint <br>          // <br> <br>          if (GetMenuState (hGraphicsSubMenu, IDM_ENUMFONTS, MF_BYCOMMAND) <br>                &amp; MF_CHECKED) <br>          { <br>            gdwGraphicsOptions &amp;= DRAWAXIS; <br> <br>            CheckMenuItem (hGraphicsSubMenu, IDM_ENUMFONTS, <br>                           MF_UNCHECKED | MF_BYCOMMAND); <br>          } <br> <br>          else <br>          { <br>            SendMessage (hwnd, WM_COMMAND, IDM_NOGRAPHICS, 0); <br> <br>            gdwGraphicsOptions = ENUMFONTS | (gdwGraphicsOptions &amp; DRAWAXIS); <br> <br>            CheckMenuItem (hGraphicsSubMenu, IDM_ENUMFONTS, <br>                           MF_CHECKED | MF_BYCOMMAND); <br>          } <br>          InvalidateClient (); <br>          break; <br> <br>        case IDM_DRAWAXIS: <br> <br>          // <br>          // Set/clear DRAWAXIS flag, toggle (un/check) menuitem, <br>          //   cause a repaint <br>          // <br> <br>          if (GetMenuState (hGraphicsSubMenu, IDM_DRAWAXIS, MF_BYCOMMAND) <br>                &amp; MF_CHECKED) <br>          { <br>            gdwGraphicsOptions &amp;= ~DRAWAXIS; <br> <br>            CheckMenuItem (hGraphicsSubMenu, IDM_DRAWAXIS, <br>                           MF_UNCHECKED | MF_BYCOMMAND); <br>          } <br> <br>          else <br>          { <br>            gdwGraphicsOptions |= DRAWAXIS; <br> <br>            CheckMenuItem (hGraphicsSubMenu, IDM_DRAWAXIS, <br>                           MF_CHECKED | MF_BYCOMMAND); <br>          } <br>          InvalidateClient (); <br>          break; <br> <br>        case IDM_SETPENCOLOR: <br>        case IDM_SETBRUSHCOLOR: <br>        case IDM_TEXTCOLOR: <br>        { <br>          CHOOSECOLOR cc; <br> <br>          static DWORD adwCustColors[16]; <br> <br>          memset ((void *) &amp;cc, 0, sizeof (CHOOSECOLOR)); <br> <br>          cc.lStructSize  = sizeof (CHOOSECOLOR); <br>          cc.hwndOwner    = hwnd; <br>          cc.Flags        = CC_RGBINIT; <br>          cc.lpCustColors = adwCustColors; <br> <br>          if (LOWORD (wParam) == IDM_SETPENCOLOR) <br> <br>            cc.rgbResult = gdwPenColor; <br> <br>          else if (LOWORD (wParam) == IDM_SETBRUSHCOLOR) <br> <br>            cc.rgbResult = gdwBrushColor; <br> <br>          else <br> <br>            cc.rgbResult = gdwTextColor; <br> <br>          // <br>          // bring up choose color common dialog <br>          // <br> <br>          ChooseColor (&amp;cc); <br> <br>          if (LOWORD (wParam) == IDM_SETPENCOLOR) <br> <br>            gdwPenColor   = cc.rgbResult; <br> <br>          else if (LOWORD (wParam) == IDM_SETBRUSHCOLOR) <br> <br>            gdwBrushColor = cc.rgbResult; <br> <br>          else <br> <br>            gdwTextColor  = cc.rgbResult; <br> <br>          InvalidateClient (); <br>          break; <br>        } <br> <br>        case IDM_PENWIDTH_1: <br>        case IDM_PENWIDTH_2: <br>        case IDM_PENWIDTH_3: <br>        case IDM_PENWIDTH_4: <br>        case IDM_PENWIDTH_5: <br>        case IDM_PENWIDTH_6: <br>        case IDM_PENWIDTH_7: <br>        case IDM_PENWIDTH_8: <br> <br>          // <br>          // uncheck old pen width menuitem, check new one, cause a repaint <br>          // <br> <br>          for (i = 0; i &lt; MAX_PENWIDTHS; i++) <br> <br>            if (giPenWidth == gaPenWidths[i].iPenWidth) <br>            { <br>              CheckMenuItem (hPenWidthSubMenu, gaPenWidths[i].wMenuItem, <br>                             MF_UNCHECKED | MF_BYCOMMAND); <br>              break; <br>            } <br> <br>          for (i = 0; i &lt; MAX_PENWIDTHS; i++) <br> <br>            if (LOWORD(wParam) == gaPenWidths[i].wMenuItem) <br>            { <br>              CheckMenuItem (hPenWidthSubMenu, gaPenWidths[i].wMenuItem, <br>                             MF_CHECKED | MF_BYCOMMAND); <br> <br>              giPenWidth = gaPenWidths[i].iPenWidth; <br> <br>              break; <br>            } <br> <br>          InvalidateClient (); <br>          break; <br> <br>        case IDM_PENCOLOR_SOLID: <br>        case IDM_PENCOLOR_DASH: <br>        case IDM_PENCOLOR_DOT: <br>        case IDM_PENCOLOR_DASHDOT: <br>        case IDM_PENCOLOR_DASHDOTDOT: <br>        case IDM_PENCOLOR_NULL: <br>        case IDM_PENCOLOR_INSIDEFRAME: <br> <br>          // <br>          // uncheck old pen style menuitem, check new one, cause a repaint <br>          // <br> <br>          for (i = 0; i &lt; MAX_PENSTYLES; i++) <br> <br>            if (giPenStyle == gaPenStyles[i].iPenStyle) <br>            { <br>              CheckMenuItem (hPenStyleSubMenu, gaPenStyles[i].wMenuItem, <br>                             MF_UNCHECKED | MF_BYCOMMAND); <br>              break; <br>            } <br> <br>          for (i = 0; i &lt; MAX_PENSTYLES; i++) <br> <br>            if (LOWORD(wParam) == gaPenStyles[i].wMenuItem) <br>            { <br>              CheckMenuItem (hPenStyleSubMenu, gaPenStyles[i].wMenuItem, <br>                             MF_CHECKED | MF_BYCOMMAND); <br> <br>              giPenStyle = gaPenStyles[i].iPenStyle; <br> <br>              break; <br>            } <br> <br>          InvalidateClient (); <br>          break; <br> <br>        case IDM_BRUSHSTYLE_HORIZONTAL: <br>        case IDM_BRUSHSTYLE_VERTICAL: <br>        case IDM_BRUSHSTYLE_FDIAGONAL: <br>        case IDM_BRUSHSTYLE_BDIAGONAL: <br>        case IDM_BRUSHSTYLE_CROSS: <br>        case IDM_BRUSHSTYLE_DIAGCROSS: <br>         <br>          for (i = 0; i &lt; MAX_BRUSHSTYLES; i++) { <br> <br>// Uncheck the old option <br>if (giBrushStyle == gaBrushStyles[i].iBrushStyle) { <br>CheckMenuItem (hBrushStyleSubMenu, gaBrushStyles[i].wMenuItem, <br>   MF_UNCHECKED | MF_BYCOMMAND); <br>} <br> <br>// Check the new option <br>if (LOWORD(wParam) == gaBrushStyles[i].wMenuItem) { <br> <br>CheckMenuItem (hBrushStyleSubMenu, gaBrushStyles[i].wMenuItem, <br>   MF_CHECKED | MF_BYCOMMAND); <br> <br>giBrushStyle = gaBrushStyles[i].iBrushStyle; <br>} <br>} <br> <br>          InvalidateClient (); <br>          break; <br> <br>        case ID_COMBOBOX: <br> <br>          switch (HIWORD(wParam)) <br>          { <br>            case CBN_SELCHANGE: <br>            { <br>              DWORD dwIndex; <br>              char  buf[BUFSIZE]; <br> <br>              // <br>              // User clicked on one of the items in the toolbar combobox; <br>              //   figure out which item, then parse the text apart and <br>              //   copy it to the gszDriverName, gszDeviceName, and gszPort <br>              //   variables. <br>              // <br> <br>              dwIndex = (DWORD) SendMessage ((HWND) lParam, <br>                                             CB_GETCURSEL, 0, 0); <br>              SendMessage ((HWND) lParam, CB_GETLBTEXT, dwIndex, <br>                           (LONG) buf); <br> <br>              if (!strcmp (buf, "Display")) <br>              { <br>                strcpy (gszDeviceName, "Display"); <br> <br>                gszPort[0]       = <br>                gszDriverName[0] = '\0'; <br>              } <br>              else <br>              { <br>                LPSTR   lpszSrc; <br>                LPSTR   lpszDst; <br> <br>                for (lpszSrc = buf, lpszDst = gszDeviceName; <br>                    *lpszSrc &amp;&amp; *lpszSrc != ';';    ) { <br>                    if (IsDBCSLeadByte(*lpszSrc)) { <br>                        *lpszDst++ = *lpszSrc++; <br>                    } <br>                    *lpszDst++ = *lpszSrc++; <br>                } <br>                *lpszDst = '\0'; <br> <br>                for (lpszSrc++, lpszDst = gszPort; <br>                    *lpszSrc &amp;&amp; *lpszSrc != ';';    ) { <br>                    if (IsDBCSLeadByte(*lpszSrc)) { <br>                        *lpszDst++ = *lpszSrc++; <br>                    } <br>                    *lpszDst++ = *lpszSrc++; <br>                } <br>                *lpszDst = '\0'; <br> <br>                for (lpszSrc++, lpszDst = gszDriverName; *lpszSrc;    ) { <br>                    if (IsDBCSLeadByte(*lpszSrc)) { <br>                        *lpszDst++ = *lpszSrc++; <br>                    } <br>                    *lpszDst++ = *lpszSrc++; <br>                } <br>                *lpszDst = '\0'; <br>              } <br>              break; <br>            } <br>          } <br>          break; <br>      } <br>      break; <br> <br>    case WM_PAINT: <br>    { <br>      PAINTSTRUCT ps; <br>      RECT        rect; <br>      HRGN        hrgn; <br>      HPEN        hpen, hpenSave; <br>      HBRUSH      hbr; <br>      char        buf[BUFSIZE]; <br>      POINT       p; <br> <br>      BeginPaint (hwnd, &amp;ps); <br> <br>      // <br>      // paint 3d toolbar background &amp; client size text <br>      // <br> <br>      GetClientRect (hwnd, &amp;rect); <br>      rect.bottom = 2*glcyMenu; <br>      FillRect (ps.hdc, &amp;rect, GetStockObject (LTGRAY_BRUSH)); <br>      SelectObject (ps.hdc, GetStockObject (WHITE_PEN)); <br>      MoveToEx (ps.hdc, 0, 2*glcyMenu - 2, NULL); <br>      LineTo   (ps.hdc, 0, 0); <br>      LineTo   (ps.hdc, (int) rect.right, 0); <br>      hpen = CreatePen (PS_SOLID, 1, 0x808080); <br>      hpenSave = SelectObject (ps.hdc, hpen); <br>      MoveToEx (ps.hdc, 0, (int) 2*glcyMenu-1, NULL); <br>      LineTo   (ps.hdc, (int) rect.right - 1, (int) 2*glcyMenu-1); <br>      LineTo   (ps.hdc, (int) rect.right - 1, 1); <br>      SelectObject (ps.hdc, hpenSave); <br>      DeleteObject (hpen); <br> <br>      GetClientRect (hwnd, &amp;rect); <br> <br>      // <br>      // positioning of the string based upon x,y,cx,cy of combobox <br>      // <br> <br>      SetBkMode (ps.hdc, TRANSPARENT); <br> <br>      p.x = rect.right; <br>      p.y = (rect.bottom - 2*glcyMenu &lt; 0 ? 0 : rect.bottom - 2*glcyMenu); <br>      SetMapMode (ps.hdc, giMapMode); <br>      DPtoLP (ps.hdc, &amp;p, 1); <br> <br>      if ((giMapMode != MM_TEXT) &amp;&amp; (giMapMode != MM_ANISOTROPIC)) <br> <br>        // <br>        // p.y will come out negative because we started with origin in <br>        //   upper left corner <br>        // <br> <br>        p.y = -p.y; <br> <br>      SetMapMode (ps.hdc, MM_TEXT); <br>      sprintf (buf, "cxClient = %ld (%ld)", rect.right, p.x); <br>      TextOut (ps.hdc, iComboboxWidth + (int) 3*glcyMenu/2, (int) glcyMenu/8, <br>               buf, strlen (buf)); <br>      sprintf (buf, "cyClient = %ld (%ld)", <br>               rect.bottom - 2*glcyMenu &lt; 0 ? 0 : rect.bottom - 2*glcyMenu, <br>               p.y); <br>      TextOut (ps.hdc, iComboboxWidth + (int) 3*glcyMenu/2, <br>               (int) (glcyMenu/8 + lTextHeight), <br>               buf, strlen (buf)); <br> <br>      // <br>      // paint graphics background white <br>      // <br> <br>      rect.top    += 2*glcyMenu; <br>      FillRect (ps.hdc, &amp;rect, GetStockObject (WHITE_BRUSH)); <br> <br> <br>      if (rect.bottom &lt;= 4*glcyMenu) <br> <br>        // <br>        // we don't want to overpaint the toolbar, so just skip Paint() call <br>        // <br> <br>        goto done_painting; <br> <br>      // <br>      // set up a clip region so we don't draw all over our toolbar <br>      // <br> <br>      GetClientRect (hwnd, &amp;rect); <br>      rect.top += 2*glcyMenu; <br>      hrgn = CreateRectRgnIndirect (&amp;rect); <br>      SelectClipRgn (ps.hdc, hrgn); <br>      DeleteObject (hrgn); <br> <br>      // <br>      // set up view port, pens/brushes, &amp; map mode, then paint <br>      // <br> <br>      rect.top -= 2*glcyMenu; <br> <br>      if (giMapMode == MM_TEXT || giMapMode == MM_ANISOTROPIC) <br> <br>        SetViewportOrgEx (ps.hdc, glcyMenu, 3*glcyMenu, NULL); <br> <br>      else <br> <br>        SetViewportOrgEx (ps.hdc, glcyMenu, rect.bottom - glcyMenu, NULL); <br> <br>      rect.bottom -= 4*glcyMenu; <br>      rect.right  -= 2*glcyMenu; <br> <br>      hpen = CreatePen (giPenStyle, giPenWidth, gdwPenColor); <br>      SelectObject (ps.hdc, hpen); <br>      hbr  = CreateHatchBrush (giBrushStyle, gdwBrushColor); <br>      SelectObject (ps.hdc, hbr); <br> <br>      SetTextColor (ps.hdc, gdwTextColor); <br> <br>      SetMapMode (ps.hdc, giMapMode); <br>      Paint      (ps.hdc, &amp;rect); <br> <br>      DeleteObject (hpen); <br>      DeleteObject (hbr); <br> <br>done_painting: <br> <br>      EndPaint (hwnd, &amp;ps); <br>      break; <br>    } <br> <br>    case WM_CREATE: <br>    { <br>      HDC         hdc; <br>      TEXTMETRIC  tm; <br>      SIZE        size; <br>      HMENU       hmenu, hPenSubMenu, hBrushSubMenu; <br> <br>      // <br>      // initialize the globals <br>      // <br> <br>      glcyMenu = (LONG) GetSystemMetrics (SM_CYMENU); <br> <br>      hmenu                = GetMenu (hwnd); <br>      hMappingModesSubMenu = GetSubMenu (hmenu, 2); <br>      hGraphicsSubMenu     = GetSubMenu (hmenu, 3); <br>      hPenSubMenu          = GetSubMenu (hmenu, 4); <br>      hPenWidthSubMenu     = GetSubMenu (hPenSubMenu, 1); <br>      hPenStyleSubMenu     = GetSubMenu (hPenSubMenu, 2); <br>      hBrushSubMenu        = GetSubMenu (hmenu, 5); <br>      hBrushStyleSubMenu   = GetSubMenu (hBrushSubMenu, 1); <br> <br>      GetTextMetrics ((hdc = GetDC (hwnd)), &amp;tm); <br>      lTextHeight = tm.tmHeight; <br> <br>      // <br>      // create combobox to display current printers in. the width <br>      //   is caluculated by getting the text extent of a typical <br>      //   entry in the listbox. <br>      // <br> <br> <br>      #define ASTRING "long  printer  name;long  port  name;long  driver  name" <br> <br>      GetTextExtentPoint (hdc, ASTRING, sizeof (ASTRING), &amp;size); <br> <br>      iComboboxWidth = (int) size.cx; <br> <br>      ReleaseDC (hwnd, hdc); <br> <br>      hwndCombobox = CreateWindow ((LPCSTR) "COMBOBOX", (LPCSTR) "", <br>                                   WS_CHILD | WS_VISIBLE | CBS_DROPDOWN | WS_VSCROLL, <br>                                   (int) glcyMenu/2, <br>                                   (int) glcyMenu/2 - 2,  // - 2 = fudge factor <br>                                   iComboboxWidth, <br>                                   (int) 6*glcyMenu, <br>                                   hwnd, NULL, ghInst, NULL); <br> <br>      SetWindowLong (hwndCombobox, GWL_ID, ID_COMBOBOX); <br> <br>      PostMessage (hwnd, WM_COMMAND, <br>                   (WPARAM) MAKELONG (IDM_REFRESH, 0), <br>                   (LPARAM) 0); <br>      PostMessage (hwnd, WM_COMMAND, <br>                   (WPARAM) MAKELONG (IDM_POLYPOLYGON, 0), <br>                   (LPARAM) 0); <br>      break; <br>    } <br> <br>    case WM_DESTROY: <br> <br>      PostQuitMessage (0); <br>      break; <br> <br>    default: <br> <br>      return (DefWindowProc (hwnd, msg, wParam, lParam)); <br>  } <br>  return 0; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    AboutDlgProc (standard dialog procedure INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Handles "About" dialog messages <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK AboutDlgProc (HWND   hwnd, UINT msg, WPARAM wParam, <br>                               LPARAM lParam) <br>{ <br>  switch (msg) <br>  { <br>    case WM_INITDIALOG: <br> <br>      return TRUE; <br> <br>    case WM_COMMAND: <br> <br>      switch (LOWORD (wParam)) <br>      { <br>        case IDOK: <br> <br>          EndDialog (hwnd, TRUE); <br> <br>          return 1; <br>      } <br>      break; <br>  } <br>  return 0; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    InvalidateClient <br>* <br>*  COMMENTS:    Eliminates the flashing of the toolbar when we redraw <br>* <br>\******************************************************************************/ <br> <br>void InvalidateClient () <br>{ <br>  RECT rect; <br> <br>  GetClientRect (ghwndMain, &amp;rect); <br> <br>  rect.top += 2*glcyMenu; <br> <br>  InvalidateRect (ghwndMain, &amp;rect, TRUE); <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    RefreshPrinterCombobox <br>* <br>*  INPUTS:      hwndCombobox- handle of the toolbar combobox <br>* <br>*  COMMENTS:    The idea here is to enumerate all printers &amp; list them in <br>*               then combobox in the form: "DEVICE_NAME;PORT;DRIVER_NAME". <br>*               Then later, when a user selects one of these, we just <br>*               query out the string &amp; parse it apart, sticking the <br>*               appropriate parts into the DriverName, DeviceName, and <br>*               Port variables. <br>* <br>*               Also, the "Display" option is added to the combobox so <br>*               that user can get DevCaps info about it. <br>* <br>\******************************************************************************/ <br> <br>void RefreshPrinterCombobox (HWND hwndCombobox) <br>{ <br>  DWORD            dwFlags = PRINTER_ENUM_FAVORITE | PRINTER_ENUM_LOCAL; <br>  LPPRINTER_INFO_2 pPrinters; <br>  DWORD            cbPrinters; <br>  DWORD            cReturned, i; <br>  char             buf[256]; <br> <br>  SendMessage (hwndCombobox, CB_RESETCONTENT, 0, 0); <br> <br>  // <br>  // add the "Display" option to the combobox <br>  // <br> <br>  strcpy (buf, "Display"); <br>  SendMessage (hwndCombobox, CB_INSERTSTRING, (UINT)-1, (LONG) buf); <br> <br>  // <br>  // get byte count needed for buffer, alloc buffer, the enum the printers <br>  // <br> <br>  EnumPrinters (dwFlags, NULL, 2, NULL, 0, &amp;cbPrinters, <br>                &amp;cReturned); <br> <br>  if (!(pPrinters = (LPPRINTER_INFO_2) LocalAlloc (LPTR, cbPrinters + 4))) <br>  { <br>    MessageBox (ghwndMain, (LPCTSTR) GetStringRes(IDS_LALLOCFAIL), <br>                (LPCTSTR)GetStringRes2(ERR_MOD_NAME), MB_OK | MB_ICONEXCLAMATION); <br>    goto done_refreshing; <br>  } <br> <br> <br>  if (!EnumPrinters (dwFlags, NULL, 2, (LPBYTE) pPrinters, <br>                     cbPrinters, &amp;cbPrinters, &amp;cReturned)) <br>  { <br>    MessageBox (ghwndMain, (LPCTSTR) GetStringRes(IDS_ENUMPRTFAIL), <br>                (LPCTSTR) GetStringRes2(ERR_MOD_NAME), MB_OK | MB_ICONEXCLAMATION); <br>    goto done_refreshing; <br>  } <br> <br>  if (cReturned &gt; 0) <br> <br>    for (i = 0; i &lt; cReturned; i++) <br>    { <br>      // <br>      // for each printer in the PRINTER_INFO_2 array: build a string that <br>      //   looks like "DEVICE_NAME;PORT;DRIVER_NAME" <br>      // <br> <br>      strcpy (buf, (pPrinters + i)-&gt;pPrinterName); <br>      strcat (buf, ";"); <br>      strcat (buf, (pPrinters + i)-&gt;pPortName); <br>      strcat (buf, ";"); <br>      strcat (buf, (pPrinters + i)-&gt;pDriverName); <br> <br>      SendMessage (hwndCombobox, CB_INSERTSTRING, (UINT)-1, (LONG) buf); <br>    } <br> <br>  else <br> <br>    MessageBox (ghwndMain, GetStringRes(IDS_NOPRTLST), "PRINTER.EXE", MB_OK); <br> <br>done_refreshing: <br> <br>  SendMessage (hwndCombobox, CB_SELECTSTRING, (UINT) -1, (LONG) buf); <br> <br>  PostMessage (ghwndMain, WM_COMMAND, <br>               (WPARAM) MAKELONG (ID_COMBOBOX, CBN_SELCHANGE), <br>               (LPARAM) hwndCombobox); <br> <br>  LocalFree (LocalHandle (pPrinters)); <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    PrintThread <br>* <br>*  INPUTS:      wParam - wParam of a WM_COMMAND message containing menuitem id </code></pre>
<p>
</p>
<pre><code>* <br>*  COMMENTS:    This is the code for the print thread created when the user <br>*               selects the "Print" or "PrintDlg" menuitems. A thread is used <br>*               here more demostration purposes only, since we really don't <br>*               have any background processing to do. A real app would want <br>*               to have alot more error checking here (e.g. check return of <br>*               StartDoc, StartPage...). <br>* <br>\******************************************************************************/ <br> <br>void PrintThread (LPVOID wParam) <br>{ <br>DOCINFO di; <br>RECT    rect; <br>HPEN    hpen; <br>HBRUSH  hbr; <br> <br>switch (LOWORD((WPARAM) wParam)) { <br>    case IDM_PRINT: <br>{ <br>if (!strcmp (gszDeviceName, "Display")) <br>{ <br>MessageBox (ghwndMain, GetStringRes(IDS_ASKSELPRT), <br>                    "PRINTER.EXE:", MB_OK); <br>return; <br>} <br>else if (!(ghdc = CreateDC (gszDriverName, gszDeviceName, gszPort, NULL))) <br>{ <br>MessageBox (ghwndMain, "PrintThread(): CreateDC() failed", <br>                    GetStringRes2(ERR_MOD_NAME), MB_OK); <br>return; <br>} <br>break; <br>} <br> <br>    case IDM_PRINTDLG: <br>{ <br>PRINTDLG  pd; <br> <br>// <br>// Initialize a PRINTDLG struct and call PrintDlg to allow user to <br>//   specify various printing options... <br>// <br> <br>memset ((void *) &amp;pd, 0, sizeof(PRINTDLG)); <br> <br>pd.lStructSize = sizeof(PRINTDLG); <br>pd.hwndOwner   = ghwndMain; <br>pd.Flags       = PD_RETURNDC; <br>pd.hInstance   = NULL; <br> <br>PrintDlg(&amp;pd); <br>ghdc = pd.hDC; <br> <br>if (pd.hDevMode) <br> <br>GlobalFree (pd.hDevMode); <br> <br>if (pd.hDevNames) <br> <br>GlobalFree (pd.hDevNames); <br> <br>if (!ghdc) <br>{ <br>MessageBox (ghwndMain, GetStringRes(IDS_PRTDLGFAIL), <br>                    GetStringRes2(ERR_MOD_NAME), MB_OK); <br>return; <br>} <br>} <br>} <br> <br>// <br>// put up Abort &amp; install the abort procedure <br>// <br> <br>gbAbort = FALSE; <br>ghwndAbort = CreateDialog (ghInst, (LPCTSTR) "Abort", ghwndMain, <br>(DLGPROC) AbortDlgProc); <br>EnableWindow (ghwndMain, FALSE); <br>SetAbortProc (ghdc, AbortProc); <br> <br>// <br>// create &amp; select pen/brush <br>// <br> <br>hpen = CreatePen (giPenStyle, giPenWidth, gdwPenColor); <br>SelectObject (ghdc, hpen); <br> <br>hbr  = CreateHatchBrush (giBrushStyle, gdwBrushColor); <br>SelectObject (ghdc, hbr); <br> <br>SetTextColor (ghdc, gdwTextColor); <br> <br>SetMapMode (ghdc, giMapMode); <br> <br>SetRect(&amp;rect, 0,0, GetDeviceCaps (ghdc, HORZRES), GetDeviceCaps (ghdc, VERTRES)); <br> <br>di.cbSize      = sizeof(DOCINFO); <br>di.lpszDocName = GetStringRes(IDS_PRTTST); <br>di.lpszOutput  = NULL; <br> <br>StartDoc  (ghdc, &amp;di); <br> <br>if (gdwGraphicsOptions) { <br> <br>Paint (ghdc, &amp;rect); <br> <br>} else { <br>LPSTR pBuf = GetStringRes(IDS_BLANKPG);  <br>TextOut (ghdc, 5, 5, (LPCTSTR) pBuf, My_mbslen(pBuf)); <br>} <br> <br>// If we didn't abort the job <br>if (!gbAbort) <br>{ <br>EndPage   (ghdc);   <br>EndDoc    (ghdc); <br> <br>DestroyWindow (ghwndAbort); <br>} <br> <br>// Clean up <br>DeleteDC  (ghdc); <br>DeleteObject(hpen); <br>DeleteObject(hbr); <br> <br>EnableWindow  (ghwndMain, TRUE); <br>} <br>     <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    AbortProc <br>* <br>*  COMMENTS:    Standard printing abort proc <br>* <br>\******************************************************************************/ <br> <br>BOOL CALLBACK AbortProc (HDC hdc, int error) <br>{ <br>MSG msg; <br> <br>while (!gbAbort &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br> <br>if (!IsDialogMessage (ghwndAbort, &amp;msg)) { <br>TranslateMessage (&amp;msg); <br>DispatchMessage (&amp;msg); <br>} <br> <br>} <br> <br>return !gbAbort; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    AbortDlgProc (standard dialog procedure INPUTS/RETURNS) <br>* <br>*  COMMENTS:    Handles "Abort" dialog messages <br>* <br>\******************************************************************************/ <br> <br>LRESULT CALLBACK AbortDlgProc (HWND   hwnd, UINT msg, WPARAM wParam, <br>                               LPARAM lParam) <br>{ <br>switch (msg) { <br>    case WM_INITDIALOG: <br>EnableMenuItem (GetSystemMenu (hwnd, FALSE), SC_CLOSE, MF_GRAYED); <br>return TRUE; <br> <br>    case WM_COMMAND:   // There's only one  <br>switch (LOWORD (wParam)) { <br>case DID_CANCEL: <br>MessageBeep(MB_OK); <br>gbAbort = TRUE; <br>AbortDoc (ghdc); <br>DestroyWindow (hwnd); <br>break; <br>} <br>break; <br>} <br>return 0; <br>} <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> <br>LPTSTR   GetStringRes2 (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
