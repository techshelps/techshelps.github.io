<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAINT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3438"></a>PAINT.C</h2>
<pre><code><br>/******************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples.  <br>*       Copyright 1993 - 1998 Microsoft Corporation. <br>*       All rights reserved.  <br>*       This source code is only intended as a supplement to  <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the  <br>*       Microsoft samples programs. <br>\******************************************************************************/ <br> <br>/******************************************************************************\ <br>* <br>*  MODULE:      PAINT.C <br>* <br>*  PURPOSE:     Given an HDC and a pointer to a bounding rectangle <br>*               draw all graphics/fonts based on the flags set in <br>*               the dwGraphicsOptions global variable. <br>* <br>*  FUNTIONS:    Paint              - main painting routine <br>*               GetFirstGraphicSlot- computes bounding rect of 1st <br>*                                      graphic <br>*               GetNextGraphicSlot - computes bounding rect of next <br>*                                      graphic <br>*               DrawFonts          - draws enumerated fonts <br>*               BuildFontList      - builds a list of fonts of fonts <br>*                                      supported by a given DC <br>*               MyEnumFaces        - enumerates the font facenames <br>*                                      supported by a given DC <br>*               MyEnumCopy         - copies LOGFONT &amp; TEXTMETRIC info <br>*                                      to a global variable <br>*               MyEnumCount        - counts total number of fonts <br>*                                      supported by a given DC <br>*               FreeFontList       - frees a (BuildFontList-) font list <br>* <br>*  COMMENTS:    Most of the font-enumeration code "lifted" from NTF.EXE <br>*               sample. For more complete documentation have a look a <br>*               that. <br>* <br>\******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "common.h" <br>#include "paint.h" <br>#include "resource.h" <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    Paint <br>* <br>*  INPUTS:      hdc    - device context to paint <br>*               lpRect - bounding rectangle of device to paint <br>* <br>*  RETURNS:     TRUE if painting went ok, or <br>*               FALSE if error while painting <br>* <br>\******************************************************************************/ <br> <br>BOOL Paint (HDC hdc, LPRECT lpRect) <br>{ <br>RECT  rect; <br>HPEN  hpenSave; <br>RECTI ri; <br> <br>if (gdwGraphicsOptions &amp; DRAWAXIS) <br>{ <br>// <br>// draw axis <br>// <br> <br>rect = *lpRect; <br> <br>hpenSave = SelectObject (hdc, GetStockObject (BLACK_PEN)); <br> <br>// <br>// if giMapMode == MM_TEXT, MM_ANISOTROPIC then (0,0) is upper left corner <br>// <br> <br>if (giMapMode == MM_TEXT || giMapMode == MM_ANISOTROPIC) <br>{ <br>MoveToEx (hdc, rect.left - glcyMenu/2, rect.bottom, NULL); <br>LineTo   (hdc, rect.left,  rect.bottom + glcyMenu/2); <br>LineTo   (hdc, rect.left + glcyMenu/2,  rect.bottom); <br> <br>MoveToEx (hdc, rect.left,  rect.bottom + glcyMenu/2, NULL); <br>LineTo   (hdc, rect.left,  rect.top); <br>LineTo   (hdc, rect.right + glcyMenu/2, rect.top); <br> <br>MoveToEx (hdc, rect.right, rect.top - glcyMenu/2, NULL); <br>LineTo   (hdc, rect.right + glcyMenu/2,  rect.top); <br>LineTo   (hdc, rect.right,  rect.top + glcyMenu/2); <br>} <br> <br>// <br>// else (0,0) is lower left corner <br>// <br> <br>else <br>{ <br>MoveToEx (hdc, rect.left - glcyMenu/2, rect.bottom, NULL); <br>LineTo   (hdc, rect.left,  rect.bottom + glcyMenu/2); <br>LineTo   (hdc, rect.left + glcyMenu/2,  rect.bottom); <br> <br>MoveToEx (hdc, rect.left,  rect.bottom + glcyMenu/2, NULL); <br>LineTo   (hdc, rect.left,  rect.top); <br>LineTo   (hdc, rect.right + glcyMenu/2, rect.top); <br> <br>MoveToEx (hdc, rect.right, rect.top + glcyMenu/2, NULL); <br>LineTo   (hdc, rect.right + glcyMenu/2, rect.top); <br>LineTo   (hdc, rect.right, rect.top - glcyMenu/2); <br>} <br> <br>SelectObject (hdc, hpenSave); <br>} <br> <br>// <br>// look at bits in gdwGraphicsOptions &amp; determine which graphics to draw <br>// <br> <br>if (gdwGraphicsOptions &amp; ENUMFONTS) <br>{ <br>DrawFonts (hdc, lpRect); <br>return TRUE; <br>} <br> <br>giDeltaX = (int) ((lpRect-&gt;right - BORDER) / NUM_GRAPHICS_XSLOTS); <br>giDeltaY = (int) ((lpRect-&gt;bottom - lpRect-&gt;top - BORDER) <br>/ NUM_GRAPHICS_YSLOTS); <br> <br>GetFirstGraphicSlot (lpRect, &amp;ri); <br> <br>if (gdwGraphicsOptions &amp; ARC) <br>{ <br>Arc (hdc, ri.left, ri.top, ri.right, ri.bottom, <br>ri.left, ri.top, ri.right-10, ri.bottom-10); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; ELLIPSE) <br>{ <br>Ellipse (hdc, ri.left, ri.top, ri.right, ri.bottom); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; LINETO) <br>{ <br>int i; <br> <br>for (i = PS_SOLID; i &lt;= PS_DASHDOTDOT; i++) <br>{ <br>MoveToEx (hdc, ri.left, ri.top + (i+1)*giDeltaY/7, NULL); <br>LineTo   (hdc, ri.right, ri.top + (i+1)*giDeltaY/7); <br>} <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; PIE) <br>{ <br>Pie (hdc, ri.left, ri.top, ri.right, ri.bottom, <br>ri.left, ri.top, ri.right-10, ri.bottom-10); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; PLG_BLT) <br>{ <br>HBITMAP hbm; <br>BITMAP  bm; <br>HDC     hdcMem; <br>POINT   ap[3]; <br> <br>hbm = LoadBitmap (ghInst, "printer"); <br>hdcMem = CreateCompatibleDC (hdc); <br>SelectObject (hdcMem, hbm); <br> <br>GetObject (hbm, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>// <br>// special case here because PlgBlt requires coordinates <br>//   of upper left, upper right, &amp; lower left <br>// <br> <br>ap[0].x = (LONG) (ri.left + (ri.right - ri.left)/4); <br>ap[0].y = (LONG) (ri.top + (ri.bottom - ri.top)/4); <br>ap[1].x = (LONG) ri.right; <br>ap[1].y = (LONG) ri.top; <br>ap[2].x = (LONG) ri.left; <br>ap[2].y = (LONG) ri.bottom; <br> <br>PlgBlt (hdc, ap, hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, NULL, 0, 0); <br> <br>DeleteDC(hdcMem); <br>DeleteObject(hbm); <br>GetNextGraphicSlot (&amp;ri); <br> <br>} <br> <br>if (gdwGraphicsOptions &amp; POLYBEZIER) <br>{ <br>POINT ap[4]; <br> <br>ap[0].x  = (LONG) ri.left;    ap[0].y = (LONG) ri.top; <br>ap[1].x  = (LONG) ri.left;    ap[1].y = (LONG) ri.bottom; <br>ap[2].x  = (LONG) ri.right;   ap[2].y = (LONG) ri.top; <br>ap[3].x  = (LONG) ri.right;   ap[3].y = (LONG) ri.bottom; <br> <br>PolyBezier (hdc, ap, 4); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; POLYGON) <br>{ <br>POINT ap[5]; <br> <br>ap[0].x  = (LONG) ri.left;    ap[0].y = (LONG) ri.top; <br>ap[1].x  = (LONG) ri.right;   ap[1].y = (LONG) ri.bottom; <br>ap[2].x  = (LONG) ri.right;   ap[2].y = (LONG) ri.top; <br>ap[3].x  = (LONG) ri.left;    ap[3].y = (LONG) ri.bottom; <br>ap[4].x  = (LONG) ri.left;    ap[4].y = (LONG) ri.top; <br> <br>Polygon (hdc, ap, 4); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; POLYLINE) <br>{ <br>POINT ap[4]; <br> <br>ap[0].x  = (LONG) ri.left;    ap[0].y = (LONG) ri.top; <br>ap[1].x  = (LONG) ri.left;    ap[1].y = (LONG) ri.bottom; <br>ap[2].x  = (LONG) ri.right;   ap[2].y = (LONG) ri.top; <br>ap[3].x  = (LONG) ri.right;   ap[3].y = (LONG) ri.bottom; <br> <br>Polyline (hdc, ap, 4); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; POLYPOLYGON) <br>{ <br>POINT ap[8]; <br>int ai[2] = { 4, 4 }; <br> <br>ap[0].x = (LONG)  ri.left; <br>ap[0].y = (LONG)  ri.top; <br>ap[1].x = (LONG) (ri.left + giDeltaX/4); <br>ap[1].y = (LONG)  ri.top; <br>ap[2].x = (LONG) (ri.left + giDeltaX/4); <br>ap[2].y = (LONG) (ri.top  + giDeltaY/4); <br>ap[3].x = (LONG)  ri.left; <br>ap[3].y = (LONG) (ri.top  + giDeltaY/4); <br>ap[4].x = (LONG) (ri.right  - 2*giDeltaX/3); <br>ap[4].y = (LONG) (ri.bottom - 2*giDeltaY/3); <br>ap[5].x = (LONG)  ri.right; <br>ap[5].y = (LONG) (ri.bottom - 2*giDeltaY/3); <br>ap[6].x = (LONG)  ri.right; <br>ap[6].y = (LONG)  ri.bottom; <br>ap[7].x = (LONG) (ri.right  - 2*giDeltaX/3); <br>ap[7].y = (LONG)  ri.bottom; <br> <br>PolyPolygon (hdc, ap, ai, 2); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; RECTANGLE) <br>{ <br>Rectangle (hdc, ri.left, ri.top, ri.right, ri.bottom); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; ROUNDRECT) <br>{ <br>RoundRect (hdc, ri.left, ri.top, ri.right, ri.bottom, 15, 25); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>if (gdwGraphicsOptions &amp; STRETCH_BLT) <br>{ <br>HBITMAP hbm; <br>BITMAP  bm; <br>HDC     hdcMem; <br> <br>hbm = LoadBitmap (ghInst, "printer"); <br>hdcMem = CreateCompatibleDC (hdc); <br>SelectObject (hdcMem, hbm); <br> <br>GetObject (hbm, sizeof(BITMAP), (LPSTR)&amp;bm); <br> <br>StretchBlt (hdc, ri.left, ri.top, ri.right-ri.left, <br>ri.bottom - ri.top, hdcMem, 0, 0, <br>bm.bmWidth, bm.bmHeight, SRCCOPY); <br> <br>DeleteDC(hdcMem); <br>DeleteObject(hbm); <br>GetNextGraphicSlot (&amp;ri); <br>} <br> <br>return TRUE; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetFirstGraphicSlot <br>* <br>*  INPUTS:      pri - pointer to a RECTI <br>* <br>\******************************************************************************/ <br> <br>void GetFirstGraphicSlot (LPRECT lpRect, PRECTI pri) <br>{ <br>  pri-&gt;left   = BORDER; <br>  pri-&gt;top    = lpRect-&gt;top + BORDER; <br>  pri-&gt;right  = giDeltaX; <br>  pri-&gt;bottom = giDeltaY; <br> <br>  giColumn = 1; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetNextGraphicSlot <br>* <br>*  INPUTS:      pri - pointer to a RECTI <br>* <br>\******************************************************************************/ <br> <br>void GetNextGraphicSlot (PRECTI pri) <br>{ <br>  if (++giColumn &lt;= NUM_GRAPHICS_XSLOTS) <br>  { <br>    pri-&gt;left  += giDeltaX; <br>    pri-&gt;right += giDeltaX; <br>  } <br>  else <br>  { <br>    giColumn = 1; <br> <br>    pri-&gt;left   =  BORDER; <br>    pri-&gt;top    += giDeltaY; <br>    pri-&gt;right  =  giDeltaX; <br>    pri-&gt;bottom += giDeltaY; <br>  } <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    DrawFonts <br>* <br>*  INPUTS:      hdc   - device context to enumerate from &amp; draw on <br>*               pRect - pointer to bounding rect to draw fonts in <br>* <br>*  LOCAL VARS:  i, j       - loop variables <br>*               xText      - starting x position to draw text <br>*               yText      - starting y position to draw text <br>*               iMaxStrLen - length in pels of string to draw <br>* <br>\******************************************************************************/ <br> <br>void DrawFonts (HDC hdc, LPRECT lpRect) <br>{ <br>  int      i, j, xText, yText, iMaxStrLen = 0; <br>  PARFONTS paf; <br> <br>  paf = BuildFontList (hdc); <br> <br>  xText = yText = 2; <br> <br>  // <br>  // set the appropriate text align mode depending on <br>  //   whether we're drawing from top down or bottom up <br>  // <br> <br>  if (giMapMode == MM_TEXT | giMapMode == MM_ANISOTROPIC) <br> <br>    SetTextAlign (hdc, TA_TOP); <br> <br>  else <br> <br>    SetTextAlign (hdc, TA_BOTTOM); <br> <br>  for (i = 0; i &lt; nFaces; i++) <br>  { <br>    for (j = 0; j &lt; (paf + i)-&gt;nFonts; j++) <br>    { <br>      HFONT      hFont, hSaveFont; <br>      SIZE       size; <br>      POINT      LogPtExtent; <br> <br>      LogPtExtent.x = lpRect-&gt;right; <br>      LogPtExtent.y = lpRect-&gt;bottom; <br> <br>      hFont = CreateFontIndirect ((paf + i)-&gt;lf + j); <br> <br>      hSaveFont = SelectObject (hdc, hFont); <br> <br>      TextOut (hdc, xText, yText, ((paf + i)-&gt;lf + j)-&gt;lfFaceName, <br>               strlen(((paf + i)-&gt;lf + j)-&gt;lfFaceName)); <br> <br>      GetTextExtentPoint (hdc, ((paf + i)-&gt;lf + j)-&gt;lfFaceName, <br>                          strlen(((paf+i)-&gt;lf+j)-&gt;lfFaceName), <br>                          &amp;size); <br>      size.cx += 2; <br>      iMaxStrLen = iMaxStrLen &gt; (int)size.cx ? iMaxStrLen: (int) size.cx; <br> <br>      if (!(i == (nFaces - 1) &amp;&amp; j == ((paf + i)-&gt;nFonts - 1))) <br>      { <br>        TEXTMETRIC *pNextTM; <br> <br>        pNextTM = j &lt; ((paf+i)-&gt;nFonts-1) ? <br>                          (paf+i)-&gt;tm+j+1 : (paf+i+1)-&gt;tm; <br> <br>        // <br>        // add in the height of the face name we just drew <br>        // <br> <br>        yText += (int) ((paf + i)-&gt;tm + j)-&gt;tmHeight; <br> <br>        // <br>        // if the next facename will be drawn outside the bounding rect then <br>        //   start at first line of next column <br>        // <br> <br>        if (yText + (int) pNextTM-&gt;tmHeight &gt; (int) LogPtExtent.y) <br>        { <br>          yText = 2; <br>          xText += iMaxStrLen + 2; <br>          iMaxStrLen = 0; <br>        } <br>      } <br> <br>      SelectObject (hdc, hSaveFont); <br>      DeleteObject (hFont); <br> <br>      if (xText &gt; (int) LogPtExtent.x) <br>      { <br>        if (GetDeviceCaps (hdc, TECHNOLOGY) &amp; DT_RASDISPLAY) <br>        { <br>          // <br>          // If we're drawing to the screen &amp; have run out of <br>          //   room then tell user how many fonts there are left <br>          //   (that we haven't displayed) <br>          // <br> <br>          int   k; <br>          int   iFontsLeft = (paf + i)-&gt;nFonts - j - 1; <br>          char  buf[40]; <br>          SIZE  size; <br> <br> <br>          for (k = i + 1; k &lt; nFaces; k++) <br> <br>            iFontsLeft += (paf + k)-&gt;nFonts; <br> <br>          wsprintf (buf, GetStringRes(IDS_FMT_MOREDSPFNTNL), <br>                    iFontsLeft); <br> <br>          GetTextExtentPoint (hdc, buf, strlen(buf), &amp;size); <br> <br>          if ((xText = lpRect-&gt;right - size.cx) &lt; glcyMenu + 1) <br> <br>            xText = glcyMenu/2 + 1; <br> <br>          TextOut (hdc, xText, lpRect-&gt;bottom, buf, strlen(buf)); <br> <br>          goto done_enumfonts; <br>        } <br> <br>        else <br>        { <br>          // <br>          // Else we're drawing to a printer &amp; have filled up <br>          //   the first page. If there's any fonts left to draw <br>          //   then start a new page. <br>          // <br> <br>          if (!(i == nFaces - 1 &amp;&amp; j == (paf + i)-&gt;nFonts - 1)) <br>          { <br>            EndPage   (hdc); <br>            xText = yText = 2; <br>            StartPage (hdc); <br>          } <br>        } <br>      } <br>    } <br>  } <br> <br>done_enumfonts: <br> <br>  FreeFontList (paf); <br>} <br> <br> <br> <br> <br>/*  In the callback functions for the enumerations, there is a limited <br> *  ability to pass in parameters.  For that reason, declare the following <br> *  global variables to be used by any of the call back functions. <br> * <br> *        HDC      hdcGlobal; <br> *        PARFONTS parFontsGlobal; <br> *        int      iFace,jFont; <br> *        int      nFaces; <br> * <br> * <br> * General call structure: <br> * <br> *        BuildFontList <br> *            EnumFonts <br> *                MyEnumCount <br> *            LocalAlloc <br> *            EnumFonts <br> *                MyEnumFaces <br> *                    EnumFonts <br> *                        MyEnumCount <br> *                    LocalAlloc <br> *                    LocalAlloc <br> *                    LocalAlloc <br> *                    EnumFonts <br> *                        MyEnumCopy <br> */ <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    BuildFontList <br>* <br>*  GLOBAL VARS: (see above) <br>* <br>\******************************************************************************/ <br> <br>PARFONTS BuildFontList (HDC hdcIn) <br>{ <br>  nFaces = 0; <br> <br>  hdcGlobal = hdcIn; <br> <br>  // <br>  // count the total number of face names. <br>  // <br> <br>  EnumFonts (hdcGlobal, NULL, (FONTENUMPROC)MyEnumCount, (LPARAM)&amp;nFaces); <br> <br>  // <br>  // allocate the pointer to the array of PArFont structures. <br>  // <br> <br>  parFontsGlobal = (PARFONTS) LocalAlloc (LPTR, sizeof(ARFONTS) * (nFaces+1)); <br> <br>  // <br>  // step through all fonts again.  For each one fill a LOGFONT and <br>  //   a TEXTMETRIC stucture. <br>  // <br> <br>  iFace = 0; <br>  EnumFonts (hdcGlobal, NULL, (FONTENUMPROC)MyEnumFaces, 0); <br> <br>  return parFontsGlobal; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    MyEnumFaces <br>* <br>*  GLOBAL VARS: (see above) <br>* <br>\******************************************************************************/ <br> <br>int CALLBACK MyEnumFaces (LPLOGFONT lpLogFont, LPTEXTMETRIC lpTEXTMETRICs, <br>                          DWORD fFontType, LPVOID  lpData) <br>{ <br>  int nFonts; <br> <br>  nFonts = 0; <br>  EnumFonts (hdcGlobal, lpLogFont-&gt;lfFaceName, (FONTENUMPROC)MyEnumCount, <br>             (LPARAM)&amp;nFonts); <br> <br>  parFontsGlobal[iFace].lf   = (LOGFONT *)    LocalAlloc (LPTR, <br>                                                          sizeof(LOGFONT) * <br>                                                            nFonts); <br>  parFontsGlobal[iFace].tm   = (TEXTMETRIC *) LocalAlloc (LPTR, <br>                                                          sizeof(TEXTMETRIC) * <br>                                                            nFonts); <br>  parFontsGlobal[iFace].Type = (int *)        LocalAlloc (LPTR, <br>                                                          sizeof(int) * <br>                                                            nFonts); <br> <br>  if ((parFontsGlobal[iFace].lf   == NULL) || <br>      (parFontsGlobal[iFace].tm   == NULL) || <br>      (parFontsGlobal[iFace].Type == NULL)) <br>  { <br>    ErrMsgBox (GetStringRes(IDS_LALLOCFAIL), ERR_MOD_NAME); <br>    return FALSE; <br>  } <br> <br>  parFontsGlobal[iFace].nFonts = nFonts; <br> <br>  jFont = 0; <br>  EnumFonts (hdcGlobal, lpLogFont-&gt;lfFaceName, (FONTENUMPROC)MyEnumCopy, 0); <br> <br>  iFace++; <br> <br>  return TRUE; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    MyEnumCopy <br>* <br>*  GLOBAL VARS: (see above) <br>* <br>\******************************************************************************/ <br> <br>int CALLBACK MyEnumCopy (LPLOGFONT lpLogFont, LPTEXTMETRIC lpTEXTMETRICs, <br>                         DWORD fFontType, LPVOID  lpData) <br>{ <br>  LOGFONT    *lplf; <br>  TEXTMETRIC *lptm; <br>  int        *pType; <br> <br>  lplf  = parFontsGlobal[iFace].lf; <br>  lptm  = parFontsGlobal[iFace].tm; <br>  pType = parFontsGlobal[iFace].Type; <br> <br>  lplf[jFont]  = *lpLogFont; <br>  lptm[jFont]  = *lpTEXTMETRICs; <br>  pType[jFont] = fFontType; <br> <br>  jFont++; <br>  return TRUE; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    MyEnumCount <br>* <br>*  GLOBAL VARS: (see above) <br>* <br>\******************************************************************************/ <br> <br>int CALLBACK MyEnumCount (LPLOGFONT lpLogFont, LPTEXTMETRIC lpTEXTMETRICs, <br>                          DWORD fFontType, LPVOID lpData) <br>{ <br>  (*(LPINT)lpData)++; <br>  return TRUE; <br>} <br> <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    FreeFontList <br>* <br>*  INPUTS:      paf - pointer to ARFONTS struct to free <br>* <br>\******************************************************************************/ <br> <br>void FreeFontList (PARFONTS paf) <br>{ <br>  int i; <br> <br>  for (i = 0; i &lt; nFaces; i++) <br>  { <br>    LocalFree (LocalHandle ((LPSTR) ((paf + i)-&gt;lf  ))); <br>    LocalFree (LocalHandle ((LPSTR) ((paf + i)-&gt;tm  ))); <br>    LocalFree (LocalHandle ((LPSTR) ((paf + i)-&gt;Type))); <br>  } <br>  LocalFree (LocalHandle ((LPSTR) paf)); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
