<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEXTFX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3463"></a>TEXTFX.C</h2>
<pre><code>/*****************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\*****************************************************************************/ <br>/***************************************************************************** <br> * * <br> *   PROGRAM: TextFX.c * <br> * * <br> *   PURPOSE: TextFX template for Windows applications * <br> * * <br> *   FUNCTIONS: * <br> * * <br> *   GetLastErrorBox() - Report GetLastError() values as text                * <br> *   WinMain() - calls initialization function, processes message loop * <br> *   InitApplication() - initializes window data and registers window * <br> *   InitInstance() - saves instance handle and creates main window * <br> *   WndProc() - processes messages * <br> *   CenterWindow() - used to center the "About" box over application window * <br> *   About() - processes messages for "About" dialog box * <br> * * <br> *   COMMENTS: * <br> *****************************************************************************/ <br> <br>#include &lt;windows.h&gt;   // required for all Windows applications <br>#include "resource.h"  // specific to this program <br>#include &lt;time.h&gt; <br>#include "textfx.h"    // specific to this program <br>#include "guide.h" <br>#include "fx.h" <br> <br>#define QUICKTESTPOINTS 2      // Number of points to use for Quick Test <br> <br>HINSTANCE hInst;       // current instance <br> <br>char szAppName[] = "TextFX";   // The name of this application <br>char szTitle[]   = "TextFX Test Application"; // The title bar text <br> <br>// Random number stuff for generating random points for "Quick Test" option <br>#define randfloat() ((float)rand() / (float)RAND_MAX) <br>#define random(i) ((short)(randfloat() * (float)(i))) <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  GetLastErrorBox(HWND, LPSTR)                            *   <br> *  * <br> * PURPOSE:   Gets the error status and, if an error is indicated,    * <br> *            converts the error number into text and displays it     * <br> *            in a MessageBox.                                        * <br> *                                                                    * <br> *********************************************************************/ <br>DWORD GetLastErrorBox(HWND hWnd, LPSTR lpTitle) <br>{ <br>   LPVOID lpv; <br>   DWORD  dwRv; <br> <br>   if (GetLastError() == 0) return 0; <br>    <br>   dwRv = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>                        FORMAT_MESSAGE_FROM_SYSTEM, <br>                        NULL, <br>                        GetLastError(), <br>                        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), <br>                        (LPVOID)&amp;lpv, <br>                        0, <br>                        NULL); <br>    <br>   MessageBox(hWnd, lpv, lpTitle, MB_OK); <br>    <br>   if(dwRv) <br>      LocalFree(lpv); <br>    <br>   SetLastError(0); <br>   return dwRv; <br>} <br> <br>/***************************************************************************** <br> * * <br> * FUNCTION: WinMain(HINSTANCE, HINSTANCE, LPSTR, int) * <br> * * <br> * PURPOSE: calls initialization function, processes message loop * <br> * * <br> * COMMENTS: * <br> * * <br> *    Windows recognizes this function by name as the initial entry point * <br> *    for the program.  This function calls the application initialization * <br> *    routine, if no other instance of the program is running, and always * <br> *    calls the instance initialization routine.  It then executes a message * <br> *    retrieval and dispatch loop that is the top-level control structure * <br> *    for the remainder of execution.  The loop is terminated when a WM_QUIT * <br> *    message is received, at which time this function exits the application * <br> *    instance by returning the value passed by PostQuitMessage(). * <br> * * <br> *    If this function must abort before entering the message loop, it * <br> *    returns the conventional value NULL. * <br> * * <br> ****************************************************************************/ <br>int APIENTRY WinMain( <br>        HINSTANCE hInstance, <br>        HINSTANCE hPrevInstance, <br>        LPSTR lpCmdLine, <br>        int nCmdShow) <br>{ <br>    MSG msg; <br>    HANDLE hAccelTable; <br>LONG lTime; <br> <br>// Just for fun, lets seed the random number generator <br>time(&amp;lTime); <br>    srand(lTime); <br> <br> <br>    if (!hPrevInstance) {       // Other instances of app running? <br>            if (!InitApplication(hInstance)) { // Initialize shared things <br>            return (FALSE);     // Exits if unable to initialize <br>        } <br>    } <br> <br>    /* Perform initializations that apply to a specific instance */ <br> <br>    if (!InitInstance(hInstance, nCmdShow)) { <br>            return (FALSE); <br>    } <br> <br>    hAccelTable = LoadAccelerators (hInstance, "TEXTFXACCEL"); <br> <br>    /* Acquire and dispatch messages until a WM_QUIT message is received. */ <br> <br>    while (GetMessage(&amp;msg, // message structure <br>       NULL,   // handle of window receiving the message <br>       0,      // lowest message to examine <br>       0))     // highest message to examine <br>    { <br>        if (!TranslateAccelerator (msg.hwnd, hAccelTable, &amp;msg)) { <br>            TranslateMessage(&amp;msg);// Translates virtual key codes <br>            DispatchMessage(&amp;msg); // Dispatches message to window <br>        } <br>    } <br> <br>    return (msg.wParam); // Returns the value from PostQuitMessage <br> <br>    UNREFERENCED_PARAMETER(lpCmdLine); // This will prevent 'unused formal parameter' warnings <br>} <br> <br> <br>/***************************************************************************** <br> * * <br> *  FUNCTION: InitApplication(HINSTANCE) * <br> * * <br> *  PURPOSE: Initializes window data and registers window class * <br> * * <br> *  COMMENTS: * <br> * * <br> *    This function is called at initialization time only if no other * <br> *    instances of the application are running.  This function performs     * <br> *    initialization tasks that can be done once for any number of running * <br> *    instances. * <br> * * <br> *    In this case, we initialize a window class by filling out a data * <br> *    structure of type WNDCLASS and calling the Windows RegisterClass() * <br> *    function.  Since all instances of this application use the same window * <br> *    class, we only need to do this when the first instance is initialized. * <br> * * <br> *****************************************************************************/ <br>BOOL InitApplication(HINSTANCE hInstance) <br>{ <br>    WNDCLASS  wc; <br> <br>    // Fill in window class structure with parameters that describe the <br>    // main window. <br> <br>    wc.style         = CS_OWNDC;               // Class style(s). <br>    wc.lpfnWndProc   = (WNDPROC)WndProc;       // Window Procedure <br>    wc.cbClsExtra    = 0;                      // No per-class extra data. <br>    wc.cbWndExtra    = 0;                      // No per-window extra data. <br>    wc.hInstance     = hInstance;              // Owner of this class <br>    wc.hIcon         = LoadIcon (hInstance, szAppName); // Icon name from .RC <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);// Cursor <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);// Default color <br>    wc.lpszMenuName  = "TEXTFXMENU";           // Menu name from .RC <br>    wc.lpszClassName = szAppName;              // Name to register as <br> <br>    // Register the window class and return success/failure code. <br>    return (RegisterClass(&amp;wc)); <br>} <br> <br> <br>/***************************************************************************** <br> * * <br> *   FUNCTION:  InitInstance(HINSTANCE, int) * <br> * * <br> *   PURPOSE:  Saves instance handle and creates main window * <br> * * <br> *   COMMENTS: * <br> * * <br> *      This function is called at initialization time for every instance of * <br> *      this application.  This function performs initialization tasks that * <br> *      cannot be shared by multiple instances. * <br> * * <br> *      In this case, we save the instance handle in a static variable and * <br> *      create and display the main program window. * <br> * * <br> ****************************************************************************/ <br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    HWND            hWnd; // Main window handle. <br> <br>    // Save the instance handle in static variable, which will be used in <br>    // many subsequence calls from this application to Windows. <br> <br>    hInst = hInstance; // Store instance handle in our global variable <br> <br>    // Create a main window for this application instance. <br> <br>    hWnd = CreateWindow( <br>            szAppName,           // See RegisterClass() call. <br>            szTitle,             // Text for window title bar. <br>            WS_OVERLAPPEDWINDOW,// Window style. <br>            CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, // Use default positioning <br>            NULL,                // Overlapped windows have no parent. <br>            NULL,                // Use the window class menu. <br>            hInstance,           // This instance owns this window. <br>            NULL                 // We don't use any data in our WM_CREATE <br>    ); <br> <br>    // If window could not be created, return "failure" <br>    if (!hWnd) { <br>            return (FALSE); <br>    } <br> <br>    // Make the window visible; update its client area; and return "success" <br>    ShowWindow(hWnd, nCmdShow); // Show the window <br>    UpdateWindow(hWnd);         // Sends WM_PAINT message <br> <br>    return (TRUE);              // We succeeded... <br> <br>} <br>   <br> <br>/***************************************************************************** <br> * * <br> *   FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM) * <br> * * <br> *   PURPOSE:  Processes messages * <br> * * <br> *   MESSAGES: * <br> * * <br> *   WM_COMMAND    - application menu (About dialog box) * <br> *   WM_DESTROY    - destroy window * <br> * * <br> *   COMMENTS: * <br> * * <br> *   To process the IDM_ABOUT message, call MakeProcInstance() to get the * <br> *   current instance address of the About() function.  Then call Dialog * <br> *   box which will create the box according to the information in your * <br> *   TextFX.rc file and turn control over to the About() function.  When * <br> *   it returns, free the intance address. * <br> * * <br> ****************************************************************************/ <br>LRESULT CALLBACK WndProc( <br>                HWND hWnd,         // window handle <br>                UINT message,      // type of message <br>                WPARAM uParam,     // additional information <br>                LPARAM lParam)     // additional information <br>{ <br>int wmId, wmEvent; <br>    static BOOL bOn = TRUE;  // Which guide line (top = TRUE) are we on? <br>    static LPPOINT lpTop = NULL; <br>static LPPOINT lpBot = NULL; <br>    static DWORD dwTop = 0; <br>static DWORD dwBot = 0; <br>static BOOL bOutlineOnly = FALSE; <br>static BOOL bShowGuides  = FALSE; <br>    static HPEN hpenBlue, hpenRed; <br> <br>SetLastError(0); // Set error flag to "no errors" <br> <br>switch (message) {  <br>    case WM_CREATE:  // Select an big Arial font into our DC  <br>    { <br>    HDC hDC = GetDC(hWnd); <br>                LOGFONT lf; <br>HFONT hf; <br> <br>    memset(&amp;lf, 0, sizeof(LOGFONT)); <br>    lf.lfHeight = -72;// Big fonts scale better <br>        strcpy((LPSTR)&amp;(lf.lfFaceName), "arial"); <br>           <br>    // Create and select the font <br>    hf = CreateFontIndirect(&amp;lf);  <br>    SelectObject(hDC, hf); <br> <br>hpenBlue = CreatePen(PS_SOLID, 1, RGB(0,0,255)); <br>hpenRed  = CreatePen(PS_SOLID, 1, RGB(255,0,0)); <br>} <br> <br>GetLastErrorBox(hWnd, "Error in WM_CREATE"); <br>break; <br> <br>case WM_PAINT:  <br>            { <br>   PAINTSTRUCT ps; <br>   HDC hDC = BeginPaint(hWnd, &amp;ps); <br>               RECT rect; <br>                   <br>   // Clear the client area  <br>               GetClientRect(hWnd, &amp;rect); <br>              PatBlt(hDC, 0, 0, rect.right, rect.bottom, WHITENESS); <br>            <br>       <br>      // If we have something to show... <br>      if (dwTop &amp;&amp; dwBot) { <br> <br>       // Show the top guide line if we have one and the user wants to <br>       if (dwTop &amp;&amp; bShowGuides) { <br>                     SelectObject(hDC, hpenBlue); <br>                     ShowGuide(hDC, lpTop, dwTop); <br>                     SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>                   } <br>    <br>       // If we have a bottom guide line <br>       if (dwBot) {                      <br>        <br>              // ...then show it if the use wants to <br>               if (bShowGuides) { <br>                 SelectObject(hDC, hpenRed); <br>                         ShowGuide(hDC, lpBot, dwBot); <br>             SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>                       }      <br>   <br>               // Do the mapping and show the text <br>               TextEffect(hDC, lpTop, lpBot, dwTop, dwBot, "This is a test", bOutlineOnly);  <br>                   } <br>               } <br> <br>               EndPaint(hWnd, &amp;ps); <br>} <br>            break; <br> <br>case WM_LBUTTONDOWN: // Read a guide line from the user <br>            { <br>               HDC hDC = GetDC(hWnd);                    <br>               RECT rect;     <br>                <br>               if (bOn) { <br>                   GetClientRect(hWnd, &amp;rect); <br>                    <br>                   // Clear the screen <br>                   PatBlt(hDC, 0, 0, rect.right, rect.bottom, WHITENESS); <br>                    <br>                   // Get rid of the previous guide lines <br>                   if (lpTop)  <br>                     GlobalFree(lpTop); <br>                   if (lpBot)  <br>                     GlobalFree(lpBot); <br>       dwBot = 0; <br> <br>   SelectObject(hDC, hpenBlue);  // Top guide line is blue <br>                   GetGuideLine(hWnd, &amp;lpTop, &amp;dwTop); <br>               } <br>               else { <br>                   SelectObject(hDC, hpenRed);// Bottom guide line is red <br>                   GetGuideLine(hWnd, &amp;lpBot, &amp;dwBot); <br>               } <br>                <br>               // Black as night, black as coal, I want to see the sun blotted out from the sky... <br>               SelectObject(hDC, GetStockObject(BLACK_PEN)); <br>               bOn = !bOn; <br> <br>   if (bOn) {   <br> <br>                  // Expand the line segment into points  <br>             FillOut(&amp;lpTop, &amp;dwTop); <br>                  FillOut(&amp;lpBot, &amp;dwBot); <br> <br>                  InvalidateRect(hWnd, NULL, FALSE);  // Draw the text via WM_PAINT <br>               } <br>            }   <br> <br>GetLastErrorBox(hWnd, "Error in WM_LBUTTONDOWN"); <br>            break; <br>         <br>        case WM_COMMAND: <br>            wmId    = LOWORD(uParam); <br>            wmEvent = HIWORD(uParam); <br> <br>            switch (wmId) { <br>case IDM_QUICKTEST:  // Randomly generate guide lines <br>    { <br>  RECT rect; <br>  int i; <br>   <br>  bOn = TRUE;  // Reset to top guide line <br> <br>  GetClientRect(hWnd, &amp;rect); <br>  if (dwTop) <br>    GlobalFree(lpTop); <br>  if (dwBot) <br>    GlobalFree(lpBot); <br>   <br>  // Allocate top guide line <br>  lpTop = (LPPOINT)GlobalAlloc(GPTR, sizeof(POINT) * QUICKTESTPOINTS); <br>  if (!lpTop) break; <br>   <br>  // Allocate bottom guide line <br>  lpBot = (LPPOINT)GlobalAlloc(GPTR, sizeof(POINT) * QUICKTESTPOINTS); <br>  if (!lpBot) { <br>    GlobalFree(lpTop); <br>break; <br>  } <br>   <br>  // Generate points <br>  for (i=0; i&lt;QUICKTESTPOINTS; i++) { <br>    lpTop[i].x = random(rect.right); <br>                        lpTop[i].y = random(rect.bottom); <br>lpBot[i].x = random(rect.right); <br>                        lpBot[i].y = random(rect.bottom); <br>  }  <br>   <br>  // Set number of points for top and bottom lines <br>  dwTop = QUICKTESTPOINTS; <br>  dwBot = QUICKTESTPOINTS; <br>   <br>  // Expand the line segment into points  <br>              FillOut(&amp;lpTop, &amp;dwTop); <br>                      FillOut(&amp;lpBot, &amp;dwBot); <br>   <br>          InvalidateRect(hWnd, NULL, FALSE);  // Draw the text via WM_PAINT <br>} <br> <br>GetLastErrorBox(hWnd, "Error in IDM_QUICKTEST");   <br>break; <br> <br>            case IDM_CHOOSEFONT: // Let the user pick a font <br>{ <br>   HDC hDC = GetDC(hWnd); <br>                       HFONT hf; <br>   LOGFONT lf; <br>   CHOOSEFONT cf; <br>                            <br>       ZeroMemory(&amp;cf, sizeof(cf));   <br>   ZeroMemory(&amp;lf, sizeof(lf));   <br>    <br>   cf.lStructSize = sizeof(CHOOSEFONT); <br>   cf.lpLogFont = &amp;lf; <br>                       cf.Flags = CF_SCREENFONTS | CF_TTONLY; <br>    <br>   if (ChooseFont(&amp;cf)) { <br>                           lf.lfHeight = -72;    // Bigger fonts look better <br>       hf = CreateFontIndirect(&amp;lf);  <br>                          DeleteObject(SelectObject(hDC, hf));  <br>   } <br>        } <br> <br>        // If we have text to show then re-render it <br>if (dwTop &amp;&amp; dwBot)  <br>  InvalidateRect(hWnd, NULL, FALSE);  // Draw the text via WM_PAINT <br> <br>GetLastErrorBox(hWnd, "Error in IDM_CHOOSEFONT"); <br>        break; <br>                     <br>case IDM_SHOWGUIDES:  // User toggled guide display <br>                    bShowGuides = !bShowGuides; <br>                    CheckMenuItem(GetMenu(hWnd), IDM_SHOWGUIDES, bShowGuides ? MF_CHECKED : MF_UNCHECKED); <br> <br>// If we have text to show then re-render it <br>if (dwTop &amp;&amp; dwBot)  <br>  InvalidateRect(hWnd, NULL, FALSE);  // Draw the text via WM_PAINT <br> <br>GetLastErrorBox(hWnd, "Error in IDM_SHOWGUIDES"); <br>                    break; <br>   <br>case IDM_OUTLINE:  // User toggled display of text as outline <br>                    bOutlineOnly = !bOutlineOnly; <br>                    CheckMenuItem(GetMenu(hWnd), IDM_OUTLINE, bOutlineOnly ? MF_CHECKED : MF_UNCHECKED); <br> <br>// If we have text to show then re-render it <br>if (dwTop &amp;&amp; dwBot)  <br>  InvalidateRect(hWnd, NULL, FALSE);  // Draw the text via WM_PAINT <br> <br>GetLastErrorBox(hWnd, "Error in IDM_OUTLINE"); <br>                    break; <br> <br>                case IDM_ABOUT: <br>                    DialogBox(hInst,          // current instance <br>                             "ABOUTBOX",      // dlg resource to use <br>                             hWnd,            // parent handle <br>                             (DLGPROC)About); // About() instance address <br> <br>                    break; <br> <br>                 <br>                case IDM_EXIT: <br>                    DestroyWindow (hWnd); <br>                    break; <br> <br>                default: <br>                    return (DefWindowProc(hWnd, message, uParam, lParam)); <br>            } <br>            break; <br> <br>        case WM_DESTROY:  // message: window being destroyed <br>                PostQuitMessage(0); <br>                break; <br>     <br>        default:          // Passes it on if unproccessed <br>                return (DefWindowProc(hWnd, message, uParam, lParam)); <br>} <br>return (0); <br>} <br> <br>/***************************************************************************** <br> * * <br> *   FUNCTION: CenterWindow (HWND, HWND) * <br> * * <br> *   PURPOSE:  Center one window over another * <br> * * <br> *   COMMENTS: * <br> * * <br> *   Dialog boxes take on the screen position that they were designed at, * <br> *   which is not always appropriate. Centering the dialog over a particular * <br> *   window usually results in a better position. * <br> * * <br> ****************************************************************************/ <br> <br>BOOL CenterWindow (HWND hwndChild, HWND hwndParent) <br>{ <br>        RECT    rChild, rParent; <br>        int     wChild, hChild, wParent, hParent; <br>        int     wScreen, hScreen, xNew, yNew; <br>        HDC     hdc; <br> <br>        // Get the Height and Width of the child window <br>        GetWindowRect (hwndChild, &amp;rChild); <br>        wChild = rChild.right - rChild.left; <br>        hChild = rChild.bottom - rChild.top; <br> <br>        // Get the Height and Width of the parent window <br>        GetWindowRect (hwndParent, &amp;rParent); <br>        wParent = rParent.right - rParent.left; <br>        hParent = rParent.bottom - rParent.top; <br> <br>        // Get the display limits <br>        hdc = GetDC (hwndChild); <br>        wScreen = GetDeviceCaps (hdc, HORZRES); <br>        hScreen = GetDeviceCaps (hdc, VERTRES); <br>        ReleaseDC (hwndChild, hdc); <br> <br>        // Calculate new X position, then adjust for screen <br>        xNew = rParent.left + ((wParent - wChild) /2); <br>        if (xNew &lt; 0) { <br>                xNew = 0; <br>        } else if ((xNew+wChild) &gt; wScreen) { <br>                xNew = wScreen - wChild; <br>        } <br> <br>        // Calculate new Y position, then adjust for screen <br>        yNew = rParent.top  + ((hParent - hChild) /2); <br>        if (yNew &lt; 0) { <br>                yNew = 0; <br>        } else if ((yNew+hChild) &gt; hScreen) { <br>                yNew = hScreen - hChild; <br>        } <br> <br>        // Set it, and return <br>        return SetWindowPos (hwndChild, NULL, <br>                xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER); <br>} <br> <br> <br>/***************************************************************************** <br> * * <br> *   FUNCTION: About(HWND, UINT, WPARAM, LPARAM) * <br> * * <br> *   PURPOSE:  Processes messages for "About" dialog box * <br> * * <br> *   MESSAGES: * <br> * * <br> *   WM_INITDIALOG - initialize dialog box * <br> *   WM_COMMAND    - Input received * <br> * * <br> *   COMMENTS: * <br> * * <br> *   Display version information from the version section of the * <br> *   application resource. * <br> * * <br> *   Wait for user to click on "Ok" button, then close the dialog box. * <br> * * <br> ****************************************************************************/ <br> <br>LRESULT CALLBACK About( <br>                HWND hDlg,           // window handle of the dialog box <br>                UINT message,        // type of message <br>                WPARAM uParam,       // message-specific information <br>                LPARAM lParam) <br>{ <br>    switch (message) { <br>        case WM_INITDIALOG:  // message: initialize dialog box <br>            // Center the dialog over the application window <br>            CenterWindow (hDlg, GetWindow (hDlg, GW_OWNER)); <br>            return (TRUE); <br> <br>        case WM_COMMAND:                      // message: received a command <br>            if (LOWORD(uParam) == IDOK || LOWORD(uParam) == IDCANCEL) {  <br>                EndDialog(hDlg, TRUE);        // Exit the dialog <br>                return (TRUE); <br>            } <br>            break; <br>    } <br>    return (FALSE); // Didn't process the message <br> <br>    UNREFERENCED_PARAMETER(lParam); // This will prevent 'unused formal parameter' warnings <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
