<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FX.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context3458"></a>FX.C</h2>
<pre><code>/*****************************************************************************\ <br>*       This is a part of the Microsoft Source Code Samples. <br>*       Copyright 1992 - 1998 Microsoft Corporation. <br>*       All rights reserved. <br>*       This source code is only intended as a supplement to <br>*       Microsoft Development Tools and/or WinHelp documentation. <br>*       See these sources for detailed information regarding the <br>*       Microsoft samples programs. <br>\*****************************************************************************/ <br>/***************************************************************************** <br> * * <br> *FX.C                              * <br> * * <br> *PURPOSE:  Routines for rendering text with stange effects                * <br> * * <br> * * <br> *FillOut           - Converts an array of line segments into an array of * <br> *                       all the points in the segments     * <br> * * <br> *RenderPathPoints   - Renders the outline of points returned from GetPath *  <br> * * <br> *RenderAndFillPath  - Renders the points returned from GetPath as a       * <br> *                       filled polygon * <br> * * <br> *TextEffect         - Draws a string of text between two guide lines      * <br> * * <br> *****************************************************************************/ <br>  <br>#include &lt;windows.h&gt; <br>#include "fx.h" <br> <br>// This structure is used by FillOut for passing data into LineDDA <br>typedef struct tagSEG { <br>  DWORD dwPos; <br>  LPPOINT lpPoints;  <br>} PTS; <br> <br>/********************************************************************** <br> *                                                                    * <br> * AddSegment - used with LineDDA to add points from a line segment   * <br> *    to an array containing all the points on a set of line segments * <br> *                                                                    * <br> *********************************************************************/ <br>VOID CALLBACK AddSegment(int x, int y, PTS *pts) <br>{ <br>   pts-&gt;lpPoints[pts-&gt;dwPos].x = x; <br>   pts-&gt;lpPoints[pts-&gt;dwPos].y = y; <br>   pts-&gt;dwPos++; <br>}  <br> <br>/********************************************************************** <br> *                                                                    * <br> * CountPoints - used with LineDDA to determine the number of points  * <br> *    needed to store all the points on a set of line segments        * <br> *                                                                    * <br> *********************************************************************/ <br>VOID CALLBACK CountPoints(int x, int y, LPDWORD lpdwNumPts) <br>{ <br>   (*lpdwNumPts)++; <br> <br>   UNREFERENCED_PARAMETER(x); <br>   UNREFERENCED_PARAMETER(y); <br>}  <br> <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  FillOut(LPPOINT, LPDWORD)                               * <br> *  * <br> * PURPOSE:   Converts an array of line segments into an array of all * <br> *            of the points comprising the line segments.             * <br> *                                                                    * <br> *********************************************************************/ <br>BOOL FillOut(LPPOINT *lpPoints, LPDWORD lpdwNumPts) <br>{ <br>   DWORD i; <br>   LPPOINT lpPts = *lpPoints; <br>   PTS pts; <br>   DWORD dwNumPts = 0; <br> <br>   // Make sure we have at least two points <br>   if (*lpdwNumPts &lt; 2) { <br>     MessageBox(NULL, "You need at least two points for a guide line.", "Not enough points!", MB_ICONSTOP); <br>     *lpdwNumPts = 0; <br>     return FALSE; <br>   } <br> <br>   // Find out how namy points are on the segments <br>   for (i=0; i&lt;*lpdwNumPts - 1; i++)  <br>     LineDDA(lpPts[i].x, lpPts[i].y, lpPts[i+1].x, lpPts[i+1].y, (LINEDDAPROC)CountPoints, (LPARAM)&amp;dwNumPts); <br>    <br>   // If there are too many points, print an anoying message so the user doesnt do it again <br>   if (dwNumPts &gt; MAXFILLPOINTS) { <br>     MessageBox(NULL, "Make your guide lines a bit shorter please!", "Too many points!", MB_ICONSTOP); <br>     *lpdwNumPts = 0; <br>     return FALSE;  // Bail <br>   } <br>    <br>   // Allocate memory for the the points and initialize our "last point" index <br>   pts.lpPoints = (LPPOINT)GlobalAlloc(GPTR, dwNumPts * sizeof(POINT)); <br>   pts.dwPos = 0; <br>                                                                     <br>   // Convert the segments to points <br>   for (i=0; i&lt;*lpdwNumPts - 1; i++)  <br>     LineDDA(lpPts[i].x, lpPts[i].y, lpPts[i+1].x, lpPts[i+1].y, (LINEDDAPROC)AddSegment, (LPARAM)&amp;pts); <br>    <br>   // Get rid of the original array of segments... <br>   GlobalFree(lpPts); <br>  <br>   // ... and replace it with the new points <br>   *lpPoints = pts.lpPoints; <br>   *lpdwNumPts = pts.dwPos; <br>    <br>   // Check to see if anything hit the fan <br>   if (!pts.dwPos) <br>     return FALSE; <br> <br>   return TRUE;   <br>} <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  PolyDraw95(HDC, LPPOINT, LPBYTE, int)                   * <br> *  * <br> * PURPOSE:   Draws the points returned from a call to GetPath()      * <br> *            to an HDC                                               * <br> *                                                                    * <br> * NOTES:     This function is similar to the Windows NT function     * <br> *            PolyDraw which draws a set of line segments and B zier  * <br> *            curves.  Since PolyDraw is not supported on Windows 95  * <br> *            this PolyDraw95 is used instead.                        *   <br> *                                                                    * <br> *********************************************************************/ <br>BOOL PolyDraw95(HDC  hdc,              // handle of a device context  <br>                CONST LPPOINT lppt,   // address of array of points  <br>                CONST LPBYTE lpbTypes, // address of line and curve identifiers   <br>                int  cCount)        // count of points  <br>{ <br>  int i; <br>   <br>  for (i=0; i&lt;cCount; i++)  <br>    switch (lpbTypes[i]) { <br>      case PT_MOVETO :  <br>         MoveToEx(hdc, lppt[i].x, lppt[i].y, NULL);  <br>         break; <br>       <br>      case PT_LINETO | PT_CLOSEFIGURE: <br>      case PT_LINETO :  <br>         LineTo(hdc, lppt[i].x, lppt[i].y);  <br>         break; <br>       <br>      case PT_BEZIERTO | PT_CLOSEFIGURE: <br>      case PT_BEZIERTO : <br>     PolyBezierTo(hdc, &amp;lppt[i], 3); <br> i+=2; <br>         break; <br>   } <br> <br>   return TRUE; <br>}   <br> <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  RenderPathPoints(HDC, LPPOINT, LPBYTE, int, BOOL)      * <br> *  * <br> * PURPOSE:   Renders the points returned from a call to GetPath()    * <br> *            by converting them back into a path and calling either  * <br> *            FillPath or StrokePath to display them.                 * <br> *                                                                    * <br> * NOTE:      The R2_MERGEPENNOT is used here so that things like the * <br> *            inside of and "a" or an "o" get painted correctly when  * <br> *            using FillPath.                                         * <br> *                                                                    * <br> *********************************************************************/ <br>BOOL RenderPathPoints(HDC hDC, LPPOINT lpPoints, LPBYTE lpTypes, int iNumPts, BOOL bOutline) <br>{ <br>  BeginPath(hDC); // Draw into a path so that we can use FillPath() <br> <br>  PolyDraw95(hDC, lpPoints, lpTypes, iNumPts); <br> <br>  CloseFigure(hDC); <br>  EndPath(hDC);    <br> <br>  // Draw the path <br>  if (bOutline)   <br>    StrokePath(hDC); // As an outline <br>  else  <br>      {              // As solid figures <br>        int iROP2 = SetROP2(hDC, R2_MERGEPENNOT); <br>        HPEN hPen = SelectObject(hDC, GetStockObject(NULL_PEN)); // Just say "no" to outlines <br>        HBRUSH hBrush = SelectObject(hDC, GetStockObject(BLACK_BRUSH)); // Paint It Black <br> <br>        FillPath(hDC);   <br> <br>        // Restore the DC to its previous state <br>        SetROP2(hDC, iROP2);         <br>        SelectObject(hDC, hPen); <br>        SelectObject(hDC, hBrush); <br>      }  <br>   <br>  return TRUE; <br>} <br> <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  GetRealTextExtent(LPPOINT, int, LPSIZE)                 * <br> *  * <br> * PURPOSE:   Makes sure that the extents in a SIZE are large enough  * <br> *            to bound the points in an array.                        * <br> *                                                                    * <br> * NOTES:     Why not just use GetTextExtentPoint32?  Well, the text  * <br> *            extents returned by GetTextExtentPoint32 dont include   * <br> *            the overhang of an italics character into the next      * <br> *            cell.  This function expands the extents to include     * <br> *            the greatest x, and y extents of the string data.       * <br> *                                                                    * <br> *********************************************************************/ <br>void GetRealTextExtent(LPPOINT lpPoints, int iNumPts, LPSIZE size) <br>{ <br>  int i; <br> <br>  for (i=0; i&lt;iNumPts; i++) { <br>    if (lpPoints[i].x &gt; size-&gt;cx) size-&gt;cx = lpPoints[i].x; <br>    if (lpPoints[i].y &gt; size-&gt;cy) size-&gt;cy = lpPoints[i].y; <br>  } <br>} <br> <br>/********************************************************************** <br> *                                                                    * <br> * FUNCTION:  TextEffect(HDC, LPPOINT, LPPOINT, DWORD, DWORD,         * <br> *                            LPSTR, BOOL)    * <br> *  * <br> * PURPOSE:   Draws a string of text in the currently selected font   * <br> *            using two arrays of points as guide lines for orienting * <br> *            the text.  The text can be displayed either as outlines * <br> *            or as filled characters.                                * <br> *                                                                    * <br> *********************************************************************/ <br>BOOL TextEffect(HDC hDC,            // DC to display into <br>                LPPOINT lpTop,  // Top guide line <br>                LPPOINT lpBot, // Bottom guide line <br>                DWORD dwTopPts, // Number of points in top guide <br>                DWORD dwBotPts, // Number of points in bottom guide <br>                LPSTR szText, // Text string to apply effects to <br>                BOOL bOutlineOnly)  // Print as outline or as solid text <br>{ <br>   LPPOINT lpPoints;  // Path data points <br>   LPBYTE lpTypes;  // Path data types <br>   int i, iNumPts; <br>   SIZE size;  // Text size info <br>   float fXScale, fYScale;  // Scaling values <br>   int iTopInd, iBotInd;  // Guide array indices <br> <br>   // Set to transparent so we dont get an outline around the text string <br>   SetBkMode(hDC, TRANSPARENT); <br>       <br>   // Output the text into a path <br>   BeginPath(hDC); <br>   TextOut(hDC, 0, 0, szText, strlen(szText)); <br>   EndPath(hDC);     <br>       <br>   // How many points are in the path <br>   iNumPts = GetPath(hDC, NULL, NULL, 0); <br>   if (iNumPts == -1) return FALSE; <br> <br>   // Allocate room for the points <br>   lpPoints = (LPPOINT)GlobalAlloc(GPTR, sizeof(POINT) * iNumPts); <br>   if (!lpPoints) return FALSE; <br> <br>   // Allocate room for the point types <br>   lpTypes = GlobalAlloc(GPTR, iNumPts); <br>   if (!lpTypes) { <br>     GlobalFree(lpPoints); <br>   return FALSE; <br>   } <br>    <br>   // Get the points and types from the current path <br>   iNumPts = GetPath(hDC, lpPoints, lpTypes, iNumPts); <br> <br>   // Even more error checking <br>   if (iNumPts == -1) { <br>     GlobalFree(lpTypes); <br>     GlobalFree(lpPoints); <br> return FALSE; <br>   } <br>    <br>   //Get extents of the text string for scaling purposes   <br>   GetTextExtentPoint32(hDC, szText, strlen(szText), &amp;size); <br> <br>   // OK, but lets make sure our extents are big enough (handle italics fonts) <br>   GetRealTextExtent(lpPoints, iNumPts, &amp;size); <br>    <br>   // Relocate the points in the path based on the guide lines <br>   for (i=0; i &lt; iNumPts; i++) { <br>    // How far along is this point on the x-axis <br>     fXScale = (float)lpPoints[i].x / (float)size.cx; <br> <br>     // What point on the top guide does this coorespond to <br>     iTopInd = (int)(fXScale * (dwTopPts-1)); <br> // What point on the bottom guide does this coorespond to <br>     iBotInd = (int)(fXScale * (dwBotPts-1)); <br> <br>     // How far along is this point on the y-axis <br>     fYScale = (float)lpPoints[i].y / (float)size.cy; <br> <br>     // Scale the points to their new locations <br>     lpPoints[i].x = (int)((lpBot[iBotInd].x * fYScale) + (lpTop[iTopInd].x * (1.0f-fYScale))); <br>     lpPoints[i].y = (int)((lpBot[iBotInd].y * fYScale) + (lpTop[iTopInd].y * (1.0f-fYScale))); <br>   } <br> <br>   // Draw the new path  <br>   RenderPathPoints(hDC, lpPoints, lpTypes, iNumPts, bOutlineOnly); <br>    <br>   GlobalFree(lpPoints); <br>   GlobalFree(lpTypes); <br> <br>   return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
