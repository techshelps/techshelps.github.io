<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AAPLYREC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2456"></a>AAPLYREC.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  aaplyrec.c <br>// <br>//  Description: <br>//      An play/record dialog based on MCI Wave. <br>// <br>// <br>//  Known Bugs In MCIWAVE for Windows 3.1: <br>//  ====================================== <br>// <br>//  o   If you are running SHARE (or the equivelant) and attempt to open <br>//      a file that is open by another application, you will receive the <br>//      following error: <br>// <br>//          "Cannot find the specified file. Make sure the path and <br>//           filename are correct..." <br>// <br>//      This is of course wrong. The problem is the file cannot be opened <br>//      read/write by multiple applications. <br>// <br>//  o   Opening a wave file that is more than about three seconds long and <br>//      issueing the following commands will hang Windows: <br>// <br>//          open xxx.wav alias zyz          ; open &gt; 3 second file <br>//          delete zyz from 1000 to 2000    ; remove some data <br>//          delete zyz from 1000 to 2000    ; do it again and you hang <br>// <br>//      I think this will also happen with the following commands: <br>// <br>//          open c:\win31\ding.wav alias zyz <br>//          delete zyz to 100 <br>// <br>//  o   You cannot play or record data with a synchronous wave device. This <br>//      is due to MCIWAVE relying on the ability to 'stream' data. This is <br>//      not really a bug, just a limitation. <br>// <br>//  o   Block alignment is not correctly handled for non-PCM wave files <br>//      when editing (includes recording). It is illegal to start recording <br>//      in the middle of a block. The result if this happens is garbage <br>//      data. This occurs if you insert data with a partial block at the <br>//      end also... <br>// <br>//  o   It is possible to kill Windows by issueing the following commands <br>//      without yielding between sending the commands: <br>// <br>//          capability &lt;file&gt; inputs <br>//          close &lt;file&gt; <br>//          open &lt;file&gt; <br>// <br>//      Should be able to fix the problem by Yield'ing. <br>// <br>//  o   Saving to the same wave file twice without closing the device deletes <br>//      the existing file. Don't save twice. <br>//   <br>//  o   Saving an 'empty' wave file does not work. Issueing the following <br>//      commands demonstrates the problem: <br>// <br>//          open new type waveaudio alias zyz <br>//          save zyz as c:\zyz.wav <br>// <br>//      You will receive an 'out of memory error' which is completely bogus. <br>//      Just don't save empty files. <br>// <br>//  o   Setting the time format to bytes doesn't work with compressed files. <br>//      Sigh... <br>// <br>//  o   And there are others with less frequently used commands. <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br> <br>#include "muldiv32.h" <br>#include "appport.h" <br>#include "acmapp.h" <br> <br>#include "debug.h" <br> <br> <br>#ifndef _MCIERROR_ <br>#define _MCIERROR_ <br>typedef DWORD           MCIERROR;   // error return code, 0 means no error <br>#endif <br> <br> <br>TCHAR           gszAlias[]          = TEXT("zyzthing"); <br> <br>BOOL            gfFileOpen; <br>BOOL            gfDirty; <br>BOOL            gfTimerGoing; <br> <br>UINT            guPlayRecordStatus; <br> <br> <br>#define AAPLAYRECORD_TIMER_RESOLUTION       54 <br> <br>#define AAPLAYRECORD_MAX_MCI_COMMAND_CHARS  255 <br> <br>#define AAPLAYRECORD_STATUS_NOT_READY       0 <br>#define AAPLAYRECORD_STATUS_PAUSED          1 <br>#define AAPLAYRECORD_STATUS_PLAYING         2 <br>#define AAPLAYRECORD_STATUS_STOPPED         3 <br>#define AAPLAYRECORD_STATUS_RECORDING       4 <br>#define AAPLAYRECORD_STATUS_SEEKING         5 <br> <br>#define AAPLAYRECORD_STATUS_NOT_OPEN        (UINT)-1 <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  MCIERROR AcmPlayRecordSendCommand <br>//   <br>//  Description: <br>//      The string is of the form "verb params" our device name is inserted <br>//      after the verb and send to the device. <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PSTR pszCommand: <br>//   <br>//      PSTR pszReturn: <br>//   <br>//      UINT cbReturn: <br>//   <br>//      BOOL fErrorBox: <br>//   <br>//  Return (MCIERROR): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>MCIERROR FNLOCAL AcmPlayRecordSendCommand <br>( <br>    HWND                    hwnd, <br>    PTSTR                   pszCommand, <br>    PTSTR                   pszReturn, <br>    UINT                    cbReturn, <br>    BOOL                    fErrorBox <br>) <br>{ <br>    MCIERROR            mcierr; <br>    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS * 2]; <br>    TCHAR              *pch; <br>    PTSTR               psz; <br> <br>    pch = pszCommand; <br> <br>    while (('\t' == *pch) || (' ' == *pch)) <br>    { <br>        pch++; <br>    } <br> <br>    if (0 == lstrlen(pch)) <br>    { <br>        return (MMSYSERR_NOERROR); <br>    } <br> <br>    pch = ach; <br>    psz = pszCommand; <br>    while (('\0' != *psz) &amp;&amp; (' ' != *psz)) <br>    { <br>        *pch++ = *psz++; <br>    } <br> <br>    *pch++ = ' '; <br> <br>    lstrcpy(pch, gszAlias); <br>    lstrcat(pch, psz); <br> <br>    mcierr = mciSendString(ach, pszReturn, cbReturn, hwnd); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        if (fErrorBox) <br>        { <br>            int         n; <br> <br>            n = wsprintf(ach, TEXT("Command: '%s'\n\nMCI Wave Error (%lu): "), <br>                            (LPTSTR)pszCommand, mcierr); <br> <br>            mciGetErrorString(mcierr, &amp;ach[n], SIZEOF(ach) - n); <br>            MessageBox(hwnd, ach, TEXT("MCI Wave Error"), MB_ICONEXCLAMATION | MB_OK); <br>        } <br>    } <br> <br>    return (mcierr); <br>} // AcmPlayRecordSendCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordCommand <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordCommand <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS * 2]; <br>    HWND                hedit; <br>    MCIERROR            mcierr; <br> <br>    // <br>    // <br>    // <br>    hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND); <br>    Edit_SetSel(hedit, 0, -1); <br> <br>    Edit_GetText(hedit, ach, SIZEOF(ach)); <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, ach, ach, SIZEOF(ach), FALSE); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        mciGetErrorString(mcierr, ach, SIZEOF(ach)); <br>    } <br> <br>    hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_RESULT); <br>    Edit_SetText(hedit, ach); <br> <br>    return (TRUE); <br>} // AcmAppPlayRecordCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordSetPosition <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      HWND hsb: <br>//   <br>//      UINT uCode: <br>//   <br>//      int nPos: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordSetPosition <br>( <br>    HWND                    hwnd, <br>    HWND                    hsb, <br>    UINT                    uCode, <br>    int                     nPos <br>) <br>{ <br>    MCIERROR            mcierr; <br>    TCHAR               szPosition[40]; <br>    TCHAR               szLength[40]; <br>    LONG                lLength; <br>    LONG                lPosition; <br>    LONG                lPageInc; <br>    int                 nRange; <br>    int                 nMinPos; <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    if (AAPLAYRECORD_STATUS_NOT_OPEN == guPlayRecordStatus) <br>    { <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status length"), szLength, SIZEOF(szLength), FALSE); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        return (FALSE); <br>    } <br> <br>    lLength = _tcstol(szLength, NULL, 10); <br>    if (0L == lLength) <br>    { <br>        return (FALSE); <br>    } <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status position"), szPosition, SIZEOF(szPosition), FALSE); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        return (FALSE); <br>    } <br> <br>    lPosition = _tcstol(szPosition, NULL, 10); <br> <br>    lPageInc = (lLength / 10); <br>    if (0L == lPageInc) <br>    { <br>        lPageInc = 1; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    switch (uCode) <br>    { <br>        case SB_PAGEDOWN: <br>            lPosition = min(lLength, lPosition + lPageInc); <br>            break; <br> <br>        case SB_LINEDOWN: <br>            lPosition = min(lLength, lPosition + 1); <br>            break; <br> <br>        case SB_PAGEUP: <br>            lPosition -= lPageInc; <br> <br>            //-- fall through --// <br> <br>        case SB_LINEUP: <br>            lPosition = (lPosition &lt; 1) ? 0 : (lPosition - 1); <br>            break; <br> <br> <br>        case SB_TOP: <br>            lPosition = 0; <br>            break; <br> <br>        case SB_BOTTOM: <br>            lPosition = lLength; <br>            break; <br> <br>        case SB_THUMBPOSITION: <br>        case SB_THUMBTRACK: <br>            GetScrollRange(hsb, SB_CTL, &amp;nMinPos, &amp;nRange); <br>            lPosition = (DWORD)MulDivRN((DWORD)nPos, (DWORD)lLength, (DWORD)nRange); <br>            break; <br> <br>        default: <br>            return (FALSE); <br>    } <br> <br>    // <br>    // <br>    // <br>    wsprintf(szPosition, TEXT("seek to %lu"), lPosition); <br>    AcmPlayRecordSendCommand(hwnd, szPosition, NULL, 0, FALSE); <br> <br>    return (TRUE); <br>} // AcmAppPlayRecordSetPosition() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordStatus <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordStatus <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS]; <br>    TCHAR               szMode[40]; <br>    TCHAR               szPosition[40]; <br>    TCHAR               szLength[40]; <br>    TCHAR               szFormat[40]; <br>    MCIERROR            mcierr; <br>    UINT                uStatus; <br>    BOOL                fStartTimer; <br>    BOOL                fPlay; <br>    BOOL                fPause; <br>    BOOL                fStop; <br>    BOOL                fStart; <br>    BOOL                fEnd; <br>    BOOL                fRecord; <br>    BOOL                fCommand; <br>    UINT                uIdFocus; <br>    DWORD               dwLength; <br>    DWORD               dwPosition; <br>    HWND                hsb; <br> <br>    // <br>    // <br>    // <br>    if (AAPLAYRECORD_STATUS_NOT_OPEN != guPlayRecordStatus) <br>    { <br>        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status mode"), szMode, SIZEOF(szMode), FALSE); <br>        if (MMSYSERR_NOERROR != mcierr) <br>        { <br>            guPlayRecordStatus = AAPLAYRECORD_STATUS_NOT_OPEN; <br>        } <br>    } <br> <br> <br>    // <br>    //  assume all buttons disabled <br>    // <br>    fStartTimer = FALSE; <br>    fPlay       = FALSE; <br>    fPause      = FALSE; <br>    fStop       = FALSE; <br>    fStart      = FALSE; <br>    fEnd        = FALSE; <br>    fRecord     = FALSE; <br>    fCommand    = TRUE; <br>    uIdFocus    = IDOK; <br>    dwPosition  = 0L; <br>    dwLength    = 0L; <br>    lstrcpy(szFormat, TEXT("???")); <br> <br>    hsb = GetDlgItem(hwnd, IDD_AAPLAYRECORD_SCROLL_POSITION); <br> <br> <br>    // <br>    // <br>    // <br>    if (AAPLAYRECORD_STATUS_NOT_OPEN == guPlayRecordStatus) <br>    { <br>        lstrcpy(szMode, TEXT("not open")); <br>    } <br>    else if (0 == lstrcmpi(TEXT("not ready"), szMode)) <br>    { <br>        uStatus = AAPLAYRECORD_STATUS_NOT_READY; <br> <br>        fStartTimer = TRUE; <br>    } <br>    else if (0 == lstrcmpi(TEXT("paused"), szMode)) <br>    { <br>        uStatus = AAPLAYRECORD_STATUS_PAUSED; <br> <br>        fPause      = TRUE; <br>        fStop       = TRUE; <br>    } <br>    else if (0 == lstrcmpi(TEXT("playing"), szMode)) <br>    { <br>        uStatus = AAPLAYRECORD_STATUS_PLAYING; <br> <br>        fStartTimer = TRUE; <br>        fPause      = TRUE; <br>        fStop       = TRUE; <br>    } <br>    else if (0 == lstrcmpi(TEXT("stopped"), szMode)) <br>    { <br>        uStatus = AAPLAYRECORD_STATUS_STOPPED; <br> <br>        fPlay       = TRUE; <br>        fStart      = TRUE; <br>        fEnd        = TRUE; <br>        fRecord     = TRUE; <br>    } <br>    else if (0 == lstrcmpi(TEXT("recording"), szMode)) <br>    { <br>        uStatus = AAPLAYRECORD_STATUS_RECORDING; <br> <br>        fStartTimer = TRUE; <br>        fPause      = TRUE; <br>        fStop       = TRUE; <br>    } <br>    else if (0 == lstrcmpi(TEXT("seeking"), szMode)) <br>    { <br>        uStatus = AAPLAYRECORD_STATUS_SEEKING; <br> <br>        fStartTimer = TRUE; <br>        fStop       = TRUE; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    // <br>    if (fStartTimer) <br>    { <br>        if (!gfTimerGoing) <br>        { <br>            SetTimer(hwnd, 1, AAPLAYRECORD_TIMER_RESOLUTION, NULL); <br>            gfTimerGoing = TRUE; <br>        } <br>    } <br>    else if (gfTimerGoing) <br>    { <br>        KillTimer(hwnd, 1); <br>        gfTimerGoing = FALSE; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    if (AAPLAYRECORD_STATUS_NOT_OPEN != guPlayRecordStatus) <br>    { <br>        // <br>        // <br>        // <br>        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status position"), szPosition, SIZEOF(szPosition), FALSE); <br>        if (MMSYSERR_NOERROR == mcierr) <br>        { <br>            dwPosition = _tcstoul(szPosition, NULL, 10); <br>        } <br> <br>        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status length"), szLength, SIZEOF(szLength), FALSE); <br>        if (MMSYSERR_NOERROR == mcierr) <br>        { <br>            dwLength   = _tcstoul(szLength, NULL, 10); <br>        } <br> <br>        mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status time format"), szFormat, SIZEOF(szFormat), FALSE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    if (uStatus != guPlayRecordStatus) <br>    { <br>        if (GetFocus() != hsb) <br>        { <br>            LRESULT             lr; <br> <br>            lr = SendMessage(hwnd, DM_GETDEFID, 0, 0L); <br>            if (DC_HASDEFID == HIWORD(lr)) <br>            { <br>                UINT        uIdDefId; <br> <br>                uIdDefId = LOWORD(lr); <br>                if (IDOK != uIdDefId) <br>                { <br>                    HWND        hwndDefId; <br> <br>                    hwndDefId = GetDlgItem(hwnd, uIdDefId); <br> <br>                    Button_SetStyle(hwndDefId, BS_PUSHBUTTON, TRUE); <br>                } <br>            } <br> <br> <br>            SendMessage(hwnd, DM_SETDEFID, IDOK, 0L); <br> <br>            SetFocus(GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND)); <br>        } <br> <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_PLAY),   fPlay  ); <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_PAUSE),  fPause ); <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_STOP),   fStop  ); <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_START),  fStart ); <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_END),    fEnd   ); <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_BTN_RECORD), fRecord); <br> <br>        EnableWindow(GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND), fCommand); <br>        EnableWindow(GetDlgItem(hwnd, IDOK), fCommand); <br> <br>        if (AAPLAYRECORD_STATUS_PAUSED == uStatus) <br>            SetDlgItemText(hwnd, IDD_AAPLAYRECORD_BTN_PAUSE, TEXT("Resum&amp;e")); <br>        else <br>            SetDlgItemText(hwnd, IDD_AAPLAYRECORD_BTN_PAUSE, TEXT("Paus&amp;e")); <br> <br>        guPlayRecordStatus = uStatus; <br>    } <br> <br>    // <br>    // <br>    // <br>    AppFormatBigNumber(szPosition, dwPosition); <br>    AppFormatBigNumber(szLength, dwLength); <br> <br>    wsprintf(ach, TEXT("%s: %14s (%s) %s"), <br>                 (LPSTR)szMode, <br>                 (LPSTR)szPosition, <br>                 (LPSTR)szLength, <br>                 (LPSTR)szFormat); <br> <br>    SetDlgItemText(hwnd, IDD_AAPLAYRECORD_TXT_POSITION, ach); <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    { <br>        int         nRange; <br>        int         nValue; <br>        int         nMinPos; <br>        int         nMaxPos; <br> <br>        GetScrollRange(hsb, SB_CTL, &amp;nMinPos, &amp;nMaxPos); <br> <br>        nRange = (int)min(dwLength, 32767L); <br> <br>        if (nMaxPos != nRange) <br>        { <br>            SetScrollRange(hsb, SB_CTL, 0, nRange, FALSE); <br>        } <br> <br>        // <br>        // <br>        // <br>        nValue = 0; <br>        if (0L != dwLength) <br>        { <br>            nValue = (int)MulDivRN(dwPosition, nRange, dwLength); <br>        } <br> <br>        if (nValue != GetScrollPos(hsb, SB_CTL)) <br>        { <br>            SetScrollPos(hsb, SB_CTL, nValue, TRUE); <br>        } <br>    } <br> <br>    return (TRUE); <br>} // AcmAppPlayRecordStatus() <br> <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordRecord <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordRecord <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br> <br>    // <br>    // <br>    // <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("record insert"), NULL, 0, TRUE); <br>    if (MMSYSERR_NOERROR == mcierr) <br>    { <br>        gfDirty = TRUE; <br>    } <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordRecord() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordStart <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordStart <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br> <br>    // <br>    // <br>    // <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("seek to start"), NULL, 0, TRUE); <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordStart() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordEnd <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordEnd <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br> <br>    // <br>    // <br>    // <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("seek to end"), NULL, 0, TRUE); <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordEnd() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordStop <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordStop <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br> <br>    // <br>    // <br>    // <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("stop"), NULL, 0, TRUE); <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordStop() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordPause <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordPause <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br>    PTSTR               psz; <br> <br>    // <br>    // <br>    // <br>    if (AAPLAYRECORD_STATUS_PAUSED == guPlayRecordStatus) <br>        psz = TEXT("resume"); <br>    else <br>        psz = TEXT("pause"); <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, psz, NULL, 0, TRUE); <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordPause() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordPlay <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordPlay <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br>    TCHAR               szPosition[40]; <br>    TCHAR               szLength[40]; <br> <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status position"), szPosition, SIZEOF(szPosition), TRUE); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        return (FALSE); <br>    } <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("status length"), szLength, SIZEOF(szLength), TRUE); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        return (FALSE); <br>    } <br> <br>    if (0 == lstrcmp(szPosition, szLength)) <br>    { <br>        AcmPlayRecordSendCommand(hwnd, TEXT("seek to start"), NULL, 0, TRUE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("play"), NULL, 0, TRUE); <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordPlay() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordClose <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordClose <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MCIERROR            mcierr; <br> <br>    if (gfDirty) <br>    { <br>        UINT    u; <br> <br>        u = MessageBox(hwnd, TEXT("Save newly recorded data?"), TEXT("Save"), <br>                       MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2); <br>        if (IDYES == u) <br>        { <br>            AppHourGlass(TRUE); <br>            mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("save"), NULL, 0, TRUE); <br>            AppHourGlass(FALSE); <br>        } <br>        else <br>        { <br>            gfDirty = FALSE; <br>        } <br>    } <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("close"), NULL, 0, TRUE); <br> <br>    return (MMSYSERR_NOERROR == mcierr); <br>} // AcmAppPlayRecordClose() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordOpen <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordOpen <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd, <br>    UINT                    uWaveInId, <br>    UINT                    uWaveOutId <br>) <br>{ <br>    TCHAR               ach[AAPLAYRECORD_MAX_MCI_COMMAND_CHARS]; <br>    MCIERROR            mcierr; <br> <br>    guPlayRecordStatus = AAPLAYRECORD_STATUS_NOT_OPEN; <br> <br>    gfTimerGoing       = FALSE; <br>    gfFileOpen         = FALSE; <br> <br>    gfDirty = FALSE; <br> <br>    if (NULL == paafd-&gt;pwfx) <br>    { <br>        MessageBox(hwnd, TEXT("No wave file currently selected."), <br>                    TEXT("Open Error"), MB_ICONEXCLAMATION | MB_OK); <br>        return (FALSE); <br>    } <br> <br>    wsprintf(ach, TEXT("open \"%s\" alias %s"), (LPSTR)paafd-&gt;szFilePath, (LPSTR)gszAlias); <br> <br>    mcierr = mciSendString(ach, NULL, 0, NULL); <br>    if (MMSYSERR_NOERROR != mcierr) <br>    { <br>        mciGetErrorString(mcierr, ach, SIZEOF(ach)); <br>        MessageBox(hwnd, ach, TEXT("Open Error"), MB_ICONEXCLAMATION | MB_OK); <br> <br>        return (FALSE); <br>    } <br> <br>    gfFileOpen         = TRUE; <br>    guPlayRecordStatus = AAPLAYRECORD_STATUS_NOT_READY; <br> <br>    mcierr = AcmPlayRecordSendCommand(hwnd, TEXT("set time format samples"), NULL, 0, TRUE); <br> <br>    if (WAVE_MAPPER != uWaveInId) <br>    { <br>        wsprintf(ach, TEXT("set input %u"), uWaveInId); <br>        mcierr = AcmPlayRecordSendCommand(hwnd, ach, NULL, 0, TRUE); <br>    } <br> <br>    if (WAVE_MAPPER != uWaveOutId) <br>    { <br>        wsprintf(ach, TEXT("set output %u"), uWaveOutId); <br>        mcierr = AcmPlayRecordSendCommand(hwnd, ach, NULL, 0, TRUE); <br>    } <br> <br>    return (TRUE); <br>} // AcmAppPlayRecordOpen() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppPlayRecordInitCommands <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppPlayRecordInitCommands <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    static PTSTR    pszCommands[] = <br>    { <br>        TEXT("play"), <br>        TEXT("play to Y"), <br>        TEXT("play from X to Y"), <br> <br>        TEXT(""), <br>        TEXT("capability can eject"), <br>        TEXT("capability can play"), <br>        TEXT("capability can record"), <br>        TEXT("capability can save"), <br>        TEXT("capability compound device"), <br>        TEXT("capability device type"), <br>        TEXT("capability has audio"), <br>        TEXT("capability has video"), <br>        TEXT("capability inputs"), <br>        TEXT("capability outputs"), <br>        TEXT("capability uses files"), <br> <br>        TEXT(""), <br>        TEXT("cue input !"), <br>        TEXT("cue output !"), <br> <br>        TEXT(""), <br>        TEXT("delete to Y !"), <br>        TEXT("delete from X to Y !"), <br> <br>        TEXT(""), <br>        TEXT("info input"), <br>        TEXT("info file"), <br>        TEXT("info output"), <br>        TEXT("info product"), <br> <br>        TEXT(""), <br>        TEXT("pause"), <br> <br>        TEXT(""), <br>        TEXT("record insert !"), <br>        TEXT("record overwrite !"), <br>        TEXT("record to Y !"), <br>        TEXT("record from X to Y !"), <br> <br>        TEXT(""), <br>        TEXT("resume"), <br> <br>        TEXT(""), <br>        TEXT("save"), <br>        TEXT("save FILENAME"), <br> <br>        TEXT(""), <br>        TEXT("seek to Y"), <br>        TEXT("seek to start"), <br>        TEXT("seek to end"), <br> <br>        TEXT(""), <br>        TEXT("set alignment X"), <br>        TEXT("set any input"), <br>        TEXT("set any output"), <br>        TEXT("set audio all off"), <br>        TEXT("set audio all on"), <br>        TEXT("set audio left off"), <br>        TEXT("set audio left on"), <br>        TEXT("set audio right off"), <br>        TEXT("set audio right on"), <br>        TEXT("set bitspersample X"), <br>        TEXT("set bytespersec X"), <br>        TEXT("set channels X"), <br>        TEXT("set format tag X"), <br>        TEXT("set format tag pcm"), <br>        TEXT("set input X"), <br>        TEXT("set output X"), <br>        TEXT("set samplespersec X"), <br>        TEXT("set time format bytes"), <br>        TEXT("set time format milliseconds"), <br>        TEXT("set time format samples"), <br> <br>        TEXT(""), <br>        TEXT("status alignment"), <br>        TEXT("status bitspersample"), <br>        TEXT("status bytespersec"), <br>        TEXT("status channels"), <br>        TEXT("status current track"), <br>        TEXT("status format tag"), <br>        TEXT("status input"), <br>        TEXT("status length"), <br>        TEXT("status length track X"), <br>        TEXT("status level"), <br>        TEXT("status media present"), <br>        TEXT("status mode"), <br>        TEXT("status number of tracks"), <br>        TEXT("status output"), <br>        TEXT("status position"), <br>        TEXT("status position track X"), <br>        TEXT("status ready"), <br>        TEXT("status samplespersec"), <br>        TEXT("status start position"), <br>        TEXT("status time format"), <br> <br>        TEXT(""), <br>        TEXT("stop"), <br>        NULL <br>    }; <br> <br>    HWND                hcb; <br>    UINT                u; <br>    PTSTR               psz; <br> <br>    // <br>    // <br>    // <br>    hcb = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND); <br> <br>    for (u = 0; psz = pszCommands[u]; u++) </code></pre>
<p>
</p>
<pre><code>{ <br>        ComboBox_AddString(hcb, psz); <br>    } <br> <br>    ComboBox_SetCurSel(hcb, 0); <br> <br>    return (TRUE); <br>} // AcmAppPlayRecordInitCommands() <br> <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppPlayRecord <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AcmAppPlayRecord <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    PACMAPPFILEDESC     paafd; <br>    UINT                uId; <br>    HWND                hedit; <br>    HFONT               hfont; <br> <br>    paafd = (PACMAPPFILEDESC)(UINT)GetWindowLong(hwnd, DWL_USER); <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            paafd = (PACMAPPFILEDESC)(UINT)lParam; <br> <br>            SetWindowLong(hwnd, DWL_USER, lParam); <br> <br>//          hfont = GetStockFont(ANSI_FIXED_FONT); <br>            hfont = ghfontApp; <br> <br>            hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_TXT_POSITION); <br>            SetWindowFont(hedit, hfont, FALSE); <br> <br>            hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_COMMAND); <br>            SetWindowFont(hedit, hfont, FALSE); <br> <br>            hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_RESULT); <br>            SetWindowFont(hedit, hfont, FALSE); <br> <br>            AcmAppPlayRecordInitCommands(hwnd, paafd); <br> <br>            AcmAppPlayRecordOpen(hwnd, paafd, guWaveInId, guWaveOutId); <br>            AcmAppPlayRecordStatus(hwnd, paafd); <br> <br> <br>            // <br>            //  if the format is non-PCM, display a little warning so the <br>            //  user knows that not everything may work correctly when <br>            //  dealing working with MCI Wave.. <br>            // <br>            if ((NULL != paafd-&gt;pwfx) &amp;&amp; <br>                (WAVE_FORMAT_PCM != paafd-&gt;pwfx-&gt;wFormatTag)) <br>            { <br>                hedit = GetDlgItem(hwnd, IDD_AAPLAYRECORD_EDIT_RESULT); <br>                Edit_SetText(hedit, TEXT("WARNING! There are known bugs with MCI Wave EDITING operations on non-PCM formats--see the README.TXT with this application. (end)\r\n\r\nRemember, DON'T PANIC!\r\n\r\n\r\n\r\n\r\n\r\n- zYz -")); <br>            } <br>            return (TRUE); <br> <br>        case WM_TIMER: <br>            AcmAppPlayRecordStatus(hwnd, paafd); <br>            break; <br> <br>        case WM_HSCROLL: <br>            HANDLE_WM_HSCROLL(hwnd, wParam, lParam, AcmAppPlayRecordSetPosition); <br> <br>            guPlayRecordStatus = AAPLAYRECORD_STATUS_SEEKING; <br>            AcmAppPlayRecordStatus(hwnd, paafd); <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            uId = GET_WM_COMMAND_ID(wParam, lParam); <br>            switch (uId) <br>            { <br>                case IDD_AAPLAYRECORD_BTN_PLAY: <br>                    AcmAppPlayRecordPlay(hwnd, paafd); <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br>                case IDD_AAPLAYRECORD_BTN_PAUSE: <br>                    AcmAppPlayRecordPause(hwnd, paafd); <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br>                case IDD_AAPLAYRECORD_BTN_STOP: <br>                    AcmAppPlayRecordStop(hwnd, paafd); <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br>                case IDD_AAPLAYRECORD_BTN_START: <br>                    AcmAppPlayRecordStart(hwnd, paafd); <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br>                case IDD_AAPLAYRECORD_BTN_END: <br>                    AcmAppPlayRecordEnd(hwnd, paafd); <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br>                case IDD_AAPLAYRECORD_BTN_RECORD: <br>                    AcmAppPlayRecordRecord(hwnd, paafd); <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br>                case IDOK: <br>                    AcmAppPlayRecordCommand(hwnd); <br> <br>                    guPlayRecordStatus = AAPLAYRECORD_STATUS_SEEKING; <br>                    AcmAppPlayRecordStatus(hwnd, paafd); <br>                    break; <br> <br> <br>                case IDCANCEL: <br>                    if (gfFileOpen) <br>                    { <br>                        AcmAppPlayRecordStop(hwnd, paafd); <br>                        AcmAppPlayRecordStatus(hwnd, paafd); <br> <br>                        AcmAppPlayRecordClose(hwnd, paafd); <br>                    } <br> <br>                    EndDialog(hwnd, gfDirty); <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // AcmAppPlayRecord() </code></pre>
<p>&nbsp;</p></body>
</HTML>
