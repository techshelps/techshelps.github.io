<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WAVEIO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2471"></a>WAVEIO.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  waveio.c <br>// <br>//  Description: <br>//      Contains routines for opening and closing RIFF WAVE files. <br>// <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#include "appport.h" <br>#include "waveio.h" <br> <br>#include "debug.h" <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  WIOERR wioFileClose <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      LPWAVEIOCB pwio: <br>//   <br>//      DWORD fdwClose: <br>//   <br>//  Return (WIOERR): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>WIOERR WIOAPI wioFileClose <br>( <br>    LPWAVEIOCB      pwio, <br>    DWORD           fdwClose <br>) <br>{ <br>    // <br>    //  validate a couple of things... <br>    // <br>    if (NULL == pwio) <br>        return (WIOERR_BADPARAM); <br> <br> <br>    // <br>    //  get rid of stuff... <br>    // <br>//  wioStopWave(pwio); <br>     <br>    if (NULL != pwio-&gt;hmmio) <br>    { <br>        mmioClose(pwio-&gt;hmmio, 0); <br>    } <br>     <br>//  FreeWaveHeaders(lpwio); <br> <br>#if 0 <br>    if (pwio-&gt;pInfo) <br>        riffFreeINFO(&amp;(lpwio-&gt;pInfo)); <br>     <br>    if (pwio-&gt;pDisp) <br>        riffFreeDISP(&amp;(lpwio-&gt;pDisp)); <br>#endif <br> <br>    if (NULL != pwio-&gt;pwfx) <br>        GlobalFreePtr(pwio-&gt;pwfx); <br> <br>    _fmemset(pwio, 0, sizeof(*pwio)); <br> <br>    return (WIOERR_NOERROR); <br>} // wioFileClose() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  WIOERR wioFileOpen <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      LPWAVEIOCB pwio: <br>//   <br>//      LPCTSTR pszFilePath: <br>//   <br>//      DWORD fdwOpen: <br>//   <br>//  Return (WIOERR): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>WIOERR WIOAPI wioFileOpen <br>( <br>    LPWAVEIOCB      pwio, <br>    LPCTSTR         pszFilePath, <br>    DWORD           fdwOpen <br>) <br>{ <br>    UINT        u; <br>    TCHAR       ach[255]; <br>    WIOERR      werr; <br>    HMMIO       hmmio; <br>    MMCKINFO    ckRIFF; <br>    MMCKINFO    ck; <br>    DWORD       dw; <br> <br>    // <br>    //  validate a couple of things... <br>    // <br>    if (NULL == pwio) <br>        return (WIOERR_BADPARAM); <br> <br>    // <br>    //  default our error return (assume the worst) <br>    // <br>    _fmemset(pwio, 0, sizeof(*pwio)); <br>    werr = WIOERR_FILEERROR; <br> <br>    pwio-&gt;dwFlags   = fdwOpen; <br> <br>    // <br>    //  first try to open the file, etc.. open the given file for reading <br>    //  using buffered I/O <br>    // <br>    hmmio = mmioOpen((LPTSTR)pszFilePath, NULL, MMIO_READ | MMIO_ALLOCBUF); <br>    if (NULL == hmmio) <br>        goto wio_Open_Error; <br> <br>    pwio-&gt;hmmio     = hmmio; <br> <br> <br>    // <br>    //  locate a 'WAVE' form type... <br>    // <br>    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>    if (mmioDescend(hmmio, &amp;ckRIFF, NULL, MMIO_FINDRIFF)) <br>        goto wio_Open_Error; <br> <br>    // <br>    //  we found a WAVE chunk--now go through and get all subchunks that <br>    //  we know how to deal with... <br>    // <br>    pwio-&gt;dwDataSamples = (DWORD)-1L; <br> <br>#if 0 <br>    if (lrt=riffInitINFO(&amp;wio.pInfo)) <br>    { <br>        lr=lrt; <br>        goto wio_Open_Error; <br>    } <br>#endif <br> <br>    // <br>    // <br>    // <br>    while (MMSYSERR_NOERROR == mmioDescend(hmmio, &amp;ck, &amp;ckRIFF, 0)) <br>    { <br>        // <br>        //  quickly check for corrupt RIFF file--don't ascend past end! <br>        // <br>        if ((ck.dwDataOffset + ck.cksize) &gt; (ckRIFF.dwDataOffset + ckRIFF.cksize)) <br>        { <br>            DPF(1, "wioFileOpen() FILE MIGHT BE CORRUPT!"); <br>            DPF(1, "    ckRIFF.dwDataOffset: %lu", ckRIFF.dwDataOffset); <br>            DPF(1, "          ckRIFF.cksize: %lu", ckRIFF.cksize); <br>            DPF(1, "        ck.dwDataOffset: %lu", ck.dwDataOffset); <br>            DPF(1, "              ck.cksize: %lu", ck.cksize); <br> <br>            wsprintf(ach, TEXT("This wave file might be corrupt. The RIFF chunk.ckid '%.08lX' (data offset at %lu) specifies a cksize of %lu that extends beyond what the RIFF header cksize of %lu allows. Attempt to load?"), <br>                     ck.ckid, ck.dwDataOffset, ck.cksize, ckRIFF.cksize); <br>            u = MessageBox(NULL, ach, TEXT("wioFileOpen"), <br>                           MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL); <br>            if (IDNO == u) <br>            { <br>                werr = WIOERR_BADFILE; <br>                goto wio_Open_Error; <br>            } <br>        } <br> <br>        switch (ck.ckid) <br>        { <br>            case mmioFOURCC('L', 'I', 'S', 'T'): <br>                if (ck.fccType == mmioFOURCC('I', 'N', 'F', 'O')) <br>                { <br>#if 0 <br>                    if(lrt=riffReadINFO(hmmio, &amp;ck, wio.pInfo)) <br>                    { <br>                        lr=lrt; <br>                        goto wio_Open_Error; <br>                    } <br>#endif <br>                } <br>                break; <br>                 <br>            case mmioFOURCC('D', 'I', 'S', 'P'): <br>#if 0 <br>                riffReadDISP(hmmio, &amp;ck, &amp;(wio.pDisp)); <br>#endif <br>                break; <br>                 <br>            case mmioFOURCC('f', 'm', 't', ' '): <br>                // <br>                //  !?! another format chunk !?! <br>                // <br>                if (NULL != pwio-&gt;pwfx) <br>                    break; <br> <br>                // <br>                //  get size of the format chunk, allocate and lock memory <br>                //  for it. we always alloc a complete extended format header <br>                //  (even for PCM headers that do not have the cbSize field <br>                //  defined--we just set it to zero). <br>                // <br>                dw = ck.cksize; <br>                if (dw &lt; sizeof(WAVEFORMATEX)) <br>                    dw = sizeof(WAVEFORMATEX); <br> <br>                pwio-&gt;pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, dw); <br>                if (NULL == pwio-&gt;pwfx) <br>                { <br>                    werr = WIOERR_NOMEM; <br>                    goto wio_Open_Error; <br>                } <br> <br>                // <br>                //  read the format chunk <br>                // <br>                werr = WIOERR_FILEERROR; <br>                dw = ck.cksize; <br>                if (mmioRead(hmmio, (HPSTR)pwio-&gt;pwfx, dw) != (LONG)dw) <br>                    goto wio_Open_Error; <br>                break; <br> <br> <br>            case mmioFOURCC('d', 'a', 't', 'a'): <br>                // <br>                //  !?! multiple data chunks !?! <br>                // <br>                if (0L != pwio-&gt;dwDataBytes) <br>                    break; <br> <br>                // <br>                //  just hang on to the total length in bytes of this data <br>                //  chunk.. and the offset to the start of the data <br>                // <br>                pwio-&gt;dwDataBytes  = ck.cksize; <br>                pwio-&gt;dwDataOffset = ck.dwDataOffset; <br>                break; <br> <br> <br>            case mmioFOURCC('f', 'a', 'c', 't'): <br>                // <br>                //  !?! multiple fact chunks !?! <br>                // <br>                if (-1L != pwio-&gt;dwDataSamples) <br>                    break; <br> <br>                // <br>                //  read the first dword in the fact chunk--it's the only <br>                //  info we need (and is currently the only info defined for <br>                //  the fact chunk...) <br>                // <br>                //  if this fails, dwDataSamples will remain -1 so we will <br>                //  deal with it later... <br>                // <br>                mmioRead(hmmio, (HPSTR)&amp;pwio-&gt;dwDataSamples, sizeof(DWORD)); <br>                break; <br>        } <br> <br>        // <br>        //  step up to prepare for next chunk.. <br>        // <br>        mmioAscend(hmmio, &amp;ck, 0); <br>    } <br> <br>    // <br>    //  if no fmt chunk was found, then die! <br>    // <br>    if (NULL == pwio-&gt;pwfx) <br>    { <br>        werr = WIOERR_ERROR; <br>        goto wio_Open_Error; <br>    } <br> <br>    // <br>    //  all wave files other than PCM are _REQUIRED_ to have a fact chunk <br>    //  telling the number of samples that are contained in the file. it <br>    //  is optional for PCM (and if not present, we compute it here). <br>    // <br>    //  if the file is not PCM and the fact chunk is not found, then fail! <br>    // <br>    if (-1L == pwio-&gt;dwDataSamples) <br>    { <br>        if (WAVE_FORMAT_PCM == pwio-&gt;pwfx-&gt;wFormatTag) <br>        { <br>            pwio-&gt;dwDataSamples = pwio-&gt;dwDataBytes / pwio-&gt;pwfx-&gt;nBlockAlign; <br>        } <br>        else <br>        { <br>            // <br>            //  !!! HACK HACK HACK !!! <br>            // <br>            //  although this should be considered an invalid wave file, we <br>            //  will bring up a message box describing the error--hopefully <br>            //  people will start realizing that something is missing??? <br>            // <br>            u = MessageBox(NULL, TEXT("This wave file does not have a 'fact' chunk and requires one! This is completely invalid and MUST be fixed! Attempt to load it anyway?"), <br>                            TEXT("wioFileOpen"), MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL); <br>            if (IDNO == u) <br>            { <br>                werr = WIOERR_BADFILE; <br>                goto wio_Open_Error; <br>            } <br> <br>            // <br>            //  !!! need to hack stuff in here !!! <br>            // <br>            pwio-&gt;dwDataSamples = 0L; <br>        } <br>    } <br> <br>    // <br>    //  cool! no problems..  <br>    // <br>    return (WIOERR_NOERROR); <br> <br> <br>    // <br>    //  return error (after minor cleanup) <br>    // <br>wio_Open_Error: <br> <br>    wioFileClose(pwio, 0L); <br>    return (werr); <br>} // wioFileOpen() </code></pre>
<p>&nbsp;</p></body>
</HTML>
