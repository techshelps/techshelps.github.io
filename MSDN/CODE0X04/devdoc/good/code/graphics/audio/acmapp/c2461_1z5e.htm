<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACMTHUNK.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2462"></a>ACMTHUNK.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  acmthunk.c <br>// <br>//  Description: <br>//      This is a thunk layer to the Audio Compression Manager. It's  <br>//      purpose is to allow an application to use the ACM only if it is <br>//      available (like under Win 3.1 and NT where the ACM may or may not <br>//      be installed). <br>// <br>//      There are two requirements for using this module: <br>// <br>//      1.  Compile and link with this module before linking to MMSYSTEM.LIB. <br>//          Do *NOT* link with MSACM.LIB. <br>// <br>//      2.  Before calling any other functions in ACM function set, call <br>//          acmThunkInitialize(). This will cause all dyna-linking to occur. <br>// <br>//      3.  Before exiting your application, call acmThunkTerminate(). <br>//          This will unlink to the ACM and free allocated resources. <br>// <br>//      NOTE! this could be written more efficiently in Assembly by doing <br>//      a jump to the correct API in the ACM, but this would not be <br>//      portable (easily) on NT. So the arguments will be repushed on the <br>//      stack.. such is life. <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br> <br>// <br>// <br>// <br>#ifdef WIN32 <br>    #define BCODE <br>#else <br>    #define BCODE           _based(_segname("_CODE")) <br>#endif <br> <br> <br>//==========================================================================; <br>// <br>//  Prototypes and String Defines for Dyna-Linking to the ACM <br>// <br>// <br>//==========================================================================; <br> <br>#define ACMINST_NOT_PRESENT     NULL <br>#define ACMINST_TRY_LINKING     (HINSTANCE)(UINT)-1 <br> <br>static HINSTANCE    ghinstAcm   = ACMINST_TRY_LINKING; <br> <br>#ifdef WIN32 <br>TCHAR BCODE gszAcmModuleName[]  = TEXT("MSACM32.DLL"); <br>#else <br>char BCODE  gszAcmModuleName[]  = "MSACM.DLL"; <br>#endif <br> <br>FARPROC    *gpafnAcmFunctions; <br> <br>PSTR BCODE  gapszAcmFunctions[] = <br>{ <br>    "acmGetVersion", <br>    "acmMetrics", <br> <br>    "acmDriverEnum", <br>#ifdef WIN32 <br>    "acmDriverDetailsW", <br>    "acmDriverDetailsA", <br>#else <br>    "acmDriverDetails", <br>#endif <br>#ifdef WIN32 <br>    "acmDriverAddW", <br>    "acmDriverAddA", <br>#else <br>    "acmDriverAdd", <br>#endif <br>    "acmDriverRemove", <br>    "acmDriverOpen", <br>    "acmDriverClose", <br>    "acmDriverMessage", <br>    "acmDriverID", <br>    "acmDriverPriority", <br> <br>#ifdef WIN32 <br>    "acmFormatTagDetailsW", <br>    "acmFormatTagDetailsA", <br>#else <br>    "acmFormatTagDetails", <br>#endif <br>#ifdef WIN32 <br>    "acmFormatTagEnumW", <br>    "acmFormatTagEnumA", <br>#else <br>    "acmFormatTagEnum", <br>#endif <br>#ifdef WIN32 <br>    "acmFormatChooseW", <br>    "acmFormatChooseA", <br>#else <br>    "acmFormatChoose", <br>#endif <br>#ifdef WIN32 <br>    "acmFormatDetailsW", <br>    "acmFormatDetailsA", <br>#else <br>    "acmFormatDetails", <br>#endif <br>#ifdef WIN32 <br>    "acmFormatEnumW", <br>    "acmFormatEnumA", <br>#else <br>    "acmFormatEnum", <br>#endif <br>    "acmFormatSuggest", <br> <br>#ifdef WIN32 <br>    "acmFilterTagDetailsW", <br>    "acmFilterTagDetailsA", <br>#else <br>    "acmFilterTagDetails", <br>#endif <br>#ifdef WIN32 <br>    "acmFilterTagEnumW", <br>    "acmFilterTagEnumA", <br>#else <br>    "acmFilterTagEnum", <br>#endif <br>#ifdef WIN32 <br>    "acmFilterChooseW", <br>    "acmFilterChooseA", <br>#else <br>    "acmFilterChoose", <br>#endif <br>#ifdef WIN32 <br>    "acmFilterDetailsW", <br>    "acmFilterDetailsA", <br>#else <br>    "acmFilterDetails", <br>#endif <br>#ifdef WIN32 <br>    "acmFilterEnumW", <br>    "acmFilterEnumA", <br>#else <br>    "acmFilterEnum", <br>#endif <br> <br>    "acmStreamOpen", <br>    "acmStreamClose", <br>    "acmStreamSize", <br>    "acmStreamConvert", <br>    "acmStreamReset", <br>    "acmStreamPrepareHeader", <br>    "acmStreamUnprepareHeader" <br>}; <br> <br>#ifdef WIN32     <br>// <br>//  For Win32 <br>// <br>enum <br>{ <br>     ACMTHUNK_GETVERSION = 0, <br>     ACMTHUNK_METRICS, <br>     ACMTHUNK_DRIVERENUM, <br>     ACMTHUNK_DRIVERDETAILSW, <br>     ACMTHUNK_DRIVERDETAILSA, <br>     ACMTHUNK_DRIVERADDW, <br>     ACMTHUNK_DRIVERADDA, <br>     ACMTHUNK_DRIVERREMOVE, <br>     ACMTHUNK_DRIVEROPEN, <br>     ACMTHUNK_DRIVERCLOSE, <br>     ACMTHUNK_DRIVERMESSAGE, <br>     ACMTHUNK_DRIVERID, <br>     ACMTHUNK_DRIVERPRIORITY, <br>     ACMTHUNK_FORMATTAGDETAILSW, <br>     ACMTHUNK_FORMATTAGDETAILSA, <br>     ACMTHUNK_FORMATTAGENUMW, <br>     ACMTHUNK_FORMATTAGENUMA, <br>     ACMTHUNK_FORMATCHOOSEW, <br>     ACMTHUNK_FORMATCHOOSEA, <br>     ACMTHUNK_FORMATDETAILSW, <br>     ACMTHUNK_FORMATDETAILSA, <br>     ACMTHUNK_FORMATENUMW, <br>     ACMTHUNK_FORMATENUMA, <br>     ACMTHUNK_FORMATSUGGEST, <br>     ACMTHUNK_FILTERTAGDETAILSW, <br>     ACMTHUNK_FILTERTAGDETAILSA, <br>     ACMTHUNK_FILTERTAGENUMW, <br>     ACMTHUNK_FILTERTAGENUMA, <br>     ACMTHUNK_FILTERCHOOSEW, <br>     ACMTHUNK_FILTERCHOOSEA, <br>     ACMTHUNK_FILTERDETAILSW, <br>     ACMTHUNK_FILTERDETAILSA, <br>     ACMTHUNK_FILTERENUMW, <br>     ACMTHUNK_FILTERENUMA, <br>     ACMTHUNK_STREAMOPEN, <br>     ACMTHUNK_STREAMCLOSE, <br>     ACMTHUNK_STREAMSIZE, <br>     ACMTHUNK_STREAMCONVERT, <br>     ACMTHUNK_STREAMRESET, <br>     ACMTHUNK_STREAMPREPAREHEADER, <br>     ACMTHUNK_STREAMUNPREPAREHEADER, <br> <br>     ACMTHUNK_MAX_FUNCTIONS <br>}; <br>      <br>#ifdef _UNICODE <br>#define ACMTHUNK_DRIVERDETAILS    ACMTHUNK_DRIVERDETAILSW <br>#define ACMTHUNK_DRIVERADD    ACMTHUNK_DRIVERADDW <br>#define ACMTHUNK_FORMATTAGDETAILS   ACMTHUNK_FORMATTAGDETAILSW <br>#define ACMTHUNK_FORMATTAGENUM    ACMTHUNK_FORMATTAGENUMW <br>#define ACMTHUNK_FORMATCHOOSE    ACMTHUNK_FORMATCHOOSEW <br>#define ACMTHUNK_FORMATDETAILS    ACMTHUNK_FORMATDETAILSW <br>#define ACMTHUNK_FORMATENUM    ACMTHUNK_FORMATENUMW <br>#define ACMTHUNK_FILTERTAGDETAILS   ACMTHUNK_FILTERTAGDETAILSW <br>#define ACMTHUNK_FILTERTAGENUM    ACMTHUNK_FILTERTAGENUMW <br>#define ACMTHUNK_FILTERCHOOSE    ACMTHUNK_FILTERCHOOSEW <br>#define ACMTHUNK_FILTERDETAILS    ACMTHUNK_FILTERDETAILSW <br>#define ACMTHUNK_FILTERENUM    ACMTHUNK_FILTERENUMW <br> <br>#else <br>#define ACMTHUNK_DRIVERDETAILS    ACMTHUNK_DRIVERDETAILSA <br>#define ACMTHUNK_DRIVERADD    ACMTHUNK_DRIVERADDA <br>#define ACMTHUNK_FORMATTAGDETAILS   ACMTHUNK_FORMATTAGDETAILSA <br>#define ACMTHUNK_FORMATTAGENUM    ACMTHUNK_FORMATTAGENUMA <br>#define ACMTHUNK_FORMATCHOOSE    ACMTHUNK_FORMATCHOOSEA <br>#define ACMTHUNK_FORMATDETAILS    ACMTHUNK_FORMATDETAILSA <br>#define ACMTHUNK_FORMATENUM    ACMTHUNK_FORMATENUMA <br>#define ACMTHUNK_FILTERTAGDETAILS   ACMTHUNK_FILTERTAGDETAILSA <br>#define ACMTHUNK_FILTERTAGENUM    ACMTHUNK_FILTERTAGENUMA <br>#define ACMTHUNK_FILTERCHOOSE    ACMTHUNK_FILTERCHOOSEA <br>#define ACMTHUNK_FILTERDETAILS    ACMTHUNK_FILTERDETAILSA <br>#define ACMTHUNK_FILTERENUM    ACMTHUNK_FILTERENUMA <br> <br>#endif <br> <br>#else     // if Win32 <br>// <br>//  For Win16 <br>// <br>enum <br>{ <br>     ACMTHUNK_GETVERSION = 0, <br>     ACMTHUNK_METRICS, <br>     ACMTHUNK_DRIVERENUM, <br>     ACMTHUNK_DRIVERDETAILS, <br>     ACMTHUNK_DRIVERADD, <br>     ACMTHUNK_DRIVERREMOVE, <br>     ACMTHUNK_DRIVEROPEN, <br>     ACMTHUNK_DRIVERCLOSE, <br>     ACMTHUNK_DRIVERMESSAGE, <br>     ACMTHUNK_DRIVERID, <br>     ACMTHUNK_DRIVERPRIORITY, <br>     ACMTHUNK_FORMATTAGDETAILS, <br>     ACMTHUNK_FORMATTAGENUM, <br>     ACMTHUNK_FORMATCHOOSE, <br>     ACMTHUNK_FORMATDETAILS, <br>     ACMTHUNK_FORMATENUM, <br>     ACMTHUNK_FORMATSUGGEST, <br>     ACMTHUNK_FILTERTAGDETAILS, <br>     ACMTHUNK_FILTERTAGENUM, <br>     ACMTHUNK_FILTERCHOOSE, <br>     ACMTHUNK_FILTERDETAILS, <br>     ACMTHUNK_FILTERENUM, <br>     ACMTHUNK_STREAMOPEN, <br>     ACMTHUNK_STREAMCLOSE, <br>     ACMTHUNK_STREAMSIZE, <br>     ACMTHUNK_STREAMCONVERT, <br>     ACMTHUNK_STREAMRESET, <br>     ACMTHUNK_STREAMPREPAREHEADER, <br>     ACMTHUNK_STREAMUNPREPAREHEADER, <br> <br>     ACMTHUNK_MAX_FUNCTIONS <br>}; <br> <br>#endif// if WIN32 else <br> <br>#define ACMTHUNK_SIZE_TABLE_BYTES   (ACMTHUNK_MAX_FUNCTIONS * sizeof(FARPROC)) <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL acmThunkInitialize <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      None. <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FAR PASCAL acmThunkInitialize <br>( <br>    void <br>) <br>{ <br>    DWORD (ACMAPI *pfnAcmGetVersion) <br>    ( <br>        void <br>    ); <br> <br>    UINT            fuErrorMode; <br>    DWORD           dwVersion; <br>    UINT            u; <br> <br>    // <br>    //  if we have already linked to the API's, then just succeed... <br>    // <br>    if (NULL != gpafnAcmFunctions) <br>    { <br>        // <br>        //  someone isn't satisfied with calling this API only once? <br>        // <br>        return (TRUE); <br>    } <br> <br> <br>    // <br>    //  if we have already tried to link to the ACM, then fail this <br>    //  call--it isn't present. <br>    // <br>    if (ACMINST_TRY_LINKING != ghinstAcm) <br>        return (FALSE); <br> <br> <br>    // <br>    //  try to get a handle on the ACM--if we cannot do this, then fail <br>    // <br>    fuErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br>    ghinstAcm = LoadLibrary(gszAcmModuleName); <br>    SetErrorMode(fuErrorMode); <br>    if (ghinstAcm &lt; (HINSTANCE)HINSTANCE_ERROR) <br>    { <br>        ghinstAcm = ACMINST_NOT_PRESENT; <br>        return (FALSE); <br>    } <br> <br>    (FARPROC)pfnAcmGetVersion = GetProcAddress(ghinstAcm, gapszAcmFunctions[ACMTHUNK_GETVERSION]); <br>    if (NULL == pfnAcmGetVersion) <br>    { <br>        FreeLibrary(ghinstAcm); <br>        ghinstAcm = ACMINST_NOT_PRESENT; <br> <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    //  allocate our array of function pointers to the ACM... note that <br>    //  this is dynamically allocated so if the ACM is _not_ present, <br>    //  then this code and data takes up very little space. <br>    // <br>    gpafnAcmFunctions = (FARPROC *)LocalAlloc(LPTR, ACMTHUNK_SIZE_TABLE_BYTES); <br>    if (NULL == gpafnAcmFunctions) <br>    { <br>        FreeLibrary(ghinstAcm); <br>        ghinstAcm = ACMINST_NOT_PRESENT; <br> <br>        return (FALSE); <br>    } <br> <br>    gpafnAcmFunctions[ACMTHUNK_GETVERSION] = (FARPROC)pfnAcmGetVersion; <br> <br>    // <br>    //  if the version of the ACM is *NOT* V2.00 or greater, then <br>    //  all other API's are unavailable--so don't waste time trying <br>    //  to link to them. <br>    // <br>    dwVersion = (* pfnAcmGetVersion)(); <br>    if (0x0200 &gt; HIWORD(dwVersion)) <br>    { <br>        return (TRUE); <br>    } <br> <br> <br>    // <br>    //  yipee! the ACM V2.00 or greater appears to be installed and <br>    //  happy with us--so link to the rest of the nifty cool API's. <br>    // <br>    //  start at index 1 since we already linked to acmGetVersion above <br>    // <br>    for (u = 1; u &lt; ACMTHUNK_MAX_FUNCTIONS; u++) <br>    { <br>        gpafnAcmFunctions[u] = GetProcAddress(ghinstAcm, gapszAcmFunctions[u]); <br>    } <br> <br> <br>    // <br>    //  finally, return success <br>    // <br>    return (TRUE); <br>} // acmThunkInitialize() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL acmThunkTerminate <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      None. <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FAR PASCAL acmThunkTerminate <br>( <br>    void <br>) <br>{ <br>    // <br>    // <br>    // <br>    if (NULL != gpafnAcmFunctions) <br>    { <br>        LocalFree((HLOCAL)gpafnAcmFunctions); <br> <br>        gpafnAcmFunctions = NULL; <br> <br>        FreeLibrary(ghinstAcm); <br>        ghinstAcm = ACMINST_TRY_LINKING; <br>    } <br> <br>    return (TRUE); <br>} // acmThunkTerminate() <br> <br> <br>//==========================================================================; <br>// <br>//  General Information API's <br>// <br>// <br>//==========================================================================; <br> <br>DWORD ACMAPI acmGetVersion <br>( <br>    void <br>) <br>{ <br>    DWORD (ACMAPI *pfnAcmGetVersion) <br>    ( <br>        void <br>    ); <br> <br>    DWORD           dwVersion; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (0L); <br> <br>    (FARPROC)pfnAcmGetVersion = gpafnAcmFunctions[ACMTHUNK_GETVERSION]; <br>    if (NULL == pfnAcmGetVersion) <br>        return (0L); <br> <br>    dwVersion = (* pfnAcmGetVersion)(); <br> <br>    return (dwVersion); <br>} // acmGetVersion() <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmMetrics <br>( <br>    HACMOBJ                 hao, <br>    UINT                    uMetric, <br>    LPVOID                  pMetric <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmMetrics) <br>    ( <br>        HACMOBJ                 hao, <br>        UINT                    uMetric, <br>        LPVOID                  pMetric <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmMetrics = gpafnAcmFunctions[ACMTHUNK_METRICS]; <br>    if (NULL == pfnAcmMetrics) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmMetrics)(hao, uMetric, pMetric); <br> <br>    return (mmr); <br>} // acmMetrics() <br> <br> <br>//==========================================================================; <br>// <br>//  ACM Driver Management API's <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverEnum <br>( <br>    ACMDRIVERENUMCB         fnCallback, <br>    DWORD                   dwInstance, <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverEnum) <br>    ( <br>        ACMDRIVERENUMCB         fnCallback, <br>        DWORD                   dwInstance, <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverEnum = gpafnAcmFunctions[ACMTHUNK_DRIVERENUM]; <br>    if (NULL == pfnAcmDriverEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverEnum)(fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverDetails <br>( <br>    HACMDRIVERID            hadid, <br>    LPACMDRIVERDETAILS      padd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverDetails) <br>    ( <br>        HACMDRIVERID            hadid, <br>        LPACMDRIVERDETAILS      padd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverDetails = gpafnAcmFunctions[ACMTHUNK_DRIVERDETAILS]; <br>    if (NULL == pfnAcmDriverDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverDetails)(hadid, padd, fdwDetails); <br> <br>    return (mmr); <br>} <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmDriverDetailsA <br>( <br>    HACMDRIVERID            hadid, <br>    LPACMDRIVERDETAILSA     padd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverDetails) <br>    ( <br>        HACMDRIVERID            hadid, <br>        LPACMDRIVERDETAILSA     padd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverDetails = gpafnAcmFunctions[ACMTHUNK_DRIVERDETAILSA]; <br>    if (NULL == pfnAcmDriverDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverDetails)(hadid, padd, fdwDetails); <br> <br>    return (mmr); <br>} <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverAdd <br>( <br>    LPHACMDRIVERID          phadid, <br>    HINSTANCE               hinstModule, <br>    LPARAM                  lParam,  <br>    DWORD                   dwPriority, <br>    DWORD                   fdwAdd <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverAdd) <br>    ( <br>        LPHACMDRIVERID          phadid, <br>        HINSTANCE               hinstModule, <br>        LPARAM                  lParam,  <br>        DWORD                   dwPriority, <br>        DWORD                   fdwAdd <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverAdd = gpafnAcmFunctions[ACMTHUNK_DRIVERADD]; <br>    if (NULL == pfnAcmDriverAdd) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverAdd)(phadid, hinstModule, lParam, dwPriority, fdwAdd); <br> <br>    return (mmr); <br>} <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmDriverAddA <br>( <br>    LPHACMDRIVERID          phadid, <br>    HINSTANCE               hinstModule, <br>    LPARAM                  lParam,  <br>    DWORD                   dwPriority, <br>    DWORD                   fdwAdd <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverAdd) <br>    ( <br>        LPHACMDRIVERID          phadid, <br>        HINSTANCE               hinstModule, <br>        LPARAM                  lParam,  <br>        DWORD                   dwPriority, <br>        DWORD                   fdwAdd <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverAdd = gpafnAcmFunctions[ACMTHUNK_DRIVERADDA]; <br>    if (NULL == pfnAcmDriverAdd) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverAdd)(phadid, hinstModule, lParam, dwPriority, fdwAdd); <br> <br>    return (mmr); <br>} <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverRemove <br>( <br>    HACMDRIVERID            hadid, <br>    DWORD                   fdwRemove <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverRemove) <br>    ( <br>        HACMDRIVERID            hadid, <br>        DWORD                   fdwRemove <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverRemove = gpafnAcmFunctions[ACMTHUNK_DRIVERREMOVE]; <br>    if (NULL == pfnAcmDriverRemove) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverRemove)(hadid, fdwRemove); <br> <br>    return (mmr); <br>} <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverOpen <br>( <br>    LPHACMDRIVER            phad,  <br>    HACMDRIVERID            hadid, <br>    DWORD                   fdwOpen <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverOpen) <br>    ( <br>        LPHACMDRIVER            phad,  <br>        HACMDRIVERID            hadid, <br>        DWORD                   fdwOpen <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverOpen = gpafnAcmFunctions[ACMTHUNK_DRIVEROPEN]; <br>    if (NULL == pfnAcmDriverOpen) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverOpen)(phad, hadid, fdwOpen); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverClose <br>( <br>    HACMDRIVER              had, <br>    DWORD                   fdwClose <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverClose) <br>    ( <br>        HACMDRIVER              had, <br>        DWORD                   fdwClose <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverClose = gpafnAcmFunctions[ACMTHUNK_DRIVERCLOSE]; <br>    if (NULL == pfnAcmDriverClose) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverClose)(had, fdwClose); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>LRESULT ACMAPI acmDriverMessage <br>( <br>    HACMDRIVER              had, <br>    UINT                    uMsg,  <br>    LPARAM                  lParam1, <br>    LPARAM                  lParam2 <br>) <br>{ <br>    LRESULT (ACMAPI *pfnAcmDriverMessage) <br>    ( <br>        HACMDRIVER              had, <br>        UINT                    uMsg,  <br>        LPARAM                  lParam1, <br>        LPARAM                  lParam2 <br>    ); <br> <br>    LRESULT         lr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverMessage = gpafnAcmFunctions[ACMTHUNK_DRIVERMESSAGE]; <br>    if (NULL == pfnAcmDriverMessage) <br>        return (MMSYSERR_ERROR); <br> <br>    lr = (* pfnAcmDriverMessage)(had, uMsg, lParam1, lParam2); <br> <br>    return (lr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverID <br>( <br>    HACMOBJ                 hao, <br>    LPHACMDRIVERID          phadid, <br>    DWORD                   fdwDriverId <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverId) <br>    ( <br>        HACMOBJ                 hao, <br>        LPHACMDRIVERID          phadid, <br>        DWORD                   fdwDriverId <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverId = gpafnAcmFunctions[ACMTHUNK_DRIVERID]; <br>    if (NULL == pfnAcmDriverId) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverId)(hao, phadid, fdwDriverId); <br> <br>    return (mmr); <br>} <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmDriverPriority <br>( <br>    HACMDRIVERID            hadid, <br>    DWORD                   dwPriority, <br>    DWORD                   fdwPriority <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmDriverPriority) <br>    ( <br>        HACMDRIVERID            hadid, <br>        DWORD                   dwPriority, <br>        DWORD                   fdwPriority <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmDriverPriority = gpafnAcmFunctions[ACMTHUNK_DRIVERPRIORITY]; <br>    if (NULL == pfnAcmDriverPriority) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmDriverPriority)(hadid, dwPriority, fdwPriority); <br> <br>    return (mmr); <br>} <br> <br> <br>//==========================================================================; <br>// <br>//  Format Tag Information API's <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFormatTagDetails <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATTAGDETAILS   paftd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatTagDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATTAGDETAILS   paftd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatTagDetails = gpafnAcmFunctions[ACMTHUNK_FORMATTAGDETAILS]; <br>    if (NULL == pfnAcmFormatTagDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatTagDetails)(had, paftd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFormatTagDetails() <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFormatTagDetailsA <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATTAGDETAILSA  paftd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatTagDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATTAGDETAILSA  paftd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatTagDetails = gpafnAcmFunctions[ACMTHUNK_FORMATTAGDETAILSA]; <br>    if (NULL == pfnAcmFormatTagDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatTagDetails)(had, paftd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFormatTagDetails() <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFormatTagEnum <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATTAGDETAILS   paftd, <br>    ACMFORMATTAGENUMCB      fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatTagEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATTAGDETAILS   paftd, <br>        ACMFORMATTAGENUMCB      fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatTagEnum = gpafnAcmFunctions[ACMTHUNK_FORMATTAGENUM]; <br>    if (NULL == pfnAcmFormatTagEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} // acmFormatTagEnum() <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFormatTagEnumA <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATTAGDETAILSA  paftd, <br>    ACMFORMATTAGENUMCBA     fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatTagEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATTAGDETAILSA  paftd, <br>        ACMFORMATTAGENUMCBA     fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatTagEnum = gpafnAcmFunctions[ACMTHUNK_FORMATTAGENUMA]; <br>    if (NULL == pfnAcmFormatTagEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} // acmFormatTagEnum() <br>#endif <br> <br>//==========================================================================; <br>// <br>//  Format Information API's <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFormatChoose <br>( <br>    LPACMFORMATCHOOSE       pafmtc <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatChoose) <br>    ( <br>        LPACMFORMATCHOOSE       pafmtc <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatChoose = gpafnAcmFunctions[ACMTHUNK_FORMATCHOOSE]; <br>    if (NULL == pfnAcmFormatChoose) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatChoose)(pafmtc); <br> <br>    return (mmr); <br>} <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFormatChooseA <br>( <br>    LPACMFORMATCHOOSEA      pafmtc <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatChoose) <br>    ( <br>        LPACMFORMATCHOOSEA      pafmtc <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatChoose = gpafnAcmFunctions[ACMTHUNK_FORMATCHOOSEA]; <br>    if (NULL == pfnAcmFormatChoose) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatChoose)(pafmtc); <br> <br>    return (mmr); <br>} <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFormatDetails <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATDETAILS      pafd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATDETAILS      pafd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatDetails = gpafnAcmFunctions[ACMTHUNK_FORMATDETAILS]; <br>    if (NULL == pfnAcmFormatDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatDetails)(had, pafd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFormatDetails() <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFormatDetailsA <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATDETAILSA     pafd, <br>    DWORD                   fdwDetails </code></pre>
<p>
</p>
<pre><code>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATDETAILSA     pafd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatDetails = gpafnAcmFunctions[ACMTHUNK_FORMATDETAILSA]; <br>    if (NULL == pfnAcmFormatDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatDetails)(had, pafd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFormatDetails() <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFormatEnum <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATDETAILS      pafd, <br>    ACMFORMATENUMCB         fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATDETAILS      pafd, <br>        ACMFORMATENUMCB         fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatEnum = gpafnAcmFunctions[ACMTHUNK_FORMATENUM]; <br>    if (NULL == pfnAcmFormatEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatEnum)(had, pafd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFormatEnumA <br>( <br>    HACMDRIVER              had, <br>    LPACMFORMATDETAILSA     pafd, <br>    ACMFORMATENUMCBA        fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFORMATDETAILSA     pafd, <br>        ACMFORMATENUMCBA        fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatEnum = gpafnAcmFunctions[ACMTHUNK_FORMATENUMA]; <br>    if (NULL == pfnAcmFormatEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatEnum)(had, pafd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFormatSuggest <br>( <br>    HACMDRIVER          had, <br>    LPWAVEFORMATEX      pwfxSrc, <br>    LPWAVEFORMATEX      pwfxDst, <br>    DWORD               cbwfxDst, <br>    DWORD               fdwSuggest <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFormatSuggest) <br>    ( <br>        HACMDRIVER          had, <br>        LPWAVEFORMATEX      pwfxSrc, <br>        LPWAVEFORMATEX      pwfxDst, <br>        DWORD               cbwfxDst, <br>        DWORD               fdwSuggest <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFormatSuggest = gpafnAcmFunctions[ACMTHUNK_FORMATSUGGEST]; <br>    if (NULL == pfnAcmFormatSuggest) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFormatSuggest)(had, pwfxSrc, pwfxDst, cbwfxDst, fdwSuggest); <br> <br>    return (mmr); <br>} <br> <br> <br>//==========================================================================; <br>// <br>//  Filter Tag Information API's <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFilterTagDetails <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERTAGDETAILS   paftd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterTagDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERTAGDETAILS   paftd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterTagDetails = gpafnAcmFunctions[ACMTHUNK_FILTERTAGDETAILS]; <br>    if (NULL == pfnAcmFilterTagDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterTagDetails)(had, paftd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFilterTagDetails() <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFilterTagDetailsA <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERTAGDETAILSA  paftd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterTagDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERTAGDETAILSA  paftd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterTagDetails = gpafnAcmFunctions[ACMTHUNK_FILTERTAGDETAILSA]; <br>    if (NULL == pfnAcmFilterTagDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterTagDetails)(had, paftd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFilterTagDetails() <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFilterTagEnum <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERTAGDETAILS   paftd, <br>    ACMFILTERTAGENUMCB      fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterTagEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERTAGDETAILS   paftd, <br>        ACMFILTERTAGENUMCB      fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterTagEnum = gpafnAcmFunctions[ACMTHUNK_FILTERTAGENUM]; <br>    if (NULL == pfnAcmFilterTagEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} // acmFilterTagEnum() <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFilterTagEnumA <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERTAGDETAILSA  paftd, <br>    ACMFILTERTAGENUMCBA     fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterTagEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERTAGDETAILSA  paftd, <br>        ACMFILTERTAGENUMCBA     fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterTagEnum = gpafnAcmFunctions[ACMTHUNK_FILTERTAGENUMA]; <br>    if (NULL == pfnAcmFilterTagEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterTagEnum)(had, paftd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} // acmFilterTagEnum() <br>#endif <br> <br>//==========================================================================; <br>// <br>//  Filter Information API's <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFilterChoose <br>( <br>    LPACMFILTERCHOOSE       pafltrc <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterChoose) <br>    ( <br>        LPACMFILTERCHOOSE       pafltrc <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterChoose = gpafnAcmFunctions[ACMTHUNK_FILTERCHOOSE]; <br>    if (NULL == pfnAcmFilterChoose) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterChoose)(pafltrc); <br> <br>    return (mmr); <br>} <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFilterChooseA <br>( <br>    LPACMFILTERCHOOSEA      pafltrc <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterChoose) <br>    ( <br>        LPACMFILTERCHOOSEA      pafltrc <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterChoose = gpafnAcmFunctions[ACMTHUNK_FILTERCHOOSEA]; <br>    if (NULL == pfnAcmFilterChoose) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterChoose)(pafltrc); <br> <br>    return (mmr); <br>} <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFilterDetails <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERDETAILS      pafd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERDETAILS      pafd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterDetails = gpafnAcmFunctions[ACMTHUNK_FILTERDETAILS]; <br>    if (NULL == pfnAcmFilterDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterDetails)(had, pafd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFilterDetails() <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFilterDetailsA <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERDETAILSA     pafd, <br>    DWORD                   fdwDetails <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterDetails) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERDETAILSA     pafd, <br>        DWORD                   fdwDetails <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterDetails = gpafnAcmFunctions[ACMTHUNK_FILTERDETAILSA]; <br>    if (NULL == pfnAcmFilterDetails) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterDetails)(had, pafd, fdwDetails); <br> <br>    return (mmr); <br>} // acmFilterDetails() <br>#endif <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmFilterEnum <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERDETAILS      pafd, <br>    ACMFILTERENUMCB         fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERDETAILS      pafd, <br>        ACMFILTERENUMCB         fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterEnum = gpafnAcmFunctions[ACMTHUNK_FILTERENUM]; <br>    if (NULL == pfnAcmFilterEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterEnum)(had, pafd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} <br> <br>#ifdef _UNICODE <br>MMRESULT ACMAPI acmFilterEnumA <br>( <br>    HACMDRIVER              had, <br>    LPACMFILTERDETAILSA     pafd, <br>    ACMFILTERENUMCBA        fnCallback, <br>    DWORD                   dwInstance,  <br>    DWORD                   fdwEnum <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmFilterEnum) <br>    ( <br>        HACMDRIVER              had, <br>        LPACMFILTERDETAILSA     pafd, <br>        ACMFILTERENUMCBA        fnCallback, <br>        DWORD                   dwInstance,  <br>        DWORD                   fdwEnum <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmFilterEnum = gpafnAcmFunctions[ACMTHUNK_FILTERENUMA]; <br>    if (NULL == pfnAcmFilterEnum) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmFilterEnum)(had, pafd, fnCallback, dwInstance, fdwEnum); <br> <br>    return (mmr); <br>} <br>#endif <br> <br>//==========================================================================; <br>// <br>//  ACM Stream Management API's <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamOpen <br>( <br>    LPHACMSTREAM            phas, <br>    HACMDRIVER              had, <br>    LPWAVEFORMATEX          pwfxSrc, <br>    LPWAVEFORMATEX          pwfxDst, <br>    LPWAVEFILTER            pwfltr, <br>    DWORD                   dwCallback, <br>    DWORD                   dwInstance, <br>    DWORD                   fdwOpen <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamOpen) <br>    ( <br>        LPHACMSTREAM            phas, <br>        HACMDRIVER              had, <br>        LPWAVEFORMATEX          pwfxSrc, <br>        LPWAVEFORMATEX          pwfxDst, <br>        LPWAVEFILTER            pwfltr, <br>        DWORD                   dwCallback, <br>        DWORD                   dwInstance, <br>        DWORD                   fdwOpen <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamOpen = gpafnAcmFunctions[ACMTHUNK_STREAMOPEN]; <br>    if (NULL == pfnAcmStreamOpen) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamOpen)(phas, had, pwfxSrc, pwfxDst, pwfltr, dwCallback, dwInstance, fdwOpen); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamClose <br>( <br>    HACMSTREAM              has, <br>    DWORD                   fdwClose <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamClose) <br>    ( <br>        HACMSTREAM              has, <br>        DWORD                   fdwClose <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamClose = gpafnAcmFunctions[ACMTHUNK_STREAMCLOSE]; <br>    if (NULL == pfnAcmStreamClose) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamClose)(has, fdwClose); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamSize <br>( <br>    HACMSTREAM              has, <br>    DWORD                   cbInput, <br>    LPDWORD                 pdwOutputBytes, <br>    DWORD                   fdwSize <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamSize) <br>    ( <br>        HACMSTREAM              has, <br>        DWORD                   cbInput, <br>        LPDWORD                 pdwOutputBytes, <br>        DWORD                   fdwSize <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamSize = gpafnAcmFunctions[ACMTHUNK_STREAMSIZE]; <br>    if (NULL == pfnAcmStreamSize) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamSize)(has, cbInput, pdwOutputBytes, fdwSize); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamConvert <br>( <br>    HACMSTREAM              has,  <br>    LPACMSTREAMHEADER       pash, <br>    DWORD                   fdwConvert <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamConvert) <br>    ( <br>        HACMSTREAM              has,  <br>        LPACMSTREAMHEADER       pash, <br>        DWORD                   fdwConvert <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamConvert = gpafnAcmFunctions[ACMTHUNK_STREAMCONVERT]; <br>    if (NULL == pfnAcmStreamConvert) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamConvert)(has, pash, fdwConvert); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamReset <br>( <br>    HACMSTREAM              has,  <br>    DWORD                   fdwReset <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamReset) <br>    ( <br>        HACMSTREAM              has,  <br>        DWORD                   fdwReset <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamReset = gpafnAcmFunctions[ACMTHUNK_STREAMRESET]; <br>    if (NULL == pfnAcmStreamReset) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamReset)(has, fdwReset); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamPrepareHeader <br>( <br>    HACMSTREAM              has,  <br>    LPACMSTREAMHEADER       pash, <br>    DWORD                   fdwPrepare <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamPrepareHeader) <br>    ( <br>        HACMSTREAM              has,  <br>        LPACMSTREAMHEADER       pash, <br>        DWORD                   fdwPrepare <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamPrepareHeader = gpafnAcmFunctions[ACMTHUNK_STREAMPREPAREHEADER]; <br>    if (NULL == pfnAcmStreamPrepareHeader) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamPrepareHeader)(has, pash, fdwPrepare); <br> <br>    return (mmr); <br>} <br> <br> <br>//--------------------------------------------------------------------------; <br>//--------------------------------------------------------------------------; <br> <br>MMRESULT ACMAPI acmStreamUnprepareHeader <br>( <br>    HACMSTREAM              has,  <br>    LPACMSTREAMHEADER       pash, <br>    DWORD                   fdwUnprepare <br>) <br>{ <br>    MMRESULT (ACMAPI *pfnAcmStreamUnprepareHeader) <br>    ( <br>        HACMSTREAM              has,  <br>        LPACMSTREAMHEADER       pash, <br>        DWORD                   fdwUnprepare <br>    ); <br> <br>    MMRESULT        mmr; <br> <br>    if (NULL == gpafnAcmFunctions) <br>        return (MMSYSERR_ERROR); <br> <br>    (FARPROC)pfnAcmStreamUnprepareHeader = gpafnAcmFunctions[ACMTHUNK_STREAMUNPREPAREHEADER]; <br>    if (NULL == pfnAcmStreamUnprepareHeader) <br>        return (MMSYSERR_ERROR); <br> <br>    mmr = (* pfnAcmStreamUnprepareHeader)(has, pash, fdwUnprepare); <br> <br>    return (mmr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
