<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AAFILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2454"></a>AAFILE.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  aafile.c <br>// <br>//  Description: <br>//      Contains routines to deal with the FILE menu - loading and saving <br>//      files, and also contains some support routines for dealing with <br>//      RIFF files. <br>// <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br> <br>#include "appport.h" <br>#include "waveio.h" <br>#include "acmapp.h" <br> <br>#include "debug.h" <br> <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  DWORD DosGetFileAttributes <br>//   <br>//  Description: <br>//      INT 21 - DOS 2+ - GET FILE ATTRIBUTES <br>//          AX = 4300h <br>//          DS:DX -&gt; ASCIZ file name or directory name without trailing slash <br>// <br>//      Return: CF set on error <br>//              AX = error code (01h,02h,03h,05h) (see AH=59h) <br>//              CF clear if successful <br>//              CX = file attributes (see AX=4301h) <br>// <br>//      SeeAlso: AX=4301h, INT 2F/AX=110Fh <br>// <br>//      -------- <br>//      INT 21 - DOS 2+ - PUT FILE ATTRIBUTES (CHMOD) <br>//          AX = 4301h <br>//          CX = file attribute bits <br>//              bit 0 = read only <br>//                  1 = hidden file <br>//                  2 = system file <br>//                  3 = volume label <br>//                  4 = subdirectory <br>//                  5 = written since backup ("archive" bit) <br>//                  8 = shareable (Novell NetWare) <br>//          DS:DX -&gt; ASCIZ file name <br>// <br>//      Return: CF set on error <br>//              AX = error code (01h,02h,03h,05h) (see AH=59h) <br>//          CF clear if successful <br>// <br>//      Note:   will not change volume label or directory attributes <br>// <br>//      SeeAlso: AX=4300h, INT 2F/AX=110Eh <br>//   <br>//   <br>//  Arguments: <br>//      LPTSTR pszFilePath: <br>//   <br>//  Return (DWORD): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br>#ifndef WIN32 <br>#pragma optimize("", off) <br>DWORD FNGLOBAL DosGetFileAttributes <br>( <br>    LPTSTR          pszFilePath <br>) <br>{ <br>    WORD        fwDosAttributes; <br> <br>    _asm <br>    { <br>        push    ds <br>        mov     ax, 4300h <br>        lds     dx, pszFilePath <br>        int     21h <br>        jnc     Get_File_Attributes_Continue <br> <br>        xor     cx, cx <br> <br>Get_File_Attributes_Continue: <br> <br>        mov     fwDosAttributes, cx <br>        pop     ds <br>    } <br> <br> <br>    return ((DWORD)fwDosAttributes); <br>} // DosGetFileAttributes() <br>#pragma optimize("", on) <br>#endif <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  DWORD DosGetDateTime <br>//   <br>//  Description: <br>//   <br>//  Arguments: <br>//      HFILE hf: <br>//   <br>//  Return (DWORD): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br>#ifndef WIN32 <br>#pragma optimize("", off) <br>DWORD FNGLOBAL DosGetDateTime <br>( <br>    HFILE       hf <br>) <br>{ <br>    WORD        wDosDate; <br>    WORD        wDosTime; <br> <br>    _asm <br>    { <br>        mov     ax, 5700h <br>        mov     bx, hf <br>        int     21h <br>        jnc     Get_Date_Time_Continue <br> <br>        xor     cx, cx <br>        xor     dx, dx <br> <br>Get_Date_Time_Continue: <br> <br>        mov     wDosDate, dx <br>        mov     wDosTime, cx <br>    } <br> <br> <br>    return ((DWORD)MAKELONG(wDosDate, wDosTime)); <br>} // DosGetDateTime() <br>#pragma optimize("", on) <br>#endif <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppFileSaveModified <br>// <br>//  Description: <br>//      This function tests if the current file has been modified, and <br>//      if it has it gives the option of saving the file. <br>// <br>//      NOTE! This function does *NOT* clear the modified bit for the <br>//      file. The calling function must do this if necessary. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to file descriptor. <br>// <br>//  Return (BOOL): <br>//      Returns TRUE if the calling function should continue--the file was <br>//      either saved or the user does not wish to save it. Returns FALSE <br>//      if the calling function should cancel its operation--the user <br>//      wants to keep the data, but it has not been saved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppFileSaveModified <br>( <br>    HWND            hwnd, <br>    PACMAPPFILEDESC paafd <br>) <br>{ <br>    BOOL    f; <br>    int     n; <br> <br>    // <br>    //  check if the contents of the file have been modified--if they have <br>    //  then ask the user if they want to save the current contents... <br>    // <br>    f = (0 != (ACMAPPFILEDESC_STATEF_MODIFIED &amp; paafd-&gt;fdwState)); <br>    if (f) <br>    { <br>        // <br>        //  display an appropriate message box asking for the user's opinion <br>        // <br>        n = AppMsgBox(hwnd, MB_YESNOCANCEL | MB_ICONQUESTION| MB_SETFOREGROUND, <br>                      TEXT("The file '%s' has been modified. Do you want to save these changes?"), <br>                      (LPSTR)paafd-&gt;szFilePath); <br>        switch (n) <br>        { <br>            case IDYES: <br>                f = AppFileSave(hwnd, paafd, FALSE); <br>                if (f) <br>                    break; <br> <br>                // -- fall through -- <br> <br>            case IDCANCEL: <br>                // <br>                //  don't continue! <br>                // <br>                return (FALSE); <br> <br>            case IDNO: <br>                break; <br>        } <br>    } <br> <br>    // <br>    //  ok to continue... <br>    // <br>    return (TRUE); <br>} // AcmAppFileSaveModified() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppFileNew <br>// <br>//  Description: <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to file descriptor. <br>// <br>//  Return (BOOL): <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppFileNew <br>( <br>    HWND                hwnd, <br>    PACMAPPFILEDESC     paafd <br>) <br>{ <br>    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS]; <br>    MMRESULT            mmr; <br>    LPWAVEFORMATEX      pwfx; <br>    DWORD               cbwfx; <br>    BOOL                f; <br>    ACMFORMATCHOOSE     afc; <br>    HMMIO               hmmio; <br>    MMCKINFO            ckRIFF; <br>    MMCKINFO            ck; <br>    DWORD               cSamples; <br> <br> <br> <br>    if (!gfAcmAvailable) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppFileNew() called when ACM is not installed!")); <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    //  test for a modified file first... <br>    // <br>    f = AcmAppFileSaveModified(hwnd, paafd); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    // <br>    //  get a filename <br>    // <br>    szFileTitle[0] = '\0'; <br>    szFilePath[0]  = '\0'; <br> <br>    f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_SAVE); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    // <br>    // <br>    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &amp;cbwfx); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppFileNew() acmMetrics failed mmr=%u!"), mmr); <br>        return (FALSE); <br>    } <br> <br>    pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx); <br>    if (NULL == pwfx) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppFileNew() GlobalAllocPtr(%lu) failed!"), cbwfx); <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    f = FALSE; <br> <br> <br>    // <br>    //  initialize the ACMFORMATCHOOSE members <br>    // <br>    memset(&amp;afc, 0, sizeof(afc)); <br> <br>    afc.cbStruct        = sizeof(afc); <br>    afc.fdwStyle        = ACMFORMATCHOOSE_STYLEF_SHOWHELP; <br>    afc.hwndOwner       = hwnd; <br>    afc.pwfx            = pwfx; <br>    afc.cbwfx           = cbwfx; <br>    afc.pszTitle        = TEXT("ACM App: New Format Choice"); <br> <br>    afc.szFormatTag[0]  = '\0'; <br>    afc.szFormat[0]     = '\0'; <br>    afc.pszName         = NULL; <br>    afc.cchName         = 0; <br> <br>    afc.fdwEnum         = 0; <br>    afc.pwfxEnum        = NULL; <br> <br>    afc.hInstance       = NULL; <br>    afc.pszTemplateName = NULL; <br>    afc.lCustData       = 0L; <br>    afc.pfnHook         = NULL; <br> <br> <br>    // <br>    // <br>    // <br>    mmr = acmFormatChoose(&amp;afc); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        if (ACMERR_CANCELED != mmr) <br>        { <br>            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                    TEXT("acmFormatChoose() failed with error = %u!"), mmr); <br>        } <br>         <br>        GlobalFreePtr(pwfx); <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    hmmio = mmioOpen(szFilePath, <br>                     NULL, <br>                     MMIO_CREATE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF); <br>    if (NULL == hmmio) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppFileNew() cannot create file '%s'!"), (LPSTR)szFilePath); <br>       <br>        GlobalFreePtr(pwfx); <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    //  create the RIFF chunk of form type 'WAVE' <br>    // <br>    ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>    ckRIFF.cksize  = 0L; <br>    mmioCreateChunk(hmmio, &amp;ckRIFF, MMIO_CREATERIFF); <br> <br> <br>    // <br>    //  now create the destination fmt, fact, and data chunks _in that order_ <br>    // <br>    //  hmmio is now descended into the 'RIFF' chunk--create the format chunk <br>    //  and write the format header into it <br>    // <br>    cbwfx = SIZEOF_WAVEFORMATEX(pwfx); <br> <br>    ck.ckid   = mmioFOURCC('f', 'm', 't', ' '); <br>    ck.cksize = 0L; <br>    mmioCreateChunk(hmmio, &amp;ck, 0); <br> <br>    mmioWrite(hmmio, (HPSTR)pwfx, cbwfx); <br>    mmioAscend(hmmio, &amp;ck, 0); <br> <br>    // <br>    //  create the 'fact' chunk (not necessary for PCM--but is nice to have) <br>    //  since we are not writing any data to this file (yet), we set the <br>    //  samples contained in the file to 0.. <br>    // <br>    ck.ckid   = mmioFOURCC('f', 'a', 'c', 't'); <br>    ck.cksize = 0L; <br>    mmioCreateChunk(hmmio, &amp;ck, 0); <br> <br>    cSamples  = 0L; <br>    mmioWrite(hmmio, (HPSTR)&amp;cSamples, sizeof(DWORD)); <br>    mmioAscend(hmmio, &amp;ck, 0); <br> <br> <br>    // <br>    //  create the data chunk with no data.. <br>    // <br>    ck.ckid   = mmioFOURCC('d', 'a', 't', 'a'); <br>    ck.cksize = 0L; <br>    mmioCreateChunk(hmmio, &amp;ck, 0); <br>    mmioAscend(hmmio, &amp;ck, 0); <br> <br>    mmioAscend(hmmio, &amp;ckRIFF, 0); <br> <br>    mmioClose(hmmio, 0); <br> <br> <br>    // <br>    // <br>    // <br>    GlobalFreePtr(pwfx); <br> <br>    lstrcpy(paafd-&gt;szFilePath, szFilePath); <br>    lstrcpy(paafd-&gt;szFileTitle, szFileTitle); <br> <br>    return (AcmAppFileOpen(hwnd, paafd)); <br> <br> <br>    // <br>    //  success <br>    // <br>    return (TRUE); <br>} // AcmAppFileNew() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppFileOpen <br>// <br>//  Description: <br>//      This function opens the specified file and get the important info <br>//      from it. <br>// <br>//      NOTE! This function does NOT check for a modified file! It is <br>//      assumed that the calling function took care of everything before <br>//      calling this function. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to file descriptor. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if an error occurred. If an error does occur, then the contents <br>//      of the file descriptor will remain unchanged. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppFileOpen <br>( <br>    HWND            hwnd, <br>    PACMAPPFILEDESC paafd <br>) <br>{ <br>    WAVEIOCB    wio; <br>    WIOERR      werr; <br> <br>#ifdef WIN32 <br>    HANDLE      hf; <br>#else <br>    #define SEEK_SET        0       // flags for _lseek <br>    #define SEEK_CUR        1 <br>    #define SEEK_END        2 <br> <br>    HFILE       hf; <br>    OFSTRUCT    of; <br>    DWORD       dw; <br>#endif <br>    DWORD       cbFileSize; <br>    BOOL        fReturn; <br> <br> <br> <br>    // <br>    //  blow previous stuff... <br>    // <br>    if (NULL != paafd-&gt;pwfx) <br>    { <br>        GlobalFreePtr(paafd-&gt;pwfx); <br>        paafd-&gt;pwfx  = NULL; <br>        paafd-&gt;cbwfx = 0; <br>    } <br> <br>    paafd-&gt;fdwState          = 0L; <br>    paafd-&gt;cbFileSize        = 0L; <br>    paafd-&gt;uDosChangeDate    = 0; <br>    paafd-&gt;uDosChangeTime    = 0; <br>    paafd-&gt;fdwFileAttributes = 0L; <br>    paafd-&gt;dwDataBytes       = 0L; <br>    paafd-&gt;dwDataSamples     = 0L; <br> <br> <br>    // <br>    //  open the file for reading.. <br>    // <br>#ifdef WIN32 <br>    hf = CreateFile(paafd-&gt;szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, <br>                    OPEN_EXISTING, 0, 0); <br>    if (INVALID_HANDLE_VALUE == hf) <br>        return (FALSE); <br>#else <br>    of.cBytes = sizeof(of); <br>    hf = OpenFile(paafd-&gt;szFilePath, &amp;of, OF_READ); <br>    if (HFILE_ERROR == hf) <br>        return (FALSE); <br>#endif <br> <br>    // <br>    //  assume the worst <br>    // <br>    fReturn = FALSE; <br> <br>    // <br>    //  determine the length in _bytes_ of the file <br>    // <br>#ifdef WIN32 <br>    cbFileSize = GetFileSize((HANDLE)hf, NULL); <br>#else <br>    cbFileSize = _llseek(hf, 0L, SEEK_END); <br>    _llseek(hf, 0L, SEEK_SET); <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    paafd-&gt;cbFileSize        = cbFileSize; <br> <br>#ifdef WIN32 <br>{ <br>    BY_HANDLE_FILE_INFORMATION  bhfi; <br>    WORD                        wDosChangeDate; <br>    WORD                        wDosChangeTime; <br> <br>    GetFileInformationByHandle(hf, &amp;bhfi); <br> <br>    paafd-&gt;fdwFileAttributes = bhfi.dwFileAttributes; <br> <br>    FileTimeToDosDateTime(&amp;bhfi.ftLastWriteTime, <br>                          &amp;wDosChangeDate, &amp;wDosChangeTime); <br> <br>    paafd-&gt;uDosChangeDate = (UINT)wDosChangeDate; <br>    paafd-&gt;uDosChangeTime = (UINT)wDosChangeTime; <br>} <br>#else <br>    paafd-&gt;fdwFileAttributes = DosGetFileAttributes(paafd-&gt;szFilePath); <br> <br>    dw = DosGetDateTime(hf); <br>    paafd-&gt;uDosChangeDate = LOWORD(dw); <br>    paafd-&gt;uDosChangeTime = HIWORD(dw); <br>#endif <br> <br> <br>    // <br>    //  now return the fully qualified path and title for the file <br>    // <br>#ifndef WIN32 <br>    lstrcpy(paafd-&gt;szFilePath, of.szPathName); <br>#endif <br>    AppGetFileTitle(paafd-&gt;szFilePath, paafd-&gt;szFileTitle); <br> <br>#ifdef WIN32 <br>    CloseHandle(hf); <br>#else <br>    _lclose(hf); <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    werr = wioFileOpen(&amp;wio, paafd-&gt;szFilePath, 0L); <br>    if (WIOERR_NOERROR == werr) <br>    { <br>        UINT        cbwfx; <br> <br>        cbwfx = SIZEOF_WAVEFORMATEX(wio.pwfx); <br> <br>        paafd-&gt;pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, cbwfx); <br>        if (NULL != paafd-&gt;pwfx) <br>        { <br>            _fmemcpy(paafd-&gt;pwfx, wio.pwfx, cbwfx); <br> <br>            paafd-&gt;cbwfx         = cbwfx; <br> <br>            paafd-&gt;dwDataBytes   = wio.dwDataBytes; <br>            paafd-&gt;dwDataSamples = wio.dwDataSamples; <br> <br>            fReturn = TRUE; <br>        } <br> <br>        wioFileClose(&amp;wio, 0L); <br>    } <br>    else <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL, <br>                  TEXT("The file '%s' cannot be loaded as a wave file (wio error=%u)."), <br>                  (LPTSTR)paafd-&gt;szFilePath, werr); <br>    } <br> <br> <br>    // <br>    //  !!! before returning, we really should try to display a error <br>    //      message... memory error, etc.. <br>    // <br>    return (fReturn); <br>} // AcmAppFileOpen() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppOpenInstance <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      LPCTSTR pszFilePath: <br>//   <br>//      BOOL fForceOpen: <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppOpenInstance <br>( <br>    HWND                    hwnd, <br>    LPCTSTR                 pszFilePath, <br>    BOOL                    fForceOpen <br>) <br>{ <br>    TCHAR               szCmdLine[APP_MAX_FILE_PATH_CHARS * 2]; <br>    BOOL                f; <br>    UINT                uDosErr; <br> <br> <br>    // <br>    // <br>    // <br>    if (!fForceOpen) <br>    { <br>        if (0 == (APP_OPTIONSF_AUTOOPEN * gfuAppOptions)) <br>        { <br>            return (TRUE); <br>        } <br>    } <br> <br>    // <br>    // <br>    // <br>    if (0 == GetModuleFileName(ghinst, szCmdLine, SIZEOF(szCmdLine))) <br>    { <br>        // <br>        //  this would be fatal <br>        // <br>        AppMsgBox(hwnd, MB_ICONEXCLAMATION | MB_OK, <br>                  TEXT("GetModuleFileName() is unable to return self reference!")); <br> <br>        return (FALSE); <br>    } <br> <br>     <br>    lstrcat(szCmdLine, TEXT(" ")); <br>    lstrcat(szCmdLine, pszFilePath); <br> <br>#ifdef WIN32 <br>{ <br>    STARTUPINFO         si; <br>    PROCESS_INFORMATION pi; <br> <br>    // <br>    //  perform the equivalent of WinExec in NT, but we use a Unicode string <br>    // <br>    memset(&amp;si, 0, sizeof(si)); <br>    si.cb           = sizeof(si); <br>    si.dwFlags      = STARTF_USESHOWWINDOW; <br>    si.wShowWindow  = SW_SHOW; <br> <br>    f = CreateProcess(NULL, <br>                      szCmdLine, <br>                      NULL, <br>                      NULL, <br>                      FALSE,  <br>                      0, <br>                      NULL, <br>                      NULL, <br>                      &amp;si, <br>                      &amp;pi); <br> <br>    if (f) <br>    { <br>        // <br>        //  as the docs say.. wait 10 second for process to go idle before <br>        //  continuing. <br>        // <br>        WaitForInputIdle(pi.hProcess, 10000); <br> <br>        CloseHandle(pi.hProcess); <br>        CloseHandle(pi.hThread); <br>    } <br>    else <br>    { <br>        uDosErr = GetLastError(); <br>    } <br>} <br>#else <br>{ <br>    uDosErr = WinExec(szCmdLine, SW_SHOW); <br>    f = (uDosErr &gt;= 32); <br>} <br>#endif <br> <br>    if (!f) <br>    { <br>        AppMsgBox(hwnd, MB_ICONEXCLAMATION | MB_OK, <br>                  TEXT("WinExec(%s) failed! DOS error=%u."), <br>                  (LPTSTR)szCmdLine, uDosErr); <br> <br>    } <br> <br>    return (f); <br>} // AcmAppOpenInstance() <br> <br> <br> <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppFileSave <br>// <br>//  Description: <br>//      This function saves the file to the specified file. <br>// <br>//      NOTE! This function does NOT bring up a save file chooser dialog <br>//      if the file path is invalid. The calling function is responsible <br>//      for making sure the file path is valid before calling this function. <br>// <br>//      This function also does NOT modify the 'modified' bit of the file <br>//      descriptor. This is up to the calling function. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to file descriptor. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if an error occurred. If an error does occur, then the contents <br>//      of the file descriptor was not saved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppFileSave <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd, <br>    PTSTR                   pszFilePath, <br>    PTSTR                   pszFileTitle, <br>    UINT                    fuSave <br>) <br>{ <br> <br>    return (FALSE); <br>} // AcmAppFileSave() <br> <br> <br> <br> <br> <br> <br>//==========================================================================; <br>//==========================================================================; <br>//==========================================================================; <br>//==========================================================================; <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>// <br>// <br>// <br> <br>#define IDD_INFOLIST            100 <br>#define IDD_INFOINFO            101 <br>#define IDD_INFOTEXT            102 <br> <br>#ifdef RC_INVOKED <br> <br>#define DLG_INFOEDIT            31 <br> <br>#else <br>                         <br>#define DLG_INFOEDIT            MAKEINTRESOURCE(31) <br> <br>#endif <br> <br>//////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct tCHUNK <br>{ <br>    FOURCC  fcc; <br>    DWORD   cksize; <br>    BYTE    data[]; <br>} CHUNK, * PCHUNK, far * LPCHUNK; <br> <br> <br> <br>typedef struct tDISP <br>{ <br>    DWORD   cfid;   // Clipboard id of data <br>    HANDLE  h;      // handle to data <br>    struct tDISP *  next;    // next in list <br>} DISP; <br> <br>typedef struct tINFODATA <br>{ <br>    WORD    index;  // index into aINFO <br>    WORD    wFlags; // flags for chunk <br>    DWORD   dwINFOOffset;   // offset in file to INFO chunk <br>     <br>#define INFOCHUNK_MODIFIED  1 <br>#define INFOCHUNK_REVERT    2   // command to revert to original text <br> <br>    LPCTSTR   lpText; // text of modified chunk.  None if NULL. <br> <br>    struct tINFODATA  near *  pnext; // next read sub-chunk <br>} INFODATA, * PINFODATA, FAR * LPINFODATA; <br> <br>typedef struct tINFOCHUNK <br>{ <br>    LPTSTR   lpChunk;    // complete chunk in memory (GlobalPtr) <br>    DWORD   cksize;     // size of chunk data <br>    PINFODATA   pHead;  // first sub-chunk data <br>} INFOCHUNK, * PINFOCHUNK, FAR * LPINFOCHUNK; <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>//  error returns from RIFF functions <br>// <br>#define RIFFERR_BASE         (0) <br>#define RIFFERR_NOERROR      (0) <br>#define RIFFERR_ERROR        (RIFFERR_BASE+1) <br>#define RIFFERR_BADPARAM     (RIFFERR_BASE+2) <br>#define RIFFERR_FILEERROR    (RIFFERR_BASE+3) <br>#define RIFFERR_NOMEM        (RIFFERR_BASE+4) <br>#define RIFFERR_BADFILE      (RIFFERR_BASE+5) <br> <br>//////////////////////////////////////////////////////////////////////////// <br>// <br>//  public function prototypes <br>// <br> <br>#define RIFFAPI  FAR PASCAL <br> <br> <br>BOOL RIFFAPI riffCopyList(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck); <br>BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck); <br> <br>LRESULT RIFFAPI  riffInitINFO(INFOCHUNK FAR * FAR * lplpInfo); <br>LRESULT RIFFAPI  riffReadINFO(HMMIO hmmio, const LPMMCKINFO lpck, LPINFOCHUNK lpInfo); <br>LRESULT RIFFAPI  riffEditINFO(HWND hwnd, LPINFOCHUNK lpInfo, HINSTANCE hInst); <br>LRESULT RIFFAPI  riffFreeINFO(INFOCHUNK FAR * FAR * lpnpInfo); <br>LRESULT RIFFAPI riffWriteINFO(HMMIO hmmioDst, LPINFOCHUNK lpInfo); <br> <br> <br>LRESULT RIFFAPI  riffReadDISP(HMMIO hmmio, LPMMCKINFO lpck, DISP FAR * FAR * lpnpDisp); <br>LRESULT RIFFAPI  riffFreeDISP(DISP FAR * FAR * lpnpDisp); <br>LRESULT RIFFAPI riffWriteDISP(HMMIO hmmio, DISP FAR * FAR * lpnpDisp); <br> <br> <br>LRESULT NEAR PASCAL riffParseINFO(const LPINFOCHUNK lpInfo); <br> <br> <br> <br>/** BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) <br> * <br> *  DESCRIPTION: <br> *       <br> * <br> *  ARGUMENTS: <br> *      (LPWAVECONVCB lpwc, LPMMCKINFO lpck) <br> * <br> *  RETURN (BOOL NEAR PASCAL): <br> * <br> * <br> *  NOTES: <br> * <br> **  */ <br> <br>BOOL RIFFAPI riffCopyChunk(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) <br>{ <br>    MMCKINFO    ck; <br>    HPSTR       hpBuf; <br> <br>    // <br>    // <br>    // <br>    hpBuf = (HPSTR)GlobalAllocPtr(GHND, lpck-&gt;cksize); <br>    if (!hpBuf) <br>        return (FALSE); <br> <br>    ck.ckid   = lpck-&gt;ckid; <br>    ck.cksize = lpck-&gt;cksize; <br>    if (mmioCreateChunk(hmmioDst, &amp;ck, 0)) <br>        goto rscc_Error; <br>         <br>    if (mmioRead(hmmioSrc, hpBuf, lpck-&gt;cksize) != (LONG)lpck-&gt;cksize) <br>        goto rscc_Error; <br> <br>    if (mmioWrite(hmmioDst, hpBuf, lpck-&gt;cksize) != (LONG)lpck-&gt;cksize) <br>        goto rscc_Error; <br> <br>    if (mmioAscend(hmmioDst, &amp;ck, 0)) <br>        goto rscc_Error; <br> <br>    if (hpBuf) <br>        GlobalFreePtr(hpBuf); <br> <br>    return (TRUE); <br> <br>rscc_Error: <br> <br>    if (hpBuf) <br>        GlobalFreePtr(hpBuf); <br> <br>    return (FALSE); <br>} /* RIFFSupCopyChunk() */ <br> <br>/** BOOL RIFFAPI riffCopyList(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) <br> * <br> *  DESCRIPTION: <br> *       <br> * <br> *  ARGUMENTS: <br> *  (HMMIO hmmioSrc, HMMIO hmmioDst, LPMMCKINFO lpck) <br> * <br> *  RETURN (BOOL NEAR PASCAL): <br> * <br> * <br> *  NOTES: <br> * <br> ** */ <br> <br>BOOL RIFFAPI riffCopyList(HMMIO hmmioSrc, HMMIO hmmioDst, const LPMMCKINFO lpck) <br>{ <br>    MMCKINFO    ck; <br>    HPSTR       hpBuf; <br>    DWORD       dwCopySize; <br> <br>    hpBuf = (HPSTR)GlobalAllocPtr(GHND, lpck-&gt;cksize); <br>    if (!hpBuf) <br>        return (FALSE); <br> <br>    dwCopySize=lpck-&gt;cksize; <br>     <br>    // mmio leaves us after LIST ID <br>         <br>    ck.ckid   = lpck-&gt;ckid; <br>    ck.cksize = dwCopySize; <br>    ck.fccType= lpck-&gt;fccType; <br>         <br>    if (mmioCreateChunk(hmmioDst, &amp;ck, MMIO_CREATELIST)) <br>        goto rscl_Error; <br> <br>    // we already wrote 'LIST' ID, so reduce byte count <br>    dwCopySize-=sizeof(FOURCC); <br> <br>    if (mmioRead(hmmioSrc, hpBuf, dwCopySize) != (LONG)dwCopySize) <br>        goto rscl_Error; <br> <br>    if (mmioWrite(hmmioDst, hpBuf, dwCopySize) != (LONG)dwCopySize) <br>        goto rscl_Error; <br> <br>    if (mmioAscend(hmmioDst, &amp;ck, 0)) <br>        goto rscl_Error; <br> <br>    if (hpBuf) <br>        GlobalFreePtr(hpBuf); <br> <br>    return (TRUE); <br> <br>rscl_Error: <br> <br>    if (hpBuf) <br>        GlobalFreePtr(hpBuf); <br> <br>    return (FALSE); <br>} /* RIFFSupCopyList() */ <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br> <br>typedef struct tINFO <br>{ <br>    PTSTR       pFOURCC; <br>    PTSTR       pShort; <br>    PTSTR       pLong; <br>} INFO; <br> <br>static INFO aINFO[]= <br>{ <br>TEXT("IARL"), TEXT("Archival Location"),  TEXT("Indicates where the subject of the file is archived."), <br>TEXT("IART"), TEXT("Artist"),             TEXT("Lists the artist of the original subject of the file. For example, \"Michaelangelo.\""), <br>TEXT("ICMS"), TEXT("Commissioned"),       TEXT("Lists the name of the person or organization that commissioned the subject of the file. For example, \"Pope Julian II.\""), <br>TEXT("ICMT"), TEXT("Comments"),           TEXT("Provides general comments about the file or the subject of the file. If the comment is several sentences long, end each sentence with a period. Do not include newline characters."), <br>TEXT("ICOP"), TEXT("Copyright"),          TEXT("Records the copyright information for the file. For example, \"Copyright Encyclopedia International 1991.\" If there are multiple copyrights, separate them by a semicolon followed by a space."), <br>TEXT("ICRD"), TEXT("Creation date"),      TEXT("Specifies the date the subject of the file was created. List dates in year-month-day format, padding one-digit months and days with a zero on the left. For example, \"1553-05-03\" for May 3, 1553."), <br>TEXT("ICRP"), TEXT("Cropped"),            TEXT("Describes whether an image has been cropped and, if so, how it was cropped. For example, \"lower right corner.\""), <br>TEXT("IDIM"), TEXT("Dimensions"),         TEXT("Specifies the size of the original subject of the file. For example, \"8.5 in h, 11 in w.\""), <br>TEXT("IDPI"), TEXT("Dots Per Inch"),      TEXT("Stores dots per inch setting of the digitizer used to produce the file, such as \"300.\""), <br>TEXT("IENG"), TEXT("Engineer"),           TEXT("Stores the name of the engineer who worked on the file. If there are multiple engineers, separate the names by a semicolon and a blank. For example, \"Smith, John; Adams, Joe.\""), <br>TEXT("IGNR"), TEXT("Genre"),              TEXT("Describes the original work, such as, \"landscape,\" \"portrait,\" \"still life,\" etc."), <br>TEXT("IKEY"), TEXT("Keywords"),           TEXT("Provides a list of keywords that refer to the file or subject of the file. Separate multiple keywords with a semicolon and a blank. For example, \"Seattle; aerial view; scenery.\""), <br>TEXT("ILGT"), TEXT("Lightness"),          TEXT("Describes the changes in lightness settings on the digitizer required to produce the file. Note that the format of this information depends on hardware used."), <br>TEXT("IMED"), TEXT("Medium"),             TEXT("Describes the original subject of the file, such as, \"computer image,\" \"drawing,\" \"lithograph,\" and so forth."), <br>TEXT("INAM"), TEXT("Name"),               TEXT("Stores the title of the subject of the file, such as, \"Seattle From Above.\""), <br>TEXT("IPLT"), TEXT("Palette Setting"),    TEXT("Specifies the number of colors requested when digitizing an image, such as \"256.\""), <br>TEXT("IPRD"), TEXT("Product"),            TEXT("Specifies the name of the title the file was originally intended for, such as \"Encyclopedia of Pacific Northwest Geography.\""), <br>TEXT("ISBJ"), TEXT("Subject"),            TEXT("Describes the contents of the file, such as \"Aerial view of Seattle.\""), </code></pre>
<p>
</p>
<pre><code>TEXT("ISFT"), TEXT("Software"),           TEXT("Identifies the name of the software package used to create the file, such as \"Microsoft WaveEdit.\""), <br>TEXT("ISHP"), TEXT("Sharpness"),          TEXT("Identifies the changes in sharpness for the digitizer required to produce the file (the format depends on the hardware used)."), <br>TEXT("ISRC"), TEXT("Source"),             TEXT("Identifies the name of the person or organization who supplied the original subject of the file. For example, \"Trey Research.\""), <br>TEXT("ISRF"), TEXT("Source Form"),        TEXT("Identifies the original form of the material that was digitized, such as \"slide,\" \"paper,\" \"map,\" and so forth. This is not necessarily the same as IMED."), <br>TEXT("ITCH"), TEXT("Technician"),         TEXT("Identifies the technician who digitized the subject file. For example, \"Smith, John.\""), <br> <br>NULL, NULL, NULL <br> <br>}; <br> <br> <br>void NEAR PASCAL riffInsertINFO(LPINFOCHUNK lpInfo, const PINFODATA pInfo) <br>{ <br>    PINFODATA pI; <br>     <br>    if(!lpInfo) <br>        return; <br>     <br>    if(!lpInfo-&gt;pHead) <br>    { <br>        lpInfo-&gt;pHead=pInfo; <br>        return; <br>    } <br>     <br>    pI=lpInfo-&gt;pHead; <br>    while(pI-&gt;pnext) <br>    { <br>        pI=pI-&gt;pnext; <br>    } <br>    // insert at end <br>    pI-&gt;pnext=pInfo; <br>     <br>    return; <br>} <br> <br>PINFODATA NEAR PASCAL riffCreateINFO(WORD id, WORD wFlags, DWORD dwInfoOffset, LPCTSTR lpText) <br>{ <br>    PINFODATA pI; <br>    pI=(PINFODATA)LocalAlloc(LPTR,sizeof(INFODATA)); <br>    if(!pI) <br>        return NULL; <br>     <br>    pI-&gt;index=id; <br>    pI-&gt;wFlags=wFlags; <br>    pI-&gt;dwINFOOffset=dwInfoOffset; <br>    pI-&gt;lpText=lpText; <br>     <br>    return pI; <br>} <br> <br>LRESULT RIFFAPI riffInitINFO(INFOCHUNK FAR * FAR * lplpInfo) <br>{ <br>    LPINFOCHUNK lpInfo; <br>    WORD        id; <br>    PINFODATA   pI; <br>     <br>    lpInfo=(LPINFOCHUNK)GlobalAllocPtr(GHND, sizeof(INFOCHUNK)); <br>    if(!lpInfo) <br>        return RIFFERR_NOMEM; <br>    *lplpInfo=lpInfo; <br> <br>    for (id=0;aINFO[id].pFOURCC;id++) <br>    { <br>        pI=riffCreateINFO(id, 0, 0L, NULL);   // create empty INFO <br>        riffInsertINFO(lpInfo,pI); <br>    } <br>    return RIFFERR_NOERROR; <br>} <br> <br>LRESULT RIFFAPI riffReadINFO(HMMIO hmmio, const LPMMCKINFO lpck, LPINFOCHUNK lpInfo) <br>{ <br>    DWORD       dwInfoSize; <br> <br>    dwInfoSize=lpck-&gt;cksize - sizeof(FOURCC);   // take out 'INFO' <br> <br>    lpInfo-&gt;cksize=dwInfoSize; <br>    lpInfo-&gt;lpChunk=(LPTSTR)GlobalAllocPtr(GHND, dwInfoSize); <br>    if(!lpInfo-&gt;lpChunk) <br>        return RIFFERR_NOMEM; <br>     <br>    if (mmioRead(hmmio, (HPSTR)lpInfo-&gt;lpChunk, dwInfoSize) != (LONG)dwInfoSize) <br>        return RIFFERR_FILEERROR; <br>    else <br>        return riffParseINFO(lpInfo); <br>} <br> <br>PINFODATA NEAR PASCAL riffFindPIINFO(const LPINFOCHUNK lpInfo, FOURCC fcc) <br>{ <br>    PINFODATA pI; <br> <br>    pI=lpInfo-&gt;pHead; <br>    while(pI) <br>    { <br>        if(mmioStringToFOURCC(aINFO[pI-&gt;index].pFOURCC,0)==fcc) <br>            return(pI); <br>        pI=pI-&gt;pnext; <br>    } <br>    return NULL; <br>} <br> <br>void NEAR PASCAL riffModifyINFO(const LPINFOCHUNK lpInfo, PINFODATA pI, WORD wFlags, DWORD dw, LPCTSTR lpText) <br>{ <br>    if(!pI) <br>        return; <br>     <br>    pI-&gt;wFlags=wFlags; <br>    if(!(wFlags&amp;INFOCHUNK_MODIFIED)) <br>        pI-&gt;dwINFOOffset=dw; <br>     <br>    if(pI-&gt;lpText) <br>    { <br>        if(lpText) <br>        { <br>            if(!lstrcmp(lpText,pI-&gt;lpText)) <br>            { <br>                // they are the same, don't bother changing... <br>                GlobalFreePtr(lpText); <br>            } <br>            else <br>            { <br>                GlobalFreePtr(pI-&gt;lpText); <br>                pI-&gt;lpText=lpText; <br>            } <br>        } <br>        else if(wFlags&amp;INFOCHUNK_REVERT) <br>        { <br>            GlobalFreePtr(pI-&gt;lpText); <br>            pI-&gt;lpText=NULL; <br>        } <br>    } <br>    else if(lpText) <br>    { <br>        // if no read data, don't bother to check.... <br>        if(!lpInfo-&gt;lpChunk &amp;&amp; *lpText) <br>        { <br>            pI-&gt;lpText=lpText; <br>        } <br>        else if(lstrcmp(lpText, (LPTSTR)lpInfo-&gt;lpChunk+pI-&gt;dwINFOOffset)) <br>        {       // new text... <br>            if(*lpText) <br>                // NOT the same, set... <br>                pI-&gt;lpText=lpText; <br>            else <br>                // new is blank, do nothing... <br>                GlobalFreePtr(lpText); <br>        } <br>        else <br>            // the same, don't bother... <br>            GlobalFreePtr(lpText); <br>    } <br>} <br> <br>WORD NEAR PASCAL riffFindaINFO(FOURCC fcc) <br>{ <br>    WORD    id; <br> <br>    for (id=0;aINFO[id].pFOURCC;id++) <br>    { <br>        if(mmioStringToFOURCC(aINFO[id].pFOURCC,0)==fcc) <br>            return id; <br>    } <br>    return 0xFFFF; <br>} <br> <br> <br> <br>LRESULT NEAR PASCAL riffParseINFO(const LPINFOCHUNK lpInfo) <br>{ <br>    LPTSTR   lpBuf; <br>    DWORD   dwCurInfoOffset; <br>    PINFODATA pI; <br>    LPCHUNK lpck; <br> <br>    lpBuf=lpInfo-&gt;lpChunk; <br>    for(dwCurInfoOffset=0;dwCurInfoOffset&lt;lpInfo-&gt;cksize;) <br>    { <br>        lpck=(LPCHUNK)((LPSTR)(lpBuf+dwCurInfoOffset)); <br>        dwCurInfoOffset+=sizeof(CHUNK);   // dwCurInfoOffset is offset of data <br>        pI=riffFindPIINFO(lpInfo,lpck-&gt;fcc); <br>        if(!pI) <br>        { <br>            int     n; <br> <br>            // file contains unknown INFO chunk <br>            n = AppMsgBox(NULL, MB_YESNO | MB_ICONEXCLAMATION | MB_TASKMODAL, <br>                          TEXT("This wave file contains an unknown item in the INFO chunk: '%4.4s'.  Open anyway?"), <br>                          (LPCSTR)(lpck)); <br>            if (n == IDNO) <br>            { <br>                return RIFFERR_BADFILE; <br>            } <br>             <br>             <br>        } <br>        else <br>        { <br>            // modify entry to show text (data) from file... <br>            riffModifyINFO(lpInfo, pI, 0, dwCurInfoOffset, NULL); <br>        } <br>        dwCurInfoOffset+=lpck-&gt;cksize+(lpck-&gt;cksize&amp;1);  // skip past data <br>    } <br> <br>    return RIFFERR_NOERROR; <br>} <br> <br>LRESULT RIFFAPI riffFreeINFO(INFOCHUNK FAR * FAR * lplpInfo) <br>{ <br>    PINFODATA   pI; <br>    PINFODATA   pIT; <br>    LPINFOCHUNK lpInfo; <br>    LRESULT     lr; <br> <br>    lr    = RIFFERR_BADPARAM; <br> <br>    if(!lplpInfo) <br>        goto riff_FI_Error; <br>     <br>    lpInfo=*lplpInfo; <br>    if(!lpInfo) <br>        goto riff_FI_Error; <br>     <br>    if(lpInfo-&gt;lpChunk) <br>        GlobalFreePtr(lpInfo-&gt;lpChunk); <br> <br> <br>    pI=lpInfo-&gt;pHead; <br>     <br>    while(pI) <br>    { <br>        pIT=pI; <br>        pI=pI-&gt;pnext; <br>        LocalFree((HANDLE)pIT); <br>    } <br> <br>     <br>    // <br> <br>    GlobalFreePtr(lpInfo); <br>    *lplpInfo=NULL; <br>    return RIFFERR_NOERROR; <br>     <br>riff_FI_Error:     <br>    return lr; <br>} <br> <br> <br>TCHAR   szBuf[255]; <br> <br>static BOOL NEAR PASCAL riffSetupEditBoxINFO(HWND hdlg, const LPINFOCHUNK lpInfo, WORD wFlags) <br>{ <br>    static PTSTR szFormat = TEXT("%-4s%c %-25s"); <br>    PINFODATA   pI; <br>    WORD        iSel; <br>    HWND        hLB; <br>     <br>    hLB=GetDlgItem(hdlg, IDD_INFOLIST); <br>    if(wFlags&amp;INFOCHUNK_MODIFIED) <br>    { <br>        iSel = ComboBox_GetCurSel(hLB); <br>         <br>    } <br>    else <br>        iSel = 0; <br> <br>    ComboBox_ResetContent(hLB); <br>     <br>    pI=lpInfo-&gt;pHead; <br>     <br>    while(pI) <br>    { <br>        wsprintf(szBuf,szFormat, <br>            (LPCSTR)aINFO[pI-&gt;index].pFOURCC, <br>            (pI-&gt;dwINFOOffset || ( (pI-&gt;lpText) &amp;&amp; (pI-&gt;lpText[0]) ) ) ? <br>                        '*' : ' ', <br>            (LPCSTR)aINFO[pI-&gt;index].pShort <br>            ); <br> <br>        ComboBox_AddString(hLB, szBuf); <br>        pI=pI-&gt;pnext; <br>    } <br>    ComboBox_SetCurSel(hLB, iSel); <br> <br>    if(!(wFlags&amp;INFOCHUNK_MODIFIED)) <br>    { <br>        // FIRST time only <br>        pI=lpInfo-&gt;pHead; <br>        if(pI) <br>            if(pI-&gt;lpText) <br>                // Modified text <br>                SetDlgItemText(hdlg, IDD_INFOTEXT, (LPCTSTR)pI-&gt;lpText); <br>            else if(pI-&gt;dwINFOOffset) <br>                // default text <br>                SetDlgItemText(hdlg, IDD_INFOTEXT, (LPCTSTR)(lpInfo-&gt;lpChunk+pI-&gt;dwINFOOffset)); <br>            else <br>                // no text <br>                SetDlgItemText(hdlg, IDD_INFOTEXT, (LPCTSTR)TEXT("")); <br>        SetDlgItemText(hdlg, IDD_INFOINFO, (LPCTSTR)aINFO[0].pLong); <br>    } <br>    return TRUE; <br>} <br> <br> <br>static BOOL Cls_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam) <br>{ <br>    LPINFOCHUNK lpInfo; <br>    HFONT       hFont; <br>    HWND        hLB; <br> <br>    lpInfo = (LPINFOCHUNK)lParam; <br>    if(!lpInfo) <br>        return FALSE; <br> <br>    SetWindowLong(hwnd, DWL_USER, (LONG)lpInfo); <br>             <br>    hFont = GetStockFont(SYSTEM_FIXED_FONT); <br> <br>    hLB=GetDlgItem(hwnd, IDD_INFOLIST); <br>    SetWindowFont(hLB, hFont, FALSE); <br> <br>    riffSetupEditBoxINFO(hwnd, lpInfo, 0); <br> <br>    return TRUE; <br>} <br> <br>static void Cls_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>    LPINFOCHUNK lpInfo; <br>    PINFODATA   pI; <br>    WORD        iSel; <br>    int         i; <br>    LPTSTR       lpstr; <br> <br>    lpInfo=(LPINFOCHUNK)GetWindowLong(hwnd, DWL_USER); <br>             <br>    switch(id) <br>    { <br>        case IDOK: <br>        case IDCANCEL: <br>            EndDialog(hwnd, (id == IDOK)); <br>            break; <br>        case IDD_INFOLIST: <br>            switch(codeNotify) <br>            { <br>                case CBN_SELCHANGE: <br> <br>                    iSel = ComboBox_GetCurSel(GetDlgItem(hwnd, id)); <br>                    SetDlgItemText(hwnd, IDD_INFOINFO, (LPCTSTR)aINFO[iSel].pLong); <br> <br>                    pI=lpInfo-&gt;pHead; <br>                    while(pI) <br>                    { <br>                        if(pI-&gt;index==iSel) <br>                            break; <br>                        pI=pI-&gt;pnext; <br>                    } <br>                    if(pI) <br>                    { <br>                        if(pI-&gt;lpText) <br>                            // Modified text <br>                            SetDlgItemText(hwnd, IDD_INFOTEXT, (LPCTSTR)pI-&gt;lpText); <br>                        else if(pI-&gt;dwINFOOffset) <br>                            // default text <br>                            SetDlgItemText(hwnd, IDD_INFOTEXT, (LPCTSTR)(lpInfo-&gt;lpChunk+pI-&gt;dwINFOOffset)); <br>                        else <br>                            // no text <br>                            SetDlgItemText(hwnd, IDD_INFOTEXT, (LPCTSTR)TEXT("")); <br>                    } <br>                        else <br>                            SetDlgItemText(hwnd, IDD_INFOINFO, (LPCTSTR)TEXT("Can't FIND iSel")); <br>                    break; <br>            } <br> <br>        case IDD_INFOTEXT: <br>            switch(codeNotify) <br>            { <br>                case EN_KILLFOCUS: <br>                    // get text out and give to current id <br>                    iSel=(WORD)SendDlgItemMessage(hwnd,IDD_INFOLIST,CB_GETCURSEL,0,0L); <br>                    pI=lpInfo-&gt;pHead; <br>                    while(pI) <br>                    { <br>                        if(pI-&gt;index==iSel) <br>                            break; <br>                        pI=pI-&gt;pnext; <br>                    } <br>                    if(pI) <br>                    { <br>                        i=GetDlgItemText(hwnd, IDD_INFOTEXT, szBuf,sizeof(szBuf)); <br>                        lpstr=(LPTSTR)GlobalAllocPtr(GHND,(DWORD)i+1); <br>                        if(!lpstr) <br>                            break; <br> <br>                        lstrcpy(lpstr,szBuf); <br> <br>                        riffModifyINFO(lpInfo, pI, INFOCHUNK_MODIFIED, 0, lpstr); <br> <br>                        riffSetupEditBoxINFO(hwnd, lpInfo, INFOCHUNK_MODIFIED); <br>                    } <br>                    else <br>                        SetDlgItemText(hwnd, IDD_INFOINFO, (LPCTSTR)TEXT("Can't FIND iSel")); <br>                    break; <br> <br>            } <br>            break; <br>        case IDD_INFOINFO: <br>            break; <br>    } <br> <br>}                            <br> <br>BOOL FNGLOBAL DlgProcINFOEdit(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            return (BOOL)(UINT)(DWORD)(LRESULT)HANDLE_WM_INITDIALOG(hdlg, wParam, lParam, Cls_OnInitDialog); <br> <br>        case WM_COMMAND: <br>            HANDLE_WM_COMMAND(hdlg, wParam, lParam, Cls_OnCommand); <br>            break; <br>    } <br> <br>    return FALSE; <br>} <br> <br> <br>LRESULT RIFFAPI riffEditINFO(HWND hwnd, LPINFOCHUNK lpInfo, HINSTANCE hInst) <br>{ <br>    LRESULT     lr; <br>    DLGPROC     lpfn; <br>#ifdef DEBUG     <br>    int         i; <br>#endif <br>     <br>    lr    = RIFFERR_BADPARAM; <br> <br>    if(!lpInfo) <br>        goto riff_EI_Error; <br> <br>    if (lpfn = (DLGPROC)MakeProcInstance((FARPROC)DlgProcINFOEdit, hInst)) <br>    { <br>#ifdef DEBUG <br>        i= <br>#endif <br>        DialogBoxParam(hInst, DLG_INFOEDIT, hwnd, lpfn, (LPARAM)(LPVOID)lpInfo); <br>        FreeProcInstance((FARPROC)lpfn); <br>        lr=RIFFERR_NOERROR; <br>#ifdef DEBUG <br>        if(i==-1) <br>        { <br>            MessageBox(hwnd, TEXT("INFO Edit Error: DLG_INFOEDIT not found.  Check .RC file."), TEXT("RIFF SUP module"), MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>            lr=RIFFERR_ERROR; <br>        } <br>#endif <br>         <br>    } <br>#ifdef DEBUG <br>    else <br>    { <br>        MessageBox(hwnd, TEXT("INFO Edit Error: Can't MakeProcInstace()"), TEXT("RIFF SUP module"), MB_OK|MB_ICONEXCLAMATION|MB_TASKMODAL); <br>        lr=RIFFERR_ERROR; <br>    } <br>#endif <br>     <br>riff_EI_Error:     <br>    return lr; <br>} <br> <br>LRESULT RIFFAPI riffWriteINFO(HMMIO hmmioDst, LPINFOCHUNK lpInfo) <br>{ <br>    LRESULT     lr; <br>    MMCKINFO    ck; <br>    MMCKINFO    ckINFO; <br>    PINFODATA   pI; <br>    LPTSTR      lpstr; <br>    BOOL        fList=FALSE; <br> <br>    lr    = RIFFERR_BADPARAM; <br> <br>    if(!hmmioDst || !lpInfo) <br>        goto riff_SI_Error; <br> <br>    lr=RIFFERR_FILEERROR; <br>     <br>    ckINFO.ckid   = mmioFOURCC('L', 'I', 'S', 'T'); <br>    ckINFO.cksize = 0;  // mmio fill fill it in later <br>    ckINFO.fccType= mmioFOURCC('I', 'N', 'F', 'O'); <br>         <br>    pI=lpInfo-&gt;pHead; <br>     <br>    while(pI) <br>    { <br>        if(pI-&gt;lpText) <br>            // Modified text <br>            lpstr=(LPTSTR)pI-&gt;lpText; <br>        else if(pI-&gt;dwINFOOffset) <br>            // default text <br>            lpstr=(lpInfo-&gt;lpChunk+pI-&gt;dwINFOOffset); <br>        else <br>            // no text <br>            lpstr=NULL; <br>        if(lpstr) <br>        { <br>            if(!fList) <br>            { <br>                // only create if needed... <br>                if (mmioCreateChunk(hmmioDst, &amp;ckINFO, MMIO_CREATELIST)) <br>                    goto riff_SI_Error; <br>                fList=TRUE; <br>            } <br>     <br>            ck.ckid=mmioStringToFOURCC(aINFO[pI-&gt;index].pFOURCC,0); <br>            ck.cksize=lstrlen(lpstr)+1; <br>            ck.fccType=0; <br>            if (mmioCreateChunk(hmmioDst, &amp;ck, 0)) <br>                goto riff_SI_Error; <br> <br>            if (mmioWrite(hmmioDst, (LPBYTE)lpstr, ck.cksize) != (LONG)(ck.cksize)) <br>                goto riff_SI_Error; <br> <br>            if (mmioAscend(hmmioDst, &amp;ck, 0)) <br>                goto riff_SI_Error; <br> <br>        } <br>        pI=pI-&gt;pnext; <br>    } <br>     <br>    if(fList) <br>    { <br>        if (mmioAscend(hmmioDst, &amp;ckINFO, 0)) <br>            goto riff_SI_Error; <br>    } <br> <br>    return RIFFERR_NOERROR; <br>     <br>riff_SI_Error:     <br>    return lr; <br>     <br>} <br> <br> <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>LRESULT RIFFAPI riffReadDISP(HMMIO hmmio, LPMMCKINFO lpck, DISP FAR * FAR * lpnpDisp) <br>{ <br>    LRESULT     lr; <br>    lr    = RIFFERR_ERROR; <br>    <br>    return lr; <br>} <br> <br>LRESULT RIFFAPI riffFreeDISP(DISP FAR * FAR * lpnpDisp) <br>{ <br>    LRESULT     lr; <br>    lr    = RIFFERR_ERROR; <br>     <br>    return lr; <br>} <br> <br>LRESULT RIFFAPI riffWriteDISP(HMMIO hmmio, DISP FAR * FAR * lpnpDisp) <br>{ <br>    LRESULT     lr; <br>    lr    = RIFFERR_ERROR; <br>     <br>    return lr; <br>} <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>//==========================================================================; <br>//==========================================================================; <br>//==========================================================================; <br>//==========================================================================; <br> <br> <br> <br> <br>BOOL        gfCancelConvert; <br> <br> <br>#define WM_CONVERT_BEGIN        (WM_USER + 100) <br>#define WM_CONVERT_END          (WM_USER + 101) <br> <br>#define BeginConvert(hwnd, paacd)   PostMessage(hwnd, WM_CONVERT_BEGIN, 0, (LPARAM)(UINT)paacd) <br>#define EndConvert(hwnd, f, paacd)  PostMessage(hwnd, WM_CONVERT_END, (WPARAM)f, (LPARAM)(UINT)paacd) <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  void AppDlgYield <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hdlg: <br>//   <br>//  Return (void): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>void FNLOCAL AppDlgYield <br>( <br>    HWND            hdlg <br>) <br>{ <br>    MSG     msg; <br> <br>    while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>    { <br>        if ((hdlg == NULL) || !IsDialogMessage(hdlg, &amp;msg)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br>} // AppDlgYield() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppConvertEnd <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hdlg: <br>//   <br>//      PAACONVERTDESC paacd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppConvertEnd <br>( <br>    HWND                hdlg, <br>    PAACONVERTDESC      paacd <br>) <br>{ <br>    MMRESULT            mmr; <br>    LPACMSTREAMHEADER   pash; <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    if (NULL != paacd-&gt;hmmioSrc) <br>    { <br>        mmioClose(paacd-&gt;hmmioSrc, 0); <br>        paacd-&gt;hmmioSrc = NULL; <br>    } <br> <br>    if (NULL != paacd-&gt;hmmioDst) <br>    { <br>        mmioAscend(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDst, 0); <br>        mmioAscend(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDstRIFF, 0); <br> <br>        mmioClose(paacd-&gt;hmmioDst, 0); <br>        paacd-&gt;hmmioDst = NULL; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    if (NULL != paacd-&gt;has) <br>    { <br>        pash = &amp;paacd-&gt;ash; <br> <br>        if (ACMSTREAMHEADER_STATUSF_PREPARED &amp; pash-&gt;fdwStatus) <br>        { <br>            pash-&gt;cbSrcLength = paacd-&gt;cbSrcReadSize; <br>            pash-&gt;cbDstLength = paacd-&gt;cbDstBufSize; <br> <br>            mmr = acmStreamUnprepareHeader(paacd-&gt;has, &amp;paacd-&gt;ash, 0L); <br>            if (MMSYSERR_NOERROR != mmr) <br>            { <br>                AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                          TEXT("acmStreamUnprepareHeader() failed with error = %u!"), mmr); <br>            } <br>        } <br> <br>        // <br>        // <br>        // <br>        acmStreamClose(paacd-&gt;has, 0L); <br>        paacd-&gt;has = NULL; <br> <br>        if (NULL != paacd-&gt;had) <br>        { <br>            acmDriverClose(paacd-&gt;had, 0L); <br>            paacd-&gt;had = NULL; <br>        } <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    if (NULL != paacd-&gt;pbSrc) <br>    { <br>        GlobalFreePtr(paacd-&gt;pbSrc); <br>        paacd-&gt;pbSrc = NULL; <br>    } <br>     <br>    if (NULL != paacd-&gt;pbDst) <br>    { <br>        GlobalFreePtr(paacd-&gt;pbDst); <br>        paacd-&gt;pbDst = NULL; <br>    } <br> <br> <br>    return (TRUE); <br>} // AcmAppConvertEnd() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppConvertBegin <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hdlg: <br>//   <br>//      PAACONVERTDESC paacd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppConvertBegin <br>( <br>    HWND                    hdlg, <br>    PAACONVERTDESC          paacd <br>) <br>{ <br>    TCHAR               ach[40]; <br>    MMRESULT            mmr; <br>    MMCKINFO            ckSrcRIFF; <br>    MMCKINFO            ck; <br>    DWORD               dw; <br>    LPACMSTREAMHEADER   pash; <br>    LPWAVEFILTER        pwfltr; <br> <br> <br>    // <br>    // <br>    // <br>    if (NULL != paacd-&gt;hadid) <br>    { <br>        mmr = acmDriverOpen(&amp;paacd-&gt;had, paacd-&gt;hadid, 0L); <br>        if (MMSYSERR_NOERROR != mmr) <br>        { <br>            AcmAppGetErrorString(mmr, ach); <br>            AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                        TEXT("The selected driver (hadid=%.04Xh) cannot be opened. %s (%u)"), <br>                        paacd-&gt;hadid, (LPSTR)ach, mmr); <br>            return (FALSE); <br>        } <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    pwfltr = paacd-&gt;fApplyFilter ? paacd-&gt;pwfltr : (LPWAVEFILTER)NULL; <br> <br>    mmr = acmStreamOpen(&amp;paacd-&gt;has, <br>                        paacd-&gt;had, <br>                        paacd-&gt;pwfxSrc, <br>                        paacd-&gt;pwfxDst, <br>                        pwfltr, <br>                        0L, <br>                        0L, <br>                        paacd-&gt;fdwOpen); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("acmStreamOpen() failed with error = %u!"), mmr); <br> <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    mmr = acmStreamSize(paacd-&gt;has, <br>                        paacd-&gt;cbSrcReadSize, <br>                        &amp;paacd-&gt;cbDstBufSize, <br>                        ACM_STREAMSIZEF_SOURCE); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("acmStreamSize() failed with error = %u!"), mmr); <br> <br>        return (FALSE); <br>    } <br> <br> <br> <br>    // <br>    //  first try to open the file, etc.. open the given file for reading <br>    //  using buffered I/O <br>    // <br>    paacd-&gt;hmmioSrc = mmioOpen(paacd-&gt;szFilePathSrc, <br>                               NULL, <br>                               MMIO_READ | MMIO_DENYWRITE | MMIO_ALLOCBUF); <br>    if (NULL == paacd-&gt;hmmioSrc) <br>        goto aacb_Error; <br> <br>    // <br>    // <br>    // <br>    paacd-&gt;hmmioDst = mmioOpen(paacd-&gt;szFilePathDst, <br>                               NULL, <br>                               MMIO_CREATE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_ALLOCBUF); <br>    if (NULL == paacd-&gt;hmmioDst) <br>        goto aacb_Error; <br> <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    pash = &amp;paacd-&gt;ash; <br>    pash-&gt;fdwStatus = 0L; <br> <br> <br>    // <br>    //  allocate the src and dst buffers for reading/converting data <br>    // <br>    paacd-&gt;pbSrc = (HPSTR)GlobalAllocPtr(GHND, paacd-&gt;cbSrcReadSize); <br>    if (NULL == paacd-&gt;pbSrc) <br>        goto aacb_Error; <br>     <br>    paacd-&gt;pbDst = (HPSTR)GlobalAllocPtr(GHND, paacd-&gt;cbDstBufSize); <br>    if (NULL == paacd-&gt;pbDst) <br>        goto aacb_Error; <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    pash-&gt;cbStruct          = sizeof(*pash); <br>    pash-&gt;fdwStatus         = 0L; <br>    pash-&gt;dwUser            = 0L; <br>    pash-&gt;pbSrc             = paacd-&gt;pbSrc; <br>    pash-&gt;cbSrcLength       = paacd-&gt;cbSrcReadSize; <br>    pash-&gt;cbSrcLengthUsed   = 0L; <br>    pash-&gt;dwSrcUser         = paacd-&gt;cbSrcReadSize; <br>    pash-&gt;pbDst             = paacd-&gt;pbDst; <br>    pash-&gt;cbDstLength       = paacd-&gt;cbDstBufSize; <br>    pash-&gt;cbDstLengthUsed   = 0L; <br>    pash-&gt;dwDstUser         = paacd-&gt;cbDstBufSize; <br> <br>    mmr = acmStreamPrepareHeader(paacd-&gt;has, pash, 0L); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                    TEXT("acmStreamPrepareHeader() failed with error = %u!"), mmr); <br> <br>        goto aacb_Error; <br>    }                           <br> <br> <br> <br>    // <br>    //  create the RIFF chunk of form type 'WAVE' <br>    // <br>    // <br>    paacd-&gt;ckDstRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>    paacd-&gt;ckDstRIFF.cksize  = 0L; <br>    if (mmioCreateChunk(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDstRIFF, MMIO_CREATERIFF)) <br>        goto aacb_Error; <br> <br>    // <br>    //  locate a 'WAVE' form type in a 'RIFF' thing... <br>    // <br>    ckSrcRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>    if (mmioDescend(paacd-&gt;hmmioSrc, (LPMMCKINFO)&amp;ckSrcRIFF, NULL, MMIO_FINDRIFF)) <br>        goto aacb_Error; <br> <br>    // <br>    //  we found a WAVE chunk--now go through and get all subchunks that <br>    //  we know how to deal with... <br>    // <br>    while (mmioDescend(paacd-&gt;hmmioSrc, &amp;ck, &amp;ckSrcRIFF, 0) == 0) <br>    { <br>        // <br>        //  quickly check for corrupt RIFF file--don't ascend past end! <br>        // <br>        if ((ck.dwDataOffset + ck.cksize) &gt; (ckSrcRIFF.dwDataOffset + ckSrcRIFF.cksize)) <br>            goto aacb_Error; <br> <br>        switch (ck.ckid) <br>        { <br>            // <br>            //  explicitly skip these... <br>            // <br>            // <br>            // <br>            case mmioFOURCC('f', 'm', 't', ' '): <br>                break; <br> <br>            case mmioFOURCC('d', 'a', 't', 'a'): <br>                break; <br> <br>            case mmioFOURCC('f', 'a', 'c', 't'): <br>                break; <br> <br>            case mmioFOURCC('J', 'U', 'N', 'K'): <br>                break; <br> <br>            case mmioFOURCC('P', 'A', 'D', ' '): <br>                break; <br> <br>            case mmioFOURCC('c', 'u', 'e', ' '): <br>                break; <br> <br> <br>            // <br>            //  copy chunks that are OK to copy <br>            // <br>            // <br>            // <br>            case mmioFOURCC('p', 'l', 's', 't'): <br>                // although without the 'cue' chunk, it doesn't make much sense <br>                riffCopyChunk(paacd-&gt;hmmioSrc, paacd-&gt;hmmioDst, &amp;ck); <br>                break; <br> <br>            case mmioFOURCC('D', 'I', 'S', 'P'): <br>                riffCopyChunk(paacd-&gt;hmmioSrc, paacd-&gt;hmmioDst, &amp;ck); <br>                break; <br> <br>                 <br>            // <br>            //  don't copy unknown chunks <br>            // <br>            // <br>            // <br>            default: <br>                break; <br>        } <br> <br>        // <br>        //  step up to prepare for next chunk.. <br>        // <br>        mmioAscend(paacd-&gt;hmmioSrc, &amp;ck, 0); <br>    } <br> <br>#if 0 <br>    // <br>    //  now write out possibly editted chunks... <br>    // <br>    if (riffWriteINFO(paacd-&gt;hmmioDst, (glpwio-&gt;pInfo))) <br>    { <br>        goto aacb_Error; <br>    } <br>#endif <br> <br>    // <br>    // go back to beginning of data portion of WAVE chunk <br>    // <br>    if (-1 == mmioSeek(paacd-&gt;hmmioSrc, ckSrcRIFF.dwDataOffset + sizeof(FOURCC), SEEK_SET)) <br>        goto aacb_Error; <br> <br>    ck.ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>    mmioDescend(paacd-&gt;hmmioSrc, &amp;ck, &amp;ckSrcRIFF, MMIO_FINDCHUNK); <br> <br> <br>    // <br>    //  now create the destination fmt, fact, and data chunks _in that order_ <br>    // <br>    // <br>    // <br>    //  hmmio is now descended into the 'RIFF' chunk--create the format chunk <br>    //  and write the format header into it <br>    // <br>    dw = SIZEOF_WAVEFORMATEX(paacd-&gt;pwfxDst); <br> <br>    paacd-&gt;ckDst.ckid   = mmioFOURCC('f', 'm', 't', ' '); <br>    paacd-&gt;ckDst.cksize = dw; <br>    if (mmioCreateChunk(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDst, 0)) <br>        goto aacb_Error; <br> <br>    if (mmioWrite(paacd-&gt;hmmioDst, (HPSTR)paacd-&gt;pwfxDst, dw) != (LONG)dw) <br>        goto aacb_Error; <br> <br>    if (mmioAscend(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDst, 0) != 0) <br>        goto aacb_Error; <br> <br>    // <br>    //  create the 'fact' chunk (not necessary for PCM--but is nice to have) <br>    //  since we are not writing any data to this file (yet), we set the <br>    //  samples contained in the file to 0.. <br>    // <br>    paacd-&gt;ckDst.ckid   = mmioFOURCC('f', 'a', 'c', 't'); <br>    paacd-&gt;ckDst.cksize = 0L; <br>    if (mmioCreateChunk(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDst, 0)) <br>        goto aacb_Error; <br> <br>    if (mmioWrite(paacd-&gt;hmmioDst, (HPSTR)&amp;paacd-&gt;dwSrcSamples, sizeof(DWORD)) != sizeof(DWORD)) <br>        goto aacb_Error; <br> <br>    if (mmioAscend(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDst, 0) != 0) <br>        goto aacb_Error; <br> <br> <br>    // <br>    //  create the data chunk AND STAY DESCENDED... for reasons that will <br>    //  become apparent later.. <br>    // <br>    paacd-&gt;ckDst.ckid   = mmioFOURCC('d', 'a', 't', 'a'); <br>    paacd-&gt;ckDst.cksize = 0L; <br>    if (mmioCreateChunk(paacd-&gt;hmmioDst, &amp;paacd-&gt;ckDst, 0)) <br>        goto aacb_Error; <br> <br>    // <br>    //  at this point, BOTH the src and dst files are sitting at the very <br>    //  beginning of their data chunks--so we can READ from the source, <br>    //  CONVERT the data, then WRITE it to the destination file... <br>    // <br>    return (TRUE); <br> <br> <br>    // <br>    // <br>    // <br>    // <br>aacb_Error: <br> <br>    AcmAppConvertEnd(hdlg, paacd); <br> <br>    return (FALSE); <br>} // AcmAppConvertBegin() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppConvertConvert <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hdlg: <br>//   <br>//      PAACONVERTDESC paacd: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppConvertConvert <br>( <br>    HWND                hdlg, <br>    PAACONVERTDESC     paacd <br>) <br>{ <br>    MMRESULT            mmr; <br>    TCHAR               ach[40]; <br>    DWORD               dw; <br>    WORD                w; <br>    DWORD               dwCurrent; <br>    WORD                wCurPercent; <br>    LPACMSTREAMHEADER   pash; <br>    DWORD               cbRead; <br>    DWORD               dwTime; <br> <br> <br>    wCurPercent = (WORD)-1; <br> <br>    paacd-&gt;cTotalConverts    = 0L; <br>    paacd-&gt;dwTimeTotal       = 0L; <br>    paacd-&gt;dwTimeLongest     = 0L; <br>    if (0 == paacd-&gt;cbSrcData) <br>    { <br>        paacd-&gt;dwTimeShortest    = 0L; <br>        paacd-&gt;dwShortestConvert = 0L; <br>        paacd-&gt;dwLongestConvert  = 0L; <br>    } <br>    else <br>    { <br>        paacd-&gt;dwTimeShortest    = (DWORD)-1L; <br>        paacd-&gt;dwShortestConvert = (DWORD)-1L; </code></pre>
<p>
</p>
<pre><code>paacd-&gt;dwLongestConvert  = (DWORD)-1L; <br>    } <br> <br>    pash = &amp;paacd-&gt;ash; <br> <br>    for (dwCurrent = 0; dwCurrent &lt; paacd-&gt;cbSrcData; ) <br>    { <br>        w = (WORD)((dwCurrent * 100) / paacd-&gt;cbSrcData); <br>        if (w != wCurPercent) <br>        { <br>            wCurPercent = w; <br>            wsprintf(ach, TEXT("%u%%"), wCurPercent); <br> <br>            if (hdlg) <br>                SetDlgItemText(hdlg, IDD_AACONVERT_TXT_STATUS, ach); <br>        } <br> <br>        AppDlgYield(hdlg); <br> <br>        if (gfCancelConvert) <br>            goto aacc_Error; <br> <br>        // <br>        // <br>        // <br>        cbRead = min(paacd-&gt;cbSrcReadSize, paacd-&gt;cbSrcData - dwCurrent); <br>        dw = mmioRead(paacd-&gt;hmmioSrc, paacd-&gt;pbSrc, cbRead); <br>        if (0L == dw) <br>            break; <br> <br> <br>        AppDlgYield(hdlg); <br>        if (gfCancelConvert) <br>            goto aacc_Error; <br> <br>              <br> <br>        // <br>        // <br>        // <br>        pash-&gt;cbSrcLength     = dw; <br>        pash-&gt;cbDstLengthUsed = 0L; <br> <br> <br> <br>        dwTime = timeGetTime(); <br> <br>        mmr = acmStreamConvert(paacd-&gt;has, <br>                               &amp;paacd-&gt;ash, <br>                               ACM_STREAMCONVERTF_BLOCKALIGN); <br> <br>        if (MMSYSERR_NOERROR != mmr) <br>        { <br>            AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                      TEXT("acmStreamConvert() failed with error = %u!"), mmr); <br>            goto aacc_Error; <br>        } <br> <br>        while (0 == (ACMSTREAMHEADER_STATUSF_DONE &amp; ((AACONVERTDESC volatile *)paacd)-&gt;ash.fdwStatus)) <br>            ; <br> <br>        dwTime = timeGetTime() - dwTime; <br> <br> <br>        paacd-&gt;dwTimeTotal += dwTime; <br> <br>        if (dwTime &lt; paacd-&gt;dwTimeShortest) <br>        { <br>            paacd-&gt;dwTimeShortest    = dwTime; <br>            paacd-&gt;dwShortestConvert = paacd-&gt;cTotalConverts; <br>        } <br> <br>        if (dwTime &gt; paacd-&gt;dwTimeLongest) <br>        { <br>            paacd-&gt;dwTimeLongest     = dwTime; <br>            paacd-&gt;dwLongestConvert  = paacd-&gt;cTotalConverts; <br>        } <br> <br>        paacd-&gt;cTotalConverts++; <br> <br> <br>        AppDlgYield(hdlg); <br>        if (gfCancelConvert) <br>            goto aacc_Error; <br> <br> <br>        // <br>        // <br>        // <br>        dw = (cbRead - pash-&gt;cbSrcLengthUsed); <br>        if (0L != dw) <br>        { <br>            mmioSeek(paacd-&gt;hmmioSrc, -(LONG)dw, SEEK_CUR); <br>        } <br> <br>        dwCurrent += pash-&gt;cbSrcLengthUsed; <br> <br> <br>        // <br>        // <br>        // <br>        dw = pash-&gt;cbDstLengthUsed; <br>        if (0L == dw) <br>            break; <br>           <br>        if (mmioWrite(paacd-&gt;hmmioDst, paacd-&gt;pbDst, dw) != (LONG)dw) <br>            goto aacc_Error; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    // <br>    // <br>    wCurPercent = (WORD)-1; <br> <br>    for (;paacd-&gt;cbSrcData;) <br>    { <br>        w = (WORD)((dwCurrent * 100) / paacd-&gt;cbSrcData); <br>        if (w != wCurPercent) <br>        { <br>            wCurPercent = w; <br>            wsprintf(ach, TEXT("Cleanup Pass -- %u%%"), wCurPercent); <br> <br>            if (hdlg) <br>                SetDlgItemText(hdlg, IDD_AACONVERT_TXT_STATUS, ach); <br>        } <br> <br>        AppDlgYield(hdlg); <br>        if (gfCancelConvert) <br>            goto aacc_Error; <br> <br> <br>        // <br>        // <br>        // <br>        dw = 0L; <br>        cbRead = min(paacd-&gt;cbSrcReadSize, paacd-&gt;cbSrcData - dwCurrent); <br>        if (0L != cbRead) <br>        { <br>            dw = mmioRead(paacd-&gt;hmmioSrc, paacd-&gt;pbSrc, cbRead); <br>            if (0L == dw) <br>                break; <br>        } <br> <br> <br>        AppDlgYield(hdlg); <br>        if (gfCancelConvert) <br>            goto aacc_Error; <br> <br>              <br> <br>        // <br>        // <br>        // <br>        pash-&gt;cbSrcLength     = dw; <br>        pash-&gt;cbDstLengthUsed = 0L; <br> <br> <br> <br>        dwTime = timeGetTime(); <br> <br>        mmr = acmStreamConvert(paacd-&gt;has, <br>                               &amp;paacd-&gt;ash, <br>                               ACM_STREAMCONVERTF_BLOCKALIGN | <br>                               ACM_STREAMCONVERTF_END); <br> <br>        if (MMSYSERR_NOERROR != mmr) <br>        { <br>            AppMsgBox(hdlg, MB_OK | MB_ICONEXCLAMATION, <br>                      TEXT("acmStreamConvert() failed with error = %u!"), mmr); <br>            goto aacc_Error; <br>        } <br> <br>        while (0 == (ACMSTREAMHEADER_STATUSF_DONE &amp; ((AACONVERTDESC volatile *)paacd)-&gt;ash.fdwStatus)) <br>            ; <br> <br>        dwTime = timeGetTime() - dwTime; <br> <br> <br>        paacd-&gt;dwTimeTotal += dwTime; <br> <br>        if (dwTime &lt; paacd-&gt;dwTimeShortest) <br>        { <br>            paacd-&gt;dwTimeShortest    = dwTime; <br>            paacd-&gt;dwShortestConvert = paacd-&gt;cTotalConverts; <br>        } <br> <br>        if (dwTime &gt; paacd-&gt;dwTimeLongest) <br>        { <br>            paacd-&gt;dwTimeLongest     = dwTime; <br>            paacd-&gt;dwLongestConvert  = paacd-&gt;cTotalConverts; <br>        } <br> <br>        paacd-&gt;cTotalConverts++; <br> <br> <br>        AppDlgYield(hdlg); <br>        if (gfCancelConvert) <br>            goto aacc_Error; <br> <br>        // <br>        // <br>        // <br>        dw = pash-&gt;cbDstLengthUsed; <br>        if (0L == dw) <br>        { <br>            pash-&gt;cbDstLengthUsed = 0L; <br> <br>            // <br>            //  BUGBUG BOBSTER <br>            //  What if the last conversion ate up some of the source bytes? <br>            //  It's possible - the codec could cache some of the data <br>            //  without actually converting it, right?  The pbSrc pointer <br>            //  might have to be incremented, and cbSrcLength might have to <br>            //  to be decreased by cbSrcLengthUsed.  This probably wouldn't <br>            //  happen with most of our codecs though...? <br>            // <br>            mmr = acmStreamConvert(paacd-&gt;has, <br>                                   &amp;paacd-&gt;ash, <br>                                   ACM_STREAMCONVERTF_END); <br> <br>            if (MMSYSERR_NOERROR == mmr) <br>            { <br>                while (0 == (ACMSTREAMHEADER_STATUSF_DONE &amp; ((AACONVERTDESC volatile *)paacd)-&gt;ash.fdwStatus)) <br>                    ; <br>            } <br> <br>            dw = pash-&gt;cbDstLengthUsed; <br>            if (0L == dw) <br>                break; <br>        } <br>           <br>        if (mmioWrite(paacd-&gt;hmmioDst, paacd-&gt;pbDst, dw) != (LONG)dw) <br>            goto aacc_Error; <br> <br>        // <br>        // <br>        // <br>        dw = (cbRead - pash-&gt;cbSrcLengthUsed); <br>        if (0L != dw) <br>        { <br>            mmioSeek(paacd-&gt;hmmioSrc, -(LONG)dw, SEEK_CUR); <br>        } <br> <br>        dwCurrent += pash-&gt;cbSrcLengthUsed; <br> <br>        if (0L == pash-&gt;cbDstLengthUsed) <br>            break; <br>    } <br> <br>    if (hdlg) <br>        EndConvert(hdlg, !gfCancelConvert, paacd); <br> <br>    return (!gfCancelConvert); <br> <br> <br>aacc_Error: <br> <br>    if (hdlg) <br>        EndConvert(hdlg, FALSE, paacd); <br>    return (FALSE); <br>} // AcmAppConvertConvert() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppConvertDlgProc <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hdlg: <br>//   <br>//      UINT uMsg: <br>//   <br>//      WPARAM wParam: <br>//   <br>//      LPARAM lParam: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AcmAppConvertDlgProc <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    PAACONVERTDESC      paacd; <br>    UINT                uId; <br> <br>    paacd = (PAACONVERTDESC)(UINT)GetWindowLong(hwnd, DWL_USER); <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            paacd = (PAACONVERTDESC)(UINT)lParam; <br> <br>            SetWindowLong(hwnd, DWL_USER, lParam); <br> <br>            SetWindowFont(GetDlgItem(hwnd, IDD_AACONVERT_TXT_INFILEPATH), ghfontApp, FALSE); <br>            SetWindowFont(GetDlgItem(hwnd, IDD_AACONVERT_TXT_OUTFILEPATH), ghfontApp, FALSE); <br>            SetWindowFont(GetDlgItem(hwnd, IDD_AACONVERT_TXT_STATUS), ghfontApp, FALSE); <br> <br>            SetDlgItemText(hwnd, IDD_AACONVERT_TXT_INFILEPATH, paacd-&gt;szFilePathSrc); <br>            SetDlgItemText(hwnd, IDD_AACONVERT_TXT_OUTFILEPATH, paacd-&gt;szFilePathDst); <br> <br>            BeginConvert(hwnd, paacd); <br>            return (TRUE); <br> <br> <br>        case WM_CONVERT_BEGIN: <br>            gfCancelConvert = FALSE; <br>            if (AcmAppConvertBegin(hwnd, paacd)) <br>            { <br>                AcmAppConvertConvert(hwnd, paacd); <br>            } <br>            else <br>            { <br>                EndConvert(hwnd, FALSE, paacd); <br>            } <br>            break; <br> <br> <br>        case WM_CONVERT_END: <br>            AcmAppConvertEnd(hwnd, paacd); <br>            EndDialog(hwnd, !gfCancelConvert); <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            uId = GET_WM_COMMAND_ID(wParam, lParam); <br>            if (IDCANCEL == uId) <br>            { <br>                gfCancelConvert = TRUE; <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // AcmAppConvertDlgProc() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppMultiThreadConvert <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hdlg: <br>//   <br>//      UINT uMsg: <br>//   <br>//      WPARAM wParam: <br>//   <br>//      LPARAM lParam: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>LONG AcmAppMultiThreadConvert <br>( <br>    PAACONVERTDESC      paacd <br>) <br>{ <br>    if (AcmAppConvertBegin(NULL, paacd)) <br>    { <br>        AcmAppConvertConvert(NULL, paacd); <br>    } <br> <br>    AcmAppConvertEnd(NULL, paacd); <br> <br>    AcmAppOpenInstance(NULL, paacd-&gt;szFilePathDst, FALSE); <br> <br>    // <br>    //  clean up... <br>    // <br>    if (NULL != paacd-&gt;pwfxDst) <br>    { <br>        GlobalFreePtr(paacd-&gt;pwfxDst); <br>        paacd-&gt;pwfxDst = NULL; <br>    } <br> <br>    if (NULL != paacd-&gt;pwfltr) <br>    { <br>        GlobalFreePtr(paacd-&gt;pwfltr); <br>        paacd-&gt;pwfltr = NULL; <br>    } <br> <br>    paacd-&gt;pwfxSrc = NULL; <br> <br>    LocalFree((HLOCAL)paacd); <br> <br>    return (TRUE); <br> <br>} // AcmAppMultiThreadConvert() <br> <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppFileConvert <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppFileConvert <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    BOOL                f; <br>    DWORD               nAvgBytesPerSec; <br>    DWORD               nBlockAlign; <br>    DWORD               dwTimeAverage; <br>    PAACONVERTDESC      paacd; <br> <br>    paacd = (PAACONVERTDESC)LocalAlloc(LPTR, sizeof(*paacd)); <br>    if (NULL == paacd) <br>    { <br>        return (FALSE); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    paacd-&gt;hmmioSrc      = NULL; <br>    paacd-&gt;hmmioDst      = NULL; <br> <br>    // <br>    //  default to 1 second per convert buffer.. <br>    // <br>    paacd-&gt;uBufferTimePerConvert = 1000; <br> <br>    paacd-&gt;dwSrcSamples  = paafd-&gt;dwDataSamples; <br> <br> <br>    // <br>    //  compute source bytes to read (round down to nearest block for <br>    //  one second of data) <br>    // <br>    nAvgBytesPerSec     = paafd-&gt;pwfx-&gt;nAvgBytesPerSec; <br>    nBlockAlign         = paafd-&gt;pwfx-&gt;nBlockAlign; <br>    paacd-&gt;cbSrcReadSize = nAvgBytesPerSec - (nAvgBytesPerSec % nBlockAlign); <br> <br>    paacd-&gt;cbDstBufSize  = 0L; <br>    paacd-&gt;fdwOpen       = 0L; <br> <br>    lstrcpy(paacd-&gt;szFilePathSrc, paafd-&gt;szFilePath); <br>    paacd-&gt;pwfxSrc       = paafd-&gt;pwfx; <br>    paacd-&gt;pbSrc         = NULL; <br> <br>    paacd-&gt;cbSrcData     = paafd-&gt;dwDataBytes; <br> <br>    lstrcpy(paacd-&gt;szFilePathDst, gszLastSaveFile); <br>    paacd-&gt;pwfxDst       = NULL; <br>    paacd-&gt;pbDst         = NULL; <br> <br>    paacd-&gt;fApplyFilter  = FALSE; <br>    paacd-&gt;pwfltr        = NULL; <br> <br> <br>    paacd-&gt;cTotalConverts     = 0L; <br>    paacd-&gt;dwTimeTotal        = 0L; <br>    paacd-&gt;dwTimeShortest     = (DWORD)-1L; <br>    paacd-&gt;dwShortestConvert  = (DWORD)-1L; <br>    paacd-&gt;dwTimeLongest      = 0L; <br>    paacd-&gt;dwLongestConvert   = (DWORD)-1L; <br> <br>    // <br>    // <br>    // <br>    f = DialogBoxParam(ghinst, <br>                       DLG_AACHOOSER, <br>                       hwnd, <br>                       AcmAppDlgProcChooser, <br>                       (LPARAM)(UINT)paacd); <br>    if (f) <br>    { <br>        lstrcpy(gszLastSaveFile, paacd-&gt;szFilePathDst); <br> <br>        // <br>        // <br>        // <br>        f = DialogBoxParam(ghinst, <br>                            DLG_AACONVERT, <br>                            hwnd, <br>                            AcmAppConvertDlgProc, <br>                            (LPARAM)(UINT)paacd); <br>        if (!f) <br>        { <br>            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                        TEXT("Conversion aborted--destination file is corrupt!")); <br>        } <br> <br> <br>        if (paacd-&gt;cTotalConverts &gt; 1) <br>        { <br>            dwTimeAverage  = paacd-&gt;dwTimeTotal; <br>            dwTimeAverage -= paacd-&gt;dwTimeShortest; <br> <br>            dwTimeAverage /= (paacd-&gt;cTotalConverts - 1); <br>        } <br>        else <br>        { <br>            dwTimeAverage = paacd-&gt;dwTimeTotal; <br>        } <br> <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                    TEXT("Conversion Statistics:\n\nTotal Time:\t%lu ms\nTotal Converts:\t%lu\nShortest Time:\t%lu ms (on %lu)\nLongest Time:\t%lu ms (on %lu)\n\nAverage Time:\t%lu ms"), <br>                    paacd-&gt;dwTimeTotal, <br>                    paacd-&gt;cTotalConverts, <br>                    paacd-&gt;dwTimeShortest, <br>                    paacd-&gt;dwShortestConvert, <br>                    paacd-&gt;dwTimeLongest, <br>                    paacd-&gt;dwLongestConvert, <br>                    dwTimeAverage); <br> <br>        if (f) <br>        { <br>            AcmAppOpenInstance(hwnd, paacd-&gt;szFilePathDst, FALSE); <br>        } <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    if (NULL != paacd-&gt;pwfxDst) <br>    { <br>        GlobalFreePtr(paacd-&gt;pwfxDst); <br>        paacd-&gt;pwfxDst = NULL; <br>    } <br> <br>    if (NULL != paacd-&gt;pwfltr) <br>    { <br>        GlobalFreePtr(paacd-&gt;pwfltr); <br>        paacd-&gt;pwfltr = NULL; <br>    } <br> <br>    paacd-&gt;pwfxSrc = NULL; <br> <br> <br>    LocalFree((HLOCAL)paacd); <br> <br>    return (f); <br>} // AcmAppFileConvert() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppMultiThreadedCallback <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HACMDRIVERID hadid: <br>//   <br>//      DWORD dwInstance: <br>//   <br>//      DWORD fdwSupport: <br>//   <br>//  Return (BOOL): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AcmAppMultiThreadedCallback <br>( <br>    HACMDRIVERID        hadid, <br>    LPACMFORMATDETAILS  pafd, <br>    DWORD               dwInstance, <br>    DWORD               fdwSupport <br>) <br>{ <br>    DWORD               nAvgBytesPerSec; <br>    DWORD               nBlockAlign; <br>    PAACONVERTDESC      paacd; <br>    PACMAPPFILEDESC     paafd; <br>#ifdef WIN32 <br>    int                 i = -1; <br>    ACMFORMATTAGDETAILS aftd; <br>    MMRESULT            mmr; <br>    HANDLE              hThrd; <br>    LONG                lThreadId; <br>#endif <br> <br>    // <br>    // I have sent myself (PACMAPPFILEDESC)paafd for the source <br>    // file.  I need to copy the relevent information from this structure <br>    // into a (PAACONVERTDESC)paacd and send it off to the thread created <br>    // below. <br>    // <br>    paafd = (PACMAPPFILEDESC)dwInstance; <br> <br>    paacd = (PAACONVERTDESC)LocalAlloc(LPTR, sizeof(*paacd)); <br>    if (NULL == paacd) <br>    { <br>        return (FALSE); <br>    } <br> <br>    // <br>    // <br>    // <br>    paacd-&gt;hmmioSrc      = NULL; <br>    paacd-&gt;hmmioDst      = NULL; <br> <br>    // <br>    //  default to 1 second per convert buffer.. <br>    // <br>    paacd-&gt;uBufferTimePerConvert = 1000; <br> <br>    paacd-&gt;dwSrcSamples  = paafd-&gt;dwDataSamples; <br> <br> <br>    // <br>    //  compute source bytes to read (round down to nearest block for <br>    //  one second of data) <br>    // <br>    nAvgBytesPerSec     = paafd-&gt;pwfx-&gt;nAvgBytesPerSec; <br>    nBlockAlign         = paafd-&gt;pwfx-&gt;nBlockAlign; <br>    paacd-&gt;cbSrcReadSize = nAvgBytesPerSec - (nAvgBytesPerSec % nBlockAlign); <br> <br>    paacd-&gt;cbDstBufSize  = 0L; <br>    paacd-&gt;fdwOpen       = ACM_STREAMOPENF_NONREALTIME; <br> <br>    lstrcpy(paacd-&gt;szFilePathSrc, paafd-&gt;szFilePath); <br>    paacd-&gt;pwfxSrc       = paafd-&gt;pwfx; <br>    paacd-&gt;pbSrc         = NULL; <br> <br>    paacd-&gt;cbSrcData     = paafd-&gt;dwDataBytes; <br> <br> <br>      <br>    paacd-&gt;pwfxDst = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, SIZEOF_WAVEFORMATEX(pafd-&gt;pwfx)); <br>    if (NULL == paacd-&gt;pwfxDst) <br>    { <br>        return (FALSE); <br>    } <br>    _fmemcpy(paacd-&gt;pwfxDst,pafd-&gt;pwfx,SIZEOF_WAVEFORMATEX(pafd-&gt;pwfx)); <br>    paacd-&gt;pbDst         = NULL; <br> <br>    paacd-&gt;fApplyFilter  = FALSE; <br>    paacd-&gt;pwfltr        = NULL; <br> <br> <br>    paacd-&gt;cTotalConverts     = 0L; <br>    paacd-&gt;dwTimeTotal        = 0L; <br>    paacd-&gt;dwTimeShortest     = (DWORD)-1L; <br>    paacd-&gt;dwShortestConvert  = (DWORD)-1L; <br>    paacd-&gt;dwTimeLongest      = 0L; <br>    paacd-&gt;dwLongestConvert   = (DWORD)-1L; <br> <br> <br>    // <br>    //  Under Win32 I can spawn a thread for each conversion. <br>    //  Under Win16 I have to wait for each of the conversions to complete. <br>    // <br>#ifdef WIN32 <br>    // <br>    // Remove file extension and add extra info <br>    // <br>    lstrcpy(paacd-&gt;szFilePathDst, paafd-&gt;szFilePath); <br> <br>    while ((paacd-&gt;szFilePathDst[++i] != '.') &amp;&amp; <br>           (paacd-&gt;szFilePathDst[i]   != '(')); <br>    paacd-&gt;szFilePathDst[i] = '\0'; <br> <br>    // <br>    //  initialize all unused members of the ACMFORMATTAGDETAILS <br>    //  structure to zero <br>    // <br>    memset(&amp;aftd, 0, sizeof(aftd)); <br> <br>    // <br>    //  fill in the required members of the ACMFORMATTAGDETAILS <br>    //  structure for the ACM_FORMATTAGDETAILSF_FORMATTAG query <br>    // <br>    aftd.cbStruct    = sizeof(aftd); <br>    aftd.dwFormatTag = pafd-&gt;pwfx-&gt;wFormatTag; <br> <br>    mmr = acmFormatTagDetails(NULL, <br>                              &amp;aftd, <br>                              ACM_FORMATTAGDETAILSF_FORMATTAG); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(NULL, MB_OK | MB_ICONEXCLAMATION, <br>                    TEXT("Conversion aborted--could not construct filename")); <br>    } <br> <br>    // <br>    //  Construct a long filename based on the format type <br>    // <br>    wsprintf(paacd-&gt;szFilePathDst, "%s(%s %s).wav", <br>                (LPCTSTR)paacd-&gt;szFilePathDst, <br>                (LPCTSTR)aftd.szFormatTag, <br>                (LPCTSTR)pafd-&gt;szFormat); <br> <br>    hThrd = CreateThread(NULL, 0, <br>                         (LPTHREAD_START_ROUTINE)AcmAppMultiThreadConvert, <br>                         (LPVOID)paacd, <br>                         0, <br>                         (LPDWORD)&amp;lThreadId ); <br> <br>    if (!hThrd) <br>    { <br>        AppMsgBox(NULL, MB_OK | MB_ICONEXCLAMATION, <br>                    TEXT("Conversion aborted--failure doing conversion")); <br>    } <br> <br>    // <br>    //  Since I don't use this handle anywhere, I will close it <br>    // <br>    CloseHandle(hThrd); <br>#else <br>    // <br>    //  Don't want to make too much trouble for the Win16 version. <br>    // <br>    wsprintf(paacd-&gt;szFilePathDst, "%d%c%d%d.wav", <br>                pafd-&gt;pwfx-&gt;wFormatTag, <br>                (2 == pafd-&gt;pwfx-&gt;nChannels) ? 's' : 'm', <br>                (UINT)(pafd-&gt;pwfx-&gt;nAvgBytesPerSec * 8 / <br>                 pafd-&gt;pwfx-&gt;nSamplesPerSec / <br>                 pafd-&gt;pwfx-&gt;nChannels), <br>                 pafd-&gt;pwfx-&gt;nSamplesPerSec/1000); <br> <br>    AcmAppMultiThreadConvert(paacd); <br>#endif <br> <br>    // <br>    //  return TRUE to continue with enumeration <br>    // <br>    return (TRUE); <br>} // AcmAppMultiThreadedCallback() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AcmAppMultiThreadedConvertAll <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//      PACMAPPFILEDESC paafd: <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppMultiThreadedConvertAll <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    MMRESULT            mmr; <br>    ACMFORMATDETAILS    afd; <br>    DWORD               cbwfx; <br> <br> <br>    // <br>    //  Call acmFormatEnum to enumerated all formats that the source format <br>    //  can convert to. <br>    // <br>    //  Use the wave format for the enumeration <br>    // <br> <br>    mmr = acmMetrics(NULL, ACM_METRIC_MAX_SIZE_FORMAT, &amp;cbwfx); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppMultiThreadedConvertAll() acmMetrics failed mmr=%u!"), mmr); <br>        return (FALSE); <br>    } <br> <br>    memset(&amp;afd, 0, sizeof(afd)); <br>    afd.cbStruct    = sizeof(afd); <br>    afd.dwFormatTag = WAVE_FORMAT_UNKNOWN; <br> <br>    afd.pwfx = (LPWAVEFORMATEX)GlobalAllocPtr(GHND, (UINT)cbwfx); <br>    if (NULL == afd.pwfx) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppMultiThreadedConvertAll() LocalAlloc failed!")); <br>        return (FALSE); <br>    } <br> <br>    _fmemcpy(afd.pwfx, paafd-&gt;pwfx, SIZEOF_WAVEFORMATEX(paafd-&gt;pwfx)); <br>    afd.cbwfx = cbwfx; <br> <br> <br>    mmr = acmFormatEnum(NULL, &amp;afd, AcmAppMultiThreadedCallback, (DWORD)(LPVOID)paafd, <br>            ACM_FORMATENUMF_CONVERT); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                  TEXT("AcmAppMultiThreadedConvertAll() acmFormatEnum failed mmr=%u!"), mmr); <br>        return (FALSE); <br>    } <br> <br>    GlobalFreePtr(afd.pwfx); <br> <br>    return TRUE; <br> <br>} // AcmAppMultiThreadedConvertAll() <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
