<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AAINIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2455"></a>AAINIT.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  aainit.c <br>// <br>//  Description: <br>//      This file contains initialization and termination code for the <br>//      application (as well as some rarely used stuff). <br>// <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#ifndef WIN32 <br>#include &lt;shellapi.h&gt; <br>#endif  <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;memory.h&gt; <br> <br>#include "acmthunk.h" <br>#include "appport.h" <br>#include "acmapp.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>// <br>// <br>TCHAR   gszSecConfig[]          = TEXT("Configuration"); <br> <br>TCHAR   gszKeyOptions[]         = TEXT("Options"); <br>TCHAR   gszFormatOptions[]      = TEXT("%u"); <br> <br>TCHAR   gszKeyWindow[]          = TEXT("Window"); <br>TCHAR   gszKeyFont[]            = TEXT("Font"); <br>TCHAR   gszKeyInitialDirOpen[]  = TEXT("InitialDirOpen"); <br>TCHAR   gszKeyInitialDirSave[]  = TEXT("InitialDirSave"); <br>TCHAR   gszKeyLastSaveFile[]    = TEXT("LastSaveFile"); <br> <br> <br>//==========================================================================; <br>// <br>//  Application helper functions and rarely called stuff... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppWinIniChange <br>// <br>//  Description: <br>//      This function is responsible for handling the WM_WININICHANGE <br>//      message. This message is sent when modifications have been made <br>//      to WIN.INI (from SystemParametersInfo() or other sources). <br>// <br>//      An application should re-enumerate system metrics (GetSystemMetrics) <br>//      and system color (GetSystemColors) information that it has cached. <br>//      Note that checking the section that was modified should be done if <br>//      some enumerations are time consuming. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP <br>//      message. <br>// <br>//      LPCTSTR pszSection: Pointer to section name that has been modified <br>//      in WIN.INI. Note that this argument might be NULL (sent by apps <br>//      that were written incorrectly!). If it is NULL, then this application <br>//      should re-enumerate ALL metrics, colors, etc. <br>// <br>//  Return (LRESULT): <br>//      The return value is zero if the message is processed. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppWinIniChange <br>( <br>    HWND                    hwnd, <br>    LPCTSTR                 pszSection <br>) <br>{ <br>    DPF(1, "AppWinIniChanged(hwnd=%Xh, pszSection='%s')", <br>            hwnd, (NULL == pszSection) ? TEXT("(null)") : pszSection); <br> <br>    // <br>    //  we processed the message... <br>    // <br>    return (0L); <br>} // AppWinIniChange() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  HFONT AppChooseFont <br>// <br>//  Description: <br>//      This function is a wrapper for the ChooseFont() common dialog. <br>//      The purpose of this function is to let the user choose a font that <br>//      looks good to them--regardless of how stupid it really looks. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for chooser dialog. <br>// <br>//      HFONT hfont: Handle to current font (default for chooser dialog). <br>// <br>//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a <br>//      copy of the LOGFONT information for the newly chosen font. <br>// <br>//  Return (HFONT): <br>//      The return value is the newly chosen font. If no new font was chosen <br>//      then the return value is NULL. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>HFONT FNGLOBAL AppChooseFont <br>( <br>    HWND                    hwnd, <br>    HFONT                   hfont, <br>    PLOGFONT                plf <br>) <br>{ <br>    LOGFONT             lf; <br>    CHOOSEFONT          cf; <br>    BOOL                f; <br>    HFONT               hfontNew; <br> <br>    // <br>    //  get the font info for the current font... <br>    // <br>    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&amp;lf); <br> <br>    // <br>    //  fill in the choosefont structure <br>    // <br>    cf.lStructSize  = sizeof(CHOOSEFONT); <br>    cf.hwndOwner    = hwnd; <br>    cf.hDC          = NULL; <br>    cf.Flags        = CF_SCREENFONTS | <br>                      CF_INITTOLOGFONTSTRUCT | <br>                      CF_FIXEDPITCHONLY | <br>                      CF_FORCEFONTEXIST; <br>    cf.lCustData    = 0; <br>    cf.lpfnHook     = NULL; <br>    cf.hInstance    = NULL; <br>    cf.nFontType    = SCREEN_FONTTYPE; <br>    cf.lpLogFont    = (LPLOGFONT)&amp;lf; <br> <br>    // <br>    //  splash a dialog into the user's face.. <br>    // <br>    hfontNew = NULL; <br>    f = ChooseFont(&amp;cf); <br>    if (f) <br>    { <br>        // <br>        //  create the new font.. <br>        // <br>        hfontNew = CreateFontIndirect(&amp;lf); <br>        if (NULL == hfontNew) <br>            return (NULL); <br> <br>        // <br>        //  copy the logfont structure if caller wants it <br>        // <br>        if (NULL != plf) <br>            *plf = lf; <br>    } <br> <br>    // <br>    //  return the new font (if one was chosen) <br>    // <br>    return (hfontNew); <br>} // AppChooseFont() <br> <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppProfileWriteBytes <br>//   <br>//  Description: <br>//      This function writes a raw structure of bytes to the application's <br>//      ini section that can later be retrieved using AppProfileReadBytes. <br>//      This gives an application the ability to write any structure to <br>//      the ini file and restore it later--very useful. <br>// <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>// <br>//  Arguments: <br>//      PTSTR pszSection: Pointer to section for the stored data. <br>// <br>//      PTSTR pszKey: Pointer to key name for the stored data. <br>//   <br>//      LPBYTE pbStruct: Pointer to the data to be saved. <br>//   <br>//      UINT cbStruct: Count in bytes of the data to store. <br>//   <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if it fails. <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileWriteBytes <br>( <br>    PTSTR                   pszSection, <br>    PTSTR                   pszKey, <br>    LPBYTE                  pbStruct, <br>    UINT                    cbStruct <br>) <br>{ <br>    static TCHAR achNibbleToChar[] = <br>    { <br>        '0', '1', '2', '3', '4', '5', '6', '7', <br>        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', <br>    }; <br>    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x]) <br>     <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br> <br>    // <br>    //  if pbStruct is NULL, then erase the key from the ini file, otherwise <br>    //  format the raw bytes into a hex string and write that out... <br>    // <br>    fAllocated = FALSE; <br>    psz        = NULL; <br>    if (NULL != pbStruct) <br>    { <br>        // <br>        //  check if the quick buffer can be used for formatting the output <br>        //  text--if it cannot, then alloc space for it. note that space <br>        //  must be available for an ending checksum byte (2 bytes for high <br>        //  and low nibble) as well as a null terminator. <br>        // <br>        psz     = (LPTSTR)ach; <br>        cchTemp = cbStruct * 2 + 3; <br>        if (cchTemp &gt; SIZEOF(ach)) <br>        { <br>            psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>            if (NULL == psz) <br>                return (FALSE); <br> <br>            fAllocated = TRUE; <br>        } <br>   <br>        // <br>        //  step through all bytes in the structure and convert it to <br>        //  a string of hex numbers... <br>        // <br>        bChecksum = 0; <br>        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>        { <br>            // <br>            //  grab the next byte and add into checksum... <br>            // <br>            bChecksum += (b = *pbStruct); <br>       <br>            *pch++ = NIBBLE2CHAR((b &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>            *pch++ = NIBBLE2CHAR(b &amp; (BYTE)0x0F); <br>        } <br> <br>        // <br>        //  add the checksum byte to the end and null terminate the hex <br>        //  dumped string... <br>        // <br>        *pch++ = NIBBLE2CHAR((bChecksum &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>        *pch++ = NIBBLE2CHAR(bChecksum &amp; (BYTE)0x0F); <br>        *pch   = '\0'; <br>    } <br> <br>    // <br>    //  write the string of hex bytes out to the ini file... <br>    // <br>    fReturn = WritePrivateProfileString(pszSection, pszKey, psz, gszAppProfile); <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>        GlobalFreePtr(psz); <br>   <br>    return (fReturn); <br>} // AppProfileWriteBytes <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppProfileReadBytes <br>//   <br>//  Description: <br>//      This function reads a previously stored structure of bytes from <br>//      the application's ini file. This data must have been written with <br>//      the AppProfileWriteBytes function--it is checksumed to keep bad <br>//      data from blowing up the application. <br>//   <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>//   <br>//  Arguments: <br>//      PTSTR pszSection: Pointer to section that contains the data. <br>// <br>//      PTSTR pszKey: Pointer to key that contains the data. <br>//   <br>//      LPBYTE pbStruct: Pointer to buffer to receive the data. <br>//   <br>//      UINT cbStruct: Number of bytes expected. <br>//   <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if the function fails (bad checksum, missing key, etc). <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileReadBytes <br>( <br>    PTSTR                   pszSection, <br>    PTSTR                   pszKey, <br>    LPBYTE                  pbStruct, <br>    UINT                    cbStruct <br>) <br>{ <br>    // <br>    //  note that the following works for both upper and lower case, and <br>    //  will return valid values for garbage chars <br>    // <br>    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') ?  \ <br>                                (BYTE)((ch) - '0') :                \ <br>                                ((BYTE)(10 + (ch) - 'A') &amp; (BYTE)0x0F) ) <br> <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    UINT        u; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br>    TCHAR       ch; <br> <br>    // <br>    //  add one the the number of bytes needed to accomodate the checksum <br>    //  byte placed at the end by AppProfileWriteBytes... <br>    // <br>    cbStruct++; <br> <br>    // <br>    //  check if the quick buffer can be used for retrieving the input <br>    //  text--if it cannot, then alloc space for it. note that there must <br>    //  be space available for the null terminator (the +1 below). <br>    // <br>    fAllocated = FALSE; <br>    psz        = (LPTSTR)ach; <br>    cchTemp    = cbStruct * 2 + 1; <br>    if (cchTemp &gt; SIZEOF(ach)) <br>    { <br>        psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>        if (NULL == psz) <br>            return (FALSE); <br> <br>        fAllocated = TRUE; <br>    } <br> <br>    // <br>    //  read the hex string... if it is not the correct length, then assume <br>    //  error and return. <br>    // <br>    fReturn = FALSE; <br>    u = (UINT)GetPrivateProfileString(pszSection, pszKey, gszNull, <br>                                      psz, cchTemp, gszAppProfile); <br>    if ((cbStruct * 2) == u) <br>    { <br>        bChecksum = 0; <br>        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>        { <br>            ch = *pch++; <br>            b  = CHAR2NIBBLE(ch) &lt;&lt; (BYTE)4; <br>            ch = *pch++; <br>            b |= CHAR2NIBBLE(ch); <br> <br>            // <br>            //  if this is not the final byte (the checksum byte), then  <br>            //  store it and accumulate checksum.. <br>            // <br>            if (cbStruct != 1) <br>                bChecksum += (*pbStruct = b); <br>        } <br> <br>        // <br>        //  check the last byte read against the checksum that we calculated <br>        //  if they are not equal then return error... <br>        // <br>        fReturn = (bChecksum == b); <br>    } <br> <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>        GlobalFreePtr(psz); <br>   <br>    return (fReturn); <br>} // AppProfileReadBytes <br> <br> <br>//==========================================================================; <br>// <br>//  Startup and shutdown code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppChooseFont <br>// <br>//  Description: <br>//      This function lets the user choose a new font for the script window. <br>//      After a new font is chosen, the font structure is stored to the <br>//      .ini file so it can be restored on the next run of this application. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a new font was chosen. It is FALSE if <br>//      the user canceled the operation. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppChooseFont <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    LOGFONT             lf; <br>    HWND                hedit; <br>    HFONT               hfont; <br>    HFONT               hfontNew; <br> <br>    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY); <br> <br>    // <br>    //  get the current font and pass it to the choose font dialog <br>    // <br>    hfont = GetWindowFont(hedit); <br> <br>    hfontNew = AppChooseFont(hwnd, hfont, &amp;lf); <br>    if (NULL == hfontNew) <br>        return (FALSE); <br> <br>    // <br>    //  select the new font into the window and delete the old one <br>    // <br>    SetWindowFont(hedit, hfontNew, TRUE); <br>    DeleteFont(hfont); <br> <br>    ghfontApp = hfontNew; <br> <br> <br>    // <br>    //  save the complete description of the chosen font so there can be <br>    //  no strangness in the font mapping next run. this is overkill, but <br>    //  it works... <br>    // <br>    AppProfileWriteBytes(gszSecConfig, gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br> <br>    return (TRUE); <br>} // AcmAppChooseFont() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppSettingsRestore <br>// <br>//  Description: <br>//      This function restores state information for the application. This <br>//      function is called just after the main window is created (it has <br>//      not been ShowWindow()'d). This function will generate the call <br>//      to ShowWindow before returning. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that has just been created but <br>//      not shown. <br>// <br>//      int nCmdShow: The state that the application window should show as. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppSettingsRestore <br>( <br>    HWND                    hwnd, <br>    int                     nCmdShow <br>) <br>{ <br>    WINDOWPLACEMENT     wp; <br>    LOGFONT             lf; <br>    RECT                rc; <br>    RECT                rcWindow; <br>    POINT               pt; <br>    int                 n; <br>    BOOL                f; <br> <br> <br>    // <br>    //  restore the previous Options state... <br>    // <br>    gfuAppOptions = GetPrivateProfileInt(gszSecConfig, gszKeyOptions, <br>                                         gfuAppOptions, gszAppProfile); <br> <br> <br> <br>    // <br>    //  restore the user's preferred font. <br>    // <br>    ghfontApp = GetStockFont(SYSTEM_FIXED_FONT); <br>    f = AppProfileReadBytes(gszSecConfig, gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br>    if (f) <br>    { <br>        HFONT   hfont; <br> <br>        hfont = CreateFontIndirect(&amp;lf); <br>        if (NULL != hfont) <br>        { <br>            ghfontApp = hfont; <br>        } <br>    } <br> <br>    SetWindowFont(GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY), ghfontApp, FALSE); <br> <br> <br>    // <br>    // <br>    // <br>    GetPrivateProfileString(gszSecConfig, gszKeyInitialDirOpen, gszNull, <br>                            gszInitialDirOpen, SIZEOF(gszInitialDirOpen), <br>                            gszAppProfile); <br> <br>    GetPrivateProfileString(gszSecConfig, gszKeyInitialDirSave, gszNull, <br>                            gszInitialDirSave, SIZEOF(gszInitialDirSave), <br>                            gszAppProfile); <br> <br>    GetPrivateProfileString(gszSecConfig, gszKeyLastSaveFile, gszNull, <br>                            gszLastSaveFile, SIZEOF(gszLastSaveFile), <br>                            gszAppProfile); <br> <br> <br>    // <br>    //  grab the stored window position and size from the .ini file... <br>    //  there must be four arguments stored or the entry is considered <br>    //  invalid. <br>    // <br>    f = AppProfileReadBytes(gszSecConfig, gszKeyWindow, <br>                            (LPBYTE)&amp;rcWindow, sizeof(rcWindow)); <br>    if (f) <br>    { <br>        // <br>        //  to make sure the user can always get at the window, check to <br>        //  see if the midpoint of the caption is visible--if it is not, <br>        //  then default to the default position used when creating the <br>        //  window. <br>        // <br>        n = (rcWindow.right - rcWindow.left) / 2; <br>        pt.x = (n + rcWindow.left); <br> <br>        n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME); <br>        pt.y = (n + rcWindow.top); <br> <br>        GetWindowRect(GetDesktopWindow(), &amp;rc); <br>        if (PtInRect(&amp;rc, pt)) <br>        { <br>            // <br>            //  fill out the window placement structure--default the <br>            //  maximized and minimized states to default placement by <br>            //  getting its current placement. <br>            // <br>            wp.length = sizeof(wp); <br>            GetWindowPlacement(hwnd, &amp;wp); <br> <br>            wp.showCmd          = nCmdShow; <br>#if 0 <br>            wp.rcNormalPosition = rcWindow; <br>#else <br>            n = rcWindow.right - rcWindow.left; <br>            wp.rcNormalPosition.right  = wp.rcNormalPosition.left + n; <br> <br>            n = rcWindow.bottom - rcWindow.top; <br>            wp.rcNormalPosition.bottom = wp.rcNormalPosition.top + n; <br>#endif <br> <br>            SetWindowPlacement(hwnd, &amp;wp); <br>            return (TRUE); <br>        } <br>    } <br> <br>    // <br>    //  show defaulted and succeed <br>    // <br>    ShowWindow(hwnd, nCmdShow); <br> <br>    return (TRUE); <br>} // AcmAppSettingsRestore() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppSettingsSave <br>// <br>//  Description: <br>//      This function saves the current state information for the application. <br>//      It is called just before the main window is closed (destroyed); or <br>//      as Windows is exiting (query end session). <br>// <br>//      Note that this function should not destroy any resources--it can <br>//      be called at any time to save a snapshot of the application state. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that will be destroyed shortly. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppSettingsSave <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    TCHAR               ach[APP_MAX_STRING_RC_CHARS]; <br>    WINDOWPLACEMENT     wp; <br>    PRECT               prc; <br>    BOOL                f; <br> <br>    // <br>    //  save the current option settings--note that we ALWAYS turn off the <br>    //  debug logging option so the app doesn't try to OutputDebugString <br>    //  unexpectedly during the next session... <br>    // <br>    gfuAppOptions &amp;= ~APP_OPTIONSF_DEBUGLOG; <br>    if (GetPrivateProfileInt(gszSecConfig, gszKeyOptions, 0, gszAppProfile) != gfuAppOptions) <br>    { <br>        wsprintf(ach, gszFormatOptions, gfuAppOptions); <br>        WritePrivateProfileString(gszSecConfig, gszKeyOptions, ach, gszAppProfile); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    WritePrivateProfileString(gszSecConfig, gszKeyInitialDirOpen, <br>                              gszInitialDirOpen, gszAppProfile); <br> <br>    WritePrivateProfileString(gszSecConfig, gszKeyInitialDirSave, <br>                              gszInitialDirSave, gszAppProfile); <br> <br>    WritePrivateProfileString(gszSecConfig, gszKeyLastSaveFile, <br>                              gszLastSaveFile, gszAppProfile); <br> <br> <br> <br>    // <br>    //  save the current window placement--only store the size and location <br>    //  of the restored window. maximized and minimized states should <br>    //  remain defaulted on the next invocation of this application. <br>    // <br>    wp.length = sizeof(wp); <br>    f = GetWindowPlacement(hwnd, &amp;wp); <br>    if (f) <br>    { <br>        prc = &amp;wp.rcNormalPosition; <br> <br> <br>        // <br>        //  save the _bounding rectangle_ of the restored window state... <br>        // <br>        AppProfileWriteBytes(gszSecConfig, gszKeyWindow, (LPBYTE)prc, sizeof(*prc)); <br>    } <br> <br> <br>    // <br>    //  succeed <br>    // <br>    return (TRUE); <br>} // AcmAppSettingsSave() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppShutdown <br>// <br>//  Description: <br>//      This function is called to gracefully shut down the application. <br>//      If the application should not be closed, a FALSE value is returned. <br>//      This function is called for WM_CLOSE and WM_QUERYENDSESSION <br>//      messages... <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to current file description. <br>// <br>//  Return (BOOL): <br>//      Returns TRUE if the application can proceed with close. Returns <br>//      FALSE if the application should NOT be closed. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppShutdown <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    BOOL                f; <br> <br> <br>    // <br>    //  check if the script has been modified without saving. if the user <br>    //  cancels the operation, then we will NOT close the application. <br>    // <br>    f = AcmAppFileSaveModified(hwnd, paafd); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    // <br>    // <br>    // <br>    if (NULL != ghadidNotify) <br>    { <br>        acmDriverRemove(ghadidNotify, 0L); <br>        ghadidNotify = NULL; <br>    } <br> <br> <br>    // <br>    //  save any settings that should be saved on app termination... <br>    // <br>    AcmAppSettingsSave(hwnd); <br> <br> <br>    // <br>    //  allow closing of application... <br>    // <br>    return (TRUE); <br>} // AcmAppShutdown() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppInit <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>// <br>// <br>//  Return (BOOL): <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AcmAppInit <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd, <br>    LPTSTR                  pszCmdLine, <br>    int                     nCmdShow <br>) <br>{ <br>    BOOL                f; <br>    DWORD               dwVersion; <br> <br> <br>    // <br>    //  !!! VERY IMPORTANT !!! <br>    // <br>    //  the ACM may or may not be installed. this application is using  <br>    //  the ACMTHUNK.C file to dynamically link to the ACM. if the <br>    //  acmThunkInitialize() API fails, then the ACM is *NOT* installed <br>    //  and none of the API's should be used. <br>    // <br>    //  if the ACM *is* installed, then the version MUST be at least <br>    //  V2.00 for the API's to be available (earlier versions do not <br>    //  supply the API we need). <br>    // <br>    acmThunkInitialize(); <br> <br>    dwVersion = acmGetVersion(); <br>    if (0x0200 &lt;= HIWORD(dwVersion)) <br>    { <br>        MMRESULT        mmr; <br> <br>        gfAcmAvailable = TRUE; <br> <br>        mmr = acmDriverAdd(&amp;ghadidNotify, <br>                            ghinst, <br>                            (LPARAM)(UINT)hwnd, <br>                            WM_ACMAPP_ACM_NOTIFY, <br>                            ACM_DRIVERADDF_NOTIFYHWND); <br>        if (MMSYSERR_NOERROR != mmr) <br>        { <br>            DPF(0, "!AppCreate: acmDriverAdd failed to add notify window! mmr=%u", mmr); <br>        } <br>    } <br>    else <br>    { <br>        if (0L == dwVersion) <br>        { <br>            AppMsgBoxId(NULL, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL, <br>                        IDS_ERROR_ACM_NOT_PRESENT); <br>        } <br>        else <br>        { <br>            AppMsgBoxId(NULL, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL, <br>                        IDS_ERROR_ACM_TOO_OLD, <br>                        HIWORD(dwVersion) &gt;&gt; 8, <br>                        HIWORD(dwVersion) &amp; 0x00FF); <br>        } <br> <br>        gfAcmAvailable = FALSE; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    AcmAppSettingsRestore(hwnd, nCmdShow); <br> <br>    // <br>    //  strip the command line.. <br>    // <br>    if (NULL != pszCmdLine) <br>    { <br>        while (('\0' != *pszCmdLine) &amp;&amp; (' ' == *pszCmdLine)) <br>            pszCmdLine++; <br>    } <br> <br>    // <br>    //  if there is a command line, assume it is a filename for a script <br>    //  and try to open it. otherwise, just initialize the script window. <br>    // <br>    if ((NULL != pszCmdLine) &amp;&amp; ('\0' != *pszCmdLine)) <br>    { <br>        // <br>        //  attempt to open the specified file.. <br>        // <br>        lstrcpy(paafd-&gt;szFilePath, pszCmdLine); <br>        f = AcmAppFileOpen(hwnd, paafd); <br>        if (f) <br>        { <br>            AppTitle(hwnd, paafd-&gt;szFileTitle); <br>            AcmAppDisplayFileProperties(hwnd, paafd); <br>        } <br>        else <br>        { <br>            // <br>            //  opening the command line file was untriumphant.. <br>            // <br>            AppMsgBoxId(hwnd, MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL, <br>                        IDS_ERROR_OPEN_FAILED, (LPSTR)paafd-&gt;szFilePath); <br> <br> <br>            paafd-&gt;szFilePath[0]  = '\0'; <br>            paafd-&gt;szFileTitle[0] = '\0'; <br>            AppFileNew(hwnd, paafd, FALSE); <br>        } <br>    } <br>    else <br>    { <br>        AppFileNew(hwnd, paafd, FALSE); <br>    } <br> <br>    return (TRUE); <br>} // AcmAppInit() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppExit <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>// <br>// <br>//  Return (BOOL): <br>// <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AcmAppExit <br>( <br>    void <br>) <br>{ <br>    acmThunkTerminate(); <br> <br>    return (TRUE); <br>} // AcmAppExit() <br> <br> <br>//==========================================================================; <br>// <br>//  Initialization and exit code... </code></pre>
<p>
</p>
<pre><code>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppRegisterPenApp <br>// <br>//  Description: <br>//      This function is used to register and de-register an application <br>//      as being 'Pen Enhanced.' If the Windows installation is Pen enabled <br>//      then this function allows the RC Manager to replace all 'Edit' <br>//      controls with 'HEdit' controls. <br>// <br>//      This function must be called to register the application BEFORE <br>//      creating any edit controls. <br>// <br>//  Arguments: <br>//      BOOL fRegister: If this argument is TRUE, the app is registered <br>//      with the RC Manager as being Pen aware. If this argument is FALSE <br>//      the app is de-registered. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if Windows for Pen Computing is installed <br>//      on the system. The return value is FALSE if the Windows installation <br>//      is not Pen enabled. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AppRegisterPenApp <br>( <br>    BOOL                    fRegister <br>) <br>{ <br>    #define RPA_DEFAULT     0x0001 <br> <br>    typedef void (FAR PASCAL *PENWINREGISTERPROC)(UINT, BOOL); <br> <br>    static char                 szRegPenApp[]   = "RegisterPenApp"; <br>    static PENWINREGISTERPROC   pfnRegPenApp    = NULL; <br> <br>    HINSTANCE   hinstPenWin; <br> <br>    // <br>    //  check if Windows for Pen Computing is installed--and if it is,  <br>    //  dyna-link to the RegisterPenApp() function. <br>    // <br>    //  if Pens are not supported, then return FALSE. <br>    // <br>    if (NULL == pfnRegPenApp) <br>    { <br>        hinstPenWin = (HINSTANCE)GetSystemMetrics(SM_PENWINDOWS); <br>        if (NULL == hinstPenWin) <br>            return (FALSE); <br> <br>        pfnRegPenApp = (PENWINREGISTERPROC)GetProcAddress(hinstPenWin, szRegPenApp); <br>        if (NULL == pfnRegPenApp) <br>            return (FALSE); <br>    } <br> <br>    // <br>    //  either enable or disable the RC Manager's Pen meathooks.. <br>    // <br>    (*pfnRegPenApp)(RPA_DEFAULT, fRegister); <br> <br>    return (TRUE); <br>} // AppRegisterPenApp() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCreate <br>// <br>//  Description: <br>//      This function is called to handle the WM_CREATE message for the <br>//      applications window. The application should finish the creation <br>//      of the window (create controls, allocate resources, etc). The <br>//      window has not been displayed (CreateWindow[Ex] has not returned). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to the window that is in the process of being <br>//      created. <br>// <br>//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info <br>//      about the window being created. <br>// <br>//  Return (LRESULT): <br>//      The return value should be nonzero if the application wishes to <br>//      let the window finish being created. A return of zero tells <br>//      CreateWindow[Ex] to fail the creation of the window. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppCreate <br>( <br>    HWND                    hwnd, <br>    LPCREATESTRUCT          pcs <br>) <br>{ <br>    static TCHAR        szEdit[]    = TEXT("edit"); <br> <br>    HWND                hedit; <br> <br>    DPF(1, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)", <br>            hwnd, pcs-&gt;x, pcs-&gt;y, pcs-&gt;cx, pcs-&gt;cy); <br> <br>    // <br>    //  create the driver selection listbox <br>    // <br>    hedit = CreateWindow(szEdit, gszNull, <br>                         ES_LEFT | ES_MULTILINE | WS_TABSTOP | <br>                         ES_AUTOVSCROLL | ES_AUTOHSCROLL | <br>                         ES_NOHIDESEL | WS_BORDER | WS_VSCROLL | WS_HSCROLL | <br>                         WS_VISIBLE | WS_CHILD | ES_READONLY, <br>                         0, 0, 0, 0, hwnd, (HMENU)IDD_ACMAPP_EDIT_DISPLAY, <br>                         pcs-&gt;hInstance, NULL); <br>    if (NULL == hedit) <br>        return (0L); <br> <br> <br>    // <br>    //  return nonzero to succeed the creation of the window <br>    // <br>    return (1L); <br>} // AppCreate() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppQueryEndSession <br>// <br>//  Description: <br>//      This function handles the WM_QUERYENDSESSION. This message is sent <br>//      by USER when ExitWindows has been called to end the Windows session. <br>//      This function can stop Windows from exiting if it is not convenient <br>//      for Windows to end. <br>// <br>//      Giving the user the option to save modified data before continueing <br>//      with the shutdown of Windows is a good idea. <br>// <br>//      Telling Windows to continue with the exit procedure does not <br>//      necessarily mean Windows will exit. All applications are queried <br>//      for shutdown approval. When the actual decision is made on whether <br>//      Windows will exit, WM_ENDSESSION will be sent with the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//  Return (LRESULT): <br>//      Returns zero to STOP Windows from exiting. Returns non-zero to <br>//      allows windows to shut down. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppQueryEndSession <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    BOOL                f; <br> <br>    DPF(1, "AppQueryEndSession(hwnd=%Xh)", hwnd); <br> <br>    // <br>    //  attempt to shut down--if this fails (user canceled it, etc) then <br>    //  do NOT allow the Windows to exit. <br>    // <br>    f = AcmAppShutdown(hwnd, &amp;gaafd); <br>    if (!f) <br>        return (0L); <br> <br> <br>    // <br>    //  tell Windows to proceed with the shutdown process! <br>    // <br>    return (1L); <br>} // AppQueryEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppEndSession <br>// <br>//  Description: <br>//      This function is called to handle the WM_ENDSESSION message. This <br>//      message is generated after the application answers the <br>//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION <br>//      message is to tell the application if Windows will be exiting <br>//      (TRUE  == fEndSession) or the end session was canceled by an <br>//      application (FALSE == fEndSession). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end <br>//      session was canceled. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. Note that an application <br>//      cannot halt the termination of Windows from this message--the <br>//      WM_QUERYENDSESSION is the only message that allows that behaviour. <br>//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it <br>//      or not. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppEndSession <br>( <br>    HWND                    hwnd, <br>    BOOL                    fEndSession <br>) <br>{ <br>    DPF(1, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession); <br> <br>    // <br>    //  we processed the message, return zero.. <br>    // <br>    return (0L); <br>} // AppEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppClose <br>// <br>//  Description: <br>//      This function handles the WM_CLOSE message for the application. <br>//      If the application should close, DestroyWindow() must be called <br>//      by this function. Otherwise the application will not close. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_CLOSE message. <br>// <br>//  Return (LRESULT): <br>//      There return value is zero. The DestroyWindow function will have <br>//      been called if the application should actually close. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppClose <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    HWND                hedit; <br>    HFONT               hfont; <br>    BOOL                f; <br> <br>    // <br>    //  if the Shift key is held down during the close message, then just <br>    //  save the current state but don't destroy the window... this is <br>    //  useful if the user does not want to exit the app and rerun it <br>    //  to make sure the state is saved--just before the user does something <br>    //  that may crash Windows or something.. <br>    // <br>    if (GetKeyState(VK_SHIFT) &lt; 0) <br>    { <br>        // <br>        //  save any settings that should be saved on app termination... <br>        // <br>        AcmAppSettingsSave(hwnd); <br>        return (0L); <br>    } <br> <br>    // <br>    //  attempt to shut down--if this fails (user canceled it, etc) then <br>    //  do NOT allow the window to be destroyed. <br>    // <br>    f = AcmAppShutdown(hwnd, &amp;gaafd); <br>    if (!f) <br>        return (0L); <br> <br> <br> <br>    // <br>    //  destroy the font we are using... before deleting the font, select <br>    //  the system font back into the window so the font won't be 'in use' <br>    //  anymore. <br>    // <br>    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY); <br> <br>    hfont = GetWindowFont(hedit); <br>    SetWindowFont(hedit, NULL, FALSE); <br>    DeleteFont(hfont); <br> <br>    ghfontApp = NULL; <br> <br>    // <br>    //  make the window close and terminate the application <br>    // <br>    DestroyWindow(hwnd); <br> <br>    return (0L); <br>} // AppClose() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppInit <br>// <br>//  Description: <br>//      This function is called to initialize a new instance of the <br>//      application. We want to parse our command line, create our window, <br>//      allocate resources, etc. <br>// <br>//      The arguments passed to this function are exactly the same as <br>//      those passed to WinMain. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      If the application is compiled for Unicode, then this argument is <br>//      ignored. <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (HWND): <br>//      Returns the newly created handle to the applications main window. <br>//      This handle is NULL if something went wrong and tells the application <br>//      to exit immediately. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>HWND FNGLOBAL AppInit <br>( <br>    HINSTANCE               hinst, <br>    HINSTANCE               hinstPrev, <br>    LPTSTR                  pszCmdLine, <br>    int                     nCmdShow <br>) <br>{ <br>    HWND                hwnd; <br>    WNDCLASS            wc; <br> <br>    DPF(1, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)", <br>            hinst, hinstPrev, pszCmdLine, nCmdShow); <br> <br>    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName)); <br>    LoadString(hinst, IDS_FILE_UNTITLED, gszFileUntitled, SIZEOF(gszFileUntitled)); <br> <br> <br>    // <br>    //  determine whether a new window class needs to be registered for <br>    //  this application. for Win 16, this only needs to be done for the <br>    //  first instance of the application created. for Win 32, this must <br>    //  be done for EVERY instance of the application. <br>    // <br>    if (NULL == hinstPrev) <br>    { <br>        wc.style         = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc   = (WNDPROC)AppWndProc; <br>        wc.cbClsExtra    = 0; <br>        wc.cbWndExtra    = 0; <br>        wc.hInstance     = hinst; <br>        wc.hIcon         = LoadIcon(hinst, ICON_APP); <br>        wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName  = MENU_APP; <br>        wc.lpszClassName = gszAppName; <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return (NULL); <br>    } <br> <br> <br>    // <br>    //  if Windows for Pen Computing is installed, then allow the RC <br>    //  Manager to replace all edit controls created from this point on <br>    //  with hedit controls <br>    // <br>    AppRegisterPenApp(TRUE); <br> <br> <br>    // <br>    //  create the application's main window <br>    // <br>    //  style bits available: <br>    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages <br>    //      WS_EX_DLGMODALFRAME :  creates window with double border <br>    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages <br>    //      WS_EX_TOPMOST       :  puts window in topmost space <br>    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only) <br>    // <br>    hwnd = CreateWindowEx(WS_EX_ACCEPTFILES | WS_EX_NOPARENTNOTIFY, <br>                          gszAppName, <br>                          gszAppName, <br>                          WS_OVERLAPPEDWINDOW, <br>                          APP_WINDOW_XOFFSET, <br>                          APP_WINDOW_YOFFSET, <br>                          APP_WINDOW_WIDTH, <br>                          APP_WINDOW_HEIGHT, <br>                          NULL, <br>                          NULL, <br>                          hinst, <br>                          NULL); <br> <br>    if (NULL == hwnd) <br>        return (NULL); <br> <br> <br>#ifdef UNICODE <br>    // <br>    //  GetCommandLine() returns a pointer to our command line. but this <br>    //  command line includes the complete command line used to launch <br>    //  the application--which is different than the pszCmdLine argument <br>    //  passed through WinMain()... <br>    // <br>    //  so, skip over the command name to get to the argument string <br>    // <br>    pszCmdLine = GetCommandLine(); <br>    if (NULL != pszCmdLine) <br>    { <br>        while (('\0' != *pszCmdLine) &amp;&amp; (' ' != *pszCmdLine++)) <br>            ; <br>    } <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    AcmAppInit(hwnd, &amp;gaafd, pszCmdLine, nCmdShow); <br> <br> <br>    // <br>    //  finally, get the window displayed and return success <br>    // <br>    //  the ShowWindow call is made during AcmAppInit <br>    // <br>//  ShowWindow(hwnd, nCmdShow); <br>//  UpdateWindow(hwnd); <br> <br>    return (hwnd); <br>} // AppInit() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppExit <br>// <br>//  Description: <br>//      This function is called just before the application exits from <br>//      WinMain. Its purpose is to clean up any resources that were allocated <br>//      for running the application: brushes, heaps, etc.. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application that is exiting. <br>// <br>//      int nResult: The result of the WM_QUIT message (in wParam of the <br>//      MSG structure. This argument will usually be 0 (even if the message <br>//      loop was never entered). <br>// <br>//  Return (int): <br>//      The return value is usually nResult--be we give this function the <br>//      opportunity to modify its value. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNGLOBAL AppExit <br>( <br>    HINSTANCE               hinst, <br>    int                     nResult <br>) <br>{ <br>    DPF(1, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult); <br> <br>    AcmAppExit(); <br> <br>    // <br>    //  if Windows for Pen Computing is installed, then de-register the <br>    //  application so the RC Manager knows we will no longer need its <br>    //  services... <br>    // <br>    AppRegisterPenApp(FALSE); <br> <br>    return (nResult); <br>} // AppExit() <br> <br> <br>//==========================================================================; <br>// <br>//  Misc rarely used application dialogs and stuff... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AboutDlgProc <br>// <br>//  Description: <br>//      This dialog procedure is used for the ubiquitous about box. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AboutDlgProc <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    UINT                u; <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            u = GET_WM_COMMAND_ID(wParam, lParam); <br>            if ((IDOK == u) || (IDCANCEL == u)) <br>            { <br>                EndDialog(hwnd, (IDOK == u)); <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // AboutDlgProc() </code></pre>
<p>&nbsp;</p></body>
</HTML>
