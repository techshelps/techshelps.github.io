<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACMAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2460"></a>ACMAPP.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  acmapp.c <br>// <br>//  Description: <br>//      This is a sample application that demonstrates how to use the  <br>//      Audio Compression Manager API's in Windows. This application is <br>//      also useful as an ACM driver test. <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;mmreg.h&gt; <br>#include &lt;msacm.h&gt; <br> <br>#include "appport.h" <br>#include "acmapp.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>//  globals, no less <br>// <br>HINSTANCE       ghinst; <br>BOOL            gfAcmAvailable; <br>UINT            gfuAppOptions       = APP_OPTIONSF_AUTOOPEN; <br>HFONT           ghfontApp; <br>HACMDRIVERID    ghadidNotify; <br> <br>UINT            guWaveInId          = (UINT)WAVE_MAPPER; <br>UINT            guWaveOutId         = (UINT)WAVE_MAPPER; <br> <br>TCHAR           gszNull[]           = TEXT(""); <br>TCHAR           gszAppProfile[]     = TEXT("acmapp.ini"); <br>TCHAR           gszYes[]            = TEXT("Yes"); <br>TCHAR           gszNo[]             = TEXT("No"); <br> <br>TCHAR           gszAppName[APP_MAX_APP_NAME_CHARS]; <br>TCHAR           gszFileUntitled[APP_MAX_FILE_TITLE_CHARS]; <br> <br>TCHAR           gszInitialDirOpen[APP_MAX_FILE_PATH_CHARS]; <br>TCHAR           gszInitialDirSave[APP_MAX_FILE_PATH_CHARS]; <br> <br>TCHAR           gszLastSaveFile[APP_MAX_FILE_PATH_CHARS]; <br> <br>ACMAPPFILEDESC  gaafd; <br> <br> <br>//==========================================================================; <br>// <br>//  Application helper functions <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBox <br>// <br>//  Description: <br>//      This function displays a message for the application in a standard <br>//      message box. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      PTSTR pszFormat: Format string used for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() function. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBox <br>( <br>    HWND                    hwnd, <br>    UINT                    fuStyle, <br>    PTSTR                   pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[1024]; <br>    int         n; <br> <br>    // <br>    //  format and display the message.. <br>    // <br>    va_start(va, pszFormat); <br>#ifdef WIN32 <br>    wvsprintf(ach, pszFormat, va); <br>#else <br>    wvsprintf(ach, pszFormat, (LPSTR)va); <br>#endif <br>    va_end(va); <br> <br>    n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br> <br>    return (n); <br>} // AppMsgBox() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBoxId <br>// <br>//  Description: <br>//      This function displays a message for the application. The message <br>//      text is retrieved from the string resource table using LoadString. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      UINT uIdsFormat: String resource id to be loaded with LoadString() <br>//      and used a the format string for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() if the string <br>//      resource specified by uIdsFormat is valid. The return value is zero <br>//      if the string resource failed to load. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBoxId <br>( <br>    HWND                    hwnd, <br>    UINT                    fuStyle, <br>    UINT                    uIdsFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat)); <br>    if (0 != n) <br>    { <br>        // <br>        //  format and display the message.. <br>        // <br>        va_start(va, uIdsFormat); <br>#ifdef WIN32 <br>        wvsprintf(ach, szFormat, va); <br>#else <br>        wvsprintf(ach, szFormat, (LPSTR)va); <br>#endif <br>        va_end(va); <br> <br>        n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br>    } <br> <br>    return (n); <br>} // AppMsgBoxId() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void AppHourGlass <br>// <br>//  Description: <br>//      This function changes the cursor to that of the hour glass or <br>//      back to the previous cursor. <br>// <br>//      This function can be called recursively. <br>// <br>//  Arguments: <br>//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need <br>//      the arrow back. <br>// <br>//  Return (void): <br>//      On return, the cursor will be what was requested. <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNGLOBAL AppHourGlass <br>( <br>    BOOL                    fHourGlass <br>) <br>{ <br>    static HCURSOR  hcur; <br>    static UINT     uWaiting = 0; <br> <br>    if (fHourGlass) <br>    { <br>        if (!uWaiting) <br>        { <br>            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>            ShowCursor(TRUE); <br>        } <br> <br>        uWaiting++; <br>    } <br>    else <br>    { <br>        --uWaiting; <br> <br>        if (!uWaiting) <br>        { <br>            ShowCursor(FALSE); <br>            SetCursor(hcur); <br>        } <br>    } <br>} // AppHourGlass() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppYield <br>// <br>//  Description: <br>//      This function yields by dispatching all messages stacked up in the <br>//      application queue. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window of application if not yielding <br>//      for a dialog. Handle to dialog box if yielding for a dialog box. <br>// <br>//      BOOL fIsDialog: TRUE if being called to yield for a dialog box. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppYield <br>( <br>    HWND                    hwnd, <br>    BOOL                    fIsDialog <br>) <br>{ <br>    MSG     msg; <br> <br>    if (fIsDialog) <br>    { <br>        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            if ((NULL == hwnd) || !IsDialogMessage(hwnd, &amp;msg)) <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br>    } <br> <br>    return (TRUE); <br>} // AppYield() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowText <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      PTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowText <br>( <br>    HWND                    hwnd, <br>    PTSTR                   pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the string in the window... <br>    // <br>    va_start(va, pszFormat); <br>#ifdef WIN32 <br>    n = wvsprintf(ach, pszFormat, va); <br>#else <br>    n = wvsprintf(ach, pszFormat, (LPSTR)va); <br>#endif <br>    va_end(va); <br> <br>    SetWindowText(hwnd, ach); <br> <br>    return (n); <br>} // AppSetWindowText() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowTextId <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. The format string is extracted from the string <br>//      table using LoadString() on the uIdsFormat argument. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      UINT uIdsFormat: String resource id to be loaded with LoadString() <br>//      and used a the format string for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. This value is zero if the LoadString() function fails <br>//      for the uIdsFormat argument. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowTextId <br>( <br>    HWND                    hwnd, <br>    UINT                    uIdsFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat)); <br>    if (0 != n) <br>    { <br>        // <br>        //  format and display the string in the window... <br>        // <br>        va_start(va, uIdsFormat); <br>#ifdef WIN32 <br>        n = wvsprintf(ach, szFormat, va); <br>#else <br>        n = wvsprintf(ach, szFormat, (LPSTR)va); <br>#endif <br>        va_end(va); <br> <br>        SetWindowText(hwnd, ach); <br>    } <br> <br>    return (n); <br>} // AppSetWindowTextId() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppFormatBigNumber <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      LPTSTR pszNumber: <br>//   <br>//      DWORD dw: <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppFormatBigNumber <br>( <br>    LPTSTR                  pszNumber, <br>    DWORD                   dw <br>) <br>{ <br>    // <br>    //  this is ugly... <br>    // <br>    // <br>    if (dw &gt;= 1000000000L) <br>    { <br>        wsprintf(pszNumber, TEXT("%u,%03u,%03u,%03u"), <br>                            (WORD)(dw / 1000000000L), <br>                            (WORD)((dw % 1000000000L) / 1000000L), <br>                            (WORD)((dw % 1000000L) / 1000), <br>                            (WORD)(dw % 1000)); <br>    } <br>    else if (dw &gt;= 1000000L) <br>    { <br>        wsprintf(pszNumber, TEXT("%u,%03u,%03u"), <br>                            (WORD)(dw / 1000000L), <br>                            (WORD)((dw % 1000000L) / 1000), <br>                            (WORD)(dw % 1000)); <br>    } <br>    else if (dw &gt;= 1000) <br>    { <br>        wsprintf(pszNumber, TEXT("%u,%03u"), <br>                            (WORD)(dw / 1000), <br>                            (WORD)(dw % 1000)); <br>    } <br>    else <br>    { <br>        wsprintf(pszNumber, TEXT("%lu"), dw); <br>    } <br> <br> <br>    return (TRUE); <br>} // AppFormatBigNumber() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppFormatDosDateTime <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      LPTSTR pszDateTime: <br>//   <br>//      UINT uDosDate: <br>//   <br>//      UINT uDosTime: <br>//   <br>//  Return (BOOL): <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppFormatDosDateTime <br>( <br>    LPTSTR                  pszDateTime, <br>    UINT                    uDosDate, <br>    UINT                    uDosTime <br>) <br>{ <br>    static TCHAR        szFormatDateTime[]  = TEXT("%.02u/%.02u/%.02u  %.02u:%.02u:%.02u"); <br> <br>    UINT                uDateMonth; <br>    UINT                uDateDay; <br>    UINT                uDateYear; <br>    UINT                uTimeHour; <br>    UINT                uTimeMinute; <br>    UINT                uTimeSecond; <br> <br>    // <br>    // <br>    // <br>    uTimeHour   = uDosTime &gt;&gt; 11; <br>    uTimeMinute = (uDosTime &amp; 0x07E0) &gt;&gt; 5; <br>    uTimeSecond = (uDosTime &amp; 0x001F) &lt;&lt; 1; <br> <br>    uDateMonth  = (uDosDate &amp; 0x01E0) &gt;&gt; 5; <br>    uDateDay    = (uDosDate &amp; 0x001F); <br>    uDateYear   = (uDosDate &gt;&gt; 9) + 80; <br> <br>    // <br>    // <br>    // <br>    // <br>    wsprintf(pszDateTime, szFormatDateTime, <br>             uDateMonth, <br>             uDateDay, <br>             uDateYear, <br>             uTimeHour, <br>             uTimeMinute, <br>             uTimeSecond); <br> <br>    return (TRUE); <br>} // AppFormatDosDateTime() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void AcmAppDebugLog <br>// <br>//  Description: <br>//      This function logs information to the debugger if the Debug Log <br>//      option is set. You can then run DBWin (or something similar) <br>//      to redirect the output whereever you want. Very useful for debugging <br>//      ACM drivers. <br>// <br>//  Arguments: <br>//      PTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (void): <br>//      None. <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNCGLOBAL AcmAppDebugLog <br>( <br>    PTSTR                   pszFormat, <br>    ... <br>) <br>{ <br>    static  TCHAR   szDebugLogSeparator[] = TEXT("=============================================================================\r\n"); <br> <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br> <br> <br>    // <br>    //  !!! UNICODE !!! <br>    // <br>    // <br>    if (0 != (APP_OPTIONSF_DEBUGLOG &amp; gfuAppOptions)) <br>    { <br>        if (NULL == pszFormat) <br>        { <br>            OutputDebugString(szDebugLogSeparator); <br>            return; <br>        } <br> <br>        // <br>        //  format and display the string in a message box... <br>        // <br>        va_start(va, pszFormat); <br>#ifdef WIN32 <br>        wvsprintf(ach, pszFormat, va); <br>#else <br>        wvsprintf(ach, pszFormat, (LPSTR)va); <br>#endif <br>        va_end(va); <br> <br>        OutputDebugString(ach); <br>    } <br>} // AcmAppDebugLog() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  int MEditPrintF <br>//   <br>//  Description: <br>//      This function is used to print formatted text into a Multiline <br>//      Edit Control as if it were a standard console display. This is <br>//      a very easy way to display small amounts of text information <br>//      that can be scrolled and copied to the clip-board. <br>//   <br>//  Arguments: <br>//      HWND hedit: Handle to a Multiline Edit control. <br>//   <br>//      PTSTR pszFormat: Pointer to any valid format for wsprintf. If <br>//      this argument is NULL, then the Multiline Edit Control is cleared <br>//      of all text. <br>// <br>// <br>//  Return (int): <br>//      Returns the number of characters written into the edit control. <br>// <br>//  Notes: <br>//      The pszFormat string can contain combinations of escapes that  <br>//      modify the default behaviour of this function. Escapes are single <br>//      character codes placed at the _beginning_ of the format string. <br>// <br>//      Current escapes defined are: <br>// <br>//      ~   :   Suppresses the default CR/LF added to the end of the  <br>//              printed line. Since the most common use of this function <br>//              is to output a whole line of text with a CR/LF, that is <br>//              the default. <br>// <br>//      `   :   Suppresses logging to the debug terminal (regardless of <br>//              the global debug log options flag). <br>// <br>//   <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL MEditPrintF <br>( <br>    HWND                    hedit, <br>    PTSTR                   pszFormat, <br>    ... <br>) <br>{ <br>    static  TCHAR   szCRLF[]              = TEXT("\r\n"); <br> <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    int         n; <br>    BOOL        fCRLF; <br>    BOOL        fDebugLog; <br> <br>    // <br>    //  default the escapes <br>    // <br>    fCRLF     = TRUE; <br>    fDebugLog = TRUE; <br> <br> <br>    // <br>    //  if the pszFormat argument is NULL, then just clear all text in <br>    //  the edit control.. <br>    // <br>    if (NULL == pszFormat) <br>    { <br>        SetWindowText(hedit, gszNull); <br> <br>        AcmAppDebugLog(NULL); <br> <br>        return (0); <br>    } <br> <br>    // <br>    //  format and display the string in the window... first search for <br>    //  escapes to modify default behaviour. <br>    // <br>    for (;;) <br>    { <br>        switch (*pszFormat) <br>        { <br>            case '~': <br>                fCRLF = FALSE; <br>                pszFormat++; <br>                continue; <br> <br>            case '`': <br>                fDebugLog = FALSE; <br>                pszFormat++; <br>                continue; <br>        } <br> <br>        break; <br>    } <br> <br>    va_start(va, pszFormat); <br>#ifdef WIN32 <br>    n = wvsprintf(ach, pszFormat, va); <br>#else <br>    n = wvsprintf(ach, pszFormat, (LPSTR)va); <br>#endif <br>    va_end(va); <br> <br>    Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1); <br>    Edit_ReplaceSel(hedit, ach); <br> <br>    if (fDebugLog) <br>    { <br>        AcmAppDebugLog(ach); <br>    } <br> <br>    if (fCRLF) <br>    { <br>        Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1); <br>        Edit_ReplaceSel(hedit, szCRLF); <br> <br>        if (fDebugLog) <br>        { <br>            AcmAppDebugLog(szCRLF); <br>        } <br>    } <br> <br>    return (n); <br>} // MEditPrintF() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppGetFileTitle <br>// <br>//  Description: <br>//      This function extracts the file title from a file path and returns <br>//      it in the caller's specified buffer. <br>// <br>//  Arguments: <br>//      PTSTR pszFilePath: Pointer to null terminated file path. <br>// <br>//      PTSTR pszFileTitle: Pointer to buffer to receive the file title. <br>// <br>//  Return (BOOL): <br>//      Always returns TRUE. But should return FALSE if this function <br>//      checked for bogus values, etc. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppGetFileTitle <br>( <br>    PTSTR                   pszFilePath, <br>    PTSTR                   pszFileTitle <br>) <br>{ <br>    #define IS_SLASH(c)     ('/' == (c) || '\\' == (c)) <br> <br>    PTSTR       pch; <br> <br>    // <br>    //  scan to the end of the file path string.. <br>    // <br>    for (pch = pszFilePath; '\0' != *pch; pch++) <br>        ; <br> <br>    // <br>    //  now scan back toward the beginning of the string until a slash (\), <br>    //  colon, or start of the string is encountered. <br>    // <br>    while ((pch &gt;= pszFilePath) &amp;&amp; !IS_SLASH(*pch) &amp;&amp; (':' != *pch)) <br>    { <br>        pch--; <br>    } <br> <br>    // <br>    //  finally, copy the 'title' into the destination buffer.. skip ahead <br>    //  one char since the above loop steps back one too many chars... <br>    // <br>    lstrcpy(pszFileTitle, ++pch); <br> <br>    return (TRUE); <br>} // AppGetFileTitle() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppGetFileName <br>// <br>//  Description: <br>//      This function is a wrapper for the Get[Open/Save]FileName commdlg <br>//      chooser dialogs. Based on the fuFlags argument, this function will <br>//      display the appropriate chooser dialog and return the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for chooser dialog. <br>// <br>//      PTSTR pszFilePath: Pointer to buffer to receive the file path. <br>// <br>//      PTSTR pszFileTitle: Pointer to buffer to receive the file title. <br>//      This argument may be NULL, in which case no title will be returned. <br>// <br>//      UINT fuFlags: <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a file was chosen. It is FALSE if the <br>//      user canceled the operation. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppGetFileName <br>( <br>    HWND                    hwnd, <br>    PTSTR                   pszFilePath, <br>    PTSTR                   pszFileTitle, <br>    UINT                    fuFlags <br>) <br>{ <br>    #define APP_OFN_FLAGS_SAVE  (OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT) <br>    #define APP_OFN_FLAGS_OPEN  (OFN_HIDEREADONLY | OFN_FILEMUSTEXIST) <br> <br>    TCHAR               szExtDefault[APP_MAX_EXT_DEFAULT_CHARS]; <br>    TCHAR               szExtFilter[APP_MAX_EXT_FILTER_CHARS]; <br>    OPENFILENAME        ofn; <br>    BOOL                f; <br>    PTCHAR              pch; <br> <br> <br>    // <br>    //  get the extension filter and default extension for this application <br>    // <br>    LoadString(ghinst, IDS_OFN_EXT_DEF, szExtDefault, SIZEOF(szExtDefault)); <br>    LoadString(ghinst, IDS_OFN_EXT_FILTER, szExtFilter, SIZEOF(szExtFilter)); <br> <br> <br>    // <br>    //  NOTE! building the filter string for the OPENFILENAME structure <br>    //  is a bit more difficult when dealing with Unicode and C8's new <br>    //  optimizer. it joyfully removes literal '\0' characters from <br>    //  strings that are concatted together. if you try making each <br>    //  string separate (array of pointers to strings), the compiler <br>    //  will dword align them... etc, etc. <br>    // <br>    //  if you can think of a better way to build the silly filter string <br>    //  for common dialogs and still work in Win 16 and Win 32 [Unicode] <br>    //  i'd sure like to hear about it... <br>    // <br>    for (pch = &amp;szExtFilter[0]; '\0' != *pch; pch++) <br>    { <br>        if ('!' == *pch) <br>            *pch = '\0'; <br>    } <br> <br>    // <br>    //  initialize the OPENFILENAME members <br>    // <br>    memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br> <br>    pszFilePath[0]          = '\0'; <br>    if (pszFileTitle) <br>        pszFileTitle[0]     = '\0'; <br> <br>    ofn.lStructSize         = sizeof(OPENFILENAME); <br>    ofn.hwndOwner           = hwnd; <br>    ofn.lpstrFilter         = szExtFilter; <br>    ofn.lpstrCustomFilter   = NULL; <br>    ofn.nMaxCustFilter      = 0L; <br>    ofn.nFilterIndex        = 1L; <br>    ofn.lpstrFile           = pszFilePath; <br>    ofn.nMaxFile            = APP_MAX_FILE_PATH_CHARS; <br>    ofn.lpstrFileTitle      = pszFileTitle; <br>    ofn.nMaxFileTitle       = pszFileTitle ? APP_MAX_FILE_TITLE_CHARS : 0; <br>    if (fuFlags &amp; APP_GETFILENAMEF_SAVE) <br>    { <br>        ofn.lpstrInitialDir = gszInitialDirSave; <br>    } <br>    else <br>    { <br>        ofn.lpstrInitialDir = gszInitialDirOpen; <br>    } <br>    ofn.nFileOffset         = 0; <br>    ofn.nFileExtension      = 0; <br>    ofn.lpstrDefExt         = szExtDefault; <br> <br>    // <br>    //  if the fuFlags.APP_GETFILENAMEF_SAVE bit is set, then call <br>    //  GetSaveFileName() otherwise call GetOpenFileName(). why commdlg was <br>    //  designed with two separate functions for save and open only clark <br>    //  knows. <br>    // <br>    if (fuFlags &amp; APP_GETFILENAMEF_SAVE) <br>    { <br>        ofn.Flags = APP_OFN_FLAGS_SAVE; <br>        f = GetSaveFileName(&amp;ofn); <br>        if (f) <br>        { <br>            if (NULL != pszFilePath) <br>            { <br>                lstrcpy(gszInitialDirSave, pszFilePath); <br> <br>                pch = &amp;gszInitialDirSave[lstrlen(gszInitialDirSave) - 1]; <br>                for ( ; gszInitialDirSave != pch; pch--) <br>                { <br>                    if ('\\' == *pch) <br>                    { <br>                        *pch = '\0'; <br>                        break; <br>                    } <br>                } <br>            } <br>        } <br>    } <br>    else <br>    { <br>        ofn.Flags = APP_OFN_FLAGS_OPEN; <br>        f = GetOpenFileName(&amp;ofn); <br>        if (f) <br>        { <br>            if (NULL != pszFilePath) <br>            { <br>                lstrcpy(gszInitialDirOpen, pszFilePath); <br> <br>                pch = &amp;gszInitialDirOpen[lstrlen(gszInitialDirOpen) - 1]; <br>                for ( ; gszInitialDirOpen != pch; pch--) <br>                { <br>                    if ('\\' == *pch) <br>                    { <br>                        *pch = '\0'; <br>                        break; <br>                    } <br>                } <br>            } <br>        } <br>    } <br> <br>    return (f); <br>} // AppGetFileName() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppTitle <br>// <br>//  Description: <br>//      This function formats and sets the title text of the application's <br>//      window. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window to set title text for. <br>// <br>//      PTSTR pszFileTitle: Pointer to file title to display. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppTitle <br>( <br>    HWND                    hwnd, <br>    PTSTR                   pszFileTitle <br>) <br>{ <br>    static  TCHAR   szFormatTitle[]     = TEXT("%s - %s"); <br> <br>    TCHAR       ach[APP_MAX_FILE_PATH_CHARS]; <br> <br>    // <br>    //  format the title text as 'AppName - FileTitle' <br>    // <br>    wsprintf(ach, szFormatTitle, (LPSTR)gszAppName, (LPSTR)pszFileTitle); <br>    SetWindowText(hwnd, ach); <br> <br>    return (TRUE); <br>} // AppTitle() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppFileNew <br>// <br>//  Description: <br>//      This function is called to handle the IDM_FILE_NEW message. It is <br>//      responsible for clearing the working area for a new unnamed file. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to current file descriptor. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the working area was cleared and is <br>//      ready for new stuff. The return value is FALSE if the user canceled <br>//      the operation. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppFileNew <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd, <br>    BOOL                    fCreate <br>) <br>{ <br>    BOOL                f; <br> <br>    if (fCreate) <br>    { <br>        f = AcmAppFileNew(hwnd, paafd); <br>        if (!f) <br>            return (FALSE); <br>    } <br>    else <br>    { <br>        // <br>        //  if there is currently a file path, then we have to do some real <br>        //  work... <br>        // <br>        if ('\0' != paafd-&gt;szFilePath[0]) <br>        { <br>            f = AcmAppFileNew(hwnd, paafd); <br>            if (!f) <br>                return (FALSE); <br>        } <br> <br>        // <br>        //  blow away the old file path and title; set the window title <br>        //  and return success <br>        // <br>        lstrcpy(paafd-&gt;szFilePath, gszFileUntitled); <br>        lstrcpy(paafd-&gt;szFileTitle, gszFileUntitled); <br>    } <br> <br>    AppTitle(hwnd, paafd-&gt;szFileTitle); <br> <br>    AcmAppDisplayFileProperties(hwnd, paafd); <br> <br>    return (TRUE); <br>} // AppFileNew() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppFileOpen <br>// <br>//  Description: <br>//      This function handles the IDM_FILE_OPEN message. It is responsible <br>//      for getting a new file name from the user and opening that file <br>//      if possible. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to current file descriptor. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a new file was selected and opened. <br>//      It is FALSE if the user canceled the operation. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL AppFileOpen <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd <br>) <br>{ <br>    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS]; <br>    BOOL                f; <br> <br>    // <br>    //  first test for a modified file that has not been saved. if the <br>    //  return value is FALSE we should cancel the File.Open operation. <br>    // <br>    f = AcmAppFileSaveModified(hwnd, paafd); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    // <br>    //  get the file name of the new file into temporary buffers (so <br>    //  if we fail to open it we can back out cleanly). <br>    // <br>    f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_OPEN); <br>    if (!f) <br>        return (FALSE); <br> <br> <br>    //!!! <br>    //  read the new file... <br>    // <br>    lstrcpy(paafd-&gt;szFilePath, szFilePath); <br>    lstrcpy(paafd-&gt;szFileTitle, szFileTitle); </code></pre>
<p>
</p>
<pre><code><br>    f = AcmAppFileOpen(hwnd, paafd); <br>    if (f) <br>    { <br>        // <br>        //  set the window title text... <br>        // <br>        AppTitle(hwnd, szFileTitle); <br>        AcmAppDisplayFileProperties(hwnd, paafd); <br>    } <br> <br>    return (f); <br>} // AppFileOpen() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppFileSave <br>// <br>//  Description: <br>//      This function handles the IDM_FILE_SAVE[AS] messages. It is <br>//      responsible for saving the current file. If a file name needs <br>//      to be specified then the save file dialog is displayed. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to application window. <br>// <br>//      PACMAPPFILEDESC paafd: Pointer to current file descriptor. <br>// <br>//      BOOL fSaveAs: TRUE if the save file chooser should be displayed <br>//      before saving the file. FALSE if should operate like File.Save. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the file was saved. It is FALSE if the <br>//      user canceled the operation or the file does not need saved. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppFileSave <br>( <br>    HWND                    hwnd, <br>    PACMAPPFILEDESC         paafd, <br>    BOOL                    fSaveAs <br>) <br>{ <br>    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    TCHAR               szFileTitle[APP_MAX_FILE_TITLE_CHARS]; <br>    BOOL                f; <br> <br>    // <br>    // <br>    // <br>    lstrcpy(szFilePath, paafd-&gt;szFilePath); <br>    lstrcpy(szFileTitle, paafd-&gt;szFileTitle); <br> <br> <br>    // <br>    //  check if we should bring up the save file chooser dialog... <br>    // <br>    if (fSaveAs || (0 == lstrcmp(paafd-&gt;szFileTitle, gszFileUntitled))) <br>    { <br>        // <br>        //  get the file name for saving the data to into temporary <br>        //  buffers (so if we fail to save it we can back out cleanly). <br>        // <br>        f = AppGetFileName(hwnd, szFilePath, szFileTitle, APP_GETFILENAMEF_SAVE); <br>        if (!f) <br>            return (FALSE); <br>    } <br> <br>    // <br>    //  save the file... <br>    // <br>    f = AcmAppFileSave(hwnd, paafd, szFilePath, szFileTitle, 0); <br>    if (f) <br>    { <br>        // <br>        //  changes have been saved, so clear the modified bit... <br>        // <br>        paafd-&gt;fdwState &amp;= ~ACMAPPFILEDESC_STATEF_MODIFIED; <br> <br>        AppTitle(hwnd, paafd-&gt;szFileTitle); <br> <br>        AcmAppDisplayFileProperties(hwnd, paafd); <br>    } <br> <br>    return (f); <br>} // AppFileSave() <br> <br> <br>//==========================================================================; <br>// <br>//  Main application window handling code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppInitMenuPopup <br>// <br>//  Description: <br>//      This function handles the WM_INITMENUPOPUP message. This message <br>//      is sent to the window owning the menu that is going to become <br>//      active. This gives an application the ability to modify the menu <br>//      before it is displayed (disable/add items, etc). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP <br>//      message. <br>// <br>//      HMENU hmenu: Handle to the menu that is to become active. <br>// <br>//      int nItem: Specifies the zero-based relative position of the menu <br>//      item that invoked the popup menu. <br>// <br>//      BOOL fSysMenu: Specifies whether the popup menu is a System menu <br>//      (TRUE) or it is not a System menu (FALSE). <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppInitMenuPopup <br>( <br>    HWND                    hwnd, <br>    HMENU                   hmenu, <br>    int                     nItem, <br>    BOOL                    fSysMenu <br>) <br>{ <br>    BOOL                f; <br>    int                 nSelStart; <br>    int                 nSelEnd; <br>    HWND                hedit; <br> <br>    DPF(4, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)", <br>            hwnd, hmenu, nItem, fSysMenu); <br> <br>    // <br>    //  if the system menu is what got hit, succeed immediately... this <br>    //  application has no stuff in the system menu. <br>    // <br>    if (fSysMenu) <br>        return (0L); <br> <br>    // <br>    //  initialize the menu that is being 'popped up' <br>    // <br>    switch (nItem) <br>    { <br>        case APP_MENU_ITEM_FILE: <br>            EnableMenuItem(hmenu, IDM_FILE_NEW, <br>                           (UINT)(gfAcmAvailable ? MF_ENABLED : MF_GRAYED)); <br> <br>            f = (NULL != gaafd.pwfx); <br>            EnableMenuItem(hmenu, IDM_FILE_SNDPLAYSOUND_PLAY, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hmenu, IDM_FILE_SNDPLAYSOUND_STOP, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            f = (NULL != gaafd.pwfx) &amp;&amp; gfAcmAvailable; <br>            EnableMenuItem(hmenu, IDM_FILE_CONVERT, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hmenu, IDM_FILE_CONVERT_ALL, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br> <br>            // <br>            //  if the file has been modified, then enable the File.Save <br>            //  menu <br>            // <br>            f = (0 != (gaafd.fdwState &amp; ACMAPPFILEDESC_STATEF_MODIFIED)); <br>            EnableMenuItem(hmenu, IDM_FILE_SAVE, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            // f = (NULL != gaafd.pwfx); <br>            EnableMenuItem(hmenu, IDM_FILE_SAVEAS, <br>                           (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            break; <br> <br>        case APP_MENU_ITEM_EDIT: <br>            // <br>            //  check to see if something is selected in the display <br>            //  window and enable/disable Edit menu options appropriately <br>            // <br>            hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY); <br>            Edit_GetSelEx(hedit, &amp;nSelStart, &amp;nSelEnd); <br> <br>            f = (nSelStart != nSelEnd); <br>            EnableMenuItem(hmenu, WM_COPY,  (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            break; <br> <br>        case APP_MENU_ITEM_VIEW: <br>            EnableMenuItem(hmenu, IDM_VIEW_ACM_DRIVERS, <br>                           (UINT)(gfAcmAvailable ? MF_ENABLED : MF_GRAYED)); <br>            break; <br> <br> <br>        case APP_MENU_ITEM_OPTIONS: <br>            f = (0 != waveInGetNumDevs()); <br>            EnableMenuItem(hmenu, IDM_OPTIONS_WAVEINDEVICE,  (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            f = (0 != waveOutGetNumDevs()); <br>            EnableMenuItem(hmenu, IDM_OPTIONS_WAVEOUTDEVICE, (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            // <br>            //  make sure the options that need a checkmark are checked.. <br>            // <br>            f = (0 != (APP_OPTIONSF_AUTOOPEN &amp; gfuAppOptions)); <br>            CheckMenuItem(hmenu, IDM_OPTIONS_AUTOOPEN, <br>                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br> <br>            f = (0 != (APP_OPTIONSF_DEBUGLOG &amp; gfuAppOptions)); <br>            CheckMenuItem(hmenu, IDM_OPTIONS_DEBUGLOG, <br>                          (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br>            break; <br>    } <br> <br>    // <br>    //  we processed the message--return 0... <br>    // <br>    return (0L); <br>} // AppInitMenuPopup() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCommand <br>// <br>//  Description: <br>//      This function handles the WM_COMMAND message. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window receiving the WM_COMMAND message. <br>// <br>//      int nId: Control or menu item identifier. <br>// <br>//      HWND hwndCtl: Handle of control if the message is from a control. <br>//      This argument is NULL if the message was not generated by a control. <br>// <br>//      UINT uCode: Notification code. This argument is 1 if the message <br>//      was generated by an accelerator. If the message is from a menu, <br>//      this argument is 0. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppCommand <br>( <br>    HWND                    hwnd, <br>    int                     nId, <br>    HWND                    hwndCtl, <br>    UINT                    uCode <br>) <br>{ <br>    BOOL                f; <br>    DWORD               dw; <br>    UINT                uDevId; <br> <br>    switch (nId) <br>    { <br>        case IDM_FILE_NEW: <br>            AppFileNew(hwnd, &amp;gaafd, TRUE); <br>            break; <br> <br>        case IDM_FILE_OPEN: <br>            AppFileOpen(hwnd, &amp;gaafd); <br>            break; <br> <br>        case IDM_FILE_SAVE: <br>            AppFileSave(hwnd, &amp;gaafd, FALSE); <br>            break; <br> <br>        case IDM_FILE_SAVEAS: <br>            AppFileSave(hwnd, &amp;gaafd, TRUE); <br>            break; <br> <br> <br>        case IDM_FILE_SNDPLAYSOUND_PLAY: <br>            if (NULL == gaafd.pwfx) <br>            { <br>                MessageBeep((UINT)-1); <br>                break; <br>            } <br> <br>            AppHourGlass(TRUE); <br>            dw = timeGetTime(); <br>            f  = sndPlaySound(gaafd.szFilePath, SND_ASYNC | SND_NODEFAULT); <br>            dw = timeGetTime() - dw; <br>            AppHourGlass(FALSE); <br> <br>            if (0 != (APP_OPTIONSF_DEBUGLOG &amp; gfuAppOptions)) <br>            { <br>                AcmAppDebugLog(NULL); <br>                AcmAppDebugLog(TEXT("sndPlaySound(%s) took %lu milliseconds to %s.\r\n"), <br>                                (LPTSTR)gaafd.szFilePath, <br>                                dw, <br>                                f ? (LPTSTR)TEXT("succeed") : (LPTSTR)TEXT("fail")); <br>            } <br>             <br>            if (!f) <br>            { <br>                AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                          TEXT("The file '%s' cannot be played by sndPlaySound."), <br>                          (LPSTR)gaafd.szFilePath); <br>            } <br>            break; <br> <br>        case IDM_FILE_SNDPLAYSOUND_STOP: <br>            sndPlaySound(NULL, 0L); <br>            break; <br> <br>        case IDM_FILE_CONVERT: <br>            AcmAppFileConvert(hwnd, &amp;gaafd); <br>            break; <br> <br>        case IDM_FILE_CONVERT_ALL: <br>            AcmAppMultiThreadedConvertAll(hwnd, &amp;gaafd); <br>            break; <br> <br> <br>        case IDM_FILE_ABOUT: <br>            DialogBox(ghinst, DLG_ABOUT, hwnd, AboutDlgProc); <br>            break; <br> <br>        case IDM_FILE_EXIT: <br>            FORWARD_WM_CLOSE(hwnd, SendMessage); <br>            break; <br> <br> <br>        case WM_COPY: <br>            // <br>            //  pass on edit messages received to the display window <br>            // <br>            SendMessage(GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY), nId, 0, 0L); <br>            break; <br> <br>        case IDM_EDIT_SELECTALL: <br>            Edit_SetSel(GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY), 0, -1); <br>            break; <br> <br> <br>        case IDM_UPDATE: <br>            AcmAppFileOpen(hwnd, &amp;gaafd); <br> <br>            AcmAppDisplayFileProperties(hwnd, &amp;gaafd); <br>            break; <br> <br>        case IDM_VIEW_SYSTEMINFO: <br>            DialogBox(ghinst, DLG_AADETAILS, hwnd, AcmAppSystemInfoDlgProc); <br>            break; <br> <br>        case IDM_VIEW_ACM_DRIVERS: <br>            DialogBox(ghinst, DLG_AADRIVERS, hwnd, AcmAppDriversDlgProc); <br>            break; <br> <br> <br>        case IDM_OPTIONS_WAVEINDEVICE: <br>            uDevId = DialogBoxParam(ghinst, DLG_AAWAVEDEVICE, hwnd, <br>                                    AcmAppWaveDeviceDlgProc, <br>                                    MAKELONG((WORD)guWaveInId, TRUE)); <br> <br>            if (uDevId != guWaveInId) <br>            { <br>                guWaveInId = uDevId; <br>                AcmAppDisplayFileProperties(hwnd, &amp;gaafd); <br>            } <br>            break; <br> <br>        case IDM_OPTIONS_WAVEOUTDEVICE: <br>            uDevId = DialogBoxParam(ghinst, DLG_AAWAVEDEVICE, hwnd, <br>                                    AcmAppWaveDeviceDlgProc, <br>                                    MAKELONG((WORD)guWaveOutId, FALSE)); <br> <br>            if (uDevId != guWaveOutId) <br>            { <br>                guWaveOutId = uDevId; <br>                AcmAppDisplayFileProperties(hwnd, &amp;gaafd); <br>            } <br>            break; <br> <br> <br>        case IDM_OPTIONS_AUTOOPEN: <br>            gfuAppOptions ^= APP_OPTIONSF_AUTOOPEN; <br>            break; <br> <br>        case IDM_OPTIONS_DEBUGLOG: <br>            gfuAppOptions ^= APP_OPTIONSF_DEBUGLOG; <br>            break; <br> <br>        case IDM_OPTIONS_FONT: <br>            AcmAppChooseFont(hwnd); <br>            break; <br> <br> <br>        case IDM_PLAYRECORD: <br>            if (NULL == gaafd.pwfx) <br>            { <br>                f = AppFileNew(hwnd, &amp;gaafd, TRUE); <br>                if (!f) <br>                    break; <br> <br>                if (NULL == gaafd.pwfx) <br>                    break; <br>            } <br> <br>            f = DialogBoxParam(ghinst, DLG_AAPLAYRECORD, hwnd, <br>                               AcmAppPlayRecord, (LPARAM)(LPVOID)&amp;gaafd); <br>            if (f) <br>            { <br>                AcmAppFileOpen(hwnd, &amp;gaafd); <br> <br>                AcmAppDisplayFileProperties(hwnd, &amp;gaafd); <br>            } <br>            break; <br>    } <br> <br>    return (0L); <br>} // AppCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AcmAppDlgProcDragDropContinue <br>// <br>//  Description: <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AcmAppDlgProcDragDropContinue <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    UINT                uId; <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            AppSetWindowText(hwnd, TEXT("File %u of %u"), LOWORD(lParam), HIWORD(lParam)); <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            uId = GET_WM_COMMAND_ID(wParam, lParam); <br>            if ((IDOK == uId) || (IDCANCEL == uId)) <br>            { <br>                EndDialog(hwnd, uId); <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // AcmAppDlgProcDragDropContinue() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppDropFiles <br>// <br>//  Description: <br>//      This function handles the WM_DROPFILES message. This message is <br>//      sent when files are 'dropped' on the window from file manager <br>//      (or other drag/drop servers made by ISV's that figured out the <br>//      undocumented internal workings of the SHELL). <br>// <br>//      A window must be registered to receive these messages either by <br>//      called DragAcceptFiles() or using CreateWindowEx() with the <br>//      WS_EX_ACCEPTFILES style bit. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window receiving the message. <br>// <br>//      HDROP hdrop: Handle to drop structure. <br>// <br>//  Return (LRESULT): <br>//      Returns 0 if the message is processed. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppDropFiles <br>( <br>    HWND                    hwnd, <br>    HDROP                   hdrop <br>) <br>{ <br>    TCHAR               szFilePath[APP_MAX_FILE_PATH_CHARS]; <br>    UINT                cFiles; <br>    UINT                u; <br>    BOOL                f; <br>    int                 n; <br> <br>    // <br>    //  first test for a file that has not been saved. if the return <br>    //  value is FALSE we should cancel the drop operation. <br>    // <br>    f = AcmAppFileSaveModified(hwnd, &amp;gaafd); <br>    if (!f) <br>    { <br>        goto App_Drop_Files_Exit; <br>    } <br> <br>    // <br>    //  get number of files dropped on our window <br>    // <br>    cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0); <br> <br>    DPF(4, "AppDropFiles(hwnd=%Xh, hdrop=%Xh)--cFiles=%u", hwnd, hdrop, cFiles); <br> <br>    // <br>    //  step through each file and stop on the one the user wants or <br>    //  the last file (whichever comes first). <br>    // <br>    for (u = 0; u &lt; cFiles; u++) <br>    { <br>        // <br>        //  get the next file name and try to open it--if not a valid <br>        //  file, then skip to the next one (if there is one). <br>        // <br>        DragQueryFile(hdrop, u, szFilePath, SIZEOF(szFilePath)); <br> <br> <br>        // <br>        //  !!! destructive !!! <br>        // <br>        //  attempt to open the file <br>        // <br>        lstrcpy(gaafd.szFilePath, szFilePath); <br>        lstrcpy(gaafd.szFileTitle, gszNull); <br> <br>        f = AcmAppFileOpen(hwnd, &amp;gaafd); <br>        if (!f) <br>        { <br>            continue; <br>        } <br> <br>        AppTitle(hwnd, gaafd.szFileTitle); <br>        AcmAppDisplayFileProperties(hwnd, &amp;gaafd); <br> <br>        // <br>        //  if this is NOT the last file in the list of files that are <br>        //  being dropped on us, then bring up a box asking if we should <br>        //  continue or stop where we are.. <br>        // <br>        if ((cFiles - 1) != u) <br>        { <br>            n = DialogBoxParam(ghinst, <br>                               DLG_AADRAGDROP, <br>                               hwnd, <br>                               AcmAppDlgProcDragDropContinue, <br>                               MAKELPARAM((WORD)(u + 1), (WORD)cFiles)); <br>            if (IDCANCEL == n) <br>                break; <br>        } <br>    } <br> <br>    // <br>    //  tell the shell to release the memory it allocated for beaming <br>    //  the file name(s) over to us... return 0 to show we processed <br>    //  the message. <br>    // <br>App_Drop_Files_Exit: <br> <br>    DragFinish(hdrop); <br>    return (0L); <br>} // AppDropFiles() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppSize <br>// <br>//  Description: <br>//      This function handles the WM_SIZE message for the application's <br>//      window. This message is sent to the application window after the <br>//      size has changed (but before it is painted). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_SIZE message. <br>// <br>//      UINT fuSizeType: Specifies the type of resizing requested. This <br>//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED, <br>//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW. <br>// <br>//      int nWidth: Width of the new client area for the window. <br>// <br>//      int nHeight: Height of the new client area for the window. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the application processes the message. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppSize <br>( <br>    HWND                    hwnd, <br>    UINT                    fuSizeType, <br>    int                     nWidth, <br>    int                     nHeight <br>) <br>{ <br>    HWND                hedit; <br>    RECT                rc; <br> <br>    DPF(4, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)", <br>            hwnd, fuSizeType, nWidth, nHeight); <br> <br>    // <br>    //  unless this application is the one being resized then don't waste <br>    //  time computing stuff that doesn't matter. this applies to being <br>    //  minimized also because this application does not have a custom <br>    //  minimized state. <br>    // <br>    if ((SIZE_RESTORED != fuSizeType) &amp;&amp; (SIZE_MAXIMIZED != fuSizeType)) <br>        return (0L); <br> <br> <br>    // <br>    // <br>    // <br>    GetClientRect(hwnd, &amp;rc); <br>    InflateRect(&amp;rc, 1, 1); <br> <br>    hedit = GetDlgItem(hwnd, IDD_ACMAPP_EDIT_DISPLAY); <br>    SetWindowPos(hedit, <br>                 NULL, <br>                 rc.left, <br>                 rc.top, <br>                 rc.right - rc.left, <br>                 rc.bottom - rc.top, <br>                 SWP_NOZORDER); <br> <br> <br>    // <br>    //  we processed the message.. <br>    // <br>    return (0L); <br>} // AppSize() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  LRESULT AcmAppNotify <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//   <br>//  Return (LRESULT): <br>//   <br>//   <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AcmAppNotify <br>( <br>    HWND                hwnd, <br>    WPARAM              wParam, <br>    LPARAM              lParam <br>) <br>{ <br>    HWND                hwndNext; <br> <br>    DPF(1, "AcmAppNotify: hwnd=%.04Xh, wParam=%.04Xh, lParam2=%.08lXh", <br>        hwnd, wParam, lParam); <br> <br>    // <br>    // <br>    // <br>    hwndNext = GetWindow(hwnd, GW_HWNDFIRST); <br>    while (NULL != hwndNext) <br>    { <br>        if (GetParent(hwndNext) == hwnd) <br>        { <br>            SendMessage(hwndNext, WM_ACMAPP_ACM_NOTIFY, wParam, lParam); <br>        } <br> <br>        hwndNext = GetWindow(hwndNext, GW_HWNDNEXT); <br>    } <br> <br> <br>    // <br>    //  now force an update to our display in case driver [dis/en]able <br>    //  changed what is playable/recordable. <br>    // <br>    AcmAppDisplayFileProperties(hwnd, &amp;gaafd); <br> <br> <br>    // <br>    // <br>    // <br>    return (1L); <br>} // AcmAppNotify() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppWndProc <br>// <br>//  Description: <br>//      This is the main application window procedure. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (LRESULT): <br>//      The return value depends on the message that is being processed. <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNEXPORT AppWndProc <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    LRESULT             lr; <br> <br>    switch (uMsg) <br>    { <br>        case WM_CREATE: <br>            lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate); <br>            return (lr); <br> <br>        case WM_WININICHANGE: <br>            HANDLE_WM_WININICHANGE(hwnd, wParam, lParam, AppWinIniChange); <br>            return (0L); <br> <br>        case WM_INITMENUPOPUP: <br>            HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup); <br>            return (0L); <br> <br>        case WM_COMMAND: <br>            lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand); <br>            return (lr); <br> <br>        case WM_DROPFILES: <br>            // <br>            //  some windowsx.h files have a screwed up message cracker for <br>            //  WM_DROPFILES. because this is a sample app, i don't want <br>            //  people having trouble with bogus windowsx.h files, so crack <br>            //  the message manually... you should use the message cracker <br>            //  if you know your windowsx.h file is good. <br>            // <br>            //  lr = HANDLE_WM_DROPFILES(hwnd, wParam, lParam, AppDropFiles); <br>            // <br>            lr = AppDropFiles(hwnd, (HDROP)wParam); <br>            return (lr); <br> <br>        case WM_SIZE: <br>            // <br>            //  handle what we want for sizing, and then always call the <br>            //  default handler... <br>            // <br>            HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize); <br>            break; <br> <br>        case WM_QUERYENDSESSION: <br>            lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession); <br>            return (lr); <br> <br>        case WM_ENDSESSION: <br>            HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession); <br>            return (0L); <br> <br>        case WM_CLOSE: <br>            HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose); <br>            return (0L); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            return (0L); <br> <br>        case WM_ACMAPP_ACM_NOTIFY: <br>            AcmAppNotify(hwnd, wParam, lParam); <br>            return (0L); <br>    } <br> <br>    return (DefWindowProc(hwnd, uMsg, wParam, lParam)); <br>} // AppWndProc() <br> <br> <br>//==========================================================================; <br>// <br>//  Main entry and message dispatching code <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int WinMain <br>// <br>//  Description: <br>//      This function is called by the system as the initial entry point <br>//      for a Windows application. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      This string is strictly ANSI regardless of whether the application <br>//      is built for Unicode. To get the Unicode equivalent call the <br>//      GetCommandLine() function (Win 32 only). <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (int): <br>//      Returns result from WM_QUIT message (in wParam of MSG structure) if <br>//      the application is able to enter its message loop. Returns 0 if <br>//      the application is not able to enter its message loop. <br>// <br>//--------------------------------------------------------------------------; <br> <br>int PASCAL WinMain <br>( <br>    HINSTANCE               hinst, <br>    HINSTANCE               hinstPrev, <br>    LPSTR                   pszCmdLine, <br>    int                     nCmdShow <br>) <br>{ <br>    int                 nResult; <br>    HWND                hwnd; <br>    MSG                 msg; <br>    HACCEL              haccl; <br> <br>    DbgInitialize(TRUE); <br> <br>    // <br>    //  our documentation states that WinMain is supposed to return 0 if <br>    //  we do not enter our message loop--so assume the worst... <br>    // <br>    nResult = 0; <br> <br>    // <br>    //  make our instance handle global for convenience.. <br>    // <br>    ghinst = hinst; <br> <br>    // <br>    //  init some stuff, create window, etc.. note the explicit cast of <br>    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when <br>    //  compiling for Unicode. see AppInit() for more details. <br>    // <br>    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow); <br>    if (hwnd) <br>    { <br>        haccl = LoadAccelerators(hinst, ACCEL_APP); <br> <br>        // <br>        //  dispatch messages <br>        // <br>        while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>            // <br>            //  do all the special stuff required for this application <br>            //  when dispatching messages.. <br>            // <br>            if (!TranslateAccelerator(hwnd, haccl, &amp;msg)) <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>        // <br>        //  return result of WM_QUIT message. <br>        // <br>        nResult = (int)msg.wParam; <br>    } <br> <br>    // <br>    //  shut things down, clean up, etc. <br>    // <br>    nResult = AppExit(hinst, nResult); <br> <br>    return (nResult); <br>} // WinMain() <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
