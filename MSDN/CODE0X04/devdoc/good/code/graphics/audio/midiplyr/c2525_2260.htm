<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMFREAD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2538"></a>SMFREAD.C</h2>
<pre><code>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>****************************************************************************** <br>* <br>* SMFRead.C <br>* <br>* MIDI File access routines. <br>* <br>*****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;memory.h&gt; <br>#include "muldiv32.h"  <br>#include "smf.h" <br>#include "smfi.h" <br>#include "debug.h" <br> <br>PRIVATE UINT grbChanMsgLen[] = <br>{  <br>    0,                      /* 0x   not a status byte   */ <br>    0,                      /* 1x   not a status byte   */ <br>    0,                      /* 2x   not a status byte   */ <br>    0,                      /* 3x   not a status byte   */ <br>    0,                      /* 4x   not a status byte   */ <br>    0,                      /* 5x   not a status byte   */ <br>    0,                      /* 6x   not a status byte   */ <br>    0,                      /* 7x   not a status byte   */ <br>    3,                      /* 8x   Note off            */ <br>    3,                      /* 9x   Note on             */ <br>    3,                      /* Ax   Poly pressure       */ <br>    3,                      /* Bx   Control change      */ <br>    2,                      /* Cx   Program change      */ <br>    2,                      /* Dx   Chan pressure       */ <br>    3,                      /* Ex   Pitch bend change   */ <br>    0,                      /* Fx   SysEx (see below)   */              <br>} ; <br> <br>/****************************************************************************** <br>* <br>* smfBuildFileIndex <br>* <br>* Preliminary parsing of a MIDI file. <br>* <br>* ppSmf                     - Pointer to a returned SMF structure if the <br>*                             file is successfully parsed. <br>* <br>* Returns <br>*   SMF_SUCCESS The events were successfully read. <br>*   SMF_NO_MEMORY Out of memory to build key frames. <br>*   SMF_INVALID_FILE A disk or parse error occured on the file. <br>*  <br>* This function validates the format of and existing MIDI or RMI file <br>* and builds the handle structure which will refer to it for the <br>* lifetime of the instance. <br>*   <br>* The file header information will be read and verified, and <br>* smfBuildTrackIndices will be called on every existing track <br>* to build keyframes and validate the track format. <br>* <br>*****************************************************************************/ <br>SMFRESULT FNLOCAL smfBuildFileIndex( <br>    PSMF BSTACK *           ppSmf) <br>{ <br>    SMFRESULT               smfrc; <br>    UNALIGNED CHUNKHDR *    pCh; <br>    FILEHDR FAR *           pFh; <br>    DWORD                   idx; <br>    PSMF                    pSmf, <br>                            pSmfTemp; <br>    PTRACK                  pTrk; <br>    WORD                    wMemory; <br>    DWORD                   dwLeft; <br>    HPBYTE                  hpbImage; <br>     <br>    DWORD                   idxTrack; <br>    EVENT                   event; <br>    BOOL                    fFirst; <br>    DWORD                   dwLength; <br>    HLOCAL                  hLocal; <br>    PTEMPOMAPENTRY          pTempo; <br> <br>    assert(ppSmf != NULL); <br> <br>    pSmf = *ppSmf; <br> <br>    assert(pSmf != NULL); <br> <br>    /* MIDI data image is already in hpbImage (already extracted from <br>    ** RIFF header if necessary). <br>    */ <br> <br>    /* Validate MIDI header <br>    */ <br>    dwLeft   = pSmf-&gt;cbImage; <br>    hpbImage = pSmf-&gt;hpbImage; <br>     <br>    if (dwLeft &lt; sizeof(CHUNKHDR)) <br>        return SMF_INVALID_FILE; <br> <br>    pCh = (CHUNKHDR FAR *)hpbImage; <br> <br>    dwLeft   -= sizeof(CHUNKHDR); <br>    hpbImage += sizeof(CHUNKHDR); <br>     <br>    if (pCh-&gt;fourccType != FOURCC_MThd) <br>        return SMF_INVALID_FILE; <br> <br>    dwLength = DWORDSWAP(pCh-&gt;dwLength); <br>    if (dwLength &lt; sizeof(FILEHDR) || dwLength &gt; dwLeft) <br>        return SMF_INVALID_FILE; <br> <br>    pFh = (FILEHDR FAR *)hpbImage; <br> <br>    dwLeft   -= dwLength; <br>    hpbImage += dwLength; <br>     <br>    pSmf-&gt;dwFormat       = (DWORD)(WORDSWAP(pFh-&gt;wFormat)); <br>    pSmf-&gt;dwTracks       = (DWORD)(WORDSWAP(pFh-&gt;wTracks)); <br>    pSmf-&gt;dwTimeDivision = (DWORD)(WORDSWAP(pFh-&gt;wDivision)); <br> <br>    /* <br>    ** We've successfully parsed the header. Now try to build the track <br>    ** index. <br>    **  <br>    ** We only check out the track header chunk here; the track will be <br>    ** preparsed after we do a quick integretiy check. <br>    */ <br>    wMemory = sizeof(SMF) + (WORD)(pSmf-&gt;dwTracks*sizeof(TRACK)); <br>    pSmfTemp = (PSMF)LocalReAlloc((HLOCAL)pSmf, wMemory, LMEM_MOVEABLE|LMEM_ZEROINIT); <br> <br>    if (NULL == pSmfTemp) <br>    { <br>        DPF(1, "No memory for extended pSmf"); <br>        return SMF_NO_MEMORY; <br>    } <br> <br>    pSmf = *ppSmf = pSmfTemp; <br>    pTrk = pSmf-&gt;rTracks; <br>     <br>    for (idx=0; idx&lt;pSmf-&gt;dwTracks; idx++) <br>    { <br>        if (dwLeft &lt; sizeof(CHUNKHDR)) <br>            return SMF_INVALID_FILE; <br> <br>        pCh = (CHUNKHDR FAR *)hpbImage; <br> <br>        dwLeft   -= sizeof(CHUNKHDR); <br>        hpbImage += sizeof(CHUNKHDR); <br> <br>        if (pCh-&gt;fourccType != FOURCC_MTrk) <br>            return SMF_INVALID_FILE; <br>         <br>        pTrk-&gt;idxTrack      = (DWORD)(hpbImage - pSmf-&gt;hpbImage); <br>        pTrk-&gt;smti.cbLength = DWORDSWAP(pCh-&gt;dwLength); <br> <br>        if (pTrk-&gt;smti.cbLength &gt; dwLeft) <br>        { <br>            DPF(1, "Track longer than file!"); <br>            return SMF_INVALID_FILE; <br>        } <br> <br>        dwLeft   -= pTrk-&gt;smti.cbLength; <br>        hpbImage += pTrk-&gt;smti.cbLength; <br> <br>        pTrk++; <br>    } <br> <br>    /* File looks OK. Now preparse, doing the following: <br>    ** (1) Build tempo map so we can convert to/from ticks quickly <br>    ** (2) Determine actual tick length of file <br>    ** (3) Validate all events in all tracks <br>    */  <br>    pSmf-&gt;tkPosition = 0; <br>    pSmf-&gt;fdwSMF &amp;= ~SMF_F_EOF; <br>     <br>    for (pTrk = pSmf-&gt;rTracks, idxTrack = pSmf-&gt;dwTracks; idxTrack--; pTrk++) <br>    { <br>        pTrk-&gt;pSmf              = pSmf; <br>        pTrk-&gt;tkPosition        = 0; <br>        pTrk-&gt;cbLeft            = pTrk-&gt;smti.cbLength; <br>        pTrk-&gt;hpbImage          = pSmf-&gt;hpbImage + pTrk-&gt;idxTrack; <br>        pTrk-&gt;bRunningStatus    = 0; <br>        pTrk-&gt;fdwTrack          = 0; <br>    } <br> <br>    while (SMF_SUCCESS == (smfrc = smfGetNextEvent(pSmf, (EVENT BSTACK *)&amp;event, MAX_TICKS))) <br>    { <br>        if (MIDI_META == event.abEvent[0] &amp;&amp;  <br>            MIDI_META_TEMPO == event.abEvent[1]) <br>        { <br>            if (3 != event.cbParm) <br>            { <br>                return SMF_INVALID_FILE; <br>            } <br> <br>            if (pSmf-&gt;cTempoMap == pSmf-&gt;cTempoMapAlloc) <br>            { <br>                if (NULL != pSmf-&gt;hTempoMap) <br>                { <br>                    LocalUnlock(pSmf-&gt;hTempoMap); <br>                } <br>                 <br>                pSmf-&gt;cTempoMapAlloc += C_TEMPO_MAP_CHK; <br>                fFirst = FALSE; <br>                if (0 == pSmf-&gt;cTempoMap) <br>                { <br>                    hLocal = LocalAlloc(LHND, (UINT)(pSmf-&gt;cTempoMapAlloc*sizeof(TEMPOMAPENTRY))); <br>                    fFirst = TRUE; <br>                } <br>                else <br>                { <br>                    hLocal = LocalReAlloc(pSmf-&gt;hTempoMap, (UINT)(pSmf-&gt;cTempoMapAlloc*sizeof(TEMPOMAPENTRY)), LHND); <br>                } <br> <br>                if (NULL == hLocal) <br>                { <br>                    return SMF_NO_MEMORY; <br>                } <br> <br>                pSmf-&gt;pTempoMap = (PTEMPOMAPENTRY)LocalLock(pSmf-&gt;hTempoMap = hLocal); <br>            } <br> <br>            if (fFirst &amp;&amp; pSmf-&gt;tkPosition != 0) <br>            { <br>                /* Inserting first event and the absolute time is zero. <br>                ** Use defaults of 500,000 uSec/qn from MIDI spec <br>                */ <br>                 <br>                pTempo = &amp;pSmf-&gt;pTempoMap[pSmf-&gt;cTempoMap++]; <br> <br>                pTempo-&gt;tkTempo = 0; <br>                pTempo-&gt;msBase  = 0; <br>                pTempo-&gt;dwTempo = MIDI_DEFAULT_TEMPO; <br> <br>                fFirst = FALSE; <br>            } <br> <br>            pTempo = &amp;pSmf-&gt;pTempoMap[pSmf-&gt;cTempoMap++]; <br> <br>            pTempo-&gt;tkTempo = pSmf-&gt;tkPosition; <br>            if (fFirst) <br>                pTempo-&gt;msBase = 0; <br>            else <br>            { <br>                /* NOTE: Better not be here unless we're q/n format! <br>                */ <br>                pTempo-&gt;msBase = (pTempo-1)-&gt;msBase + <br>                                 muldiv32(pTempo-&gt;tkTempo-((pTempo-1)-&gt;tkTempo), <br>                                          (pTempo-1)-&gt;dwTempo, <br>                                          1000L*pSmf-&gt;dwTimeDivision); <br>            } <br>            pTempo-&gt;dwTempo = (((DWORD)event.hpbParm[0])&lt;&lt;16)| <br>                              (((DWORD)event.hpbParm[1])&lt;&lt;8)| <br>                              ((DWORD)event.hpbParm[2]); <br>        } <br>    } <br> <br>if (0 == pSmf-&gt;cTempoMap) <br>{ <br>DPF(1, "File contains no tempo map! Insert default tempo."); <br> <br>hLocal = LocalAlloc(LHND, sizeof(TEMPOMAPENTRY)); <br>if (!hLocal) <br>return SMF_NO_MEMORY; <br> <br>        pSmf-&gt;pTempoMap = (PTEMPOMAPENTRY)LocalLock(pSmf-&gt;hTempoMap = hLocal); <br>pSmf-&gt;cTempoMap = 1; <br>pSmf-&gt;cTempoMapAlloc = 1; <br> <br>pSmf-&gt;pTempoMap-&gt;tkTempo = 0; <br>        pSmf-&gt;pTempoMap-&gt;msBase  = 0; <br>        pSmf-&gt;pTempoMap-&gt;dwTempo = MIDI_DEFAULT_TEMPO; <br>} <br> <br>    if (SMF_END_OF_FILE == smfrc || SMF_SUCCESS == smfrc) <br>    { <br>        pSmf-&gt;tkLength = pSmf-&gt;tkPosition; <br>        smfrc = SMF_SUCCESS; <br>    } <br>         <br>    return smfrc; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfGetNextEvent <br>* <br>* Read the next event from the given file. <br>* <br>* pSmf                      - File to read the event from. <br>* <br>* pEvent                    - Pointer to an event structure which will receive <br>*                             basic information about the event. <br>* <br>* tkMax                     - Tick destination. An attempt to read past this <br>*                             position in the file will fail. <br>* <br>* Returns <br>*   SMF_SUCCESS The events were successfully read. <br>*   SMF_END_OF_FILE There are no more events to read in this track. <br>*   SMF_REACHED_TKMAX No event was read because &lt;p tkMax&gt; was reached. <br>*   SMF_INVALID_FILE A disk or parse error occured on the file. <br>* <br>* This is the lowest level of parsing for a raw MIDI stream. The basic <br>* information about one event in the file will be returned in pEvent. <br>* <br>* Merging data from all tracks into one stream is performed here. <br>*  <br>* pEvent-&gt;tkDelta will contain the tick delta for the event. <br>* <br>* pEvent-&gt;abEvent will contain a description of the event. <br>*  pevent-&gt;abEvent[0] will contain <br>*    F0 or F7 for a System Exclusive message. <br>*    FF for a MIDI file meta event. <br>*    The status byte of any other MIDI message. (Running status will <br>*    be tracked and expanded). <br>* <br>* pEvent-&gt;cbParm will contain the number of bytes of paramter data <br>*   which is still in the file behind the event header already read. <br>*   This data may be read with &lt;f smfGetTrackEventData&gt;. Any unread <br>*   data will be skipped on the next call to &lt;f smfGetNextTrackEvent&gt;. <br>* <br>* Channel messages (0x8? - 0xE?) will always be returned fully in <br>*   pevent-&gt;abEvent. <br>* <br>*  Meta events will contain the meta type in pevent-&gt;abEvent[1]. <br>* <br>*  System exclusive events will contain only an 0xF0 or 0xF7 in <br>*    pevent-&gt;abEvent[0]. <br>* <br>*  The following fields in pTrk are used to maintain state and must <br>*  be updated if a seek-in-track is performed: <br>* <br>*  bRunningStatus contains the last running status message or 0 if <br>*   there is no valid running status. <br>* <br>*  hpbImage is a pointer into the file image of the first byte of <br>*   the event to follow the event just read. <br>* <br>*  dwLeft contains the number of bytes from hpbImage to the end <br>*   of the track. <br>* <br>* <br>* Get the next due event from all (in-use?) tracks <br>* <br>* For all tracks <br>*  If not end-of-track <br>*   decode event delta time without advancing through buffer <br>*   event_absolute_time = track_tick_time + track_event_delta_time <br>*   relative_time = event_absolute_time - last_stream_time <br>*   if relative_time is lowest so far <br>*    save this track as the next to pull from, along with times <br>* <br>* If we found a track with a due event <br>*  Advance track pointer past event, saving ptr to parm data if needed <br>*  track_tick_time += track_event_delta_time <br>*  last_stream_time = track_tick_time <br>* Else <br>*  Mark and return end_of_file <br>* <br>*****************************************************************************/ <br>SMFRESULT FNLOCAL smfGetNextEvent( <br>    PSMF                    pSmf, <br>    EVENT BSTACK *          pEvent, <br>    TICKS                   tkMax) <br>{ <br>    PTRACK                  pTrk; <br>    PTRACK                  pTrkFound; <br>    DWORD                   idxTrack; <br>    TICKS                   tkEventDelta; <br>    TICKS                   tkRelTime; <br>    TICKS                   tkMinRelTime; <br>    BYTE                    bEvent; <br>    DWORD                   dwGotTotal; <br>    DWORD                   dwGot; <br>    DWORD                   cbEvent; <br> <br>    assert(pSmf != NULL); <br>    assert(pEvent != NULL); <br> <br>    if (pSmf-&gt;fdwSMF &amp; SMF_F_EOF) <br>    { <br>        return SMF_END_OF_FILE; <br>    } <br> <br>    pTrkFound       = NULL; <br>    tkMinRelTime    = MAX_TICKS; <br>     <br>    for (pTrk = pSmf-&gt;rTracks, idxTrack = pSmf-&gt;dwTracks; idxTrack--; pTrk++) <br>    { <br>        if (pTrk-&gt;fdwTrack &amp; SMF_TF_EOT) <br>            continue; <br> <br>         <br>        if (!smfGetVDword(pTrk-&gt;hpbImage, pTrk-&gt;cbLeft, (DWORD BSTACK *)&amp;tkEventDelta)) <br>        { <br>            DPF(1, "Hit end of track w/o end marker!"); <br>            return SMF_INVALID_FILE; <br>        } <br> <br>        tkRelTime = pTrk-&gt;tkPosition + tkEventDelta - pSmf-&gt;tkPosition; <br> <br>        if (tkRelTime &lt; tkMinRelTime) <br>        { <br>            tkMinRelTime = tkRelTime; <br>            pTrkFound = pTrk; <br>        } <br>    } <br> <br>    if (!pTrkFound) <br>    { <br>        pSmf-&gt;fdwSMF |= SMF_F_EOF; <br>        return SMF_END_OF_FILE; <br>    } <br> <br>    pTrk = pTrkFound; <br> <br>    if (pSmf-&gt;tkPosition + tkMinRelTime &gt;= tkMax) <br>    { <br>        return SMF_REACHED_TKMAX; <br>    } <br>         <br> <br>    pTrk-&gt;hpbImage += (dwGot = smfGetVDword(pTrk-&gt;hpbImage, pTrk-&gt;cbLeft, (DWORD BSTACK *)&amp;tkEventDelta)); <br>    pTrk-&gt;cbLeft   -= dwGot; <br> <br>    /* We MUST have at least three bytes here (cause we haven't hit <br>    ** the end-of-track meta yet, which is three bytes long). Checking <br>    ** against three means we don't have to check how much is left <br>    ** in the track again for any short event, which is most cases. <br>    */ <br>    if (pTrk-&gt;cbLeft &lt; 3) <br>    { <br>        return SMF_INVALID_FILE; <br>    } <br> <br>    pTrk-&gt;tkPosition += tkEventDelta; <br>    pEvent-&gt;tkDelta = pTrk-&gt;tkPosition - pSmf-&gt;tkPosition; <br>    pSmf-&gt;tkPosition = pTrk-&gt;tkPosition; <br> <br>    bEvent = *pTrk-&gt;hpbImage++; <br>     <br>    if (MIDI_MSG &gt; bEvent) <br>    { <br>        if (0 == pTrk-&gt;bRunningStatus) <br>        { <br>            return SMF_INVALID_FILE; <br>        } <br> <br>        dwGotTotal = 1; <br>        pEvent-&gt;abEvent[0] = pTrk-&gt;bRunningStatus; <br>        pEvent-&gt;abEvent[1] = bEvent; <br>        if (3 == grbChanMsgLen[(pTrk-&gt;bRunningStatus &gt;&gt; 4) &amp; 0x0F]) <br>        { <br>            pEvent-&gt;abEvent[2] = *pTrk-&gt;hpbImage++; <br>            dwGotTotal++; <br>        } <br>    } <br>    else if (MIDI_SYSEX &gt; bEvent) <br>    { <br>        pTrk-&gt;bRunningStatus = bEvent; <br>         <br>        dwGotTotal = 2; <br>        pEvent-&gt;abEvent[0] = bEvent; <br>        pEvent-&gt;abEvent[1] = *pTrk-&gt;hpbImage++; <br>        if (3 == grbChanMsgLen[(bEvent &gt;&gt; 4) &amp; 0x0F]) <br>        { <br>            pEvent-&gt;abEvent[2] = *pTrk-&gt;hpbImage++; <br>            dwGotTotal++; <br>        } <br>    } <br>    else <br>    { <br>        pTrk-&gt;bRunningStatus = 0; <br>        if (MIDI_META == bEvent) <br>        { <br>            pEvent-&gt;abEvent[0] = MIDI_META; <br>            if (MIDI_META_EOT == (pEvent-&gt;abEvent[1] = *pTrk-&gt;hpbImage++)) <br>            { <br>                pTrk-&gt;fdwTrack |= SMF_TF_EOT; <br>            } <br> <br>            dwGotTotal = 2; <br>        } <br>        else if (MIDI_SYSEX == bEvent || MIDI_SYSEXEND == bEvent) <br>        { <br>            pEvent-&gt;abEvent[0] = bEvent; <br>            dwGotTotal = 1; <br>        } <br>        else <br>        { <br>            return SMF_INVALID_FILE; <br>        } <br>         <br>        if (0 == (dwGot = smfGetVDword(pTrk-&gt;hpbImage, pTrk-&gt;cbLeft - 2, (DWORD BSTACK *)&amp;cbEvent))) <br>        { <br>            return SMF_INVALID_FILE; <br>        } <br> <br>        pTrk-&gt;hpbImage  += dwGot; <br>        dwGotTotal      += dwGot; <br> <br>        if (dwGotTotal + cbEvent &gt; pTrk-&gt;cbLeft) <br>        { <br>            return SMF_INVALID_FILE; <br>        } <br> <br>        pEvent-&gt;cbParm  = cbEvent; <br>        pEvent-&gt;hpbParm = pTrk-&gt;hpbImage; <br> <br>        pTrk-&gt;hpbImage += cbEvent; <br>        dwGotTotal     += cbEvent; <br>    } <br> <br>    assert(pTrk-&gt;cbLeft &gt;= dwGotTotal); <br> <br>    pTrk-&gt;cbLeft -= dwGotTotal; <br> <br>    return SMF_SUCCESS; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfGetVDword <br>* <br>* Reads a variable length DWORD from the given file. <br>* <br>* hpbImage                  - Pointer to the first byte of the VDWORD. <br>* <br>* dwLeft                    - Bytes left in image <br>* <br>* pDw                       - Pointer to a DWORD to store the result in. <br>*                             track. <br>* <br>* Returns the number of bytes consumed from the stream. <br>* <br>* A variable length DWORD stored in a MIDI file contains one or more <br>* bytes. Each byte except the last has the high bit set; only the <br>* low 7 bits are significant. <br>*   <br>*****************************************************************************/ <br>DWORD FNLOCAL smfGetVDword( <br>    HPBYTE                  hpbImage,                                 <br>    DWORD                   dwLeft,                                <br>    DWORD BSTACK *          pDw) <br>{ <br>    BYTE                    b; <br>    DWORD                   dwUsed  = 0; <br> <br>    assert(hpbImage != NULL); <br>    assert(pDw != NULL); <br>     <br>    *pDw = 0; <br> <br>    do <br>    { <br>        if (!dwLeft) <br>        { <br>            return 0; <br>        } <br> <br>        b = *hpbImage++; <br>        dwLeft--; <br>        dwUsed++; <br>         <br>        *pDw = (*pDw &lt;&lt; 7) | (b &amp; 0x7F); <br>    } while (b&amp;0x80); <br> <br>    return dwUsed; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
