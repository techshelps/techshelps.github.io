<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAINWND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2528"></a>MAINWND.C</h2>
<pre><code>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>****************************************************************************** <br>* <br>* MainWnd.C <br>* <br>* Message handlers and UI for the main window and associated controls <br>* <br>*****************************************************************************/ <br> <br>#pragma warning(disable:4756) <br> <br>#define _INC_SHELLAPI <br>#include &lt;windows.h&gt; <br>#undef _INC_SHELLAPI <br> <br>#include &lt;shellapi.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>#include "debug.h" <br> <br>#include "MIDIPlyr.H" <br> <br>#define BITMAP_COUNT    6           /* Number of buttons in bitmap */ <br> <br>PRIVATE HWND            ghWndToolbar                    = NULL; <br>PRIVATE HWND            ghWndStatus                     = NULL; <br>PRIVATE HWND            ghWndTime                       = NULL; <br>PRIVATE char            gszAppTitle[80]                 = ""; <br>PRIVATE int             gnSB_TFPaneSize                 = 0; <br>PRIVATE char            gszOpenName[MAX_FILEPATH]       = ""; <br>PRIVATE char            gszOpenTitle[MAX_FILEPATH]      = ""; <br>PRIVATE char BCODE      gszFilter[]                      = <br>    "MIDI File (*.MID;*.RMI)\0*.MID;*.RMI\0" <br>    "All Files (*.*)\0*.*\0"; <br> <br>PRIVATE char BCODE      gszDefExtension[]               = "MID"; <br>PRIVATE BOOL            gbAutoPlay                      = TRUE; <br>PRIVATE UINT            guDevice                        = 0; <br> <br>PRIVATE TBBUTTON gatbButton[] = <br>{ <br>    {0, -1,             TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0,  0, -1}, <br>    {0, IDM_OPEN,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0,  0, -1}, <br>    {0, -1,             TBSTATE_ENABLED, TBSTYLE_SEP,    0, 0,  0, -1}, <br>    {2, IDM_PLAY,       0,               TBSTYLE_BUTTON, 0, 0,  0, -1}, <br>    {3, IDM_STOP,       0,               TBSTYLE_BUTTON, 0, 0,  0, -1}, <br>    {4, IDM_PAUSE,      0,               TBSTYLE_BUTTON, 0, 0,  0, -1}, <br>}; <br> <br>#define BUTTON_COUNT (sizeof(gatbButton)/sizeof(gatbButton[0])) <br> <br>PRIVATE VOID FNLOCAL InitToolbar(HWND hWnd); <br>PRIVATE VOID FNLOCAL InitStatusBar(HWND hWnd); <br>PRIVATE VOID FNLOCAL ResizeStatusBar(HWND hWnd); <br>PRIVATE VOID FNLOCAL SyncUI(HWND hWnd); <br>PRIVATE VOID FNLOCAL SetOneAction(HWND hWnd, int nMenuID, BOOL fEnable); <br>PRIVATE VOID FNLOCAL AttemptFileOpen(HWND hWnd); <br>PRIVATE BOOL FNLOCAL PrerollAndWait(HWND hWnd); <br> <br>PRIVATE BOOL FNLOCAL MWnd_OnCreate(HWND hWnd, CREATESTRUCT FAR* lpCreateStruct); <br>PRIVATE VOID FNLOCAL MWnd_OnGetMinMaxInfo(HWND hWnd, MINMAXINFO FAR* lpMinMaxInfo); <br>PRIVATE VOID FNLOCAL MWnd_OnSize(HWND hWnd, UINT state, int cx, int cy); <br>PRIVATE VOID FNLOCAL MWnd_OnPaint(HWND hWnd); <br>PRIVATE VOID FNLOCAL MWnd_OnDropFiles(HWND hWnd, HDROP hDrop); <br>PRIVATE VOID FNLOCAL MWnd_OnFileOpen(HWND hWnd); <br>PRIVATE VOID FNLOCAL MWnd_OnCommandToggleChild(HWND hWnd, UINT id); <br>PRIVATE VOID FNLOCAL MWnd_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify); <br>PRIVATE VOID FNLOCAL MWnd_OnDestroy(HWND hWnd); <br> <br>/***************************************************************************** <br>* <br>* InitToolbar <br>* <br>* Called to create the toolbar <br>* <br>* HWND hWnd                 - Application window which toolbar is a child of <br>* <br>* Create and show the toolbar window. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL InitToolbar( <br>    HWND                    hWnd) <br>{ <br>    ghWndToolbar = CreateToolbarEx(hWnd, <br>                                   WS_CHILD|WS_CLIPSIBLINGS|WS_CLIPCHILDREN, <br>                                   IDC_TOOLBAR, <br>                                   BITMAP_COUNT, <br>                                   ghInst, <br>                                   IDB_TOOLBAR, <br>                                   gatbButton, <br>                                   BUTTON_COUNT, <br>                                   0,  0, <br>                                   0,  0, <br>                                   sizeof(TBBUTTON)); <br> <br>    if (ghWndToolbar) <br>        ShowWindow(ghWndToolbar, SW_RESTORE); <br>} <br> <br>/***************************************************************************** <br>* <br>* InitStatusBar <br>* <br>* Called to create the status bar <br>* <br>* HWND hWnd                 - Application window which status bar is a child of <br>* <br>* Create and show the status window. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL InitStatusBar( <br>    HWND                    hWnd) <br>{ <br>    HWND                    hWndDesktop; <br>    HFONT                   hFontStat; <br>    HDC                     hDC; <br>    UINT                    idx; <br>    SIZE                    size; <br> <br>    ghWndStatus = CreateStatusWindow(WS_CHILD|SBARS_SIZEGRIP, <br>                                     "", <br>                                     hWnd, <br>                                     IDC_STATBAR); <br> <br>    if (ghWndStatus) <br>    { <br>        hWndDesktop = GetDesktopWindow(); <br>        hFontStat = (HFONT)SendMessage(ghWndStatus, WM_GETFONT, 0, 0L); <br>        hDC = GetDC(hWndDesktop); <br> <br>        if (hFontStat != (HFONT)NULL &amp;&amp; hDC != (HDC)NULL) <br>        { <br>            hFontStat = (HFONT)SelectObject(hDC, hFontStat); <br> <br>            gnSB_TFPaneSize = 0; <br>            for (idx = 0; idx &lt; N_TIME_FORMATS; idx++) <br>            { <br>                GetTextExtentPoint(hDC, <br>                                   grgszTimeFormats[idx], <br>                                   lstrlen(grgszTimeFormats[idx]), <br>                                   &amp;size); <br> <br>                gnSB_TFPaneSize = max(gnSB_TFPaneSize, size.cx); <br>            } <br> <br>            SelectObject(hDC, hFontStat); <br> <br>            gnSB_TFPaneSize *= 2; <br>        } <br> <br>        if (hDC != (HDC)NULL) <br>            ReleaseDC(hWndDesktop, hDC); <br> <br>        ResizeStatusBar(hWnd); <br>         <br>        FORWARD_WM_COMMAND(hWnd, gnTimeFormat, 0, 0, SendMessage); <br>        ShowWindow(ghWndStatus, SW_RESTORE); <br>    } <br>} <br> <br>/***************************************************************************** <br>* <br>* ResizeStatusBar <br>* <br>* Force the status bar to resize to fit in the main window <br>* <br>* HWND hWnd                 - Application window which status bar is a child of <br>* <br>* Figure out the pane sizes and send a message to the status bar to set them. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL ResizeStatusBar( <br>    HWND                    hWnd) <br>{ <br>    RECT                    rc; <br>    int                     rnPaneEdge[SB_N_PANES]; <br> <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    /* SB_SETPARTS expects: <br>    **  wParam == Number of panes in status bar. <br>    **  lParam == Pointer to an array of int's indicating the right-hand <br>    **            coordinate of each pane. <br>    */ <br>    rnPaneEdge[SB_PANE_STATE] = rc.right - gnSB_TFPaneSize; <br>    rnPaneEdge[SB_PANE_TFMT]  = -1; <br> <br>    SendMessage(ghWndStatus, <br>                SB_SETPARTS, <br>                SB_N_PANES, <br>                (DWORD)(LPINT)(rnPaneEdge)); <br>} <br> <br>/***************************************************************************** <br>* <br>* SyncUI <br>* <br>* Bring all UI elements into sync with the state of the sequencer <br>* <br>* HWND hWnd                 - Application main window  <br>* <br>* Build a flag word of the actions which are allowed from the current state. <br>* Set the menu items and toolbar buttons for each action appropriately. <br>* Show the current state as a string in the status bar. <br>* Depress the pause button if the sequencer is paused. <br>* Cause the time window to update. <br>* <br>*****************************************************************************/ <br>#define SUI_F_CANPLAY       0x0001 <br>#define SUI_F_CANPAUSE      0x0002 <br>#define SUI_F_CANSTOP       0x0004 <br>#define SUI_F_CANSELDEVICE  0x0008 <br> <br>PRIVATE VOID FNLOCAL SyncUI( <br>    HWND                    hWnd) <br>{ <br>    WORD                    wActionFlags; <br>    UINT                    uState; <br>    char                    szState[40]; <br>    BOOL                    fPress; <br> <br>    wActionFlags = 0; <br>    uState = SEQ_S_NOFILE; <br>     <br>    if (gpSeq != NULL) <br>    { <br>        uState = gpSeq-&gt;uState; <br>        switch (uState) <br>        { <br>        case SEQ_S_NOFILE: <br>            wActionFlags = SUI_F_CANSELDEVICE; <br>            break; <br> <br>        case SEQ_S_OPENED: <br>        case SEQ_S_PREROLLED: <br>            wActionFlags = SUI_F_CANPLAY|SUI_F_CANSELDEVICE; <br>            break; <br> <br>        case SEQ_S_PAUSED: <br>        case SEQ_S_PLAYING: <br>            wActionFlags = SUI_F_CANPAUSE|SUI_F_CANSTOP; <br>            break; <br> <br> <br>        case SEQ_S_PREROLLING: <br>        case SEQ_S_STOPPING: <br>//            assert(0); <br>            wActionFlags = 0; <br>            break; <br>        } <br>    } <br>     <br>    fPress = (gpSeq-&gt;uState == SEQ_S_PAUSED); <br>    SendMessage(ghWndToolbar, <br>                TB_PRESSBUTTON, <br>                IDM_PAUSE, <br>                fPress); <br> <br>    SetOneAction(hWnd, IDM_PLAY,   wActionFlags &amp; SUI_F_CANPLAY); <br>    SetOneAction(hWnd, IDM_PAUSE,  wActionFlags &amp; SUI_F_CANPAUSE); <br>    SetOneAction(hWnd, IDM_STOP,   wActionFlags &amp; SUI_F_CANSTOP); <br> <br>    EnableMenuItem(GetMenu(hWnd), <br>                   POS_PLAYTHRU, <br>                   MF_BYPOSITION|((wActionFlags &amp; SUI_F_CANSELDEVICE) ? MF_ENABLED : MF_DISABLED)); <br> <br>    DrawMenuBar(hWnd); <br> <br>    szState[0] = '\0'; <br>    LoadString(ghInst, IDS_STATES + uState, szState, sizeof(szState)); <br>    SendMessage(ghWndStatus, SB_SETTEXT, SB_PANE_STATE, (LPARAM)(LPSTR)szState); <br> <br>    InvalidateRect(ghWndTime, NULL, TRUE); <br>} <br> <br>/***************************************************************************** <br>* <br>* SetOneAction <br>* <br>* Update the state of one action in both the toolbar and action menu <br>* <br>* HWND hWnd                 - Application main window <br>* int nMenuID               - Menu ID of action <br>* BOOL fEnable              - Enable or disable this action <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL SetOneAction( <br>    HWND                hWnd, <br>    int                 nMenuID, <br>    BOOL                fEnable) <br>{ <br>    EnableMenuItem(GetMenu(hWnd), <br>                   nMenuID, <br>                   MF_BYCOMMAND|(fEnable ? MF_ENABLED : MF_DISABLED)); <br> <br>    SendMessage(ghWndToolbar, <br>                TB_ENABLEBUTTON, <br>                nMenuID, <br>                (DWORD)fEnable); <br>} <br> <br>/***************************************************************************** <br>* <br>* AttemptFileOpen <br>* <br>* Try to open the given file in the sequencer. <br>* <br>* HWND hWnd                 - Application main window <br>* <br>* Stop and close the current file. <br>* Open the new file. <br>* Preroll the new file. <br>* Set the title test for the main window. <br>* Call SyncUI to update available actions. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL AttemptFileOpen( <br>    HWND                    hWnd) <br>{ <br>    MMRESULT                mmrc; <br>    PSTR                    pStrFile    = gszUntitled; <br>     <br>    /* Stop, close, etc. if we're still playing <br>    */ <br>    DPF(1, "AttemptFileOpen: Calling seqStop(); state = %u", gpSeq-&gt;uState); <br>     <br>    mmrc = seqStop(gpSeq); <br>if (mmrc != MMSYSERR_NOERROR) <br>{ <br>Error(hWnd, IDS_STOPFAILED, mmrc); <br>return; <br>} <br> <br>    DPF(1, "Calling seqCloseFile(); state = %u", gpSeq-&gt;uState); <br>    seqCloseFile(gpSeq); <br> <br>    DPF(1, "Calling seqOpenFile(); state = %u", gpSeq-&gt;uState); <br>    /* Open new file <br>    */ <br> <br>    gpSeq-&gt;pstrFile = gszOpenName; <br>    mmrc = seqOpenFile(gpSeq); <br>    if (mmrc != MMSYSERR_NOERROR) <br>    { <br>        Error(hWnd, IDS_OPENFAILED, mmrc); <br>        return; <br>    } <br> <br>    pStrFile = gszOpenTitle; <br> <br>    wsprintf(gszAppTitle, gszAppTitleMask, (LPSTR)pStrFile); <br>    SetWindowText(hWnd, gszAppTitle); <br> <br>    SyncUI(hWnd); <br>} <br> <br>/***************************************************************************** <br>* <br>* PrerollAndWait <br>* <br>* Prerolls the sequencer using the current device ID and file. <br>* <br>* HWND hWnd                 - Current window <br>* <br>* Just call preroll and loop processing messages until done. <br>* <br>*****************************************************************************/ <br>PRIVATE BOOL FNLOCAL PrerollAndWait( <br>    HWND                    hWnd) <br>{ <br>    PREROLL                 preroll; <br>    MMRESULT                mmrc; <br>     <br>    preroll.tkBase = 0; <br>    preroll.tkEnd  = gpSeq-&gt;tkLength; <br> <br>    gpSeq-&gt;uDeviceID = guDevice; <br> <br>    if (MMSYSERR_NOERROR != (mmrc = seqPreroll(gpSeq, &amp;preroll))) <br>{ <br>        Error(hWnd, IDS_PREROLLFAILED, mmrc); <br>        return FALSE; <br>} <br> <br>return TRUE; <br>} <br> <br>/***************************************************************************** <br>* <br>* MWnd_OnCreate <br>* <br>* Handle WM_CREATE message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* CREATESTRUCT FAR* lpCreateStruct <br>*                           - Pointer to creation parameters for the window. <br>* <br>* Returns TRUE on success. Returning FALSE will cause the window to be <br>* destroyed and the application will exit. <br>* <br>* Set the default time format. <br>* Create the tool and status bars. <br>* Create the time window as a child of the main app window and show it. <br>* Set the main window's title to show no document ('Untitled'). <br>* Accept drag/drop files. <br>* Call SyncUI to update the enable status of the toolbar and menu items. <br>* <br>*****************************************************************************/ <br>PRIVATE BOOL FNLOCAL MWnd_OnCreate( <br>    HWND                    hWnd, <br>    CREATESTRUCT FAR*       lpCreateStruct) <br>{ <br>    HMENU                   hMenu; <br>    HMENU                   hMenuOptions; <br>    HMENU                   hMenuPlayThru; <br>    UINT                    cDevs; <br>    UINT                    idx; <br>    RECT                    rc; <br>    MIDIOUTCAPS             moutCaps; <br> <br>    gnTimeFormat = IDS_TF_FIRST; <br> <br>    InitToolbar(hWnd); <br>    InitStatusBar(hWnd); <br>     <br>    hMenu = GetMenu(hWnd); <br>    hMenuOptions = GetSubMenu(hMenu, POS_OPTIONS); <br>    hMenuPlayThru = GetSubMenu(hMenu, POS_PLAYTHRU); <br> <br>    AppendMenu(hMenuOptions, MF_SEPARATOR, 0, NULL); <br>     <br>    for (idx = 0; idx &lt; N_TIME_FORMATS; idx++) <br>    { <br>        AppendMenu(hMenuOptions, <br>                   MF_ENABLED|MF_STRING, <br>                   IDS_TF_FIRST + idx, <br>                   grgszTimeFormats[idx]); <br>    } <br> <br>    cDevs = midiOutGetNumDevs(); <br>    if (cDevs) <br>        AppendMenu(hMenuPlayThru, MF_SEPARATOR, 0, NULL); <br>     <br>    for (idx = 0; idx &lt; cDevs; idx++) <br>    { <br>        if (midiOutGetDevCaps(idx, &amp;moutCaps, sizeof(moutCaps)) == MMSYSERR_NOERROR) <br>        { <br>            AppendMenu(hMenuPlayThru, <br>                       MF_ENABLED|MF_STRING, <br>                       IDM_DEVICES + idx, <br>                       moutCaps.szPname); <br>        } <br>    } <br>     <br>    CheckMenuItem(hMenu, IDM_TOOLBAR, MF_BYCOMMAND|MF_CHECKED); <br>    CheckMenuItem(hMenu, IDM_STATUS,  MF_BYCOMMAND|MF_CHECKED); <br>    CheckMenuItem(hMenu, IDM_AUTOPLAY,MF_BYCOMMAND|MF_CHECKED); <br>    CheckMenuItem(hMenu, gnTimeFormat,MF_BYCOMMAND|MF_CHECKED); <br>    CheckMenuItem(hMenu, IDM_DEVICES,  MF_BYCOMMAND|MF_CHECKED);   <br> <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    ghWndTime = CreateWindow( <br>        gszTWndClass, <br>        NULL, <br>        WS_CHILD, <br>        rc.left, rc.top, <br>        rc.right-rc.left, rc.bottom-rc.top, <br>        hWnd, <br>        NULL, <br>        lpCreateStruct-&gt;hInstance, <br>        NULL); <br> <br>    ShowWindow(ghWndTime, SW_RESTORE); <br> <br>    wsprintf(gszAppTitle, gszAppTitleMask, (LPSTR)gszUntitled); <br>    SetWindowText(hWnd, gszAppTitle); <br> <br>    DragAcceptFiles(hWnd, TRUE); <br> <br>    SyncUI(hWnd); <br> <br>    return TRUE; <br>} <br>                       <br>/***************************************************************************** <br>* <br>* MWnd_OnGetMinMaxSize <br>* <br>* Handle WM_GETMINMAXSIZE message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* MINMAXINFO FAR* lpMinMaxInfo <br>*                           - Pointer to min/max tracking information <br>* <br>* This message is sent to a window before resize tracking begins. The <br>* lpMinMaxInfo structure contains the minimum and maximum x and y values <br>* the window can be resized to. <br>* <br>* We don't allow resizing small enough to cause the status bar and toolbar <br>* to overlap so they don't try to draw over each other.  <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnGetMinMaxInfo( <br>    HWND                    hWnd, <br>    MINMAXINFO FAR*         lpMinMaxInfo) <br>{ <br>    RECT                    rc; <br> <br>    GetWindowRect(hWnd, &amp;rc); <br> <br>    /* Only go small enough that our client area after children is zero. <br>    */ <br>    lpMinMaxInfo-&gt;ptMinTrackSize.y = <br>        (rc.bottom - rc.top) - <br>        (grcTWnd.bottom - grcTWnd.top);                                       <br>} <br> <br>/***************************************************************************** <br>* <br>* MWnd_OnSize <br>* <br>* Handle WM_SIZE message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* UINT state                - Some SIZE_xxx code indicating what type of <br>*                             size operation this is. <br>* int  cx, cy               - New x and y size of the window's client area. <br>* <br>* Get the new client area. <br>* Adjust the client area for the toolbar and status bar if they exist. <br>* Make sure the client area isn't a negative height and adjust if it is. <br>* Resize the time window to fit in our new client area. <br>* Forward the WM_SIZE to the time window so it can resize its font. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnSize( <br>    HWND                    hWnd, <br>    UINT                    state, <br>    int                     cx, <br>    int                     cy) <br>{ <br>    RECT                    rc; <br>    RECT                    rcClient; <br> <br>    GetClientRect(hWnd, &amp;rcClient); <br>    if (ghWndToolbar != NULL) <br>    { <br>        /* Cause the toolbar to be aware of the size change <br>        */ <br>        FORWARD_WM_SIZE(ghWndToolbar, SIZE_RESTORED, 0, 0, SendMessage); <br>         <br>        GetWindowRect(ghWndToolbar, &amp;rc); <br>        rcClient.top += (rc.bottom - rc.top); <br>    } <br> <br>    if (ghWndStatus != NULL) <br>    { <br>        ResizeStatusBar(hWnd); <br>         <br>        /* Cause the status bar to be aware of the size change <br>        */ <br>        FORWARD_WM_SIZE(ghWndStatus, SIZE_RESTORED, 0, 0, SendMessage); <br>         <br>        GetWindowRect(ghWndStatus, &amp;rc); <br>        rcClient.bottom -= (rc.bottom - rc.top); <br>    } <br> <br>    /* Do we need to resize entire window so the tool/status bars <br>    ** don't overlap? (The only case where this can happen is <br>    ** on creation of one of the two -- we set minimum tracking so <br>    ** a user can't manually resize the window to cause this <br>    ** condition). <br>    */ <br>    if (rcClient.bottom &lt; rcClient.top) <br>    { <br>        GetWindowRect(hWnd, &amp;rc); <br>        SetWindowPos(hWnd, <br>                     (HWND)NULL, <br>                     0, 0, <br>                     rc.right - rc.left + 1, <br>                     rc.bottom - rc.top + 1 - rcClient.top - rcClient.bottom, <br>                     SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOZORDER); <br>    } <br> <br>    SetWindowPos(ghWndTime, <br>                 (HWND)NULL, <br>                 rcClient.left, <br>                 rcClient.top, <br>                 rcClient.right - rcClient.left, <br>                 rcClient.bottom - rcClient.top, <br>                 SWP_NOACTIVATE|SWP_NOZORDER); <br> <br>    FORWARD_WM_SIZE(ghWndTime, SIZE_RESTORED, 0, 0, SendMessage); <br>} <br> <br>/***************************************************************************** <br>* <br>* MWnd_OnPaint <br>* <br>* Handle WM_PAINT message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* <br>* Just do a BeginPaint/EndPaint pair so USER will mark the area <br>*   as valid. All the real work of painting the time is done <br>*   by the WM_PAINT handler for the time window. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnPaint( <br>    HWND                    hWnd) <br>{ <br>    PAINTSTRUCT             ps; <br>    HDC                     hDC; <br> <br>    hDC = BeginPaint(hWnd, &amp;ps); <br>    EndPaint(hWnd, &amp;ps); <br>} <br> <br>/***************************************************************************** <br>* <br>* MWnd_OnDropFiles <br>* <br>* Handle WM_DROPFILES message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* HDROP hDrop               - Handle to dropped file information <br>* <br>* Get the 0th filename and free the drop handle. <br>* Extract the file title from the full pathname. <br>* Open the file. <br>* If we opened successfully, start playback by forwarding a WM_COMMAND <br>*   of IDM_PLAY to the main window. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnDropFiles( <br>    HWND                    hWnd, <br>    HDROP                   hDrop) <br>{ <br>    PSTR                    pStr; <br>     <br>    /* For multiple selections, we only accept the first file <br>    */ <br>    DragQueryFile(hDrop, 0, gszOpenName, sizeof(gszOpenName)); <br>    DragFinish(hDrop); <br> <br>    /* We don't get OpenTitle like we do from GetOpenFileName; need to <br>    ** figure this out for ourselves <br>    */ <br>    pStr = gszOpenName + lstrlen(gszOpenName) - 1; <br> <br>    while (pStr &gt;= gszOpenName &amp;&amp; *pStr != '/' &amp;&amp; *pStr != '\\' &amp;&amp; *pStr != ':') <br>        pStr--; <br> <br>    pStr++; <br>    lstrcpy(gszOpenTitle, pStr); <br> <br>    AttemptFileOpen(hWnd); <br> <br>    if (gbAutoPlay &amp;&amp; gpSeq-&gt;uState == SEQ_S_OPENED) <br>        FORWARD_WM_COMMAND(hWnd, IDM_PLAY, (HWND)NULL, 0, SendMessage); <br>} <br> <br> <br>/***************************************************************************** <br>* <br>* MWnd_OnFileOpen <br>* <br>* Handle WM_COMMAND/IDM_OPEN message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* <br>* Fill in the OPENFILENAME struct and call GetOpenFileName. <br>* If not canceled, try to open the file. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnFileOpen( <br>    HWND                    hWnd) <br>{ <br>    OPENFILENAME            ofn; <br> <br>    *gszOpenName = '\0'; <br>     <br>ofn.lStructSize= sizeof(OPENFILENAME); <br>ofn.hwndOwner= hWnd; <br>ofn.lpstrFilter= gszFilter; <br>ofn.lpstrCustomFilter= (LPSTR)NULL; <br>ofn.nMaxCustFilter= 0L; <br>ofn.nFilterIndex= 1L; <br>ofn.lpstrFile= gszOpenName; <br>ofn.nMaxFile= MAX_FILEPATH; <br>ofn.lpstrFileTitle= gszOpenTitle; <br>ofn.nMaxFileTitle= MAX_FILEPATH; <br>ofn.lpstrTitle= (LPSTR)NULL; <br>ofn.lpstrInitialDir= (LPSTR)NULL; <br>ofn.Flags= OFN_HIDEREADONLY|OFN_FILEMUSTEXIST; <br>ofn.nFileOffset= 0; <br>ofn.nFileExtension= 0; <br>ofn.lpstrDefExt= gszDefExtension; <br> <br>    if (!GetOpenFileName(&amp;ofn)) <br>        return; <br> <br>    AttemptFileOpen(hWnd); <br>} <br> <br>/***************************************************************************** <br>* <br>* MWnd_OnCommandToggleChild <br>* <br>* Handle WM_COMMAND message of toggle tool or status bar to main application <br>* window. <br>* <br>* HWND hWnd                 - Window handle <br>* UINT id                   - Control id of menu selection; either <br>*                             IDM_TOOLBAR or IDM_STATUS <br>* <br>* Get the current menu item check state. <br>* Destroy or create the child as needed. <br>* Send a WM_SIZE to the main window so client area will be recalculated. <br>* Toggle the menu item check state. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnCommandToggleChild( <br>    HWND                    hWnd,                                       <br>    UINT                    id) <br>{ <br>    HMENU                   hMenu; <br>    UINT                    uState; <br>    HWND*                   phWnd; <br>     <br>    phWnd = (id == IDM_TOOLBAR) ? &amp;ghWndToolbar : &amp;ghWndStatus; <br> <br>    hMenu = GetMenu(hWnd); <br>    uState = GetMenuState(hMenu, id, MF_BYCOMMAND); <br>    if (uState &amp; MF_CHECKED) <br>    { <br>        DestroyWindow(*phWnd); <br>        *phWnd = NULL; <br>    } <br>    else <br>    { <br>        if (id == IDM_TOOLBAR) <br>            InitToolbar(hWnd); <br>        else <br>            InitStatusBar(hWnd); <br>    } <br> <br>    SendMessage(hWnd, WM_SIZE, 0, 0L); <br> <br>    uState ^= MF_CHECKED; <br>    uState &amp;= MF_CHECKED; <br>    CheckMenuItem(hMenu, id, MF_BYCOMMAND|uState); <br> <br>    SyncUI(hWnd); <br>} <br>                                           <br>                             <br>/***************************************************************************** <br>* <br>* MWnd_OnCommand <br>* <br>* Handle WM_COMMAND message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* int id                    - id of control or menu causing WM_COMMAND <br>* HWND hwndCtl              - Window handle of child control, if any <br>* UINT codeNotify           - Notification code if this message is from a <br>*                             control. <br>* <br>* For a press of the toolbar buttons or their menu equivalents, just load <br>* a resource string and display it in the status bar. <br>* <br>* For an exit request, send ourselves a WM_CLOSE message. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnCommand( <br>    HWND                    hWnd, <br>    int                     id, <br>    HWND                    hWndCtl, <br>    UINT                    codeNotify) <br>{ <br>    HMENU                   hMenu; <br>    int                     nIdxFormat; <br>    LPSTR                   lpstr; <br>     <br>    if (id &gt;= IDS_TF_FIRST &amp;&amp; id &lt;= IDS_TF_LAST) <br>    { <br>        if (NULL != ghWndStatus) <br>        { <br>            nIdxFormat = id - IDS_TF_FIRST; <br> <br>            lpstr = (LPSTR)(grgszTimeFormats[nIdxFormat]); <br>             <br>            SendMessage(ghWndStatus, <br>                        SB_SETTEXT, <br>                        SB_PANE_TFMT, <br>                        (LPARAM)lpstr); <br> <br>        } <br> <br>        hMenu = GetMenu(hWnd); <br> <br>        CheckMenuItem(hMenu, gnTimeFormat, MF_UNCHECKED|MF_BYCOMMAND); <br>        CheckMenuItem(hMenu, id, MF_CHECKED|MF_BYCOMMAND); <br> <br>        gnTimeFormat = id; <br>         <br>        /* Force time window to update font and repaint entire time string <br>         */ <br>         <br>        if(ghWndTime)// for when WM_COMMAND is called before WM_CREATE <br>        FORWARD_WM_SIZE(ghWndTime, SIZE_RESTORED, 0, 0, SendMessage); <br>    } <br>    else if (id &gt;= IDM_DEVMIN &amp;&amp; id &lt;= IDM_DEVMAX) <br>    { <br>        hMenu = GetMenu(hWnd); <br>                 <br>        CheckMenuItem(hMenu, guDevice + IDM_DEVICES, MF_UNCHECKED|MF_BYCOMMAND); <br>        guDevice = id - IDM_DEVICES; <br>        CheckMenuItem(hMenu, guDevice + IDM_DEVICES, MF_CHECKED|MF_BYCOMMAND); <br>    } <br>    else switch(id) <br>    { <br>        case IDM_OPEN: <br>            MWnd_OnFileOpen(hWnd); <br>            break; <br>         <br>        case IDM_TOOLBAR: <br>        case IDM_STATUS: <br>            MWnd_OnCommandToggleChild(hWnd, id); <br>            break; <br> <br>        case IDM_AUTOPLAY: <br>            gbAutoPlay = !gbAutoPlay; <br>            CheckMenuItem(GetMenu(hWnd), <br>                          IDM_AUTOPLAY, <br>                          MF_BYCOMMAND|(gbAutoPlay ? MF_CHECKED : MF_UNCHECKED)); <br>            break; <br> <br>        case IDM_PLAY: <br>            FORWARD_WM_COMMAND(ghWndTime, IDM_PLAY, 0, 0, SendMessage); <br>         <br>if (gpSeq-&gt;uState != SEQ_S_OPENED) <br>DPF(1, "IDM_PLAY: State %u", gpSeq-&gt;uState); <br>             <br>            if (PrerollAndWait(hWnd))                    <br>            seqStart(gpSeq); <br> <br>            SyncUI(hWnd); <br>            break; <br> <br>        case IDM_STOP: <br>            FORWARD_WM_COMMAND(ghWndTime, IDM_STOP, 0, 0, SendMessage); <br> <br>            seqStop(gpSeq); <br>            SyncUI(hWnd); <br>            break; <br> <br>        case IDM_PAUSE: <br>            if (gpSeq-&gt;uState == SEQ_S_PAUSED) <br>            { <br>                seqRestart(gpSeq); <br>            } <br>            else <br>            { <br>                seqPause(gpSeq); <br>            } <br> <br>            SyncUI(hWnd); <br>            break; <br> <br>        case IDM_SYNCUI: <br>            SyncUI(hWnd); <br>            break; <br>             <br>        case IDM_EXIT: <br>            SendMessage(hWnd, WM_CLOSE, 0, 0L); <br>            break; <br>    } <br>} <br>                                    <br>/***************************************************************************** <br>* <br>* MWnd_OnDestroy <br>* <br>* Handle WM_DESTROY message to main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* <br>* Our main application window has been closed. PostQuitMessage so the main <br>* message loop will exit and the app can terminate. <br>* <br>*****************************************************************************/ <br>PRIVATE VOID FNLOCAL MWnd_OnDestroy( <br>    HWND                    hWnd) <br>{ <br>    seqStop(gpSeq); <br>    PostQuitMessage(0); <br>} <br> <br>/***************************************************************************** <br>* <br>* MWnd_WndProc <br>* <br>* Window procedure for main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* UINT msg                  - Message code <br>* WPARAM wParam             - Message specific parameter <br>* LPARAM lParam             - Message specific parameter </code></pre>
<p>
</p>
<pre><code>* <br>* Dispatch messages we care about to the appropriate handler, else just <br>* call DefWindowProc. <br>* <br>* Note this use of message cracker macros from windowsx.h. Using these <br>* macros will shield you from the differences between Win16 and Win32; <br>* if your app is cross-compilable, you should use these and save yourself <br>* some headaches! <br>* <br>*****************************************************************************/ <br>LRESULT CALLBACK MWnd_WndProc( <br>    HWND                    hWnd, <br>    UINT                    msg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam) <br>{ <br>    switch( msg ) <br>    { <br>        HANDLE_MSG(hWnd, WM_CREATE,         MWnd_OnCreate); <br>        HANDLE_MSG(hWnd, WM_GETMINMAXINFO,  MWnd_OnGetMinMaxInfo); <br>        HANDLE_MSG(hWnd, WM_SIZE,           MWnd_OnSize); <br>        HANDLE_MSG(hWnd, WM_PAINT,          MWnd_OnPaint); <br>        HANDLE_MSG(hWnd, WM_DROPFILES,      MWnd_OnDropFiles); <br>        HANDLE_MSG(hWnd, WM_COMMAND,        MWnd_OnCommand); <br>        HANDLE_MSG(hWnd, WM_DESTROY,        MWnd_OnDestroy); <br> <br>        case MMSG_DONE: <br>            FORWARD_WM_COMMAND(ghWndTime, IDM_STOP, 0, 0, SendMessage); <br>             <br>if (gpSeq-&gt;uState != SEQ_S_OPENED) <br>DPF(1, "MMSG_DONE and state %u", gpSeq-&gt;uState); <br> <br>            SyncUI(hWnd); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
