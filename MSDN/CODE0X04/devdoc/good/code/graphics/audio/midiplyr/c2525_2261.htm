<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TIMEWND.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2539"></a>TIMEWND.C</h2>
<pre><code>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>****************************************************************************** <br>* <br>* TimeWnd.C <br>* <br>* Message handlers and other code for the time window <br>* <br>*****************************************************************************/ <br> <br>#pragma warning(disable:4756) <br> <br>#define _INC_SHELLAPI <br>#include &lt;windows.h&gt; <br>#undef _INC_SHELLAPI <br> <br>#include &lt;shellapi.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>#include "debug.h" <br> <br>#include "MIDIPlyr.H" <br> <br>/* Into gszFormatHMS[] <br>*/ <br>#define HOUR_INDEX          0 <br>#define MIN_INDEX           3 <br>#define SEC_INDEX           6 <br> <br>#define MIN_SEP_INDEX       2 <br>#define SEC_SEP_INDEX       5 <br> <br>#define TIMER_ID            0 <br>#define TIMER_INTERVAL      100 <br> <br>PRIVATE HFONT           ghFont          = NULL; <br>PRIVATE char BCODE      gszFormatHMS[]  = "44:44:44"; <br>PRIVATE char BCODE      gszFormatTicks[]= "444444444"; <br> <br>#define MAX_CBFMT (max(sizeof(gszFormatHMS), sizeof(gszFormatTicks))) <br> <br>PRIVATE BOOL            gbRepaint       = TRUE; <br>PRIVATE int             gnPosY; <br>PRIVATE int             ganPosX[MAX_CBFMT]; <br> <br>PRIVATE int             gnTimerOn       = 0; <br> <br>PRIVATE VOID NEAR PASCAL PaintTime(HDC hDC); <br> <br>PRIVATE BOOL NEAR PASCAL TWnd_OnCreate(HWND hWnd, CREATESTRUCT FAR* lpCreateStruct); <br>PRIVATE VOID NEAR PASCAL TWnd_OnSize(HWND hWnd, UINT state, int cx, int cy); <br>PRIVATE VOID NEAR PASCAL TWnd_OnPaint(HWND hWnd); <br>PRIVATE VOID NEAR PASCAL TWnd_OnCommand(HWND hWnd, int id, HWND hWndCtl, UINT codeNotify); <br>PRIVATE VOID NEAR PASCAL TWnd_OnDestroy(HWND hWnd); <br>PRIVATE VOID NEAR PASCAL TWnd_OnTimer(HWND hWnd, UINT id); <br> <br>/***************************************************************************** <br>* <br>* PaintTime <br>* <br>* Paint the current sequencer time into the time window. <br>* <br>* HWND hDC                  - DC to paint time into <br>* <br>* Repaint the time. Unless gbRepaint is set, just repaint the sections <br>* of the time that need updating. Clear gbRepaint when done. <br>* <br>*****************************************************************************/ <br>static UINT oldh = 0; <br>static UINT oldm = 0; <br>static UINT olds = 0; <br> <br>static char szOldTicks[MAX_CBFMT]; <br> <br>PRIVATE VOID NEAR PASCAL PaintTime( <br>    HDC                     hDC)            <br>{ <br>    TICKS                   tkTime; <br>    DWORD                   msTime; <br>    int                     ii; <br>    int                     cb; <br>    char                    szWork[MAX_CBFMT]; <br>    HFONT                   hFont; <br>    UINT                    h; <br>    UINT                    m; <br>    UINT                    s; <br>    BOOL                    fRepaintedSec; <br>    BOOL                    fRepaintedMin; <br> <br>    if (MMSYSERR_NOERROR != seqTime(gpSeq, &amp;tkTime)) <br>        return; <br> <br>    SetBkColor(hDC, RGB(0xFF, 0xFF, 0xFF)); <br>    hFont = SelectObject(hDC, ghFont); <br>     <br>    if (gnTimeFormat == IDS_TICKS) <br>    { <br>        wsprintf(szWork, "%9lu", (DWORD)tkTime); <br> <br>        for (ii = 0; ii &lt; 9; ii++) <br>        { <br>            if (gbRepaint || szOldTicks[ii] != szWork[ii]) <br>                EmbossedTextOut( <br>                                hDC, <br>                                ganPosX[ii], <br>                                gnPosY, <br>                                szWork+ii, <br>                                1, <br>                                (COLORREF)-1, <br>                                (COLORREF)-1, <br>                                3, <br>                                3); <br>            szOldTicks[ii] = szWork[ii]; <br>        } <br>    } <br>    else <br>    { <br>        msTime = seqTicksToMillisecs(gpSeq, tkTime) / 1000L; <br> <br>        h = (UINT)(msTime / 3600L);    msTime %= 3600L; <br>        m = (UINT)(msTime / 60L);      msTime %= 60L; <br>        s = (UINT)msTime; <br> <br>        cb = lstrlen(gszFormatHMS); <br> <br>        if (gbRepaint || h != oldh) <br>        { <br>            szWork[0] = '0' + (char)(h / 10); <br>            szWork[1] = '0' + (char)(h % 10); <br>            EmbossedTextOut( <br>                            hDC, <br>                            ganPosX[HOUR_INDEX], <br>                            gnPosY, <br>                            szWork, <br>                            2, <br>                            (COLORREF)-1, <br>                            (COLORREF)-1, <br>                            3, <br>                            3); <br>            oldh = h; <br>        } <br> <br>        fRepaintedMin = FALSE; <br>        if (gbRepaint || m != oldm) <br>        { <br>            szWork[0] = gszFormatHMS[MIN_SEP_INDEX]; <br>            szWork[1] = '0' + (char)(m / 10); <br>            szWork[2] = '0' + (char)(m % 10); <br>            EmbossedTextOut( <br>                            hDC, <br>                            ganPosX[MIN_SEP_INDEX], <br>                            gnPosY, <br>                            szWork, <br>                            3, <br>                            (COLORREF)-1, <br>                            (COLORREF)-1, <br>                            3, <br>                            3); <br>            oldm = m; <br>            fRepaintedMin = TRUE; <br>        } <br> <br>        fRepaintedSec = FALSE; <br>        if (gbRepaint || s != olds) <br>        { <br>            szWork[0] = gszFormatHMS[SEC_SEP_INDEX]; <br>            szWork[1] = '0' + (char)(s / 10); <br>            szWork[2] = '0' + (char)(s % 10); <br>            EmbossedTextOut( <br>                            hDC, <br>                            ganPosX[SEC_SEP_INDEX], <br>                            gnPosY, <br>                            szWork, <br>                            3, <br>                            (COLORREF)-1, <br>                            (COLORREF)-1, <br>                            3, <br>                            3); <br>            olds = s; <br>            fRepaintedSec = TRUE; <br>        } <br> <br>        /* If we're doing a full repaint, then update the separators <br>         */ <br>        if (gbRepaint) <br>            for (ii=0; ii &lt; cb; ii++) <br>                if (!isdigit(gszFormatHMS[ii])) <br>                { <br>                    if (SEC_SEP_INDEX == ii &amp;&amp; fRepaintedSec) <br>                        continue; <br> <br>                    if (MIN_SEP_INDEX == ii &amp;&amp; fRepaintedMin) <br>                        continue; <br> <br>                    EmbossedTextOut( <br>                                    hDC, <br>                                    ganPosX[ii], <br>                                    gnPosY, <br>                                    gszFormatHMS+ii, <br>                                    1, <br>                                    (COLORREF)-1, <br>                                    (COLORREF)-1, <br>                                    3, <br>                                    3); <br>                } <br>    } <br>     <br>    gbRepaint = FALSE; <br>    SelectObject(hDC, hFont); <br>} <br> <br>/***************************************************************************** <br>* <br>* TWnd_OnCreate <br>* <br>* Handle WM_CREATE message to time window. <br>* <br>* HWND hWnd                 - Window handle <br>* CREATESTRUCT FAR* lpCreateStruct <br>*                           - Pointer to creation parameters for the window. <br>* <br>* Returns TRUE on success. Returning FALSE will cause the window to be <br>* destroyed and the application will exit. <br>* <br>* Just return TRUE so the window will be created. <br>* <br>*****************************************************************************/ <br>BOOL NEAR PASCAL TWnd_OnCreate( <br>    HWND                    hWnd, <br>    CREATESTRUCT FAR*       lpCreateStruct) <br>{ <br>    return TRUE; <br>} <br> <br>/***************************************************************************** <br>* <br>* TWnd_OnSize <br>* <br>* Handle WM_SIZE message to time window. <br>* <br>* HWND hWnd                 - Window handle <br>* UINT state                - Some SIZE_xxx code indicating what type of <br>*                             size operation this is. <br>* int  cx, cy               - New x and y size of the window's client area. <br>* <br>* Get the new client rect into grcTWnd. <br>* Destroy and recreate the font scaled to show the time at the correct size. <br>* Force the time to fully repaint. <br>* <br>*****************************************************************************/ <br>VOID NEAR PASCAL TWnd_OnSize( <br>    HWND                    hWnd, <br>    UINT                    state, <br>    int                     cx, <br>    int                     cy) <br>{ <br>    HDC                     hDC; <br>     <br>    GetClientRect(hWnd, &amp;grcTWnd); <br> <br>    if (ghFont != (HFONT)NULL) <br>        DeleteObject(ghFont); <br> <br>    hDC = GetDC(hWnd); <br>    ghFont = CreateScaledFont(hDC, <br>                              &amp;grcTWnd, <br>                              (gnTimeFormat == IDS_TICKS) ? gszFormatTicks : gszFormatHMS, <br>                              ganPosX, <br>                              &amp;gnPosY); <br>    ReleaseDC(hWnd, hDC); <br> <br>    gbRepaint = TRUE; <br>    InvalidateRect(hWnd, NULL, TRUE); <br>} <br> <br> <br>/***************************************************************************** <br>* <br>* TWnd_OnPaint <br>* <br>* Handle WM_PAINT message to time window. <br>* <br>* HWND hWnd                 - Window handle <br>* <br>* Repaint the 3D inset borders around the edge of the client area. <br>* Repaint the time. <br>* <br>*****************************************************************************/ <br>VOID NEAR PASCAL TWnd_OnPaint( HWND hWnd) { PAINTSTRUCT ps; HDC hDC; <br>HBRUSH hBrOld; int nWidth; int nHeight; <br> <br>    RECT                    rc; <br> <br>    GetClientRect(hWnd, &amp;rc); <br>    nWidth  = rc.right; <br>    nHeight = rc.bottom; <br>     <br>    hDC = BeginPaint(hWnd, &amp;ps); <br> <br>    hBrOld = (HBRUSH)SelectObject(hDC, GetStockObject(GRAY_BRUSH)); <br>    PatBlt(hDC, 0, 0, 1, nHeight-1, PATCOPY); <br>    PatBlt(hDC, 1, 0, nWidth-2, 1, PATCOPY); <br> <br>    SelectObject(hDC, GetStockObject(BLACK_BRUSH)); <br>    PatBlt(hDC, 1, 1, 1, nHeight-3, PATCOPY); <br>    PatBlt(hDC, 2, 1, nWidth-4, 1, PATCOPY); <br> <br>    SelectObject(hDC, GetStockObject(WHITE_BRUSH)); <br>    PatBlt(hDC, rc.right-1, 0, 1, nHeight-1, PATCOPY); <br>    PatBlt(hDC, 0, rc.bottom-1, nWidth, 1, PATCOPY); <br> <br>    SelectObject(hDC, GetStockObject(LTGRAY_BRUSH)); <br>    PatBlt(hDC, rc.right-2, 1, 1, nHeight-2, PATCOPY); <br>    PatBlt(hDC, 1, rc.bottom-2, nWidth-2, 1, PATCOPY); <br>     <br>    SelectObject(hDC, hBrOld); <br> <br>    gbRepaint = TRUE; <br>    PaintTime(hDC); <br> <br>    EndPaint(hWnd, &amp;ps); <br>} <br> <br>/***************************************************************************** <br>* <br>* TWnd_OnCommand <br>* <br>* Handle WM_COMMAND message to the time window. <br>* <br>* HWND hWnd                 - Window handle <br>* int id                    - id of control or menu causing WM_COMMAND <br>* HWND hwndCtl              - Window handle of child control, if any <br>* UINT codeNotify           - Notification code if this message is from a <br>*                             control. <br>* <br>* We will receive IDM_PLAY and IDM_STOP messages forwarded from the main <br>* application window whenver playback starts or stops. Use these messages <br>* to create or kill a timer which will be used to update the time. <br>*  <br>*****************************************************************************/ <br>VOID NEAR PASCAL TWnd_OnCommand( <br>    HWND                    hWnd, <br>    int                     id, <br>    HWND                    hWndCtl, <br>    UINT                    codeNotify) <br>{ <br>    switch(id) <br>    { <br>        case IDM_PLAY: <br>            if (0 == gnTimerOn) <br>            { <br>                gnTimerOn++; <br>                SetTimer(hWnd, TIMER_ID, TIMER_INTERVAL, 0); <br>            } <br> <br>            UpdateWindow(hWnd); <br>            break; <br> <br>        case IDM_STOP: <br>            if (0 == gnTimerOn) <br>            { <br>                gnTimerOn--; <br>                KillTimer(hWnd, TIMER_ID); <br>            } <br>             <br>            UpdateWindow(hWnd); <br>            break; <br>    } <br>} <br> <br>/***************************************************************************** <br>* <br>* TWnd_OnDestroy <br>* <br>* Handle WM_DESTROY message to the time window. <br>* <br>* HWND hWnd                 - Window handle <br>* <br>* If we're being destroyed and the timer is still running, stop it. <br>*  <br>*****************************************************************************/ <br>VOID NEAR PASCAL TWnd_OnDestroy( <br>    HWND                    hWnd) <br>{ <br>    if (gnTimerOn) <br>    { <br>        KillTimer(hWnd, TIMER_ID); <br>    } <br>} <br> <br>/***************************************************************************** <br>* <br>* TWnd_OnTimer <br>* <br>* Handle WM_TIMER message to the time window. <br>* <br>* HWND hWnd                 - Window handle <br>* UINT id                   - Timer ID <br>* <br>* Update the time. <br>*  <br>*****************************************************************************/ <br>PRIVATE VOID NEAR PASCAL TWnd_OnTimer( <br>    HWND                    hWnd, <br>    UINT                    id) <br>{ <br>    HDC                     hDC; <br> <br>    hDC = GetDC(hWnd); <br>    PaintTime(hDC); <br>    ReleaseDC(hWnd, hDC); <br>} <br> <br>/***************************************************************************** <br>* <br>* TWnd_WndProc <br>* <br>* Window procedure for main application window. <br>* <br>* HWND hWnd                 - Window handle <br>* UINT msg                  - Message code <br>* WPARAM wParam             - Message specific parameter <br>* LPARAM lParam             - Message specific parameter <br>* <br>* Dispatch messages we care about to the appropriate handler, else just <br>* call DefWindowProc. <br>* <br>* Note this use of message cracker macros from windowsx.h. Using these <br>* macros will shield you from the differences between Win16 and Win32; <br>* if your app is cross-compilable, you should use these and save yourself <br>* some headaches! <br>* <br>*****************************************************************************/ <br>LRESULT CALLBACK TWnd_WndProc( <br>    HWND                    hWnd, <br>    UINT                    msg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam) <br>{ <br>    switch( msg ) <br>    { <br>        HANDLE_MSG(hWnd, WM_CREATE,         TWnd_OnCreate); <br>        HANDLE_MSG(hWnd, WM_SIZE,           TWnd_OnSize); <br>        HANDLE_MSG(hWnd, WM_PAINT,          TWnd_OnPaint); <br>        HANDLE_MSG(hWnd, WM_COMMAND,        TWnd_OnCommand); <br>        HANDLE_MSG(hWnd, WM_DESTROY,        TWnd_OnDestroy); <br>        HANDLE_MSG(hWnd, WM_TIMER,          TWnd_OnTimer); <br> <br>        default: <br>            return DefWindowProc(hWnd, msg, wParam, lParam); <br>    } <br> <br>    return 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
