<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UIUTILS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2540"></a>UIUTILS.C</h2>
<pre><code>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>****************************************************************************** <br>* <br>* UiUtils.C <br>* <br>* UI utility routines <br>* <br>*****************************************************************************/ <br> <br>#pragma warning(disable:4756) <br> <br>#define _INC_SHELLAPI <br>#include &lt;windows.h&gt; <br>#undef _INC_SHELLAPI <br> <br>#include &lt;shellapi.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;commctrl.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>#include "debug.h" <br> <br>#include "MIDIPlyr.H" <br> <br>static char BCODE           gszErrFmt[]             = "%s:\n%s"; <br>static char BCODE           gszFace[]               = "arial"; <br>static char                 gszErrDescTxt[256]; <br>static char                 gszErrCodeTxt[256]; <br>static char                 gszErrStr[512]; <br> <br>/***************************************************************************** <br>* <br>* Error <br>* <br>* Puts up a general error dialog <br>* <br>* hWnd                      - Handle of the owner window <br>* nErrDesc                  - id into the string table of the message <br>* mmrc                      - Return code from MMSYSTEM or lower layer <br>*                             which caused the error. <br>* <br>* Just formats and puts up an error dialog. <br>* <br>* For convenience, all of the sequencer functions return MMSYSERR_ or <br>* MCIERR_ codes, so we can use mciGetErrorString instead of inventing <br>* our own error messages again. <br>* <br>*****************************************************************************/ <br>VOID FNLOCAL Error( <br>    HWND                    hWnd,                              <br>    int                     nErrDesc, <br>    MMRESULT                mmrc) <br>{ <br>    LoadString(ghInst, nErrDesc, gszErrDescTxt, sizeof(gszErrDescTxt)); <br>    mciGetErrorString(mmrc, gszErrCodeTxt, sizeof(gszErrCodeTxt)); <br>     <br>    wsprintf(gszErrStr, gszErrFmt, (LPSTR)gszErrDescTxt, (LPSTR)gszErrCodeTxt); <br>    MessageBox(hWnd, gszErrStr, gszAppLongName, MB_ICONEXCLAMATION|MB_OK); <br>} <br> <br>/***************************************************************************** <br>* <br>* MessagePump <br>* <br>* Process messages <br>* <br>* This function is called when, in certain cases, we need to wait for a <br>* window callback to complete. Since callbacks are posted, not sent, we <br>* need to process messages while waiting. <br>* <br>* Note that some documentation refers to this operation as a 'directed <br>* yield' if messages are being processed for a particular window. This <br>* is misleading; Yield() merely allows other tasks in the system to run <br>* and does absolutely nothing to the message queue. <br>* <br>*****************************************************************************/ <br>VOID NEAR PASCAL MessagePump( <br>    VOID) <br>{ <br>    MSG                     msg; <br> <br>    while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>    { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg);  <br>    } <br>} <br> <br>/***************************************************************************** <br>* <br>* EmbossedTextOut <br>* <br>* Draw embossed text in the given device context <br>* <br>* hDC                       - hDC to draw in <br>* x, y                      - Upper left corner of text <br>* lpsz                      - Pointer to the text <br>* cb                        - Length of text <br>* crText                    - Color for text face <br>* crShadow                  - Color for text shadow <br>* cx, cy                    - Offset for shadow <br>* <br>* The text will be drawn with the currently selected font. <br>* <br>* If cb == -1, the lstrlen(lpsz) will be used. <br>* <br>* If crText == -1, COLOR_BTNTEXT will be used. <br>* <br>* If crShadow == -1, COLOR_BTNSHADOW will be used. <br>* <br>*****************************************************************************/ <br>VOID NEAR PASCAL EmbossedTextOut( <br>    HDC                     hDC, <br>    int                     x, <br>    int                     y, <br>    LPSTR                   lpsz, <br>    UINT                    cb, <br>    COLORREF                crText, <br>    COLORREF                crShadow, <br>    int                     cx, <br>    int                     cy) <br>{ <br>    COLORREF                crOld; <br>    UINT                    uMode; <br>    SIZE                    sizeText; <br>    RECT                    rcText; <br> <br>    /* If text length is -1, use lstrlen to get the length <br>    ** of the text. <br>    */ <br>    if (cb == -1) <br>        cb = lstrlen(lpsz); <br> <br>    /* If the shadow or text color is -1, use the <br>    ** system color for that one. <br>    */ <br>    if (crShadow == (COLORREF)-1) <br>        crShadow = GetSysColor (COLOR_BTNSHADOW); <br>    if (crText == (COLORREF)-1) <br>        crText = GetSysColor (COLOR_BTNTEXT); <br> <br>    /* setup the DC, saving off the old values <br>    */ <br>    uMode = SetBkMode(hDC, OPAQUE); <br>    crOld = SetTextColor(hDC, crShadow); <br> <br>    /* Draw the text at the desired offset using the <br>    ** shadow color, then again at the normal position <br>    ** using the text color.  This will the text an 'Embossed' <br>    ** or 'drop shadowed' look depending on what shadow color <br>    ** and offset are used. <br>    */ <br>    GetTextExtentPoint32(hDC, lpsz, cb, &amp;sizeText); <br>    rcText.left   = x;    rcText.right  = x+cx+sizeText.cx;  <br>    rcText.top    = y;    rcText.bottom = y+cy+sizeText.cy;  <br>    ExtTextOut(hDC, x+cx, y+cy, ETO_OPAQUE, &amp;rcText, lpsz, cb, NULL); <br>    SetBkMode(hDC, TRANSPARENT); <br>    SetTextColor(hDC, crText); <br>    ExtTextOut(hDC, x, y, 0, NULL, lpsz, cb, NULL); <br> <br>    /* restore the DC <br>    */ <br>    SetTextColor(hDC, crOld); <br>    SetBkMode(hDC, uMode); <br>} <br> <br>/***************************************************************************** <br>* <br>* CreateScaledFont <br>* <br>* Create a font scaled so that the given string will fit in the given <br>* rect, but be as large as possible while maintaining correct aspect ratio. <br>* <br>* hDC                       - DC to calculate font for <br>* lpRect                    - Rectangle to fit text into <br>* lpszFormat                - Format string to fit into rect <br>* anPosX[]                  - Will contain the X coordinates for each char <br>* anPosY                    - Will contain the Y coordinate for the string <br>* <br>* Returns HFONT or NULL if one could not be created  <br>* <br>*****************************************************************************/ <br>HFONT NEAR PASCAL CreateScaledFont( <br>    HDC                     hDC, <br>    LPRECT                  lpRect, <br>    LPSTR                   lpszFormat, <br>    int                     anPosX[], <br>    int*                    nPosY)                                                         <br>{ <br>    LOGFONT                 lf; <br>    HFONT                   hFont; <br>    HFONT                   h; <br>    LONG                    FormatWidth; <br>    LONG                    ScaledClientWidth; <br>    LONG                    ScaledClientHeight; <br>    LONG                    AspectN; <br>    LONG                    AspectD; <br>    int                     nPosX; <br>    UINT                    cb; <br>    UINT                    ii; <br>    UINT                    jj; <br>    SIZE                    size; <br> <br>    ScaledClientHeight =  ((lpRect-&gt;bottom - lpRect-&gt;top)) * 3 / 4; <br>    ScaledClientWidth  =  ((lpRect-&gt;right  - lpRect-&gt;left)) * 3 / 4; <br>     <br>    _fmemset(&amp;lf, 0, sizeof(lf)); <br>    lf.lfHeight         = -(int)ScaledClientHeight; <br>    lf.lfWeight         = FW_BOLD; <br>    lf.lfCharSet        = ANSI_CHARSET; <br>    lf.lfClipPrecision  = CLIP_DEFAULT_PRECIS; <br>    lf.lfQuality        = PROOF_QUALITY; <br>    lf.lfPitchAndFamily = FF_ROMAN|DEFAULT_PITCH; <br>    lstrcpy(lf.lfFaceName, gszFace); <br>     <br>    hFont = CreateFontIndirect(&amp;lf); <br>    h = SelectObject(hDC, hFont); <br> <br>    cb = lstrlen(lpszFormat); <br>    GetTextExtentPoint(hDC, lpszFormat, cb, &amp;size); <br> <br>    AspectN = (LONG)size.cx; <br>    AspectD = (LONG)size.cy; <br>     <br>    FormatWidth = (ScaledClientHeight*AspectN)/AspectD; <br> <br>    if (FormatWidth &gt; ScaledClientWidth) <br>    { <br>        ScaledClientHeight = <br>            (ScaledClientWidth*AspectD)/AspectN; <br>    SelectObject(hDC, h); <br>        DeleteObject(hFont); <br>         <br>        lf.lfHeight = -(int)ScaledClientHeight; <br> <br>        hFont = CreateFontIndirect(&amp;lf); <br> <br>        SelectObject(hDC, hFont); <br>        GetTextExtentPoint(hDC, lpszFormat, cb, &amp;size); <br>    } <br>     <br>    *nPosY  = grcTWnd.top  + (grcTWnd.bottom- grcTWnd.top  - size.cy)/2; <br>    nPosX   = grcTWnd.left + (grcTWnd.right - grcTWnd.left - size.cx)/2; <br> <br>    ii = 0; <br>    for (jj=0; jj &lt; cb; jj++) <br>    { <br>        if (jj != 0) <br>            GetTextExtentPoint(hDC, lpszFormat, jj, &amp;size); <br>        else <br>            size.cx = 0; <br>         <br>        anPosX[ii++] = nPosX + size.cx; <br>    } <br> <br>    SelectObject(hDC, h); <br> <br>    return hFont; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
