<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SMF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2535"></a>SMF.C</h2>
<pre><code>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>****************************************************************************** <br>* <br>* SMF.C <br>* <br>* MIDI File access routines. <br>* <br>*****************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;memory.h&gt; <br>#include "muldiv32.h"  <br>#include "smf.h" <br>#include "smfi.h" <br>#include "debug.h" <br> <br>PRIVATE SMFRESULT FNLOCAL smfInsertParmData( <br>    PSMF                    pSmf, <br>    TICKS                   tkDelta,                                             <br>    LPMIDIHDR               lpmh); <br> <br>/***************************************************************************** <br>* <br>* smfOpenFile <br>* <br>* This function opens a MIDI file for access.  <br>* <br>* psofs                     - Specifies the file to open and associated <br>*                             parameters. Contains a valid HSMF handle <br>*                             on success. <br>* <br>* Returns <br>*   SMF_SUCCESS The specified file was opened. <br>* <br>*   SMF_OPEN_FAILED The specified file could not be opened because it <br>*     did not exist or could not be created on the disk. <br>* <br>*   SMF_INVALID_FILE The specified file was corrupt or not a MIDI file. <br>*  <br>*   SMF_NO_MEMORY There was insufficient memory to open the file. <br>* <br>*   SMF_INVALID_PARM The given flags or time division in the <br>*     SMFOPENFILESTRUCT were invalid. <br>*  <br>*****************************************************************************/ <br>SMFRESULT FNLOCAL smfOpenFile( <br>    PSMFOPENFILESTRUCT      psofs) <br>{ <br>    HMMIO                   hmmio = (HMMIO)NULL; <br>    PSMF                    pSmf; <br>    SMFRESULT               smfrc = SMF_SUCCESS; <br>    MMIOINFO                mmioinfo; <br>    MMCKINFO                ckRIFF; <br>    MMCKINFO                ckDATA; <br> <br>    assert(psofs != NULL); <br>    assert(psofs-&gt;pstrName != NULL); <br>     <br>    /* Verify that the file can be opened or created <br>    */ <br>    _fmemset(&amp;mmioinfo, 0, sizeof(mmioinfo)); <br> <br>    hmmio = mmioOpen(psofs-&gt;pstrName, &amp;mmioinfo, MMIO_READ|MMIO_ALLOCBUF); <br>    if ((HMMIO)NULL == hmmio) <br>    { <br>        DPF(1, "smfOpenFile: mmioOpen failed!"); <br>        return SMF_OPEN_FAILED; <br>    } <br> <br>    /* Now see if we can create the handle structure <br>    */ <br>    pSmf = (PSMF)LocalAlloc(LPTR, sizeof(SMF)); <br>    if (NULL == pSmf) <br>    { <br>        DPF(1, "smfOpenFile: LocalAlloc failed!"); <br>        smfrc = SMF_NO_MEMORY; <br>        goto smf_Open_File_Cleanup; <br>    } <br> <br>    lstrcpy(pSmf-&gt;szName, psofs-&gt;pstrName); <br>    pSmf-&gt;fdwSMF = 0; <br>    pSmf-&gt;pTempoMap = NULL; <br> <br>    /* Pull the entire file into a block of memory.  <br>    */ <br>    _fmemset(&amp;ckRIFF, 0, sizeof(ckRIFF)); <br>     <br>    if (0 == mmioDescend(hmmio, &amp;ckRIFF, NULL, MMIO_FINDRIFF) &amp;&amp; <br>        ckRIFF.fccType == FOURCC_RMID) <br>    { <br>        ckDATA.ckid = FOURCC_data; <br>         <br>        if (0 == mmioDescend(hmmio, &amp;ckDATA, &amp;ckRIFF, MMIO_FINDCHUNK)) <br>        { <br>            pSmf-&gt;cbImage   = ckDATA.cksize; <br>        } <br>        else <br>        { <br>            DPF(1, "smfOpenFile: Could not descend into RIFF DATA chunk!"); <br>            smfrc = SMF_INVALID_FILE; <br>            goto smf_Open_File_Cleanup; <br>        } <br>    } <br>    else <br>    { <br>        mmioSeek(hmmio, 0L, SEEK_SET); <br>         <br>        pSmf-&gt;cbImage = mmioSeek(hmmio, 0L, SEEK_END); <br>        mmioSeek(hmmio, 0L, SEEK_SET); <br>    } <br>     <br>    if (NULL == (pSmf-&gt;hpbImage = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, pSmf-&gt;cbImage))) <br>    { <br>        DPF(1, "smfOpenFile: No memory for image! [%08lX]", pSmf-&gt;cbImage); <br>        smfrc = SMF_NO_MEMORY; <br>        goto smf_Open_File_Cleanup; <br>    } <br>  <br>    if (pSmf-&gt;cbImage != (DWORD)mmioRead(hmmio, pSmf-&gt;hpbImage, pSmf-&gt;cbImage)) <br>    { <br>        DPF(1, "smfOpenFile: Read error on image!"); <br>        smfrc = SMF_INVALID_FILE; <br>        goto smf_Open_File_Cleanup; <br>    } <br> <br>    /* If the file exists, parse it just enough to pull out the header and <br>    ** build a track index. <br>    */ <br>    smfrc = smfBuildFileIndex((PSMF BSTACK *)&amp;pSmf); <br>    if (MMSYSERR_NOERROR != smfrc) <br>    { <br>        DPF(1, "smfOpenFile: smfBuildFileIndex failed! [%lu]", (DWORD)smfrc); <br>    } <br> <br>smf_Open_File_Cleanup: <br> <br>    mmioClose(hmmio, 0); <br> <br>    if (SMF_SUCCESS != smfrc) <br>    { <br>        if (NULL != pSmf) <br>        { <br>            if (NULL != pSmf-&gt;hpbImage) <br>            { <br>                GlobalFreePtr(pSmf-&gt;hpbImage); <br>            } <br>             <br>            LocalFree((HLOCAL)pSmf); <br>        } <br>    } <br>    else <br>    { <br>        psofs-&gt;hSmf = (HSMF)pSmf; <br>    } <br>     <br>    return smfrc; <br>} <br> <br>/***************************************************************************** <br>* <br>* smfCloseFile <br>* <br>* This function closes an open MIDI file. <br>* <br>* hSmf                      - The handle of the open file to close. <br>* <br>* Returns <br>*   SMF_SUCCESS The specified file was closed. <br>*   SMF_INVALID_PARM The given handle was not valid. <br>* <br>* Any track handles opened from this file handle are invalid after this <br>* call. <br>*         <br>*****************************************************************************/ <br>SMFRESULT FNLOCAL smfCloseFile( <br>    HSMF                    hSmf) <br>{ <br>    PSMF                    pSmf        = (PSMF)hSmf; <br>     <br>    assert(pSmf != NULL); <br>     <br>    /* <br>    ** Free up handle memory  <br>    */ <br>     <br>    if (NULL != pSmf-&gt;hpbImage) <br>        GlobalFreePtr(pSmf-&gt;hpbImage); <br>     <br>    LocalFree((HLOCAL)pSmf); <br>     <br>    return SMF_SUCCESS; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfGetFileInfo This function gets information about the MIDI file. <br>* <br>* hSmf                      - Specifies the open MIDI file to inquire about. <br>* <br>* psfi                      - A structure which will be filled in with <br>*                             information about the file. <br>* <br>* Returns <br>*   SMF_SUCCESS Information was gotten about the file. <br>*   SMF_INVALID_PARM The given handle was invalid. <br>* <br>*****************************************************************************/ <br>SMFRESULT FNLOCAL smfGetFileInfo( <br>    HSMF                    hSmf, <br>    PSMFFILEINFO            psfi) <br>{ <br>    PSMF                    pSmf = (PSMF)hSmf; <br> <br>    assert(pSmf != NULL); <br>    assert(psfi != NULL); <br> <br>    /*  <br>    ** Just fill in the structure with useful information. <br>    */ <br>    psfi-&gt;dwTracks      = pSmf-&gt;dwTracks; <br>    psfi-&gt;dwFormat      = pSmf-&gt;dwFormat; <br>    psfi-&gt;dwTimeDivision= pSmf-&gt;dwTimeDivision; <br>    psfi-&gt;tkLength      = pSmf-&gt;tkLength; <br>     <br>    return SMF_SUCCESS; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfTicksToMillisecs <br>* <br>* This function returns the millisecond offset into the file given the <br>* tick offset. <br>* <br>* hSmf                      - Specifies the open MIDI file to perform <br>*                             the conversion on. <br>* <br>* tkOffset                  - Specifies the tick offset into the stream <br>*                             to convert. <br>* <br>* Returns the number of milliseconds from the start of the stream. <br>* <br>* The conversion is performed taking into account the file's time division and <br>* tempo map from the first track. Note that the same millisecond value <br>* might not be valid at a later time if the tempo track is rewritten. <br>* <br>*****************************************************************************/ <br>DWORD FNLOCAL smfTicksToMillisecs( <br>    HSMF                    hSmf, <br>    TICKS                   tkOffset) <br>{ <br>    PSMF                    pSmf            = (PSMF)hSmf; <br>    PTEMPOMAPENTRY          pTempo; <br>    UINT                    idx; <br>    UINT                    uSMPTE; <br>    DWORD                   dwTicksPerSec; <br> <br>    assert(pSmf != NULL); <br> <br>    if (tkOffset &gt; pSmf-&gt;tkLength) <br>    { <br>        DPF(1, "sTTM: Clipping ticks to file length!"); <br>        tkOffset = pSmf-&gt;tkLength; <br>    } <br> <br>    /* SMPTE time is easy -- no tempo map, just linear conversion <br>    ** Note that 30-Drop means nothing to us here since we're not <br>    ** converting to a colonized format, which is where dropping <br>    ** happens. <br>    */ <br>    if (pSmf-&gt;dwTimeDivision &amp; 0x8000) <br>    { <br>        uSMPTE = -(int)(char)((pSmf-&gt;dwTimeDivision &gt;&gt; 8)&amp;0xFF); <br>        if (29 == uSMPTE) <br>            uSMPTE = 30; <br>         <br>        dwTicksPerSec = (DWORD)uSMPTE * <br>                        (DWORD)(BYTE)(pSmf-&gt;dwTimeDivision &amp; 0xFF); <br>         <br>        return (DWORD)muldiv32(tkOffset, 1000L, dwTicksPerSec); <br>    } <br>        <br>    /* Walk the tempo map and find the nearest tick position. Linearly <br>    ** calculate the rest (using MATH.ASM) <br>    */ <br> <br>    pTempo = pSmf-&gt;pTempoMap; <br>    assert(pTempo != NULL); <br>     <br>    for (idx = 0; idx &lt; pSmf-&gt;cTempoMap; idx++, pTempo++) <br>        if (tkOffset &lt; pTempo-&gt;tkTempo) <br>            break; <br>    pTempo--; <br> <br>    /* pTempo is the tempo map entry preceding the requested tick offset. <br>    */ <br> <br>    return pTempo-&gt;msBase + muldiv32(tkOffset-pTempo-&gt;tkTempo, <br>                                     pTempo-&gt;dwTempo, <br>                                     1000L*pSmf-&gt;dwTimeDivision); <br>     <br>} <br> <br> <br>/****************************************************************************** <br>* <br>* smfMillisecsToTicks <br>* <br>* This function returns the nearest tick offset into the file given the <br>* millisecond offset. <br>* <br>* hSmf                      - Specifies the open MIDI file to perform the <br>*                             conversion on. <br>* <br>* msOffset                  - Specifies the millisecond offset into the stream <br>*                             to convert. <br>* <br>* Returns the number of ticks from the start of the stream. <br>* <br>* The conversion is performed taking into account the file's time division and <br>* tempo map from the first track. Note that the same tick value <br>* might not be valid at a later time if the tempo track is rewritten. <br>* If the millisecond value does not exactly map to a tick value, then <br>* the tick value will be rounded down. <br>* <br>*****************************************************************************/ <br>TICKS FNLOCAL smfMillisecsToTicks( <br>    HSMF                    hSmf, <br>    DWORD                   msOffset) <br>{ <br>    PSMF                    pSmf            = (PSMF)hSmf; <br>    PTEMPOMAPENTRY          pTempo; <br>    UINT                    idx; <br>    UINT                    uSMPTE; <br>    DWORD                   dwTicksPerSec; <br>    TICKS                   tkOffset; <br> <br>    assert(pSmf != NULL); <br>     <br>    /* SMPTE time is easy -- no tempo map, just linear conversion <br>    ** Note that 30-Drop means nothing to us here since we're not <br>    ** converting to a colonized format, which is where dropping <br>    ** happens. <br>    */ <br>    if (pSmf-&gt;dwTimeDivision &amp; 0x8000) <br>    { <br>        uSMPTE = -(int)(char)((pSmf-&gt;dwTimeDivision &gt;&gt; 8)&amp;0xFF); <br>        if (29 == uSMPTE) <br>            uSMPTE = 30; <br>         <br>        dwTicksPerSec = (DWORD)uSMPTE * <br>                        (DWORD)(BYTE)(pSmf-&gt;dwTimeDivision &amp; 0xFF); <br> <br>        return (DWORD)muldiv32(msOffset, dwTicksPerSec, 1000L); <br>    } <br>     <br>    /* Walk the tempo map and find the nearest millisecond position. Linearly <br>    ** calculate the rest (using MATH.ASM) <br>    */ <br>    pTempo = pSmf-&gt;pTempoMap; <br>    assert(pTempo != NULL); <br>     <br>    for (idx = 0; idx &lt; pSmf-&gt;cTempoMap; idx++, pTempo++) <br>        if (msOffset &lt; pTempo-&gt;msBase) <br>            break; <br>    pTempo--; <br> <br>    /* pTempo is the tempo map entry preceding the requested tick offset. <br>    */ <br> <br>    tkOffset = pTempo-&gt;tkTempo + muldiv32(msOffset-pTempo-&gt;msBase, <br>                                     1000L*pSmf-&gt;dwTimeDivision, <br>                                     pTempo-&gt;dwTempo); <br>     <br>    if (tkOffset &gt; pSmf-&gt;tkLength) <br>    { <br>        DPF(1, "sMTT: Clipping ticks to file length!"); <br>        tkOffset = pSmf-&gt;tkLength; <br>    } <br> <br>    return tkOffset; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfReadEvents <br>* <br>* This function reads events from a track. <br>* <br>* hSmf                      - Specifies the file to read data from. <br>* <br>* lpmh                      - Contains information about the buffer to fill. <br>* <br>* tkMax                     - Specifies a cutoff point in the stream <br>*                             beyond which events will not be read.         <br>* <br>* Return@rdes <br>*   SMF_SUCCESS The events were successfully read. <br>*   SMF_END_OF_TRACK There are no more events to read in this track. <br>*   SMF_INVALID_FILE A disk error occured on the file. <br>*  <br>* @xref &lt;f smfWriteEvents&gt; <br>*****************************************************************************/ <br>SMFRESULT FNLOCAL smfReadEvents( <br>    HSMF                    hSmf, <br>    LPMIDIHDR               lpmh, <br>    TICKS                   tkMax) <br>{ <br>    PSMF                    pSmf = (PSMF)hSmf; <br>    SMFRESULT               smfrc; <br>    EVENT                   event; <br>    LPDWORD                 lpdw; <br>    DWORD                   dwTempo; <br> <br>    assert(pSmf != NULL); <br>    assert(lpmh != NULL); <br> <br>    /*  <br>    ** Read events from the track and pack them into the buffer in polymsg <br>    ** format. <br>    **  <br>    ** If a SysEx or meta would go over a buffer boundry, split it. <br>    */  <br>    lpmh-&gt;dwBytesRecorded = 0; <br>    if (pSmf-&gt;dwPendingUserEvent) <br>    { <br>        smfrc = smfInsertParmData(pSmf, (TICKS)0, lpmh); <br>        if (SMF_SUCCESS != smfrc) <br>        { <br>            DPF(1, "smfInsertParmData() -&gt; %u", (UINT)smfrc); <br>            return smfrc; <br>        } <br>    } <br>     <br>    lpdw = (LPDWORD)(lpmh-&gt;lpData + lpmh-&gt;dwBytesRecorded); <br> <br>    if (pSmf-&gt;fdwSMF &amp; SMF_F_EOF) <br>    { <br>        return SMF_END_OF_FILE; <br>    } <br> <br>    while(TRUE) <br>    { <br>        assert(lpmh-&gt;dwBytesRecorded &lt;= lpmh-&gt;dwBufferLength); <br>         <br>        /* If we know ahead of time we won't have room for the <br>        ** event, just break out now. We need 2 DWORD's for the <br>        ** terminator event and at least 2 DWORD's for any <br>        ** event we might store - this will allow us a full <br>        ** short event or the delta time and stub for a long <br>        ** event to be split. <br>        */ <br>        if (lpmh-&gt;dwBufferLength - lpmh-&gt;dwBytesRecorded &lt; 4*sizeof(DWORD)) <br>        { <br>            break; <br>        } <br> <br>        smfrc = smfGetNextEvent(pSmf, (SPEVENT)&amp;event, tkMax); <br>        if (SMF_SUCCESS != smfrc) <br>        { <br>            /* smfGetNextEvent doesn't set this because smfSeek uses it <br>            ** as well and needs to distinguish between reaching the <br>            ** seek point and reaching end-of-file. <br>            ** <br>            ** To the user, however, we present the selection between <br>            ** their given tkBase and tkEnd as the entire file, therefore <br>            ** we want to translate this into EOF. <br>            */ <br>            if (SMF_REACHED_TKMAX == smfrc) <br>            { <br>                pSmf-&gt;fdwSMF |= SMF_F_EOF; <br>            } <br>             <br>            DPF(1, "smfReadEvents: smfGetNextEvent() -&gt; %u", (UINT)smfrc); <br>            break; <br>        } <br> <br>         <br>        if (MIDI_SYSEX &gt; EVENT_TYPE(event)) <br>        { <br>            *lpdw++ = (DWORD)event.tkDelta; <br>            *lpdw++ = 0; <br>            *lpdw++ = (((DWORD)MEVT_SHORTMSG)&lt;&lt;24) | <br>                      ((DWORD)EVENT_TYPE(event)) | <br>                      (((DWORD)EVENT_CH_B1(event)) &lt;&lt; 8) | <br>                      (((DWORD)EVENT_CH_B2(event)) &lt;&lt; 16); <br>             <br>            lpmh-&gt;dwBytesRecorded += 3*sizeof(DWORD); <br>        } <br>        else if (MIDI_META == EVENT_TYPE(event) &amp;&amp; <br>                 MIDI_META_EOT == EVENT_META_TYPE(event)) <br>        { <br>            /* These are ignoreable since smfReadNextEvent() <br>            ** takes care of track merging <br>            */ <br>        } <br>        else if (MIDI_META == EVENT_TYPE(event) &amp;&amp; <br>                 MIDI_META_TEMPO == EVENT_META_TYPE(event)) <br>        { <br>            if (event.cbParm != 3) <br>            { <br>                DPF(1, "smfReadEvents: Corrupt tempo event"); <br>                return SMF_INVALID_FILE; <br>            } <br> <br>            dwTempo = (((DWORD)MEVT_TEMPO)&lt;&lt;24)| <br>                      (((DWORD)event.hpbParm[0])&lt;&lt;16)| <br>                      (((DWORD)event.hpbParm[1])&lt;&lt;8)| <br>                      ((DWORD)event.hpbParm[2]); <br> <br>            *lpdw++ = (DWORD)event.tkDelta; <br>            *lpdw++ = 0; <br>            *lpdw++ = dwTempo; <br> <br>            lpmh-&gt;dwBytesRecorded += 3*sizeof(DWORD); <br>        } <br>        else if (MIDI_META != EVENT_TYPE(event)) <br>        { <br>            /* Must be F0 or F7 system exclusive or FF meta <br>            ** that we didn't recognize <br>            */ <br>            pSmf-&gt;cbPendingUserEvent = event.cbParm; <br>            pSmf-&gt;hpbPendingUserEvent = event.hpbParm; <br>            pSmf-&gt;fdwSMF &amp;= ~SMF_F_INSERTSYSEX; <br> <br>            switch(EVENT_TYPE(event)) <br>            { <br>                case MIDI_SYSEX: <br>                    pSmf-&gt;fdwSMF |= SMF_F_INSERTSYSEX; <br>             <br>                    ++pSmf-&gt;cbPendingUserEvent; <br> <br>                    /* Falling through... <br>                    */ <br> <br>                case MIDI_SYSEXEND: <br>                    pSmf-&gt;dwPendingUserEvent = ((DWORD)MEVT_LONGMSG) &lt;&lt; 24; <br>                    break; <br>            } <br> <br>            smfrc = smfInsertParmData(pSmf, event.tkDelta, lpmh); <br>            if (SMF_SUCCESS != smfrc) <br>            { <br>                DPF(1, "smfInsertParmData[2] %u", (UINT)smfrc); <br>                return smfrc; <br>            } <br> <br>            lpdw = (LPDWORD)(lpmh-&gt;lpData + lpmh-&gt;dwBytesRecorded); <br>        } <br>    } <br> <br>    return (pSmf-&gt;fdwSMF &amp; SMF_F_EOF) ? SMF_END_OF_FILE : SMF_SUCCESS; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfInsertParmData <br>* <br>* Inserts pending long data from a track into the given buffer. <br>* <br>* pSmf                      - Specifies the file to read data from. <br>* <br>* tkDelta                   - Specfices the tick delta for the data. <br>* <br>* lpmh                      - Contains information about the buffer to fill. <br>* <br>* Returns <br>*   SMF_SUCCESS The events were successfully read. <br>*   SMF_INVALID_FILE A disk error occured on the file. <br>*  <br>* Fills as much data as will fit while leaving room for the buffer <br>* terminator. <br>* <br>* If the long data is depleted, resets pSmf-&gt;dwPendingUserEvent so <br>* that the next event may be read. <br>* <br>*****************************************************************************/ <br>PRIVATE SMFRESULT FNLOCAL smfInsertParmData( <br>    PSMF                    pSmf, <br>    TICKS                   tkDelta,                                             <br>    LPMIDIHDR               lpmh) <br>{ <br>    DWORD                   dwLength; <br>    DWORD                   dwRounded; <br>    LPDWORD                 lpdw; <br> <br>    assert(pSmf != NULL); <br>    assert(lpmh != NULL); <br>     <br>    /* Can't fit 4 DWORD's? (tkDelta + stream-id + event + some data) <br>    ** Can't do anything. <br>    */ <br>    assert(lpmh-&gt;dwBufferLength &gt;= lpmh-&gt;dwBytesRecorded); <br>     <br>    if (lpmh-&gt;dwBufferLength - lpmh-&gt;dwBytesRecorded &lt; 4*sizeof(DWORD)) <br>    { <br>        if (0 == tkDelta) <br>            return SMF_SUCCESS; <br> <br>        /* If we got here with a real delta, that means smfReadEvents screwed <br>        ** up calculating left space and we should flag it somehow. <br>        */ <br>        DPF(1, "Can't fit initial piece of SysEx into buffer!"); <br>        return SMF_INVALID_FILE; <br>    } <br> <br>    lpdw = (LPDWORD)(lpmh-&gt;lpData + lpmh-&gt;dwBytesRecorded); <br> <br>    dwLength = lpmh-&gt;dwBufferLength - lpmh-&gt;dwBytesRecorded - 3*sizeof(DWORD); <br>    dwLength = min(dwLength, pSmf-&gt;cbPendingUserEvent); <br> <br>    *lpdw++ = (DWORD)tkDelta; <br>    *lpdw++ = 0L; <br>    *lpdw++ = (pSmf-&gt;dwPendingUserEvent &amp; 0xFF000000L) | (dwLength &amp; 0x00FFFFFFL); <br> <br>    dwRounded = (dwLength + 3) &amp; (~3L); <br>     <br>    if (pSmf-&gt;fdwSMF &amp; SMF_F_INSERTSYSEX) <br>    { <br>        *((LPBYTE)lpdw)++ = MIDI_SYSEX; <br>        pSmf-&gt;fdwSMF &amp;= ~SMF_F_INSERTSYSEX; <br>        --dwLength; <br>        --pSmf-&gt;cbPendingUserEvent; <br>    } <br> <br>    if (dwLength &amp; 0x80000000L) <br>    { <br>        DPF(1, "dwLength %08lX  dwBytesRecorded %08lX  dwBufferLength %08lX", dwLength, lpmh-&gt;dwBytesRecorded, lpmh-&gt;dwBufferLength); <br>        DPF(1, "cbPendingUserEvent %08lX  dwPendingUserEvent %08lX dwRounded %08lX", pSmf-&gt;cbPendingUserEvent, pSmf-&gt;dwPendingUserEvent, dwRounded); <br>        DPF(1, "Offset into MIDI image %08lX", (DWORD)(pSmf-&gt;hpbPendingUserEvent - pSmf-&gt;hpbImage)); <br>        DPF(1, "!hmemcpy is about to fault"); <br>    } <br> <br>    hmemcpy(lpdw, pSmf-&gt;hpbPendingUserEvent, dwLength); <br>    if (0 == (pSmf-&gt;cbPendingUserEvent -= dwLength)) <br>        pSmf-&gt;dwPendingUserEvent = 0; <br> <br>    lpmh-&gt;dwBytesRecorded += 3*sizeof(DWORD) + dwRounded; <br> <br>    return SMF_SUCCESS; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfSeek <br>* <br>* This function moves the file pointer within a track <br>* and gets the state of the track at the new position. It returns a buffer of <br>* state information which can be used to set up to play from the new position. <br>* <br>* hSmf                      - Handle of file to seek within <br>* <br>* tkPosition                - The position to seek to in the track. <br>*          <br>* lpmh                      - A buffer to contain the state information. <br>* <br>* Returns <br>*   SMF_SUCCESS | The state was successfully read. <br>*   SMF_END_OF_TRACK | The pointer was moved to end of track and no state <br>*     information was returned. <br>*   SMF_INVALID_PARM | The given handle or buffer was invalid. <br>*   SMF_NO_MEMORY | There was insufficient memory in the given buffer to <br>*     contain all of the state data. <br>* <br>* The state information in the buffer includes patch changes, tempo changes, <br>* time signature, key signature,  <br>* and controller information. Only the most recent of these paramters before <br>* the current position will be stored. The state buffer will be returned <br>* in polymsg format so that it may be directly transmitted over the MIDI <br>* bus to bring the state up to date. <br>* <br>* The buffer is mean to be sent as a streaming buffer; i.e. immediately <br>* followed by the first data buffer. If the requested tick position <br>* does not exist in the file, the last event in the buffer <br>* will be a MEVT_NOP with a delta time calculated to make sure that <br>* the next stream event plays at the proper time. <br>* <br>* The meta events (tempo, time signature, key signature) will be the <br>* first events in the buffer if they exist. <br>*  <br>* Use smfGetStateMaxSize to determine the maximum size of the state <br>* information buffer. State information that will not fit into the given <br>* buffer will be lost. <br>* <br>* On return, the dwBytesRecorded field of lpmh will contain the <br>* actual number of bytes stored in the buffer. <br>* <br>*****************************************************************************/ <br> <br>typedef struct tag_keyframe <br>{ <br>    /* <br>    ** Meta events. All FF's indicates never seen. <br>    */ <br>    BYTE        rbTempo[3]; <br> <br>    /* <br>    ** MIDI channel messages. FF indicates never seen. <br>    */ <br>    BYTE        rbProgram[16]; <br>    BYTE        rbControl[16*120]; <br>}   KEYFRAME, <br>    FAR *PKEYFRAME; <br> <br>#define KF_EMPTY ((BYTE)0xFF) <br> <br>SMFRESULT FNLOCAL smfSeek( <br>    HSMF                    hSmf, <br>    TICKS                   tkPosition, <br>    LPMIDIHDR               lpmh) <br>{ <br>    PSMF                    pSmf    = (PSMF)hSmf; <br>    PTRACK                  ptrk; <br>    DWORD                   idxTrack; <br>    SMFRESULT               smfrc; <br>    EVENT                   event; <br>    LPDWORD                 lpdw; <br>    BYTE                    bEvent; <br>    UINT                    idx; <br>    UINT                    idxChannel; <br>    UINT                    idxController; <br>     <br>    static KEYFRAME         kf; <br> <br>    _fmemset(&amp;kf, 0xFF, sizeof(kf)); <br>     <br>    pSmf-&gt;tkPosition = 0; <br>    pSmf-&gt;fdwSMF &amp;= ~SMF_F_EOF; <br>     <br>    for (ptrk = pSmf-&gt;rTracks, idxTrack = pSmf-&gt;dwTracks; idxTrack--; ptrk++) <br>    { <br>        ptrk-&gt;pSmf              = pSmf; <br>        ptrk-&gt;tkPosition        = 0; <br>        ptrk-&gt;cbLeft            = ptrk-&gt;smti.cbLength; <br>        ptrk-&gt;hpbImage          = pSmf-&gt;hpbImage + ptrk-&gt;idxTrack; <br>        ptrk-&gt;bRunningStatus    = 0; <br>        ptrk-&gt;fdwTrack          = 0; <br>    } <br> <br>    while (SMF_SUCCESS == (smfrc = smfGetNextEvent(pSmf, (SPEVENT)&amp;event, tkPosition))) <br>    { <br>        if (MIDI_META == (bEvent = EVENT_TYPE(event))) <br>        { <br>            if (EVENT_META_TYPE(event) == MIDI_META_TEMPO) <br>            { <br>                if (event.cbParm != sizeof(kf.rbTempo)) <br>                    return SMF_INVALID_FILE; <br> <br>                hmemcpy((HPBYTE)kf.rbTempo, event.hpbParm, event.cbParm); <br>            } <br>        } <br>        else switch(bEvent &amp; 0xF0) <br>        { <br>            case MIDI_PROGRAMCHANGE: <br>                kf.rbProgram[bEvent &amp; 0x0F] = EVENT_CH_B1(event); <br>                break; <br> <br>            case MIDI_CONTROLCHANGE: <br>                kf.rbControl[(((WORD)bEvent &amp; 0x0F)*120) + EVENT_CH_B1(event)] = <br>                    EVENT_CH_B2(event); <br>                break; <br>        } <br>    } <br> <br>    if (SMF_REACHED_TKMAX != smfrc) <br>    { <br>        return smfrc; <br>    } <br> <br>    /* Build lpmh from keyframe <br>    */ <br>    lpmh-&gt;dwBytesRecorded = 0; <br>    lpdw = (LPDWORD)lpmh-&gt;lpData; <br> <br>    /* Tempo change event? <br>    */ <br>    if (KF_EMPTY != kf.rbTempo[0] || <br>        KF_EMPTY != kf.rbTempo[1] || <br>        KF_EMPTY != kf.rbTempo[2]) <br>    { <br>        if (lpmh-&gt;dwBufferLength - lpmh-&gt;dwBytesRecorded &lt; 3*sizeof(DWORD)) <br>            return SMF_NO_MEMORY; <br> <br>        *lpdw++ = 0; <br>        *lpdw++ = 0; <br>        *lpdw++ = (((DWORD)kf.rbTempo[0])&lt;&lt;16)| <br>                  (((DWORD)kf.rbTempo[1])&lt;&lt;8)| <br>                  ((DWORD)kf.rbTempo[2])| <br>                  (((DWORD)MEVT_TEMPO) &lt;&lt; 24); <br> <br>        lpmh-&gt;dwBytesRecorded += 3*sizeof(DWORD); <br>    } <br> <br>    /* Program change events? <br>    */ <br>    for (idx = 0; idx &lt; 16; idx++) <br>    { <br>        if (KF_EMPTY != kf.rbProgram[idx]) <br>        { <br>            if (lpmh-&gt;dwBufferLength - lpmh-&gt;dwBytesRecorded &lt; 3*sizeof(DWORD)) <br>                return SMF_NO_MEMORY; <br> <br>            *lpdw++ = 0; <br>            *lpdw++ = 0; <br>            *lpdw++ = (((DWORD)MEVT_SHORTMSG) &lt;&lt; 24)      | <br>                      ((DWORD)MIDI_PROGRAMCHANGE)         | <br>                      ((DWORD)idx)                        | <br>                      (((DWORD)kf.rbProgram[idx]) &lt;&lt; 8); <br> <br>            lpmh-&gt;dwBytesRecorded += 3*sizeof(DWORD); <br>        } <br>    } <br> <br>    /* Controller events? <br>    */ <br>    idx = 0; <br>    for (idxChannel = 0; idxChannel &lt; 16; idxChannel++) <br>    { <br>        for (idxController = 0; idxController &lt; 120; idxController++) <br>        { <br>            if (KF_EMPTY != kf.rbControl[idx]) <br>            { <br>                if (lpmh-&gt;dwBufferLength - lpmh-&gt;dwBytesRecorded &lt; 3*sizeof(DWORD)) <br>                    return SMF_NO_MEMORY; <br> <br>                *lpdw++ = 0; <br>                *lpdw++ = 0; <br>                *lpdw++ = (((DWORD)MEVT_SHORTMSG &lt;&lt; 24)     | <br>                          ((DWORD)MIDI_CONTROLCHANGE)       | <br>                          ((DWORD)idxChannel)               | <br>                          (((DWORD)idxController) &lt;&lt; 8)     | <br>                          (((DWORD)kf.rbControl[idx]) &lt;&lt; 16)); <br> <br> <br>                lpmh-&gt;dwBytesRecorded += 3*sizeof(DWORD); <br>            } <br> <br>            idx++; <br>        } <br>    } <br> <br>    /* Force all tracks to be at tkPosition. We are guaranteed that <br>    ** all tracks will be past the event immediately preceding tkPosition; <br>    ** this will force correct delta-ticks to be generated so that events <br>    ** on all tracks will line up properly on a seek into the middle of the <br>    ** file. <br>    */ <br>    for (ptrk = pSmf-&gt;rTracks, idxTrack = pSmf-&gt;dwTracks; idxTrack--; ptrk++) <br>    { <br>        ptrk-&gt;tkPosition        = tkPosition; <br>    } <br>     <br>    return SMF_SUCCESS; <br>} <br> <br>/****************************************************************************** <br>* <br>* smfGetStateMaxSize <br>* <br>* This function returns the maximum sizeof buffer that is needed to <br>* hold the state information returned by f smfSeek. <br>* <br>* pdwSize                   - Gets the size in bytes that should be allocated <br>*                             for the state buffer. <br>* <br>* Returns the state size in bytes. <br>* <br>*****************************************************************************/ <br>DWORD FNLOCAL smfGetStateMaxSize( <br>    VOID) <br>{ <br>    return  3*sizeof(DWORD) +           /* Tempo                */ <br>            3*16*sizeof(DWORD) +        /* Patch changes        */   <br>            3*16*120*sizeof(DWORD) +    /* Controller changes   */ <br>            3*sizeof(DWORD);            /* Time alignment NOP   */ <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
