<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SEQUENCE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2534"></a>SEQUENCE.C</h2>
<pre><code>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>****************************************************************************** <br>* <br>* Sequence.C <br>* <br>* Sequencer engine for MIDI player app <br>* <br>*****************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;limits.h&gt; <br> <br>#include "debug.h" <br>#include "seq.h" <br> <br>PRIVATE void FAR PASCAL seqMIDICallback(HMIDISTRM hms, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2); <br>PRIVATE MMRESULT FNLOCAL XlatSMFErr(SMFRESULT smfrc); <br> <br>/*************************************************************************** <br>*   <br>* seqAllocBuffers <br>* <br>* Allocate buffers for this instance. <br>* <br>* pSeq                      - The sequencer instance to allocate buffers for. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation was successful. <br>* <br>*   MCIERR_OUT_OF_MEMORY  If there is insufficient memory for <br>*     the requested number and size of buffers. <br>* <br>* seqAllocBuffers allocates playback buffers based on the <br>* cbBuffer and cBuffer fields of pSeq. cbBuffer specifies the <br>* number of bytes in each buffer, and cBuffer specifies the <br>* number of buffers to allocate. <br>* <br>* seqAllocBuffers must be called before any other sequencer call <br>* on a newly allocted SEQUENCE structure. It must be paired with <br>* a call to seqFreeBuffers, which should be the last call made <br>* before the SEQUENCE structure is discarded. <br>* <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqAllocBuffers( <br>    PSEQ                    pSeq) <br>{ <br>    DWORD                   dwEachBufferSize; <br>    DWORD                   dwAlloc; <br>    UINT                    i; <br>    LPBYTE                  lpbWork; <br> <br>    assert(pSeq != NULL); <br> <br>    pSeq-&gt;uState    = SEQ_S_NOFILE; <br>    pSeq-&gt;lpmhFree  = NULL; <br>    pSeq-&gt;lpbAlloc  = NULL; <br>    pSeq-&gt;hSmf      = (HSMF)NULL; <br>     <br>    /* First make sure we can allocate the buffers they asked for <br>    */ <br>    dwEachBufferSize = sizeof(MIDIHDR) + (DWORD)(pSeq-&gt;cbBuffer); <br>    dwAlloc          = dwEachBufferSize * (DWORD)(pSeq-&gt;cBuffer); <br>     <br>    pSeq-&gt;lpbAlloc = GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, dwAlloc); <br>    if (NULL == pSeq-&gt;lpbAlloc) <br>        return MCIERR_OUT_OF_MEMORY; <br> <br>    /* Initialize all MIDIHDR's and throw them into a free list <br>    */ <br>    pSeq-&gt;lpmhFree = NULL; <br> <br>    lpbWork = pSeq-&gt;lpbAlloc; <br>    for (i=0; i &lt; pSeq-&gt;cBuffer; i++) <br>    { <br>        ((LPMIDIHDR)lpbWork)-&gt;lpNext            = pSeq-&gt;lpmhFree; <br> <br>        ((LPMIDIHDR)lpbWork)-&gt;lpData            = lpbWork + sizeof(MIDIHDR); <br>        ((LPMIDIHDR)lpbWork)-&gt;dwBufferLength    = pSeq-&gt;cbBuffer; <br>        ((LPMIDIHDR)lpbWork)-&gt;dwBytesRecorded   = 0; <br>        ((LPMIDIHDR)lpbWork)-&gt;dwUser            = (DWORD)(UINT)pSeq; <br>        ((LPMIDIHDR)lpbWork)-&gt;dwFlags           = 0; <br> <br>        pSeq-&gt;lpmhFree = (LPMIDIHDR)lpbWork; <br> <br>        lpbWork += dwEachBufferSize; <br>    } <br> <br>    return MMSYSERR_NOERROR; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqFreeBuffers <br>* <br>* Free buffers for this instance. <br>* <br>* pSeq                      - The sequencer instance to free buffers for. <br>*    <br>* seqFreeBuffers frees all allocated memory belonging to the <br>* given sequencer instance pSeq. It must be the last call <br>* performed on the instance before it is destroyed. <br>*        <br>****************************************************************************/ <br>VOID FNLOCAL seqFreeBuffers( <br>    PSEQ                    pSeq) <br>{ <br>    LPMIDIHDR               lpmh; <br>     <br>    assert(pSeq != NULL); <br> <br>    if (NULL != pSeq-&gt;lpbAlloc) <br>    { <br>        lpmh = (LPMIDIHDR)pSeq-&gt;lpbAlloc; <br>        assert(!(lpmh-&gt;dwFlags &amp; MHDR_PREPARED)); <br>         <br>        GlobalFreePtr(pSeq-&gt;lpbAlloc); <br>    } <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqOpenFile <br>* <br>* Associates a MIDI file with the given sequencer instance. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If there is already a file open <br>*     on this instance. <br>*      <br>*   MCIERR_OUT_OF_MEMORY If there was insufficient memory to <br>*     allocate internal buffers on the file. <br>* <br>*   MCIERR_INVALID_FILE If initial attempts to parse the file <br>*     failed (such as the file is not a MIDI or RMI file). <br>* <br>* seqOpenFile may only be called if there is no currently open file <br>* on the instance. It must be paired with a call to seqCloseFile <br>* when operations on this file are complete. <br>* <br>* The pstrFile field of pSeq contains the name of the file <br>* to open. This name will be passed directly to mmioOpen; it may <br>* contain a specifcation for a custom MMIO file handler. The task <br>* context used for all I/O will be the task which calls seqOpenFile. <br>* <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqOpenFile( <br>    PSEQ                    pSeq) <br>{                             <br>    MMRESULT                rc      = MMSYSERR_NOERROR; <br>    SMFOPENFILESTRUCT       sofs; <br>    SMFFILEINFO             sfi; <br>    SMFRESULT               smfrc; <br>    DWORD                   cbBuffer; <br> <br>    assert(pSeq != NULL); <br> <br>    if (pSeq-&gt;uState != SEQ_S_NOFILE) <br>    { <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br>    } <br> <br>    assert(pSeq-&gt;pstrFile != NULL); <br>     <br>    sofs.pstrName     = pSeq-&gt;pstrFile; <br> <br>    smfrc = smfOpenFile(&amp;sofs); <br>    if (SMF_SUCCESS != smfrc) <br>    { <br>        rc = XlatSMFErr(smfrc); <br>        goto Seq_Open_File_Cleanup; <br>    } <br> <br>    pSeq-&gt;hSmf = sofs.hSmf; <br>    smfGetFileInfo(pSeq-&gt;hSmf, &amp;sfi); <br>     <br>    pSeq-&gt;dwTimeDivision = sfi.dwTimeDivision; <br>    pSeq-&gt;tkLength       = sfi.tkLength; <br>    pSeq-&gt;cTrk           = sfi.dwTracks; <br>                <br>    /* Track buffers must be big enough to hold the state data returned <br>    ** by smfSeek() <br>    */ <br>    cbBuffer = min(pSeq-&gt;cbBuffer, smfGetStateMaxSize()); <br>     <br>Seq_Open_File_Cleanup:     <br>    if (MMSYSERR_NOERROR != rc) <br>        seqCloseFile(pSeq); <br>    else <br>        pSeq-&gt;uState = SEQ_S_OPENED; <br> <br>    return rc; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqCloseFile <br>* <br>* Deassociates a MIDI file with the given sequencer instance. <br>* <br>* pSeq                      -  The sequencer instance. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     stopped. <br>*      <br>* A call to seqCloseFile must be paired with a prior call to <br>* seqOpenFile. All buffers associated with the file will be <br>* freed and the file will be closed. The sequencer must be <br>* stopped before this call will be accepted. <br>* <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqCloseFile( <br>    PSEQ                    pSeq) <br>{ <br>    LPMIDIHDR               lpmh; <br>     <br>    assert(pSeq != NULL); <br>     <br>    if (SEQ_S_OPENED != pSeq-&gt;uState) <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br>     <br>    if ((HSMF)NULL != pSeq-&gt;hSmf) <br>    { <br>        smfCloseFile(pSeq-&gt;hSmf); <br>        pSeq-&gt;hSmf = (HSMF)NULL; <br>    } <br> <br>    /* If we were prerolled, need to clean up -- have an open MIDI handle <br>    ** and buffers in the ready queue <br>    */ <br> <br>    for (lpmh = pSeq-&gt;lpmhFree; lpmh; lpmh = lpmh-&gt;lpNext) <br>        midiOutUnprepareHeader(pSeq-&gt;hmidi, lpmh, sizeof(*lpmh)); <br> <br>    if (pSeq-&gt;lpmhPreroll) <br>        midiOutUnprepareHeader(pSeq-&gt;hmidi, pSeq-&gt;lpmhPreroll, sizeof(*pSeq-&gt;lpmhPreroll)); <br> <br>    if (pSeq-&gt;hmidi != NULL) <br>    { <br>        midiStreamClose((HMIDISTRM)(pSeq-&gt;hmidi)); <br>        pSeq-&gt;hmidi = NULL; <br>    } <br> <br>    pSeq-&gt;uState = SEQ_S_NOFILE; <br> <br>    return MMSYSERR_NOERROR; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqPreroll <br>* <br>* Prepares the file for playback at the given position. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* lpPreroll                 - Specifies the starting and ending tick <br>*                             positions to play between. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     opened or prerolled. <br>* <br>* Open the device so we can initialize channels. <br>* <br>* Loop through the tracks. For each track, seek to the given position and <br>* send the init data SMF gives us to the handle. <br>* <br>* Wait for all init buffers to finish. <br>* <br>* Unprepare the buffers (they're only ever sent here; the sequencer <br>* engine merges them into a single stream during normal playback) and <br>* refill them with the first chunk of data from the track.  <br>* <br>*      <br>****************************************************************************/ <br>MMRESULT FNLOCAL seqPreroll( <br>    PSEQ                    pSeq, <br>    LPPREROLL               lpPreroll) <br>{ <br>    SMFRESULT           smfrc; <br>    MMRESULT            mmrc        = MMSYSERR_NOERROR; <br>    MIDIPROPTIMEDIV     mptd; <br>    LPMIDIHDR           lpmh = NULL; <br>    LPMIDIHDR           lpmhPreroll = NULL; <br>    DWORD               cbPrerollBuffer; <br>    UINT                uDeviceID; <br> <br>    assert(pSeq != NULL); <br> <br>    pSeq-&gt;mmrcLastErr = MMSYSERR_NOERROR; <br> <br>    if (pSeq-&gt;uState != SEQ_S_OPENED &amp;&amp; <br>        pSeq-&gt;uState != SEQ_S_PREROLLED) <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br> <br>pSeq-&gt;tkBase = lpPreroll-&gt;tkBase; <br>pSeq-&gt;tkEnd = lpPreroll-&gt;tkEnd; <br> <br>    if (pSeq-&gt;hmidi) <br>    { <br>        // Recollect buffers from MMSYSTEM back into free queue <br>        // <br>        pSeq-&gt;uState = SEQ_S_RESET; <br>        midiOutReset(pSeq-&gt;hmidi); <br> <br>while (pSeq-&gt;uBuffersInMMSYSTEM) <br>Sleep(0); <br>    } <br>     <br>    pSeq-&gt;uBuffersInMMSYSTEM = 0; <br>    pSeq-&gt;uState = SEQ_S_PREROLLING; <br>     <br>    // <br>    // We've successfully opened the file and all of the tracks; now <br>    // open the MIDI device and set the time division. <br>    // <br>    // NOTE: seqPreroll is equivalent to seek; device might already be open <br>    // <br>    if (NULL == pSeq-&gt;hmidi) <br>    { <br>        uDeviceID = pSeq-&gt;uDeviceID; <br>        if ((mmrc = midiStreamOpen(&amp;(HMIDISTRM)pSeq-&gt;hmidi, <br>                                   &amp;uDeviceID, <br>                                   1, <br>                                   (DWORD)seqMIDICallback, <br>                                   0, <br>                                   CALLBACK_FUNCTION)) != MMSYSERR_NOERROR) <br>        { <br>            pSeq-&gt;hmidi = NULL; <br>            goto seq_Preroll_Cleanup; <br>        } <br>         <br>        mptd.cbStruct  = sizeof(mptd); <br>        mptd.dwTimeDiv = pSeq-&gt;dwTimeDivision; <br>        if ((mmrc = midiStreamProperty( <br>                                       (HMIDISTRM)pSeq-&gt;hmidi, <br>                                       (LPBYTE)&amp;mptd, <br>                                       MIDIPROP_SET|MIDIPROP_TIMEDIV)) != MMSYSERR_NOERROR) <br>        { <br>            DPF(1, "midiStreamProperty() -&gt; %04X", (WORD)mmrc); <br>            midiStreamClose((HMIDISTRM)pSeq-&gt;hmidi); <br>            pSeq-&gt;hmidi = NULL; <br>            mmrc = MCIERR_DEVICE_NOT_READY; <br>            goto seq_Preroll_Cleanup; <br>        } <br>    } <br> <br>    mmrc = MMSYSERR_NOERROR; <br> <br>    // <br>    //  Allocate a preroll buffer.  Then if we don't have enough room for <br>    //  all the preroll info, we make the buffer larger.   <br>    // <br>    if (!pSeq-&gt;lpmhPreroll) <br>    { <br>        cbPrerollBuffer = 4096; <br>        lpmhPreroll = (LPMIDIHDR)GlobalAllocPtr(GMEM_MOVEABLE|GMEM_SHARE, <br>                                                            cbPrerollBuffer); <br>    } <br>    else <br>    { <br>        cbPrerollBuffer = pSeq-&gt;cbPreroll; <br>        lpmhPreroll = pSeq-&gt;lpmhPreroll; <br>    } <br> <br>    lpmhPreroll-&gt;lpNext            = pSeq-&gt;lpmhFree; <br>    lpmhPreroll-&gt;lpData            = (LPBYTE)lpmhPreroll + sizeof(MIDIHDR); <br>    lpmhPreroll-&gt;dwBufferLength    = cbPrerollBuffer - sizeof(MIDIHDR); <br>    lpmhPreroll-&gt;dwBytesRecorded   = 0; <br>    lpmhPreroll-&gt;dwUser            = (DWORD)(UINT)pSeq; <br>    lpmhPreroll-&gt;dwFlags           = 0; <br> <br>    do <br>    { <br>        smfrc = smfSeek(pSeq-&gt;hSmf, pSeq-&gt;tkBase, lpmhPreroll); <br>        if( SMF_SUCCESS != smfrc ) <br>        { <br>            if( ( SMF_NO_MEMORY != smfrc )  || <br>                ( cbPrerollBuffer &gt;= 32768L ) ) <br>            { <br>                DPF(1, "smfSeek() returned %lu", (DWORD)smfrc); <br> <br>                GlobalFreePtr(lpmhPreroll); <br>                pSeq-&gt;lpmhPreroll = NULL; <br> <br>                mmrc = XlatSMFErr(smfrc); <br>                goto seq_Preroll_Cleanup; <br>            } <br>            else   //  Try to grow buffer. <br>            { <br>                cbPrerollBuffer *= 2; <br>                lpmh = (LPMIDIHDR)GlobalReAllocPtr( lpmhPreroll, cbPrerollBuffer, 0 ); <br>                if( NULL == lpmh ) <br>                { <br>                    DPF(2,"seqPreroll - realloc failed, aborting preroll."); <br>                    mmrc = MCIERR_OUT_OF_MEMORY; <br>                    goto seq_Preroll_Cleanup; <br>                } <br> <br>                lpmhPreroll = lpmh; <br>                lpmhPreroll-&gt;lpData = (LPBYTE)lpmhPreroll + sizeof(MIDIHDR); <br>                lpmhPreroll-&gt;dwBufferLength = cbPrerollBuffer - sizeof(MIDIHDR); <br> <br>                pSeq-&gt;lpmhPreroll = lpmhPreroll; <br>                pSeq-&gt;cbPreroll = cbPrerollBuffer; <br>            } <br>        } <br>    } while( SMF_SUCCESS != smfrc ); <br> <br>    if (MMSYSERR_NOERROR != (mmrc = midiOutPrepareHeader(pSeq-&gt;hmidi, lpmhPreroll, sizeof(MIDIHDR)))) <br>    { <br>        DPF(1, "midiOutPrepare(preroll) -&gt; %lu!", (DWORD)mmrc); <br> <br>        mmrc = MCIERR_DEVICE_NOT_READY; <br>        goto seq_Preroll_Cleanup; <br>    } <br> <br>    ++pSeq-&gt;uBuffersInMMSYSTEM; <br> <br>    if (MMSYSERR_NOERROR != (mmrc = midiStreamOut((HMIDISTRM)pSeq-&gt;hmidi, lpmhPreroll, sizeof(MIDIHDR)))) <br>    { <br>        DPF(1, "midiStreamOut(preroll) -&gt; %lu!", (DWORD)mmrc); <br> <br>        mmrc = MCIERR_DEVICE_NOT_READY; <br>        --pSeq-&gt;uBuffersInMMSYSTEM; <br>        goto seq_Preroll_Cleanup; <br>    } <br>    DPF(3,"seqPreroll: midiStreamOut(0x%x,0x%lx,%u) returned %u.",pSeq-&gt;hmidi,lpmhPreroll,sizeof(MIDIHDR),mmrc); <br> <br>    pSeq-&gt;fdwSeq &amp;= ~SEQ_F_EOF; <br>    while (pSeq-&gt;lpmhFree) <br>    { <br>        lpmh = pSeq-&gt;lpmhFree; <br>        pSeq-&gt;lpmhFree = lpmh-&gt;lpNext; <br> <br>        smfrc = smfReadEvents(pSeq-&gt;hSmf, lpmh, pSeq-&gt;tkEnd); <br>        if (SMF_SUCCESS != smfrc &amp;&amp; SMF_END_OF_FILE != smfrc) <br>        { <br>            DPF(1, "SFP: smfReadEvents() -&gt; %u", (UINT)smfrc); <br>            mmrc = XlatSMFErr(smfrc); <br>            goto seq_Preroll_Cleanup; <br>        } <br> <br>        if (MMSYSERR_NOERROR != (mmrc = midiOutPrepareHeader(pSeq-&gt;hmidi, lpmh, sizeof(*lpmh)))) <br>        { <br>            DPF(1, "SFP: midiOutPrepareHeader failed"); <br>            goto seq_Preroll_Cleanup; <br>        } <br> <br>        if (MMSYSERR_NOERROR != (mmrc = midiStreamOut((HMIDISTRM)pSeq-&gt;hmidi, lpmh, sizeof(*lpmh)))) <br>        { <br>            DPF(1, "SFP: midiStreamOut failed"); <br>            goto seq_Preroll_Cleanup; <br>        } <br> <br>        ++pSeq-&gt;uBuffersInMMSYSTEM;  <br> <br>        if (SMF_END_OF_FILE == smfrc) <br>        { <br>            pSeq-&gt;fdwSeq |= SEQ_F_EOF; <br>            break; <br>        } <br>    }  <br> <br>seq_Preroll_Cleanup: <br>    if (MMSYSERR_NOERROR != mmrc) <br>    { <br>        pSeq-&gt;uState = SEQ_S_OPENED; <br>        pSeq-&gt;fdwSeq &amp;= ~SEQ_F_WAITING; <br>    } <br>    else <br>    { <br>        pSeq-&gt;uState = SEQ_S_PREROLLED; <br>    } <br> <br>    return mmrc; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqStart <br>* <br>* Starts playback at the current position. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     stopped. <br>* <br>*   MCIERR_DEVICE_NOT_READY If the underlying MIDI device could <br>*     not be opened or fails any call. <br>*  <br>* The sequencer must be prerolled before seqStart may be called. <br>* <br>* Just feed everything in the ready queue to the device. <br>*        <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqStart( <br>    PSEQ                    pSeq) <br>{ <br>    assert(NULL != pSeq); <br> <br>    if (SEQ_S_PREROLLED != pSeq-&gt;uState) <br>    { <br>        DPF(1, "seqStart(): State is wrong! [%u]", pSeq-&gt;uState); <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br>    } <br> <br>    pSeq-&gt;uState = SEQ_S_PLAYING; <br> <br>    return midiStreamRestart((HMIDISTRM)pSeq-&gt;hmidi); <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqPause <br>* <br>* Pauses playback of the instance. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     playing. <br>* <br>* The sequencer must be playing before seqPause may be called. <br>* Pausing the sequencer will cause all currently on notes to be turned <br>* off. This may cause playback to be slightly inaccurate on restart <br>* due to missing notes. <br>*        <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqPause( <br>    PSEQ                    pSeq) <br>{ <br>    assert(NULL != pSeq); <br>     <br>    if (SEQ_S_PLAYING != pSeq-&gt;uState) <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br> <br>    pSeq-&gt;uState = SEQ_S_PAUSED; <br>    midiStreamPause((HMIDISTRM)pSeq-&gt;hmidi); <br>     <br>    return MMSYSERR_NOERROR; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqRestart <br>* <br>* Restarts playback of an instance after a pause. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* Returns <br>*    MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*    MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     paused. <br>* <br>* The sequencer must be paused before seqRestart may be called. <br>* <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqRestart( <br>    PSEQ                    pSeq) <br>{ <br>    assert(NULL != pSeq); <br> <br>    if (SEQ_S_PAUSED != pSeq-&gt;uState) <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br> <br>    pSeq-&gt;uState = SEQ_S_PLAYING; <br>    midiStreamRestart((HMIDISTRM)pSeq-&gt;hmidi); <br> <br>    return MMSYSERR_NOERROR; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqStop <br>* <br>* Totally stops playback of an instance. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     paused or playing. <br>* <br>* The sequencer must be paused or playing before seqStop may be called. <br>* <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqStop( <br>    PSEQ                    pSeq) <br>{ <br>    assert(NULL != pSeq); <br> <br>    /* Automatic success if we're already stopped <br>    */ <br>    if (SEQ_S_PLAYING != pSeq-&gt;uState &amp;&amp; <br>        SEQ_S_PAUSED != pSeq-&gt;uState) <br>    { <br>        pSeq-&gt;fdwSeq &amp;= ~SEQ_F_WAITING; <br>        return MMSYSERR_NOERROR; <br>    } <br> <br>    pSeq-&gt;uState = SEQ_S_STOPPING; <br>    pSeq-&gt;fdwSeq |= SEQ_F_WAITING; <br>     <br>    if (MMSYSERR_NOERROR != (pSeq-&gt;mmrcLastErr = midiStreamStop((HMIDISTRM)pSeq-&gt;hmidi))) <br>    { <br>        DPF(1, "midiOutStop() returned %lu in seqStop()!", (DWORD)pSeq-&gt;mmrcLastErr); <br>         <br>        pSeq-&gt;fdwSeq &amp;= ~SEQ_F_WAITING; <br>        return MCIERR_DEVICE_NOT_READY; <br>    } <br> <br>while (pSeq-&gt;uBuffersInMMSYSTEM) <br>Sleep(0); <br>     <br>    return MMSYSERR_NOERROR; <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqTime <br>* <br>* Determine the current position in playback of an instance. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* pTicks                    - A pointer to a DWORD where the current position <br>*                             in ticks will be returned. <br>* <br>* Returns <br>*   MMSYSERR_NOERROR If the operation is successful. <br>* <br>*   MCIERR_DEVICE_NOT_READY If the underlying device fails to report <br>*     the position. <br>*     <br>*   MCIERR_UNSUPPORTED_FUNCTION If the sequencer instance is not <br>*     paused or playing. <br>* <br>* The sequencer must be paused, playing or prerolled before seqTime <br>* may be called. <br>* <br>***************************************************************************/ <br>MMRESULT FNLOCAL seqTime( <br>    PSEQ                    pSeq, <br>    PTICKS                  pTicks) <br>{ <br>    MMRESULT                mmr; <br>    MMTIME                  mmt; <br>     <br>    assert(pSeq != NULL); <br> <br>    if (SEQ_S_PLAYING != pSeq-&gt;uState &amp;&amp; <br>        SEQ_S_PAUSED != pSeq-&gt;uState &amp;&amp; <br>        SEQ_S_PREROLLING != pSeq-&gt;uState &amp;&amp; <br>        SEQ_S_PREROLLED != pSeq-&gt;uState &amp;&amp; <br>        SEQ_S_OPENED != pSeq-&gt;uState) <br>    { <br>        DPF(1, "seqTime(): State wrong! [is %u]", pSeq-&gt;uState); <br>        return MCIERR_UNSUPPORTED_FUNCTION; <br>    } <br> <br>    *pTicks = 0; <br>    if (SEQ_S_OPENED != pSeq-&gt;uState) <br>    { <br>        *pTicks = pSeq-&gt;tkBase; <br>        if (SEQ_S_PREROLLED != pSeq-&gt;uState) <br>        { <br>            mmt.wType = TIME_TICKS; <br>            mmr = midiStreamPosition((HMIDISTRM)pSeq-&gt;hmidi, &amp;mmt, sizeof(mmt)); <br>            if (MMSYSERR_NOERROR != mmr) <br>            { <br>                DPF(1, "midiStreamPosition() returned %lu", (DWORD)mmr); <br>                return MCIERR_DEVICE_NOT_READY; <br>            } <br> <br>            *pTicks += mmt.u.ticks; <br>        } <br>    } <br> <br>    return MMSYSERR_NOERROR; <br>} <br>                               <br>/*************************************************************************** <br>*   <br>* seqMillisecsToTicks <br>* <br>* Given a millisecond offset in the output stream, returns the associated <br>* tick position. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* msOffset                  - The millisecond offset into the stream. <br>* <br>* Returns the number of ticks into the stream. <br>* <br>***************************************************************************/ <br>TICKS FNLOCAL seqMillisecsToTicks( <br>    PSEQ                    pSeq, <br>    DWORD                   msOffset) <br>{ <br>    return smfMillisecsToTicks(pSeq-&gt;hSmf, msOffset); <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqTicksToMillisecs <br>* <br>* Given a tick offset in the output stream, returns the associated <br>* millisecond position. <br>* <br>* pSeq                      - The sequencer instance. <br>* <br>* tkOffset                  - The tick offset into the stream. <br>* <br>* Returns the number of milliseconds into the stream. <br>* <br>***************************************************************************/ <br>DWORD FNLOCAL seqTicksToMillisecs( <br>    PSEQ                    pSeq, <br>    TICKS                   tkOffset) <br>{ <br>    return smfTicksToMillisecs(pSeq-&gt;hSmf, tkOffset); <br>} <br> <br>/*************************************************************************** <br>*   <br>* seqMIDICallback <br>* <br>* Called by the system when a buffer is done <br>* <br>* dw1                       - The buffer that has completed playback. <br>* <br>***************************************************************************/ <br>PRIVATE void FAR PASCAL seqMIDICallback(HMIDISTRM hms, UINT uMsg, DWORD dwUser, DWORD dw1, DWORD dw2) <br>{ <br>LPMIDIHDRlpmh= (LPMIDIHDR)dw1; <br>    PSEQ                    pSeq; <br>    MMRESULT                mmrc; <br>    SMFRESULT               smfrc; <br> <br>if (uMsg != MOM_DONE) <br>return; <br> <br>assert(NULL != lpmh); <br> <br>    pSeq = (PSEQ)(lpmh-&gt;dwUser); <br> <br>    assert(pSeq != NULL); <br> <br>    --pSeq-&gt;uBuffersInMMSYSTEM; <br>     <br>    if (SEQ_S_RESET == pSeq-&gt;uState) <br>    { <br>        // We're recollecting buffers from MMSYSTEM <br>        // <br>if (lpmh != pSeq-&gt;lpmhPreroll) <br>{ <br>        lpmh-&gt;lpNext   = pSeq-&gt;lpmhFree; <br>        pSeq-&gt;lpmhFree = lpmh; <br>} <br> <br>        return; <br>    } <br>     <br> <br>    if ((SEQ_S_STOPPING == pSeq-&gt;uState) || (pSeq-&gt;fdwSeq &amp; SEQ_F_EOF)) <br>    { <br>        /* <br>        ** Reached EOF, just put the buffer back on the free <br>        ** list  <br>        */ <br>if (lpmh != pSeq-&gt;lpmhPreroll) <br>{ <br>        lpmh-&gt;lpNext   = pSeq-&gt;lpmhFree; <br>        pSeq-&gt;lpmhFree = lpmh; <br>} <br> <br>        if (MMSYSERR_NOERROR != (mmrc = midiOutUnprepareHeader(pSeq-&gt;hmidi, lpmh, sizeof(*lpmh)))) <br>        { <br>            DPF(1, "midiOutUnprepareHeader failed in seqBufferDone! (%lu)", (DWORD)mmrc); <br>        } <br> <br>        if (0 == pSeq-&gt;uBuffersInMMSYSTEM) <br>        { <br>            DPF(1, "seqBufferDone: normal sequencer shutdown."); <br>             <br>            /* Totally done! Free device and notify. <br>            */ <br>            midiStreamClose((HMIDISTRM)pSeq-&gt;hmidi); <br>             <br>            pSeq-&gt;hmidi = NULL; <br>            pSeq-&gt;uState = SEQ_S_OPENED; <br>            pSeq-&gt;mmrcLastErr = MMSYSERR_NOERROR; <br>            pSeq-&gt;fdwSeq &amp;= ~SEQ_F_WAITING; <br>         <br>        // lParam indicates whether or not to preroll again. Don't if we were explicitly <br>        // stopped. <br>        //     <br>            PostMessage(pSeq-&gt;hWnd, MMSG_DONE, (WPARAM)pSeq, (LPARAM)(SEQ_S_STOPPING != pSeq-&gt;uState)); <br>        } <br>    } <br>    else <br>    { <br>        /* <br>        ** Not EOF yet; attempt to fill another buffer <br>        */ <br>        smfrc = smfReadEvents(pSeq-&gt;hSmf, lpmh, pSeq-&gt;tkEnd); <br>         <br>        switch(smfrc) <br>        { <br>            case SMF_SUCCESS: <br>                break; <br> <br>            case SMF_END_OF_FILE: <br>                pSeq-&gt;fdwSeq |= SEQ_F_EOF; <br>                smfrc = SMF_SUCCESS; <br>                break; <br> <br>            default: <br>                DPF(1, "smfReadEvents returned %lu in callback!", (DWORD)smfrc); <br>                pSeq-&gt;uState = SEQ_S_STOPPING; <br>                break; <br>        } <br> <br>        if (SMF_SUCCESS == smfrc) <br>        { <br>            ++pSeq-&gt;uBuffersInMMSYSTEM; <br>            mmrc = midiStreamOut((HMIDISTRM)pSeq-&gt;hmidi, lpmh, sizeof(*lpmh)); <br>            if (MMSYSERR_NOERROR != mmrc) <br>            { <br>                DPF(1, "seqBufferDone(): midiStreamOut() returned %lu!", (DWORD)mmrc); <br>                 <br>                --pSeq-&gt;uBuffersInMMSYSTEM; <br>                pSeq-&gt;uState = SEQ_S_STOPPING; <br>            } <br>        } <br>    } <br>} <br> <br>/*************************************************************************** <br>*   <br>* XlatSMFErr <br>* <br>* Translates an error from the SMF layer into an appropriate MCI error. <br>* <br>* smfrc                     - The return code from any SMF function. <br>* <br>* Returns <br>*   A parallel error from the MCI error codes.    <br>* <br>***************************************************************************/ <br>PRIVATE MMRESULT FNLOCAL XlatSMFErr( <br>    SMFRESULT               smfrc) <br>{ <br>    switch(smfrc) <br>    { <br>        case SMF_SUCCESS: <br>            return MMSYSERR_NOERROR; <br> <br>        case SMF_NO_MEMORY: <br>            return MCIERR_OUT_OF_MEMORY; <br> <br>        case SMF_INVALID_FILE: <br>        case SMF_OPEN_FAILED: <br>        case SMF_INVALID_TRACK: <br>            return MCIERR_INVALID_FILE; <br> <br>        default: <br>            return MCIERR_UNSUPPORTED_FUNCTION; <br>    } <br>} <br> <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
