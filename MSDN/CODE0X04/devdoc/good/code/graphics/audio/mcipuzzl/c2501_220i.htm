<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MCIPUZZL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2502"></a>MCIPUZZL.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/*----------------------------------------------------------------------------*\ <br> * <br> *  MCIPUZZLE: <br> * <br> *    Sample app showing the use of MCIWnd, installable draw procedure <br> * <br> *    MCIPUZZLE is an application that demonstrates the following: <br> * <br> *      - Using the MCIWnd window class to play MCI files. <br> * <br> *      - Using an installable draw procedure with MCIAVI <br> * <br> *      - Implementing a version of the classic "15" puzzle <br> * <br> *----------------------------------------------------------------------------*/ <br> <br>#define  STRICT <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;digitalv.h&gt; <br>#include &lt;mciavi.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "mcipuzzl.h" <br>#include "puzzle.h" <br>#include "puzzproc.h" <br> <br>//--------------------------------------------------------------------------- <br> <br>#define BUFSIZE 260 <br>#define MCIPLAY_APP_CLASS "MCIPuzzle_App" <br>#define MCIPLAY_DOC_CLASS MCIWND_WINDOW_CLASS <br>typedef MCI_DGV_SETVIDEO_PARMS * LP_MCI_DGV; <br> <br>/*-------------------------------------------------------------------------*\ <br>|                                                                          | <br>|   g l o b a l   v a r i a b l e s                                        | <br>|                                                                          | <br>\*------------------------------------------------------------------------*/ <br> <br>static  HINSTANCE ghInstApp;            /* Instance handle */ <br>static  HACCEL    ghAccelApp; <br>static  HWND      ghwndApp;             /* Handle to parent window */ <br>static  HWND      ghwndMCI;             /* Handle to MCI client window */ <br>static  char      gszBuffer[BUFSIZE]; <br>static  DWORD     gdwHook = 0L; <br> <br>PUZZLE            gPuzzle; <br> <br>//--------------------------------------------------------------------------- <br> <br>LRESULT CALLBACK AppWndProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK AppAbout(HWND, UINT, WPARAM, LPARAM); <br> <br>static BOOL AppInit(HINSTANCE, HINSTANCE, LPSTR, int); <br>static BOOL FormatFilterString(UINT, LPSTR); <br>static void MCI_OnCommand(HWND, int, HWND, UINT); <br>static void MCI_OnInitMenuPopup(HWND, HMENU, int, BOOL); <br>static void MCI_OnSize(HWND, UINT, int, int); <br>static void MCI_OnParentNotify(HWND, UINT, HWND, int); <br>static void Handle_NotifyMedia(HWND,WPARAM); <br>static void Handle_NotifySize(HWND,WPARAM); <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppAbout( hDlg, msg, wParam, lParam )                                      | <br>|                                                                              | <br>|   Description:                                                               | <br>|       This function handles messages belonging to the "About" dialog box.    | <br>|       The only message that it looks for is WM_COMMAND, indicating the user  | <br>|       has pressed the "OK" button.  When this happens, it takes down         | <br>|       the dialog box.                                                        | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hDlg            window handle of about dialog window                   | <br>|       msg             message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       TRUE if message has been processed, else FALSE                         | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>BOOL CALLBACK AppAbout( <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>        switch (msg) { <br>                case WM_COMMAND: <br>                EndDialog(hwnd,TRUE); <br>                return TRUE; <br>        } <br>        return FALSE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppInit ( hInstance, hPrevInstance )                                       | <br>|                                                                              | <br>|   Description:                                                               | <br>|       This is called when the application is first loaded into               | <br>|       memory.  It performs all initialization that doesn't need to be done   | <br>|       once per instance.                                                     | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hPrevInstance   instance handle of previous instance                   | <br>|       hInstance       instance handle of current instance                    | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       TRUE if successful, FALSE if not                                       | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>static BOOL AppInit( <br>HINSTANCE hInst, <br>HINSTANCE hPrev, <br>LPSTR szCmd, <br>int sw) <br>{ <br>        WNDCLASS cls; <br>        WORD wVer; <br>        char szAppName[BUFSIZE]; <br> <br>        /* Save instance handle for DialogBox */ <br>        ghInstApp = hInst; <br> <br>        LoadString( ghInstApp, IDS_APPNAME, szAppName, BUFSIZE ); <br> <br>        /* first let's make sure we are running on 1.1 */ <br>        wVer = HIWORD(VideoForWindowsVersion()); <br>        if (wVer &lt; 0x010a){ <br>                char szTitle[BUFSIZE]; <br>                /* oops, we are too old, blow out of here */ <br>                LoadString( ghInstApp, IDS_APPERR, szTitle, BUFSIZE ); <br>                LoadString( ghInstApp, IDS_VFWTOOOLD, gszBuffer, BUFSIZE ); <br>                MessageBeep(MB_ICONHAND); <br>                MessageBox(NULL, gszBuffer, szTitle, MB_OK|MB_ICONSTOP); <br>                return FALSE; <br>        } <br> <br>        ghAccelApp = LoadAccelerators(ghInstApp, "AppAccel"); <br> <br>        if (!hPrev) { <br>                cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>                cls.hIcon          = LoadIcon(hInst,"AppIcon"); <br>                cls.lpszMenuName   = "AppMenu"; <br>                cls.lpszClassName  = MCIPLAY_APP_CLASS; <br>                cls.hbrBackground  = (HBRUSH)COLOR_APPWORKSPACE+1; <br>                cls.hInstance      = hInst; <br>                cls.style          = 0; <br>                cls.lpfnWndProc    = (WNDPROC)AppWndProc; <br>                cls.cbClsExtra     = 0; <br>                cls.cbWndExtra     = 0; <br> <br>                if (!RegisterClass(&amp;cls)) <br>                        return FALSE; <br>        } <br> <br>        ghwndApp = CreateWindow( <br>                MCIPLAY_APP_CLASS, <br>                szAppName, <br>                WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>                CW_USEDEFAULT, <br>                0, <br>                160, <br>                120, <br>                (HWND)NULL,       /* no parent */ <br>                (HMENU)NULL,      /* use class menu */ <br>                (HANDLE)hInst,     /* handle to window instance */ <br>                (LPSTR)NULL);     /* no params to pass on */ <br> <br>        InitPuzzle(&amp;gPuzzle, TRUE /* FALSE to not scramble */); <br> <br>        /* Make window visible according to the way the app is activated */ <br>        ShowWindow(ghwndApp,sw); <br> <br>        return TRUE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   WinMain( hInstance, hPrevInstance, lpszCmdLine, cmdShow )                  | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The main procedure for the App.  After initializing, it just goes      | <br>|       into a message-processing loop until it gets a WM_QUIT message         | <br>|       (meaning the app was closed).                                          | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hInstance       instance handle of this instance of the app            | <br>|       hPrevInstance   instance handle of previous instance, NULL if first    | <br>|       lpszCmdLine     -&gt;null-terminated command line                         | <br>|       cmdShow         specifies how the window is initially displayed        | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       The exit code as specified in the WM_QUIT message.                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>int PASCAL WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR szCmdLine, <br>int sw) <br>{ <br>        MSG msg; <br> <br>        if (!AppInit(hInstance,hPrevInstance,szCmdLine,sw)) <br>                return FALSE; <br> <br>        //Polling messages from event queue <br>        for (;;) { <br>                if (PeekMessage(&amp;msg, NULL, 0, 0,PM_REMOVE)) { <br>                        if (msg.message == WM_QUIT) <br>                                break; <br> <br>                        if (ghAccelApp &amp;&amp; ghwndApp &amp;&amp; TranslateAccelerator(ghwndApp, ghAccelApp, &amp;msg)) <br>                                continue; <br> <br>                        TranslateMessage(&amp;msg); <br>                        DispatchMessage(&amp;msg); <br>                        } else { <br>                        // idle time here, DONT BE A PIG! <br>                        WaitMessage(); <br>                } <br>        } <br>        return msg.wParam; <br>} <br> <br> <br>//---------------------------------------------------------------------------- <br>// MCI_OnCommand - Handles WM_COMMAND <br>//---------------------------------------------------------------------------- <br>static void MCI_OnCommand( <br>HWND hwnd, <br>int id, <br>HWND hwndCtl, <br>UINT codeNotify) <br>{ <br>        switch(id) { <br>                case MENU_ABOUT: <br>                DialogBox(ghInstApp,MAKEINTRESOURCE(ABOUTBOX),hwnd,AppAbout); <br>                break; <br> <br>                case MENU_EXIT: <br>                PostMessage(hwnd,WM_CLOSE,0,0L); <br>                break; <br> <br>                case MENU_CLOSE: <br>                PostMessage(ghwndMCI, WM_CLOSE, 0, 0L); <br>                break; <br> <br>                case MENU_OPEN: <br>                { <br>                        OPENFILENAME ofn; <br>                        char szFileName[BUFSIZE]; <br>                        char szFilter[BUFSIZE]; <br> <br>                        FormatFilterString( IDS_FILTERSTRING, szFilter ); <br> <br>                        /* prompt user for file to open */ <br>                        ofn.lStructSize = sizeof(OPENFILENAME); <br>                        ofn.hwndOwner = hwnd; <br>                        ofn.hInstance = NULL; <br>                        ofn.lpstrFilter = szFilter; <br>                        ofn.lpstrCustomFilter = NULL; <br>                        ofn.nMaxCustFilter = 0; <br>                        ofn.nFilterIndex = 0; <br>                        *szFileName = '\0'; <br>                        ofn.lpstrFile = szFileName; <br>                        ofn.nMaxFile = BUFSIZE; <br>                        ofn.lpstrFileTitle = NULL; <br>                        ofn.nMaxFileTitle = 0; <br>                        ofn.lpstrInitialDir = NULL; <br>                        ofn.lpstrTitle = "Open"; <br>                        ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY; <br>                        ofn.nFileOffset = 0; <br>                        ofn.nFileExtension = 0; <br>                        ofn.lpstrDefExt = NULL; <br>                        ofn.lCustData = 0; <br>                        ofn.lpfnHook = NULL; <br>                        ofn.lpTemplateName = NULL; <br> <br>                        if (GetOpenFileName(&amp;ofn)) { <br>                                MCIWndOpen(ghwndMCI, (LPARAM)(LPSTR)szFileName, 0); <br>                                InitPuzzle(&amp;gPuzzle, TRUE /* FALSE to not scramble */); <br>                        } <br>                } <br>                break; <br> <br> <br>                /* Movie Menu (for use by accelerators) */ <br>                case IDM_PLAY: <br>                        MCIWndPlay(ghwndMCI); <br>                        break; <br> <br>                case IDM_RPLAY: <br>                        MCIWndPlayReverse(ghwndMCI); <br>                        break; <br> <br>      // Solve or scramble the puzzle, as appropriate <br>                case IDM_SOLVE: <br>                case IDM_SCRAMBLE: <br>                    InitPuzzle(&amp;gPuzzle, id == IDM_SCRAMBLE); <br>                    InvalidateRect(ghwndMCI, NULL, FALSE); <br>                    break; <br>        } <br>        return; <br>} <br> <br>//---------------------------------------------------------------------------- <br>// MCI_OnSize - Handles WM_SIZE <br>//---------------------------------------------------------------------------- <br>static void MCI_OnSize( <br>HWND hwnd, <br>UINT state, <br>int cx, <br>int cy) <br>{ <br>if (!IsIconic(hwnd)) { <br>        MoveWindow(ghwndMCI,0,0,cx,cy,TRUE); <br>        } <br>} <br>//---------------------------------------------------------------------------- <br>// MCI_OnParentNotify - Handles WM_PARENTNOTIFY <br>//---------------------------------------------------------------------------- <br>static void MCI_OnParentNotify( <br>HWND hwnd, <br>UINT msg, <br>HWND hwndChild, <br>int idChild) <br>{ <br>    if (msg == WM_LBUTTONDOWN &amp;&amp; ghwndMCI) { <br>        RECT    rc; <br>        POINT   pt; <br> <br>        pt.x = (int)LOWORD((DWORD)hwndChild); <br>        pt.y = (int)HIWORD((DWORD)hwndChild); <br> <br>        ClientToScreen(hwnd, &amp;pt); <br> <br>        MCIWndGetDest(ghwndMCI, &amp;rc); <br> <br>        if (rc.bottom != rc.top &amp;&amp; rc.right != rc.left) { <br>            ScreenToClient(ghwndMCI, &amp;pt); <br> <br>            ClickPuzzle(&amp;gPuzzle, <br>                    (pt.x - rc.left) * PSIZE / (rc.right - rc.left), <br>                    (pt.y - rc.top) * PSIZE / (rc.bottom - rc.top)); <br> <br>            InvalidateRect(ghwndMCI, &amp;rc, FALSE); <br>        } <br>    } <br>    return; <br>} <br>/*----------------------------------------------------------------------------*\ <br>|   AppWndProc( hwnd, msg, wParam, lParam )                                    | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The window proc for the app's main (tiled) window.  This processes all | <br>|       of the parent window's messages.                                       | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hwnd            window handle for the parent window                    | <br>|       msg             message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       0 if processed, nonzero if ignored                                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>LRESULT CALLBACK AppWndProc( <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br> <br>    switch (msg) { <br>       case WM_CREATE: <br>                ghwndMCI = MCIWndCreate(hwnd, ghInstApp, WS_CHILD | WS_VISIBLE | <br>                        MCIWNDF_NOTIFYMEDIA | MCIWNDF_NOTIFYSIZE | MCIWNDF_NOMENU, 0); <br>                break; <br> <br>        case WM_COMMAND: <br>                HANDLE_WM_COMMAND(hwnd, wParam, lParam, MCI_OnCommand); <br>                break; <br> <br>        case WM_PALETTECHANGED: <br>        case WM_QUERYNEWPALETTE: <br>        case WM_ACTIVATE: <br>                // Forward palette-related messages through to the MCIWnd, <br>                // so it can do the right thing. <br>                if (ghwndMCI) <br>                        return SendMessage(ghwndMCI, msg, wParam, lParam); <br>                break; <br> <br>        case WM_SIZE: <br>                HANDLE_WM_SIZE(hwnd, wParam, lParam, MCI_OnSize); <br>                break; <br> <br>        case WM_DESTROY: <br>                PostQuitMessage(0); <br>                return (0); <br>                break; <br> <br>       case WM_PARENTNOTIFY: <br>                HANDLE_WM_PARENTNOTIFY(hwnd, wParam, lParam, MCI_OnParentNotify); <br>                break; <br> <br>       case MCIWNDM_NOTIFYMEDIA: <br>                Handle_NotifyMedia(hwnd, wParam); <br>                break; <br> <br>       case MCIWNDM_NOTIFYSIZE: <br>                Handle_NotifySize(hwnd, wParam); <br>                break; <br>        } <br> <br>        return DefWindowProc(hwnd,msg,wParam,lParam); <br>} <br> <br>/*--------------------------------------------------------------+ <br>| Handle_NotifyMedia                                            | <br>|                                                               | <br>+--------------------------------------------------------------*/ <br>static void Handle_NotifyMedia( <br>HWND hwnd, <br>WPARAM wParam) <br>{ <br>        MCI_DGV_SETVIDEO_PARMS dgv; <br>        DWORD dw; <br>        UINT uDevice; <br> <br>        if (ghwndMCI == 0) <br>                ghwndMCI = (HWND) wParam; <br> <br>        if (!gdwHook) <br>                gdwHook = (DWORD)ICAVIDrawProc; <br> <br>        dgv.dwValue = gdwHook; <br> <br>        dgv.dwItem = MCI_AVI_SETVIDEO_DRAW_PROCEDURE; <br> <br>        uDevice = MCIWndGetDeviceID(ghwndMCI); <br>        if (uDevice) { <br>                dw = mciSendCommand(uDevice, MCI_SETVIDEO, <br>                               MCI_DGV_SETVIDEO_ITEM | MCI_DGV_SETVIDEO_VALUE, <br>                               (DWORD)(LP_MCI_DGV)&amp;dgv); <br> <br>                if (dw != 0) { <br>                        char szTitle[BUFSIZE]; <br> <br>                        LoadString( ghInstApp, IDS_APPERR, szTitle, BUFSIZE ); <br>                        LoadString( ghInstApp, IDS_MCIERROR, gszBuffer, BUFSIZE ); <br> <br>                        MessageBox(hwnd, gszBuffer, szTitle, MB_OK | MB_ICONHAND); <br>                } <br>        } <br>        return; <br>} <br> <br> <br>/*--------------------------------------------------------------+ <br>| Handle_NotifySize                                             | <br>|                                                               | <br>+--------------------------------------------------------------*/ <br>static void Handle_NotifySize( <br>HWND hwnd, <br>WPARAM wParam) <br>{ <br>RECT rc; <br> <br>if (!IsIconic(hwnd)) { <br>        if (ghwndMCI == 0) <br>                ghwndMCI = (HWND) wParam; <br> <br>        GetWindowRect(ghwndMCI, &amp;rc); <br>        AdjustWindowRect(&amp;rc, GetWindowLong(hwnd, GWL_STYLE), TRUE); <br>        SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left, <br>rc.bottom - rc.top, <br>                SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE); <br>} <br>} <br>/*--------------------------------------------------------------+ <br>| FormatFilterString                                            | <br>|                                                               | <br>+--------------------------------------------------------------*/ <br>static BOOL FormatFilterString( <br>UINT uID, <br>LPSTR lpszString ) <br>{ <br>        int nLength, nCtr = 0; <br>        char chWildCard; <br> <br>        *lpszString = 0; <br> <br>        nLength = LoadString( ghInstApp, uID, lpszString, BUFSIZE ); <br> <br>        chWildCard = lpszString[nLength-1]; <br> <br>        while( lpszString[nCtr] ) { <br>                if( lpszString[nCtr] == chWildCard ) <br>                        lpszString[nCtr] = 0; <br>                nCtr++; <br>        } <br> <br>        return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
