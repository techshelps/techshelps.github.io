<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PUZZLE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2504"></a>PUZZLE.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define  STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include "puzzle.h" <br> <br>#define MEM_COPY( hpd, hps, size ) memcpy( hpd, hps, size ) <br>#define DATA_PTR BYTE * <br> <br>#define WIDTHBYTES(i)     ((unsigned)((i+31)&amp;(~31))/8)  /* ULONG aligned ! */ <br>#define DIBWIDTHBYTES(bi) (DWORD)WIDTHBYTES((int)(bi).biWidth * (int)(bi).biBitCount) <br> <br>// <br>// Initialize the puzzle, and optionally simulate 1000 clicks on the puzzle <br>// <br>void InitPuzzle( <br>LPPUZZLE p, <br>BOOL fScramble) <br>{ <br>        int i,j; <br> <br>        // Set the puzzle to a "solved" state <br>        for (i = 0; i &lt; PSIZE; i++) <br>                for (j = 0; j &lt; PSIZE; j++) <br>                        p-&gt;a[i][j] = i + j * PSIZE; <br> <br>        // Put the "hole" in the lower right corner. <br>        p-&gt;a[PSIZE-1][PSIZE-1] = -1; <br>        p-&gt;hx = PSIZE - 1; <br>        p-&gt;hy = PSIZE - 1; <br> <br>        if(fScramble) { <br>                // Make things really be random <br>                srand((unsigned int) timeGetTime()); <br> <br>                for (i = 0; i &lt; 1000; i++) { <br>                        // Click on a random square <br>                        int r = rand() % PSIZE; <br>                        int s = rand() % PSIZE; <br>                        ClickPuzzle(p, r, s); <br>                } <br>        } <br>} <br> <br>// <br>// Given a puzzle, and x &amp; y in puzzle coordinates, move squares around <br>// or not as appropriate, given how such puzzles work. <br>// <br>void ClickPuzzle( <br>LPPUZZLE p, <br>int x, <br>int y) <br>{ <br>        int i; <br> <br>        if (x &lt; 0 || x &gt;= PSIZE) <br>                return; <br> <br>        if (y &lt; 0 || y &gt;= PSIZE) <br>                return; <br> <br>        if (x == p-&gt;hx) { <br>                if (y &lt; p-&gt;hy) { <br>                        for (i = p-&gt;hy; i &gt; y; i--) <br>                                p-&gt;a[x][i] = p-&gt;a[x][i-1]; <br>                } else if (y &gt; p-&gt;hy) { <br>                        for (i = p-&gt;hy; i &lt; y; i++) <br>                                p-&gt;a[x][i] = p-&gt;a[x][i+1]; <br>                } <br>                p-&gt;hy = y; <br>                p-&gt;a[x][y] = -1; <br>        } else if (y == p-&gt;hy) { <br>                if (x &lt; p-&gt;hx) { <br>                        for (i = p-&gt;hx; i &gt; x; i--) <br>                                p-&gt;a[i][y] = p-&gt;a[i-1][y]; <br>                } else if (x &gt; p-&gt;hx) { <br>                        for (i = p-&gt;hx; i &lt; x; i++) <br>                                p-&gt;a[i][y] = p-&gt;a[i+1][y]; <br>                } <br>                p-&gt;hx = x; <br>                p-&gt;a[x][y] = -1; <br>        } <br> <br>        // We could potentially see if the puzzle was solved here. <br>        // If we do that, the prototype should change to <br>        // BOOL ClickPuzzle(LPPUZZLE p, int x, int y, BOOL fCheckSolved) <br>        // where we would pass TRUE for fCheckSolved if the call was <br>        // a result of the user really clicking, and not a call from <br>        // InitPuzzle() or something.... <br>} <br> <br> <br>// <br>// Given a puzzle, map the input picture to the output picture with squares <br>// rearranged. <br>// <br>// Works on any RGB DIB.  Doesn't work on bitmaps, probably, so could be a <br>// problem with Todd's new DrawDib. <br>// <br>void MixPicture( <br>LPPUZZLE p, <br>LPBITMAPINFOHEADER lpbi, <br>LPBYTE lpIn, <br>LPBYTE lpOut) <br>{ <br>        int i,j; <br>        int y; <br>        char achHack[1024] = {0}; <br>        int dx = ((int) lpbi-&gt;biWidth / PSIZE) * ((int) lpbi-&gt;biBitCount / 8); <br>        int dy = (int) lpbi-&gt;biHeight / PSIZE; <br>        LONG lRowBytes = DIBWIDTHBYTES(*lpbi); <br>        DATA_PTR lpI; <br>        DATA_PTR lpO; <br> <br>        for (i = 0; i &lt; PSIZE; i++) { <br>                for (j = 0; j &lt; PSIZE; j++) { <br>                        // Get pointer to square we're copying into <br>                        lpO = (DATA_PTR) lpOut + (PSIZE - 1 - j) * dy * lRowBytes + dx * i; <br> <br>                        if (p-&gt;a[i][j] &gt;= 0) { <br>                                // Get pointer to square we're copying from <br>                                lpI = (DATA_PTR) lpIn + <br>                                                (PSIZE - 1 - (p-&gt;a[i][j] / PSIZE)) * dy * lRowBytes + <br>                                                dx * (p-&gt;a[i][j] % PSIZE); <br> <br>                                // do the copy <br>                                for (y = 0; y &lt; dy; y++) { <br>                                        MEM_COPY(lpO, lpI, dx); <br>                                        lpO += lRowBytes; <br>                                        lpI += lRowBytes; <br>                                } <br>                        } else { <br>                                // clear the square to zeroes <br>                                for (y = 0; y &lt; dy; y++) { <br>                                        MEM_COPY(lpO, achHack, dx); <br>                                        lpO += lRowBytes; <br>                                } <br>                        } <br>                } <br>        } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
