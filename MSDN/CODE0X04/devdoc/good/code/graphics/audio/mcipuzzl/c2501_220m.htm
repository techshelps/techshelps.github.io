<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PUZZPROC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2506"></a>PUZZPROC.C</h2>
<pre><code>/**************************************************************************** <br> * <br> *  PUZZPROC.C <br> * <br> *  Modification of standard AVI drawing handler. <br> * <br> ***************************************************************************/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define  STRICT <br>#define  INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "puzzproc.h" <br>#include "puzzle.h" <br> <br>#define LOCAL  __stdcall <br>#define SZCODE char <br> <br>static SZCODE szDescription[] = "Microsoft Puzzle Draw handler"; <br>static SZCODE szName[]        = "MS Puzzle"; <br> <br>#define FOURCC_AVIDraw          mmioFOURCC('P','U','Z','Z') <br>#define VERSION_AVIDraw         0x00010000      // 1.00 <br> <br>extern PUZZLE   gPuzzle; <br> <br>/*************************************************************************** <br> ***************************************************************************/ <br> <br>typedef struct { <br>    HDRAWDIB            hdd; <br>    HDC                 hdc;            // HDC to draw to <br>    int                 xDst;           // destination rectangle <br>    int                 yDst; <br>    int                 dxDst; <br>    int                 dyDst; <br>    int                 xSrc;           // source rectangle <br>    int                 ySrc; <br>    int                 dxSrc; <br>    int                 dySrc; <br>    LPBYTE              lpBuffer; <br>} INSTINFO; <br> <br> <br>/*************************************************************************** <br> ***************************************************************************/ <br> <br>typedef ICOPEN *                LPICOPEN; <br>typedef ICINFO *                LPICINFO; <br>typedef ICDRAW *                LPICDRAW; <br>typedef ICDRAWSUGGEST *         LPICDRAWSUGGEST; <br>typedef ICDRAWBEGIN *           LPICDRAWBEGIN; <br>typedef INSTINFO *              LPINSTINFO; <br> <br>/*************************************************************************** <br> ***************************************************************************/ <br> <br>// static stuff in this file. <br>static LONG LOCAL AVIDrawOpen(LPICOPEN); <br>static LONG LOCAL AVIDrawClose(LPINSTINFO); <br>static LONG LOCAL AVIDrawGetInfo(LPICINFO, LONG); <br>static LONG LOCAL AVIDrawQuery(LPINSTINFO, LPBITMAPINFOHEADER); <br>static LONG LOCAL AVIDrawSuggestFormat(LPINSTINFO, LPICDRAWSUGGEST, LONG); <br>static LONG LOCAL AVIDrawBegin(LPINSTINFO, LPICDRAWBEGIN, LONG); <br>static LONG LOCAL AVIDraw(LPINSTINFO, LPICDRAW, LONG); <br>static LONG LOCAL AVIDrawEnd(LPINSTINFO); <br>static LONG LOCAL AVIDrawChangePalette(LPINSTINFO, LPBITMAPINFOHEADER); <br> <br>/*************************************************************************** <br> ***************************************************************************/ <br> <br>LONG CALLBACK ICAVIDrawProc( <br>DWORD id, <br>HDRVR hDriver, <br>UINT uiMessage, <br>LPARAM lParam1, <br>LPARAM lParam2) <br>{ <br>        LPINSTINFO pi = (LPINSTINFO)id; <br> <br>        switch (uiMessage) { <br> <br>                case DRV_LOAD: <br>                case DRV_FREE: <br>                        return 1L; <br> <br>                //open <br>                case DRV_OPEN: <br>                        if (lParam2 == 0L) <br>                                return 1L; <br>                        else <br>                                return AVIDrawOpen((LPICOPEN)lParam2); <br> <br>                //close <br>                case DRV_CLOSE: <br>                        return AVIDrawClose(pi); <br> <br>                //Configure and Info messages <br>                case DRV_QUERYCONFIGURE:    // configuration from drivers applet <br>                        return 0; <br> <br>                case DRV_CONFIGURE: <br>                        return 1; <br> <br>                case ICM_CONFIGURE: <br>                case ICM_ABOUT: <br>                        return ICERR_UNSUPPORTED; <br> <br>                case ICM_GETINFO: <br>                        return AVIDrawGetInfo((LPICINFO)lParam1, lParam2); <br> <br>                //state messages <br>                case ICM_GETSTATE: <br>                case ICM_SETSTATE: <br>                        return 0L; <br> <br>                //draw messages <br>                case ICM_DRAW_QUERY: <br>                        return AVIDrawQuery(pi, (LPBITMAPINFOHEADER)lParam1); <br> <br>                case ICM_DRAW_SUGGESTFORMAT: <br>                        return AVIDrawSuggestFormat(pi, (LPICDRAWSUGGEST) lParam1, lParam2); <br> <br>                case ICM_DRAW_BEGIN: <br>                        return AVIDrawBegin(pi, (LPICDRAWBEGIN) lParam1, lParam2); <br> <br>                case ICM_DRAW_REALIZE: <br>                        pi-&gt;hdc = (HDC) lParam1; <br>                        if (!pi-&gt;hdc || !pi-&gt;hdd) <br>                                break; <br>                        return DrawDibRealize(pi-&gt;hdd, pi-&gt;hdc, (BOOL) lParam2); <br> <br>                case ICM_DRAW_GET_PALETTE: <br>                        if (!pi-&gt;hdd) <br>                                break; <br>                        return (LONG) (UINT) DrawDibGetPalette(pi-&gt;hdd); <br> <br>                case ICM_DRAW: <br>                        return AVIDraw(pi, (LPICDRAW)lParam1, lParam2); <br> <br>                case ICM_DRAW_CHANGEPALETTE: <br>                        return AVIDrawChangePalette(pi, (LPBITMAPINFOHEADER) lParam1); <br> <br>                case ICM_DRAW_END: <br>                        return AVIDrawEnd(pi); <br> <br>                //standard driver messages <br>                case DRV_DISABLE: <br>                case DRV_ENABLE: <br>                        return 1L; <br> <br>                case DRV_INSTALL: <br>                case DRV_REMOVE: <br>                        return 1L; <br>        } <br>        if (uiMessage &lt; DRV_USER) <br>                return DefDriverProc(id,hDriver,uiMessage,lParam1,lParam2); <br>        else <br>                return ICERR_UNSUPPORTED; <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawOpen() is called from the DRV_OPEN message <br> * <br> ****************************************************************************/ <br> <br>static LONG LOCAL AVIDrawOpen( <br>LPICOPEN icopen) <br>{ <br>        LPINSTINFO pinst; <br> <br>        // refuse to open if we are not being opened as a video draw device <br>        if (icopen-&gt;fccType != streamtypeVIDEO) <br>                return 0L; <br> <br>        if (icopen-&gt;dwFlags == ICMODE_COMPRESS) <br>                return 0L; <br> <br>        if (icopen-&gt;dwFlags == ICMODE_DECOMPRESS) <br>                return 0L; <br> <br>        pinst = (LPINSTINFO)GlobalAllocPtr(GHND, sizeof(INSTINFO)); <br> <br>        if (!pinst) { <br>                icopen-&gt;dwError = ICERR_MEMORY; <br>                return 0L; <br>        } <br> <br>        // init structure <br>        pinst-&gt;hdd = DrawDibOpen(); <br> <br>        // return success. <br>        icopen-&gt;dwError = ICERR_OK; <br> <br>        return (LONG)pinst; <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawClose() is called on the DRV_CLOSE message. <br> * <br> ****************************************************************************/ <br>static LONG LOCAL AVIDrawClose( <br>LPINSTINFO pi) <br>{ <br>        if (pi-&gt;hdd) <br>                DrawDibClose(pi-&gt;hdd); <br> <br>        if (pi-&gt;lpBuffer) <br>                GlobalFreePtr(pi-&gt;lpBuffer); <br> <br>        GlobalFreePtr(pi); <br>        return 1L; <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawGetInfo() implements the ICM_GETINFO message <br> * <br> ****************************************************************************/ <br>static LONG LOCAL AVIDrawGetInfo( <br>LPICINFO icinfo, <br>LONG lSize) <br>{ <br>        if (icinfo == NULL) <br>                return sizeof(ICINFO); <br> <br>        if (lSize &lt; sizeof(ICINFO)) <br>                return 0L; <br> <br>        icinfo-&gt;dwSize          = sizeof(ICINFO); <br>        icinfo-&gt;fccType         = ICTYPE_VIDEO; <br>        icinfo-&gt;fccHandler      = FOURCC_AVIDraw; <br>        icinfo-&gt;dwFlags         = VIDCF_DRAW; <br>        icinfo-&gt;dwVersion       = VERSION_AVIDraw; <br>        icinfo-&gt;dwVersionICM    = ICVERSION; <br>        MultiByteToWideChar(CP_ACP, 0, szDescription, -1, icinfo-&gt;szDescription, sizeof(icinfo-&gt;szDescription)); <br>        MultiByteToWideChar(CP_ACP, 0, szName, -1, icinfo-&gt;szDescription, sizeof(icinfo-&gt;szDescription)); <br>        return sizeof(ICINFO); <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawQuery() implements ICM_DRAW_QUERY <br> * <br> ****************************************************************************/ <br>static LONG LOCAL AVIDrawQuery( <br>LPINSTINFO pi, <br>LPBITMAPINFOHEADER lpbiIn) <br>{ <br>        // determine if the input DIB data is in a format we like. <br>        if (lpbiIn == NULL) <br>                return ICERR_BADFORMAT; <br> <br>        // determine if the input DIB data is in a format we like. <br>        if (lpbiIn-&gt;biCompression != BI_RGB) <br>                return ICERR_BADFORMAT; <br> <br>        return ICERR_OK; <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawSuggestFormat() implements ICM_DRAW_SUGGESTFORMAT <br> * <br> ****************************************************************************/ <br> <br>static LONG LOCAL AVIDrawSuggestFormat( <br>LPINSTINFO pi, <br>LPICDRAWSUGGEST lpicd, <br>LONG cbicd) <br>{ <br>        HIC hic; <br>        LONG l; <br> <br>        if (lpicd-&gt;lpbiSuggest == NULL) <br>                return sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD); <br> <br>        // Call COMPMAN to get a good format to display data in.... <br>        hic = ICGetDisplayFormat(NULL, lpicd-&gt;lpbiIn, lpicd-&gt;lpbiSuggest, <br>                                                0, lpicd-&gt;dxDst, lpicd-&gt;dyDst); <br> <br>        if (hic) <br>                ICClose(hic); <br> <br>        l = lpicd-&gt;lpbiSuggest-&gt;biClrUsed; <br> <br>        if (lpicd-&gt;lpbiSuggest) <br>                if (lpicd-&gt;lpbiSuggest-&gt;biCompression == BI_RLE8) <br>                        lpicd-&gt;lpbiSuggest-&gt;biCompression = BI_RGB; <br> <br>        // !!! Should check this format here to make sure it's RGB... <br>        // !!! If not, we could force it to 8-bit.... <br> <br>        l = l * sizeof(RGBQUAD); <br>        return l + sizeof(BITMAPINFOHEADER); <br>} <br> <br>/***************************************************************************** <br> * <br> * AVIDrawBegin() implements ICM_DRAW_BEGIN <br> * <br> ****************************************************************************/ <br> <br>static LONG LOCAL AVIDrawBegin( <br>LPINSTINFO pi, <br>LPICDRAWBEGIN lpicd, <br>LONG cbicd) <br>{ <br>        LONG l = AVIDrawQuery(pi, lpicd-&gt;lpbi); <br> <br>        if ((l != 0) || (lpicd-&gt;dwFlags &amp; ICDRAW_QUERY)) <br>                return l; <br> <br>        // Copy over whatever we want to remember <br>        pi-&gt;hdc = lpicd-&gt;hdc; <br>        pi-&gt;xDst = lpicd-&gt;xDst; <br>        pi-&gt;yDst = lpicd-&gt;yDst; <br>        pi-&gt;dxDst = lpicd-&gt;dxDst; <br>        pi-&gt;dyDst = lpicd-&gt;dyDst; <br>        pi-&gt;xSrc = lpicd-&gt;xSrc; <br>        pi-&gt;ySrc = lpicd-&gt;ySrc; <br>        pi-&gt;dxSrc = lpicd-&gt;dxSrc; <br>        pi-&gt;dySrc = lpicd-&gt;dySrc; <br> <br>        SetStretchBltMode(pi-&gt;hdc, COLORONCOLOR); <br> <br>        if (!DrawDibBegin( <br>                        pi-&gt;hdd, <br>                        pi-&gt;hdc, <br>                        pi-&gt;dxDst, <br>                        pi-&gt;dyDst, <br>                        lpicd-&gt;lpbi, <br>                        pi-&gt;dxSrc, <br>                        pi-&gt;dySrc, <br>                        0)) {  // !!! Flags? <br>                return ICERR_UNSUPPORTED; <br>        } <br> <br>        // !!! error check <br> <br>        // Allocate a buffer for the scrambled picture <br>        if (pi-&gt;lpBuffer) <br>                GlobalFreePtr(pi-&gt;lpBuffer); <br> <br>        pi-&gt;lpBuffer = GlobalAllocPtr(GMEM_MOVEABLE, lpicd-&gt;lpbi-&gt;biSizeImage); <br> <br>        if (!pi-&gt;lpBuffer) <br>                return ICERR_MEMORY; <br> <br>        return ICERR_OK; <br>} <br>/***************************************************************************** <br> * <br> * AVIDraw() implements ICM_DRAW <br> * <br> ****************************************************************************/ <br> <br>static LONG LOCAL AVIDraw( <br>LPINSTINFO pi, <br>LPICDRAW lpicd, <br>LONG cbicd) <br>{ <br>        UINT wFlags = DDF_SAME_HDC; <br> <br>        if ((lpicd-&gt;dwFlags &amp; ICDRAW_NULLFRAME) || lpicd-&gt;lpData == NULL) { <br>                if (lpicd-&gt;dwFlags &amp; ICDRAW_UPDATE) <br>                        wFlags |= DDF_UPDATE; <br>                else <br>                        return ICERR_OK;            // nothing to draw <br>        } <br> <br>        if (lpicd-&gt;dwFlags &amp; ICDRAW_PREROLL) <br>                wFlags |= DDF_DONTDRAW; <br> <br>        if (lpicd-&gt;dwFlags &amp; ICDRAW_HURRYUP) <br>                wFlags |= DDF_HURRYUP; <br> <br>        // This is the only part that actually has to do with the puzzle: <br>        // Mix up the picture into our extra buffer. <br>        if (lpicd-&gt;lpData) <br>                MixPicture(&amp;gPuzzle, lpicd-&gt;lpFormat, lpicd-&gt;lpData, pi-&gt;lpBuffer); <br> <br>        if (!DrawDibDraw( <br>                        pi-&gt;hdd, <br>                        pi-&gt;hdc, <br>                        pi-&gt;xDst, <br>                        pi-&gt;yDst, <br>                        pi-&gt;dxDst, <br>                        pi-&gt;dyDst, <br>                        lpicd-&gt;lpFormat, <br>                        pi-&gt;lpBuffer, <br>                        pi-&gt;xSrc, <br>                        pi-&gt;ySrc, <br>                        pi-&gt;dxSrc, <br>                        pi-&gt;dySrc, <br>                        wFlags)) { <br>                if (wFlags &amp; DDF_UPDATE) <br>                        return ICERR_CANTUPDATE; <br>                else <br>                        return ICERR_UNSUPPORTED; <br>        } <br> <br>        return ICERR_OK; <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawChangePalette() implements ICM_DRAW_CHANGE_PALETTE <br> * <br> ****************************************************************************/ <br> <br>static LONG LOCAL AVIDrawChangePalette( <br>LPINSTINFO pi, <br>LPBITMAPINFOHEADER lpbi) <br>{ <br>        PALETTEENTRY ape[256]; <br>        LPRGBQUAD lprgb = (LPRGBQUAD) ((LPBYTE) lpbi + lpbi-&gt;biSize); <br>        int i; <br> <br>        for (i = 0; i &lt; (int) lpbi-&gt;biClrUsed; i++) { <br>                ape[i].peRed = lprgb[i].rgbRed; <br>                ape[i].peGreen = lprgb[i].rgbGreen; <br>                ape[i].peBlue = lprgb[i].rgbBlue; <br>                ape[i].peFlags = 0; <br>        } <br> <br>        DrawDibChangePalette(pi-&gt;hdd, 0, (int) lpbi-&gt;biClrUsed, (LPPALETTEENTRY)ape); <br>        return ICERR_OK; <br>} <br>/***************************************************************************** <br> * <br> * AVIDrawEnd() implements ICM_DRAW_END <br> * <br> ****************************************************************************/ <br> <br>static LONG LOCAL AVIDrawEnd( <br>LPINSTINFO pi) <br>{ <br>        // Note: do not call DrawDibEnd here, as we still may be asked to <br>        // update our current display, and calling DrawDibEnd would wipe <br>        // that out. <br> <br>        return ICERR_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
