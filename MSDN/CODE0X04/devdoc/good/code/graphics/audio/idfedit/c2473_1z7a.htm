<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HEAD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2476"></a>HEAD.C</h2>
<pre><code>//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//**  A PARTICULAR PURPOSE. <br>//** <br>//**  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>//** <br>//**  head.c <br>//** <br>//**  DESCRIPTION: <br>//**     Window proc for IDF head pane <br>//** <br>//************************************************************************ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commctrl.h&gt; <br> <br>#include "idfedit.h" <br>#include "tridee.h" <br> <br>/*+ <br> * <br> *-=================================================================*/ <br> <br>STATICFN void LoadTree ( <br>   HWND      hWndT, <br>   struct _instrum_info * piSelect, <br>   LPIDFHEAD pih) <br>{ <br>   HTREEITEM htiSelect = NULL; <br>   HTREEITEM htiParent = TVI_ROOT; <br>   struct _instrum_info * pi; <br>   UINT  ii; <br> <br>   TreeView_DeleteAllItems(hWndT); <br> <br>   for (pi = &amp;pih-&gt;ai[ii = 0]; ii &lt; pih-&gt;nInstrum; ++ii, ++pi) <br>      { <br>      TV_INSERTSTRUCT ti; <br>      HTREEITEM       hti; <br> <br>      ZeroMemory (&amp;ti, sizeof(ti)); <br> <br>      ti.hParent        = TVI_ROOT; <br>      ti.hInsertAfter   = TVI_SORT; <br>      ti.item.mask      = TVIF_TEXT | TVIF_STATE | TVIF_PARAM; <br>      ti.item.state     = TVIS_EXPANDED; <br>      ti.item.stateMask = 0xFF; <br>      ti.item.lParam    = (LPARAM)pi; <br> <br>      if (pi-&gt;pInstrum) <br>         ti.item.pszText = pi-&gt;pInstrum-&gt;szInstID; <br>      else if (pi-&gt;pList) <br>         { <br>         LPRIFF pRiff = FindListChunk(pi-&gt;pList, FCC_hdr); <br>         if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFHEADER)) <br>            ti.item.pszText = ((LPIDFHEADER)(pRiff+1))-&gt;abInstID; <br>         }                                                              <br>          <br> <br>      assert (ti.item.pszText); <br>      if ( ! ti.item.pszText) <br>         continue; <br> <br>      hti = TreeView_InsertItem (hWndT, &amp;ti); <br> <br>      if (piSelect &amp;&amp; (piSelect == pi)) <br>         htiSelect = hti; <br>      } <br> <br>   if (htiSelect) <br>      { <br>      assert (piSelect); <br>      TreeView_SelectItem (hWndT, htiSelect); <br>      } <br>} <br> <br>/*+ <br> *  HeadPrivate <br> * <br> *-=================================================================*/ <br> <br>static LONG WINAPI HeadPrivate ( <br>   HWND   hWnd, <br>   UINT   wMsgID, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   LPIDFHEAD  pih; <br> <br>   pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br> <br>   switch (wMsgID) <br>      { <br>      case HM_REFRESH_TREE: <br>         LoadTree(pih-&gt;hWndTree, pih-&gt;piSelect, pih); <br>         InvalidateRect (hWnd, NULL, FALSE); <br>         break; <br>      } <br> <br>   return lRet; <br>   } <br> <br>/*+ <br> *  HeadCommands <br> * <br> *-=================================================================*/ <br> <br>LONG WINAPI HeadCommands ( <br>   HWND   hWnd, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   LPIDFHEAD  pih; <br> <br>   pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br> <br>   switch (GET_WM_COMMAND_ID(wParam,lParam)) <br>      { <br>      } <br> <br>   return lRet; <br>   } <br> <br>/*+ <br> *   <br> * <br> *-=================================================================*/ <br> <br>STATICFN BOOL WINAPI HandleInstrumentsSelChange ( <br>    HWND      hWnd, <br>    LPNMHDR   lpnm, <br>    LPIDFHEAD pih) <br>{ <br>   LPNM_TREEVIEW pntv = (LPVOID)lpnm; <br>   LPTV_ITEM     pti  = &amp;pntv-&gt;itemNew; <br>   //TV_ITEM       ti; <br>   struct _instrum_info * pi; <br>   //char          szSingle[MAX_ALIAS]; <br>   //BOOL          bChange = FALSE; <br> <br>   if (!pih) <br>      return FALSE; <br> <br>   // if there was a valid previous selection. <br>   // make sure that there a now changes to be <br>   // saved off before we allow selection to proceed. <br>   // <br>   pi = (LPVOID)pntv-&gt;itemNew.lParam; <br>   if (pi &amp;&amp; !pi-&gt;pInstrum &amp;&amp; <br>       (pih-&gt;piSelect == pi) &amp;&amp;  <br>       (pih-&gt;pInstrumSelect == &amp;pih-&gt;instrum) &amp;&amp; <br>       (pih-&gt;instrum.bChanged)) <br>      { <br>      assert (0); <br>      // need to save changes made to the instrument data <br>      // <br>      pi-&gt;pInstrum = CopyForEditing (&amp;pih-&gt;instrum, sizeof(pih-&gt;instrum)); <br>      pih-&gt;bChanged = TRUE; <br>      } <br> <br>   // setup ti to get text &amp; # of children <br>   // from the IDF filename entry. <br>   // <br>   //ti.mask       = TVIF_PARAM; <br>   //ti.mask       = TVIF_TEXT | TVIF_PARAM; <br>   //ti.pszText    = szSingle; <br>   //ti.cchTextMax = NUMELMS(szSingle); <br>   //ti.hItem      = pti-&gt;hItem; <br>   //TreeView_GetItem (lpnm-&gt;hwndFrom, &amp;ti); <br>   //pi = (LPVOID)ti.lParam; <br>   pi = (LPVOID)pti-&gt;lParam; <br>   if (!pi) <br>      return FALSE; <br> <br>   // if the selected instrument has no editable data set,  <br>   // copy the raw RIFF data into the temp edit set <br>   // and display instrument settings from there. <br>   // <br>   pih-&gt;piSelect = NULL; <br>   pih-&gt;pInstrumSelect = NULL; <br>   if (pih-&gt;nInstrum) <br>      { <br>      pih-&gt;piSelect = pi; <br>      pih-&gt;pInstrumSelect = pi-&gt;pInstrum; <br>      if (!pi-&gt;pInstrum) <br>         { <br>         CopyInstrumData (&amp;pih-&gt;instrum, pi-&gt;pList); <br>         pih-&gt;pInstrumSelect = &amp;pih-&gt;instrum; <br>         } <br>      } <br> <br>   View_SetData (pih-&gt;hWndInstrument, pih-&gt;pInstrumSelect); <br>   View_InvalidateLines (pih-&gt;hWndInstrument, 0, 0); <br>   return TRUE; <br>} <br> <br>/*+ <br> *  HeadNotifications <br> * <br> *-=================================================================*/ <br> <br>LONG WINAPI HeadNotifications ( <br>   HWND     hWnd, <br>   LPNMHDR  lpnm) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   LPIDFHEAD  pih; <br> <br>   pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br> <br>   switch (lpnm-&gt;idFrom) <br>      { <br>      case IDL_INSTRUMENTS: <br>         switch (lpnm-&gt;code) <br>            { <br>            case TVN_SELCHANGED: <br>                HandleInstrumentsSelChange (hWnd, lpnm, pih); <br>                break; <br> <br>            //case NM_DBLCLK: <br>            //    break; <br> <br>            case TVN_ENDLABELEDIT: <br>                { <br>                TV_DISPINFO * ptv = (LPVOID)lpnm; <br>                struct _instrum_info * pi = (LPVOID)ptv-&gt;item.lParam; <br> <br>                if (!pi) <br>                   break; <br> <br>                if (!pi-&gt;pInstrum) <br>                   { <br>                   if (pih-&gt;piSelect == pi &amp;&amp; pih-&gt;pInstrumSelect == &amp;pih-&gt;instrum) <br>                      pi-&gt;pInstrum = CopyForEditing (&amp;pih-&gt;instrum, sizeof(pih-&gt;instrum)); <br>                   else <br>                      { <br>                      assert (0); // shoundn't be able to label edit without first selecting <br>                      pi-&gt;pInstrum = HeapAlloc (gs.idf.hEditHeap, 0, sizeof(INSTRUMENT)); <br>                      CopyInstrumData (pi-&gt;pInstrum, pi-&gt;pList); <br>                      } <br>                   } <br>                   <br>                lstrcpyn (pi-&gt;pInstrum-&gt;szInstID, ptv-&gt;item.pszText, NUMELMS(pi-&gt;pInstrum-&gt;szInstID)); <br>                pi-&gt;pInstrum-&gt;bChanged = TRUE; <br>                pih-&gt;bChanged = TRUE; <br>                View_InvalidateLines (pih-&gt;hWndInstrument, 0, 0); <br>                lRet = 1; <br>                } <br>                break; <br>            } <br>         break; <br> <br>      case IDC_CURRENT_INSTRUM: <br>         switch (lpnm-&gt;code) <br>            { <br>            case VN_CHANGE: <br>               if (pih-&gt;pInstrumSelect) <br>                  { <br>                  if (pih-&gt;pInstrumSelect == &amp;pih-&gt;instrum) <br>                     { <br>                     assert (!pih-&gt;piSelect-&gt;pInstrum); <br>                     if ( ! pih-&gt;piSelect-&gt;pInstrum) <br>                        { <br>                        pih-&gt;pInstrumSelect = <br>                        pih-&gt;piSelect-&gt;pInstrum = CopyForEditing (&amp;pih-&gt;instrum, sizeof(pih-&gt;instrum)); <br>                        View_SetData (pih-&gt;hWndInstrument, pih-&gt;pInstrumSelect); <br>                        View_InvalidateLines (pih-&gt;hWndInstrument, 0, 0); <br>                        } <br>                     } <br>                  pih-&gt;pInstrumSelect-&gt;bChanged = TRUE; <br>                  pih-&gt;bChanged = TRUE; <br>                  } <br>               else <br>                  { <br>                  assert (0); <br>                  } <br>               break; <br>            } <br>         break; <br>      } <br> <br>   return lRet; <br>   } <br> <br>/*+ <br> *  HeadWndProc <br> * <br> *-=================================================================*/ <br> <br>LONG CALLBACK HeadWndProc ( <br>   HWND   hWnd, <br>   UINT   wMsgID, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   if (wMsgID &gt;= WM_USER &amp;&amp; wMsgID &lt; 0x8000) <br>      lRet = HeadPrivate (hWnd, wMsgID, wParam, lParam); <br>   else <br>   switch (wMsgID) <br>      { <br>      case WM_COMMAND: <br>         lRet = HeadCommands (hWnd, wParam, lParam); <br>         break; <br> <br>      case WM_NOTIFY: <br>         lRet = HeadNotifications (hWnd, (LPNMHDR)lParam); <br>         break; <br> <br>      case WM_SIZE: <br>         { <br>         LPIDFHEAD pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br>         HDC hDC; <br>         TEXTMETRIC tm; <br>         #define BORDER 0 <br> <br>         hDC = GetDC (hWnd); <br>         //if (pih-&gt;hFont) <br>         //   SelectObject (hDC, pih-&gt;hFont); <br>         GetTextMetrics (hDC, &amp;tm); <br>         pih-&gt;ptClient.y = tm.tmHeight + tm.tmExternalLeading + 6; <br>         pih-&gt;ptClient.x = 0; <br>         ReleaseDC (hWnd, hDC); <br> <br>         pih-&gt;sClient.cx = LOWORD(lParam) - pih-&gt;ptClient.x; <br>         pih-&gt;sClient.cy = HIWORD(lParam) - pih-&gt;ptClient.y; <br> <br>         SetWindowPos (pih-&gt;hWndTree, NULL, <br>                       pih-&gt;ptClient.x, pih-&gt;ptClient.y, <br>                       pih-&gt;cxTree, pih-&gt;sClient.cy, <br>                       SWP_NOZORDER); <br> <br>         SetWindowPos (pih-&gt;hWndInstrument, NULL, <br>                       pih-&gt;ptClient.x + pih-&gt;cxTree + BORDER, pih-&gt;ptClient.y, <br>                       pih-&gt;sClient.cx - pih-&gt;cxTree - BORDER, pih-&gt;sClient.cy, <br>                       SWP_NOZORDER); <br>         } <br>         break; <br> <br>      case WM_CREATE: <br>         { <br>         LPCREATESTRUCT    lpCreate = (LPCREATESTRUCT)lParam; <br>         LPIDFHEAD         pih; <br> <br>         SetWindowLong (hWnd, GWL_USERDATA, 0); <br> <br>         pih = (LPVOID)lpCreate-&gt;lpCreateParams; <br>         if (!pih) <br>             return -1; <br>         SetWindowLong (hWnd, GWL_USERDATA, (LONG)pih); <br> <br>         pih-&gt;cxTree = LOWORD(GetDialogBaseUnits()) * 20; <br> <br>         pih-&gt;hWndTree =  <br>             CreateWindowEx (fdwExStyle | WS_EX_NOPARENTNOTIFY, <br>                             WC_TREEVIEW, <br>                             "", <br>                             TVS_DISABLEDRAGDROP | <br>                             TVS_SHOWSELALWAYS | <br>                             TVS_EDITLABELS | <br>                             WS_CHILD | WS_VISIBLE | WS_BORDER, <br>                             0, 0, pih-&gt;cxTree, 0, <br>                             hWnd, <br>                             (HMENU)IDL_INSTRUMENTS, <br>                             hInst, <br>                             NULL); <br>         if ( ! pih-&gt;hWndTree) <br>            lRet = -1; <br> <br>         pih-&gt;hWndInstrument =  <br>             CreateWindowEx (fdwExStyle | WS_EX_NOPARENTNOTIFY, <br>                             cszInstrumClass, <br>                             "", <br>                             WS_CHILD | WS_VISIBLE | WS_BORDER, <br>                             pih-&gt;cxTree + 6, 0, 200, 0, <br>                             hWnd, <br>                             (HMENU)IDC_CURRENT_INSTRUM, <br>                             hInst, <br>                             &amp;pih-&gt;vi); <br>         if ( ! pih-&gt;hWndInstrument) <br>            lRet = -1; <br> <br>         LoadTree (pih-&gt;hWndTree, &amp;pih-&gt;ai[0], pih); <br>         LoadString (hInst, IDS_TREE_LABEL, pih-&gt;szTreeLabel, NUMELMS(pih-&gt;szTreeLabel)); <br>         LoadString (hInst, IDS_VIEW_LABEL, pih-&gt;szViewLabel, NUMELMS(pih-&gt;szViewLabel)); <br> <br>         TrideeCreate(hWnd); <br>         } <br>         break; <br> <br>      case WM_DESTROY: <br>         { <br>         LPIDFHEAD pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br>         if (pih &amp;&amp; pih != &amp;gs.idf) <br>            HeapFree (GetProcessHeap(), 0, pih); <br>         SetWindowLong (hWnd, GWL_USERDATA, 0); <br>         TrideeDestroy(hWnd); <br>         } <br>         break; <br> <br>      case WM_ERASEBKGND: <br>         { <br>         RECT rc; <br>         LPIDFHEAD pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br>         HDC  hDC = (HDC)wParam; <br>         int  cx = 2; <br>         int  cy = 4; <br> <br>         lRet = DefWindowProc (hWnd, wMsgID, wParam, lParam); <br> <br>         GetClientRect (hWnd, &amp;rc); <br> <br>         SetTextColor (hDC, GetSysColor (COLOR_BTNTEXT)); <br>         SetBkColor (hDC, GetSysColor (COLOR_BTNFACE)); <br> <br>         SetTextAlign (hDC, TA_TOP | TA_LEFT); <br>         ExtTextOut (hDC, cx, cy, ETO_CLIPPED, &amp;rc,  <br>                     pih-&gt;szTreeLabel, lstrlen(pih-&gt;szTreeLabel), NULL); <br> <br>         cx = pih-&gt;ptClient.x + pih-&gt;cxTree + BORDER +2; <br>         ExtTextOut (hDC, cx, cy, ETO_CLIPPED, &amp;rc,  <br>                     pih-&gt;szViewLabel, lstrlen(pih-&gt;szViewLabel), NULL); <br> <br>         rc.bottom = rc.top + 2; <br>         TrideeWellShadow(hDC, &amp;rc); <br>         } <br>         break; <br> <br>      case WM_PAINT: <br>         { <br>         PAINTSTRUCT ps;           // structure for BeginPaint <br>         HDC         hDC;          // DC to draw info into <br> <br>         LPIDFHEAD pih = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br> <br>         // and draw the info into our client area <br>         // <br>         hDC = BeginPaint (hWnd, &amp;ps); <br>         EndPaint (hWnd, &amp;ps); <br>         } <br>         break; <br> <br>      default: <br>         lRet = DefWindowProc (hWnd, wMsgID, wParam, lParam); <br>      } <br> <br>   return lRet; <br>   } </code></pre>
<p>&nbsp;</p></body>
</HTML>
