<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDF.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2477"></a>IDF.C</h2>
<pre><code>//************************************************************************ <br>//** <br>//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//**  A PARTICULAR PURPOSE. <br>//** <br>//**  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>//** <br>//**  idf.c <br>//** <br>//**  DESCRIPTION: <br>//**    main worker code for IDF editing <br>//** <br>//************************************************************************ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br> <br>#include "idfedit.h" <br> <br>#include &lt;commdlg.h&gt; <br>#include "drawstr.h" <br> <br>VOID FreeIDFFile (LPIDFHEAD); <br> <br> <br>/*+ PromptForIDFName(); <br> * <br> * <br> *  DESCRIPTION: <br> *     This function is a wrapper for the Get[Open/Save]FileName commdlg <br> *     chooser dialogs. Based on the fuFlags argument, this function <br> *     will display the appropriate chooser dialog and return the result. <br> * <br> *  ARGUMENTS: <br> *     HWND    hwnd          - Handle to parent window. <br> *     LPSTR   lpszPath      - Pointer to the buffer to receive the <br> *                             the file path. <br> *     LPSTR   lpszTitle     - Pointer to the buffer to receive the <br> *                             file the file title, NULL if no title <br> *                             is wanted. <br> *     BOOL     fSave        - TRUE if we are to save a file, <br> *                             FALSE if we are to open the file. <br> * <br> *  RETURNS: <br> *     BOOL  -  TRUE if a file was chosen. FALSE if the user canceled <br> *              the operation. <br> * <br> *-=======================================================================*/ <br> <br>BOOL WINAPI PromptForIDFName ( <br>    HWND    hwnd, <br>    LPTSTR  lpszPath, <br>    LPTSTR  lpszTitle, <br>    BOOL    fSave) <br>{ <br>   OPENFILENAME   ofn; <br>   TCHAR          szExtDefault[4]; <br>   TCHAR          szExtFilter[256]; <br>   LPTSTR         pstr; <br>   BOOL           bRet; <br> <br>   //  Get the extension filter and default extension. <br>   // <br>   LoadString (hInst, IDS_OFN_EXT_DEF, szExtDefault, NUMELMS(szExtDefault)); <br>   LoadString (hInst, IDS_OFN_EXT_FILTER, szExtFilter, NUMELMS(szExtFilter)); <br> <br>   // Parse the bang out of the filter string, replace with a NULL. <br>   // <br>   for (pstr = szExtFilter; *pstr; pstr = AnsiNext(pstr)) <br>      if (TEXT('!') == *pstr) <br>         *pstr = 0; <br> <br>   // set the default path to *.ext <br>   // <br>   lpszPath[0] = TEXT('*'); <br>   if (szExtDefault[0]) <br>      { <br>      lpszPath[1] = TEXT('.'); <br>      lstrcpy (lpszPath+2, szExtDefault); <br>      } <br> <br> <br>   // If there is a title then reset it also. <br>   // <br>   if (lpszTitle) <br>      lpszTitle[0] = 0; <br> <br>   //  Initialize the OPENFILENAME structure elements. <br>   // <br>   ZeroMemory(&amp;ofn, sizeof(ofn)); <br>   ofn.lStructSize    = sizeof(OPENFILENAME); <br>   ofn.hwndOwner      = hwnd; <br>   ofn.lpstrFilter    = szExtFilter; <br>   ofn.nFilterIndex   = 1; <br>   ofn.lpstrFile      = lpszPath; <br>   ofn.nMaxFile       = MAX_PATH; <br>   ofn.lpstrFileTitle = lpszTitle; <br>   ofn.nMaxFileTitle  = lpszTitle ? MAX_PATH : 0; <br>   ofn.lpstrDefExt    = szExtDefault; <br> <br>   //  If the fSave is TRUE, then call GetSaveFileName() <br>   //  otherwise call GetOpenFileName(). <br>   // <br>   if (fSave) <br>      { <br>      // Set the OPENFILENAME flags to save and prompt if we <br>      // will overwrite an existing file. <br>      // <br>      ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT; <br>      bRet = GetSaveFileName(&amp;ofn); <br>      } <br>   else <br>      { <br>      // Set the OPENFILENAME flags to open and the file  <br>      // must exist if we are opening. <br>      // <br>      ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST; <br>      bRet = GetOpenFileName(&amp;ofn); <br>      } <br> <br>   return bRet; <br>} <br> <br>STATICFN UINT fnMapLabel ( <br>   LPTSTR    psz, <br>   UINT      cch, <br>   UINT      uDummy, <br>   UINT      uIndex, <br>   UINT      uMsgID) <br>{ <br>   UINT   lRet = 0; <br> <br>   switch (uMsgID) <br>   { <br>      case WM_GETTEXT: <br>         lstrcpy (psz, "  0   1   2   3   4   5   6   7   8   9"); <br>         lRet = lstrlen (psz); <br>         break; <br>   } <br> <br>   return lRet; <br>} <br> <br>#define BLANK_LINE "", 0,0,AS_HEX,0,0 <br> <br>// 0 <br>// <br>#undef STDFLD <br>#define STDFLD(fld) FLD(INSTRUMENT,fld) <br>static DSFIELD aINSTRUMENTfields[] = { <br>    "IDF Version", STDFLD(dwVersion),            AS_HEX | IS_EDIT, 0, 0, <br>    "IDF Creator", STDFLD(dwCreator),            AS_HEX | IS_EDIT, 0, 0, <br>//  "Instrument Identifier",  STDFLD(szInstID),             AS_SZ | IS_EDIT,  0, 0, <br> <br>    BLANK_LINE, <br>    "Manufacturer ID",      STDFLD(dwManufactID),         AS_INT | IS_EDIT, 0, 0, <br>    "Product ID",           STDFLD(dwProductID),          AS_INT | IS_EDIT, 0, 0, <br>    "Product Rev.",         STDFLD(dwRevision),           AS_INT | IS_EDIT, 0, 0, <br>    "Manufacturer",         STDFLD(szManufact),           AS_SZ | IS_EDIT, 0, 0, <br>    "Product Name",         STDFLD(szProduct),            AS_SZ | IS_EDIT, 0, 0, <br> <br>    BLANK_LINE, <br>    "Supports General MIDI",   STDFLD(dwFlags), AS_BITFIELD | IS_EDIT, 0, 0, <br>    "Supports SysEx Messages", STDFLD(dwFlags), AS_BITFIELD | IS_EDIT, 1, 0, <br>    "Basic Channel",           STDFLD(dwBasicChannel),       AS_INT | IS_EDIT, 0, 0, <br>    "Number of Channels",      STDFLD(nChannels),            AS_INT | IS_EDIT, 0, 0, <br>    "Instrument Polyphony",    STDFLD(nInstrumentPolyphony), AS_INT | IS_EDIT, 0, 0, <br>    "Channel Polyphony",       STDFLD(nChannelPolyphony),    AS_INT | IS_EDIT, 0, 0, <br> <br>    // pmap fields <br>    // <br>    BLANK_LINE, <br>    "Patch Map",       0, 0, AS_XMODE, (DWORD)fnMapLabel, 0, <br>    " %02d",           FIELDOFF(INSTRUMENT,aPatch), 10, AS_BYTES | IS_EDIT | AS_ARRAY, 0, 12, <br>    " 12",             FIELDOFF(INSTRUMENT,aPatch) + 120, 8, AS_BYTES | IS_EDIT, 0, 0, <br> <br>    // key fields <br>    // <br>    BLANK_LINE, <br>    "General Key Map", 0, 0,  AS_XMODE, (DWORD)fnMapLabel, 0, <br>    " %02d",           FIELDOFF(INSTRUMENT,aGenKeymap), 10, AS_BYTES | IS_EDIT | AS_ARRAY, 0, 12, <br>    " 12",             FIELDOFF(INSTRUMENT,aGenKeymap) + 120, 8, AS_BYTES | IS_EDIT, 0, 0, <br> <br>    BLANK_LINE, <br>    "Drum Key Map",    0, 0,  AS_XMODE, (DWORD)fnMapLabel, 0, <br>    " %02d",           FIELDOFF(INSTRUMENT,aDrumKeymap), 10, AS_BYTES | IS_EDIT | AS_ARRAY, 0, 12, <br>    " 12",             FIELDOFF(INSTRUMENT,aDrumKeymap) + 120, 8, AS_BYTES | IS_EDIT, 0, 0, <br> <br>    // chnl fields <br>    // <br>    BLANK_LINE, <br>    "Channel %2d",     FIELDOFF(INSTRUMENT,aChannel), 0, AS_ARRAY | AS_STRUCT, 1, 16, <br>    // CHANNEL aChannel[MAX_CHANNEL]; <br> <br>    NULL, (UINT)-1, 0, AS_NONE, 0, 0, <br>    }; <br> <br>#include &lt;stdlib.h&gt; <br> <br>STATICFN UINT AsciiToBytes ( <br>   LPDWORD lpv, <br>   UINT    cb, <br>   LPTSTR  psz) <br>   { <br>   UINT   jj; <br> <br>   for (jj = 0; ; ++jj) <br>      { <br>      ULONG uu; <br>      LPTSTR pszStop; <br>      while (*psz == '\t' || *psz == ' ') <br>         ++psz; <br> <br>      pszStop = psz; <br>      uu = strtoul (psz, &amp;pszStop, 16); <br>      if (pszStop == psz) <br>         break; <br> <br>      if (jj &lt; cb/sizeof(*lpv)) <br>         lpv[jj] = uu; <br> <br>      psz = pszStop; <br>      } <br> <br>   return jj * sizeof(*lpv); <br>   } <br> <br>STATICFN VOID BytesToAscii ( <br>   LPTSTR  psz, <br>   UINT    cch, <br>   LPDWORD lpv, <br>   UINT    cbData) <br>{ <br>   UINT jj; <br>   UINT cb; <br> <br>   for (jj = 0; jj &lt; (cbData+sizeof(*lpv)-1)/sizeof(*lpv); ++jj) <br>      { <br>      wsprintf (psz, "%08lX ", lpv[jj]); <br>      cch -= (cb = lstrlen(psz)); <br>      psz += cb; <br>      *psz = 0; <br>      if (cch &lt; cb + 4) <br>         { <br>         *psz++ = '.'; <br>         *psz++ = '.'; <br>         *psz++ = '.'; <br>         *psz++ = 0; <br>         break; <br>         }  <br>      } <br>}    <br> <br>const TCHAR cszNone[] = "&lt;none&gt;"; <br> <br>STATICFN UINT fnChanData ( <br>   LPTSTR    psz, <br>   UINT      cch, <br>   LPCHANNEL pChan, <br>   UINT      uIndex, <br>   UINT      uMsgID) <br>{ <br>   LPDWORD lpvData = pChan-&gt;lpInit; <br>   UINT    cbData  = pChan-&gt;cbInit; <br>   UINT    lRet = 0; <br> <br>   switch (uMsgID) <br>   { <br>      case WM_GETTEXT: <br>         if (!lpvData || !cbData) <br>            lstrcpy (psz, cszNone); <br>         else <br>            BytesToAscii (psz, cch, lpvData, cbData); <br>         lRet = lstrlen (psz); <br>         break; <br> <br>      case WM_SETTEXT: <br>         { <br>         UINT uu; <br> <br>         // if we dont have a writable pointer to sysex data, <br>         // we must allocate an editable one before we go further. <br>         // <br>         if (IsBadWritePtr (lpvData,1)) <br>            cbData = 0; <br> <br>         // if the data is not the string &lt;none&gt; <br>         // parse it as HEX data and use that to set the sysex <br>         // data.  if it is &lt;none&gt; remove the sysex data. <br>         // <br>         if (!psz || ! lstrcmpi(psz, cszNone)) <br>            uu = 0; <br>         else <br>            uu = AsciiToBytes (lpvData, cbData, psz); <br> <br>         // if there was more data than would fit in the current <br>         // sysex buffer. allocate a new buffer and try again <br>         // <br>         if (uu &gt; cbData) <br>            { <br>            if (cbData &amp;&amp; lpvData) <br>               HeapFree (gs.idf.hEditHeap, 0, lpvData); <br> <br>            lpvData = HeapAlloc (gs.idf.hEditHeap, 0, uu); <br>            AsciiToBytes (lpvData, uu, psz); <br>            } <br> <br>         // update pChan pointers to reflect the new sysex data <br>         // <br>         pChan-&gt;lpInit = lpvData; <br>         pChan-&gt;cbInit = uu; <br>         } <br>         break; <br> <br>      case WM_COPY: <br>         { <br>         HGLOBAL hMem = GlobalAlloc (GHND, 4 + cbData * 3); <br>         if (!(psz = GlobalLock (hMem))) <br>            break; <br> <br>         // put the sysex data on the clipboard as ASCII <br>         // <br>         BytesToAscii (psz, 4 + cbData * 3, lpvData, cbData); <br>         GlobalUnlock (hMem); <br>         if (!OpenClipboard (hWndMain)) <br>            GlobalFree (hMem); <br>         else <br>            { <br>            EmptyClipboard (); <br>            SetClipboardData (CF_TEXT, hMem); <br>            CloseClipboard (); <br>            lRet = 1; <br>            } <br>         } <br>         break; <br> <br>      case WM_PASTE: <br>         { <br>         HGLOBAL hMem; <br> <br>         // grap text from the clipboard and use it as the sysex data <br>         // however, ignore the data if it's not valid hex data <br>         // <br>         if (!OpenClipboard (hWndMain)) <br>            break; <br>         if (hMem = GetClipboardData (CF_TEXT)) <br>            { <br>            if (psz = GlobalLock (hMem)) <br>               { <br>               fnChanData (psz, GlobalSize(hMem), pChan, uIndex, WM_SETTEXT); <br>               GlobalUnlock (hMem); <br>               lRet = 1; <br>               } <br>            } <br>         CloseClipboard (); <br>         } <br>         break; <br>   } <br> <br>   return lRet; <br>} <br> <br>// 0 <br>// <br>#undef STDFLD <br>#define STDFLD(fld) #fld, FLD(CHANNEL,fld) <br>static DSFIELD aCHANNELfields[] = { <br>    "Mute This Channel", FLD(CHANNEL,iFlags), AS_BITFIELD | IS_EDIT, 1, 0, <br>    "Is Drum Channel",   FLD(CHANNEL,iFlags), AS_BITFIELD | IS_EDIT, 0, 0, <br>    //"Init Data",  0, sizeof(CHANNEL), AS_XMODE | IS_EDIT, (DWORD)fnChanData, 0, <br>    NULL, (UINT)-1, 0, AS_NONE, 0, 0, <br>    }; <br> <br>static DSFIELDTBL aStructs[] = { <br>    aINSTRUMENTfields,   "INSTRUMENT", sizeof(INSTRUMENT), <br>    aCHANNELfields,      "CHANNEL",    sizeof(CHANNEL), <br>    }; <br> <br> <br>/*+ FindListChunk <br> * <br> *-======================================================================*/ <br> <br>LPRIFF FindListChunk ( <br>   LPRIFFLIST pList, <br>   DWORD      fccToFind) <br>{ <br>   UINT   cbRemain; <br>   LPRIFF pRiff; <br> <br>   // in this code, we expect to have only MMAP lists <br>   // <br>   assert (pList); <br>   assert (pList-&gt;cbList &gt; sizeof(RIFF) + sizeof(DWORD)); <br>   assert (pList-&gt;fccType == FCC_MMAP); <br> <br>   cbRemain = pList-&gt;cbList - sizeof(DWORD); <br>   assert (cbRemain &lt; 0x10000); // reasonableness check <br> <br>   // scan for the requested chunk <br>   // <br>   pRiff = (LPRIFF)(pList+1); <br>   for (;;) <br>      { <br>      UINT cbAdvance = pRiff-&gt;cb + (pRiff-&gt;cb &amp; 1) + sizeof(RIFF); <br>      if (pRiff-&gt;fcc == fccToFind) <br>         return pRiff; <br>      if (cbRemain &lt;= cbAdvance) <br>         break; <br> <br>      cbRemain -= cbAdvance; <br>      pRiff = NEXTRIFF(pRiff); <br>      } <br> <br>   return NULL; <br>} <br> <br>/*+  <br> * <br> *-======================================================================*/ <br> <br>LPVOID CopyForEditing ( <br>   LPVOID pData,  <br>   UINT   cbData) <br>{ <br>   LPVOID pDataT; <br> <br>   pDataT = HeapAlloc (gs.idf.hEditHeap, 0, cbData); <br>   if (pDataT) <br>      CopyMemory (pDataT, pData, cbData); <br>   return pDataT; <br>}    <br> <br>/*+  <br> * <br> *-======================================================================*/ <br> <br>void FreeInstrumEdits ( <br>   LPINSTRUMENT pInstrum) <br>{ <br>   UINT      ii; <br> <br>   // free anything that has been dynamically allocated for editing <br>   // purposes.  (currently only sysex channel init data) <br>   // <br>   for (ii = 0; ii &lt; NUMELMS(pInstrum-&gt;aChannel); ++ii) <br>      { <br>      LPCHANNEL pChan = &amp;pInstrum-&gt;aChannel[ii]; <br> <br>      // if the pointer is a valid writeable pointer, assume it <br>      // cam from the edit heap. <br>      // <br>      if (pChan-&gt;lpInit &amp;&amp; !IsBadWritePtr(pChan-&gt;lpInit, 1)) <br>         HeapFree (gs.idf.hEditHeap, 0, pChan-&gt;lpInit); <br> <br>      ZeroMemory (pChan, sizeof(*pChan)); <br>      } <br>} <br> <br>/*+ IdentityMap <br> * <br> *-======================================================================*/ <br> <br>STATICFN void _inline IdentityMap ( <br>   LPBYTE abData) <br>{ <br>   BYTE ii; <br> <br>   assert (MAX_PATCH == MAX_KEYMAP); <br> <br>   for (ii = 0; ii &lt; MAX_KEYMAP; ++ii) <br>      abData[ii] = ii; <br>} <br> <br>/*+ IsIdentityMap <br> * <br> *-======================================================================*/ <br> <br>STATICFN BOOL IsIdentityMap ( <br>   LPBYTE abData) <br>{ <br>   BYTE ii; <br> <br>   assert (MAX_PATCH == MAX_KEYMAP); <br> <br>   for (ii = 0; ii &lt; MAX_KEYMAP; ++ii) <br>      if (abData[ii] != ii) <br>         return FALSE; <br>   return TRUE; <br>} <br> <br>/*+  <br> * <br> *-======================================================================*/ <br> <br>void CopyInstrumData ( <br>   LPINSTRUMENT pInstrum,  <br>   LPRIFFLIST   pList) <br>{ <br>   LPRIFF pRiff; <br>   UINT   ii; <br> <br>   #pragma message (SQUAWK "free channel data first?") <br> <br>   // initialize to defaults for optional fields in the IDF file <br>   // <br>   FreeInstrumEdits (pInstrum); <br>   ZeroMemory (pInstrum, sizeof(*pInstrum)); <br>   IdentityMap (pInstrum-&gt;aPatch); <br>   IdentityMap (pInstrum-&gt;aGenKeymap); <br>   IdentityMap (pInstrum-&gt;aDrumKeymap); <br>   pInstrum-&gt;aChannel[9].iFlags = CHANNEL_IS_DRUM; <br> <br>   assert (pList); <br>   if (!pList) <br>      return; <br> <br>   // is there a header chunk? if so, then <br>   // copy it's data into the instrum structure <br>   // <br>   pRiff = FindListChunk (pList, FCC_hdr); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFHEADER)) <br>      { <br>      LPIDFHEADER phdr = (LPVOID)(pRiff+1); <br> <br>      pInstrum-&gt;dwVersion = phdr-&gt;dwVersion; <br>      pInstrum-&gt;dwCreator = phdr-&gt;dwCreator; <br> <br>      // copy instrument id, and force a NULL terminator <br>      // <br>      CopyMemory (pInstrum-&gt;szInstID,  <br>                  phdr-&gt;abInstID, <br>                  max(phdr-&gt;cbInstID, NUMELMS(pInstrum-&gt;szInstID))); <br>      pInstrum-&gt;szInstID[NUMELMS(pInstrum-&gt;szInstID)-1] = 0; <br>      } <br> <br> <br>   // manufacturer info <br>   // <br>   pRiff = FindListChunk (pList, FCC_inst); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFINSTINFO)) <br>      { <br>      LPIDFINSTINFO pinst = (LPVOID)(pRiff+1); <br> <br>      #pragma message (SQUAWK "get tables of manufactures &amp; products") <br> <br>      pInstrum-&gt;dwManufactID = pinst-&gt;dwManufactID; <br>      pInstrum-&gt;dwProductID = pinst-&gt;dwProductID; <br>      pInstrum-&gt;dwRevision = pinst-&gt;dwRevision; <br> <br>     #ifdef UNICODE <br>      CopyMemory (pInstrum-&gt;szManufact, pinst-&gt;abData, <br>                  max(pinst-&gt;cbManufactUNICODE, sizeof(pInstrum-&gt;szManufact))); <br>     #else <br>      CopyMemory (pInstrum-&gt;szManufact, pinst-&gt;abData, <br>                  max(pinst-&gt;cbManufactASCII, sizeof(pInstrum-&gt;szManufact))); <br>     #endif <br>      pInstrum-&gt;szManufact[NUMELMS(pInstrum-&gt;szManufact)-1] = 0; <br> <br>     #ifdef UNICODE <br>      CopyMemory (pInstrum-&gt;szProduct,  <br>                  pinst-&gt;abData + pinst-&gt;cbManufactASCII + pinst-&gt;cbManufactUNICODE,  <br>                  max(pinst-&gt;cbProductUNICODE, sizeof(pInstrum-&gt;szProduct))); <br>     #else <br>      CopyMemory (pInstrum-&gt;szProduct, <br>                  pinst-&gt;abData + pinst-&gt;cbManufactASCII + pinst-&gt;cbManufactUNICODE,  <br>                  max(pinst-&gt;cbProductASCII, sizeof(pInstrum-&gt;szProduct))); <br>     #endif <br>      pInstrum-&gt;szProduct[NUMELMS(pInstrum-&gt;szProduct)-1] = 0; <br>      } <br> <br>   // capabilities <br>   // <br>   pRiff = FindListChunk (pList, FCC_caps); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFINSTCAPS)) <br>      { <br>      LPIDFINSTCAPS pcaps = (LPVOID)(pRiff+1); <br> <br>      pInstrum-&gt;dwFlags = pcaps-&gt;fdwFlags; <br>      pInstrum-&gt;dwBasicChannel = pcaps-&gt;dwBasicChannel; <br>      pInstrum-&gt;nChannels      = pcaps-&gt;cNumChannels; <br>      pInstrum-&gt;nInstrumentPolyphony = pcaps-&gt;cInstrumentPolyphony; <br>      pInstrum-&gt;nChannelPolyphony = pcaps-&gt;cChannelPolyphony; <br>      } <br> <br> <br>   // per channel init data <br>   // <br>   pRiff = FindListChunk (pList, FCC_chan); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFCHANNELHDR)) <br>      { <br>      LPIDFCHANNELHDR  pchan = (LPVOID)(pRiff+1); <br>      LPIDFCHANNELINFO pinfo = (LPVOID)(pchan+1); <br>      UINT cbRemain = pRiff-&gt;cb - sizeof(IDFCHANNELHDR); <br> <br>      for (ii = 0; ii &lt; NUMELMS(pInstrum-&gt;aChannel); ++ii) <br>      { <br>         pInstrum-&gt;aChannel[ii].iFlags &amp;= ~CHANNEL_IS_MUTE; <br>         if (pchan-&gt;dwDrumMask &amp; (1 &lt;&lt; ii)) <br>            pInstrum-&gt;aChannel[ii].iFlags |= CHANNEL_IS_DRUM; <br>         else <br>         { <br>            pInstrum-&gt;aChannel[ii].iFlags &amp;= ~CHANNEL_IS_DRUM; <br>            if (!(pchan-&gt;dwGeneralMask &amp; (1 &lt;&lt; ii))) <br>               pInstrum-&gt;aChannel[ii].iFlags |= CHANNEL_IS_MUTE; <br>         } <br>      } <br> <br> <br>      for (ii = 0; /*ii &lt; pchan-&gt;cNumChannels*/ ;++ii) <br>         { <br>         if (cbRemain &lt; sizeof(IDFCHANNELINFO) || <br>             cbRemain &lt; pinfo-&gt;cbStruct) <br>            break; <br> <br>         if (pinfo-&gt;dwChannel &lt; NUMELMS(pInstrum-&gt;aChannel)) <br>            { <br>            LPCHANNEL pChan = &amp;pInstrum-&gt;aChannel[pinfo-&gt;dwChannel]; <br>            pChan-&gt;cbInit = pinfo-&gt;cbInitData; <br>            pChan-&gt;lpInit = (LPVOID)pinfo-&gt;abData; <br>            } <br> <br>         cbRemain -= pinfo-&gt;cbStruct; <br>         if (cbRemain &lt; sizeof(IDFCHANNELINFO)) <br>            break; <br> <br>         pinfo = (LPVOID)((LPBYTE)pinfo + pinfo-&gt;cbStruct); <br>         } <br>      } <br>   else <br>      { <br>      pRiff = FindListChunk (pList, FCC_chnl); <br>      if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFCHNLHDR)) <br>         { <br>         LPIDFCHNLHDR pchnl = (LPVOID)(pRiff+1); <br>         LPIDFCHNLINFO pinfo = (LPVOID)(pchnl+1); <br>         UINT cbRemain = pRiff-&gt;cb; <br> <br>         if (cbRemain &gt;= sizeof(IDFCHNLHDR) + sizeof(IDFCHNLINFO)) <br>            { <br>            cbRemain -= sizeof(IDFCHNLHDR); <br> <br>            for (ii = 0; ii &lt; pchnl-&gt;cNumChannels; ++ii) <br>               { <br>               if (cbRemain &lt; pinfo-&gt;cbStruct) <br>                  break; <br> <br>               if (pinfo-&gt;dwChannel &lt; NUMELMS(pInstrum-&gt;aChannel)) <br>                  { <br>                  LPCHANNEL pChan = &amp;pInstrum-&gt;aChannel[pinfo-&gt;dwChannel]; <br> <br>                  // for now, just point channel data at riff data, we'll <br>                  // copy it when they try to actually edit it. <br>                  // <br>                  if (pinfo-&gt;fdwChannel &amp; IDFCHNLINFO_F_DRUM_CHANNEL) <br>                     { <br>                     pChan-&gt;iFlags |= CHANNEL_IS_DRUM; <br>                     pChan-&gt;cbInit = pinfo-&gt;cbDrumInitData; <br>                     pChan-&gt;lpInit = (LPVOID)(pinfo-&gt;abData + pinfo-&gt;cbGeneralInitData); <br>                     } <br>                  else <br>                     { <br>                     pChan-&gt;iFlags &amp;= ~CHANNEL_IS_DRUM; <br>                     pChan-&gt;cbInit = pinfo-&gt;cbGeneralInitData; <br>                     pChan-&gt;lpInit = (LPVOID)pinfo-&gt;abData; <br>                     } <br>                  } <br> <br>               cbRemain -= pinfo-&gt;cbStruct; <br>               if (cbRemain &lt; sizeof(IDFCHNLINFO)) <br>                  break; <br> <br>               pinfo = (LPVOID)((LPBYTE)pinfo + pinfo-&gt;cbStruct); <br>               } <br>            } <br>         } <br>      } <br> <br>   // patch map <br>   // <br>   pRiff = FindListChunk (pList, FCC_pmap); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFPATCHMAPHDR)) <br>      { <br>      LPIDFPATCHMAPHDR ppmap = (LPVOID)(pRiff+1); <br>      CopyMemory (pInstrum-&gt;aPatch, ppmap-&gt;abPatchMap, sizeof(pInstrum-&gt;aPatch)); <br>      } <br> <br>   // <br>   // key map.  we support old style 'key' chunk.  but will override <br>   // it with the data from a new style 'gkey' &amp; 'dkey' chunk if both <br>   // are found <br>   // <br> <br>   // old style 'key ' chunk <br>   // <br>   pRiff = FindListChunk (pList, FCC_key); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFKEYHDR)) <br>      { <br>      LPIDFKEYHDR pkey = (LPVOID)(pRiff+1); <br>      LPIDFKEY    pmap = (LPVOID)(pkey+1); <br>      UINT        nMaps = pkey-&gt;cNumKeyMaps; <br>      UINT        cbRemain = pRiff-&gt;cb - sizeof(IDFKEYHDR); <br> <br>      // copy keymaps as we find them, we only recognize 2 differnent <br>      // keymap types however.  and we only honor the last instance <br>      // each type that we find <br>      // <br>      while (nMaps &gt; 0 &amp;&amp; cbRemain &gt;= sizeof(IDFKEY)) <br>         { <br>         if (IDFKEY_F_GENERAL_CHANNEL == pmap-&gt;fdwKeyMap) <br>             CopyMemory (pInstrum-&gt;aGenKeymap, pmap-&gt;abKeyMap, sizeof(pInstrum-&gt;aGenKeymap)); <br>         else if (IDFKEY_F_DRUM_CHANNEL == pmap-&gt;fdwKeyMap) <br>             CopyMemory (pInstrum-&gt;aDrumKeymap, pmap-&gt;abKeyMap, sizeof(pInstrum-&gt;aDrumKeymap)); <br>         --nMaps; <br>         ++pmap; <br>         cbRemain -= sizeof(IDFKEY); <br>         } <br>      } <br> <br>   // 'gkey' chunk <br>   // <br>   pRiff = FindListChunk (pList, FCC_gkey); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFKEYMAP)) <br>      { <br>      LPIDFKEYMAP pgkey = (LPVOID)(pRiff+1); <br> <br>      assert (sizeof(pgkey-&gt;abKeyMap) == sizeof(pInstrum-&gt;aGenKeymap)); <br>      CopyMemory (pInstrum-&gt;aGenKeymap, pgkey-&gt;abKeyMap, sizeof(pInstrum-&gt;aGenKeymap)); <br>      } <br> <br>   // 'dkey' chunk <br>   // <br>   pRiff = FindListChunk (pList, FCC_dkey); <br>   if (pRiff &amp;&amp; pRiff-&gt;cb &gt;= sizeof(IDFKEYMAP)) <br>      { <br>      LPIDFKEYMAP pdkey = (LPVOID)(pRiff+1); <br> <br>      assert (sizeof(pdkey-&gt;abKeyMap) == sizeof(pInstrum-&gt;aDrumKeymap)); <br>      CopyMemory (pInstrum-&gt;aDrumKeymap, pdkey-&gt;abKeyMap, sizeof(pInstrum-&gt;aDrumKeymap)); <br>      } <br>} <br> <br>/*+ SaveInstrumToRiff <br> * <br> *-======================================================================*/ <br> <br>VOID SaveInstrumToRiff( <br>    LPRIFFLIST   pList,  <br>    LPINSTRUMENT pInstrum) <br>{ <br>    LPRIFF pRiff = (LPVOID)(pList+1); <br> <br>    // hdr <br>    { <br>    LPIDFHEADER phdr = (LPVOID)(pRiff+1); <br>    UINT        cb = lstrlen(pInstrum-&gt;szInstID) + 1; <br>    phdr-&gt;cbStruct = sizeof(*phdr) + cb; <br>    phdr-&gt;dwVersion = pInstrum-&gt;dwVersion; <br>    phdr-&gt;dwCreator = pInstrum-&gt;dwCreator; <br>    phdr-&gt;cbInstID = cb; <br>    lstrcpy (phdr-&gt;abInstID, pInstrum-&gt;szInstID); <br>    phdr-&gt;abInstID[cb-1] = 0; <br>    pRiff-&gt;fcc = FCC_hdr; <br>    pRiff-&gt;cb = phdr-&gt;cbStruct; <br>    pRiff = NEXTRIFF(pRiff); <br>    } <br> <br>    // inst <br>    // <br>    { <br>    LPIDFINSTINFO pinst = (LPVOID)(pRiff+1); <br>    UINT          cb1 = lstrlen(pInstrum-&gt;szManufact)+1; <br>    UINT          cb2 = lstrlen(pInstrum-&gt;szProduct)+1; <br>    cb1 += (cb1 &amp; 1); <br>    cb2 += (cb2 &amp; 2); <br>    pinst-&gt;cbStruct = sizeof(*pinst) + (cb1 + cb2) * 3; <br>    pinst-&gt;dwManufactID = pInstrum-&gt;dwManufactID; <br>    pinst-&gt;dwProductID = pInstrum-&gt;dwProductID; <br>    pinst-&gt;dwRevision = pInstrum-&gt;dwRevision; <br>    pinst-&gt;cbManufactASCII = cb1; <br>    pinst-&gt;cbManufactUNICODE = cb1 * 2; <br>    pinst-&gt;cbProductASCII = cb2; <br>    pinst-&gt;cbProductUNICODE = cb2 * 2; <br>    ZeroMemory (pinst-&gt;abData, (cb1 + cb2) * 3); <br>   #ifdef UNICODE <br>    #error not yet implemented <br>   #else <br>    lstrcpy (pinst-&gt;abData, pInstrum-&gt;szManufact); <br>    MultiByteToWideChar(CP_ACP, 0, pInstrum-&gt;szManufact,  <br>                        cb1, (LPWSTR)(pinst-&gt;abData + cb1),  cb1); <br>    lstrcpy (pinst-&gt;abData + (cb1 * 3), pInstrum-&gt;szProduct); <br>    MultiByteToWideChar(CP_ACP, 0, pInstrum-&gt;szProduct,  <br>                        cb2, (LPWSTR)(pinst-&gt;abData + (cb1 * 3) + cb2), cb2); <br>   #endif <br>    pRiff-&gt;fcc = FCC_inst; <br>    pRiff-&gt;cb = pinst-&gt;cbStruct; <br>    pRiff = NEXTRIFF(pRiff); <br>    } <br> <br>    // caps <br>    // <br>    { <br>    LPIDFINSTCAPS pcaps = (LPVOID)(pRiff+1); <br>    pcaps-&gt;cbStruct = sizeof(*pcaps); <br>    pcaps-&gt;fdwFlags = pInstrum-&gt;dwFlags; <br>    pcaps-&gt;dwBasicChannel = pInstrum-&gt;dwBasicChannel; <br>    pcaps-&gt;cNumChannels = pInstrum-&gt;nChannels; <br>    pcaps-&gt;cInstrumentPolyphony = pInstrum-&gt;nInstrumentPolyphony; <br>    pcaps-&gt;cChannelPolyphony = pInstrum-&gt;nChannelPolyphony; <br>    pRiff-&gt;fcc = FCC_caps; <br>    pRiff-&gt;cb = pcaps-&gt;cbStruct; <br>    pRiff = NEXTRIFF(pRiff); <br>    } <br> <br>    // <br>    // chan chunk <br>    // <br>    { <br>    LPIDFCHANNELHDR  pchan = (LPVOID)(pRiff+1); <br>    LPIDFCHANNELINFO pinfo = (LPVOID)(pchan+1); <br>    UINT cbTotal = 0; <br>    UINT ii; <br> <br>    pchan-&gt;cbStruct = sizeof(*pchan); <br>    pchan-&gt;dwDrumMask = 0; <br>    pchan-&gt;dwGeneralMask = 0x0000FFFF; <br>    for (ii = 0; ii &lt; NUMELMS(pInstrum-&gt;aChannel); ++ii) <br>        if (pInstrum-&gt;aChannel[ii].iFlags &amp; CHANNEL_IS_MUTE) <br>            pchan-&gt;dwGeneralMask &amp;= ~(1 &lt;&lt; ii); <br>        else if (pInstrum-&gt;aChannel[ii].iFlags &amp; CHANNEL_IS_DRUM) <br>            pchan-&gt;dwDrumMask |= (1 &lt;&lt; ii); <br> <br>    pchan-&gt;dwGeneralMask &amp;= ~(pchan-&gt;dwDrumMask); <br>    pchan-&gt;fdwFlags = 0; <br> <br>    cbTotal = pchan-&gt;cbStruct; <br> <br>    for (ii = 0; ii &lt; NUMELMS(pInstrum-&gt;aChannel); ++ii) <br>       { <br>       LPCHANNEL pChan = &amp;pInstrum-&gt;aChannel[ii]; <br> <br>       // if we have non-default channel info. append <br>       // channel info data <br>       // <br>       if (pChan-&gt;cbInit) <br>          { <br>          UINT cbData = (pChan-&gt;cbInit + 3) &amp; ~3; <br> <br>          pinfo-&gt;dwChannel = ii; <br>          pinfo-&gt;cbInitData = cbData; <br>          ZeroMemory (pinfo-&gt;abData, cbData); <br>          CopyMemory (pinfo-&gt;abData, pChan-&gt;lpInit, pChan-&gt;cbInit); <br> <br>          // advance pinfo to the next channel header <br>          // <br>          //++pchan-&gt;cNumChannels; <br>          pinfo-&gt;cbStruct = sizeof(*pinfo) + cbData; <br>          cbTotal += pinfo-&gt;cbStruct; <br>          pinfo = (LPVOID)(((LPBYTE)pinfo) + pinfo-&gt;cbStruct); <br>          } <br>       } <br> <br>    // save the chan chunk <br>    // <br>    pRiff-&gt;fcc = FCC_chan; <br>    pRiff-&gt;cb = cbTotal; <br>    pRiff = NEXTRIFF(pRiff); <br>    } <br> <br>    // pmap <br>    // <br>    { <br>    if (!IsIdentityMap(pInstrum-&gt;aPatch)) <br>       { <br>       LPIDFPATCHMAPHDR ppmap = (LPVOID)(pRiff+1); <br>       ppmap-&gt;cbStruct = sizeof(*ppmap); <br>       CopyMemory (ppmap-&gt;abPatchMap, pInstrum-&gt;aPatch, sizeof(ppmap-&gt;abPatchMap)); <br>       pRiff-&gt;fcc = FCC_pmap; <br>       pRiff-&gt;cb = ppmap-&gt;cbStruct;   <br>       pRiff = NEXTRIFF(pRiff); <br>       } <br> <br>    // <br>    // gkey chunk (general keymap) <br>    // <br>    if (!IsIdentityMap(pInstrum-&gt;aGenKeymap)) <br>       { <br>       LPIDFKEYMAP pgkey = (LPVOID)(pRiff+1); <br>       pgkey-&gt;cbStruct = sizeof(*pgkey); <br>       CopyMemory (pgkey-&gt;abKeyMap, pInstrum-&gt;aGenKeymap, sizeof(pgkey-&gt;abKeyMap)); <br>       pRiff-&gt;fcc = FCC_gkey; <br>       pRiff-&gt;cb = sizeof(*pgkey); <br>       pRiff = NEXTRIFF(pRiff); <br>       } <br>    // dkey chunk (drum keymap) <br>    // <br>    if (!IsIdentityMap(pInstrum-&gt;aDrumKeymap)) <br>       { <br>       LPIDFKEYMAP pdkey = (LPVOID)(pRiff+1); <br>       pdkey-&gt;cbStruct = sizeof(*pdkey); <br>       CopyMemory (pdkey-&gt;abKeyMap, pInstrum-&gt;aDrumKeymap, sizeof(pdkey-&gt;abKeyMap)); <br>       pRiff-&gt;fcc = FCC_dkey; <br>       pRiff-&gt;cb = sizeof(*pdkey); <br>       pRiff = NEXTRIFF(pRiff); <br>       } <br>    } <br> <br>    pList-&gt;fccList = FCC_LIST; <br>    pList-&gt;cbList = (DWORD)pRiff - (DWORD)pList - sizeof(RIFF); <br>    pList-&gt;fccType = FCC_MMAP; <br>} <br> <br>/*+ GetBackupName <br> * <br> *-======================================================================*/ <br> <br>BOOL GetBackupName ( <br>   LPTSTR pszBak, <br>   LPTSTR pszName) <br>{ <br>   LPTSTR psz; <br>   lstrcpy (pszBak, pszName); <br>   psz = pszBak + lstrlen(pszBak); <br>   while (psz &gt; pszBak) <br>      { <br>      if (*psz == TEXT(':')) <br>         break; <br>      if (*psz == TEXT('\\')) <br>         break; <br>      if (*psz == TEXT('.')) <br>         *psz = 0; <br> <br>      --psz; <br>      } <br>   lstrcat (pszBak, TEXT(".id-")); <br>   return TRUE; <br>} <br> <br>/*+ InstrumMaxRiffDataSize <br> * <br> *-======================================================================*/ <br> <br>STATICFN UINT InstrumMaxRiffDataSize ( <br>   LPINSTRUMENT pInstrum) <br>{ <br>   UINT cbData; <br>   UINT ii; <br> <br>   cbData = (sizeof(RIFF) * 6) <br>            + sizeof(IDFHEADER) + MAX_NAME  <br>            + sizeof(IDFINSTINFO) + (MAX_NAME * 6) <br>            + sizeof(IDFINSTCAPS) <br>            + sizeof(IDFCHNLHDR) <br>            + sizeof(IDFPATCHMAPHDR) <br>            + sizeof(IDFKEYHDR) + (sizeof(IDFKEY) * 2); <br> <br>   for (ii = 0; ii &lt; NUMELMS(pInstrum-&gt;aChannel); ++ii) <br>       { <br>       LPCHANNEL pChan = &amp;pInstrum-&gt;aChannel[ii]; <br>       cbData += pChan-&gt;cbInit + sizeof(IDFCHNLINFO); <br>       } <br>   return cbData; <br>} <br> <br>/*+ SaveIDFToFile  <br> * <br> *-======================================================================*/ <br> <br>BOOL SaveIDFToFile ( <br>   LPIDFHEAD pIDF, <br>   LPTSTR    pszFileIn) <br>{ <br>   HANDLE hFile = NULL; <br>   HANDLE hSection = NULL; <br>   LPBYTE pBase = NULL; <br>   TCHAR  szBakName[MAX_PATH]; <br>   LPTSTR pszFile = pszFileIn; <br>   DWORD  cbFile; <br>   UINT   ii; <br>   LPRIFFLIST pList; <br> <br>   // are we saving to the same name? if so <br>   // rename the old file to a backup name <br>   // <br>   szBakName[0] = 0; <br>   if (!lstrcmpi(pszFile, pIDF-&gt;szFile)) </code></pre>
<p>
</p>
<pre><code>{ <br>      if (pIDF-&gt;bReadOnly) <br>         return FALSE; <br> <br>      GetBackupName (szBakName, pszFile); <br>      pszFile = szBakName; <br>   } <br> <br>   // determine necessary file size <br>   // <br>   cbFile = sizeof(RIFFLIST) * 2; <br>   for (ii = 0; ii &lt; pIDF-&gt;nInstrum; ++ii) <br>      { <br>      cbFile += sizeof(RIFFLIST); <br>      if (pIDF-&gt;ai[ii].pInstrum) <br>         { <br>         cbFile += InstrumMaxRiffDataSize (pIDF-&gt;ai[ii].pInstrum); <br>         } <br>      else if (pIDF-&gt;ai[ii].pList) <br>         { <br>         cbFile += pIDF-&gt;ai[ii].pList-&gt;cbList; <br>         } <br>      else <br>         { <br>         assert (0); // should never get here <br>         } <br>      } <br> <br>   // open a writable mapped file of the size <br>   // necessary to write the IDF data <br>   // <br>   hFile = CreateFile (pszFile, <br>                       GENERIC_READ | GENERIC_WRITE, <br>                       FILE_SHARE_READ, <br>                       NULL, // security <br>                       OPEN_ALWAYS, <br>                       FILE_ATTRIBUTE_NORMAL, <br>                       NULL); <br>   if (INVALID_HANDLE_VALUE == hFile) <br>      goto error_exit; <br> <br>   SetFilePointer (hFile, cbFile, NULL, FILE_BEGIN); <br>   SetEndOfFile (hFile); <br> <br>   hSection = CreateFileMapping (hFile, NULL, <br>                                 PAGE_READWRITE, 0, 0, NULL); <br>   if (INVALID_HANDLE_VALUE == hSection) <br>      goto error_exit; <br> <br>   pBase = MapViewOfFile (hSection, FILE_MAP_ALL_ACCESS, 0, 0, 0); <br>   if (NULL == pBase) <br>      goto error_exit; <br> <br>   // Create RIFF data into the memory mapped file <br>   //    <br>   pList = (LPVOID)pBase; <br>   pList-&gt;fccList = FCC_RIFF; <br>   pList-&gt;cbList = 0; <br>   pList-&gt;fccType = FCC_IDF; <br>   ++pList; <br>   for (ii = 0; ii &lt; pIDF-&gt;nInstrum; ++ii) <br>      { <br>      struct _instrum_info * pi = &amp;pIDF-&gt;ai[ii]; <br> <br>      pList-&gt;cbList = 0; <br> <br>      if (pi-&gt;pInstrum) <br>         { <br>         SaveInstrumToRiff(pList, pi-&gt;pInstrum); <br>         } <br>      else if (pi-&gt;pList) <br>         {    <br>         CopyMemory (pList, pi-&gt;pList,  <br>                     pi-&gt;pList-&gt;cbList + sizeof(RIFF)); <br>         } <br>      else <br>         { <br>         assert(0); <br>         } <br> <br>      if (pList-&gt;cbList &gt; 0) <br>         pList = (LPVOID) NEXTRIFF(pList); <br>      } <br>   cbFile = (DWORD)pList - (DWORD)pBase; <br>   ((LPRIFF)pBase)-&gt;cb = cbFile - sizeof(RIFF); <br> <br>   UnmapViewOfFile (pBase); <br>   CloseHandle (hSection); <br> <br>   SetFilePointer (hFile, cbFile, NULL, FILE_BEGIN); <br>   SetEndOfFile (hFile); <br>   CloseHandle (hFile); <br> <br>   // close the existing file, delete the old file,  <br>   // rename the new file to the previous filename <br>   // and open the new file &amp; display contents <br>   // <br>   FreeIDFFile (pIDF); <br>   if (pszFile == szBakName) <br>      { <br>      pszFile = pszFileIn; <br>      DeleteFile (pszFile); <br>      if ( ! MoveFile (szBakName, pszFile)) <br>         { <br>         // inexplicable failure copy the back over the origonal, <br>         // int this case we delete the backup and return failure <br>         // <br>         DeleteFile (szBakName); <br>         return FALSE; <br>         } <br>      } <br> <br>   // return success <br>   // <br>   return TRUE; <br> <br>error_exit: <br>   if (pBase) <br>      UnmapViewOfFile (pBase); <br>   if (hSection &amp;&amp; INVALID_HANDLE_VALUE != hSection) <br>      CloseHandle (hSection); <br>   if (hFile &amp;&amp; INVALID_HANDLE_VALUE != hFile) <br>      CloseHandle (hFile); <br>   return FALSE; <br>} <br> <br>/*+ <br> * <br> *-======================================================================*/ <br> <br>VOID FreeIDFFile ( <br>   LPIDFHEAD pIDF) <br>{ <br> <br>   if (pIDF-&gt;pFileBase) <br>      UnmapViewOfFile (pIDF-&gt;pFileBase), pIDF-&gt;pFileBase = NULL; <br> <br>   if (pIDF-&gt;hSection &amp;&amp; INVALID_HANDLE_VALUE != pIDF-&gt;hSection) <br>      CloseHandle (pIDF-&gt;hSection), pIDF-&gt;hSection = NULL; <br> <br>   if (pIDF-&gt;hFile &amp;&amp; INVALID_HANDLE_VALUE != pIDF-&gt;hFile) <br>      CloseHandle (pIDF-&gt;hFile), pIDF-&gt;hFile = NULL; <br> <br>   if (gs.idf.hEditHeap) <br>      HeapDestroy (gs.idf.hEditHeap); <br>   gs.idf.hEditHeap = HeapCreate (0, 0x1000, 0x100000); <br> <br>   gs.idf.vi.pTable = aStructs; <br>   gs.idf.vi.lpData = &amp;gs.idf.instrum; <br> <br>   pIDF-&gt;bChanged = FALSE; <br>   pIDF-&gt;nInstrum = 0; <br>   pIDF-&gt;piSelect = NULL; <br>   pIDF-&gt;pInstrumSelect = NULL; <br>   ZeroMemory (pIDF-&gt;ai, sizeof(pIDF-&gt;ai)); <br>   ZeroMemory (&amp;pIDF-&gt;instrum, sizeof(pIDF-&gt;instrum)); <br> <br>   pIDF-&gt;szFile[0] = 0; <br>} <br> <br>typedef struct _idffile { <br>    DWORD fccRIFF; <br>    DWORD cbRIFF; <br>    DWORD fccIDF; <br>    } IDFFILE, * LPIDFFILE; <br> <br>/*+ <br> * <br> *-======================================================================*/ <br> <br>BOOL LoadIDFFromFile ( <br>   LPIDFHEAD pIDF, <br>   LPTSTR    pszFile) <br>{ <br>   LPIDFFILE  pIdfFile; <br>   LPRIFFLIST pList; <br>   DWORD      cbRemain; <br>   UINT       ii; <br> <br>   if (!pszFile) <br>      pszFile = pIDF-&gt;szFile; <br> <br>   pIDF-&gt;bReadOnly = FALSE; <br>   pIDF-&gt;hFile = CreateFile (pszFile, <br>                             GENERIC_READ | GENERIC_WRITE, <br>                             FILE_SHARE_READ, <br>                             NULL, // security <br>                             OPEN_EXISTING, <br>                             FILE_ATTRIBUTE_NORMAL, <br>                             NULL); <br>   if (INVALID_HANDLE_VALUE == pIDF-&gt;hFile) <br>   { <br>      pIDF-&gt;bReadOnly = TRUE; <br>      pIDF-&gt;hFile = CreateFile (pszFile, <br>                                GENERIC_READ, <br>                                FILE_SHARE_READ, <br>                                NULL, // security <br>                                OPEN_EXISTING, <br>                                FILE_ATTRIBUTE_NORMAL, <br>                                NULL); <br> <br>      if (INVALID_HANDLE_VALUE == pIDF-&gt;hFile) <br>         goto error_exit; <br>   } <br> <br>   pIDF-&gt;hSection = CreateFileMapping (pIDF-&gt;hFile, NULL, <br>                                       PAGE_READONLY, //PAGE_READWRITE, <br>                                       0, 0, NULL); <br>   if (INVALID_HANDLE_VALUE == pIDF-&gt;hSection) <br>      goto error_exit; <br> <br>   pIDF-&gt;pFileBase = MapViewOfFile (pIDF-&gt;hSection, FILE_MAP_READ, 0, 0, 0); <br>   if (NULL == pIDF-&gt;pFileBase) <br>      goto error_exit; <br>   pIDF-&gt;cbFile = GetFileSize (pIDF-&gt;hFile, NULL); <br> <br>   // verify that this is indeed a valid IDF file <br>   // <br>   pIdfFile = (LPVOID)pIDF-&gt;pFileBase; <br>   if (pIdfFile-&gt;fccRIFF != FCC_RIFF || <br>       pIdfFile-&gt;cbRIFF + sizeof(RIFF) &gt; pIDF-&gt;cbFile || <br>       pIdfFile-&gt;fccIDF != FCC_IDF) <br>       goto error_exit; <br> <br>   lstrcpy (pIDF-&gt;szFile, pszFile); <br> <br>   // now parse the IDF file and find the instruments therein <br>   // <br>   pList = (LPVOID)(pIdfFile + 1); <br>   cbRemain = pIdfFile-&gt;cbRIFF; <br> <br>   for (ii = 0; <br>        pList-&gt;fccList == FCC_LIST &amp;&amp; (ii &lt; NUMELMS(pIDF-&gt;ai)); <br>        ++ii, pList = (LPVOID) NEXTRIFF(pList)) <br>      { <br>      UINT cbAdvance = pList-&gt;cbList + (pList-&gt;cbList &amp; 1) + sizeof(RIFF);  <br>      pIDF-&gt;ai[ii].pList = pList; <br>      pIDF-&gt;nInstrum = ii+1; <br>      if (cbAdvance &gt; cbRemain) <br>         break; <br>      cbRemain -= cbAdvance; <br>      } <br> <br>   if (pIDF-&gt;nInstrum) <br>      pIDF-&gt;piSelect = &amp;pIDF-&gt;ai[0]; <br> <br>   pIDF-&gt;bChanged = FALSE; <br> <br>   return TRUE; <br> <br>error_exit: <br>  #if defined DEBUG || defined _DEBUG <br>   { <br>   TCHAR sz[512]; <br>   lstrcpy (sz, "LoadIDFFromFile failed: "); <br>   FormatMessage (FORMAT_MESSAGE_IGNORE_INSERTS <br>                  | FORMAT_MESSAGE_FROM_SYSTEM, <br>                  0, <br>                  GetLastError(), <br>                  0, <br>                  sz + lstrlen(sz), <br>                  NUMELMS(sz) - lstrlen(sz), <br>                  NULL); <br>   lstrcat (sz, "\r\n"); <br>   OutputDebugString (sz); <br>   } <br>  #endif <br>   FreeIDFFile (pIDF); <br>   return FALSE; <br>} <br> <br>/*+ NewIDFInstrum <br> * <br> *-======================================================================*/ <br> <br>LPINSTRUMENT WINAPI NewIDFInstrum ( <br>   LPIDFHEAD  pIDF, <br>   LPRIFFLIST pList, // optional RIFF init data for instrument <br>   LPSTR      pszInstrument) <br>{ <br>   static VIEWINIT vi; <br>   LPINSTRUMENT    lpi; <br> <br>   if (pIDF-&gt;nInstrum &gt;= NUMELMS(pIDF-&gt;ai)) <br>      return NULL; <br> <br>   lpi = HeapAlloc (gs.idf.hEditHeap, HEAP_ZERO_MEMORY, sizeof(INSTRUMENT)); <br>   if (lpi) <br>      { <br>      static struct { <br>          RIFFLIST    list; <br>          RIFF        rhdr; <br>          IDFHEADER   hdr; <br>          RIFF        rcaps; <br>          IDFINSTCAPS caps; <br>          }  gmMMAP = {  <br>              FCC_LIST, sizeof(gmMMAP) - sizeof(RIFF), FCC_MMAP, //list <br>              FCC_hdr, sizeof(IDFHEADER),           // rhdr <br>              sizeof(IDFHEADER), 0x100, 1, 1, 0,    // hdr <br>              FCC_caps, sizeof(IDFINSTCAPS),  <br>              sizeof(IDFINSTCAPS),          // caps size <br>              IDFINSTCAPS_F_GENERAL_MIDI,   // caps flags <br>              1,                            // caps basic channel  <br>              16,                           // caps num channels  <br>              16,                           // instrument polyphony <br>              16,                           // channel polyphony <br>          }; <br> <br>      // set default instrument data <br>      // <br>      if (!pList) <br>         pList = &amp;gmMMAP.list; <br>      CopyInstrumData (lpi, pList); <br> <br>      if (pszInstrument) <br>         lstrcpyA (lpi-&gt;szInstID, pszInstrument); <br> <br>      pIDF-&gt;ai[pIDF-&gt;nInstrum].pList = pList; <br>      pIDF-&gt;ai[pIDF-&gt;nInstrum].pInstrum = lpi; <br>      pIDF-&gt;piSelect = &amp;pIDF-&gt;ai[pIDF-&gt;nInstrum]; <br>      ++pIDF-&gt;nInstrum; <br> <br>      pIDF-&gt;bChanged = TRUE; <br>      } <br> <br>   return lpi; <br>} <br> <br>/*+ DeleteInstrum <br> * <br> *-======================================================================*/ <br> <br>VOID DeleteInstrum ( <br>   LPIDFHEAD pIDF) <br>{ <br>   UINT ii; <br> <br>   // figure out which slot in the instrument array <br>   // is the selected one. <br>   // <br>   for (ii = 0; ii &lt; pIDF-&gt;nInstrum; ++ii) <br>      { <br>      if (pIDF-&gt;piSelect == &amp;pIDF-&gt;ai[ii]) <br>         { <br>         struct _instrum_info info; <br>         assert (pIDF-&gt;nInstrum &gt; 0); <br> <br>         // exchange the selected instrument with the one <br>         // at the end of the list. then decrement the <br>         // count of valid instruments. <br>         // <br>         info = pIDF-&gt;ai[ii]; <br>         pIDF-&gt;ai[ii] = pIDF-&gt;ai[pIDF-&gt;nInstrum-1]; <br>         pIDF-&gt;ai[pIDF-&gt;nInstrum-1] = info; <br>         --pIDF-&gt;nInstrum; <br> <br>         pIDF-&gt;bChanged = TRUE; <br>         Head_RefreshTree (pIDF-&gt;hWndHead); <br>         break; <br>         } <br>      }                <br>} <br> <br>/*+ CopyInstrumToClip <br> * <br> *-======================================================================*/ <br> <br>VOID CopyInstrumToClip ( <br>   LPIDFHEAD pIDF) <br>{ <br>   UINT ii; <br> <br>   for (ii = 0; ii &lt; pIDF-&gt;nInstrum; ++ii) <br>      { <br>      if (pIDF-&gt;piSelect == &amp;pIDF-&gt;ai[ii]) <br>         { <br>         HGLOBAL hMem; <br>         if (pIDF-&gt;piSelect-&gt;pInstrum) <br>            { <br>            LPRIFFLIST pList; <br>            UINT   cb = InstrumMaxRiffDataSize (pIDF-&gt;piSelect-&gt;pInstrum); <br> <br>            hMem = GlobalAlloc (GHND | GMEM_ZEROINIT, cb); <br>            if (!(pList = GlobalLock (hMem))) <br>               return; <br> <br>            SaveInstrumToRiff (pList, pIDF-&gt;piSelect-&gt;pInstrum); <br>            GlobalUnlock (hMem); <br>            GlobalReAlloc (hMem, pList-&gt;cbList + sizeof(RIFF), 0); <br>            } <br>         else if (pIDF-&gt;piSelect-&gt;pList) <br>            { <br>            LPBYTE lpv; <br>            UINT   cb = pIDF-&gt;piSelect-&gt;pList-&gt;cbList + sizeof(RIFF); <br>            hMem = GlobalAlloc (GHND, cb); <br>            if (!(lpv = GlobalLock (hMem))) <br>               return; <br>            CopyMemory (lpv, pIDF-&gt;piSelect-&gt;pList, cb); <br>            GlobalUnlock (hMem); <br>            } <br> <br>         if (!OpenClipboard (hWndMain)) <br>            GlobalFree (hMem); <br>         else <br>            { <br>            EmptyClipboard (); <br>            SetClipboardData (CF_RIFF, hMem); <br>            CloseClipboard (); <br>            } <br>         } <br>      }                <br>} <br> <br>/*+ PasteInstrum <br> * <br> *-======================================================================*/ <br> <br>VOID PasteInstrum ( <br>   LPIDFHEAD pIDF) <br>{ <br>   HGLOBAL      hMem; <br>   LPRIFFLIST   pList; <br> <br>   if (!OpenClipboard(hWndMain)) <br>      return; <br> <br>   if (hMem = GetClipboardData(CF_RIFF)) <br>      { <br>      if (pList = GlobalLock (hMem)) <br>         { <br>         if (pList-&gt;fccList == FCC_LIST &amp;&amp; pList-&gt;fccType == FCC_MMAP) <br>            { <br>            NewIDFInstrum (pIDF, pList, NULL); <br>            Head_RefreshTree (pIDF-&gt;hWndHead); <br>            } <br>         GlobalUnlock (hMem); <br>         } <br>      } <br> <br>   CloseClipboard (); <br> <br>   return; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
