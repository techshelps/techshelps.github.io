<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2479"></a>MAIN.C</h2>
<pre><code>//************************************************************************ <br>//** <br>//**  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//**  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//**  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//**  A PARTICULAR PURPOSE. <br>//** <br>//**  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>//** <br>//**  main.c <br>//** <br>//**  DESCRIPTION: <br>//**     Performs window class registration, creations and message  <br>//**     polling. <br>//** <br>//************************************************************************ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>#define DECLARE_VARS <br>#include "idfedit.h" <br> <br>/*+ ErrorBox () <br> * <br> *  bring up a message box with a string from the stringtable <br> * <br> *-=================================================================*/ <br> <br>#include &lt;stdarg.h&gt; <br> <br>int WINAPI ErrorBox (UINT wStringID, UINT wType, ...) <br>{ <br>   char  szFormat[512]; <br>   char  szErr[512]; <br>   int   cbSize; <br>   va_list va; <br> <br>   va_start (va, wType); <br>   cbSize = LoadString (hInst, wStringID, szFormat, NUMELMS(szFormat)); <br>   if (!cbSize) <br>      wsprintf (szErr, "Error %d", wStringID); <br>   else <br>      wvsprintf (szErr, szFormat, va); <br>   va_end (va); <br> <br>   return MessageBox (hWndMain, szErr, szApp, wType); <br>} <br> <br>/*+ GetWindowPosFromIni <br> * <br> * retrieve the window position information from IDFEDIT.ini <br> * <br> *-=================================================================*/ <br> <br>static TCHAR cszProfile[] = TEXT ("MsIdfEd.ini"); <br>static TCHAR cszSection[] = TEXT ("General"); <br>static TCHAR cszWindow[]  = TEXT ("Window"); <br>static TCHAR cszWindowDef[] = TEXT (""); <br>static TCHAR cszWindowFmt[] = TEXT ("%d,%d,%d,%d"); <br> <br>BOOL WINAPI GetWindowPosFromIni ( <br>   LPRECT lprc) <br>   { <br>   TCHAR sz[100]; <br>   RECT  rcScreen; <br>   RECT  rc; <br> <br>   GetPrivateProfileString (cszSection, cszWindow, cszWindowDef, <br>                            sz, NUMELMS (sz), cszProfile); <br> <br>   if ( ! SystemParametersInfo (SPI_GETWORKAREA, 0, &amp;rcScreen, FALSE)) <br>      { <br>      rcScreen.top = rcScreen.left = 0; <br>      rcScreen.right = 640; <br>      rcScreen.bottom = 480; <br>      } <br> <br>   sscanf (sz, cszWindowFmt, <br>           &amp;lprc-&gt;left, &amp;lprc-&gt;top, <br>           &amp;lprc-&gt;right, &amp;lprc-&gt;bottom); <br> <br>   if ( ! IntersectRect (&amp;rc, &amp;rcScreen, lprc)) <br>      *lprc = rcScreen; <br> <br>   return ! IsRectEmpty (lprc); <br>   } <br> <br>/*+ SaveWindowPosToIni <br> * <br> * store the window position information in dragn.ini <br> * <br> *-=================================================================*/ <br> <br>BOOL WINAPI SaveWindowPosToIni ( <br>   LPRECT lprc) <br>   { <br>   TCHAR sz[100]; <br> <br>   wsprintf (sz, cszWindowFmt, <br>            lprc-&gt;left, <br>            lprc-&gt;top, <br>            lprc-&gt;right - lprc-&gt;left, <br>            lprc-&gt;bottom - lprc-&gt;top); <br> <br>   WritePrivateProfileString (cszSection, cszWindow, sz, cszProfile); <br> <br>   return TRUE; <br>   } <br> <br>/*+ AboutDlgProc() <br> * <br> *  callback function for the about dialog <br> * <br> *-=================================================================*/ <br> <br>BOOL CALLBACK AboutDlgProc ( <br>   HWND   hWnd, <br>   UINT   wMsgID, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   BOOL bRet = FALSE; <br>                          <br>   switch (wMsgID) <br>   {                     <br>      case WM_COMMAND: <br>      { <br>         UINT  uID     = GET_WM_COMMAND_ID(wParam, lParam); <br>         //UINT Notify   = GET_WM_COMMAND_CMD(wParam, lParam); <br>         //HWND hWndCtl  = GET_WM_COMMAND_HWND(wParam, lParam); <br> <br>         if (uID == IDOK || uID == IDCANCEL) <br>         {    <br>            EndDialog(hWnd, uID); <br>            bRet = TRUE; <br>         } <br>         break; <br>      } <br>   } <br>       <br>   return bRet; <br>   } <br> <br>/*+ GetActiveData <br> * <br> * helper function, gets data space from the active MDI child <br> * window <br> * <br> *-=================================================================*/ <br> <br>static LPVOID GetActiveData () <br>   { <br>   if (gs.pIDF &amp;&amp; gs.pIDF-&gt;szFile[0]) <br>      return gs.pIDF; <br>   return NULL; <br>   } <br> <br> <br>/*+ <br> * <br> *-======================================================================*/ <br> <br>STATICFN VOID WINAPI SetStandardCaption (VOID) <br>   { <br>   TCHAR sz[MAX_PATH + 20]; <br>   LoadString (hInst, IDS_CAPTION_BAR, sz, NUMELMS (sz)); <br>   lstrcat (sz, TEXT(" - ")); <br>   if (gs.szDefFile[0]) <br>      lstrcat (sz, gs.szDefFile); <br>   else <br>      { <br>      UINT cb = lstrlen(sz); <br>      LoadString (hInst, IDS_DEF_FILE_NAME, sz + cb, NUMELMS(sz) - cb); <br>      } <br>   SetWindowText (hWndMain, sz); <br>   } <br> <br>/*+ SaveAndCloseHeader <br> * <br> *-======================================================================*/ <br> <br>STATICFN BOOL SaveAndCloseHeader ( <br>   HWND hWnd, <br>   BOOL bSaveAs) <br>   { <br>   LPIDFHEAD pIDF = gs.pIDF; <br>   BOOL      bRet; <br> <br>   if (!pIDF) <br>      return TRUE; <br> <br>   if (!pIDF-&gt;szFile[0]) <br>      bSaveAs = TRUE; <br> <br>   if (pIDF-&gt;bReadOnly) <br>   { <br>      ErrorBox (IDS_ERR_READONLY, EB_INFO, gs.szDefFile); <br>      bSaveAs = TRUE; <br>   } <br> <br>   if (bSaveAs) <br>      {   <br>      if (! PromptForIDFName(hWnd, gs.szDefFile, NULL, TRUE)) <br>         return FALSE; <br>      } <br>   else <br>      lstrcpy (gs.szDefFile, pIDF-&gt;szFile); <br> <br>   if (!(bRet = SaveIDFToFile (pIDF, gs.szDefFile))) <br>      ErrorBox (IDS_ERR_SAVE, EB_ERROR, gs.szDefFile); <br> <br>   SetStandardCaption(); <br>   return bRet; <br>   } <br> <br>/*+ QuerySaveChanges <br> * <br> *-======================================================================*/ <br> <br>BOOL QuerySaveChanges ( <br>   HWND hWnd, <br>   BOOL bSetForeground) <br>   { <br>   UINT  idBtn; <br>   DWORD dwEB = EB_YNC; <br> <br>   if (!gs.pIDF) <br>      return TRUE; <br> <br>   if (bSetForeground) <br>      dwEB |= MB_SETFOREGROUND; <br> <br>   idBtn = ErrorBox (IDS_QUERY_SAVE, dwEB, gs.pIDF-&gt;szFile); <br>   if (idBtn == IDYES) <br>      return SaveAndCloseHeader (hWnd, FALSE); <br>   else if (idBtn == IDCANCEL) <br>      return FALSE; <br>   return TRUE; <br>   } <br> <br>/*+ OpenHeader <br> * <br> *-======================================================================*/ <br> <br>STATICFN LONG WINAPI OpenHeader ( <br>   HWND hWnd, <br>   BOOL bPrompt) <br>   { <br>   TCHAR szFile[MAX_PATH]; <br>   TCHAR szTitle[MAX_PATH]; <br>   LPIDFHEAD pIDF; <br> <br>   pIDF = gs.pIDF = &amp;gs.idf; <br>   if (gs.idf.bChanged &amp;&amp; ! QuerySaveChanges (hWnd, FALSE)) <br>      return 0; <br> <br>   FreeIDFFile (gs.pIDF); <br> <br>   szFile[0] = 0; <br>   if (bPrompt) <br>      { <br>      if ( ! PromptForIDFName (hWnd, szFile, szTitle, FALSE)) <br>         return 0; <br> <br>      lstrcpy (gs.szDefFile, szFile); <br>      LoadIDFFromFile (pIDF, szFile); <br>      } <br> <br>   if (!pIDF-&gt;hWndHead) <br>      { <br>      RECT rc; <br>      GetClientRect (hWnd, &amp;rc); <br> <br>      pIDF-&gt;hWndHead = CreateWindowEx (fdwExStyle | WS_EX_NOPARENTNOTIFY, <br>                                       cszHdrClass, <br>                                       "", <br>                                       WS_CHILD | WS_VISIBLE, <br>                                       0, 0, rc.right, rc.bottom, <br>                                       hWnd, <br>                                       (HMENU)1, <br>                                       hInst, <br>                                       pIDF); <br>      } <br>   else <br>      { <br>      Head_RefreshTree (pIDF-&gt;hWndHead); <br>      } <br> <br>   SetStandardCaption(); <br> <br>   return (LONG)pIDF-&gt;hWndHead; <br>   } <br> <br>/*+ MainCommands <br> * <br> *-=================================================================*/ <br> <br>LONG WINAPI MainCommands ( <br>   HWND   hWnd, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG lRet     = 1; <br>   WORD wID      = GET_WM_COMMAND_ID (wParam, lParam); <br>   WORD wNotify  = GET_WM_COMMAND_CMD (wParam, lParam); <br>   HWND hWndCtl  = GET_WM_COMMAND_HWND (wParam, lParam); <br> <br>   switch (wID) <br>      { <br>      case IDM_ABOUT: <br>         return DialogBox (hInst, <br>                           MAKEINTRESOURCE(IDD_ABOUT), <br>                           hWnd, <br>                           AboutDlgProc); <br>         break; <br> <br>      case IDM_HELP: <br>         ErrorBox (IDS_ERR_NOHELP, MB_OK); <br>         break; <br> <br>      case IDM_FILEOPEN: <br>         lRet = OpenHeader (hWnd, TRUE); <br>         break; <br> <br>      case IDM_FILENEW: <br>         lRet = OpenHeader (hWnd, FALSE); <br>         if (gs.pIDF) <br>         { <br>            NewIDFInstrum (gs.pIDF, NULL, "&lt;untitled&gt;"); <br>            gs.pIDF-&gt;bChanged = FALSE; <br>            Head_RefreshTree (gs.pIDF-&gt;hWndHead); <br>         } <br>         break; <br> <br>      case IDM_FILESAVE: <br>      case IDM_FILESAVEAS: <br>         lRet = SaveAndCloseHeader (hWnd, wID == IDM_FILESAVEAS); <br>         if (lRet) <br>         { <br>            // Saving has the side effect of also closing the file <br>            // so we need to re-open it after the save completes <br>            // <br>            LoadIDFFromFile (gs.pIDF, gs.szDefFile); <br>         } <br>         Head_RefreshTree (gs.pIDF-&gt;hWndHead); <br>         break; <br> <br>      case IDM_NEW_INSTRUMENT: <br>         NewIDFInstrum (gs.pIDF, NULL, "&lt;untitled&gt;"); <br>         Head_RefreshTree (gs.pIDF-&gt;hWndHead); <br>         break; <br> <br>      case IDM_FILEEXIT: <br>         PostMessage (hWnd, WM_CLOSE, 0, 0); <br>         break; <br> <br>      //case IDM_EDITUNDO: <br>      //   break; <br> <br>      case IDM_EDITCUT: <br>      case IDM_EDITCOPY: <br>         if (gs.pIDF &amp;&amp; gs.pIDF-&gt;piSelect) <br>            { <br>            CopyInstrumToClip (gs.pIDF); <br>            if (wID == IDM_EDITCUT) <br>               DeleteInstrum (gs.pIDF); <br>            } <br>         break; <br> <br>      case IDM_EDITPASTE: <br>         PasteInstrum (gs.pIDF); <br>         break; <br> <br>      case IDM_EDITDELETE: <br>         if (gs.pIDF &amp;&amp; gs.pIDF-&gt;piSelect) <br>            DeleteInstrum (gs.pIDF); <br>         break; <br>      } <br> <br>   return lRet; <br>   } <br> <br>/*+ MainWndProc <br> * <br> *-=================================================================*/ <br> <br>LRESULT CALLBACK MainWndProc ( <br>   HWND   hWnd, <br>   UINT   wMsgID, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG  lRet = 0;         // return value from this routine <br> <br>   switch (wMsgID) <br>      { <br>      case WM_COMMAND: <br>         lRet = MainCommands (hWnd, wParam, lParam); <br>         break; <br> <br>      case WM_NOTIFY: <br>         break; <br> <br>      case WM_SIZE: <br>         if (gs.idf.hWndHead) <br>            SetWindowPos (gs.idf.hWndHead, NULL, <br>                          0, 0, LOWORD(lParam), HIWORD(lParam), <br>                          SWP_NOZORDER); <br>         break; <br> <br>      case WM_CREATE: <br>         { <br>         // send ourselves a command to create a document window. <br>         // <br>         PostMessage (hWnd, WM_COMMAND, IDM_FILEOPEN, 0); <br>         } <br>         break; <br> <br>      case WM_INITMENUPOPUP: <br>         { <br>         HMENU  hPopup = (HMENU)wParam; <br>         UINT   uPos   = (UINT) LOWORD (lParam); <br>         BOOL   fSystemMenu = HIWORD (lParam); <br>         UINT   uFirstID; <br> <br>         // if this is for the system menu, go no further. <br>         // <br>         if (fSystemMenu) <br>            break; <br> <br>         // if this is the 'File' popup, do menu initialization <br>         // <br>         uFirstID = GetMenuItemID (hPopup, 0); <br>         if (uFirstID == IDM_FILENEW) <br>            { <br>            EnableMenuItem (hPopup, IDM_FILESAVE, gs.pIDF ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem (hPopup, IDM_FILESAVEAS, gs.pIDF ? MF_ENABLED : MF_GRAYED); <br>            } <br>         else if (uFirstID == IDM_EDITCUT) <br>            { <br>            BOOL bCanPaste = IsClipboardFormatAvailable(CF_RIFF); <br>            BOOL bCanCut = (gs.idf.piSelect != NULL); <br>            // BOOL bCanUndo = FALSE; <br> <br>            // EnableMenuItem (hPopup, IDM_EDITUNDO, bCanUndo ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem (hPopup, IDM_EDITCUT, bCanCut ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem (hPopup, IDM_EDITDELETE, bCanCut ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem (hPopup, IDM_EDITCOPY, bCanCut ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem (hPopup, IDM_EDITPASTE, bCanPaste ? MF_ENABLED : MF_GRAYED); <br>            } <br>         break; <br>         } <br> <br>      case WM_CLOSE: <br>      case WM_QUERYENDSESSION: <br>         { <br>         WINDOWPLACEMENT wpl; <br> <br>         if (gs.idf.bChanged &amp;&amp; <br>             !QuerySaveChanges (hWnd, wMsgID == WM_QUERYENDSESSION)) <br>            break; <br> <br>         // <br>         // before we shutdown, save the current size and position <br>         // of the window to the INI file. <br>         // <br>         ZeroMemory (&amp;wpl, sizeof(wpl)); <br>         wpl.length = sizeof(wpl); <br>         GetWindowPlacement (hWnd, &amp;wpl); <br> <br>         SaveWindowPosToIni (&amp;wpl.rcNormalPosition); <br> <br>         lRet = DefWindowProc (hWnd, wMsgID, wParam, lParam); <br>         break; <br>         } <br> <br>      case WM_DESTROY: <br>         // close the app (by causing an exit from the message loop) <br>         PostQuitMessage (0); <br>         break; <br> <br>      default: <br>         lRet = DefWindowProc (hWnd, wMsgID, wParam, lParam); <br>      } <br>   return lRet; <br>   } <br> <br>/*+ RegClasses () <br> * <br> *  Registers all window classes that will be <br> *   used in this application. <br> * <br> *  Called from WinMain <br> * <br> *  returns: the return value of the call to RegisterClass () <br> *          TRUE   if successful registration <br> *          FALSE  if registration failed <br> * <br> *-=================================================================*/ <br> <br>static CONST TCHAR cszMainClass[] = "Main"; <br> <br>extern LRESULT WINAPI ViewWndProc (HWND, UINT, WPARAM, LPARAM); <br> <br>BOOL WINAPI RegClasses ( <br>   HANDLE hInstance) <br>   { <br>   WNDCLASS  wc; <br>   TCHAR     ach[2]; <br> <br>   LoadString(hInstance, IDS_IS_RTL, ach, sizeof(ach)/sizeof(ach[0])); <br>   fdwExStyle = (ach[0] == '1') ? WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING : 0; <br> <br>   //InitCommonControls(); <br> <br>   // register the main window class <br>   // <br>   ZeroMemory (&amp;wc, sizeof(wc)); <br>   wc.lpszClassName = cszMainClass; <br>   wc.lpfnWndProc   = MainWndProc; <br>   wc.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>   wc.hIcon         = LoadIcon (hInst, MAKEINTRESOURCE (IDR_MAIN)); <br>   wc.lpszMenuName  = MAKEINTRESOURCE (IDR_MAIN); <br>   wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1); <br>   wc.hInstance     = hInstance; <br>   if (!RegisterClass (&amp;wc)) <br>       return FALSE; <br> <br>   // register the idf instrument window class <br>   // <br>   ZeroMemory (&amp;wc, sizeof(wc)); <br>   wc.lpszClassName = cszHdrClass; <br>   wc.lpfnWndProc   = HeadWndProc; <br>   wc.style         = CS_VREDRAW | CS_HREDRAW  | CS_DBLCLKS; <br>   wc.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>   wc.hIcon         = LoadIcon (hInst, MAKEINTRESOURCE (IDR_MAIN)); <br>   wc.lpszMenuName  = NULL; <br>   wc.hbrBackground = (HBRUSH) (COLOR_BTNFACE+1); <br>   wc.hInstance     = hInstance; <br>   if (!RegisterClass (&amp;wc)) <br>       return FALSE; <br> <br>   ZeroMemory (&amp;wc, sizeof(wc)); <br>   wc.lpszClassName = cszInstrumClass; <br>   wc.lpfnWndProc   = ViewWndProc; <br>   wc.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS; <br>   wc.hCursor       = LoadCursor (NULL, IDC_ARROW); <br>   wc.hIcon         = LoadIcon (hInst, MAKEINTRESOURCE (IDR_INSTRUM)); <br>   wc.lpszMenuName  = NULL; <br>   wc.hbrBackground = (HBRUSH) (COLOR_WINDOW+1); <br>   wc.hInstance     = hInstance; <br>   if (!RegisterClass (&amp;wc)) <br>       return FALSE; <br> <br>   return TRUE; <br>   } <br> <br>/*+ CreateMainWindow () <br> * <br> *  Creates the main window for the application. <br> * <br> *  Called from WinMain <br> * <br> *  returns:  a valid window handle if CreateWindow succeeds <br> *            or NULL if CreateWindow Fails <br> * <br> *-=================================================================*/ <br> <br>HWND WINAPI CreateMainWindow ( <br>   int nCmdShow) <br>   { <br>   HWND   hWnd; <br>   TCHAR  szTitle[100]; <br>   RECT   rc; <br> <br>   LoadString (hInst, IDS_CAPTION_BAR, szTitle, NUMELMS (szTitle)); <br> <br>   // get x, y, cx, cy positions from ini files <br>   // <br>   if ( ! GetWindowPosFromIni (&amp;rc)) <br>      rc.left = rc.right = CW_USEDEFAULT; <br> <br>   hWnd = CreateWindowEx (fdwExStyle,        // RTL style <br>                       cszMainClass,         // class <br>                       szTitle,              // title <br>                       WS_OVERLAPPEDWINDOW, <br>                       rc.left, <br>                       rc.top,               // position: x,y <br>                       rc.right, <br>                       rc.bottom,            // size: width, height <br>                       NULL,                 // parent <br>                       NULL,                 // menu or child id <br>                       hInst,                // instance <br>                       NULL);                // params to pass on to WM_CREATE <br> <br>   if (hWnd) <br>      ShowWindow (hWnd, nCmdShow); <br> <br>   return hWnd; <br>   } <br> <br>/*+ WinMain () <br> * <br> *-=================================================================*/ <br> <br>int WINAPI WinMain ( <br>   HINSTANCE hInstance, <br>   HINSTANCE hPrevInstance, <br>   LPSTR lpszCmdLine, <br>   int nCmdShow) <br>   { <br>   MSG     msg;      // temp for current message <br>   HACCEL  hAccel; <br> <br>   // save off instance handle in a global. THIS MUST BE DONE FIRST! <br>   // also load the application name into a global string <br>   // <br>   hInst = hInstance; <br>   LoadString (hInst, IDS_APPNAME, szApp, NUMELMS (szApp)); <br> <br>   // if this is not the first instance, register the class <br>   // if class registration fails, put up a message box and quit <br>   if (!RegClasses (hInstance)) <br>       return ErrorBox (IDS_ERR_REGCLASSES, EB_FATAL); <br> <br>   hAccel = LoadAccelerators (hInst, MAKEINTRESOURCE(IDR_MAIN)); <br> <br>   // create the main window and save it's window handle in a global <br>   // if the creation fails, put up a message box and quit. <br>   // <br>   hWndMain = CreateMainWindow (nCmdShow); <br>   if ( !hWndMain) <br>      return ErrorBox (IDS_ERR_CREATEMAIN, EB_FATAL); <br> <br>   // loop forever getting messages and dispatching them <br>   // to the appropriate window. <br>   // <br>   while (GetMessage (&amp;msg, NULL, 0,0)) <br>   { <br>      if (TranslateAccelerator (hWndMain, hAccel, &amp;msg)) <br>         continue; <br> <br>      TranslateMessage (&amp;msg); <br>      DispatchMessage (&amp;msg); <br>   } <br> <br>   // return the wParam of the last message (the QUIT message) <br>   // <br>   return msg.wParam; <br>   } </code></pre>
<p>&nbsp;</p></body>
</HTML>
