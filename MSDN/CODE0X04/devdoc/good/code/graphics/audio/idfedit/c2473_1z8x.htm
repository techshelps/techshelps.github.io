<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAWSTR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2481"></a>DRAWSTR.C</h2>
<pre><code><br>/***************************************************************************** <br>* <br>*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>*  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>*  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>*  A PARTICULAR PURPOSE. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>* <br>*****************************************************************************/ <br> <br>/*+ DrawStr.c <br> * <br> *-=================================================================*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br> <br>#include &lt;string.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#include "drawstr.h" <br>#include "tridee.h" <br>#include "res.h" <br>#include "idfedit.h" <br> <br>CONST LOGFONT lfMain = { <br>    12,                        //int   lfHeight; <br>    0,                         //int   lfWidth; <br>    0,                         //int   lfEscapement; <br>    0,                         //int   lfOrientation; <br>    FW_DONTCARE,               //int   lfWeight; <br>    0,                         //BYTE  lfItalic; <br>    0,                         //BYTE  lfUnderline; <br>    0,                         //BYTE  lfStrikeOut; <br>    ANSI_CHARSET,              //BYTE  lfCharSet; <br>    OUT_DEFAULT_PRECIS,        //BYTE  lfOutPrecision; <br>    CLIP_DEFAULT_PRECIS,       //BYTE  lfClipPrecision; <br>    DEFAULT_QUALITY,           //BYTE  lfQuality; <br>    DEFAULT_PITCH | FF_SWISS,  //BYTE  lfPitchAndFamily; <br>    "MS Sans Serif",           //BYTE  lfFaceName[LF_FACESIZE]; <br>    }; <br> <br>DSPREF dspref = {0}; <br>BOOL   bInEditingMode; <br> <br>#ifdef USE_MDI <br> #define DefProc DefMDIChildProc <br>#else <br> #define DefProc DefWindowProc <br>#endif <br> <br>/*+  AccessFilter <br> * <br> *   exception filter for access violations <br> * <br> *   this function is a filter for an except block. It must <br> *   return one of the following DWORD values: <br> *      EXCEPTION_EXECUTE_HANDLER <br> *      EXCEPTION_CONTINUE_SEARCH <br> *      EXCEPTION_CONTINUE_EXECUTION <br> * <br> *-=================================================================*/ <br> <br>DWORD AccessFilter ( <br>   DWORD dwExceptCode) <br>{ <br>   if (dwExceptCode == EXCEPTION_ACCESS_VIOLATION) <br>      return EXCEPTION_EXECUTE_HANDLER; <br>   return EXCEPTION_CONTINUE_SEARCH; <br>} <br> <br>/*+ DrawDsLabels <br> * <br> *-=================================================================*/ <br> <br>VOID WINAPI DrawDsLabels ( <br>   HDC          hDC, <br>   PDSFIELDTBL  pTable, <br>   PDSLINEINFO  pLineInfo, <br>   LPRECT       lpRect, <br>   POINT        ptOffset) <br>   { <br>   WORD        wOldAlign;  // temp, prev state of alignment <br>   UINT        ii;         // general index variable <br>   int         cx;         // current x position to draw at <br>   int         cy;         // current y position to draw at <br>   int         cyText; <br>   PDSFIELD    pField; <br>   struct _dsline * pLine; <br>   char        sz[100]; <br> <br>   // do some simple error checking, if not a valid DC <br>   // dont go any further. <br>   // <br>   if (!hDC) <br>      return; <br> <br>   // get the text metrics and initialize the max width variable <br>   // <br>   cyText = pLineInfo-&gt;cyLine; <br> <br>   // setup the current x &amp; y locations for writing text <br>   // <br>   cx = lpRect-&gt;left - ptOffset.x; <br>   cy = lpRect-&gt;top - ptOffset.y; <br> <br>   // draw each of the labels making a vertical <br>   // column starting 'cx,cy'.  But be sure not to <br>   // draw outside of the rectangle 'lpRect' <br>   // <br>   wOldAlign = SetTextAlign (hDC, TA_TOP | TA_LEFT); <br> <br>   // clear the background <br>   // <br>   ExtTextOut (hDC, cx, cy, ETO_CLIPPED | ETO_OPAQUE, lpRect, "", 0, NULL); <br> <br>   // draw the labels <br>   // <br>   for (pLine = &amp;pLineInfo-&gt;aLine[ii = 0]; <br>        ii &lt; pLineInfo-&gt;nCurLine; <br>        ++ii, ++pLine, cy += cyText) <br>      { <br>      if (cy &lt; lpRect-&gt;top - cyText) <br>         continue; <br> <br>      if (cy &gt; lpRect-&gt;bottom) <br>         break; <br> <br>      pField = pTable[pLine-&gt;uStruct].pFields; <br>      pField += pLine-&gt;uField; <br> <br>      wsprintf (sz, pField-&gt;psz, pLine-&gt;uMember); <br> <br>      if (sz[0] == ' ') <br>         { <br>         SetTextAlign (hDC, TA_TOP | TA_RIGHT); <br>         cx = lpRect-&gt;right - 2; <br>         } <br>      else <br>         { <br>         SetTextAlign (hDC, TA_TOP | TA_LEFT); <br>         cx = lpRect-&gt;left - ptOffset.x + (pLine-&gt;uDepth-1) * 16; <br>         } <br> <br>      // draw the label pointed to by pFields[ii].psz <br>      // then increment cy by the height of a label <br>      // <br>      ExtTextOut (hDC, <br>                  cx, <br>                  cy, <br>                  ETO_CLIPPED, <br>                  lpRect, <br>                  sz, <br>                  lstrlen(sz), <br>                  NULL); <br>      } <br> <br>   // restore text alignment and return <br>   // <br>   SetTextAlign (hDC, wOldAlign); <br> <br>   return; <br>   } <br> <br>/*+ GetFieldText <br> * <br> *-=================================================================*/ <br> <br>VOID WINAPI GetFieldText ( <br>   PDSFIELD  pField, <br>   LPVOID    lpData, <br>   UINT      uMember, <br>   LPSTR     pszIn, <br>   UINT      cchIn, <br>   PDSBUFF   pds) <br>   { <br>   UINT    cb; <br>   LPBYTE  lp; <br> <br>   pds-&gt;ptr = pszIn; <br>   pds-&gt;cch = cchIn; <br>   if (pds-&gt;cch &gt; 10) // allow a bit of slop <br>      pds-&gt;cch -= 10; <br>   pds-&gt;ptr[0] = 0; <br> <br>   __try <br>      { <br>      if (pField-&gt;fmt &amp; AS_REF) <br>         { <br>         lp = *(LPBYTE *)lpData; <br>         lp += (uMember * pField-&gt;siz); <br> <br>         if (dspref.bShowAddresses) <br>            { <br>            wsprintf (pds-&gt;ptr, "@%08x: ", lpData); <br>            cb = lstrlen(pds-&gt;ptr); <br>            pds-&gt;ptr += cb; <br>            pds-&gt;cch -= cb; <br>            } <br>         } <br>      else <br>         { <br>         lp = (LPBYTE)lpData + (uMember * pField-&gt;siz); <br> <br>         if (dspref.bShowAddresses) <br>            { <br>            wsprintf (pds-&gt;ptr, "@%08x: ", lp); <br>            cb = lstrlen(pds-&gt;ptr); <br>            pds-&gt;ptr += cb; <br>            pds-&gt;cch -= cb; <br>            } <br>         } <br> <br> <br>      if (lp == NULL) <br>         lstrcpy (pds-&gt;ptr, "&lt;null&gt;"); <br>      else <br>      switch (pField-&gt;fmt &amp; 0xFF) <br>         { <br>         case AS_NONE: <br>            //wsprintf (pds-&gt;ptr, "%08X = ", lp); <br>            break; <br> <br>         case AS_SZ: <br>            strncpy (pds-&gt;ptr, (LPTSTR)lp, pds-&gt;cch); <br>            break; <br> <br>         case AS_MODE: <br>            { <br>            UINT (*pfnMode)(LPSTR, UINT, DWORD) = (LPVOID)pField-&gt;aux; <br> <br>            if (pField-&gt;siz == sizeof(DWORD)) <br>                pfnMode (pds-&gt;ptr, pds-&gt;cch, *(DWORD *)lp); <br>            else <br>                pfnMode (pds-&gt;ptr, pds-&gt;cch, (DWORD)lp); <br>            } <br>            break; <br> <br>         case AS_XMODE: <br>            { <br>            UINT (*pfnMode)(LPSTR, UINT, UINT, UINT, UINT) = (LPVOID)pField-&gt;aux; <br> <br>            if (pField-&gt;siz == sizeof(DWORD)) <br>                pfnMode (pds-&gt;ptr, pds-&gt;cch, *(UINT *)lp, pField-&gt;array, WM_GETTEXT); <br>            else <br>                pfnMode (pds-&gt;ptr, pds-&gt;cch, (UINT)lp, pField-&gt;array, WM_GETTEXT); <br>            } <br>            break; <br> <br>         case AS_ERROR: <br>            { <br>            UINT cb; <br>            DWORD dwError = *(LPDWORD)lp; <br> <br>            pds-&gt;ptr[0] = 0; <br>            if (dwError) <br>                FormatMessage (FORMAT_MESSAGE_IGNORE_INSERTS <br>                               | FORMAT_MESSAGE_FROM_SYSTEM, <br>                               0, <br>                               dwError, <br>                               0, <br>                               pds-&gt;ptr, <br>                               pds-&gt;cch, <br>                               NULL); <br> <br>            // get rid of terminating CR/LF if it exists <br>            // <br>            cb = lstrlen(pds-&gt;ptr); <br>            if (cb &gt; 2) <br>               pds-&gt;ptr[cb-2] = 0; <br>            } <br>            break; <br> <br>         case AS_ACH: <br>            { <br>            UINT jj; <br>            for (jj = 0; jj &lt; pds-&gt;cch-1 &amp;&amp; jj &lt; pField-&gt;siz; ++jj) <br>                pds-&gt;ptr[jj] = lp[jj] &gt; 31 ? lp[jj] : '.'; <br>            pds-&gt;ptr[jj] = 0; <br>            } <br>            break; <br> <br>         case AS_DUMP: <br>            { <br>            UINT   jj; <br>            UINT   cb; <br> <br>            for (jj = 0; jj &lt; pField-&gt;siz; jj += sizeof(WORD)) <br>               { <br>               cb = wsprintf (pds-&gt;ptr, "%04X ", *(WORD *)(lp+jj)); <br>               if (cb &gt;= pds-&gt;cch) <br>                  { <br>                  pds-&gt;ptr[pds-&gt;cch-1] = 0; <br>                  break; <br>                  } <br> <br>               pds-&gt;cch -= cb; <br>               pds-&gt;ptr += cb; <br>               } <br> <br>            for (jj = 0; jj &lt; pds-&gt;cch-1 &amp;&amp; jj &lt; pField-&gt;siz; ++jj) <br>                pds-&gt;ptr[jj] = lp[jj] &gt; 31 ? lp[jj] : '.'; <br>            pds-&gt;ptr[jj] = 0; <br>            } <br>            break; <br> <br>         case AS_HEX: <br>            { <br>            UINT   jj; <br>            UINT   cb; <br> <br>            if (pField-&gt;siz == sizeof(DWORD)) <br>                pds-&gt;ptr += wsprintf (pds-&gt;ptr, "%08X", *(DWORD *)lp); <br>            else <br>            for (jj = 0; jj &lt; pField-&gt;siz; jj += sizeof(WORD)) <br>               { <br>               cb = wsprintf (pds-&gt;ptr, "%04X ", *(WORD *)(lp+jj)); <br>               if (cb &gt;= pds-&gt;cch) <br>                  { <br>                  pds-&gt;ptr[pds-&gt;cch-1] = 0; <br>                  break; <br>                  } <br> <br>               pds-&gt;cch -= cb; <br>               pds-&gt;ptr += cb; <br>               } <br>            *pds-&gt;ptr = 0; <br>            } <br>            break; <br> <br>         case AS_INT: <br>         case AS_UINT: <br>            if (sizeof(WORD) == pField-&gt;siz) <br>               wsprintf (pds-&gt;ptr, "%d", *(WORD *)lp); <br>            else if (sizeof(DWORD) == pField-&gt;siz) <br>               wsprintf (pds-&gt;ptr, "%d", *(DWORD *)lp); <br>            else <br>               { <br>               int  jj; <br>               UINT cb; <br> <br>               for (jj = pField-&gt;siz-2; jj &gt;= 0; jj -= sizeof(WORD)) <br>                  { <br>                  cb = wsprintf (pds-&gt;ptr, "%d ", *(WORD *)(lp+jj)); <br>                  if (cb &gt;= pds-&gt;cch) <br>                     { <br>                     pds-&gt;ptr[pds-&gt;cch-1] = 0; <br>                     break; <br>                     } <br>                  pds-&gt;ptr += cb; <br>                  pds-&gt;ptr -= cb; <br>                  } <br>               *pds-&gt;ptr = 0; <br>               } <br>            break; <br> <br>         case AS_HANDLE: <br>            wsprintf (pds-&gt;ptr, "%08X", *(UINT *)lp); <br>            break; <br> <br>         case AS_BITFIELD: <br>            lstrcpy (pds-&gt;ptr, ((*(UINT *)lp &amp; (1 &lt;&lt; pField-&gt;aux)) ? "TRUE" : "FALSE")); <br>            break; <br> <br>         case AS_RECT: <br>            wsprintf (pds-&gt;ptr, "%d,%d,%d,%d", *(LPRECT)lp); <br>            break; <br> <br>         case AS_POINT: <br>         case AS_SIZE: <br>            wsprintf (pds-&gt;ptr, "%d,%d", *(LPPOINT)lp); <br>            break; <br> <br>         case AS_POINTS: <br>            wsprintf (pds-&gt;ptr, "%d,%d", ((SHORT *)lp)[0], ((SHORT *)lp)[1]); <br>            break; <br> <br>         case AS_FLOAT: <br>            lstrcpy (pds-&gt;ptr, "&lt;float not supported&gt;"); <br>            break; <br> <br>         case AS_BYTES: <br>            { <br>            UINT   jj; <br>            LPTSTR psz = pds-&gt;ptr; <br> <br>            for (jj = 0; jj &lt; pField-&gt;siz; ++jj) <br>               { <br>               wsprintf (psz, "%3d ", *(BYTE *)((LPSTR)lp+jj)); <br>               psz += lstrlen(psz); <br>               *psz = 0; <br>               if (psz &gt; (pds-&gt;ptr + pds-&gt;cch - 10)) <br>                  { <br>                  *psz++ = '.'; <br>                  *psz++ = '.'; <br>                  *psz++ = '.'; <br>                  *psz++ = 0; <br>                  break; <br>                  }  <br>               } <br>            } <br>            break; <br>         } <br>      } <br>   __except (AccessFilter(GetExceptionCode())) <br>      { <br>      lstrcpy (pds-&gt;ptr, "&lt;no access&gt;"); <br>      } <br> <br>   return; <br>   } <br> <br>/*+ SetFieldText <br> * <br> * <br> *-=================================================================*/ <br> <br>BOOL SetFieldText ( <br>   struct _dsline * pLine, <br>   PDSFIELD         pField, <br>   PDSBUFF          pds) <br>{ <br>   LPBYTE lpv; <br> <br>   lpv = pLine-&gt;lpv; <br>   if (pField-&gt;fmt &amp; AS_REF) <br>     lpv = *(LPBYTE *)lpv; <br>   lpv += (pLine-&gt;uMember * pField-&gt;siz); <br> <br>   if (!pds-&gt;cch) <br>      return FALSE; <br>   pds-&gt;ptr[pds-&gt;cch-1] = 0; <br> <br>   switch (pField-&gt;fmt &amp; 0xFF) <br>      { <br>      case AS_SZ: <br>         strncpy (lpv, pds-&gt;ptr, min(pField-&gt;siz, pds-&gt;cch)); <br>         break; <br> <br>      case AS_BITFIELD: <br>         { <br>         LPTSTR psz = pds-&gt;ptr; <br> <br>         while (*psz == '\t' &amp;&amp; *psz == ' ') <br>            ++psz; <br> <br>         if ((*psz &amp; ~0x20) == 'T' || (*psz &amp; ~0x20) == 'Y' || *psz == '1') <br>            *(LPDWORD)lpv |= (1 &lt;&lt; pField-&gt;aux); <br>         else if ((*psz &amp; ~0x20) == 'F' || (*psz &amp; ~0x20) == 'N' || *psz == '0') <br>            *(LPDWORD)lpv &amp;= ~(1 &lt;&lt; pField-&gt;aux); <br>         } <br>         break; <br> <br>      case AS_XMODE: <br>         { <br>         UINT (*pfnMode)(LPSTR, UINT, UINT, UINT, UINT) = (LPVOID)pField-&gt;aux; <br> <br>         if (pField-&gt;siz == sizeof(DWORD)) <br>             pfnMode (pds-&gt;ptr, pds-&gt;cch, *(UINT *)lpv, pField-&gt;array, WM_SETTEXT); <br>         else <br>             pfnMode (pds-&gt;ptr, pds-&gt;cch, (UINT)lpv, pField-&gt;array, WM_SETTEXT); <br>         } <br>         break; <br> <br>      case AS_UINT: <br>         { <br>         LPSTR pszStop = pds-&gt;ptr; <br>         DWORD dw = (DWORD)strtoul (pds-&gt;ptr, &amp;pszStop, 10); <br>         if (pszStop != pds-&gt;ptr) <br>            { <br>            if (pField-&gt;siz == sizeof(DWORD)) <br>               *(LPDWORD)lpv = dw; <br>            else if (pField-&gt;siz == sizeof(WORD)) <br>               *(LPWORD)lpv = LOWORD(dw); <br>            } <br>         } <br>         break; <br> <br>      case AS_INT: <br>         { <br>         LPSTR pszStop = pds-&gt;ptr; <br>         LONG  ii = strtol (pds-&gt;ptr, &amp;pszStop, 10); <br>         if (pszStop != pds-&gt;ptr) <br>            { <br>            if (pField-&gt;siz == sizeof(LONG)) <br>               *(LPLONG)lpv = ii; <br>            else if (pField-&gt;siz == sizeof(short)) <br>               *(short int *)lpv = (short int)ii; <br>            } <br>         } <br>         break; <br> <br>      case AS_BYTES: <br>         { <br>         UINT   jj; <br>         LPTSTR psz; <br> <br>         psz = pds-&gt;ptr; <br>         for (jj = 0; jj &lt; pField-&gt;siz; ++jj) <br>            { <br>            ULONG uu; <br>            LPTSTR pszStop; <br>            while (*psz == '\t' || *psz == ' ') <br>               ++psz; <br> <br>            pszStop = psz; <br>            uu = strtoul (psz, &amp;pszStop, 10); <br>            if (pszStop == psz) <br>               break; <br> <br>            lpv[jj] = (BYTE)uu; <br> <br>            psz = pszStop; <br>            } <br>         } <br>         break; <br> <br>      case AS_HEX: <br>         { <br>         DWORD  dw = 0; <br>         LPTSTR psz; <br> <br>         psz = pds-&gt;ptr; <br>         while (*psz == '\t' || *psz == ' ') <br>             ++psz; <br> <br>         if (psz[0] == '0' &amp;&amp; (psz[1] == 'X' || psz[1] == 'x')) <br>             psz += 2; <br> <br>         while (*psz) <br>            { <br>            if (*psz &gt;= '0' &amp;&amp; *psz &lt;= '9') <br>               dw = (dw &lt;&lt; 4) + *psz - '0'; <br>            else if ((*psz &gt;= 'A' &amp;&amp; *psz &lt;= 'F') || <br>                     (*psz &gt;= 'a' &amp;&amp; *psz &lt;= 'f')) <br>               dw = (dw &lt;&lt; 4) + (*psz &amp; ~0x20) - 'A' + 10; <br>            else <br>               break; <br>            ++psz; <br>            } <br> <br>         if (dw != 0 || (psz &gt; pds-&gt;ptr &amp;&amp; psz[-1] == '0')) <br>            { <br>            if (pField-&gt;siz == sizeof(DWORD)) <br>               *(LPDWORD)lpv = dw; <br>            else if (pField-&gt;siz == sizeof(WORD)) <br>               *(LPWORD)lpv = LOWORD(dw); <br>            } <br>         } <br>         break; <br>      } <br> <br>   return TRUE; <br>} <br> <br>/*+ DrawDsData <br> * <br> *-=================================================================*/ <br> <br>VOID WINAPI DrawDsData ( <br>   HDC          hDC, <br>   PDSFIELDTBL  pTable, <br>   PDSLINEINFO  pLineInfo, // <br>   LPRECT       lpRect,     // rectangle to clip drawing to <br>   POINT        ptOffset)   // scrolling offset for upper left corner <br>   { <br>   WORD        wOldAlign;  // temp, prev state of alignment <br>   UINT        ii;         // general index variable <br>   int         cx;         // current x position to draw at <br>   int         cy;         // current y position to draw at <br>   int         cyText; <br>   PDSFIELD    pField; <br>   struct _dsline * pLine; <br> <br>   // do some simple error checking, if not a valid DC <br>   // dont go any further. <br>   // <br>   if (!hDC) <br>      return; <br> <br>   // get the text metrics and initialize the max width variable <br>   // <br>   cyText = pLineInfo-&gt;cyLine; <br> <br>   // setup the current x &amp; y locations for writing text <br>   // <br>   cx = lpRect-&gt;left - ptOffset.x; <br>   cy = lpRect-&gt;top - ptOffset.y; <br> <br>   // draw each of the labels making a vertical <br>   // column starting 'cx,cy'.  But be sure not to <br>   // draw outside of the rectangle 'lpRect' <br>   // <br>   wOldAlign = SetTextAlign (hDC, TA_TOP | TA_LEFT); <br> <br>   // clear the background <br>   // <br>   ExtTextOut (hDC, cx, cy, ETO_CLIPPED | ETO_OPAQUE, lpRect, "", 0, NULL); <br> <br>   // draw the data <br>   // <br>   for (pLine = &amp;pLineInfo-&gt;aLine[ii = 0]; <br>        ii &lt; pLineInfo-&gt;nCurLine; <br>        ++ii, ++pLine, cy += cyText) <br>      { <br>      char   sz[1024]; // buffer for formatting text info <br>      LPBYTE lpv; <br>      DSBUFF ds; <br>      UINT   cb; <br> <br>      if (cy &lt; lpRect-&gt;top - cyText) <br>         continue; <br>      if (cy &gt; lpRect-&gt;bottom) <br>         break; <br> <br>      pField = pTable[pLine-&gt;uStruct].pFields; <br>      pField += pLine-&gt;uField; <br>      lpv = pLine-&gt;lpv; <br> <br>      sz[0] = 0; <br>      GetFieldText (pField, lpv, pLine-&gt;uMember, sz, NUMELMS(sz), &amp;ds); <br>      if (cb = lstrlen (sz)) <br>         ExtTextOut (hDC, <br>                     cx, cy, <br>                     ETO_CLIPPED, lpRect, sz, cb, NULL); <br>      } <br> <br>   // restore text alignment and return <br>   // <br>   SetTextAlign (hDC, wOldAlign); <br> <br>   return; <br>   } <br> <br>/*+ GetDsLabelWidth <br> * <br> *-=================================================================*/ <br> <br>int WINAPI GetDsLabelWidth ( <br>   HDC          hDC, <br>   PDSFIELDTBL  pTable, <br>   PDSLINEINFO  pLineInfo) <br>   { <br>   int  cxWidth = 0; <br>   UINT ii; <br>   struct _dsline * pLine = pLineInfo-&gt;aLine; <br> <br>   for (pLine = &amp;pLineInfo-&gt;aLine[ii = 0]; <br>        ii &lt; pLineInfo-&gt;nCurLine; <br>        ++ii, ++pLine) <br>      { <br>      PDSFIELD pFields = pTable[pLine-&gt;uStruct].pFields; <br>      SIZE     size = {0,0}; <br> <br>      GetTextExtentPoint (hDC, <br>                          pFields[pLine-&gt;uField].psz, <br>                          lstrlen (pFields[pLine-&gt;uField].psz), <br>                          &amp;size); <br> <br>      size.cx += (pLine-&gt;uDepth * 16) - 16; <br> <br>      if (cxWidth &lt; size.cx) <br>         cxWidth = size.cx; <br>      } <br> <br>   return cxWidth; <br>   } <br> <br>/*+ AllocDsLineInfo <br> * <br> *-=================================================================*/ <br> <br>PDSLINEINFO WINAPI AllocDsLineInfo ( <br>   UINT nMax) <br>   { <br>   PDSLINEINFO pLineInfo; <br> <br>   pLineInfo = GlobalAllocPtr (GHND, sizeof(DSLINEINFO) <br>                               + sizeof(struct _dsline) * nMax); <br>   pLineInfo-&gt;nMaxLine = nMax; <br>   pLineInfo-&gt;nMaxDepth = 10; <br>   pLineInfo-&gt;nCurLine = 0; <br>   pLineInfo-&gt;nCurDepth = 0; <br>   return pLineInfo; <br>   } <br> <br>/*+ BuildDsLineInfo <br> * <br> *-=================================================================*/ <br> <br>VOID WINAPI BuildDsLineInfo ( <br>   PDSFIELDTBL  pTable, <br>   UINT         uStruct,    // <br>   LPVOID       lpData,     // pointer to structure to show <br>   WORD         nMember, <br>   WORD         nLastMember, <br>   PDSLINEINFO  pLineInfo) <br>   { <br>   UINT      uField; <br>   PDSFIELD  pField; <br>   UINT      cbStruct; <br> <br>   if (!pTable) <br>     return; <br>   pField = pTable[uStruct].pFields; <br>   cbStruct = pTable[uStruct].cbSize; <br> <br> <br>   if (pLineInfo-&gt;nCurDepth &gt;= pLineInfo-&gt;nMaxDepth) <br>      return; <br> <br>   ++pLineInfo-&gt;nCurDepth; <br> <br>   do <br>   { <br>      // now build the lines <br>      // <br>      for (uField = 0; pField-&gt;psz != NULL; ++pField, ++uField) <br>         { <br>         UINT   ix; <br> <br>         if (pLineInfo-&gt;nCurLine &gt;= pLineInfo-&gt;nMaxLine) <br>            break; <br> <br>         ix = 0; <br>         do { <br>            struct _dsline * pLine; <br>            LPBYTE lpv; <br> <br>            if (pLineInfo-&gt;nCurLine &gt;= pLineInfo-&gt;nMaxLine) <br>               break; <br> <br>            pLine = &amp;pLineInfo-&gt;aLine[pLineInfo-&gt;nCurLine]; <br>            ++pLineInfo-&gt;nCurLine; <br> <br>            pLine-&gt;uStruct = uStruct; <br>            pLine-&gt;uField = uField; <br>            pLine-&gt;uDepth = pLineInfo-&gt;nCurDepth; <br>            pLine-&gt;uMember = ix; <br>            pLine-&gt;lpv = (LPVOID)-2; <br> <br>            __try <br>               { <br>               lpv = (LPBYTE)lpData + (cbStruct * nMember) + pField-&gt;off; <br> <br>               pLine-&gt;lpv = lpv; <br> <br>               if (HIWORD(lpv)) // simple validity check... <br>                  { <br>                  lpv += (ix * pField-&gt;siz); <br>                  if ((pField-&gt;fmt &amp; 0x1FF) == AS_STRUCT) <br>                      BuildDsLineInfo (pTable, pField-&gt;aux, lpv, <br>                                       (WORD)ix, (WORD)ix, pLineInfo); <br>                  } <br>               } <br>            __except (AccessFilter(GetExceptionCode())) <br>               { <br>               } <br>            } while (++ix &lt; pField-&gt;array); <br>         } <br> <br>   } while (++nMember &lt;= nLastMember); <br> <br>   --pLineInfo-&gt;nCurDepth; <br>   return; <br>   } <br> <br>/*+ GetViewExtent <br> * <br> *-=================================================================*/ <br> <br>int WINAPI GetViewExtent ( <br>   HDC         hDC, <br>   PVIEWINIT   pvim, <br>   PDSLINEINFO pLineInfo, <br>   LPSIZE      lpItemSize, <br>   LPSIZE      lpTotalSize) <br>   { <br>   TEXTMETRIC tm; <br> <br>   pLineInfo-&gt;nCurLine = 0; <br>   pLineInfo-&gt;nCurDepth = 0; <br> <br>   BuildDsLineInfo (pvim-&gt;pTable, <br>                    pvim-&gt;uStruct, <br>                    pvim-&gt;lpData, <br>                    0, 0, <br>                    pLineInfo); <br> <br>   GetTextMetrics (hDC, &amp;tm); <br>   pLineInfo-&gt;cyLine = tm.tmHeight + tm.tmExternalLeading; <br> <br>   lpItemSize-&gt;cx = GetDsLabelWidth (hDC, pvim-&gt;pTable, pLineInfo); <br>   lpItemSize-&gt;cy = pLineInfo-&gt;cyLine; <br> <br>   lpTotalSize-&gt;cx = lpItemSize-&gt;cx * 2; <br>   lpTotalSize-&gt;cy = pLineInfo-&gt;cyLine * pLineInfo-&gt;nCurLine; <br> <br>   return pLineInfo-&gt;nCurLine; <br>   } <br> <br>/*+ <br> *  ViewWndProc <br> * <br> *-=================================================================*/ <br> <br>// misc manifest constants <br>// <br>#define HTLABEL 1 <br>#define HTEDGE  2 <br>#define HTDATA  3 <br> <br>typedef struct _viewstate { <br>   UINT        wLabelWidth; <br>   SIZE        sTotal; <br>   SIZE        sLabel; <br>   SIZE        sScroll; <br>   POINT       ptVisible; <br>   //HBRUSH      hBrFace; <br>   HFONT       hFontLabel; <br>   HFONT       hFontData; <br>   HMENU       hMenu; <br>   WORD        wHit; <br>   UINT        nHitLine; <br>   HCURSOR     hCurEdge; <br>   POINT       ptEdgeBegin; <br>   int         cxEdgeSlop; <br>   POINT       ptLastEdge; <br>   int         nWindowCnt; <br>   PDSLINEINFO pLineInfo; <br>   int         cyLine; <br>   int         cyWnd; <br>   VIEWINIT    vi; <br>   } VIEWSTATE, *PVIEWSTATE; <br> <br> <br>/*+ <br> * <br> * <br> *-=================================================================*/ <br> <br>VOID WINAPI UpdateScrollRanges ( <br>   PVIEWSTATE pv, <br>   HWND       hWnd) <br>   { <br>   RECT rc; <br> <br>   pv-&gt;sTotal.cy = pv-&gt;cyLine * pv-&gt;pLineInfo-&gt;nCurLine; <br> <br>   GetClientRect (hWnd, &amp;rc); <br>   pv-&gt;cyWnd = (rc.bottom - rc.top); <br>   pv-&gt;cyWnd -= (pv-&gt;cyWnd % pv-&gt;cyLine); <br>   pv-&gt;sScroll.cy = max (pv-&gt;sTotal.cy - pv-&gt;cyWnd, 0); <br>   pv-&gt;ptVisible.y = min (pv-&gt;sScroll.cy, pv-&gt;ptVisible.y); <br> <br>   SetScrollRange (hWnd, SB_VERT, 0, pv-&gt;sScroll.cy, FALSE); <br>   SetScrollPos (hWnd, SB_VERT, pv-&gt;ptVisible.y, TRUE); <br>   } <br> <br>/*+ <br> *  ViewPrivate <br> * <br> *-=================================================================*/ <br> <br>UINT WINAPI EditInPlace ( <br>   HWND       hWnd, <br>   PVIEWSTATE pv, <br>   UINT       nLine); <br> <br>LONG WINAPI ViewPrivate ( <br>   HWND   hWnd, <br>   UINT   wMsgID, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   PVIEWSTATE pv; <br> <br>   pv = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br>   if (!pv) <br>      return 0; <br> <br>   switch (wMsgID) <br>      { <br>      case VM_GETDATA: <br>         lRet = (LRESULT)pv-&gt;vi.lpData; <br>         break; <br> <br>      case VM_SETDATA: <br>         lRet = (LRESULT)pv-&gt;vi.lpData; <br>         pv-&gt;vi.lpData = (LPVOID)lParam; <br>         if (lRet != (LRESULT)pv-&gt;vi.lpData) <br>            { <br>            RECT rc; <br> <br>            pv-&gt;pLineInfo-&gt;nCurLine = 0; <br>            pv-&gt;pLineInfo-&gt;nCurDepth = 0; <br> <br>            BuildDsLineInfo (pv-&gt;vi.pTable, <br>                             pv-&gt;vi.uStruct, <br>                             pv-&gt;vi.lpData, <br>                             0, 0, <br>                             pv-&gt;pLineInfo); <br> <br>            GetClientRect (hWnd, &amp;rc); <br>            rc.left = pv-&gt;wLabelWidth + 5; <br>            InvalidateRect (hWnd, &amp;rc, FALSE); <br>            } <br>         break; <br> <br>      case VM_INVALIDATE: <br>         { <br>         RECT  rc; <br>         int   yLine; <br> <br>         if (!wParam &amp;&amp; !lParam) <br>            InvalidateRect (hWnd, NULL, FALSE); <br> <br>         GetClientRect (hWnd, &amp;rc); <br>         yLine = ((int)lParam * pv-&gt;cyLine) - pv-&gt;ptVisible.y; <br>         if (yLine &gt;= rc.top &amp;&amp; yLine &lt;= rc.bottom) <br>            { <br>            rc.left += pv-&gt;wLabelWidth + 5; <br>            rc.top += yLine; <br>            rc.bottom = rc.top + (pv-&gt;cyLine * max(1, wParam)); <br>            InvalidateRect (hWnd, &amp;rc, FALSE); <br>            } <br>         } <br>         break; <br> <br>      case VM_SETSEL: <br>         { <br>         UINT nLine = (UINT)lParam; <br>         BOOL bPrev = (BOOL)wParam; <br> <br>         while (nLine &lt; pv-&gt;pLineInfo-&gt;nCurLine) <br>            { <br>            struct _dsline * pLine = &amp;pv-&gt;pLineInfo-&gt;aLine[nLine]; <br>            PDSFIELD pField = pv-&gt;vi.pTable[pLine-&gt;uStruct].pFields + pLine-&gt;uField; <br>            if (pField-&gt;fmt &amp; IS_EDIT) <br>               { <br>               RECT rc; <br>               int  yLine; <br> <br>               GetClientRect (hWnd, &amp;rc); <br>               yLine = (int)(nLine * pv-&gt;cyLine) - pv-&gt;ptVisible.y; <br>               if (yLine &gt;= rc.top &amp;&amp; (yLine + pv-&gt;cyLine) &lt;= rc.bottom) <br>                  pv-&gt;nHitLine = nLine, lRet = 1; <br>               break; <br>               } <br>            if (bPrev &amp;&amp; nLine == 0) <br>                break; <br>            nLine = bPrev ? nLine-1 : nLine+1; <br>            } <br> <br>         } <br>         break; <br> <br>      case VM_EDITNEXT: <br>         { <br>         UINT nLine = pv-&gt;nHitLine; <br>         BOOL bPrev = (BOOL)wParam; <br> <br>         if (bPrev &amp;&amp; nLine == 0) <br>            break; <br>         nLine = bPrev ? nLine-1 : nLine+1; <br> <br>         if (ViewPrivate (hWnd, VM_SETSEL, bPrev, nLine)) <br>            { <br>            EditInPlace (hWnd, pv, pv-&gt;nHitLine); <br>            } <br>         } <br>      } <br> <br>   return lRet; <br>   } <br> <br>/*+ <br> *   <br> * <br> *-=================================================================*/ <br> <br>LRESULT Notify ( <br>   HWND hWnd, <br>   UINT code) <br>{ <br>   NMHDR nm; <br> <br>   nm.hwndFrom = hWnd; <br>   nm.idFrom = GetDlgCtrlID(hWnd); <br>   nm.code = code; <br>   return SendMessage (GetParent(hWnd), WM_NOTIFY, nm.idFrom, (LPARAM)(LPVOID)&amp;nm); <br>} <br> <br>/*+ <br> *  EditInPlace <br> * <br> *-=================================================================*/ <br> <br>UINT WINAPI EditInPlace ( <br>   HWND       hWnd, <br>   PVIEWSTATE pv, <br>   UINT       nLine) <br>   { <br>   PDSFIELDTBL  pTable = pv-&gt;vi.pTable; <br>   PDSLINEINFO  pLineInfo = pv-&gt;pLineInfo; <br>   struct _dsline * pLine; <br>   PDSFIELD         pField; <br>   TCHAR        sz[1000]; <br>   HWND         hWndEdit; <br>   RECT         rc; <br>   MSG          msg; <br>   UINT         uId; <br>   DSBUFF       ds; <br> <br>   if (nLine &gt;= pLineInfo-&gt;nCurLine) <br>      return 0; <br> <br>   pLine = &amp;pLineInfo-&gt;aLine[nLine]; <br>   pField = pTable[pLine-&gt;uStruct].pFields + pLine-&gt;uField; <br> <br>   GetFieldText (pField, pLine-&gt;lpv, pLine-&gt;uMember, sz, NUMELMS(sz), &amp;ds); <br> <br>   GetClientRect (hWnd, &amp;rc); <br>   rc.left += pv-&gt;wLabelWidth + 5; <br>   rc.top = (nLine * pv-&gt;cyLine) - pv-&gt;ptVisible.y -2; <br>   rc.bottom = rc.top + pv-&gt;cyLine + 4; <br> <br>   hWndEdit = CreateWindowEx (fdwExStyle | WS_EX_NOPARENTNOTIFY, <br>                              "Edit", <br>                              sz, <br>                              ES_AUTOHSCROLL | <br>                              ES_LEFT | <br>                              WS_CHILD | WS_BORDER, <br>                              rc.left, rc.top, <br>                              rc.right - rc.left, rc.bottom - rc.top, <br>                              hWnd, <br>                              (HMENU)IDE_VALUE, <br>                              GetWindowInstance(hWnd), <br>                              NULL); <br>   if ( ! hWndEdit) <br>      return 0; <br> <br>   SendMessage (hWndEdit, WM_SETFONT, (WPARAM)pv-&gt;hFontData, 0); <br>   Edit_SetSel (hWndEdit, 0, NUMELMS(sz)+2); <br>   ShowWindow (hWndEdit, SW_SHOWNORMAL); <br>   SetFocus (hWndEdit); <br> <br>   uId = IDOK; <br>   bInEditingMode = TRUE; <br>   do { <br>      if (PeekMessage (&amp;msg, NULL, 0, 0, PM_NOREMOVE)) <br>         { <br>         if (msg.hwnd != hWndEdit &amp;&amp; <br>             (msg.message == WM_LBUTTONDOWN || <br>              msg.message == WM_RBUTTONDOWN)) <br>            break; <br> <br>         if (msg.message == WM_QUIT) <br>            break; <br> <br>         if (msg.message == WM_SYSKEYDOWN) <br>            break; <br> <br>         GetMessage (&amp;msg, NULL, 0, 0); <br>         if ((msg.hwnd == hWndEdit) &amp;&amp; (msg.message == WM_KEYDOWN)) <br>            { <br>            if (LOWORD(msg.wParam) == VK_RETURN) <br>               break; </code></pre>
<p>
</p>
<pre><code>else if (LOWORD(msg.wParam) == VK_TAB) <br>               { <br>               PostMessage (hWnd, VM_EDITNEXT, (WPARAM)GetKeyState(VK_SHIFT), 0); <br>               break; <br>               } <br>            else if (LOWORD(msg.wParam) == VK_ESCAPE) <br>               { <br>               uId = IDCANCEL; <br>               break; <br>               } <br>            } <br> <br>         TranslateMessage (&amp;msg); <br>         DispatchMessage (&amp;msg); <br>         } <br>      else <br>         { <br>         //SendMessage (hWnd, WM_ENTERIDLE, 0, 0); <br>         WaitMessage(); <br>         } <br> <br>      } while (bInEditingMode &amp;&amp; GetFocus() == hWndEdit); <br> <br>   bInEditingMode = FALSE; <br>   if (uId == IDOK) <br>   { <br>       GetWindowText (hWndEdit, sz, NUMELMS(sz)); <br>       ds.ptr = sz; <br>       ds.cch = lstrlen(ds.ptr)+1; <br>       SetFieldText (pLine, pField, &amp;ds); <br>       ViewPrivate (hWnd, VM_INVALIDATE, 0, nLine); <br>       Notify (hWnd, VN_CHANGE); <br>   } <br>   DestroyWindow (hWndEdit); <br> <br>   return uId; <br>} <br> <br>/*+ <br> *  CopyLineToClip <br> * <br> *-=================================================================*/ <br> <br>LONG WINAPI CopyLineToClip ( <br>   HWND       hWnd, <br>   PVIEWSTATE pv, <br>   UINT       nLine) <br>{ <br>   PDSFIELDTBL  pTable = pv-&gt;vi.pTable; <br>   PDSLINEINFO  pLineInfo = pv-&gt;pLineInfo; <br>   HGLOBAL      hMem; <br>   struct _dsline * pLine; <br>   PDSFIELD         pField; <br>   UINT         cfType; <br> <br>   pLine = &amp;pLineInfo-&gt;aLine[nLine]; <br>   pField = pTable[pLine-&gt;uStruct].pFields + pLine-&gt;uField; <br> <br>   switch (pField-&gt;fmt &amp; 0xFF) <br>      { <br>      case AS_BYTES: <br>      case AS_DUMP: <br>         { <br>         LPRIFF pRiff; <br>         LPBYTE lpv; <br> <br>         lpv = pLine-&gt;lpv; <br>         if (pField-&gt;fmt &amp; AS_REF) <br>            lpv = *(LPBYTE *)lpv; <br>         lpv += (pLine-&gt;uMember * pField-&gt;siz); <br> <br>         cfType = CF_RIFF; <br>         hMem = GlobalAlloc (GHND, pField-&gt;siz + sizeof(RIFF)); <br>         if (!(pRiff = GlobalLock (hMem))) <br>            return 0; <br> <br>         pRiff-&gt;fcc = MAKEFOURCC('B','y','t','e'); <br>         pRiff-&gt;cb = pField-&gt;siz; <br>         CopyMemory (pRiff+1, lpv, pField-&gt;siz); <br>         GlobalUnlock (hMem); <br>         } <br>         break; <br> <br>      case AS_XMODE: <br>         { <br>         UINT (*pfnMode)(LPSTR, UINT, UINT, UINT, UINT) = (LPVOID)pField-&gt;aux; <br>         LPBYTE lpv; <br> <br>         lpv = pLine-&gt;lpv; <br>         if (pField-&gt;fmt &amp; AS_REF) <br>            lpv = *(LPBYTE *)lpv; <br>         lpv += (pLine-&gt;uMember * pField-&gt;siz); <br> <br>         if (pField-&gt;siz == sizeof(DWORD)) <br>             { <br>             if (pfnMode (NULL, (UINT)hWnd, *(UINT *)lpv, pField-&gt;array, WM_COPY)) <br>                return 0; <br>             } <br>         else <br>             { <br>             if (pfnMode (NULL, (UINT)hWnd, (UINT)lpv, pField-&gt;array, WM_COPY)) <br>                return 0; <br>             } <br>         } <br>         // fall through <br>      default: <br>         { <br>         DSBUFF ds; <br>         LPSTR  psz; <br>         UINT   cch = 128 * 5 + 10; <br>         cfType = CF_TEXT; <br> <br>         hMem = GlobalAlloc (GHND, cch); <br>         if (!(psz = GlobalLock (hMem))) <br>            return 0; <br> <br>         // get data for the current line into the global <br>         // object. <br>         // <br>         GetFieldText (pField, pLine-&gt;lpv, pLine-&gt;uMember, psz, cch, &amp;ds); <br> <br>         // truncate the global object to fit the size of the data <br>         // <br>         GlobalUnlock (hMem); <br>         GlobalReAlloc (hMem, lstrlen(psz) + 2, 0); <br>         } <br>         break; <br>      } <br> <br>   if (OpenClipboard (hWnd)) <br>       { <br>       EmptyClipboard (); <br>       SetClipboardData (cfType, hMem); <br>       CloseClipboard (); <br>       } <br>   else <br>       GlobalFree (hMem); <br> <br>   return 0; <br>} <br> <br>/*+ <br> *  PasteLineFromClip <br> * <br> *-=================================================================*/ <br> <br>LONG WINAPI PasteLineFromClip ( <br>   HWND       hWnd, <br>   PVIEWSTATE pv, <br>   UINT       nLine) <br>{ <br>   HGLOBAL hMem; <br>   PDSFIELDTBL  pTable = pv-&gt;vi.pTable; <br>   PDSLINEINFO  pLineInfo = pv-&gt;pLineInfo; <br>   struct _dsline * pLine = &amp;pLineInfo-&gt;aLine[nLine]; <br>   PDSFIELD     pField = pTable[pLine-&gt;uStruct].pFields + pLine-&gt;uField; <br>   LONG lRet = 0; <br> <br>   switch (pField-&gt;fmt &amp; 0xFF) <br>      { <br>      case AS_BYTES: <br>      case AS_DUMP: <br>          if (OpenClipboard (hWnd)) <br>             { <br>             if (hMem = GetClipboardData (CF_RIFF)) <br>               { <br>               LPRIFF pRiff; <br>               LPBYTE lpv; <br> <br>               lpv = pLine-&gt;lpv; <br>               if (pField-&gt;fmt &amp; AS_REF) <br>                  lpv = *(LPBYTE *)lpv; <br>               lpv += (pLine-&gt;uMember * pField-&gt;siz); <br> <br>               if (pRiff = GlobalLock (hMem)) <br>                  { <br>                  if (pRiff-&gt;fcc == MAKEFOURCC('B','y','t','e') &amp;&amp; <br>                      pRiff-&gt;cb == pField-&gt;siz) <br>                     { <br>                     CopyMemory (lpv, pRiff+1, pField-&gt;siz); <br>                     lRet = 2; <br>                     } <br>                  GlobalUnlock (hMem); <br>                  } <br>               }  <br>            CloseClipboard (); <br>            } <br>         break; <br> <br>      case AS_XMODE: <br>         { <br>         UINT (*pfnMode)(LPSTR, UINT, UINT, UINT, UINT) = (LPVOID)pField-&gt;aux; <br>         LPBYTE lpv; <br> <br>         lpv = pLine-&gt;lpv; <br>         if (pField-&gt;fmt &amp; AS_REF) <br>            lpv = *(LPBYTE *)lpv; <br>         lpv += (pLine-&gt;uMember * pField-&gt;siz); <br> <br>         if (pField-&gt;siz == sizeof(DWORD)) <br>             lRet = pfnMode (NULL, (UINT)hWnd, *(UINT *)lpv, pField-&gt;array, WM_PASTE); <br>         else <br>             lRet = pfnMode (NULL, (UINT)hWnd, (UINT)lpv, pField-&gt;array, WM_PASTE); <br> <br>         // fall through if pfnMode handled the paste operation <br>         // <br>         if (lRet != 0) <br>            break; <br>         } <br>         // fall through <br>      default: <br>         if (OpenClipboard (hWnd)) <br>            { <br>            if (hMem = GetClipboardData (CF_TEXT)) <br>               { <br>               DSBUFF ds; <br>               ds.ptr = GlobalLock (hMem); <br>               if (ds.ptr) <br>                  { <br>                  ds.cch = lstrlen(ds.ptr)+1; <br>                  SetFieldText (pLine, pField, &amp;ds); <br>                  lRet = 2; <br>                  } <br>               } <br>            CloseClipboard (); <br>            } <br>         break; <br>      } <br> <br>   if (lRet &gt; 0) <br>   { <br>      ViewPrivate (hWnd, VM_INVALIDATE, 0, nLine); <br>      Notify (hWnd, VN_CHANGE); <br>   } <br> <br>   return lRet; <br>} <br> <br>/*+ <br> *  ViewCommands <br> * <br> *-=================================================================*/ <br> <br>LONG WINAPI ViewCommands ( <br>   HWND   hWnd, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   PVIEWSTATE pv; <br> <br>   pv = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br>   if (!pv) <br>      return 0; <br> <br>   switch (GET_WM_COMMAND_ID(wParam,lParam)) <br>      { <br>      case IDM_OBJEDIT: <br>          EditInPlace   (hWnd, pv, pv-&gt;nHitLine); <br>          //EditLineValue (hWnd, pv, pv-&gt;nHitLine); <br>          break; <br> <br>      case IDM_EDITCOPY: <br>          CopyLineToClip (hWnd, pv, pv-&gt;nHitLine); <br>          break; <br> <br>      case IDM_EDITPASTE: <br>          PasteLineFromClip (hWnd, pv, pv-&gt;nHitLine); <br>          break; <br>      } <br> <br>   return lRet; <br>   } <br> <br>/*+ <br> *  ViewWndProc <br> * <br> *-=================================================================*/ <br> <br>LONG CALLBACK ViewWndProc ( <br>   HWND   hWnd, <br>   UINT   wMsgID, <br>   WPARAM wParam, <br>   LPARAM lParam) <br>   { <br>   LONG       lRet = 0l;               // return value from this routine <br>   PVIEWSTATE pv; <br> <br>   pv = (LPVOID) GetWindowLong (hWnd, GWL_USERDATA); <br> <br>   if (wMsgID &gt;= WM_USER &amp;&amp; wMsgID &lt; 0x8000) <br>      lRet = ViewPrivate (hWnd, wMsgID, wParam, lParam); <br>   else <br>   switch (wMsgID) <br>      { <br>      case WM_NCHITTEST: <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br>         if (lRet == HTCLIENT) <br>            { <br>            POINT pt = {MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y}; <br> <br>            ScreenToClient (hWnd, &amp;pt); <br> <br>            pv-&gt;wHit = HTEDGE; <br>            if (pt.x &lt;= (int)pv-&gt;wLabelWidth -4) <br>               pv-&gt;wHit = HTLABEL; <br>            else if (pt.x &gt;= (int)pv-&gt;wLabelWidth +4) <br>               pv-&gt;wHit = HTDATA; <br>            } <br>         break; <br> <br>     #if 0 <br>      case WM_SETCURSOR: <br>         if (LOWORD (lParam) == HTCLIENT &amp;&amp; <br>             pv-&gt;wHit == HTEDGE &amp;&amp; <br>             pv-&gt;hCurEdge != NULL) <br>            SetCursor (pv-&gt;hCurEdge); <br>         else <br>            lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br>         break; <br>     #endif <br> <br>      case WM_LBUTTONDBLCLK: <br>         { <br>         POINT pt = {MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y}; <br>         PDSFIELDTBL  pTable = pv-&gt;vi.pTable; <br>         PDSLINEINFO  pLineInfo = pv-&gt;pLineInfo; <br>         UINT         nLine = (pt.y + pv-&gt;ptVisible.y) / pv-&gt;cyLine; <br> <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br> <br>         if (nLine &lt; pLineInfo-&gt;nCurLine) <br>             { <br>             struct _dsline * pLine = &amp;pLineInfo-&gt;aLine[nLine]; <br>             PDSFIELD pField = pTable[pLine-&gt;uStruct].pFields + pLine-&gt;uField; <br> <br>             if ((pField-&gt;fmt &amp; IS_EDIT) &amp;&amp; pv-&gt;hMenu) <br>                { <br>                pv-&gt;nHitLine = nLine; <br>                SetCapture (hWnd); <br>                } <br>            } <br>         break; <br>         } <br> <br>      case WM_LBUTTONUP: <br>         { <br>         if (GetCapture() == hWnd) <br>            { <br>            POINT pt = {MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y}; <br>            PDSFIELDTBL  pTable = pv-&gt;vi.pTable; <br>            PDSLINEINFO  pLineInfo = pv-&gt;pLineInfo; <br>            UINT         nLine = (pt.y + pv-&gt;ptVisible.y) / pv-&gt;cyLine; <br> <br>            ReleaseCapture (); <br> <br>            if (nLine == pv-&gt;nHitLine) <br>               PostMessage (hWnd, WM_COMMAND, IDM_OBJEDIT, 0); <br>            } <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br>         break; <br>         } <br> <br>      case WM_LBUTTONDOWN: <br>      case WM_RBUTTONDOWN: <br>         SetFocus (hWnd); <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br>         break; <br> <br>      case WM_RBUTTONUP: <br>         { <br>         POINT pt = {MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y}; <br>         PDSFIELDTBL  pTable = pv-&gt;vi.pTable; <br>         PDSLINEINFO  pLineInfo = pv-&gt;pLineInfo; <br>         UINT         nLine = (pt.y + pv-&gt;ptVisible.y) / pv-&gt;cyLine; <br> <br> <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br> <br>         if (nLine &lt; pLineInfo-&gt;nCurLine) <br>             { <br>             struct _dsline * pLine = &amp;pLineInfo-&gt;aLine[nLine]; <br>             PDSFIELD pField = pTable[pLine-&gt;uStruct].pFields + pLine-&gt;uField; <br> <br>             //if (pv-&gt;wHit == HTLABEL) <br>             //   { <br>             //   } <br> <br>             if ((pField-&gt;fmt &amp; IS_EDIT) &amp;&amp; pv-&gt;hMenu) <br>                { <br>                pv-&gt;nHitLine = nLine; <br>                ClientToScreen (hWnd, &amp;pt); <br>                TrackPopupMenu (pv-&gt;hMenu, <br>                               #if (WINVER &gt;= 0x400) <br>                                TPM_TOPALIGN | <br>                               #endif <br>                                TPM_LEFTALIGN | TPM_RIGHTBUTTON, <br>                                pt.x, pt.y, <br>                                0, <br>                                hWnd, <br>                                NULL); <br>                } <br>            } <br>         break; <br> <br>         } <br> <br>      case WM_COMMAND: <br>         lRet = ViewCommands (hWnd, wParam, lParam); <br>         break; <br> <br>      case WM_SIZE: <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br>         UpdateScrollRanges (pv, hWnd); <br>         break; <br> <br>      case WM_KEYDOWN: <br>         { <br>         int  nNewPos = -1; <br> <br>         switch (LOWORD(wParam)) <br>            { <br>            case VK_UP: <br>               nNewPos = pv-&gt;ptVisible.y - pv-&gt;cyLine; <br>               break; <br> <br>            case VK_DOWN: <br>               nNewPos = pv-&gt;ptVisible.y + pv-&gt;cyLine; <br>               break; <br> <br>            case VK_PRIOR: <br>               nNewPos = pv-&gt;ptVisible.y - (pv-&gt;cyWnd - pv-&gt;cyLine); <br>               break; <br> <br>            case VK_NEXT: <br>               nNewPos = pv-&gt;ptVisible.y + (pv-&gt;cyWnd - pv-&gt;cyLine); <br>               break; <br>            } <br> <br>         if (nNewPos != -1) <br>            { <br>            nNewPos = min (nNewPos, pv-&gt;sScroll.cy); <br>            nNewPos = max (nNewPos, 0); <br>            ScrollWindow (hWnd, 0, pv-&gt;ptVisible.y - nNewPos, NULL, NULL); <br>            pv-&gt;ptVisible.y = nNewPos; <br>            SetScrollPos (hWnd, SB_VERT, pv-&gt;ptVisible.y, TRUE); <br>            } <br>         break; <br>         } <br> <br>     case WM_VSCROLL: <br>         { <br>         int  nPos; <br>         int  nNewPos = -1; <br>         WORD wScrollCode; <br> <br>         wScrollCode = LOWORD (wParam); <br>         nPos        = (int)HIWORD (wParam); <br>       <br>         switch (wScrollCode) <br>            { <br>            case SB_LINEUP: <br>               nNewPos = pv-&gt;ptVisible.y - pv-&gt;cyLine; <br>               break; <br> <br>            case SB_LINEDOWN: <br>               nNewPos = pv-&gt;ptVisible.y + pv-&gt;cyLine; <br>               break; <br> <br>            case SB_PAGEUP: <br>               nNewPos = pv-&gt;ptVisible.y - (pv-&gt;cyWnd - pv-&gt;cyLine); <br>               break; <br> <br>            case SB_PAGEDOWN: <br>               nNewPos = pv-&gt;ptVisible.y + (pv-&gt;cyWnd - pv-&gt;cyLine); <br>               break; <br> <br>            case SB_THUMBPOSITION: <br>               nNewPos = nPos - (nPos % pv-&gt;cyLine); <br>               break; <br>            } <br> <br> <br>         if (nNewPos != -1) <br>            { <br>            nNewPos = min (nNewPos, pv-&gt;sScroll.cy); <br>            nNewPos = max (nNewPos, 0); <br>            ScrollWindow (hWnd, 0, pv-&gt;ptVisible.y - nNewPos, NULL, NULL); <br>            pv-&gt;ptVisible.y = nNewPos; <br>            SetScrollPos (hWnd, SB_VERT, pv-&gt;ptVisible.y, TRUE); <br>            } <br>         break; <br>         } <br> <br>      case WM_ERASEBKGND: <br>         { <br>         RECT rc; <br>         lRet = DefWindowProc (hWnd, wMsgID, wParam, lParam); <br> <br>         GetClientRect (hWnd, &amp;rc); <br>         //rc.left = pv-&gt;wLabelWidth + 3; <br>         //TrideeWellShadow ( (HDC)wParam, &amp;rc); <br> <br>         SetTextColor ( (HDC)wParam, RGB (0,0,128)); <br>         //SetBkColor ( (HDC)wParam, GetSysColor (COLOR_BTNFACE)); <br> <br>         //rc.left = 0; <br>         rc.right = pv-&gt;wLabelWidth; <br>         //TrideeWellShadow ( (HDC)wParam, &amp;rc); <br>         if (pv-&gt;hFontLabel) <br>            SelectObject ((HDC)wParam, pv-&gt;hFontLabel); <br> <br>         DrawDsLabels ((HDC)wParam, <br>                       pv-&gt;vi.pTable, <br>                       pv-&gt;pLineInfo, <br>                       &amp;rc, <br>                       pv-&gt;ptVisible); <br>         break; <br>         } <br> <br>      case WM_PAINT: <br>         { <br>         PAINTSTRUCT ps;           // structure for BeginPaint <br>         HDC         hDC;          // DC to draw info into <br>         RECT        rcClip;       // clip rect for drawing <br> <br>         // and draw the info into our client area <br>         // <br>         hDC = BeginPaint (hWnd, &amp;ps); <br>         GetClientRect (hWnd, &amp;rcClip); <br>         rcClip.left += pv-&gt;wLabelWidth + 5; <br> <br>         if (pv-&gt;hFontData) <br>            SelectObject (hDC, pv-&gt;hFontData); <br>         SetTextColor (hDC, GetSysColor (COLOR_WINDOWTEXT)); <br>         SetBkColor (hDC, GetSysColor (COLOR_WINDOW)); <br> <br>         DrawDsData (hDC, <br>                     pv-&gt;vi.pTable, <br>                     pv-&gt;pLineInfo, <br>                     &amp;rcClip, <br>                     pv-&gt;ptVisible); <br> <br>         EndPaint (hWnd, &amp;ps); <br>         break; <br>         } <br> <br>      case WM_CREATE: <br>         { <br>         HDC               hDC; <br>         char              sz[120]; <br>         LPCREATESTRUCT    lpCreate = (LPCREATESTRUCT)lParam; <br>         POINT             pt = {0,0}; <br> <br>         pv = LocalAlloc (LPTR, sizeof(VIEWSTATE)); <br>         if (!pv) <br>            return -1; <br>         SetWindowLong (hWnd, GWL_USERDATA, (LONG)pv); <br> <br>         // init local state information <br>         // <br>         pv-&gt;pLineInfo = AllocDsLineInfo (1000); <br>         //pv-&gt;hBrFace = TrideeCreate (hWnd); <br>          //CreateFontIndirect (&amp;lfMain); <br>         pv-&gt;hFontLabel = GetStockObject (DEFAULT_GUI_FONT); <br>         pv-&gt;hFontData  = GetStockObject (ANSI_FIXED_FONT); <br> <br>         pv-&gt;hMenu = CreatePopupMenu (); <br>         //AppendMenuItem (pv-&gt;hMenu, &amp;mii); <br>         AppendMenu (pv-&gt;hMenu, MF_STRING, IDM_OBJEDIT, "&amp;Edit..."); <br>         AppendMenu (pv-&gt;hMenu, MF_STRING, IDM_EDITCOPY, "&amp;Copy"); <br>         AppendMenu (pv-&gt;hMenu, MF_STRING, IDM_EDITPASTE, "&amp;Paste"); <br> <br>         // get init stuff from last parameter (if possible) <br>         // <br>        #ifdef USE_MDI <br>         { <br>         LPMDICREATESTRUCT lpMcs; <br>         lpMcs = (LPMDICREATESTRUCT) (lpCreate-&gt;lpCreateParams); <br>         lpMcs-&gt;x = lpMcs-&gt;y = CW_USEDEFAULT; <br>         lpMcs-&gt;cx = lpMcs-&gt;cy = CW_USEDEFAULT; <br>         if (lpMcs-&gt;lParam) <br>            pv-&gt;vi = *(PVIEWINIT)lpMcs-&gt;lParam; <br>         } <br>        #else <br>         if (lpCreate-&gt;lpCreateParams) <br>            pv-&gt;vi = *(PVIEWINIT)(lpCreate-&gt;lpCreateParams); <br>        #endif <br> <br>         hDC = GetDC (hWnd); <br>         if (pv-&gt;hFontLabel) <br>            SelectObject (hDC, pv-&gt;hFontLabel); <br> <br>         GetViewExtent (hDC, <br>                        &amp;pv-&gt;vi, <br>                        pv-&gt;pLineInfo, <br>                        &amp;pv-&gt;sLabel, <br>                        &amp;pv-&gt;sTotal); <br> <br>         pv-&gt;cyLine = pv-&gt;pLineInfo-&gt;cyLine; <br>         pv-&gt;wLabelWidth = pv-&gt;sLabel.cx + 16; <br>         ReleaseDC (hWnd, hDC); <br> <br>         pv-&gt;hCurEdge = LoadCursor (lpCreate-&gt;hInstance, <br>                                    MAKEINTRESOURCE (IDC_EDGE)); <br> <br>         wsprintf (sz, "%s:%08lxx", <br>                   pv-&gt;vi.pTable[pv-&gt;vi.uStruct].pszName, <br>                   pv-&gt;vi.lpData); <br> <br>         SetWindowText (hWnd, sz); <br>          <br>         break; <br>         } <br> <br>      case WM_DESTROY: <br>         { <br>         //TrideeDestroy (hWnd); <br> <br>         // delete font if not using stock object <br>         //DeleteObject (pv-&gt;hFontLabel); <br> <br>         break;            // return FALSE; <br>         } <br> <br>      default: <br>         lRet = DefProc (hWnd, wMsgID, wParam, lParam); <br>      } <br> <br>   return lRet; <br>   } <br> <br> <br>/*+ DrawDragEdge <br> * <br> * <br> *-=================================================================*/ <br> <br>VOID WINAPI DrawDragEdge (HWND hWnd, LPPOINT lppt, LPPOINT lpptLastEdge) <br>   { <br>   HDC  hDC; <br>   RECT rc; <br> <br>   hDC = GetDC (hWnd); <br> <br>   GetClientRect (hWnd, &amp;rc); <br> <br>   if (lpptLastEdge) <br>      PatBlt (hDC, lpptLastEdge-&gt;x, rc.top, 3, rc.bottom - rc.top, PATINVERT); <br> <br>   if (lppt) <br>      { <br>      PatBlt (hDC, lppt-&gt;x, rc.top, 3, rc.bottom - rc.top, PATINVERT); <br>      if (lpptLastEdge) <br>         *lpptLastEdge = *lppt; <br>      } <br> <br>   ReleaseDC (hWnd, hDC); <br>   } </code></pre>
<p>&nbsp;</p></body>
</HTML>
