<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WAVEFILE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2583"></a>WAVEFILE.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *  WAVEFILE.C <br> * <br> *  An implementation in C of an AVI File Handler to read standard windows <br> *  WAV files as if they were an AVI file with one audio stream. <br> * <br> ***************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;vfw.h&gt; <br>#include "MulDiv32.h" <br>#include "wavefile.h" <br> <br>#define formtypeWAVEmmioFOURCC('W', 'A', 'V', 'E') <br>#define ckidWAVEFORMATmmioFOURCC('f', 'm', 't', ' ') <br>#define ckidWAVEDATAmmioFOURCC('d', 'a', 't', 'a') <br> <br>LPSTR FAR FileName(LPCSTR lszPath); <br>// <br>// Function prototypes and Vtbl for the Unknown interface <br>// <br>STDMETHODIMP WaveUnknownQueryInterface(LPUNKNOWN pu, REFIID iid, void FAR* FAR* ppv); <br>STDMETHODIMP_(ULONG) WaveUnknownAddRef(LPUNKNOWN pu); <br>STDMETHODIMP_(ULONG) WaveUnknownRelease(LPUNKNOWN pu); <br> <br>IUnknownVtbl UnknownVtbl = { <br>WaveUnknownQueryInterface, <br>WaveUnknownAddRef, <br>WaveUnknownRelease <br>}; <br> <br>// <br>// Function prototypes and Vtbl for the AVIFile interface <br>// <br>STDMETHODIMP WaveFileQueryInterface(PAVIFILE pf, REFIID iid, void FAR* FAR* ppv); <br>STDMETHODIMP_(ULONG) WaveFileAddRef(PAVIFILE pf); <br>STDMETHODIMP_(ULONG) WaveFileRelease(PAVIFILE pf); <br>STDMETHODIMP WaveFileInfo(PAVIFILE pf, AVIFILEINFOW FAR * pfi, LONG lSize); <br>STDMETHODIMP WaveFileGetStream(PAVIFILE pf, PAVISTREAM FAR * ppavi, DWORD fccType, LONG lParam); <br>STDMETHODIMP WaveFileCreateStream(PAVIFILE pf, PAVISTREAM FAR *ppstream, AVISTREAMINFOW FAR *psi); <br>STDMETHODIMP WaveFileWriteData(PAVIFILE pf, DWORD ckid, LPVOID lpData, LONG cbData); <br>STDMETHODIMP WaveFileReadData(PAVIFILE pf, DWORD ckid, LPVOID lpData, LONG FAR *lpcbData); <br>STDMETHODIMP WaveFileEndRecord(PAVIFILE pf); <br>STDMETHODIMP WaveFileDeleteStream(PAVIFILE pf, DWORD fccType, LONG lParam); <br> <br> <br>IAVIFileVtbl FileVtbl = { <br>WaveFileQueryInterface, <br>WaveFileAddRef, <br>WaveFileRelease, <br>WaveFileInfo, <br>WaveFileGetStream, <br>WaveFileCreateStream, <br>WaveFileWriteData, <br>WaveFileReadData, <br>WaveFileEndRecord, <br>WaveFileDeleteStream <br>}; <br> <br> <br>STDMETHODIMP WavePersistQueryInterface(LPPERSISTFILE pf, REFIID iid, void FAR* FAR* ppv); <br>STDMETHODIMP_(ULONG) WavePersistAddRef(LPPERSISTFILE pf); <br>STDMETHODIMP_(ULONG) WavePersistRelease(LPPERSISTFILE pf); <br>STDMETHODIMP WavePersistGetClassID (LPPERSISTFILE ppf, LPCLSID lpClassID); <br>STDMETHODIMP WavePersistIsDirty (LPPERSISTFILE ppf); <br>STDMETHODIMP WavePersistLoad (LPPERSISTFILE ppf, <br>      LPCOLESTR lpszFileName, DWORD grfMode); <br>STDMETHODIMP WavePersistSave (LPPERSISTFILE ppf, <br>      LPCOLESTR lpszFileName, BOOL fRemember); <br>STDMETHODIMP WavePersistSaveCompleted (LPPERSISTFILE ppf, <br>       LPCOLESTR lpszFileName); <br>STDMETHODIMP WavePersistGetCurFile (LPPERSISTFILE ppf, <br>    LPOLESTR FAR * lplpszFileName); <br> <br> <br>IPersistFileVtbl PersistVtbl = { <br>WavePersistQueryInterface, <br>WavePersistAddRef, <br>WavePersistRelease, <br>WavePersistGetClassID, <br>WavePersistIsDirty, <br>WavePersistLoad, <br>WavePersistSave, <br>WavePersistSaveCompleted, <br>WavePersistGetCurFile <br>}; <br> <br>// <br>// Function prototypes and Vtbl for the AVIStream interface <br>// <br>STDMETHODIMP WaveStreamQueryInterface(PAVISTREAM ps, REFIID riid, LPVOID FAR* ppvObj); <br>STDMETHODIMP WaveStreamCreate(PAVISTREAM ps, LONG lParam1, LONG lParam2); <br>STDMETHODIMP_(ULONG) WaveStreamAddRef(PAVISTREAM ps); <br>STDMETHODIMP_(ULONG) WaveStreamRelease(PAVISTREAM ps); <br>STDMETHODIMP WaveStreamInfo(PAVISTREAM ps, AVISTREAMINFOW FAR * psi, LONG lSize); <br>STDMETHODIMP_(LONG) WaveStreamFindSample(PAVISTREAM ps, LONG lPos, LONG lFlags); <br>STDMETHODIMP WaveStreamReadFormat(PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG FAR *lpcbFormat); <br>STDMETHODIMP WaveStreamSetFormat(PAVISTREAM ps, LONG lPos, LPVOID lpFormat, LONG cbFormat); <br>STDMETHODIMP WaveStreamRead(PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpBuffer, LONG cbBuffer, LONG FAR * plBytes,LONG FAR * plSamples); <br>STDMETHODIMP WaveStreamWrite(PAVISTREAM ps, LONG lStart, LONG lSamples, LPVOID lpData, LONG cbData, DWORD dwFlags, LONG FAR *plSampWritten, LONG FAR *plBytesWritten); <br>STDMETHODIMP WaveStreamDelete(PAVISTREAM ps, LONG lStart, LONG lSamples); <br>STDMETHODIMP WaveStreamReadData(PAVISTREAM ps, DWORD fcc, LPVOID lp,LONG FAR *lpcb); <br>STDMETHODIMP WaveStreamWriteData(PAVISTREAM ps, DWORD fcc, LPVOID lp,LONG cb); <br>STDMETHODIMP WaveStreamSetInfo(PAVISTREAM ps, AVISTREAMINFOW FAR * psi, LONG lSize); <br> <br>IAVIStreamVtbl StreamVtbl = { <br>WaveStreamQueryInterface, <br>WaveStreamAddRef, <br>WaveStreamRelease, <br>WaveStreamCreate, <br>WaveStreamInfo, <br>WaveStreamFindSample, <br>WaveStreamReadFormat, <br>WaveStreamSetFormat, <br>WaveStreamRead, <br>WaveStreamWrite, <br>WaveStreamDelete, <br>WaveStreamReadData, <br>WaveStreamWriteData, <br>WaveStreamSetInfo <br>}; <br> <br> <br>#if !defined UNICODE <br> <br>int LoadUnicodeString(HINSTANCE hinst, UINT wID, LPWSTR lpBuffer, int cchBuffer) <br>{ <br>    char    ach[128]; <br>    int    i; <br> <br>    i = LoadString(hinst, wID, ach, sizeof(ach)); <br> <br>    if (i &gt; 0) <br>MultiByteToWideChar(CP_ACP, 0, ach, -1, lpBuffer, cchBuffer); <br> <br>    return i; <br>} <br> <br>#else <br>#define LoadUnicodeString   LoadString <br>#endif <br> <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>/*--------*/ <br> <br>UINTuUseCount;// the reference count for our objects <br>UINTuLockCount;// our lock count for LockServer <br> <br>/*--------*/ <br> <br>// <br>// Create a new instance.  Since this is a C implementation we have to <br>// allocate space for our structure ourselves. <br>// <br>HRESULT WaveFileCreate( <br>IUnknown FAR*pUnknownOuter, <br>REFIIDriid, <br>void FAR* FAR*ppv) <br>{ <br>IUnknown FAR*pUnknown; <br>LPWAVESTUFFpWaveStuff; <br>HRESULThresult; <br> <br>// Allocate space for our structure <br>pWaveStuff = (LPWAVESTUFF)GlobalAllocPtr(GMEM_MOVEABLE, <br>sizeof(WAVESTUFF)); <br>if (!pWaveStuff) <br>return ResultFromScode(E_OUTOFMEMORY); <br> <br>// Initialize the Vtbls <br>pWaveStuff-&gt;AVIFile = &amp;FileVtbl; <br>pWaveStuff-&gt;AVIStream = &amp;StreamVtbl; <br>pWaveStuff-&gt;Unknown = &amp;UnknownVtbl; <br>pWaveStuff-&gt;Persist = &amp;PersistVtbl; <br> <br>// Set up our controlling object <br>pUnknown = (IUnknown FAR *)&amp;pWaveStuff-&gt;Unknown; <br>if (pUnknownOuter) <br>pWaveStuff-&gt;pUnknownOuter = pUnknownOuter; <br>else <br>pWaveStuff-&gt;pUnknownOuter =(IUnknown FAR *)&amp;pWaveStuff-&gt;Unknown; <br> <br>// Initial the things in our structure <br>pWaveStuff-&gt;refs = 0; <br>pWaveStuff-&gt;hmmio = NULL; <br>pWaveStuff-&gt;lpFormat = NULL; <br>pWaveStuff-&gt;cbFormat = 0L; <br>pWaveStuff-&gt;fDirty = FALSE; <br>pWaveStuff-&gt;extra.lp = NULL; <br>pWaveStuff-&gt;extra.cb = 0L; <br> <br>// Call our Query interface to increment our ref count and get a <br>// pointer to our interface to return. <br>hresult = pUnknown-&gt;lpVtbl-&gt;QueryInterface(pUnknown, riid, ppv); <br> <br>if (FAILED(GetScode(hresult))) <br>GlobalFreePtr(pWaveStuff); <br>return hresult; <br>} <br> <br>/*--------*/ <br> <br>// <br>// Query interface from all three interfaces comes here.  We support the <br>// Unknown interface, AVIStream and AVIFile. <br>// <br>STDMETHODIMP WaveUnknownQueryInterface( <br>LPUNKNOWNpu, <br>REFIIDiid, <br>void FAR* FAR*ppv) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_UNKNOWN(pu); <br> <br>if (IsEqualIID(iid, &amp;IID_IUnknown)) <br>*ppv = (LPVOID)&amp;pWaveStuff-&gt;Unknown; <br>else if (IsEqualIID(iid, &amp;IID_IAVIFile)) <br>*ppv = (LPVOID)&amp;pWaveStuff-&gt;AVIFile; <br>else if (IsEqualIID(iid, &amp;IID_IAVIStream)) <br>*ppv = (LPVOID)&amp;pWaveStuff-&gt;AVIStream; <br>else if (IsEqualIID(iid, &amp;IID_IPersistFile)) <br>*ppv = (LPVOID)&amp;pWaveStuff-&gt;Persist; <br>else <br>return ResultFromScode(E_NOINTERFACE); <br>pu-&gt;lpVtbl-&gt;AddRef(pu); <br>return NOERROR; <br>} <br> <br>/*--------*/ <br> <br>// <br>// Increase our reference count.  AddRef for all three interfaces comes here. <br>// <br>STDMETHODIMP_(ULONG) WaveUnknownAddRef( <br>LPUNKNOWNpu) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_UNKNOWN(pu); <br> <br>uUseCount++; <br>return ++pWaveStuff-&gt;refs; <br>} <br> <br>/*--------*/ <br> <br>// <br>// Decrease our reference count.  Release for all three interfaces comes here. <br>// <br>STDMETHODIMP_(ULONG) WaveUnknownRelease( <br>LPUNKNOWN pu) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_UNKNOWN(pu); <br> <br>uUseCount--; <br> <br>// <br>// Ref count is zero.  Close the file.  If we've been writing to it, it's <br>// clean-up time! <br>// <br>if (!--p-&gt;refs) { <br>LONG lRet = AVIERR_OK; <br> <br>if (p-&gt;fDirty) { <br>MMCKINFO ckRIFF; <br>MMCKINFO ck; <br> <br>mmioSeek(p-&gt;hmmio, 0, SEEK_SET); <br> <br>/* create the output file RIFF chunk of form type 'WAVE' */ <br>ckRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>ckRIFF.cksize = 0L;// let MMIO figure out ck. size <br>if (mmioCreateChunk(p-&gt;hmmio, &amp;ckRIFF, MMIO_CREATERIFF) != 0) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br> <br>ck.ckid = mmioFOURCC('f', 'm', 't', ' '); <br>ck.cksize = p-&gt;cbFormat;// we know the size of this ck. <br>if (mmioCreateChunk(p-&gt;hmmio, &amp;ck, 0) != 0) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br> <br>if (mmioWrite(p-&gt;hmmio, (HPSTR) p-&gt;lpFormat, p-&gt;cbFormat) != p-&gt;cbFormat) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br> <br>/* ascend out of the 'fmt' chunk, back into 'RIFF' chunk */ <br>if (mmioAscend(p-&gt;hmmio, &amp;ck, 0) != 0) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br> <br>// If there was extra stuff here, we need to fill it! <br>if (mmioSeek(p-&gt;hmmio, 0, SEEK_CUR) <br>+ 2 * (LRESULT)sizeof(DWORD) <br>!= (LRESULT) p-&gt;ckData.dwDataOffset) { <br>/* create the 'data' chunk that holds the waveform samples */ <br>ck.ckid = mmioFOURCC('J', 'U', 'N', 'K'); <br>ck.cksize = 0; <br>if (mmioCreateChunk(p-&gt;hmmio, &amp;ck, 0) != 0) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br> <br>mmioSeek(p-&gt;hmmio, <br>p-&gt;ckData.dwDataOffset - 2 * sizeof(DWORD), <br>SEEK_SET); <br> <br>if (mmioAscend(p-&gt;hmmio, &amp;ck, 0) != 0) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br>} <br> <br>/* create the 'data' chunk that holds the waveform samples */ <br>ck.ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>ck.cksize = p-&gt;ckData.cksize; <br>if (mmioCreateChunk(p-&gt;hmmio, &amp;ck, 0) != 0) <br>goto ERROR_CANNOT_WRITE;// cannot write file, probably <br> <br>mmioSeek(p-&gt;hmmio, p-&gt;ckData.cksize, SEEK_CUR); <br> <br>mmioAscend(p-&gt;hmmio, &amp;ck, 0); <br> <br>if (p-&gt;extra.cb) { <br>if (mmioWrite(p-&gt;hmmio, (HPSTR) p-&gt;extra.lp, p-&gt;extra.cb) != p-&gt;extra.cb) <br>goto ERROR_CANNOT_WRITE; <br>} <br> <br>if (mmioAscend(p-&gt;hmmio, &amp;ckRIFF, 0) != 0) <br>goto ERROR_CANNOT_WRITE; <br> <br>if (mmioFlush(p-&gt;hmmio, 0) != 0) <br>goto ERROR_CANNOT_WRITE; <br>} <br> <br> <br>goto success; <br> <br>ERROR_CANNOT_WRITE: <br>lRet = AVIERR_FILEWRITE; <br> <br>success: <br>if (p-&gt;hmmio) <br>mmioClose(p-&gt;hmmio, 0); <br> <br>if (p-&gt;lpFormat) <br>GlobalFreePtr(p-&gt;lpFormat); <br> <br>// Free the memory for our structure. <br>GlobalFreePtr(p); <br>return 0; <br>} <br>return p-&gt;refs; <br>} <br> <br> <br>// <br>// Use our controlling object to call QueryInterface on Unknown <br>// <br>STDMETHODIMP WaveFileQueryInterface( <br>PAVIFILEpf, <br>REFIIDiid, <br>void FAR* FAR*ppv) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_FILE(pf); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;QueryInterface( <br>pWaveStuff-&gt;pUnknownOuter, iid, ppv); <br>} <br> <br>/*--------*/ <br> <br>// <br>// Use our controlling object to call AddRef on Unknown <br>// <br>STDMETHODIMP_(ULONG) WaveFileAddRef( <br>PAVIFILEpf) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_FILE(pf); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;AddRef( <br>pWaveStuff-&gt;pUnknownOuter); <br>} <br> <br>/*--------*/ <br> <br>// <br>// Use our controlling object to call Release on Unknown <br>// <br>STDMETHODIMP_(ULONG) WaveFileRelease( <br>PAVIFILEpf) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_FILE(pf); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;Release( <br>pWaveStuff-&gt;pUnknownOuter); <br>} <br> <br>/*--------*/ <br> <br> <br>// <br>// Use our controlling object to call QueryInterface on Unknown <br>// <br>STDMETHODIMP WavePersistQueryInterface( <br>LPPERSISTFILEppf, <br>REFIIDiid, <br>void FAR* FAR*ppv) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_PERSIST(ppf); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;QueryInterface( <br>pWaveStuff-&gt;pUnknownOuter, iid, ppv); <br>} <br> <br>/*--------*/ <br> <br>// <br>// Use our controlling object to call AddRef on Unknown <br>// <br>STDMETHODIMP_(ULONG) WavePersistAddRef( <br>LPPERSISTFILEppf) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_PERSIST(ppf); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;AddRef( <br>pWaveStuff-&gt;pUnknownOuter); <br>} <br> <br>/*--------*/ <br> <br>// <br>// Use our controlling object to call Release on Unknown <br>// <br>STDMETHODIMP_(ULONG) WavePersistRelease( <br>LPPERSISTFILEppf) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_PERSIST(ppf); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;Release( <br>pWaveStuff-&gt;pUnknownOuter); <br>} <br> <br>/*--------*/ <br> <br> <br> <br>// <br>// Use our controlling object to call QueryInterface on Unknown <br>// <br>STDMETHODIMP WaveStreamQueryInterface( <br>PAVISTREAMps, <br>REFIIDiid, <br>void FAR* FAR*ppv) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_STREAM(ps); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;QueryInterface( <br>pWaveStuff-&gt;pUnknownOuter, iid, ppv); <br>} <br> <br>/*--------*/ <br> <br>// <br>// Use our controlling object to call AddRef on Unknown <br>// <br>STDMETHODIMP_(ULONG) WaveStreamAddRef( <br>PAVISTREAMps) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_STREAM(ps); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;AddRef( <br>pWaveStuff-&gt;pUnknownOuter); <br>} <br> <br>/*--------*/ <br> <br>// <br>// Use our controlling object to call Release on Unknown <br>// <br>STDMETHODIMP_(ULONG) WaveStreamRelease( <br>PAVISTREAMps) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pWaveStuff = WAVESTUFF_FROM_STREAM(ps); <br> <br>return pWaveStuff-&gt;pUnknownOuter-&gt;lpVtbl-&gt;Release( <br>pWaveStuff-&gt;pUnknownOuter); <br>} <br> <br>/*--------*/ <br> <br>#define SLASH(c)((c) == '/' || (c) == '\\') <br> <br>/*--------------------------------------------------------------+ <br>| FileName  - return a pointer to the filename part of szPath   | <br>|             with no preceding path.                           | <br>+--------------------------------------------------------------*/ <br>LPSTR FAR FileName( <br>LPCSTR lszPath) <br>{ <br>LPCSTR lszCur; <br> <br>for (lszCur = lszPath + lstrlen(lszPath); lszCur &gt; lszPath &amp;&amp; !SLASH(*lszCur) &amp;&amp; *lszCur != ':';) <br>lszCur = AnsiPrev(lszPath, lszCur); <br>if (lszCur == lszPath) <br>return (LPSTR)lszCur; <br>else <br>return (LPSTR)(lszCur + 1); <br>} <br> <br>/*--------*/ <br> <br>// <br>// The Open Method for our File interface - Open a WAVE file <br>// <br>STDMETHODIMP WaveFileOpen( <br>PAVIFILE pf, <br>LPCSTR szFile, <br>UINT mode) <br>{ <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br>UINTui; <br>charach[80]; <br> <br>// !!! Assumptions about the AVIFILE.DLL (which calls us): <br>// We will only see READWRITE mode, never only WRITE mode. <br> <br>// <br>// try to open the actual file, first with share, then without. <br>// You may need to use specific flags in order to open a file <br>// that's already open by somebody else. <br>// <br> <br>// If the first attempt fails, no system error box, please. <br>ui = SetErrorMode(SEM_NOOPENFILEERRORBOX); <br>p-&gt;hmmio = mmioOpen((LPSTR) szFile, NULL, MMIO_ALLOCBUF | mode); <br>if (!p-&gt;hmmio &amp;&amp; ((mode &amp; MMIO_RWMODE) == OF_READ)) { <br>// if the open fails, try again without the share flags. <br>mode &amp;= ~(MMIO_SHAREMODE); <br>p-&gt;hmmio = mmioOpen((LPSTR) szFile, NULL, MMIO_ALLOCBUF | mode); <br>} <br>SetErrorMode(ui); <br> <br>// <br>// Now set up our structure <br>// <br> <br>p-&gt;mode = mode; <br> <br>if (!p-&gt;hmmio) <br>goto error; <br> <br>_fmemset(&amp;p-&gt;avistream, 0, sizeof(p-&gt;avistream)); <br> <br>// If this is defined, we pretend that the data is at FPSHACK "frames" <br>// per second in the main header, otherwise we use the sample <br>// rate of the audio, which looks somewhat strange in MPlayer. <br>#define FPSHACK1000 <br> <br>_fmemset(&amp;p-&gt;avihdr, 0, sizeof(p-&gt;avihdr)); <br> <br>#ifdef FPSHACK <br>// <br>// Initialize our AVIFILEHEADER <br>// <br>p-&gt;avihdr.dwRate = FPSHACK; <br>p-&gt;avihdr.dwScale = 1; <br>#endif <br> <br>p-&gt;avihdr.dwStreams = 1; <br>LoadUnicodeString(ghModule, IDS_FILETYPE, p-&gt;avihdr.szFileType, <br>sizeof(p-&gt;avihdr.szFileType)); <br> <br>// <br>// Initialize our AVISTREAMHEADER <br>// <br>LoadString(ghModule, IDS_STREAMNAME, ach, sizeof(ach)); <br>#if !defined UNICODE <br>{ <br>    char    achTemp[64]; <br> <br>    wsprintf(achTemp, ach, FileName(szFile)); <br> <br>    MultiByteToWideChar(CP_ACP, 0, achTemp, -1, <br>p-&gt;avistream.szName, 64); <br>} <br>#else <br>wsprintf(p-&gt;avistream.szName, ach, FileName(szFile)); <br>#endif <br> <br>if (mode &amp; OF_CREATE) {// Brand new file <br>p-&gt;avistream.fccType = streamtypeAUDIO; <br>p-&gt;avistream.fccHandler = 0; <br>p-&gt;avistream.dwFlags = 0; <br>p-&gt;avistream.wPriority = 0; <br>p-&gt;avistream.wLanguage = 0; <br>p-&gt;avistream.dwInitialFrames = 0; <br>p-&gt;avistream.dwScale = 0; <br>p-&gt;avistream.dwRate = 0; <br>p-&gt;avistream.dwStart = 0; <br>p-&gt;avistream.dwLength = 0; <br>p-&gt;avistream.dwSuggestedBufferSize = 0; <br>p-&gt;avistream.dwSampleSize = 0; <br> <br>p-&gt;fDirty = TRUE; <br> <br>} else {// read the existing file to get info <br> <br>MMCKINFOck; <br>MMCKINFOckRIFF; <br>/* Read RIFF chunk */ <br>if (mmioDescend(p-&gt;hmmio, &amp;ckRIFF, NULL, 0) != 0) <br>goto error; <br> <br>if (ckRIFF.ckid != FOURCC_RIFF) <br>goto error; <br> <br>if (ckRIFF.fccType != formtypeWAVE) <br>goto error; <br> <br>/* Read WAVE format chunk */ <br>ck.ckid = ckidWAVEFORMAT; <br>if (FindChunkAndKeepExtras(&amp;p-&gt;extra, p-&gt;hmmio, &amp;ck, &amp;ckRIFF, MMIO_FINDCHUNK)) <br>goto error; <br> <br>p-&gt;cbFormat = ck.cksize; <br>p-&gt;lpFormat = (LPWAVEFORMAT) GlobalAllocPtr(GMEM_MOVEABLE, ck.cksize); <br> <br>if (p-&gt;lpFormat == NULL) <br>goto error; <br> <br>if (mmioRead(p-&gt;hmmio, <br>(HPSTR) p-&gt;lpFormat, <br>(LONG)ck.cksize) != (LONG)ck.cksize) <br>goto error; <br> <br> <br>/* Ascend out of stream header */ <br>if (mmioAscend(p-&gt;hmmio, &amp;ck, 0) != 0) <br>goto error; <br> <br>/* Find big data chunk */ <br>p-&gt;ckData.ckid = ckidWAVEDATA; <br>if (FindChunkAndKeepExtras(&amp;p-&gt;extra, p-&gt;hmmio, &amp;p-&gt;ckData, &amp;ckRIFF, MMIO_FINDCHUNK)) <br>goto error; <br> <br>p-&gt;fDirty = FALSE; <br> <br>p-&gt;avistream.fccType = streamtypeAUDIO; <br>p-&gt;avistream.fccHandler = 0; <br>p-&gt;avistream.dwFlags = 0; <br>p-&gt;avistream.wPriority = 0; <br>p-&gt;avistream.wLanguage = 0; <br>p-&gt;avistream.dwInitialFrames = 0; <br>p-&gt;avistream.dwScale = p-&gt;lpFormat-&gt;nBlockAlign; <br>p-&gt;avistream.dwRate = p-&gt;lpFormat-&gt;nAvgBytesPerSec; <br>p-&gt;avistream.dwStart = 0; <br>p-&gt;avistream.dwLength = p-&gt;ckData.cksize / p-&gt;lpFormat-&gt;nBlockAlign; <br>p-&gt;avistream.dwSuggestedBufferSize = 0; <br>p-&gt;avistream.dwSampleSize = p-&gt;lpFormat-&gt;nBlockAlign; <br> <br>#ifdef FPSHACK <br>p-&gt;avihdr.dwLength = MulDiv32(p-&gt;avistream.dwLength, <br>p-&gt;avistream.dwScale * FPSHACK, <br>p-&gt;avistream.dwRate); <br>#else <br>p-&gt;avihdr.dwScale = 1; <br>p-&gt;avihdr.dwRate = p-&gt;lpFormat-&gt;nSamplesPerSec; <br>p-&gt;avihdr.dwLength = MulDiv32(p-&gt;ckData.cksize, <br>p-&gt;lpFormat-&gt;nSamplesPerSec, <br>p-&gt;lpFormat-&gt;nAvgBytesPerSec); <br>#endif <br> <br> <br>mmioAscend(p-&gt;hmmio, &amp;p-&gt;ckData, 0); <br> <br>// Read extra data at end of file.... <br>if (FindChunkAndKeepExtras(&amp;p-&gt;extra, p-&gt;hmmio, &amp;ckRIFF, &amp;ck, 0) <br>!= AVIERR_OK) <br>goto error; <br>} <br> <br>// <br>// all done return success. <br>// <br>return ResultFromScode(0); // success <br> <br>error: <br>return ResultFromScode(AVIERR_FILEREAD); <br>} <br> <br> <br>// <br>// Get a stream from the file... Each WAVE file has exactly 1 audio stream. <br>// <br>STDMETHODIMP WaveFileGetStream( <br>PAVIFILE pf, <br>PAVISTREAM FAR * ppavi, <br>DWORD fccType, <br>LONG lParam) <br>{ <br>int iStreamWant; <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br> <br>iStreamWant = (int)lParam; <br> <br>if (p-&gt;lpFormat == NULL) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>// We only support one stream <br>if (iStreamWant != 0) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>// We only support audio streams <br>if (fccType &amp;&amp; fccType != streamtypeAUDIO) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>// increase the reference count <br>p-&gt;AVIStream-&gt;AddRef((PAVISTREAM)&amp;p-&gt;AVIStream); <br> <br>// Return a pointer to our stream Vtbl <br>*ppavi = (PAVISTREAM) &amp;(p-&gt;AVIStream); <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>STDMETHODIMP WaveFileDeleteStream(PAVIFILE pf, DWORD fccType, LONG lParam) <br>{ <br>int iStreamWant; <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br> <br>iStreamWant = (int)lParam; <br> <br>if (p-&gt;lpFormat == NULL) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>// We only support one stream <br>if (iStreamWant != 0) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br>// We only support audio streams <br>if (fccType &amp;&amp; fccType != streamtypeAUDIO) <br>return ResultFromScode(AVIERR_BADPARAM); <br> <br> <br>GlobalFreePtr(p-&gt;lpFormat); <br>p-&gt;lpFormat = NULL; <br> <br>return NOERROR; <br>} <br> <br>// <br>// We don't support the Save Method of the File Interface (We don't save) <br>// <br>STDMETHODIMP WaveFileSave( <br>PAVIFILE pf, <br>LPCSTR szFile, <br>AVICOMPRESSOPTIONS FAR *lpOptions, <br>AVISAVECALLBACK lpfnCallback) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>// <br>// Method to create a stream in a WAVE file.  We only support this for blank <br>// WAVE files. <br>// <br>STDMETHODIMP WaveFileCreateStream( <br>PAVIFILE pf, <br>PAVISTREAM FAR *ppstream, <br>AVISTREAMINFOW FAR *psi) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br> <br>// We can't add a second stream to a file <br>if (p-&gt;lpFormat) <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br> <br>// We only like audio.... <br>if (psi-&gt;fccType != streamtypeAUDIO) <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br> <br>// Increase our reference count. <br>p-&gt;AVIStream-&gt;AddRef((PAVISTREAM)&amp;p-&gt;AVIStream); <br> <br>p-&gt;cbFormat = 0; <br>p-&gt;lpFormat = NULL; <br> <br>// Return a pointer to our stream Vtbl. <br>*ppstream = (PAVISTREAM) &amp;(p-&gt;AVIStream); <br> <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br>// <br>// The WriteData Method of the File interface <br>// <br>STDMETHODIMP WaveFileWriteData( <br>PAVIFILE pf, <br>DWORD ckid, <br>LPVOID lpData, <br>LONG cbData) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br> <br>// Write the data in the Wave File. <br>return ResultFromScode(WriteExtra(&amp;p-&gt;extra, ckid, lpData, cbData)); <br>} <br> <br>// <br>// The ReadData Method of the File interface <br>// <br>STDMETHODIMP WaveFileReadData( <br>PAVIFILE pf, <br>DWORD ckid, <br>LPVOID lpData, <br>LONG FAR *lpcbData) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br> <br>// Read the data from the file <br>return ResultFromScode(ReadExtra(&amp;p-&gt;extra, ckid, lpData, lpcbData)); <br>} <br> <br>// <br>// The EndRecord Method of the File interface.. this doesn't need to do <br>// anything.. (no concept of interleaving or packaging streams) <br>// <br>STDMETHODIMP WaveFileEndRecord( <br>PAVIFILE pf) <br>{ <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>// <br>// The Info Method of the File interface <br>// <br>STDMETHODIMP WaveFileInfo( <br>PAVIFILE pf, <br>AVIFILEINFOW FAR * pfi, <br>LONG lSize) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_FILE(pf); <br> <br>// Return an AVIFILEHEADER. <br>hmemcpy(pfi, &amp;p-&gt;avihdr, min(lSize, sizeof(p-&gt;avihdr))); <br>return 0; <br>} <br> <br> <br> <br>// <br>// The Create Method of the Stream interface. We can't create streams that <br>// aren't attached to the file. <br>// <br>STDMETHODIMP WaveStreamCreate( <br>PAVISTREAMps, <br>LONG lParam1, <br>LONG lParam2) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br>// <br>// The FindSample Method of the Stream interface <br>// <br>STDMETHODIMP_(LONG) WaveStreamFindSample( <br>PAVISTREAMps, <br>LONG lPos, LONG lFlags) <br>{ <br>if (lFlags &amp; FIND_FORMAT) { <br>if ((lFlags &amp; FIND_NEXT) &amp;&amp; lPos &gt; 0) <br>return -1; <br>else <br>return 0; <br>} <br> <br>return lPos; <br>} <br> <br> <br>// <br>// The ReadFormat Method of the Stream interface <br>// <br>STDMETHODIMP WaveStreamReadFormat( <br>PAVISTREAMps, <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG FAR *lpcbFormat) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps); <br> <br>// No buffer to fill in, this means return the size needed. <br>if (lpFormat == NULL || *lpcbFormat == 0) { <br>*lpcbFormat = p-&gt;cbFormat; <br>return 0; <br>} <br> <br>// Give them the WAVE format. <br>hmemcpy(lpFormat, p-&gt;lpFormat, min(*lpcbFormat, p-&gt;cbFormat)); <br> <br>// Our buffer is too small <br>if (*lpcbFormat &lt; p-&gt;cbFormat) <br>return ResultFromScode(AVIERR_BUFFERTOOSMALL); <br> <br>*lpcbFormat = p-&gt;cbFormat; <br> <br>return 0; <br>} <br> <br>// <br>// The Info Method of the Stream interface <br>// <br>STDMETHODIMP WaveStreamInfo( <br>PAVISTREAMps, <br>AVISTREAMINFOW FAR * psi, <br>LONG lSize) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps); <br> <br>// give them an AVISTREAMINFO <br>hmemcpy(psi, &amp;p-&gt;avistream, min(lSize, sizeof(p-&gt;avistream))); <br>return 0; <br>} <br> <br> <br>STDMETHODIMP WaveStreamSetInfo(PAVISTREAM ps, AVISTREAMINFOW FAR * psi, LONG lSize) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>/////////////////////////////////////////////////////////////////////////// <br> <br>/* <br>invalid lPos return error <br> <br>if lPos + lSamples is invalid trim lSamples to fit. <br> <br>lpBuffer == NULL <br> <br>cbBuffer == 0 &amp;&amp; lSamples &gt; 0 <br>return size of lSamples sample. <br>else <br>return the exactly the number of bytes and sample <br>you would have read if lpBuffer was not zero. <br> <br>NOTE return means fill in *plBytes and *plSamples. <br> <br>lpBuffer != NULL <br> <br>lSamples == -1      read convenient amount (just fill buffer) <br>lSamples == 0       fill buffer with as many samples that will fit. <br>lSamples &gt;  0       read lSamples (or as much will fit in cbBuffer) <br> <br>fill in *plBytes   with bytes actualy read <br>fill in *plSamples with samples actualy read <br> <br>*/ <br> <br>// <br>// The Read Method for the Stream Interface - Read some wave data <br>STDMETHODIMP WaveStreamRead( <br>PAVISTREAMps, <br>LONGlStart, <br>LONGlSamples, <br>LPVOIDlpBuffer, <br>LONGcbBuffer, <br>LONG FAR *plBytes, <br>LONG FAR *plSamples) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps); <br> <br>LONGlSampleSize; <br>LONGlSeek; <br>LONGlRead; <br> <br>// Invalid position <br>if (lStart &lt; 0 || lStart &gt; (LONG) p-&gt;avistream.dwLength) { <br>ack: <br>if (plBytes) <br>*plBytes = 0; <br>if (plSamples) <br>*plSamples = 0; <br>return 0; <br>} <br> <br>// Can't read quite this much data <br>if (lSamples + lStart &gt; (LONG) p-&gt;avistream.dwLength) <br>lSamples = p-&gt;avistream.dwLength - lStart; <br> <br>lSampleSize = p-&gt;avistream.dwSampleSize; <br> <br>// We have fixed-length samples <br> <br>if (lpBuffer == NULL) { <br>if (cbBuffer &gt; 0 &amp;&amp; lSamples &gt; 0) <br>// Trim how many samples we'd really be able to read <br>lSamples = min(lSamples, cbBuffer / lSampleSize); <br>else if (lSamples &lt;= 0) <br>    // Use as many as will fit <br>lSamples = cbBuffer / lSampleSize; <br>} else { <br>if (lSamples &gt; 0) <br>// Trim how many samples we'd really be able to read <br>lSamples = min(lSamples, cbBuffer / lSampleSize); <br>else <br>// Use as many as will fit <br>lSamples = cbBuffer / lSampleSize; <br>} <br> <br>// <br>// a NULL buffer means return the size buffer needed to read <br>// the given sample. <br>// <br>if (lpBuffer == NULL || cbBuffer == 0) { <br>if (plBytes) <br>*plBytes = lSamples * lSampleSize;; <br>if (plSamples) <br>*plSamples = lSamples; <br>return 0; <br>} <br> <br>// Buffer too small! <br>if (cbBuffer &lt; lSampleSize) <br>goto ack; <br> <br>// Seek and read <br> <br>cbBuffer = lSamples * lSampleSize; <br> <br>lSeek = p-&gt;ckData.dwDataOffset + lSampleSize * lStart; <br>lRead = lSamples * lSampleSize; <br> <br>if (mmioSeek(p-&gt;hmmio, lSeek, SEEK_SET) != lSeek) <br>goto ack; <br> <br>if (mmioRead(p-&gt;hmmio, (HPSTR) lpBuffer, lRead) != lRead) <br>goto ack; <br> <br>// <br>// success return number of bytes and number of samples read <br>// <br>if (plBytes) <br>*plBytes = lRead; <br> <br>if (plSamples) <br>*plSamples = lSamples; <br> <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>// <br>// The SetFormat Method of the Stream interface- called on an empty WAVE file <br>// before writing data to it. <br>// <br>STDMETHODIMP WaveStreamSetFormat( <br>PAVISTREAM ps, <br>LONG lPos, <br>LPVOID lpFormat, <br>LONG cbFormat) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps); </code></pre>
<p>
</p>
<pre><code><br>// We can only do this to an empty wave file <br>if (p-&gt;lpFormat) { <br>if (cbFormat != p-&gt;cbFormat || <br>_fmemcmp(lpFormat, p-&gt;lpFormat, (int) cbFormat)) <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br> <br>return NOERROR; <br>} <br> <br>// Go ahead and set the format! <br> <br>p-&gt;cbFormat = cbFormat; <br>p-&gt;lpFormat = (LPWAVEFORMAT) GlobalAllocPtr(GMEM_MOVEABLE, cbFormat); <br> <br>if (p-&gt;lpFormat == NULL) <br>return ResultFromScode(AVIERR_MEMORY); <br> <br>hmemcpy(p-&gt;lpFormat, lpFormat, cbFormat); <br> <br>p-&gt;ckData.dwDataOffset = cbFormat + 7 * sizeof(DWORD); <br>p-&gt;ckData.cksize = 0; <br>p-&gt;avistream.dwScale = p-&gt;lpFormat-&gt;nBlockAlign; <br>p-&gt;avistream.dwRate = p-&gt;lpFormat-&gt;nAvgBytesPerSec; <br>p-&gt;avistream.dwLength = 0; <br>p-&gt;avistream.dwSampleSize = p-&gt;lpFormat-&gt;nBlockAlign; <br> <br>#ifndef FPSHACK <br>p-&gt;avihdr.dwScale = 1; <br>p-&gt;avihdr.dwRate = p-&gt;lpFormat-&gt;nSamplesPerSec; <br>#endif <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br>// <br>// The Write Method of the Stream interface - write some wave data <br>// <br>STDMETHODIMP WaveStreamWrite( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples, <br>LPVOID lpData, <br>LONG cbData, <br>DWORD dwFlags, <br>LONG FAR *plSampWritten, <br>LONG FAR *plBytesWritten) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF p = WAVESTUFF_FROM_STREAM(ps); <br> <br>if ((p-&gt;mode &amp; (OF_WRITE | OF_READWRITE)) == 0) <br>return ResultFromScode(AVIERR_READONLY); <br> <br>// &lt; 0 means "at end" <br>if (lStart &lt; 0) <br>// !!! <br>lStart = p-&gt;avistream.dwStart + p-&gt;avistream.dwLength; <br> <br>p-&gt;fDirty = TRUE; <br> <br>mmioSeek(p-&gt;hmmio, <br>p-&gt;ckData.dwDataOffset + <br>lStart * p-&gt;avistream.dwSampleSize, <br>SEEK_SET); <br> <br>if (mmioWrite(p-&gt;hmmio, (HPSTR) lpData, cbData) != cbData) <br>return ResultFromScode(AVIERR_FILEWRITE); <br> <br>p-&gt;avistream.dwLength = max((LONG) p-&gt;avistream.dwLength, <br>lStart + lSamples); <br> <br>p-&gt;ckData.cksize = max(p-&gt;ckData.cksize, <br>lStart * p-&gt;avistream.dwSampleSize + cbData); <br> <br>#ifdef FPSHACK <br>p-&gt;avihdr.dwLength = MulDiv32(p-&gt;avistream.dwLength * FPSHACK, <br>p-&gt;avistream.dwScale, <br>p-&gt;avistream.dwRate); <br>#else <br>p-&gt;avihdr.dwLength = MulDiv32(p-&gt;ckData.cksize, <br>p-&gt;lpFormat-&gt;nSamplesPerSec, <br>p-&gt;lpFormat-&gt;nAvgBytesPerSec); <br>#endif <br> <br> <br>if (plSampWritten) <br>*plSampWritten = lSamples; <br> <br>if (plBytesWritten) <br>*plBytesWritten = cbData; <br> <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br>// <br>// The Delete Method of the Stream interface - we don't cut from wave files <br>// <br>STDMETHODIMP WaveStreamDelete( <br>PAVISTREAM ps, <br>LONG lStart, <br>LONG lSamples) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br>// <br>// We also don't support ReadData and WriteData for the Stream Interface <br>// <br> <br>STDMETHODIMP WaveStreamReadData( <br>PAVISTREAM ps, <br>DWORD fcc, <br>LPVOID lp, <br>LONG FAR *lpcb) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>STDMETHODIMP WaveStreamWriteData( <br>PAVISTREAM ps, <br>DWORD fcc, <br>LPVOID lp, <br>LONG cb) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br> <br>STDMETHODIMP WaveFileReserved( <br>PAVIFILE pf) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>STDMETHODIMP WaveStreamReserved( <br>PAVISTREAM ps) <br>{ <br>return ResultFromScode(AVIERR_UNSUPPORTED); <br>} <br> <br>/*      -       -       -       -       -       -       -       -       */ <br> <br>// *** IPersist methods *** <br>STDMETHODIMP WavePersistGetClassID (LPPERSISTFILE ppf, LPCLSID lpClassID) <br>{ <br>    // Get a pointer to our structure <br>    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf); <br> <br>    hmemcpy(lpClassID, &amp;CLSID_AVIWaveFileReader, sizeof(CLSID)); <br>    return NOERROR; <br>} <br> <br>// *** IPersistFile methods *** <br>STDMETHODIMP WavePersistIsDirty (LPPERSISTFILE ppf) <br>{ <br>    // Get a pointer to our structure <br>    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf); <br> <br>    return pfile-&gt;fDirty ? NOERROR : ResultFromScode(S_FALSE); <br>} <br> <br>STDMETHODIMP WavePersistLoad (LPPERSISTFILE ppf, <br>      LPCOLESTR lpszFileName, DWORD grfMode) <br>{ <br>    // Get a pointer to our structure <br>    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf); <br> <br> <br>#if !defined UNICODE <br>    char    achTemp[256]; <br> <br>    // Internally, we're using ANSI, but this interface is defined <br>    // to always accept UNICODE under WIN32, so we have to convert. <br>    WideCharToMultiByte(CP_ACP, 0, lpszFileName, -1, <br>achTemp, sizeof(achTemp), NULL, NULL); <br>#else <br>    #define achTemplpszFileName <br>#endif <br> <br>    return WaveFileOpen((PAVIFILE) &amp;pfile-&gt;AVIFile, achTemp, (UINT) grfMode); <br>} <br> <br>STDMETHODIMP WavePersistSave (LPPERSISTFILE ppf, <br>      LPCOLESTR lpszFileName, BOOL fRemember) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf); <br> <br> <br>    return ResultFromScode(E_FAIL); <br>} <br> <br>STDMETHODIMP WavePersistSaveCompleted (LPPERSISTFILE ppf, <br>       LPCOLESTR lpszFileName) <br>{ <br>// Get a pointer to our structure <br>LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf); <br> <br> <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP WavePersistGetCurFile (LPPERSISTFILE ppf, <br>    LPOLESTR FAR * lplpszFileName) <br>{ <br>    // Get a pointer to our structure <br>    LPWAVESTUFF pfile = WAVESTUFF_FROM_PERSIST(ppf); <br> <br>    return ResultFromScode(E_FAIL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
