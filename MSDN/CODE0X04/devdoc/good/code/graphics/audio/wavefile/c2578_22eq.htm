<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTRA.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2582"></a>EXTRA.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/**************************************************************************** <br> * <br> *  EXTRA.C <br> * <br> *  Routines for reading and managing extra chunks in a RIFF file besides <br> *  the actual stream data. <br> * <br> ***************************************************************************/ <br> <br>#define   NOCOMPMAN <br>#define   NODRAWDIB <br>#define   NOVIDEO <br>#define   NOAVIFMT <br>#define   NOMMREG <br>#define   NOMCIWND <br>#define   NOAVICAP <br>#define   NOMSACM <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;stdarg.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "extra.h" <br> <br>// <br>// Search the EXTRA chunks for a particular chunk ID and return it's data. <br>// <br>HRESULT ReadExtra( <br>LPEXTRA extra, <br>DWORD ckid, <br>LPVOID lpData, <br>LONG FAR *lpcbData) <br>{ <br> <br>#define lpdw ((DWORD FAR *) lp) <br> <br>LPBYTE lp = (LPBYTE) extra-&gt;lp; <br>LONG cb = extra-&gt;cb; <br> <br>while (cb &gt; 0) { <br>if (lpdw[0] == ckid) { <br>if (!lpData) { <br>*lpcbData = lpdw[1]; <br>return AVIERR_OK; <br>} <br> <br>hmemcpy(lpData, lp + 2 * sizeof(DWORD), min((LONG) lpdw[1], *lpcbData)); <br>*lpcbData = lpdw[1]; <br> <br>return ResultFromScode(AVIERR_OK); <br>} <br>cb -= lpdw[1] + sizeof(DWORD) * 2; <br>lp += lpdw[1] + sizeof(DWORD) * 2; <br>} <br>#undef lpdw <br>*lpcbData = 0; <br>return ResultFromScode(AVIERR_NODATA); <br>} <br> <br>// <br>// Write data for the given chunk ID into the extra data <br>// <br>HRESULT WriteExtra( <br>LPEXTRA extra, <br>DWORD ckid, <br>LPVOID lpData, <br>LONG cbData) <br>{ <br>LPBYTE lp; <br> <br>cbData += sizeof(DWORD) * 2; <br>if (extra-&gt;lp) { <br>lp = (LPBYTE) GlobalReAllocPtr(extra-&gt;lp, extra-&gt;cb + cbData, GMEM_MOVEABLE); <br>} else { <br>lp = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE, cbData); <br>} <br> <br>if (!lp) <br>return ResultFromScode(AVIERR_MEMORY); <br> <br>// build RIFF chunk in block <br>((DWORD FAR *) (lp + extra-&gt;cb))[0] = ckid; <br>((DWORD FAR *) (lp + extra-&gt;cb))[1] = cbData - sizeof(DWORD) * 2; <br> <br>hmemcpy(lp + extra-&gt;cb + sizeof(DWORD) * 2, <br>lpData, <br>cbData - sizeof(DWORD) * 2); <br>extra-&gt;lp = lp; <br>extra-&gt;cb += cbData; <br> <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br>// <br>// Reads the data from the given chunk into the EXTRA pile. <br>// <br>HRESULT ReadIntoExtra( <br>LPEXTRA extra, <br>HMMIO hmmio, <br>MMCKINFO FAR * lpck) <br>{ <br>LPBYTElp; <br>LONGcbData = lpck-&gt;cksize + sizeof(DWORD) * 2; <br> <br>if (extra-&gt;lp) { <br>lp = (LPBYTE) GlobalReAllocPtr(extra-&gt;lp, extra-&gt;cb + cbData, GMEM_MOVEABLE); <br>} else { <br>lp = (LPBYTE) GlobalAllocPtr(GMEM_MOVEABLE, cbData); <br>} <br> <br>if (!lp) <br>return ResultFromScode(AVIERR_MEMORY); <br> <br>// build RIFF chunk in block <br>((DWORD FAR *) (lp + extra-&gt;cb))[0] = lpck-&gt;ckid; <br>((DWORD FAR *) (lp + extra-&gt;cb))[1] = lpck-&gt;cksize; <br> <br>cbData += (cbData &amp; 1); <br> <br>mmioSeek(hmmio, lpck-&gt;dwDataOffset, SEEK_SET); <br>if (mmioRead(hmmio, (HPSTR) lp + extra-&gt;cb + sizeof(DWORD) * 2, lpck-&gt;cksize) != <br>(LONG) lpck-&gt;cksize) <br>return ResultFromScode(AVIERR_FILEREAD); <br> <br>extra-&gt;lp = lp; <br>extra-&gt;cb += cbData; <br> <br>return ResultFromScode(AVIERR_OK); <br>} <br> <br> <br>// <br>// Look for a specific chunk.  Throw all of the extra stuff we didn't want <br>// into the EXTRA pile. <br>// <br>LONG FindChunkAndKeepExtras( <br>LPEXTRA extra, HMMIO hmmio, <br>MMCKINFO FAR* lpck, <br>MMCKINFO FAR* lpckParent, <br>UINT uFlags) <br>{ <br>FOURCCckidFind;// chunk ID to find (or NULL) <br>FOURCCfccTypeFind;// form/list type to find (or NULL) <br>LONGlRet; <br> <br>/* figure out what chunk id and form/list type to search for */ <br>if (uFlags &amp; MMIO_FINDCHUNK) <br>ckidFind = lpck-&gt;ckid, fccTypeFind = 0; <br>else if (uFlags &amp; MMIO_FINDRIFF) <br>ckidFind = FOURCC_RIFF, fccTypeFind = lpck-&gt;fccType; <br>else if (uFlags &amp; MMIO_FINDLIST) <br>ckidFind = FOURCC_LIST, fccTypeFind = lpck-&gt;fccType; <br>else <br>ckidFind = fccTypeFind = (FOURCC) -1; // keep looking indefinitely <br> <br>for (;;) { <br>lRet = mmioDescend(hmmio, lpck, lpckParent, 0); <br>if (lRet) { <br>if (uFlags == 0 &amp;&amp; lRet == MMIOERR_CHUNKNOTFOUND) <br>lRet = 0; <br>return lRet; <br>} <br> <br>if ((!ckidFind || lpck-&gt;ckid == ckidFind) &amp;&amp; <br>(!fccTypeFind || lpck-&gt;fccType == fccTypeFind)) <br>return 0; <br> <br>lRet = (LONG) ReadIntoExtra(extra, hmmio, lpck); <br>if (lRet != AVIERR_OK) <br>return lRet; <br>} <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
