<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2514"></a>DISPLAY.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>/* <br> * display.c - Functions to manage the display buffer and convert a <br> *      MIDI event to a text string for display. <br> * <br> *      The display buffer is filled by the application's WndProc() <br> *      function when it receives an MM_MIDIINPUT message.  This message <br> *      is sent by the low-level callback function upon reception of a <br> *      MIDI event.  When the display buffer becomes full, newly added <br> *      events overwrite the oldest events in the buffer. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "midimon.h" <br>#include "circbuf.h" <br>#include "display.h" <br> <br>/* MIDI event-name strings <br> */ <br>char szEventNames[8][24] = <br>{ <br>                    "Note Off", <br>                    "Note On", <br>                    "Key Aftertouch", <br>                    "Control Change", <br>                    "Program Change", <br>                    "Channel Aftertouch", <br>                    "Pitch Bend", <br>                    "System Message" <br>}; <br> <br>char szSysMsgNames[16][24] = <br>{ <br>                    "System Exclusive", <br>                    "MTC Quarter Frame", <br>                    "Song Position Pointer", <br>                    "Song Select", <br>                    "Undefined", <br>                    "Undefined", <br>                    "Tune Request", <br>                    "System Exclusive End", <br>                    "Timing Clock", <br>                    "Undefined", <br>                    "Start", <br>                    "Continue", <br>                    "Stop", <br>                    "Undefined", <br>                    "Active Sensing", <br>                    "System Reset" <br>}; <br> <br>/* GetDisplayText - Takes a MIDI event and creates a text string for display. <br> * <br> * Params:  npText - Points to a string that the function fills. <br> *          lpEvent - Points to a MIDI event. <br> * <br> * Return:  The number of characters in the text string pointed to by npText. <br> */ <br>int GetDisplayText(NPSTR npText, LPEVENT lpEvent) <br>{ <br>    BYTE bStatus, bStatusRaw, bChannel, bData1, bData2; <br>    char chErr; <br>    DWORD dwTimestamp; <br> <br>    bStatusRaw  = LOBYTE(LOWORD(lpEvent-&gt;data)); <br>    bStatus     = (BYTE) (bStatusRaw &amp; (BYTE) 0xf0); <br>    bChannel    = (BYTE) (bStatusRaw &amp; (BYTE) 0x0f); <br>    bData1      = HIBYTE(LOWORD(lpEvent-&gt;data)); <br>    bData2      = LOBYTE(HIWORD(lpEvent-&gt;data)); <br>    dwTimestamp = lpEvent-&gt;timestamp; <br>    chErr       = (lpEvent-&gt;fdwEvent &amp; EVNT_F_ERROR) ? '*' : ' '; <br> <br>    switch(bStatus) <br>    { <br>        /* Three byte events <br>         */ <br>        case NOTEOFF: <br>        case NOTEON: <br>        case KEYAFTERTOUCH: <br>        case CONTROLCHANGE: <br>        case PITCHBEND: <br>            /* A note on with a velocity of 0 is a note off <br>             */ <br>            if((bStatus == NOTEON) &amp;&amp; (bData2 == 0)) <br>                bStatus = NOTEOFF; <br> <br>            return(sprintf(npText, FORMAT3, dwTimestamp, bStatusRaw, bData1, <br>                    bData2, bChannel, chErr, &amp;szEventNames[(bStatus-0x80) &gt;&gt; 4][0])); <br>            break; <br> <br>        /* Two byte events <br>         */ <br>        case PROGRAMCHANGE: <br>        case CHANAFTERTOUCH: <br>            return(sprintf(npText, FORMAT2, dwTimestamp, bStatusRaw, bData1, <br>                    bChannel, chErr, &amp;szEventNames[(bStatus-0x80) &gt;&gt; 4][0])); <br>            break; <br> <br>        /* MIDI system events (0xf0 - 0xff) <br>         */ <br>        case SYSTEMMESSAGE: <br>            switch(bStatusRaw) <br>            { <br>                /* Two byte system events <br>                 */ <br>                case MTCQUARTERFRAME: <br>                case SONGSELECT: <br>                    return(sprintf(npText, FORMAT2X, dwTimestamp, bStatusRaw, <br>                            bData1, <br>                            chErr,  <br>                            &amp;szSysMsgNames[(bStatusRaw &amp; 0x0f)][0])); <br>                    break; <br> <br>                /* Three byte system events <br>                 */ <br>                case SONGPOSPTR: <br>                    return(sprintf(npText, FORMAT3X, dwTimestamp, bStatusRaw, <br>                            bData1, bData2, chErr,  <br>                            &amp;szSysMsgNames[(bStatusRaw &amp; 0x0f)][0])); <br>                    break; <br> <br>                /* One byte system events <br>                 */ <br>                default: <br>                    return(sprintf(npText, FORMAT1X, dwTimestamp, bStatusRaw, <br>                            chErr, &amp;szSysMsgNames[(bStatusRaw &amp; 0x0f)][0])); <br>                    break; <br>            } <br>            break; <br> <br>        default: <br>            return(sprintf(npText, FORMAT3X, dwTimestamp, bStatusRaw, bData1, <br>                    bData2, chErr, GetStringRes(IDS_UNKNOWN_EVENT))); <br>            break; <br>    } <br>} <br> <br>/* AddDisplayEvent - Puts a MIDI event in the display buffer.  The display <br> *      buffer is a circular buffer.  Once it is full, newly added events <br> *      overwrite the oldest events in the buffer. <br> * <br> * Params:  lpBuf - Points to the display buffer. <br> *          lpEvent - Points to a MIDI event. <br> * <br> * Return:  void <br> */ <br>void AddDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent) <br>{ <br>    /* Put the event in the buffer, bump the head pointer and byte count. <br>     */ <br>    *lpBuf-&gt;lpHead = *lpEvent; <br>    ++lpBuf-&gt;lpHead; <br>    ++lpBuf-&gt;dwCount; <br> <br>    /* Wrap pointer, if necessary. <br>     */ <br>    if(lpBuf-&gt;lpHead == lpBuf-&gt;lpEnd) <br>        lpBuf-&gt;lpHead = lpBuf-&gt;lpStart; <br> <br>    /* A full buffer is a full buffer, no more. <br>     */ <br>    lpBuf-&gt;dwCount = min(lpBuf-&gt;dwCount, lpBuf-&gt;dwSize); <br>} <br> <br> <br>/* GetDisplayEvent - Retrieves a MIDI event from the display buffer. <br> *      Unlike the input buffer, the event is not removed from the buffer. <br> * <br> * Params:  lpBuf - Points to the display buffer. <br> *          lpEvent - Points to an EVENT structure that is filled with <br> *              the retrieved MIDI event. <br> *          wNum - Specifies which event to retrieve. <br> * <br> * Return:  void <br> */ <br>void GetDisplayEvent(LPDISPLAYBUFFER lpBuf, LPEVENT lpEvent, DWORD wNum) <br>{ <br>    LPEVENT lpFirstEvent, lpThisEvent; <br> <br>    /* Get pointer to the first (oldest) event in buffer. <br>     */ <br>    if(lpBuf-&gt;dwCount &lt; lpBuf-&gt;dwSize)      // buffer is not yet full <br>        lpFirstEvent = lpBuf-&gt;lpStart; <br> <br>    else                                    // buffer is full <br>        lpFirstEvent = lpBuf-&gt;lpHead; <br> <br>    /* Offset pointer to point to requested event; wrap pointer. <br>     */ <br>    lpThisEvent = lpFirstEvent + wNum; <br>    if(lpThisEvent &gt;= lpBuf-&gt;lpEnd) <br>        lpThisEvent = lpBuf-&gt;lpStart + (lpThisEvent - lpBuf-&gt;lpEnd); <br> <br>    /* Get the requested event. <br>     */ <br>    *(lpEvent) = *lpThisEvent; <br>} <br> <br>/* AllocDisplayBuffer - Allocates memory for a DISPLAYBUFFER structure <br> *      and a buffer of the specified size.  Each memory block is allocated <br> *      with GlobalAlloc() using GMEM_SHARE and GMEM_MOVEABLE flags and <br> *      locked with GlobalLock().  Since this buffer is only accessed by the <br> *      application, and not the low-level callback function, it does not <br> *      have to be page locked. <br> * <br> * Params:  dwSize - The size of the buffer, in events. <br> * <br> * Return:  A pointer to a DISPLAYBUFFER structure identifying the <br> *      allocated display buffer.  NULL if the buffer could not be allocated. <br>*/ <br>LPDISPLAYBUFFER AllocDisplayBuffer(DWORD dwSize) <br>{ <br>    HANDLE hMem; <br>    LPDISPLAYBUFFER lpBuf; <br>    LPEVENT lpMem; <br> <br>    /* Allocate and lock a DISPLAYBUFFER structure. <br>     */ <br>    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, <br>                       (DWORD)sizeof(DISPLAYBUFFER)); <br>    if(hMem == NULL) <br>        return NULL; <br> <br>    lpBuf = (LPDISPLAYBUFFER)GlobalLock(hMem); <br>    if(lpBuf == NULL) <br>    { <br>        GlobalFree(hMem); <br>        return NULL; <br>    } <br> <br>    /* Save the handle. <br>     */ <br>    lpBuf-&gt;hSelf = hMem; <br> <br>    /* Allocate and lock memory for the actual buffer. <br>     */ <br>    hMem = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, dwSize * sizeof(EVENT)); <br>    if(hMem == NULL) <br>    { <br>        GlobalUnlock(lpBuf-&gt;hSelf); <br>        GlobalFree(lpBuf-&gt;hSelf); <br>        return NULL; <br>    } <br>    lpMem = (LPEVENT)GlobalLock(hMem); <br>    if(lpMem == NULL) <br>    { <br>        GlobalFree(hMem); <br>        GlobalUnlock(lpBuf-&gt;hSelf); <br>        GlobalFree(lpBuf-&gt;hSelf); <br>        return NULL; <br>    } <br> <br>    /* Set up the DISPLAYBUFFER structure. <br>     */ <br>    lpBuf-&gt;hBuffer = hMem; <br>    lpBuf-&gt;wError = 0; <br>    lpBuf-&gt;dwSize = dwSize; <br>    lpBuf-&gt;dwCount = 0L; <br>    lpBuf-&gt;lpStart = lpMem; <br>    lpBuf-&gt;lpEnd = lpMem + dwSize; <br>    lpBuf-&gt;lpTail = lpMem; <br>    lpBuf-&gt;lpHead = lpMem; <br> <br>    return lpBuf; <br>} <br> <br>/* FreeDisplayBuffer - Frees the memory for a display buffer. <br> * <br> * Params:  lpBuf - Points to the DISPLAYBUFFER to be freed. <br> * <br> * Return:  void <br> */ <br>void FreeDisplayBuffer(LPDISPLAYBUFFER lpBuf) <br>{ <br>    HANDLE hMem; <br> <br>    /* Unlock and free the buffer itself. <br>     */ <br>    GlobalUnlock(lpBuf-&gt;hBuffer); <br>    GlobalFree(lpBuf-&gt;hBuffer); <br> <br>    /* Unlock and free the DISPLAYBUFFER structure. <br>     */ <br>    hMem = lpBuf-&gt;hSelf; <br>    GlobalUnlock(hMem); <br>    GlobalFree(hMem); <br>} <br> <br>/* ResetDisplayBuffer - Empties a display buffer. <br> * <br> * Params:  lpBuf - Points to a display buffer. <br> * <br> * Return:  void <br> */ <br>void ResetDisplayBuffer(LPDISPLAYBUFFER lpBuf) <br>{ <br>    /* Reset the pointers and event count. <br>     */ <br>    lpBuf-&gt;lpHead = lpBuf-&gt;lpStart; <br>    lpBuf-&gt;lpTail = lpBuf-&gt;lpStart; <br>    lpBuf-&gt;dwCount = 0L; <br>    lpBuf-&gt;wError = 0; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
