<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MIDIMON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2520"></a>MIDIMON.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> *  <br> **************************************************************************/ <br> <br>/* midimon.c - WinMain() and WndProc() functions for MIDIMon, along <br> *      with some initialization and error reporting functions. <br> * <br> * MIDIMon is a Windows with Multimedia application that records and displays  <br> *  incoming MIDI information.  It uses a low-level callback function to  <br> *  get timestamped MIDI input.  The callback function puts the incoming <br> *  MIDI event information (source device, timestamp, and raw MIDI <br> *  data) in a circular input buffer and notifies the application by posting  <br> *  a MM_MIDIINPUT message.  When the application processes the MM_MIDIINPUT <br> *  message, it removes the MIDI event from the input buffer and puts it in <br> *  a display buffer.  Information in the display buffer is converted to <br> *  text and displayed in a scrollable window.  Incoming MIDI data can be sent <br> *  to the MIDI Mapper if the user chooses.  Filtering is provided for the <br> *  display buffer, but not for data sent to the Mapper. <br> * <br>  <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "midimon.h" <br>#include "about.h" <br>#include "circbuf.h" <br>#include "display.h" <br>#include "prefer.h" <br>#include "instdata.h" <br>#include "callback.h" <br>#include "filter.h" <br> <br>HANDLE hInst;                           // Instance handle for application <br>char szAppName[20];                     // Application name <br>HWND hMainWnd;                          // Main window handle <br>HMIDIOUT hMapper = 0;                   // Handle to MIDI Mapper <br>UINT wNumDevices = 0; // Number of MIDI input devices opened <br>BOOL bRecordingEnabled = 1;             // Enable/disable recording flag <br>int  nNumBufferLines = 0; // Number of lines in display buffer <br>RECT rectScrollClip;                    // Clipping rectangle for scrolling <br> <br>LPCIRCULARBUFFER lpInputBuffer;         // Input buffer structure <br>LPDISPLAYBUFFER lpDisplayBuffer;        // Display buffer structure <br>PREFERENCES preferences;                // User preferences structure <br>EVENT incomingEvent;                    // Incoming MIDI event structure <br> <br>MIDIINCAPS midiInCaps[MAX_NUM_DEVICES]; // Device capabilities structures <br>HMIDIIN hMidiIn[MAX_NUM_DEVICES];       // MIDI input device handles <br> <br>// Callback instance data pointers <br>LPCALLBACKINSTANCEDATA lpCallbackInstanceData[MAX_NUM_DEVICES]; <br> <br>// Display filter structure <br>FILTER filter = { <br>                    0, 0, 0, 0, 0, 0, 0, 0,  <br>                    0, 0, 0, 0, 0, 0, 0, 0,  <br>                    0, 0, 0, 0, 0, 0, 0, 0,  <br>                    0, 0, 0, 0, 0, 0, 0, 0 <br>                }; <br> <br>// Virtual key to scroll message translation structure <br>KEYTOSCROLL keyToScroll [] = {  <br>                                VK_HOME,  WM_VSCROLL, SB_TOP, <br>                                VK_END,   WM_VSCROLL, SB_BOTTOM, <br>                                VK_PRIOR, WM_VSCROLL, SB_PAGEUP, <br>                                VK_NEXT,  WM_VSCROLL, SB_PAGEDOWN, <br>                                VK_UP,    WM_VSCROLL, SB_LINEUP, <br>                                VK_DOWN,  WM_VSCROLL, SB_LINEDOWN, <br>                                VK_LEFT,  WM_HSCROLL, SB_LINEUP, <br>                                VK_RIGHT, WM_HSCROLL, SB_LINEDOWN  <br>                             }; <br> <br>#define NUMKEYS (sizeof (keyToScroll) / sizeof (keyToScroll[0])) <br> <br> <br>                                                                        //  <br>/* WinMain - Entry point for MIDIMon. <br> */ <br>int PASCAL WinMain(hInstance,hPrevInstance,lpszCmdLine,cmdShow) <br>HINSTANCE hInstance,hPrevInstance; <br>LPSTR lpszCmdLine; <br>int cmdShow; <br>{ <br>    MSG msg; <br>    UINT  wRtn; <br>    PREFERENCES preferences; <br>    char szErrorText[256]; <br>    unsigned int i; <br> <br>    hInst = hInstance; <br> <br>    /* Get preferred user setup. <br>     */ <br>    getPreferences(&amp;preferences); <br>     <br>    /* Initialize application. <br>     */ <br>    LoadString(hInstance, IDS_APPNAME, szAppName, sizeof(szAppName));  <br>    if (hPrevInstance || !InitFirstInstance(hInstance)) <br>        return 0; <br> <br>    /* Create a display window. <br>     */ <br>    hMainWnd = CreateWindow(szAppName, <br>                        szAppName, <br>                        WS_OVERLAPPEDWINDOW | WS_HSCROLL | WS_VSCROLL, <br>                        preferences.iInitialX, <br>                        preferences.iInitialY, <br>                        preferences.iInitialW, <br>                        preferences.iInitialH, <br>                        (HWND)NULL, <br>                        (HMENU)NULL, <br>                        hInstance, <br>                        (LPSTR)NULL); <br> <br>    if (!hMainWnd) <br>        return 1; <br> <br>    /* Hide scroll bars for now. <br>     */ <br>    SetScrollRange(hMainWnd, SB_VERT, 0, 0, FALSE); <br>    SetScrollRange(hMainWnd, SB_HORZ, 0, 0, FALSE); <br>     <br>    /* Show the display window. <br>     */ <br>    ShowWindow(hMainWnd, cmdShow); <br>    UpdateWindow(hMainWnd); <br>     <br>    /* Get the number of MIDI input devices.  Then get the capabilities of <br>     * each device.  We don't use the capabilities information right now, <br>     * but we could use it to report the name of the device that received <br>     * each MIDI event. <br>     */ <br>    wNumDevices = midiInGetNumDevs(); <br>    if (!wNumDevices) { <br>        Error(GetStringRes(IDS_NOMIDIIN)); <br>        PostQuitMessage(0); <br>    } <br>    for (i=0; (i&lt;wNumDevices) &amp;&amp; (i&lt;MAX_NUM_DEVICES); i++) { <br>        wRtn = midiInGetDevCaps(i, (LPMIDIINCAPS) &amp;midiInCaps[i], <br>                                sizeof(MIDIINCAPS)); <br>        if(wRtn) { <br>            midiInGetErrorText(wRtn, (LPSTR)szErrorText,  <br>                               sizeof(szErrorText)); <br>            Error(szErrorText); <br>            Error("midiInGetDevCaps"); <br>        } <br>    } <br> <br>    /* Allocate a circular buffer for low-level MIDI input.  This buffer <br>     * is filled by the low-level callback function and emptied by the <br>     * application when it receives MM_MIDIINPUT messages. <br>     */ <br>    lpInputBuffer = AllocCircularBuffer( <br>                        (DWORD)(INPUT_BUFFER_SIZE * sizeof(EVENT))); <br>    if (lpInputBuffer == NULL) { <br>        Error(GetStringRes(IDS_NOMEM_IBUF)); <br>        return 1; <br>    } <br> <br>    /* Allocate a display buffer.  Incoming events from the circular input <br>     * buffer are put into this buffer for display. <br>     */ <br>    lpDisplayBuffer = AllocDisplayBuffer((DWORD)(DISPLAY_BUFFER_SIZE)); <br>    if (lpDisplayBuffer == NULL) { <br>        Error(GetStringRes(IDS_NOMEM_DBUF)); <br>        FreeCircularBuffer(lpInputBuffer); <br>        return 1; <br>    } <br> <br>    /* Open all MIDI input devices after allocating and setting up <br>     * instance data for each device.  The instance data is used to <br>     * pass buffer management information between the application and <br>     * the low-level callback function.  It also includes a device ID, <br>     * a handle to the MIDI Mapper, and a handle to the application's <br>     * display window, so the callback can notify the window when input <br>     * data is available.  A single callback function is used to service <br>     * all opened input devices. <br>     */ <br>    for (i=0; (i&lt;wNumDevices) &amp;&amp; (i&lt;MAX_NUM_DEVICES); i++) <br>    { <br>        if ((lpCallbackInstanceData[i] = AllocCallbackInstanceData()) == NULL) <br>        { <br>            Error(GetStringRes(IDS_NOMEM)); <br>            FreeCircularBuffer(lpInputBuffer); <br>            FreeDisplayBuffer(lpDisplayBuffer); <br>            return 1; <br>        } <br>        lpCallbackInstanceData[i]-&gt;hWnd = hMainWnd;          <br>        lpCallbackInstanceData[i]-&gt;dwDevice = i; <br>        lpCallbackInstanceData[i]-&gt;lpBuf = lpInputBuffer; <br>        lpCallbackInstanceData[i]-&gt;hMapper = hMapper; <br>         <br>        wRtn = midiInOpen((LPHMIDIIN)&amp;hMidiIn[i], <br>                          i, <br>                          (DWORD)midiInputHandler, <br>                          (DWORD)lpCallbackInstanceData[i], <br>                          CALLBACK_FUNCTION); <br>        if(wRtn) <br>        { <br>            FreeCallbackInstanceData(lpCallbackInstanceData[i]); <br>            midiInGetErrorText(wRtn, (LPSTR)szErrorText, sizeof(szErrorText)); <br>            Error(szErrorText); <br>            wsprintf(szErrorText, "midiInOpen(%u)", i); <br>            Error(szErrorText); <br>        } <br>    } <br> <br>    /* Start MIDI input. <br>     */ <br>    for (i=0; (i&lt;wNumDevices) &amp;&amp; (i&lt;MAX_NUM_DEVICES); i++) { <br>        if (hMidiIn[i]) <br>            midiInStart(hMidiIn[i]); <br>    } <br> <br>    /* Standard Windows message processing loop.  We don't drop out of <br>     * this loop until the user quits the application. <br>     */ <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>    } <br> <br>    /* Stop, reset, close MIDI input.  Free callback instance data. <br>     */ <br>    for (i=0; (i&lt;wNumDevices) &amp;&amp; (i&lt;MAX_NUM_DEVICES); i++) { <br>        if (hMidiIn[i]) { <br>            midiInStop(hMidiIn[i]); <br>            midiInReset(hMidiIn[i]); <br>            midiInClose(hMidiIn[i]); <br>            FreeCallbackInstanceData(lpCallbackInstanceData[i]); <br>        } <br>    } <br> <br>    /* Close the MIDI Mapper, if it's open. <br>     */ <br>    if (hMapper) <br>        midiOutClose(hMapper); <br>     <br>    /* Free input and display buffers. <br>     */ <br>    FreeCircularBuffer(lpInputBuffer); <br>    FreeDisplayBuffer(lpDisplayBuffer); <br> <br>    return (msg.wParam); <br>} <br> <br>                                                                        //  <br>/* WndProc - Main window procedure function. <br> */ <br>LRESULT FAR PASCAL WndProc( <br>  HWND  hWnd, <br>  UINT  message, <br>  WPARAM  wParam, <br>  LPARAM  lParam) <br>{ <br>    PAINTSTRUCT ps; <br>    HFONT hFont; <br>    HBRUSH hBrush; <br>//!!    HPEN hPen; <br>    HDC hDC; <br>    TEXTMETRIC tm; <br>    static BOOL  bWindowCreated = 0; <br>    static int  wChar, hChar; <br>    static int   maxClientWidth; <br>    static int  wClient, hClient; <br>    static int  nVscrollMax = 0; <br>    static int  nHscrollMax = 0; <br>    static int  nVscrollPos = 0; <br>    static int  nHscrollPos = 0; <br>    static int   nNumCharsPerLine = 0; <br>    static int   nNumDisplayLines = 0; <br>    static int   nNumDisplayChars = 0; <br>    BOOL bNeedToUpdate = FALSE; <br>    int  nVscrollInc, nHscrollInc; <br>    int  nPaintBeg, nPaintEnd; <br>    int          i; <br>    SIZE  size; <br>         <br>    char szDisplayTextBuffer[120]; <br> <br>    switch(message) <br>    { <br>        case WM_CREATE: <br>            hDC = GetDC(hWnd); <br> <br>            /* Set the font we want to use. <br>             */ <br>            hFont = GetStockObject(SYSTEM_FIXED_FONT); <br>            SelectObject(hDC, hFont); <br>             <br>            /* Get text metrics and calculate the number of characters <br>             * per line and the maximum width required for the client area. <br>             */ <br>            GetTextMetrics(hDC, &amp;tm); <br>    wChar = tm.tmAveCharWidth; <br>    hChar = tm.tmHeight + tm.tmExternalLeading; <br>    nNumCharsPerLine = strlen(GetStringRes(IDS_LABEL)) - 1; <br> <br>    GetTextExtentPoint(hDC, <br>       szDisplayTextBuffer, <br>       sprintf(szDisplayTextBuffer, GetStringRes(IDS_LABEL)), <br>       &amp;size); <br>    maxClientWidth = size.cx; <br> <br>            ReleaseDC(hWnd, hDC); <br>             <br>            bWindowCreated = 1; <br>            break; <br> <br>        case WM_SIZE: <br>    hClient = (int)HIWORD(lParam); <br>    wClient = (int)LOWORD(lParam); <br> <br>            /* Get new client area and adjust scroll clip rectangle. <br>             */ <br>            GetClientRect(hWnd, (LPRECT)&amp;rectScrollClip); <br>            rectScrollClip.top += hChar; <br>             <br>            /* Calculate new display metrics.  We subtract 1 from <br>             * nNumDisplayLines to allow room for the label line. <br>             */ <br>            nNumDisplayLines = hClient / hChar - 1; <br>            nNumDisplayChars = wClient / wChar; <br> <br>            /* Calculate and set new scroll bar calibrations. <br>             */ <br>    nVscrollMax = max(0, nNumBufferLines - nNumDisplayLines); <br>    nVscrollPos = min(nVscrollPos, nVscrollMax); <br>    nHscrollMax = max(0, nNumCharsPerLine - nNumDisplayChars); <br>    nHscrollPos = min(nHscrollPos, nHscrollMax); <br>            SetScrollRange(hWnd, SB_VERT, 0, nVscrollMax, FALSE); <br>            SetScrollPos(hWnd, SB_VERT, nVscrollPos, TRUE); <br>            SetScrollRange(hWnd, SB_HORZ, 0, nHscrollMax, FALSE); <br>            SetScrollPos(hWnd, SB_HORZ, nHscrollPos, TRUE); <br>            break; <br> <br>        case WM_GETMINMAXINFO: <br>            /* Limit the maximum width of the window. <br>             */ <br>    if(bWindowCreated) { <br>((LPPOINT)lParam)[4].x = maxClientWidth + <br> (2 * GetSystemMetrics(SM_CXFRAME)) + <br> (GetSystemMetrics(SM_CXVSCROLL)); <br>    } <br> <br>  //*((LPWORD)lParam + 8) = maxClientWidth + <br>  // (2 * GetSystemMetrics(SM_CXFRAME)) + <br>  //(GetSystemMetrics(SM_CXVSCROLL)); <br>            break; <br>             <br>        case WM_COMMAND: <br>            /* Process menu messages.  <br>             */ <br>            CommandMsg(hWnd, wParam, lParam);  <br>            break; <br> <br>        case WM_VSCROLL: <br>            /* Determine how much to scroll vertically. <br>             */ <br>    switch (LOWORD(wParam)) <br>            { <br>                case SB_TOP: <br>                    nVscrollInc = -nVscrollPos; <br>                    break; <br>                     <br>                case SB_BOTTOM: <br>                    nVscrollInc = nVscrollMax - nVscrollPos; <br>                    break; <br> <br>                case SB_LINEUP: <br>                    nVscrollInc = -1; <br>                    break; <br> <br>                case SB_LINEDOWN: <br>                    nVscrollInc = 1; <br>                    break; <br> <br>                case SB_PAGEUP: <br>                    nVscrollInc = min (-1, -nNumDisplayLines); <br>                    break; <br> <br>                case SB_PAGEDOWN: <br>    nVscrollInc = max(1, nNumDisplayLines); <br>                    break; <br> <br>                case SB_THUMBTRACK: <br>    nVscrollInc = ((int)HIWORD(wParam) - nVscrollPos); <br>                    break; <br> <br>                default: <br>                    nVscrollInc = 0; <br>             <br>            } <br>             <br>            /* Limit the scroll range and do the scroll.  We use the <br>             * rectScrollClip rectangle because we don't want to scroll <br>             * the entire window, only the part below the display label line. <br>             */ <br>    if(nVscrollInc = max(-nVscrollPos, <br> min(nVscrollInc, <br>     nVscrollMax - nVscrollPos))) <br>            { <br>                nVscrollPos += nVscrollInc; <br>                ScrollWindow(hWnd, 0, -hChar * nVscrollInc, <br>                              (LPRECT)&amp;rectScrollClip, <br>                              (LPRECT)&amp;rectScrollClip); <br>                UpdateWindow(hWnd); <br>                SetScrollPos(hWnd, SB_VERT, nVscrollPos, TRUE); <br>            } <br>            break; <br> <br>        case WM_HSCROLL: <br>            /* Determine how much to scroll horizontally. <br>             */ <br>    switch (LOWORD(wParam)) <br>            { <br>                case SB_LINEUP: <br>                    nHscrollInc = -1; <br>                    break; <br> <br>                case SB_LINEDOWN: <br>                    nHscrollInc = 1; <br>                    break; <br> <br>                case SB_PAGEUP: <br>    nHscrollInc = min(-1, -nNumDisplayChars); <br>                    break; <br> <br>                case SB_PAGEDOWN: <br>    nHscrollInc = max(1, nNumDisplayChars); <br>                    break; <br> <br>                case SB_THUMBTRACK: <br>    nHscrollInc = ((int)HIWORD(wParam) - nHscrollPos); <br>                    break; <br> <br>                default: <br>                    nHscrollInc = 0; <br>            } <br>             <br>            /* Limit the scroll range and to the scroll. <br>             */ <br>    if(nHscrollInc = max(-nHscrollPos, <br> min(nHscrollInc, <br>     nHscrollMax - nHscrollPos))) <br>            { <br>                nHscrollPos += nHscrollInc; <br>                ScrollWindow(hWnd, -wChar * nHscrollInc, 0, NULL, NULL); <br>                UpdateWindow(hWnd); <br>                SetScrollPos(hWnd, SB_HORZ, nHscrollPos, TRUE); <br>            } <br>            break; <br> <br>        case WM_KEYDOWN: <br>            /* Translate keystrokes to scroll message. <br>             */ <br>            for (i = 0; i &lt; NUMKEYS; i++) <br>                if (wParam == keyToScroll[i].wVirtKey) <br>                { <br>                    SendMessage(hWnd, keyToScroll[i].iMessage, <br>                                keyToScroll[i].wRequest, 0L); <br>                    break; <br>                } <br>            break; <br> <br>        case WM_PAINT: <br>            BeginPaint(hWnd, &amp;ps); <br> <br>            hBrush = CreateSolidBrush(GetSysColor(COLOR_APPWORKSPACE)); <br>            FillRect(ps.hdc, &amp;ps.rcPaint, hBrush); <br>            DeleteObject(hBrush); <br> <br>            /* Set up text attributes. <br>             */ <br>            hFont = GetStockObject(SYSTEM_FIXED_FONT); <br>            SelectObject(ps.hdc, hFont); <br>            SetBkMode(ps.hdc, TRANSPARENT); <br> <br>            /* Put up the display label if we're asked to repaint the <br>             * top line of the screen. <br>             */ <br>    if(ps.rcPaint.top &lt; hChar) <br>            { <br>                TextOut(ps.hdc, wChar * (0 - nHscrollPos), <br>                        0, szDisplayTextBuffer, <br>                        sprintf(szDisplayTextBuffer, GetStringRes(IDS_LABEL))); <br>MoveToEx(ps.hdc, wChar * (0 - nHscrollPos), hChar - 1, NULL); <br>                LineTo(ps.hdc, wClient, hChar - 1); <br> <br>                ps.rcPaint.top = hChar; <br>            } <br>                 <br>            /* Calculate the beginning and ending line numbers that we need <br>             * to paint.  These line numbers refer to lines in the display <br>             * buffer, not to lines in the display window. <br>             */ <br>    nPaintBeg = max (0, nVscrollPos + ps.rcPaint.top / hChar - 1); <br>            nPaintEnd = min(nNumBufferLines, <br>                              nVscrollPos + ps.rcPaint.bottom / hChar + 1); <br> <br>            /* Get the appropriate events from the display buffer, convert <br>             * to a text string and paint the text on the display. <br>             */ <br>            for (i = nPaintBeg; i &lt; nPaintEnd; i++) <br>            { <br>                GetDisplayEvent(lpDisplayBuffer, (LPEVENT)&amp;incomingEvent, i); <br>                TextOut(ps.hdc,  <br>                        wChar * (0 - nHscrollPos), <br>                        hChar * (1 - nVscrollPos + i), <br>                        szDisplayTextBuffer,  <br>                        GetDisplayText(szDisplayTextBuffer, <br>                                       (LPEVENT)&amp;incomingEvent)); <br>            } <br>                 <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case MM_MIDIINPUT: <br>            /* This is a custom message sent by the low level callback <br>             * function telling us that there is at least one MIDI event <br>             * in the input buffer.  We empty the input buffer, and put <br>             * each event in the display buffer, if it's not filtered. <br>             * If the input buffer is being filled as fast we can empty <br>             * it, then we'll stay in this loop and not process any other <br>             * Windows messages, or yield to other applications.  We need <br>             * something to restrict the amount of time we spend here... <br>             */ <br>            while(GetEvent(lpInputBuffer, (LPEVENT)&amp;incomingEvent)) <br>            { <br>                if(!bRecordingEnabled) <br>                    continue; <br> <br>                if(!CheckEventFilter((LPEVENT)&amp;incomingEvent, <br>                                    (LPFILTER)&amp;filter)) <br>                { <br>                    AddDisplayEvent(lpDisplayBuffer,  <br>                                    (LPEVENT)&amp;incomingEvent); <br>                    ++nNumBufferLines; <br>                    nNumBufferLines = min(nNumBufferLines, <br>  DISPLAY_BUFFER_SIZE - 1); <br>    bNeedToUpdate = TRUE; <br>                } <br>            } <br>             <br>            /* Recalculate vertical scroll bar range, and force <br>             * the display to be updated. <br>     */ <br> <br>    if (bNeedToUpdate) { <br>      nVscrollMax = max(0, nNumBufferLines - nNumDisplayLines); <br>      nVscrollPos = nVscrollMax; <br>      SetScrollRange(hWnd, SB_VERT, 0, nVscrollMax, FALSE); <br>      SetScrollPos(hWnd, SB_VERT, nVscrollPos, TRUE); <br>      InvalidateRect(hMainWnd, (LPRECT)&amp;rectScrollClip, 0); <br>      UpdateWindow(hMainWnd); <br>    } <br>             <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, message, wParam, lParam); <br>            break; <br>    } <br>    return 0; <br>} <br> <br>                                                                        //  <br>/* CommandMsg - Processes WM_COMMAND messages. <br> * <br> * Params:  hWnd - Handle to the window receiving the message. <br> *    wParam - Parameter of the WM_COMMAND message. <br> *    lParam - Parameter of the WM_COMMAND message. <br> * <br> * Return:  void <br> */ <br>VOID  CommandMsg( <br>  HWND  hWnd, <br>  WPARAM  wParam, <br>  LPARAM  lParam) <br>{ <br>    PREFERENCES preferences; <br>    RECT rectWindow; <br>    UINT  wRtn; <br>    HMENU hMenu; <br>    unsigned int i; <br>    char szErrorText[256]; <br>    WORD  wCommand; <br> <br>    wCommand = LOWORD(wParam); <br>     <br>    /* Process any WM_COMMAND messages we want */ <br>    switch (wCommand) { <br>        case IDM_ABOUT: <br>            About(hInst, hWnd); <br>            break; <br> <br>        case IDM_EXIT: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0l); <br>            break; <br> <br>        case IDM_SENDTOMAPPER: <br>            /* We use hMapper as a toggle between sending events to the <br>             * Mapper and not sending events. <br>             */ <br>            if(hMapper) { <br>                /* Close the Mapper and reset hMapper.  Uncheck the menu item. <br>                 * Clear Mapper handle in the instance data for each device. <br>                 */ <br>                wRtn = midiOutClose(hMapper); <br>                if(wRtn != 0) <br>                { <br>                    midiOutGetErrorText(wRtn, (LPSTR)szErrorText,  <br>                                        sizeof(szErrorText)); <br>                    Error(szErrorText); <br>                    Error("midiOutClose"); <br>                } <br>                hMapper = 0; <br> <br>                for (i=0; (i&lt;wNumDevices) &amp;&amp; (i&lt;MAX_NUM_DEVICES); i++) <br>                    lpCallbackInstanceData[i]-&gt;hMapper = hMapper; <br> <br>DoMenuItemCheck(hWnd, wCommand, FALSE); <br>            } <br>             <br>            else { <br>                /* Open the MIDI Mapper, put the Mapper handle in the instance <br>                 * data for each device and check the menu item. <br>                 */ <br>wRtn = midiOutOpen((LPHMIDIOUT) &amp;hMapper, (UINT) MIDIMAPPER, <br>                                    0L, 0L, 0L); <br>                                 <br>                if(wRtn != 0) {             // error opening Mapper <br>                    midiOutGetErrorText(wRtn, (LPSTR)szErrorText,  <br>                                        sizeof(szErrorText)); <br>                    Error("midiOutOpen"); <br>                    Error(szErrorText); <br>                    hMapper = 0; <br>                } <br> <br>                else {                      // Mapper opened successfully <br>                    for (i=0; (i&lt;wNumDevices) &amp;&amp; (i&lt;MAX_NUM_DEVICES); i++) <br>                        lpCallbackInstanceData[i]-&gt;hMapper = hMapper; <br> <br>    DoMenuItemCheck(hWnd, wCommand, TRUE); <br>                } <br>            } <br>             <br>            break; <br>             <br>        case IDM_SAVESETUP: <br>            /* Save the current location and size of the display window <br>             * in the MIDIMON.INI file. <br>             */ <br>            GetWindowRect(hMainWnd, (LPRECT)&amp;rectWindow); <br>            preferences.iInitialX = rectWindow.left; <br>            preferences.iInitialY = rectWindow.top; <br>            preferences.iInitialW = rectWindow.right - rectWindow.left; <br>            preferences.iInitialH = rectWindow.bottom - rectWindow.top; <br> <br>            setPreferences((LPPREFERENCES) &amp;preferences); <br>            break; <br> <br>        case IDM_STARTSTOP: <br>            /* Toggle between recording into the display buffer and not <br>             * recording.  Toggle the menu item between "Start" to "Stop" <br>             * accordingly. <br>             */ <br>            hMenu = GetMenu(hWnd); <br>            if(bRecordingEnabled) <br>            { <br>                ModifyMenu(hMenu, IDM_STARTSTOP, MF_BYCOMMAND, IDM_STARTSTOP, <br>                           GetStringRes(IDS_START)); <br>                bRecordingEnabled = 0; <br>            } <br>            else <br>            { <br>                ModifyMenu(hMenu, IDM_STARTSTOP, MF_BYCOMMAND, IDM_STARTSTOP, <br>                           GetStringRes(IDS_STOP)); <br>                bRecordingEnabled = 1; <br>            } <br>            DrawMenuBar(hWnd); <br>            break; <br> <br>        case IDM_CLEAR: <br>            /* Reset the display buffer, recalibrate the scroll bars, <br>             * and force an update of the display. <br>             */ <br>            ResetDisplayBuffer(lpDisplayBuffer); <br>            nNumBufferLines = 0; <br>            SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE); <br> <br>            InvalidateRect(hWnd, (LPRECT)&amp;rectScrollClip, 0); <br>            UpdateWindow(hWnd); <br> <br>            break; <br>             <br>        /* Set up filter structure for MIDI channel filtering. <br>         */ <br>        case IDM_FILTCHAN0: <br>        case IDM_FILTCHAN1: <br>        case IDM_FILTCHAN2: <br>        case IDM_FILTCHAN3: <br>        case IDM_FILTCHAN4: <br>        case IDM_FILTCHAN5: <br>        case IDM_FILTCHAN6: <br>        case IDM_FILTCHAN7: <br>        case IDM_FILTCHAN8: <br>        case IDM_FILTCHAN9: <br>        case IDM_FILTCHAN10: <br>        case IDM_FILTCHAN11: <br>        case IDM_FILTCHAN12: <br>        case IDM_FILTCHAN13: <br>        case IDM_FILTCHAN14: <br>        case IDM_FILTCHAN15: <br>    filter.channel[wCommand - IDM_FILTCHAN0] = <br>!filter.channel[wCommand - IDM_FILTCHAN0]; <br>    DoMenuItemCheck(hWnd, wCommand, <br>filter.channel[wCommand - IDM_FILTCHAN0]); <br>            break; <br>             <br>        /* Setup filter structure for MIDI event filtering. <br>         */ <br>        case IDM_NOTEOFF: <br>            filter.event.noteOff = !filter.event.noteOff; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.noteOff); <br>            break; <br>        case IDM_NOTEON: <br>            filter.event.noteOn = !filter.event.noteOn; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.noteOn); <br>            break; <br>        case IDM_POLYAFTERTOUCH: <br>            filter.event.keyAftertouch = !filter.event.keyAftertouch; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.keyAftertouch); <br>            break; <br>        case IDM_CONTROLCHANGE: <br>            filter.event.controller = !filter.event.controller; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.controller); <br>            break; <br>        case IDM_PROGRAMCHANGE: <br>            filter.event.progChange = !filter.event.progChange; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.progChange); <br>            break; <br>        case IDM_CHANNELAFTERTOUCH: <br>            filter.event.chanAftertouch = !filter.event.chanAftertouch; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.chanAftertouch); <br>            break; <br>        case IDM_PITCHBEND: <br>            filter.event.pitchBend = !filter.event.pitchBend; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.pitchBend); <br>            break; <br>        case IDM_CHANNELMODE: <br>            filter.event.channelMode = !filter.event.channelMode; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.channelMode); <br>            break; <br>        case IDM_SYSTEMEXCLUSIVE: <br>            filter.event.sysEx = !filter.event.sysEx; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.sysEx); <br>            break; <br>        case IDM_SYSTEMCOMMON: <br>            filter.event.sysCommon = !filter.event.sysCommon; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.sysCommon); <br>            break; <br>        case IDM_SYSTEMREALTIME: <br>            filter.event.sysRealTime = !filter.event.sysRealTime; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.sysRealTime); <br>            break; <br>        case IDM_ACTIVESENSE: <br>            filter.event.activeSense = !filter.event.activeSense; <br>    DoMenuItemCheck(hWnd, wCommand, filter.event.activeSense); <br>            break; <br> <br>        default: <br>            break; <br>    } <br>} <br> <br>                                                                        //  <br>/* InitFirstInstance - Performs initializaion for the first instance  <br> *      of the application. <br> * <br> * Params:  hInstance - Instance handle. <br> * <br> * Return:  Returns 1 if there were no errors.  Otherwise, returns 0. <br> */ <br>BOOL InitFirstInstance(hInstance) <br>HANDLE hInstance; <br>{ <br>    WNDCLASS wc; <br>     <br>    /* Define the class of window we want to register. <br>     */ <br>    wc.lpszClassName    = szAppName; <br>    wc.style            = CS_HREDRAW | CS_VREDRAW; <br>    wc.hCursor          = LoadCursor(NULL, IDC_ARROW); <br>    wc.hIcon            = LoadIcon(hInstance,"Icon"); <br>    wc.lpszMenuName     = "Menu"; <br>    wc.hbrBackground    = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wc.hInstance        = hInstance; <br>    wc.lpfnWndProc      = WndProc; <br>    wc.cbClsExtra       = 0; <br>    wc.cbWndExtra       = 0; <br>     <br>    if(!RegisterClass(&amp;wc)) <br>        return FALSE; <br>     <br>    return TRUE; <br>} <br> <br>                                                                        //  <br>/* DoMenuItemCheck - Checks and unchecks menu items. </code></pre>
<p>
</p>
<pre><code>* <br> * Params:  hWnd - Window handle for window associated with menu items. <br> *          wMenuItem - The menu ID for the menu item. <br> *          newState - The new checked/unchecked state of the menu item. <br> * <br> * Return:  void <br>*/ <br>void  DoMenuItemCheck( <br>  HWNDhWnd, <br>  WORDwMenuItem, <br>  BOOLnewState) <br>{ <br>    HMENU hMenu; <br>     <br>    hMenu = GetMenu(hWnd); <br>    CheckMenuItem(hMenu, wMenuItem, (newState ? MF_CHECKED: MF_UNCHECKED)); <br>} <br> <br> <br>/* Error - Beeps and shows an error message. <br> * <br> * Params:  szMsg - Points to a NULL-terminated string containing the <br> *              error message. <br> * <br> * Return:  Returns the return value from the MessageBox() call. <br> *          Since this message box has only a single button, the <br> *          return value isn't too meaningful. <br> */ <br>int Error(szMsg) <br>LPSTR szMsg; <br>{ <br>    MessageBeep(0); <br>    return MessageBox(hMainWnd, szMsg, szAppName, MB_OK); <br>} <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:Load the resource string with the ID given, and return a <br>*pointer to it.Notice that the buffer is common memory so <br>*the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
