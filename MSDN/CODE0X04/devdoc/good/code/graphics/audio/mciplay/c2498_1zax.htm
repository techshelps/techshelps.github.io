<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MCIPLAY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2499"></a>MCIPLAY.C</h2>
<pre><code>/*----------------------------------------------------------------------------*\ <br> * <br> *  MCIPLAY: <br> * <br> *    Sample app showing the use of MCIWnd <br> * <br> *    MCIPLAY is a MDI aplication that demonstates the following: <br> * <br> *      - Using the MCIWnd window class to play MCI files. <br> * <br> *----------------------------------------------------------------------------*/ <br>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br> <br>#define  STRICT <br>#define  INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;vfw.h&gt; <br> <br>#include "mciplay.h" <br> <br>#define BUFSIZE 260 <br>#define MCIPLAY_APP_CLASS "MCIPlay_App" <br>#define MCIPLAY_DOC_CLASS MCIWND_WINDOW_CLASS <br> <br>//--------------------------------------------------------------------------- <br> <br>#define ISCHECKED(hwnd,id) (BOOL)(GetMenuState(GetMenu(hwnd), id, 0) &amp; MF_CHECKED) <br> <br>/*-------------------------------------------------------------------------*\ <br>|                                                                          | <br>|   g l o b a l   v a r i a b l e s                                        | <br>|                                                                          | <br>\*------------------------------------------------------------------------*/ <br> <br>    HINSTANCE ghInstApp;        /* Instance handle */ <br>    HACCEL ghAccelApp; <br>    HWND ghwndApp;          /* Handle to parent window */ <br>    HWND ghwndMdi;          /* Handle to MCI client window */ <br>    char gszBuffer[BUFSIZE]; <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>LRESULT CALLBACK AppWndProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL    CALLBACK AppAbout(HWND, UINT, WPARAM, LPARAM); <br> <br>static BOOL AppInit(HINSTANCE, HINSTANCE, LPSTR, int); <br>static HWND mdiCreateDoc(LPSTR, LPSTR, LPARAM); <br>static HWND mdiCreateClient(HWND, HMENU); <br>static LRESULT mdiSendMessage(HWND, HWND, UINT, WPARAM, LPARAM); <br>static BOOL FormatFilterString(UINT, LPSTR); <br>static void MCI_OnCommand(HWND, int, HWND, UINT); <br>static void mdiFilterSendMessage(HWND, UINT, WPARAM, LPARAM); <br>static void MCI_OnInitMenuPopup(HWND, HMENU, int, BOOL); <br>static void MCI_OnSize(HWND, UINT, int, int); <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppAbout( hDlg, msg, wParam, lParam )                                      | <br>|                                                                              | <br>|   Description:                                                               | <br>|       This function handles messages belonging to the "About" dialog box.    | <br>|       The only message that it looks for is WM_COMMAND, indicating the use   | <br>|       has pressed the "OK" button.  When this happens, it takes down         | <br>|       the dialog box.                                                        | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hDlg            window handle of about dialog window                   | <br>|       msg             message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       TRUE if message has been processed, else FALSE                         | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>BOOL CALLBACK AppAbout( <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    switch (msg) { <br>        case WM_COMMAND: <br>        EndDialog(hwnd,TRUE); <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppInit ( hInstance, hPrevInstance )                                       | <br>|                                                                              | <br>|   Description:                                                               | <br>|       This is called when the application is first loaded into               | <br>|       memory.  It performs all initialization that doesn't need to be done   | <br>|       once per instance.                                                     | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|   hPrevInstance   instance handle of previous instance                       | <br>|       hInstance       instance handle of current instance                    | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       TRUE if successful, FALSE if not                                       | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>static BOOL AppInit( <br>HINSTANCE hInst, <br>HINSTANCE hPrev, <br>LPSTR szCmd, <br>int sw) <br>{ <br>    WNDCLASS cls; <br>    WORD wVer; <br>    char szAppName[BUFSIZE]; <br> <br>    /* Save instance handle for DialogBox */ <br>    ghInstApp = hInst; <br> <br>    LoadString( ghInstApp, IDS_APPNAME, szAppName, BUFSIZE ); <br> <br>    /* first let's make sure we are running on 1.1 */ <br>    wVer = HIWORD(VideoForWindowsVersion()); <br>    if (wVer &lt; 0x010a){ <br>        char szTitle[BUFSIZE]; <br>        /* oops, we are too old, blow out of here */ <br>        LoadString( ghInstApp, IDS_APPERR, szTitle, BUFSIZE ); <br>        LoadString( ghInstApp, IDS_VFWTOOOLD, gszBuffer, BUFSIZE ); <br>        MessageBeep(MB_ICONHAND); <br>        MessageBox(NULL, gszBuffer, szTitle, MB_OK|MB_ICONSTOP); <br>        return FALSE; <br>    } <br> <br>    ghAccelApp = LoadAccelerators(ghInstApp, "AppAccel"); <br> <br>    if (!hPrev) { <br>        cls.hCursor        = LoadCursor(NULL,IDC_ARROW); <br>        cls.hIcon          = LoadIcon(hInst,"AppIcon"); <br>        cls.lpszMenuName   = "AppMenu"; <br>        cls.lpszClassName  = MCIPLAY_APP_CLASS; <br>        cls.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE+1); <br>        cls.hInstance      = hInst; <br>        cls.style          = 0; <br>        cls.lpfnWndProc    = (WNDPROC)AppWndProc; <br>        cls.cbClsExtra     = 0; <br>        cls.cbWndExtra     = 0; <br> <br>        if (!RegisterClass(&amp;cls)) <br>            return FALSE; <br>    } <br> <br>    // !!! Not using MCIWndCreate, so we must init ourselves <br>    if (!MCIWndRegisterClass()) <br>        return FALSE; <br> <br>    ghwndApp = CreateWindow( <br>        MCIPLAY_APP_CLASS, <br>        szAppName, <br>        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>        CW_USEDEFAULT, <br>        0, <br>        CW_USEDEFAULT, <br>        0, <br>        (HWND)NULL,   /* no parent */ <br>        (HMENU)NULL,      /* use class menu */ <br>        (HANDLE)hInst,     /* handle to window instance */ <br>        (LPSTR)NULL);     /* no params to pass on */ <br> <br>    /* Make window visible according to the way the app is activated */ <br>    ShowWindow(ghwndApp,sw); <br> <br>    return TRUE; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   WinMain( hInstance, hPrevInstance, lpszCmdLine, cmdShow )                  | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The main procedure for the App.  After initializing, it just goes      | <br>|       into a message-processing loop until it gets a WM_QUIT message         | <br>|       (meaning the app was closed).                                          | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hInstance       instance handle of this instance of the app            | <br>|       hPrevInstance   instance handle of previous instance, NULL if first    | <br>|       lpszCmdLine     -&gt;null-terminated command line                         | <br>|       cmdShow         specifies how the window is initially displayed        | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       The exit code as specified in the WM_QUIT message.                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>int PASCAL WinMain( <br>HINSTANCE hInstance, <br>HINSTANCE hPrevInstance, <br>LPSTR szCmdLine, <br>int sw) <br>{ <br>    MSG msg; <br> <br>    if (!AppInit(hInstance,hPrevInstance,szCmdLine,sw)) <br>        return FALSE; <br> <br>    //Polling messages from event queue <br>    for (;;) { <br>        if (PeekMessage(&amp;msg, NULL, 0, 0,PM_REMOVE)) { <br>            if (msg.message == WM_QUIT) <br>                break; <br> <br>            if (ghAccelApp &amp;&amp; ghwndApp &amp;&amp; TranslateAccelerator(ghwndApp, ghAccelApp, &amp;msg)) <br>                continue; <br> <br>            if(!TranslateMDISysAccel(ghwndMdi, &amp;msg)) { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } else { <br>            // idle time here, DONT BE A PIG! <br>            WaitMessage(); <br>        } <br>    } <br>    return msg.wParam; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>static HWND mdiCreateDoc( <br>LPSTR szClass, <br>LPSTR szTitle, <br>LPARAM l) <br>{ <br>    MDICREATESTRUCT mdics; <br> <br>    mdics.szClass   = szClass; <br>    mdics.szTitle   = szTitle; <br>    mdics.hOwner    = ghInstApp; <br>    mdics.x         = CW_USEDEFAULT; <br>    mdics.y         = 0; <br>    mdics.cx        = CW_USEDEFAULT; <br>    mdics.cy        = 0; <br>    mdics.style     = WS_CLIPCHILDREN | WS_CLIPSIBLINGS | MCIWNDF_SHOWALL; <br>    mdics.lParam    = l; <br> <br>    return FORWARD_WM_MDICREATE(ghwndMdi, (LPMDICREATESTRUCT)&amp;mdics, SendMessage); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   mdiCreateClient()                                                          | <br>|                                                                              | <br>|   Description:                                                               | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|   HWND if successful, NULL otherwise                                         | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>static HWND mdiCreateClient( <br>HWND hwndP, <br>HMENU hmenuWindow) <br>{ <br>    CLIENTCREATESTRUCT ccs; <br> <br>    ccs.hWindowMenu = hmenuWindow; <br>    ccs.idFirstChild = 100; <br> <br>    return CreateWindow( <br>            "MDICLIENT", <br>            NULL, <br>            WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE, <br>            0, <br>            0, <br>            0, <br>            0, <br>            hwndP, <br>            0, <br>            ghInstApp, <br>            (LPVOID)&amp;ccs); <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>\*----------------------------------------------------------------------------*/ <br> <br>static LRESULT mdiSendMessage( <br>HWND hwndMdi, <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>    if (hwnd == (HWND)-1) { <br>        for (hwnd = GetWindow(hwndMdi, GW_CHILD); hwnd; <br>                    hwnd = GetWindow(hwnd, GW_HWNDNEXT)) <br>            SendMessage(hwnd, msg, wParam, lParam); <br>        return 0L; <br>    } else { <br>        if (hwnd == NULL) <br>            hwnd = FORWARD_WM_MDIGETACTIVE(hwndMdi, SendMessage); <br>        if (hwnd) <br>            return SendMessage(hwnd, msg, wParam, lParam); <br>    } <br>} <br> <br>//---------------------------------------------------------------------------- <br>// MCI_OnCommand - Handles WM_COMMAND <br>//---------------------------------------------------------------------------- <br>static void MCI_OnCommand( <br>HWND hwnd, <br>int id, <br>HWND hwndCtl, <br>UINT codeNotify) <br>{ <br>    HWND hwndNew; <br>    HWND hwndMovie = FORWARD_WM_MDIGETACTIVE(ghwndMdi, SendMessage); <br> <br>    switch(id) { <br>        case MENU_ABOUT: <br>            DialogBox(ghInstApp,MAKEINTRESOURCE(ABOUTBOX),hwnd,AppAbout); <br>            break; <br> <br>        case MENU_EXIT: <br>            PostMessage(hwnd,WM_CLOSE,0,0L); <br>            break; <br> <br>        case MENU_CLOSE: <br>            PostMessage(hwndMovie, WM_CLOSE, 0, 0L); <br>            break; <br> <br>        case MENU_NEW: <br>            LoadString( ghInstApp, IDS_UNTITLLED, gszBuffer, BUFSIZE ); <br>            if (hwndNew = mdiCreateDoc(MCIPLAY_DOC_CLASS, gszBuffer, 0)) <br>                SetFocus(hwndNew); <br>            break; <br> <br>        case MENU_OPEN: <br>        { <br>            OPENFILENAME ofn; <br>            char szFileName[BUFSIZE]; <br>            char szFilter[BUFSIZE]; <br> <br>            FormatFilterString( IDS_FILTERSTRING, szFilter ); <br> <br>            /* prompt user for file to open */ <br>            ofn.lStructSize = sizeof(OPENFILENAME); <br>            ofn.hwndOwner = hwnd; <br>            ofn.hInstance = NULL; <br>            ofn.lpstrFilter = szFilter; <br>            ofn.lpstrCustomFilter = NULL; <br>            ofn.nMaxCustFilter = 0; <br>            ofn.nFilterIndex = 0; <br>            *szFileName = '\0'; <br>            ofn.lpstrFile = szFileName; <br>            ofn.nMaxFile = BUFSIZE; <br>            ofn.lpstrFileTitle = NULL; <br>            ofn.nMaxFileTitle = 0; <br>            ofn.lpstrInitialDir = NULL; <br>            ofn.lpstrTitle = "Open"; <br>            ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY; <br>            ofn.nFileOffset = 0; <br>            ofn.nFileExtension = 0; <br>            ofn.lpstrDefExt = NULL; <br>            ofn.lCustData = 0; <br>            ofn.lpfnHook = NULL; <br>            ofn.lpTemplateName = NULL; <br> <br>            if (GetOpenFileName(&amp;ofn)) <br>                if (hwndNew = mdiCreateDoc(MCIPLAY_DOC_CLASS, 0, (LPARAM)(LPSTR)szFileName)) <br>                    SetFocus(hwndNew); <br>        } <br>        break; <br> <br>        case WM_MDITILE: <br>        case WM_MDICASCADE: <br>        case WM_MDIICONARRANGE: <br>            SendMessage(ghwndMdi, id, 0, 0); <br>            break; <br> <br>        /* Movie Menu */ <br>        case IDM_PLAY: <br>            MCIWndPlay(hwndMovie); <br>            break; <br> <br>        case IDM_RPLAY: <br>            MCIWndPlayReverse(hwndMovie); <br>            break; <br> <br>        case IDM_STOP: <br>            MCIWndStop(hwndMovie); <br>            break; <br> <br>        case IDM_HOME: <br>            MCIWndHome(hwndMovie); <br>            break; <br> <br>        case IDM_END: <br>            MCIWndEnd(hwndMovie); <br>            break; <br> <br>        case IDM_STEP: <br>            MCIWndStep(hwndMovie, 1); <br>            break; <br> <br>        case IDM_RSTEP: <br>            MCIWndStep(hwndMovie, -1); <br>            break; <br> <br>        /* Styles POPUP */ <br> <br>        case IDM_SAutosizeWindow: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOAUTOSIZEWINDOW, <br>                ISCHECKED(hwnd,id) ? MCIWNDF_NOAUTOSIZEWINDOW : 0); <br>            break; <br> <br>        case IDM_SAutosizeMovie: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOAUTOSIZEMOVIE, <br>                ISCHECKED(hwnd,id) ? MCIWNDF_NOAUTOSIZEMOVIE : 0); <br>            break; <br> <br>        case IDM_SPlaybar: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOPLAYBAR, <br>                ISCHECKED(hwnd,id) ? MCIWNDF_NOPLAYBAR : 0); <br>            break; <br> <br>        case IDM_SRecord: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_RECORD, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_RECORD); <br>            break; <br> <br>        case IDM_SMenu: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOMENU, <br>                ISCHECKED(hwnd,id) ? MCIWNDF_NOMENU : 0); <br>            break; <br> <br>        case IDM_SErrorDlg: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOERRORDLG, <br>                ISCHECKED(hwnd,id) ? MCIWNDF_NOERRORDLG : 0); <br>            break; <br> <br>        case IDM_SShowName: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_SHOWNAME, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_SHOWNAME); <br>            break; <br> <br>        case IDM_SShowMode: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_SHOWMODE, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_SHOWMODE); <br>            break; <br> <br>        case IDM_SShowPos: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_SHOWPOS, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_SHOWPOS); <br>            break; <br> <br>        case IDM_SNotifyMedia: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYMEDIA, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_NOTIFYMEDIA); <br>            break; <br> <br>        case IDM_SNotifyMode: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYMODE, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_NOTIFYMODE); <br>            break; <br> <br>        case IDM_SNotifyPos: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYPOS, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_NOTIFYPOS); <br>            break; <br> <br>        case IDM_SNotifySize: <br>            MCIWndChangeStyles(hwndMovie, MCIWNDF_NOTIFYSIZE, <br>                ISCHECKED(hwnd,id) ? 0 : MCIWNDF_NOTIFYSIZE); <br>            break; <br> <br>        default: <br>            FORWARD_WM_COMMAND(NULL, id, hwndCtl, codeNotify, mdiFilterSendMessage); <br>            break; <br>    } <br>    return; <br>} <br> <br>/*----------------------------------------------------------------------------*/ <br>static void mdiFilterSendMessage( <br>HWND    hwnd, <br>UINT    msg, <br>WPARAM  wParam, <br>LPARAM  lParam) <br>{ <br>    mdiSendMessage(ghwndMdi, hwnd, msg, wParam, lParam); <br>} <br> <br>//---------------------------------------------------------------------------- <br>// MCI_OnInitMenuPopup - Handles WM_INITMENUPOPUP <br>//---------------------------------------------------------------------------- <br>static void MCI_OnInitMenuPopup( <br>HWND hwnd, <br>HMENU hMenu, <br>int item, <br>BOOL fSystemMenu) <br>{ <br>    HMENU hStylesMenu = GetSubMenu(GetSubMenu(GetMenu(hwnd), 1), 10); <br>    HMENU hFileMenu = GetSubMenu(GetMenu(hwnd), 0); <br>    HMENU hMovieMenu = GetSubMenu(GetMenu(hwnd), 1); <br>    HMENU hWindowMenu = GetSubMenu(GetMenu(hwnd), 2); <br>    HWND  hwndMovie = FORWARD_WM_MDIGETACTIVE(ghwndMdi, SendMessage); <br>    UINT f; <br> <br>    // be sure this isn't the system menu <br>    if (fSystemMenu) <br>        return; <br> <br>    // <br>    // Check the styles properly when styles is chosen <br>    // !!! Make sure position constants don't change! <br>    // Dont forget that some of these styles use multiple bits <br>    // in wStyles - therefore check carefully. <br>    if ((hMenu == hStylesMenu) &amp;&amp; hwndMovie) { <br> <br>        UINT  wStyles = MCIWndGetStyles(hwndMovie); <br> <br>        CheckMenuItem(hStylesMenu, IDM_SAutosizeWindow, <br>            ((wStyles &amp; MCIWNDF_NOAUTOSIZEWINDOW) == MCIWNDF_NOAUTOSIZEWINDOW) ? MF_UNCHECKED : MF_CHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SAutosizeMovie, <br>            ((wStyles &amp; MCIWNDF_NOAUTOSIZEMOVIE) == MCIWNDF_NOAUTOSIZEMOVIE) ? MF_UNCHECKED : MF_CHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SPlaybar, <br>            ((wStyles &amp; MCIWNDF_NOPLAYBAR) == MCIWNDF_NOPLAYBAR) ? MF_UNCHECKED : MF_CHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SRecord, <br>            ((wStyles &amp; MCIWNDF_RECORD) == MCIWNDF_RECORD) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SMenu, <br>            ((wStyles &amp; MCIWNDF_NOMENU) == MCIWNDF_NOMENU) ? MF_UNCHECKED :MF_CHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SErrorDlg, <br>            ((wStyles &amp; MCIWNDF_NOERRORDLG) == MCIWNDF_NOERRORDLG) ? MF_UNCHECKED :MF_CHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SShowName, <br>            ((wStyles &amp; MCIWNDF_SHOWNAME) == MCIWNDF_SHOWNAME) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SShowMode, <br>            ((wStyles &amp; MCIWNDF_SHOWMODE) == MCIWNDF_SHOWMODE) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SShowPos, <br>            ((wStyles &amp; MCIWNDF_SHOWPOS) == MCIWNDF_SHOWPOS) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SNotifyMedia, <br>            ((wStyles &amp; MCIWNDF_NOTIFYMEDIA) == MCIWNDF_NOTIFYMEDIA) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SNotifyMode, <br>            ((wStyles &amp; MCIWNDF_NOTIFYMODE) == MCIWNDF_NOTIFYMODE) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SNotifyPos, <br>            ((wStyles &amp; MCIWNDF_NOTIFYPOS) == MCIWNDF_NOTIFYPOS) ? MF_CHECKED :MF_UNCHECKED); <br>        CheckMenuItem(hStylesMenu, IDM_SNotifySize, <br>            ((wStyles &amp; MCIWNDF_NOTIFYSIZE) == MCIWNDF_NOTIFYSIZE) ? MF_CHECKED :MF_UNCHECKED); <br>    } <br> <br>    // <br>    // Enable/Disable the stuff under the MOVIE popup <br>    // !!! Make sure position constants don't change! <br>    // <br>    else if (hMenu == hMovieMenu) { <br> <br>        EnableMenuItem( hMenu, 10, <br>                        MF_BYPOSITION | (hwndMovie ? MF_ENABLED : MF_GRAYED) ); <br> <br>        if ( !hwndMovie <br>           || MCIWndGetMode(hwndMovie, NULL, 0) == MCI_MODE_NOT_READY) { <br> <br>            EnableMenuItem( hFileMenu, MENU_CLOSE, <br>                            hwndMovie ? MF_ENABLED : MF_GRAYED ); <br> <br>            EnableMenuItem(hMenu, IDM_STOP, MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_PLAY, MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_RPLAY, MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_HOME, MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_END, MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_STEP, MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_RSTEP, MF_GRAYED); <br> <br>        } else { <br> <br>            EnableMenuItem(hFileMenu, MENU_CLOSE, MF_ENABLED); <br>            f = MCIWndGetMode(hwndMovie, NULL, 0) != MCI_MODE_STOP; <br>            EnableMenuItem(hMenu, IDM_PLAY, !f ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_RPLAY, !f ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_STOP, f ? MF_ENABLED : MF_GRAYED); <br>            EnableMenuItem(hMenu, IDM_HOME, MF_ENABLED); <br>            EnableMenuItem(hMenu, IDM_END,  MF_ENABLED); <br>            EnableMenuItem(hMenu, IDM_STEP, MF_ENABLED); <br>            EnableMenuItem(hMenu, IDM_RSTEP,MF_ENABLED); <br>        } <br>    } <br> <br>    // <br>    // Enable/Disable the stuff under the WINDOW menu <br>    // !!! Make sure position constants don't change! <br>    // <br>    else if (hMenu == hWindowMenu) { <br> <br>            EnableMenuItem(hMenu, 0, <br>                        MF_BYPOSITION | (hwndMovie ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hMenu, 1, <br>                        MF_BYPOSITION | (hwndMovie ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hMenu, 2, <br>                        MF_BYPOSITION | (hwndMovie ? MF_ENABLED : MF_GRAYED)); <br>    } <br> <br>    // <br>    // Enable/Disable the stuff under the FILE menu <br>    // <br>    else if (hMenu == hFileMenu) { <br> <br>        EnableMenuItem( hFileMenu, MENU_CLOSE, <br>                        hwndMovie ? MF_ENABLED : MF_GRAYED); <br>    } <br> <br>    FORWARD_WM_INITMENUPOPUP(NULL, hMenu, item, <br>                             fSystemMenu, mdiFilterSendMessage); <br>    return; <br>} <br> <br>//---------------------------------------------------------------------------- <br>// MCI_OnSize - Handles WM_SIZE <br>//---------------------------------------------------------------------------- <br>static void MCI_OnSize( <br>HWND hwnd, <br>UINT state, <br>int cx, <br>int cy) <br>{ <br>    MoveWindow(ghwndMdi,0,0,cx,cy,TRUE); <br>    return; <br>} <br> <br>/*----------------------------------------------------------------------------*\ <br>|   AppWndProc( hwnd, msg, wParam, lParam )                                    | <br>|                                                                              | <br>|   Description:                                                               | <br>|       The window proc for the app's main (tiled) window.  This processes all | <br>|       of the parent window's messages.                                       | <br>|                                                                              | <br>|   Arguments:                                                                 | <br>|       hwnd            window handle for the parent window                    | <br>|       msg             message number                                         | <br>|       wParam          message-dependent                                      | <br>|       lParam          message-dependent                                      | <br>|                                                                              | <br>|   Returns:                                                                   | <br>|       0 if processed, nonzero if ignored                                     | <br>|                                                                              | <br>\*----------------------------------------------------------------------------*/ <br>LRESULT CALLBACK AppWndProc( <br>HWND hwnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br> <br>    switch (msg) { <br>       case WM_CREATE: <br>        ghwndMdi = mdiCreateClient(hwnd, GetSubMenu(GetMenu(hwnd), GetMenuItemCount(GetMenu(hwnd))-1)); <br>        break; <br> <br>        case WM_COMMAND: <br>            HANDLE_WM_COMMAND(hwnd, wParam, lParam, MCI_OnCommand); <br>            break; <br> <br>    case WM_PALETTECHANGED: <br>        mdiSendMessage(ghwndMdi, (HWND)-1, msg, wParam, lParam); <br>        break; <br> <br>    case WM_QUERYNEWPALETTE: <br>        return mdiSendMessage(ghwndMdi, NULL, msg, wParam, lParam); <br>            break; <br> <br>        case WM_INITMENUPOPUP: <br>        HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, MCI_OnInitMenuPopup); <br>        break; <br> <br>    case WM_SIZE: <br>        HANDLE_WM_SIZE(hwnd, wParam, lParam, MCI_OnSize); <br>        break; <br> <br>    case WM_DESTROY: <br>        PostQuitMessage(0); <br>        return (0); <br>    } <br>    return DefFrameProc(hwnd,ghwndMdi,msg,wParam,lParam); <br>} <br> <br>/*--------------------------------------------------------------+ <br>| FormatFilterString                                            | <br>|                                                               | <br>+--------------------------------------------------------------*/ <br>static BOOL FormatFilterString( <br>UINT uID, <br>LPSTR lpszString ) <br>{ <br>    int nLength, nCtr = 0; <br>    char chWildCard; <br> <br>    *lpszString = 0; <br> <br>    nLength = LoadString( ghInstApp, uID, lpszString, BUFSIZE ); <br> <br>    chWildCard = lpszString[nLength-1]; <br> <br>    while( lpszString[nCtr] ) { <br>        if( lpszString[nCtr] == chWildCard ) <br>            lpszString[nCtr] = 0; <br>        nCtr++; <br>    } <br> <br>    return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
