<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MMCAPS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2566"></a>MMCAPS.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//  A PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  mmcaps.c <br>// <br>//  Description: <br>// <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;stdarg.h&gt; <br> <br>#include "appport.h" <br>#include "mmcaps.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>//  globals, no less <br>// <br>HINSTANCE   ghinst; <br>TCHAR       gszAppSection[]     = TEXT("MMCaps"); <br>TCHAR       gszNull[]           = TEXT(""); <br> <br>TCHAR       gszAppName[APP_MAX_APP_NAME_CHARS]; <br> <br> <br>// <br>// <br>// <br>PZYZTABBEDLISTBOX   gptlbDrivers; <br> <br>TCHAR       gszUnknown[]        = TEXT("Unknown"); <br>TCHAR       gszNotSpecified[]   = TEXT("Not Specified"); <br> <br>UINT        guDriverType        = MMCAPS_DRIVERTYPE_LOWLEVEL; <br> <br> <br> <br>//==========================================================================; <br>// <br>//  Application helper functions <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppProfileWriteBytes <br>//   <br>//  Description: <br>//      This function writes a raw structure of bytes to the application's <br>//      ini section that can later be retrieved using AppProfileReadBytes. <br>//      This gives an application the ability to write any structure to <br>//      the ini file and restore it later--very useful. <br>// <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>// <br>//  Arguments: <br>//      PCTSTR pszKey: Pointer to key name for the stored data. <br>//   <br>//      LPBYTE pbStruct: Pointer to the data to be saved. <br>//   <br>//      UINT cbStruct: Count in bytes of the data to store. <br>//   <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if it fails. <br>//   <br>//  History: <br>//       3/10/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileWriteBytes <br>( <br>    PCTSTR          pszKey, <br>    LPBYTE          pbStruct, <br>    UINT            cbStruct <br>) <br>{ <br>    static TCHAR achNibbleToChar[] = <br>    { <br>'0', '1', '2', '3', '4', '5', '6', '7', <br>'8', '9', 'A', 'B', 'C', 'D', 'E', 'F', <br>    }; <br>    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x]) <br>     <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br> <br>    // <br>    //  if pbStruct is NULL, then erase the key from the ini file, otherwise <br>    //  format the raw bytes into a hex string and write that out... <br>    // <br>    fAllocated = FALSE; <br>    psz        = NULL; <br>    if (NULL != pbStruct) <br>    { <br>// <br>//  check if the quick buffer can be used for formatting the output <br>//  text--if it cannot, then alloc space for it. note that space <br>//  must be available for an ending checksum byte (2 bytes for high <br>//  and low nibble) as well as a null terminator. <br>// <br>psz     = (LPTSTR)ach; <br>cchTemp = cbStruct * 2 + 3; <br>if (cchTemp &gt; SIZEOF(ach)) <br>{ <br>    psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>    if (NULL == psz) <br>return (FALSE); <br> <br>    fAllocated = TRUE; <br>} <br>   <br>// <br>//  step through all bytes in the structure and convert it to <br>//  a string of hex numbers... <br>// <br>bChecksum = 0; <br>for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>{ <br>    // <br>    //  grab the next byte and add into checksum... <br>    // <br>    bChecksum += (b = *pbStruct); <br>       <br>    *pch++ = NIBBLE2CHAR((b &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>    *pch++ = NIBBLE2CHAR(b &amp; (BYTE)0x0F); <br>} <br> <br>// <br>//  add the checksum byte to the end and null terminate the hex <br>//  dumped string... <br>// <br>*pch++ = NIBBLE2CHAR((bChecksum &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>*pch++ = NIBBLE2CHAR(bChecksum &amp; (BYTE)0x0F); <br>*pch   = '\0'; <br>    } <br> <br>    // <br>    //  write the string of hex bytes out to the ini file... <br>    // <br>    fReturn = WriteProfileString(gszAppSection, pszKey, psz); <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>GlobalFreePtr(psz); <br>   <br>    return (fReturn); <br>} // AppProfileWriteBytes <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL AppProfileReadBytes <br>//   <br>//  Description: <br>//      This function reads a previously stored structure of bytes from <br>//      the application's ini file. This data must have been written with <br>//      the AppProfileWriteBytes function--it is checksumed to keep bad <br>//      data from blowing up the application. <br>//   <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>//   <br>//  Arguments: <br>//      PCTSTR pszKey: Pointer to key that contains the data. <br>//   <br>//      LPBYTE pbStruct: Pointer to buffer to receive the data. <br>//   <br>//      UINT cbStruct: Number of bytes expected. <br>//   <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if the function fails (bad checksum, missing key, etc). <br>//   <br>//  History: <br>//       3/10/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileReadBytes <br>( <br>    PCTSTR          pszKey, <br>    LPBYTE          pbStruct, <br>    UINT            cbStruct <br>) <br>{ <br>    // <br>    //  note that the following works for both upper and lower case, and <br>    //  will return valid values for garbage chars <br>    // <br>    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') ?  \ <br>(BYTE)((ch) - '0') :                \ <br>((BYTE)(10 + (ch) - 'A') &amp; (BYTE)0x0F) ) <br> <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    UINT        u; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br>    TCHAR       ch; <br> <br>    // <br>    //  add one the the number of bytes needed to accomodate the checksum <br>    //  byte placed at the end by AppProfileWriteBytes... <br>    // <br>    cbStruct++; <br> <br>    // <br>    //  check if the quick buffer can be used for retrieving the input <br>    //  text--if it cannot, then alloc space for it. note that there must <br>    //  be space available for the null terminator (the +1 below). <br>    // <br>    fAllocated = FALSE; <br>    psz        = (LPTSTR)ach; <br>    cchTemp    = cbStruct * 2 + 1; <br>    if (cchTemp &gt; SIZEOF(ach)) <br>    { <br>psz = GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>if (NULL == psz) <br>    return (FALSE); <br> <br>fAllocated = TRUE; <br>    } <br> <br>    // <br>    //  read the hex string... if it is not the correct length, then assume <br>    //  error and return. <br>    // <br>    fReturn = FALSE; <br>    u = (UINT)GetProfileString(gszAppSection, pszKey, gszNull, psz, cchTemp); <br>    if ((cbStruct * 2) == u) <br>    { <br>bChecksum = 0; <br>for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>{ <br>    ch = *pch++; <br>    b  = CHAR2NIBBLE(ch) &lt;&lt; (BYTE)4; <br>    ch = *pch++; <br>    b |= CHAR2NIBBLE(ch); <br> <br>    // <br>    //  if this is not the final byte (the checksum byte), then  <br>    //  store it and accumulate checksum.. <br>    // <br>    if (cbStruct != 1) <br>bChecksum += (*pbStruct = b); <br>} <br> <br>// <br>//  check the last byte read against the checksum that we calculated <br>//  if they are not equal then return error... <br>// <br>fReturn = (bChecksum == b); <br>    } <br> <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>GlobalFreePtr(psz); <br>   <br>    return (fReturn); <br>} // AppProfileReadBytes <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBox <br>// <br>//  Description: <br>//      This function displays a message for the application in a standard <br>//      message box. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      PCTSTR pszFormat: Format string used for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() function. <br>// <br>//  History: <br>//       2/13/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBox <br>( <br>    HWND            hwnd, <br>    UINT            fuStyle, <br>    PCTSTR          pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the message.. <br>    // <br>    va_start(va, pszFormat); <br>    wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br> <br>    return (n); <br>} // AppMsgBox() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBoxId <br>// <br>//  Description: <br>//      This function displays a message for the application. The message <br>//      text is retrieved from the string resource table using LoadString. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      UINT uIdsFormat: String resource id to be loaded with LoadString() <br>//      and used a the format string for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() if the string <br>//      resource specified by uIdsFormat is valid. The return value is zero <br>//      if the string resource failed to load. <br>// <br>//  History: <br>//       2/13/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBoxId <br>( <br>    HWND            hwnd, <br>    UINT            fuStyle, <br>    UINT            uIdsFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat)); <br>    if (0 != n) <br>    { <br>// <br>//  format and display the message.. <br>// <br>va_start(va, uIdsFormat); <br>wvsprintf(ach, szFormat, va); <br>va_end(va); <br> <br>n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br>    } <br> <br>    return (n); <br>} // AppMsgBoxId() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void AppHourGlass <br>// <br>//  Description: <br>//      This function changes the cursor to that of the hour glass or <br>//      back to the previous cursor. <br>// <br>//      This function can be called recursively. <br>// <br>//  Arguments: <br>//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need <br>//      the arrow back. <br>// <br>//  Return (void): <br>//      On return, the cursor will be what was requested. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNGLOBAL AppHourGlass <br>( <br>    BOOL            fHourGlass <br>) <br>{ <br>    static HCURSOR  hcur; <br>    static UINT     uWaiting = 0; <br> <br>    if (fHourGlass) <br>    { <br>if (!uWaiting) <br>{ <br>    hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>    ShowCursor(TRUE); <br>} <br> <br>uWaiting++; <br>    } <br>    else <br>    { <br>--uWaiting; <br> <br>if (!uWaiting) <br>{ <br>    ShowCursor(FALSE); <br>    SetCursor(hcur); <br>} <br>    } <br>} // AppHourGlass() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppDialogBox <br>// <br>//  Description: <br>//      This function is used to display a dialog modal box. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for new dialog. <br>// <br>//      LPCSTR pszDlg: Dialog template to use. <br>// <br>//      DLGPROC pfnDlg: Pointer to dialog procedure. <br>// <br>//      LPARAM lParam: Any lParam to be passed as lParam for WM_INITDIALOG. <br>// <br>//  Return (int): <br>//      The return value is the nResult from EndDialog. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNGLOBAL AppDialogBox <br>( <br>    HWND            hwnd, <br>    LPCTSTR         pszDlg, <br>    DLGPROC         pfnDlg, <br>    LPARAM          lParam <br>) <br>{ <br>    int     nResult; <br> <br>    // <br>    //  !!! NT doesn't need this--neither does Win 3.1 with C7/C8 !!! <br>    // <br>    // <br>    nResult = 0; <br>    pfnDlg  = (DLGPROC)MakeProcInstance((FARPROC)pfnDlg, ghinst); <br>    if (NULL != pfnDlg) <br>    { <br>nResult = DialogBoxParam(ghinst, pszDlg, hwnd, pfnDlg, lParam); <br>FreeProcInstance((FARPROC)pfnDlg); <br>    } <br> <br>    return (nResult); <br>} // AppDialogBox() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowText <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      PCTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowText <br>( <br>    HWND            hwnd, <br>    PCTSTR          pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the string in the window... <br>    // <br>    va_start(va, pszFormat); <br>    n = wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    SetWindowText(hwnd, ach); <br> <br>    return (n); <br>} // AppSetWindowText() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowTextId <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. The format string is extracted from the string <br>//      table using LoadString() on the uIdsFormat argument. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      UINT uIdsFormat: String resource id to be loaded with LoadString() <br>//      and used a the format string for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. This value is zero if the LoadString() function fails <br>//      for the uIdsFormat argument. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowTextId <br>( <br>    HWND            hwnd, <br>    UINT            uIdsFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       szFormat[APP_MAX_STRING_RC_CHARS]; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    n = LoadString(ghinst, uIdsFormat, szFormat, SIZEOF(szFormat)); <br>    if (0 != n) <br>    { <br>// <br>//  format and display the string in the window... <br>// <br>va_start(va, uIdsFormat); <br>n = wvsprintf(ach, szFormat, va); <br>va_end(va); <br> <br>SetWindowText(hwnd, ach); <br>    } <br> <br>    return (n); <br>} // AppSetWindowTextId() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  int AppMEditPrintF <br>//   <br>//  Description: <br>//      This function is used to print formatted text into a Multiline <br>//      Edit Control as if it were a standard console display. This is <br>//      a very easy way to display small amounts of text information <br>//      that can be scrolled and copied to the clip-board. <br>//   <br>//  Arguments: <br>//      HWND hedit: Handle to a Multiline Edit control. <br>//   <br>//      PCTSTR pszFormat: Pointer to any valid format for wsprintf. If <br>//      this argument is NULL, then the Multiline Edit Control is cleared <br>//      of all text. <br>//   <br>//  Return (int): <br>//      Returns the number of characters written into the edit control. <br>// <br>//  History: <br>//      05/16/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMEditPrintF <br>( <br>    HWND            hedit, <br>    PCTSTR          pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    int         n; <br> <br> <br>    // <br>    //  if the pszFormat argument is NULL, then just clear all text in <br>    //  the edit control.. <br>    // <br>    if (NULL == pszFormat) <br>    { <br>SetWindowText(hedit, gszNull); <br>return (0); <br>    } <br> <br> <br>    // <br>    //  format and display the string in the window... <br>    // <br>    va_start(va, pszFormat); <br>    n = wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1); <br>    Edit_ReplaceSel(hedit, ach); <br> <br>    return (n); <br>} // AppMEditPrintF() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  DWORD AppGetWindowsVersion <br>// <br>//  Description: <br>//      This function returns the version of Windows that the application <br>//      is running on plus some platform information. <br>// <br>//  Arguments: <br>//      PTSTR pach: Options pointer to buffer to receive text string of <br>//      the Windows version and platform. <br>// <br>//  Return (LRESULT): <br>//      The return value will be the version and platform information of <br>//      the current operating system in the following format: <br>// <br>//      0xPPPPMMRR where: <br>// <br>//      MM      :   major version of Windows <br>//      RR      :   minor version (revision) of Windows <br>//      PPPP    :   the platform the application is running on which <br>//                  will be one of the following: <br>// <br>//                  #ifdef WIN32 <br>//                      the HIWORD() is RESERVED except for the high bit: <br>//                          high bit is 0 = Windows NT <br>//                          high bit is 1 = Win32s/Windows 3.1 <br>//                  #else <br>//                      0xMMRR = Major and Minor version of [MS-]DOS <br>//                      GetWinFlags() &amp; 0x8000 = Windows on OS/2 (WLO) <br>//                      GetWinFlags() &amp; 0x4000 = Windows on Windows NT (WOW) <br>//                  #endif <br>// <br>//  History: <br>//       2/13/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppGetWindowsVersion <br>( <br>    PTSTR           pszEnvironment, <br>    PTSTR           pszPlatform <br>) <br>{ <br> <br>    BYTE    bVerWinMajor; <br>    BYTE    bVerWinMinor; <br>    UINT    uVerEnv; <br>    DWORD   dw; <br>    LRESULT lr; <br> <br>    dw = GetVersion(); <br> <br>    // <br>    //  massage the version information into something intelligent <br>    // <br>    // <br>    bVerWinMajor = LOBYTE(LOWORD(dw)); <br>    bVerWinMinor = HIBYTE(LOWORD(dw)); <br>    uVerEnv      = HIWORD(dw); <br>    lr = MAKELPARAM(((UINT)bVerWinMajor &lt;&lt; 8) | bVerWinMinor, uVerEnv); <br> <br>    // <br>    //  if caller wants the environment string version... <br>    // <br>    if (NULL != pszEnvironment) <br>    { <br>    // <br>    // <br>    // <br>#ifdef WIN32 <br>{ <br>    static TCHAR    szFormatVersion[]   = TEXT("%s Version %u.%.2u"); <br>    static TCHAR    szEnvWinNT[]        = TEXT("Windows NT"); <br>    static TCHAR    szEnvWin32s[]       = TEXT("Win32s"); <br> <br>    wsprintf(pszEnvironment, szFormatVersion, <br>     (LPSTR)((0x8000 &amp; uVerEnv) ? szEnvWin32s : szEnvWinNT), <br>     bVerWinMajor, bVerWinMinor); <br>} <br>#else <br>{ <br>#ifndef WF_WINNT <br>    #define WF_CPUR4000         0x0100 <br>    #define WF_CPUALPHA21064    0x0200 <br>    #define WF_WINNT            0x4000 <br>    #define WF_WLO              0x8000 <br>#endif <br> <br>    static TCHAR    szFormatSubSys[]= TEXT("Windows Version %u.%.2u (%s%s)\n%s Subsystem, DOS Version %u.%.2u"); <br>    static TCHAR    szFormatDOS[]   = TEXT("Windows Version %u.%.2u (%s%s)\nDOS Version %u.%.2u"); <br>    static TCHAR    szSubSysWLO[]   = TEXT("WLO"); <br>    static TCHAR    szSubSysWOW[]   = TEXT("WOW"); <br>    static TCHAR    szModeEnhanced[]= TEXT("Enhanced"); <br>    static TCHAR    szModeStandard[]= TEXT("Standard"); <br>    static TCHAR    szEnvPaging[]   = TEXT(", Paging"); <br> <br>    DWORD   dwWinFlags; <br>    PTSTR   pszMode; <br> <br>    BYTE    bVerEnvMajor    = HIBYTE(LOWORD(uVerEnv)); <br>    BYTE    bVerEnvMinor    = LOBYTE(LOWORD(uVerEnv)); <br> <br>    dwWinFlags = GetWinFlags(); <br> <br>    pszMode = (dwWinFlags &amp; WF_ENHANCED) ? szModeEnhanced : szModeStandard; <br>    if (dwWinFlags &amp; (WF_WLO | WF_WINNT)) <br>    { <br>wsprintf(pszEnvironment, szFormatSubSys, bVerWinMajor, bVerWinMinor, <br> (LPSTR)pszMode, <br> (LPSTR)((dwWinFlags &amp; WF_PAGING) ? szEnvPaging : gszNull), <br> (LPSTR)((dwWinFlags &amp; WF_WINNT) ? szSubSysWOW : szSubSysWLO), <br> bVerEnvMajor, bVerEnvMinor); <br>    } <br>    else <br>    { <br>wsprintf(pszEnvironment, szFormatDOS, bVerWinMajor, bVerWinMinor, <br> (LPSTR)pszMode, <br> (LPSTR)((dwWinFlags &amp; WF_PAGING) ? szEnvPaging : gszNull), <br> bVerEnvMajor, bVerEnvMinor); <br>    } <br>} <br>#endif <br>    } <br> <br>    // <br>    //  if caller wants the platform string version... <br>    // <br>    if (NULL != pszPlatform) <br>    { <br>#ifdef WIN32 <br>{ <br>    static TCHAR    szFormatPlatform[]  = TEXT("%s%u, %u Processor(s)"); <br>    static TCHAR    szProcessorIntel[]  = TEXT("Intel "); <br>    static TCHAR    szProcessorMIPS[]   = TEXT("MIPS R"); <br>    static TCHAR    szProcessorAlpha[]  = TEXT("DEC Alpha "); <br>    static TCHAR    szProcessorDunno[]  = TEXT("Dunno zYz"); <br> <br>    SYSTEM_INFO sysinfo; <br>    PTSTR       pszProcessor; <br> <br>    // <br>    //  this is absolutely silly. one would think that the dwOemId member <br>    //  would provide something useful like the processor class... but <br>    //  no, it doesn't--it is always 0. <br>    // <br>    GetSystemInfo(&amp;sysinfo); <br>    switch (sysinfo.dwProcessorType) <br>    { <br>case PROCESSOR_INTEL_386: <br>case PROCESSOR_INTEL_486: <br>    pszProcessor = szProcessorIntel; <br>    break; <br> <br>case PROCESSOR_MIPS_R4000: <br>    pszProcessor = szProcessorMIPS; <br>    break; <br> <br>case PROCESSOR_ALPHA_21064: <br>    pszProcessor = szProcessorAlpha; <br>    break; <br> <br>default: <br>    pszProcessor = szProcessorDunno; <br>    break; <br>    } <br> <br>    // <br>    // <br>    // <br>    wsprintf(pszPlatform, szFormatPlatform, (LPSTR)pszProcessor, <br>     sysinfo.dwProcessorType, sysinfo.dwNumberOfProcessors); <br>} <br>#else <br>{ <br>    static TCHAR    szPlat286[]         = TEXT("80286"); <br>    static TCHAR    szPlat386[]         = TEXT("80386"); <br>    static TCHAR    szPlat486[]         = TEXT("i486"); <br>    static TCHAR    szPlatR4000[]       = TEXT("MIPS R4000, Emulation: "); <br>    static TCHAR    szPlatAlpha21064[]  = TEXT("Alpha 21064, Emulation: "); <br>    static TCHAR    szPlat80x87[]       = TEXT(", 80x87"); <br> <br>    DWORD   dwWinFlags; <br> <br>    dwWinFlags = GetWinFlags(); <br>    pszPlatform[0] = '\0'; <br> <br>    if (dwWinFlags &amp; (WF_WLO | WF_WINNT)) <br>    { <br>if (dwWinFlags &amp; WF_CPUR4000) <br>    lstrcpy(pszPlatform, szPlatR4000); <br>else if (dwWinFlags &amp; WF_CPUALPHA21064) <br>    lstrcpy(pszPlatform, szPlatAlpha21064); <br>    } <br> <br>    if (dwWinFlags &amp; WF_CPU286) <br>lstrcat(pszPlatform, szPlat286); <br>    else if (dwWinFlags &amp; WF_CPU386) <br>lstrcat(pszPlatform, szPlat386); <br>    else if (dwWinFlags &amp; WF_CPU486) <br>lstrcat(pszPlatform, szPlat486); <br> <br>    if (dwWinFlags &amp; WF_80x87) <br>lstrcat(pszPlatform, szPlat80x87); <br>} <br>#endif <br>    } <br> <br>    // <br>    //  return the result <br>    // <br>    return (lr); <br>} // AppGetWindowsVersion() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  HFONT AppChooseFont <br>// <br>//  Description: <br>//      This function is a wrapper for the ChooseFont() common dialog. <br>//      The purpose of this function is to let the user choose a font that <br>//      looks good to them--regardless of how stupid it really looks. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for chooser dialog. <br>// <br>//      HFONT hfont: Handle to current font (default for chooser dialog). <br>// <br>//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a <br>//      copy of the LOGFONT information for the newly chosen font. <br>// <br>//  Return (HFONT): <br>//      The return value is the newly chosen font. If no new font was chosen <br>//      then the return value is NULL. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>HFONT FNGLOBAL AppChooseFont <br>( <br>    HWND            hwnd, <br>    HFONT           hfont, <br>    PLOGFONT        plf <br>) <br>{ <br>    LOGFONT     lf; <br>    CHOOSEFONT  cf; <br>    BOOL        f; <br>    HFONT       hfontNew; <br> <br>    // <br>    //  get the font info for the current font... <br>    // <br>    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&amp;lf); <br> <br>    // <br>    //  fill in the choosefont structure <br>    // <br>    cf.lStructSize  = sizeof(CHOOSEFONT); <br>    cf.hwndOwner    = hwnd; <br>    cf.hDC          = NULL; <br>    cf.Flags        = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT; <br>    cf.lCustData    = 0; <br>    cf.lpfnHook     = NULL; <br>    cf.hInstance    = NULL; <br>    cf.nFontType    = SCREEN_FONTTYPE; <br>    cf.lpLogFont    = (LPLOGFONT)&amp;lf; <br> <br>    // <br>    //  splash a dialog into the user's face.. <br>    // <br>    hfontNew = NULL; <br>    f = ChooseFont(&amp;cf); <br>    if (f) <br>    { <br>// <br>//  create the new font.. <br>// <br>hfontNew = CreateFontIndirect(&amp;lf); <br>if (NULL == hfontNew) <br>    return (NULL); <br> <br>// <br>//  copy the logfont structure if caller wants it <br>// <br>if (NULL != plf) <br>    *plf = lf; <br>    } <br> <br>    // <br>    //  return the new font (if one was chosen) <br>    // <br>    return (hfontNew); <br>} // AppChooseFont() <br> <br> <br>//==========================================================================; <br>// <br>//  Misc rarely used application dialogs and stuff... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AboutDlgProc <br>// <br>//  Description: <br>//      This dialog procedure is used for the ubiquitous about box. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For </code></pre>
<p>
</p>
<pre><code>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//  History: <br>//       1/ 2/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT AboutDlgProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    HWND    hwndT; <br>    PTSTR   pach; <br>    UINT    u; <br> <br>    switch (uMsg) <br>    { <br>case WM_INITDIALOG: <br>    // <br>    //  display some OS version information <br>    // <br>    // <br>    pach = (PTSTR)LocalAlloc(LPTR, APP_MAX_STRING_RC_BYTES); <br>    if (NULL == pach) <br>return (TRUE); <br> <br>    AppGetWindowsVersion(pach, NULL); <br>    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_OS); <br>    SetWindowText(hwndT, pach); <br> <br>    AppGetWindowsVersion(NULL, pach); <br>    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_PLATFORM); <br>    SetWindowText(hwndT, pach); <br> <br>    wsprintf(pach, "MMREG.H V%u.%.02u", <br>     (_INC_MMREG / 100), (_INC_MMREG % 100)); <br>    hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_MMSYSTEM); <br>    SetWindowText(hwndT, pach); <br> <br>    LocalFree((HLOCAL)pach); <br> <br>    // <br>    //  return nonzero to set the input focus to the control <br>    //  identified by the (hwndFocus = (HWND)wParam) argument. <br>    //  a zero return tells the dialog manager that this function <br>    //  has set the focus using SetFocus. <br>    // <br>    return (TRUE); <br> <br>case WM_COMMAND: <br>    u = GET_WM_COMMAND_ID(wParam, lParam); <br>    if ((IDOK == u) || (IDCANCEL == u)) <br>    { <br>EndDialog(hwnd, (IDOK == u)); <br>    } <br>    break; <br>    } <br> <br>    return (FALSE); <br>} // AboutDlgProc() <br> <br> <br>//==========================================================================; <br>// <br>//  Initialization and exit code... <br>// <br>// <br>//==========================================================================; <br> <br>TCHAR   gszKeyWindow[]      = TEXT("Window"); <br>TCHAR   gszKeyFont[]        = TEXT("Font"); <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MMCapsChooseFont <br>// <br>//  Description: <br>//      This function lets the user choose a new font for the script window. <br>//      After a new font is chosen, the font structure is stored to the <br>//      .ini file so it can be restored on the next run of this application. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a new font was chosen. It is FALSE if <br>//      the user canceled the operation. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MMCapsChooseFont <br>( <br>    HWND            hwnd <br>) <br>{ <br>    LOGFONT     lf; <br>    HWND        hlb; <br>    HFONT       hfont; <br>    HFONT       hfontNew; <br> <br>    hlb = GetDlgItem(hwnd, IDD_APP_LIST_DEVICES); <br> <br>    // <br>    //  get the current font and pass it to the choose font dialog <br>    // <br>    hfont = GetWindowFont(gptlbDrivers-&gt;hlb); <br> <br>    hfontNew = AppChooseFont(hwnd, hfont, &amp;lf); <br>    if (NULL == hfontNew) <br>return (FALSE); <br> <br>    // <br>    //  select the new font into the script window and delete the old one <br>    // <br>    TlbSetFont(gptlbDrivers, hfontNew, TRUE); <br>    DeleteFont(hfont); <br> <br> <br>    // <br>    //  save the complete description of the chosen font so there can be <br>    //  no strangness in the font mapping next run. this is overkill, but <br>    //  it works... <br>    // <br>    AppProfileWriteBytes(gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br> <br>    return (TRUE); <br>} // MMCapsChooseFont() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsSettingsRestore <br>//   <br>//  Description: <br>//      This function restores state information for the application. This <br>//      function is called just after the main window is created (it has <br>//      not been ShowWindow()'d). This function will generate the call <br>//      to ShowWindow before returning. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that has just been created but <br>//      not shown. <br>// <br>//      int nCmdShow: The state that the application window should show as. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsSettingsRestore <br>( <br>    HWND            hwnd, <br>    int             nCmdShow <br>) <br>{ <br>    WINDOWPLACEMENT wp; <br>    PRECT           prc; <br>    HFONT           hfont; <br>    LOGFONT         lf; <br>    RECT            rc; <br>    POINT           pt; <br>    int             n; <br>    BOOL            f; <br> <br> <br> <br>    // <br>    //  restore the user's preferred font. <br>    // <br>    hfont = NULL; <br>    f = AppProfileReadBytes(gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br>    if (f) <br>    { <br>hfont = CreateFontIndirect(&amp;lf); <br>    } <br> <br>    if (NULL == hfont) <br>    { <br>hfont = GetStockFont(ANSI_VAR_FONT); <br>    } <br> <br>    TlbSetFont(gptlbDrivers, hfont, TRUE); <br> <br> <br>    // <br>    //  grab the stored window position and size from the .ini file... <br>    //  there must be four arguments stored or the entry is considered <br>    //  invalid. <br>    // <br>    prc = &amp;wp.rcNormalPosition; <br>    f = AppProfileReadBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc)); <br>    if (f) <br>    { <br>// <br>//  to make sure the user can always get at the window, check to <br>//  see if the midpoint of the caption is visible--if it is not, <br>//  then default to the default position used when creating the <br>//  window. <br>// <br>n = (prc-&gt;right - prc-&gt;left) / 2; <br>pt.x = (n + prc-&gt;left); <br> <br>n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME); <br>pt.y = (n + prc-&gt;top); <br> <br>GetWindowRect(GetDesktopWindow(), &amp;rc); <br>if (PtInRect(&amp;rc, pt)) <br>{ <br>    // <br>    //  fill out the window placement structure--default the <br>    //  maximized and minimized states to default placement by <br>    //  getting its current placement. <br>    // <br>    wp.length = sizeof(wp); <br>    GetWindowPlacement(hwnd, &amp;wp); <br> <br>    wp.flags           = 0; <br>    wp.showCmd         = nCmdShow; <br> <br>    SetWindowPlacement(hwnd, &amp;wp); <br>    return (TRUE); <br>} <br>    } <br> <br>    // <br>    //  show defaulted and succeed <br>    // <br>    ShowWindow(hwnd, nCmdShow); <br>    return (TRUE); <br>} // MMCapsSettingsRestore() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsSettingsSave <br>//   <br>//  Description: <br>//      This function saves the current state information for the application. <br>//      It is called just before the main window is closed (destroyed); or <br>//      as Windows is exiting (query end session). <br>// <br>//      Note that this function should not destroy any resources--it can <br>//      be called at any time to save a snapshot of the application state. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that will be destroyed shortly. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsSettingsSave <br>( <br>    HWND            hwnd <br>) <br>{ <br>    WINDOWPLACEMENT wp; <br>    PRECT           prc; <br>    BOOL            f; <br> <br>    // <br>    //  save the current window placement--only store the size and location <br>    //  of the restored window. maximized and minimized states should <br>    //  remain defaulted on the next invocation of this application. <br>    // <br>    wp.length = sizeof(wp); <br>    f = GetWindowPlacement(hwnd, &amp;wp); <br>    if (f) <br>    { <br>prc = &amp;wp.rcNormalPosition; <br> <br>DPF(0, "WindowPlacement: show=%d, minX=%d, minY=%d, maxX=%d, maxY=%d", <br>     wp.showCmd, wp.ptMinPosition.x, wp.ptMinPosition.y, <br>     wp.ptMaxPosition.x, wp.ptMaxPosition.y); <br> <br>DPF(0, "                 normX=%d, normY=%d, normW=%d, normH=%d", <br>     prc-&gt;left, prc-&gt;top, prc-&gt;right, prc-&gt;bottom); <br> <br>// <br>//  save the _bounding rectangle_ of the restored window state... <br>// <br>AppProfileWriteBytes(gszKeyWindow, (LPBYTE)prc, sizeof(*prc)); <br>    } <br> <br> <br>    // <br>    //  succeed <br>    // <br>    return (TRUE); <br>} // MMCapsSettingsSave() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MMCapsDlgProc <br>// <br>//  Description: <br>//      This dialog procedure is used to display driver capabilities. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//  History: <br>//       1/ 2/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNEXPORT MMCapsDlgProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    HWND        hedit; <br>    UINT        u; <br> <br>    switch (uMsg) <br>    { <br>case WM_INITDIALOG: <br>    hedit = GetDlgItem(hwnd, IDD_DEVCAPS_EDIT_DETAILS); <br>    SetWindowFont(hedit, GetStockFont(ANSI_FIXED_FONT), FALSE); <br> <br>    // <br>    // <br>    // <br>    switch (guDriverType) <br>    { <br>case MMCAPS_DRIVERTYPE_LOWLEVEL: <br>    MMCapsDetailLowLevel(hedit, lParam); <br>    break; <br> <br>#if 0 <br>case MMCAPS_DRIVERTYPE_MCI: <br>    MMCapsDetailMCI(hedit, lParam); <br>    break; <br> <br>case MMCAPS_DRIVERTYPE_ACM: <br>    MMCapsDetailACM(hedit, lParam); <br>    break; <br> <br>case MMCAPS_DRIVERTYPE_VIDEO: <br>    MMCapsDetailVideo(hedit, lParam); <br>    break; <br>#endif <br>    } <br> <br>    // <br>    //  return nonzero to set the input focus to the control <br>    //  identified by the (hwndFocus = (HWND)wParam) argument. <br>    //  a zero return tells the dialog manager that this function <br>    //  has set the focus using SetFocus. <br>    // <br>    return (TRUE); <br> <br>case WM_COMMAND: <br>    u = GET_WM_COMMAND_ID(wParam, lParam); <br>    if ((IDOK == u) || (IDCANCEL == u)) <br>    { <br>EndDialog(hwnd, (IDOK == u)); <br>    } <br>    break; <br>    } <br> <br>    return (FALSE); <br>} // MMCapsDlgProc() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsRefreshDriverList <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: Handle of main window. <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/16/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsRefreshDriverList <br>( <br>    PZYZTABBEDLISTBOX   ptlb <br>) <br>{ <br>    static UINT     uIdPrev = (UINT)-1; <br> <br>    BOOL        fComplete; <br> <br>    // <br>    // <br>    // <br>    SetWindowRedraw(ptlb-&gt;hlb, FALSE); <br>    ListBox_ResetContent(ptlb-&gt;hlb); <br> <br> <br>    // <br>    //  only force complete update if the driver type is different from <br>    //  previous... <br>    // <br>    fComplete = (guDriverType != uIdPrev); <br>    uIdPrev = guDriverType; <br> <br>    // <br>    // <br>    // <br>    switch (guDriverType) <br>    { <br>case MMCAPS_DRIVERTYPE_LOWLEVEL: <br>    MMCapsEnumerateLowLevel(ptlb, fComplete); <br>    break; <br> <br> <br>#if 0 <br>case MMCAPS_DRIVERTYPE_MCI: <br>    MMCapsEnumerateMCI(ptlb, fComplete); <br>    break; <br> <br>case MMCAPS_DRIVERTYPE_ACM: <br>    MMCapsEnumerateACM(ptlb, fComplete); <br>    break; <br> <br>case MMCAPS_DRIVERTYPE_VIDEO: <br>    MMCapsEnumerateVideo(ptlb, fComplete); <br>    break; <br> <br>case MMCAPS_DRIVERTYPE_DRIVERS: <br>    MMCapsEnumerateDrivers(ptlb, fComplete); <br>    break; <br>#endif <br> <br>    } <br> <br>    // <br>    // <br>    // <br>    SetWindowRedraw(ptlb-&gt;hlb, TRUE); <br> <br>    return (TRUE); <br>} // MMCapsRefreshDriverList() <br> <br> <br>//==========================================================================; <br>// <br>//  Main application window handling code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCreate <br>// <br>//  Description: <br>//      This function is called to handle the WM_CREATE message for the <br>//      application's window. The application should finish the creation <br>//      of the window (create controls, allocate resources, etc). The <br>//      window has not been displayed (CreateWindow[Ex] has not returned). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to the window that is in the process of being <br>//      created. <br>// <br>//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info <br>//      about the window being created. <br>// <br>//  Return (LRESULT): <br>//      The return value should be nonzero if the application wishes to <br>//      let the window finish being created. A return of zero tells <br>//      CreateWindow[Ex] to fail the creation of the window. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppCreate <br>( <br>    HWND            hwnd, <br>    LPCREATESTRUCT  pcs <br>) <br>{ <br>    DPF(0, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)", <br>    hwnd, pcs-&gt;x, pcs-&gt;y, pcs-&gt;cx, pcs-&gt;cy); <br> <br>    // <br>    //  create the driver selection listbox <br>    // <br>    gptlbDrivers = TlbCreate(hwnd, IDD_APP_LIST_DEVICES, NULL); <br>    if (NULL == gptlbDrivers) <br>return (0L); <br> <br>    // <br>    // <br>    // <br>    MMCapsRefreshDriverList(gptlbDrivers); <br> <br> <br>    // <br>    //  we want the focus to default to the device listbox window <br>    // <br>    SetFocus(gptlbDrivers-&gt;hlb); <br> <br> <br>    // <br>    //  return nonzero to succeed the creation of the window <br>    // <br>    return (1L); <br>} // AppCreate() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppQueryEndSession <br>// <br>//  Description: <br>//      This function handles the WM_QUERYENDSESSION. This message is sent <br>//      by USER when ExitWindows has been called to end the Windows session. <br>//      This function can stop Windows from exiting if it is not convenient <br>//      for Windows to end. <br>// <br>//      Giving the user the option to save modified data before continueing <br>//      with the shutdown of Windows is a good idea. <br>// <br>//      Telling Windows to continue with the exit procedure does not <br>//      necessarily mean Windows will exit. All applications are queried <br>//      for shutdown approval. When the actual decision is made on whether <br>//      Windows will exit, WM_ENDSESSION will be sent with the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//  Return (LRESULT): <br>//      Returns zero to STOP Windows from exiting. Returns non-zero to <br>//      allows windows to shut down. <br>// <br>//  History: <br>//       2/ 9/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppQueryEndSession <br>( <br>    HWND            hwnd <br>) <br>{ <br>    DPF(0, "AppQueryEndSession(hwnd=%Xh)", hwnd); <br> <br>    // <br>    //  tell Windows to proceed with the shutdown process! <br>    // <br>    return (1L); <br>} // AppQueryEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppEndSession <br>// <br>//  Description: <br>//      This function is called to handle the WM_ENDSESSION message. This <br>//      message is generated after the application answers the <br>//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION <br>//      message is to tell the application if Windows will be exiting <br>//      (TRUE  == fEndSession) or the end session was canceled by an <br>//      application (FALSE == fEndSession). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end <br>//      session was canceled. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. Note that an application <br>//      cannot halt the termination of Windows from this message--the <br>//      WM_QUERYENDSESSION is the only message that allows that behaviour. <br>//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it <br>//      or not. <br>// <br>//  History: <br>//       2/ 9/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppEndSession <br>( <br>    HWND            hwnd, <br>    BOOL            fEndSession <br>) <br>{ <br>    DPF(0, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession); <br> <br>    // <br>    //  we processed the message, return zero.. <br>    // <br>    return (0L); <br>} // AppEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppClose <br>// <br>//  Description: <br>//      This function handles the WM_CLOSE message for the application. <br>//      If the application should close, DestroyWindow() must be called <br>//      by this function. Otherwise the application will not close. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_CLOSE message. <br>// <br>//  Return (LRESULT): <br>//      There return value is zero. The DestroyWindow function will have <br>//      been called if the application should actually close. <br>// <br>//  History: <br>//       2/ 6/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppClose <br>( <br>    HWND            hwnd <br>) <br>{ <br>    HWND        hlb; <br>    HFONT       hfont; <br> <br> <br>    DPF(0, "AppClose(hwnd=%Xh)", hwnd); <br> <br>    // <br>    //  save any settings that should be saved on app termination... <br>    // <br>    MMCapsSettingsSave(hwnd); <br> <br> <br>    // <br>    //  if the Shift key is held down during the close message, then just <br>    //  save the current state but don't destroy the window... this is <br>    //  useful if the user does not want to exit the app and rerun it <br>    //  to make sure the state is saved--just before the user does something <br>    //  that may crash Windows or something.. <br>    // <br>    if (GetKeyState(VK_SHIFT) &lt; 0) <br>    { <br>return (0L); <br>    } <br> <br> <br>    // <br>    //  destroy the font we are using... before deleting the font, select <br>    //  the system font back into the script window so the font won't <br>    //  be 'in use' anymore. <br>    // <br>    hlb = GetDlgItem(hwnd, IDD_APP_LIST_DEVICES); <br> <br>    hfont = GetWindowFont(hlb); <br>    SetWindowFont(hlb, NULL, FALSE); <br>    DeleteFont(hfont); <br> <br>    // <br>    //  make the window close and terminate the application <br>    // <br>    DestroyWindow(hwnd); <br> <br>    return (0L); <br>} // AppClose() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppInitMenuPopup <br>// <br>//  Description: <br>//      This function handles the WM_INITMENUPOPUP message. This message <br>//      is sent to the window owning the menu that is going to become <br>//      active. This gives an application the ability to modify the menu <br>//      before it is displayed (disable/add items, etc). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP <br>//      message. <br>// <br>//      HMENU hmenu: Handle to the menu that is to become active. <br>// <br>//      int nItem: Specifies the zero-based relative position of the menu <br>//      item that invoked the popup menu. <br>// <br>//      BOOL fSysMenu: Specifies whether the popup menu is a System menu <br>//      (TRUE) or it is not a System menu (FALSE). <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//  History: <br>//       1/ 2/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppInitMenuPopup <br>( <br>    HWND            hwnd, <br>    HMENU           hmenu, <br>    int             nItem, <br>    BOOL            fSysMenu <br>) <br>{ <br>    UINT        u; <br> <br>    DPF(0, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)", <br>    hwnd, hmenu, nItem, fSysMenu); <br> <br>    // <br>    //  if the system menu is what got hit, succeed immediately... this <br>    //  application has no stuff in the system menu. <br>    // <br>    if (fSysMenu) <br>return (0L); <br> <br>    // <br>    //  initialize the menu that is being 'popped up' <br>    // <br>    switch (nItem) <br>    { <br>case APP_MENU_ITEM_FILE: <br>    break; <br> <br>case APP_MENU_ITEM_DRIVERS: <br>    for (u = IDM_DRIVERS_LOWLEVEL; u &lt;= IDM_DRIVERS_DRIVERS; u++) <br>    { <br>UINT    uCheck; <br> <br>uCheck = (u == guDriverType) ? MF_CHECKED : MF_UNCHECKED; <br>CheckMenuItem(hmenu, u, uCheck); <br>    } <br>    break; <br>    } <br> <br>    // <br>    //  we processed the message--return 0... <br>    // <br>    return (0L); <br>} // AppInitMenuPopup() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCommand <br>// <br>//  Description: <br>//      This function handles the WM_COMMAND message. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window receiving the WM_COMMAND message. <br>// <br>//      int nId: Control or menu item identifier. <br>// <br>//      HWND hwndCtl: Handle of control if the message is from a control. <br>//      This argument is NULL if the message was not generated by a control. <br>// <br>//      UINT uCode: Notification code. This argument is 1 if the message <br>//      was generated by an accelerator. If the message is from a menu, <br>//      this argument is 0. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppCommand <br>( <br>    HWND            hwnd, <br>    int             nId, <br>    HWND            hwndCtl, <br>    UINT            uCode <br>) <br>{ <br>    int         n; <br>    LRESULT     lr; <br> <br>    switch (nId) <br>    { <br>case IDM_FILE_FONT: <br>    MMCapsChooseFont(hwnd); <br>    break; <br> <br>case IDM_FILE_ABOUT: <br>    AppDialogBox(hwnd, DLG_ABOUT, (DLGPROC)AboutDlgProc, 0L); <br>    break; <br> <br>case IDM_FILE_EXIT: <br>    FORWARD_WM_CLOSE(hwnd, SendMessage); <br>    break; <br> <br> <br>case IDM_DRIVERS_LOWLEVEL: <br>case IDM_DRIVERS_MCI: <br>case IDM_DRIVERS_ACM: <br>case IDM_DRIVERS_VIDEO: <br>case IDM_DRIVERS_DRIVERS: <br>    if ((UINT)nId == guDriverType) <br>break; <br> <br>    guDriverType = (UINT)nId; <br> <br>    // -- fall through -- // <br> <br>case IDM_UPDATE: <br>    MMCapsRefreshDriverList(gptlbDrivers); <br>    break; <br> <br> <br>case IDD_APP_LIST_DEVICES: <br>    switch (uCode) <br>    { <br>case LBN_SELCHANGE: <br>    break; <br> <br>case LBN_DBLCLK: <br>    n  = ListBox_GetCurSel(hwndCtl); <br>    lr = ListBox_GetItemData(hwndCtl, n); <br>    AppDialogBox(hwnd, DLG_DEVCAPS, (DLGPROC)MMCapsDlgProc, lr); <br>    break; <br>    } <br>    break; <br>    } <br> <br>    return (0L); <br>} // AppCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppSize <br>// <br>//  Description: <br>//      This function handles the WM_SIZE message for the application's <br>//      window. This message is sent to the application window after the <br>//      size has changed (but before it is painted). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_SIZE message. <br>// <br>//      UINT fuSizeType: Specifies the type of resizing requested. This <br>//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED, <br>//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW. <br>// <br>//      int nWidth: Width of the new client area for the window. <br>// <br>//      int nHeight: Height of the new client area for the window. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the application processes the message. <br>// <br>//  History: <br>//       2/ 5/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppSize <br>( <br>    HWND            hwnd, <br>    UINT            fuSizeType, <br>    int             nWidth, <br>    int             nHeight <br>) <br>{ <br>    RECT        rc; <br> <br>    DPF(0, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)", <br>    hwnd, fuSizeType, nWidth, nHeight); <br> <br>    // <br>    //  unless this application is the one being resized then don't waste <br>    //  time computing stuff that doesn't matter. this applies to being <br>    //  minimized also because this application does not have a custom <br>    //  minimized state. <br>    // <br>    if ((SIZE_RESTORED != fuSizeType) &amp;&amp; (SIZE_MAXIMIZED != fuSizeType)) <br>return (0L); <br> <br> <br>    // <br>    //  size the devices listbox to be the total size of the client area-- <br>    //  inflate the rect by one so borders are not visible. note that  <br>    //  we need to leave room at the top for the title text which is one <br>    //  line of text in height... <br>    // <br>    GetClientRect(hwnd, &amp;rc); <br>    InflateRect(&amp;rc, 1, 1); <br> <br> <br>    TlbMove(gptlbDrivers, &amp;rc, FALSE); <br> <br> <br>    // <br>    //  we processed the message.. <br>    // <br>    return (0L); <br>} // AppSize() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  LRESULT AppPaint <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hwnd: <br>//   <br>//  Return (LRESULT): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppPaint <br>( <br>    HWND            hwnd <br>) <br>{ <br>    PAINTSTRUCT ps; <br> <br>    // <br>    // <br>    // <br>    BeginPaint(hwnd, &amp;ps); <br> <br>    TlbPaint(gptlbDrivers, hwnd, ps.hdc); <br> <br>    EndPaint(hwnd, &amp;ps); <br> <br>    // <br>    //  we processed the message <br>    // <br>    return (0L); <br>} // AppPaint() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppWndProc <br>// <br>//  Description: <br>//      This is the main application window procedure. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (LRESULT): <br>//      The return value depends on the message that is being processed. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNEXPORT AppWndProc <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    LRESULT     lr; <br> <br>    switch (uMsg) <br>    { <br>case WM_CREATE: <br>    lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate); <br>    return (lr); <br> <br>case WM_INITMENUPOPUP: <br>    HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup); <br>    return (0L); <br> <br>case WM_COMMAND: <br>    lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand); <br>    return (lr); <br> <br>case WM_SIZE: <br>    // <br>    //  handle what we want for sizing, and then always call the <br>    //  default handler... <br>    // <br>    HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize); <br>    break; <br> <br>case WM_PAINT: <br>    HANDLE_WM_PAINT(hwnd, wParam, lParam, AppPaint); <br>    break; <br> <br>case WM_QUERYENDSESSION: <br>    lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession); <br>    return (lr); <br> <br>case WM_ENDSESSION: <br>    HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession); <br>    return (0L); <br> <br>case WM_CLOSE: <br>    HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose); <br>    return (0L); <br> <br>case WM_DESTROY: <br>    PostQuitMessage(0); <br>    return (0L); <br>    } <br> <br>    return (DefWindowProc(hwnd, uMsg, wParam, lParam)); <br>} // AppWndProc() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppInit <br>// <br>//  Description: <br>//      This function is called to initialize a new instance of the <br>//      application. We want to parse our command line, create our window, <br>//      allocate resources, etc. <br>// <br>//      The arguments passed to this function are exactly the same as <br>//      those passed to WinMain. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      If the application is compiled for Unicode, then this argument is <br>//      ignored. <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (HWND): <br>//      Returns the newly created handle to the applications main window. </code></pre>
<p>
</p>
<pre><code>//      This handle is NULL if something went wrong and tells the application <br>//      to exit immediately. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>HWND FNGLOBAL AppInit <br>( <br>    HINSTANCE       hinst, <br>    HINSTANCE       hinstPrev, <br>    LPTSTR          pszCmdLine, <br>    int             nCmdShow <br>) <br>{ <br>    LRESULT FNEXPORT AppWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>    HWND        hwnd; <br>    WNDCLASS    wc; <br> <br>    DPF(0, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)", <br>    hinst, hinstPrev, pszCmdLine, nCmdShow); <br> <br>    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName)); <br> <br> <br>    // <br>    //  determine whether a new window class needs to be registered for <br>    //  this application. for Win 16, this only needs to be done for the <br>    //  first instance of the application created. for Win 32, this must <br>    //  be done for EVERY instance of the application. <br>    // <br>    if (NULL == hinstPrev) <br>    { <br>wc.style         = CS_HREDRAW | CS_VREDRAW; <br>wc.lpfnWndProc   = (WNDPROC)AppWndProc; <br>wc.cbClsExtra    = 0; <br>wc.cbWndExtra    = 0; <br>wc.hInstance     = hinst; <br>wc.hIcon         = LoadIcon(hinst, ICON_APP); <br>wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>wc.lpszMenuName  = MENU_APP; <br>wc.lpszClassName = gszAppName; <br> <br>if (!RegisterClass(&amp;wc)) <br>    return (NULL); <br>    } <br> <br> <br>    // <br>    //  create the application's main window <br>    // <br>    //  style bits available: <br>    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages <br>    //      WS_EX_DLGMODALFRAME :  creates window with double border <br>    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages <br>    //      WS_EX_TOPMOST       :  puts window in topmost space <br>    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only) <br>    // <br>    hwnd = CreateWindowEx(WS_EX_NOPARENTNOTIFY, <br>  gszAppName, <br>  gszAppName, <br>  WS_OVERLAPPEDWINDOW, <br>  APP_WINDOW_XOFFSET, <br>  APP_WINDOW_YOFFSET, <br>  APP_WINDOW_WIDTH, <br>  APP_WINDOW_HEIGHT, <br>  NULL, <br>  NULL, <br>  hinst, <br>  NULL); <br> <br>    if (NULL == hwnd) <br>return (NULL); <br> <br>#ifdef UNICODE <br>    // <br>    //  the application--which is different than the pszCmdLine argument <br>    //  passed through WinMain()... <br>    // <br>    //  so, skip over the command name to get to the argument string <br>    // <br>    pszCmdLine = GetCommandLine(); <br>    if (NULL != pszCmdLine) <br>    { <br>while (('\0' != *pszCmdLine) &amp;&amp; (' ' != *pszCmdLine++)) <br>    ; <br>    } <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsSettingsRestore(hwnd, nCmdShow); <br> <br> <br>    // <br>    //  finally, get the window displayed and return success <br>    // <br>    //  the ShowWindow call is made during MMCapsInit <br>    // <br>//  ShowWindow(hwnd, nCmdShow); <br>//  UpdateWindow(hwnd); <br> <br>    return (hwnd); <br>} // AppInit() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppExit <br>// <br>//  Description: <br>//      This function is called just before the application exits from <br>//      WinMain. Its purpose is to clean up any resources that were allocated <br>//      for running the application: brushes, heaps, etc.. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application that is exiting. <br>// <br>//      int nResult: The result of the WM_QUIT message (in wParam of the <br>//      MSG structure. This argument will usually be 0 (even if the message <br>//      loop was never entered). <br>// <br>//  Return (int): <br>//      The return value is usually nResult--be we give this function the <br>//      opportunity to modify its value. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNGLOBAL AppExit <br>( <br>    HINSTANCE       hinst, <br>    int             nResult <br>) <br>{ <br>    DPF(0, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult); <br> <br>    // <br>    // <br>    // <br>    // <br> <br>    return (nResult); <br>} // AppExit() <br> <br> <br>//==========================================================================; <br>// <br>//  Main entry and message dispatching code <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int WinMain <br>// <br>//  Description: <br>//      This function is called by the system as the initial entry point <br>//      for a Windows application. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      This string is strictly ANSI regardless of whether the application <br>//      is built for Unicode. To get the Unicode equivalent call the <br>//      GetCommandLine() function (Win 32 only). <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (int): <br>//      Returns result from WM_QUIT message (in wParam of MSG structure) if <br>//      the application is able to enter its message loop. Returns 0 if <br>//      the application is not able to enter its message loop. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int PASCAL WinMain <br>( <br>    HINSTANCE       hinst, <br>    HINSTANCE       hinstPrev, <br>    LPSTR           pszCmdLine, <br>    int             nCmdShow <br>) <br>{ <br>    int     nResult; <br>    HWND    hwnd; <br>    MSG     msg; <br>    HACCEL  haccl; <br> <br>    // <br>    //  our documentation states that WinMain is supposed to return 0 if <br>    //  we do not enter our message loop--so assume the worst... <br>    // <br>    nResult = 0; <br> <br>    // <br>    //  make our instance handle global for convenience.. <br>    // <br>    ghinst = hinst; <br> <br>    // <br>    //  init some stuff, create window, etc.. note the explicit cast of <br>    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when <br>    //  compiling for Unicode. see AppInit() for more details. <br>    // <br>    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow); <br>    if (hwnd) <br>    { <br>haccl = LoadAccelerators(hinst, ACCEL_APP); <br> <br>// <br>//  dispatch messages <br>// <br>while (GetMessage(&amp;msg, NULL, 0, 0)) <br>{ <br>    // <br>    //  do all the special stuff required for this application <br>    //  when dispatching messages.. <br>    // <br>    if (!TranslateAccelerator(hwnd, haccl, &amp;msg)) <br>    { <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>    } <br>} <br> <br>// <br>//  return result of WM_QUIT message. <br>// <br>nResult = (int)msg.wParam; <br>    } <br> <br>    // <br>    //  shut things down, clean up, etc. <br>    // <br>    nResult = AppExit(hinst, nResult); <br> <br>    return (nResult); <br>} // WinMain() </code></pre>
<p>&nbsp;</p></body>
</HTML>
