<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOWLEVEL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2564"></a>LOWLEVEL.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>//  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br>//  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br>//  A PARTICULAR PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  lowlevel.c <br>// <br>//  Description: <br>// <br>// <br>//  History: <br>//       5/16/93 <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br> <br>//#include "msmixmgr.h" <br> <br>#include "appport.h" <br>#include "mmcaps.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>// <br>// <br>TCHAR       gszDeviceFormatTitle[]  = TEXT("Type\t8!Index\t5!Version\t7!Product Name"); <br>TCHAR       gszDeviceFormatList[]   = TEXT("%-9s\t%d\t%u.%.02u\t%-32s"); <br> <br> <br>// <br>// <br>// <br>// <br>TCHAR       gszBogusCaps[]       = TEXT("????"); <br>TCHAR       gszTimerDevice[]     = TEXT("Internal PC Timer"); <br>TCHAR       gszDefaultMapper[]   = TEXT("Default Mapper"); <br> <br> <br>#define MMCAPS_DEVTYPE_UNKNOWN      0 <br>#define MMCAPS_DEVTYPE_AUXILIARY    1 <br>#define MMCAPS_DEVTYPE_JOYSTICK     2 <br>#define MMCAPS_DEVTYPE_MIDIIN       3 <br>#define MMCAPS_DEVTYPE_MIDIOUT      4 <br>#define MMCAPS_DEVTYPE_MIXER        5 <br>#define MMCAPS_DEVTYPE_TIMER        6 <br>#define MMCAPS_DEVTYPE_WAVEIN       7 <br>#define MMCAPS_DEVTYPE_WAVEOUT      8 <br> <br>PTSTR gaszDeviceType[] = <br>{ <br>    gszUnknown, <br>    TEXT("Auxiliary"), <br>    TEXT("Joystick"), <br>    TEXT("MIDI In"), <br>    TEXT("MIDI Out"), <br>    TEXT("Mixer"), <br>    TEXT("Timer"), <br>    TEXT("Wave In"), <br>    TEXT("Wave Out") <br>}; <br> <br> <br> <br> <br> <br>// <br>//  AUXCAPS <br>// <br>// <br>// <br>PTSTR gaszAuxCapsTechnology[] = <br>{ <br>    gszNotSpecified,                // <br>    TEXT("CD-Audio"),               // AUXCAPS_CDAUDIO <br>    TEXT("Auxiliary Input")         // AUXCAPS_AUXIN <br>}; <br> <br>#define AUXCAPS_TECHNOLOGY_LAST     AUXCAPS_AUXIN <br> <br> <br>PTSTR gaszAuxCapsSupport[32] = <br>{ <br>    TEXT("Volume"),         // Bit 0    AUXCAPS_VOLUME <br>    TEXT("L/R Volume"),     // Bit 1    AUXCAPS_LRVOLUME <br>    NULL,                   // Bit 2 <br>    NULL,                   // Bit 3 <br>    NULL,                   // Bit 4 <br>    NULL,                   // Bit 5 <br>    NULL,                   // Bit 6 <br>    NULL,                   // Bit 7 <br>    NULL,                   // Bit 8 <br>    NULL,                   // Bit 9 <br>    NULL,                   // Bit 10 <br>    NULL,                   // Bit 11 <br>    NULL,                   // Bit 12 <br>    NULL,                   // Bit 13 <br>    NULL,                   // Bit 14 <br>    NULL,                   // Bit 15 <br>    NULL,                   // Bit 16 <br>    NULL,                   // Bit 17 <br>    NULL,                   // Bit 18 <br>    NULL,                   // Bit 19 <br>    NULL,                   // Bit 20 <br>    NULL,                   // Bit 21 <br>    NULL,                   // Bit 22 <br>    NULL,                   // Bit 23 <br>    NULL,                   // Bit 24 <br>    NULL,                   // Bit 25 <br>    NULL,                   // Bit 26 <br>    NULL,                   // Bit 27 <br>    NULL,                   // Bit 28 <br>    NULL,                   // Bit 29 <br>    NULL,                   // Bit 30 <br>    NULL                    // Bit 31 <br>}; <br> <br> <br> <br>// <br>//  MIDI[IN|OUT]CAPS <br>// <br>// <br>// <br>PTSTR gaszMidiOutCapsTechnology[] = <br>{ <br>    gszNotSpecified, <br>    TEXT("MIDI Port"),                  // MOD_MIDIPORT <br>    TEXT("Internal Synth"),             // MOD_SYNTH    <br>    TEXT("Internal Square Wave Synth"), // MOD_SQSYNTH  <br>    TEXT("Internal FM Synth"),          // MOD_FMSYNTH  <br>    TEXT("MIDI Mapper")                 // MOD_MAPPER   <br>}; <br> <br>#define MIDIOUTCAPS_TECHNOLOGY_LAST     MOD_MAPPER <br> <br> <br>PTSTR gaszMidiOutCapsSupport[32] = <br>{ <br>    TEXT("Volume"),         // Bit 0    MIDICAPS_VOLUME <br>    TEXT("L/R Volume"),     // Bit 1    MIDICAPS_LRVOLUME <br>    TEXT("Patch Caching"),  // Bit 2    MIDICAPS_CACHE <br>    TEXT("Poly Message"),   // Bit 3    MIDICAPS_POLYMSG (Win 4) <br>    NULL,                   // Bit 4 <br>    NULL,                   // Bit 5 <br>    NULL,                   // Bit 6 <br>    NULL,                   // Bit 7 <br>    NULL,                   // Bit 8 <br>    NULL,                   // Bit 9 <br>    NULL,                   // Bit 10 <br>    NULL,                   // Bit 11 <br>    NULL,                   // Bit 12 <br>    NULL,                   // Bit 13 <br>    NULL,                   // Bit 14 <br>    NULL,                   // Bit 15 <br>    NULL,                   // Bit 16 <br>    NULL,                   // Bit 17 <br>    NULL,                   // Bit 18 <br>    NULL,                   // Bit 19 <br>    NULL,                   // Bit 20 <br>    NULL,                   // Bit 21 <br>    NULL,                   // Bit 22 <br>    NULL,                   // Bit 23 <br>    NULL,                   // Bit 24 <br>    NULL,                   // Bit 25 <br>    NULL,                   // Bit 26 <br>    NULL,                   // Bit 27 <br>    NULL,                   // Bit 28 <br>    NULL,                   // Bit 29 <br>    NULL,                   // Bit 30 <br>    NULL                    // Bit 31 <br>}; <br> <br> <br> <br> <br>// <br>//  MIXERCAPS <br>// <br>// <br>// <br>PTSTR gaszMixerCapsSupport[32] = <br>{ <br>    NULL,                   // Bit 0 <br>    NULL,                   // Bit 1 <br>    NULL,                   // Bit 2 <br>    NULL,                   // Bit 3 <br>    NULL,                   // Bit 4 <br>    NULL,                   // Bit 5 <br>    NULL,                   // Bit 6 <br>    NULL,                   // Bit 7 <br>    NULL,                   // Bit 8 <br>    NULL,                   // Bit 9 <br>    NULL,                   // Bit 10 <br>    NULL,                   // Bit 11 <br>    NULL,                   // Bit 12 <br>    NULL,                   // Bit 13 <br>    NULL,                   // Bit 14 <br>    NULL,                   // Bit 15 <br>    NULL,                   // Bit 16 <br>    NULL,                   // Bit 17 <br>    NULL,                   // Bit 18 <br>    NULL,                   // Bit 19 <br>    NULL,                   // Bit 20 <br>    NULL,                   // Bit 21 <br>    NULL,                   // Bit 22 <br>    NULL,                   // Bit 23 <br>    NULL,                   // Bit 24 <br>    NULL,                   // Bit 25 <br>    NULL,                   // Bit 26 <br>    NULL,                   // Bit 27 <br>    NULL,                   // Bit 28 <br>    NULL,                   // Bit 29 <br>    NULL,                   // Bit 30 <br>    NULL                    // Bit 31 <br>}; <br> <br> <br> <br> <br> <br>// <br>//  WAVE[IN|OUT]CAPS <br>// <br>// <br>// <br>PTSTR gaszWaveInOutCapsFormats[32] = <br>{ <br>    TEXT("8M11"),           // Bit 0    WAVE_FORMAT_1M08 <br>    TEXT("8S11"),           // Bit 1    WAVE_FORMAT_1S08 <br>    TEXT("16M11"),          // Bit 2    WAVE_FORMAT_1M16 <br>    TEXT("16S11"),          // Bit 3    WAVE_FORMAT_1S16 <br>    TEXT("8M22"),           // Bit 4    WAVE_FORMAT_2M08 <br>    TEXT("8S22"),           // Bit 5    WAVE_FORMAT_2S08 <br>    TEXT("16M22"),          // Bit 6    WAVE_FORMAT_2M16 <br>    TEXT("16S22"),          // Bit 7    WAVE_FORMAT_2S16 <br>    TEXT("8M44"),           // Bit 8    WAVE_FORMAT_4M08 <br>    TEXT("8S44"),           // Bit 9    WAVE_FORMAT_4S08 <br>    TEXT("16M44"),          // Bit 10   WAVE_FORMAT_4M16 <br>    TEXT("16S44"),          // Bit 11   WAVE_FORMAT_4S16 <br>    NULL,                   // Bit 12 <br>    NULL,                   // Bit 13 <br>    NULL,                   // Bit 14 <br>    NULL,                   // Bit 15 <br>    NULL,                   // Bit 16 <br>    NULL,                   // Bit 17 <br>    NULL,                   // Bit 18 <br>    NULL,                   // Bit 19 <br>    NULL,                   // Bit 20 <br>    NULL,                   // Bit 21 <br>    NULL,                   // Bit 22 <br>    NULL,                   // Bit 23 <br>    NULL,                   // Bit 24 <br>    NULL,                   // Bit 25 <br>    NULL,                   // Bit 26 <br>    NULL,                   // Bit 27 <br>    NULL,                   // Bit 28 <br>    NULL,                   // Bit 29 <br>    NULL,                   // Bit 30 <br>    NULL                    // Bit 31 <br>}; <br> <br>PTSTR gaszWaveOutCapsSupport[32] = <br>{ <br>    TEXT("Pitch"),          // Bit 0    WAVECAPS_PITCH <br>    TEXT("Playback Rate"),  // Bit 1    WAVECAPS_PLAYBACKRATE <br>    TEXT("Volume"),         // Bit 2    WAVECAPS_VOLUME <br>    TEXT("L/R Volume"),     // Bit 3    WAVECAPS_LRVOLUME <br>    TEXT("Sync"),           // Bit 4    WAVECAPS_SYNC <br>    NULL,                   // Bit 5 <br>    NULL,                   // Bit 6 <br>    NULL,                   // Bit 7 <br>    NULL,                   // Bit 8 <br>    NULL,                   // Bit 9 <br>    NULL,                   // Bit 10 <br>    NULL,                   // Bit 11 <br>    NULL,                   // Bit 12 <br>    NULL,                   // Bit 13 <br>    NULL,                   // Bit 14 <br>    NULL,                   // Bit 15 <br>    NULL,                   // Bit 16 <br>    NULL,                   // Bit 17 <br>    NULL,                   // Bit 18 <br>    NULL,                   // Bit 19 <br>    NULL,                   // Bit 20 <br>    NULL,                   // Bit 21 <br>    NULL,                   // Bit 22 <br>    NULL,                   // Bit 23 <br>    NULL,                   // Bit 24 <br>    NULL,                   // Bit 25 <br>    NULL,                   // Bit 26 <br>    NULL,                   // Bit 27 <br>    NULL,                   // Bit 28 <br>    NULL,                   // Bit 29 <br>    NULL,                   // Bit 30 <br>    NULL                    // Bit 31 <br>}; <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailAuxiliary <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailAuxiliary <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    PSTR            psz; <br>    MMRESULT        mmr; <br>    AUXCAPS         ac; <br>    UINT            u; <br>    DWORD           dw; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_AUXILIARY]); <br> <br>    if (-1 == nDevId) <br>AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId); <br>    else <br>AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br> <br> <br>    // <br>    // <br>    // <br>    mmr = auxGetDevCaps(nDevId, &amp;ac, sizeof(ac)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>_fmemset(&amp;ac, 0, sizeof(ac)); <br>if (-1 != nDevId) <br>{ <br>    lstrcpy(ac.szPname, gszBogusCaps); <br>} <br>else <br>{ <br>    if (0 != auxGetNumDevs()) <br>    { <br>ac.wMid           = MM_MICROSOFT; <br>ac.vDriverVersion = (MMVERSION)GetVersion(); <br>lstrcpy(ac.szPname, gszDefaultMapper); <br>mmr = MMSYSERR_NOERROR; <br>    } <br>} <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)ac.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(ac.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(ac.wMid, NULL, ac.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (ac.vDriverVersion &gt;&gt; 8), (BYTE)ac.vDriverVersion); <br> <br> <br>    if (ac.wTechnology &gt; AUXCAPS_TECHNOLOGY_LAST) <br>    { <br>wsprintf(ach, "[%u], Unknown", ac.wTechnology); <br>psz = ach; <br>    } <br>    else <br>    { <br>psz = gaszAuxCapsTechnology[ac.wTechnology]; <br>    } <br> <br>    AppMEditPrintF(hedit, "       Technology: %s\r\n", (LPSTR)psz); <br> <br>    // <br>    // <br>    // <br>    // <br>    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", ac.dwSupport); <br>    for (u = 0, dw = ac.dwSupport; dw; u++) <br>    { <br>if ((BYTE)dw &amp; (BYTE)1) <br>{ <br>    psz = gaszAuxCapsSupport[u]; <br>    if (NULL == psz) <br>    { <br>wsprintf(ach, "Unknown%u", u); <br>psz = ach; <br>    } <br> <br>    AppMEditPrintF(hedit, ", %s", (LPSTR)psz); <br>} <br> <br>dw &gt;&gt;= 1; <br>    } <br>    AppMEditPrintF(hedit, "\r\n"); <br> <br>    return (TRUE); <br>} // MMCapsDetailAuxiliary() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailJoystick <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailJoystick <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    MMRESULT        mmr; <br>    JOYCAPS         jc; <br> <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_JOYSTICK]); <br> <br>    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br> <br> <br>    // <br>    // <br>    // <br>    mmr = joyGetDevCaps(nDevId, &amp;jc, sizeof(jc)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>lstrcpy(jc.szPname, gszBogusCaps); <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)jc.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(jc.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(jc.wMid, NULL, jc.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: (sigh)\r\n"); <br> <br>    AppMEditPrintF(hedit, "          Buttons: %u\r\n", jc.wNumButtons); <br>    AppMEditPrintF(hedit, "    Minimum X Pos: %u\r\n", jc.wXmin); <br>    AppMEditPrintF(hedit, "    Maximum X Pos: %u\r\n", jc.wXmax); <br>    AppMEditPrintF(hedit, "    Minimum Y Pos: %u\r\n", jc.wYmin); <br>    AppMEditPrintF(hedit, "    Maximum Y Pos: %u\r\n", jc.wYmax); <br>    AppMEditPrintF(hedit, "    Minimum Z Pos: %u\r\n", jc.wZmin); <br>    AppMEditPrintF(hedit, "    Maximum Z Pos: %u\r\n", jc.wZmax); <br>    AppMEditPrintF(hedit, "   Minimum Period: %u\r\n", jc.wPeriodMin); <br>    AppMEditPrintF(hedit, "   Maximum Period: %u\r\n", jc.wPeriodMax); <br> <br> <br>    return (TRUE); <br>} // MMCapsDetailJoystick() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailMidiIn <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailMidiIn <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    MMRESULT        mmr; <br>    MIDIINCAPS      mic; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIDIIN]); <br> <br>    if (-1 == nDevId) <br>AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId); <br>    else <br>AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br> <br> <br>    // <br>    // <br>    // <br>    mmr = midiInGetDevCaps(nDevId, &amp;mic, sizeof(mic)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>_fmemset(&amp;mic, 0, sizeof(mic)); <br>if (-1 != nDevId) <br>{ <br>    lstrcpy(mic.szPname, gszBogusCaps); <br>} <br>else <br>{ <br>    if (0 != midiInGetNumDevs()) <br>    { <br>mic.wMid           = MM_MICROSOFT; <br>mic.vDriverVersion = (MMVERSION)GetVersion(); <br>lstrcpy(mic.szPname, gszDefaultMapper); <br>mmr = MMSYSERR_NOERROR; <br>    } <br>} <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)mic.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(mic.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(mic.wMid, NULL, mic.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (mic.vDriverVersion &gt;&gt; 8), (BYTE)mic.vDriverVersion); <br> <br>    return (TRUE); <br>} // MMCapsDetailMidiIn() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailMidiOut <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailMidiOut <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    PSTR            psz; <br>    MMRESULT        mmr; <br>    MIDIOUTCAPS     moc; <br>    UINT            u; <br>    DWORD           dw; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIDIOUT]); <br> <br>    if (-1 == nDevId) <br>AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId); <br>    else <br>AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br> <br> <br>    // <br>    // <br>    // <br>    mmr = midiOutGetDevCaps(nDevId, &amp;moc, sizeof(moc)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>_fmemset(&amp;moc, 0, sizeof(moc)); <br>if (-1 != nDevId) <br>{ <br>    lstrcpy(moc.szPname, gszBogusCaps); <br>} <br>else <br>{ <br>    if (0 != midiOutGetNumDevs()) <br>    { <br>moc.wMid           = MM_MICROSOFT; <br>moc.vDriverVersion = (MMVERSION)GetVersion(); <br>lstrcpy(moc.szPname, gszDefaultMapper); <br>mmr = MMSYSERR_NOERROR; <br>    } <br>} <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)moc.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(moc.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(moc.wMid, NULL, moc.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (moc.vDriverVersion &gt;&gt; 8), (BYTE)moc.vDriverVersion); <br> <br> <br>    if (moc.wTechnology &gt; MIDIOUTCAPS_TECHNOLOGY_LAST) <br>    { <br>wsprintf(ach, "[%u], Unknown", moc.wTechnology); <br>psz = ach; <br>    } <br>    else <br>    { <br>psz = gaszMidiOutCapsTechnology[moc.wTechnology]; <br>    } <br> <br>    AppMEditPrintF(hedit, "       Technology: %s\r\n", (LPSTR)psz); <br>    AppMEditPrintF(hedit, " Voices (Patches): %u (if internal synth)\r\n", moc.wVoices); <br>    AppMEditPrintF(hedit, "        Polyphony: %u (if internal synth)\r\n", moc.wNotes); <br>    AppMEditPrintF(hedit, "     Channel Mask: %.04Xh (if internal synth)\r\n", moc.wChannelMask); <br> <br>    // <br>    // <br>    // <br>    // <br>    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", moc.dwSupport); <br>    for (u = 0, dw = moc.dwSupport; dw; u++) <br>    { <br>if ((BYTE)dw &amp; (BYTE)1) <br>{ <br>    psz = gaszMidiOutCapsSupport[u]; <br>    if (NULL == psz) <br>    { <br>wsprintf(ach, "Unknown%u", u); <br>psz = ach; <br>    } <br> <br>    AppMEditPrintF(hedit, ", %s", (LPSTR)psz); <br>} <br> <br>dw &gt;&gt;= 1; <br>    } <br>    AppMEditPrintF(hedit, "\r\n"); <br> <br>    return (TRUE); <br>} // MMCapsDetailMidiOut() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailMixer <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailMixer <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    PSTR            psz; <br>    MMRESULT        mmr; <br>    MIXERCAPS       mxc; <br>    UINT            u; <br>    DWORD           dw; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_MIXER]); <br> <br>#ifdef MIXER_MAPPER <br>    if (-1 == nDevId) <br>AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId); <br>    else <br>AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br>#else <br>    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    mmr = mixerGetDevCaps(nDevId, &amp;mxc, sizeof(mxc)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>_fmemset(&amp;mxc, 0, sizeof(mxc)); <br>if (-1 != nDevId) <br>{ <br>    lstrcpy(mxc.szPname, gszBogusCaps); <br>} <br>else <br>{ <br>    if (0 != mixerGetNumDevs()) <br>    { <br>mxc.wMid           = MM_MICROSOFT; <br>mxc.vDriverVersion = (MMVERSION)GetVersion(); <br>lstrcpy(mxc.szPname, gszDefaultMapper); <br>mmr = MMSYSERR_NOERROR; <br>    } <br>} <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)mxc.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(mxc.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(mxc.wMid, NULL, mxc.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (mxc.vDriverVersion &gt;&gt; 8), (BYTE)mxc.vDriverVersion); <br> <br>    AppMEditPrintF(hedit, "     Destinations: %u\r\n", mxc.cDestinations); <br> <br>    // <br>    // <br>    // <br>    // <br>    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", mxc.fdwSupport); <br>    for (u = 0, dw = mxc.fdwSupport; dw; u++) <br>    { <br>if ((BYTE)dw &amp; (BYTE)1) <br>{ <br>    psz = gaszMixerCapsSupport[u]; <br>    if (NULL == psz) <br>    { <br>wsprintf(ach, "Unknown%u", u); <br>psz = ach; <br>    } <br> <br>    AppMEditPrintF(hedit, ", %s", (LPSTR)psz); <br>} <br> <br>dw &gt;&gt;= 1; <br>    } <br>    AppMEditPrintF(hedit, "\r\n"); <br> <br>    return (TRUE); <br>} // MMCapsDetailMixer() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailTimer <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailTimer <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    MMRESULT        mmr; <br>    TIMECAPS        tc; <br>    MMVERSION       uMMSysVer; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_TIMER]); <br> <br>    AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)gszTimerDevice); <br> <br>    mmr = timeGetDevCaps(&amp;tc, sizeof(tc)); <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    uMMSysVer = (MMVERSION)GetVersion(); <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (uMMSysVer &gt;&gt; 8), (BYTE)uMMSysVer); <br> <br>    AppMEditPrintF(hedit, "   Minimum Period: %u\r\n", tc.wPeriodMin); <br>    AppMEditPrintF(hedit, "   Maximum Period: %u\r\n", tc.wPeriodMax); <br> <br>    return (TRUE); <br>} // MMCapsDetailTimer() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailWaveIn <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailWaveIn <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    PSTR            psz; <br>    MMRESULT        mmr; <br>    WAVEINCAPS      wic; <br>    UINT            u; <br>    DWORD           dw; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_WAVEIN]); <br> <br>    if (-1 == nDevId) <br>AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId); <br>    else <br>AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br> <br> <br>    // <br>    // <br>    // <br>    mmr = waveInGetDevCaps(nDevId, &amp;wic, sizeof(wic)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>_fmemset(&amp;wic, 0, sizeof(wic)); <br>if (-1 != nDevId) <br>{ <br>    lstrcpy(wic.szPname, gszBogusCaps); <br>} <br>else <br>{ <br>    if (0 != waveInGetNumDevs()) <br>    { <br>wic.wMid           = MM_MICROSOFT; <br>wic.vDriverVersion = (MMVERSION)GetVersion(); <br>lstrcpy(wic.szPname, gszDefaultMapper); <br>mmr = MMSYSERR_NOERROR; <br>    } <br>} <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)wic.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(wic.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(wic.wMid, NULL, wic.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (wic.vDriverVersion &gt;&gt; 8), (BYTE)wic.vDriverVersion); <br> <br>    AppMEditPrintF(hedit, "         Channels: %u\r\n", wic.wChannels); <br> <br>    // <br>    // <br>    // <br>    // <br>    AppMEditPrintF(hedit, " Standard Formats: [%.08lXh]", wic.dwFormats); <br>    for (u = 0, dw = wic.dwFormats; dw; u++) <br>    { <br>if ((BYTE)dw &amp; (BYTE)1) <br>{ <br>    psz = gaszWaveInOutCapsFormats[u]; <br>    if (NULL == psz) <br>    { <br>wsprintf(ach, "Unknown%u", u); <br>psz = ach; <br>    } <br> <br>    AppMEditPrintF(hedit, ", %s", (LPSTR)psz); <br>} <br> <br>dw &gt;&gt;= 1; <br>    } <br>    AppMEditPrintF(hedit, "\r\n"); <br> <br> <br>    return (TRUE); <br>} // MMCapsDetailWaveIn() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailWaveOut <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>//   <br>//      int nDevId: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/11/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MMCapsDetailWaveOut <br>( <br>    HWND            hedit, <br>    int             nDevId <br>) <br>{ <br>    TCHAR           ach[MMCAPS_MAX_STRING_MIDPID_CHARS]; <br>    PSTR            psz; <br>    MMRESULT        mmr; <br>    WAVEOUTCAPS     woc; <br>    UINT            u; <br>    DWORD           dw; <br> <br>    AppMEditPrintF(hedit, "      Device Type: %s\r\n", <br> (LPSTR)gaszDeviceType[MMCAPS_DEVTYPE_WAVEOUT]); <br> <br>    if (-1 == nDevId) <br>AppMEditPrintF(hedit, "       Index (Id): %d (Mapper)\r\n", nDevId); <br>    else <br>AppMEditPrintF(hedit, "       Index (Id): %d\r\n", nDevId); <br> <br> <br>    // <br>    // <br>    // <br>    mmr = waveOutGetDevCaps(nDevId, &amp;woc, sizeof(woc)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>_fmemset(&amp;woc, 0, sizeof(woc)); <br>if (-1 != nDevId) <br>{ <br>    lstrcpy(woc.szPname, gszBogusCaps); <br>} <br>else <br>{ <br>    if (0 != waveOutGetNumDevs()) <br>    { <br>woc.wMid           = MM_MICROSOFT; <br>woc.vDriverVersion = (MMVERSION)GetVersion(); <br>lstrcpy(woc.szPname, gszDefaultMapper); <br>mmr = MMSYSERR_NOERROR; <br>    } <br>} <br>    } <br> <br>    AppMEditPrintF(hedit, "     Product Name: %s\r\n", (LPSTR)woc.szPname); <br> <br>    if (MMSYSERR_NOERROR != mmr) <br>return (TRUE); <br> <br>    // <br>    // <br>    // <br>    // <br>    MMCapsMidAndPid(woc.wMid, ach, 0, NULL); <br>    AppMEditPrintF(hedit, "  Manufacturer Id: %s\r\n", (LPSTR)ach); <br> <br>    MMCapsMidAndPid(woc.wMid, NULL, woc.wPid, ach); <br>    AppMEditPrintF(hedit, "       Product Id: %s\r\n", (LPSTR)ach); <br> <br>    AppMEditPrintF(hedit, "   Driver Version: %u.%.02u\r\n", <br> (woc.vDriverVersion &gt;&gt; 8), (BYTE)woc.vDriverVersion); <br> <br>    AppMEditPrintF(hedit, "         Channels: %u\r\n", woc.wChannels); <br> <br>    // <br>    // <br>    // <br>    // <br>    AppMEditPrintF(hedit, " Standard Formats: [%.08lXh]", woc.dwFormats); <br>    for (u = 0, dw = woc.dwFormats; dw; u++) <br>    { <br>if ((BYTE)dw &amp; (BYTE)1) <br>{ <br>    psz = gaszWaveInOutCapsFormats[u]; <br>    if (NULL == psz) <br>    { <br>wsprintf(ach, "Unknown%u", u); <br>psz = ach; <br>    } <br> <br>    AppMEditPrintF(hedit, ", %s", (LPSTR)psz); <br>} <br> <br>dw &gt;&gt;= 1; <br>    } <br>    AppMEditPrintF(hedit, "\r\n"); <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    AppMEditPrintF(hedit, " Standard Support: [%.08lXh]", woc.dwSupport); <br>    for (u = 0, dw = woc.dwSupport; dw; u++) <br>    { <br>if ((BYTE)dw &amp; (BYTE)1) <br>{ <br>    psz = gaszWaveOutCapsSupport[u]; <br>    if (NULL == psz) <br>    { <br>wsprintf(ach, "Unknown%u", u); <br>psz = ach; <br>    } <br> <br>    AppMEditPrintF(hedit, ", %s", (LPSTR)psz); <br>} <br> <br>dw &gt;&gt;= 1; </code></pre>
<p>
</p>
<pre><code>} <br>    AppMEditPrintF(hedit, "\r\n"); <br> <br>    return (TRUE); <br>} // MMCapsDetailWaveOut() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsDetailLowLevel <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      HWND hedit: <br>// <br>//      LPARAM lParam: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/16/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MMCapsDetailLowLevel <br>( <br>    HWND            hedit, <br>    LPARAM          lParam <br>) <br>{ <br>    int         nDevId; <br>    UINT        uDevType; <br> <br>    // <br>    //  HIWORD(lParam): MMCAPS_DEVTYPE_* <br>    //  LOWORD(lParam): Device index (id) <br>    // <br>    nDevId   = (int)(short)LOWORD(lParam); <br>    uDevType = HIWORD(lParam); <br> <br>    // <br>    // <br>    // <br>    // <br>    switch (uDevType) <br>    { <br>case MMCAPS_DEVTYPE_AUXILIARY: <br>    MMCapsDetailAuxiliary(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_JOYSTICK: <br>    MMCapsDetailJoystick(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_MIDIIN: <br>    MMCapsDetailMidiIn(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_MIDIOUT: <br>    MMCapsDetailMidiOut(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_MIXER: <br>    MMCapsDetailMixer(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_TIMER: <br>    MMCapsDetailTimer(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_WAVEIN: <br>    MMCapsDetailWaveIn(hedit, nDevId); <br>    break; <br> <br>case MMCAPS_DEVTYPE_WAVEOUT: <br>    MMCapsDetailWaveOut(hedit, nDevId); <br>    break; <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    return (TRUE); <br>} // MMCapsDetailLowLevel() <br> <br> <br>//--------------------------------------------------------------------------; <br>//   <br>//  BOOL MMCapsEnumerateLowLevel <br>//   <br>//  Description: <br>//   <br>//   <br>//  Arguments: <br>//      PZYZTABBEDLISTBOX ptlb: <br>//   <br>//      BOOL fComplete: <br>//   <br>//  Return (BOOL): <br>//   <br>//  History: <br>//      05/18/93 <br>//   <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MMCapsEnumerateLowLevel <br>( <br>    PZYZTABBEDLISTBOX   ptlb, <br>    BOOL                fComplete <br>) <br>{ <br>    TCHAR       ach[128]; <br>    MMRESULT    mmr; <br>    int         n; <br>    int         nDevs; <br>    int         nIndex; <br>    LPARAM      lParam; <br>    UINT        uDevType; <br>    MMVERSION   uMMSysVer; <br>    HWND        hlb; <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    // <br>    if (fComplete) <br>    { <br>TlbSetTitleAndTabs(ptlb, gszDeviceFormatTitle, FALSE); <br>    } <br> <br>    hlb = ptlb-&gt;hlb; <br> <br>    uMMSysVer = (MMVERSION)GetVersion(); <br> <br> <br>    // <br>    // <br>    // <br>    nDevs = auxGetNumDevs(); <br>    for (n = -1; n &lt; nDevs; n++) <br>    { <br>AUXCAPS         ac; <br> <br>mmr = auxGetDevCaps(n, &amp;ac, sizeof(ac)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    if (-1 != n) <br>    { <br>ac.vDriverVersion = 0; <br>lstrcpy(ac.szPname, gszBogusCaps); <br>    } <br>    else <br>    { <br>if (0 == nDevs) <br>    break; <br> <br>ac.vDriverVersion = uMMSysVer; <br>lstrcpy(ac.szPname, gszDefaultMapper); <br>    } <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_AUXILIARY; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, (ac.vDriverVersion &gt;&gt; 8), (BYTE)ac.vDriverVersion, <br> (LPSTR)ac.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    nDevs = joyGetNumDevs(); <br>    for (n = 0; n &lt; nDevs; n++) <br>    { <br>JOYCAPS         jc; <br> <br>mmr = joyGetDevCaps(n, &amp;jc, sizeof(jc)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    lstrcpy(jc.szPname, gszBogusCaps); <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_JOYSTICK; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, 0, 0, (LPSTR)jc.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br> <br> <br> <br>    // <br>    // <br>    // <br>    nDevs = midiInGetNumDevs(); <br>    for (n = -1; n &lt; nDevs; n++) <br>    { <br>MIDIINCAPS      mic; <br> <br>mmr = midiInGetDevCaps(n, &amp;mic, sizeof(mic)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    if (-1 != n) <br>    { <br>mic.vDriverVersion = 0; <br>lstrcpy(mic.szPname, gszBogusCaps); <br>    } <br>    else <br>    { <br>if (0 == nDevs) <br>    break; <br> <br>mic.vDriverVersion = uMMSysVer; <br>lstrcpy(mic.szPname, gszDefaultMapper); <br>    } <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_MIDIIN; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, (mic.vDriverVersion &gt;&gt; 8), (BYTE)mic.vDriverVersion, <br> (LPSTR)mic.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br> <br>    // <br>    // <br>    // <br>    nDevs = midiOutGetNumDevs(); <br>    for (n = -1; n &lt; nDevs; n++) <br>    { <br>MIDIOUTCAPS     moc; <br> <br>mmr = midiOutGetDevCaps(n, &amp;moc, sizeof(moc)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    if (-1 != n) <br>    { <br>moc.vDriverVersion = 0; <br>lstrcpy(moc.szPname, gszBogusCaps); <br>    } <br>    else <br>    { <br>if (0 == nDevs) <br>    break; <br> <br>moc.vDriverVersion = uMMSysVer; <br>lstrcpy(moc.szPname, gszDefaultMapper); <br>    } <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_MIDIOUT; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, (moc.vDriverVersion &gt;&gt; 8), (BYTE)moc.vDriverVersion, <br> (LPSTR)moc.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    // <br>#ifndef WIN32 <br>    nDevs = mixerGetNumDevs(); <br>#ifdef MIXER_MAPPER <br>    for (n = -1; n &lt; nDevs; n++) <br>#else <br>    for (n = 0; n &lt; nDevs; n++) <br>#endif <br>    { <br>MIXERCAPS       mxc; <br> <br>mmr = mixerGetDevCaps(n, &amp;mxc, sizeof(mxc)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    if (-1 != n) <br>    { <br>mxc.vDriverVersion = 0; <br>lstrcpy(mxc.szPname, gszBogusCaps); <br>    } <br>    else <br>    { <br>if (0 == nDevs) <br>    break; <br> <br>mxc.vDriverVersion = uMMSysVer; <br>lstrcpy(mxc.szPname, gszDefaultMapper); <br>    } <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_MIXER; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, (mxc.vDriverVersion &gt;&gt; 8), (BYTE)mxc.vDriverVersion, <br> (LPSTR)mxc.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br>#endif <br> <br> <br> <br>    // <br>    // <br>    // <br>    { <br>TIMECAPS    tc; <br> <br>mmr = timeGetDevCaps(&amp;tc, sizeof(tc)); <br>if (MMSYSERR_NOERROR == mmr) <br>{ <br>    // <br>    // <br>    // <br>    uDevType = MMCAPS_DEVTYPE_TIMER; <br>    wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br>     0, (uMMSysVer &gt;&gt; 8), (BYTE)uMMSysVer, <br>     (LPSTR)gszTimerDevice); <br> <br>    nIndex = ListBox_AddString(hlb, ach); <br>    lParam = MAKELPARAM(0, (WORD)uDevType); <br>    ListBox_SetItemData(hlb, nIndex, lParam); <br>} <br>    } <br> <br> <br> <br>    // <br>    // <br>    // <br>    nDevs = waveInGetNumDevs(); <br>    for (n = -1; n &lt; nDevs; n++) <br>    { <br>WAVEINCAPS      wic; <br> <br>mmr = waveInGetDevCaps(n, &amp;wic, sizeof(wic)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    if (-1 != n) <br>    { <br>wic.vDriverVersion = 0; <br>lstrcpy(wic.szPname, gszBogusCaps); <br>    } <br>    else <br>    { <br>if (0 == nDevs) <br>    break; <br> <br>wic.vDriverVersion = uMMSysVer; <br>lstrcpy(wic.szPname, gszDefaultMapper); <br>    } <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_WAVEIN; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, (wic.vDriverVersion &gt;&gt; 8), (BYTE)wic.vDriverVersion, <br> (LPSTR)wic.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br> <br>    // <br>    // <br>    // <br>    nDevs = waveOutGetNumDevs(); <br>    for (n = -1; n &lt; nDevs; n++) <br>    { <br>WAVEOUTCAPS     woc; <br> <br>mmr = waveOutGetDevCaps(n, &amp;woc, sizeof(woc)); <br>if (MMSYSERR_NOERROR != mmr) <br>{ <br>    if (-1 != n) <br>    { <br>woc.vDriverVersion = 0; <br>lstrcpy(woc.szPname, gszBogusCaps); <br>    } <br>    else <br>    { <br>if (0 == nDevs) <br>    break; <br> <br>woc.vDriverVersion = uMMSysVer; <br>lstrcpy(woc.szPname, gszDefaultMapper); <br>    } <br>} <br> <br>// <br>// <br>// <br>uDevType = MMCAPS_DEVTYPE_WAVEOUT; <br>wsprintf(ach, gszDeviceFormatList, (LPSTR)gaszDeviceType[uDevType], <br> n, (woc.vDriverVersion &gt;&gt; 8), (BYTE)woc.vDriverVersion, <br> (LPSTR)woc.szPname); <br> <br>nIndex = ListBox_AddString(hlb, ach); <br>lParam = MAKELPARAM((WORD)n, (WORD)uDevType); <br>ListBox_SetItemData(hlb, nIndex, lParam); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    return (TRUE); <br>} // MMCapsEnumerateLowLevel() </code></pre>
<p>&nbsp;</p></body>
</HTML>
