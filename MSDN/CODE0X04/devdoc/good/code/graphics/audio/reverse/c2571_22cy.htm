<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REVERSE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2572"></a>REVERSE.C</h2>
<pre><code>/************************************************************************** <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br> *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br> *  PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br> * <br> **************************************************************************/ <br>/* reverse.c - WinMain() and WndProc() for REVERSE, along with <br> * initialization and support code. <br> * <br> * REVERSE is a Windows sample application that illustrates how to use <br> * the low-level waveform playback services. It also shows how to use <br> * the multimedia file I/O services to read data from a WAVE file. <br> * <br> * REVERSE plays a WAVE waveform audio file backwards. <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "reverse.h" <br>#include "strings.h" <br> <br>#define MAX_FILENAME_SIZE 128 <br> <br>/* Global variables. <br> */ <br>char     szAppName[]    = "Reverse";   // application name <br>HANDLEhInstApp = NULL;     // instance handle <br>HWND     hwndApp     = NULL;     // main window handle <br>HWND     hwndName = NULL;     // filename window handle <br>HWND     hwndPlay = NULL;     // "Play" button window handle <br>HWND     hwndQuit = NULL;     // "Exit" button window handle <br>HWAVEOUT hWaveOut = NULL; <br>LPWAVEHDR   lpWaveHdr   = NULL; <br>HPSTR    lpData      = NULL;     // waveform data block <br>LPSTR    lpstrLoadStrBuf   = NULL; <br> <br>/* WinMain - Entry point for Reverse. <br> */ <br>int PASCAL WinMain( <br>HINSTANCE hInst, <br>HINSTANCE hPrev, <br>LPSTR szCmdLine, <br>int cmdShow) <br>{ <br>   MSG      msg; <br>   WNDCLASS wc; <br> <br>   hInstApp =  hInst; <br> <br>   /* Define and register a window class for the main window. <br>    */ <br>   if (!hPrev) <br>   { <br>      wc.hCursor     = LoadCursor(NULL, IDC_ARROW); <br>      wc.hIcon    = LoadIcon(hInst, szAppName); <br>      wc.lpszMenuName      = szAppName; <br>      wc.lpszClassName  = szAppName; <br>      wc.hbrBackground  = GetStockBrush(LTGRAY_BRUSH); <br>      wc.hInstance      = hInst; <br>      wc.style    = 0; <br>      wc.lpfnWndProc    = WndProc; <br>      wc.cbWndExtra     = 0; <br>      wc.cbClsExtra     = 0; <br> <br>      if (!RegisterClass(&amp;wc)) <br>         return FALSE; <br>   } <br>   // Keep string memory out of WIN16 DS. <br>   lpstrLoadStrBuf = GlobalAllocPtr(GMEM_MOVEABLE, LOADSTRBUFSIZE); <br>   if(lpstrLoadStrBuf == NULL) <br>   { <br>      // don't use LoadString here; it fails when memory is low <br>      MessageBox(NULL, GetStringRes(IDS_NOMEM), <br>            NULL, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL); <br>      return FALSE; <br>   } <br>   /* Create and show the main window. <br>    */ <br>   LoadString(hInstApp, IDS_REVERSEWNDTITLE, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   hwndApp = CreateWindow (szAppName,  // class name <br>         lpstrLoadStrBuf,  // title from string resource <br>         WS_OVERLAPPEDWINDOW, // style bits <br>         CW_USEDEFAULT,    // x position <br>         CW_USEDEFAULT,    // y position <br>         WMAIN_DX,      // x size <br>         WMAIN_DY,      // y size <br>         (HWND)NULL,    // parent window <br>         (HMENU)NULL,      // use class menu <br>         (HANDLE)hInst,    // instance handle <br>         (LPSTR)NULL    // no params to pass on <br>         ); <br>   /* Create child windows for the "Play" and "Exit" buttons <br>    * and for an edit field to enter filenames. <br>    */ <br>   LoadString(hInstApp, IDS_PLAYBUTTONTEXT, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   hwndPlay = CreateWindow( "BUTTON", lpstrLoadStrBuf, <br>         WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <br>         PLAY_X, PLAY_Y, <br>         PLAY_DX, PLAY_DY, <br>         hwndApp, (HMENU)IDB_PLAY, hInstApp, NULL ); <br>   if( !hwndPlay ) <br>      return( FALSE ); <br> <br>   LoadString(hInstApp, IDS_EXITBUTTONTEXT, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   hwndQuit = CreateWindow( "BUTTON", lpstrLoadStrBuf, <br>         WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, <br>         QUIT_X, QUIT_Y, <br>         QUIT_DX, QUIT_DY, <br>         hwndApp, (HMENU)IDB_QUIT, hInstApp, NULL ); <br>   if( !hwndQuit ) <br>      return( FALSE ); <br> <br>   hwndName = CreateWindow("EDIT","", <br>         WS_CHILD|WS_VISIBLE|WS_BORDER|ES_AUTOHSCROLL, <br>         NAME_X, NAME_Y, <br>         NAME_DX, NAME_DY, <br>         hwndApp, (HMENU)IDE_NAME, hInstApp, NULL); <br>   if( !hwndName ) <br>      return( FALSE ); <br>   Edit_LimitText(hwndName, MAX_FILENAME_SIZE - 1); <br> <br>   ShowWindow(hwndApp,cmdShow); <br> <br>   /* Add about dialog to system menu. <br>    */ <br>   LoadString(hInstApp, IDS_ABOUTMENUTEXT, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   AppendMenu(GetSystemMenu(hwndApp, FALSE), <br>      MF_STRING | MF_ENABLED, IDM_ABOUT, lpstrLoadStrBuf); <br> <br> <br>   /* The main message processing loop. Nothing special here. <br>   */ <br>   while (GetMessage(&amp;msg,NULL,0,0)) <br>   { <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg); <br>   } <br> <br>   return msg.wParam; <br>} <br> <br> <br>/* WndProc - Main window procedure function. <br> */ <br>LONG FAR PASCAL WndProc( <br>HWND hWnd, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>   switch (msg) <br>   { <br>      HANDLE_MSG(hWnd, WM_DESTROY, ReverseOnDestroy); <br> <br>      HANDLE_MSG(hWnd, WM_SYSCOMMAND, ReverseOnSysCommand); <br> <br>      case WM_SETFOCUS: <br>         SetFocus(hwndName); <br>         return 0; <br> <br>      HANDLE_MSG(hWnd, WM_COMMAND, ReverseOnCommand); <br>      case MM_WOM_DONE: <br>         /* This message indicates a waveform data block has <br>          * been played and can be freed. Clean up the <br>          * preparation done previously on the header. <br>          */ <br>         waveOutUnprepareHeader( (HWAVEOUT) wParam, <br>            (LPWAVEHDR) lParam, sizeof(WAVEHDR) ); <br> <br>         /* free all memory associated with the data block <br>          */ <br>         cleanup(); <br>         /* Close the waveform output device. <br>          */ <br>         waveOutClose( (HWAVEOUT) wParam ); <br>         hWaveOut = NULL; <br> <br>         /* Reenable both button controls. <br>          */ <br>         EnableWindow( hwndPlay, TRUE ); <br>         EnableWindow( hwndQuit, TRUE ); <br>         SetFocus(hwndName); <br> <br>         break; <br>   } <br>   return MyDefProc(hWnd,msg,wParam,lParam); <br>} <br> <br>void ReverseOnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) <br>{ <br>   /* Process messages sent by the child window controls. <br>    */ <br>   switch (id) <br>   { <br>      case IDE_NAME:    // filename edit control <br>         return; <br> <br>      case IDB_PLAY: // "Play" button <br>         if (codeNotify == BN_CLICKED) <br>            ReversePlay(); <br>         break; <br> <br>      case IDB_QUIT: // "Exit" button <br>         if (codeNotify == BN_CLICKED) <br>            PostQuitMessage(0); <br>         break; <br>   } <br>   FORWARD_WM_COMMAND(hwnd, id, hwndCtl, codeNotify, MyDefProc); <br>} <br> <br>void ReverseOnDestroy( <br>HWND hwnd) <br>{ <br>   if(lpstrLoadStrBuf) <br>      GlobalFreePtr(lpstrLoadStrBuf); <br>   if (hWaveOut) <br>   { <br>      waveOutReset(hWaveOut); <br>      waveOutUnprepareHeader(hWaveOut, lpWaveHdr, <br>         sizeof(WAVEHDR) ); <br>      cleanup(); <br>      waveOutClose(hWaveOut); <br>   } <br>   PostQuitMessage(0); <br>   FORWARD_WM_DESTROY(hwnd, MyDefProc); <br>} <br> <br>void ReverseOnSysCommand( <br>HWND hwnd, <br>UINT cmd, <br>int x, <br>int y) <br>{ <br>   switch (cmd) <br>   { <br>      case IDM_ABOUT: <br>         /* Show ABOUTBOX dialog box. <br>          */ <br>         DialogBox(hInstApp, "ABOUTBOX", hwnd, AppAbout); <br>         break; <br>   } <br>   FORWARD_WM_SYSCOMMAND(hwnd, cmd, x, y, MyDefProc); <br>} <br> <br> <br> <br>/* AppAbout -- Dialog procedure for ABOUTBOX dialog box. <br> */ <br>BOOL FAR PASCAL AppAbout( <br>HWND hDlg, <br>UINT msg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>   switch (msg) <br>   { <br>      case WM_COMMAND: <br>         if (GET_WM_COMMAND_ID(wParam, lParam) == IDOK <br>            || GET_WM_COMMAND_ID(wParam, lParam) <br>            == IDCANCEL) <br>            EndDialog(hDlg,TRUE); <br>         break; <br> <br>      case WM_INITDIALOG: <br>         return TRUE; <br>   } <br>   return FALSE; <br>} <br> <br> <br> <br>/* ReversePlay - Gets a filename from the edit control, then uses <br> * the multimedia file I/O services to read data from the requested <br> * WAVE file. If the file is a proper WAVE file, ReversePlay() calls <br> * the Interchange() function to reverse the order of the waveform <br> * samples in the file. It then plays the reversed waveform data. <br> * <br> * Note that ReversePlay() only handles a single waveform data block. <br> * If the requested WAVE file will not fit in a single data block, it <br> * will not be played. The size of a single data block depends on the <br> * amount of available system memory. <br> * <br> * Params: void <br> * <br> * Return: void <br> */ <br>void ReversePlay() <br>{ <br>   HMMIO          hmmio; <br>   MMCKINFO       mmckinfoParent; <br>   MMCKINFO       mmckinfoSubchunk; <br>   DWORD          dwFmtSize; <br>   char           szFileName[ MAX_FILENAME_SIZE ]; <br>   DWORD          dwResult; <br>   HANDLE         hFormat; <br>   WAVEFORMATEX   *pFormat; <br>   DWORD          dwDataSize; <br>   HPSTR          hpch1, hpch2; <br>   WORD           wBlockSize; <br>   HANDLE         hData    = NULL; <br> <br>   /* Get the filename from the edit control. <br>    */ <br>   if (!GetWindowText( hwndName, (LPSTR)szFileName, MAX_FILENAME_SIZE)) <br>   { <br>      LoadString(hInstApp, IDS_FAILEDTOGETFNAME, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br> <br>   /* Open the given file for reading using buffered I/O. <br>    */ <br>   if(!(hmmio = mmioOpen(szFileName, NULL, MMIO_READ | MMIO_ALLOCBUF))) <br>   { <br>      LoadString(hInstApp, IDS_FAILEDTOOPENFILE, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br> <br>   /* Locate a 'RIFF' chunk with a 'WAVE' form type <br>    * to make sure it's a WAVE file. <br>    */ <br>   mmckinfoParent.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>   if (mmioDescend(hmmio, &amp;mmckinfoParent, NULL, MMIO_FINDRIFF)) <br>   { <br>      LoadString(hInstApp, IDS_NOTAWAVEFILE, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Now, find the format chunk (form type 'fmt '). It should be <br>    * a subchunk of the 'RIFF' parent chunk. <br>    */ <br>   mmckinfoSubchunk.ckid = mmioFOURCC('f', 'm', 't', ' '); <br>   if (mmioDescend(hmmio, &amp;mmckinfoSubchunk, &amp;mmckinfoParent, <br>      MMIO_FINDCHUNK)) <br>   { <br>      LoadString(hInstApp, IDS_WAVEFILECORRUPT, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Get the size of the format chunk, allocate and lock memory for it. <br>    */ <br>   dwFmtSize = mmckinfoSubchunk.cksize; <br>   hFormat = LocalAlloc(LMEM_MOVEABLE, LOWORD(dwFmtSize)); <br>   if (!hFormat) <br>   { <br>      MessageBox(hwndApp, GetStringRes(IDS_NOMEM), <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br>   pFormat = (WAVEFORMATEX *) LocalLock(hFormat); <br>   if (!pFormat) <br>   { <br>      MessageBox(hwndApp, GetStringRes(IDS_NOMEM_LK), <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Read the format chunk. <br>    */ <br>   if (mmioRead(hmmio, (HPSTR) pFormat, dwFmtSize) != (LONG) dwFmtSize) <br>   { <br>      LoadString(hInstApp, IDS_FAILEDREADFMTCHNK, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      LocalUnlock( hFormat ); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Make sure it's a PCM file. <br>    */ <br>   if (pFormat-&gt;wFormatTag != WAVE_FORMAT_PCM) <br>   { <br>      LocalUnlock( hFormat ); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      LoadString(hInstApp, IDS_NOTAPCMFILE, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br> <br>   /* Make sure a waveform output device supports this format. <br>    */ <br>   #if (WINVER &gt;= 0x0400) <br>   if (waveOutOpen(&amp;hWaveOut, WAVE_MAPPER, pFormat, 0, 0L, <br>               WAVE_FORMAT_QUERY)) <br>        #else <br>   if (waveOutOpen(&amp;hWaveOut, WAVE_MAPPER, (LPWAVEFORMAT)pFormat, 0, 0L, <br>               WAVE_FORMAT_QUERY)) <br>        #endif <br>   { <br>      LocalUnlock( hFormat ); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      LoadString(hInstApp, IDS_CANTPLAYFORMAT, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br> <br>   /* Ascend out of the format subchunk. <br>    */ <br>   mmioAscend(hmmio, &amp;mmckinfoSubchunk, 0); <br> <br>   /* Find the data subchunk. <br>    */ <br>   mmckinfoSubchunk.ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>   if (mmioDescend(hmmio, &amp;mmckinfoSubchunk, &amp;mmckinfoParent, <br>      MMIO_FINDCHUNK)) <br>   { <br>      LoadString(hInstApp, IDS_NODATACHUNK, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      LocalUnlock( hFormat ); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Get the size of the data subchunk. <br>    */ <br>   dwDataSize = mmckinfoSubchunk.cksize; <br>   if (dwDataSize == 0L) <br>   { <br>      LoadString(hInstApp, IDS_CHUNKHASNODATA, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      LocalUnlock( hFormat ); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Open a waveform output device. <br>    */ <br>   #if (WINVER &gt;= 0x0400) <br>   if (waveOutOpen(&amp;hWaveOut, WAVE_MAPPER, <br>      pFormat, (UINT)hwndApp, 0L, CALLBACK_WINDOW)) <br>        #else <br>   if (waveOutOpen(&amp;hWaveOut, WAVE_MAPPER, <br>      (LPWAVEFORMAT)pFormat, (UINT)hwndApp, 0L, CALLBACK_WINDOW)) <br>        #endif <br>   { <br>      LoadString(hInstApp, IDS_FAILEDOPENDEVICE, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      LocalUnlock( hFormat ); <br>      LocalFree( hFormat ); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Save block alignment info for later use. <br>    */ <br>   wBlockSize = pFormat-&gt;nBlockAlign; <br> <br>   /* We're done with the format header, free it. <br>    */ <br>   LocalUnlock( hFormat ); <br>   LocalFree( hFormat ); <br> <br>   /* Allocate and lock memory for the waveform data. <br>    */ <br>   lpData = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, dwDataSize ); <br>   if (!lpData) <br>   { <br>      MessageBox(hwndApp, GetStringRes(IDS_NOMEM_DT), <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* Read the waveform data subchunk. <br>    */ <br>   if(mmioRead(hmmio, lpData, dwDataSize) != (LONG) dwDataSize) <br>   { <br>      LoadString(hInstApp, IDS_FAILEDREADCHUNK, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      GlobalFreePtr( lpData ); <br>      mmioClose(hmmio, 0); <br>      return; <br>   } <br> <br>   /* We're done with the file, close it. <br>    */ <br>   mmioClose(hmmio, 0); <br> <br>   /* Reverse the sound for playing. <br>    */ <br>   hpch1 = lpData; <br>   hpch2 = lpData + dwDataSize - 1; <br>   while (hpch1 &lt; hpch2) <br>   { <br>      Interchange( hpch1, hpch2, wBlockSize ); <br>      hpch1 += wBlockSize; <br>      hpch2 -= wBlockSize; <br>   } <br> <br>   /* Allocate a waveform data header. The WAVEHDR must be <br>    * globally allocated and locked. <br>    */ <br>   lpWaveHdr = (LPWAVEHDR)GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, <br>                  (DWORD) sizeof(WAVEHDR)); <br>   if (!lpWaveHdr) <br>   { <br>      GlobalFreePtr( lpData ); <br>      MessageBox(hwndApp, GetStringRes(IDS_NOMEM_HR), <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br> <br>   /* If you need instance data for a waveform data block, allocate some <br>    * memory and store the pointer in lpWaveHdr-&gt;dwUser, before the call <br>    * to waveOutPrepareHeader(). The code inside the #if 0 / #endif, and <br>    * the commented-out lpWaveHdr-&gt;dwUser = ... illustrate this. <br>    * Don't forget to free the instance memory when you're done with it, <br>    * or on error bailout. <br>    */ <br>   #if 0 <br>   lpYourData = GlobalAllocPtr(GMEM_MOVEABLE | GMEM_SHARE, sizeof(YOURDATA)); <br>   if (!lpYourData) <br>   { <br>      GlobalFreePtr( lpData ); <br>      GlobalFreePtr( lpWaveHdr ); <br>      MessageBox(hwndApp, GetStringRes(IDS_NOMEM_IS), <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br>   #endif <br>   /* Set up WAVEHDR structure and prepare it to be written to wave device. <br>    */ <br>   lpWaveHdr-&gt;lpData = lpData; <br>   lpWaveHdr-&gt;dwBufferLength = dwDataSize; <br>   lpWaveHdr-&gt;dwFlags = 0L; <br>   lpWaveHdr-&gt;dwLoops = 0L; <br>   // lpWaveHdr-&gt;dwUser = (DWORD) lpYourData; // save instance data ptr <br>   if(waveOutPrepareHeader(hWaveOut, lpWaveHdr, sizeof(WAVEHDR))) <br>   { <br>      cleanup(); <br>      LoadString(hInstApp, IDS_UNABLEPREPAREHDR, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br> <br>      return; <br>   } <br> <br>   /* Then the data block can be sent to the output device. <br>    */ <br>   dwResult = waveOutWrite(hWaveOut, lpWaveHdr, sizeof(WAVEHDR)); <br>   if (dwResult != 0) <br>   { <br>      waveOutUnprepareHeader( hWaveOut, lpWaveHdr, sizeof(WAVEHDR)); <br>      cleanup(); <br>      LoadString(hInstApp, IDS_FAILEDWRITEDEVICE, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      MessageBox(hwndApp, lpstrLoadStrBuf, <br>            NULL, MB_OK | MB_ICONEXCLAMATION); <br>      return; <br>   } <br> <br>   /* Disable input to the button controls. <br>    */ <br>   EnableWindow(hwndPlay, FALSE); <br>   EnableWindow(hwndQuit, FALSE); <br>} <br> <br>/* Interchange - Interchanges two samples at the given positions. <br> * <br> * Params:  hpchPos1 - Points to one sample. <br> *       hpchPos2 - Points to the other sample. <br> *       wLength  - The length of a sample in bytes. <br> * <br> * Return: void <br> */ <br>void Interchange( <br>HPSTR hpchPos1, <br>HPSTR hpchPos2, <br>WORD wLength) <br>{ <br>   WORD  wPlace; <br>   BYTE  bTemp; <br> <br>   for (wPlace = 0; wPlace &lt; wLength; wPlace++) <br>   { <br>      bTemp = hpchPos1[wPlace]; <br>      hpchPos1[wPlace] = hpchPos2[wPlace]; <br>      hpchPos2[wPlace] = bTemp; <br>   } <br>} <br> <br>VOID cleanup(void) <br>{ <br>   // if you add wave instance data, this is a good place to free it. <br>   GlobalFreePtr( lpWaveHdr ); <br>   GlobalFreePtr( lpData ); <br>} <br> <br> <br>/******************************************************************************\ <br>* <br>*  FUNCTION:    GetStringRes (int id INPUT ONLY) <br>* <br>*  COMMENTS:    Load the resource string with the ID given, and return a <br>*               pointer to it.  Notice that the buffer is common memory so <br>*               the string must be used before this call is made a second time. <br>* <br>\******************************************************************************/ <br> <br>LPTSTR   GetStringRes (int id) <br>{ <br>  static TCHAR buffer[MAX_PATH]; <br> <br>  buffer[0]=0; <br>  LoadString (GetModuleHandle (NULL), id, buffer, MAX_PATH); <br>  return buffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
