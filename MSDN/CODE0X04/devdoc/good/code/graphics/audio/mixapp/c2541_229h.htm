<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MIXAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2555"></a>MIXAPP.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  mixapp.c <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;stdarg.h&gt; <br> <br>#include "mixapp.h" <br> <br>#include "debug.h" <br> <br> <br>// <br>//  globals, no less <br>// <br>HINSTANCE   ghinst; <br>UINT        gfuAppOptions; <br> <br>TCHAR       gszNull[]           = TEXT(""); <br>TCHAR       gszCRLF[]           = TEXT("\r\n"); <br> <br>TCHAR       gszAppName[APP_MAX_APP_NAME_CHARS]; <br> <br> <br> <br> <br>// <br>// <br>// <br>PTABBEDLISTBOX      gptlbLines; <br>HMIXER              ghmx; <br> <br> <br> <br>BOOL                gfDisplayingControl     = FALSE; <br>DWORD               gdwControlID; <br>HWND                ghdlgControl; <br>MIXERLINE           gmxl; <br>MIXERCONTROL        gmxctrl; <br> <br> <br> <br>//==========================================================================; <br>// <br>//  Application helper functions <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void AppHourGlass <br>// <br>//  Description: <br>//      This function changes the cursor to that of the hour glass or <br>//      back to the previous cursor. <br>// <br>//      This function can be called recursively. <br>// <br>//  Arguments: <br>//      BOOL fHourGlass: TRUE if we need the hour glass.  FALSE if we need <br>//      the arrow back. <br>// <br>//  Return (void): <br>//      On return, the cursor will be what was requested. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNGLOBAL AppHourGlass <br>( <br>    BOOL                    fHourGlass <br>) <br>{ <br>    static HCURSOR  hcur; <br>    static UINT     uWaiting = 0; <br> <br>    if (fHourGlass) <br>    { <br>        if (!uWaiting) <br>        { <br>            hcur = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>            ShowCursor(TRUE); <br>        } <br> <br>        uWaiting++; <br>    } <br>    else <br>    { <br>        --uWaiting; <br> <br>        if (!uWaiting) <br>        { <br>            ShowCursor(FALSE); <br>            SetCursor(hcur); <br>        } <br>    } <br>} // AppHourGlass() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppMsgBox <br>// <br>//  Description: <br>//      This function displays a message for the application in a standard <br>//      message box. <br>// <br>//      Note that this function takes any valid argument list that can <br>//      be passed to wsprintf. Because of this, the application must <br>//      remember to cast near string pointers to FAR when built for Win 16. <br>//      You will get a nice GP fault if you do not cast them correctly. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for message box holding the <br>//      message. <br>// <br>//      UINT fuStyle: Style flags for MessageBox(). <br>// <br>//      PTSTR pszFormat: Format string used for wvsprintf(). <br>// <br>//  Return (int): <br>//      The return value is the result of MessageBox() function. <br>// <br>//  History: <br>//       2/13/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppMsgBox <br>( <br>    HWND                    hwnd, <br>    UINT                    fuStyle, <br>    PTSTR                  pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the message.. <br>    // <br>    va_start(va, pszFormat); <br>    wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    n = MessageBox(hwnd, ach, gszAppName, fuStyle); <br> <br>    return (n); <br>} // AppMsgBox() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppSetWindowText <br>// <br>//  Description: <br>//      This function formats a string and sets the specified window text <br>//      to the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window to receive the new text. <br>// <br>//      PTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (int): <br>//      The return value is the number of bytes that the resulting window <br>//      text was. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL AppSetWindowText <br>( <br>    HWND                    hwnd, <br>    PTSTR                  pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br>    int         n; <br> <br>    // <br>    //  format and display the string in the window... <br>    // <br>    va_start(va, pszFormat); <br>    n = wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    SetWindowText(hwnd, ach); <br> <br>    return (n); <br>} // AppSetWindowText() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  void MixAppDebugLog <br>// <br>//  Description: <br>//      This function logs information to the debugger if the Debug Log <br>//      option is set. You can then run DBWin (or something similar) <br>//      to redirect the output whereever you want. Very useful for debugging <br>//      ACM drivers. <br>// <br>//  Arguments: <br>//      PTSTR pszFormat: Pointer to any valid format for wsprintf. <br>// <br>//  Return (void): <br>//      None. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>void FNCGLOBAL MixAppDebugLog <br>( <br>    PTSTR                  pszFormat, <br>    ... <br>) <br>{ <br>    static  TCHAR   szDebugLogSeparator[] = TEXT("=============================================================================\r\n"); <br> <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_ERROR_CHARS]; <br> <br> <br>    // <br>    //  !!! UNICODE !!! <br>    // <br>    // <br>    if (0 != (APP_OPTF_DEBUGLOG &amp; gfuAppOptions)) <br>    { <br>        if (NULL == pszFormat) <br>        { <br>            OutputDebugString(szDebugLogSeparator); <br>            return; <br>        } <br> <br>        // <br>        //  format and display the string in a message box... <br>        // <br>        va_start(va, pszFormat); <br>        wvsprintf(ach, pszFormat, va); <br>        va_end(va); <br> <br>        OutputDebugString(ach); <br>    } <br>} // MixAppDebugLog() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int MEditPrintF <br>// <br>//  Description: <br>//      This function is used to print formatted text into a Multiline <br>//      Edit Control as if it were a standard console display. This is <br>//      a very easy way to display small amounts of text information <br>//      that can be scrolled and copied to the clip-board. <br>// <br>//  Arguments: <br>//      HWND hedit: Handle to a Multiline Edit control. <br>// <br>//      PTSTR pszFormat: Pointer to any valid format for wsprintf. If <br>//      this argument is NULL, then the Multiline Edit Control is cleared <br>//      of all text. <br>// <br>// <br>//  Return (int): <br>//      Returns the number of characters written into the edit control. <br>// <br>//  Notes: <br>//      The pszFormat string can contain combinations of escapes that <br>//      modify the default behaviour of this function. Escapes are single <br>//      character codes placed at the _beginning_ of the format string. <br>// <br>//      Current escapes defined are: <br>// <br>//      ~   :   Suppresses the default CR/LF added to the end of the <br>//              printed line. Since the most common use of this function <br>//              is to output a whole line of text with a CR/LF, that is <br>//              the default. <br>// <br>//      `   :   Suppresses logging to the debug terminal (regardless of <br>//              the global debug log options flag). <br>// <br>//  History: <br>//      05/16/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNCGLOBAL MEditPrintF <br>( <br>    HWND                    hedit, <br>    PTSTR                   pszFormat, <br>    ... <br>) <br>{ <br>    va_list     va; <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    int         n; <br>    BOOL        fCRLF; <br>    BOOL        fDebugLog; <br> <br>    // <br>    //  default the escapes <br>    // <br>    fCRLF     = TRUE; <br>    fDebugLog = (0 != (APP_OPTF_DEBUGLOG &amp; gfuAppOptions)); <br> <br> <br>    // <br>    //  if the pszFormat argument is NULL, then just clear all text in <br>    //  the edit control.. <br>    // <br>    if (NULL == pszFormat) <br>    { <br>        SetWindowText(hedit, gszNull); <br> <br>        if (fDebugLog) <br>            MixAppDebugLog(NULL); <br> <br>        return (0); <br>    } <br> <br>    // <br>    //  format and display the string in the window... first search for <br>    //  escapes to modify default behaviour. <br>    // <br>    for (;;) <br>    { <br>        switch (*pszFormat) <br>        { <br>            case '~': <br>                fCRLF = FALSE; <br>                pszFormat++; <br>                continue; <br> <br>            case '`': <br>                fDebugLog = FALSE; <br>                pszFormat++; <br>                continue; <br>        } <br> <br>        break; <br>    } <br> <br>    va_start(va, pszFormat); <br>    n = wvsprintf(ach, pszFormat, va); <br>    va_end(va); <br> <br>    Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1); <br>    Edit_ReplaceSel(hedit, ach); <br> <br>    if (fDebugLog) <br>        MixAppDebugLog(ach); <br> <br>    if (fCRLF) <br>    { <br>        Edit_SetSel(hedit, (WPARAM)-1, (LPARAM)-1); <br>        Edit_ReplaceSel(hedit, gszCRLF); <br> <br>        if (fDebugLog) <br>            MixAppDebugLog(gszCRLF); <br>    } <br> <br>    return (n); <br>} // MEditPrintF() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  HMIXER MixAppNewDevice <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>//      HWND hwnd: <br>// <br>//      HMIXER hmxCur: <br>// <br>//      UINT uMxId: <br>// <br>//  Return (HMIXER): <br>// <br>//  History: <br>//      09/25/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>HMIXER FNGLOBAL MixAppNewDevice <br>( <br>    HWND                    hwnd, <br>    HMIXER                  hmxCur, <br>    UINT                    uMxId <br>) <br>{ <br>    MMRESULT            mmr; <br>    HMIXER              hmx; <br>    MIXERCAPS           mxcaps; <br> <br> <br>    // <br>    // <br>    // <br>    mmr = mixerGetDevCaps(uMxId, &amp;mxcaps, sizeof(mxcaps)); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(NULL, MB_OK | MB_ICONEXCLAMATION, <br>                "mixerGetDevCaps() failed on uMxId=%u, mmr=%u!", <br>                uMxId, mmr); <br>        return (hmxCur); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    mmr = mixerOpen(&amp;hmx, uMxId, (DWORD)(UINT)hwnd, 0L, CALLBACK_WINDOW); <br>    if (MMSYSERR_NOERROR != mmr) <br>    { <br>        AppMsgBox(NULL, MB_OK | MB_ICONEXCLAMATION, <br>                "mixerOpen() failed on uMxId=%u, mmr=%u!", <br>                uMxId, mmr); <br>        return (hmxCur); <br>    } <br> <br> <br>    if (NULL != hmxCur) <br>    { <br>        mmr = mixerClose(hmxCur); <br>        if (MMSYSERR_NOERROR != mmr) <br>        { <br>            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                      "mixerClose() failed on hmx=%.04Xh, mmr=%u!", <br>                      hmxCur, mmr); <br>        } <br> <br>        hmxCur = NULL; <br>    } <br> <br> <br>    AppSetWindowText(hwnd, "Mixer Device: %s", (LPSTR)mxcaps.szPname); <br> <br>    return (hmx); <br>} // MixAppNewDevice() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MixAppDisplayDevCaps <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>//      HWND hedit: <br>// <br>//      UINT uMxId: <br>// <br>//      LPMIXERCAPS pmxcaps: <br>// <br>//  Return (BOOL): <br>// <br>//  History: <br>//      09/25/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MixAppDisplayDevCaps <br>( <br>    HWND                    hedit, <br>    UINT                    uMxId, <br>    LPMIXERCAPS             pmxcaps <br>) <br>{ <br>    static TCHAR    szDisplayTitle[]    = TEXT("[Mixer Device Capabilities]\r\n"); <br> <br>    SetWindowRedraw(hedit, FALSE); <br> <br>    // <br>    // <br>    // <br>    MEditPrintF(hedit, NULL); <br>    MEditPrintF(hedit, szDisplayTitle); <br> <br>    MEditPrintF(hedit, "%18s: %u", (LPTSTR)"Device Id", uMxId); <br> <br>    MEditPrintF(hedit, "%18s: %u", (LPTSTR)"Manufacturer Id", pmxcaps-&gt;wMid); <br>    MEditPrintF(hedit, "%18s: %u", (LPTSTR)"Product Id", pmxcaps-&gt;wPid); <br>    MEditPrintF(hedit, "%18s: %u.%.02u", (LPTSTR)"Driver Version", <br>                (pmxcaps-&gt;vDriverVersion &gt;&gt; 8), <br>                (pmxcaps-&gt;vDriverVersion &amp; 0x00FF)); <br>    MEditPrintF(hedit, "%18s: '%s'", (LPTSTR)"Device Name", (LPSTR)pmxcaps-&gt;szPname); <br>    MEditPrintF(hedit, "%18s: %.08lXh", (LPTSTR)"Support Flags", pmxcaps-&gt;fdwSupport); <br>    MEditPrintF(hedit, "%18s: %lu", (LPTSTR)"Destinations", pmxcaps-&gt;cDestinations); <br> <br>    SetWindowRedraw(hedit, TRUE); <br> <br>    return (TRUE); <br>} // MixAppDisplayDevCaps() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MixAppDlgProcDevice <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>//      HWND hwnd: <br>// <br>//      UINT uMsg: <br>// <br>//      WPARAM wParam: <br>// <br>//      LPARAM lParam: <br>// <br>//  Return (BOOL): <br>// <br>//  History: <br>//      09/25/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL CALLBACK MixAppDlgProcDevice <br>( <br>    HWND            hwnd, <br>    UINT            uMsg, <br>    WPARAM          wParam, <br>    LPARAM          lParam <br>) <br>{ <br>    UINT                cMixerDevs; <br>    UINT                u; <br>    UINT                uMxId; <br>    UINT                uId; <br>    UINT                uCmd; <br>    HWND                hcb; <br>    HWND                hedit; <br>    MIXERCAPS           mxcaps; <br> <br>    // <br>    // <br>    // <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            hedit = GetDlgItem(hwnd, IDD_MADEVICE_EDIT_CAPABILITIES); <br>            SetWindowFont(hedit, GetStockFont(SYSTEM_FIXED_FONT), FALSE); <br> <br>            SetWindowLong(hwnd, DWL_USER, lParam); <br> <br>            uMxId = (UINT)lParam; <br> <br>            // <br>            // <br>            // <br>            hcb = GetDlgItem(hwnd, IDD_MADEVICE_COMBO_DEVICE); <br> <br>            cMixerDevs = mixerGetNumDevs(); <br>            for (u = 0; u &lt; cMixerDevs; u++) <br>            { <br>                mixerGetDevCaps(u, &amp;mxcaps, sizeof(mxcaps)); <br>                ComboBox_AddString(hcb, mxcaps.szPname); <br> <br>                if (uMxId == u) <br>                { <br>                    hedit = GetDlgItem(hwnd, IDD_MADEVICE_EDIT_CAPABILITIES); <br>                    MixAppDisplayDevCaps(hedit, uMxId, &amp;mxcaps); <br>                } <br>            } <br> <br>            ComboBox_SetCurSel(hcb, uMxId); <br>            return (TRUE); <br> <br> <br>        case WM_COMMAND: <br>            uId = GET_WM_COMMAND_ID(wParam, lParam); <br> <br>            switch (uId) <br>            { <br>                case IDOK: <br>                    hcb   = GetDlgItem(hwnd, IDD_MADEVICE_COMBO_DEVICE); <br>                    uMxId = ComboBox_GetCurSel(hcb); <br>                    if (CB_ERR != uMxId) <br>                    { <br>                        EndDialog(hwnd, uMxId); <br>                        break; <br>                    } <br> <br>                    // -- fall through -- // <br> <br>                case IDCANCEL: <br>                    uMxId = (UINT)GetWindowLong(hwnd, DWL_USER); <br>                    EndDialog(hwnd, uMxId); <br>                    break; <br> <br> <br>                case IDD_MADEVICE_COMBO_DEVICE: <br>                    uCmd = GET_WM_COMMAND_CMD(wParam, lParam); <br>                    hcb  = GET_WM_COMMAND_HWND(wParam, lParam); <br>                    switch (uCmd) <br>                    { <br>                        case CBN_SELCHANGE: <br>                            uMxId = ComboBox_GetCurSel(hcb); <br>                            if (CB_ERR == uMxId) <br>                                break; <br> <br>                            mixerGetDevCaps(uMxId, &amp;mxcaps, sizeof(mxcaps)); <br> <br>                            hedit = GetDlgItem(hwnd, IDD_MADEVICE_EDIT_CAPABILITIES); <br>                            MixAppDisplayDevCaps(hedit, uMxId, &amp;mxcaps); <br>                            break; <br>                    } <br>            } <br>            return (TRUE); <br>    } <br> <br>    return (FALSE); <br>} // MixAppDlgProcDevice() <br> <br> <br> <br>//==========================================================================; <br>// <br>//  Main application window handling code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppInitMenuPopup <br>// <br>//  Description: <br>//      This function handles the WM_INITMENUPOPUP message. This message <br>//      is sent to the window owning the menu that is going to become <br>//      active. This gives an application the ability to modify the menu <br>//      before it is displayed (disable/add items, etc). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_INITMENUPOPUP <br>//      message. <br>// <br>//      HMENU hmenu: Handle to the menu that is to become active. <br>// <br>//      int nItem: Specifies the zero-based relative position of the menu <br>//      item that invoked the popup menu. <br>// <br>//      BOOL fSysMenu: Specifies whether the popup menu is a System menu <br>//      (TRUE) or it is not a System menu (FALSE). <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//  History: <br>//       1/ 2/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppInitMenuPopup <br>( <br>    HWND                    hwnd, <br>    HMENU                   hmenu, <br>    int                     nItem, <br>    BOOL                    fSysMenu <br>) <br>{ <br>    int                 n; <br>    BOOL                f; <br> <br>    DPF(1, "AppInitMenuPopup(hwnd=%Xh, hmenu=%Xh, nItem=%d, fSysMenu=%d)", <br>            hwnd, hmenu, nItem, fSysMenu); <br> <br>    // <br>    //  if the system menu is what got hit, succeed immediately... this <br>    //  application has no stuff in the system menu. <br>    // <br>    if (fSysMenu) <br>        return (0L); <br> <br>    // <br>    //  initialize the menu that is being 'popped up' <br>    // <br>    switch (nItem) <br>    { <br>        case APP_MENU_ITEM_FILE: <br>            f = (0 != mixerGetNumDevs()); <br>            EnableMenuItem(hmenu, IDM_FILE_MIXER_DEVICE, (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br> <br>            f = (0 != (gfuAppOptions &amp; APP_OPTF_DEBUGLOG)); <br>            CheckMenuItem(hmenu, IDM_FILE_DEBUG_LOG, (UINT)(f ? MF_CHECKED : MF_UNCHECKED)); <br>            break; <br> <br>        case APP_MENU_ITEM_VIEW: <br>            n = ListBox_GetCurSel(gptlbLines-&gt;hlb); <br>            f = (LB_ERR != n); <br> <br>            EnableMenuItem(hmenu, IDM_VIEW_LINE_INFO,  (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            EnableMenuItem(hmenu, IDM_VIEW_LINE_CONTROLS,  (UINT)(f ? MF_ENABLED : MF_GRAYED)); <br>            break; <br>    } <br> <br>    // <br>    //  we processed the message--return 0... <br>    // <br>    return (0L); <br>} // AppInitMenuPopup() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCommand <br>// <br>//  Description: <br>//      This function handles the WM_COMMAND message. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window receiving the WM_COMMAND message. <br>// <br>//      int nId: Control or menu item identifier. <br>// <br>//      HWND hwndCtl: Handle of control if the message is from a control. <br>//      This argument is NULL if the message was not generated by a control. <br>// <br>//      UINT uCode: Notification code. This argument is 1 if the message <br>//      was generated by an accelerator. If the message is from a menu, <br>//      this argument is 0. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppCommand <br>( <br>    HWND                    hwnd, <br>    int                     nId, <br>    HWND                    hwndCtl, <br>    UINT                    uCode <br>) <br>{ <br>    int                 n; <br>    UINT                uMxId; <br>    LRESULT             lr; <br> <br>    switch (nId) <br>    { <br>        case IDM_FILE_MIXER_DEVICE: <br>            mixerGetID((HMIXEROBJ)ghmx, &amp;uMxId, MIXER_OBJECTF_HMIXER); <br>            n = DialogBoxParam(ghinst, DLG_MIXAPP_DEVICE, hwnd, (DLGPROC)MixAppDlgProcDevice, uMxId); <br>            if ((UINT)n != uMxId) <br>            { <br>                uMxId = (UINT)n; <br>                ghmx  = MixAppNewDevice(hwnd, ghmx, uMxId); <br> <br>                MixAppRefreshLineList(hwnd, gptlbLines); <br>            } <br>            break; <br> <br>        case IDM_FILE_FONT: <br>            MixAppChooseFont(hwnd); <br>            break; <br> <br>        case IDM_FILE_DEBUG_LOG: <br>            gfuAppOptions ^= APP_OPTF_DEBUGLOG; <br>            break; <br> <br>        case IDM_FILE_ABOUT: <br>            DialogBox(ghinst, DLG_ABOUT, hwnd, (DLGPROC)AboutDlgProc); <br>            break; <br> <br>        case IDM_FILE_EXIT: <br>            FORWARD_WM_CLOSE(hwnd, SendMessage); <br>            break; <br> <br> <br>        case IDM_VIEW_LINE_INFO: <br>            n  = ListBox_GetCurSel(gptlbLines-&gt;hlb); <br>            if (LB_ERR == n) <br>                break; <br> <br>            lr = ListBox_GetItemData(gptlbLines-&gt;hlb, n); <br>            DialogBoxParam(ghinst, DLG_LINEINFO, hwnd, (DLGPROC)MixAppDlgProcLineInfo, lr); <br>            break; <br> <br>        case IDM_VIEW_LINE_CONTROLS: <br>            n  = ListBox_GetCurSel(gptlbLines-&gt;hlb); <br>            if (LB_ERR == n) <br>                break; <br> <br>            lr = ListBox_GetItemData(gptlbLines-&gt;hlb, n); <br>            DialogBoxParam(ghinst, DLG_LINECONTROLS, hwnd, (DLGPROC)MixAppDlgProcLineControls, lr); <br>            break; <br> <br> <br>        case IDM_UPDATE: <br>            MixAppRefreshLineList(hwnd, gptlbLines); <br>            break; <br> <br> <br>        case IDD_APP_LIST_LINES: <br>            switch (uCode) <br>            { <br>                case LBN_SELCHANGE: <br>                    break; <br> <br>                case LBN_DBLCLK: <br>                    n  = ListBox_GetCurSel(hwndCtl); <br>                    if (LB_ERR == n) <br>                        break; <br> <br>                    lr = ListBox_GetItemData(hwndCtl, n); <br>                    if (GetKeyState(VK_CONTROL) &lt; 0) <br>                    { <br>                        DialogBoxParam(ghinst, DLG_LINEINFO, hwnd, (DLGPROC)MixAppDlgProcLineInfo, lr); <br>                    } <br>                    else <br>                    { <br>                        DialogBoxParam(ghinst, DLG_LINECONTROLS, hwnd, (DLGPROC)MixAppDlgProcLineControls, lr); <br>                    } <br>                    break; <br>            } <br>            break; <br>    } <br> <br>    return (0L); <br>} // AppCommand() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppSize <br>// <br>//  Description: <br>//      This function handles the WM_SIZE message for the application's <br>//      window. This message is sent to the application window after the <br>//      size has changed (but before it is painted). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_SIZE message. <br>// <br>//      UINT fuSizeType: Specifies the type of resizing requested. This <br>//      argument is one of the following: SIZE_MAXIMIZED, SIZE_MINIMIZED, <br>//      SIZE_RESTORED, SIZE_MAXHIDE, or SIZE_MAXSHOW. <br>// <br>//      int nWidth: Width of the new client area for the window. <br>// <br>//      int nHeight: Height of the new client area for the window. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the application processes the message. <br>// <br>//  History: <br>//       2/ 5/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppSize <br>( <br>    HWND                    hwnd, <br>    UINT                    fuSizeType, <br>    int                     nWidth, <br>    int                     nHeight <br>) <br>{ <br>    RECT                rc; <br> <br>    DPF(1, "AppSize(hwnd=%Xh, fuSizeType=%u, nWidth=%d, nHeight=%d)", <br>            hwnd, fuSizeType, nWidth, nHeight); <br> <br>    // <br>    //  unless this application is the one being resized then don't waste <br>    //  time computing stuff that doesn't matter. this applies to being <br>    //  minimized also because this application does not have a custom <br>    //  minimized state. <br>    // <br>    if ((SIZE_RESTORED != fuSizeType) &amp;&amp; (SIZE_MAXIMIZED != fuSizeType)) <br>        return (0L); <br> <br> <br>    // <br>    //  size the devices listbox to be the total size of the client area-- <br>    //  inflate the rect by one so borders are not visible. note that <br>    //  we need to leave room at the top for the title text which is one <br>    //  line of text in height... <br>    // <br>    GetClientRect(hwnd, &amp;rc); <br>    InflateRect(&amp;rc, 1, 1); <br> <br> <br>    TlbMove(gptlbLines, &amp;rc, FALSE); <br> <br> <br>    // <br>    //  we processed the message.. <br>    // <br>    return (0L); <br>} // AppSize() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppPaint <br>// <br>//  Description: <br>// <br>// <br>//  Arguments: <br>//      HWND hwnd: <br>// <br>//  Return (LRESULT): <br>// <br>//  History: <br>//      05/11/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppPaint <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    PAINTSTRUCT         ps; <br> <br>    // <br>    // <br>    // <br>    BeginPaint(hwnd, &amp;ps); <br> <br>    TlbPaint(gptlbLines, hwnd, ps.hdc); <br> <br>    EndPaint(hwnd, &amp;ps); <br> <br>    // <br>    //  we processed the message <br>    // <br>    return (0L); <br>} // AppPaint() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppWndProc <br>// <br>//  Description: <br>//      This is the main application window procedure. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (LRESULT): <br>//      The return value depends on the message that is being processed. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT CALLBACK AppWndProc <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    LRESULT             lr; <br> <br>    switch (uMsg) <br>    { <br>        case WM_CREATE: <br>            lr = HANDLE_WM_CREATE(hwnd, wParam, lParam, AppCreate); <br>            return (lr); <br> <br>        case WM_INITMENUPOPUP: <br>            HANDLE_WM_INITMENUPOPUP(hwnd, wParam, lParam, AppInitMenuPopup); <br>            return (0L); <br> <br>        case WM_COMMAND: <br>            lr = HANDLE_WM_COMMAND(hwnd, wParam, lParam, AppCommand); <br>            return (lr); <br> <br>        case WM_SIZE: <br>            // <br>            //  handle what we want for sizing, and then always call the <br>            //  default handler... <br>            // <br>            HANDLE_WM_SIZE(hwnd, wParam, lParam, AppSize); <br>            break; <br> <br>        case WM_PAINT: <br>            HANDLE_WM_PAINT(hwnd, wParam, lParam, AppPaint); <br>            break; <br> <br>        case WM_QUERYENDSESSION: <br>            lr = HANDLE_WM_QUERYENDSESSION(hwnd, wParam, lParam, AppQueryEndSession); <br>            return (lr); <br> <br>        case WM_ENDSESSION: <br>            HANDLE_WM_ENDSESSION(hwnd, wParam, lParam, AppEndSession); <br>            return (0L); <br> <br>        case WM_CLOSE: <br>            HANDLE_WM_CLOSE(hwnd, wParam, lParam, AppClose); <br>            return (0L); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            return (0L); <br> <br> <br>        case MM_MIXM_LINE_CHANGE: <br>            lr = MixAppLineChange(hwnd, (HMIXER)wParam, lParam); <br>            return (lr); <br> <br>        case MM_MIXM_CONTROL_CHANGE: <br>            lr = MixAppControlChange(hwnd, (HMIXER)wParam, lParam); <br>            return (lr); <br>    } <br> <br>    return (DefWindowProc(hwnd, uMsg, wParam, lParam)); <br>} // AppWndProc() <br> <br> <br>//==========================================================================; <br>// <br>//  Main entry and message dispatching code <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int WinMain <br>// <br>//  Description: <br>//      This function is called by the system as the initial entry point <br>//      for a Windows application. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPSTR pszCmdLine: Points to null-terminated unparsed command line. </code></pre>
<p>
</p>
<pre><code>//      This string is strictly ANSI regardless of whether the application <br>//      is built for Unicode. To get the Unicode equivalent call the <br>//      GetCommandLine() function (Win 32 only). <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (int): <br>//      Returns result from WM_QUIT message (in wParam of MSG structure) if <br>//      the application is able to enter its message loop. Returns 0 if <br>//      the application is not able to enter its message loop. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int PASCAL WinMain <br>( <br>    HINSTANCE               hinst, <br>    HINSTANCE               hinstPrev, <br>    LPSTR                   pszCmdLine, <br>    int                     nCmdShow <br>) <br>{ <br>    int                 nResult; <br>    HWND                hwnd; <br>    MSG                 msg; <br>    HACCEL              haccl; <br> <br>    // * * * temp  bodge * * * <br>    { <br>      HKEY htemp; <br>      RegOpenKey(HKEY_LOCAL_MACHINE, "A Value That Does Not Exist", &amp;htemp); <br>    } <br>    // * * * * * * * * * * * * <br> <br>    // <br>    //  our documentation states that WinMain is supposed to return 0 if <br>    //  we do not enter our message loop--so assume the worst... <br>    // <br>    nResult = 0; <br> <br>    // <br>    //  make our instance handle global for convenience.. <br>    // <br>    ghinst = hinst; <br> <br>    // <br>    //  init some stuff, create window, etc.. note the explicit cast of <br>    //  pszCmdLine--this is to mute a warning (and an ugly ifdef) when <br>    //  compiling for Unicode. see AppInit() for more details. <br>    // <br>    hwnd = AppInit(hinst, hinstPrev, (LPTSTR)pszCmdLine, nCmdShow); <br>    if (hwnd) <br>    { <br>        haccl = LoadAccelerators(hinst, ACCEL_APP); <br> <br>        // <br>        //  dispatch messages <br>        // <br>        while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>            // <br>            //  do all the special stuff required for this application <br>            //  when dispatching messages.. <br>            // <br>            if (!TranslateAccelerator(hwnd, haccl, &amp;msg)) <br>            { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>        // <br>        //  return result of WM_QUIT message. <br>        // <br>        nResult = (int)msg.wParam; <br>    } <br> <br>    // <br>    //  shut things down, clean up, etc. <br>    // <br>    nResult = AppExit(hinst, nResult); <br> <br>    return (nResult); <br>} // WinMain() </code></pre>
<p>&nbsp;</p></body>
</HTML>
