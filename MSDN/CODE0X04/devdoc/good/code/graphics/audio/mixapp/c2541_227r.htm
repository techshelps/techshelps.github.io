<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAINIT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2547"></a>MAINIT.C</h2>
<pre><code>//==========================================================================; <br>// <br>//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY <br>//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE <br>//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR <br>//  PURPOSE. <br>// <br>//  Copyright 1993 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>//--------------------------------------------------------------------------; <br>// <br>//  mainit.c <br>// <br>//  Description: <br>// <br>// <br>//  History: <br>//       9/21/93 <br>// <br>//==========================================================================; <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include &lt;commdlg.h&gt; <br> <br>#include "mixapp.h" <br> <br>#include "debug.h" <br> <br> <br> <br>// <br>// <br>// <br>TCHAR       gszAppProfile[]     = TEXT("mixapp.ini"); <br> <br>TCHAR       gszSecConfig[]      = TEXT("Configuration"); <br> <br>TCHAR       gszKeyOptions[]     = TEXT("Options"); <br>TCHAR       gszFormatOptions[]  = TEXT("%u"); <br> <br>TCHAR       gszKeyWindow[]      = TEXT("Window"); <br>TCHAR       gszKeyFont[]        = TEXT("Font"); <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppProfileWriteBytes <br>// <br>//  Description: <br>//      This function writes a raw structure of bytes to the application's <br>//      ini section that can later be retrieved using AppProfileReadBytes. <br>//      This gives an application the ability to write any structure to <br>//      the ini file and restore it later--very useful. <br>// <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>// <br>//  Arguments: <br>//      PTSTR pszSection: Pointer to section for the stored data. <br>// <br>//      PTSTR pszKey: Pointer to key name for the stored data. <br>// <br>//      LPBYTE pbStruct: Pointer to the data to be saved. <br>// <br>//      UINT cbStruct: Count in bytes of the data to store. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if it fails. <br>// <br>//  History: <br>//       3/10/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileWriteBytes <br>( <br>    PTSTR                   pszSection, <br>    PTSTR                   pszKey, <br>    LPBYTE                  pbStruct, <br>    UINT                    cbStruct <br>) <br>{ <br>    static TCHAR achNibbleToChar[] = <br>    { <br>        '0', '1', '2', '3', '4', '5', '6', '7', <br>        '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', <br>    }; <br>    #define     NIBBLE2CHAR(x)      (achNibbleToChar[x]) <br> <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br> <br>    // <br>    //  if pbStruct is NULL, then erase the key from the ini file, otherwise <br>    //  format the raw bytes into a hex string and write that out... <br>    // <br>    fAllocated = FALSE; <br>    psz        = NULL; <br>    if (NULL != pbStruct) <br>    { <br>        // <br>        //  check if the quick buffer can be used for formatting the output <br>        //  text--if it cannot, then alloc space for it. note that space <br>        //  must be available for an ending checksum byte (2 bytes for high <br>        //  and low nibble) as well as a null terminator. <br>        // <br>        psz     = (LPTSTR)ach; <br>        cchTemp = cbStruct * 2 + 3; <br>        if (cchTemp &gt; SIZEOF(ach)) <br>        { <br>            psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>            if (NULL == psz) <br>                return (FALSE); <br> <br>            fAllocated = TRUE; <br>        } <br> <br>        // <br>        //  step through all bytes in the structure and convert it to <br>        //  a string of hex numbers... <br>        // <br>        bChecksum = 0; <br>        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>        { <br>            // <br>            //  grab the next byte and add into checksum... <br>            // <br>            bChecksum = (BYTE) (bChecksum + (b = *pbStruct)); <br> <br>            *pch++ = NIBBLE2CHAR((b &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>            *pch++ = NIBBLE2CHAR(b &amp; (BYTE)0x0F); <br>        } <br> <br>        // <br>        //  add the checksum byte to the end and null terminate the hex <br>        //  dumped string... <br>        // <br>        *pch++ = NIBBLE2CHAR((bChecksum &gt;&gt; (BYTE)4) &amp; (BYTE)0x0F); <br>        *pch++ = NIBBLE2CHAR(bChecksum &amp; (BYTE)0x0F); <br>        *pch   = '\0'; <br>    } <br> <br>    // <br>    //  write the string of hex bytes out to the ini file... <br>    // <br>    fReturn = WritePrivateProfileString(pszSection, pszKey, psz, gszAppProfile); <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>        GlobalFreePtr(psz); <br> <br>    return (fReturn); <br>} // AppProfileWriteBytes <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppProfileReadBytes <br>// <br>//  Description: <br>//      This function reads a previously stored structure of bytes from <br>//      the application's ini file. This data must have been written with <br>//      the AppProfileWriteBytes function--it is checksumed to keep bad <br>//      data from blowing up the application. <br>// <br>//      NOTE! Starting with Windows for Workgroups 3.1 there are two new <br>//      profile functions that provide the same functionality of this <br>//      function. Specifically, these functions are GetPrivateProfileStruct <br>//      and WritePrivateProfileStruct. These new functions are provided <br>//      by the Common Controls DLL. The prototypes are as follows: <br>// <br>//      BOOL GetPrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      BOOL WritePrivateProfileStruct <br>//      ( <br>//          LPSTR       szSection, <br>//          LPSTR       szKey, <br>//          LPBYTE      lpStruct, <br>//          UINT        uSizeStruct, <br>//          LPSTR       szFile <br>//      ); <br>// <br>//      If you are building an application that is for Window for Workgroups <br>//      or newer versions of Windows, you will probably want to use the <br>//      above functions. <br>// <br>//  Arguments: <br>//      PTSTR pszSection: Pointer to section that contains the data. <br>// <br>//      PTSTR pszKey: Pointer to key that contains the data. <br>// <br>//      LPBYTE pbStruct: Pointer to buffer to receive the data. <br>// <br>//      UINT cbStruct: Number of bytes expected. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if the function is successful. It is FALSE <br>//      if the function fails (bad checksum, missing key, etc). <br>// <br>//  History: <br>//       3/10/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL AppProfileReadBytes <br>( <br>    PTSTR                   pszSection, <br>    PTSTR                   pszKey, <br>    LPBYTE                  pbStruct, <br>    UINT                    cbStruct <br>) <br>{ <br>    // <br>    //  note that the following works for both upper and lower case, and <br>    //  will return valid values for garbage chars <br>    // <br>    #define CHAR2NIBBLE(ch) (BYTE)( ((ch) &gt;= '0' &amp;&amp; (ch) &lt;= '9') ?  \ <br>                                (BYTE)((ch) - '0') :                \ <br>                                ((BYTE)(10 + (ch) - 'A') &amp; (BYTE)0x0F) ) <br> <br>    TCHAR       ach[APP_MAX_STRING_RC_CHARS]; <br>    LPTSTR      psz; <br>    LPTSTR      pch; <br>    UINT        cchTemp; <br>    UINT        u; <br>    BOOL        fAllocated; <br>    BOOL        fReturn; <br>    BYTE        b; <br>    BYTE        bChecksum; <br>    TCHAR       ch; <br> <br>    // <br>    //  add one the the number of bytes needed to accomodate the checksum <br>    //  byte placed at the end by AppProfileWriteBytes... <br>    // <br>    cbStruct++; <br> <br>    // <br>    //  check if the quick buffer can be used for retrieving the input <br>    //  text--if it cannot, then alloc space for it. note that there must <br>    //  be space available for the null terminator (the +1 below). <br>    // <br>    fAllocated = FALSE; <br>    psz        = (LPTSTR)ach; <br>    cchTemp    = cbStruct * 2 + 1; <br>    if (cchTemp &gt; SIZEOF(ach)) <br>    { <br>        psz = (LPTSTR)GlobalAllocPtr(GHND, cchTemp * sizeof(TCHAR)); <br>        if (NULL == psz) <br>            return (FALSE); <br> <br>        fAllocated = TRUE; <br>    } <br> <br>    // <br>    //  read the hex string... if it is not the correct length, then assume <br>    //  error and return. <br>    // <br>    fReturn = FALSE; <br>    u = (UINT)GetPrivateProfileString(pszSection, pszKey, gszNull, <br>                                      psz, cchTemp, gszAppProfile); <br>    if ((cbStruct * 2) == u) <br>    { <br>        bChecksum = 0; <br>        for (pch = psz; 0 != cbStruct; cbStruct--, pbStruct++) <br>        { <br>            ch = *pch++; <br>            b  = (BYTE) (CHAR2NIBBLE(ch) &lt;&lt; (BYTE)4); <br>            ch = *pch++; <br>            b |= CHAR2NIBBLE(ch); <br> <br>            // <br>            //  if this is not the final byte (the checksum byte), then <br>            //  store it and accumulate checksum.. <br>            // <br>            if (cbStruct != 1) <br>                bChecksum = (BYTE) (bChecksum + (*pbStruct = b)); <br>        } <br> <br>        // <br>        //  check the last byte read against the checksum that we calculated <br>        //  if they are not equal then return error... <br>        // <br>        fReturn = (bChecksum == b); <br>    } <br> <br> <br>    // <br>    //  free the temporary buffer if one was allocated (lots of bytes!) <br>    // <br>    if (fAllocated) <br>        GlobalFreePtr(psz); <br> <br>    return (fReturn); <br>} // AppProfileReadBytes <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  DWORD AppGetWindowsVersion <br>// <br>//  Description: <br>//      This function returns the version of Windows that the application <br>//      is running on plus some platform information. <br>// <br>//  Arguments: <br>//      PTSTR pach: Options pointer to buffer to receive text string of <br>//      the Windows version and platform. <br>// <br>//  Return (LRESULT): <br>//      The return value will be the version and platform information of <br>//      the current operating system in the following format: <br>// <br>//      0xPPPPMMRR where: <br>// <br>//      MM      :   major version of Windows <br>//      RR      :   minor version (revision) of Windows <br>//      PPPP    :   the platform the application is running on which <br>//                  the HIWORD() is RESERVED except for the high bit: <br>//                      high bit is 0 = Windows NT <br>//                      high bit is 1 = Win32s/Windows 3.1 <br>// <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNLOCAL AppGetWindowsVersion <br>( <br>    PTSTR                   pszEnvironment, <br>    PTSTR                   pszPlatform <br>) <br>{ <br> <br>    BYTE    bVerWinMajor; <br>    BYTE    bVerWinMinor; <br>    UINT    uVerEnv; <br>    DWORD   dw; <br>    LRESULT lr; <br> <br>    dw = GetVersion(); <br> <br>    // <br>    //  massage the version information into something intelligent <br>    // <br>    // <br>    bVerWinMajor = LOBYTE(LOWORD(dw)); <br>    bVerWinMinor = HIBYTE(LOWORD(dw)); <br>    uVerEnv      = HIWORD(dw); <br>    lr = MAKELPARAM(((UINT)bVerWinMajor &lt;&lt; 8) | bVerWinMinor, uVerEnv); <br> <br>    // <br>    //  if caller wants the environment string version... <br>    // <br>    if (NULL != pszEnvironment) <br>    { <br>        static TCHAR    szFormatVersion[]   = TEXT("Win32 Version %u.%.2u"); <br> <br>        wsprintf(pszEnvironment, szFormatVersion, <br>                 bVerWinMajor, bVerWinMinor); <br>    } <br> <br>    // <br>    //  if caller wants the platform string version... <br>    // <br>    if (NULL != pszPlatform) <br>    { <br>        static TCHAR    szFormatPlatform[]  = TEXT("%s%u, %u Processor(s)"); <br>        static TCHAR    szProcessorIntel[]  = TEXT("Intel "); <br>        static TCHAR    szProcessorMIPS[]   = TEXT("MIPS R"); <br>        static TCHAR    szProcessorAlpha[]  = TEXT("DEC Alpha "); <br>        static TCHAR    szProcessorDunno[]  = TEXT("Dunno zYz"); <br> <br>        SYSTEM_INFO sysinfo; <br>        PTSTR       pszProcessor; <br> <br>        // <br>        //  this is absolutely silly. one would think that the dwOemId member <br>        //  would provide something useful like the processor class... but <br>        //  no, it doesn't--it is always 0. <br>        // <br>        GetSystemInfo(&amp;sysinfo); <br>        switch (sysinfo.dwProcessorType) <br>        { <br>            case PROCESSOR_INTEL_386: <br>            case PROCESSOR_INTEL_486: <br>                pszProcessor = szProcessorIntel; <br>                break; <br> <br>            case PROCESSOR_MIPS_R4000: <br>                pszProcessor = szProcessorMIPS; <br>                break; <br> <br>            case PROCESSOR_ALPHA_21064: <br>                pszProcessor = szProcessorAlpha; <br>                break; <br> <br>            default: <br>                pszProcessor = szProcessorDunno; <br>                break; <br>        } <br> <br>        // <br>        // <br>        // <br>        wsprintf(pszPlatform, szFormatPlatform, (LPSTR)pszProcessor, <br>                 sysinfo.dwProcessorType, sysinfo.dwNumberOfProcessors); <br>    } <br> <br>    // <br>    //  return the result <br>    // <br>    return (lr); <br>} // AppGetWindowsVersion() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  HFONT AppChooseFont <br>// <br>//  Description: <br>//      This function is a wrapper for the ChooseFont() common dialog. <br>//      The purpose of this function is to let the user choose a font that <br>//      looks good to them--regardless of how stupid it really looks. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to parent window for chooser dialog. <br>// <br>//      HFONT hfont: Handle to current font (default for chooser dialog). <br>// <br>//      PLOGFONT plf: Pointer to optional LOGFONT structure to receive a <br>//      copy of the LOGFONT information for the newly chosen font. <br>// <br>//  Return (HFONT): <br>//      The return value is the newly chosen font. If no new font was chosen <br>//      then the return value is NULL. <br>// <br>//--------------------------------------------------------------------------; <br> <br>HFONT FNGLOBAL AppChooseFont <br>( <br>    HWND                    hwnd, <br>    HFONT                   hfont, <br>    PLOGFONT                plf <br>) <br>{ <br>    LOGFONT             lf; <br>    CHOOSEFONT          cf; <br>    BOOL                f; <br>    HFONT               hfontNew; <br> <br>    // <br>    //  get the font info for the current font... <br>    // <br>    GetObject(hfont, sizeof(LOGFONT), (LPVOID)&amp;lf); <br> <br>    // <br>    //  fill in the choosefont structure <br>    // <br>    cf.lStructSize  = sizeof(CHOOSEFONT); <br>    cf.hwndOwner    = hwnd; <br>    cf.hDC          = NULL; <br>    cf.Flags        = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT; <br>    cf.lCustData    = 0; <br>    cf.lpfnHook     = NULL; <br>    cf.hInstance    = NULL; <br>    cf.nFontType    = SCREEN_FONTTYPE; <br>    cf.lpLogFont    = (LPLOGFONT)&amp;lf; <br> <br>    // <br>    //  splash a dialog into the user's face.. <br>    // <br>    hfontNew = NULL; <br>    f = ChooseFont(&amp;cf); <br>    if (f) <br>    { <br>        // <br>        //  create the new font.. <br>        // <br>        hfontNew = CreateFontIndirect(&amp;lf); <br>        if (NULL == hfontNew) <br>            return (NULL); <br> <br>        // <br>        //  copy the logfont structure if caller wants it <br>        // <br>        if (NULL != plf) <br>            *plf = lf; <br>    } <br> <br>    // <br>    //  return the new font (if one was chosen) <br>    // <br>    return (hfontNew); <br>} // AppChooseFont() <br> <br> <br>//==========================================================================; <br>// <br>//  Misc rarely used application dialogs and stuff... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AboutDlgProc <br>// <br>//  Description: <br>//      This dialog procedure is used for the ubiquitous about box. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window. <br>// <br>//      UINT uMsg: Message being sent to the window. <br>// <br>//      WPARAM wParam: Specific argument to message. <br>// <br>//      LPARAM lParam: Specific argument to message. <br>// <br>//  Return (BOOL): <br>//      The return value is specific to the message that was received. For <br>//      the most part, it is FALSE if this dialog procedure does not handle <br>//      a message. <br>// <br>//  History: <br>//       1/ 2/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL CALLBACK AboutDlgProc <br>( <br>    HWND                    hwnd, <br>    UINT                    uMsg, <br>    WPARAM                  wParam, <br>    LPARAM                  lParam <br>) <br>{ <br>    HWND                hwndT; <br>    PTSTR               pach; <br>    UINT                u; <br> <br>    switch (uMsg) <br>    { <br>        case WM_INITDIALOG: <br>            // <br>            //  display some OS version information <br>            // <br>            // <br>            pach = (PTSTR)LocalAlloc(LPTR, APP_MAX_STRING_RC_BYTES); <br>            if (NULL == pach) <br>                return (TRUE); <br> <br>            AppGetWindowsVersion(pach, NULL); <br>            hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_OS); <br>            SetWindowText(hwndT, pach); <br> <br>            AppGetWindowsVersion(NULL, pach); <br>            hwndT = GetDlgItem(hwnd, IDD_ABOUT_VERSION_PLATFORM); <br>            SetWindowText(hwndT, pach); <br>            LocalFree((HLOCAL)pach); <br>            return (TRUE); <br> <br>        case WM_COMMAND: <br>            u = GET_WM_COMMAND_ID(wParam, lParam); <br>            if ((IDOK == u) || (IDCANCEL == u)) <br>            { <br>                EndDialog(hwnd, (IDOK == u)); <br>            } <br>            break; <br>    } <br> <br>    return (FALSE); <br>} // AboutDlgProc() <br> <br> <br>//==========================================================================; <br>// <br>//  Initialization and exit code... <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MixAppChooseFont <br>// <br>//  Description: <br>//      This function lets the user choose a new font for the script window. <br>//      After a new font is chosen, the font structure is stored to the <br>//      .ini file so it can be restored on the next run of this application. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window. <br>// <br>//  Return (BOOL): <br>//      The return value is TRUE if a new font was chosen. It is FALSE if <br>//      the user canceled the operation. <br>// <br>//  History: <br>//       2/ 7/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNGLOBAL MixAppChooseFont <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    LOGFONT             lf; <br>    HWND                hlb; <br>    HFONT               hfont; <br>    HFONT               hfontNew; <br> <br> <br>    // <br>    //  get the current font and pass it to the choose font dialog <br>    // <br>    hlb   = GetDlgItem(hwnd, IDD_APP_LIST_LINES); <br>    hfont = GetWindowFont(hlb); <br> <br>    hfontNew = AppChooseFont(hwnd, hfont, &amp;lf); <br>    if (NULL == hfontNew) <br>        return (FALSE); <br> <br>    // <br>    //  select the new font into the script window and delete the old one <br>    // <br>    TlbSetFont(gptlbLines, hfontNew, TRUE); <br>    DeleteFont(hfont); <br> <br> <br>    // <br>    //  save the complete description of the chosen font so there can be <br>    //  no strangness in the font mapping next run. this is overkill, but <br>    //  it works... <br>    // <br>    AppProfileWriteBytes(gszSecConfig, gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br> <br>    return (TRUE); <br>} // MixAppChooseFont() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MixAppSettingsRestore <br>// <br>//  Description: <br>//      This function restores state information for the application. This <br>//      function is called just after the main window is created (it has <br>//      not been ShowWindow()'d). This function will generate the call <br>//      to ShowWindow before returning. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that has just been created but <br>//      not shown. <br>// <br>//      int nCmdShow: The state that the application window should show as. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//      05/11/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MixAppSettingsRestore <br>( <br>    HWND                    hwnd, <br>    int                     nCmdShow <br>) <br>{ <br>    WINDOWPLACEMENT     wp; <br>    HFONT               hfont; <br>    LOGFONT             lf; <br>    RECT                rc; <br>    RECT                rcWindow; <br>    POINT               pt; <br>    int                 n; <br>    BOOL                f; <br> <br> <br>    // <br>    //  restore the user's preferred font. <br>    // <br>    hfont = NULL; <br>    f = AppProfileReadBytes(gszSecConfig, gszKeyFont, (LPBYTE)&amp;lf, sizeof(lf)); <br>    if (f) <br>    { <br>        hfont = CreateFontIndirect(&amp;lf); <br>    } <br> <br>    if (NULL == hfont) <br>    { <br>        hfont = GetStockFont(SYSTEM_FONT); <br>    } <br> <br>    TlbSetFont(gptlbLines, hfont, TRUE); <br> <br> <br>    // <br>    //  grab the stored window position and size from the .ini file... <br>    //  there must be four arguments stored or the entry is considered <br>    //  invalid. <br>    // <br>    f = AppProfileReadBytes(gszSecConfig, gszKeyWindow, <br>                            (LPBYTE)&amp;rcWindow, sizeof(rcWindow)); <br>    if (f) <br>    { <br>        // <br>        //  to make sure the user can always get at the window, check to <br>        //  see if the midpoint of the caption is visible--if it is not, <br>        //  then default to the default position used when creating the <br>        //  window. <br>        // <br>        n = (rcWindow.right - rcWindow.left) / 2; <br>        pt.x = (n + rcWindow.left); <br> <br>        n = GetSystemMetrics(SM_CYCAPTION) / 2 + GetSystemMetrics(SM_CXFRAME); <br>        pt.y = (n + rcWindow.top); <br> <br>        GetWindowRect(GetDesktopWindow(), &amp;rc); <br>        if (PtInRect(&amp;rc, pt)) <br>        { <br>            // <br>            //  fill out the window placement structure--default the <br>            //  maximized and minimized states to default placement by <br>            //  getting its current placement. <br>            // <br>            wp.length = sizeof(wp); <br>            GetWindowPlacement(hwnd, &amp;wp); <br> <br>            wp.showCmd          = nCmdShow; <br>            wp.rcNormalPosition = rcWindow; <br> <br>            SetWindowPlacement(hwnd, &amp;wp); <br>            return (TRUE); <br>        } <br>    } <br> <br>    // <br>    //  show defaulted and succeed <br>    // <br>    ShowWindow(hwnd, nCmdShow); <br>    return (TRUE); <br>} // MixAppSettingsRestore() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL MixAppSettingsSave <br>// <br>//  Description: <br>//      This function saves the current state information for the application. <br>//      It is called just before the main window is closed (destroyed); or <br>//      as Windows is exiting (query end session). <br>// <br>//      Note that this function should not destroy any resources--it can <br>//      be called at any time to save a snapshot of the application state. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to main window that will be destroyed shortly. <br>// <br>//  Return (BOOL): <br>//      The return value is always TRUE. <br>// <br>//  History: <br>//      05/11/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>BOOL FNLOCAL MixAppSettingsSave <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    WINDOWPLACEMENT     wp; <br>    PRECT               prc; <br>    BOOL                f; <br> <br>    // <br>    //  save the current window placement--only store the size and location <br>    //  of the restored window. maximized and minimized states should <br>    //  remain defaulted on the next invocation of this application. <br>    // <br>    wp.length = sizeof(wp); <br>    f = GetWindowPlacement(hwnd, &amp;wp); <br>    if (f) <br>    { <br>        prc = &amp;wp.rcNormalPosition; <br> <br>        DPF(1, "WindowPlacement: show=%d, minX=%d, minY=%d, maxX=%d, maxY=%d", <br>             wp.showCmd, wp.ptMinPosition.x, wp.ptMinPosition.y, <br>             wp.ptMaxPosition.x, wp.ptMaxPosition.y); <br> <br>        DPF(1, "                 normX=%d, normY=%d, normW=%d, normH=%d", <br>             prc-&gt;left, prc-&gt;top, prc-&gt;right, prc-&gt;bottom); <br> <br>        // <br>        //  save the _bounding rectangle_ of the restored window state... <br>        // <br>        AppProfileWriteBytes(gszSecConfig, gszKeyWindow, (LPBYTE)prc, sizeof(*prc)); <br>    } <br> <br> <br>    // <br>    //  succeed <br>    // <br>    return (TRUE); <br>} // MixAppSettingsSave() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppCreate <br>// <br>//  Description: <br>//      This function is called to handle the WM_CREATE message for the <br>//      application's window. The application should finish the creation <br>//      of the window (create controls, allocate resources, etc). The <br>//      window has not been displayed (CreateWindow[Ex] has not returned). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to the window that is in the process of being <br>//      created. <br>// <br>//      LPCREATESTRUCT pcs: Pointer to a CREATESTRUCT that contains info <br>//      about the window being created. <br>// <br>//  Return (LRESULT): <br>//      The return value should be nonzero if the application wishes to <br>//      let the window finish being created. A return of zero tells <br>//      CreateWindow[Ex] to fail the creation of the window. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppCreate <br>( <br>    HWND                    hwnd, <br>    LPCREATESTRUCT          pcs <br>) <br>{ <br>    extern TCHAR       gszLineFormatTitle[]; <br> <br>    DPF(1, "AppCreate(hwnd=%Xh, cs.x=%d, cs.y=%d, cs.cx=%d, cs.cy=%d)", <br>            hwnd, pcs-&gt;x, pcs-&gt;y, pcs-&gt;cx, pcs-&gt;cy); <br> <br>    // <br>    //  create the driver selection listbox <br>    // <br>    gptlbLines = TlbCreate(hwnd, IDD_APP_LIST_LINES, NULL); <br>    if (NULL == gptlbLines) <br>        return (0L); <br> <br>    TlbSetTitleAndTabs(gptlbLines, gszLineFormatTitle, FALSE); <br> <br> <br>    // <br>    //  default to device id zero... a real app would allow configuration <br>    //  and set to previous selection. but this is not a real app. <br>    // <br>    ghmx = MixAppNewDevice(hwnd, NULL, 0); <br>    if (NULL == ghmx) <br>    { <br>        // <br>        //  must be having a very bad day.. <br>        // <br>        return (0L); <br>    } <br> <br> <br>    // <br>    // <br>    // <br>    MixAppRefreshLineList(hwnd, gptlbLines); <br> <br> <br>    // <br>    //  return nonzero to succeed the creation of the window <br>    // <br>    return (1L); <br>} // AppCreate() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppQueryEndSession <br>// <br>//  Description: <br>//      This function handles the WM_QUERYENDSESSION. This message is sent <br>//      by USER when ExitWindows has been called to end the Windows session. <br>//      This function can stop Windows from exiting if it is not convenient <br>//      for Windows to end. <br>// <br>//      Giving the user the option to save modified data before continueing <br>//      with the shutdown of Windows is a good idea. <br>// <br>//      Telling Windows to continue with the exit procedure does not <br>//      necessarily mean Windows will exit. All applications are queried <br>//      for shutdown approval. When the actual decision is made on whether <br>//      Windows will exit, WM_ENDSESSION will be sent with the result. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//  Return (LRESULT): <br>//      Returns zero to STOP Windows from exiting. Returns non-zero to <br>//      allows windows to shut down. <br>// <br>//  History: <br>//       2/ 9/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppQueryEndSession <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    DPF(1, "AppQueryEndSession(hwnd=%Xh)", hwnd); <br> <br>    // <br>    //  tell Windows to proceed with the shutdown process! <br>    // <br>    return (1L); <br>} // AppQueryEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppEndSession <br>// <br>//  Description: <br>//      This function is called to handle the WM_ENDSESSION message. This </code></pre>
<p>
</p>
<pre><code>//      message is generated after the application answers the <br>//      WM_QUERYENDSESSION message. The purpose of the WM_ENDSESSION <br>//      message is to tell the application if Windows will be exiting <br>//      (TRUE  == fEndSession) or the end session was canceled by an <br>//      application (FALSE == fEndSession). <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that received the message. <br>// <br>//      BOOL fEndSession: TRUE if Windows is exiting. FALSE if the end <br>//      session was canceled. <br>// <br>//  Return (LRESULT): <br>//      Returns zero if the message is processed. Note that an application <br>//      cannot halt the termination of Windows from this message--the <br>//      WM_QUERYENDSESSION is the only message that allows that behaviour. <br>//      If fEndSession is TRUE, Windows *WILL* exit--whether you like it <br>//      or not. <br>// <br>//  History: <br>//       2/ 9/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppEndSession <br>( <br>    HWND                    hwnd, <br>    BOOL                    fEndSession <br>) <br>{ <br>    DPF(1, "AppEndSession(hwnd=%Xh, fEndSession=%d)", hwnd, fEndSession); <br> <br>    // <br>    //  we processed the message, return zero.. <br>    // <br>    return (0L); <br>} // AppEndSession() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  LRESULT AppClose <br>// <br>//  Description: <br>//      This function handles the WM_CLOSE message for the application. <br>//      If the application should close, DestroyWindow() must be called <br>//      by this function. Otherwise the application will not close. <br>// <br>//  Arguments: <br>//      HWND hwnd: Handle to window that generated the WM_CLOSE message. <br>// <br>//  Return (LRESULT): <br>//      There return value is zero. The DestroyWindow function will have <br>//      been called if the application should actually close. <br>// <br>//  History: <br>//       2/ 6/93 <br>// <br>//--------------------------------------------------------------------------; <br> <br>LRESULT FNGLOBAL AppClose <br>( <br>    HWND                    hwnd <br>) <br>{ <br>    HWND                hlb; <br>    HFONT               hfont; <br>    MMRESULT            mmr; <br> <br> <br>    DPF(1, "AppClose(hwnd=%Xh)", hwnd); <br> <br>    // <br>    //  save any settings that should be saved on app termination... <br>    // <br>    MixAppSettingsSave(hwnd); <br> <br> <br>    // <br>    //  if the Shift key is held down during the close message, then just <br>    //  save the current state but don't destroy the window... this is <br>    //  useful if the user does not want to exit the app and rerun it <br>    //  to make sure the state is saved--just before the user does something <br>    //  that may crash Windows or something.. <br>    // <br>    if (GetKeyState(VK_SHIFT) &lt; 0) <br>    { <br>        return (0L); <br>    } <br> <br> <br>    // <br>    //  destroy the font we are using... before deleting the font, select <br>    //  the system font back into the script window so the font won't <br>    //  be 'in use' anymore. <br>    // <br>    hlb = GetDlgItem(hwnd, IDD_APP_LIST_LINES); <br> <br>    hfont = GetWindowFont(hlb); <br>    SetWindowFont(hlb, NULL, FALSE); <br>    DeleteFont(hfont); <br> <br> <br> <br>    // <br>    // <br>    // <br>    if (NULL != ghmx) <br>    { <br>        mmr = mixerClose(ghmx); <br>        if (MMSYSERR_NOERROR != mmr) <br>        { <br>            AppMsgBox(hwnd, MB_OK | MB_ICONEXCLAMATION, <br>                      "mixerClose() failed on hmx=%.04Xh, mmr=%u!", <br>                      ghmx, mmr); <br>        } <br> <br>        ghmx = NULL; <br>    } <br> <br> <br>    gptlbLines-&gt;hlb = NULL; <br>    TlbDestroy(gptlbLines); <br>    gptlbLines = NULL; <br> <br> <br>    // <br>    //  make the window close and terminate the application <br>    // <br>    DestroyWindow(hwnd); <br> <br>    return (0L); <br>} // AppClose() <br> <br> <br>//==========================================================================; <br>// <br>// <br>// <br>// <br>//==========================================================================; <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  BOOL AppInit <br>// <br>//  Description: <br>//      This function is called to initialize a new instance of the <br>//      application. We want to parse our command line, create our window, <br>//      allocate resources, etc. <br>// <br>//      The arguments passed to this function are exactly the same as <br>//      those passed to WinMain. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application. <br>// <br>//      HINSTANCE hinstPrev: Identifies the previous instance of the <br>//      application (NULL if first instance). For Win 32, this argument <br>//      is _always_ NULL. <br>// <br>//      LPTSTR pszCmdLine: Points to null-terminated unparsed command line. <br>//      If the application is compiled for Unicode, then this argument is <br>//      ignored. <br>// <br>//      int nCmdShow: How the main window for the application is to be <br>//      shown by default. <br>// <br>//  Return (HWND): <br>//      Returns the newly created handle to the applications main window. <br>//      This handle is NULL if something went wrong and tells the application <br>//      to exit immediately. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>HWND FNGLOBAL AppInit <br>( <br>    HINSTANCE               hinst, <br>    HINSTANCE               hinstPrev, <br>    LPTSTR                  pszCmdLine, <br>    int                     nCmdShow <br>) <br>{ <br>    LRESULT CALLBACK AppWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam); <br> <br>    HWND                hwnd; <br>    WNDCLASS            wc; <br>    UINT                cMixerDevs; <br> <br>    DPF(1, "AppInit(hinst=%Xh, hinstPrev=%Xh, pszCmdLine='%s', nCmdShow=%d)", <br>            hinst, hinstPrev, pszCmdLine, nCmdShow); <br> <br>    LoadString(hinst, IDS_APP_NAME, gszAppName, SIZEOF(gszAppName)); <br> <br> <br>    // <br>    //  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING <br>    // <br>    //      BEFORE calling any other mixer API's, we must call the <br>    //      mixerGetNumDevs() function to let the mixer thunk library <br>    //      dynamically link to all the mixer API's! <br>    // <br>    //  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING <br>    // <br>    cMixerDevs = mixerGetNumDevs(); <br>    if (0 == cMixerDevs) <br>    { <br>        AppMsgBox(NULL, MB_OK | MB_ICONEXCLAMATION, <br>                  "There are no mixer devices installed. This application is useless."); <br>        return (NULL); <br>    } <br> <br> <br>    // <br>    //  determine whether a new window class needs to be registered for <br>    //  this application. for Win 16, this only needs to be done for the <br>    //  first instance of the application created. for Win 32, this must <br>    //  be done for EVERY instance of the application. <br>    // <br>    if (NULL == hinstPrev) <br>    { <br>        wc.style         = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc   = (WNDPROC)AppWndProc; <br>        wc.cbClsExtra    = 0; <br>        wc.cbWndExtra    = 0; <br>        wc.hInstance     = hinst; <br>        wc.hIcon         = LoadIcon(hinst, ICON_APP); <br>        wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName  = MENU_APP; <br>        wc.lpszClassName = gszAppName; <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return (NULL); <br>    } <br> <br> <br>    // <br>    //  create the application's main window <br>    // <br>    //  style bits available: <br>    //      WS_EX_ACCEPTFILES   :  will receive WM_DROPFILES messages <br>    //      WS_EX_DLGMODALFRAME :  creates window with double border <br>    //      WS_EX_NOPARENTNOTIFY:  won't receive WM_PARENTNOTIFY messages <br>    //      WS_EX_TOPMOST       :  puts window in topmost space <br>    //      WS_EX_TRANSPARENT   :  a very bizarre style indeed (Win 16 only) <br>    // <br>    hwnd = CreateWindowEx(WS_EX_NOPARENTNOTIFY, <br>                          gszAppName, <br>                          gszAppName, <br>                          WS_OVERLAPPEDWINDOW, <br>                          APP_WINDOW_XOFFSET, <br>                          APP_WINDOW_YOFFSET, <br>                          APP_WINDOW_WIDTH, <br>                          APP_WINDOW_HEIGHT, <br>                          NULL, <br>                          NULL, <br>                          hinst, <br>                          NULL); <br> <br>    if (NULL == hwnd) <br>        return (NULL); <br> <br>#ifdef UNICODE <br>    // <br>    //  the application--which is different than the pszCmdLine argument <br>    //  passed through WinMain()... <br>    // <br>    //  so, skip over the command name to get to the argument string <br>    // <br>    pszCmdLine = GetCommandLine(); <br>    if (NULL != pszCmdLine) <br>    { <br>        while (('\0' != *pszCmdLine) &amp;&amp; (' ' != *pszCmdLine++)) <br>            ; <br>    } <br>#endif <br> <br> <br>    // <br>    // <br>    // <br>    // <br>    MixAppSettingsRestore(hwnd, nCmdShow); <br> <br> <br>    // <br>    //  finally, get the window displayed and return success <br>    // <br>    //  the ShowWindow call is made during MixAppInit <br>    // <br>//  ShowWindow(hwnd, nCmdShow); <br>//  UpdateWindow(hwnd); <br> <br>    return (hwnd); <br>} // AppInit() <br> <br> <br>//--------------------------------------------------------------------------; <br>// <br>//  int AppExit <br>// <br>//  Description: <br>//      This function is called just before the application exits from <br>//      WinMain. Its purpose is to clean up any resources that were allocated <br>//      for running the application: brushes, heaps, etc.. <br>// <br>//  Arguments: <br>//      HINSTANCE hinst: Identifies the current instance of the <br>//      application that is exiting. <br>// <br>//      int nResult: The result of the WM_QUIT message (in wParam of the <br>//      MSG structure. This argument will usually be 0 (even if the message <br>//      loop was never entered). <br>// <br>//  Return (int): <br>//      The return value is usually nResult--be we give this function the <br>//      opportunity to modify its value. <br>// <br>//  History: <br>//      11/ 8/92 <br>// <br>//--------------------------------------------------------------------------; <br> <br>int FNGLOBAL AppExit <br>( <br>    HINSTANCE               hinst, <br>    int                     nResult <br>) <br>{ <br>    DPF(1, "AppExit(hinst=%Xh, nResult=%d)", hinst, nResult); <br> <br>    // <br>    // <br>    // <br>    // <br> <br>    return (nResult); <br>} // AppExit() </code></pre>
<p>&nbsp;</p></body>
</HTML>
