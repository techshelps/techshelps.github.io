<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LOWPASS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2487"></a>LOWPASS.C</h2>
<pre><code>/*********************************************************************** <br> * lowpass.c - WinMain() and dialog procedures for LOWPASS, along with <br> * initialization and support code. <br> * <br> * LOWPASS is a sample application illustrating how to use the multimedia <br> * file I/O services to read and write RIFF files. <br> * <br> * LOWPASS runs a simple low-pass filter over an 8-bit-per-sample <br> * mono WAVE file.  Note that this program does not copy unknown chunks <br> * to the output file. <br> ************************************************************************ <br> * <br> *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br> *  ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED <br> *  TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR <br> *  A PARTICULAR PURPOSE. <br> * <br> *  Copyright 1993 - 1998 Microsoft Corporation. All Rights Reserved. <br> *********************************************************************** */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#include &lt;mmsystem.h&gt; <br>#include "lowpass.h" <br>#include "strings.h" <br> <br> <br>/* Globals <br> */ <br>char     gszAppName[] = "LowPass";  // for title bar, etc. <br>HINSTANCE   ghInst;           // app's instance handle <br>LPSTR    lpstrLoadStrBuf   = NULL; <br> <br> <br>/* DoLowPass - Gets the name of the input and output WAVE files from <br> *  the dialog box; reads waveform data from the input file, performs <br> *  a simple low-pass filter by averaging adjacent samples, and writes <br> *  the filtered waveform data to the output WAVE file. <br> * <br> * Params:  hWnd - Window handle for our dialog box. <br> * <br> * Returns: <br> */ <br>void DoLowPass( <br>HWND hWnd) <br>{ <br>   char         achInFile[200];  // name of input file <br>   char         achOutFile[200]; // name of output file <br>   HMMIO        hmmioIn = NULL;  // handle to open input WAVE file <br>   HMMIO        hmmioOut = NULL; // handle to open output WAVE file <br>   MMCKINFO       ckInRIFF;   // chunk info. for input RIFF chunk <br>   MMCKINFO       ckOutRIFF;  // chunk info. for output RIFF chunk <br>   MMCKINFO       ckIn;    // info. for a chunk in input file <br>   MMCKINFO       ckOut;      // info. for a chunk in output file <br>   PCMWAVEFORMAT  pcmWaveFormat; // contents of 'fmt' chunks <br>   MMIOINFO       mmioinfoIn; // current status of &lt;hmmioIn&gt; <br>   MMIOINFO       mmioinfoOut;   // current status of &lt;hmmioOut&gt; <br>   long         lSamples;  // number of samples to filter <br>   BYTE         abSamples[3]; // this, last, and before-last sample <br> <br>   /* Read filenames from dialog box fields. <br>    */ <br>   achInFile[0] = 0; <br>   GetDlgItemText(hWnd, ID_INPUTFILEEDIT, achInFile, sizeof(achInFile)); <br>   achOutFile[0] = 0; <br>   GetDlgItemText(hWnd, ID_OUTPUTFILEEDIT, achOutFile, sizeof(achOutFile)); <br> <br>   /* Open the input file for reading using buffered I/O. <br>    */ <br>   hmmioIn = mmioOpen(achInFile, NULL, MMIO_ALLOCBUF | MMIO_READ); <br>   if (hmmioIn == NULL) <br>      goto LOWPASS_ERROR_CANNOT_READ;  // cannot open WAVE file <br> <br>   /* Open the output file for writing using buffered I/O. Note that <br>    * if the file exists, the MMIO_CREATE flag causes it to be truncated <br>    * to zero length.  This means of course that if the SAME FILE is given <br>    * for both input and output, the input file will be truncated right here <br>    * and the program will then (surprise!) be unable to read it! <br>    */ <br>   hmmioOut = mmioOpen(achOutFile, NULL, <br>                  MMIO_ALLOCBUF | MMIO_WRITE | MMIO_CREATE); <br>   if (hmmioOut == NULL) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot open WAVE file <br> <br>   /* Descend the input file into the 'RIFF' chunk. <br>    */ <br>   if (mmioDescend(hmmioIn, &amp;ckInRIFF, NULL, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_READ;  // end-of-file, probably <br> <br>   /* Make sure the input file is a WAVE file. <br>    */ <br>   if ((ckInRIFF.ckid != FOURCC_RIFF) || <br>      (ckInRIFF.fccType != mmioFOURCC('W', 'A', 'V', 'E'))) <br>      goto LOWPASS_ERROR_BAD_FORMAT; <br> <br>   /* Search the input file for for the 'fmt ' chunk. <br>    */ <br>   ckIn.ckid = mmioFOURCC('f', 'm', 't', ' '); <br>   if (mmioDescend(hmmioIn, &amp;ckIn, &amp;ckInRIFF, MMIO_FINDCHUNK) != 0) <br>      goto LOWPASS_ERROR_BAD_FORMAT;   // no 'fmt ' chunk <br> <br>   /* Expect the 'fmt' chunk to be at least as large as &lt;pcmWaveFormat&gt;; <br>    * if there are extra parameters at the end, we'll ignore them <br>    */ <br>   if (ckIn.cksize &lt; (long) sizeof(pcmWaveFormat)) <br>      goto LOWPASS_ERROR_BAD_FORMAT;   // 'fmt ' chunk too small <br> <br>   /* Read the 'fmt ' chunk into &lt;pcmWaveFormat&gt;. <br>    */ <br>   if (mmioRead(hmmioIn, (HPSTR) &amp;pcmWaveFormat, <br>      (long) sizeof(pcmWaveFormat)) != (long) sizeof(pcmWaveFormat)) <br>      goto LOWPASS_ERROR_CANNOT_READ;  // truncated file, probably <br> <br>   /* Ascend the input file out of the 'fmt ' chunk. <br>    */ <br>   if (mmioAscend(hmmioIn, &amp;ckIn, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_READ;  // truncated file, probably <br> <br>   /* Make sure the input file is an 8-bit mono PCM WAVE file. <br>    */ <br>   if ((pcmWaveFormat.wf.wFormatTag != WAVE_FORMAT_PCM) || <br>      (pcmWaveFormat.wf.nChannels != 1) || <br>      (pcmWaveFormat.wBitsPerSample != 8)) <br>      goto LOWPASS_ERROR_BAD_FORMAT;   // bad input file format <br> <br>   /* Search the input file for for the 'data' chunk. <br>    */ <br>   ckIn.ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>   if (mmioDescend(hmmioIn, &amp;ckIn, &amp;ckInRIFF, MMIO_FINDCHUNK) != 0) <br>      goto LOWPASS_ERROR_BAD_FORMAT;   // no 'data' chunk <br> <br>   /* Create the output file RIFF chunk of form type 'WAVE'. <br>    */ <br>   ckOutRIFF.fccType = mmioFOURCC('W', 'A', 'V', 'E'); <br>   if (mmioCreateChunk(hmmioOut, &amp;ckOutRIFF, MMIO_CREATERIFF) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* We are now descended into the 'RIFF' chunk we just created. <br>    * Now create the 'fmt ' chunk. Since we know the size of this chunk, <br>    * specify it in the MMCKINFO structure so MMIO doesn't have to seek <br>    * back and set the chunk size after ascending from the chunk. <br>    */ <br>   ckOut.ckid = mmioFOURCC('f', 'm', 't', ' '); <br>   ckOut.cksize = sizeof(pcmWaveFormat);  // we know the size of this ck. <br>   if (mmioCreateChunk(hmmioOut, &amp;ckOut, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* Write the PCMWAVEFORMAT structure to the 'fmt ' chunk. <br>    */ <br>   if (mmioWrite(hmmioOut, (HPSTR) &amp;pcmWaveFormat, sizeof(pcmWaveFormat)) <br>      != sizeof(pcmWaveFormat)) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* Ascend out of the 'fmt ' chunk, back into the 'RIFF' chunk. <br>    */ <br>   if (mmioAscend(hmmioOut, &amp;ckOut, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* Create the 'data' chunk that holds the waveform samples. <br>    */ <br>   ckOut.ckid = mmioFOURCC('d', 'a', 't', 'a'); <br>   if (mmioCreateChunk(hmmioOut, &amp;ckOut, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* Read samples from the 'data' chunk of the input file, and write <br>    * samples to the 'data' chunk of the output file.  Each sample in <br>    * the output file equals the average of the corresponding sample <br>    * in the input file and the previous two samples from the input file. <br>    * Access the I/O buffers of &lt;hmmioIn&gt; and &lt;hmmioOut&gt; directly, <br>    * since this is faster than calling mmioRead() and mmioWrite() <br>    * for each sample. <br>    */ <br>   abSamples[0] = abSamples[1] = abSamples[2] = 128; <br> <br>   /* Begin direct access of the I/O buffers. <br>    */ <br>   if (mmioGetInfo(hmmioIn, &amp;mmioinfoIn, 0) != 0) <br>      goto LOWPASS_ERROR_UNKNOWN; <br>   if (mmioGetInfo(hmmioOut, &amp;mmioinfoOut, 0) != 0) <br>      goto LOWPASS_ERROR_UNKNOWN; <br> <br>   /* For each input sample, compute and write the output sample. <br>    */ <br>   for (lSamples = ckIn.cksize; lSamples &gt; 0; lSamples--) <br>   { <br>      /* If we are at the end of the input file I/O buffer, fill it. <br>       * Test to see that we don't hit end of file while (lSamples &gt; 0). <br>       */ <br>      if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) <br>      { <br>         if (mmioAdvance(hmmioIn, &amp;mmioinfoIn, MMIO_READ) != 0) <br>            goto LOWPASS_ERROR_CANNOT_READ; <br> <br>         if (mmioinfoIn.pchNext == mmioinfoIn.pchEndRead) <br>            goto LOWPASS_ERROR_CANNOT_READ; <br>      } <br> <br>      /* If we are the end of the output file I/O buffer, flush it. <br>       */ <br>      if (mmioinfoOut.pchNext == mmioinfoOut.pchEndWrite) <br>      { <br>         mmioinfoOut.dwFlags |= MMIO_DIRTY; <br>         if (mmioAdvance(hmmioOut, &amp;mmioinfoOut, MMIO_WRITE) != 0) <br>            goto LOWPASS_ERROR_CANNOT_WRITE; <br>      } <br> <br>      /* Keep track of the last 3 samples so we can average. <br>       */ <br>      abSamples[2] = abSamples[1];  // next-to-last sample <br>      abSamples[1] = abSamples[0];  // last sample <br>      abSamples[0] = *(mmioinfoIn.pchNext)++; // current sample <br> <br>      /* The output file sample is the average of the last <br>       * 3 input file samples. <br>       */ <br>      *(mmioinfoOut.pchNext)++ = (BYTE) (((int) abSamples[0] <br>         + (int) abSamples[1] + (int) abSamples[2]) / 3); <br>   } <br> <br>   /* We are through processing samples, end direct access of <br>    * the I/O buffers. Set the MMIO_DIRTY flag for the output buffer <br>    * to flush it. <br>    */ <br>   if (mmioSetInfo(hmmioIn, &amp;mmioinfoIn, 0) != 0) <br>      goto LOWPASS_ERROR_UNKNOWN; <br>   mmioinfoOut.dwFlags |= MMIO_DIRTY; <br>   if (mmioSetInfo(hmmioOut, &amp;mmioinfoOut, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot flush, probably <br> <br>   /* Ascend the output file out of the 'data' chunk -- this will cause <br>    * the chunk size of the 'data' chunk to be written. <br>    */ <br>   if (mmioAscend(hmmioOut, &amp;ckOut, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* Ascend the output file out of the 'RIFF' chunk -- this will cause <br>    * the chunk size of the 'RIFF' chunk to be written. <br>    */ <br>   if (mmioAscend(hmmioOut, &amp;ckOutRIFF, 0) != 0) <br>      goto LOWPASS_ERROR_CANNOT_WRITE; // cannot write file, probably <br> <br>   /* We are done -- files are closed below. <br>    */ <br>   goto EXIT_FUNCTION; <br> <br>LOWPASS_ERROR_BAD_FORMAT: <br> <br>   LoadString(ghInst, IDS_MUSTBEPCMWAVE, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   MessageBox(hWnd, lpstrLoadStrBuf, <br>         gszAppName, MB_OK | MB_ICONEXCLAMATION); <br>   goto EXIT_FUNCTION; <br> <br>LOWPASS_ERROR_CANNOT_READ: <br> <br>   LoadString(ghInst, IDS_CANTREADINPUTWAV, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   MessageBox(hWnd, lpstrLoadStrBuf, <br>         gszAppName, MB_OK | MB_ICONEXCLAMATION); <br>   goto EXIT_FUNCTION; <br> <br>LOWPASS_ERROR_CANNOT_WRITE: <br> <br>   LoadString(ghInst, IDS_CANTWRITEOUTPUT, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   MessageBox(hWnd, lpstrLoadStrBuf, <br>         gszAppName, MB_OK | MB_ICONEXCLAMATION); <br>   goto EXIT_FUNCTION; <br> <br>LOWPASS_ERROR_UNKNOWN: <br> <br>   LoadString(ghInst, IDS_UNKOWNERROR, lpstrLoadStrBuf, <br>      LOADSTRBUFSIZE); <br>   MessageBox(hWnd, lpstrLoadStrBuf, <br>         gszAppName, MB_OK | MB_ICONEXCLAMATION); <br>   goto EXIT_FUNCTION; <br> <br>EXIT_FUNCTION: <br> <br>   /* Close the files (unless they weren't opened successfully). <br>    */ <br>   if (hmmioIn != NULL) <br>      mmioClose(hmmioIn, 0); <br>   if (hmmioOut != NULL) <br>      mmioClose(hmmioOut, 0); <br>} <br> <br> <br>/* WinMain - Entry point for LowPass. <br> */ <br>int PASCAL WinMain( <br>HINSTANCE hInst, <br>HINSTANCE hPrev, <br>LPSTR lpszCmdLine, <br>int iCmdShow) <br>{ <br>   // Keep string memory out of WIN16 DS. <br>   lpstrLoadStrBuf = GlobalAllocPtr(GMEM_MOVEABLE, LOADSTRBUFSIZE); <br>   if(lpstrLoadStrBuf == NULL) <br>   { <br>      // don't use LoadString here; it fails when memory is low <br>      MessageBox(NULL, "No memory left.", <br>            NULL, MB_OK | MB_ICONHAND | MB_SYSTEMMODAL); <br>      return FALSE; <br>   } <br>   /* Save instance handle for dialog boxes. <br>    */ <br>   ghInst = hInst; <br> <br>   /* Display our dialog box. <br>    */ <br>   DialogBox(ghInst, "LOWPASSBOX", NULL, LowPassDlgProc); <br>   if(lpstrLoadStrBuf) <br>      GlobalFreePtr(lpstrLoadStrBuf); <br>   return TRUE; <br>} <br> <br> <br>/* AboutDlgProc - Dialog procedure function for ABOUTBOX dialog box. <br> */ <br>BOOL FAR PASCAL AboutDlgProc( <br>HWND hWnd, <br>UINT wMsg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>   switch (wMsg) <br>   { <br>   case WM_INITDIALOG: <br>      return TRUE; <br> <br>   case WM_COMMAND: <br>      if (wParam == IDOK || wParam == IDCANCEL) <br>         EndDialog(hWnd, TRUE); <br>      break; <br>   } <br>   return FALSE; <br>} <br> <br> <br>/* LowPassDlgProc - Dialog procedure function for LOWPASSBOX dialog box. <br> */ <br>BOOL WINAPI LowPassDlgProc( <br>HWND hWnd, <br>UINT wMsg, <br>WPARAM wParam, <br>LPARAM lParam) <br>{ <br>   HMENU hmenuSystem;   // system menu <br>   HCURSOR  ghcurSave;  // previous cursor <br> <br>   switch (wMsg) <br>   { <br>   case WM_INITDIALOG: <br>      /* Append "About" menu item to system menu. <br>       */ <br>      hmenuSystem = GetSystemMenu(hWnd, FALSE); <br>      AppendMenu(hmenuSystem, MF_SEPARATOR, 0, NULL); <br>      LoadString(ghInst, IDS_ABOUTMENUCAPTION, lpstrLoadStrBuf, <br>         LOADSTRBUFSIZE); <br>      AppendMenu(hmenuSystem, MF_STRING, IDM_ABOUT, <br>         lpstrLoadStrBuf); <br>      return TRUE; <br> <br>   case WM_SYSCOMMAND: <br>      switch (wParam)   // WIN16 and 32 have same message packing <br>      { <br>         case IDM_ABOUT: <br>            /* Display "About" dialog box. <br>             */ <br>            DialogBox(ghInst, "ABOUTBOX", hWnd, AboutDlgProc); <br>            break; <br>      } <br>      break; <br> <br>   case WM_COMMAND: <br>      switch (wParam) <br>      { <br>         case IDOK:  // "Begin" <br>            /* Set "busy" cursor, filter input file, restore cursor. <br>             */ <br>            ghcurSave = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>            DoLowPass(hWnd); <br>            SetCursor(ghcurSave); <br>            break; <br> <br>         case IDCANCEL: // "Done" <br>            EndDialog(hWnd, TRUE); <br>            break; <br>      } <br>      break; <br>   } <br>   return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
